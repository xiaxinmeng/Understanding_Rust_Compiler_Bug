{"sha": "c3284718808ca6da39d16507f5d29c34e2795cc7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzMyODQ3MTg4MDhjYTZkYTM5ZDE2NTA3ZjVkMjljMzRlMjc5NWNjNw==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2013-09-28T08:42:34Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2013-09-28T08:42:34Z"}, "message": "alloc-pool.c, [...]: Add missing whitespace before \"(\".\n\ngcc/\n\t* alloc-pool.c, asan.c, auto-inc-dec.c, basic-block.h, bb-reorder.c,\n\tbitmap.c, bitmap.h, bt-load.c, builtins.c, calls.c, cfgcleanup.c,\n\tcfgexpand.c, cfghooks.c, cfgloop.c, cfgloopmanip.c, cfgrtl.c, cgraph.c,\n\tcgraph.h, cgraphbuild.c, cgraphclones.c, cgraphunit.c, collect2.c,\n\tcombine-stack-adj.c, combine.c, compare-elim.c, context.c, context.h,\n\tcprop.c, cse.c, cselib.c, dbxout.c, dce.c, defaults.h, df-core.c,\n\tdf-problems.c, df-scan.c, df.h, diagnostic.c, double-int.c, dse.c,\n\tdumpfile.c, dwarf2asm.c, dwarf2cfi.c, dwarf2out.c, emit-rtl.c,\n\terrors.c, except.c, expmed.c, expr.c, file-find.c, final.c,\n\tfixed-value.c, fold-const.c, function.c, fwprop.c, gcc-ar.c, gcc.c,\n\tgcov-io.c, gcov-io.h, gcov.c, gcse.c, genattr-common.c, genattr.c,\n\tgenattrtab.c, genautomata.c, genconfig.c, genemit.c, genextract.c,\n\tgenflags.c, gengenrtl.c, gengtype-state.c, gengtype.c, genmodes.c,\n\tgenopinit.c, genoutput.c, genpeep.c, genpreds.c, genrecog.c,\n\tgensupport.c, ggc-common.c, ggc-page.c, gimple-fold.c, gimple-low.c,\n\tgimple-pretty-print.c, gimple-ssa-strength-reduction.c, gimple.c,\n\tgimple.h, godump.c, graphite-clast-to-gimple.c,\n\tgraphite-optimize-isl.c, graphite-poly.h, graphite-sese-to-poly.c,\n\tgraphite.c, haifa-sched.c, hash-table.c, hash-table.h, hwint.c,\n\thwint.h, ifcvt.c, incpath.c, init-regs.c, input.h, intl.c, intl.h,\n\tipa-cp.c, ipa-devirt.c, ipa-inline-analysis.c, ipa-inline.c,\n\tipa-profile.c, ipa-pure-const.c, ipa-reference.c, ipa-split.c,\n\tipa-utils.c, ipa.c, ira-build.c, ira.c, jump.c, loop-doloop.c,\n\tloop-init.c, loop-invariant.c, loop-iv.c, lower-subreg.c, lto-cgraph.c,\n\tlto-streamer-in.c, lto-streamer-out.c, lto-wrapper.c, mcf.c,\n\tmode-switching.c, modulo-sched.c, omp-low.c, optabs.c, opts.c,\n\tpass_manager.h, passes.c, plugin.c, postreload-gcse.c, postreload.c,\n\tpredict.c, prefix.c, pretty-print.c, print-rtl.c, print-tree.c,\n\tprofile.c, read-md.c, real.c, real.h, recog.c, ree.c, reg-stack.c,\n\tregcprop.c, reginfo.c, regmove.c, regrename.c, regs.h, regstat.c,\n\treload1.c, reorg.c, rtl.c, rtl.h, rtlanal.c, sbitmap.c, sched-rgn.c,\n\tsdbout.c, sel-sched-ir.c, sel-sched.c, sparseset.c, stack-ptr-mod.c,\n\tstatistics.c, stmt.c, stor-layout.c, store-motion.c, streamer-hooks.h,\n\tsystem.h, target-hooks-macros.h, targhooks.c, targhooks.h, toplev.c,\n\ttracer.c, trans-mem.c, tree-browser.c, tree-call-cdce.c, tree-cfg.c,\n\ttree-cfgcleanup.c, tree-complex.c, tree-data-ref.c, tree-data-ref.h,\n\ttree-eh.c, tree-emutls.c, tree-flow.h, tree-if-conv.c, tree-into-ssa.c,\n\ttree-iterator.c, tree-loop-distribution.c, tree-mudflap.c,\n\ttree-nested.c, tree-nomudflap.c, tree-nrv.c, tree-object-size.c,\n\ttree-optimize.c, tree-pass.h, tree-pretty-print.c, tree-profile.c,\n\ttree-scalar-evolution.c, tree-sra.c, tree-ssa-ccp.c,\n\ttree-ssa-coalesce.c, tree-ssa-copy.c, tree-ssa-copyrename.c,\n\ttree-ssa-dce.c, tree-ssa-dom.c, tree-ssa-dse.c, tree-ssa-forwprop.c,\n\ttree-ssa-ifcombine.c, tree-ssa-live.c, tree-ssa-loop-ch.c,\n\ttree-ssa-loop-im.c, tree-ssa-loop-ivopts.c, tree-ssa-loop-prefetch.c,\n\ttree-ssa-loop.c, tree-ssa-math-opts.c, tree-ssa-operands.c,\n\ttree-ssa-phiopt.c, tree-ssa-phiprop.c, tree-ssa-pre.c,\n\ttree-ssa-reassoc.c, tree-ssa-sink.c, tree-ssa-strlen.c,\n\ttree-ssa-structalias.c, tree-ssa-threadedge.c, tree-ssa-threadupdate.c,\n\ttree-ssa-uncprop.c, tree-ssa-uninit.c, tree-ssa.c, tree-ssanames.c,\n\ttree-stdarg.c, tree-switch-conversion.c, tree-tailcall.c,\n\ttree-vect-data-refs.c, tree-vect-generic.c, tree-vect-loop-manip.c,\n\ttree-vect-stmts.c, tree-vectorizer.c, tree-vectorizer.h, tree-vrp.c,\n\ttree.c, tree.h, tsan.c, tsystem.h, value-prof.c, var-tracking.c,\n\tvarasm.c, vec.h, vmsdbgout.c, vtable-verify.c, web.c: Add missing\n\twhitespace before \"(\".\n\nFrom-SVN: r203004", "tree": {"sha": "d508fc7773e01b720c3929468a0618058edbf8f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d508fc7773e01b720c3929468a0618058edbf8f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c3284718808ca6da39d16507f5d29c34e2795cc7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3284718808ca6da39d16507f5d29c34e2795cc7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3284718808ca6da39d16507f5d29c34e2795cc7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3284718808ca6da39d16507f5d29c34e2795cc7/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c6285bd7bbc2823f6146a30fe06a8b6b871a06d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6285bd7bbc2823f6146a30fe06a8b6b871a06d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6285bd7bbc2823f6146a30fe06a8b6b871a06d0"}], "stats": {"total": 3141, "additions": 1612, "deletions": 1529}, "files": [{"sha": "1e9839a8eb0994c348aaceadebfb3af76083d005", "filename": "gcc/ChangeLog", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -1,3 +1,62 @@\n+2013-09-28  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* alloc-pool.c, asan.c, auto-inc-dec.c, basic-block.h, bb-reorder.c,\n+\tbitmap.c, bitmap.h, bt-load.c, builtins.c, calls.c, cfgcleanup.c,\n+\tcfgexpand.c, cfghooks.c, cfgloop.c, cfgloopmanip.c, cfgrtl.c, cgraph.c,\n+\tcgraph.h, cgraphbuild.c, cgraphclones.c, cgraphunit.c, collect2.c,\n+\tcombine-stack-adj.c, combine.c, compare-elim.c, context.c, context.h,\n+\tcprop.c, cse.c, cselib.c, dbxout.c, dce.c, defaults.h, df-core.c,\n+\tdf-problems.c, df-scan.c, df.h, diagnostic.c, double-int.c, dse.c,\n+\tdumpfile.c, dwarf2asm.c, dwarf2cfi.c, dwarf2out.c, emit-rtl.c,\n+\terrors.c, except.c, expmed.c, expr.c, file-find.c, final.c,\n+\tfixed-value.c, fold-const.c, function.c, fwprop.c, gcc-ar.c, gcc.c,\n+\tgcov-io.c, gcov-io.h, gcov.c, gcse.c, genattr-common.c, genattr.c,\n+\tgenattrtab.c, genautomata.c, genconfig.c, genemit.c, genextract.c,\n+\tgenflags.c, gengenrtl.c, gengtype-state.c, gengtype.c, genmodes.c,\n+\tgenopinit.c, genoutput.c, genpeep.c, genpreds.c, genrecog.c,\n+\tgensupport.c, ggc-common.c, ggc-page.c, gimple-fold.c, gimple-low.c,\n+\tgimple-pretty-print.c, gimple-ssa-strength-reduction.c, gimple.c,\n+\tgimple.h, godump.c, graphite-clast-to-gimple.c,\n+\tgraphite-optimize-isl.c, graphite-poly.h, graphite-sese-to-poly.c,\n+\tgraphite.c, haifa-sched.c, hash-table.c, hash-table.h, hwint.c,\n+\thwint.h, ifcvt.c, incpath.c, init-regs.c, input.h, intl.c, intl.h,\n+\tipa-cp.c, ipa-devirt.c, ipa-inline-analysis.c, ipa-inline.c,\n+\tipa-profile.c, ipa-pure-const.c, ipa-reference.c, ipa-split.c,\n+\tipa-utils.c, ipa.c, ira-build.c, ira.c, jump.c, loop-doloop.c,\n+\tloop-init.c, loop-invariant.c, loop-iv.c, lower-subreg.c, lto-cgraph.c,\n+\tlto-streamer-in.c, lto-streamer-out.c, lto-wrapper.c, mcf.c,\n+\tmode-switching.c, modulo-sched.c, omp-low.c, optabs.c, opts.c,\n+\tpass_manager.h, passes.c, plugin.c, postreload-gcse.c, postreload.c,\n+\tpredict.c, prefix.c, pretty-print.c, print-rtl.c, print-tree.c,\n+\tprofile.c, read-md.c, real.c, real.h, recog.c, ree.c, reg-stack.c,\n+\tregcprop.c, reginfo.c, regmove.c, regrename.c, regs.h, regstat.c,\n+\treload1.c, reorg.c, rtl.c, rtl.h, rtlanal.c, sbitmap.c, sched-rgn.c,\n+\tsdbout.c, sel-sched-ir.c, sel-sched.c, sparseset.c, stack-ptr-mod.c,\n+\tstatistics.c, stmt.c, stor-layout.c, store-motion.c, streamer-hooks.h,\n+\tsystem.h, target-hooks-macros.h, targhooks.c, targhooks.h, toplev.c,\n+\ttracer.c, trans-mem.c, tree-browser.c, tree-call-cdce.c, tree-cfg.c,\n+\ttree-cfgcleanup.c, tree-complex.c, tree-data-ref.c, tree-data-ref.h,\n+\ttree-eh.c, tree-emutls.c, tree-flow.h, tree-if-conv.c, tree-into-ssa.c,\n+\ttree-iterator.c, tree-loop-distribution.c, tree-mudflap.c,\n+\ttree-nested.c, tree-nomudflap.c, tree-nrv.c, tree-object-size.c,\n+\ttree-optimize.c, tree-pass.h, tree-pretty-print.c, tree-profile.c,\n+\ttree-scalar-evolution.c, tree-sra.c, tree-ssa-ccp.c,\n+\ttree-ssa-coalesce.c, tree-ssa-copy.c, tree-ssa-copyrename.c,\n+\ttree-ssa-dce.c, tree-ssa-dom.c, tree-ssa-dse.c, tree-ssa-forwprop.c,\n+\ttree-ssa-ifcombine.c, tree-ssa-live.c, tree-ssa-loop-ch.c,\n+\ttree-ssa-loop-im.c, tree-ssa-loop-ivopts.c, tree-ssa-loop-prefetch.c,\n+\ttree-ssa-loop.c, tree-ssa-math-opts.c, tree-ssa-operands.c,\n+\ttree-ssa-phiopt.c, tree-ssa-phiprop.c, tree-ssa-pre.c,\n+\ttree-ssa-reassoc.c, tree-ssa-sink.c, tree-ssa-strlen.c,\n+\ttree-ssa-structalias.c, tree-ssa-threadedge.c, tree-ssa-threadupdate.c,\n+\ttree-ssa-uncprop.c, tree-ssa-uninit.c, tree-ssa.c, tree-ssanames.c,\n+\ttree-stdarg.c, tree-switch-conversion.c, tree-tailcall.c,\n+\ttree-vect-data-refs.c, tree-vect-generic.c, tree-vect-loop-manip.c,\n+\ttree-vect-stmts.c, tree-vectorizer.c, tree-vectorizer.h, tree-vrp.c,\n+\ttree.c, tree.h, tsan.c, tsystem.h, value-prof.c, var-tracking.c,\n+\tvarasm.c, vec.h, vmsdbgout.c, vtable-verify.c, web.c: Add missing\n+\twhitespace before \"(\".\n+\n 2013-09-28  Sandra Loosemore  <sandra@codesourcery.com>\n \n \t* expr.h (extract_bit_field): Remove packedp parameter."}, {"sha": "64535685de051cabf29891d70a95d7145e2ab674", "filename": "gcc/alloc-pool.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Falloc-pool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Falloc-pool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falloc-pool.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -316,7 +316,7 @@ pool_alloc (alloc_pool pool)\n \n   /* Pull the first free element from the free list, and return it.  */\n   header = pool->returned_free_list;\n-  VALGRIND_DISCARD (VALGRIND_MAKE_MEM_DEFINED (header, sizeof(*header)));\n+  VALGRIND_DISCARD (VALGRIND_MAKE_MEM_DEFINED (header, sizeof (*header)));\n   pool->returned_free_list = header->next;\n   pool->elts_free--;\n "}, {"sha": "688c2310e818a471fe8a10a433e3929ad0d8cef8", "filename": "gcc/asan.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -2268,8 +2268,8 @@ const pass_data pass_data_asan =\n class pass_asan : public gimple_opt_pass\n {\n public:\n-  pass_asan(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_asan, ctxt)\n+  pass_asan (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_asan, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -2314,8 +2314,8 @@ const pass_data pass_data_asan_O0 =\n class pass_asan_O0 : public gimple_opt_pass\n {\n public:\n-  pass_asan_O0(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_asan_O0, ctxt)\n+  pass_asan_O0 (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_asan_O0, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "6006b70c085aa0383416527ede9bae310a18c83b", "filename": "gcc/auto-inc-dec.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fauto-inc-dec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fauto-inc-dec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fauto-inc-dec.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -1452,9 +1452,9 @@ merge_in_block (int max_reg, basic_block bb)\n     {\n       /* In this case, we must clear these vectors since the trick of\n \t testing if the stale insn in the block will not work.  */\n-      memset (reg_next_use, 0, max_reg * sizeof(rtx));\n-      memset (reg_next_inc_use, 0, max_reg * sizeof(rtx));\n-      memset (reg_next_def, 0, max_reg * sizeof(rtx));\n+      memset (reg_next_use, 0, max_reg * sizeof (rtx));\n+      memset (reg_next_inc_use, 0, max_reg * sizeof (rtx));\n+      memset (reg_next_def, 0, max_reg * sizeof (rtx));\n       df_recompute_luids (bb);\n       merge_in_block (max_reg, bb);\n     }\n@@ -1526,8 +1526,8 @@ const pass_data pass_data_inc_dec =\n class pass_inc_dec : public rtl_opt_pass\n {\n public:\n-  pass_inc_dec(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_inc_dec, ctxt)\n+  pass_inc_dec (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_inc_dec, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "b68cb453d36d813bf2aa44efb4a7dc97e3fa08df", "filename": "gcc/basic-block.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -214,8 +214,8 @@ struct GTY((chain_next (\"%h.next_bb\"), chain_prev (\"%h.prev_bb\"))) basic_block_d\n    struct rtl_bb_info, so that inlining the former into basic_block_def\n    is the better choice.  */\n typedef int __assert_gimple_bb_smaller_rtl_bb\n-              [(int)sizeof(struct rtl_bb_info)\n-               - (int)sizeof (struct gimple_bb_info)];\n+              [(int) sizeof (struct rtl_bb_info)\n+               - (int) sizeof (struct gimple_bb_info)];\n \n \n #define BB_FREQ_MAX 10000\n@@ -324,9 +324,9 @@ struct GTY(()) control_flow_graph {\n #define profile_status_for_function(FN)\t     ((FN)->cfg->x_profile_status)\n \n #define BASIC_BLOCK_FOR_FUNCTION(FN,N) \\\n-  ((*basic_block_info_for_function(FN))[(N)])\n+  ((*basic_block_info_for_function (FN))[(N)])\n #define SET_BASIC_BLOCK_FOR_FUNCTION(FN,N,BB) \\\n-  ((*basic_block_info_for_function(FN))[(N)] = (BB))\n+  ((*basic_block_info_for_function (FN))[(N)] = (BB))\n \n /* Defines for textual backward source compatibility.  */\n #define ENTRY_BLOCK_PTR\t\t(cfun->cfg->x_entry_block_ptr)\n@@ -353,7 +353,7 @@ struct GTY(()) control_flow_graph {\n #define FOR_EACH_BB_REVERSE_FN(BB, FN) \\\n   FOR_BB_BETWEEN (BB, (FN)->cfg->x_exit_block_ptr->prev_bb, (FN)->cfg->x_entry_block_ptr, prev_bb)\n \n-#define FOR_EACH_BB_REVERSE(BB) FOR_EACH_BB_REVERSE_FN(BB, cfun)\n+#define FOR_EACH_BB_REVERSE(BB) FOR_EACH_BB_REVERSE_FN (BB, cfun)\n \n /* For iterating over insns in basic block.  */\n #define FOR_BB_INSNS(BB, INSN)\t\t\t\\\n@@ -951,7 +951,7 @@ extern void default_rtl_profile (void);\n \n /* In profile.c.  */\n typedef struct gcov_working_set_info gcov_working_set_t;\n-extern gcov_working_set_t *find_working_set(unsigned pct_times_10);\n+extern gcov_working_set_t *find_working_set (unsigned pct_times_10);\n \n /* Check tha probability is sane.  */\n "}, {"sha": "b89f9855e77f42d8f9ceb9dc3783aceaaaf32565", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -2329,8 +2329,8 @@ const pass_data pass_data_reorder_blocks =\n class pass_reorder_blocks : public rtl_opt_pass\n {\n public:\n-  pass_reorder_blocks(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_reorder_blocks, ctxt)\n+  pass_reorder_blocks (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_reorder_blocks, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -2495,8 +2495,8 @@ const pass_data pass_data_duplicate_computed_gotos =\n class pass_duplicate_computed_gotos : public rtl_opt_pass\n {\n public:\n-  pass_duplicate_computed_gotos(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_duplicate_computed_gotos, ctxt)\n+  pass_duplicate_computed_gotos (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_duplicate_computed_gotos, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -2719,8 +2719,8 @@ const pass_data pass_data_partition_blocks =\n class pass_partition_blocks : public rtl_opt_pass\n {\n public:\n-  pass_partition_blocks(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_partition_blocks, ctxt)\n+  pass_partition_blocks (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_partition_blocks, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "ecaca42d00e70f64847d8a2226a4ec5745081d73", "filename": "gcc/bitmap.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -811,7 +811,7 @@ bitmap_first_set_bit (const_bitmap a)\n   bit_no += ix * BITMAP_WORD_BITS;\n \n #if GCC_VERSION >= 3004\n-  gcc_assert (sizeof(long) == sizeof (word));\n+  gcc_assert (sizeof (long) == sizeof (word));\n   bit_no += __builtin_ctzl (word);\n #else\n   /* Binary search for the first set bit.  */\n@@ -863,7 +863,7 @@ bitmap_last_set_bit (const_bitmap a)\n  found_bit:\n   bit_no += ix * BITMAP_WORD_BITS;\n #if GCC_VERSION >= 3004\n-  gcc_assert (sizeof(long) == sizeof (word));\n+  gcc_assert (sizeof (long) == sizeof (word));\n   bit_no += BITMAP_WORD_BITS - __builtin_clzl (word) - 1;\n #else\n   /* Hopefully this is a twos-complement host...  */"}, {"sha": "b3cb5da98e99402ac44b88d9d01fb0d4849cbc57", "filename": "gcc/bitmap.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.h?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -300,7 +300,7 @@ extern unsigned bitmap_first_set_bit (const_bitmap);\n extern unsigned bitmap_last_set_bit (const_bitmap);\n \n /* Compute bitmap hash (for purposes of hashing etc.)  */\n-extern hashval_t bitmap_hash(const_bitmap);\n+extern hashval_t bitmap_hash (const_bitmap);\n \n /* Allocate a bitmap from a bit obstack.  */\n #define BITMAP_ALLOC(OBSTACK) bitmap_obstack_alloc (OBSTACK)"}, {"sha": "5384d01d5256fd8a6bb2f7927736fb4ff792f671", "filename": "gcc/bt-load.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fbt-load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fbt-load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbt-load.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -605,7 +605,7 @@ compute_defs_uses_and_gen (fibheap_t all_btr_defs, btr_def *def_array,\n \t}\n \n       if (dump_file)\n-\tdump_btrs_live(i);\n+\tdump_btrs_live (i);\n     }\n }\n \n@@ -691,13 +691,13 @@ link_btr_uses (btr_def *def_array, btr_user *use_array, sbitmap *bb_out,\n \t\t     for this one.  */\n \t\t  bitmap_and_compl (reaching_defs, reaching_defs,\n \t\t\t\t      btr_defset[def->btr - first_btr]);\n-\t\t  bitmap_set_bit(reaching_defs, insn_uid);\n+\t\t  bitmap_set_bit (reaching_defs, insn_uid);\n \t\t}\n \n \t      if (user != NULL)\n \t\t{\n \t\t  /* Find all the reaching defs for this use.  */\n-\t\t  sbitmap reaching_defs_of_reg = sbitmap_alloc(max_uid);\n+\t\t  sbitmap reaching_defs_of_reg = sbitmap_alloc (max_uid);\n \t\t  unsigned int uid = 0;\n \t\t  sbitmap_iterator sbi;\n \n@@ -1363,7 +1363,7 @@ migrate_btr_def (btr_def def, int min_cost)\n \t  if (btr != -1)\n \t    {\n \t      move_btr_def (attempt, btr, def, live_range, &btrs_live_in_range);\n-\t      bitmap_copy(live_range, def->live_range);\n+\t      bitmap_copy (live_range, def->live_range);\n \t      btr_used_near_def = 0;\n \t      def_moved = 1;\n \t      def_basic_block_freq = basic_block_freq (def->bb);\n@@ -1406,11 +1406,11 @@ migrate_btr_defs (enum reg_class btr_class, int allow_callee_save)\n       for (i = NUM_FIXED_BLOCKS; i < last_basic_block; i++)\n \t{\n \t  basic_block bb = BASIC_BLOCK (i);\n-\t  fprintf(dump_file,\n-\t    \"Basic block %d: count = \" HOST_WIDEST_INT_PRINT_DEC\n-\t    \" loop-depth = %d idom = %d\\n\",\n-\t    i, (HOST_WIDEST_INT) bb->count, bb_loop_depth (bb),\n-\t    get_immediate_dominator (CDI_DOMINATORS, bb)->index);\n+\t  fprintf (dump_file,\n+\t\t   \"Basic block %d: count = \" HOST_WIDEST_INT_PRINT_DEC\n+\t\t   \" loop-depth = %d idom = %d\\n\",\n+\t\t   i, (HOST_WIDEST_INT) bb->count, bb_loop_depth (bb),\n+\t\t   get_immediate_dominator (CDI_DOMINATORS, bb)->index);\n \t}\n     }\n \n@@ -1524,8 +1524,8 @@ const pass_data pass_data_branch_target_load_optimize1 =\n class pass_branch_target_load_optimize1 : public rtl_opt_pass\n {\n public:\n-  pass_branch_target_load_optimize1(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_branch_target_load_optimize1, ctxt)\n+  pass_branch_target_load_optimize1 (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_branch_target_load_optimize1, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -1593,8 +1593,8 @@ const pass_data pass_data_branch_target_load_optimize2 =\n class pass_branch_target_load_optimize2 : public rtl_opt_pass\n {\n public:\n-  pass_branch_target_load_optimize2(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_branch_target_load_optimize2, ctxt)\n+  pass_branch_target_load_optimize2 (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_branch_target_load_optimize2, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "3b16d592db435d06f34e7c3c67dcba1a5553e063", "filename": "gcc/builtins.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -1703,7 +1703,7 @@ expand_builtin_apply (rtx function, rtx arguments, rtx argsize)\n   else\n #endif\n     emit_stack_restore (SAVE_BLOCK, old_stack_level);\n-  fixup_args_size_notes (call_insn, get_last_insn(), 0);\n+  fixup_args_size_notes (call_insn, get_last_insn (), 0);\n \n   OK_DEFER_POP;\n \n@@ -4172,7 +4172,7 @@ std_canonical_va_list_type (tree type)\n \n   if (INDIRECT_REF_P (type))\n     type = TREE_TYPE (type);\n-  else if (POINTER_TYPE_P (type) && POINTER_TYPE_P (TREE_TYPE(type)))\n+  else if (POINTER_TYPE_P (type) && POINTER_TYPE_P (TREE_TYPE (type)))\n     type = TREE_TYPE (type);\n   wtype = va_list_type_node;\n   htype = type;\n@@ -5342,7 +5342,7 @@ get_memmodel (tree exp)\n       return MEMMODEL_SEQ_CST;\n     }\n \n-  if ((INTVAL(op) & MEMMODEL_MASK) >= MEMMODEL_LAST)\n+  if ((INTVAL (op) & MEMMODEL_MASK) >= MEMMODEL_LAST)\n     {\n       warning (OPT_Winvalid_memory_model,\n \t       \"invalid memory model argument to builtin\");\n@@ -5546,7 +5546,7 @@ expand_builtin_atomic_fetch_op (enum machine_mode mode, tree exp, rtx target,\n   STRIP_NOPS (addr);\n \n   gcc_assert (TREE_OPERAND (addr, 0) == fndecl);\n-  TREE_OPERAND (addr, 0) = builtin_decl_explicit(ext_call);\n+  TREE_OPERAND (addr, 0) = builtin_decl_explicit (ext_call);\n \n   /* Expand the call here so we can emit trailing code.  */\n   ret = expand_call (exp, target, ignore);\n@@ -9644,8 +9644,8 @@ static tree\n fold_builtin_fma (location_t loc, tree arg0, tree arg1, tree arg2, tree type)\n {\n   if (validate_arg (arg0, REAL_TYPE)\n-      && validate_arg(arg1, REAL_TYPE)\n-      && validate_arg(arg2, REAL_TYPE))\n+      && validate_arg (arg1, REAL_TYPE)\n+      && validate_arg (arg2, REAL_TYPE))\n     {\n       tree tem = fold_fma (loc, type, arg0, arg1, arg2);\n       if (tem)\n@@ -10387,13 +10387,13 @@ fold_builtin_1 (location_t loc, tree fndecl, tree arg0, bool ignore)\n     break;\n \n     CASE_FLT_FN (BUILT_IN_CCOS):\n-      return fold_builtin_ccos(loc, arg0, type, fndecl, /*hyper=*/ false);\n+      return fold_builtin_ccos (loc, arg0, type, fndecl, /*hyper=*/ false);\n \n     CASE_FLT_FN (BUILT_IN_CCOSH):\n-      return fold_builtin_ccos(loc, arg0, type, fndecl, /*hyper=*/ true);\n+      return fold_builtin_ccos (loc, arg0, type, fndecl, /*hyper=*/ true);\n \n     CASE_FLT_FN (BUILT_IN_CPROJ):\n-      return fold_builtin_cproj(loc, arg0, type);\n+      return fold_builtin_cproj (loc, arg0, type);\n \n     CASE_FLT_FN (BUILT_IN_CSIN):\n       if (validate_arg (arg0, COMPLEX_TYPE)\n@@ -10768,26 +10768,26 @@ fold_builtin_2 (location_t loc, tree fndecl, tree arg0, tree arg1, bool ignore)\n     CASE_FLT_FN (BUILT_IN_DREM):\n     CASE_FLT_FN (BUILT_IN_REMAINDER):\n       if (validate_arg (arg0, REAL_TYPE)\n-          && validate_arg(arg1, REAL_TYPE))\n+          && validate_arg (arg1, REAL_TYPE))\n         return do_mpfr_arg2 (arg0, arg1, type, mpfr_remainder);\n     break;\n \n     CASE_FLT_FN_REENT (BUILT_IN_GAMMA): /* GAMMA_R */\n     CASE_FLT_FN_REENT (BUILT_IN_LGAMMA): /* LGAMMA_R */\n       if (validate_arg (arg0, REAL_TYPE)\n-\t  && validate_arg(arg1, POINTER_TYPE))\n+\t  && validate_arg (arg1, POINTER_TYPE))\n \treturn do_mpfr_lgamma_r (arg0, arg1, type);\n     break;\n \n     CASE_FLT_FN (BUILT_IN_ATAN2):\n       if (validate_arg (arg0, REAL_TYPE)\n-\t  && validate_arg(arg1, REAL_TYPE))\n+\t  && validate_arg (arg1, REAL_TYPE))\n \treturn do_mpfr_arg2 (arg0, arg1, type, mpfr_atan2);\n     break;\n \n     CASE_FLT_FN (BUILT_IN_FDIM):\n       if (validate_arg (arg0, REAL_TYPE)\n-\t  && validate_arg(arg1, REAL_TYPE))\n+\t  && validate_arg (arg1, REAL_TYPE))\n \treturn do_mpfr_arg2 (arg0, arg1, type, mpfr_dim);\n     break;\n \n@@ -10969,8 +10969,8 @@ fold_builtin_3 (location_t loc, tree fndecl,\n \n     CASE_FLT_FN (BUILT_IN_REMQUO):\n       if (validate_arg (arg0, REAL_TYPE)\n-\t  && validate_arg(arg1, REAL_TYPE)\n-\t  && validate_arg(arg2, POINTER_TYPE))\n+\t  && validate_arg (arg1, REAL_TYPE)\n+\t  && validate_arg (arg2, POINTER_TYPE))\n \treturn do_mpfr_remquo (arg0, arg1, arg2);\n     break;\n \n@@ -13943,7 +13943,7 @@ do_mpfr_bessel_n (tree arg1, tree arg2, tree type,\n       && host_integerp (arg1, 0)\n       && TREE_CODE (arg2) == REAL_CST && !TREE_OVERFLOW (arg2))\n     {\n-      const HOST_WIDE_INT n = tree_low_cst(arg1, 0);\n+      const HOST_WIDE_INT n = tree_low_cst (arg1, 0);\n       const REAL_VALUE_TYPE *const ra = &TREE_REAL_CST (arg2);\n \n       if (n == (long)n\n@@ -14071,7 +14071,7 @@ do_mpfr_lgamma_r (tree arg, tree arg_sg, tree type)\n \t negative integer.  */\n       if (real_isfinite (ra)\n \t  && ra->cl != rvc_zero\n-\t  && !(real_isneg(ra) && real_isinteger(ra, TYPE_MODE (type))))\n+\t  && !(real_isneg (ra) && real_isinteger (ra, TYPE_MODE (type))))\n         {\n \t  const struct real_format *fmt = REAL_MODE_FORMAT (TYPE_MODE (type));\n \t  const int prec = fmt->p;\n@@ -14140,8 +14140,8 @@ do_mpc_arg1 (tree arg, tree type, int (*func)(mpc_ptr, mpc_srcptr, mpc_rnd_t))\n \t  mpc_t m;\n \n \t  mpc_init2 (m, prec);\n-\t  mpfr_from_real (mpc_realref(m), re, rnd);\n-\t  mpfr_from_real (mpc_imagref(m), im, rnd);\n+\t  mpfr_from_real (mpc_realref (m), re, rnd);\n+\t  mpfr_from_real (mpc_imagref (m), im, rnd);\n \t  mpfr_clear_flags ();\n \t  inexact = func (m, m, crnd);\n \t  result = do_mpc_ckconv (m, type, inexact, /*force_convert=*/ 0);\n@@ -14196,10 +14196,10 @@ do_mpc_arg2 (tree arg0, tree arg1, tree type, int do_nonfinite,\n \n \t  mpc_init2 (m0, prec);\n \t  mpc_init2 (m1, prec);\n-\t  mpfr_from_real (mpc_realref(m0), re0, rnd);\n-\t  mpfr_from_real (mpc_imagref(m0), im0, rnd);\n-\t  mpfr_from_real (mpc_realref(m1), re1, rnd);\n-\t  mpfr_from_real (mpc_imagref(m1), im1, rnd);\n+\t  mpfr_from_real (mpc_realref (m0), re0, rnd);\n+\t  mpfr_from_real (mpc_imagref (m0), im0, rnd);\n+\t  mpfr_from_real (mpc_realref (m1), re1, rnd);\n+\t  mpfr_from_real (mpc_imagref (m1), im1, rnd);\n \t  mpfr_clear_flags ();\n \t  inexact = func (m0, m0, m1, crnd);\n \t  result = do_mpc_ckconv (m0, type, inexact, do_nonfinite);"}, {"sha": "f489f4baf75f71904974610ff0b39d2a007b7b75", "filename": "gcc/calls.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -1732,7 +1732,8 @@ internal_arg_pointer_based_exp_scan (void)\n \t  if (val != NULL_RTX)\n \t    {\n \t      if (idx >= internal_arg_pointer_exp_state.cache.length ())\n-\t\tinternal_arg_pointer_exp_state.cache.safe_grow_cleared(idx + 1);\n+\t\tinternal_arg_pointer_exp_state.cache\n+\t\t  .safe_grow_cleared (idx + 1);\n \t      internal_arg_pointer_exp_state.cache[idx] = val;\n \t    }\n \t}"}, {"sha": "53a997550101d6c6a2283188cbe81f19b2ef03bf", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -3089,8 +3089,8 @@ const pass_data pass_data_jump =\n class pass_jump : public rtl_opt_pass\n {\n public:\n-  pass_jump(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_jump, ctxt)\n+  pass_jump (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_jump, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -3133,8 +3133,8 @@ const pass_data pass_data_jump2 =\n class pass_jump2 : public rtl_opt_pass\n {\n public:\n-  pass_jump2(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_jump2, ctxt)\n+  pass_jump2 (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_jump2, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "afb02a0801b9fa17f22220e616d5e3a09b9d12ba", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -569,7 +569,7 @@ add_partitioned_vars_to_ptset (struct pt_solution *pt,\n       || pt->vars == NULL\n       /* The pointed-to vars bitmap is shared, it is enough to\n \t visit it once.  */\n-      || pointer_set_insert(visited, pt->vars))\n+      || pointer_set_insert (visited, pt->vars))\n     return;\n \n   bitmap_clear (temp);\n@@ -1184,7 +1184,7 @@ expand_one_var (tree var, bool toplevel, bool really_expand)\n     {\n       /* stack_alignment_estimated shouldn't change after stack\n          realign decision made */\n-      gcc_assert(!crtl->stack_realign_processed);\n+      gcc_assert (!crtl->stack_realign_processed);\n       crtl->stack_alignment_estimated = align;\n     }\n \n@@ -1723,7 +1723,7 @@ expand_used_vars (void)\n \n     case SPCT_FLAG_DEFAULT:\n       if (cfun->calls_alloca || has_protected_decls)\n-\tcreate_stack_guard();\n+\tcreate_stack_guard ();\n       break;\n \n     default:\n@@ -1770,7 +1770,7 @@ expand_used_vars (void)\n \t  var_end_seq\n \t    = asan_emit_stack_protection (virtual_stack_vars_rtx,\n \t\t\t\t\t  data.asan_vec.address (),\n-\t\t\t\t\t  data.asan_decl_vec. address(),\n+\t\t\t\t\t  data.asan_decl_vec. address (),\n \t\t\t\t\t  data.asan_vec.length ());\n \t}\n \n@@ -4934,8 +4934,8 @@ const pass_data pass_data_expand =\n class pass_expand : public rtl_opt_pass\n {\n public:\n-  pass_expand(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_expand, ctxt)\n+  pass_expand (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_expand, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "c12a62fca500b3be42c4daf76818d24a592d0126", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -1443,6 +1443,6 @@ account_profile_record (struct profile_record *record, int after_pass)\n \t  || bb == EXIT_BLOCK_PTR_FOR_FUNCTION (cfun))\n \tcontinue;\n       gcc_assert (cfg_hooks->account_profile_record);\n-      cfg_hooks->account_profile_record(bb, after_pass, record);\n+      cfg_hooks->account_profile_record (bb, after_pass, record);\n    }\n }"}, {"sha": "f39b1944ab690b1d3428540daf673032f8c47ceb", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -433,7 +433,7 @@ flow_loops_find (struct loops *loops)\n \n   /* Gather all loop headers in reverse completion order and allocate\n      loop structures for loops that are not already present.  */\n-  larray.create (loops->larray->length());\n+  larray.create (loops->larray->length ());\n   for (b = 0; b < n_basic_blocks - NUM_FIXED_BLOCKS; b++)\n     {\n       basic_block header = BASIC_BLOCK (rc_order[b]);\n@@ -509,7 +509,7 @@ flow_loops_find (struct loops *loops)\n \t}\n     }\n \n-  larray.release();\n+  larray.release ();\n \n   return loops;\n }"}, {"sha": "b4840dcf014bd83d6568487df275647f3645bec6", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -950,7 +950,7 @@ unloop (struct loop *loop, bool *irred_invalidated,\n \tremove_bb_from_loops (body[i]);\n \tadd_bb_to_loop (body[i], loop_outer (loop));\n       }\n-  free(body);\n+  free (body);\n \n   while (loop->inner)\n     {"}, {"sha": "85738a43f36d7212e6678be46293859f339b5673", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -479,8 +479,8 @@ const pass_data pass_data_free_cfg =\n class pass_free_cfg : public rtl_opt_pass\n {\n public:\n-  pass_free_cfg(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_free_cfg, ctxt)\n+  pass_free_cfg (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_free_cfg, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -1441,7 +1441,7 @@ void\n emit_barrier_after_bb (basic_block bb)\n {\n   rtx barrier = emit_barrier_after (BB_END (bb));\n-  gcc_assert (current_ir_type() == IR_RTL_CFGRTL\n+  gcc_assert (current_ir_type () == IR_RTL_CFGRTL\n               || current_ir_type () == IR_RTL_CFGLAYOUT);\n   if (current_ir_type () == IR_RTL_CFGLAYOUT)\n     BB_FOOTER (bb) = unlink_insn_chain (barrier, barrier);\n@@ -2346,7 +2346,7 @@ verify_hot_cold_block_grouping (void)\n      again (in compgoto). Ensure we don't call this before going back\n      into linearized RTL when any layout fixes would have been committed.  */\n   if (!crtl->bb_reorder_complete\n-      || current_ir_type() != IR_RTL_CFGRTL)\n+      || current_ir_type () != IR_RTL_CFGRTL)\n     return err;\n \n   FOR_EACH_BB (bb)\n@@ -3484,8 +3484,8 @@ const pass_data pass_data_into_cfg_layout_mode =\n class pass_into_cfg_layout_mode : public rtl_opt_pass\n {\n public:\n-  pass_into_cfg_layout_mode(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_into_cfg_layout_mode, ctxt)\n+  pass_into_cfg_layout_mode (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_into_cfg_layout_mode, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -3521,8 +3521,8 @@ const pass_data pass_data_outof_cfg_layout_mode =\n class pass_outof_cfg_layout_mode : public rtl_opt_pass\n {\n public:\n-  pass_outof_cfg_layout_mode(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_outof_cfg_layout_mode, ctxt)\n+  pass_outof_cfg_layout_mode (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_outof_cfg_layout_mode, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -4887,7 +4887,7 @@ rtl_lv_add_condition_to_bb (basic_block first_head ,\n   end_sequence ();\n \n   /* Add the new cond , in the new head.  */\n-  emit_insn_after(seq, BB_END(cond_bb));\n+  emit_insn_after (seq, BB_END (cond_bb));\n }\n \n "}, {"sha": "124ee0adf8556586d0b7e915a7d490f3eeb6616f", "filename": "gcc/cgraph.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -1635,7 +1635,7 @@ release_function_body (tree decl)\n \t}\n       if (cfun->value_histograms)\n \tfree_histograms ();\n-      pop_cfun();\n+      pop_cfun ();\n       gimple_set_body (decl, NULL);\n       /* Struct function hangs a lot of data that would leak if we didn't\n          removed all pointers to it.   */\n@@ -1762,7 +1762,7 @@ cgraph_remove_node (struct cgraph_node *node)\n \n   /* Clear out the node to NULL all pointers and add the node to the free\n      list.  */\n-  memset (node, 0, sizeof(*node));\n+  memset (node, 0, sizeof (*node));\n   node->symbol.type = SYMTAB_FUNCTION;\n   node->uid = uid;\n   SET_NEXT_FREE_NODE (node, free_nodes);\n@@ -1947,13 +1947,13 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n \tfprintf (f, \"(%.2f per call) \",\n \t\t edge->frequency / (double)CGRAPH_FREQ_BASE);\n       if (edge->speculative)\n-\tfprintf(f, \"(speculative) \");\n+\tfprintf (f, \"(speculative) \");\n       if (!edge->inline_failed)\n-\tfprintf(f, \"(inlined) \");\n+\tfprintf (f, \"(inlined) \");\n       if (edge->indirect_inlining_edge)\n-\tfprintf(f, \"(indirect_inlining) \");\n+\tfprintf (f, \"(indirect_inlining) \");\n       if (edge->can_throw_external)\n-\tfprintf(f, \"(can throw external) \");\n+\tfprintf (f, \"(can throw external) \");\n     }\n \n   fprintf (f, \"\\n  Calls: \");\n@@ -1962,19 +1962,19 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n       fprintf (f, \"%s/%i \", cgraph_node_asm_name (edge->callee),\n \t       edge->callee->symbol.order);\n       if (edge->speculative)\n-\tfprintf(f, \"(speculative) \");\n+\tfprintf (f, \"(speculative) \");\n       if (!edge->inline_failed)\n-\tfprintf(f, \"(inlined) \");\n+\tfprintf (f, \"(inlined) \");\n       if (edge->indirect_inlining_edge)\n-\tfprintf(f, \"(indirect_inlining) \");\n+\tfprintf (f, \"(indirect_inlining) \");\n       if (edge->count)\n \tfprintf (f, \"(\"HOST_WIDEST_INT_PRINT_DEC\"x) \",\n \t\t (HOST_WIDEST_INT)edge->count);\n       if (edge->frequency)\n \tfprintf (f, \"(%.2f per call) \",\n \t\t edge->frequency / (double)CGRAPH_FREQ_BASE);\n       if (edge->can_throw_external)\n-\tfprintf(f, \"(can throw external) \");\n+\tfprintf (f, \"(can throw external) \");\n     }\n   fprintf (f, \"\\n\");\n "}, {"sha": "afdeaba4c3d9f90236886ea9e485cfbd19a0f2c0", "filename": "gcc/cgraph.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -901,21 +901,21 @@ cgraph_node_asm_name (struct cgraph_node *node)\n \n /* Return asm name of varpool node.  */\n static inline const char *\n-varpool_node_asm_name(struct varpool_node *node)\n+varpool_node_asm_name (struct varpool_node *node)\n {\n   return symtab_node_asm_name ((symtab_node)node);\n }\n \n /* Return name of cgraph node.  */\n static inline const char *\n-cgraph_node_name(struct cgraph_node *node)\n+cgraph_node_name (struct cgraph_node *node)\n {\n   return symtab_node_name ((symtab_node)node);\n }\n \n /* Return name of varpool node.  */\n static inline const char *\n-varpool_node_name(struct varpool_node *node)\n+varpool_node_name (struct varpool_node *node)\n {\n   return symtab_node_name ((symtab_node)node);\n }"}, {"sha": "4cf562ecdd57557f6c79fab44ba65443b182e8ec", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -393,8 +393,8 @@ const pass_data pass_data_build_cgraph_edges =\n class pass_build_cgraph_edges : public gimple_opt_pass\n {\n public:\n-  pass_build_cgraph_edges(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_build_cgraph_edges, ctxt)\n+  pass_build_cgraph_edges (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_build_cgraph_edges, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -525,8 +525,8 @@ const pass_data pass_data_rebuild_cgraph_edges =\n class pass_rebuild_cgraph_edges : public gimple_opt_pass\n {\n public:\n-  pass_rebuild_cgraph_edges(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_rebuild_cgraph_edges, ctxt)\n+  pass_rebuild_cgraph_edges (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_rebuild_cgraph_edges, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -573,8 +573,8 @@ const pass_data pass_data_remove_cgraph_callee_edges =\n class pass_remove_cgraph_callee_edges : public gimple_opt_pass\n {\n public:\n-  pass_remove_cgraph_callee_edges(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_remove_cgraph_callee_edges, ctxt)\n+  pass_remove_cgraph_callee_edges (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_remove_cgraph_callee_edges, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "cad10a7dcb0a739fc903f018d1d2fb69da9a04a1", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -750,8 +750,8 @@ cgraph_function_versioning (struct cgraph_node *old_version_node,\n   SET_DECL_RTL (new_decl, NULL);\n \n   /* When the old decl was a con-/destructor make sure the clone isn't.  */\n-  DECL_STATIC_CONSTRUCTOR(new_decl) = 0;\n-  DECL_STATIC_DESTRUCTOR(new_decl) = 0;\n+  DECL_STATIC_CONSTRUCTOR (new_decl) = 0;\n+  DECL_STATIC_DESTRUCTOR (new_decl) = 0;\n \n   /* Create the new version's call-graph node.\n      and update the edges of the new node. */"}, {"sha": "e01918cfbd497370a8a2092024b9fa36f4ccb7bf", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -850,7 +850,7 @@ walk_polymorphic_call_targets (pointer_set_t *reachable_call_targets,\n \tdump_possible_polymorphic_call_targets \n \t  (cgraph_dump_file, edge);\n \n-      for (i = 0; i < targets.length(); i++)\n+      for (i = 0; i < targets.length (); i++)\n \t{\n \t  /* Do not bother to mark virtual methods in anonymous namespace;\n \t     either we will find use of virtual table defining it, or it is\n@@ -872,7 +872,7 @@ walk_polymorphic_call_targets (pointer_set_t *reachable_call_targets,\n      make the edge direct.  */\n   if (final)\n     {\n-      if (targets.length() <= 1)\n+      if (targets.length () <= 1)\n \t{\n \t  cgraph_node *target;\n \t  if (targets.length () == 1)"}, {"sha": "84cf6b476e41c100aaea421d8ce5fcab6af21f5e", "filename": "gcc/collect2.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -602,7 +602,7 @@ is_ctor_dtor (const char *s)\n     {\n       if (ch == p->name[0]\n \t  && (!p->two_underscores || ((s - orig_s) >= 2))\n-\t  && strncmp(s, p->name, p->len) == 0)\n+\t  && strncmp (s, p->name, p->len) == 0)\n \t{\n \t  return p->ret;\n \t}\n@@ -777,7 +777,7 @@ maybe_run_lto_and_relink (char **lto_ld_argv, char **object_lst,\n \t plus number of partitions.  */\n       for (lto_ld_argv_size = 0; lto_ld_argv[lto_ld_argv_size]; lto_ld_argv_size++)\n \t;\n-      out_lto_ld_argv = XCNEWVEC(char *, num_files + lto_ld_argv_size + 1);\n+      out_lto_ld_argv = XCNEWVEC (char *, num_files + lto_ld_argv_size + 1);\n       out_lto_ld_argv_size = 0;\n \n       /* After running the LTO back end, we will relink, substituting\n@@ -1644,9 +1644,9 @@ main (int argc, char **argv)\n                                    \"%d destructors found\\n\",\n                                    destructors.number),\n                          destructors.number);\n-      notice_translated (ngettext(\"%d frame table found\\n\",\n-                                  \"%d frame tables found\\n\",\n-                                  frame_tables.number),\n+      notice_translated (ngettext (\"%d frame table found\\n\",\n+                                   \"%d frame tables found\\n\",\n+\t\t\t\t   frame_tables.number),\n                          frame_tables.number);\n     }\n \n@@ -1698,7 +1698,7 @@ main (int argc, char **argv)\n   sort_ids (&constructors);\n   sort_ids (&destructors);\n \n-  maybe_unlink(output_file);\n+  maybe_unlink (output_file);\n   outf = fopen (c_file, \"w\");\n   if (outf == (FILE *) 0)\n     fatal_error (\"fopen %s: %m\", c_file);\n@@ -1812,8 +1812,8 @@ collect_wait (const char *prog, struct pex_obj *pex)\n \t{\n \t  int sig = WTERMSIG (status);\n \t  error (\"%s terminated with signal %d [%s]%s\",\n-\t\t prog, sig, strsignal(sig),\n-\t\t WCOREDUMP(status) ? \", core dumped\" : \"\");\n+\t\t prog, sig, strsignal (sig),\n+\t\t WCOREDUMP (status) ? \", core dumped\" : \"\");\n \t  exit (FATAL_EXIT_CODE);\n \t}\n \n@@ -2255,8 +2255,8 @@ write_c_file_stat (FILE *stream, const char *name ATTRIBUTE_UNUSED)\n \n   if (shared_obj)\n     {\n-      COLLECT_SHARED_INIT_FUNC(stream, initname);\n-      COLLECT_SHARED_FINI_FUNC(stream, fininame);\n+      COLLECT_SHARED_INIT_FUNC (stream, initname);\n+      COLLECT_SHARED_FINI_FUNC (stream, fininame);\n     }\n }\n \n@@ -2727,16 +2727,16 @@ scan_libraries (const char *prog_name)\n \n #if defined (EXTENDED_COFF)\n \n-#   define GCC_SYMBOLS(X)\t(SYMHEADER(X).isymMax + SYMHEADER(X).iextMax)\n+#   define GCC_SYMBOLS(X)\t(SYMHEADER (X).isymMax + SYMHEADER (X).iextMax)\n #   define GCC_SYMENT\t\tSYMR\n #   define GCC_OK_SYMBOL(X)\t((X).st == stProc || (X).st == stGlobal)\n #   define GCC_SYMINC(X)\t(1)\n-#   define GCC_SYMZERO(X)\t(SYMHEADER(X).isymMax)\n-#   define GCC_CHECK_HDR(X)\t(PSYMTAB(X) != 0)\n+#   define GCC_SYMZERO(X)\t(SYMHEADER (X).isymMax)\n+#   define GCC_CHECK_HDR(X)\t(PSYMTAB (X) != 0)\n \n #else\n \n-#   define GCC_SYMBOLS(X)\t(HEADER(ldptr).f_nsyms)\n+#   define GCC_SYMBOLS(X)\t(HEADER (ldptr).f_nsyms)\n #   define GCC_SYMENT\t\tSYMENT\n #   if defined (C_WEAKEXT)\n #     define GCC_OK_SYMBOL(X) \\\n@@ -2994,7 +2994,7 @@ scan_prog_file (const char *prog_name, scanpass which_pass,\n   while (ldclose (ldptr) == FAILURE);\n #else\n   /* Otherwise we simply close ldptr.  */\n-  (void) ldclose(ldptr);\n+  (void) ldclose (ldptr);\n #endif\n }\n #endif /* OBJECT_FORMAT_COFF */\n@@ -3014,7 +3014,7 @@ resolve_lib_name (const char *name)\n     if (libpaths[i]->max_len > l)\n       l = libpaths[i]->max_len;\n \n-  lib_buf = XNEWVEC (char, l + strlen(name) + 10);\n+  lib_buf = XNEWVEC (char, l + strlen (name) + 10);\n \n   for (i = 0; libpaths[i]; i++)\n     {\n@@ -3025,7 +3025,7 @@ resolve_lib_name (const char *name)\n \t     may contain directories both with trailing DIR_SEPARATOR and\n \t     without it.  */\n \t  const char *p = \"\";\n-\t  if (!IS_DIR_SEPARATOR (list->prefix[strlen(list->prefix)-1]))\n+\t  if (!IS_DIR_SEPARATOR (list->prefix[strlen (list->prefix)-1]))\n \t    p = \"/\";\n \t  for (j = 0; j < 2; j++)\n \t    {"}, {"sha": "5ca131f346a4856086d618493324a842ac0da31f", "filename": "gcc/combine-stack-adj.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fcombine-stack-adj.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fcombine-stack-adj.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine-stack-adj.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -663,8 +663,8 @@ const pass_data pass_data_stack_adjustments =\n class pass_stack_adjustments : public rtl_opt_pass\n {\n public:\n-  pass_stack_adjustments(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_stack_adjustments, ctxt)\n+  pass_stack_adjustments (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_stack_adjustments, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "fcf60cd08aa5971bd92af83c8f382b4f4fd91985", "filename": "gcc/combine.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -735,7 +735,7 @@ do_SUBST (rtx *into, rtx newval)\n   buf->next = undobuf.undos, undobuf.undos = buf;\n }\n \n-#define SUBST(INTO, NEWVAL)\tdo_SUBST(&(INTO), (NEWVAL))\n+#define SUBST(INTO, NEWVAL)\tdo_SUBST (&(INTO), (NEWVAL))\n \n /* Similar to SUBST, but NEWVAL is an int expression.  Note that substitution\n    for the value of a HOST_WIDE_INT value (including CONST_INT) is\n@@ -763,7 +763,7 @@ do_SUBST_INT (int *into, int newval)\n   buf->next = undobuf.undos, undobuf.undos = buf;\n }\n \n-#define SUBST_INT(INTO, NEWVAL)  do_SUBST_INT(&(INTO), (NEWVAL))\n+#define SUBST_INT(INTO, NEWVAL)  do_SUBST_INT (&(INTO), (NEWVAL))\n \n /* Similar to SUBST, but just substitute the mode.  This is used when\n    changing the mode of a pseudo-register, so that any other\n@@ -792,7 +792,7 @@ do_SUBST_MODE (rtx *into, enum machine_mode newval)\n   buf->next = undobuf.undos, undobuf.undos = buf;\n }\n \n-#define SUBST_MODE(INTO, NEWVAL)  do_SUBST_MODE(&(INTO), (NEWVAL))\n+#define SUBST_MODE(INTO, NEWVAL)  do_SUBST_MODE (&(INTO), (NEWVAL))\n \n #ifndef HAVE_cc0\n /* Similar to SUBST, but NEWVAL is a LOG_LINKS expression.  */\n@@ -1197,8 +1197,8 @@ combine_instructions (rtx f, unsigned int nregs)\n \t      INSN_COST (insn) = insn_rtx_cost (PATTERN (insn),\n \t      \t\t\t\t\toptimize_this_for_speed_p);\n \t    if (dump_file)\n-\t      fprintf(dump_file, \"insn_cost %d: %d\\n\",\n-\t\t    INSN_UID (insn), INSN_COST (insn));\n+\t      fprintf (dump_file, \"insn_cost %d: %d\\n\",\n+\t\t       INSN_UID (insn), INSN_COST (insn));\n \t  }\n     }\n \n@@ -2328,7 +2328,7 @@ can_change_dest_mode (rtx x, int added_sets, enum machine_mode mode)\n {\n   unsigned int regno;\n \n-  if (!REG_P(x))\n+  if (!REG_P (x))\n     return false;\n \n   regno = REGNO (x);\n@@ -4279,7 +4279,7 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p,\n       df_insn_rescan (undobuf.other_insn);\n     }\n \n-  if (i0 && !(NOTE_P(i0) && (NOTE_KIND (i0) == NOTE_INSN_DELETED)))\n+  if (i0 && !(NOTE_P (i0) && (NOTE_KIND (i0) == NOTE_INSN_DELETED)))\n     {\n       if (dump_file)\n \t{\n@@ -4289,7 +4289,7 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p,\n       df_insn_rescan (i0);\n     }\n \n-  if (i1 && !(NOTE_P(i1) && (NOTE_KIND (i1) == NOTE_INSN_DELETED)))\n+  if (i1 && !(NOTE_P (i1) && (NOTE_KIND (i1) == NOTE_INSN_DELETED)))\n     {\n       if (dump_file)\n \t{\n@@ -4299,7 +4299,7 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p,\n       df_insn_rescan (i1);\n     }\n \n-  if (i2 && !(NOTE_P(i2) && (NOTE_KIND (i2) == NOTE_INSN_DELETED)))\n+  if (i2 && !(NOTE_P (i2) && (NOTE_KIND (i2) == NOTE_INSN_DELETED)))\n     {\n       if (dump_file)\n \t{\n@@ -4309,7 +4309,7 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p,\n       df_insn_rescan (i2);\n     }\n \n-  if (i3 && !(NOTE_P(i3) && (NOTE_KIND (i3) == NOTE_INSN_DELETED)))\n+  if (i3 && !(NOTE_P (i3) && (NOTE_KIND (i3) == NOTE_INSN_DELETED)))\n     {\n       if (dump_file)\n \t{\n@@ -11015,7 +11015,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t this shift are known to be zero for both inputs and if the type of\n \t comparison is compatible with the shift.  */\n       if (GET_CODE (op0) == GET_CODE (op1)\n-\t  && HWI_COMPUTABLE_MODE_P (GET_MODE(op0))\n+\t  && HWI_COMPUTABLE_MODE_P (GET_MODE (op0))\n \t  && ((GET_CODE (op0) == ROTATE && (code == NE || code == EQ))\n \t      || ((GET_CODE (op0) == LSHIFTRT || GET_CODE (op0) == ASHIFT)\n \t\t  && (code != GT && code != LT && code != GE && code != LE))\n@@ -13875,8 +13875,8 @@ const pass_data pass_data_combine =\n class pass_combine : public rtl_opt_pass\n {\n public:\n-  pass_combine(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_combine, ctxt)\n+  pass_combine (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_combine, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "847c89128b477ebb4ddf3a2e1a00cca4a3d494fb", "filename": "gcc/compare-elim.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fcompare-elim.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fcompare-elim.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcompare-elim.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -247,7 +247,7 @@ class find_comparison_dom_walker : public dom_walker\n {\n public:\n   find_comparison_dom_walker (cdi_direction direction)\n-    : dom_walker(direction) {}\n+    : dom_walker (direction) {}\n \n   virtual void before_dom_children (basic_block);\n };\n@@ -673,8 +673,8 @@ const pass_data pass_data_compare_elim_after_reload =\n class pass_compare_elim_after_reload : public rtl_opt_pass\n {\n public:\n-  pass_compare_elim_after_reload(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_compare_elim_after_reload, ctxt)\n+  pass_compare_elim_after_reload (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_compare_elim_after_reload, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "6bd25f018520880a31320a22a0648fa0bcea2d93", "filename": "gcc/context.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fcontext.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fcontext.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcontext.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -27,7 +27,7 @@ along with GCC; see the file COPYING3.  If not see\n /* The singleton holder of global state: */\n gcc::context *g;\n \n-gcc::context::context()\n+gcc::context::context ()\n {\n   passes_ = new gcc::pass_manager (this);\n }"}, {"sha": "ed6a24a8f5c0a0df34c01842c135b73f4c41b719", "filename": "gcc/context.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fcontext.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fcontext.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcontext.h?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -30,7 +30,7 @@ class pass_manager;\n class context\n {\n public:\n-  context();\n+  context ();\n \n   /* Pass-management.  */\n "}, {"sha": "9d6cb46654bfe1c13ea461010ccd020db8bdf38e", "filename": "gcc/cprop.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcprop.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -246,7 +246,8 @@ insert_set_in_table (rtx dest, rtx src, rtx insn, struct hash_table_d *table,\n \n   /* Record bitmap_index of the implicit set in implicit_set_indexes.  */\n   if (implicit)\n-    implicit_set_indexes[BLOCK_FOR_INSN(insn)->index] = cur_expr->bitmap_index;\n+    implicit_set_indexes[BLOCK_FOR_INSN (insn)->index]\n+      = cur_expr->bitmap_index;\n }\n \n /* Determine whether the rtx X should be treated as a constant for CPROP.\n@@ -1402,9 +1403,9 @@ find_implicit_sets (void)\n       implicit_sets[dest->index] = new_rtx;\n       if (dump_file)\n \t{\n-\t  fprintf(dump_file, \"Implicit set of reg %d in \",\n-\t\t  REGNO (XEXP (cond, 0)));\n-\t  fprintf(dump_file, \"basic block %d\\n\", dest->index);\n+\t  fprintf (dump_file, \"Implicit set of reg %d in \",\n+\t\t   REGNO (XEXP (cond, 0)));\n+\t  fprintf (dump_file, \"basic block %d\\n\", dest->index);\n \t}\n       count++;\n     }\n@@ -1934,8 +1935,8 @@ const pass_data pass_data_rtl_cprop =\n class pass_rtl_cprop : public rtl_opt_pass\n {\n public:\n-  pass_rtl_cprop(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_rtl_cprop, ctxt)\n+  pass_rtl_cprop (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_rtl_cprop, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "43fa1e8191f56865fce6d09d9a35a54994a86577", "filename": "gcc/cse.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -468,7 +468,7 @@ struct table_elt\n    a cost of 2.  Aside from these special cases, call `rtx_cost'.  */\n \n #define CHEAP_REGNO(N)\t\t\t\t\t\t\t\\\n-  (REGNO_PTR_FRAME_P(N)\t\t\t\t\t\t\t\\\n+  (REGNO_PTR_FRAME_P (N)\t\t\t\t\t\t\\\n    || (HARD_REGISTER_NUM_P (N)\t\t\t\t\t\t\\\n        && FIXED_REGNO_P (N) && REGNO_REG_CLASS (N) != NO_REGS))\n \n@@ -4839,7 +4839,7 @@ cse_insn (rtx insn)\n \n \t  /* Set what we are trying to extend and the operation it might\n \t     have been extended with.  */\n-\t  memset (memory_extend_rtx, 0, sizeof(*memory_extend_rtx));\n+\t  memset (memory_extend_rtx, 0, sizeof (*memory_extend_rtx));\n \t  PUT_CODE (memory_extend_rtx, LOAD_EXTEND_OP (mode));\n \t  XEXP (memory_extend_rtx, 0) = src;\n \n@@ -7479,8 +7479,8 @@ const pass_data pass_data_cse =\n class pass_cse : public rtl_opt_pass\n {\n public:\n-  pass_cse(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_cse, ctxt)\n+  pass_cse (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_cse, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -7559,8 +7559,8 @@ const pass_data pass_data_cse2 =\n class pass_cse2 : public rtl_opt_pass\n {\n public:\n-  pass_cse2(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_cse2, ctxt)\n+  pass_cse2 (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_cse2, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -7637,8 +7637,8 @@ const pass_data pass_data_cse_after_global_opts =\n class pass_cse_after_global_opts : public rtl_opt_pass\n {\n public:\n-  pass_cse_after_global_opts(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_cse_after_global_opts, ctxt)\n+  pass_cse_after_global_opts (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_cse_after_global_opts, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "e201f5e7c490c57850b4d8e1d8335b4802078c39", "filename": "gcc/cselib.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -259,10 +259,10 @@ void (*cselib_record_sets_hook) (rtx insn, struct cselib_set *sets,\n \t\t\t\t int n_sets);\n \n #define PRESERVED_VALUE_P(RTX) \\\n-  (RTL_FLAG_CHECK1(\"PRESERVED_VALUE_P\", (RTX), VALUE)->unchanging)\n+  (RTL_FLAG_CHECK1 (\"PRESERVED_VALUE_P\", (RTX), VALUE)->unchanging)\n \n #define SP_BASED_VALUE_P(RTX) \\\n-  (RTL_FLAG_CHECK1(\"SP_BASED_VALUE_P\", (RTX), VALUE)->jump)\n+  (RTL_FLAG_CHECK1 (\"SP_BASED_VALUE_P\", (RTX), VALUE)->jump)\n \n \f\n "}, {"sha": "9b5e23f6d71c6aeaf5f7a53060a511527f165766", "filename": "gcc/dbxout.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -636,7 +636,7 @@ dbxout_begin_complex_stabs_noforcetext (void)\n #define stabstr_C(chr) obstack_1grow (&stabstr_ob, chr)\n \n /* Add STR, a normal C string, to the string being built.  */\n-#define stabstr_S(str) obstack_grow (&stabstr_ob, str, strlen(str))\n+#define stabstr_S(str) obstack_grow (&stabstr_ob, str, strlen (str))\n \n /* Add the text of ID, an IDENTIFIER_NODE, to the string being built.  */\n #define stabstr_I(id) obstack_grow (&stabstr_ob, \\\n@@ -2434,7 +2434,7 @@ dbxout_class_name_qualifiers (tree decl)\n   tree context = decl_type_context (decl);\n \n   if (context != NULL_TREE\n-      && TREE_CODE(context) == RECORD_TYPE\n+      && TREE_CODE (context) == RECORD_TYPE\n       && TYPE_NAME (context) != 0\n       && (TREE_CODE (TYPE_NAME (context)) == IDENTIFIER_NODE\n           || (DECL_NAME (TYPE_NAME (context)) != 0)))\n@@ -3302,8 +3302,8 @@ dbxout_common_check (tree decl, int *value)\n      for thread-local symbols.  Can be handled via same mechanism as used\n      in dwarf2out.c.  */\n   if (TREE_CODE (decl) != VAR_DECL\n-      || !TREE_STATIC(decl)\n-      || !DECL_HAS_VALUE_EXPR_P(decl)\n+      || !TREE_STATIC (decl)\n+      || !DECL_HAS_VALUE_EXPR_P (decl)\n       || DECL_THREAD_LOCAL_P (decl)\n       || !is_fortran ())\n     return NULL;\n@@ -3337,21 +3337,21 @@ dbxout_common_check (tree decl, int *value)\n           if (CONST_INT_P (XEXP (sym_addr, 0)))\n             {\n               name =\n-                targetm.strip_name_encoding(XSTR (XEXP (sym_addr, 1), 0));\n+                targetm.strip_name_encoding (XSTR (XEXP (sym_addr, 1), 0));\n               *value = INTVAL (XEXP (sym_addr, 0));\n               cdecl = SYMBOL_REF_DECL (XEXP (sym_addr, 1));\n             }\n           else\n             {\n               name =\n-                targetm.strip_name_encoding(XSTR (XEXP (sym_addr, 0), 0));\n+                targetm.strip_name_encoding (XSTR (XEXP (sym_addr, 0), 0));\n               *value = INTVAL (XEXP (sym_addr, 1));\n               cdecl = SYMBOL_REF_DECL (XEXP (sym_addr, 0));\n             }\n           break;\n \n         case SYMBOL_REF:\n-          name = targetm.strip_name_encoding(XSTR (sym_addr, 0));\n+          name = targetm.strip_name_encoding (XSTR (sym_addr, 0));\n           *value = 0;\n           cdecl = SYMBOL_REF_DECL (sym_addr);\n           break;\n@@ -3364,7 +3364,7 @@ dbxout_common_check (tree decl, int *value)\n       /* Check area common symbol is offset into.  If this is not public, then\n          it is not a symbol in a common block.  It must be a .lcomm symbol, not\n          a .comm symbol.  */\n-      if (cdecl == NULL || !TREE_PUBLIC(cdecl))\n+      if (cdecl == NULL || !TREE_PUBLIC (cdecl))\n         name = NULL;\n     }\n   else"}, {"sha": "5c11cbeef0da574f8a749b00f60bdcfff61c1f03", "filename": "gcc/dce.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdce.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -806,8 +806,8 @@ const pass_data pass_data_ud_rtl_dce =\n class pass_ud_rtl_dce : public rtl_opt_pass\n {\n public:\n-  pass_ud_rtl_dce(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_ud_rtl_dce, ctxt)\n+  pass_ud_rtl_dce (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_ud_rtl_dce, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -1239,8 +1239,8 @@ const pass_data pass_data_fast_rtl_dce =\n class pass_fast_rtl_dce : public rtl_opt_pass\n {\n public:\n-  pass_fast_rtl_dce(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_fast_rtl_dce, ctxt)\n+  pass_fast_rtl_dce (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_fast_rtl_dce, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "37e8a08ac5af32b5d22e64d53dcb8e940b0de483", "filename": "gcc/defaults.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -76,7 +76,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \t  int c = p[i];\t\t\t   \t\t\t\t      \\\n \t  if (c == '\\\"' || c == '\\\\')\t\t\t\t\t      \\\n \t    putc ('\\\\', asm_out_file);\t\t\t\t\t      \\\n-\t  if (ISPRINT(c))\t\t\t\t\t\t      \\\n+\t  if (ISPRINT (c))\t\t\t\t\t\t      \\\n \t    putc (c, asm_out_file);\t\t\t\t\t      \\\n \t  else\t\t\t\t\t\t\t\t      \\\n \t    {\t\t\t\t\t\t\t\t      \\\n@@ -86,7 +86,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \t\t The VAX assembler fails to stop reading the escape\t      \\\n \t\t after three digits, so this is the only way we\t\t      \\\n \t\t can get it to parse the data properly.  */\t\t      \\\n-\t      if (i < thissize - 1 && ISDIGIT(p[i + 1]))\t\t      \\\n+\t      if (i < thissize - 1 && ISDIGIT (p[i + 1]))\t\t      \\\n \t\tfprintf (asm_out_file, \"\\\"\\n\\t.ascii \\\"\");\t\t      \\\n \t  }\t\t\t\t\t\t\t\t      \\\n \t}\t\t\t\t\t\t\t\t      \\\n@@ -351,7 +351,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n /* If we have named sections, and we're using crtstuff to run ctors,\n    use them for registering eh frame information.  */\n #if defined (TARGET_ASM_NAMED_SECTION) && DWARF2_UNWIND_INFO \\\n-    && !defined(EH_FRAME_IN_DATA_SECTION)\n+    && !defined (EH_FRAME_IN_DATA_SECTION)\n #ifndef EH_FRAME_SECTION_NAME\n #define EH_FRAME_SECTION_NAME \".eh_frame\"\n #endif\n@@ -1278,7 +1278,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n    SET_RATIO or more simple move-instruction sequences, we will do a movmem\n    or libcall instead.  */\n #ifndef SET_RATIO\n-#define SET_RATIO(speed) MOVE_RATIO(speed)\n+#define SET_RATIO(speed) MOVE_RATIO (speed)\n #endif\n \n /* Supply a default definition for FUNCTION_ARG_PADDING:"}, {"sha": "deea7551053471b7158eedcd4ab6d451af0c555a", "filename": "gcc/df-core.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -549,7 +549,7 @@ df_set_blocks (bitmap blocks)\n \t\t    {\n \t\t      basic_block bb;\n \t\t      bitmap_initialize (&blocks_to_reset, &df_bitmap_obstack);\n-\t\t      FOR_ALL_BB(bb)\n+\t\t      FOR_ALL_BB (bb)\n \t\t\t{\n \t\t\t  bitmap_set_bit (&blocks_to_reset, bb->index);\n \t\t\t}\n@@ -766,8 +766,8 @@ const pass_data pass_data_df_initialize_opt =\n class pass_df_initialize_opt : public rtl_opt_pass\n {\n public:\n-  pass_df_initialize_opt(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_df_initialize_opt, ctxt)\n+  pass_df_initialize_opt (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_df_initialize_opt, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -812,8 +812,8 @@ const pass_data pass_data_df_initialize_no_opt =\n class pass_df_initialize_no_opt : public rtl_opt_pass\n {\n public:\n-  pass_df_initialize_no_opt(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_df_initialize_no_opt, ctxt)\n+  pass_df_initialize_no_opt (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_df_initialize_no_opt, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -878,8 +878,8 @@ const pass_data pass_data_df_finish =\n class pass_df_finish : public rtl_opt_pass\n {\n public:\n-  pass_df_finish(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_df_finish, ctxt)\n+  pass_df_finish (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_df_finish, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -2078,7 +2078,7 @@ df_dump_start (FILE *file)\n \t{\n \t  df_dump_problem_function fun = dflow->problem->dump_start_fun;\n \t  if (fun)\n-\t    fun(file);\n+\t    fun (file);\n \t}\n     }\n }"}, {"sha": "59fc2f64444e713b54eb83c8a09230cfc5bc32c9", "filename": "gcc/df-problems.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -326,7 +326,7 @@ df_rd_bb_local_compute_process_def (struct df_rd_bb_info *bb_info,\n \t\t      if (n_defs > DF_SPARSE_THRESHOLD)\n \t\t\t{\n \t\t\t  bitmap_set_bit (&bb_info->sparse_kill, regno);\n-\t\t\t  bitmap_clear_range(&bb_info->gen, begin, n_defs);\n+\t\t\t  bitmap_clear_range (&bb_info->gen, begin, n_defs);\n \t\t\t}\n \t\t      else\n \t\t\t{\n@@ -594,7 +594,7 @@ df_rd_start_dump (FILE *file)\n {\n   struct df_rd_problem_data *problem_data\n     = (struct df_rd_problem_data *) df_rd->problem_data;\n-  unsigned int m = DF_REG_SIZE(df);\n+  unsigned int m = DF_REG_SIZE (df);\n   unsigned int regno;\n \n   if (!df_rd->block_info)\n@@ -622,7 +622,7 @@ df_rd_dump_defs_set (bitmap defs_set, const char *prefix, FILE *file)\n {\n   bitmap_head tmp;\n   unsigned int regno;\n-  unsigned int m = DF_REG_SIZE(df);\n+  unsigned int m = DF_REG_SIZE (df);\n   bool first_reg = true;\n \n   fprintf (file, \"%s\\t(%d) \", prefix, (int) bitmap_count_bits (defs_set));"}, {"sha": "f2e8ab2713604543917c21abea0041d1751b8f01", "filename": "gcc/df-scan.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -191,9 +191,9 @@ df_scan_free_internal (void)\n   /* The vectors that hold the refs are not pool allocated because\n      they come in many sizes.  This makes them impossible to delete\n      all at once.  */\n-  for (i = 0; i < DF_INSN_SIZE(); i++)\n+  for (i = 0; i < DF_INSN_SIZE (); i++)\n     {\n-      struct df_insn_info *insn_info = DF_INSN_UID_GET(i);\n+      struct df_insn_info *insn_info = DF_INSN_UID_GET (i);\n       /* Skip the insns that have no insn_info or have been\n \t deleted.  */\n       if (insn_info)\n@@ -233,7 +233,7 @@ df_scan_free_internal (void)\n   free (df->eq_use_regs);\n   df->eq_use_regs = NULL;\n   df->regs_size = 0;\n-  DF_REG_SIZE(df) = 0;\n+  DF_REG_SIZE (df) = 0;\n \n   free (df->insns);\n   df->insns = NULL;\n@@ -2188,7 +2188,7 @@ df_notes_rescan (rtx insn)\n   df_grow_bb_info (df_scan);\n   df_grow_reg_info ();\n \n-  insn_info = DF_INSN_UID_SAFE_GET (INSN_UID(insn));\n+  insn_info = DF_INSN_UID_SAFE_GET (INSN_UID (insn));\n \n   /* The client has deferred rescanning.  */\n   if (df->changeable_flags & DF_DEFER_INSN_RESCAN)\n@@ -4558,11 +4558,11 @@ df_scan_verify (void)\n   for (i = 0; i < DF_REG_SIZE (df); i++)\n     {\n       gcc_assert (df_reg_chain_mark (DF_REG_DEF_CHAIN (i), i, true, false)\n-\t\t  == DF_REG_DEF_COUNT(i));\n+\t\t  == DF_REG_DEF_COUNT (i));\n       gcc_assert (df_reg_chain_mark (DF_REG_USE_CHAIN (i), i, false, false)\n-\t\t  == DF_REG_USE_COUNT(i));\n+\t\t  == DF_REG_USE_COUNT (i));\n       gcc_assert (df_reg_chain_mark (DF_REG_EQ_USE_CHAIN (i), i, false, true)\n-\t\t  == DF_REG_EQ_USE_COUNT(i));\n+\t\t  == DF_REG_EQ_USE_COUNT (i));\n     }\n \n   /* (2) There are various bitmaps whose value may change over the"}, {"sha": "e3ca67b684117b04b75a201d9403e650df64ad31", "filename": "gcc/df.h", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -607,29 +607,29 @@ struct df_d\n   bool redo_entry_and_exit;\n };\n \n-#define DF_SCAN_BB_INFO(BB) (df_scan_get_bb_info((BB)->index))\n-#define DF_RD_BB_INFO(BB) (df_rd_get_bb_info((BB)->index))\n-#define DF_LR_BB_INFO(BB) (df_lr_get_bb_info((BB)->index))\n-#define DF_LIVE_BB_INFO(BB) (df_live_get_bb_info((BB)->index))\n-#define DF_WORD_LR_BB_INFO(BB) (df_word_lr_get_bb_info((BB)->index))\n-#define DF_MD_BB_INFO(BB) (df_md_get_bb_info((BB)->index))\n+#define DF_SCAN_BB_INFO(BB) (df_scan_get_bb_info ((BB)->index))\n+#define DF_RD_BB_INFO(BB) (df_rd_get_bb_info ((BB)->index))\n+#define DF_LR_BB_INFO(BB) (df_lr_get_bb_info ((BB)->index))\n+#define DF_LIVE_BB_INFO(BB) (df_live_get_bb_info ((BB)->index))\n+#define DF_WORD_LR_BB_INFO(BB) (df_word_lr_get_bb_info ((BB)->index))\n+#define DF_MD_BB_INFO(BB) (df_md_get_bb_info ((BB)->index))\n \n /* Most transformations that wish to use live register analysis will\n    use these macros.  This info is the and of the lr and live sets.  */\n-#define DF_LIVE_IN(BB) (&DF_LIVE_BB_INFO(BB)->in)\n-#define DF_LIVE_OUT(BB) (&DF_LIVE_BB_INFO(BB)->out)\n+#define DF_LIVE_IN(BB) (&DF_LIVE_BB_INFO (BB)->in)\n+#define DF_LIVE_OUT(BB) (&DF_LIVE_BB_INFO (BB)->out)\n \n /* These macros are used by passes that are not tolerant of\n    uninitialized variables.  This intolerance should eventually\n    be fixed.  */\n-#define DF_LR_IN(BB) (&DF_LR_BB_INFO(BB)->in)\n-#define DF_LR_OUT(BB) (&DF_LR_BB_INFO(BB)->out)\n+#define DF_LR_IN(BB) (&DF_LR_BB_INFO (BB)->in)\n+#define DF_LR_OUT(BB) (&DF_LR_BB_INFO (BB)->out)\n \n /* These macros are used by passes that are not tolerant of\n    uninitialized variables.  This intolerance should eventually\n    be fixed.  */\n-#define DF_WORD_LR_IN(BB) (&DF_WORD_LR_BB_INFO(BB)->in)\n-#define DF_WORD_LR_OUT(BB) (&DF_WORD_LR_BB_INFO(BB)->out)\n+#define DF_WORD_LR_IN(BB) (&DF_WORD_LR_BB_INFO (BB)->in)\n+#define DF_WORD_LR_OUT(BB) (&DF_WORD_LR_BB_INFO (BB)->out)\n \n /* Macros to access the elements within the ref structure.  */\n \n@@ -640,10 +640,11 @@ struct df_d\n #define DF_REF_REAL_LOC(REF) (GET_CODE (*((REF)->regular_ref.loc)) == SUBREG \\\n                                ? &SUBREG_REG (*((REF)->regular_ref.loc)) : ((REF)->regular_ref.loc))\n #define DF_REF_REG(REF) ((REF)->base.reg)\n-#define DF_REF_LOC(REF) (DF_REF_CLASS(REF) == DF_REF_REGULAR ? \\\n+#define DF_REF_LOC(REF) (DF_REF_CLASS (REF) == DF_REF_REGULAR ? \\\n \t\t\t (REF)->regular_ref.loc : NULL)\n-#define DF_REF_BB(REF) (DF_REF_IS_ARTIFICIAL(REF) ? \\\n-                        (REF)->artificial_ref.bb : BLOCK_FOR_INSN (DF_REF_INSN(REF)))\n+#define DF_REF_BB(REF) (DF_REF_IS_ARTIFICIAL (REF) \\\n+\t\t\t? (REF)->artificial_ref.bb \\\n+\t\t\t: BLOCK_FOR_INSN (DF_REF_INSN (REF)))\n #define DF_REF_BBNO(REF) (DF_REF_BB (REF)->index)\n #define DF_REF_INSN_INFO(REF) ((REF)->base.insn_info)\n #define DF_REF_INSN(REF) ((REF)->base.insn_info->insn)\n@@ -660,7 +661,7 @@ struct df_d\n /* If DF_REF_IS_ARTIFICIAL () is true, this is not a real\n    definition/use, but an artificial one created to model always live\n    registers, eh uses, etc.  */\n-#define DF_REF_IS_ARTIFICIAL(REF) (DF_REF_CLASS(REF) == DF_REF_ARTIFICIAL)\n+#define DF_REF_IS_ARTIFICIAL(REF) (DF_REF_CLASS (REF) == DF_REF_ARTIFICIAL)\n #define DF_REF_REG_MARK(REF) (DF_REF_FLAGS_SET ((REF),DF_REF_REG_MARKER))\n #define DF_REF_REG_UNMARK(REF) (DF_REF_FLAGS_CLEAR ((REF),DF_REF_REG_MARKER))\n #define DF_REF_IS_REG_MARKED(REF) (DF_REF_FLAGS_IS_SET ((REF),DF_REF_REG_MARKER))\n@@ -722,35 +723,35 @@ struct df_d\n /* Macros to access the elements within the reg_info structure table.  */\n \n #define DF_REGNO_FIRST_DEF(REGNUM) \\\n-(DF_REG_DEF_GET(REGNUM) ? DF_REG_DEF_GET(REGNUM) : 0)\n+(DF_REG_DEF_GET(REGNUM) ? DF_REG_DEF_GET (REGNUM) : 0)\n #define DF_REGNO_LAST_USE(REGNUM) \\\n-(DF_REG_USE_GET(REGNUM) ? DF_REG_USE_GET(REGNUM) : 0)\n+(DF_REG_USE_GET(REGNUM) ? DF_REG_USE_GET (REGNUM) : 0)\n \n /* Macros to access the elements within the insn_info structure table.  */\n \n #define DF_INSN_SIZE() ((df)->insns_size)\n-#define DF_INSN_INFO_GET(INSN) (df->insns[(INSN_UID(INSN))])\n+#define DF_INSN_INFO_GET(INSN) (df->insns[(INSN_UID (INSN))])\n #define DF_INSN_INFO_SET(INSN,VAL) (df->insns[(INSN_UID (INSN))]=(VAL))\n #define DF_INSN_INFO_LUID(II) ((II)->luid)\n #define DF_INSN_INFO_DEFS(II) ((II)->defs)\n #define DF_INSN_INFO_USES(II) ((II)->uses)\n #define DF_INSN_INFO_EQ_USES(II) ((II)->eq_uses)\n \n-#define DF_INSN_LUID(INSN) (DF_INSN_INFO_LUID (DF_INSN_INFO_GET(INSN)))\n-#define DF_INSN_DEFS(INSN) (DF_INSN_INFO_DEFS (DF_INSN_INFO_GET(INSN)))\n-#define DF_INSN_USES(INSN) (DF_INSN_INFO_USES (DF_INSN_INFO_GET(INSN)))\n-#define DF_INSN_EQ_USES(INSN) (DF_INSN_INFO_EQ_USES (DF_INSN_INFO_GET(INSN)))\n+#define DF_INSN_LUID(INSN) (DF_INSN_INFO_LUID (DF_INSN_INFO_GET (INSN)))\n+#define DF_INSN_DEFS(INSN) (DF_INSN_INFO_DEFS (DF_INSN_INFO_GET (INSN)))\n+#define DF_INSN_USES(INSN) (DF_INSN_INFO_USES (DF_INSN_INFO_GET (INSN)))\n+#define DF_INSN_EQ_USES(INSN) (DF_INSN_INFO_EQ_USES (DF_INSN_INFO_GET (INSN)))\n \n #define DF_INSN_UID_GET(UID) (df->insns[(UID)])\n #define DF_INSN_UID_SET(UID,VAL) (df->insns[(UID)]=(VAL))\n-#define DF_INSN_UID_SAFE_GET(UID) (((unsigned)(UID) < DF_INSN_SIZE())\t\\\n+#define DF_INSN_UID_SAFE_GET(UID) (((unsigned)(UID) < DF_INSN_SIZE ())\t\\\n                                      ? DF_INSN_UID_GET (UID) \\\n                                      : NULL)\n-#define DF_INSN_UID_LUID(INSN) (DF_INSN_UID_GET(INSN)->luid)\n-#define DF_INSN_UID_DEFS(INSN) (DF_INSN_UID_GET(INSN)->defs)\n-#define DF_INSN_UID_USES(INSN) (DF_INSN_UID_GET(INSN)->uses)\n-#define DF_INSN_UID_EQ_USES(INSN) (DF_INSN_UID_GET(INSN)->eq_uses)\n-#define DF_INSN_UID_MWS(INSN) (DF_INSN_UID_GET(INSN)->mw_hardregs)\n+#define DF_INSN_UID_LUID(INSN) (DF_INSN_UID_GET (INSN)->luid)\n+#define DF_INSN_UID_DEFS(INSN) (DF_INSN_UID_GET (INSN)->defs)\n+#define DF_INSN_UID_USES(INSN) (DF_INSN_UID_GET (INSN)->uses)\n+#define DF_INSN_UID_EQ_USES(INSN) (DF_INSN_UID_GET (INSN)->eq_uses)\n+#define DF_INSN_UID_MWS(INSN) (DF_INSN_UID_GET (INSN)->mw_hardregs)\n \n /* An obstack for bitmap not related to specific dataflow problems.\n    This obstack should e.g. be used for bitmaps with a short life time"}, {"sha": "36094a19c9a6659ed43225d72ad0919d19f769b2", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -267,7 +267,7 @@ adjust_line (const char *line, int max_width, int *column_p)\n   int line_width = strlen (line);\n   int column = *column_p;\n \n-  right_margin = MIN(line_width - column, right_margin);\n+  right_margin = MIN (line_width - column, right_margin);\n   right_margin = max_width - right_margin;\n   if (line_width >= max_width && column > right_margin)\n     {\n@@ -354,7 +354,7 @@ bt_callback (void *data, uintptr_t pc, const char *filename, int lineno,\n   /* Skip functions in diagnostic.c.  */\n   if (*pcount == 0\n       && filename != NULL\n-      && strcmp (lbasename(filename), \"diagnostic.c\") == 0)\n+      && strcmp (lbasename (filename), \"diagnostic.c\") == 0)\n     return 0;\n \n   /* Print up to 20 functions.  We could make this a --param, but\n@@ -881,7 +881,7 @@ diagnostic_append_note (diagnostic_context *context,\n   pp_destroy_prefix (context->printer);\n   pp_set_prefix (context->printer, saved_prefix);\n   diagnostic_show_locus (context, &diagnostic);\n-  va_end(ap);\n+  va_end (ap);\n }\n \n bool"}, {"sha": "32dc514a3dd1415357925d2e79558afebbaa4003", "filename": "gcc/double-int.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fdouble-int.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fdouble-int.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdouble-int.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -1555,11 +1555,11 @@ mpz_get_double_int (const_tree type, mpz_t val, bool wrap)\n      for representing the value.  The code to calculate count is\n      extracted from the GMP manual, section \"Integer Import and Export\":\n      http://gmplib.org/manual/Integer-Import-and-Export.html  */\n-  numb = 8*sizeof(HOST_WIDE_INT);\n+  numb = 8 * sizeof (HOST_WIDE_INT);\n   count = (mpz_sizeinbase (val, 2) + numb-1) / numb;\n   if (count < 2)\n     count = 2;\n-  vp = (unsigned HOST_WIDE_INT *) alloca (count * sizeof(HOST_WIDE_INT));\n+  vp = (unsigned HOST_WIDE_INT *) alloca (count * sizeof (HOST_WIDE_INT));\n \n   vp[0] = 0;\n   vp[1] = 0;"}, {"sha": "1d04a2525837ddf96f60bcfe5a295f0cd13ef577", "filename": "gcc/dse.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -2916,8 +2916,8 @@ dse_step2_nospill (void)\n       if (group == clear_alias_group)\n \tcontinue;\n \n-      memset (group->offset_map_n, 0, sizeof(int) * group->offset_map_size_n);\n-      memset (group->offset_map_p, 0, sizeof(int) * group->offset_map_size_p);\n+      memset (group->offset_map_n, 0, sizeof (int) * group->offset_map_size_n);\n+      memset (group->offset_map_p, 0, sizeof (int) * group->offset_map_size_p);\n       bitmap_clear (group->group_kill);\n \n       EXECUTE_IF_SET_IN_BITMAP (group->store2_n, 0, j, bi)\n@@ -3749,8 +3749,8 @@ const pass_data pass_data_rtl_dse1 =\n class pass_rtl_dse1 : public rtl_opt_pass\n {\n public:\n-  pass_rtl_dse1(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_rtl_dse1, ctxt)\n+  pass_rtl_dse1 (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_rtl_dse1, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -3787,8 +3787,8 @@ const pass_data pass_data_rtl_dse2 =\n class pass_rtl_dse2 : public rtl_opt_pass\n {\n public:\n-  pass_rtl_dse2(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_rtl_dse2, ctxt)\n+  pass_rtl_dse2 (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_rtl_dse2, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "435d22dc8eb79ed776dfe3f731cecbaef51d1032", "filename": "gcc/dumpfile.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fdumpfile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fdumpfile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdumpfile.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -240,10 +240,10 @@ dump_open_alternate_stream (struct dump_file_info *dfi)\n   if (dfi->alt_stream)\n     return dfi->alt_stream;\n \n-  stream = strcmp(\"stderr\", dfi->alt_filename) == 0\n+  stream = strcmp (\"stderr\", dfi->alt_filename) == 0\n     ? stderr\n-    : strcmp(\"stdout\", dfi->alt_filename) == 0\n-    ?  stdout\n+    : strcmp (\"stdout\", dfi->alt_filename) == 0\n+    ? stdout\n     : fopen (dfi->alt_filename, dfi->alt_state < 0 ? \"w\" : \"a\");\n \n   if (!stream)\n@@ -404,10 +404,10 @@ dump_start (int phase, int *flag_ptr)\n   name = get_dump_file_name (phase);\n   if (name)\n     {\n-      stream = strcmp(\"stderr\", name) == 0\n+      stream = strcmp (\"stderr\", name) == 0\n           ? stderr\n-          : strcmp(\"stdout\", name) == 0\n-          ?  stdout\n+          : strcmp (\"stdout\", name) == 0\n+          ? stdout\n           : fopen (name, dfi->pstate < 0 ? \"w\" : \"a\");\n       if (!stream)\n         error (\"could not open dump file %qs: %m\", name);\n@@ -451,12 +451,12 @@ dump_finish (int phase)\n     return;\n   dfi = get_dump_file_info (phase);\n   if (dfi->pstream && (!dfi->pfilename\n-                       || (strcmp(\"stderr\", dfi->pfilename) != 0\n-                           && strcmp(\"stdout\", dfi->pfilename) != 0)))\n+                       || (strcmp (\"stderr\", dfi->pfilename) != 0\n+                           && strcmp (\"stdout\", dfi->pfilename) != 0)))\n     fclose (dfi->pstream);\n \n-  if (dfi->alt_stream && strcmp(\"stderr\", dfi->alt_filename) != 0\n-      && strcmp(\"stdout\", dfi->alt_filename) != 0)\n+  if (dfi->alt_stream && strcmp (\"stderr\", dfi->alt_filename) != 0\n+      && strcmp (\"stdout\", dfi->alt_filename) != 0)\n     fclose (dfi->alt_stream);\n \n   dfi->alt_stream = NULL;\n@@ -488,10 +488,10 @@ dump_begin (int phase, int *flag_ptr)\n     return NULL;\n   dfi = get_dump_file_info (phase);\n \n-  stream = strcmp(\"stderr\", name) == 0\n+  stream = strcmp (\"stderr\", name) == 0\n     ? stderr\n-    : strcmp(\"stdout\", name) == 0\n-    ?  stdout\n+    : strcmp (\"stdout\", name) == 0\n+    ? stdout\n     : fopen (name, dfi->pstate < 0 ? \"w\" : \"a\");\n \n   if (!stream)"}, {"sha": "69907f9fbf28fbf01319c9692c0110cf45214036", "filename": "gcc/dwarf2asm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fdwarf2asm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fdwarf2asm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2asm.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -315,7 +315,7 @@ dw2_asm_output_nstring (const char *str, size_t orig_len,\n \t  int c = str[i];\n \t  if (c == '\\\"' || c == '\\\\')\n \t    fputc ('\\\\', asm_out_file);\n-\t  if (ISPRINT(c))\n+\t  if (ISPRINT (c))\n \t    fputc (c, asm_out_file);\n \t  else\n \t    fprintf (asm_out_file, \"\\\\%o\", c);"}, {"sha": "5a096adcd0ff09b5577fbb8c69caa8a264e63270", "filename": "gcc/dwarf2cfi.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fdwarf2cfi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fdwarf2cfi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2cfi.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -2841,14 +2841,14 @@ create_cie_data (void)\n   dw_stack_pointer_regnum = DWARF_FRAME_REGNUM (STACK_POINTER_REGNUM);\n   dw_frame_pointer_regnum = DWARF_FRAME_REGNUM (HARD_FRAME_POINTER_REGNUM);\n \n-  memset (&cie_trace, 0, sizeof(cie_trace));\n+  memset (&cie_trace, 0, sizeof (cie_trace));\n   cur_trace = &cie_trace;\n \n   add_cfi_vec = &cie_cfi_vec;\n   cie_cfi_row = cur_row = new_cfi_row ();\n \n   /* On entry, the Canonical Frame Address is at SP.  */\n-  memset(&loc, 0, sizeof (loc));\n+  memset (&loc, 0, sizeof (loc));\n   loc.reg = dw_stack_pointer_regnum;\n   loc.offset = INCOMING_FRAME_SP_OFFSET;\n   def_cfa_1 (&loc);\n@@ -3268,7 +3268,7 @@ dump_cfi_row (FILE *f, dw_cfi_row *row)\n   if (!cfi)\n     {\n       dw_cfa_location dummy;\n-      memset(&dummy, 0, sizeof(dummy));\n+      memset (&dummy, 0, sizeof (dummy));\n       dummy.reg = INVALID_REGNUM;\n       cfi = def_cfa_0 (&dummy, &row->cfa);\n     }\n@@ -3391,8 +3391,8 @@ const pass_data pass_data_dwarf2_frame =\n class pass_dwarf2_frame : public rtl_opt_pass\n {\n public:\n-  pass_dwarf2_frame(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_dwarf2_frame, ctxt)\n+  pass_dwarf2_frame (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_dwarf2_frame, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "8d865d38d0e0ad969dbd4ceb2a04f9c6af415c57", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -4245,7 +4245,7 @@ index_addr_table_entry (void **h, void *v)\n   if (node->refcount == 0)\n     return 1;\n \n-  gcc_assert(node->index == NO_INDEX_ASSIGNED);\n+  gcc_assert (node->index == NO_INDEX_ASSIGNED);\n   node->index = *index;\n   *index += 1;\n \n@@ -6163,7 +6163,7 @@ generate_type_signature (dw_die_ref die, comdat_type_node *type_node)\n      context, if any.  This is stored in the type unit DIE for link-time\n      ODR (one-definition rule) checking.  */\n \n-  if (is_cxx() && name != NULL)\n+  if (is_cxx () && name != NULL)\n     {\n       md5_init_ctx (&ctx);\n \n@@ -6249,7 +6249,7 @@ same_dw_val_p (const dw_val_node *v1, const dw_val_node *v2, int *mark)\n     case dw_val_class_flag:\n       return v1->v.val_flag == v2->v.val_flag;\n     case dw_val_class_str:\n-      return !strcmp(v1->v.val_str->str, v2->v.val_str->str);\n+      return !strcmp (v1->v.val_str->str, v2->v.val_str->str);\n \n     case dw_val_class_addr:\n       r1 = v1->v.val_addr;\n@@ -6788,7 +6788,7 @@ contains_subprogram_definition (dw_die_ref die)\n \n   if (die->die_tag == DW_TAG_subprogram && ! is_declaration_die (die))\n     return 1;\n-  FOR_EACH_CHILD (die, c, if (contains_subprogram_definition(c)) return 1);\n+  FOR_EACH_CHILD (die, c, if (contains_subprogram_definition (c)) return 1);\n   return 0;\n }\n \n@@ -6860,7 +6860,7 @@ clone_tree (dw_die_ref die)\n   dw_die_ref c;\n   dw_die_ref clone = clone_die (die);\n \n-  FOR_EACH_CHILD (die, c, add_child_die (clone, clone_tree(c)));\n+  FOR_EACH_CHILD (die, c, add_child_die (clone, clone_tree (c)));\n \n   return clone;\n }\n@@ -7052,7 +7052,7 @@ copy_declaration_context (dw_die_ref unit, dw_die_ref die)\n             add_dwarf_attr (die, a);\n         }\n \n-      FOR_EACH_CHILD (decl, c, add_child_die (die, clone_tree(c)));\n+      FOR_EACH_CHILD (decl, c, add_child_die (die, clone_tree (c)));\n     }\n \n   if (decl->die_parent != NULL\n@@ -19109,7 +19109,7 @@ gen_compile_unit_die (const char *filename)\n \t  else if (strcmp (common_lang, TRANSLATION_UNIT_LANGUAGE (t)) == 0)\n \t    ;\n \t  else if (strncmp (common_lang, \"GNU C\", 5) == 0\n-\t\t    && strncmp(TRANSLATION_UNIT_LANGUAGE (t), \"GNU C\", 5) == 0)\n+\t\t    && strncmp (TRANSLATION_UNIT_LANGUAGE (t), \"GNU C\", 5) == 0)\n \t    /* Mixing C and C++ is ok, use C++ in that case.  */\n \t    common_lang = \"GNU C++\";\n \t  else\n@@ -21996,7 +21996,7 @@ index_string (void **h, void *v)\n   find_string_form (node);\n   if (node->form == DW_FORM_GNU_str_index && node->refcount > 0)\n     {\n-      gcc_assert(node->index == NO_INDEX_ASSIGNED);\n+      gcc_assert (node->index == NO_INDEX_ASSIGNED);\n       node->index = *index;\n       *index += 1;\n     }"}, {"sha": "85714f5d8a5bd63103c79556345142f2e73061ad", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -4090,7 +4090,7 @@ reorder_insns_nobb (rtx from, rtx to, rtx after)\n   NEXT_INSN (to) = NEXT_INSN (after);\n   PREV_INSN (from) = after;\n   NEXT_INSN (after) = from;\n-  if (after == get_last_insn())\n+  if (after == get_last_insn ())\n     set_last_insn (to);\n }\n \n@@ -4300,7 +4300,7 @@ emit_insn_after_1 (rtx first, rtx after, basic_block bb)\n   if (after_after)\n     PREV_INSN (after_after) = last;\n \n-  if (after == get_last_insn())\n+  if (after == get_last_insn ())\n     set_last_insn (last);\n \n   return last;\n@@ -4700,7 +4700,7 @@ emit_debug_insn_before (rtx pattern, rtx before)\n rtx\n emit_insn (rtx x)\n {\n-  rtx last = get_last_insn();\n+  rtx last = get_last_insn ();\n   rtx insn;\n \n   if (x == NULL_RTX)\n@@ -4747,7 +4747,7 @@ emit_insn (rtx x)\n rtx\n emit_debug_insn (rtx x)\n {\n-  rtx last = get_last_insn();\n+  rtx last = get_last_insn ();\n   rtx insn;\n \n   if (x == NULL_RTX)\n@@ -5804,9 +5804,9 @@ init_emit_once (void)\n        mode != VOIDmode;\n        mode = GET_MODE_WIDER_MODE (mode))\n     {\n-      FCONST0(mode).data.high = 0;\n-      FCONST0(mode).data.low = 0;\n-      FCONST0(mode).mode = mode;\n+      FCONST0 (mode).data.high = 0;\n+      FCONST0 (mode).data.low = 0;\n+      FCONST0 (mode).mode = mode;\n       const_tiny_rtx[0][(int) mode] = CONST_FIXED_FROM_FIXED_VALUE (\n \t\t\t\t      FCONST0 (mode), mode);\n     }\n@@ -5815,9 +5815,9 @@ init_emit_once (void)\n        mode != VOIDmode;\n        mode = GET_MODE_WIDER_MODE (mode))\n     {\n-      FCONST0(mode).data.high = 0;\n-      FCONST0(mode).data.low = 0;\n-      FCONST0(mode).mode = mode;\n+      FCONST0 (mode).data.high = 0;\n+      FCONST0 (mode).data.low = 0;\n+      FCONST0 (mode).mode = mode;\n       const_tiny_rtx[0][(int) mode] = CONST_FIXED_FROM_FIXED_VALUE (\n \t\t\t\t      FCONST0 (mode), mode);\n     }\n@@ -5826,17 +5826,17 @@ init_emit_once (void)\n        mode != VOIDmode;\n        mode = GET_MODE_WIDER_MODE (mode))\n     {\n-      FCONST0(mode).data.high = 0;\n-      FCONST0(mode).data.low = 0;\n-      FCONST0(mode).mode = mode;\n+      FCONST0 (mode).data.high = 0;\n+      FCONST0 (mode).data.low = 0;\n+      FCONST0 (mode).mode = mode;\n       const_tiny_rtx[0][(int) mode] = CONST_FIXED_FROM_FIXED_VALUE (\n \t\t\t\t      FCONST0 (mode), mode);\n \n       /* We store the value 1.  */\n-      FCONST1(mode).data.high = 0;\n-      FCONST1(mode).data.low = 0;\n-      FCONST1(mode).mode = mode;\n-      FCONST1(mode).data\n+      FCONST1 (mode).data.high = 0;\n+      FCONST1 (mode).data.low = 0;\n+      FCONST1 (mode).mode = mode;\n+      FCONST1 (mode).data\n \t= double_int_one.lshift (GET_MODE_FBIT (mode),\n \t\t\t\t HOST_BITS_PER_DOUBLE_INT,\n \t\t\t\t SIGNED_FIXED_POINT_MODE_P (mode));\n@@ -5848,17 +5848,17 @@ init_emit_once (void)\n        mode != VOIDmode;\n        mode = GET_MODE_WIDER_MODE (mode))\n     {\n-      FCONST0(mode).data.high = 0;\n-      FCONST0(mode).data.low = 0;\n-      FCONST0(mode).mode = mode;\n+      FCONST0 (mode).data.high = 0;\n+      FCONST0 (mode).data.low = 0;\n+      FCONST0 (mode).mode = mode;\n       const_tiny_rtx[0][(int) mode] = CONST_FIXED_FROM_FIXED_VALUE (\n \t\t\t\t      FCONST0 (mode), mode);\n \n       /* We store the value 1.  */\n-      FCONST1(mode).data.high = 0;\n-      FCONST1(mode).data.low = 0;\n-      FCONST1(mode).mode = mode;\n-      FCONST1(mode).data\n+      FCONST1 (mode).data.high = 0;\n+      FCONST1 (mode).data.low = 0;\n+      FCONST1 (mode).mode = mode;\n+      FCONST1 (mode).data\n \t= double_int_one.lshift (GET_MODE_FBIT (mode),\n \t\t\t\t HOST_BITS_PER_DOUBLE_INT,\n \t\t\t\t SIGNED_FIXED_POINT_MODE_P (mode));"}, {"sha": "5e0bc720e6fb95fbe32030828f6880bf85df1d78", "filename": "gcc/errors.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ferrors.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ferrors.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ferrors.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -48,7 +48,7 @@ warning (const char *format, ...)\n   fprintf (stderr, \"%s: warning: \", progname);\n   vfprintf (stderr, format, ap);\n   va_end (ap);\n-  fputc('\\n', stderr);\n+  fputc ('\\n', stderr);\n }\n \n \n@@ -63,7 +63,7 @@ error (const char *format, ...)\n   fprintf (stderr, \"%s: \", progname);\n   vfprintf (stderr, format, ap);\n   va_end (ap);\n-  fputc('\\n', stderr);\n+  fputc ('\\n', stderr);\n \n   have_error = 1;\n }\n@@ -80,7 +80,7 @@ fatal (const char *format, ...)\n   fprintf (stderr, \"%s: \", progname);\n   vfprintf (stderr, format, ap);\n   va_end (ap);\n-  fputc('\\n', stderr);\n+  fputc ('\\n', stderr);\n   exit (FATAL_EXIT_CODE);\n }\n "}, {"sha": "fb47fbb06cb18ab1e0453094c6a51af0444fd0b7", "filename": "gcc/except.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -641,7 +641,7 @@ eh_region_outermost (struct function *ifun, eh_region region_a,\n   gcc_assert (ifun->eh->region_array);\n   gcc_assert (ifun->eh->region_tree);\n \n-  b_outer = sbitmap_alloc (ifun->eh->region_array->length());\n+  b_outer = sbitmap_alloc (ifun->eh->region_array->length ());\n   bitmap_clear (b_outer);\n \n   do\n@@ -2021,8 +2021,8 @@ const pass_data pass_data_set_nothrow_function_flags =\n class pass_set_nothrow_function_flags : public rtl_opt_pass\n {\n public:\n-  pass_set_nothrow_function_flags(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_set_nothrow_function_flags, ctxt)\n+  pass_set_nothrow_function_flags (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_set_nothrow_function_flags, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -2652,8 +2652,8 @@ const pass_data pass_data_convert_to_eh_region_ranges =\n class pass_convert_to_eh_region_ranges : public rtl_opt_pass\n {\n public:\n-  pass_convert_to_eh_region_ranges(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_convert_to_eh_region_ranges, ctxt)\n+  pass_convert_to_eh_region_ranges (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_convert_to_eh_region_ranges, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "92c293879d567cb39a32e94394bc92532c5c65c7", "filename": "gcc/expmed.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -2806,7 +2806,7 @@ choose_mult_variant (enum machine_mode mode, HOST_WIDE_INT val,\n      `unsigned int' */\n   if (HOST_BITS_PER_INT >= GET_MODE_UNIT_BITSIZE (mode))\n     {\n-      op_cost = neg_cost(speed, mode);\n+      op_cost = neg_cost (speed, mode);\n       if (MULT_COST_LESS (&alg->cost, mult_cost))\n \t{\n \t  limit.cost = alg->cost.cost - op_cost;\n@@ -3124,7 +3124,7 @@ expand_mult (enum machine_mode mode, rtx op0, rtx op1, rtx target,\n \t     calculation of the synth_mult.  */\n \t  coeff = -(unsigned HOST_WIDE_INT) coeff;\n \t  max_cost = (set_src_cost (gen_rtx_MULT (mode, fake_reg, op1), speed)\n-\t\t      - neg_cost(speed, mode));\n+\t\t      - neg_cost (speed, mode));\n \t  if (max_cost <= 0)\n \t    goto skip_synth;\n \n@@ -3877,7 +3877,7 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n     {\n       if (rem_flag)\n \treturn const0_rtx;\n-      return expand_unop (mode, flag_trapv && GET_MODE_CLASS(mode) == MODE_INT\n+      return expand_unop (mode, flag_trapv && GET_MODE_CLASS (mode) == MODE_INT\n \t\t\t  ? negv_optab : neg_optab, op0, target, 0);\n     }\n "}, {"sha": "01cd9e66bdff6828b9a68acf9c1e427e952b2c12", "filename": "gcc/expr.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -1738,7 +1738,7 @@ emit_group_load_1 (rtx *tmps, rtx dst, rtx orig_src, tree type, int ssize)\n \t}\n       else if (CONSTANT_P (src) && GET_MODE (dst) != BLKmode\n                && XVECLEN (dst, 0) > 1)\n-        tmps[i] = simplify_gen_subreg (mode, src, GET_MODE(dst), bytepos);\n+        tmps[i] = simplify_gen_subreg (mode, src, GET_MODE (dst), bytepos);\n       else if (CONSTANT_P (src))\n \t{\n \t  HOST_WIDE_INT len = (HOST_WIDE_INT) bytelen;\n@@ -3247,10 +3247,10 @@ emit_move_complex (enum machine_mode mode, rtx x, rtx y)\n       && optab_handler (mov_optab, GET_MODE_INNER (mode)) != CODE_FOR_nothing\n       && !(REG_P (x)\n \t   && HARD_REGISTER_P (x)\n-\t   && hard_regno_nregs[REGNO(x)][mode] == 1)\n+\t   && hard_regno_nregs[REGNO (x)][mode] == 1)\n       && !(REG_P (y)\n \t   && HARD_REGISTER_P (y)\n-\t   && hard_regno_nregs[REGNO(y)][mode] == 1))\n+\t   && hard_regno_nregs[REGNO (y)][mode] == 1))\n     try_int = false;\n   /* Not possible if the values are inherently not adjacent.  */\n   else if (GET_CODE (x) == CONCAT || GET_CODE (y) == CONCAT)\n@@ -7560,7 +7560,7 @@ expand_expr_addr_expr_1 (tree exp, rtx target, enum machine_mode tmode,\n \n \t  if (TREE_ADDRESSABLE (exp)\n \t      && ! MEM_P (result)\n-\t      && ! targetm.calls.allocate_stack_slots_for_args())\n+\t      && ! targetm.calls.allocate_stack_slots_for_args ())\n \t    {\n \t      error (\"local frame unavailable (naked function?)\");\n \t      return result;"}, {"sha": "3952349e98936c1ec2062d49fac1051674f93b0c", "filename": "gcc/file-find.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ffile-find.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ffile-find.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffile-find.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -25,7 +25,7 @@ along with GCC; see the file COPYING3.  If not see\n static bool debug = false;\n \n void\n-find_file_set_debug(bool debug_state)\n+find_file_set_debug (bool debug_state)\n {\n   debug = debug_state;\n }"}, {"sha": "641ebe48eee51cd5f5ea926fcb8ffb9726ba0d74", "filename": "gcc/final.c", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -704,7 +704,7 @@ compute_alignments (void)\n   freq_threshold = freq_max / PARAM_VALUE (PARAM_ALIGN_THRESHOLD);\n \n   if (dump_file)\n-    fprintf(dump_file, \"freq_max: %i\\n\",freq_max);\n+    fprintf (dump_file, \"freq_max: %i\\n\",freq_max);\n   FOR_EACH_BB (bb)\n     {\n       rtx label = BB_HEAD (bb);\n@@ -716,9 +716,10 @@ compute_alignments (void)\n \t  || optimize_bb_for_size_p (bb))\n \t{\n \t  if (dump_file)\n-\t    fprintf(dump_file, \"BB %4i freq %4i loop %2i loop_depth %2i skipped.\\n\",\n-\t\t    bb->index, bb->frequency, bb->loop_father->num,\n-\t\t    bb_loop_depth (bb));\n+\t    fprintf (dump_file,\n+\t\t     \"BB %4i freq %4i loop %2i loop_depth %2i skipped.\\n\",\n+\t\t     bb->index, bb->frequency, bb->loop_father->num,\n+\t\t     bb_loop_depth (bb));\n \t  continue;\n \t}\n       max_log = LABEL_ALIGN (label);\n@@ -733,10 +734,11 @@ compute_alignments (void)\n \t}\n       if (dump_file)\n \t{\n-\t  fprintf(dump_file, \"BB %4i freq %4i loop %2i loop_depth %2i fall %4i branch %4i\",\n-\t\t  bb->index, bb->frequency, bb->loop_father->num,\n-\t\t  bb_loop_depth (bb),\n-\t\t  fallthru_frequency, branch_frequency);\n+\t  fprintf (dump_file, \"BB %4i freq %4i loop %2i loop_depth\"\n+\t\t   \" %2i fall %4i branch %4i\",\n+\t\t   bb->index, bb->frequency, bb->loop_father->num,\n+\t\t   bb_loop_depth (bb),\n+\t\t   fallthru_frequency, branch_frequency);\n \t  if (!bb->loop_father->inner && bb->loop_father->num)\n \t    fprintf (dump_file, \" inner_loop\");\n \t  if (bb->loop_father->header == bb)\n@@ -762,7 +764,7 @@ compute_alignments (void)\n \t{\n \t  log = JUMP_ALIGN (label);\n \t  if (dump_file)\n-\t    fprintf(dump_file, \"  jump alignment added.\\n\");\n+\t    fprintf (dump_file, \"  jump alignment added.\\n\");\n \t  if (max_log < log)\n \t    {\n \t      max_log = log;\n@@ -779,7 +781,7 @@ compute_alignments (void)\n \t{\n \t  log = LOOP_ALIGN (label);\n \t  if (dump_file)\n-\t    fprintf(dump_file, \"  internal loop alignment added.\\n\");\n+\t    fprintf (dump_file, \"  internal loop alignment added.\\n\");\n \t  if (max_log < log)\n \t    {\n \t      max_log = log;\n@@ -862,8 +864,8 @@ const pass_data pass_data_compute_alignments =\n class pass_compute_alignments : public rtl_opt_pass\n {\n public:\n-  pass_compute_alignments(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_compute_alignments, ctxt)\n+  pass_compute_alignments (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_compute_alignments, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -1123,7 +1125,7 @@ shorten_branches (rtx first)\n       INSN_ADDRESSES (uid) = insn_current_address + insn_lengths[uid];\n \n       if (NOTE_P (insn) || BARRIER_P (insn)\n-\t  || LABEL_P (insn) || DEBUG_INSN_P(insn))\n+\t  || LABEL_P (insn) || DEBUG_INSN_P (insn))\n \tcontinue;\n       if (INSN_DELETED_P (insn))\n \tcontinue;\n@@ -4489,8 +4491,8 @@ const pass_data pass_data_final =\n class pass_final : public rtl_opt_pass\n {\n public:\n-  pass_final(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_final, ctxt)\n+  pass_final (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_final, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -4535,8 +4537,8 @@ const pass_data pass_data_shorten_branches =\n class pass_shorten_branches : public rtl_opt_pass\n {\n public:\n-  pass_shorten_branches(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_shorten_branches, ctxt)\n+  pass_shorten_branches (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_shorten_branches, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -4699,8 +4701,8 @@ const pass_data pass_data_clean_state =\n class pass_clean_state : public rtl_opt_pass\n {\n public:\n-  pass_clean_state(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_clean_state, ctxt)\n+  pass_clean_state (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_clean_state, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "91ec58801190b3e21e3d13770dbfdd487000f525", "filename": "gcc/fixed-value.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ffixed-value.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ffixed-value.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixed-value.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -97,7 +97,7 @@ fixed_from_double_int (double_int payload, enum machine_mode mode)\n   else if (UNSIGNED_SCALAR_FIXED_POINT_MODE_P (mode))\n     value.data = payload.zext (GET_MODE_IBIT (mode) + GET_MODE_FBIT (mode));\n   else\n-    gcc_unreachable();\n+    gcc_unreachable ();\n \n   value.mode = mode;\n "}, {"sha": "72a43e04a44d845ae58404652077b57fcd5047a9", "filename": "gcc/fold-const.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -11711,8 +11711,8 @@ fold_binary_loc (location_t loc,\n       if (TREE_CODE (arg1) == INTEGER_CST)\n \t{\n \t  double_int cst1 = tree_to_double_int (arg1);\n-\t  double_int ncst1 = (-cst1).ext(TYPE_PRECISION (TREE_TYPE (arg1)),\n-\t\t\t\t\t TYPE_UNSIGNED (TREE_TYPE (arg1)));\n+\t  double_int ncst1 = (-cst1).ext (TYPE_PRECISION (TREE_TYPE (arg1)),\n+\t\t\t\t\t  TYPE_UNSIGNED (TREE_TYPE (arg1)));\n \t  if ((cst1 & ncst1) == ncst1\n \t      && multiple_of_p (type, arg0,\n \t\t\t\tdouble_int_to_tree (TREE_TYPE (arg1), ncst1)))"}, {"sha": "eb8aca91aaae3a89276c18d16829dbe07bc81f50", "filename": "gcc/function.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -1970,8 +1970,8 @@ const pass_data pass_data_instantiate_virtual_regs =\n class pass_instantiate_virtual_regs : public rtl_opt_pass\n {\n public:\n-  pass_instantiate_virtual_regs(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_instantiate_virtual_regs, ctxt)\n+  pass_instantiate_virtual_regs (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_instantiate_virtual_regs, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -2078,7 +2078,7 @@ aggregate_value_p (const_tree exp, const_tree fntype)\n bool\n use_register_for_decl (const_tree decl)\n {\n-  if (!targetm.calls.allocate_stack_slots_for_args())\n+  if (!targetm.calls.allocate_stack_slots_for_args ())\n     return true;\n \n   /* Honor volatile.  */\n@@ -7022,8 +7022,8 @@ const pass_data pass_data_leaf_regs =\n class pass_leaf_regs : public rtl_opt_pass\n {\n public:\n-  pass_leaf_regs(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_leaf_regs, ctxt)\n+  pass_leaf_regs (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_leaf_regs, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -7079,8 +7079,8 @@ const pass_data pass_data_thread_prologue_and_epilogue =\n class pass_thread_prologue_and_epilogue : public rtl_opt_pass\n {\n public:\n-  pass_thread_prologue_and_epilogue(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_thread_prologue_and_epilogue, ctxt)\n+  pass_thread_prologue_and_epilogue (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_thread_prologue_and_epilogue, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -7298,8 +7298,8 @@ const pass_data pass_data_match_asm_constraints =\n class pass_match_asm_constraints : public rtl_opt_pass\n {\n public:\n-  pass_match_asm_constraints(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_match_asm_constraints, ctxt)\n+  pass_match_asm_constraints (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_match_asm_constraints, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "d08710c9614f0c7615dd6d2fd243803e22708947", "filename": "gcc/fwprop.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -1504,8 +1504,8 @@ const pass_data pass_data_rtl_fwprop =\n class pass_rtl_fwprop : public rtl_opt_pass\n {\n public:\n-  pass_rtl_fwprop(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_rtl_fwprop, ctxt)\n+  pass_rtl_fwprop (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_rtl_fwprop, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -1570,8 +1570,8 @@ const pass_data pass_data_rtl_fwprop_addr =\n class pass_rtl_fwprop_addr : public rtl_opt_pass\n {\n public:\n-  pass_rtl_fwprop_addr(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_rtl_fwprop_addr, ctxt)\n+  pass_rtl_fwprop_addr (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_rtl_fwprop_addr, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "d7e05e3f35c5b4c255017f2ecf907502a74afc5b", "filename": "gcc/gcc-ar.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgcc-ar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgcc-ar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc-ar.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -123,7 +123,7 @@ setup_prefixes (const char *exec_path)\n }\n \n int \n-main(int ac, char **av)\n+main (int ac, char **av)\n {\n   const char *exe_name;\n   char *plugin;\n@@ -166,7 +166,7 @@ main(int ac, char **av)\n   nargv[1] = \"--plugin\";\n   nargv[2] = plugin;\n   if (is_ar && av[1] && av[1][0] != '-')\n-    av[1] = concat(\"-\", av[1], NULL);\n+    av[1] = concat (\"-\", av[1], NULL);\n   for (k = 1; k < ac; k++)\n     nargv[2 + k] = av[k];\n   nargv[2 + k] = NULL;\n@@ -176,18 +176,18 @@ main(int ac, char **av)\n   err_msg = pex_one (PEX_LAST|PEX_SEARCH, \n \t\t     exe_name, \n \t\t     CONST_CAST2 (char * const *, const char **, nargv),\n-\t\t     concat(\"gcc-\", exe_name, NULL), \n+\t\t     concat (\"gcc-\", exe_name, NULL),\n \t\t     NULL,NULL,  &status, &err);\n   if (err_msg) \n-    fprintf(stderr, \"Error running %s: %s\\n\", exe_name, err_msg);\n+    fprintf (stderr, \"Error running %s: %s\\n\", exe_name, err_msg);\n   else if (status)\n     {\n       if (WIFSIGNALED (status))\n \t{\n \t  int sig = WTERMSIG (status);\n \t  fprintf (stderr, \"%s terminated with signal %d [%s]%s\\n\",\n-\t\t   exe_name, sig, strsignal(sig),\n-\t\t   WCOREDUMP(status) ? \", core dumped\" : \"\");\n+\t\t   exe_name, sig, strsignal (sig),\n+\t\t   WCOREDUMP (status) ? \", core dumped\" : \"\");\n \t}\n       else if (WIFEXITED (status))\n \texit_code = WEXITSTATUS (status);"}, {"sha": "2bbc9426cf99b000bc38950bcbd4495c78f119ae", "filename": "gcc/gcc.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -1556,7 +1556,7 @@ init_spec (void)\n   /* Prepend \"--traditional-format\" to whatever asm_spec we had before.  */\n   {\n     static const char tf[] = \"--traditional-format \";\n-    obstack_grow (&obstack, tf, sizeof(tf) - 1);\n+    obstack_grow (&obstack, tf, sizeof (tf) - 1);\n     obstack_grow0 (&obstack, asm_spec, strlen (asm_spec));\n     asm_spec = XOBFINISH (&obstack, const char *);\n   }\n@@ -1566,19 +1566,19 @@ init_spec (void)\n     defined LINKER_HASH_STYLE\n # ifdef LINK_BUILDID_SPEC\n   /* Prepend LINK_BUILDID_SPEC to whatever link_spec we had before.  */\n-  obstack_grow (&obstack, LINK_BUILDID_SPEC, sizeof(LINK_BUILDID_SPEC) - 1);\n+  obstack_grow (&obstack, LINK_BUILDID_SPEC, sizeof (LINK_BUILDID_SPEC) - 1);\n # endif\n # ifdef LINK_EH_SPEC\n   /* Prepend LINK_EH_SPEC to whatever link_spec we had before.  */\n-  obstack_grow (&obstack, LINK_EH_SPEC, sizeof(LINK_EH_SPEC) - 1);\n+  obstack_grow (&obstack, LINK_EH_SPEC, sizeof (LINK_EH_SPEC) - 1);\n # endif\n # ifdef LINKER_HASH_STYLE\n   /* Prepend --hash-style=LINKER_HASH_STYLE to whatever link_spec we had\n      before.  */\n   {\n     static const char hash_style[] = \"--hash-style=\";\n-    obstack_grow (&obstack, hash_style, sizeof(hash_style) - 1);\n-    obstack_grow (&obstack, LINKER_HASH_STYLE, sizeof(LINKER_HASH_STYLE) - 1);\n+    obstack_grow (&obstack, hash_style, sizeof (hash_style) - 1);\n+    obstack_grow (&obstack, LINKER_HASH_STYLE, sizeof (LINKER_HASH_STYLE) - 1);\n     obstack_1grow (&obstack, ' ');\n   }\n # endif\n@@ -1644,7 +1644,7 @@ set_spec (const char *name, const char *spec, bool user_p)\n \n   /* Free the old spec.  */\n   if (old_spec && sl->alloc_p)\n-    free (CONST_CAST(char *, old_spec));\n+    free (CONST_CAST (char *, old_spec));\n \n   sl->user_p = user_p;\n   sl->alloc_p = true;\n@@ -2490,7 +2490,7 @@ find_a_file (const struct path_prefix *pprefix, const char *name, int mode,\n #endif\n \n #ifdef DEFAULT_LINKER\n-  if (! strcmp(name, \"ld\") && access (DEFAULT_LINKER, mode) == 0)\n+  if (! strcmp (name, \"ld\") && access (DEFAULT_LINKER, mode) == 0)\n     return xstrdup (DEFAULT_LINKER);\n #endif\n \n@@ -5741,11 +5741,11 @@ handle_braces (const char *p)\n       a_is_negated = false;\n       a_is_spectype = false;\n \n-      SKIP_WHITE();\n+      SKIP_WHITE ();\n       if (*p == '!')\n \tp++, a_is_negated = true;\n \n-      SKIP_WHITE();\n+      SKIP_WHITE ();\n       if (*p == '%' && p[1] == ':')\n \t{\n \t  atom = NULL;\n@@ -5760,7 +5760,7 @@ handle_braces (const char *p)\n \t    p++, a_is_spectype = true;\n \n \t  atom = p;\n-\t  while (ISIDNUM(*p) || *p == '-' || *p == '+' || *p == '='\n+\t  while (ISIDNUM (*p) || *p == '-' || *p == '+' || *p == '='\n \t\t || *p == ',' || *p == '.' || *p == '@')\n \t    p++;\n \t  end_atom = p;\n@@ -5769,7 +5769,7 @@ handle_braces (const char *p)\n \t    p++, a_is_starred = 1;\n \t}\n \n-      SKIP_WHITE();\n+      SKIP_WHITE ();\n       switch (*p)\n \t{\n \tcase '&': case '}':\n@@ -6074,13 +6074,13 @@ give_switch (int switchnum, int omit_first_word)\n \t      while (length-- && !IS_DIR_SEPARATOR (arg[length]))\n \t\tif (arg[length] == '.')\n \t\t  {\n-\t\t    (CONST_CAST(char *, arg))[length] = 0;\n+\t\t    (CONST_CAST (char *, arg))[length] = 0;\n \t\t    dot = 1;\n \t\t    break;\n \t\t  }\n \t      do_spec_1 (arg, 1, NULL);\n \t      if (dot)\n-\t\t(CONST_CAST(char *, arg))[length] = '.';\n+\t\t(CONST_CAST (char *, arg))[length] = '.';\n \t      do_spec_1 (suffix_subst, 1, NULL);\n \t    }\n \t  else\n@@ -8395,7 +8395,7 @@ get_random_number (void)\n   }\n #endif\n \n-  return ret ^ getpid();\n+  return ret ^ getpid ();\n }\n \n /* %:compare-debug-dump-opt spec function.  Save the last argument,\n@@ -8607,7 +8607,7 @@ replace_extension_spec_func (int argc, const char **argv)\n \n   name = xstrdup (argv[0]);\n \n-  for (i = strlen(name) - 1; i >= 0; i--)\n+  for (i = strlen (name) - 1; i >= 0; i--)\n     if (IS_DIR_SEPARATOR (name[i]))\n       break;\n "}, {"sha": "5a21c1f0691335da4f22a5da390ca7ec7334fd82", "filename": "gcc/gcov-io.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgcov-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgcov-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -386,7 +386,7 @@ gcov_write_summary (gcov_unsigned_t tag, const struct gcov_summary *summary)\n           h_cnt++;\n         }\n     }\n-  gcov_write_tag_length (tag, GCOV_TAG_SUMMARY_LENGTH(h_cnt));\n+  gcov_write_tag_length (tag, GCOV_TAG_SUMMARY_LENGTH (h_cnt));\n   gcov_write_unsigned (summary->checksum);\n   for (csum = summary->ctrs, ix = GCOV_COUNTERS_SUMMABLE; ix--; csum++)\n     {\n@@ -559,15 +559,15 @@ gcov_read_summary (struct gcov_summary *summary)\n           while (!cur_bitvector)\n             {\n               h_ix = bv_ix * 32;\n-              gcc_assert(bv_ix < GCOV_HISTOGRAM_BITVECTOR_SIZE);\n+              gcc_assert (bv_ix < GCOV_HISTOGRAM_BITVECTOR_SIZE);\n               cur_bitvector = histo_bitvector[bv_ix++];\n             }\n           while (!(cur_bitvector & 0x1))\n             {\n               h_ix++;\n               cur_bitvector >>= 1;\n             }\n-          gcc_assert(h_ix < GCOV_HISTOGRAM_SIZE);\n+          gcc_assert (h_ix < GCOV_HISTOGRAM_SIZE);\n \n           csum->histogram[h_ix].num_counters = gcov_read_unsigned ();\n           csum->histogram[h_ix].min_value = gcov_read_counter ();\n@@ -709,7 +709,7 @@ static void gcov_histogram_merge (gcov_bucket_type *tgt_histo,\n   gcov_bucket_type tmp_histo[GCOV_HISTOGRAM_SIZE];\n   int src_done = 0;\n \n-  memset(tmp_histo, 0, sizeof (gcov_bucket_type) * GCOV_HISTOGRAM_SIZE);\n+  memset (tmp_histo, 0, sizeof (gcov_bucket_type) * GCOV_HISTOGRAM_SIZE);\n \n   /* Assume that the counters are in the same relative order in both\n      histograms. Walk the histograms from largest to smallest entry,\n@@ -797,7 +797,7 @@ static void gcov_histogram_merge (gcov_bucket_type *tgt_histo,\n \n           /* The merged counters get placed in the new merged histogram\n              at the entry for the merged min_value.  */\n-          tmp_i = gcov_histo_index(merge_min);\n+          tmp_i = gcov_histo_index (merge_min);\n           gcc_assert (tmp_i < GCOV_HISTOGRAM_SIZE);\n           tmp_histo[tmp_i].num_counters += merge_num;\n           tmp_histo[tmp_i].cum_value += merge_cum;\n@@ -829,12 +829,13 @@ static void gcov_histogram_merge (gcov_bucket_type *tgt_histo,\n     }\n   /* At this point, tmp_i should be the smallest non-zero entry in the\n      tmp_histo.  */\n-  gcc_assert(tmp_i >= 0 && tmp_i < GCOV_HISTOGRAM_SIZE\n-             && tmp_histo[tmp_i].num_counters > 0);\n+  gcc_assert (tmp_i >= 0 && tmp_i < GCOV_HISTOGRAM_SIZE\n+\t      && tmp_histo[tmp_i].num_counters > 0);\n   tmp_histo[tmp_i].cum_value += src_cum;\n \n   /* Finally, copy the merged histogram into tgt_histo.  */\n-  memcpy(tgt_histo, tmp_histo, sizeof (gcov_bucket_type) * GCOV_HISTOGRAM_SIZE);\n+  memcpy (tgt_histo, tmp_histo,\n+\t  sizeof (gcov_bucket_type) * GCOV_HISTOGRAM_SIZE);\n }\n #endif /* !IN_GCOV */\n "}, {"sha": "ea8d9a7b76966815bdd0543fa4d26e42f37d60cb", "filename": "gcc/gcov-io.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgcov-io.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgcov-io.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.h?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -382,7 +382,7 @@ typedef unsigned HOST_WIDEST_INT gcov_type_unsigned;\n /* Return nonzero if SUB is an immediate subtag of TAG.  */\n #define GCOV_TAG_IS_SUBTAG(TAG,SUB)\t\t\t\t\\\n \t(GCOV_TAG_MASK (TAG) >> 8 == GCOV_TAG_MASK (SUB) \t\\\n-\t && !(((SUB) ^ (TAG)) & ~GCOV_TAG_MASK(TAG)))\n+\t && !(((SUB) ^ (TAG)) & ~GCOV_TAG_MASK (TAG)))\n \n /* Return nonzero if SUB is at a sublevel to TAG.  */\n #define GCOV_TAG_IS_SUBLEVEL(TAG,SUB)\t\t\t\t\\"}, {"sha": "9458812d86b9d751d6861c5d737098b1163f7c21", "filename": "gcc/gcov.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -398,7 +398,7 @@ static void executed_summary (unsigned, unsigned);\n static void function_summary (const coverage_t *, const char *);\n static const char *format_gcov (gcov_type, gcov_type, int);\n static void accumulate_line_counts (source_t *);\n-static void output_gcov_file(const char *, source_t *);\n+static void output_gcov_file (const char *, source_t *);\n static int output_branch_count (FILE *, int, const arc_t *);\n static void output_lines (FILE *, const source_t *);\n static char *make_gcov_file_name (const char *, const char *);\n@@ -448,8 +448,8 @@ main (int argc, char **argv)\n   for (; argno != argc; argno++)\n     {\n       if (flag_display_progress)\n-        printf(\"Processing file %d out of %d\\n\",  \n-               argno - first_arg + 1, argc - first_arg);\n+        printf (\"Processing file %d out of %d\\n\",\n+\t\targno - first_arg + 1, argc - first_arg);\n       process_file (argv[argno]);\n     }\n \n@@ -621,7 +621,7 @@ get_gcov_intermediate_filename (const char *file_name)\n   /* Find the 'basename'.  */\n   cptr = lbasename (file_name);\n \n-  result = XNEWVEC(char, strlen (cptr) + strlen (gcov) + 1);\n+  result = XNEWVEC (char, strlen (cptr) + strlen (gcov) + 1);\n   sprintf (result, \"%s%s\", cptr, gcov);\n \n   return result;\n@@ -699,7 +699,7 @@ output_intermediate_file (FILE *gcov_file, source_t *src)\n                   branch_type = (arc->count > 0) ? \"taken\" : \"nottaken\";\n                 else\n                   branch_type = \"notexec\";\n-                fprintf(gcov_file, \"branch:%d,%s\\n\", line_num, branch_type);\n+                fprintf (gcov_file, \"branch:%d,%s\\n\", line_num, branch_type);\n               }\n           }\n     }\n@@ -782,7 +782,7 @@ process_file (const char *file_name)\n }\n \n static void\n-output_gcov_file(const char *file_name, source_t *src)\n+output_gcov_file (const char *file_name, source_t *src)\n {\n   char *gcov_file_name = make_gcov_file_name (file_name, src->coverage.name);\n "}, {"sha": "bb9ba15ea8b0eca27f0f1b75dcb1468ff32d4c5c", "filename": "gcc/gcse.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -4169,8 +4169,8 @@ const pass_data pass_data_rtl_pre =\n class pass_rtl_pre : public rtl_opt_pass\n {\n public:\n-  pass_rtl_pre(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_rtl_pre, ctxt)\n+  pass_rtl_pre (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_rtl_pre, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -4208,8 +4208,8 @@ const pass_data pass_data_rtl_hoist =\n class pass_rtl_hoist : public rtl_opt_pass\n {\n public:\n-  pass_rtl_hoist(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_rtl_hoist, ctxt)\n+  pass_rtl_hoist (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_rtl_hoist, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "b0848cff7ecfdf50f80be5e429f5b762e89b6480", "filename": "gcc/genattr-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgenattr-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgenattr-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattr-common.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -33,7 +33,7 @@ static void\n write_upcase (const char *str)\n {\n   for (; *str; str++)\n-    putchar (TOUPPER(*str));\n+    putchar (TOUPPER (*str));\n }\n \n static void"}, {"sha": "0b92243a86dd895e618eab23408352d6973ad739", "filename": "gcc/genattr.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgenattr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgenattr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattr.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -361,10 +361,10 @@ main (int argc, char **argv)\n   /* Output flag masks for use by reorg.\n \n      Flags are used to hold branch direction for use by eligible_for_...  */\n-  printf(\"\\n#define ATTR_FLAG_forward\\t0x1\\n\");\n-  printf(\"#define ATTR_FLAG_backward\\t0x2\\n\");\n+  printf (\"\\n#define ATTR_FLAG_forward\\t0x1\\n\");\n+  printf (\"#define ATTR_FLAG_backward\\t0x2\\n\");\n \n-  puts(\"\\n#endif /* GCC_INSN_ATTR_H */\");\n+  puts (\"\\n#endif /* GCC_INSN_ATTR_H */\");\n \n   if (ferror (stdout) || fflush (stdout) || fclose (stdout))\n     return FATAL_EXIT_CODE;"}, {"sha": "973cade3fc2a6e29e788ef6c3b1a7bddc59f1041", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -90,9 +90,9 @@ along with GCC; see the file COPYING3.  If not see\n    `return_val' (ATTR_PERMANENT_P): This rtx is permanent and unique\n       (see attr_rtx).  */\n \n-#define ATTR_IND_SIMPLIFIED_P(RTX) (RTX_FLAG((RTX), unchanging))\n-#define ATTR_CURR_SIMPLIFIED_P(RTX) (RTX_FLAG((RTX), in_struct))\n-#define ATTR_PERMANENT_P(RTX) (RTX_FLAG((RTX), return_val))\n+#define ATTR_IND_SIMPLIFIED_P(RTX) (RTX_FLAG ((RTX), unchanging))\n+#define ATTR_CURR_SIMPLIFIED_P(RTX) (RTX_FLAG ((RTX), in_struct))\n+#define ATTR_PERMANENT_P(RTX) (RTX_FLAG ((RTX), return_val))\n \n #if 0\n #define strcmp_check(S1, S2) ((S1) == (S2)\t\t\\\n@@ -2815,7 +2815,7 @@ simplify_test_exp (rtx exp, int insn_code, int insn_index)\n \t      x = evaluate_eq_attr (exp, attr, av->value,\n \t\t\t\t    insn_code, insn_index);\n \t      x = SIMPLIFY_TEST_EXP (x, insn_code, insn_index);\n-\t      if (attr_rtx_cost(x) < 7)\n+\t      if (attr_rtx_cost (x) < 7)\n \t\treturn x;\n \t    }\n \t}\n@@ -4403,7 +4403,7 @@ write_upcase (FILE *outf, const char *str)\n   while (*str)\n     {\n       /* The argument of TOUPPER should not have side effects.  */\n-      fputc (TOUPPER(*str), outf);\n+      fputc (TOUPPER (*str), outf);\n       str++;\n     }\n }\n@@ -5285,7 +5285,7 @@ main (int argc, char **argv)\n       {\n         FILE *outf;\n \n-#define IS_ATTR_GROUP(X) (!strncmp(attr->name,X,strlen(X)))\n+#define IS_ATTR_GROUP(X) (!strncmp (attr->name, X, strlen (X)))\n \tif (IS_ATTR_GROUP (\"*internal_dfa_insn_code\"))\n \t  outf = dfa_file;\n \telse if (IS_ATTR_GROUP (\"*insn_default_latency\"))"}, {"sha": "a0bf0767aa95691493bf2f65d733add3c3cbc658", "filename": "gcc/genautomata.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgenautomata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgenautomata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenautomata.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -5533,7 +5533,7 @@ static reserv_sets_t\n form_reservs_matter (automaton_t automaton)\n {\n   int cycle, unit;\n-  reserv_sets_t reservs_matter = alloc_empty_reserv_sets();\n+  reserv_sets_t reservs_matter = alloc_empty_reserv_sets ();\n \n   for (cycle = 0; cycle < max_cycles_num; cycle++)\n     for (unit = 0; unit < description->units_num; unit++)\n@@ -7558,7 +7558,7 @@ output_trans_table (automaton_t automaton)\n {\n   size_t i;\n   arc_t arc;\n-  vla_hwint_t transition_vect = vla_hwint_t();\n+  vla_hwint_t transition_vect = vla_hwint_t ();\n \n   undefined_vect_el_value = automaton->achieved_states_num;\n   automaton->trans_table = create_state_ainsn_table (automaton);\n@@ -7742,7 +7742,7 @@ output_dead_lock_vect (automaton_t automaton)\n {\n   size_t i;\n   arc_t arc;\n-  vla_hwint_t dead_lock_vect = vla_hwint_t();\n+  vla_hwint_t dead_lock_vect = vla_hwint_t ();\n \n   /* Create vect of pointers to states ordered by num of\n      transitions from the state (state with the maximum num is the\n@@ -7787,7 +7787,7 @@ output_dead_lock_vect (automaton_t automaton)\n static void\n output_reserved_units_table (automaton_t automaton)\n {\n-  vla_hwint_t reserved_units_table = vla_hwint_t();\n+  vla_hwint_t reserved_units_table = vla_hwint_t ();\n   int state_byte_size;\n   int reserved_units_size;\n   size_t n;"}, {"sha": "498dd72e375b773cbeb3d2797542e8e91029452e", "filename": "gcc/genconfig.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgenconfig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgenconfig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenconfig.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -355,7 +355,7 @@ main (int argc, char **argv)\n       printf (\"#define MAX_INSNS_PER_PEEP2 %d\\n\", max_insns_per_peep2);\n     }\n \n-  puts(\"\\n#endif /* GCC_INSN_CONFIG_H */\");\n+  puts (\"\\n#endif /* GCC_INSN_CONFIG_H */\");\n \n   if (ferror (stdout) || fflush (stdout) || fclose (stdout))\n     return FATAL_EXIT_CODE;"}, {"sha": "d4bb301320dc7839e49be745132b067dc00bc469", "filename": "gcc/genemit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgenemit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgenemit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenemit.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -68,7 +68,7 @@ print_code (RTX_CODE code)\n {\n   const char *p1;\n   for (p1 = GET_RTX_NAME (code); *p1; p1++)\n-    putchar (TOUPPER(*p1));\n+    putchar (TOUPPER (*p1));\n }\n \n static void"}, {"sha": "35fc91e880618935510053cb34554d0296fe63c8", "filename": "gcc/genextract.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgenextract.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgenextract.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenextract.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -165,9 +165,9 @@ gen_insn (rtx insn, int insn_code_number)\n   p->duplocs = p->oplocs + op_count;\n   p->dupnums = (int *)(p->duplocs + dup_count);\n \n-  memcpy(p->oplocs,  acc.oplocs.address(),   op_count*sizeof(locstr));\n-  memcpy(p->duplocs, acc.duplocs.address(), dup_count*sizeof(locstr));\n-  memcpy(p->dupnums, acc.dupnums.address(), dup_count*sizeof(int));\n+  memcpy (p->oplocs, acc.oplocs.address (), op_count * sizeof (locstr));\n+  memcpy (p->duplocs, acc.duplocs.address (), dup_count * sizeof (locstr));\n+  memcpy (p->dupnums, acc.dupnums.address (), dup_count * sizeof (int));\n \n  done:\n   acc.oplocs.release ();\n@@ -334,7 +334,7 @@ print_path (const char *path)\n     {\n       if (ISLOWER (path[i]))\n \tprintf (\", 0, %d)\", path[i] - 'a');\n-      else if (ISDIGIT(path[i]))\n+      else if (ISDIGIT (path[i]))\n \tprintf (\", %d)\", path[i] - '0');\n       else\n \tgcc_unreachable ();"}, {"sha": "80d8315e41b02693f1f6011ae6fd60fe9d861fbd", "filename": "gcc/genflags.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgenflags.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgenflags.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenflags.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -109,7 +109,7 @@ gen_macro (const char *name, int real, int expect)\n   for (i = 0; name[i]; i++)\n     putchar (TOUPPER (name[i]));\n \n-  putchar('(');\n+  putchar ('(');\n   for (i = 0; i < expect - 1; i++)\n     printf (\"%c, \", i + 'A');\n   printf (\"%c) gen_%s (\", i + 'A', name);\n@@ -290,7 +290,7 @@ main (int argc, char **argv)\n   for (insn_ptr = insns; *insn_ptr; insn_ptr++)\n     gen_proto (*insn_ptr);\n \n-  puts(\"\\n#endif /* GCC_INSN_FLAGS_H */\");\n+  puts (\"\\n#endif /* GCC_INSN_FLAGS_H */\");\n \n   if (have_error || ferror (stdout) || fflush (stdout) || fclose (stdout))\n     return FATAL_EXIT_CODE;"}, {"sha": "4a35683c8969690270aa05d591734ea958a359e4", "filename": "gcc/gengenrtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgengenrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgengenrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengenrtl.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -37,7 +37,7 @@ static const struct rtx_definition defs[] =\n {\n #include \"rtl.def\"\t\t/* rtl expressions are documented here */\n };\n-#define NUM_RTX_CODE ARRAY_SIZE(defs)\n+#define NUM_RTX_CODE ARRAY_SIZE (defs)\n \n static const char *formats[NUM_RTX_CODE];\n \f"}, {"sha": "a019aaf353e4642a2b534ffd2b9c8cf61e138886", "filename": "gcc/gengtype-state.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgengtype-state.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgengtype-state.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype-state.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -142,7 +142,7 @@ static long state_bol = 0;\t/* offset of beginning of line */\n class s_expr_writer\n {\n public:\n-  s_expr_writer();\n+  s_expr_writer ();\n \n   void write_new_line ();\n   void write_any_indent (int leading_spaces);\n@@ -159,7 +159,7 @@ class s_expr_writer\n class state_writer : public s_expr_writer\n {\n public:\n-  state_writer();\n+  state_writer ();\n \n private:\n   void write_state_fileloc (struct fileloc *floc);\n@@ -205,7 +205,7 @@ class state_writer : public s_expr_writer\n \n \n /* class s_expr_writer's trivial constructor.  */\n-s_expr_writer::s_expr_writer()\n+s_expr_writer::s_expr_writer ()\n   : indent_amount_(0),\n     had_recent_newline_(0)\n {\n@@ -269,9 +269,9 @@ s_expr_writer::end_s_expr (void)\n \n \n /* class state_writer's trivial constructor.  */\n-state_writer::state_writer()\n-  : s_expr_writer(),\n-    state_written_type_count(0)\n+state_writer::state_writer ()\n+  : s_expr_writer (),\n+    state_written_type_count (0)\n {\n }\n \n@@ -309,7 +309,7 @@ fatal_reading_state (struct state_token_st* tok, const char*msg)\n     else\t\t\t\t\t\t\\\n       fatal (\"%s:%d: Invalid state file; \" Fmt,\t\t\\\n \t     state_path, state_line, __VA_ARGS__);\t\\\n-  } while(0)\n+  } while (0)\n \n \n /* Find or allocate an identifier in our name hash table.  */"}, {"sha": "b9bef4df76c12ae2e55ff40c3d71f0eeb1129a6f", "filename": "gcc/gengtype.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -617,7 +617,7 @@ type_for_name (const char *s)\n          extern GTY(()) gcc::some_type *some_ptr;\n      where the autogenerated functions will refer to simply \"some_type\",\n      where they can be resolved into their namespace.  */\n-  if (0 == strncmp(s, \"gcc::\", 5))\n+  if (0 == strncmp (s, \"gcc::\", 5))\n     s += 5;\n \n   for (p = typedefs; p != NULL; p = p->next)\n@@ -953,7 +953,7 @@ create_field_at (pair_p next, type_p type, const char *name, options_p opt,\n /* Create a fake field with the given type and name.  NEXT is the next\n    field in the chain.  */\n #define create_field(next,type,name) \\\n-    create_field_all(next,type,name, 0, this_file, __LINE__)\n+    create_field_all (next,type,name, 0, this_file, __LINE__)\n \n /* Like create_field, but the field is only valid when condition COND\n    is true.  */\n@@ -2131,7 +2131,7 @@ matching_file_name_substitute (const char *filnam, regmatch_t pmatch[10],\n \telse\n \t  {\n \t    /* This can happen only when files_rules is buggy! */\n-\t    gcc_unreachable();\n+\t    gcc_unreachable ();\n \t  }\n \t/* Always skip the character after the dollar.  */\n \tpt++;\n@@ -2544,7 +2544,7 @@ output_mangled_typename (outf_p of, const_type_p t)\n \t  oprintf (of, \"%lu%s\", (unsigned long) strlen (id_for_tag),\n \t\t   id_for_tag);\n \t  if (id_for_tag != t->u.s.tag)\n-\t    free (CONST_CAST(char *, id_for_tag));\n+\t    free (CONST_CAST (char *, id_for_tag));\n \t}\n \tbreak;\n       case TYPE_PARAM_STRUCT:\n@@ -3329,7 +3329,7 @@ write_marker_function_name (outf_p of, type_p s, const char *prefix)\n       const char *id_for_tag = filter_type_name (s->u.s.tag);\n       oprintf (of, \"gt_%sx_%s\", prefix, id_for_tag);\n       if (id_for_tag != s->u.s.tag)\n-\tfree (CONST_CAST(char *, id_for_tag));\n+\tfree (CONST_CAST (char *, id_for_tag));\n     }\n   else if (s->kind == TYPE_PARAM_STRUCT)\n     {\n@@ -3663,7 +3663,7 @@ write_types (outf_p output_header, type_p structures, type_p param_structs,\n \t\t\t   \"#define gt_%sx_%s gt_%sx_%s\\n\",\n \t\t\t   wtd->prefix, s->u.s.tag, wtd->prefix, t_id_for_tag);\n \t\t  if (t_id_for_tag != t->u.s.tag)\n-\t\t    free (CONST_CAST(char *, t_id_for_tag));\n+\t\t    free (CONST_CAST (char *, t_id_for_tag));\n \t\t}\n \t      else\n \t\terror_at_line (&s->u.s.line,\n@@ -3679,7 +3679,7 @@ write_types (outf_p output_header, type_p structures, type_p param_structs,\n \t\t wtd->prefix, s_id_for_tag);\n \n \tif (s_id_for_tag != s->u.s.tag)\n-\t  free (CONST_CAST(char *, s_id_for_tag));\n+\t  free (CONST_CAST (char *, s_id_for_tag));\n \n \tif (s->u.s.line.file == NULL)\n \t  {\n@@ -4373,7 +4373,7 @@ write_root (outf_p f, pair_p v, type_p type, const char *name, int has_length,\n \t    else\n \t      oprintf (f, \"    NULL\");\n \t    if (id_for_tag != tp->u.s.tag)\n-\t      free (CONST_CAST(char *, id_for_tag));\n+\t      free (CONST_CAST (char *, id_for_tag));\n \t  }\n \telse if (!has_length && tp->kind == TYPE_PARAM_STRUCT)\n \t  {\n@@ -4789,7 +4789,7 @@ write_typed_alloc_def (outf_p f,\n     oprintf (f, \", n\");\n   oprintf (f, \" MEM_STAT_INFO)))\\n\");\n   if (type_name_as_id != type_name)\n-    free (CONST_CAST(char *, type_name_as_id));\n+    free (CONST_CAST (char *, type_name_as_id));\n }\n \n /* Writes a typed allocator definition into output F for a struct or\n@@ -4856,7 +4856,7 @@ write_typed_alloc_defns (outf_p f,\n \t relevant to plugin input files.  */\n       if (nb_plugin_files > 0) \n \t{\n-\t  struct fileloc* filoc = type_fileloc(s);\n+\t  struct fileloc* filoc = type_fileloc (s);\n \t  if (!filoc || !filoc->file->inpisplugin)\n \t    continue;\n \t};\n@@ -5470,7 +5470,7 @@ main (int argc, char **argv)\n          we can see them.  We should initialize them before calling\n          read_input_list.  */\n #define POS_HERE(Call) do { pos.file = this_file; pos.line = __LINE__; \\\n-\tCall;} while(0)\n+\tCall;} while (0)\n       POS_HERE (do_scalar_typedef (\"CUMULATIVE_ARGS\", &pos));\n       POS_HERE (do_scalar_typedef (\"REAL_VALUE_TYPE\", &pos));\n       POS_HERE (do_scalar_typedef (\"FIXED_VALUE_TYPE\", &pos));"}, {"sha": "a0b2f21f11b52ad37d5db5d49692d6b8122b0ac6", "filename": "gcc/genmodes.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgenmodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgenmodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmodes.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -418,7 +418,7 @@ complete_all_modes (void)\n }\n \n /* For each mode in class CLASS, construct a corresponding complex mode.  */\n-#define COMPLEX_MODES(C) make_complex_modes(MODE_##C, __FILE__, __LINE__)\n+#define COMPLEX_MODES(C) make_complex_modes (MODE_##C, __FILE__, __LINE__)\n static void\n make_complex_modes (enum mode_class cl,\n \t\t    const char *file, unsigned int line)\n@@ -474,7 +474,7 @@ make_complex_modes (enum mode_class cl,\n \n /* For all modes in class CL, construct vector modes of width\n    WIDTH, having as many components as necessary.  */\n-#define VECTOR_MODES(C, W) make_vector_modes(MODE_##C, W, __FILE__, __LINE__)\n+#define VECTOR_MODES(C, W) make_vector_modes (MODE_##C, W, __FILE__, __LINE__)\n static void ATTRIBUTE_UNUSED\n make_vector_modes (enum mode_class cl, unsigned int width,\n \t\t   const char *file, unsigned int line)\n@@ -522,7 +522,8 @@ make_vector_modes (enum mode_class cl, unsigned int width,\n \n /* Input.  */\n \n-#define _SPECIAL_MODE(C, N) make_special_mode(MODE_##C, #N, __FILE__, __LINE__)\n+#define _SPECIAL_MODE(C, N) \\\n+  make_special_mode (MODE_##C, #N, __FILE__, __LINE__)\n #define RANDOM_MODE(N) _SPECIAL_MODE (RANDOM, N)\n #define CC_MODE(N) _SPECIAL_MODE (CC, N)\n \n@@ -704,11 +705,11 @@ make_vector_mode (enum mode_class bclass,\n #define _ADD_ADJUST(A, M, X, C1, C2) \\\n   new_adjust (#M, &adj_##A, #A, #X, MODE_##C1, MODE_##C2, __FILE__, __LINE__)\n \n-#define ADJUST_BYTESIZE(M, X)  _ADD_ADJUST(bytesize, M, X, RANDOM, RANDOM)\n-#define ADJUST_ALIGNMENT(M, X) _ADD_ADJUST(alignment, M, X, RANDOM, RANDOM)\n-#define ADJUST_FLOAT_FORMAT(M, X)    _ADD_ADJUST(format, M, X, FLOAT, FLOAT)\n-#define ADJUST_IBIT(M, X)  _ADD_ADJUST(ibit, M, X, ACCUM, UACCUM)\n-#define ADJUST_FBIT(M, X)  _ADD_ADJUST(fbit, M, X, FRACT, UACCUM)\n+#define ADJUST_BYTESIZE(M, X)  _ADD_ADJUST (bytesize, M, X, RANDOM, RANDOM)\n+#define ADJUST_ALIGNMENT(M, X) _ADD_ADJUST (alignment, M, X, RANDOM, RANDOM)\n+#define ADJUST_FLOAT_FORMAT(M, X)    _ADD_ADJUST (format, M, X, FLOAT, FLOAT)\n+#define ADJUST_IBIT(M, X)  _ADD_ADJUST (ibit, M, X, ACCUM, UACCUM)\n+#define ADJUST_FBIT(M, X)  _ADD_ADJUST (fbit, M, X, FRACT, UACCUM)\n \n static void\n create_modes (void)"}, {"sha": "9c7cf2c06a4744e1a7dcd091a8f72cebe78f08ce", "filename": "gcc/genopinit.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -194,7 +194,7 @@ match_pattern (pattern *p, const char *name, const char *pat)\n \t    for (i = (MAX_MACHINE_MODE) - 1; i >= 0; i--)\n \t      {\n \t\tconst char *p, *q;\n-\t\tfor (p = GET_MODE_NAME(i), q = name; *p; p++, q++)\n+\t\tfor (p = GET_MODE_NAME (i), q = name; *p; p++, q++)\n \t\t  if (TOLOWER (*p) != *q)\n \t\t    break;\n \t\tif (*p == 0\n@@ -372,7 +372,7 @@ main (int argc, char **argv)\n   /* Sort the (real) optabs.  Better than forcing the optabs.def file to\n      remain sorted by kind.  We also scrogged any real ordering with the\n      purging of the X patterns above.  */\n-  qsort (optabs, n, sizeof(optab_def), optab_kind_cmp);\n+  qsort (optabs, n, sizeof (optab_def), optab_kind_cmp);\n \n   /* Emit the optab enumeration for the header file.  */\n   fprintf (h_file, \"enum optab_tag {\\n\");"}, {"sha": "c3a0936fc97ff0ec267660022ef6fda9e880e514", "filename": "gcc/genoutput.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgenoutput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgenoutput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenoutput.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -286,9 +286,9 @@ output_operand_data (void)\n \tpred = lookup_predicate (d->predicate);\n       printf (\"    %d\\n\", pred && pred->codes[MEM]);\n \n-      printf(\"  },\\n\");\n+      printf (\"  },\\n\");\n     }\n-  printf(\"};\\n\\n\\n\");\n+  printf (\"};\\n\\n\\n\");\n }\n \n static void\n@@ -415,7 +415,7 @@ output_insn_data (void)\n       printf (\"    %d,\\n\", d->n_alternatives);\n       printf (\"    %d\\n\", d->output_format);\n \n-      printf(\"  },\\n\");\n+      printf (\"  },\\n\");\n     }\n   printf (\"};\\n\\n\\n\");\n }\n@@ -1112,7 +1112,7 @@ main (int argc, char **argv)\n       next_index_number++;\n     }\n \n-  printf(\"\\n\\n\");\n+  printf (\"\\n\\n\");\n   output_operand_data ();\n   output_insn_data ();\n   output_get_insn_name ();\n@@ -1223,7 +1223,7 @@ note_constraint (rtx exp, int lineno)\n \t}\n     }\n   new_cdata = XNEWVAR (struct constraint_data, sizeof (struct constraint_data) + namelen);\n-  strcpy (CONST_CAST(char *, new_cdata->name), name);\n+  strcpy (CONST_CAST (char *, new_cdata->name), name);\n   new_cdata->namelen = namelen;\n   new_cdata->lineno = lineno;\n   new_cdata->next_this_letter = *slot;"}, {"sha": "a14d061a50bcf3b9a4a79c89a52f703347bf63be", "filename": "gcc/genpeep.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgenpeep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgenpeep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenpeep.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -334,7 +334,7 @@ print_code (RTX_CODE code)\n {\n   const char *p1;\n   for (p1 = GET_RTX_NAME (code); *p1; p1++)\n-    putchar (TOUPPER(*p1));\n+    putchar (TOUPPER (*p1));\n }\n \n extern int main (int, char **);"}, {"sha": "f3d9dac9c55008bcb4d078aff0cdc77e237a58c7", "filename": "gcc/genpreds.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgenpreds.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgenpreds.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenpreds.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -529,7 +529,7 @@ write_match_code_switch (rtx exp)\n \t  putchar (TOUPPER (*code));\n \t  code++;\n \t}\n-      fputs(\":\\n\", stdout);\n+      fputs (\":\\n\", stdout);\n     }\n }\n \n@@ -596,9 +596,9 @@ write_predicate_stmts (rtx exp)\n       break;\n     }\n \n-  fputs(\"  return \",stdout);\n+  fputs (\"  return \",stdout);\n   write_predicate_expr (exp);\n-  fputs(\";\\n\", stdout);\n+  fputs (\";\\n\", stdout);\n }\n \n /* Given a predicate, write out a complete C function to compute it.  */\n@@ -932,7 +932,7 @@ write_lookup_constraint (void)\n \t\"  switch (str[0])\\n\"\n \t\"    {\");\n \n-  for (i = 0; i < ARRAY_SIZE(constraints_by_letter_table); i++)\n+  for (i = 0; i < ARRAY_SIZE (constraints_by_letter_table); i++)\n     {\n       struct constraint_data *c = constraints_by_letter_table[i];\n       if (!c)\n@@ -975,7 +975,7 @@ write_insn_constraint_len (void)\n \t\"  switch (fc)\\n\"\n \t\"    {\");\n \n-  for (i = 0; i < ARRAY_SIZE(constraints_by_letter_table); i++)\n+  for (i = 0; i < ARRAY_SIZE (constraints_by_letter_table); i++)\n     {\n       struct constraint_data *c = constraints_by_letter_table[i];\n "}, {"sha": "814be7d17e39a35734066d1461d6f6e09ce108bc", "filename": "gcc/genrecog.c", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -58,7 +58,7 @@\n #include \"gensupport.h\"\n \n #define OUTPUT_LABEL(INDENT_STRING, LABEL_NUMBER) \\\n-  printf(\"%sL%d: ATTRIBUTE_UNUSED_LABEL\\n\", (INDENT_STRING), (LABEL_NUMBER))\n+  printf (\"%sL%d: ATTRIBUTE_UNUSED_LABEL\\n\", (INDENT_STRING), (LABEL_NUMBER))\n \n /* Ways of obtaining an rtx to be tested.  */\n enum position_type {\n@@ -1619,7 +1619,7 @@ write_afterward (struct decision *start, struct decision *afterward,\n \t\t const char *indent)\n {\n   if (!afterward || start->subroutine_number > 0)\n-    printf(\"%sgoto ret0;\\n\", indent);\n+    printf (\"%sgoto ret0;\\n\", indent);\n   else\n     {\n       change_state (start->position, afterward->position, indent);\n@@ -1669,7 +1669,7 @@ write_switch (struct decision *start, int depth)\n       struct decision *ret;\n       RTX_CODE code;\n \n-      memset (codemap, 0, sizeof(codemap));\n+      memset (codemap, 0, sizeof (codemap));\n \n       printf (\"  switch (GET_CODE (x%d))\\n    {\\n\", depth);\n       code = p->tests->u.code;\n@@ -1762,7 +1762,8 @@ write_switch (struct decision *start, int depth)\n       if (type == DT_elt_zero_wide_safe)\n \t{\n \t  indent = \"  \";\n-\t  printf(\"  if ((int) XWINT (x%d, 0) == XWINT (x%d, 0))\\n\", depth, depth);\n+\t  printf (\"  if ((int) XWINT (x%d, 0) == XWINT (x%d, 0))\\n\",\n+\t\t  depth, depth);\n \t}\n       printf (\"%s  switch (\", indent);\n       switch (type)\n@@ -1937,7 +1938,7 @@ write_action (struct decision *p, struct decision_test *test,\n \n   if (test->type == DT_accept_op)\n     {\n-      printf(\"%soperands[%d] = x%d;\\n\", indent, test->u.opno, depth);\n+      printf (\"%soperands[%d] = x%d;\\n\", indent, test->u.opno, depth);\n \n       /* Only allow DT_accept_insn to follow.  */\n       if (test->next)\n@@ -1992,7 +1993,7 @@ write_action (struct decision *p, struct decision_test *test,\n     }\n   else\n     {\n-      printf(\"%sgoto L%d;\\n\", indent, success->number);\n+      printf (\"%sgoto L%d;\\n\", indent, success->number);\n       success->need_label = 1;\n     }\n \n@@ -2357,7 +2358,7 @@ make_insn_sequence (rtx insn, enum routine_type type)\n \n   validate_pattern (x, insn, NULL_RTX, 0);\n \n-  memset(&head, 0, sizeof(head));\n+  memset (&head, 0, sizeof (head));\n   last = add_to_sequence (x, &head, &root_pos, type, 1);\n \n   /* Find the end of the test chain on the last node.  */\n@@ -2423,7 +2424,7 @@ make_insn_sequence (rtx insn, enum routine_type type)\n \t\t}\n \n \t      /* Recognize it.  */\n-\t      memset (&clobber_head, 0, sizeof(clobber_head));\n+\t      memset (&clobber_head, 0, sizeof (clobber_head));\n \t      last = add_to_sequence (new_rtx, &clobber_head, &root_pos,\n \t\t\t\t      type, 1);\n \n@@ -2493,7 +2494,7 @@ process_tree (struct decision_head *head, enum routine_type subroutine_type)\n       /* We run this after find_afterward, because find_afterward needs\n \t the redundant DT_mode tests on predicates to determine whether\n \t two tests can both be true or not.  */\n-      simplify_tests(head);\n+      simplify_tests (head);\n \n       write_subroutines (head, subroutine_type);\n     }\n@@ -2601,12 +2602,12 @@ debug_decision_2 (struct decision_test *test)\n       break;\n     case DT_pred:\n       fprintf (stderr, \"pred=(%s,%s)\",\n-\t       test->u.pred.name, GET_MODE_NAME(test->u.pred.mode));\n+\t       test->u.pred.name, GET_MODE_NAME (test->u.pred.mode));\n       break;\n     case DT_c_test:\n       {\n \tchar sub[16+4];\n-\tstrncpy (sub, test->u.c_test, sizeof(sub));\n+\tstrncpy (sub, test->u.c_test, sizeof (sub));\n \tmemcpy (sub+16, \"...\", 4);\n \tfprintf (stderr, \"c_test=\\\"%s\\\"\", sub);\n       }"}, {"sha": "28165e371379176ebef1de3b33ebd3241912c908", "filename": "gcc/gensupport.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgensupport.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgensupport.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -392,7 +392,7 @@ static struct queue_elem *\n queue_pattern (rtx pattern, struct queue_elem ***list_tail,\n \t       const char *filename, int lineno)\n {\n-  struct queue_elem *e = XNEW(struct queue_elem);\n+  struct queue_elem *e = XNEW (struct queue_elem);\n   e->data = pattern;\n   e->filename = filename;\n   e->lineno = lineno;\n@@ -429,7 +429,7 @@ remove_from_queue (struct queue_elem *elem, struct queue_elem **queue)\n static void\n add_define_attr (const char *name)\n {\n-  struct queue_elem *e = XNEW(struct queue_elem);\n+  struct queue_elem *e = XNEW (struct queue_elem);\n   rtx t1 = rtx_alloc (DEFINE_ATTR);\n   XSTR (t1, 0) = name;\n   XSTR (t1, 1) = \"no,yes\";\n@@ -2870,7 +2870,7 @@ record_insn_name (int code, const char *name)\n       new_size = (insn_name_ptr_size ? insn_name_ptr_size * 2 : 512);\n       insn_name_ptr = XRESIZEVEC (char *, insn_name_ptr, new_size);\n       memset (insn_name_ptr + insn_name_ptr_size, 0,\n-\t      sizeof(char *) * (new_size - insn_name_ptr_size));\n+\t      sizeof (char *) * (new_size - insn_name_ptr_size));\n       insn_name_ptr_size = new_size;\n     }\n "}, {"sha": "dcabd61433d1e47e43f5f2aca109cf4163544426", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -488,7 +488,7 @@ gt_pch_save (FILE *f)\n   char *this_object = NULL;\n   size_t this_object_size = 0;\n   struct mmap_info mmi;\n-  const size_t mmap_offset_alignment = host_hooks.gt_pch_alloc_granularity();\n+  const size_t mmap_offset_alignment = host_hooks.gt_pch_alloc_granularity ();\n \n   gt_pch_save_stringpool ();\n \n@@ -749,7 +749,7 @@ default_gt_pch_use_address (void *base, size_t size, int fd ATTRIBUTE_UNUSED,\n size_t\n default_gt_pch_alloc_granularity (void)\n {\n-  return getpagesize();\n+  return getpagesize ();\n }\n \n #if HAVE_MMAP_FILE\n@@ -837,7 +837,7 @@ ggc_rlimit_bound (double limit)\n static int\n ggc_min_expand_heuristic (void)\n {\n-  double min_expand = physmem_total();\n+  double min_expand = physmem_total ();\n \n   /* Adjust for rlimits.  */\n   min_expand = ggc_rlimit_bound (min_expand);\n@@ -856,7 +856,7 @@ ggc_min_expand_heuristic (void)\n static int\n ggc_min_heapsize_heuristic (void)\n {\n-  double phys_kbytes = physmem_total();\n+  double phys_kbytes = physmem_total ();\n   double limit_kbytes = ggc_rlimit_bound (phys_kbytes * 2);\n \n   phys_kbytes /= 1024; /* Convert to Kbytes.  */"}, {"sha": "249aa010507770b68668e05534765c8a45ec09c3", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -462,7 +462,7 @@ static struct globals\n /* The size in bytes required to maintain a bitmap for the objects\n    on a page-entry.  */\n #define BITMAP_SIZE(Num_objects) \\\n-  (CEIL ((Num_objects), HOST_BITS_PER_LONG) * sizeof(long))\n+  (CEIL ((Num_objects), HOST_BITS_PER_LONG) * sizeof (long))\n \n /* Allocate pages in chunks of this size, to throttle calls to memory\n    allocation routines.  The first page is used, the rest go onto the\n@@ -785,7 +785,7 @@ alloc_page (unsigned order)\n       page = alloc_anon (NULL, G.pagesize * GGC_QUIRE_SIZE, false);\n       if (page == NULL)\n      \t{\n-\t  page = alloc_anon(NULL, G.pagesize, true);\n+\t  page = alloc_anon (NULL, G.pagesize, true);\n           entries = 1;\n \t}\n \n@@ -1644,7 +1644,7 @@ init_ggc (void)\n {\n   unsigned order;\n \n-  G.pagesize = getpagesize();\n+  G.pagesize = getpagesize ();\n   G.lg_pagesize = exact_log2 (G.pagesize);\n \n #ifdef HAVE_MMAP_DEV_ZERO\n@@ -2163,7 +2163,7 @@ ggc_print_statistics (void)\n     }\n   fprintf (stderr, \"%-5s %10lu%c %10lu%c %10lu%c\\n\", \"Total\",\n \t   SCALE (G.bytes_mapped), STAT_LABEL (G.bytes_mapped),\n-\t   SCALE (G.allocated), STAT_LABEL(G.allocated),\n+\t   SCALE (G.allocated), STAT_LABEL (G.allocated),\n \t   SCALE (total_overhead), STAT_LABEL (total_overhead));\n \n   if (GATHER_STATISTICS)\n@@ -2315,13 +2315,13 @@ ggc_pch_write_object (struct ggc_pch_data *d,\n \n   if (size != OBJECT_SIZE (order))\n     {\n-      unsigned padding = OBJECT_SIZE(order) - size;\n+      unsigned padding = OBJECT_SIZE (order) - size;\n \n       /* To speed small writes, we use a nulled-out array that's larger\n          than most padding requests as the source for our null bytes.  This\n          permits us to do the padding with fwrite() rather than fseek(), and\n          limits the chance the OS may try to flush any outstanding writes.  */\n-      if (padding <= sizeof(emptyBytes))\n+      if (padding <= sizeof (emptyBytes))\n         {\n           if (fwrite (emptyBytes, 1, padding, f) != padding)\n             fatal_error (\"can%'t write PCH file\");\n@@ -2419,7 +2419,7 @@ ggc_pch_read (FILE *f, void *addr)\n #endif\n   /* Since we free all the allocated objects, the free list becomes\n      useless.  Validate it now, which will also clear it.  */\n-  validate_free_objects();\n+  validate_free_objects ();\n \n   /* No object read from a PCH file should ever be freed.  So, set the\n      context depth to 1, and set the depth of all the currently-allocated"}, {"sha": "dd2aed73e77c902f9ddbec0df8938c36e65fc066", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -2825,7 +2825,7 @@ fold_array_ctor_reference (tree type, tree ctor,\n   else\n     low_bound = double_int_zero;\n   /* Static constructors for variably sized objects makes no sense.  */\n-  gcc_assert (TREE_CODE(TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (ctor))))\n+  gcc_assert (TREE_CODE (TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (ctor))))\n \t      == INTEGER_CST);\n   elt_size =\n     tree_to_double_int (TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (ctor))));"}, {"sha": "cf6bac2b35e102ce6e5cf2f7f82b6e6f201d3d75", "filename": "gcc/gimple-low.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgimple-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgimple-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -118,7 +118,8 @@ lower_function_body (void)\n      need to do anything special.  Otherwise build one by hand.  */\n   if (gimple_seq_may_fallthru (lowered_body)\n       && (data.return_statements.is_empty ()\n-\t  || gimple_return_retval (data.return_statements.last().stmt) != NULL))\n+\t  || (gimple_return_retval (data.return_statements.last().stmt)\n+\t      != NULL)))\n     {\n       x = gimple_build_return (NULL);\n       gimple_set_location (x, cfun->function_end_locus);\n@@ -197,8 +198,8 @@ const pass_data pass_data_lower_cf =\n class pass_lower_cf : public gimple_opt_pass\n {\n public:\n-  pass_lower_cf(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_lower_cf, ctxt)\n+  pass_lower_cf (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_lower_cf, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -707,7 +708,7 @@ block_may_fallthru (const_tree block)\n {\n   /* This CONST_CAST is okay because expr_last returns its argument\n      unmodified and we assign it to a const_tree.  */\n-  const_tree stmt = expr_last (CONST_CAST_TREE(block));\n+  const_tree stmt = expr_last (CONST_CAST_TREE (block));\n \n   switch (stmt ? TREE_CODE (stmt) : ERROR_MARK)\n     {"}, {"sha": "1e985e0dbd7b4b8a42323e96ef9d4510173eee95", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -524,7 +524,7 @@ dump_gimple_assign (pretty_printer *buffer, gimple gs, int spc, int flags)\n       else\n         gcc_unreachable ();\n       if (!(flags & TDF_RHS_ONLY))\n-\tpp_semicolon(buffer);\n+\tpp_semicolon (buffer);\n     }\n }\n \n@@ -2285,7 +2285,7 @@ gimple_dump_bb_buff (pretty_printer *buffer, basic_block bb, int indent,\n       pp_newline_and_flush (buffer);\n       gcc_checking_assert (DECL_STRUCT_FUNCTION (current_function_decl));\n       dump_histograms_for_stmt (DECL_STRUCT_FUNCTION (current_function_decl),\n-\t\t\t\tpp_buffer(buffer)->stream, stmt);\n+\t\t\t\tpp_buffer (buffer)->stream, stmt);\n     }\n \n   dump_implicit_edges (buffer, bb, indent, flags);"}, {"sha": "139a4a16472938c0b02e6a277f6976fa99f1d65a", "filename": "gcc/gimple-ssa-strength-reduction.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgimple-ssa-strength-reduction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgimple-ssa-strength-reduction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-strength-reduction.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -3564,8 +3564,8 @@ const pass_data pass_data_strength_reduction =\n class pass_strength_reduction : public gimple_opt_pass\n {\n public:\n-  pass_strength_reduction(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_strength_reduction, ctxt)\n+  pass_strength_reduction (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_strength_reduction, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "e12f7d92c2e31a4d4603f14a4c29366f8abd0106", "filename": "gcc/gimple.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -54,7 +54,7 @@ EXPORTED_CONST size_t gimple_ops_offset_[] = {\n };\n #undef DEFGSSTRUCT\n \n-#define DEFGSSTRUCT(SYM, STRUCT, HAS_TREE_OP) sizeof(struct STRUCT),\n+#define DEFGSSTRUCT(SYM, STRUCT, HAS_TREE_OP) sizeof (struct STRUCT),\n static const size_t gsstruct_code_size[] = {\n #include \"gsstruct.def\"\n };\n@@ -2153,7 +2153,7 @@ gimple_set_lhs (gimple stmt, tree lhs)\n   else if (code == GIMPLE_CALL)\n     gimple_call_set_lhs (stmt, lhs);\n   else\n-    gcc_unreachable();\n+    gcc_unreachable ();\n }\n \n "}, {"sha": "376fda2c6f2d7a2a278cdb78c2cd68d5f5d77b2e", "filename": "gcc/gimple.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -5037,7 +5037,7 @@ gsi_start_1 (gimple_seq *seq)\n   return i;\n }\n \n-#define gsi_start(x) gsi_start_1(&(x))\n+#define gsi_start(x) gsi_start_1 (&(x))\n \n static inline gimple_stmt_iterator\n gsi_none (void)\n@@ -5080,7 +5080,7 @@ gsi_last_1 (gimple_seq *seq)\n   return i;\n }\n \n-#define gsi_last(x) gsi_last_1(&(x))\n+#define gsi_last(x) gsi_last_1 (&(x))\n \n /* Return a new iterator pointing to the last statement in basic block BB.  */\n "}, {"sha": "0303e4f06283c0a876f94badfca4d6a932cdcd5d", "filename": "gcc/godump.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgodump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgodump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgodump.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -1213,7 +1213,7 @@ go_finish (const char *filename)\n \t  break;\n \n \tdefault:\n-\t  gcc_unreachable();\n+\t  gcc_unreachable ();\n \t}\n     }\n "}, {"sha": "d0e23021f5dd4fe1122ed677c7f51ac352026c5a", "filename": "gcc/graphite-clast-to-gimple.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgraphite-clast-to-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgraphite-clast-to-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-clast-to-gimple.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -1306,7 +1306,7 @@ translate_clast (loop_p context_loop, struct clast_stmt *stmt, edge next_e,\n     next_e = translate_clast_assignment ((struct clast_assignment *) stmt,\n \t\t\t\t\t next_e, level, ip);\n   else\n-    gcc_unreachable();\n+    gcc_unreachable ();\n \n   recompute_all_dominators ();\n   graphite_verify ();\n@@ -1409,7 +1409,7 @@ init_cloog_input_file (int scop_number)\n /* Extend the scattering to NEW_DIMS scattering dimensions.  */\n \n static\n-isl_map *extend_scattering(isl_map *scattering, int new_dims)\n+isl_map *extend_scattering (isl_map *scattering, int new_dims)\n {\n   int old_dims, i;\n   isl_space *space;\n@@ -1462,12 +1462,13 @@ build_cloog_union_domain (scop_p scop, int nb_scattering_dims)\n \n       /* Dead code elimination: when the domain of a PBB is empty,\n \t don't generate code for the PBB.  */\n-      if (isl_set_is_empty(pbb->domain))\n+      if (isl_set_is_empty (pbb->domain))\n \tcontinue;\n \n-      domain = cloog_domain_from_isl_set(isl_set_copy(pbb->domain));\n-      scattering = cloog_scattering_from_isl_map(extend_scattering(isl_map_copy(pbb->transformed),\n-\t\t\t\t\t\t nb_scattering_dims));\n+      domain = cloog_domain_from_isl_set (isl_set_copy (pbb->domain));\n+      scattering = cloog_scattering_from_isl_map\n+\t(extend_scattering (isl_map_copy (pbb->transformed),\n+\t\t\t    nb_scattering_dims));\n \n       union_domain = cloog_union_domain_add_domain (union_domain, \"\", domain,\n \t\t\t\t\t\t    scattering, pbb);"}, {"sha": "b9b21566fb52b6378076b09bd15d6a5e93ba70e6", "filename": "gcc/graphite-optimize-isl.c", "status": "modified", "additions": 109, "deletions": 108, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgraphite-optimize-isl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgraphite-optimize-isl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-optimize-isl.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -114,7 +114,7 @@ scop_get_dependences (scop_p scop)\n    */\n  \n static isl_basic_map *\n-getTileMap(isl_ctx *ctx, int scheduleDimensions, int tileSize)\n+getTileMap (isl_ctx *ctx, int scheduleDimensions, int tileSize)\n {\n   int x;\n   /* We construct\n@@ -124,11 +124,11 @@ getTileMap(isl_ctx *ctx, int scheduleDimensions, int tileSize)\n     \t                s1 = a1 * 32 and s1 = p1 and t1 <= p1 < t1 + 32}\n \n      and project out the auxilary dimensions a0 and a1.  */\n-  isl_space *Space = isl_space_alloc(ctx, 0, scheduleDimensions,\n-\t\t\t\t     scheduleDimensions * 3);\n-  isl_basic_map *tileMap = isl_basic_map_universe(isl_space_copy(Space));\n+  isl_space *Space = isl_space_alloc (ctx, 0, scheduleDimensions,\n+\t\t\t\t      scheduleDimensions * 3);\n+  isl_basic_map *tileMap = isl_basic_map_universe (isl_space_copy (Space));\n \n-  isl_local_space *LocalSpace = isl_local_space_from_space(Space);\n+  isl_local_space *LocalSpace = isl_local_space_from_space (Space);\n \n   for (x = 0; x < scheduleDimensions; x++)\n     {\n@@ -140,40 +140,40 @@ getTileMap(isl_ctx *ctx, int scheduleDimensions, int tileSize)\n       isl_constraint *c;\n \n       /* sX = aX * tileSize; */\n-      c = isl_equality_alloc(isl_local_space_copy(LocalSpace));\n-      isl_constraint_set_coefficient_si(c, isl_dim_out, sX, 1);\n-      isl_constraint_set_coefficient_si(c, isl_dim_out, aX, -tileSize);\n-      tileMap = isl_basic_map_add_constraint(tileMap, c);\n+      c = isl_equality_alloc (isl_local_space_copy (LocalSpace));\n+      isl_constraint_set_coefficient_si (c, isl_dim_out, sX, 1);\n+      isl_constraint_set_coefficient_si (c, isl_dim_out, aX, -tileSize);\n+      tileMap = isl_basic_map_add_constraint (tileMap, c);\n \n       /* pX = sX; */\n-      c = isl_equality_alloc(isl_local_space_copy(LocalSpace));\n-      isl_constraint_set_coefficient_si(c, isl_dim_out, pX, 1);\n-      isl_constraint_set_coefficient_si(c, isl_dim_in, sX, -1);\n-      tileMap = isl_basic_map_add_constraint(tileMap, c);\n+      c = isl_equality_alloc (isl_local_space_copy (LocalSpace));\n+      isl_constraint_set_coefficient_si (c, isl_dim_out, pX, 1);\n+      isl_constraint_set_coefficient_si (c, isl_dim_in, sX, -1);\n+      tileMap = isl_basic_map_add_constraint (tileMap, c);\n \n       /* tX <= pX */\n-      c = isl_inequality_alloc(isl_local_space_copy(LocalSpace));\n-      isl_constraint_set_coefficient_si(c, isl_dim_out, pX, 1);\n-      isl_constraint_set_coefficient_si(c, isl_dim_out, tX, -1);\n-      tileMap = isl_basic_map_add_constraint(tileMap, c);\n+      c = isl_inequality_alloc (isl_local_space_copy (LocalSpace));\n+      isl_constraint_set_coefficient_si (c, isl_dim_out, pX, 1);\n+      isl_constraint_set_coefficient_si (c, isl_dim_out, tX, -1);\n+      tileMap = isl_basic_map_add_constraint (tileMap, c);\n \n       /* pX <= tX + (tileSize - 1) */\n-      c = isl_inequality_alloc(isl_local_space_copy(LocalSpace));\n-      isl_constraint_set_coefficient_si(c, isl_dim_out, tX, 1);\n-      isl_constraint_set_coefficient_si(c, isl_dim_out, pX, -1);\n-      isl_constraint_set_constant_si(c, tileSize - 1);\n-      tileMap = isl_basic_map_add_constraint(tileMap, c);\n+      c = isl_inequality_alloc (isl_local_space_copy (LocalSpace));\n+      isl_constraint_set_coefficient_si (c, isl_dim_out, tX, 1);\n+      isl_constraint_set_coefficient_si (c, isl_dim_out, pX, -1);\n+      isl_constraint_set_constant_si (c, tileSize - 1);\n+      tileMap = isl_basic_map_add_constraint (tileMap, c);\n     }\n \n   /* Project out auxiliary dimensions.\n \n      The auxiliary dimensions are transformed into existentially quantified ones.\n      This reduces the number of visible scattering dimensions and allows Cloog\n      to produces better code.  */\n-  tileMap = isl_basic_map_project_out(tileMap, isl_dim_out,\n-\t\t\t\t      2 * scheduleDimensions,\n-\t\t\t\t      scheduleDimensions);\n-  isl_local_space_free(LocalSpace);\n+  tileMap = isl_basic_map_project_out (tileMap, isl_dim_out,\n+\t\t\t\t       2 * scheduleDimensions,\n+\t\t\t\t       scheduleDimensions);\n+  isl_local_space_free (LocalSpace);\n   return tileMap;\n }\n \n@@ -185,16 +185,16 @@ getTileMap(isl_ctx *ctx, int scheduleDimensions, int tileSize)\n static bool DisableTiling = false;\n \n static isl_union_map *\n-getScheduleForBand(isl_band *Band, int *Dimensions)\n+getScheduleForBand (isl_band *Band, int *Dimensions)\n {\n   isl_union_map *PartialSchedule;\n   isl_ctx *ctx;\n   isl_space *Space;\n   isl_basic_map *TileMap;\n   isl_union_map *TileUMap;\n \n-  PartialSchedule = isl_band_get_partial_schedule(Band);\n-  *Dimensions = isl_band_n_member(Band);\n+  PartialSchedule = isl_band_get_partial_schedule (Band);\n+  *Dimensions = isl_band_n_member (Band);\n \n   if (DisableTiling)\n     return PartialSchedule;\n@@ -203,15 +203,15 @@ getScheduleForBand(isl_band *Band, int *Dimensions)\n   if (*Dimensions == 1)\n     return PartialSchedule;\n \n-  ctx = isl_union_map_get_ctx(PartialSchedule);\n-  Space = isl_union_map_get_space(PartialSchedule);\n+  ctx = isl_union_map_get_ctx (PartialSchedule);\n+  Space = isl_union_map_get_space (PartialSchedule);\n \n-  TileMap = getTileMap(ctx, *Dimensions, 32);\n-  TileUMap = isl_union_map_from_map(isl_map_from_basic_map(TileMap));\n-  TileUMap = isl_union_map_align_params(TileUMap, Space);\n+  TileMap = getTileMap (ctx, *Dimensions, 32);\n+  TileUMap = isl_union_map_from_map (isl_map_from_basic_map (TileMap));\n+  TileUMap = isl_union_map_align_params (TileUMap, Space);\n   *Dimensions = 2 * *Dimensions;\n \n-  return isl_union_map_apply_range(PartialSchedule, TileUMap);\n+  return isl_union_map_apply_range (PartialSchedule, TileUMap);\n }\n \n /* Create a map that pre-vectorizes one scheduling dimension.\n@@ -253,9 +253,9 @@ getScheduleForBand(isl_band *Band, int *Dimensions)\n    currently constant and not yet target specific. This function does not reason\n    about parallelism.  */\n static isl_map *\n-getPrevectorMap(isl_ctx *ctx, int DimToVectorize,\n-\t\tint ScheduleDimensions,\n-\t\tint VectorWidth)\n+getPrevectorMap (isl_ctx *ctx, int DimToVectorize,\n+\t\t int ScheduleDimensions,\n+\t\t int VectorWidth)\n {\n   isl_space *Space;\n   isl_local_space *LocalSpace, *LocalSpaceRange;\n@@ -270,53 +270,53 @@ getPrevectorMap(isl_ctx *ctx, int DimToVectorize,\n \n   /* assert (0 <= DimToVectorize && DimToVectorize < ScheduleDimensions);*/\n \n-  Space = isl_space_alloc(ctx, 0, ScheduleDimensions, ScheduleDimensions + 1);\n-  TilingMap = isl_map_universe(isl_space_copy(Space));\n-  LocalSpace = isl_local_space_from_space(Space);\n+  Space = isl_space_alloc (ctx, 0, ScheduleDimensions, ScheduleDimensions + 1);\n+  TilingMap = isl_map_universe (isl_space_copy (Space));\n+  LocalSpace = isl_local_space_from_space (Space);\n   PointDimension = ScheduleDimensions;\n   TileDimension = DimToVectorize;\n \n   /* Create an identity map for everything except DimToVectorize and map\n      DimToVectorize to the point loop at the innermost dimension.  */\n   for (i = 0; i < ScheduleDimensions; i++)\n     {\n-      c = isl_equality_alloc(isl_local_space_copy(LocalSpace));\n-      isl_constraint_set_coefficient_si(c, isl_dim_in, i, -1);\n+      c = isl_equality_alloc (isl_local_space_copy (LocalSpace));\n+      isl_constraint_set_coefficient_si (c, isl_dim_in, i, -1);\n \n       if (i == DimToVectorize)\n-\tisl_constraint_set_coefficient_si(c, isl_dim_out, PointDimension, 1);\n+\tisl_constraint_set_coefficient_si (c, isl_dim_out, PointDimension, 1);\n       else\n-\tisl_constraint_set_coefficient_si(c, isl_dim_out, i, 1);\n+\tisl_constraint_set_coefficient_si (c, isl_dim_out, i, 1);\n \n-      TilingMap = isl_map_add_constraint(TilingMap, c);\n+      TilingMap = isl_map_add_constraint (TilingMap, c);\n     }\n \n   /* it % 'VectorWidth' = 0  */\n-  LocalSpaceRange = isl_local_space_range(isl_local_space_copy(LocalSpace));\n-  Aff = isl_aff_zero_on_domain(LocalSpaceRange);\n-  Aff = isl_aff_set_constant_si(Aff, VectorWidth);\n-  Aff = isl_aff_set_coefficient_si(Aff, isl_dim_in, TileDimension, 1);\n-  isl_int_init(VectorWidthMP);\n-  isl_int_set_si(VectorWidthMP, VectorWidth);\n-  Aff = isl_aff_mod(Aff, VectorWidthMP);\n-  isl_int_clear(VectorWidthMP);\n-  Modulo = isl_pw_aff_zero_set(isl_pw_aff_from_aff(Aff));\n-  TilingMap = isl_map_intersect_range(TilingMap, Modulo);\n+  LocalSpaceRange = isl_local_space_range (isl_local_space_copy (LocalSpace));\n+  Aff = isl_aff_zero_on_domain (LocalSpaceRange);\n+  Aff = isl_aff_set_constant_si (Aff, VectorWidth);\n+  Aff = isl_aff_set_coefficient_si (Aff, isl_dim_in, TileDimension, 1);\n+  isl_int_init (VectorWidthMP);\n+  isl_int_set_si (VectorWidthMP, VectorWidth);\n+  Aff = isl_aff_mod (Aff, VectorWidthMP);\n+  isl_int_clear (VectorWidthMP);\n+  Modulo = isl_pw_aff_zero_set (isl_pw_aff_from_aff (Aff));\n+  TilingMap = isl_map_intersect_range (TilingMap, Modulo);\n \n   /* it <= ip */\n-  c = isl_inequality_alloc(isl_local_space_copy(LocalSpace));\n-  isl_constraint_set_coefficient_si(c, isl_dim_out, TileDimension, -1);\n-  isl_constraint_set_coefficient_si(c, isl_dim_out, PointDimension, 1);\n-  TilingMap = isl_map_add_constraint(TilingMap, c);\n+  c = isl_inequality_alloc (isl_local_space_copy (LocalSpace));\n+  isl_constraint_set_coefficient_si (c, isl_dim_out, TileDimension, -1);\n+  isl_constraint_set_coefficient_si (c, isl_dim_out, PointDimension, 1);\n+  TilingMap = isl_map_add_constraint (TilingMap, c);\n \n   /* ip <= it + ('VectorWidth' - 1) */\n-  c = isl_inequality_alloc(LocalSpace);\n-  isl_constraint_set_coefficient_si(c, isl_dim_out, TileDimension, 1);\n-  isl_constraint_set_coefficient_si(c, isl_dim_out, PointDimension, -1);\n-  isl_constraint_set_constant_si(c, VectorWidth - 1);\n-  TilingMap = isl_map_add_constraint(TilingMap, c);\n+  c = isl_inequality_alloc (LocalSpace);\n+  isl_constraint_set_coefficient_si (c, isl_dim_out, TileDimension, 1);\n+  isl_constraint_set_coefficient_si (c, isl_dim_out, PointDimension, -1);\n+  isl_constraint_set_constant_si (c, VectorWidth - 1);\n+  TilingMap = isl_map_add_constraint (TilingMap, c);\n \n-  isl_map_dump(TilingMap);\n+  isl_map_dump (TilingMap);\n \n   return TilingMap;\n }\n@@ -329,15 +329,15 @@ static bool EnablePollyVector = false;\n    individual bands to the overall schedule. In case tiling is requested,\n    the individual bands are tiled.  */\n static isl_union_map *\n-getScheduleForBandList(isl_band_list *BandList)\n+getScheduleForBandList (isl_band_list *BandList)\n {\n   int NumBands, i;\n   isl_union_map *Schedule;\n   isl_ctx *ctx;\n \n-  ctx = isl_band_list_get_ctx(BandList);\n-  NumBands = isl_band_list_n_band(BandList);\n-  Schedule = isl_union_map_empty(isl_space_params_alloc(ctx, 0));\n+  ctx = isl_band_list_get_ctx (BandList);\n+  NumBands = isl_band_list_n_band (BandList);\n+  Schedule = isl_union_map_empty (isl_space_params_alloc (ctx, 0));\n \n   for (i = 0; i < NumBands; i++)\n     {\n@@ -346,61 +346,61 @@ getScheduleForBandList(isl_band_list *BandList)\n       int ScheduleDimensions;\n       isl_space *Space;\n \n-      Band = isl_band_list_get_band(BandList, i);\n-      PartialSchedule = getScheduleForBand(Band, &ScheduleDimensions);\n-      Space = isl_union_map_get_space(PartialSchedule);\n+      Band = isl_band_list_get_band (BandList, i);\n+      PartialSchedule = getScheduleForBand (Band, &ScheduleDimensions);\n+      Space = isl_union_map_get_space (PartialSchedule);\n \n-      if (isl_band_has_children(Band))\n+      if (isl_band_has_children (Band))\n \t{\n \t  isl_band_list *Children;\n \t  isl_union_map *SuffixSchedule;\n \n-\t  Children = isl_band_get_children(Band);\n-\t  SuffixSchedule = getScheduleForBandList(Children);\n-\t  PartialSchedule = isl_union_map_flat_range_product(PartialSchedule,\n-\t\t\t\t\t\t\t     SuffixSchedule);\n-\t  isl_band_list_free(Children);\n+\t  Children = isl_band_get_children (Band);\n+\t  SuffixSchedule = getScheduleForBandList (Children);\n+\t  PartialSchedule = isl_union_map_flat_range_product (PartialSchedule,\n+\t\t\t\t\t\t\t      SuffixSchedule);\n+\t  isl_band_list_free (Children);\n \t}\n       else if (EnablePollyVector)\n \t{\n \t  for (i = ScheduleDimensions - 1 ;  i >= 0 ; i--)\n \t    {\n-\t      if (isl_band_member_is_zero_distance(Band, i))\n+\t      if (isl_band_member_is_zero_distance (Band, i))\n \t\t{\n \t\t  isl_map *TileMap;\n \t\t  isl_union_map *TileUMap;\n \n-\t\t  TileMap = getPrevectorMap(ctx, i, ScheduleDimensions, 4);\n-\t\t  TileUMap = isl_union_map_from_map(TileMap);\n-\t\t  TileUMap = isl_union_map_align_params(TileUMap,\n-\t\t\t\t\t\t\tisl_space_copy(Space));\n-\t\t  PartialSchedule = isl_union_map_apply_range(PartialSchedule,\n-\t\t\t\t\t\t\t      TileUMap);\n+\t\t  TileMap = getPrevectorMap (ctx, i, ScheduleDimensions, 4);\n+\t\t  TileUMap = isl_union_map_from_map (TileMap);\n+\t\t  TileUMap = isl_union_map_align_params\n+\t\t    (TileUMap, isl_space_copy (Space));\n+\t\t  PartialSchedule = isl_union_map_apply_range\n+\t\t    (PartialSchedule, TileUMap);\n \t\t  break;\n \t\t}\n \t    }\n \t}\n \n-      Schedule = isl_union_map_union(Schedule, PartialSchedule);\n+      Schedule = isl_union_map_union (Schedule, PartialSchedule);\n \n-      isl_band_free(Band);\n-      isl_space_free(Space);\n+      isl_band_free (Band);\n+      isl_space_free (Space);\n     }\n \n   return Schedule;\n }\n \n static isl_union_map *\n-getScheduleMap(isl_schedule *Schedule)\n+getScheduleMap (isl_schedule *Schedule)\n {\n-  isl_band_list *BandList = isl_schedule_get_band_forest(Schedule);\n-  isl_union_map *ScheduleMap = getScheduleForBandList(BandList);\n-  isl_band_list_free(BandList);\n+  isl_band_list *BandList = isl_schedule_get_band_forest (Schedule);\n+  isl_union_map *ScheduleMap = getScheduleForBandList (BandList);\n+  isl_band_list_free (BandList);\n   return ScheduleMap;\n }\n \n static int\n-getSingleMap(__isl_take isl_map *map, void *user)\n+getSingleMap (__isl_take isl_map *map, void *user)\n {\n   isl_map **singleMap = (isl_map **) user;\n   *singleMap = map;\n@@ -420,12 +420,13 @@ apply_schedule_map_to_scop (scop_p scop, isl_union_map *schedule_map)\n       isl_union_map *stmtBand;\n       isl_map *stmtSchedule;\n \n-      stmtBand = isl_union_map_intersect_domain(isl_union_map_copy(schedule_map),\n-\t\t\t\t\t\tisl_union_set_from_set(domain));\n-      isl_union_map_foreach_map(stmtBand, getSingleMap, &stmtSchedule);\n-      isl_map_free(pbb->transformed);\n+      stmtBand = isl_union_map_intersect_domain\n+\t(isl_union_map_copy (schedule_map),\n+\t isl_union_set_from_set (domain));\n+      isl_union_map_foreach_map (stmtBand, getSingleMap, &stmtSchedule);\n+      isl_map_free (pbb->transformed);\n       pbb->transformed = stmtSchedule;\n-      isl_union_map_free(stmtBand);\n+      isl_union_map_free (stmtBand);\n     }\n }\n \n@@ -442,20 +443,20 @@ optimize_isl (scop_p scop)\n \n   domain = scop_get_domains (scop);\n   dependences = scop_get_dependences (scop);\n-  dependences = isl_union_map_gist_domain(dependences,\n-\t\t\t\t\t  isl_union_set_copy(domain));\n-  dependences = isl_union_map_gist_range(dependences,\n-\t\t\t\t\t isl_union_set_copy(domain));\n+  dependences = isl_union_map_gist_domain (dependences,\n+\t\t\t\t\t   isl_union_set_copy (domain));\n+  dependences = isl_union_map_gist_range (dependences,\n+\t\t\t\t\t  isl_union_set_copy (domain));\n   validity = dependences;\n \n   proximity = isl_union_map_copy (validity);\n \n-  isl_options_set_schedule_max_constant_term(scop->ctx, CONSTANT_BOUND);\n-  isl_options_set_schedule_maximize_band_depth(scop->ctx, 1);\n-  isl_options_set_schedule_fuse(scop->ctx, ISL_SCHEDULE_FUSE_MIN);\n-  isl_options_set_on_error(scop->ctx, ISL_ON_ERROR_CONTINUE);\n+  isl_options_set_schedule_max_constant_term (scop->ctx, CONSTANT_BOUND);\n+  isl_options_set_schedule_maximize_band_depth (scop->ctx, 1);\n+  isl_options_set_schedule_fuse (scop->ctx, ISL_SCHEDULE_FUSE_MIN);\n+  isl_options_set_on_error (scop->ctx, ISL_ON_ERROR_CONTINUE);\n   schedule = isl_union_set_compute_schedule (domain, validity, proximity);\n-  isl_options_set_on_error(scop->ctx, ISL_ON_ERROR_ABORT);\n+  isl_options_set_on_error (scop->ctx, ISL_ON_ERROR_ABORT);\n \n   if (!schedule)\n     return false;"}, {"sha": "9720f3f60f53c98e8db7604500dbf496bf03cfcc", "filename": "gcc/graphite-poly.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgraphite-poly.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgraphite-poly.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-poly.h?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -403,7 +403,7 @@ extern int scop_do_interchange (scop_p);\n extern int scop_do_strip_mine (scop_p, int);\n extern bool scop_do_block (scop_p);\n extern bool flatten_all_loops (scop_p);\n-extern bool optimize_isl(scop_p);\n+extern bool optimize_isl (scop_p);\n extern void pbb_number_of_iterations_at_time (poly_bb_p, graphite_dim_t, mpz_t);\n extern void debug_gmp_value (mpz_t);\n "}, {"sha": "3949098f83ca59b8ed419e2d34459413c1003e4f", "filename": "gcc/graphite-sese-to-poly.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -665,7 +665,7 @@ extract_affine_name (scop_p s, tree e, __isl_take isl_space *space)\n \n   id = isl_id_for_ssa_name (s, e);\n   dimension = isl_space_find_dim_by_id (space, isl_dim_param, id);\n-  isl_id_free(id);\n+  isl_id_free (id);\n   dom = isl_set_universe (isl_space_copy (space));\n   aff = isl_aff_zero_on_domain (isl_local_space_from_space (space));\n   aff = isl_aff_add_coefficient_si (aff, isl_dim_param, dimension, 1);\n@@ -994,7 +994,7 @@ build_loop_iteration_domains (scop_p scop, struct loop *loop,\n   if (TREE_CODE (nb_iters) == INTEGER_CST)\n     {\n       c = isl_inequality_alloc\n-\t  (isl_local_space_from_space(isl_space_copy (space)));\n+\t  (isl_local_space_from_space (isl_space_copy (space)));\n       c = isl_constraint_set_coefficient_si (c, isl_dim_set, pos, -1);\n       tree_int_to_gmp (nb_iters, g);\n       isl_int_set_gmp (v, g);\n@@ -1132,8 +1132,8 @@ add_condition_to_pbb (poly_bb_p pbb, gimple stmt, enum tree_code code)\n \tbreak;\n \n       default:\n-\tisl_pw_aff_free(lhs);\n-\tisl_pw_aff_free(rhs);\n+\tisl_pw_aff_free (lhs);\n+\tisl_pw_aff_free (rhs);\n \treturn;\n     }\n "}, {"sha": "cbd0b5a156899d10eca9ca1324c96ba13e9ad9d7", "filename": "gcc/graphite.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgraphite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fgraphite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -265,7 +265,7 @@ graphite_transform_loops (void)\n     return;\n \n   ctx = isl_ctx_alloc ();\n-  isl_options_set_on_error(ctx, ISL_ON_ERROR_ABORT);\n+  isl_options_set_on_error (ctx, ISL_ON_ERROR_ABORT);\n   if (!graphite_initialize (ctx))\n     return;\n "}, {"sha": "aab5748f67b6d1e4474e81dc38ec91d7892ba6ca", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -2605,7 +2605,7 @@ rank_for_schedule (const void *x, const void *y)\n     }\n \n   info_val = (*current_sched_info->rank) (tmp, tmp2);\n-  if(flag_sched_rank_heuristic && info_val)\n+  if (flag_sched_rank_heuristic && info_val)\n     return info_val;\n \n   /* Compare insns based on their relation to the last scheduled\n@@ -7879,7 +7879,7 @@ create_check_block_twin (rtx insn, bool mutate_p)\n     /* Fix priorities.  If MUTATE_P is nonzero, this is not necessary,\n        because it'll be done later in add_to_speculative_block.  */\n     {\n-      rtx_vec_t priorities_roots = rtx_vec_t();\n+      rtx_vec_t priorities_roots = rtx_vec_t ();\n \n       clear_priorities (twin, &priorities_roots);\n       calc_priorities (priorities_roots);"}, {"sha": "1cf7b234862fc5ee44844746c40f77cb0a2135a5", "filename": "gcc/hash-table.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fhash-table.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fhash-table.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-table.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -111,7 +111,7 @@ unsigned int\n hash_table_higher_prime_index (unsigned long n)\n {\n   unsigned int low = 0;\n-  unsigned int high = sizeof(prime_tab) / sizeof(prime_tab[0]);\n+  unsigned int high = sizeof (prime_tab) / sizeof (prime_tab[0]);\n \n   while (low != high)\n     {"}, {"sha": "6d01188fe40c815d6576e651fb561c47e0b9a653", "filename": "gcc/hash-table.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fhash-table.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fhash-table.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-table.h?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -456,8 +456,8 @@ class hash_table\n \t    int (*Callback) (value_type **slot, Argument argument)>\n   void traverse (Argument argument);\n \n-  iterator begin();\n-  iterator end();\n+  iterator begin ();\n+  iterator end ();\n };\n \n \n@@ -522,7 +522,7 @@ hash_table <Descriptor, Allocator>::remove_elt (const value_type *value)\n template <typename Descriptor,\n \t  template <typename Type> class Allocator>\n inline size_t\n-hash_table <Descriptor, Allocator>::size()\n+hash_table <Descriptor, Allocator>::size ()\n {\n   return htab->size;\n }\n@@ -556,7 +556,7 @@ hash_table <Descriptor, Allocator>::elements_with_deleted ()\n template <typename Descriptor,\n \t  template <typename Type> class Allocator>\n inline double\n-hash_table <Descriptor, Allocator>::collisions()\n+hash_table <Descriptor, Allocator>::collisions ()\n {\n   if (htab->searches == 0)\n     return 0.0;"}, {"sha": "9e99dd99e0b02774535a4daf654b89424e3b8735", "filename": "gcc/hwint.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fhwint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fhwint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhwint.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -93,7 +93,7 @@ ctz_hwi (unsigned HOST_WIDE_INT x)\n int\n clz_hwi (unsigned HOST_WIDE_INT x)\n {\n-  return HOST_BITS_PER_WIDE_INT - 1 - floor_log2(x);\n+  return HOST_BITS_PER_WIDE_INT - 1 - floor_log2 (x);\n }\n \n /* Similar to ctz_hwi, except that the least significant bit is numbered"}, {"sha": "d2c2ec377b02304dd7cbed6820d81839d11e51a3", "filename": "gcc/hwint.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fhwint.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fhwint.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhwint.h?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -37,7 +37,7 @@\n # if GCC_VERSION >= 3000\n #  define HAVE_LONG_LONG 1\n #  define SIZEOF_LONG_LONG 8\n-extern char sizeof_long_long_must_be_8[sizeof(long long) == 8 ? 1 : -1];\n+extern char sizeof_long_long_must_be_8[sizeof (long long) == 8 ? 1 : -1];\n # endif\n #endif\n \n@@ -110,11 +110,11 @@ extern char sizeof_long_long_must_be_8[sizeof(long long) == 8 ? 1 : -1];\n #endif\n \n \n-#define HOST_WIDE_INT_UC(X) HOST_WIDE_INT_C(X ## U)\n-#define HOST_WIDE_INT_1 HOST_WIDE_INT_C(1)\n-#define HOST_WIDE_INT_1U HOST_WIDE_INT_UC(1)\n-#define HOST_WIDE_INT_M1 HOST_WIDE_INT_C(-1)\n-#define HOST_WIDE_INT_M1U HOST_WIDE_INT_UC(-1)\n+#define HOST_WIDE_INT_UC(X) HOST_WIDE_INT_C (X ## U)\n+#define HOST_WIDE_INT_1 HOST_WIDE_INT_C (1)\n+#define HOST_WIDE_INT_1U HOST_WIDE_INT_UC (1)\n+#define HOST_WIDE_INT_M1 HOST_WIDE_INT_C (-1)\n+#define HOST_WIDE_INT_M1U HOST_WIDE_INT_UC (-1)\n \n /* This is a magic identifier which allows GCC to figure out the type\n    of HOST_WIDE_INT for %wd specifier checks.  You must issue this\n@@ -168,7 +168,7 @@ typedef HOST_WIDE_INT __gcc_host_wide_int__;\n # define HOST_WIDEST_INT_PRINT_UNSIGNED\t      HOST_WIDE_INT_PRINT_UNSIGNED\n # define HOST_WIDEST_INT_PRINT_HEX\t      HOST_WIDE_INT_PRINT_HEX\n # define HOST_WIDEST_INT_PRINT_DOUBLE_HEX     HOST_WIDE_INT_PRINT_DOUBLE_HEX\n-# define HOST_WIDEST_INT_C(X)\t\t      HOST_WIDE_INT(X)\n+# define HOST_WIDEST_INT_C(X)\t\t      HOST_WIDE_INT (X)\n #else\n # if HOST_BITS_PER_LONGLONG >= 64\n #  define HOST_BITS_PER_WIDEST_INT\t      HOST_BITS_PER_LONGLONG"}, {"sha": "fafff9d09255ef5d1d75388c94c31a03e0e4cba7", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -336,7 +336,7 @@ cond_exec_process_insns (ce_if_block_t *ce_info ATTRIBUTE_UNUSED,\n       if (NOTE_P (insn) || DEBUG_INSN_P (insn))\n \tgoto insn_done;\n \n-      gcc_assert(NONJUMP_INSN_P (insn) || CALL_P (insn));\n+      gcc_assert (NONJUMP_INSN_P (insn) || CALL_P (insn));\n \n       /* Remove USE insns that get in the way.  */\n       if (reload_completed && GET_CODE (PATTERN (insn)) == USE)\n@@ -4503,8 +4503,8 @@ const pass_data pass_data_rtl_ifcvt =\n class pass_rtl_ifcvt : public rtl_opt_pass\n {\n public:\n-  pass_rtl_ifcvt(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_rtl_ifcvt, ctxt)\n+  pass_rtl_ifcvt (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_rtl_ifcvt, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -4558,8 +4558,8 @@ const pass_data pass_data_if_after_combine =\n class pass_if_after_combine : public rtl_opt_pass\n {\n public:\n-  pass_if_after_combine(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_if_after_combine, ctxt)\n+  pass_if_after_combine (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_if_after_combine, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -4612,8 +4612,8 @@ const pass_data pass_data_if_after_reload =\n class pass_if_after_reload : public rtl_opt_pass\n {\n public:\n-  pass_if_after_reload(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_if_after_reload, ctxt)\n+  pass_if_after_reload (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_if_after_reload, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "54b636034f33c4925f353cd40853f57bddb74009", "filename": "gcc/incpath.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fincpath.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fincpath.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fincpath.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -33,15 +33,15 @@\n    VMS has non-numeric inodes.  */\n #ifdef VMS\n # define INO_T_EQ(A, B) (!memcmp (&(A), &(B), sizeof (A)))\n-# define INO_T_COPY(DEST, SRC) memcpy(&(DEST), &(SRC), sizeof (SRC))\n+# define INO_T_COPY(DEST, SRC) memcpy (&(DEST), &(SRC), sizeof (SRC))\n #elif !defined (HOST_LACKS_INODE_NUMBERS)\n # define INO_T_EQ(A, B) ((A) == (B))\n # define INO_T_COPY(DEST, SRC) (DEST) = (SRC)\n #endif\n \n #if defined INO_T_EQ\n #define DIRS_EQ(A, B) ((A)->dev == (B)->dev \\\n-\t&& INO_T_EQ((A)->ino, (B)->ino))\n+\t&& INO_T_EQ ((A)->ino, (B)->ino))\n #else\n #define DIRS_EQ(A, B) (!filename_cmp ((A)->canonical_name, (B)->canonical_name))\n #endif\n@@ -128,7 +128,7 @@ add_standard_paths (const char *sysroot, const char *iprefix,\n \t\t    const char *imultilib, int cxx_stdinc)\n {\n   const struct default_include *p;\n-  int relocated = cpp_relocated();\n+  int relocated = cpp_relocated ();\n   size_t len;\n \n   if (iprefix && (len = cpp_GCC_INCLUDE_DIR_len) != 0)"}, {"sha": "2a15b3e0a6f2215ae63bfe626958cdb54513ea87", "filename": "gcc/init-regs.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Finit-regs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Finit-regs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finit-regs.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -158,8 +158,8 @@ const pass_data pass_data_initialize_regs =\n class pass_initialize_regs : public rtl_opt_pass\n {\n public:\n-  pass_initialize_regs(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_initialize_regs, ctxt)\n+  pass_initialize_regs (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_initialize_regs, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "8fdc7b28d92e92af42e90bdd09a97f649074b0f6", "filename": "gcc/input.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Finput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Finput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.h?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -37,7 +37,7 @@ extern char builtins_location_check[(BUILTINS_LOCATION\n \t\t\t\t     < RESERVED_LOCATION_COUNT) ? 1 : -1];\n \n extern expanded_location expand_location (source_location);\n-extern const char * location_get_source_line(expanded_location xloc);\n+extern const char *location_get_source_line (expanded_location xloc);\n extern expanded_location expand_location_to_spelling_point (source_location);\n extern source_location expansion_point_location_if_in_system_header (source_location);\n \n@@ -51,10 +51,11 @@ extern location_t input_location;\n #define LOCATION_LINE(LOC) ((expand_location (LOC)).line)\n #define LOCATION_COLUMN(LOC)((expand_location (LOC)).column)\n #define LOCATION_LOCUS(LOC) \\\n-  ((IS_ADHOC_LOC(LOC)) ? get_location_from_adhoc_loc (line_table, LOC) : (LOC))\n+  ((IS_ADHOC_LOC (LOC)) ? get_location_from_adhoc_loc (line_table, LOC) \\\n+   : (LOC))\n #define LOCATION_BLOCK(LOC) \\\n   ((tree) ((IS_ADHOC_LOC (LOC)) ? get_data_from_adhoc_loc (line_table, (LOC)) \\\n-  : NULL))\n+   : NULL))\n \n #define input_line LOCATION_LINE (input_location)\n #define input_filename LOCATION_FILE (input_location)"}, {"sha": "aa443509a6fd674ce9f952dde1460cb536c22fd2", "filename": "gcc/intl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fintl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fintl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintl.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -140,7 +140,7 @@ char *\n get_spaces (const char *str)\n {\n    size_t len = gcc_gettext_width (str);\n-   char *spaces = XNEWVEC(char, len + 1);\n+   char *spaces = XNEWVEC (char, len + 1);\n    memset (spaces, ' ', len);\n    spaces[len] = '\\0';\n    return spaces;"}, {"sha": "d34973e88fc2d0dfa3b1eb73c4b46bbf0113d9ec", "filename": "gcc/intl.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fintl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fintl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintl.h?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -38,12 +38,12 @@ extern size_t gcc_gettext_width (const char *);\n # define bindtextdomain(domain, directory) (domain)\n # undef gettext\n # define gettext(msgid) (msgid)\n-# define ngettext(singular,plural,n) fake_ngettext(singular,plural,n)\n+# define ngettext(singular,plural,n) fake_ngettext (singular, plural, n)\n # define gcc_init_libintl()\t/* nothing */\n-# define gcc_gettext_width(s) strlen(s)\n+# define gcc_gettext_width(s) strlen (s)\n \n-extern const char *fake_ngettext(const char *singular,const char *plural,\n-                                 unsigned long int n);\n+extern const char *fake_ngettext (const char *singular, const char *plural,\n+\t\t\t\t  unsigned long int n);\n \n #endif\n "}, {"sha": "c38ba82e5f0bacfc063a98135e6f3523050e1d68", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -3023,7 +3023,7 @@ intersect_aggregates_with_edge (struct cgraph_edge *cs, int index,\n     }\n   else\n     {\n-      inter.release();\n+      inter.release ();\n       return vec<ipa_agg_jf_item_t>();\n     }\n   return inter;\n@@ -3194,7 +3194,7 @@ cgraph_edge_brings_all_agg_vals_for_node (struct cgraph_edge *cs,\n \treturn false;\n \n       values = intersect_aggregates_with_edge (cs, i, values);\n-      if (!values.exists())\n+      if (!values.exists ())\n \treturn false;\n \n       for (struct ipa_agg_replacement_value *av = aggval; av; av = av->next)\n@@ -3213,7 +3213,7 @@ cgraph_edge_brings_all_agg_vals_for_node (struct cgraph_edge *cs,\n \t\t}\n \t    if (!found)\n \t      {\n-\t\tvalues.release();\n+\t\tvalues.release ();\n \t\treturn false;\n \t      }\n \t  }\n@@ -3679,19 +3679,19 @@ const pass_data pass_data_ipa_cp =\n class pass_ipa_cp : public ipa_opt_pass_d\n {\n public:\n-  pass_ipa_cp(gcc::context *ctxt)\n-    : ipa_opt_pass_d(pass_data_ipa_cp, ctxt,\n-\t\t     ipcp_generate_summary, /* generate_summary */\n-\t\t     ipcp_write_summary, /* write_summary */\n-\t\t     ipcp_read_summary, /* read_summary */\n-\t\t     ipa_prop_write_all_agg_replacement, /*\n-\t\t     write_optimization_summary */\n-\t\t     ipa_prop_read_all_agg_replacement, /*\n-\t\t     read_optimization_summary */\n-\t\t     NULL, /* stmt_fixup */\n-\t\t     0, /* function_transform_todo_flags_start */\n-\t\t     ipcp_transform_function, /* function_transform */\n-\t\t     NULL) /* variable_transform */\n+  pass_ipa_cp (gcc::context *ctxt)\n+    : ipa_opt_pass_d (pass_data_ipa_cp, ctxt,\n+\t\t      ipcp_generate_summary, /* generate_summary */\n+\t\t      ipcp_write_summary, /* write_summary */\n+\t\t      ipcp_read_summary, /* read_summary */\n+\t\t      ipa_prop_write_all_agg_replacement, /*\n+\t\t      write_optimization_summary */\n+\t\t      ipa_prop_read_all_agg_replacement, /*\n+\t\t      read_optimization_summary */\n+\t\t      NULL, /* stmt_fixup */\n+\t\t      0, /* function_transform_todo_flags_start */\n+\t\t      ipcp_transform_function, /* function_transform */\n+\t\t      NULL) /* variable_transform */\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "10499e1cfc0bd1de692b64e9abadaaefeacc8342", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -373,7 +373,7 @@ add_type_duplicate (odr_type val, tree type)\n \t      unsigned int i;\n \n \t      TYPE_BINFO (val->type) = TYPE_BINFO (type);\n-\t      for (i = 0; i < val->types->length(); i++)\n+\t      for (i = 0; i < val->types->length (); i++)\n \t\t{\n \t\t  if (TYPE_BINFO ((*val->types)[i])\n \t\t      == master_binfo)\n@@ -438,7 +438,7 @@ get_odr_type (tree type, bool insert)\n \t  }\n       /* First record bases, then add into array so ids are increasing.  */\n       if (odr_types_ptr)\n-        val->id = odr_types.length();\n+        val->id = odr_types.length ();\n       vec_safe_push (odr_types_ptr, val);\n     }\n   return val;\n@@ -460,17 +460,17 @@ dump_odr_type (FILE *f, odr_type t, int indent=0)\n \t       DECL_SOURCE_FILE (TYPE_NAME (t->type)),\n \t       DECL_SOURCE_LINE (TYPE_NAME (t->type)));\n     }\n-  if (t->bases.length())\n+  if (t->bases.length ())\n     {\n       fprintf (f, \"%*s base odr type ids: \", indent * 2, \"\");\n-      for (i = 0; i < t->bases.length(); i++)\n+      for (i = 0; i < t->bases.length (); i++)\n \tfprintf (f, \" %i\", t->bases[i]->id);\n       fprintf (f, \"\\n\");\n     }\n-  if (t->derived_types.length())\n+  if (t->derived_types.length ())\n     {\n       fprintf (f, \"%*s derived types:\\n\", indent * 2, \"\");\n-      for (i = 0; i < t->derived_types.length(); i++)\n+      for (i = 0; i < t->derived_types.length (); i++)\n         dump_odr_type (f, t->derived_types[i], indent + 1);\n     }\n   fprintf (f, \"\\n\");\n@@ -485,19 +485,19 @@ dump_type_inheritance_graph (FILE *f)\n   if (!odr_types_ptr)\n     return;\n   fprintf (f, \"\\n\\nType inheritance graph:\\n\");\n-  for (i = 0; i < odr_types.length(); i++)\n+  for (i = 0; i < odr_types.length (); i++)\n     {\n-      if (odr_types[i]->bases.length() == 0)\n+      if (odr_types[i]->bases.length () == 0)\n \tdump_odr_type (f, odr_types[i]);\n     }\n-  for (i = 0; i < odr_types.length(); i++)\n+  for (i = 0; i < odr_types.length (); i++)\n     {\n-      if (odr_types[i]->types && odr_types[i]->types->length())\n+      if (odr_types[i]->types && odr_types[i]->types->length ())\n \t{\n \t  unsigned int j;\n \t  fprintf (f, \"Duplicate tree types for odr type %i\\n\", i);\n \t  print_node (f, \"\", odr_types[i]->type, 0);\n-\t  for (j = 0; j < odr_types[i]->types->length(); j++)\n+\t  for (j = 0; j < odr_types[i]->types->length (); j++)\n \t    {\n \t      tree t;\n \t      fprintf (f, \"duplicate #%i\\n\", j);\n@@ -665,7 +665,7 @@ possible_polymorphic_call_targets_1 (vec <cgraph_node *> &nodes,\n \n   record_binfo (nodes, binfo, otr_type, binfo, otr_token, inserted,\n \t        matched_vtables, type->anonymous_namespace);\n-  for (i = 0; i < type->derived_types.length(); i++)\n+  for (i = 0; i < type->derived_types.length (); i++)\n     possible_polymorphic_call_targets_1 (nodes, inserted, \n \t\t\t\t\t matched_vtables,\n \t\t\t\t\t otr_type,\n@@ -854,7 +854,7 @@ possible_polymorphic_call_targets (tree otr_type,\n \n   /* Walk recursively all derived types.  Here we need to lookup proper basetype\n      via their BINFO walk that is done by record_binfo  */\n-  for (i = 0; i < type->derived_types.length(); i++)\n+  for (i = 0; i < type->derived_types.length (); i++)\n     possible_polymorphic_call_targets_1 (nodes, inserted,\n \t\t\t\t\t matched_vtables,\n \t\t\t\t\t otr_type, type->derived_types[i],\n@@ -1030,7 +1030,7 @@ ipa_devirt (void)\n \t\tnmultiple++;\n \t\tcontinue;\n \t      }\n-\t    for (i = 0; i < targets.length(); i++)\n+\t    for (i = 0; i < targets.length (); i++)\n \t      if (likely_target_p (targets[i]))\n \t\t{\n \t\t  if (likely_target)\n@@ -1163,17 +1163,17 @@ const pass_data pass_data_ipa_devirt =\n class pass_ipa_devirt : public ipa_opt_pass_d\n {\n public:\n-  pass_ipa_devirt(gcc::context *ctxt)\n-    : ipa_opt_pass_d(pass_data_ipa_devirt, ctxt,\n-\t\t     NULL, /* generate_summary */\n-\t\t     NULL, /* write_summary */\n-\t\t     NULL, /* read_summary */\n-\t\t     NULL, /* write_optimization_summary */\n-\t\t     NULL, /* read_optimization_summary */\n-\t\t     NULL, /* stmt_fixup */\n-\t\t     0, /* function_transform_todo_flags_start */\n-\t\t     NULL, /* function_transform */\n-\t\t     NULL) /* variable_transform */\n+  pass_ipa_devirt (gcc::context *ctxt)\n+    : ipa_opt_pass_d (pass_data_ipa_devirt, ctxt,\n+\t\t      NULL, /* generate_summary */\n+\t\t      NULL, /* write_summary */\n+\t\t      NULL, /* read_summary */\n+\t\t      NULL, /* write_optimization_summary */\n+\t\t      NULL, /* read_optimization_summary */\n+\t\t      NULL, /* stmt_fixup */\n+\t\t      0, /* function_transform_todo_flags_start */\n+\t\t      NULL, /* function_transform */\n+\t\t      NULL) /* variable_transform */\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "00a21d9288a5652484e83daac449ba293562cbfb", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -2739,8 +2739,8 @@ const pass_data pass_data_inline_parameters =\n class pass_inline_parameters : public gimple_opt_pass\n {\n public:\n-  pass_inline_parameters(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_inline_parameters, ctxt)\n+  pass_inline_parameters (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_inline_parameters, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "7735bb9da7bb71a14b414d6d7829b2c73540f2f2", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -904,8 +904,8 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n       sreal tmp, relbenefit_real, growth_real;\n       int relbenefit = relative_time_benefit (callee_info, edge, edge_time);\n \n-      sreal_init(&relbenefit_real, relbenefit, 0);\n-      sreal_init(&growth_real, growth, 0);\n+      sreal_init (&relbenefit_real, relbenefit, 0);\n+      sreal_init (&growth_real, growth, 0);\n \n       /* relative_edge_count.  */\n       sreal_init (&tmp, edge->count, 0);\n@@ -2311,8 +2311,8 @@ const pass_data pass_data_early_inline =\n class pass_early_inline : public gimple_opt_pass\n {\n public:\n-  pass_early_inline(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_early_inline, ctxt)\n+  pass_early_inline (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_early_inline, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -2361,17 +2361,17 @@ const pass_data pass_data_ipa_inline =\n class pass_ipa_inline : public ipa_opt_pass_d\n {\n public:\n-  pass_ipa_inline(gcc::context *ctxt)\n-    : ipa_opt_pass_d(pass_data_ipa_inline, ctxt,\n-\t\t     inline_generate_summary, /* generate_summary */\n-\t\t     inline_write_summary, /* write_summary */\n-\t\t     inline_read_summary, /* read_summary */\n-\t\t     NULL, /* write_optimization_summary */\n-\t\t     NULL, /* read_optimization_summary */\n-\t\t     NULL, /* stmt_fixup */\n-\t\t     0, /* function_transform_todo_flags_start */\n-\t\t     inline_transform, /* function_transform */\n-\t\t     NULL) /* variable_transform */\n+  pass_ipa_inline (gcc::context *ctxt)\n+    : ipa_opt_pass_d (pass_data_ipa_inline, ctxt,\n+\t\t      inline_generate_summary, /* generate_summary */\n+\t\t      inline_write_summary, /* write_summary */\n+\t\t      inline_read_summary, /* read_summary */\n+\t\t      NULL, /* write_optimization_summary */\n+\t\t      NULL, /* read_optimization_summary */\n+\t\t      NULL, /* stmt_fixup */\n+\t\t      0, /* function_transform_todo_flags_start */\n+\t\t      inline_transform, /* function_transform */\n+\t\t      NULL) /* variable_transform */\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "bae9aecd3b1f0b6a0879b881d2ef5afb18d6ee84", "filename": "gcc/ipa-profile.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fipa-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fipa-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-profile.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -240,7 +240,7 @@ ipa_profile_write_summary (void)\n     = lto_create_simple_output_block (LTO_section_ipa_profile);\n   unsigned int i;\n \n-  streamer_write_uhwi_stream (ob->main_stream, histogram.length());\n+  streamer_write_uhwi_stream (ob->main_stream, histogram.length ());\n   for (i = 0; i < histogram.length (); i++)\n     {\n       streamer_write_gcov_count_stream (ob->main_stream, histogram[i]->count);\n@@ -560,7 +560,7 @@ ipa_profile (void)\n           set_hot_bb_threshold (threshold);\n \t}\n     }\n-  histogram.release();\n+  histogram.release ();\n   free_alloc_pool (histogram_pool);\n \n   /* Produce speculative calls: we saved common traget from porfiling into\n@@ -732,17 +732,17 @@ const pass_data pass_data_ipa_profile =\n class pass_ipa_profile : public ipa_opt_pass_d\n {\n public:\n-  pass_ipa_profile(gcc::context *ctxt)\n-    : ipa_opt_pass_d(pass_data_ipa_profile, ctxt,\n-\t\t     ipa_profile_generate_summary, /* generate_summary */\n-\t\t     ipa_profile_write_summary, /* write_summary */\n-\t\t     ipa_profile_read_summary, /* read_summary */\n-\t\t     NULL, /* write_optimization_summary */\n-\t\t     NULL, /* read_optimization_summary */\n-\t\t     NULL, /* stmt_fixup */\n-\t\t     0, /* function_transform_todo_flags_start */\n-\t\t     NULL, /* function_transform */\n-\t\t     NULL) /* variable_transform */\n+  pass_ipa_profile (gcc::context *ctxt)\n+    : ipa_opt_pass_d (pass_data_ipa_profile, ctxt,\n+\t\t      ipa_profile_generate_summary, /* generate_summary */\n+\t\t      ipa_profile_write_summary, /* write_summary */\n+\t\t      ipa_profile_read_summary, /* read_summary */\n+\t\t      NULL, /* write_optimization_summary */\n+\t\t      NULL, /* read_optimization_summary */\n+\t\t      NULL, /* stmt_fixup */\n+\t\t      0, /* function_transform_todo_flags_start */\n+\t\t      NULL, /* function_transform */\n+\t\t      NULL) /* variable_transform */\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "bc0a17bc5dc4238892154e3b63a63a8f0c03166a", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -759,7 +759,7 @@ analyze_function (struct cgraph_node *fn, bool ipa)\n       gimple_stmt_iterator gsi;\n       struct walk_stmt_info wi;\n \n-      memset (&wi, 0, sizeof(wi));\n+      memset (&wi, 0, sizeof (wi));\n       for (gsi = gsi_start_bb (this_block);\n \t   !gsi_end_p (gsi);\n \t   gsi_next (&gsi))\n@@ -1520,17 +1520,17 @@ const pass_data pass_data_ipa_pure_const =\n class pass_ipa_pure_const : public ipa_opt_pass_d\n {\n public:\n-  pass_ipa_pure_const(gcc::context *ctxt)\n-    : ipa_opt_pass_d(pass_data_ipa_pure_const, ctxt,\n-\t\t     pure_const_generate_summary, /* generate_summary */\n-\t\t     pure_const_write_summary, /* write_summary */\n-\t\t     pure_const_read_summary, /* read_summary */\n-\t\t     NULL, /* write_optimization_summary */\n-\t\t     NULL, /* read_optimization_summary */\n-\t\t     NULL, /* stmt_fixup */\n-\t\t     0, /* function_transform_todo_flags_start */\n-\t\t     NULL, /* function_transform */\n-\t\t     NULL) /* variable_transform */\n+  pass_ipa_pure_const (gcc::context *ctxt)\n+    : ipa_opt_pass_d (pass_data_ipa_pure_const, ctxt,\n+\t\t      pure_const_generate_summary, /* generate_summary */\n+\t\t      pure_const_write_summary, /* write_summary */\n+\t\t      pure_const_read_summary, /* read_summary */\n+\t\t      NULL, /* write_optimization_summary */\n+\t\t      NULL, /* read_optimization_summary */\n+\t\t      NULL, /* stmt_fixup */\n+\t\t      0, /* function_transform_todo_flags_start */\n+\t\t      NULL, /* function_transform */\n+\t\t      NULL) /* variable_transform */\n   {}\n \n   /* opt_pass methods: */\n@@ -1704,8 +1704,8 @@ const pass_data pass_data_local_pure_const =\n class pass_local_pure_const : public gimple_opt_pass\n {\n public:\n-  pass_local_pure_const(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_local_pure_const, ctxt)\n+  pass_local_pure_const (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_local_pure_const, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "d9463804ea2c3e2f7ca19ccc64bc27536deab049", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -578,8 +578,7 @@ generate_summary (void)\n \t    EXECUTE_IF_SET_IN_BITMAP (l->statics_written,\n \t\t\t\t      0, index, bi)\n \t      {\n-\t        fprintf(dump_file, \"%s \",\n-\t\t        get_static_name (index));\n+\t        fprintf (dump_file, \"%s \", get_static_name (index));\n \t      }\n \t}\n }\n@@ -949,7 +948,7 @@ stream_out_bitmap (struct lto_simple_output_block *ob,\n   EXECUTE_IF_AND_IN_BITMAP (bits, ltrans_statics, 0, index, bi)\n     {\n       tree decl = (tree)splay_tree_lookup (reference_vars_to_consider, index)->value;\n-      lto_output_var_decl_index(ob->decl_state, ob->main_stream, decl);\n+      lto_output_var_decl_index (ob->decl_state, ob->main_stream, decl);\n     }\n }\n \n@@ -1175,20 +1174,20 @@ const pass_data pass_data_ipa_reference =\n class pass_ipa_reference : public ipa_opt_pass_d\n {\n public:\n-  pass_ipa_reference(gcc::context *ctxt)\n-    : ipa_opt_pass_d(pass_data_ipa_reference, ctxt,\n-\t\t     NULL, /* generate_summary */\n-\t\t     NULL, /* write_summary */\n-\t\t     NULL, /* read_summary */\n-\t\t     ipa_reference_write_optimization_summary, /*\n-\t\t     write_optimization_summary */\n-\t\t     ipa_reference_read_optimization_summary, /*\n-\t\t     read_optimization_summary */\n-\t\t     NULL, /* stmt_fixup */\n-\t\t     0, /* function_transform_todo_flags_start */\n-\t\t     NULL, /* function_transform */\n-\t\t     NULL) /* variable_transform */\n-  {}\n+  pass_ipa_reference (gcc::context *ctxt)\n+    : ipa_opt_pass_d (pass_data_ipa_reference, ctxt,\n+\t\t      NULL, /* generate_summary */\n+\t\t      NULL, /* write_summary */\n+\t\t      NULL, /* read_summary */\n+\t\t      ipa_reference_write_optimization_summary, /*\n+\t\t      write_optimization_summary */\n+\t\t      ipa_reference_read_optimization_summary, /*\n+\t\t      read_optimization_summary */\n+\t\t      NULL, /* stmt_fixup */\n+\t\t      0, /* function_transform_todo_flags_start */\n+\t\t      NULL, /* function_transform */\n+\t\t      NULL) /* variable_transform */\n+    {}\n \n   /* opt_pass methods: */\n   bool gate () { return gate_reference (); }"}, {"sha": "874e7b83542347036ad71469b667a76bf1743fef", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -1650,8 +1650,8 @@ const pass_data pass_data_split_functions =\n class pass_split_functions : public gimple_opt_pass\n {\n public:\n-  pass_split_functions(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_split_functions, ctxt)\n+  pass_split_functions (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_split_functions, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -1710,8 +1710,8 @@ const pass_data pass_data_feedback_split_functions =\n class pass_feedback_split_functions : public gimple_opt_pass\n {\n public:\n-  pass_feedback_split_functions(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_feedback_split_functions, ctxt)\n+  pass_feedback_split_functions (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_feedback_split_functions, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "b59be8c63929d8954322d5d8301cdfbf531978e1", "filename": "gcc/ipa-utils.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fipa-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fipa-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -54,9 +54,9 @@ ipa_print_order (FILE* out,\n   fprintf (out, \"\\n\\n ordered call graph: %s\\n\", note);\n \n   for (i = count - 1; i >= 0; i--)\n-    dump_cgraph_node(dump_file, order[i]);\n+    dump_cgraph_node (dump_file, order[i]);\n   fprintf (out, \"\\n\");\n-  fflush(out);\n+  fflush (out);\n }\n \n \f"}, {"sha": "92343fb22c935a1dc5c84fee63e5883977f5dd51", "filename": "gcc/ipa.c", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -173,7 +173,7 @@ walk_polymorphic_call_targets (pointer_set_t *reachable_call_targets,\n   if (!pointer_set_insert (reachable_call_targets,\n \t\t\t   cache_token))\n     {\n-      for (i = 0; i < targets.length(); i++)\n+      for (i = 0; i < targets.length (); i++)\n \t{\n \t  struct cgraph_node *n = targets[i];\n \n@@ -204,7 +204,7 @@ walk_polymorphic_call_targets (pointer_set_t *reachable_call_targets,\n      make the edge direct.  */\n   if (final)\n     {\n-      if (targets.length() <= 1)\n+      if (targets.length () <= 1)\n \t{\n \t  cgraph_node *target, *node = edge->caller;\n \t  if (targets.length () == 1)\n@@ -882,7 +882,7 @@ function_and_variable_visibility (bool whole_program)\n   struct varpool_node *vnode;\n \n   /* All aliases should be procssed at this point.  */\n-  gcc_checking_assert (!alias_pairs || !alias_pairs->length());\n+  gcc_checking_assert (!alias_pairs || !alias_pairs->length ());\n \n   FOR_EACH_FUNCTION (node)\n     {\n@@ -1122,8 +1122,9 @@ const pass_data pass_data_ipa_function_and_variable_visibility =\n class pass_ipa_function_and_variable_visibility : public simple_ipa_opt_pass\n {\n public:\n-  pass_ipa_function_and_variable_visibility(gcc::context *ctxt)\n-    : simple_ipa_opt_pass(pass_data_ipa_function_and_variable_visibility, ctxt)\n+  pass_ipa_function_and_variable_visibility (gcc::context *ctxt)\n+    : simple_ipa_opt_pass (pass_data_ipa_function_and_variable_visibility,\n+\t\t\t   ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -1170,8 +1171,8 @@ const pass_data pass_data_ipa_free_inline_summary =\n class pass_ipa_free_inline_summary : public simple_ipa_opt_pass\n {\n public:\n-  pass_ipa_free_inline_summary(gcc::context *ctxt)\n-    : simple_ipa_opt_pass(pass_data_ipa_free_inline_summary, ctxt)\n+  pass_ipa_free_inline_summary (gcc::context *ctxt)\n+    : simple_ipa_opt_pass (pass_data_ipa_free_inline_summary, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -1226,17 +1227,17 @@ const pass_data pass_data_ipa_whole_program_visibility =\n class pass_ipa_whole_program_visibility : public ipa_opt_pass_d\n {\n public:\n-  pass_ipa_whole_program_visibility(gcc::context *ctxt)\n-    : ipa_opt_pass_d(pass_data_ipa_whole_program_visibility, ctxt,\n-\t\t     NULL, /* generate_summary */\n-\t\t     NULL, /* write_summary */\n-\t\t     NULL, /* read_summary */\n-\t\t     NULL, /* write_optimization_summary */\n-\t\t     NULL, /* read_optimization_summary */\n-\t\t     NULL, /* stmt_fixup */\n-\t\t     0, /* function_transform_todo_flags_start */\n-\t\t     NULL, /* function_transform */\n-\t\t     NULL) /* variable_transform */\n+  pass_ipa_whole_program_visibility (gcc::context *ctxt)\n+    : ipa_opt_pass_d (pass_data_ipa_whole_program_visibility, ctxt,\n+\t\t      NULL, /* generate_summary */\n+\t\t      NULL, /* write_summary */\n+\t\t      NULL, /* read_summary */\n+\t\t      NULL, /* write_optimization_summary */\n+\t\t      NULL, /* read_optimization_summary */\n+\t\t      NULL, /* stmt_fixup */\n+\t\t      0, /* function_transform_todo_flags_start */\n+\t\t      NULL, /* function_transform */\n+\t\t      NULL) /* variable_transform */\n   {}\n \n   /* opt_pass methods: */\n@@ -1559,17 +1560,17 @@ const pass_data pass_data_ipa_cdtor_merge =\n class pass_ipa_cdtor_merge : public ipa_opt_pass_d\n {\n public:\n-  pass_ipa_cdtor_merge(gcc::context *ctxt)\n-    : ipa_opt_pass_d(pass_data_ipa_cdtor_merge, ctxt,\n-\t\t     NULL, /* generate_summary */\n-\t\t     NULL, /* write_summary */\n-\t\t     NULL, /* read_summary */\n-\t\t     NULL, /* write_optimization_summary */\n-\t\t     NULL, /* read_optimization_summary */\n-\t\t     NULL, /* stmt_fixup */\n-\t\t     0, /* function_transform_todo_flags_start */\n-\t\t     NULL, /* function_transform */\n-\t\t     NULL) /* variable_transform */\n+  pass_ipa_cdtor_merge (gcc::context *ctxt)\n+    : ipa_opt_pass_d (pass_data_ipa_cdtor_merge, ctxt,\n+\t\t      NULL, /* generate_summary */\n+\t\t      NULL, /* write_summary */\n+\t\t      NULL, /* read_summary */\n+\t\t      NULL, /* write_optimization_summary */\n+\t\t      NULL, /* read_optimization_summary */\n+\t\t      NULL, /* stmt_fixup */\n+\t\t      0, /* function_transform_todo_flags_start */\n+\t\t      NULL, /* function_transform */\n+\t\t      NULL) /* variable_transform */\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "32aec6f1da4ef2c1728df25aced41d342e90580a", "filename": "gcc/ira-build.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -2408,8 +2408,8 @@ remove_unnecessary_regions (bool all_p)\n     mark_all_loops_for_removal ();\n   else\n     mark_loops_for_removal ();\n-  children_vec.create(last_basic_block + number_of_loops (cfun));\n-  removed_loop_vec.create(last_basic_block + number_of_loops (cfun));\n+  children_vec.create (last_basic_block + number_of_loops (cfun));\n+  removed_loop_vec.create (last_basic_block + number_of_loops (cfun));\n   remove_uneccesary_loop_nodes_from_loop_tree (ira_loop_tree_root);\n   children_vec.release ();\n   if (all_p)"}, {"sha": "203fbff6a269f6d6b0bbb11c14fe5c1b3bc1f628", "filename": "gcc/ira.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -3515,7 +3515,7 @@ setup_reg_equiv (void)\n static void\n print_insn_chain (FILE *file, struct insn_chain *c)\n {\n-  fprintf (file, \"insn=%d, \", INSN_UID(c->insn));\n+  fprintf (file, \"insn=%d, \", INSN_UID (c->insn));\n   bitmap_print (file, &c->live_throughout, \"live_throughout: \", \", \");\n   bitmap_print (file, &c->dead_or_set, \"dead_or_set: \", \"\\n\");\n }\n@@ -4391,9 +4391,9 @@ allocate_initial_values (void)\n \t\t  /* Update global register liveness information.  */\n \t\t  FOR_EACH_BB (bb)\n \t\t    {\n-\t\t      if (REGNO_REG_SET_P(df_get_live_in (bb), regno))\n+\t\t      if (REGNO_REG_SET_P (df_get_live_in (bb), regno))\n \t\t\tSET_REGNO_REG_SET (df_get_live_in (bb), new_regno);\n-\t\t      if (REGNO_REG_SET_P(df_get_live_out (bb), regno))\n+\t\t      if (REGNO_REG_SET_P (df_get_live_out (bb), regno))\n \t\t\tSET_REGNO_REG_SET (df_get_live_out (bb), new_regno);\n \t\t    }\n \t\t}\n@@ -4792,8 +4792,8 @@ const pass_data pass_data_ira =\n class pass_ira : public rtl_opt_pass\n {\n public:\n-  pass_ira(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_ira, ctxt)\n+  pass_ira (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_ira, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -4836,8 +4836,8 @@ const pass_data pass_data_reload =\n class pass_reload : public rtl_opt_pass\n {\n public:\n-  pass_reload(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_reload, ctxt)\n+  pass_reload (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_reload, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "a27aaa94b8daac5a252493ec196140d69f09a9bd", "filename": "gcc/jump.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -159,8 +159,8 @@ const pass_data pass_data_cleanup_barriers =\n class pass_cleanup_barriers : public rtl_opt_pass\n {\n public:\n-  pass_cleanup_barriers(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_cleanup_barriers, ctxt)\n+  pass_cleanup_barriers (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_cleanup_barriers, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -401,9 +401,9 @@ reversed_comparison_code_parts (enum rtx_code code, const_rtx arg0,\n       /* These CONST_CAST's are okay because prev_nonnote_insn just\n \t returns its argument and we assign it to a const_rtx\n \t variable.  */\n-      for (prev = prev_nonnote_insn (CONST_CAST_RTX(insn));\n+      for (prev = prev_nonnote_insn (CONST_CAST_RTX (insn));\n \t   prev != 0 && !LABEL_P (prev);\n-\t   prev = prev_nonnote_insn (CONST_CAST_RTX(prev)))\n+\t   prev = prev_nonnote_insn (CONST_CAST_RTX (prev)))\n \t{\n \t  const_rtx set = set_of (arg0, prev);\n \t  if (set && GET_CODE (set) == SET"}, {"sha": "b989454ed9e9a4dfb0896c11cfd8eaad37bb3e5c", "filename": "gcc/loop-doloop.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Floop-doloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Floop-doloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-doloop.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -556,7 +556,7 @@ doloop_modify (struct loop *loop, struct niter_desc *desc,\n \t|| !iter.fits_shwi ())\n       iter_rtx = const0_rtx;\n     else\n-      iter_rtx = GEN_INT (iter.to_shwi());\n+      iter_rtx = GEN_INT (iter.to_shwi ());\n     init = gen_doloop_begin (counter_reg,\n \t\t\t     desc->const_iter ? desc->niter_expr : const0_rtx,\n \t\t\t     iter_rtx,\n@@ -673,7 +673,7 @@ doloop_optimize (struct loop *loop)\n       || !iter.fits_shwi ())\n     iterations_max = const0_rtx;\n   else\n-    iterations_max = GEN_INT (iter.to_shwi());\n+    iterations_max = GEN_INT (iter.to_shwi ());\n   level = get_loop_level (loop) + 1;\n \n   /* Generate looping insn.  If the pattern FAILs then give up trying"}, {"sha": "c7aee1da6b92d9767bbc627caa6edd34171b6083", "filename": "gcc/loop-init.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Floop-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Floop-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-init.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -336,8 +336,8 @@ const pass_data pass_data_loop2 =\n class pass_loop2 : public rtl_opt_pass\n {\n public:\n-  pass_loop2(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_loop2, ctxt)\n+  pass_loop2 (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_loop2, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -390,8 +390,8 @@ const pass_data pass_data_rtl_loop_init =\n class pass_rtl_loop_init : public rtl_opt_pass\n {\n public:\n-  pass_rtl_loop_init(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_rtl_loop_init, ctxt)\n+  pass_rtl_loop_init (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_rtl_loop_init, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -448,8 +448,8 @@ const pass_data pass_data_rtl_loop_done =\n class pass_rtl_loop_done : public rtl_opt_pass\n {\n public:\n-  pass_rtl_loop_done(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_rtl_loop_done, ctxt)\n+  pass_rtl_loop_done (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_rtl_loop_done, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -502,8 +502,8 @@ const pass_data pass_data_rtl_move_loop_invariants =\n class pass_rtl_move_loop_invariants : public rtl_opt_pass\n {\n public:\n-  pass_rtl_move_loop_invariants(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_rtl_move_loop_invariants, ctxt)\n+  pass_rtl_move_loop_invariants (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_rtl_move_loop_invariants, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -556,8 +556,8 @@ const pass_data pass_data_rtl_unswitch =\n class pass_rtl_unswitch : public rtl_opt_pass\n {\n public:\n-  pass_rtl_unswitch(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_rtl_unswitch, ctxt)\n+  pass_rtl_unswitch (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_rtl_unswitch, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -623,8 +623,8 @@ const pass_data pass_data_rtl_unroll_and_peel_loops =\n class pass_rtl_unroll_and_peel_loops : public rtl_opt_pass\n {\n public:\n-  pass_rtl_unroll_and_peel_loops(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_rtl_unroll_and_peel_loops, ctxt)\n+  pass_rtl_unroll_and_peel_loops (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_rtl_unroll_and_peel_loops, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -683,8 +683,8 @@ const pass_data pass_data_rtl_doloop =\n class pass_rtl_doloop : public rtl_opt_pass\n {\n public:\n-  pass_rtl_doloop(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_rtl_doloop, ctxt)\n+  pass_rtl_doloop (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_rtl_doloop, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "c5d6b5ac29de83b9cd837defbd2c34826f4b46bb", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -180,7 +180,7 @@ static vec<invariant_p> invariants;\n static void\n check_invariant_table_size (void)\n {\n-  if (invariant_table_size < DF_DEFS_TABLE_SIZE())\n+  if (invariant_table_size < DF_DEFS_TABLE_SIZE ())\n     {\n       unsigned int new_size = DF_DEFS_TABLE_SIZE () + (DF_DEFS_TABLE_SIZE () / 4);\n       invariant_table = XRESIZEVEC (struct invariant *, invariant_table, new_size);\n@@ -274,13 +274,13 @@ invariant_for_use (df_ref use)\n     return NULL;\n   def = defs->ref;\n   check_invariant_table_size ();\n-  if (!invariant_table[DF_REF_ID(def)])\n+  if (!invariant_table[DF_REF_ID (def)])\n     return NULL;\n \n   def_bb = DF_REF_BB (def);\n   if (!dominated_by_p (CDI_DOMINATORS, bb, def_bb))\n     return NULL;\n-  return invariant_table[DF_REF_ID(def)];\n+  return invariant_table[DF_REF_ID (def)];\n }\n \n /* Computes hash value for invariant expression X in INSN.  */\n@@ -807,7 +807,7 @@ check_dependency (basic_block bb, df_ref use, bitmap depends_on)\n \n   def = defs->ref;\n   check_invariant_table_size ();\n-  inv = invariant_table[DF_REF_ID(def)];\n+  inv = invariant_table[DF_REF_ID (def)];\n   if (!inv)\n     return false;\n \n@@ -908,7 +908,7 @@ find_invariant_insn (rtx insn, bool always_reached, bool always_executed)\n     {\n       ref = df_find_def (insn, dest);\n       check_invariant_table_size ();\n-      invariant_table[DF_REF_ID(ref)] = inv;\n+      invariant_table[DF_REF_ID (ref)] = inv;\n     }\n }\n "}, {"sha": "07f28e3affea67bb33e5acaf20c03eaca15fe968", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -99,8 +99,8 @@ static unsigned int iv_ref_table_size = 0;\n static struct rtx_iv ** iv_ref_table;\n \n /* Induction variable stored at the reference.  */\n-#define DF_REF_IV(REF) iv_ref_table[DF_REF_ID(REF)]\n-#define DF_REF_IV_SET(REF, IV) iv_ref_table[DF_REF_ID(REF)] = (IV)\n+#define DF_REF_IV(REF) iv_ref_table[DF_REF_ID (REF)]\n+#define DF_REF_IV_SET(REF, IV) iv_ref_table[DF_REF_ID (REF)] = (IV)\n \n /* The current loop.  */\n \n@@ -212,7 +212,7 @@ lowpart_subreg (enum machine_mode outer_mode, rtx expr,\n static void\n check_iv_ref_table_size (void)\n {\n-  if (iv_ref_table_size < DF_DEFS_TABLE_SIZE())\n+  if (iv_ref_table_size < DF_DEFS_TABLE_SIZE ())\n     {\n       unsigned int new_size = DF_DEFS_TABLE_SIZE () + (DF_DEFS_TABLE_SIZE () / 4);\n       iv_ref_table = XRESIZEVEC (struct rtx_iv *, iv_ref_table, new_size);"}, {"sha": "57b4b3c2467c91133edad43e906863c717f99a54", "filename": "gcc/lower-subreg.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Flower-subreg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Flower-subreg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flower-subreg.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -1709,8 +1709,8 @@ const pass_data pass_data_lower_subreg =\n class pass_lower_subreg : public rtl_opt_pass\n {\n public:\n-  pass_lower_subreg(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_lower_subreg, ctxt)\n+  pass_lower_subreg (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_lower_subreg, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -1748,8 +1748,8 @@ const pass_data pass_data_lower_subreg2 =\n class pass_lower_subreg2 : public rtl_opt_pass\n {\n public:\n-  pass_lower_subreg2(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_lower_subreg2, ctxt)\n+  pass_lower_subreg2 (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_lower_subreg2, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "211eda972690a69054ce71bea804532d780e75fe", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -853,7 +853,7 @@ compute_ltrans_boundary (lto_symtab_encoder_t in_encoder)\n \t      if (!pointer_set_insert (reachable_call_targets,\n \t\t\t\t       cache_token))\n \t\t{\n-\t\t  for (i = 0; i < targets.length(); i++)\n+\t\t  for (i = 0; i < targets.length (); i++)\n \t\t    {\n \t\t      struct cgraph_node *callee = targets[i];\n \n@@ -1560,7 +1560,8 @@ input_symtab (void)\n       ib = lto_create_simple_input_block (file_data, LTO_section_refs,\n \t\t\t\t\t  &data, &len);\n       if (!ib)\n-\tfatal_error(\"cannot find LTO section refs in %s\", file_data->file_name);\n+\tfatal_error (\"cannot find LTO section refs in %s\",\n+\t\t     file_data->file_name);\n       input_refs (ib, nodes);\n       lto_destroy_simple_input_block (file_data, LTO_section_refs,\n \t\t\t\t      ib, data, len);"}, {"sha": "72d450ca9d9bcd01c72611117fc0de2ff72c1aff", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -652,7 +652,7 @@ input_cfg (struct lto_input_block *ib, struct function *fn,\n       index = streamer_read_hwi (ib);\n     }\n \n-  p_bb = ENTRY_BLOCK_PTR_FOR_FUNCTION(fn);\n+  p_bb = ENTRY_BLOCK_PTR_FOR_FUNCTION (fn);\n   index = streamer_read_hwi (ib);\n   while (index != -1)\n     {"}, {"sha": "20d8bfa9c426018675f381397ba7d9823e64c077", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -2034,17 +2034,17 @@ const pass_data pass_data_ipa_lto_gimple_out =\n class pass_ipa_lto_gimple_out : public ipa_opt_pass_d\n {\n public:\n-  pass_ipa_lto_gimple_out(gcc::context *ctxt)\n-    : ipa_opt_pass_d(pass_data_ipa_lto_gimple_out, ctxt,\n-\t\t     NULL, /* generate_summary */\n-\t\t     lto_output, /* write_summary */\n-\t\t     NULL, /* read_summary */\n-\t\t     lto_output, /* write_optimization_summary */\n-\t\t     NULL, /* read_optimization_summary */\n-\t\t     NULL, /* stmt_fixup */\n-\t\t     0, /* function_transform_todo_flags_start */\n-\t\t     NULL, /* function_transform */\n-\t\t     NULL) /* variable_transform */\n+  pass_ipa_lto_gimple_out (gcc::context *ctxt)\n+    : ipa_opt_pass_d (pass_data_ipa_lto_gimple_out, ctxt,\n+\t\t      NULL, /* generate_summary */\n+\t\t      lto_output, /* write_summary */\n+\t\t      NULL, /* read_summary */\n+\t\t      lto_output, /* write_optimization_summary */\n+\t\t      NULL, /* read_optimization_summary */\n+\t\t      NULL, /* stmt_fixup */\n+\t\t      0, /* function_transform_todo_flags_start */\n+\t\t      NULL, /* function_transform */\n+\t\t      NULL) /* variable_transform */\n   {}\n \n   /* opt_pass methods: */\n@@ -2248,7 +2248,7 @@ write_symbol (struct streamer_tree_cache_d *cache,\n       && !targetm.binds_local_p (t))\n     visibility = GCCPV_DEFAULT;\n   else\n-    switch (DECL_VISIBILITY(t))\n+    switch (DECL_VISIBILITY (t))\n       {\n       case VISIBILITY_DEFAULT:\n \tvisibility = GCCPV_DEFAULT;\n@@ -2458,7 +2458,7 @@ produce_asm_for_decls (void)\n       lto_output_decl_state_refs (ob, decl_state_stream, fn_out_state);\n     }\n   lto_write_stream (decl_state_stream);\n-  free(decl_state_stream);\n+  free (decl_state_stream);\n \n   lto_write_stream (ob->main_stream);\n   lto_write_stream (ob->string_stream);\n@@ -2506,17 +2506,17 @@ const pass_data pass_data_ipa_lto_finish_out =\n class pass_ipa_lto_finish_out : public ipa_opt_pass_d\n {\n public:\n-  pass_ipa_lto_finish_out(gcc::context *ctxt)\n-    : ipa_opt_pass_d(pass_data_ipa_lto_finish_out, ctxt,\n-\t\t     NULL, /* generate_summary */\n-\t\t     produce_asm_for_decls, /* write_summary */\n-\t\t     NULL, /* read_summary */\n-\t\t     produce_asm_for_decls, /* write_optimization_summary */\n-\t\t     NULL, /* read_optimization_summary */\n-\t\t     NULL, /* stmt_fixup */\n-\t\t     0, /* function_transform_todo_flags_start */\n-\t\t     NULL, /* function_transform */\n-\t\t     NULL) /* variable_transform */\n+  pass_ipa_lto_finish_out (gcc::context *ctxt)\n+    : ipa_opt_pass_d (pass_data_ipa_lto_finish_out, ctxt,\n+\t\t      NULL, /* generate_summary */\n+\t\t      produce_asm_for_decls, /* write_summary */\n+\t\t      NULL, /* read_summary */\n+\t\t      produce_asm_for_decls, /* write_optimization_summary */\n+\t\t      NULL, /* read_optimization_summary */\n+\t\t      NULL, /* stmt_fixup */\n+\t\t      0, /* function_transform_todo_flags_start */\n+\t\t      NULL, /* function_transform */\n+\t\t      NULL) /* variable_transform */\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "755993ca634e01552612ce36ceaef7689da23054", "filename": "gcc/lto-wrapper.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Flto-wrapper.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Flto-wrapper.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-wrapper.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -744,7 +744,7 @@ run_gcc (unsigned argc, char *argv[])\n \n   if (lto_mode == LTO_MODE_LTO)\n     {\n-      printf(\"%s\\n\", flto_out);\n+      printf (\"%s\\n\", flto_out);\n       free (flto_out);\n       flto_out = NULL;\n     }\n@@ -820,9 +820,9 @@ run_gcc (unsigned argc, char *argv[])\n \t    {\n \t      char *dumpbase\n \t\t  = (char *) xmalloc (strlen (linker_output)\n-\t\t\t\t      + sizeof(DUMPBASE_SUFFIX) + 1);\n+\t\t\t\t      + sizeof (DUMPBASE_SUFFIX) + 1);\n \t      snprintf (dumpbase,\n-\t\t\tstrlen (linker_output) + sizeof(DUMPBASE_SUFFIX),\n+\t\t\tstrlen (linker_output) + sizeof (DUMPBASE_SUFFIX),\n \t\t\t\"%s.ltrans%u\", linker_output, i);\n \t      argv_ptr[0] = dumpbase;\n \t    }"}, {"sha": "52020b8c2f813e94989a117d5003fe87b6853652", "filename": "gcc/mcf.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fmcf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fmcf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmcf.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -385,7 +385,7 @@ add_fixup_edge (fixup_graph_type *fixup_graph, int src, int dest,\n \t\tedge_type type, gcov_type weight, gcov_type cost,\n \t\tgcov_type max_capacity)\n {\n-  fixup_edge_p curr_edge = add_edge(fixup_graph, src, dest, cost);\n+  fixup_edge_p curr_edge = add_edge (fixup_graph, src, dest, cost);\n   curr_edge->type = type;\n   curr_edge->weight = weight;\n   curr_edge->max_capacity = max_capacity;"}, {"sha": "23ed63b10f8b7787fa11aa99509add9b36f9b18a", "filename": "gcc/mode-switching.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fmode-switching.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fmode-switching.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmode-switching.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -804,8 +804,8 @@ const pass_data pass_data_mode_switching =\n class pass_mode_switching : public rtl_opt_pass\n {\n public:\n-  pass_mode_switching(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_mode_switching, ctxt)\n+  pass_mode_switching (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_mode_switching, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "599c025f57de62452d0d063e1bf54a763a7f4328", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -3374,8 +3374,8 @@ const pass_data pass_data_sms =\n class pass_sms : public rtl_opt_pass\n {\n public:\n-  pass_sms(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_sms, ctxt)\n+  pass_sms (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_sms, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "84b2357b7542be46c9868581472fd8a3d7b4d9ab", "filename": "gcc/omp-low.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -6860,8 +6860,8 @@ const pass_data pass_data_expand_omp =\n class pass_expand_omp : public gimple_opt_pass\n {\n public:\n-  pass_expand_omp(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_expand_omp, ctxt)\n+  pass_expand_omp (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_expand_omp, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -8056,8 +8056,8 @@ const pass_data pass_data_lower_omp =\n class pass_lower_omp : public gimple_opt_pass\n {\n public:\n-  pass_lower_omp(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_lower_omp, ctxt)\n+  pass_lower_omp (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_lower_omp, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -8337,8 +8337,8 @@ const pass_data pass_data_diagnose_omp_blocks =\n class pass_diagnose_omp_blocks : public gimple_opt_pass\n {\n public:\n-  pass_diagnose_omp_blocks(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_diagnose_omp_blocks, ctxt)\n+  pass_diagnose_omp_blocks (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_diagnose_omp_blocks, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "06a626c839bf437df5979b8e7f9fc17120dde90b", "filename": "gcc/optabs.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -401,8 +401,8 @@ optab_for_tree_code (enum tree_code code, const_tree type,\n     case FLOOR_DIV_EXPR:\n     case ROUND_DIV_EXPR:\n     case EXACT_DIV_EXPR:\n-      if (TYPE_SATURATING(type))\n-\treturn TYPE_UNSIGNED(type) ? usdiv_optab : ssdiv_optab;\n+      if (TYPE_SATURATING (type))\n+\treturn TYPE_UNSIGNED (type) ? usdiv_optab : ssdiv_optab;\n       return TYPE_UNSIGNED (type) ? udiv_optab : sdiv_optab;\n \n     case LSHIFT_EXPR:\n@@ -413,8 +413,8 @@ optab_for_tree_code (enum tree_code code, const_tree type,\n \n \t  gcc_assert (subtype == optab_scalar);\n \t}\n-      if (TYPE_SATURATING(type))\n-\treturn TYPE_UNSIGNED(type) ? usashl_optab : ssashl_optab;\n+      if (TYPE_SATURATING (type))\n+\treturn TYPE_UNSIGNED (type) ? usashl_optab : ssashl_optab;\n       return ashl_optab;\n \n     case RSHIFT_EXPR:\n@@ -556,23 +556,23 @@ optab_for_tree_code (enum tree_code code, const_tree type,\n     {\n     case POINTER_PLUS_EXPR:\n     case PLUS_EXPR:\n-      if (TYPE_SATURATING(type))\n-\treturn TYPE_UNSIGNED(type) ? usadd_optab : ssadd_optab;\n+      if (TYPE_SATURATING (type))\n+\treturn TYPE_UNSIGNED (type) ? usadd_optab : ssadd_optab;\n       return trapv ? addv_optab : add_optab;\n \n     case MINUS_EXPR:\n-      if (TYPE_SATURATING(type))\n-\treturn TYPE_UNSIGNED(type) ? ussub_optab : sssub_optab;\n+      if (TYPE_SATURATING (type))\n+\treturn TYPE_UNSIGNED (type) ? ussub_optab : sssub_optab;\n       return trapv ? subv_optab : sub_optab;\n \n     case MULT_EXPR:\n-      if (TYPE_SATURATING(type))\n-\treturn TYPE_UNSIGNED(type) ? usmul_optab : ssmul_optab;\n+      if (TYPE_SATURATING (type))\n+\treturn TYPE_UNSIGNED (type) ? usmul_optab : ssmul_optab;\n       return trapv ? smulv_optab : smul_optab;\n \n     case NEGATE_EXPR:\n-      if (TYPE_SATURATING(type))\n-\treturn TYPE_UNSIGNED(type) ? usneg_optab : ssneg_optab;\n+      if (TYPE_SATURATING (type))\n+\treturn TYPE_UNSIGNED (type) ? usneg_optab : ssneg_optab;\n       return trapv ? negv_optab : neg_optab;\n \n     case ABS_EXPR:\n@@ -5714,7 +5714,7 @@ gen_interclass_conv_libfunc (convert_optab tab,\n   fname = GET_MODE_NAME (fmode);\n   tname = GET_MODE_NAME (tmode);\n \n-  if (DECIMAL_FLOAT_MODE_P(fmode) || DECIMAL_FLOAT_MODE_P(tmode))\n+  if (DECIMAL_FLOAT_MODE_P (fmode) || DECIMAL_FLOAT_MODE_P (tmode))\n     {\n       libfunc_name = dec_name;\n       suffix = dec_suffix;\n@@ -5847,7 +5847,7 @@ gen_intraclass_conv_libfunc (convert_optab tab, const char *opname,\n   fname = GET_MODE_NAME (fmode);\n   tname = GET_MODE_NAME (tmode);\n \n-  if (DECIMAL_FLOAT_MODE_P(fmode) || DECIMAL_FLOAT_MODE_P(tmode))\n+  if (DECIMAL_FLOAT_MODE_P (fmode) || DECIMAL_FLOAT_MODE_P (tmode))\n     {\n       libfunc_name = dec_name;\n       suffix = dec_suffix;\n@@ -7585,7 +7585,7 @@ expand_atomic_store (rtx mem, rtx val, enum memmodel model, bool use_release)\n   /* If the size of the object is greater than word size on this target,\n      a default store will not be atomic, Try a mem_exchange and throw away\n      the result.  If that doesn't work, don't do anything.  */\n-  if (GET_MODE_PRECISION(mode) > BITS_PER_WORD)\n+  if (GET_MODE_PRECISION (mode) > BITS_PER_WORD)\n     {\n       rtx target = maybe_emit_atomic_exchange (NULL_RTX, mem, val, model);\n       if (!target)"}, {"sha": "8adfc9bc3dd7723aaa781dbf3e039c38b23456e3", "filename": "gcc/opts.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -169,7 +169,7 @@ base_of_path (const char *path, const char **base_out)\n   char c = *p;\n   while (c)\n     {\n-      if (IS_DIR_SEPARATOR(c))\n+      if (IS_DIR_SEPARATOR (c))\n         {\n           base = p + 1;\n           dot = 0;\n@@ -888,7 +888,7 @@ wrap_help (const char *help,\n \t    }\n \t}\n \n-      printf( \"  %-*.*s %.*s\\n\", col_width, item_width, item, len, help);\n+      printf (\"  %-*.*s %.*s\\n\", col_width, item_width, item, len, help);\n       item_width = 0;\n       while (help[len] == ' ')\n \tlen++;"}, {"sha": "cca6a3567cd1f975d2f2b6880d17b629b69a6b96", "filename": "gcc/pass_manager.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fpass_manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fpass_manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpass_manager.h?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -49,7 +49,7 @@ class pass_manager\n public:\n   void *operator new (size_t sz);\n \n-  pass_manager(context *ctxt);\n+  pass_manager (context *ctxt);\n \n   void register_pass (struct register_pass_info *pass_info);\n   void register_one_dump_file (struct opt_pass *pass);"}, {"sha": "e64281e1d53830dbbfd549413d1a9e1c562168d4", "filename": "gcc/passes.c", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -107,12 +107,12 @@ opt_pass::execute ()\n   return 0;\n }\n \n-opt_pass::opt_pass(const pass_data &data, context *ctxt)\n-  : pass_data(data),\n-    sub(NULL),\n-    next(NULL),\n-    static_pass_number(0),\n-    ctxt_(ctxt)\n+opt_pass::opt_pass (const pass_data &data, context *ctxt)\n+  : pass_data (data),\n+    sub (NULL),\n+    next (NULL),\n+    static_pass_number (0),\n+    ctxt_ (ctxt)\n {\n }\n \n@@ -350,8 +350,8 @@ const pass_data pass_data_early_local_passes =\n class pass_early_local_passes : public simple_ipa_opt_pass\n {\n public:\n-  pass_early_local_passes(gcc::context *ctxt)\n-    : simple_ipa_opt_pass(pass_data_early_local_passes, ctxt)\n+  pass_early_local_passes (gcc::context *ctxt)\n+    : simple_ipa_opt_pass (pass_data_early_local_passes, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -398,8 +398,8 @@ const pass_data pass_data_all_early_optimizations =\n class pass_all_early_optimizations : public gimple_opt_pass\n {\n public:\n-  pass_all_early_optimizations(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_all_early_optimizations, ctxt)\n+  pass_all_early_optimizations (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_all_early_optimizations, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -443,8 +443,8 @@ const pass_data pass_data_all_optimizations =\n class pass_all_optimizations : public gimple_opt_pass\n {\n public:\n-  pass_all_optimizations(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_all_optimizations, ctxt)\n+  pass_all_optimizations (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_all_optimizations, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -488,8 +488,8 @@ const pass_data pass_data_all_optimizations_g =\n class pass_all_optimizations_g : public gimple_opt_pass\n {\n public:\n-  pass_all_optimizations_g(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_all_optimizations_g, ctxt)\n+  pass_all_optimizations_g (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_all_optimizations_g, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -533,8 +533,8 @@ const pass_data pass_data_rest_of_compilation =\n class pass_rest_of_compilation : public rtl_opt_pass\n {\n public:\n-  pass_rest_of_compilation(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_rest_of_compilation, ctxt)\n+  pass_rest_of_compilation (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_rest_of_compilation, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -576,8 +576,8 @@ const pass_data pass_data_postreload =\n class pass_postreload : public rtl_opt_pass\n {\n public:\n-  pass_postreload(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_postreload, ctxt)\n+  pass_postreload (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_postreload, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -836,7 +836,7 @@ dump_one_pass (struct opt_pass *pass, int pass_indent)\n   const char *pn;\n   bool is_on, is_really_on;\n \n-  is_on = pass->has_gate ? pass->gate() : true;\n+  is_on = pass->has_gate ? pass->gate () : true;\n   is_really_on = override_gate_status (pass, current_function_decl, is_on);\n \n   if (pass->static_pass_number <= 0)\n@@ -879,7 +879,7 @@ pass_manager::dump_passes () const\n {\n   struct cgraph_node *n, *node = NULL;\n \n-  create_pass_tab();\n+  create_pass_tab ();\n \n   FOR_EACH_FUNCTION (n)\n     if (DECL_STRUCT_FUNCTION (n->symbol.decl))\n@@ -1485,10 +1485,10 @@ pass_manager::operator new (size_t sz)\n }\n \n pass_manager::pass_manager (context *ctxt)\n-: all_passes(NULL), all_small_ipa_passes(NULL), all_lowering_passes(NULL),\n-  all_regular_ipa_passes(NULL), all_lto_gen_passes(NULL),\n-  all_late_ipa_passes(NULL), passes_by_id(NULL), passes_by_id_size(0),\n-  ctxt_(ctxt)\n+: all_passes (NULL), all_small_ipa_passes (NULL), all_lowering_passes (NULL),\n+  all_regular_ipa_passes (NULL), all_lto_gen_passes (NULL),\n+  all_late_ipa_passes (NULL), passes_by_id (NULL), passes_by_id_size (0),\n+  ctxt_ (ctxt)\n {\n   struct opt_pass **p;\n \n@@ -2090,7 +2090,7 @@ apply_ipa_transforms (void *data)\n   if (!node->global.inlined_to && node->ipa_transforms_to_apply.exists ())\n     {\n       *(bool *)data = true;\n-      execute_all_ipa_transforms();\n+      execute_all_ipa_transforms ();\n       rebuild_cgraph_edges ();\n     }\n }\n@@ -2139,7 +2139,7 @@ execute_one_pass (struct opt_pass *pass)\n \n   /* Check whether gate check should be avoided.\n      User controls the value of the gate through the parameter \"gate_status\". */\n-  gate_status = pass->has_gate ? pass->gate() : true;\n+  gate_status = pass->has_gate ? pass->gate () : true;\n   gate_status = override_gate_status (pass, current_function_decl, gate_status);\n \n   /* Override gate with plugin.  */"}, {"sha": "d7dcb5f4d3606a7d08eba2bbdff4f96d45220ada", "filename": "gcc/plugin.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fplugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fplugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fplugin.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -803,7 +803,7 @@ dump_active_plugins (FILE *file)\n \tfor (ci = plugin_callbacks[event]; ci; ci = ci->next)\n \t  fprintf (file, \" %s\", ci->plugin_name);\n \n-\tputc('\\n', file);\n+\tputc ('\\n', file);\n       }\n }\n "}, {"sha": "941007f5220879bc6ef208e72944232821ef8aef", "filename": "gcc/postreload-gcse.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fpostreload-gcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fpostreload-gcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload-gcse.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -892,7 +892,7 @@ get_avail_load_store_reg (rtx insn)\n {\n   if (REG_P (SET_DEST (PATTERN (insn))))\n     /* A load.  */\n-    return SET_DEST(PATTERN(insn));\n+    return SET_DEST (PATTERN (insn));\n   else\n     {\n       /* A store.  */\n@@ -1344,8 +1344,8 @@ const pass_data pass_data_gcse2 =\n class pass_gcse2 : public rtl_opt_pass\n {\n public:\n-  pass_gcse2(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_gcse2, ctxt)\n+  pass_gcse2 (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_gcse2, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "b0c634223572cad3a3bd62f2a37e85bd3d2984ec", "filename": "gcc/postreload.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -2359,8 +2359,8 @@ const pass_data pass_data_postreload_cse =\n class pass_postreload_cse : public rtl_opt_pass\n {\n public:\n-  pass_postreload_cse(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_postreload_cse, ctxt)\n+  pass_postreload_cse (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_postreload_cse, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "2472fca81cd6d58419515e12a40dd316ed339675", "filename": "gcc/predict.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -2957,8 +2957,8 @@ const pass_data pass_data_profile =\n class pass_profile : public gimple_opt_pass\n {\n public:\n-  pass_profile(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_profile, ctxt)\n+  pass_profile (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_profile, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -2995,8 +2995,8 @@ const pass_data pass_data_strip_predict_hints =\n class pass_strip_predict_hints : public gimple_opt_pass\n {\n public:\n-  pass_strip_predict_hints(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_strip_predict_hints, ctxt)\n+  pass_strip_predict_hints (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_strip_predict_hints, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "6092fbf1987e22cb9b2bcb43b3a8428d5ecec487", "filename": "gcc/prefix.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fprefix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fprefix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprefix.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -250,7 +250,7 @@ update_path (const char *path, const char *key)\n   const int len = strlen (std_prefix);\n \n   if (! filename_ncmp (path, std_prefix, len)\n-      && (IS_DIR_SEPARATOR(path[len])\n+      && (IS_DIR_SEPARATOR (path[len])\n           || path[len] == '\\0')\n       && key != 0)\n     {"}, {"sha": "8cec71b762aedb1eeaa6f02944d9bcdef124126b", "filename": "gcc/pretty-print.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fpretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fpretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpretty-print.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -773,7 +773,7 @@ pretty_printer::pretty_printer (const char *p, int l)\n     format_decoder (),\n     emitted_prefix (),\n     need_newline (),\n-    translate_identifiers(true),\n+    translate_identifiers (true),\n     show_color ()\n {\n   pp_line_cutoff (this) = l;"}, {"sha": "7d712c1562d1023eea68230ccd2c5d0efe8c7b7c", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -399,7 +399,8 @@ print_rtx (const_rtx in_rtx)\n \t\tredundant with line number information and do not print anything\n \t\twhen there is no location information available.  */\n \t    if (INSN_LOCATION (in_rtx) && insn_file (in_rtx))\n-\t      fprintf(outfile, \" %s:%i\", insn_file (in_rtx), insn_line (in_rtx));\n+\t      fprintf (outfile, \" %s:%i\", insn_file (in_rtx),\n+\t\t       insn_line (in_rtx));\n #endif\n \t  }\n \telse if (i == 6 && GET_CODE (in_rtx) == ASM_OPERANDS)"}, {"sha": "4ded0d6360a0c3db5a16998434398e2766fbad47", "filename": "gcc/print-tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -818,7 +818,7 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n \t\tif (ch >= ' ' && ch < 127)\n \t\t  putc (ch, file);\n \t\telse\n-\t\t  fprintf(file, \"\\\\%03o\", ch & 0xFF);\n+\t\t  fprintf (file, \"\\\\%03o\", ch & 0xFF);\n \t      }\n \t    fputc ('\\\"', file);\n \t  }"}, {"sha": "edc202cf767ab52bcdc6d619474e9b7a6678a189", "filename": "gcc/profile.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -275,11 +275,11 @@ get_exec_counts (unsigned cfg_checksum, unsigned lineno_checksum)\n   if (!counts)\n     return NULL;\n \n-  get_working_sets();\n+  get_working_sets ();\n \n   if (dump_file && profile_info)\n-    fprintf(dump_file, \"Merged %u profiles with maximal count %u.\\n\",\n-\t    profile_info->runs, (unsigned) profile_info->sum_max);\n+    fprintf (dump_file, \"Merged %u profiles with maximal count %u.\\n\",\n+\t     profile_info->runs, (unsigned) profile_info->sum_max);\n \n   return counts;\n }\n@@ -976,7 +976,7 @@ branch_prob (void)\n   unsigned num_edges, ignored_edges;\n   unsigned num_instrumented;\n   struct edge_list *el;\n-  histogram_values values = histogram_values();\n+  histogram_values values = histogram_values ();\n   unsigned cfg_checksum, lineno_checksum;\n \n   total_num_times_called++;"}, {"sha": "c108d51fd069742187831cb7132b080118e89822", "filename": "gcc/read-md.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fread-md.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fread-md.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-md.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -672,7 +672,7 @@ scan_comma_elt (const char **pstr)\n \n   if (*p == ',')\n     p++;\n-  while (ISSPACE(*p))\n+  while (ISSPACE (*p))\n     p++;\n \n   if (*p == '\\0')"}, {"sha": "b59be66af94dc2a7f36846de2c42df872f86d5af", "filename": "gcc/real.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -2855,7 +2855,7 @@ real_hash (const REAL_VALUE_TYPE *r)\n       gcc_unreachable ();\n     }\n \n-  if (sizeof(unsigned long) > sizeof(unsigned int))\n+  if (sizeof (unsigned long) > sizeof (unsigned int))\n     for (i = 0; i < SIGSZ; ++i)\n       {\n \tunsigned long s = r->sig[i];"}, {"sha": "b92453411d7406fa2f3431b80769538d5c8c0243", "filename": "gcc/real.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Freal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Freal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.h?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -73,7 +73,7 @@ struct GTY(()) real_value {\n \n /* Verify the guess.  */\n extern char test_real_width\n-  [sizeof(REAL_VALUE_TYPE) <= REAL_WIDTH*sizeof(HOST_WIDE_INT) ? 1 : -1];\n+  [sizeof (REAL_VALUE_TYPE) <= REAL_WIDTH * sizeof (HOST_WIDE_INT) ? 1 : -1];\n \n /* Calculate the format for CONST_DOUBLE.  We need as many slots as\n    are necessary to overlay a REAL_VALUE_TYPE on them.  This could be"}, {"sha": "f64753ad6cad0ed3a53b4e1c2f8c1082291d2804", "filename": "gcc/recog.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -3801,8 +3801,8 @@ const pass_data pass_data_peephole2 =\n class pass_peephole2 : public rtl_opt_pass\n {\n public:\n-  pass_peephole2(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_peephole2, ctxt)\n+  pass_peephole2 (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_peephole2, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -3849,8 +3849,8 @@ const pass_data pass_data_split_all_insns =\n class pass_split_all_insns : public rtl_opt_pass\n {\n public:\n-  pass_split_all_insns(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_split_all_insns, ctxt)\n+  pass_split_all_insns (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_split_all_insns, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -3900,8 +3900,8 @@ const pass_data pass_data_split_after_reload =\n class pass_split_after_reload : public rtl_opt_pass\n {\n public:\n-  pass_split_after_reload(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_split_after_reload, ctxt)\n+  pass_split_after_reload (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_split_after_reload, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -3962,8 +3962,8 @@ const pass_data pass_data_split_before_regstack =\n class pass_split_before_regstack : public rtl_opt_pass\n {\n public:\n-  pass_split_before_regstack(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_split_before_regstack, ctxt)\n+  pass_split_before_regstack (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_split_before_regstack, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -4021,8 +4021,8 @@ const pass_data pass_data_split_before_sched2 =\n class pass_split_before_sched2 : public rtl_opt_pass\n {\n public:\n-  pass_split_before_sched2(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_split_before_sched2, ctxt)\n+  pass_split_before_sched2 (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_split_before_sched2, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -4071,8 +4071,8 @@ const pass_data pass_data_split_for_shorten_branches =\n class pass_split_for_shorten_branches : public rtl_opt_pass\n {\n public:\n-  pass_split_for_shorten_branches(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_split_for_shorten_branches, ctxt)\n+  pass_split_for_shorten_branches (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_split_for_shorten_branches, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "fa05feed7491cf9af20ae062b0fba35d0e79eec8", "filename": "gcc/ree.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Free.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Free.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Free.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -800,7 +800,7 @@ add_removable_extension (const_rtx expr, rtx insn,\n       /* Second, make sure the reaching definitions don't feed another and\n \t different extension.  FIXME: this obviously can be improved.  */\n       for (def = defs; def; def = def->next)\n-\tif ((idx = def_map[INSN_UID(DF_REF_INSN (def->ref))])\n+\tif ((idx = def_map[INSN_UID (DF_REF_INSN (def->ref))])\n \t    && (cand = &(*insn_list)[idx - 1])\n \t    && cand->code != code)\n \t  {\n@@ -820,7 +820,7 @@ add_removable_extension (const_rtx expr, rtx insn,\n       idx = insn_list->length ();\n \n       for (def = defs; def; def = def->next)\n-\tdef_map[INSN_UID(DF_REF_INSN (def->ref))] = idx;\n+\tdef_map[INSN_UID (DF_REF_INSN (def->ref))] = idx;\n     }\n }\n \n@@ -961,8 +961,8 @@ const pass_data pass_data_ree =\n class pass_ree : public rtl_opt_pass\n {\n public:\n-  pass_ree(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_ree, ctxt)\n+  pass_ree (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_ree, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "1917c46fe961adcd0f00880ae4140dbda8b699f8", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -253,7 +253,7 @@ static void replace_reg (rtx *, int);\n static void remove_regno_note (rtx, enum reg_note, unsigned int);\n static int get_hard_regnum (stack_ptr, rtx);\n static rtx emit_pop_insn (rtx, stack_ptr, rtx, enum emit_where);\n-static void swap_to_top(rtx, stack_ptr, rtx, rtx);\n+static void swap_to_top (rtx, stack_ptr, rtx, rtx);\n static bool move_for_stack_reg (rtx, stack_ptr, rtx);\n static bool move_nan_for_stack_reg (rtx, stack_ptr, rtx);\n static int swap_rtx_condition_1 (rtx);\n@@ -3314,8 +3314,8 @@ const pass_data pass_data_stack_regs =\n class pass_stack_regs : public rtl_opt_pass\n {\n public:\n-  pass_stack_regs(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_stack_regs, ctxt)\n+  pass_stack_regs (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_stack_regs, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -3363,8 +3363,8 @@ const pass_data pass_data_stack_regs_run =\n class pass_stack_regs_run : public rtl_opt_pass\n {\n public:\n-  pass_stack_regs_run(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_stack_regs_run, ctxt)\n+  pass_stack_regs_run (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_stack_regs_run, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "0fa0afbc82488d26685183c26d7e0acba8d0b9e3", "filename": "gcc/regcprop.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fregcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fregcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregcprop.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -1256,8 +1256,8 @@ const pass_data pass_data_cprop_hardreg =\n class pass_cprop_hardreg : public rtl_opt_pass\n {\n public:\n-  pass_cprop_hardreg(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_cprop_hardreg, ctxt)\n+  pass_cprop_hardreg (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_cprop_hardreg, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "26318dc503add33db065afdf215e55b1e9060a1e", "filename": "gcc/reginfo.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Freginfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Freginfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freginfo.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -447,7 +447,7 @@ init_reg_sets_1 (void)\n         }\n     }\n \n-  COPY_HARD_REG_SET(call_fixed_reg_set, fixed_reg_set);\n+  COPY_HARD_REG_SET (call_fixed_reg_set, fixed_reg_set);\n \n   /* Preserve global registers if called more than once.  */\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n@@ -495,7 +495,7 @@ init_reg_modes_target (void)\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     for (j = 0; j < MAX_MACHINE_MODE; j++)\n-      hard_regno_nregs[i][j] = HARD_REGNO_NREGS(i, (enum machine_mode)j);\n+      hard_regno_nregs[i][j] = HARD_REGNO_NREGS (i, (enum machine_mode)j);\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     {\n@@ -980,8 +980,8 @@ const pass_data pass_data_reginfo_init =\n class pass_reginfo_init : public rtl_opt_pass\n {\n public:\n-  pass_reginfo_init(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_reginfo_init, ctxt)\n+  pass_reginfo_init (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_reginfo_init, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "85c7ff490c840a439062066f88bc6957a576ecf5", "filename": "gcc/regmove.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -1382,8 +1382,8 @@ const pass_data pass_data_regmove =\n class pass_regmove : public rtl_opt_pass\n {\n public:\n-  pass_regmove(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_regmove, ctxt)\n+  pass_regmove (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_regmove, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "5b2c85799bb3cb6dc698c79871bdbc46e16ed024", "filename": "gcc/regrename.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -1862,8 +1862,8 @@ const pass_data pass_data_regrename =\n class pass_regrename : public rtl_opt_pass\n {\n public:\n-  pass_regrename(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_regrename, ctxt)\n+  pass_regrename (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_regrename, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "b5fa3f3995f3ff8dc8d288c33edfef3cabec7314", "filename": "gcc/regs.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fregs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fregs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregs.h?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -69,7 +69,7 @@ extern struct regstat_n_sets_and_refs_t *regstat_n_sets_and_refs;\n \n /* Indexed by n, gives number of times (REG n) is used or set.  */\n static inline int\n-REG_N_REFS(int regno)\n+REG_N_REFS (int regno)\n {\n   return regstat_n_sets_and_refs[regno].refs;\n }"}, {"sha": "85678a70f68c8e3af3553762976c804abeab0de1", "filename": "gcc/regstat.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fregstat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fregstat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregstat.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -172,7 +172,7 @@ regstat_bb_compute_ri (unsigned int bb_index,\n       while (link)\n \t{\n \t  if (REG_NOTE_KIND (link) == REG_DEAD)\n-\t    REG_N_DEATHS(REGNO (XEXP (link, 0)))++;\n+\t    REG_N_DEATHS (REGNO (XEXP (link, 0)))++;\n \t  link = XEXP (link, 1);\n \t}\n "}, {"sha": "bb13bf802d1fc697f356bdb4fb6c5d0f2245917b", "filename": "gcc/reload1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -2325,7 +2325,7 @@ mark_home_live_1 (int regno, enum machine_mode mode)\n     return;\n   lim = end_hard_regno (mode, i);\n   while (i < lim)\n-    df_set_regs_ever_live(i++, true);\n+    df_set_regs_ever_live (i++, true);\n }\n \n /* Mark the slots in regs_ever_live for the hard regs"}, {"sha": "e9aa889b17d8a6a39395b8843e372f0bb8001e04", "filename": "gcc/reorg.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -2173,7 +2173,7 @@ fill_simple_delay_slots (int non_jumps_p)\n \t\t  && ! (maybe_never && may_trap_or_fault_p (pat))\n \t\t  && (trial = try_split (pat, trial, 0))\n \t\t  && eligible_for_delay (insn, slots_filled, trial, flags)\n-\t\t  && ! can_throw_internal(trial))\n+\t\t  && ! can_throw_internal (trial))\n \t\t{\n \t\t  next_trial = next_nonnote_insn (trial);\n \t\t  delay_list = add_to_delay_list (trial, delay_list);\n@@ -2363,8 +2363,8 @@ fill_slots_from_thread (rtx insn, rtx condition, rtx thread,\n   int flags;\n \n   /* Validate our arguments.  */\n-  gcc_assert(condition != const_true_rtx || thread_if_true);\n-  gcc_assert(own_thread || thread_if_true);\n+  gcc_assert (condition != const_true_rtx || thread_if_true);\n+  gcc_assert (own_thread || thread_if_true);\n \n   flags = get_jump_flags (insn, JUMP_LABEL (insn));\n \n@@ -3888,8 +3888,8 @@ const pass_data pass_data_delay_slots =\n class pass_delay_slots : public rtl_opt_pass\n {\n public:\n-  pass_delay_slots(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_delay_slots, ctxt)\n+  pass_delay_slots (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_delay_slots, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -3941,8 +3941,8 @@ const pass_data pass_data_machine_reorg =\n class pass_machine_reorg : public rtl_opt_pass\n {\n public:\n-  pass_machine_reorg(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_machine_reorg, ctxt)\n+  pass_machine_reorg (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_machine_reorg, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "52b7747b693eff4da42e5a60aee84be4f1bba447", "filename": "gcc/rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -222,7 +222,7 @@ shared_const_p (const_rtx orig)\n      a LABEL_REF, it isn't sharable.  */\n   return (GET_CODE (XEXP (orig, 0)) == PLUS\n \t  && GET_CODE (XEXP (XEXP (orig, 0), 0)) == SYMBOL_REF\n-\t  && CONST_INT_P(XEXP (XEXP (orig, 0), 1)));\n+\t  && CONST_INT_P (XEXP (XEXP (orig, 0), 1)));\n }\n \n "}, {"sha": "247a0d0670183a3a7d57f9968fc78b7e0f4a1bc3", "filename": "gcc/rtl.h", "status": "modified", "additions": 74, "deletions": 72, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -544,7 +544,7 @@ struct GTY((variable_size)) rtvec_def {\n      if (_n < 0 || _n >= GET_RTX_LENGTH (_code))\t\t\t\\\n        rtl_check_failed_bounds (_rtx, _n, __FILE__, __LINE__,\t\t\\\n \t\t\t\t__FUNCTION__);\t\t\t\t\\\n-     if (GET_RTX_FORMAT(_code)[_n] != C1)\t\t\t\t\\\n+     if (GET_RTX_FORMAT (_code)[_n] != C1)\t\t\t\t\\\n        rtl_check_failed_type1 (_rtx, _n, C1, __FILE__, __LINE__,\t\\\n \t\t\t       __FUNCTION__);\t\t\t\t\\\n      &_rtx->u.fld[_n]; }))\n@@ -555,8 +555,8 @@ struct GTY((variable_size)) rtvec_def {\n      if (_n < 0 || _n >= GET_RTX_LENGTH (_code))\t\t\t\\\n        rtl_check_failed_bounds (_rtx, _n, __FILE__, __LINE__,\t\t\\\n \t\t\t\t__FUNCTION__);\t\t\t\t\\\n-     if (GET_RTX_FORMAT(_code)[_n] != C1\t\t\t\t\\\n-\t && GET_RTX_FORMAT(_code)[_n] != C2)\t\t\t\t\\\n+     if (GET_RTX_FORMAT (_code)[_n] != C1\t\t\t\t\\\n+\t && GET_RTX_FORMAT (_code)[_n] != C2)\t\t\t\t\\\n        rtl_check_failed_type2 (_rtx, _n, C1, C2, __FILE__, __LINE__,\t\\\n \t\t\t       __FUNCTION__);\t\t\t\t\\\n      &_rtx->u.fld[_n]; }))\n@@ -589,7 +589,7 @@ struct GTY((variable_size)) rtvec_def {\n      if (_n < 0 || _n >= GET_RTX_LENGTH (_code))\t\t\t\\\n        rtl_check_failed_bounds (_rtx, _n, __FILE__, __LINE__,\t\t\\\n \t\t\t\t__FUNCTION__);\t\t\t\t\\\n-     if (GET_RTX_FORMAT(_code)[_n] != 'w')\t\t\t\t\\\n+     if (GET_RTX_FORMAT (_code)[_n] != 'w')\t\t\t\t\\\n        rtl_check_failed_type1 (_rtx, _n, 'w', __FILE__, __LINE__,\t\\\n \t\t\t       __FUNCTION__);\t\t\t\t\\\n      &_rtx->u.hwint[_n]; }))\n@@ -679,71 +679,71 @@ extern void rtvec_check_failed_bounds (const_rtvec, int, const char *, int,\n #if defined ENABLE_RTL_FLAG_CHECKING && (GCC_VERSION >= 2007)\n #define RTL_FLAG_CHECK1(NAME, RTX, C1) __extension__\t\t\t\\\n ({ __typeof (RTX) const _rtx = (RTX);\t\t\t\t\t\\\n-   if (GET_CODE(_rtx) != C1)\t\t\t\t\t\t\\\n+   if (GET_CODE (_rtx) != C1)\t\t\t\t\t\t\\\n      rtl_check_failed_flag  (NAME, _rtx, __FILE__, __LINE__,\t\t\\\n \t\t\t     __FUNCTION__);\t\t\t\t\\\n    _rtx; })\n \n #define RTL_FLAG_CHECK2(NAME, RTX, C1, C2) __extension__\t\t\\\n ({ __typeof (RTX) const _rtx = (RTX);\t\t\t\t\t\\\n-   if (GET_CODE(_rtx) != C1 && GET_CODE(_rtx) != C2)\t\t\t\\\n+   if (GET_CODE (_rtx) != C1 && GET_CODE(_rtx) != C2)\t\t\t\\\n      rtl_check_failed_flag  (NAME,_rtx, __FILE__, __LINE__,\t\t\\\n \t\t\t      __FUNCTION__);\t\t\t\t\\\n    _rtx; })\n \n #define RTL_FLAG_CHECK3(NAME, RTX, C1, C2, C3) __extension__\t\t\\\n ({ __typeof (RTX) const _rtx = (RTX);\t\t\t\t\t\\\n-   if (GET_CODE(_rtx) != C1 && GET_CODE(_rtx) != C2\t\t\t\\\n-       && GET_CODE(_rtx) != C3)\t\t\t\t\t\t\\\n+   if (GET_CODE (_rtx) != C1 && GET_CODE(_rtx) != C2\t\t\t\\\n+       && GET_CODE (_rtx) != C3)\t\t\t\t\t\\\n      rtl_check_failed_flag  (NAME, _rtx, __FILE__, __LINE__,\t\t\\\n \t\t\t     __FUNCTION__);\t\t\t\t\\\n    _rtx; })\n \n #define RTL_FLAG_CHECK4(NAME, RTX, C1, C2, C3, C4) __extension__\t\\\n ({ __typeof (RTX) const _rtx = (RTX);\t\t\t\t\t\\\n-   if (GET_CODE(_rtx) != C1 && GET_CODE(_rtx) != C2\t\t\t\\\n-       && GET_CODE(_rtx) != C3 && GET_CODE(_rtx) != C4)\t\t\t\\\n+   if (GET_CODE (_rtx) != C1 && GET_CODE(_rtx) != C2\t\t\t\\\n+       && GET_CODE (_rtx) != C3 && GET_CODE(_rtx) != C4)\t\t\\\n      rtl_check_failed_flag  (NAME, _rtx, __FILE__, __LINE__,\t\t\\\n \t\t\t      __FUNCTION__);\t\t\t\t\\\n    _rtx; })\n \n #define RTL_FLAG_CHECK5(NAME, RTX, C1, C2, C3, C4, C5) __extension__\t\\\n ({ __typeof (RTX) const _rtx = (RTX);\t\t\t\t\t\\\n-   if (GET_CODE(_rtx) != C1 && GET_CODE(_rtx) != C2\t\t\t\\\n-       && GET_CODE(_rtx) != C3 && GET_CODE(_rtx) != C4\t\t\t\\\n-       && GET_CODE(_rtx) != C5)\t\t\t\t\t\t\\\n+   if (GET_CODE (_rtx) != C1 && GET_CODE (_rtx) != C2\t\t\t\\\n+       && GET_CODE (_rtx) != C3 && GET_CODE (_rtx) != C4\t\t\\\n+       && GET_CODE (_rtx) != C5)\t\t\t\t\t\\\n      rtl_check_failed_flag  (NAME, _rtx, __FILE__, __LINE__,\t\t\\\n \t\t\t     __FUNCTION__);\t\t\t\t\\\n    _rtx; })\n \n #define RTL_FLAG_CHECK6(NAME, RTX, C1, C2, C3, C4, C5, C6)\t\t\\\n   __extension__\t\t\t\t\t\t\t\t\\\n ({ __typeof (RTX) const _rtx = (RTX);\t\t\t\t\t\\\n-   if (GET_CODE(_rtx) != C1 && GET_CODE(_rtx) != C2\t\t\t\\\n-       && GET_CODE(_rtx) != C3 && GET_CODE(_rtx) != C4\t\t\t\\\n-       && GET_CODE(_rtx) != C5 && GET_CODE(_rtx) != C6)\t\t\t\\\n+   if (GET_CODE (_rtx) != C1 && GET_CODE (_rtx) != C2\t\t\t\\\n+       && GET_CODE (_rtx) != C3 && GET_CODE (_rtx) != C4\t\t\\\n+       && GET_CODE (_rtx) != C5 && GET_CODE (_rtx) != C6)\t\t\\\n      rtl_check_failed_flag  (NAME,_rtx, __FILE__, __LINE__,\t\t\\\n \t\t\t     __FUNCTION__);\t\t\t\t\\\n    _rtx; })\n \n #define RTL_FLAG_CHECK7(NAME, RTX, C1, C2, C3, C4, C5, C6, C7)\t\t\\\n   __extension__\t\t\t\t\t\t\t\t\\\n ({ __typeof (RTX) const _rtx = (RTX);\t\t\t\t\t\\\n-   if (GET_CODE(_rtx) != C1 && GET_CODE(_rtx) != C2\t\t\t\\\n-       && GET_CODE(_rtx) != C3 && GET_CODE(_rtx) != C4\t\t\t\\\n-       && GET_CODE(_rtx) != C5 && GET_CODE(_rtx) != C6\t\t\t\\\n-       && GET_CODE(_rtx) != C7)\t\t\t\t\t\t\\\n+   if (GET_CODE (_rtx) != C1 && GET_CODE (_rtx) != C2\t\t\t\\\n+       && GET_CODE (_rtx) != C3 && GET_CODE (_rtx) != C4\t\t\\\n+       && GET_CODE (_rtx) != C5 && GET_CODE (_rtx) != C6\t\t\\\n+       && GET_CODE (_rtx) != C7)\t\t\t\t\t\\\n      rtl_check_failed_flag  (NAME, _rtx, __FILE__, __LINE__,\t\t\\\n \t\t\t     __FUNCTION__);\t\t\t\t\\\n    _rtx; })\n \n #define RTL_FLAG_CHECK8(NAME, RTX, C1, C2, C3, C4, C5, C6, C7, C8)\t\\\n   __extension__\t\t\t\t\t\t\t\t\\\n ({ __typeof (RTX) const _rtx = (RTX);\t\t\t\t\t\\\n-   if (GET_CODE(_rtx) != C1 && GET_CODE(_rtx) != C2\t\t\t\\\n-       && GET_CODE(_rtx) != C3 && GET_CODE(_rtx) != C4\t\t\t\\\n-       && GET_CODE(_rtx) != C5 && GET_CODE(_rtx) != C6\t\t\t\\\n-       && GET_CODE(_rtx) != C7 && GET_CODE(_rtx) != C8)\t\t\t\\\n+   if (GET_CODE (_rtx) != C1 && GET_CODE (_rtx) != C2\t\t\t\\\n+       && GET_CODE (_rtx) != C3 && GET_CODE (_rtx) != C4\t\t\\\n+       && GET_CODE (_rtx) != C5 && GET_CODE (_rtx) != C6\t\t\\\n+       && GET_CODE (_rtx) != C7 && GET_CODE (_rtx) != C8)\t\t\\\n      rtl_check_failed_flag  (NAME, _rtx, __FILE__, __LINE__,\t\t\\\n \t\t\t     __FUNCTION__);\t\t\t\t\\\n    _rtx; })\n@@ -844,56 +844,57 @@ extern void rtl_check_failed_flag (const char *, const_rtx, const char *,\n #define INSN_CODE(INSN) XINT (INSN, 6)\n \n #define RTX_FRAME_RELATED_P(RTX)\t\t\t\t\t\\\n-  (RTL_FLAG_CHECK6(\"RTX_FRAME_RELATED_P\", (RTX), DEBUG_INSN, INSN,\t\\\n-\t\t   CALL_INSN, JUMP_INSN, BARRIER, SET)->frame_related)\n+  (RTL_FLAG_CHECK6 (\"RTX_FRAME_RELATED_P\", (RTX), DEBUG_INSN, INSN,\t\\\n+\t\t    CALL_INSN, JUMP_INSN, BARRIER, SET)->frame_related)\n \n /* 1 if RTX is an insn that has been deleted.  */\n #define INSN_DELETED_P(RTX)\t\t\t\t\t\t\\\n-  (RTL_FLAG_CHECK8(\"INSN_DELETED_P\", (RTX), DEBUG_INSN, INSN,\t\t\\\n-\t\t   CALL_INSN, JUMP_INSN, JUMP_TABLE_DATA,\t\t\\\n-\t\t   CODE_LABEL, BARRIER, NOTE)->volatil)\n+  (RTL_FLAG_CHECK8 (\"INSN_DELETED_P\", (RTX), DEBUG_INSN, INSN,\t\t\\\n+\t\t    CALL_INSN, JUMP_INSN, JUMP_TABLE_DATA,\t\t\\\n+\t\t    CODE_LABEL, BARRIER, NOTE)->volatil)\n \n /* 1 if RTX is a call to a const function.  Built from ECF_CONST and\n    TREE_READONLY.  */\n #define RTL_CONST_CALL_P(RTX)\t\t\t\t\t\\\n-  (RTL_FLAG_CHECK1(\"RTL_CONST_CALL_P\", (RTX), CALL_INSN)->unchanging)\n+  (RTL_FLAG_CHECK1 (\"RTL_CONST_CALL_P\", (RTX), CALL_INSN)->unchanging)\n \n /* 1 if RTX is a call to a pure function.  Built from ECF_PURE and\n    DECL_PURE_P.  */\n #define RTL_PURE_CALL_P(RTX)\t\t\t\t\t\\\n-  (RTL_FLAG_CHECK1(\"RTL_PURE_CALL_P\", (RTX), CALL_INSN)->return_val)\n+  (RTL_FLAG_CHECK1 (\"RTL_PURE_CALL_P\", (RTX), CALL_INSN)->return_val)\n \n /* 1 if RTX is a call to a const or pure function.  */\n #define RTL_CONST_OR_PURE_CALL_P(RTX) \\\n-  (RTL_CONST_CALL_P(RTX) || RTL_PURE_CALL_P(RTX))\n+  (RTL_CONST_CALL_P (RTX) || RTL_PURE_CALL_P (RTX))\n \n /* 1 if RTX is a call to a looping const or pure function.  Built from\n    ECF_LOOPING_CONST_OR_PURE and DECL_LOOPING_CONST_OR_PURE_P.  */\n #define RTL_LOOPING_CONST_OR_PURE_CALL_P(RTX)\t\t\t\t\\\n-  (RTL_FLAG_CHECK1(\"CONST_OR_PURE_CALL_P\", (RTX), CALL_INSN)->call)\n+  (RTL_FLAG_CHECK1 (\"CONST_OR_PURE_CALL_P\", (RTX), CALL_INSN)->call)\n \n /* 1 if RTX is a call_insn for a sibling call.  */\n #define SIBLING_CALL_P(RTX)\t\t\t\t\t\t\\\n-  (RTL_FLAG_CHECK1(\"SIBLING_CALL_P\", (RTX), CALL_INSN)->jump)\n+  (RTL_FLAG_CHECK1 (\"SIBLING_CALL_P\", (RTX), CALL_INSN)->jump)\n \n /* 1 if RTX is a jump_insn, call_insn, or insn that is an annulling branch.  */\n #define INSN_ANNULLED_BRANCH_P(RTX)\t\t\t\t\t\\\n-  (RTL_FLAG_CHECK1(\"INSN_ANNULLED_BRANCH_P\", (RTX), JUMP_INSN)->unchanging)\n+  (RTL_FLAG_CHECK1 (\"INSN_ANNULLED_BRANCH_P\", (RTX), JUMP_INSN)->unchanging)\n \n /* 1 if RTX is an insn in a delay slot and is from the target of the branch.\n    If the branch insn has INSN_ANNULLED_BRANCH_P set, this insn should only be\n    executed if the branch is taken.  For annulled branches with this bit\n    clear, the insn should be executed only if the branch is not taken.  */\n #define INSN_FROM_TARGET_P(RTX)\t\t\t\t\t\t\\\n-  (RTL_FLAG_CHECK3(\"INSN_FROM_TARGET_P\", (RTX), INSN, JUMP_INSN, CALL_INSN)->in_struct)\n+  (RTL_FLAG_CHECK3 (\"INSN_FROM_TARGET_P\", (RTX), INSN, JUMP_INSN, \\\n+\t\t    CALL_INSN)->in_struct)\n \n /* In an ADDR_DIFF_VEC, the flags for RTX for use by branch shortening.\n    See the comments for ADDR_DIFF_VEC in rtl.def.  */\n-#define ADDR_DIFF_VEC_FLAGS(RTX) X0ADVFLAGS(RTX, 4)\n+#define ADDR_DIFF_VEC_FLAGS(RTX) X0ADVFLAGS (RTX, 4)\n \n /* In a VALUE, the value cselib has assigned to RTX.\n    This is a \"struct cselib_val_struct\", see cselib.h.  */\n-#define CSELIB_VAL_PTR(RTX) X0CSELIB(RTX, 0)\n+#define CSELIB_VAL_PTR(RTX) X0CSELIB (RTX, 0)\n \n /* Holds a list of notes on what this insn does to various REGs.\n    It is a chain of EXPR_LIST rtx's, where the second operand is the\n@@ -1003,7 +1004,7 @@ extern const char * const reg_note_name[];\n /* 1 if RTX is emitted after a call, but it should take effect before\n    the call returns.  */\n #define NOTE_DURING_CALL_P(RTX)\t\t\t\t\\\n-  (RTL_FLAG_CHECK1(\"NOTE_VAR_LOCATION_DURING_CALL_P\", (RTX), NOTE)->call)\n+  (RTL_FLAG_CHECK1 (\"NOTE_VAR_LOCATION_DURING_CALL_P\", (RTX), NOTE)->call)\n \n /* DEBUG_EXPR_DECL corresponding to a DEBUG_EXPR RTX.  */\n #define DEBUG_EXPR_TREE_DECL(RTX) XCTREE (RTX, 0, DEBUG_EXPR)\n@@ -1109,7 +1110,8 @@ enum label_kind\n /* For a REG rtx, REGNO extracts the register number.  REGNO can only\n    be used on RHS.  Use SET_REGNO to change the value.  */\n #define REGNO(RTX) (rhs_regno(RTX))\n-#define SET_REGNO(RTX,N) (df_ref_change_reg_with_loc (REGNO(RTX), N, RTX), XCUINT (RTX, 0, REG) = N)\n+#define SET_REGNO(RTX,N) \\\n+  (df_ref_change_reg_with_loc (REGNO (RTX), N, RTX), XCUINT (RTX, 0, REG) = N)\n #define SET_REGNO_RAW(RTX,N) (XCUINT (RTX, 0, REG) = N)\n \n /* ORIGINAL_REGNO holds the number the register originally had; for a\n@@ -1128,19 +1130,19 @@ rhs_regno (const_rtx x)\n /* 1 if RTX is a reg or parallel that is the current function's return\n    value.  */\n #define REG_FUNCTION_VALUE_P(RTX)\t\t\t\t\t\\\n-  (RTL_FLAG_CHECK2(\"REG_FUNCTION_VALUE_P\", (RTX), REG, PARALLEL)->return_val)\n+  (RTL_FLAG_CHECK2 (\"REG_FUNCTION_VALUE_P\", (RTX), REG, PARALLEL)->return_val)\n \n /* 1 if RTX is a reg that corresponds to a variable declared by the user.  */\n #define REG_USERVAR_P(RTX)\t\t\t\t\t\t\\\n-  (RTL_FLAG_CHECK1(\"REG_USERVAR_P\", (RTX), REG)->volatil)\n+  (RTL_FLAG_CHECK1 (\"REG_USERVAR_P\", (RTX), REG)->volatil)\n \n /* 1 if RTX is a reg that holds a pointer value.  */\n #define REG_POINTER(RTX)\t\t\t\t\t\t\\\n-  (RTL_FLAG_CHECK1(\"REG_POINTER\", (RTX), REG)->frame_related)\n+  (RTL_FLAG_CHECK1 (\"REG_POINTER\", (RTX), REG)->frame_related)\n \n /* 1 if RTX is a mem that holds a pointer value.  */\n #define MEM_POINTER(RTX)\t\t\t\t\t\t\\\n-  (RTL_FLAG_CHECK1(\"MEM_POINTER\", (RTX), MEM)->frame_related)\n+  (RTL_FLAG_CHECK1 (\"MEM_POINTER\", (RTX), MEM)->frame_related)\n \n /* 1 if the given register REG corresponds to a hard register.  */\n #define HARD_REGISTER_P(REG) (HARD_REGISTER_NUM_P (REGNO (REG)))\n@@ -1149,7 +1151,7 @@ rhs_regno (const_rtx x)\n #define HARD_REGISTER_NUM_P(REG_NO) ((REG_NO) < FIRST_PSEUDO_REGISTER)\n \n /* For a CONST_INT rtx, INTVAL extracts the integer.  */\n-#define INTVAL(RTX) XCWINT(RTX, 0, CONST_INT)\n+#define INTVAL(RTX) XCWINT (RTX, 0, CONST_INT)\n #define UINTVAL(RTX) ((unsigned HOST_WIDE_INT) INTVAL (RTX))\n \n /* For a CONST_DOUBLE:\n@@ -1165,9 +1167,9 @@ rhs_regno (const_rtx x)\n #define CONST_FIXED_VALUE(r) \\\n   ((const struct fixed_value *) XCNMPFV (r, CONST_FIXED, VOIDmode))\n #define CONST_FIXED_VALUE_HIGH(r) \\\n-  ((HOST_WIDE_INT) (CONST_FIXED_VALUE(r)->data.high))\n+  ((HOST_WIDE_INT) (CONST_FIXED_VALUE (r)->data.high))\n #define CONST_FIXED_VALUE_LOW(r) \\\n-  ((HOST_WIDE_INT) (CONST_FIXED_VALUE(r)->data.low))\n+  ((HOST_WIDE_INT) (CONST_FIXED_VALUE (r)->data.low))\n \n /* For a CONST_VECTOR, return element #n.  */\n #define CONST_VECTOR_ELT(RTX, N) XCVECEXP (RTX, 0, N, CONST_VECTOR)\n@@ -1387,11 +1389,12 @@ get_full_set_src_cost (rtx x, struct full_rtx_costs *c)\n    when assigning to SUBREG_REG.  */\n \n #define SUBREG_PROMOTED_VAR_P(RTX)\t\t\t\t\t\\\n-  (RTL_FLAG_CHECK1(\"SUBREG_PROMOTED\", (RTX), SUBREG)->in_struct)\n+  (RTL_FLAG_CHECK1 (\"SUBREG_PROMOTED\", (RTX), SUBREG)->in_struct)\n \n #define SUBREG_PROMOTED_UNSIGNED_SET(RTX, VAL)\t\t\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n-  rtx const _rtx = RTL_FLAG_CHECK1(\"SUBREG_PROMOTED_UNSIGNED_SET\", (RTX), SUBREG); \\\n+  rtx const _rtx = RTL_FLAG_CHECK1 (\"SUBREG_PROMOTED_UNSIGNED_SET\",\t\\\n+\t\t\t\t    (RTX), SUBREG);\t\t\t\\\n   if ((VAL) < 0)\t\t\t\t\t\t\t\\\n     _rtx->volatil = 1;\t\t\t\t\t\t\t\\\n   else {\t\t\t\t\t\t\t\t\\\n@@ -1409,13 +1412,13 @@ do {\t\t\t\t\t\t\t\t\t\\\n \temit special code (ptr_extend insns) on some architectures.  */\n \n #define SUBREG_PROMOTED_UNSIGNED_P(RTX)\t\\\n-  ((RTL_FLAG_CHECK1(\"SUBREG_PROMOTED_UNSIGNED_P\", (RTX), SUBREG)->volatil) \\\n+  ((RTL_FLAG_CHECK1 (\"SUBREG_PROMOTED_UNSIGNED_P\", (RTX), SUBREG)->volatil) \\\n    ? -1 : (int) (RTX)->unchanging)\n \n /* True if the subreg was generated by LRA for reload insns.  Such\n    subregs are valid only during LRA.  */\n #define LRA_SUBREG_P(RTX)\t\\\n-  (RTL_FLAG_CHECK1(\"LRA_SUBREG_P\", (RTX), SUBREG)->jump)\n+  (RTL_FLAG_CHECK1 (\"LRA_SUBREG_P\", (RTX), SUBREG)->jump)\n \n /* Access various components of an ASM_OPERANDS rtx.  */\n \n@@ -1440,22 +1443,22 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n /* 1 if RTX is a mem that is statically allocated in read-only memory.  */\n #define MEM_READONLY_P(RTX) \\\n-  (RTL_FLAG_CHECK1(\"MEM_READONLY_P\", (RTX), MEM)->unchanging)\n+  (RTL_FLAG_CHECK1 (\"MEM_READONLY_P\", (RTX), MEM)->unchanging)\n \n /* 1 if RTX is a mem and we should keep the alias set for this mem\n    unchanged when we access a component.  Set to 1, or example, when we\n    are already in a non-addressable component of an aggregate.  */\n #define MEM_KEEP_ALIAS_SET_P(RTX)\t\t\t\t\t\\\n-  (RTL_FLAG_CHECK1(\"MEM_KEEP_ALIAS_SET_P\", (RTX), MEM)->jump)\n+  (RTL_FLAG_CHECK1 (\"MEM_KEEP_ALIAS_SET_P\", (RTX), MEM)->jump)\n \n /* 1 if RTX is a mem or asm_operand for a volatile reference.  */\n #define MEM_VOLATILE_P(RTX)\t\t\t\t\t\t\\\n-  (RTL_FLAG_CHECK3(\"MEM_VOLATILE_P\", (RTX), MEM, ASM_OPERANDS,\t\t\\\n-\t\t   ASM_INPUT)->volatil)\n+  (RTL_FLAG_CHECK3 (\"MEM_VOLATILE_P\", (RTX), MEM, ASM_OPERANDS,\t\t\\\n+\t\t    ASM_INPUT)->volatil)\n \n /* 1 if RTX is a mem that cannot trap.  */\n #define MEM_NOTRAP_P(RTX) \\\n-  (RTL_FLAG_CHECK1(\"MEM_NOTRAP_P\", (RTX), MEM)->call)\n+  (RTL_FLAG_CHECK1 (\"MEM_NOTRAP_P\", (RTX), MEM)->call)\n \n /* The memory attribute block.  We provide access macros for each value\n    in the block and provide defaults if none specified.  */\n@@ -1521,25 +1524,24 @@ do {\t\t\t\t\t\t\t\t\t\\\n /* Likewise in an expr_list for a REG_LABEL_OPERAND or\n    REG_LABEL_TARGET note.  */\n #define LABEL_REF_NONLOCAL_P(RTX)\t\t\t\t\t\\\n-  (RTL_FLAG_CHECK1(\"LABEL_REF_NONLOCAL_P\", (RTX), LABEL_REF)->volatil)\n+  (RTL_FLAG_CHECK1 (\"LABEL_REF_NONLOCAL_P\", (RTX), LABEL_REF)->volatil)\n \n /* 1 if RTX is a code_label that should always be considered to be needed.  */\n #define LABEL_PRESERVE_P(RTX)\t\t\t\t\t\t\\\n-  (RTL_FLAG_CHECK2(\"LABEL_PRESERVE_P\", (RTX), CODE_LABEL, NOTE)->in_struct)\n+  (RTL_FLAG_CHECK2 (\"LABEL_PRESERVE_P\", (RTX), CODE_LABEL, NOTE)->in_struct)\n \n /* During sched, 1 if RTX is an insn that must be scheduled together\n    with the preceding insn.  */\n #define SCHED_GROUP_P(RTX)\t\t\t\t\t\t\\\n-  (RTL_FLAG_CHECK4(\"SCHED_GROUP_P\", (RTX), DEBUG_INSN, INSN,\t\t\\\n-\t\t   JUMP_INSN, CALL_INSN\t\t\t\t\t\\\n-\t\t   )->in_struct)\n+  (RTL_FLAG_CHECK4 (\"SCHED_GROUP_P\", (RTX), DEBUG_INSN, INSN,\t\t\\\n+\t\t    JUMP_INSN, CALL_INSN)->in_struct)\n \n /* For a SET rtx, SET_DEST is the place that is set\n    and SET_SRC is the value it is set to.  */\n-#define SET_DEST(RTX) XC2EXP(RTX, 0, SET, CLOBBER)\n-#define SET_SRC(RTX) XCEXP(RTX, 1, SET)\n+#define SET_DEST(RTX) XC2EXP (RTX, 0, SET, CLOBBER)\n+#define SET_SRC(RTX) XCEXP (RTX, 1, SET)\n #define SET_IS_RETURN_P(RTX)\t\t\t\t\t\t\\\n-  (RTL_FLAG_CHECK1(\"SET_IS_RETURN_P\", (RTX), SET)->jump)\n+  (RTL_FLAG_CHECK1 (\"SET_IS_RETURN_P\", (RTX), SET)->jump)\n \n /* For a TRAP_IF rtx, TRAP_CONDITION is an expression.  */\n #define TRAP_CONDITION(RTX) XCEXP (RTX, 0, TRAP_IF)\n@@ -1554,26 +1556,26 @@ do {\t\t\t\t\t\t\t\t\t\\\n /* 1 if RTX is a symbol_ref that addresses this function's rtl\n    constants pool.  */\n #define CONSTANT_POOL_ADDRESS_P(RTX)\t\t\t\t\t\\\n-  (RTL_FLAG_CHECK1(\"CONSTANT_POOL_ADDRESS_P\", (RTX), SYMBOL_REF)->unchanging)\n+  (RTL_FLAG_CHECK1 (\"CONSTANT_POOL_ADDRESS_P\", (RTX), SYMBOL_REF)->unchanging)\n \n /* 1 if RTX is a symbol_ref that addresses a value in the file's\n    tree constant pool.  This information is private to varasm.c.  */\n #define TREE_CONSTANT_POOL_ADDRESS_P(RTX)\t\t\t\t\\\n-  (RTL_FLAG_CHECK1(\"TREE_CONSTANT_POOL_ADDRESS_P\",\t\t\t\\\n-\t\t   (RTX), SYMBOL_REF)->frame_related)\n+  (RTL_FLAG_CHECK1 (\"TREE_CONSTANT_POOL_ADDRESS_P\",\t\t\t\\\n+\t\t    (RTX), SYMBOL_REF)->frame_related)\n \n /* Used if RTX is a symbol_ref, for machine-specific purposes.  */\n #define SYMBOL_REF_FLAG(RTX)\t\t\t\t\t\t\\\n-  (RTL_FLAG_CHECK1(\"SYMBOL_REF_FLAG\", (RTX), SYMBOL_REF)->volatil)\n+  (RTL_FLAG_CHECK1 (\"SYMBOL_REF_FLAG\", (RTX), SYMBOL_REF)->volatil)\n \n /* 1 if RTX is a symbol_ref that has been the library function in\n    emit_library_call.  */\n #define SYMBOL_REF_USED(RTX)\t\t\t\t\t\t\\\n-  (RTL_FLAG_CHECK1(\"SYMBOL_REF_USED\", (RTX), SYMBOL_REF)->used)\n+  (RTL_FLAG_CHECK1 (\"SYMBOL_REF_USED\", (RTX), SYMBOL_REF)->used)\n \n /* 1 if RTX is a symbol_ref for a weak symbol.  */\n #define SYMBOL_REF_WEAK(RTX)\t\t\t\t\t\t\\\n-  (RTL_FLAG_CHECK1(\"SYMBOL_REF_WEAK\", (RTX), SYMBOL_REF)->return_val)\n+  (RTL_FLAG_CHECK1 (\"SYMBOL_REF_WEAK\", (RTX), SYMBOL_REF)->return_val)\n \n /* A pointer attached to the SYMBOL_REF; either SYMBOL_REF_DECL or\n    SYMBOL_REF_CONSTANT.  */\n@@ -1656,7 +1658,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n /* True if RTX is flagged to be a scheduling barrier.  */\n #define PREFETCH_SCHEDULE_BARRIER_P(RTX)\t\t\t\t\t\\\n-  (RTL_FLAG_CHECK1(\"PREFETCH_SCHEDULE_BARRIER_P\", (RTX), PREFETCH)->volatil)\n+  (RTL_FLAG_CHECK1 (\"PREFETCH_SCHEDULE_BARRIER_P\", (RTX), PREFETCH)->volatil)\n \n /* Indicate whether the machine has any sort of auto increment addressing.\n    If not, we can avoid checking for REG_INC notes.  */\n@@ -2072,7 +2074,7 @@ extern bool insn_could_throw_p (const_rtx);\n extern bool insn_nothrow_p (const_rtx);\n extern bool can_nonlocal_goto (const_rtx);\n extern void copy_reg_eh_region_note_forward (rtx, rtx, rtx);\n-extern void copy_reg_eh_region_note_backward(rtx, rtx, rtx);\n+extern void copy_reg_eh_region_note_backward (rtx, rtx, rtx);\n extern int inequality_comparisons_p (const_rtx);\n extern rtx replace_rtx (rtx, rtx, rtx);\n extern int replace_label (rtx *, void *);"}, {"sha": "9769b69bdb51291727037406ba91fbb336a383a5", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -3713,7 +3713,7 @@ keep_with_call_p (const_rtx insn)\n \t  /* This CONST_CAST is okay because next_nonnote_insn just\n \t     returns its argument and we assign it to a const_rtx\n \t     variable.  */\n-\t  const_rtx i2 = next_nonnote_insn (CONST_CAST_RTX(insn));\n+\t  const_rtx i2 = next_nonnote_insn (CONST_CAST_RTX (insn));\n \t  if (i2 && keep_with_call_p (i2))\n \t    return true;\n \t}"}, {"sha": "ceadd09eddaf0401a9c062ca5fc4c8d0fd10808e", "filename": "gcc/sbitmap.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fsbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fsbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsbitmap.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -30,15 +30,15 @@ along with GCC; see the file COPYING3.  If not see\n \n #if GCC_VERSION >= 3400\n #  if SBITMAP_ELT_BITS == HOST_BITS_PER_LONG\n-#    define do_popcount(x) __builtin_popcountl(x)\n+#    define do_popcount(x) __builtin_popcountl (x)\n #  elif SBITMAP_ELT_BITS == HOST_BITS_PER_LONGLONG\n-#    define do_popcount(x) __builtin_popcountll(x)\n+#    define do_popcount(x) __builtin_popcountll (x)\n #  else\n #    error \"internal error: sbitmap.h and hwint.h are inconsistent\"\n #  endif\n #else\n static unsigned long sbitmap_elt_popcount (SBITMAP_ELT_TYPE);\n-#  define do_popcount(x) sbitmap_elt_popcount((x))\n+#  define do_popcount(x) sbitmap_elt_popcount (x)\n #endif\n \n typedef SBITMAP_ELT_TYPE *sbitmap_ptr;"}, {"sha": "bf9b10df3a99caf0c3133070f7bc591d66bf372d", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -3638,8 +3638,8 @@ const pass_data pass_data_sched =\n class pass_sched : public rtl_opt_pass\n {\n public:\n-  pass_sched(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_sched, ctxt)\n+  pass_sched (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_sched, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -3677,8 +3677,8 @@ const pass_data pass_data_sched2 =\n class pass_sched2 : public rtl_opt_pass\n {\n public:\n-  pass_sched2(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_sched2, ctxt)\n+  pass_sched2 (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_sched2, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "1eedde3f5205a0f4f971c29f6920d3a8611e2fad", "filename": "gcc/sdbout.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fsdbout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fsdbout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsdbout.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -155,7 +155,7 @@ static void sdbout_global_decl\t\t(tree);\n #endif\n \n #ifndef PUT_SDB_SCL\n-#define PUT_SDB_SCL(a) fprintf(asm_out_file, \"\\t.scl\\t%d%s\", (a), SDB_DELIM)\n+#define PUT_SDB_SCL(a) fprintf (asm_out_file, \"\\t.scl\\t%d%s\", (a), SDB_DELIM)\n #endif\n \n #ifndef PUT_SDB_INT_VAL\n@@ -182,35 +182,36 @@ do { fprintf (asm_out_file, \"\\t.def\\t\");\t\\\n #endif\n \n #ifndef PUT_SDB_PLAIN_DEF\n-#define PUT_SDB_PLAIN_DEF(a) fprintf(asm_out_file,\"\\t.def\\t.%s%s\",a, SDB_DELIM)\n+#define PUT_SDB_PLAIN_DEF(a) \\\n+  fprintf (asm_out_file, \"\\t.def\\t.%s%s\", a, SDB_DELIM)\n #endif\n \n #ifndef PUT_SDB_ENDEF\n-#define PUT_SDB_ENDEF fputs(\"\\t.endef\\n\", asm_out_file)\n+#define PUT_SDB_ENDEF fputs (\"\\t.endef\\n\", asm_out_file)\n #endif\n \n #ifndef PUT_SDB_TYPE\n-#define PUT_SDB_TYPE(a) fprintf(asm_out_file, \"\\t.type\\t0%o%s\", a, SDB_DELIM)\n+#define PUT_SDB_TYPE(a) fprintf (asm_out_file, \"\\t.type\\t0%o%s\", a, SDB_DELIM)\n #endif\n \n #ifndef PUT_SDB_SIZE\n #define PUT_SDB_SIZE(a) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    fprintf (asm_out_file, \"\\t.size\\t\" HOST_WIDE_INT_PRINT_DEC \"%s\",\t\\\n \t    (HOST_WIDE_INT) (a), SDB_DELIM);\t\t\t\t\\\n- } while(0)\n+ } while (0)\n #endif\n \n #ifndef PUT_SDB_START_DIM\n-#define PUT_SDB_START_DIM fprintf(asm_out_file, \"\\t.dim\\t\")\n+#define PUT_SDB_START_DIM fprintf (asm_out_file, \"\\t.dim\\t\")\n #endif\n \n #ifndef PUT_SDB_NEXT_DIM\n-#define PUT_SDB_NEXT_DIM(a) fprintf(asm_out_file, \"%d,\", a)\n+#define PUT_SDB_NEXT_DIM(a) fprintf (asm_out_file, \"%d,\", a)\n #endif\n \n #ifndef PUT_SDB_LAST_DIM\n-#define PUT_SDB_LAST_DIM(a) fprintf(asm_out_file, \"%d%s\", a, SDB_DELIM)\n+#define PUT_SDB_LAST_DIM(a) fprintf (asm_out_file, \"%d%s\", a, SDB_DELIM)\n #endif\n \n #ifndef PUT_SDB_TAG"}, {"sha": "4eb27c5da5dea4e90414af0d24cb2f3c4c9efdec", "filename": "gcc/sel-sched-ir.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fsel-sched-ir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fsel-sched-ir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -4881,7 +4881,7 @@ in_same_ebb_p (insn_t insn, insn_t succ)\n {\n   basic_block ptr = BLOCK_FOR_INSN (insn);\n \n-  for(;;)\n+  for (;;)\n     {\n       if (ptr == BLOCK_FOR_INSN (succ))\n         return true;"}, {"sha": "08fdc772292589dbe8ffa41b27f406df694f7ee3", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -509,12 +509,12 @@ typedef vec<vinsn_t> vinsn_vec_t;\n    can't be moved up due to bookkeeping created during code motion to another\n    fence.  See comment near the call to update_and_record_unavailable_insns\n    for the detailed explanations.  */\n-static vinsn_vec_t vec_bookkeeping_blocked_vinsns = vinsn_vec_t();\n+static vinsn_vec_t vec_bookkeeping_blocked_vinsns = vinsn_vec_t ();\n \n /* This vector has vinsns which are scheduled with renaming on the first fence\n    and then seen on the second.  For expressions with such vinsns, target\n    availability information may be wrong.  */\n-static vinsn_vec_t vec_target_unavailable_vinsns = vinsn_vec_t();\n+static vinsn_vec_t vec_target_unavailable_vinsns = vinsn_vec_t ();\n \n /* Vector to store temporary nops inserted in move_op to prevent removal\n    of empty bbs.  */\n@@ -809,7 +809,7 @@ count_occurrences_1 (rtx *cur_rtx, void *arg)\n       /* Bail out if mode is different or more than one register is used.  */\n       if (GET_MODE (*cur_rtx) != GET_MODE (p->x)\n           || (HARD_REGISTER_P (*cur_rtx)\n-\t      && hard_regno_nregs[REGNO(*cur_rtx)][GET_MODE (*cur_rtx)] > 1))\n+\t      && hard_regno_nregs[REGNO (*cur_rtx)][GET_MODE (*cur_rtx)] > 1))\n         {\n           p->n = 0;\n           return 1;"}, {"sha": "279c22bf72b1929c208332ecf2c813d96d40fef9", "filename": "gcc/sparseset.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fsparseset.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fsparseset.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsparseset.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -30,7 +30,7 @@ sparseset_alloc (SPARSESET_ELT_TYPE n_elms)\n   unsigned int n_bytes = sizeof (struct sparseset_def)\n \t\t\t + ((n_elms - 1) * 2 * sizeof (SPARSESET_ELT_TYPE));\n \n-  sparseset set = XNEWVAR(struct sparseset_def, n_bytes);\n+  sparseset set = XNEWVAR (struct sparseset_def, n_bytes);\n \n   /* Mark the sparseset as defined to silence some valgrind uninitialized\n      read errors when accessing set->sparse[n] when \"n\" is not, and never has"}, {"sha": "68ccd1619ed8ed5580c8fe0a665ea0665c188c70", "filename": "gcc/stack-ptr-mod.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fstack-ptr-mod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fstack-ptr-mod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstack-ptr-mod.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -110,8 +110,8 @@ const pass_data pass_data_stack_ptr_mod =\n class pass_stack_ptr_mod : public rtl_opt_pass\n {\n public:\n-  pass_stack_ptr_mod(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_stack_ptr_mod, ctxt)\n+  pass_stack_ptr_mod (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_stack_ptr_mod, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "62590ba352805b0be304a54a6d7feb5d89a241db", "filename": "gcc/statistics.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fstatistics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fstatistics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstatistics.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -76,7 +76,7 @@ stats_counter_hasher::equal (const value_type *c1, const compare_type *c2)\n inline void\n stats_counter_hasher::remove (value_type *v)\n {\n-  free (CONST_CAST(char *, v->id));\n+  free (CONST_CAST (char *, v->id));\n   free (v);\n }\n "}, {"sha": "2e17db1cfae5e8f590ba29195534ec1370d36235", "filename": "gcc/stmt.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -1641,11 +1641,11 @@ dump_case_nodes (FILE *f, struct case_node *root,\n \n   fputs (\";; \", f);\n   if (high == low)\n-    fprintf(f, \"%*s\" HOST_WIDE_INT_PRINT_DEC,\n-\t    indent_step * indent_level, \"\", low);\n+    fprintf (f, \"%*s\" HOST_WIDE_INT_PRINT_DEC,\n+\t     indent_step * indent_level, \"\", low);\n   else\n-    fprintf(f, \"%*s\" HOST_WIDE_INT_PRINT_DEC \" ... \" HOST_WIDE_INT_PRINT_DEC,\n-\t    indent_step * indent_level, \"\", low, high);\n+    fprintf (f, \"%*s\" HOST_WIDE_INT_PRINT_DEC \" ... \" HOST_WIDE_INT_PRINT_DEC,\n+\t     indent_step * indent_level, \"\", low, high);\n   fputs (\"\\n\", f);\n \n   dump_case_nodes (f, root->right, indent_step, indent_level);\n@@ -1802,7 +1802,7 @@ get_outgoing_edge_probs (basic_block bb)\n   int prob_sum = 0;\n   if (!bb)\n     return 0;\n-  FOR_EACH_EDGE(e, ei, bb->succs)\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n     prob_sum += e->probability;\n   return prob_sum;\n }\n@@ -1851,7 +1851,7 @@ emit_case_dispatch_table (tree index_expr, tree index_type,\n   rtx fallback_label = label_rtx (case_list->code_label);\n   rtx table_label = gen_label_rtx ();\n   bool has_gaps = false;\n-  edge default_edge = stmt_bb ? EDGE_SUCC(stmt_bb, 0) : NULL;\n+  edge default_edge = stmt_bb ? EDGE_SUCC (stmt_bb, 0) : NULL;\n   int default_prob = default_edge ? default_edge->probability : 0;\n   int base = get_outgoing_edge_probs (stmt_bb);\n   bool try_with_tablejump = false;\n@@ -1976,7 +1976,7 @@ reset_out_edges_aux (basic_block bb)\n {\n   edge e;\n   edge_iterator ei;\n-  FOR_EACH_EDGE(e, ei, bb->succs)\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n     e->aux = (void *)0;\n }\n \n@@ -2042,7 +2042,7 @@ expand_case (gimple stmt)\n \n   /* Find the default case target label.  */\n   default_label = label_rtx (CASE_LABEL (gimple_switch_default_label (stmt)));\n-  edge default_edge = EDGE_SUCC(bb, 0);\n+  edge default_edge = EDGE_SUCC (bb, 0);\n   int default_prob = default_edge->probability;\n \n   /* Get upper and lower bounds of case values.  */"}, {"sha": "02998365804c15d74ae2164db15d8222b38007db", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -1352,7 +1352,7 @@ place_field (record_layout_info rli, tree field)\n \n \t      /* Cause a new bitfield to be captured, either this time (if\n \t\t currently a bitfield) or next time we see one.  */\n-\t      if (!DECL_BIT_FIELD_TYPE(field)\n+\t      if (!DECL_BIT_FIELD_TYPE (field)\n \t\t  || integer_zerop (DECL_SIZE (field)))\n \t\trli->prev_field = NULL;\n \t    }"}, {"sha": "68f293c6252189e1474d8dc9bd19e2f8d55bf656", "filename": "gcc/store-motion.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fstore-motion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fstore-motion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstore-motion.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -271,7 +271,7 @@ store_ops_ok (const_rtx x, int *regs_set)\n   for (; x; x = XEXP (x, 1))\n     {\n       reg = XEXP (x, 0);\n-      if (regs_set[REGNO(reg)])\n+      if (regs_set[REGNO (reg)])\n \treturn false;\n     }\n \n@@ -1256,8 +1256,8 @@ const pass_data pass_data_rtl_store_motion =\n class pass_rtl_store_motion : public rtl_opt_pass\n {\n public:\n-  pass_rtl_store_motion(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_rtl_store_motion, ctxt)\n+  pass_rtl_store_motion (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_rtl_store_motion, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "d989cc904523f2e445c94bb67e52f021b7870070", "filename": "gcc/streamer-hooks.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fstreamer-hooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fstreamer-hooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstreamer-hooks.h?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -61,19 +61,19 @@ struct streamer_hooks {\n };\n \n #define stream_write_tree(OB, EXPR, REF_P) \\\n-    streamer_hooks.write_tree(OB, EXPR, REF_P, REF_P)\n+    streamer_hooks.write_tree (OB, EXPR, REF_P, REF_P)\n \n #define stream_write_tree_shallow_non_ref(OB, EXPR, REF_P) \\\n-    streamer_hooks.write_tree(OB, EXPR, REF_P, false)\n+    streamer_hooks.write_tree (OB, EXPR, REF_P, false)\n \n #define stream_read_tree(IB, DATA_IN) \\\n-    streamer_hooks.read_tree(IB, DATA_IN)\n+    streamer_hooks.read_tree (IB, DATA_IN)\n \n #define stream_input_location(BP, DATA_IN) \\\n-    streamer_hooks.input_location(BP, DATA_IN)\n+    streamer_hooks.input_location (BP, DATA_IN)\n \n #define stream_output_location(OB, BP, LOC) \\\n-    streamer_hooks.output_location(OB, BP, LOC)\n+    streamer_hooks.output_location (OB, BP, LOC)\n \n /* Streamer hooks.  */\n extern struct streamer_hooks streamer_hooks;"}, {"sha": "fab1c7bb32fea26098ffe9177a3ab1f40fb35cad", "filename": "gcc/system.h", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -27,7 +27,7 @@ along with GCC; see the file COPYING3.  If not see\n \n #ifndef va_copy\n # ifdef __va_copy\n-#   define va_copy(d,s)  __va_copy((d),(s))\n+#   define va_copy(d,s)  __va_copy (d, s)\n # else\n #   define va_copy(d,s)  ((d) = (s))\n # endif\n@@ -53,9 +53,9 @@ along with GCC; see the file COPYING3.  If not see\n #undef fopen \n #undef freopen \n \n-#define fopen(PATH,MODE) fopen_unlocked(PATH,MODE)\n-#define fdopen(FILDES,MODE) fdopen_unlocked(FILDES,MODE)\n-#define freopen(PATH,MODE,STREAM) freopen_unlocked(PATH,MODE,STREAM)\n+#define fopen(PATH, MODE) fopen_unlocked (PATH, MODE)\n+#define fdopen(FILDES, MODE) fdopen_unlocked (FILDES, MODE)\n+#define freopen(PATH, MODE, STREAM) freopen_unlocked (PATH, MODE, STREAM)\n \n /* The compiler is not a multi-threaded application and therefore we\n    do not have to use the locking functions.  In fact, using the locking\n@@ -294,7 +294,7 @@ extern int errno;\n /* The outer cast is needed to work around a bug in Cray C 5.0.3.0.\n    It is necessary at least when t == time_t.  */\n #define INTTYPE_MINIMUM(t) ((t) (INTTYPE_SIGNED (t) \\\n-                             ? ~ (t) 0 << (sizeof(t) * CHAR_BIT - 1) : (t) 0))\n+                             ? ~ (t) 0 << (sizeof (t) * CHAR_BIT - 1) : (t) 0))\n #define INTTYPE_MAXIMUM(t) ((t) (~ (t) 0 - INTTYPE_MINIMUM (t)))\n \n /* Use that infrastructure to provide a few constants.  */\n@@ -536,7 +536,7 @@ extern int snprintf (char *, size_t, const char *, ...);\n #endif\n \n #if defined (HAVE_DECL_VSNPRINTF) && !HAVE_DECL_VSNPRINTF\n-extern int vsnprintf(char *, size_t, const char *, va_list);\n+extern int vsnprintf (char *, size_t, const char *, va_list);\n #endif\n \n #ifdef __cplusplus\n@@ -611,11 +611,11 @@ extern int vsnprintf(char *, size_t, const char *, va_list);\n \n /* Some systems have mkdir that takes a single argument.  */\n #ifdef MKDIR_TAKES_ONE_ARG\n-# define mkdir(a,b) mkdir(a)\n+# define mkdir(a,b) mkdir (a)\n #endif\n \n #ifndef HAVE_KILL\n-# define kill(p,s) raise(s)\n+# define kill(p,s) raise (s)\n #endif\n \n /* Provide a way to print an address via printf.  */\n@@ -693,7 +693,7 @@ extern void fancy_abort (const char *, int, const char *) ATTRIBUTE_NORETURN;\n    ((void)(!(EXPR) ? fancy_abort (__FILE__, __LINE__, __FUNCTION__), 0 : 0))\n #elif (GCC_VERSION >= 4005)\n #define gcc_assert(EXPR) \t\t\t\t\t\t\\\n-  ((void)(__builtin_expect(!(EXPR), 0) ? __builtin_unreachable(), 0 : 0))\n+  ((void)(__builtin_expect (!(EXPR), 0) ? __builtin_unreachable (), 0 : 0))\n #else\n /* Include EXPR, so that unused variable warnings do not occur.  */\n #define gcc_assert(EXPR) ((void)(0 && (EXPR)))\n@@ -708,7 +708,7 @@ extern void fancy_abort (const char *, int, const char *) ATTRIBUTE_NORETURN;\n /* Use gcc_unreachable() to mark unreachable locations (like an\n    unreachable default case of a switch.  Do not use gcc_assert(0).  */\n #if (GCC_VERSION >= 4005) && !ENABLE_ASSERT_CHECKING\n-#define gcc_unreachable() __builtin_unreachable()\n+#define gcc_unreachable() __builtin_unreachable ()\n #else\n #define gcc_unreachable() (fancy_abort (__FILE__, __LINE__, __FUNCTION__))\n #endif\n@@ -1011,11 +1011,11 @@ helper_const_non_const_cast (const char *p)\n #define CONST_CAST2(TOTYPE,FROMTYPE,X) ((TOTYPE)(FROMTYPE)(X))\n #endif\n #endif\n-#define CONST_CAST(TYPE,X) CONST_CAST2(TYPE, const TYPE, (X))\n-#define CONST_CAST_TREE(X) CONST_CAST(union tree_node *, (X))\n-#define CONST_CAST_RTX(X) CONST_CAST(struct rtx_def *, (X))\n-#define CONST_CAST_BB(X) CONST_CAST(struct basic_block_def *, (X))\n-#define CONST_CAST_GIMPLE(X) CONST_CAST(union gimple_statement_d *, (X))\n+#define CONST_CAST(TYPE,X) CONST_CAST2 (TYPE, const TYPE, (X))\n+#define CONST_CAST_TREE(X) CONST_CAST (union tree_node *, (X))\n+#define CONST_CAST_RTX(X) CONST_CAST (struct rtx_def *, (X))\n+#define CONST_CAST_BB(X) CONST_CAST (struct basic_block_def *, (X))\n+#define CONST_CAST_GIMPLE(X) CONST_CAST (union gimple_statement_d *, (X))\n \n /* Activate certain diagnostics as warnings (not errors via the\n    -Werror flag).  */"}, {"sha": "602b2a42d28ac83f0000fabc44f0e2672d204b52", "filename": "gcc/target-hooks-macros.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftarget-hooks-macros.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftarget-hooks-macros.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-hooks-macros.h?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -37,7 +37,7 @@\n    HOOK_VECTOR_END: Close a struct declaration, providing a member declarator\n                     name for nested use.  */\n #ifndef HOOK_VECTOR_1\n-#define HOOK_VECTOR_1(NAME, FRAGMENT) HOOKSTRUCT(FRAGMENT)\n+#define HOOK_VECTOR_1(NAME, FRAGMENT) HOOKSTRUCT (FRAGMENT)\n #endif\n #define HOOK_VECTOR(INIT_NAME, SNAME) HOOK_VECTOR_1 (INIT_NAME, struct SNAME {)\n #define HOOK_VECTOR_END(DECL_NAME) HOOK_VECTOR_1(,} DECL_NAME ;)"}, {"sha": "ec73a6406d29a9f5ec1c681d9a31282c19c0db7f", "filename": "gcc/targhooks.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -93,7 +93,7 @@ void\n default_external_libcall (rtx fun ATTRIBUTE_UNUSED)\n {\n #ifdef ASM_OUTPUT_EXTERNAL_LIBCALL\n-  ASM_OUTPUT_EXTERNAL_LIBCALL(asm_out_file, fun);\n+  ASM_OUTPUT_EXTERNAL_LIBCALL (asm_out_file, fun);\n #endif\n }\n \n@@ -1427,7 +1427,7 @@ default_debug_unwind_info (void)\n    mode for registers used in apply_builtin_return and apply_builtin_arg.  */\n \n enum machine_mode\n-default_get_reg_raw_mode(int regno)\n+default_get_reg_raw_mode (int regno)\n {\n   return reg_raw_mode[regno];\n }"}, {"sha": "b3bd15503cded950aad5ab9a93bd0eaee527b60a", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -193,7 +193,7 @@ extern int default_label_align_max_skip (rtx);\n extern int default_jump_align_max_skip (rtx);\n extern section * default_function_section(tree decl, enum node_frequency freq,\n \t\t\t\t\t  bool startup, bool exit);\n-extern enum machine_mode default_get_reg_raw_mode(int);\n+extern enum machine_mode default_get_reg_raw_mode (int);\n \n extern void *default_get_pch_validity (size_t *);\n extern const char *default_pch_valid_p (const void *, size_t);"}, {"sha": "feba0510f619bc368c3df7c4c153bd9ce9f7d60b", "filename": "gcc/toplev.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -706,17 +706,19 @@ print_version (FILE *file, const char *indent)\n      two string formats, \"i.j.k\" and \"i.j\" when k is zero.  As of\n      gmp-4.3.0, GMP always uses the 3 number format.  */\n #define GCC_GMP_STRINGIFY_VERSION3(X) #X\n-#define GCC_GMP_STRINGIFY_VERSION2(X) GCC_GMP_STRINGIFY_VERSION3(X)\n+#define GCC_GMP_STRINGIFY_VERSION2(X) GCC_GMP_STRINGIFY_VERSION3 (X)\n #define GCC_GMP_VERSION_NUM(X,Y,Z) (((X) << 16L) | ((Y) << 8) | (Z))\n #define GCC_GMP_VERSION \\\n   GCC_GMP_VERSION_NUM(__GNU_MP_VERSION, __GNU_MP_VERSION_MINOR, __GNU_MP_VERSION_PATCHLEVEL)\n #if GCC_GMP_VERSION < GCC_GMP_VERSION_NUM(4,3,0) && __GNU_MP_VERSION_PATCHLEVEL == 0\n-#define GCC_GMP_STRINGIFY_VERSION GCC_GMP_STRINGIFY_VERSION2(__GNU_MP_VERSION) \".\" \\\n-  GCC_GMP_STRINGIFY_VERSION2(__GNU_MP_VERSION_MINOR)\n+#define GCC_GMP_STRINGIFY_VERSION \\\n+  GCC_GMP_STRINGIFY_VERSION2 (__GNU_MP_VERSION) \".\" \\\n+  GCC_GMP_STRINGIFY_VERSION2 (__GNU_MP_VERSION_MINOR)\n #else\n-#define GCC_GMP_STRINGIFY_VERSION GCC_GMP_STRINGIFY_VERSION2(__GNU_MP_VERSION) \".\" \\\n-  GCC_GMP_STRINGIFY_VERSION2(__GNU_MP_VERSION_MINOR) \".\" \\\n-  GCC_GMP_STRINGIFY_VERSION2(__GNU_MP_VERSION_PATCHLEVEL)\n+#define GCC_GMP_STRINGIFY_VERSION \\\n+  GCC_GMP_STRINGIFY_VERSION2 (__GNU_MP_VERSION) \".\" \\\n+  GCC_GMP_STRINGIFY_VERSION2 (__GNU_MP_VERSION_MINOR) \".\" \\\n+  GCC_GMP_STRINGIFY_VERSION2 (__GNU_MP_VERSION_PATCHLEVEL)\n #endif\n   fprintf (file,\n \t   file == stderr ? _(fmt2) : fmt2,\n@@ -1170,11 +1172,11 @@ general_init (const char *argv0)\n \n   /* This must be done after global_init_params but before argument\n      processing.  */\n-  init_ggc_heuristics();\n+  init_ggc_heuristics ();\n \n   /* Create the singleton holder for global state.\n      Doing so also creates the pass manager and with it the passes.  */\n-  g = new gcc::context();\n+  g = new gcc::context ();\n \n   statistics_early_init ();\n   finish_params ();"}, {"sha": "57055662ea54730b218e73e996f39985445c4830", "filename": "gcc/tracer.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftracer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftracer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftracer.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -417,8 +417,8 @@ const pass_data pass_data_tracer =\n class pass_tracer : public gimple_opt_pass\n {\n public:\n-  pass_tracer(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_tracer, ctxt)\n+  pass_tracer (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_tracer, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "82f3ee08a39bd140201c1afe4f7f214b33cc4f6c", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -821,8 +821,8 @@ const pass_data pass_data_diagnose_tm_blocks =\n class pass_diagnose_tm_blocks : public gimple_opt_pass\n {\n public:\n-  pass_diagnose_tm_blocks(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_diagnose_tm_blocks, ctxt)\n+  pass_diagnose_tm_blocks (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_diagnose_tm_blocks, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -1631,7 +1631,7 @@ lower_transaction (gimple_stmt_iterator *gsi, struct walk_stmt_info *wi)\n   /* If the transaction calls abort or if this is an outer transaction,\n      add an \"over\" label afterwards.  */\n   if ((this_state & (GTMA_HAVE_ABORT))\n-      || (gimple_transaction_subcode(stmt) & GTMA_IS_OUTER))\n+      || (gimple_transaction_subcode (stmt) & GTMA_IS_OUTER))\n     {\n       tree label = create_artificial_label (UNKNOWN_LOCATION);\n       gimple_transaction_set_label (stmt, label);\n@@ -1744,8 +1744,8 @@ const pass_data pass_data_lower_tm =\n class pass_lower_tm : public gimple_opt_pass\n {\n public:\n-  pass_lower_tm(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_lower_tm, ctxt)\n+  pass_lower_tm (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_lower_tm, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -2024,8 +2024,8 @@ const pass_data pass_data_tm_init =\n class pass_tm_init : public gimple_opt_pass\n {\n public:\n-  pass_tm_init(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_tm_init, ctxt)\n+  pass_tm_init (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_tm_init, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -2753,8 +2753,8 @@ expand_transaction (struct tm_region *region, void *data ATTRIBUTE_UNUSED)\n       ei->probability = PROB_ALWAYS;\n       et->probability = PROB_LIKELY;\n       ef->probability = PROB_UNLIKELY;\n-      et->count = apply_probability(test_bb->count, et->probability);\n-      ef->count = apply_probability(test_bb->count, ef->probability);\n+      et->count = apply_probability (test_bb->count, et->probability);\n+      ef->count = apply_probability (test_bb->count, ef->probability);\n \n       code_bb->count = et->count;\n       code_bb->frequency = EDGE_FREQUENCY (et);\n@@ -2793,14 +2793,14 @@ expand_transaction (struct tm_region *region, void *data ATTRIBUTE_UNUSED)\n       fallthru_edge->flags = EDGE_FALSE_VALUE;\n       fallthru_edge->probability = PROB_VERY_LIKELY;\n       fallthru_edge->count\n-\t= apply_probability(test_bb->count, fallthru_edge->probability);\n+\t= apply_probability (test_bb->count, fallthru_edge->probability);\n \n       // Abort/over edge.\n       redirect_edge_pred (abort_edge, test_bb);\n       abort_edge->flags = EDGE_TRUE_VALUE;\n       abort_edge->probability = PROB_VERY_UNLIKELY;\n       abort_edge->count\n-\t= apply_probability(test_bb->count, abort_edge->probability);\n+\t= apply_probability (test_bb->count, abort_edge->probability);\n \n       transaction_bb = test_bb;\n     }\n@@ -2842,13 +2842,13 @@ expand_transaction (struct tm_region *region, void *data ATTRIBUTE_UNUSED)\n       inst_edge->flags = EDGE_FALSE_VALUE;\n       inst_edge->probability = REG_BR_PROB_BASE / 2;\n       inst_edge->count\n-\t= apply_probability(test_bb->count, inst_edge->probability);\n+\t= apply_probability (test_bb->count, inst_edge->probability);\n \n       redirect_edge_pred (uninst_edge, test_bb);\n       uninst_edge->flags = EDGE_TRUE_VALUE;\n       uninst_edge->probability = REG_BR_PROB_BASE / 2;\n       uninst_edge->count\n-\t= apply_probability(test_bb->count, uninst_edge->probability);\n+\t= apply_probability (test_bb->count, uninst_edge->probability);\n     }\n \n   // If we have no previous special cases, and we have PHIs at the beginning\n@@ -3000,8 +3000,8 @@ const pass_data pass_data_tm_mark =\n class pass_tm_mark : public gimple_opt_pass\n {\n public:\n-  pass_tm_mark(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_tm_mark, ctxt)\n+  pass_tm_mark (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_tm_mark, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -3183,8 +3183,8 @@ const pass_data pass_data_tm_edges =\n class pass_tm_edges : public gimple_opt_pass\n {\n public:\n-  pass_tm_edges(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_tm_edges, ctxt)\n+  pass_tm_edges (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_tm_edges, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -3923,8 +3923,8 @@ const pass_data pass_data_tm_memopt =\n class pass_tm_memopt : public gimple_opt_pass\n {\n public:\n-  pass_tm_memopt(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_tm_memopt, ctxt)\n+  pass_tm_memopt (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_tm_memopt, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -4287,7 +4287,7 @@ ipa_tm_scan_irr_block (basic_block bb)\n \t\tif (find_tm_replacement_function (fn))\n \t\t  break;\n \n-\t\tnode = cgraph_get_node(fn);\n+\t\tnode = cgraph_get_node (fn);\n \t\td = get_cg_data (&node, true);\n \n \t\t/* Return true if irrevocable, but above all, believe\n@@ -4991,7 +4991,7 @@ ipa_tm_insert_gettmclone_call (struct cgraph_node *node,\n \n   cgraph_create_edge (node, cgraph_get_create_node (gettm_fn), g, 0,\n \t\t      compute_call_stmt_bb_frequency (node->symbol.decl,\n-\t\t\t\t\t\t      gimple_bb(g)));\n+\t\t\t\t\t\t      gimple_bb (g)));\n \n   /* Cast return value from tm_gettmclone* into appropriate function\n      pointer.  */\n@@ -5272,9 +5272,9 @@ ipa_tm_transform_clone (struct cgraph_node *node)\n static unsigned int\n ipa_tm_execute (void)\n {\n-  cgraph_node_queue tm_callees = cgraph_node_queue();\n+  cgraph_node_queue tm_callees = cgraph_node_queue ();\n   /* List of functions that will go irrevocable.  */\n-  cgraph_node_queue irr_worklist = cgraph_node_queue();\n+  cgraph_node_queue irr_worklist = cgraph_node_queue ();\n \n   struct cgraph_node *node;\n   struct tm_ipa_cg_data *d;\n@@ -5558,8 +5558,8 @@ const pass_data pass_data_ipa_tm =\n class pass_ipa_tm : public simple_ipa_opt_pass\n {\n public:\n-  pass_ipa_tm(gcc::context *ctxt)\n-    : simple_ipa_opt_pass(pass_data_ipa_tm, ctxt)\n+  pass_ipa_tm (gcc::context *ctxt)\n+    : simple_ipa_opt_pass (pass_data_ipa_tm, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "dad06a5175acc93eff9135f633d252c8b486edab", "filename": "gcc/tree-browser.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-browser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-browser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-browser.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -46,7 +46,7 @@ struct tb_command {\n   TB_CODE comm_code;\n };\n \n-#define DEFTBCODE(code, str, help) { help, str, sizeof(str) - 1, code },\n+#define DEFTBCODE(code, str, help) { help, str, sizeof (str) - 1, code },\n static const struct tb_command tb_commands[] =\n {\n #include \"tree-browser.def\""}, {"sha": "c38f694a5db09df1a5e938b2c3a172feb1b9d86f", "filename": "gcc/tree-call-cdce.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-call-cdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-call-cdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-call-cdce.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -946,8 +946,8 @@ const pass_data pass_data_call_cdce =\n class pass_call_cdce : public gimple_opt_pass\n {\n public:\n-  pass_call_cdce(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_call_cdce, ctxt)\n+  pass_call_cdce (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_call_cdce, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "be6618183406d4585cfb338eb982964d6ab74f9e", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -273,8 +273,8 @@ const pass_data pass_data_build_cfg =\n class pass_build_cfg : public gimple_opt_pass\n {\n public:\n-  pass_build_cfg(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_build_cfg, ctxt)\n+  pass_build_cfg (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_build_cfg, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -3360,7 +3360,7 @@ verify_gimple_assign_unary (gimple stmt)\n       {\n \tif ((!INTEGRAL_TYPE_P (rhs1_type) || !SCALAR_FLOAT_TYPE_P (lhs_type))\n \t    && (!VECTOR_INTEGER_TYPE_P (rhs1_type)\n-\t        || !VECTOR_FLOAT_TYPE_P(lhs_type)))\n+\t        || !VECTOR_FLOAT_TYPE_P (lhs_type)))\n \t  {\n \t    error (\"invalid types in conversion to floating point\");\n \t    debug_generic_expr (lhs_type);\n@@ -3375,7 +3375,7 @@ verify_gimple_assign_unary (gimple stmt)\n       {\n         if ((!INTEGRAL_TYPE_P (lhs_type) || !SCALAR_FLOAT_TYPE_P (rhs1_type))\n             && (!VECTOR_INTEGER_TYPE_P (lhs_type)\n-                || !VECTOR_FLOAT_TYPE_P(rhs1_type)))\n+                || !VECTOR_FLOAT_TYPE_P (rhs1_type)))\n \t  {\n \t    error (\"invalid types in conversion to integer\");\n \t    debug_generic_expr (lhs_type);\n@@ -7957,8 +7957,8 @@ const pass_data pass_data_split_crit_edges =\n class pass_split_crit_edges : public gimple_opt_pass\n {\n public:\n-  pass_split_crit_edges(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_split_crit_edges, ctxt)\n+  pass_split_crit_edges (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_split_crit_edges, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -8129,8 +8129,8 @@ const pass_data pass_data_warn_function_return =\n class pass_warn_function_return : public gimple_opt_pass\n {\n public:\n-  pass_warn_function_return(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_warn_function_return, ctxt)\n+  pass_warn_function_return (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_warn_function_return, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -8183,8 +8183,8 @@ const pass_data pass_data_warn_function_noreturn =\n class pass_warn_function_noreturn : public gimple_opt_pass\n {\n public:\n-  pass_warn_function_noreturn(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_warn_function_noreturn, ctxt)\n+  pass_warn_function_noreturn (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_warn_function_noreturn, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -8300,8 +8300,8 @@ const pass_data pass_data_warn_unused_result =\n class pass_warn_unused_result : public gimple_opt_pass\n {\n public:\n-  pass_warn_unused_result(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_warn_unused_result, ctxt)\n+  pass_warn_unused_result (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_warn_unused_result, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "37d6d03822b95f5879b1bbcc4a4a69bb7ec67503", "filename": "gcc/tree-cfgcleanup.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-cfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-cfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfgcleanup.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -1009,8 +1009,8 @@ const pass_data pass_data_merge_phi =\n class pass_merge_phi : public gimple_opt_pass\n {\n public:\n-  pass_merge_phi(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_merge_phi, ctxt)\n+  pass_merge_phi (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_merge_phi, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "0f26ab68de937fb7b07c862207ecad2525e3d6e0", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -1657,8 +1657,8 @@ const pass_data pass_data_lower_complex =\n class pass_lower_complex : public gimple_opt_pass\n {\n public:\n-  pass_lower_complex(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_lower_complex, ctxt)\n+  pass_lower_complex (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_lower_complex, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -1704,8 +1704,8 @@ const pass_data pass_data_lower_complex_O0 =\n class pass_lower_complex_O0 : public gimple_opt_pass\n {\n public:\n-  pass_lower_complex_O0(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_lower_complex_O0, ctxt)\n+  pass_lower_complex_O0 (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_lower_complex_O0, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "530f00d82d061b05694d058a750fa8ebaf61ff7e", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -1136,13 +1136,13 @@ common_affine_function (conflict_function *cf)\n   affine_fn comm;\n \n   if (!CF_NONTRIVIAL_P (cf))\n-    return affine_fn();\n+    return affine_fn ();\n \n   comm = cf->fns[0];\n \n   for (i = 1; i < cf->n; i++)\n     if (!affine_function_equal_p (comm, cf->fns[i]))\n-      return affine_fn();\n+      return affine_fn ();\n \n   return comm;\n }\n@@ -1637,12 +1637,12 @@ conflict_fn (unsigned n, ...)\n   va_list ap;\n \n   gcc_assert (0 < n && n <= MAX_DIM);\n-  va_start(ap, n);\n+  va_start (ap, n);\n \n   ret->n = n;\n   for (i = 0; i < n; i++)\n     ret->fns[i] = va_arg (ap, affine_fn);\n-  va_end(ap);\n+  va_end (ap);\n \n   return ret;\n }"}, {"sha": "14a5a21af83cbd2c169a363c4ff63ac4850d4152", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -144,7 +144,7 @@ struct access_matrix\n #define AM_NB_INDUCTION_VARS(M) (M)->nb_induction_vars\n #define AM_PARAMETERS(M) (M)->parameters\n #define AM_MATRIX(M) (M)->matrix\n-#define AM_NB_PARAMETERS(M) (AM_PARAMETERS(M)).length ()\n+#define AM_NB_PARAMETERS(M) (AM_PARAMETERS (M)).length ()\n #define AM_CONST_COLUMN_INDEX(M) (AM_NB_INDUCTION_VARS (M) + AM_NB_PARAMETERS (M))\n #define AM_NB_COLUMNS(M) (AM_NB_INDUCTION_VARS (M) + AM_NB_PARAMETERS (M) + 1)\n #define AM_GET_SUBSCRIPT_ACCESS_VECTOR(M, I) AM_MATRIX (M)[I]\n@@ -162,7 +162,7 @@ am_vector_index_for_loop (struct access_matrix *access_matrix, int loop_num)\n     if (l->num == loop_num)\n       return i;\n \n-  gcc_unreachable();\n+  gcc_unreachable ();\n }\n \n struct data_reference"}, {"sha": "e8462cff4a4dd2d3f546a5119eeb2353c1e06745", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -1737,7 +1737,7 @@ lower_try_finally (struct leh_state *state, gimple tp)\n \t{\n \t  gimple_seq new_eh_seq = eh_seq;\n \t  eh_seq = old_eh_seq;\n-\t  gimple_seq_add_seq(&eh_seq, new_eh_seq);\n+\t  gimple_seq_add_seq (&eh_seq, new_eh_seq);\n \t}\n     }\n \n@@ -2177,8 +2177,8 @@ const pass_data pass_data_lower_eh =\n class pass_lower_eh : public gimple_opt_pass\n {\n public:\n-  pass_lower_eh(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_lower_eh, ctxt)\n+  pass_lower_eh (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_lower_eh, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -3054,8 +3054,8 @@ const pass_data pass_data_refactor_eh =\n class pass_refactor_eh : public gimple_opt_pass\n {\n public:\n-  pass_refactor_eh(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_refactor_eh, ctxt)\n+  pass_refactor_eh (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_refactor_eh, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -3281,8 +3281,8 @@ const pass_data pass_data_lower_resx =\n class pass_lower_resx : public gimple_opt_pass\n {\n public:\n-  pass_lower_resx(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_lower_resx, ctxt)\n+  pass_lower_resx (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_lower_resx, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -3692,8 +3692,8 @@ const pass_data pass_data_lower_eh_dispatch =\n class pass_lower_eh_dispatch : public gimple_opt_pass\n {\n public:\n-  pass_lower_eh_dispatch(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_lower_eh_dispatch, ctxt)\n+  pass_lower_eh_dispatch (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_lower_eh_dispatch, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -4536,8 +4536,8 @@ const pass_data pass_data_cleanup_eh =\n class pass_cleanup_eh : public gimple_opt_pass\n {\n public:\n-  pass_cleanup_eh(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_cleanup_eh, ctxt)\n+  pass_cleanup_eh (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_cleanup_eh, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "7359295391282d2dadbc0f6d30739f83d4f02ee1", "filename": "gcc/tree-emutls.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-emutls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-emutls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-emutls.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -606,7 +606,7 @@ static inline void\n clear_access_vars (void)\n {\n   memset (access_vars.address (), 0,\n-          access_vars.length () * sizeof(tree));\n+          access_vars.length () * sizeof (tree));\n }\n \n /* Lower the entire function NODE.  */\n@@ -831,8 +831,8 @@ const pass_data pass_data_ipa_lower_emutls =\n class pass_ipa_lower_emutls : public simple_ipa_opt_pass\n {\n public:\n-  pass_ipa_lower_emutls(gcc::context *ctxt)\n-    : simple_ipa_opt_pass(pass_data_ipa_lower_emutls, ctxt)\n+  pass_ipa_lower_emutls (gcc::context *ctxt)\n+    : simple_ipa_opt_pass (pass_data_ipa_lower_emutls, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "3f3c3be3830db7082edf64eb12c612b0d8e42ef8", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -569,8 +569,8 @@ extern void threadedge_initialize_values (void);\n extern void threadedge_finalize_values (void);\n extern vec<tree> ssa_name_values;\n #define SSA_NAME_VALUE(x) \\\n-    (SSA_NAME_VERSION(x) < ssa_name_values.length () \\\n-     ? ssa_name_values[SSA_NAME_VERSION(x)] \\\n+    (SSA_NAME_VERSION (x) < ssa_name_values.length () \\\n+     ? ssa_name_values[SSA_NAME_VERSION (x)] \\\n      : NULL_TREE)\n extern void set_ssa_name_value (tree, tree);\n extern bool potentially_threadable_block (basic_block);"}, {"sha": "b487381e4be99d5821f10b259785ff05f879a310", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -1842,8 +1842,8 @@ const pass_data pass_data_if_conversion =\n class pass_if_conversion : public gimple_opt_pass\n {\n public:\n-  pass_if_conversion(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_if_conversion, ctxt)\n+  pass_if_conversion (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_if_conversion, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "2fe710e1bfba5a8684139ce45fca61a4016af942", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -2402,8 +2402,8 @@ const pass_data pass_data_build_ssa =\n class pass_build_ssa : public gimple_opt_pass\n {\n public:\n-  pass_build_ssa(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_build_ssa, ctxt)\n+  pass_build_ssa (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_build_ssa, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "53347b54dc653873b25b0bc89953ea9d36cd97d2", "filename": "gcc/tree-iterator.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-iterator.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-iterator.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-iterator.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -39,7 +39,7 @@ alloc_stmt_list (void)\n   if (!vec_safe_is_empty (stmt_list_cache))\n     {\n       list = stmt_list_cache->pop ();\n-      memset (list, 0, sizeof(struct tree_base));\n+      memset (list, 0, sizeof (struct tree_base));\n       TREE_SET_CODE (list, STATEMENT_LIST);\n     }\n   else"}, {"sha": "b7cafeaa62a9894fcebd821f557a74b2f9fcbcff", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -240,7 +240,7 @@ dot_rdg (struct graph *rdg)\n {\n   /* When debugging, you may want to enable the following code.  */\n #if 1\n-  FILE *file = popen(\"dot -Tx11\", \"w\");\n+  FILE *file = popen (\"dot -Tx11\", \"w\");\n   if (!file)\n     return;\n   dot_rdg_1 (file, rdg);\n@@ -1784,8 +1784,8 @@ const pass_data pass_data_loop_distribution =\n class pass_loop_distribution : public gimple_opt_pass\n {\n public:\n-  pass_loop_distribution(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_loop_distribution, ctxt)\n+  pass_loop_distribution (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_loop_distribution, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "9616762f24ed051518931d70e884504674d3158a", "filename": "gcc/tree-mudflap.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-mudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-mudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-mudflap.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -1390,8 +1390,8 @@ const pass_data pass_data_mudflap_1 =\n class pass_mudflap_1 : public gimple_opt_pass\n {\n public:\n-  pass_mudflap_1(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_mudflap_1, ctxt)\n+  pass_mudflap_1 (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_mudflap_1, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -1429,8 +1429,8 @@ const pass_data pass_data_mudflap_2 =\n class pass_mudflap_2 : public gimple_opt_pass\n {\n public:\n-  pass_mudflap_2(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_mudflap_2, ctxt)\n+  pass_mudflap_2 (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_mudflap_2, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "c6703b78acfcf6016e724ad5026fb0c8a544e297", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -2304,7 +2304,7 @@ remap_vla_decls (tree block, struct nesting_info *root)\n static bool\n fold_mem_refs (const void *e, void *data ATTRIBUTE_UNUSED)\n {\n-  tree *ref_p = CONST_CAST2(tree *, const tree *, (const tree *)e);\n+  tree *ref_p = CONST_CAST2 (tree *, const tree *, (const tree *)e);\n   *ref_p = fold (*ref_p);\n   return true;\n }"}, {"sha": "fe9ea6058bd1bb16767c56b13b91de523492cd4a", "filename": "gcc/tree-nomudflap.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-nomudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-nomudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nomudflap.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -105,8 +105,8 @@ const pass_data pass_data_mudflap_1 =\n class pass_mudflap_1 : public gimple_opt_pass\n {\n public:\n-  pass_mudflap_1(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_mudflap_1, ctxt)\n+  pass_mudflap_1 (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_mudflap_1, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -142,8 +142,8 @@ const pass_data pass_data_mudflap_2 =\n class pass_mudflap_2 : public gimple_opt_pass\n {\n public:\n-  pass_mudflap_2(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_mudflap_2, ctxt)\n+  pass_mudflap_2 (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_mudflap_2, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "1fec697589caed0bc54d4fccad77c5fbc83c391e", "filename": "gcc/tree-nrv.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-nrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-nrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nrv.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -289,8 +289,8 @@ const pass_data pass_data_nrv =\n class pass_nrv : public gimple_opt_pass\n {\n public:\n-  pass_nrv(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_nrv, ctxt)\n+  pass_nrv (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_nrv, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -393,8 +393,8 @@ const pass_data pass_data_return_slot =\n class pass_return_slot : public gimple_opt_pass\n {\n public:\n-  pass_return_slot(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_return_slot, ctxt)\n+  pass_return_slot (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_return_slot, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "9721457262b428ddab54d4d28feabd6ad81d559a", "filename": "gcc/tree-object-size.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-object-size.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-object-size.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-object-size.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -392,7 +392,8 @@ alloc_object_size (const_gimple call, int object_size_type)\n   if (!callee)\n     return unknown[object_size_type];\n \n-  alloc_size = lookup_attribute (\"alloc_size\", TYPE_ATTRIBUTES (TREE_TYPE(callee)));\n+  alloc_size = lookup_attribute (\"alloc_size\",\n+\t\t\t\t TYPE_ATTRIBUTES (TREE_TYPE (callee)));\n   if (alloc_size && TREE_VALUE (alloc_size))\n     {\n       tree p = TREE_VALUE (alloc_size);\n@@ -1282,8 +1283,8 @@ const pass_data pass_data_object_sizes =\n class pass_object_sizes : public gimple_opt_pass\n {\n public:\n-  pass_object_sizes(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_object_sizes, ctxt)\n+  pass_object_sizes (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_object_sizes, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "6663146488575309f743dfa77a7ee35b092fc56d", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -108,8 +108,8 @@ const pass_data pass_data_cleanup_cfg_post_optimizing =\n class pass_cleanup_cfg_post_optimizing : public gimple_opt_pass\n {\n public:\n-  pass_cleanup_cfg_post_optimizing(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_cleanup_cfg_post_optimizing, ctxt)\n+  pass_cleanup_cfg_post_optimizing (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_cleanup_cfg_post_optimizing, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -250,8 +250,8 @@ const pass_data pass_data_fixup_cfg =\n class pass_fixup_cfg : public gimple_opt_pass\n {\n public:\n-  pass_fixup_cfg(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_fixup_cfg, ctxt)\n+  pass_fixup_cfg (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_fixup_cfg, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "3400329b3c1821a793abf1049ca3f18ddfc266dd", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 27, "deletions": 28, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -102,7 +102,7 @@ class opt_pass : public pass_data\n   virtual unsigned int execute ();\n \n protected:\n-  opt_pass(const pass_data&, gcc::context *);\n+  opt_pass (const pass_data&, gcc::context *);\n \n public:\n   /* A list of sub-passes to run, dependent on gate predicate.  */\n@@ -122,8 +122,8 @@ class opt_pass : public pass_data\n class gimple_opt_pass : public opt_pass\n {\n protected:\n-  gimple_opt_pass(const pass_data& data, gcc::context *ctxt)\n-    : opt_pass(data, ctxt)\n+  gimple_opt_pass (const pass_data& data, gcc::context *ctxt)\n+    : opt_pass (data, ctxt)\n   {\n   }\n };\n@@ -132,8 +132,8 @@ class gimple_opt_pass : public opt_pass\n class rtl_opt_pass : public opt_pass\n {\n protected:\n-  rtl_opt_pass(const pass_data& data, gcc::context *ctxt)\n-    : opt_pass(data, ctxt)\n+  rtl_opt_pass (const pass_data& data, gcc::context *ctxt)\n+    : opt_pass (data, ctxt)\n   {\n   }\n };\n@@ -174,27 +174,26 @@ class ipa_opt_pass_d : public opt_pass\n   void (*variable_transform) (struct varpool_node *);\n \n protected:\n-  ipa_opt_pass_d(const pass_data& data, gcc::context *ctxt,\n-                 void (*generate_summary) (void),\n-                 void (*write_summary) (void),\n-                 void (*read_summary) (void),\n-                 void (*write_optimization_summary) (void),\n-                 void (*read_optimization_summary) (void),\n-                 void (*stmt_fixup) (struct cgraph_node *, gimple *),\n-                 unsigned int function_transform_todo_flags_start,\n-                 unsigned int (*function_transform) (struct cgraph_node *),\n-                 void (*variable_transform) (struct varpool_node *))\n-    : opt_pass(data, ctxt),\n-\t       generate_summary(generate_summary),\n-\t       write_summary(write_summary),\n-\t       read_summary(read_summary),\n-\t       write_optimization_summary(write_optimization_summary),\n-\t       read_optimization_summary(read_optimization_summary),\n-\t       stmt_fixup(stmt_fixup),\n-\t       function_transform_todo_flags_start(\n-\t         function_transform_todo_flags_start),\n-\t       function_transform(function_transform),\n-\t       variable_transform(variable_transform)\n+  ipa_opt_pass_d (const pass_data& data, gcc::context *ctxt,\n+\t\t  void (*generate_summary) (void),\n+\t\t  void (*write_summary) (void),\n+\t\t  void (*read_summary) (void),\n+\t\t  void (*write_optimization_summary) (void),\n+\t\t  void (*read_optimization_summary) (void),\n+\t\t  void (*stmt_fixup) (struct cgraph_node *, gimple *),\n+\t\t  unsigned int function_transform_todo_flags_start,\n+\t\t  unsigned int (*function_transform) (struct cgraph_node *),\n+\t\t  void (*variable_transform) (struct varpool_node *))\n+    : opt_pass (data, ctxt),\n+      generate_summary (generate_summary),\n+      write_summary (write_summary),\n+      read_summary (read_summary),\n+      write_optimization_summary (write_optimization_summary),\n+      read_optimization_summary (read_optimization_summary),\n+      stmt_fixup (stmt_fixup),\n+      function_transform_todo_flags_start (function_transform_todo_flags_start),\n+      function_transform (function_transform),\n+      variable_transform (variable_transform)\n   {\n   }\n };\n@@ -204,8 +203,8 @@ class ipa_opt_pass_d : public opt_pass\n class simple_ipa_opt_pass : public opt_pass\n {\n protected:\n-  simple_ipa_opt_pass(const pass_data& data, gcc::context *ctxt)\n-    : opt_pass(data, ctxt)\n+  simple_ipa_opt_pass (const pass_data& data, gcc::context *ctxt)\n+    : opt_pass (data, ctxt)\n   {\n   }\n };"}, {"sha": "c357b06f978087a878ff3804b9c9b0985e810a8c", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -46,7 +46,7 @@ static void do_niy (pretty_printer *, const_tree);\n #define INDENT(SPACE) do { \\\n   int i; for (i = 0; i<SPACE; i++) pp_space (buffer); } while (0)\n \n-#define NIY do_niy(buffer,node)\n+#define NIY do_niy (buffer, node)\n \n static pretty_printer buffer;\n static int initialized = 0;"}, {"sha": "a0e49b5304750389a598d7510844c3267cf433e6", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -607,7 +607,7 @@ tree_profiling (void)\n       pop_cfun ();\n     }\n \n-  del_node_map();\n+  del_node_map ();\n   return 0;\n }\n \n@@ -641,8 +641,8 @@ const pass_data pass_data_ipa_tree_profile =\n class pass_ipa_tree_profile : public simple_ipa_opt_pass\n {\n public:\n-  pass_ipa_tree_profile(gcc::context *ctxt)\n-    : simple_ipa_opt_pass(pass_data_ipa_tree_profile, ctxt)\n+  pass_ipa_tree_profile (gcc::context *ctxt)\n+    : simple_ipa_opt_pass (pass_data_ipa_tree_profile, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "063790244505b3ebce9bb1ddc15290227c0d7ee0", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -2071,7 +2071,7 @@ struct instantiate_cache_type\n   htab_t map;\n   vec<scev_info_str> entries;\n \n-  instantiate_cache_type () : map (NULL), entries(vNULL) {}\n+  instantiate_cache_type () : map (NULL), entries (vNULL) {}\n   ~instantiate_cache_type ();\n   tree get (unsigned slot) { return entries[slot].chrec; }\n   void set (unsigned slot, tree chrec) { entries[slot].chrec = chrec; }"}, {"sha": "a2529cb4b55d431cacf1aca70230d39ddf317feb", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -3468,8 +3468,8 @@ const pass_data pass_data_sra_early =\n class pass_sra_early : public gimple_opt_pass\n {\n public:\n-  pass_sra_early(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_sra_early, ctxt)\n+  pass_sra_early (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_sra_early, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -3506,8 +3506,8 @@ const pass_data pass_data_sra =\n class pass_sra : public gimple_opt_pass\n {\n public:\n-  pass_sra(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_sra, ctxt)\n+  pass_sra (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_sra, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -4292,7 +4292,7 @@ analyze_all_param_acesses (void)\n \n   repr_state = splice_all_param_accesses (representatives);\n   if (repr_state == NO_GOOD_ACCESS)\n-    return ipa_parm_adjustment_vec();\n+    return ipa_parm_adjustment_vec ();\n \n   /* If there are any parameters passed by reference which are not modified\n      directly, we need to check whether they can be modified indirectly.  */\n@@ -4356,7 +4356,7 @@ analyze_all_param_acesses (void)\n     adjustments = turn_representatives_into_adjustments (representatives,\n \t\t\t\t\t\t\t adjustments_count);\n   else\n-    adjustments = ipa_parm_adjustment_vec();\n+    adjustments = ipa_parm_adjustment_vec ();\n \n   representatives.release ();\n   return adjustments;\n@@ -4952,7 +4952,7 @@ ipa_sra_preliminary_function_checks (struct cgraph_node *node)\n     }\n \n   if ((DECL_COMDAT (node->symbol.decl) || DECL_EXTERNAL (node->symbol.decl))\n-      && inline_summary(node)->size >= MAX_INLINE_INSNS_AUTO)\n+      && inline_summary (node)->size >= MAX_INLINE_INSNS_AUTO)\n     {\n       if (dump_file)\n \tfprintf (dump_file, \"Function too big to be made truly local.\\n\");\n@@ -5088,8 +5088,8 @@ const pass_data pass_data_early_ipa_sra =\n class pass_early_ipa_sra : public gimple_opt_pass\n {\n public:\n-  pass_early_ipa_sra(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_early_ipa_sra, ctxt)\n+  pass_early_ipa_sra (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_early_ipa_sra, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "849e9e927020d1235bf44aff5202fad307fd1170", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -2166,8 +2166,8 @@ const pass_data pass_data_ccp =\n class pass_ccp : public gimple_opt_pass\n {\n public:\n-  pass_ccp(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_ccp, ctxt)\n+  pass_ccp (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_ccp, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -2583,8 +2583,8 @@ const pass_data pass_data_fold_builtins =\n class pass_fold_builtins : public gimple_opt_pass\n {\n public:\n-  pass_fold_builtins(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_fold_builtins, ctxt)\n+  pass_fold_builtins (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_fold_builtins, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "087272fe13a7d0ce9a01433772b11ac4040ae539", "filename": "gcc/tree-ssa-coalesce.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-coalesce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-coalesce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-coalesce.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -635,7 +635,7 @@ new_live_track (var_map map)\n   ptr->map = map;\n   lim = num_basevars (map);\n   bitmap_obstack_initialize (&ptr->obstack);\n-  ptr->live_base_partitions = (bitmap *) xmalloc(sizeof (bitmap *) * lim);\n+  ptr->live_base_partitions = (bitmap *) xmalloc (sizeof (bitmap *) * lim);\n   ptr->live_base_var = BITMAP_ALLOC (&ptr->obstack);\n   for (x = 0; x < lim; x++)\n     ptr->live_base_partitions[x] = BITMAP_ALLOC (&ptr->obstack);"}, {"sha": "a20fc97f2ad1d9c3297a51e9dbb7d279f2a2cb1c", "filename": "gcc/tree-ssa-copy.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-copy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-copy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copy.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -858,8 +858,8 @@ const pass_data pass_data_copy_prop =\n class pass_copy_prop : public gimple_opt_pass\n {\n public:\n-  pass_copy_prop(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_copy_prop, ctxt)\n+  pass_copy_prop (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_copy_prop, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "f4395e44cb71c42994bf02c7f185ccba7d1480fc", "filename": "gcc/tree-ssa-copyrename.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-copyrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-copyrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copyrename.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -455,8 +455,8 @@ const pass_data pass_data_rename_ssa_copies =\n class pass_rename_ssa_copies : public gimple_opt_pass\n {\n public:\n-  pass_rename_ssa_copies(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_rename_ssa_copies, ctxt)\n+  pass_rename_ssa_copies (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_rename_ssa_copies, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "c132baf82ee7cce3a58e48ef21d4f3f8d5f0c195", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -1560,8 +1560,8 @@ const pass_data pass_data_dce =\n class pass_dce : public gimple_opt_pass\n {\n public:\n-  pass_dce(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_dce, ctxt)\n+  pass_dce (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_dce, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -1599,8 +1599,8 @@ const pass_data pass_data_dce_loop =\n class pass_dce_loop : public gimple_opt_pass\n {\n public:\n-  pass_dce_loop(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_dce_loop, ctxt)\n+  pass_dce_loop (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_dce_loop, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -1638,8 +1638,8 @@ const pass_data pass_data_cd_dce =\n class pass_cd_dce : public gimple_opt_pass\n {\n public:\n-  pass_cd_dce(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_cd_dce, ctxt)\n+  pass_cd_dce (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_cd_dce, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "495b6b8b957be75f7be66062a34cf6903e5897f5", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -935,8 +935,8 @@ const pass_data pass_data_dominator =\n class pass_dominator : public gimple_opt_pass\n {\n public:\n-  pass_dominator(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_dominator, ctxt)\n+  pass_dominator (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_dominator, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -3128,8 +3128,8 @@ const pass_data pass_data_phi_only_cprop =\n class pass_phi_only_cprop : public gimple_opt_pass\n {\n public:\n-  pass_phi_only_cprop(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_phi_only_cprop, ctxt)\n+  pass_phi_only_cprop (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_phi_only_cprop, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "45c8b2f685f09982fd2e98c8be0e751f42e645fa", "filename": "gcc/tree-ssa-dse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-dse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-dse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dse.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -375,8 +375,8 @@ const pass_data pass_data_dse =\n class pass_dse : public gimple_opt_pass\n {\n public:\n-  pass_dse(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_dse, ctxt)\n+  pass_dse (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_dse, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "ee8240e35f188399c7bbdf5b4dd885e45146468d", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -3177,9 +3177,9 @@ simplify_permutation (gimple_stmt_iterator *gsi)\n \t    return 0;\n \t  arg1 = arg0;\n \t}\n-      opt = fold_ternary (VEC_PERM_EXPR, TREE_TYPE(op0), arg0, arg1, op2);\n+      opt = fold_ternary (VEC_PERM_EXPR, TREE_TYPE (op0), arg0, arg1, op2);\n       if (!opt\n-\t  || (TREE_CODE (opt) != CONSTRUCTOR && TREE_CODE(opt) != VECTOR_CST))\n+\t  || (TREE_CODE (opt) != CONSTRUCTOR && TREE_CODE (opt) != VECTOR_CST))\n \treturn 0;\n       gimple_assign_set_rhs_from_tree (gsi, opt);\n       update_stmt (gsi_stmt (*gsi));\n@@ -3560,8 +3560,8 @@ const pass_data pass_data_forwprop =\n class pass_forwprop : public gimple_opt_pass\n {\n public:\n-  pass_forwprop(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_forwprop, ctxt)\n+  pass_forwprop (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_forwprop, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "2a7745194e3764cb8af10d2426c0e56d3b3cca56", "filename": "gcc/tree-ssa-ifcombine.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-ifcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-ifcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ifcombine.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -668,8 +668,8 @@ const pass_data pass_data_tree_ifcombine =\n class pass_tree_ifcombine : public gimple_opt_pass\n {\n public:\n-  pass_tree_ifcombine(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_tree_ifcombine, ctxt)\n+  pass_tree_ifcombine (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_tree_ifcombine, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "7705f1312b86c3b32431eda85b2ef8fc1d30b9ba", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -1237,7 +1237,7 @@ dump_var_map (FILE *f, var_map map)\n \t    {\n \t      if (t++ == 0)\n \t        {\n-\t\t  fprintf(f, \"Partition %d (\", x);\n+\t\t  fprintf (f, \"Partition %d (\", x);\n \t\t  print_generic_expr (f, partition_to_var (map, p), TDF_SLIM);\n \t\t  fprintf (f, \" - \");\n \t\t}"}, {"sha": "faa6bbcc58531e80f098f973a8c90e04bd0eec02", "filename": "gcc/tree-ssa-loop-ch.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-loop-ch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-loop-ch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ch.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -277,8 +277,8 @@ const pass_data pass_data_ch =\n class pass_ch : public gimple_opt_pass\n {\n public:\n-  pass_ch(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_ch, ctxt)\n+  pass_ch (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_ch, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "fc255289f24ba7fce8d310d6cc9825a273c624f2", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -227,7 +227,7 @@ get_lim_data (gimple stmt)\n static void\n free_lim_aux_data (struct lim_aux_data *data)\n {\n-  data->depends.release();\n+  data->depends.release ();\n   free (data);\n }\n \n@@ -1695,12 +1695,12 @@ for_all_locs_in_loop (struct loop *loop, mem_ref_p ref, FN fn)\n struct rewrite_mem_ref_loc\n {\n   rewrite_mem_ref_loc (tree tmp_var_) : tmp_var (tmp_var_) {}\n-  bool operator()(mem_ref_loc_p loc);\n+  bool operator () (mem_ref_loc_p loc);\n   tree tmp_var;\n };\n \n bool\n-rewrite_mem_ref_loc::operator()(mem_ref_loc_p loc)\n+rewrite_mem_ref_loc::operator () (mem_ref_loc_p loc)\n {\n   *loc->ref = tmp_var;\n   update_stmt (loc->stmt);\n@@ -1720,12 +1720,12 @@ rewrite_mem_refs (struct loop *loop, mem_ref_p ref, tree tmp_var)\n struct first_mem_ref_loc_1\n {\n   first_mem_ref_loc_1 (mem_ref_loc_p *locp_) : locp (locp_) {}\n-  bool operator()(mem_ref_loc_p loc);\n+  bool operator () (mem_ref_loc_p loc);\n   mem_ref_loc_p *locp;\n };\n \n bool\n-first_mem_ref_loc_1::operator()(mem_ref_loc_p loc)\n+first_mem_ref_loc_1::operator () (mem_ref_loc_p loc)\n {\n   *locp = loc;\n   return true;\n@@ -2001,12 +2001,12 @@ execute_sm_if_changed (edge ex, tree mem, tree tmp_var, tree flag)\n struct sm_set_flag_if_changed\n {\n   sm_set_flag_if_changed (tree flag_) : flag (flag_) {}\n-  bool operator()(mem_ref_loc_p loc);\n+  bool operator () (mem_ref_loc_p loc);\n   tree flag;\n };\n \n bool\n-sm_set_flag_if_changed::operator()(mem_ref_loc_p loc)\n+sm_set_flag_if_changed::operator () (mem_ref_loc_p loc)\n {\n   /* Only set the flag for writes.  */\n   if (is_gimple_assign (loc->stmt)\n@@ -2130,14 +2130,14 @@ struct ref_always_accessed\n {\n   ref_always_accessed (struct loop *loop_, tree base_, bool stored_p_)\n       : loop (loop_), base (base_), stored_p (stored_p_) {}\n-  bool operator()(mem_ref_loc_p loc);\n+  bool operator () (mem_ref_loc_p loc);\n   struct loop *loop;\n   tree base;\n   bool stored_p;\n };\n \n bool\n-ref_always_accessed::operator()(mem_ref_loc_p loc)\n+ref_always_accessed::operator () (mem_ref_loc_p loc)\n {\n   struct loop *must_exec;\n "}, {"sha": "7b684a6281908000f5ac0fa84deecd9c36adb961", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -3920,7 +3920,7 @@ get_loop_invariant_expr_id (struct ivopts_data *data, tree ubase,\n \n   if (ratio == 1)\n     {\n-      if(operand_equal_p (ubase, cbase, 0))\n+      if (operand_equal_p (ubase, cbase, 0))\n         return -1;\n \n       if (TREE_CODE (ubase) == ADDR_EXPR"}, {"sha": "d75155d15d6e2585077ba95bd1c833d98d1175b1", "filename": "gcc/tree-ssa-loop-prefetch.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-loop-prefetch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-loop-prefetch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-prefetch.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -555,7 +555,7 @@ gather_memory_references_ref (struct loop *loop, struct mem_ref_group **refs,\n               fprintf (dump_file, \"Memory expression %p\\n\",(void *) ref ); \n               print_generic_expr (dump_file, ref, TDF_TREE); \n               fprintf (dump_file,\":\");\n-              dump_mem_details( dump_file, base, step, delta, write_p);              \n+              dump_mem_details (dump_file, base, step, delta, write_p);\n               fprintf (dump_file, \n                        \"Ignoring %p, non-constant step prefetching is \"\n                        \"limited to inner most loops \\n\", \n@@ -572,7 +572,7 @@ gather_memory_references_ref (struct loop *loop, struct mem_ref_group **refs,\n                 fprintf (dump_file, \"Memory expression %p\\n\",(void *) ref );\n                 print_generic_expr (dump_file, ref, TDF_TREE);\n                 fprintf (dump_file,\":\");\n-                dump_mem_details(dump_file, base, step, delta, write_p);\n+                dump_mem_details (dump_file, base, step, delta, write_p);\n                 fprintf (dump_file, \n                          \"Not prefetching, ignoring %p due to \"\n                          \"loop variant step\\n\","}, {"sha": "947f4d4782fe42f908eb5ed06a2f24ba79368e1b", "filename": "gcc/tree-ssa-loop.c", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -61,8 +61,8 @@ const pass_data pass_data_tree_loop =\n class pass_tree_loop : public gimple_opt_pass\n {\n public:\n-  pass_tree_loop(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_tree_loop, ctxt)\n+  pass_tree_loop (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_tree_loop, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -117,8 +117,8 @@ const pass_data pass_data_tree_loop_init =\n class pass_tree_loop_init : public gimple_opt_pass\n {\n public:\n-  pass_tree_loop_init(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_tree_loop_init, ctxt)\n+  pass_tree_loop_init (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_tree_loop_init, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -171,8 +171,8 @@ const pass_data pass_data_lim =\n class pass_lim : public gimple_opt_pass\n {\n public:\n-  pass_lim(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_lim, ctxt)\n+  pass_lim (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_lim, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -227,8 +227,8 @@ const pass_data pass_data_tree_unswitch =\n class pass_tree_unswitch : public gimple_opt_pass\n {\n public:\n-  pass_tree_unswitch(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_tree_unswitch, ctxt)\n+  pass_tree_unswitch (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_tree_unswitch, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -282,8 +282,8 @@ const pass_data pass_data_predcom =\n class pass_predcom : public gimple_opt_pass\n {\n public:\n-  pass_predcom(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_predcom, ctxt)\n+  pass_predcom (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_predcom, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -337,8 +337,8 @@ const pass_data pass_data_vectorize =\n class pass_vectorize : public gimple_opt_pass\n {\n public:\n-  pass_vectorize(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_vectorize, ctxt)\n+  pass_vectorize (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_vectorize, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -404,8 +404,8 @@ const pass_data pass_data_graphite =\n class pass_graphite : public gimple_opt_pass\n {\n public:\n-  pass_graphite(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_graphite, ctxt)\n+  pass_graphite (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_graphite, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -441,8 +441,8 @@ const pass_data pass_data_graphite_transforms =\n class pass_graphite_transforms : public gimple_opt_pass\n {\n public:\n-  pass_graphite_transforms(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_graphite_transforms, ctxt)\n+  pass_graphite_transforms (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_graphite_transforms, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -497,8 +497,8 @@ const pass_data pass_data_check_data_deps =\n class pass_check_data_deps : public gimple_opt_pass\n {\n public:\n-  pass_check_data_deps(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_check_data_deps, ctxt)\n+  pass_check_data_deps (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_check_data_deps, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -552,8 +552,8 @@ const pass_data pass_data_iv_canon =\n class pass_iv_canon : public gimple_opt_pass\n {\n public:\n-  pass_iv_canon(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_iv_canon, ctxt)\n+  pass_iv_canon (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_iv_canon, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -599,8 +599,8 @@ const pass_data pass_data_scev_cprop =\n class pass_scev_cprop : public gimple_opt_pass\n {\n public:\n-  pass_scev_cprop(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_scev_cprop, ctxt)\n+  pass_scev_cprop (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_scev_cprop, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -650,8 +650,8 @@ const pass_data pass_data_record_bounds =\n class pass_record_bounds : public gimple_opt_pass\n {\n public:\n-  pass_record_bounds(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_record_bounds, ctxt)\n+  pass_record_bounds (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_record_bounds, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -706,8 +706,8 @@ const pass_data pass_data_complete_unroll =\n class pass_complete_unroll : public gimple_opt_pass\n {\n public:\n-  pass_complete_unroll(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_complete_unroll, ctxt)\n+  pass_complete_unroll (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_complete_unroll, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -771,8 +771,8 @@ const pass_data pass_data_complete_unrolli =\n class pass_complete_unrolli : public gimple_opt_pass\n {\n public:\n-  pass_complete_unrolli(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_complete_unrolli, ctxt)\n+  pass_complete_unrolli (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_complete_unrolli, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -828,8 +828,8 @@ const pass_data pass_data_parallelize_loops =\n class pass_parallelize_loops : public gimple_opt_pass\n {\n public:\n-  pass_parallelize_loops(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_parallelize_loops, ctxt)\n+  pass_parallelize_loops (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_parallelize_loops, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -883,8 +883,8 @@ const pass_data pass_data_loop_prefetch =\n class pass_loop_prefetch : public gimple_opt_pass\n {\n public:\n-  pass_loop_prefetch(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_loop_prefetch, ctxt)\n+  pass_loop_prefetch (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_loop_prefetch, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -939,8 +939,8 @@ const pass_data pass_data_iv_optimize =\n class pass_iv_optimize : public gimple_opt_pass\n {\n public:\n-  pass_iv_optimize(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_iv_optimize, ctxt)\n+  pass_iv_optimize (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_iv_optimize, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -988,8 +988,8 @@ const pass_data pass_data_tree_loop_done =\n class pass_tree_loop_done : public gimple_opt_pass\n {\n public:\n-  pass_tree_loop_done(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_tree_loop_done, ctxt)\n+  pass_tree_loop_done (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_tree_loop_done, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "f7f8ec91fcec57d7f9fa8b7f838939b210aeb1c8", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -657,8 +657,8 @@ const pass_data pass_data_cse_reciprocals =\n class pass_cse_reciprocals : public gimple_opt_pass\n {\n public:\n-  pass_cse_reciprocals(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_cse_reciprocals, ctxt)\n+  pass_cse_reciprocals (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_cse_reciprocals, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -1575,8 +1575,8 @@ const pass_data pass_data_cse_sincos =\n class pass_cse_sincos : public gimple_opt_pass\n {\n public:\n-  pass_cse_sincos(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_cse_sincos, ctxt)\n+  pass_cse_sincos (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_cse_sincos, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -2065,8 +2065,8 @@ const pass_data pass_data_optimize_bswap =\n class pass_optimize_bswap : public gimple_opt_pass\n {\n public:\n-  pass_optimize_bswap(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_optimize_bswap, ctxt)\n+  pass_optimize_bswap (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_optimize_bswap, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -2871,8 +2871,8 @@ const pass_data pass_data_optimize_widening_mul =\n class pass_optimize_widening_mul : public gimple_opt_pass\n {\n public:\n-  pass_optimize_widening_mul(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_optimize_widening_mul, ctxt)\n+  pass_optimize_widening_mul (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_optimize_widening_mul, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "6bb36729617b59470f5ab72214e68cb5a49684c1", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -1203,7 +1203,7 @@ verify_imm_links (FILE *f, tree var)\n   fprintf (f, \" IMM ERROR : (use_p : tree - %p:%p)\", (void *)ptr,\n \t   (void *)ptr->use);\n   print_generic_expr (f, USE_FROM_PTR (ptr), TDF_SLIM);\n-  fprintf(f, \"\\n\");\n+  fprintf (f, \"\\n\");\n   return true;\n }\n \n@@ -1238,7 +1238,7 @@ dump_immediate_uses_for (FILE *file, tree var)\n \telse\n \t  print_gimple_stmt (file, USE_STMT (use_p), 0, TDF_SLIM);\n     }\n-  fprintf(file, \"\\n\");\n+  fprintf (file, \"\\n\");\n }\n \n \n@@ -1253,7 +1253,7 @@ dump_immediate_uses (FILE *file)\n   fprintf (file, \"Immediate_uses: \\n\\n\");\n   for (x = 1; x < num_ssa_names; x++)\n     {\n-      var = ssa_name(x);\n+      var = ssa_name (x);\n       if (!var)\n         continue;\n       dump_immediate_uses_for (file, var);"}, {"sha": "d9dbed3e71b6e81c7dac8390a7391408b2e415b7", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -2034,8 +2034,8 @@ const pass_data pass_data_phiopt =\n class pass_phiopt : public gimple_opt_pass\n {\n public:\n-  pass_phiopt(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_phiopt, ctxt)\n+  pass_phiopt (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_phiopt, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -2080,8 +2080,8 @@ const pass_data pass_data_cselim =\n class pass_cselim : public gimple_opt_pass\n {\n public:\n-  pass_cselim(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_cselim, ctxt)\n+  pass_cselim (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_cselim, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "f3ea552795d67229b3a39b95bc5dd6325c13afca", "filename": "gcc/tree-ssa-phiprop.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-phiprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-phiprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiprop.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -414,8 +414,8 @@ const pass_data pass_data_phiprop =\n class pass_phiprop : public gimple_opt_pass\n {\n public:\n-  pass_phiprop(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_phiprop, ctxt)\n+  pass_phiprop (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_phiprop, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "243f37e70a8ef67c4a6366bc2539fa3690c97681", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -360,10 +360,10 @@ typedef struct bitmap_set\n } *bitmap_set_t;\n \n #define FOR_EACH_EXPR_ID_IN_SET(set, id, bi)\t\t\\\n-  EXECUTE_IF_SET_IN_BITMAP(&(set)->expressions, 0, (id), (bi))\n+  EXECUTE_IF_SET_IN_BITMAP (&(set)->expressions, 0, (id), (bi))\n \n #define FOR_EACH_VALUE_ID_IN_SET(set, id, bi)\t\t\\\n-  EXECUTE_IF_SET_IN_BITMAP(&(set)->values, 0, (id), (bi))\n+  EXECUTE_IF_SET_IN_BITMAP (&(set)->values, 0, (id), (bi))\n \n /* Mapping from value id to expressions with that value_id.  */\n static vec<bitmap> value_expressions;\n@@ -1344,7 +1344,7 @@ get_expr_type (const pre_expr e)\n     case NARY:\n       return PRE_EXPR_NARY (e)->type;\n     }\n-  gcc_unreachable();\n+  gcc_unreachable ();\n }\n \n /* Get a representative SSA_NAME for a given expression.\n@@ -1488,7 +1488,7 @@ phi_translate_1 (pre_expr expr, bitmap_set_t set1, bitmap_set_t set2,\n \t    else\n \t      {\n \t\tnew_val_id = get_next_value_id ();\n-\t\tvalue_expressions.safe_grow_cleared (get_max_value_id() + 1);\n+\t\tvalue_expressions.safe_grow_cleared (get_max_value_id () + 1);\n \t\tnary = vn_nary_op_insert_pieces (newnary->length,\n \t\t\t\t\t\t newnary->opcode,\n \t\t\t\t\t\t newnary->type,\n@@ -1673,7 +1673,8 @@ phi_translate_1 (pre_expr expr, bitmap_set_t set1, bitmap_set_t set2,\n \t\tif (changed || !same_valid)\n \t\t  {\n \t\t    new_val_id = get_next_value_id ();\n-\t\t    value_expressions.safe_grow_cleared(get_max_value_id() + 1);\n+\t\t    value_expressions.safe_grow_cleared\n+\t\t      (get_max_value_id () + 1);\n \t\t  }\n \t\telse\n \t\t  new_val_id = ref->value_id;\n@@ -4629,7 +4630,7 @@ init_pre (void)\n   expressions.create (0);\n   expressions.safe_push (NULL);\n   value_expressions.create (get_max_value_id () + 1);\n-  value_expressions.safe_grow_cleared (get_max_value_id() + 1);\n+  value_expressions.safe_grow_cleared (get_max_value_id () + 1);\n   name_to_id.create (0);\n \n   inserted_exprs = BITMAP_ALLOC (NULL);\n@@ -4789,8 +4790,8 @@ const pass_data pass_data_pre =\n class pass_pre : public gimple_opt_pass\n {\n public:\n-  pass_pre(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_pre, ctxt)\n+  pass_pre (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_pre, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -4859,8 +4860,8 @@ const pass_data pass_data_fre =\n class pass_fre : public gimple_opt_pass\n {\n public:\n-  pass_fre(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_fre, ctxt)\n+  pass_fre (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_fre, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "62c46a145986a25577073e1a90f1f5813e960304", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -4480,8 +4480,8 @@ const pass_data pass_data_reassoc =\n class pass_reassoc : public gimple_opt_pass\n {\n public:\n-  pass_reassoc(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_reassoc, ctxt)\n+  pass_reassoc (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_reassoc, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "e3d62fb9b4e71ce32545da4d90174ff86b1df631", "filename": "gcc/tree-ssa-sink.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-sink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-sink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sink.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -607,8 +607,8 @@ const pass_data pass_data_sink_code =\n class pass_sink_code : public gimple_opt_pass\n {\n public:\n-  pass_sink_code(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_sink_code, ctxt)\n+  pass_sink_code (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_sink_code, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "5df1ddf59bd5ac077a1158822fde1df935d1229c", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -2098,8 +2098,8 @@ const pass_data pass_data_strlen =\n class pass_strlen : public gimple_opt_pass\n {\n public:\n-  pass_strlen(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_strlen, ctxt)\n+  pass_strlen (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_strlen, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "46acc9ab9add0d20e86bd774ba6adbb3a35ad795", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -1747,7 +1747,7 @@ do_complex_constraint (constraint_graph_t graph, constraint_t c, bitmap delta)\n     {\n       if (c->rhs.type == ADDRESSOF)\n \t{\n-\t  gcc_unreachable();\n+\t  gcc_unreachable ();\n \t}\n       else\n \t{\n@@ -2096,7 +2096,7 @@ label_visit (constraint_graph_t graph, struct scc_info *si, unsigned int n)\n \t\t}\n \t    }\n \t  else\n-\t    bitmap_ior_into(graph->points_to[n], graph->points_to[w]);\n+\t    bitmap_ior_into (graph->points_to[n], graph->points_to[w]);\n \t}\n     }\n \n@@ -4301,8 +4301,8 @@ find_func_aliases_for_builtin_call (gimple t)\n \t    rhsc.safe_push (nul);\n \t    get_constraint_for (gimple_call_lhs (t), &lhsc);\n \t    process_all_all_constraints (lhsc, rhsc);\n-\t    lhsc.release();\n-\t    rhsc.release();\n+\t    lhsc.release ();\n+\t    rhsc.release ();\n \t  }\n \treturn true;\n       /* Trampolines are special - they set up passing the static\n@@ -6980,8 +6980,8 @@ const pass_data pass_data_build_alias =\n class pass_build_alias : public gimple_opt_pass\n {\n public:\n-  pass_build_alias(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_build_alias, ctxt)\n+  pass_build_alias (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_build_alias, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -7020,8 +7020,8 @@ const pass_data pass_data_build_ealias =\n class pass_build_ealias : public gimple_opt_pass\n {\n public:\n-  pass_build_ealias(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_build_ealias, ctxt)\n+  pass_build_ealias (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_build_ealias, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -7414,8 +7414,8 @@ const pass_data pass_data_ipa_pta =\n class pass_ipa_pta : public simple_ipa_opt_pass\n {\n public:\n-  pass_ipa_pta(gcc::context *ctxt)\n-    : simple_ipa_opt_pass(pass_data_ipa_pta, ctxt)\n+  pass_ipa_pta (gcc::context *ctxt)\n+    : simple_ipa_opt_pass (pass_data_ipa_pta, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "cf62785c31689bc61989d617a7528d3ce7c06695", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -1022,7 +1022,7 @@ thread_across_edge (gimple dummy_cond,\n \n \tfor (unsigned int i = 0; i < path.length (); i++)\n \t  delete path[i];\n-        path.release();\n+        path.release ();\n       }\n     BITMAP_FREE (visited);\n   }"}, {"sha": "05d56826a1528cfced0fca8f428dfbd210616bb1", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -364,8 +364,8 @@ create_edge_and_update_destination_phis (struct redirection_data *rd,\n   if (rd->outgoing_edge->aux)\n     {\n       e->aux = XNEWVEC (edge, 2);\n-      THREAD_TARGET(e) = THREAD_TARGET (rd->outgoing_edge);\n-      THREAD_TARGET2(e) = THREAD_TARGET2 (rd->outgoing_edge);\n+      THREAD_TARGET (e) = THREAD_TARGET (rd->outgoing_edge);\n+      THREAD_TARGET2 (e) = THREAD_TARGET2 (rd->outgoing_edge);\n     }\n   else\n     {\n@@ -1306,7 +1306,7 @@ mark_threaded_blocks (bitmap threaded_blocks)\n   else\n     bitmap_copy (threaded_blocks, tmp);\n \n-  BITMAP_FREE(tmp);\n+  BITMAP_FREE (tmp);\n }\n \n "}, {"sha": "0bff196f8990cdb81fa50856289bc85c93eef7b1", "filename": "gcc/tree-ssa-uncprop.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-uncprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-uncprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uncprop.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -603,8 +603,8 @@ const pass_data pass_data_uncprop =\n class pass_uncprop : public gimple_opt_pass\n {\n public:\n-  pass_uncprop(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_uncprop, ctxt)\n+  pass_uncprop (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_uncprop, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "044efb348073df06b73b9a4732e88487f1888b01", "filename": "gcc/tree-ssa-uninit.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-uninit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa-uninit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uninit.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -2193,8 +2193,8 @@ const pass_data pass_data_late_warn_uninitialized =\n class pass_late_warn_uninitialized : public gimple_opt_pass\n {\n public:\n-  pass_late_warn_uninitialized(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_late_warn_uninitialized, ctxt)\n+  pass_late_warn_uninitialized (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_late_warn_uninitialized, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -2254,8 +2254,8 @@ const pass_data pass_data_early_warn_uninitialized =\n class pass_early_warn_uninitialized : public gimple_opt_pass\n {\n public:\n-  pass_early_warn_uninitialized(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_early_warn_uninitialized, ctxt)\n+  pass_early_warn_uninitialized (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_early_warn_uninitialized, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "421e200da9ffe2b495da8e23b995da14ab4953cf", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -1247,8 +1247,8 @@ const pass_data pass_data_init_datastructures =\n class pass_init_datastructures : public gimple_opt_pass\n {\n public:\n-  pass_init_datastructures(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_init_datastructures, ctxt)\n+  pass_init_datastructures (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_init_datastructures, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -1778,8 +1778,8 @@ const pass_data pass_data_update_address_taken =\n class pass_update_address_taken : public gimple_opt_pass\n {\n public:\n-  pass_update_address_taken(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_update_address_taken, ctxt)\n+  pass_update_address_taken (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_update_address_taken, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "a51f60307ec1ba26e76d3b3a89e38499d03c7f51", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -553,8 +553,8 @@ const pass_data pass_data_release_ssa_names =\n class pass_release_ssa_names : public gimple_opt_pass\n {\n public:\n-  pass_release_ssa_names(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_release_ssa_names, ctxt)\n+  pass_release_ssa_names (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_release_ssa_names, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "d7cd291f3a8461a0a2721621b851f8ced8f27825", "filename": "gcc/tree-stdarg.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-stdarg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-stdarg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-stdarg.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -1005,8 +1005,8 @@ const pass_data pass_data_stdarg =\n class pass_stdarg : public gimple_opt_pass\n {\n public:\n-  pass_stdarg(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_stdarg, ctxt)\n+  pass_stdarg (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_stdarg, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "a0d33067a8fe139f78e0379d6a1c032cb0e36d35", "filename": "gcc/tree-switch-conversion.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-switch-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-switch-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -365,7 +365,7 @@ emit_case_bit_tests (gimple swtch, tree index_expr,\n \t  test[k].lo |= (HOST_WIDE_INT) 1 << j;\n     }\n \n-  qsort (test, count, sizeof(*test), case_bit_test_cmp);\n+  qsort (test, count, sizeof (*test), case_bit_test_cmp);\n \n   /* We generate two jumps to the default case label.\n      Split the default edge, so that we don't have to do any PHI node\n@@ -1485,8 +1485,8 @@ const pass_data pass_data_convert_switch =\n class pass_convert_switch : public gimple_opt_pass\n {\n public:\n-  pass_convert_switch(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_convert_switch, ctxt)\n+  pass_convert_switch (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_convert_switch, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "9e770cb8dbc8861fce1e7a096b8c7dd9e7ef24f2", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -1083,8 +1083,8 @@ const pass_data pass_data_tail_recursion =\n class pass_tail_recursion : public gimple_opt_pass\n {\n public:\n-  pass_tail_recursion(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_tail_recursion, ctxt)\n+  pass_tail_recursion (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_tail_recursion, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -1122,8 +1122,8 @@ const pass_data pass_data_tail_calls =\n class pass_tail_calls : public gimple_opt_pass\n {\n public:\n-  pass_tail_calls(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_tail_calls, ctxt)\n+  pass_tail_calls (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_tail_calls, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "e7b2f33440189e9382c96dec15364521d9529782", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -1223,7 +1223,7 @@ vect_peeling_hash_choose_best_peeling (loop_vec_info loop_vinfo,\n    struct _vect_peel_extended_info res;\n \n    res.peel_info.dr = NULL;\n-   res.body_cost_vec = stmt_vector_for_cost();\n+   res.body_cost_vec = stmt_vector_for_cost ();\n \n    if (!unlimited_cost_model ())\n      {\n@@ -1358,7 +1358,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n   unsigned possible_npeel_number = 1;\n   tree vectype;\n   unsigned int nelements, mis, same_align_drs_max = 0;\n-  stmt_vector_for_cost body_cost_vec = stmt_vector_for_cost();\n+  stmt_vector_for_cost body_cost_vec = stmt_vector_for_cost ();\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n@@ -2538,7 +2538,7 @@ vect_analyze_data_ref_accesses (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n \n   /* Sort the array of datarefs to make building the interleaving chains\n      linear.  */\n-  qsort (datarefs.address(), datarefs.length (),\n+  qsort (datarefs.address (), datarefs.length (),\n \t sizeof (data_reference_p), dr_group_sort_cmp);\n \n   /* Build the interleaving chains.  */"}, {"sha": "07158fb05e9be1ce90cd1438be63c564cb9a863f", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -1477,8 +1477,8 @@ const pass_data pass_data_lower_vector =\n class pass_lower_vector : public gimple_opt_pass\n {\n public:\n-  pass_lower_vector(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_lower_vector, ctxt)\n+  pass_lower_vector (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_lower_vector, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -1518,8 +1518,8 @@ const pass_data pass_data_lower_vector_ssa =\n class pass_lower_vector_ssa : public gimple_opt_pass\n {\n public:\n-  pass_lower_vector_ssa(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_lower_vector_ssa, ctxt)\n+  pass_lower_vector_ssa (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_lower_vector_ssa, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "574446a7ddec0cfb6b3b300e27e051656b30e4d7", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -923,10 +923,10 @@ set_prologue_iterations (basic_block bb_before_first_loop,\n     unshare_expr (LOOP_VINFO_NITERS_UNCHANGED (loop_vec_info_for_loop (loop)));\n \n   e = single_pred_edge (bb_before_first_loop);\n-  cond_bb = split_edge(e);\n+  cond_bb = split_edge (e);\n \n   e = single_pred_edge (bb_before_first_loop);\n-  then_bb = split_edge(e);\n+  then_bb = split_edge (e);\n   set_immediate_dominator (CDI_DOMINATORS, then_bb, cond_bb);\n \n   e_false = make_single_succ_edge (cond_bb, bb_before_first_loop,\n@@ -2449,7 +2449,7 @@ vect_loop_versioning (loop_vec_info loop_vinfo,\n \t\t\t \"alignment\\n\");\n \n     }\n-  free_original_copy_tables();\n+  free_original_copy_tables ();\n \n   /* Loop versioning violates an assumption we try to maintain during\n      vectorization - that the loop exit block has a single predecessor."}, {"sha": "7d9c9ed8d7d9b9859e79d3623271d2e8b7bee3fe", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -2675,7 +2675,7 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n     {\n       if (modifier == WIDEN)\n \t{\n-\t  vec_oprnds0.create (multi_step_cvt ? vect_pow2(multi_step_cvt) : 1);\n+\t  vec_oprnds0.create (multi_step_cvt ? vect_pow2 (multi_step_cvt) : 1);\n \t  if (op_type == binary_op)\n \t    vec_oprnds1.create (1);\n \t}\n@@ -4790,7 +4790,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t    (unshare_expr (DR_BASE_ADDRESS (dr)),\n \t     size_binop (PLUS_EXPR,\n \t\t\t convert_to_ptrofftype (unshare_expr (DR_OFFSET (dr))),\n-\t\t\t convert_to_ptrofftype (DR_INIT(dr))));\n+\t\t\t convert_to_ptrofftype (DR_INIT (dr))));\n       stride_step = fold_convert (sizetype, unshare_expr (DR_STEP (dr)));\n \n       /* For a load with loop-invariant (but other than power-of-2)"}, {"sha": "87404cf05365224de9aedd0ede16d24dc281d01b", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -510,8 +510,8 @@ const pass_data pass_data_slp_vectorize =\n class pass_slp_vectorize : public gimple_opt_pass\n {\n public:\n-  pass_slp_vectorize(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_slp_vectorize, ctxt)\n+  pass_slp_vectorize (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_slp_vectorize, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -550,7 +550,7 @@ increase_alignment (void)\n       tree t;\n       unsigned int alignment;\n \n-      t = TREE_TYPE(decl);\n+      t = TREE_TYPE (decl);\n       if (TREE_CODE (t) != ARRAY_TYPE)\n         continue;\n       vectype = get_vectype_for_scalar_type (strip_array_types (t));\n@@ -600,8 +600,8 @@ const pass_data pass_data_ipa_increase_alignment =\n class pass_ipa_increase_alignment : public simple_ipa_opt_pass\n {\n public:\n-  pass_ipa_increase_alignment(gcc::context *ctxt)\n-    : simple_ipa_opt_pass(pass_data_ipa_increase_alignment, ctxt)\n+  pass_ipa_increase_alignment (gcc::context *ctxt)\n+    : simple_ipa_opt_pass (pass_data_ipa_increase_alignment, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "a5cef5a58ad974b772e4e87c4ca657abbcaf2965", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -27,7 +27,7 @@ along with GCC; see the file COPYING3.  If not see\n \n typedef source_location LOC;\n #define UNKNOWN_LOC UNKNOWN_LOCATION\n-#define EXPR_LOC(e) EXPR_LOCATION(e)\n+#define EXPR_LOC(e) EXPR_LOCATION (e)\n #define LOC_FILE(l) LOCATION_FILE (l)\n #define LOC_LINE(l) LOCATION_LINE (l)\n \n@@ -356,7 +356,7 @@ typedef struct _loop_vec_info {\n && TREE_INT_CST_LOW ((n)) > 0)\n \n #define LOOP_VINFO_NITERS_KNOWN_P(L)          \\\n-NITERS_KNOWN_P((L)->num_iters)\n+NITERS_KNOWN_P ((L)->num_iters)\n \n static inline loop_vec_info\n loop_vec_info_for_loop (struct loop *loop)"}, {"sha": "caf3d55dc49159235aeb4dc8597193e98d3abc12", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -5854,7 +5854,7 @@ find_assert_locations_1 (basic_block bb, sbitmap live)\n     }\n \n   /* Traverse all PHI nodes in BB, updating live.  */\n-  for (si = gsi_start_phis (bb); !gsi_end_p(si); gsi_next (&si))\n+  for (si = gsi_start_phis (bb); !gsi_end_p (si); gsi_next (&si))\n     {\n       use_operand_p arg_p;\n       ssa_op_iter i;\n@@ -9665,8 +9665,8 @@ const pass_data pass_data_vrp =\n class pass_vrp : public gimple_opt_pass\n {\n public:\n-  pass_vrp(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_vrp, ctxt)\n+  pass_vrp (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_vrp, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "ebee116f0c5508443ee63dd92bda834c79de3aa4", "filename": "gcc/tree.c", "status": "modified", "additions": 30, "deletions": 27, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -1007,7 +1007,7 @@ copy_node_stat (tree node MEM_STAT_DECL)\n       TYPE_SYMTAB_ADDRESS (t) = 0;\n \n       /* Do not copy the values cache.  */\n-      if (TYPE_CACHED_VALUES_P(t))\n+      if (TYPE_CACHED_VALUES_P (t))\n \t{\n \t  TYPE_CACHED_VALUES_P (t) = 0;\n \t  TYPE_CACHED_VALUES (t) = NULL_TREE;\n@@ -1112,7 +1112,7 @@ force_fit_type_double (tree type, double_int cst, int overflowable,\n   bool sign_extended_type = !TYPE_UNSIGNED (type);\n \n   /* If we need to set overflow flags, return a new unshared node.  */\n-  if (overflowed || !double_int_fits_to_tree_p(type, cst))\n+  if (overflowed || !double_int_fits_to_tree_p (type, cst))\n     {\n       if (overflowed\n \t  || overflowable < 0\n@@ -1726,7 +1726,7 @@ build_one_cst (tree type)\n     case FIXED_POINT_TYPE:\n       /* We can only generate 1 for accum types.  */\n       gcc_assert (ALL_SCALAR_ACCUM_MODE_P (TYPE_MODE (type)));\n-      return build_fixed (type, FCONST1(TYPE_MODE (type)));\n+      return build_fixed (type, FCONST1 (TYPE_MODE (type)));\n \n     case VECTOR_TYPE:\n       {\n@@ -4118,8 +4118,8 @@ build2_stat (enum tree_code code, tree tt, tree arg0, tree arg1 MEM_STAT_DECL)\n   read_only = 1;\n   side_effects = TREE_SIDE_EFFECTS (t);\n \n-  PROCESS_ARG(0);\n-  PROCESS_ARG(1);\n+  PROCESS_ARG (0);\n+  PROCESS_ARG (1);\n \n   TREE_READONLY (t) = read_only;\n   TREE_CONSTANT (t) = constant;\n@@ -4158,9 +4158,9 @@ build3_stat (enum tree_code code, tree tt, tree arg0, tree arg1,\n   else\n     side_effects = TREE_SIDE_EFFECTS (t);\n \n-  PROCESS_ARG(0);\n-  PROCESS_ARG(1);\n-  PROCESS_ARG(2);\n+  PROCESS_ARG (0);\n+  PROCESS_ARG (1);\n+  PROCESS_ARG (2);\n \n   if (code == COND_EXPR)\n     TREE_READONLY (t) = read_only;\n@@ -4187,10 +4187,10 @@ build4_stat (enum tree_code code, tree tt, tree arg0, tree arg1,\n \n   side_effects = TREE_SIDE_EFFECTS (t);\n \n-  PROCESS_ARG(0);\n-  PROCESS_ARG(1);\n-  PROCESS_ARG(2);\n-  PROCESS_ARG(3);\n+  PROCESS_ARG (0);\n+  PROCESS_ARG (1);\n+  PROCESS_ARG (2);\n+  PROCESS_ARG (3);\n \n   TREE_SIDE_EFFECTS (t) = side_effects;\n   TREE_THIS_VOLATILE (t)\n@@ -4214,11 +4214,11 @@ build5_stat (enum tree_code code, tree tt, tree arg0, tree arg1,\n \n   side_effects = TREE_SIDE_EFFECTS (t);\n \n-  PROCESS_ARG(0);\n-  PROCESS_ARG(1);\n-  PROCESS_ARG(2);\n-  PROCESS_ARG(3);\n-  PROCESS_ARG(4);\n+  PROCESS_ARG (0);\n+  PROCESS_ARG (1);\n+  PROCESS_ARG (2);\n+  PROCESS_ARG (3);\n+  PROCESS_ARG (4);\n \n   TREE_SIDE_EFFECTS (t) = side_effects;\n   TREE_THIS_VOLATILE (t)\n@@ -5515,8 +5515,8 @@ const pass_data pass_data_ipa_free_lang_data =\n class pass_ipa_free_lang_data : public simple_ipa_opt_pass\n {\n public:\n-  pass_ipa_free_lang_data(gcc::context *ctxt)\n-    : simple_ipa_opt_pass(pass_data_ipa_free_lang_data, ctxt)\n+  pass_ipa_free_lang_data (gcc::context *ctxt)\n+    : simple_ipa_opt_pass (pass_data_ipa_free_lang_data, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -6680,9 +6680,11 @@ attribute_list_contained (const_tree l1, const_tree l2)\n       /* This CONST_CAST is okay because lookup_attribute does not\n \t modify its argument and the return value is assigned to a\n \t const_tree.  */\n-      for (attr = lookup_ident_attribute (get_attribute_name (t2), CONST_CAST_TREE(l1));\n+      for (attr = lookup_ident_attribute (get_attribute_name (t2),\n+\t\t\t\t\t  CONST_CAST_TREE (l1));\n \t   attr != NULL_TREE && !attribute_value_equal (t2, attr);\n-\t   attr = lookup_ident_attribute (get_attribute_name (t2), TREE_CHAIN (attr)))\n+\t   attr = lookup_ident_attribute (get_attribute_name (t2),\n+\t\t\t\t\t  TREE_CHAIN (attr)))\n \t;\n \n       if (attr == NULL_TREE)\n@@ -7801,9 +7803,9 @@ strip_array_types (tree type)\n    true) or would not differ from ARGTYPES.  */\n \n static tree\n-maybe_canonicalize_argtypes(tree argtypes,\n-\t\t\t    bool *any_structural_p,\n-\t\t\t    bool *any_noncanonical_p)\n+maybe_canonicalize_argtypes (tree argtypes,\n+\t\t\t     bool *any_structural_p,\n+\t\t\t     bool *any_noncanonical_p)\n {\n   tree arg;\n   bool any_noncanonical_argtypes_p = false;\n@@ -9342,7 +9344,7 @@ tree_contains_struct_check_failed (const_tree node,\n {\n   internal_error\n     (\"tree check: expected tree that contains %qs structure, have %qs in %s, at %s:%d\",\n-     TS_ENUM_NAME(en),\n+     TS_ENUM_NAME (en),\n      tree_code_name[TREE_CODE (node)], function, trim_filename (file), line);\n }\n \n@@ -10998,7 +11000,8 @@ walk_tree_1 (tree *tp, walk_tree_fn func, void *data,\n \tunsigned HOST_WIDE_INT idx;\n \tconstructor_elt *ce;\n \n-\tfor (idx = 0; vec_safe_iterate(CONSTRUCTOR_ELTS (*tp), idx, &ce); idx++)\n+\tfor (idx = 0; vec_safe_iterate (CONSTRUCTOR_ELTS (*tp), idx, &ce);\n+\t     idx++)\n \t  WALK_SUBTREE (ce->value);\n       }\n       break;\n@@ -11304,7 +11307,7 @@ stdarg_p (const_tree fntype)\n   if (!fntype)\n     return false;\n \n-  FOREACH_FUNCTION_ARGS(fntype, t, args_iter)\n+  FOREACH_FUNCTION_ARGS (fntype, t, args_iter)\n     {\n       n = t;\n     }"}, {"sha": "4cd7e9e9f65203e226b93abf8c1ecc7e0df87e1f", "filename": "gcc/tree.h", "status": "modified", "additions": 44, "deletions": 43, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -577,17 +577,17 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n    exit of a function.  Calls for which this is true are candidates for tail\n    call optimizations.  */\n #define CALL_EXPR_TAILCALL(NODE) \\\n-  (CALL_EXPR_CHECK(NODE)->base.addressable_flag)\n+  (CALL_EXPR_CHECK (NODE)->base.addressable_flag)\n \n /* Used as a temporary field on a CASE_LABEL_EXPR to indicate that the\n    CASE_LOW operand has been processed.  */\n #define CASE_LOW_SEEN(NODE) \\\n   (CASE_LABEL_EXPR_CHECK (NODE)->base.addressable_flag)\n \n #define PREDICT_EXPR_OUTCOME(NODE) \\\n-  ((enum prediction) (PREDICT_EXPR_CHECK(NODE)->base.addressable_flag))\n+  ((enum prediction) (PREDICT_EXPR_CHECK (NODE)->base.addressable_flag))\n #define SET_PREDICT_EXPR_OUTCOME(NODE, OUTCOME) \\\n-  (PREDICT_EXPR_CHECK(NODE)->base.addressable_flag = (int) OUTCOME)\n+  (PREDICT_EXPR_CHECK (NODE)->base.addressable_flag = (int) OUTCOME)\n #define PREDICT_EXPR_PREDICTOR(NODE) \\\n   ((enum br_predictor)tree_low_cst (TREE_OPERAND (PREDICT_EXPR_CHECK (NODE), 0), 0))\n \n@@ -659,7 +659,7 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n \n /* In a _TYPE, indicates whether TYPE_CACHED_VALUES contains a vector\n    of cached values, or is something else.  */\n-#define TYPE_CACHED_VALUES_P(NODE) (TYPE_CHECK(NODE)->base.public_flag)\n+#define TYPE_CACHED_VALUES_P(NODE) (TYPE_CHECK (NODE)->base.public_flag)\n \n /* In a SAVE_EXPR, indicates that the original expression has already\n    been substituted with a VAR_DECL that contains the value.  */\n@@ -669,7 +669,7 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n /* Set on a CALL_EXPR if this stdarg call should be passed the argument\n    pack.  */\n #define CALL_EXPR_VA_ARG_PACK(NODE) \\\n-  (CALL_EXPR_CHECK(NODE)->base.public_flag)\n+  (CALL_EXPR_CHECK (NODE)->base.public_flag)\n \n /* In any expression, decl, or constant, nonzero means it has side effects or\n    reevaluation of the whole expression could produce a different value.\n@@ -848,19 +848,19 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n \n /* These flags are available for each language front end to use internally.  */\n #define TREE_LANG_FLAG_0(NODE) \\\n-  (TREE_NOT_CHECK2(NODE, TREE_VEC, SSA_NAME)->base.u.bits.lang_flag_0)\n+  (TREE_NOT_CHECK2 (NODE, TREE_VEC, SSA_NAME)->base.u.bits.lang_flag_0)\n #define TREE_LANG_FLAG_1(NODE) \\\n-  (TREE_NOT_CHECK2(NODE, TREE_VEC, SSA_NAME)->base.u.bits.lang_flag_1)\n+  (TREE_NOT_CHECK2 (NODE, TREE_VEC, SSA_NAME)->base.u.bits.lang_flag_1)\n #define TREE_LANG_FLAG_2(NODE) \\\n-  (TREE_NOT_CHECK2(NODE, TREE_VEC, SSA_NAME)->base.u.bits.lang_flag_2)\n+  (TREE_NOT_CHECK2 (NODE, TREE_VEC, SSA_NAME)->base.u.bits.lang_flag_2)\n #define TREE_LANG_FLAG_3(NODE) \\\n-  (TREE_NOT_CHECK2(NODE, TREE_VEC, SSA_NAME)->base.u.bits.lang_flag_3)\n+  (TREE_NOT_CHECK2 (NODE, TREE_VEC, SSA_NAME)->base.u.bits.lang_flag_3)\n #define TREE_LANG_FLAG_4(NODE) \\\n-  (TREE_NOT_CHECK2(NODE, TREE_VEC, SSA_NAME)->base.u.bits.lang_flag_4)\n+  (TREE_NOT_CHECK2 (NODE, TREE_VEC, SSA_NAME)->base.u.bits.lang_flag_4)\n #define TREE_LANG_FLAG_5(NODE) \\\n-  (TREE_NOT_CHECK2(NODE, TREE_VEC, SSA_NAME)->base.u.bits.lang_flag_5)\n+  (TREE_NOT_CHECK2 (NODE, TREE_VEC, SSA_NAME)->base.u.bits.lang_flag_5)\n #define TREE_LANG_FLAG_6(NODE) \\\n-  (TREE_NOT_CHECK2(NODE, TREE_VEC, SSA_NAME)->base.u.bits.lang_flag_6)\n+  (TREE_NOT_CHECK2 (NODE, TREE_VEC, SSA_NAME)->base.u.bits.lang_flag_6)\n \f\n /* Define additional fields and accessors for nodes representing constants.  */\n \n@@ -1131,7 +1131,7 @@ extern void protected_set_expr_location (tree, location_t);\n #define CALL_EXPR_FN(NODE) TREE_OPERAND (CALL_EXPR_CHECK (NODE), 1)\n #define CALL_EXPR_STATIC_CHAIN(NODE) TREE_OPERAND (CALL_EXPR_CHECK (NODE), 2)\n #define CALL_EXPR_ARG(NODE, I) TREE_OPERAND (CALL_EXPR_CHECK (NODE), (I) + 3)\n-#define call_expr_nargs(NODE) (VL_EXP_OPERAND_LENGTH(NODE) - 3)\n+#define call_expr_nargs(NODE) (VL_EXP_OPERAND_LENGTH (NODE) - 3)\n \n /* CALL_EXPR_ARGP returns a pointer to the argument vector for NODE.\n    We can't use &CALL_EXPR_ARG (NODE, 0) because that will complain if\n@@ -1654,10 +1654,10 @@ extern enum machine_mode vector_type_mode (const_tree);\n #define TYPE_DOMAIN(NODE) (ARRAY_TYPE_CHECK (NODE)->type_non_common.values)\n #define TYPE_FIELDS(NODE) \\\n   (RECORD_OR_UNION_CHECK (NODE)->type_non_common.values)\n-#define TYPE_CACHED_VALUES(NODE) (TYPE_CHECK(NODE)->type_non_common.values)\n+#define TYPE_CACHED_VALUES(NODE) (TYPE_CHECK (NODE)->type_non_common.values)\n #define TYPE_ARG_TYPES(NODE) \\\n   (FUNC_OR_METHOD_CHECK (NODE)->type_non_common.values)\n-#define TYPE_VALUES_RAW(NODE) (TYPE_CHECK(NODE)->type_non_common.values)\n+#define TYPE_VALUES_RAW(NODE) (TYPE_CHECK (NODE)->type_non_common.values)\n \n #define TYPE_METHODS(NODE) \\\n   (RECORD_OR_UNION_CHECK (NODE)->type_non_common.maxval)\n@@ -1686,11 +1686,11 @@ extern enum machine_mode vector_type_mode (const_tree);\n \n /* For record and union types, information about this type, as a base type\n    for itself.  */\n-#define TYPE_BINFO(NODE) (RECORD_OR_UNION_CHECK(NODE)->type_non_common.binfo)\n+#define TYPE_BINFO(NODE) (RECORD_OR_UNION_CHECK (NODE)->type_non_common.binfo)\n \n /* For non record and union types, used in a language-dependent way.  */\n #define TYPE_LANG_SLOT_1(NODE) \\\n-  (NOT_RECORD_OR_UNION_CHECK(NODE)->type_non_common.binfo)\n+  (NOT_RECORD_OR_UNION_CHECK (NODE)->type_non_common.binfo)\n \n /* Define accessor macros for information about type inheritance\n    and basetypes.\n@@ -1713,44 +1713,44 @@ extern enum machine_mode vector_type_mode (const_tree);\n #define BINFO_VIRTUAL_P(NODE) (TREE_BINFO_CHECK (NODE)->base.static_flag)\n \n /* Flags for language dependent use.  */\n-#define BINFO_MARKED(NODE) TREE_LANG_FLAG_0(TREE_BINFO_CHECK(NODE))\n-#define BINFO_FLAG_1(NODE) TREE_LANG_FLAG_1(TREE_BINFO_CHECK(NODE))\n-#define BINFO_FLAG_2(NODE) TREE_LANG_FLAG_2(TREE_BINFO_CHECK(NODE))\n-#define BINFO_FLAG_3(NODE) TREE_LANG_FLAG_3(TREE_BINFO_CHECK(NODE))\n-#define BINFO_FLAG_4(NODE) TREE_LANG_FLAG_4(TREE_BINFO_CHECK(NODE))\n-#define BINFO_FLAG_5(NODE) TREE_LANG_FLAG_5(TREE_BINFO_CHECK(NODE))\n-#define BINFO_FLAG_6(NODE) TREE_LANG_FLAG_6(TREE_BINFO_CHECK(NODE))\n+#define BINFO_MARKED(NODE) TREE_LANG_FLAG_0 (TREE_BINFO_CHECK (NODE))\n+#define BINFO_FLAG_1(NODE) TREE_LANG_FLAG_1 (TREE_BINFO_CHECK (NODE))\n+#define BINFO_FLAG_2(NODE) TREE_LANG_FLAG_2 (TREE_BINFO_CHECK (NODE))\n+#define BINFO_FLAG_3(NODE) TREE_LANG_FLAG_3 (TREE_BINFO_CHECK (NODE))\n+#define BINFO_FLAG_4(NODE) TREE_LANG_FLAG_4 (TREE_BINFO_CHECK (NODE))\n+#define BINFO_FLAG_5(NODE) TREE_LANG_FLAG_5 (TREE_BINFO_CHECK (NODE))\n+#define BINFO_FLAG_6(NODE) TREE_LANG_FLAG_6 (TREE_BINFO_CHECK (NODE))\n \n /* The actual data type node being inherited in this basetype.  */\n-#define BINFO_TYPE(NODE) TREE_TYPE (TREE_BINFO_CHECK(NODE))\n+#define BINFO_TYPE(NODE) TREE_TYPE (TREE_BINFO_CHECK (NODE))\n \n /* The offset where this basetype appears in its containing type.\n    BINFO_OFFSET slot holds the offset (in bytes)\n    from the base of the complete object to the base of the part of the\n    object that is allocated on behalf of this `type'.\n    This is always 0 except when there is multiple inheritance.  */\n \n-#define BINFO_OFFSET(NODE) (TREE_BINFO_CHECK(NODE)->binfo.offset)\n+#define BINFO_OFFSET(NODE) (TREE_BINFO_CHECK (NODE)->binfo.offset)\n #define BINFO_OFFSET_ZEROP(NODE) (integer_zerop (BINFO_OFFSET (NODE)))\n \n /* The virtual function table belonging to this basetype.  Virtual\n    function tables provide a mechanism for run-time method dispatching.\n    The entries of a virtual function table are language-dependent.  */\n \n-#define BINFO_VTABLE(NODE) (TREE_BINFO_CHECK(NODE)->binfo.vtable)\n+#define BINFO_VTABLE(NODE) (TREE_BINFO_CHECK (NODE)->binfo.vtable)\n \n /* The virtual functions in the virtual function table.  This is\n    a TREE_LIST that is used as an initial approximation for building\n    a virtual function table for this basetype.  */\n-#define BINFO_VIRTUALS(NODE) (TREE_BINFO_CHECK(NODE)->binfo.virtuals)\n+#define BINFO_VIRTUALS(NODE) (TREE_BINFO_CHECK (NODE)->binfo.virtuals)\n \n /* A vector of binfos for the direct basetypes inherited by this\n    basetype.\n \n    If this basetype describes type D as inherited in C, and if the\n    basetypes of D are E and F, then this vector contains binfos for\n    inheritance of E and F by C.  */\n-#define BINFO_BASE_BINFOS(NODE) (&TREE_BINFO_CHECK(NODE)->binfo.base_binfos)\n+#define BINFO_BASE_BINFOS(NODE) (&TREE_BINFO_CHECK (NODE)->binfo.base_binfos)\n \n /* The number of basetypes for NODE.  */\n #define BINFO_N_BASE_BINFOS(NODE) (BINFO_BASE_BINFOS (NODE)->length ())\n@@ -1768,12 +1768,13 @@ extern enum machine_mode vector_type_mode (const_tree);\n    base.  The actual contents are language-dependent.  In the C++\n    front-end this field is an INTEGER_CST giving an offset into the\n    vtable where the offset to the virtual base can be found.  */\n-#define BINFO_VPTR_FIELD(NODE) (TREE_BINFO_CHECK(NODE)->binfo.vptr_field)\n+#define BINFO_VPTR_FIELD(NODE) (TREE_BINFO_CHECK (NODE)->binfo.vptr_field)\n \n /* Indicates the accesses this binfo has to its bases. The values are\n    access_public_node, access_protected_node or access_private_node.\n    If this array is not present, public access is implied.  */\n-#define BINFO_BASE_ACCESSES(NODE) (TREE_BINFO_CHECK(NODE)->binfo.base_accesses)\n+#define BINFO_BASE_ACCESSES(NODE) \\\n+  (TREE_BINFO_CHECK (NODE)->binfo.base_accesses)\n \n #define BINFO_BASE_ACCESS(NODE,N) \\\n   (*BINFO_BASE_ACCESSES (NODE))[(N)]\n@@ -1782,18 +1783,18 @@ extern enum machine_mode vector_type_mode (const_tree);\n \n /* The index in the VTT where this subobject's sub-VTT can be found.\n    NULL_TREE if there is no sub-VTT.  */\n-#define BINFO_SUBVTT_INDEX(NODE) (TREE_BINFO_CHECK(NODE)->binfo.vtt_subvtt)\n+#define BINFO_SUBVTT_INDEX(NODE) (TREE_BINFO_CHECK (NODE)->binfo.vtt_subvtt)\n \n /* The index in the VTT where the vptr for this subobject can be\n    found.  NULL_TREE if there is no secondary vptr in the VTT.  */\n-#define BINFO_VPTR_INDEX(NODE) (TREE_BINFO_CHECK(NODE)->binfo.vtt_vptr)\n+#define BINFO_VPTR_INDEX(NODE) (TREE_BINFO_CHECK (NODE)->binfo.vtt_vptr)\n \n /* The BINFO_INHERITANCE_CHAIN points at the binfo for the base\n    inheriting this base for non-virtual bases. For virtual bases it\n    points either to the binfo for which this is a primary binfo, or to\n    the binfo of the most derived type.  */\n #define BINFO_INHERITANCE_CHAIN(NODE) \\\n-\t(TREE_BINFO_CHECK(NODE)->binfo.inheritance)\n+\t(TREE_BINFO_CHECK (NODE)->binfo.inheritance)\n \n \n /* Define fields and accessors for nodes representing declared names.  */\n@@ -2718,7 +2719,7 @@ inline tree\n contains_struct_check (tree __t, const enum tree_node_structure_enum __s,\n                        const char *__f, int __l, const char *__g)\n {\n-  if (tree_contains_struct[TREE_CODE(__t)][__s] != 1)\n+  if (tree_contains_struct[TREE_CODE (__t)][__s] != 1)\n       tree_contains_struct_check_failed (__t, __s, __f, __l, __g);\n   return __t;\n }\n@@ -2727,7 +2728,7 @@ inline tree\n tree_class_check (tree __t, const enum tree_code_class __class,\n                   const char *__f, int __l, const char *__g)\n {\n-  if (TREE_CODE_CLASS (TREE_CODE(__t)) != __class)\n+  if (TREE_CODE_CLASS (TREE_CODE (__t)) != __class)\n     tree_class_check_failed (__t, __class, __f, __l, __g);\n   return __t;\n }\n@@ -2928,7 +2929,7 @@ inline const_tree\n contains_struct_check (const_tree __t, const enum tree_node_structure_enum __s,\n                        const char *__f, int __l, const char *__g)\n {\n-  if (tree_contains_struct[TREE_CODE(__t)][__s] != 1)\n+  if (tree_contains_struct[TREE_CODE (__t)][__s] != 1)\n       tree_contains_struct_check_failed (__t, __s, __f, __l, __g);\n   return __t;\n }\n@@ -2937,7 +2938,7 @@ inline const_tree\n tree_class_check (const_tree __t, const enum tree_code_class __class,\n                   const char *__f, int __l, const char *__g)\n {\n-  if (TREE_CODE_CLASS (TREE_CODE(__t)) != __class)\n+  if (TREE_CODE_CLASS (TREE_CODE (__t)) != __class)\n     tree_class_check_failed (__t, __class, __f, __l, __g);\n   return __t;\n }\n@@ -3476,21 +3477,21 @@ extern tree build_all_ones_cst (tree);\n extern tree build_zero_cst (tree);\n extern tree build_string (int, const char *);\n extern tree build_tree_list_stat (tree, tree MEM_STAT_DECL);\n-#define build_tree_list(t,q) build_tree_list_stat(t,q MEM_STAT_INFO)\n+#define build_tree_list(t, q) build_tree_list_stat (t, q MEM_STAT_INFO)\n extern tree build_tree_list_vec_stat (const vec<tree, va_gc> *MEM_STAT_DECL);\n #define build_tree_list_vec(v) build_tree_list_vec_stat (v MEM_STAT_INFO)\n extern tree build_decl_stat (location_t, enum tree_code,\n \t\t\t     tree, tree MEM_STAT_DECL);\n extern tree build_fn_decl (const char *, tree);\n-#define build_decl(l,c,t,q) build_decl_stat (l,c,t,q MEM_STAT_INFO)\n+#define build_decl(l,c,t,q) build_decl_stat (l, c, t, q MEM_STAT_INFO)\n extern tree build_translation_unit_decl (tree);\n extern tree build_block (tree, tree, tree, tree);\n extern tree build_empty_stmt (location_t);\n extern tree build_omp_clause (location_t, enum omp_clause_code);\n extern tree find_omp_clause (tree, enum omp_clause_code);\n \n extern tree build_vl_exp_stat (enum tree_code, int MEM_STAT_DECL);\n-#define build_vl_exp(c,n) build_vl_exp_stat (c,n MEM_STAT_INFO)\n+#define build_vl_exp(c, n) build_vl_exp_stat (c, n MEM_STAT_INFO)\n \n extern tree build_call_nary (tree, tree, int, ...);\n extern tree build_call_valist (tree, tree, int, va_list);\n@@ -4301,7 +4302,7 @@ extern tree fold_build_call_array_loc (location_t, tree, tree, int, tree *);\n extern tree fold_build_call_array_initializer_loc (location_t, tree, tree, int, tree *);\n extern bool fold_convertible_p (const_tree, const_tree);\n #define fold_convert(T1,T2)\\\n-   fold_convert_loc(UNKNOWN_LOCATION, T1, T2)\n+   fold_convert_loc (UNKNOWN_LOCATION, T1, T2)\n extern tree fold_convert_loc (location_t, tree, tree);\n extern tree fold_single_bit_test (location_t, enum tree_code, tree, tree, tree);\n extern tree fold_ignored_result (tree);\n@@ -4321,7 +4322,7 @@ extern tree omit_one_operand_loc (location_t, tree, tree, tree);\n    omit_two_operands_loc (UNKNOWN_LOCATION, T1, T2, T3, T4)\n extern tree omit_two_operands_loc (location_t, tree, tree, tree, tree);\n #define invert_truthvalue(T)\\\n-   invert_truthvalue_loc(UNKNOWN_LOCATION, T)\n+   invert_truthvalue_loc (UNKNOWN_LOCATION, T)\n extern tree invert_truthvalue_loc (location_t, tree);\n extern tree fold_unary_to_constant (enum tree_code, tree, tree);\n extern tree fold_binary_to_constant (enum tree_code, tree, tree, tree);"}, {"sha": "363f16085135ef1089598b4b71dd6849e58a5ecb", "filename": "gcc/tsan.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftsan.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -753,8 +753,8 @@ const pass_data pass_data_tsan =\n class pass_tsan : public gimple_opt_pass\n {\n public:\n-  pass_tsan(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_tsan, ctxt)\n+  pass_tsan (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_tsan, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -798,8 +798,8 @@ const pass_data pass_data_tsan_O0 =\n class pass_tsan_O0 : public gimple_opt_pass\n {\n public:\n-  pass_tsan_O0(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_tsan_O0, ctxt)\n+  pass_tsan_O0 (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_tsan_O0, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "bc628a076d80a3109d75f170c2ad1ca0ca3cdc13", "filename": "gcc/tsystem.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Ftsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftsystem.h?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -129,7 +129,7 @@ extern int errno;\n #define gcc_unreachable() (abort ())\n \n #define CONST_CAST2(TOTYPE,FROMTYPE,X) ((__extension__(union {FROMTYPE _q; TOTYPE _nq;})(X))._nq)\n-#define CONST_CAST(TYPE,X) CONST_CAST2(TYPE, const TYPE, (X))\n+#define CONST_CAST(TYPE,X) CONST_CAST2 (TYPE, const TYPE, (X))\n \n /* Filename handling macros.  */\n #include \"filenames.h\""}, {"sha": "597e9c0f5c0367b1fc2c2503490f8cb58ed64dcb", "filename": "gcc/value-prof.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -249,7 +249,7 @@ dump_histogram_value (FILE *dump_file, histogram_value hist)\n       if (hist->hvalue.counters)\n \t{\n \t   unsigned int i;\n-\t   fprintf(dump_file, \" [\");\n+\t   fprintf (dump_file, \" [\");\n            for (i = 0; i < hist->hdata.intvl.steps; i++)\n \t     fprintf (dump_file, \" %d:\"HOST_WIDEST_INT_PRINT_DEC,\n \t\t      hist->hdata.intvl.int_start + i,\n@@ -1568,7 +1568,7 @@ gimple_stringop_fixed_value (gimple vcall_stmt, tree icall_size, int prob,\n \n   fndecl = gimple_call_fndecl (vcall_stmt);\n   if (!interesting_stringop_to_profile_p (fndecl, vcall_stmt, &size_arg))\n-    gcc_unreachable();\n+    gcc_unreachable ();\n \n   cond_bb = gimple_bb (vcall_stmt);\n   gsi = gsi_for_stmt (vcall_stmt);"}, {"sha": "24c61ccd2a2c111b61cfe1a72047bc867adadd16", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -2877,7 +2877,7 @@ variable_union (variable src, dataflow_set *set)\n \t      /* The most common case, much simpler, no qsort is needed.  */\n \t      location_chain dstnode = dst->var_part[j].loc_chain;\n \t      dst->var_part[k].loc_chain = dstnode;\n-\t      VAR_PART_OFFSET (dst, k) = VAR_PART_OFFSET(dst, j);\n+\t      VAR_PART_OFFSET (dst, k) = VAR_PART_OFFSET (dst, j);\n \t      node2 = dstnode;\n \t      for (node = src->var_part[i].loc_chain; node; node = node->next)\n \t\tif (!((REG_P (dstnode->loc)\n@@ -10256,8 +10256,8 @@ const pass_data pass_data_variable_tracking =\n class pass_variable_tracking : public rtl_opt_pass\n {\n public:\n-  pass_variable_tracking(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_variable_tracking, ctxt)\n+  pass_variable_tracking (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_variable_tracking, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "12fb7c46b33c23debf0472f3ed78690065a873ab", "filename": "gcc/varasm.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -3085,7 +3085,7 @@ compare_constant (const tree t1, const tree t2)\n     case MINUS_EXPR:\n     case RANGE_EXPR:\n       return (compare_constant (TREE_OPERAND (t1, 0), TREE_OPERAND (t2, 0))\n-\t      && compare_constant(TREE_OPERAND (t1, 1), TREE_OPERAND (t2, 1)));\n+\t      && compare_constant (TREE_OPERAND (t1, 1), TREE_OPERAND (t2, 1)));\n \n     CASE_CONVERT:\n     case VIEW_CONVERT_EXPR:\n@@ -5546,9 +5546,9 @@ void\n do_assemble_alias (tree decl, tree target)\n {\n   /* Emulated TLS had better not get this var.  */\n-  gcc_assert(!(!targetm.have_tls\n-\t       && TREE_CODE (decl) == VAR_DECL\n-\t       && DECL_THREAD_LOCAL_P (decl)));\n+  gcc_assert (!(!targetm.have_tls\n+\t\t&& TREE_CODE (decl) == VAR_DECL\n+\t\t&& DECL_THREAD_LOCAL_P (decl)));\n \n   if (TREE_ASM_WRITTEN (decl))\n     return;"}, {"sha": "a75d3bfc7659098a7992106df22d8d961ba68a99", "filename": "gcc/vec.h", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fvec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fvec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.h?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -719,7 +719,7 @@ vec_safe_grow_cleared (vec<T, A, vl_embed> *&v, unsigned len CXX_MEM_STAT_INFO)\n {\n   unsigned oldlen = vec_safe_length (v);\n   vec_safe_grow (v, len PASS_MEM_STAT);\n-  memset (&(v->address()[oldlen]), 0, sizeof (T) * (len - oldlen));\n+  memset (&(v->address ()[oldlen]), 0, sizeof (T) * (len - oldlen));\n }\n \n \n@@ -858,7 +858,7 @@ vec<T, A, vl_embed>::space (unsigned nelems) const\n    element of this vector.  Use this to iterate over the elements of a\n    vector as follows,\n \n-     for (ix = 0; vec<T, A>::iterate(v, ix, &ptr); ix++)\n+     for (ix = 0; vec<T, A>::iterate (v, ix, &ptr); ix++)\n        continue;  */\n \n template<typename T, typename A>\n@@ -882,7 +882,7 @@ vec<T, A, vl_embed>::iterate (unsigned ix, T *ptr) const\n    IX'th element of this vector.  Use this to iterate over the\n    elements of a vector as follows,\n \n-     for (ix = 0; v->iterate(ix, &ptr); ix++)\n+     for (ix = 0; v->iterate (ix, &ptr); ix++)\n        continue;\n \n    This variant is for vectors of objects.  */\n@@ -916,7 +916,7 @@ vec<T, A, vl_embed>::copy (ALONE_MEM_STAT_DECL) const\n     {\n       vec_alloc (new_vec, len PASS_MEM_STAT);\n       new_vec->embedded_init (len, len);\n-      memcpy (new_vec->address(), vecdata_, sizeof (T) * len);\n+      memcpy (new_vec->address (), vecdata_, sizeof (T) * len);\n     }\n   return new_vec;\n }\n@@ -929,11 +929,11 @@ template<typename T, typename A>\n inline void\n vec<T, A, vl_embed>::splice (vec<T, A, vl_embed> &src)\n {\n-  unsigned len = src.length();\n+  unsigned len = src.length ();\n   if (len)\n     {\n       gcc_checking_assert (space (len));\n-      memcpy (address() + length(), src.address(), len * sizeof (T));\n+      memcpy (address () + length (), src.address (), len * sizeof (T));\n       vecpfx_.num_ += len;\n     }\n }\n@@ -1008,7 +1008,7 @@ template<typename T, typename A>\n inline void\n vec<T, A, vl_embed>::ordered_remove (unsigned ix)\n {\n-  gcc_checking_assert (ix < length());\n+  gcc_checking_assert (ix < length ());\n   T *slot = &vecdata_[ix];\n   memmove (slot, slot + 1, (--vecpfx_.num_ - ix) * sizeof (T));\n }\n@@ -1021,7 +1021,7 @@ template<typename T, typename A>\n inline void\n vec<T, A, vl_embed>::unordered_remove (unsigned ix)\n {\n-  gcc_checking_assert (ix < length());\n+  gcc_checking_assert (ix < length ());\n   vecdata_[ix] = vecdata_[--vecpfx_.num_];\n }\n \n@@ -1033,7 +1033,7 @@ template<typename T, typename A>\n inline void\n vec<T, A, vl_embed>::block_remove (unsigned ix, unsigned len)\n {\n-  gcc_checking_assert (ix + len <= length());\n+  gcc_checking_assert (ix + len <= length ());\n   T *slot = &vecdata_[ix];\n   vecpfx_.num_ -= len;\n   memmove (slot, slot + len, (vecpfx_.num_ - ix) * sizeof (T));\n@@ -1047,7 +1047,7 @@ template<typename T, typename A>\n inline void\n vec<T, A, vl_embed>::qsort (int (*cmp) (const void *, const void *))\n {\n-  ::qsort (address(), length(), sizeof (T), cmp);\n+  ::qsort (address (), length (), sizeof (T), cmp);\n }\n \n \n@@ -1091,7 +1091,7 @@ vec<T, A, vl_embed>::lower_bound (T obj, bool (*lessthan)(const T &, const T &))\n    final member):\n \n    size_t vec<T, A, vl_embed>::embedded_size (unsigned alloc);\n-   void v->embedded_init(unsigned alloc, unsigned num);\n+   void v->embedded_init (unsigned alloc, unsigned num);\n \n    These allow the caller to perform the memory allocation.  */\n \n@@ -1137,7 +1137,7 @@ vec<T, A, vl_embed>::quick_grow_cleared (unsigned len)\n {\n   unsigned oldlen = length ();\n   quick_grow (len);\n-  memset (&(address()[oldlen]), 0, sizeof (T) * (len - oldlen));\n+  memset (&(address ()[oldlen]), 0, sizeof (T) * (len - oldlen));\n }\n \n \n@@ -1232,10 +1232,10 @@ struct vec<T, A, vl_ptr>\n   { return vec_ != NULL; }\n \n   bool is_empty (void) const\n-  { return vec_ ? vec_->is_empty() : true; }\n+  { return vec_ ? vec_->is_empty () : true; }\n \n   unsigned length (void) const\n-  { return vec_ ? vec_->length() : 0; }\n+  { return vec_ ? vec_->length () : 0; }\n \n   T *address (void)\n   { return vec_ ? vec_->vecdata_ : NULL; }\n@@ -1250,13 +1250,13 @@ struct vec<T, A, vl_ptr>\n   { return !(*this == other); }\n \n   bool operator==(const vec &other) const\n-  { return address() == other.address(); }\n+  { return address () == other.address (); }\n \n   T &operator[] (unsigned ix)\n   { return (*vec_)[ix]; }\n \n   T &last (void)\n-  { return vec_->last(); }\n+  { return vec_->last (); }\n \n   bool space (int nelems) const\n   { return vec_ ? vec_->space (nelems) : nelems == 0; }\n@@ -1285,8 +1285,8 @@ struct vec<T, A, vl_ptr>\n   unsigned lower_bound (T, bool (*)(const T &, const T &)) const;\n \n   template<typename T1>\n-  friend void va_stack::alloc(vec<T1, va_stack, vl_ptr>&, unsigned,\n-\t\t\t      vec<T1, va_stack, vl_embed> *);\n+  friend void va_stack::alloc (vec<T1, va_stack, vl_ptr>&, unsigned,\n+\t\t\t       vec<T1, va_stack, vl_embed> *);\n \n   /* FIXME - This field should be private, but we need to cater to\n \t     compilers that have stricter notions of PODness for types.  */\n@@ -1386,7 +1386,7 @@ vec_free (vec<T> *&v)\n    element of this vector.  Use this to iterate over the elements of a\n    vector as follows,\n \n-     for (ix = 0; v.iterate(ix, &ptr); ix++)\n+     for (ix = 0; v.iterate (ix, &ptr); ix++)\n        continue;  */\n \n template<typename T, typename A>\n@@ -1407,7 +1407,7 @@ vec<T, A, vl_ptr>::iterate (unsigned ix, T *ptr) const\n    IX'th element of this vector.  Use this to iterate over the\n    elements of a vector as follows,\n \n-     for (ix = 0; v->iterate(ix, &ptr); ix++)\n+     for (ix = 0; v->iterate (ix, &ptr); ix++)\n        continue;\n \n    This variant is for vectors of objects.  */\n@@ -1544,9 +1544,9 @@ template<typename T, typename A>\n inline void\n vec<T, A, vl_ptr>::safe_splice (vec<T, A, vl_ptr> &src MEM_STAT_DECL)\n {\n-  if (src.length())\n+  if (src.length ())\n     {\n-      reserve_exact (src.length());\n+      reserve_exact (src.length ());\n       splice (src);\n     }\n }\n@@ -1626,7 +1626,7 @@ vec<T, A, vl_ptr>::safe_grow_cleared (unsigned len MEM_STAT_DECL)\n {\n   unsigned oldlen = length ();\n   safe_grow (len PASS_MEM_STAT);\n-  memset (&(address()[oldlen]), 0, sizeof (T) * (len - oldlen));\n+  memset (&(address ()[oldlen]), 0, sizeof (T) * (len - oldlen));\n }\n \n "}, {"sha": "9f308a6fdf2ee0970be9a68cd95fe77aadaee509", "filename": "gcc/vmsdbgout.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fvmsdbgout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fvmsdbgout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvmsdbgout.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -221,9 +221,9 @@ const struct gcc_debug_hooks vmsdbg_debug_hooks\n \n #ifndef UNALIGNED_OFFSET_ASM_OP\n #define UNALIGNED_OFFSET_ASM_OP(OFFSET) \\\n-  (NUMBYTES(OFFSET) == 4 \\\n+  (NUMBYTES (OFFSET) == 4 \\\n    ? VMS_UNALIGNED_LONG_ASM_OP \\\n-   : (NUMBYTES(OFFSET) == 2 ? VMS_UNALIGNED_SHORT_ASM_OP : VMS_ASM_BYTE_OP))\n+   : (NUMBYTES (OFFSET) == 2 ? VMS_UNALIGNED_SHORT_ASM_OP : VMS_ASM_BYTE_OP))\n #endif\n \n /* Definitions of defaults for formats and names of various special\n@@ -329,7 +329,7 @@ static char text_end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n \n #ifndef ASM_OUTPUT_DEBUG_DATA\n #define ASM_OUTPUT_DEBUG_DATA(FILE,VALUE) \\\n-  fprintf ((FILE), \"\\t%s\\t%#lx\", UNALIGNED_OFFSET_ASM_OP(VALUE), VALUE)\n+  fprintf ((FILE), \"\\t%s\\t%#lx\", UNALIGNED_OFFSET_ASM_OP (VALUE), VALUE)\n #endif\n \n #ifndef ASM_OUTPUT_DEBUG_ADDR_DATA\n@@ -351,7 +351,7 @@ static char text_end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n #define ASM_OUTPUT_DEBUG_STRING(FILE,P)\t\t\\\n   do\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\\\n-      register int slen = strlen(P);\t\t\\\n+      register int slen = strlen (P);\t\t\\\n       register const char *p = (P);\t\t\\\n       register int i;\t\t\t\t\\\n       fprintf (FILE, \"\\t.ascii \\\"\");\t\t\\"}, {"sha": "d954d1f91e0608e7bde31e89ad6b938a3d9406cf", "filename": "gcc/vtable-verify.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fvtable-verify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fvtable-verify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvtable-verify.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -173,7 +173,7 @@ vtbl_map_node_registration_find (struct vtbl_map_node *node,\n   struct vtable_registration key;\n   struct vtable_registration **slot;\n \n-  gcc_assert (node && node->registered.is_created());\n+  gcc_assert (node && node->registered.is_created ());\n \n   key.vtable_decl = vtable_decl;\n   slot = (struct vtable_registration **) node->registered.find_slot (&key,\n@@ -182,7 +182,7 @@ vtbl_map_node_registration_find (struct vtbl_map_node *node,\n   if (slot && (*slot))\n     {\n       unsigned i;\n-      for (i = 0; i < ((*slot)->offsets).length(); ++i)\n+      for (i = 0; i < ((*slot)->offsets).length (); ++i)\n         if ((*slot)->offsets[i] == offset)\n           return true;\n     }\n@@ -203,7 +203,7 @@ vtbl_map_node_registration_insert (struct vtbl_map_node *node,\n   struct vtable_registration **slot;\n   bool inserted_something = false;\n \n-  if (!node || !node->registered.is_created())\n+  if (!node || !node->registered.is_created ())\n     return false;\n \n   key.vtable_decl = vtable_decl;\n@@ -227,7 +227,7 @@ vtbl_map_node_registration_insert (struct vtbl_map_node *node,\n          contains the offset.  If not, we need to add the offset.  */\n       unsigned i;\n       bool found = false;\n-      for (i = 0; i < ((*slot)->offsets).length() && !found; ++i)\n+      for (i = 0; i < ((*slot)->offsets).length () && !found; ++i)\n         if ((*slot)->offsets[i] == offset)\n           found = true;\n \n@@ -319,7 +319,7 @@ vtbl_map_get_node (tree class_type)\n   tree class_name;\n   unsigned int type_quals;\n \n-  if (!vtbl_map_hash.is_created())\n+  if (!vtbl_map_hash.is_created ())\n     return NULL;\n \n   gcc_assert (TREE_CODE (class_type) == RECORD_TYPE);\n@@ -356,7 +356,7 @@ find_or_create_vtbl_map_node (tree base_class_type)\n   tree class_type_decl;\n   unsigned int type_quals;\n \n-  if (!vtbl_map_hash.is_created())\n+  if (!vtbl_map_hash.is_created ())\n     vtbl_map_hash.create (10);\n \n   /* Find the TYPE_DECL for the class.  */\n@@ -772,8 +772,8 @@ const pass_data pass_data_vtable_verify =\n class pass_vtable_verify : public gimple_opt_pass\n {\n public:\n-  pass_vtable_verify(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_vtable_verify, ctxt)\n+  pass_vtable_verify (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_vtable_verify, ctxt)\n   {}\n \n   /* opt_pass methods: */"}, {"sha": "8e8c4658fd22663408af539c57abcc84153fdb4c", "filename": "gcc/web.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fweb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3284718808ca6da39d16507f5d29c34e2795cc7/gcc%2Fweb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fweb.c?ref=c3284718808ca6da39d16507f5d29c34e2795cc7", "patch": "@@ -374,7 +374,7 @@ web_main (void)\n     }\n \n   /* Record the number of uses and defs at the beginning of the optimization.  */\n-  def_entry = XCNEWVEC (struct web_entry, DF_DEFS_TABLE_SIZE());\n+  def_entry = XCNEWVEC (struct web_entry, DF_DEFS_TABLE_SIZE ());\n   used = XCNEWVEC (unsigned, max);\n   use_entry = XCNEWVEC (struct web_entry, uses_num);\n \n@@ -469,8 +469,8 @@ const pass_data pass_data_web =\n class pass_web : public rtl_opt_pass\n {\n public:\n-  pass_web(gcc::context *ctxt)\n-    : rtl_opt_pass(pass_data_web, ctxt)\n+  pass_web (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_web, ctxt)\n   {}\n \n   /* opt_pass methods: */"}]}