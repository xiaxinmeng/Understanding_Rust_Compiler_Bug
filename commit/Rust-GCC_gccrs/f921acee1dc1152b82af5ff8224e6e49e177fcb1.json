{"sha": "f921acee1dc1152b82af5ff8224e6e49e177fcb1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjkyMWFjZWUxZGMxMTUyYjgyYWY1ZmY4MjI0ZTZlNDllMTc3ZmNiMQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1999-03-16T19:34:49Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1999-03-16T19:34:49Z"}, "message": "method.c (old_backref_index): Split out...\n\n\t* method.c (old_backref_index): Split out...\n\t(flush_repeats): From here.  Rename back from try_old_backref.\n\t(build_mangled_name): Put back some old-style repeat handling.\n\nFrom-SVN: r25809", "tree": {"sha": "6f51d19f4751f298188eb094b3a072c0d98cb937", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f51d19f4751f298188eb094b3a072c0d98cb937"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f921acee1dc1152b82af5ff8224e6e49e177fcb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f921acee1dc1152b82af5ff8224e6e49e177fcb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f921acee1dc1152b82af5ff8224e6e49e177fcb1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f921acee1dc1152b82af5ff8224e6e49e177fcb1/comments", "author": null, "committer": null, "parents": [{"sha": "8fe57f78b614a55c9d29def19b7403f60d7c56a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fe57f78b614a55c9d29def19b7403f60d7c56a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8fe57f78b614a55c9d29def19b7403f60d7c56a9"}], "stats": {"total": 89, "additions": 67, "deletions": 22}, "files": [{"sha": "5c6eb36fac7f37edc369e8c83e1465ab34d81dc0", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f921acee1dc1152b82af5ff8224e6e49e177fcb1/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f921acee1dc1152b82af5ff8224e6e49e177fcb1/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f921acee1dc1152b82af5ff8224e6e49e177fcb1", "patch": "@@ -1,3 +1,9 @@\n+1999-03-16  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* method.c (old_backref_index): Split out...\n+\t(flush_repeats): From here.  Rename back from try_old_backref.\n+\t(build_mangled_name): Put back some old-style repeat handling.\n+\n Mon Mar 15 21:57:16 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n         * lex.c: Don't include setjmp.h."}, {"sha": "096d6628b9483263c81a17c0fec8bc6d9967938e", "filename": "gcc/cp/method.c", "status": "modified", "additions": 61, "deletions": 22, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f921acee1dc1152b82af5ff8224e6e49e177fcb1/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f921acee1dc1152b82af5ff8224e6e49e177fcb1/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=f921acee1dc1152b82af5ff8224e6e49e177fcb1", "patch": "@@ -57,7 +57,8 @@ static char *scratch_firstobj;\n \n static void icat PROTO((HOST_WIDE_INT));\n static void dicat PROTO((HOST_WIDE_INT, HOST_WIDE_INT));\n-static int try_old_backref PROTO((tree));\n+static int old_backref_index PROTO((tree));\n+static int flush_repeats PROTO((int, tree));\n static void build_overload_identifier PROTO((tree));\n static void build_overload_nested_name PROTO((tree));\n static void build_overload_int PROTO((tree, int));\n@@ -299,17 +300,16 @@ dicat (lo, hi)\n   OB_PUTC ('0' + ulo);\n }\n \n-/* Old mangling style:  If TYPE has already been used in the parameter list,\n-   emit a backward reference and return non-zero; otherwise, return 0.  */\n+/* Returns the index of TYPE in the typevec, or -1 if it's not there.  */\n \n static __inline int\n-try_old_backref (type)\n+old_backref_index (type)\n      tree type;\n {\n   int tindex = 0;\n \n   if (! is_back_referenceable_type (type))\n-    return 0;\n+    return -1;\n \n   /* The entry for this parm is at maxtype-1, so don't look there for\n      something to repeat.  */\n@@ -318,9 +318,40 @@ try_old_backref (type)\n       break;\n \n   if (tindex == maxtype - 1)\n-    return 0;\n+    return -1;\n+\n+  return tindex;\n+}\n+\n+/* Old mangling style:  If TYPE has already been used in the parameter list,\n+   emit a backward reference and return non-zero; otherwise, return 0.\n+\n+   NREPEATS is the number of repeats we've recorded of this type, or 0 if\n+   this is the first time we've seen it and we're just looking to see if\n+   it had been used before.  */\n+\n+static __inline int\n+flush_repeats (nrepeats, type)\n+     int nrepeats;\n+     tree type;\n+{\n+  int tindex = old_backref_index (type);\n+\n+  if (tindex == -1)\n+    {\n+      my_friendly_assert (nrepeats == 0, 990316);\n+      return 0;\n+    }\n \n-  OB_PUTC ('T');\n+  if (nrepeats > 1)\n+    {\n+      OB_PUTC ('N');\n+      icat (nrepeats);\n+      if (nrepeats > 9)\n+\tOB_PUTC ('_');\n+    }\n+  else\n+    OB_PUTC ('T');\n   icat (tindex);\n   if (tindex > 9)\n     OB_PUTC ('_');\n@@ -1129,36 +1160,41 @@ build_mangled_name (parmtypes, begin, end)\n \n \t  if (old_style_repeats)\n \t    {\n-\t      /* Note that for bug-compatibility with 2.7.2, we can't build\n-\t\t up repeats.  So we call try_old_backref (formerly\n-\t\t flush_repeats) every round, and only emit Tn codes.  */\n-\n \t      /* Every argument gets counted.  */\n \t      my_friendly_assert (maxtype < typevec_size, 387);\n \t      typevec[maxtype++] = parmtype;\n \t    }\n-\t  else if (flag_do_squangling)\n+\n+\t  if (last_type && same_type_p (parmtype, last_type))\n \t    {\n-\t      if (last_type && same_type_p (parmtype, last_type))\n+\t      if (flag_do_squangling \n+\t\t  || (old_style_repeats\n+\t\t      && is_back_referenceable_type (parmtype)))\n \t\t{\n \t\t  /* The next type is the same as this one.  Keep\n \t\t     track of the repetition, and output the repeat\n \t\t     count later.  */\n \t\t  nrepeats++;\n \t\t  continue;\n \t\t}\n-\t      else if (nrepeats != 0)\n-\t\t{\n-\t\t  /* Indicate how many times the previous parameter was\n-\t\t     repeated.  */\n-\t\t  issue_nrepeats (nrepeats, last_type);\n-\t\t  nrepeats = 0;\n-\t\t}\n+\t    }\n+\t  else if (nrepeats != 0)\n+\t    {\n+\t      /* Indicate how many times the previous parameter was\n+\t\t repeated.  */\n+\t      if (old_style_repeats)\n+\t\tflush_repeats (nrepeats, last_type);\n+\t      else\n+\t\tissue_nrepeats (nrepeats, last_type);\n+\t      nrepeats = 0;\n \t    }\n \t  \n \t  last_type = parmtype;\n \n-\t  if (old_style_repeats && try_old_backref (parmtype))\n+\t  /* Note that for bug-compatibility with 2.7.2, we can't build up\n+\t     repeats of types other than the most recent one.  So we call\n+\t     flush_repeats every round, if we get this far.  */\n+\t  if (old_style_repeats && flush_repeats (0, parmtype))\n \t    continue;\n \n \t  /* Output the PARMTYPE.  */\n@@ -1169,7 +1205,10 @@ build_mangled_name (parmtypes, begin, end)\n \t necessary.  */\n       if (nrepeats != 0)\n \t{\n-\t  issue_nrepeats (nrepeats, last_type);\n+\t  if (old_style_repeats)\n+\t    flush_repeats (nrepeats, last_type);\n+\t  else\n+\t    issue_nrepeats (nrepeats, last_type);\n \t  nrepeats = 0;\n \t}\n "}]}