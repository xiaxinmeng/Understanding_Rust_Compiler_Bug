{"sha": "c2952b018a1baf25b12c339f2b96518425164295", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzI5NTJiMDE4YTFiYWYyNWIxMmMzMzlmMmI5NjUxODQyNTE2NDI5NQ==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "2000-03-14T05:01:05Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "2000-03-14T05:01:05Z"}, "message": "Added Java 1.1 language features.\n\nFrom-SVN: r32517", "tree": {"sha": "bf1619873e76c17441a1423f1eaba6a4a64f054a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf1619873e76c17441a1423f1eaba6a4a64f054a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c2952b018a1baf25b12c339f2b96518425164295", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2952b018a1baf25b12c339f2b96518425164295", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2952b018a1baf25b12c339f2b96518425164295", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2952b018a1baf25b12c339f2b96518425164295/comments", "author": null, "committer": null, "parents": [{"sha": "e4476d1cbd567593c068dba421b5e089f7ccbcd5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4476d1cbd567593c068dba421b5e089f7ccbcd5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4476d1cbd567593c068dba421b5e089f7ccbcd5"}], "stats": {"total": 11946, "additions": 8817, "deletions": 3129}, "files": [{"sha": "521a4529337c03b40355dc016d11d1167854df39", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 617, "deletions": 6, "changes": 623, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2952b018a1baf25b12c339f2b96518425164295/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2952b018a1baf25b12c339f2b96518425164295/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=c2952b018a1baf25b12c339f2b96518425164295", "patch": "@@ -1,7 +1,37 @@\n+Mon Mar 13 12:21:13 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* parse.h (PUSH_CPC): Fixed indentation.\n+\t(DEBUG_CPC): New macro.\n+\t(SET_CPC_INITIALIZER_STMT, SET_CPC_STATIC_INITIALIZER_STMT,\n+ \tSET_CPC_INSTANCE_INITIALIZER_STMT): New macros.\n+\t* parse.y (class_body_declaration:): Use\n+ \tSET_CPC_INSTANCE_INITIALIZER_STMT.\n+\t(method_declaration:): Check for null current_function_decl.\n+\t(static_initializer:): Use SET_CPC_STATIC_INITIALIZER_STMT.\n+\t(java_parser_context_pop_initialized_field): Better handling of\n+ \tempty lists.\n+\t(maybe_make_nested_class_name): Mark nested class name as\n+ \tqualified when necessary.\n+\t(end_class_declaration): Don't call java_parse_context_resume when\n+ \tone or more error occured.\n+\t(add_inner_class_fields): Use SET_CPC_INITIALIZER_STMT.\n+\t(register_fields): Use SET_CPC_STATIC_INITIALIZER_STMT and\n+ \tSET_CPC_INITIALIZER_STMT.\n+\t(method_header): Check for inner classes declaring static methods.\n+\t(resolve_qualified_expression_name): Handle situation where `this'\n+ \tis implied.\n+\n Mon Mar 13 11:36:51 2000  Hans Boehm <boehm@acm.org>\n \n \t* typeck.c (build_prim_array_type): Correctly set the high word too.\n \n+2000-03-09  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* parse.y (java_complete_expand_methods): Leave <clinit> out of\n+\tordinary methods.\n+\t(maybe_generate_pre_expand_clinit): Put <clinit> at the end of the\n+\tlist of methods for interfaces.\n+\n 2000-03-07  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n \t* parse.y (qualify_ambiguous_name): Properly handle expressions\n@@ -50,6 +80,10 @@ Mon Mar  6 18:07:07 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \twhen looking up an interface method. From Godmar Back\n \t<gback@cs.utah.edu>\n \n+2000-03-06  Tom Tromey  <tromey@cygnus.com>\n+\n+\t* Make-lang.in (JAVA_SRCS): Added boehm.c, lex.c.\n+\n 2000-03-02  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n \t* java-tree.h (lookup_argument_method2): Declared.\n@@ -66,9 +100,13 @@ Mon Mar  6 18:07:07 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t(lookup_java_method): Re-written by calling lookup_do.\n \t(lookup_do): New function.\n \n-2000-03-06  Tom Tromey  <tromey@cygnus.com>\n+Thu Mar  2 15:18:33 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n-\t* Make-lang.in (JAVA_SRCS): Added boehm.c, lex.c.\n+\t* check-init.c (check_init): Removed dead code. Handle (blank)\n+ \tfinal variables.\n+\t* parse.y (declare_local_variables): New local `final_p', set it\n+ \tand use it to initialize LOCAL_FINAL.\n+\t(check_final_assignment): Only check FIELD_DECLs.\n \n 2000-02-17  Tom Tromey  <tromey@cygnus.com>\n \n@@ -89,6 +127,36 @@ Mon Mar  6 18:07:07 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* decl.c (init_decl_processing):  Initialize sizetype properly.\n \n+2000-03-01  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* java-tree.h (LOCAL_CLASS_P): New flag usage and macro.\n+\t(PURE_INNER_CLASS_DECL_P, PURE_INNER_CLASS_TYPE_P): New macros.\n+\t* jcf-dump.c (HANDLE_INNERCLASSES_ATTRIBUTE): New macro.  \n+\t* jcf-parse.c (HANDLE_INNERCLASSES_ATTRIBUTE): Likewise.\n+\t(jcf_parse): New local `current'. Load innerclasses seen in outer\n+\tcontext being processed.\n+\t* jcf-reader.c (HANDLE_INNERCLASSES_ATTRIBUTE): New macro.\n+\t* jcf-write.c (append_innerclasses_attribute): New function.\n+\t(append_innerclasses_attribute_entry): Likewise.\n+\t(get_access_flags): Handle static classes. Set anonymous and local\n+\tclasses to be private.\n+\t(generate_classfile): Attribute count adjusted. Call\n+\tappend_innerclasses_attribute.\n+\t* parse.h (SKIP_THIS_AND_ARTIFICIAL_PARMS): Use\n+\tPURE_INNER_CLASS_TYPE_P.\n+\t* parse.y (parser_qualified_classname): New parameter `is_static',\n+\tproduce non qualified name accordingly.\n+\t(block_statement:): Set LOCAL_CLASS_P when declaring local class.\n+\t(create_interface): Added argument to parser_qualified_classname.\n+\t(create_class): Added argument to parser_qualified_classname. Setup\n+\talias for top level classes. Use PURE_INNER_CLASS_DECP_P.\n+\t(add_inner_class_fields): Fixed indentation.\n+\t(method_declarator): Use PURE_INNER_CLASS_DECP_P.\n+\t(method_declarator): Fixed typo in comment.\n+\t(craft_constructor): Use PURE_INNER_CLASS_DECP_P.\n+\t(build_current_thisn): Likewise.\n+\t(patch_method_invocation): Likewise.\n+\n 2000-03-01  Martin von Loewis  <loewis@informatik.hu-berlin.de>\n \n \t* decl.c (current_function_decl): Move to toplev.c.\n@@ -144,6 +212,14 @@ Fri Feb 25 18:00:37 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \t(resolve_field_access): Removed unecessary code when dealing with\n  \tstatic fields.\n \n+Wed Feb 23 17:41:50 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* class.c (push_super_field): Don't push the field twice.\n+\t* jcf-parse.c (parse_source_file): Call java_reorder_fields.\n+\t* parse.h (java_reorder_fields): Prototyped.\n+\t* parse.y (java_reorder_fields): New function.\n+\t(java_layout_class): Simplified not to worry about re-ordering.\n+\n 2000-02-23  Tom Tromey  <tromey@cygnus.com>\n \n \t* gjavah.c (print_name): In JNI case, correctly quote string.\n@@ -210,9 +286,12 @@ Thu Feb 17 13:20:58 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n 2000-02-15  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n-\t* lex.c (java_parse_doc_section): Alway unget the last unicode\n-\twhen returning 0.\n-\t(java_lex): Call java_parse_end_comment with fetched unicode.\n+\t* parse.y (outer_field_access_p): Stop in time when outer contexts\n+ \tare exhausted.\n+\t(resolve_qualified_expression_name): Properly qualify *everything*\n+ \tafter a package.type to be resoled as expression names.\n+\t(find_applicable_accessible_methods_list): Save/restore `class' to\n+ \tisolate it from a possible outer context search.\n \n 2000-02-15  Tom Tromey  <tromey@cygnus.com>\n \n@@ -233,6 +312,75 @@ Thu Feb 17 13:20:58 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n \t* jv-scan.c: Likewise.\n \n+Sat Feb 12 04:34:04 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* parse.y (outer_field_access_fix): First parameter now a tree\n+\tnode. Check for assignement to final. First argument to\n+\tbuild_outer_field_access_fix modified to accomodate prototype.\n+\t(build_outer_field_access): Don't check for assignment to final\n+\there.\n+\t(java_complete_lhs): MODIFY_EXPR case: Check for `error_mark_node'\n+\tpossibly returned by outer_field_access_fix. Changed\n+\touter_field_access_fix's first argument.\n+\t(check_final_assignment): $finit$'s context is OK.\n+\t(patch_unaryop): Use node instead of its line/column value when\n+\tcalling outer_field_access_fix.\n+\n+Fri Feb 11 17:38:26 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* parse.y (interface_declaration:): No longer tagged\n+ \t<node>. Re-installed default action.\n+\t(class_member_declaration:): Handle inner interfaces.\n+\t(interface_member_declaration): Handle inner interfaces and\n+ \tclasses.\n+\t(create_interface): Push error if one seen. Suspend parsing\n+ \tcontext when processing an inner interface.\n+\t(register_fields): Inner class static field limitations not to\n+ \tapply to inner interfaces.\n+\n+Thu Feb 10 22:07:35 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* jcf-parse.c (load_class): Update `java_error_count' when a\n+ \tclass' file can't be found.\n+\t(parse.y): Avoid (byte)code generation when errors seen.\n+\n+Thu Feb 10 20:10:43 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* parse.y (java_complete_lhs): Handle TRUNC_DIV_EXPR. Ensure `fatal'\n+ \tdecodes a valid node.\n+\t(patch_binop): Handle TRUNC_DIV_EXPR.\n+\n+Thu Feb 10 16:04:26 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* parse.y (resolve_package): New local `acc.' Try to progressively\n+ \tbuild and guess a package and type name.\n+\n+Thu Feb 10 12:52:09 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* parse.y (find_applicable_accessible_methods_list): Load and\n+ \tlayout the search class if necessary.\n+\t(java_complete_tree): Keep to original type of the folded initial\n+ \tvalue.\n+\n+2000-02-09  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+        * class.c (layout_class): Set and test CLASS_BEING_LAIDOUT.\n+        Generate error message if circularity is detected. New static\n+        local `list.'\n+        * java-tree.h (CLASS_BEING_LAIDOUT): New flag usage, new macro.  *\n+        * jcf-write.c (generate_bytecode_insns): Very simply handle\n+        SAVE_EXPR.\n+        * parse.y (java_check_circular_reference): Use\n+        `cyclic_inheritance_report' during report, if necessary.\n+        (java_complete_lhs): fixed comment with `THROW_EXPR:' case. Avoid\n+        walking NEW_ARRAY_INIT twice.\n+\n+2000-02-09  Tom Tromey  <tromey@cygnus.com>\n+\n+        * parse.y (check_class_interface_creation): Allow inner classes to\n+        be `private' or `protected', check modifiers' consistency. Prevent\n+        block local classes from bearing any modifiers.\n+\n 2000-02-10  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* except.c (check_start_handlers): Re-add prototype lost in last\n@@ -246,6 +394,42 @@ Thu Feb 17 13:20:58 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \t(force_poplevels): Ditto.\n \t(struct binding_level): Add comment.\n \t\n+2000-02-07  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+        * jcf-write.c (generate_classfile): Don't consider\n+        pre-initialization with reference value (use <clinit> instead.)\n+        * parse.y (java_fix_constructors): No generated constructor for\n+        interfaces.\n+        (build_outer_field_access): Removed debug message.\n+        (outer_field_expanded_access_p): Adapted to bytecode generation.\n+        (build_outer_field_access_method): Use fix_method_argument_names.\n+        (build_outer_method_access_method): Fixed indentation. Added\n+        comment. Handle access method generation for static and also void\n+        methods.\n+        (build_access_to_thisn): Inserted debug message.\n+        (maybe_build_thisn_access_method): Use fix_method_argument_names.\n+        (resolve_qualified_expression_name): Fixed comment.\n+        (not_accessible_p): Adapted to bytecode generation. Added comment.\n+        (patch_method_invocation): Added comment.\n+        (maybe_use_access_method): Fixed leading comment. Handle static\n+        methods.\n+        (java_complete_lhs): Don't shortcut handling of initialized upon\n+        declaration String type static fields when generating bytecode.\n+        (patch_unaryop): Handle outer field access when generating\n+        bytecode.\n+\n+Thu Feb  3 20:23:19 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* java-tree.h (FIELD_THISN): New macro.\n+\t* jcf-write.c (append_synthetic_attribute): New function.\n+\t(generate_classfile): Set \"Synthetic\" attribute on this$<n>,\n+ \tval$<name> fields, access$<n> and $finit$ methods. Fixed indentation.\n+\t* parse.y (add_inner_class_fields): Set FIELD_THISN for created\n+ \tthis$<n> fields.\n+\t(build_outer_field_access): Turned on access functions usage and\n+ \tgeneration when compiling to bytecode.\n+\t(maybe_use_access_method): Likewise.\n+\n 2000-01-25  Andrew Haley  <aph@cygnus.com>\n \n         * java-except.h (struct eh_range): Add `expanded' field.\n@@ -301,6 +485,37 @@ Thu Feb 17 13:20:58 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \tassemble doubles correctly when HOST_FLOAT_WORDS_BIG_ENDIAN is\n \tdefined to be 1.\n \n+Wed Feb  2 18:43:37 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* java-tree.def (INSTANCE_INITIALIZERS_EXPR): New tree code.\n+\t* java-tree.h (TYPE_II_STMT_LIST): New macro.\n+\t(struct lang_type): New field `ii_block'.\n+\t* lex.c (java_init_lex): Use CPC_INITIALIZER_LIST,\n+\tCPC_STATIC_INITIALIZER_LIST and CPC_INSTANCE_INITIALIZER_LIST.\n+\t* parse.h (struct parser_ctxt): New field `instance_initializers'.\n+\t(CPC_INITIALIZER_LIST, CPC_STATIC_INITIALIZER_LIST,\n+\tCPC_INSTANCE_INITIALIZER_LIST, CPC_INITIALIZER_STMT,\n+\tCPC_STATIC_INITIALIZER_STMT, CPC_INSTANCE_INITIALIZER_STMT): New\n+\tmacros.\n+\t* parse.y (add_instance_initializer): New function.\n+\t(in_instance_initializer): New static global.\n+\t(class_body_declaration:): Link instance initializer block.\n+\t(static_initializer:): Use CPC_STATIC_INITIALIZER_STMT.\n+\t(array_creation_expression:): Remove unused local.\n+\t(java_parser_context_push_initialized_field): Fixed leading\n+\tcomment. Use CPC_STATIC_INITIALIZER_LIST, CPC_INITIALIZER_LIST and\n+\tCPC_INSTANCE_INITIALIZER_LIST.\n+\t(java_parser_context_pop_initialized_field): Likewise.\n+\t(add_inner_class_fields): Use CPC_INITIALIZER_STMT.\n+\t(register_fields): Use CPC_STATIC_INITIALIZER_STMT and\n+\tCPC_INITIALIZER_STMT.\n+\t(fix_constructors): New local `class_type'. Use it. Call\n+\tadd_instance_initializer.\n+\t(java_complete_lhs): New case INSTANCE_INITIALIZERS_EXPR.\n+\t(patch_return): Forbid return in instance initializers.\n+\t(patch_throw_statement): Enforce exception handling in the context\n+\tof instance initializers.\n+\t\n 2000-02-03  Tom Tromey  <tromey@cygnus.com>\n \n \t* Make-lang.in (java.mostlyclean): Remove executables in\n@@ -363,6 +578,52 @@ Thu Feb 17 13:20:58 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \t(main): Use getopt_long_only to parse command line.\n \t(usage): Changed message.\n \n+Tue Feb  1 22:23:41 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* java-tree.def (NEW_ANONYMOUS_ARRAY_EXPR): New tree code.\n+\t* parse.h (ANONYMOUS_ARRAY_BASE_TYPE, ANONYMOUS_ARRAY_DIMS_SIG,\n+\tANONYMOUS_ARRAY_INITIALIZER): New access macros.\n+\t* parse.y (array_creation_expression:): Handle anonymous arrays.\n+\t(build_array_from_name): Don't set `ret_name' if null.\n+\t(resolve_qualified_expression_name): New case NEW_ANONYMOUS_ARRAY_EXPR.\n+\t(qualify_ambiguous_name): Likewise.\n+\t(java_complete_expand_class): Likewise.\n+\n+Tue Feb  1 14:59:35 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* java-tree.def (SYNCHRONIZED_EXPR): Fixed typo.\n+\t* parse.h (MANGLE_ALIAS_INITIALIZER_PARAMETER_NAME_ID): New macro.\n+\t(MANGLE_ALIAS_INITIALIZER_PARAMETER_NAME_STR): Likewise.\n+\t(SKIP_THIS_AND_ARTIFICIAL_PARMS): Use DECL_FINIT_P.\n+\t(AIPL_FUNCTION_FINIT_INVOCATION): Replaces\n+\tAIPL_FUNCTION_COMPLETED_INVOCATION.\n+\t(AIPL_FUNCTION_CTOR_INVOCATION): Replaces \n+\tAIPL_FUNCTION_INVOCATION_READY.\n+\t(AIPL_FUNCTION_DECLARATION): New enum entry.\n+\t* parse.y (reorder_static_initialized): New function.\n+\t(java_parser_context_pop_initialized_field): Use it.\n+\t(add_inner_class_fields): Use\n+\tMANGLE_ALIAS_INITIALIZER_PARAMETER_NAME_ID. Comment\n+\taugmented. Install marker after last alias initializer, if any.\n+\t(generate_finit): Fixed typo. Don't try to retain only the used\n+\tfields.\n+\t(method_header): Compute and set DECL_FUNCTION_NAP.\n+\t(method_declarator): Fixed comment. Insert alias initializer in\n+\tparameter list.\n+\t(build_alias_initializer_parameter_list): Fixed leading\n+\tcomment. New case for AIPL_FUNCTION_DECLARATION. Old enum value\n+\treplaced by new ones. Use MANGLE_ALIAS_INITIALIZER_PARAMETER_NAME_ID.\n+\t(java_complete_expand_class): Code to retain only used aliases\n+\tremoved.\n+\t(java_complete_expand_methods): New local `first_decl'. Generate\n+\t$finit$ first, then expand the constructors, regular methods and\n+\t<clinit>.\n+\t(java_complete_expand_method): Don't report error on missing\n+\treturn statement if previously detected bogus.\n+\t(fix_constructors): Don't patch constructor parameters list.\n+\t(patch_method_invocation): Use new AIPL enum values. Reverse\n+\talias initializer list for anonymous classes.\n+\t\n 2000-01-30  Anthony Green  <green@redhat.com>\n \n \t* jcf-write.c (generate_bytecode_insns): Use TYPE_IS_WIDE to\n@@ -374,6 +635,72 @@ Thu Feb 17 13:20:58 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \terror handling/recovery.\n \t* java-tree.h (SYNCHRONIZED_EXPR): Fixed typo in comment.\n \n+Fri Jan 28 20:10:57 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* java-tree.h (ARG_FINAL_P, FIELD_LOCAL_ALIAS,\n+ \tFIELD_LOCAL_ALIAS_USED): New macros.\n+\t(DECL_FUNCTION_NAP): New macro.\n+\t(struct lang_decl): New field `nap'.\n+\t(TYPE_FINIT_STMT_LIST, TYPE_CLINIT_STMT_LIST): New macros.\n+\t(struct lang_type): New fields `finit_stmt_list' and\n+ \t`clinit_stmt_list'.\n+\t(CLASS_HAS_FINIT_P): Defined using TYPE_FINIT_STMT_LIST.\n+\t* parse.h (MANGLE_OUTER_LOCAL_VARIABLE_NAME): New macro.\n+\t(SKIP_THIS_AND_ARTIFICIAL_PARMS, MARK_FINAL_PARMS,\n+ \tUNMARK_FINAL_PARMS, CRAFTED_PARAM_LIST_FIXUP): New macros.\n+\t(AIPL_FUNCTION_CREATION, AIPL_FUNCTION_COMPLETED_INVOCATION,\n+ \tAIPL_FUNCTION_INVOCATION_READY): New enum fields.\n+\t(BUILD_THROW): Macro line separator re-indented.\n+\t* parse.y (end_class_declaration): New function.\n+\t(maybe_generate_pre_expand_clinit): New name for\n+ \tjava_pre_expand_clinit. Create <clinit> off TYPE_CLINIT_STMT_LIST,\n+ \tpre-expand static fields.\n+\t(maybe_generate_clinit): Function deleted.\n+\t(check_for_static_method_reference): Prototype's parameter list\n+ \tindented.\n+\t(generate_finit): New name for maybe_generate_finit. Changed\n+ \tleading comment. Function rewritten to use\n+ \tTYPE_FINIT_STMT_LIST. Call build_alias_initializer_parameter_list.\n+\t(build_alias_initializer_parameter_list): New function.\n+\t(java_parser_context_pop_initialized_field): Likewise.\n+\t(add_inner_class_fields): Likewise.\n+\t(type_declaration:): Call end_class_declaration.\n+\t(class_member_declaration:): Likewise.\n+\t(formal_parameter_list:): Fixed typos.\n+\t(formal_parameter:): Use ARG_FINAL_P to mark created tree list\n+ \telement. Improved error handling.\n+\t(block_statement:): Call end_class_declaration.\n+\t(anonymous_class_creation:): Likewise.\n+\t(create_anonymous_class): Fixed comments.\n+\t(create_class): Call add_inner_class_fields.\n+\t(register_fields): Set FIELD_LOCAL_ALIAS according to ARG_FINAL_P.\n+\t(method_header): Use MARK_FINAL_PARMS.\n+\t(finish_method_declaration): Use UNMARK_FINAL_PARMS.\n+\t(method_declarator): Propagate final argument flag.\n+\t(craft_constructor): New local `artificial'. Call\n+ \tbuild_alias_initializer_parameter_list. Use\n+ \tCRAFTED_PARAM_LIST_FIXUP, assign DECL_FUNCTION_NAP.\n+\t(source_start_java_method): Mark parm decls with LOCAL_FINAL if\n+ \tnecessary.\n+\t(complete_expand_class): Get rid of unused outer context local\n+ \talias fields.\n+\t(java_complete_expand_methods): Fixed leading\n+ \tcomment. Generate/pre-expand <clinit> first. Changed method\n+ \texpansion order to regular, $finit$, constructors, <clinit>.\n+\t(java_complete_expand_method): Set current_function_decl.\n+\t(fix_constructors): Fix constructor parameter list to account for\n+ \touter context local alias initializers.\n+\t(verify_constructor_super): Use SKIP_THIS_AND_ARTIFICIAL_PARMS.\n+\t(resolve_expression_name): Lookup outer context local aliases. New\n+ \tlocal `access', use it.\n+\t(patch_method_invocation): Patch inner class ctor invocation with\n+ \touter context local aliases initialization values. $finit$\n+ \tinvocation patching now includes things generated with\n+ \tbuild_alias_initializer_parameter_list.\n+\t(argument_types_convertible): Use SKIP_THIS_AND_ARTIFICIAL_PARMS.\n+\t(build_super_invocation): Likewise.\n+\t(patch_assignment): Changed comment.\n+\n 2000-01-27  Andrew Haley  <aph@cygnus.com>\n \n         * jcf-write.c (emit_goto): RESERVE 3 bytes for insn.\n@@ -429,7 +756,62 @@ Thu Feb 17 13:20:58 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \t* xref.h: Likewise.\n \t* zextract.c: Likewise.\n \t* zipfile.h: Likewise.\n-\n+\t\n+2000-01-18  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* class.c (make_class): Use MAYBE_CREATE_TYPE_TYPE_LANG_SPECIFIC.\n+\t(is_compiled_class): Remove test on TYPE_LANG_SPECIFIC, use TYPE_JCF.\n+\t* constants.c (build_constant_data_ref): Check for cached\n+\tcurrent_constant_pool_data_ref. Cache current_constant_pool_data_ref\n+\tin TYPE_CPOOL_DATE_REF.\n+\t* java-tree.h (TYPE_JCF, TYPE_CPOOL, TYPE_CPOOL_DATA_REF,\n+\tMAYBE_CREATE_TYPE_TYPE_LANG_SPECIFIC:) New macros.\n+\t(struct lang_type): New fields `cpool' and `cpool_data_ref'.\n+\t(LOCAL_FINAL): New macro.\n+\t* jcf-parse.c (init_outgoing_cpool): Always allocate new outgoing\n+\tconstant pool -- don't try to reuse.\n+\t(parse_zip_file_entries): Use TYPE_JCF, don't lazily allocate\n+\tTYPE_LANG_SPECIFIC.\n+\t(find_in_current_zip): Use TYPE_JCF.\n+\t* parse.h (java_check_final): Prototype removed.\n+\t* parse.y (create_class): Reversed Jan 12, 2000 extra argument patch.\n+\t(maybe_create_class_interface_decl,\n+\tcheck_class_interface_creation): Likewise.\n+\t(java_expand_finals): Function removed.\n+\t(class_declaration:): Reversed Jan 12, 2000 extra argument patch.\n+\t(block_statement:): Fixed comment.\n+\t(anonymous_class_creation:): Likewise.\n+\t(check_class_interface_creation): Reversed Jan 12, 2000 extra\n+\targument patch.\n+\t(check_class_interface_creation): Loosened error report on (inner)\n+\tpublic class declarations. CPC_INNER_P replaces GET_CPC_LIST.\n+\t(link_nested_class_to_enclosing): Reversed Jan 12, 2000 patch.\n+\t(maybe_create_class_interface_decl): Reversed Jan 12, 2000 extra\n+\targument patch.\n+\t(create_interface): Likewise.\n+\t(anonymous_class_counter): New static global.\n+\t(create_anonymous_class): Reversed Jan 12, 2000 extra argument\n+\tpatch. Fixed comments.\n+\t(create_class): Reversed Jan 12, 2000 extra argument patch. Reset\n+\tanonymous_class_counter when declaring a toplevel class.\n+\t(craft_constructor): Fixed constructor name when handling\n+\tanonymous classes. Anonymous class constructors to feature hidden\n+\tthis$<n> parameter.\n+\t(java_fix_constructors): Added comment.\n+\t(java_check_final): Function removed.\n+\t(java_complete_expand_methods): Fixed comment. Don't generate\n+\tclass data, save its outgoing constant pool instead.\n+\t(verify_constructor_super): Skip anonymous class constructor\n+\thidden this$<n> parameter.\n+\t(java_expand_classes): New local `saved_ctxp'. Removed call to\n+\tjava_expand_finals and java_check_final. Expand anonymous class\n+\tconstructors. Generate class data.\n+\t(build_super_invocation): Skip anonymous class hidden this$<n>\n+\tparameter.\n+\t* typeck.c (build_java_signature): Use TYPE_SIGNATURE and\n+\tMAYBE_CREATE_TYPE_TYPE_LANG_SPECIFIC.\n+\t(set_java_signature): Likewise.\n+\t\n Mon Jan 18 14:30:09 2000  Joerg Brunsmann  <joerg.brunsmann@fernuni-hagen.de>\n \n \t* gjavah.c: Delete ACC_VISIBILITY define.\n@@ -448,6 +830,235 @@ Mon Jan 17 11:58:17 2000  Joerg Brunsmann  <joerg.brunsmann@fernuni-hagen.de>\n \n \t* gjavah.c (print_field_info): Allow non-static final fields.\n \n+Fri Jan 14 18:03:41 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* parse.h (enum jdep_code): New entry `JDEP_ANONYMOUS'.\n+\t* parse.y (patch_anonymous_class): New function.\n+\t(create_anonymous_class): Register incomplete type when the\n+ \tclass/interface to extends/implement isn't known yet.\n+\t(parser_check_super_interface): Simplify argument to CLASS_INTERFACE.\n+\t(verify_constructor_super): Tuned error message.\n+\n+Fri Jan 14 00:14:24 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* java-tree.h (FOR_LOOP_P): Replaces IS_FOR_LOOP_P.\n+\t(ANONYMOUS_CLASS_P): New macro.\n+\t(TYPE_SIGNATURE, TYPE_JCF): New macros.\n+\t(INNER_CLASS_TYPE_P): Fixed typo in leading comment.\n+\t* parse.y (create_class): Added leading argument.\n+\t(maybe_create_class_interface_decl,\n+ \tcheck_class_interface_creation): Likewise.\n+\t(craft_constructor): New function.\n+\t(verify_constructor_super): Added argument in prototype.\n+\t(class_declaration:): Inserted leading argument.\n+\t(for_begin:): Use FOR_LOOP_P.\n+\t(anonymous_class_creation): Create WFL of the anonymous class to\n+ \tinstantiate. Call build_new_invocation. Added comments.\n+\t(check_class_interface_creation): Handle parameter `anonymous' in\n+ \tverbose mode class creation announce.\n+\t(link_nested_class_to_enclosing): Exclude anonymous classes.\n+\t(maybe_create_class_interface_decl): Don't set DECL_CONTEXT on\n+ \tanonymous class, even though they appear to have an enclosing\n+ \tcontext.\n+\t(create_interface): Pass extra argument to\n+ \tcheck_class_interface_creation.\n+\t(create_anonymous_class): Set ANONYMOUS_CLASS_P to 1.\n+\t(create_class): Call check_class_interface_creation and\n+ \tmaybe_create_class_interface_decl with extra new argument. Don't\n+ \tadd private this$<n> to anonymous classes.\n+\t(method_declarator): Insert hidden this$<n> to anonymous class\n+ \tconstructors.\n+\t(java_fix_constructors): Deleted code creating default\n+ \tconstructor. Call craft_constructor instead.\n+\t(java_check_regular_methods): Set `saw_constructor' to 1 for\n+ \tanonymous classes.\n+\t(fix_constructors): Pass extra argument to verify_constructor_super.\n+\t(verify_constructor_super): New local `sdecl', use it. Search for\n+ \tmatching constructor (possibly featuring arguments) in super\n+ \tclass.\n+\t(lookup_method_invoke): Craft constructor according to arguments\n+ \tlist when dealing with anonymous class constructors.\n+\t(build_super_invocation): Pass arguments to anonymous class super\n+ \tconstructors.\n+\t(search_loop): Use FOR_LOOP_P.\n+\t(labeled_block_contains_loop_p): Likewise.\n+\t\n+Wed Jan 12 00:38:47 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* class.c (set_super_info): Set CLASS_STATIC when appropriate.\n+\t(enclosing_context_p): New function.\n+\t(get_access_flags_from_decl): Handle CLASS_STATIC.\n+\t(maybe_layout_super_class): Extra first argument passed to\n+ \tdo_resolve_class.\n+\t(layout_class_method): Use ID_FINIT_P, DECL_CLINIT_P and\n+ \tID_INIT_P.\n+\t* decl.c (access0_identifier_node): New global.\n+\t(init_decl_processing): access0_identifier_node initialized. \n+\t(pushdecl): Set DECL_CONTEXT only on non type decls.\n+\t* expr.c (lookup_field): Lookup inner class fields in enclosing\n+ \tcontexts.\n+\t(expand_invoke): Use ID_INIT_P.\n+\t(expand_java_field_op): Use DECL_CLINIT_P.\n+\t* java-tree.def (CLASS_LITERAL): New tree code.\n+\t* java-tree.h (DECL_FUNCTION_ACCESS_DECL,\n+ \tDECL_FUNCTION_INNER_ACCESS, FIELD_INNER_ACCESS): New macros.\n+\t(struct lang_decl): New field `inner_access'.\n+\t(enclosing_context_p): Prototyped.\n+\t(DECL_INIT_P, DECL_FINIT_P, DECL_CLINIT_P, ID_INIT_P, ID_FINIT_P,\n+ \tID_CLINIT_P): New macros.\n+\t(CLASS_STATIC): New macro.\n+\t(CLASS_ACCESS0_GENERATED_P): New macro.\n+\t(OUTER_FIELD_ACCESS_IDENTIFIER_P, INNER_CLASS_DECL_P,\n+ \tTOPLEVEL_CLASS_DECL_P, INNER_CLASS_TYPE_P, TOPLEVEL_CLASS_TYPE_P,\n+ \tINNER_CLASS_P): New macros.\n+\t(DECL_INNER_CLASS_LIST): New macro.\n+\t* jcf-parse.c (yyparse): Avoid the use of ANSI string\n+ \tconcatenation.\n+\t* jcf-write.c (generate_bytecode_insns): binop: Change the type of\n+ \tthe shift value to int. Fixed typo in comment.\n+\t* lex.c (inst_id, wpv_id): Initialize.\n+\t* mangle.c (unicode_mangling_length): Take `$' into account.\n+\t* parse.h (DRECOVER, RECOVER): Terminate properly.\n+\t(IDENTIFIER_INNER_CLASS_OUTER_FIELD_ACCESS): New macro.\n+\t(typedef struct _jdep): New field `enclosing'.\n+\t(JDEP_ENCLOSING): New macro.\n+\t(IS_CLINIT): Deleted (DECL_CLINIT_P replaces it.)\n+\t(struct parser_ctxt): New fields `marker_beginning', `marked_end'.\n+\t(GET_CPC_LIST, CPC_INNER_P, GET_CPC, GET_CPC_UN, GET_CPC_UN_MODE,\n+ \tGET_CPC_DECL_NODE, GET_ENCLOSING_CPC, GET_NEXT_ENCLOSING_CPC,\n+ \tGET_ENCLOSING_CPC_CONTEXT): New macros.\n+\t(PUSH_CPC, PUSH_ERROR, POP_CPC): New macros.\t\n+\t(do_resolve_class): Added extra argument in prototype.\n+\t* parse.y (resolve_class): Added extra argument in prototype.\n+\t(maybe_create_class_interface_decl): Likewise.\n+\t(maybe_use_access_method, build_wfl_wrap): New functions.\n+\t(java_complete_expand_classes, java_complete_expand_class):\n+ \tLikewise.\n+\t(java_parser_context_push_initialized_field,\n+ \tjava_parser_context_suspend, java_parser_context_resume):\n+ \tLikewise.\n+\t(maybe_make_nested_class_name, make_nested_class_name,\n+ \tset_nested_class_simple_name_value,\n+ \tlink_nested_class_to_enclosing, find_as_inner_class,\n+ \tfind_as_inner_class_do, check_inner_class_redefinition,\n+ \tbuild_thisn_assign, build_current_thisn, build_access_to_thisn,\n+ \tmaybe_build_thisn_access_method, build_outer_field_access,\n+ \tbuild_outer_field_access_methods, build_outer_field_access_expr,\n+ \tbuild_outer_method_access_method, build_new_access_id,\n+ \tbuild_outer_field_access_method, outer_field_access_p,\n+ \touter_field_expanded_access_p, outer_field_access_fix,\n+ \tbuild_incomplete_class_ref, patch_incomplete_class_ref,\n+ \tcreate_anonymous_class): Likewise.\n+\t(inst_id, wpv_id): New static global variables.\n+\t(synchronized:): New rule, tagged <node>.\n+\t(type_declaration:): No longer tagged <node>. Call POP_CPC in sub\n+ \trules.\n+\t(anonymous_class_creation:): New rule, tagged <node>.\n+\t(NEW_TK): Tagged <node>.\n+\t(type_literals, array_type_literal): New rules, tagged <node>.\n+\t(class_declaration:): Removed action when reducing by class_body:\n+\t(class_body:): Set DECL_END_SOURCE_LINE and rule's returned value\n+ \tusing GET_CPC in sub-rules.\n+\t(class_member_declaration): Handle inner classes.\n+\t(method_declaration): When reducing method_header:, reset\n+ \tcurrent_function_decl when appropriate.\n+\t(method_declarator:): Set the number of formal parameter to 0 for\n+ \tmethod declared without arguments.\n+\t(constructor_declarator:): Likewise.\n+\t(static_initializer:): List of elements kept in a list.\n+\t(static:): Rule modifiers: replaces MODIFIER_TK. Enforce correct\n+ \tuse of the keyword `static' for type declarations.\n+\t(block_statement:): Handle inner class declarations.\n+\t(primary_no_new_array:): Use type_literals:. Fixed comment. Handle\n+ \ttype qualified `this'.\n+\t(class_instance_creation_expression): Use anonymous_class_creation:\n+\tto handle inner class instances creation. Handle qualified `new'.\n+\t(something_dot_new): Added appropriate actions.\n+\t(create_new_parser_context): New function.\n+\t(java_push_parser_context, java_parser_context_save_global,\n+ \tjava_parser_context_suspend): Use create_new_parser_context.\n+\t(check_modifiers): Changed leading comment.\n+\t(check_class_interface_creation): Handle interclasses.\n+\t(add_superinterfaces): Fixed comment.\n+\t(create_interface): Build qualified name from the raw_name instead\n+ \tof its matching WFL. Push the initialized fields list. raw_name added\n+ \tas an extra argument to maybe_create_class_interface_decl.\n+\t(create_class): Build qualified name from the raw_name instead of\n+ \tits matching WFL. Removed assignment to\tcurrent_parsed_class_un.\n+\tCall PUSH_ERROR before returning an error. Suspend the current\n+ \tparser context when processing an inner class. Push the\n+ \tinitialized fields list. raw_name added as an extra argument to\n+ \tmaybe_create_class_interface_decl. Add the private this$<n>\n+ \tfield. \n+\t(duplicate_declaration_error_p): Use GET_CPC when calling find_field.\n+\t(register_fields): Get the class type from GET_CPC and handle\n+ \tprevious errors.  Added code to handle the creation of static\n+ \tfields in inner classes. Initialized fields initialization\n+ \tstatements kept in a list of lists.\n+\t(maybe_generate_finit): Initialized fields initialization\n+ \tstatements kept in a list of lists. Use GET_CPC.\n+\t(maybe_generate_clinit): Likewise.\n+\t(method_header): Use GET_CPC and GET_CPC_UN.\n+\t(parser_qualified_classname): Handle inner classes.\n+\t(register_incomplete_type): Set JDEP_ENCLOSING using GET_CPC.\n+\t(java_fix_constructors): Hide pointer to enclosing context\n+ \tinstance in constructor list when dealing with inner classes.\n+\t(jdep_resolve_class): Call resolve_class with extra first argument\n+ \tJDEP_ENCLOSING.\n+\t(resolve_class): Add enclosing context as a first extra argument\n+ \tto do_resolve_class.\n+\t(do_resolve_class): Call find_as_inner_class. Handle WFLs\n+ \tproperly.\n+\t(resolve_no_layout): Extra argument added to resolve_class\n+ \tinvocation.\n+\t(reset_method_name): Use DECL_CLINIT_P, DECL_FINIT_P.\n+\t(java_get_real_method_name): Use GET_CPC_UN.\n+\t(check_abstract_method_definitions): Use DECL_CLINIT_P.\n+\t(java_check_abstract_methods): Handle static method declared in\n+ \tinner classes by an error.\n+\t(java_check_regular_methods): Use DECL_CLINIT_P.\n+\t(source_start_java_method): Also set DECL_MAX_LOCALS.\n+\t(create_artificial_method): Call java_parser_context_save_global\n+ \tand java_parser_context_restore_global instead of saving/restoring\n+ \tthe context by hand.\n+\t(expand_start_java_method): Improved verbose mode message.\n+\t(java_complete_expand_methods): Fixed leading comment. Use\n+ \tDECL_CLINIT_P.\n+\t(fix_constructors): Added assignment to this$<n> if necessary.\n+\t(java_expand_classes): Call java_complete_expand_classes instead\n+ \tof java_complete_expand_methods.\n+\t(make_qualified_primary): Simplified.\n+\t(merge_qualified_name): Optimized for missing left or right parts.\n+\t(resolve_expression_name): Handle access to outer class fields from\n+ \tinterclasses.\n+\t(resolve_qualified_expression_name): New macro\n+ \tRESTORE_THIS_AND_CURRENT_CLASS, used. Handle creation of inner\n+ \tclasses. Report error on non appropriate qualification of\n+ \t`new'. Handle qualified `this'.\n+\t(not_accessible_p): Allow access to outer class private fields from\n+ \tinner classes.\n+\t(patch_method_invocation): Handle method invocations through\n+ \taccess methods and inner class constructor invocations.\n+\t(find_applicable_accessible_methods_list): Search enclosing\n+ \tcontexts of an inner class.\n+\t(search_applicable_methods_list): Fixed typo.\n+\t(argument_types_convertible): Handle inner class constructors'\n+ \thidden outer context reference argument.\n+\t(qualify_ambiguous_name): Handle qualified `this'.\n+\t(java_complete_lhs): Handle use of field accessed through\n+ \tartificial access methods in various cases of assignments. Handle\n+ \tCLASS_LITERAL node.\n+\t(check_final_assignment): Use DECL_CLINIT_P.\n+\t(valid_ref_assignconv_cast_p): Handle the destination being an\n+ \tenclosing context of the source.\n+\t(patch_unaryop): Handle use of field accessed through artificial\n+ \taccess methods.\n+\t(patch_return): Use DECL_CLINIT_P.\n+\t(patch_throw_statement): Use DECL_CLINIT_P.\n+\t(check_thrown_exceptions): Use DECL_FINIT_P and DECL_INIT_P.\n+\t* verify.c (verify_jvm_instructions): Use ID_CLINIT_P and\n+ \tID_INIT_P.\n+\t\n 2000-01-16  Anthony Green  <green@cygnus.com>\n \n \t* parse.y (build_string_concatenation): Only use"}, {"sha": "aa0e47bc77291652638d3b18dda18ed16edc2c0f", "filename": "gcc/java/check-init.c", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2952b018a1baf25b12c339f2b96518425164295/gcc%2Fjava%2Fcheck-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2952b018a1baf25b12c339f2b96518425164295/gcc%2Fjava%2Fcheck-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fcheck-init.c?ref=c2952b018a1baf25b12c339f2b96518425164295", "patch": "@@ -374,25 +374,30 @@ check_init (exp, before)\n \t  int index = DECL_BIT_INDEX (exp);\n \t  if (index >= 0 && ! SET_P (before, index))\n \t    {\n-#if 1\n-\t      parse_error_context (wfl,\n-\t\t\t\t   \"Variable `%s' may not have been initialized\"\n-\t\t\t\t   , IDENTIFIER_POINTER (DECL_NAME (exp)));\n-#else\n-\t      error_with_decl (exp, \"variable may be used uninitialized\");\n-#endif\n+\t      parse_error_context \n+\t\t(wfl, \"Variable `%s' may not have been initialized\",\n+\t\t IDENTIFIER_POINTER (DECL_NAME (exp)));\n \t      /* Suppress further errors. */\n \t      DECL_BIT_INDEX (exp) = -1;\n \t    }\n \t}\n       break;\n     case MODIFY_EXPR:\n       tmp = TREE_OPERAND (exp, 0);\n-      if (TREE_CODE (tmp) == VAR_DECL && ! FIELD_STATIC (tmp))\n+      /* We're interested in variable declaration and parameter\n+         declaration when they're declared with the `final' modifier. */\n+      if ((TREE_CODE (tmp) == VAR_DECL && ! FIELD_STATIC (tmp))\n+\t  || (TREE_CODE (tmp) == PARM_DECL && LOCAL_FINAL (tmp)))\n \t{\n \t  int index;\n \t  check_init (TREE_OPERAND (exp, 1), before);\n \t  index = DECL_BIT_INDEX (tmp);\n+\t  /* A final local already assigned or a final parameter\n+             assigned must be reported as errors */\n+\t  if (LOCAL_FINAL (tmp) \n+\t      && (index == -1 || TREE_CODE (tmp) == PARM_DECL))\n+\t    parse_error_context (wfl, \"Can't assign here a value to the `final' variable `%s'\", IDENTIFIER_POINTER (DECL_NAME (tmp)));\n+\n \t  if (index >= 0)\n \t    SET_BIT (before, index);\n \t  /* Minor optimization.  See comment for start_current_locals. */"}, {"sha": "aea3dfd80378a707bc3e6f9ea905cc99da469eb8", "filename": "gcc/java/class.c", "status": "modified", "additions": 68, "deletions": 8, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2952b018a1baf25b12c339f2b96518425164295/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2952b018a1baf25b12c339f2b96518425164295/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=c2952b018a1baf25b12c339f2b96518425164295", "patch": "@@ -282,6 +282,7 @@ make_class ()\n #else\n   TYPE_BINFO (type) = make_tree_vec (6);\n #endif\n+  MAYBE_CREATE_TYPE_TYPE_LANG_SPECIFIC (type);\n   pop_obstacks ();\n \n   return type;\n@@ -395,6 +396,7 @@ set_super_info (access_flags, this_class, super_class, interfaces_count)\n   if (access_flags & ACC_SUPER)     CLASS_SUPER (class_decl) = 1;\n   if (access_flags & ACC_INTERFACE) CLASS_INTERFACE (class_decl) = 1;\n   if (access_flags & ACC_ABSTRACT)  CLASS_ABSTRACT (class_decl) = 1;\n+  if (access_flags & ACC_STATIC)    CLASS_STATIC (class_decl) = 1;\n }\n \n /* Return length of inheritance chain of CLAS, where java.lang.Object is 0,\n@@ -460,6 +462,27 @@ inherits_from_p (type1, type2)\n   return 0;\n }\n \n+/* Return a 1 iff TYPE1 is an enclosing context for TYPE2 */\n+\n+int\n+enclosing_context_p (type1, type2)\n+     tree type1, type2;\n+{\n+  if (!INNER_CLASS_TYPE_P (type2))\n+    return 0;\n+\n+  for (type2 = TREE_TYPE (DECL_CONTEXT (TYPE_NAME (type2)));\n+       type2; \n+       type2 = (INNER_CLASS_TYPE_P (type2) ?\n+\t\tTREE_TYPE (DECL_CONTEXT (TYPE_NAME (type2))) : NULL_TREE))\n+    {\n+      if (type2 == type1)\n+\treturn 1;\n+    }\n+\n+  return 0;\n+}\n+\n static void\n add_interface_do (basetype_vec, interface_class, i)\n      tree basetype_vec, interface_class;\n@@ -1016,6 +1039,8 @@ get_access_flags_from_decl (decl)\n \taccess_flags |= ACC_INTERFACE;\n       if (CLASS_ABSTRACT (decl))\n \taccess_flags |= ACC_ABSTRACT;\n+      if (CLASS_STATIC (decl))\n+\taccess_flags |= ACC_STATIC;\n       return access_flags;\n     }\n   if (TREE_CODE (decl) == FUNCTION_DECL)\n@@ -1457,8 +1482,7 @@ is_compiled_class (class)\n   if (class == current_class)\n     return 2;\n \n-  seen_in_zip = (TYPE_LANG_SPECIFIC (class) && TYPE_LANG_SPECIFIC (class)->jcf\n-\t\t && TYPE_LANG_SPECIFIC (class)->jcf->seen_in_zip);\n+  seen_in_zip = (TYPE_JCF (class) && TYPE_JCF (class)->seen_in_zip);\n   if (CLASS_FROM_CURRENTLY_COMPILED_SOURCE_P (class) || seen_in_zip)\n     {\n       /* The class was seen in the current ZIP file and will be\n@@ -1635,6 +1659,9 @@ push_super_field (this_class, super_class)\n      tree this_class, super_class;\n {\n   tree base_decl;\n+  /* Don't insert the field if we're just re-laying the class out. */ \n+  if (TYPE_FIELDS (this_class) && !DECL_NAME (TYPE_FIELDS (this_class)))\n+    return;\n   push_obstacks (&permanent_obstack, &permanent_obstack);\n   base_decl = build_decl (FIELD_DECL, NULL_TREE, super_class);\n   pop_obstacks ();\n@@ -1668,7 +1695,8 @@ maybe_layout_super_class (super_class, this_class)\n \tsuper_class = TREE_TYPE (super_class);\n       else\n \t{\n-\t  super_class = do_resolve_class (super_class, NULL_TREE, this_class);\n+\t  super_class = do_resolve_class (NULL_TREE, /* FIXME? */\n+\t\t\t\t\t  super_class, NULL_TREE, this_class);\n \t  if (!super_class)\n \t    return NULL_TREE;\t/* FIXME, NULL_TREE not checked by caller. */\n \t  super_class = TREE_TYPE (super_class);\n@@ -1684,15 +1712,45 @@ void\n layout_class (this_class)\n      tree this_class;\n {\n+  static tree list = NULL_TREE;\n   tree super_class = CLASSTYPE_SUPER (this_class);\n   tree field;\n+  \n+  list = tree_cons (this_class, NULL_TREE, list);\n+  if (CLASS_BEING_LAIDOUT (this_class))\n+    {\n+      char buffer [1024];\n+      tree current;\n+      \n+      sprintf (buffer, \" with `%s'\",\n+\t       IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (this_class))));\n+      obstack_grow (&temporary_obstack, buffer, strlen (buffer));\n+\n+      for (current = TREE_CHAIN (list); current; \n+\t   current = TREE_CHAIN (current))\n+\t{\n+\t  tree decl = TYPE_NAME (TREE_PURPOSE (current));\n+\t  sprintf (buffer, \"\\n  which inherits from `%s' (%s:%d)\",\n+\t\t   IDENTIFIER_POINTER (DECL_NAME (decl)),\n+\t\t   DECL_SOURCE_FILE (decl),\n+\t\t   DECL_SOURCE_LINE (decl));\n+\t  obstack_grow (&temporary_obstack, buffer, strlen (buffer));\n+\t}\n+      obstack_1grow (&temporary_obstack, '\\0');\n+      cyclic_inheritance_report = obstack_finish (&temporary_obstack);\n+      TYPE_SIZE (this_class) = error_mark_node;\n+      return;\n+    }\n+  CLASS_BEING_LAIDOUT (this_class) = 1;\n \n   if (super_class)\n     {\n       super_class = maybe_layout_super_class (super_class, this_class);\n       if (TREE_CODE (TYPE_SIZE (super_class)) == ERROR_MARK)\n \t{\n \t  TYPE_SIZE (this_class) = error_mark_node;\n+\t  CLASS_BEING_LAIDOUT (this_class) = 0;\n+\t  list = TREE_CHAIN (list);\n \t  return;\n \t}\n       if (TYPE_SIZE (this_class) == NULL_TREE)\n@@ -1714,6 +1772,9 @@ layout_class (this_class)\n   /* Convert the size back to an SI integer value */\n   TYPE_SIZE_UNIT (this_class) = \n     fold (convert (int_type_node, TYPE_SIZE_UNIT (this_class)));\n+\n+  CLASS_BEING_LAIDOUT (this_class) = 0;\n+  list = TREE_CHAIN (list);\n }\n \n void\n@@ -1772,8 +1833,7 @@ layout_class_method (this_class, super_class, method_decl, dtable_count)\n   if (method_name_is_wfl)\n     method_name = java_get_real_method_name (method_decl);\n \n-  if (method_name != init_identifier_node \n-      && method_name != finit_identifier_node)\n+  if (!ID_INIT_P (method_name) && !ID_FINIT_P (method_name))\n     {\n       int encoded_len\n \t= unicode_mangling_length (IDENTIFIER_POINTER (method_name), \n@@ -1794,7 +1854,7 @@ layout_class_method (this_class, super_class, method_decl, dtable_count)\n     }\n       \n   obstack_grow (&temporary_obstack, \"__\", 2);\n-  if (method_name == finit_identifier_node)\n+  if (ID_FINIT_P (method_name))\n     obstack_grow (&temporary_obstack, \"finit\", 5);\n   append_gpp_mangled_type (&temporary_obstack, this_class);\n   TREE_PUBLIC (method_decl) = 1;\n@@ -1856,11 +1916,11 @@ layout_class_method (this_class, super_class, method_decl, dtable_count)\n      it's an interface method that isn't clinit. */\n   if (! METHOD_ABSTRACT (method_decl) \n       || (CLASS_INTERFACE (TYPE_NAME (this_class)) \n-\t  && (IS_CLINIT (method_decl))))\n+\t  && (DECL_CLINIT_P (method_decl))))\n     make_function_rtl (method_decl);\n   obstack_free (&temporary_obstack, asm_name);\n \n-  if (method_name == init_identifier_node)\n+  if (ID_INIT_P (method_name))\n     {\n       const char *p = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (this_class)));\n       for (ptr = p; *ptr; )"}, {"sha": "d465f52ae9844ecf2acd6501fafb79bd93d69586", "filename": "gcc/java/constants.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2952b018a1baf25b12c339f2b96518425164295/gcc%2Fjava%2Fconstants.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2952b018a1baf25b12c339f2b96518425164295/gcc%2Fjava%2Fconstants.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fconstants.c?ref=c2952b018a1baf25b12c339f2b96518425164295", "patch": "@@ -390,7 +390,10 @@ alloc_class_constant (clas)\n static tree\n build_constant_data_ref ()\n {\n-  if (current_constant_pool_data_ref == NULL_TREE)\n+  if (TYPE_CPOOL_DATA_REF (current_class))\n+    current_constant_pool_data_ref = TYPE_CPOOL_DATA_REF (current_class);\n+\n+  else if (current_constant_pool_data_ref == NULL_TREE)\n     {\n       tree decl;\n       tree decl_name = mangled_classname (\"_CD_\", current_class);\n@@ -401,7 +404,7 @@ build_constant_data_ref ()\n       TREE_STATIC (decl) = 1;\n       make_decl_rtl (decl, NULL, 1);\n       pop_obstacks ();\n-      current_constant_pool_data_ref\n+      TYPE_CPOOL_DATA_REF (current_class) = current_constant_pool_data_ref\n \t= build1 (ADDR_EXPR, ptr_type_node, decl);\n     }\n   return current_constant_pool_data_ref;"}, {"sha": "b4dc28da833bb21bf9ea0c9fbf9e772a5c781e0f", "filename": "gcc/java/decl.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2952b018a1baf25b12c339f2b96518425164295/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2952b018a1baf25b12c339f2b96518425164295/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=c2952b018a1baf25b12c339f2b96518425164295", "patch": "@@ -360,7 +360,7 @@ tree length_identifier_node;\n tree this_identifier_node;\n tree super_identifier_node;\n tree continue_identifier_node;\n-\n+tree access0_identifier_node;\t/* 1.1 */\n tree end_params_node;\n \n /* References to internal libjava functions we use. */\n@@ -460,6 +460,7 @@ init_decl_processing ()\n   error_mark_node = make_node (ERROR_MARK);\n   TREE_TYPE (error_mark_node) = error_mark_node;\n \n+  initialize_sizetypes ();\n   /* Create sizetype first - needed for other types. */\n   initialize_sizetypes ();\n   set_sizetype (make_unsigned_type (POINTER_SIZE));\n@@ -601,6 +602,7 @@ init_decl_processing ()\n   this_identifier_node = get_identifier (\"this\");\n   super_identifier_node = get_identifier (\"super\");\n   continue_identifier_node = get_identifier (\"continue\");\n+  access0_identifier_node = get_identifier (\"access$0\");\n \n   /* for lack of a better place to put this stub call */\n   init_expr_processing();\n@@ -965,8 +967,9 @@ pushdecl (x)\n   register tree t;\n   register tree name = DECL_NAME (x);\n   register struct binding_level *b = current_binding_level;\n-\n-  DECL_CONTEXT (x) = current_function_decl;\n+  \n+  if (TREE_CODE (x) != TYPE_DECL)\n+    DECL_CONTEXT (x) = current_function_decl;\n   if (name)\n     {\n       const char *file;\n@@ -1629,7 +1632,6 @@ build_result_decl (fndecl)\n   return (DECL_RESULT (fndecl) = build_decl (RESULT_DECL, NULL_TREE, restype));\n }\n \n-\n /* Called for every element in DECL_FUNCTION_INIT_TEST_TABLE in order\n    to emit initialization code for each test flag.  */\n    "}, {"sha": "86c731fde63e1c3167e3701aad837f4bb5238703", "filename": "gcc/java/expr.c", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2952b018a1baf25b12c339f2b96518425164295/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2952b018a1baf25b12c339f2b96518425164295/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=c2952b018a1baf25b12c339f2b96518425164295", "patch": "@@ -1263,6 +1263,16 @@ lookup_field (typep, name)\n \tif (DECL_NAME (field) == name)\n \t  return field;\n \n+      /* If *typep is an innerclass, lookup the field in its enclosing\n+         contexts */\n+      if (INNER_CLASS_TYPE_P (*typep))\n+\t{\n+\t  tree outer_type = TREE_TYPE (DECL_CONTEXT (TYPE_NAME (*typep)));\n+\n+\t  if ((field = lookup_field (&outer_type, name)))\n+\t    return field;\n+\t}\n+\n       /* Process implemented interfaces. */\n       basetype_vec = TYPE_BINFO_BASETYPES (*typep);\n       n = TREE_VEC_LENGTH (basetype_vec);\n@@ -1721,7 +1731,7 @@ expand_invoke (opcode, method_ref_index, nargs)\n     }\n   layout_class_methods (self_type);\n \n-  if (method_name == init_identifier_node)\n+  if (ID_INIT_P (method_name))\n     method = lookup_java_constructor (CLASS_TO_HANDLE_TYPE (self_type),\n \t\t\t\t      method_signature);\n   else\n@@ -1881,7 +1891,7 @@ expand_java_field_op (is_static, is_putting, field_ref_index)\n \t\t     \"assignment to final field `%s' not in field's class\");\n \t  else if (FIELD_STATIC (field_decl))\n \t    {\n-\t      if (!IS_CLINIT (current_function_decl))\n+\t      if (!DECL_CLINIT_P (current_function_decl))\n \t\terror_with_decl (field_decl, \n              \"assignment to final static field `%s' not in class initializer\");\n \t    }\n@@ -2013,18 +2023,15 @@ java_lang_expand_expr (exp, target, tmode, modifier)\n \tif (TREE_CONSTANT (init)\n \t    && ilength >= 10 && JPRIMITIVE_TYPE_P (element_type))\n \t  {\n-\t    tree init_decl;\n-\t    push_obstacks (&permanent_obstack, &permanent_obstack);\n-\t    init_decl = build_decl (VAR_DECL, generate_name (),\n-\t\t\t\t    TREE_TYPE (init));\n+\t    tree init_decl = build_decl (VAR_DECL, generate_name (),\n+\t\t\t\t\t TREE_TYPE (init));\n \t    pushdecl_top_level (init_decl);\n \t    TREE_STATIC (init_decl) = 1;\n \t    DECL_INITIAL (init_decl) = init;\n \t    DECL_IGNORED_P (init_decl) = 1;\n \t    TREE_READONLY (init_decl) = 1;\n \t    TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (init_decl)) = 1;\n \t    make_decl_rtl (init_decl, NULL, 1);\n-\t    pop_obstacks ();\n \t    init = init_decl;\n \t  }\n \texpand_assignment (build (COMPONENT_REF, TREE_TYPE (data_fld),"}, {"sha": "ea793227a09f67fdb63ac72ca8dab550f5003cd6", "filename": "gcc/java/java-tree.def", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2952b018a1baf25b12c339f2b96518425164295/gcc%2Fjava%2Fjava-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2952b018a1baf25b12c339f2b96518425164295/gcc%2Fjava%2Fjava-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.def?ref=c2952b018a1baf25b12c339f2b96518425164295", "patch": "@@ -22,6 +22,13 @@ DEFTREECODE (UNARY_PLUS_EXPR, \"unary_plus_expr\", '1', 1)\n    Once patched, the node will bear the type of the created array.  */\n DEFTREECODE (NEW_ARRAY_EXPR, \"new_array_expr\", 'e', 3)\n \n+/* New anonymous array creation expression.\n+   Operand 0 is the base type of the anonymous array.\n+   Operand 1 is the signature of the dimensions this array contains.\n+   Operand 2 is the anonymous array initializer.\n+   Once patched, the node will bear the type of the created array.  */\n+DEFTREECODE (NEW_ANONYMOUS_ARRAY_EXPR, \"new_anonymous_array\", 'e', 3)\n+\n /* New class creation expression.\n    Operand 0 is the name of the class to be created\n    Operand 1 is the argument list used to select a constructor.\n@@ -75,3 +82,14 @@ DEFTREECODE (INSTANCEOF_EXPR, \"instanceof\", 'e', 2)\n    when the node is created.\n    Operand 1 is a CONSTRUCTOR node.  */\n DEFTREECODE (NEW_ARRAY_INIT, \"new_array_init\", '1', 1)\n+\n+/* Class literal.\n+   Operand 0 is the name of the class we're trying to build a\n+   reference from.  */\n+DEFTREECODE (CLASS_LITERAL, \"class_litteral\", '1', 1)\n+\n+/* Instance initializer.\n+   Operand 0 contains the intance initializer statement. This tree node\n+   is used for context detection, so that special rules can be\n+   enforced. */\n+DEFTREECODE (INSTANCE_INITIALIZERS_EXPR, \"instance_initializers_expr\", '1', 1)"}, {"sha": "9e550702c614ce51cc25f8c53f7dfcf35eaf1ae6", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 156, "deletions": 7, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2952b018a1baf25b12c339f2b96518425164295/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2952b018a1baf25b12c339f2b96518425164295/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=c2952b018a1baf25b12c339f2b96518425164295", "patch": "@@ -41,10 +41,13 @@ struct JCF;\n /* Usage of TREE_LANG_FLAG_?:\n    0: IS_A_SINGLE_IMPORT_CLASSFILE_NAME_P (in IDENTIFIER_NODE)\n       RESOLVE_EXPRESSION_NAME_P (in EXPR_WITH_FILE_LOCATION)\n-      IS_FOR_LOOP_P (in LOOP_EXPR)\n+      FOR_LOOP_P (in LOOP_EXPR)\n+      ANONYMOUS_CLASS_P (in RECORD_TYPE)\n+      ARG_FINAL_P (in TREE_LIST)\n    1: CLASS_HAS_SUPER_FLAG (in TREE_VEC).\n       IS_A_CLASSFILE_NAME (in IDENTIFIER_NODE)\n       COMPOUND_ASSIGN_P (in EXPR (binop_*))\n+      LOCAL_CLASS_P (in RECORD_TYPE)\n    2: RETURN_MAP_ADJUSTED (in TREE_VEC).\n       QUALIFIED_P (in IDENTIFIER_NODE)\n       PRIMARY_P (in EXPR_WITH_FILE_LOCATION)\n@@ -59,15 +62,17 @@ struct JCF;\n       IS_BREAK_STMT_P (in EXPR_WITH_FILE_LOCATION)\n       IS_CRAFTED_STRING_BUFFER_P (in CALL_EXPR)\n       IS_INIT_CHECKED (in SAVE_EXPR)\n-   6: CAN_COMPLETE_NORMALLY (in statement nodes).\n+   6: CAN_COMPLETE_NORMALLY (in statement nodes)\n+      OUTER_FIELD_ACCESS_IDENTIFIER_P (in IDENTIFIER_NODE)\n \n    Usage of TYPE_LANG_FLAG_?:\n+   0: CLASS_ACCESS0_GENERATED_P (in RECORD_TYPE)\n    1: TYPE_ARRAY_P (in RECORD_TYPE).\n    2: CLASS_LOADED_P (in RECORD_TYPE).\n    3: CLASS_FROM_SOURCE_P (in RECORD_TYPE).\n    4: CLASS_P (in RECORD_TYPE).\n    5: CLASS_FROM_CURRENTLY_COMPILED_SOURCE_P (in RECORD_TYPE)\n-   6: CLASS_HAS_FINIT_P (in RECORD_TYPE)\n+   6: CLASS_BEING_LAIDOUT (in RECORD_TYPE)\n \n    Usage of DECL_LANG_FLAG_?:\n    0: METHOD_DEPRECATED (in FUNCTION_DECL).\n@@ -82,6 +87,7 @@ struct JCF;\n    3: METHOD_FINAL (in FUNCTION_DECL)\n       FIELD_FINAL (in FIELD_DECL)\n       CLASS_FINAL (in TYPE_DECL)\n+      LOCAL_FINAL (in VAR_DECL)\n    4: METHOD_SYNCHRONIZED (in FUNCTION_DECL).\n       LABEL_IN_SUBR (in LABEL_DECL)\n       CLASS_INTERFACE (in TYPE_DECL)\n@@ -93,7 +99,11 @@ struct JCF;\n    6: METHOD_TRANSIENT (in FUNCTION_DECL)\n       LABEL_CHANGED (in LABEL_DECL)\n       CLASS_SUPER (in TYPE_DECL, ACC_SUPER flag)\n+      FIELD_LOCAL_ALIAS (in FIELD_DECL)\n    7: DECL_CONSTRUCTOR_P (in FUNCTION_DECL).\n+      CLASS_STATIC (in TYPE_DECL)\n+      FIELD_LOCAL_ALIAS_USED (in FIELD_DECL)\n+      FIELD_THISN (in FIELD_DECL)\n */\n \n /* True if the class whose TYPE_BINFO this is has a superclass.\n@@ -230,6 +240,7 @@ extern tree length_identifier_node;  /* \"length\" */\n extern tree this_identifier_node;  /* \"this\" */\n extern tree super_identifier_node;  /* \"super\" */\n extern tree continue_identifier_node;  /* \"continue\" */\n+extern tree access0_identifier_node; /* \"access$0\" */\n extern tree one_elt_array_domain_type;\n /* The type of the return address of a subroutine. */\n extern tree return_address_type_node;\n@@ -297,6 +308,10 @@ extern tree current_constant_pool_data_ref;\n \n extern tree wfl_operator;\n \n+extern char *cyclic_inheritance_report;\n+\n+extern char *cyclic_inheritance_report;\n+\n struct lang_identifier\n {\n   struct tree_identifier ignore;\n@@ -368,6 +383,14 @@ struct lang_identifier\n    calls */\n #define DECL_CONSTRUCTOR_CALLS(DECL) \\\n   (DECL_LANG_SPECIFIC(DECL)->called_constructor)\n+/* When the function is an access function, the DECL it was trying to\n+   access */\n+#define DECL_FUNCTION_ACCESS_DECL(DECL) \\\n+  (DECL_LANG_SPECIFIC(DECL)->called_constructor)\n+/* The identifier of the access method used to invoke this method from\n+   an inner class.  */\n+#define DECL_FUNCTION_INNER_ACCESS(DECL) \\\n+  (DECL_LANG_SPECIFIC(DECL)->inner_access)\n /* Pointer to the function's current's COMPOUND_EXPR tree (while\n    completing its body) or the function's block */\n #define DECL_FUNCTION_BODY(DECL) (DECL_LANG_SPECIFIC(DECL)->function_decl_body)\n@@ -380,6 +403,27 @@ struct lang_identifier\n    class has been initialized in this function, and FALSE otherwise.  */\n #define DECL_FUNCTION_INIT_TEST_TABLE(DECL) \\\n   (DECL_LANG_SPECIFIC(DECL)->init_test_table)\n+/* The Number of Artificial Parameters (NAP) DECL contains. this$<n>\n+   is excluded, because sometimes created as a parameter before the\n+   function decl exists. */\n+#define DECL_FUNCTION_NAP(DECL) (DECL_LANG_SPECIFIC(DECL)->nap)\n+\n+/* For a FIELD_DECL, holds the name of the access method used to\n+   read/write the content of the field from an inner class. \n+   The cast is ugly. FIXME  */\n+#define FIELD_INNER_ACCESS(DECL)       ((tree)DECL_LANG_SPECIFIC (DECL))\n+\n+/* True when DECL aliases an outer context local variable.  */\n+#define FIELD_LOCAL_ALIAS(DECL) DECL_LANG_FLAG_6 (DECL)\n+\n+/* True when DECL, which aliases an outer context local variable is\n+   used by the inner classe */\n+#define FIELD_LOCAL_ALIAS_USED(DECL) DECL_LANG_FLAG_7 (DECL)\n+\n+/* True when DECL is a this$<n> field. Note that\n+   FIELD_LOCAL_ALIAS_USED can be differenciated when tested against\n+   FIELD_LOCAL_ALIAS.  */\n+#define FIELD_THISN(DECL) DECL_LANG_FLAG_7 (DECL)\n \n /* In a LABEL_DECL, a TREE_VEC that saves the type_map at that point. */\n #define LABEL_TYPE_STATE(NODE) (DECL_INITIAL (NODE))\n@@ -461,7 +505,10 @@ struct lang_decl\n   tree called_constructor;\t/* When decl is a constructor, the\n \t\t\t\t   list of other constructor it calls. */\n   struct hash_table init_test_table;\n-                                /* Class initialization test variables.  */\n+\t\t\t\t/* Class initialization test variables.  */\n+  tree inner_access;\t\t/* The identifier of the access method\n+\t\t\t\t   used for invocation from inner classes */\n+  int nap;\t\t\t/* Number of artificial parameters */\n };\n \n /* init_test_table hash table entry structure.  */\n@@ -471,7 +518,6 @@ struct init_test_hash_entry\n   tree init_test_decl;\n };\n \n-\n /* DECL_LANG_SPECIFIC for VAR_DECL and PARM_DECL. */\n struct lang_decl_var\n {\n@@ -481,10 +527,32 @@ struct lang_decl_var\n   tree slot_chain;\n };\n \n+/* Macro to access fields in `struct lang_type'.  */\n+\n+#define TYPE_SIGNATURE(T) (TYPE_LANG_SPECIFIC(T)->signature)\n+#define TYPE_JCF(T) (TYPE_LANG_SPECIFIC(T)->jcf)\n+#define TYPE_CPOOL(T) (TYPE_LANG_SPECIFIC(T)->cpool)\n+#define TYPE_CPOOL_DATA_REF(T) (TYPE_LANG_SPECIFIC(T)->cpool_data_ref)\n+#define MAYBE_CREATE_TYPE_TYPE_LANG_SPECIFIC(T)\t\t\t\t\\\n+  if (TYPE_LANG_SPECIFIC ((T)) == NULL)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      TYPE_LANG_SPECIFIC ((T)) = \t\t\t\t\t\\\n+\t(struct lang_type *)xmalloc (sizeof (struct lang_type));\t\\\n+      bzero (TYPE_LANG_SPECIFIC ((T)), sizeof (struct lang_type));\t\\\n+    }\n+#define TYPE_FINIT_STMT_LIST(T)  (TYPE_LANG_SPECIFIC(T)->finit_stmt_list)\n+#define TYPE_CLINIT_STMT_LIST(T) (TYPE_LANG_SPECIFIC(T)->clinit_stmt_list)\n+#define TYPE_II_STMT_LIST(T)     (TYPE_LANG_SPECIFIC(T)->ii_block)\n+\n struct lang_type\n {\n   tree signature;\n   struct JCF *jcf;\n+  struct CPool *cpool;\n+  tree cpool_data_ref;\t\t/* Cached */\n+  tree finit_stmt_list;\t\t/* List of statements $finit$ will use */\n+  tree clinit_stmt_list;\t/* List of statements <clinit> will use  */\n+  tree ii_block;\t\t/* Instance initializer block */\n };\n \n #ifdef JAVA_USE_HANDLES\n@@ -590,6 +658,7 @@ extern void set_super_info PARAMS ((int, tree, tree, int));\n extern int get_access_flags_from_decl PARAMS ((tree));\n extern int interface_of_p PARAMS ((tree, tree));\n extern int inherits_from_p PARAMS ((tree, tree));\n+extern int enclosing_context_p PARAMS ((tree, tree));\n extern void complete_start_java_method PARAMS ((tree));\n extern tree build_result_decl PARAMS ((tree));\n extern void emit_handlers PARAMS ((void));\n@@ -690,8 +759,20 @@ struct rtx_def * java_lang_expand_expr PARAMS ((tree, rtx, enum machine_mode,\n #define METHOD_ABSTRACT(DECL) DECL_LANG_FLAG_5 (DECL)\n #define METHOD_TRANSIENT(DECL) DECL_LANG_FLAG_6 (DECL)\n \n+/* Other predicates on method decls  */\n+\n #define DECL_CONSTRUCTOR_P(DECL) DECL_LANG_FLAG_7(DECL)\n \n+#define DECL_INIT_P(DECL)   (ID_INIT_P (DECL_NAME (DECL)))\n+#define DECL_FINIT_P(DECL)  (ID_FINIT_P (DECL_NAME (DECL)))\n+#define DECL_CLINIT_P(DECL) (ID_CLINIT_P (DECL_NAME (DECL)))\n+\n+/* Predicates on method identifiers. Kept close to other macros using\n+   them  */\n+#define ID_INIT_P(ID)   ((ID) == init_identifier_node)\n+#define ID_FINIT_P(ID)  ((ID) == finit_identifier_node)\n+#define ID_CLINIT_P(ID) ((ID) == clinit_identifier_node)\n+\n /* Access flags etc for a variable/field (a FIELD_DECL): */\n \n #define FIELD_PRIVATE(DECL) TREE_PRIVATE (DECL)\n@@ -701,6 +782,7 @@ struct rtx_def * java_lang_expand_expr PARAMS ((tree, rtx, enum machine_mode,\n #define FIELD_FINAL(DECL) DECL_LANG_FLAG_3 (DECL)\n #define FIELD_VOLATILE(DECL) DECL_LANG_FLAG_4 (DECL)\n #define FIELD_TRANSIENT(DECL) DECL_LANG_FLAG_5 (DECL)\n+#define LOCAL_FINAL(DECL) FIELD_FINAL(DECL)\n \n /* Access flags etc for a class (a TYPE_DECL): */\n \n@@ -709,6 +791,7 @@ struct rtx_def * java_lang_expand_expr PARAMS ((tree, rtx, enum machine_mode,\n #define CLASS_INTERFACE(DECL) DECL_LANG_FLAG_4 (DECL)\n #define CLASS_ABSTRACT(DECL) DECL_LANG_FLAG_5 (DECL)\n #define CLASS_SUPER(DECL) DECL_LANG_FLAG_6 (DECL)\n+#define CLASS_STATIC(DECL) DECL_LANG_FLAG_7 (DECL)\n \n /* @deprecated marker flag on methods, fields and classes */\n \n@@ -794,6 +877,9 @@ extern tree *type_map;\n #define TYPE_IS_WIDE(TYPE) \\\n   ((TYPE) == double_type_node || (TYPE) == long_type_node)\n \n+/* True iif CLASS has it's access$0 method generated.  */\n+#define CLASS_ACCESS0_GENERATED_P(CLASS) TYPE_LANG_FLAG_0 (CLASS)\n+\n /* True iff TYPE is a Java array type. */\n #define TYPE_ARRAY_P(TYPE) TYPE_LANG_FLAG_1 (TYPE)\n \n@@ -817,8 +903,18 @@ extern tree *type_map;\n #define CLASS_FROM_CURRENTLY_COMPILED_SOURCE_P(TYPE) \\\n   TYPE_LANG_FLAG_5 (TYPE)\n \n+/* True if class TYPE is currently being laid out. Helps in detection\n+   of inheritance cycle occuring as a side effect of performing the\n+   layout of a class.  */\n+#define CLASS_BEING_LAIDOUT(TYPE) TYPE_LANG_FLAG_6 (TYPE)\n+\n+/* True if class TYPE is currently being laid out. Helps in detection\n+   of inheritance cycle occuring as a side effect of performing the\n+   layout of a class.  */\n+#define CLASS_BEING_LAIDOUT(TYPE) TYPE_LANG_FLAG_6 (TYPE)\n+\n /* True if class TYPE has a field initializer $finit$ function */\n-#define CLASS_HAS_FINIT_P(TYPE) TYPE_LANG_FLAG_6 (TYPE)\n+#define CLASS_HAS_FINIT_P(TYPE) TYPE_FINIT_STMT_LIST (TYPE)\n \n /* True if identifier ID was seen while processing a single type import stmt */\n #define IS_A_SINGLE_IMPORT_CLASSFILE_NAME_P(ID) TREE_LANG_FLAG_0 (ID)\n@@ -856,7 +952,17 @@ extern tree *type_map;\n #define RESOLVE_EXPRESSION_NAME_P(WFL) TREE_LANG_FLAG_0 (WFL)\n \n /* True if EXPR (a LOOP_EXPR in that case) is part of a for statement */\n-#define IS_FOR_LOOP_P(EXPR) TREE_LANG_FLAG_0 (EXPR)\n+#define FOR_LOOP_P(EXPR) TREE_LANG_FLAG_0 (EXPR)\n+\n+/* True if NODE (a RECORD_TYPE in that case) is an anonymous class.  */\n+#define ANONYMOUS_CLASS_P(NODE) TREE_LANG_FLAG_0 (NODE)\n+\n+/* True if NODE (a RECORD_TYPE in that case) is a block local class.  */\n+#define LOCAL_CLASS_P(NODE) TREE_LANG_FLAG_1 (NODE)\n+\n+/* True if NODE (a TREE_LIST) hold a pair of argument name/type\n+   declared with the final modifier */\n+#define ARG_FINAL_P(NODE) TREE_LANG_FLAG_0 (NODE)\n \n /* True if EXPR (a WFL in that case) resolves into a package name */\n #define RESOLVE_PACKAGE_NAME_P(WFL) TREE_LANG_FLAG_3 (WFL)\n@@ -880,6 +986,49 @@ extern tree *type_map;\n /* True if NODE (a statement) can complete normally. */\n #define CAN_COMPLETE_NORMALLY(NODE) TREE_LANG_FLAG_6(NODE)\n \n+/* True if NODE (an IDENTIFIER) bears the name of a outer field from\n+   inner class access function.  */\n+#define OUTER_FIELD_ACCESS_IDENTIFIER_P(NODE) TREE_LANG_FLAG_6(NODE)\n+\n+/* Non null if NODE belongs to an inner class TYPE_DECL node.\n+   Verifies that NODE as the attributes of a decl.  */\n+#define INNER_CLASS_DECL_P(NODE) (TYPE_NAME (TREE_TYPE (NODE)) == NODE\t\\\n+\t\t\t\t  && DECL_CONTEXT (NODE))\n+\n+/* Non null if NODE is an top level class TYPE_DECL node: NODE isn't\n+   an inner class or NODE is a static class.  */\n+#define TOPLEVEL_CLASS_DECL_P(NODE) (!INNER_CLASS_DECL_P (NODE) \t\\\n+\t\t\t\t     || CLASS_STATIC (NODE))\n+\n+/* True if the class decl NODE was declared in a inner scope and is\n+   not a toplevel class */\n+#define PURE_INNER_CLASS_DECL_P(NODE) \\\n+  (INNER_CLASS_DECL_P (NODE) && !CLASS_STATIC (NODE))\n+\n+/* Non null if NODE belongs to an inner class RECORD_TYPE node. Checks\n+   that TYPE_NAME bears a decl. An array type wouldn't.  */\n+#define INNER_CLASS_TYPE_P(NODE) (TREE_CODE (TYPE_NAME (NODE)) == TYPE_DECL \\\n+\t\t\t\t  && DECL_CONTEXT (TYPE_NAME (NODE)))\n+\n+#define TOPLEVEL_CLASS_TYPE_P(NODE) (!INNER_CLASS_TYPE_P (NODE) \t\\\n+\t\t\t\t     || CLASS_STATIC (TYPE_NAME (NODE)))\n+\n+/* True if the class type NODE was declared in a inner scope and is\n+   not a toplevel class */\n+#define PURE_INNER_CLASS_TYPE_P(NODE) \\\n+  (INNER_CLASS_TYPE_P (NODE) && !CLASS_STATIC (TYPE_NAME (NODE)))\n+\n+/* Non null if NODE (a TYPE_DECL or a RECORD_TYPE) is an inner class.  */\n+#define INNER_CLASS_P(NODE) (TREE_CODE (NODE) == TYPE_DECL ? \t\t      \\\n+\t\t\t     INNER_CLASS_DECL_P (NODE) :\t\t      \\\n+\t\t\t     (TREE_CODE (NODE) == RECORD_TYPE ? \t      \\\n+\t\t\t      INNER_CLASS_TYPE_P (NODE) : \t\t      \\\n+\t\t\t      (fatal (\"INNER_CLASS_P: Wrong node type\"), 0)))\n+\n+/* On a TYPE_DECL, hold the list of inner classes defined within the\n+   scope of TYPE_DECL.  */\n+#define DECL_INNER_CLASS_LIST(NODE) DECL_INITIAL (NODE)\n+\n /* Add a FIELD_DECL to RECORD_TYPE RTYPE.\n    The field has name NAME (a char*), and type FTYPE.\n    Unless this is the first field, FIELD most hold the previous field."}, {"sha": "dfff14e6beb0e6316c3a9abb324a56e3cfd97741", "filename": "gcc/java/jcf-dump.c", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2952b018a1baf25b12c339f2b96518425164295/gcc%2Fjava%2Fjcf-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2952b018a1baf25b12c339f2b96518425164295/gcc%2Fjava%2Fjcf-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-dump.c?ref=c2952b018a1baf25b12c339f2b96518425164295", "patch": "@@ -294,6 +294,38 @@ DEFUN(utf8_equal_string, (jcf, index, value),\n   else \\\n     JCF_SKIP (jcf, 4 * n); }\n \n+#define HANDLE_INNERCLASSES_ATTRIBUTE(COUNT)\t\t\t\t    \\\n+{ int n = (COUNT);\t\t\t\t\t\t\t    \\\n+  COMMON_HANDLE_ATTRIBUTE(jcf, attribute_name, attribute_length);\t    \\\n+  while (n--)\t\t\t\t\t\t\t\t    \\\n+    {\t\t\t\t\t\t\t\t\t    \\\n+      uint16 inner_class_info_index = JCF_readu2 (jcf);\t\t\t    \\\n+      uint16 outer_class_info_index = JCF_readu2 (jcf);\t\t\t    \\\n+      uint16 inner_name_index = JCF_readu2 (jcf);\t\t\t    \\\n+      uint16 inner_class_access_flags = JCF_readu2 (jcf);\t\t    \\\n+\t\t\t\t\t\t\t\t\t    \\\n+      if (flag_print_class_info)\t\t\t\t\t    \\\n+\t{\t\t\t\t\t\t\t\t    \\\n+\t  fprintf (out, \"\\n  class: \");\t\t\t\t\t    \\\n+\t  if (flag_print_constant_pool)\t\t\t\t\t    \\\n+\t    fprintf (out, \"%d=\", inner_class_info_index);\t\t    \\\n+\t  print_constant_terse (out, jcf,\t\t\t\t    \\\n+\t\t\t\tinner_class_info_index, CONSTANT_Class);    \\\n+\t  fprintf (out, \" (%d=\", inner_name_index);\t\t\t    \\\n+\t  print_constant_terse (out, jcf, inner_name_index, CONSTANT_Utf8); \\\n+\t  fprintf (out, \"), access flags: 0x%x\", inner_class_access_flags); \\\n+\t  print_access_flags (out, inner_class_access_flags, 'c');\t    \\\n+\t  fprintf (out, \", outer class: \");\t\t\t\t    \\\n+\t  if (flag_print_constant_pool)\t\t\t\t\t    \\\n+\t    fprintf (out, \"%d=\", outer_class_info_index);\t\t    \\\n+\t  print_constant_terse (out, jcf,\t\t\t\t    \\\n+\t\t\t\touter_class_info_index, CONSTANT_Class);    \\\n+\t}\t\t\t\t\t\t\t\t    \\\n+    }\t\t\t\t\t\t\t\t\t    \\\n+      if (flag_print_class_info)\t\t\t\t\t    \\\n+\tfputc ('\\n', out);\t\t\t\t\t\t    \\\n+}\n+\n #define PROCESS_OTHER_ATTRIBUTE(JCF, INDEX, LENGTH) \\\n { COMMON_HANDLE_ATTRIBUTE(JCF, INDEX, LENGTH); \\\n   fputc ('\\n', out); JCF_SKIP (JCF, LENGTH); }"}, {"sha": "09991eb818ed86a8d5f597462b8cdd665d00d9fd", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 41, "deletions": 17, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2952b018a1baf25b12c339f2b96518425164295/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2952b018a1baf25b12c339f2b96518425164295/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=c2952b018a1baf25b12c339f2b96518425164295", "patch": "@@ -185,6 +185,32 @@ set_source_filename (jcf, index)\n   DECL_FUNCTION_THROWS (current_method) = nreverse (list); \\\n }\n \n+/* Link seen inner classes to their outer context and register the\n+   inner class to its outer context. They will be later loaded.  */\n+#define HANDLE_INNERCLASSES_ATTRIBUTE(COUNT)\t\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  int c = (count);\t\t\t\t\t\t\t  \\\n+  while (c--)\t\t\t\t\t\t\t\t  \\\n+    {\t\t\t\t\t\t\t\t\t  \\\n+      tree class = get_class_constant (jcf, JCF_readu2 (jcf));\t    \t  \\\n+      if (!CLASS_COMPLETE_P (class))\t\t\t\t\t  \\\n+\t{\t\t\t\t\t\t\t\t  \\\n+\t  tree outer = TYPE_NAME (get_class_constant (jcf, \t\t  \\\n+\t\t\t\t\t\t      JCF_readu2 (jcf))); \\\n+\t  tree alias = get_name_constant (jcf, JCF_readu2 (jcf));\t  \\\n+\t  tree decl = TYPE_NAME (class);\t\t\t\t  \\\n+\t  JCF_SKIP (jcf, 2);\t\t\t\t\t     \t  \\\n+\t  IDENTIFIER_GLOBAL_VALUE (alias) = decl;\t     \t\t  \\\n+\t  DECL_CONTEXT (decl) = outer;\t\t\t\t\t  \\\n+\t  DECL_INNER_CLASS_LIST (outer) = \t\t\t\t  \\\n+\t    tree_cons (decl, alias, DECL_INNER_CLASS_LIST (outer));\t  \\\n+\t  CLASS_COMPLETE_P (class) = 1;\t\t\t\t\t  \\\n+\t}\t\t\t\t\t\t\t\t  \\\n+      else\t\t\t\t\t\t\t\t  \\\n+\tJCF_SKIP (jcf, 6);\t\t\t\t\t\t  \\\n+    }\t\t\t\t\t\t\t\t\t  \\\n+}\n+\n #include \"jcf-reader.c\"\n \n static int yydebug;\n@@ -565,6 +591,7 @@ jcf_parse (jcf)\n      JCF* jcf;\n {\n   int i, code;\n+  tree current;\n \n   if (jcf_parse_preamble (jcf) != 0)\n     fatal (\"Not a valid Java .class file.\\n\");\n@@ -617,23 +644,21 @@ jcf_parse (jcf)\n   else\n     all_class_list = tree_cons (NULL_TREE, \n \t\t\t\tTYPE_NAME (current_class), all_class_list );\n+\n+  /* And if we came accross inner classes, load them now. */\n+  for (current = DECL_INNER_CLASS_LIST (TYPE_NAME (current_class)); current;\n+       current = TREE_CHAIN (current))\n+    load_class (DECL_NAME (TREE_PURPOSE (current)), 1);\n+\n   pop_obstacks ();\n }\n \n void\n init_outgoing_cpool ()\n {\n-  current_constant_pool_data_ref = NULL_TREE; \n-  if (outgoing_cpool == NULL)\n-    {\n-      static CPool outgoing_cpool_buffer;\n-      outgoing_cpool = &outgoing_cpool_buffer;\n-      CPOOL_INIT(outgoing_cpool);\n-    }\n-  else\n-    {\n-      CPOOL_REINIT(outgoing_cpool);\n-    }\n+  current_constant_pool_data_ref = NULL_TREE;\n+  outgoing_cpool = (struct CPool *)xmalloc (sizeof (struct CPool));\n+  bzero (outgoing_cpool, sizeof (struct CPool));\n }\n \n static void\n@@ -737,6 +762,7 @@ parse_source_file (file)\n   java_parse_abort_on_error ();\n   java_fix_constructors ();\t    /* Fix the constructors */\n   java_parse_abort_on_error ();\n+  java_reorder_fields ();\t    /* Reorder the fields */\n }\n \n static int\n@@ -893,7 +919,7 @@ parse_zip_file_entries (void)\n \tcontinue;\n \n       class = lookup_class (get_identifier (ZIPDIR_FILENAME (zdir)));\n-      current_jcf = TYPE_LANG_SPECIFIC (class)->jcf;\n+      current_jcf = TYPE_JCF (class);\n       current_class = class;\n \n       if ( !CLASS_LOADED_P (class))\n@@ -970,9 +996,7 @@ static void process_zip_dir()\n       jcf->classname   = class_name;\n       jcf->filename    = file_name;\n \n-      TYPE_LANG_SPECIFIC (class) = \n-        (struct lang_type *) perm_calloc (1, sizeof (struct lang_type));\n-      TYPE_LANG_SPECIFIC (class)->jcf = jcf;\n+      TYPE_JCF (class) = jcf;\n     }\n }\n \n@@ -994,10 +1018,10 @@ DEFUN(find_in_current_zip, (name, length, jcf),\n   class = TREE_TYPE (icv);\n \n   /* Doesn't have jcf specific info ? It's not ours */\n-  if (!TYPE_LANG_SPECIFIC (class) || !TYPE_LANG_SPECIFIC (class)->jcf)\n+  if (!TYPE_JCF (class))\n     return 0;\n \n-  *jcf = local_jcf = TYPE_LANG_SPECIFIC (class)->jcf;\n+  *jcf = local_jcf = TYPE_JCF (class);\n   fseek (local_jcf->read_state, local_jcf->zip_offset, SEEK_SET);\n   return 1;\n }"}, {"sha": "3e63bc5b988753392cbd4df1e3491d01d66a1177", "filename": "gcc/java/jcf-path.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2952b018a1baf25b12c339f2b96518425164295/gcc%2Fjava%2Fjcf-path.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2952b018a1baf25b12c339f2b96518425164295/gcc%2Fjava%2Fjcf-path.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-path.c?ref=c2952b018a1baf25b12c339f2b96518425164295", "patch": "@@ -34,6 +34,15 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #define GET_ENV_PATH_LIST(VAR,NAME)\tdo { (VAR) = getenv (NAME); } while (0)\n #endif\n \n+/* By default, colon separates directories in a path.  */\n+#ifndef PATH_SEPARATOR\n+#define PATH_SEPARATOR ':'\n+#endif\n+\n+#ifndef DIR_SEPARATOR\n+#define DIR_SEPARATOR '/'\n+#endif\n+\n #ifndef DIR_UP\n #define DIR_UP \"..\"\n #endif"}, {"sha": "878c4de86b1a968d9efbca6df30b5ce385a5364c", "filename": "gcc/java/jcf-reader.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2952b018a1baf25b12c339f2b96518425164295/gcc%2Fjava%2Fjcf-reader.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2952b018a1baf25b12c339f2b96518425164295/gcc%2Fjava%2Fjcf-reader.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-reader.c?ref=c2952b018a1baf25b12c339f2b96518425164295", "patch": "@@ -129,6 +129,14 @@ DEFUN(get_attribute, (jcf),\n       HANDLE_LOCALVARIABLETABLE_ATTRIBUTE (count);\n     }\n   else\n+#endif\n+#ifdef HANDLE_INNERCLASSES_ATTRIBUTE\n+  if (name_length == 12 && memcmp (name_data, \"InnerClasses\", 12) == 0)\n+    {\n+      uint16 count = JCF_readu2 (jcf);\n+      HANDLE_INNERCLASSES_ATTRIBUTE (count);\n+    }\n+  else\n #endif\n     {\n #ifdef PROCESS_OTHER_ATTRIBUTE"}, {"sha": "4eccf254c57d3a4016e592a56acd7ab2eb6ef4c8", "filename": "gcc/java/jcf-write.c", "status": "modified", "additions": 155, "deletions": 15, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2952b018a1baf25b12c339f2b96518425164295/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2952b018a1baf25b12c339f2b96518425164295/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=c2952b018a1baf25b12c339f2b96518425164295", "patch": "@@ -35,6 +35,10 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #include \"buffer.h\"\n #include \"toplev.h\"\n \n+#ifndef DIR_SEPARATOR\n+#define DIR_SEPARATOR '/'\n+#endif\n+\n extern struct obstack temporary_obstack;\n \n /* Base directory in which `.class' files should be written.\n@@ -335,6 +339,9 @@ static void emit_goto PARAMS ((struct jcf_block *, struct jcf_partial *));\n static void emit_jsr PARAMS ((struct jcf_block *, struct jcf_partial *));\n static void call_cleanups PARAMS ((struct jcf_block *, struct jcf_partial *));\n static char *make_class_file_name PARAMS ((tree));\n+static unsigned char *append_synthetic_attribute PARAMS ((struct jcf_partial *));\n+static void append_innerclasses_attribute PARAMS ((struct jcf_partial *, tree));\n+static void append_innerclasses_attribute_entry PARAMS ((struct jcf_partial *, tree, tree));\n \n /* Utility macros for appending (big-endian) data to a buffer.\n    We assume a local variable 'ptr' points into where we want to\n@@ -665,6 +672,11 @@ get_access_flags (decl)\n \tflags |= ACC_ABSTRACT;\n       if (CLASS_INTERFACE (decl))\n \tflags |= ACC_INTERFACE;\n+      if (CLASS_STATIC (decl))\n+\tflags |= ACC_STATIC;\n+      if (ANONYMOUS_CLASS_P (TREE_TYPE (decl))\n+\t  || LOCAL_CLASS_P (TREE_TYPE (decl)))\n+\tflags |= ACC_PRIVATE;\n     }\n   else\n     fatal (\"internal error - bad argument to get_access_flags\");\n@@ -1159,8 +1171,7 @@ generate_bytecode_conditional (exp, true_label, false_label,\n       }\n       break;\n     case TRUTH_NOT_EXPR:\n-      generate_bytecode_conditional (TREE_OPERAND (exp, 0), \n-\t\t\t\t     false_label, true_label,\n+      generate_bytecode_conditional (TREE_OPERAND (exp, 0), false_label, true_label,\n \t\t\t\t     ! true_branch_first, state);\n       break;\n     case TRUTH_ANDIF_EXPR:\n@@ -1238,7 +1249,7 @@ generate_bytecode_conditional (exp, true_label, false_label,\n \t    }\n \t  if (integer_zerop (exp1) || integer_zerop (exp0))\n \t    {\n-\t      generate_bytecode_insns (integer_zerop (exp1) ? exp0 : exp1,\n+\t      generate_bytecode_insns (integer_zerop (exp1) ? exp0 : exp0,\n \t\t\t\t       STACK_TARGET, state);\n \t      op = op + (OPCODE_ifnull - OPCODE_if_acmpeq);\n \t      negop = (op & 1) ? op - 1 : op + 1;\n@@ -1622,7 +1633,6 @@ generate_bytecode_insns (exp, target, state)\n \tdefine_jcf_label (else_label, state);\n \tgenerate_bytecode_insns (TREE_OPERAND (exp, 2), target, state);\n \tdefine_jcf_label (end_label, state);\n-\n \t/* COND_EXPR can be used in a binop. The stack must be adjusted. */\n \tif (TREE_TYPE (exp) != void_type_node)\n \t  NOTE_POP (TYPE_IS_WIDE (TREE_TYPE (exp)) ? 2 : 1);\n@@ -2131,6 +2141,9 @@ generate_bytecode_insns (exp, target, state)\n \tOP2 (index);\n       }\n       break;\n+    case SAVE_EXPR:\n+      generate_bytecode_insns (TREE_OPERAND (exp, 0), STACK_TARGET, state);\n+      break;\n     case CONVERT_EXPR:\n     case NOP_EXPR:\n     case FLOAT_EXPR:\n@@ -2535,11 +2548,6 @@ generate_bytecode_insns (exp, target, state)\n \t    else\n \t      OP1 (OPCODE_invokevirtual);\n \t    OP2 (index);\n-\t    if (interface)\n-\t      {\n-\t\tOP1 (nargs);\n-\t\tOP1 (0);\n-\t      }\n \t    f = TREE_TYPE (TREE_TYPE (f));\n \t    if (TREE_CODE (f) != VOID_TYPE)\n \t      {\n@@ -2549,6 +2557,11 @@ generate_bytecode_insns (exp, target, state)\n \t\telse\n \t\t  NOTE_PUSH (size);\n \t      }\n+\t    if (interface)\n+\t      {\n+\t\tOP1 (nargs);\n+\t\tOP1 (0);\n+\t      }\n \t    break;\n \t  }\n       }\n@@ -2836,16 +2849,24 @@ generate_classfile (clas, state)\n \n   for (part = TYPE_FIELDS (clas);  part;  part = TREE_CHAIN (part))\n     {\n-      int have_value;\n+      int have_value, attr_count = 0;\n       if (DECL_NAME (part) == NULL_TREE || DECL_ARTIFICIAL (part))\n \tcontinue;\n       ptr = append_chunk (NULL, 8, state);\n       i = get_access_flags (part);  PUT2 (i);\n       i = find_utf8_constant (&state->cpool, DECL_NAME (part));  PUT2 (i);\n-      i = find_utf8_constant (&state->cpool, build_java_signature (TREE_TYPE (part)));\n+      i = find_utf8_constant (&state->cpool, \n+\t\t\t      build_java_signature (TREE_TYPE (part)));\n       PUT2(i);\n-      have_value = DECL_INITIAL (part) != NULL_TREE && FIELD_STATIC (part);\n-      PUT2 (have_value);  /* attributes_count */\n+      have_value = DECL_INITIAL (part) != NULL_TREE && FIELD_STATIC (part)\n+\t&& TREE_CODE (TREE_TYPE (part)) != POINTER_TYPE;\n+      if (have_value)\n+\tattr_count++;\n+\n+      if (FIELD_THISN (part) || FIELD_LOCAL_ALIAS (part))\n+\tattr_count++;\n+\n+      PUT2 (attr_count);  /* attributes_count */\n       if (have_value)\n \t{\n \t  tree init = DECL_INITIAL (part);\n@@ -2858,6 +2879,9 @@ generate_classfile (clas, state)\n \t  PUT4 (2); /* attribute_length */\n \t  i = find_constant_index (init, state);  PUT2 (i);\n \t}\n+      /* Emit the \"Synthetic\" attribute for val$<x> and this$<n> fields. */\n+      if (FIELD_THISN (part) || FIELD_LOCAL_ALIAS (part))\n+\tptr = append_synthetic_attribute (state);\n       fields_count++;\n     }\n   ptr = fields_count_ptr;  UNSAFE_PUT2 (fields_count);\n@@ -2875,14 +2899,28 @@ generate_classfile (clas, state)\n \t: DECL_NAME (part);\n       tree type = TREE_TYPE (part);\n       tree save_function = current_function_decl;\n+      int synthetic_p = 0;\n       current_function_decl = part;\n       ptr = append_chunk (NULL, 8, state);\n       i = get_access_flags (part);  PUT2 (i);\n       i = find_utf8_constant (&state->cpool, name);  PUT2 (i);\n       i = find_utf8_constant (&state->cpool, build_java_signature (type));\n       PUT2 (i);\n       i = (body != NULL_TREE) + (DECL_FUNCTION_THROWS (part) != NULL_TREE);\n+\n+      /* Make room for the Synthetic attribute (of zero length.)  */\n+      if (DECL_FINIT_P (part) \n+\t  || OUTER_FIELD_ACCESS_IDENTIFIER_P (DECL_NAME (part)))\n+\t{\n+\t  i++;\n+\t  synthetic_p = 1;\n+\t}\n+\n       PUT2 (i);   /* attributes_count */\n+\n+      if (synthetic_p)\n+\tptr = append_synthetic_attribute (state);\n+\n       if (body != NULL_TREE)\n \t{\n \t  int code_attributes_count = 0;\n@@ -2956,7 +2994,8 @@ generate_classfile (clas, state)\n \t  if (state->linenumber_count > 0)\n \t    {\n \t      static tree LineNumberTable_node = NULL_TREE;\n-\t      ptr = append_chunk (NULL, 8 + 4 * state->linenumber_count, state);\n+\t      ptr = append_chunk (NULL, \n+\t\t\t\t  8 + 4 * state->linenumber_count, state);\n \t      if (LineNumberTable_node == NULL_TREE)\n \t\tLineNumberTable_node = get_identifier (\"LineNumberTable\");\n \t      i = find_utf8_constant (&state->cpool, LineNumberTable_node);\n@@ -3031,7 +3070,10 @@ generate_classfile (clas, state)\n \tsource_file = ptr+1;\n     }\n   ptr = append_chunk (NULL, 10, state);\n-  PUT2 (1);  /* attributes_count */\n+\n+  i = ((INNER_CLASS_TYPE_P (clas) \n+\t|| DECL_INNER_CLASS_LIST (TYPE_NAME (clas))) ? 2 : 1);\n+  PUT2 (i);\t\t\t/* attributes_count */\n \n   /* generate the SourceFile attribute. */\n   if (SourceFile_node == NULL_TREE) \n@@ -3041,6 +3083,7 @@ generate_classfile (clas, state)\n   PUT4 (2);\n   i = find_utf8_constant (&state->cpool, get_identifier (source_file));\n   PUT2 (i);\n+  append_innerclasses_attribute (state, clas);\n \n   /* New finally generate the contents of the constant pool chunk. */\n   i = count_constant_pool_bytes (&state->cpool);\n@@ -3051,6 +3094,103 @@ generate_classfile (clas, state)\n   return state->first;\n }\n \n+static unsigned char *\n+append_synthetic_attribute (state)\n+     struct jcf_partial *state;\n+{\n+  static tree Synthetic_node = NULL_TREE;\n+  unsigned char *ptr = append_chunk (NULL, 6, state);\n+  int i;\n+\n+  if (Synthetic_node == NULL_TREE)\n+    Synthetic_node = get_identifier (\"Synthetic\");\n+  i = find_utf8_constant (&state->cpool, Synthetic_node);\n+  PUT2 (i);\t\t/* Attribute string index */\n+  PUT4 (0);\t\t/* Attribute length */\n+\n+  return ptr;\n+}\n+\n+static void\n+append_innerclasses_attribute (state, class)\n+     struct jcf_partial *state;\n+     tree class;\n+{\n+  static tree InnerClasses_node = NULL_TREE;\n+  tree orig_decl = TYPE_NAME (class);\n+  tree current, decl;\n+  int length = 0, i;\n+  unsigned char *ptr, *length_marker, *number_marker;\n+\n+  if (!INNER_CLASS_TYPE_P (class) && !DECL_INNER_CLASS_LIST (orig_decl))\n+    return;\n+\n+  ptr = append_chunk (NULL, 8, state); /* 2+4+2 */\n+  \n+  if (InnerClasses_node == NULL_TREE)\n+    InnerClasses_node = get_identifier (\"InnerClasses\");\n+  i = find_utf8_constant (&state->cpool, InnerClasses_node);\n+  PUT2 (i);\n+  length_marker = ptr; PUT4 (0); /* length, to be later patched */\n+  number_marker = ptr; PUT2 (0); /* number of classes, tblp */\n+\n+  /* Generate the entries: all inner classes visible from the one we\n+     process: itself, up and down. */\n+  while (class && INNER_CLASS_TYPE_P (class))\n+    {\n+      char *n;\n+\n+      decl = TYPE_NAME (class);\n+      n = IDENTIFIER_POINTER (DECL_NAME (decl)) + \n+\tIDENTIFIER_LENGTH (DECL_NAME (decl));\n+\n+      while (n[-1] != '$')\n+\tn--;\n+      append_innerclasses_attribute_entry (state, decl, get_identifier (n));\n+      length++;\n+\n+      class = TREE_TYPE (DECL_CONTEXT (TYPE_NAME (class)));\n+    }\n+\n+  decl = orig_decl;\n+  for (current = DECL_INNER_CLASS_LIST (decl); \n+       current; current = TREE_CHAIN (current))\n+    {\n+      append_innerclasses_attribute_entry (state, TREE_PURPOSE (current),\n+\t\t\t\t\t   TREE_VALUE (current));\n+      length++;\n+    }\n+  \n+  ptr = length_marker; PUT4 (8*length+2);\n+  ptr = number_marker; PUT2 (length);\n+}\n+\n+static void\n+append_innerclasses_attribute_entry (state, decl, name)\n+     struct jcf_partial *state;\n+     tree decl, name;\n+{\n+  static tree anonymous_name = NULL_TREE;\n+  int icii, ocii, ini, icaf;\n+  unsigned char *ptr = append_chunk (NULL, 8, state);\n+\n+  if (!anonymous_name)\n+    anonymous_name = get_identifier (\"\");\n+  \n+  icii = find_class_constant (&state->cpool, TREE_TYPE (decl));\n+  ocii = find_class_constant (&state->cpool, TREE_TYPE (DECL_CONTEXT (decl))); \n+\n+  /* The specs are saying that if the class is anonymous,\n+     inner_name_index must be zero. But the implementation makes it\n+     point to an empty string. */\n+  ini = find_utf8_constant (&state->cpool,\n+\t\t\t    (ANONYMOUS_CLASS_P (TREE_TYPE (decl)) ? \n+\t\t\t     anonymous_name : name));\n+  icaf = get_access_flags (decl);\n+  \n+  PUT2 (icii); PUT2 (ocii); PUT2 (ini);  PUT2 (icaf);\n+}\n+\n static char *\n make_class_file_name (clas)\n      tree clas;"}, {"sha": "d11cee1915c5ba37592d7d459546c43f380aba4e", "filename": "gcc/java/lang.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2952b018a1baf25b12c339f2b96518425164295/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2952b018a1baf25b12c339f2b96518425164295/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=c2952b018a1baf25b12c339f2b96518425164295", "patch": "@@ -413,7 +413,7 @@ put_decl_node (node)\n \t}\n #endif\n       if (TREE_CODE (node) == FUNCTION_DECL\n-\t  && DECL_NAME (node) == init_identifier_node\n+\t  && DECL_INIT_P (node)\n \t  && !DECL_ARTIFICIAL (node) && current_class)\n \tput_decl_node (TYPE_NAME (current_class));\n       else"}, {"sha": "c5de7ed66a063a9ecdd1e12a8280c285f50e496b", "filename": "gcc/java/lex.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2952b018a1baf25b12c339f2b96518425164295/gcc%2Fjava%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2952b018a1baf25b12c339f2b96518425164295/gcc%2Fjava%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.c?ref=c2952b018a1baf25b12c339f2b96518425164295", "patch": "@@ -72,6 +72,10 @@ java_init_lex ()\n     java_lang_id = get_identifier (\"java.lang\");\n   if (!java_lang_cloneable)\n     java_lang_cloneable = get_identifier (\"java.lang.Cloneable\");\n+  if (!inst_id)\n+    inst_id = get_identifier (\"inst$\");\n+  if (!wpv_id)\n+    wpv_id = get_identifier (\"write_parm_value$\");\n \n   if (!java_lang_imported)\n     {\n@@ -95,9 +99,9 @@ java_init_lex ()\n   if (!wfl_to_string)\n     wfl_to_string = build_expr_wfl (get_identifier (\"toString\"), NULL, 0, 0);\n \n-  ctxp->static_initialized = ctxp->non_static_initialized = \n-    ctxp->incomplete_class = NULL_TREE;\n-  \n+  CPC_INITIALIZER_LIST (ctxp) = CPC_STATIC_INITIALIZER_LIST (ctxp) =\n+    CPC_INSTANCE_INITIALIZER_LIST (ctxp) = ctxp->incomplete_class = NULL_TREE;\n+\n   bzero ((PTR) ctxp->modifier_ctx, 11*sizeof (ctxp->modifier_ctx[0]));\n   bzero ((PTR) current_jcf, sizeof (JCF));\n   ctxp->current_parsed_class = NULL;"}, {"sha": "e54df393989d83ae62a52814aa22e95e1e6c19cc", "filename": "gcc/java/mangle.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2952b018a1baf25b12c339f2b96518425164295/gcc%2Fjava%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2952b018a1baf25b12c339f2b96518425164295/gcc%2Fjava%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fmangle.c?ref=c2952b018a1baf25b12c339f2b96518425164295", "patch": "@@ -56,7 +56,7 @@ unicode_mangling_length (name, len)\n \tneed_escapes += num_chars == 0;\n       else if (ch == '_')\n \tunderscores++;\n-      else if ((ch < 'a' || ch > 'z') && (ch < 'A' || ch > 'Z'))\n+      else if (ch != '$' && (ch < 'a' || ch > 'z') && (ch < 'A' || ch > 'Z'))\n \tneed_escapes++;\n       num_chars++;\n     }"}, {"sha": "15a43605b813c107778e062bf95acc7339696957", "filename": "gcc/java/parse.c", "status": "modified", "additions": 4694, "deletions": 2477, "changes": 7171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2952b018a1baf25b12c339f2b96518425164295/gcc%2Fjava%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2952b018a1baf25b12c339f2b96518425164295/gcc%2Fjava%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.c?ref=c2952b018a1baf25b12c339f2b96518425164295"}, {"sha": "b80f879f21cb5ee3e824f7903ba05da16a98a95f", "filename": "gcc/java/parse.h", "status": "modified", "additions": 217, "deletions": 17, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2952b018a1baf25b12c339f2b96518425164295/gcc%2Fjava%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2952b018a1baf25b12c339f2b96518425164295/gcc%2Fjava%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.h?ref=c2952b018a1baf25b12c339f2b96518425164295", "patch": "@@ -66,8 +66,8 @@ extern tree stabilize_reference PARAMS ((tree));\n #define DRECOVERED(s)\n #endif\n \n-#define DRECOVER(s) {yyerrok; DRECOVERED(s)}\n-#define RECOVER     {yyerrok; RECOVERED}\n+#define DRECOVER(s) {yyerrok; DRECOVERED(s);}\n+#define RECOVER     {yyerrok; RECOVERED;}\n \n #define YYERROR_NOW ctxp->java_error_flag = 1\n #define YYNOT_TWICE if (ctxp->prevent_ese != lineno)\n@@ -205,7 +205,7 @@ extern tree stabilize_reference PARAMS ((tree));\n #define JNULLP_TYPE_P(TYPE) ((TYPE) && (TREE_CODE (TYPE) == POINTER_TYPE) \\\n \t\t\t     && (TYPE) == TREE_TYPE (null_pointer_node))\n \n-/* Other predicate */\n+/* Other predicates */\n #define JDECL_P(NODE) (NODE && (TREE_CODE (NODE) == PARM_DECL\t\t\\\n \t\t\t\t|| TREE_CODE (NODE) == VAR_DECL\t\t\\\n \t\t\t\t|| TREE_CODE (NODE) == FIELD_DECL))\n@@ -216,6 +216,109 @@ extern tree stabilize_reference PARAMS ((tree));\n #define TYPE_CLASS_P(TYPE) (CLASS_P (TYPE) \t\t\t\t\\\n \t\t\t    && !CLASS_INTERFACE (TYPE_NAME (TYPE)))\n \n+/* Identifier business related to 1.1 language extensions.  */\n+\n+#define IDENTIFIER_INNER_CLASS_OUTER_FIELD_ACCESS(NODE)\t\\\n+  (TREE_CODE (NODE) == IDENTIFIER_NODE &&\t\t\\\n+   IDENTIFIER_LENGTH (NODE) >= 8 &&\t\t\t\\\n+   IDENTIFIER_POINTER (NODE)[7] != '0')\n+\n+/* Build the string val$<O> and store it into N. The is used to\n+   construct the name of inner class hidden fields used to alias outer\n+   scope local variables.  */\n+#define MANGLE_OUTER_LOCAL_VARIABLE_NAME(N, O)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    obstack_grow (&temporary_obstack, \"val$\", 4);\t\t\t\\\n+    obstack_grow (&temporary_obstack, \t\t\t\t\t\\\n+\t\t  IDENTIFIER_POINTER ((O)), IDENTIFIER_LENGTH ((O)));\t\\\n+    obstack_1grow (&temporary_obstack, '\\0');\t\t\t\t\\\n+    (N) = obstack_finish (&temporary_obstack);  \t\t\t\\\n+  }\n+\n+/* Build the string parm$<O> and store in into the identifier N. This\n+   is used to contruct the name of hidden parameters used to\n+   initialize outer scope aliases.  */\n+#define MANGLE_ALIAS_INITIALIZER_PARAMETER_NAME_ID(N, O)\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    obstack_grow (&temporary_obstack, \"parm$\", 5);\t\t\t\\\n+    obstack_grow (&temporary_obstack, \t\t\t\t\t\\\n+\t\t  IDENTIFIER_POINTER ((O)), IDENTIFIER_LENGTH ((O)));\t\\\n+    obstack_1grow (&temporary_obstack, '\\0');\t\t\t\t\\\n+    (N) = obstack_finish (&temporary_obstack);  \t\t\t\\\n+  }\n+\n+#define MANGLE_ALIAS_INITIALIZER_PARAMETER_NAME_STR(N, S)\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    obstack_grow (&temporary_obstack, \"parm$\", 5);\t\t\\\n+    obstack_grow (&temporary_obstack, (S), strlen ((S)));\t\\\n+    obstack_1grow (&temporary_obstack, '\\0');\t\t\t\\\n+    (N) = obstack_finish (&temporary_obstack);\t\t\t\\\n+  }\n+\n+/* Skip THIS and artificial parameters found in function decl M and\n+   assign the result to C. We don't do that for $finit$, since it's\n+   knowingly called with artificial parms.  */\n+#define SKIP_THIS_AND_ARTIFICIAL_PARMS(C,M)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    int i;\t\t\t\t\t\t\t\\\n+    (C) = TYPE_ARG_TYPES (TREE_TYPE ((M)));\t\t\t\\\n+    if (!METHOD_STATIC ((M)))\t\t\t\t\t\\\n+      (C) = TREE_CHAIN (C);\t\t\t\t\t\\\n+    if (DECL_CONSTRUCTOR_P ((M))\t\t\t\t\\\n+        && PURE_INNER_CLASS_TYPE_P (DECL_CONTEXT ((M))))\t\\\n+      (C) = TREE_CHAIN (C);\t\t\t\t\t\\\n+    if (!DECL_FINIT_P ((M)))\t\t\t\t\t\\\n+      for (i = DECL_FUNCTION_NAP ((M)); i; i--)\t\t\t\\\n+       (C) = TREE_CHAIN (C);\t\t\t\t\t\\\n+  }\n+\n+/* Mark final parameters in method M, by comparison of the argument\n+   list L. This macro is used to set the flag once the method has been\n+   build.  */\n+#define MARK_FINAL_PARMS(M, L)\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    tree current = TYPE_ARG_TYPES (TREE_TYPE ((M)));\t\t\t\\\n+    tree list = (L);\t\t\t\t\t\t\t\\\n+    if (!METHOD_STATIC ((M)))\t\t\t\t\t\t\\\n+      current = TREE_CHAIN (current);\t\t\t\t\t\\\n+    for (; current !=  end_params_node;\t\t\t\t\t\\\n+\t current = TREE_CHAIN (current), list = TREE_CHAIN (list))\t\\\n+      ARG_FINAL_P (current) = ARG_FINAL_P (list);\t\t\t\\\n+    if (current != list)\t\t\t\t\t\t\\\n+      fatal (\"MARK_FINAL_PARMS\");\t\t\t\t\t\\\n+  }\n+\n+/* Reset the ARG_FINAL_P that might have been set in method M args.  */\n+#define UNMARK_FINAL_PARMS(M)\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    tree current;\t\t\t\t\t\t\t\\\n+    for (current = TYPE_ARG_TYPES (TREE_TYPE ((M))); \t\t\t\\\n+\t current != end_params_node; current = TREE_CHAIN (current))\t\\\n+      ARG_FINAL_P (current) = 0;\t\t\t\t\t\\\n+  }\n+\n+/* Reverse a crafted parameter list as required.  */\n+#define CRAFTED_PARAM_LIST_FIXUP(P)\t\t\\\n+  {\t\t\t\t\t\t\\\n+    if ((P))\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\\\n+\ttree last = (P);\t\t\t\\\n+\t(P) = nreverse (P);\t\t\t\\\n+\tTREE_CHAIN (last) = end_params_node;\t\\\n+      }\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\\\n+      (P) = end_params_node;\t\t\t\\\n+  }\n+\n+/* Modes governing the creation of a alias initializer parameter\n+   lists. AIPL stands for Alias Initializer Parameter List.  */\n+enum {\n+  AIPL_FUNCTION_CREATION,\t  /* Suitable for artificial method creation */\n+  AIPL_FUNCTION_DECLARATION,\t  /* Suitable for declared methods */\n+  AIPL_FUNCTION_CTOR_INVOCATION,  /* Invocation of constructors */\n+  AIPL_FUNCTION_FINIT_INVOCATION  /* Invocation of $finit$ */\n+};\n+\n /* Standard error messages */\n #define ERROR_CANT_CONVERT_TO_BOOLEAN(OPERATOR, NODE, TYPE)\t\t\\\n   parse_error_context ((OPERATOR),\t\t\t\t\t\\\n@@ -303,6 +406,11 @@ do {\t\t\t\t\t\t\t\t\t\\\n /* Check that we have exceptions in E.  */\n #define EXCEPTIONS_P(E) ((E) ? TREE_VALUE (E) : NULL_TREE)\n \n+/* Anonymous array access */\n+#define ANONYMOUS_ARRAY_BASE_TYPE(N)   TREE_OPERAND ((N), 0)\n+#define ANONYMOUS_ARRAY_DIMS_SIG(N)    TREE_OPERAND ((N), 1)\n+#define ANONYMOUS_ARRAY_INITIALIZER(N) TREE_OPERAND ((N), 2)\n+\n /* Invocation modes, as returned by invocation_mode (). */\n enum {\n   INVOKE_STATIC,\n@@ -358,7 +466,10 @@ enum jdep_code {\n   JDEP_TYPE,\t\t\t/* Patch a random tree node type,\n                                    without the need for any specific\n                                    actions */\n-  JDEP_EXCEPTION\t\t/* Patch exceptions specified by `throws' */\n+  JDEP_EXCEPTION,\t\t/* Patch exceptions specified by `throws' */\n+  JDEP_ANONYMOUS\t\t/* Patch anonymous classes\n+\t\t\t\t   (implementation or extension.) */\n+\n };\n \n typedef struct _jdep {\n@@ -373,6 +484,7 @@ typedef struct _jdep {\n   tree solv;\t\t\t/* What to solve */\n   tree wfl;\t\t\t/* Where thing to resolve where found */\n   tree misc;\t\t\t/* Miscellaneous info (optional). */\n+  tree enclosing;\t\t/* The enclosing (current) class */\n   tree *patch;\t\t\t/* Address of a location to patch */\n   struct _jdep *next;\t\t/* Linked list */\n } jdep;\n@@ -384,6 +496,7 @@ typedef struct _jdep {\n #define JDEP_SOLV(J)          ((J)->solv)\n #define JDEP_WFL(J)           ((J)->wfl)\n #define JDEP_MISC(J)          ((J)->misc)\n+#define JDEP_ENCLOSING(J)     ((J)->enclosing)\n #define JDEP_CLASS(J)         ((J)->class)\n #define JDEP_APPLY_PATCH(J,P) (*(J)->patch = (P))\n #define JDEP_GET_PATCH(J)     ((J)->patch)\n@@ -537,12 +650,13 @@ typedef struct _jdeplist {\n     TREE_SIDE_EFFECTS (WHERE) = 1;\t\t\t\\\n   }\n \n-#define BUILD_THROW(WHERE, WHAT)\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    (WHERE) = build (CALL_EXPR, void_type_node,\t\t\t\t\\\n-\t\t  build_address_of (throw_node[exceptions_via_longjmp ? 1 : 0]), \\\n-\t\t  build_tree_list (NULL_TREE, (WHAT)), NULL_TREE);\t\\\n-    TREE_SIDE_EFFECTS ((WHERE)) = 1;\t\t\t\t\t\\\n+#define BUILD_THROW(WHERE, WHAT)\t\t\t\t\t    \\\n+  {\t\t\t\t\t\t\t\t\t    \\\n+    (WHERE) = \t\t\t\t\t\t\t\t    \\\n+      build (CALL_EXPR, void_type_node,\t\t\t\t\t    \\\n+\t     build_address_of (throw_node[exceptions_via_longjmp ? 1 : 0]), \\\n+\t     build_tree_list (NULL_TREE, (WHAT)), NULL_TREE);\t\t    \\\n+    TREE_SIDE_EFFECTS ((WHERE)) = 1;\t\t\t\t\t    \\\n   }\n \n /* Set wfl_operator for the most accurate error location */\n@@ -584,10 +698,6 @@ typedef struct _jdeplist {\n   ctxp->import_list = node;\t\t\t\t\\\n }\n \n-/* Safe check that DECL is <clinit> */\n-#define IS_CLINIT(DECL)\t\t\t\t\\\n-  (DECL != NULL_TREE && DECL_NAME (DECL) == clinit_identifier_node)\n-\n /* Macro to access the osb (opening square bracket) count */\n #define CURRENT_OSB(C) (C)->osb_number [(C)->osb_depth]\n \n@@ -602,6 +712,7 @@ struct parser_ctxt {\n   FILE *finput;\t\t\t    /* Current file input stream */\n   struct parser_ctxt *next;\n \n+  char marker_begining;\t\t     /* Marker. Should be a sub-struct */\n   struct java_line *p_line, *c_line; /* Previous and current line */\n   java_lc elc;\t\t\t     /* Error's line column info */\n   unicode_t unget_utf8_value;        /* An unget utf8 value */\n@@ -613,6 +724,7 @@ struct parser_ctxt {\n   int osb_limit;\t\t     /* Limit of this depth */\n   int *osb_number;\t\t     /* Keep track of ['s */\n   int lineno;\t\t\t     /* Current lineno */\n+  char marker_end;\t\t     /* End marker. Should be a sub-struct */\n \n   /* The flags section */\n \n@@ -646,7 +758,7 @@ struct parser_ctxt {\n \n   tree package;\t\t\t    /* Defined package ID */\n \n-  /* Those tow list are saved accross file traversal */\n+  /* Those two list are saved accross file traversal */\n   tree  incomplete_class;\t    /* List of non-complete classes */\n   tree  gclass_list;\t\t    /* All classes seen from source code */\n \n@@ -659,6 +771,7 @@ struct parser_ctxt {\n \n   tree non_static_initialized;\t    /* List of non static initialized fields */\n   tree static_initialized;\t    /* List of static non final initialized */\n+  tree instance_initializers;\t    /* List of instancei initializers stmts */\n \n   tree import_list;\t\t    /* List of import */\n   tree import_demand_list;\t    /* List of import on demand */\n@@ -677,16 +790,103 @@ struct parser_ctxt {\n #endif /* JC1_LITE */\n };\n \n+/* A set of macros to push/pop/access the currently parsed class.  */\n+#define GET_CPC_LIST()     ctxp->current_parsed_class\n+\n+/* Currently class being parsed is an inner class if an enclosing\n+   class has been already pushed. This truth value is only valid prior\n+   an inner class is pushed. After, use FIXME. */\n+#define CPC_INNER_P() GET_CPC_LIST ()\n+\n+/* Get the currently parsed class DECL_TYPE node.  */\n+#define GET_CPC() TREE_VALUE (GET_CPC_LIST ())\n+\n+/* Get the currently parsed class unqualified IDENTIFIER_NODE.  */\n+#define GET_CPC_UN() TREE_PURPOSE (GET_CPC_LIST ())\n+\n+/* Get a parsed class unqualified IDENTIFIER_NODE from its CPC node.  */\n+#define GET_CPC_UN_NODE(N) TREE_PURPOSE (N)\n+\n+/* Get the currently parsed class DECL_TYPE from its CPC node.  */\n+#define GET_CPC_DECL_NODE(N) TREE_VALUE (N)\n+\n+/* The currently parsed enclosing currently parsed TREE_LIST node.  */\n+#define GET_ENCLOSING_CPC() TREE_CHAIN (GET_CPC_LIST ())\n+\n+/* Get the next enclosing context.  */\n+#define GET_NEXT_ENCLOSING_CPC(C) TREE_CHAIN (C)\n+\n+/* The DECL_TYPE node of the enclosing currently parsed\n+   class. NULL_TREE if the currently parsed class isn't an inner\n+   class.  */\n+#define GET_ENCLOSING_CPC_CONTEXT() (GET_ENCLOSING_CPC () ?\t\t      \\\n+                                     TREE_VALUE (GET_ENCLOSING_CPC ()) :      \\\n+\t\t\t\t     NULL_TREE)\n+\n+/* Push macro. First argument to PUSH_CPC is a DECL_TYPE, second\n+   argument is the unqualified currently parsed class name.  */\n+#define PUSH_CPC(C,R) { \t\t\t\t\t\\\n+                        ctxp->current_parsed_class =\t\t\\\n+\t\t        tree_cons ((R), (C), GET_CPC_LIST ()); \t\\\n+\t\t      }\n+\n+/* In case of an error, push an error.  */\n+#define PUSH_ERROR() PUSH_CPC (error_mark_node, error_mark_node)\n+\n+/* Pop macro. Before we pop, we link the current inner class decl (if any)\n+   to its enclosing class.  */\n+#define POP_CPC() {\t\t\t\t\t\\\n+\t\t    link_nested_class_to_enclosing ();\t\\\n+\t\t    ctxp->current_parsed_class =\t\\\n+\t\t      TREE_CHAIN (GET_CPC_LIST ());\t\\\n+\t\t  }\n+\n+#define DEBUG_CPC()\t\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      tree tmp =  ctxp->current_parsed_class;\t\t\t\\\n+      while (tmp)\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  fprintf (stderr, \"%s \",\t\t\t\t\\\n+\t\t   IDENTIFIER_POINTER (TREE_PURPOSE (tmp)));\t\\\n+\t  tmp = TREE_CHAIN (tmp);\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+    } \t\t\t\t\t\t\t\t\\\n+  while (0);\n+\n+/* Access to the various initializer statement lists */\n+#define CPC_INITIALIZER_LIST(C)          ((C)->non_static_initialized)\n+#define CPC_STATIC_INITIALIZER_LIST(C)   ((C)->static_initialized)\n+#define CPC_INSTANCE_INITIALIZER_LIST(C) ((C)->instance_initializers)\n+\n+/* Access to the various initializer statements */\n+#define CPC_INITIALIZER_STMT(C) (TREE_PURPOSE (CPC_INITIALIZER_LIST (C)))\n+#define CPC_STATIC_INITIALIZER_STMT(C) \\\n+  (TREE_PURPOSE (CPC_STATIC_INITIALIZER_LIST (C)))\n+#define CPC_INSTANCE_INITIALIZER_STMT(C) \\\n+  (TREE_PURPOSE (CPC_INSTANCE_INITIALIZER_LIST (C)))\n+\n+/* Set various initializer statements */\n+#define SET_CPC_INITIALIZER_STMT(C,S)\t\t\t\\\n+  if (CPC_INITIALIZER_LIST (C))\t\t\t\t\\\n+    TREE_PURPOSE (CPC_INITIALIZER_LIST (C)) = (S);\n+#define SET_CPC_STATIC_INITIALIZER_STMT(C,S)\t\t\t\\\n+  if (CPC_STATIC_INITIALIZER_LIST (C))\t\t\t\t\\\n+    TREE_PURPOSE (CPC_STATIC_INITIALIZER_LIST (C)) = (S);\n+#define SET_CPC_INSTANCE_INITIALIZER_STMT(C,S)\t\t\t\\\n+  if (CPC_INSTANCE_INITIALIZER_LIST(C))\t\t\t\t\\\n+    TREE_PURPOSE (CPC_INSTANCE_INITIALIZER_LIST (C)) = (S);\n+\n #ifndef JC1_LITE\n void java_complete_class PARAMS ((void));\n void java_check_circular_reference PARAMS ((void));\n void java_fix_constructors PARAMS ((void));\n-void java_check_final PARAMS ((void));\n void java_layout_classes PARAMS ((void));\n+void java_reorder_fields PARAMS ((void));\n tree java_method_add_stmt PARAMS ((tree, tree));\n void java_expand_switch PARAMS ((tree));\n int java_report_errors PARAMS ((void));\n-extern tree do_resolve_class PARAMS ((tree, tree, tree));\n+extern tree do_resolve_class PARAMS ((tree, tree, tree, tree));\n #endif\n char *java_get_line_col PARAMS ((char *, int, int));\n extern void reset_report PARAMS ((void));"}, {"sha": "e5d52966fff3d25197475902890fd13a704895e5", "filename": "gcc/java/parse.y", "status": "modified", "additions": 2747, "deletions": 538, "changes": 3285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2952b018a1baf25b12c339f2b96518425164295/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2952b018a1baf25b12c339f2b96518425164295/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=c2952b018a1baf25b12c339f2b96518425164295"}, {"sha": "4309cfbfff1bd7a72c2b036f232002540becbeac", "filename": "gcc/java/typeck.c", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2952b018a1baf25b12c339f2b96518425164295/gcc%2Fjava%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2952b018a1baf25b12c339f2b96518425164295/gcc%2Fjava%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Ftypeck.c?ref=c2952b018a1baf25b12c339f2b96518425164295", "patch": "@@ -611,12 +611,8 @@ build_java_signature (type)\n   push_obstacks (&permanent_obstack, &permanent_obstack);\n   while (TREE_CODE (type) == POINTER_TYPE)\n     type = TREE_TYPE (type);\n-  if (TYPE_LANG_SPECIFIC (type) == NULL)\n-    {\n-      TYPE_LANG_SPECIFIC (type) = (struct lang_type *)\n-\tperm_calloc (1, sizeof (struct lang_type));\n-    }\n-  sig = TYPE_LANG_SPECIFIC (type)->signature;\n+  MAYBE_CREATE_TYPE_TYPE_LANG_SPECIFIC (type);\n+  sig = TYPE_SIGNATURE (type);\n   if (sig == NULL_TREE)\n     {\n       char sg[2];\n@@ -682,7 +678,7 @@ build_java_signature (type)\n \tdefault:\n \t  fatal (\"internal error - build_java_signature passed invalid type\");\n \t}\n-      TYPE_LANG_SPECIFIC (type)->signature = sig;\n+      TYPE_SIGNATURE (type) = sig;\n     }\n   pop_obstacks ();\n   return sig;\n@@ -698,16 +694,11 @@ set_java_signature (type, sig)\n   tree old_sig;\n   while (TREE_CODE (type) == POINTER_TYPE)\n     type = TREE_TYPE (type);\n-  if (TYPE_LANG_SPECIFIC (type) == NULL)\n-    {\n-      TYPE_LANG_SPECIFIC (type) = (struct lang_type *)\n-\tperm_calloc (1, sizeof (struct lang_type));\n-      \n-    }\n-  old_sig = TYPE_LANG_SPECIFIC (type)->signature;\n+  MAYBE_CREATE_TYPE_TYPE_LANG_SPECIFIC (type);\n+  old_sig = TYPE_SIGNATURE (type);\n   if (old_sig != NULL_TREE && old_sig != sig)\n     fatal (\"internal error - set_java_signature\");\n-  TYPE_LANG_SPECIFIC (type)->signature = sig;\n+  TYPE_SIGNATURE (type) = sig;\n #if 0 /* careful about METHOD_TYPE */\n   if (IDENTIFIER_SIGNATURE_TYPE (sig) == NULL_TREE && TREE_PERMANENT (type))\n     IDENTIFIER_SIGNATURE_TYPE (sig) = type;"}, {"sha": "3aff5e4595500f8986488e56fc38d68e64676491", "filename": "gcc/java/verify.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2952b018a1baf25b12c339f2b96518425164295/gcc%2Fjava%2Fverify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2952b018a1baf25b12c339f2b96518425164295/gcc%2Fjava%2Fverify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fverify.c?ref=c2952b018a1baf25b12c339f2b96518425164295", "patch": "@@ -940,11 +940,10 @@ verify_jvm_instructions (jcf, byte_ops, length)\n \t    pop_argument_types (TYPE_ARG_TYPES (method_type));\n \n \t    /* Can't invoke <clinit> */\n-\t    if (method_name == clinit_identifier_node)\n+\t    if (ID_CLINIT_P (method_name))\n \t      VERIFICATION_ERROR (\"invoke opcode can't invoke <clinit>\");\n \t    /* Apart invokespecial, can't invoke <init> */\n-\t    if (op_code != OPCODE_invokespecial\n-\t\t&& method_name == init_identifier_node)\n+\t    if (op_code != OPCODE_invokespecial && ID_INIT_P (method_name))\n \t      VERIFICATION_ERROR (\"invoke opcode can't invoke <init>\");\n \n \t    if (op_code != OPCODE_invokestatic)"}]}