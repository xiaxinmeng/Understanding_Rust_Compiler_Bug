{"sha": "2767a7f2109b4b3cf980c7f5fab5d6383085f12a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjc2N2E3ZjIxMDliNGIzY2Y5ODBjN2Y1ZmFiNWQ2MzgzMDg1ZjEyYQ==", "commit": {"author": {"name": "H.J. Lu", "email": "hongjiu.lu@intel.com", "date": "2010-10-27T12:36:15Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2010-10-27T12:36:15Z"}, "message": "Add -mvzeroupper to x86.\n\ngcc/\n\n2010-10-27  H.J. Lu  <hongjiu.lu@intel.com>\n\n\t* config/i386/i386-protos.h (init_cumulative_args): Add an int.\n\n\t* config/i386/i386.c (block_info): New.\n\t(BLOCK_INFO): Likewise.\n\t(call_avx256_state): Likewise.\n\t(check_avx256_stores): Likewise.\n\t(move_or_delete_vzeroupper_2): Likewise.\n\t(move_or_delete_vzeroupper_1): Likewise.\n\t(move_or_delete_vzeroupper): Likewise.\n\t(use_avx256_p): Likewise.\n\t(function_pass_avx256_p): Likewise.\n\t(flag_opts): Add -mvzeroupper.\n\t(ix86_option_override_internal): Turn on MASK_VZEROUPPER by\n\tdefault for TARGET_AVX.  Turn off MASK_VZEROUPPER if TARGET_AVX\n\tis disabled.\n\t(ix86_function_ok_for_sibcall): Disable sibcall if we need to\n\tgenerate vzeroupper.\n\t(init_cumulative_args): Add an int to indicate caller.  Set\n\tuse_avx256_p, callee_return_avx256_p and caller_use_avx256_p\n\tbased on return type.\n\t(ix86_function_arg): Set use_avx256_p, callee_pass_avx256_p and\n\tcaller_pass_avx256_p based on argument type.\n\t(ix86_expand_epilogue): Emit vzeroupper if 256bit AVX register\n\tis used, but not returned by caller.\n\t(ix86_expand_call): Emit vzeroupper if 256bit AVX register is\n\tused.\n\t(ix86_local_alignment): Set use_avx256_p if 256bit AVX register\n\tis used.\n\t(ix86_minimum_alignment): Likewise.\n\t(ix86_expand_special_args_builtin): Set target to\n\tGEN_INT (vzeroupper_intrinsic) for CODE_FOR_avx_vzeroupper.\n\t(ix86_reorg): Run the vzeroupper optimization if needed.\n\n\t* config/i386/i386.h (ix86_args): Add caller.\n\t(INIT_CUMULATIVE_ARGS): Updated.\n\t(machine_function): Add use_vzeroupper_p, use_avx256_p,\n\tcaller_pass_avx256_p, caller_return_avx256_p,\n\tcallee_pass_avx256_p and callee_return_avx256_p.\n\n\t* config/i386/i386.opt (-mvzeroupper): New.\n\n\t* config/i386/predicates.md (vzeroupper_operation): Removed.\n\n\t* config/i386/sse.md (avx_vzeroupper): Removed.\n\t(*avx_vzeroupper): Removed.\n\t(avx_vzeroupper): New.\n\n\t* doc/invoke.texi: Document -mvzeroupper.\n\ngcc/testsuite/\n\n2010-10-27  H.J. Lu  <hongjiu.lu@intel.com>\n\n\t* gcc.target/i386/avx-vzeroupper-1.c: Add -mtune=generic.\n\t* gcc.target/i386/avx-vzeroupper-2.c: Likewise.\n\n\t* gcc.target/i386/avx-vzeroupper-3.c: New.\n\t* gcc.target/i386/avx-vzeroupper-4.c: Likewise.\n\t* gcc.target/i386/avx-vzeroupper-5.c: Likewise.\n\t* gcc.target/i386/avx-vzeroupper-6.c: Likewise.\n\t* gcc.target/i386/avx-vzeroupper-7.c: Likewise.\n\t* gcc.target/i386/avx-vzeroupper-8.c: Likewise.\n\t* gcc.target/i386/avx-vzeroupper-9.c: Likewise.\n\t* gcc.target/i386/avx-vzeroupper-10.c: Likewise.\n\t* gcc.target/i386/avx-vzeroupper-11.c: Likewise.\n\t* gcc.target/i386/avx-vzeroupper-12.c: Likewise.\n\t* gcc.target/i386/avx-vzeroupper-13.c: Likewise.\n\t* gcc.target/i386/avx-vzeroupper-14.c: Likewise.\n\nFrom-SVN: r166000", "tree": {"sha": "e6bb0c094c327d8c2c95394432623ac76fa04746", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e6bb0c094c327d8c2c95394432623ac76fa04746"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2767a7f2109b4b3cf980c7f5fab5d6383085f12a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2767a7f2109b4b3cf980c7f5fab5d6383085f12a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2767a7f2109b4b3cf980c7f5fab5d6383085f12a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2767a7f2109b4b3cf980c7f5fab5d6383085f12a/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "22bc122eca010c61c17e05dd5f595c66ca050ae4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22bc122eca010c61c17e05dd5f595c66ca050ae4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22bc122eca010c61c17e05dd5f595c66ca050ae4"}], "stats": {"total": 837, "additions": 776, "deletions": 61}, "files": [{"sha": "1e7dc32427e6f41ba4386353d1b1ca695f7ee47f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2767a7f2109b4b3cf980c7f5fab5d6383085f12a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2767a7f2109b4b3cf980c7f5fab5d6383085f12a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2767a7f2109b4b3cf980c7f5fab5d6383085f12a", "patch": "@@ -1,3 +1,54 @@\n+2010-10-27  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\t* config/i386/i386-protos.h (init_cumulative_args): Add an int.\n+\n+\t* config/i386/i386.c (block_info): New.\n+\t(BLOCK_INFO): Likewise.\n+\t(call_avx256_state): Likewise.\n+\t(check_avx256_stores): Likewise.\n+\t(move_or_delete_vzeroupper_2): Likewise.\n+\t(move_or_delete_vzeroupper_1): Likewise.\n+\t(move_or_delete_vzeroupper): Likewise.\n+\t(use_avx256_p): Likewise.\n+\t(function_pass_avx256_p): Likewise.\n+\t(flag_opts): Add -mvzeroupper.\n+\t(ix86_option_override_internal): Turn on MASK_VZEROUPPER by\n+\tdefault for TARGET_AVX.  Turn off MASK_VZEROUPPER if TARGET_AVX\n+\tis disabled.\n+\t(ix86_function_ok_for_sibcall): Disable sibcall if we need to\n+\tgenerate vzeroupper.\n+\t(init_cumulative_args): Add an int to indicate caller.  Set\n+\tuse_avx256_p, callee_return_avx256_p and caller_use_avx256_p\n+\tbased on return type.\n+\t(ix86_function_arg): Set use_avx256_p, callee_pass_avx256_p and\n+\tcaller_pass_avx256_p based on argument type.\n+\t(ix86_expand_epilogue): Emit vzeroupper if 256bit AVX register\n+\tis used, but not returned by caller.\n+\t(ix86_expand_call): Emit vzeroupper if 256bit AVX register is\n+\tused.\n+\t(ix86_local_alignment): Set use_avx256_p if 256bit AVX register\n+\tis used.\n+\t(ix86_minimum_alignment): Likewise.\n+\t(ix86_expand_special_args_builtin): Set target to\n+\tGEN_INT (vzeroupper_intrinsic) for CODE_FOR_avx_vzeroupper.\n+\t(ix86_reorg): Run the vzeroupper optimization if needed.\n+\n+\t* config/i386/i386.h (ix86_args): Add caller.\n+\t(INIT_CUMULATIVE_ARGS): Updated.\n+\t(machine_function): Add use_vzeroupper_p, use_avx256_p,\n+\tcaller_pass_avx256_p, caller_return_avx256_p,\n+\tcallee_pass_avx256_p and callee_return_avx256_p.\n+\n+\t* config/i386/i386.opt (-mvzeroupper): New.\n+\n+\t* config/i386/predicates.md (vzeroupper_operation): Removed.\n+\n+\t* config/i386/sse.md (avx_vzeroupper): Removed.\n+\t(*avx_vzeroupper): Removed.\n+\t(avx_vzeroupper): New.\n+\n+\t* doc/invoke.texi: Document -mvzeroupper.\n+\n 2010-10-27  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* config/i386/t-mingw32 (SHLIB_LC): Add -lmingwthrd."}, {"sha": "02c2a9008243a8629a2c3ef9a8f67142c88b9e68", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2767a7f2109b4b3cf980c7f5fab5d6383085f12a/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2767a7f2109b4b3cf980c7f5fab5d6383085f12a/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=2767a7f2109b4b3cf980c7f5fab5d6383085f12a", "patch": "@@ -177,7 +177,7 @@ extern void ix86_expand_trunc (rtx, rtx);\n extern void ix86_expand_truncdf_32 (rtx, rtx);\n \n #ifdef TREE_CODE\n-extern void init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree);\n+extern void init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree, int);\n #endif\t/* TREE_CODE  */\n \n #endif\t/* RTX_CODE  */"}, {"sha": "f2bd70555dcbc49dce4170eae7febf03a5bd6884", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 452, "deletions": 11, "changes": 463, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2767a7f2109b4b3cf980c7f5fab5d6383085f12a/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2767a7f2109b4b3cf980c7f5fab5d6383085f12a/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=2767a7f2109b4b3cf980c7f5fab5d6383085f12a", "patch": "@@ -56,6 +56,293 @@ along with GCC; see the file COPYING3.  If not see\n #include \"debug.h\"\n #include \"dwarf2out.h\"\n #include \"sched-int.h\"\n+\n+typedef struct block_info_def\n+{\n+  /* TRUE if the upper 128bits of any AVX registers are live at exit.  */\n+  bool upper_128bits_set;\n+  /* TRUE if block has been processed.  */\n+  bool done;\n+} *block_info;\n+\n+#define BLOCK_INFO(B)   ((block_info) (B)->aux)\n+\n+enum call_avx256_state\n+{\n+  /* Callee returns 256bit AVX register.  */\n+  callee_return_avx256 = -1,\n+  /* Callee returns and passes 256bit AVX register.  */\n+  callee_return_pass_avx256,\n+  /* Callee passes 256bit AVX register.  */\n+  callee_pass_avx256,\n+  /* Callee doesn't return nor passe 256bit AVX register, or no\n+     256bit AVX register in function return.  */\n+  call_no_avx256,\n+  /* vzeroupper intrinsic.  */\n+  vzeroupper_intrinsic\n+};\n+\n+/* Check if a 256bit AVX register is referenced in stores.   */\n+\n+static void\n+check_avx256_stores (rtx dest, const_rtx set, void *data)\n+{\n+  if ((REG_P (dest)\n+       && VALID_AVX256_REG_MODE (GET_MODE (dest)))\n+      || (GET_CODE (set) == SET\n+\t  && REG_P (SET_SRC (set))\n+\t  && VALID_AVX256_REG_MODE (GET_MODE (SET_SRC (set)))))\n+    {\n+      bool *upper_128bits_set = (bool *) data;\n+      *upper_128bits_set = true;\n+    }\n+}\n+\n+/* Helper function for move_or_delete_vzeroupper_1.  Look for vzeroupper\n+   in basic block BB.  Delete it if upper 128bit AVX registers are\n+   unused.  If it isn't deleted, move it to just before a jump insn.\n+   \n+   UPPER_128BITS_LIVE is TRUE if the upper 128bits of any AVX registers\n+   are live at entry.  */\n+\n+static void\n+move_or_delete_vzeroupper_2 (basic_block bb, bool upper_128bits_set)\n+{\n+  rtx curr_insn, next_insn, prev_insn, insn;\n+\n+  if (dump_file)\n+    fprintf (dump_file, \" BB [%i] entry: upper 128bits: %d\\n\",\n+\t     bb->index, upper_128bits_set);\n+\n+  for (curr_insn = BB_HEAD (bb);\n+       curr_insn && curr_insn != NEXT_INSN (BB_END (bb));\n+       curr_insn = next_insn)\n+    {\n+      int avx256;\n+\n+      next_insn = NEXT_INSN (curr_insn);\n+\n+      if (!NONDEBUG_INSN_P (curr_insn))\n+\tcontinue;\n+\n+      /* Search for vzeroupper.  */\n+      insn = PATTERN (curr_insn);\n+      if (GET_CODE (insn) == UNSPEC_VOLATILE\n+\t  && XINT (insn, 1) == UNSPECV_VZEROUPPER)\n+\t{\n+\t  /* Found vzeroupper.  */\n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file, \"Found vzeroupper:\\n\");\n+\t      print_rtl_single (dump_file, curr_insn);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* Check vzeroall intrinsic.  */\n+\t  if (GET_CODE (insn) == PARALLEL\n+\t      && GET_CODE (XVECEXP (insn, 0, 0)) == UNSPEC_VOLATILE\n+\t      && XINT (XVECEXP (insn, 0, 0), 1) == UNSPECV_VZEROALL)\n+\t    upper_128bits_set = false;\n+\t  else if (!upper_128bits_set)\n+\t    {\n+\t      /* Check if upper 128bits of AVX registers are used.  */\n+\t      note_stores (insn, check_avx256_stores,\n+\t\t\t   &upper_128bits_set);\n+\t    }\n+\t  continue;\n+\t}\n+\n+      avx256 = INTVAL (XVECEXP (insn, 0, 0));\n+\n+      if (!upper_128bits_set)\n+\t{\n+\t  /* Since the upper 128bits are cleared, callee must not pass\n+\t     256bit AVX register.  We only need to check if callee\n+\t     returns 256bit AVX register.  */\n+\t  upper_128bits_set = avx256 == callee_return_avx256;\n+\n+\t  /* Remove unnecessary vzeroupper since upper 128bits are\n+\t     cleared.  */\n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file, \"Delete redundant vzeroupper:\\n\");\n+\t      print_rtl_single (dump_file, curr_insn);\n+\t    }\n+\t  delete_insn (curr_insn);\n+\t  continue;\n+\t}\n+      else if (avx256 == callee_return_pass_avx256\n+\t       || avx256 == callee_pass_avx256)\n+\t{\n+\t  /* Callee passes 256bit AVX register.  Check if callee\n+\t     returns 256bit AVX register.  */\n+\t  upper_128bits_set = avx256 == callee_return_pass_avx256;\n+\n+\t  /* Must remove vzeroupper since callee passes 256bit AVX\n+\t     register.  */\n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file, \"Delete callee pass vzeroupper:\\n\");\n+\t      print_rtl_single (dump_file, curr_insn);\n+\t    }\n+\t  delete_insn (curr_insn);\n+\t  continue;\n+\t}\n+\n+      /* Find the jump after vzeroupper.  */\n+      prev_insn = curr_insn;\n+      if (avx256 == vzeroupper_intrinsic)\n+\t{\n+\t  /* For vzeroupper intrinsic, check if there is another\n+\t     vzeroupper.  */\n+\t  insn = NEXT_INSN (curr_insn);\n+\t  while (insn)\n+\t    {\n+\t      if (NONJUMP_INSN_P (insn)\n+\t\t  && GET_CODE (PATTERN (insn)) == UNSPEC_VOLATILE\n+\t\t  && XINT (PATTERN (insn), 1) == UNSPECV_VZEROUPPER)\n+\t\t{\n+\t\t  if (dump_file)\n+\t\t    {\n+\t\t      fprintf (dump_file,\n+\t\t\t       \"Delete redundant vzeroupper intrinsic:\\n\");\n+\t\t      print_rtl_single (dump_file, curr_insn);\n+\t\t    }\n+\t\t  delete_insn (curr_insn);\n+\t\t  insn = NULL;\n+\t\t  continue;\n+\t\t}\n+\n+\t      if (JUMP_P (insn) || CALL_P (insn))\n+\t\tbreak;\n+\t      prev_insn = insn;\n+\t      insn = NEXT_INSN (insn);\n+\t      if (insn == NEXT_INSN (BB_END (bb)))\n+\t\tbreak;\n+\t    }\n+\n+\t  /* Continue if redundant vzeroupper intrinsic is deleted.  */\n+\t  if (!insn)\n+\t    continue;\n+\t}\n+      else\n+\t{\n+\t  /* Find the next jump/call.  */\n+\t  insn = NEXT_INSN (curr_insn);\n+\t  while (insn)\n+\t    {\n+\t      if (JUMP_P (insn) || CALL_P (insn))\n+\t\tbreak;\n+\t      prev_insn = insn;\n+\t      insn = NEXT_INSN (insn);\n+\t      if (insn == NEXT_INSN (BB_END (bb)))\n+\t\tbreak;\n+\t    }\n+\n+\t  if (!insn)\n+\t    gcc_unreachable();\n+\t}\n+\n+      /* Keep vzeroupper.  */\n+      upper_128bits_set = false;\n+\n+      /* Also allow label as the next instruction.  */\n+      if (insn == NEXT_INSN (BB_END (bb)) && !LABEL_P (insn))\n+\tgcc_unreachable();\n+\n+      /* Move vzeroupper before jump/call if neeeded.  */\n+      if (curr_insn != prev_insn)\n+\t{\n+\t  reorder_insns_nobb (curr_insn, curr_insn, prev_insn);\n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file, \"Move vzeroupper after:\\n\");\n+\t      print_rtl_single (dump_file, prev_insn);\n+\t      fprintf (dump_file, \"before:\\n\");\n+\t      print_rtl_single (dump_file, insn);\n+\t    }\n+\t}\n+\n+      next_insn = NEXT_INSN (insn);\n+    }\n+\n+  BLOCK_INFO (bb)->upper_128bits_set = upper_128bits_set;\n+\n+  if (dump_file)\n+    fprintf (dump_file, \" BB [%i] exit: upper 128bits: %d\\n\",\n+\t     bb->index, upper_128bits_set);\n+}\n+\n+/* Helper function for move_or_delete_vzeroupper.  Process vzeroupper\n+   in BLOCK and its predecessor blocks recursively.  */\n+\n+static void\n+move_or_delete_vzeroupper_1 (basic_block block)\n+{\n+  edge e;\n+  edge_iterator ei;\n+  bool upper_128bits_set;\n+\n+  if (dump_file)\n+    fprintf (dump_file, \" Process BB [%i]: status: %d\\n\",\n+\t     block->index, BLOCK_INFO (block)->done);\n+\n+  if (BLOCK_INFO (block)->done)\n+    return;\n+\n+  BLOCK_INFO (block)->done = true;\n+\n+  upper_128bits_set = false;\n+\n+  /* Process all predecessor edges of this block.  */\n+  FOR_EACH_EDGE (e, ei, block->preds)\n+    {\n+      if (e->src == block)\n+\tcontinue;\n+      move_or_delete_vzeroupper_1 (e->src);\n+      if (BLOCK_INFO (e->src)->upper_128bits_set)\n+\tupper_128bits_set = true;\n+    }\n+\n+  /* Process this block.  */\n+  move_or_delete_vzeroupper_2 (block, upper_128bits_set);\n+}\n+\n+/* Go through the instruction stream looking for vzeroupper.  Delete\n+   it if upper 128bit AVX registers are unused.  If it isn't deleted,\n+   move it to just before a jump insn.  */\n+\n+static void\n+move_or_delete_vzeroupper (void)\n+{\n+  edge e;\n+  edge_iterator ei;\n+\n+  /* Set up block info for each basic block.  */\n+  alloc_aux_for_blocks (sizeof (struct block_info_def));\n+\n+  /* Process successor blocks of all entry points.  */\n+  if (dump_file)\n+    fprintf (dump_file, \"Process all entry points\\n\");\n+\n+  FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR->succs)\n+    {\n+      move_or_delete_vzeroupper_2 (e->dest,\n+\t\t\t\t   cfun->machine->caller_pass_avx256_p);\n+      BLOCK_INFO (e->dest)->done = true;\n+    }\n+\n+  /* Process predecessor blocks of all exit points.  */\n+  if (dump_file)\n+    fprintf (dump_file, \"Process all exit points\\n\");\n+\n+  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n+    move_or_delete_vzeroupper_1 (e->src);\n+\n+  free_aux_for_blocks ();\n+}\n+\n static rtx legitimize_dllimport_symbol (rtx, bool);\n \n #ifndef CHECK_STACK_LIMIT\n@@ -2633,6 +2920,7 @@ ix86_target_string (int isa, int flags, const char *arch, const char *tune,\n     { \"-mtls-direct-seg-refs\",\t\tMASK_TLS_DIRECT_SEG_REFS },\n     { \"-mvect8-ret-in-mem\",\t\tMASK_VECT8_RETURNS },\n     { \"-m8bit-idiv\",\t\t\tMASK_USE_8BIT_IDIV },\n+    { \"-mvzeroupper\",\t\t\tMASK_VZEROUPPER },\n   };\n \n   const char *opts[ARRAY_SIZE (isa_opts) + ARRAY_SIZE (flag_opts) + 6][2];\n@@ -3712,6 +4000,60 @@ ix86_option_override_internal (bool main_args_p)\n   if (main_args_p)\n     target_option_default_node = target_option_current_node\n       = build_target_option_node ();\n+\n+  if (TARGET_AVX)\n+    {\n+      /* Enable vzeroupper pass by default for TARGET_AVX.  */\n+      if (!(target_flags_explicit & MASK_VZEROUPPER))\n+\ttarget_flags |= MASK_VZEROUPPER;\n+    }\n+  else \n+    {\n+      /* Disable vzeroupper pass if TARGET_AVX is disabled.  */\n+      target_flags &= ~MASK_VZEROUPPER;\n+    }\n+}\n+\n+/* Return TRUE if type TYPE and mode MODE use 256bit AVX modes.  */\n+\n+static bool\n+use_avx256_p (enum machine_mode mode, const_tree type)\n+{\n+  return (VALID_AVX256_REG_MODE (mode)\n+\t  || (type\n+\t      && TREE_CODE (type) == VECTOR_TYPE\n+\t      && int_size_in_bytes (type) == 32));\n+}\n+\n+/* Return TRUE if VAL is passed in register with 256bit AVX modes.  */\n+\n+static bool\n+function_pass_avx256_p (const_rtx val)\n+{\n+  if (!val)\n+    return false;\n+\n+  if (REG_P (val) && VALID_AVX256_REG_MODE (GET_MODE (val)))\n+    return true;\n+\n+  if (GET_CODE (val) == PARALLEL)\n+    {\n+      int i;\n+      rtx r;\n+\n+      for (i = XVECLEN (val, 0) - 1; i >= 0; i--)\n+\t{\n+\t  r = XVECEXP (val, 0, i);\n+\t  if (GET_CODE (r) == EXPR_LIST\n+\t      && XEXP (r, 0)\n+\t      && REG_P (XEXP (r, 0))\n+\t      && (GET_MODE (XEXP (r, 0)) == OImode\n+\t\t  || VALID_AVX256_REG_MODE (GET_MODE (XEXP (r, 0)))))\n+\t    return true;\n+\t}\n+    }\n+\n+  return false;\n }\n \n /* Implement the TARGET_OPTION_OVERRIDE hook.  */\n@@ -4626,7 +4968,14 @@ ix86_function_ok_for_sibcall (tree decl, tree exp)\n \treturn false;\n     }\n   else if (VOID_TYPE_P (TREE_TYPE (DECL_RESULT (cfun->decl))))\n-    ;\n+    {\n+      /* Disable sibcall if we need to generate vzeroupper after\n+\t callee returns.  */\n+      if (TARGET_VZEROUPPER\n+\t  && cfun->machine->callee_return_avx256_p\n+\t  && !cfun->machine->caller_return_avx256_p)\n+\treturn false;\n+    }\n   else if (!rtx_equal_p (a, b))\n     return false;\n \n@@ -5243,15 +5592,54 @@ void\n init_cumulative_args (CUMULATIVE_ARGS *cum,  /* Argument info to initialize */\n \t\t      tree fntype,\t/* tree ptr for function decl */\n \t\t      rtx libname,\t/* SYMBOL_REF of library name or 0 */\n-\t\t      tree fndecl)\n+\t\t      tree fndecl,\n+\t\t      int caller)\n {\n-  struct cgraph_local_info *i = fndecl ? cgraph_local_info (fndecl) : NULL;\n+  struct cgraph_local_info *i;\n+  tree fnret_type;\n+\n   memset (cum, 0, sizeof (*cum));\n \n+  /* Initialize for the current callee.  */\n+  if (caller)\n+    {\n+      cfun->machine->callee_pass_avx256_p = false;\n+      cfun->machine->callee_return_avx256_p = false;\n+    }\n+\n   if (fndecl)\n-   cum->call_abi = ix86_function_abi (fndecl);\n+    {\n+      i = cgraph_local_info (fndecl);\n+      cum->call_abi = ix86_function_abi (fndecl);\n+      fnret_type = TREE_TYPE (TREE_TYPE (fndecl));\n+    }\n   else\n-   cum->call_abi = ix86_function_type_abi (fntype);\n+    {\n+      i = NULL;\n+      cum->call_abi = ix86_function_type_abi (fntype);\n+      if (fntype)\n+\tfnret_type = TREE_TYPE (fntype);\n+      else\n+\tfnret_type = NULL;\n+    }\n+\n+  if (TARGET_VZEROUPPER && fnret_type)\n+    {\n+      rtx fnret_value = ix86_function_value (fnret_type, fntype,\n+\t\t\t\t\t     false);\n+      if (function_pass_avx256_p (fnret_value))\n+\t{\n+\t  /* The return value of this function uses 256bit AVX modes.  */\n+\t  cfun->machine->use_avx256_p = true;\n+\t  if (caller)\n+\t    cfun->machine->callee_return_avx256_p = true;\n+\t  else\n+\t    cfun->machine->caller_return_avx256_p = true;\n+\t}\n+    }\n+\n+  cum->caller = caller;\n+\n   /* Set up the number of registers to use for passing arguments.  */\n \n   if (cum->call_abi == MS_ABI && !ACCUMULATE_OUTGOING_ARGS)\n@@ -6488,6 +6876,7 @@ ix86_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode omode,\n {\n   enum machine_mode mode = omode;\n   HOST_WIDE_INT bytes, words;\n+  rtx arg;\n \n   if (mode == BLKmode)\n     bytes = int_size_in_bytes (type);\n@@ -6501,11 +6890,23 @@ ix86_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode omode,\n     mode = type_natural_mode (type, cum);\n \n   if (TARGET_64BIT && (cum ? cum->call_abi : ix86_abi) == MS_ABI)\n-    return function_arg_ms_64 (cum, mode, omode, named, bytes);\n+    arg = function_arg_ms_64 (cum, mode, omode, named, bytes);\n   else if (TARGET_64BIT)\n-    return function_arg_64 (cum, mode, omode, type, named);\n+    arg = function_arg_64 (cum, mode, omode, type, named);\n   else\n-    return function_arg_32 (cum, mode, omode, type, bytes, words);\n+    arg = function_arg_32 (cum, mode, omode, type, bytes, words);\n+\n+  if (TARGET_VZEROUPPER && function_pass_avx256_p (arg))\n+    {\n+      /* This argument uses 256bit AVX modes.  */\n+      cfun->machine->use_avx256_p = true;\n+      if (cum->caller)\n+\tcfun->machine->callee_pass_avx256_p = true;\n+      else\n+\tcfun->machine->caller_pass_avx256_p = true;\n+    }\n+\n+  return arg;\n }\n \n /* A C expression that indicates when an argument must be passed by\n@@ -10353,6 +10754,15 @@ ix86_expand_epilogue (int style)\n       return;\n     }\n \n+  /* Emit vzeroupper if needed.  */\n+  if (TARGET_VZEROUPPER\n+      && cfun->machine->use_avx256_p\n+      && !cfun->machine->caller_return_avx256_p)\n+    {\n+      cfun->machine->use_vzeroupper_p = 1;\n+      emit_insn (gen_avx_vzeroupper (GEN_INT (call_no_avx256))); \n+    }\n+\n   if (crtl->args.pops_args && crtl->args.size)\n     {\n       rtx popc = GEN_INT (crtl->args.pops_args);\n@@ -20910,6 +21320,25 @@ ix86_expand_call (rtx retval, rtx fnaddr, rtx callarg1,\n \t\t\t       + 2, vec));\n     }\n \n+  /* Emit vzeroupper if needed.  */\n+  if (TARGET_VZEROUPPER && cfun->machine->use_avx256_p)\n+    {\n+      int avx256;\n+      cfun->machine->use_vzeroupper_p = 1;\n+      if (cfun->machine->callee_pass_avx256_p)\n+\t{\n+\t  if (cfun->machine->callee_return_avx256_p)\n+\t    avx256 = callee_return_pass_avx256;\n+\t  else\n+\t    avx256 = callee_pass_avx256;\n+\t}\n+      else if (cfun->machine->callee_return_avx256_p)\n+\tavx256 = callee_return_avx256;\n+      else\n+\tavx256 = call_no_avx256;\n+      emit_insn (gen_avx_vzeroupper (GEN_INT (avx256))); \n+    }\n+\n   call = emit_call_insn (call);\n   if (use)\n     CALL_INSN_FUNCTION_USAGE (call) = use;\n@@ -21653,6 +22082,9 @@ ix86_local_alignment (tree exp, enum machine_mode mode,\n       decl = NULL;\n     }\n \n+  if (use_avx256_p (mode, type))\n+    cfun->machine->use_avx256_p = true;\n+\n   /* Don't do dynamic stack realignment for long long objects with\n      -mpreferred-stack-boundary=2.  */\n   if (!TARGET_64BIT\n@@ -21748,9 +22180,6 @@ ix86_minimum_alignment (tree exp, enum machine_mode mode,\n {\n   tree type, decl;\n \n-  if (TARGET_64BIT || align != 64 || ix86_preferred_stack_boundary >= 64)\n-    return align;\n-\n   if (exp && DECL_P (exp))\n     {\n       type = TREE_TYPE (exp);\n@@ -21762,6 +22191,12 @@ ix86_minimum_alignment (tree exp, enum machine_mode mode,\n       decl = NULL;\n     }\n \n+  if (use_avx256_p (mode, type))\n+    cfun->machine->use_avx256_p = true;\n+\n+  if (TARGET_64BIT || align != 64 || ix86_preferred_stack_boundary >= 64)\n+    return align;\n+\n   /* Don't do dynamic stack realignment for long long objects with\n      -mpreferred-stack-boundary=2.  */\n   if ((mode == DImode || (type && TYPE_MODE (type) == DImode))\n@@ -25505,6 +25940,8 @@ ix86_expand_special_args_builtin (const struct builtin_description *d,\n   switch ((enum ix86_builtin_func_type) d->flag)\n     {\n     case VOID_FTYPE_VOID:\n+      if (icode == CODE_FOR_avx_vzeroupper)\n+\ttarget = GEN_INT (vzeroupper_intrinsic);\n       emit_insn (GEN_FCN (icode) (target));\n       return 0;\n     case VOID_FTYPE_UINT64:\n@@ -28542,6 +28979,10 @@ ix86_reorg (void)\n \tix86_avoid_jump_mispredicts ();\n #endif\n     }\n+\n+  /* Run the vzeroupper optimization if needed.  */\n+  if (cfun->machine->use_vzeroupper_p)\n+    move_or_delete_vzeroupper ();\n }\n \n /* Return nonzero when QImode register that must be represented via REX prefix"}, {"sha": "54740481ed886f67f54505484d687f2a7d417a96", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2767a7f2109b4b3cf980c7f5fab5d6383085f12a/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2767a7f2109b4b3cf980c7f5fab5d6383085f12a/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=2767a7f2109b4b3cf980c7f5fab5d6383085f12a", "patch": "@@ -1507,6 +1507,7 @@ typedef struct ix86_args {\n   int mmx_nregs;\t\t/* # mmx registers available for passing */\n   int mmx_regno;\t\t/* next available mmx register number */\n   int maybe_vaarg;\t\t/* true for calls to possibly vardic fncts.  */\n+  int caller;\t\t\t/* true if it is caller.  */\n   int float_in_sse;\t\t/* Set to 1 or 2 for 32bit targets if\n \t\t\t\t   SFmode/DFmode arguments should be passed\n \t\t\t\t   in SSE registers.  Otherwise 0.  */\n@@ -1519,7 +1520,8 @@ typedef struct ix86_args {\n    For a library call, FNTYPE is 0.  */\n \n #define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, FNDECL, N_NAMED_ARGS) \\\n-  init_cumulative_args (&(CUM), (FNTYPE), (LIBNAME), (FNDECL))\n+  init_cumulative_args (&(CUM), (FNTYPE), (LIBNAME), (FNDECL), \\\n+\t\t\t(N_NAMED_ARGS) != -1)\n \n /* Output assembler code to FILE to increment profiler label # LABELNO\n    for profiling a function entry.  */\n@@ -2289,6 +2291,24 @@ struct GTY(()) machine_function {\n      stack below the return address.  */\n   BOOL_BITFIELD static_chain_on_stack : 1;\n \n+  /* Nonzero if the current function uses vzeroupper.  */\n+  BOOL_BITFIELD use_vzeroupper_p : 1;\n+\n+  /* Nonzero if the current function uses 256bit AVX regisers.  */\n+  BOOL_BITFIELD use_avx256_p : 1;\n+\n+  /* Nonzero if caller passes 256bit AVX modes.  */\n+  BOOL_BITFIELD caller_pass_avx256_p : 1;\n+\n+  /* Nonzero if caller returns 256bit AVX modes.  */\n+  BOOL_BITFIELD caller_return_avx256_p : 1;\n+\n+  /* Nonzero if the current callee passes 256bit AVX modes.  */\n+  BOOL_BITFIELD callee_pass_avx256_p : 1;\n+\n+  /* Nonzero if the current callee returns 256bit AVX modes.  */\n+  BOOL_BITFIELD callee_return_avx256_p : 1;\n+\n   /* During prologue/epilogue generation, the current frame state.\n      Otherwise, the frame state at the end of the prologue.  */\n   struct machine_frame_state fs;"}, {"sha": "28a921f9131a0eea795843976d152d099d676cd0", "filename": "gcc/config/i386/i386.opt", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2767a7f2109b4b3cf980c7f5fab5d6383085f12a/gcc%2Fconfig%2Fi386%2Fi386.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2767a7f2109b4b3cf980c7f5fab5d6383085f12a/gcc%2Fconfig%2Fi386%2Fi386.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.opt?ref=2767a7f2109b4b3cf980c7f5fab5d6383085f12a", "patch": "@@ -256,6 +256,11 @@ mcld\n Target Report Mask(CLD) Save\n Generate cld instruction in the function prologue.\n \n+mvzeroupper\n+Target Report Mask(VZEROUPPER) Save\n+Generate vzeroupper instruction before a transfer of control flow out of\n+the function.\n+\n mfused-madd\n Target Report Mask(FUSED_MADD) Save\n Enable automatic generation of fused floating point multiply-add instructions"}, {"sha": "364e93a7398555550c2dcdaaadd0ec77e3b5a454", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2767a7f2109b4b3cf980c7f5fab5d6383085f12a/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2767a7f2109b4b3cf980c7f5fab5d6383085f12a/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=2767a7f2109b4b3cf980c7f5fab5d6383085f12a", "patch": "@@ -1178,28 +1178,6 @@\n   return true;\n })\n \n-;; Return true if OP is a vzeroupper operation, known to be a PARALLEL.\n-(define_predicate \"vzeroupper_operation\"\n-  (match_code \"parallel\")\n-{\n-  unsigned i, nregs = TARGET_64BIT ? 16 : 8;\n- \n-  if ((unsigned) XVECLEN (op, 0) != 1 + nregs)\n-    return false;\n-\n-  for (i = 0; i < nregs; i++)\n-    {\n-      rtx elt = XVECEXP (op, 0, i+1);\n-\n-      if (GET_CODE (elt) != CLOBBER\n-\t  || GET_CODE (SET_DEST (elt)) != REG\n-\t  || GET_MODE (SET_DEST (elt)) != V8SImode\n-\t  || REGNO (SET_DEST (elt)) != SSE_REGNO (i))\n-\treturn false;\n-    }\n-  return true;\n-})\n-\n ;; Return true if OP is a parallel for a vpermilp[ds] permute.\n ;; ??? It would be much easier if the PARALLEL for a VEC_SELECT\n ;; had a mode, but it doesn't.  So we have 4 copies and install"}, {"sha": "078fac6c0f1f2b7aa5f362af559d7dbc04a0313c", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 5, "deletions": 23, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2767a7f2109b4b3cf980c7f5fab5d6383085f12a/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2767a7f2109b4b3cf980c7f5fab5d6383085f12a/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=2767a7f2109b4b3cf980c7f5fab5d6383085f12a", "patch": "@@ -11508,29 +11508,11 @@\n    (set_attr \"prefix\" \"vex\")\n    (set_attr \"mode\" \"OI\")])\n \n-;; vzeroupper clobbers the upper 128bits of AVX registers.\n-(define_expand \"avx_vzeroupper\"\n-  [(match_par_dup 0 [(const_int 0)])]\n-  \"TARGET_AVX\"\n-{\n-  int nregs = TARGET_64BIT ? 16 : 8;\n-  int regno;\n-\n-  operands[0] = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (nregs + 1));\n-\n-  XVECEXP (operands[0], 0, 0)\n-    = gen_rtx_UNSPEC_VOLATILE (VOIDmode, gen_rtvec (1, const0_rtx),\n-\t\t\t       UNSPECV_VZEROUPPER);\n-\n-  for (regno = 0; regno < nregs; regno++)\n-    XVECEXP (operands[0], 0, regno + 1)\n-      = gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t gen_rtx_REG (V8SImode, SSE_REGNO (regno)));\n-})\n-\n-(define_insn \"*avx_vzeroupper\"\n-  [(match_parallel 0 \"vzeroupper_operation\"\n-    [(unspec_volatile [(const_int 0)] UNSPECV_VZEROUPPER)])]\n+;; Clear the upper 128bits of AVX registers, equivalent to a NOP\n+;; if the upper 128bits are unused.\n+(define_insn \"avx_vzeroupper\"\n+  [(unspec_volatile [(match_operand 0 \"const_int_operand\" \"\")]\n+\t\t    UNSPECV_VZEROUPPER)]\n   \"TARGET_AVX\"\n   \"vzeroupper\"\n   [(set_attr \"type\" \"sse\")"}, {"sha": "365b8c3af434c952afb12671163aaa5cc38ce99e", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2767a7f2109b4b3cf980c7f5fab5d6383085f12a/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2767a7f2109b4b3cf980c7f5fab5d6383085f12a/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=2767a7f2109b4b3cf980c7f5fab5d6383085f12a", "patch": "@@ -594,7 +594,7 @@ Objective-C and Objective-C++ Dialects}.\n -mno-wide-multiply  -mrtd  -malign-double @gol\n -mpreferred-stack-boundary=@var{num}\n -mincoming-stack-boundary=@var{num} @gol\n--mcld -mcx16 -msahf -mmovbe -mcrc32 -mrecip @gol\n+-mcld -mcx16 -msahf -mmovbe -mcrc32 -mrecip -mvzeroupper @gol\n -mmmx  -msse  -msse2 -msse3 -mssse3 -msse4.1 -msse4.2 -msse4 -mavx @gol\n -maes -mpclmul -mfsgsbase -mrdrnd -mf16c -mfused-madd @gol\n -msse4a -m3dnow -mpopcnt -mabm -mfma4 -mxop -mlwp @gol\n@@ -12466,6 +12466,13 @@ GCC with the @option{--enable-cld} configure option.  Generation of @code{cld}\n instructions can be suppressed with the @option{-mno-cld} compiler option\n in this case.\n \n+@item -mvzeroupper\n+@opindex mvzeroupper\n+This option instructs GCC to emit a @code{vzeroupper} instruction\n+before a transfer of control flow out of the function to minimize\n+AVX to SSE transition penalty as well as remove unnecessary zeroupper \n+intrinsics.\n+\n @item -mcx16\n @opindex mcx16\n This option will enable GCC to use CMPXCHG16B instruction in generated code."}, {"sha": "d7e5e8db17bd81916e19e5d28910729b4f19480b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2767a7f2109b4b3cf980c7f5fab5d6383085f12a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2767a7f2109b4b3cf980c7f5fab5d6383085f12a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2767a7f2109b4b3cf980c7f5fab5d6383085f12a", "patch": "@@ -1,3 +1,21 @@\n+2010-10-27  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\t* gcc.target/i386/avx-vzeroupper-1.c: Add -mtune=generic.\n+\t* gcc.target/i386/avx-vzeroupper-2.c: Likewise.\n+\n+\t* gcc.target/i386/avx-vzeroupper-3.c: New.\n+\t* gcc.target/i386/avx-vzeroupper-4.c: Likewise.\n+\t* gcc.target/i386/avx-vzeroupper-5.c: Likewise.\n+\t* gcc.target/i386/avx-vzeroupper-6.c: Likewise.\n+\t* gcc.target/i386/avx-vzeroupper-7.c: Likewise.\n+\t* gcc.target/i386/avx-vzeroupper-8.c: Likewise.\n+\t* gcc.target/i386/avx-vzeroupper-9.c: Likewise.\n+\t* gcc.target/i386/avx-vzeroupper-10.c: Likewise.\n+\t* gcc.target/i386/avx-vzeroupper-11.c: Likewise.\n+\t* gcc.target/i386/avx-vzeroupper-12.c: Likewise.\n+\t* gcc.target/i386/avx-vzeroupper-13.c: Likewise.\n+\t* gcc.target/i386/avx-vzeroupper-14.c: Likewise.\n+\n 2010-10-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* obj-c.dg/property/at-property-4.m: New."}, {"sha": "73ce795f35146d6349a82ea608309bad37bbbad2", "filename": "gcc/testsuite/gcc.target/i386/avx-vzeroupper-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2767a7f2109b4b3cf980c7f5fab5d6383085f12a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2767a7f2109b4b3cf980c7f5fab5d6383085f12a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-1.c?ref=2767a7f2109b4b3cf980c7f5fab5d6383085f12a", "patch": "@@ -1,6 +1,6 @@\n /* { dg-do run } */\n /* { dg-require-effective-target avx } */\n-/* { dg-options \"-O2 -mavx\" } */\n+/* { dg-options \"-O2 -mavx -mtune=generic\" } */\n \n #include \"avx-check.h\"\n "}, {"sha": "5007753a0b747d8a7f2ef3c25f69dbc15e0a5c34", "filename": "gcc/testsuite/gcc.target/i386/avx-vzeroupper-10.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2767a7f2109b4b3cf980c7f5fab5d6383085f12a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2767a7f2109b4b3cf980c7f5fab5d6383085f12a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-10.c?ref=2767a7f2109b4b3cf980c7f5fab5d6383085f12a", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -mavx -mvzeroupper -dp\" } */\n+\n+#include <immintrin.h>\n+\n+extern float x, y;\n+\n+void\n+foo ()\n+{\n+  x = y;\n+  _mm256_zeroupper ();\n+  _mm256_zeroupper ();\n+  _mm256_zeroupper ();\n+}\n+\n+/* { dg-final { scan-assembler-times \"avx_vzeroupper\" 3 } } */"}, {"sha": "507f9454391fbad6beef3081a2a193dfbb92b46e", "filename": "gcc/testsuite/gcc.target/i386/avx-vzeroupper-11.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2767a7f2109b4b3cf980c7f5fab5d6383085f12a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2767a7f2109b4b3cf980c7f5fab5d6383085f12a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-11.c?ref=2767a7f2109b4b3cf980c7f5fab5d6383085f12a", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -mavx -mvzeroupper -dp\" } */\n+\n+#include <immintrin.h>\n+\n+extern float x, y;\n+\n+void\n+foo ()\n+{\n+  x = y;\n+  _mm256_zeroall ();\n+  _mm256_zeroupper ();\n+  _mm256_zeroupper ();\n+  _mm256_zeroupper ();\n+}\n+\n+/* { dg-final { scan-assembler-times \"\\\\*avx_vzeroall\" 1 } } */\n+/* { dg-final { scan-assembler-times \"avx_vzeroupper\" 3 } } */"}, {"sha": "f74ea0c2cd3a3fb5ee23010d279f7de29ec693d3", "filename": "gcc/testsuite/gcc.target/i386/avx-vzeroupper-12.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2767a7f2109b4b3cf980c7f5fab5d6383085f12a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2767a7f2109b4b3cf980c7f5fab5d6383085f12a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-12.c?ref=2767a7f2109b4b3cf980c7f5fab5d6383085f12a", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -mavx -mvzeroupper -dp\" } */\n+\n+#include <immintrin.h>\n+\n+extern __m256 x, y;\n+\n+void\n+foo ()\n+{\n+  _mm256_zeroall ();\n+  _mm256_zeroupper ();\n+  x = y;\n+  _mm256_zeroupper ();\n+  _mm256_zeroupper ();\n+  _mm256_zeroupper ();\n+}\n+\n+/* { dg-final { scan-assembler-times \"avx_vzeroupper\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\\\*avx_vzeroall\" 1 } } */"}, {"sha": "cff5f88780287432adbaa52a15ce68d90054daad", "filename": "gcc/testsuite/gcc.target/i386/avx-vzeroupper-13.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2767a7f2109b4b3cf980c7f5fab5d6383085f12a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2767a7f2109b4b3cf980c7f5fab5d6383085f12a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-13.c?ref=2767a7f2109b4b3cf980c7f5fab5d6383085f12a", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -mavx -mno-vzeroupper -dp\" } */\n+\n+#include <immintrin.h>\n+\n+extern __m256 x, y;\n+\n+void\n+foo ()\n+{\n+  x = y;\n+}\n+\n+/* { dg-final { scan-assembler-not \"avx_vzeroupper\" } } */"}, {"sha": "e74bc247c6bf6f12084fa68ab5a3311a6edb07bb", "filename": "gcc/testsuite/gcc.target/i386/avx-vzeroupper-14.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2767a7f2109b4b3cf980c7f5fab5d6383085f12a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2767a7f2109b4b3cf980c7f5fab5d6383085f12a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-14.c?ref=2767a7f2109b4b3cf980c7f5fab5d6383085f12a", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -mavx -mtune=generic -dp\" } */\n+\n+#include <immintrin.h>\n+\n+extern __m256 x, y;\n+\n+void\n+foo ()\n+{\n+  x = y;\n+}\n+\n+/* { dg-final { scan-assembler-times \"avx_vzeroupper\" 1 } } */"}, {"sha": "66df90f14672f6472f36f5be67a4048bdc0b7768", "filename": "gcc/testsuite/gcc.target/i386/avx-vzeroupper-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2767a7f2109b4b3cf980c7f5fab5d6383085f12a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2767a7f2109b4b3cf980c7f5fab5d6383085f12a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-2.c?ref=2767a7f2109b4b3cf980c7f5fab5d6383085f12a", "patch": "@@ -1,6 +1,6 @@\n /* { dg-do run } */\n /* { dg-require-effective-target avx } */\n-/* { dg-options \"-O2 -mavx\" } */\n+/* { dg-options \"-O2 -mavx -mtune=generic\" } */\n \n #include \"avx-check.h\"\n "}, {"sha": "8053d787fea440006bf579e234d841a76279e978", "filename": "gcc/testsuite/gcc.target/i386/avx-vzeroupper-3.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2767a7f2109b4b3cf980c7f5fab5d6383085f12a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2767a7f2109b4b3cf980c7f5fab5d6383085f12a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-3.c?ref=2767a7f2109b4b3cf980c7f5fab5d6383085f12a", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target avx } */\n+/* { dg-options \"-O2 -mavx -mvzeroupper\" } */\n+\n+#include \"avx-check.h\"\n+\n+int s[8] = {1, 2, 3, 4, 5, 6, 7, 8};\n+int d[8] = {11, 22, 33, 44, 55, 66, 77, 88};\n+\n+void\n+__attribute__((noinline))\n+foo ()\n+{\n+  int i;\n+  for (i = 0; i < ARRAY_SIZE (d); i++)\n+    d[i] = s[i] + 0x1000;\n+}\n+\n+static void\n+__attribute__((noinline))\n+bar (__m256i src)\n+{\n+  foo ();\n+  _mm256_storeu_si256 ((__m256i*) d, src);\n+  if (__builtin_memcmp (d, s, sizeof (d)))\n+    abort ();\n+}\n+\n+static void\n+avx_test (void)\n+{\n+  __m256i src = _mm256_loadu_si256 ((__m256i*) s);\n+  bar (src);\n+}"}, {"sha": "c55c814316c2ca7bc0030ebe8a7b074418df8f05", "filename": "gcc/testsuite/gcc.target/i386/avx-vzeroupper-4.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2767a7f2109b4b3cf980c7f5fab5d6383085f12a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2767a7f2109b4b3cf980c7f5fab5d6383085f12a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-4.c?ref=2767a7f2109b4b3cf980c7f5fab5d6383085f12a", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -mavx -mvzeroupper -dp\" } */\n+\n+typedef float __m256 __attribute__ ((__vector_size__ (32), __may_alias__));\n+\n+extern void bar2 (__m256);\n+extern __m256 y;\n+\n+void\n+foo ()\n+{\n+  bar2 (y);\n+}\n+\n+/* { dg-final { scan-assembler-not \"avx_vzeroupper\" } } */"}, {"sha": "a14460cf8a4be4740425a7e6c1bf70b14d01e448", "filename": "gcc/testsuite/gcc.target/i386/avx-vzeroupper-5.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2767a7f2109b4b3cf980c7f5fab5d6383085f12a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2767a7f2109b4b3cf980c7f5fab5d6383085f12a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-5.c?ref=2767a7f2109b4b3cf980c7f5fab5d6383085f12a", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -mavx -mvzeroupper -dp\" } */\n+\n+#include <immintrin.h>\n+\n+extern void bar2 (__m256);\n+extern __m256 y;\n+\n+void\n+foo ()\n+{\n+  bar2 (y);\n+  _mm256_zeroupper ();\n+}\n+\n+/* { dg-final { scan-assembler-not \"avx_vzeroupper\" } } */"}, {"sha": "ada87bd31e9c916a96048654633c683db9f39865", "filename": "gcc/testsuite/gcc.target/i386/avx-vzeroupper-6.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2767a7f2109b4b3cf980c7f5fab5d6383085f12a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2767a7f2109b4b3cf980c7f5fab5d6383085f12a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-6.c?ref=2767a7f2109b4b3cf980c7f5fab5d6383085f12a", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -mavx -mvzeroupper -dp\" } */\n+\n+#include <immintrin.h>\n+\n+extern __m256 x, y;\n+\n+void\n+foo ()\n+{\n+  x = y;\n+  _mm256_zeroall ();\n+}\n+\n+/* { dg-final { scan-assembler-not \"avx_vzeroupper\" } } */"}, {"sha": "ab6d68779b380b34faca7beec60055a7a31897b4", "filename": "gcc/testsuite/gcc.target/i386/avx-vzeroupper-7.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2767a7f2109b4b3cf980c7f5fab5d6383085f12a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2767a7f2109b4b3cf980c7f5fab5d6383085f12a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-7.c?ref=2767a7f2109b4b3cf980c7f5fab5d6383085f12a", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -mavx -mvzeroupper -dp\" } */\n+\n+#include <immintrin.h>\n+\n+extern __m256 x, y;\n+\n+void\n+foo ()\n+{\n+  x = y;\n+  _mm256_zeroupper ();\n+}\n+\n+/* { dg-final { scan-assembler-times \"avx_vzeroupper\" 1 } } */"}, {"sha": "0a821c24a866d732b91e9ab17b5177e5b09bcb21", "filename": "gcc/testsuite/gcc.target/i386/avx-vzeroupper-8.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2767a7f2109b4b3cf980c7f5fab5d6383085f12a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2767a7f2109b4b3cf980c7f5fab5d6383085f12a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-8.c?ref=2767a7f2109b4b3cf980c7f5fab5d6383085f12a", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -mavx -mvzeroupper -dp\" } */\n+\n+#include <immintrin.h>\n+\n+extern __m256 x, y;\n+\n+void\n+foo ()\n+{\n+  x = y;\n+  _mm256_zeroall ();\n+  _mm256_zeroupper ();\n+}\n+\n+/* { dg-final { scan-assembler-not \"avx_vzeroupper\" } } */"}, {"sha": "5aa05b83902eae77e77113300f70b913c0031738", "filename": "gcc/testsuite/gcc.target/i386/avx-vzeroupper-9.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2767a7f2109b4b3cf980c7f5fab5d6383085f12a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2767a7f2109b4b3cf980c7f5fab5d6383085f12a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-9.c?ref=2767a7f2109b4b3cf980c7f5fab5d6383085f12a", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -mavx -mvzeroupper -dp\" } */\n+\n+#include <immintrin.h>\n+\n+extern __m256 x, y;\n+\n+void\n+foo ()\n+{\n+  _mm256_zeroupper ();\n+  x = y;\n+  _mm256_zeroupper ();\n+  _mm256_zeroupper ();\n+  _mm256_zeroupper ();\n+}\n+\n+/* { dg-final { scan-assembler-times \"avx_vzeroupper\" 1 } } */"}]}