{"sha": "39d658e3950054b6f18727d907a047a4dd6c10d4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzlkNjU4ZTM5NTAwNTRiNmYxODcyN2Q5MDdhMDQ3YTRkZDZjMTBkNA==", "commit": {"author": {"name": "Joel Brobecker", "email": "brobecker@gnat.com", "date": "2003-04-14T22:06:07Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2003-04-14T22:06:07Z"}, "message": "dbxout.c (print_int_cst_bounds_in_octal_p): New function, extracted from dbxout_type.\n\n\t* dbxout.c (print_int_cst_bounds_in_octal_p): New function,\n\textracted from dbxout_type.\n\t(dbxout_range_type): print large bounds in octal format.\n\t(dbxout_type): Replace extracted code by call to\n\tprint_int_cst_bounds_in_octal_p.\n\nFrom-SVN: r65599", "tree": {"sha": "ead26b5a5f141b19830e8affa8f24cc6b2541519", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ead26b5a5f141b19830e8affa8f24cc6b2541519"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/39d658e3950054b6f18727d907a047a4dd6c10d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39d658e3950054b6f18727d907a047a4dd6c10d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39d658e3950054b6f18727d907a047a4dd6c10d4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39d658e3950054b6f18727d907a047a4dd6c10d4/comments", "author": null, "committer": null, "parents": [{"sha": "4694840a01cc4b82378fdfbbf7d7d8a5c7426b54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4694840a01cc4b82378fdfbbf7d7d8a5c7426b54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4694840a01cc4b82378fdfbbf7d7d8a5c7426b54"}], "stats": {"total": 76, "additions": 50, "deletions": 26}, "files": [{"sha": "b7c46908861c347cec9434449921b75a68af44d1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d658e3950054b6f18727d907a047a4dd6c10d4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d658e3950054b6f18727d907a047a4dd6c10d4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=39d658e3950054b6f18727d907a047a4dd6c10d4", "patch": "@@ -12,6 +12,12 @@\n \n 2003-04-14  Joel Brobecker  <brobecker@gnat.com>\n \n+\t* dbxout.c (print_int_cst_bounds_in_octal_p): New function,\n+\textracted from dbxout_type.\n+\t(dbxout_range_type): print large bounds in octal format.\n+\t(dbxout_type): Replace extracted code by call to\n+\tprint_int_cst_bounds_in_octal_p.\n+\n         * dwarf2out.c (gen_compile_unit_die): Emit DW_LANG_Ada95 instead\n         of DW_LANG_Ada83 for Ada units.\n "}, {"sha": "dc898290e8edeb342a6218aa021877cfd1ca5413", "filename": "gcc/dbxout.c", "status": "modified", "additions": 44, "deletions": 26, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d658e3950054b6f18727d907a047a4dd6c10d4/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d658e3950054b6f18727d907a047a4dd6c10d4/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=39d658e3950054b6f18727d907a047a4dd6c10d4", "patch": "@@ -310,6 +310,7 @@ static void dbxout_type_method_1\tPARAMS ((tree, const char *));\n static void dbxout_type_methods\t\tPARAMS ((tree));\n static void dbxout_range_type\t\tPARAMS ((tree));\n static void dbxout_type\t\t\tPARAMS ((tree, int));\n+static bool print_int_cst_bounds_in_octal_p\tPARAMS ((tree));\n static void print_int_cst_octal\t\tPARAMS ((tree));\n static void print_octal\t\t\tPARAMS ((unsigned HOST_WIDE_INT, int));\n static void print_wide_int\t\tPARAMS ((HOST_WIDE_INT));\n@@ -1098,7 +1099,10 @@ dbxout_range_type (type)\n     {\n       putc (';', asmfile);\n       CHARS (1);\n-      print_wide_int (tree_low_cst (TYPE_MIN_VALUE (type), 0));\n+      if (print_int_cst_bounds_in_octal_p (type))\n+        print_int_cst_octal (TYPE_MIN_VALUE (type));\n+      else\n+        print_wide_int (tree_low_cst (TYPE_MIN_VALUE (type), 0));\n     }\n   else\n     {\n@@ -1111,7 +1115,10 @@ dbxout_range_type (type)\n     {\n       putc (';', asmfile);\n       CHARS (1);\n-      print_wide_int (tree_low_cst (TYPE_MAX_VALUE (type), 0));\n+      if (print_int_cst_bounds_in_octal_p (type))\n+        print_int_cst_octal (TYPE_MAX_VALUE (type));\n+      else\n+        print_wide_int (tree_low_cst (TYPE_MAX_VALUE (type), 0));\n       putc (';', asmfile);\n       CHARS (1);\n     }\n@@ -1345,30 +1352,7 @@ dbxout_type (type, full)\n \t      CHARS (5);\n \t    }\n \n-\t  /* If we can use GDB extensions and the size is wider than a\n-\t     long (the size used by GDB to read them) or we may have\n-\t     trouble writing the bounds the usual way, write them in\n-\t     octal.  Note the test is for the *target's* size of \"long\",\n-\t     not that of the host.  The host test is just to make sure we\n-\t     can write it out in case the host wide int is narrower than the\n-\t     target \"long\".  */\n-\n-\t  /* For unsigned types, we use octal if they are the same size or\n-\t     larger.  This is because we print the bounds as signed decimal,\n-\t     and hence they can't span same size unsigned types.  */\n-\n-\t  if (use_gnu_debug_info_extensions\n-\t      && TYPE_MIN_VALUE (type) != 0\n-\t      && TREE_CODE (TYPE_MIN_VALUE (type)) == INTEGER_CST\n-\t      && TYPE_MAX_VALUE (type) != 0\n-\t      && TREE_CODE (TYPE_MAX_VALUE (type)) == INTEGER_CST\n-\t      && (TYPE_PRECISION (type) > TYPE_PRECISION (integer_type_node)\n-\t\t  || ((TYPE_PRECISION (type)\n-\t\t       == TYPE_PRECISION (integer_type_node))\n-\t\t      && TREE_UNSIGNED (type))\n-\t\t  || TYPE_PRECISION (type) > HOST_BITS_PER_WIDE_INT\n-\t\t  || (TYPE_PRECISION (type) == HOST_BITS_PER_WIDE_INT\n-\t\t      && TREE_UNSIGNED (type))))\n+ \t  if (print_int_cst_bounds_in_octal_p (type))\n \t    {\n \t      fprintf (asmfile, \"r\");\n \t      CHARS (1);\n@@ -1833,6 +1817,40 @@ dbxout_type (type, full)\n     }\n }\n \n+/* Return non-zero if the given type represents an integer whose bounds\n+   should be printed in octal format.  */\n+\n+static bool\n+print_int_cst_bounds_in_octal_p (type)\n+     tree type;\n+{\n+  /* If we can use GDB extensions and the size is wider than a long\n+     (the size used by GDB to read them) or we may have trouble writing\n+     the bounds the usual way, write them in octal.  Note the test is for\n+     the *target's* size of \"long\", not that of the host.  The host test\n+     is just to make sure we can write it out in case the host wide int\n+     is narrower than the target \"long\".\n+  \n+     For unsigned types, we use octal if they are the same size or larger.\n+     This is because we print the bounds as signed decimal, and hence they\n+     can't span same size unsigned types.  */\n+\n+  if (use_gnu_debug_info_extensions\n+      && TYPE_MIN_VALUE (type) != 0\n+      && TREE_CODE (TYPE_MIN_VALUE (type)) == INTEGER_CST\n+      && TYPE_MAX_VALUE (type) != 0\n+      && TREE_CODE (TYPE_MAX_VALUE (type)) == INTEGER_CST\n+      && (TYPE_PRECISION (type) > TYPE_PRECISION (integer_type_node)\n+\t  || ((TYPE_PRECISION (type) == TYPE_PRECISION (integer_type_node))\n+\t      && TREE_UNSIGNED (type))\n+\t  || TYPE_PRECISION (type) > HOST_BITS_PER_WIDE_INT\n+\t  || (TYPE_PRECISION (type) == HOST_BITS_PER_WIDE_INT\n+\t      && TREE_UNSIGNED (type))))\n+    return TRUE;\n+  else\n+    return FALSE;\n+}\n+\n /* Print the value of integer constant C, in octal,\n    handling double precision.  */\n "}]}