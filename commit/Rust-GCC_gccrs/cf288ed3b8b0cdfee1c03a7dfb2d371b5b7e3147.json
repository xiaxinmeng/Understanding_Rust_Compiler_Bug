{"sha": "cf288ed3b8b0cdfee1c03a7dfb2d371b5b7e3147", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2YyODhlZDNiOGIwY2RmZWUxYzAzYTdkZmIyZDM3MWI1YjdlMzE0Nw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-05-20T19:57:45Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-05-20T19:57:45Z"}, "message": "tree.h (DECL_ONE_ONLY): Return true only for externally visible symbols.\n\n\n\t* tree.h (DECL_ONE_ONLY): Return true only for externally visible\n\tsymbols.\n\t* except.c (switch_to_exception_section, resolve_unique_section,\n\tget_named_text_section, default_function_rodata_section, \n\talign_variable, get_block_for_decl, default_section_type_flags):\n\tUse DECL_COMDAT_GROUP instead of DECL_ONE_ONLY.\n\t* symtab.c (symtab_add_to_same_comdat_group,\n\tsymtab_make_decl_local, fixup_same_cpp_alias_visibility,\n\tsymtab_nonoverwritable_alias, symtab_get_symbol_partitioning_class):\n\tLikewise.\n\t* cgraphclones.c (cgraph_create_virtual_clone): Likewise.\n\t* bb-reorder.c (pass_partition_blocks::gate): Likewise.\n\t* config/c6x/c6x.c (c6x_elf_unique_section): Likewise.\n\t(c6x_function_in_section_p): Likewise.\n\t* config/darwin.c (machopic_select_section): Likewise.\n\t* config/arm/arm.c (arm_function_in_section_p): Likewise.\n\t* config/mips/mips.c (mips_function_rodata_section): Likewise.\n\t* config/mep/mep.c (mep_select_section): LIkewise.\n\t* config/i386/i386.c (x86_64_elf_unique_section): Likewise.\n\nFrom-SVN: r210654", "tree": {"sha": "c7cb5df0ad4b66323aabee83001d4e28934f6229", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c7cb5df0ad4b66323aabee83001d4e28934f6229"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf288ed3b8b0cdfee1c03a7dfb2d371b5b7e3147", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf288ed3b8b0cdfee1c03a7dfb2d371b5b7e3147", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf288ed3b8b0cdfee1c03a7dfb2d371b5b7e3147", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf288ed3b8b0cdfee1c03a7dfb2d371b5b7e3147/comments", "author": null, "committer": null, "parents": [{"sha": "f4cd9c518ba414724bacb1d936ba1676929fa52e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4cd9c518ba414724bacb1d936ba1676929fa52e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4cd9c518ba414724bacb1d936ba1676929fa52e"}], "stats": {"total": 79, "additions": 51, "deletions": 28}, "files": [{"sha": "e16d69e5e57976d42ca68023c02e85c58f9e081e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf288ed3b8b0cdfee1c03a7dfb2d371b5b7e3147/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf288ed3b8b0cdfee1c03a7dfb2d371b5b7e3147/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cf288ed3b8b0cdfee1c03a7dfb2d371b5b7e3147", "patch": "@@ -1,3 +1,25 @@\n+2014-05-20  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* tree.h (DECL_ONE_ONLY): Return true only for externally visible\n+\tsymbols.\n+\t* except.c (switch_to_exception_section, resolve_unique_section,\n+\tget_named_text_section, default_function_rodata_section, \n+\talign_variable, get_block_for_decl, default_section_type_flags):\n+\tUse DECL_COMDAT_GROUP instead of DECL_ONE_ONLY.\n+\t* symtab.c (symtab_add_to_same_comdat_group,\n+\tsymtab_make_decl_local, fixup_same_cpp_alias_visibility,\n+\tsymtab_nonoverwritable_alias, symtab_get_symbol_partitioning_class):\n+\tLikewise.\n+\t* cgraphclones.c (cgraph_create_virtual_clone): Likewise.\n+\t* bb-reorder.c (pass_partition_blocks::gate): Likewise.\n+\t* config/c6x/c6x.c (c6x_elf_unique_section): Likewise.\n+\t(c6x_function_in_section_p): Likewise.\n+\t* config/darwin.c (machopic_select_section): Likewise.\n+\t* config/arm/arm.c (arm_function_in_section_p): Likewise.\n+\t* config/mips/mips.c (mips_function_rodata_section): Likewise.\n+\t* config/mep/mep.c (mep_select_section): LIkewise.\n+\t* config/i386/i386.c (x86_64_elf_unique_section): Likewise.\n+\n 2014-05-20  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* tree-ssa-dom.c (hashable_expr_equal_p) <EXPR_CALL>: Also compare the"}, {"sha": "f16f57b69611b0aa3178a2668d5afcaddea667fc", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf288ed3b8b0cdfee1c03a7dfb2d371b5b7e3147/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf288ed3b8b0cdfee1c03a7dfb2d371b5b7e3147/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=cf288ed3b8b0cdfee1c03a7dfb2d371b5b7e3147", "patch": "@@ -2669,7 +2669,7 @@ pass_partition_blocks::gate (function *fun)\n \t  /* See gate_handle_reorder_blocks.  We should not partition if\n \t     we are going to omit the reordering.  */\n \t  && optimize_function_for_speed_p (fun)\n-\t  && !DECL_ONE_ONLY (current_function_decl)\n+\t  && !DECL_COMDAT_GROUP (current_function_decl)\n \t  && !user_defined_section_attribute);\n }\n "}, {"sha": "df8b2a29e2248d74d74426e05150ae0f2d27b4b3", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf288ed3b8b0cdfee1c03a7dfb2d371b5b7e3147/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf288ed3b8b0cdfee1c03a7dfb2d371b5b7e3147/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=cf288ed3b8b0cdfee1c03a7dfb2d371b5b7e3147", "patch": "@@ -558,7 +558,7 @@ cgraph_create_virtual_clone (struct cgraph_node *old_node,\n      that is not weak also.\n      ??? We cannot use COMDAT linkage because there is no\n      ABI support for this.  */\n-  if (DECL_ONE_ONLY (old_decl))\n+  if (DECL_COMDAT_GROUP (old_decl))\n     DECL_SECTION_NAME (new_node->decl) = NULL;\n   set_new_clone_decl_and_node_flags (new_node);\n   new_node->clone.tree_map = tree_map;"}, {"sha": "ccad5484ff519c5c304d54875ec960a61dee869a", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf288ed3b8b0cdfee1c03a7dfb2d371b5b7e3147/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf288ed3b8b0cdfee1c03a7dfb2d371b5b7e3147/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=cf288ed3b8b0cdfee1c03a7dfb2d371b5b7e3147", "patch": "@@ -6154,7 +6154,7 @@ arm_function_in_section_p (tree decl, section *section)\n   if (!DECL_SECTION_NAME (decl))\n     {\n       /* Make sure that we will not create a unique section for DECL.  */\n-      if (flag_function_sections || DECL_ONE_ONLY (decl))\n+      if (flag_function_sections || DECL_COMDAT_GROUP (decl))\n \treturn false;\n     }\n "}, {"sha": "339da13e23b36d1e82192ac7dda798c1e3b1bc44", "filename": "gcc/config/c6x/c6x.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf288ed3b8b0cdfee1c03a7dfb2d371b5b7e3147/gcc%2Fconfig%2Fc6x%2Fc6x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf288ed3b8b0cdfee1c03a7dfb2d371b5b7e3147/gcc%2Fconfig%2Fc6x%2Fc6x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x.c?ref=cf288ed3b8b0cdfee1c03a7dfb2d371b5b7e3147", "patch": "@@ -985,7 +985,7 @@ c6x_elf_unique_section (tree decl, int reloc)\n {\n   const char *prefix = NULL;\n   /* We only need to use .gnu.linkonce if we don't have COMDAT groups.  */\n-  bool one_only = DECL_ONE_ONLY (decl) && !HAVE_COMDAT_GROUP;\n+  bool one_only = DECL_COMDAT_GROUP (decl) && !HAVE_COMDAT_GROUP;\n \n   if (c6x_in_small_data_p (decl))\n     {\n@@ -1202,7 +1202,7 @@ c6x_function_in_section_p (tree decl, section *section)\n   if (!DECL_SECTION_NAME (decl))\n     {\n       /* Make sure that we will not create a unique section for DECL.  */\n-      if (flag_function_sections || DECL_ONE_ONLY (decl))\n+      if (flag_function_sections || DECL_COMDAT_GROUP (decl))\n \treturn false;\n     }\n "}, {"sha": "cec341dfe35ac32d7733ee0b4adc09a8fdc2aaca", "filename": "gcc/config/darwin.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf288ed3b8b0cdfee1c03a7dfb2d371b5b7e3147/gcc%2Fconfig%2Fdarwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf288ed3b8b0cdfee1c03a7dfb2d371b5b7e3147/gcc%2Fconfig%2Fdarwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.c?ref=cf288ed3b8b0cdfee1c03a7dfb2d371b5b7e3147", "patch": "@@ -1521,7 +1521,7 @@ machopic_select_section (tree decl,\n \n   one = DECL_P (decl) \n \t&& TREE_CODE (decl) == VAR_DECL \n-\t&& DECL_ONE_ONLY (decl);\n+\t&& DECL_COMDAT_GROUP (decl);\n \n   ro = TREE_READONLY (decl) || TREE_CONSTANT (decl) ;\n "}, {"sha": "415e31b560668027eea095f5561277aafba8bb2c", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf288ed3b8b0cdfee1c03a7dfb2d371b5b7e3147/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf288ed3b8b0cdfee1c03a7dfb2d371b5b7e3147/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=cf288ed3b8b0cdfee1c03a7dfb2d371b5b7e3147", "patch": "@@ -5147,7 +5147,7 @@ x86_64_elf_unique_section (tree decl, int reloc)\n     {\n       const char *prefix = NULL;\n       /* We only need to use .gnu.linkonce if we don't have COMDAT groups.  */\n-      bool one_only = DECL_ONE_ONLY (decl) && !HAVE_COMDAT_GROUP;\n+      bool one_only = DECL_COMDAT_GROUP (decl) && !HAVE_COMDAT_GROUP;\n \n       switch (categorize_decl_for_section (decl, reloc))\n \t{"}, {"sha": "107f1fa02d7aced83f56359ae6926fdd599a7199", "filename": "gcc/config/mep/mep.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf288ed3b8b0cdfee1c03a7dfb2d371b5b7e3147/gcc%2Fconfig%2Fmep%2Fmep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf288ed3b8b0cdfee1c03a7dfb2d371b5b7e3147/gcc%2Fconfig%2Fmep%2Fmep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmep%2Fmep.c?ref=cf288ed3b8b0cdfee1c03a7dfb2d371b5b7e3147", "patch": "@@ -4532,7 +4532,7 @@ mep_select_section (tree decl, int reloc ATTRIBUTE_UNUSED,\n       else\n \tencoding = 0;\n \n-      if (flag_function_sections || DECL_ONE_ONLY (decl))\n+      if (flag_function_sections || DECL_COMDAT_GROUP (decl))\n \tmep_unique_section (decl, 0);\n       else if (lookup_attribute (\"vliw\", TYPE_ATTRIBUTES (TREE_TYPE (decl))))\n \t{\n@@ -4651,7 +4651,7 @@ mep_unique_section (tree decl, int reloc)\n       name += 3;\n     }\n \n-  prefix = prefixes[sec][DECL_ONE_ONLY(decl)];\n+  prefix = prefixes[sec][DECL_COMDAT_GROUP(decl) != NULL];\n   len    = strlen (name) + strlen (prefix);\n   string = (char *) alloca (len + 1);\n "}, {"sha": "17af1d6fbd6935ca149d815ae00b4c1ddd2e1c07", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf288ed3b8b0cdfee1c03a7dfb2d371b5b7e3147/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf288ed3b8b0cdfee1c03a7dfb2d371b5b7e3147/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=cf288ed3b8b0cdfee1c03a7dfb2d371b5b7e3147", "patch": "@@ -8469,7 +8469,7 @@ mips_function_rodata_section (tree decl)\n   if (decl && DECL_SECTION_NAME (decl))\n     {\n       const char *name = TREE_STRING_POINTER (DECL_SECTION_NAME (decl));\n-      if (DECL_ONE_ONLY (decl) && strncmp (name, \".gnu.linkonce.t.\", 16) == 0)\n+      if (DECL_COMDAT_GROUP (decl) && strncmp (name, \".gnu.linkonce.t.\", 16) == 0)\n \t{\n \t  char *rname = ASTRDUP (name);\n \t  rname[14] = 'd';"}, {"sha": "fe1de06a12e963f90200fcfff1858af6a8409bd0", "filename": "gcc/except.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf288ed3b8b0cdfee1c03a7dfb2d371b5b7e3147/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf288ed3b8b0cdfee1c03a7dfb2d371b5b7e3147/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=cf288ed3b8b0cdfee1c03a7dfb2d371b5b7e3147", "patch": "@@ -2867,12 +2867,12 @@ switch_to_exception_section (const char * ARG_UNUSED (fnname))\n \n #ifdef HAVE_LD_EH_GC_SECTIONS\n \t  if (flag_function_sections\n-\t      || (DECL_ONE_ONLY (current_function_decl) && HAVE_COMDAT_GROUP))\n+\t      || (DECL_COMDAT_GROUP (current_function_decl) && HAVE_COMDAT_GROUP))\n \t    {\n \t      char *section_name = XNEWVEC (char, strlen (fnname) + 32);\n \t      /* The EH table must match the code section, so only mark\n \t\t it linkonce if we have COMDAT groups to tie them together.  */\n-\t      if (DECL_ONE_ONLY (current_function_decl) && HAVE_COMDAT_GROUP)\n+\t      if (DECL_COMDAT_GROUP (current_function_decl) && HAVE_COMDAT_GROUP)\n \t\tflags |= SECTION_LINKONCE;\n \t      sprintf (section_name, \".gcc_except_table.%s\", fnname);\n \t      s = get_section (section_name, flags, current_function_decl);"}, {"sha": "9d7c7e64b494484970ab7e4670b94d91b351d922", "filename": "gcc/symtab.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf288ed3b8b0cdfee1c03a7dfb2d371b5b7e3147/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf288ed3b8b0cdfee1c03a7dfb2d371b5b7e3147/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=cf288ed3b8b0cdfee1c03a7dfb2d371b5b7e3147", "patch": "@@ -513,7 +513,7 @@ void\n symtab_add_to_same_comdat_group (symtab_node *new_node,\n \t\t\t\t symtab_node *old_node)\n {\n-  gcc_assert (DECL_ONE_ONLY (old_node->decl));\n+  gcc_assert (DECL_COMDAT_GROUP (old_node->decl));\n   gcc_assert (!new_node->same_comdat_group);\n   gcc_assert (new_node != old_node);\n \n@@ -832,9 +832,9 @@ verify_symtab_base (symtab_node *node)\n     {\n       symtab_node *n = node->same_comdat_group;\n \n-      if (!DECL_ONE_ONLY (n->decl))\n+      if (!DECL_COMDAT_GROUP (n->decl))\n \t{\n-\t  error (\"non-DECL_ONE_ONLY node in a same_comdat_group list\");\n+\t  error (\"node is in same_comdat_group list but has no DECL_COMDAT_GROUP\");\n \t  error_found = true;\n \t}\n       if (DECL_COMDAT_GROUP (n->decl) != DECL_COMDAT_GROUP (node->same_comdat_group->decl))\n@@ -958,7 +958,7 @@ symtab_make_decl_local (tree decl)\n     DECL_COMMON (decl) = 0;\n   else gcc_assert (TREE_CODE (decl) == FUNCTION_DECL);\n \n-  if (DECL_ONE_ONLY (decl) || DECL_COMDAT (decl))\n+  if (DECL_COMDAT_GROUP (decl) || DECL_COMDAT (decl))\n     {\n       DECL_SECTION_NAME (decl) = 0;\n       DECL_COMDAT (decl) = 0;\n@@ -1101,7 +1101,7 @@ fixup_same_cpp_alias_visibility (symtab_node *node, symtab_node *target)\n       DECL_COMDAT (node->decl) = DECL_COMDAT (target->decl);\n       DECL_COMDAT_GROUP (node->decl)\n \t = DECL_COMDAT_GROUP (target->decl);\n-      if (DECL_ONE_ONLY (target->decl)\n+      if (DECL_COMDAT_GROUP (target->decl)\n \t  && !node->same_comdat_group)\n \tsymtab_add_to_same_comdat_group (node, target);\n     }\n@@ -1231,7 +1231,7 @@ symtab_nonoverwritable_alias (symtab_node *node)\n \n   /* Update the properties.  */\n   DECL_EXTERNAL (new_decl) = 0;\n-  if (DECL_ONE_ONLY (node->decl))\n+  if (DECL_COMDAT_GROUP (node->decl))\n     DECL_SECTION_NAME (new_decl) = NULL;\n   DECL_COMDAT_GROUP (new_decl) = 0;\n   TREE_PUBLIC (new_decl) = 0;\n@@ -1328,8 +1328,7 @@ symtab_get_symbol_partitioning_class (symtab_node *node)\n     return SYMBOL_EXTERNAL;\n \n   /* Linker discardable symbols are duplicated to every use unless they are\n-     keyed.\n-     Keyed symbols or those.  */\n+     keyed.  */\n   if (DECL_ONE_ONLY (node->decl)\n       && !node->force_output\n       && !node->forced_by_abi"}, {"sha": "e0a3084b755d620899217c6e257cad3e043a6981", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf288ed3b8b0cdfee1c03a7dfb2d371b5b7e3147/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf288ed3b8b0cdfee1c03a7dfb2d371b5b7e3147/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=cf288ed3b8b0cdfee1c03a7dfb2d371b5b7e3147", "patch": "@@ -2327,7 +2327,8 @@ extern void decl_value_expr_insert (tree, tree);\n \n /* Used in TREE_PUBLIC decls to indicate that copies of this DECL in\n    multiple translation units should be merged.  */\n-#define DECL_ONE_ONLY(NODE) (DECL_COMDAT_GROUP (NODE) != NULL_TREE)\n+#define DECL_ONE_ONLY(NODE) (DECL_COMDAT_GROUP (NODE) != NULL_TREE \\\n+\t\t\t     && (TREE_PUBLIC (NODE) || DECL_EXTERNAL (NODE)))\n \n /* The name of the object as the assembler will see it (but before any\n    translations made by ASM_OUTPUT_LABELREF).  Often this is the same"}, {"sha": "67810960a6e7ec730c6a9583cb83030291114546", "filename": "gcc/varasm.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf288ed3b8b0cdfee1c03a7dfb2d371b5b7e3147/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf288ed3b8b0cdfee1c03a7dfb2d371b5b7e3147/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=cf288ed3b8b0cdfee1c03a7dfb2d371b5b7e3147", "patch": "@@ -428,7 +428,7 @@ resolve_unique_section (tree decl, int reloc ATTRIBUTE_UNUSED,\n   if (DECL_SECTION_NAME (decl) == NULL_TREE\n       && targetm_common.have_named_sections\n       && (flag_function_or_data_sections\n-\t  || DECL_ONE_ONLY (decl)))\n+\t  || DECL_COMDAT_GROUP (decl)))\n     {\n       targetm.asm_out.unique_section (decl, reloc);\n       DECL_HAS_IMPLICIT_SECTION_NAME_P (decl) = true;\n@@ -517,7 +517,7 @@ get_named_text_section (tree decl,\n \n \t  /* Do not try to split gnu_linkonce functions.  This gets somewhat\n \t     slipperly.  */\n-\t  if (DECL_ONE_ONLY (decl) && !HAVE_COMDAT_GROUP)\n+\t  if (DECL_COMDAT_GROUP (decl) && !HAVE_COMDAT_GROUP)\n \t    return NULL;\n \t  name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n \t  name = targetm.strip_name_encoding (name);\n@@ -687,7 +687,7 @@ default_function_rodata_section (tree decl)\n     {\n       const char *name = TREE_STRING_POINTER (DECL_SECTION_NAME (decl));\n \n-      if (DECL_ONE_ONLY (decl) && HAVE_COMDAT_GROUP)\n+      if (DECL_COMDAT_GROUP (decl) && HAVE_COMDAT_GROUP)\n         {\n \t  const char *dot;\n \t  size_t len;\n@@ -704,7 +704,7 @@ default_function_rodata_section (tree decl)\n \t  return get_section (rname, SECTION_LINKONCE, decl);\n \t}\n       /* For .gnu.linkonce.t.foo we want to use .gnu.linkonce.r.foo.  */\n-      else if (DECL_ONE_ONLY (decl)\n+      else if (DECL_COMDAT_GROUP (decl)\n \t       && strncmp (name, \".gnu.linkonce.t.\", 16) == 0)\n \t{\n \t  size_t len = strlen (name) + 1;\n@@ -996,7 +996,8 @@ align_variable (tree decl, bool dont_output_data)\n \t and for code accessing the variable as guaranteed alignment, we\n \t can only increase the alignment if it is a performance optimization\n \t if the references to it must bind to the current definition.  */\n-      if (decl_binds_to_current_def_p (decl))\n+      if (decl_binds_to_current_def_p (decl)\n+\t  && !DECL_VIRTUAL_P (decl))\n \t{\n #ifdef DATA_ALIGNMENT\n \t  unsigned int data_align = DATA_ALIGNMENT (TREE_TYPE (decl), align);\n@@ -1142,7 +1143,7 @@ get_block_for_decl (tree decl)\n \n       /* There's no point using object blocks for something that is\n \t isolated by definition.  */\n-      if (DECL_ONE_ONLY (decl))\n+      if (DECL_COMDAT_GROUP (decl))\n \treturn NULL;\n     }\n \n@@ -6076,7 +6077,7 @@ default_section_type_flags (tree decl, const char *name, int reloc)\n \tflags |= SECTION_RELRO;\n     }\n \n-  if (decl && DECL_P (decl) && DECL_ONE_ONLY (decl))\n+  if (decl && DECL_P (decl) && DECL_COMDAT_GROUP (decl))\n     flags |= SECTION_LINKONCE;\n \n   if (strcmp (name, \".vtable_map_vars\") == 0)"}]}