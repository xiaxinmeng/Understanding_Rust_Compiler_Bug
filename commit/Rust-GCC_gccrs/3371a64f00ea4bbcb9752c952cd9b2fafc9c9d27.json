{"sha": "3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzM3MWE2NGYwMGVhNGJiY2I5NzUyYzk1MmNkOWIyZmFmYzljOWQyNw==", "commit": {"author": {"name": "Teresa Johnson", "email": "tejohnson@google.com", "date": "2013-06-06T16:30:07Z"}, "committer": {"name": "Teresa Johnson", "email": "tejohnson@gcc.gnu.org", "date": "2013-06-06T16:30:07Z"}, "message": "re PR c++/53743 (ICE when compiling firefox with PGO and LTO)\n\n2013-06-06  Teresa Johnson  <tejohnson@google.com>\n\n\tPR c++/53743\n\t* ifcvt.c (find_if_case_1): Replace BB_COPY_PARTITION with assert\n\tas this is now done by redirect_edge_and_branch_force.\n\t* function.c (thread_prologue_and_epilogue_insns): Insert new bb after\n\tbarriers, and fix interaction with splitting.\n\t* emit-rtl.c (try_split): Copy REG_CROSSING_JUMP notes.\n\t* cfgcleanup.c (try_forward_edges): Fix early return value to properly\n\treflect changes made in the routine.\n\t* bb-reorder.c (emit_barrier_after_bb): Move to cfgrtl.c.\n\t(fix_up_fall_thru_edges): Remove incorrect check for bb layout order\n\tsince this is called in cfglayout mode, and replace partition fixup\n\twith assert as that is now done by force_nonfallthru_and_redirect.\n\t(add_reg_crossing_jump_notes): Handle the fact that some jumps may\n\talready be marked with region crossing note.\n\t(insert_section_boundary_note): Make non-static, gate on flag\n\thas_bb_partition, rewrite to also check for multiple partitions.\n\t(rest_of_handle_reorder_blocks): Remove call to\n\tinsert_section_boundary_note, now done later during free_cfg.\n\t(duplicate_computed_gotos): Don't duplicate partition crossing edge.\n\t* bb-reorder.h (insert_section_boundary_note): Declare.\n\t* Makefile.in (cfgrtl.o): Depend on bb-reorder.h\n\t* cfgrtl.c (rest_of_pass_free_cfg): If partitions exist\n\tinvoke insert_section_boundary_note.\n\t(try_redirect_by_replacing_jump): Remove unnecessary\n\tcheck for region crossing note.\n\t(fixup_partition_crossing): New function.\n\t(rtl_redirect_edge_and_branch): Fixup partition boundaries.\n\t(emit_barrier_after_bb): Move here from bb-reorder.c, handle insertion\n\tin non-cfglayout mode.\n\t(force_nonfallthru_and_redirect): Fixup partition boundaries,\n\tremove old code that tried to do this. Emit barrier correctly\n\twhen we are in cfglayout mode.\n\t(last_bb_in_partition): New function.\n\t(rtl_split_edge): Correctly fixup partition boundaries.\n\t(commit_one_edge_insertion): Remove old code that tried to\n\tfixup region crossing edge since this is now handled in\n\tsplit_block, and set up insertion point correctly since\n\tblock may now end in a jump.\n\t(verify_hot_cold_block_grouping): Guard against checking when not in\n\tlinearized RTL mode.\n\t(rtl_verify_edges): Add checks for incorrect/missing REG_CROSSING_JUMP\n\tnotes.\n\t(rtl_verify_flow_info_1): Move verify_hot_cold_block_grouping to\n\trtl_verify_flow_info, so not called in cfglayout mode.\n\t(rtl_verify_flow_info): Move verify_hot_cold_block_grouping here.\n\t(fixup_reorder_chain): Remove old code that attempted to fixup region\n\tcrossing note as this is now handled in force_nonfallthru_and_redirect.\n\t(duplicate_insn_chain): Don't duplicate switch section notes.\n\t(rtl_can_remove_branch_p): Remove unnecessary check for region crossing\n\tnote.\n\t* basic-block.h (emit_barrier_after_bb): Declare.\n\n\t* testsuite/gcc.dg/tree-prof/va-arg-pack-1.c: Cloned from c-torture, made\n\tinto -freorder-blocks-and-partition test.\n\t* testsuite/gcc.dg/tree-prof/comp-goto-1.c: Ditto.\n\t* testsuite/gcc.dg/tree-prof/20041218-1.c: Ditto.\n\t* testsuite/gcc.dg/tree-prof/pr52027.c: Use -O2.\n\t* testsuite/gcc.dg/tree-prof/pr50907.c: Ditto.\n\t* testsuite/gcc.dg/tree-prof/pr45354.c: Ditto.\n\t* testsuite/g++.dg/tree-prof/partition2.C: Ditto.\n\t* testsuite/g++.dg/tree-prof/partition3.C: Ditto.\n\nFrom-SVN: r199744", "tree": {"sha": "16bf9573b52b0a038e49fde2d0f5bda9f0f70dd8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/16bf9573b52b0a038e49fde2d0f5bda9f0f70dd8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27/comments", "author": {"login": "teresajohnson", "id": 20446403, "node_id": "MDQ6VXNlcjIwNDQ2NDAz", "avatar_url": "https://avatars.githubusercontent.com/u/20446403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/teresajohnson", "html_url": "https://github.com/teresajohnson", "followers_url": "https://api.github.com/users/teresajohnson/followers", "following_url": "https://api.github.com/users/teresajohnson/following{/other_user}", "gists_url": "https://api.github.com/users/teresajohnson/gists{/gist_id}", "starred_url": "https://api.github.com/users/teresajohnson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/teresajohnson/subscriptions", "organizations_url": "https://api.github.com/users/teresajohnson/orgs", "repos_url": "https://api.github.com/users/teresajohnson/repos", "events_url": "https://api.github.com/users/teresajohnson/events{/privacy}", "received_events_url": "https://api.github.com/users/teresajohnson/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "66071e103cdaf8535c63a096aab414db51e06c99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66071e103cdaf8535c63a096aab414db51e06c99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66071e103cdaf8535c63a096aab414db51e06c99"}], "stats": {"total": 797, "additions": 714, "deletions": 83}, "files": [{"sha": "2d144191e2e804ba6a481f94fd3ffce45aa79dfa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27", "patch": "@@ -1,3 +1,57 @@\n+2013-06-06  Teresa Johnson  <tejohnson@google.com>\n+\n+\tPR c++/53743\n+\t* ifcvt.c (find_if_case_1): Replace BB_COPY_PARTITION with assert\n+\tas this is now done by redirect_edge_and_branch_force.\n+\t* function.c (thread_prologue_and_epilogue_insns): Insert new bb after\n+\tbarriers, and fix interaction with splitting.\n+\t* emit-rtl.c (try_split): Copy REG_CROSSING_JUMP notes.\n+\t* cfgcleanup.c (try_forward_edges): Fix early return value to properly\n+\treflect changes made in the routine.\n+\t* bb-reorder.c (emit_barrier_after_bb): Move to cfgrtl.c.\n+\t(fix_up_fall_thru_edges): Remove incorrect check for bb layout order\n+\tsince this is called in cfglayout mode, and replace partition fixup\n+\twith assert as that is now done by force_nonfallthru_and_redirect.\n+\t(add_reg_crossing_jump_notes): Handle the fact that some jumps may\n+\talready be marked with region crossing note.\n+\t(insert_section_boundary_note): Make non-static, gate on flag\n+\thas_bb_partition, rewrite to also check for multiple partitions.\n+\t(rest_of_handle_reorder_blocks): Remove call to\n+\tinsert_section_boundary_note, now done later during free_cfg.\n+\t(duplicate_computed_gotos): Don't duplicate partition crossing edge.\n+\t* bb-reorder.h (insert_section_boundary_note): Declare.\n+\t* Makefile.in (cfgrtl.o): Depend on bb-reorder.h\n+\t* cfgrtl.c (rest_of_pass_free_cfg): If partitions exist\n+\tinvoke insert_section_boundary_note.\n+\t(try_redirect_by_replacing_jump): Remove unnecessary\n+\tcheck for region crossing note.\n+\t(fixup_partition_crossing): New function.\n+\t(rtl_redirect_edge_and_branch): Fixup partition boundaries.\n+\t(emit_barrier_after_bb): Move here from bb-reorder.c, handle insertion\n+\tin non-cfglayout mode.\n+\t(force_nonfallthru_and_redirect): Fixup partition boundaries,\n+\tremove old code that tried to do this. Emit barrier correctly\n+\twhen we are in cfglayout mode.\n+\t(last_bb_in_partition): New function.\n+\t(rtl_split_edge): Correctly fixup partition boundaries.\n+\t(commit_one_edge_insertion): Remove old code that tried to\n+\tfixup region crossing edge since this is now handled in\n+\tsplit_block, and set up insertion point correctly since\n+\tblock may now end in a jump.\n+\t(verify_hot_cold_block_grouping): Guard against checking when not in\n+\tlinearized RTL mode.\n+\t(rtl_verify_edges): Add checks for incorrect/missing REG_CROSSING_JUMP\n+\tnotes.\n+\t(rtl_verify_flow_info_1): Move verify_hot_cold_block_grouping to\n+\trtl_verify_flow_info, so not called in cfglayout mode.\n+\t(rtl_verify_flow_info): Move verify_hot_cold_block_grouping here.\n+\t(fixup_reorder_chain): Remove old code that attempted to fixup region\n+\tcrossing note as this is now handled in force_nonfallthru_and_redirect.\n+\t(duplicate_insn_chain): Don't duplicate switch section notes.\n+\t(rtl_can_remove_branch_p): Remove unnecessary check for region crossing\n+\tnote.\n+\t* basic-block.h (emit_barrier_after_bb): Declare.\n+\n 2013-06-06  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* config/arm/arm-fixed.md (add<mode>3,usadd<mode>3,ssadd<mode>3,"}, {"sha": "81f75cec8ae3bd909033b1b629d07cbeeb068510", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27", "patch": "@@ -3155,7 +3155,7 @@ cfgrtl.o : cfgrtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_ERROR_H) \\\n    $(FUNCTION_H) $(EXCEPT_H) $(TM_P_H) $(INSN_ATTR_H) \\\n    insn-config.h $(EXPR_H) \\\n    $(CFGLOOP_H) $(OBSTACK_H) $(TARGET_H) $(TREE_H) \\\n-   $(TREE_PASS_H) $(DF_H) $(GGC_H) $(COMMON_TARGET_H) gt-cfgrtl.h\n+   $(TREE_PASS_H) $(DF_H) $(GGC_H) $(COMMON_TARGET_H) gt-cfgrtl.h bb-reorder.h\n cfganal.o : cfganal.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(BASIC_BLOCK_H) \\\n    $(TIMEVAR_H) sbitmap.h $(BITMAP_H)\n cfgbuild.o : cfgbuild.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\"}, {"sha": "154dc7a2c3157ca5d59e34b37dc73ae740c40123", "filename": "gcc/basic-block.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27", "patch": "@@ -796,6 +796,7 @@ extern basic_block force_nonfallthru_and_redirect (edge, basic_block, rtx);\n extern bool contains_no_active_insn_p (const_basic_block);\n extern bool forwarder_block_p (const_basic_block);\n extern bool can_fallthru (basic_block, basic_block);\n+extern void emit_barrier_after_bb (basic_block bb);\n \n /* In cfgbuild.c.  */\n extern void find_many_sub_basic_blocks (sbitmap);"}, {"sha": "d3bc4f927410023d09b55478f447af1193ae790d", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27", "patch": "@@ -1380,15 +1380,6 @@ get_uncond_jump_length (void)\n   return length;\n }\n \n-/* Emit a barrier into the footer of BB.  */\n-\n-static void\n-emit_barrier_after_bb (basic_block bb)\n-{\n-  rtx barrier = emit_barrier_after (BB_END (bb));\n-  BB_FOOTER (bb) = unlink_insn_chain (barrier, barrier);\n-}\n-\n /* The landing pad OLD_LP, in block OLD_BB, has edges from both partitions.\n    Duplicate the landing pad and split the edges so that no EH edge\n    crosses partitions.  */\n@@ -1720,8 +1711,7 @@ fix_up_fall_thru_edges (void)\n \t\t     (i.e. fix it so the fall through does not cross and\n \t\t     the cond jump does).  */\n \n-\t\t  if (!cond_jump_crosses\n-\t\t      && cur_bb->aux == cond_jump->dest)\n+\t\t  if (!cond_jump_crosses)\n \t\t    {\n \t\t      /* Find label in fall_thru block. We've already added\n \t\t\t any missing labels, so there must be one.  */\n@@ -1765,10 +1755,10 @@ fix_up_fall_thru_edges (void)\n \t\t      new_bb->aux = cur_bb->aux;\n \t\t      cur_bb->aux = new_bb;\n \n-\t\t      /* Make sure new fall-through bb is in same\n-\t\t\t partition as bb it's falling through from.  */\n+                      /* This is done by force_nonfallthru_and_redirect.  */\n+\t\t      gcc_assert (BB_PARTITION (new_bb)\n+                                  == BB_PARTITION (cur_bb));\n \n-\t\t      BB_COPY_PARTITION (new_bb, cur_bb);\n \t\t      single_succ_edge (new_bb)->flags |= EDGE_CROSSING;\n \t\t    }\n \t\t  else\n@@ -2064,7 +2054,10 @@ add_reg_crossing_jump_notes (void)\n   FOR_EACH_BB (bb)\n     FOR_EACH_EDGE (e, ei, bb->succs)\n       if ((e->flags & EDGE_CROSSING)\n-\t  && JUMP_P (BB_END (e->src)))\n+\t  && JUMP_P (BB_END (e->src))\n+          /* Some notes were added during fix_up_fall_thru_edges, via\n+             force_nonfallthru_and_redirect.  */\n+          && !find_reg_note (BB_END (e->src), REG_CROSSING_JUMP, NULL_RTX))\n \tadd_reg_note (BB_END (e->src), REG_CROSSING_JUMP, NULL_RTX);\n }\n \n@@ -2133,23 +2126,26 @@ reorder_basic_blocks (void)\n    encountering this note will make the compiler switch between the\n    hot and cold text sections.  */\n \n-static void\n+void\n insert_section_boundary_note (void)\n {\n   basic_block bb;\n-  int first_partition = 0;\n+  bool switched_sections = false;\n+  int current_partition = 0;\n \n-  if (!flag_reorder_blocks_and_partition)\n+  if (!crtl->has_bb_partition)\n     return;\n \n   FOR_EACH_BB (bb)\n     {\n-      if (!first_partition)\n-\tfirst_partition = BB_PARTITION (bb);\n-      if (BB_PARTITION (bb) != first_partition)\n+      if (!current_partition)\n+\tcurrent_partition = BB_PARTITION (bb);\n+      if (BB_PARTITION (bb) != current_partition)\n \t{\n-\t  emit_note_before (NOTE_INSN_SWITCH_TEXT_SECTIONS, BB_HEAD (bb));\n-\t  break;\n+\t  gcc_assert (!switched_sections);\n+          switched_sections = true;\n+          emit_note_before (NOTE_INSN_SWITCH_TEXT_SECTIONS, BB_HEAD (bb));\n+          current_partition = BB_PARTITION (bb);\n \t}\n     }\n }\n@@ -2180,8 +2176,6 @@ rest_of_handle_reorder_blocks (void)\n       bb->aux = bb->next_bb;\n   cfg_layout_finalize ();\n \n-  /* Add NOTE_INSN_SWITCH_TEXT_SECTIONS notes.  */\n-  insert_section_boundary_note ();\n   return 0;\n }\n \n@@ -2315,6 +2309,11 @@ duplicate_computed_gotos (void)\n       if (!bitmap_bit_p (candidates, single_succ (bb)->index))\n \tcontinue;\n \n+      /* Don't duplicate a partition crossing edge, which requires difficult\n+         fixup.  */\n+      if (find_reg_note (BB_END (bb), REG_CROSSING_JUMP, NULL_RTX))\n+\tcontinue;\n+\n       new_bb = duplicate_block (single_succ (bb), single_succ_edge (bb), bb);\n       new_bb->aux = bb->aux;\n       bb->aux = new_bb;"}, {"sha": "025300ca4819a0b2b2371e0181596d153f5aff7e", "filename": "gcc/bb-reorder.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27/gcc%2Fbb-reorder.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27/gcc%2Fbb-reorder.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.h?ref=3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27", "patch": "@@ -35,4 +35,6 @@ extern struct target_bb_reorder *this_target_bb_reorder;\n \n extern int get_uncond_jump_length (void);\n \n+extern void insert_section_boundary_note (void);\n+\n #endif"}, {"sha": "99e0baa756ed5302f45febfd6ba9585976bf0771", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27", "patch": "@@ -456,7 +456,7 @@ try_forward_edges (int mode, basic_block b)\n \n       if (first != EXIT_BLOCK_PTR\n \t  && find_reg_note (BB_END (first), REG_CROSSING_JUMP, NULL_RTX))\n-\treturn false;\n+\treturn changed;\n \n       while (counter < n_basic_blocks)\n \t{"}, {"sha": "36438b8409b273ba239d18e87d5c1ff823d94cf7", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 168, "deletions": 44, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27", "patch": "@@ -44,6 +44,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree.h\"\n #include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n+#include \"bb-reorder.h\"\n #include \"regs.h\"\n #include \"flags.h\"\n #include \"function.h\"\n@@ -451,6 +452,9 @@ rest_of_pass_free_cfg (void)\n     }\n #endif\n \n+  if (crtl->has_bb_partition)\n+    insert_section_boundary_note ();\n+\n   free_bb_for_insn ();\n   return 0;\n }\n@@ -981,8 +985,7 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n      partition boundaries).  See  the comments at the top of\n      bb-reorder.c:partition_hot_cold_basic_blocks for complete details.  */\n \n-  if (find_reg_note (insn, REG_CROSSING_JUMP, NULL_RTX)\n-      || BB_PARTITION (src) != BB_PARTITION (target))\n+  if (BB_PARTITION (src) != BB_PARTITION (target))\n     return NULL;\n \n   /* We can replace or remove a complex jump only when we have exactly\n@@ -1291,6 +1294,53 @@ redirect_branch_edge (edge e, basic_block target)\n   return e;\n }\n \n+/* Called when edge E has been redirected to a new destination,\n+   in order to update the region crossing flag on the edge and\n+   jump.  */\n+\n+static void\n+fixup_partition_crossing (edge e)\n+{\n+  rtx note;\n+\n+  if (e->src == ENTRY_BLOCK_PTR || e->dest == EXIT_BLOCK_PTR)\n+    return;\n+  /* If we redirected an existing edge, it may already be marked\n+     crossing, even though the new src is missing a reg crossing note.\n+     But make sure reg crossing note doesn't already exist before\n+     inserting.  */\n+  if (BB_PARTITION (e->src) != BB_PARTITION (e->dest))\n+    {\n+      e->flags |= EDGE_CROSSING;\n+      note = find_reg_note (BB_END (e->src), REG_CROSSING_JUMP, NULL_RTX);\n+      if (JUMP_P (BB_END (e->src))\n+          && !note)\n+        add_reg_note (BB_END (e->src), REG_CROSSING_JUMP, NULL_RTX);\n+    }\n+  else if (BB_PARTITION (e->src) == BB_PARTITION (e->dest))\n+    {\n+      e->flags &= ~EDGE_CROSSING;\n+      /* Remove the section crossing note from jump at end of\n+         src if it exists, and if no other successors are\n+         still crossing.  */\n+      note = find_reg_note (BB_END (e->src), REG_CROSSING_JUMP, NULL_RTX);\n+      if (note)\n+        {\n+          bool has_crossing_succ = false;\n+          edge e2;\n+          edge_iterator ei;\n+          FOR_EACH_EDGE (e2, ei, e->src->succs)\n+            {\n+              has_crossing_succ |= (e2->flags & EDGE_CROSSING);\n+              if (has_crossing_succ)\n+                break;\n+            }\n+          if (!has_crossing_succ)\n+            remove_note (BB_END (e->src), note);\n+        }\n+    }\n+}\n+\n /* Attempt to change code to redirect edge E to TARGET.  Don't do that on\n    expense of adding new instructions or reordering basic blocks.\n \n@@ -1307,16 +1357,18 @@ rtl_redirect_edge_and_branch (edge e, basic_block target)\n {\n   edge ret;\n   basic_block src = e->src;\n+  basic_block dest = e->dest;\n \n   if (e->flags & (EDGE_ABNORMAL_CALL | EDGE_EH))\n     return NULL;\n \n-  if (e->dest == target)\n+  if (dest == target)\n     return e;\n \n   if ((ret = try_redirect_by_replacing_jump (e, target, false)) != NULL)\n     {\n       df_set_bb_dirty (src);\n+      fixup_partition_crossing (ret);\n       return ret;\n     }\n \n@@ -1325,9 +1377,22 @@ rtl_redirect_edge_and_branch (edge e, basic_block target)\n     return NULL;\n \n   df_set_bb_dirty (src);\n+  fixup_partition_crossing (ret);\n   return ret;\n }\n \n+/* Emit a barrier after BB, into the footer if we are in CFGLAYOUT mode.  */\n+\n+void\n+emit_barrier_after_bb (basic_block bb)\n+{\n+  rtx barrier = emit_barrier_after (BB_END (bb));\n+  gcc_assert (current_ir_type() == IR_RTL_CFGRTL\n+              || current_ir_type () == IR_RTL_CFGLAYOUT);\n+  if (current_ir_type () == IR_RTL_CFGLAYOUT)\n+    BB_FOOTER (bb) = unlink_insn_chain (barrier, barrier);\n+}\n+\n /* Like force_nonfallthru below, but additionally performs redirection\n    Used by redirect_edge_and_branch_force.  JUMP_LABEL is used only\n    when redirecting to the EXIT_BLOCK, it is either ret_rtx or\n@@ -1492,12 +1557,6 @@ force_nonfallthru_and_redirect (edge e, basic_block target, rtx jump_label)\n       /* Make sure new block ends up in correct hot/cold section.  */\n \n       BB_COPY_PARTITION (jump_block, e->src);\n-      if (flag_reorder_blocks_and_partition\n-\t  && targetm_common.have_named_sections\n-\t  && JUMP_P (BB_END (jump_block))\n-\t  && !any_condjump_p (BB_END (jump_block))\n-\t  && (EDGE_SUCC (jump_block, 0)->flags & EDGE_CROSSING))\n-\tadd_reg_note (BB_END (jump_block), REG_CROSSING_JUMP, NULL_RTX);\n \n       /* Wire edge in.  */\n       new_edge = make_edge (e->src, jump_block, EDGE_FALLTHRU);\n@@ -1508,6 +1567,10 @@ force_nonfallthru_and_redirect (edge e, basic_block target, rtx jump_label)\n       redirect_edge_pred (e, jump_block);\n       e->probability = REG_BR_PROB_BASE;\n \n+      /* If e->src was previously region crossing, it no longer is\n+         and the reg crossing note should be removed.  */\n+      fixup_partition_crossing (new_edge);\n+\n       /* If asm goto has any label refs to target's label,\n \t add also edge from asm goto bb to target.  */\n       if (asm_goto_edge)\n@@ -1559,13 +1622,16 @@ force_nonfallthru_and_redirect (edge e, basic_block target, rtx jump_label)\n       LABEL_NUSES (label)++;\n     }\n \n-  emit_barrier_after (BB_END (jump_block));\n+  /* We might be in cfg layout mode, and if so, the following routine will\n+     insert the barrier correctly.  */\n+  emit_barrier_after_bb (jump_block);\n   redirect_edge_succ_nodup (e, target);\n \n   if (abnormal_edge_flags)\n     make_edge (src, target, abnormal_edge_flags);\n \n   df_mark_solutions_dirty ();\n+  fixup_partition_crossing (e);\n   return new_bb;\n }\n \n@@ -1654,6 +1720,21 @@ rtl_move_block_after (basic_block bb ATTRIBUTE_UNUSED,\n   return false;\n }\n \n+/* Locate the last bb in the same partition as START_BB.  */\n+\n+static basic_block\n+last_bb_in_partition (basic_block start_bb)\n+{\n+  basic_block bb;\n+  FOR_BB_BETWEEN (bb, start_bb, EXIT_BLOCK_PTR, next_bb)\n+    {\n+      if (BB_PARTITION (start_bb) != BB_PARTITION (bb->next_bb))\n+        return bb;\n+    }\n+  /* Return bb before EXIT_BLOCK_PTR.  */\n+  return bb->prev_bb;\n+}\n+\n /* Split a (typically critical) edge.  Return the new block.\n    The edge must not be abnormal.\n \n@@ -1664,7 +1745,7 @@ rtl_move_block_after (basic_block bb ATTRIBUTE_UNUSED,\n static basic_block\n rtl_split_edge (edge edge_in)\n {\n-  basic_block bb;\n+  basic_block bb, new_bb;\n   rtx before;\n \n   /* Abnormal edges cannot be split.  */\n@@ -1696,13 +1777,50 @@ rtl_split_edge (edge edge_in)\n     }\n   else\n     {\n-      bb = create_basic_block (before, NULL, edge_in->dest->prev_bb);\n-      /* ??? Why not edge_in->dest->prev_bb here?  */\n-      BB_COPY_PARTITION (bb, edge_in->dest);\n+      if (edge_in->src == ENTRY_BLOCK_PTR)\n+        {\n+          bb = create_basic_block (before, NULL, edge_in->dest->prev_bb);\n+          BB_COPY_PARTITION (bb, edge_in->dest);\n+        }\n+      else\n+        {\n+          basic_block after = edge_in->dest->prev_bb;\n+          /* If this is post-bb reordering, and the edge crosses a partition\n+             boundary, the new block needs to be inserted in the bb chain\n+             at the end of the src partition (since we put the new bb into\n+             that partition, see below). Otherwise we may end up creating\n+             an extra partition crossing in the chain, which is illegal.\n+             It can't go after the src, because src may have a fall-through\n+             to a different block.  */\n+          if (crtl->bb_reorder_complete\n+              && (edge_in->flags & EDGE_CROSSING))\n+            {\n+              after = last_bb_in_partition (edge_in->src);\n+              before = NEXT_INSN (BB_END (after));\n+              /* The instruction following the last bb in partition should\n+                 be a barrier, since it cannot end in a fall-through.  */\n+              gcc_checking_assert (BARRIER_P (before));\n+              before = NEXT_INSN (before);\n+            }\n+          bb = create_basic_block (before, NULL, after);\n+          /* Put the split bb into the src partition, to avoid creating\n+             a situation where a cold bb dominates a hot bb, in the case\n+             where src is cold and dest is hot. The src will dominate\n+             the new bb (whereas it might not have dominated dest).  */\n+          BB_COPY_PARTITION (bb, edge_in->src);\n+        }\n     }\n \n   make_single_succ_edge (bb, edge_in->dest, EDGE_FALLTHRU);\n \n+  /* Can't allow a region crossing edge to be fallthrough.  */\n+  if (BB_PARTITION (bb) != BB_PARTITION (edge_in->dest)\n+      && edge_in->dest != EXIT_BLOCK_PTR)\n+    {\n+      new_bb = force_nonfallthru (single_succ_edge (bb));\n+      gcc_assert (!new_bb);\n+    }\n+\n   /* For non-fallthru edges, we must adjust the predecessor's\n      jump instruction to target our new block.  */\n   if ((edge_in->flags & EDGE_FALLTHRU) == 0)\n@@ -1815,17 +1933,13 @@ commit_one_edge_insertion (edge e)\n   else\n     {\n       bb = split_edge (e);\n-      after = BB_END (bb);\n-\n-      if (flag_reorder_blocks_and_partition\n-\t  && targetm_common.have_named_sections\n-\t  && e->src != ENTRY_BLOCK_PTR\n-\t  && BB_PARTITION (e->src) == BB_COLD_PARTITION\n-\t  && !(e->flags & EDGE_CROSSING)\n-\t  && JUMP_P (after)\n-\t  && !any_condjump_p (after)\n-\t  && (single_succ_edge (bb)->flags & EDGE_CROSSING))\n-\tadd_reg_note (after, REG_CROSSING_JUMP, NULL_RTX);\n+\n+      /* If E crossed a partition boundary, we needed to make bb end in\n+         a region-crossing jump, even though it was originally fallthru.  */\n+      if (JUMP_P (BB_END (bb)))\n+\tbefore = BB_END (bb);\n+      else\n+        after = BB_END (bb);\n     }\n \n   /* Now that we've found the spot, do the insertion.  */\n@@ -2071,7 +2185,11 @@ verify_hot_cold_block_grouping (void)\n   bool switched_sections = false;\n   int current_partition = BB_UNPARTITIONED;\n \n-  if (!crtl->bb_reorder_complete)\n+  /* Even after bb reordering is complete, we go into cfglayout mode\n+     again (in compgoto). Ensure we don't call this before going back\n+     into linearized RTL when any layout fixes would have been committed.  */\n+  if (!crtl->bb_reorder_complete\n+      || current_ir_type() != IR_RTL_CFGRTL)\n     return err;\n \n   FOR_EACH_BB (bb)\n@@ -2116,6 +2234,7 @@ rtl_verify_edges (void)\n       edge e, fallthru = NULL;\n       edge_iterator ei;\n       rtx note;\n+      bool has_crossing_edge = false;\n \n       if (JUMP_P (BB_END (bb))\n \t  && (note = find_reg_note (BB_END (bb), REG_BR_PROB, NULL_RTX))\n@@ -2141,6 +2260,7 @@ rtl_verify_edges (void)\n \t  is_crossing = (BB_PARTITION (e->src) != BB_PARTITION (e->dest)\n \t\t\t && e->src != ENTRY_BLOCK_PTR\n \t\t\t && e->dest != EXIT_BLOCK_PTR);\n+          has_crossing_edge |= is_crossing;\n \t  if (e->flags & EDGE_CROSSING)\n \t    {\n \t      if (!is_crossing)\n@@ -2160,6 +2280,13 @@ rtl_verify_edges (void)\n \t\t\t e->src->index);\n \t\t  err = 1;\n \t\t}\n+              if (JUMP_P (BB_END (bb))\n+                  && !find_reg_note (BB_END (bb), REG_CROSSING_JUMP, NULL_RTX))\n+\t\t{\n+\t\t  error (\"No region crossing jump at section boundary in bb %i\",\n+\t\t\t bb->index);\n+\t\t  err = 1;\n+\t\t}\n \t    }\n \t  else if (is_crossing)\n \t    {\n@@ -2188,6 +2315,15 @@ rtl_verify_edges (void)\n \t    n_abnormal++;\n \t}\n \n+        if (!has_crossing_edge\n+            && find_reg_note (BB_END (bb), REG_CROSSING_JUMP, NULL_RTX))\n+          {\n+            print_rtl_with_bb (stderr, get_insns (), TDF_RTL | TDF_BLOCKS | TDF_DETAILS);\n+            error (\"Region crossing jump across same section in bb %i\",\n+                   bb->index);\n+            err = 1;\n+          }\n+\n       if (n_eh && !find_reg_note (BB_END (bb), REG_EH_REGION, NULL_RTX))\n \t{\n \t  error (\"missing REG_EH_REGION note at the end of bb %i\", bb->index);\n@@ -2395,8 +2531,6 @@ rtl_verify_flow_info_1 (void)\n \n   err |= rtl_verify_edges ();\n \n-  err |= verify_hot_cold_block_grouping();\n-\n   return err;\n }\n \n@@ -2642,6 +2776,8 @@ rtl_verify_flow_info (void)\n \n   err |= rtl_verify_bb_layout ();\n \n+  err |= verify_hot_cold_block_grouping ();\n+\n   return err;\n }\n \f\n@@ -3343,7 +3479,7 @@ fixup_reorder_chain (void)\n       edge e_fall, e_taken, e;\n       rtx bb_end_insn;\n       rtx ret_label = NULL_RTX;\n-      basic_block nb, src_bb;\n+      basic_block nb;\n       edge_iterator ei;\n \n       if (EDGE_COUNT (bb->succs) == 0)\n@@ -3478,25 +3614,13 @@ fixup_reorder_chain (void)\n       /* We got here if we need to add a new jump insn. \n \t Note force_nonfallthru can delete E_FALL and thus we have to\n \t save E_FALL->src prior to the call to force_nonfallthru.  */\n-      src_bb = e_fall->src;\n       nb = force_nonfallthru_and_redirect (e_fall, e_fall->dest, ret_label);\n       if (nb)\n \t{\n \t  nb->aux = bb->aux;\n \t  bb->aux = nb;\n \t  /* Don't process this new block.  */\n \t  bb = nb;\n-\n-\t  /* Make sure new bb is tagged for correct section (same as\n-\t     fall-thru source, since you cannot fall-thru across\n-\t     section boundaries).  */\n-\t  BB_COPY_PARTITION (src_bb, single_pred (bb));\n-\t  if (flag_reorder_blocks_and_partition\n-\t      && targetm_common.have_named_sections\n-\t      && JUMP_P (BB_END (bb))\n-\t      && !any_condjump_p (BB_END (bb))\n-\t      && (EDGE_SUCC (bb, 0)->flags & EDGE_CROSSING))\n-\t    add_reg_note (BB_END (bb), REG_CROSSING_JUMP, NULL_RTX);\n \t}\n     }\n \n@@ -3796,10 +3920,11 @@ duplicate_insn_chain (rtx from, rtx to)\n \t    case NOTE_INSN_FUNCTION_BEG:\n \t      /* There is always just single entry to function.  */\n \t    case NOTE_INSN_BASIC_BLOCK:\n+              /* We should only switch text sections once.  */\n+\t    case NOTE_INSN_SWITCH_TEXT_SECTIONS:\n \t      break;\n \n \t    case NOTE_INSN_EPILOGUE_BEG:\n-\t    case NOTE_INSN_SWITCH_TEXT_SECTIONS:\n \t      emit_note_copy (insn);\n \t      break;\n \n@@ -4611,8 +4736,7 @@ rtl_can_remove_branch_p (const_edge e)\n   if (e->flags & (EDGE_ABNORMAL_CALL | EDGE_EH))\n     return false;\n \n-  if (find_reg_note (insn, REG_CROSSING_JUMP, NULL_RTX)\n-      || BB_PARTITION (src) != BB_PARTITION (target))\n+  if (BB_PARTITION (src) != BB_PARTITION (target))\n     return false;\n \n   if (!onlyjump_p (insn)"}, {"sha": "8a7b8a563d5cc46a8e077b07af79ea63d9c17e50", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27", "patch": "@@ -3574,6 +3574,7 @@ try_split (rtx pat, rtx trial, int last)\n \t  break;\n \n \tcase REG_NON_LOCAL_GOTO:\n+\tcase REG_CROSSING_JUMP:\n \t  for (insn = insn_last; insn != NULL_RTX; insn = PREV_INSN (insn))\n \t    {\n \t      if (JUMP_P (insn))"}, {"sha": "39fa22a2c66ab4155a9c04440d4f0decaac2c0dd", "filename": "gcc/function.c", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27", "patch": "@@ -6270,8 +6270,10 @@ thread_prologue_and_epilogue_insns (void)\n \t\t    break;\n \t\tif (e)\n \t\t  {\n-\t\t    copy_bb = create_basic_block (NEXT_INSN (BB_END (e->src)),\n-\t\t\t\t\t\t  NULL_RTX, e->src);\n+                    /* Make sure we insert after any barriers.  */\n+                    rtx end = get_last_bb_insn (e->src);\n+                    copy_bb = create_basic_block (NEXT_INSN (end),\n+                                                  NULL_RTX, e->src);\n \t\t    BB_COPY_PARTITION (copy_bb, e->src);\n \t\t  }\n \t\telse\n@@ -6538,7 +6540,7 @@ thread_prologue_and_epilogue_insns (void)\n       basic_block simple_return_block_cold = NULL;\n       edge pending_edge_hot = NULL;\n       edge pending_edge_cold = NULL;\n-      basic_block exit_pred = EXIT_BLOCK_PTR->prev_bb;\n+      basic_block exit_pred;\n       int i;\n \n       gcc_assert (entry_edge != orig_entry_edge);\n@@ -6566,6 +6568,12 @@ thread_prologue_and_epilogue_insns (void)\n \t    else\n \t      pending_edge_cold = e;\n \t  }\n+      \n+      /* Save a pointer to the exit's predecessor BB for use in\n+         inserting new BBs at the end of the function. Do this\n+         after the call to split_block above which may split\n+         the original exit pred.  */\n+      exit_pred = EXIT_BLOCK_PTR->prev_bb;\n \n       FOR_EACH_VEC_ELT (unconverted_simple_returns, i, e)\n \t{"}, {"sha": "c6c2aeb4b87326bcc9c613e73afc3aaa84cec31f", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27", "patch": "@@ -3905,10 +3905,9 @@ find_if_case_1 (basic_block test_bb, edge then_edge, edge else_edge)\n   if (new_bb)\n     {\n       df_bb_replace (then_bb_index, new_bb);\n-      /* Since the fallthru edge was redirected from test_bb to new_bb,\n-         we need to ensure that new_bb is in the same partition as\n-         test bb (you can not fall through across section boundaries).  */\n-      BB_COPY_PARTITION (new_bb, test_bb);\n+      /* This should have been done above via force_nonfallthru_and_redirect\n+         (possibly called from redirect_edge_and_branch_force).  */\n+      gcc_checking_assert (BB_PARTITION (new_bb) == BB_PARTITION (test_bb));\n     }\n \n   num_true_changes++;"}, {"sha": "035781b98197df820257953789c2de4b4f52f1cf", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27", "patch": "@@ -1,3 +1,16 @@\n+2013-06-06  Teresa Johnson  <tejohnson@google.com>\n+\n+\tPR c++/53743\n+\t* gcc.dg/tree-prof/va-arg-pack-1.c: Cloned from c-torture, made\n+\tinto -freorder-blocks-and-partition test.\n+\t* gcc.dg/tree-prof/comp-goto-1.c: Ditto.\n+\t* gcc.dg/tree-prof/20041218-1.c: Ditto.\n+\t* gcc.dg/tree-prof/pr52027.c: Use -O2.\n+\t* gcc.dg/tree-prof/pr50907.c: Ditto.\n+\t* gcc.dg/tree-prof/pr45354.c: Ditto.\n+\t* g++.dg/tree-prof/partition2.C: Ditto.\n+\t* g++.dg/tree-prof/partition3.C: Ditto.\n+\n 2013-06-06  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/57542"}, {"sha": "0bc50fae98a3818ea1d91cc179f31bac67db9de1", "filename": "gcc/testsuite/g++.dg/tree-prof/partition2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-prof%2Fpartition2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-prof%2Fpartition2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-prof%2Fpartition2.C?ref=3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27", "patch": "@@ -1,6 +1,6 @@\n // PR middle-end/45458\n // { dg-require-effective-target freorder }\n-// { dg-options \"-fnon-call-exceptions -freorder-blocks-and-partition\" }\n+// { dg-options \"-O2 -fnon-call-exceptions -freorder-blocks-and-partition\" }\n \n int\n main ()"}, {"sha": "c62174aa4d31f2e4a25291f0b4d5519560d47f39", "filename": "gcc/testsuite/g++.dg/tree-prof/partition3.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-prof%2Fpartition3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-prof%2Fpartition3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-prof%2Fpartition3.C?ref=3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27", "patch": "@@ -1,6 +1,6 @@\n // PR middle-end/45566\n // { dg-require-effective-target freorder }\n-// { dg-options \"-O -fnon-call-exceptions -freorder-blocks-and-partition\" }\n+// { dg-options \"-O2 -fnon-call-exceptions -freorder-blocks-and-partition\" }\n \n int k;\n "}, {"sha": "cbd1c7c80ecf63d14a750f7e582865492cd9408a", "filename": "gcc/testsuite/gcc.dg/tree-prof/20041218-1.c", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2F20041218-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2F20041218-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2F20041218-1.c?ref=3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27", "patch": "@@ -0,0 +1,119 @@\n+/* PR rtl-optimization/16968 */\n+/* Testcase by Jakub Jelinek  <jakub@redhat.com> */\n+/* { dg-require-effective-target freorder } */\n+/* { dg-options \"-O2 -freorder-blocks-and-partition\" } */\n+\n+struct T\n+{\n+  unsigned int b, c, *d;\n+  unsigned char e;\n+};\n+struct S\n+{\n+  unsigned int a;\n+  struct T f;\n+};\n+struct U\n+{\n+  struct S g, h;\n+};\n+struct V\n+{\n+  unsigned int i;\n+  struct U j;\n+};\n+\n+extern void exit (int);\n+extern void abort (void);\n+\n+void *\n+dummy1 (void *x)\n+{\n+  return \"\";\n+}\n+\n+void *\n+dummy2 (void *x, void *y)\n+{\n+  exit (0);\n+}\n+\n+struct V *\n+baz (unsigned int x)\n+{\n+  static struct V v;\n+  __builtin_memset (&v, 0x55, sizeof (v));\n+  return &v;\n+}\n+\n+int\n+check (void *x, struct S *y)\n+{\n+  if (y->a || y->f.b || y->f.c || y->f.d || y->f.e)\n+    abort ();\n+  return 1;\n+}\n+\n+static struct V *\n+bar (unsigned int x, void *y)\n+{\n+  const struct T t = { 0, 0, (void *) 0, 0 };\n+  struct V *u;\n+  void *v;\n+  v = dummy1 (y);\n+  if (!v)\n+    return (void *) 0;\n+\n+  u = baz (sizeof (struct V));\n+  u->i = x;\n+  u->j.g.a = 0;\n+  u->j.g.f = t;\n+  u->j.h.a = 0;\n+  u->j.h.f = t;\n+\n+  if (!check (v, &u->j.g) || !check (v, &u->j.h))\n+    return (void *) 0;\n+  return u;\n+}\n+\n+int\n+foo (unsigned int *x, unsigned int y, void **z)\n+{\n+  void *v;\n+  unsigned int i, j;\n+\n+  *z = v = (void *) 0;\n+\n+  for (i = 0; i < y; i++)\n+    {\n+      struct V *c;\n+\n+      j = *x;\n+\n+      switch (j)\n+\t{\n+\tcase 1:\n+\t  c = bar (j, x);\n+\t  break;\n+\tdefault:\n+\t  c = 0;\n+\t  break;\n+\t}\n+      if (c)\n+\tv = dummy2 (v, c);\n+      else\n+        return 1;\n+    }\n+\n+  *z = v;\n+  return 0;\n+}\n+\n+int\n+main (void)\n+{\n+  unsigned int one = 1;\n+  void *p;\n+  foo (&one, 1, &p);\n+  abort ();\n+}"}, {"sha": "bbfe1f4728f5d2bf67177f2a20b6038bc832abee", "filename": "gcc/testsuite/gcc.dg/tree-prof/comp-goto-1.c", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fcomp-goto-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fcomp-goto-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fcomp-goto-1.c?ref=3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27", "patch": "@@ -0,0 +1,166 @@\n+/* { dg-require-effective-target freorder } */\n+/* { dg-options \"-O2 -freorder-blocks-and-partition\" } */\n+#include <stdlib.h>\n+\n+#if !defined(NO_LABEL_VALUES) && (!defined(STACK_SIZE) || STACK_SIZE >= 4000) && __INT_MAX__ >= 2147483647\n+typedef unsigned int uint32;\n+typedef signed int sint32;\n+\n+typedef uint32 reg_t;\n+\n+typedef unsigned long int host_addr_t;\n+typedef uint32 target_addr_t;\n+typedef sint32 target_saddr_t;\n+\n+typedef union\n+{\n+  struct\n+    {\n+      unsigned int\toffset:18;\n+      unsigned int\tignore:4;\n+      unsigned int\ts1:8;\n+      int\t\t:2;\n+      signed int\tsimm:14;\n+      unsigned int\ts3:8;\n+      unsigned int\ts2:8;\n+      int\t\tpad2:2;\n+    } f1;\n+  long long ll;\n+  double d;\n+} insn_t;\n+\n+typedef struct\n+{\n+  target_addr_t vaddr_tag;\n+  unsigned long int rigged_paddr;\n+} tlb_entry_t;\n+\n+typedef struct\n+{\n+  insn_t *pc;\n+  reg_t registers[256];\n+  insn_t *program;\n+  tlb_entry_t tlb_tab[0x100];\n+} environment_t;\n+\n+enum operations\n+{\n+  LOAD32_RR,\n+  METAOP_DONE\n+};\n+\n+host_addr_t\n+f ()\n+{\n+  abort ();\n+}\n+\n+reg_t\n+simulator_kernel (int what, environment_t *env)\n+{\n+  register insn_t *pc = env->pc;\n+  register reg_t *regs = env->registers;\n+  register insn_t insn;\n+  register int s1;\n+  register reg_t r2;\n+  register void *base_addr = &&sim_base_addr;\n+  register tlb_entry_t *tlb = env->tlb_tab;\n+\n+  if (what != 0)\n+    {\n+      int i;\n+      static void *op_map[] =\n+\t{\n+\t  &&L_LOAD32_RR,\n+\t  &&L_METAOP_DONE,\n+\t};\n+      insn_t *program = env->program;\n+      for (i = 0; i < what; i++)\n+\tprogram[i].f1.offset = op_map[program[i].f1.offset] - base_addr;\n+    }\n+\n+ sim_base_addr:;\n+\n+  insn = *pc++;\n+  r2 = (*(reg_t *) (((char *) regs) + (insn.f1.s2 << 2)));\n+  s1 = (insn.f1.s1 << 2);\n+  goto *(base_addr + insn.f1.offset);\n+\n+ L_LOAD32_RR:\n+  {\n+    target_addr_t vaddr_page = r2 / 4096;\n+    unsigned int x = vaddr_page % 0x100;\n+    insn = *pc++;\n+\n+    for (;;)\n+      {\n+\ttarget_addr_t tag = tlb[x].vaddr_tag;\n+\thost_addr_t rigged_paddr = tlb[x].rigged_paddr;\n+\n+\tif (tag == vaddr_page)\n+\t  {\n+\t    *(reg_t *) (((char *) regs) + s1) = *(uint32 *) (rigged_paddr + r2);\n+\t    r2 = *(reg_t *) (((char *) regs) + (insn.f1.s2 << 2));\n+\t    s1 = insn.f1.s1 << 2;\n+\t    goto *(base_addr + insn.f1.offset);\n+\t  }\n+\n+\tif (((target_saddr_t) tag < 0))\n+\t  {\n+\t    *(reg_t *) (((char *) regs) + s1) = *(uint32 *) f ();\n+\t    r2 = *(reg_t *) (((char *) regs) + (insn.f1.s2 << 2));\n+\t    s1 = insn.f1.s1 << 2;\n+\t    goto *(base_addr + insn.f1.offset);\n+\t  }\n+\n+\tx = (x - 1) % 0x100;\n+      }\n+\n+    L_METAOP_DONE:\n+      return (*(reg_t *) (((char *) regs) + s1));\n+  }\n+}\n+\n+insn_t program[2 + 1];\n+\n+void *malloc ();\n+\n+int\n+main ()\n+{\n+  environment_t env;\n+  insn_t insn;\n+  int i, res;\n+  host_addr_t a_page = (host_addr_t) malloc (2 * 4096);\n+  target_addr_t a_vaddr = 0x123450;\n+  target_addr_t vaddr_page = a_vaddr / 4096;\n+  a_page = (a_page + 4096 - 1) & -4096;\n+\n+  env.tlb_tab[((vaddr_page) % 0x100)].vaddr_tag = vaddr_page;\n+  env.tlb_tab[((vaddr_page) % 0x100)].rigged_paddr = a_page - vaddr_page * 4096;\n+  insn.f1.offset = LOAD32_RR;\n+  env.registers[0] = 0;\n+  env.registers[2] = a_vaddr;\n+  *(sint32 *) (a_page + a_vaddr % 4096) = 88;\n+  insn.f1.s1 = 0;\n+  insn.f1.s2 = 2;\n+\n+  for (i = 0; i < 2; i++)\n+    program[i] = insn;\n+\n+  insn.f1.offset = METAOP_DONE;\n+  insn.f1.s1 = 0;\n+  program[2] = insn;\n+\n+  env.pc = program;\n+  env.program = program;\n+\n+  res = simulator_kernel (2 + 1, &env);\n+\n+  if (res != 88)\n+    abort ();\n+  exit (0);\n+}\n+#else\n+main(){ exit (0); }\n+#endif"}, {"sha": "849e786bb2d8a79b1870715e3b4293eb1efbcc5f", "filename": "gcc/testsuite/gcc.dg/tree-prof/pr45354.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fpr45354.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fpr45354.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fpr45354.c?ref=3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27", "patch": "@@ -1,5 +1,5 @@\n /* { dg-require-effective-target freorder } */\n-/* { dg-options \"-O -freorder-blocks-and-partition -fschedule-insns -fselective-scheduling\" { target powerpc*-*-* ia64-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -freorder-blocks-and-partition -fschedule-insns -fselective-scheduling\" { target powerpc*-*-* ia64-*-* x86_64-*-* } } */\n \n extern void abort (void);\n "}, {"sha": "b850513a13bb951025b174bbec4afedaf13fca91", "filename": "gcc/testsuite/gcc.dg/tree-prof/pr50907.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fpr50907.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fpr50907.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fpr50907.c?ref=3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27", "patch": "@@ -1,5 +1,5 @@\n /* PR middle-end/50907 */\n /* { dg-require-effective-target freorder } */\n-/* { dg-options \"-O -freorder-blocks-and-partition -fschedule-insns -fselective-scheduling -fpic\" { target { { powerpc*-*-* ia64-*-* x86_64-*-* } && fpic } } } */\n+/* { dg-options \"-O2 -freorder-blocks-and-partition -fschedule-insns -fselective-scheduling -fpic\" { target { { powerpc*-*-* ia64-*-* x86_64-*-* } && fpic } } } */\n \n #include \"pr45354.c\""}, {"sha": "c46a14b2e86c37e3521b0de849f7b5871e6017fa", "filename": "gcc/testsuite/gcc.dg/tree-prof/pr52027.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fpr52027.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fpr52027.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fpr52027.c?ref=3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27", "patch": "@@ -1,6 +1,6 @@\n /* PR debug/52027 */\n /* { dg-require-effective-target freorder } */\n-/* { dg-options \"-O -freorder-blocks-and-partition -fno-reorder-functions\" } */\n+/* { dg-options \"-O2 -freorder-blocks-and-partition -fno-reorder-functions\" } */\n \n void\n foo (int len)"}, {"sha": "8d17dbfef85ff3b57c3c918b2fe4d5b1d940ce4b", "filename": "gcc/testsuite/gcc.dg/tree-prof/va-arg-pack-1.c", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fva-arg-pack-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fva-arg-pack-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fva-arg-pack-1.c?ref=3371a64f00ea4bbcb9752c952cd9b2fafc9c9d27", "patch": "@@ -0,0 +1,145 @@\n+/* __builtin_va_arg_pack () builtin tests.  */\n+/* { dg-require-effective-target freorder } */\n+/* { dg-options \"-O2 -freorder-blocks-and-partition\" } */\n+\n+#include <stdarg.h>\n+\n+extern void abort (void);\n+\n+int v1 = 8;\n+long int v2 = 3;\n+void *v3 = (void *) &v2;\n+struct A { char c[16]; } v4 = { \"foo\" };\n+long double v5 = 40;\n+char seen[20];\n+int cnt;\n+\n+__attribute__ ((noinline)) int\n+foo1 (int x, int y, ...)\n+{\n+  int i;\n+  long int l;\n+  void *v;\n+  struct A a;\n+  long double ld;\n+  va_list ap;\n+\n+  va_start (ap, y);\n+  if (x < 0 || x >= 20 || seen[x])\n+    abort ();\n+  seen[x] = ++cnt;\n+  if (y != 6)\n+    abort ();\n+  i = va_arg (ap, int);\n+  if (i != 5)\n+    abort ();\n+  switch (x)\n+    {\n+    case 0:\n+      i = va_arg (ap, int);\n+      if (i != 9 || v1 != 9)\n+\tabort ();\n+      a = va_arg (ap, struct A);\n+      if (__builtin_memcmp (a.c, v4.c, sizeof (a.c)) != 0)\n+\tabort ();\n+      v = (void *) va_arg (ap, struct A *);\n+      if (v != (void *) &v4)\n+\tabort ();\n+      l = va_arg (ap, long int);\n+      if (l != 3 || v2 != 4)\n+\tabort ();\n+      break;\n+    case 1:\n+      ld = va_arg (ap, long double);\n+      if (ld != 41 || v5 != ld)\n+\tabort ();\n+      i = va_arg (ap, int);\n+      if (i != 8)\n+\tabort ();\n+      v = va_arg (ap, void *);\n+      if (v != &v2)\n+\tabort ();\n+      break;\n+    case 2:\n+      break;\n+    default:\n+      abort ();\n+    }\n+  va_end (ap);\n+  return x;\n+}\n+\n+__attribute__ ((noinline)) int\n+foo2 (int x, int y, ...)\n+{\n+  long long int ll;\n+  void *v;\n+  struct A a, b;\n+  long double ld;\n+  va_list ap;\n+\n+  va_start (ap, y);\n+  if (x < 0 || x >= 20 || seen[x])\n+    abort ();\n+  seen[x] = ++cnt | 64;\n+  if (y != 10)\n+    abort ();\n+  switch (x)\n+    {\n+    case 11:\n+      break;\n+    case 12:\n+      ld = va_arg (ap, long double);\n+      if (ld != 41 || v5 != 40)\n+\tabort ();\n+      a = va_arg (ap, struct A);\n+      if (__builtin_memcmp (a.c, v4.c, sizeof (a.c)) != 0)\n+\tabort ();\n+      b = va_arg (ap, struct A);\n+      if (__builtin_memcmp (b.c, v4.c, sizeof (b.c)) != 0)\n+\tabort ();\n+      v = va_arg (ap, void *);\n+      if (v != &v2)\n+\tabort ();\n+      ll = va_arg (ap, long long int);\n+      if (ll != 16LL)\n+\tabort ();\n+      break;\n+    case 2:\n+      break;\n+    default:\n+      abort ();\n+    }\n+  va_end (ap);\n+  return x + 8;\n+}\n+\n+__attribute__ ((noinline)) int\n+foo3 (void)\n+{\n+  return 6;\n+}\n+\n+extern inline __attribute__ ((always_inline, gnu_inline)) int\n+bar (int x, ...)\n+{\n+  if (x < 10)\n+    return foo1 (x, foo3 (), 5, __builtin_va_arg_pack ());\n+  return foo2 (x, foo3 () + 4, __builtin_va_arg_pack ());\n+}\n+\n+int\n+main (void)\n+{\n+  if (bar (0, ++v1, v4, &v4, v2++) != 0)\n+    abort ();\n+  if (bar (1, ++v5, 8, v3) != 1)\n+    abort ();\n+  if (bar (2) != 2)\n+    abort ();\n+  if (bar (v1 + 2) != 19)\n+    abort ();\n+  if (bar (v1 + 3, v5--, v4, v4, v3, 16LL) != 20)\n+    abort ();\n+  return 0;\n+}"}]}