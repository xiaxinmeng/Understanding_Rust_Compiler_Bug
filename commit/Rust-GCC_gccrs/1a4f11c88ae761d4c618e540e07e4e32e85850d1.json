{"sha": "1a4f11c88ae761d4c618e540e07e4e32e85850d1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWE0ZjExYzg4YWU3NjFkNGM2MThlNTQwZTA3ZTRlMzJlODU4NTBkMQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2016-06-22T15:20:41Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2016-06-22T15:20:41Z"}, "message": "C FE: suggest corrections for misspelled identifiers and type names\n\ngcc/c-family/ChangeLog:\n\tPR c/70339\n\t* c-common.h (enum lookup_name_fuzzy_kind): New enum.\n\t(lookup_name_fuzzy): New prototype.\n\ngcc/c/ChangeLog:\n\tPR c/70339\n\t* c-decl.c: Include spellcheck-tree.h and gcc-rich-location.h.\n\t(implicit_decl_warning): When issuing warnings for implicit\n\tdeclarations, attempt to provide a suggestion via\n\tlookup_name_fuzzy.\n\t(undeclared_variable): Likewise when issuing errors.\n\t(lookup_name_in_scope): Likewise.\n\t(struct edit_distance_traits<cpp_hashnode *>): New struct.\n\t(best_macro_match): New typedef.\n\t(find_closest_macro_cpp_cb): New function.\n\t(lookup_name_fuzzy): New function.\n\t* c-parser.c: Include gcc-rich-location.h.\n\t(c_token_starts_typename): Split out case CPP_KEYWORD into...\n\t(c_keyword_starts_typename): ...this new function.\n\t(c_parser_declaration_or_fndef): When issuing errors about\n\tmissing \"struct\" etc, add a fixit.  For other kinds of errors,\n\tattempt to provide a suggestion via lookup_name_fuzzy.\n\t(c_parser_parms_declarator): When looking ahead to detect typos in\n\ttype names, also reject CPP_KEYWORD.\n\t(c_parser_parameter_declaration): When issuing errors about\n\tunknown type names, attempt to provide a suggestion via\n\tlookup_name_fuzzy.\n\t* c-tree.h (c_keyword_starts_typename): New prototype.\n\ngcc/ChangeLog:\n\tPR c/70339\n\t* diagnostic-core.h (pedwarn_at_rich_loc): New prototype.\n\t* diagnostic.c (pedwarn_at_rich_loc): New function.\n\t* spellcheck.h (best_match::best_match): Add a\n\t\"best_distance_so_far\" optional parameter.\n\t(best_match::set_best_so_far): New method.\n\t(best_match::get_best_distance): New accessor.\n\t(best_match::get_best_candidate_length): New accessor.\n\ngcc/testsuite/ChangeLog:\n\tPR c/70339\n\t* c-c++-common/attributes-1.c: Update dg-prune-output to include\n\thint.\n\t* gcc.dg/diagnostic-token-ranges.c (undeclared_identifier): Update\n\texpected results due to builtin \"nanl\" now being suggested for\n\t\"name\".\n\t* gcc.dg/pr67580.c: Update expected messages.\n\t* gcc.dg/spellcheck-identifiers.c: New testcase.\n\t* gcc.dg/spellcheck-typenames.c: New testcase.\n\nFrom-SVN: r237714", "tree": {"sha": "6249c6a772dc9140476eee29b52cfe04dbe0e29d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6249c6a772dc9140476eee29b52cfe04dbe0e29d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a4f11c88ae761d4c618e540e07e4e32e85850d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a4f11c88ae761d4c618e540e07e4e32e85850d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a4f11c88ae761d4c618e540e07e4e32e85850d1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a4f11c88ae761d4c618e540e07e4e32e85850d1/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6f99ef82f1457d2f71121853ef2f006d0800bd19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f99ef82f1457d2f71121853ef2f006d0800bd19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f99ef82f1457d2f71121853ef2f006d0800bd19"}], "stats": {"total": 701, "additions": 634, "deletions": 67}, "files": [{"sha": "0ae2b0338fbb0bcdaa7e48a09d60e4240ad6efe7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4f11c88ae761d4c618e540e07e4e32e85850d1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4f11c88ae761d4c618e540e07e4e32e85850d1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1a4f11c88ae761d4c618e540e07e4e32e85850d1", "patch": "@@ -1,3 +1,14 @@\n+2016-06-22  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR c/70339\n+\t* diagnostic-core.h (pedwarn_at_rich_loc): New prototype.\n+\t* diagnostic.c (pedwarn_at_rich_loc): New function.\n+\t* spellcheck.h (best_match::best_match): Add a\n+\t\"best_distance_so_far\" optional parameter.\n+\t(best_match::set_best_so_far): New method.\n+\t(best_match::get_best_distance): New accessor.\n+\t(best_match::get_best_candidate_length): New accessor.\n+\n 2016-06-22  Nick Clifton  <nickc@redhat.com>\n \n \t* dwarf2out.c (scompare_loc_descriptor): Use SCALAR_INT_MODE_P() in"}, {"sha": "cd463154da64b586d57de5df04c004721064aac3", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4f11c88ae761d4c618e540e07e4e32e85850d1/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4f11c88ae761d4c618e540e07e4e32e85850d1/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=1a4f11c88ae761d4c618e540e07e4e32e85850d1", "patch": "@@ -1,3 +1,9 @@\n+2016-06-22  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR c/70339\n+\t* c-common.h (enum lookup_name_fuzzy_kind): New enum.\n+\t(lookup_name_fuzzy): New prototype.\n+\n 2016-06-21  John David Anglin  <danglin@gcc.gnu.org>\n \n \t* c-common.c (get_source_date_epoch): Use int64_t instead of long long."}, {"sha": "3ad5400458efb0e9dde10519b6892254cbd5be07", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4f11c88ae761d4c618e540e07e4e32e85850d1/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4f11c88ae761d4c618e540e07e4e32e85850d1/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=1a4f11c88ae761d4c618e540e07e4e32e85850d1", "patch": "@@ -990,6 +990,15 @@ extern tree lookup_label (tree);\n extern tree lookup_name (tree);\n extern bool lvalue_p (const_tree);\n \n+enum lookup_name_fuzzy_kind {\n+  /* Names of types.  */\n+  FUZZY_LOOKUP_TYPENAME,\n+\n+  /* Any name.  */\n+  FUZZY_LOOKUP_NAME\n+};\n+extern tree lookup_name_fuzzy (tree, enum lookup_name_fuzzy_kind);\n+\n extern bool vector_targets_convertible_p (const_tree t1, const_tree t2);\n extern bool vector_types_convertible_p (const_tree t1, const_tree t2, bool emit_lax_note);\n extern tree c_build_vec_perm_expr (location_t, tree, tree, tree, bool = true);"}, {"sha": "47d1f571f98b06ec33bcda88016cbc35074bd0a1", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4f11c88ae761d4c618e540e07e4e32e85850d1/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4f11c88ae761d4c618e540e07e4e32e85850d1/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=1a4f11c88ae761d4c618e540e07e4e32e85850d1", "patch": "@@ -1,3 +1,29 @@\n+2016-06-22  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR c/70339\n+\t* c-decl.c: Include spellcheck-tree.h and gcc-rich-location.h.\n+\t(implicit_decl_warning): When issuing warnings for implicit\n+\tdeclarations, attempt to provide a suggestion via\n+\tlookup_name_fuzzy.\n+\t(undeclared_variable): Likewise when issuing errors.\n+\t(lookup_name_in_scope): Likewise.\n+\t(struct edit_distance_traits<cpp_hashnode *>): New struct.\n+\t(best_macro_match): New typedef.\n+\t(find_closest_macro_cpp_cb): New function.\n+\t(lookup_name_fuzzy): New function.\n+\t* c-parser.c: Include gcc-rich-location.h.\n+\t(c_token_starts_typename): Split out case CPP_KEYWORD into...\n+\t(c_keyword_starts_typename): ...this new function.\n+\t(c_parser_declaration_or_fndef): When issuing errors about\n+\tmissing \"struct\" etc, add a fixit.  For other kinds of errors,\n+\tattempt to provide a suggestion via lookup_name_fuzzy.\n+\t(c_parser_parms_declarator): When looking ahead to detect typos in\n+\ttype names, also reject CPP_KEYWORD.\n+\t(c_parser_parameter_declaration): When issuing errors about\n+\tunknown type names, attempt to provide a suggestion via\n+\tlookup_name_fuzzy.\n+\t* c-tree.h (c_keyword_starts_typename): New prototype.\n+\n 2016-06-20  Joseph Myers  <joseph@codesourcery.com>\n \n \tPR c/71601"}, {"sha": "8b966fecc29bd71978a2314dcf7a9c3c254a2646", "filename": "gcc/c/c-decl.c", "status": "modified", "additions": 184, "deletions": 6, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4f11c88ae761d4c618e540e07e4e32e85850d1/gcc%2Fc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4f11c88ae761d4c618e540e07e4e32e85850d1/gcc%2Fc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.c?ref=1a4f11c88ae761d4c618e540e07e4e32e85850d1", "patch": "@@ -51,6 +51,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"c-family/c-ada-spec.h\"\n #include \"cilk.h\"\n #include \"builtins.h\"\n+#include \"spellcheck-tree.h\"\n+#include \"gcc-rich-location.h\"\n \n /* In grokdeclarator, distinguish syntactic contexts of declarators.  */\n enum decl_context\n@@ -3086,13 +3088,36 @@ implicit_decl_warning (location_t loc, tree id, tree olddecl)\n   if (warn_implicit_function_declaration)\n     {\n       bool warned;\n+      tree hint = NULL_TREE;\n+      if (!olddecl)\n+\thint = lookup_name_fuzzy (id, FUZZY_LOOKUP_NAME);\n \n       if (flag_isoc99)\n-\twarned = pedwarn (loc, OPT_Wimplicit_function_declaration,\n-\t\t\t  \"implicit declaration of function %qE\", id);\n+\tif (hint)\n+\t  {\n+\t    gcc_rich_location richloc (loc);\n+\t    richloc.add_fixit_misspelled_id (loc, hint);\n+\t    warned = pedwarn_at_rich_loc\n+\t      (&richloc, OPT_Wimplicit_function_declaration,\n+\t       \"implicit declaration of function %qE; did you mean %qE?\",\n+\t       id, hint);\n+\t  }\n+\telse\n+\t  warned = pedwarn (loc, OPT_Wimplicit_function_declaration,\n+\t\t\t    \"implicit declaration of function %qE\", id);\n       else\n-\twarned = warning_at (loc, OPT_Wimplicit_function_declaration,\n-\t\t\t     G_(\"implicit declaration of function %qE\"), id);\n+\tif (hint)\n+\t  {\n+\t    gcc_rich_location richloc (loc);\n+\t    richloc.add_fixit_misspelled_id (loc, hint);\n+\t    warned = warning_at_rich_loc\n+\t      (&richloc, OPT_Wimplicit_function_declaration,\n+\t       G_(\"implicit declaration of function %qE;did you mean %qE?\"),\n+\t       id, hint);\n+\t  }\n+\telse\n+\t  warned = warning_at (loc, OPT_Wimplicit_function_declaration,\n+\t\t\t       G_(\"implicit declaration of function %qE\"), id);\n       if (olddecl && warned)\n \tlocate_old_decl (olddecl);\n     }\n@@ -3408,13 +3433,38 @@ undeclared_variable (location_t loc, tree id)\n \n   if (current_function_decl == 0)\n     {\n-      error_at (loc, \"%qE undeclared here (not in a function)\", id);\n+      tree guessed_id = lookup_name_fuzzy (id, FUZZY_LOOKUP_NAME);\n+      if (guessed_id)\n+\t{\n+\t  gcc_rich_location richloc (loc);\n+\t  richloc.add_fixit_misspelled_id (loc, guessed_id);\n+\t  error_at_rich_loc (&richloc,\n+\t\t\t     \"%qE undeclared here (not in a function);\"\n+\t\t\t     \" did you mean %qE?\",\n+\t\t\t     id, guessed_id);\n+\t}\n+      else\n+\terror_at (loc, \"%qE undeclared here (not in a function)\", id);\n       scope = current_scope;\n     }\n   else\n     {\n       if (!objc_diagnose_private_ivar (id))\n-        error_at (loc, \"%qE undeclared (first use in this function)\", id);\n+\t{\n+\t  tree guessed_id = lookup_name_fuzzy (id, FUZZY_LOOKUP_NAME);\n+\t  if (guessed_id)\n+\t    {\n+\t      gcc_rich_location richloc (loc);\n+\t      richloc.add_fixit_misspelled_id (loc, guessed_id);\n+\t      error_at_rich_loc\n+\t\t(&richloc,\n+\t\t \"%qE undeclared (first use in this function);\"\n+\t\t \" did you mean %qE?\",\n+\t\t id, guessed_id);\n+\t    }\n+\t  else\n+\t    error_at (loc, \"%qE undeclared (first use in this function)\", id);\n+\t}\n       if (!already)\n \t{\n           inform (loc, \"each undeclared identifier is reported only\"\n@@ -3904,6 +3954,134 @@ lookup_name_in_scope (tree name, struct c_scope *scope)\n       return b->decl;\n   return NULL_TREE;\n }\n+\n+/* Specialization of edit_distance_traits for preprocessor macros.  */\n+\n+template <>\n+struct edit_distance_traits<cpp_hashnode *>\n+{\n+  static size_t get_length (cpp_hashnode *hashnode)\n+  {\n+    return hashnode->ident.len;\n+  }\n+\n+  static const char *get_string (cpp_hashnode *hashnode)\n+  {\n+    return (const char *)hashnode->ident.str;\n+  }\n+};\n+\n+/* Specialization of best_match<> for finding the closest preprocessor\n+   macro to a given identifier.  */\n+\n+typedef best_match<tree, cpp_hashnode *> best_macro_match;\n+\n+/* A callback for cpp_forall_identifiers, for use by lookup_name_fuzzy.\n+   Process HASHNODE and update the best_macro_match instance pointed to be\n+   USER_DATA.  */\n+\n+static int\n+find_closest_macro_cpp_cb (cpp_reader *, cpp_hashnode *hashnode,\n+\t\t\t   void *user_data)\n+{\n+  if (hashnode->type != NT_MACRO)\n+    return 1;\n+\n+  best_macro_match *bmm = (best_macro_match *)user_data;\n+  bmm->consider (hashnode);\n+\n+  /* Keep iterating.  */\n+  return 1;\n+}\n+\n+/* Look for the closest match for NAME within the currently valid\n+   scopes.\n+\n+   This finds the identifier with the lowest Levenshtein distance to\n+   NAME.  If there are multiple candidates with equal minimal distance,\n+   the first one found is returned.  Scopes are searched from innermost\n+   outwards, and within a scope in reverse order of declaration, thus\n+   benefiting candidates \"near\" to the current scope.\n+\n+   The function also looks for similar macro names to NAME, since a\n+   misspelled macro name will not be expanded, and hence looks like an\n+   identifier to the C frontend.\n+\n+   It also looks for start_typename keywords, to detect \"singed\" vs \"signed\"\n+   typos.  */\n+\n+tree\n+lookup_name_fuzzy (tree name, enum lookup_name_fuzzy_kind kind)\n+{\n+  gcc_assert (TREE_CODE (name) == IDENTIFIER_NODE);\n+\n+  best_match<tree, tree> bm (name);\n+\n+  /* Look within currently valid scopes.  */\n+  for (c_scope *scope = current_scope; scope; scope = scope->outer)\n+    for (c_binding *binding = scope->bindings; binding; binding = binding->prev)\n+      {\n+\tif (!binding->id)\n+\t  continue;\n+\t/* Don't use bindings from implicitly declared functions,\n+\t   as they were likely misspellings themselves.  */\n+\tif (TREE_CODE (binding->decl) == FUNCTION_DECL)\n+\t  if (C_DECL_IMPLICIT (binding->decl))\n+\t    continue;\n+\tif (kind == FUZZY_LOOKUP_TYPENAME)\n+\t  if (TREE_CODE (binding->decl) != TYPE_DECL)\n+\t    continue;\n+\tbm.consider (binding->id);\n+      }\n+\n+  /* Consider macros: if the user misspelled a macro name e.g. \"SOME_MACRO\"\n+     as:\n+       x = SOME_OTHER_MACRO (y);\n+     then \"SOME_OTHER_MACRO\" will survive to the frontend and show up\n+     as a misspelled identifier.\n+\n+     Use the best distance so far so that a candidate is only set if\n+     a macro is better than anything so far.  This allows early rejection\n+     (without calculating the edit distance) of macro names that must have\n+     distance >= bm.get_best_distance (), and means that we only get a\n+     non-NULL result for best_macro_match if it's better than any of\n+     the identifiers already checked, which avoids needless creation\n+     of identifiers for macro hashnodes.  */\n+  best_macro_match bmm (name, bm.get_best_distance ());\n+  cpp_forall_identifiers (parse_in, find_closest_macro_cpp_cb, &bmm);\n+  cpp_hashnode *best_macro = bmm.get_best_meaningful_candidate ();\n+  /* If a macro is the closest so far to NAME, use it, creating an\n+     identifier tree node for it.  */\n+  if (best_macro)\n+    {\n+      const char *id = (const char *)best_macro->ident.str;\n+      tree macro_as_identifier\n+\t= get_identifier_with_length (id, best_macro->ident.len);\n+      bm.set_best_so_far (macro_as_identifier,\n+\t\t\t  bmm.get_best_distance (),\n+\t\t\t  bmm.get_best_candidate_length ());\n+    }\n+\n+  /* Try the \"start_typename\" keywords to detect\n+     \"singed\" vs \"signed\" typos.  */\n+  if (kind == FUZZY_LOOKUP_TYPENAME)\n+    {\n+      for (unsigned i = 0; i < num_c_common_reswords; i++)\n+\t{\n+\t  const c_common_resword *resword = &c_common_reswords[i];\n+\t  if (!c_keyword_starts_typename (resword->rid))\n+\t    continue;\n+\t  tree resword_identifier = ridpointers [resword->rid];\n+\t  if (!resword_identifier)\n+\t    continue;\n+\t  gcc_assert (TREE_CODE (resword_identifier) == IDENTIFIER_NODE);\n+\t  bm.consider (resword_identifier);\n+\t}\n+    }\n+\n+  return bm.get_best_meaningful_candidate ();\n+}\n+\n \f\n /* Create the predefined scalar types of C,\n    and some nodes representing standard constants (0, 1, (void *) 0)."}, {"sha": "7f491f1dc060857e22ff489621e97d0508fa4e80", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 99, "deletions": 45, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4f11c88ae761d4c618e540e07e4e32e85850d1/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4f11c88ae761d4c618e540e07e4e32e85850d1/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=1a4f11c88ae761d4c618e540e07e4e32e85850d1", "patch": "@@ -58,6 +58,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"c-family/c-indentation.h\"\n #include \"gimple-expr.h\"\n #include \"context.h\"\n+#include \"gcc-rich-location.h\"\n \n /* We need to walk over decls with incomplete struct/union/enum types\n    after parsing the whole translation unit.\n@@ -518,6 +519,48 @@ c_parser_peek_nth_token (c_parser *parser, unsigned int n)\n   return &parser->tokens[n - 1];\n }\n \n+bool\n+c_keyword_starts_typename (enum rid keyword)\n+{\n+  switch (keyword)\n+    {\n+    case RID_UNSIGNED:\n+    case RID_LONG:\n+    case RID_SHORT:\n+    case RID_SIGNED:\n+    case RID_COMPLEX:\n+    case RID_INT:\n+    case RID_CHAR:\n+    case RID_FLOAT:\n+    case RID_DOUBLE:\n+    case RID_VOID:\n+    case RID_DFLOAT32:\n+    case RID_DFLOAT64:\n+    case RID_DFLOAT128:\n+    case RID_BOOL:\n+    case RID_ENUM:\n+    case RID_STRUCT:\n+    case RID_UNION:\n+    case RID_TYPEOF:\n+    case RID_CONST:\n+    case RID_ATOMIC:\n+    case RID_VOLATILE:\n+    case RID_RESTRICT:\n+    case RID_ATTRIBUTE:\n+    case RID_FRACT:\n+    case RID_ACCUM:\n+    case RID_SAT:\n+    case RID_AUTO_TYPE:\n+      return true;\n+    default:\n+      if (keyword >= RID_FIRST_INT_N\n+\t  && keyword < RID_FIRST_INT_N + NUM_INT_N_ENTS\n+\t  && int_n_enabled_p[keyword - RID_FIRST_INT_N])\n+\treturn true;\n+      return false;\n+    }\n+}\n+\n /* Return true if TOKEN can start a type name,\n    false otherwise.  */\n static bool\n@@ -541,43 +584,7 @@ c_token_starts_typename (c_token *token)\n \t  gcc_unreachable ();\n \t}\n     case CPP_KEYWORD:\n-      switch (token->keyword)\n-\t{\n-\tcase RID_UNSIGNED:\n-\tcase RID_LONG:\n-\tcase RID_SHORT:\n-\tcase RID_SIGNED:\n-\tcase RID_COMPLEX:\n-\tcase RID_INT:\n-\tcase RID_CHAR:\n-\tcase RID_FLOAT:\n-\tcase RID_DOUBLE:\n-\tcase RID_VOID:\n-\tcase RID_DFLOAT32:\n-\tcase RID_DFLOAT64:\n-\tcase RID_DFLOAT128:\n-\tcase RID_BOOL:\n-\tcase RID_ENUM:\n-\tcase RID_STRUCT:\n-\tcase RID_UNION:\n-\tcase RID_TYPEOF:\n-\tcase RID_CONST:\n-\tcase RID_ATOMIC:\n-\tcase RID_VOLATILE:\n-\tcase RID_RESTRICT:\n-\tcase RID_ATTRIBUTE:\n-\tcase RID_FRACT:\n-\tcase RID_ACCUM:\n-\tcase RID_SAT:\n-\tcase RID_AUTO_TYPE:\n-\t  return true;\n-\tdefault:\n-\t  if (token->keyword >= RID_FIRST_INT_N\n-\t      && token->keyword < RID_FIRST_INT_N + NUM_INT_N_ENTS\n-\t      && int_n_enabled_p[token->keyword - RID_FIRST_INT_N])\n-\t    return true;\n-\t  return false;\n-\t}\n+      return c_keyword_starts_typename (token->keyword);\n     case CPP_LESS:\n       if (c_dialect_objc ())\n \treturn true;\n@@ -1655,15 +1662,50 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n       && (!nested || !lookup_name (c_parser_peek_token (parser)->value)))\n     {\n       tree name = c_parser_peek_token (parser)->value;\n-      error_at (here, \"unknown type name %qE\", name);\n-      /* Give a hint to the user.  This is not C++ with its implicit\n-\t typedef.  */\n+\n+      /* Issue a warning about NAME being an unknown type name, perhaps\n+\t with some kind of hint.\n+\t If the user forgot a \"struct\" etc, suggest inserting\n+\t it.  Otherwise, attempt to look for misspellings.  */\n+      gcc_rich_location richloc (here);\n       if (tag_exists_p (RECORD_TYPE, name))\n-\tinform (here, \"use %<struct%> keyword to refer to the type\");\n+\t{\n+\t  /* This is not C++ with its implicit typedef.  */\n+\t  richloc.add_fixit_insert (here, \"struct\");\n+\t  error_at_rich_loc (&richloc,\n+\t\t\t     \"unknown type name %qE;\"\n+\t\t\t     \" use %<struct%> keyword to refer to the type\",\n+\t\t\t     name);\n+\t}\n       else if (tag_exists_p (UNION_TYPE, name))\n-\tinform (here, \"use %<union%> keyword to refer to the type\");\n+\t{\n+\t  richloc.add_fixit_insert (here, \"union\");\n+\t  error_at_rich_loc (&richloc,\n+\t\t\t     \"unknown type name %qE;\"\n+\t\t\t     \" use %<union%> keyword to refer to the type\",\n+\t\t\t     name);\n+\t}\n       else if (tag_exists_p (ENUMERAL_TYPE, name))\n-\tinform (here, \"use %<enum%> keyword to refer to the type\");\n+\t{\n+\t  richloc.add_fixit_insert (here, \"enum\");\n+\t  error_at_rich_loc (&richloc,\n+\t\t\t     \"unknown type name %qE;\"\n+\t\t\t     \" use %<enum%> keyword to refer to the type\",\n+\t\t\t     name);\n+\t}\n+      else\n+\t{\n+\t  tree hint = lookup_name_fuzzy (name, FUZZY_LOOKUP_TYPENAME);\n+\t  if (hint)\n+\t    {\n+\t      richloc.add_fixit_misspelled_id (here, hint);\n+\t      error_at_rich_loc (&richloc,\n+\t\t\t\t \"unknown type name %qE; did you mean %qE?\",\n+\t\t\t\t name, hint);\n+\t    }\n+\t  else\n+\t    error_at (here, \"unknown type name %qE\", name);\n+\t}\n \n       /* Parse declspecs normally to get a correct pointer type, but avoid\n          a further \"fails to be a type name\" error.  Refuse nested functions\n@@ -3632,7 +3674,8 @@ c_parser_parms_declarator (c_parser *parser, bool id_list_ok, tree attrs)\n       && c_parser_peek_2nd_token (parser)->type != CPP_NAME\n       && c_parser_peek_2nd_token (parser)->type != CPP_MULT\n       && c_parser_peek_2nd_token (parser)->type != CPP_OPEN_PAREN\n-      && c_parser_peek_2nd_token (parser)->type != CPP_OPEN_SQUARE)\n+      && c_parser_peek_2nd_token (parser)->type != CPP_OPEN_SQUARE\n+      && c_parser_peek_2nd_token (parser)->type != CPP_KEYWORD)\n     {\n       tree list = NULL_TREE, *nextp = &list;\n       while (c_parser_next_token_is (parser, CPP_NAME)\n@@ -3807,7 +3850,18 @@ c_parser_parameter_declaration (c_parser *parser, tree attrs)\n       c_parser_set_source_position_from_token (token);\n       if (c_parser_next_tokens_start_typename (parser, cla_prefer_type))\n \t{\n-\t  error_at (token->location, \"unknown type name %qE\", token->value);\n+\t  tree hint = lookup_name_fuzzy (token->value, FUZZY_LOOKUP_TYPENAME);\n+\t  if (hint)\n+\t    {\n+\t      gcc_assert (TREE_CODE (hint) == IDENTIFIER_NODE);\n+\t      gcc_rich_location richloc (token->location);\n+\t      richloc.add_fixit_misspelled_id (token->location, hint);\n+\t      error_at_rich_loc (&richloc,\n+\t\t\t\t \"unknown type name %qE; did you mean %qE?\",\n+\t\t\t\t token->value, hint);\n+\t    }\n+\t  else\n+\t    error_at (token->location, \"unknown type name %qE\", token->value);\n \t  parser->error = true;\n \t}\n       /* ??? In some Objective-C cases '...' isn't applicable so there"}, {"sha": "46be53ece2166bca7fdfaf4d756fea7e797bda1f", "filename": "gcc/c/c-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4f11c88ae761d4c618e540e07e4e32e85850d1/gcc%2Fc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4f11c88ae761d4c618e540e07e4e32e85850d1/gcc%2Fc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-tree.h?ref=1a4f11c88ae761d4c618e540e07e4e32e85850d1", "patch": "@@ -482,6 +482,7 @@ enum c_inline_static_type {\n \f\n /* in c-parser.c */\n extern void c_parse_init (void);\n+extern bool c_keyword_starts_typename (enum rid keyword);\n \n /* in c-aux-info.c */\n extern void gen_aux_info_record (tree, int, int, int);"}, {"sha": "51df15028d4c327dc414324a92f991f012c3d9b5", "filename": "gcc/diagnostic-core.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4f11c88ae761d4c618e540e07e4e32e85850d1/gcc%2Fdiagnostic-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4f11c88ae761d4c618e540e07e4e32e85850d1/gcc%2Fdiagnostic-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic-core.h?ref=1a4f11c88ae761d4c618e540e07e4e32e85850d1", "patch": "@@ -76,6 +76,8 @@ extern void fatal_error (location_t, const char *, ...) ATTRIBUTE_GCC_DIAG(2,3)\n /* Pass one of the OPT_W* from options.h as the second parameter.  */\n extern bool pedwarn (location_t, int, const char *, ...)\n      ATTRIBUTE_GCC_DIAG(3,4);\n+extern bool pedwarn_at_rich_loc (rich_location *, int, const char *, ...)\n+     ATTRIBUTE_GCC_DIAG(3,4);\n extern bool permerror (location_t, const char *, ...) ATTRIBUTE_GCC_DIAG(2,3);\n extern bool permerror_at_rich_loc (rich_location *, const char *,\n \t\t\t\t   ...) ATTRIBUTE_GCC_DIAG(2,3);"}, {"sha": "bb41011afad68cca29af356d591d293fba75224f", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4f11c88ae761d4c618e540e07e4e32e85850d1/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4f11c88ae761d4c618e540e07e4e32e85850d1/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=1a4f11c88ae761d4c618e540e07e4e32e85850d1", "patch": "@@ -1201,6 +1201,18 @@ pedwarn (location_t location, int opt, const char *gmsgid, ...)\n   return ret;\n }\n \n+/* Same as pedwarn, but using RICHLOC.  */\n+\n+bool\n+pedwarn_at_rich_loc (rich_location *richloc, int opt, const char *gmsgid, ...)\n+{\n+  va_list ap;\n+  va_start (ap, gmsgid);\n+  bool ret = diagnostic_impl (richloc, opt, gmsgid, &ap, DK_PEDWARN);\n+  va_end (ap);\n+  return ret;\n+}\n+\n /* A \"permissive\" error at LOCATION: issues an error unless\n    -fpermissive was given on the command line, in which case it issues\n    a warning.  Use this for things that really should be errors but we"}, {"sha": "035f4ac360880bdbb8970bcf746d37692eaab73f", "filename": "gcc/spellcheck.h", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4f11c88ae761d4c618e540e07e4e32e85850d1/gcc%2Fspellcheck.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4f11c88ae761d4c618e540e07e4e32e85850d1/gcc%2Fspellcheck.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fspellcheck.h?ref=1a4f11c88ae761d4c618e540e07e4e32e85850d1", "patch": "@@ -69,11 +69,12 @@ class best_match\n \n   /* Constructor.  */\n \n-  best_match (goal_t goal)\n+  best_match (GOAL_TYPE goal,\n+\t      edit_distance_t best_distance_so_far = MAX_EDIT_DISTANCE)\n   : m_goal (goal_traits::get_string (goal)),\n     m_goal_len (goal_traits::get_length (goal)),\n     m_best_candidate (NULL),\n-    m_best_distance (MAX_EDIT_DISTANCE)\n+    m_best_distance (best_distance_so_far)\n   {}\n \n   /* Compare the edit distance between CANDIDATE and m_goal,\n@@ -118,6 +119,20 @@ class best_match\n       }\n   }\n \n+  /* Assuming that BEST_CANDIDATE is known to be better than\n+     m_best_candidate, update (without recomputing the edit distance to\n+     the goal).  */\n+\n+  void set_best_so_far (CANDIDATE_TYPE best_candidate,\n+\t\t\tedit_distance_t best_distance,\n+\t\t\tsize_t best_candidate_len)\n+  {\n+    gcc_assert (best_distance < m_best_distance);\n+    m_best_candidate = best_candidate;\n+    m_best_distance = best_distance;\n+    m_best_candidate_len = best_candidate_len;\n+  }\n+\n   /* Get the best candidate so far, but applying a filter to ensure\n      that we return NULL if none of the candidates are close to the goal,\n      to avoid offering nonsensical suggestions to the user.  */\n@@ -135,6 +150,9 @@ class best_match\n     return m_best_candidate;\n   }\n \n+  edit_distance_t get_best_distance () const { return m_best_distance; }\n+  size_t get_best_candidate_length () const { return m_best_candidate_len; }\n+\n  private:\n   const char *m_goal;\n   size_t m_goal_len;"}, {"sha": "2082fff71c9ffb316f6856c408f07336cce5149f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4f11c88ae761d4c618e540e07e4e32e85850d1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4f11c88ae761d4c618e540e07e4e32e85850d1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1a4f11c88ae761d4c618e540e07e4e32e85850d1", "patch": "@@ -1,3 +1,15 @@\n+2016-06-22  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR c/70339\n+\t* c-c++-common/attributes-1.c: Update dg-prune-output to include\n+\thint.\n+\t* gcc.dg/diagnostic-token-ranges.c (undeclared_identifier): Update\n+\texpected results due to builtin \"nanl\" now being suggested for\n+\t\"name\".\n+\t* gcc.dg/pr67580.c: Update expected messages.\n+\t* gcc.dg/spellcheck-identifiers.c: New testcase.\n+\t* gcc.dg/spellcheck-typenames.c: New testcase.\n+\n 2016-06-22  David Malcolm  <dmalcolm@redhat.com>\n \n \t* gcc.dg/plugin/diagnostic-test-show-locus-parseable-fixits.c: New"}, {"sha": "c348526b0d4b3cc56c7f94a53a07832f0b1510a7", "filename": "gcc/testsuite/c-c++-common/attributes-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4f11c88ae761d4c618e540e07e4e32e85850d1/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattributes-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4f11c88ae761d4c618e540e07e4e32e85850d1/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattributes-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattributes-1.c?ref=1a4f11c88ae761d4c618e540e07e4e32e85850d1", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-prune-output \"undeclared here \\\\(not in a function\\\\)|\\[^\\n\\r\\]* was not declared in this scope\" } */\n+/* { dg-prune-output \"undeclared here \\\\(not in a function\\\\); did you mean .carg..|\\[^\\n\\r\\]* was not declared in this scope\" } */\n \n void* my_calloc(unsigned, unsigned) __attribute__((alloc_size(1,bar))); /* { dg-warning \"outside range\" } */\n void* my_realloc(void*, unsigned) __attribute__((alloc_size(bar))); /* { dg-warning \"outside range\" } */"}, {"sha": "19399490c04d3c2d88120d58966b4739947a4fd7", "filename": "gcc/testsuite/gcc.dg/diagnostic-token-ranges.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4f11c88ae761d4c618e540e07e4e32e85850d1/gcc%2Ftestsuite%2Fgcc.dg%2Fdiagnostic-token-ranges.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4f11c88ae761d4c618e540e07e4e32e85850d1/gcc%2Ftestsuite%2Fgcc.dg%2Fdiagnostic-token-ranges.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdiagnostic-token-ranges.c?ref=1a4f11c88ae761d4c618e540e07e4e32e85850d1", "patch": "@@ -6,11 +6,12 @@\n \n void undeclared_identifier (void)\n {\n-  name; /* { dg-error \"'name' undeclared\" } */\n+  name; /* { dg-error \"'name' undeclared .first use in this function.; did you mean .nanl.\" } */\n /*\n { dg-begin-multiline-output \"\" }\n    name;\n    ^~~~\n+   nanl\n { dg-end-multiline-output \"\" }\n */\n }"}, {"sha": "c2760e5da11edfb25444befd0794b49ff52c57dd", "filename": "gcc/testsuite/gcc.dg/pr67580.c", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4f11c88ae761d4c618e540e07e4e32e85850d1/gcc%2Ftestsuite%2Fgcc.dg%2Fpr67580.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4f11c88ae761d4c618e540e07e4e32e85850d1/gcc%2Ftestsuite%2Fgcc.dg%2Fpr67580.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr67580.c?ref=1a4f11c88ae761d4c618e540e07e4e32e85850d1", "patch": "@@ -8,12 +8,9 @@ enum E { A };\n void\n f (void)\n {\n-  S s; /* { dg-error \"unknown type name\" } */\n-/* { dg-message \"use .struct. keyword to refer to the type\" \"\" { target *-*-* } 11 } */\n-  U u; /* { dg-error \"unknown type name\" } */\n-/* { dg-message \"use .union. keyword to refer to the type\" \"\" { target *-*-* } 13 } */\n-  E e; /* { dg-error \"unknown type name\" } */\n-/* { dg-message \"use .enum. keyword to refer to the type\" \"\" { target *-*-* } 15 } */\n+  S s; /* { dg-error \"unknown type name .S.; use .struct. keyword to refer to the type\" } */\n+  U u; /* { dg-error \"unknown type name .U.; use .union. keyword to refer to the type\" } */\n+  E e; /* { dg-error \"unknown type name .E.; use .enum. keyword to refer to the type\" } */\n }\n \n void\n@@ -22,10 +19,7 @@ g (void)\n   struct T { int i; };\n   union V { int i; };\n   enum F { J };\n-  T t; /* { dg-error \"unknown type name\" } */\n-/* { dg-message \"use .struct. keyword to refer to the type\" \"\" { target *-*-* } 25 } */\n-  V v; /* { dg-error \"unknown type name\" } */\n-/* { dg-message \"use .union. keyword to refer to the type\" \"\" { target *-*-* } 27 } */\n-  F f; /* { dg-error \"unknown type name\" } */\n-/* { dg-message \"use .enum. keyword to refer to the type\" \"\" { target *-*-* } 29 } */\n+  T t; /* { dg-error \"unknown type name .T.; use .struct. keyword to refer to the type\" } */\n+  V v; /* { dg-error \"unknown type name .V.; use .union. keyword to refer to the type\" } */\n+  F f; /* { dg-error \"unknown type name .F.; use .enum. keyword to refer to the type\" } */\n }"}, {"sha": "22a12d0fa1cbb9f271bd4ea13e02d6e6d7642e2e", "filename": "gcc/testsuite/gcc.dg/spellcheck-identifiers.c", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4f11c88ae761d4c618e540e07e4e32e85850d1/gcc%2Ftestsuite%2Fgcc.dg%2Fspellcheck-identifiers.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4f11c88ae761d4c618e540e07e4e32e85850d1/gcc%2Ftestsuite%2Fgcc.dg%2Fspellcheck-identifiers.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fspellcheck-identifiers.c?ref=1a4f11c88ae761d4c618e540e07e4e32e85850d1", "patch": "@@ -0,0 +1,136 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wimplicit-function-declaration -fdiagnostics-show-caret\" } */\n+\n+typedef struct GtkWidget { int dummy; } GtkWidget;\n+\n+extern void gtk_widget_show_all (GtkWidget *w);\n+\n+void\n+test_1 (GtkWidget *w)\n+{\n+  gtk_widget_showall (w); /* { dg-warning \"3: implicit declaration of function .gtk_widget_showall.; did you mean .gtk_widget_show_all.?\" } */\n+  /* { dg-begin-multiline-output \"\" }\n+   gtk_widget_showall (w);\n+   ^~~~~~~~~~~~~~~~~~\n+   gtk_widget_show_all\n+   { dg-end-multiline-output \"\" } */\n+\n+  /* Ensure we don't try to suggest \"gtk_widget_showall\" for subsequent\n+     corrections.  */\n+  gtk_widget_showall_ (w); /* { dg-warning \"3: implicit declaration of function .gtk_widget_showall_.; did you mean .gtk_widget_show_all.?\" } */\n+  /* { dg-begin-multiline-output \"\" }\n+   gtk_widget_showall_ (w);\n+   ^~~~~~~~~~~~~~~~~~~\n+   gtk_widget_show_all\n+   { dg-end-multiline-output \"\" } */\n+\n+  GtkWidgetShowAll (w); /* { dg-warning \"3: implicit declaration of function .GtkWidgetShowAll.; did you mean .gtk_widget_show_all.?\" } */\n+  /* { dg-begin-multiline-output \"\" }\n+   GtkWidgetShowAll (w);\n+   ^~~~~~~~~~~~~~~~\n+   gtk_widget_show_all\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+int\n+test_2 (int param)\n+{\n+  return parma * parma; /* { dg-error \"10: .parma. undeclared .first use in this function.; did you mean .param.\" } */\n+  /* { dg-begin-multiline-output \"\" }\n+   return parma * parma;\n+          ^~~~~\n+          param\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+#define MACRO(X) ((X))\n+\n+int\n+test_3 (int i)\n+{\n+  return MACRAME (i); /* { dg-warning \"10: implicit declaration of function .MACRAME.; did you mean .MACRO.?\" } */\n+  /* { dg-begin-multiline-output \"\" }\n+   return MACRAME (i);\n+          ^~~~~~~\n+          MACRO\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+#define IDENTIFIER_POINTER(X) ((X))\n+\n+int\n+test_4 (int node)\n+{\n+  return IDENTIFIER_PTR (node); /* { dg-warning \"10: implicit declaration of function .IDENTIFIER_PTR.; did you mean .IDENTIFIER_POINTER.?\" } */\n+  /* { dg-begin-multiline-output \"\" }\n+   return IDENTIFIER_PTR (node);\n+          ^~~~~~~~~~~~~~\n+          IDENTIFIER_POINTER\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+\n+int\n+test_5 (void)\n+{\n+  return __LINE_; /* { dg-error \"10: .__LINE_. undeclared .first use in this function.; did you mean .__LINE__.\" } */\n+  /* { dg-begin-multiline-output \"\" }\n+   return __LINE_;\n+          ^~~~~~~\n+          __LINE__\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+#define MAX_ITEMS 100\n+int array[MAX_ITEM]; /* { dg-error \"11: .MAX_ITEM. undeclared here .not in a function.; did you mean .MAX_ITEMS.\" } */\n+  /* { dg-begin-multiline-output \"\" }\n+ int array[MAX_ITEM];\n+           ^~~~~~~~\n+           MAX_ITEMS\n+   { dg-end-multiline-output \"\" } */\n+\n+\n+enum foo {\n+  FOO_FIRST,\n+  FOO_SECOND\n+};\n+\n+int\n+test_6 (enum foo f)\n+{\n+  switch (f)\n+    {\n+    case FOO_FURST: /* { dg-error \"10: .FOO_FURST. undeclared .first use in this function.; did you mean .FOO_FIRST.\" } */\n+      break;\n+  /* { dg-begin-multiline-output \"\" }\n+     case FOO_FURST:\n+          ^~~~~~~~~\n+          FOO_FIRST\n+   { dg-end-multiline-output \"\" } */\n+\n+    case FOO_SECCOND: /* { dg-error \"10: .FOO_SECCOND. undeclared .first use in this function.; did you mean .FOO_SECOND.\" } */\n+      break;\n+  /* { dg-begin-multiline-output \"\" }\n+     case FOO_SECCOND:\n+          ^~~~~~~~~~~\n+          FOO_SECOND\n+   { dg-end-multiline-output \"\" } */\n+\n+    default:\n+      break;\n+    }\n+}\n+\n+/* Verify that we offer names of builtins as suggestions.  */\n+\n+void\n+test_7 (int i, int j)\n+{\n+  int buffer[100];\n+  snprint (buffer, 100, \"%i of %i\", i, j); /* { dg-warning \"3: implicit declaration of function .snprint.; did you mean .snprintf..\" } */\n+  /* { dg-begin-multiline-output \"\" }\n+   snprint (buffer, 100, \"%i of %i\", i, j);\n+   ^~~~~~~\n+   snprintf\n+   { dg-end-multiline-output \"\" } */\n+}"}, {"sha": "ae22ce318ae2641fafe472c3ad1963ddf1b1393b", "filename": "gcc/testsuite/gcc.dg/spellcheck-typenames.c", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4f11c88ae761d4c618e540e07e4e32e85850d1/gcc%2Ftestsuite%2Fgcc.dg%2Fspellcheck-typenames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4f11c88ae761d4c618e540e07e4e32e85850d1/gcc%2Ftestsuite%2Fgcc.dg%2Fspellcheck-typenames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fspellcheck-typenames.c?ref=1a4f11c88ae761d4c618e540e07e4e32e85850d1", "patch": "@@ -0,0 +1,107 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fdiagnostics-show-caret\" } */\n+\n+void test_1 (signed char e);\n+\n+/* PR c/70339.  */\n+void test_2 (singed char e); /* { dg-error \"14: unknown type name .singed.; did you mean .signed.?\" } */\n+/* { dg-begin-multiline-output \"\" }\n+ void test_2 (singed char e);\n+              ^~~~~~\n+              signed\n+   { dg-end-multiline-output \"\" } */\n+\n+void test_3 (car e); /* { dg-error \"14: unknown type name .car.; did you mean .char.?\" } */\n+/* { dg-begin-multiline-output \"\" }\n+ void test_3 (car e);\n+              ^~~\n+              char\n+   { dg-end-multiline-output \"\" } */\n+\n+/* TODO: this one could be handled better.  */\n+void test_4 (signed car e); /* { dg-error \"25: before .e.\" } */\n+/* { dg-begin-multiline-output \"\" }\n+ void test_4 (signed car e);\n+                         ^\n+   { dg-end-multiline-output \"\" } */\n+\n+/* Verify that we handle misspelled typedef names.  */\n+\n+typedef struct something {} something_t;\n+\n+some_thing_t test_5; /* { dg-error \"1: unknown type name .some_thing_t.; did you mean .something_t.?\" } */\n+  /* { dg-begin-multiline-output \"\" }\n+ some_thing_t test_5;\n+ ^~~~~~~~~~~~\n+ something_t\n+   { dg-end-multiline-output \"\" } */\n+\n+/* TODO: we don't yet handle misspelled struct names.  */\n+struct some_thing test_6; /* { dg-error \"storage size of .test_6. isn't known\" } */\n+  /* { dg-begin-multiline-output \"\" }\n+ struct some_thing test_6;\n+                   ^~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+typedef long int64_t;\n+int64 i; /* { dg-error \"unknown type name 'int64'; did you mean 'int64_t'?\" } */\n+/* { dg-begin-multiline-output \"\" }\n+ int64 i;\n+ ^~~~~\n+ int64_t\n+   { dg-end-multiline-output \"\" } */\n+\n+/* Verify that gcc doesn't offer nonsensical suggestions.  */\n+\n+nonsensical_suggestion_t var; /* { dg-bogus \"did you mean\" } */\n+/* { dg-error \"unknown type name\" \"\" { target { *-*-* } } 56 } */\n+/* { dg-begin-multiline-output \"\" }\n+ nonsensical_suggestion_t var;\n+ ^~~~~~~~~~~~~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+\n+/* In the following, we should suggest inserting \"struct\" (rather\n+   than \"did you mean 'float'\") and provide a fixit hint.  */\n+struct foo_t {\n+  int i;\n+};\n+foo_t *foo_ptr; /* { dg-error \"1: unknown type name .foo_t.; use .struct. keyword to refer to the type\" } */\n+/* { dg-begin-multiline-output \"\" }\n+ foo_t *foo_ptr;\n+ ^~~~~\n+ struct\n+   { dg-end-multiline-output \"\" } */\n+\n+\n+/* Similarly for unions.  */\n+union bar_t {\n+  int i;\n+  char j;\n+};\n+bar_t *bar_ptr; /* { dg-error \"1: unknown type name .bar_t.; use .union. keyword to refer to the type\" } */\n+/* { dg-begin-multiline-output \"\" }\n+ bar_t *bar_ptr;\n+ ^~~~~\n+ union\n+   { dg-end-multiline-output \"\" } */\n+\n+\n+/* Similarly for enums.  */\n+enum baz {\n+  BAZ_FIRST,\n+  BAZ_SECOND\n+};\n+baz value; /* { dg-error \"1: unknown type name .baz.; use .enum. keyword to refer to the type\" } */\n+/* { dg-begin-multiline-output \"\" }\n+ baz value;\n+ ^~~\n+ enum\n+   { dg-end-multiline-output \"\" } */\n+\n+/* TODO: it would be better to detect the \"singed\" vs \"signed\" typo here.  */\n+singed char ch; /* { dg-error \"8: before .char.\" } */\n+/* { dg-begin-multiline-output \"\" }\n+ singed char ch;\n+        ^~~~\n+   { dg-end-multiline-output \"\" } */"}]}