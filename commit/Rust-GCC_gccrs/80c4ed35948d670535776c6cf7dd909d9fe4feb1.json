{"sha": "80c4ed35948d670535776c6cf7dd909d9fe4feb1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODBjNGVkMzU5NDhkNjcwNTM1Nzc2YzZjZjdkZDkwOWQ5ZmU0ZmViMQ==", "commit": {"author": {"name": "Andrew Pinski", "email": "pinskia@physics.uc.edu", "date": "2005-03-08T00:40:33Z"}, "committer": {"name": "Andrew Pinski", "email": "pinskia@gcc.gnu.org", "date": "2005-03-08T00:40:33Z"}, "message": "re PR tree-optimization/17671 (PHI-OPT is not smart enough)\n\n2005-03-06  Andrew Pinski  <pinskia@physics.uc.edu>\n\n\tPR tree-opt/17671\n\t* tree-ssa-phiopt.c (tree_ssa_phiopt): Rewrite so we base the\n\tbbs on the COND_EXPR instead of the PHI_NODEs.\n\t(candidate_bb_for_phi_optimization): Remove.\n\t(replace_phi_with_stmt): Rename to ...\n\t(replace_phi_edge_with_variable): this and change so that we\n\treplace the phi argument instead of removing the PHI.\n\t(conditional_replacement): Change so we deal with PHI with more\n\tthan two arguments.\n\t(value_replacement): Likewise.\n\t(abs_replacement): Likewise.\n\n2005-03-06  Andrew Pinski  <pinskia@physics.uc.edu>\n\n\tPR tree-opt/17671\n\t* gcc.dg/tree-ssa/phi-opt-[1-4].c: New tests.\n\nFrom-SVN: r96067", "tree": {"sha": "7ae22cec14c557ac1e465d45ea8bdddf4c1774dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ae22cec14c557ac1e465d45ea8bdddf4c1774dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/80c4ed35948d670535776c6cf7dd909d9fe4feb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80c4ed35948d670535776c6cf7dd909d9fe4feb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80c4ed35948d670535776c6cf7dd909d9fe4feb1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80c4ed35948d670535776c6cf7dd909d9fe4feb1/comments", "author": null, "committer": null, "parents": [{"sha": "64022b5db4e10421bb18b64aed8e67c15ac18cee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64022b5db4e10421bb18b64aed8e67c15ac18cee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64022b5db4e10421bb18b64aed8e67c15ac18cee"}], "stats": {"total": 397, "additions": 245, "deletions": 152}, "files": [{"sha": "94a9dd9c72bf3d63ed073a7bd3c823066f3bfb0a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80c4ed35948d670535776c6cf7dd909d9fe4feb1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80c4ed35948d670535776c6cf7dd909d9fe4feb1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=80c4ed35948d670535776c6cf7dd909d9fe4feb1", "patch": "@@ -1,3 +1,17 @@\n+2005-03-06  Andrew Pinski  <pinskia@physics.uc.edu>\n+\t\n+\tPR tree-opt/17671\n+\t* tree-ssa-phiopt.c (tree_ssa_phiopt): Rewrite so we base the\n+\tbbs on the COND_EXPR instead of the PHI_NODEs.\n+\t(candidate_bb_for_phi_optimization): Remove.\n+\t(replace_phi_with_stmt): Rename to ...\n+\t(replace_phi_edge_with_variable): this and change so that we\n+\treplace the phi argument instead of removing the PHI.\n+\t(conditional_replacement): Change so we deal with PHI with more\n+\tthan two arguments.\n+\t(value_replacement): Likewise.\n+\t(abs_replacement): Likewise.\n+\n 2005-03-07  Aldy Hernandez  <aldyh@redhat.com>\n \n \t* config/rs6000/rs6000-protos.h: Rename output_e500_flip_eq_bit to"}, {"sha": "c8b47778cd8ca2abeceaead53f9cbd58ee20e979", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80c4ed35948d670535776c6cf7dd909d9fe4feb1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80c4ed35948d670535776c6cf7dd909d9fe4feb1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=80c4ed35948d670535776c6cf7dd909d9fe4feb1", "patch": "@@ -1,3 +1,8 @@\n+2005-03-06  Andrew Pinski  <pinskia@physics.uc.edu>\n+\n+\tPR tree-opt/17671\n+\t* gcc.dg/tree-ssa/phi-opt-[1-4].c: New tests.\n+\n 2005-03-07  Mark Mitchell  <mark@codesourcery.com>\n \n \t* g++.dg/warn/Wnvdtor.C: New test."}, {"sha": "53929864c00d68e44aad2373889e49f04384f540", "filename": "gcc/testsuite/gcc.dg/tree-ssa/phi-opt-1.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80c4ed35948d670535776c6cf7dd909d9fe4feb1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fphi-opt-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80c4ed35948d670535776c6cf7dd909d9fe4feb1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fphi-opt-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fphi-opt-1.c?ref=80c4ed35948d670535776c6cf7dd909d9fe4feb1", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -fdump-tree-optimized\" } */\n+\n+int f(int a, int b, int c)\n+{\n+  if (c == 0) goto temp;\n+  if (a == 0)\n+   return 0;\n+temp:\n+  if (a == b)\n+   return a;\n+ return a;\n+}\n+\n+/* There should be no ifs as the PHI arguments, we did not\n+   optimize this before because PHI-OPT did not look at \n+   PHIs which have more than two arguments.  */\n+/* { dg-final { scan-tree-dump-times \"if\" 0 \"optimized\"} } */\n+"}, {"sha": "93a4b66cb5d658d903c2ba0610c5968e18cbdf56", "filename": "gcc/testsuite/gcc.dg/tree-ssa/phi-opt-2.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80c4ed35948d670535776c6cf7dd909d9fe4feb1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fphi-opt-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80c4ed35948d670535776c6cf7dd909d9fe4feb1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fphi-opt-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fphi-opt-2.c?ref=80c4ed35948d670535776c6cf7dd909d9fe4feb1", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -fdump-tree-optimized\" } */\n+\n+_Bool f1(_Bool a, _Bool b)\n+{\n+  if (a)\n+   {\n+     if (b)\n+      return 1;\n+     else\n+      return 0;\n+   }\n+  return 0;\n+}\n+\n+\n+/* There should be only one if, the outer one; the inner one\n+   should have been changed to straight line code with the\n+   value of b (except that we don't fold ! (b != 0) into b\n+   which can be fixed in a different patch).  */\n+/* { dg-final { scan-tree-dump-times \"if\" 1 \"optimized\"} } */"}, {"sha": "c11b2c64894a3b95252685fd585bc34ad205e2b0", "filename": "gcc/testsuite/gcc.dg/tree-ssa/phi-opt-3.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80c4ed35948d670535776c6cf7dd909d9fe4feb1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fphi-opt-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80c4ed35948d670535776c6cf7dd909d9fe4feb1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fphi-opt-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fphi-opt-3.c?ref=80c4ed35948d670535776c6cf7dd909d9fe4feb1", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -fdump-tree-optimized\" } */\n+\n+int f(int a, int b)\n+{\n+  if (a == 0)\n+   return 0;\n+  if (a != b)\n+   return a;\n+ return a;\n+}\n+\n+/* There should be no ifs as the PHI arguments, we did not\n+   optimize this before because PHI-OPT did not look at \n+   PHIs which have more than two arguments.  */\n+/* { dg-final { scan-tree-dump-times \"if\" 0 \"optimized\"} } */\n+"}, {"sha": "45563a87276755a887ba75266a7729b208ccc870", "filename": "gcc/testsuite/gcc.dg/tree-ssa/phi-opt-4.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80c4ed35948d670535776c6cf7dd909d9fe4feb1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fphi-opt-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80c4ed35948d670535776c6cf7dd909d9fe4feb1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fphi-opt-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fphi-opt-4.c?ref=80c4ed35948d670535776c6cf7dd909d9fe4feb1", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -fdump-tree-optimized\" } */\n+\n+_Bool t();\n+_Bool t1();\n+\n+_Bool f1()\n+{\n+  return t() && t1();\n+}\n+\n+/* There should be only one if, the outer one; the inner one\n+   should have been changed to straight line code with the\n+   value of b (except that we don't fold ! (b != 0) into b\n+   which means that we miss a sib calling opportunity).  */\n+/* { dg-final { scan-tree-dump-times \"if \" 1 \"optimized\"} } */\n+"}, {"sha": "d915b4c5950eb9d7b895d506423ef3dfd5b134d2", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 152, "deletions": 152, "changes": 304, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80c4ed35948d670535776c6cf7dd909d9fe4feb1/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80c4ed35948d670535776c6cf7dd909d9fe4feb1/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=80c4ed35948d670535776c6cf7dd909d9fe4feb1", "patch": "@@ -37,14 +37,14 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"langhooks.h\"\n \n static void tree_ssa_phiopt (void);\n-static bool conditional_replacement (basic_block, tree, tree, tree);\n-static bool value_replacement (basic_block, tree, tree, tree);\n-static bool abs_replacement (basic_block, tree, tree, tree);\n-static void replace_phi_with_stmt (block_stmt_iterator, basic_block,\n-\t\t\t\t   basic_block, tree, tree);\n-static bool candidate_bb_for_phi_optimization (basic_block,\n-\t\t\t\t\t       basic_block *,\n-\t\t\t\t\t       basic_block *);\n+static bool conditional_replacement (basic_block, basic_block, basic_block,\n+\t\t\t\t     edge, edge, tree, tree, tree);\n+static bool value_replacement (basic_block, basic_block, basic_block,\n+\t\t\t       edge, edge, tree, tree, tree);\n+static bool abs_replacement (basic_block, basic_block, basic_block,\n+\t\t\t     edge, edge, tree, tree, tree);\n+static void replace_phi_edge_with_variable (basic_block, basic_block, edge,\n+\t\t\t\t\t    tree, tree);\n \n /* This pass eliminates PHI nodes which can be trivially implemented as\n    an assignment from a conditional expression.  i.e. if we have something\n@@ -112,24 +112,85 @@ tree_ssa_phiopt (void)\n   basic_block bb;\n   bool removed_phis = false;\n \n-  /* Search every basic block for PHI nodes we may be able to optimize.  */\n-  FOR_EACH_BB (bb)\n+  /* Search every basic block for COND_EXPR we may be able to optimize in reverse\n+     order so we can find more.  */\n+  FOR_EACH_BB_REVERSE (bb)\n     {\n-      tree arg0, arg1, phi;\n+      tree cond_expr;\n+      tree phi;\n+      basic_block bb1, bb2;\n+      edge e1, e2;\n+      \n+      cond_expr = last_stmt (bb);\n+      /* Check to see if the last statement is a COND_EXPR */\n+      if (!cond_expr\n+          || TREE_CODE (cond_expr) != COND_EXPR)\n+        continue;\n+      \n+      e1 = EDGE_SUCC (bb, 0);\n+      bb1 = e1->dest;\n+      e2 = EDGE_SUCC (bb, 1);\n+      bb2 = e2->dest;\n+      \n+      /* We cannot do the optimization on abnormal edges.  */\n+      if ((e1->flags & EDGE_ABNORMAL) != 0\n+          || (e2->flags & EDGE_ABNORMAL) != 0)\n+       continue;\n+      \n+      /* If either bb1's succ or bb2 or bb2's succ is non NULL.  */\n+      if (EDGE_COUNT (bb1->succs) < 1\n+          || bb2 == NULL\n+\t  || EDGE_COUNT (bb2->succs) < 1)\n+        continue;\n+      \n+      /* Find the bb which is the fall through to the other.  */\n+      if (EDGE_SUCC (bb1, 0)->dest == bb2)\n+        ;\n+      else if (EDGE_SUCC (bb2, 0)->dest == bb1)\n+        {\n+\t  basic_block bb_tmp = bb1;\n+\t  edge e_tmp = e1;\n+\t  bb1 = bb2;\n+\t  bb2 = bb_tmp;\n+\t  e1 = e2;\n+\t  e2 = e_tmp;\n+\t}\n+      else\n+        continue;\n+      \n+      e1 = EDGE_SUCC (bb1, 0);\n+      \n+      /* Make sure that bb1 is just a fall through.  */\n+      if (EDGE_COUNT (bb1->succs) > 1\n+\t  || (e1->flags & EDGE_FALLTHRU) == 0)\n+        continue;\n+\t\n+      /* Also make that bb1 only have one pred and it is bb. */\n+      if (EDGE_COUNT (bb1->preds) > 1\n+          || EDGE_PRED (bb1, 0)->src != bb)\n+\tcontinue;\n+      \n+      phi = phi_nodes (bb2);\n \n-      /* We're searching for blocks with one PHI node which has two\n-\t arguments.  */\n-      phi = phi_nodes (bb);\n-      if (phi && PHI_CHAIN (phi) == NULL\n-\t  && PHI_NUM_ARGS (phi) == 2)\n+      /* Check to make sure that there is only one PHI node.\n+         TODO: we could do it with more than one iff the other PHI nodes\n+\t have the same elements for these two edges.  */\n+      if (phi && PHI_CHAIN (phi) == NULL)\n \t{\n-\t  arg0 = PHI_ARG_DEF (phi, 0);\n-\t  arg1 = PHI_ARG_DEF (phi, 1);\n+\t  tree arg0 = NULL, arg1 = NULL;\n+\t  int i;\n+\t  \n+\t  arg0 = PHI_ARG_DEF_TREE (phi, e1->dest_idx);\n+\t  arg1 = PHI_ARG_DEF_TREE (phi, e2->dest_idx);\n+\t   \t  \n+\t  /* We know something is wrong if we cannot find the edges in the PHI\n+\t     node.  */\n+\t  gcc_assert (arg0 != NULL && arg1 != NULL);\n \t    \n \t  /* Do the replacement of conditional if it can be done.  */\n-\t    if (conditional_replacement (bb, phi, arg0, arg1)\n-\t\t|| value_replacement (bb, phi, arg0, arg1)\n-\t\t|| abs_replacement (bb, phi, arg0, arg1))\n+\t    if (conditional_replacement (bb, bb1, bb2, e1, e2, phi, arg0, arg1)\n+\t\t|| value_replacement (bb, bb1, bb2, e1, e2, phi, arg0, arg1)\n+\t\t|| abs_replacement (bb, bb1, bb2, e1, e2, phi, arg0, arg1))\n \t      {\n \t\t/* We have done the replacement so we need to rebuild the\n \t\t   cfg when this pass is complete.  */\n@@ -159,89 +220,21 @@ empty_block_p (basic_block bb)\n   return true;\n }\n \n-/* BB is a basic block which has only one PHI node with precisely two\n-   arguments.\n-\n-   Examine both of BB's predecessors to see if one ends with a \n-   COND_EXPR and the other is a successor of the COND_EXPR.  If so, then\n-   we may be able to optimize PHI nodes at the start of BB. \n-\n-   If so, mark store the block with the COND_EXPR into COND_BLOCK_P\n-   and the other block into OTHER_BLOCK_P and return true, otherwise\n-   return false.  */\n-\n-static bool\n-candidate_bb_for_phi_optimization (basic_block bb,\n-\t\t\t\t   basic_block *cond_block_p,\n-\t\t\t\t   basic_block *other_block_p)\n-{\n-  tree last0, last1;\n-  basic_block cond_block, other_block;\n-\n-  /* One of the alternatives must come from a block ending with\n-     a COND_EXPR.  */\n-  last0 = last_stmt (EDGE_PRED (bb, 0)->src);\n-  last1 = last_stmt (EDGE_PRED (bb, 1)->src);\n-  if (last0 && TREE_CODE (last0) == COND_EXPR)\n-    {\n-      cond_block = EDGE_PRED (bb, 0)->src;\n-      other_block = EDGE_PRED (bb, 1)->src;\n-    }\n-  else if (last1 && TREE_CODE (last1) == COND_EXPR)\n-    {\n-      other_block = EDGE_PRED (bb, 0)->src;\n-      cond_block = EDGE_PRED (bb, 1)->src;\n-    }\n-  else\n-    return false;\n-  \n-  /* COND_BLOCK must have precisely two successors.  We indirectly\n-     verify that those successors are BB and OTHER_BLOCK.  */\n-  if (EDGE_COUNT (cond_block->succs) != 2\n-      || (EDGE_SUCC (cond_block, 0)->flags & EDGE_ABNORMAL) != 0\n-      || (EDGE_SUCC (cond_block, 1)->flags & EDGE_ABNORMAL) != 0)\n-    return false;\n-  \n-  /* OTHER_BLOCK must have a single predecessor which is COND_BLOCK,\n-     OTHER_BLOCK must have a single successor which is BB and\n-     OTHER_BLOCK must have no PHI nodes.  */\n-  if (EDGE_COUNT (other_block->preds) != 1\n-      || EDGE_PRED (other_block, 0)->src != cond_block\n-      || EDGE_COUNT (other_block->succs) != 1\n-      || EDGE_SUCC (other_block, 0)->dest != bb\n-      || phi_nodes (other_block))\n-    return false;\n-  \n-  *cond_block_p = cond_block;\n-  *other_block_p = other_block;\n-  /* Everything looks OK.  */\n-  return true;\n-}\n-\n-/* Replace PHI in block BB with statement NEW.  NEW is inserted after\n-   BSI.  Remove the edge from COND_BLOCK which does not lead to BB (COND_BLOCK\n+/* Replace PHI node element whoes edge is E in block BB with variable NEW.\n+   Remove the edge from COND_BLOCK which does not lead to BB (COND_BLOCK\n    is known to have two edges, one of which must reach BB).  */\n \n static void\n-replace_phi_with_stmt (block_stmt_iterator bsi, basic_block bb,\n-\t\t       basic_block cond_block, tree phi, tree new)\n+replace_phi_edge_with_variable (basic_block cond_block, basic_block bb,\n+\t\t\t\tedge e, tree phi, tree new)\n {\n   basic_block block_to_remove;\n+  int i;\n+  block_stmt_iterator bsi;\n+\n+  /* Change the PHI argument to new. */\n+  PHI_ARG_DEF_TREE (phi, e->dest_idx) = new;\n \n-  /* Insert our new statement at the head of our block.  */\n-  bsi_insert_after (&bsi, new, BSI_NEW_STMT);\n-  \n-  /* Register our new statement as the defining statement for\n-     the result.  */\n-  SSA_NAME_DEF_STMT (PHI_RESULT (phi)) = new;\n-  \n-  /* Remove the now useless PHI node. \n-  \n-     We do not want to use remove_phi_node since that releases the\n-     SSA_NAME as well and the SSA_NAME is still being used.  */\n-  release_phi_node (phi);\n-  bb_ann (bb)->phi_nodes = NULL;\n-  \n   /* Remove the empty basic block.  */\n   if (EDGE_SUCC (cond_block, 0)->dest == bb)\n     {\n@@ -278,16 +271,17 @@ replace_phi_with_stmt (block_stmt_iterator bsi, basic_block bb,\n     is argument 0 from PHI.  Likewise for ARG1.  */\n \n static bool\n-conditional_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n+conditional_replacement (basic_block cond_bb, basic_block middle_bb,\n+\t\t\t basic_block phi_bb, edge e0, edge e1, tree phi,\n+\t\t\t tree arg0, tree arg1)\n {\n   tree result;\n   tree old_result = NULL;\n-  basic_block other_block = NULL;\n-  basic_block cond_block = NULL;\n   tree new, cond;\n   block_stmt_iterator bsi;\n   edge true_edge, false_edge;\n   tree new_var = NULL;\n+  tree new_var1;\n \n   /* The PHI arguments have the constants 0 and 1, then convert\n      it to the conditional.  */\n@@ -297,16 +291,15 @@ conditional_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n   else\n     return false;\n   \n-  if (!candidate_bb_for_phi_optimization (bb, &cond_block, &other_block)\n-      || !empty_block_p (other_block))\n+  if (!empty_block_p (middle_bb))\n     return false;\n \t\t\t\t\t\t\t\t\t\t\n   /* If the condition is not a naked SSA_NAME and its type does not\n      match the type of the result, then we have to create a new\n      variable to optimize this case as it would likely create\n      non-gimple code when the condition was converted to the\n      result's type.  */\n-  cond = COND_EXPR_COND (last_stmt (cond_block));\n+  cond = COND_EXPR_COND (last_stmt (cond_bb));\n   result = PHI_RESULT (phi);\n   if (TREE_CODE (cond) != SSA_NAME\n       && !lang_hooks.types_compatible_p (TREE_TYPE (cond), TREE_TYPE (result)))\n@@ -324,10 +317,12 @@ conditional_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n   \n   /* We need to know which is the true edge and which is the false\n      edge so that we know when to invert the condition below.  */\n-  extract_true_false_edges_from_block (cond_block, &true_edge, &false_edge);\n+  extract_true_false_edges_from_block (cond_bb, &true_edge, &false_edge);\n       \n-  /* Insert our new statement at the head of our block.  */\n-  bsi = bsi_after_labels (bb);\n+  /* Insert our new statement at the end of condtional block before the\n+     COND_EXPR.  */\n+  bsi = bsi_last (cond_bb);\n+  bsi_insert_before (&bsi, build_empty_stmt (), BSI_NEW_STMT);\n   \n   if (old_result)\n     {\n@@ -342,6 +337,9 @@ conditional_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n       new1 = build (MODIFY_EXPR, TREE_TYPE (old_result), new_var, new1);\n       bsi_insert_after (&bsi, new1, BSI_NEW_STMT);\n     }\n+    \n+  new_var1 = duplicate_ssa_name (PHI_RESULT (phi), NULL);\n+  \n   \n   /* At this point we know we have a COND_EXPR with two successors.\n      One successor is BB, the other successor is an empty block which\n@@ -360,13 +358,12 @@ conditional_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n      false edge as the value zero.  Note that those conditions are not\n      the same since only one of the outgoing edges from the COND_EXPR\n      will directly reach BB and thus be associated with an argument.  */\n-  if ((PHI_ARG_EDGE (phi, 0) == true_edge && integer_onep (arg0))\n-      || (PHI_ARG_EDGE (phi, 0) == false_edge && integer_zerop (arg0))\n-      || (PHI_ARG_EDGE (phi, 1) == true_edge && integer_onep (arg1))\n-      || (PHI_ARG_EDGE (phi, 1) == false_edge && integer_zerop (arg1)))\n+  if ((e0 == true_edge && integer_onep (arg0))\n+      || (e0 == false_edge && integer_zerop (arg0))\n+      || (e1 == true_edge && integer_onep (arg1))\n+      || (e1 == false_edge && integer_zerop (arg1)))\n     {\n-      new = build (MODIFY_EXPR, TREE_TYPE (PHI_RESULT (phi)),\n-\t\t    PHI_RESULT (phi), cond);\n+      new = build (MODIFY_EXPR, TREE_TYPE (new_var1), new_var1, cond);\n     }\n   else\n     {\n@@ -376,7 +373,10 @@ conditional_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n       /* If what we get back is a conditional expression, there is no\n \t  way that it can be gimple.  */\n       if (TREE_CODE (cond) == COND_EXPR)\n-\treturn false; \n+\t{\n+\t  release_ssa_name (new_var1);\n+\t  return false; \n+\t}\n \n       /* If what we get back is not gimple try to create it as gimple by\n \t using a temporary variable.  */\n@@ -392,13 +392,19 @@ conditional_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n       \n       if (TREE_CODE (cond) == TRUTH_NOT_EXPR\n \t  &&  !is_gimple_val (TREE_OPERAND (cond, 0)))\n-\treturn false;\n+\t{\n+\t  release_ssa_name (new_var1);\n+\t  return false;\n+\t}\n \n-      new = build (MODIFY_EXPR, TREE_TYPE (PHI_RESULT (phi)),\n-\t\t    PHI_RESULT (phi), cond);\n+      new = build (MODIFY_EXPR, TREE_TYPE (new_var1), new_var1, cond);\n     }\n   \n-  replace_phi_with_stmt (bsi, bb, cond_block, phi, new);\n+  bsi_insert_after (&bsi, new, BSI_NEW_STMT);\n+  \n+  SSA_NAME_DEF_STMT (new_var1) = new;\n+  \n+  replace_phi_edge_with_variable (cond_bb, phi_bb, e1, phi, new_var1);\n \n   /* Note that we optimized this PHI.  */\n   return true;\n@@ -411,24 +417,23 @@ conditional_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n     is argument 0 from the PHI.  Likewise for ARG1.  */\n \n static bool\n-value_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n+value_replacement (basic_block cond_bb, basic_block middle_bb,\n+\t\t   basic_block phi_bb, edge e0, edge e1, tree phi,\n+\t\t   tree arg0, tree arg1)\n {\n   tree result;\n-  basic_block other_block = NULL;\n-  basic_block cond_block = NULL;\n-  tree new, cond;\n+  tree cond;\n   edge true_edge, false_edge;\n \n   /* If the type says honor signed zeros we cannot do this\n      optimization.  */\n   if (HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (arg1))))\n     return false;\n \n-  if (!candidate_bb_for_phi_optimization (bb, &cond_block, &other_block)\n-      || !empty_block_p (other_block))\n+  if (!empty_block_p (middle_bb))\n     return false;\n \n-  cond = COND_EXPR_COND (last_stmt (cond_block));\n+  cond = COND_EXPR_COND (last_stmt (cond_bb));\n   result = PHI_RESULT (phi);\n \n   /* This transformation is only valid for equality comparisons.  */\n@@ -437,7 +442,7 @@ value_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n \n   /* We need to know which is the true edge and which is the false\n       edge so that we know if have abs or negative abs.  */\n-  extract_true_false_edges_from_block (cond_block, &true_edge, &false_edge);\n+  extract_true_false_edges_from_block (cond_bb, &true_edge, &false_edge);\n \n   /* At this point we know we have a COND_EXPR with two successors.\n      One successor is BB, the other successor is an empty block which\n@@ -467,20 +472,17 @@ value_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n \t OTHER_BLOCK).  If that is the case, then we want the single outgoing\n \t edge from OTHER_BLOCK which reaches BB and represents the desired\n \t path from COND_BLOCK.  */\n-      if (e->dest == other_block)\n+      if (e->dest == middle_bb)\n \te = EDGE_SUCC (e->dest, 0);\n \n       /* Now we know the incoming edge to BB that has the argument for the\n \t RHS of our new assignment statement.  */\n-      if (PHI_ARG_EDGE (phi, 0) == e)\n+      if (e0 == e)\n \targ = arg0;\n       else\n \targ = arg1;\n \n-      /* Build the new assignment.  */\n-      new = build (MODIFY_EXPR, TREE_TYPE (result), result, arg);\n-\n-      replace_phi_with_stmt (bsi_after_labels (bb), bb, cond_block, phi, new);\n+      replace_phi_edge_with_variable (cond_bb, phi_bb, e1, phi, arg);\n \n       /* Note that we optimized this PHI.  */\n       return true;\n@@ -492,13 +494,14 @@ value_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n     replacement.  Return true if the replacement is done.  Otherwise return\n     false.\n     bb is the basic block where the replacement is going to be done on.  arg0\n-    is argument 0 from the phi.  Likewise for arg1.  */\n+    is argument 0 from the phi.  Likewise for arg1.   */\n+\n static bool\n-abs_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n+abs_replacement (basic_block cond_bb, basic_block middle_bb,\n+\t\t basic_block phi_bb, edge e0 ATTRIBUTE_UNUSED, edge e1, tree phi,\n+\t\t tree arg0, tree arg1)\n {\n   tree result;\n-  basic_block other_block = NULL;\n-  basic_block cond_block = NULL;\n   tree new, cond;\n   block_stmt_iterator bsi;\n   edge true_edge, false_edge;\n@@ -513,12 +516,9 @@ abs_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n   if (HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (arg1))))\n     return false;\n \n-  if (!candidate_bb_for_phi_optimization (bb, &cond_block, &other_block))\n-    return false;\n-\n   /* OTHER_BLOCK must have only one executable statement which must have the\n      form arg0 = -arg1 or arg1 = -arg0.  */\n-  bsi = bsi_start (other_block);\n+  bsi = bsi_start (middle_bb);\n   while (!bsi_end_p (bsi))\n     {\n       tree stmt = bsi_stmt (bsi);\n@@ -570,7 +570,7 @@ abs_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n   if (assign == NULL)\n     return false;\n \n-  cond = COND_EXPR_COND (last_stmt (cond_block));\n+  cond = COND_EXPR_COND (last_stmt (cond_bb));\n   result = PHI_RESULT (phi);\n \n   /* Only relationals comparing arg[01] against zero are interesting.  */\n@@ -592,7 +592,7 @@ abs_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n \n   /* We need to know which is the true edge and which is the false\n      edge so that we know if have abs or negative abs.  */\n-  extract_true_false_edges_from_block (cond_block, &true_edge, &false_edge);\n+  extract_true_false_edges_from_block (cond_bb, &true_edge, &false_edge);\n \n   /* For GT_EXPR/GE_EXPR, if the true edge goes to OTHER_BLOCK, then we\n      will need to negate the result.  Similarly for LT_EXPR/LE_EXPR if\n@@ -602,10 +602,12 @@ abs_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n   else\n     e = false_edge;\n   \n-  if (e->dest == other_block)\n+  if (e->dest == middle_bb)\n     negate = true;\n   else\n     negate = false;\n+    \n+  result = duplicate_ssa_name (result, NULL);\n   \n   if (negate)\n     lhs = make_rename_temp (TREE_TYPE (result), NULL);\n@@ -616,26 +618,24 @@ abs_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n   new = build (MODIFY_EXPR, TREE_TYPE (lhs),\n                lhs, build1 (ABS_EXPR, TREE_TYPE (lhs), rhs));\n \n-  replace_phi_with_stmt (bsi_after_labels (bb), bb, cond_block, phi, new);\n+  bsi = bsi_last (cond_bb);\n+  bsi_insert_before (&bsi, new, BSI_NEW_STMT);\n \n   if (negate)\n     {\n \n       /* Get the right BSI.  We want to insert after the recently \n \t added ABS_EXPR statement (which we know is the first statement\n \t in the block.  */\n-      bsi = bsi_start (bb);\n-      bsi_next (&bsi);\n       new = build (MODIFY_EXPR, TREE_TYPE (result),\n                    result, build1 (NEGATE_EXPR, TREE_TYPE (lhs), lhs));\n \n       bsi_insert_after (&bsi, new, BSI_NEW_STMT);\n-\n-      /* Register the new statement as defining the temporary -- this is\n-\t normally done by replace_phi_with_stmt, but the link will be wrong\n-\t if we had to negate the resulting value.  */\n-      SSA_NAME_DEF_STMT (result) = new;\n+      \n     }\n+    \n+  SSA_NAME_DEF_STMT (result) = new;\n+  replace_phi_edge_with_variable (cond_bb, phi_bb, e1, phi, result);\n \n   /* Note that we optimized this PHI.  */\n   return true;\n@@ -665,7 +665,7 @@ struct tree_opt_pass pass_phiopt =\n   0,\t\t\t\t\t/* todo_flags_start */\n   TODO_cleanup_cfg | TODO_dump_func | TODO_ggc_collect\t/* todo_flags_finish */\n     | TODO_verify_ssa | TODO_rename_vars\n-    | TODO_verify_flow,\n+    | TODO_verify_flow | TODO_verify_stmts,\n   0\t\t\t\t\t/* letter */\n };\n \t\t\t\t\t\t\t\t\t\t\t\t"}]}