{"sha": "550d138775ddd05e61d684a9e6407e422e2ee5b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTUwZDEzODc3NWRkZDA1ZTYxZDY4NGE5ZTY0MDdlNDIyZTJlZTViMw==", "commit": {"author": {"name": "Geoffrey Keating", "email": "geoffk@apple.com", "date": "2004-01-06T22:51:00Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2004-01-06T22:51:00Z"}, "message": "emit-rtl.c (gen_lowpart_common): Use simplify_gen_subreg for constants.\n\n\t* emit-rtl.c (gen_lowpart_common): Use simplify_gen_subreg\n\tfor constants.\n\t(constant_subword): Delete.\n\t* rtl.h (constant_subword): Delete prototype.\n\t(immed_double_const): Is not in varasm.c.\n\t* simplify-rtx.c (simplify_immed_subreg): New.\n\t(simplify_subreg): Use simplify_immed_subreg.\n\nFrom-SVN: r75487", "tree": {"sha": "28233b540fd6d35965e896129ee05cfa74b5ae05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28233b540fd6d35965e896129ee05cfa74b5ae05"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/550d138775ddd05e61d684a9e6407e422e2ee5b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/550d138775ddd05e61d684a9e6407e422e2ee5b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/550d138775ddd05e61d684a9e6407e422e2ee5b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/550d138775ddd05e61d684a9e6407e422e2ee5b3/comments", "author": {"login": "geoffk01", "id": 31905243, "node_id": "MDQ6VXNlcjMxOTA1MjQz", "avatar_url": "https://avatars.githubusercontent.com/u/31905243?v=4", "gravatar_id": "", "url": "https://api.github.com/users/geoffk01", "html_url": "https://github.com/geoffk01", "followers_url": "https://api.github.com/users/geoffk01/followers", "following_url": "https://api.github.com/users/geoffk01/following{/other_user}", "gists_url": "https://api.github.com/users/geoffk01/gists{/gist_id}", "starred_url": "https://api.github.com/users/geoffk01/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/geoffk01/subscriptions", "organizations_url": "https://api.github.com/users/geoffk01/orgs", "repos_url": "https://api.github.com/users/geoffk01/repos", "events_url": "https://api.github.com/users/geoffk01/events{/privacy}", "received_events_url": "https://api.github.com/users/geoffk01/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fed2b316853250918337788d0f7cdf9632ffd8fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fed2b316853250918337788d0f7cdf9632ffd8fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fed2b316853250918337788d0f7cdf9632ffd8fc"}], "stats": {"total": 813, "additions": 301, "deletions": 512}, "files": [{"sha": "89baf13d193d9ae63e9a7b8560f8dc6f07e1b54b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/550d138775ddd05e61d684a9e6407e422e2ee5b3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/550d138775ddd05e61d684a9e6407e422e2ee5b3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=550d138775ddd05e61d684a9e6407e422e2ee5b3", "patch": "@@ -5,6 +5,14 @@\n \n 2004-01-06  Geoffrey Keating  <geoffk@apple.com>\n \n+\t* emit-rtl.c (gen_lowpart_common): Use simplify_gen_subreg\n+\tfor constants.\n+\t(constant_subword): Delete.\n+\t* rtl.h (constant_subword): Delete prototype.\n+\t(immed_double_const): Is not in varasm.c.\n+\t* simplify-rtx.c (simplify_immed_subreg): New.\n+\t(simplify_subreg): Use simplify_immed_subreg.\n+\n \t* config/rs6000/rs6000.md (floatsitf2): Use expand_float rather\n \tthan trying to generate RTL directly.\n \t(fix_trunctfsi2): Use expand_fix rather than trying to generate"}, {"sha": "92b86dbca82dca17356e9d550f02397c83584499", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 25, "deletions": 308, "changes": 333, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/550d138775ddd05e61d684a9e6407e422e2ee5b3/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/550d138775ddd05e61d684a9e6407e422e2ee5b3/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=550d138775ddd05e61d684a9e6407e422e2ee5b3", "patch": "@@ -1050,24 +1050,36 @@ rtx\n gen_lowpart_common (enum machine_mode mode, rtx x)\n {\n   int msize = GET_MODE_SIZE (mode);\n-  int xsize = GET_MODE_SIZE (GET_MODE (x));\n+  int xsize;\n   int offset = 0;\n+  enum machine_mode innermode;\n+\n+  /* Unfortunately, this routine doesn't take a parameter for the mode of X,\n+     so we have to make one up.  Yuk.  */\n+  innermode = GET_MODE (x);\n+  if (GET_CODE (x) == CONST_INT && msize <= HOST_BITS_PER_WIDE_INT)\n+    innermode = mode_for_size (HOST_BITS_PER_WIDE_INT, MODE_INT, 0);\n+  else if (innermode == VOIDmode)\n+    innermode = mode_for_size (HOST_BITS_PER_WIDE_INT * 2, MODE_INT, 0);\n+  \n+  xsize = GET_MODE_SIZE (innermode);\n+\n+  if (innermode == VOIDmode || innermode == BLKmode)\n+    abort ();\n \n-  if (GET_MODE (x) == mode)\n+  if (innermode == mode)\n     return x;\n \n   /* MODE must occupy no more words than the mode of X.  */\n-  if (GET_MODE (x) != VOIDmode\n-      && ((msize + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD\n-\t  > ((xsize + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD)))\n+  if ((msize + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD\n+      > ((xsize + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD))\n     return 0;\n \n   /* Don't allow generating paradoxical FLOAT_MODE subregs.  */\n-  if (GET_MODE_CLASS (mode) == MODE_FLOAT\n-      && GET_MODE (x) != VOIDmode && msize > xsize)\n+  if (GET_MODE_CLASS (mode) == MODE_FLOAT && msize > xsize)\n     return 0;\n \n-  offset = subreg_lowpart_offset (mode, GET_MODE (x));\n+  offset = subreg_lowpart_offset (mode, innermode);\n \n   if ((GET_CODE (x) == ZERO_EXTEND || GET_CODE (x) == SIGN_EXTEND)\n       && (GET_MODE_CLASS (mode) == MODE_INT\n@@ -1083,154 +1095,15 @@ gen_lowpart_common (enum machine_mode mode, rtx x)\n \n       if (GET_MODE (XEXP (x, 0)) == mode)\n \treturn XEXP (x, 0);\n-      else if (GET_MODE_SIZE (mode) < GET_MODE_SIZE (GET_MODE (XEXP (x, 0))))\n+      else if (msize < GET_MODE_SIZE (GET_MODE (XEXP (x, 0))))\n \treturn gen_lowpart_common (mode, XEXP (x, 0));\n-      else if (GET_MODE_SIZE (mode) < GET_MODE_SIZE (GET_MODE (x)))\n+      else if (msize < xsize)\n \treturn gen_rtx_fmt_e (GET_CODE (x), mode, XEXP (x, 0));\n     }\n   else if (GET_CODE (x) == SUBREG || GET_CODE (x) == REG\n-\t   || GET_CODE (x) == CONCAT || GET_CODE (x) == CONST_VECTOR)\n-    return simplify_gen_subreg (mode, x, GET_MODE (x), offset);\n-  else if (VECTOR_MODE_P (mode) && GET_MODE (x) == VOIDmode)\n-    return simplify_gen_subreg (mode, x, int_mode_for_mode (mode), offset);\n-  /* If X is a CONST_INT or a CONST_DOUBLE, extract the appropriate bits\n-     from the low-order part of the constant.  */\n-  else if ((GET_MODE_CLASS (mode) == MODE_INT\n-\t    || GET_MODE_CLASS (mode) == MODE_PARTIAL_INT)\n-\t   && GET_MODE (x) == VOIDmode\n-\t   && (GET_CODE (x) == CONST_INT || GET_CODE (x) == CONST_DOUBLE))\n-    {\n-      /* If MODE is twice the host word size, X is already the desired\n-\t representation.  Otherwise, if MODE is wider than a word, we can't\n-\t do this.  If MODE is exactly a word, return just one CONST_INT.  */\n-\n-      if (GET_MODE_BITSIZE (mode) >= 2 * HOST_BITS_PER_WIDE_INT)\n-\treturn x;\n-      else if (GET_MODE_BITSIZE (mode) > HOST_BITS_PER_WIDE_INT)\n-\treturn 0;\n-      else if (GET_MODE_BITSIZE (mode) == HOST_BITS_PER_WIDE_INT)\n-\treturn (GET_CODE (x) == CONST_INT ? x\n-\t\t: GEN_INT (CONST_DOUBLE_LOW (x)));\n-      else\n-\t{\n-\t  /* MODE must be narrower than HOST_BITS_PER_WIDE_INT.  */\n-\t  HOST_WIDE_INT val = (GET_CODE (x) == CONST_INT ? INTVAL (x)\n-\t\t\t       : CONST_DOUBLE_LOW (x));\n-\n-\t  /* Sign extend to HOST_WIDE_INT.  */\n-\t  val = trunc_int_for_mode (val, mode);\n-\n-\t  return (GET_CODE (x) == CONST_INT && INTVAL (x) == val ? x\n-\t\t  : GEN_INT (val));\n-\t}\n-    }\n-\n-  /* The floating-point emulator can handle all conversions between\n-     FP and integer operands.  This simplifies reload because it\n-     doesn't have to deal with constructs like (subreg:DI\n-     (const_double:SF ...)) or (subreg:DF (const_int ...)).  */\n-  /* Single-precision floats are always 32-bits and double-precision\n-     floats are always 64-bits.  */\n-\n-  else if (GET_MODE_CLASS (mode) == MODE_FLOAT\n-\t   && GET_MODE_BITSIZE (mode) == 32\n-\t   && GET_CODE (x) == CONST_INT)\n-    {\n-      REAL_VALUE_TYPE r;\n-      long i = INTVAL (x);\n-\n-      real_from_target (&r, &i, mode);\n-      return CONST_DOUBLE_FROM_REAL_VALUE (r, mode);\n-    }\n-  else if (GET_MODE_CLASS (mode) == MODE_FLOAT\n-\t   && GET_MODE_BITSIZE (mode) == 64\n-\t   && (GET_CODE (x) == CONST_INT || GET_CODE (x) == CONST_DOUBLE)\n-\t   && GET_MODE (x) == VOIDmode)\n-    {\n-      REAL_VALUE_TYPE r;\n-      HOST_WIDE_INT low, high;\n-      long i[2];\n-\n-      if (GET_CODE (x) == CONST_INT)\n-\t{\n-\t  low = INTVAL (x);\n-\t  high = low >> (HOST_BITS_PER_WIDE_INT - 1);\n-\t}\n-      else\n-\t{\n-\t  low = CONST_DOUBLE_LOW (x);\n-\t  high = CONST_DOUBLE_HIGH (x);\n-\t}\n-\n-      if (HOST_BITS_PER_WIDE_INT > 32)\n-\thigh = low >> 31 >> 1;\n-\n-      /* REAL_VALUE_TARGET_DOUBLE takes the addressing order of the\n-\t target machine.  */\n-      if (WORDS_BIG_ENDIAN)\n-\ti[0] = high, i[1] = low;\n-      else\n-\ti[0] = low, i[1] = high;\n-\n-      real_from_target (&r, i, mode);\n-      return CONST_DOUBLE_FROM_REAL_VALUE (r, mode);\n-    }\n-  else if ((GET_MODE_CLASS (mode) == MODE_INT\n-\t    || GET_MODE_CLASS (mode) == MODE_PARTIAL_INT)\n-\t   && GET_CODE (x) == CONST_DOUBLE\n-\t   && GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)\n-    {\n-      REAL_VALUE_TYPE r;\n-      long i[4];  /* Only the low 32 bits of each 'long' are used.  */\n-      int endian = WORDS_BIG_ENDIAN ? 1 : 0;\n-\n-      /* Convert 'r' into an array of four 32-bit words in target word\n-         order.  */\n-      REAL_VALUE_FROM_CONST_DOUBLE (r, x);\n-      switch (GET_MODE_BITSIZE (GET_MODE (x)))\n-\t{\n-\tcase 32:\n-\t  REAL_VALUE_TO_TARGET_SINGLE (r, i[3 * endian]);\n-\t  i[1] = 0;\n-\t  i[2] = 0;\n-\t  i[3 - 3 * endian] = 0;\n-\t  break;\n-\tcase 64:\n-\t  REAL_VALUE_TO_TARGET_DOUBLE (r, i + 2 * endian);\n-\t  i[2 - 2 * endian] = 0;\n-\t  i[3 - 2 * endian] = 0;\n-\t  break;\n-\tcase 96:\n-\t  REAL_VALUE_TO_TARGET_LONG_DOUBLE (r, i + endian);\n-\t  i[3 - 3 * endian] = 0;\n-\t  break;\n-\tcase 128:\n-\t  REAL_VALUE_TO_TARGET_LONG_DOUBLE (r, i);\n-\t  break;\n-\tdefault:\n-\t  abort ();\n-\t}\n-      /* Now, pack the 32-bit elements of the array into a CONST_DOUBLE\n-\t and return it.  */\n-#if HOST_BITS_PER_WIDE_INT == 32\n-      return immed_double_const (i[3 * endian], i[1 + endian], mode);\n-#else\n-      if (HOST_BITS_PER_WIDE_INT != 64)\n-\tabort ();\n-\n-      return immed_double_const ((((unsigned long) i[3 * endian])\n-\t\t\t\t  | ((HOST_WIDE_INT) i[1 + endian] << 32)),\n-\t\t\t\t (((unsigned long) i[2 - endian])\n-\t\t\t\t  | ((HOST_WIDE_INT) i[3 - 3 * endian] << 32)),\n-\t\t\t\t mode);\n-#endif\n-    }\n-  /* If MODE is a condition code and X is a CONST_INT, the value of X\n-     must already have been \"recognized\" by the back-end, and we can\n-     assume that it is valid for this mode.  */\n-  else if (GET_MODE_CLASS (mode) == MODE_CC\n-\t   && GET_CODE (x) == CONST_INT)\n-    return x;\n+\t   || GET_CODE (x) == CONCAT || GET_CODE (x) == CONST_VECTOR\n+\t   || GET_CODE (x) == CONST_DOUBLE || GET_CODE (x) == CONST_INT)\n+    return simplify_gen_subreg (mode, x, innermode, offset);\n \n   /* Otherwise, we can't do this.  */\n   return 0;\n@@ -1481,162 +1354,6 @@ subreg_lowpart_p (rtx x)\n \t  == SUBREG_BYTE (x));\n }\n \f\n-\n-/* Helper routine for all the constant cases of operand_subword.\n-   Some places invoke this directly.  */\n-\n-rtx\n-constant_subword (rtx op, int offset, enum machine_mode mode)\n-{\n-  int size_ratio = HOST_BITS_PER_WIDE_INT / BITS_PER_WORD;\n-  HOST_WIDE_INT val;\n-\n-  /* If OP is already an integer word, return it.  */\n-  if (GET_MODE_CLASS (mode) == MODE_INT\n-      && GET_MODE_SIZE (mode) == UNITS_PER_WORD)\n-    return op;\n-\n-  /* The output is some bits, the width of the target machine's word.\n-     A wider-word host can surely hold them in a CONST_INT. A narrower-word\n-     host can't.  */\n-  if (HOST_BITS_PER_WIDE_INT >= BITS_PER_WORD\n-      && GET_MODE_CLASS (mode) == MODE_FLOAT\n-      && GET_MODE_BITSIZE (mode) == 64\n-      && GET_CODE (op) == CONST_DOUBLE)\n-    {\n-      long k[2];\n-      REAL_VALUE_TYPE rv;\n-\n-      REAL_VALUE_FROM_CONST_DOUBLE (rv, op);\n-      REAL_VALUE_TO_TARGET_DOUBLE (rv, k);\n-\n-      /* We handle 32-bit and >= 64-bit words here.  Note that the order in\n-\t which the words are written depends on the word endianness.\n-\t ??? This is a potential portability problem and should\n-\t be fixed at some point.\n-\n-\t We must exercise caution with the sign bit.  By definition there\n-\t are 32 significant bits in K; there may be more in a HOST_WIDE_INT.\n-\t Consider a host with a 32-bit long and a 64-bit HOST_WIDE_INT.\n-\t So we explicitly mask and sign-extend as necessary.  */\n-      if (BITS_PER_WORD == 32)\n-\t{\n-\t  val = k[offset];\n-\t  val = ((val & 0xffffffff) ^ 0x80000000) - 0x80000000;\n-\t  return GEN_INT (val);\n-\t}\n-#if HOST_BITS_PER_WIDE_INT >= 64\n-      else if (BITS_PER_WORD >= 64 && offset == 0)\n-\t{\n-\t  val = k[! WORDS_BIG_ENDIAN];\n-\t  val = (((val & 0xffffffff) ^ 0x80000000) - 0x80000000) << 32;\n-\t  val |= (HOST_WIDE_INT) k[WORDS_BIG_ENDIAN] & 0xffffffff;\n-\t  return GEN_INT (val);\n-\t}\n-#endif\n-      else if (BITS_PER_WORD == 16)\n-\t{\n-\t  val = k[offset >> 1];\n-\t  if ((offset & 1) == ! WORDS_BIG_ENDIAN)\n-\t    val >>= 16;\n-\t  val = ((val & 0xffff) ^ 0x8000) - 0x8000;\n-\t  return GEN_INT (val);\n-\t}\n-      else\n-\tabort ();\n-    }\n-  else if (HOST_BITS_PER_WIDE_INT >= BITS_PER_WORD\n-\t   && GET_MODE_CLASS (mode) == MODE_FLOAT\n-\t   && GET_MODE_BITSIZE (mode) > 64\n-\t   && GET_CODE (op) == CONST_DOUBLE)\n-    {\n-      long k[4];\n-      REAL_VALUE_TYPE rv;\n-\n-      REAL_VALUE_FROM_CONST_DOUBLE (rv, op);\n-      REAL_VALUE_TO_TARGET_LONG_DOUBLE (rv, k);\n-\n-      if (BITS_PER_WORD == 32)\n-\t{\n-\t  val = k[offset];\n-\t  val = ((val & 0xffffffff) ^ 0x80000000) - 0x80000000;\n-\t  return GEN_INT (val);\n-\t}\n-#if HOST_BITS_PER_WIDE_INT >= 64\n-      else if (BITS_PER_WORD >= 64 && offset <= 1)\n-\t{\n-\t  val = k[offset * 2 + ! WORDS_BIG_ENDIAN];\n-\t  val = (((val & 0xffffffff) ^ 0x80000000) - 0x80000000) << 32;\n-\t  val |= (HOST_WIDE_INT) k[offset * 2 + WORDS_BIG_ENDIAN] & 0xffffffff;\n-\t  return GEN_INT (val);\n-\t}\n-#endif\n-      else\n-\tabort ();\n-    }\n-\n-  /* Single word float is a little harder, since single- and double-word\n-     values often do not have the same high-order bits.  We have already\n-     verified that we want the only defined word of the single-word value.  */\n-  if (GET_MODE_CLASS (mode) == MODE_FLOAT\n-      && GET_MODE_BITSIZE (mode) == 32\n-      && GET_CODE (op) == CONST_DOUBLE)\n-    {\n-      long l;\n-      REAL_VALUE_TYPE rv;\n-\n-      REAL_VALUE_FROM_CONST_DOUBLE (rv, op);\n-      REAL_VALUE_TO_TARGET_SINGLE (rv, l);\n-\n-      /* Sign extend from known 32-bit value to HOST_WIDE_INT.  */\n-      val = l;\n-      val = ((val & 0xffffffff) ^ 0x80000000) - 0x80000000;\n-\n-      if (BITS_PER_WORD == 16)\n-\t{\n-\t  if ((offset & 1) == ! WORDS_BIG_ENDIAN)\n-\t    val >>= 16;\n-\t  val = ((val & 0xffff) ^ 0x8000) - 0x8000;\n-\t}\n-\n-      return GEN_INT (val);\n-    }\n-\n-  /* The only remaining cases that we can handle are integers.\n-     Convert to proper endianness now since these cases need it.\n-     At this point, offset == 0 means the low-order word.\n-\n-     We do not want to handle the case when BITS_PER_WORD <= HOST_BITS_PER_INT\n-     in general.  However, if OP is (const_int 0), we can just return\n-     it for any word.  */\n-\n-  if (op == const0_rtx)\n-    return op;\n-\n-  if (GET_MODE_CLASS (mode) != MODE_INT\n-      || (GET_CODE (op) != CONST_INT && GET_CODE (op) != CONST_DOUBLE)\n-      || BITS_PER_WORD > HOST_BITS_PER_WIDE_INT)\n-    return 0;\n-\n-  if (WORDS_BIG_ENDIAN)\n-    offset = GET_MODE_SIZE (mode) / UNITS_PER_WORD - 1 - offset;\n-\n-  /* Find out which word on the host machine this value is in and get\n-     it from the constant.  */\n-  val = (offset / size_ratio == 0\n-\t ? (GET_CODE (op) == CONST_INT ? INTVAL (op) : CONST_DOUBLE_LOW (op))\n-\t : (GET_CODE (op) == CONST_INT\n-\t    ? (INTVAL (op) < 0 ? ~0 : 0) : CONST_DOUBLE_HIGH (op)));\n-\n-  /* Get the value we want into the low bits of val.  */\n-  if (BITS_PER_WORD < HOST_BITS_PER_WIDE_INT)\n-    val = ((val >> ((offset % size_ratio) * BITS_PER_WORD)));\n-\n-  val = trunc_int_for_mode (val, word_mode);\n-\n-  return GEN_INT (val);\n-}\n-\n /* Return subword OFFSET of operand OP.\n    The word number, OFFSET, is interpreted as the word number starting\n    at the low-order address.  OFFSET 0 is the low-order word if not"}, {"sha": "7e42a1dc4075d328b181ad9b310e22028127c9f0", "filename": "gcc/rtl.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/550d138775ddd05e61d684a9e6407e422e2ee5b3/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/550d138775ddd05e61d684a9e6407e422e2ee5b3/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=550d138775ddd05e61d684a9e6407e422e2ee5b3", "patch": "@@ -1485,7 +1485,6 @@ extern rtx gen_highpart_mode (enum machine_mode, enum machine_mode, rtx);\n extern rtx gen_realpart (enum machine_mode, rtx);\n extern rtx gen_imagpart (enum machine_mode, rtx);\n extern rtx operand_subword (rtx, unsigned int, int, enum machine_mode);\n-extern rtx constant_subword (rtx, int, enum machine_mode);\n \n /* In emit-rtl.c */\n extern rtx operand_subword_force (rtx, unsigned int, enum machine_mode);\n@@ -1507,10 +1506,10 @@ extern void push_to_sequence (rtx);\n extern void end_sequence (void);\n extern void push_to_full_sequence (rtx, rtx);\n extern void end_full_sequence (rtx*, rtx*);\n-\n-/* In varasm.c  */\n extern rtx immed_double_const (HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t       enum machine_mode);\n+\n+/* In varasm.c  */\n extern rtx force_const_mem (enum machine_mode, rtx);\n \n /* In varasm.c  */"}, {"sha": "d5beb2eb5fc4f217b083f46256f5b2510486769f", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 266, "deletions": 201, "changes": 467, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/550d138775ddd05e61d684a9e6407e422e2ee5b3/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/550d138775ddd05e61d684a9e6407e422e2ee5b3/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=550d138775ddd05e61d684a9e6407e422e2ee5b3", "patch": "@@ -53,6 +53,8 @@ static rtx neg_const_int (enum machine_mode, rtx);\n static int simplify_plus_minus_op_data_cmp (const void *, const void *);\n static rtx simplify_plus_minus (enum rtx_code, enum machine_mode, rtx,\n \t\t\t\trtx, int);\n+static rtx simplify_immed_subreg (enum machine_mode, rtx, enum machine_mode,\n+\t\t\t\t  unsigned int);\n static bool associative_constant_p (rtx);\n static rtx simplify_associative_operation (enum rtx_code, enum machine_mode,\n \t\t\t\t\t   rtx, rtx);\n@@ -2949,238 +2951,300 @@ simplify_ternary_operation (enum rtx_code code, enum machine_mode mode,\n   return 0;\n }\n \n-/* Simplify SUBREG:OUTERMODE(OP:INNERMODE, BYTE)\n-   Return 0 if no simplifications is possible.  */\n-rtx\n-simplify_subreg (enum machine_mode outermode, rtx op,\n-\t\t enum machine_mode innermode, unsigned int byte)\n-{\n-  /* Little bit of sanity checking.  */\n-  if (innermode == VOIDmode || outermode == VOIDmode\n-      || innermode == BLKmode || outermode == BLKmode)\n-    abort ();\n-\n-  if (GET_MODE (op) != innermode\n-      && GET_MODE (op) != VOIDmode)\n-    abort ();\n+/* Evaluate a SUBREG of a CONST_INT or CONST_DOUBLE or CONST_VECTOR,\n+   returning another CONST_INT or CONST_DOUBLE or CONST_VECTOR.\n \n-  if (byte % GET_MODE_SIZE (outermode)\n-      || byte >= GET_MODE_SIZE (innermode))\n-    abort ();\n+   Works by unpacking OP into a collection of 8-bit values\n+   represented as a little-endian array of 'unsigned char', selecting by BYTE,\n+   and then repacking them again for OUTERMODE.  */\n \n-  if (outermode == innermode && !byte)\n+static rtx\n+simplify_immed_subreg (enum machine_mode outermode, rtx op, \n+\t\t       enum machine_mode innermode, unsigned int byte)\n+{\n+  /* We support up to 512-bit values (for V8DFmode).  */\n+  enum {\n+    max_bitsize = 512,\n+    value_bit = 8,\n+    value_mask = (1 << value_bit) - 1\n+  };\n+  unsigned char value[max_bitsize / value_bit];\n+  int value_start;\n+  int i;\n+  int elem;\n+\n+  int num_elem;\n+  rtx * elems;\n+  int elem_bitsize;\n+  rtx result_s;\n+  rtvec result_v = NULL;\n+  enum mode_class outer_class;\n+  enum machine_mode outer_submode;\n+\n+  /* Some ports misuse CCmode.  */\n+  if (GET_MODE_CLASS (outermode) == MODE_CC && GET_CODE (op) == CONST_INT)\n     return op;\n \n-  /* Simplify subregs of vector constants.  */\n+  /* Unpack the value.  */\n+\n   if (GET_CODE (op) == CONST_VECTOR)\n     {\n-      int elt_size = GET_MODE_SIZE (GET_MODE_INNER (innermode));\n-      const unsigned int offset = byte / elt_size;\n-      rtx elt;\n+      num_elem = CONST_VECTOR_NUNITS (op);\n+      elems = &CONST_VECTOR_ELT (op, 0);\n+      elem_bitsize = GET_MODE_BITSIZE (GET_MODE_INNER (innermode));\n+    }\n+  else\n+    {\n+      num_elem = 1;\n+      elems = &op;\n+      elem_bitsize = max_bitsize;\n+    }\n \n-      if (GET_MODE_INNER (innermode) == outermode)\n+  if (BITS_PER_UNIT % value_bit != 0)\n+    abort ();  /* Too complicated; reducing value_bit may help.  */\n+  if (elem_bitsize % BITS_PER_UNIT != 0)\n+    abort ();  /* I don't know how to handle endianness of sub-units.  */\n+  \n+  for (elem = 0; elem < num_elem; elem++)\n+    {\n+      unsigned char * vp;\n+      rtx el = elems[elem];\n+      \n+      /* Vectors are kept in target memory order.  (This is probably\n+\t a mistake.)  */\n+      {\n+\tunsigned byte = (elem * elem_bitsize) / BITS_PER_UNIT;\n+\tunsigned ibyte = (((num_elem - 1 - elem) * elem_bitsize) \n+\t\t\t  / BITS_PER_UNIT);\n+\tunsigned word_byte = WORDS_BIG_ENDIAN ? ibyte : byte;\n+\tunsigned subword_byte = BYTES_BIG_ENDIAN ? ibyte : byte;\n+\tunsigned bytele = (subword_byte % UNITS_PER_WORD\n+\t\t\t + (word_byte / UNITS_PER_WORD) * UNITS_PER_WORD);\n+\tvp = value + (bytele * BITS_PER_UNIT) / value_bit;\n+      }\n+\t\n+      switch (GET_CODE (el))\n \t{\n-\t  elt = CONST_VECTOR_ELT (op, offset);\n-\n-\t  /* ?? We probably don't need this copy_rtx because constants\n-\t     can be shared.  ?? */\n+\tcase CONST_INT:\n+\t  for (i = 0;\n+\t       i < HOST_BITS_PER_WIDE_INT && i < elem_bitsize; \n+\t       i += value_bit)\n+\t    *vp++ = INTVAL (el) >> i;\n+\t  /* CONST_INTs are always logically sign-extended.  */\n+\t  for (; i < elem_bitsize; i += value_bit)\n+\t    *vp++ = INTVAL (el) < 0 ? -1 : 0;\n+\t  break;\n+      \n+\tcase CONST_DOUBLE:\n+\t  if (GET_MODE (el) == VOIDmode)\n+\t    {\n+\t      /* If this triggers, someone should have generated a\n+\t\t CONST_INT instead.  */\n+\t      if (elem_bitsize <= HOST_BITS_PER_WIDE_INT)\n+\t\tabort ();\n \n-\t  return copy_rtx (elt);\n-\t}\n-      else if (GET_MODE_INNER (innermode) == GET_MODE_INNER (outermode)\n-\t       && GET_MODE_SIZE (innermode) > GET_MODE_SIZE (outermode))\n-\t{\n-\t  return (gen_rtx_CONST_VECTOR\n-\t\t  (outermode,\n-\t\t   gen_rtvec_v (GET_MODE_NUNITS (outermode),\n-\t\t\t\t&CONST_VECTOR_ELT (op, offset))));\n-\t}\n-      else if (GET_MODE_CLASS (outermode) == MODE_INT\n-\t       && (GET_MODE_SIZE (outermode) % elt_size == 0))\n-\t{\n-\t  /* This happens when the target register size is smaller then\n-\t     the vector mode, and we synthesize operations with vectors\n-\t     of elements that are smaller than the register size.  */\n-\t  HOST_WIDE_INT sum = 0, high = 0;\n-\t  unsigned n_elts = (GET_MODE_SIZE (outermode) / elt_size);\n-\t  unsigned i = BYTES_BIG_ENDIAN ? offset : offset + n_elts - 1;\n-\t  unsigned step = BYTES_BIG_ENDIAN ? 1 : -1;\n-\t  int shift = BITS_PER_UNIT * elt_size;\n-\t  unsigned HOST_WIDE_INT unit_mask;\n-\n-\t  unit_mask = (unsigned HOST_WIDE_INT) -1\n-\t    >> (sizeof (HOST_WIDE_INT) * BITS_PER_UNIT - shift);\n-\n-\t  for (; n_elts--; i += step)\n+\t      for (i = 0; i < HOST_BITS_PER_WIDE_INT; i += value_bit)\n+\t\t*vp++ = CONST_DOUBLE_LOW (el) >> i;\n+\t      while (i < HOST_BITS_PER_WIDE_INT * 2 && i < elem_bitsize)\n+\t\t{\n+\t\t  *vp++ = CONST_DOUBLE_HIGH (el) >> i;\n+\t\t  i += value_bit;\n+\t\t}\n+\t      /* It shouldn't matter what's done here, so fill it with\n+\t\t zero.  */\n+\t      for (; i < max_bitsize; i += value_bit)\n+\t\t*vp++ = 0;\n+\t    }\n+\t  else if (GET_MODE_CLASS (GET_MODE (el)) == MODE_FLOAT)\n \t    {\n-\t      elt = CONST_VECTOR_ELT (op, i);\n-\t      if (GET_CODE (elt) == CONST_DOUBLE\n-\t\t  && GET_MODE_CLASS (GET_MODE (elt)) == MODE_FLOAT)\n+\t      long tmp[max_bitsize / 32];\n+\t      int bitsize = GET_MODE_BITSIZE (GET_MODE (el));\n+\t      \n+\t      if (bitsize > elem_bitsize)\n+\t\tabort ();\n+\t      if (bitsize % value_bit != 0)\n+\t\tabort ();\n+\n+\t      real_to_target (tmp, CONST_DOUBLE_REAL_VALUE (el),\n+\t\t\t      GET_MODE (el));\n+\n+\t      /* real_to_target produces its result in words affected by\n+\t\t FLOAT_WORDS_BIG_ENDIAN.  However, we ignore this,\n+\t\t and use WORDS_BIG_ENDIAN instead; see the documentation\n+\t         of SUBREG in rtl.texi.  */\n+\t      for (i = 0; i < bitsize; i += value_bit)\n \t\t{\n-\t\t  elt = gen_lowpart_common (int_mode_for_mode (GET_MODE (elt)),\n-\t\t\t\t\t    elt);\n-\t\t  if (! elt)\n-\t\t    return NULL_RTX;\n+\t\t  int ibase;\n+\t\t  if (WORDS_BIG_ENDIAN)\n+\t\t    ibase = bitsize - 1 - i;\n+\t\t  else\n+\t\t    ibase = i;\n+\t\t  *vp++ = tmp[ibase / 32] >> i % 32;\n \t\t}\n-\t      if (GET_CODE (elt) != CONST_INT)\n-\t\treturn NULL_RTX;\n-\t      /* Avoid overflow.  */\n-\t      if (high >> (HOST_BITS_PER_WIDE_INT - shift))\n-\t\treturn NULL_RTX;\n-\t      high = high << shift | sum >> (HOST_BITS_PER_WIDE_INT - shift);\n-\t      sum = (sum << shift) + (INTVAL (elt) & unit_mask);\n+\t      \n+\t      /* It shouldn't matter what's done here, so fill it with\n+\t\t zero.  */\n+\t      for (; i < elem_bitsize; i += value_bit)\n+\t\t*vp++ = 0;\n \t    }\n-\t  if (GET_MODE_BITSIZE (outermode) <= HOST_BITS_PER_WIDE_INT)\n-\t    return GEN_INT (trunc_int_for_mode (sum, outermode));\n-\t  else if (GET_MODE_BITSIZE (outermode) == 2* HOST_BITS_PER_WIDE_INT)\n-\t    return immed_double_const (sum, high, outermode);\n \t  else\n-\t    return NULL_RTX;\n-\t}\n-      else if (GET_MODE_CLASS (outermode) == MODE_INT\n-\t       && (elt_size % GET_MODE_SIZE (outermode) == 0))\n-\t{\n-\t  enum machine_mode new_mode\n-\t    = int_mode_for_mode (GET_MODE_INNER (innermode));\n-\t  int subbyte = byte % elt_size;\n-\n-\t  op = simplify_subreg (new_mode, op, innermode, byte - subbyte);\n-\t  if (! op)\n-\t    return NULL_RTX;\n-\t  return simplify_subreg (outermode, op, new_mode, subbyte);\n+\t    abort ();\n+\t  break;\n+\t  \n+\tdefault:\n+\t  abort ();\n \t}\n-      else if (GET_MODE_CLASS (outermode) == MODE_INT)\n-        /* This shouldn't happen, but let's not do anything stupid.  */\n-\treturn NULL_RTX;\n     }\n \n-  /* Attempt to simplify constant to non-SUBREG expression.  */\n-  if (CONSTANT_P (op))\n+  /* Now, pick the right byte to start with.  */\n+  /* Renumber BYTE so that the least-significant byte is byte 0.  A special\n+     case is paradoxical SUBREGs, which shouldn't be adjusted since they\n+     will already have offset 0.  */\n+  if (GET_MODE_SIZE (innermode) >= GET_MODE_SIZE (outermode))\n     {\n-      int offset, part;\n-      unsigned HOST_WIDE_INT val = 0;\n+      unsigned ibyte = (GET_MODE_SIZE (innermode) - GET_MODE_SIZE (outermode) \n+\t\t\t- byte);\n+      unsigned word_byte = WORDS_BIG_ENDIAN ? ibyte : byte;\n+      unsigned subword_byte = BYTES_BIG_ENDIAN ? ibyte : byte;\n+      byte = (subword_byte % UNITS_PER_WORD\n+\t      + (word_byte / UNITS_PER_WORD) * UNITS_PER_WORD);\n+    }\n \n-      if (VECTOR_MODE_P (outermode))\n-\t{\n-\t  /* Construct a CONST_VECTOR from individual subregs.  */\n-\t  enum machine_mode submode = GET_MODE_INNER (outermode);\n-\t  int subsize = GET_MODE_UNIT_SIZE (outermode);\n-\t  int i, elts = GET_MODE_NUNITS (outermode);\n-\t  rtvec v = rtvec_alloc (elts);\n-\t  rtx elt;\n-\n-\t  for (i = 0; i < elts; i++, byte += subsize)\n-\t    {\n-\t      /* This might fail, e.g. if taking a subreg from a SYMBOL_REF.  */\n-\t      /* ??? It would be nice if we could actually make such subregs\n-\t\t on targets that allow such relocations.  */\n-\t      if (byte >= GET_MODE_SIZE (innermode))\n-\t\telt = CONST0_RTX (submode);\n-\t      else\n-\t        elt = simplify_subreg (submode, op, innermode, byte);\n-\t      if (! elt)\n-\t\treturn NULL_RTX;\n-\t      RTVEC_ELT (v, i) = elt;\n-\t    }\n-\t  return gen_rtx_CONST_VECTOR (outermode, v);\n-\t}\n+  /* BYTE should still be inside OP.  (Note that BYTE is unsigned,\n+     so if it's become negative it will instead be very large.)  */\n+  if (byte >= GET_MODE_SIZE (innermode))\n+    abort ();\n \n-      /* ??? This code is partly redundant with code below, but can handle\n-\t the subregs of floats and similar corner cases.\n-\t Later it we should move all simplification code here and rewrite\n-\t GEN_LOWPART_IF_POSSIBLE, GEN_HIGHPART, OPERAND_SUBWORD and friends\n-\t using SIMPLIFY_SUBREG.  */\n-      if (subreg_lowpart_offset (outermode, innermode) == byte\n-\t  && GET_CODE (op) != CONST_VECTOR)\n-\t{\n-\t  rtx new = gen_lowpart_if_possible (outermode, op);\n-\t  if (new)\n-\t    return new;\n-\t}\n+  /* Convert from bytes to chunks of size value_bit.  */\n+  value_start = byte * (BITS_PER_UNIT / value_bit);\n \n-      /* Similar comment as above apply here.  */\n-      if (GET_MODE_SIZE (outermode) == UNITS_PER_WORD\n-\t  && GET_MODE_SIZE (innermode) > UNITS_PER_WORD\n-\t  && GET_MODE_CLASS (outermode) == MODE_INT)\n-\t{\n-\t  rtx new = constant_subword (op,\n-\t\t\t\t      (byte / UNITS_PER_WORD),\n-\t\t\t\t      innermode);\n-\t  if (new)\n-\t    return new;\n-\t}\n+  /* Re-pack the value.  */\n+    \n+  if (VECTOR_MODE_P (outermode))\n+    {\n+      num_elem = GET_MODE_NUNITS (outermode);\n+      result_v = rtvec_alloc (num_elem);\n+      elems = &RTVEC_ELT (result_v, 0);\n+      outer_submode = GET_MODE_INNER (outermode);\n+    }\n+  else\n+    {\n+      num_elem = 1;\n+      elems = &result_s;\n+      outer_submode = outermode;\n+    }\n \n-      if (GET_MODE_CLASS (outermode) != MODE_INT\n-\t  && GET_MODE_CLASS (outermode) != MODE_CC)\n-\t{\n-\t  enum machine_mode new_mode = int_mode_for_mode (outermode);\n+  outer_class = GET_MODE_CLASS (outer_submode);\n+  elem_bitsize = GET_MODE_BITSIZE (outer_submode);\n \n-\t  if (new_mode != innermode || byte != 0)\n-\t    {\n-\t      op = simplify_subreg (new_mode, op, innermode, byte);\n-\t      if (! op)\n-\t\treturn NULL_RTX;\n-\t      return simplify_subreg (outermode, op, new_mode, 0);\n-\t    }\n-\t}\n+  if (elem_bitsize % value_bit != 0)\n+    abort ();\n+  if (elem_bitsize + value_start * value_bit > max_bitsize)\n+    abort ();\n \n-      offset = byte * BITS_PER_UNIT;\n-      switch (GET_CODE (op))\n+  for (elem = 0; elem < num_elem; elem++)\n+    {\n+      unsigned char *vp;\n+      \n+      /* Vectors are stored in target memory order.  (This is probably\n+\t a mistake.)  */\n+      {\n+\tunsigned byte = (elem * elem_bitsize) / BITS_PER_UNIT;\n+\tunsigned ibyte = (((num_elem - 1 - elem) * elem_bitsize) \n+\t\t\t  / BITS_PER_UNIT);\n+\tunsigned word_byte = WORDS_BIG_ENDIAN ? ibyte : byte;\n+\tunsigned subword_byte = BYTES_BIG_ENDIAN ? ibyte : byte;\n+\tunsigned bytele = (subword_byte % UNITS_PER_WORD\n+\t\t\t + (word_byte / UNITS_PER_WORD) * UNITS_PER_WORD);\n+\tvp = value + value_start + (bytele * BITS_PER_UNIT) / value_bit;\n+      }\n+\n+      switch (outer_class)\n \t{\n-\tcase CONST_DOUBLE:\n-\t  if (GET_MODE (op) != VOIDmode)\n-\t    break;\n-\n-\t  /* We can't handle this case yet.  */\n-\t  if (GET_MODE_BITSIZE (outermode) >= HOST_BITS_PER_WIDE_INT)\n-\t    return NULL_RTX;\n+\tcase MODE_INT:\n+\tcase MODE_PARTIAL_INT:\n+\t  {\n+\t    unsigned HOST_WIDE_INT hi = 0, lo = 0;\n+\n+\t    for (i = 0;\n+\t\t i < HOST_BITS_PER_WIDE_INT && i < elem_bitsize;\n+\t\t i += value_bit)\n+\t      lo |= (HOST_WIDE_INT)(*vp++ & value_mask) << i;\n+\t    for (; i < elem_bitsize; i += value_bit)\n+\t      hi |= ((HOST_WIDE_INT)(*vp++ & value_mask)\n+\t\t     << (i - HOST_BITS_PER_WIDE_INT));\n+\t    \n+\t    /* immed_double_const doesn't call trunc_int_for_mode.  I don't\n+\t       know why.  */\n+\t    if (elem_bitsize <= HOST_BITS_PER_WIDE_INT)\n+\t      elems[elem] = gen_int_mode (lo, outer_submode);\n+\t    else\n+\t      elems[elem] = immed_double_const (lo, hi, outer_submode);\n+\t  }\n+\t  break;\n+      \n+\tcase MODE_FLOAT:\n+\t  {\n+\t    REAL_VALUE_TYPE r;\n+\t    long tmp[max_bitsize / 32];\n+\t    \n+\t    /* real_from_target wants its input in words affected by\n+\t       FLOAT_WORDS_BIG_ENDIAN.  However, we ignore this,\n+\t       and use WORDS_BIG_ENDIAN instead; see the documentation\n+\t       of SUBREG in rtl.texi.  */\n+\t    for (i = 0; i < max_bitsize / 32; i++)\n+\t      tmp[i] = 0;\n+\t    for (i = 0; i < elem_bitsize; i += value_bit)\n+\t      {\n+\t\tint ibase;\n+\t\tif (WORDS_BIG_ENDIAN)\n+\t\t  ibase = elem_bitsize - 1 - i;\n+\t\telse\n+\t\t  ibase = i;\n+\t\ttmp[ibase / 32] = (*vp++ & value_mask) << i % 32;\n+\t      }\n \n-\t  part = offset >= HOST_BITS_PER_WIDE_INT;\n-\t  if ((BITS_PER_WORD > HOST_BITS_PER_WIDE_INT\n-\t       && BYTES_BIG_ENDIAN)\n-\t      || (BITS_PER_WORD <= HOST_BITS_PER_WIDE_INT\n-\t\t  && WORDS_BIG_ENDIAN))\n-\t    part = !part;\n-\t  val = part ? CONST_DOUBLE_HIGH (op) : CONST_DOUBLE_LOW (op);\n-\t  offset %= HOST_BITS_PER_WIDE_INT;\n+\t    real_from_target (&r, tmp, outer_submode);\n+\t    elems[elem] = CONST_DOUBLE_FROM_REAL_VALUE (r, outer_submode);\n+\t  }\n+\t  break;\n+\t    \n+\tdefault:\n+\t  abort ();\n+\t}\n+    }\n+  if (VECTOR_MODE_P (outermode))\n+    return gen_rtx_CONST_VECTOR (outermode, result_v);\n+  else\n+    return result_s;\n+}\n \n-\t  /* We've already picked the word we want from a double, so\n-\t     pretend this is actually an integer.  */\n-\t  innermode = mode_for_size (HOST_BITS_PER_WIDE_INT, MODE_INT, 0);\n+/* Simplify SUBREG:OUTERMODE(OP:INNERMODE, BYTE)\n+   Return 0 if no simplifications are possible.  */\n+rtx\n+simplify_subreg (enum machine_mode outermode, rtx op,\n+\t\t enum machine_mode innermode, unsigned int byte)\n+{\n+  /* Little bit of sanity checking.  */\n+  if (innermode == VOIDmode || outermode == VOIDmode\n+      || innermode == BLKmode || outermode == BLKmode)\n+    abort ();\n \n-\t  /* Fall through.  */\n-\tcase CONST_INT:\n-\t  if (GET_CODE (op) == CONST_INT)\n-\t    val = INTVAL (op);\n+  if (GET_MODE (op) != innermode\n+      && GET_MODE (op) != VOIDmode)\n+    abort ();\n \n-\t  /* We don't handle synthesizing of non-integral constants yet.  */\n-\t  if (GET_MODE_CLASS (outermode) != MODE_INT)\n-\t    return NULL_RTX;\n+  if (byte % GET_MODE_SIZE (outermode)\n+      || byte >= GET_MODE_SIZE (innermode))\n+    abort ();\n \n-\t  if (BYTES_BIG_ENDIAN || WORDS_BIG_ENDIAN)\n-\t    {\n-\t      if (WORDS_BIG_ENDIAN)\n-\t\toffset = (GET_MODE_BITSIZE (innermode)\n-\t\t\t  - GET_MODE_BITSIZE (outermode) - offset);\n-\t      if (BYTES_BIG_ENDIAN != WORDS_BIG_ENDIAN\n-\t\t  && GET_MODE_SIZE (outermode) < UNITS_PER_WORD)\n-\t\toffset = (offset + BITS_PER_WORD - GET_MODE_BITSIZE (outermode)\n-\t\t\t  - 2 * (offset % BITS_PER_WORD));\n-\t    }\n+  if (outermode == innermode && !byte)\n+    return op;\n \n-\t  if (offset >= HOST_BITS_PER_WIDE_INT)\n-\t    return ((HOST_WIDE_INT) val < 0) ? constm1_rtx : const0_rtx;\n-\t  else\n-\t    {\n-\t      val >>= offset;\n-\t      if (GET_MODE_BITSIZE (outermode) < HOST_BITS_PER_WIDE_INT)\n-\t\tval = trunc_int_for_mode (val, outermode);\n-\t      return GEN_INT (val);\n-\t    }\n-\tdefault:\n-\t  break;\n-\t}\n-    }\n+  if (GET_CODE (op) == CONST_INT\n+      || GET_CODE (op) == CONST_DOUBLE\n+      || GET_CODE (op) == CONST_VECTOR)\n+    return simplify_immed_subreg (outermode, op, innermode, byte);\n \n   /* Changing mode twice with SUBREG => just change it once,\n      or not at all if changing back op starting mode.  */\n@@ -3335,6 +3399,7 @@ simplify_subreg (enum machine_mode outermode, rtx op,\n \n   return NULL_RTX;\n }\n+\n /* Make a SUBREG operation or equivalent if it folds.  */\n \n rtx"}]}