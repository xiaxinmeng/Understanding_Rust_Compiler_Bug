{"sha": "2c23db6dd33ea21edc8970449e420eea4eaa3616", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmMyM2RiNmRkMzNlYTIxZWRjODk3MDQ0OWU0MjBlZWE0ZWFhMzYxNg==", "commit": {"author": {"name": "Evgeny Stupachenko", "email": "evstupac@gmail.com", "date": "2014-05-07T12:10:22Z"}, "committer": {"name": "Kirill Yukhin", "email": "kyukhin@gcc.gnu.org", "date": "2014-05-07T12:10:22Z"}, "message": "re PR tree-optimization/52252 (An opportunity for x86 gcc vectorizer (gain up to 3 times))\n\ngcc/\n\t* tree-vect-data-refs.c (vect_grouped_load_supported): New\n\tcheck for loads group of length 3.\n\t(vect_permute_load_chain): New permutations for loads group of\n\tlength 3.\n\t* tree-vect-stmts.c (vect_model_load_cost): Change cost\n\tof vec_perm_shuffle for the new permutations.\n\ngcc/testsuite/\n\tPR tree-optimization/52252\n\t* gcc.dg/vect/pr52252-ld.c: Test on loads group of size 3.\n\nFrom-SVN: r210155", "tree": {"sha": "2209bca524450055906393fe7143a936507176ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2209bca524450055906393fe7143a936507176ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c23db6dd33ea21edc8970449e420eea4eaa3616", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c23db6dd33ea21edc8970449e420eea4eaa3616", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c23db6dd33ea21edc8970449e420eea4eaa3616", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c23db6dd33ea21edc8970449e420eea4eaa3616/comments", "author": {"login": "evstupac", "id": 38332307, "node_id": "MDQ6VXNlcjM4MzMyMzA3", "avatar_url": "https://avatars.githubusercontent.com/u/38332307?v=4", "gravatar_id": "", "url": "https://api.github.com/users/evstupac", "html_url": "https://github.com/evstupac", "followers_url": "https://api.github.com/users/evstupac/followers", "following_url": "https://api.github.com/users/evstupac/following{/other_user}", "gists_url": "https://api.github.com/users/evstupac/gists{/gist_id}", "starred_url": "https://api.github.com/users/evstupac/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/evstupac/subscriptions", "organizations_url": "https://api.github.com/users/evstupac/orgs", "repos_url": "https://api.github.com/users/evstupac/repos", "events_url": "https://api.github.com/users/evstupac/events{/privacy}", "received_events_url": "https://api.github.com/users/evstupac/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "586199f3092d6ff1b0bd18cc9eb0a1f3654d47cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/586199f3092d6ff1b0bd18cc9eb0a1f3654d47cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/586199f3092d6ff1b0bd18cc9eb0a1f3654d47cb"}], "stats": {"total": 228, "additions": 184, "deletions": 44}, "files": [{"sha": "000a5fb4dcbc4b6875055159d83cfc7d00f21ae7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c23db6dd33ea21edc8970449e420eea4eaa3616/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c23db6dd33ea21edc8970449e420eea4eaa3616/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2c23db6dd33ea21edc8970449e420eea4eaa3616", "patch": "@@ -1,3 +1,12 @@\n+2014-05-07  Evgeny Stupachenko  <evstupac@gmail.com>\n+\n+\t* tree-vect-data-refs.c (vect_grouped_load_supported): New\n+\tcheck for loads group of length 3.\n+\t(vect_permute_load_chain): New permutations for loads group of\n+\tlength 3.\n+\t* tree-vect-stmts.c (vect_model_load_cost): Change cost\n+\tof vec_perm_shuffle for the new permutations.\n+\n 2014-05-07  Alan Lawrence  <alan.lawrence@arm.com>\n \n \t* config/aarch64/arm_neon.h (vtrn1_f32, vtrn1_p8, vtrn1_p16, vtrn1_s8,"}, {"sha": "ea89f0614808b2fe2ea02d2d2498242a23d20985", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c23db6dd33ea21edc8970449e420eea4eaa3616/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c23db6dd33ea21edc8970449e420eea4eaa3616/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2c23db6dd33ea21edc8970449e420eea4eaa3616", "patch": "@@ -1,3 +1,8 @@\n+2014-05-07  Evgeny Stupachenko  <evstupac@gmail.com>\n+\n+\tPR tree-optimization/52252\n+\t* gcc.dg/vect/pr52252-ld.c: Test on loads group of size 3.\n+\n 2014-05-07  Alan Lawrence  <alan.lawrence@arm.com>\n \n \t* gcc.target/aarch64/simd/vrev16p8_1.c: New file."}, {"sha": "6e3cb52b85d9a8429fa7f40c598a4881c2f1d689", "filename": "gcc/testsuite/gcc.dg/vect/pr52252-ld.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c23db6dd33ea21edc8970449e420eea4eaa3616/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr52252-ld.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c23db6dd33ea21edc8970449e420eea4eaa3616/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr52252-ld.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr52252-ld.c?ref=2c23db6dd33ea21edc8970449e420eea4eaa3616", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -g -ftree-vectorize -mssse3 -fdump-tree-vect-details\" { target { i?86-*-* x86_64-*-* } } } */\n+\n+#define byte unsigned char\n+\n+void\n+matrix_mul (byte *in, byte *out, int size)\n+{\n+  int i;\n+  for (i = 0; i < size; i++)\n+    {\n+      byte in0 = in[0];\n+      byte in1 = in[1];\n+      byte in2 = in[2];\n+      byte out0, out1, out2, out3;\n+      out0 = in0 + in1;\n+      out1 = in0 + in2;\n+      out2 = in1 + in2;\n+      out3 = in0 + in1 + in2;\n+      out[0] = out0;\n+      out[1] = out1;\n+      out[2] = out2;\n+      out[3] = out3;\n+      in += 3;\n+      out += 4;\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "c48640550e7d705fa6a0e173e1d1007c546f5f62", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 135, "deletions": 40, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c23db6dd33ea21edc8970449e420eea4eaa3616/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c23db6dd33ea21edc8970449e420eea4eaa3616/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=2c23db6dd33ea21edc8970449e420eea4eaa3616", "patch": "@@ -4810,36 +4810,76 @@ vect_grouped_load_supported (tree vectype, unsigned HOST_WIDE_INT count)\n {\n   enum machine_mode mode = TYPE_MODE (vectype);\n \n-  /* vect_permute_load_chain requires the group size to be a power of two.  */\n-  if (exact_log2 (count) == -1)\n+  /* vect_permute_load_chain requires the group size to be equal to 3 or\n+     be a power of two.  */\n+  if (count != 3 && exact_log2 (count) == -1)\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                         \"the size of the group of accesses\"\n-                         \" is not a power of 2\\n\");\n+\t\t\t \"the size of the group of accesses\"\n+\t\t\t \" is not a power of 2 or not equal to 3\\n\");\n       return false;\n     }\n \n   /* Check that the permutation is supported.  */\n   if (VECTOR_MODE_P (mode))\n     {\n-      unsigned int i, nelt = GET_MODE_NUNITS (mode);\n+      unsigned int i, j, nelt = GET_MODE_NUNITS (mode);\n       unsigned char *sel = XALLOCAVEC (unsigned char, nelt);\n \n-      for (i = 0; i < nelt; i++)\n-\tsel[i] = i * 2;\n-      if (can_vec_perm_p (mode, false, sel))\n+      if (count == 3)\n \t{\n+\t  unsigned int k;\n+\t  for (k = 0; k < 3; k++)\n+\t    {\n+\t      for (i = 0; i < nelt; i++)\n+\t\tif (3 * i + k < 2 * nelt)\n+\t\t  sel[i] = 3 * i + k;\n+\t\telse\n+\t\t  sel[i] = 0;\n+\t      if (!can_vec_perm_p (mode, false, sel))\n+\t\t{\n+\t\t  if (dump_enabled_p ())\n+\t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t     \"shuffle of 3 loads is not supported by\"\n+\t\t\t\t     \" target\\n\");\n+\t\t    return false;\n+\t\t}\n+\t      for (i = 0, j = 0; i < nelt; i++)\n+\t\tif (3 * i + k < 2 * nelt)\n+\t\t  sel[i] = i;\n+\t\telse\n+\t\t  sel[i] = nelt + ((nelt + k) % 3) + 3 * (j++);\n+\t      if (!can_vec_perm_p (mode, false, sel))\n+\t\t{\n+\t\t  if (dump_enabled_p ())\n+\t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t     \"shuffle of 3 loads is not supported by\"\n+\t\t\t\t     \" target\\n\");\n+\t\t  return false;\n+\t\t}\n+\t    }\n+\t  return true;\n+\t}\n+      else\n+\t{\n+\t  /* If length is not equal to 3 then only power of 2 is supported.  */\n+\t  gcc_assert (exact_log2 (count) != -1);\n \t  for (i = 0; i < nelt; i++)\n-\t    sel[i] = i * 2 + 1;\n+\t    sel[i] = i * 2;\n \t  if (can_vec_perm_p (mode, false, sel))\n-\t    return true;\n-\t}\n+\t    {\n+\t      for (i = 0; i < nelt; i++)\n+\t\tsel[i] = i * 2 + 1;\n+\t      if (can_vec_perm_p (mode, false, sel))\n+\t\treturn true;\n+\t    }\n+        }\n     }\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                     \"extract even/odd not supported by target\\n\");\n+\t\t     \"extract even/odd not supported by target\\n\");\n   return false;\n }\n \n@@ -4857,8 +4897,9 @@ vect_load_lanes_supported (tree vectype, unsigned HOST_WIDE_INT count)\n /* Function vect_permute_load_chain.\n \n    Given a chain of interleaved loads in DR_CHAIN of LENGTH that must be\n-   a power of 2, generate extract_even/odd stmts to reorder the input data\n-   correctly.  Return the final references for loads in RESULT_CHAIN.\n+   a power of 2 or equal to 3, generate extract_even/odd stmts to reorder\n+   the input data correctly.  Return the final references for loads in\n+   RESULT_CHAIN.\n \n    E.g., LENGTH is 4 and the scalar type is short, i.e., VF is 8.\n    The input is 4 vectors each containing 8 elements. We assign a number to each\n@@ -4939,6 +4980,7 @@ vect_permute_load_chain (vec<tree> dr_chain,\n {\n   tree data_ref, first_vect, second_vect;\n   tree perm_mask_even, perm_mask_odd;\n+  tree perm3_mask_low, perm3_mask_high;\n   gimple perm_stmt;\n   tree vectype = STMT_VINFO_VECTYPE (vinfo_for_stmt (stmt));\n   unsigned int i, j, log_length = exact_log2 (length);\n@@ -4949,44 +4991,97 @@ vect_permute_load_chain (vec<tree> dr_chain,\n   memcpy (result_chain->address (), dr_chain.address (),\n \t  length * sizeof (tree));\n \n-  for (i = 0; i < nelt; ++i)\n-    sel[i] = i * 2;\n-  perm_mask_even = vect_gen_perm_mask (vectype, sel);\n-  gcc_assert (perm_mask_even != NULL);\n-\n-  for (i = 0; i < nelt; ++i)\n-    sel[i] = i * 2 + 1;\n-  perm_mask_odd = vect_gen_perm_mask (vectype, sel);\n-  gcc_assert (perm_mask_odd != NULL);\n-\n-  for (i = 0; i < log_length; i++)\n+  if (length == 3)\n     {\n-      for (j = 0; j < length; j += 2)\n-\t{\n-\t  first_vect = dr_chain[j];\n-\t  second_vect = dr_chain[j+1];\n+      unsigned int k;\n \n-\t  /* data_ref = permute_even (first_data_ref, second_data_ref);  */\n-\t  data_ref = make_temp_ssa_name (vectype, NULL, \"vect_perm_even\");\n+      for (k = 0; k < 3; k++)\n+\t{\n+\t  for (i = 0; i < nelt; i++)\n+\t    if (3 * i + k < 2 * nelt)\n+\t      sel[i] = 3 * i + k;\n+\t    else\n+\t      sel[i] = 0;\n+\t  perm3_mask_low = vect_gen_perm_mask (vectype, sel);\n+\t  gcc_assert (perm3_mask_low != NULL);\n+\n+\t  for (i = 0, j = 0; i < nelt; i++)\n+\t    if (3 * i + k < 2 * nelt)\n+\t      sel[i] = i;\n+\t    else\n+\t      sel[i] = nelt + ((nelt + k) % 3) + 3 * (j++);\n+\n+\t  perm3_mask_high = vect_gen_perm_mask (vectype, sel);\n+\t  gcc_assert (perm3_mask_high != NULL);\n+\n+\t  first_vect = dr_chain[0];\n+\t  second_vect = dr_chain[1];\n+\n+\t  /* Create interleaving stmt (low part of):\n+\t     low = VEC_PERM_EXPR <first_vect, second_vect2, {k, 3 + k, 6 + k,\n+\t\t\t\t\t\t\t     ...}>  */\n+\t  data_ref = make_temp_ssa_name (vectype, NULL, \"vect_suffle3_low\");\n \t  perm_stmt = gimple_build_assign_with_ops (VEC_PERM_EXPR, data_ref,\n \t\t\t\t\t\t    first_vect, second_vect,\n-\t\t\t\t\t\t    perm_mask_even);\n+\t\t\t\t\t\t    perm3_mask_low);\n \t  vect_finish_stmt_generation (stmt, perm_stmt, gsi);\n-\t  (*result_chain)[j/2] = data_ref;\n \n-\t  /* data_ref = permute_odd (first_data_ref, second_data_ref);  */\n-\t  data_ref = make_temp_ssa_name (vectype, NULL, \"vect_perm_odd\");\n+\t  /* Create interleaving stmt (high part of):\n+\t     high = VEC_PERM_EXPR <first_vect, second_vect2, {k, 3 + k, 6 + k,\n+\t\t\t\t\t\t\t      ...}>  */\n+\t  first_vect = data_ref;\n+\t  second_vect = dr_chain[2];\n+\t  data_ref = make_temp_ssa_name (vectype, NULL, \"vect_suffle3_high\");\n \t  perm_stmt = gimple_build_assign_with_ops (VEC_PERM_EXPR, data_ref,\n \t\t\t\t\t\t    first_vect, second_vect,\n-\t\t\t\t\t\t    perm_mask_odd);\n+\t\t\t\t\t\t    perm3_mask_high);\n \t  vect_finish_stmt_generation (stmt, perm_stmt, gsi);\n-\t  (*result_chain)[j/2+length/2] = data_ref;\n+\t  (*result_chain)[k] = data_ref;\n \t}\n-      memcpy (dr_chain.address (), result_chain->address (),\n-\t      length * sizeof (tree));\n     }\n-}\n+  else\n+    {\n+      /* If length is not equal to 3 then only power of 2 is supported.  */\n+      gcc_assert (exact_log2 (length) != -1);\n+\n+      for (i = 0; i < nelt; ++i)\n+\tsel[i] = i * 2;\n+      perm_mask_even = vect_gen_perm_mask (vectype, sel);\n+      gcc_assert (perm_mask_even != NULL);\n+\n+      for (i = 0; i < nelt; ++i)\n+\tsel[i] = i * 2 + 1;\n+      perm_mask_odd = vect_gen_perm_mask (vectype, sel);\n+      gcc_assert (perm_mask_odd != NULL);\n \n+      for (i = 0; i < log_length; i++)\n+\t{\n+\t  for (j = 0; j < length; j += 2)\n+\t    {\n+\t      first_vect = dr_chain[j];\n+\t      second_vect = dr_chain[j+1];\n+\n+\t      /* data_ref = permute_even (first_data_ref, second_data_ref);  */\n+\t      data_ref = make_temp_ssa_name (vectype, NULL, \"vect_perm_even\");\n+\t      perm_stmt = gimple_build_assign_with_ops (VEC_PERM_EXPR, data_ref,\n+\t\t\t\t\t\t\tfirst_vect, second_vect,\n+\t\t\t\t\t\t\tperm_mask_even);\n+\t      vect_finish_stmt_generation (stmt, perm_stmt, gsi);\n+\t      (*result_chain)[j/2] = data_ref;\n+\n+\t      /* data_ref = permute_odd (first_data_ref, second_data_ref);  */\n+\t      data_ref = make_temp_ssa_name (vectype, NULL, \"vect_perm_odd\");\n+\t      perm_stmt = gimple_build_assign_with_ops (VEC_PERM_EXPR, data_ref,\n+\t\t\t\t\t\t\tfirst_vect, second_vect,\n+\t\t\t\t\t\t\tperm_mask_odd);\n+\t      vect_finish_stmt_generation (stmt, perm_stmt, gsi);\n+\t      (*result_chain)[j/2+length/2] = data_ref;\n+\t    }\n+\t  memcpy (dr_chain.address (), result_chain->address (),\n+\t\t  length * sizeof (tree));\n+\t}\n+    }\n+}\n \n /* Function vect_transform_grouped_load.\n "}, {"sha": "ec9cc68bfabb07d919494c2464d58ced1e4aacb4", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c23db6dd33ea21edc8970449e420eea4eaa3616/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c23db6dd33ea21edc8970449e420eea4eaa3616/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=2c23db6dd33ea21edc8970449e420eea4eaa3616", "patch": "@@ -1091,10 +1091,11 @@ vect_model_load_cost (stmt_vec_info stmt_info, int ncopies,\n      include the cost of the permutes.  */\n   if (!load_lanes_p && group_size > 1)\n     {\n-      /* Uses an even and odd extract operations for each needed permute.  */\n-      int nstmts = ncopies * exact_log2 (group_size) * group_size;\n-      inside_cost += record_stmt_cost (body_cost_vec, nstmts, vec_perm,\n-\t\t\t\t       stmt_info, 0, vect_body);\n+      /* Uses an even and odd extract operations or shuffle operations\n+\t for each needed permute.  */\n+      int nstmts = ncopies * ceil_log2 (group_size) * group_size;\n+      inside_cost = record_stmt_cost (body_cost_vec, nstmts, vec_perm,\n+\t\t\t\t      stmt_info, 0, vect_body);\n \n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,"}]}