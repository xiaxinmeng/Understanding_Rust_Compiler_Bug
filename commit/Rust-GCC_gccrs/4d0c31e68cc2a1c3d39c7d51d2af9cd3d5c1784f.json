{"sha": "4d0c31e68cc2a1c3d39c7d51d2af9cd3d5c1784f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQwYzMxZTY4Y2MyYTFjM2QzOWM3ZDUxZDJhZjljZDNkNWMxNzg0Zg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-03-11T03:19:04Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-03-11T03:19:04Z"}, "message": "c-pch.c (c_common_no_more_pch): Update for gt_pch_use_address extra arguments.\n\n        * c-pch.c (c_common_no_more_pch): Update for gt_pch_use_address\n        extra arguments.\n        * config.host (*-*-solaris2*, *-*-linux*): Add out_host_hook_obj\n        and host_xmake_file fragments.\n        * ggc-common.c (gt_pch_save): Update for gt_pch_get_address change.\n        (gt_pch_restore): Similarly for gt_pch_use_address.\n        (default_gt_pch_get_address): New.\n        (mmap_gt_pch_get_address): Split out of gt_pch_save.\n        (default_gt_pch_use_address): Split out of gt_pch_restore.\n        (mmap_gt_pch_use_address): Likewise.\n        * hooks.c (hook_voidp_size_t_null): Remove.\n        (hook_bool_voidp_size_t_false): Remove.\n        * hooks.h: Likewise.\n        * hosthooks-def.h (HOST_HOOKS_GT_PCH_GET_ADDRESS): Use one of the\n        default_ or mmap_ definitions.\n        (HOST_HOOKS_GT_PCH_USE_ADDRESS): Likewise.\n        * hosthooks.h (struct host_hooks): Update gt_pch_get_address\n        and gt_pch_use_address.\n        * config/host-linux.c, config/host-solaris.c: New files.\n        * config/x-linux, config/x-solaris: New files.\n        * config/rs6000/host-darwin.c darwin_rs6000_gt_pch_get_address):\n        Update for changed definition.\n        (darwin_rs6000_gt_pch_use_address): Likewise.\n        * doc/hostconfig.texi: Update docs.\n\nFrom-SVN: r79295", "tree": {"sha": "1bfb02abe9d554906754df59966f7f6a0f7158fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1bfb02abe9d554906754df59966f7f6a0f7158fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d0c31e68cc2a1c3d39c7d51d2af9cd3d5c1784f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d0c31e68cc2a1c3d39c7d51d2af9cd3d5c1784f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d0c31e68cc2a1c3d39c7d51d2af9cd3d5c1784f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d0c31e68cc2a1c3d39c7d51d2af9cd3d5c1784f/comments", "author": null, "committer": null, "parents": [{"sha": "20475e78e413a8a3327022a0b88da88b55819842", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20475e78e413a8a3327022a0b88da88b55819842", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20475e78e413a8a3327022a0b88da88b55819842"}], "stats": {"total": 562, "additions": 400, "deletions": 162}, "files": [{"sha": "4dd705f425c4cca6e663b72213bd4a171def4b6d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d0c31e68cc2a1c3d39c7d51d2af9cd3d5c1784f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d0c31e68cc2a1c3d39c7d51d2af9cd3d5c1784f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4d0c31e68cc2a1c3d39c7d51d2af9cd3d5c1784f", "patch": "@@ -1,3 +1,30 @@\n+2004-03-10  Richard Henderson  <rth@redhat.com>\n+\n+\t* c-pch.c (c_common_no_more_pch): Update for gt_pch_use_address\n+\textra arguments.\n+\t* config.host (*-*-solaris2*, *-*-linux*): Add out_host_hook_obj\n+\tand host_xmake_file fragments.\n+\t* ggc-common.c (gt_pch_save): Update for gt_pch_get_address change.\n+\t(gt_pch_restore): Similarly for gt_pch_use_address.\n+\t(default_gt_pch_get_address): New.\n+\t(mmap_gt_pch_get_address): Split out of gt_pch_save.\n+\t(default_gt_pch_use_address): Split out of gt_pch_restore.\n+\t(mmap_gt_pch_use_address): Likewise.\n+\t* hooks.c (hook_voidp_size_t_null): Remove.\n+\t(hook_bool_voidp_size_t_false): Remove.\n+\t* hooks.h: Likewise.\n+\t* hosthooks-def.h (HOST_HOOKS_GT_PCH_GET_ADDRESS): Use one of the\n+\tdefault_ or mmap_ definitions.\n+\t(HOST_HOOKS_GT_PCH_USE_ADDRESS): Likewise.\n+\t* hosthooks.h (struct host_hooks): Update gt_pch_get_address\n+\tand gt_pch_use_address.\n+\t* config/host-linux.c, config/host-solaris.c: New files.\n+\t* config/x-linux, config/x-solaris: New files.\n+\t* config/rs6000/host-darwin.c darwin_rs6000_gt_pch_get_address): \n+\tUpdate for changed definition.\n+\t(darwin_rs6000_gt_pch_use_address): Likewise.\n+\t* doc/hostconfig.texi: Update docs.\n+\n 2004-03-10  Richard Henderson  <rth@redhat.com>\n \n \tPR c/14517"}, {"sha": "cf738759ee4d5bc19630513b70da5e344b520ee4", "filename": "gcc/c-pch.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d0c31e68cc2a1c3d39c7d51d2af9cd3d5c1784f/gcc%2Fc-pch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d0c31e68cc2a1c3d39c7d51d2af9cd3d5c1784f/gcc%2Fc-pch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pch.c?ref=4d0c31e68cc2a1c3d39c7d51d2af9cd3d5c1784f", "patch": "@@ -401,6 +401,6 @@ c_common_no_more_pch (void)\n   if (cpp_get_callbacks (parse_in)->valid_pch)\n     {\n       cpp_get_callbacks (parse_in)->valid_pch = NULL;\n-      host_hooks.gt_pch_use_address (NULL, 0);\n+      host_hooks.gt_pch_use_address (NULL, 0, -1, 0);\n     }\n }"}, {"sha": "19566518810f091e80c29b927f43ff8c7ab5b87d", "filename": "gcc/config.host", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d0c31e68cc2a1c3d39c7d51d2af9cd3d5c1784f/gcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d0c31e68cc2a1c3d39c7d51d2af9cd3d5c1784f/gcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.host?ref=4d0c31e68cc2a1c3d39c7d51d2af9cd3d5c1784f", "patch": "@@ -113,6 +113,8 @@ case ${host} in\n     ;;\n   i[34567]86-*-solaris2*)\n     host_xm_defines=\"SMALL_ARG_MAX\"\n+    out_host_hook_obj=host-solaris.o\n+    host_xmake_file=x-solaris\n     ;;\n   i[34567]86-*-sysv4*) # Intel 80386's running System V Release 4\n     host_xm_defines=\"SMALL_ARG_MAX\"\n@@ -152,4 +154,12 @@ case ${host} in\n     out_host_hook_obj=host-darwin.o\n     host_xmake_file=rs6000/x-darwin\n     ;;\n+  *-*-solaris2*)\n+    out_host_hook_obj=host-solaris.o\n+    host_xmake_file=x-solaris\n+    ;;\n+  *-*-linux*)\n+    out_host_hook_obj=host-linux.o\n+    host_xmake_file=x-linux\n+    ;;\n esac"}, {"sha": "7302d381dbe9730d90ec355f8633dd8fc7b3f13d", "filename": "gcc/config/host-linux.c", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d0c31e68cc2a1c3d39c7d51d2af9cd3d5c1784f/gcc%2Fconfig%2Fhost-linux.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d0c31e68cc2a1c3d39c7d51d2af9cd3d5c1784f/gcc%2Fconfig%2Fhost-linux.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fhost-linux.c?ref=4d0c31e68cc2a1c3d39c7d51d2af9cd3d5c1784f", "patch": "@@ -0,0 +1,137 @@\n+/* Linux host-specific hook definitions.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 2, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the\n+   Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include <sys/mman.h>\n+#include \"hosthooks.h\"\n+#include \"hosthooks-def.h\"\n+\n+\n+/* Linux has a feature called exec-shield-randomize that perturbs the\n+   address of non-fixed mapped segments by a (relatively) small amount.\n+   The feature is intended to make it harder to attack the system with\n+   buffer overflow attacks, since every invocation of a program will\n+   have its libraries and data segments at slightly different addresses.\n+\n+   This feature causes us problems with PCH because it makes it that\n+   much harder to acquire a stable location at which to map our PCH\n+   data file.\n+\n+   [ The feature causes other points of non-determinism within the\n+     compiler as well, so we'd *really* like to be able to have the\n+     driver disable exec-shield-randomize for the process group, but\n+     that isn't possible at present.  ]\n+\n+   We're going to try several things:\n+\n+      * Select an architecture specific address as \"likely\" and see\n+\tif that's free.  For our 64-bit hosts, we can easily choose\n+\tan address in Never Never Land.\n+\n+      * If exec-shield-randomize is disabled, then just use the\n+\taddress chosen by mmap in step one.\n+\n+      * If exec-shield-randomize is enabled, then temporarily allocate\n+\t32M of memory as a buffer, then allocate PCH memory, then\n+\tfree the buffer.  The theory here is that the perturbation is\n+\tno more than 16M, and so by allocating our buffer larger than\n+\tthat we make it considerably more likely that the address will\n+\tbe free when we want to load the data back.\n+*/\n+\n+#undef HOST_HOOKS_GT_PCH_GET_ADDRESS\n+#define HOST_HOOKS_GT_PCH_GET_ADDRESS linux_gt_pch_get_address\n+\n+/* For various ports, try to guess a fixed spot in the vm space\n+   that's probably free.  */\n+#if defined(__alpha)\n+# define TRY_EMPTY_VM_SPACE\t0x10000000000\n+#elif defined(__ia64)\n+# define TRY_EMPTY_VM_SPACE\t0x2000000100000000\n+#elif defined(__x86_64)\n+# define TRY_EMPTY_VM_SPACE\t0x1000000000\n+#elif defined(__i386)\n+# define TRY_EMPTY_VM_SPACE\t0x60000000\n+#else\n+# define TRY_EMPTY_VM_SPACE\t0\n+#endif\n+\n+/* Determine a location where we might be able to reliably allocate SIZE\n+   bytes.  FD is the PCH file, though we should return with the file \n+   unmapped.  */\n+\n+static void *\n+linux_gt_pch_get_address (size_t size, int fd)\n+{\n+  size_t buffer_size = 32 * 1024 * 1024;\n+  void *addr, *buffer;\n+  FILE *f;\n+  bool randomize_on;\n+\n+  addr = mmap ((void *)TRY_EMPTY_VM_SPACE, size, PROT_READ | PROT_WRITE,\n+\t       MAP_PRIVATE, fd, 0);\n+\n+  /* If we failed the map, that means there's *no* free space.  */\n+  if (addr == (void *) MAP_FAILED)\n+    return NULL;\n+  /* Unmap the area before returning.  */\n+  munmap (addr, size);\n+\n+  /* If we got the exact area we requested, then that's great.  */\n+  if (TRY_EMPTY_VM_SPACE && addr == (void *) TRY_EMPTY_VM_SPACE)\n+    return addr;\n+\n+  /* If we didn't, then we need to look to see if randomization is on.  */\n+  f = fopen (\"/proc/sys/kernel/exec-shield-randomize\", \"r\");\n+  randomize_on = false;\n+  if (f != NULL)\n+    {\n+      char buf[100];\n+      size_t c;\n+\n+      c = fread (buf, 1, sizeof buf - 1, f);\n+      if (c > 0)\n+\t{\n+\t  buf[c] = '\\0';\n+\t  randomize_on = (atoi (buf) > 0);\n+\t}\n+      fclose (f);\n+    }\n+\n+  /* If it isn't, then accept the address that mmap selected as fine.  */\n+  if (!randomize_on)\n+    return addr;\n+\n+  /* Otherwise, we need to try again with buffer space.  */\n+  buffer = mmap (0, buffer_size, PROT_NONE, MAP_PRIVATE | MAP_ANON, -1, 0);\n+  addr = mmap (0, size, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);\n+  if (buffer != (void *) MAP_FAILED)\n+    munmap (buffer, buffer_size);\n+  if (addr == (void *) MAP_FAILED)\n+    return NULL;\n+  munmap (addr, size);\n+\n+  return addr;\n+}\n+\n+\f\n+const struct host_hooks host_hooks = HOST_HOOKS_INITIALIZER;"}, {"sha": "43efc5c23e92333fb47e1c2f8c2c85d6cbfaa355", "filename": "gcc/config/host-solaris.c", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d0c31e68cc2a1c3d39c7d51d2af9cd3d5c1784f/gcc%2Fconfig%2Fhost-solaris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d0c31e68cc2a1c3d39c7d51d2af9cd3d5c1784f/gcc%2Fconfig%2Fhost-solaris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fhost-solaris.c?ref=4d0c31e68cc2a1c3d39c7d51d2af9cd3d5c1784f", "patch": "@@ -0,0 +1,79 @@\n+/* Solaris host-specific hook definitions.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 2, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the\n+   Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include <sys/mman.h>\n+#include \"hosthooks.h\"\n+#include \"hosthooks-def.h\"\n+\n+\n+#undef HOST_HOOKS_GT_PCH_USE_ADDRESS\n+#define HOST_HOOKS_GT_PCH_USE_ADDRESS sol_gt_pch_use_address\n+\n+/* Map SIZE bytes of FD+OFFSET at BASE.  Return 1 if we succeeded at \n+   mapping the data at BASE, -1 if we couldn't.  */\n+\n+static int\n+sol_gt_pch_use_address (void *base, size_t size, int fd, size_t offset)\n+{\n+  void *addr;\n+\n+  /* We're called with size == 0 if we're not planning to load a PCH\n+     file at all.  This allows the hook to free any static space that\n+     we might have allocated at link time.  */\n+  if (size == 0)\n+    return -1;\n+\n+  addr = mmap (base, size, PROT_READ | PROT_WRITE, MAP_PRIVATE,\n+\t       fd, offset);\n+\n+  /* Solaris isn't good about honoring the mmap START parameter\n+     without MAP_FIXED set.  Before we give up, search the desired\n+     address space with mincore to see if the space is really free.\n+  if (addr != base)\n+    {\n+      size_t page_size = getpagesize();\n+      char one_byte;\n+      size_t i;\n+\n+      if (addr != (void *) MAP_FAILED)\n+\tmunmap (addr, size);\n+\n+      errno = 0;\n+      for (i = 0; i < size; i += page_size)\n+\tif (mincore ((char *)base + i, page_size, (void *)&one_byte) == -1\n+\t    && errno == ENOMEM)\n+\t  continue; /* The page is not mapped.  */\n+\telse\n+\t  break;\n+\n+      if (i >= size)\n+\taddr = mmap (base, size, \n+\t\t     PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_FIXED,\n+\t\t     fd, offset);\n+    }\n+\n+  return addr == base ? 1 : -1;\n+}\n+\n+\f\n+const struct host_hooks host_hooks = HOST_HOOKS_INITIALIZER;"}, {"sha": "1699d48856046cd319fa45698d149b3f0a368aeb", "filename": "gcc/config/rs6000/host-darwin.c", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d0c31e68cc2a1c3d39c7d51d2af9cd3d5c1784f/gcc%2Fconfig%2Frs6000%2Fhost-darwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d0c31e68cc2a1c3d39c7d51d2af9cd3d5c1784f/gcc%2Fconfig%2Frs6000%2Fhost-darwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fhost-darwin.c?ref=4d0c31e68cc2a1c3d39c7d51d2af9cd3d5c1784f", "patch": "@@ -137,22 +137,18 @@ darwin_rs6000_extra_signals (void)\n     fatal_error (\"While setting up signal handler: %m\");\n }\n \f\n-static void * darwin_rs6000_gt_pch_get_address (size_t);\n-static bool darwin_rs6000_gt_pch_use_address (void *, size_t);\n-\n #undef HOST_HOOKS_GT_PCH_GET_ADDRESS\n #define HOST_HOOKS_GT_PCH_GET_ADDRESS darwin_rs6000_gt_pch_get_address\n #undef HOST_HOOKS_GT_PCH_USE_ADDRESS\n #define HOST_HOOKS_GT_PCH_USE_ADDRESS darwin_rs6000_gt_pch_use_address\n \n-\n /* Yes, this is really supposed to work.  */\n static char pch_address_space[1024*1024*1024] __attribute__((aligned (4096)));\n \n /* Return the address of the PCH address space, if the PCH will fit in it.  */\n \n static void *\n-darwin_rs6000_gt_pch_get_address (size_t sz)\n+darwin_rs6000_gt_pch_get_address (size_t sz, int fd ATTRIBUTE_UNUSED)\n {\n   if (sz <= sizeof (pch_address_space))\n     return pch_address_space;\n@@ -163,11 +159,12 @@ darwin_rs6000_gt_pch_get_address (size_t sz)\n /* Check ADDR and SZ for validity, and deallocate (using munmap) that part of\n    pch_address_space beyond SZ.  */\n \n-static bool\n-darwin_rs6000_gt_pch_use_address (void *addr, size_t sz)\n+static int\n+darwin_rs6000_gt_pch_use_address (void *addr, size_t sz, int fd, size_t off)\n {\n   const size_t pagesize = getpagesize();\n-  bool result;\n+  void *mmap_result;\n+  int ret;\n \n   if ((size_t)pch_address_space % pagesize != 0\n       || sizeof (pch_address_space) % pagesize != 0)\n@@ -183,7 +180,19 @@ darwin_rs6000_gt_pch_use_address (void *addr, size_t sz)\n   if (munmap (pch_address_space + sz, sizeof (pch_address_space) - sz) != 0)\n     fatal_error (\"couldn't unmap pch_address_space: %m\\n\");\n \n-  return result;\n+  mmap_result = mmap (addr, sz,\n+\t\t      PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_FIXED,\n+\t\t      fd, off);\n+\n+  /* The file might not be mmap-able.  */\n+  ret = mmap_result == (void *) MAP_FAILED;\n+\n+  /* Sanity check for broken MAP_FIXED.  */\n+  if (ret && mmap_result != base)\n+    abort ();\n+\n+  return ret;\n }\n+\f\n \n const struct host_hooks host_hooks = HOST_HOOKS_INITIALIZER;"}, {"sha": "d14586b0b363306d5f00817769dfcf5c34e612a2", "filename": "gcc/config/x-linux", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d0c31e68cc2a1c3d39c7d51d2af9cd3d5c1784f/gcc%2Fconfig%2Fx-linux", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d0c31e68cc2a1c3d39c7d51d2af9cd3d5c1784f/gcc%2Fconfig%2Fx-linux", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fx-linux?ref=4d0c31e68cc2a1c3d39c7d51d2af9cd3d5c1784f", "patch": "@@ -0,0 +1,4 @@\n+host-linux.o : $(srcdir)/config/host-linux.c $(CONFIG_H) $(SYSTEM_H) \\\n+  coretypes.h hosthooks.h hosthooks-def.h\n+\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n+\t\t$(srcdir)/config/host-linux.c"}, {"sha": "782f4a3680250bcd6bb5faf6c04ca69bfd8c870e", "filename": "gcc/config/x-solaris", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d0c31e68cc2a1c3d39c7d51d2af9cd3d5c1784f/gcc%2Fconfig%2Fx-solaris", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d0c31e68cc2a1c3d39c7d51d2af9cd3d5c1784f/gcc%2Fconfig%2Fx-solaris", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fx-solaris?ref=4d0c31e68cc2a1c3d39c7d51d2af9cd3d5c1784f", "patch": "@@ -0,0 +1,4 @@\n+host-solaris.o : $(srcdir)/config/host-solaris.c $(CONFIG_H) $(SYSTEM_H) \\\n+  coretypes.h hosthooks.h hosthooks-def.h\n+\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n+\t\t$(srcdir)/config/host-solaris.c"}, {"sha": "8830c6b8ac1af74244b791a743f77877a52ceecd", "filename": "gcc/doc/hostconfig.texi", "status": "modified", "additions": 20, "deletions": 24, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d0c31e68cc2a1c3d39c7d51d2af9cd3d5c1784f/gcc%2Fdoc%2Fhostconfig.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d0c31e68cc2a1c3d39c7d51d2af9cd3d5c1784f/gcc%2Fdoc%2Fhostconfig.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fhostconfig.texi?ref=4d0c31e68cc2a1c3d39c7d51d2af9cd3d5c1784f", "patch": "@@ -42,35 +42,31 @@ This host hook is used to set up handling for extra signals.  The most\n common thing to do in this hook is to detect stack overflow.\n @end deftypefn\n \n-@deftypefn {Host Hook} void * HOST_HOOKS_GT_PCH_GET_ADDRESS (size_t @var{size})\n-This host hook returns the address of some space in which a PCH may be\n-loaded with @samp{HOST_HOOKS_PCH_LOAD_PCH}.  The space will need to\n-have @var{size} bytes.  If insufficient space is available,\n-@samp{NULL} may be returned; the PCH machinery will try to find a\n-suitable address using a heuristic.\n-\n-The memory does not have to be available now.  In fact, usually\n-@samp{HOST_HOOKS_PCH_LOAD_PCH} will already have been called.  The memory\n-need only be available in future invocations of GCC.\n+@deftypefn {Host Hook} void * HOST_HOOKS_GT_PCH_GET_ADDRESS (size_t @var{size}, int @var{fd})\n+This host hook returns the address of some space that is likely to be\n+free in some subsequent invocation of the compiler.  We intend to load\n+the PCH data at this address such that the data need not be relocated.\n+The area should be able to hold @var{size} bytes.  If the host uses\n+@code{mmap}, @var{fd} is an open file descriptor that can be used for\n+probing.\n @end deftypefn\n \n-@deftypefn {Host Hook} bool HOST_HOOKS_GT_PCH_USE_ADDRESS (size_t @var{size}, void * @var{address})\n-This host hook is called when a PCH file is about to be loaded.  If\n-@var{address} is the address that would have been returned by\n-@samp{HOST_HOOKS_PCH_MEMORY_ADDRESS}, and @var{size} is smaller than\n-the maximum than @samp{HOST_HOOKS_PCH_MEMORY_ADDRESS} would have\n-accepted, return true, otherwise return false.\n+@deftypefn {Host Hook} int HOST_HOOKS_GT_PCH_USE_ADDRESS (void * @var{address}, size_t @var{size}, int @var{fd}, size_t @var{offset})\n+This host hook is called when a PCH file is about to be loaded.\n+We want to load @var{size} bytes from @var{fd} at @var{offset}\n+into memory at @var{address}.  The given address will be the result of\n+a previous invocation of @code{HOST_HOOKS_GT_PCH_GET_ADDRESS}.\n+Return @minus{}1 if we couldn't allocate @var{size} bytes at @var{address}.\n+Return 0 if the memory is allocated but the data is not loaded.  Return 1\n+if the hook has performed everything.\n \n-In addition, free any address space reserved that isn't needed to hold\n-@var{size} bytes (whether or not true is returned).  The PCH machinery will\n-use @samp{mmap} with @samp{MAP_FIXED} to load the PCH if @samp{HAVE_MMAP_FILE},\n-or will use @samp{fread} otherwise.\n-\n-If no PCH will be loaded, this hook may be called with @var{size}\n-zero, in which case all reserved address space should be freed.\n+If the implementation uses reserved address space, free any reserved\n+space beyond @var{size}, regardless of the return value.  If no PCH will\n+be loaded, this hook may be called with @var{size} zero, in which case\n+all reserved address space should be freed.\n \n Do not try to handle values of @var{address} that could not have been\n-returned by this executable; just return false.  Such values usually\n+returned by this executable; just return @minus{}1.  Such values usually\n indicate an out-of-date PCH file (built by some other GCC executable),\n and such a PCH file won't work.\n @end deftypefn"}, {"sha": "d8a803979c72ced7ca25e761d2d5825dc1949d76", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 78, "deletions": 107, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d0c31e68cc2a1c3d39c7d51d2af9cd3d5c1784f/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d0c31e68cc2a1c3d39c7d51d2af9cd3d5c1784f/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=4d0c31e68cc2a1c3d39c7d51d2af9cd3d5c1784f", "patch": "@@ -30,6 +30,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"toplev.h\"\n #include \"params.h\"\n #include \"hosthooks.h\"\n+#include \"hosthooks-def.h\"\n \n #ifdef HAVE_SYS_RESOURCE_H\n # include <sys/resource.h>\n@@ -459,21 +460,8 @@ gt_pch_save (FILE *f)\n      and on the rest it's a lot of work to do better.  \n      (The extra work goes in HOST_HOOKS_GT_PCH_GET_ADDRESS and\n      HOST_HOOKS_GT_PCH_USE_ADDRESS.)  */\n-  mmi.preferred_base = host_hooks.gt_pch_get_address (mmi.size);\n+  mmi.preferred_base = host_hooks.gt_pch_get_address (mmi.size, fileno (f));\n       \n-#if HAVE_MMAP_FILE\n-  if (mmi.preferred_base == NULL)\n-    {\n-      mmi.preferred_base = mmap (NULL, mmi.size,\n-\t\t\t\t PROT_READ | PROT_WRITE, MAP_PRIVATE,\n-\t\t\t\t fileno (state.f), 0);\n-      if (mmi.preferred_base == (void *) MAP_FAILED)\n-\tmmi.preferred_base = NULL;\n-      else\n-\tmunmap (mmi.preferred_base, mmi.size);\n-    }\n-#endif /* HAVE_MMAP_FILE */\n-\n   ggc_pch_this_base (state.d, mmi.preferred_base);\n \n   state.ptrs = xmalloc (state.count * sizeof (*state.ptrs));\n@@ -527,7 +515,8 @@ gt_pch_save (FILE *f)\n \t\t\t\t  state.ptrs[i]->note_ptr_cookie,\n \t\t\t\t  relocate_ptrs, &state);\n       ggc_pch_write_object (state.d, state.f, state.ptrs[i]->obj,\n-\t\t\t    state.ptrs[i]->new_addr, state.ptrs[i]->size, state.ptrs[i]->note_ptr_fn == gt_pch_p_S);\n+\t\t\t    state.ptrs[i]->new_addr, state.ptrs[i]->size,\n+\t\t\t    state.ptrs[i]->note_ptr_fn == gt_pch_p_S);\n       if (state.ptrs[i]->note_ptr_fn != gt_pch_p_S)\n \tmemcpy (state.ptrs[i]->obj, this_object, state.ptrs[i]->size);\n     }\n@@ -547,8 +536,7 @@ gt_pch_restore (FILE *f)\n   const struct ggc_root_tab *rti;\n   size_t i;\n   struct mmap_info mmi;\n-  void *addr;\n-  bool needs_read;\n+  int result;\n \n   /* Delete any deletable objects.  This makes ggc_pch_read much\n      faster, as it can be sure that no GCable objects remain other\n@@ -581,111 +569,94 @@ gt_pch_restore (FILE *f)\n   if (fread (&mmi, sizeof (mmi), 1, f) != 1)\n     fatal_error (\"can't read PCH file: %m\");\n \n-  if (host_hooks.gt_pch_use_address (mmi.preferred_base, mmi.size))\n+  result = host_hooks.gt_pch_use_address (mmi.preferred_base, mmi.size,\n+\t\t\t\t\t  fileno (f), mmi.offset);\n+  if (result < 0)\n+    fatal_error (\"had to relocate PCH\");\n+  if (result == 0)\n     {\n-#if HAVE_MMAP_FILE\n-      void *mmap_result;\n+      if (fseek (f, mmi.offset, SEEK_SET) != 0\n+\t  || fread (mmi.preferred_base, mmi.size, 1, f) != 1)\n+\tfatal_error (\"can't read PCH file: %m\");\n+    }\n+  else if (fseek (f, mmi.offset + mmi.size, SEEK_SET) != 0)\n+    fatal_error (\"can't read PCH file: %m\");\n \n-      mmap_result = mmap (mmi.preferred_base, mmi.size,\n-\t\t\t  PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_FIXED,\n-\t\t\t  fileno (f), mmi.offset);\n+  ggc_pch_read (f, mmi.preferred_base);\n \n-      /* The file might not be mmap-able.  */\n-      needs_read = mmap_result == (void *) MAP_FAILED;\n+  gt_pch_restore_stringpool ();\n+}\n \n-      /* Sanity check for broken MAP_FIXED.  */\n-      if (! needs_read && mmap_result != mmi.preferred_base)\n-\tabort ();\n-#else\n-      needs_read = true;\n-#endif\n-      addr = mmi.preferred_base;\n-    }\n-  else\n-    {\n-#if HAVE_MMAP_FILE\n-      addr = mmap (mmi.preferred_base, mmi.size,\n-\t\t   PROT_READ | PROT_WRITE, MAP_PRIVATE,\n-\t\t   fileno (f), mmi.offset);\n+/* Default version of HOST_HOOKS_GT_PCH_GET_ADDRESS when mmap is not present.\n+   Select no address whatsoever, and let gt_pch_save choose what it will with\n+   malloc, presumably.  */\n \n-#if HAVE_MINCORE\n-      if (addr != mmi.preferred_base)\n-\t{\n-\t  size_t page_size = getpagesize();\n-\t  char one_byte;\n-\n-\t  /* We really want to be mapped at mmi.preferred_base\n-\t     so we're going to resort to MAP_FIXED.  But before,\n-\t     make sure that we can do so without destroying a\n-\t     previously mapped area, by looping over all pages\n-\t     that would be affected by the fixed mapping.  */\n-\t  errno = 0;\n-\n-\t  for (i = 0; i < mmi.size; i+= page_size)\n-\t    if (mincore ((char *)mmi.preferred_base + i, page_size, \n-\t\t\t (void *)&one_byte) == -1\n-\t\t&& errno == ENOMEM)\n-\t      continue; /* The page is not mapped.  */\n-\t    else\n-\t      break;\n-\n-\t  if (i >= mmi.size)\n-\t    {\n-\t      if (addr != (void *) MAP_FAILED)\n-\t\tmunmap (addr, mmi.size);\n+void *\n+default_gt_pch_get_address (size_t size ATTRIBUTE_UNUSED,\n+\t\t\t    int fd ATTRIBUTE_UNUSED)\n+{\n+  return NULL;\n+}\n \n-\t      addr = mmap (mmi.preferred_base, mmi.size, \n-\t\t\t   PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_FIXED,\n-\t\t\t   fileno (f), mmi.offset);\n-\t    }\n-\t}\n-#endif /* HAVE_MINCORE */\n+/* Default version of HOST_HOOKS_GT_PCH_USE_ADDRESS when mmap is not present.\n+   Allocate SIZE bytes with malloc.  Return 0 if the address we got is the\n+   same as base, indicating that the memory has been allocated but needs to\n+   be read in from the file.  Return -1 if the address differs, to relocation\n+   of the PCH file would be required.  */\n+\n+int\n+default_gt_pch_use_address (void *base, size_t size, int fd ATTRIBUTE_UNUSED,\n+\t\t\t    size_t offset ATTRIBUTE_UNUSED)\n+{\n+  void *addr = xmalloc (size);\n+  return (addr == base) - 1;\n+}\n \n-      needs_read = addr == (void *) MAP_FAILED;\n+#if HAVE_MMAP_FILE\n+/* Default version of HOST_HOOKS_GT_PCH_GET_ADDRESS when mmap is present.\n+   We temporarily allocate SIZE bytes, and let the kernel place the data\n+   whereever it will.  If it worked, that's our spot, if not we're likely\n+   to be in trouble.  */\n \n-#else /* HAVE_MMAP_FILE */\n-      needs_read = true;\n-#endif /* HAVE_MMAP_FILE */\n-      if (needs_read)\n-\taddr = xmalloc (mmi.size);\n-    }\n+void *\n+mmap_gt_pch_get_address (size_t size, int fd)\n+{\n+  void *ret;\n \n-  if (needs_read)\n-    {\n-      if (fseek (f, mmi.offset, SEEK_SET) != 0\n-\t  || fread (addr, mmi.size, 1, f) != 1)\n-\tfatal_error (\"can't read PCH file: %m\");\n-    }\n-  else if (fseek (f, mmi.offset + mmi.size, SEEK_SET) != 0)\n-    fatal_error (\"can't read PCH file: %m\");\n+  ret = mmap (NULL, size, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);\n+  if (ret == (void *) MAP_FAILED)\n+    ret = NULL;\n+  else\n+    munmap (ret, size);\n \n-  ggc_pch_read (f, addr);\n+  return ret;\n+}\n \n-  if (addr != mmi.preferred_base)\n-    {\n-      for (rt = gt_ggc_rtab; *rt; rt++)\n-\tfor (rti = *rt; rti->base != NULL; rti++)\n-\t  for (i = 0; i < rti->nelt; i++)\n-\t    {\n-\t      char **ptr = (char **)((char *)rti->base + rti->stride * i);\n-\t      if (*ptr != NULL)\n-\t\t*ptr += (size_t)addr - (size_t)mmi.preferred_base;\n-\t    }\n+/* Default version of HOST_HOOKS_GT_PCH_USE_ADDRESS when mmap is present.\n+   Map SIZE bytes of FD+OFFSET at BASE.  Return 1 if we succeeded at \n+   mapping the data at BASE, -1 if we couldn't.\n \n-      for (rt = gt_pch_cache_rtab; *rt; rt++)\n-\tfor (rti = *rt; rti->base != NULL; rti++)\n-\t  for (i = 0; i < rti->nelt; i++)\n-\t    {\n-\t      char **ptr = (char **)((char *)rti->base + rti->stride * i);\n-\t      if (*ptr != NULL)\n-\t\t*ptr += (size_t)addr - (size_t)mmi.preferred_base;\n-\t    }\n+   This version assumes that the kernel honors the START operand of mmap\n+   even without MAP_FIXED if START through START+SIZE are not currently\n+   mapped with something.  */\n \n-      fatal_error (\"had to relocate PCH\");\n-    }\n+int\n+mmap_gt_pch_use_address (void *base, size_t size, int fd, size_t offset)\n+{\n+  void *addr;\n \n-  gt_pch_restore_stringpool ();\n+  /* We're called with size == 0 if we're not planning to load a PCH\n+     file at all.  This allows the hook to free any static space that\n+     we might have allocated at link time.  */\n+  if (size == 0)\n+    return -1;\n+\n+  addr = mmap (base, size, PROT_READ | PROT_WRITE, MAP_PRIVATE,\n+\t       fd, offset);\n+\n+  return addr == base ? 1 : -1;\n }\n+#endif /* HAVE_MMAP_FILE */\n \n /* Modify the bound based on rlimits.  Keep the smallest number found.  */\n static double"}, {"sha": "5b9bb653996b85646cf7ba58fdf18a956850c564", "filename": "gcc/hooks.c", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d0c31e68cc2a1c3d39c7d51d2af9cd3d5c1784f/gcc%2Fhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d0c31e68cc2a1c3d39c7d51d2af9cd3d5c1784f/gcc%2Fhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.c?ref=4d0c31e68cc2a1c3d39c7d51d2af9cd3d5c1784f", "patch": "@@ -205,21 +205,6 @@ hook_rtx_tree_int_null (tree a ATTRIBUTE_UNUSED, int b ATTRIBUTE_UNUSED)\n   return NULL;\n }\n \n-/* Generic hook that takes a size_t and returns NULL.  */\n-void *\n-hook_voidp_size_t_null (size_t a ATTRIBUTE_UNUSED)\n-{\n-  return NULL;\n-}\n-\n-/* Generic hook that takes a size_t and a pointer and returns false.  */\n-bool\n-hook_bool_voidp_size_t_false (void * a ATTRIBUTE_UNUSED,\n-\t\t\t      size_t b ATTRIBUTE_UNUSED)\n-{\n-  return false;\n-}\n-\n /* Generic hook that takes a tree and returns it as is.  */\n tree\n hook_tree_tree_identity (tree a)"}, {"sha": "824683b4cf4eeed604e183e615a04e4965b4d1aa", "filename": "gcc/hooks.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d0c31e68cc2a1c3d39c7d51d2af9cd3d5c1784f/gcc%2Fhooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d0c31e68cc2a1c3d39c7d51d2af9cd3d5c1784f/gcc%2Fhooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.h?ref=4d0c31e68cc2a1c3d39c7d51d2af9cd3d5c1784f", "patch": "@@ -57,8 +57,6 @@ extern bool hook_bool_tree_tree_false (tree, tree);\n extern rtx hook_rtx_rtx_identity (rtx);\n extern rtx hook_rtx_rtx_null (rtx);\n extern rtx hook_rtx_tree_int_null (tree, int);\n-extern void * hook_voidp_size_t_null (size_t);\n-extern bool hook_bool_voidp_size_t_false (void *, size_t);\n extern tree hook_tree_tree_identity (tree a);\n \n #endif"}, {"sha": "537ac6f262432e5761ae70f4a7452fe534a44449", "filename": "gcc/hosthooks-def.h", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d0c31e68cc2a1c3d39c7d51d2af9cd3d5c1784f/gcc%2Fhosthooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d0c31e68cc2a1c3d39c7d51d2af9cd3d5c1784f/gcc%2Fhosthooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhosthooks-def.h?ref=4d0c31e68cc2a1c3d39c7d51d2af9cd3d5c1784f", "patch": "@@ -24,8 +24,18 @@ Boston, MA 02111-1307, USA.  */\n #include \"hooks.h\"\n \n #define HOST_HOOKS_EXTRA_SIGNALS hook_void_void\n-#define HOST_HOOKS_GT_PCH_GET_ADDRESS hook_voidp_size_t_null\n-#define HOST_HOOKS_GT_PCH_USE_ADDRESS hook_bool_voidp_size_t_false\n+#if HAVE_MMAP_FILE\n+#define HOST_HOOKS_GT_PCH_GET_ADDRESS mmap_gt_pch_get_address\n+#define HOST_HOOKS_GT_PCH_USE_ADDRESS mmap_gt_pch_use_address\n+#else\n+#define HOST_HOOKS_GT_PCH_GET_ADDRESS default_gt_pch_get_address\n+#define HOST_HOOKS_GT_PCH_USE_ADDRESS default_gt_pch_use_address\n+#endif\n+\n+extern void* default_gt_pch_get_address (size_t, int);\n+extern int default_gt_pch_use_address (void *, size_t, int, size_t);\n+extern void* mmap_gt_pch_get_address (size_t, int);\n+extern int mmap_gt_pch_use_address (void *, size_t, int, size_t);\n \n /* The structure is defined in hosthooks.h.  */\n #define HOST_HOOKS_INITIALIZER {\t\t\\"}, {"sha": "a3fc0c7c4307c1a0c27fa1be757b0147edaf5418", "filename": "gcc/hosthooks.h", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d0c31e68cc2a1c3d39c7d51d2af9cd3d5c1784f/gcc%2Fhosthooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d0c31e68cc2a1c3d39c7d51d2af9cd3d5c1784f/gcc%2Fhosthooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhosthooks.h?ref=4d0c31e68cc2a1c3d39c7d51d2af9cd3d5c1784f", "patch": "@@ -25,8 +25,16 @@ struct host_hooks\n {\n   void (*extra_signals) (void);\n \n-  void * (*gt_pch_get_address) (size_t);\n-  bool (*gt_pch_use_address) (void *, size_t);\n+  /* Identify an address that's likely to be free in a subsequent invocation\n+     of the compiler.  The area should be able to hold SIZE bytes.  FD is an\n+     open file descriptor if the host would like to probe with mmap.  */\n+  void * (*gt_pch_get_address) (size_t size, int fd);\n+\n+  /* ADDR is an address returned by gt_pch_get_address.  Attempt to allocate\n+     SIZE bytes at the same address and load it with the data from FD at \n+     OFFSET.  Return -1 if we couldn't allocate memory at ADDR, return 0\n+     if the memory is allocated but the data not loaded, return 1 if done.  */\n+  int (*gt_pch_use_address) (void *addr, size_t size, int fd, size_t offset);\n \n   /* Whenever you add entries here, make sure you adjust hosthooks-def.h.  */\n };"}]}