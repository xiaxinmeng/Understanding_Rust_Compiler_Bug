{"sha": "d2fd6a04f958346c6311113f4244540ac28efef2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDJmZDZhMDRmOTU4MzQ2YzYzMTExMTNmNDI0NDU0MGFjMjhlZmVmMg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-12-21T07:02:36Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-12-21T07:02:36Z"}, "message": "poly_int: tree-ssa-loop-ivopts.c:iv_use\n\nThis patch makes ivopts handle polynomial address offsets\nwhen recording potential IV uses.\n\n2017-12-21  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* tree-ssa-loop-ivopts.h (strip_offset): Return the offset as\n\tpoly_uint64_pod rather than an unsigned HOST_WIDE_INT.\n\t* tree-loop-distribution.c (classify_builtin_st): Update accordingly.\n\t* tree-ssa-loop-ivopts.c (iv_use::addr_offset): Change from\n\tan unsigned HOST_WIDE_INT to a poly_uint64_pod.\n\t(group_compare_offset): Update accordingly.\n\t(split_small_address_groups_p): Likewise.\n\t(record_use): Take addr_offset as a poly_uint64 rather than\n\tan unsigned HOST_WIDE_INT.\n\t(strip_offset): Return the offset as a poly_uint64 rather than\n\tan unsigned HOST_WIDE_INT.\n\t(record_group_use, split_address_groups): Track polynomial offsets.\n\t(add_iv_candidate_for_use): Likewise.\n\t(addr_offset_valid_p): Take the offset as a poly_int64 rather\n\tthan a HOST_WIDE_INT.\n\t(strip_offset_1): Return the offset as a poly_int64 rather than\n\ta HOST_WIDE_INT.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r255933", "tree": {"sha": "320bf9bcc39e950dd35fcd65beec033182129dbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/320bf9bcc39e950dd35fcd65beec033182129dbf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d2fd6a04f958346c6311113f4244540ac28efef2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2fd6a04f958346c6311113f4244540ac28efef2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2fd6a04f958346c6311113f4244540ac28efef2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2fd6a04f958346c6311113f4244540ac28efef2/comments", "author": null, "committer": null, "parents": [{"sha": "0ddcd294d54bf049bb48fd7face88a1d8254877f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ddcd294d54bf049bb48fd7face88a1d8254877f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ddcd294d54bf049bb48fd7face88a1d8254877f"}], "stats": {"total": 83, "additions": 52, "deletions": 31}, "files": [{"sha": "5f45bd15d9b4c2a81324b7d01349d3a904576180", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2fd6a04f958346c6311113f4244540ac28efef2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2fd6a04f958346c6311113f4244540ac28efef2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d2fd6a04f958346c6311113f4244540ac28efef2", "patch": "@@ -1,3 +1,25 @@\n+2017-12-21  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* tree-ssa-loop-ivopts.h (strip_offset): Return the offset as\n+\tpoly_uint64_pod rather than an unsigned HOST_WIDE_INT.\n+\t* tree-loop-distribution.c (classify_builtin_st): Update accordingly.\n+\t* tree-ssa-loop-ivopts.c (iv_use::addr_offset): Change from\n+\tan unsigned HOST_WIDE_INT to a poly_uint64_pod.\n+\t(group_compare_offset): Update accordingly.\n+\t(split_small_address_groups_p): Likewise.\n+\t(record_use): Take addr_offset as a poly_uint64 rather than\n+\tan unsigned HOST_WIDE_INT.\n+\t(strip_offset): Return the offset as a poly_uint64 rather than\n+\tan unsigned HOST_WIDE_INT.\n+\t(record_group_use, split_address_groups): Track polynomial offsets.\n+\t(add_iv_candidate_for_use): Likewise.\n+\t(addr_offset_valid_p): Take the offset as a poly_int64 rather\n+\tthan a HOST_WIDE_INT.\n+\t(strip_offset_1): Return the offset as a poly_int64 rather than\n+\ta HOST_WIDE_INT.\n+\n 2017-12-21  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "e195a46a36e311f29e7670005cba33a41a85b66f", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2fd6a04f958346c6311113f4244540ac28efef2/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2fd6a04f958346c6311113f4244540ac28efef2/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=d2fd6a04f958346c6311113f4244540ac28efef2", "patch": "@@ -1513,10 +1513,16 @@ classify_builtin_st (loop_p loop, partition *partition, data_reference_p dr)\n   if (!compute_access_range (loop, dr, &base, &size))\n     return;\n \n+  poly_uint64 base_offset;\n+  unsigned HOST_WIDE_INT const_base_offset;\n+  tree base_base = strip_offset (base, &base_offset);\n+  if (!base_offset.is_constant (&const_base_offset))\n+    return;\n+\n   struct builtin_info *builtin;\n   builtin = alloc_builtin (dr, NULL, base, NULL_TREE, size);\n-  builtin->dst_base_base = strip_offset (builtin->dst_base,\n-\t\t\t\t\t &builtin->dst_base_offset);\n+  builtin->dst_base_base = base_base;\n+  builtin->dst_base_offset = const_base_offset;\n   partition->builtin = builtin;\n   partition->kind = PKIND_MEMSET;\n }"}, {"sha": "b5d5ea629202b213981beef56433a25b9cd2319d", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 21, "deletions": 28, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2fd6a04f958346c6311113f4244540ac28efef2/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2fd6a04f958346c6311113f4244540ac28efef2/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=d2fd6a04f958346c6311113f4244540ac28efef2", "patch": "@@ -367,7 +367,7 @@ struct iv_use\n   tree *op_p;\t\t/* The place where it occurs.  */\n \n   tree addr_base;\t/* Base address with const offset stripped.  */\n-  unsigned HOST_WIDE_INT addr_offset;\n+  poly_uint64_pod addr_offset;\n \t\t\t/* Const offset stripped from base address.  */\n };\n \n@@ -1508,7 +1508,7 @@ find_induction_variables (struct ivopts_data *data)\n static struct iv_use *\n record_use (struct iv_group *group, tree *use_p, struct iv *iv,\n \t    gimple *stmt, enum use_type type, tree addr_base,\n-\t    unsigned HOST_WIDE_INT addr_offset)\n+\t    poly_uint64 addr_offset)\n {\n   struct iv_use *use = XCNEW (struct iv_use);\n \n@@ -1577,7 +1577,7 @@ record_group_use (struct ivopts_data *data, tree *use_p,\n {\n   tree addr_base = NULL;\n   struct iv_group *group = NULL;\n-  unsigned HOST_WIDE_INT addr_offset = 0;\n+  poly_uint64 addr_offset = 0;\n \n   /* Record non address type use in a new group.  */\n   if (type == USE_ADDRESS && iv->base_object)\n@@ -2511,7 +2511,7 @@ find_interesting_uses_outside (struct ivopts_data *data, edge exit)\n static GTY (()) vec<rtx, va_gc> *addr_list;\n \n static bool\n-addr_offset_valid_p (struct iv_use *use, HOST_WIDE_INT offset)\n+addr_offset_valid_p (struct iv_use *use, poly_int64 offset)\n {\n   rtx reg, addr;\n   unsigned list_index;\n@@ -2545,10 +2545,7 @@ group_compare_offset (const void *a, const void *b)\n   const struct iv_use *const *u1 = (const struct iv_use *const *) a;\n   const struct iv_use *const *u2 = (const struct iv_use *const *) b;\n \n-  if ((*u1)->addr_offset != (*u2)->addr_offset)\n-    return (*u1)->addr_offset < (*u2)->addr_offset ? -1 : 1;\n-  else\n-    return 0;\n+  return compare_sizes_for_sort ((*u1)->addr_offset, (*u2)->addr_offset);\n }\n \n /* Check if small groups should be split.  Return true if no group\n@@ -2579,7 +2576,8 @@ split_small_address_groups_p (struct ivopts_data *data)\n       gcc_assert (group->type == USE_ADDRESS);\n       if (group->vuses.length () == 2)\n \t{\n-\t  if (group->vuses[0]->addr_offset > group->vuses[1]->addr_offset)\n+\t  if (compare_sizes_for_sort (group->vuses[0]->addr_offset,\n+\t\t\t\t      group->vuses[1]->addr_offset) > 0)\n \t    std::swap (group->vuses[0], group->vuses[1]);\n \t}\n       else\n@@ -2591,7 +2589,7 @@ split_small_address_groups_p (struct ivopts_data *data)\n       distinct = 1;\n       for (pre = group->vuses[0], j = 1; j < group->vuses.length (); j++)\n \t{\n-\t  if (group->vuses[j]->addr_offset != pre->addr_offset)\n+\t  if (maybe_ne (group->vuses[j]->addr_offset, pre->addr_offset))\n \t    {\n \t      pre = group->vuses[j];\n \t      distinct++;\n@@ -2632,13 +2630,13 @@ split_address_groups (struct ivopts_data *data)\n       for (j = 1; j < group->vuses.length ();)\n \t{\n \t  struct iv_use *next = group->vuses[j];\n-\t  HOST_WIDE_INT offset = next->addr_offset - use->addr_offset;\n+\t  poly_int64 offset = next->addr_offset - use->addr_offset;\n \n \t  /* Split group if aksed to, or the offset against the first\n \t     use can't fit in offset part of addressing mode.  IV uses\n \t     having the same offset are still kept in one group.  */\n-\t  if (offset != 0 &&\n-\t      (split_p || !addr_offset_valid_p (use, offset)))\n+\t  if (maybe_ne (offset, 0)\n+\t      && (split_p || !addr_offset_valid_p (use, offset)))\n \t    {\n \t      if (!new_group)\n \t\tnew_group = record_group (data, group->type);\n@@ -2699,12 +2697,13 @@ find_interesting_uses (struct ivopts_data *data)\n \n static tree\n strip_offset_1 (tree expr, bool inside_addr, bool top_compref,\n-\t\tHOST_WIDE_INT *offset)\n+\t\tpoly_int64 *offset)\n {\n   tree op0 = NULL_TREE, op1 = NULL_TREE, tmp, step;\n   enum tree_code code;\n   tree type, orig_type = TREE_TYPE (expr);\n-  HOST_WIDE_INT off0, off1, st;\n+  poly_int64 off0, off1;\n+  HOST_WIDE_INT st;\n   tree orig_expr = expr;\n \n   STRIP_NOPS (expr);\n@@ -2715,14 +2714,6 @@ strip_offset_1 (tree expr, bool inside_addr, bool top_compref,\n \n   switch (code)\n     {\n-    case INTEGER_CST:\n-      if (!cst_and_fits_in_hwi (expr)\n-\t  || integer_zerop (expr))\n-\treturn orig_expr;\n-\n-      *offset = int_cst_value (expr);\n-      return build_int_cst (orig_type, 0);\n-\n     case POINTER_PLUS_EXPR:\n     case PLUS_EXPR:\n     case MINUS_EXPR:\n@@ -2840,6 +2831,8 @@ strip_offset_1 (tree expr, bool inside_addr, bool top_compref,\n       break;\n \n     default:\n+      if (ptrdiff_tree_p (expr, offset) && maybe_ne (*offset, 0))\n+\treturn build_int_cst (orig_type, 0);\n       return orig_expr;\n     }\n \n@@ -2869,9 +2862,9 @@ strip_offset_1 (tree expr, bool inside_addr, bool top_compref,\n /* Strips constant offsets from EXPR and stores them to OFFSET.  */\n \n tree\n-strip_offset (tree expr, unsigned HOST_WIDE_INT *offset)\n+strip_offset (tree expr, poly_uint64_pod *offset)\n {\n-  HOST_WIDE_INT off;\n+  poly_int64 off;\n   tree core = strip_offset_1 (expr, false, false, &off);\n   *offset = off;\n   return core;\n@@ -3398,7 +3391,7 @@ add_iv_candidate_derived_from_uses (struct ivopts_data *data)\n static void\n add_iv_candidate_for_use (struct ivopts_data *data, struct iv_use *use)\n {\n-  unsigned HOST_WIDE_INT offset;\n+  poly_uint64 offset;\n   tree base;\n   tree basetype;\n   struct iv *iv = use->iv;\n@@ -3417,7 +3410,7 @@ add_iv_candidate_for_use (struct ivopts_data *data, struct iv_use *use)\n   /* Record common candidate with constant offset stripped in base.\n      Like the use itself, we also add candidate directly for it.  */\n   base = strip_offset (iv->base, &offset);\n-  if (offset || base != iv->base)\n+  if (maybe_ne (offset, 0U) || base != iv->base)\n     {\n       record_common_cand (data, base, iv->step, use);\n       add_candidate (data, base, iv->step, false, use);\n@@ -3436,7 +3429,7 @@ add_iv_candidate_for_use (struct ivopts_data *data, struct iv_use *use)\n       record_common_cand (data, base, step, use);\n       /* Also record common candidate with offset stripped.  */\n       base = strip_offset (base, &offset);\n-      if (offset)\n+      if (maybe_ne (offset, 0U))\n \trecord_common_cand (data, base, step, use);\n     }\n "}, {"sha": "cca3692203a67a3e431b23aabb92edb1c8cc246c", "filename": "gcc/tree-ssa-loop-ivopts.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2fd6a04f958346c6311113f4244540ac28efef2/gcc%2Ftree-ssa-loop-ivopts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2fd6a04f958346c6311113f4244540ac28efef2/gcc%2Ftree-ssa-loop-ivopts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.h?ref=d2fd6a04f958346c6311113f4244540ac28efef2", "patch": "@@ -28,7 +28,7 @@ extern void dump_cand (FILE *, struct iv_cand *);\n extern bool contains_abnormal_ssa_name_p (tree);\n extern struct loop *outermost_invariant_loop_for_expr (struct loop *, tree);\n extern bool expr_invariant_in_loop_p (struct loop *, tree);\n-extern tree strip_offset (tree, unsigned HOST_WIDE_INT *);\n+extern tree strip_offset (tree, poly_uint64_pod *);\n bool may_be_nonaddressable_p (tree expr);\n void tree_ssa_iv_optimize (void);\n "}]}