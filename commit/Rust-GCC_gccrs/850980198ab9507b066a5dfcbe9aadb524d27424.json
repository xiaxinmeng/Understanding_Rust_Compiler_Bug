{"sha": "850980198ab9507b066a5dfcbe9aadb524d27424", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODUwOTgwMTk4YWI5NTA3YjA2NmE1ZGZjYmU5YWFkYjUyNGQyNzQyNA==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1994-04-01T00:48:24Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1994-04-01T00:48:24Z"}, "message": "(mips_rtx_classify, md_register_operand,\n\nfpsw_register_operand, cmp2_op, uns_cmp_op, fcmp_op): Delete.\n(mips_const_double_ok, mips_fill_delay_slot, output_block_move,\nprint_operand, function_epilogue): Don't treat gas differently\nthan native assembler.\n(equality_op, cmp_op): Delete use of classify_op.\n(override_options): Delete uses of mips_rtx_classify.\n(final_prescan_insn): Simplify based on other changes.\n\nFrom-SVN: r6932", "tree": {"sha": "bd0da34dd4a20d12ddf27117f69bd748ee415772", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bd0da34dd4a20d12ddf27117f69bd748ee415772"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/850980198ab9507b066a5dfcbe9aadb524d27424", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/850980198ab9507b066a5dfcbe9aadb524d27424", "html_url": "https://github.com/Rust-GCC/gccrs/commit/850980198ab9507b066a5dfcbe9aadb524d27424", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/850980198ab9507b066a5dfcbe9aadb524d27424/comments", "author": null, "committer": null, "parents": [{"sha": "9a863c83a43c753303ac34623b39411ee4d8aaf5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a863c83a43c753303ac34623b39411ee4d8aaf5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a863c83a43c753303ac34623b39411ee4d8aaf5"}], "stats": {"total": 171, "additions": 33, "deletions": 138}, "files": [{"sha": "16315b4566b62f43436addd7ee468207101da46b", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 33, "deletions": 138, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/850980198ab9507b066a5dfcbe9aadb524d27424/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/850980198ab9507b066a5dfcbe9aadb524d27424/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=850980198ab9507b066a5dfcbe9aadb524d27424", "patch": "@@ -204,12 +204,6 @@ enum mips_abicalls_type mips_abicalls;\n    initialized in override_options.  */\n REAL_VALUE_TYPE dfhigh, dflow, sfhigh, sflow;\n \n-/* Array to RTX class classification.  At present, we care about\n-   whether the operator is an add-type operator, or a divide/modulus,\n-   and if divide/modulus, whether it is unsigned.  This is for the\n-   peephole code.  */\n-char mips_rtx_classify[NUM_RTX_CODE];\n-\n /* Array giving truth value on whether or not a given hard register\n    can support a given mode.  */\n char mips_hard_regno_mode_ok[(int)MAX_MACHINE_MODE][FIRST_PSEUDO_REGISTER];\n@@ -467,36 +461,15 @@ reg_or_0_operand (op, mode)\n   return FALSE;\n }\n \n-/* Return truth value of whether OP is one of the special multiply/divide\n-   registers (hi, lo).  */\n-\n-int\n-md_register_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return (GET_MODE_CLASS (mode) == MODE_INT\n-\t  && GET_CODE (op) == REG\n-\t  && MD_REG_P (REGNO (op)));\n-}\n-\n-/* Return truth value of whether OP is the FP status register.  */\n-\n-int\n-fpsw_register_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return (GET_CODE (op) == REG && ST_REG_P (REGNO (op)));\n-}\n-\n /* Return truth value if a CONST_DOUBLE is ok to be a legitimate constant.  */\n \n int\n mips_const_double_ok (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n+  REAL_VALUE_TYPE d;\n+\n   if (GET_CODE (op) != CONST_DOUBLE)\n     return FALSE;\n \n@@ -509,30 +482,25 @@ mips_const_double_ok (op, mode)\n   if (op == CONST0_RTX (mode))\n     return TRUE;\n \n-  if (TARGET_MIPS_AS)\t\t/* gas doesn't like li.d/li.s yet */\n-    {\n-      REAL_VALUE_TYPE d;\n+  REAL_VALUE_FROM_CONST_DOUBLE (d, op);\n \n-      REAL_VALUE_FROM_CONST_DOUBLE (d, op);\n-\n-      if (REAL_VALUE_ISNAN (d))\n-\treturn FALSE;\n+  if (REAL_VALUE_ISNAN (d))\n+    return FALSE;\n \n-      if (REAL_VALUE_NEGATIVE (d))\n-\td = REAL_VALUE_NEGATE (d);\n+  if (REAL_VALUE_NEGATIVE (d))\n+    d = REAL_VALUE_NEGATE (d);\n \n-      if (mode == DFmode)\n-\t{\n-\t  if (REAL_VALUES_LESS (d, dfhigh)\n-\t      && REAL_VALUES_LESS (dflow, d))\n-\t    return TRUE;\n-\t}\n-      else\n-\t{\n-\t  if (REAL_VALUES_LESS (d, sfhigh)\n-\t      && REAL_VALUES_LESS (sflow, d))\n-\t    return TRUE;\n-\t}\n+  if (mode == DFmode)\n+    {\n+      if (REAL_VALUES_LESS (d, dfhigh)\n+\t  && REAL_VALUES_LESS (dflow, d))\n+\treturn TRUE;\n+    }\n+  else\n+    {\n+      if (REAL_VALUES_LESS (d, sfhigh)\n+\t  && REAL_VALUES_LESS (sflow, d))\n+\treturn TRUE;\n     }\n \n   return FALSE;\n@@ -630,7 +598,7 @@ equality_op (op, mode)\n   if (mode != GET_MODE (op))\n     return FALSE;\n \n-  return (classify_op (op, mode) & CLASS_EQUALITY_OP) != 0;\n+  return (GET_CODE (op) == EQ || GET_CODE (op) == NE);\n }\n \n /* Return true if the code is a relational operations (EQ, LE, etc.) */\n@@ -643,52 +611,9 @@ cmp_op (op, mode)\n   if (mode != GET_MODE (op))\n     return FALSE;\n \n-  return (classify_op (op, mode) & CLASS_CMP_OP) != 0;\n+  return (GET_RTX_CLASS (GET_CODE (op)) == '<');\n }\n \n-\n-/* Genrecog does not take the type of match_operator into consideration,\n-   and would complain about two patterns being the same if the same\n-   function is used, so make it believe they are different.  */\n-\n-int\n-cmp2_op (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  if (mode != GET_MODE (op))\n-    return FALSE;\n-\n-  return (classify_op (op, mode) & CLASS_CMP_OP) != 0;\n-}\n-\n-/* Return true if the code is an unsigned relational operations (LEU, etc.) */\n-\n-int\n-uns_cmp_op (op,mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  if (mode != GET_MODE (op))\n-    return FALSE;\n-\n-  return (classify_op (op, mode) & CLASS_UNS_CMP_OP) == CLASS_UNS_CMP_OP;\n-}\n-\n-/* Return true if the code is a relational operation FP can use.  */\n-\n-int\n-fcmp_op (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  if (mode != GET_MODE (op))\n-    return FALSE;\n-\n-  return (classify_op (op, mode) & CLASS_FCMP_OP) != 0;\n-}\n-\n-\n /* Return true if the operand is either the PC or a label_ref.  */\n \n int\n@@ -725,18 +650,18 @@ call_insn_operand (op, mode)\n   return 0;\n }\n \f\n-/* Return an operand string if the given instruction's delay slot or\n-   wrap it in a .set noreorder section.  This is for filling delay\n-   slots on load type instructions under GAS, which does no reordering\n-   on its own.  For the MIPS assembler, all we do is update the filled\n-   delay slot statistics.\n+/* Returns an operand string for the given instruction's delay slot,\n+   after updating filled delay slot statistics.\n \n    We assume that operands[0] is the target register that is set.\n \n    In order to check the next insn, most of this functionality is moved\n    to FINAL_PRESCAN_INSN, and we just set the global variables that\n    it needs.  */\n \n+/* ??? This function no longer does anything useful, because final_prescan_insn\n+   now will never emit a nop.  */\n+\n char *\n mips_fill_delay_slot (ret, type, operands, cur_insn)\n      char *ret;\t\t\t/* normal string to return */\n@@ -808,9 +733,6 @@ mips_fill_delay_slot (ret, type, operands, cur_insn)\n       mips_load_reg4 = 0;\n     }\n \n-  if (TARGET_GAS && set_noreorder++ == 0)\n-    fputs (\"\\t.set\\tnoreorder\\n\", asm_out_file);\n-\n   return ret;\n }\n \n@@ -2521,9 +2443,6 @@ output_block_move (insn, operands, num_regs, move_type)\n   else if (num_regs < 1)\n     abort_with_insn (insn, \"Cannot do block move, not enough scratch registers\");\n \n-  if (TARGET_GAS && move_type != BLOCK_MOVE_LAST && set_noreorder++ == 0)\n-    output_asm_insn (\".set\\tnoreorder\", operands);\n-\n   while (bytes > 0)\n     {\n       load_store[num].offset = offset;\n@@ -2716,9 +2635,6 @@ output_block_move (insn, operands, num_regs, move_type)\n \t}\n     }\n \n-  if (TARGET_GAS && move_type != BLOCK_MOVE_LAST && --set_noreorder == 0)\n-    output_asm_insn (\".set\\treorder\", operands);\n-\n   return \"\";\n }\n \n@@ -3312,24 +3228,6 @@ override_options ()\n   sfhigh = REAL_VALUE_ATOF (\"1.0e38\", SFmode);\n   sflow = REAL_VALUE_ATOF (\"1.0e-38\", SFmode);\n \n-  /* Set up the classification arrays now.  */\n-  mips_rtx_classify[(int)PLUS]  = CLASS_ADD_OP;\n-  mips_rtx_classify[(int)MINUS] = CLASS_ADD_OP;\n-  mips_rtx_classify[(int)DIV]   = CLASS_DIVMOD_OP;\n-  mips_rtx_classify[(int)MOD]   = CLASS_DIVMOD_OP;\n-  mips_rtx_classify[(int)UDIV]  = CLASS_DIVMOD_OP | CLASS_UNSIGNED_OP;\n-  mips_rtx_classify[(int)UMOD]  = CLASS_DIVMOD_OP | CLASS_UNSIGNED_OP;\n-  mips_rtx_classify[(int)EQ]    = CLASS_CMP_OP | CLASS_EQUALITY_OP | CLASS_FCMP_OP;\n-  mips_rtx_classify[(int)NE]    = CLASS_CMP_OP | CLASS_EQUALITY_OP | CLASS_FCMP_OP;\n-  mips_rtx_classify[(int)GT]    = CLASS_CMP_OP | CLASS_FCMP_OP;\n-  mips_rtx_classify[(int)GE]    = CLASS_CMP_OP | CLASS_FCMP_OP;\n-  mips_rtx_classify[(int)LT]    = CLASS_CMP_OP | CLASS_FCMP_OP;\n-  mips_rtx_classify[(int)LE]    = CLASS_CMP_OP | CLASS_FCMP_OP;\n-  mips_rtx_classify[(int)GTU]   = CLASS_CMP_OP | CLASS_UNSIGNED_OP;\n-  mips_rtx_classify[(int)GEU]   = CLASS_CMP_OP | CLASS_UNSIGNED_OP;\n-  mips_rtx_classify[(int)LTU]   = CLASS_CMP_OP | CLASS_UNSIGNED_OP;\n-  mips_rtx_classify[(int)LEU]   = CLASS_CMP_OP | CLASS_UNSIGNED_OP;\n-\n   mips_print_operand_punct['?'] = TRUE;\n   mips_print_operand_punct['#'] = TRUE;\n   mips_print_operand_punct['&'] = TRUE;\n@@ -3564,7 +3462,7 @@ print_operand (file, op, letter)\n \t  if (set_noreorder != 0)\n \t    fputs (\"\\n\\tnop\", file);\n \n-\t  else if (TARGET_GAS || TARGET_STATS)\n+\t  else if (TARGET_STATS)\n \t    fputs (\"\\n\\t#nop\", file);\n \n \t  break;\n@@ -3991,6 +3889,9 @@ mips_output_lineno (stream, line)\n    because of load delays, and also to update the delay slot\n    statistics.  */\n \n+/* ??? There is no real need for this function, because it never actually\n+   emits a NOP anymore.  */\n+\n void\n final_prescan_insn (insn, opvec, noperands)\n      rtx insn;\n@@ -4008,21 +3909,18 @@ final_prescan_insn (insn, opvec, noperands)\n \t  || (mips_load_reg2 != (rtx)0 && reg_mentioned_p (mips_load_reg2, pattern))\n \t  || (mips_load_reg3 != (rtx)0 && reg_mentioned_p (mips_load_reg3, pattern))\n \t  || (mips_load_reg4 != (rtx)0 && reg_mentioned_p (mips_load_reg4, pattern)))\n-\tfputs ((set_noreorder) ? \"\\tnop\\n\" : \"\\t#nop\\n\", asm_out_file);\n+\tfputs (\"\\t#nop\\n\", asm_out_file);\n \n       else\n \tdslots_load_filled++;\n \n       while (--dslots_number_nops > 0)\n-\tfputs ((set_noreorder) ? \"\\tnop\\n\" : \"\\t#nop\\n\", asm_out_file);\n+\tfputs (\"\\t#nop\\n\", asm_out_file);\n \n       mips_load_reg  = (rtx)0;\n       mips_load_reg2 = (rtx)0;\n       mips_load_reg3 = (rtx)0;\n       mips_load_reg4 = (rtx)0;\n-\n-      if (set_noreorder && --set_noreorder == 0)\n-\tfputs (\"\\t.set\\treorder\\n\", asm_out_file);\n     }\n \n   if (TARGET_STATS)\n@@ -4935,7 +4833,7 @@ function_epilogue (file, size)\n   char *sp_str = reg_names[STACK_POINTER_REGNUM];\n   char *t1_str = reg_names[MIPS_TEMP1_REGNUM];\n   rtx epilogue_delay = current_function_epilogue_delay_list;\n-  int noreorder = !TARGET_MIPS_AS || (epilogue_delay != 0);\n+  int noreorder = (epilogue_delay != 0);\n   int noepilogue = FALSE;\n   int load_nop = FALSE;\n   int load_only_r31;\n@@ -4958,11 +4856,8 @@ function_epilogue (file, size)\n       else\n \t{\n \t  while (--dslots_number_nops > 0)\n-\t    fputs ((set_noreorder) ? \"\\tnop\\n\" : \"\\t#nop\\n\", asm_out_file);\n+\t    fputs (\"\\t#nop\\n\", asm_out_file);\n \t}\n-\n-      if (set_noreorder > 0 && --set_noreorder == 0)\n-\tfputs (\"\\t.set\\treorder\\n\", file);\n     }\n \n   if (set_noat != 0)"}]}