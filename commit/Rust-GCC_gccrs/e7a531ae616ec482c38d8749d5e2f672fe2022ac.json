{"sha": "e7a531ae616ec482c38d8749d5e2f672fe2022ac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTdhNTMxYWU2MTZlYzQ4MmMzOGQ4NzQ5ZDVlMmY2NzJmZTIwMjJhYw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-11-20T12:48:15Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-11-20T12:48:15Z"}, "message": "tree-ssa-threadupdate.c, [...]: Fix comment typos.\n\n\t* tree-ssa-threadupdate.c, tree-vectorizer.c: Fix comment\n\ttypos.\n\t* config/arm/arm.c: Follow spelling conventions.\n\nFrom-SVN: r90963", "tree": {"sha": "f97e652167bbb5013f18a7eded4bd5d837950d60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f97e652167bbb5013f18a7eded4bd5d837950d60"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e7a531ae616ec482c38d8749d5e2f672fe2022ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7a531ae616ec482c38d8749d5e2f672fe2022ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7a531ae616ec482c38d8749d5e2f672fe2022ac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7a531ae616ec482c38d8749d5e2f672fe2022ac/comments", "author": null, "committer": null, "parents": [{"sha": "2075b05db6dbd95bd334cd9a8f1bc085aef642aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2075b05db6dbd95bd334cd9a8f1bc085aef642aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2075b05db6dbd95bd334cd9a8f1bc085aef642aa"}], "stats": {"total": 20, "additions": 13, "deletions": 7}, "files": [{"sha": "edcf93e07e38f402a2b29f55d1c9ab2460a3aef0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a531ae616ec482c38d8749d5e2f672fe2022ac/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a531ae616ec482c38d8749d5e2f672fe2022ac/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e7a531ae616ec482c38d8749d5e2f672fe2022ac", "patch": "@@ -1,3 +1,9 @@\n+2004-11-20  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* tree-ssa-threadupdate.c, tree-vectorizer.c: Fix comment\n+\ttypos.\n+\t* config/arm/arm.c: Follow spelling conventions.\n+\n 2004-11-20  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* arm.c (arm_override_options): Use arm_ld_sched rather than testing"}, {"sha": "9db8b79332859b50b738fe4f97673e884a0752f9", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a531ae616ec482c38d8749d5e2f672fe2022ac/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a531ae616ec482c38d8749d5e2f672fe2022ac/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=e7a531ae616ec482c38d8749d5e2f672fe2022ac", "patch": "@@ -7258,7 +7258,7 @@ push_minipool_fix (rtx insn, HOST_WIDE_INT address, rtx *loc,\n   minipool_fix_tail = fix;\n }\n \n-/* Return the cost of synthesising the const_double VAL inline.\n+/* Return the cost of synthesizing the const_double VAL inline.\n    Returns the number of insns needed, or 99 if we don't know how to\n    do it.  */\n int"}, {"sha": "8d205fdf384428b0fb461c645e4d4056114e46dc", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a531ae616ec482c38d8749d5e2f672fe2022ac/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a531ae616ec482c38d8749d5e2f672fe2022ac/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=e7a531ae616ec482c38d8749d5e2f672fe2022ac", "patch": "@@ -106,7 +106,7 @@ struct el\n /* We need to efficiently record the unique thread destinations of this\n    block and specific information associated with those destinations.  We\n    may have many incoming edges threaded to the same outgoing edge.  This\n-   can be naturaly implemented with a hash table.  */\n+   can be naturally implemented with a hash table.  */\n \n struct redirection_data\n {\n@@ -467,7 +467,7 @@ thread_block (basic_block bb)\n   bool all = true;\n \n   /* To avoid scanning a linear array for the element we need we instead\n-     use a hash table.  For normal code there should be no noticable\n+     use a hash table.  For normal code there should be no noticeable\n      difference.  However, if we have a block with a large number of\n      incoming and outgoing edges such linear searches can get expensive.  */\n   redirection_data = htab_create (EDGE_COUNT (bb->succs),"}, {"sha": "7793b0b6b0104496a3e28c8071a858acd09df694", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a531ae616ec482c38d8749d5e2f672fe2022ac/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a531ae616ec482c38d8749d5e2f672fe2022ac/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=e7a531ae616ec482c38d8749d5e2f672fe2022ac", "patch": "@@ -574,7 +574,7 @@ slpeel_update_phis_for_duplicate_loop (struct loop *orig_loop,\n \n    - IS_NEW_LOOP: TRUE if LOOP is a new loop (a duplicated copy of another\n         \"original\" loop).  FALSE if LOOP is an original loop (not a newly \n-        created copy).  The SSA_NAME_AUX fields of the defs in the origianl\n+        created copy).  The SSA_NAME_AUX fields of the defs in the original\n         loop are the corresponding new ssa-names used in the new duplicated\n         loop copy.  IS_NEW_LOOP indicates which of the two args of the phi \n         nodes in UPDATE_BB takes the original ssa-name, and which takes the \n@@ -929,14 +929,14 @@ slpeel_verify_cfg_after_peeling (struct loop *first_loop,\n         case, first-loop is the newly created loop, and second-loop is LOOP.\n    - NITERS: the number of iterations that LOOP iterates.\n    - FIRST_NITERS: the number of iterations that the first-loop should iterate.\n-   - UPDATE_FIRST_LOOP_COUNT:  specified whether this function is responssible\n+   - UPDATE_FIRST_LOOP_COUNT:  specified whether this function is responsible\n         for updating the loop bound of the first-loop to FIRST_NITERS.  If it\n         is false, the caller of this function may want to take care of this\n-        (this can be usefull is we don't want new stmts added to first-loop).\n+        (this can be useful if we don't want new stmts added to first-loop).\n \n    Output:\n    The function returns a pointer to the new loop-copy, or NULL if it failed\n-   to perform the trabsformation.\n+   to perform the transformation.\n \n    The function generates two if-then-else guards: one before the first loop,\n    and the other before the second loop:"}]}