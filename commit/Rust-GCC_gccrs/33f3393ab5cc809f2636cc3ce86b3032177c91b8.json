{"sha": "33f3393ab5cc809f2636cc3ce86b3032177c91b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzNmMzM5M2FiNWNjODA5ZjI2MzZjYzNjZTg2YjMwMzIxNzdjOTFiOA==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel@linux.ibm.com", "date": "2018-11-20T16:19:54Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2018-11-20T16:19:54Z"}, "message": "S/390: Fix flogr RTX.\n\nThe flogr instruction uses a 64 bit register pair target operand.  In\nthe RTX we model this as a write to a TImode register.  Unfortunately\nthe RTX's being assigned to the two parts of the target operand were\nswapped.  This is no problem if in the end the flogr instruction will\nbe emitted since the instruction still does what the clzdi expander\nexpects.  However, a problem arises when the RTX is used to optimize\nCLZ for a constant input operand.  Even then it matters only if the\nexpression couldn't be folded on tree level already.\n\nIn the testcase this happened thanks to loop unrolling on RTL level.\nThe iteration variable is used as an argument to the clz\nbuiltin. Due to the loop unrolling it becomes a constant and after\nfolding the broken RTX leads to a wrong assumption.\n\ngcc/ChangeLog:\n\n2018-11-20  Andreas Krebbel  <krebbel@linux.ibm.com>\n\n\t* config/s390/s390.md (\"clztidi2\"): Swap the RTX's written to the\n\tDImode parts of the target operand.\n\ngcc/testsuite/ChangeLog:\n\n2018-11-20  Andreas Krebbel  <krebbel@linux.ibm.com>\n\n\t* gcc.target/s390/flogr-1.c: New test.\n\nFrom-SVN: r266321", "tree": {"sha": "844a5c7e059a1d38f8d2473cdc66764f66d73c76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/844a5c7e059a1d38f8d2473cdc66764f66d73c76"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/33f3393ab5cc809f2636cc3ce86b3032177c91b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33f3393ab5cc809f2636cc3ce86b3032177c91b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33f3393ab5cc809f2636cc3ce86b3032177c91b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33f3393ab5cc809f2636cc3ce86b3032177c91b8/comments", "author": {"login": "Andreas-Krebbel", "id": 38103320, "node_id": "MDQ6VXNlcjM4MTAzMzIw", "avatar_url": "https://avatars.githubusercontent.com/u/38103320?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Andreas-Krebbel", "html_url": "https://github.com/Andreas-Krebbel", "followers_url": "https://api.github.com/users/Andreas-Krebbel/followers", "following_url": "https://api.github.com/users/Andreas-Krebbel/following{/other_user}", "gists_url": "https://api.github.com/users/Andreas-Krebbel/gists{/gist_id}", "starred_url": "https://api.github.com/users/Andreas-Krebbel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Andreas-Krebbel/subscriptions", "organizations_url": "https://api.github.com/users/Andreas-Krebbel/orgs", "repos_url": "https://api.github.com/users/Andreas-Krebbel/repos", "events_url": "https://api.github.com/users/Andreas-Krebbel/events{/privacy}", "received_events_url": "https://api.github.com/users/Andreas-Krebbel/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "84bfc7328990c247d74c6f6fde4320d11d4403db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84bfc7328990c247d74c6f6fde4320d11d4403db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84bfc7328990c247d74c6f6fde4320d11d4403db"}], "stats": {"total": 72, "additions": 64, "deletions": 8}, "files": [{"sha": "779ed5948787b4221ff36f6658ab39618cd43117", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f3393ab5cc809f2636cc3ce86b3032177c91b8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f3393ab5cc809f2636cc3ce86b3032177c91b8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=33f3393ab5cc809f2636cc3ce86b3032177c91b8", "patch": "@@ -1,3 +1,8 @@\n+2018-11-20  Andreas Krebbel  <krebbel@linux.ibm.com>\n+\n+\t* config/s390/s390.md (\"clztidi2\"): Swap the RTX's written to the\n+\tDImode parts of the target operand.\n+\n 2018-11-20  Nathan Sidwell  <nathan@acm.org>\n \n \tPR 87926"}, {"sha": "30d113fd9cc94ff8f9b5ab9c03f301908b09e31e", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f3393ab5cc809f2636cc3ce86b3032177c91b8/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f3393ab5cc809f2636cc3ce86b3032177c91b8/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=33f3393ab5cc809f2636cc3ce86b3032177c91b8", "patch": "@@ -8759,17 +8759,17 @@\n   DONE;\n })\n \n+; CLZ result is in hard reg op0 - this is the high part of the target operand\n+; The source with the left-most one bit cleared is in hard reg op0 + 1 - the low part\n (define_insn \"clztidi2\"\n   [(set (match_operand:TI 0 \"register_operand\" \"=d\")\n \t(ior:TI\n-\t  (ashift:TI\n-            (zero_extend:TI\n-   \t      (xor:DI (match_operand:DI 1 \"register_operand\" \"d\")\n-                      (lshiftrt (match_operand:DI 2 \"const_int_operand\" \"\")\n-\t\t\t\t(subreg:SI (clz:DI (match_dup 1)) 4))))\n-\n-\t    (const_int 64))\n-          (zero_extend:TI (clz:DI (match_dup 1)))))\n+\t  (ashift:TI (zero_extend:TI (clz:DI (match_operand:DI 1 \"register_operand\" \"d\")))\n+\t\t     (const_int 64))\n+\t  (zero_extend:TI\n+\t   (xor:DI (match_dup 1)\n+\t\t   (lshiftrt (match_operand:DI 2 \"const_int_operand\" \"\")\n+\t\t\t     (subreg:SI (clz:DI (match_dup 1)) 4))))))\n    (clobber (reg:CC CC_REGNUM))]\n   \"UINTVAL (operands[2]) == HOST_WIDE_INT_1U << 63\n    && TARGET_EXTIMM && TARGET_ZARCH\""}, {"sha": "d522b2cebdc63211c9fbc470754290187f4489fc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f3393ab5cc809f2636cc3ce86b3032177c91b8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f3393ab5cc809f2636cc3ce86b3032177c91b8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=33f3393ab5cc809f2636cc3ce86b3032177c91b8", "patch": "@@ -1,3 +1,7 @@\n+2018-11-20  Andreas Krebbel  <krebbel@linux.ibm.com>\n+\n+\t* gcc.target/s390/flogr-1.c: New test.\n+\n 2018-11-20  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR ipa/87706"}, {"sha": "a3869000d62336d47ef8408d2e5aa68a0bbb1ff3", "filename": "gcc/testsuite/gcc.target/s390/flogr-1.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f3393ab5cc809f2636cc3ce86b3032177c91b8/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fflogr-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f3393ab5cc809f2636cc3ce86b3032177c91b8/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fflogr-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fflogr-1.c?ref=33f3393ab5cc809f2636cc3ce86b3032177c91b8", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -funroll-loops -march=z9-109\" } */\n+/* { dg-require-effective-target stdint_types } */\n+\n+/* Folding of the FLOGR caused a wrong value to be returned by\n+   __builtin_clz becuase of a problem in the RTX we emit for FLOGR.\n+   The problematic folding can only be triggered with constants inputs\n+   introduced on RTL level.  In this case it happens with loop\n+   unrolling.  */\n+\n+#include <stdint.h>\n+#include <assert.h>\n+\n+static inline uint32_t pow2_ceil_u32(uint32_t x) {\n+  if (x <= 1) {\n+    return x;\n+  }\n+  int msb_on_index;\n+  msb_on_index = (31 ^ __builtin_clz(x - 1));\n+  assert(msb_on_index < 31);\n+  return 1U << (msb_on_index + 1);\n+}\n+\n+void __attribute__((noinline,noclone))\n+die (int a)\n+{\n+  if (a)\n+    __builtin_abort ();\n+}\n+\n+void test_pow2_ceil_u32(void) {\n+  unsigned i;\n+\n+  for (i = 0; i < 18; i++) {\n+      uint32_t a_ = (pow2_ceil_u32(((uint32_t)1) << i));\n+      if (!(a_ == (((uint32_t)1) << i))) {\n+\tdie(1);\n+      }\n+  }\n+}\n+\n+int\n+main(void) {\n+  test_pow2_ceil_u32();\n+\n+  return 0;\n+}"}]}