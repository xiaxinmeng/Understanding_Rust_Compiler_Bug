{"sha": "af0d0f50722e17f9c7c23149866143e1c54d3ec3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWYwZDBmNTA3MjJlMTdmOWM3YzIzMTQ5ODY2MTQzZTFjNTRkM2VjMw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2019-10-13T07:34:31Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-10-13T07:34:31Z"}, "message": "lto-streamer-out.c (collect_block_tree_leafs): Renumber statements so non-virutal are before virutals.\n\n\t* lto-streamer-out.c (collect_block_tree_leafs): Renumber statements\n\tso non-virutal are before virutals.\n\t(output_function): Avoid body modifications.\n\nFrom-SVN: r276934", "tree": {"sha": "c25f3df4caad1c14b49dd62315caeaf196f7cb83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c25f3df4caad1c14b49dd62315caeaf196f7cb83"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af0d0f50722e17f9c7c23149866143e1c54d3ec3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af0d0f50722e17f9c7c23149866143e1c54d3ec3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af0d0f50722e17f9c7c23149866143e1c54d3ec3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af0d0f50722e17f9c7c23149866143e1c54d3ec3/comments", "author": null, "committer": null, "parents": [{"sha": "cb6055a89f71bbd2d0858bb24ce2af473804e3a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb6055a89f71bbd2d0858bb24ce2af473804e3a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb6055a89f71bbd2d0858bb24ce2af473804e3a8"}], "stats": {"total": 91, "additions": 49, "deletions": 42}, "files": [{"sha": "4df0e0dfc3a1fd17abae6002522b5a94113261b8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af0d0f50722e17f9c7c23149866143e1c54d3ec3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af0d0f50722e17f9c7c23149866143e1c54d3ec3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=af0d0f50722e17f9c7c23149866143e1c54d3ec3", "patch": "@@ -1,3 +1,9 @@\n+2019-10-12  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* lto-streamer-out.c (collect_block_tree_leafs): Renumber statements\n+\tso non-virutal are before virutals.\n+\t(output_function): Avoid body modifications.\n+\n 2019-10-12  John David Anglin  <danglin@gcc.gnu.org>\n \n \t* config/pa/pa.c (pa_output_call): Load descriptor address to register"}, {"sha": "285c010abdf552375a990351ee8b54b4f4f23e38", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 43, "deletions": 42, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af0d0f50722e17f9c7c23149866143e1c54d3ec3/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af0d0f50722e17f9c7c23149866143e1c54d3ec3/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=af0d0f50722e17f9c7c23149866143e1c54d3ec3", "patch": "@@ -2066,14 +2066,54 @@ collect_block_tree_leafs (tree root, vec<tree> &leafs)\n void\n lto_prepare_function_for_streaming (struct cgraph_node *node)\n {\n-  if (number_of_loops (DECL_STRUCT_FUNCTION (node->decl)))\n+  struct function *fn = DECL_STRUCT_FUNCTION (node->decl);\n+  basic_block bb;\n+\n+  if (number_of_loops (fn))\n     {\n-      push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n+      push_cfun (fn);\n       loop_optimizer_init (AVOID_CFG_MODIFICATIONS);\n       loop_optimizer_finalize ();\n       pop_cfun ();\n     }\n-  renumber_gimple_stmt_uids (DECL_STRUCT_FUNCTION (node->decl));\n+  /* We will renumber the statements.  The code that does this uses\n+     the same ordering that we use for serializing them so we can use\n+     the same code on the other end and not have to write out the\n+     statement numbers.  We do not assign UIDs to PHIs here because\n+     virtual PHIs get re-computed on-the-fly which would make numbers\n+     inconsistent.  */\n+  set_gimple_stmt_max_uid (fn, 0);\n+  FOR_ALL_BB_FN (bb, fn)\n+    {\n+      for (gphi_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi);\n+\t   gsi_next (&gsi))\n+\t{\n+\t  gphi *stmt = gsi.phi ();\n+\n+\t  /* Virtual PHIs are not going to be streamed.  */\n+\t  if (!virtual_operand_p (gimple_phi_result (stmt)))\n+\t    gimple_set_uid (stmt, inc_gimple_stmt_max_uid (fn));\n+\t}\n+      for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);\n+\t   gsi_next (&gsi))\n+\t{\n+\t  gimple *stmt = gsi_stmt (gsi);\n+\t  gimple_set_uid (stmt, inc_gimple_stmt_max_uid (fn));\n+\t}\n+    }\n+  /* To avoid keeping duplicate gimple IDs in the statements, renumber\n+     virtual phis now.  */\n+  FOR_ALL_BB_FN (bb, fn)\n+    {\n+      for (gphi_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi);\n+\t   gsi_next (&gsi))\n+\t{\n+\t  gphi *stmt = gsi.phi ();\n+\t  if (virtual_operand_p (gimple_phi_result (stmt)))\n+\t    gimple_set_uid (stmt, inc_gimple_stmt_max_uid (fn));\n+\t}\n+    }\n+\n }\n \n /* Output the body of function NODE->DECL.  */\n@@ -2144,45 +2184,6 @@ output_function (struct cgraph_node *node)\n       /* Output any exception handling regions.  */\n       output_eh_regions (ob, fn);\n \n-\n-      /* We will renumber the statements.  The code that does this uses\n-\t the same ordering that we use for serializing them so we can use\n-\t the same code on the other end and not have to write out the\n-\t statement numbers.  We do not assign UIDs to PHIs here because\n-\t virtual PHIs get re-computed on-the-fly which would make numbers\n-\t inconsistent.  */\n-      set_gimple_stmt_max_uid (fn, 0);\n-      FOR_ALL_BB_FN (bb, fn)\n-\t{\n-\t  for (gphi_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi);\n-\t       gsi_next (&gsi))\n-\t    {\n-\t      gphi *stmt = gsi.phi ();\n-\n-\t      /* Virtual PHIs are not going to be streamed.  */\n-\t      if (!virtual_operand_p (gimple_phi_result (stmt)))\n-\t        gimple_set_uid (stmt, inc_gimple_stmt_max_uid (fn));\n-\t    }\n-\t  for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);\n-\t       gsi_next (&gsi))\n-\t    {\n-\t      gimple *stmt = gsi_stmt (gsi);\n-\t      gimple_set_uid (stmt, inc_gimple_stmt_max_uid (fn));\n-\t    }\n-\t}\n-      /* To avoid keeping duplicate gimple IDs in the statements, renumber\n-\t virtual phis now.  */\n-      FOR_ALL_BB_FN (bb, fn)\n-\t{\n-\t  for (gphi_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi);\n-\t       gsi_next (&gsi))\n-\t    {\n-\t      gphi *stmt = gsi.phi ();\n-\t      if (virtual_operand_p (gimple_phi_result (stmt)))\n-\t        gimple_set_uid (stmt, inc_gimple_stmt_max_uid (fn));\n-\t    }\n-\t}\n-\n       /* Output the code for the function.  */\n       FOR_ALL_BB_FN (bb, fn)\n \toutput_bb (ob, bb, fn);"}]}