{"sha": "4c8c70e06a66649496afd6fed8ffa3c131c8de82", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGM4YzcwZTA2YTY2NjQ5NDk2YWZkNmZlZDhmZmEzYzEzMWM4ZGU4Mg==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2007-06-12T18:36:05Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2007-06-12T18:36:05Z"}, "message": "real.c (real_isfinite): New.\n\n\t* real.c (real_isfinite): New.\n\t(real_sqrt): Use it.\n\t* real.h (real_isfinite): New.\n\t* builtins.c: Use it.\n\nFrom-SVN: r125654", "tree": {"sha": "28a5829b4314d3e5594b4821a5e06e7b7ae2fbe9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28a5829b4314d3e5594b4821a5e06e7b7ae2fbe9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4c8c70e06a66649496afd6fed8ffa3c131c8de82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c8c70e06a66649496afd6fed8ffa3c131c8de82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c8c70e06a66649496afd6fed8ffa3c131c8de82", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c8c70e06a66649496afd6fed8ffa3c131c8de82/comments", "author": null, "committer": null, "parents": [{"sha": "058dcc25b74ed4d171182311a12d27272844ee16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/058dcc25b74ed4d171182311a12d27272844ee16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/058dcc25b74ed4d171182311a12d27272844ee16"}], "stats": {"total": 48, "additions": 30, "deletions": 18}, "files": [{"sha": "398f2417980cf2b7904a81872c1ecac1c74fa38b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c8c70e06a66649496afd6fed8ffa3c131c8de82/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c8c70e06a66649496afd6fed8ffa3c131c8de82/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4c8c70e06a66649496afd6fed8ffa3c131c8de82", "patch": "@@ -1,3 +1,10 @@\n+2007-06-12  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* real.c (real_isfinite): New.\n+\t(real_sqrt): Use it.\n+\t* real.h (real_isfinite): New.\n+\t* builtins.c: Use it.\n+\n 2007-06-12  Ian Lance Taylor  <iant@google.com>\n \t    Daniel Berlin  <dberlin@dberlin.org>\n "}, {"sha": "133aa7c8d113ae815ffb829b6410396de077b9c9", "filename": "gcc/builtins.c", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c8c70e06a66649496afd6fed8ffa3c131c8de82/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c8c70e06a66649496afd6fed8ffa3c131c8de82/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=4c8c70e06a66649496afd6fed8ffa3c131c8de82", "patch": "@@ -7774,7 +7774,7 @@ fold_builtin_int_roundingfn (tree fndecl, tree arg)\n     {\n       const REAL_VALUE_TYPE x = TREE_REAL_CST (arg);\n \n-      if (! REAL_VALUE_ISNAN (x) && ! REAL_VALUE_ISINF (x))\n+      if (real_isfinite (&x))\n \t{\n \t  tree itype = TREE_TYPE (TREE_TYPE (fndecl));\n \t  tree ftype = TREE_TYPE (arg);\n@@ -9335,8 +9335,7 @@ fold_builtin_load_exponent (tree arg0, tree arg1, tree type, bool ldexp)\n       /* If arg0 is 0, Inf or NaN, or if arg1 is 0, then return arg0.  */\n       if (real_zerop (arg0) || integer_zerop (arg1)\n \t  || (TREE_CODE (arg0) == REAL_CST\n-\t      && (real_isnan (&TREE_REAL_CST (arg0))\n-\t\t  || real_isinf (&TREE_REAL_CST (arg0)))))\n+\t      && !real_isfinite (&TREE_REAL_CST (arg0))))\n \treturn omit_one_operand (type, arg0, arg1);\n       \n       /* If both arguments are constant, then try to evaluate it.  */\n@@ -9479,8 +9478,7 @@ fold_builtin_classify (tree fndecl, tree arg, int builtin_index)\n       if (TREE_CODE (arg) == REAL_CST)\n \t{\n \t  r = TREE_REAL_CST (arg);\n-\t  return real_isinf (&r) || real_isnan (&r)\n-\t\t ? integer_zero_node : integer_one_node;\n+\t  return real_isfinite (&r) ? integer_one_node : integer_zero_node;\n \t}\n \n       return NULL_TREE;\n@@ -12361,7 +12359,7 @@ do_mpfr_ckconv (mpfr_srcptr m, tree type, int inexact)\n \t check for overflow/underflow.  If the REAL_VALUE_TYPE is zero\n \t but the mpft_t is not, then we underflowed in the\n \t conversion.  */\n-      if (!real_isnan (&rr) && !real_isinf (&rr)\n+      if (real_isfinite (&rr)\n \t  && (rr.cl == rvc_zero) == (mpfr_zero_p (m) != 0))\n         {\n \t  REAL_VALUE_TYPE rmode;\n@@ -12400,7 +12398,7 @@ do_mpfr_arg1 (tree arg, tree type, int (*func)(mpfr_ptr, mpfr_srcptr, mp_rnd_t),\n     {\n       const REAL_VALUE_TYPE *const ra = &TREE_REAL_CST (arg);\n \n-      if (!real_isnan (ra) && !real_isinf (ra)\n+      if (real_isfinite (ra)\n \t  && (!min || real_compare (inclusive ? GE_EXPR: GT_EXPR , ra, min))\n \t  && (!max || real_compare (inclusive ? LE_EXPR: LT_EXPR , ra, max)))\n         {\n@@ -12444,8 +12442,7 @@ do_mpfr_arg2 (tree arg1, tree arg2, tree type,\n       const REAL_VALUE_TYPE *const ra1 = &TREE_REAL_CST (arg1);\n       const REAL_VALUE_TYPE *const ra2 = &TREE_REAL_CST (arg2);\n \n-      if (!real_isnan (ra1) && !real_isinf (ra1)\n-\t  && !real_isnan (ra2) && !real_isinf (ra2))\n+      if (real_isfinite (ra1) && real_isfinite (ra2))\n         {\n \t  const int prec = REAL_MODE_FORMAT (TYPE_MODE (type))->p;\n \t  int inexact;\n@@ -12491,9 +12488,7 @@ do_mpfr_arg3 (tree arg1, tree arg2, tree arg3, tree type,\n       const REAL_VALUE_TYPE *const ra2 = &TREE_REAL_CST (arg2);\n       const REAL_VALUE_TYPE *const ra3 = &TREE_REAL_CST (arg3);\n \n-      if (!real_isnan (ra1) && !real_isinf (ra1)\n-\t  && !real_isnan (ra2) && !real_isinf (ra2)\n-\t  && !real_isnan (ra3) && !real_isinf (ra3))\n+      if (real_isfinite (ra1) && real_isfinite (ra2) && real_isfinite (ra3))\n         {\n \t  const int prec = REAL_MODE_FORMAT (TYPE_MODE (type))->p;\n \t  int inexact;\n@@ -12536,7 +12531,7 @@ do_mpfr_sincos (tree arg, tree arg_sinp, tree arg_cosp)\n     {\n       const REAL_VALUE_TYPE *const ra = &TREE_REAL_CST (arg);\n \n-      if (!real_isnan (ra) && !real_isinf (ra))\n+      if (real_isfinite (ra))\n         {\n \t  const int prec = REAL_MODE_FORMAT (TYPE_MODE (type))->p;\n \t  tree result_s, result_c;\n@@ -12608,7 +12603,7 @@ do_mpfr_bessel_n (tree arg1, tree arg2, tree type,\n       const REAL_VALUE_TYPE *const ra = &TREE_REAL_CST (arg2);\n \n       if (n == (long)n\n-\t  && !real_isnan (ra) && !real_isinf (ra)\n+\t  && real_isfinite (ra)\n \t  && (!min || real_compare (inclusive ? GE_EXPR: GT_EXPR , ra, min)))\n         {\n \t  const int prec = REAL_MODE_FORMAT (TYPE_MODE (type))->p;\n@@ -12650,8 +12645,7 @@ do_mpfr_remquo (tree arg0, tree arg1, tree arg_quo)\n       const REAL_VALUE_TYPE *const ra0 = TREE_REAL_CST_PTR (arg0);\n       const REAL_VALUE_TYPE *const ra1 = TREE_REAL_CST_PTR (arg1);\n \n-      if (!real_isnan (ra0) && !real_isinf (ra0)\n-\t  && !real_isnan (ra1) && !real_isinf (ra1))\n+      if (real_isfinite (ra0) && real_isfinite (ra1))\n         {\n \t  const int prec = REAL_MODE_FORMAT (TYPE_MODE (type))->p;\n \t  tree result_rem;\n@@ -12726,7 +12720,7 @@ do_mpfr_lgamma_r (tree arg, tree arg_sg, tree type)\n \n       /* In addition to NaN and Inf, the argument cannot be zero or a\n \t negative integer.  */\n-      if (!real_isnan (ra) && !real_isinf (ra)\n+      if (real_isfinite (ra)\n \t  && ra->cl != rvc_zero\n \t  && !(real_isneg(ra) && real_isinteger(ra, TYPE_MODE (type))))\n         {"}, {"sha": "b4d617f94d6ed12bfd2f63c231815b6701a820ad", "filename": "gcc/real.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c8c70e06a66649496afd6fed8ffa3c131c8de82/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c8c70e06a66649496afd6fed8ffa3c131c8de82/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=4c8c70e06a66649496afd6fed8ffa3c131c8de82", "patch": "@@ -1163,6 +1163,14 @@ real_isnan (const REAL_VALUE_TYPE *r)\n   return (r->cl == rvc_nan);\n }\n \n+/* Determine whether a floating-point value X is finite.  */\n+\n+bool\n+real_isfinite (const REAL_VALUE_TYPE *r)\n+{\n+  return (r->cl != rvc_nan) && (r->cl != rvc_inf);\n+}\n+\n /* Determine whether a floating-point value X is negative.  */\n \n bool\n@@ -4571,7 +4579,7 @@ real_sqrt (REAL_VALUE_TYPE *r, enum machine_mode mode,\n     }\n \n   /* Infinity and NaN return themselves.  */\n-  if (real_isinf (x) || real_isnan (x))\n+  if (!real_isfinite (x))\n     {\n       *r = *x;\n       return false;"}, {"sha": "09b1e52fb2c50cd3580516d9d4f610d226010691", "filename": "gcc/real.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c8c70e06a66649496afd6fed8ffa3c131c8de82/gcc%2Freal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c8c70e06a66649496afd6fed8ffa3c131c8de82/gcc%2Freal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.h?ref=4c8c70e06a66649496afd6fed8ffa3c131c8de82", "patch": "@@ -192,6 +192,9 @@ extern bool real_isinf (const REAL_VALUE_TYPE *);\n /* Determine whether a floating-point value X is a NaN.  */\n extern bool real_isnan (const REAL_VALUE_TYPE *);\n \n+/* Determine whether a floating-point value X is finite.  */\n+extern bool real_isfinite (const REAL_VALUE_TYPE *);\n+\n /* Determine whether a floating-point value X is negative.  */\n extern bool real_isneg (const REAL_VALUE_TYPE *);\n "}]}