{"sha": "7144270e2de7ba4954729c75ca389ed3081134ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzE0NDI3MGUyZGU3YmE0OTU0NzI5Yzc1Y2EzODllZDMwODExMzRlZQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-11-06T12:30:39Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-11-06T12:30:39Z"}, "message": "Move ipa-refs from ggc to heap.\n\ngcc/ChangeLog:\n\n\t* ipa-ref.h (enum ipa_ref_use): Remove GTY marker.\n\t(struct ipa_ref): Remove GTY marker; reorder for better packing.\n\t(struct ipa_ref_list): Remove GTY marker; turn references\n\tnad referring to va_heap, vl_ptr vectors; update accesors.\n\t* cgraph.h (symtab_node::iterate_reference): Update.\n\t* ipa-ref.c (ipa_ref::remove_reference): Update.\n\t* symtab.c (symtab_node::create_reference): Update.\n\t(symtab_node::remove_all_references): Update.\n\t(symtab_node::resolve_alias): Update.\n\ngcc/cp/ChangeLog:\n\n\t* tree.c (cp_fix_function_decl_p): Do not access ipa_ref_list dirrectly.", "tree": {"sha": "307a579391e35ce50e8199e2d3504aefdd5caf33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/307a579391e35ce50e8199e2d3504aefdd5caf33"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7144270e2de7ba4954729c75ca389ed3081134ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7144270e2de7ba4954729c75ca389ed3081134ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7144270e2de7ba4954729c75ca389ed3081134ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7144270e2de7ba4954729c75ca389ed3081134ee/comments", "author": null, "committer": null, "parents": [{"sha": "8a2fd716c9e9ccde7fb98c7128d2e907ece809e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a2fd716c9e9ccde7fb98c7128d2e907ece809e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a2fd716c9e9ccde7fb98c7128d2e907ece809e9"}], "stats": {"total": 53, "additions": 24, "deletions": 29}, "files": [{"sha": "73c37d8807da0e59117248f011765159e5599200", "filename": "gcc/cgraph.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7144270e2de7ba4954729c75ca389ed3081134ee/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7144270e2de7ba4954729c75ca389ed3081134ee/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=7144270e2de7ba4954729c75ca389ed3081134ee", "patch": "@@ -221,7 +221,7 @@ struct GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n   /* Get number of references for this node.  */\n   inline unsigned num_references (void)\n   {\n-    return ref_list.references ? ref_list.references->length () : 0;\n+    return ref_list.references.length ();\n   }\n \n   /* Iterates I-th reference in the list, REF is also set.  */\n@@ -604,7 +604,7 @@ struct GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n   symtab_node *same_comdat_group;\n \n   /* Vectors of referring and referenced entities.  */\n-  ipa_ref_list ref_list;\n+  ipa_ref_list GTY((skip)) ref_list;\n \n   /* Alias target. May be either DECL pointer or ASSEMBLER_NAME pointer\n      depending to what was known to frontend on the creation time.\n@@ -2676,7 +2676,7 @@ symtab_node::next_defined_symbol (void)\n inline ipa_ref *\n symtab_node::iterate_reference (unsigned i, ipa_ref *&ref)\n {\n-  vec_safe_iterate (ref_list.references, i, &ref);\n+  ref_list.references.iterate (i, &ref);\n \n   return ref;\n }"}, {"sha": "28e591086b3876645d6d1a445eb4e9ca92692ec6", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7144270e2de7ba4954729c75ca389ed3081134ee/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7144270e2de7ba4954729c75ca389ed3081134ee/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=7144270e2de7ba4954729c75ca389ed3081134ee", "patch": "@@ -5719,8 +5719,7 @@ cp_fix_function_decl_p (tree decl)\n \n       /* Don't fix same_body aliases.  Although they don't have their own\n \t CFG, they share it with what they alias to.  */\n-      if (!node || !node->alias\n-\t  || !vec_safe_length (node->ref_list.references))\n+      if (!node || !node->alias || !node->num_references ())\n \treturn true;\n     }\n "}, {"sha": "b7217c427f2804717e16057f5fa81364db4cec7e", "filename": "gcc/ipa-ref.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7144270e2de7ba4954729c75ca389ed3081134ee/gcc%2Fipa-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7144270e2de7ba4954729c75ca389ed3081134ee/gcc%2Fipa-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-ref.c?ref=7144270e2de7ba4954729c75ca389ed3081134ee", "patch": "@@ -32,7 +32,6 @@ ipa_ref::remove_reference ()\n {\n   struct ipa_ref_list *list = referred_ref_list ();\n   struct ipa_ref_list *list2 = referring_ref_list ();\n-  vec<ipa_ref_t, va_gc> *old_references = list2->references;\n   struct ipa_ref *last;\n \n   gcc_assert (list->referring[referred_index] == this);\n@@ -66,7 +65,7 @@ ipa_ref::remove_reference ()\n     }\n   list->referring.pop ();\n \n-  last = &list2->references->last ();\n+  last = &list2->references.last ();\n \n   struct ipa_ref *ref = this;\n \n@@ -75,8 +74,7 @@ ipa_ref::remove_reference ()\n       *ref = *last;\n       ref->referred_ref_list ()->referring[referred_index] = ref;\n     }\n-  list2->references->pop ();\n-  gcc_assert (list2->references == old_references);\n+  list2->references.pop ();\n }\n \n /* Return true when execution of reference can lead to return from"}, {"sha": "3ea3f665c3bc74a0bb9cd273733befed8e12782a", "filename": "gcc/ipa-ref.h", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7144270e2de7ba4954729c75ca389ed3081134ee/gcc%2Fipa-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7144270e2de7ba4954729c75ca389ed3081134ee/gcc%2Fipa-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-ref.h?ref=7144270e2de7ba4954729c75ca389ed3081134ee", "patch": "@@ -27,7 +27,7 @@ struct symtab_node;\n \n \n /* How the reference is done.  */\n-enum GTY(()) ipa_ref_use\n+enum ipa_ref_use\n {\n   IPA_REF_LOAD,\n   IPA_REF_STORE,\n@@ -36,7 +36,7 @@ enum GTY(()) ipa_ref_use\n };\n \n /* Record of reference in callgraph or varpool.  */\n-struct GTY(()) ipa_ref\n+struct ipa_ref\n {\n public:\n   /* Remove reference.  */\n@@ -59,28 +59,27 @@ struct GTY(()) ipa_ref\n   symtab_node *referred;\n   gimple *stmt;\n   unsigned int lto_stmt_uid;\n+  unsigned int referred_index;\n   /* speculative id is used to link direct calls with their corresponding\n      IPA_REF_ADDR references when representing speculative calls.  */\n   unsigned int speculative_id : 16;\n-  unsigned int referred_index;\n   ENUM_BITFIELD (ipa_ref_use) use:3;\n   unsigned int speculative:1;\n };\n \n typedef struct ipa_ref ipa_ref_t;\n-typedef struct ipa_ref *ipa_ref_ptr;\n \n \n /* List of references.  This is stored in both callgraph and varpool nodes.  */\n-struct GTY(()) ipa_ref_list\n+struct ipa_ref_list\n {\n public:\n   /* Return first reference in list or NULL if empty.  */\n   struct ipa_ref *first_reference (void)\n   {\n-    if (!vec_safe_length (references))\n+    if (!references.length ())\n       return NULL;\n-    return &(*references)[0];\n+    return &references[0];\n   }\n \n   /* Return first referring ref in list or NULL if empty.  */\n@@ -121,20 +120,20 @@ struct GTY(()) ipa_ref_list\n   void clear (void)\n   {\n     referring.create (0);\n-    references = NULL;\n+    references.create (0);\n   }\n \n   /* Return number of references.  */\n   unsigned int nreferences (void)\n   {\n-    return vec_safe_length (references);\n+    return references.length ();\n   }\n \n   /* Store actual references in references vector.  */\n-  vec<ipa_ref_t, va_gc> *references;\n+  vec<ipa_ref_t, va_heap, vl_ptr> references;\n   /* Referring is vector of pointers to references.  It must not live in GGC space\n      or GGC will try to mark middle of references vectors.  */\n-  vec<ipa_ref_ptr>  GTY((skip)) referring;\n+  vec<ipa_ref_t *, va_heap, vl_ptr> referring;\n };\n \n #endif /* GCC_IPA_REF_H */"}, {"sha": "58b14f321c59c7120373c89affee669d851490ae", "filename": "gcc/symtab.c", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7144270e2de7ba4954729c75ca389ed3081134ee/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7144270e2de7ba4954729c75ca389ed3081134ee/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=7144270e2de7ba4954729c75ca389ed3081134ee", "patch": "@@ -592,10 +592,9 @@ symtab_node::create_reference (symtab_node *referred_node,\n   gcc_checking_assert (use_type != IPA_REF_ALIAS || !stmt);\n \n   list = &ref_list;\n-  old_references = vec_safe_address (list->references);\n-  vec_safe_grow (list->references, vec_safe_length (list->references) + 1,\n-\t\t true);\n-  ref = &list->references->last ();\n+  old_references = list->references.address ();\n+  list->references.safe_grow (list->references.length () + 1, false);\n+  ref = &list->references.last ();\n \n   list2 = &referred_node->ref_list;\n \n@@ -623,7 +622,7 @@ symtab_node::create_reference (symtab_node *referred_node,\n   ref->speculative = 0;\n \n   /* If vector was moved in memory, update pointers.  */\n-  if (old_references != list->references->address ())\n+  if (old_references != list->references.address ())\n     {\n       int i;\n       for (i = 0; iterate_reference(i, ref2); i++)\n@@ -786,9 +785,9 @@ symtab_node::clear_stmts_in_references (void)\n void\n symtab_node::remove_all_references (void)\n {\n-  while (vec_safe_length (ref_list.references))\n-    ref_list.references->last ().remove_reference ();\n-  vec_free (ref_list.references);\n+  while (ref_list.references.length ())\n+    ref_list.references.last ().remove_reference ();\n+  ref_list.references.release ();\n }\n \n /* Remove all referring items in ref list.  */\n@@ -1774,7 +1773,7 @@ symtab_node::resolve_alias (symtab_node *target, bool transparent)\n {\n   symtab_node *n;\n \n-  gcc_assert (!analyzed && !vec_safe_length (ref_list.references));\n+  gcc_assert (!analyzed && !ref_list.references.length ());\n \n   /* Never let cycles to creep into the symbol table alias references;\n      those will make alias walkers to be infinite.  */"}]}