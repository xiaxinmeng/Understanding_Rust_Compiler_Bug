{"sha": "596883039a3e90fef3aa597d7d5ebae467543e39", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTk2ODgzMDM5YTNlOTBmZWYzYWE1OTdkN2Q1ZWJhZTQ2NzU0M2UzOQ==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2018-12-27T08:59:35Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2018-12-27T08:59:35Z"}, "message": "Fix slowness in gcov (PR gcov-profile/88225).\n\n2018-12-27  Martin Liska  <mliska@suse.cz>\n\n\tPR gcov-profile/88225\n\t* gcov.c(source_info::get_functions_at_location):\n\tUse newly added line_to_function_map.\n\t(source_info::add_function): New.\n\t(output_json_intermediate_file): Use a pointer return\n\ttype for get_functions_at_location.\n\t(process_all_functions): Use add_function instead\n\tof direct push to a s->functions container.\n\t(release_structures): Release ident_to_fn.\n\t(read_graph_file): Register function into ident_to_fn.\n\t(read_count_file): Use the map.\n\t(output_lines): Handle pointer return type of\n\tget_functions_at_location.\n\nFrom-SVN: r267431", "tree": {"sha": "7654f343d6eda4fb6c4fbb9733a4154798f37342", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7654f343d6eda4fb6c4fbb9733a4154798f37342"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/596883039a3e90fef3aa597d7d5ebae467543e39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/596883039a3e90fef3aa597d7d5ebae467543e39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/596883039a3e90fef3aa597d7d5ebae467543e39", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/596883039a3e90fef3aa597d7d5ebae467543e39/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "42bdb8f24940aa932e73feda2750e0e80c018441", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42bdb8f24940aa932e73feda2750e0e80c018441", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42bdb8f24940aa932e73feda2750e0e80c018441"}], "stats": {"total": 128, "additions": 80, "deletions": 48}, "files": [{"sha": "b8f39f1e1a290189afa64ebbed63d357edd0c342", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/596883039a3e90fef3aa597d7d5ebae467543e39/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/596883039a3e90fef3aa597d7d5ebae467543e39/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=596883039a3e90fef3aa597d7d5ebae467543e39", "patch": "@@ -1,3 +1,19 @@\n+2018-12-27  Martin Liska  <mliska@suse.cz>\n+\n+\tPR gcov-profile/88225\n+\t* gcov.c(source_info::get_functions_at_location):\n+\tUse newly added line_to_function_map.\n+\t(source_info::add_function): New.\n+\t(output_json_intermediate_file): Use a pointer return\n+\ttype for get_functions_at_location.\n+\t(process_all_functions): Use add_function instead\n+\tof direct push to a s->functions container.\n+\t(release_structures): Release ident_to_fn.\n+\t(read_graph_file): Register function into ident_to_fn.\n+\t(read_count_file): Use the map.\n+\t(output_lines): Handle pointer return type of\n+\tget_functions_at_location.\n+\n 2018-12-27  Martin Liska  <mliska@suse.cz>\n \n \t* builtins.c (expand_movstr): Compare with RETURN_BEGIN."}, {"sha": "23d75f892656db16d573b2874dfc907161315c42", "filename": "gcc/gcov.c", "status": "modified", "additions": 64, "deletions": 48, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/596883039a3e90fef3aa597d7d5ebae467543e39/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/596883039a3e90fef3aa597d7d5ebae467543e39/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=596883039a3e90fef3aa597d7d5ebae467543e39", "patch": "@@ -358,7 +358,10 @@ struct source_info\n   /* Default constructor.  */\n   source_info ();\n \n-  vector<function_info *> get_functions_at_location (unsigned line_num) const;\n+  vector<function_info *> *get_functions_at_location (unsigned line_num) const;\n+\n+  /* Register a new function.  */\n+  void add_function (function_info *fn);\n \n   /* Index of the source_info in sources vector.  */\n   unsigned index;\n@@ -377,29 +380,44 @@ struct source_info\n \n   /* Functions in this source file.  These are in ascending line\n      number order.  */\n-  vector <function_info *> functions;\n+  vector<function_info *> functions;\n+\n+  /* Line number to functions map.  */\n+  vector<vector<function_info *> *> line_to_function_map;\n };\n \n source_info::source_info (): index (0), name (NULL), file_time (),\n   lines (), coverage (), maximum_count (0), functions ()\n {\n }\n \n-vector<function_info *>\n-source_info::get_functions_at_location (unsigned line_num) const\n+/* Register a new function.  */\n+void\n+source_info::add_function (function_info *fn)\n {\n-  vector<function_info *> r;\n+  functions.push_back (fn);\n \n-  for (vector<function_info *>::const_iterator it = functions.begin ();\n-       it != functions.end (); it++)\n-    {\n-      if ((*it)->start_line == line_num && (*it)->src == index)\n-\tr.push_back (*it);\n-    }\n+  if (fn->start_line >= line_to_function_map.size ())\n+    line_to_function_map.resize (fn->start_line + 1);\n+\n+  vector<function_info *> **slot = &line_to_function_map[fn->start_line];\n+  if (*slot == NULL)\n+    *slot = new vector<function_info *> ();\n \n-  std::sort (r.begin (), r.end (), function_line_start_cmp ());\n+  (*slot)->push_back (fn);\n+}\n+\n+vector<function_info *> *\n+source_info::get_functions_at_location (unsigned line_num) const\n+{\n+  if (line_num >= line_to_function_map.size ())\n+    return NULL;\n \n-  return r;\n+  vector<function_info *> *slot = line_to_function_map[line_num];\n+  if (slot != NULL)\n+    std::sort (slot->begin (), slot->end (), function_line_start_cmp ());\n+\n+  return slot;\n }\n \n class name_map\n@@ -438,6 +456,9 @@ class name_map\n /* Vector of all functions.  */\n static vector<function_info *> functions;\n \n+/* Function ident to function_info * map.  */\n+static map<unsigned, function_info *> ident_to_fn;\n+\n /* Vector of source files.  */\n static vector<source_info> sources;\n \n@@ -1121,19 +1142,20 @@ output_json_intermediate_file (json::array *json_files, source_info *src)\n \n   for (unsigned line_num = 1; line_num <= src->lines.size (); line_num++)\n     {\n-      vector<function_info *> fns = src->get_functions_at_location (line_num);\n+      vector<function_info *> *fns = src->get_functions_at_location (line_num);\n \n-      /* Print first group functions that begin on the line.  */\n-      for (vector<function_info *>::iterator it2 = fns.begin ();\n-\t   it2 != fns.end (); it2++)\n-\t{\n-\t  vector<line_info> &lines = (*it2)->lines;\n-\t  for (unsigned i = 0; i < lines.size (); i++)\n-\t    {\n-\t      line_info *line = &lines[i];\n-\t      output_intermediate_json_line (lineso, line, line_num + i);\n-\t    }\n-\t}\n+      if (fns != NULL)\n+\t/* Print first group functions that begin on the line.  */\n+\tfor (vector<function_info *>::iterator it2 = fns->begin ();\n+\t     it2 != fns->end (); it2++)\n+\t  {\n+\t    vector<line_info> &lines = (*it2)->lines;\n+\t    for (unsigned i = 0; i < lines.size (); i++)\n+\t      {\n+\t\tline_info *line = &lines[i];\n+\t\toutput_intermediate_json_line (lineso, line, line_num + i);\n+\t      }\n+\t  }\n \n       /* Follow with lines associated with the source file.  */\n       if (line_num < src->lines.size ())\n@@ -1256,7 +1278,7 @@ process_all_functions (void)\n       if (!fn->counts.empty () || no_data_file)\n \t{\n \t  source_info *s = &sources[src];\n-\t  s->functions.push_back (fn);\n+\t  s->add_function (fn);\n \n \t  /* Mark last line in files touched by function.  */\n \t  for (unsigned block_no = 0; block_no != fn->blocks.size ();\n@@ -1475,6 +1497,7 @@ release_structures (void)\n   sources.resize (0);\n   names.resize (0);\n   functions.resize (0);\n+  ident_to_fn.clear ();\n }\n \n /* Generate the names of the graph and data files.  If OBJECT_DIRECTORY\n@@ -1693,6 +1716,8 @@ read_graph_file (void)\n \n \t  fn = new function_info ();\n \t  functions.push_back (fn);\n+\t  ident_to_fn[ident] = fn;\n+\n \t  fn->m_name = function_name;\n \t  fn->ident = ident;\n \t  fn->lineno_checksum = lineno_checksum;\n@@ -1843,6 +1868,7 @@ read_count_file (void)\n   unsigned tag;\n   function_info *fn = NULL;\n   int error = 0;\n+  map<unsigned, function_info *>::iterator it;\n \n   if (!gcov_open (da_file_name, 1))\n     {\n@@ -1892,21 +1918,11 @@ read_count_file (void)\n       else if (tag == GCOV_TAG_FUNCTION && length == GCOV_TAG_FUNCTION_LENGTH)\n \t{\n \t  unsigned ident;\n-\n-\t  /* Try to find the function in the list.  To speed up the\n-\t     search, first start from the last function found.  */\n \t  ident = gcov_read_unsigned ();\n-\n \t  fn = NULL;\n-\t  for (vector<function_info *>::reverse_iterator it\n-\t       = functions.rbegin (); it != functions.rend (); it++)\n-\t    {\n-\t      if ((*it)->ident == ident)\n-\t\t{\n-\t\t  fn = *it;\n-\t\t  break;\n-\t\t}\n-\t    }\n+\t  it = ident_to_fn.find (ident);\n+\t  if (it != ident_to_fn.end ())\n+\t    fn = it->second;\n \n \t  if (!fn)\n \t    ;\n@@ -3023,7 +3039,7 @@ output_lines (FILE *gcov_file, const source_info *src)\n       source_lines.push_back (xstrdup (retval));\n \n   unsigned line_start_group = 0;\n-  vector<function_info *> fns;\n+  vector<function_info *> *fns;\n \n   for (unsigned line_num = 1; line_num <= source_lines.size (); line_num++)\n     {\n@@ -3039,18 +3055,18 @@ output_lines (FILE *gcov_file, const source_info *src)\n       if (line_start_group == 0)\n \t{\n \t  fns = src->get_functions_at_location (line_num);\n-\t  if (fns.size () > 1)\n+\t  if (fns != NULL && fns->size () > 1)\n \t    {\n \t      /* It's possible to have functions that partially overlap,\n \t\t thus take the maximum end_line of functions starting\n \t\t at LINE_NUM.  */\n-\t      for (unsigned i = 0; i < fns.size (); i++)\n-\t\tif (fns[i]->end_line > line_start_group)\n-\t\t  line_start_group = fns[i]->end_line;\n+\t      for (unsigned i = 0; i < fns->size (); i++)\n+\t\tif ((*fns)[i]->end_line > line_start_group)\n+\t\t  line_start_group = (*fns)[i]->end_line;\n \t    }\n-\t  else if (fns.size () == 1)\n+\t  else if (fns != NULL && fns->size () == 1)\n \t    {\n-\t      function_info *fn = fns[0];\n+\t      function_info *fn = (*fns)[0];\n \t      output_function_details (gcov_file, fn);\n \t    }\n \t}\n@@ -3070,8 +3086,8 @@ output_lines (FILE *gcov_file, const source_info *src)\n \n       if (line_start_group == line_num)\n \t{\n-\t  for (vector<function_info *>::iterator it = fns.begin ();\n-\t       it != fns.end (); it++)\n+\t  for (vector<function_info *>::iterator it = fns->begin ();\n+\t       it != fns->end (); it++)\n \t    {\n \t      function_info *fn = *it;\n \t      vector<line_info> &lines = fn->lines;"}]}