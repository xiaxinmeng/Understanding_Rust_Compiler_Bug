{"sha": "b0e5163960eceab701a1a25dfa049e394fe5b3de", "node_id": "C_kwDOANBUbNoAKGIwZTUxNjM5NjBlY2VhYjcwMWExYTI1ZGZhMDQ5ZTM5NGZlNWIzZGU", "commit": {"author": {"name": "Robin Dapp", "email": "rdapp@linux.ibm.com", "date": "2022-01-13T08:51:07Z"}, "committer": {"name": "Robin Dapp", "email": "rdapp@linux.ibm.com", "date": "2022-01-13T19:05:18Z"}, "message": "vect: Add bias parameter for partial vectorization\n\nThis introduces a bias parameter for the len_load/len_store ifns as well as\noptabs that is meant to distinguish between Power and s390 variants.\nPowerPC's instructions require a bias of 0, while in s390's case\nvll/vstl do not support lengths of zero bytes and a bias of -1 must be used.\n\ngcc/ChangeLog:\n\n\t* internal-fn.c (expand_partial_load_optab_fn): Add bias.\n\t(expand_partial_store_optab_fn): Likewise.\n\t(internal_len_load_store_bias): New function.\n\t* internal-fn.h (VECT_PARTIAL_BIAS_UNSUPPORTED): New define.\n\t(internal_len_load_store_bias): New function.\n\t* tree-vect-loop-manip.c (vect_set_loop_controls_directly): Set bias.\n\t(vect_set_loop_condition_partial_vectors): Add header_seq parameter.\n\t* tree-vect-loop.c (vect_verify_loop_lens): Verify bias.\n\t(vect_estimate_min_profitable_iters): Account for bias.\n\t(vect_get_loop_len): Add bias-adjusted length.\n\t* tree-vect-stmts.c (vectorizable_store): Use.\n\t(vectorizable_load): Use.\n\t* tree-vectorizer.h (struct rgroup_controls): Add bias-adjusted length.\n\t(LOOP_VINFO_PARTIAL_LOAD_STORE_BIAS): New macro.\n\t* config/rs6000/vsx.md: Use const0 bias predicate.\n\t* doc/md.texi: Document bias value.", "tree": {"sha": "6f06da924ca25a3ea73e937f55eda28cbcdd51f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f06da924ca25a3ea73e937f55eda28cbcdd51f7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0e5163960eceab701a1a25dfa049e394fe5b3de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0e5163960eceab701a1a25dfa049e394fe5b3de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0e5163960eceab701a1a25dfa049e394fe5b3de", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0e5163960eceab701a1a25dfa049e394fe5b3de/comments", "author": {"login": "rdapp-ibm", "id": 80318053, "node_id": "MDQ6VXNlcjgwMzE4MDUz", "avatar_url": "https://avatars.githubusercontent.com/u/80318053?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rdapp-ibm", "html_url": "https://github.com/rdapp-ibm", "followers_url": "https://api.github.com/users/rdapp-ibm/followers", "following_url": "https://api.github.com/users/rdapp-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/rdapp-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rdapp-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rdapp-ibm/subscriptions", "organizations_url": "https://api.github.com/users/rdapp-ibm/orgs", "repos_url": "https://api.github.com/users/rdapp-ibm/repos", "events_url": "https://api.github.com/users/rdapp-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/rdapp-ibm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rdapp-ibm", "id": 80318053, "node_id": "MDQ6VXNlcjgwMzE4MDUz", "avatar_url": "https://avatars.githubusercontent.com/u/80318053?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rdapp-ibm", "html_url": "https://github.com/rdapp-ibm", "followers_url": "https://api.github.com/users/rdapp-ibm/followers", "following_url": "https://api.github.com/users/rdapp-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/rdapp-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rdapp-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rdapp-ibm/subscriptions", "organizations_url": "https://api.github.com/users/rdapp-ibm/orgs", "repos_url": "https://api.github.com/users/rdapp-ibm/repos", "events_url": "https://api.github.com/users/rdapp-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/rdapp-ibm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "69561fc781aca3dea3aa4d5d562ef5a502965924", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69561fc781aca3dea3aa4d5d562ef5a502965924", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69561fc781aca3dea3aa4d5d562ef5a502965924"}], "stats": {"total": 220, "additions": 185, "deletions": 35}, "files": [{"sha": "7bcf48fa0b086bbf8b85a483586c96e64141782a", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0e5163960eceab701a1a25dfa049e394fe5b3de/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0e5163960eceab701a1a25dfa049e394fe5b3de/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=b0e5163960eceab701a1a25dfa049e394fe5b3de", "patch": "@@ -5632,7 +5632,8 @@\n (define_expand \"len_load_v16qi\"\n   [(match_operand:V16QI 0 \"vlogical_operand\")\n    (match_operand:V16QI 1 \"memory_operand\")\n-   (match_operand:QI 2 \"gpc_reg_operand\")]\n+   (match_operand:QI 2 \"gpc_reg_operand\")\n+   (match_operand:QI 3 \"zero_constant\")]\n   \"TARGET_P9_VECTOR && TARGET_64BIT\"\n {\n   rtx mem = XEXP (operands[1], 0);\n@@ -5646,6 +5647,7 @@\n   [(match_operand:V16QI 0 \"memory_operand\")\n    (match_operand:V16QI 1 \"vlogical_operand\")\n    (match_operand:QI 2 \"gpc_reg_operand\")\n+   (match_operand:QI 3 \"zero_constant\")\n   ]\n   \"TARGET_P9_VECTOR && TARGET_64BIT\"\n {"}, {"sha": "261933a4212696e960f78d19e12c7a185d8c4b22", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0e5163960eceab701a1a25dfa049e394fe5b3de/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0e5163960eceab701a1a25dfa049e394fe5b3de/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=b0e5163960eceab701a1a25dfa049e394fe5b3de", "patch": "@@ -5214,25 +5214,43 @@ This pattern is not allowed to @code{FAIL}.\n \n @cindex @code{len_load_@var{m}} instruction pattern\n @item @samp{len_load_@var{m}}\n-Load the number of vector elements specified by operand 2 from memory\n-operand 1 into vector register operand 0, setting the other elements of\n+Load (operand 2 - operand 3) elements from vector memory operand 1\n+into vector register operand 0, setting the other elements of\n operand 0 to undefined values.  Operands 0 and 1 have mode @var{m},\n which must be a vector mode.  Operand 2 has whichever integer mode the\n-target prefers.  If operand 2 exceeds the number of elements in mode\n-@var{m}, the behavior is undefined.  If the target prefers the length\n-to be measured in bytes rather than elements, it should only implement\n-this pattern for vectors of @code{QI} elements.\n+target prefers.  Operand 3 conceptually has mode @code{QI}.\n+\n+Operand 2 can be a variable or a constant amount.  Operand 3 specifies a\n+constant bias: it is either a constant 0 or a constant -1.  The predicate on\n+operand 3 must only accept the bias values that the target actually supports.\n+GCC handles a bias of 0 more efficiently than a bias of -1.\n+\n+If (operand 2 - operand 3) exceeds the number of elements in mode\n+@var{m}, the behavior is undefined.\n+\n+If the target prefers the length to be measured in bytes rather than\n+elements, it should only implement this pattern for vectors of @code{QI}\n+elements.\n \n This pattern is not allowed to @code{FAIL}.\n \n @cindex @code{len_store_@var{m}} instruction pattern\n @item @samp{len_store_@var{m}}\n-Store the number of vector elements specified by operand 2 from vector\n-register operand 1 into memory operand 0, leaving the other elements of\n+Store (operand 2 - operand 3) vector elements from vector register operand 1\n+into memory operand 0, leaving the other elements of\n operand 0 unchanged.  Operands 0 and 1 have mode @var{m}, which must be\n a vector mode.  Operand 2 has whichever integer mode the target prefers.\n-If operand 2 exceeds the number of elements in mode @var{m}, the behavior\n-is undefined.  If the target prefers the length to be measured in bytes\n+Operand 3 conceptually has mode @code{QI}.\n+\n+Operand 2 can be a variable or a constant amount.  Operand 3 specifies a\n+constant bias: it is either a constant 0 or a constant -1.  The predicate on\n+operand 3 must only accept the bias values that the target actually supports.\n+GCC handles a bias of 0 more efficiently than a bias of -1.\n+\n+If (operand 2 - operand 3) exceeds the number of elements in mode\n+@var{m}, the behavior is undefined.\n+\n+If the target prefers the length to be measured in bytes\n rather than elements, it should only implement this pattern for vectors\n of @code{QI} elements.\n "}, {"sha": "b922e6a0090dbeaaa4477cb11dc298a9d813087d", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 55, "deletions": 14, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0e5163960eceab701a1a25dfa049e394fe5b3de/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0e5163960eceab701a1a25dfa049e394fe5b3de/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=b0e5163960eceab701a1a25dfa049e394fe5b3de", "patch": "@@ -2696,9 +2696,9 @@ expand_call_mem_ref (tree type, gcall *stmt, int index)\n static void\n expand_partial_load_optab_fn (internal_fn, gcall *stmt, convert_optab optab)\n {\n-  class expand_operand ops[3];\n-  tree type, lhs, rhs, maskt;\n-  rtx mem, target, mask;\n+  class expand_operand ops[4];\n+  tree type, lhs, rhs, maskt, biast;\n+  rtx mem, target, mask, bias;\n   insn_code icode;\n \n   maskt = gimple_call_arg (stmt, 2);\n@@ -2723,11 +2723,20 @@ expand_partial_load_optab_fn (internal_fn, gcall *stmt, convert_optab optab)\n   create_output_operand (&ops[0], target, TYPE_MODE (type));\n   create_fixed_operand (&ops[1], mem);\n   if (optab == len_load_optab)\n-    create_convert_operand_from (&ops[2], mask, TYPE_MODE (TREE_TYPE (maskt)),\n-\t\t\t\t TYPE_UNSIGNED (TREE_TYPE (maskt)));\n+    {\n+      create_convert_operand_from (&ops[2], mask, TYPE_MODE (TREE_TYPE (maskt)),\n+\t\t\t\t   TYPE_UNSIGNED (TREE_TYPE (maskt)));\n+      biast = gimple_call_arg (stmt, 3);\n+      bias = expand_normal (biast);\n+      create_input_operand (&ops[3], bias, QImode);\n+      expand_insn (icode, 4, ops);\n+    }\n   else\n-    create_input_operand (&ops[2], mask, TYPE_MODE (TREE_TYPE (maskt)));\n-  expand_insn (icode, 3, ops);\n+    {\n+      create_input_operand (&ops[2], mask, TYPE_MODE (TREE_TYPE (maskt)));\n+      expand_insn (icode, 3, ops);\n+    }\n+\n   if (!rtx_equal_p (target, ops[0].value))\n     emit_move_insn (target, ops[0].value);\n }\n@@ -2741,9 +2750,9 @@ expand_partial_load_optab_fn (internal_fn, gcall *stmt, convert_optab optab)\n static void\n expand_partial_store_optab_fn (internal_fn, gcall *stmt, convert_optab optab)\n {\n-  class expand_operand ops[3];\n-  tree type, lhs, rhs, maskt;\n-  rtx mem, reg, mask;\n+  class expand_operand ops[4];\n+  tree type, lhs, rhs, maskt, biast;\n+  rtx mem, reg, mask, bias;\n   insn_code icode;\n \n   maskt = gimple_call_arg (stmt, 2);\n@@ -2766,11 +2775,19 @@ expand_partial_store_optab_fn (internal_fn, gcall *stmt, convert_optab optab)\n   create_fixed_operand (&ops[0], mem);\n   create_input_operand (&ops[1], reg, TYPE_MODE (type));\n   if (optab == len_store_optab)\n-    create_convert_operand_from (&ops[2], mask, TYPE_MODE (TREE_TYPE (maskt)),\n-\t\t\t\t TYPE_UNSIGNED (TREE_TYPE (maskt)));\n+    {\n+      create_convert_operand_from (&ops[2], mask, TYPE_MODE (TREE_TYPE (maskt)),\n+\t\t\t\t   TYPE_UNSIGNED (TREE_TYPE (maskt)));\n+      biast = gimple_call_arg (stmt, 4);\n+      bias = expand_normal (biast);\n+      create_input_operand (&ops[3], bias, QImode);\n+      expand_insn (icode, 4, ops);\n+    }\n   else\n-    create_input_operand (&ops[2], mask, TYPE_MODE (TREE_TYPE (maskt)));\n-  expand_insn (icode, 3, ops);\n+    {\n+      create_input_operand (&ops[2], mask, TYPE_MODE (TREE_TYPE (maskt)));\n+      expand_insn (icode, 3, ops);\n+    }\n }\n \n #define expand_mask_store_optab_fn expand_partial_store_optab_fn\n@@ -4323,6 +4340,30 @@ internal_check_ptrs_fn_supported_p (internal_fn ifn, tree type,\n \t  && insn_operand_matches (icode, 4, GEN_INT (align)));\n }\n \n+/* Return the supported bias for IFN which is either IFN_LEN_LOAD\n+   or IFN_LEN_STORE.  For now we only support the biases of 0 and -1\n+   (in case 0 is not an allowable length for len_load or len_store).\n+   If none of the biases match what the backend provides, return\n+   VECT_PARTIAL_BIAS_UNSUPPORTED.  */\n+\n+signed char\n+internal_len_load_store_bias (internal_fn ifn, machine_mode mode)\n+{\n+  optab optab = direct_internal_fn_optab (ifn);\n+  insn_code icode = direct_optab_handler (optab, mode);\n+\n+  if (icode != CODE_FOR_nothing)\n+    {\n+      /* For now we only support biases of 0 or -1.  Try both of them.  */\n+      if (insn_operand_matches (icode, 3, GEN_INT (0)))\n+\treturn 0;\n+      if (insn_operand_matches (icode, 3, GEN_INT (-1)))\n+\treturn -1;\n+    }\n+\n+  return VECT_PARTIAL_BIAS_UNSUPPORTED;\n+}\n+\n /* Expand STMT as though it were a call to internal function FN.  */\n \n void"}, {"sha": "036d59d71381f6883164f9e2c1737cc5fc2d0ce9", "filename": "gcc/internal-fn.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0e5163960eceab701a1a25dfa049e394fe5b3de/gcc%2Finternal-fn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0e5163960eceab701a1a25dfa049e394fe5b3de/gcc%2Finternal-fn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.h?ref=b0e5163960eceab701a1a25dfa049e394fe5b3de", "patch": "@@ -230,6 +230,10 @@ extern bool internal_gather_scatter_fn_supported_p (internal_fn, tree,\n \t\t\t\t\t\t    tree, tree, int);\n extern bool internal_check_ptrs_fn_supported_p (internal_fn, tree,\n \t\t\t\t\t\tpoly_uint64, unsigned int);\n+#define VECT_PARTIAL_BIAS_UNSUPPORTED 127\n+\n+extern signed char internal_len_load_store_bias (internal_fn ifn,\n+\t\t\t\t\t\t machine_mode);\n \n extern void expand_addsub_overflow (location_t, tree_code, tree, tree, tree,\n \t\t\t\t    bool, bool, bool, bool, tree *);"}, {"sha": "a7bbc916bbcfc68508540e16c39c51a15f6a5f06", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0e5163960eceab701a1a25dfa049e394fe5b3de/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0e5163960eceab701a1a25dfa049e394fe5b3de/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=b0e5163960eceab701a1a25dfa049e394fe5b3de", "patch": "@@ -421,6 +421,7 @@ vect_maybe_permute_loop_masks (gimple_seq *seq, rgroup_controls *dest_rgm,\n static tree\n vect_set_loop_controls_directly (class loop *loop, loop_vec_info loop_vinfo,\n \t\t\t\t gimple_seq *preheader_seq,\n+\t\t\t\t gimple_seq *header_seq,\n \t\t\t\t gimple_stmt_iterator loop_cond_gsi,\n \t\t\t\t rgroup_controls *rgc, tree niters,\n \t\t\t\t tree niters_skip, bool might_wrap_p)\n@@ -664,6 +665,19 @@ vect_set_loop_controls_directly (class loop *loop, loop_vec_info loop_vinfo,\n \n       vect_set_loop_control (loop, ctrl, init_ctrl, next_ctrl);\n     }\n+\n+  int partial_load_bias = LOOP_VINFO_PARTIAL_LOAD_STORE_BIAS (loop_vinfo);\n+  if (partial_load_bias != 0)\n+    {\n+      tree adjusted_len = rgc->bias_adjusted_ctrl;\n+      gassign *minus = gimple_build_assign (adjusted_len, PLUS_EXPR,\n+\t\t\t\t\t    rgc->controls[0],\n+\t\t\t\t\t    build_int_cst\n+\t\t\t\t\t    (TREE_TYPE (rgc->controls[0]),\n+\t\t\t\t\t     partial_load_bias));\n+      gimple_seq_add_stmt (header_seq, minus);\n+    }\n+\n   return next_ctrl;\n }\n \n@@ -744,6 +758,7 @@ vect_set_loop_condition_partial_vectors (class loop *loop,\n \t/* Set up all controls for this group.  */\n \ttest_ctrl = vect_set_loop_controls_directly (loop, loop_vinfo,\n \t\t\t\t\t\t     &preheader_seq,\n+\t\t\t\t\t\t     &header_seq,\n \t\t\t\t\t\t     loop_cond_gsi, rgc,\n \t\t\t\t\t\t     niters, niters_skip,\n \t\t\t\t\t\t     might_wrap_p);"}, {"sha": "8748b1a55936b0137d4f9688dfd255ce607c1ab6", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 48, "deletions": 1, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0e5163960eceab701a1a25dfa049e394fe5b3de/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0e5163960eceab701a1a25dfa049e394fe5b3de/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=b0e5163960eceab701a1a25dfa049e394fe5b3de", "patch": "@@ -1165,6 +1165,31 @@ vect_verify_loop_lens (loop_vec_info loop_vinfo)\n   if (LOOP_VINFO_LENS (loop_vinfo).is_empty ())\n     return false;\n \n+  machine_mode len_load_mode = get_len_load_store_mode\n+    (loop_vinfo->vector_mode, true).require ();\n+  machine_mode len_store_mode = get_len_load_store_mode\n+    (loop_vinfo->vector_mode, false).require ();\n+\n+  signed char partial_load_bias = internal_len_load_store_bias\n+    (IFN_LEN_LOAD, len_load_mode);\n+\n+  signed char partial_store_bias = internal_len_load_store_bias\n+    (IFN_LEN_STORE, len_store_mode);\n+\n+  gcc_assert (partial_load_bias == partial_store_bias);\n+\n+  if (partial_load_bias == VECT_PARTIAL_BIAS_UNSUPPORTED)\n+    return false;\n+\n+  /* If the backend requires a bias of -1 for LEN_LOAD, we must not emit\n+     len_loads with a length of zero.  In order to avoid that we prohibit\n+     more than one loop length here.  */\n+  if (partial_load_bias == -1\n+      && LOOP_VINFO_LENS (loop_vinfo).length () > 1)\n+    return false;\n+\n+  LOOP_VINFO_PARTIAL_LOAD_STORE_BIAS (loop_vinfo) = partial_load_bias;\n+\n   unsigned int max_nitems_per_iter = 1;\n   unsigned int i;\n   rgroup_controls *rgl;\n@@ -4076,6 +4101,8 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n \t here.  */\n \n       bool niters_known_p = LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo);\n+      signed char partial_load_store_bias\n+\t= LOOP_VINFO_PARTIAL_LOAD_STORE_BIAS (loop_vinfo);\n       bool need_iterate_p\n \t= (!LOOP_VINFO_EPILOGUE_P (loop_vinfo)\n \t   && !vect_known_niters_smaller_than_vf (loop_vinfo));\n@@ -4108,6 +4135,11 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n \t       for each since start index is zero.  */\n \t    prologue_stmts += num_vectors;\n \n+\t    /* If we have a non-zero partial load bias, we need one PLUS\n+\t       to adjust the load length.  */\n+\t    if (partial_load_store_bias != 0)\n+\t      body_stmts += 1;\n+\n \t    /* Each may need two MINs and one MINUS to update lengths in body\n \t       for next iteration.  */\n \t    if (need_iterate_p)\n@@ -9158,6 +9190,8 @@ vect_get_loop_len (loop_vec_info loop_vinfo, vec_loop_lens *lens,\n \t\t   unsigned int nvectors, unsigned int index)\n {\n   rgroup_controls *rgl = &(*lens)[nvectors - 1];\n+  bool use_bias_adjusted_len =\n+    LOOP_VINFO_PARTIAL_LOAD_STORE_BIAS (loop_vinfo) != 0;\n \n   /* Populate the rgroup's len array, if this is the first time we've\n      used it.  */\n@@ -9168,15 +9202,28 @@ vect_get_loop_len (loop_vec_info loop_vinfo, vec_loop_lens *lens,\n \t{\n \t  tree len_type = LOOP_VINFO_RGROUP_COMPARE_TYPE (loop_vinfo);\n \t  gcc_assert (len_type != NULL_TREE);\n+\n \t  tree len = make_temp_ssa_name (len_type, NULL, \"loop_len\");\n \n \t  /* Provide a dummy definition until the real one is available.  */\n \t  SSA_NAME_DEF_STMT (len) = gimple_build_nop ();\n \t  rgl->controls[i] = len;\n+\n+\t  if (use_bias_adjusted_len)\n+\t    {\n+\t      gcc_assert (i == 0);\n+\t      tree adjusted_len =\n+\t\tmake_temp_ssa_name (len_type, NULL, \"adjusted_loop_len\");\n+\t      SSA_NAME_DEF_STMT (adjusted_len) = gimple_build_nop ();\n+\t      rgl->bias_adjusted_ctrl = adjusted_len;\n+\t    }\n \t}\n     }\n \n-  return rgl->controls[index];\n+  if (use_bias_adjusted_len)\n+    return rgl->bias_adjusted_ctrl;\n+  else\n+    return rgl->controls[index];\n }\n \n /* Scale profiling counters by estimation for LOOP which is vectorized"}, {"sha": "44ef7a6b63630978f318bd6e4667ff24feac9624", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0e5163960eceab701a1a25dfa049e394fe5b3de/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0e5163960eceab701a1a25dfa049e394fe5b3de/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=b0e5163960eceab701a1a25dfa049e394fe5b3de", "patch": "@@ -8416,9 +8416,15 @@ vectorizable_store (vec_info *vinfo,\n \t\t\t\t\t\t   gsi);\n \t\t      vec_oprnd = var;\n \t\t    }\n+\n+\t\t  signed char biasval =\n+\t\t    LOOP_VINFO_PARTIAL_LOAD_STORE_BIAS (loop_vinfo);\n+\n+\t\t  tree bias = build_int_cst (intQI_type_node, biasval);\n \t\t  gcall *call\n-\t\t    = gimple_build_call_internal (IFN_LEN_STORE, 4, dataref_ptr,\n-\t\t\t\t\t\t  ptr, final_len, vec_oprnd);\n+\t\t    = gimple_build_call_internal (IFN_LEN_STORE, 5, dataref_ptr,\n+\t\t\t\t\t\t  ptr, final_len, vec_oprnd,\n+\t\t\t\t\t\t  bias);\n \t\t  gimple_call_set_nothrow (call, true);\n \t\t  vect_finish_stmt_generation (vinfo, stmt_info, call, gsi);\n \t\t  new_stmt = call;\n@@ -9724,22 +9730,29 @@ vectorizable_load (vec_info *vinfo,\n \t\t\t\t\t       vec_num * j + i);\n \t\t\ttree ptr = build_int_cst (ref_type,\n \t\t\t\t\t\t  align * BITS_PER_UNIT);\n+\n+\t\t\tmachine_mode vmode = TYPE_MODE (vectype);\n+\t\t\topt_machine_mode new_ovmode\n+\t\t\t  = get_len_load_store_mode (vmode, true);\n+\t\t\tmachine_mode new_vmode = new_ovmode.require ();\n+\t\t\ttree qi_type = unsigned_intQI_type_node;\n+\n+\t\t\tsigned char biasval =\n+\t\t\t  LOOP_VINFO_PARTIAL_LOAD_STORE_BIAS (loop_vinfo);\n+\n+\t\t\ttree bias = build_int_cst (intQI_type_node, biasval);\n+\n \t\t\tgcall *call\n-\t\t\t  = gimple_build_call_internal (IFN_LEN_LOAD, 3,\n+\t\t\t  = gimple_build_call_internal (IFN_LEN_LOAD, 4,\n \t\t\t\t\t\t\tdataref_ptr, ptr,\n-\t\t\t\t\t\t\tfinal_len);\n+\t\t\t\t\t\t\tfinal_len, bias);\n \t\t\tgimple_call_set_nothrow (call, true);\n \t\t\tnew_stmt = call;\n \t\t\tdata_ref = NULL_TREE;\n \n \t\t\t/* Need conversion if it's wrapped with VnQI.  */\n-\t\t\tmachine_mode vmode = TYPE_MODE (vectype);\n-\t\t\topt_machine_mode new_ovmode\n-\t\t\t  = get_len_load_store_mode (vmode, true);\n-\t\t\tmachine_mode new_vmode = new_ovmode.require ();\n \t\t\tif (vmode != new_vmode)\n \t\t\t  {\n-\t\t\t    tree qi_type = unsigned_intQI_type_node;\n \t\t\t    tree new_vtype\n \t\t\t      = build_vector_type_for_mode (qi_type, new_vmode);\n \t\t\t    tree var = vect_get_new_ssa_name (new_vtype,"}, {"sha": "7e077f63f66b6375a3fd831609d0b5220d85ff27", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0e5163960eceab701a1a25dfa049e394fe5b3de/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0e5163960eceab701a1a25dfa049e394fe5b3de/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=b0e5163960eceab701a1a25dfa049e394fe5b3de", "patch": "@@ -555,6 +555,10 @@ struct rgroup_controls {\n \n   /* A vector of nV controls, in iteration order.  */\n   vec<tree> controls;\n+\n+  /* In case of len_load and len_store with a bias there is only one\n+     rgroup.  This holds the adjusted loop length for the this rgroup.  */\n+  tree bias_adjusted_ctrl;\n };\n \n typedef auto_vec<rgroup_controls> vec_loop_masks;\n@@ -759,6 +763,11 @@ typedef class _loop_vec_info : public vec_info {\n      epilogue of loop.  */\n   bool epil_using_partial_vectors_p;\n \n+  /* The bias for len_load and len_store.  For now, only 0 and -1 are\n+     supported.  -1 must be used when a backend does not support\n+     len_load/len_store with a length of zero.  */\n+  signed char partial_load_store_bias;\n+\n   /* When we have grouped data accesses with gaps, we may introduce invalid\n      memory accesses.  We peel the last iteration of the loop to prevent\n      this.  */\n@@ -824,6 +833,7 @@ typedef class _loop_vec_info : public vec_info {\n #define LOOP_VINFO_USING_PARTIAL_VECTORS_P(L) (L)->using_partial_vectors_p\n #define LOOP_VINFO_EPIL_USING_PARTIAL_VECTORS_P(L)                             \\\n   (L)->epil_using_partial_vectors_p\n+#define LOOP_VINFO_PARTIAL_LOAD_STORE_BIAS(L) (L)->partial_load_store_bias\n #define LOOP_VINFO_VECT_FACTOR(L)          (L)->vectorization_factor\n #define LOOP_VINFO_MAX_VECT_FACTOR(L)      (L)->max_vectorization_factor\n #define LOOP_VINFO_MASKS(L)                (L)->masks"}]}