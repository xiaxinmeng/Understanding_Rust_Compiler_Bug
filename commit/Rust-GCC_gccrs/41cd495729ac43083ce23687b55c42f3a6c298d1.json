{"sha": "41cd495729ac43083ce23687b55c42f3a6c298d1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDFjZDQ5NTcyOWFjNDMwODNjZTIzNjg3YjU1YzQyZjNhNmMyOThkMQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2011-06-22T10:44:56Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2011-06-22T10:44:56Z"}, "message": "dwarf2out.c (size_of_loc_descr, [...]): Allow DW_OP_GNU_convert and DW_OP_GNU_reinterpret to use constant instead of...\n\n\t* dwarf2out.c (size_of_loc_descr, output_loc_operands,\n\tmark_base_types, hash_loc_operands, compare_loc_operands): Allow\n\tDW_OP_GNU_convert and DW_OP_GNU_reinterpret to use constant instead\n\tof base type reference as argument.\n\t(resolve_addr_in_expr): Likewise.  Fix keep computation.\n\t(convert_descriptor_to_signed): Renamed to...\n\t(convert_descriptor_to_mode): ... this.  For wider types convert\n\tto unsigned instead of signed, for <= DWARF2_ADDR_SIZE convert to\n\tuntyped.\n\t(typed_binop): New function.\n\t(scompare_loc_descriptor, ucompare_loc_descriptor,\n\tminmax_loc_descriptor, mem_loc_descriptor): For wider integer modes\n\tdefault to unsigned type instead of signed.\n\nFrom-SVN: r175289", "tree": {"sha": "4615dceb2e238574c59d3ebbc75f981cadfe849d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4615dceb2e238574c59d3ebbc75f981cadfe849d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/41cd495729ac43083ce23687b55c42f3a6c298d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41cd495729ac43083ce23687b55c42f3a6c298d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41cd495729ac43083ce23687b55c42f3a6c298d1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41cd495729ac43083ce23687b55c42f3a6c298d1/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ddb555ed5129279c1bbe74574507ad67fff22e5e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddb555ed5129279c1bbe74574507ad67fff22e5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ddb555ed5129279c1bbe74574507ad67fff22e5e"}], "stats": {"total": 281, "additions": 173, "deletions": 108}, "files": [{"sha": "d5cd5ce0d1c9b17fff08258aa686bac850e089d2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41cd495729ac43083ce23687b55c42f3a6c298d1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41cd495729ac43083ce23687b55c42f3a6c298d1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=41cd495729ac43083ce23687b55c42f3a6c298d1", "patch": "@@ -1,5 +1,19 @@\n 2011-06-22  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* dwarf2out.c (size_of_loc_descr, output_loc_operands,\n+\tmark_base_types, hash_loc_operands, compare_loc_operands): Allow\n+\tDW_OP_GNU_convert and DW_OP_GNU_reinterpret to use constant instead\n+\tof base type reference as argument.\n+\t(resolve_addr_in_expr): Likewise.  Fix keep computation.\n+\t(convert_descriptor_to_signed): Renamed to...\n+\t(convert_descriptor_to_mode): ... this.  For wider types convert\n+\tto unsigned instead of signed, for <= DWARF2_ADDR_SIZE convert to\n+\tuntyped.\n+\t(typed_binop): New function.\n+\t(scompare_loc_descriptor, ucompare_loc_descriptor,\n+\tminmax_loc_descriptor, mem_loc_descriptor): For wider integer modes\n+\tdefault to unsigned type instead of signed.\n+\n \tPR debug/47858\n \t* gimple.h (enum gimple_debug_subcode): Add GIMPLE_DEBUG_SOURCE_BIND.\n \t(gimple_build_debug_source_bind_stat): New prototype."}, {"sha": "492de62b58418b686e2ca9119f226eabd0a68b98", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 159, "deletions": 108, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41cd495729ac43083ce23687b55c42f3a6c298d1/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41cd495729ac43083ce23687b55c42f3a6c298d1/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=41cd495729ac43083ce23687b55c42f3a6c298d1", "patch": "@@ -5082,11 +5082,14 @@ size_of_loc_descr (dw_loc_descr_ref loc)\n       break;\n     case DW_OP_GNU_convert:\n     case DW_OP_GNU_reinterpret:\n-      {\n-\tunsigned long o\n-\t  = get_base_type_offset (loc->dw_loc_oprnd1.v.val_die_ref.die);\n-\tsize += size_of_uleb128 (o);\n-      }\n+      if (loc->dw_loc_oprnd1.val_class == dw_val_class_unsigned_const)\n+\tsize += size_of_uleb128 (loc->dw_loc_oprnd1.v.val_unsigned);\n+      else\n+\t{\n+\t  unsigned long o\n+\t    = get_base_type_offset (loc->dw_loc_oprnd1.v.val_die_ref.die);\n+\t  size += size_of_uleb128 (o);\n+\t}\n       break;\n     case DW_OP_GNU_parameter_ref:\n       size += 4;\n@@ -5467,11 +5470,14 @@ output_loc_operands (dw_loc_descr_ref loc, int for_eh_or_skip)\n       break;\n     case DW_OP_GNU_convert:\n     case DW_OP_GNU_reinterpret:\n-      {\n-\tunsigned long o = get_base_type_offset (val1->v.val_die_ref.die);\n-\tgcc_assert (o);\n-\tdw2_asm_output_data_uleb128 (o, NULL);\n-      }\n+      if (loc->dw_loc_oprnd1.val_class == dw_val_class_unsigned_const)\n+\tdw2_asm_output_data_uleb128 (val1->v.val_unsigned, NULL);\n+      else\n+\t{\n+\t  unsigned long o = get_base_type_offset (val1->v.val_die_ref.die);\n+\t  gcc_assert (o);\n+\t  dw2_asm_output_data_uleb128 (o, NULL);\n+\t}\n       break;\n \n     case DW_OP_GNU_parameter_ref:\n@@ -13881,27 +13887,24 @@ base_type_for_mode (enum machine_mode mode, bool unsignedp)\n   return type_die;\n }\n \n-/* For OP descriptor assumed to be in unsigned MODE, convert it to a signed\n-   type matching MODE, or, if MODE is narrower than DWARF2_ADDR_SIZE, signed\n-   type matching DWARF2_ADDR_SIZE.  Return NULL if the conversion is not\n+/* For OP descriptor assumed to be in unsigned MODE, convert it to a unsigned\n+   type matching MODE, or, if MODE is narrower than or as wide as\n+   DWARF2_ADDR_SIZE, untyped.  Return NULL if the conversion is not\n    possible.  */\n \n static dw_loc_descr_ref\n-convert_descriptor_to_signed (enum machine_mode mode, dw_loc_descr_ref op)\n+convert_descriptor_to_mode (enum machine_mode mode, dw_loc_descr_ref op)\n {\n   enum machine_mode outer_mode = mode;\n   dw_die_ref type_die;\n   dw_loc_descr_ref cvt;\n \n-  if (GET_MODE_SIZE (mode) < DWARF2_ADDR_SIZE)\n+  if (GET_MODE_SIZE (mode) <= DWARF2_ADDR_SIZE)\n     {\n-      outer_mode = mode_for_size (DWARF2_ADDR_SIZE * BITS_PER_UNIT,\n-\t\t\t\t  MODE_INT, 0);\n-      if (outer_mode == BLKmode\n-\t  || GET_MODE_SIZE (outer_mode) != DWARF2_ADDR_SIZE)\n-\treturn NULL;\n+      add_loc_descr (&op, new_loc_descr (DW_OP_GNU_convert, 0, 0));\n+      return op;\n     }\n-  type_die = base_type_for_mode (outer_mode, 0);\n+  type_die = base_type_for_mode (outer_mode, 1);\n   if (type_die == NULL)\n     return NULL;\n   cvt = new_loc_descr (DW_OP_GNU_convert, 0, 0);\n@@ -13958,9 +13961,29 @@ scompare_loc_descriptor (enum dwarf_location_atom op, rtx rtl,\n     return NULL;\n \n   if (GET_MODE_CLASS (op_mode) != MODE_INT\n-      || GET_MODE_SIZE (op_mode) >= DWARF2_ADDR_SIZE)\n+      || GET_MODE_SIZE (op_mode) == DWARF2_ADDR_SIZE)\n     return compare_loc_descriptor (op, op0, op1);\n \n+  if (GET_MODE_SIZE (op_mode) > DWARF2_ADDR_SIZE)\n+    {\n+      dw_die_ref type_die = base_type_for_mode (op_mode, 0);\n+      dw_loc_descr_ref cvt;\n+\n+      if (type_die == NULL)\n+\treturn NULL;\n+      cvt = new_loc_descr (DW_OP_GNU_convert, 0, 0);\n+      cvt->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n+      cvt->dw_loc_oprnd1.v.val_die_ref.die = type_die;\n+      cvt->dw_loc_oprnd1.v.val_die_ref.external = 0;\n+      add_loc_descr (&op0, cvt);\n+      cvt = new_loc_descr (DW_OP_GNU_convert, 0, 0);\n+      cvt->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n+      cvt->dw_loc_oprnd1.v.val_die_ref.die = type_die;\n+      cvt->dw_loc_oprnd1.v.val_die_ref.external = 0;\n+      add_loc_descr (&op1, cvt);\n+      return compare_loc_descriptor (op, op0, op1);\n+    }\n+\n   shift = (DWARF2_ADDR_SIZE - GET_MODE_SIZE (op_mode)) * BITS_PER_UNIT;\n   /* For eq/ne, if the operands are known to be zero-extended,\n      there is no need to do the fancy shifting up.  */\n@@ -14016,9 +14039,6 @@ ucompare_loc_descriptor (enum dwarf_location_atom op, rtx rtl,\n   if (dwarf_strict && GET_MODE_SIZE (op_mode) > DWARF2_ADDR_SIZE)\n     return NULL;\n \n-  if (op_mode != VOIDmode && GET_MODE_CLASS (op_mode) != MODE_INT)\n-    return NULL;\n-\n   op0 = mem_loc_descriptor (XEXP (rtl, 0), op_mode, mem_mode,\n \t\t\t    VAR_INIT_STATUS_INITIALIZED);\n   op1 = mem_loc_descriptor (XEXP (rtl, 1), op_mode, mem_mode,\n@@ -14066,24 +14086,6 @@ ucompare_loc_descriptor (enum dwarf_location_atom op, rtx rtl,\n \tadd_loc_descr (&op1, new_loc_descr (DW_OP_plus_uconst,\n \t\t\t\t\t    bias, 0));\n     }\n-  else\n-    {\n-      dw_die_ref type_die = base_type_for_mode (op_mode, 1);\n-      dw_loc_descr_ref cvt;\n-\n-      if (type_die == NULL)\n-\treturn NULL;\n-      cvt = new_loc_descr (DW_OP_GNU_convert, 0, 0);\n-      cvt->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n-      cvt->dw_loc_oprnd1.v.val_die_ref.die = type_die;\n-      cvt->dw_loc_oprnd1.v.val_die_ref.external = 0;\n-      add_loc_descr (&op0, cvt);\n-      cvt = new_loc_descr (DW_OP_GNU_convert, 0, 0);\n-      cvt->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n-      cvt->dw_loc_oprnd1.v.val_die_ref.die = type_die;\n-      cvt->dw_loc_oprnd1.v.val_die_ref.external = 0;\n-      add_loc_descr (&op1, cvt);\n-    }\n   return compare_loc_descriptor (op, op0, op1);\n }\n \n@@ -14130,23 +14132,6 @@ minmax_loc_descriptor (rtx rtl, enum machine_mode mode,\n \t  add_loc_descr (&op0, new_loc_descr (DW_OP_plus_uconst, bias, 0));\n \t  add_loc_descr (&op1, new_loc_descr (DW_OP_plus_uconst, bias, 0));\n \t}\n-      else\n-\t{\n-\t  dw_die_ref type_die = base_type_for_mode (mode, 1);\n-\t  dw_loc_descr_ref cvt;\n-\t  if (type_die == NULL)\n-\t    return NULL;\n-\t  cvt = new_loc_descr (DW_OP_GNU_convert, 0, 0);\n-\t  cvt->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n-\t  cvt->dw_loc_oprnd1.v.val_die_ref.die = type_die;\n-\t  cvt->dw_loc_oprnd1.v.val_die_ref.external = 0;\n-\t  add_loc_descr (&op0, cvt);\n-\t  cvt = new_loc_descr (DW_OP_GNU_convert, 0, 0);\n-\t  cvt->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n-\t  cvt->dw_loc_oprnd1.v.val_die_ref.die = type_die;\n-\t  cvt->dw_loc_oprnd1.v.val_die_ref.external = 0;\n-\t  add_loc_descr (&op1, cvt);\n-\t}\n     }\n   else if (GET_MODE_CLASS (mode) == MODE_INT\n \t   && GET_MODE_SIZE (mode) < DWARF2_ADDR_SIZE)\n@@ -14157,6 +14142,24 @@ minmax_loc_descriptor (rtx rtl, enum machine_mode mode,\n       add_loc_descr (&op1, int_loc_descriptor (shift));\n       add_loc_descr (&op1, new_loc_descr (DW_OP_shl, 0, 0));\n     }\n+  else if (GET_MODE_CLASS (mode) == MODE_INT\n+\t   && GET_MODE_SIZE (mode) > DWARF2_ADDR_SIZE)\n+    {\n+      dw_die_ref type_die = base_type_for_mode (mode, 0);\n+      dw_loc_descr_ref cvt;\n+      if (type_die == NULL)\n+\treturn NULL;\n+      cvt = new_loc_descr (DW_OP_GNU_convert, 0, 0);\n+      cvt->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n+      cvt->dw_loc_oprnd1.v.val_die_ref.die = type_die;\n+      cvt->dw_loc_oprnd1.v.val_die_ref.external = 0;\n+      add_loc_descr (&op0, cvt);\n+      cvt = new_loc_descr (DW_OP_GNU_convert, 0, 0);\n+      cvt->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n+      cvt->dw_loc_oprnd1.v.val_die_ref.die = type_die;\n+      cvt->dw_loc_oprnd1.v.val_die_ref.external = 0;\n+      add_loc_descr (&op1, cvt);\n+    }\n \n   if (GET_CODE (rtl) == SMIN || GET_CODE (rtl) == UMIN)\n     op = DW_OP_lt;\n@@ -14172,9 +14175,46 @@ minmax_loc_descriptor (rtx rtl, enum machine_mode mode,\n   add_loc_descr (&ret, drop_node);\n   bra_node->dw_loc_oprnd1.val_class = dw_val_class_loc;\n   bra_node->dw_loc_oprnd1.v.val_loc = drop_node;\n+  if ((GET_CODE (rtl) == SMIN || GET_CODE (rtl) == SMAX)\n+      && GET_MODE_CLASS (mode) == MODE_INT\n+      && GET_MODE_SIZE (mode) > DWARF2_ADDR_SIZE)\n+    ret = convert_descriptor_to_mode (mode, ret);\n   return ret;\n }\n \n+/* Helper function for mem_loc_descriptor.  Perform OP binary op,\n+   but after converting arguments to type_die, afterwards\n+   convert back to unsigned.  */\n+\n+static dw_loc_descr_ref\n+typed_binop (enum dwarf_location_atom op, rtx rtl, dw_die_ref type_die,\n+\t     enum machine_mode mode, enum machine_mode mem_mode)\n+{\n+  dw_loc_descr_ref cvt, op0, op1;\n+\n+  if (type_die == NULL)\n+    return NULL;\n+  op0 = mem_loc_descriptor (XEXP (rtl, 0), mode, mem_mode,\n+\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n+  op1 = mem_loc_descriptor (XEXP (rtl, 1), mode, mem_mode,\n+\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n+  if (op0 == NULL || op1 == NULL)\n+    return NULL;\n+  cvt = new_loc_descr (DW_OP_GNU_convert, 0, 0);\n+  cvt->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n+  cvt->dw_loc_oprnd1.v.val_die_ref.die = type_die;\n+  cvt->dw_loc_oprnd1.v.val_die_ref.external = 0;\n+  add_loc_descr (&op0, cvt);\n+  cvt = new_loc_descr (DW_OP_GNU_convert, 0, 0);\n+  cvt->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n+  cvt->dw_loc_oprnd1.v.val_die_ref.die = type_die;\n+  cvt->dw_loc_oprnd1.v.val_die_ref.external = 0;\n+  add_loc_descr (&op1, cvt);\n+  add_loc_descr (&op0, op1);\n+  add_loc_descr (&op0, new_loc_descr (op, 0, 0));\n+  return convert_descriptor_to_mode (mode, op0);\n+}\n+\n /* CLZ (where constV is CLZ_DEFINED_VALUE_AT_ZERO computed value,\n    const0 is DW_OP_lit0 or corresponding typed constant,\n    const1 is DW_OP_lit1 or corresponding typed constant\n@@ -14647,7 +14687,8 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n \t\t\t\t\t       mem_mode, initialized);\n \t  if (mem_loc_result == NULL)\n \t    break;\n-\t  type_die = base_type_for_mode (mode, 0);\n+\t  type_die = base_type_for_mode (mode,\n+\t\t\t\t\t GET_MODE_CLASS (mode) == MODE_INT);\n \t  if (type_die == NULL)\n \t    {\n \t      mem_loc_result = NULL;\n@@ -14679,7 +14720,8 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n \t    break;\n \t  if (REGNO (rtl) > FIRST_PSEUDO_REGISTER)\n \t    break;\n-\t  type_die = base_type_for_mode (mode, 0);\n+\t  type_die = base_type_for_mode (mode,\n+\t\t\t\t\t GET_MODE_CLASS (mode) == MODE_INT);\n \t  if (type_die == NULL)\n \t    break;\n \t  mem_loc_result = new_loc_descr (DW_OP_GNU_regval_type,\n@@ -14762,7 +14804,7 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n \t\t\t\t\t  GET_CODE (rtl) == ZERO_EXTEND);\n \t  if (type_die1 == NULL)\n \t    break;\n-\t  type_die2 = base_type_for_mode (mode, 0);\n+\t  type_die2 = base_type_for_mode (mode, 1);\n \t  if (type_die2 == NULL)\n \t    break;\n \t  mem_loc_result = op0;\n@@ -14795,7 +14837,8 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n \n \t      if (dwarf_strict)\n \t\treturn NULL;\n-\t      type_die = base_type_for_mode (mode, 0);\n+\t      type_die\n+\t\t= base_type_for_mode (mode, GET_MODE_CLASS (mode) == MODE_INT);\n \t      if (type_die == NULL)\n \t\treturn NULL;\n \t      deref = new_loc_descr (DW_OP_GNU_deref_type,\n@@ -14950,12 +14993,11 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n \t    loc_descr_plus_const (&mem_loc_result, INTVAL (XEXP (rtl, 1)));\n \t  else\n \t    {\n-\t      dw_loc_descr_ref mem_loc_result2\n-\t\t= mem_loc_descriptor (XEXP (rtl, 1), mode, mem_mode,\n-\t\t\t\t      VAR_INIT_STATUS_INITIALIZED);\n-\t      if (mem_loc_result2 == 0)\n+\t      op1 = mem_loc_descriptor (XEXP (rtl, 1), mode, mem_mode,\n+\t\t\t\t\tVAR_INIT_STATUS_INITIALIZED);\n+\t      if (op1 == 0)\n \t\tbreak;\n-\t      add_loc_descr (&mem_loc_result, mem_loc_result2);\n+\t      add_loc_descr (&mem_loc_result, op1);\n \t      add_loc_descr (&mem_loc_result,\n \t\t\t     new_loc_descr (DW_OP_plus, 0, 0));\n \t    }\n@@ -14973,6 +15015,15 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n       goto do_binop;\n \n     case DIV:\n+      if (!dwarf_strict\n+\t  && GET_MODE_CLASS (mode) == MODE_INT\n+\t  && GET_MODE_SIZE (mode) > DWARF2_ADDR_SIZE)\n+\t{\n+\t  mem_loc_result = typed_binop (DW_OP_div, rtl,\n+\t\t\t\t\tbase_type_for_mode (mode, 0),\n+\t\t\t\t\tmode, mem_mode);\n+\t  break;\n+\t}\n       op = DW_OP_div;\n       goto do_binop;\n \n@@ -15044,12 +15095,10 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n     case MOD:\n       if (GET_MODE_SIZE (mode) > DWARF2_ADDR_SIZE && !dwarf_strict)\n \t{\n-\t  /* If MODE is wider than DWARF2_ADDR_SIZE, mem_loc_descriptor\n-\t     should return signed typed values and therefore DW_OP_mod\n-\t     won't be unsigned as it defaults for untyped stack values,\n-\t     but signed.  */\n-\t  op = DW_OP_mod;\n-\t  goto do_binop;\n+\t  mem_loc_result = typed_binop (DW_OP_mod, rtl,\n+\t\t\t\t\tbase_type_for_mode (mode, 0),\n+\t\t\t\t\tmode, mem_mode);\n+\t  break;\n \t}\n \n       op0 = mem_loc_descriptor (XEXP (rtl, 0), mode, mem_mode,\n@@ -15072,32 +15121,14 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n     case UDIV:\n       if (!dwarf_strict && GET_MODE_CLASS (mode) == MODE_INT)\n \t{\n-\t  dw_die_ref type_die;\n-\t  dw_loc_descr_ref cvt;\n-\n-\t  type_die = base_type_for_mode (mode, 1);\n-\t  if (type_die == NULL)\n-\t    break;\n-\t  op0 = mem_loc_descriptor (XEXP (rtl, 0), mode, mem_mode,\n-\t\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n-\t  op1 = mem_loc_descriptor (XEXP (rtl, 1), mode, mem_mode,\n-\t\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n-\t  if (op0 == 0 || op1 == 0)\n-\t    break;\n-\t  cvt = new_loc_descr (DW_OP_GNU_convert, 0, 0);\n-\t  cvt->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n-\t  cvt->dw_loc_oprnd1.v.val_die_ref.die = type_die;\n-\t  cvt->dw_loc_oprnd1.v.val_die_ref.external = 0;\n-\t  add_loc_descr (&op0, cvt);\n-\t  cvt = new_loc_descr (DW_OP_GNU_convert, 0, 0);\n-\t  cvt->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n-\t  cvt->dw_loc_oprnd1.v.val_die_ref.die = type_die;\n-\t  cvt->dw_loc_oprnd1.v.val_die_ref.external = 0;\n-\t  add_loc_descr (&op1, cvt);\n-\t  mem_loc_result = op0;\n-\t  add_loc_descr (&mem_loc_result, op1);\n-\t  add_loc_descr (&mem_loc_result, new_loc_descr (DW_OP_div, 0, 0));\n-\t  mem_loc_result = convert_descriptor_to_signed (mode, mem_loc_result);\n+\t  if (GET_MODE_CLASS (mode) > DWARF2_ADDR_SIZE)\n+\t    {\n+\t      op = DW_OP_div;\n+\t      goto do_binop;\n+\t    }\n+\t  mem_loc_result = typed_binop (DW_OP_div, rtl,\n+\t\t\t\t\tbase_type_for_mode (mode, 1),\n+\t\t\t\t\tmode, mem_mode);\n \t}\n       break;\n \n@@ -15140,7 +15171,7 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n \t  && (GET_MODE_BITSIZE (mode) == HOST_BITS_PER_WIDE_INT\n \t      || GET_MODE_BITSIZE (mode) == 2 * HOST_BITS_PER_WIDE_INT))\n \t{\n-\t  dw_die_ref type_die = base_type_for_mode (mode, 0);\n+\t  dw_die_ref type_die = base_type_for_mode (mode, 1);\n \t  if (type_die == NULL)\n \t    return NULL;\n \t  mem_loc_result = new_loc_descr (DW_OP_GNU_const_type, 0,\n@@ -15173,7 +15204,8 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n \t      || (GET_MODE (rtl) == VOIDmode\n \t\t  && GET_MODE_BITSIZE (mode) != 2 * HOST_BITS_PER_WIDE_INT))\n \t    break;\n-\t  type_die = base_type_for_mode (mode, 0);\n+\t  type_die = base_type_for_mode (mode,\n+\t\t\t\t\t GET_MODE_CLASS (mode) == MODE_INT);\n \t  if (type_die == NULL)\n \t    return NULL;\n \t  mem_loc_result = new_loc_descr (DW_OP_GNU_const_type, 0, 0);\n@@ -15337,7 +15369,7 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n \t  if (op0 == NULL)\n \t    break;\n \t  if (GET_MODE_CLASS (GET_MODE (XEXP (rtl, 0))) == MODE_INT\n-\t      && (GET_CODE (rtl) == UNSIGNED_FLOAT\n+\t      && (GET_CODE (rtl) == FLOAT\n \t\t  || GET_MODE_SIZE (GET_MODE (XEXP (rtl, 0)))\n \t\t     <= DWARF2_ADDR_SIZE))\n \t    {\n@@ -15360,10 +15392,10 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n \t  cvt->dw_loc_oprnd1.v.val_die_ref.external = 0;\n \t  add_loc_descr (&op0, cvt);\n \t  if (GET_MODE_CLASS (mode) == MODE_INT\n-\t      && (GET_CODE (rtl) == UNSIGNED_FIX\n+\t      && (GET_CODE (rtl) == FIX\n \t\t  || GET_MODE_SIZE (mode) < DWARF2_ADDR_SIZE))\n \t    {\n-\t      op0 = convert_descriptor_to_signed (mode, op0);\n+\t      op0 = convert_descriptor_to_mode (mode, op0);\n \t      if (op0 == NULL)\n \t\tbreak;\n \t    }\n@@ -24115,9 +24147,12 @@ mark_base_types (dw_loc_descr_ref loc)\n \tcase DW_OP_GNU_deref_type:\n \t  base_type = loc->dw_loc_oprnd2.v.val_die_ref.die;\n \t  break;\n-\tcase DW_OP_GNU_const_type:\n \tcase DW_OP_GNU_convert:\n \tcase DW_OP_GNU_reinterpret:\n+\t  if (loc->dw_loc_oprnd1.val_class == dw_val_class_unsigned_const)\n+\t    continue;\n+\t  /* FALLTHRU */\n+\tcase DW_OP_GNU_const_type:\n \t  base_type = loc->dw_loc_oprnd1.v.val_die_ref.die;\n \t  break;\n \tcase DW_OP_GNU_entry_value:\n@@ -24306,8 +24341,14 @@ resolve_addr_in_expr (dw_loc_descr_ref loc)\n \t    if (loc->dw_loc_opc == DW_OP_GNU_regval_type\n \t\t|| loc->dw_loc_opc == DW_OP_GNU_deref_type)\n \t      base1 = loc->dw_loc_oprnd2.v.val_die_ref.die;\n+\t    else if (loc->dw_loc_oprnd1.val_class\n+\t\t     == dw_val_class_unsigned_const)\n+\t      break;\n \t    else\n \t      base1 = loc->dw_loc_oprnd1.v.val_die_ref.die;\n+\t    if (loc->dw_loc_next->dw_loc_oprnd1.val_class\n+\t\t== dw_val_class_unsigned_const)\n+\t      break;\n \t    base2 = loc->dw_loc_next->dw_loc_oprnd1.v.val_die_ref.die;\n \t    gcc_assert (base1->die_tag == DW_TAG_base_type\n \t\t\t&& base2->die_tag == DW_TAG_base_type);\n@@ -24334,7 +24375,7 @@ resolve_addr_in_expr (dw_loc_descr_ref loc)\n \t    /* Don't change integer DW_OP_GNU_convert after e.g. floating\n \t       point typed stack entry.  */\n \t    else if (enc1 != DW_ATE_unsigned && enc1 != DW_ATE_signed)\n-\t      keep = loc;\n+\t      keep = loc->dw_loc_next;\n \t    break;\n \t  }\n \tbreak;\n@@ -24600,6 +24641,12 @@ hash_loc_operands (dw_loc_descr_ref loc, hashval_t hash)\n       break;\n     case DW_OP_GNU_convert:\n     case DW_OP_GNU_reinterpret:\n+      if (val1->val_class == dw_val_class_unsigned_const)\n+\t{\n+\t  hash = iterative_hash_object (val1->v.val_unsigned, hash);\n+\t  break;\n+\t}\n+      /* FALLTHRU */\n     case DW_OP_GNU_const_type:\n       {\n \tunsigned int byte_size\n@@ -24821,6 +24868,10 @@ compare_loc_operands (dw_loc_descr_ref x, dw_loc_descr_ref y)\n \t     && valx2->v.val_die_ref.die == valy2->v.val_die_ref.die;\n     case DW_OP_GNU_convert:\n     case DW_OP_GNU_reinterpret:\n+      if (valx1->val_class != valy1->val_class)\n+\treturn false;\n+      if (valx1->val_class == dw_val_class_unsigned_const)\n+\treturn valx1->v.val_unsigned == valy1->v.val_unsigned;\n       return valx1->v.val_die_ref.die == valy1->v.val_die_ref.die;\n     case DW_OP_GNU_parameter_ref:\n       return valx1->val_class == dw_val_class_die_ref"}]}