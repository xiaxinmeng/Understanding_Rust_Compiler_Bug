{"sha": "2ca202e792186e9641f933ad0830266dbace0eeb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmNhMjAyZTc5MjE4NmU5NjQxZjkzM2FkMDgzMDI2NmRiYWNlMGVlYg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-04-28T05:03:09Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-04-28T05:03:09Z"}, "message": "bt-load.c, [...]: Use JUMP_P, LABEL_P, REG_P, MEM_P, NONJUMP_INSN_P, and INSN_P where appropriate.\n\n\t* bt-load.c, cfgexpand.c, dwarf2out.c, emit-rtl.c, expr.c,\n\tfunction.c, global.c, lcm.c, loop-invariant.c, optabs.c,\n\treorg.c, resource.c, tree-ssa-loop-ivopts.c, value-prof.c: Use\n\tJUMP_P, LABEL_P, REG_P, MEM_P, NONJUMP_INSN_P, and INSN_P\n\twhere appropriate.\n\nFrom-SVN: r98913", "tree": {"sha": "fe6f1039398672aa41a8e7ee84c0d75a91f4b324", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fe6f1039398672aa41a8e7ee84c0d75a91f4b324"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ca202e792186e9641f933ad0830266dbace0eeb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ca202e792186e9641f933ad0830266dbace0eeb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ca202e792186e9641f933ad0830266dbace0eeb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ca202e792186e9641f933ad0830266dbace0eeb/comments", "author": null, "committer": null, "parents": [{"sha": "b6f9abcfe37f1b295c17b97f351465467e47921d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6f9abcfe37f1b295c17b97f351465467e47921d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6f9abcfe37f1b295c17b97f351465467e47921d"}], "stats": {"total": 57, "additions": 31, "deletions": 26}, "files": [{"sha": "3fb68d3bf370d99258130a79cb644144a09cf103", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ca202e792186e9641f933ad0830266dbace0eeb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ca202e792186e9641f933ad0830266dbace0eeb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2ca202e792186e9641f933ad0830266dbace0eeb", "patch": "@@ -7,6 +7,12 @@\n \n \t* tree.h (edge_def): Remove.\n \n+\t* bt-load.c, cfgexpand.c, dwarf2out.c, emit-rtl.c, expr.c,\n+\tfunction.c, global.c, lcm.c, loop-invariant.c, optabs.c,\n+\treorg.c, resource.c, tree-ssa-loop-ivopts.c, value-prof.c: Use\n+\tJUMP_P, LABEL_P, REG_P, MEM_P, NONJUMP_INSN_P, and INSN_P\n+\twhere appropriate.\n+\n 2005-04-28  Joseph S. Myers  <joseph@codesourcery.com>\n \n \t* c-typeck.c (build_compound_expr): Correct logic in last change."}, {"sha": "c8c94127c6609cb9b4e16765caf81323d8b98dbf", "filename": "gcc/bt-load.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ca202e792186e9641f933ad0830266dbace0eeb/gcc%2Fbt-load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ca202e792186e9641f933ad0830266dbace0eeb/gcc%2Fbt-load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbt-load.c?ref=2ca202e792186e9641f933ad0830266dbace0eeb", "patch": "@@ -1008,7 +1008,7 @@ btr_def_live_range (btr_def def, HARD_REG_SET *btrs_live_in_range)\n \t\t\t    def->bb, user->bb,\n \t\t\t    (flag_btr_bb_exclusive\n \t\t\t     || user->insn != BB_END (def->bb)\n-\t\t\t     || GET_CODE (user->insn) != JUMP_INSN));\n+\t\t\t     || !JUMP_P (user->insn)));\n     }\n   else\n     {\n@@ -1072,7 +1072,7 @@ combine_btr_defs (btr_def def, HARD_REG_SET *btrs_live_in_range)\n \t\t\t\tdef->bb, user->bb,\n \t\t\t\t(flag_btr_bb_exclusive\n \t\t\t\t || user->insn != BB_END (def->bb)\n-\t\t\t\t || GET_CODE (user->insn) != JUMP_INSN));\n+\t\t\t\t || !JUMP_P (user->insn)));\n \n \t  btr = choose_btr (combined_btrs_live);\n \t  if (btr != -1)"}, {"sha": "215f6d451c327a2f0e84c52c64a0003099bb828d", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ca202e792186e9641f933ad0830266dbace0eeb/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ca202e792186e9641f933ad0830266dbace0eeb/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=2ca202e792186e9641f933ad0830266dbace0eeb", "patch": "@@ -49,15 +49,15 @@ add_reg_br_prob_note (FILE *dump_file, rtx last, int probability)\n   if (profile_status == PROFILE_ABSENT)\n     return;\n   for (last = NEXT_INSN (last); last && NEXT_INSN (last); last = NEXT_INSN (last))\n-    if (GET_CODE (last) == JUMP_INSN)\n+    if (JUMP_P (last))\n       {\n \t/* It is common to emit condjump-around-jump sequence when we don't know\n \t   how to reverse the conditional.  Special case this.  */\n \tif (!any_condjump_p (last)\n-\t    || GET_CODE (NEXT_INSN (last)) != JUMP_INSN\n+\t    || !JUMP_P (NEXT_INSN (last))\n \t    || !simplejump_p (NEXT_INSN (last))\n-\t    || GET_CODE (NEXT_INSN (NEXT_INSN (last))) != BARRIER\n-\t    || GET_CODE (NEXT_INSN (NEXT_INSN (NEXT_INSN (last)))) != CODE_LABEL\n+\t    || !BARRIER_P (NEXT_INSN (NEXT_INSN (last)))\n+\t    || !LABEL_P (NEXT_INSN (NEXT_INSN (NEXT_INSN (last))))\n \t    || NEXT_INSN (NEXT_INSN (NEXT_INSN (NEXT_INSN (last)))))\n \t  goto failed;\n \tgcc_assert (!find_reg_note (last, REG_BR_PROB, 0));\n@@ -67,7 +67,7 @@ add_reg_br_prob_note (FILE *dump_file, rtx last, int probability)\n \t\t\t       REG_NOTES (last));\n \treturn;\n       }\n-  if (!last || GET_CODE (last) != JUMP_INSN || !any_condjump_p (last))\n+  if (!last || !JUMP_P (last) || !any_condjump_p (last))\n     goto failed;\n   gcc_assert (!find_reg_note (last, REG_BR_PROB, 0));\n   REG_NOTES (last)"}, {"sha": "fc0213d121e6c6506722b422ed01986d614131af", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ca202e792186e9641f933ad0830266dbace0eeb/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ca202e792186e9641f933ad0830266dbace0eeb/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=2ca202e792186e9641f933ad0830266dbace0eeb", "patch": "@@ -1482,7 +1482,7 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n   src = SET_SRC (expr);\n   dest = SET_DEST (expr);\n \n-  if (GET_CODE (src) == REG)\n+  if (REG_P (src))\n     {\n       rtx rsi = reg_saved_in (src);\n       if (rsi)"}, {"sha": "162d3f301f30f000ebc959f9871b5d7a6f802664", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ca202e792186e9641f933ad0830266dbace0eeb/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ca202e792186e9641f933ad0830266dbace0eeb/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=2ca202e792186e9641f933ad0830266dbace0eeb", "patch": "@@ -2697,7 +2697,7 @@ get_first_nonnote_insn (void)\n \t  continue;\n       else\n \t{\n-\t  if (GET_CODE (insn) == INSN\n+\t  if (NONJUMP_INSN_P (insn)\n \t      && GET_CODE (PATTERN (insn)) == SEQUENCE)\n \t    insn = XVECEXP (PATTERN (insn), 0, 0);\n \t}\n@@ -2723,7 +2723,7 @@ get_last_nonnote_insn (void)\n \t  continue;\n       else\n \t{\n-\t  if (GET_CODE (insn) == INSN\n+\t  if (NONJUMP_INSN_P (insn)\n \t      && GET_CODE (PATTERN (insn)) == SEQUENCE)\n \t    insn = XVECEXP (PATTERN (insn), 0,\n \t\t\t    XVECLEN (PATTERN (insn), 0) - 1);"}, {"sha": "020e78d65471f2efae041544eb18ed7029ec12bd", "filename": "gcc/expr.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ca202e792186e9641f933ad0830266dbace0eeb/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ca202e792186e9641f933ad0830266dbace0eeb/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=2ca202e792186e9641f933ad0830266dbace0eeb", "patch": "@@ -2650,7 +2650,7 @@ write_complex_part (rtx cplx, rtx val, bool imag_p)\n \t the original object if it spans an even number of hard regs.\n \t This special case is important for SCmode on 64-bit platforms\n \t where the natural size of floating-point regs is 32-bit.  */\n-      || (GET_CODE (cplx) == REG\n+      || (REG_P (cplx)\n \t  && REGNO (cplx) < FIRST_PSEUDO_REGISTER\n \t  && hard_regno_nregs[REGNO (cplx)][cmode] % 2 == 0)\n       /* For MEMs we always try to make a \"subreg\", that is to adjust\n@@ -2710,7 +2710,7 @@ read_complex_part (rtx cplx, bool imag_p)\n \t the original object if it spans an even number of hard regs.\n \t This special case is important for SCmode on 64-bit platforms\n \t where the natural size of floating-point regs is 32-bit.  */\n-      || (GET_CODE (cplx) == REG\n+      || (REG_P (cplx)\n \t  && REGNO (cplx) < FIRST_PSEUDO_REGISTER\n \t  && hard_regno_nregs[REGNO (cplx)][cmode] % 2 == 0)\n       /* For MEMs we always try to make a \"subreg\", that is to adjust\n@@ -6213,7 +6213,7 @@ expand_expr_addr_expr_1 (tree exp, rtx target, enum machine_mode tmode,\n \t  /* If the DECL isn't in memory, then the DECL wasn't properly\n \t     marked TREE_ADDRESSABLE, which will be either a front-end\n \t     or a tree optimizer bug.  */\n-\t  gcc_assert (GET_CODE (result) == MEM);\n+\t  gcc_assert (MEM_P (result));\n \t  result = XEXP (result, 0);\n \n \t  /* ??? Is this needed anymore?  */"}, {"sha": "5a1cf8b36c1e3610e68058638b7dc8ee07a6a785", "filename": "gcc/function.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ca202e792186e9641f933ad0830266dbace0eeb/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ca202e792186e9641f933ad0830266dbace0eeb/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=2ca202e792186e9641f933ad0830266dbace0eeb", "patch": "@@ -1244,15 +1244,14 @@ instantiate_virtual_regs (void)\n   /* Scan through all the insns, instantiating every virtual register still\n      present.  */\n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-    if (GET_CODE (insn) == INSN || GET_CODE (insn) == JUMP_INSN\n-\t|| GET_CODE (insn) == CALL_INSN)\n+    if (INSN_P (insn))\n       {\n \tinstantiate_virtual_regs_1 (&PATTERN (insn), insn, 1);\n \tif (INSN_DELETED_P (insn))\n \t  continue;\n \tinstantiate_virtual_regs_1 (&REG_NOTES (insn), NULL_RTX, 0);\n \t/* Instantiate any virtual registers in CALL_INSN_FUNCTION_USAGE.  */\n-\tif (GET_CODE (insn) == CALL_INSN)\n+\tif (CALL_P (insn))\n \t  instantiate_virtual_regs_1 (&CALL_INSN_FUNCTION_USAGE (insn),\n \t\t\t\t      NULL_RTX, 0);\n "}, {"sha": "eaf8d257ba9e56b6e56991e1efbc310924dd34d6", "filename": "gcc/global.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ca202e792186e9641f933ad0830266dbace0eeb/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ca202e792186e9641f933ad0830266dbace0eeb/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=2ca202e792186e9641f933ad0830266dbace0eeb", "patch": "@@ -2192,7 +2192,7 @@ mark_reg_use_for_earlyclobber (rtx *x, void *data ATTRIBUTE_UNUSED)\n   basic_block bb = data;\n   struct bb_info *bb_info = BB_INFO (bb);\n \n-  if (GET_CODE (*x) == REG && REGNO (*x) >= FIRST_PSEUDO_REGISTER)\n+  if (REG_P (*x) && REGNO (*x) >= FIRST_PSEUDO_REGISTER)\n     {\n       regno = REGNO (*x);\n       if (bitmap_bit_p (bb_info->killed, regno)"}, {"sha": "210e4d600b1f95a8b9e47a49d434c6622a016cc4", "filename": "gcc/lcm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ca202e792186e9641f933ad0830266dbace0eeb/gcc%2Flcm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ca202e792186e9641f933ad0830266dbace0eeb/gcc%2Flcm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.c?ref=2ca202e792186e9641f933ad0830266dbace0eeb", "patch": "@@ -1000,7 +1000,7 @@ create_pre_exit (int n_entities, int *entity_map, const int *num_modes)\n \t   insert the final mode switch before the return value copy\n \t   to its hard register.  */\n \tif (EDGE_COUNT (EXIT_BLOCK_PTR->preds) == 1\n-\t    && GET_CODE ((last_insn = BB_END (src_bb))) == INSN\n+\t    && NONJUMP_INSN_P ((last_insn = BB_END (src_bb)))\n \t    && GET_CODE (PATTERN (last_insn)) == USE\n \t    && GET_CODE ((ret_reg = XEXP (PATTERN (last_insn), 0))) == REG)\n \t  {"}, {"sha": "c39402b10bf7a2467c40f5edef11b2f754c02cef", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ca202e792186e9641f933ad0830266dbace0eeb/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ca202e792186e9641f933ad0830266dbace0eeb/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=2ca202e792186e9641f933ad0830266dbace0eeb", "patch": "@@ -427,7 +427,7 @@ find_invariant_insn (rtx insn, bool always_reached, bool always_executed,\n     return;\n   dest = SET_DEST (set);\n \n-  if (GET_CODE (dest) != REG\n+  if (!REG_P (dest)\n       || HARD_REGISTER_P (dest))\n     simple = false;\n "}, {"sha": "3b3250aac3b18a5e821942282283b841d9ea4fa1", "filename": "gcc/optabs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ca202e792186e9641f933ad0830266dbace0eeb/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ca202e792186e9641f933ad0830266dbace0eeb/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=2ca202e792186e9641f933ad0830266dbace0eeb", "patch": "@@ -5554,7 +5554,7 @@ expand_bool_compare_and_swap (rtx mem, rtx old_val, rtx new_val, rtx target)\n \n       /* Ensure that if old_val == mem, that we're not comparing\n \t against an old value.  */\n-      if (GET_CODE (old_val) == MEM)\n+      if (MEM_P (old_val))\n \told_val = force_reg (mode, old_val);\n \n       subtarget = expand_val_compare_and_swap_1 (mem, old_val, new_val,"}, {"sha": "43ba32194221d412518f5cb2c4e3b19f4701c856", "filename": "gcc/reorg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ca202e792186e9641f933ad0830266dbace0eeb/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ca202e792186e9641f933ad0830266dbace0eeb/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=2ca202e792186e9641f933ad0830266dbace0eeb", "patch": "@@ -384,7 +384,7 @@ find_end_label (void)\n       /* If the basic block reorder pass moves the return insn to\n \t some other place try to locate it again and put our\n \t end_of_function_label there.  */\n-      while (insn && ! (GET_CODE (insn) == JUMP_INSN\n+      while (insn && ! (JUMP_P (insn)\n \t\t        && (GET_CODE (PATTERN (insn)) == RETURN)))\n \tinsn = PREV_INSN (insn);\n       if (insn)"}, {"sha": "6d7bf5f587f28b364a877678c0c7fb8c99511738", "filename": "gcc/resource.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ca202e792186e9641f933ad0830266dbace0eeb/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ca202e792186e9641f933ad0830266dbace0eeb/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=2ca202e792186e9641f933ad0830266dbace0eeb", "patch": "@@ -834,10 +834,10 @@ mark_set_resources (rtx x, struct resources *res, int in_dest,\n static bool\n return_insn_p (rtx insn)\n {\n-  if (GET_CODE (insn) == JUMP_INSN && GET_CODE (PATTERN (insn)) == RETURN)\n+  if (JUMP_P (insn) && GET_CODE (PATTERN (insn)) == RETURN)\n     return true;\n \n-  if (GET_CODE (insn) == INSN && GET_CODE (PATTERN (insn)) == SEQUENCE)\n+  if (NONJUMP_INSN_P (insn) && GET_CODE (PATTERN (insn)) == SEQUENCE)\n     return return_insn_p (XVECEXP (PATTERN (insn), 0, 0));\n \n   return false;"}, {"sha": "f7373a44e85164bfaa17d06a05f69923370b1a19", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ca202e792186e9641f933ad0830266dbace0eeb/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ca202e792186e9641f933ad0830266dbace0eeb/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=2ca202e792186e9641f933ad0830266dbace0eeb", "patch": "@@ -2477,7 +2477,7 @@ computation_cost (tree expr)\n   end_sequence ();\n \n   cost = seq_cost (seq);\n-  if (GET_CODE (rslt) == MEM)\n+  if (MEM_P (rslt))\n     cost += address_cost (XEXP (rslt, 0), TYPE_MODE (type));\n \n   return cost;"}, {"sha": "b96cdcafbf6be4c64424d6b888d0455b7e6ac882", "filename": "gcc/value-prof.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ca202e792186e9641f933ad0830266dbace0eeb/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ca202e792186e9641f933ad0830266dbace0eeb/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=2ca202e792186e9641f933ad0830266dbace0eeb", "patch": "@@ -232,7 +232,7 @@ find_mem_reference_1 (rtx *expr, void *ret)\n {\n   rtx *mem = ret;\n \n-  if (GET_CODE (*expr) == MEM)\n+  if (MEM_P (*expr))\n     {\n       *mem = *expr;\n       return 1;\n@@ -283,7 +283,7 @@ insn_prefetch_values_to_profile (rtx insn, histogram_values* values)\n   histogram_value hist;\n \n   /* It only makes sense to look for memory references in ordinary insns.  */\n-  if (GET_CODE (insn) != INSN)\n+  if (!NONJUMP_INSN_P (insn))\n     return false;\n \n   if (!find_mem_reference (insn, &mem, &write))"}]}