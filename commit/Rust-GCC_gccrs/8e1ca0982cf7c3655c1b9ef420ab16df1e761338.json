{"sha": "8e1ca0982cf7c3655c1b9ef420ab16df1e761338", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGUxY2EwOTgyY2Y3YzM2NTVjMWI5ZWY0MjBhYjE2ZGYxZTc2MTMzOA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-03-19T11:37:39Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-03-19T11:37:39Z"}, "message": "fold-const.c (extract_muldiv): Apply type check for defined overflow to multiply as well as divide.\n\n        * fold-const.c (extract_muldiv): Apply type check for defined\n        overflow to multiply as well as divide.\n\nFrom-SVN: r32636", "tree": {"sha": "81409a7f141cfb1a92f4c5d7fa61af46319d4642", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/81409a7f141cfb1a92f4c5d7fa61af46319d4642"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e1ca0982cf7c3655c1b9ef420ab16df1e761338", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e1ca0982cf7c3655c1b9ef420ab16df1e761338", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e1ca0982cf7c3655c1b9ef420ab16df1e761338", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e1ca0982cf7c3655c1b9ef420ab16df1e761338/comments", "author": null, "committer": null, "parents": [{"sha": "1519ae2c7fb8cacc3a24bbca784618adeca28251", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1519ae2c7fb8cacc3a24bbca784618adeca28251", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1519ae2c7fb8cacc3a24bbca784618adeca28251"}], "stats": {"total": 38, "additions": 23, "deletions": 15}, "files": [{"sha": "864d4b5555f159612740f4ff0674007493d66391", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1ca0982cf7c3655c1b9ef420ab16df1e761338/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1ca0982cf7c3655c1b9ef420ab16df1e761338/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8e1ca0982cf7c3655c1b9ef420ab16df1e761338", "patch": "@@ -4,6 +4,9 @@\n \t(flow_delete_insn): Decrement LABEL_NUSES when deleting insns that\n \treference labels.\n \n+\t* fold-const.c (extract_muldiv): Apply type check for defined\n+\toverflow to multiply as well as divide.\n+\n 2000-03-18  Mark Mitchell  <mark@codesourcery.com>\n \n \t* emit-rtl.c (remove_unncessary_notes): Check that all"}, {"sha": "fee1c4ba5b7f6e7e6462bfee90d54a534946b38e", "filename": "gcc/fold-const.c", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1ca0982cf7c3655c1b9ef420ab16df1e761338/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1ca0982cf7c3655c1b9ef420ab16df1e761338/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=8e1ca0982cf7c3655c1b9ef420ab16df1e761338", "patch": "@@ -4333,9 +4333,13 @@ optimize_minmax_comparison (t)\n    should be used for the computation if wider than our type.\n \n    For example, if we are dividing (X * 8) + (Y + 16) by 4, we can return\n-   (X * 2) + (Y + 4).  We also canonicalize (X + 7) * 4 into X * 4 + 28\n-   in the hope that either the machine has a multiply-accumulate insn\n-   or that this is part of an addressing calculation.\n+   (X * 2) + (Y + 4).  We must, however, be assured that either the original\n+   expression would not overflow or that overflow is undefined for the type\n+   in the language in question.\n+\n+   We also canonicalize (X + 7) * 4 into X * 4 + 28 in the hope that either\n+   the machine has a multiply-accumulate insn or that this is part of an\n+   addressing calculation.\n \n    If we return a non-null expression, it is an equivalent form of the\n    original computation, but need not be in the original type.  */\n@@ -4358,7 +4362,7 @@ extract_muldiv (t, c, code, wide_type)\n \n   /* Don't deal with constants of zero here; they confuse the code below.  */\n   if (integer_zerop (c))\n-    return 0;\n+    return NULL_TREE;\n \n   if (TREE_CODE_CLASS (tcode) == '1')\n     op0 = TREE_OPERAND (t, 0);\n@@ -4379,7 +4383,6 @@ extract_muldiv (t, c, code, wide_type)\n       break;\n \n     case CONVERT_EXPR:  case NON_LVALUE_EXPR:  case NOP_EXPR:\n-\n       /* Pass the constant down and see if we can make a simplification.  If\n \t we can, replace this expression with the inner simplification for\n \t possible later conversion to our or some other type.  */\n@@ -4534,16 +4537,18 @@ extract_muldiv (t, c, code, wide_type)\n       /* If these operations \"cancel\" each other, we have the main\n \t optimizations of this pass, which occur when either constant is a\n \t multiple of the other, in which case we replace this with either an\n-\t operation or CODE or TCODE.  If we have an unsigned type that is\n-\t not a sizetype, we canot do this for division since it will change\n-\t the result if the original computation overflowed.  */\n-      if ((code == MULT_EXPR && tcode == EXACT_DIV_EXPR\n-\t   && (! TREE_UNSIGNED (ctype)\n-\t       || (TREE_CODE (ctype) == INTEGER_TYPE\n-\t\t   && TYPE_IS_SIZETYPE (ctype))))\n-\t  || (tcode == MULT_EXPR\n-\t      && code != TRUNC_MOD_EXPR && code != CEIL_MOD_EXPR\n-\t      && code != FLOOR_MOD_EXPR && code != ROUND_MOD_EXPR))\n+\t operation or CODE or TCODE. \n+\n+\t If we have an unsigned type that is not a sizetype, we canot do\n+\t this since it will change the result if the original computation\n+\t overflowed.  */\n+      if ((! TREE_UNSIGNED (ctype)\n+\t   || (TREE_CODE (ctype) == INTEGER_TYPE\n+\t       && TYPE_IS_SIZETYPE (ctype)))\n+\t  && ((code == MULT_EXPR && tcode == EXACT_DIV_EXPR)\n+\t      || (tcode == MULT_EXPR\n+\t\t  && code != TRUNC_MOD_EXPR && code != CEIL_MOD_EXPR\n+\t\t  && code != FLOOR_MOD_EXPR && code != ROUND_MOD_EXPR)))\n \t{\n \t  if (integer_zerop (const_binop (TRUNC_MOD_EXPR, op1, c, 0)))\n \t    return fold (build (tcode, ctype, convert (ctype, op0),"}]}