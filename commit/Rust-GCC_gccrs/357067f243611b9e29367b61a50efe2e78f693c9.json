{"sha": "357067f243611b9e29367b61a50efe2e78f693c9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzU3MDY3ZjI0MzYxMWI5ZTI5MzY3YjYxYTUwZWZlMmU3OGY2OTNjOQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2017-06-29T16:40:53Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2017-06-29T16:40:53Z"}, "message": "asan.c (asan_emit_stack_protection): Update.\n\n\n\t* asan.c (asan_emit_stack_protection): Update.\n\t(create_cond_insert_point): Update.\n\t* auto-profile.c (afdo_propagate_circuit): Update.\n\t* basic-block.h (struct edge_def): Turn probability to\n\tprofile_probability.\n\t(EDGE_FREQUENCY): Update.\n\t* bb-reorder.c (find_traces_1_round): Update.\n\t(better_edge_p): Update.\n\t(sanitize_hot_paths): Update.\n\t* cfg.c (unchecked_make_edge): Initialize probability to uninitialized.\n\t(make_single_succ_edge): Update.\n\t(check_bb_profile): Update.\n\t(dump_edge_info): Update.\n\t(update_bb_profile_for_threading): Update.\n\t* cfganal.c (connect_infinite_loops_to_exit): Initialize new edge\n\tprobabilitycount to 0.\n\t* cfgbuild.c (compute_outgoing_frequencies): Update.\n\t* cfgcleanup.c (try_forward_edges): Update.\n\t(outgoing_edges_match): Update.\n\t(try_crossjump_to_edge): Update.\n\t* cfgexpand.c (expand_gimple_cond): Update make_single_succ_edge.\n\t(expand_gimple_tailcall): Update.\n\t(construct_init_block): Use make_single_succ_edge.\n\t(construct_exit_block): Use make_single_succ_edge.\n\t* cfghooks.c (verify_flow_info): Update.\n\t(redirect_edge_succ_nodup): Update.\n\t(split_edge): Update.\n\t(account_profile_record): Update.\n\t* cfgloopanal.c (single_likely_exit): Update.\n\t* cfgloopmanip.c (scale_loop_profile): Update.\n\t(set_zero_probability): Remove.\n\t(duplicate_loop_to_header_edge): Update.\n\t* cfgloopmanip.h (loop_version): Update prototype.\n\t* cfgrtl.c (try_redirect_by_replacing_jump): Update.\n\t(force_nonfallthru_and_redirect): Update.\n\t(update_br_prob_note): Update.\n\t(rtl_verify_edges): Update.\n\t(purge_dead_edges): Update.\n\t(rtl_lv_add_condition_to_bb): Update.\n\t* cgraph.c: (cgraph_edge::redirect_call_stmt_to_calle): Update.\n\t* cgraphunit.c (init_lowered_empty_function): Update.\n\t(cgraph_node::expand_thunk): Update.\n\t* cilk-common.c: Include profile-count.h\n\t* dojump.c (inv): Remove.\n\t(jumpifnot): Update.\n\t(jumpifnot_1): Update.\n\t(do_jump_1): Update.\n\t(do_jump): Update.\n\t(do_jump_by_parts_greater_rtx): Update.\n\t(do_compare_rtx_and_jump): Update.\n\t* dojump.h (jumpifnot, jumpifnot_1, jumpif_1, jumpif, do_jump,\n\tdo_jump_1. do_compare_rtx_and_jump): Update prototype.\n\t* dwarf2cfi.c: Include profile-count.h\n\t* except.c (dw2_build_landing_pads): Use make_single_succ_edge.\n\t(sjlj_emit_dispatch_table): Likewise.\n\t* explow.c: Include profile-count.h\n\t* expmed.c (emit_store_flag_force): Update.\n\t(do_cmp_and_jump): Update.\n\t* expr.c (compare_by_pieces_d::generate): Update.\n\t(compare_by_pieces_d::finish_mode): Update.\n\t(emit_block_move_via_loop): Update.\n\t(store_expr_with_bounds): Update.\n\t(store_constructor): Update.\n\t(expand_expr_real_2): Update.\n\t(expand_expr_real_1): Update.\n\t* expr.h (try_casesi, try_tablejump): Update prototypes.\n\t* gimple-pretty-print.c (dump_probability): Update.\n\t(dump_profile): New.\n\t(dump_gimple_label): Update.\n\t(dump_gimple_bb_header): Update.\n\t* graph.c (draw_cfg_node_succ_edges): Update.\n\t* hsa-gen.c (convert_switch_statements): Update.\n\t* ifcvt.c (cheap_bb_rtx_cost_p): Update.\n\t(find_if_case_1): Update.\n\t(find_if_case_2): Update.\n\t* internal-fn.c (expand_arith_overflow_result_store): Update.\n\t(expand_addsub_overflow): Update.\n\t(expand_neg_overflow): Update.\n\t(expand_mul_overflow): Update.\n\t(expand_vector_ubsan_overflow): Update.\n\t* ipa-cp.c (good_cloning_opportunity_p): Update.\n\t* ipa-split.c (split_function): Use make_single_succ_edge.\n\t* ipa-utils.c (ipa_merge_profiles): Update.\n\t* loop-doloop.c (add_test): Update.\n\t(doloop_modify): Update.\n\t* loop-unroll.c (compare_and_jump_seq): Update.\n\t(unroll_loop_runtime_iterations): Update.\n\t* lra-constraints.c (lra_inheritance): Update.\n\t* lto-streamer-in.c (input_cfg): Update.\n\t* lto-streamer-out.c (output_cfg): Update.\n\t* mcf.c (adjust_cfg_counts): Update.\n\t* modulo-sched.c (sms_schedule): Update.\n\t* omp-expand.c (expand_omp_for_init_counts): Update.\n\t(extract_omp_for_update_vars): Update.\n\t(expand_omp_ordered_sink): Update.\n\t(expand_omp_for_ordered_loops): Update.\n\t(expand_omp_for_generic): Update.\n\t(expand_omp_for_static_nochunk): Update.\n\t(expand_omp_for_static_chunk): Update.\n\t(expand_cilk_for): Update.\n\t(expand_omp_simd): Update.\n\t(expand_omp_taskloop_for_outer): Update.\n\t(expand_omp_taskloop_for_inner): Update.\n\t* omp-simd-clone.c (simd_clone_adjust): Update.\n\t* optabs.c (expand_doubleword_shift): Update.\n\t(expand_abs): Update.\n\t(emit_cmp_and_jump_insn_1): Update.\n\t(expand_compare_and_swap_loop): Update.\n\t* optabs.h (emit_cmp_and_jump_insns): Update prototype.\n\t* predict.c (predictable_edge_p): Update.\n\t(edge_probability_reliable_p): Update.\n\t(set_even_probabilities): Update.\n\t(combine_predictions_for_insn): Update.\n\t(combine_predictions_for_bb): Update.\n\t(propagate_freq): Update.\n\t(estimate_bb_frequencies): Update.\n\t(force_edge_cold): Update.\n\t* profile-count.c (profile_count::dump): Add missing space into dump.\n\t(profile_count::debug): Add newline.\n\t(profile_count::differs_from_p): Explicitly convert to unsigned.\n\t(profile_count::stream_in): Update.\n\t(profile_probability::dump): New member function.\n\t(profile_probability::debug): New member function.\n\t(profile_probability::differs_from_p): New member function.\n\t(profile_probability::differs_lot_from_p): New member function.\n\t(profile_probability::stream_in): New member function.\n\t(profile_probability::stream_out): New member function.\n\t* profile-count.h (profile_count_quality): Rename to ...\n\t(profile_quality): ... this one.\n\t(profile_probability): New.\n\t(profile_count): Update.\n\t* profile.c (compute_branch_probabilities): Update.\n\t* recog.c (peep2_attempt): Update.\n\t* sched-ebb.c (schedule_ebbs): Update.\n\t* sched-rgn.c (find_single_block_region): Update.\n\t(compute_dom_prob_ps): Update.\n\t(schedule_region): Update.\n\t* sel-sched-ir.c (compute_succs_info): Update.\n\t* stmt.c (struct case_node): Update.\n\t(do_jump_if_equal): Update.\n\t(get_outgoing_edge_probs): Update.\n\t(conditional_probability): Update.\n\t(emit_case_dispatch_table): Update.\n\t(expand_case): Update.\n\t(expand_sjlj_dispatch_table): Update.\n\t(emit_case_nodes): Update.\n\t* targhooks.c: Update.\n\t* tracer.c (better_p): Update.\n\t(find_best_successor): Update.\n\t* trans-mem.c (expand_transaction): Update.\n\t* tree-call-cdce.c: Update.\n\t* tree-cfg.c (gimple_split_edge): Upate.\n\t(move_sese_region_to_fn): Upate.\n\t* tree-cfgcleanup.c (cleanup_control_expr_graph): Upate.\n\t* tree-eh.c (lower_resx): Upate.\n\t(cleanup_empty_eh_move_lp): Upate.\n\t* tree-if-conv.c (version_loop_for_if_conversion): Update.\n\t* tree-inline.c (copy_edges_for_bb): Update.\n\t(copy_cfg_body): Update.\n\t* tree-parloops.c (gen_parallel_loop): Update.\n\t* tree-profile.c (gimple_gen_ic_func_profiler): Update.\n\t(gimple_gen_time_profiler): Update.\n\t* tree-ssa-dce.c (remove_dead_stmt): Update.\n\t* tree-ssa-ifcombine.c (update_profile_after_ifcombine): Update.\n\t* tree-ssa-loop-im.c (execute_sm_if_changed): Update.\n\t* tree-ssa-loop-ivcanon.c (remove_exits_and_undefined_stmts): Update.\n\t(unloop_loops): Update.\n\t(try_peel_loop): Update.\n\t* tree-ssa-loop-manip.c (tree_transform_and_unroll_loop): Update.\n\t* tree-ssa-loop-split.c (connect_loops): Update.\n\t(split_loop): Update.\n\t* tree-ssa-loop-unswitch.c (tree_unswitch_loop): Update.\n\t(hoist_guard): Update.\n\t* tree-ssa-phionlycprop.c (propagate_rhs_into_lhs): Update.\n\t* tree-ssa-phiopt.c (replace_phi_edge_with_variable): Update.\n\t(value_replacement): Update.\n\t* tree-ssa-reassoc.c (branch_fixup): Update.\n\t* tree-ssa-tail-merge.c (replace_block_by): Update.\n\t* tree-ssa-threadupdate.c (remove_ctrl_stmt_and_useless_edges): Update.\n\t(create_edge_and_update_destination_phis): Update.\n\t(compute_path_counts): Update.\n\t(recompute_probabilities): Update.\n\t(update_joiner_offpath_counts): Update.\n\t(freqs_to_counts_path): Update.\n\t(duplicate_thread_path): Update.\n\t* tree-switch-conversion.c (hoist_edge_and_branch_if_true): Update.\n\t(struct switch_conv_info): Update.\n\t(gen_inbound_check): Update.\n\t* tree-vect-loop-manip.c (slpeel_add_loop_guard): Update.\n\t(vect_do_peeling): Update.\n\t(vect_loop_versioning): Update.\n\t* tree-vect-loop.c (scale_profile_for_vect_loop): Update.\n\t(optimize_mask_stores): Update.\n\t* ubsan.c (ubsan_expand_null_ifn): Update.\n\t* value-prof.c (gimple_divmod_fixed_value): Update.\n\t(gimple_divmod_fixed_value_transform): Update.\n\t(gimple_mod_pow2): Update.\n\t(gimple_mod_pow2_value_transform): Update.\n\t(gimple_mod_subtract): Update.\n\t(gimple_mod_subtract_transform): Update.\n\t(gimple_ic): Update.\n\t(gimple_stringop_fixed_value): Update.\n\t(gimple_stringops_transform): Update.\n\t* value-prof.h: Update.\n\nFrom-SVN: r249800", "tree": {"sha": "45e6fed3d816c143ade1663a45c34681cee487a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/45e6fed3d816c143ade1663a45c34681cee487a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/357067f243611b9e29367b61a50efe2e78f693c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/357067f243611b9e29367b61a50efe2e78f693c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/357067f243611b9e29367b61a50efe2e78f693c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/357067f243611b9e29367b61a50efe2e78f693c9/comments", "author": null, "committer": null, "parents": [{"sha": "fac877a14ab52fcf94b260112cd133aa80b349b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fac877a14ab52fcf94b260112cd133aa80b349b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fac877a14ab52fcf94b260112cd133aa80b349b2"}], "stats": {"total": 2532, "additions": 1721, "deletions": 811}, "files": [{"sha": "2f339ccb3b19c79fd59e01f1fd04e5775eb9ec43", "filename": "gcc/ChangeLog", "status": "modified", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -1,3 +1,210 @@\n+2017-06-29  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* asan.c (asan_emit_stack_protection): Update.\n+\t(create_cond_insert_point): Update.\n+\t* auto-profile.c (afdo_propagate_circuit): Update.\n+\t* basic-block.h (struct edge_def): Turn probability to\n+\tprofile_probability.\n+\t(EDGE_FREQUENCY): Update.\n+\t* bb-reorder.c (find_traces_1_round): Update.\n+\t(better_edge_p): Update.\n+\t(sanitize_hot_paths): Update.\n+\t* cfg.c (unchecked_make_edge): Initialize probability to uninitialized.\n+\t(make_single_succ_edge): Update.\n+\t(check_bb_profile): Update.\n+\t(dump_edge_info): Update.\n+\t(update_bb_profile_for_threading): Update.\n+\t* cfganal.c (connect_infinite_loops_to_exit): Initialize new edge\n+\tprobabilitycount to 0.\n+\t* cfgbuild.c (compute_outgoing_frequencies): Update.\n+\t* cfgcleanup.c (try_forward_edges): Update.\n+\t(outgoing_edges_match): Update.\n+\t(try_crossjump_to_edge): Update.\n+\t* cfgexpand.c (expand_gimple_cond): Update make_single_succ_edge.\n+\t(expand_gimple_tailcall): Update.\n+\t(construct_init_block): Use make_single_succ_edge.\n+\t(construct_exit_block): Use make_single_succ_edge.\n+\t* cfghooks.c (verify_flow_info): Update.\n+\t(redirect_edge_succ_nodup): Update.\n+\t(split_edge): Update.\n+\t(account_profile_record): Update.\n+\t* cfgloopanal.c (single_likely_exit): Update.\n+\t* cfgloopmanip.c (scale_loop_profile): Update.\n+\t(set_zero_probability): Remove.\n+\t(duplicate_loop_to_header_edge): Update.\n+\t* cfgloopmanip.h (loop_version): Update prototype.\n+\t* cfgrtl.c (try_redirect_by_replacing_jump): Update.\n+\t(force_nonfallthru_and_redirect): Update.\n+\t(update_br_prob_note): Update.\n+\t(rtl_verify_edges): Update.\n+\t(purge_dead_edges): Update.\n+\t(rtl_lv_add_condition_to_bb): Update.\n+\t* cgraph.c: (cgraph_edge::redirect_call_stmt_to_calle): Update.\n+\t* cgraphunit.c (init_lowered_empty_function): Update.\n+\t(cgraph_node::expand_thunk): Update.\n+\t* cilk-common.c: Include profile-count.h\n+\t* dojump.c (inv): Remove.\n+\t(jumpifnot): Update.\n+\t(jumpifnot_1): Update.\n+\t(do_jump_1): Update.\n+\t(do_jump): Update.\n+\t(do_jump_by_parts_greater_rtx): Update.\n+\t(do_compare_rtx_and_jump): Update.\n+\t* dojump.h (jumpifnot, jumpifnot_1, jumpif_1, jumpif, do_jump,\n+\tdo_jump_1. do_compare_rtx_and_jump): Update prototype.\n+\t* dwarf2cfi.c: Include profile-count.h\n+\t* except.c (dw2_build_landing_pads): Use make_single_succ_edge.\n+\t(sjlj_emit_dispatch_table): Likewise.\n+\t* explow.c: Include profile-count.h\n+\t* expmed.c (emit_store_flag_force): Update.\n+\t(do_cmp_and_jump): Update.\n+\t* expr.c (compare_by_pieces_d::generate): Update.\n+\t(compare_by_pieces_d::finish_mode): Update.\n+\t(emit_block_move_via_loop): Update.\n+\t(store_expr_with_bounds): Update.\n+\t(store_constructor): Update.\n+\t(expand_expr_real_2): Update.\n+\t(expand_expr_real_1): Update.\n+\t* expr.h (try_casesi, try_tablejump): Update prototypes.\n+\t* gimple-pretty-print.c (dump_probability): Update.\n+\t(dump_profile): New.\n+\t(dump_gimple_label): Update.\n+\t(dump_gimple_bb_header): Update.\n+\t* graph.c (draw_cfg_node_succ_edges): Update.\n+\t* hsa-gen.c (convert_switch_statements): Update.\n+\t* ifcvt.c (cheap_bb_rtx_cost_p): Update.\n+\t(find_if_case_1): Update.\n+\t(find_if_case_2): Update.\n+\t* internal-fn.c (expand_arith_overflow_result_store): Update.\n+\t(expand_addsub_overflow): Update.\n+\t(expand_neg_overflow): Update.\n+\t(expand_mul_overflow): Update.\n+\t(expand_vector_ubsan_overflow): Update.\n+\t* ipa-cp.c (good_cloning_opportunity_p): Update.\n+\t* ipa-split.c (split_function): Use make_single_succ_edge.\n+\t* ipa-utils.c (ipa_merge_profiles): Update.\n+\t* loop-doloop.c (add_test): Update.\n+\t(doloop_modify): Update.\n+\t* loop-unroll.c (compare_and_jump_seq): Update.\n+\t(unroll_loop_runtime_iterations): Update.\n+\t* lra-constraints.c (lra_inheritance): Update.\n+\t* lto-streamer-in.c (input_cfg): Update.\n+\t* lto-streamer-out.c (output_cfg): Update.\n+\t* mcf.c (adjust_cfg_counts): Update.\n+\t* modulo-sched.c (sms_schedule): Update.\n+\t* omp-expand.c (expand_omp_for_init_counts): Update.\n+\t(extract_omp_for_update_vars): Update.\n+\t(expand_omp_ordered_sink): Update.\n+\t(expand_omp_for_ordered_loops): Update.\n+\t(expand_omp_for_generic): Update.\n+\t(expand_omp_for_static_nochunk): Update.\n+\t(expand_omp_for_static_chunk): Update.\n+\t(expand_cilk_for): Update.\n+\t(expand_omp_simd): Update.\n+\t(expand_omp_taskloop_for_outer): Update.\n+\t(expand_omp_taskloop_for_inner): Update.\n+\t* omp-simd-clone.c (simd_clone_adjust): Update.\n+\t* optabs.c (expand_doubleword_shift): Update.\n+\t(expand_abs): Update.\n+\t(emit_cmp_and_jump_insn_1): Update.\n+\t(expand_compare_and_swap_loop): Update.\n+\t* optabs.h (emit_cmp_and_jump_insns): Update prototype.\n+\t* predict.c (predictable_edge_p): Update.\n+\t(edge_probability_reliable_p): Update.\n+\t(set_even_probabilities): Update.\n+\t(combine_predictions_for_insn): Update.\n+\t(combine_predictions_for_bb): Update.\n+\t(propagate_freq): Update.\n+\t(estimate_bb_frequencies): Update.\n+\t(force_edge_cold): Update.\n+\t* profile-count.c (profile_count::dump): Add missing space into dump.\n+\t(profile_count::debug): Add newline.\n+\t(profile_count::differs_from_p): Explicitly convert to unsigned.\n+\t(profile_count::stream_in): Update.\n+\t(profile_probability::dump): New member function.\n+\t(profile_probability::debug): New member function.\n+\t(profile_probability::differs_from_p): New member function.\n+\t(profile_probability::differs_lot_from_p): New member function.\n+\t(profile_probability::stream_in): New member function.\n+\t(profile_probability::stream_out): New member function.\n+\t* profile-count.h (profile_count_quality): Rename to ...\n+\t(profile_quality): ... this one.\n+\t(profile_probability): New.\n+\t(profile_count): Update.\n+\t* profile.c (compute_branch_probabilities): Update.\n+\t* recog.c (peep2_attempt): Update.\n+\t* sched-ebb.c (schedule_ebbs): Update.\n+\t* sched-rgn.c (find_single_block_region): Update.\n+\t(compute_dom_prob_ps): Update.\n+\t(schedule_region): Update.\n+\t* sel-sched-ir.c (compute_succs_info): Update.\n+\t* stmt.c (struct case_node): Update.\n+\t(do_jump_if_equal): Update.\n+\t(get_outgoing_edge_probs): Update.\n+\t(conditional_probability): Update.\n+\t(emit_case_dispatch_table): Update.\n+\t(expand_case): Update.\n+\t(expand_sjlj_dispatch_table): Update.\n+\t(emit_case_nodes): Update.\n+\t* targhooks.c: Update.\n+\t* tracer.c (better_p): Update.\n+\t(find_best_successor): Update.\n+\t* trans-mem.c (expand_transaction): Update.\n+\t* tree-call-cdce.c: Update.\n+\t* tree-cfg.c (gimple_split_edge): Upate.\n+\t(move_sese_region_to_fn): Upate.\n+\t* tree-cfgcleanup.c (cleanup_control_expr_graph): Upate.\n+\t* tree-eh.c (lower_resx): Upate.\n+\t(cleanup_empty_eh_move_lp): Upate.\n+\t* tree-if-conv.c (version_loop_for_if_conversion): Update.\n+\t* tree-inline.c (copy_edges_for_bb): Update.\n+\t(copy_cfg_body): Update.\n+\t* tree-parloops.c (gen_parallel_loop): Update.\n+\t* tree-profile.c (gimple_gen_ic_func_profiler): Update.\n+\t(gimple_gen_time_profiler): Update.\n+\t* tree-ssa-dce.c (remove_dead_stmt): Update.\n+\t* tree-ssa-ifcombine.c (update_profile_after_ifcombine): Update.\n+\t* tree-ssa-loop-im.c (execute_sm_if_changed): Update.\n+\t* tree-ssa-loop-ivcanon.c (remove_exits_and_undefined_stmts): Update.\n+\t(unloop_loops): Update.\n+\t(try_peel_loop): Update.\n+\t* tree-ssa-loop-manip.c (tree_transform_and_unroll_loop): Update.\n+\t* tree-ssa-loop-split.c (connect_loops): Update.\n+\t(split_loop): Update.\n+\t* tree-ssa-loop-unswitch.c (tree_unswitch_loop): Update.\n+\t(hoist_guard): Update.\n+\t* tree-ssa-phionlycprop.c (propagate_rhs_into_lhs): Update.\n+\t* tree-ssa-phiopt.c (replace_phi_edge_with_variable): Update.\n+\t(value_replacement): Update.\n+\t* tree-ssa-reassoc.c (branch_fixup): Update.\n+\t* tree-ssa-tail-merge.c (replace_block_by): Update.\n+\t* tree-ssa-threadupdate.c (remove_ctrl_stmt_and_useless_edges): Update.\n+\t(create_edge_and_update_destination_phis): Update.\n+\t(compute_path_counts): Update.\n+\t(recompute_probabilities): Update.\n+\t(update_joiner_offpath_counts): Update.\n+\t(freqs_to_counts_path): Update.\n+\t(duplicate_thread_path): Update.\n+\t* tree-switch-conversion.c (hoist_edge_and_branch_if_true): Update.\n+\t(struct switch_conv_info): Update.\n+\t(gen_inbound_check): Update.\n+\t* tree-vect-loop-manip.c (slpeel_add_loop_guard): Update.\n+\t(vect_do_peeling): Update.\n+\t(vect_loop_versioning): Update.\n+\t* tree-vect-loop.c (scale_profile_for_vect_loop): Update.\n+\t(optimize_mask_stores): Update.\n+\t* ubsan.c (ubsan_expand_null_ifn): Update.\n+\t* value-prof.c (gimple_divmod_fixed_value): Update.\n+\t(gimple_divmod_fixed_value_transform): Update.\n+\t(gimple_mod_pow2): Update.\n+\t(gimple_mod_pow2_value_transform): Update.\n+\t(gimple_mod_subtract): Update.\n+\t(gimple_mod_subtract_transform): Update.\n+\t(gimple_ic): Update.\n+\t(gimple_stringop_fixed_value): Update.\n+\t(gimple_stringops_transform): Update.\n+\t* value-prof.h: Update.\n+\n 2017-06-29  Carl Love  <cel@us.ibm.com>\n \n \t* config/rs6000/rs6000-c.c: Add support for built-in functions"}, {"sha": "2de16402c5113365e1b4e16e06f2507a0b16c3bc", "filename": "gcc/asan.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -1145,9 +1145,9 @@ asan_emit_stack_protection (rtx base, rtx pbase, unsigned int alignb,\n       emit_move_insn (orig_base, base);\n       ret = expand_normal (asan_detect_stack_use_after_return);\n       lab = gen_label_rtx ();\n-      int very_likely = REG_BR_PROB_BASE - (REG_BR_PROB_BASE / 2000 - 1);\n       emit_cmp_and_jump_insns (ret, const0_rtx, EQ, NULL_RTX,\n-\t\t\t       VOIDmode, 0, lab, very_likely);\n+\t\t\t       VOIDmode, 0, lab,\n+\t\t\t       profile_probability::very_likely ());\n       snprintf (buf, sizeof buf, \"__asan_stack_malloc_%d\",\n \t\tuse_after_return_class);\n       ret = init_one_libfunc (buf);\n@@ -1158,9 +1158,9 @@ asan_emit_stack_protection (rtx base, rtx pbase, unsigned int alignb,\n       /* __asan_stack_malloc_[n] returns a pointer to fake stack if succeeded\n \t and NULL otherwise.  Check RET value is NULL here and jump over the\n \t BASE reassignment in this case.  Otherwise, reassign BASE to RET.  */\n-      int very_unlikely = REG_BR_PROB_BASE / 2000 - 1;\n       emit_cmp_and_jump_insns (ret, const0_rtx, EQ, NULL_RTX,\n-\t\t\t       VOIDmode, 0, lab, very_unlikely);\n+\t\t\t       VOIDmode, 0, lab,\n+\t\t\t       profile_probability:: very_unlikely ());\n       ret = convert_memory_address (Pmode, ret);\n       emit_move_insn (base, ret);\n       emit_label (lab);\n@@ -1255,9 +1255,9 @@ asan_emit_stack_protection (rtx base, rtx pbase, unsigned int alignb,\n     {\n       rtx_code_label *lab2 = gen_label_rtx ();\n       char c = (char) ASAN_STACK_MAGIC_USE_AFTER_RET;\n-      int very_likely = REG_BR_PROB_BASE - (REG_BR_PROB_BASE / 2000 - 1);\n       emit_cmp_and_jump_insns (orig_base, base, EQ, NULL_RTX,\n-\t\t\t       VOIDmode, 0, lab2, very_likely);\n+\t\t\t       VOIDmode, 0, lab2,\n+\t\t\t       profile_probability::very_likely ());\n       shadow_mem = gen_rtx_MEM (BLKmode, shadow_base);\n       set_mem_alias_set (shadow_mem, asan_shadow_set);\n       mem = gen_rtx_MEM (ptr_mode, base);\n@@ -1588,15 +1588,17 @@ create_cond_insert_point (gimple_stmt_iterator *iter,\n     = then_more_likely_p\n     ? PROB_VERY_UNLIKELY\n     : PROB_ALWAYS - PROB_VERY_UNLIKELY;\n-  e->probability = PROB_ALWAYS - fallthrough_probability;\n+  e->probability = profile_probability::from_reg_br_prob_base\n+\t\t(PROB_ALWAYS - fallthrough_probability);\n   if (create_then_fallthru_edge)\n     make_single_succ_edge (then_bb, fallthru_bb, EDGE_FALLTHRU);\n \n   /* Set up the fallthrough basic block.  */\n   e = find_edge (cond_bb, fallthru_bb);\n   e->flags = EDGE_FALSE_VALUE;\n   e->count = cond_bb->count;\n-  e->probability = fallthrough_probability;\n+  e->probability\n+\t = profile_probability::from_reg_br_prob_base (fallthrough_probability);\n \n   /* Update dominance info for the newly created then_bb; note that\n      fallthru_bb's dominance info has already been updated by"}, {"sha": "521f4c0d3eb3e59cf5bb23b283d52d97cd827f17", "filename": "gcc/auto-profile.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fauto-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fauto-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fauto-profile.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -1346,9 +1346,10 @@ afdo_propagate_circuit (const bb_set &annotated_bb, edge_set *annotated_edge)\n             continue;\n           total++;\n           only_one = ep;\n-          if (e->probability == 0 && !is_edge_annotated (ep, *annotated_edge))\n+          if (!e->probability.initialized_p ()\n+\t      && !is_edge_annotated (ep, *annotated_edge))\n             {\n-              ep->probability = 0;\n+              ep->probability = profile_probability::never ();\n               ep->count = profile_count::zero ();\n               set_edge_annotated (ep, annotated_edge);\n             }"}, {"sha": "c0c47784c02448b177acca538404d0493825b32e", "filename": "gcc/basic-block.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -45,7 +45,7 @@ struct GTY((user)) edge_def {\n   unsigned int dest_idx;\n \n   int flags;\t\t\t/* see cfg-flags.def */\n-  int probability;\t\t/* biased by REG_BR_PROB_BASE */\n+  profile_probability probability;\n   profile_count count;\t\t/* Expected number of executions calculated\n \t\t\t\t   in profile.c  */\n };\n@@ -300,8 +300,7 @@ enum cfg_bb_flags\n \t\t\t\t\t ? EDGE_SUCC ((bb), 1) : EDGE_SUCC ((bb), 0))\n \n /* Return expected execution frequency of the edge E.  */\n-#define EDGE_FREQUENCY(e)\t\tRDIV ((e)->src->frequency * (e)->probability, \\\n-\t\t\t\t\t      REG_BR_PROB_BASE)\n+#define EDGE_FREQUENCY(e)\t\te->probability.apply (e->src->frequency)\n \n /* Compute a scale factor (or probability) suitable for scaling of\n    gcov_type values via apply_probability() and apply_scale().  */"}, {"sha": "276ab589427b83ebc199198716453c33cb5afd0f", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -206,8 +206,8 @@ static void find_traces_1_round (int, int, gcov_type, struct trace *, int *,\n \t\t\t\t int, bb_heap_t **, int);\n static basic_block copy_bb (basic_block, edge, basic_block, int);\n static long bb_to_key (basic_block);\n-static bool better_edge_p (const_basic_block, const_edge, int, int, int, int,\n-\t\t\t   const_edge);\n+static bool better_edge_p (const_basic_block, const_edge, profile_probability,\n+\t\t\t   int, profile_probability, int, const_edge);\n static bool connect_better_edge_p (const_edge, bool, int, const_edge,\n \t\t\t\t   struct trace *);\n static void connect_traces (int, struct trace *);\n@@ -513,11 +513,12 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \n       do\n \t{\n-\t  int prob, freq;\n+\t  profile_probability prob;\n+\t  int freq;\n \t  bool ends_in_call;\n \n \t  /* The probability and frequency of the best edge.  */\n-\t  int best_prob = INT_MIN / 2;\n+\t  profile_probability best_prob = profile_probability::uninitialized ();\n \t  int best_freq = INT_MIN / 2;\n \n \t  best_edge = NULL;\n@@ -565,7 +566,9 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t\t successor (i.e. it is unsuitable successor).  When optimizing\n \t\t for size, ignore the probability and frequency.  */\n \t      if (!(e->flags & EDGE_CAN_FALLTHRU) || (e->flags & EDGE_COMPLEX)\n-\t\t  || ((prob < branch_th || EDGE_FREQUENCY (e) < exec_th\n+\t\t  || !prob.initialized_p ()\n+\t\t  || ((prob.to_reg_br_prob_base () < branch_th\n+\t\t       || EDGE_FREQUENCY (e) < exec_th\n \t\t      || e->count < count_th) && (!for_size)))\n \t\tcontinue;\n \n@@ -648,7 +651,9 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \n \t\t  if (!(e->flags & EDGE_CAN_FALLTHRU)\n \t\t      || (e->flags & EDGE_COMPLEX)\n-\t\t      || prob < branch_th || freq < exec_th\n+\t\t      || !prob.initialized_p ()\n+\t\t      || prob.to_reg_br_prob_base () < branch_th\n+\t\t      || freq < exec_th\n \t\t      || e->count < count_th)\n \t\t    {\n \t\t      /* When partitioning hot/cold basic blocks, make sure\n@@ -936,14 +941,15 @@ bb_to_key (basic_block bb)\n    BEST_PROB; similarly for frequency.  */\n \n static bool\n-better_edge_p (const_basic_block bb, const_edge e, int prob, int freq,\n-\t       int best_prob, int best_freq, const_edge cur_best_edge)\n+better_edge_p (const_basic_block bb, const_edge e, profile_probability prob,\n+\t       int freq, profile_probability best_prob, int best_freq,\n+\t       const_edge cur_best_edge)\n {\n   bool is_better_edge;\n \n   /* The BEST_* values do not have to be best, but can be a bit smaller than\n      maximum values.  */\n-  int diff_prob = best_prob / 10;\n+  profile_probability diff_prob = best_prob.apply_scale (1, 10);\n   int diff_freq = best_freq / 10;\n \n   /* The smaller one is better to keep the original order.  */\n@@ -1494,7 +1500,8 @@ sanitize_hot_paths (bool walk_up, unsigned int cold_bb_count,\n       vec<edge, va_gc> *edges = walk_up ? bb->preds : bb->succs;\n       edge e;\n       edge_iterator ei;\n-      int highest_probability = 0;\n+      profile_probability highest_probability\n+\t\t\t\t = profile_probability::uninitialized ();\n       int highest_freq = 0;\n       profile_count highest_count = profile_count::uninitialized ();\n       bool found = false;\n@@ -1517,12 +1524,13 @@ sanitize_hot_paths (bool walk_up, unsigned int cold_bb_count,\n           /* The following loop will look for the hottest edge via\n              the edge count, if it is non-zero, then fallback to the edge\n              frequency and finally the edge probability.  */\n-          if (e->count > highest_count)\n+          if (!highest_count.initialized_p () || e->count > highest_count)\n             highest_count = e->count;\n           int edge_freq = EDGE_FREQUENCY (e);\n           if (edge_freq > highest_freq)\n             highest_freq = edge_freq;\n-          if (e->probability > highest_probability)\n+          if (!highest_probability.initialized_p ()\n+\t      || e->probability > highest_probability)\n             highest_probability = e->probability;\n         }\n "}, {"sha": "5d31185c8926c16592524731d01bc095da884eec", "filename": "gcc/cfg.c", "status": "modified", "additions": 56, "deletions": 43, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -264,6 +264,7 @@ unchecked_make_edge (basic_block src, basic_block dst, int flags)\n   n_edges_for_fn (cfun)++;\n \n   e->count = profile_count::uninitialized ();\n+  e->probability = profile_probability::uninitialized ();\n   e->src = src;\n   e->dest = dst;\n   e->flags = flags;\n@@ -332,7 +333,7 @@ make_single_succ_edge (basic_block src, basic_block dest, int flags)\n {\n   edge e = make_edge (src, dest, flags);\n \n-  e->probability = REG_BR_PROB_BASE;\n+  e->probability = profile_probability::always ();\n   e->count = src->count;\n   return e;\n }\n@@ -400,7 +401,6 @@ static void\n check_bb_profile (basic_block bb, FILE * file, int indent)\n {\n   edge e;\n-  int sum = 0;\n   edge_iterator ei;\n   struct function *fun = DECL_STRUCT_FUNCTION (current_function_decl);\n   char *s_indent = (char *) alloca ((size_t) indent + 1);\n@@ -413,21 +413,38 @@ check_bb_profile (basic_block bb, FILE * file, int indent)\n   if (bb != EXIT_BLOCK_PTR_FOR_FN (fun))\n     {\n       bool found = false;\n+      profile_probability sum = profile_probability::never ();\n+      int isum = 0;\n+\n       FOR_EACH_EDGE (e, ei, bb->succs)\n \t{\n-\t  if (!(e->flags & EDGE_EH))\n+\t  if (!(e->flags & (EDGE_EH | EDGE_FAKE)))\n \t    found = true;\n \t  sum += e->probability;\n+\t  if (e->probability.initialized_p ())\n+\t    isum += e->probability.to_reg_br_prob_base ();\n \t}\n       /* Only report mismatches for non-EH control flow. If there are only EH\n \t edges it means that the BB ends by noreturn call.  Here the control\n \t flow may just terminate.  */\n       if (found)\n \t{\n-\t  if (EDGE_COUNT (bb->succs) && abs (sum - REG_BR_PROB_BASE) > 100)\n-\t    fprintf (file,\n-\t\t     \";; %sInvalid sum of outgoing probabilities %.1f%%\\n\",\n-\t\t     s_indent, sum * 100.0 / REG_BR_PROB_BASE);\n+\t  if (sum.differs_from_p (profile_probability::always ()))\n+\t    {\n+\t      fprintf (file,\n+\t\t       \";; %sInvalid sum of outgoing probabilities \",\n+\t\t       s_indent);\n+\t      sum.dump (file);\n+\t      fprintf (file, \"\\n\");\n+\t    }\n+\t  /* Probabilities caps to 100% and thus the previous test will never\n+\t     fire if the sum of probabilities is too large.  */\n+\t  else if (isum > REG_BR_PROB_BASE + 100)\n+\t    {\n+\t      fprintf (file,\n+\t\t       \";; %sInvalid sum of outgoing probabilities %.1f%%\\n\",\n+\t\t       s_indent, isum * 100.0 / REG_BR_PROB_BASE);\n+\t    }\n \t  profile_count lsum = profile_count::zero ();\n \t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t    lsum += e->count;\n@@ -442,9 +459,9 @@ check_bb_profile (basic_block bb, FILE * file, int indent)\n \t    }\n \t}\n     }\n-    if (bb != ENTRY_BLOCK_PTR_FOR_FN (fun))\n+  if (bb != ENTRY_BLOCK_PTR_FOR_FN (fun))\n     {\n-      sum = 0;\n+      int sum = 0;\n       FOR_EACH_EDGE (e, ei, bb->preds)\n \tsum += EDGE_FREQUENCY (e);\n       if (abs (sum - bb->frequency) > 100)\n@@ -498,8 +515,12 @@ dump_edge_info (FILE *file, edge e, dump_flags_t flags, int do_succ)\n   else\n     fprintf (file, \" %d\", side->index);\n \n-  if (e->probability && do_details)\n-    fprintf (file, \" [%.1f%%] \", e->probability * 100.0 / REG_BR_PROB_BASE);\n+  if (e->probability.initialized_p () && do_details)\n+    {\n+      fprintf (file, \" [\");\n+      e->probability.dump (file);\n+      fprintf (file, \"] \");\n+    }\n \n   if (e->count.initialized_p () && do_details)\n     {\n@@ -860,7 +881,7 @@ update_bb_profile_for_threading (basic_block bb, int edge_frequency,\n \t\t\t\t profile_count count, edge taken_edge)\n {\n   edge c;\n-  int prob;\n+  profile_probability prob;\n   edge_iterator ei;\n \n   if (bb->count < count)\n@@ -878,59 +899,51 @@ update_bb_profile_for_threading (basic_block bb, int edge_frequency,\n   /* Compute the probability of TAKEN_EDGE being reached via threaded edge.\n      Watch for overflows.  */\n   if (bb->frequency)\n-    prob = GCOV_COMPUTE_SCALE (edge_frequency, bb->frequency);\n+    /* FIXME: We should get edge frequency as count.  */\n+    prob = profile_probability::probability_in_gcov_type\n+\t\t (edge_frequency, bb->frequency);\n   else\n-    prob = 0;\n+    prob = profile_probability::never ();\n   if (prob > taken_edge->probability)\n     {\n       if (dump_file)\n-\tfprintf (dump_file, \"Jump threading proved probability of edge \"\n-\t\t \"%i->%i too small (it is %i, should be %i).\\n\",\n-\t\t taken_edge->src->index, taken_edge->dest->index,\n-\t\t taken_edge->probability, prob);\n-      prob = taken_edge->probability * 6 / 8;\n+\t{\n+\t  fprintf (dump_file, \"Jump threading proved probability of edge \"\n+\t\t   \"%i->%i too small (it is \",\n+\t\t   taken_edge->src->index, taken_edge->dest->index);\t\n+\t  taken_edge->probability.dump (dump_file);\n+\t  fprintf (dump_file, \" should be \");\n+\t  prob.dump (dump_file);\n+\t  fprintf (dump_file, \")\\n\");\n+\t}\n+      prob = taken_edge->probability.apply_scale (6, 8);\n     }\n \n   /* Now rescale the probabilities.  */\n   taken_edge->probability -= prob;\n-  prob = REG_BR_PROB_BASE - prob;\n-  if (prob <= 0)\n+  prob = prob.invert ();\n+  if (prob == profile_probability::never ())\n     {\n       if (dump_file)\n \tfprintf (dump_file, \"Edge frequencies of bb %i has been reset, \"\n \t\t \"frequency of block should end up being 0, it is %i\\n\",\n \t\t bb->index, bb->frequency);\n-      EDGE_SUCC (bb, 0)->probability = REG_BR_PROB_BASE;\n+      EDGE_SUCC (bb, 0)->probability = profile_probability::guessed_always ();\n       ei = ei_start (bb->succs);\n       ei_next (&ei);\n       for (; (c = ei_safe_edge (ei)); ei_next (&ei))\n-\tc->probability = 0;\n+\tc->probability = profile_probability::guessed_never ();\n     }\n-  else if (prob != REG_BR_PROB_BASE)\n+  else if (!(prob == profile_probability::always ()))\n     {\n-      int scale = RDIV (65536 * REG_BR_PROB_BASE, prob);\n-\n       FOR_EACH_EDGE (c, ei, bb->succs)\n-\t{\n-\t  /* Protect from overflow due to additional scaling.  */\n-\t  if (c->probability > prob)\n-\t    c->probability = REG_BR_PROB_BASE;\n-\t  else\n-\t    {\n-\t      c->probability = RDIV (c->probability * scale, 65536);\n-\t      if (c->probability > REG_BR_PROB_BASE)\n-\t\tc->probability = REG_BR_PROB_BASE;\n-\t    }\n-\t}\n+\tc->probability /= prob;\n     }\n \n   gcc_assert (bb == taken_edge->src);\n-  if (taken_edge->count < count)\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \"edge %i->%i count became negative after threading\",\n-\t\t taken_edge->src->index, taken_edge->dest->index);\n-    }\n+  if (dump_file && taken_edge->count < count)\n+    fprintf (dump_file, \"edge %i->%i count became negative after threading\",\n+\t     taken_edge->src->index, taken_edge->dest->index);\n   taken_edge->count -= count;\n }\n "}, {"sha": "792ea62cc56e411105a49c26cd2c23dc28893917", "filename": "gcc/cfganal.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -610,7 +610,10 @@ connect_infinite_loops_to_exit (void)\n \tbreak;\n \n       basic_block deadend_block = dfs_find_deadend (unvisited_block);\n-      make_edge (deadend_block, EXIT_BLOCK_PTR_FOR_FN (cfun), EDGE_FAKE);\n+      edge e = make_edge (deadend_block, EXIT_BLOCK_PTR_FOR_FN (cfun),\n+\t\t\t  EDGE_FAKE);\n+      e->count = profile_count::zero ();\n+      e->probability = profile_probability::never ();\n       dfs.add_bb (deadend_block);\n     }\n }"}, {"sha": "56a2cb92860c68b601b0892a83bfb0ec5f06255b", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -545,10 +545,13 @@ compute_outgoing_frequencies (basic_block b)\n \t{\n \t  probability = XINT (note, 0);\n \t  e = BRANCH_EDGE (b);\n-\t  e->probability = probability;\n+\t  e->probability\n+\t\t = profile_probability::from_reg_br_prob_base (probability);\n \t  e->count = b->count.apply_probability (probability);\n \t  f = FALLTHRU_EDGE (b);\n-\t  f->probability = REG_BR_PROB_BASE - probability;\n+\t  f->probability\n+\t\t = profile_probability::from_reg_br_prob_base (REG_BR_PROB_BASE\n+\t\t\t\t\t\t\t       - probability);\n \t  f->count = b->count - e->count;\n \t  return;\n \t}\n@@ -560,7 +563,7 @@ compute_outgoing_frequencies (basic_block b)\n   else if (single_succ_p (b))\n     {\n       e = single_succ_edge (b);\n-      e->probability = REG_BR_PROB_BASE;\n+      e->probability = profile_probability::always ();\n       e->count = b->count;\n       return;\n     }\n@@ -656,7 +659,8 @@ find_many_sub_basic_blocks (sbitmap blocks)\n \t\t  }\n \t\telse\n \t\t  uninitialized_src = true;\n-\t\tbb->frequency += EDGE_FREQUENCY (e);\n+\t\tif (e->probability.initialized_p ())\n+\t\t  bb->frequency += EDGE_FREQUENCY (e);\n \t      }\n \t    /* When some edges are missing with read profile, this is\n \t       most likely because RTL expansion introduced loop."}, {"sha": "5d00fafffa307b7296f5dc1007cc25b0c76672ce", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -559,7 +559,7 @@ try_forward_edges (int mode, basic_block b)\n \t{\n \t  /* Save the values now, as the edge may get removed.  */\n \t  profile_count edge_count = e->count;\n-\t  int edge_probability = e->probability;\n+\t  profile_probability edge_probability = e->probability;\n \t  int edge_frequency;\n \t  int n = 0;\n \n@@ -585,7 +585,7 @@ try_forward_edges (int mode, basic_block b)\n \t  /* We successfully forwarded the edge.  Now update profile\n \t     data: for each edge we traversed in the chain, remove\n \t     the original edge's execution count.  */\n-\t  edge_frequency = apply_probability (b->frequency, edge_probability);\n+\t  edge_frequency = edge_probability.apply (b->frequency);\n \n \t  do\n \t    {\n@@ -1710,24 +1710,28 @@ outgoing_edges_match (int mode, basic_block bb1, basic_block bb2)\n \t  && optimize_bb_for_speed_p (bb1)\n \t  && optimize_bb_for_speed_p (bb2))\n \t{\n-\t  int prob2;\n+\t  profile_probability prob2;\n \n \t  if (b1->dest == b2->dest)\n \t    prob2 = b2->probability;\n \t  else\n \t    /* Do not use f2 probability as f2 may be forwarded.  */\n-\t    prob2 = REG_BR_PROB_BASE - b2->probability;\n+\t    prob2 = b2->probability.invert ();\n \n \t  /* Fail if the difference in probabilities is greater than 50%.\n \t     This rules out two well-predicted branches with opposite\n \t     outcomes.  */\n-\t  if (abs (b1->probability - prob2) > REG_BR_PROB_BASE / 2)\n+\t  if (b1->probability.differs_lot_from_p (prob2))\n \t    {\n \t      if (dump_file)\n-\t\tfprintf (dump_file,\n-\t\t\t \"Outcomes of branch in bb %i and %i differ too much (%i %i)\\n\",\n-\t\t\t bb1->index, bb2->index, b1->probability, prob2);\n-\n+\t\t{\n+\t\t  fprintf (dump_file,\n+\t\t\t   \"Outcomes of branch in bb %i and %i differ too\"\n+\t\t\t   \" much (\", bb1->index, bb2->index);\n+\t\t  b1->probability.dump (dump_file);\n+\t\t  prob2.dump (dump_file);\n+\t\t  fprintf (dump_file, \")\\n\");\n+\t\t}\n \t      return false;\n \t    }\n \t}\n@@ -2149,12 +2153,9 @@ try_crossjump_to_edge (int mode, edge e1, edge e2,\n \t}\n \n       if (!redirect_edges_to->frequency && !src1->frequency)\n-\ts->probability = (s->probability + s2->probability) / 2;\n-      else\n-\ts->probability\n-\t  = ((s->probability * redirect_edges_to->frequency +\n-\t      s2->probability * src1->frequency)\n-\t     / (redirect_edges_to->frequency + src1->frequency));\n+\ts->probability = s->probability.combine_with_freq\n+\t\t\t   (redirect_edges_to->frequency,\n+\t\t\t    s2->probability, src1->frequency);\n     }\n \n   /* Adjust count and frequency for the block.  An earlier jump"}, {"sha": "71662f21350bd80eca341af55ec8d1924d5ad36f", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -2389,7 +2389,6 @@ static basic_block\n expand_gimple_cond (basic_block bb, gcond *stmt)\n {\n   basic_block new_bb, dest;\n-  edge new_edge;\n   edge true_edge;\n   edge false_edge;\n   rtx_insn *last2, *last;\n@@ -2508,9 +2507,7 @@ expand_gimple_cond (basic_block bb, gcond *stmt)\n   if (loop->latch == bb\n       && loop->header == dest)\n     loop->latch = new_bb;\n-  new_edge = make_edge (new_bb, dest, 0);\n-  new_edge->probability = REG_BR_PROB_BASE;\n-  new_edge->count = new_bb->count;\n+  make_single_succ_edge (new_bb, dest, 0);\n   if (BARRIER_P (BB_END (new_bb)))\n     BB_END (new_bb) = PREV_INSN (BB_END (new_bb));\n   update_bb_for_insn (new_bb);\n@@ -3788,7 +3785,7 @@ expand_gimple_tailcall (basic_block bb, gcall *stmt, bool *can_fallthru)\n   rtx_insn *last2, *last;\n   edge e;\n   edge_iterator ei;\n-  int probability;\n+  profile_probability probability;\n \n   last2 = last = expand_gimple_stmt (stmt);\n \n@@ -3813,7 +3810,7 @@ expand_gimple_tailcall (basic_block bb, gcall *stmt, bool *can_fallthru)\n      all edges here, or redirecting the existing fallthru edge to\n      the exit block.  */\n \n-  probability = 0;\n+  probability = profile_probability::never ();\n   profile_count count = profile_count::zero ();\n \n   for (ei = ei_start (bb->succs); (e = ei_safe_edge (ei)); )\n@@ -5839,12 +5836,11 @@ construct_init_block (void)\n     {\n       first_block = e->dest;\n       redirect_edge_succ (e, init_block);\n-      e = make_edge (init_block, first_block, flags);\n+      e = make_single_succ_edge (init_block, first_block, flags);\n     }\n   else\n-    e = make_edge (init_block, EXIT_BLOCK_PTR_FOR_FN (cfun), EDGE_FALLTHRU);\n-  e->probability = REG_BR_PROB_BASE;\n-  e->count = ENTRY_BLOCK_PTR_FOR_FN (cfun)->count;\n+    e = make_single_succ_edge (init_block, EXIT_BLOCK_PTR_FOR_FN (cfun),\n+\t\t\t       EDGE_FALLTHRU);\n \n   update_bb_for_insn (init_block);\n   return init_block;\n@@ -5924,9 +5920,8 @@ construct_exit_block (void)\n \tix++;\n     }\n \n-  e = make_edge (exit_block, EXIT_BLOCK_PTR_FOR_FN (cfun), EDGE_FALLTHRU);\n-  e->probability = REG_BR_PROB_BASE;\n-  e->count = EXIT_BLOCK_PTR_FOR_FN (cfun)->count;\n+  e = make_single_succ_edge (exit_block, EXIT_BLOCK_PTR_FOR_FN (cfun),\n+\t\t\t     EDGE_FALLTHRU);\n   FOR_EACH_EDGE (e2, ei, EXIT_BLOCK_PTR_FOR_FN (cfun)->preds)\n     if (e2 != e)\n       {"}, {"sha": "18dc49a035e604b153a36b093d582513d7d19564", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -160,10 +160,10 @@ verify_flow_info (void)\n \t\t     e->src->index, e->dest->index);\n \t      err = 1;\n \t    }\n-\t  if (e->probability < 0 || e->probability > REG_BR_PROB_BASE)\n+\t  if (!e->probability.verify ())\n \t    {\n-\t      error (\"verify_flow_info: Wrong probability of edge %i->%i %i\",\n-\t\t     e->src->index, e->dest->index, e->probability);\n+\t      error (\"verify_flow_info: Wrong probability of edge %i->%i\",\n+\t\t     e->src->index, e->dest->index);\n \t      err = 1;\n \t    }\n \t  if (!e->count.verify ())\n@@ -443,8 +443,6 @@ redirect_edge_succ_nodup (edge e, basic_block new_succ)\n     {\n       s->flags |= e->flags;\n       s->probability += e->probability;\n-      if (s->probability > REG_BR_PROB_BASE)\n-\ts->probability = REG_BR_PROB_BASE;\n       s->count += e->count;\n       /* FIXME: This should be called via a hook and only for IR_GIMPLE.  */\n       redirect_edge_var_map_dup (s, e);\n@@ -640,7 +638,7 @@ split_edge (edge e)\n   ret = cfg_hooks->split_edge (e);\n   ret->count = count;\n   ret->frequency = freq;\n-  single_succ_edge (ret)->probability = REG_BR_PROB_BASE;\n+  single_succ_edge (ret)->probability = profile_probability::always ();\n   single_succ_edge (ret)->count = count;\n \n   if (irr)\n@@ -1451,17 +1449,17 @@ account_profile_record (struct profile_record *record, int after_pass)\n   basic_block bb;\n   edge_iterator ei;\n   edge e;\n-  int sum;\n \n   FOR_ALL_BB_FN (bb, cfun)\n    {\n       if (bb != EXIT_BLOCK_PTR_FOR_FN (cfun)\n \t  && profile_status_for_fn (cfun) != PROFILE_ABSENT)\n \t{\n-\t  sum = 0;\n+\t  profile_probability sum = profile_probability::never ();\n \t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t    sum += e->probability;\n-\t  if (EDGE_COUNT (bb->succs) && abs (sum - REG_BR_PROB_BASE) > 100)\n+\t  if (EDGE_COUNT (bb->succs)\n+\t      && sum.differs_from_p (profile_probability::always ()))\n \t    record->num_mismatched_freq_out[after_pass]++;\n \t  profile_count lsum = profile_count::zero ();\n \t  FOR_EACH_EDGE (e, ei, bb->succs)\n@@ -1472,7 +1470,7 @@ account_profile_record (struct profile_record *record, int after_pass)\n       if (bb != ENTRY_BLOCK_PTR_FOR_FN (cfun)\n \t  && profile_status_for_fn (cfun) != PROFILE_ABSENT)\n \t{\n-\t  sum = 0;\n+\t  int sum = 0;\n \t  FOR_EACH_EDGE (e, ei, bb->preds)\n \t    sum += EDGE_FREQUENCY (e);\n \t  if (abs (sum - bb->frequency) > 100"}, {"sha": "62e1c0084b88981902b3ae8c3e3927708bace050", "filename": "gcc/cfgloopanal.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fcfgloopanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fcfgloopanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopanal.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -477,7 +477,7 @@ single_likely_exit (struct loop *loop)\n          reasons.\n \t FIXME: Turn to likely_never_executed  */\n       if ((profile_status_for_fn (cfun) != PROFILE_ABSENT\n-\t   && ex->probability < 5)\n+\t   && ex->probability < profile_probability::from_reg_br_prob_base (5))\n \t  || ex->count == profile_count::zero ())\n \tcontinue;\n       if (!found)"}, {"sha": "f319026ae1659691f4effc33aadf9ecba6184481", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 18, "deletions": 49, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -542,8 +542,9 @@ scale_loop_profile (struct loop *loop, int scale, gcov_type iteration_bound)\n \n \t  /* Probability of exit must be 1/iterations.  */\n \t  freq_delta = EDGE_FREQUENCY (e);\n-\t  e->probability = REG_BR_PROB_BASE / iteration_bound;\n-\t  other_e->probability = inverse_probability (e->probability);\n+\t  e->probability = profile_probability::from_reg_br_prob_base\n+\t\t\t\t(REG_BR_PROB_BASE / iteration_bound);\n+\t  other_e->probability = e->probability.invert ();\n \t  freq_delta -= EDGE_FREQUENCY (e);\n \n \t  /* Adjust counts accordingly.  */\n@@ -1101,43 +1102,6 @@ can_duplicate_loop_p (const struct loop *loop)\n   return ret;\n }\n \n-/* Sets probability and count of edge E to zero.  The probability and count\n-   is redistributed evenly to the remaining edges coming from E->src.  */\n-\n-static void\n-set_zero_probability (edge e)\n-{\n-  basic_block bb = e->src;\n-  edge_iterator ei;\n-  edge ae, last = NULL;\n-  unsigned n = EDGE_COUNT (bb->succs);\n-  profile_count cnt = e->count, cnt1;\n-  unsigned prob = e->probability, prob1;\n-\n-  gcc_assert (n > 1);\n-  cnt1 = cnt.apply_scale (1, (n - 1));\n-  prob1 = prob / (n - 1);\n-\n-  FOR_EACH_EDGE (ae, ei, bb->succs)\n-    {\n-      if (ae == e)\n-\tcontinue;\n-\n-      ae->probability += prob1;\n-      ae->count += cnt1;\n-      last = ae;\n-    }\n-\n-  /* Move the rest to one of the edges.  */\n-  last->probability += prob % (n - 1);\n-  /* TODO: Remove once we have fractional counts.  */\n-  if (cnt.initialized_p ())\n-    last->count += profile_count::from_gcov_type (cnt.to_gcov_type () % (n - 1));\n-\n-  e->probability = 0;\n-  e->count = profile_count::zero ();\n-}\n-\n /* Duplicates body of LOOP to given edge E NDUPL times.  Takes care of updating\n    loop structure and dominators.  E's destination must be LOOP header for\n    this to work, i.e. it must be entry or latch edge of this loop; these are\n@@ -1224,14 +1188,18 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e,\n       prob_pass_wont_exit =\n \t      RDIV (REG_BR_PROB_BASE * (freq_le + freq_out_orig), freq_in);\n \n-      if (orig\n-\t  && REG_BR_PROB_BASE - orig->probability != 0)\n+      if (orig && orig->probability.initialized_p ()\n+\t  && !(orig->probability == profile_probability::always ()))\n \t{\n \t  /* The blocks that are dominated by a removed exit edge ORIG have\n \t     frequencies scaled by this.  */\n-\t  scale_after_exit\n-              = GCOV_COMPUTE_SCALE (REG_BR_PROB_BASE,\n-                                    REG_BR_PROB_BASE - orig->probability);\n+\t  if (orig->probability.initialized_p ())\n+\t    scale_after_exit\n+                = GCOV_COMPUTE_SCALE (REG_BR_PROB_BASE,\n+                                      REG_BR_PROB_BASE\n+\t\t\t\t      - orig->probability.to_reg_br_prob_base ());\n+\t  else\n+\t    scale_after_exit = REG_BR_PROB_BASE;\n \t  bbs_to_scale = BITMAP_ALLOC (NULL);\n \t  for (i = 0; i < n; i++)\n \t    {\n@@ -1387,7 +1355,7 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e,\n \t{\n \t  if (to_remove)\n \t    to_remove->safe_push (new_spec_edges[SE_ORIG]);\n-\t  set_zero_probability (new_spec_edges[SE_ORIG]);\n+\t  force_edge_cold (new_spec_edges[SE_ORIG], true);\n \n \t  /* Scale the frequencies of the blocks dominated by the exit.  */\n \t  if (bbs_to_scale)\n@@ -1423,7 +1391,7 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e,\n     {\n       if (to_remove)\n \tto_remove->safe_push (orig);\n-      set_zero_probability (orig);\n+      force_edge_cold (orig, true);\n \n       /* Scale the frequencies of the blocks dominated by the exit.  */\n       if (bbs_to_scale)\n@@ -1657,8 +1625,9 @@ force_single_succ_latches (void)\n \n static basic_block\n lv_adjust_loop_entry_edge (basic_block first_head, basic_block second_head,\n-\t\t\t   edge e, void *cond_expr, unsigned then_prob,\n-\t\t\t   unsigned else_prob)\n+\t\t\t   edge e, void *cond_expr,\n+\t\t\t   profile_probability then_prob,\n+\t\t\t   profile_probability else_prob)\n {\n   basic_block new_head = NULL;\n   edge e1;\n@@ -1713,7 +1682,7 @@ lv_adjust_loop_entry_edge (basic_block first_head, basic_block second_head,\n struct loop *\n loop_version (struct loop *loop,\n \t      void *cond_expr, basic_block *condition_bb,\n-\t      unsigned then_prob, unsigned else_prob,\n+\t      profile_probability then_prob, profile_probability else_prob,\n \t      unsigned then_scale, unsigned else_scale,\n \t      bool place_after)\n {"}, {"sha": "3c9536c8fc55dabc549aa856d9af7771b5c58583", "filename": "gcc/cfgloopmanip.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fcfgloopmanip.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fcfgloopmanip.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.h?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -58,7 +58,8 @@ basic_block create_preheader (struct loop *, int);\n extern void create_preheaders (int);\n extern void force_single_succ_latches (void);\n struct loop * loop_version (struct loop *, void *,\n-\t\t\t    basic_block *, unsigned, unsigned,\n+\t\t\t    basic_block *,\n+\t\t\t    profile_probability, profile_probability,\n \t\t\t    unsigned, unsigned, bool);\n \n #endif /* GCC_CFGLOOPMANIP_H */"}, {"sha": "f2a238c1d5d92fcbcb1cccb8f0a0829e646d7929", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 32, "deletions": 18, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -1155,7 +1155,7 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n   else\n     e->flags = 0;\n \n-  e->probability = REG_BR_PROB_BASE;\n+  e->probability = profile_probability::always ();\n   e->count = src->count;\n \n   if (e->dest != target)\n@@ -1504,12 +1504,10 @@ force_nonfallthru_and_redirect (edge e, basic_block target, rtx jump_label)\n \t{\n \t  int prob = XINT (note, 0);\n \n-\t  b->probability = prob;\n+\t  b->probability = profile_probability::from_reg_br_prob_base (prob);\n \t  b->count = e->count.apply_probability (prob);\n \t  e->probability -= e->probability;\n \t  e->count -= b->count;\n-\t  if (e->probability < 0)\n-\t    e->probability = 0;\n \t}\n     }\n \n@@ -1618,7 +1616,7 @@ force_nonfallthru_and_redirect (edge e, basic_block target, rtx jump_label)\n     {\n       rtx_insn *new_head;\n       profile_count count = e->count;\n-      int probability = e->probability;\n+      profile_probability probability = e->probability;\n       /* Create the new structures.  */\n \n       /* If the old block ended with a tablejump, skip its table\n@@ -1646,7 +1644,7 @@ force_nonfallthru_and_redirect (edge e, basic_block target, rtx jump_label)\n \n       /* Redirect old edge.  */\n       redirect_edge_pred (e, jump_block);\n-      e->probability = REG_BR_PROB_BASE;\n+      e->probability = profile_probability::always ();\n \n       /* If e->src was previously region crossing, it no longer is\n          and the reg crossing note should be removed.  */\n@@ -1656,7 +1654,7 @@ force_nonfallthru_and_redirect (edge e, basic_block target, rtx jump_label)\n \t add also edge from asm goto bb to target.  */\n       if (asm_goto_edge)\n \t{\n-\t  new_edge->probability /= 2;\n+\t  new_edge->probability = new_edge->probability.apply_scale (1, 2);\n \t  new_edge->count = new_edge->count.apply_scale (1, 2);\n \t  jump_block->count = jump_block->count.apply_scale (1, 2);\n \t  jump_block->frequency /= 2;\n@@ -2251,12 +2249,13 @@ void\n update_br_prob_note (basic_block bb)\n {\n   rtx note;\n-  if (!JUMP_P (BB_END (bb)))\n+  if (!JUMP_P (BB_END (bb)) || !BRANCH_EDGE (bb)->probability.initialized_p ())\n     return;\n   note = find_reg_note (BB_END (bb), REG_BR_PROB, NULL_RTX);\n-  if (!note || XINT (note, 0) == BRANCH_EDGE (bb)->probability)\n+  if (!note\n+      || XINT (note, 0) == BRANCH_EDGE (bb)->probability.to_reg_br_prob_base ())\n     return;\n-  XINT (note, 0) = BRANCH_EDGE (bb)->probability;\n+  XINT (note, 0) = BRANCH_EDGE (bb)->probability.to_reg_br_prob_base ();\n }\n \n /* Get the last insn associated with block BB (that includes barriers and\n@@ -2447,11 +2446,24 @@ rtl_verify_edges (void)\n \t  && EDGE_COUNT (bb->succs) >= 2\n \t  && any_condjump_p (BB_END (bb)))\n \t{\n-\t  if (XINT (note, 0) != BRANCH_EDGE (bb)->probability\n-\t      && profile_status_for_fn (cfun) != PROFILE_ABSENT)\n+\t  if (!BRANCH_EDGE (bb)->probability.initialized_p ())\n+\t    {\n+\t      /* FIXME: sometimes we create BBs with only branch edge\n+\t\t probability defined.  */\n+\t      if (0)\n+\t\t{\n+\t          error (\"verify_flow_info: \"\n+\t\t         \"REG_BR_PROB is set but cfg probability is not\");\n+\t          err = 1;\n+\t\t}\n+\t    }\n+\t  else if (XINT (note, 0)\n+\t           != BRANCH_EDGE (bb)->probability.to_reg_br_prob_base ()\n+\t           && profile_status_for_fn (cfun) != PROFILE_ABSENT)\n \t    {\n \t      error (\"verify_flow_info: REG_BR_PROB does not match cfg %i %i\",\n-\t\t     XINT (note, 0), BRANCH_EDGE (bb)->probability);\n+\t\t     XINT (note, 0),\n+\t\t     BRANCH_EDGE (bb)->probability.to_reg_br_prob_base ());\n \t      err = 1;\n \t    }\n \t}\n@@ -3143,7 +3155,7 @@ purge_dead_edges (basic_block bb)\n       /* Redistribute probabilities.  */\n       if (single_succ_p (bb))\n \t{\n-\t  single_succ_edge (bb)->probability = REG_BR_PROB_BASE;\n+\t  single_succ_edge (bb)->probability = profile_probability::always ();\n \t  single_succ_edge (bb)->count = bb->count;\n \t}\n       else\n@@ -3154,8 +3166,9 @@ purge_dead_edges (basic_block bb)\n \n \t  b = BRANCH_EDGE (bb);\n \t  f = FALLTHRU_EDGE (bb);\n-\t  b->probability = XINT (note, 0);\n-\t  f->probability = REG_BR_PROB_BASE - b->probability;\n+\t  b->probability = profile_probability::from_reg_br_prob_base\n+\t\t\t\t\t (XINT (note, 0));\n+\t  f->probability = profile_probability::always () - b->probability;\n \t  b->count = bb->count.apply_probability (b->probability);\n \t  f->count = bb->count.apply_probability (f->probability);\n \t}\n@@ -3208,7 +3221,7 @@ purge_dead_edges (basic_block bb)\n \n   gcc_assert (single_succ_p (bb));\n \n-  single_succ_edge (bb)->probability = REG_BR_PROB_BASE;\n+  single_succ_edge (bb)->probability = profile_probability::always ();\n   single_succ_edge (bb)->count = bb->count;\n \n   if (dump_file)\n@@ -4931,7 +4944,8 @@ rtl_lv_add_condition_to_bb (basic_block first_head ,\n   start_sequence ();\n   op0 = force_operand (op0, NULL_RTX);\n   op1 = force_operand (op1, NULL_RTX);\n-  do_compare_rtx_and_jump (op0, op1, comp, 0, mode, NULL_RTX, NULL, label, -1);\n+  do_compare_rtx_and_jump (op0, op1, comp, 0, mode, NULL_RTX, NULL, label,\n+\t\t\t   profile_probability::uninitialized ());\n   jump = get_last_insn ();\n   JUMP_LABEL (jump) = label;\n   LABEL_NUSES (label)++;"}, {"sha": "6711aeb828e70f0331c1071503ed232fcec0a855", "filename": "gcc/cgraph.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -20,8 +20,9 @@ along with GCC; see the file COPYING3.  If not see\n \n /*  This file contains basic routines manipulating call graph\n \n-    The call-graph is a data structure designed for intra-procedural optimization.\n-    It represents a multi-graph where nodes are functions and edges are call sites. */\n+    The call-graph is a data structure designed for inter-procedural\n+    optimization.  It represents a multi-graph where nodes are functions\n+    (symbols within symbol table) and edges are call sites. */\n \n #include \"config.h\"\n #include \"system.h\"\n@@ -1316,13 +1317,16 @@ cgraph_edge::redirect_call_stmt_to_callee (void)\n \t  push_cfun (DECL_STRUCT_FUNCTION (e->caller->decl));\n \t  new_stmt = gimple_ic (e->call_stmt,\n \t\t\t\tdyn_cast<cgraph_node *> (ref->referred),\n+\t\t\t\t/* FIXME: cleanup. */\n+\t\t\t\tprofile_probability::from_reg_br_prob_base (\n \t\t\t\te->count > profile_count::zero ()\n \t\t\t\t|| e2->count > profile_count::zero ()\n-\t\t\t\t? e->count.probability_in (e->count + e2->count)\n+\t\t\t\t? e->count.probability_in\n+\t\t\t\t   (e->count + e2->count).to_reg_br_prob_base ()\n \t\t\t\t: e->frequency || e2->frequency\n \t\t\t\t? RDIV (e->frequency * REG_BR_PROB_BASE,\n \t\t\t\t\te->frequency + e2->frequency)\n-\t\t\t\t: REG_BR_PROB_BASE / 2,\n+\t\t\t\t: REG_BR_PROB_BASE / 2),\n \t\t\t\te->count, e->count + e2->count);\n \t  e->speculative = false;\n \t  e->caller->set_call_stmt_including_clones (e->call_stmt, new_stmt,"}, {"sha": "a0d1f303b2a0c86bb8857cf1bc1bfc1e7911a584", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -1506,18 +1506,18 @@ init_lowered_empty_function (tree decl, bool in_ssa, profile_count count)\n \n   /* Create BB for body of the function and connect it properly.  */\n   ENTRY_BLOCK_PTR_FOR_FN (cfun)->count = count;\n-  ENTRY_BLOCK_PTR_FOR_FN (cfun)->frequency = REG_BR_PROB_BASE;\n+  ENTRY_BLOCK_PTR_FOR_FN (cfun)->frequency = BB_FREQ_MAX;\n   EXIT_BLOCK_PTR_FOR_FN (cfun)->count = count;\n-  EXIT_BLOCK_PTR_FOR_FN (cfun)->frequency = REG_BR_PROB_BASE;\n+  EXIT_BLOCK_PTR_FOR_FN (cfun)->frequency = BB_FREQ_MAX;\n   bb = create_basic_block (NULL, ENTRY_BLOCK_PTR_FOR_FN (cfun));\n   bb->count = count;\n   bb->frequency = BB_FREQ_MAX;\n   e = make_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun), bb, EDGE_FALLTHRU);\n   e->count = count;\n-  e->probability = REG_BR_PROB_BASE;\n+  e->probability = profile_probability::always ();\n   e = make_edge (bb, EXIT_BLOCK_PTR_FOR_FN (cfun), 0);\n   e->count = count;\n-  e->probability = REG_BR_PROB_BASE;\n+  e->probability = profile_probability::always ();\n   add_bb_to_loop (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun)->loop_father);\n \n   return bb;\n@@ -1891,19 +1891,18 @@ cgraph_node::expand_thunk (bool output_asm_thunks, bool force_gimple_thunk)\n \t\t\t\t\t    NULL_TREE, NULL_TREE);\n \t\t  gsi_insert_after (&bsi, stmt, GSI_NEW_STMT);\n \t\t  e = make_edge (bb, then_bb, EDGE_TRUE_VALUE);\n-\t\t  e->probability = REG_BR_PROB_BASE - REG_BR_PROB_BASE / 16;\n+\t\t  e->probability = profile_probability::guessed_always ()\n+\t\t\t\t\t.apply_scale (1, 16);\n \t\t  e->count = count - count.apply_scale (1, 16);\n \t\t  e = make_edge (bb, else_bb, EDGE_FALSE_VALUE);\n-\t\t  e->probability = REG_BR_PROB_BASE / 16;\n+\t\t  e->probability = profile_probability::guessed_always ()\n+\t\t\t\t\t.apply_scale (1, 16);\n \t\t  e->count = count.apply_scale (1, 16);\n-\t\t  e = make_edge (return_bb, EXIT_BLOCK_PTR_FOR_FN (cfun), 0);\n-\t\t  e->probability = REG_BR_PROB_BASE;\n-\t\t  e->count = count;\n-\t\t  e = make_edge (then_bb, return_bb, EDGE_FALLTHRU);\n-\t\t  e->probability = REG_BR_PROB_BASE;\n-\t\t  e->count = count - count.apply_scale (1, 16);\n+\t\t  make_single_succ_edge (return_bb,\n+\t\t\t\t\t EXIT_BLOCK_PTR_FOR_FN (cfun), 0);\n+\t\t  make_single_succ_edge (then_bb, return_bb, EDGE_FALLTHRU);\n \t\t  e = make_edge (else_bb, return_bb, EDGE_FALLTHRU);\n-\t\t  e->probability = REG_BR_PROB_BASE;\n+\t\t  e->probability = profile_probability::always ();\n \t\t  e->count = count.apply_scale (1, 16);\n \t\t  bsi = gsi_last_bb (then_bb);\n \t\t}"}, {"sha": "edde47118697bb4832f7634819715a2dd8d9ccbd", "filename": "gcc/cilk-common.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fcilk-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fcilk-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcilk-common.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -38,6 +38,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stor-layout.h\"\n #include \"langhooks.h\"\n #include \"explow.h\"\n+#include \"profile-count.h\"\n #include \"expr.h\"\n #include \"tree-iterator.h\"\n #include \"gimplify.h\""}, {"sha": "772268084fa490355b55ede857abdb1a560a0c9d", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -8699,7 +8699,7 @@ into separate sections of the assembly and @file{.o} files, to improve\n paging and cache locality performance.\n \n This optimization is automatically turned off in the presence of\n-exception handling, for linkonce sections, for functions with a user-defined\n+exception handling or unwind tables (on targets using setjump/longjump or target specific scheme), for linkonce sections, for functions with a user-defined\n section attribute and on any architecture that does not support named\n sections.  When @option{-fsplit-stack} is used this option is not\n enabled by default (to avoid linker errors), but may be enabled"}, {"sha": "7a389663ab4cbce234f4777a05daa24bc9a810a3", "filename": "gcc/dojump.c", "status": "modified", "additions": 66, "deletions": 61, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fdojump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fdojump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -39,19 +39,13 @@ along with GCC; see the file COPYING3.  If not see\n \n static bool prefer_and_bit_test (machine_mode, int);\n static void do_jump_by_parts_greater (tree, tree, int,\n-\t\t\t\t      rtx_code_label *, rtx_code_label *, int);\n+\t\t\t\t      rtx_code_label *, rtx_code_label *,\n+\t\t\t\t      profile_probability);\n static void do_jump_by_parts_equality (tree, tree, rtx_code_label *,\n-\t\t\t\t       rtx_code_label *, int);\n+\t\t\t\t       rtx_code_label *, profile_probability);\n static void do_compare_and_jump\t(tree, tree, enum rtx_code, enum rtx_code,\n-\t\t\t\t rtx_code_label *, rtx_code_label *, int);\n-\n-/* Invert probability if there is any.  -1 stands for unknown.  */\n-\n-static inline int\n-inv (int prob)\n-{\n-  return prob == -1 ? -1 : REG_BR_PROB_BASE - prob;\n-}\n+\t\t\t\t rtx_code_label *, rtx_code_label *,\n+\t\t\t\t profile_probability);\n \n /* At the start of a function, record that we have no previously-pushed\n    arguments waiting to be popped.  */\n@@ -128,29 +122,29 @@ restore_pending_stack_adjust (saved_pending_stack_adjust *save)\n /* Generate code to evaluate EXP and jump to LABEL if the value is zero.  */\n \n void\n-jumpifnot (tree exp, rtx_code_label *label, int prob)\n+jumpifnot (tree exp, rtx_code_label *label, profile_probability prob)\n {\n-  do_jump (exp, label, NULL, inv (prob));\n+  do_jump (exp, label, NULL, prob.invert ());\n }\n \n void\n jumpifnot_1 (enum tree_code code, tree op0, tree op1, rtx_code_label *label,\n-\t     int prob)\n+\t     profile_probability prob)\n {\n-  do_jump_1 (code, op0, op1, label, NULL, inv (prob));\n+  do_jump_1 (code, op0, op1, label, NULL, prob.invert ());\n }\n \n /* Generate code to evaluate EXP and jump to LABEL if the value is nonzero.  */\n \n void\n-jumpif (tree exp, rtx_code_label *label, int prob)\n+jumpif (tree exp, rtx_code_label *label, profile_probability prob)\n {\n   do_jump (exp, NULL, label, prob);\n }\n \n void\n jumpif_1 (enum tree_code code, tree op0, tree op1,\n-\t  rtx_code_label *label, int prob)\n+\t  rtx_code_label *label, profile_probability prob)\n {\n   do_jump_1 (code, op0, op1, NULL, label, prob);\n }\n@@ -200,12 +194,12 @@ prefer_and_bit_test (machine_mode mode, int bitnum)\n \n /* Subroutine of do_jump, dealing with exploded comparisons of the type\n    OP0 CODE OP1 .  IF_FALSE_LABEL and IF_TRUE_LABEL like in do_jump.\n-   PROB is probability of jump to if_true_label, or -1 if unknown.  */\n+   PROB is probability of jump to if_true_label.  */\n \n void\n do_jump_1 (enum tree_code code, tree op0, tree op1,\n \t   rtx_code_label *if_false_label, rtx_code_label *if_true_label,\n-\t   int prob)\n+\t   profile_probability prob)\n {\n   machine_mode mode;\n   rtx_code_label *drop_through_label = 0;\n@@ -222,7 +216,8 @@ do_jump_1 (enum tree_code code, tree op0, tree op1,\n \t\t    != MODE_COMPLEX_INT);\n \n         if (integer_zerop (op1))\n-\t  do_jump (op0, if_true_label, if_false_label, inv (prob));\n+\t  do_jump (op0, if_true_label, if_false_label,\n+\t\t   prob.invert ());\n         else if (GET_MODE_CLASS (TYPE_MODE (inner_type)) == MODE_INT\n                  && !can_compare_p (EQ, TYPE_MODE (inner_type), ccp_jump))\n \t  do_jump_by_parts_equality (op0, op1, if_false_label, if_true_label,\n@@ -247,7 +242,7 @@ do_jump_1 (enum tree_code code, tree op0, tree op1,\n         else if (GET_MODE_CLASS (TYPE_MODE (inner_type)) == MODE_INT\n            && !can_compare_p (NE, TYPE_MODE (inner_type), ccp_jump))\n \t  do_jump_by_parts_equality (op0, op1, if_true_label, if_false_label,\n-\t\t\t\t     inv (prob));\n+\t\t\t\t     prob.invert ());\n         else\n \t  do_compare_and_jump (op0, op1, NE, NE, if_false_label, if_true_label,\n \t\t\t       prob);\n@@ -270,7 +265,7 @@ do_jump_1 (enum tree_code code, tree op0, tree op1,\n       if (GET_MODE_CLASS (mode) == MODE_INT\n           && ! can_compare_p (LE, mode, ccp_jump))\n \tdo_jump_by_parts_greater (op0, op1, 0, if_true_label, if_false_label,\n-\t\t\t\t  inv (prob));\n+\t\t\t\t  prob.invert ());\n       else\n \tdo_compare_and_jump (op0, op1, LE, LEU, if_false_label, if_true_label,\n \t\t\t     prob);\n@@ -292,7 +287,7 @@ do_jump_1 (enum tree_code code, tree op0, tree op1,\n       if (GET_MODE_CLASS (mode) == MODE_INT\n           && ! can_compare_p (GE, mode, ccp_jump))\n \tdo_jump_by_parts_greater (op0, op1, 1, if_true_label, if_false_label,\n-\t\t\t\t  inv (prob));\n+\t\t\t\t  prob.invert ());\n       else\n \tdo_compare_and_jump (op0, op1, GE, GEU, if_false_label, if_true_label,\n \t\t\t     prob);\n@@ -346,17 +341,17 @@ do_jump_1 (enum tree_code code, tree op0, tree op1,\n            half of the total probability of being false, so its jump has a false\n            probability of half the total, relative to the probability we\n            reached it (i.e. the first condition was true).  */\n-        int op0_prob = -1;\n-        int op1_prob = -1;\n-        if (prob != -1)\n+        profile_probability op0_prob = profile_probability::uninitialized ();\n+        profile_probability op1_prob = profile_probability::uninitialized ();\n+        if (prob.initialized_p ())\n           {\n-            int false_prob = inv (prob);\n-            int op0_false_prob = false_prob / 2;\n-            int op1_false_prob = GCOV_COMPUTE_SCALE ((false_prob / 2),\n-                                                     inv (op0_false_prob));\n+            profile_probability false_prob = prob.invert ();\n+            profile_probability op0_false_prob = false_prob.apply_scale (1, 2);\n+\t    profile_probability op1_false_prob = false_prob.apply_scale (1, 2)\n+\t\t\t\t/ op0_false_prob.invert ();\n             /* Get the probability that each jump below is true.  */\n-            op0_prob = inv (op0_false_prob);\n-            op1_prob = inv (op1_false_prob);\n+            op0_prob = op0_false_prob.invert ();\n+            op1_prob = op1_false_prob.invert ();\n           }\n \tif (if_false_label == NULL)\n           {\n@@ -379,12 +374,12 @@ do_jump_1 (enum tree_code code, tree op0, tree op1,\n            The second condition has the other half of the total probability,\n            so its jump has a probability of half the total, relative to\n            the probability we reached it (i.e. the first condition was false).  */\n-        int op0_prob = -1;\n-        int op1_prob = -1;\n-        if (prob != -1)\n+        profile_probability op0_prob = profile_probability::uninitialized ();\n+        profile_probability op1_prob = profile_probability::uninitialized ();\n+        if (prob.initialized_p ())\n           {\n-            op0_prob = prob / 2;\n-            op1_prob = GCOV_COMPUTE_SCALE ((prob / 2), inv (op0_prob));\n+            op0_prob = prob.apply_scale (1, 2);\n+            op1_prob = prob.apply_scale (1, 2) / op0_prob.invert ();\n \t  }\n \tif (if_true_label == NULL)\n \t  {\n@@ -420,11 +415,11 @@ do_jump_1 (enum tree_code code, tree op0, tree op1,\n    actually perform a jump.  An example where there is no jump\n    is when EXP is `(foo (), 0)' and IF_FALSE_LABEL is null.\n \n-   PROB is probability of jump to if_true_label, or -1 if unknown.  */\n+   PROB is probability of jump to if_true_label.  */\n \n void\n do_jump (tree exp, rtx_code_label *if_false_label,\n-\t rtx_code_label *if_true_label, int prob)\n+\t rtx_code_label *if_true_label, profile_probability prob)\n {\n   enum tree_code code = TREE_CODE (exp);\n   rtx temp;\n@@ -481,7 +476,7 @@ do_jump (tree exp, rtx_code_label *if_false_label,\n \n     case TRUTH_NOT_EXPR:\n       do_jump (TREE_OPERAND (exp, 0), if_true_label, if_false_label,\n-\t       inv (prob));\n+\t       prob.invert ());\n       break;\n \n     case COND_EXPR:\n@@ -497,7 +492,8 @@ do_jump (tree exp, rtx_code_label *if_false_label,\n \t  }\n \n         do_pending_stack_adjust ();\n-\tdo_jump (TREE_OPERAND (exp, 0), label1, NULL, -1);\n+\tdo_jump (TREE_OPERAND (exp, 0), label1, NULL,\n+\t\t profile_probability::uninitialized ());\n \tdo_jump (TREE_OPERAND (exp, 1), if_false_label, if_true_label, prob);\n         emit_label (label1);\n \tdo_jump (TREE_OPERAND (exp, 2), if_false_label, if_true_label, prob);\n@@ -542,7 +538,7 @@ do_jump (tree exp, rtx_code_label *if_false_label,\n \t{\n \t  tree exp0 = TREE_OPERAND (exp, 0);\n \t  rtx_code_label *set_label, *clr_label;\n-\t  int setclr_prob = prob;\n+\t  profile_probability setclr_prob = prob;\n \n \t  /* Strip narrowing integral type conversions.  */\n \t  while (CONVERT_EXPR_P (exp0)\n@@ -558,7 +554,7 @@ do_jump (tree exp, rtx_code_label *if_false_label,\n \t      exp0 = TREE_OPERAND (exp0, 0);\n \t      clr_label = if_true_label;\n \t      set_label = if_false_label;\n-\t      setclr_prob = inv (prob);\n+\t      setclr_prob = prob.invert ();\n \t    }\n \t  else\n \t    {\n@@ -673,7 +669,7 @@ static void\n do_jump_by_parts_greater_rtx (machine_mode mode, int unsignedp, rtx op0,\n \t\t\t      rtx op1, rtx_code_label *if_false_label,\n \t\t\t      rtx_code_label *if_true_label,\n-\t\t\t      int prob)\n+\t\t\t      profile_probability prob)\n {\n   int nwords = (GET_MODE_SIZE (mode) / UNITS_PER_WORD);\n   rtx_code_label *drop_through_label = 0;\n@@ -703,7 +699,7 @@ do_jump_by_parts_greater_rtx (machine_mode mode, int unsignedp, rtx op0,\n       if_false_label = drop_through_label;\n       drop_through_if_true = false;\n       drop_through_if_false = true;\n-      prob = inv (prob);\n+      prob = prob.invert ();\n     }\n \n   /* Compare a word at a time, high order first.  */\n@@ -733,7 +729,8 @@ do_jump_by_parts_greater_rtx (machine_mode mode, int unsignedp, rtx op0,\n \n       /* Consider lower words only if these are equal.  */\n       do_compare_rtx_and_jump (op0_word, op1_word, NE, unsignedp, word_mode,\n-\t\t\t       NULL_RTX, NULL, if_false_label, inv (prob));\n+\t\t\t       NULL_RTX, NULL, if_false_label,\n+\t\t\t       prob.invert ());\n     }\n \n   if (!drop_through_if_false)\n@@ -750,7 +747,8 @@ do_jump_by_parts_greater_rtx (machine_mode mode, int unsignedp, rtx op0,\n static void\n do_jump_by_parts_greater (tree treeop0, tree treeop1, int swap,\n \t\t\t  rtx_code_label *if_false_label,\n-\t\t\t  rtx_code_label *if_true_label, int prob)\n+\t\t\t  rtx_code_label *if_true_label,\n+\t\t\t  profile_probability prob)\n {\n   rtx op0 = expand_normal (swap ? treeop1 : treeop0);\n   rtx op1 = expand_normal (swap ? treeop0 : treeop1);\n@@ -769,7 +767,8 @@ do_jump_by_parts_greater (tree treeop0, tree treeop1, int swap,\n static void\n do_jump_by_parts_zero_rtx (machine_mode mode, rtx op0,\n \t\t\t   rtx_code_label *if_false_label,\n-\t\t\t   rtx_code_label *if_true_label, int prob)\n+\t\t\t   rtx_code_label *if_true_label,\n+\t\t\t   profile_probability prob)\n {\n   int nwords = GET_MODE_SIZE (mode) / UNITS_PER_WORD;\n   rtx part;\n@@ -819,7 +818,8 @@ do_jump_by_parts_zero_rtx (machine_mode mode, rtx op0,\n static void\n do_jump_by_parts_equality_rtx (machine_mode mode, rtx op0, rtx op1,\n \t\t\t       rtx_code_label *if_false_label,\n-\t\t\t       rtx_code_label *if_true_label, int prob)\n+\t\t\t       rtx_code_label *if_true_label,\n+\t\t\t       profile_probability prob)\n {\n   int nwords = (GET_MODE_SIZE (mode) / UNITS_PER_WORD);\n   rtx_code_label *drop_through_label = NULL;\n@@ -859,7 +859,8 @@ do_jump_by_parts_equality_rtx (machine_mode mode, rtx op0, rtx op1,\n static void\n do_jump_by_parts_equality (tree treeop0, tree treeop1,\n \t\t\t   rtx_code_label *if_false_label,\n-\t\t\t   rtx_code_label *if_true_label, int prob)\n+\t\t\t   rtx_code_label *if_true_label,\n+\t\t\t   profile_probability prob)\n {\n   rtx op0 = expand_normal (treeop0);\n   rtx op1 = expand_normal (treeop1);\n@@ -956,7 +957,8 @@ void\n do_compare_rtx_and_jump (rtx op0, rtx op1, enum rtx_code code, int unsignedp,\n \t\t\t machine_mode mode, rtx size,\n \t\t\t rtx_code_label *if_false_label,\n-\t\t\t rtx_code_label *if_true_label, int prob)\n+\t\t\t rtx_code_label *if_true_label,\n+\t\t\t profile_probability prob)\n {\n   rtx tem;\n   rtx_code_label *dummy_label = NULL;\n@@ -983,7 +985,7 @@ do_compare_rtx_and_jump (rtx op0, rtx op1, enum rtx_code code, int unsignedp,\n \t{\n \t  std::swap (if_true_label, if_false_label);\n \t  code = rcode;\n-\t  prob = inv (prob);\n+\t  prob = prob.invert ();\n \t}\n     }\n \n@@ -1035,7 +1037,7 @@ do_compare_rtx_and_jump (rtx op0, rtx op1, enum rtx_code code, int unsignedp,\n \tcase LEU:\n \t  do_jump_by_parts_greater_rtx (mode, 1, op0, op1,\n \t\t\t\t\tif_true_label, if_false_label,\n-\t\t\t\t\tinv (prob));\n+\t\t\t\t\tprob.invert ());\n \t  break;\n \n \tcase GTU:\n@@ -1046,7 +1048,7 @@ do_compare_rtx_and_jump (rtx op0, rtx op1, enum rtx_code code, int unsignedp,\n \tcase GEU:\n \t  do_jump_by_parts_greater_rtx (mode, 1, op1, op0,\n \t\t\t\t\tif_true_label, if_false_label,\n-\t\t\t\t\tinv (prob));\n+\t\t\t\t\tprob.invert ());\n \t  break;\n \n \tcase LT:\n@@ -1057,7 +1059,7 @@ do_compare_rtx_and_jump (rtx op0, rtx op1, enum rtx_code code, int unsignedp,\n \tcase LE:\n \t  do_jump_by_parts_greater_rtx (mode, 0, op0, op1,\n \t\t\t\t\tif_true_label, if_false_label,\n-\t\t\t\t\tinv (prob));\n+\t\t\t\t\tprob.invert ());\n \t  break;\n \n \tcase GT:\n@@ -1068,7 +1070,7 @@ do_compare_rtx_and_jump (rtx op0, rtx op1, enum rtx_code code, int unsignedp,\n \tcase GE:\n \t  do_jump_by_parts_greater_rtx (mode, 0, op1, op0,\n \t\t\t\t\tif_true_label, if_false_label,\n-\t\t\t\t\tinv (prob));\n+\t\t\t\t\tprob.invert ());\n \t  break;\n \n \tcase EQ:\n@@ -1078,7 +1080,8 @@ do_compare_rtx_and_jump (rtx op0, rtx op1, enum rtx_code code, int unsignedp,\n \n \tcase NE:\n \t  do_jump_by_parts_equality_rtx (mode, op0, op1, if_true_label,\n-\t\t\t\t\t if_false_label, inv (prob));\n+\t\t\t\t\t if_false_label,\n+\t\t\t\t\t prob.invert ());\n \t  break;\n \n \tdefault:\n@@ -1115,11 +1118,13 @@ do_compare_rtx_and_jump (rtx op0, rtx op1, enum rtx_code code, int unsignedp,\n \n \t  else\n \t    {\n-\t      int first_prob = prob;\n+\t      profile_probability first_prob = prob;\n \t      if (first_code == UNORDERED)\n-\t\tfirst_prob = REG_BR_PROB_BASE / 100;\n+\t\tfirst_prob = profile_probability::guessed_always ().apply_scale\n+\t\t\t\t (1, 100);\n \t      else if (first_code == ORDERED)\n-\t\tfirst_prob = REG_BR_PROB_BASE - REG_BR_PROB_BASE / 100;\n+\t\tfirst_prob = profile_probability::guessed_always ().apply_scale\n+\t\t\t\t (99, 100);\n \t      if (and_them)\n \t\t{\n \t\t  rtx_code_label *dest_label;\n@@ -1165,7 +1170,7 @@ static void\n do_compare_and_jump (tree treeop0, tree treeop1, enum rtx_code signed_code,\n \t\t     enum rtx_code unsigned_code,\n \t\t     rtx_code_label *if_false_label,\n-\t\t     rtx_code_label *if_true_label, int prob)\n+\t\t     rtx_code_label *if_true_label, profile_probability prob)\n {\n   rtx op0, op1;\n   tree type;"}, {"sha": "ca6df449f74e6526e486b8f2c5e505956ca29e06", "filename": "gcc/dojump.h", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fdojump.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fdojump.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.h?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -57,23 +57,26 @@ extern void save_pending_stack_adjust (saved_pending_stack_adjust *);\n extern void restore_pending_stack_adjust (saved_pending_stack_adjust *);\n \n /* Generate code to evaluate EXP and jump to LABEL if the value is zero.  */\n-extern void jumpifnot (tree exp, rtx_code_label *label, int prob);\n-extern void jumpifnot_1 (enum tree_code, tree, tree, rtx_code_label *, int);\n+extern void jumpifnot (tree exp, rtx_code_label *label,\n+\t\t       profile_probability prob);\n+extern void jumpifnot_1 (enum tree_code, tree, tree, rtx_code_label *,\n+\t\t\t profile_probability);\n \n /* Generate code to evaluate EXP and jump to LABEL if the value is nonzero.  */\n-extern void jumpif (tree exp, rtx_code_label *label, int prob);\n-extern void jumpif_1 (enum tree_code, tree, tree, rtx_code_label *, int);\n+extern void jumpif (tree exp, rtx_code_label *label, profile_probability prob);\n+extern void jumpif_1 (enum tree_code, tree, tree, rtx_code_label *,\n+\t\t      profile_probability);\n \n /* Generate code to evaluate EXP and jump to IF_FALSE_LABEL if\n    the result is zero, or IF_TRUE_LABEL if the result is one.  */\n extern void do_jump (tree exp, rtx_code_label *if_false_label,\n-\t\t     rtx_code_label *if_true_label, int prob);\n+\t\t     rtx_code_label *if_true_label, profile_probability prob);\n extern void do_jump_1 (enum tree_code, tree, tree, rtx_code_label *,\n-\t\t       rtx_code_label *, int);\n+\t\t       rtx_code_label *, profile_probability);\n \n extern void do_compare_rtx_and_jump (rtx, rtx, enum rtx_code, int,\n \t\t\t\t     machine_mode, rtx, rtx_code_label *,\n-\t\t\t\t     rtx_code_label *, int);\n+\t\t\t\t     rtx_code_label *, profile_probability);\n \n extern bool split_comparison (enum rtx_code, machine_mode,\n \t\t\t      enum rtx_code *, enum rtx_code *);"}, {"sha": "a5f9832fc4a85635684c2f2d75be70357d74d2ae", "filename": "gcc/dwarf2cfi.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fdwarf2cfi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fdwarf2cfi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2cfi.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -35,6 +35,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"common/common-target.h\"\n \n #include \"except.h\"\t\t/* expand_builtin_dwarf_sp_column */\n+#include \"profile-count.h\"\t/* For expr.h */\n #include \"expr.h\"\t\t/* init_return_column_size */\n #include \"output.h\"\t\t/* asm_out_file */\n #include \"debug.h\"\t\t/* dwarf2out_do_frame, dwarf2out_do_cfi_asm */"}, {"sha": "4ec2f82eb1f42eb63b2515fd180365d8c59c8004", "filename": "gcc/except.c", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -974,7 +974,6 @@ dw2_build_landing_pads (void)\n     {\n       basic_block bb;\n       rtx_insn *seq;\n-      edge e;\n \n       if (lp == NULL || lp->post_landing_pad == NULL)\n \tcontinue;\n@@ -991,9 +990,7 @@ dw2_build_landing_pads (void)\n       end_sequence ();\n \n       bb = emit_to_new_bb_before (seq, label_rtx (lp->post_landing_pad));\n-      e = make_edge (bb, bb->next_bb, e_flags);\n-      e->count = bb->count;\n-      e->probability = REG_BR_PROB_BASE;\n+      make_single_succ_edge (bb, bb->next_bb, e_flags);\n       if (current_loops)\n \t{\n \t  struct loop *loop = bb->next_bb->loop_father;\n@@ -1258,7 +1255,6 @@ sjlj_emit_dispatch_table (rtx_code_label *dispatch_label, int num_dispatch)\n   rtx_insn *seq;\n   basic_block bb;\n   eh_region r;\n-  edge e;\n   int i, disp_index;\n   vec<tree> dispatch_labels = vNULL;\n \n@@ -1346,9 +1342,7 @@ sjlj_emit_dispatch_table (rtx_code_label *dispatch_label, int num_dispatch)\n \n \trtx_insn *before = label_rtx (lp->post_landing_pad);\n \tbb = emit_to_new_bb_before (seq2, before);\n-\te = make_edge (bb, bb->next_bb, EDGE_FALLTHRU);\n-\te->count = bb->count;\n-\te->probability = REG_BR_PROB_BASE;\n+\tmake_single_succ_edge (bb, bb->next_bb, EDGE_FALLTHRU);\n \tif (current_loops)\n \t  {\n \t    struct loop *loop = bb->next_bb->loop_father;\n@@ -1386,9 +1380,7 @@ sjlj_emit_dispatch_table (rtx_code_label *dispatch_label, int num_dispatch)\n   bb = emit_to_new_bb_before (seq, first_reachable_label);\n   if (num_dispatch == 1)\n     {\n-      e = make_edge (bb, bb->next_bb, EDGE_FALLTHRU);\n-      e->count = bb->count;\n-      e->probability = REG_BR_PROB_BASE;\n+      make_single_succ_edge (bb, bb->next_bb, EDGE_FALLTHRU);\n       if (current_loops)\n \t{\n \t  struct loop *loop = bb->next_bb->loop_father;"}, {"sha": "50074e281edd5270c76d29feac6b7a92f598d11d", "filename": "gcc/explow.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -28,6 +28,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"memmodel.h\"\n #include \"tm_p.h\"\n #include \"expmed.h\"\n+#include \"profile-count.h\"\n #include \"optabs.h\"\n #include \"emit-rtl.h\"\n #include \"recog.h\""}, {"sha": "fe23066fc26da4f3d77bdf725df3ba717c4a5762", "filename": "gcc/expmed.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -5905,7 +5905,8 @@ emit_store_flag_force (rtx target, enum rtx_code code, rtx op0, rtx op1,\n     {\n       label = gen_label_rtx ();\n       do_compare_rtx_and_jump (target, const0_rtx, EQ, unsignedp, mode,\n-\t\t\t       NULL_RTX, NULL, label, -1);\n+\t\t\t       NULL_RTX, NULL, label,\n+\t\t\t       profile_probability::uninitialized ());\n       emit_move_insn (target, trueval);\n       emit_label (label);\n       return target;\n@@ -5943,7 +5944,7 @@ emit_store_flag_force (rtx target, enum rtx_code code, rtx op0, rtx op1,\n   emit_move_insn (target, trueval);\n   label = gen_label_rtx ();\n   do_compare_rtx_and_jump (op0, op1, code, unsignedp, mode, NULL_RTX, NULL,\n-\t\t\t   label, -1);\n+\t\t\t   label, profile_probability::uninitialized ());\n \n   emit_move_insn (target, falseval);\n   emit_label (label);\n@@ -5961,5 +5962,5 @@ do_cmp_and_jump (rtx arg1, rtx arg2, enum rtx_code op, machine_mode mode,\n {\n   int unsignedp = (op == LTU || op == LEU || op == GTU || op == GEU);\n   do_compare_rtx_and_jump (arg1, arg2, op, unsignedp, mode, NULL_RTX,\n-\t\t\t   NULL, label, -1);\n+\t\t\t   NULL, label, profile_probability::uninitialized ());\n }"}, {"sha": "753f5efde6c7eaee14a85b65f9f525ca88138940", "filename": "gcc/expr.c", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -96,7 +96,8 @@ static rtx do_store_flag (sepops, rtx, machine_mode);\n #ifdef PUSH_ROUNDING\n static void emit_single_push_insn (machine_mode, rtx, tree);\n #endif\n-static void do_tablejump (rtx, machine_mode, rtx, rtx, rtx, int);\n+static void do_tablejump (rtx, machine_mode, rtx, rtx, rtx,\n+\t\t\t  profile_probability);\n static rtx const_vector_from_tree (tree);\n static rtx const_scalar_mask_from_tree (tree);\n static tree tree_expr_size (const_tree);\n@@ -1452,7 +1453,7 @@ compare_by_pieces_d::generate (rtx op0, rtx op1, machine_mode mode)\n       m_accumulator = NULL_RTX;\n     }\n   do_compare_rtx_and_jump (op0, op1, NE, true, mode, NULL_RTX, NULL,\n-\t\t\t   m_fail_label, -1);\n+\t\t\t   m_fail_label, profile_probability::uninitialized ());\n }\n \n /* Return true if MODE can be used for a set of moves and comparisons,\n@@ -1484,7 +1485,8 @@ compare_by_pieces_d::finish_mode (machine_mode mode)\n {\n   if (m_accumulator != NULL_RTX)\n     do_compare_rtx_and_jump (m_accumulator, const0_rtx, NE, true, mode,\n-\t\t\t     NULL_RTX, NULL, m_fail_label, -1);\n+\t\t\t     NULL_RTX, NULL, m_fail_label,\n+\t\t\t     profile_probability::uninitialized ());\n }\n \n /* Generate several move instructions to compare LEN bytes from blocks\n@@ -1845,7 +1847,9 @@ emit_block_move_via_loop (rtx x, rtx y, rtx size,\n   emit_label (cmp_label);\n \n   emit_cmp_and_jump_insns (iter, size, LT, NULL_RTX, iter_mode,\n-\t\t\t   true, top_label, REG_BR_PROB_BASE * 90 / 100);\n+\t\t\t   true, top_label,\n+\t\t\t   profile_probability::guessed_always ()\n+\t\t\t\t.apply_scale (9, 10));\n }\n \f\n /* Expand a call to memcpy or memmove or memcmp, and return the result.\n@@ -5402,7 +5406,8 @@ store_expr_with_bounds (tree exp, rtx target, int call_param_p,\n \n       do_pending_stack_adjust ();\n       NO_DEFER_POP;\n-      jumpifnot (TREE_OPERAND (exp, 0), lab1, -1);\n+      jumpifnot (TREE_OPERAND (exp, 0), lab1,\n+\t\t profile_probability::uninitialized ());\n       store_expr_with_bounds (TREE_OPERAND (exp, 1), target, call_param_p,\n \t\t\t      nontemporal, reverse, btarget);\n       emit_jump_insn (targetm.gen_jump (lab2));\n@@ -6504,7 +6509,8 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size,\n \t\t    /* Generate a conditional jump to exit the loop.  */\n \t\t    exit_cond = build2 (LT_EXPR, integer_type_node,\n \t\t\t\t\tindex, hi_index);\n-\t\t    jumpif (exit_cond, loop_end, -1);\n+\t\t    jumpif (exit_cond, loop_end,\n+\t\t\t    profile_probability::uninitialized ());\n \n \t\t    /* Update the loop counter, and jump to the head of\n \t\t       the loop.  */\n@@ -9043,7 +9049,7 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n \tlab = gen_label_rtx ();\n \tdo_compare_rtx_and_jump (target, cmpop1, comparison_code,\n \t\t\t\t unsignedp, mode, NULL_RTX, NULL, lab,\n-\t\t\t\t -1);\n+\t\t\t\t profile_probability::uninitialized ());\n       }\n       emit_move_insn (target, op1);\n       emit_label (lab);\n@@ -9272,7 +9278,8 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n \temit_move_insn (target, const0_rtx);\n \n \trtx_code_label *lab1 = gen_label_rtx ();\n-\tjumpifnot_1 (code, treeop0, treeop1, lab1, -1);\n+\tjumpifnot_1 (code, treeop0, treeop1, lab1,\n+\t\t     profile_probability::uninitialized ());\n \n \tif (TYPE_PRECISION (type) == 1 && !TYPE_UNSIGNED (type))\n \t  emit_move_insn (target, constm1_rtx);\n@@ -9523,7 +9530,8 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n \tNO_DEFER_POP;\n \trtx_code_label *lab0 = gen_label_rtx ();\n \trtx_code_label *lab1 = gen_label_rtx ();\n-\tjumpifnot (treeop0, lab0, -1);\n+\tjumpifnot (treeop0, lab0,\n+\t\t   profile_probability::uninitialized ());\n \tstore_expr (treeop1, temp,\n \t\t    modifier == EXPAND_STACK_PARM,\n \t\t    false, false);\n@@ -11042,7 +11050,8 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \t    int value = TREE_CODE (rhs) == BIT_IOR_EXPR;\n \t    do_jump (TREE_OPERAND (rhs, 1),\n \t\t     value ? label : 0,\n-\t\t     value ? 0 : label, -1);\n+\t\t     value ? 0 : label,\n+\t\t     profile_probability::uninitialized ());\n \t    expand_assignment (lhs, build_int_cst (TREE_TYPE (rhs), value),\n \t\t\t       false);\n \t    do_pending_stack_adjust ();\n@@ -11512,7 +11521,7 @@ do_store_flag (sepops ops, rtx target, machine_mode mode)\n int\n try_casesi (tree index_type, tree index_expr, tree minval, tree range,\n \t    rtx table_label, rtx default_label, rtx fallback_label,\n-            int default_probability)\n+            profile_probability default_probability)\n {\n   struct expand_operand ops[5];\n   machine_mode index_mode = SImode;\n@@ -11582,7 +11591,7 @@ try_casesi (tree index_type, tree index_expr, tree minval, tree range,\n \n static void\n do_tablejump (rtx index, machine_mode mode, rtx range, rtx table_label,\n-\t      rtx default_label, int default_probability)\n+\t      rtx default_label, profile_probability default_probability)\n {\n   rtx temp, vector;\n \n@@ -11645,7 +11654,8 @@ do_tablejump (rtx index, machine_mode mode, rtx range, rtx table_label,\n \n int\n try_tablejump (tree index_type, tree index_expr, tree minval, tree range,\n-\t       rtx table_label, rtx default_label, int default_probability)\n+\t       rtx table_label, rtx default_label, \n+\t       profile_probability default_probability)\n {\n   rtx index;\n "}, {"sha": "b92ff3ce8a63f743d10e18ea02286a601d70845b", "filename": "gcc/expr.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -288,8 +288,8 @@ expand_normal (tree exp)\n extern tree string_constant (tree, tree *);\n \n /* Two different ways of generating switch statements.  */\n-extern int try_casesi (tree, tree, tree, tree, rtx, rtx, rtx, int);\n-extern int try_tablejump (tree, tree, tree, tree, rtx, rtx, int);\n+extern int try_casesi (tree, tree, tree, tree, rtx, rtx, rtx, profile_probability);\n+extern int try_tablejump (tree, tree, tree, tree, rtx, rtx, profile_probability);\n \n extern int safe_from_p (const_rtx, tree, int);\n "}, {"sha": "4012b3b9e2d445f0b88c26bd024e845ff8a5689a", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 36, "deletions": 4, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -80,7 +80,7 @@ debug_gimple_stmt (gimple *gs)\n    by xstrdup_for_dump.  */\n \n static const char *\n-dump_probability (int frequency, profile_count &count)\n+dump_profile (int frequency, profile_count &count)\n {\n   float minimum = 0.01f;\n \n@@ -102,6 +102,38 @@ dump_probability (int frequency, profile_count &count)\n   return ret;\n }\n \n+/* Return formatted string of a VALUE probability\n+   (biased by REG_BR_PROB_BASE).  Returned string is allocated\n+   by xstrdup_for_dump.  */\n+\n+static const char *\n+dump_probability (profile_probability probability, profile_count &count)\n+{\n+  float minimum = 0.01f;\n+  float fvalue = -1;\n+\n+  if (probability.initialized_p ())\n+    {\n+      fvalue = probability.to_reg_br_prob_base () * 100.0f / REG_BR_PROB_BASE;\n+      if (fvalue < minimum && probability.to_reg_br_prob_base ())\n+\tfvalue = minimum;\n+    }\n+\n+  char *buf;\n+  if (count.initialized_p ())\n+    asprintf (&buf, \"[%.2f%%] [count: %\" PRId64 \"]\", fvalue,\n+\t      count.to_gcov_type ());\n+  else if (probability.initialized_p ())\n+    asprintf (&buf, \"[%.2f%%] [count: INV]\", fvalue);\n+  else\n+    asprintf (&buf, \"[INV] [count: INV]\");\n+\n+  const char *ret = xstrdup_for_dump (buf);\n+  free (buf);\n+\n+  return ret;\n+}\n+\n /* Dump E probability to BUFFER.  */\n \n static void\n@@ -1090,7 +1122,7 @@ dump_gimple_label (pretty_printer *buffer, glabel *gs, int spc,\n       dump_generic_node (buffer, label, spc, flags, false);\n       basic_block bb = gimple_bb (gs);\n       if (bb && !(flags & TDF_GIMPLE))\n-\tpp_scalar (buffer, \" %s\", dump_probability (bb->frequency, bb->count));\n+\tpp_scalar (buffer, \" %s\", dump_profile (bb->frequency, bb->count));\n       pp_colon (buffer);\n     }\n   if (flags & TDF_GIMPLE)\n@@ -2670,8 +2702,8 @@ dump_gimple_bb_header (FILE *outf, basic_block bb, int indent,\n \t    fprintf (outf, \"%*sbb_%d:\\n\", indent, \"\", bb->index);\n \t  else\n \t    fprintf (outf, \"%*s<bb %d> %s:\\n\",\n-\t\t     indent, \"\", bb->index, dump_probability (bb->frequency,\n-\t\t\t\t\t\t\t      bb->count));\n+\t\t     indent, \"\", bb->index, dump_profile (bb->frequency,\n+\t\t\t\t\t\t\t  bb->count));\n \t}\n     }\n }"}, {"sha": "2197a7e32af902eb7c460728143703b8eb8793d0", "filename": "gcc/graph.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraph.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -136,12 +136,16 @@ draw_cfg_node_succ_edges (pretty_printer *pp, int funcdef_no, basic_block bb)\n \n       pp_printf (pp,\n \t\t \"\\tfn_%d_basic_block_%d:s -> fn_%d_basic_block_%d:n \"\n-\t\t \"[style=%s,color=%s,weight=%d,constraint=%s, label=\\\"[%i%%]\\\"];\\n\",\n+\t\t \"[style=%s,color=%s,weight=%d,constraint=%s];\\n\",\n \t\t funcdef_no, e->src->index,\n \t\t funcdef_no, e->dest->index,\n \t\t style, color, weight,\n-\t\t (e->flags & (EDGE_FAKE | EDGE_DFS_BACK)) ? \"false\" : \"true\",\n-\t\t e->probability * 100 / REG_BR_PROB_BASE);\n+\t\t (e->flags & (EDGE_FAKE | EDGE_DFS_BACK)) ? \"false\" : \"true\");\n+      if (e->probability.initialized_p ())\n+        pp_printf (pp, \", label=\\\"[%i%%]\\\"\",\n+\t\t   e->probability.to_reg_br_prob_base ()\n+\t\t   * 100 / REG_BR_PROB_BASE);\n+      pp_printf (pp, \"];\\n\");\n     }\n   pp_flush (pp);\n }"}, {"sha": "7d628179ea67436866b3e00776b384b3be318b39", "filename": "gcc/hsa-gen.c", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fhsa-gen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fhsa-gen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa-gen.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -6139,7 +6139,7 @@ convert_switch_statements (void)\n \tauto_vec <edge> new_edges;\n \tauto_vec <phi_definition *> phi_todo_list;\n \tauto_vec <profile_count> edge_counts;\n-\tauto_vec <int> edge_probabilities;\n+\tauto_vec <profile_probability> edge_probabilities;\n \n \t/* Investigate all labels that and PHI nodes in these edges which\n \t   should be fixed after we add new collection of edges.  */\n@@ -6231,12 +6231,12 @@ convert_switch_statements (void)\n \t    basic_block label_bb\n \t      = label_to_block_fn (func, CASE_LABEL (label));\n \t    edge new_edge = make_edge (cur_bb, label_bb, EDGE_TRUE_VALUE);\n-\t    int prob_sum = sum_slice <int> (edge_probabilities, i, labels, 0) +\n-\t       edge_probabilities[0];\n+\t    profile_probability prob_sum = sum_slice <profile_probability>\n+\t\t (edge_probabilities, i, labels, profile_probability::never ())\n+\t\t  + edge_probabilities[0];\n \n-\t    if (prob_sum)\n-\t      new_edge->probability\n-\t\t= RDIV (REG_BR_PROB_BASE * edge_probabilities[i], prob_sum);\n+\t    if (prob_sum.initialized_p ())\n+\t      new_edge->probability = edge_probabilities[i] / prob_sum;\n \n \t    new_edge->count = edge_counts[i];\n \t    new_edges.safe_push (new_edge);\n@@ -6253,8 +6253,7 @@ convert_switch_statements (void)\n \t\t  }\n \n \t\tedge next_edge = make_edge (cur_bb, next_bb, EDGE_FALSE_VALUE);\n-\t\tnext_edge->probability\n-\t\t  = inverse_probability (new_edge->probability);\n+\t\tnext_edge->probability = new_edge->probability.invert ();\n \t\tnext_edge->count = edge_counts[0]\n \t\t  + sum_slice <profile_count> (edge_counts, i, labels,\n \t\t\t\t\t       profile_count::zero ());\n@@ -6265,7 +6264,7 @@ convert_switch_statements (void)\n \t\t    of the switch.  */\n \t      {\n \t\tedge e = make_edge (cur_bb, default_label_bb, EDGE_FALSE_VALUE);\n-\t\te->probability = inverse_probability (new_edge->probability);\n+\t\te->probability = new_edge->probability.invert ();\n \t\te->count = edge_counts[0];\n \t\tnew_edges.safe_insert (0, e);\n \t      }"}, {"sha": "fd682a4cf5aae64defa9667f0316caa332c8d563", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -78,7 +78,7 @@ static int cond_exec_changed_p;\n \n /* Forward references.  */\n static int count_bb_insns (const_basic_block);\n-static bool cheap_bb_rtx_cost_p (const_basic_block, int, int);\n+static bool cheap_bb_rtx_cost_p (const_basic_block, profile_probability, int);\n static rtx_insn *first_active_insn (basic_block);\n static rtx_insn *last_active_insn (basic_block, int);\n static rtx_insn *find_active_insn_before (basic_block, rtx_insn *);\n@@ -132,11 +132,14 @@ count_bb_insns (const_basic_block bb)\n    plus a small fudge factor.  */\n \n static bool\n-cheap_bb_rtx_cost_p (const_basic_block bb, int scale, int max_cost)\n+cheap_bb_rtx_cost_p (const_basic_block bb,\n+\t\t     profile_probability prob, int max_cost)\n {\n   int count = 0;\n   rtx_insn *insn = BB_HEAD (bb);\n   bool speed = optimize_bb_for_speed_p (bb);\n+  int scale = prob.initialized_p () ? prob.to_reg_br_prob_base ()\n+\t      : REG_BR_PROB_BASE;\n \n   /* Set scale to REG_BR_PROB_BASE to void the identical scaling\n      applied to insn_rtx_cost when optimizing for size.  Only do\n@@ -4807,7 +4810,8 @@ find_if_case_1 (basic_block test_bb, edge then_edge, edge else_edge)\n   basic_block then_bb = then_edge->dest;\n   basic_block else_bb = else_edge->dest;\n   basic_block new_bb;\n-  int then_bb_index, then_prob;\n+  int then_bb_index;\n+  profile_probability then_prob;\n   rtx else_target = NULL_RTX;\n \n   /* If we are partitioning hot/cold basic blocks, we don't want to\n@@ -4853,10 +4857,7 @@ find_if_case_1 (basic_block test_bb, edge then_edge, edge else_edge)\n \t     \"\\nIF-CASE-1 found, start %d, then %d\\n\",\n \t     test_bb->index, then_bb->index);\n \n-  if (then_edge->probability)\n-    then_prob = REG_BR_PROB_BASE - then_edge->probability;\n-  else\n-    then_prob = REG_BR_PROB_BASE / 2;\n+  then_prob = then_edge->probability.invert ();\n \n   /* We're speculating from the THEN path, we want to make sure the cost\n      of speculation is within reason.  */\n@@ -4927,7 +4928,7 @@ find_if_case_2 (basic_block test_bb, edge then_edge, edge else_edge)\n   basic_block then_bb = then_edge->dest;\n   basic_block else_bb = else_edge->dest;\n   edge else_succ;\n-  int then_prob, else_prob;\n+  profile_probability then_prob, else_prob;\n \n   /* We do not want to speculate (empty) loop latches.  */\n   if (current_loops\n@@ -4973,16 +4974,8 @@ find_if_case_2 (basic_block test_bb, edge then_edge, edge else_edge)\n   if (then_bb->index < NUM_FIXED_BLOCKS)\n     return FALSE;\n \n-  if (else_edge->probability)\n-    {\n-      else_prob = else_edge->probability;\n-      then_prob = REG_BR_PROB_BASE - else_prob;\n-    }\n-  else\n-    {\n-      else_prob = REG_BR_PROB_BASE / 2;\n-      then_prob = REG_BR_PROB_BASE / 2;\n-    }\n+  else_prob = else_edge->probability;\n+  then_prob = else_prob.invert ();\n \n   /* ELSE is predicted or SUCC(ELSE) postdominates THEN.  */\n   if (else_prob > then_prob)"}, {"sha": "d276dfecf9a3bf52507783e4e0a804692dc48c22", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -569,7 +569,7 @@ expand_arith_overflow_result_store (tree lhs, rtx target,\n       gcc_assert (GET_MODE_PRECISION (tgtmode) < GET_MODE_PRECISION (mode));\n       do_compare_rtx_and_jump (res, convert_modes (mode, tgtmode, lres, uns),\n \t\t\t       EQ, true, mode, NULL_RTX, NULL, done_label,\n-\t\t\t       PROB_VERY_LIKELY);\n+\t\t\t       profile_probability::very_likely ());\n       expand_arith_set_overflow (lhs, target);\n       emit_label (done_label);\n     }\n@@ -597,7 +597,7 @@ expand_arith_overflow_result_store (tree lhs, rtx target,\n \t}\n       do_compare_rtx_and_jump (res, lres,\n \t\t\t       EQ, true, tgtmode, NULL_RTX, NULL, done_label,\n-\t\t\t       PROB_VERY_LIKELY);\n+\t\t\t       profile_probability::very_likely ());\n       expand_arith_set_overflow (lhs, target);\n       emit_label (done_label);\n     }\n@@ -767,7 +767,7 @@ expand_addsub_overflow (location_t loc, tree_code code, tree lhs,\n \ttem = op1;\n       do_compare_rtx_and_jump (res, tem, code == PLUS_EXPR ? GEU : LEU,\n \t\t\t       true, mode, NULL_RTX, NULL, done_label,\n-\t\t\t       PROB_VERY_LIKELY);\n+\t\t\t       profile_probability::very_likely ());\n       goto do_error_label;\n     }\n \n@@ -782,7 +782,7 @@ expand_addsub_overflow (location_t loc, tree_code code, tree lhs,\n \t\t\t      code == PLUS_EXPR ? res : op0, sgn,\n \t\t\t      NULL_RTX, false, OPTAB_LIB_WIDEN);\n       do_compare_rtx_and_jump (tem, op1, GEU, true, mode, NULL_RTX, NULL,\n-\t\t\t       done_label, PROB_VERY_LIKELY);\n+\t\t\t       done_label, profile_probability::very_likely ());\n       goto do_error_label;\n     }\n \n@@ -824,9 +824,9 @@ expand_addsub_overflow (location_t loc, tree_code code, tree lhs,\n       else if (pos_neg == 3)\n \t/* If ARG0 is not known to be always positive, check at runtime.  */\n \tdo_compare_rtx_and_jump (op0, const0_rtx, LT, false, mode, NULL_RTX,\n-\t\t\t\t NULL, do_error, PROB_VERY_UNLIKELY);\n+\t\t\t\t NULL, do_error, profile_probability::very_unlikely ());\n       do_compare_rtx_and_jump (op1, op0, LEU, true, mode, NULL_RTX, NULL,\n-\t\t\t       done_label, PROB_VERY_LIKELY);\n+\t\t\t       done_label, profile_probability::very_likely ());\n       goto do_error_label;\n     }\n \n@@ -840,7 +840,7 @@ expand_addsub_overflow (location_t loc, tree_code code, tree lhs,\n       rtx tem = expand_binop (mode, add_optab, op1, sgn, NULL_RTX, false,\n \t\t\t      OPTAB_LIB_WIDEN);\n       do_compare_rtx_and_jump (op0, tem, LTU, true, mode, NULL_RTX, NULL,\n-\t\t\t       done_label, PROB_VERY_LIKELY);\n+\t\t\t       done_label, profile_probability::very_likely ());\n       goto do_error_label;\n     }\n \n@@ -852,7 +852,7 @@ expand_addsub_overflow (location_t loc, tree_code code, tree lhs,\n       res = expand_binop (mode, add_optab, op0, op1, NULL_RTX, false,\n \t\t\t  OPTAB_LIB_WIDEN);\n       do_compare_rtx_and_jump (res, const0_rtx, LT, false, mode, NULL_RTX,\n-\t\t\t       NULL, do_error, PROB_VERY_UNLIKELY);\n+\t\t\t       NULL, do_error, profile_probability::very_unlikely ());\n       rtx tem = op1;\n       /* The operation is commutative, so we can pick operand to compare\n \t against.  For prec <= BITS_PER_WORD, I think preferring REG operand\n@@ -866,7 +866,7 @@ expand_addsub_overflow (location_t loc, tree_code code, tree lhs,\n \t  : CONST_SCALAR_INT_P (op0))\n \ttem = op0;\n       do_compare_rtx_and_jump (res, tem, GEU, true, mode, NULL_RTX, NULL,\n-\t\t\t       done_label, PROB_VERY_LIKELY);\n+\t\t\t       done_label, profile_probability::very_likely ());\n       goto do_error_label;\n     }\n \n@@ -894,25 +894,25 @@ expand_addsub_overflow (location_t loc, tree_code code, tree lhs,\n \t\t\t\t    ? and_optab : ior_optab,\n \t\t\t      op0, res, NULL_RTX, false, OPTAB_LIB_WIDEN);\n \t  do_compare_rtx_and_jump (tem, const0_rtx, GE, false, mode, NULL,\n-\t\t\t\t   NULL, done_label, PROB_VERY_LIKELY);\n+\t\t\t\t   NULL, done_label, profile_probability::very_likely ());\n \t}\n       else\n \t{\n \t  rtx_code_label *do_ior_label = gen_label_rtx ();\n \t  do_compare_rtx_and_jump (op1, const0_rtx,\n \t\t\t\t   code == MINUS_EXPR ? GE : LT, false, mode,\n \t\t\t\t   NULL_RTX, NULL, do_ior_label,\n-\t\t\t\t   PROB_EVEN);\n+\t\t\t\t   profile_probability::even ());\n \t  tem = expand_binop (mode, and_optab, op0, res, NULL_RTX, false,\n \t\t\t      OPTAB_LIB_WIDEN);\n \t  do_compare_rtx_and_jump (tem, const0_rtx, GE, false, mode, NULL_RTX,\n-\t\t\t\t   NULL, done_label, PROB_VERY_LIKELY);\n+\t\t\t\t   NULL, done_label, profile_probability::very_likely ());\n \t  emit_jump (do_error);\n \t  emit_label (do_ior_label);\n \t  tem = expand_binop (mode, ior_optab, op0, res, NULL_RTX, false,\n \t\t\t      OPTAB_LIB_WIDEN);\n \t  do_compare_rtx_and_jump (tem, const0_rtx, GE, false, mode, NULL_RTX,\n-\t\t\t\t   NULL, done_label, PROB_VERY_LIKELY);\n+\t\t\t\t   NULL, done_label, profile_probability::very_likely ());\n \t}\n       goto do_error_label;\n     }\n@@ -926,13 +926,13 @@ expand_addsub_overflow (location_t loc, tree_code code, tree lhs,\n \t\t\t  OPTAB_LIB_WIDEN);\n       rtx_code_label *op0_geu_op1 = gen_label_rtx ();\n       do_compare_rtx_and_jump (op0, op1, GEU, true, mode, NULL_RTX, NULL,\n-\t\t\t       op0_geu_op1, PROB_EVEN);\n+\t\t\t       op0_geu_op1, profile_probability::even ());\n       do_compare_rtx_and_jump (res, const0_rtx, LT, false, mode, NULL_RTX,\n-\t\t\t       NULL, done_label, PROB_VERY_LIKELY);\n+\t\t\t       NULL, done_label, profile_probability::very_likely ());\n       emit_jump (do_error);\n       emit_label (op0_geu_op1);\n       do_compare_rtx_and_jump (res, const0_rtx, GE, false, mode, NULL_RTX,\n-\t\t\t       NULL, done_label, PROB_VERY_LIKELY);\n+\t\t\t       NULL, done_label, profile_probability::very_likely ());\n       goto do_error_label;\n     }\n \n@@ -960,7 +960,7 @@ expand_addsub_overflow (location_t loc, tree_code code, tree lhs,\n \t\t&& JUMP_P (last)\n \t\t&& any_condjump_p (last)\n \t\t&& !find_reg_note (last, REG_BR_PROB, 0))\n-\t      add_int_reg_note (last, REG_BR_PROB, PROB_VERY_UNLIKELY);\n+\t      add_int_reg_note (last, REG_BR_PROB, PROB_UNLIKELY);\n \t    emit_jump (done_label);\n \t    goto do_error_label;\n \t  }\n@@ -1020,7 +1020,7 @@ expand_addsub_overflow (location_t loc, tree_code code, tree lhs,\n \n \t/* No overflow if the result has bit sign cleared.  */\n \tdo_compare_rtx_and_jump (tem, const0_rtx, GE, false, mode, NULL_RTX,\n-\t\t\t\t NULL, done_label, PROB_VERY_LIKELY);\n+\t\t\t\t NULL, done_label, profile_probability::very_likely ());\n       }\n \n     /* Compare the result of the operation with the first operand.\n@@ -1031,7 +1031,7 @@ expand_addsub_overflow (location_t loc, tree_code code, tree lhs,\n       do_compare_rtx_and_jump (res, op0,\n \t\t\t       (pos_neg == 1) ^ (code == MINUS_EXPR) ? GE : LE,\n \t\t\t       false, mode, NULL_RTX, NULL, done_label,\n-\t\t\t       PROB_VERY_LIKELY);\n+\t\t\t       profile_probability::very_likely ());\n   }\n \n  do_error_label:\n@@ -1128,7 +1128,7 @@ expand_neg_overflow (location_t loc, tree lhs, tree arg1, bool is_ubsan,\n       /* Compare the operand with the most negative value.  */\n       rtx minv = expand_normal (TYPE_MIN_VALUE (TREE_TYPE (arg1)));\n       do_compare_rtx_and_jump (op1, minv, NE, true, mode, NULL_RTX, NULL,\n-\t\t\t       done_label, PROB_VERY_LIKELY);\n+\t\t\t       done_label, profile_probability::very_likely ());\n     }\n \n   emit_label (do_error);\n@@ -1261,15 +1261,15 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n \t  ops.location = loc;\n \t  res = expand_expr_real_2 (&ops, NULL_RTX, mode, EXPAND_NORMAL);\n \t  do_compare_rtx_and_jump (op1, const0_rtx, EQ, true, mode, NULL_RTX,\n-\t\t\t\t   NULL, done_label, PROB_VERY_LIKELY);\n+\t\t\t\t   NULL, done_label, profile_probability::very_likely ());\n \t  goto do_error_label;\n \tcase 3:\n \t  rtx_code_label *do_main_label;\n \t  do_main_label = gen_label_rtx ();\n \t  do_compare_rtx_and_jump (op0, const0_rtx, GE, false, mode, NULL_RTX,\n-\t\t\t\t   NULL, do_main_label, PROB_VERY_LIKELY);\n+\t\t\t\t   NULL, do_main_label, profile_probability::very_likely ());\n \t  do_compare_rtx_and_jump (op1, const0_rtx, EQ, true, mode, NULL_RTX,\n-\t\t\t\t   NULL, do_main_label, PROB_VERY_LIKELY);\n+\t\t\t\t   NULL, do_main_label, profile_probability::very_likely ());\n \t  expand_arith_set_overflow (lhs, target);\n \t  emit_label (do_main_label);\n \t  goto do_main;\n@@ -1306,15 +1306,15 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n \t  ops.location = loc;\n \t  res = expand_expr_real_2 (&ops, NULL_RTX, mode, EXPAND_NORMAL);\n \t  do_compare_rtx_and_jump (op0, const0_rtx, EQ, true, mode, NULL_RTX,\n-\t\t\t\t   NULL, done_label, PROB_VERY_LIKELY);\n+\t\t\t\t   NULL, done_label, profile_probability::very_likely ());\n \t  do_compare_rtx_and_jump (op0, constm1_rtx, NE, true, mode, NULL_RTX,\n-\t\t\t\t   NULL, do_error, PROB_VERY_UNLIKELY);\n+\t\t\t\t   NULL, do_error, profile_probability::very_unlikely ());\n \t  int prec;\n \t  prec = GET_MODE_PRECISION (mode);\n \t  rtx sgn;\n \t  sgn = immed_wide_int_const (wi::min_value (prec, SIGNED), mode);\n \t  do_compare_rtx_and_jump (op1, sgn, EQ, true, mode, NULL_RTX,\n-\t\t\t\t   NULL, done_label, PROB_VERY_LIKELY);\n+\t\t\t\t   NULL, done_label, profile_probability::very_likely ());\n \t  goto do_error_label;\n \tcase 3:\n \t  /* Rest of handling of this case after res is computed.  */\n@@ -1361,7 +1361,7 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n \t\t\t\t  OPTAB_LIB_WIDEN);\n \t      do_compare_rtx_and_jump (tem, const0_rtx, EQ, true, mode,\n \t\t\t\t       NULL_RTX, NULL, done_label,\n-\t\t\t\t       PROB_VERY_LIKELY);\n+\t\t\t\t       profile_probability::very_likely ());\n \t      goto do_error_label;\n \t    }\n \t  /* The general case, do all the needed comparisons at runtime.  */\n@@ -1378,7 +1378,7 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n \t  tem = expand_binop (mode, and_optab, op0, op1, NULL_RTX, false,\n \t\t\t      OPTAB_LIB_WIDEN);\n \t  do_compare_rtx_and_jump (tem, const0_rtx, GE, false, mode, NULL_RTX,\n-\t\t\t\t   NULL, after_negate_label, PROB_VERY_LIKELY);\n+\t\t\t\t   NULL, after_negate_label, profile_probability::very_likely ());\n \t  /* Both arguments negative here, negate them and continue with\n \t     normal unsigned overflow checking multiplication.  */\n \t  emit_move_insn (op0, expand_unop (mode, neg_optab, op0,\n@@ -1394,13 +1394,13 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n \t  tem2 = expand_binop (mode, xor_optab, op0, op1, NULL_RTX, false,\n \t\t\t       OPTAB_LIB_WIDEN);\n \t  do_compare_rtx_and_jump (tem2, const0_rtx, GE, false, mode, NULL_RTX,\n-\t\t\t\t   NULL, do_main_label, PROB_VERY_LIKELY);\n+\t\t\t\t   NULL, do_main_label, profile_probability::very_likely ());\n \t  /* One argument is negative here, the other positive.  This\n \t     overflows always, unless one of the arguments is 0.  But\n \t     if e.g. s2 is 0, (U) s1 * 0 doesn't overflow, whatever s1\n \t     is, thus we can keep do_main code oring in overflow as is.  */\n \t  do_compare_rtx_and_jump (tem, const0_rtx, EQ, true, mode, NULL_RTX,\n-\t\t\t\t   NULL, do_main_label, PROB_VERY_LIKELY);\n+\t\t\t\t   NULL, do_main_label, profile_probability::very_likely ());\n \t  expand_arith_set_overflow (lhs, target);\n \t  emit_label (do_main_label);\n \t  goto do_main;\n@@ -1467,7 +1467,7 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n \t       HIPART is non-zero.  */\n \t    do_compare_rtx_and_jump (hipart, const0_rtx, EQ, true, mode,\n \t\t\t\t     NULL_RTX, NULL, done_label,\n-\t\t\t\t     PROB_VERY_LIKELY);\n+\t\t\t\t     profile_probability::very_likely ());\n \t  else\n \t    {\n \t      rtx signbit = expand_shift (RSHIFT_EXPR, mode, res, prec - 1,\n@@ -1477,7 +1477,7 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n \t\t HIPART is different from RES < 0 ? -1 : 0.  */\n \t      do_compare_rtx_and_jump (signbit, hipart, EQ, true, mode,\n \t\t\t\t       NULL_RTX, NULL, done_label,\n-\t\t\t\t       PROB_VERY_LIKELY);\n+\t\t\t\t       profile_probability::very_likely ());\n \t    }\n \t}\n       else if (hmode != BLKmode && 2 * GET_MODE_PRECISION (hmode) == prec)\n@@ -1570,12 +1570,12 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n \t  if (!op0_small_p)\n \t    do_compare_rtx_and_jump (signbit0, hipart0, NE, true, hmode,\n \t\t\t\t     NULL_RTX, NULL, large_op0,\n-\t\t\t\t     PROB_UNLIKELY);\n+\t\t\t\t     profile_probability::unlikely ());\n \n \t  if (!op1_small_p)\n \t    do_compare_rtx_and_jump (signbit1, hipart1, NE, true, hmode,\n \t\t\t\t     NULL_RTX, NULL, small_op0_large_op1,\n-\t\t\t\t     PROB_UNLIKELY);\n+\t\t\t\t     profile_probability::unlikely ());\n \n \t  /* If both op0 and op1 are sign (!uns) or zero (uns) extended from\n \t     hmode to mode, the multiplication will never overflow.  We can\n@@ -1621,7 +1621,7 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n \t  if (!op1_small_p)\n \t    do_compare_rtx_and_jump (signbit1, hipart1, NE, true, hmode,\n \t\t\t\t     NULL_RTX, NULL, both_ops_large,\n-\t\t\t\t     PROB_UNLIKELY);\n+\t\t\t\t     profile_probability::unlikely ());\n \n \t  /* If op1 is sign (!uns) or zero (uns) extended from hmode to mode,\n \t     but op0 is not, prepare larger, hipart and lopart pseudos and\n@@ -1658,7 +1658,7 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n \t      else if (larger_sign != -1)\n \t\tdo_compare_rtx_and_jump (hipart, const0_rtx, GE, false, hmode,\n \t\t\t\t\t NULL_RTX, NULL, after_hipart_neg,\n-\t\t\t\t\t PROB_EVEN);\n+\t\t\t\t\t profile_probability::even ());\n \n \t      tem = convert_modes (mode, hmode, lopart, 1);\n \t      tem = expand_shift (LSHIFT_EXPR, mode, tem, hprec, NULL_RTX, 1);\n@@ -1674,7 +1674,7 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n \t      else if (smaller_sign != -1)\n \t\tdo_compare_rtx_and_jump (lopart, const0_rtx, GE, false, hmode,\n \t\t\t\t\t NULL_RTX, NULL, after_lopart_neg,\n-\t\t\t\t\t PROB_EVEN);\n+\t\t\t\t\t profile_probability::even ());\n \n \t      tem = expand_simple_binop (mode, MINUS, loxhi, larger, NULL_RTX,\n \t\t\t\t\t 1, OPTAB_DIRECT);\n@@ -1704,7 +1704,7 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n \n \t  do_compare_rtx_and_jump (signbitloxhi, hipartloxhi, NE, true, hmode,\n \t\t\t\t   NULL_RTX, NULL, do_overflow,\n-\t\t\t\t   PROB_VERY_UNLIKELY);\n+\t\t\t\t   profile_probability::very_unlikely ());\n \n \t  /* res = (loxhi << (bitsize / 2)) | (hmode) lo0xlo1;  */\n \t  rtx loxhishifted = expand_shift (LSHIFT_EXPR, mode, loxhi, hprec,\n@@ -1741,7 +1741,7 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n \t\t\t\t\t     NULL_RTX, 1, OPTAB_DIRECT);\n \t\t  do_compare_rtx_and_jump (tem, const1_rtx, GTU, true, hmode,\n \t\t\t\t\t   NULL_RTX, NULL, do_error,\n-\t\t\t\t\t   PROB_VERY_UNLIKELY);\n+\t\t\t\t\t   profile_probability::very_unlikely ());\n \t\t}\n \n \t      if (!op1_medium_p)\n@@ -1750,7 +1750,7 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n \t\t\t\t\t     NULL_RTX, 1, OPTAB_DIRECT);\n \t\t  do_compare_rtx_and_jump (tem, const1_rtx, GTU, true, hmode,\n \t\t\t\t\t   NULL_RTX, NULL, do_error,\n-\t\t\t\t\t   PROB_VERY_UNLIKELY);\n+\t\t\t\t\t   profile_probability::very_unlikely ());\n \t\t}\n \n \t      /* At this point hipart{0,1} are both in [-1, 0].  If they are\n@@ -1761,18 +1761,18 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n \t      else if (op0_sign == 1 || op1_sign == 1)\n \t\tdo_compare_rtx_and_jump (hipart0, hipart1, NE, true, hmode,\n \t\t\t\t\t NULL_RTX, NULL, hipart_different,\n-\t\t\t\t\t PROB_EVEN);\n+\t\t\t\t\t profile_probability::even ());\n \n \t      do_compare_rtx_and_jump (res, const0_rtx, LT, false, mode,\n \t\t\t\t       NULL_RTX, NULL, do_error,\n-\t\t\t\t       PROB_VERY_UNLIKELY);\n+\t\t\t\t       profile_probability::very_unlikely ());\n \t      emit_jump (done_label);\n \n \t      emit_label (hipart_different);\n \n \t      do_compare_rtx_and_jump (res, const0_rtx, GE, false, mode,\n \t\t\t\t       NULL_RTX, NULL, do_error,\n-\t\t\t\t       PROB_VERY_UNLIKELY);\n+\t\t\t\t       profile_probability::very_unlikely ());\n \t      emit_jump (done_label);\n \t    }\n \n@@ -1817,7 +1817,7 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n     {\n       rtx_code_label *all_done_label = gen_label_rtx ();\n       do_compare_rtx_and_jump (res, const0_rtx, GE, false, mode, NULL_RTX,\n-\t\t\t       NULL, all_done_label, PROB_VERY_LIKELY);\n+\t\t\t       NULL, all_done_label, profile_probability::very_likely ());\n       expand_arith_set_overflow (lhs, target);\n       emit_label (all_done_label);\n     }\n@@ -1828,14 +1828,14 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n       rtx_code_label *all_done_label = gen_label_rtx ();\n       rtx_code_label *set_noovf = gen_label_rtx ();\n       do_compare_rtx_and_jump (op1, const0_rtx, GE, false, mode, NULL_RTX,\n-\t\t\t       NULL, all_done_label, PROB_VERY_LIKELY);\n+\t\t\t       NULL, all_done_label, profile_probability::very_likely ());\n       expand_arith_set_overflow (lhs, target);\n       do_compare_rtx_and_jump (op0, const0_rtx, EQ, true, mode, NULL_RTX,\n-\t\t\t       NULL, set_noovf, PROB_VERY_LIKELY);\n+\t\t\t       NULL, set_noovf, profile_probability::very_likely ());\n       do_compare_rtx_and_jump (op0, constm1_rtx, NE, true, mode, NULL_RTX,\n-\t\t\t       NULL, all_done_label, PROB_VERY_UNLIKELY);\n+\t\t\t       NULL, all_done_label, profile_probability::very_unlikely ());\n       do_compare_rtx_and_jump (op1, res, NE, true, mode, NULL_RTX, NULL,\n-\t\t\t       all_done_label, PROB_VERY_UNLIKELY);\n+\t\t\t       all_done_label, profile_probability::very_unlikely ());\n       emit_label (set_noovf);\n       write_complex_part (target, const0_rtx, true);\n       emit_label (all_done_label);\n@@ -1977,7 +1977,7 @@ expand_vector_ubsan_overflow (location_t loc, enum tree_code code, tree lhs,\n \temit_move_insn (cntvar, ret);\n       do_compare_rtx_and_jump (cntvar, GEN_INT (cnt), NE, false,\n \t\t\t       TYPE_MODE (sizetype), NULL_RTX, NULL, loop_lab,\n-\t\t\t       PROB_VERY_LIKELY);\n+\t\t\t       profile_probability::very_likely ());\n     }\n   if (lhs && resv == NULL_TREE)\n     {"}, {"sha": "3b9eab41672dd8da81f25244ec7549d2b030a1f6", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -2631,7 +2631,8 @@ good_cloning_opportunity_p (struct cgraph_node *node, int time_benefit,\n   struct ipa_node_params *info = IPA_NODE_REF (node);\n   if (max_count > profile_count::zero ())\n     {\n-      int factor = RDIV (count_sum.probability_in (max_count)\n+      int factor = RDIV (count_sum.probability_in\n+\t\t\t\t (max_count).to_reg_br_prob_base ()\n \t\t         * 1000, REG_BR_PROB_BASE);\n       int64_t evaluation = (((int64_t) time_benefit * factor)\n \t\t\t\t    / size_cost);"}, {"sha": "e3759d6c50e401f49f315d93af4978417c7dbbd2", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -1292,9 +1292,7 @@ split_function (basic_block return_bb, struct split_point *split_point,\n \t\tbreak;\n \t      }\n \t}\n-      e = make_edge (new_return_bb, EXIT_BLOCK_PTR_FOR_FN (cfun), 0);\n-      e->probability = REG_BR_PROB_BASE;\n-      e->count = new_return_bb->count;\n+      e = make_single_succ_edge (new_return_bb, EXIT_BLOCK_PTR_FOR_FN (cfun), 0);\n       add_bb_to_loop (new_return_bb, current_loops->tree_root);\n       bitmap_set_bit (split_point->split_bbs, new_return_bb->index);\n       retbnd = find_retbnd (return_bb);\n@@ -1527,11 +1525,9 @@ split_function (basic_block return_bb, struct split_point *split_point,\n     }\n   else\n     {\n-      e = make_edge (call_bb, return_bb,\n-\t\t     return_bb == EXIT_BLOCK_PTR_FOR_FN (cfun)\n-\t\t     ? 0 : EDGE_FALLTHRU);\n-      e->count = call_bb->count;\n-      e->probability = REG_BR_PROB_BASE;\n+      e = make_single_succ_edge (call_bb, return_bb,\n+\t\t\t\t return_bb == EXIT_BLOCK_PTR_FOR_FN (cfun)\n+\t\t\t\t ? 0 : EDGE_FALLTHRU);\n \n       /* If there is return basic block, see what value we need to store\n          return value into and put call just before it.  */"}, {"sha": "65eed77c930f17839c8860e134e88cf0ae6d32b1", "filename": "gcc/ipa-utils.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fipa-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fipa-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -598,7 +598,8 @@ ipa_merge_profiles (struct cgraph_node *dst,\n \t\t\t}\n \t\t    }\n \t\t  int  prob = direct->count.probability_in (direct->count\n-\t\t\t\t\t\t\t    + indirect->count);\n+\t\t\t\t\t\t\t    + indirect->count).\n+\t\t\t      to_reg_br_prob_base ();\n \t\t  direct->frequency = RDIV (freq * prob, REG_BR_PROB_BASE);\n \t\t  indirect->frequency = RDIV (freq * (REG_BR_PROB_BASE - prob),\n \t\t\t\t\t      REG_BR_PROB_BASE);\n@@ -616,7 +617,8 @@ ipa_merge_profiles (struct cgraph_node *dst,\n \t      e2->speculative_call_info (direct, indirect, ref);\n \t      e->count = count;\n \t      e->frequency = freq;\n-\t      int prob = direct->count.probability_in (e->count);\n+\t      int prob = direct->count.probability_in (e->count)\n+\t\t\t .to_reg_br_prob_base ();\n \t      e->make_speculative (direct->callee, direct->count,\n \t\t\t\t   RDIV (freq * prob, REG_BR_PROB_BASE));\n \t    }"}, {"sha": "13bf8cf2ecf58ee887c2d3fafa282397611571b8", "filename": "gcc/loop-doloop.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Floop-doloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Floop-doloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-doloop.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -356,7 +356,8 @@ add_test (rtx cond, edge *e, basic_block dest)\n   op0 = force_operand (op0, NULL_RTX);\n   op1 = force_operand (op1, NULL_RTX);\n   label = block_label (dest);\n-  do_compare_rtx_and_jump (op0, op1, code, 0, mode, NULL_RTX, NULL, label, -1);\n+  do_compare_rtx_and_jump (op0, op1, code, 0, mode, NULL_RTX, NULL, label,\n+\t\t\t   profile_probability::uninitialized ());\n \n   jump = get_last_insn ();\n   if (!jump || !JUMP_P (jump))\n@@ -575,10 +576,11 @@ doloop_modify (struct loop *loop, struct niter_desc *desc,\n     add_reg_note (jump_insn, REG_NONNEG, NULL_RTX);\n \n   /* Update the REG_BR_PROB note.  */\n-  if (true_prob_val)\n+  if (true_prob_val && desc->in_edge->probability.initialized_p ())\n     {\n       /* Seems safer to use the branch probability.  */\n-      add_int_reg_note (jump_insn, REG_BR_PROB, desc->in_edge->probability);\n+      add_int_reg_note (jump_insn, REG_BR_PROB,\n+\t\t\tdesc->in_edge->probability.to_reg_br_prob_base ());\n     }\n }\n "}, {"sha": "5e2e77a232729188a9e6a62e033eeec5951ef82e", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -774,7 +774,8 @@ split_edge_and_insert (edge e, rtx_insn *insns)\n \n static rtx_insn *\n compare_and_jump_seq (rtx op0, rtx op1, enum rtx_code comp,\n-\t\t      rtx_code_label *label, int prob, rtx_insn *cinsn)\n+\t\t      rtx_code_label *label, profile_probability prob,\n+\t\t      rtx_insn *cinsn)\n {\n   rtx_insn *seq;\n   rtx_jump_insn *jump;\n@@ -808,12 +809,14 @@ compare_and_jump_seq (rtx op0, rtx op1, enum rtx_code comp,\n       op0 = force_operand (op0, NULL_RTX);\n       op1 = force_operand (op1, NULL_RTX);\n       do_compare_rtx_and_jump (op0, op1, comp, 0,\n-\t\t\t       mode, NULL_RTX, NULL, label, -1);\n+\t\t\t       mode, NULL_RTX, NULL, label,\n+\t\t\t       profile_probability::uninitialized ());\n       jump = as_a <rtx_jump_insn *> (get_last_insn ());\n       jump->set_jump_target (label);\n       LABEL_NUSES (label)++;\n     }\n-  add_int_reg_note (jump, REG_BR_PROB, prob);\n+  if (prob.initialized_p ())\n+    add_int_reg_note (jump, REG_BR_PROB, prob.to_reg_br_prob_base ());\n \n   seq = get_insns ();\n   end_sequence ();\n@@ -857,7 +860,8 @@ unroll_loop_runtime_iterations (struct loop *loop)\n {\n   rtx old_niter, niter, tmp;\n   rtx_insn *init_code, *branch_code;\n-  unsigned i, j, p;\n+  unsigned i, j;\n+  profile_probability p;\n   basic_block preheader, *body, swtch, ezc_swtch = NULL;\n   int may_exit_copy, iter_freq, new_freq;\n   profile_count iter_count, new_count;\n@@ -989,7 +993,7 @@ unroll_loop_runtime_iterations (struct loop *loop)\n \n       /* Create item for switch.  */\n       j = n_peel - i - (extra_zero_check ? 0 : 1);\n-      p = REG_BR_PROB_BASE / (i + 2);\n+      p = profile_probability::always ().apply_scale (1, i + 2);\n \n       preheader = split_edge (loop_preheader_edge (loop));\n       /* Add in frequency/count of edge from switch block.  */\n@@ -1006,7 +1010,7 @@ unroll_loop_runtime_iterations (struct loop *loop)\n \n       swtch = split_edge_and_insert (single_pred_edge (swtch), branch_code);\n       set_immediate_dominator (CDI_DOMINATORS, preheader, swtch);\n-      single_succ_edge (swtch)->probability = REG_BR_PROB_BASE - p;\n+      single_succ_edge (swtch)->probability = p.invert ();\n       single_succ_edge (swtch)->count = new_count;\n       new_freq += iter_freq;\n       new_count += iter_count;\n@@ -1021,7 +1025,7 @@ unroll_loop_runtime_iterations (struct loop *loop)\n   if (extra_zero_check)\n     {\n       /* Add branch for zero iterations.  */\n-      p = REG_BR_PROB_BASE / (max_unroll + 1);\n+      p = profile_probability::always ().apply_scale (1, max_unroll + 1);\n       swtch = ezc_swtch;\n       preheader = split_edge (loop_preheader_edge (loop));\n       /* Recompute frequency/count adjustments since initial peel copy may\n@@ -1039,7 +1043,7 @@ unroll_loop_runtime_iterations (struct loop *loop)\n \n       swtch = split_edge_and_insert (single_succ_edge (swtch), branch_code);\n       set_immediate_dominator (CDI_DOMINATORS, preheader, swtch);\n-      single_succ_edge (swtch)->probability = REG_BR_PROB_BASE - p;\n+      single_succ_edge (swtch)->probability = p.invert ();\n       single_succ_edge (swtch)->count -= iter_count;\n       e = make_edge (swtch, preheader,\n \t\t     single_succ_edge (swtch)->flags & EDGE_IRREDUCIBLE_LOOP);"}, {"sha": "2bb68261bb93f126c0dc9a470bceafc12033c618", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -6482,7 +6482,8 @@ lra_inheritance (void)\n \t  e = find_fallthru_edge (bb->succs);\n \t  if (! e)\n \t    break;\n-\t  if (e->probability < EBB_PROBABILITY_CUTOFF)\n+\t  if (e->probability.initialized_p ()\n+\t      && e->probability.to_reg_br_prob_base () < EBB_PROBABILITY_CUTOFF)\n \t    break;\n \t  bb = bb->next_bb;\n \t}"}, {"sha": "ec47fe4f165315f9f9baf27b9dbd97858f58c69c", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -754,12 +754,12 @@ input_cfg (struct lto_input_block *ib, struct data_in *data_in,\n \t  unsigned int dest_index;\n \t  unsigned int edge_flags;\n \t  basic_block dest;\n-\t  int probability;\n+\t  profile_probability probability;\n \t  profile_count count;\n \t  edge e;\n \n \t  dest_index = streamer_read_uhwi (ib);\n-\t  probability = (int) streamer_read_hwi (ib);\n+\t  probability = profile_probability::stream_in (ib);\n \t  count = profile_count::stream_in (ib).apply_scale\n \t\t\t (count_materialization_scale, REG_BR_PROB_BASE);\n \t  edge_flags = streamer_read_uhwi (ib);"}, {"sha": "f35dd020a519b877d8c5d88ca573666e941f5e22", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -1860,7 +1860,7 @@ output_cfg (struct output_block *ob, struct function *fn)\n       FOR_EACH_EDGE (e, ei, bb->succs)\n \t{\n \t  streamer_write_uhwi (ob, e->dest->index);\n-\t  streamer_write_hwi (ob, e->probability);\n+\t  e->probability.stream_out (ob);\n \t  e->count.stream_out (ob);\n \t  streamer_write_uhwi (ob, e->flags);\n \t}"}, {"sha": "67088506dac9cbdcd4fd40158b3d86c94f54d13c", "filename": "gcc/mcf.c", "status": "modified", "additions": 10, "deletions": 30, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fmcf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fmcf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmcf.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -1231,12 +1231,15 @@ adjust_cfg_counts (fixup_graph_type *fixup_graph)\n \t    }\n \n           if (bb_gcov_count (bb))\n-\t    e->probability = RDIV (REG_BR_PROB_BASE * edge_gcov_count (e),\n-\t\t\t           bb_gcov_count (bb));\n+\t    e->probability = profile_probability::probability_in_gcov_type\n+\t\t\t (edge_gcov_count (e), bb_gcov_count (bb));\n           if (dump_file)\n-\t    fprintf (dump_file, \" = %\" PRId64 \"\\t(%.1f%%)\\n\",\n-\t\t     edge_gcov_count (e),\n-\t\t     e->probability * 100.0 / REG_BR_PROB_BASE);\n+\t    {\n+\t      fprintf (dump_file, \" = %\" PRId64 \"\\t\",\n+\t\t       edge_gcov_count (e));\n+\t      e->probability.dump (dump_file);\n+\t      fprintf (dump_file, \"\\n\");\n+\t    }\n         }\n     }\n \n@@ -1251,31 +1254,8 @@ adjust_cfg_counts (fixup_graph_type *fixup_graph)\n       if (bb_gcov_count (bb))\n         {\n           FOR_EACH_EDGE (e, ei, bb->succs)\n-            e->probability = RDIV (REG_BR_PROB_BASE * edge_gcov_count (e),\n-\t\t\t\t   bb_gcov_count (bb));\n-        }\n-      else\n-        {\n-          int total = 0;\n-          FOR_EACH_EDGE (e, ei, bb->succs)\n-            if (!(e->flags & (EDGE_COMPLEX | EDGE_FAKE)))\n-              total++;\n-          if (total)\n-            {\n-              FOR_EACH_EDGE (e, ei, bb->succs)\n-                {\n-                  if (!(e->flags & (EDGE_COMPLEX | EDGE_FAKE)))\n-                    e->probability = REG_BR_PROB_BASE / total;\n-                  else\n-                    e->probability = 0;\n-                }\n-            }\n-          else\n-            {\n-              total += EDGE_COUNT (bb->succs);\n-              FOR_EACH_EDGE (e, ei, bb->succs)\n-                  e->probability = REG_BR_PROB_BASE / total;\n-            }\n+            e->probability = profile_probability::probability_in_gcov_type\n+\t\t\t\t(edge_gcov_count (e), bb_gcov_count (bb));\n         }\n     }\n "}, {"sha": "4289738e27dd706cf7538b26f6ef3bf6de774900", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -1713,12 +1713,13 @@ sms_schedule (void)\n \t      rtx comp_rtx = gen_rtx_GT (VOIDmode, count_reg,\n \t\t\t\t\t gen_int_mode (stage_count,\n \t\t\t\t\t\t       GET_MODE (count_reg)));\n-\t      unsigned prob = (PROB_SMS_ENOUGH_ITERATIONS\n-\t\t\t       * REG_BR_PROB_BASE) / 100;\n+\t      profile_probability prob = profile_probability::guessed_always ()\n+\t\t\t\t.apply_scale (PROB_SMS_ENOUGH_ITERATIONS, 100);\n \n \t      loop_version (loop, comp_rtx, &condition_bb,\n-\t  \t\t    prob, REG_BR_PROB_BASE - prob,\n-\t\t\t    prob, REG_BR_PROB_BASE - prob,\n+\t  \t\t    prob, prob.invert (),\n+\t\t\t    prob.to_reg_br_prob_base (),\n+\t\t\t    prob.invert ().to_reg_br_prob_base (),\n \t\t\t    true);\n \t     }\n "}, {"sha": "929c53078d5c0840214a04b83fe4e45e74d0cd3f", "filename": "gcc/omp-expand.c", "status": "modified", "additions": 30, "deletions": 25, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fomp-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fomp-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-expand.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -1741,9 +1741,9 @@ expand_omp_for_init_counts (struct omp_for_data *fd, gimple_stmt_iterator *gsi,\n \t\t\t\t       entry_bb);\n \t    }\n \t  ne = make_edge (entry_bb, zero_iter_bb, EDGE_FALSE_VALUE);\n-\t  ne->probability = REG_BR_PROB_BASE / 2000 - 1;\n+\t  ne->probability = profile_probability::very_unlikely ();\n \t  e->flags = EDGE_TRUE_VALUE;\n-\t  e->probability = REG_BR_PROB_BASE - ne->probability;\n+\t  e->probability = ne->probability.invert ();\n \t  if (l2_dom_bb == NULL)\n \t    l2_dom_bb = entry_bb;\n \t  entry_bb = e->dest;\n@@ -1920,7 +1920,7 @@ extract_omp_for_update_vars (struct omp_for_data *fd, basic_block cont_bb,\n       if (i < fd->collapse - 1)\n \t{\n \t  e = make_edge (last_bb, bb, EDGE_FALSE_VALUE);\n-\t  e->probability = REG_BR_PROB_BASE / 8;\n+\t  e->probability = profile_probability::guessed_always ().apply_scale (1, 8);\n \n \t  t = fd->loops[i + 1].n1;\n \t  t = force_gimple_operand_gsi (&gsi, t,\n@@ -1961,7 +1961,7 @@ extract_omp_for_update_vars (struct omp_for_data *fd, basic_block cont_bb,\n \t  stmt = gimple_build_cond_empty (t);\n \t  gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n \t  e = make_edge (bb, body_bb, EDGE_TRUE_VALUE);\n-\t  e->probability = REG_BR_PROB_BASE * 7 / 8;\n+\t  e->probability = profile_probability::guessed_always ().apply_scale (7, 8);\n \t}\n       else\n \tmake_edge (bb, body_bb, EDGE_FALLTHRU);\n@@ -2219,8 +2219,8 @@ expand_omp_ordered_sink (gimple_stmt_iterator *gsi, struct omp_for_data *fd,\n \t\t\t\t   GSI_CONTINUE_LINKING);\n   gsi_insert_after (gsi, gimple_build_cond_empty (cond), GSI_NEW_STMT);\n   edge e3 = make_edge (e1->src, e2->dest, EDGE_FALSE_VALUE);\n-  e3->probability = REG_BR_PROB_BASE / 8;\n-  e1->probability = REG_BR_PROB_BASE - e3->probability;\n+  e3->probability = profile_probability::guessed_always ().apply_scale (1, 8);\n+  e1->probability = e3->probability.invert ();\n   e1->flags = EDGE_TRUE_VALUE;\n   set_immediate_dominator (CDI_DOMINATORS, e2->dest, e1->src);\n \n@@ -2373,9 +2373,9 @@ expand_omp_for_ordered_loops (struct omp_for_data *fd, tree *counts,\n       remove_edge (e1);\n       make_edge (body_bb, new_header, EDGE_FALLTHRU);\n       e3->flags = EDGE_FALSE_VALUE;\n-      e3->probability = REG_BR_PROB_BASE / 8;\n+      e3->probability = profile_probability::guessed_always ().apply_scale (1, 8);\n       e1 = make_edge (new_header, new_body, EDGE_TRUE_VALUE);\n-      e1->probability = REG_BR_PROB_BASE - e3->probability;\n+      e1->probability = e3->probability.invert ();\n \n       set_immediate_dominator (CDI_DOMINATORS, new_header, body_bb);\n       set_immediate_dominator (CDI_DOMINATORS, new_body, new_header);\n@@ -3149,8 +3149,8 @@ expand_omp_for_generic (struct omp_region *region,\n \te->flags = EDGE_TRUE_VALUE;\n       if (e)\n \t{\n-\t  e->probability = REG_BR_PROB_BASE * 7 / 8;\n-\t  find_edge (cont_bb, l2_bb)->probability = REG_BR_PROB_BASE / 8;\n+\t  e->probability = profile_probability::guessed_always ().apply_scale (7, 8);\n+\t  find_edge (cont_bb, l2_bb)->probability = e->probability.invert ();\n \t}\n       else\n \t{\n@@ -3351,9 +3351,9 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n       ep = split_block (entry_bb, cond_stmt);\n       ep->flags = EDGE_TRUE_VALUE;\n       entry_bb = ep->dest;\n-      ep->probability = REG_BR_PROB_BASE - (REG_BR_PROB_BASE / 2000 - 1);\n+      ep->probability = profile_probability::very_likely ();\n       ep = make_edge (ep->src, fin_bb, EDGE_FALSE_VALUE);\n-      ep->probability = REG_BR_PROB_BASE / 2000 - 1;\n+      ep->probability = profile_probability::very_unlikely ();\n       if (gimple_in_ssa_p (cfun))\n \t{\n \t  int dest_idx = find_edge (entry_bb, fin_bb)->dest_idx;\n@@ -3634,10 +3634,10 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n \n   /* Connect all the blocks.  */\n   ep = make_edge (entry_bb, third_bb, EDGE_FALSE_VALUE);\n-  ep->probability = REG_BR_PROB_BASE / 4 * 3;\n+  ep->probability = profile_probability::guessed_always ().apply_scale (3, 4);\n   ep = find_edge (entry_bb, second_bb);\n   ep->flags = EDGE_TRUE_VALUE;\n-  ep->probability = REG_BR_PROB_BASE / 4;\n+  ep->probability = profile_probability::guessed_always ().apply_scale (1, 4);\n   find_edge (third_bb, seq_start_bb)->flags = EDGE_FALSE_VALUE;\n   find_edge (third_bb, fin_bb)->flags = EDGE_TRUE_VALUE;\n \n@@ -3835,9 +3835,9 @@ expand_omp_for_static_chunk (struct omp_region *region,\n       se = split_block (entry_bb, cond_stmt);\n       se->flags = EDGE_TRUE_VALUE;\n       entry_bb = se->dest;\n-      se->probability = REG_BR_PROB_BASE - (REG_BR_PROB_BASE / 2000 - 1);\n+      se->probability = profile_probability::very_likely ();\n       se = make_edge (se->src, fin_bb, EDGE_FALSE_VALUE);\n-      se->probability = REG_BR_PROB_BASE / 2000 - 1;\n+      se->probability = profile_probability::very_unlikely ();\n       if (gimple_in_ssa_p (cfun))\n \t{\n \t  int dest_idx = find_edge (iter_part_bb, fin_bb)->dest_idx;\n@@ -4448,8 +4448,8 @@ expand_cilk_for (struct omp_region *region, struct omp_for_data *fd)\n \n     }\n   ne->flags = EDGE_FALSE_VALUE;\n-  e->probability = REG_BR_PROB_BASE * 7 / 8;\n-  ne->probability = REG_BR_PROB_BASE / 8;\n+  e->probability = profile_probability::guessed_always ().apply_scale (7, 8);\n+  ne->probability = e->probability.invert ();\n \n   set_immediate_dominator (CDI_DOMINATORS, l1_bb, entry_bb);\n   set_immediate_dominator (CDI_DOMINATORS, l2_bb, l2_dom_bb);\n@@ -4810,8 +4810,8 @@ expand_omp_simd (struct omp_region *region, struct omp_for_data *fd)\n \n     }\n   ne->flags = EDGE_FALSE_VALUE;\n-  e->probability = REG_BR_PROB_BASE * 7 / 8;\n-  ne->probability = REG_BR_PROB_BASE / 8;\n+  e->probability = profile_probability::guessed_always ().apply_scale (7, 8);\n+  ne->probability = e->probability.invert ();\n \n   set_immediate_dominator (CDI_DOMINATORS, l1_bb, entry_bb);\n   set_immediate_dominator (CDI_DOMINATORS, l0_bb, l1_bb);\n@@ -4824,8 +4824,10 @@ expand_omp_simd (struct omp_region *region, struct omp_for_data *fd)\n       gsi_insert_after (&gsi, cond_stmt, GSI_NEW_STMT);\n       make_edge (entry_bb, l2_bb, EDGE_FALSE_VALUE);\n       FALLTHRU_EDGE (entry_bb)->flags = EDGE_TRUE_VALUE;\n-      FALLTHRU_EDGE (entry_bb)->probability = REG_BR_PROB_BASE * 7 / 8;\n-      BRANCH_EDGE (entry_bb)->probability = REG_BR_PROB_BASE / 8;\n+      FALLTHRU_EDGE (entry_bb)->probability\n+\t = profile_probability::guessed_always ().apply_scale (7, 8);\n+      BRANCH_EDGE (entry_bb)->probability \n+\t = FALLTHRU_EDGE (entry_bb)->probability.invert ();\n       l2_dom_bb = entry_bb;\n     }\n   set_immediate_dominator (CDI_DOMINATORS, l2_bb, l2_dom_bb);\n@@ -5018,9 +5020,9 @@ expand_omp_taskloop_for_outer (struct omp_region *region,\n   gsi = gsi_last_bb (exit_bb);\n   gsi_remove (&gsi, true);\n \n-  FALLTHRU_EDGE (entry_bb)->probability = REG_BR_PROB_BASE;\n+  FALLTHRU_EDGE (entry_bb)->probability = profile_probability::always ();\n   remove_edge (BRANCH_EDGE (entry_bb));\n-  FALLTHRU_EDGE (cont_bb)->probability = REG_BR_PROB_BASE;\n+  FALLTHRU_EDGE (cont_bb)->probability = profile_probability::always ();\n   remove_edge (BRANCH_EDGE (cont_bb));\n   set_immediate_dominator (CDI_DOMINATORS, exit_bb, cont_bb);\n   set_immediate_dominator (CDI_DOMINATORS, region->entry,\n@@ -5208,7 +5210,7 @@ expand_omp_taskloop_for_inner (struct omp_region *region,\n   gsi = gsi_last_bb (exit_bb);\n   gsi_remove (&gsi, true);\n \n-  FALLTHRU_EDGE (entry_bb)->probability = REG_BR_PROB_BASE;\n+  FALLTHRU_EDGE (entry_bb)->probability = profile_probability::always ();\n   if (!broken_loop)\n     remove_edge (BRANCH_EDGE (entry_bb));\n   else\n@@ -6604,8 +6606,11 @@ expand_omp_atomic_pipeline (basic_block load_bb, basic_block store_bb,\n   e = single_succ_edge (store_bb);\n   e->flags &= ~EDGE_FALLTHRU;\n   e->flags |= EDGE_FALSE_VALUE;\n+  /* Expect no looping.  */\n+  e->probability = profile_probability::guessed_always ();\n \n   e = make_edge (store_bb, loop_header, EDGE_TRUE_VALUE);\n+  e->probability = profile_probability::guessed_never ();\n \n   /* Copy the new value to loadedi (we already did that before the condition\n      if we are not in SSA).  */"}, {"sha": "a1a563e80943cb048ff8913146f18cd73f2ec2d9", "filename": "gcc/omp-simd-clone.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fomp-simd-clone.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fomp-simd-clone.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-simd-clone.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -1151,8 +1151,7 @@ simd_clone_adjust (struct cgraph_node *node)\n \n   if (incr_bb)\n     {\n-      edge e = make_edge (incr_bb, EXIT_BLOCK_PTR_FOR_FN (cfun), 0);\n-      e->probability = REG_BR_PROB_BASE;\n+      make_single_succ_edge (incr_bb, EXIT_BLOCK_PTR_FOR_FN (cfun), 0);\n       gsi = gsi_last_bb (incr_bb);\n       iter2 = make_ssa_name (iter);\n       g = gimple_build_assign (iter2, PLUS_EXPR, iter1,\n@@ -1264,7 +1263,10 @@ simd_clone_adjust (struct cgraph_node *node)\n \n       redirect_edge_succ (FALLTHRU_EDGE (latch_bb), body_bb);\n \n-      make_edge (incr_bb, new_exit_bb, EDGE_FALSE_VALUE);\n+      edge new_e = make_edge (incr_bb, new_exit_bb, EDGE_FALSE_VALUE);\n+\n+      /* FIXME: Do we need to distribute probabilities for the conditional? */\n+      new_e->probability = profile_probability::guessed_never ();\n       /* The successor of incr_bb is already pointing to latch_bb; just\n \t change the flags.\n \t make_edge (incr_bb, latch_bb, EDGE_TRUE_VALUE);  */"}, {"sha": "9598adf84bf25662e5d59160cee34eb7477a07d9", "filename": "gcc/optabs.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -693,7 +693,8 @@ expand_doubleword_shift (machine_mode op1_mode, optab binoptab,\n \n   NO_DEFER_POP;\n   do_compare_rtx_and_jump (cmp1, cmp2, cmp_code, false, op1_mode,\n-\t\t\t   0, 0, subword_label, -1);\n+\t\t\t   0, 0, subword_label,\n+\t\t\t   profile_probability::uninitialized ());\n   OK_DEFER_POP;\n \n   if (!expand_superword_shift (binoptab, outof_input, superword_op1,\n@@ -3187,7 +3188,8 @@ expand_abs (machine_mode mode, rtx op0, rtx target,\n   NO_DEFER_POP;\n \n   do_compare_rtx_and_jump (target, CONST0_RTX (mode), GE, 0, mode,\n-\t\t\t   NULL_RTX, NULL, op1, -1);\n+\t\t\t   NULL_RTX, NULL, op1,\n+\t\t\t   profile_probability::uninitialized ());\n \n   op0 = expand_unop (mode, result_unsignedp ? neg_optab : negv_optab,\n                      target, target, 0);\n@@ -3979,7 +3981,8 @@ prepare_operand (enum insn_code icode, rtx x, int opnum, machine_mode mode,\n    we can do the branch.  */\n \n static void\n-emit_cmp_and_jump_insn_1 (rtx test, machine_mode mode, rtx label, int prob)\n+emit_cmp_and_jump_insn_1 (rtx test, machine_mode mode, rtx label,\n+\t\t\t  profile_probability prob)\n {\n   machine_mode optab_mode;\n   enum mode_class mclass;\n@@ -3994,13 +3997,13 @@ emit_cmp_and_jump_insn_1 (rtx test, machine_mode mode, rtx label, int prob)\n   gcc_assert (insn_operand_matches (icode, 0, test));\n   insn = emit_jump_insn (GEN_FCN (icode) (test, XEXP (test, 0),\n                                           XEXP (test, 1), label));\n-  if (prob != -1\n+  if (prob.initialized_p ()\n       && profile_status_for_fn (cfun) != PROFILE_ABSENT\n       && insn\n       && JUMP_P (insn)\n       && any_condjump_p (insn)\n       && !find_reg_note (insn, REG_BR_PROB, 0))\n-    add_int_reg_note (insn, REG_BR_PROB, prob);\n+    add_int_reg_note (insn, REG_BR_PROB, prob.to_reg_br_prob_base ());\n }\n \n /* Generate code to compare X with Y so that the condition codes are\n@@ -4025,7 +4028,7 @@ emit_cmp_and_jump_insn_1 (rtx test, machine_mode mode, rtx label, int prob)\n void\n emit_cmp_and_jump_insns (rtx x, rtx y, enum rtx_code comparison, rtx size,\n \t\t\t machine_mode mode, int unsignedp, rtx label,\n-                         int prob)\n+                         profile_probability prob)\n {\n   rtx op0 = x, op1 = y;\n   rtx test;\n@@ -5856,7 +5859,8 @@ expand_compare_and_swap_loop (rtx mem, rtx old_reg, rtx new_reg, rtx seq)\n \n   /* Mark this jump predicted not taken.  */\n   emit_cmp_and_jump_insns (success, const0_rtx, EQ, const0_rtx,\n-\t\t\t   GET_MODE (success), 1, label, 0);\n+\t\t\t   GET_MODE (success), 1, label,\n+\t\t\t   profile_probability::guessed_never ());\n   return true;\n }\n "}, {"sha": "07d07fe836658b4be0be4a3b04dce47cf27165fc", "filename": "gcc/optabs.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -247,7 +247,9 @@ extern rtx prepare_operand (enum insn_code, rtx, int, machine_mode,\n /* Emit a pair of rtl insns to compare two rtx's and to jump\n    to a label if the comparison is true.  */\n extern void emit_cmp_and_jump_insns (rtx, rtx, enum rtx_code, rtx,\n-\t\t\t\t     machine_mode, int, rtx, int prob=-1);\n+\t\t\t\t     machine_mode, int, rtx,\n+\t\t\t\t     profile_probability prob\n+\t\t\t\t\t= profile_probability::uninitialized ());\n \n /* Generate code to indirectly jump to a location given in the rtx LOC.  */\n extern void emit_indirect_jump (rtx);"}, {"sha": "4ee36ffc8c3e00bff1a05b6a005855009af12fe3", "filename": "gcc/predict.c", "status": "modified", "additions": 68, "deletions": 45, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -58,6 +58,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ipa-utils.h\"\n #include \"gimple-pretty-print.h\"\n #include \"selftest.h\"\n+#include \"cfgrtl.h\"\n \n /* Enum with reasons why a predictor is ignored.  */\n \n@@ -404,11 +405,11 @@ optimize_loop_nest_for_size_p (struct loop *loop)\n bool\n predictable_edge_p (edge e)\n {\n-  if (profile_status_for_fn (cfun) == PROFILE_ABSENT)\n+  if (!e->probability.initialized_p ())\n     return false;\n-  if ((e->probability\n+  if ((e->probability.to_reg_br_prob_base ()\n        <= PARAM_VALUE (PARAM_PREDICTABLE_BRANCH_OUTCOME) * REG_BR_PROB_BASE / 100)\n-      || (REG_BR_PROB_BASE - e->probability\n+      || (REG_BR_PROB_BASE - e->probability.to_reg_br_prob_base ()\n           <= PARAM_VALUE (PARAM_PREDICTABLE_BRANCH_OUTCOME) * REG_BR_PROB_BASE / 100))\n     return true;\n   return false;\n@@ -539,7 +540,7 @@ probability_reliable_p (int prob)\n bool\n edge_probability_reliable_p (const_edge e)\n {\n-  return probability_reliable_p (e->probability);\n+  return e->probability.reliable_p ();\n }\n \n /* Same predicate as edge_probability_reliable_p, working on notes.  */\n@@ -859,12 +860,13 @@ set_even_probabilities (basic_block bb,\n     if (!unlikely_executed_edge_p (e))\n       {\n \tif (unlikely_edges != NULL && unlikely_edges->contains (e))\n-\t  e->probability = PROB_VERY_UNLIKELY;\n+\t  e->probability = profile_probability::very_unlikely ();\n \telse\n-\t  e->probability = (REG_BR_PROB_BASE + c / 2) / c;\n+\t  e->probability = profile_probability::guessed_always ()\n+\t\t\t\t.apply_scale (1, c);\n       }\n     else\n-      e->probability = 0;\n+      e->probability = profile_probability::never ();\n }\n \n /* Combine all REG_BR_PRED notes into single probability and attach REG_BR_PROB\n@@ -971,20 +973,23 @@ combine_predictions_for_insn (rtx_insn *insn, basic_block bb)\n \t conditional jump.  */\n       if (!single_succ_p (bb))\n \t{\n-\t  BRANCH_EDGE (bb)->probability = combined_probability;\n+\t  BRANCH_EDGE (bb)->probability\n+\t    = profile_probability::from_reg_br_prob_base (combined_probability);\n \t  FALLTHRU_EDGE (bb)->probability\n-\t    = REG_BR_PROB_BASE - combined_probability;\n+\t    = BRANCH_EDGE (bb)->probability.invert ();\n \t}\n     }\n   else if (!single_succ_p (bb))\n     {\n       int prob = XINT (prob_note, 0);\n \n-      BRANCH_EDGE (bb)->probability = prob;\n-      FALLTHRU_EDGE (bb)->probability = REG_BR_PROB_BASE - prob;\n+      BRANCH_EDGE (bb)->probability\n+\t = profile_probability::from_reg_br_prob_base (prob);\n+      FALLTHRU_EDGE (bb)->probability\n+\t = BRANCH_EDGE (bb)->probability.invert ();\n     }\n   else\n-    single_succ_edge (bb)->probability = REG_BR_PROB_BASE;\n+    single_succ_edge (bb)->probability = profile_probability::always ();\n }\n \n /* Edge prediction hash traits.  */\n@@ -1129,6 +1134,8 @@ combine_predictions_for_bb (basic_block bb, bool dry_run)\n \tif (!first)\n \t  first = e;\n       }\n+    else if (!e->probability.initialized_p ())\n+      e->probability = profile_probability::never ();\n \n   /* When there is no successor or only one choice, prediction is easy.\n \n@@ -1173,8 +1180,8 @@ combine_predictions_for_bb (basic_block bb, bool dry_run)\n \t\t       nedges, bb->index);\n \t      FOR_EACH_EDGE (e, ei, bb->succs)\n \t\tif (!unlikely_executed_edge_p (e))\n-\t\t  dump_prediction (dump_file, PRED_COMBINED, e->probability,\n-\t\t   bb, REASON_NONE, e);\n+\t\t  dump_prediction (dump_file, PRED_COMBINED,\n+\t\t   e->probability.to_reg_br_prob_base (), bb, REASON_NONE, e);\n \t    }\n \t}\n       return;\n@@ -1284,8 +1291,9 @@ combine_predictions_for_bb (basic_block bb, bool dry_run)\n \n   if (!bb->count.initialized_p () && !dry_run)\n     {\n-      first->probability = combined_probability;\n-      second->probability = REG_BR_PROB_BASE - combined_probability;\n+      first->probability\n+\t = profile_probability::from_reg_br_prob_base (combined_probability);\n+      second->probability = first->probability.invert ();\n     }\n }\n \n@@ -3042,7 +3050,7 @@ propagate_freq (basic_block head, bitmap tovisit)\n \t\t\t\t  * BLOCK_INFO (e->src)->frequency /\n \t\t\t\t  REG_BR_PROB_BASE);  */\n \n-\t\tsreal tmp = e->probability;\n+\t\tsreal tmp = e->probability.to_reg_br_prob_base ();\n \t\ttmp *= BLOCK_INFO (e->src)->frequency;\n \t\ttmp *= real_inv_br_prob_base;\n \t\tfrequency += tmp;\n@@ -3074,7 +3082,7 @@ propagate_freq (basic_block head, bitmap tovisit)\n \t     = ((e->probability * BLOCK_INFO (bb)->frequency)\n \t     / REG_BR_PROB_BASE); */\n \n-\t  sreal tmp = e->probability;\n+\t  sreal tmp = e->probability.to_reg_br_prob_base ();\n \t  tmp *= BLOCK_INFO (bb)->frequency;\n \t  EDGE_INFO (e)->back_edge_prob = tmp * real_inv_br_prob_base;\n \t}\n@@ -3534,7 +3542,7 @@ estimate_bb_frequencies (bool force)\n       mark_dfs_back_edges ();\n \n       single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun))->probability =\n-\t REG_BR_PROB_BASE;\n+\t profile_probability::always ();\n \n       /* Set up block info for each basic block.  */\n       alloc_aux_for_blocks (sizeof (block_info));\n@@ -3546,7 +3554,8 @@ estimate_bb_frequencies (bool force)\n \n \t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t    {\n-\t      EDGE_INFO (e)->back_edge_prob = e->probability;\n+\t      EDGE_INFO (e)->back_edge_prob\n+\t\t = e->probability.to_reg_br_prob_base ();\n \t      EDGE_INFO (e)->back_edge_prob *= real_inv_br_prob_base;\n \t    }\n \t}\n@@ -3898,16 +3907,18 @@ void\n force_edge_cold (edge e, bool impossible)\n {\n   profile_count count_sum = profile_count::zero ();\n-  int prob_sum = 0;\n+  profile_probability prob_sum = profile_probability::never ();\n   edge_iterator ei;\n   edge e2;\n   profile_count old_count = e->count;\n-  int old_probability = e->probability;\n-  int prob_scale = REG_BR_PROB_BASE;\n+  profile_probability old_probability = e->probability;\n   bool uninitialized_exit = false;\n \n+  profile_probability goal = (impossible ? profile_probability::never ()\n+\t\t\t      : profile_probability::very_unlikely ());\n+\n   /* If edge is already improbably or cold, just return.  */\n-  if (e->probability <= (impossible ? PROB_VERY_UNLIKELY : 0)\n+  if (e->probability <= goal\n       && (!impossible || e->count == profile_count::zero ()))\n     return;\n   FOR_EACH_EDGE (e2, ei, e->src->succs)\n@@ -3917,24 +3928,26 @@ force_edge_cold (edge e, bool impossible)\n \t  count_sum += e2->count;\n \telse\n \t  uninitialized_exit = true;\n-\tprob_sum += e2->probability;\n+\tif (e2->probability.initialized_p ())\n+\t  prob_sum += e2->probability;\n       }\n \n   /* If there are other edges out of e->src, redistribute probabilitity\n      there.  */\n-  if (prob_sum)\n+  if (prob_sum > profile_probability::never ())\n     {\n-      e->probability\n-\t = MIN (e->probability, impossible ? 0 : PROB_VERY_UNLIKELY);\n+      if (!(e->probability < goal))\n+\te->probability = goal;\n       if (impossible)\n \te->count = profile_count::zero ();\n-      else if (old_probability)\n-\te->count = e->count.apply_scale (e->probability, old_probability);\n+      else if (old_probability > profile_probability::never ())\n+\te->count = e->count.apply_probability (e->probability\n+\t\t\t\t\t       / old_probability);\n       else\n         e->count = e->count.apply_scale (1, REG_BR_PROB_BASE);\n \n-      prob_scale = RDIV ((REG_BR_PROB_BASE - e->probability) * REG_BR_PROB_BASE,\n-\t\t\t prob_sum);\n+      profile_probability prob_comp = prob_sum / e->probability.invert ();\n+\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"Making edge %i->%i %s by redistributing \"\n \t\t \"probability to other edges.\\n\",\n@@ -3946,30 +3959,39 @@ force_edge_cold (edge e, bool impossible)\n \t  {\n \t    if (count_sum > 0)\n \t      e2->count.apply_scale (count_sum2, count_sum);\n-\t    e2->probability = RDIV (e2->probability * prob_scale,\n-\t\t\t\t    REG_BR_PROB_BASE);\n+\t    e2->probability /= prob_comp;\n \t  }\n+      if (current_ir_type () != IR_GIMPLE)\n+\tupdate_br_prob_note (e->src);\n     }\n   /* If all edges out of e->src are unlikely, the basic block itself\n      is unlikely.  */\n   else\n     {\n-      e->probability = REG_BR_PROB_BASE;\n+      e->probability = profile_probability::always ();\n+      if (current_ir_type () != IR_GIMPLE)\n+\tupdate_br_prob_note (e->src);\n       if (e->src->count == profile_count::zero ())\n \treturn;\n       if (count_sum == profile_count::zero () && !uninitialized_exit\n \t  && impossible)\n \t{\n \t  bool found = false;\n-\t  for (gimple_stmt_iterator gsi = gsi_start_bb (e->src);\n-\t       !gsi_end_p (gsi); gsi_next (&gsi))\n-\t    {\n-\t      if (stmt_can_terminate_bb_p (gsi_stmt (gsi)))\n-\t\t{\n-\t\t  found = true;\n-\t          break;\n-\t\t}\n-\t    }\n+\t  if (e->src == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n+\t    ;\n+\t  else if (current_ir_type () == IR_GIMPLE)\n+\t    for (gimple_stmt_iterator gsi = gsi_start_bb (e->src);\n+\t         !gsi_end_p (gsi); gsi_next (&gsi))\n+\t      {\n+\t        if (stmt_can_terminate_bb_p (gsi_stmt (gsi)))\n+\t\t  {\n+\t\t    found = true;\n+\t            break;\n+\t\t  }\n+\t      }\n+\t  /* FIXME: Implement RTL path.  */\n+\t  else \n+\t    found = true;\n \t  if (!found)\n \t    {\n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -3989,7 +4011,8 @@ force_edge_cold (edge e, bool impossible)\n \t This in general is difficult task to do, but handle special case when\n \t BB has only one predecestor.  This is common case when we are updating\n \t after loop transforms.  */\n-      if (!prob_sum && count_sum == profile_count::zero ()\n+      if (!(prob_sum > profile_probability::never ())\n+\t  && count_sum == profile_count::zero ()\n \t  && single_pred_p (e->src) && e->src->frequency > (impossible ? 0 : 1))\n \t{\n \t  int old_frequency = e->src->frequency;"}, {"sha": "4d22428a195bc6f03c0023734a0a4ea8cc765296", "filename": "gcc/profile-count.c", "status": "modified", "additions": 114, "deletions": 9, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fprofile-count.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fprofile-count.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile-count.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -31,6 +31,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"data-streamer.h\"\n #include \"cgraph.h\"\n \n+/* Dump THIS to F.  */\n+\n void\n profile_count::dump (FILE *f) const\n {\n@@ -39,53 +41,156 @@ profile_count::dump (FILE *f) const\n   else\n     {\n       fprintf (f, \"%\" PRId64, m_val);\n-      if (m_quality == count_adjusted)\n-\tfprintf (f, \"(adjusted)\");\n-      else if (m_quality == count_afdo)\n-\tfprintf (f, \"(auto FDO)\");\n-      else if (m_quality == count_guessed)\n-\tfprintf (f, \"(guessed)\");\n+      if (m_quality == profile_adjusted)\n+\tfprintf (f, \" (adjusted)\");\n+      else if (m_quality == profile_afdo)\n+\tfprintf (f, \" (auto FDO)\");\n+      else if (m_quality == profile_guessed)\n+\tfprintf (f, \" (guessed)\");\n     }\n }\n \n+/* Dump THIS to stderr.  */\n+\n void\n profile_count::debug () const\n {\n   dump (stderr);\n+  fprintf (stderr, \"\\n\");\n }\n \n+/* Return true if THIS differs from OTHER; tolerate small diferences.  */\n+\n bool\n profile_count::differs_from_p (profile_count other) const\n {\n   if (!initialized_p () || !other.initialized_p ())\n     return false;\n-  if (m_val - other.m_val < 100 || other.m_val - m_val < 100)\n+  if ((uint64_t)m_val - (uint64_t)other.m_val < 100\n+      || (uint64_t)other.m_val - (uint64_t)m_val < 100)\n     return false;\n   if (!other.m_val)\n     return true;\n-  int64_t ratio = m_val * 100 / other.m_val;\n+  int64_t ratio = (int64_t)m_val * 100 / other.m_val;\n   return ratio < 99 || ratio > 101;\n }\n \n+/* Stream THIS from IB.  */\n+\n profile_count\n profile_count::stream_in (struct lto_input_block *ib)\n {\n   profile_count ret;\n   ret.m_val = streamer_read_gcov_count (ib);\n-  ret.m_quality = (profile_count_quality) streamer_read_uhwi (ib);\n+  ret.m_quality = (profile_quality) streamer_read_uhwi (ib);\n   return ret;\n }\n \n+/* Stream THIS to OB.  */\n+\n void\n profile_count::stream_out (struct output_block *ob)\n {\n   streamer_write_gcov_count (ob, m_val);\n   streamer_write_uhwi (ob, m_quality);\n }\n \n+/* Stream THIS to OB.  */\n+\n void\n profile_count::stream_out (struct lto_output_stream *ob)\n {\n   streamer_write_gcov_count_stream (ob, m_val);\n   streamer_write_uhwi_stream (ob, m_quality);\n }\n+\n+/* Dump THIS to F.  */\n+\n+void\n+profile_probability::dump (FILE *f) const\n+{\n+  if (!initialized_p ())\n+    fprintf (f, \"uninitialized\");\n+  else\n+    {\n+      /* Make difference between 0.00 as a roundoff error and actual 0.\n+\t Similarly for 1.  */\n+      if (m_val == 0)\n+        fprintf (f, \"never\");\n+      else if (m_val == max_probability)\n+        fprintf (f, \"always\");\n+      else\n+        fprintf (f, \"%3.1f%%\", (double)m_val * 100 / max_probability);\n+      if (m_quality == profile_adjusted)\n+\tfprintf (f, \" (adjusted)\");\n+      else if (m_quality == profile_afdo)\n+\tfprintf (f, \" (auto FDO)\");\n+      else if (m_quality == profile_guessed)\n+\tfprintf (f, \" (guessed)\");\n+    }\n+}\n+\n+/* Dump THIS to stderr.  */\n+\n+void\n+profile_probability::debug () const\n+{\n+  dump (stderr);\n+  fprintf (stderr, \"\\n\");\n+}\n+\n+/* Return true if THIS differs from OTHER; tolerate small diferences.  */\n+\n+bool\n+profile_probability::differs_from_p (profile_probability other) const\n+{\n+  if (!initialized_p () || !other.initialized_p ())\n+    return false;\n+  if ((uint64_t)m_val - (uint64_t)other.m_val < 10\n+      || (uint64_t)other.m_val - (uint64_t)m_val < 10)\n+    return false;\n+  if (!other.m_val)\n+    return true;\n+  int64_t ratio = m_val * 100 / other.m_val;\n+  return ratio < 99 || ratio > 101;\n+}\n+\n+/* Return true if THIS differs significantly from OTHER.  */\n+\n+bool\n+profile_probability::differs_lot_from_p (profile_probability other) const\n+{\n+  if (!initialized_p () || !other.initialized_p ())\n+    return false;\n+  uint32_t d = m_val > other.m_val ? m_val - other.m_val : other.m_val - m_val;\n+  return d > max_probability / 2;\n+}\n+\n+/* Stream THIS from IB.  */\n+\n+profile_probability\n+profile_probability::stream_in (struct lto_input_block *ib)\n+{\n+  profile_probability ret;\n+  ret.m_val = streamer_read_uhwi (ib);\n+  ret.m_quality = (profile_quality) streamer_read_uhwi (ib);\n+  return ret;\n+}\n+\n+/* Stream THIS to OB.  */\n+\n+void\n+profile_probability::stream_out (struct output_block *ob)\n+{\n+  streamer_write_uhwi (ob, m_val);\n+  streamer_write_uhwi (ob, m_quality);\n+}\n+\n+/* Stream THIS to OB.  */\n+\n+void\n+profile_probability::stream_out (struct lto_output_stream *ob)\n+{\n+  streamer_write_uhwi_stream (ob, m_val);\n+  streamer_write_uhwi_stream (ob, m_quality);\n+}"}, {"sha": "461dac6c495e72190cbf9c9e8c1273d91f32ddab", "filename": "gcc/profile-count.h", "status": "modified", "additions": 458, "deletions": 22, "changes": 480, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fprofile-count.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fprofile-count.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile-count.h?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -23,26 +23,442 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Quality of the proflie count.  Because gengtype does not support enums\n    inside of clases, this is in global namespace.  */\n-enum profile_count_quality {\n+enum profile_quality {\n   /* Profile is based on static branch prediction heuristics.  It may or may\n      not reflect the reality.  */\n-  count_guessed = 0,\n+  profile_guessed = 0,\n   /* Profile was determined by autofdo.  */\n-  count_afdo = 1,\n+  profile_afdo = 1,\n   /* Profile was originally based on feedback but it was adjusted \n      by code duplicating optimization.  It may not precisely reflect the\n      particular code path.  */\n-  count_adjusted = 2,\n+  profile_adjusted = 2,\n   /* Profile was read from profile feedback or determined by accurate static\n      method.  */\n-  count_read = 3\n+  profile_precise = 3\n };\n \n /* The base value for branch probability notes and edge probabilities.  */\n #define REG_BR_PROB_BASE  10000\n \n #define RDIV(X,Y) (((X) + (Y) / 2) / (Y))\n \n+/* Data type to hold probabilities.  It implement fixed point arithmetics\n+   with capping so probability is always in range [0,1] and scaling requiring\n+   values greater than 1 needs to be represented otherwise.\n+\n+   In addition to actual value the quality of profile is tracked and propagated\n+   through all operations.  Special value UNINITIALIZED is used for probabilities\n+   that has not been detemrined yet (for example bacause of\n+   -fno-guess-branch-probability)\n+\n+   Typically probabilities are derived from profile feedback (via\n+   probability_in_gcov_type), autoFDO or guessed statically and then propagated\n+   thorough the compilation.\n+\n+   Named probabilities are available:\n+     - never           (0 probability)\n+     - guessed_never\n+     - very_unlikely   (1/2000 probability)\n+     - unlikely        (1/5 probablity)\n+     - even            (1/2 probability)\n+     - likely          (4/5 probability)\n+     - very_likely     (1999/2000 probability)\n+     - guessed_always\n+     - always\n+\n+   Named probabilities except for never/always are assumed to be statically\n+   guessed and thus not necessarily acurate.  The difference between never\n+   and guessedn never is that the first one should be used only in case that\n+   well behaving program will very likely not execute the \"never\" path.\n+   For example if the path is going to abort () call or it exception handling.\n+\n+   Alawyas and guessted_always probabilities are symmetric.\n+\n+   For legacy code we support conversion to/from REG_BR_PROB_BASE based fixpoint\n+   integer arithmetics. Once the code is converted to branch probabiitlies,\n+   these conversions will probably go away because they are lossy.\n+*/\n+\n+class GTY((user)) profile_probability\n+{\n+  /* For now use values in range 0...REG_BR_PROB_BASE.  Later we can use full\n+     precision of 30 bits available.  */\n+\n+  static const int n_bits = 30;\n+  static const uint32_t max_probability = REG_BR_PROB_BASE;\n+  static const uint32_t uninitialized_probability = ((uint32_t) 1 << n_bits) - 1;\n+\n+  uint32_t m_val : 30;\n+  enum profile_quality m_quality : 2;\n+\n+  friend class profile_count;\n+public:\n+\n+  /* Named probabilities.  */\n+  static profile_probability never ()\n+    {\n+      profile_probability ret;\n+      ret.m_val = 0;\n+      ret.m_quality = profile_precise;\n+      return ret;\n+    }\n+  static profile_probability guessed_never ()\n+    {\n+      profile_probability ret;\n+      ret.m_val = 0;\n+      ret.m_quality = profile_guessed;\n+      return ret;\n+    }\n+  static profile_probability very_unlikely ()\n+    {\n+      /* Be consistent with PROB_VERY_UNLIKELY in predict.h.  */\n+      profile_probability r\n+\t = profile_probability::always ().apply_scale (1, 2000);\n+      r.m_val--;\n+      return r;\n+    }\n+  static profile_probability unlikely ()\n+    {\n+      /* Be consistent with PROB_VERY_LIKELY in predict.h.  */\n+      profile_probability r\n+\t = profile_probability::always ().apply_scale (1, 5);\n+      r.m_val--;\n+      return r;\n+    }\n+  static profile_probability even ()\n+    {\n+      return profile_probability::always ().apply_scale (1, 2);\n+    }\n+  static profile_probability very_likely ()\n+    {\n+      return profile_probability::always () - very_unlikely ();\n+    }\n+  static profile_probability likely ()\n+    {\n+      return profile_probability::always () - unlikely ();\n+    }\n+  static profile_probability guessed_always ()\n+    {\n+      profile_probability ret;\n+      ret.m_val = max_probability;\n+      ret.m_quality = profile_guessed;\n+      return ret;\n+    }\n+  static profile_probability always ()\n+    {\n+      profile_probability ret;\n+      ret.m_val = max_probability;\n+      ret.m_quality = profile_precise;\n+      return ret;\n+    }\n+  /* Probabilities which has not been initialized. Either because\n+     initialization did not happen yet or because profile is unknown.  */\n+  static profile_probability uninitialized ()\n+    {\n+      profile_probability c;\n+      c.m_val = uninitialized_probability;\n+      c.m_quality = profile_guessed;\n+      return c;\n+    }\n+\n+\n+  /* Return true if value has been initialized.  */\n+  bool initialized_p () const\n+    {\n+      return m_val != uninitialized_probability;\n+    }\n+  /* Return true if value can be trusted.  */\n+  bool reliable_p () const\n+    {\n+      return initialized_p ();\n+    }\n+\n+  /* Conversion from and to REG_BR_PROB_BASE integer fixpoint arithmetics.\n+     this is mostly to support legacy code and hsould go away.  */\n+  static profile_probability from_reg_br_prob_base (int v)\n+    {\n+      profile_probability ret;\n+      gcc_checking_assert (v >= 0 && v <= REG_BR_PROB_BASE);\n+      ret.m_val = RDIV (v * max_probability, REG_BR_PROB_BASE);\n+      ret.m_quality = profile_guessed;\n+      return ret;\n+    }\n+  int to_reg_br_prob_base () const\n+    {\n+      gcc_checking_assert (initialized_p ());\n+      return RDIV (m_val * REG_BR_PROB_BASE, max_probability);\n+    }\n+\n+  /* Return VAL1/VAL2.  */\n+  static profile_probability probability_in_gcov_type\n+\t\t\t\t (gcov_type val1, gcov_type val2)\n+    {\n+      profile_probability ret;\n+      gcc_checking_assert (val1 >= 0 && val2 > 0);\n+      if (val1 > val2)\n+\tret.m_val = max_probability;\n+      else\n+        ret.m_val = RDIV (val1 * max_probability, val2);\n+      ret.m_quality = profile_precise;\n+      return ret;\n+    }\n+\n+  /* Basic operations.  */\n+  bool operator== (const profile_probability &other) const\n+    {\n+      return m_val == other.m_val && m_quality == other.m_quality;\n+    }\n+  profile_probability operator+ (const profile_probability &other) const\n+    {\n+      if (other == profile_probability::never ())\n+\treturn *this;\n+      if (*this == profile_probability::never ())\n+\treturn other;\n+      if (!initialized_p () || !other.initialized_p ())\n+\treturn profile_probability::uninitialized ();\n+\n+      profile_probability ret;\n+      ret.m_val = MIN ((uint32_t)(m_val + other.m_val), max_probability);\n+      ret.m_quality = MIN (m_quality, other.m_quality);\n+      return ret;\n+    }\n+  profile_probability &operator+= (const profile_probability &other)\n+    {\n+      if (other == profile_probability::never ())\n+\treturn *this;\n+      if (*this == profile_probability::never ())\n+\t{\n+\t  *this = other;\n+\t  return *this;\n+\t}\n+      if (!initialized_p () || !other.initialized_p ())\n+\treturn *this = profile_probability::uninitialized ();\n+      else\n+\t{\n+\t  m_val = MIN ((uint32_t)(m_val + other.m_val), max_probability);\n+          m_quality = MIN (m_quality, other.m_quality);\n+\t}\n+      return *this;\n+    }\n+  profile_probability operator- (const profile_probability &other) const\n+    {\n+      if (*this == profile_probability::never ()\n+\t  || other == profile_probability::never ())\n+\treturn *this;\n+      if (!initialized_p () || !other.initialized_p ())\n+\treturn profile_probability::uninitialized ();\n+      profile_probability ret;\n+      ret.m_val = m_val >= other.m_val ? m_val - other.m_val : 0;\n+      ret.m_quality = MIN (m_quality, other.m_quality);\n+      return ret;\n+    }\n+  profile_probability &operator-= (const profile_probability &other)\n+    {\n+      if (*this == profile_probability::never ()\n+\t  || other == profile_probability::never ())\n+\treturn *this;\n+      if (!initialized_p () || !other.initialized_p ())\n+\treturn *this = profile_probability::uninitialized ();\n+      else\n+\t{\n+\t  m_val = m_val >= other.m_val ? m_val - other.m_val : 0;\n+          m_quality = MIN (m_quality, other.m_quality);\n+\t}\n+      return *this;\n+    }\n+  profile_probability operator* (const profile_probability &other) const\n+    {\n+      if (*this == profile_probability::never ()\n+\t  || other == profile_probability::never ())\n+\treturn profile_probability::never ();\n+      if (!initialized_p () || !other.initialized_p ())\n+\treturn profile_probability::uninitialized ();\n+      profile_probability ret;\n+      ret.m_val = RDIV ((uint64_t)m_val * other.m_val, max_probability);\n+      ret.m_quality = MIN (m_quality, other.m_quality);\n+      return ret;\n+    }\n+  profile_probability &operator*= (const profile_probability &other)\n+    {\n+      if (*this == profile_probability::never ()\n+\t  || other == profile_probability::never ())\n+\treturn *this = profile_probability::never ();\n+      if (!initialized_p () || !other.initialized_p ())\n+\treturn *this = profile_probability::uninitialized ();\n+      else\n+\t{\n+          m_val = RDIV ((uint64_t)m_val * other.m_val, max_probability);\n+          m_quality = MIN (m_quality, other.m_quality);\n+\t}\n+      return *this;\n+    }\n+  profile_probability operator/ (const profile_probability &other) const\n+    {\n+      if (*this == profile_probability::never ())\n+\treturn profile_probability::never ();\n+      if (!initialized_p () || !other.initialized_p ())\n+\treturn profile_probability::uninitialized ();\n+      profile_probability ret;\n+      if (m_val >= other.m_val)\n+\tret.m_val = max_probability;\n+      else if (!m_val)\n+\tret.m_val = 0;\n+      else\n+\t{\n+\t  gcc_checking_assert (other.m_val);\n+          ret.m_val = MIN (RDIV ((uint64_t)m_val * max_probability,\n+\t\t\t\t other.m_val),\n+\t\t\t   max_probability);\n+\t}\n+      ret.m_quality = MIN (m_quality, other.m_quality);\n+      return ret;\n+    }\n+  profile_probability &operator/= (const profile_probability &other)\n+    {\n+      if (*this == profile_probability::never ())\n+\treturn *this = profile_probability::never ();\n+      if (!initialized_p () || !other.initialized_p ())\n+\treturn *this = profile_probability::uninitialized ();\n+      else\n+\t{\n+\t  if (m_val > other.m_val)\n+\t    m_val = max_probability;\n+\t  else if (!m_val)\n+\t    ;\n+\t  else\n+\t    {\n+\t      gcc_checking_assert (other.m_val);\n+              m_val = MIN (RDIV ((uint64_t)m_val * max_probability,\n+\t\t\t\t other.m_val),\n+\t\t\t   max_probability);\n+\t    }\n+          m_quality = MIN (m_quality, other.m_quality);\n+\t}\n+      return *this;\n+    }\n+\n+  gcov_type apply (gcov_type val) const\n+    {\n+      if (*this == profile_probability::uninitialized ())\n+\treturn val / 2;\n+      return RDIV (val * m_val, max_probability);\n+    }\n+\n+  /* Return 1-*THIS.  */\n+  profile_probability invert () const\n+    {\n+      return profile_probability::always() - *this;\n+    }\n+\n+  profile_probability combine_with_freq (int freq1, profile_probability other,\n+\t\t\t\t\t int freq2) const\n+    {\n+      profile_probability ret;\n+\n+      if (*this == profile_probability::uninitialized ()\n+\t  || other == profile_probability::uninitialized ())\n+\treturn profile_probability::uninitialized ();\n+\n+      gcc_checking_assert (freq1 >= 0 && freq2 >= 0);\n+      if (!freq1 && !freq2)\n+\t{\n+\t  ret.m_val = (m_val + other.m_val) / 2;\n+\t}\n+      else\n+\tret.m_val = RDIV (m_val * (uint64_t) freq1\n+\t\t\t  + other.m_val * (uint64_t) freq2, freq1 + freq2);\n+      ret.m_quality = MIN (m_quality, other.m_quality);\n+      return ret;\n+    }\n+\n+  /* Return *THIS * NUM / DEN.  */\n+  profile_probability apply_scale (int64_t num, int64_t den) const\n+    {\n+      if (*this == profile_probability::never ())\n+\treturn *this;\n+      if (!initialized_p ())\n+\treturn profile_probability::uninitialized ();\n+      profile_probability ret;\n+      ret.m_val = MIN (RDIV (m_val * num, den),\n+\t\t       max_probability);\n+      ret.m_quality = MIN (m_quality, profile_adjusted);\n+      return ret;\n+    }\n+\n+  /* Return true when the probability of edge is reliable.\n+\n+     The profile guessing code is good at predicting branch outcome (ie.\n+     taken/not taken), that is predicted right slightly over 75% of time.\n+     It is however notoriously poor on predicting the probability itself.\n+     In general the profile appear a lot flatter (with probabilities closer\n+     to 50%) than the reality so it is bad idea to use it to drive optimization\n+     such as those disabling dynamic branch prediction for well predictable\n+     branches.\n+\n+     There are two exceptions - edges leading to noreturn edges and edges\n+     predicted by number of iterations heuristics are predicted well.  This macro\n+     should be able to distinguish those, but at the moment it simply check for\n+     noreturn heuristic that is only one giving probability over 99% or bellow\n+     1%.  In future we might want to propagate reliability information across the\n+     CFG if we find this information useful on multiple places.   */\n+\n+  bool probably_reliable_p () const\n+    {\n+      if (m_quality >= profile_adjusted)\n+\treturn true;\n+      if (!initialized_p ())\n+\treturn false;\n+      return m_val < max_probability / 100\n+\t     || m_val > max_probability - max_probability / 100;\n+    }\n+\n+  /* Return false if profile_probability is bogus.  */\n+  bool verify () const\n+    {\n+      if (m_val == uninitialized_probability)\n+\treturn m_quality == profile_guessed;\n+      else\n+\treturn m_val <= REG_BR_PROB_BASE;\n+    }\n+\n+  /* Comparsions are three-state and conservative.  False is returned if\n+     the inequality can not be decided.  */\n+  bool operator< (const profile_probability &other) const\n+    {\n+      return initialized_p () && other.initialized_p () && m_val < other.m_val;\n+    }\n+  bool operator> (const profile_probability &other) const\n+    {\n+      return initialized_p () && other.initialized_p () && m_val > other.m_val;\n+    }\n+\n+  bool operator<= (const profile_probability &other) const\n+    {\n+      return initialized_p () && other.initialized_p () && m_val <= other.m_val;\n+    }\n+  bool operator>= (const profile_probability &other) const\n+    {\n+      return initialized_p () && other.initialized_p () && m_val >= other.m_val;\n+    }\n+\n+  /* Output THIS to F.  */\n+  void dump (FILE *f) const;\n+\n+  /* Print THIS to stderr.  */\n+  void debug () const;\n+\n+  /* Return true if THIS is known to differ significantly from OTHER.  */\n+  bool differs_from_p (profile_probability other) const;\n+  /* Return if difference is greater than 50%.  */\n+  bool differs_lot_from_p (profile_probability other) const;\n+\n+  /* LTO streaming support.  */\n+  static profile_probability stream_in (struct lto_input_block *);\n+  void stream_out (struct output_block *);\n+  void stream_out (struct lto_output_stream *);\n+};\n+\n /* Main data type to hold profile counters in GCC.  In most cases profile\n    counts originate from profile feedback. They are 64bit integers\n    representing number of executions during the train run.\n@@ -85,7 +501,7 @@ class GTY(()) profile_count\n   static const uint64_t uninitialized_count = ((uint64_t) 1 << n_bits) - 1;\n \n   uint64_t m_val : n_bits;\n-  enum profile_count_quality m_quality : 2;\n+  enum profile_quality m_quality : 2;\n \n   /* Assume numbers smaller than this to multiply.  This is set to make\n      testsuite pass, in future we may implement precise multiplication in higer\n@@ -108,7 +524,7 @@ class GTY(()) profile_count\n     {\n       profile_count c;\n       c.m_val = uninitialized_count;\n-      c.m_quality = count_guessed;\n+      c.m_quality = profile_guessed;\n       return c;\n     }\n \n@@ -120,7 +536,7 @@ class GTY(()) profile_count\n       profile_count ret;\n       gcc_checking_assert (v >= 0 && (uint64_t) v <= max_count);\n       ret.m_val = v;\n-      ret.m_quality = count_read;\n+      ret.m_quality = profile_precise;\n       return ret;\n     }\n \n@@ -207,7 +623,7 @@ class GTY(()) profile_count\n   /* Return false if profile_count is bogus.  */\n   bool verify () const\n     {\n-      return m_val != uninitialized_count || m_quality == count_guessed;\n+      return m_val != uninitialized_count || m_quality == profile_guessed;\n     }\n \n   /* Comparsions are three-state and conservative.  False is returned if\n@@ -237,7 +653,7 @@ class GTY(()) profile_count\n     }\n   bool operator>= (const profile_count &other) const\n     {\n-      return initialized_p () && m_val >= other.m_val;\n+      return initialized_p () && other.initialized_p () && m_val >= other.m_val;\n     }\n   bool operator<= (const gcov_type other) const\n     {\n@@ -261,7 +677,23 @@ class GTY(()) profile_count\n \treturn profile_count::uninitialized ();\n       profile_count ret;\n       ret.m_val = RDIV (m_val * prob, REG_BR_PROB_BASE);\n-      ret.m_quality = MIN (m_quality, count_adjusted);\n+      ret.m_quality = MIN (m_quality, profile_adjusted);\n+      return ret;\n+    }\n+\n+  /* Scale counter according to PROB.  */\n+  profile_count apply_probability (profile_probability prob) const\n+    {\n+      if (*this == profile_count::zero ())\n+\treturn *this;\n+      if (prob == profile_probability::never ())\n+\treturn profile_count::zero ();\n+      if (!initialized_p ())\n+\treturn profile_count::uninitialized ();\n+      profile_count ret;\n+      ret.m_val = RDIV (m_val * prob.m_val,\n+\t\t\tprofile_probability::max_probability);\n+      ret.m_quality = MIN (m_quality, prob.m_quality);\n       return ret;\n     }\n   /* Return *THIS * NUM / DEN.  */\n@@ -277,7 +709,7 @@ class GTY(()) profile_count\n       gcc_checking_assert ((num <= REG_BR_PROB_BASE\n \t\t\t    || den <= REG_BR_PROB_BASE) || 1);\n       ret.m_val = RDIV (m_val * num, den);\n-      ret.m_quality = MIN (m_quality, count_adjusted);\n+      ret.m_quality = MIN (m_quality, profile_adjusted);\n       return ret;\n     }\n   profile_count apply_scale (profile_count num, profile_count den) const\n@@ -299,23 +731,27 @@ class GTY(()) profile_count\n       else\n         ret.m_val = RDIV (m_val * RDIV (num.m_val * max_safe_multiplier,\n \t\t\t\t\tden.m_val), max_safe_multiplier);\n-      ret.m_quality = MIN (m_quality, count_adjusted);\n+      ret.m_quality = MIN (m_quality, profile_adjusted);\n       return ret;\n     }\n \n   /* Return probability of event with counter THIS within event with counter\n      OVERALL.  */\n-  int probability_in (profile_count overall)\n+  profile_probability probability_in (const profile_count overall) const\n     {\n       if (!m_val)\n-\treturn 0;\n-      if (!initialized_p () || !overall.initialized_p ())\n-\treturn REG_BR_PROB_BASE / 2;\n-      if (overall < *this)\n-\treturn REG_BR_PROB_BASE;\n-      if (!overall.m_val)\n-\treturn REG_BR_PROB_BASE / 2;\n-      return RDIV (m_val * REG_BR_PROB_BASE, overall.m_val);\n+\treturn profile_probability::never ();\n+      if (!initialized_p () || !overall.initialized_p ()\n+\t  || !overall.m_val)\n+\treturn profile_probability::uninitialized ();\n+      profile_probability ret;\n+      if (overall < m_val)\n+\tret.m_val = profile_probability::max_probability;\n+      else\n+        ret.m_val = RDIV (m_val * profile_probability::max_probability,\n+\t\t\t  overall.m_val);\n+      ret.m_quality = MIN (m_quality, overall.m_quality);\n+      return ret;\n     }\n \n   /* Output THIS to F.  */"}, {"sha": "6d40241a37bccdad614d9fc9f7b3e8e45d67f0eb", "filename": "gcc/profile.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -768,8 +768,8 @@ compute_branch_probabilities (unsigned cfg_checksum, unsigned lineno_checksum)\n       if (bb_gcov_count (bb))\n \t{\n \t  FOR_EACH_EDGE (e, ei, bb->succs)\n-\t    e->probability = GCOV_COMPUTE_SCALE (edge_gcov_count (e),\n-\t\t\t\t\t\t bb_gcov_count (bb));\n+\t    e->probability = profile_probability::probability_in_gcov_type\n+\t\t(edge_gcov_count (e), bb_gcov_count (bb));\n \t  if (bb->index >= NUM_FIXED_BLOCKS\n \t      && block_ends_with_condjump_p (bb)\n \t      && EDGE_COUNT (bb->succs) >= 2)\n@@ -784,7 +784,7 @@ compute_branch_probabilities (unsigned cfg_checksum, unsigned lineno_checksum)\n \t\tif (!(e->flags & (EDGE_FAKE | EDGE_FALLTHRU)))\n \t\t  break;\n \n-\t      prob = e->probability;\n+\t      prob = e->probability.to_reg_br_prob_base ();\n \t      index = prob * 20 / REG_BR_PROB_BASE;\n \n \t      if (index == 20)\n@@ -810,15 +810,17 @@ compute_branch_probabilities (unsigned cfg_checksum, unsigned lineno_checksum)\n \t    {\n \t      FOR_EACH_EDGE (e, ei, bb->succs)\n \t\tif (!(e->flags & (EDGE_COMPLEX | EDGE_FAKE)))\n-\t\t  e->probability = REG_BR_PROB_BASE / total;\n+\t\t  e->probability\n+\t\t    = profile_probability::guessed_always ().apply_scale (1, total);\n \t\telse\n-\t\t  e->probability = 0;\n+\t\t  e->probability = profile_probability::never ();\n \t    }\n \t  else\n \t    {\n \t      total += EDGE_COUNT (bb->succs);\n \t      FOR_EACH_EDGE (e, ei, bb->succs)\n-\t\te->probability = REG_BR_PROB_BASE / total;\n+\t\te->probability\n+\t\t = profile_probability::guessed_always ().apply_scale (1, total);\n \t    }\n \t  if (bb->index >= NUM_FIXED_BLOCKS\n \t      && block_ends_with_condjump_p (bb)"}, {"sha": "fd4e46058307b53516c59d3ca5508cdd26a35c00", "filename": "gcc/recog.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -3460,8 +3460,7 @@ peep2_attempt (basic_block bb, rtx_insn *insn, int match_len, rtx_insn *attempt)\n \t\t\t\tflags);\n \n \t      nehe->probability = eh_edge->probability;\n-\t      nfte->probability\n-\t\t= REG_BR_PROB_BASE - nehe->probability;\n+\t      nfte->probability = nehe->probability.invert ();\n \n \t      peep2_do_cleanup_cfg |= purge_dead_edges (nfte->dest);\n \t      bb = nfte->src;"}, {"sha": "a0422f4b1baf03a168e9dfc2e97afcfd66f15a45", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -648,7 +648,8 @@ schedule_ebbs (void)\n \t  e = find_fallthru_edge (bb->succs);\n \t  if (! e)\n \t    break;\n-\t  if (e->probability <= probability_cutoff)\n+\t  if (e->probability.initialized_p ()\n+\t      && e->probability.to_reg_br_prob_base () <= probability_cutoff)\n \t    break;\n \t  if (e->dest->flags & BB_DISABLE_SCHEDULE)\n  \t    break;"}, {"sha": "492094e36240cbeb52684bd87c155831e97def93", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -507,7 +507,8 @@ find_single_block_region (bool ebbs_p)\n \t    e = find_fallthru_edge (bb->succs);\n             if (! e)\n               break;\n-            if (e->probability <= probability_cutoff)\n+            if (e->probability.initialized_p ()\n+\t\t&& e->probability.to_reg_br_prob_base () <= probability_cutoff)\n               break;\n           }\n \n@@ -1441,7 +1442,11 @@ compute_dom_prob_ps (int bb)\n       FOR_EACH_EDGE (out_edge, out_ei, in_edge->src->succs)\n \tbitmap_set_bit (pot_split[bb], EDGE_TO_BIT (out_edge));\n \n-      prob[bb] += combine_probabilities (prob[pred_bb], in_edge->probability);\n+      prob[bb] += combine_probabilities\n+\t\t (prob[pred_bb],\n+\t\t  in_edge->probability.initialized_p ()\n+\t\t  ? in_edge->probability.to_reg_br_prob_base ()\n+\t\t  : 0);\n       // The rounding divide in combine_probabilities can result in an extra\n       // probability increment propagating along 50-50 edges. Eventually when\n       // the edges re-merge, the accumulated probability can go slightly above\n@@ -3171,8 +3176,10 @@ schedule_region (int rgn)\n \t  sched_rgn_n_insns += sched_n_insns;\n \t  realloc_bb_state_array (saved_last_basic_block);\n \t  f = find_fallthru_edge (last_bb->succs);\n-\t  if (f && f->probability * 100 / REG_BR_PROB_BASE >=\n-\t      PARAM_VALUE (PARAM_SCHED_STATE_EDGE_PROB_CUTOFF))\n+\t  if (f\n+\t      && (!f->probability.initialized_p ()\n+\t\t  || f->probability.to_reg_br_prob_base () * 100 / REG_BR_PROB_BASE >=\n+\t             PARAM_VALUE (PARAM_SCHED_STATE_EDGE_PROB_CUTOFF)))\n \t    {\n \t      memcpy (bb_state[f->dest->index], curr_state,\n \t\t      dfa_state_size);"}, {"sha": "dd72828795dbbc62abedfb3c85883d74cd06446c", "filename": "gcc/sel-sched-ir.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fsel-sched-ir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fsel-sched-ir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -4747,7 +4747,9 @@ compute_succs_info (insn_t insn, short flags)\n           sinfo->probs_ok.safe_push (\n \t\t    /* FIXME: Improve calculation when skipping\n                        inner loop to exits.  */\n-                    si.bb_end ? si.e1->probability : REG_BR_PROB_BASE);\n+                    si.bb_end && si.e1->probability.initialized_p ()\n+\t\t    ? si.e1->probability.to_reg_br_prob_base ()\n+\t\t    : REG_BR_PROB_BASE);\n           sinfo->succs_ok_n++;\n         }\n       else\n@@ -4756,8 +4758,8 @@ compute_succs_info (insn_t insn, short flags)\n       /* Compute all_prob.  */\n       if (!si.bb_end)\n         sinfo->all_prob = REG_BR_PROB_BASE;\n-      else\n-        sinfo->all_prob += si.e1->probability;\n+      else if (si.e1->probability.initialized_p ())\n+        sinfo->all_prob += si.e1->probability.to_reg_br_prob_base ();\n \n       sinfo->all_succs_n++;\n     }"}, {"sha": "10d394eee695d9bc7d204cc73d0c7ca281f67310", "filename": "gcc/stmt.c", "status": "modified", "additions": 48, "deletions": 47, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -93,9 +93,9 @@ struct case_node\n   tree\t\t\tlow;\t/* Lowest index value for this label */\n   tree\t\t\thigh;\t/* Highest index value for this label */\n   tree\t\t\tcode_label; /* Label to jump to when node matches */\n-  int                   prob; /* Probability of taking this case.  */\n+  profile_probability   prob; /* Probability of taking this case.  */\n   /* Probability of reaching subtree rooted at this node */\n-  int                   subtree_prob;\n+  profile_probability   subtree_prob;\n };\n \n typedef struct case_node *case_node_ptr;\n@@ -108,7 +108,8 @@ static void balance_case_nodes (case_node_ptr *, case_node_ptr);\n static int node_has_low_bound (case_node_ptr, tree);\n static int node_has_high_bound (case_node_ptr, tree);\n static int node_is_bounded (case_node_ptr, tree);\n-static void emit_case_nodes (rtx, case_node_ptr, rtx_code_label *, int, tree);\n+static void emit_case_nodes (rtx, case_node_ptr, rtx_code_label *,\n+\t\t\t     profile_probability, tree);\n \f\n /* Return the rtx-label that corresponds to a LABEL_DECL,\n    creating it if necessary.  */\n@@ -704,9 +705,8 @@ expand_naked_return (void)\n    is the probability of jumping to LABEL.  */\n static void\n do_jump_if_equal (machine_mode mode, rtx op0, rtx op1, rtx_code_label *label,\n-\t\t  int unsignedp, int prob)\n+\t\t  int unsignedp, profile_probability prob)\n {\n-  gcc_assert (prob <= REG_BR_PROB_BASE);\n   do_compare_rtx_and_jump (op0, op1, EQ, unsignedp, mode,\n \t\t\t   NULL_RTX, NULL, label, prob);\n }\n@@ -722,7 +722,7 @@ do_jump_if_equal (machine_mode mode, rtx op0, rtx op1, rtx_code_label *label,\n \n static struct case_node *\n add_case_node (struct case_node *head, tree low, tree high,\n-\t       tree label, int prob,\n+\t       tree label, profile_probability prob,\n \t       object_allocator<case_node> &case_node_pool)\n {\n   struct case_node *r;\n@@ -859,7 +859,7 @@ expand_switch_as_decision_tree_p (tree range,\n static void\n emit_case_decision_tree (tree index_expr, tree index_type,\n \t\t\t case_node_ptr case_list, rtx_code_label *default_label,\n-\t\t\t int default_prob)\n+\t\t\t profile_probability default_prob)\n {\n   rtx index = expand_normal (index_expr);\n \n@@ -902,14 +902,14 @@ emit_case_decision_tree (tree index_expr, tree index_type,\n \n /* Return the sum of probabilities of outgoing edges of basic block BB.  */\n \n-static int\n+static profile_probability\n get_outgoing_edge_probs (basic_block bb)\n {\n   edge e;\n   edge_iterator ei;\n-  int prob_sum = 0;\n+  profile_probability prob_sum = profile_probability::never ();\n   if (!bb)\n-    return 0;\n+    return profile_probability::never ();\n   FOR_EACH_EDGE (e, ei, bb->succs)\n     prob_sum += e->probability;\n   return prob_sum;\n@@ -922,16 +922,11 @@ get_outgoing_edge_probs (basic_block bb)\n    BASE_PROB is the probability of reaching the branch instruction relative\n    to the same basic block BB.  */\n \n-static inline int\n-conditional_probability (int target_prob, int base_prob)\n+static inline profile_probability\n+conditional_probability (profile_probability target_prob,\n+\t\t\t profile_probability base_prob)\n {\n-  if (base_prob > 0)\n-    {\n-      gcc_assert (target_prob >= 0);\n-      gcc_assert (target_prob <= base_prob);\n-      return GCOV_COMPUTE_SCALE (target_prob, base_prob);\n-    }\n-  return -1;\n+  return target_prob / base_prob;\n }\n \n /* Generate a dispatch tabler, switching on INDEX_EXPR and jumping to\n@@ -960,12 +955,13 @@ emit_case_dispatch_table (tree index_expr, tree index_type,\n   rtx_code_label *table_label = gen_label_rtx ();\n   bool has_gaps = false;\n   edge default_edge = stmt_bb ? EDGE_SUCC (stmt_bb, 0) : NULL;\n-  int default_prob = default_edge ? default_edge->probability : 0;\n-  int base = get_outgoing_edge_probs (stmt_bb);\n+  profile_probability default_prob = default_edge ? default_edge->probability\n+\t\t\t\t\t\t  : profile_probability::never ();\n+  profile_probability base = get_outgoing_edge_probs (stmt_bb);\n   bool try_with_tablejump = false;\n \n-  int new_default_prob = conditional_probability (default_prob,\n-                                                  base);\n+  profile_probability new_default_prob = conditional_probability (default_prob,\n+\t\t\t\t\t\t\t\t  base);\n \n   if (! try_casesi (index_type, index_expr, minval, range,\n \t\t    table_label, default_label, fallback_label,\n@@ -1030,15 +1026,16 @@ emit_case_dispatch_table (tree index_expr, tree index_type,\n          through the indirect jump or the direct conditional jump\n          before that. Split the probability of reaching the\n          default label among these two jumps.  */\n-      new_default_prob = conditional_probability (default_prob/2,\n+      new_default_prob = conditional_probability (default_prob.apply_scale\n+\t\t\t\t\t\t\t (1, 2),\n                                                   base);\n-      default_prob /= 2;\n+      default_prob = default_prob.apply_scale (1, 2);\n       base -= default_prob;\n     }\n   else\n     {\n       base -= default_prob;\n-      default_prob = 0;\n+      default_prob = profile_probability::never ();\n     }\n \n   if (default_edge)\n@@ -1047,12 +1044,12 @@ emit_case_dispatch_table (tree index_expr, tree index_type,\n   /* We have altered the probability of the default edge. So the probabilities\n      of all other edges need to be adjusted so that it sums up to\n      REG_BR_PROB_BASE.  */\n-  if (base)\n+  if (base > profile_probability::never ())\n     {\n       edge e;\n       edge_iterator ei;\n       FOR_EACH_EDGE (e, ei, stmt_bb->succs)\n-        e->probability = GCOV_COMPUTE_SCALE (e->probability,  base);\n+        e->probability /= base;\n     }\n \n   if (try_with_tablejump)\n@@ -1153,7 +1150,7 @@ expand_case (gswitch *stmt)\n   default_label = jump_target_rtx\n       (CASE_LABEL (gimple_switch_default_label (stmt)));\n   edge default_edge = EDGE_SUCC (bb, 0);\n-  int default_prob = default_edge->probability;\n+  profile_probability default_prob = default_edge->probability;\n \n   /* Get upper and lower bounds of case values.  */\n   elt = gimple_switch_label (stmt, 1);\n@@ -1216,7 +1213,7 @@ expand_case (gswitch *stmt)\n       edge case_edge = find_edge (bb, case_bb);\n       case_list = add_case_node (\n           case_list, low, high, lab,\n-          case_edge->probability / (intptr_t)(case_edge->aux),\n+          case_edge->probability.apply_scale (1, (intptr_t)(case_edge->aux)),\n           case_node_pool);\n     }\n   reset_out_edges_aux (bb);\n@@ -1313,7 +1310,8 @@ expand_sjlj_dispatch_table (rtx dispatch_index,\n         {\n \t  tree elt = dispatch_table[i];\n \t  rtx_code_label *lab = jump_target_rtx (CASE_LABEL (elt));\n-\t  do_jump_if_equal (index_mode, index, zero, lab, 0, -1);\n+\t  do_jump_if_equal (index_mode, index, zero, lab, 0,\n+\t\t\t    profile_probability::uninitialized ());\n \t  force_expand_binop (index_mode, sub_optab,\n \t\t\t      index, CONST1_RTX (index_mode),\n \t\t\t      index, 0, OPTAB_DIRECT);\n@@ -1335,7 +1333,10 @@ expand_sjlj_dispatch_table (rtx dispatch_index,\n \t  tree elt = dispatch_table[i];\n \t  tree low = CASE_LOW (elt);\n \t  tree lab = CASE_LABEL (elt);\n-\t  case_list = add_case_node (case_list, low, low, lab, 0, case_node_pool);\n+\t  case_list = add_case_node (case_list, low, low, lab,\n+\t\t\t\t     profile_probability::guessed_always ()\n+\t\t\t\t\t.apply_scale (1, ncases),\n+\t\t\t\t     case_node_pool);\n \t}\n \n       emit_case_dispatch_table (index_expr, index_type,\n@@ -1579,12 +1580,12 @@ node_is_bounded (case_node_ptr node, tree index_type)\n \n static void\n emit_case_nodes (rtx index, case_node_ptr node, rtx_code_label *default_label,\n-\t\t int default_prob, tree index_type)\n+\t\t profile_probability default_prob, tree index_type)\n {\n   /* If INDEX has an unsigned type, we must make unsigned branches.  */\n   int unsignedp = TYPE_UNSIGNED (index_type);\n-  int probability;\n-  int prob = node->prob, subtree_prob = node->subtree_prob;\n+  profile_probability probability;\n+  profile_probability prob = node->prob, subtree_prob = node->subtree_prob;\n   machine_mode mode = GET_MODE (index);\n   machine_mode imode = TYPE_MODE (index_type);\n \n@@ -1704,7 +1705,7 @@ emit_case_nodes (rtx index, case_node_ptr node, rtx_code_label *default_label,\n                  subtree or the left subtree. Divide the probability\n                  equally.  */\n               probability = conditional_probability (\n-                  node->right->subtree_prob + default_prob/2,\n+                  node->right->subtree_prob + default_prob.apply_scale (1, 2),\n                   subtree_prob + default_prob);\n \t      /* See if the value is on the right.  */\n \t      emit_cmp_and_jump_insns (index,\n@@ -1715,7 +1716,7 @@ emit_case_nodes (rtx index, case_node_ptr node, rtx_code_label *default_label,\n \t\t\t\t       GT, NULL_RTX, mode, unsignedp,\n \t\t\t\t       label_rtx (test_label),\n                                        probability);\n-              default_prob /= 2;\n+              default_prob = default_prob.apply_scale (1, 2);\n \n \t      /* Value must be on the left.\n \t\t Handle the left-hand subtree.  */\n@@ -1746,7 +1747,7 @@ emit_case_nodes (rtx index, case_node_ptr node, rtx_code_label *default_label,\n \t      if (!node_has_low_bound (node, index_type))\n \t\t{\n                   probability = conditional_probability (\n-                      default_prob/2,\n+                      default_prob.apply_scale (1, 2),\n                       subtree_prob + default_prob);\n \t\t  emit_cmp_and_jump_insns (index,\n \t\t\t\t\t   convert_modes\n@@ -1756,7 +1757,7 @@ emit_case_nodes (rtx index, case_node_ptr node, rtx_code_label *default_label,\n \t\t\t\t\t   LT, NULL_RTX, mode, unsignedp,\n \t\t\t\t\t   default_label,\n                                            probability);\n-                  default_prob /= 2;\n+                  default_prob = default_prob.apply_scale (1, 2);\n \t\t}\n \n \t      emit_case_nodes (index, node->right, default_label, default_prob, index_type);\n@@ -1788,7 +1789,7 @@ emit_case_nodes (rtx index, case_node_ptr node, rtx_code_label *default_label,\n \t      if (!node_has_high_bound (node, index_type))\n \t\t{\n                   probability = conditional_probability (\n-                      default_prob/2,\n+                      default_prob.apply_scale (1, 2),\n                       subtree_prob + default_prob);\n \t\t  emit_cmp_and_jump_insns (index,\n \t\t\t\t\t   convert_modes\n@@ -1798,7 +1799,7 @@ emit_case_nodes (rtx index, case_node_ptr node, rtx_code_label *default_label,\n \t\t\t\t\t   GT, NULL_RTX, mode, unsignedp,\n \t\t\t\t\t   default_label,\n                                            probability);\n-                  default_prob /= 2;\n+                  default_prob = default_prob.apply_scale (1, 2);\n \t\t}\n \n \t      emit_case_nodes (index, node->left, default_label,\n@@ -1861,7 +1862,7 @@ emit_case_nodes (rtx index, case_node_ptr node, rtx_code_label *default_label,\n \t      test_label = build_decl (curr_insn_location (),\n \t\t\t\t       LABEL_DECL, NULL_TREE, void_type_node);\n               probability = conditional_probability (\n-                  node->right->subtree_prob + default_prob/2,\n+                  node->right->subtree_prob + default_prob.apply_scale (1, 2),\n                   subtree_prob + default_prob);\n \t      emit_cmp_and_jump_insns (index,\n \t\t\t\t       convert_modes\n@@ -1871,7 +1872,7 @@ emit_case_nodes (rtx index, case_node_ptr node, rtx_code_label *default_label,\n \t\t\t\t       GT, NULL_RTX, mode, unsignedp,\n \t\t\t\t       label_rtx (test_label),\n                                        probability);\n-              default_prob /= 2;\n+              default_prob = default_prob.apply_scale (1, 2);\n \t    }\n \n \t  /* Value belongs to this node or to the left-hand subtree.  */\n@@ -1912,7 +1913,7 @@ emit_case_nodes (rtx index, case_node_ptr node, rtx_code_label *default_label,\n \t  if (!node_has_low_bound (node, index_type))\n \t    {\n               probability = conditional_probability (\n-                  default_prob/2,\n+                  default_prob.apply_scale (1, 2),\n                   subtree_prob + default_prob);\n \t      emit_cmp_and_jump_insns (index,\n \t\t\t\t       convert_modes\n@@ -1922,7 +1923,7 @@ emit_case_nodes (rtx index, case_node_ptr node, rtx_code_label *default_label,\n \t\t\t\t       LT, NULL_RTX, mode, unsignedp,\n \t\t\t\t       default_label,\n                                        probability);\n-              default_prob /= 2;\n+              default_prob = default_prob.apply_scale (1, 2);\n \t    }\n \n \t  /* Value belongs to this node or to the right-hand subtree.  */\n@@ -1949,7 +1950,7 @@ emit_case_nodes (rtx index, case_node_ptr node, rtx_code_label *default_label,\n \t  if (!node_has_high_bound (node, index_type))\n \t    {\n               probability = conditional_probability (\n-                  default_prob/2,\n+                  default_prob.apply_scale (1, 2),\n                   subtree_prob + default_prob);\n \t      emit_cmp_and_jump_insns (index,\n \t\t\t\t       convert_modes\n@@ -1959,7 +1960,7 @@ emit_case_nodes (rtx index, case_node_ptr node, rtx_code_label *default_label,\n \t\t\t\t       GT, NULL_RTX, mode, unsignedp,\n \t\t\t\t       default_label,\n                                        probability);\n-              default_prob /= 2;\n+              default_prob = default_prob.apply_scale (1, 2);\n \t    }\n \n \t  /* Value belongs to this node or to the left-hand subtree.  */"}, {"sha": "889189c5d82ea15470a13d093054fe82183ce40b", "filename": "gcc/targhooks.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -60,6 +60,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stringpool.h\"\n #include \"tree-vrp.h\"\n #include \"tree-ssanames.h\"\n+#include \"profile-count.h\"\n #include \"optabs.h\"\n #include \"regs.h\"\n #include \"recog.h\""}, {"sha": "dd071c1650c8d9b7cef5a4d70ff0bf9a9ac57fe6", "filename": "gcc/tracer.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Ftracer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Ftracer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftracer.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -135,10 +135,8 @@ better_p (const_edge e1, const_edge e2)\n   if (e1->count.initialized_p () && e2->count.initialized_p ()\n       && !(e1->count == e2->count))\n     return e1->count > e2->count;\n-  if (e1->src->frequency * e1->probability !=\n-      e2->src->frequency * e2->probability)\n-    return (e1->src->frequency * e1->probability\n-\t    > e2->src->frequency * e2->probability);\n+  if (EDGE_FREQUENCY (e1) != EDGE_FREQUENCY (e2))\n+    return EDGE_FREQUENCY (e1) > EDGE_FREQUENCY (e2);\n   /* This is needed to avoid changes in the decision after\n      CFG is modified.  */\n   if (e1->src != e2->src)\n@@ -160,7 +158,8 @@ find_best_successor (basic_block bb)\n       best = e;\n   if (!best || ignore_bb_p (best->dest))\n     return NULL;\n-  if (best->probability <= probability_cutoff)\n+  if (best->probability.initialized_p ()\n+      && best->probability.to_reg_br_prob_base () <= probability_cutoff)\n     return NULL;\n   return best;\n }"}, {"sha": "f747e05bd10381a0b8e86199e5474f7af503603a", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -2934,9 +2934,9 @@ expand_transaction (struct tm_region *region, void *data ATTRIBUTE_UNUSED)\n       join_bb->frequency = test_bb->frequency = transaction_bb->frequency;\n       join_bb->count = test_bb->count = transaction_bb->count;\n \n-      ei->probability = PROB_ALWAYS;\n-      et->probability = PROB_LIKELY;\n-      ef->probability = PROB_UNLIKELY;\n+      ei->probability = profile_probability::always ();\n+      et->probability = profile_probability::likely ();\n+      ef->probability = profile_probability::unlikely ();\n       et->count = test_bb->count.apply_probability (et->probability);\n       ef->count = test_bb->count.apply_probability (ef->probability);\n \n@@ -2967,20 +2967,20 @@ expand_transaction (struct tm_region *region, void *data ATTRIBUTE_UNUSED)\n       edge ei = make_edge (transaction_bb, test_bb, EDGE_FALLTHRU);\n       test_bb->frequency = transaction_bb->frequency;\n       test_bb->count = transaction_bb->count;\n-      ei->probability = PROB_ALWAYS;\n+      ei->probability = profile_probability::always ();\n \n       // Not abort edge.  If both are live, chose one at random as we'll\n       // we'll be fixing that up below.\n       redirect_edge_pred (fallthru_edge, test_bb);\n       fallthru_edge->flags = EDGE_FALSE_VALUE;\n-      fallthru_edge->probability = PROB_VERY_LIKELY;\n+      fallthru_edge->probability = profile_probability::very_likely ();\n       fallthru_edge->count = test_bb->count.apply_probability\n \t\t\t\t(fallthru_edge->probability);\n \n       // Abort/over edge.\n       redirect_edge_pred (abort_edge, test_bb);\n       abort_edge->flags = EDGE_TRUE_VALUE;\n-      abort_edge->probability = PROB_VERY_UNLIKELY;\n+      abort_edge->probability = profile_probability::unlikely ();\n       abort_edge->count = test_bb->count.apply_probability\n \t\t\t\t(abort_edge->probability);\n \n@@ -3020,13 +3020,13 @@ expand_transaction (struct tm_region *region, void *data ATTRIBUTE_UNUSED)\n       // use the uninst path when falling back to serial mode.\n       redirect_edge_pred (inst_edge, test_bb);\n       inst_edge->flags = EDGE_FALSE_VALUE;\n-      inst_edge->probability = REG_BR_PROB_BASE / 2;\n+      inst_edge->probability = profile_probability::even ();\n       inst_edge->count\n \t= test_bb->count.apply_probability (inst_edge->probability);\n \n       redirect_edge_pred (uninst_edge, test_bb);\n       uninst_edge->flags = EDGE_TRUE_VALUE;\n-      uninst_edge->probability = REG_BR_PROB_BASE / 2;\n+      uninst_edge->probability = profile_probability::even ();\n       uninst_edge->count\n \t= test_bb->count.apply_probability (uninst_edge->probability);\n     }"}, {"sha": "862d1a6421d4f3c7e98a3243ffa3f688a96670ce", "filename": "gcc/tree-call-cdce.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Ftree-call-cdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Ftree-call-cdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-call-cdce.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -752,10 +752,6 @@ gen_shrink_wrap_conditions (gcall *bi_call, vec<gimple *> conds,\n   return;\n }\n \n-\n-/* Probability of the branch (to the call) is taken.  */\n-#define ERR_PROB 0.01\n-\n /* Shrink-wrap BI_CALL so that it is only called when one of the NCONDS\n    conditions in CONDS is false.  */\n \n@@ -916,14 +912,15 @@ shrink_wrap_one_built_in_call_with_conds (gcall *bi_call, vec <gimple *> conds,\n       basic_block src_bb = call_edge->src;\n       gcc_assert (src_bb == nocall_edge->src);\n \n-      call_edge->probability = REG_BR_PROB_BASE * ERR_PROB;\n+      call_edge->probability = profile_probability::very_unlikely ();\n       call_edge->count\n \t = src_bb->count.apply_probability (call_edge->probability);\n-      nocall_edge->probability = inverse_probability (call_edge->probability);\n+      nocall_edge->probability = profile_probability::always ()\n+\t\t\t\t - call_edge->probability;\n       nocall_edge->count = src_bb->count - call_edge->count;\n \n-      unsigned int call_frequency = apply_probability (src_bb->frequency,\n-\t\t\t\t\t\t       call_edge->probability);\n+      unsigned int call_frequency\n+\t = call_edge->probability.apply (src_bb->frequency);\n \n       bi_call_bb->count += call_edge->count;\n       bi_call_bb->frequency += call_frequency;"}, {"sha": "5af677ba65294993f48ffffa2b4d80e98a9bc56c", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -2843,9 +2843,7 @@ gimple_split_edge (edge edge_in)\n   new_bb = create_empty_bb (after_bb);\n   new_bb->frequency = EDGE_FREQUENCY (edge_in);\n   new_bb->count = edge_in->count;\n-  new_edge = make_edge (new_bb, dest, EDGE_FALLTHRU);\n-  new_edge->probability = REG_BR_PROB_BASE;\n-  new_edge->count = edge_in->count;\n+  new_edge = make_single_succ_edge (new_bb, dest, EDGE_FALLTHRU);\n \n   e = redirect_edge_and_branch (edge_in, new_bb);\n   gcc_assert (e == edge_in);\n@@ -7250,7 +7248,7 @@ move_sese_region_to_fn (struct function *dest_cfun, basic_block entry_bb,\n   basic_block after, bb, *entry_pred, *exit_succ, abb;\n   struct function *saved_cfun = cfun;\n   int *entry_flag, *exit_flag;\n-  unsigned *entry_prob, *exit_prob;\n+  profile_probability *entry_prob, *exit_prob;\n   unsigned i, num_entry_edges, num_exit_edges, num_nodes;\n   edge e;\n   edge_iterator ei;\n@@ -7288,7 +7286,7 @@ move_sese_region_to_fn (struct function *dest_cfun, basic_block entry_bb,\n   num_entry_edges = EDGE_COUNT (entry_bb->preds);\n   entry_pred = XNEWVEC (basic_block, num_entry_edges);\n   entry_flag = XNEWVEC (int, num_entry_edges);\n-  entry_prob = XNEWVEC (unsigned, num_entry_edges);\n+  entry_prob = XNEWVEC (profile_probability, num_entry_edges);\n   i = 0;\n   for (ei = ei_start (entry_bb->preds); (e = ei_safe_edge (ei)) != NULL;)\n     {\n@@ -7303,7 +7301,7 @@ move_sese_region_to_fn (struct function *dest_cfun, basic_block entry_bb,\n       num_exit_edges = EDGE_COUNT (exit_bb->succs);\n       exit_succ = XNEWVEC (basic_block, num_exit_edges);\n       exit_flag = XNEWVEC (int, num_exit_edges);\n-      exit_prob = XNEWVEC (unsigned, num_exit_edges);\n+      exit_prob = XNEWVEC (profile_probability, num_exit_edges);\n       i = 0;\n       for (ei = ei_start (exit_bb->succs); (e = ei_safe_edge (ei)) != NULL;)\n \t{"}, {"sha": "b4127f968ff353a97b1eba8c5326827fce8b4b0f", "filename": "gcc/tree-cfgcleanup.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Ftree-cfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Ftree-cfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfgcleanup.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -155,8 +155,6 @@ cleanup_control_expr_graph (basic_block bb, gimple_stmt_iterator gsi,\n \t}\n       if (!warned)\n \tfold_undefer_and_ignore_overflow_warnings ();\n-      if (taken_edge->probability > REG_BR_PROB_BASE)\n-\ttaken_edge->probability = REG_BR_PROB_BASE;\n     }\n   else\n     taken_edge = single_succ_edge (bb);"}, {"sha": "34c223d661d750ae280cfe720f459befc24859d8", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -3244,9 +3244,7 @@ lower_resx (basic_block bb, gresx *stmt,\n \t    }\n \n \t  gcc_assert (EDGE_COUNT (bb->succs) == 0);\n-\t  e = make_edge (bb, new_bb, EDGE_FALLTHRU);\n-\t  e->count = bb->count;\n-\t  e->probability = REG_BR_PROB_BASE;\n+\t  e = make_single_succ_edge (bb, new_bb, EDGE_FALLTHRU);\n \t}\n       else\n \t{\n@@ -3262,7 +3260,7 @@ lower_resx (basic_block bb, gresx *stmt,\n \t  e = single_succ_edge (bb);\n \t  gcc_assert (e->flags & EDGE_EH);\n \t  e->flags = (e->flags & ~EDGE_EH) | EDGE_FALLTHRU;\n-\t  e->probability = REG_BR_PROB_BASE;\n+\t  e->probability = profile_probability::always ();\n \t  e->count = bb->count;\n \n \t  /* If there are no more EH users of the landing pad, delete it.  */\n@@ -4283,7 +4281,7 @@ cleanup_empty_eh_move_lp (basic_block bb, edge e_out,\n \n   /* Clean up E_OUT for the fallthru.  */\n   e_out->flags = (e_out->flags & ~EDGE_EH) | EDGE_FALLTHRU;\n-  e_out->probability = REG_BR_PROB_BASE;\n+  e_out->probability = profile_probability::always ();\n   e_out->count = e_out->src->count;\n }\n "}, {"sha": "b1f06a83fb2044fde5f920b98dde7b641120020e", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -2564,7 +2564,8 @@ version_loop_for_if_conversion (struct loop *loop)\n   /* At this point we invalidate porfile confistency until IFN_LOOP_VECTORIZED\n      is re-merged in the vectorizer.  */\n   new_loop = loop_version (loop, cond, &cond_bb,\n-\t\t\t   REG_BR_PROB_BASE, REG_BR_PROB_BASE,\n+\t\t\t   profile_probability::always (),\n+\t\t\t   profile_probability::always (),\n \t\t\t   REG_BR_PROB_BASE, REG_BR_PROB_BASE, true);\n   free_original_copy_tables ();\n "}, {"sha": "9306c3fbdf797d8c32422ba2ab34792ca2876164", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 39, "deletions": 4, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -2291,10 +2291,44 @@ copy_edges_for_bb (basic_block bb, profile_count num, profile_count den,\n \t    }\n \t}\n \n+      bool update_probs = false;\n+\n       if (gimple_code (copy_stmt) == GIMPLE_EH_DISPATCH)\n-\tmake_eh_dispatch_edges (as_a <geh_dispatch *> (copy_stmt));\n+\t{\n+\t  make_eh_dispatch_edges (as_a <geh_dispatch *> (copy_stmt));\n+\t  update_probs = true;\n+\t}\n       else if (can_throw)\n-\tmake_eh_edges (copy_stmt);\n+\t{\n+\t  make_eh_edges (copy_stmt);\n+\t  update_probs = true;\n+\t}\n+\n+      /* EH edges may not match old edges.  Copy as much as possible.  */\n+      if (update_probs)\n+\t{\n+          edge e;\n+          edge_iterator ei;\n+\t  basic_block copy_stmt_bb = gimple_bb (copy_stmt);\n+\n+          FOR_EACH_EDGE (old_edge, ei, bb->succs)\n+            if ((old_edge->flags & EDGE_EH)\n+\t\t&& (e = find_edge (copy_stmt_bb,\n+\t\t\t\t   (basic_block) old_edge->dest->aux))\n+\t\t&& (e->flags & EDGE_EH))\n+\t      {\n+\t\te->probability = old_edge->probability;\n+\t\te->count = old_edge->count;\n+\t      }\n+\t    \n+          FOR_EACH_EDGE (e, ei, copy_stmt_bb->succs)\n+\t    if ((e->flags & EDGE_EH) && !e->probability.initialized_p ())\n+\t      {\n+\t        e->probability = profile_probability::never ();\n+\t        e->count = profile_count::zero ();\n+\t      }\n+        }\n+\n \n       /* If the call we inline cannot make abnormal goto do not add\n          additional abnormal edges but only retain those already present\n@@ -2317,7 +2351,8 @@ copy_edges_for_bb (basic_block bb, profile_count num, profile_count den,\n \t\t   && gimple_call_arg (copy_stmt, 0) == boolean_true_node)\n \t    nonlocal_goto = false;\n \t  else\n-\t    make_edge (copy_stmt_bb, abnormal_goto_dest, EDGE_ABNORMAL);\n+\t    make_single_succ_edge (copy_stmt_bb, abnormal_goto_dest,\n+\t\t\t\t   EDGE_ABNORMAL);\n \t}\n \n       if ((can_throw || nonlocal_goto)\n@@ -2789,7 +2824,7 @@ copy_cfg_body (copy_body_data * id, profile_count count, int frequency_scale,\n   if (new_entry)\n     {\n       edge e = make_edge (entry_block_map, (basic_block)new_entry->aux, EDGE_FALLTHRU);\n-      e->probability = REG_BR_PROB_BASE;\n+      e->probability = profile_probability::always ();\n       e->count = incoming_count;\n     }\n "}, {"sha": "a47ea5c149e0ed1920fe3b02b5dc67bf22c71a5a", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -2115,10 +2115,12 @@ create_parallel_loop (struct loop *loop, tree loop_fn, tree data,\n   gcc_assert (exit == single_dom_exit (loop));\n \n   guard = make_edge (for_bb, ex_bb, 0);\n+  /* FIXME: What is the probability?  */\n+  guard->probability = profile_probability::guessed_never ();\n   /* Split the latch edge, so LOOPS_HAVE_SIMPLE_LATCHES is still valid.  */\n   loop->latch = split_edge (single_succ_edge (loop->latch));\n   single_pred_edge (loop->latch)->flags = 0;\n-  end = make_edge (single_pred (loop->latch), ex_bb, EDGE_FALLTHRU);\n+  end = make_single_succ_edge (single_pred (loop->latch), ex_bb, EDGE_FALLTHRU);\n   rescan_loop_exit (end, true, false);\n \n   for (gphi_iterator gpi = gsi_start_phis (ex_bb);\n@@ -2358,7 +2360,9 @@ gen_parallel_loop (struct loop *loop,\n       /* We assume that the loop usually iterates a lot.  */\n       prob = 4 * REG_BR_PROB_BASE / 5;\n       loop_version (loop, many_iterations_cond, NULL,\n-\t\t    prob, REG_BR_PROB_BASE - prob,\n+\t\t    profile_probability::from_reg_br_prob_base (prob),\n+\t\t    profile_probability::from_reg_br_prob_base\n+\t\t\t\t (REG_BR_PROB_BASE - prob),\n \t\t    prob, REG_BR_PROB_BASE - prob, true);\n       update_ssa (TODO_update_ssa);\n       free_original_copy_tables ();\n@@ -3132,6 +3136,8 @@ oacc_entry_exit_single_gang (bitmap in_loop_bbs, vec<basic_block> region_bbs,\n \t    gsi_insert_after (&gsi2, cond, GSI_NEW_STMT);\n \n \t    edge e3 = make_edge (bb, bb3, EDGE_FALSE_VALUE);\n+\t    /* FIXME: What is the probability?  */\n+\t    e3->probability = profile_probability::guessed_never ();\n \t    e->flags = EDGE_TRUE_VALUE;\n \n \t    tree vdef = gimple_vdef (stmt);"}, {"sha": "b1ee7f2b3f53d4f7c54c385fbce76fe133b1ea89", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -436,16 +436,16 @@ gimple_gen_ic_func_profiler (void)\n   edge true_edge = single_succ_edge (cond_bb);\n   true_edge->flags = EDGE_TRUE_VALUE;\n \n-  int probability;\n+  profile_probability probability;\n   if (DECL_VIRTUAL_P (current_function_decl))\n-    probability = PROB_VERY_LIKELY;\n+    probability = profile_probability::very_likely ();\n   else\n-    probability = PROB_UNLIKELY;\n+    probability = profile_probability::unlikely ();\n \n   true_edge->probability = probability;\n   edge e = make_edge (cond_bb, single_succ_edge (update_bb)->dest,\n \t\t      EDGE_FALSE_VALUE);\n-  e->probability = REG_BR_PROB_BASE - true_edge->probability;\n+  e->probability = true_edge->probability.invert ();\n \n   /* Insert code:\n \n@@ -497,10 +497,10 @@ gimple_gen_time_profiler (unsigned tag, unsigned base)\n \n   edge true_edge = single_succ_edge (cond_bb);\n   true_edge->flags = EDGE_TRUE_VALUE;\n-  true_edge->probability = PROB_UNLIKELY;\n+  true_edge->probability = profile_probability::unlikely ();\n   edge e\n     = make_edge (cond_bb, single_succ_edge (update_bb)->dest, EDGE_FALSE_VALUE);\n-  e->probability = REG_BR_PROB_BASE - true_edge->probability;\n+  e->probability = true_edge->probability.invert ();\n \n   gimple_stmt_iterator gsi = gsi_start_bb (cond_bb);\n   tree original_ref = tree_coverage_counter_ref (tag, base);"}, {"sha": "e62afad1bea7e3c1adf42a1c323aa9fdadfc20ec", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -1054,7 +1054,7 @@ remove_dead_stmt (gimple_stmt_iterator *i, basic_block bb)\n \t      e = e2;\n \t}\n       gcc_assert (e);\n-      e->probability = REG_BR_PROB_BASE;\n+      e->probability = profile_probability::always ();\n       e->count = bb->count;\n \n       /* The edge is no longer associated with a conditional, so it does"}, {"sha": "c564ea104bce63f3a112ba2ef81d4d09ca0b8c57", "filename": "gcc/tree-ssa-ifcombine.c", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Ftree-ssa-ifcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Ftree-ssa-ifcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ifcombine.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -363,18 +363,14 @@ update_profile_after_ifcombine (basic_block inner_cond_bb,\n   inner_taken->count += outer2->count;\n   outer2->count = profile_count::zero ();\n \n-  inner_taken->probability = outer2->probability\n-\t\t\t     + RDIV (outer_to_inner->probability\n-\t\t\t\t     * inner_taken->probability,\n-\t\t\t\t     REG_BR_PROB_BASE);\n-  if (inner_taken->probability > REG_BR_PROB_BASE)\n-    inner_taken->probability = REG_BR_PROB_BASE;\n-  inner_not_taken->probability = REG_BR_PROB_BASE\n+  inner_taken->probability = outer2->probability + outer_to_inner->probability\n+\t\t\t     * inner_taken->probability;\n+  inner_not_taken->probability = profile_probability::always ()\n \t\t\t\t - inner_taken->probability;\n \n-  outer_to_inner->probability = REG_BR_PROB_BASE;\n+  outer_to_inner->probability = profile_probability::always ();\n   inner_cond_bb->frequency = outer_cond_bb->frequency;\n-  outer2->probability = 0;\n+  outer2->probability = profile_probability::never ();\n }\n \n /* If-convert on a and pattern with a common else block.  The inner"}, {"sha": "2fbaa62c142eeeb8c6ffdc9c015a550af8e312e7", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -1801,7 +1801,7 @@ execute_sm_if_changed (edge ex, tree mem, tree tmp_var, tree flag,\n   int freq_sum = 0;\n   profile_count count_sum = profile_count::zero ();\n   int nbbs = 0, ncount = 0;\n-  int flag_probability = -1;\n+  profile_probability flag_probability = profile_probability::uninitialized ();\n \n   /* Flag is set in FLAG_BBS. Determine probability that flag will be true\n      at loop exit.\n@@ -1824,27 +1824,29 @@ execute_sm_if_changed (edge ex, tree mem, tree tmp_var, tree flag,\n        if ((*it)->count.initialized_p ())\n          count_sum += (*it)->count, ncount ++;\n        if (dominated_by_p (CDI_DOMINATORS, ex->src, *it))\n-\t flag_probability = REG_BR_PROB_BASE;\n+\t flag_probability = profile_probability::always ();\n        nbbs++;\n     }\n \n-  if (flag_probability != -1)\n+  profile_probability cap = profile_probability::always ().apply_scale (2, 3);\n+\n+  if (flag_probability.initialized_p ())\n     ;\n   else if (ncount == nbbs && count_sum > 0 && preheader->count >= count_sum)\n     {\n       flag_probability = count_sum.probability_in (preheader->count);\n-      if (flag_probability > REG_BR_PROB_BASE * 2 / 3)\n-\tflag_probability = REG_BR_PROB_BASE * 2 / 3;\n+      if (flag_probability > cap)\n+\tflag_probability = cap;\n     }\n   else if (freq_sum > 0 && EDGE_FREQUENCY (preheader) >= freq_sum)\n     {\n-      flag_probability = GCOV_COMPUTE_SCALE (freq_sum,\n-\t\t\t\t\t     EDGE_FREQUENCY (preheader));\n-      if (flag_probability > REG_BR_PROB_BASE * 2 / 3)\n-\tflag_probability = REG_BR_PROB_BASE * 2 / 3;\n+      flag_probability = profile_probability::from_reg_br_prob_base\n+\t\t(GCOV_COMPUTE_SCALE (freq_sum, EDGE_FREQUENCY (preheader)));\n+      if (flag_probability > cap)\n+\tflag_probability = cap;\n     }\n   else\n-    flag_probability = REG_BR_PROB_BASE * 2 / 3;\n+    flag_probability = cap;\n \n   /* ?? Insert store after previous store if applicable.  See note\n      below.  */\n@@ -1876,7 +1878,7 @@ execute_sm_if_changed (edge ex, tree mem, tree tmp_var, tree flag,\n   old_dest = ex->dest;\n   new_bb = split_edge (ex);\n   then_bb = create_empty_bb (new_bb);\n-  then_bb->frequency = apply_probability (new_bb->frequency, flag_probability);\n+  then_bb->frequency = flag_probability.apply (new_bb->frequency);\n   then_bb->count = new_bb->count.apply_probability (flag_probability);\n   if (irr)\n     then_bb->flags = BB_IRREDUCIBLE_LOOP;\n@@ -1901,13 +1903,11 @@ execute_sm_if_changed (edge ex, tree mem, tree tmp_var, tree flag,\n   e1->flags |= EDGE_FALSE_VALUE | (irr ? EDGE_IRREDUCIBLE_LOOP : 0);\n   e1->flags &= ~EDGE_FALLTHRU;\n \n-  e1->probability = REG_BR_PROB_BASE - flag_probability;\n+  e1->probability = flag_probability.invert ();\n   e1->count = new_bb->count - then_bb->count;\n \n-  then_old_edge = make_edge (then_bb, old_dest,\n+  then_old_edge = make_single_succ_edge (then_bb, old_dest,\n \t\t\t     EDGE_FALLTHRU | (irr ? EDGE_IRREDUCIBLE_LOOP : 0));\n-  then_old_edge->probability = REG_BR_PROB_BASE;\n-  then_old_edge->count = then_bb->count;\n \n   set_immediate_dominator (CDI_DOMINATORS, then_bb, new_bb);\n "}, {"sha": "4e828931f5309efd4859eebed62359be9f350f46", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -529,7 +529,7 @@ remove_exits_and_undefined_stmts (struct loop *loop, unsigned int npeeled)\n \t    }\n \t  if (!loop_exit_edge_p (loop, exit_edge))\n \t    exit_edge = EDGE_SUCC (bb, 1);\n-\t  exit_edge->probability = REG_BR_PROB_BASE;\n+\t  exit_edge->probability = profile_probability::always ();\n \t  exit_edge->count = exit_edge->src->count;\n \t  gcc_checking_assert (loop_exit_edge_p (loop, exit_edge));\n \t  gcond *cond_stmt = as_a <gcond *> (elt->stmt);\n@@ -642,7 +642,7 @@ unloop_loops (bitmap loop_closed_ssa_invalidated,\n \t it in.  */\n       stmt = gimple_build_call (builtin_decl_implicit (BUILT_IN_UNREACHABLE), 0);\n       latch_edge = make_edge (latch, create_basic_block (NULL, NULL, latch), flags);\n-      latch_edge->probability = 0;\n+      latch_edge->probability = profile_probability::never ();\n       latch_edge->count = profile_count::zero ();\n       latch_edge->flags |= flags;\n       latch_edge->goto_locus = locus;\n@@ -1106,7 +1106,7 @@ try_peel_loop (struct loop *loop,\n       }\n   int scale = 1;\n   if (loop->header->count > 0)\n-    scale = entry_count.probability_in (loop->header->count);\n+    scale = entry_count.probability_in (loop->header->count).to_reg_br_prob_base ();\n   else if (loop->header->frequency)\n     scale = RDIV (entry_freq * REG_BR_PROB_BASE, loop->header->frequency);\n   scale_loop_profile (loop, scale, 0);"}, {"sha": "b2c1ccdd6f44bb974436927dfd876a537e201bed", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -1244,7 +1244,10 @@ tree_transform_and_unroll_loop (struct loop *loop, unsigned factor,\n   scale_rest = REG_BR_PROB_BASE;\n \n   new_loop = loop_version (loop, enter_main_cond, NULL,\n-\t\t\t   prob_entry, REG_BR_PROB_BASE - prob_entry,\n+\t\t\t   profile_probability::from_reg_br_prob_base\n+\t\t\t\t (prob_entry),\n+\t\t\t   profile_probability::from_reg_br_prob_base\n+\t\t\t\t (REG_BR_PROB_BASE - prob_entry),\n \t\t\t   scale_unrolled, scale_rest, true);\n   gcc_assert (new_loop != NULL);\n   update_ssa (TODO_update_ssa);\n@@ -1259,9 +1262,11 @@ tree_transform_and_unroll_loop (struct loop *loop, unsigned factor,\n   /* Since the exit edge will be removed, the frequency of all the blocks\n      in the loop that are dominated by it must be scaled by\n      1 / (1 - exit->probability).  */\n-  scale_dominated_blocks_in_loop (loop, exit->src,\n-\t\t\t\t  REG_BR_PROB_BASE,\n-\t\t\t\t  REG_BR_PROB_BASE - exit->probability);\n+  if (exit->probability.initialized_p ())\n+    scale_dominated_blocks_in_loop (loop, exit->src,\n+\t\t\t\t    REG_BR_PROB_BASE,\n+\t\t\t\t    REG_BR_PROB_BASE\n+\t\t\t\t    - exit->probability.to_reg_br_prob_base ());\n \n   bsi = gsi_last_bb (exit_bb);\n   exit_if = gimple_build_cond (EQ_EXPR, integer_zero_node,\n@@ -1278,11 +1283,13 @@ tree_transform_and_unroll_loop (struct loop *loop, unsigned factor,\n   new_exit->count = exit->count;\n   new_exit->probability = exit->probability;\n   new_nonexit = single_pred_edge (loop->latch);\n-  new_nonexit->probability = REG_BR_PROB_BASE - exit->probability;\n+  new_nonexit->probability = exit->probability.invert ();\n   new_nonexit->flags = EDGE_TRUE_VALUE;\n   new_nonexit->count -= exit->count;\n-  scale_bbs_frequencies_int (&loop->latch, 1, new_nonexit->probability,\n-\t\t\t     REG_BR_PROB_BASE);\n+  if (new_nonexit->probability.initialized_p ())\n+    scale_bbs_frequencies_int (&loop->latch, 1,\n+\t\t\t       new_nonexit->probability.to_reg_br_prob_base (),\n+\t\t\t       REG_BR_PROB_BASE);\n \n   old_entry = loop_preheader_edge (loop);\n   new_entry = loop_preheader_edge (new_loop);\n@@ -1368,24 +1375,29 @@ tree_transform_and_unroll_loop (struct loop *loop, unsigned factor,\n       if (freq_e == profile_count::zero ())\n         freq_e = profile_count::from_gcov_type (1);\n       /* This should not overflow.  */\n-      scale = freq_e.probability_in (freq_h);\n+      scale = freq_e.probability_in (freq_h).to_reg_br_prob_base ();\n       scale_loop_frequencies (loop, scale, REG_BR_PROB_BASE);\n     }\n \n   exit_bb = single_pred (loop->latch);\n   new_exit = find_edge (exit_bb, rest);\n   new_exit->count = loop_preheader_edge (loop)->count;\n-  new_exit->probability = REG_BR_PROB_BASE / (new_est_niter + 1);\n+  new_exit->probability = profile_probability::always ()\n+\t\t\t\t.apply_scale (1, new_est_niter + 1);\n \n   rest->count += new_exit->count;\n   rest->frequency += EDGE_FREQUENCY (new_exit);\n \n   new_nonexit = single_pred_edge (loop->latch);\n-  prob = new_nonexit->probability;\n-  new_nonexit->probability = REG_BR_PROB_BASE - new_exit->probability;\n+  if (new_nonexit->probability.initialized_p ())\n+    prob = new_nonexit->probability.to_reg_br_prob_base ();\n+  else\n+    prob = 0;\n+  new_nonexit->probability = new_exit->probability.invert ();\n   new_nonexit->count = exit_bb->count - new_exit->count;\n   if (prob > 0)\n-    scale_bbs_frequencies_int (&loop->latch, 1, new_nonexit->probability,\n+    scale_bbs_frequencies_int (&loop->latch, 1,\n+\t\t\t       new_nonexit->probability.to_reg_br_prob_base (),\n \t\t\t       prob);\n \n   /* Finally create the new counter for number of iterations and add the new"}, {"sha": "2d57957dcfde498d3a3d870f76d417ee780a4cfe", "filename": "gcc/tree-ssa-loop-split.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Ftree-ssa-loop-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Ftree-ssa-loop-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-split.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -354,10 +354,10 @@ connect_loops (struct loop *loop1, struct loop *loop2)\n     }\n \n   new_e->count = skip_bb->count;\n-  new_e->probability = PROB_LIKELY;\n+  new_e->probability = profile_probability::likely ();\n   new_e->count = skip_e->count.apply_probability (PROB_LIKELY);\n   skip_e->count -= new_e->count;\n-  skip_e->probability = inverse_probability (PROB_LIKELY);\n+  skip_e->probability = profile_probability::unlikely ();\n \n   return new_e;\n }\n@@ -559,8 +559,11 @@ split_loop (struct loop *loop1, struct tree_niter_desc *niter)\n \t   them, and fix up SSA form for that.  */\n \tinitialize_original_copy_tables ();\n \tbasic_block cond_bb;\n+\n+\t/* FIXME: probabilities seems wrong here.  */\n \tstruct loop *loop2 = loop_version (loop1, cond, &cond_bb,\n-\t\t\t\t\t   REG_BR_PROB_BASE, REG_BR_PROB_BASE,\n+\t\t\t\t\t   profile_probability::always (),\n+\t\t\t\t\t   profile_probability::always (),\n \t\t\t\t\t   REG_BR_PROB_BASE, REG_BR_PROB_BASE,\n \t\t\t\t\t   true);\n \tgcc_assert (loop2);"}, {"sha": "6ad5741827b9e9012a820bd754a667a744566133", "filename": "gcc/tree-ssa-loop-unswitch.c", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Ftree-ssa-loop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Ftree-ssa-loop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-unswitch.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -480,7 +480,7 @@ static struct loop *\n tree_unswitch_loop (struct loop *loop,\n \t\t    basic_block unswitch_on, tree cond)\n {\n-  unsigned prob_true;\n+  profile_probability prob_true;\n   edge edge_true, edge_false;\n \n   /* Some sanity checking.  */\n@@ -490,9 +490,13 @@ tree_unswitch_loop (struct loop *loop,\n \n   extract_true_false_edges_from_block (unswitch_on, &edge_true, &edge_false);\n   prob_true = edge_true->probability;\n+  int p = prob_true.initialized_p () ? prob_true.to_reg_br_prob_base ()\n+\t\t\t\t     : REG_BR_PROB_BASE / 2;\n   return loop_version (loop, unshare_expr (cond),\n-\t\t       NULL, prob_true, REG_BR_PROB_BASE - prob_true, prob_true,\n-\t\t       REG_BR_PROB_BASE - prob_true, false);\n+\t\t       NULL, prob_true,\n+\t\t       prob_true.invert (),\n+\t\t       p, REG_BR_PROB_BASE - p,\n+\t\t       false);\n }\n \n /* Unswitch outer loops by hoisting invariant guard on\n@@ -818,10 +822,13 @@ hoist_guard (struct loop *loop, edge guard)\n   /* Create new loop pre-header.  */\n   e = split_block (pre_header, last_stmt (pre_header));\n   if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"  Moving guard %i->%i (prob %i) to bb %i, \"\n-\t     \"new preheader is %i\\n\",\n-\t     guard->src->index, guard->dest->index, guard->probability,\n-\t     e->src->index, e->dest->index);\n+    {\n+      fprintf (dump_file, \"  Moving guard %i->%i (prob \",\n+\t       guard->src->index, guard->dest->index);\n+      guard->probability.dump (dump_file);\n+      fprintf (dump_file, \") to bb %i, new preheader is %i\\n\",\n+\t       e->src->index, e->dest->index);\n+    }\n \n   gcc_assert (loop_preheader_edge (loop)->src == e->dest);\n \n@@ -854,23 +861,26 @@ hoist_guard (struct loop *loop, edge guard)\n     }\n   new_edge->count = skip_count;\n   if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"  Estimated probability of skipping loop is %i\\n\",\n-\t     new_edge->probability);\n+    {\n+      fprintf (dump_file, \"  Estimated probability of skipping loop is \");\n+      new_edge->probability.dump (dump_file);\n+      fprintf (dump_file, \"\\n\");\n+    }\n \n   /* Update profile after the transform:\n \n      First decrease count of path from newly hoisted loop guard\n      to loop header...  */\n   e->count -= skip_count;\n-  e->probability = REG_BR_PROB_BASE - new_edge->probability;\n+  e->probability = new_edge->probability.invert ();\n   e->dest->count = e->count;\n   e->dest->frequency = EDGE_FREQUENCY (e);\n \n   /* ... now update profile to represent that original guard will be optimized\n      away ...  */\n-  guard->probability = 0;\n+  guard->probability = profile_probability::never ();\n   guard->count = profile_count::zero ();\n-  not_guard->probability = REG_BR_PROB_BASE;\n+  not_guard->probability = profile_probability::always ();\n   /* This count is wrong (frequency of not_guard does not change),\n      but will be scaled later.  */\n   not_guard->count = guard->src->count;\n@@ -888,7 +898,10 @@ hoist_guard (struct loop *loop, edge guard)\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file, \" %i\", bb->index);\n-          scale_bbs_frequencies_int (&bb, 1, e->probability, REG_BR_PROB_BASE);\n+\t  if (e->probability.initialized_p ())\n+            scale_bbs_frequencies_int (&bb, 1,\n+\t\t\t\t       e->probability.to_reg_br_prob_base (),\n+\t\t\t\t       REG_BR_PROB_BASE);\n   \t}\n     }\n "}, {"sha": "65af44834df71592d80d546ffa779a245f5765f5", "filename": "gcc/tree-ssa-phionlycprop.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Ftree-ssa-phionlycprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Ftree-ssa-phionlycprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phionlycprop.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -313,8 +313,6 @@ propagate_rhs_into_lhs (gimple *stmt, tree lhs, tree rhs,\n \t\t  te->flags &= ~(EDGE_TRUE_VALUE | EDGE_FALSE_VALUE);\n \t\t  te->flags &= ~EDGE_ABNORMAL;\n \t\t  te->flags |= EDGE_FALLTHRU;\n-\t\t  if (te->probability > REG_BR_PROB_BASE)\n-\t\t    te->probability = REG_BR_PROB_BASE;\n \t        }\n \t    }\n \t}"}, {"sha": "f5c07dc27f116cdc25190c34dc328158581b1cb5", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -374,7 +374,7 @@ replace_phi_edge_with_variable (basic_block cond_block,\n     {\n       EDGE_SUCC (cond_block, 0)->flags |= EDGE_FALLTHRU;\n       EDGE_SUCC (cond_block, 0)->flags &= ~(EDGE_TRUE_VALUE | EDGE_FALSE_VALUE);\n-      EDGE_SUCC (cond_block, 0)->probability = REG_BR_PROB_BASE;\n+      EDGE_SUCC (cond_block, 0)->probability = profile_probability::always ();\n       EDGE_SUCC (cond_block, 0)->count += EDGE_SUCC (cond_block, 1)->count;\n \n       block_to_remove = EDGE_SUCC (cond_block, 1)->dest;\n@@ -384,7 +384,7 @@ replace_phi_edge_with_variable (basic_block cond_block,\n       EDGE_SUCC (cond_block, 1)->flags |= EDGE_FALLTHRU;\n       EDGE_SUCC (cond_block, 1)->flags\n \t&= ~(EDGE_TRUE_VALUE | EDGE_FALSE_VALUE);\n-      EDGE_SUCC (cond_block, 1)->probability = REG_BR_PROB_BASE;\n+      EDGE_SUCC (cond_block, 1)->probability = profile_probability::always ();\n       EDGE_SUCC (cond_block, 1)->count += EDGE_SUCC (cond_block, 0)->count;\n \n       block_to_remove = EDGE_SUCC (cond_block, 0)->dest;\n@@ -1017,7 +1017,7 @@ value_replacement (basic_block cond_bb, basic_block middle_bb,\n   if (optimize_bb_for_speed_p (cond_bb)\n       /* The special case is useless if it has a low probability.  */\n       && profile_status_for_fn (cfun) != PROFILE_ABSENT\n-      && EDGE_PRED (middle_bb, 0)->probability < PROB_EVEN\n+      && EDGE_PRED (middle_bb, 0)->probability < profile_probability::even ()\n       /* If assign is cheap, there is no point avoiding it.  */\n       && estimate_num_insns (assign, &eni_time_weights)\n \t >= 3 * estimate_num_insns (cond, &eni_time_weights))"}, {"sha": "2f49ba135539af0c06722f46e9edbde918949553", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -5843,7 +5843,7 @@ branch_fixup (void)\n       gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n \n       edge etrue = make_edge (cond_bb, merge_bb, EDGE_TRUE_VALUE);\n-      etrue->probability = REG_BR_PROB_BASE / 2;\n+      etrue->probability = profile_probability::even ();\n       etrue->count = cond_bb->count.apply_scale (1, 2);\n       edge efalse = find_edge (cond_bb, then_bb);\n       efalse->flags = EDGE_FALSE_VALUE;"}, {"sha": "db836f7187f848d826070082f391dbd4f53da76b", "filename": "gcc/tree-ssa-tail-merge.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Ftree-ssa-tail-merge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Ftree-ssa-tail-merge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-tail-merge.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -1592,9 +1592,10 @@ replace_block_by (basic_block bb1, basic_block bb2)\n       else if (bb2->frequency && !bb1->frequency)\n \t;\n       else if (out_freq_sum)\n-\te2->probability = GCOV_COMPUTE_SCALE (EDGE_FREQUENCY (e1)\n-\t\t\t\t\t      + EDGE_FREQUENCY (e2),\n-\t\t\t\t\t      out_freq_sum);\n+\te2->probability = profile_probability::from_reg_br_prob_base\n+\t\t(GCOV_COMPUTE_SCALE (EDGE_FREQUENCY (e1)\n+\t\t\t\t     + EDGE_FREQUENCY (e2),\n+\t\t\t\t     out_freq_sum));\n       out_sum += e2->count;\n     }\n   bb2->frequency += bb1->frequency;"}, {"sha": "f5bc95f092f749ccf930f4e786fad9eb8a6b09c1", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -302,7 +302,7 @@ remove_ctrl_stmt_and_useless_edges (basic_block bb, basic_block dest_bb)\n \t}\n       else\n \t{\n-\t  e->probability = REG_BR_PROB_BASE;\n+\t  e->probability = profile_probability::always ();\n \t  e->count = bb->count;\n \t  ei_next (&ei);\n \t}\n@@ -546,11 +546,9 @@ static void\n create_edge_and_update_destination_phis (struct redirection_data *rd,\n \t\t\t\t\t basic_block bb, int idx)\n {\n-  edge e = make_edge (bb, rd->path->last ()->e->dest, EDGE_FALLTHRU);\n+  edge e = make_single_succ_edge (bb, rd->path->last ()->e->dest, EDGE_FALLTHRU);\n \n   rescan_loop_exit (e, true, false);\n-  e->probability = REG_BR_PROB_BASE;\n-  e->count = bb->count;\n \n   /* We used to copy the thread path here.  That was added in 2007\n      and dutifully updated through the representation changes in 2013.\n@@ -765,7 +763,8 @@ compute_path_counts (struct redirection_data *rd,\n   /* Handle incoming profile insanities.  */\n   if (total_count < path_in_count)\n     path_in_count = total_count;\n-  int onpath_scale = path_in_count.probability_in (total_count);\n+  int onpath_scale\n+\t = path_in_count.probability_in (total_count).to_reg_br_prob_base ();\n \n   /* Walk the entire path to do some more computation in order to estimate\n      how much of the path_in_count will flow out of the duplicated threading\n@@ -919,7 +918,7 @@ recompute_probabilities (basic_block bb)\n \t   get a flow verification error.\n \t   Not much we can do to make counts/freqs sane without\n \t   redoing the profile estimation.  */\n-\tesucc->probability = REG_BR_PROB_BASE;\n+\tesucc->probability = profile_probability::guessed_always ();\n     }\n }\n \n@@ -978,7 +977,8 @@ update_joiner_offpath_counts (edge epath, basic_block dup_bb,\n \t among the duplicated off-path edges based on their original\n \t ratio to the full off-path count (total_orig_off_path_count).\n \t */\n-      int scale = enonpath->count.probability_in (total_orig_off_path_count);\n+      int scale = enonpath->count.probability_in (total_orig_off_path_count)\n+\t\t\t.to_reg_br_prob_base ();\n       /* Give the duplicated offpath edge a portion of the duplicated\n \t total.  */\n       enonpathdup->count = total_dup_off_path_count.apply_probability (scale);\n@@ -1048,9 +1048,13 @@ freqs_to_counts_path (struct redirection_data *rd)\n       /* Scale up the frequency by REG_BR_PROB_BASE, to avoid rounding\n \t errors applying the probability when the frequencies are very\n \t small.  */\n-      ein->count = profile_count::from_gcov_type\n-\t\t(apply_probability (ein->src->frequency * REG_BR_PROB_BASE,\n-\t\t\t\t      ein->probability));\n+      if (ein->probability.initialized_p ())\n+        ein->count = profile_count::from_gcov_type\n+\t\t  (apply_probability (ein->src->frequency * REG_BR_PROB_BASE,\n+\t\t\t\t        ein->probability.to_reg_br_prob_base ()));\n+      else\n+\t/* FIXME: this is hack; we should track uninitialized values.  */\n+\tein->count = profile_count::zero ();\n     }\n \n   for (unsigned int i = 1; i < path->length (); i++)\n@@ -2358,7 +2362,7 @@ duplicate_thread_path (edge entry, edge exit,\n   if (e)\n     {\n       rescan_loop_exit (e, true, false);\n-      e->probability = REG_BR_PROB_BASE;\n+      e->probability = profile_probability::always ();\n       e->count = region_copy[n_region - 1]->count;\n     }\n "}, {"sha": "e5b5cb9a0be6c598e7fe08646dd45068b121a049", "filename": "gcc/tree-switch-conversion.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Ftree-switch-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Ftree-switch-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -103,7 +103,7 @@ hoist_edge_and_branch_if_true (gimple_stmt_iterator *gsip,\n \n   e_false->flags &= ~EDGE_FALLTHRU;\n   e_false->flags |= EDGE_FALSE_VALUE;\n-  e_false->probability = REG_BR_PROB_BASE - e_true->probability;\n+  e_false->probability = e_true->probability.invert ();\n   e_false->count = split_bb->count - e_true->count;\n   new_bb->count = e_false->count;\n \n@@ -556,7 +556,7 @@ struct switch_conv_info\n   basic_block final_bb;\n \n   /* The probability of the default edge in the replaced switch.  */\n-  int default_prob;\n+  profile_probability default_prob;\n \n   /* The count of the default edge in the replaced switch.  */\n   profile_count default_count;\n@@ -1422,7 +1422,7 @@ gen_inbound_check (gswitch *swtch, struct switch_conv_info *info)\n   /* flags and profiles of the edge for in-range values */\n   if (!info->default_case_nonstandard)\n     e01 = make_edge (bb0, bb1, EDGE_TRUE_VALUE);\n-  e01->probability = REG_BR_PROB_BASE - info->default_prob;\n+  e01->probability = info->default_prob.invert ();\n   e01->count = info->other_count;\n \n   /* flags and profiles of the edge taking care of out-of-range values */\n@@ -1434,15 +1434,15 @@ gen_inbound_check (gswitch *swtch, struct switch_conv_info *info)\n   bbf = info->final_bb;\n \n   e1f = make_edge (bb1, bbf, EDGE_FALLTHRU);\n-  e1f->probability = REG_BR_PROB_BASE;\n+  e1f->probability = profile_probability::always ();\n   e1f->count = info->other_count;\n \n   if (info->default_case_nonstandard)\n     e2f = NULL;\n   else\n     {\n       e2f = make_edge (bb2, bbf, EDGE_FALLTHRU);\n-      e2f->probability = REG_BR_PROB_BASE;\n+      e2f->probability = profile_probability::always ();\n       e2f->count = info->default_count;\n     }\n "}, {"sha": "e41372b02358361c91a6ad8bec5dbb7ae71b6630", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 31, "deletions": 19, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -540,7 +540,7 @@ slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *loop,\n static edge\n slpeel_add_loop_guard (basic_block guard_bb, tree cond,\n \t\t       basic_block guard_to, basic_block dom_bb,\n-\t\t       int probability, bool irreducible_p)\n+\t\t       profile_probability probability, bool irreducible_p)\n {\n   gimple_stmt_iterator gsi;\n   edge new_e, enter_e;\n@@ -571,7 +571,7 @@ slpeel_add_loop_guard (basic_block guard_bb, tree cond,\n     new_e->flags |= EDGE_IRREDUCIBLE_LOOP;\n \n   enter_e->count -= new_e->count;\n-  enter_e->probability = inverse_probability (probability);\n+  enter_e->probability = probability.invert ();\n   set_immediate_dominator (CDI_DOMINATORS, guard_to, dom_bb);\n \n   /* Split enter_e to preserve LOOPS_HAVE_PREHEADERS.  */\n@@ -1660,7 +1660,7 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n   edge e, guard_e;\n   tree type = TREE_TYPE (niters), guard_cond;\n   basic_block guard_bb, guard_to;\n-  int prob_prolog, prob_vector, prob_epilog;\n+  profile_probability prob_prolog, prob_vector, prob_epilog;\n   int bound_prolog = 0, bound_scalar = 0, bound = 0;\n   int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n   int prolog_peeling = LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo);\n@@ -1670,10 +1670,11 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n   if (!prolog_peeling && !epilog_peeling)\n     return NULL;\n \n-  prob_vector = 9 * REG_BR_PROB_BASE / 10;\n+  prob_vector = profile_probability::guessed_always ().apply_scale (9, 10);\n   if ((vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo)) == 2)\n     vf = 3;\n-  prob_prolog = prob_epilog = (vf - 1) * REG_BR_PROB_BASE / vf;\n+  prob_prolog = prob_epilog = profile_probability::guessed_always ()\n+\t\t\t.apply_scale (vf - 1, vf);\n   vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n \n   struct loop *prolog, *epilog = NULL, *loop = LOOP_VINFO_LOOP (loop_vinfo);\n@@ -1718,9 +1719,11 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n \t separately.  Note in this case, the probability of epilog loop\n \t needs to be scaled back later.  */\n       basic_block bb_before_loop = loop_preheader_edge (loop)->src;\n-      scale_bbs_frequencies_int (&bb_before_loop, 1, prob_vector,\n+      if (prob_vector.initialized_p ())\n+      scale_bbs_frequencies_int (&bb_before_loop, 1,\n+\t\t\t\t prob_vector.to_reg_br_prob_base (),\n \t\t\t\t REG_BR_PROB_BASE);\n-      scale_loop_profile (loop, prob_vector, bound);\n+      scale_loop_profile (loop, prob_vector.to_reg_br_prob_base (), bound);\n     }\n \n   tree niters_prolog = build_int_cst (type, 0);\n@@ -1762,15 +1765,17 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n \t  guard_to = split_edge (loop_preheader_edge (loop));\n \t  guard_e = slpeel_add_loop_guard (guard_bb, guard_cond,\n \t\t\t\t\t   guard_to, guard_bb,\n-\t\t\t\t\t   inverse_probability (prob_prolog),\n+\t\t\t\t\t   prob_prolog.invert (),\n \t\t\t\t\t   irred_flag);\n \t  e = EDGE_PRED (guard_to, 0);\n \t  e = (e != guard_e ? e : EDGE_PRED (guard_to, 1));\n \t  slpeel_update_phi_nodes_for_guard1 (prolog, loop, guard_e, e);\n \n-\t  scale_bbs_frequencies_int (&bb_after_prolog, 1, prob_prolog,\n+\t  scale_bbs_frequencies_int (&bb_after_prolog, 1,\n+\t\t\t\t     prob_prolog.to_reg_br_prob_base (),\n \t\t\t\t     REG_BR_PROB_BASE);\n-\t  scale_loop_profile (prolog, prob_prolog, bound_prolog);\n+\t  scale_loop_profile (prolog, prob_prolog.to_reg_br_prob_base (),\n+\t\t\t      bound_prolog);\n \t}\n       /* Update init address of DRs.  */\n       vect_update_inits_of_drs (loop_vinfo, niters_prolog);\n@@ -1834,7 +1839,7 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n \t  guard_to = split_edge (loop_preheader_edge (epilog));\n \t  guard_e = slpeel_add_loop_guard (guard_bb, guard_cond,\n \t\t\t\t\t   guard_to, guard_bb,\n-\t\t\t\t\t   inverse_probability (prob_vector),\n+\t\t\t\t\t   prob_vector.invert (),\n \t\t\t\t\t   irred_flag);\n \t  e = EDGE_PRED (guard_to, 0);\n \t  e = (e != guard_e ? e : EDGE_PRED (guard_to, 1));\n@@ -1846,7 +1851,8 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n \t  guard_to->count = guard_bb->count;\n \t  single_succ_edge (guard_to)->count = guard_to->count;\n \t  /* Scale probability of epilog loop back.  */\n-\t  int scale_up = REG_BR_PROB_BASE * REG_BR_PROB_BASE / prob_vector;\n+\t  int scale_up = REG_BR_PROB_BASE * REG_BR_PROB_BASE\n+\t\t\t / prob_vector.to_reg_br_prob_base ();\n \t  scale_loop_frequencies (epilog, scale_up, REG_BR_PROB_BASE);\n \t}\n \n@@ -1875,21 +1881,21 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n \t  guard_to = split_edge (single_exit (epilog));\n \t  guard_e = slpeel_add_loop_guard (guard_bb, guard_cond, guard_to,\n \t\t\t\t\t   skip_vector ? anchor : guard_bb,\n-\t\t\t\t\t   inverse_probability (prob_epilog),\n+\t\t\t\t\t   prob_epilog.invert (),\n \t\t\t\t\t   irred_flag);\n \t  slpeel_update_phi_nodes_for_guard2 (loop, epilog, guard_e,\n \t\t\t\t\t      single_exit (epilog));\n \t  /* Only need to handle basic block before epilog loop if it's not\n \t     the guard_bb, which is the case when skip_vector is true.  */\n \t  if (guard_bb != bb_before_epilog)\n \t    {\n-\t      prob_epilog = (combine_probabilities (prob_vector, prob_epilog)\n-\t\t\t     + inverse_probability (prob_vector));\n+\t      prob_epilog = prob_vector * prob_epilog + prob_vector.invert ();\n \n-\t      scale_bbs_frequencies_int (&bb_before_epilog, 1, prob_epilog,\n+\t      scale_bbs_frequencies_int (&bb_before_epilog, 1,\n+\t\t\t\t\t prob_epilog.to_reg_br_prob_base (),\n \t\t\t\t\t REG_BR_PROB_BASE);\n \t    }\n-\t  scale_loop_profile (epilog, prob_epilog, bound);\n+\t  scale_loop_profile (epilog, prob_epilog.to_reg_br_prob_base (), bound);\n \t}\n       else\n \tslpeel_update_phi_nodes_for_lcssa (epilog);\n@@ -2171,7 +2177,10 @@ vect_loop_versioning (loop_vec_info loop_vinfo,\n       /* We don't want to scale SCALAR_LOOP's frequencies, we need to\n \t scale LOOP's frequencies instead.  */\n       nloop = loop_version (scalar_loop, cond_expr, &condition_bb,\n-\t\t\t    prob, REG_BR_PROB_BASE - prob,\n+\t\t\t    profile_probability::guessed_always ().apply_scale \n+\t\t\t\t(prob, REG_BR_PROB_BASE),\n+\t\t\t    profile_probability::guessed_always ().apply_scale\n+\t\t\t\t (REG_BR_PROB_BASE - prob, REG_BR_PROB_BASE),\n \t\t\t    REG_BR_PROB_BASE, REG_BR_PROB_BASE - prob, true);\n       scale_loop_frequencies (loop, prob, REG_BR_PROB_BASE);\n       /* CONDITION_BB was created above SCALAR_LOOP's preheader,\n@@ -2200,7 +2209,10 @@ vect_loop_versioning (loop_vec_info loop_vinfo,\n     }\n   else\n     nloop = loop_version (loop, cond_expr, &condition_bb,\n-\t\t\t  prob, REG_BR_PROB_BASE - prob,\n+\t\t\t  profile_probability::guessed_always ().apply_scale \n+\t\t\t      (prob, REG_BR_PROB_BASE),\n+\t\t\t  profile_probability::guessed_always ().apply_scale\n+\t\t\t       (REG_BR_PROB_BASE - prob, REG_BR_PROB_BASE),\n \t\t\t  prob, REG_BR_PROB_BASE - prob, true);\n \n   if (version_niter)"}, {"sha": "576a42fc42fe3f09de96e7fcd88bf87283624d8b", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -7123,21 +7123,25 @@ scale_profile_for_vect_loop (struct loop *loop, unsigned vf)\n       if (!(freq_e > profile_count::from_gcov_type (1)))\n        freq_e = profile_count::from_gcov_type (1);\n       /* This should not overflow.  */\n-      scale = freq_e.apply_scale (new_est_niter + 1, 1).probability_in (freq_h);\n+      scale = freq_e.apply_scale (new_est_niter + 1, 1).probability_in (freq_h)\n+\t\t\t.to_reg_br_prob_base ();\n       scale_loop_frequencies (loop, scale, REG_BR_PROB_BASE);\n     }\n \n   basic_block exit_bb = single_pred (loop->latch);\n   edge exit_e = single_exit (loop);\n   exit_e->count = loop_preheader_edge (loop)->count;\n-  exit_e->probability = REG_BR_PROB_BASE / (new_est_niter + 1);\n+  exit_e->probability = profile_probability::always ()\n+\t\t\t\t .apply_scale (1, new_est_niter + 1);\n \n   edge exit_l = single_pred_edge (loop->latch);\n-  int prob = exit_l->probability;\n-  exit_l->probability = REG_BR_PROB_BASE - exit_e->probability;\n+  int prob = exit_l->probability.initialized_p ()\n+\t     ? exit_l->probability.to_reg_br_prob_base () : 0;\n+  exit_l->probability = exit_e->probability.invert ();\n   exit_l->count = exit_bb->count - exit_e->count;\n   if (prob > 0)\n-    scale_bbs_frequencies_int (&loop->latch, 1, exit_l->probability, prob);\n+    scale_bbs_frequencies_int (&loop->latch, 1,\n+\t\t\t       exit_l->probability.to_reg_br_prob_base (), prob);\n }\n \n /* Function vect_transform_loop.\n@@ -7660,7 +7664,7 @@ optimize_mask_stores (struct loop *loop)\n       e->flags = EDGE_TRUE_VALUE;\n       efalse = make_edge (bb, store_bb, EDGE_FALSE_VALUE);\n       /* Put STORE_BB to likely part.  */\n-      efalse->probability = PROB_UNLIKELY;\n+      efalse->probability = profile_probability::unlikely ();\n       store_bb->frequency = PROB_ALWAYS - EDGE_FREQUENCY (efalse);\n       make_edge (store_bb, join_bb, EDGE_FALLTHRU);\n       if (dom_info_available_p (CDI_DOMINATORS))"}, {"sha": "8ea352a69d400e856623de2e4ef33e4f2bf53037", "filename": "gcc/ubsan.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fubsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fubsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fubsan.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -799,7 +799,7 @@ ubsan_expand_null_ifn (gimple_stmt_iterator *gsip)\n   /* Make an edge coming from the 'cond block' into the 'then block';\n      this edge is unlikely taken, so set up the probability accordingly.  */\n   e = make_edge (cond_bb, then_bb, EDGE_TRUE_VALUE);\n-  e->probability = PROB_VERY_UNLIKELY;\n+  e->probability = profile_probability::very_unlikely ();\n \n   /* Connect 'then block' with the 'else block'.  This is needed\n      as the ubsan routines we call in the 'then block' are not noreturn.\n@@ -810,7 +810,7 @@ ubsan_expand_null_ifn (gimple_stmt_iterator *gsip)\n   e = find_edge (cond_bb, fallthru_bb);\n   e->flags = EDGE_FALSE_VALUE;\n   e->count = cond_bb->count;\n-  e->probability = REG_BR_PROB_BASE - PROB_VERY_UNLIKELY;\n+  e->probability = profile_probability::very_likely ();\n \n   /* Update dominance info for the newly created then_bb; note that\n      fallthru_bb's dominance info has already been updated by\n@@ -873,13 +873,13 @@ ubsan_expand_null_ifn (gimple_stmt_iterator *gsip)\n \t     this edge is unlikely taken, so set up the probability\n \t     accordingly.  */\n \t  e = make_edge (cond1_bb, then_bb, EDGE_TRUE_VALUE);\n-\t  e->probability = PROB_VERY_UNLIKELY;\n+\t  e->probability = profile_probability::very_unlikely ();\n \n \t  /* Set up the fallthrough basic block.  */\n \t  e = find_edge (cond1_bb, cond2_bb);\n \t  e->flags = EDGE_FALSE_VALUE;\n \t  e->count = cond1_bb->count;\n-\t  e->probability = REG_BR_PROB_BASE - PROB_VERY_UNLIKELY;\n+\t  e->probability = profile_probability::very_likely ();\n \n \t  /* Update dominance info.  */\n \t  if (dom_info_available_p (CDI_DOMINATORS))"}, {"sha": "23b8dc26471c6c38c270a9d1777b6eea8d6db80e", "filename": "gcc/value-prof.c", "status": "modified", "additions": 37, "deletions": 39, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -104,11 +104,6 @@ along with GCC; see the file COPYING3.  If not see\n      and gimple_value_profile_transformations table-driven, perhaps...\n */\n \n-static tree gimple_divmod_fixed_value (gassign *, tree, int, gcov_type,\n-\t\t\t\t       gcov_type);\n-static tree gimple_mod_pow2 (gassign *, int, gcov_type, gcov_type);\n-static tree gimple_mod_subtract (gassign *, int, int, int, gcov_type,\n-\t\t\t\t gcov_type, gcov_type);\n static bool gimple_divmod_fixed_value_transform (gimple_stmt_iterator *);\n static bool gimple_mod_pow2_value_transform (gimple_stmt_iterator *);\n static bool gimple_mod_subtract_transform (gimple_stmt_iterator *);\n@@ -693,7 +688,7 @@ gimple_value_profile_transformations (void)\n    alter the original STMT.  */\n \n static tree\n-gimple_divmod_fixed_value (gassign *stmt, tree value, int prob,\n+gimple_divmod_fixed_value (gassign *stmt, tree value, profile_probability prob,\n \t\t\t   gcov_type count, gcov_type all)\n {\n   gassign *stmt1, *stmt2;\n@@ -753,16 +748,16 @@ gimple_divmod_fixed_value (gassign *stmt, tree value, int prob,\n   e12->count = profile_count::from_gcov_type (count);\n \n   e13 = make_edge (bb, bb3, EDGE_TRUE_VALUE);\n-  e13->probability = REG_BR_PROB_BASE - prob;\n+  e13->probability = prob.invert ();\n   e13->count = profile_count::from_gcov_type (all - count);\n \n   remove_edge (e23);\n \n   e24 = make_edge (bb2, bb4, EDGE_FALLTHRU);\n-  e24->probability = REG_BR_PROB_BASE;\n+  e24->probability = profile_probability::always ();\n   e24->count = profile_count::from_gcov_type (count);\n \n-  e34->probability = REG_BR_PROB_BASE;\n+  e34->probability = profile_probability::always ();\n   e34->count = profile_count::from_gcov_type (all - count);\n \n   return tmp2;\n@@ -777,7 +772,7 @@ gimple_divmod_fixed_value_transform (gimple_stmt_iterator *si)\n   enum tree_code code;\n   gcov_type val, count, all;\n   tree result, value, tree_val;\n-  gcov_type prob;\n+  profile_probability prob;\n   gassign *stmt;\n \n   stmt = dyn_cast <gassign *> (gsi_stmt (*si));\n@@ -816,9 +811,9 @@ gimple_divmod_fixed_value_transform (gimple_stmt_iterator *si)\n \n   /* Compute probability of taking the optimal path.  */\n   if (all > 0)\n-    prob = GCOV_COMPUTE_SCALE (count, all);\n+    prob = profile_probability::probability_in_gcov_type (count, all);\n   else\n-    prob = 0;\n+    prob = profile_probability::never ();\n \n   if (sizeof (gcov_type) == sizeof (HOST_WIDE_INT))\n     tree_val = build_int_cst (get_gcov_type (), val);\n@@ -855,7 +850,7 @@ gimple_divmod_fixed_value_transform (gimple_stmt_iterator *si)\n    the temp; it does not replace or alter the original STMT.  */\n \n static tree\n-gimple_mod_pow2 (gassign *stmt, int prob, gcov_type count, gcov_type all)\n+gimple_mod_pow2 (gassign *stmt, profile_probability prob, gcov_type count, gcov_type all)\n {\n   gassign *stmt1, *stmt2, *stmt3;\n   gcond *stmt4;\n@@ -918,16 +913,16 @@ gimple_mod_pow2 (gassign *stmt, int prob, gcov_type count, gcov_type all)\n   e12->count = profile_count::from_gcov_type (count);\n \n   e13 = make_edge (bb, bb3, EDGE_TRUE_VALUE);\n-  e13->probability = REG_BR_PROB_BASE - prob;\n+  e13->probability = prob.invert ();\n   e13->count = profile_count::from_gcov_type (all - count);\n \n   remove_edge (e23);\n \n   e24 = make_edge (bb2, bb4, EDGE_FALLTHRU);\n-  e24->probability = REG_BR_PROB_BASE;\n+  e24->probability = profile_probability::always ();\n   e24->count = profile_count::from_gcov_type (count);\n \n-  e34->probability = REG_BR_PROB_BASE;\n+  e34->probability = profile_probability::always ();\n   e34->count = profile_count::from_gcov_type (all - count);\n \n   return result;\n@@ -942,7 +937,7 @@ gimple_mod_pow2_value_transform (gimple_stmt_iterator *si)\n   enum tree_code code;\n   gcov_type count, wrong_values, all;\n   tree lhs_type, result, value;\n-  gcov_type prob;\n+  profile_probability prob;\n   gassign *stmt;\n \n   stmt = dyn_cast <gassign *> (gsi_stmt (*si));\n@@ -987,9 +982,9 @@ gimple_mod_pow2_value_transform (gimple_stmt_iterator *si)\n     return false;\n \n   if (all > 0)\n-    prob = GCOV_COMPUTE_SCALE (count, all);\n+    prob = profile_probability::probability_in_gcov_type (count, all);\n   else\n-    prob = 0;\n+    prob = profile_probability::never ();\n \n   result = gimple_mod_pow2 (stmt, prob, count, all);\n \n@@ -1009,7 +1004,8 @@ gimple_mod_pow2_value_transform (gimple_stmt_iterator *si)\n /* FIXME: Generalize the interface to handle NCOUNTS > 1.  */\n \n static tree\n-gimple_mod_subtract (gassign *stmt, int prob1, int prob2, int ncounts,\n+gimple_mod_subtract (gassign *stmt, profile_probability prob1,\n+\t\t     profile_probability prob2, int ncounts,\n \t\t     gcov_type count1, gcov_type count2, gcov_type all)\n {\n   gassign *stmt1;\n@@ -1079,7 +1075,7 @@ gimple_mod_subtract (gassign *stmt, int prob1, int prob2, int ncounts,\n \n   e12->flags &= ~EDGE_FALLTHRU;\n   e12->flags |= EDGE_FALSE_VALUE;\n-  e12->probability = REG_BR_PROB_BASE - prob1;\n+  e12->probability = prob1.invert ();\n   e12->count = profile_count::from_gcov_type (all - count1);\n \n   e14 = make_edge (bb, bb4, EDGE_TRUE_VALUE);\n@@ -1091,14 +1087,14 @@ gimple_mod_subtract (gassign *stmt, int prob1, int prob2, int ncounts,\n       e23->flags &= ~EDGE_FALLTHRU;\n       e23->flags |= EDGE_FALSE_VALUE;\n       e23->count = profile_count::from_gcov_type (all - count1 - count2);\n-      e23->probability = REG_BR_PROB_BASE - prob2;\n+      e23->probability = prob2.invert ();\n \n       e24 = make_edge (bb2, bb4, EDGE_TRUE_VALUE);\n       e24->probability = prob2;\n       e24->count = profile_count::from_gcov_type (count2);\n     }\n \n-  e34->probability = REG_BR_PROB_BASE;\n+  e34->probability = profile_probability::always ();\n   e34->count = profile_count::from_gcov_type (all - count1 - count2);\n \n   return result;\n@@ -1113,7 +1109,7 @@ gimple_mod_subtract_transform (gimple_stmt_iterator *si)\n   enum tree_code code;\n   gcov_type count, wrong_values, all;\n   tree lhs_type, result;\n-  gcov_type prob1, prob2;\n+  profile_probability prob1, prob2;\n   unsigned int i, steps;\n   gcov_type count1, count2;\n   gassign *stmt;\n@@ -1181,12 +1177,12 @@ gimple_mod_subtract_transform (gimple_stmt_iterator *si)\n   /* Compute probability of taking the optimal path(s).  */\n   if (all > 0)\n     {\n-      prob1 = GCOV_COMPUTE_SCALE (count1, all);\n-      prob2 = GCOV_COMPUTE_SCALE (count2, all);\n+      prob1 = profile_probability::probability_in_gcov_type (count1, all);\n+      prob2 = profile_probability::probability_in_gcov_type (count2, all);\n     }\n   else\n     {\n-      prob1 = prob2 = 0;\n+      prob1 = prob2 = profile_probability::never ();\n     }\n \n   /* In practice, \"steps\" is always 2.  This interface reflects this,\n@@ -1316,7 +1312,7 @@ check_ic_target (gcall *call_stmt, struct cgraph_node *target)\n \n gcall *\n gimple_ic (gcall *icall_stmt, struct cgraph_node *direct_call,\n-\t   int prob, profile_count count, profile_count all)\n+\t   profile_probability prob, profile_count count, profile_count all)\n {\n   gcall *dcall_stmt;\n   gassign *load_stmt;\n@@ -1386,7 +1382,7 @@ gimple_ic (gcall *icall_stmt, struct cgraph_node *direct_call,\n       /* The indirect call might be noreturn.  */\n       if (e_ij != NULL)\n \t{\n-\t  e_ij->probability = REG_BR_PROB_BASE;\n+\t  e_ij->probability = profile_probability::always ();\n \t  e_ij->count = all - count;\n \t  e_ij = single_pred_edge (split_edge (e_ij));\n \t}\n@@ -1402,7 +1398,7 @@ gimple_ic (gcall *icall_stmt, struct cgraph_node *direct_call,\n   e_cd->count = count;\n \n   e_ci = make_edge (cond_bb, icall_bb, EDGE_FALSE_VALUE);\n-  e_ci->probability = REG_BR_PROB_BASE - prob;\n+  e_ci->probability = prob.invert ();\n   e_ci->count = all - count;\n \n   remove_edge (e_di);\n@@ -1414,12 +1410,12 @@ gimple_ic (gcall *icall_stmt, struct cgraph_node *direct_call,\n       else\n \t{\n \t  e_dj = make_edge (dcall_bb, join_bb, EDGE_FALLTHRU);\n-\t  e_dj->probability = REG_BR_PROB_BASE;\n+\t  e_dj->probability = profile_probability::always ();\n \t  e_dj->count = count;\n \n \t  e_ij->count = all - count;\n \t}\n-      e_ij->probability = REG_BR_PROB_BASE;\n+      e_ij->probability = profile_probability::always ();\n     }\n \n   /* Insert PHI node for the call result if necessary.  */\n@@ -1497,6 +1493,8 @@ gimple_ic (gcall *icall_stmt, struct cgraph_node *direct_call,\n     if (e_eh->flags & (EDGE_EH | EDGE_ABNORMAL))\n       {\n \te = make_edge (dcall_bb, e_eh->dest, e_eh->flags);\n+\te->probability = e_eh->probability;\n+\te->count = e_eh->count;\n \tfor (gphi_iterator psi = gsi_start_phis (e_eh->dest);\n \t     !gsi_end_p (psi); gsi_next (&psi))\n \t  {\n@@ -1645,7 +1643,7 @@ interesting_stringop_to_profile_p (gcall *call, int *size_arg)\n    assuming we'll propagate a true constant into ICALL_SIZE later.  */\n \n static void\n-gimple_stringop_fixed_value (gcall *vcall_stmt, tree icall_size, int prob,\n+gimple_stringop_fixed_value (gcall *vcall_stmt, tree icall_size, profile_probability prob,\n \t\t\t     gcov_type count, gcov_type all)\n {\n   gassign *tmp_stmt;\n@@ -1709,16 +1707,16 @@ gimple_stringop_fixed_value (gcall *vcall_stmt, tree icall_size, int prob,\n   e_ci->count = profile_count::from_gcov_type (count);\n \n   e_cv = make_edge (cond_bb, vcall_bb, EDGE_FALSE_VALUE);\n-  e_cv->probability = REG_BR_PROB_BASE - prob;\n+  e_cv->probability = prob.invert ();\n   e_cv->count = profile_count::from_gcov_type (all - count);\n \n   remove_edge (e_iv);\n \n   e_ij = make_edge (icall_bb, join_bb, EDGE_FALLTHRU);\n-  e_ij->probability = REG_BR_PROB_BASE;\n+  e_ij->probability = profile_probability::always ();\n   e_ij->count = profile_count::from_gcov_type (count);\n \n-  e_vj->probability = REG_BR_PROB_BASE;\n+  e_vj->probability = profile_probability::always ();\n   e_vj->count = profile_count::from_gcov_type (all - count);\n \n   /* Insert PHI node for the call result if necessary.  */\n@@ -1753,7 +1751,7 @@ gimple_stringops_transform (gimple_stmt_iterator *gsi)\n   gcov_type count, all, val;\n   tree dest, src;\n   unsigned int dest_align, src_align;\n-  gcov_type prob;\n+  profile_probability prob;\n   tree tree_val;\n   int size_arg;\n \n@@ -1788,9 +1786,9 @@ gimple_stringops_transform (gimple_stmt_iterator *gsi)\n   if (check_counter (stmt, \"value\", &count, &all, gimple_bb (stmt)->count))\n     return false;\n   if (all > 0)\n-    prob = GCOV_COMPUTE_SCALE (count, all);\n+    prob = profile_probability::probability_in_gcov_type (count, all);\n   else\n-    prob = 0;\n+    prob = profile_probability::never ();\n \n   dest = gimple_call_arg (stmt, 0);\n   dest_align = get_pointer_alignment (dest);"}, {"sha": "f72bb2d2241539edb126577a79f00729014aebaf", "filename": "gcc/value-prof.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fvalue-prof.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357067f243611b9e29367b61a50efe2e78f693c9/gcc%2Fvalue-prof.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.h?ref=357067f243611b9e29367b61a50efe2e78f693c9", "patch": "@@ -90,8 +90,8 @@ void gimple_move_stmt_histograms (struct function *, gimple *, gimple *);\n void verify_histograms (void);\n void free_histograms (function *);\n void stringop_block_profile (gimple *, unsigned int *, HOST_WIDE_INT *);\n-gcall *gimple_ic (gcall *, struct cgraph_node *, int, profile_count,\n-\t\t  profile_count);\n+gcall *gimple_ic (gcall *, struct cgraph_node *, profile_probability,\n+\t\t  profile_count, profile_count);\n bool check_ic_target (gcall *, struct cgraph_node *);\n \n "}]}