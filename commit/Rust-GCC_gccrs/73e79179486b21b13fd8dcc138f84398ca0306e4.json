{"sha": "73e79179486b21b13fd8dcc138f84398ca0306e4", "node_id": "C_kwDOANBUbNoAKDczZTc5MTc5NDg2YjIxYjEzZmQ4ZGNjMTM4Zjg0Mzk4Y2EwMzA2ZTQ", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-17T11:12:36Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-17T12:01:13Z"}, "message": "Refactor backend to use finegrained visitors\n\nThis also moves more code out of the headers to their associated impl files\nto improve compilation times and code navigation.", "tree": {"sha": "32a8727145460104e05c00f65b0c06f262c6179c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/32a8727145460104e05c00f65b0c06f262c6179c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/73e79179486b21b13fd8dcc138f84398ca0306e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73e79179486b21b13fd8dcc138f84398ca0306e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73e79179486b21b13fd8dcc138f84398ca0306e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73e79179486b21b13fd8dcc138f84398ca0306e4/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f039ff9f6f18d15e32ddb54e3a6124802c45b7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f039ff9f6f18d15e32ddb54e3a6124802c45b7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f039ff9f6f18d15e32ddb54e3a6124802c45b7f"}], "stats": {"total": 2394, "additions": 1222, "deletions": 1172}, "files": [{"sha": "49be3a1b47380b269716ba7551892dcc3575ea49", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73e79179486b21b13fd8dcc138f84398ca0306e4/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73e79179486b21b13fd8dcc138f84398ca0306e4/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=73e79179486b21b13fd8dcc138f84398ca0306e4", "patch": "@@ -137,8 +137,11 @@ GRS_OBJS = \\\n     rust/rust-optional-test.o \\\n     rust/rust-compile-item.o \\\n     rust/rust-compile-implitem.o \\\n+    rust/rust-compile-stmt.o \\\n     rust/rust-compile-expr.o \\\n     rust/rust-compile-type.o \\\n+    rust/rust-compile-block.o \\\n+    rust/rust-compile-struct-field-expr.o \\\n     rust/rust-constexpr.o \\\n     rust/rust-compile-base.o \\\n     rust/rust-tree.o \\"}, {"sha": "2b5c850872f2bf98c646c47cfc9451c86dbe2ec5", "filename": "gcc/rust/backend/rust-compile-base.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73e79179486b21b13fd8dcc138f84398ca0306e4/gcc%2Frust%2Fbackend%2Frust-compile-base.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73e79179486b21b13fd8dcc138f84398ca0306e4/gcc%2Frust%2Fbackend%2Frust-compile-base.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.cc?ref=73e79179486b21b13fd8dcc138f84398ca0306e4", "patch": "@@ -20,9 +20,10 @@\n #include \"rust-abi.h\"\n #include \"rust-compile-item.h\"\n #include \"rust-compile-stmt.h\"\n+#include \"rust-compile-expr.h\"\n #include \"rust-compile-fnparam.h\"\n #include \"rust-compile-var-decl.h\"\n-\n+#include \"rust-constexpr.h\"\n #include \"rust-diagnostics.h\"\n #include \"rust-expr.h\"\t// for AST::AttrInputLiteral\n #include \"rust-macro.h\" // for AST::MetaNameValueStr"}, {"sha": "99674e2d1e7691ee967c702afab9bbb69dbceff3", "filename": "gcc/rust/backend/rust-compile-block.cc", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73e79179486b21b13fd8dcc138f84398ca0306e4/gcc%2Frust%2Fbackend%2Frust-compile-block.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73e79179486b21b13fd8dcc138f84398ca0306e4/gcc%2Frust%2Fbackend%2Frust-compile-block.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-block.cc?ref=73e79179486b21b13fd8dcc138f84398ca0306e4", "patch": "@@ -0,0 +1,158 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-compile-block.h\"\n+#include \"rust-compile-stmt.h\"\n+#include \"rust-compile-expr.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+CompileBlock::CompileBlock (Context *ctx, Bvariable *result)\n+  : HIRCompileBase (ctx), translated (nullptr), result (result)\n+{}\n+\n+tree\n+CompileBlock::compile (HIR::BlockExpr *expr, Context *ctx, Bvariable *result)\n+{\n+  CompileBlock compiler (ctx, result);\n+  compiler.visit (*expr);\n+  return compiler.translated;\n+}\n+\n+void\n+CompileBlock::visit (HIR::BlockExpr &expr)\n+{\n+  fncontext fnctx = ctx->peek_fn ();\n+  tree fndecl = fnctx.fndecl;\n+  Location start_location = expr.get_locus ();\n+  Location end_location = expr.get_end_locus ();\n+  auto body_mappings = expr.get_mappings ();\n+\n+  Resolver::Rib *rib = nullptr;\n+  if (!ctx->get_resolver ()->find_name_rib (body_mappings.get_nodeid (), &rib))\n+    {\n+      rust_fatal_error (expr.get_locus (), \"failed to setup locals per block\");\n+      return;\n+    }\n+\n+  std::vector<Bvariable *> locals\n+    = compile_locals_for_block (ctx, *rib, fndecl);\n+\n+  tree enclosing_scope = ctx->peek_enclosing_scope ();\n+  tree new_block = ctx->get_backend ()->block (fndecl, enclosing_scope, locals,\n+\t\t\t\t\t       start_location, end_location);\n+  ctx->push_block (new_block);\n+\n+  for (auto &s : expr.get_statements ())\n+    {\n+      auto compiled_expr = CompileStmt::Compile (s.get (), ctx);\n+      if (compiled_expr != nullptr)\n+\t{\n+\t  tree s = convert_to_void (compiled_expr, ICV_STATEMENT);\n+\t  ctx->add_statement (s);\n+\t}\n+    }\n+\n+  if (expr.has_expr ())\n+    {\n+      // the previous passes will ensure this is a valid return or\n+      // a valid trailing expression\n+      tree compiled_expr = CompileExpr::Compile (expr.expr.get (), ctx);\n+      if (compiled_expr != nullptr)\n+\t{\n+\t  if (result == nullptr)\n+\t    {\n+\t      ctx->add_statement (compiled_expr);\n+\t    }\n+\t  else\n+\t    {\n+\t      tree result_reference = ctx->get_backend ()->var_expression (\n+\t\tresult, expr.get_final_expr ()->get_locus ());\n+\n+\t      tree assignment\n+\t\t= ctx->get_backend ()->assignment_statement (result_reference,\n+\t\t\t\t\t\t\t     compiled_expr,\n+\t\t\t\t\t\t\t     expr.get_locus ());\n+\t      ctx->add_statement (assignment);\n+\t    }\n+\t}\n+    }\n+\n+  ctx->pop_block ();\n+  translated = new_block;\n+}\n+\n+void\n+CompileConditionalBlocks::visit (HIR::IfExpr &expr)\n+{\n+  fncontext fnctx = ctx->peek_fn ();\n+  tree fndecl = fnctx.fndecl;\n+  tree condition_expr = CompileExpr::Compile (expr.get_if_condition (), ctx);\n+  tree then_block = CompileBlock::compile (expr.get_if_block (), ctx, result);\n+\n+  translated\n+    = ctx->get_backend ()->if_statement (fndecl, condition_expr, then_block,\n+\t\t\t\t\t NULL, expr.get_locus ());\n+}\n+\n+void\n+CompileConditionalBlocks::visit (HIR::IfExprConseqElse &expr)\n+{\n+  fncontext fnctx = ctx->peek_fn ();\n+  tree fndecl = fnctx.fndecl;\n+  tree condition_expr = CompileExpr::Compile (expr.get_if_condition (), ctx);\n+  tree then_block = CompileBlock::compile (expr.get_if_block (), ctx, result);\n+  tree else_block = CompileBlock::compile (expr.get_else_block (), ctx, result);\n+\n+  translated\n+    = ctx->get_backend ()->if_statement (fndecl, condition_expr, then_block,\n+\t\t\t\t\t else_block, expr.get_locus ());\n+}\n+\n+void\n+CompileConditionalBlocks::visit (HIR::IfExprConseqIf &expr)\n+{\n+  fncontext fnctx = ctx->peek_fn ();\n+  tree fndecl = fnctx.fndecl;\n+  tree condition_expr = CompileExpr::Compile (expr.get_if_condition (), ctx);\n+  tree then_block = CompileBlock::compile (expr.get_if_block (), ctx, result);\n+\n+  // else block\n+  std::vector<Bvariable *> locals;\n+  Location start_location = expr.get_conseq_if_expr ()->get_locus ();\n+  Location end_location = expr.get_conseq_if_expr ()->get_locus (); // FIXME\n+  tree enclosing_scope = ctx->peek_enclosing_scope ();\n+  tree else_block = ctx->get_backend ()->block (fndecl, enclosing_scope, locals,\n+\t\t\t\t\t\tstart_location, end_location);\n+  ctx->push_block (else_block);\n+\n+  tree else_stmt_decl\n+    = CompileConditionalBlocks::compile (expr.get_conseq_if_expr (), ctx,\n+\t\t\t\t\t result);\n+  ctx->add_statement (else_stmt_decl);\n+\n+  ctx->pop_block ();\n+\n+  translated\n+    = ctx->get_backend ()->if_statement (fndecl, condition_expr, then_block,\n+\t\t\t\t\t else_block, expr.get_locus ());\n+}\n+\n+} // namespace Compile\n+} // namespace Rust"}, {"sha": "cdd17f19ca2089a90f222da665a16ce1baa5e8aa", "filename": "gcc/rust/backend/rust-compile-block.h", "status": "modified", "additions": 5, "deletions": 66, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73e79179486b21b13fd8dcc138f84398ca0306e4/gcc%2Frust%2Fbackend%2Frust-compile-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73e79179486b21b13fd8dcc138f84398ca0306e4/gcc%2Frust%2Fbackend%2Frust-compile-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-block.h?ref=73e79179486b21b13fd8dcc138f84398ca0306e4", "patch": "@@ -24,77 +24,16 @@\n namespace Rust {\n namespace Compile {\n \n-class CompileBlock : public HIRCompileBase, public HIR::HIRExpressionVisitor\n+class CompileBlock : private HIRCompileBase\n {\n public:\n-  static tree compile (HIR::BlockExpr *expr, Context *ctx, Bvariable *result)\n-  {\n-    CompileBlock compiler (ctx, result);\n-    expr->accept_vis (compiler);\n-    return compiler.translated;\n-  }\n+  static tree compile (HIR::BlockExpr *expr, Context *ctx, Bvariable *result);\n \n-  void visit (HIR::BlockExpr &expr) override;\n-\n-  // Empty visit for unused Expression HIR nodes.\n-  void visit (HIR::PathInExpression &) override {}\n-  void visit (HIR::QualifiedPathInExpression &) override {}\n-  void visit (HIR::ClosureExprInner &) override {}\n-  void visit (HIR::ClosureExprInnerTyped &) override {}\n-  void visit (HIR::StructExprFieldIdentifier &) override {}\n-  void visit (HIR::StructExprFieldIdentifierValue &) override {}\n-  void visit (HIR::StructExprFieldIndexValue &) override {}\n-  void visit (HIR::StructExprStruct &) override {}\n-  void visit (HIR::StructExprStructFields &) override {}\n-  void visit (HIR::LiteralExpr &) override {}\n-  void visit (HIR::BorrowExpr &) override {}\n-  void visit (HIR::DereferenceExpr &) override {}\n-  void visit (HIR::ErrorPropagationExpr &) override {}\n-  void visit (HIR::NegationExpr &) override {}\n-  void visit (HIR::ArithmeticOrLogicalExpr &) override {}\n-  void visit (HIR::ComparisonExpr &) override {}\n-  void visit (HIR::LazyBooleanExpr &) override {}\n-  void visit (HIR::TypeCastExpr &) override {}\n-  void visit (HIR::AssignmentExpr &) override {}\n-  void visit (HIR::CompoundAssignmentExpr &) override {}\n-  void visit (HIR::GroupedExpr &) override {}\n-  void visit (HIR::ArrayExpr &) override {}\n-  void visit (HIR::ArrayIndexExpr &) override {}\n-  void visit (HIR::TupleExpr &) override {}\n-  void visit (HIR::TupleIndexExpr &) override {}\n-  void visit (HIR::CallExpr &) override {}\n-  void visit (HIR::MethodCallExpr &) override {}\n-  void visit (HIR::FieldAccessExpr &) override {}\n-  void visit (HIR::ContinueExpr &) override {}\n-  void visit (HIR::BreakExpr &) override {}\n-  void visit (HIR::RangeFromToExpr &) override {}\n-  void visit (HIR::RangeFromExpr &) override {}\n-  void visit (HIR::RangeToExpr &) override {}\n-  void visit (HIR::RangeFullExpr &) override {}\n-  void visit (HIR::RangeFromToInclExpr &) override {}\n-  void visit (HIR::RangeToInclExpr &) override {}\n-  void visit (HIR::ReturnExpr &) override {}\n-  void visit (HIR::UnsafeBlockExpr &) override {}\n-  void visit (HIR::LoopExpr &) override {}\n-  void visit (HIR::WhileLoopExpr &) override {}\n-  void visit (HIR::WhileLetLoopExpr &) override {}\n-  void visit (HIR::ForLoopExpr &) override {}\n-  void visit (HIR::IfExpr &) override {}\n-  void visit (HIR::IfExprConseqElse &) override {}\n-  void visit (HIR::IfExprConseqIf &) override {}\n-  void visit (HIR::IfExprConseqIfLet &) override {}\n-  void visit (HIR::IfLetExpr &) override {}\n-  void visit (HIR::IfLetExprConseqElse &) override {}\n-  void visit (HIR::IfLetExprConseqIf &) override {}\n-  void visit (HIR::IfLetExprConseqIfLet &) override {}\n-  void visit (HIR::MatchExpr &) override {}\n-  void visit (HIR::AwaitExpr &) override {}\n-  void visit (HIR::AsyncBlockExpr &) override {}\n+protected:\n+  void visit (HIR::BlockExpr &expr);\n \n private:\n-  CompileBlock (Context *ctx, Bvariable *result)\n-    : HIRCompileBase (ctx), translated (nullptr), result (result)\n-  {}\n+  CompileBlock (Context *ctx, Bvariable *result);\n \n   tree translated;\n   Bvariable *result;"}, {"sha": "9a8b779f12dafad1cadd70042876f54d1bcad296", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 743, "deletions": 3, "changes": 746, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73e79179486b21b13fd8dcc138f84398ca0306e4/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73e79179486b21b13fd8dcc138f84398ca0306e4/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=73e79179486b21b13fd8dcc138f84398ca0306e4", "patch": "@@ -16,15 +16,15 @@\n // along with GCC; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-#include \"rust-compile.h\"\n-#include \"rust-compile-item.h\"\n-#include \"rust-compile-implitem.h\"\n #include \"rust-compile-expr.h\"\n #include \"rust-compile-struct-field-expr.h\"\n #include \"rust-hir-trait-resolve.h\"\n #include \"rust-hir-path-probe.h\"\n #include \"rust-hir-type-bounds.h\"\n #include \"rust-compile-pattern.h\"\n+#include \"rust-compile-resolve-path.h\"\n+#include \"rust-compile-block.h\"\n+#include \"rust-compile-implitem.h\"\n #include \"rust-constexpr.h\"\n \n #include \"fold-const.h\"\n@@ -35,6 +35,97 @@\n namespace Rust {\n namespace Compile {\n \n+CompileExpr::CompileExpr (Context *ctx)\n+  : HIRCompileBase (ctx), translated (error_mark_node)\n+{}\n+\n+tree\n+CompileExpr::Compile (HIR::Expr *expr, Context *ctx)\n+{\n+  CompileExpr compiler (ctx);\n+  expr->accept_vis (compiler);\n+  return compiler.translated;\n+}\n+\n+void\n+CompileExpr::visit (HIR::TupleIndexExpr &expr)\n+{\n+  HIR::Expr *tuple_expr = expr.get_tuple_expr ().get ();\n+  TupleIndex index = expr.get_tuple_index ();\n+\n+  tree receiver_ref = CompileExpr::Compile (tuple_expr, ctx);\n+\n+  TyTy::BaseType *tuple_expr_ty = nullptr;\n+  bool ok\n+    = ctx->get_tyctx ()->lookup_type (tuple_expr->get_mappings ().get_hirid (),\n+\t\t\t\t      &tuple_expr_ty);\n+  rust_assert (ok);\n+\n+  // do we need to add an indirect reference\n+  if (tuple_expr_ty->get_kind () == TyTy::TypeKind::REF)\n+    {\n+      tree indirect = indirect_expression (receiver_ref, expr.get_locus ());\n+      receiver_ref = indirect;\n+    }\n+\n+  translated\n+    = ctx->get_backend ()->struct_field_expression (receiver_ref, index,\n+\t\t\t\t\t\t    expr.get_locus ());\n+}\n+\n+void\n+CompileExpr::visit (HIR::TupleExpr &expr)\n+{\n+  if (expr.is_unit ())\n+    {\n+      translated = ctx->get_backend ()->unit_expression ();\n+      return;\n+    }\n+\n+  TyTy::BaseType *tyty = nullptr;\n+  if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n+\t\t\t\t       &tyty))\n+    {\n+      rust_fatal_error (expr.get_locus (),\n+\t\t\t\"did not resolve type for this TupleExpr\");\n+      return;\n+    }\n+\n+  tree tuple_type = TyTyResolveCompile::compile (ctx, tyty);\n+  rust_assert (tuple_type != nullptr);\n+\n+  // this assumes all fields are in order from type resolution\n+  std::vector<tree> vals;\n+  for (auto &elem : expr.get_tuple_elems ())\n+    {\n+      auto e = CompileExpr::Compile (elem.get (), ctx);\n+      vals.push_back (e);\n+    }\n+\n+  translated\n+    = ctx->get_backend ()->constructor_expression (tuple_type, false, vals, -1,\n+\t\t\t\t\t\t   expr.get_locus ());\n+}\n+\n+void\n+CompileExpr::visit (HIR::ReturnExpr &expr)\n+{\n+  auto fncontext = ctx->peek_fn ();\n+\n+  std::vector<tree> retstmts;\n+  if (expr.has_return_expr ())\n+    {\n+      tree compiled_expr = CompileExpr::Compile (expr.return_expr.get (), ctx);\n+      rust_assert (compiled_expr != nullptr);\n+\n+      retstmts.push_back (compiled_expr);\n+    }\n+\n+  auto s = ctx->get_backend ()->return_statement (fncontext.fndecl, retstmts,\n+\t\t\t\t\t\t  expr.get_locus ());\n+  ctx->add_statement (s);\n+}\n+\n void\n CompileExpr::visit (HIR::ArithmeticOrLogicalExpr &expr)\n {\n@@ -119,6 +210,585 @@ CompileExpr::visit (HIR::NegationExpr &expr)\n     = ctx->get_backend ()->negation_expression (op, negated_expr, location);\n }\n \n+void\n+CompileExpr::visit (HIR::ComparisonExpr &expr)\n+{\n+  auto op = expr.get_expr_type ();\n+  auto lhs = CompileExpr::Compile (expr.get_lhs (), ctx);\n+  auto rhs = CompileExpr::Compile (expr.get_rhs (), ctx);\n+  auto location = expr.get_locus ();\n+\n+  translated\n+    = ctx->get_backend ()->comparison_expression (op, lhs, rhs, location);\n+}\n+\n+void\n+CompileExpr::visit (HIR::LazyBooleanExpr &expr)\n+{\n+  auto op = expr.get_expr_type ();\n+  auto lhs = CompileExpr::Compile (expr.get_lhs (), ctx);\n+  auto rhs = CompileExpr::Compile (expr.get_rhs (), ctx);\n+  auto location = expr.get_locus ();\n+\n+  translated\n+    = ctx->get_backend ()->lazy_boolean_expression (op, lhs, rhs, location);\n+}\n+\n+void\n+CompileExpr::visit (HIR::TypeCastExpr &expr)\n+{\n+  TyTy::BaseType *tyty = nullptr;\n+  if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n+\t\t\t\t       &tyty))\n+    {\n+      translated = error_mark_node;\n+      return;\n+    }\n+\n+  auto type_to_cast_to = TyTyResolveCompile::compile (ctx, tyty);\n+  auto casted_expr = CompileExpr::Compile (expr.get_casted_expr ().get (), ctx);\n+  translated\n+    = type_cast_expression (type_to_cast_to, casted_expr, expr.get_locus ());\n+}\n+\n+void\n+CompileExpr::visit (HIR::IfExpr &expr)\n+{\n+  auto stmt = CompileConditionalBlocks::compile (&expr, ctx, nullptr);\n+  ctx->add_statement (stmt);\n+}\n+\n+void\n+CompileExpr::visit (HIR::IfExprConseqElse &expr)\n+{\n+  TyTy::BaseType *if_type = nullptr;\n+  if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n+\t\t\t\t       &if_type))\n+    {\n+      rust_error_at (expr.get_locus (),\n+\t\t     \"failed to lookup type of IfExprConseqElse\");\n+      return;\n+    }\n+\n+  Bvariable *tmp = NULL;\n+  bool needs_temp = !if_type->is_unit ();\n+  if (needs_temp)\n+    {\n+      fncontext fnctx = ctx->peek_fn ();\n+      tree enclosing_scope = ctx->peek_enclosing_scope ();\n+      tree block_type = TyTyResolveCompile::compile (ctx, if_type);\n+\n+      bool is_address_taken = false;\n+      tree ret_var_stmt = nullptr;\n+      tmp = ctx->get_backend ()->temporary_variable (\n+\tfnctx.fndecl, enclosing_scope, block_type, NULL, is_address_taken,\n+\texpr.get_locus (), &ret_var_stmt);\n+      ctx->add_statement (ret_var_stmt);\n+    }\n+\n+  auto stmt = CompileConditionalBlocks::compile (&expr, ctx, tmp);\n+  ctx->add_statement (stmt);\n+\n+  if (tmp != NULL)\n+    {\n+      translated = ctx->get_backend ()->var_expression (tmp, expr.get_locus ());\n+    }\n+}\n+\n+void\n+CompileExpr::visit (HIR::IfExprConseqIf &expr)\n+{\n+  TyTy::BaseType *if_type = nullptr;\n+  if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n+\t\t\t\t       &if_type))\n+    {\n+      rust_error_at (expr.get_locus (),\n+\t\t     \"failed to lookup type of IfExprConseqElse\");\n+      return;\n+    }\n+\n+  Bvariable *tmp = NULL;\n+  bool needs_temp = !if_type->is_unit ();\n+  if (needs_temp)\n+    {\n+      fncontext fnctx = ctx->peek_fn ();\n+      tree enclosing_scope = ctx->peek_enclosing_scope ();\n+      tree block_type = TyTyResolveCompile::compile (ctx, if_type);\n+\n+      bool is_address_taken = false;\n+      tree ret_var_stmt = nullptr;\n+      tmp = ctx->get_backend ()->temporary_variable (\n+\tfnctx.fndecl, enclosing_scope, block_type, NULL, is_address_taken,\n+\texpr.get_locus (), &ret_var_stmt);\n+      ctx->add_statement (ret_var_stmt);\n+    }\n+\n+  auto stmt = CompileConditionalBlocks::compile (&expr, ctx, tmp);\n+  ctx->add_statement (stmt);\n+\n+  if (tmp != NULL)\n+    {\n+      translated = ctx->get_backend ()->var_expression (tmp, expr.get_locus ());\n+    }\n+}\n+\n+void\n+CompileExpr::visit (HIR::BlockExpr &expr)\n+{\n+  TyTy::BaseType *block_tyty = nullptr;\n+  if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n+\t\t\t\t       &block_tyty))\n+    {\n+      rust_error_at (expr.get_locus (), \"failed to lookup type of BlockExpr\");\n+      return;\n+    }\n+\n+  Bvariable *tmp = NULL;\n+  bool needs_temp = !block_tyty->is_unit ();\n+  if (needs_temp)\n+    {\n+      fncontext fnctx = ctx->peek_fn ();\n+      tree enclosing_scope = ctx->peek_enclosing_scope ();\n+      tree block_type = TyTyResolveCompile::compile (ctx, block_tyty);\n+\n+      bool is_address_taken = false;\n+      tree ret_var_stmt = nullptr;\n+      tmp = ctx->get_backend ()->temporary_variable (\n+\tfnctx.fndecl, enclosing_scope, block_type, NULL, is_address_taken,\n+\texpr.get_locus (), &ret_var_stmt);\n+      ctx->add_statement (ret_var_stmt);\n+    }\n+\n+  auto block_stmt = CompileBlock::compile (&expr, ctx, tmp);\n+  rust_assert (TREE_CODE (block_stmt) == BIND_EXPR);\n+  ctx->add_statement (block_stmt);\n+\n+  if (tmp != NULL)\n+    {\n+      translated = ctx->get_backend ()->var_expression (tmp, expr.get_locus ());\n+    }\n+}\n+\n+void\n+CompileExpr::visit (HIR::UnsafeBlockExpr &expr)\n+{\n+  expr.get_block_expr ()->accept_vis (*this);\n+}\n+\n+void\n+CompileExpr::visit (HIR::StructExprStruct &struct_expr)\n+{\n+  TyTy::BaseType *tyty = nullptr;\n+  if (!ctx->get_tyctx ()->lookup_type (struct_expr.get_mappings ().get_hirid (),\n+\t\t\t\t       &tyty))\n+    {\n+      rust_error_at (struct_expr.get_locus (), \"unknown type\");\n+      return;\n+    }\n+\n+  rust_assert (tyty->is_unit ());\n+  translated = ctx->get_backend ()->unit_expression ();\n+}\n+\n+void\n+CompileExpr::visit (HIR::StructExprStructFields &struct_expr)\n+{\n+  TyTy::BaseType *tyty = nullptr;\n+  if (!ctx->get_tyctx ()->lookup_type (struct_expr.get_mappings ().get_hirid (),\n+\t\t\t\t       &tyty))\n+    {\n+      rust_error_at (struct_expr.get_locus (), \"unknown type\");\n+      return;\n+    }\n+\n+  // it must be an ADT\n+  rust_assert (tyty->get_kind () == TyTy::TypeKind::ADT);\n+  TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (tyty);\n+\n+  // what variant is it?\n+  int union_disriminator = struct_expr.union_index;\n+  TyTy::VariantDef *variant = nullptr;\n+  if (!adt->is_enum ())\n+    {\n+      rust_assert (adt->number_of_variants () == 1);\n+      variant = adt->get_variants ().at (0);\n+    }\n+  else\n+    {\n+      HirId variant_id;\n+      bool ok = ctx->get_tyctx ()->lookup_variant_definition (\n+\tstruct_expr.get_struct_name ().get_mappings ().get_hirid (),\n+\t&variant_id);\n+      rust_assert (ok);\n+\n+      ok\n+\t= adt->lookup_variant_by_id (variant_id, &variant, &union_disriminator);\n+      rust_assert (ok);\n+    }\n+\n+  // compile it\n+  tree compiled_adt_type = TyTyResolveCompile::compile (ctx, tyty);\n+\n+  std::vector<tree> arguments;\n+  if (adt->is_union ())\n+    {\n+      rust_assert (struct_expr.get_fields ().size () == 1);\n+\n+      // assignments are coercion sites so lets convert the rvalue if\n+      // necessary\n+      auto respective_field = variant->get_field_at_index (union_disriminator);\n+      auto expected = respective_field->get_field_type ();\n+\n+      // process arguments\n+      auto &argument = struct_expr.get_fields ().at (0);\n+      auto lvalue_locus\n+\t= ctx->get_mappings ()->lookup_location (expected->get_ty_ref ());\n+      auto rvalue_locus = argument->get_locus ();\n+      auto rvalue = CompileStructExprField::Compile (argument.get (), ctx);\n+\n+      TyTy::BaseType *actual = nullptr;\n+      bool ok = ctx->get_tyctx ()->lookup_type (\n+\targument->get_mappings ().get_hirid (), &actual);\n+\n+      if (ok)\n+\t{\n+\t  rvalue\n+\t    = coercion_site (argument->get_mappings ().get_hirid (), rvalue,\n+\t\t\t     actual, expected, lvalue_locus, rvalue_locus);\n+\t}\n+\n+      // add it to the list\n+      arguments.push_back (rvalue);\n+    }\n+  else\n+    {\n+      // this assumes all fields are in order from type resolution and if a\n+      // base struct was specified those fields are filed via accesors\n+      for (size_t i = 0; i < struct_expr.get_fields ().size (); i++)\n+\t{\n+\t  // assignments are coercion sites so lets convert the rvalue if\n+\t  // necessary\n+\t  auto respective_field = variant->get_field_at_index (i);\n+\t  auto expected = respective_field->get_field_type ();\n+\n+\t  // process arguments\n+\t  auto &argument = struct_expr.get_fields ().at (i);\n+\t  auto lvalue_locus\n+\t    = ctx->get_mappings ()->lookup_location (expected->get_ty_ref ());\n+\t  auto rvalue_locus = argument->get_locus ();\n+\t  auto rvalue = CompileStructExprField::Compile (argument.get (), ctx);\n+\n+\t  TyTy::BaseType *actual = nullptr;\n+\t  bool ok = ctx->get_tyctx ()->lookup_type (\n+\t    argument->get_mappings ().get_hirid (), &actual);\n+\n+\t  // coerce it if required/possible see\n+\t  // compile/torture/struct_base_init_1.rs\n+\t  if (ok)\n+\t    {\n+\t      rvalue\n+\t\t= coercion_site (argument->get_mappings ().get_hirid (), rvalue,\n+\t\t\t\t actual, expected, lvalue_locus, rvalue_locus);\n+\t    }\n+\n+\t  // add it to the list\n+\t  arguments.push_back (rvalue);\n+\t}\n+    }\n+\n+  // the constructor depends on whether this is actually an enum or not if\n+  // its an enum we need to setup the discriminator\n+  std::vector<tree> ctor_arguments;\n+  if (adt->is_enum ())\n+    {\n+      HIR::Expr *discrim_expr = variant->get_discriminant ();\n+      tree discrim_expr_node = CompileExpr::Compile (discrim_expr, ctx);\n+      tree folded_discrim_expr = fold_expr (discrim_expr_node);\n+      tree qualifier = folded_discrim_expr;\n+\n+      ctor_arguments.push_back (qualifier);\n+    }\n+  for (auto &arg : arguments)\n+    ctor_arguments.push_back (arg);\n+\n+  translated = ctx->get_backend ()->constructor_expression (\n+    compiled_adt_type, adt->is_enum (), ctor_arguments, union_disriminator,\n+    struct_expr.get_locus ());\n+}\n+\n+void\n+CompileExpr::visit (HIR::GroupedExpr &expr)\n+{\n+  translated = CompileExpr::Compile (expr.get_expr_in_parens ().get (), ctx);\n+}\n+\n+void\n+CompileExpr::visit (HIR::FieldAccessExpr &expr)\n+{\n+  HIR::Expr *receiver_expr = expr.get_receiver_expr ().get ();\n+  tree receiver_ref = CompileExpr::Compile (receiver_expr, ctx);\n+\n+  // resolve the receiver back to ADT type\n+  TyTy::BaseType *receiver = nullptr;\n+  if (!ctx->get_tyctx ()->lookup_type (\n+\texpr.get_receiver_expr ()->get_mappings ().get_hirid (), &receiver))\n+    {\n+      rust_error_at (expr.get_receiver_expr ()->get_locus (),\n+\t\t     \"unresolved type for receiver\");\n+      return;\n+    }\n+\n+  size_t field_index = 0;\n+  if (receiver->get_kind () == TyTy::TypeKind::ADT)\n+    {\n+      TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (receiver);\n+      rust_assert (!adt->is_enum ());\n+      rust_assert (adt->number_of_variants () == 1);\n+\n+      TyTy::VariantDef *variant = adt->get_variants ().at (0);\n+      bool ok\n+\t= variant->lookup_field (expr.get_field_name (), nullptr, &field_index);\n+      rust_assert (ok);\n+    }\n+  else if (receiver->get_kind () == TyTy::TypeKind::REF)\n+    {\n+      TyTy::ReferenceType *r = static_cast<TyTy::ReferenceType *> (receiver);\n+      TyTy::BaseType *b = r->get_base ();\n+      rust_assert (b->get_kind () == TyTy::TypeKind::ADT);\n+\n+      TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (b);\n+      rust_assert (!adt->is_enum ());\n+      rust_assert (adt->number_of_variants () == 1);\n+\n+      TyTy::VariantDef *variant = adt->get_variants ().at (0);\n+      bool ok\n+\t= variant->lookup_field (expr.get_field_name (), nullptr, &field_index);\n+      rust_assert (ok);\n+\n+      tree indirect = indirect_expression (receiver_ref, expr.get_locus ());\n+      receiver_ref = indirect;\n+    }\n+\n+  translated\n+    = ctx->get_backend ()->struct_field_expression (receiver_ref, field_index,\n+\t\t\t\t\t\t    expr.get_locus ());\n+}\n+\n+void\n+CompileExpr::visit (HIR::QualifiedPathInExpression &expr)\n+{\n+  translated = ResolvePathRef::Compile (expr, ctx);\n+}\n+\n+void\n+CompileExpr::visit (HIR::PathInExpression &expr)\n+{\n+  translated = ResolvePathRef::Compile (expr, ctx);\n+}\n+\n+void\n+CompileExpr::visit (HIR::LoopExpr &expr)\n+{\n+  TyTy::BaseType *block_tyty = nullptr;\n+  if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n+\t\t\t\t       &block_tyty))\n+    {\n+      rust_error_at (expr.get_locus (), \"failed to lookup type of BlockExpr\");\n+      return;\n+    }\n+\n+  fncontext fnctx = ctx->peek_fn ();\n+  tree enclosing_scope = ctx->peek_enclosing_scope ();\n+  tree block_type = TyTyResolveCompile::compile (ctx, block_tyty);\n+\n+  bool is_address_taken = false;\n+  tree ret_var_stmt = NULL_TREE;\n+  Bvariable *tmp = ctx->get_backend ()->temporary_variable (\n+    fnctx.fndecl, enclosing_scope, block_type, NULL, is_address_taken,\n+    expr.get_locus (), &ret_var_stmt);\n+  ctx->add_statement (ret_var_stmt);\n+  ctx->push_loop_context (tmp);\n+\n+  if (expr.has_loop_label ())\n+    {\n+      HIR::LoopLabel &loop_label = expr.get_loop_label ();\n+      tree label\n+\t= ctx->get_backend ()->label (fnctx.fndecl,\n+\t\t\t\t      loop_label.get_lifetime ().get_name (),\n+\t\t\t\t      loop_label.get_locus ());\n+      tree label_decl = ctx->get_backend ()->label_definition_statement (label);\n+      ctx->add_statement (label_decl);\n+      ctx->insert_label_decl (\n+\tloop_label.get_lifetime ().get_mappings ().get_hirid (), label);\n+    }\n+\n+  tree loop_begin_label\n+    = ctx->get_backend ()->label (fnctx.fndecl, \"\", expr.get_locus ());\n+  tree loop_begin_label_decl\n+    = ctx->get_backend ()->label_definition_statement (loop_begin_label);\n+  ctx->add_statement (loop_begin_label_decl);\n+  ctx->push_loop_begin_label (loop_begin_label);\n+\n+  tree code_block\n+    = CompileBlock::compile (expr.get_loop_block ().get (), ctx, nullptr);\n+  tree loop_expr\n+    = ctx->get_backend ()->loop_expression (code_block, expr.get_locus ());\n+  ctx->add_statement (loop_expr);\n+\n+  ctx->pop_loop_context ();\n+  translated = ctx->get_backend ()->var_expression (tmp, expr.get_locus ());\n+\n+  ctx->pop_loop_begin_label ();\n+}\n+\n+void\n+CompileExpr::visit (HIR::WhileLoopExpr &expr)\n+{\n+  fncontext fnctx = ctx->peek_fn ();\n+  if (expr.has_loop_label ())\n+    {\n+      HIR::LoopLabel &loop_label = expr.get_loop_label ();\n+      tree label\n+\t= ctx->get_backend ()->label (fnctx.fndecl,\n+\t\t\t\t      loop_label.get_lifetime ().get_name (),\n+\t\t\t\t      loop_label.get_locus ());\n+      tree label_decl = ctx->get_backend ()->label_definition_statement (label);\n+      ctx->add_statement (label_decl);\n+      ctx->insert_label_decl (\n+\tloop_label.get_lifetime ().get_mappings ().get_hirid (), label);\n+    }\n+\n+  std::vector<Bvariable *> locals;\n+  Location start_location = expr.get_loop_block ()->get_locus ();\n+  Location end_location = expr.get_loop_block ()->get_locus (); // FIXME\n+\n+  tree enclosing_scope = ctx->peek_enclosing_scope ();\n+  tree loop_block\n+    = ctx->get_backend ()->block (fnctx.fndecl, enclosing_scope, locals,\n+\t\t\t\t  start_location, end_location);\n+  ctx->push_block (loop_block);\n+\n+  tree loop_begin_label\n+    = ctx->get_backend ()->label (fnctx.fndecl, \"\", expr.get_locus ());\n+  tree loop_begin_label_decl\n+    = ctx->get_backend ()->label_definition_statement (loop_begin_label);\n+  ctx->add_statement (loop_begin_label_decl);\n+  ctx->push_loop_begin_label (loop_begin_label);\n+\n+  tree condition\n+    = CompileExpr::Compile (expr.get_predicate_expr ().get (), ctx);\n+  tree exit_expr\n+    = ctx->get_backend ()->exit_expression (condition, expr.get_locus ());\n+  ctx->add_statement (exit_expr);\n+\n+  tree code_block_stmt\n+    = CompileBlock::compile (expr.get_loop_block ().get (), ctx, nullptr);\n+  rust_assert (TREE_CODE (code_block_stmt) == BIND_EXPR);\n+  ctx->add_statement (code_block_stmt);\n+\n+  ctx->pop_loop_begin_label ();\n+  ctx->pop_block ();\n+\n+  tree loop_expr\n+    = ctx->get_backend ()->loop_expression (loop_block, expr.get_locus ());\n+  ctx->add_statement (loop_expr);\n+}\n+\n+void\n+CompileExpr::visit (HIR::BreakExpr &expr)\n+{\n+  if (expr.has_break_expr ())\n+    {\n+      tree compiled_expr = CompileExpr::Compile (expr.get_expr ().get (), ctx);\n+\n+      Bvariable *loop_result_holder = ctx->peek_loop_context ();\n+      tree result_reference\n+\t= ctx->get_backend ()->var_expression (loop_result_holder,\n+\t\t\t\t\t       expr.get_expr ()->get_locus ());\n+\n+      tree assignment\n+\t= ctx->get_backend ()->assignment_statement (result_reference,\n+\t\t\t\t\t\t     compiled_expr,\n+\t\t\t\t\t\t     expr.get_locus ());\n+      ctx->add_statement (assignment);\n+    }\n+\n+  if (expr.has_label ())\n+    {\n+      NodeId resolved_node_id = UNKNOWN_NODEID;\n+      if (!ctx->get_resolver ()->lookup_resolved_label (\n+\t    expr.get_label ().get_mappings ().get_nodeid (), &resolved_node_id))\n+\t{\n+\t  rust_error_at (\n+\t    expr.get_label ().get_locus (),\n+\t    \"failed to resolve compiled label for label %s\",\n+\t    expr.get_label ().get_mappings ().as_string ().c_str ());\n+\t  return;\n+\t}\n+\n+      HirId ref = UNKNOWN_HIRID;\n+      if (!ctx->get_mappings ()->lookup_node_to_hir (resolved_node_id, &ref))\n+\t{\n+\t  rust_fatal_error (expr.get_locus (), \"reverse lookup label failure\");\n+\t  return;\n+\t}\n+\n+      tree label = NULL_TREE;\n+      if (!ctx->lookup_label_decl (ref, &label))\n+\t{\n+\t  rust_error_at (expr.get_label ().get_locus (),\n+\t\t\t \"failed to lookup compiled label\");\n+\t  return;\n+\t}\n+\n+      tree goto_label\n+\t= ctx->get_backend ()->goto_statement (label, expr.get_locus ());\n+      ctx->add_statement (goto_label);\n+    }\n+  else\n+    {\n+      tree exit_expr = ctx->get_backend ()->exit_expression (\n+\tctx->get_backend ()->boolean_constant_expression (true),\n+\texpr.get_locus ());\n+      ctx->add_statement (exit_expr);\n+    }\n+}\n+\n+void\n+CompileExpr::visit (HIR::ContinueExpr &expr)\n+{\n+  tree label = ctx->peek_loop_begin_label ();\n+  if (expr.has_label ())\n+    {\n+      NodeId resolved_node_id = UNKNOWN_NODEID;\n+      if (!ctx->get_resolver ()->lookup_resolved_label (\n+\t    expr.get_label ().get_mappings ().get_nodeid (), &resolved_node_id))\n+\t{\n+\t  rust_error_at (\n+\t    expr.get_label ().get_locus (),\n+\t    \"failed to resolve compiled label for label %s\",\n+\t    expr.get_label ().get_mappings ().as_string ().c_str ());\n+\t  return;\n+\t}\n+\n+      HirId ref = UNKNOWN_HIRID;\n+      if (!ctx->get_mappings ()->lookup_node_to_hir (resolved_node_id, &ref))\n+\t{\n+\t  rust_fatal_error (expr.get_locus (), \"reverse lookup label failure\");\n+\t  return;\n+\t}\n+\n+      if (!ctx->lookup_label_decl (ref, &label))\n+\t{\n+\t  rust_error_at (expr.get_label ().get_locus (),\n+\t\t\t \"failed to lookup compiled label\");\n+\t  return;\n+\t}\n+    }\n+\n+  translated = ctx->get_backend ()->goto_statement (label, expr.get_locus ());\n+}\n+\n void\n CompileExpr::visit (HIR::BorrowExpr &expr)\n {\n@@ -177,6 +847,76 @@ CompileExpr::visit (HIR::DereferenceExpr &expr)\n   translated = indirect_expression (main_expr, expr.get_locus ());\n }\n \n+void\n+CompileExpr::visit (HIR::LiteralExpr &expr)\n+{\n+  TyTy::BaseType *tyty = nullptr;\n+  if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n+\t\t\t\t       &tyty))\n+    return;\n+\n+  switch (expr.get_lit_type ())\n+    {\n+    case HIR::Literal::BOOL:\n+      translated = compile_bool_literal (expr, tyty);\n+      return;\n+\n+    case HIR::Literal::INT:\n+      translated = compile_integer_literal (expr, tyty);\n+      return;\n+\n+    case HIR::Literal::FLOAT:\n+      translated = compile_float_literal (expr, tyty);\n+      return;\n+\n+    case HIR::Literal::CHAR:\n+      translated = compile_char_literal (expr, tyty);\n+      return;\n+\n+    case HIR::Literal::BYTE:\n+      translated = compile_byte_literal (expr, tyty);\n+      return;\n+\n+    case HIR::Literal::STRING:\n+      translated = compile_string_literal (expr, tyty);\n+      return;\n+\n+    case HIR::Literal::BYTE_STRING:\n+      translated = compile_byte_string_literal (expr, tyty);\n+      return;\n+    }\n+}\n+\n+void\n+CompileExpr::visit (HIR::AssignmentExpr &expr)\n+{\n+  auto lvalue = CompileExpr::Compile (expr.get_lhs (), ctx);\n+  auto rvalue = CompileExpr::Compile (expr.get_rhs (), ctx);\n+\n+  // assignments are coercion sites so lets convert the rvalue if necessary\n+  TyTy::BaseType *expected = nullptr;\n+  TyTy::BaseType *actual = nullptr;\n+\n+  bool ok;\n+  ok = ctx->get_tyctx ()->lookup_type (\n+    expr.get_lhs ()->get_mappings ().get_hirid (), &expected);\n+  rust_assert (ok);\n+\n+  ok = ctx->get_tyctx ()->lookup_type (\n+    expr.get_rhs ()->get_mappings ().get_hirid (), &actual);\n+  rust_assert (ok);\n+\n+  rvalue = coercion_site (expr.get_mappings ().get_hirid (), rvalue, actual,\n+\t\t\t  expected, expr.get_lhs ()->get_locus (),\n+\t\t\t  expr.get_rhs ()->get_locus ());\n+\n+  tree assignment\n+    = ctx->get_backend ()->assignment_statement (lvalue, rvalue,\n+\t\t\t\t\t\t expr.get_locus ());\n+\n+  ctx->add_statement (assignment);\n+}\n+\n // Helper for sort_tuple_patterns.\n // Determine whether Patterns a and b are really the same pattern.\n // FIXME: This is a nasty hack to avoid properly implementing a comparison"}, {"sha": "4c1f95ade29d589182e136985b3dcd6f05ecc40c", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 26, "deletions": 743, "changes": 769, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73e79179486b21b13fd8dcc138f84398ca0306e4/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73e79179486b21b13fd8dcc138f84398ca0306e4/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=73e79179486b21b13fd8dcc138f84398ca0306e4", "patch": "@@ -20,767 +20,52 @@\n #define RUST_COMPILE_EXPR\n \n #include \"rust-compile-base.h\"\n-#include \"rust-compile-resolve-path.h\"\n-#include \"rust-compile-block.h\"\n-#include \"rust-compile-struct-field-expr.h\"\n-#include \"rust-constexpr.h\"\n \n namespace Rust {\n namespace Compile {\n \n-class CompileExpr : public HIRCompileBase, public HIR::HIRExpressionVisitor\n+class CompileExpr : private HIRCompileBase, protected HIR::HIRExpressionVisitor\n {\n public:\n-  static tree Compile (HIR::Expr *expr, Context *ctx)\n-  {\n-    CompileExpr compiler (ctx);\n-    expr->accept_vis (compiler);\n-    return compiler.translated;\n-  }\n-\n-  void visit (HIR::TupleIndexExpr &expr) override\n-  {\n-    HIR::Expr *tuple_expr = expr.get_tuple_expr ().get ();\n-    TupleIndex index = expr.get_tuple_index ();\n-\n-    tree receiver_ref = CompileExpr::Compile (tuple_expr, ctx);\n-\n-    TyTy::BaseType *tuple_expr_ty = nullptr;\n-    bool ok = ctx->get_tyctx ()->lookup_type (\n-      tuple_expr->get_mappings ().get_hirid (), &tuple_expr_ty);\n-    rust_assert (ok);\n-\n-    // do we need to add an indirect reference\n-    if (tuple_expr_ty->get_kind () == TyTy::TypeKind::REF)\n-      {\n-\ttree indirect = indirect_expression (receiver_ref, expr.get_locus ());\n-\treceiver_ref = indirect;\n-      }\n-\n-    translated\n-      = ctx->get_backend ()->struct_field_expression (receiver_ref, index,\n-\t\t\t\t\t\t      expr.get_locus ());\n-  }\n-\n-  void visit (HIR::TupleExpr &expr) override\n-  {\n-    if (expr.is_unit ())\n-      {\n-\ttranslated = ctx->get_backend ()->unit_expression ();\n-\treturn;\n-      }\n-\n-    TyTy::BaseType *tyty = nullptr;\n-    if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n-\t\t\t\t\t &tyty))\n-      {\n-\trust_fatal_error (expr.get_locus (),\n-\t\t\t  \"did not resolve type for this TupleExpr\");\n-\treturn;\n-      }\n-\n-    tree tuple_type = TyTyResolveCompile::compile (ctx, tyty);\n-    rust_assert (tuple_type != nullptr);\n-\n-    // this assumes all fields are in order from type resolution\n-    std::vector<tree> vals;\n-    for (auto &elem : expr.get_tuple_elems ())\n-      {\n-\tauto e = CompileExpr::Compile (elem.get (), ctx);\n-\tvals.push_back (e);\n-      }\n-\n-    translated\n-      = ctx->get_backend ()->constructor_expression (tuple_type, false, vals,\n-\t\t\t\t\t\t     -1, expr.get_locus ());\n-  }\n-\n-  void visit (HIR::ReturnExpr &expr) override\n-  {\n-    auto fncontext = ctx->peek_fn ();\n-\n-    std::vector<tree> retstmts;\n-    if (expr.has_return_expr ())\n-      {\n-\ttree compiled_expr\n-\t  = CompileExpr::Compile (expr.return_expr.get (), ctx);\n-\trust_assert (compiled_expr != nullptr);\n-\n-\tretstmts.push_back (compiled_expr);\n-      }\n-\n-    auto s = ctx->get_backend ()->return_statement (fncontext.fndecl, retstmts,\n-\t\t\t\t\t\t    expr.get_locus ());\n-    ctx->add_statement (s);\n-  }\n+  static tree Compile (HIR::Expr *expr, Context *ctx);\n \n+  void visit (HIR::TupleIndexExpr &expr) override;\n+  void visit (HIR::TupleExpr &expr) override;\n+  void visit (HIR::ReturnExpr &expr) override;\n   void visit (HIR::CallExpr &expr) override;\n-\n   void visit (HIR::MethodCallExpr &expr) override;\n-\n-  void visit (HIR::LiteralExpr &expr) override\n-  {\n-    TyTy::BaseType *tyty = nullptr;\n-    if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n-\t\t\t\t\t &tyty))\n-      return;\n-\n-    switch (expr.get_lit_type ())\n-      {\n-      case HIR::Literal::BOOL:\n-\ttranslated = compile_bool_literal (expr, tyty);\n-\treturn;\n-\n-      case HIR::Literal::INT:\n-\ttranslated = compile_integer_literal (expr, tyty);\n-\treturn;\n-\n-      case HIR::Literal::FLOAT:\n-\ttranslated = compile_float_literal (expr, tyty);\n-\treturn;\n-\n-      case HIR::Literal::CHAR:\n-\ttranslated = compile_char_literal (expr, tyty);\n-\treturn;\n-\n-      case HIR::Literal::BYTE:\n-\ttranslated = compile_byte_literal (expr, tyty);\n-\treturn;\n-\n-      case HIR::Literal::STRING:\n-\ttranslated = compile_string_literal (expr, tyty);\n-\treturn;\n-\n-      case HIR::Literal::BYTE_STRING:\n-\ttranslated = compile_byte_string_literal (expr, tyty);\n-\treturn;\n-      }\n-  }\n-\n-  void visit (HIR::AssignmentExpr &expr) override\n-  {\n-    auto lvalue = CompileExpr::Compile (expr.get_lhs (), ctx);\n-    auto rvalue = CompileExpr::Compile (expr.get_rhs (), ctx);\n-\n-    // assignments are coercion sites so lets convert the rvalue if necessary\n-    TyTy::BaseType *expected = nullptr;\n-    TyTy::BaseType *actual = nullptr;\n-\n-    bool ok;\n-    ok = ctx->get_tyctx ()->lookup_type (\n-      expr.get_lhs ()->get_mappings ().get_hirid (), &expected);\n-    rust_assert (ok);\n-\n-    ok = ctx->get_tyctx ()->lookup_type (\n-      expr.get_rhs ()->get_mappings ().get_hirid (), &actual);\n-    rust_assert (ok);\n-\n-    rvalue = coercion_site (expr.get_mappings ().get_hirid (), rvalue, actual,\n-\t\t\t    expected, expr.get_lhs ()->get_locus (),\n-\t\t\t    expr.get_rhs ()->get_locus ());\n-\n-    tree assignment\n-      = ctx->get_backend ()->assignment_statement (lvalue, rvalue,\n-\t\t\t\t\t\t   expr.get_locus ());\n-\n-    ctx->add_statement (assignment);\n-  }\n-\n+  void visit (HIR::LiteralExpr &expr) override;\n+  void visit (HIR::AssignmentExpr &expr) override;\n   void visit (HIR::CompoundAssignmentExpr &expr) override;\n-\n   void visit (HIR::ArrayIndexExpr &expr) override;\n-\n   void visit (HIR::ArrayExpr &expr) override;\n-\n   void visit (HIR::ArithmeticOrLogicalExpr &expr) override;\n-\n-  void visit (HIR::ComparisonExpr &expr) override\n-  {\n-    auto op = expr.get_expr_type ();\n-    auto lhs = CompileExpr::Compile (expr.get_lhs (), ctx);\n-    auto rhs = CompileExpr::Compile (expr.get_rhs (), ctx);\n-    auto location = expr.get_locus ();\n-\n-    translated\n-      = ctx->get_backend ()->comparison_expression (op, lhs, rhs, location);\n-  }\n-\n-  void visit (HIR::LazyBooleanExpr &expr) override\n-  {\n-    auto op = expr.get_expr_type ();\n-    auto lhs = CompileExpr::Compile (expr.get_lhs (), ctx);\n-    auto rhs = CompileExpr::Compile (expr.get_rhs (), ctx);\n-    auto location = expr.get_locus ();\n-\n-    translated\n-      = ctx->get_backend ()->lazy_boolean_expression (op, lhs, rhs, location);\n-  }\n-\n+  void visit (HIR::ComparisonExpr &expr) override;\n+  void visit (HIR::LazyBooleanExpr &expr) override;\n   void visit (HIR::NegationExpr &expr) override;\n-\n-  void visit (HIR::TypeCastExpr &expr) override\n-  {\n-    TyTy::BaseType *tyty = nullptr;\n-    if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n-\t\t\t\t\t &tyty))\n-      {\n-\ttranslated = error_mark_node;\n-\treturn;\n-      }\n-\n-    auto type_to_cast_to = TyTyResolveCompile::compile (ctx, tyty);\n-    auto casted_expr\n-      = CompileExpr::Compile (expr.get_casted_expr ().get (), ctx);\n-    translated\n-      = type_cast_expression (type_to_cast_to, casted_expr, expr.get_locus ());\n-  }\n-\n-  void visit (HIR::IfExpr &expr) override\n-  {\n-    auto stmt = CompileConditionalBlocks::compile (&expr, ctx, nullptr);\n-    ctx->add_statement (stmt);\n-  }\n-\n-  void visit (HIR::IfExprConseqElse &expr) override\n-  {\n-    TyTy::BaseType *if_type = nullptr;\n-    if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n-\t\t\t\t\t &if_type))\n-      {\n-\trust_error_at (expr.get_locus (),\n-\t\t       \"failed to lookup type of IfExprConseqElse\");\n-\treturn;\n-      }\n-\n-    Bvariable *tmp = NULL;\n-    bool needs_temp = !if_type->is_unit ();\n-    if (needs_temp)\n-      {\n-\tfncontext fnctx = ctx->peek_fn ();\n-\ttree enclosing_scope = ctx->peek_enclosing_scope ();\n-\ttree block_type = TyTyResolveCompile::compile (ctx, if_type);\n-\n-\tbool is_address_taken = false;\n-\ttree ret_var_stmt = nullptr;\n-\ttmp = ctx->get_backend ()->temporary_variable (\n-\t  fnctx.fndecl, enclosing_scope, block_type, NULL, is_address_taken,\n-\t  expr.get_locus (), &ret_var_stmt);\n-\tctx->add_statement (ret_var_stmt);\n-      }\n-\n-    auto stmt = CompileConditionalBlocks::compile (&expr, ctx, tmp);\n-    ctx->add_statement (stmt);\n-\n-    if (tmp != NULL)\n-      {\n-\ttranslated\n-\t  = ctx->get_backend ()->var_expression (tmp, expr.get_locus ());\n-      }\n-  }\n-\n-  void visit (HIR::IfExprConseqIf &expr) override\n-  {\n-    TyTy::BaseType *if_type = nullptr;\n-    if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n-\t\t\t\t\t &if_type))\n-      {\n-\trust_error_at (expr.get_locus (),\n-\t\t       \"failed to lookup type of IfExprConseqElse\");\n-\treturn;\n-      }\n-\n-    Bvariable *tmp = NULL;\n-    bool needs_temp = !if_type->is_unit ();\n-    if (needs_temp)\n-      {\n-\tfncontext fnctx = ctx->peek_fn ();\n-\ttree enclosing_scope = ctx->peek_enclosing_scope ();\n-\ttree block_type = TyTyResolveCompile::compile (ctx, if_type);\n-\n-\tbool is_address_taken = false;\n-\ttree ret_var_stmt = nullptr;\n-\ttmp = ctx->get_backend ()->temporary_variable (\n-\t  fnctx.fndecl, enclosing_scope, block_type, NULL, is_address_taken,\n-\t  expr.get_locus (), &ret_var_stmt);\n-\tctx->add_statement (ret_var_stmt);\n-      }\n-\n-    auto stmt = CompileConditionalBlocks::compile (&expr, ctx, tmp);\n-    ctx->add_statement (stmt);\n-\n-    if (tmp != NULL)\n-      {\n-\ttranslated\n-\t  = ctx->get_backend ()->var_expression (tmp, expr.get_locus ());\n-      }\n-  }\n-\n-  void visit (HIR::BlockExpr &expr) override\n-  {\n-    TyTy::BaseType *block_tyty = nullptr;\n-    if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n-\t\t\t\t\t &block_tyty))\n-      {\n-\trust_error_at (expr.get_locus (), \"failed to lookup type of BlockExpr\");\n-\treturn;\n-      }\n-\n-    Bvariable *tmp = NULL;\n-    bool needs_temp = !block_tyty->is_unit ();\n-    if (needs_temp)\n-      {\n-\tfncontext fnctx = ctx->peek_fn ();\n-\ttree enclosing_scope = ctx->peek_enclosing_scope ();\n-\ttree block_type = TyTyResolveCompile::compile (ctx, block_tyty);\n-\n-\tbool is_address_taken = false;\n-\ttree ret_var_stmt = nullptr;\n-\ttmp = ctx->get_backend ()->temporary_variable (\n-\t  fnctx.fndecl, enclosing_scope, block_type, NULL, is_address_taken,\n-\t  expr.get_locus (), &ret_var_stmt);\n-\tctx->add_statement (ret_var_stmt);\n-      }\n-\n-    auto block_stmt = CompileBlock::compile (&expr, ctx, tmp);\n-    rust_assert (TREE_CODE (block_stmt) == BIND_EXPR);\n-    ctx->add_statement (block_stmt);\n-\n-    if (tmp != NULL)\n-      {\n-\ttranslated\n-\t  = ctx->get_backend ()->var_expression (tmp, expr.get_locus ());\n-      }\n-  }\n-\n-  void visit (HIR::UnsafeBlockExpr &expr) override\n-  {\n-    expr.get_block_expr ()->accept_vis (*this);\n-  }\n-\n-  void visit (HIR::StructExprStruct &struct_expr) override\n-  {\n-    TyTy::BaseType *tyty = nullptr;\n-    if (!ctx->get_tyctx ()->lookup_type (\n-\t  struct_expr.get_mappings ().get_hirid (), &tyty))\n-      {\n-\trust_error_at (struct_expr.get_locus (), \"unknown type\");\n-\treturn;\n-      }\n-\n-    rust_assert (tyty->is_unit ());\n-    translated = ctx->get_backend ()->unit_expression ();\n-  }\n-\n-  void visit (HIR::StructExprStructFields &struct_expr) override\n-  {\n-    TyTy::BaseType *tyty = nullptr;\n-    if (!ctx->get_tyctx ()->lookup_type (\n-\t  struct_expr.get_mappings ().get_hirid (), &tyty))\n-      {\n-\trust_error_at (struct_expr.get_locus (), \"unknown type\");\n-\treturn;\n-      }\n-\n-    // it must be an ADT\n-    rust_assert (tyty->get_kind () == TyTy::TypeKind::ADT);\n-    TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (tyty);\n-\n-    // what variant is it?\n-    int union_disriminator = struct_expr.union_index;\n-    TyTy::VariantDef *variant = nullptr;\n-    if (!adt->is_enum ())\n-      {\n-\trust_assert (adt->number_of_variants () == 1);\n-\tvariant = adt->get_variants ().at (0);\n-      }\n-    else\n-      {\n-\tHirId variant_id;\n-\tbool ok = ctx->get_tyctx ()->lookup_variant_definition (\n-\t  struct_expr.get_struct_name ().get_mappings ().get_hirid (),\n-\t  &variant_id);\n-\trust_assert (ok);\n-\n-\tok = adt->lookup_variant_by_id (variant_id, &variant,\n-\t\t\t\t\t&union_disriminator);\n-\trust_assert (ok);\n-      }\n-\n-    // compile it\n-    tree compiled_adt_type = TyTyResolveCompile::compile (ctx, tyty);\n-\n-    std::vector<tree> arguments;\n-    if (adt->is_union ())\n-      {\n-\trust_assert (struct_expr.get_fields ().size () == 1);\n-\n-\t// assignments are coercion sites so lets convert the rvalue if\n-\t// necessary\n-\tauto respective_field\n-\t  = variant->get_field_at_index (union_disriminator);\n-\tauto expected = respective_field->get_field_type ();\n-\n-\t// process arguments\n-\tauto &argument = struct_expr.get_fields ().at (0);\n-\tauto lvalue_locus\n-\t  = ctx->get_mappings ()->lookup_location (expected->get_ty_ref ());\n-\tauto rvalue_locus = argument->get_locus ();\n-\tauto rvalue = CompileStructExprField::Compile (argument.get (), ctx);\n-\n-\tTyTy::BaseType *actual = nullptr;\n-\tbool ok = ctx->get_tyctx ()->lookup_type (\n-\t  argument->get_mappings ().get_hirid (), &actual);\n-\n-\tif (ok)\n-\t  {\n-\t    rvalue\n-\t      = coercion_site (argument->get_mappings ().get_hirid (), rvalue,\n-\t\t\t       actual, expected, lvalue_locus, rvalue_locus);\n-\t  }\n-\n-\t// add it to the list\n-\targuments.push_back (rvalue);\n-      }\n-    else\n-      {\n-\t// this assumes all fields are in order from type resolution and if a\n-\t// base struct was specified those fields are filed via accesors\n-\tfor (size_t i = 0; i < struct_expr.get_fields ().size (); i++)\n-\t  {\n-\t    // assignments are coercion sites so lets convert the rvalue if\n-\t    // necessary\n-\t    auto respective_field = variant->get_field_at_index (i);\n-\t    auto expected = respective_field->get_field_type ();\n-\n-\t    // process arguments\n-\t    auto &argument = struct_expr.get_fields ().at (i);\n-\t    auto lvalue_locus\n-\t      = ctx->get_mappings ()->lookup_location (expected->get_ty_ref ());\n-\t    auto rvalue_locus = argument->get_locus ();\n-\t    auto rvalue\n-\t      = CompileStructExprField::Compile (argument.get (), ctx);\n-\n-\t    TyTy::BaseType *actual = nullptr;\n-\t    bool ok = ctx->get_tyctx ()->lookup_type (\n-\t      argument->get_mappings ().get_hirid (), &actual);\n-\n-\t    // coerce it if required/possible see\n-\t    // compile/torture/struct_base_init_1.rs\n-\t    if (ok)\n-\t      {\n-\t\trvalue = coercion_site (argument->get_mappings ().get_hirid (),\n-\t\t\t\t\trvalue, actual, expected, lvalue_locus,\n-\t\t\t\t\trvalue_locus);\n-\t      }\n-\n-\t    // add it to the list\n-\t    arguments.push_back (rvalue);\n-\t  }\n-      }\n-\n-    // the constructor depends on whether this is actually an enum or not if\n-    // its an enum we need to setup the discriminator\n-    std::vector<tree> ctor_arguments;\n-    if (adt->is_enum ())\n-      {\n-\tHIR::Expr *discrim_expr = variant->get_discriminant ();\n-\ttree discrim_expr_node = CompileExpr::Compile (discrim_expr, ctx);\n-\ttree folded_discrim_expr = fold_expr (discrim_expr_node);\n-\ttree qualifier = folded_discrim_expr;\n-\n-\tctor_arguments.push_back (qualifier);\n-      }\n-    for (auto &arg : arguments)\n-      ctor_arguments.push_back (arg);\n-\n-    translated = ctx->get_backend ()->constructor_expression (\n-      compiled_adt_type, adt->is_enum (), ctor_arguments, union_disriminator,\n-      struct_expr.get_locus ());\n-  }\n-\n-  void visit (HIR::GroupedExpr &expr) override\n-  {\n-    translated = CompileExpr::Compile (expr.get_expr_in_parens ().get (), ctx);\n-  }\n-\n-  void visit (HIR::FieldAccessExpr &expr) override\n-  {\n-    HIR::Expr *receiver_expr = expr.get_receiver_expr ().get ();\n-    tree receiver_ref = CompileExpr::Compile (receiver_expr, ctx);\n-\n-    // resolve the receiver back to ADT type\n-    TyTy::BaseType *receiver = nullptr;\n-    if (!ctx->get_tyctx ()->lookup_type (\n-\t  expr.get_receiver_expr ()->get_mappings ().get_hirid (), &receiver))\n-      {\n-\trust_error_at (expr.get_receiver_expr ()->get_locus (),\n-\t\t       \"unresolved type for receiver\");\n-\treturn;\n-      }\n-\n-    size_t field_index = 0;\n-    if (receiver->get_kind () == TyTy::TypeKind::ADT)\n-      {\n-\tTyTy::ADTType *adt = static_cast<TyTy::ADTType *> (receiver);\n-\trust_assert (!adt->is_enum ());\n-\trust_assert (adt->number_of_variants () == 1);\n-\n-\tTyTy::VariantDef *variant = adt->get_variants ().at (0);\n-\tbool ok = variant->lookup_field (expr.get_field_name (), nullptr,\n-\t\t\t\t\t &field_index);\n-\trust_assert (ok);\n-      }\n-    else if (receiver->get_kind () == TyTy::TypeKind::REF)\n-      {\n-\tTyTy::ReferenceType *r = static_cast<TyTy::ReferenceType *> (receiver);\n-\tTyTy::BaseType *b = r->get_base ();\n-\trust_assert (b->get_kind () == TyTy::TypeKind::ADT);\n-\n-\tTyTy::ADTType *adt = static_cast<TyTy::ADTType *> (b);\n-\trust_assert (!adt->is_enum ());\n-\trust_assert (adt->number_of_variants () == 1);\n-\n-\tTyTy::VariantDef *variant = adt->get_variants ().at (0);\n-\tbool ok = variant->lookup_field (expr.get_field_name (), nullptr,\n-\t\t\t\t\t &field_index);\n-\trust_assert (ok);\n-\n-\ttree indirect = indirect_expression (receiver_ref, expr.get_locus ());\n-\treceiver_ref = indirect;\n-      }\n-\n-    translated\n-      = ctx->get_backend ()->struct_field_expression (receiver_ref, field_index,\n-\t\t\t\t\t\t      expr.get_locus ());\n-  }\n-\n-  void visit (HIR::QualifiedPathInExpression &expr) override\n-  {\n-    translated = ResolvePathRef::Compile (expr, ctx);\n-  }\n-\n-  void visit (HIR::PathInExpression &expr) override\n-  {\n-    translated = ResolvePathRef::Compile (expr, ctx);\n-  }\n-\n-  void visit (HIR::LoopExpr &expr) override\n-  {\n-    TyTy::BaseType *block_tyty = nullptr;\n-    if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n-\t\t\t\t\t &block_tyty))\n-      {\n-\trust_error_at (expr.get_locus (), \"failed to lookup type of BlockExpr\");\n-\treturn;\n-      }\n-\n-    fncontext fnctx = ctx->peek_fn ();\n-    tree enclosing_scope = ctx->peek_enclosing_scope ();\n-    tree block_type = TyTyResolveCompile::compile (ctx, block_tyty);\n-\n-    bool is_address_taken = false;\n-    tree ret_var_stmt = NULL_TREE;\n-    Bvariable *tmp = ctx->get_backend ()->temporary_variable (\n-      fnctx.fndecl, enclosing_scope, block_type, NULL, is_address_taken,\n-      expr.get_locus (), &ret_var_stmt);\n-    ctx->add_statement (ret_var_stmt);\n-    ctx->push_loop_context (tmp);\n-\n-    if (expr.has_loop_label ())\n-      {\n-\tHIR::LoopLabel &loop_label = expr.get_loop_label ();\n-\ttree label\n-\t  = ctx->get_backend ()->label (fnctx.fndecl,\n-\t\t\t\t\tloop_label.get_lifetime ().get_name (),\n-\t\t\t\t\tloop_label.get_locus ());\n-\ttree label_decl\n-\t  = ctx->get_backend ()->label_definition_statement (label);\n-\tctx->add_statement (label_decl);\n-\tctx->insert_label_decl (\n-\t  loop_label.get_lifetime ().get_mappings ().get_hirid (), label);\n-      }\n-\n-    tree loop_begin_label\n-      = ctx->get_backend ()->label (fnctx.fndecl, \"\", expr.get_locus ());\n-    tree loop_begin_label_decl\n-      = ctx->get_backend ()->label_definition_statement (loop_begin_label);\n-    ctx->add_statement (loop_begin_label_decl);\n-    ctx->push_loop_begin_label (loop_begin_label);\n-\n-    tree code_block\n-      = CompileBlock::compile (expr.get_loop_block ().get (), ctx, nullptr);\n-    tree loop_expr\n-      = ctx->get_backend ()->loop_expression (code_block, expr.get_locus ());\n-    ctx->add_statement (loop_expr);\n-\n-    ctx->pop_loop_context ();\n-    translated = ctx->get_backend ()->var_expression (tmp, expr.get_locus ());\n-\n-    ctx->pop_loop_begin_label ();\n-  }\n-\n-  void visit (HIR::WhileLoopExpr &expr) override\n-  {\n-    fncontext fnctx = ctx->peek_fn ();\n-    if (expr.has_loop_label ())\n-      {\n-\tHIR::LoopLabel &loop_label = expr.get_loop_label ();\n-\ttree label\n-\t  = ctx->get_backend ()->label (fnctx.fndecl,\n-\t\t\t\t\tloop_label.get_lifetime ().get_name (),\n-\t\t\t\t\tloop_label.get_locus ());\n-\ttree label_decl\n-\t  = ctx->get_backend ()->label_definition_statement (label);\n-\tctx->add_statement (label_decl);\n-\tctx->insert_label_decl (\n-\t  loop_label.get_lifetime ().get_mappings ().get_hirid (), label);\n-      }\n-\n-    std::vector<Bvariable *> locals;\n-    Location start_location = expr.get_loop_block ()->get_locus ();\n-    Location end_location = expr.get_loop_block ()->get_locus (); // FIXME\n-\n-    tree enclosing_scope = ctx->peek_enclosing_scope ();\n-    tree loop_block\n-      = ctx->get_backend ()->block (fnctx.fndecl, enclosing_scope, locals,\n-\t\t\t\t    start_location, end_location);\n-    ctx->push_block (loop_block);\n-\n-    tree loop_begin_label\n-      = ctx->get_backend ()->label (fnctx.fndecl, \"\", expr.get_locus ());\n-    tree loop_begin_label_decl\n-      = ctx->get_backend ()->label_definition_statement (loop_begin_label);\n-    ctx->add_statement (loop_begin_label_decl);\n-    ctx->push_loop_begin_label (loop_begin_label);\n-\n-    tree condition\n-      = CompileExpr::Compile (expr.get_predicate_expr ().get (), ctx);\n-    tree exit_expr\n-      = ctx->get_backend ()->exit_expression (condition, expr.get_locus ());\n-    ctx->add_statement (exit_expr);\n-\n-    tree code_block_stmt\n-      = CompileBlock::compile (expr.get_loop_block ().get (), ctx, nullptr);\n-    rust_assert (TREE_CODE (code_block_stmt) == BIND_EXPR);\n-    ctx->add_statement (code_block_stmt);\n-\n-    ctx->pop_loop_begin_label ();\n-    ctx->pop_block ();\n-\n-    tree loop_expr\n-      = ctx->get_backend ()->loop_expression (loop_block, expr.get_locus ());\n-    ctx->add_statement (loop_expr);\n-  }\n-\n-  void visit (HIR::BreakExpr &expr) override\n-  {\n-    if (expr.has_break_expr ())\n-      {\n-\ttree compiled_expr\n-\t  = CompileExpr::Compile (expr.get_expr ().get (), ctx);\n-\n-\tBvariable *loop_result_holder = ctx->peek_loop_context ();\n-\ttree result_reference = ctx->get_backend ()->var_expression (\n-\t  loop_result_holder, expr.get_expr ()->get_locus ());\n-\n-\ttree assignment\n-\t  = ctx->get_backend ()->assignment_statement (result_reference,\n-\t\t\t\t\t\t       compiled_expr,\n-\t\t\t\t\t\t       expr.get_locus ());\n-\tctx->add_statement (assignment);\n-      }\n-\n-    if (expr.has_label ())\n-      {\n-\tNodeId resolved_node_id = UNKNOWN_NODEID;\n-\tif (!ctx->get_resolver ()->lookup_resolved_label (\n-\t      expr.get_label ().get_mappings ().get_nodeid (),\n-\t      &resolved_node_id))\n-\t  {\n-\t    rust_error_at (\n-\t      expr.get_label ().get_locus (),\n-\t      \"failed to resolve compiled label for label %s\",\n-\t      expr.get_label ().get_mappings ().as_string ().c_str ());\n-\t    return;\n-\t  }\n-\n-\tHirId ref = UNKNOWN_HIRID;\n-\tif (!ctx->get_mappings ()->lookup_node_to_hir (resolved_node_id, &ref))\n-\t  {\n-\t    rust_fatal_error (expr.get_locus (),\n-\t\t\t      \"reverse lookup label failure\");\n-\t    return;\n-\t  }\n-\n-\ttree label = NULL_TREE;\n-\tif (!ctx->lookup_label_decl (ref, &label))\n-\t  {\n-\t    rust_error_at (expr.get_label ().get_locus (),\n-\t\t\t   \"failed to lookup compiled label\");\n-\t    return;\n-\t  }\n-\n-\ttree goto_label\n-\t  = ctx->get_backend ()->goto_statement (label, expr.get_locus ());\n-\tctx->add_statement (goto_label);\n-      }\n-    else\n-      {\n-\ttree exit_expr = ctx->get_backend ()->exit_expression (\n-\t  ctx->get_backend ()->boolean_constant_expression (true),\n-\t  expr.get_locus ());\n-\tctx->add_statement (exit_expr);\n-      }\n-  }\n-\n-  void visit (HIR::ContinueExpr &expr) override\n-  {\n-    tree label = ctx->peek_loop_begin_label ();\n-    if (expr.has_label ())\n-      {\n-\tNodeId resolved_node_id = UNKNOWN_NODEID;\n-\tif (!ctx->get_resolver ()->lookup_resolved_label (\n-\t      expr.get_label ().get_mappings ().get_nodeid (),\n-\t      &resolved_node_id))\n-\t  {\n-\t    rust_error_at (\n-\t      expr.get_label ().get_locus (),\n-\t      \"failed to resolve compiled label for label %s\",\n-\t      expr.get_label ().get_mappings ().as_string ().c_str ());\n-\t    return;\n-\t  }\n-\n-\tHirId ref = UNKNOWN_HIRID;\n-\tif (!ctx->get_mappings ()->lookup_node_to_hir (resolved_node_id, &ref))\n-\t  {\n-\t    rust_fatal_error (expr.get_locus (),\n-\t\t\t      \"reverse lookup label failure\");\n-\t    return;\n-\t  }\n-\n-\tif (!ctx->lookup_label_decl (ref, &label))\n-\t  {\n-\t    rust_error_at (expr.get_label ().get_locus (),\n-\t\t\t   \"failed to lookup compiled label\");\n-\t    return;\n-\t  }\n-      }\n-\n-    translated = ctx->get_backend ()->goto_statement (label, expr.get_locus ());\n-  }\n-\n+  void visit (HIR::TypeCastExpr &expr) override;\n+  void visit (HIR::IfExpr &expr) override;\n+  void visit (HIR::IfExprConseqIf &expr) override;\n+  void visit (HIR::IfExprConseqElse &expr) override;\n+  void visit (HIR::BlockExpr &expr) override;\n+  void visit (HIR::UnsafeBlockExpr &expr) override;\n+  void visit (HIR::StructExprStruct &struct_expr) override;\n+  void visit (HIR::StructExprStructFields &struct_expr) override;\n+  void visit (HIR::GroupedExpr &expr) override;\n+  void visit (HIR::FieldAccessExpr &expr) override;\n+  void visit (HIR::QualifiedPathInExpression &expr) override;\n+  void visit (HIR::PathInExpression &expr) override;\n+  void visit (HIR::LoopExpr &expr) override;\n+  void visit (HIR::WhileLoopExpr &expr) override;\n+  void visit (HIR::BreakExpr &expr) override;\n+  void visit (HIR::ContinueExpr &expr) override;\n   void visit (HIR::BorrowExpr &expr) override;\n   void visit (HIR::DereferenceExpr &expr) override;\n   void visit (HIR::MatchExpr &expr) override;\n-\n   void visit (HIR::RangeFromToExpr &expr) override;\n-\n   void visit (HIR::RangeFromExpr &expr) override;\n-\n   void visit (HIR::RangeToExpr &expr) override;\n-\n   void visit (HIR::RangeFullExpr &expr) override;\n-\n   void visit (HIR::RangeFromToInclExpr &expr) override;\n \n   // Empty visit for unused Expression HIR nodes.\n@@ -852,9 +137,7 @@ class CompileExpr : public HIRCompileBase, public HIR::HIRExpressionVisitor\n \t\t\t  HIR::ArrayElemsCopied &elems);\n \n private:\n-  CompileExpr (Context *ctx)\n-    : HIRCompileBase (ctx), translated (error_mark_node)\n-  {}\n+  CompileExpr (Context *ctx);\n \n   tree translated;\n };"}, {"sha": "3f0ec82b625336cd650ab26c1a38b6efabbd081d", "filename": "gcc/rust/backend/rust-compile-fnparam.cc", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73e79179486b21b13fd8dcc138f84398ca0306e4/gcc%2Frust%2Fbackend%2Frust-compile-fnparam.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73e79179486b21b13fd8dcc138f84398ca0306e4/gcc%2Frust%2Fbackend%2Frust-compile-fnparam.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-fnparam.cc?ref=73e79179486b21b13fd8dcc138f84398ca0306e4", "patch": "@@ -24,6 +24,51 @@\n namespace Rust {\n namespace Compile {\n \n+CompileFnParam::CompileFnParam (Context *ctx, tree fndecl, tree decl_type,\n+\t\t\t\tLocation locus)\n+  : HIRCompileBase (ctx), fndecl (fndecl), decl_type (decl_type), locus (locus),\n+    compiled_param (ctx->get_backend ()->error_variable ())\n+{}\n+\n+Bvariable *\n+CompileFnParam::compile (Context *ctx, tree fndecl, HIR::FunctionParam *param,\n+\t\t\t tree decl_type, Location locus)\n+{\n+  CompileFnParam compiler (ctx, fndecl, decl_type, locus);\n+  param->get_param_name ()->accept_vis (compiler);\n+  return compiler.compiled_param;\n+}\n+\n+Bvariable *\n+CompileFnParam::compile (Context *ctx, tree fndecl, HIR::Pattern *param,\n+\t\t\t tree decl_type, Location locus)\n+{\n+  CompileFnParam compiler (ctx, fndecl, decl_type, locus);\n+  param->accept_vis (compiler);\n+  return compiler.compiled_param;\n+}\n+\n+void\n+CompileFnParam::visit (HIR::IdentifierPattern &pattern)\n+{\n+  if (!pattern.is_mut ())\n+    decl_type = ctx->get_backend ()->immutable_type (decl_type);\n+\n+  compiled_param\n+    = ctx->get_backend ()->parameter_variable (fndecl,\n+\t\t\t\t\t       pattern.get_identifier (),\n+\t\t\t\t\t       decl_type, locus);\n+}\n+\n+void\n+CompileFnParam::visit (HIR::WildcardPattern &pattern)\n+{\n+  decl_type = ctx->get_backend ()->immutable_type (decl_type);\n+\n+  compiled_param\n+    = ctx->get_backend ()->parameter_variable (fndecl, \"_\", decl_type, locus);\n+}\n+\n void\n CompileFnParam::visit (HIR::StructPattern &pattern)\n {\n@@ -58,5 +103,19 @@ CompileFnParam::visit (HIR::TupleStructPattern &pattern)\n   CompilePatternBindings::Compile (&pattern, anon_param, ctx);\n }\n \n+Bvariable *\n+CompileSelfParam::compile (Context *ctx, tree fndecl, HIR::SelfParam &self,\n+\t\t\t   tree decl_type, Location locus)\n+{\n+  bool is_immutable\n+    = self.get_self_kind () == HIR::SelfParam::ImplicitSelfKind::IMM\n+      || self.get_self_kind () == HIR::SelfParam::ImplicitSelfKind::IMM_REF;\n+  if (is_immutable)\n+    decl_type = ctx->get_backend ()->immutable_type (decl_type);\n+\n+  return ctx->get_backend ()->parameter_variable (fndecl, \"self\", decl_type,\n+\t\t\t\t\t\t  locus);\n+}\n+\n } // namespace Compile\n } // namespace Rust"}, {"sha": "0dbbd99ef08d66f1b74045bc2f0afa127c00f7d2", "filename": "gcc/rust/backend/rust-compile-fnparam.h", "status": "modified", "additions": 8, "deletions": 49, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73e79179486b21b13fd8dcc138f84398ca0306e4/gcc%2Frust%2Fbackend%2Frust-compile-fnparam.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73e79179486b21b13fd8dcc138f84398ca0306e4/gcc%2Frust%2Fbackend%2Frust-compile-fnparam.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-fnparam.h?ref=73e79179486b21b13fd8dcc138f84398ca0306e4", "patch": "@@ -24,45 +24,17 @@\n namespace Rust {\n namespace Compile {\n \n-class CompileFnParam : public HIRCompileBase, public HIR::HIRPatternVisitor\n+class CompileFnParam : private HIRCompileBase, protected HIR::HIRPatternVisitor\n {\n public:\n   static Bvariable *compile (Context *ctx, tree fndecl,\n \t\t\t     HIR::FunctionParam *param, tree decl_type,\n-\t\t\t     Location locus)\n-  {\n-    CompileFnParam compiler (ctx, fndecl, decl_type, locus);\n-    param->get_param_name ()->accept_vis (compiler);\n-    return compiler.compiled_param;\n-  }\n-\n+\t\t\t     Location locus);\n   static Bvariable *compile (Context *ctx, tree fndecl, HIR::Pattern *param,\n-\t\t\t     tree decl_type, Location locus)\n-  {\n-    CompileFnParam compiler (ctx, fndecl, decl_type, locus);\n-    param->accept_vis (compiler);\n-    return compiler.compiled_param;\n-  }\n-\n-  void visit (HIR::IdentifierPattern &pattern) override\n-  {\n-    if (!pattern.is_mut ())\n-      decl_type = ctx->get_backend ()->immutable_type (decl_type);\n-\n-    compiled_param\n-      = ctx->get_backend ()->parameter_variable (fndecl,\n-\t\t\t\t\t\t pattern.get_identifier (),\n-\t\t\t\t\t\t decl_type, locus);\n-  }\n-\n-  void visit (HIR::WildcardPattern &pattern) override\n-  {\n-    decl_type = ctx->get_backend ()->immutable_type (decl_type);\n-\n-    compiled_param\n-      = ctx->get_backend ()->parameter_variable (fndecl, \"_\", decl_type, locus);\n-  }\n+\t\t\t     tree decl_type, Location locus);\n \n+  void visit (HIR::IdentifierPattern &pattern) override;\n+  void visit (HIR::WildcardPattern &pattern) override;\n   void visit (HIR::StructPattern &) override;\n   void visit (HIR::TupleStructPattern &) override;\n \n@@ -77,32 +49,19 @@ class CompileFnParam : public HIRCompileBase, public HIR::HIRPatternVisitor\n   void visit (HIR::TuplePattern &) override {}\n \n private:\n-  CompileFnParam (Context *ctx, tree fndecl, tree decl_type, Location locus)\n-    : HIRCompileBase (ctx), fndecl (fndecl), decl_type (decl_type),\n-      locus (locus), compiled_param (ctx->get_backend ()->error_variable ())\n-  {}\n+  CompileFnParam (Context *ctx, tree fndecl, tree decl_type, Location locus);\n \n   tree fndecl;\n   tree decl_type;\n   Location locus;\n   Bvariable *compiled_param;\n };\n \n-class CompileSelfParam : public HIRCompileBase, public HIR::HIRStmtVisitor\n+class CompileSelfParam : private HIRCompileBase\n {\n public:\n   static Bvariable *compile (Context *ctx, tree fndecl, HIR::SelfParam &self,\n-\t\t\t     tree decl_type, Location locus)\n-  {\n-    bool is_immutable\n-      = self.get_self_kind () == HIR::SelfParam::ImplicitSelfKind::IMM\n-\t|| self.get_self_kind () == HIR::SelfParam::ImplicitSelfKind::IMM_REF;\n-    if (is_immutable)\n-      decl_type = ctx->get_backend ()->immutable_type (decl_type);\n-\n-    return ctx->get_backend ()->parameter_variable (fndecl, \"self\", decl_type,\n-\t\t\t\t\t\t    locus);\n-  }\n+\t\t\t     tree decl_type, Location locus);\n };\n \n } // namespace Compile"}, {"sha": "3c12f1040fcb2150de4d1e3e844d378300cc94d8", "filename": "gcc/rust/backend/rust-compile-item.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73e79179486b21b13fd8dcc138f84398ca0306e4/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73e79179486b21b13fd8dcc138f84398ca0306e4/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.h?ref=73e79179486b21b13fd8dcc138f84398ca0306e4", "patch": "@@ -24,7 +24,7 @@\n namespace Rust {\n namespace Compile {\n \n-class CompileItem : public HIRCompileBase, public HIR::HIRStmtVisitor\n+class CompileItem : private HIRCompileBase, protected HIR::HIRStmtVisitor\n {\n protected:\n public:"}, {"sha": "1d8eda1a5774786cfea005b154503c8330c334a0", "filename": "gcc/rust/backend/rust-compile-pattern.cc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73e79179486b21b13fd8dcc138f84398ca0306e4/gcc%2Frust%2Fbackend%2Frust-compile-pattern.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73e79179486b21b13fd8dcc138f84398ca0306e4/gcc%2Frust%2Fbackend%2Frust-compile-pattern.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-pattern.cc?ref=73e79179486b21b13fd8dcc138f84398ca0306e4", "patch": "@@ -18,10 +18,9 @@\n \n #include \"rust-compile-pattern.h\"\n #include \"rust-compile-expr.h\"\n+#include \"rust-compile-resolve-path.h\"\n #include \"rust-constexpr.h\"\n \n-#include \"print-tree.h\"\n-\n namespace Rust {\n namespace Compile {\n "}, {"sha": "4fb3d540257ef55894863d5167ceb0c2d7bb4342", "filename": "gcc/rust/backend/rust-compile-resolve-path.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73e79179486b21b13fd8dcc138f84398ca0306e4/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73e79179486b21b13fd8dcc138f84398ca0306e4/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc?ref=73e79179486b21b13fd8dcc138f84398ca0306e4", "patch": "@@ -24,6 +24,7 @@\n #include \"rust-hir-trait-resolve.h\"\n #include \"rust-hir-path-probe.h\"\n #include \"rust-compile-extern.h\"\n+#include \"rust-constexpr.h\"\n \n namespace Rust {\n namespace Compile {"}, {"sha": "bfb25f12980ef18d9658a28cdfb1bb34db5afdb0", "filename": "gcc/rust/backend/rust-compile-stmt.cc", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73e79179486b21b13fd8dcc138f84398ca0306e4/gcc%2Frust%2Fbackend%2Frust-compile-stmt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73e79179486b21b13fd8dcc138f84398ca0306e4/gcc%2Frust%2Fbackend%2Frust-compile-stmt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-stmt.cc?ref=73e79179486b21b13fd8dcc138f84398ca0306e4", "patch": "@@ -0,0 +1,115 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-compile-stmt.h\"\n+#include \"rust-compile-expr.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+CompileStmt::CompileStmt (Context *ctx)\n+  : HIRCompileBase (ctx), translated (nullptr)\n+{}\n+\n+tree\n+CompileStmt::Compile (HIR::Stmt *stmt, Context *ctx)\n+{\n+  CompileStmt compiler (ctx);\n+  stmt->accept_vis (compiler);\n+  return compiler.translated;\n+}\n+\n+void\n+CompileStmt::visit (HIR::ExprStmtWithBlock &stmt)\n+{\n+  translated = CompileExpr::Compile (stmt.get_expr (), ctx);\n+}\n+\n+void\n+CompileStmt::visit (HIR::ExprStmtWithoutBlock &stmt)\n+{\n+  translated = CompileExpr::Compile (stmt.get_expr (), ctx);\n+}\n+\n+void\n+CompileStmt::visit (HIR::LetStmt &stmt)\n+{\n+  // nothing to do\n+  if (!stmt.has_init_expr ())\n+    return;\n+\n+  const HIR::Pattern &stmt_pattern = *stmt.get_pattern ();\n+  HirId stmt_id = stmt_pattern.get_pattern_mappings ().get_hirid ();\n+\n+  TyTy::BaseType *ty = nullptr;\n+  if (!ctx->get_tyctx ()->lookup_type (stmt_id, &ty))\n+    {\n+      // FIXME this should be an assertion instead\n+      rust_fatal_error (stmt.get_locus (),\n+\t\t\t\"failed to lookup variable declaration type\");\n+      return;\n+    }\n+\n+  Bvariable *var = nullptr;\n+  if (!ctx->lookup_var_decl (stmt_id, &var))\n+    {\n+      // FIXME this should be an assertion instead and use error mark node\n+      rust_fatal_error (stmt.get_locus (),\n+\t\t\t\"failed to lookup compiled variable declaration\");\n+      return;\n+    }\n+\n+  tree init = CompileExpr::Compile (stmt.get_init_expr (), ctx);\n+  // FIXME use error_mark_node, check that CompileExpr returns error_mark_node\n+  // on failure and make this an assertion\n+  if (init == nullptr)\n+    return;\n+\n+  TyTy::BaseType *actual = nullptr;\n+  bool ok = ctx->get_tyctx ()->lookup_type (\n+    stmt.get_init_expr ()->get_mappings ().get_hirid (), &actual);\n+  rust_assert (ok);\n+  tree stmt_type = TyTyResolveCompile::compile (ctx, ty);\n+\n+  Location lvalue_locus = stmt.get_pattern ()->get_locus ();\n+  Location rvalue_locus = stmt.get_init_expr ()->get_locus ();\n+  TyTy::BaseType *expected = ty;\n+  init = coercion_site (stmt.get_mappings ().get_hirid (), init, actual,\n+\t\t\texpected, lvalue_locus, rvalue_locus);\n+\n+  auto fnctx = ctx->peek_fn ();\n+  if (ty->is_unit ())\n+    {\n+      ctx->add_statement (init);\n+\n+      auto unit_type_init_expr\n+\t= ctx->get_backend ()->constructor_expression (stmt_type, false, {}, -1,\n+\t\t\t\t\t\t       rvalue_locus);\n+      auto s = ctx->get_backend ()->init_statement (fnctx.fndecl, var,\n+\t\t\t\t\t\t    unit_type_init_expr);\n+      ctx->add_statement (s);\n+    }\n+  else\n+    {\n+      auto s = ctx->get_backend ()->init_statement (fnctx.fndecl, var, init);\n+      ctx->add_statement (s);\n+    }\n+}\n+\n+} // namespace Compile\n+} // namespace Rust"}, {"sha": "a0ec8b26667b8af8956265faef200f88a6ea044a", "filename": "gcc/rust/backend/rust-compile-stmt.h", "status": "modified", "additions": 6, "deletions": 82, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73e79179486b21b13fd8dcc138f84398ca0306e4/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73e79179486b21b13fd8dcc138f84398ca0306e4/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h?ref=73e79179486b21b13fd8dcc138f84398ca0306e4", "patch": "@@ -20,94 +20,18 @@\n #define RUST_COMPILE_STMT\n \n #include \"rust-compile-base.h\"\n-#include \"rust-compile-expr.h\"\n \n namespace Rust {\n namespace Compile {\n \n-class CompileStmt : public HIRCompileBase, public HIR::HIRStmtVisitor\n+class CompileStmt : private HIRCompileBase, protected HIR::HIRStmtVisitor\n {\n public:\n-  static tree Compile (HIR::Stmt *stmt, Context *ctx)\n-  {\n-    CompileStmt compiler (ctx);\n-    stmt->accept_vis (compiler);\n-    return compiler.translated;\n-  }\n+  static tree Compile (HIR::Stmt *stmt, Context *ctx);\n \n-  void visit (HIR::ExprStmtWithBlock &stmt) override\n-  {\n-    translated = CompileExpr::Compile (stmt.get_expr (), ctx);\n-  }\n-\n-  void visit (HIR::ExprStmtWithoutBlock &stmt) override\n-  {\n-    translated = CompileExpr::Compile (stmt.get_expr (), ctx);\n-  }\n-\n-  void visit (HIR::LetStmt &stmt) override\n-  {\n-    // nothing to do\n-    if (!stmt.has_init_expr ())\n-      return;\n-\n-    const HIR::Pattern &stmt_pattern = *stmt.get_pattern ();\n-    HirId stmt_id = stmt_pattern.get_pattern_mappings ().get_hirid ();\n-\n-    TyTy::BaseType *ty = nullptr;\n-    if (!ctx->get_tyctx ()->lookup_type (stmt_id, &ty))\n-      {\n-\t// FIXME this should be an assertion instead\n-\trust_fatal_error (stmt.get_locus (),\n-\t\t\t  \"failed to lookup variable declaration type\");\n-\treturn;\n-      }\n-\n-    Bvariable *var = nullptr;\n-    if (!ctx->lookup_var_decl (stmt_id, &var))\n-      {\n-\t// FIXME this should be an assertion instead and use error mark node\n-\trust_fatal_error (stmt.get_locus (),\n-\t\t\t  \"failed to lookup compiled variable declaration\");\n-\treturn;\n-      }\n-\n-    tree init = CompileExpr::Compile (stmt.get_init_expr (), ctx);\n-    // FIXME use error_mark_node, check that CompileExpr returns error_mark_node\n-    // on failure and make this an assertion\n-    if (init == nullptr)\n-      return;\n-\n-    TyTy::BaseType *actual = nullptr;\n-    bool ok = ctx->get_tyctx ()->lookup_type (\n-      stmt.get_init_expr ()->get_mappings ().get_hirid (), &actual);\n-    rust_assert (ok);\n-    tree stmt_type = TyTyResolveCompile::compile (ctx, ty);\n-\n-    Location lvalue_locus = stmt.get_pattern ()->get_locus ();\n-    Location rvalue_locus = stmt.get_init_expr ()->get_locus ();\n-    TyTy::BaseType *expected = ty;\n-    init = coercion_site (stmt.get_mappings ().get_hirid (), init, actual,\n-\t\t\t  expected, lvalue_locus, rvalue_locus);\n-\n-    auto fnctx = ctx->peek_fn ();\n-    if (ty->is_unit ())\n-      {\n-\tctx->add_statement (init);\n-\n-\tauto unit_type_init_expr\n-\t  = ctx->get_backend ()->constructor_expression (stmt_type, false, {},\n-\t\t\t\t\t\t\t -1, rvalue_locus);\n-\tauto s = ctx->get_backend ()->init_statement (fnctx.fndecl, var,\n-\t\t\t\t\t\t      unit_type_init_expr);\n-\tctx->add_statement (s);\n-      }\n-    else\n-      {\n-\tauto s = ctx->get_backend ()->init_statement (fnctx.fndecl, var, init);\n-\tctx->add_statement (s);\n-      }\n-  }\n+  void visit (HIR::ExprStmtWithBlock &stmt) override;\n+  void visit (HIR::ExprStmtWithoutBlock &stmt) override;\n+  void visit (HIR::LetStmt &stmt) override;\n \n   // Empty visit for unused Stmt HIR nodes.\n   void visit (HIR::TupleStruct &) override {}\n@@ -134,7 +58,7 @@ class CompileStmt : public HIRCompileBase, public HIR::HIRStmtVisitor\n   void visit (HIR::EmptyStmt &) override {}\n \n private:\n-  CompileStmt (Context *ctx) : HIRCompileBase (ctx), translated (nullptr) {}\n+  CompileStmt (Context *ctx);\n \n   tree translated;\n };"}, {"sha": "c9a2811f61195c63762fda1d8d294fc44746343d", "filename": "gcc/rust/backend/rust-compile-struct-field-expr.cc", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73e79179486b21b13fd8dcc138f84398ca0306e4/gcc%2Frust%2Fbackend%2Frust-compile-struct-field-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73e79179486b21b13fd8dcc138f84398ca0306e4/gcc%2Frust%2Fbackend%2Frust-compile-struct-field-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-struct-field-expr.cc?ref=73e79179486b21b13fd8dcc138f84398ca0306e4", "patch": "@@ -0,0 +1,81 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-compile-struct-field-expr.h\"\n+#include \"rust-compile-expr.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+CompileStructExprField::CompileStructExprField (Context *ctx)\n+  : HIRCompileBase (ctx), translated (error_mark_node)\n+{}\n+\n+tree\n+CompileStructExprField::Compile (HIR::StructExprField *field, Context *ctx)\n+{\n+  CompileStructExprField compiler (ctx);\n+  switch (field->get_kind ())\n+    {\n+    case HIR::StructExprField::StructExprFieldKind::IDENTIFIER:\n+      compiler.visit (static_cast<HIR::StructExprFieldIdentifier &> (*field));\n+      break;\n+\n+    case HIR::StructExprField::StructExprFieldKind::IDENTIFIER_VALUE:\n+      compiler.visit (\n+\tstatic_cast<HIR::StructExprFieldIdentifierValue &> (*field));\n+      break;\n+\n+    case HIR::StructExprField::StructExprFieldKind::INDEX_VALUE:\n+      compiler.visit (static_cast<HIR::StructExprFieldIndexValue &> (*field));\n+      break;\n+    }\n+  return compiler.translated;\n+}\n+\n+void\n+CompileStructExprField::visit (HIR::StructExprFieldIdentifierValue &field)\n+{\n+  translated = CompileExpr::Compile (field.get_value (), ctx);\n+}\n+\n+void\n+CompileStructExprField::visit (HIR::StructExprFieldIndexValue &field)\n+{\n+  translated = CompileExpr::Compile (field.get_value (), ctx);\n+}\n+\n+void\n+CompileStructExprField::visit (HIR::StructExprFieldIdentifier &field)\n+{\n+  // we can make the field look like a path expr to take advantage of existing\n+  // code\n+\n+  Analysis::NodeMapping mappings_copy1 = field.get_mappings ();\n+  Analysis::NodeMapping mappings_copy2 = field.get_mappings ();\n+\n+  HIR::PathIdentSegment ident_seg (field.get_field_name ());\n+  HIR::PathExprSegment seg (mappings_copy1, ident_seg, field.get_locus (),\n+\t\t\t    HIR::GenericArgs::create_empty ());\n+  HIR::PathInExpression expr (mappings_copy2, {seg}, field.get_locus (), false,\n+\t\t\t      {});\n+  translated = CompileExpr::Compile (&expr, ctx);\n+}\n+\n+} // namespace Compile\n+} // namespace Rust"}, {"sha": "bc5da080dfef0c7c67ab1f4ade3891f04fee3ee5", "filename": "gcc/rust/backend/rust-compile-struct-field-expr.h", "status": "modified", "additions": 7, "deletions": 68, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73e79179486b21b13fd8dcc138f84398ca0306e4/gcc%2Frust%2Fbackend%2Frust-compile-struct-field-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73e79179486b21b13fd8dcc138f84398ca0306e4/gcc%2Frust%2Fbackend%2Frust-compile-struct-field-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-struct-field-expr.h?ref=73e79179486b21b13fd8dcc138f84398ca0306e4", "patch": "@@ -24,79 +24,18 @@\n namespace Rust {\n namespace Compile {\n \n-class CompileStructExprField : public HIRCompileBase,\n-\t\t\t       public HIR::HIRExpressionVisitor\n+class CompileStructExprField : private HIRCompileBase\n {\n public:\n-  static tree Compile (HIR::StructExprField *field, Context *ctx)\n-  {\n-    CompileStructExprField compiler (ctx);\n-    field->accept_vis (compiler);\n-    rust_assert (compiler.translated != nullptr);\n-    return compiler.translated;\n-  }\n+  static tree Compile (HIR::StructExprField *field, Context *ctx);\n \n-  void visit (HIR::StructExprFieldIdentifierValue &field) override;\n-  void visit (HIR::StructExprFieldIndexValue &field) override;\n-  void visit (HIR::StructExprFieldIdentifier &field) override;\n-\n-  // Empty visit for unused Expression HIR nodes.\n-  void visit (HIR::PathInExpression &) override {}\n-  void visit (HIR::QualifiedPathInExpression &) override {}\n-  void visit (HIR::ClosureExprInner &) override {}\n-  void visit (HIR::ClosureExprInnerTyped &) override {}\n-  void visit (HIR::StructExprStruct &) override {}\n-  void visit (HIR::StructExprStructFields &) override {}\n-  void visit (HIR::LiteralExpr &) override {}\n-  void visit (HIR::BorrowExpr &) override {}\n-  void visit (HIR::DereferenceExpr &) override {}\n-  void visit (HIR::ErrorPropagationExpr &) override {}\n-  void visit (HIR::NegationExpr &) override {}\n-  void visit (HIR::ArithmeticOrLogicalExpr &) override {}\n-  void visit (HIR::ComparisonExpr &) override {}\n-  void visit (HIR::LazyBooleanExpr &) override {}\n-  void visit (HIR::TypeCastExpr &) override {}\n-  void visit (HIR::AssignmentExpr &) override {}\n-  void visit (HIR::CompoundAssignmentExpr &) override {}\n-  void visit (HIR::GroupedExpr &) override {}\n-  void visit (HIR::ArrayExpr &) override {}\n-  void visit (HIR::ArrayIndexExpr &) override {}\n-  void visit (HIR::TupleExpr &) override {}\n-  void visit (HIR::TupleIndexExpr &) override {}\n-  void visit (HIR::CallExpr &) override {}\n-  void visit (HIR::MethodCallExpr &) override {}\n-  void visit (HIR::FieldAccessExpr &) override {}\n-  void visit (HIR::BlockExpr &) override {}\n-  void visit (HIR::ContinueExpr &) override {}\n-  void visit (HIR::BreakExpr &) override {}\n-  void visit (HIR::RangeFromToExpr &) override {}\n-  void visit (HIR::RangeFromExpr &) override {}\n-  void visit (HIR::RangeToExpr &) override {}\n-  void visit (HIR::RangeFullExpr &) override {}\n-  void visit (HIR::RangeFromToInclExpr &) override {}\n-  void visit (HIR::RangeToInclExpr &) override {}\n-  void visit (HIR::ReturnExpr &) override {}\n-  void visit (HIR::UnsafeBlockExpr &) override {}\n-  void visit (HIR::LoopExpr &) override {}\n-  void visit (HIR::WhileLoopExpr &) override {}\n-  void visit (HIR::WhileLetLoopExpr &) override {}\n-  void visit (HIR::ForLoopExpr &) override {}\n-  void visit (HIR::IfExpr &) override {}\n-  void visit (HIR::IfExprConseqElse &) override {}\n-  void visit (HIR::IfExprConseqIf &) override {}\n-  void visit (HIR::IfExprConseqIfLet &) override {}\n-  void visit (HIR::IfLetExpr &) override {}\n-  void visit (HIR::IfLetExprConseqElse &) override {}\n-  void visit (HIR::IfLetExprConseqIf &) override {}\n-  void visit (HIR::IfLetExprConseqIfLet &) override {}\n-  void visit (HIR::MatchExpr &) override {}\n-  void visit (HIR::AwaitExpr &) override {}\n-  void visit (HIR::AsyncBlockExpr &) override {}\n+protected:\n+  void visit (HIR::StructExprFieldIdentifierValue &field);\n+  void visit (HIR::StructExprFieldIndexValue &field);\n+  void visit (HIR::StructExprFieldIdentifier &field);\n \n private:\n-  CompileStructExprField (Context *ctx)\n-    : HIRCompileBase (ctx), translated (nullptr)\n-  {}\n+  CompileStructExprField (Context *ctx);\n \n   tree translated;\n };"}, {"sha": "b52fd71bf6b75aaa2154fb56b00665f8a386be27", "filename": "gcc/rust/backend/rust-compile-type.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73e79179486b21b13fd8dcc138f84398ca0306e4/gcc%2Frust%2Fbackend%2Frust-compile-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73e79179486b21b13fd8dcc138f84398ca0306e4/gcc%2Frust%2Fbackend%2Frust-compile-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-type.h?ref=73e79179486b21b13fd8dcc138f84398ca0306e4", "patch": "@@ -24,7 +24,7 @@\n namespace Rust {\n namespace Compile {\n \n-class TyTyResolveCompile : public TyTy::TyConstVisitor\n+class TyTyResolveCompile : protected TyTy::TyConstVisitor\n {\n public:\n   static tree compile (Context *ctx, const TyTy::BaseType *ty,"}, {"sha": "691314483bdc761124fd2db4ddd04ceaefb58e7e", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 5, "deletions": 156, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73e79179486b21b13fd8dcc138f84398ca0306e4/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73e79179486b21b13fd8dcc138f84398ca0306e4/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=73e79179486b21b13fd8dcc138f84398ca0306e4", "patch": "@@ -16,16 +16,17 @@\n // along with GCC; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-#include \"rust-hir-trait-resolve.h\"\n-#include \"rust-hir-path-probe.h\"\n-#include \"rust-hir-type-bounds.h\"\n-#include \"rust-hir-dot-operator.h\"\n #include \"rust-compile.h\"\n #include \"rust-compile-item.h\"\n #include \"rust-compile-implitem.h\"\n #include \"rust-compile-expr.h\"\n #include \"rust-compile-struct-field-expr.h\"\n #include \"rust-compile-stmt.h\"\n+#include \"rust-hir-trait-resolve.h\"\n+#include \"rust-hir-path-probe.h\"\n+#include \"rust-hir-type-bounds.h\"\n+#include \"rust-hir-dot-operator.h\"\n+#include \"rust-compile-block.h\"\n \n namespace Rust {\n namespace Compile {\n@@ -50,158 +51,6 @@ CompileCrate::go ()\n     CompileItem::compile (item.get (), ctx);\n }\n \n-// rust-compile-block.h\n-\n-void\n-CompileBlock::visit (HIR::BlockExpr &expr)\n-{\n-  fncontext fnctx = ctx->peek_fn ();\n-  tree fndecl = fnctx.fndecl;\n-  Location start_location = expr.get_locus ();\n-  Location end_location = expr.get_end_locus ();\n-  auto body_mappings = expr.get_mappings ();\n-\n-  Resolver::Rib *rib = nullptr;\n-  if (!ctx->get_resolver ()->find_name_rib (body_mappings.get_nodeid (), &rib))\n-    {\n-      rust_fatal_error (expr.get_locus (), \"failed to setup locals per block\");\n-      return;\n-    }\n-\n-  std::vector<Bvariable *> locals\n-    = compile_locals_for_block (ctx, *rib, fndecl);\n-\n-  tree enclosing_scope = ctx->peek_enclosing_scope ();\n-  tree new_block = ctx->get_backend ()->block (fndecl, enclosing_scope, locals,\n-\t\t\t\t\t       start_location, end_location);\n-  ctx->push_block (new_block);\n-\n-  for (auto &s : expr.get_statements ())\n-    {\n-      auto compiled_expr = CompileStmt::Compile (s.get (), ctx);\n-      if (compiled_expr != nullptr)\n-\t{\n-\t  tree s = convert_to_void (compiled_expr, ICV_STATEMENT);\n-\t  ctx->add_statement (s);\n-\t}\n-    }\n-\n-  if (expr.has_expr ())\n-    {\n-      // the previous passes will ensure this is a valid return or\n-      // a valid trailing expression\n-      tree compiled_expr = CompileExpr::Compile (expr.expr.get (), ctx);\n-      if (compiled_expr != nullptr)\n-\t{\n-\t  if (result == nullptr)\n-\t    {\n-\t      ctx->add_statement (compiled_expr);\n-\t    }\n-\t  else\n-\t    {\n-\t      tree result_reference = ctx->get_backend ()->var_expression (\n-\t\tresult, expr.get_final_expr ()->get_locus ());\n-\n-\t      tree assignment\n-\t\t= ctx->get_backend ()->assignment_statement (result_reference,\n-\t\t\t\t\t\t\t     compiled_expr,\n-\t\t\t\t\t\t\t     expr.get_locus ());\n-\t      ctx->add_statement (assignment);\n-\t    }\n-\t}\n-    }\n-\n-  ctx->pop_block ();\n-  translated = new_block;\n-}\n-\n-void\n-CompileConditionalBlocks::visit (HIR::IfExpr &expr)\n-{\n-  fncontext fnctx = ctx->peek_fn ();\n-  tree fndecl = fnctx.fndecl;\n-  tree condition_expr = CompileExpr::Compile (expr.get_if_condition (), ctx);\n-  tree then_block = CompileBlock::compile (expr.get_if_block (), ctx, result);\n-\n-  translated\n-    = ctx->get_backend ()->if_statement (fndecl, condition_expr, then_block,\n-\t\t\t\t\t NULL, expr.get_locus ());\n-}\n-\n-void\n-CompileConditionalBlocks::visit (HIR::IfExprConseqElse &expr)\n-{\n-  fncontext fnctx = ctx->peek_fn ();\n-  tree fndecl = fnctx.fndecl;\n-  tree condition_expr = CompileExpr::Compile (expr.get_if_condition (), ctx);\n-  tree then_block = CompileBlock::compile (expr.get_if_block (), ctx, result);\n-  tree else_block = CompileBlock::compile (expr.get_else_block (), ctx, result);\n-\n-  translated\n-    = ctx->get_backend ()->if_statement (fndecl, condition_expr, then_block,\n-\t\t\t\t\t else_block, expr.get_locus ());\n-}\n-\n-void\n-CompileConditionalBlocks::visit (HIR::IfExprConseqIf &expr)\n-{\n-  fncontext fnctx = ctx->peek_fn ();\n-  tree fndecl = fnctx.fndecl;\n-  tree condition_expr = CompileExpr::Compile (expr.get_if_condition (), ctx);\n-  tree then_block = CompileBlock::compile (expr.get_if_block (), ctx, result);\n-\n-  // else block\n-  std::vector<Bvariable *> locals;\n-  Location start_location = expr.get_conseq_if_expr ()->get_locus ();\n-  Location end_location = expr.get_conseq_if_expr ()->get_locus (); // FIXME\n-  tree enclosing_scope = ctx->peek_enclosing_scope ();\n-  tree else_block = ctx->get_backend ()->block (fndecl, enclosing_scope, locals,\n-\t\t\t\t\t\tstart_location, end_location);\n-  ctx->push_block (else_block);\n-\n-  tree else_stmt_decl\n-    = CompileConditionalBlocks::compile (expr.get_conseq_if_expr (), ctx,\n-\t\t\t\t\t result);\n-  ctx->add_statement (else_stmt_decl);\n-\n-  ctx->pop_block ();\n-\n-  translated\n-    = ctx->get_backend ()->if_statement (fndecl, condition_expr, then_block,\n-\t\t\t\t\t else_block, expr.get_locus ());\n-}\n-\n-// rust-compile-struct-field-expr.h\n-\n-void\n-CompileStructExprField::visit (HIR::StructExprFieldIdentifierValue &field)\n-{\n-  translated = CompileExpr::Compile (field.get_value (), ctx);\n-}\n-\n-void\n-CompileStructExprField::visit (HIR::StructExprFieldIndexValue &field)\n-{\n-  translated = CompileExpr::Compile (field.get_value (), ctx);\n-}\n-\n-void\n-CompileStructExprField::visit (HIR::StructExprFieldIdentifier &field)\n-{\n-  // we can make the field look like a path expr to take advantage of existing\n-  // code\n-\n-  Analysis::NodeMapping mappings_copy1 = field.get_mappings ();\n-  Analysis::NodeMapping mappings_copy2 = field.get_mappings ();\n-\n-  HIR::PathIdentSegment ident_seg (field.get_field_name ());\n-  HIR::PathExprSegment seg (mappings_copy1, ident_seg, field.get_locus (),\n-\t\t\t    HIR::GenericArgs::create_empty ());\n-  HIR::PathInExpression expr (mappings_copy2, {seg}, field.get_locus (), false,\n-\t\t\t      {});\n-  translated = CompileExpr::Compile (&expr, ctx);\n-}\n-\n // Shared methods in compilation\n \n tree"}]}