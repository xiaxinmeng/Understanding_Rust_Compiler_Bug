{"sha": "a28fbdbac8af686640ab82d2360d2babce982351", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTI4ZmJkYmFjOGFmNjg2NjQwYWI4MmQyMzYwZDJiYWJjZTk4MjM1MQ==", "commit": {"author": {"name": "Manuel L\u00f3pez-Ib\u00e1\u00f1ez", "email": "manu@gcc.gnu.org", "date": "2009-06-23T16:30:58Z"}, "committer": {"name": "Manuel L\u00f3pez-Ib\u00e1\u00f1ez", "email": "manu@gcc.gnu.org", "date": "2009-06-23T16:30:58Z"}, "message": "directives.c (parse_include): Add location argument.\n\n2009-06-23  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n\nlibcpp/\n\t* directives.c (parse_include): Add location argument. Update all\n\tcalls.\n\t(parse_answer): Likewise.\n\t(do_include_common): Error with exact location.\n\t(parse_assertion): Likewise.\ntestsuite/\n\t* gcc.dg/cpp/empty-include.c: Update column info.\n\t* gcc.dg/cpp/assert2.c: Update column info.\n\nFrom-SVN: r148857", "tree": {"sha": "bd32207e64e5475c4af5e36142b42db92f47401b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bd32207e64e5475c4af5e36142b42db92f47401b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a28fbdbac8af686640ab82d2360d2babce982351", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a28fbdbac8af686640ab82d2360d2babce982351", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a28fbdbac8af686640ab82d2360d2babce982351", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a28fbdbac8af686640ab82d2360d2babce982351/comments", "author": null, "committer": null, "parents": [{"sha": "7eb3f1f7cab7f8ffc75b8010f619a76fba2808c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7eb3f1f7cab7f8ffc75b8010f619a76fba2808c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7eb3f1f7cab7f8ffc75b8010f619a76fba2808c0"}], "stats": {"total": 67, "additions": 46, "deletions": 21}, "files": [{"sha": "1b5915425f7175c5120d2f688990e98f8e0448d0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a28fbdbac8af686640ab82d2360d2babce982351/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a28fbdbac8af686640ab82d2360d2babce982351/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a28fbdbac8af686640ab82d2360d2babce982351", "patch": "@@ -1,3 +1,8 @@\n+2009-06-23  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n+\n+\t* gcc.dg/cpp/empty-include.c: Update column info.\n+\t* gcc.dg/cpp/assert2.c: Update column info.\n+\n 2009-06-23  Jakub Jelinek  <jakub@redhat.com>\n \n \t* g++.dg/ext/builtin-object-size1.C: New test."}, {"sha": "12b11b78ea08be7c5149cd7457c502ba5da83423", "filename": "gcc/testsuite/gcc.dg/cpp/assert2.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a28fbdbac8af686640ab82d2360d2babce982351/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fassert2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a28fbdbac8af686640ab82d2360d2babce982351/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fassert2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fassert2.c?ref=a28fbdbac8af686640ab82d2360d2babce982351", "patch": "@@ -1,24 +1,24 @@\n /* Malformed assertion tests.  */\n /* { dg-do preprocess } */\n-/* { dg-options \"-Wno-deprecated\" } */\n+/* { dg-options \"-fshow-column -Wno-deprecated\" } */\n \n #assert\t\t/* { dg-error \"without predicate\" \"assert w/o predicate\" } */\n-#assert %\t/* { dg-error \"an identifier\" \"assert punctuation\" } */\n-#assert 12\t/* { dg-error \"an identifier\" \"assert number\" } */\n-#assert abc\t/* { dg-error \"missing\" \"assert w/o answer\" } */\n+#assert %\t/* { dg-error \"9:an identifier\" \"assert punctuation\" } */\n+#assert 12\t/* { dg-error \"9:an identifier\" \"assert number\" } */\n+#assert abc\t/* { dg-error \"9:missing\" \"assert w/o answer\" } */\n \n #if #\t\t/* { dg-error \"without predicate\" \"test w/o predicate\" } */\n #endif\n \n-#if #%\t\t/* { dg-error \"an identifier\" \"test punctuation\" } */\n+#if #%\t\t/* { dg-error \"6:an identifier\" \"test punctuation\" } */\n #endif\n \n-#if #12\t\t/* { dg-error \"an identifier\" \"test number\" } */\n+#if #12\t\t/* { dg-error \"6:an identifier\" \"test number\" } */\n #endif\n \n #if #abc\n #error\t\t/* { dg-bogus \"error\" \"test w/o answer\" } */\n #endif\n \n-#if #abc[def]\t/* { dg-error \"is not valid\" \"test with malformed answer\" } */\n+#if #abc[def]\t/* { dg-error \"9:is not valid\" \"test with malformed answer\" } */\n #endif"}, {"sha": "6b6c0753f56c3b1992e449472cd64694f9d00589", "filename": "gcc/testsuite/gcc.dg/cpp/empty-include.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a28fbdbac8af686640ab82d2360d2babce982351/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fempty-include.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a28fbdbac8af686640ab82d2360d2babce982351/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fempty-include.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fempty-include.c?ref=a28fbdbac8af686640ab82d2360d2babce982351", "patch": "@@ -9,5 +9,6 @@\n  */\n \n /* { dg-do preprocess } */\n-#include \"\" /* { dg-error \"empty\" \"error on empty filename in include\" } */\n+/* { dg-options \"-fshow-column\" } */\n+#include \"\" /* { dg-error \"10:empty\" \"error on empty filename in include\" } */\n int x; /* Otherwise we have an empty file and get more errors. */"}, {"sha": "e2171b0fb7b65c41349333a4c77aaed49f2f68c8", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a28fbdbac8af686640ab82d2360d2babce982351/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a28fbdbac8af686640ab82d2360d2babce982351/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=a28fbdbac8af686640ab82d2360d2babce982351", "patch": "@@ -1,3 +1,11 @@\n+2009-06-23  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n+\n+\t* directives.c (parse_include): Add location argument. Update all\n+\tcalls.\n+\t(parse_answer): Likewise.\n+\t(do_include_common): Error with exact location.\n+\t(parse_assertion): Likewise.\n+\n 2009-06-18  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \t* expr.c (num_div_op): Take explicit location."}, {"sha": "23d89259bc9b6b303ecff72c869b678ac81eaf14", "filename": "libcpp/directives.c", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a28fbdbac8af686640ab82d2360d2babce982351/libcpp%2Fdirectives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a28fbdbac8af686640ab82d2360d2babce982351/libcpp%2Fdirectives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fdirectives.c?ref=a28fbdbac8af686640ab82d2360d2babce982351", "patch": "@@ -99,7 +99,8 @@ static void end_directive (cpp_reader *, int);\n static void directive_diagnostics (cpp_reader *, const directive *, int);\n static void run_directive (cpp_reader *, int, const char *, size_t);\n static char *glue_header_name (cpp_reader *);\n-static const char *parse_include (cpp_reader *, int *, const cpp_token ***);\n+static const char *parse_include (cpp_reader *, int *, const cpp_token ***,\n+\t\t\t\t  source_location *);\n static void push_conditional (cpp_reader *, int, int, const cpp_hashnode *);\n static unsigned int read_flag (cpp_reader *, unsigned int);\n static bool strtolinenum (const uchar *, size_t, linenum_type *, bool *);\n@@ -121,7 +122,7 @@ static void do_linemarker (cpp_reader *);\n static const cpp_token *get_token_no_padding (cpp_reader *);\n static const cpp_token *get__Pragma_string (cpp_reader *);\n static void destringize_and_run (cpp_reader *, const cpp_string *);\n-static int parse_answer (cpp_reader *, struct answer **, int);\n+static int parse_answer (cpp_reader *, struct answer **, int, source_location);\n static cpp_hashnode *parse_assertion (cpp_reader *, struct answer **, int);\n static struct answer ** find_answer (cpp_hashnode *, const struct answer *);\n static void handle_assertion (cpp_reader *, const char *, int);\n@@ -683,16 +684,19 @@ glue_header_name (cpp_reader *pfile)\n \n /* Returns the file name of #include, #include_next, #import and\n    #pragma dependency.  The string is malloced and the caller should\n-   free it.  Returns NULL on error.  */\n+   free it.  Returns NULL on error.  LOCATION is the source location\n+   of the file name.  */\n+\n static const char *\n parse_include (cpp_reader *pfile, int *pangle_brackets,\n-\t       const cpp_token ***buf)\n+\t       const cpp_token ***buf, source_location *location)\n {\n   char *fname;\n   const cpp_token *header;\n \n   /* Allow macro expansion.  */\n   header = get_token_no_padding (pfile);\n+  *location = header->src_loc;\n   if (header->type == CPP_STRING || header->type == CPP_HEADER_NAME)\n     {\n       fname = XNEWVEC (char, header->val.str.len - 1);\n@@ -742,12 +746,13 @@ do_include_common (cpp_reader *pfile, enum include_type type)\n   const char *fname;\n   int angle_brackets;\n   const cpp_token **buf = NULL;\n+  source_location location;\n \n   /* Re-enable saving of comments if requested, so that the include\n      callback can dump comments which follow #include.  */\n   pfile->state.save_comments = ! CPP_OPTION (pfile, discard_comments);\n \n-  fname = parse_include (pfile, &angle_brackets, &buf);\n+  fname = parse_include (pfile, &angle_brackets, &buf, &location);\n   if (!fname)\n     {\n       if (buf)\n@@ -757,8 +762,9 @@ do_include_common (cpp_reader *pfile, enum include_type type)\n \n   if (!*fname)\n   {\n-    cpp_error (pfile, CPP_DL_ERROR, \"empty filename in #%s\",\n-               pfile->directive->name);\n+    cpp_error_with_line (pfile, CPP_DL_ERROR, location, 0,\n+\t\t\t \"empty filename in #%s\",\n+\t\t\t pfile->directive->name);\n     XDELETEVEC (fname);\n     if (buf)\n       XDELETEVEC (buf);\n@@ -1478,8 +1484,9 @@ do_pragma_dependency (cpp_reader *pfile)\n {\n   const char *fname;\n   int angle_brackets, ordering;\n+  source_location location;\n \n-  fname = parse_include (pfile, &angle_brackets, NULL);\n+  fname = parse_include (pfile, &angle_brackets, NULL, &location);\n   if (!fname)\n     return;\n \n@@ -1900,9 +1907,11 @@ push_conditional (cpp_reader *pfile, int skip, int type,\n /* Read the tokens of the answer into the macro pool, in a directive\n    of type TYPE.  Only commit the memory if we intend it as permanent\n    storage, i.e. the #assert case.  Returns 0 on success, and sets\n-   ANSWERP to point to the answer.  */\n+   ANSWERP to point to the answer.  PRED_LOC is the location of the\n+   predicate.  */\n static int\n-parse_answer (cpp_reader *pfile, struct answer **answerp, int type)\n+parse_answer (cpp_reader *pfile, struct answer **answerp, int type,\n+\t      source_location pred_loc)\n {\n   const cpp_token *paren;\n   struct answer *answer;\n@@ -1927,7 +1936,8 @@ parse_answer (cpp_reader *pfile, struct answer **answerp, int type)\n       if (type == T_UNASSERT && paren->type == CPP_EOF)\n \treturn 0;\n \n-      cpp_error (pfile, CPP_DL_ERROR, \"missing '(' after predicate\");\n+      cpp_error_with_line (pfile, CPP_DL_ERROR, pred_loc, 0,\n+\t\t\t   \"missing '(' after predicate\");\n       return 1;\n     }\n \n@@ -1991,8 +2001,9 @@ parse_assertion (cpp_reader *pfile, struct answer **answerp, int type)\n   if (predicate->type == CPP_EOF)\n     cpp_error (pfile, CPP_DL_ERROR, \"assertion without predicate\");\n   else if (predicate->type != CPP_NAME)\n-    cpp_error (pfile, CPP_DL_ERROR, \"predicate must be an identifier\");\n-  else if (parse_answer (pfile, answerp, type) == 0)\n+    cpp_error_with_line (pfile, CPP_DL_ERROR, predicate->src_loc, 0,\n+\t\t\t \"predicate must be an identifier\");\n+  else if (parse_answer (pfile, answerp, type, predicate->src_loc) == 0)\n     {\n       unsigned int len = NODE_LEN (predicate->val.node.node);\n       unsigned char *sym = (unsigned char *) alloca (len + 1);"}]}