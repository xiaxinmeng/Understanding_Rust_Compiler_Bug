{"sha": "3454335f03aae7045816c929761fc0ed4b9a148b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQ1NDMzNWYwM2FhZTcwNDU4MTZjOTI5NzYxZmMwZWQ0YjlhMTQ4Yg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-10-06T05:35:38Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-10-06T05:35:38Z"}, "message": "dump.c (DUMP_CHILDREN): Remove.\n\n\t* dump.c (DUMP_CHILDREN): Remove.\n\t(DUMP_BINFO): Adjust.\n\t(struct dump_node_info): Remove dump_children_p.\n\t(queue_and_dump_type): Remove dump_children_p parameter.\n\t(queue): Don't set dump_children_p.\n\t(dump_child): Pass DUMP_NONE, instead of DUMP_CHILDREN, to\n\tqueue_and_dump_index.\n\t(dequeue_and_dump): Unconditionally print children.  Adjust calls\n\tto functions mentioned above.\n\t(dump_node):  Pass DUMP_NONE, instead of DUMP_CHILDREN to queue.\n\nFrom-SVN: r29837", "tree": {"sha": "068c56af62573d2c0ebecdec5d299de556f203ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/068c56af62573d2c0ebecdec5d299de556f203ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3454335f03aae7045816c929761fc0ed4b9a148b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3454335f03aae7045816c929761fc0ed4b9a148b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3454335f03aae7045816c929761fc0ed4b9a148b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3454335f03aae7045816c929761fc0ed4b9a148b/comments", "author": null, "committer": null, "parents": [{"sha": "dca31eb4cc0a2df70b62d1800ac7254d14186e6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dca31eb4cc0a2df70b62d1800ac7254d14186e6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dca31eb4cc0a2df70b62d1800ac7254d14186e6b"}], "stats": {"total": 393, "additions": 146, "deletions": 247}, "files": [{"sha": "c87e517f7df33a4bcc898d7d612df245254bd82e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3454335f03aae7045816c929761fc0ed4b9a148b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3454335f03aae7045816c929761fc0ed4b9a148b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3454335f03aae7045816c929761fc0ed4b9a148b", "patch": "@@ -1,5 +1,16 @@\n 1999-10-05  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* dump.c (DUMP_CHILDREN): Remove.\n+\t(DUMP_BINFO): Adjust.\n+\t(struct dump_node_info): Remove dump_children_p.\n+\t(queue_and_dump_type): Remove dump_children_p parameter.\n+\t(queue): Don't set dump_children_p.\n+\t(dump_child): Pass DUMP_NONE, instead of DUMP_CHILDREN, to\n+\tqueue_and_dump_index.\n+\t(dequeue_and_dump): Unconditionally print children.  Adjust calls\n+\tto functions mentioned above.\n+\t(dump_node):  Pass DUMP_NONE, instead of DUMP_CHILDREN to queue.\n+\t\n \t* ir.texi: Document BIND_EXPR, LOOP_EXPR, and EXIT_EXPR.\n \t* dump.c (dequeue_and_dump): Dump them.\n \t"}, {"sha": "2098d9b8b0f2f61200c907516e8ee444332ed837", "filename": "gcc/cp/dump.c", "status": "modified", "additions": 135, "deletions": 247, "changes": 382, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3454335f03aae7045816c929761fc0ed4b9a148b/gcc%2Fcp%2Fdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3454335f03aae7045816c929761fc0ed4b9a148b/gcc%2Fcp%2Fdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdump.c?ref=3454335f03aae7045816c929761fc0ed4b9a148b", "patch": "@@ -27,17 +27,14 @@ Boston, MA 02111-1307, USA.  */\n \n /* Flags used with queue functions.  */\n #define DUMP_NONE     0\n-#define DUMP_CHILDREN 1\n-#define DUMP_BINFO    2\n+#define DUMP_BINFO    1\n \n /* Information about a node to be dumped.  */\n \n typedef struct dump_node_info\n {\n   /* The index for the node.  */\n   unsigned int index;\n-  /* Nonzero if we should dump the children of the node.  */\n-  unsigned int dump_children_p : 1;\n   /* Nonzero if the node is a binfo.  */\n   unsigned int binfo_p : 1;\n } *dump_node_info_p;\n@@ -78,7 +75,7 @@ typedef struct dump_info\n static unsigned int queue PROTO ((dump_info_p, tree, int));\n static void dump_index PROTO ((dump_info_p, unsigned int));\n static void queue_and_dump_index PROTO ((dump_info_p, const char *, tree, int));\n-static void queue_and_dump_type PROTO ((dump_info_p, tree, int));\n+static void queue_and_dump_type PROTO ((dump_info_p, tree));\n static void dequeue_and_dump PROTO ((dump_info_p));\n static void dump_new_line PROTO ((dump_info_p));\n static void dump_maybe_newline PROTO ((dump_info_p));\n@@ -89,9 +86,8 @@ static void dump_node PROTO ((tree, FILE *));\n static void dump_stmt PROTO ((dump_info_p, tree));\n static void dump_next_stmt PROTO ((dump_info_p, tree));\n \n-/* Add T to the end of the queue of nodes to dump.  If DUMP_CHILDREN_P\n-   is non-zero, then its children should be dumped as well.  Returns\n-   the index assigned to T.  */\n+/* Add T to the end of the queue of nodes to dump.  Returns the index\n+   assigned to T.  */\n \n static unsigned int\n queue (di, t, flags)\n@@ -118,7 +114,6 @@ queue (di, t, flags)\n   /* Create a new entry in the splay-tree.  */\n   dni = (dump_node_info_p) xmalloc (sizeof (struct dump_node_info));\n   dni->index = index;\n-  dni->dump_children_p = ((flags & DUMP_CHILDREN) != 0);\n   dni->binfo_p = ((flags & DUMP_BINFO) != 0);\n   dq->node = splay_tree_insert (di->nodes, (splay_tree_key) t, \n \t\t\t\t(splay_tree_value) dni);\n@@ -181,12 +176,11 @@ queue_and_dump_index (di, field, t, flags)\n /* Dump the type of T.  */\n \n static void\n-queue_and_dump_type (di, t, dump_children_p)\n+queue_and_dump_type (di, t)\n      dump_info_p di;\n      tree t;\n-     int dump_children_p;\n {\n-  queue_and_dump_index (di, \"type\", TREE_TYPE (t), dump_children_p);\n+  queue_and_dump_index (di, \"type\", TREE_TYPE (t), DUMP_NONE);\n }\n \n /* Insert a new line in the dump output, and indent to an appropriate\n@@ -273,7 +267,7 @@ dump_stmt (di, t)\n \n /* Dump the CHILD and its children.  */\n #define dump_child(field, child) \\\n-  queue_and_dump_index (di, field, child, DUMP_CHILDREN)\n+  queue_and_dump_index (di, field, child, DUMP_NONE)\n \n /* Dump the next statement after STMT.  */\n \n@@ -296,7 +290,6 @@ dequeue_and_dump (di)\n   dump_node_info_p dni;\n   tree t;\n   unsigned int index;\n-  int dump_children_p;\n   enum tree_code code;\n   char code_class;\n   const char* code_name;\n@@ -307,7 +300,6 @@ dequeue_and_dump (di)\n   t = (tree) stn->key;\n   dni = (dump_node_info_p) stn->value;\n   index = dni->index;\n-  dump_children_p = dni->dump_children_p;\n \n   /* Remove the node from the queue, and put it on the free list.  */\n   di->queue = dq->next;\n@@ -343,11 +335,8 @@ dequeue_and_dump (di)\n       if (TREE_VIA_VIRTUAL (t))\n \tdump_string (di, \"virt\");\n \t    \n-      if (dump_children_p) \n-\t{\n-\t  dump_child (\"type\", BINFO_TYPE (t));\n-\t  dump_child (\"base\", BINFO_BASETYPES (t));\n-\t}\n+      dump_child (\"type\", BINFO_TYPE (t));\n+      dump_child (\"base\", BINFO_BASETYPES (t));\n \n       goto done;\n     }\n@@ -357,29 +346,26 @@ dequeue_and_dump (di)\n   if (IS_EXPR_CODE_CLASS (code_class))\n     {\n       /* If we're dumping children, dump them now.  */\n-      if (dump_children_p)\n-\t{\n-\t  queue_and_dump_type (di, t, 1);\n+      queue_and_dump_type (di, t);\n \n-\t  switch (code_class)\n-\t    {\n-\t    case '1':\n-\t      dump_child (\"op 0\", TREE_OPERAND (t, 0));\n-\t      break;\n+      switch (code_class)\n+\t{\n+\tcase '1':\n+\t  dump_child (\"op 0\", TREE_OPERAND (t, 0));\n+\t  break;\n \t      \n-\t    case '2':\n-\t    case '<':\n-\t      dump_child (\"op 0\", TREE_OPERAND (t, 0));\n-\t      dump_child (\"op 1\", TREE_OPERAND (t, 1));\n-\t      break;\n+\tcase '2':\n+\tcase '<':\n+\t  dump_child (\"op 0\", TREE_OPERAND (t, 0));\n+\t  dump_child (\"op 1\", TREE_OPERAND (t, 1));\n+\t  break;\n \t      \n-\t    case 'e':\n-\t      /* These nodes are handled explicitly below.  */\n-\t      break;\n+\tcase 'e':\n+\t  /* These nodes are handled explicitly below.  */\n+\t  break;\n \t      \n-\t    default:\n-\t      my_friendly_abort (19990726);\n-\t    }\n+\tdefault:\n+\t  my_friendly_abort (19990726);\n \t}\n     }\n   else if (code_class == 'd')\n@@ -388,11 +374,8 @@ dequeue_and_dump (di)\n       if (DECL_NAME (t))\n \tdump_child (\"name\", DECL_NAME (t));\n       /* And types.  */\n-      if (dump_children_p)\n-\t{\n-\t  queue_and_dump_type (di, t, 1);\n-\t  queue_and_dump_index (di, \"scpe\", DECL_CONTEXT (t), 0);\n-\t}\n+      queue_and_dump_type (di, t);\n+      queue_and_dump_index (di, \"scpe\", DECL_CONTEXT (t), 0);\n       /* And a source position.  */\n       if (DECL_SOURCE_FILE (t))\n \t{\n@@ -430,22 +413,19 @@ dequeue_and_dump (di)\n       /* All types have associated declarations.  */\n       dump_child (\"name\", TYPE_NAME (t));\n \n-      if (dump_children_p)\n-\t{\n-\t  /* All types have a main variant.  */\n-\t  if (TYPE_MAIN_VARIANT (t) != t)\n-\t    dump_child (\"unql\", TYPE_MAIN_VARIANT (t));\n+      /* All types have a main variant.  */\n+      if (TYPE_MAIN_VARIANT (t) != t)\n+\tdump_child (\"unql\", TYPE_MAIN_VARIANT (t));\n       \n-\t  /* And sizes.  */\n-\t  dump_child (\"size\", TYPE_SIZE (t));\n-\t}\n+      /* And sizes.  */\n+      dump_child (\"size\", TYPE_SIZE (t));\n \n       /* All types have alignments.  */\n       dump_int (di, \"algn\", TYPE_ALIGN (t));\n     }\n-  else if (code_class == 'c' && dump_children_p)\n+  else if (code_class == 'c')\n     /* All constants can have types.  */\n-    queue_and_dump_type (di, t, 1);\n+    queue_and_dump_type (di, t);\n \n   /* Now handle the various kinds of nodes.  */\n   switch (code)\n@@ -467,37 +447,30 @@ dequeue_and_dump (di)\n       break;\n \n     case TREE_LIST:\n-      if (dump_children_p)\n-\t{\n-\t  dump_child (\"purp\", TREE_PURPOSE (t));\n-\t  dump_child (\"valu\", TREE_VALUE (t));\n-\t  dump_child (\"chan\", TREE_CHAIN (t));\n-\t}\n+      dump_child (\"purp\", TREE_PURPOSE (t));\n+      dump_child (\"valu\", TREE_VALUE (t));\n+      dump_child (\"chan\", TREE_CHAIN (t));\n       break;\n \n     case TREE_VEC:\n       dump_int (di, \"lngt\", IDENTIFIER_LENGTH (t));\n-      if (dump_children_p)\n-\tfor (i = 0; i < TREE_VEC_LENGTH (t); ++i)\n-\t  {\n-\t    char buffer[32];\n-\t    sprintf (buffer, \"%u\", i);\n-\t    queue_and_dump_index (di, buffer, TREE_VEC_ELT (t, i), 1);\n-\t  }\n+      for (i = 0; i < TREE_VEC_LENGTH (t); ++i)\n+\t{\n+\t  char buffer[32];\n+\t  sprintf (buffer, \"%u\", i);\n+\t  queue_and_dump_index (di, buffer, TREE_VEC_ELT (t, i), 1);\n+\t}\n       break;\n \n     case INTEGER_TYPE:\n     case ENUMERAL_TYPE:\n       dump_int (di, \"prec\", TYPE_PRECISION (t));\n       if (TREE_UNSIGNED (t))\n \tdump_string (di, \"unsigned\");\n-      if (dump_children_p)\n-\t{\n-\t  dump_child (\"min\", TYPE_MIN_VALUE (t));\n-\t  dump_child (\"max\", TYPE_MAX_VALUE (t));\n-\t}\n+      dump_child (\"min\", TYPE_MIN_VALUE (t));\n+      dump_child (\"max\", TYPE_MAX_VALUE (t));\n \n-      if (code == ENUMERAL_TYPE && dump_children_p)\n+      if (code == ENUMERAL_TYPE)\n \tdump_child (\"csts\", TYPE_VALUES (t));\n       break;\n \n@@ -506,45 +479,34 @@ dequeue_and_dump (di)\n       break;\n \n     case POINTER_TYPE:\n-      if (dump_children_p)\n+      if (TYPE_PTRMEM_P (t))\n \t{\n-\t  if (TYPE_PTRMEM_P (t))\n-\t    {\n-\t      dump_string (di, \"ptrmem\");\n-\t      queue_and_dump_index (di, \"ptd\", \n-\t\t\t\t    TYPE_PTRMEM_POINTED_TO_TYPE (t), 1);\n-\t      queue_and_dump_index (di, \"cls\", \n-\t\t\t\t    TYPE_PTRMEM_CLASS_TYPE (t), 1);\n-\t    }\n-\t  else\n-\t    dump_child (\"ptd\", TREE_TYPE (t));\n+\t  dump_string (di, \"ptrmem\");\n+\t  queue_and_dump_index (di, \"ptd\", \n+\t\t\t\tTYPE_PTRMEM_POINTED_TO_TYPE (t), 1);\n+\t  queue_and_dump_index (di, \"cls\", \n+\t\t\t\tTYPE_PTRMEM_CLASS_TYPE (t), 1);\n \t}\n+      else\n+\tdump_child (\"ptd\", TREE_TYPE (t));\n       break;\n \n     case REFERENCE_TYPE:\n-      if (dump_children_p)\n-\tdump_child (\"refd\", TREE_TYPE (t));\n+      dump_child (\"refd\", TREE_TYPE (t));\n       break;\n \n     case METHOD_TYPE:\n-      if (dump_children_p)\n-\tdump_child (\"clas\", TYPE_METHOD_BASETYPE (t));\n+      dump_child (\"clas\", TYPE_METHOD_BASETYPE (t));\n       /* Fall through.  */\n \n     case FUNCTION_TYPE:\n-      if (dump_children_p)\n-\t{\n-\t  dump_child (\"retn\", TREE_TYPE (t));\n-\t  dump_child (\"prms\", TYPE_ARG_TYPES (t));\n-\t}\n+      dump_child (\"retn\", TREE_TYPE (t));\n+      dump_child (\"prms\", TYPE_ARG_TYPES (t));\n       break;\n \n     case ARRAY_TYPE:\n-      if (dump_children_p)\n-\t{\n-\t  dump_child (\"elts\", TREE_TYPE (t));\n-\t  dump_child (\"domn\", TYPE_DOMAIN (t));\n-\t}\n+      dump_child (\"elts\", TREE_TYPE (t));\n+      dump_child (\"domn\", TYPE_DOMAIN (t));\n       break;\n \n     case RECORD_TYPE:\n@@ -566,36 +528,29 @@ dequeue_and_dump (di)\n \t  else\n \t    dump_string (di, \"union\");\n \n-\t  if (dump_children_p)\n-\t    {\n-\t      dump_child (\"flds\", TYPE_FIELDS (t));\n-\t      dump_child (\"fncs\", TYPE_METHODS (t));\n-\t      queue_and_dump_index (di, \"binf\", TYPE_BINFO (t), \n-\t\t\t\t    DUMP_CHILDREN | DUMP_BINFO);\n-\t    }\n+\t  dump_child (\"flds\", TYPE_FIELDS (t));\n+\t  dump_child (\"fncs\", TYPE_METHODS (t));\n+\t  queue_and_dump_index (di, \"binf\", TYPE_BINFO (t), \n+\t\t\t\tDUMP_BINFO);\n \t}\n       break;\n \n     case CONST_DECL:\n-      if (dump_children_p)\n-\tdump_child (\"cnst\", DECL_INITIAL (t));\n+      dump_child (\"cnst\", DECL_INITIAL (t));\n       break;\n \n     case VAR_DECL:\n     case PARM_DECL:\n     case FIELD_DECL:\n     case RESULT_DECL:\n-      if (dump_children_p)\n-\t{\n-\t  if (TREE_CODE (t) == PARM_DECL)\n-\t    dump_child (\"argt\", DECL_ARG_TYPE (t));\n-\t  else\n-\t    dump_child (\"init\", DECL_INITIAL (t));\n-\t  dump_child (\"size\", DECL_SIZE (t));\n-\t}\n+      if (TREE_CODE (t) == PARM_DECL)\n+\tdump_child (\"argt\", DECL_ARG_TYPE (t));\n+      else\n+\tdump_child (\"init\", DECL_INITIAL (t));\n+      dump_child (\"size\", DECL_SIZE (t));\n       dump_int (di, \"algn\", DECL_ALIGN (t));\n \n-      if (TREE_CODE (t) == FIELD_DECL && dump_children_p)\n+      if (TREE_CODE (t) == FIELD_DECL)\n \t{\n \t  if (DECL_C_BIT_FIELD (t))\n \t    dump_string (di, \"bitfield\");\n@@ -605,12 +560,9 @@ dequeue_and_dump (di)\n \n     case FUNCTION_DECL:\n     case THUNK_DECL:\n-      if (dump_children_p)\n-\t{\n-\t  queue_and_dump_index (di, \"scpe\", DECL_REAL_CONTEXT (t), 0);\n-\t  dump_child (\"mngl\", DECL_ASSEMBLER_NAME (t));\n-\t  dump_child (\"args\", DECL_ARGUMENTS (t));\n-\t}\n+      queue_and_dump_index (di, \"scpe\", DECL_REAL_CONTEXT (t), 0);\n+      dump_child (\"mngl\", DECL_ASSEMBLER_NAME (t));\n+      dump_child (\"args\", DECL_ARGUMENTS (t));\n       if (DECL_EXTERNAL (t))\n \tdump_string (di, \"undefined\");\n       if (TREE_PUBLIC (t))\n@@ -638,8 +590,7 @@ dequeue_and_dump (di)\n \t      dump_int (di, \"prio\", GLOBAL_INIT_PRIORITY (t));\n \t    }\n \n-\t  if (dump_children_p)\n-\t    dump_child (\"body\", DECL_SAVED_TREE (t));\n+\t  dump_child (\"body\", DECL_SAVED_TREE (t));\n \t}\n       else\n \t{\n@@ -653,34 +604,26 @@ dequeue_and_dump (di)\n \t and therefore many other macros do not work on it.  */\n       if (t == std_node)\n \tbreak;\n-      if (dump_children_p)\n-\tdump_child (\"dcls\", cp_namespace_decls (t));\n+      dump_child (\"dcls\", cp_namespace_decls (t));\n       break;\n \n     case TEMPLATE_DECL:\n-      if (dump_children_p)\n-\tdump_child (\"spcs\", DECL_TEMPLATE_SPECIALIZATIONS (t));\n+      dump_child (\"spcs\", DECL_TEMPLATE_SPECIALIZATIONS (t));\n       break;\n \n     case OVERLOAD:\n-      if (dump_children_p)\n-\t{\n-\t  dump_child (\"crnt\", OVL_CURRENT (t));\n-\t  dump_child (\"chan\", OVL_CHAIN (t));\n-\t}\n+      dump_child (\"crnt\", OVL_CURRENT (t));\n+      dump_child (\"chan\", OVL_CHAIN (t));\n       break;\n \n     case ASM_STMT:\n       dump_stmt (di, t);\n       if (ASM_VOLATILE_P (t))\n \tdump_string (di, \"volatile\");\n-      if (dump_children_p)\n-\t{\n-\t  dump_child (\"strg\", ASM_STRING (t));\n-\t  dump_child (\"outs\", ASM_OUTPUTS (t));\n-\t  dump_child (\"ins\", ASM_INPUTS (t));\n-\t  dump_child (\"clbr\", ASM_CLOBBERS (t));\n-\t}\n+      dump_child (\"strg\", ASM_STRING (t));\n+      dump_child (\"outs\", ASM_OUTPUTS (t));\n+      dump_child (\"ins\", ASM_INPUTS (t));\n+      dump_child (\"clbr\", ASM_CLOBBERS (t));\n       dump_next_stmt (di, t);\n       break;\n \n@@ -693,140 +636,108 @@ dequeue_and_dump (di)\n     case CASE_LABEL:\n       /* Note that a case label is not like other statments; there is\n \t no way to get the line-number of a case label.  */\n-      if (dump_children_p)\n-\t{\n-\t  dump_child (\"low\", CASE_LOW (t));\n-\t  dump_child (\"high\", CASE_HIGH (t));\n-\t}\n+      dump_child (\"low\", CASE_LOW (t));\n+      dump_child (\"high\", CASE_HIGH (t));\n       dump_next_stmt (di, t);\n       break;\n \n     case COMPOUND_STMT:\n       dump_stmt (di, t);\n-      if (dump_children_p)\n-\tdump_child (\"body\", COMPOUND_BODY (t));\n+      dump_child (\"body\", COMPOUND_BODY (t));\n       dump_next_stmt (di, t);\n       break;\n \n     case DECL_STMT:\n       dump_stmt (di, t);\n-      if (dump_children_p)\n-\tdump_child (\"decl\", DECL_STMT_DECL (t));\n+      dump_child (\"decl\", DECL_STMT_DECL (t));\n       dump_next_stmt (di, t);\n       break;\n       \n     case DO_STMT:\n       dump_stmt (di, t);\n-      if (dump_children_p)\n-\t{\n-\t  dump_child (\"body\", DO_BODY (t));\n-\t  dump_child (\"cond\", DO_COND (t));\n-\t}\n+      dump_child (\"body\", DO_BODY (t));\n+      dump_child (\"cond\", DO_COND (t));\n       dump_next_stmt (di, t);\n       break;\n \n     case EXPR_STMT:\n       dump_stmt (di, t);\n-      if (dump_children_p)\n-\tdump_child (\"expr\", EXPR_STMT_EXPR (t));\n+      dump_child (\"expr\", EXPR_STMT_EXPR (t));\n       dump_next_stmt (di, t);\n       break;\n \n     case FOR_STMT:\n       dump_stmt (di, t);\n-      if (dump_children_p)\n-\t{\n-\t  dump_child (\"init\", FOR_INIT_STMT (t));\n-\t  dump_child (\"cond\", FOR_COND (t));\n-\t  dump_child (\"expr\", FOR_EXPR (t));\n-\t  dump_child (\"body\", FOR_BODY (t));\n-\t}\n+      dump_child (\"init\", FOR_INIT_STMT (t));\n+      dump_child (\"cond\", FOR_COND (t));\n+      dump_child (\"expr\", FOR_EXPR (t));\n+      dump_child (\"body\", FOR_BODY (t));\n       dump_next_stmt (di, t);\n       break;\n \n     case GOTO_STMT:\n       dump_stmt (di, t);\n-      if (dump_children_p)\n-\tdump_child (\"dest\", GOTO_DESTINATION (t));\n+      dump_child (\"dest\", GOTO_DESTINATION (t));\n       dump_next_stmt (di, t);\n       break;\n \n     case IF_STMT:\n       dump_stmt (di, t);\n-      if (dump_children_p)\n-\t{\n-\t  dump_child (\"cond\", IF_COND (t));\n-\t  dump_child (\"then\", THEN_CLAUSE (t));\n-\t  dump_child (\"else\", ELSE_CLAUSE (t));\n-\t}\n+      dump_child (\"cond\", IF_COND (t));\n+      dump_child (\"then\", THEN_CLAUSE (t));\n+      dump_child (\"else\", ELSE_CLAUSE (t));\n       dump_next_stmt (di, t);\n       break;\n \n     case LABEL_STMT:\n       dump_stmt (di, t);\n-      if (dump_children_p)\n-\tdump_child (\"labl\", LABEL_STMT_LABEL (t));\n+      dump_child (\"labl\", LABEL_STMT_LABEL (t));\n       dump_next_stmt (di, t);\n       break;\n \n     case RETURN_STMT:\n       dump_stmt (di, t);\n-      if (dump_children_p)\n-\tdump_child (\"expr\", RETURN_EXPR (t));\n+      dump_child (\"expr\", RETURN_EXPR (t));\n       dump_next_stmt (di, t);\n       break;\n \n     case SWITCH_STMT:\n       dump_stmt (di, t);\n-      if (dump_children_p)\n-\t{\n-\t  dump_child (\"cond\", SWITCH_COND (t));\n-\t  dump_child (\"body\", SWITCH_BODY (t));\n-\t}\n+      dump_child (\"cond\", SWITCH_COND (t));\n+      dump_child (\"body\", SWITCH_BODY (t));\n       dump_next_stmt (di, t);\n       break;\n \n     case TRY_BLOCK:\n       dump_stmt (di, t);\n-      if (dump_children_p)\n-\t{\n-\t  dump_child (\"body\", TRY_STMTS (t));\n-\t  dump_child (\"hdlr\", TRY_HANDLERS (t));\n-\t}\n+      dump_child (\"body\", TRY_STMTS (t));\n+      dump_child (\"hdlr\", TRY_HANDLERS (t));\n       dump_next_stmt (di, t);\n       break;\n \n     case WHILE_STMT:\n       dump_stmt (di, t);\n-      if (dump_children_p)\n-\t{\n-\t  dump_child (\"cond\", WHILE_COND (t));\n-\t  dump_child (\"body\", WHILE_BODY (t));\n-\t}\n+      dump_child (\"cond\", WHILE_COND (t));\n+      dump_child (\"body\", WHILE_BODY (t));\n       dump_next_stmt (di, t);\n       break;\n \n     case SUBOBJECT:\n       dump_stmt (di, t);\n-      if (dump_children_p)\n-\tdump_child (\"clnp\", TREE_OPERAND (t, 0));\n+      dump_child (\"clnp\", TREE_OPERAND (t, 0));\n       dump_next_stmt (di, t);\n       break;\n \n     case START_CATCH_STMT:\n       dump_stmt (di, t);\n-      if (dump_children_p)\n-\tqueue_and_dump_type (di, TREE_TYPE (t), /*dump_children_p=*/1);\n+      queue_and_dump_type (di, TREE_TYPE (t));\n       dump_next_stmt (di, t);\n       break;\n \n     case CLEANUP_STMT:\n       dump_stmt (di, t);\n-      if (dump_children_p)\n-\t{\n-\t  dump_child (\"decl\", CLEANUP_DECL (t));\n-\t  dump_child (\"expr\", CLEANUP_EXPR (t));\n-\t}\n+      dump_child (\"decl\", CLEANUP_DECL (t));\n+      dump_child (\"expr\", CLEANUP_EXPR (t));\n       dump_next_stmt (di, t);\n       break;\n \n@@ -853,20 +764,16 @@ dequeue_and_dump (di)\n       break;\n \n     case PTRMEM_CST:\n-      if (dump_children_p)\n-\t{\n-\t  dump_child (\"clas\", PTRMEM_CST_CLASS (t));\n-\t  dump_child (\"mbr\", PTRMEM_CST_MEMBER (t));\n-\t}\n+      dump_child (\"clas\", PTRMEM_CST_CLASS (t));\n+      dump_child (\"mbr\", PTRMEM_CST_MEMBER (t));\n       break;\n \n     case TRUTH_NOT_EXPR:\n     case ADDR_EXPR:\n     case INDIRECT_REF:\n     case THROW_EXPR:\n       /* These nodes are unary, but do not have code class `1'.  */\n-      if (dump_children_p)\n-\tdump_child (\"op 0\", TREE_OPERAND (t, 0));\n+      dump_child (\"op 0\", TREE_OPERAND (t, 0));\n       break;\n \n     case TRUTH_ANDIF_EXPR:\n@@ -878,71 +785,52 @@ dequeue_and_dump (di)\n     case COND_EXPR:\n     case ARRAY_REF:\n       /* These nodes are binary, but do not have code class `2'.  */\n-      if (dump_children_p)\n-\t{\n-\t  dump_child (\"op 0\", TREE_OPERAND (t, 0));\n-\t  dump_child (\"op 1\", TREE_OPERAND (t, 1));\n-\t}\n+      dump_child (\"op 0\", TREE_OPERAND (t, 0));\n+      dump_child (\"op 1\", TREE_OPERAND (t, 1));\n       break;\n \n     case CALL_EXPR:\n-      if (dump_children_p)\n-\t{\n-\t  dump_child (\"fn\", TREE_OPERAND (t, 0));\n-\t  dump_child (\"args\", TREE_OPERAND (t, 1));\n-\t}\n+      dump_child (\"fn\", TREE_OPERAND (t, 0));\n+      dump_child (\"args\", TREE_OPERAND (t, 1));\n       break;\n \n     case CONSTRUCTOR:\n-      if (dump_children_p)\n-\tdump_child (\"elts\", TREE_OPERAND (t, 1));\n+      dump_child (\"elts\", TREE_OPERAND (t, 1));\n       break;\n \n     case STMT_EXPR:\n-      if (dump_children_p)\n-\tdump_child (\"stmt\", STMT_EXPR_STMT (t));\n+      dump_child (\"stmt\", STMT_EXPR_STMT (t));\n       break;\n \n     case BIND_EXPR:\n-      if (dump_children_p)\n-\t{\n-\t  dump_child (\"vars\", TREE_OPERAND (t, 0));\n-\t  dump_child (\"body\", TREE_OPERAND (t, 1));\n-\t}\n+      dump_child (\"vars\", TREE_OPERAND (t, 0));\n+      dump_child (\"body\", TREE_OPERAND (t, 1));\n       break;\n \n     case LOOP_EXPR:\n-      if (dump_children_p)\n-\tdump_child (\"body\", TREE_OPERAND (t, 0));\n+      dump_child (\"body\", TREE_OPERAND (t, 0));\n       break;\n \n     case EXIT_EXPR:\n-      if (dump_children_p)\n-\tdump_child (\"cond\", TREE_OPERAND (t, 0));\n+      dump_child (\"cond\", TREE_OPERAND (t, 0));\n       break;\n \n     case TARGET_EXPR:\n-      if (dump_children_p)\n-\t{\n-\t  dump_child (\"decl\", TREE_OPERAND (t, 0));\n-\t  dump_child (\"init\", TREE_OPERAND (t, 1));\n-\t  dump_child (\"clnp\", TREE_OPERAND (t, 2));\n-\t  /* There really are two possible places the initializer can\n-\t     be.  After RTL expansion, the second operand is moved to\n-\t     the position of the fourth operand, and the second\n-\t     operand becomes NULL.  */\n-\t  dump_child (\"init\", TREE_OPERAND (t, 3));\n-\t}\n+      dump_child (\"decl\", TREE_OPERAND (t, 0));\n+      dump_child (\"init\", TREE_OPERAND (t, 1));\n+      dump_child (\"clnp\", TREE_OPERAND (t, 2));\n+      /* There really are two possible places the initializer can be.\n+\t After RTL expansion, the second operand is moved to the\n+\t position of the fourth operand, and the second operand\n+\t becomes NULL.  */\n+      dump_child (\"init\", TREE_OPERAND (t, 3));\n       break;\n       \n     case AGGR_INIT_EXPR:\n       dump_int (di, \"ctor\", AGGR_INIT_VIA_CTOR_P (t));\n-      if (dump_children_p)\n-\t{\n-\t  dump_child (\"fn\", TREE_OPERAND (t, 0));\n-\t  dump_child (\"args\", TREE_OPERAND (t, 1));\n-\t  dump_child (\"decl\", TREE_OPERAND (t, 2));\n-\t}\n+      dump_child (\"fn\", TREE_OPERAND (t, 0));\n+      dump_child (\"args\", TREE_OPERAND (t, 1));\n+      dump_child (\"decl\", TREE_OPERAND (t, 2));\n       break;\n \n     default:\n@@ -977,7 +865,7 @@ dump_node (t, stream)\n \t\t\t     (splay_tree_delete_value_fn) &free);\n \n   /* Queue up the first node.  */\n-  queue (&di, t, DUMP_CHILDREN);\n+  queue (&di, t, DUMP_NONE);\n \n   /* Until the queue is empty, keep dumping nodes.  */\n   while (di.queue)"}]}