{"sha": "af74bfeee1faccef25dc0086d4249eb0f127c820", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWY3NGJmZWVlMWZhY2NlZjI1ZGMwMDg2ZDQyNDllYjBmMTI3YzgyMA==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2019-10-18T19:03:50Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2019-10-18T19:03:50Z"}, "message": "[arm] Handle some constant comparisons using rsbs+rscs\n\nIn a small number of cases it is preferable to handle comparisons with\nconstants using the sequence\n\n\tRSBS\ttmp, Xlo, constlo\n\tRSCS\ttmp, Xhi, consthi\n\nwhich allows us to handle a small number of LE/GT/LEU/GEU cases when\nchanging the code to use LT/GE/LTU/GEU would make the constant more\nexpensive.  Sadly, we cannot do this on Thumb, since we need RSC, so we\nnow always use the incremented constant in that case since normally that\nstill works out cheaper than forcing the entire constant into a register.\n\nFurther investigation has also shown that the canonicalization of a\nreverse subtract and compare is valid for signed as well as unsigned value,\nso we relax the restriction on selecting CC_RSBmode to allow all types\nof compare.\n\n\t* config/arm/arm.c (arm_const_double_prefer_rsbs_rsc): New function.\n\t(arm_canonicalize_comparison): For GT/LE/GTU/GEU, use the constant\n\tunchanged only if that will be cheaper.\n\t(arm_select_cc_mode): Recognize a swapped comparison that will\n\tbe regenerated using RSBS or RSCS.  Relax restriction on selecting\n\tCC_RSBmode.\n\t(arm_gen_dicompare_reg): Handle LE/GT/LEU/GEU comparisons against\n\ta constant.\n\t(arm_gen_compare_reg): Handle compare (CONST, X) when the mode\n\tis CC_RSBmode.\n\t(maybe_get_arm_condition_code): CC_RSBmode now returns the same codes\n\tas CCmode.\n\t* config/arm/arm.md (rsb_imm_compare_scratch): New pattern.\n\t(rscsi3_<CC_EXTEND>out_scratch): New pattern.\n\nFrom-SVN: r277180", "tree": {"sha": "e038f765785dd4e3aa0e7cbc4f11f1e69e7488eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e038f765785dd4e3aa0e7cbc4f11f1e69e7488eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af74bfeee1faccef25dc0086d4249eb0f127c820", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af74bfeee1faccef25dc0086d4249eb0f127c820", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af74bfeee1faccef25dc0086d4249eb0f127c820", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af74bfeee1faccef25dc0086d4249eb0f127c820/comments", "author": null, "committer": null, "parents": [{"sha": "8b8ab8f473b42933b9c1e292c4b1ab02adf1863a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b8ab8f473b42933b9c1e292c4b1ab02adf1863a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b8ab8f473b42933b9c1e292c4b1ab02adf1863a"}], "stats": {"total": 197, "additions": 151, "deletions": 46}, "files": [{"sha": "b4b18113fbd4d9ae94da99aa00cf93c603505ad5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af74bfeee1faccef25dc0086d4249eb0f127c820/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af74bfeee1faccef25dc0086d4249eb0f127c820/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=af74bfeee1faccef25dc0086d4249eb0f127c820", "patch": "@@ -1,3 +1,20 @@\n+2019-10-18  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* config/arm/arm.c (arm_const_double_prefer_rsbs_rsc): New function.\n+\t(arm_canonicalize_comparison): For GT/LE/GTU/GEU, use the constant\n+\tunchanged only if that will be cheaper.\n+\t(arm_select_cc_mode): Recognize a swapped comparison that will\n+\tbe regenerated using RSBS or RSCS.  Relax restriction on selecting\n+\tCC_RSBmode.\n+\t(arm_gen_dicompare_reg): Handle LE/GT/LEU/GEU comparisons against\n+\ta constant.\n+\t(arm_gen_compare_reg): Handle compare (CONST, X) when the mode\n+\tis CC_RSBmode.\n+\t(maybe_get_arm_condition_code): CC_RSBmode now returns the same codes\n+\tas CCmode.\n+\t* config/arm/arm.md (rsb_imm_compare_scratch): New pattern.\n+\t(rscsi3_<CC_EXTEND>out_scratch): New pattern.\n+\n 2019-10-18  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* config/arm/arm-modes.def (CC_NV, CC_B): New CC modes."}, {"sha": "55fd16df67886a05e73bd92369ac05cca49d7666", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 107, "deletions": 46, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af74bfeee1faccef25dc0086d4249eb0f127c820/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af74bfeee1faccef25dc0086d4249eb0f127c820/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=af74bfeee1faccef25dc0086d4249eb0f127c820", "patch": "@@ -5355,6 +5355,21 @@ arm_gen_constant (enum rtx_code code, machine_mode mode, rtx cond,\n   return insns;\n }\n \n+/* Return TRUE if op is a constant where both the low and top words are\n+   suitable for RSB/RSC instructions.  This is never true for Thumb, since\n+   we do not have RSC in that case.  */\n+static bool\n+arm_const_double_prefer_rsbs_rsc (rtx op)\n+{\n+  /* Thumb lacks RSC, so we never prefer that sequence.  */\n+  if (TARGET_THUMB || !CONST_INT_P (op))\n+    return false;\n+  HOST_WIDE_INT hi, lo;\n+  lo = UINTVAL (op) & 0xffffffffULL;\n+  hi = UINTVAL (op) >> 32;\n+  return const_ok_for_arm (lo) && const_ok_for_arm (hi);\n+}\n+\n /* Canonicalize a comparison so that we are more likely to recognize it.\n    This can be done for a few constant compares, where we can make the\n    immediate value easier to load.  */\n@@ -5380,8 +5395,7 @@ arm_canonicalize_comparison (int *code, rtx *op0, rtx *op1,\n     {\n \n       if (*code == GT || *code == LE\n-\t  || ((!TARGET_ARM || CONST_INT_P (*op1))\n-\t      && (*code == GTU || *code == LEU)))\n+\t  || *code == GTU || *code == LEU)\n \t{\n \t  /* Missing comparison.  First try to use an available\n \t     comparison.  */\n@@ -5392,10 +5406,13 @@ arm_canonicalize_comparison (int *code, rtx *op0, rtx *op1,\n \t\t{\n \t\tcase GT:\n \t\tcase LE:\n-\t\t  if (i != maxval\n-\t\t      && (!arm_const_double_by_immediates (*op1)\n-\t\t\t  || arm_const_double_by_immediates (GEN_INT (i + 1))))\n+\t\t  if (i != maxval)\n \t\t    {\n+\t\t      /* Try to convert to GE/LT, unless that would be more\n+\t\t\t expensive.  */\n+\t\t      if (!arm_const_double_by_immediates (GEN_INT (i + 1))\n+\t\t\t  && arm_const_double_prefer_rsbs_rsc (*op1))\n+\t\t\treturn;\n \t\t      *op1 = GEN_INT (i + 1);\n \t\t      *code = *code == GT ? GE : LT;\n \t\t      return;\n@@ -5404,10 +5421,13 @@ arm_canonicalize_comparison (int *code, rtx *op0, rtx *op1,\n \n \t\tcase GTU:\n \t\tcase LEU:\n-\t\t  if (i != ~((unsigned HOST_WIDE_INT) 0)\n-\t\t      && (!arm_const_double_by_immediates (*op1)\n-\t\t\t  || arm_const_double_by_immediates (GEN_INT (i + 1))))\n+\t\t  if (i != ~((unsigned HOST_WIDE_INT) 0))\n \t\t    {\n+\t\t      /* Try to convert to GEU/LTU, unless that would\n+\t\t\t be more expensive.  */\n+\t\t      if (!arm_const_double_by_immediates (GEN_INT (i + 1))\n+\t\t\t  && arm_const_double_prefer_rsbs_rsc (*op1))\n+\t\t\treturn;\n \t\t      *op1 = GEN_INT (i + 1);\n \t\t      *code = *code == GTU ? GEU : LTU;\n \t\t      return;\n@@ -5419,7 +5439,6 @@ arm_canonicalize_comparison (int *code, rtx *op0, rtx *op1,\n \t\t}\n \t    }\n \n-\t  /* If that did not work, reverse the condition.  */\n \t  if (!op0_preserve_value)\n \t    {\n \t      std::swap (*op0, *op1);\n@@ -15251,6 +15270,28 @@ arm_select_cc_mode (enum rtx_code op, rtx x, rtx y)\n \t  || GET_CODE (x) == ROTATERT))\n     return CC_SWPmode;\n \n+  /* A widened compare of the sum of a value plus a carry against a\n+     constant.  This is a representation of RSC.  We want to swap the\n+     result of the comparison at output.  Not valid if the Z bit is\n+     needed.  */\n+  if (GET_MODE (x) == DImode\n+      && GET_CODE (x) == PLUS\n+      && arm_borrow_operation (XEXP (x, 1), DImode)\n+      && CONST_INT_P (y)\n+      && ((GET_CODE (XEXP (x, 0)) == SIGN_EXTEND\n+\t   && (op == LE || op == GT))\n+\t  || (GET_CODE (XEXP (x, 0)) == ZERO_EXTEND\n+\t      && (op == LEU || op == GTU))))\n+    return CC_SWPmode;\n+\n+  /* If X is a constant we want to use CC_RSBmode.  This is\n+     non-canonical, but arm_gen_compare_reg uses this to generate the\n+     correct canonical form.  */\n+  if (GET_MODE (y) == SImode\n+      && (REG_P (y) || GET_CODE (y) == SUBREG)\n+      && CONST_INT_P (x))\n+    return CC_RSBmode;\n+\n   /* This operation is performed swapped, but since we only rely on the Z\n      flag we don't need an additional mode.  */\n   if (GET_MODE (y) == SImode\n@@ -15329,15 +15370,13 @@ arm_select_cc_mode (enum rtx_code op, rtx x, rtx y)\n \t  || (TARGET_32BIT && GET_CODE (x) == ZERO_EXTRACT)))\n     return CC_NOOVmode;\n \n-  /* An unsigned comparison of ~reg with a const is really a special\n+  /* A comparison of ~reg with a const is really a special\n      canoncialization of compare (~const, reg), which is a reverse\n      subtract operation.  We may not get here if CONST is 0, but that\n      doesn't matter because ~0 isn't a valid immediate for RSB.  */\n   if (GET_MODE (x) == SImode\n       && GET_CODE (x) == NOT\n-      && CONST_INT_P (y)\n-      && (op == EQ || op == NE\n-\t  || op == LTU || op == LEU || op == GEU || op == GTU))\n+      && CONST_INT_P (y))\n     return CC_RSBmode;\n \n   if (GET_MODE (x) == QImode && (op == EQ || op == NE))\n@@ -15431,6 +15470,7 @@ arm_gen_dicompare_reg (rtx_code code, rtx x, rtx y, rtx scratch)\n \n     /* We don't currently handle DImode in thumb1, but rely on libgcc.  */\n   gcc_assert (TARGET_32BIT);\n+  gcc_assert (!CONST_INT_P (x));\n \n   rtx x_lo = simplify_gen_subreg (SImode, x, DImode,\n \t\t\t\t  subreg_lowpart_offset (SImode, DImode));\n@@ -15445,9 +15485,6 @@ arm_gen_dicompare_reg (rtx_code code, rtx x, rtx y, rtx scratch)\n     case EQ:\n     case NE:\n       {\n-\t/* We should never have X as a const_int in this case.  */\n-\tgcc_assert (!CONST_INT_P (x));\n-\n \tif (y_lo == const0_rtx || y_hi == const0_rtx)\n \t  {\n \t    if (y_lo != const0_rtx)\n@@ -15525,24 +15562,17 @@ arm_gen_dicompare_reg (rtx_code code, rtx x, rtx y, rtx scratch)\n \tif (!arm_add_operand (y_lo, SImode))\n \t  y_lo = force_reg (SImode, y_lo);\n \n-\t/* Just for now.  */\n-\tif (!register_operand (x_lo, SImode))\n-\t  x_lo = force_reg (SImode, x_lo);\n-\n \trtx cmp1\n \t  = gen_rtx_LTU (DImode,\n \t\t\t arm_gen_compare_reg (LTU, x_lo, y_lo, NULL_RTX),\n \t\t\t const0_rtx);\n \n \tif (!scratch)\n \t  scratch = gen_rtx_SCRATCH (SImode);\n+\n \tif (!arm_not_operand (y_hi, SImode))\n \t  y_hi = force_reg (SImode, y_hi);\n \n-\t/* Just for now.  */\n-\tif (!register_operand (x_hi, SImode))\n-\t  x_hi = force_reg (SImode, x_hi);\n-\n \trtx_insn *insn;\n \tif (y_hi == const0_rtx)\n \t  insn = emit_insn (gen_cmpsi3_0_carryin_CC_NVout (scratch, x_hi,\n@@ -15556,6 +15586,27 @@ arm_gen_dicompare_reg (rtx_code code, rtx x, rtx y, rtx scratch)\n \treturn SET_DEST (single_set (insn));\n       }\n \n+    case LE:\n+    case GT:\n+      {\n+\t/* During expansion, we only expect to get here if y is a\n+\t   constant that we want to handle, otherwise we should have\n+\t   swapped the operands already.  */\n+\tgcc_assert (arm_const_double_prefer_rsbs_rsc (y));\n+\n+\tif (!const_ok_for_arm (INTVAL (y_lo)))\n+\t  y_lo = force_reg (SImode, y_lo);\n+\n+\t/* Perform a reverse subtract and compare.  */\n+\trtx cmp1\n+\t  = gen_rtx_LTU (DImode,\n+\t\t\t arm_gen_compare_reg (LTU, y_lo, x_lo, scratch),\n+\t\t\t const0_rtx);\n+\trtx_insn *insn = emit_insn (gen_rscsi3_CC_NVout_scratch (scratch, y_hi,\n+\t\t\t\t\t\t\t\t x_hi, cmp1));\n+\treturn SET_DEST (single_set (insn));\n+      }\n+\n     case LTU:\n     case GEU:\n       {\n@@ -15572,10 +15623,6 @@ arm_gen_dicompare_reg (rtx_code code, rtx x, rtx y, rtx scratch)\n \tif (!arm_add_operand (y_lo, SImode))\n \t  y_lo = force_reg (SImode, y_lo);\n \n-\t/* Just for now.  */\n-\tif (!register_operand (x_lo, SImode))\n-\t  x_lo = force_reg (SImode, x_lo);\n-\n \trtx cmp1\n \t  = gen_rtx_LTU (DImode,\n \t\t\t arm_gen_compare_reg (LTU, x_lo, y_lo, NULL_RTX),\n@@ -15586,10 +15633,6 @@ arm_gen_dicompare_reg (rtx_code code, rtx x, rtx y, rtx scratch)\n \tif (!arm_not_operand (y_hi, SImode))\n \t  y_hi = force_reg (SImode, y_hi);\n \n-\t/* Just for now.  */\n-\tif (!register_operand (x_hi, SImode))\n-\t  x_hi = force_reg (SImode, x_hi);\n-\n \trtx_insn *insn;\n \tif (y_hi == const0_rtx)\n \t  insn = emit_insn (gen_cmpsi3_0_carryin_CC_Bout (scratch, x_hi,\n@@ -15607,6 +15650,28 @@ arm_gen_dicompare_reg (rtx_code code, rtx x, rtx y, rtx scratch)\n \treturn SET_DEST (single_set (insn));\n       }\n \n+    case LEU:\n+    case GTU:\n+      {\n+\t/* During expansion, we only expect to get here if y is a\n+\t   constant that we want to handle, otherwise we should have\n+\t   swapped the operands already.  */\n+\tgcc_assert (arm_const_double_prefer_rsbs_rsc (y));\n+\n+\tif (!const_ok_for_arm (INTVAL (y_lo)))\n+\t  y_lo = force_reg (SImode, y_lo);\n+\n+\t/* Perform a reverse subtract and compare.  */\n+\trtx cmp1\n+\t  = gen_rtx_LTU (DImode,\n+\t\t\t arm_gen_compare_reg (LTU, y_lo, x_lo, scratch),\n+\t\t\t const0_rtx);\n+\ty_hi = GEN_INT (0xffffffff & UINTVAL (y_hi));\n+\trtx_insn *insn = emit_insn (gen_rscsi3_CC_Bout_scratch (scratch, y_hi,\n+\t\t\t\t\t\t\t\tx_hi, cmp1));\n+\treturn SET_DEST (single_set (insn));\n+      }\n+\n     default:\n       break;\n     }\n@@ -15695,8 +15760,15 @@ arm_gen_compare_reg (rtx_code code, rtx x, rtx y, rtx scratch)\n \n   machine_mode mode = SELECT_CC_MODE (code, x, y);\n   rtx cc_reg = gen_rtx_REG (mode, CC_REGNUM);\n-\n-  emit_set_insn (cc_reg, gen_rtx_COMPARE (mode, x, y));\n+  if (mode == CC_RSBmode)\n+    {\n+      if (!scratch)\n+\tscratch = gen_rtx_SCRATCH (SImode);\n+      emit_insn (gen_rsb_imm_compare_scratch (scratch,\n+\t\t\t\t\t      GEN_INT (~UINTVAL (x)), y));\n+    }\n+  else\n+    emit_set_insn (cc_reg, gen_rtx_COMPARE (mode, x, y));\n \n   return cc_reg;\n }\n@@ -24025,19 +24097,8 @@ maybe_get_arm_condition_code (rtx comparison)\n \tdefault: return ARM_NV;\n \t}\n \n-    case E_CC_RSBmode:\n-      switch (comp_code)\n-\t{\n-\tcase NE: return ARM_NE;\n-\tcase EQ: return ARM_EQ;\n-\tcase GEU: return ARM_CS;\n-\tcase GTU: return ARM_HI;\n-\tcase LEU: return ARM_LS;\n-\tcase LTU: return ARM_CC;\n-\tdefault: return ARM_NV;\n-\t}\n-\n     case E_CCmode:\n+    case E_CC_RSBmode:\n       switch (comp_code)\n \t{\n \tcase NE: return ARM_NE;"}, {"sha": "8607c6f95da9e965b192e8c5fb4987967ec135a5", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af74bfeee1faccef25dc0086d4249eb0f127c820/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af74bfeee1faccef25dc0086d4249eb0f127c820/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=af74bfeee1faccef25dc0086d4249eb0f127c820", "patch": "@@ -1363,6 +1363,33 @@\n    (set_attr \"type\" \"alus_imm\")]\n )\n \n+;; Similarly, but the result is unused.\n+(define_insn \"rsb_imm_compare_scratch\"\n+  [(set (reg:CC_RSB CC_REGNUM)\n+\t(compare:CC_RSB (not:SI (match_operand:SI 2 \"s_register_operand\" \"r\"))\n+\t\t\t(match_operand 1 \"arm_not_immediate_operand\" \"K\")))\n+   (clobber (match_scratch:SI 0 \"=r\"))]\n+  \"TARGET_32BIT\"\n+  \"rsbs\\\\t%0, %2, #%B1\"\n+  [(set_attr \"conds\" \"set\")\n+   (set_attr \"type\" \"alus_imm\")]\n+)\n+\n+;; Compare the sum of a value plus a carry against a constant.  Uses\n+;; RSC, so the result is swapped.  Only available on Arm\n+(define_insn \"rscsi3_<CC_EXTEND>out_scratch\"\n+  [(set (reg:CC_SWP CC_REGNUM)\n+\t(compare:CC_SWP\n+\t (plus:DI (SE:DI (match_operand:SI 2 \"s_register_operand\" \"r\"))\n+\t\t  (match_operand:DI 3 \"arm_borrow_operation\" \"\"))\n+\t (match_operand 1 \"arm_immediate_operand\" \"I\")))\n+   (clobber (match_scratch:SI 0 \"=r\"))]\n+  \"TARGET_ARM\"\n+  \"rscs\\\\t%0, %2, %1\"\n+  [(set_attr \"conds\" \"set\")\n+   (set_attr \"type\" \"alus_imm\")]\n+)\n+\n (define_expand \"subsf3\"\n   [(set (match_operand:SF           0 \"s_register_operand\")\n \t(minus:SF (match_operand:SF 1 \"s_register_operand\")"}]}