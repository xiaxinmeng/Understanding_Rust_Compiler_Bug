{"sha": "4a68b7c4d594e082b32da7e76a7cd7a472abb5de", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGE2OGI3YzRkNTk0ZTA4MmIzMmRhN2U3NmE3Y2Q3YTQ3MmFiYjVkZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-10-31T11:37:44Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-10-31T11:37:44Z"}, "message": "[multiple changes]\n\n2014-10-31  Vasiliy Fofanov  <fofanov@adacore.com>\n\n\t* prj-conf.adb (Do_Autoconf): Refactor the code so that empty\n\tNormalized_Pathname doesn't inhibit the custom Selected_Target\n\tvalue.\n\t* prj-conf.adb (Parse_Project_And_Apply_Config): Make sure that\n\tAutomatically_Generated is correctly set after the first call\n\tto Process_Project_And_Apply_Config and not modified after the\n\tsecond call, if any.\n\n2014-10-31  Yannick Moy  <moy@adacore.com>\n\n\t* Makefile.rtl, gnat_rm.texi, impunit.adb: Add mention of new library\n\tfiles.\n\t* a-cfinve.adb, a-cfinve.ads: New unit for formal indefinite\n\tvectors, suitable for use in client SPARK code, also more\n\tefficient than the standard vectors.\n\t* a-coboho.adb, a-coboho.ads New unit for bounded holders, that\n\tare used to define formal indefinite vectors in terms of formal\n\tdefinite ones.\n\t* a-cofove.adb, a-cofove.ads: Simplification of the API of formal\n\tdefinite vectors, similar to the API of the new indefinite ones. A\n\tnew formal parameter of the generic unit called Bounded allows\n\tto define growable vectors that use dynamic allocation.\n\nFrom-SVN: r216967", "tree": {"sha": "8a47b5d48d659de4f96ba2a27d617553224d72ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a47b5d48d659de4f96ba2a27d617553224d72ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a68b7c4d594e082b32da7e76a7cd7a472abb5de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a68b7c4d594e082b32da7e76a7cd7a472abb5de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a68b7c4d594e082b32da7e76a7cd7a472abb5de", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a68b7c4d594e082b32da7e76a7cd7a472abb5de/comments", "author": null, "committer": null, "parents": [{"sha": "527f5eb67affc709c78a4f65ba7a1f731d63315e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/527f5eb67affc709c78a4f65ba7a1f731d63315e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/527f5eb67affc709c78a4f65ba7a1f731d63315e"}], "stats": {"total": 2467, "additions": 1028, "deletions": 1439}, "files": [{"sha": "7081458aca4a7d82c7966d95dbaa826c103660a7", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a68b7c4d594e082b32da7e76a7cd7a472abb5de/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a68b7c4d594e082b32da7e76a7cd7a472abb5de/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=4a68b7c4d594e082b32da7e76a7cd7a472abb5de", "patch": "@@ -1,3 +1,28 @@\n+2014-10-31  Vasiliy Fofanov  <fofanov@adacore.com>\n+\n+\t* prj-conf.adb (Do_Autoconf): Refactor the code so that empty\n+\tNormalized_Pathname doesn't inhibit the custom Selected_Target\n+\tvalue.\n+\t* prj-conf.adb (Parse_Project_And_Apply_Config): Make sure that\n+\tAutomatically_Generated is correctly set after the first call\n+\tto Process_Project_And_Apply_Config and not modified after the\n+\tsecond call, if any.\n+\n+2014-10-31  Yannick Moy  <moy@adacore.com>\n+\n+\t* Makefile.rtl, gnat_rm.texi, impunit.adb: Add mention of new library\n+\tfiles.\n+\t* a-cfinve.adb, a-cfinve.ads: New unit for formal indefinite\n+\tvectors, suitable for use in client SPARK code, also more\n+\tefficient than the standard vectors.\n+\t* a-coboho.adb, a-coboho.ads New unit for bounded holders, that\n+\tare used to define formal indefinite vectors in terms of formal\n+\tdefinite ones.\n+\t* a-cofove.adb, a-cofove.ads: Simplification of the API of formal\n+\tdefinite vectors, similar to the API of the new indefinite ones. A\n+\tnew formal parameter of the generic unit called Bounded allows\n+\tto define growable vectors that use dynamic allocation.\n+\n 2014-10-31  Vincent Celier  <celier@adacore.com>\n \n \t* prj-conf.adb (Look_For_Project_Paths): New procedure"}, {"sha": "ce59a64cfc22cc5ce492ebbbf83ed5ff6f2ba8ac", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a68b7c4d594e082b32da7e76a7cd7a472abb5de/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a68b7c4d594e082b32da7e76a7cd7a472abb5de/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=4a68b7c4d594e082b32da7e76a7cd7a472abb5de", "patch": "@@ -110,6 +110,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-cfdlli$(objext) \\\n   a-cfhama$(objext) \\\n   a-cfhase$(objext) \\\n+  a-cfinve$(objext) \\\n   a-cforma$(objext) \\\n   a-cforse$(objext) \\\n   a-cgaaso$(objext) \\\n@@ -134,6 +135,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-ciormu$(objext) \\\n   a-ciorse$(objext) \\\n   a-clrefi$(objext) \\\n+  a-coboho$(objext) \\\n   a-cobove$(objext) \\\n   a-cofove$(objext) \\\n   a-cogeso$(objext) \\"}, {"sha": "793b5c3922f6848c7d0e82c1cd50e306c717da82", "filename": "gcc/ada/a-cfinve.adb", "status": "added", "additions": 295, "deletions": 0, "changes": 295, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a68b7c4d594e082b32da7e76a7cd7a472abb5de/gcc%2Fada%2Fa-cfinve.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a68b7c4d594e082b32da7e76a7cd7a472abb5de/gcc%2Fada%2Fa-cfinve.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfinve.adb?ref=4a68b7c4d594e082b32da7e76a7cd7a472abb5de", "patch": "@@ -0,0 +1,295 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                          A D A . C O N T A I N E R S\n+--           . F O R M A L _ I N D E F I N I T E _ V E C T O R S            --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--             Copyright (C) 2014, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+------------------------------------------------------------------------------\n+\n+package body Ada.Containers.Formal_Indefinite_Vectors is\n+\n+   function H (New_Item : Element_Type) return Holder renames To_Holder;\n+   function E (Container : Holder) return Element_Type renames Get;\n+\n+   ---------\n+   -- \"=\" --\n+   ---------\n+\n+   function \"=\" (Left, Right : Vector) return Boolean is\n+      (Left.V = Right.V);\n+\n+   ------------\n+   -- Append --\n+   ------------\n+\n+   procedure Append (Container : in out Vector; New_Item : Vector) is\n+   begin\n+      Append (Container.V, New_Item.V);\n+   end Append;\n+\n+   procedure Append\n+     (Container : in out Vector;\n+      New_Item  : Element_Type)\n+   is\n+   begin\n+      Append (Container.V, H (New_Item));\n+   end Append;\n+\n+   ------------\n+   -- Assign --\n+   ------------\n+\n+   procedure Assign (Target : in out Vector; Source : Vector) is\n+   begin\n+      Assign (Target.V, Source.V);\n+   end Assign;\n+\n+   --------------\n+   -- Capacity --\n+   --------------\n+\n+   function Capacity (Container : Vector) return Capacity_Range is\n+      (Capacity (Container.V));\n+\n+   -----------\n+   -- Clear --\n+   -----------\n+\n+   procedure Clear (Container : in out Vector) is\n+   begin\n+      Clear (Container.V);\n+   end Clear;\n+\n+   --------------\n+   -- Contains --\n+   --------------\n+\n+   function Contains\n+     (Container : Vector;\n+      Item      : Element_Type) return Boolean is\n+     (Contains (Container.V, H (Item)));\n+\n+   ----------\n+   -- Copy --\n+   ----------\n+\n+   function Copy\n+     (Source   : Vector;\n+      Capacity : Capacity_Range := 0) return Vector is\n+     (Capacity, V => Copy (Source.V, Capacity));\n+\n+   ---------------------\n+   -- Current_To_Last --\n+   ---------------------\n+\n+   function Current_To_Last\n+     (Container : Vector;\n+      Current   : Index_Type) return Vector is\n+   begin\n+      return (Length (Container), Current_To_Last (Container.V, Current));\n+   end Current_To_Last;\n+\n+   -----------------\n+   -- Delete_Last --\n+   -----------------\n+\n+   procedure Delete_Last\n+     (Container : in out Vector)\n+   is\n+   begin\n+      Delete_Last (Container.V);\n+   end Delete_Last;\n+\n+   -------------\n+   -- Element --\n+   -------------\n+\n+   function Element\n+     (Container : Vector;\n+      Index     : Index_Type) return Element_Type is\n+     (E (Element (Container.V, Index)));\n+\n+   ----------------\n+   -- Find_Index --\n+   ----------------\n+\n+   function Find_Index\n+     (Container : Vector;\n+      Item      : Element_Type;\n+      Index     : Index_Type := Index_Type'First) return Extended_Index is\n+     (Find_Index (Container.V, H (Item), Index));\n+\n+   -------------------\n+   -- First_Element --\n+   -------------------\n+\n+   function First_Element (Container : Vector) return Element_Type is\n+      (E (First_Element (Container.V)));\n+\n+   -----------------\n+   -- First_Index --\n+   -----------------\n+\n+   function First_Index (Container : Vector) return Index_Type is\n+      (First_Index (Container.V));\n+\n+   -----------------------\n+   -- First_To_Previous --\n+   -----------------------\n+\n+   function First_To_Previous\n+     (Container : Vector;\n+      Current   : Index_Type) return Vector is\n+   begin\n+      return (Length (Container), First_To_Previous (Container.V, Current));\n+   end First_To_Previous;\n+\n+   ---------------------\n+   -- Generic_Sorting --\n+   ---------------------\n+\n+   package body Generic_Sorting is\n+\n+      function \"<\" (X, Y : Holder) return Boolean is (E (X) < E (Y));\n+      package Def_Sorting is new Def.Generic_Sorting (\"<\");\n+      use Def_Sorting;\n+\n+      ---------------\n+      -- Is_Sorted --\n+      ---------------\n+\n+      function Is_Sorted (Container : Vector) return Boolean is\n+         (Is_Sorted (Container.V));\n+\n+      ----------\n+      -- Sort --\n+      ----------\n+\n+      procedure Sort (Container : in out Vector) is\n+      begin\n+         Sort (Container.V);\n+      end Sort;\n+\n+   end Generic_Sorting;\n+\n+   -----------------\n+   -- Has_Element --\n+   -----------------\n+\n+   function Has_Element\n+     (Container : Vector; Position : Extended_Index) return Boolean is\n+     (Has_Element (Container.V, Position));\n+\n+   --------------\n+   -- Is_Empty --\n+   --------------\n+\n+   function Is_Empty (Container : Vector) return Boolean is\n+      (Is_Empty (Container.V));\n+\n+   ------------------\n+   -- Last_Element --\n+   ------------------\n+\n+   function Last_Element (Container : Vector) return Element_Type is\n+      (E (Last_Element (Container.V)));\n+\n+   ----------------\n+   -- Last_Index --\n+   ----------------\n+\n+   function Last_Index (Container : Vector) return Extended_Index is\n+      (Last_Index (Container.V));\n+\n+   ------------\n+   -- Length --\n+   ------------\n+\n+   function Length (Container : Vector) return Capacity_Range is\n+      (Length (Container.V));\n+\n+   ---------------------\n+   -- Replace_Element --\n+   ---------------------\n+\n+   procedure Replace_Element\n+     (Container : in out Vector;\n+      Index     : Index_Type;\n+      New_Item  : Element_Type)\n+   is\n+   begin\n+      Replace_Element (Container.V, Index, H (New_Item));\n+   end Replace_Element;\n+\n+   ----------------------\n+   -- Reserve_Capacity --\n+   ----------------------\n+\n+   procedure Reserve_Capacity\n+     (Container : in out Vector;\n+      Capacity  : Capacity_Range)\n+   is\n+   begin\n+      Reserve_Capacity (Container.V, Capacity);\n+   end Reserve_Capacity;\n+\n+   ----------------------\n+   -- Reverse_Elements --\n+   ----------------------\n+\n+   procedure Reverse_Elements (Container : in out Vector) is\n+   begin\n+      Reverse_Elements (Container.V);\n+   end Reverse_Elements;\n+\n+   ------------------------\n+   -- Reverse_Find_Index --\n+   ------------------------\n+\n+   function Reverse_Find_Index\n+     (Container : Vector;\n+      Item      : Element_Type;\n+      Index     : Index_Type := Index_Type'Last) return Extended_Index is\n+     (Reverse_Find_Index (Container.V, H (Item), Index));\n+\n+   ----------\n+   -- Swap --\n+   ----------\n+\n+   procedure Swap (Container : in out Vector; I, J : Index_Type) is\n+   begin\n+      Swap (Container.V, I, J);\n+   end Swap;\n+\n+   ---------------\n+   -- To_Vector --\n+   ---------------\n+\n+   function To_Vector\n+     (New_Item : Element_Type;\n+      Length   : Capacity_Range) return Vector is\n+   begin\n+      return (Length, To_Vector (H (New_Item), Length));\n+   end To_Vector;\n+\n+end Ada.Containers.Formal_Indefinite_Vectors;"}, {"sha": "19cc166f2684778b8cac335bdb99639e09588952", "filename": "gcc/ada/a-cfinve.ads", "status": "added", "additions": 249, "deletions": 0, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a68b7c4d594e082b32da7e76a7cd7a472abb5de/gcc%2Fada%2Fa-cfinve.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a68b7c4d594e082b32da7e76a7cd7a472abb5de/gcc%2Fada%2Fa-cfinve.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfinve.ads?ref=4a68b7c4d594e082b32da7e76a7cd7a472abb5de", "patch": "@@ -0,0 +1,249 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                          A D A . C O N T A I N E R S\n+--           . F O R M A L _ I N D E F I N I T E _ V E C T O R S            --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--             Copyright (C) 2014, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+------------------------------------------------------------------------------\n+\n+--  Similar to Ada.Containers.Formal_Vectors. The main difference is that\n+--  Element_Type may be indefinite (but not an unconstrained array). In\n+--  addition, this is simplified by removing less-used functionality.\n+\n+with Ada.Containers.Bounded_Holders;\n+with Ada.Containers.Formal_Vectors;\n+\n+generic\n+   type Index_Type is range <>;\n+   type Element_Type (<>) is private;\n+   Max_Size_In_Storage_Elements : Natural :=\n+     Element_Type'Max_Size_In_Storage_Elements;\n+   --  This has the same meaning as in Ada.Containers.Bounded_Holders, with the\n+   --  same restrictions.\n+\n+   with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n+\n+   Bounded : Boolean := True;\n+   --  If True, the containers are bounded; the initial capacity is the maximum\n+   --  size, and heap allocation will be avoided. If False, the containers can\n+   --  grow via heap allocation.\n+\n+package Ada.Containers.Formal_Indefinite_Vectors is\n+   pragma Annotate (GNATprove, External_Axiomatization);\n+\n+   subtype Extended_Index is Index_Type'Base\n+   range Index_Type'First - 1 ..\n+     Index_Type'Min (Index_Type'Base'Last - 1, Index_Type'Last) + 1;\n+\n+   No_Index : constant Extended_Index := Extended_Index'First;\n+\n+   subtype Capacity_Range is\n+     Count_Type range 0 .. Count_Type (Index_Type'Last - Index_Type'First + 1);\n+\n+   type Vector (Capacity : Capacity_Range) is limited private with\n+     Default_Initial_Condition;\n+\n+   function Empty_Vector return Vector;\n+\n+   function \"=\" (Left, Right : Vector) return Boolean with\n+     Global => null;\n+\n+   function To_Vector\n+     (New_Item : Element_Type;\n+      Length   : Capacity_Range) return Vector\n+   with\n+     Global => null;\n+\n+   function Capacity (Container : Vector) return Capacity_Range with\n+     Global => null;\n+\n+   procedure Reserve_Capacity\n+     (Container : in out Vector;\n+      Capacity  : Capacity_Range)\n+   with\n+     Global => null,\n+     Pre    => (if Bounded then Capacity <= Container.Capacity);\n+\n+   function Length (Container : Vector) return Capacity_Range with\n+     Global => null;\n+\n+   function Is_Empty (Container : Vector) return Boolean with\n+     Global => null;\n+\n+   procedure Clear (Container : in out Vector) with\n+     Global => null;\n+   --  Note that this reclaims storage in the unbounded case. You need to call\n+   --  this before a container goes out of scope in order to avoid storage\n+   --  leaks.\n+\n+   procedure Assign (Target : in out Vector; Source : Vector) with\n+     Global => null,\n+     Pre    => (if Bounded then Length (Source) <= Target.Capacity);\n+\n+   function Copy\n+     (Source   : Vector;\n+      Capacity : Capacity_Range := 0) return Vector\n+   with\n+     Global => null,\n+     Pre    => (if Bounded then Length (Source) <= Capacity);\n+\n+   function Element\n+     (Container : Vector;\n+      Index     : Index_Type) return Element_Type\n+   with\n+     Global => null,\n+     Pre    => Index in First_Index (Container) .. Last_Index (Container);\n+\n+   procedure Replace_Element\n+     (Container : in out Vector;\n+      Index     : Index_Type;\n+      New_Item  : Element_Type)\n+   with\n+     Global => null,\n+     Pre    => Index in First_Index (Container) .. Last_Index (Container);\n+\n+   procedure Append\n+     (Container : in out Vector;\n+      New_Item  : Vector)\n+   with\n+     Global => null,\n+     Pre    => (if Bounded then\n+                 Length (Container) + Length (New_Item) <= Container.Capacity);\n+\n+   procedure Append\n+     (Container : in out Vector;\n+      New_Item  : Element_Type)\n+   with\n+     Global => null,\n+     Pre    => (if Bounded then\n+                  Length (Container) < Container.Capacity);\n+\n+   procedure Delete_Last\n+     (Container : in out Vector)\n+   with\n+     Global => null;\n+\n+   procedure Reverse_Elements (Container : in out Vector) with\n+     Global => null;\n+\n+   procedure Swap (Container : in out Vector; I, J : Index_Type) with\n+     Global => null,\n+     Pre    => I in First_Index (Container) .. Last_Index (Container)\n+      and then J in First_Index (Container) .. Last_Index (Container);\n+\n+   function First_Index (Container : Vector) return Index_Type with\n+     Global => null;\n+\n+   function First_Element (Container : Vector) return Element_Type with\n+     Global => null,\n+     Pre    => not Is_Empty (Container);\n+\n+   function Last_Index (Container : Vector) return Extended_Index with\n+     Global => null;\n+\n+   function Last_Element (Container : Vector) return Element_Type with\n+     Global => null,\n+     Pre    => not Is_Empty (Container);\n+\n+   function Find_Index\n+     (Container : Vector;\n+      Item      : Element_Type;\n+      Index     : Index_Type := Index_Type'First) return Extended_Index\n+   with\n+     Global => null;\n+\n+   function Reverse_Find_Index\n+     (Container : Vector;\n+      Item      : Element_Type;\n+      Index     : Index_Type := Index_Type'Last) return Extended_Index\n+   with\n+     Global => null;\n+\n+   function Contains\n+     (Container : Vector;\n+      Item      : Element_Type) return Boolean\n+   with\n+     Global => null;\n+\n+   function Has_Element\n+     (Container : Vector; Position : Extended_Index) return Boolean with\n+     Global => null;\n+\n+   generic\n+      with function \"<\" (Left, Right : Element_Type) return Boolean is <>;\n+   package Generic_Sorting is\n+\n+      function Is_Sorted (Container : Vector) return Boolean with\n+        Global => null;\n+\n+      procedure Sort (Container : in out Vector) with\n+        Global => null;\n+\n+   end Generic_Sorting;\n+\n+   function First_To_Previous\n+     (Container : Vector;\n+      Current : Index_Type) return Vector\n+   with\n+     Global => null;\n+   function Current_To_Last\n+     (Container : Vector;\n+      Current : Index_Type) return Vector\n+   with\n+     Global => null;\n+\n+private\n+\n+   pragma Inline (First_Index);\n+   pragma Inline (Last_Index);\n+   pragma Inline (Element);\n+   pragma Inline (First_Element);\n+   pragma Inline (Last_Element);\n+   pragma Inline (Replace_Element);\n+   pragma Inline (Contains);\n+\n+   --  The implementation method is to instantiate Bounded_Holders to get a\n+   --  definite type for Element_Type, and then use that Holder type to\n+   --  instantiate Formal_Vectors. All the operations are just wrappers.\n+\n+   package Holders is new Bounded_Holders\n+     (Element_Type, Max_Size_In_Storage_Elements, \"=\");\n+   use Holders;\n+\n+   package Def is new Formal_Vectors (Index_Type, Holder, \"=\", Bounded);\n+   use Def;\n+\n+   --  ????Assert that Def subtypes have the same range.\n+\n+   type Vector (Capacity : Capacity_Range) is limited record\n+      V : Def.Vector (Capacity);\n+   end record;\n+\n+   function Empty_Vector return Vector is\n+     ((Capacity => 0, V => Def.Empty_Vector));\n+\n+end Ada.Containers.Formal_Indefinite_Vectors;"}, {"sha": "23beaea9b3796774b3d6ef5790cd8ef2b9fbaef1", "filename": "gcc/ada/a-coboho.adb", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a68b7c4d594e082b32da7e76a7cd7a472abb5de/gcc%2Fada%2Fa-coboho.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a68b7c4d594e082b32da7e76a7cd7a472abb5de/gcc%2Fada%2Fa-coboho.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coboho.adb?ref=4a68b7c4d594e082b32da7e76a7cd7a472abb5de", "patch": "@@ -0,0 +1,89 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--       A D A . C O N T A I N E R S . B O U N D E D _ H O L D E R S        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2014, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+------------------------------------------------------------------------------\n+\n+with Unchecked_Conversion;\n+with Ada.Assertions; use Ada.Assertions;\n+\n+package body Ada.Containers.Bounded_Holders is\n+\n+   function Size_In_Storage_Elements (Element : Element_Type) return Natural is\n+     (Element'Size / System.Storage_Unit)\n+       with Pre =>\n+       (Element'Size mod System.Storage_Unit = 0 or else\n+          raise Assertion_Error with \"Size must be a multiple of Storage_Unit\")\n+       and then\n+         (Element'Size / System.Storage_Unit <= Max_Size_In_Storage_Elements\n+            or else raise Assertion_Error with \"Size is too big\");\n+   --  This returns the size of Element in storage units. It raises an\n+   --  exception if the size is not a multiple of Storage_Unit, or if the size\n+   --  is too big.\n+\n+   function Cast is new\n+     Unchecked_Conversion (System.Address, Element_Access);\n+\n+   ---------\n+   -- \"=\" --\n+   ---------\n+\n+   function \"=\" (Left, Right : Holder) return Boolean is\n+   begin\n+      return Get (Left) = Get (Right);\n+   end \"=\";\n+\n+   -------------\n+   -- Element --\n+   -------------\n+\n+   function Get (Container : Holder) return Element_Type is\n+   begin\n+      return Cast (Container'Address).all;\n+   end Get;\n+\n+   ---------------------\n+   -- Replace_Element --\n+   ---------------------\n+\n+   procedure Set (Container : in out Holder; New_Item  : Element_Type) is\n+      Storage : Storage_Array\n+        (1 .. Size_In_Storage_Elements (New_Item)) with\n+          Address => New_Item'Address;\n+   begin\n+      Container.Data (Storage'Range) := Storage;\n+   end Set;\n+\n+   ---------------\n+   -- To_Holder --\n+   ---------------\n+\n+   function To_Holder (New_Item : Element_Type) return Holder is\n+   begin\n+      return Result : Holder do\n+         Set (Result, New_Item);\n+      end return;\n+   end To_Holder;\n+\n+end Ada.Containers.Bounded_Holders;"}, {"sha": "244c4d41fe92eb3378676888dbf6f2b5e6ef9b12", "filename": "gcc/ada/a-coboho.ads", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a68b7c4d594e082b32da7e76a7cd7a472abb5de/gcc%2Fada%2Fa-coboho.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a68b7c4d594e082b32da7e76a7cd7a472abb5de/gcc%2Fada%2Fa-coboho.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coboho.ads?ref=4a68b7c4d594e082b32da7e76a7cd7a472abb5de", "patch": "@@ -0,0 +1,102 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--       A D A . C O N T A I N E R S . B O U N D E D _ H O L D E R S        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2014, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+------------------------------------------------------------------------------\n+\n+private with System;\n+\n+generic\n+   type Element_Type (<>) is private;\n+   Max_Size_In_Storage_Elements : Natural :=\n+     Element_Type'Max_Size_In_Storage_Elements;\n+   with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n+\n+package Ada.Containers.Bounded_Holders is\n+   --  This package is patterned after Ada.Containers.Indefinite_Holders. It is\n+   --  used to treat indefinite subtypes as definite, but without using heap\n+   --  allocation. For example, you might like to say:\n+   --\n+   --     type A is array (...) of T'Class; -- illegal\n+   --\n+   --  Instead, you can instantiate this package with Element_Type => T'Class,\n+   --  and say:\n+   --\n+   --     type A is array (...) of Holder;\n+   --\n+   --  Each object of type Holder is allocated Max_Size_In_Storage_Elements\n+   --  bytes. If you try to create a holder from an object of type Element_Type\n+   --  that is too big, an exception is raised. This applies to To_Holder and\n+   --  Replace_Element. If you pass an Element_Type object that is smaller than\n+   --  Max_Size_In_Storage_Elements, it works fine, but some space is wasted.\n+   --\n+   --  Element_Type must not be an unconstrained array type. It can be a\n+   --  class-wide type or a type with non-defaulted discriminants.\n+   --\n+   --  The 'Size of each Element_Type object must be a multiple of\n+   --  System.Storage_Unit; e.g. creating Holders from 5-bit objects won't\n+   --  work.\n+\n+   type Holder is private;\n+\n+   function \"=\" (Left, Right : Holder) return Boolean;\n+\n+   function To_Holder (New_Item : Element_Type) return Holder;\n+   function \"+\" (New_Item : Element_Type) return Holder renames To_Holder;\n+\n+   function Get (Container : Holder) return Element_Type;\n+\n+   procedure Set (Container : in out Holder; New_Item  : Element_Type);\n+\n+private\n+\n+   --  The implementation uses low-level tricks (Address clauses and unchecked\n+   --  conversions of access types) to treat the elements as storage arrays.\n+\n+   pragma Assert (Element_Type'Alignment <= Standard'Maximum_Alignment);\n+   --  This prevents elements with a user-specified Alignment that is too big\n+\n+   type Storage_Element is mod System.Storage_Unit;\n+   type Storage_Array is array (Positive range <>) of Storage_Element;\n+   type Holder is record\n+      Data : Storage_Array (1 .. Max_Size_In_Storage_Elements);\n+   end record\n+     with Alignment => Standard'Maximum_Alignment;\n+   --  We would like to say \"Alignment => Element_Type'Alignment\", but that\n+   --  is illegal because it's not static, so we use the maximum possible\n+   --  (default) alignment instead.\n+\n+   type Element_Access is access all Element_Type;\n+   pragma Assert (Element_Access'Size = Standard'Address_Size,\n+                  \"cannot instantiate with an array type\");\n+   --  If Element_Access is a fat pointer, Element_Type must be an\n+   --  unconstrained array, which is not allowed. Arrays won't work, because\n+   --  the 'Address of an array points to the first element, thus losing the\n+   --  bounds.\n+\n+end Ada.Containers.Bounded_Holders;"}, {"sha": "42d61f4e0e41c7a5ec787ef7256c34c7edc8bff6", "filename": "gcc/ada/a-cofove.adb", "status": "modified", "additions": 139, "deletions": 1139, "changes": 1278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a68b7c4d594e082b32da7e76a7cd7a472abb5de/gcc%2Fada%2Fa-cofove.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a68b7c4d594e082b32da7e76a7cd7a472abb5de/gcc%2Fada%2Fa-cofove.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofove.adb?ref=4a68b7c4d594e082b32da7e76a7cd7a472abb5de", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2010-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2010-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -26,155 +26,32 @@\n ------------------------------------------------------------------------------\n \n with Ada.Containers.Generic_Array_Sort;\n+with Unchecked_Deallocation;\n with System; use type System.Address;\n \n package body Ada.Containers.Formal_Vectors is\n \n+   Growth_Factor : constant := 2;\n+   --  When growing a container, multiply current capacity by this. Doubling\n+   --  leads to amortized linear-time copying.\n+\n    type Int is range System.Min_Int .. System.Max_Int;\n    type UInt is mod System.Max_Binary_Modulus;\n \n-   function Get_Element\n-     (Container : Vector;\n-      Position  : Count_Type) return Element_Type;\n-\n-   procedure Insert_Space\n-     (Container : in out Vector;\n-      Before    : Extended_Index;\n-      Count     : Count_Type := 1);\n-\n-   ---------\n-   -- \"&\" --\n-   ---------\n-\n-   function \"&\" (Left, Right : Vector) return Vector is\n-      LN : constant Count_Type := Length (Left);\n-      RN : constant Count_Type := Length (Right);\n-\n-   begin\n-      if LN = 0 then\n-         if RN = 0 then\n-            return Empty_Vector;\n-         end if;\n-\n-         declare\n-            E : constant Elements_Array (1 .. Length (Right)) :=\n-              Right.Elements (1 .. RN);\n-         begin\n-            return (Length (Right), E, Last => Right.Last, others => <>);\n-         end;\n-      end if;\n-\n-      if RN = 0 then\n-         declare\n-            E : constant Elements_Array (1 .. Length (Left)) :=\n-              Left.Elements (1 .. LN);\n-         begin\n-            return (Length (Left), E, Last => Left.Last, others => <>);\n-         end;\n-      end if;\n-\n-      declare\n-         N           : constant Int'Base := Int (LN) + Int (RN);\n-         Last_As_Int : Int'Base;\n-\n-      begin\n-         if Int (No_Index) > Int'Last - N then\n-            raise Constraint_Error with \"new length is out of range\";\n-         end if;\n-\n-         Last_As_Int := Int (No_Index) + N;\n-\n-         if Last_As_Int > Int (Index_Type'Last) then\n-            raise Constraint_Error with \"new length is out of range\";\n-         end if;\n-\n-         --  TODO: should check whether length > max capacity (cnt_t'last)  ???\n-\n-         declare\n-            Last : constant Index_Type := Index_Type (Last_As_Int);\n-\n-            LE : constant Elements_Array (1 .. LN) := Left.Elements (1 .. LN);\n-            RE : Elements_Array renames Right.Elements (1 .. RN);\n-\n-            Capacity : constant Count_Type := Length (Left) + Length (Right);\n-\n-         begin\n-            return (Capacity, LE & RE, Last => Last, others => <>);\n-         end;\n-      end;\n-   end \"&\";\n-\n-   function \"&\" (Left  : Vector; Right : Element_Type) return Vector is\n-      LN          : constant Count_Type := Length (Left);\n-      Last_As_Int : Int'Base;\n-\n-   begin\n-      if LN = 0 then\n-         return (1, (1 .. 1 => Right), Index_Type'First, others => <>);\n-      end if;\n-\n-      if Int (Index_Type'First) > Int'Last - Int (LN) then\n-         raise Constraint_Error with \"new length is out of range\";\n-      end if;\n-\n-      Last_As_Int := Int (Index_Type'First) + Int (LN);\n-\n-      if Last_As_Int > Int (Index_Type'Last) then\n-         raise Constraint_Error with \"new length is out of range\";\n-      end if;\n+   type Elements_Array_Ptr_Const is access constant Elements_Array;\n \n-      declare\n-         Last : constant Index_Type := Index_Type (Last_As_Int);\n-         LE   : constant Elements_Array (1 .. LN) := Left.Elements (1 .. LN);\n-\n-         Capacity : constant Count_Type := Length (Left) + 1;\n-\n-      begin\n-         return (Capacity, LE & Right, Last => Last, others => <>);\n-      end;\n-   end \"&\";\n-\n-   function \"&\" (Left  : Element_Type; Right : Vector) return Vector is\n-      RN          : constant Count_Type := Length (Right);\n-      Last_As_Int : Int'Base;\n-\n-   begin\n-      if RN = 0 then\n-         return (1, (1 .. 1 => Left),\n-                 Index_Type'First, others => <>);\n-      end if;\n-\n-      if Int (Index_Type'First) > Int'Last - Int (RN) then\n-         raise Constraint_Error with \"new length is out of range\";\n-      end if;\n-\n-      Last_As_Int := Int (Index_Type'First) + Int (RN);\n-\n-      if Last_As_Int > Int (Index_Type'Last) then\n-         raise Constraint_Error with \"new length is out of range\";\n-      end if;\n-\n-      declare\n-         Last     : constant Index_Type := Index_Type (Last_As_Int);\n-         RE       : Elements_Array renames Right.Elements (1 .. RN);\n-         Capacity : constant Count_Type := 1 + Length (Right);\n-      begin\n-         return (Capacity, Left & RE, Last => Last, others => <>);\n-      end;\n-   end \"&\";\n+   procedure Free is\n+      new Unchecked_Deallocation (Elements_Array, Elements_Array_Ptr);\n \n-   function \"&\" (Left, Right : Element_Type) return Vector is\n-   begin\n-      if Index_Type'First >= Index_Type'Last then\n-         raise Constraint_Error with \"new length is out of range\";\n-      end if;\n+   function Elems (Container : in out Vector) return Elements_Array_Ptr;\n+   function Elemsc\n+     (Container : Vector) return Elements_Array_Ptr_Const;\n+   --  Returns a pointer to the Elements array currently in use -- either\n+   --  Container.Elements_Ptr or a pointer to Container.Elements.\n \n-      declare\n-         Last : constant Index_Type := Index_Type'First + 1;\n-      begin\n-         return (2, (Left, Right), Last => Last, others => <>);\n-      end;\n-   end \"&\";\n+   function Get_Element\n+     (Container : Vector;\n+      Position  : Capacity_Range) return Element_Type;\n \n    ---------\n    -- \"=\" --\n@@ -190,7 +67,7 @@ package body Ada.Containers.Formal_Vectors is\n          return False;\n       end if;\n \n-      for J in Count_Type range 1 .. Length (Left) loop\n+      for J in 1 .. Length (Left) loop\n          if Get_Element (Left, J) /= Get_Element (Right, J) then\n             return False;\n          end if;\n@@ -205,25 +82,24 @@ package body Ada.Containers.Formal_Vectors is\n \n    procedure Append (Container : in out Vector; New_Item : Vector) is\n    begin\n-      if Is_Empty (New_Item) then\n-         return;\n-      end if;\n-\n-      if Container.Last = Index_Type'Last then\n-         raise Constraint_Error with \"vector is already at its maximum length\";\n-      end if;\n-\n-      Insert (Container, Container.Last + 1, New_Item);\n+      for X in First_Index (New_Item) .. Last_Index (New_Item)  loop\n+         Append (Container, Element (New_Item, X));\n+      end loop;\n    end Append;\n \n    procedure Append\n      (Container : in out Vector;\n-      New_Item  : Element_Type;\n-      Count     : Count_Type := 1)\n+      New_Item  : Element_Type)\n    is\n+      New_Length : constant UInt := UInt (Length (Container) + 1);\n    begin\n-      if Count = 0 then\n-         return;\n+      if not Bounded and then\n+        Capacity (Container) < Capacity_Range (New_Length)\n+      then\n+         Reserve_Capacity\n+           (Container,\n+            Capacity_Range'Max (Capacity (Container) * Growth_Factor,\n+                            Capacity_Range (New_Length)));\n       end if;\n \n       if Container.Last = Index_Type'Last then\n@@ -232,38 +108,37 @@ package body Ada.Containers.Formal_Vectors is\n \n       --  TODO: should check whether length > max capacity (cnt_t'last)  ???\n \n-      Insert (Container, Container.Last + 1, New_Item, Count);\n+      Container.Last := Container.Last + 1;\n+      Elems (Container) (Length (Container)) := New_Item;\n    end Append;\n \n    ------------\n    -- Assign --\n    ------------\n \n    procedure Assign (Target : in out Vector; Source : Vector) is\n-      LS : constant Count_Type := Length (Source);\n+      LS : constant Capacity_Range := Length (Source);\n \n    begin\n       if Target'Address = Source'Address then\n          return;\n       end if;\n \n-      if Target.Capacity < LS then\n+      if Bounded and then Target.Capacity < LS then\n          raise Constraint_Error;\n       end if;\n \n       Clear (Target);\n-\n-      Target.Elements (1 .. LS) := Source.Elements (1 .. LS);\n-      Target.Last := Source.Last;\n+      Append (Target, Source);\n    end Assign;\n \n    --------------\n    -- Capacity --\n    --------------\n \n-   function Capacity (Container : Vector) return Count_Type is\n+   function Capacity (Container : Vector) return Capacity_Range is\n    begin\n-      return Container.Elements'Length;\n+      return Elemsc (Container)'Length;\n    end Capacity;\n \n    -----------\n@@ -273,6 +148,8 @@ package body Ada.Containers.Formal_Vectors is\n    procedure Clear (Container : in out Vector) is\n    begin\n       Container.Last := No_Index;\n+      Free (Container.Elements_Ptr);\n+      --  It's OK if Container.Elements_Ptr is null\n    end Clear;\n \n    --------------\n@@ -293,22 +170,22 @@ package body Ada.Containers.Formal_Vectors is\n \n    function Copy\n      (Source   : Vector;\n-      Capacity : Count_Type := 0) return Vector\n+      Capacity : Capacity_Range := 0) return Vector\n    is\n-      LS : constant Count_Type := Length (Source);\n-      C  : Count_Type;\n+      LS : constant Capacity_Range := Length (Source);\n+      C  : Capacity_Range;\n \n    begin\n       if Capacity = 0 then\n          C := LS;\n-      elsif Capacity >= LS and then Capacity in Capacity_Range then\n+      elsif Capacity >= LS then\n          C := Capacity;\n       else\n          raise Capacity_Error;\n       end if;\n \n       return Target : Vector (C) do\n-         Target.Elements (1 .. LS) := Source.Elements (1 .. LS);\n+         Elems (Target) (1 .. LS) := Elemsc (Source) (1 .. LS);\n          Target.Last := Source.Last;\n       end return;\n    end Copy;\n@@ -319,146 +196,29 @@ package body Ada.Containers.Formal_Vectors is\n \n    function Current_To_Last\n      (Container : Vector;\n-      Current   : Cursor) return Vector\n+      Current   : Index_Type) return Vector\n    is\n-      C : Vector (Container.Capacity) := Copy (Container, Container.Capacity);\n-\n    begin\n-      if Current = No_Element then\n-         Clear (C);\n-         return C;\n-\n-      elsif not Has_Element (Container, Current) then\n-         raise Constraint_Error;\n-\n-      else\n-         while C.Last /= Container.Last - Current.Index + 1 loop\n-            Delete_First (C);\n+      return Result : Vector\n+        (Count_Type (Container.Last - Current + 1))\n+      do\n+         for X in Current .. Container.Last loop\n+            Append (Result, Element (Container, X));\n          end loop;\n-\n-         return C;\n-      end if;\n+      end return;\n    end Current_To_Last;\n \n-   ------------\n-   -- Delete --\n-   ------------\n-\n-   procedure Delete\n-     (Container : in out Vector;\n-      Index     : Extended_Index;\n-      Count     : Count_Type := 1)\n-   is\n-   begin\n-      if Index < Index_Type'First then\n-         raise Constraint_Error with \"Index is out of range (too small)\";\n-      end if;\n-\n-      if Index > Container.Last then\n-         if Index > Container.Last + 1 then\n-            raise Constraint_Error with \"Index is out of range (too large)\";\n-         end if;\n-\n-         return;\n-      end if;\n-\n-      if Count = 0 then\n-         return;\n-      end if;\n-\n-      declare\n-         I_As_Int        : constant Int := Int (Index);\n-         Old_Last_As_Int : constant Int := Index_Type'Pos (Container.Last);\n-\n-         Count1 : constant Int'Base := Count_Type'Pos (Count);\n-         Count2 : constant Int'Base := Old_Last_As_Int - I_As_Int + 1;\n-         N      : constant Int'Base := Int'Min (Count1, Count2);\n-\n-         J_As_Int : constant Int'Base := I_As_Int + N;\n-\n-      begin\n-         if J_As_Int > Old_Last_As_Int then\n-            Container.Last := Index - 1;\n-\n-         else\n-            declare\n-               EA : Elements_Array renames Container.Elements;\n-\n-               II : constant Int'Base := I_As_Int - Int (No_Index);\n-               I  : constant Count_Type := Count_Type (II);\n-\n-               JJ : constant Int'Base := J_As_Int - Int (No_Index);\n-               J  : constant Count_Type := Count_Type (JJ);\n-\n-               New_Last_As_Int : constant Int'Base := Old_Last_As_Int - N;\n-               New_Last        : constant Index_Type :=\n-                 Index_Type (New_Last_As_Int);\n-\n-               KK : constant Int := New_Last_As_Int - Int (No_Index);\n-               K  : constant Count_Type := Count_Type (KK);\n-\n-            begin\n-               EA (I .. K) := EA (J .. Length (Container));\n-               Container.Last := New_Last;\n-            end;\n-         end if;\n-      end;\n-   end Delete;\n-\n-   procedure Delete\n-     (Container : in out Vector;\n-      Position  : in out Cursor;\n-      Count     : Count_Type := 1)\n-   is\n-   begin\n-      if not Position.Valid then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      if Position.Index > Container.Last then\n-         raise Program_Error with \"Position index is out of range\";\n-      end if;\n-\n-      Delete (Container, Position.Index, Count);\n-      Position := No_Element;\n-   end Delete;\n-\n-   ------------------\n-   -- Delete_First --\n-   ------------------\n-\n-   procedure Delete_First\n-     (Container : in out Vector;\n-      Count     : Count_Type := 1)\n-   is\n-   begin\n-      if Count = 0 then\n-         return;\n-      end if;\n-\n-      if Count >= Length (Container) then\n-         Clear (Container);\n-         return;\n-      end if;\n-\n-      Delete (Container, Index_Type'First, Count);\n-   end Delete_First;\n-\n    -----------------\n    -- Delete_Last --\n    -----------------\n \n    procedure Delete_Last\n-     (Container : in out Vector;\n-      Count     : Count_Type := 1)\n+     (Container : in out Vector)\n    is\n+      Count : constant Capacity_Range := 1;\n       Index : Int'Base;\n \n    begin\n-      if Count = 0 then\n-         return;\n-      end if;\n-\n       Index := Int'Base (Container.Last) - Int'Base (Count);\n \n       if Index < Index_Type'Pos (Index_Type'First) then\n@@ -483,66 +243,30 @@ package body Ada.Containers.Formal_Vectors is\n \n       declare\n          II : constant Int'Base := Int (Index) - Int (No_Index);\n-         I  : constant Count_Type := Count_Type (II);\n+         I  : constant Capacity_Range := Capacity_Range (II);\n       begin\n          return Get_Element (Container, I);\n       end;\n    end Element;\n \n-   function Element\n-     (Container : Vector;\n-      Position  : Cursor) return Element_Type\n-   is\n-      Lst : constant Index_Type := Last_Index (Container);\n+   --------------\n+   -- Elements --\n+   --------------\n \n+   function Elems (Container : in out Vector) return Elements_Array_Ptr is\n    begin\n-      if not Position.Valid then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      if Position.Index > Lst then\n-         raise Constraint_Error with \"Position cursor is out of range\";\n-      end if;\n-\n-      declare\n-         II : constant Int'Base := Int (Position.Index) - Int (No_Index);\n-         I  : constant Count_Type := Count_Type (II);\n-      begin\n-         return Get_Element (Container, I);\n-      end;\n-   end Element;\n-\n-   ----------\n-   -- Find --\n-   ----------\n-\n-   function Find\n-     (Container : Vector;\n-      Item      : Element_Type;\n-      Position  : Cursor := No_Element) return Cursor\n-   is\n-      K    : Count_Type;\n-      Last : constant Index_Type := Last_Index (Container);\n+      return (if Container.Elements_Ptr = null\n+                then Container.Elements'Unrestricted_Access\n+                else Container.Elements_Ptr);\n+   end Elems;\n \n+   function Elemsc\n+     (Container : Vector) return Elements_Array_Ptr_Const is\n    begin\n-      if Position.Valid then\n-         if Position.Index > Last_Index (Container) then\n-            raise Program_Error with \"Position index is out of range\";\n-         end if;\n-      end if;\n-\n-      K := Count_Type (Int (Position.Index) - Int (No_Index));\n-\n-      for J in Position.Index .. Last loop\n-         if Get_Element (Container, K) = Item then\n-            return Cursor'(Index => J, others => <>);\n-         end if;\n-\n-         K := K + 1;\n-      end loop;\n-\n-      return No_Element;\n-   end Find;\n+      return (if Container.Elements_Ptr = null\n+                then Container.Elements'Unrestricted_Access\n+                else Elements_Array_Ptr_Const (Container.Elements_Ptr));\n+   end Elemsc;\n \n    ----------------\n    -- Find_Index --\n@@ -553,11 +277,11 @@ package body Ada.Containers.Formal_Vectors is\n       Item      : Element_Type;\n       Index     : Index_Type := Index_Type'First) return Extended_Index\n    is\n-      K    : Count_Type;\n+      K    : Capacity_Range;\n       Last : constant Index_Type := Last_Index (Container);\n \n    begin\n-      K := Count_Type (Int (Index) - Int (No_Index));\n+      K := Capacity_Range (Int (Index) - Int (No_Index));\n       for Indx in Index .. Last loop\n          if Get_Element (Container, K) = Item then\n             return Indx;\n@@ -569,19 +293,6 @@ package body Ada.Containers.Formal_Vectors is\n       return No_Index;\n    end Find_Index;\n \n-   -----------\n-   -- First --\n-   -----------\n-\n-   function First (Container : Vector) return Cursor is\n-   begin\n-      if Is_Empty (Container) then\n-         return No_Element;\n-      end if;\n-\n-      return (True, Index_Type'First);\n-   end First;\n-\n    -------------------\n    -- First_Element --\n    -------------------\n@@ -611,24 +322,16 @@ package body Ada.Containers.Formal_Vectors is\n \n    function First_To_Previous\n      (Container : Vector;\n-      Current   : Cursor) return Vector\n+      Current   : Index_Type) return Vector\n    is\n-      C : Vector (Container.Capacity) := Copy (Container, Container.Capacity);\n-\n    begin\n-      if Current = No_Element then\n-         return C;\n-\n-      elsif not Has_Element (Container, Current) then\n-         raise Constraint_Error;\n-\n-      else\n-         while C.Last /= Current.Index - 1 loop\n-            Delete_Last (C);\n+      return Result : Vector\n+        (Count_Type (Current - First_Index (Container)))\n+      do\n+         for X in First_Index (Container) .. Current - 1 loop\n+            Append (Result, Element (Container, X));\n          end loop;\n-\n-         return C;\n-      end if;\n+      end return;\n    end First_To_Previous;\n \n    ---------------------\n@@ -650,9 +353,9 @@ package body Ada.Containers.Formal_Vectors is\n          end if;\n \n          declare\n-            L : constant Count_Type := Length (Container);\n+            L : constant Capacity_Range := Length (Container);\n          begin\n-            for J in Count_Type range 1 .. L - 1 loop\n+            for J in 1 .. L - 1 loop\n                if Get_Element (Container, J + 1) <\n                   Get_Element (Container, J)\n                then\n@@ -664,66 +367,6 @@ package body Ada.Containers.Formal_Vectors is\n          return True;\n       end Is_Sorted;\n \n-      -----------\n-      -- Merge --\n-      -----------\n-\n-      procedure Merge (Target, Source : in out Vector) is\n-      begin\n-         declare\n-            TA : Elements_Array renames Target.Elements;\n-            SA : Elements_Array renames Source.Elements;\n-\n-            I, J : Count_Type;\n-\n-         begin\n-            --  ???\n-            --           if Target.Last < Index_Type'First then\n-            --              Move (Target => Target, Source => Source);\n-            --              return;\n-            --           end if;\n-\n-            if Target'Address = Source'Address then\n-               return;\n-            end if;\n-\n-            if Source.Last < Index_Type'First then\n-               return;\n-            end if;\n-\n-            --  I think we're missing this check in a-convec.adb...  ???\n-\n-            I := Length (Target);\n-            Set_Length (Target, I + Length (Source));\n-\n-            J := Length (Target);\n-            while not Is_Empty (Source) loop\n-               pragma Assert (Length (Source) <= 1\n-                 or else not (SA (Length (Source)) <\n-                     SA (Length (Source) - 1)));\n-\n-               if I = 0 then\n-                  TA (1 .. J) := SA (1 .. Length (Source));\n-                  Source.Last := No_Index;\n-                  return;\n-               end if;\n-\n-               pragma Assert (I <= 1 or else not (TA (I) < TA (I - 1)));\n-\n-               if SA (Length (Source)) < TA (I) then\n-                  TA (J) := TA (I);\n-                  I := I - 1;\n-\n-               else\n-                  TA (J) := SA (Length (Source));\n-                  Source.Last := Source.Last - 1;\n-               end if;\n-\n-               J := J - 1;\n-            end loop;\n-         end;\n-      end Merge;\n-\n       ----------\n       -- Sort --\n       ----------\n@@ -732,17 +375,18 @@ package body Ada.Containers.Formal_Vectors is\n       is\n          procedure Sort is\n            new Generic_Array_Sort\n-             (Index_Type   => Count_Type,\n+             (Index_Type   => Capacity_Range,\n               Element_Type => Element_Type,\n               Array_Type   => Elements_Array,\n               \"<\"          => \"<\");\n \n+         Len : constant Capacity_Range := Length (Container);\n       begin\n          if Container.Last <= Index_Type'First then\n             return;\n          end if;\n \n-         Sort (Container.Elements (1 .. Length (Container)));\n+         Sort (Elems (Container) (1 .. Len));\n       end Sort;\n \n    end Generic_Sorting;\n@@ -753,589 +397,66 @@ package body Ada.Containers.Formal_Vectors is\n \n    function Get_Element\n      (Container : Vector;\n-      Position  : Count_Type) return Element_Type\n+      Position  : Capacity_Range) return Element_Type\n    is\n    begin\n-      return Container.Elements (Position);\n+      return Elemsc (Container) (Position);\n    end Get_Element;\n \n    -----------------\n    -- Has_Element --\n    -----------------\n \n    function Has_Element\n-     (Container : Vector;\n-      Position  : Cursor) return Boolean\n-   is\n+     (Container : Vector; Position : Extended_Index) return Boolean is\n    begin\n-      if not Position.Valid then\n-         return False;\n-      else\n-         return Position.Index <= Last_Index (Container);\n-      end if;\n+      return Position in First_Index (Container) .. Last_Index (Container);\n    end Has_Element;\n \n-   ------------\n-   -- Insert --\n-   ------------\n+   --------------\n+   -- Is_Empty --\n+   --------------\n \n-   procedure Insert\n-     (Container : in out Vector;\n-      Before    : Extended_Index;\n-      New_Item  : Element_Type;\n-      Count     : Count_Type := 1)\n-   is\n-      N : constant Int := Count_Type'Pos (Count);\n+   function Is_Empty (Container : Vector) return Boolean is\n+   begin\n+      return Last_Index (Container) < Index_Type'First;\n+   end Is_Empty;\n \n-      First           : constant Int := Int (Index_Type'First);\n-      New_Last_As_Int : Int'Base;\n-      New_Last        : Index_Type;\n-      New_Length      : UInt;\n-      Max_Length      : constant UInt := UInt (Container.Capacity);\n+   ------------------\n+   -- Last_Element --\n+   ------------------\n \n+   function Last_Element (Container : Vector) return Element_Type is\n    begin\n-      if Before < Index_Type'First then\n-         raise Constraint_Error with\n-           \"Before index is out of range (too small)\";\n+      if Is_Empty (Container) then\n+         raise Constraint_Error with \"Container is empty\";\n       end if;\n \n-      if Before > Container.Last\n-        and then Before > Container.Last + 1\n-      then\n-         raise Constraint_Error with\n-           \"Before index is out of range (too large)\";\n-      end if;\n+      return Get_Element (Container, Length (Container));\n+   end Last_Element;\n \n-      if Count = 0 then\n-         return;\n-      end if;\n+   ----------------\n+   -- Last_Index --\n+   ----------------\n \n-      declare\n-         Old_Last_As_Int : constant Int := Int (Container.Last);\n+   function Last_Index (Container : Vector) return Extended_Index is\n+   begin\n+      return Container.Last;\n+   end Last_Index;\n \n-      begin\n-         if Old_Last_As_Int > Int'Last - N then\n-            raise Constraint_Error with \"new length is out of range\";\n-         end if;\n+   ------------\n+   -- Length --\n+   ------------\n \n-         New_Last_As_Int := Old_Last_As_Int + N;\n-\n-         if New_Last_As_Int > Int (Index_Type'Last) then\n-            raise Constraint_Error with \"new length is out of range\";\n-         end if;\n-\n-         New_Length := UInt (New_Last_As_Int - First + Int'(1));\n-\n-         if New_Length > Max_Length then\n-            raise Constraint_Error with \"new length is out of range\";\n-         end if;\n-\n-         New_Last := Index_Type (New_Last_As_Int);\n-\n-         --  Resolve issue of capacity vs. max index  ???\n-      end;\n-\n-      declare\n-         EA : Elements_Array renames Container.Elements;\n-\n-         BB : constant Int'Base := Int (Before) - Int (No_Index);\n-         B  : constant Count_Type := Count_Type (BB);\n-\n-         LL : constant Int'Base := New_Last_As_Int - Int (No_Index);\n-         L  : constant Count_Type := Count_Type (LL);\n-\n-      begin\n-         if Before <= Container.Last then\n-            declare\n-               II : constant Int'Base := BB + N;\n-               I  : constant Count_Type := Count_Type (II);\n-            begin\n-               EA (I .. L) := EA (B .. Length (Container));\n-               EA (B .. I - 1) := (others => New_Item);\n-            end;\n-\n-         else\n-            EA (B .. L) := (others => New_Item);\n-         end if;\n-      end;\n-\n-      Container.Last := New_Last;\n-   end Insert;\n-\n-   procedure Insert\n-     (Container : in out Vector;\n-      Before    : Extended_Index;\n-      New_Item  : Vector)\n-   is\n-      N : constant Count_Type := Length (New_Item);\n-\n-   begin\n-      if Before < Index_Type'First then\n-         raise Constraint_Error with\n-           \"Before index is out of range (too small)\";\n-      end if;\n-\n-      if Before > Container.Last\n-        and then Before > Container.Last + 1\n-      then\n-         raise Constraint_Error with\n-           \"Before index is out of range (too large)\";\n-      end if;\n-\n-      if N = 0 then\n-         return;\n-      end if;\n-\n-      Insert_Space (Container, Before, Count => N);\n-\n-      declare\n-         Dst_Last_As_Int : constant Int'Base :=\n-           Int (Before) + Int (N) - 1 - Int (No_Index);\n-\n-         Dst_Last : constant Count_Type := Count_Type (Dst_Last_As_Int);\n-\n-         BB : constant Int'Base := Int (Before) - Int (No_Index);\n-         B  : constant Count_Type := Count_Type (BB);\n-\n-      begin\n-         if Container'Address /= New_Item'Address then\n-            Container.Elements (B .. Dst_Last) := New_Item.Elements (1 .. N);\n-            return;\n-         end if;\n-\n-         declare\n-            Src : Elements_Array renames Container.Elements (1 .. B - 1);\n-\n-            Index_As_Int : constant Int'Base := BB + Src'Length - 1;\n-\n-            Index : constant Count_Type := Count_Type (Index_As_Int);\n-\n-            Dst : Elements_Array renames Container.Elements (B .. Index);\n-\n-         begin\n-            Dst := Src;\n-         end;\n-\n-         if Dst_Last = Length (Container) then\n-            return;\n-         end if;\n-\n-         declare\n-            Src : Elements_Array renames\n-                    Container.Elements (Dst_Last + 1 .. Length (Container));\n-\n-            Index_As_Int : constant Int'Base :=\n-              Dst_Last_As_Int - Src'Length + 1;\n-\n-            Index : constant Count_Type := Count_Type (Index_As_Int);\n-\n-            Dst : Elements_Array renames\n-                    Container.Elements (Index .. Dst_Last);\n-\n-         begin\n-            Dst := Src;\n-         end;\n-      end;\n-   end Insert;\n-\n-   procedure Insert\n-     (Container : in out Vector;\n-      Before    : Cursor;\n-      New_Item  : Vector)\n-   is\n-      Index : Index_Type'Base;\n-\n-   begin\n-      if Is_Empty (New_Item) then\n-         return;\n-      end if;\n-\n-      if not Before.Valid\n-        or else Before.Index > Container.Last\n-      then\n-         if Container.Last = Index_Type'Last then\n-            raise Constraint_Error with\n-              \"vector is already at its maximum length\";\n-         end if;\n-\n-         Index := Container.Last + 1;\n-\n-      else\n-         Index := Before.Index;\n-      end if;\n-\n-      Insert (Container, Index, New_Item);\n-   end Insert;\n-\n-   procedure Insert\n-     (Container : in out Vector;\n-      Before    : Cursor;\n-      New_Item  : Vector;\n-      Position  : out Cursor)\n-   is\n-      Index : Index_Type'Base;\n-\n-   begin\n-      if Is_Empty (New_Item) then\n-         if not Before.Valid\n-           or else Before.Index > Container.Last\n-         then\n-            Position := No_Element;\n-         else\n-            Position := (True, Before.Index);\n-         end if;\n-\n-         return;\n-      end if;\n-\n-      if not Before.Valid\n-        or else Before.Index > Container.Last\n-      then\n-         if Container.Last = Index_Type'Last then\n-            raise Constraint_Error with\n-              \"vector is already at its maximum length\";\n-         end if;\n-\n-         Index := Container.Last + 1;\n-\n-      else\n-         Index := Before.Index;\n-      end if;\n-\n-      Insert (Container, Index, New_Item);\n-\n-      Position := Cursor'(True, Index);\n-   end Insert;\n-\n-   procedure Insert\n-     (Container : in out Vector;\n-      Before    : Cursor;\n-      New_Item  : Element_Type;\n-      Count     : Count_Type := 1)\n-   is\n-      Index : Index_Type'Base;\n-\n-   begin\n-      if Count = 0 then\n-         return;\n-      end if;\n-\n-      if not Before.Valid\n-        or else Before.Index > Container.Last\n-      then\n-         if Container.Last = Index_Type'Last then\n-            raise Constraint_Error with\n-              \"vector is already at its maximum length\";\n-         end if;\n-\n-         Index := Container.Last + 1;\n-\n-      else\n-         Index := Before.Index;\n-      end if;\n-\n-      Insert (Container, Index, New_Item, Count);\n-   end Insert;\n-\n-   procedure Insert\n-     (Container : in out Vector;\n-      Before    : Cursor;\n-      New_Item  : Element_Type;\n-      Position  : out Cursor;\n-      Count     : Count_Type := 1)\n-   is\n-      Index : Index_Type'Base;\n-\n-   begin\n-      if Count = 0 then\n-         if not Before.Valid\n-           or else Before.Index > Container.Last\n-         then\n-            Position := No_Element;\n-         else\n-            Position := (True, Before.Index);\n-         end if;\n-\n-         return;\n-      end if;\n-\n-      if not Before.Valid\n-        or else Before.Index > Container.Last\n-      then\n-         if Container.Last = Index_Type'Last then\n-            raise Constraint_Error with\n-              \"vector is already at its maximum length\";\n-         end if;\n-\n-         Index := Container.Last + 1;\n-\n-      else\n-         Index := Before.Index;\n-      end if;\n-\n-      Insert (Container, Index, New_Item, Count);\n-\n-      Position := Cursor'(True, Index);\n-   end Insert;\n-\n-   ------------------\n-   -- Insert_Space --\n-   ------------------\n-\n-   procedure Insert_Space\n-     (Container : in out Vector;\n-      Before    : Extended_Index;\n-      Count     : Count_Type := 1)\n-   is\n-      N : constant Int := Count_Type'Pos (Count);\n-\n-      First           : constant Int := Int (Index_Type'First);\n-      New_Last_As_Int : Int'Base;\n-      New_Last        : Index_Type;\n-      New_Length      : UInt;\n-      Max_Length      : constant UInt := UInt (Count_Type'Last);\n-\n-   begin\n-      if Before < Index_Type'First then\n-         raise Constraint_Error with\n-           \"Before index is out of range (too small)\";\n-      end if;\n-\n-      if Before > Container.Last\n-        and then Before > Container.Last + 1\n-      then\n-         raise Constraint_Error with\n-           \"Before index is out of range (too large)\";\n-      end if;\n-\n-      if Count = 0 then\n-         return;\n-      end if;\n-\n-      declare\n-         Old_Last_As_Int : constant Int := Int (Container.Last);\n-\n-      begin\n-         if Old_Last_As_Int > Int'Last - N then\n-            raise Constraint_Error with \"new length is out of range\";\n-         end if;\n-\n-         New_Last_As_Int := Old_Last_As_Int + N;\n-\n-         if New_Last_As_Int > Int (Index_Type'Last) then\n-            raise Constraint_Error with \"new length is out of range\";\n-         end if;\n-\n-         New_Length := UInt (New_Last_As_Int - First + Int'(1));\n-\n-         if New_Length > Max_Length then\n-            raise Constraint_Error with \"new length is out of range\";\n-         end if;\n-\n-         New_Last := Index_Type (New_Last_As_Int);\n-\n-         --  Resolve issue of capacity vs. max index  ???\n-      end;\n-\n-      declare\n-         EA : Elements_Array renames Container.Elements;\n-\n-         BB : constant Int'Base := Int (Before) - Int (No_Index);\n-         B  : constant Count_Type := Count_Type (BB);\n-\n-         LL : constant Int'Base := New_Last_As_Int - Int (No_Index);\n-         L  : constant Count_Type := Count_Type (LL);\n-\n-      begin\n-         if Before <= Container.Last then\n-            declare\n-               II : constant Int'Base := BB + N;\n-               I  : constant Count_Type := Count_Type (II);\n-            begin\n-               EA (I .. L) := EA (B .. Length (Container));\n-            end;\n-         end if;\n-      end;\n-\n-      Container.Last := New_Last;\n-   end Insert_Space;\n-\n-   --------------\n-   -- Is_Empty --\n-   --------------\n-\n-   function Is_Empty (Container : Vector) return Boolean is\n-   begin\n-      return Last_Index (Container) < Index_Type'First;\n-   end Is_Empty;\n-\n-   ----------\n-   -- Last --\n-   ----------\n-\n-   function Last (Container : Vector) return Cursor is\n-   begin\n-      if Is_Empty (Container) then\n-         return No_Element;\n-      end if;\n-\n-      return (True, Last_Index (Container));\n-   end Last;\n-\n-   ------------------\n-   -- Last_Element --\n-   ------------------\n-\n-   function Last_Element (Container : Vector) return Element_Type is\n-   begin\n-      if Is_Empty (Container) then\n-         raise Constraint_Error with \"Container is empty\";\n-      end if;\n-\n-      return Get_Element (Container, Length (Container));\n-   end Last_Element;\n-\n-   ----------------\n-   -- Last_Index --\n-   ----------------\n-\n-   function Last_Index (Container : Vector) return Extended_Index is\n-   begin\n-      return Container.Last;\n-   end Last_Index;\n-\n-   ------------\n-   -- Length --\n-   ------------\n-\n-   function Length (Container : Vector) return Count_Type is\n+   function Length (Container : Vector) return Capacity_Range is\n       L : constant Int := Int (Last_Index (Container));\n       F : constant Int := Int (Index_Type'First);\n       N : constant Int'Base := L - F + 1;\n \n    begin\n-      return Count_Type (N);\n+      return Capacity_Range (N);\n    end Length;\n \n-   ----------\n-   -- Move --\n-   ----------\n-\n-   procedure Move\n-     (Target : in out Vector;\n-      Source : in out Vector)\n-   is\n-      N : constant Count_Type := Length (Source);\n-\n-   begin\n-      if Target'Address = Source'Address then\n-         return;\n-      end if;\n-\n-      if N > Target.Capacity then\n-         raise Constraint_Error with  -- correct exception here???\n-           \"length of Source is greater than capacity of Target\";\n-      end if;\n-\n-      --  We could also write this as a loop, and incrementally\n-      --  copy elements from source to target.\n-\n-      Target.Last := No_Index;  -- in case array assignment files\n-      Target.Elements (1 .. N) := Source.Elements (1 .. N);\n-\n-      Target.Last := Source.Last;\n-      Source.Last := No_Index;\n-   end Move;\n-\n-   ----------\n-   -- Next --\n-   ----------\n-\n-   function Next (Container : Vector; Position : Cursor) return Cursor is\n-   begin\n-      if not Position.Valid then\n-         return No_Element;\n-      end if;\n-\n-      if Position.Index < Last_Index (Container) then\n-         return (True, Position.Index + 1);\n-      end if;\n-\n-      return No_Element;\n-   end Next;\n-\n-   ----------\n-   -- Next --\n-   ----------\n-\n-   procedure Next (Container : Vector; Position : in out Cursor) is\n-   begin\n-      if not Position.Valid then\n-         return;\n-      end if;\n-\n-      if Position.Index < Last_Index (Container) then\n-         Position.Index := Position.Index + 1;\n-      else\n-         Position := No_Element;\n-      end if;\n-   end Next;\n-\n-   -------------\n-   -- Prepend --\n-   -------------\n-\n-   procedure Prepend (Container : in out Vector; New_Item : Vector) is\n-   begin\n-      Insert (Container, Index_Type'First, New_Item);\n-   end Prepend;\n-\n-   procedure Prepend\n-     (Container : in out Vector;\n-      New_Item  : Element_Type;\n-      Count     : Count_Type := 1)\n-   is\n-   begin\n-      Insert (Container,\n-              Index_Type'First,\n-              New_Item,\n-              Count);\n-   end Prepend;\n-\n-   --------------\n-   -- Previous --\n-   --------------\n-\n-   procedure Previous (Container : Vector; Position : in out Cursor) is\n-   begin\n-      if not Position.Valid then\n-         return;\n-      end if;\n-\n-      if Position.Index > Index_Type'First\n-        and then Position.Index <= Last_Index (Container)\n-      then\n-         Position.Index := Position.Index - 1;\n-      else\n-         Position := No_Element;\n-      end if;\n-   end Previous;\n-\n-   function Previous (Container : Vector; Position : Cursor) return Cursor is\n-   begin\n-      if not Position.Valid then\n-         return No_Element;\n-      end if;\n-\n-      if Position.Index > Index_Type'First\n-        and then Position.Index <= Last_Index (Container)\n-      then\n-         return (True, Position.Index - 1);\n-      end if;\n-\n-      return No_Element;\n-   end Previous;\n-\n    ---------------------\n    -- Replace_Element --\n    ---------------------\n@@ -1352,32 +473,10 @@ package body Ada.Containers.Formal_Vectors is\n \n       declare\n          II : constant Int'Base := Int (Index) - Int (No_Index);\n-         I  : constant Count_Type := Count_Type (II);\n+         I  : constant Capacity_Range := Capacity_Range (II);\n \n       begin\n-         Container.Elements (I) := New_Item;\n-      end;\n-   end Replace_Element;\n-\n-   procedure Replace_Element\n-     (Container : in out Vector;\n-      Position  : Cursor;\n-      New_Item  : Element_Type)\n-   is\n-   begin\n-      if not Position.Valid then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      if Position.Index > Container.Last then\n-         raise Constraint_Error with \"Position cursor is out of range\";\n-      end if;\n-\n-      declare\n-         II : constant Int'Base := Int (Position.Index) - Int (No_Index);\n-         I  : constant Count_Type := Count_Type (II);\n-      begin\n-         Container.Elements (I) := New_Item;\n+         Elems (Container) (I) := New_Item;\n       end;\n    end Replace_Element;\n \n@@ -1387,11 +486,25 @@ package body Ada.Containers.Formal_Vectors is\n \n    procedure Reserve_Capacity\n      (Container : in out Vector;\n-      Capacity  : Count_Type)\n+      Capacity  : Capacity_Range)\n    is\n    begin\n-      if Capacity > Container.Capacity then\n-         raise Constraint_Error with \"Capacity is out of range\";\n+      if Bounded then\n+         if Capacity > Container.Capacity then\n+            raise Constraint_Error with \"Capacity is out of range\";\n+         end if;\n+      else\n+         if Capacity > Formal_Vectors.Capacity (Container) then\n+            declare\n+               New_Elements : constant Elements_Array_Ptr :=\n+                 new Elements_Array (1 .. Capacity);\n+               L : constant Capacity_Range := Length (Container);\n+            begin\n+               New_Elements (1 .. L) := Elemsc (Container) (1 .. L);\n+               Free (Container.Elements_Ptr);\n+               Container.Elements_Ptr := New_Elements;\n+            end;\n+         end if;\n       end if;\n    end Reserve_Capacity;\n \n@@ -1406,8 +519,8 @@ package body Ada.Containers.Formal_Vectors is\n       end if;\n \n       declare\n-         I, J : Count_Type;\n-         E    : Elements_Array renames Container.Elements;\n+         I, J : Capacity_Range;\n+         E    : Elements_Array renames Elems (Container).all;\n \n       begin\n          I := 1;\n@@ -1426,39 +539,6 @@ package body Ada.Containers.Formal_Vectors is\n       end;\n    end Reverse_Elements;\n \n-   ------------------\n-   -- Reverse_Find --\n-   ------------------\n-\n-   function Reverse_Find\n-     (Container : Vector;\n-      Item      : Element_Type;\n-      Position  : Cursor := No_Element) return Cursor\n-   is\n-      Last : Index_Type'Base;\n-      K    : Count_Type;\n-\n-   begin\n-      if not Position.Valid\n-        or else Position.Index > Last_Index (Container)\n-      then\n-         Last := Last_Index (Container);\n-      else\n-         Last := Position.Index;\n-      end if;\n-\n-      K := Count_Type (Int (Last) - Int (No_Index));\n-      for Indx in reverse Index_Type'First .. Last loop\n-         if Get_Element (Container, K) = Item then\n-            return (True, Indx);\n-         end if;\n-\n-         K := K - 1;\n-      end loop;\n-\n-      return No_Element;\n-   end Reverse_Find;\n-\n    ------------------------\n    -- Reverse_Find_Index --\n    ------------------------\n@@ -1469,7 +549,7 @@ package body Ada.Containers.Formal_Vectors is\n       Index     : Index_Type := Index_Type'Last) return Extended_Index\n    is\n       Last : Index_Type'Base;\n-      K    : Count_Type;\n+      K    : Capacity_Range;\n \n    begin\n       if Index > Last_Index (Container) then\n@@ -1478,7 +558,7 @@ package body Ada.Containers.Formal_Vectors is\n          Last := Index;\n       end if;\n \n-      K := Count_Type (Int (Last) - Int (No_Index));\n+      K := Capacity_Range (Int (Last) - Int (No_Index));\n       for Indx in reverse Index_Type'First .. Last loop\n          if Get_Element (Container, K) = Item then\n             return Indx;\n@@ -1490,44 +570,6 @@ package body Ada.Containers.Formal_Vectors is\n       return No_Index;\n    end Reverse_Find_Index;\n \n-   ----------------\n-   -- Set_Length --\n-   ----------------\n-\n-   procedure Set_Length\n-     (Container : in out Vector;\n-      New_Length    : Count_Type)\n-   is\n-   begin\n-      if New_Length = Formal_Vectors.Length (Container) then\n-         return;\n-      end if;\n-\n-      if New_Length > Container.Capacity then\n-         raise Constraint_Error;  -- ???\n-      end if;\n-\n-      declare\n-         Last_As_Int : constant Int'Base :=\n-           Int (Index_Type'First) + Int (New_Length) - 1;\n-      begin\n-         Container.Last := Index_Type'Base (Last_As_Int);\n-      end;\n-   end Set_Length;\n-\n-   ------------------\n-   -- Strict_Equal --\n-   ------------------\n-\n-   function Strict_Equal (Left, Right : Vector) return Boolean is\n-   begin\n-      --  On bounded vectors, cursors are indexes. As a consequence, two\n-      --  vectors always have the same cursor at the same position and\n-      --  Strict_Equal is simply =\n-\n-      return Left = Right;\n-   end Strict_Equal;\n-\n    ----------\n    -- Swap --\n    ----------\n@@ -1550,8 +592,8 @@ package body Ada.Containers.Formal_Vectors is\n          II : constant Int'Base := Int (I) - Int (No_Index);\n          JJ : constant Int'Base := Int (J) - Int (No_Index);\n \n-         EI : Element_Type renames Container.Elements (Count_Type (II));\n-         EJ : Element_Type renames Container.Elements (Count_Type (JJ));\n+         EI : Element_Type renames Elems (Container) (Capacity_Range (II));\n+         EJ : Element_Type renames Elems (Container) (Capacity_Range (JJ));\n \n          EI_Copy : constant Element_Type := EI;\n \n@@ -1561,55 +603,13 @@ package body Ada.Containers.Formal_Vectors is\n       end;\n    end Swap;\n \n-   procedure Swap (Container : in out Vector; I, J : Cursor) is\n-   begin\n-      if not I.Valid then\n-         raise Constraint_Error with \"I cursor has no element\";\n-      end if;\n-\n-      if not J.Valid then\n-         raise Constraint_Error with \"J cursor has no element\";\n-      end if;\n-\n-      Swap (Container, I.Index, J.Index);\n-   end Swap;\n-\n-   ---------------\n-   -- To_Cursor --\n-   ---------------\n-\n-   function To_Cursor\n-     (Container : Vector;\n-      Index     : Extended_Index) return Cursor\n-   is\n-   begin\n-      if Index not in Index_Type'First .. Last_Index (Container) then\n-         return No_Element;\n-      end if;\n-\n-      return Cursor'(True, Index);\n-   end To_Cursor;\n-\n-   --------------\n-   -- To_Index --\n-   --------------\n-\n-   function To_Index (Position : Cursor) return Extended_Index is\n-   begin\n-      if not Position.Valid then\n-         return No_Index;\n-      end if;\n-\n-      return Position.Index;\n-   end To_Index;\n-\n    ---------------\n    -- To_Vector --\n    ---------------\n \n    function To_Vector\n      (New_Item : Element_Type;\n-      Length   : Count_Type) return Vector\n+      Length   : Capacity_Range) return Vector\n    is\n    begin\n       if Length = 0 then"}, {"sha": "cff122a89543be197ac512c06c9063ab960d4cb5", "filename": "gcc/ada/a-cofove.ads", "status": "modified", "additions": 67, "deletions": 285, "changes": 352, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a68b7c4d594e082b32da7e76a7cd7a472abb5de/gcc%2Fada%2Fa-cofove.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a68b7c4d594e082b32da7e76a7cd7a472abb5de/gcc%2Fada%2Fa-cofove.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofove.ads?ref=4a68b7c4d594e082b32da7e76a7cd7a472abb5de", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -35,38 +35,19 @@\n --  unit compatible with SPARK 2014. Note that the API of this unit may be\n --  subject to incompatible changes as SPARK 2014 evolves.\n \n---  The modifications are:\n-\n---    A parameter for the container is added to every function reading the\n---    content of a container: Element, Next, Query_Element, Previous, Iterate,\n---    Has_Element, Reverse_Iterate. This change is motivated by the need\n---    to have cursors which are valid on different containers (typically a\n---    container C and its previous version C'Old) for expressing properties,\n---    which is not possible if cursors encapsulate an access to the underlying\n---    container.\n-\n---    There are three new functions:\n-\n---      function Strict_Equal (Left, Right : Vector) return Boolean;\n---      function First_To_Previous  (Container : Vector; Current : Cursor)\n---         return Vector;\n---      function Current_To_Last (Container : Vector; Current : Cursor)\n---         return Vector;\n-\n---    See detailed specifications for these subprograms\n-\n-with Ada.Containers;\n-use Ada.Containers;\n-\n generic\n    type Index_Type is range <>;\n    type Element_Type is private;\n \n    with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n \n+   Bounded : Boolean := True;\n+   --  If True, the containers are bounded; the initial capacity is the maximum\n+   --  size, and heap allocation will be avoided. If False, the containers can\n+   --  grow via heap allocation.\n+\n package Ada.Containers.Formal_Vectors is\n    pragma Annotate (GNATprove, External_Axiomatization);\n-   pragma Pure;\n \n    subtype Extended_Index is Index_Type'Base\n    range Index_Type'First - 1 ..\n@@ -77,248 +58,95 @@ package Ada.Containers.Formal_Vectors is\n    subtype Capacity_Range is\n      Count_Type range 0 .. Count_Type (Index_Type'Last - Index_Type'First + 1);\n \n-   type Vector (Capacity : Capacity_Range) is private with\n-     Iterable => (First       => First,\n-                  Next        => Next,\n-                  Has_Element => Has_Element,\n-                  Element     => Element),\n+   type Vector (Capacity : Capacity_Range) is limited private with\n      Default_Initial_Condition;\n-\n-   type Cursor is private;\n-   pragma Preelaborable_Initialization (Cursor);\n-\n-   Empty_Vector : constant Vector;\n-\n-   No_Element : constant Cursor;\n+   --  In the bounded case, Capacity is the capacity of the container, which\n+   --  never changes. In the unbounded case, Capacity is the initial capacity\n+   --  of the container, and operations such as Reserve_Capacity and Append can\n+   --  increase the capacity. The capacity never shrinks, except in the case of\n+   --  Clear.\n+   --\n+   --  Note that all objects of type Vector are constrained, including in the\n+   --  unbounded case; you can't assign from one object to another if the\n+   --  Capacity is different.\n+\n+   function Empty_Vector return Vector;\n \n    function \"=\" (Left, Right : Vector) return Boolean with\n      Global => null;\n \n    function To_Vector\n      (New_Item : Element_Type;\n-      Length   : Count_Type) return Vector\n+      Length   : Capacity_Range) return Vector\n    with\n      Global => null;\n \n-   function \"&\" (Left, Right : Vector) return Vector with\n-     Global => null,\n-     Pre    => Capacity_Range'Last - Length (Left) >= Length (Right);\n-\n-   function \"&\" (Left : Vector; Right : Element_Type) return Vector with\n-     Global => null,\n-     Pre    => Length (Left) < Capacity_Range'Last;\n-\n-   function \"&\" (Left : Element_Type; Right : Vector) return Vector with\n-     Global => null,\n-     Pre    => Length (Right) < Capacity_Range'Last;\n-\n-   function \"&\" (Left, Right : Element_Type) return Vector with\n-     Global => null,\n-     Pre    => Capacity_Range'Last >= 2;\n-\n-   function Capacity (Container : Vector) return Count_Type with\n+   function Capacity (Container : Vector) return Capacity_Range with\n      Global => null;\n \n    procedure Reserve_Capacity\n      (Container : in out Vector;\n-      Capacity  : Count_Type)\n+      Capacity  : Capacity_Range)\n    with\n      Global => null,\n-     Pre    => Capacity <= Container.Capacity;\n+     Pre    => (if Bounded then Capacity <= Container.Capacity);\n \n-   function Length (Container : Vector) return Count_Type with\n+   function Length (Container : Vector) return Capacity_Range with\n      Global => null;\n \n-   procedure Set_Length\n-     (Container : in out Vector;\n-      New_Length    : Count_Type)\n-   with\n-     Global => null,\n-     Pre    => New_Length <= Length (Container);\n-\n    function Is_Empty (Container : Vector) return Boolean with\n      Global => null;\n \n    procedure Clear (Container : in out Vector) with\n      Global => null;\n+   --  Note that this reclaims storage in the unbounded case. You need to call\n+   --  this before a container goes out of scope in order to avoid storage\n+   --  leaks. In addition, \"X := ...\" can leak unless you Clear(X) first.\n \n    procedure Assign (Target : in out Vector; Source : Vector) with\n      Global => null,\n-     Pre    => Length (Source) <= Target.Capacity;\n+     Pre    => (if Bounded then Length (Source) <= Target.Capacity);\n \n    function Copy\n      (Source   : Vector;\n-      Capacity : Count_Type := 0) return Vector\n+      Capacity : Capacity_Range := 0) return Vector\n    with\n      Global => null,\n-     Pre    => Length (Source) <= Capacity and then Capacity in Capacity_Range;\n-\n-   function To_Cursor\n-     (Container : Vector;\n-      Index     : Extended_Index) return Cursor\n-   with\n-     Global => null;\n-\n-   function To_Index (Position : Cursor) return Extended_Index with\n-     Global => null;\n+     Pre    => (if Bounded then Length (Source) <= Capacity);\n \n    function Element\n      (Container : Vector;\n       Index     : Index_Type) return Element_Type\n    with\n      Global => null,\n-     Pre    => First_Index (Container) <= Index\n-                 and then Index <= Last_Index (Container);\n-\n-   function Element\n-     (Container : Vector;\n-      Position  : Cursor) return Element_Type\n-   with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position);\n+     Pre    => Index in First_Index (Container) .. Last_Index (Container);\n \n    procedure Replace_Element\n      (Container : in out Vector;\n       Index     : Index_Type;\n       New_Item  : Element_Type)\n    with\n      Global => null,\n-     Pre    => First_Index (Container) <= Index\n-                 and then Index <= Last_Index (Container);\n-\n-   procedure Replace_Element\n-     (Container : in out Vector;\n-      Position  : Cursor;\n-      New_Item  : Element_Type)\n-   with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position);\n-\n-   procedure Move (Target : in out Vector; Source : in out Vector) with\n-     Global => null,\n-     Pre    => Length (Source) <= Target.Capacity;\n-\n-   procedure Insert\n-     (Container : in out Vector;\n-      Before    : Extended_Index;\n-      New_Item  : Vector)\n-   with\n-     Global => null,\n-     Pre    => First_Index (Container) <= Before\n-                 and then Before <= Last_Index (Container) + 1\n-                 and then Length (Container) < Container.Capacity;\n-\n-   procedure Insert\n-     (Container : in out Vector;\n-      Before    : Cursor;\n-      New_Item  : Vector)\n-   with\n-     Global => null,\n-     Pre    => Length (Container) < Container.Capacity\n-                 and then (Has_Element (Container, Before)\n-                            or else Before = No_Element);\n-\n-   procedure Insert\n-     (Container : in out Vector;\n-      Before    : Cursor;\n-      New_Item  : Vector;\n-      Position  : out Cursor)\n-   with\n-     Global => null,\n-     Pre    => Length (Container) < Container.Capacity\n-                 and then (Has_Element (Container, Before)\n-                            or else Before = No_Element);\n-\n-   procedure Insert\n-     (Container : in out Vector;\n-      Before    : Extended_Index;\n-      New_Item  : Element_Type;\n-      Count     : Count_Type := 1)\n-   with\n-     Global => null,\n-     Pre    => First_Index (Container) <= Before\n-                 and then Before <= Last_Index (Container) + 1\n-                 and then Length (Container) + Count <= Container.Capacity;\n-\n-   procedure Insert\n-     (Container : in out Vector;\n-      Before    : Cursor;\n-      New_Item  : Element_Type;\n-      Count     : Count_Type := 1)\n-   with\n-     Global => null,\n-     Pre    => Length (Container) + Count <= Container.Capacity\n-                 and then (Has_Element (Container, Before)\n-                            or else Before = No_Element);\n-\n-   procedure Insert\n-     (Container : in out Vector;\n-      Before    : Cursor;\n-      New_Item  : Element_Type;\n-      Position  : out Cursor;\n-      Count     : Count_Type := 1)\n-   with\n-     Global => null,\n-     Pre    => Length (Container) + Count <= Container.Capacity\n-                 and then (Has_Element (Container, Before)\n-                            or else Before = No_Element);\n-\n-   procedure Prepend\n-     (Container : in out Vector;\n-      New_Item  : Vector)\n-   with\n-     Global => null,\n-     Pre    => Length (Container) < Container.Capacity;\n-\n-   procedure Prepend\n-     (Container : in out Vector;\n-      New_Item  : Element_Type;\n-      Count     : Count_Type := 1)\n-   with\n-     Global => null,\n-     Pre    => Length (Container) + Count <= Container.Capacity;\n+     Pre    => Index in First_Index (Container) .. Last_Index (Container);\n \n    procedure Append\n      (Container : in out Vector;\n       New_Item  : Vector)\n    with\n      Global => null,\n-     Pre    => Length (Container) < Container.Capacity;\n+     Pre    => (if Bounded then\n+                 Length (Container) + Length (New_Item) <= Container.Capacity);\n \n    procedure Append\n      (Container : in out Vector;\n-      New_Item  : Element_Type;\n-      Count     : Count_Type := 1)\n-   with\n-     Global => null,\n-     Pre    => Length (Container) + Count <= Container.Capacity;\n-\n-   procedure Delete\n-     (Container : in out Vector;\n-      Index     : Extended_Index;\n-      Count     : Count_Type := 1)\n-   with\n-     Global => null,\n-     Pre    => First_Index (Container) <= Index\n-                 and then Index <= Last_Index (Container) + 1;\n-\n-   procedure Delete\n-     (Container : in out Vector;\n-      Position  : in out Cursor;\n-      Count     : Count_Type := 1)\n+      New_Item  : Element_Type)\n    with\n      Global => null,\n-     Pre    => Has_Element (Container, Position);\n-\n-   procedure Delete_First\n-     (Container : in out Vector;\n-      Count     : Count_Type := 1)\n-   with\n-     Global => null;\n+     Pre    => (if Bounded then\n+                  Length (Container) < Container.Capacity);\n \n    procedure Delete_Last\n-     (Container : in out Vector;\n-      Count     : Count_Type := 1)\n+     (Container : in out Vector)\n    with\n      Global => null;\n \n@@ -327,89 +155,45 @@ package Ada.Containers.Formal_Vectors is\n \n    procedure Swap (Container : in out Vector; I, J : Index_Type) with\n      Global => null,\n-     Pre    => First_Index (Container) <= I\n-                 and then I <= Last_Index (Container)\n-                 and then First_Index (Container) <= J\n-                 and then J <= Last_Index (Container);\n-\n-   procedure Swap (Container : in out Vector; I, J : Cursor) with\n-     Global => null,\n-     Pre    => Has_Element (Container, I) and then Has_Element (Container, J);\n+     Pre    => I in First_Index (Container) .. Last_Index (Container)\n+      and then J in First_Index (Container) .. Last_Index (Container);\n \n    function First_Index (Container : Vector) return Index_Type with\n      Global => null;\n \n-   function First (Container : Vector) return Cursor with\n-     Global => null;\n-\n    function First_Element (Container : Vector) return Element_Type with\n      Global => null,\n      Pre    => not Is_Empty (Container);\n \n    function Last_Index (Container : Vector) return Extended_Index with\n      Global => null;\n \n-   function Last (Container : Vector) return Cursor with\n-     Global => null;\n-\n    function Last_Element (Container : Vector) return Element_Type with\n      Global => null,\n      Pre    => not Is_Empty (Container);\n \n-   function Next (Container : Vector; Position : Cursor) return Cursor with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n-\n-   procedure Next (Container : Vector; Position : in out Cursor) with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n-\n-   function Previous (Container : Vector; Position : Cursor) return Cursor with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n-\n-   procedure Previous (Container : Vector; Position : in out Cursor) with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n-\n    function Find_Index\n      (Container : Vector;\n       Item      : Element_Type;\n       Index     : Index_Type := Index_Type'First) return Extended_Index\n    with\n      Global => null;\n \n-   function Find\n-     (Container : Vector;\n-      Item      : Element_Type;\n-      Position  : Cursor := No_Element) return Cursor\n-   with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n-\n    function Reverse_Find_Index\n      (Container : Vector;\n       Item      : Element_Type;\n       Index     : Index_Type := Index_Type'Last) return Extended_Index\n    with\n      Global => null;\n \n-   function Reverse_Find\n-     (Container : Vector;\n-      Item      : Element_Type;\n-      Position  : Cursor := No_Element) return Cursor\n-   with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n-\n    function Contains\n      (Container : Vector;\n       Item      : Element_Type) return Boolean\n    with\n      Global => null;\n \n-   function Has_Element (Container : Vector; Position : Cursor) return Boolean\n-   with\n+   function Has_Element\n+     (Container : Vector; Position : Extended_Index) return Boolean with\n      Global => null;\n \n    generic\n@@ -422,29 +206,18 @@ package Ada.Containers.Formal_Vectors is\n       procedure Sort (Container : in out Vector) with\n         Global => null;\n \n-      procedure Merge (Target : in out Vector; Source : in out Vector) with\n-        Global => null;\n-\n    end Generic_Sorting;\n \n-   function Strict_Equal (Left, Right : Vector) return Boolean with\n-     Global => null;\n-   --  Strict_Equal returns True if the containers are physically equal, i.e.\n-   --  they are structurally equal (function \"=\" returns True) and that they\n-   --  have the same set of cursors.\n-\n    function First_To_Previous\n      (Container : Vector;\n-      Current : Cursor) return Vector\n+      Current : Index_Type) return Vector\n    with\n-     Global => null,\n-     Pre    => Has_Element (Container, Current) or else Current = No_Element;\n+     Global => null;\n    function Current_To_Last\n      (Container : Vector;\n-      Current : Cursor) return Vector\n+      Current : Index_Type) return Vector\n    with\n-     Global => null,\n-     Pre    => Has_Element (Container, Current) or else Current = No_Element;\n+     Global => null;\n    --  First_To_Previous returns a container containing all elements preceding\n    --  Current (excluded) in Container. Current_To_Last returns a container\n    --  containing all elements following Current (included) in Container.\n@@ -462,24 +235,33 @@ private\n    pragma Inline (Last_Element);\n    pragma Inline (Replace_Element);\n    pragma Inline (Contains);\n-   pragma Inline (Next);\n-   pragma Inline (Previous);\n \n-   type Elements_Array is array (Count_Type range <>) of Element_Type;\n+   type Elements_Array is array (Capacity_Range range <>) of Element_Type;\n    function \"=\" (L, R : Elements_Array) return Boolean is abstract;\n \n-   type Vector (Capacity : Capacity_Range) is record\n-      Elements : Elements_Array (1 .. Capacity);\n-      Last     : Extended_Index := No_Index;\n-   end record;\n+   type Elements_Array_Ptr is access all Elements_Array;\n \n-   type Cursor is record\n-      Valid : Boolean    := True;\n-      Index : Index_Type := Index_Type'First;\n+   type Vector (Capacity : Capacity_Range) is limited record\n+      --  In the bounded case, the elements are stored in Elements. In the\n+      --  unbounded case, the elements are initially stored in Elements, until\n+      --  we run out of room, then we switch to Elements_Ptr.\n+      Elements     : aliased Elements_Array (1 .. Capacity);\n+      Last         : Extended_Index := No_Index;\n+      Elements_Ptr : Elements_Array_Ptr := null;\n    end record;\n \n-   Empty_Vector : constant Vector := (Capacity => 0, others => <>);\n-\n-   No_Element : constant Cursor := (Valid => False, Index => Index_Type'First);\n+   --  The primary reason Vector is limited is that in the unbounded case, once\n+   --  Elements_Ptr is in use, assignment statements won't work. \"X := Y;\" will\n+   --  cause X and Y to share state; that is, X.Elements_Ptr = Y.Elements_Ptr,\n+   --  so for example \"Append (X, ...);\" will modify BOTH X and Y. That would\n+   --  allow SPARK to \"prove\" things that are false. We could fix that by\n+   --  making Vector a controlled type, and override Adjust to make a deep\n+   --  copy, but finalization is not allowed in SPARK.\n+   --\n+   --  Note that (unfortunately) this means that 'Old and 'Loop_Entry are not\n+   --  allowed on Vectors.\n+\n+   function Empty_Vector return Vector is\n+     ((Capacity => 0, others => <>));\n \n end Ada.Containers.Formal_Vectors;"}, {"sha": "e0f6b3fcf3b7205d2449144976733cee8f282ba5", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a68b7c4d594e082b32da7e76a7cd7a472abb5de/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a68b7c4d594e082b32da7e76a7cd7a472abb5de/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=4a68b7c4d594e082b32da7e76a7cd7a472abb5de", "patch": "@@ -542,6 +542,8 @@ The GNAT Library\n * Ada.Containers.Formal_Ordered_Maps (a-cforma.ads)::\n * Ada.Containers.Formal_Ordered_Sets (a-cforse.ads)::\n * Ada.Containers.Formal_Vectors (a-cofove.ads)::\n+* Ada.Containers.Formal_Indefinite_Vectors (a-cfinve.ads)::\n+* Ada.Containers.Bounded_Holders (a-coboho.ads)::\n * Ada.Command_Line.Environment (a-colien.ads)::\n * Ada.Command_Line.Remove (a-colire.ads)::\n * Ada.Command_Line.Response_File (a-clrefi.ads)::\n@@ -5165,6 +5167,10 @@ subranges) for unordered types. If this switch is used, then any\n enumeration type not marked with pragma @code{Ordered} will be considered\n as unordered, and will generate warnings for inappropriate uses.\n \n+Note that generic types are not considered ordered or unordered (since the\n+template can be instantiated for both cases), so we never generate warnings\n+for the case of generic enumerated types.\n+\n For additional information please refer to the description of the\n @option{-gnatw.u} switch in the @value{EDITION} User's Guide.\n \n@@ -19022,6 +19028,8 @@ of GNAT, and will generate a warning message.\n * Ada.Containers.Formal_Ordered_Maps (a-cforma.ads)::\n * Ada.Containers.Formal_Ordered_Sets (a-cforse.ads)::\n * Ada.Containers.Formal_Vectors (a-cofove.ads)::\n+* Ada.Containers.Formal_Indefinite_Vectors (a-cfinve.ads)::\n+* Ada.Containers.Bounded_Holders (a-coboho.ads)::\n * Ada.Command_Line.Environment (a-colien.ads)::\n * Ada.Command_Line.Remove (a-colire.ads)::\n * Ada.Command_Line.Response_File (a-clrefi.ads)::\n@@ -19325,6 +19333,31 @@ in mind, it may well be generally useful in that it is a simplified more\n efficient version than the one defined in the standard. In particular it\n does not have the complex overhead required to detect cursor tampering.\n \n+@node Ada.Containers.Formal_Indefinite_Vectors (a-cfinve.ads)\n+@section @code{Ada.Containers.Formal_Indefinite_Vectors} (@file{a-cfinve.ads})\n+@cindex @code{Ada.Containers.Formal_Indefinite_Vectors} (@file{a-cfinve.ads})\n+@cindex Formal container for vectors\n+\n+@noindent\n+This child of @code{Ada.Containers} defines a modified version of the\n+Ada 2005 container for vectors of indefinite elements, meant to\n+facilitate formal verification of code using such containers. The\n+specification of this unit is compatible with SPARK 2014.\n+\n+Note that although this container was designed with formal verification\n+in mind, it may well be generally useful in that it is a simplified more\n+efficient version than the one defined in the standard. In particular it\n+does not have the complex overhead required to detect cursor tampering.\n+\n+@node Ada.Containers.Bounded_Holders (a-coboho.ads)\n+@section @code{Ada.Containers.Bounded_Holders} (@file{a-coboho.ads})\n+@cindex @code{Ada.Containers.Bounded_Holders} (@file{a-coboho.ads})\n+@cindex Formal container for vectors\n+\n+@noindent\n+This child of @code{Ada.Containers} defines a modified version of\n+Indefinite_Holders that avoids heap allocation.\n+\n @node Ada.Command_Line.Environment (a-colien.ads)\n @section @code{Ada.Command_Line.Environment} (@file{a-colien.ads})\n @cindex @code{Ada.Command_Line.Environment} (@file{a-colien.ads})"}, {"sha": "ca53594fa7ccab1227ec10750fa8927c6fb29387", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a68b7c4d594e082b32da7e76a7cd7a472abb5de/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a68b7c4d594e082b32da7e76a7cd7a472abb5de/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=4a68b7c4d594e082b32da7e76a7cd7a472abb5de", "patch": "@@ -581,6 +581,8 @@ package body Impunit is\n    -- GNAT Defined Additions to Ada 2012 --\n    ----------------------------------------\n \n+    (\"a-cfinve\", F),  -- Ada.Containers.Formal_Indefinite_Vectors\n+    (\"a-coboho\", F),  -- Ada.Containers.Bounded_Holders\n     (\"a-cofove\", F),  -- Ada.Containers.Formal_Vectors\n     (\"a-cfdlli\", F),  -- Ada.Containers.Formal_Doubly_Linked_Lists\n     (\"a-cforse\", F),  -- Ada.Containers.Formal_Ordered_Sets"}, {"sha": "8d4e3d46d918e67831187d1d8d07938df4317d54", "filename": "gcc/ada/prj-conf.adb", "status": "modified", "additions": 25, "deletions": 15, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a68b7c4d594e082b32da7e76a7cd7a472abb5de/gcc%2Fada%2Fprj-conf.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a68b7c4d594e082b32da7e76a7cd7a472abb5de/gcc%2Fada%2Fprj-conf.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-conf.adb?ref=4a68b7c4d594e082b32da7e76a7cd7a472abb5de", "patch": "@@ -1101,21 +1101,21 @@ package body Prj.Conf is\n                Args (3) := Conf_File_Name;\n             end if;\n \n-            if Normalized_Hostname = \"\" then\n-               Arg_Last := 3;\n-            else\n-               if Selected_Target'Length = 0 then\n-                  if At_Least_One_Compiler_Command then\n-                     Args (4) :=\n-                       new String'(\"--target=all\");\n-                  else\n-                     Args (4) :=\n-                       new String'(\"--target=\" & Normalized_Hostname);\n-                  end if;\n+            Arg_Last := 3;\n \n+            if Selected_Target /= null and then\n+               Selected_Target.all /= \"\"\n+            then\n+               Args (4) :=\n+                  new String'(\"--target=\" & Selected_Target.all);\n+               Arg_Last := 4;\n+            elsif Normalized_Hostname /= \"\" then\n+               if At_Least_One_Compiler_Command then\n+                  Args (4) :=\n+                    new String'(\"--target=all\");\n                else\n                   Args (4) :=\n-                    new String'(\"--target=\" & Selected_Target.all);\n+                    new String'(\"--target=\" & Normalized_Hostname);\n                end if;\n \n                Arg_Last := 4;\n@@ -1496,7 +1496,7 @@ package body Prj.Conf is\n       then\n          Write_Line\n            (\"warning: \" &\n-              \"--RTS is taken into account only in auto-configuration\");\n+              \"runtimes are taken into account only in auto-configuration\");\n       end if;\n \n       --  Parse the configuration file\n@@ -1610,6 +1610,8 @@ package body Prj.Conf is\n       procedure Add_Directory (Dir : String);\n       --  Add a directory at the end of the Project Path\n \n+      Auto_Generated : Boolean;\n+\n       -------------------\n       -- Add_Directory --\n       -------------------\n@@ -1630,6 +1632,11 @@ package body Prj.Conf is\n \n       Update_Ignore_Missing_With (Env.Flags, True);\n \n+      Automatically_Generated := False;\n+      --  If in fact the config file is automatically generated,\n+      --  Automatically_Generated will be set to True after invocation of\n+      --  Process_Project_And_Apply_Config.\n+\n       --  Record Target_Value and Target_Origin.\n \n       if Target_Name = \"\" then\n@@ -1647,7 +1654,6 @@ package body Prj.Conf is\n       Prj.Initialize (Project_Tree);\n \n       Main_Project := No_Project;\n-      Automatically_Generated := False;\n \n       Prj.Part.Parse\n         (In_Tree           => Project_Node_Tree,\n@@ -1728,14 +1734,18 @@ package body Prj.Conf is\n          Env                        => Env,\n          Packages_To_Check          => Packages_To_Check,\n          Allow_Automatic_Generation => Allow_Automatic_Generation,\n-         Automatically_Generated    => Automatically_Generated,\n+         Automatically_Generated    => Auto_Generated,\n          Config_File_Path           => Config_File_Path,\n          Target_Name                => Target_Name,\n          Normalized_Hostname        => Normalized_Hostname,\n          On_Load_Config             => On_Load_Config,\n          On_New_Tree_Loaded         => On_New_Tree_Loaded,\n          Do_Phase_1                 => Opt.Target_Origin = Specified);\n \n+      if Auto_Generated then\n+         Automatically_Generated := True;\n+      end if;\n+\n       --  Exit if there was an error. Otherwise, if Config_Try_Again is True,\n       --  update the project path and try again.\n "}]}