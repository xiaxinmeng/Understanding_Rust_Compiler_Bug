{"sha": "fe663f4e45fc2041ede2b6011fa43b3bd621a70d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmU2NjNmNGU0NWZjMjA0MWVkZTJiNjAxMWZhNDNiM2JkNjIxYTcwZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2009-09-16T16:26:55Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2009-09-16T16:26:55Z"}, "message": "re PR target/41246 (should \"sorry\" when regparm=3 and nested functions are encountered)\n\nPR target/41246\n        * tree-cfg.c (verify_gimple_call): Validate that\n        * gimple_call_chain\n        is set only if DECL_NO_STATIC_CHAIN is unset.\n        * tree-nested.c (iter_nestinfo_start, iter_nestinfo_next): New.\n        (FOR_EACH_NEST_INFO): New.\n        (walk_all_functions): Use it.\n        (finalize_nesting_tree): Likewise.\n        (unnest_nesting_tree): Likewise.\n        (free_nesting_tree): Use iter_nestinfo_start, iter_nestinfo_next.\n        (get_chain_decl, get_chain_field): Reset DECL_NO_STATIC_CHAIN.\n        (convert_gimple_call): Early out if gimple_call_chain already set.\n        (convert_all_function_calls): Iterate until no new functions\n        require a static chain.\n        (finalize_nesting_tree_1): Assert DECL_NO_STATIC_CHAIN is unset\n        when building a trampoline.  Use dump_function_to_file instead\n        of dump_function.\n        (lower_nested_functions): Open dump_file.  Validate that decls\n        that have DECL_NO_STATIC_CHAIN from the front end don't have that\n        bit reset by this pass.\n\nFrom-SVN: r151762", "tree": {"sha": "9c8b5d51425dfcd062aa4b34755ad43e82f11eb8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c8b5d51425dfcd062aa4b34755ad43e82f11eb8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe663f4e45fc2041ede2b6011fa43b3bd621a70d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe663f4e45fc2041ede2b6011fa43b3bd621a70d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe663f4e45fc2041ede2b6011fa43b3bd621a70d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe663f4e45fc2041ede2b6011fa43b3bd621a70d/comments", "author": null, "committer": null, "parents": [{"sha": "9b87db3c0fc95b7f76fcdc38e21371dff155ee4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b87db3c0fc95b7f76fcdc38e21371dff155ee4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b87db3c0fc95b7f76fcdc38e21371dff155ee4b"}], "stats": {"total": 253, "additions": 198, "deletions": 55}, "files": [{"sha": "8d6ae7df4d11cad86dfefa0c0ae76bcf29ae8b11", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe663f4e45fc2041ede2b6011fa43b3bd621a70d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe663f4e45fc2041ede2b6011fa43b3bd621a70d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fe663f4e45fc2041ede2b6011fa43b3bd621a70d", "patch": "@@ -1,3 +1,25 @@\n+2009-09-16  Richard Henderson  <rth@redhat.com>\n+\n+\tPR target/41246\n+\t* tree-cfg.c (verify_gimple_call): Validate that gimple_call_chain\n+\tis set only if DECL_NO_STATIC_CHAIN is unset.\n+\t* tree-nested.c (iter_nestinfo_start, iter_nestinfo_next): New.\n+\t(FOR_EACH_NEST_INFO): New.\n+\t(walk_all_functions): Use it.\n+\t(finalize_nesting_tree): Likewise.\n+\t(unnest_nesting_tree): Likewise.\n+\t(free_nesting_tree): Use iter_nestinfo_start, iter_nestinfo_next.\n+\t(get_chain_decl, get_chain_field): Reset DECL_NO_STATIC_CHAIN.\n+\t(convert_gimple_call): Early out if gimple_call_chain already set.\n+\t(convert_all_function_calls): Iterate until no new functions\n+\trequire a static chain.\n+\t(finalize_nesting_tree_1): Assert DECL_NO_STATIC_CHAIN is unset\n+\twhen building a trampoline.  Use dump_function_to_file instead\n+\tof dump_function.\n+\t(lower_nested_functions): Open dump_file.  Validate that decls\n+\tthat have DECL_NO_STATIC_CHAIN from the front end don't have that\n+\tbit reset by this pass.\n+\n 2009-09-16  Michael Matz  <matz@suse.de>\n \n \tPR fortran/41212"}, {"sha": "ef5f32284d4e5e3c04e4c2d4a510731ef2a94936", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe663f4e45fc2041ede2b6011fa43b3bd621a70d/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe663f4e45fc2041ede2b6011fa43b3bd621a70d/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=fe663f4e45fc2041ede2b6011fa43b3bd621a70d", "patch": "@@ -3573,6 +3573,25 @@ verify_gimple_call (gimple stmt)\n       return true;\n     }\n \n+  /* If there is a static chain argument, this should not be an indirect\n+     call, and the decl should not have DECL_NO_STATIC_CHAIN set.  */\n+  if (gimple_call_chain (stmt))\n+    {\n+      if (TREE_CODE (fn) != ADDR_EXPR\n+\t  || TREE_CODE (TREE_OPERAND (fn, 0)) != FUNCTION_DECL)\n+\t{\n+\t  error (\"static chain in indirect gimple call\");\n+\t  return true;\n+\t}\n+      fn = TREE_OPERAND (fn, 0);\n+\n+      if (DECL_NO_STATIC_CHAIN (fn))\n+\t{\n+\t  error (\"static chain with function that doesn't use one\");\n+\t  return true;\n+\t}\n+    }\n+\n   /* ???  The C frontend passes unpromoted arguments in case it\n      didn't see a function declaration before the call.  So for now\n      leave the call arguments unverified.  Once we gimplify"}, {"sha": "bcf971143cfd1519f88478e3970bf037c62a84a8", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 157, "deletions": 55, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe663f4e45fc2041ede2b6011fa43b3bd621a70d/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe663f4e45fc2041ede2b6011fa43b3bd621a70d/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=fe663f4e45fc2041ede2b6011fa43b3bd621a70d", "patch": "@@ -1,5 +1,6 @@\n /* Nested function decomposition for GIMPLE.\n-   Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009\n+   Free Software Foundation, Inc.\n \n    This file is part of GCC.\n \n@@ -102,6 +103,27 @@ struct nesting_info\n };\n \n \n+/* Iterate over the nesting tree, starting with ROOT, depth first.  */\n+\n+static inline struct nesting_info *\n+iter_nestinfo_start (struct nesting_info *root)\n+{\n+  while (root->inner)\n+    root = root->inner;\n+  return root;\n+}\n+\n+static inline struct nesting_info *\n+iter_nestinfo_next (struct nesting_info *node)\n+{\n+  if (node->next)\n+    return iter_nestinfo_start (node->next);\n+  return node->outer;\n+}\n+\n+#define FOR_EACH_NEST_INFO(I, ROOT) \\\n+  for ((I) = iter_nestinfo_start (ROOT); (I); (I) = iter_nestinfo_next (I))\n+\n /* Obstack used for the bitmaps in the struct above.  */\n static struct bitmap_obstack nesting_info_bitmap_obstack;\n \n@@ -301,6 +323,7 @@ static tree\n get_chain_decl (struct nesting_info *info)\n {\n   tree decl = info->chain_decl;\n+\n   if (!decl)\n     {\n       tree type;\n@@ -327,6 +350,14 @@ get_chain_decl (struct nesting_info *info)\n       TREE_READONLY (decl) = 1;\n \n       info->chain_decl = decl;\n+\n+      if (dump_file\n+          && (dump_flags & TDF_DETAILS)\n+\t  && DECL_NO_STATIC_CHAIN (info->context))\n+\tfprintf (dump_file, \"Resetting no-static-chain for %s\\n\",\n+\t\t lang_hooks.decl_printable_name (info->context, 2));\n+\n+      DECL_NO_STATIC_CHAIN (info->context) = 0;\n     }\n   return decl;\n }\n@@ -339,6 +370,7 @@ static tree\n get_chain_field (struct nesting_info *info)\n {\n   tree field = info->chain_field;\n+\n   if (!field)\n     {\n       tree type = build_pointer_type (get_frame_type (info->outer));\n@@ -352,6 +384,14 @@ get_chain_field (struct nesting_info *info)\n       insert_field_into_struct (get_frame_type (info), field);\n \n       info->chain_field = field;\n+\n+      if (dump_file\n+          && (dump_flags & TDF_DETAILS)\n+\t  && DECL_NO_STATIC_CHAIN (info->context))\n+\tfprintf (dump_file, \"Resetting no-static-chain for %s\\n\",\n+\t\t lang_hooks.decl_printable_name (info->context, 2));\n+\n+      DECL_NO_STATIC_CHAIN (info->context) = 0;\n     }\n   return field;\n }\n@@ -622,14 +662,9 @@ static void\n walk_all_functions (walk_stmt_fn callback_stmt, walk_tree_fn callback_op,\n \t\t    struct nesting_info *root)\n {\n-  do\n-    {\n-      if (root->inner)\n-\twalk_all_functions (callback_stmt, callback_op, root->inner);\n-      walk_function (callback_stmt, callback_op, root);\n-      root = root->next;\n-    }\n-  while (root);\n+  struct nesting_info *n;\n+  FOR_EACH_NEST_INFO (n, root)\n+    walk_function (callback_stmt, callback_op, n);\n }\n \n \n@@ -1931,6 +1966,8 @@ convert_gimple_call (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n   switch (gimple_code (stmt))\n     {\n     case GIMPLE_CALL:\n+      if (gimple_call_chain (stmt))\n+\tbreak;\n       decl = gimple_call_fndecl (stmt);\n       if (!decl)\n \tbreak;\n@@ -1998,32 +2035,71 @@ convert_gimple_call (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n   return NULL_TREE;\n }\n \n-\n-/* Walk the nesting tree starting with ROOT, depth first.  Convert all\n-   trampolines and call expressions.  On the way back up, determine if\n-   a nested function actually uses its static chain; if not, remember that.  */\n+/* Walk the nesting tree starting with ROOT.  Convert all trampolines and\n+   call expressions.  At the same time, determine if a nested function\n+   actually uses its static chain; if not, remember that.  */\n \n static void\n convert_all_function_calls (struct nesting_info *root)\n {\n+  struct nesting_info *n;\n+  int iter_count;\n+  bool any_changed;\n+\n+  /* First, optimistically set no_static_chain for all decls that haven't\n+     used the static chain already for variable access.  Notice that we \n+     do this pre-order, because we want inner functions to be processed\n+     first in the LIFO worklist.  */\n+  FOR_EACH_NEST_INFO (n, root)\n+    {\n+      tree decl = n->context;\n+      if (n->outer && !n->chain_decl && !n->chain_field)\n+\t{\n+\t  DECL_NO_STATIC_CHAIN (decl) = 1;\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"Guessing no-static-chain for %s\\n\",\n+\t\t     lang_hooks.decl_printable_name (decl, 2));\n+\t}\n+      else\n+\tgcc_assert (!DECL_NO_STATIC_CHAIN (decl));\n+    }\n+\n+  /* Walk the functions and perform transformations.  Note that these\n+     transformations can induce new uses of the static chain, which in turn\n+     require re-examining all users of the decl.  */\n+  /* ??? It would make sense to try to use the call graph to speed this up,\n+     but the call graph hasn't really been built yet.  Even if it did, we \n+     would still need to iterate in this loop since address-of references\n+     wouldn't show up in the callgraph anyway.  */\n+  iter_count = 0;\n   do\n     {\n-      if (root->inner)\n-\tconvert_all_function_calls (root->inner);\n+      any_changed = false;\n+      iter_count++;\n \n-      walk_function (convert_tramp_reference_stmt, convert_tramp_reference_op,\n-\t\t     root);\n-      walk_function (convert_gimple_call, NULL, root);\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfputc ('\\n', dump_file);\n \n-      /* If the function does not use a static chain, then remember that.  */\n-      if (root->outer && !root->chain_decl && !root->chain_field)\n-\tDECL_NO_STATIC_CHAIN (root->context) = 1;\n-      else\n-\tgcc_assert (!DECL_NO_STATIC_CHAIN (root->context));\n+      FOR_EACH_NEST_INFO (n, root)\n+\t{\n+\t  tree decl = n->context;\n+\t  bool old_no_static_chain = DECL_NO_STATIC_CHAIN (decl);\n \n-      root = root->next;\n+\t  walk_function (convert_tramp_reference_stmt,\n+\t\t\t convert_tramp_reference_op, n);\n+\t  walk_function (convert_gimple_call, NULL, n);\n+\n+\t  /* If a call to another function created the use of a chain\n+\t     within this function, we'll have to continue iteration.  */\n+\t  if (old_no_static_chain && !DECL_NO_STATIC_CHAIN (decl))\n+\t    any_changed = true;\n+\t}\n     }\n-  while (root);\n+  while (any_changed);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"convert_all_function_calls iterations: %d\\n\\n\",\n+\t     iter_count);\n }\n \n struct nesting_copy_body_data\n@@ -2263,10 +2339,8 @@ finalize_nesting_tree_1 (struct nesting_info *root)\n \t  if (!field)\n \t    continue;\n \n-\t  if (DECL_NO_STATIC_CHAIN (i->context))\n-\t    arg3 = null_pointer_node;\n-\t  else\n-\t    arg3 = build_addr (root->frame_decl, context);\n+\t  gcc_assert (!DECL_NO_STATIC_CHAIN (i->context));\n+\t  arg3 = build_addr (root->frame_decl, context);\n \n \t  arg2 = build_addr (i->context, context);\n \n@@ -2379,20 +2453,19 @@ finalize_nesting_tree_1 (struct nesting_info *root)\n     }\n \n   /* Dump the translated tree function.  */\n-  dump_function (TDI_nested, root->context);\n+  if (dump_file)\n+    {\n+      fputs (\"\\n\\n\", dump_file);\n+      dump_function_to_file (root->context, dump_file, dump_flags);\n+    }\n }\n \n static void\n finalize_nesting_tree (struct nesting_info *root)\n {\n-  do\n-    {\n-      if (root->inner)\n-\tfinalize_nesting_tree (root->inner);\n-      finalize_nesting_tree_1 (root);\n-      root = root->next;\n-    }\n-  while (root);\n+  struct nesting_info *n;\n+  FOR_EACH_NEST_INFO (n, root)\n+    finalize_nesting_tree_1 (n);\n }\n \n /* Unnest the nodes and pass them to cgraph.  */\n@@ -2414,33 +2487,28 @@ unnest_nesting_tree_1 (struct nesting_info *root)\n static void\n unnest_nesting_tree (struct nesting_info *root)\n {\n-  do\n-    {\n-      if (root->inner)\n-\tunnest_nesting_tree (root->inner);\n-      unnest_nesting_tree_1 (root);\n-      root = root->next;\n-    }\n-  while (root);\n+  struct nesting_info *n;\n+  FOR_EACH_NEST_INFO (n, root)\n+    unnest_nesting_tree_1 (n);\n }\n \n /* Free the data structures allocated during this pass.  */\n \n static void\n free_nesting_tree (struct nesting_info *root)\n {\n-  struct nesting_info *next;\n+  struct nesting_info *node, *next;\n+\n+  node = iter_nestinfo_start (root);\n   do\n     {\n-      if (root->inner)\n-\tfree_nesting_tree (root->inner);\n-      pointer_map_destroy (root->var_map);\n-      pointer_map_destroy (root->field_map);\n-      next = root->next;\n-      free (root);\n-      root = next;\n+      next = iter_nestinfo_next (node);\n+      pointer_map_destroy (node->var_map);\n+      pointer_map_destroy (node->field_map);\n+      free (node);\n+      node = next;\n     }\n-  while (root);\n+  while (node);\n }\n \n /* Gimplify a function and all its nested functions.  */\n@@ -2462,6 +2530,10 @@ lower_nested_functions (tree fndecl)\n {\n   struct cgraph_node *cgn;\n   struct nesting_info *root;\n+#ifdef ENABLE_CHECKING\n+  struct nesting_info *n;\n+  bitmap orig_decl_no_static_chain;\n+#endif\n \n   /* If there are no nested functions, there's nothing to do.  */\n   cgn = cgraph_node (fndecl);\n@@ -2470,8 +2542,23 @@ lower_nested_functions (tree fndecl)\n \n   gimplify_all_functions (cgn);\n \n+  dump_file = dump_begin (TDI_nested, &dump_flags);\n+  if (dump_file)\n+    fprintf (dump_file, \"\\n;; Function %s\\n\\n\",\n+\t     lang_hooks.decl_printable_name (fndecl, 2));\n+\n   bitmap_obstack_initialize (&nesting_info_bitmap_obstack);\n   root = create_nesting_tree (cgn);\n+\n+#ifdef ENABLE_CHECKING\n+  /* The C++ and Ada front ends set DECL_NO_STATIC_CHAIN in various\n+     instances where they expect no static chain needed.  */\n+  orig_decl_no_static_chain = BITMAP_ALLOC (&nesting_info_bitmap_obstack);\n+  FOR_EACH_NEST_INFO (n, root)\n+    if (DECL_NO_STATIC_CHAIN (n->context))\n+      bitmap_set_bit (orig_decl_no_static_chain, DECL_UID (n->context));\n+#endif\n+\n   walk_all_functions (convert_nonlocal_reference_stmt,\n                       convert_nonlocal_reference_op,\n \t\t      root);\n@@ -2480,11 +2567,26 @@ lower_nested_functions (tree fndecl)\n \t\t      root);\n   walk_all_functions (convert_nl_goto_reference, NULL, root);\n   walk_all_functions (convert_nl_goto_receiver, NULL, root);\n+\n   convert_all_function_calls (root);\n   finalize_nesting_tree (root);\n   unnest_nesting_tree (root);\n+\n+#ifdef ENABLE_CHECKING\n+  /* Validate the original settings of DECL_NO_STATIC_CHAIN.  */\n+  FOR_EACH_NEST_INFO (n, root)\n+    if (bitmap_bit_p (orig_decl_no_static_chain, DECL_UID (n->context)))\n+      gcc_assert (DECL_NO_STATIC_CHAIN (n->context));\n+#endif\n+\n   free_nesting_tree (root);\n   bitmap_obstack_release (&nesting_info_bitmap_obstack);\n+\n+  if (dump_file)\n+    {\n+      dump_end (TDI_nested, dump_file);\n+      dump_file = NULL;\n+    }\n }\n \n #include \"gt-tree-nested.h\""}]}