{"sha": "b09cba37bf59305a973412fec5819bd79d56aaff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjA5Y2JhMzdiZjU5MzA1YTk3MzQxMmZlYzU4MTliZDc5ZDU2YWFmZg==", "commit": {"author": {"name": "David Edelsohn", "email": "dje.gcc@gmail.com", "date": "2012-11-30T17:54:07Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "2012-11-30T17:54:07Z"}, "message": "xcoffout.c (xcoff_tls_data_section_name): Define.\n\n        * xcoffout.c (xcoff_tls_data_section_name): Define.\n        * xcoffout.h (xcoff_tls_data_section_name): Declare.\n        * config/rs6000/rs6000.c (tls_data_section): Define.\n        (TARGET_USE_BLOCKS_FOR_DECL_P): Define.\n        (rs6000_legitimize_tls_address_aix): New function.\n        (rs6000_legitimize_tls_address): Use new function for AIX.\n        (rs6000_cannot_force_const_mem): No sum in TLS TOC symbols.\n        Allow TLS symbol in constant pool other than ELF.\n        (rs6000_legitimate_address_p): Allow TLS symbol other than ELF.\n        (rs6000_assemble_visibility): Do not emit anything on AIX.\n        (output_toc): Handle alias of TLS general-dynamic symbols.\n        Emit TLS decorations on symbols.\n        (rs6000_use_blocks_for_decl_p): New function.\n        (rs6000_xcoff_output_tls_section_asm_op): New function.\n        (rs6000_xcoff_asm_init_sections): Initialize tls_data_section.\n        (rs6000_xcoff_select_section): Choose tls_data_section for\n        thread-local storage.\n        (rs6000_xcoff_file_start): Generate xcoff_tls_data_section_name.\n        (rs6000_legitimate_constant_p): Allow TLS symbol other than ELF.\n        * config/rs6000/rs6000.md (tls_tls_): Restrict to ELF.\n        (tls_get_tpointer): New.\n        (tle_get_tpointer_internal): New.\n        (tls_get_addr<mode>): New.\n        (tls_get_addr_internal<mode>): New.\n\nFrom-SVN: r194003", "tree": {"sha": "9c9453f0032dfcfc81effe58f4991ddd2a024313", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c9453f0032dfcfc81effe58f4991ddd2a024313"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b09cba37bf59305a973412fec5819bd79d56aaff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b09cba37bf59305a973412fec5819bd79d56aaff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b09cba37bf59305a973412fec5819bd79d56aaff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b09cba37bf59305a973412fec5819bd79d56aaff/comments", "author": {"login": "edelsohn", "id": 667700, "node_id": "MDQ6VXNlcjY2NzcwMA==", "avatar_url": "https://avatars.githubusercontent.com/u/667700?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edelsohn", "html_url": "https://github.com/edelsohn", "followers_url": "https://api.github.com/users/edelsohn/followers", "following_url": "https://api.github.com/users/edelsohn/following{/other_user}", "gists_url": "https://api.github.com/users/edelsohn/gists{/gist_id}", "starred_url": "https://api.github.com/users/edelsohn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edelsohn/subscriptions", "organizations_url": "https://api.github.com/users/edelsohn/orgs", "repos_url": "https://api.github.com/users/edelsohn/repos", "events_url": "https://api.github.com/users/edelsohn/events{/privacy}", "received_events_url": "https://api.github.com/users/edelsohn/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2730ada7a02e99f9a3088b74b1ff588255c40154", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2730ada7a02e99f9a3088b74b1ff588255c40154", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2730ada7a02e99f9a3088b74b1ff588255c40154"}], "stats": {"total": 233, "additions": 228, "deletions": 5}, "files": [{"sha": "d440252d9f3ede3a4f5aae819e0f299d95d5e0f2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b09cba37bf59305a973412fec5819bd79d56aaff/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b09cba37bf59305a973412fec5819bd79d56aaff/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b09cba37bf59305a973412fec5819bd79d56aaff", "patch": "@@ -1,3 +1,30 @@\n+2012-11-30  David Edelsohn  <dje.gcc@gmail.com>\n+\n+\t* xcoffout.c (xcoff_tls_data_section_name): Define.\n+\t* xcoffout.h (xcoff_tls_data_section_name): Declare.\n+\t* config/rs6000/rs6000.c (tls_data_section): Define.\n+\t(TARGET_USE_BLOCKS_FOR_DECL_P): Define.\n+\t(rs6000_legitimize_tls_address_aix): New function.\n+\t(rs6000_legitimize_tls_address): Use new function for AIX.\n+\t(rs6000_cannot_force_const_mem): No sum in TLS TOC symbols.\n+\tAllow TLS symbol in constant pool other than ELF.\n+\t(rs6000_legitimate_address_p): Allow TLS symbol other than ELF.\n+\t(rs6000_assemble_visibility): Do not emit anything on AIX.\n+\t(output_toc): Handle alias of TLS general-dynamic symbols.\n+\tEmit TLS decorations on symbols.\n+\t(rs6000_use_blocks_for_decl_p): New function.\n+\t(rs6000_xcoff_output_tls_section_asm_op): New function.\n+\t(rs6000_xcoff_asm_init_sections): Initialize tls_data_section.\n+\t(rs6000_xcoff_select_section): Choose tls_data_section for\n+\tthread-local storage.\n+\t(rs6000_xcoff_file_start): Generate xcoff_tls_data_section_name.\n+\t(rs6000_legitimate_constant_p): Allow TLS symbol other than ELF.\n+\t* config/rs6000/rs6000.md (tls_tls_): Restrict to ELF.\n+\t(tls_get_tpointer): New.\n+\t(tle_get_tpointer_internal): New.\n+\t(tls_get_addr<mode>): New.\n+\t(tls_get_addr_internal<mode>): New.\n+\n 2012-11-30  Teresa Johnson  <tejohnson@google.com>\n \n \t* lto-cgraph.c (output_profile_summary): Stream out sum_all"}, {"sha": "7f607a63b3c24b7469fa86d16951b6b5fa8e5d1f", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 155, "deletions": 4, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b09cba37bf59305a973412fec5819bd79d56aaff/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b09cba37bf59305a973412fec5819bd79d56aaff/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=b09cba37bf59305a973412fec5819bd79d56aaff", "patch": "@@ -208,6 +208,7 @@ static short cached_can_issue_more;\n \n static GTY(()) section *read_only_data_section;\n static GTY(()) section *private_data_section;\n+static GTY(()) section *tls_data_section;\n static GTY(()) section *read_only_private_data_section;\n static GTY(()) section *sdata2_section;\n static GTY(()) section *toc_section;\n@@ -1405,6 +1406,8 @@ static const struct attribute_spec rs6000_attribute_table[] =\n #define TARGET_MAX_ANCHOR_OFFSET 0x7fffffff\n #undef TARGET_USE_BLOCKS_FOR_CONSTANT_P\n #define TARGET_USE_BLOCKS_FOR_CONSTANT_P rs6000_use_blocks_for_constant_p\n+#undef TARGET_USE_BLOCKS_FOR_DECL_P\n+#define TARGET_USE_BLOCKS_FOR_DECL_P rs6000_use_blocks_for_decl_p\n \n #undef TARGET_BUILTIN_RECIPROCAL\n #define TARGET_BUILTIN_RECIPROCAL rs6000_builtin_reciprocal\n@@ -5882,6 +5885,75 @@ rs6000_got_sym (void)\n   return rs6000_got_symbol;\n }\n \n+/* AIX Thread-Local Address support.  */\n+\n+static rtx\n+rs6000_legitimize_tls_address_aix (rtx addr, enum tls_model model)\n+{\n+  rtx sym, mem, tocref, tlsreg, tmpreg, dest;\n+\n+  /* Place addr into TOC constant pool.  */\n+  sym = force_const_mem (GET_MODE (addr), addr);\n+\n+  /* Output the TOC entry and create the MEM referencing the value.  */\n+  if (constant_pool_expr_p (XEXP (sym, 0))\n+      && ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (get_pool_constant (XEXP (sym, 0)), Pmode))\n+    {\n+      tocref = create_TOC_reference (XEXP (sym, 0), NULL_RTX);\n+      mem = gen_const_mem (Pmode, tocref);\n+      set_mem_alias_set (mem, get_TOC_alias_set ());\n+    }\n+  else\n+    return sym;\n+\n+  /* Use global-dynamic for local-dynamic.  */\n+  if (model == TLS_MODEL_GLOBAL_DYNAMIC\n+      || model == TLS_MODEL_LOCAL_DYNAMIC)\n+    {\n+      rtx module = gen_reg_rtx (Pmode);\n+      /* Create new TOC reference for @m symbol.  */\n+      const char *name = XSTR (XVECEXP (XEXP (mem, 0), 0, 0), 0);\n+      char *name2 = XALLOCAVEC (char, strlen (name) + 1);\n+      strcpy (name2, \"*LCM\");\n+      strcat (name2, name + 3);\n+      tocref = create_TOC_reference (gen_rtx_SYMBOL_REF (Pmode,\n+\t\t\t\t\t\t\t ggc_alloc_string (name2,\n+\t\t\t\t\t\t\t\t\t   strlen (name2))),\n+\t\t\t\t     NULL_RTX);\n+      rtx mem2 = gen_const_mem (Pmode, tocref);\n+      set_mem_alias_set (mem2, get_TOC_alias_set ());\n+      \n+      dest = gen_reg_rtx (Pmode);\n+      tmpreg = gen_reg_rtx (Pmode);\n+      emit_insn (gen_rtx_SET (VOIDmode, tmpreg, mem));\n+      emit_insn (gen_rtx_SET (VOIDmode, module, mem2));\n+      if (TARGET_32BIT)\n+\temit_insn (gen_tls_get_addrsi (dest, module, tmpreg));\n+      else\n+\temit_insn (gen_tls_get_addrdi (dest, module, tmpreg));\n+      return dest;\n+    }\n+  /* Obtain TLS pointer: 32 bit call or 64 bit GPR 13.  */\n+  else if (TARGET_32BIT)\n+    {\n+      tlsreg = gen_reg_rtx (SImode);\n+      emit_insn (gen_tls_get_tpointer (tlsreg));\n+    }\n+  else\n+    tlsreg = gen_rtx_REG (DImode, 13);\n+\n+  /* Load the TOC value into temporary register.  */\n+  tmpreg = gen_reg_rtx (Pmode);\n+  emit_insn (gen_rtx_SET (VOIDmode, tmpreg, mem));\n+  set_unique_reg_note (get_last_insn (), REG_EQUAL,\n+\t\t       gen_rtx_MINUS (Pmode, addr, tlsreg));\n+\n+  /* Add TOC symbol value to TLS pointer.  */\n+  dest = force_reg (Pmode, gen_rtx_PLUS (Pmode, tmpreg, tlsreg));\n+\n+  return dest;\n+}\n+\n /* ADDR contains a thread-local SYMBOL_REF.  Generate code to compute\n    this (thread-local) address.  */\n \n@@ -5890,6 +5962,9 @@ rs6000_legitimize_tls_address (rtx addr, enum tls_model model)\n {\n   rtx dest, insn;\n \n+  if (TARGET_XCOFF)\n+    return rs6000_legitimize_tls_address_aix (addr, model);\n+\n   dest = gen_reg_rtx (Pmode);\n   if (model == TLS_MODEL_LOCAL_EXEC && rs6000_tls_size == 16)\n     {\n@@ -6085,7 +6160,15 @@ rs6000_cannot_force_const_mem (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n       && GET_CODE (XEXP (x, 0)) == UNSPEC)\n     return true;\n \n-  return rs6000_tls_referenced_p (x);\n+  /* A TLS symbol in the TOC cannot contain a sum.  */\n+  if (GET_CODE (x) == CONST\n+      && GET_CODE (XEXP (x, 0)) == PLUS\n+      && GET_CODE (XEXP (XEXP (x, 0), 0)) == SYMBOL_REF\n+      && SYMBOL_REF_TLS_MODEL (XEXP (XEXP (x, 0), 0)) != 0)\n+    return true;\n+\n+  /* Do not place an ELF TLS symbol in the constant pool.  */\n+  return TARGET_ELF && rs6000_tls_referenced_p (x);\n }\n \n /* Return 1 if *X is a thread-local symbol.  This is the same as\n@@ -6380,7 +6463,7 @@ rs6000_legitimate_address_p (enum machine_mode mode, rtx x, bool reg_ok_strict)\n       && INTVAL (XEXP (x, 1)) == -16)\n     x = XEXP (x, 0);\n \n-  if (RS6000_SYMBOL_REF_TLS_P (x))\n+  if (TARGET_ELF && RS6000_SYMBOL_REF_TLS_P (x))\n     return 0;\n   if (legitimate_indirect_address_p (x, reg_ok_strict))\n     return 1;\n@@ -15486,6 +15569,9 @@ rs6000_assemble_integer (rtx x, unsigned int size, int aligned_p)\n static void\n rs6000_assemble_visibility (tree decl, int vis)\n {\n+  if (TARGET_XCOFF)\n+    return;\n+\n   /* Functions need to have their entry point symbol visibility set as\n      well as their descriptor symbol visibility.  */\n   if (DEFAULT_ABI == ABI_AIX\n@@ -21934,6 +22020,20 @@ output_toc (FILE *file, rtx x, int labelno, enum machine_mode mode)\n \t  ASM_OUTPUT_INTERNAL_LABEL_PREFIX (file, \"LC\");\n \t  fprintf (file, \"%d\\n\", ((*(const struct toc_hash_struct **)\n \t\t\t\t\t      found)->labelno));\n+\n+#ifdef HAVE_AS_TLS\n+\t  if (TARGET_XCOFF && GET_CODE (x) == SYMBOL_REF\n+\t      && (SYMBOL_REF_TLS_MODEL (x) == TLS_MODEL_GLOBAL_DYNAMIC\n+\t\t  || SYMBOL_REF_TLS_MODEL (x) == TLS_MODEL_LOCAL_DYNAMIC))\n+\t    {\n+\t      fputs (\"\\t.set \", file);\n+\t      ASM_OUTPUT_INTERNAL_LABEL_PREFIX (file, \"LCM\");\n+\t      fprintf (file, \"%d,\", labelno);\n+\t      ASM_OUTPUT_INTERNAL_LABEL_PREFIX (file, \"LCM\");\n+\t      fprintf (file, \"%d\\n\", ((*(const struct toc_hash_struct **)\n+\t\t\t       \t\t\t      found)->labelno));\n+\t    }\n+#endif\n \t  return;\n \t}\n     }\n@@ -22206,6 +22306,29 @@ output_toc (FILE *file, rtx x, int labelno, enum machine_mode mode)\n     }\n   else\n     output_addr_const (file, x);\n+\n+#if HAVE_AS_TLS\n+  if (TARGET_XCOFF && GET_CODE (base) == SYMBOL_REF)\n+    {\n+      if (SYMBOL_REF_TLS_MODEL (base) == TLS_MODEL_LOCAL_EXEC)\n+\tfputs (\"[TL]@le\", file);\n+      else if (SYMBOL_REF_TLS_MODEL (base) == TLS_MODEL_INITIAL_EXEC)\n+\tfputs (\"[TL]@ie\", file);\n+      /* Use global-dynamic for local-dynamic.  */\n+      else if (SYMBOL_REF_TLS_MODEL (base) == TLS_MODEL_GLOBAL_DYNAMIC\n+\t       || SYMBOL_REF_TLS_MODEL (base) == TLS_MODEL_LOCAL_DYNAMIC)\n+\t{\n+\t  fputs (\"[TL]\\n\", file);\n+\t  (*targetm.asm_out.internal_label) (file, \"LCM\", labelno);\n+\t  fputs (\"\\t.tc .\", file);\n+\t  RS6000_OUTPUT_BASENAME (file, name);\n+\t  fputs (\"[TC],\", file);\n+\t  output_addr_const (file, x);\n+\t  fputs (\"[TL]@m\", file);\n+\t}\n+    }\n+#endif\n+\n   putc ('\\n', file);\n }\n \f\n@@ -24884,6 +25007,14 @@ rs6000_use_blocks_for_constant_p (enum machine_mode mode, const_rtx x)\n {\n   return !ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (x, mode);\n }\n+\n+/* Do not place thread-local symbols refs in the object blocks.  */\n+\n+static bool\n+rs6000_use_blocks_for_decl_p (const_tree decl)\n+{\n+  return !DECL_THREAD_LOCAL_P (decl);\n+}\n \f\n /* Return a REG that occurs in ADDR with coefficient 1.\n    ADDR can be effectively incremented by incrementing REG.\n@@ -25516,6 +25647,14 @@ rs6000_xcoff_output_readwrite_section_asm_op (const void *directive)\n \t   XCOFF_CSECT_DEFAULT_ALIGNMENT_STR);\n }\n \n+static void\n+rs6000_xcoff_output_tls_section_asm_op (const void *directive)\n+{\n+  fprintf (asm_out_file, \"\\t.csect %s[TL],%s\\n\",\n+\t   *(const char *const *) directive,\n+\t   XCOFF_CSECT_DEFAULT_ALIGNMENT_STR);\n+}\n+\n /* A get_unnamed_section callback, used for switching to toc_section.  */\n \n static void\n@@ -25553,6 +25692,11 @@ rs6000_xcoff_asm_init_sections (void)\n \t\t\t   rs6000_xcoff_output_readwrite_section_asm_op,\n \t\t\t   &xcoff_private_data_section_name);\n \n+  tls_data_section\n+    = get_unnamed_section (SECTION_TLS,\n+\t\t\t   rs6000_xcoff_output_tls_section_asm_op,\n+\t\t\t   &xcoff_tls_data_section_name);\n+\n   read_only_private_data_section\n     = get_unnamed_section (0, rs6000_xcoff_output_readonly_section_asm_op,\n \t\t\t   &xcoff_private_data_section_name);\n@@ -25604,7 +25748,12 @@ rs6000_xcoff_select_section (tree decl, int reloc,\n     }\n   else\n     {\n-      if (TREE_PUBLIC (decl))\n+#if HAVE_AS_TLS\n+      if (TREE_CODE (decl) == VAR_DECL && DECL_THREAD_LOCAL_P (decl))\n+\treturn tls_data_section;\n+      else\n+#endif\n+\tif (TREE_PUBLIC (decl))\n \treturn data_section;\n       else\n \treturn private_data_section;\n@@ -25700,6 +25849,8 @@ rs6000_xcoff_file_start (void)\n \t\t\t   main_input_filename, \".bss_\");\n   rs6000_gen_section_name (&xcoff_private_data_section_name,\n \t\t\t   main_input_filename, \".rw_\");\n+  rs6000_gen_section_name (&xcoff_tls_data_section_name,\n+\t\t\t   main_input_filename, \".tls_\");\n   rs6000_gen_section_name (&xcoff_read_only_section_name,\n \t\t\t   main_input_filename, \".ro_\");\n \n@@ -28164,7 +28315,7 @@ rs6000_address_for_altivec (rtx x)\n static bool\n rs6000_legitimate_constant_p (enum machine_mode mode, rtx x)\n {\n-  if (rs6000_tls_referenced_p (x))\n+  if (TARGET_ELF && rs6000_tls_referenced_p (x))\n     return false;\n \n   return ((GET_CODE (x) != CONST_DOUBLE && GET_CODE (x) != CONST_VECTOR)"}, {"sha": "03ad9280386f0d244632403507a63c473be4b941", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 44, "deletions": 1, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b09cba37bf59305a973412fec5819bd79d56aaff/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b09cba37bf59305a973412fec5819bd79d56aaff/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=b09cba37bf59305a973412fec5819bd79d56aaff", "patch": "@@ -9983,8 +9983,51 @@\n \t(unspec:TLSmode [(match_operand:TLSmode 1 \"gpc_reg_operand\" \"b\")\n \t\t\t (match_operand:TLSmode 2 \"rs6000_tls_symbol_ref\" \"\")]\n \t\t\tUNSPEC_TLSTLS))]\n-  \"HAVE_AS_TLS\"\n+  \"TARGET_ELF && HAVE_AS_TLS\"\n   \"add %0,%1,%2@tls\")\n+\n+(define_expand \"tls_get_tpointer\"\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n+\t(unspec:SI [(const_int 0)] UNSPEC_TLSTLS))]\n+  \"TARGET_XCOFF && HAVE_AS_TLS\"\n+  \"\n+{\n+  emit_insn (gen_tls_get_tpointer_internal ());\n+  emit_move_insn (operands[0], gen_rtx_REG (SImode, 3));\n+  DONE;\n+}\")\n+\n+(define_insn \"tls_get_tpointer_internal\"\n+  [(set (reg:SI 3)\n+\t(unspec:SI [(const_int 0)] UNSPEC_TLSTLS))\n+   (clobber (reg:SI LR_REGNO))]\n+  \"TARGET_XCOFF && HAVE_AS_TLS\"\n+  \"bla __get_tpointer\")\n+\n+(define_expand \"tls_get_addr<mode>\"\n+  [(set (match_operand:P 0 \"gpc_reg_operand\" \"\")\n+\t(unspec:P [(match_operand:P 1 \"gpc_reg_operand\" \"\")\n+                   (match_operand:P 2 \"gpc_reg_operand\" \"\")] UNSPEC_TLSTLS))]\n+  \"TARGET_XCOFF && HAVE_AS_TLS\"\n+  \"\n+{\n+  emit_move_insn (gen_rtx_REG (Pmode, 3), operands[1]);\n+  emit_move_insn (gen_rtx_REG (Pmode, 4), operands[2]);\n+  emit_insn (gen_tls_get_addr_internal<mode> ());\n+  emit_move_insn (operands[0], gen_rtx_REG (Pmode, 3));\n+  DONE;\n+}\")\n+\n+(define_insn \"tls_get_addr_internal<mode>\"\n+  [(set (reg:P 3)\n+\t(unspec:P [(reg:P 3) (reg:P 4)] UNSPEC_TLSTLS))\n+   (clobber (reg:P 0))\n+   (clobber (reg:P 5))\n+   (clobber (reg:P 11))\n+   (clobber (reg:CC CR0_REGNO))\n+   (clobber (reg:P LR_REGNO))]\n+  \"TARGET_XCOFF && HAVE_AS_TLS\"\n+  \"bla __tls_get_addr\")\n \f\n ;; Next come insns related to the calling sequence.\n ;;"}, {"sha": "457d34f4b5b74011f66f1bfe049f39fdda17d981", "filename": "gcc/xcoffout.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b09cba37bf59305a973412fec5819bd79d56aaff/gcc%2Fxcoffout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b09cba37bf59305a973412fec5819bd79d56aaff/gcc%2Fxcoffout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fxcoffout.c?ref=b09cba37bf59305a973412fec5819bd79d56aaff", "patch": "@@ -66,6 +66,7 @@ static const char *xcoff_current_function_file;\n \n char *xcoff_bss_section_name;\n char *xcoff_private_data_section_name;\n+char *xcoff_tls_data_section_name;\n char *xcoff_read_only_section_name;\n \n /* Last source file name mentioned in a NOTE insn.  */"}, {"sha": "9a35e2d715639312b1b8b7a6415fcdf10158b785", "filename": "gcc/xcoffout.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b09cba37bf59305a973412fec5819bd79d56aaff/gcc%2Fxcoffout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b09cba37bf59305a973412fec5819bd79d56aaff/gcc%2Fxcoffout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fxcoffout.h?ref=b09cba37bf59305a973412fec5819bd79d56aaff", "patch": "@@ -126,6 +126,7 @@ extern const char *xcoff_current_include_file;\n \n extern char *xcoff_bss_section_name;\n extern char *xcoff_private_data_section_name;\n+extern char *xcoff_tls_data_section_name;\n extern char *xcoff_read_only_section_name;\n \n /* Last source file name mentioned in a NOTE insn.  */"}]}