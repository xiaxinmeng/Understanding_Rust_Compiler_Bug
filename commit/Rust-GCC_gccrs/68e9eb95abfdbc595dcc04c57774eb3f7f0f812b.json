{"sha": "68e9eb95abfdbc595dcc04c57774eb3f7f0f812b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjhlOWViOTVhYmZkYmM1OTVkY2MwNGM1Nzc3NGViM2Y3ZjBmODEyYg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-01-10T22:35:27Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-01-10T22:35:27Z"}, "message": "Initial revision\n\nFrom-SVN: r175", "tree": {"sha": "043a1a0141eb90b48394ed7a2490a4cab66b50bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/043a1a0141eb90b48394ed7a2490a4cab66b50bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/68e9eb95abfdbc595dcc04c57774eb3f7f0f812b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68e9eb95abfdbc595dcc04c57774eb3f7f0f812b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68e9eb95abfdbc595dcc04c57774eb3f7f0f812b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68e9eb95abfdbc595dcc04c57774eb3f7f0f812b/comments", "author": null, "committer": null, "parents": [{"sha": "b323f7eec28955624927f9f181cd502b810bbee2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b323f7eec28955624927f9f181cd502b810bbee2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b323f7eec28955624927f9f181cd502b810bbee2"}], "stats": {"total": 1549, "additions": 1549, "deletions": 0}, "files": [{"sha": "bcaf83b47ed576642e4127899198e02e04f736c2", "filename": "gcc/mips-tdump.c", "status": "added", "additions": 1549, "deletions": 0, "changes": 1549, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68e9eb95abfdbc595dcc04c57774eb3f7f0f812b/gcc%2Fmips-tdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68e9eb95abfdbc595dcc04c57774eb3f7f0f812b/gcc%2Fmips-tdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmips-tdump.c?ref=68e9eb95abfdbc595dcc04c57774eb3f7f0f812b", "patch": "@@ -0,0 +1,1549 @@\n+/* Read and manage MIPS symbol tables from object modules.\n+   Source originally from hartzell@boulder.colorado.edu\n+   Rewritten by: meissner@osf.org\n+   Copyright (C) 1991 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include <stdio.h>\n+#include <sys/types.h>\n+#include <sys/file.h>\n+#include <errno.h>\n+#include <a.out.h>\n+#include \"config.h\"\n+\n+#ifdef __STDC__\n+typedef void *PTR_T;\n+typedef const void *CPTR_T;\n+#define __proto(x) x\n+#else\n+\n+#ifdef _STDIO_H_\t\t/* Ultrix 4.0 */\n+typedef void *PTR_T;\n+typedef void *CPTR_T;\n+\n+#else\n+typedef char *PTR_T;\t\t/* Ultrix 3.1 */\n+typedef char *CPTR_T;\n+#endif\n+\n+#define __proto(x) ()\n+#define const\n+#endif\n+\n+#define uchar\tunsigned char\n+#define ushort\tunsigned short\n+#define uint\tunsigned int\n+#define ulong\tunsigned long\n+\n+/* Do to size_t being defined in sys/types.h and different\n+   in stddef.h, we have to do this by hand.....  Note, these\n+   types are correct for MIPS based systems, and may not be\n+   correct for other systems.  */\n+\n+#define size_t\t\tuint\n+#define ptrdiff_t\tint\n+\n+\f\n+/* Redefination of of storage classes as an enumeration for better\n+   debugging.  */\n+\n+#ifndef stStaParam\n+#define stStaParam\t16\t/* Fortran static parameters */\n+#endif\n+\n+#ifndef btVoid\n+#define btVoid\t\t26\t/* void basic type */\n+#endif\n+\n+typedef enum sc {\n+  sc_Nil\t = scNil,\t  /* no storage class */\n+  sc_Text\t = scText,\t  /* text symbol */\n+  sc_Data\t = scData,\t  /* initialized data symbol */\n+  sc_Bss\t = scBss,\t  /* un-initialized data symbol */\n+  sc_Register\t = scRegister,\t  /* value of symbol is register number */\n+  sc_Abs\t = scAbs,\t  /* value of symbol is absolute */\n+  sc_Undefined\t = scUndefined,\t  /* who knows? */\n+  sc_CdbLocal\t = scCdbLocal,\t  /* variable's value is IN se->va.?? */\n+  sc_Bits\t = scBits,\t  /* this is a bit field */\n+  sc_CdbSystem\t = scCdbSystem,\t  /* var's value is IN CDB's address space */\n+  sc_RegImage\t = scRegImage,\t  /* register value saved on stack */\n+  sc_Info\t = scInfo,\t  /* symbol contains debugger information */\n+  sc_UserStruct\t = scUserStruct,  /* addr in struct user for current process */\n+  sc_SData\t = scSData,\t  /* load time only small data */\n+  sc_SBss\t = scSBss,\t  /* load time only small common */\n+  sc_RData\t = scRData,\t  /* load time only read only data */\n+  sc_Var\t = scVar,\t  /* Var parameter (fortran,pascal) */\n+  sc_Common\t = scCommon,\t  /* common variable */\n+  sc_SCommon\t = scSCommon,\t  /* small common */\n+  sc_VarRegister = scVarRegister, /* Var parameter in a register */\n+  sc_Variant\t = scVariant,\t  /* Variant record */\n+  sc_SUndefined\t = scSUndefined,  /* small undefined(external) data */\n+  sc_Init\t = scInit,\t  /* .init section symbol */\n+  sc_Max\t = scMax\t  /* Max storage class+1 */\n+} sc_t;\n+\n+/* Redefinition of symbol type.  */\n+\n+typedef enum st {\n+  st_Nil\t= stNil,\t/* Nuthin' special */\n+  st_Global\t= stGlobal,\t/* external symbol */\n+  st_Static\t= stStatic,\t/* static */\n+  st_Param\t= stParam,\t/* procedure argument */\n+  st_Local\t= stLocal,\t/* local variable */\n+  st_Label\t= stLabel,\t/* label */\n+  st_Proc\t= stProc,\t/*     \"      \"\t Procedure */\n+  st_Block\t= stBlock,\t/* beginnning of block */\n+  st_End\t= stEnd,\t/* end (of anything) */\n+  st_Member\t= stMember,\t/* member (of anything\t- struct/union/enum */\n+  st_Typedef\t= stTypedef,\t/* type definition */\n+  st_File\t= stFile,\t/* file name */\n+  st_RegReloc\t= stRegReloc,\t/* register relocation */\n+  st_Forward\t= stForward,\t/* forwarding address */\n+  st_StaticProc\t= stStaticProc,\t/* load time only static procs */\n+  st_StaParam\t= stStaParam,\t/* Fortran static parameters */\n+  st_Constant\t= stConstant,\t/* const */\n+  st_Str\t= stStr,\t/* string */\n+  st_Number\t= stNumber,\t/* pure number (ie. 4 NOR 2+2) */\n+  st_Expr\t= stExpr,\t/* 2+2 vs. 4 */\n+  st_Type\t= stType,\t/* post-coersion SER */\n+  st_Max\t= stMax\t\t/* max type+1 */\n+} st_t;\n+\n+/* Redefinition of type qualifiers.  */\n+\n+typedef enum tq {\n+  tq_Nil\t= tqNil,\t/* bt is what you see */\n+  tq_Ptr\t= tqPtr,\t/* pointer */\n+  tq_Proc\t= tqProc,\t/* procedure */\n+  tq_Array\t= tqArray,\t/* duh */\n+  tq_Far\t= tqFar,\t/* longer addressing - 8086/8 land */\n+  tq_Vol\t= tqVol,\t/* volatile */\n+  tq_Max\t= tqMax\t\t/* Max type qualifier+1 */\n+} tq_t;\n+\n+/* Redefinition of basic types.  */\n+\n+typedef enum bt {\n+  bt_Nil\t= btNil,\t/* undefined */\n+  bt_Adr\t= btAdr,\t/* address - integer same size as pointer */\n+  bt_Char\t= btChar,\t/* character */\n+  bt_UChar\t= btUChar,\t/* unsigned character */\n+  bt_Short\t= btShort,\t/* short */\n+  bt_UShort\t= btUShort,\t/* unsigned short */\n+  bt_Int\t= btInt,\t/* int */\n+  bt_UInt\t= btUInt,\t/* unsigned int */\n+  bt_Long\t= btLong,\t/* long */\n+  bt_ULong\t= btULong,\t/* unsigned long */\n+  bt_Float\t= btFloat,\t/* float (real) */\n+  bt_Double\t= btDouble,\t/* Double (real) */\n+  bt_Struct\t= btStruct,\t/* Structure (Record) */\n+  bt_Union\t= btUnion,\t/* Union (variant) */\n+  bt_Enum\t= btEnum,\t/* Enumerated */\n+  bt_Typedef\t= btTypedef,\t/* defined via a typedef, isymRef points */\n+  bt_Range\t= btRange,\t/* subrange of int */\n+  bt_Set\t= btSet,\t/* pascal sets */\n+  bt_Complex\t= btComplex,\t/* fortran complex */\n+  bt_DComplex\t= btDComplex,\t/* fortran double complex */\n+  bt_Indirect\t= btIndirect,\t/* forward or unnamed typedef */\n+  bt_FixedDec\t= btFixedDec,\t/* Fixed Decimal */\n+  bt_FloatDec\t= btFloatDec,\t/* Float Decimal */\n+  bt_String\t= btString,\t/* Varying Length Character String */\n+  bt_Bit\t= btBit,\t/* Aligned Bit String */\n+  bt_Picture\t= btPicture,\t/* Picture */\n+  bt_Void\t= btVoid,\t/* void */\n+  bt_Max\t= btMax\t\t/* Max basic type+1 */\n+} bt_t;\n+\n+/* Redefinition of the language codes.  */\n+\n+typedef enum lang {\n+  lang_C\t = langC,\n+  lang_Pascal\t = langPascal,\n+  lang_Fortran\t = langFortran,\n+  lang_Assembler = langAssembler,\n+  lang_Machine\t = langMachine,\n+  lang_Nil\t = langNil,\n+  lang_Ada\t = langAda,\n+  lang_Pl1\t = langPl1,\n+  lang_Cobol\t = langCobol\n+} lang_t;\n+\n+/* Redefinition of the debug level codes.  */\n+\n+typedef enum glevel {\n+  glevel_0\t= GLEVEL_0,\n+  glevel_1\t= GLEVEL_1,\n+  glevel_2\t= GLEVEL_2,\n+  glevel_3\t= GLEVEL_3\n+} glevel_t;\n+\n+\f\n+/* Keep track of the active scopes.  */\n+typedef struct scope {\n+  struct scope *prev;\t\t/* previous scope */\n+  ulong open_sym;\t\t/* symbol opening scope */\n+  sc_t sc;\t\t\t/* storage class */\n+  st_t st;\t\t\t/* symbol type */\n+} scope_t;\n+\n+struct filehdr global_hdr;\t/* a.out header */\n+\n+int\t errors\t\t= 0;\t/* # of errors */\n+int\t want_aux\t= 0;\t/* print aux table */\n+int\t want_line\t= 0;\t/* print line numbers */\n+int\t want_rfd\t= 0;\t/* print relative file desc's */\n+int\t want_scope\t= 0;\t/* print scopes for every symbol */\n+int\t tfile_fd;\t\t/* file descriptor of .T file */\n+off_t\t tfile_offset;\t\t/* current offset in .T file */\n+scope_t\t*cur_scope\t= 0;\t/* list of active scopes */\n+scope_t\t*free_scope\t= 0;\t/* list of freed scopes */\n+HDRR\t sym_hdr;\t\t/* symbolic header */\n+char\t*l_strings;\t\t/* local strings */\n+char\t*e_strings;\t\t/* external strings */\n+SYMR\t*l_symbols;\t\t/* local symbols */\n+EXTR\t*e_symbols;\t\t/* external symbols */\n+LINER\t*lines;\t\t\t/* line numbers */\n+DNR\t*dense_nums;\t\t/* dense numbers */\n+OPTR\t*opt_symbols;\t\t/* optimization symbols */\n+AUXU\t*aux_symbols;\t\t/* Auxilary symbols */\n+char\t*aux_used;\t\t/* map of which aux syms are used */\n+FDR\t*file_desc;\t\t/* file tables */\n+ulong\t*rfile_desc;\t\t/* relative file tables */\n+PDR\t*proc_desc;\t\t/* procedure tables */\n+\n+/* Forward reference for functions.  */\n+PTR_T read_seek\t\t__proto((PTR_T, size_t, off_t, const char *));\n+void  read_tfile\t__proto((void));\n+void  print_global_hdr\t__proto((struct filehdr *));\n+void  print_sym_hdr\t__proto((HDRR *));\n+void  print_file_desc\t__proto((FDR *, int));\n+void  print_symbol\t__proto((SYMR *, int, char *, AUXU *, int));\n+void  print_aux\t\t__proto((AUXU, int, int));\n+void  emit_aggregate\t__proto((char *, AUXU, AUXU, const char *));\n+char *st_to_string\t__proto((st_t));\n+char *sc_to_string\t__proto((sc_t));\n+char *glevel_to_string\t__proto((glevel_t));\n+char *lang_to_string\t__proto((lang_t));\n+char *type_to_string\t__proto((AUXU *, int));\n+\n+/* Library routines with prototypes.  */\n+#if !defined(NO_LIB_PROTOTYPE) && !defined(_OSF_SOURCE) && !defined(_STDIO_H_)\n+extern void\tperror\t__proto((const char *));\n+extern char    *strcpy\t__proto((char *, const char *));\n+extern int\tstrlen\t__proto((const char *));\n+extern int\topen\t__proto((const char *, int, ...));\n+#endif\n+\n+extern int\tread\t__proto((int, PTR_T, size_t));\n+extern int\twrite\t__proto((int, CPTR_T, size_t));\n+extern int\tclose\t__proto((int));\n+extern off_t\tlseek\t__proto((int, off_t, int));\n+extern PTR_T\tmalloc\t__proto((size_t));\n+extern PTR_T\tcalloc\t__proto((size_t, size_t));\n+extern PTR_T\trealloc\t__proto((PTR_T, size_t));\n+extern void\tfree\t__proto((PTR_T));\n+extern void\texit\t__proto((int));\n+extern char    *ctime\t__proto((time_t *));\n+extern int\tgetopt\t__proto((int, char **, const char *));\n+\n+extern char *optarg;\n+extern int   optind;\n+extern int   opterr;\n+\n+/* Create a table of debugging stab-codes and corresponding names.  */\n+\n+#define __define_stab(NAME, CODE, STRING) {(int)CODE, STRING},\n+struct {short code; char string[10];} stab_names[]  = {\n+#include \"stab.def\"\n+#undef __define_stab\n+};\n+\n+\f\n+/* Read some bytes at a specified location, and return a pointer.  */\n+\n+PTR_T\n+read_seek (ptr, size, offset, context)\n+     PTR_T ptr;\t\t\t/* pointer to buffer or NULL */\n+     size_t size;\t\t/* # bytes to read */\n+     off_t offset;\t\t/* offset to read at */\n+     const char *context;\t/* context for error message */\n+{\n+  long read_size = 0;\n+\n+  if (size == 0)\t\t/* nothing to read */\n+    return ptr;\n+\n+  if ((ptr == (PTR_T)0 && (ptr = malloc (size)) == (PTR_T)0)\n+      || (tfile_offset != offset && lseek (tfile_fd, offset, 0) == -1)\n+      || (read_size = read (tfile_fd, ptr, size)) < 0)\n+    {\n+      perror (context);\n+      exit (1);\n+    }\n+\n+  if (read_size != size)\n+    {\n+      fprintf (stderr, \"%s: read %ld bytes, expected %ld bytes\\n\",\n+\t       context, read_size, (long) size);\n+      exit (1);\n+    }\n+\n+  tfile_offset = offset + size;\n+  return ptr;\n+}\n+\n+\f\n+/* Convert language code to string format.  */\n+\n+char *\n+lang_to_string (lang)\n+     lang_t lang;\n+{\n+  switch (lang)\n+    {\n+    case langC:\t\treturn \"C\";\n+    case langPascal:\treturn \"Pascal\";\n+    case langFortran:\treturn \"Fortran\";\n+    case langAssembler:\treturn \"Assembler\";\n+    case langMachine:\treturn \"Machine\";\n+    case langNil:\treturn \"Nil\";\n+    case langAda:\treturn \"Ada\";\n+    case langPl1:\treturn \"Pl1\";\n+    case langCobol:\treturn \"Cobol\";\n+    }\n+\n+  return \"Unknown language\";\n+}\n+\n+\f\n+/* Convert storage class to string.  */\n+\n+char *\n+sc_to_string(storage_class)\n+     sc_t storage_class;\n+{\n+  switch(storage_class)\n+    {\n+    case sc_Nil:\t return \"Nil\";\n+    case sc_Text:\t return \"Text\";\n+    case sc_Data:\t return \"Data\";\n+    case sc_Bss:\t return \"Bss\";\n+    case sc_Register:\t return \"Register\";\n+    case sc_Abs:\t return \"Abs\";\n+    case sc_Undefined:\t return \"Undefined\";\n+    case sc_CdbLocal:\t return \"CdbLocal\";\n+    case sc_Bits:\t return \"Bits\";\n+    case sc_CdbSystem:\t return \"CdbSystem\";\n+    case sc_RegImage:\t return \"RegImage\";\n+    case sc_Info:\t return \"Info\";\n+    case sc_UserStruct:\t return \"UserStruct\";\n+    case sc_SData:\t return \"SData\";\n+    case sc_SBss:\t return \"SBss\";\n+    case sc_RData:\t return \"RData\";\n+    case sc_Var:\t return \"Var\";\n+    case sc_Common:\t return \"Common\";\n+    case sc_SCommon:\t return \"SCommon\";\n+    case sc_VarRegister: return \"VarRegister\";\n+    case sc_Variant:\t return \"Variant\";\n+    case sc_SUndefined:\t return \"SUndefined\";\n+    case sc_Init:\t return \"Init\";\n+    case sc_Max:\t return \"Max\";\n+    }\n+\n+  return \"???\";\n+}\n+\n+\f\n+/* Convert symbol type to string.  */\n+\n+char *\n+st_to_string(symbol_type)\n+     st_t symbol_type;\n+{\n+  switch(symbol_type)\n+    {\n+    case st_Nil:\treturn \"Nil\";\n+    case st_Global:\treturn \"Global\";\n+    case st_Static:\treturn \"Static\";\n+    case st_Param:\treturn \"Param\";\n+    case st_Local:\treturn \"Local\";\n+    case st_Label:\treturn \"Label\";\n+    case st_Proc:\treturn \"Proc\";\n+    case st_Block:\treturn \"Block\";\n+    case st_End:\treturn \"End\";\n+    case st_Member:\treturn \"Member\";\n+    case st_Typedef:\treturn \"Typedef\";\n+    case st_File:\treturn \"File\";\n+    case st_RegReloc:\treturn \"RegReloc\";\n+    case st_Forward:\treturn \"Forward\";\n+    case st_StaticProc:\treturn \"StaticProc\";\n+    case st_Constant:\treturn \"Constant\";\n+    case st_StaParam:\treturn \"StaticParam\";\n+    case st_Str:\treturn \"String\";\n+    case st_Number:\treturn \"Number\";\n+    case st_Expr:\treturn \"Expr\";\n+    case st_Type:\treturn \"Type\";\n+    case st_Max:\treturn \"Max\";\n+    }\n+\n+  return \"???\";\n+}\n+\n+\f\n+/* Convert debug level to string.  */\n+\n+char *\n+glevel_to_string (g_level)\n+     glevel_t g_level;\n+{\n+  switch(g_level)\n+    {\n+    case GLEVEL_0: return \"G0\";\n+    case GLEVEL_1: return \"G1\";\n+    case GLEVEL_2: return \"G2\";\n+    case GLEVEL_3: return \"G3\";\n+    }\n+\n+  return \"??\";\n+}\n+     \n+\f\n+/* Convert the type information to string format.  */\n+\n+char *\n+type_to_string (aux_ptr, index)\n+     AUXU *aux_ptr;\n+     int index;\n+{\n+  AUXU u;\n+  struct qual {\n+    tq_t type;\n+    int  low_bound;\n+    int  high_bound;\n+    int  stride;\n+  } qualifiers[7];\n+\n+  bt_t basic_type;\n+  int i;\n+  static char buffer1[1024];\n+  static char buffer2[1024];\n+  char *p1 = buffer1;\n+  char *p2 = buffer2;\n+  char *used_ptr = aux_used + (aux_ptr - aux_symbols);\n+\n+  for (i = 0; i < 7; i++)\n+    {\n+      qualifiers[i].low_bound = 0;\n+      qualifiers[i].high_bound = 0;\n+      qualifiers[i].stride = 0;\n+    }\n+\n+  used_ptr[index] = 1;\n+  u = aux_ptr[index++];\n+  if (u.isym == -1)\n+    return \"-1 (no type)\";\n+\n+  basic_type = (bt_t) u.ti.bt;\n+  qualifiers[0].type = (tq_t) u.ti.tq0;\n+  qualifiers[1].type = (tq_t) u.ti.tq1;\n+  qualifiers[2].type = (tq_t) u.ti.tq2;\n+  qualifiers[3].type = (tq_t) u.ti.tq3;\n+  qualifiers[4].type = (tq_t) u.ti.tq4;\n+  qualifiers[5].type = (tq_t) u.ti.tq5;\n+  qualifiers[6].type = tq_Nil;\n+\n+  /*\n+   * Go get the basic type.\n+   */\n+  switch (basic_type)\n+    {\n+    case bt_Nil:\t\t/* undefined */\n+      strcpy (p1, \"nil\");\n+      break;\n+\n+    case bt_Adr:\t\t/* address - integer same size as pointer */\n+      strcpy (p1, \"address\");\n+      break;\n+\n+    case bt_Char:\t\t/* character */\n+      strcpy (p1, \"char\");\n+      break;\n+\n+    case bt_UChar:\t\t/* unsigned character */\n+      strcpy (p1, \"unsigned char\");\n+      break;\n+\n+    case bt_Short:\t\t/* short */\n+      strcpy (p1, \"short\");\n+      break;\n+\n+    case bt_UShort:\t\t/* unsigned short */\n+      strcpy (p1, \"unsigned short\");\n+      break;\n+\n+    case bt_Int:\t\t/* int */\n+      strcpy (p1, \"int\");\n+      break;\n+\n+    case bt_UInt:\t\t/* unsigned int */\n+      strcpy (p1, \"unsigned int\");\n+      break;\n+\n+    case bt_Long:\t\t/* long */\n+      strcpy (p1, \"long\");\n+      break;\n+\n+    case bt_ULong:\t\t/* unsigned long */\n+      strcpy (p1, \"unsigned long\");\n+      break;\n+\n+    case bt_Float:\t\t/* float (real) */\n+      strcpy (p1, \"float\");\n+      break;\n+\n+    case bt_Double:\t\t/* Double (real) */\n+      strcpy (p1, \"double\");\n+      break;\n+\n+      /* Structures add 1-2 aux words:\n+\t 1st word is [ST_RFDESCAPE, offset] pointer to struct def;\n+\t 2nd word is file index if 1st word rfd is ST_RFDESCAPE.  */\n+\n+    case bt_Struct:\t\t/* Structure (Record) */\n+      emit_aggregate (p1, aux_ptr[index], aux_ptr[index+1], \"struct\");\n+      used_ptr[index] = 1;\n+      if (aux_ptr[index].rndx.rfd == ST_RFDESCAPE)\n+\tused_ptr[++index] = 1;\n+\n+      index++;\t\t\t/* skip aux words */\n+      break;\n+\n+      /* Unions add 1-2 aux words:\n+\t 1st word is [ST_RFDESCAPE, offset] pointer to union def;\n+\t 2nd word is file index if 1st word rfd is ST_RFDESCAPE.  */\n+\n+    case bt_Union:\t\t/* Union */\n+      emit_aggregate (p1, aux_ptr[index], aux_ptr[index+1], \"union\");\n+      used_ptr[index] = 1;\n+      if (aux_ptr[index].rndx.rfd == ST_RFDESCAPE)\n+\tused_ptr[++index] = 1;\n+\n+      index++;\t\t\t/* skip aux words */\n+      break;\n+\n+      /* Enumerations add 1-2 aux words:\n+\t 1st word is [ST_RFDESCAPE, offset] pointer to enum def;\n+\t 2nd word is file index if 1st word rfd is ST_RFDESCAPE.  */\n+\n+    case bt_Enum:\t\t/* Enumeration */\n+      emit_aggregate (p1, aux_ptr[index], aux_ptr[index+1], \"enum\");\n+      used_ptr[index] = 1;\n+      if (aux_ptr[index].rndx.rfd == ST_RFDESCAPE)\n+\tused_ptr[++index] = 1;\n+\n+      index++;\t\t\t/* skip aux words */\n+      break;\n+\n+    case bt_Typedef:\t\t/* defined via a typedef, isymRef points */\n+      strcpy (p1, \"typedef\");\n+      break;\n+\n+    case bt_Range:\t\t/* subrange of int */\n+      strcpy (p1, \"subrange\");\n+      break;\n+\n+    case bt_Set:\t\t/* pascal sets */\n+      strcpy (p1, \"set\");\n+      break;\n+\n+    case bt_Complex:\t\t/* fortran complex */\n+      strcpy (p1, \"complex\");\n+      break;\n+\n+    case bt_DComplex:\t\t/* fortran double complex */\n+      strcpy (p1, \"double complex\");\n+      break;\n+\n+    case bt_Indirect:\t\t/* forward or unnamed typedef */\n+      strcpy (p1, \"forward/unamed typedef\");\n+      break;\n+\n+    case bt_FixedDec:\t\t/* Fixed Decimal */\n+      strcpy (p1, \"fixed decimal\");\n+      break;\n+\n+    case bt_FloatDec:\t\t/* Float Decimal */\n+      strcpy (p1, \"float decimal\");\n+      break;\n+\n+    case bt_String:\t\t/* Varying Length Character String */\n+      strcpy (p1, \"string\");\n+      break;\n+\n+    case bt_Bit:\t\t/* Aligned Bit String */\n+      strcpy (p1, \"bit\");\n+      break;\n+\n+    case bt_Picture:\t\t/* Picture */\n+      strcpy (p1, \"picture\");\n+      break;\n+\n+    case bt_Void:\t\t/* Void */\n+      strcpy (p1, \"void\");\n+      break;\n+\n+    default:\n+      sprintf (p1, \"Unknown basic type %d\", (int) basic_type);\n+      break;\n+    }\n+\n+  p1 += strlen (buffer1);\n+\n+  /*\n+   * If this is a bitfield, get the bitsize.\n+   */\n+  if (u.ti.fBitfield)\n+    {\n+      int bitsize;\n+\n+      used_ptr[index] = 1;\n+      bitsize = aux_ptr[index++].width;\n+      sprintf (p1, \" : %d\", bitsize);\n+      p1 += strlen (buffer1);\n+    }\n+\n+\n+  /*\n+   * Deal with any qualifiers.\n+   */\n+  if (qualifiers[0].type != tq_Nil)\n+    {\n+      /*\n+       * Snarf up any array bounds in the correct order.  Arrays\n+       * store 5 succesive words in the aux. table:\n+       *\tword 0\tRNDXR to type of the bounds (ie, int)\n+       *\tword 1\tCurrent file descriptor index\n+       *\tword 2\tlow bound\n+       *\tword 3\thigh bound (or -1 if [])\n+       *\tword 4\tstride size in bits\n+       */\n+      for (i = 0; i < 7; i++)\n+\t{\n+\t  if (qualifiers[i].type == tq_Array)\n+\t    {\n+\t      qualifiers[i].low_bound  = aux_ptr[index+2].dnLow;\n+\t      qualifiers[i].high_bound = aux_ptr[index+3].dnHigh;\n+\t      qualifiers[i].stride     = aux_ptr[index+4].width;\n+\t      used_ptr[index] = 1;\n+\t      used_ptr[index+1] = 1;\n+\t      used_ptr[index+2] = 1;\n+\t      used_ptr[index+3] = 1;\n+\t      used_ptr[index+4] = 1;\n+\t      index += 5;\n+\t    }\n+\t}\n+\n+      /*\n+       * Now print out the qualifiers.\n+       */\n+      for (i = 0; i < 6; i++)\n+\t{\n+\t  switch (qualifiers[i].type)\n+\t    {\n+\t    case tq_Nil:\n+\t    case tq_Max:\n+\t      break;\n+\n+\t    case tq_Ptr:\n+\t      strcpy (p2, \"ptr to \");\n+\t      p2 += sizeof (\"ptr to \")-1;\n+\t      break;\n+\n+\t    case tq_Vol:\n+\t      strcpy (p2, \"volatile \");\n+\t      p2 += sizeof (\"volatile \")-1;\n+\t      break;\n+\n+\t    case tq_Far:\n+\t      strcpy (p2, \"far \");\n+\t      p2 += sizeof (\"far \")-1;\n+\t      break;\n+\n+\t    case tq_Proc:\n+\t      strcpy (p2, \"func. ret. \");\n+\t      p2 += sizeof (\"func. ret. \");\n+\t      break;\n+\n+\t    case tq_Array:\n+\t      {\n+\t\tint first_array = i;\n+\t\tint j;\n+\n+\t\t/* Print array bounds reversed (ie, in the order the C\n+\t\t   programmer writes them).  C is such a fun language.... */\n+\n+\t\twhile (i < 5 && qualifiers[i+1].type == tq_Array)\n+\t\t  i++;\n+\n+\t\tfor (j = i; j >= first_array; j--)\n+\t\t  {\n+\t\t    strcpy (p2, \"array [\");\n+\t\t    p2 += sizeof (\"array [\")-1;\n+\t\t    if (qualifiers[j].low_bound != 0)\n+\t\t      sprintf (p2,\n+\t\t\t       \"%ld:%ld {%ld bits}\",\n+\t\t\t       (long) qualifiers[j].low_bound,\n+\t\t\t       (long) qualifiers[j].high_bound,\n+\t\t\t       (long) qualifiers[j].stride);\n+\n+\t\t    else if (qualifiers[j].high_bound != -1)\n+\t\t      sprintf (p2,\n+\t\t\t       \"%ld {%ld bits}\",\n+\t\t\t       (long) (qualifiers[j].high_bound + 1),\n+\t\t\t       (long) (qualifiers[j].stride));\n+\n+\t\t    else\n+\t\t      sprintf (p2, \" {%ld bits}\", (long) (qualifiers[j].stride));\n+\n+\t\t    p2 += strlen (p2);\n+\t\t    strcpy (p2, \"] of \");\n+\t\t    p2 += sizeof (\"] of \")-1;\n+\t\t  }\n+\t      }\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  strcpy (p2, buffer1);\n+  return buffer2;\n+}\n+\n+\f\n+/* Print out the global file header for object files.  */\n+\n+void\n+print_global_hdr (ptr)\n+     struct filehdr *ptr;\n+{\n+  char *time = ctime ((off_t *)&ptr->f_timdat);\n+  ushort flags = ptr->f_flags;\n+\n+  printf(\"Global file header:\\n\");\n+  printf(\"    %-*s 0x%x\\n\",    24, \"magic number\",\t     (ushort) ptr->f_magic);\n+  printf(\"    %-*s %d\\n\",      24, \"# sections\",\t     (int)    ptr->f_nscns);\n+  printf(\"    %-*s %ld, %s\",   24, \"timestamp\",\t\t     (long)   ptr->f_timdat, time);\n+  printf(\"    %-*s %ld\\n\",     24, \"symbolic header offset\", (long)   ptr->f_symptr);\n+  printf(\"    %-*s %ld\\n\",     24, \"symbolic header size\",   (long)   ptr->f_nsyms);\n+  printf(\"    %-*s %ld\\n\",     24, \"optional header\",\t     (long)   ptr->f_opthdr);\n+  printf(\"    %-*s 0x%lx\",     24, \"flags\",\t\t     (ushort) flags);\n+\n+  if ((flags & F_RELFLG) != 0)\n+    printf (\", F_RELFLG\");\n+\n+  if ((flags & F_EXEC) != 0)\n+    printf (\", F_EXEC\");\n+\n+  if ((flags & F_LNNO) != 0)\n+    printf (\", F_LNNO\");\n+\n+  if ((flags & F_LSYMS) != 0)\n+    printf (\", F_LSYMS\");\n+\n+  if ((flags & F_MINMAL) != 0)\n+    printf (\", F_MINMAL\");\n+\n+  if ((flags & F_UPDATE) != 0)\n+    printf (\", F_UPDATE\");\n+\n+  if ((flags & F_SWABD) != 0)\n+    printf (\", F_SWABD\");\n+\n+  if ((flags & F_AR16WR) != 0)\n+    printf (\", F_AR16WR\");\n+\n+  if ((flags & F_AR32WR) != 0)\n+    printf (\", F_AR32WR\");\n+\n+  if ((flags & F_AR32W) != 0)\n+    printf (\", F_AR32W\");\n+\n+  if ((flags & F_PATCH) != 0)\n+    printf (\", F_PATCH/F_NODF\");\n+\n+  printf (\"\\n\\n\");\n+}\n+\n+\f\n+/* Print out the symbolic header.  */\n+\n+void\n+print_sym_hdr (sym_ptr)\n+     HDRR *sym_ptr;\n+{\n+  int width = 20;\n+\n+  printf(\"Symbolic header, magic number = 0x%04x, vstamp = %d.%d:\\n\\n\",\n+\t sym_ptr->magic & 0xffff,\n+\t (sym_ptr->vstamp & 0xffff) >> 8,\n+\t sym_ptr->vstamp & 0xff);\n+\n+  printf(\"    %-*s %11s %11s %11s\\n\", width, \"Info\", \"Offset\", \"Number\", \"Bytes\");\n+  printf(\"    %-*s %11s %11s %11s\\n\", width, \"====\", \"======\", \"======\", \"=====\\n\");\n+\n+  printf(\"    %-*s %11ld %11d %11d [%d]\\n\", width, \"Line numbers\",\n+\t sym_ptr->cbLineOffset, sym_ptr->cbLine, sym_ptr->cbLine, sym_ptr->ilineMax);\n+\n+  printf(\"    %-*s %11ld %11d %11d\\n\", width, \"Dense numbers\",\n+\t sym_ptr->cbDnOffset, sym_ptr->idnMax, sym_ptr->idnMax * sizeof (DNR));\n+\n+  printf(\"    %-*s %11ld %11d %11d\\n\", width, \"Procedures Tables\",\n+\t sym_ptr->cbPdOffset, sym_ptr->ipdMax, sym_ptr->ipdMax * sizeof (PDR));\n+\n+  printf(\"    %-*s %11ld %11d %11d\\n\", width, \"Local Symbols\",\n+\t sym_ptr->cbSymOffset, sym_ptr->isymMax, sym_ptr->isymMax * sizeof (SYMR));\n+\n+  printf(\"    %-*s %11ld %11d %11d\\n\", width, \"Optimization Symbols\",\n+\t sym_ptr->cbOptOffset, sym_ptr->ioptMax, sym_ptr->ioptMax * sizeof (OPTR));\n+\n+  printf(\"    %-*s %11ld %11d %11d\\n\", width, \"Auxilary Symbols\",\n+\t sym_ptr->cbAuxOffset, sym_ptr->iauxMax, sym_ptr->iauxMax * sizeof (AUXU));\n+\n+  printf(\"    %-*s %11ld %11d %11d\\n\", width, \"Local Strings\",\n+\t sym_ptr->cbSsOffset, sym_ptr->issMax, sym_ptr->issMax);\n+\n+  printf(\"    %-*s %11ld %11d %11d\\n\", width, \"External Strings\",\n+\t sym_ptr->cbSsExtOffset, sym_ptr->issExtMax, sym_ptr->issExtMax);\n+\n+  printf(\"    %-*s %11ld %11d %11d\\n\", width, \"File Tables\",\n+\t sym_ptr->cbFdOffset, sym_ptr->ifdMax, sym_ptr->ifdMax * sizeof (FDR));\n+\n+  printf(\"    %-*s %11ld %11d %11d\\n\", width, \"Relative Files\",\n+\t sym_ptr->cbRfdOffset, sym_ptr->crfd, sym_ptr->crfd * sizeof (ulong));\n+\n+  printf(\"    %-*s %11ld %11d %11d\\n\", width, \"External Symbols\",\n+\t sym_ptr->cbExtOffset, sym_ptr->iextMax, sym_ptr->iextMax * sizeof (EXTR));\n+}\n+\n+\f\n+/* Print out a symbol.  */\n+\n+void\n+print_symbol (sym_ptr, number, strbase, aux_base, ifd)\n+     SYMR *sym_ptr;\n+     int number;\n+     char *strbase;\n+     AUXU *aux_base;\n+     int ifd;\n+{\n+  sc_t storage_class = (sc_t) sym_ptr->sc;\n+  st_t symbol_type   = (st_t) sym_ptr->st;\n+  ulong index\t     = sym_ptr->index;\n+  char *used_ptr     = aux_used + (aux_base - aux_symbols);\n+  scope_t *scope_ptr;\n+\n+  printf (\"\\n    Symbol# %d: \\\"%s\\\"\\n\", number, sym_ptr->iss + strbase);\n+\n+  if (aux_base != (AUXU *)0 && index != indexNil)\n+    switch (symbol_type)\n+      {\n+      case st_Nil:\n+      case st_Label:\n+\tbreak;\n+\n+      case st_File:\n+      case st_Block:\n+\tprintf (\"      End+1 symbol: %ld\\n\", index);\n+\tif (want_scope)\n+\t  {\n+\t    if (free_scope == (scope_t *)0)\n+\t      scope_ptr = (scope_t *) malloc (sizeof (scope_t));\n+\t    else\n+\t      {\n+\t\tscope_ptr = free_scope;\n+\t\tfree_scope = scope_ptr->prev;\n+\t      }\n+\t    scope_ptr->open_sym = number;\n+\t    scope_ptr->st = symbol_type;\n+\t    scope_ptr->sc = storage_class;\n+\t    scope_ptr->prev = cur_scope;\n+\t    cur_scope = scope_ptr;\n+\t  }\n+\tbreak;\n+\n+      case st_End:\n+\tif (storage_class == sc_Text || storage_class == sc_Info)\n+\t  printf (\"      First symbol: %ld\\n\", index);\n+\telse\n+\t  {\n+\t    used_ptr[index] = 1;\n+\t    printf (\"      First symbol: %ld\\n\", aux_base[index].isym);\n+\t  }\n+\n+\tif (want_scope)\n+\t  {\n+\t    if (cur_scope == (scope_t *)0)\n+\t      printf (\"      Can't pop end scope\\n\");\n+\t    else\n+\t      {\n+\t\tscope_ptr = cur_scope;\n+\t\tcur_scope = scope_ptr->prev;\n+\t\tscope_ptr->prev = free_scope;\n+\t\tfree_scope = scope_ptr;\n+\t      }\n+\t  }\n+\tbreak;\n+\n+      case st_Proc:\n+      case st_StaticProc:\n+\tif (MIPS_IS_STAB(sym_ptr))\n+\t  ;\n+\telse if (ifd == -1)\t\t/* local symbol */\n+\t  {\n+\t    used_ptr[index] = used_ptr[index+1] = 1;\n+\t    printf (\"      End+1 symbol: %-7ld   Type:  %s\\n\",\n+\t\t    aux_base[index].isym, type_to_string (aux_base, index+1));\n+\t  }\n+\telse\t\t\t/* global symbol */\n+\t  {\n+\t    used_ptr[index] = 1;\n+\t    printf (\"      Type: %s\\n\",\n+\t\t    type_to_string (aux_base, index));\n+\t  }\n+\n+\tif (want_scope)\n+\t  {\n+\t    if (free_scope == (scope_t *)0)\n+\t      scope_ptr = (scope_t *) malloc (sizeof (scope_t));\n+\t    else\n+\t      {\n+\t\tscope_ptr = free_scope;\n+\t\tfree_scope = scope_ptr->prev;\n+\t      }\n+\t    scope_ptr->open_sym = number;\n+\t    scope_ptr->st = symbol_type;\n+\t    scope_ptr->sc = storage_class;\n+\t    scope_ptr->prev = cur_scope;\n+\t    cur_scope = scope_ptr;\n+\t  }\n+\tbreak;\n+\n+      default:\n+\tif (!MIPS_IS_STAB (sym_ptr))\n+\t  {\n+\t    used_ptr[index] = 1;\n+\t    printf (\"      Type: %s\\n\",\n+\t\t    type_to_string (aux_base, index));\n+\t  }\n+\tbreak;\n+      }\n+\n+  if (want_scope)\n+    {\n+      printf (\"      Scopes:  \");\n+      if (cur_scope == (scope_t *)0)\n+\tprintf (\" none\\n\");\n+      else\n+\t{\n+\t  for (scope_ptr = cur_scope;\n+\t       scope_ptr != (scope_t *)0;\n+\t       scope_ptr = scope_ptr->prev)\n+\t    {\n+\t      char *class;\n+\t      if (scope_ptr->st == st_Proc || scope_ptr->st == st_StaticProc)\n+\t\tclass = \"func.\";\n+\t      else if (scope_ptr->st == st_File)\n+\t\tclass = \"file\";\n+\t      else if (scope_ptr->st == st_Block && scope_ptr->sc == sc_Text)\n+\t\tclass = \"block\";\n+\t      else if (scope_ptr->st == st_Block && scope_ptr->sc == sc_Info)\n+\t\tclass = \"type\";\n+\t      else\n+\t\tclass = \"???\";\n+\n+\t      printf (\" %d [%s]\", scope_ptr->open_sym, class);\n+\t    }\n+\t  printf (\"\\n\");\n+\t}\n+    }\n+\n+  printf (\"      Value: %-13ld    \",\n+\t  (long)sym_ptr->value);\n+  if (ifd == -1)\n+    printf (\"String index: %ld\\n\", (long)sym_ptr->iss);\n+  else\n+    printf (\"String index: %-11ld Ifd: %d\\n\",\n+\t    (long)sym_ptr->iss, ifd);\n+\n+  printf (\"      Symbol type: %-11sStorage class: %-11s\",\n+\t  st_to_string (symbol_type), sc_to_string (storage_class));\n+\n+  if (MIPS_IS_STAB(sym_ptr))\n+    {\n+      register int i = sizeof(stab_names) / sizeof(stab_names[0]);\n+      char *stab_name = \"stab\";\n+      short code = MIPS_UNMARK_STAB(sym_ptr->index);\n+      while (--i >= 0)\n+\tif (stab_names[i].code == code)\n+\t  {\n+\t    stab_name = stab_names[i].string;\n+\t    break;\n+\t  }\n+      printf (\"Index: 0x%lx (%s)\\n\", (long)sym_ptr->index, stab_name);\n+    }\n+  else if (sym_ptr->st == stLabel && sym_ptr->index != indexNil)\n+    printf (\"Index: %ld (line#)\\n\", (long)sym_ptr->index);\n+  else\n+    printf (\"Index: %ld\\n\", (long)sym_ptr->index);\n+\n+}\n+\n+\f\n+/* Print out a word from the aux. table in various formats.  */\n+\n+void\n+print_aux (u, auxi, used)\n+     AUXU u;\n+     int auxi;\n+     int used;\n+{\n+  printf (\"\\t%s#%-5d %11ld, [%4ld/%7ld], [%2d %1d:%1d %1x:%1x:%1x:%1x:%1x:%1x]\\n\",\n+\t  (used) ? \"  \" : \"* \",\n+\t  auxi,\n+\t  (long) u.isym,\n+\t  (long) u.rndx.rfd,\n+\t  (long) u.rndx.index,\n+\t  u.ti.bt,\n+\t  u.ti.fBitfield,\n+\t  u.ti.continued,\n+\t  u.ti.tq0,\n+\t  u.ti.tq1,\n+\t  u.ti.tq2,\n+\t  u.ti.tq3,\n+\t  u.ti.tq4,\n+\t  u.ti.tq5);\n+}\n+\n+\f\n+/* Write aggregate information to a string.  */\n+\n+void\n+emit_aggregate (string, u, u2, which)\n+     char *string;\n+     AUXU u;\n+     AUXU u2;\n+     const char *which;\n+{\n+  int ifd = u.rndx.rfd;\n+  int index = u.rndx.index;\n+  int sym_base, ss_base;\n+  int name;\n+  \n+  if (ifd == ST_RFDESCAPE)\n+    ifd = u2.isym;\n+\n+  sym_base = file_desc[ifd].isymBase;\n+  ss_base  = file_desc[ifd].issBase;\n+  \n+  name = (index == indexNil) ? 0 : l_symbols[index + sym_base].iss;\n+  sprintf (string,\n+\t   \"%s %s { ifd = %d, index = %d }\",\n+\t   which,\n+\t   (name == 0) ? \"/* no name */\" : &l_strings[ ss_base + name ],\n+\t   ifd,\n+\t   index);\n+}\n+\n+\f\n+/* Print out information about a file descriptor, and the symbols,\n+   procedures, and line numbers within it.  */\n+\n+void\n+print_file_desc (fdp, number)\n+     FDR *fdp;\n+     int number;\n+{\n+  char *str_base;\n+  AUXU *aux_base;\n+  int symi, pdi;\n+  int width = 20;\n+  char *used_base;\n+  \n+  str_base = l_strings + fdp->issBase;  \n+  aux_base = aux_symbols + fdp->iauxBase;\n+  used_base = aux_used + (aux_base - aux_symbols);\n+\n+  printf (\"\\nFile #%d, \\\"%s\\\"\\n\\n\", number, str_base + fdp->rss);\n+\n+  printf (\"    Name index  = %-10d Readin      = %s\\n\",\n+\t  (long) fdp->rss, (fdp->fReadin) ? \"Yes\" : \"No\");\n+\n+  printf (\"    Merge       = %-10s Endian      = %s\\n\",\n+\t  (fdp->fMerge)  ? \"Yes\" : \"No\",\n+\t  (fdp->fBigendian) ? \"BIG\" : \"LITTLE\");\n+\n+  printf (\"    Debug level = %-10s Language    = %s\\n\",\n+\t  glevel_to_string (fdp->glevel),\n+\t  lang_to_string((lang_t) fdp->lang));\n+\n+  printf (\"    Adr         = 0x%08lx\\n\\n\", (long) fdp->adr);\n+\n+  printf(\"    %-*s %11s %11s %11s %11s\\n\", width, \"Info\", \"Start\", \"Number\", \"Size\", \"Offset\");\n+  printf(\"    %-*s %11s %11s %11s %11s\\n\", width, \"====\", \"=====\", \"======\", \"====\", \"======\");\n+\n+  printf(\"    %-*s %11lu %11lu %11lu %11lu\\n\",\n+\t width, \"Local strings\",\n+\t (ulong) fdp->issBase,\n+\t (ulong) fdp->cbSs,\n+\t (ulong) fdp->cbSs,\n+\t (ulong) (fdp->issBase + sym_hdr.cbSsOffset));\n+\n+  printf(\"    %-*s %11lu %11u %11u %11lu\\n\",\n+\t width, \"Local symbols\",\n+\t (ulong) fdp->isymBase,\n+\t (ulong) fdp->csym,\n+\t (ulong) (fdp->csym * sizeof (SYMR)),\n+\t (ulong) (fdp->isymBase * sizeof (SYMR) + sym_hdr.cbSymOffset));\n+\n+  printf(\"    %-*s %11lu %11lu %11lu %11lu\\n\",\n+\t width, \"Line numbers\",\n+\t (ulong) fdp->cbLineOffset,\n+\t (ulong) fdp->cline,\n+\t (ulong) fdp->cline,\n+\t (ulong) (fdp->cbLineOffset + sym_hdr.cbLineOffset));\n+\n+  printf(\"    %-*s %11lu %11lu %11lu %11lu\\n\",\n+\t width, \"Optimization symbols\",\n+\t (ulong) fdp->ioptBase,\n+\t (ulong) fdp->copt,\n+\t (ulong) (fdp->copt * sizeof (OPTR)),\n+\t (ulong) (fdp->ioptBase * sizeof (OPTR) + sym_hdr.cbOptOffset));\n+\n+  printf(\"    %-*s %11llu %11lu %11lu %11lu\\n\",\n+\t width, \"Procedures\",\n+\t (ulong) fdp->ipdFirst,\n+\t (ulong) fdp->cpd,\n+\t (ulong) (fdp->cpd * sizeof (PDR)),\n+\t (ulong) (fdp->ipdFirst * sizeof (PDR) + sym_hdr.cbPdOffset));\n+\n+  printf(\"    %-*s %11lu %11lu %11lu %11lu\\n\",\n+\t width, \"Auxiliary symbols\",\n+\t (ulong) fdp->iauxBase,\n+\t (ulong) fdp->caux,\n+\t (ulong) (fdp->caux * sizeof (AUXU)),\n+\t (ulong) (fdp->iauxBase * sizeof(AUXU) + sym_hdr.cbAuxOffset));\n+\n+  printf(\"    %-*s %11lu %11lu %11lu %11lu\\n\",\n+\t width, \"Relative Files\",\n+\t (ulong) fdp->rfdBase,\n+\t (ulong) fdp->crfd,\n+\t (ulong) (fdp->crfd * sizeof (ulong)),\n+\t (ulong) (fdp->rfdBase * sizeof(ulong) + sym_hdr.cbRfdOffset));\n+\n+\n+  if (want_scope && cur_scope != (scope_t *)0)\n+    printf (\"\\n    Warning scope does not start at 0!\\n\");\n+\n+  /* \n+   * print the info about the symbol table.\n+   */\n+  printf (\"\\n    There are %lu local symbols, starting at %lu\\n\",\n+\t  (ulong) fdp->csym,\n+\t  (ulong) (fdp->isymBase + sym_hdr.cbSymOffset));\n+\n+  for(symi = fdp->isymBase; symi < (fdp->csym + fdp->isymBase); symi++)\n+    print_symbol (&l_symbols[symi],\n+\t\t  symi - fdp->isymBase,\n+\t\t  str_base,\n+\t\t  aux_base,\n+\t\t  -1);\n+\n+  if (want_scope && cur_scope != (scope_t *)0)\n+    printf (\"\\n    Warning scope does not end at 0!\\n\");\n+\n+  /*\n+   * print the aux. table if desired.\n+   */\n+\n+  if (want_aux && fdp->caux != 0)\n+    {\n+      int auxi;\n+\n+      printf (\"\\n    There are %lu auxiliary table entries, starting at %lu.\\n\\n\",\n+\t      (ulong) fdp->caux,\n+\t      (ulong) (fdp->iauxBase + sym_hdr.cbAuxOffset));\n+\n+      for (auxi = fdp->iauxBase; auxi < (fdp->caux + fdp->iauxBase); auxi++)\n+\tprint_aux (aux_base[auxi], auxi, used_base[auxi]);\n+    }\n+\n+  /*\n+   * print the relative file descriptors.\n+   */\n+  if (want_rfd && fdp->crfd != 0)\n+    {\n+      ulong *rfd_ptr, i;\n+\n+      printf (\"\\n    There are %lu relative file descriptors, starting at %lu.\\n\",\n+\t      (ulong) fdp->crfd,\n+\t      (ulong) fdp->rfdBase);\n+\n+      rfd_ptr = rfile_desc + fdp->rfdBase * sizeof (ulong);\n+      for (i = 0; i < fdp->crfd; i++)\n+\t{\n+\t  printf (\"\\t#%-5ld %11ld, 0x%08lx\\n\", i, *rfd_ptr, *rfd_ptr);\n+\t  rfd_ptr++;\n+\t}\n+    }\n+\n+  /* \n+   * do the procedure descriptors.\n+   */\n+  printf (\"\\n    There are %lu procedure descriptor entries, \", (ulong) fdp->cpd);\n+  printf (\"starting at %lu.\\n\", (ulong) fdp->ipdFirst);\n+\n+  for (pdi = fdp->ipdFirst; pdi < (fdp->cpd + fdp->ipdFirst); pdi++)\n+    {\n+      PDR *proc_ptr = &proc_desc[pdi];\n+      printf (\"\\n\\tProcedure descriptor %d:\\n\", (pdi - fdp->ipdFirst));\n+\n+      printf (\"\\t    Name index   = %-11ld Name          = \\\"%s\\\"\\n\",\n+\t      (long) l_symbols[proc_ptr->isym + fdp->isymBase].iss,\n+\t      l_symbols[proc_ptr->isym + fdp->isymBase].iss + str_base);\n+\n+      printf (\"\\t    .mask 0x%08lx,%-9ld .fmask 0x%08lx,%ld\\n\",\n+\t      (long) proc_ptr->regmask,\n+\t      (long) proc_ptr->regoffset,\n+\t      (long) proc_ptr->fregmask,\n+\t      (long) proc_ptr->fregoffset);\n+\n+      printf (\"\\t    .frame $%d,%ld,$%d\\n\",\n+\t      (int)  proc_ptr->framereg,\n+\t      (long) proc_ptr->frameoffset,\n+\t      (int)  proc_ptr->pcreg);\n+\n+      printf (\"\\t    Opt. start   = %-11ld Symbols start = %ld\\n\",\n+\t      (long) proc_ptr->iopt,\n+\t      (long) proc_ptr->isym);\n+\n+      printf (\"\\t    First line # = %-11ld Last line #   = %ld\\n\",\n+\t      (long) proc_ptr->lnLow,\n+\t      (long) proc_ptr->lnHigh);\n+\n+      printf (\"\\t    Line Offset  = %-11ld Address       = 0x%08lx\\n\",\n+\t      (long) proc_ptr->cbLineOffset,\n+\t      (long) proc_ptr->adr);\n+\n+      /*\n+       * print the line number entries.\n+       */\n+\n+      if (want_line && fdp->cline != 0)\n+\t{\n+\t  int delta, count;\n+\t  long cur_line = proc_ptr->lnLow;\n+\t  uchar *line_ptr = ((uchar *)lines) + proc_ptr->cbLineOffset;\n+\t  uchar *line_end;\n+\n+\t  if (pdi == fdp->cpd + fdp->ipdFirst - 1)\t/* last procedure */\n+\t    line_end = ((uchar *)lines) + fdp->cbLine + fdp->ilineBase;\n+\t  else\t\t\t\t\t\t/* not last proc. */\n+\t    line_end = ((uchar *)lines) + proc_desc[pdi+1].cbLineOffset;\n+\n+\n+\t  printf (\"\\n\\tThere are %lu bytes holding line numbers, starting at %lu.\\n\",\n+\t\t  (ulong) (line_end - line_ptr),\n+\t\t  (ulong) (fdp->ilineBase + sym_hdr.cbLineOffset));\n+\n+\t  while (line_ptr < line_end)\n+\t    {\t\t\t\t\t\t/* sign extend nibble */\n+\t      delta = ((*line_ptr >> 4) ^ 0x8) - 0x8;\n+\t      count = (*line_ptr & 0xf) + 1;\n+\t      if (delta != -8)\n+\t\tline_ptr++;\n+\t      else\n+\t\t{\n+\t\t  delta = (((line_ptr[1]) & 0xff) << 8) + ((line_ptr[2]) & 0xff);\n+\t\t  delta = (delta ^ 0x8000) - 0x8000;\n+\t\t  line_ptr += 3;\n+\t\t}\n+\n+\t      cur_line += delta;\n+\t      printf (\"\\t    Line %11ld,   delta %5d,   count %2d\\n\",\n+\t\t      cur_line,\n+\t\t      delta,\n+\t\t      count);\n+\t    }\n+\t}\n+    }\n+}\n+\n+\f\n+/* Read in the portions of the .T file that we will print out.  */\n+\n+void\n+read_tfile __proto((void))\n+{\n+  short magic;\n+  off_t sym_hdr_offset = 0;\n+\n+  /* Determine if this is a .T file (which has no file header), or some\n+     sort of object file (which does have a file header) via the magic\n+     number.  */\n+  (void) read_seek ((PTR_T) &magic, sizeof (magic), (off_t)0, \"Magic number\");\n+  if (magic == MIPSELMAGIC || magic == MIPSEBMAGIC)\n+    {\n+      (void) read_seek ((PTR_T) &global_hdr, sizeof (global_hdr), (off_t)0,\n+\t\t\t\"Global file header\");\n+\n+      print_global_hdr (&global_hdr);\n+\n+      if (global_hdr.f_symptr == 0)\n+\t{\n+\t  printf (\"No symbolic header, Goodbye!\\n\");\n+\t  exit (1);\n+\t}\n+\n+      sym_hdr_offset = global_hdr.f_symptr;\n+    }\n+\n+  (void) read_seek ((PTR_T) &sym_hdr,\n+\t\t    sizeof (sym_hdr),\n+\t\t    sym_hdr_offset,\n+\t\t    \"Symbolic header\");\n+\n+  print_sym_hdr (&sym_hdr);\n+\n+  lines = (LINER *) read_seek ((PTR_T)0,\n+\t\t\t       sym_hdr.cbLine,\n+\t\t\t       sym_hdr.cbLineOffset,\n+\t\t\t       \"Line numbers\");\n+\n+  dense_nums = (DNR *) read_seek ((PTR_T)0,\n+\t\t\t\t  sym_hdr.idnMax * sizeof (DNR),\n+\t\t\t\t  sym_hdr.cbDnOffset,\n+\t\t\t\t  \"Dense numbers\");\n+\n+  proc_desc = (PDR *) read_seek ((PTR_T)0,\n+\t\t\t\t sym_hdr.ipdMax * sizeof (PDR),\n+\t\t\t\t sym_hdr.cbPdOffset,\n+\t\t\t\t \"Procedure tables\");\n+\n+  l_symbols = (SYMR *) read_seek ((PTR_T)0,\n+\t\t\t\t  sym_hdr.isymMax * sizeof (SYMR),\n+\t\t\t\t  sym_hdr.cbSymOffset,\n+\t\t\t\t  \"Local symbols\");\n+\n+  opt_symbols = (OPTR *) read_seek ((PTR_T)0,\n+\t\t\t\t    sym_hdr.ioptMax * sizeof (OPTR),\n+\t\t\t\t    sym_hdr.cbOptOffset,\n+\t\t\t\t    \"Optimization symbols\");\n+\n+  aux_symbols = (AUXU *) read_seek ((PTR_T)0,\n+\t\t\t\t    sym_hdr.iauxMax * sizeof (AUXU),\n+\t\t\t\t    sym_hdr.cbAuxOffset,\n+\t\t\t\t    \"Auxilary symbols\");\n+\n+  if (sym_hdr.iauxMax > 0)\n+    {\n+      aux_used = calloc (sym_hdr.iauxMax, 1);\n+      if (aux_used == (char *)0)\n+\t{\n+\t  perror (\"calloc\");\n+\t  exit (1);\n+\t}\n+    }\n+\n+  l_strings = (char *) read_seek ((PTR_T)0,\n+\t\t\t\t  sym_hdr.issMax,\n+\t\t\t\t  sym_hdr.cbSsOffset,\n+\t\t\t\t  \"Local string table\");\n+\n+  e_strings = (char *) read_seek ((PTR_T)0,\n+\t\t\t\t  sym_hdr.issExtMax,\n+\t\t\t\t  sym_hdr.cbSsExtOffset,\n+\t\t\t\t  \"External string table\");\n+\n+  file_desc = (FDR *) read_seek ((PTR_T)0,\n+\t\t\t\t sym_hdr.ifdMax * sizeof (FDR),\n+\t\t\t\t sym_hdr.cbFdOffset,\n+\t\t\t\t \"File tables\");\n+\n+  rfile_desc = (ulong *) read_seek ((PTR_T)0,\n+\t\t\t\t    sym_hdr.crfd * sizeof (ulong),\n+\t\t\t\t    sym_hdr.cbRfdOffset,\n+\t\t\t\t    \"Relative file tables\");\n+\n+  e_symbols = (EXTR *) read_seek ((PTR_T)0,\n+\t\t\t\t  sym_hdr.iextMax * sizeof (EXTR),\n+\t\t\t\t  sym_hdr.cbExtOffset,\n+\t\t\t\t  \"External symbols\");\n+}\n+\n+\f\n+\n+int\n+main (argc, argv)\n+     int argc;\n+     char **argv;\n+{\n+  int i, opt;\n+\n+  /*\n+   * Process arguments\n+   */\n+  while ((opt = getopt (argc, argv, \"alrs\")) != EOF)\n+    switch (opt)\n+      {\n+      default:\terrors++;\tbreak;\n+      case 'a': want_aux++;\tbreak;\t/* print aux table */\n+      case 'l': want_line++;\tbreak;\t/* print line numbers */\n+      case 'r': want_rfd++;\tbreak;\t/* print relative fd's */\n+      case 's':\twant_scope++;\tbreak;\t/* print scope info */\n+      }\n+\n+  if (errors || optind != argc - 1)\n+    {\n+      fprintf (stderr, \"Calling Sequence:\\n\");\n+      fprintf (stderr, \"\\t%0 [-alrs] <object-or-T-file>\\n\", argv[0]);\n+      fprintf (stderr, \"\\n\");\n+      fprintf (stderr, \"switches:\\n\");\n+      fprintf (stderr, \"\\t-a Print out auxiliary table.\\n\");\n+      fprintf (stderr, \"\\t-l Print out line numbers.\\n\");\n+      fprintf (stderr, \"\\t-r Print out relative file descriptors.\\n\");\n+      fprintf (stderr, \"\\t-s Print out the current scopes for an item.\\n\");\n+      return 1;\n+    }\n+\n+  /*\n+   * Open and process the input file.\n+   */\n+  tfile_fd = open (argv[optind], O_RDONLY);\n+  if (tfile_fd < 0)\n+    {\n+      perror (argv[optind]);\n+      return 1;\n+    }\n+\n+  read_tfile ();\n+\n+  /*\n+   * Print any global aux words if any.\n+   */\n+  if (want_aux)\n+    {\n+      long last_aux_in_use;\n+\n+      if (sym_hdr.ifdMax != 0 && file_desc[0].iauxBase != 0)\n+\t{\n+\t  printf (\"\\nGlobal auxiliary entries before first file:\\n\");\n+\t  for (i = 0; i < file_desc[0].iauxBase; i++)\n+\t    print_aux (aux_symbols[i], 0, aux_used[i]);\n+\t}\n+\n+      if (sym_hdr.ifdMax == 0)\n+\tlast_aux_in_use = 0;\n+      else\n+\tlast_aux_in_use =\n+\t  file_desc[sym_hdr.ifdMax-1].iauxBase +\n+\t  file_desc[sym_hdr.ifdMax-1].caux - 1;\n+\n+      if (last_aux_in_use < sym_hdr.iauxMax-1)\n+\t{\n+\t  printf (\"\\nGlobal auxiliary entries after last file:\\n\");\n+\t  for (i = last_aux_in_use; i < sym_hdr.iauxMax; i++)\n+\t    print_aux (aux_symbols[i], i - last_aux_in_use, aux_used[i]);\n+\t}\n+    }\n+\n+  /*\n+   * Print the information for each file.\n+   */\n+  for (i = 0; i < sym_hdr.ifdMax; i++)\n+    print_file_desc (&file_desc[i], i);\n+\n+  /* \n+   * Print the external symbols.\n+   */\n+  want_scope = 0;\t\t/* scope info is meaning for extern symbols */\n+  printf (\"\\nThere are %lu external symbols, starting at %lu\\n\",\n+\t  (ulong) sym_hdr.iextMax,\n+\t  (ulong) sym_hdr.cbExtOffset);\n+\n+  for(i = 0; i < sym_hdr.iextMax; i++)\n+    print_symbol (&e_symbols[i].asym, i, e_strings,\n+\t\t  aux_symbols + file_desc[e_symbols[i].ifd].iauxBase,\n+\t\t  e_symbols[i].ifd);\n+\n+  /*\n+   * Print unused aux symbols now.\n+   */\n+\n+  if (want_aux)\n+    {\n+      int first_time = 1;\n+\n+      for (i = 0; i < sym_hdr.iauxMax; i++)\n+\t{\n+\t  if (! aux_used[i])\n+\t    {\n+\t      if (first_time)\n+\t\t{\n+\t\t  printf (\"\\nThe following auxiliary table entries were unused:\\n\\n\");\n+\t\t  first_time = 0;\n+\t\t}\n+\n+\t      printf (\"    #%-5d %11ld  0x%08lx  %s\\n\",\n+\t\t      i,\n+\t\t      (long) aux_symbols[i].isym,\n+\t\t      (long) aux_symbols[i].isym,\n+\t\t      type_to_string (aux_symbols, i));\n+\t    }\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\n+\f\n+void\n+fancy_abort ()\n+{\n+  fprintf (stderr, \"mips-tdump internal error\");\n+  exit (1);\n+}\n+\n+void\n+fatal(s)\n+char *s;\n+{\n+  fprintf(stderr, \"%s\\n\", s);\n+  exit(1);\n+}\n+\n+/* Same as `malloc' but report error if no memory available.  */\n+\n+PTR_T\n+xmalloc (size)\n+     unsigned size;\n+{\n+  register PTR_T value = malloc (size);\n+  if (value == 0)\n+    fatal (\"Virtual memory exhausted.\");\n+  return value;\n+}"}]}