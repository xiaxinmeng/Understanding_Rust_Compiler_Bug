{"sha": "4b25fc15b925f87a20bb15fe5ffcfd33fca6fd32", "node_id": "C_kwDOANBUbNoAKDRiMjVmYzE1YjkyNWY4N2EyMGJiMTVmZTVmZmNmZDMzZmNhNmZkMzI", "commit": {"author": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2023-02-13T17:51:19Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2023-04-06T08:47:23Z"}, "message": "gccrs: Support for Sized builtin marker trait\n\nWhen implementing general bounds checking as part of unify calls, we did\nnot check associated types on bounds which lead to alot of missed error\nchecking. This now recursively checks the bounds and the associated types\nwith a decent error message. This also required us to implement the Sized\nmarker trait to keep existing test-cases happy.\n\nFixes #1725\n\nSigned-off-by: Philip Herron <herron.philip@googlemail.com>\n\ngcc/rust/ChangeLog:\n\n\t* typecheck/rust-hir-trait-reference.cc (TraitReference::clear_associated_types): make const\n\t(TraitReference::clear_associated_type_projections): new interface\n\t* typecheck/rust-hir-trait-reference.h:\n\t* typecheck/rust-hir-trait-resolve.cc (TraitResolver::resolve_trait): refactor\n\t(TraitItemReference::associated_type_reset): reset projections\n\t* typecheck/rust-hir-type-bounds.h:\n\t* typecheck/rust-hir-type-check-expr.cc (TypeCheckExpr::visit): fix bounds\n\t* typecheck/rust-tyty-bounds.cc (TypeBoundsProbe::TypeBoundsProbe): refactor into cc file\n\t(TypeBoundsProbe::Probe): refactor\n\t(TypeBoundsProbe::is_bound_satisfied_for_type): likewise\n\t(TypeBoundsProbe::assemble_sized_builtin): add builtin for Sized\n\t(TypeCheckBase::get_predicate_from_bound): refactor\n\t(TypeBoundPredicate::lookup_associated_type): refactor\n\t* typecheck/rust-tyty-subst.cc (SubstitutionRef::lookup_associated_impl)\n\t(SubstitutionRef::prepare_higher_ranked_bounds): new interface to clear hanging bounds\n\t(SubstitutionRef::monomorphize): refactor\n\t* typecheck/rust-tyty-subst.h:\n\t* typecheck/rust-tyty.cc (BaseType::get_locus): helper\n\t(BaseType::satisfies_bound): ensure bounds are satisfied and assoicated types\n\t(ParamType::ParamType): new field in constructor\n\t(ParamType::clone): update clone\n\t(ParamType::set_implicit_self_trait): new interface\n\t(ParamType::is_implicit_self_trait): likewise\n\t* typecheck/rust-tyty.h: cleanup\n\t* util/rust-hir-map.cc (Mappings::Mappings): builtin marker\n\t(Mappings::~Mappings): delete marker\n\t(Mappings::lookup_builtin_marker): lookup\n\t* util/rust-hir-map.h: update header\n\ngcc/testsuite/ChangeLog:\n\n\t* rust/compile/issue-1725-1.rs: New test.\n\t* rust/compile/issue-1725-2.rs: New test.", "tree": {"sha": "961ae4c51820e34d87f6cb5ea2f1421c8374f5c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/961ae4c51820e34d87f6cb5ea2f1421c8374f5c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b25fc15b925f87a20bb15fe5ffcfd33fca6fd32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b25fc15b925f87a20bb15fe5ffcfd33fca6fd32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b25fc15b925f87a20bb15fe5ffcfd33fca6fd32", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b25fc15b925f87a20bb15fe5ffcfd33fca6fd32/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e90d06c544733165d2e58b86213070f7ebd79f61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e90d06c544733165d2e58b86213070f7ebd79f61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e90d06c544733165d2e58b86213070f7ebd79f61"}], "stats": {"total": 662, "additions": 476, "deletions": 186}, "files": [{"sha": "a1229adc06c5ff361db576be6c92a1d9d4c8d98f", "filename": "gcc/rust/typecheck/rust-hir-trait-reference.cc", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b25fc15b925f87a20bb15fe5ffcfd33fca6fd32/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-reference.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b25fc15b925f87a20bb15fe5ffcfd33fca6fd32/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-reference.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-reference.cc?ref=4b25fc15b925f87a20bb15fe5ffcfd33fca6fd32", "patch": "@@ -343,14 +343,26 @@ TraitReference::on_resolved ()\n }\n \n void\n-TraitReference::clear_associated_types ()\n+TraitReference::clear_associated_types () const\n {\n-  for (auto &item : item_refs)\n+  for (const auto &item : item_refs)\n+    {\n+      bool is_assoc_type = item.get_trait_item_type ()\n+\t\t\t   == TraitItemReference::TraitItemType::TYPE;\n+      if (is_assoc_type)\n+\titem.associated_type_reset (false);\n+    }\n+}\n+\n+void\n+TraitReference::clear_associated_type_projections () const\n+{\n+  for (const auto &item : item_refs)\n     {\n       bool is_assoc_type = item.get_trait_item_type ()\n \t\t\t   == TraitItemReference::TraitItemType::TYPE;\n       if (is_assoc_type)\n-\titem.associated_type_reset ();\n+\titem.associated_type_reset (true);\n     }\n }\n "}, {"sha": "d20b2952e5b2b67ff1b7db127a364a62c0bae91f", "filename": "gcc/rust/typecheck/rust-hir-trait-reference.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b25fc15b925f87a20bb15fe5ffcfd33fca6fd32/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-reference.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b25fc15b925f87a20bb15fe5ffcfd33fca6fd32/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-reference.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-reference.h?ref=4b25fc15b925f87a20bb15fe5ffcfd33fca6fd32", "patch": "@@ -106,7 +106,7 @@ class TraitItemReference\n \n   void associated_type_set (TyTy::BaseType *ty) const;\n \n-  void associated_type_reset () const;\n+  void associated_type_reset (bool only_projections) const;\n \n   bool is_object_safe () const;\n \n@@ -212,7 +212,9 @@ class TraitReference\n \n   void on_resolved ();\n \n-  void clear_associated_types ();\n+  void clear_associated_types () const;\n+\n+  void clear_associated_type_projections () const;\n \n   bool is_equal (const TraitReference &other) const;\n "}, {"sha": "2d7985703cfb5206d4f50d159f09314b4c94a300", "filename": "gcc/rust/typecheck/rust-hir-trait-resolve.cc", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b25fc15b925f87a20bb15fe5ffcfd33fca6fd32/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b25fc15b925f87a20bb15fe5ffcfd33fca6fd32/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc?ref=4b25fc15b925f87a20bb15fe5ffcfd33fca6fd32", "patch": "@@ -161,6 +161,9 @@ TraitResolver::resolve_trait (HIR::Trait *trait_reference)\n   TraitQueryGuard guard (trait_id);\n   TyTy::BaseType *self = nullptr;\n   std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+\n+  // FIXME\n+  // this should use the resolve_generic_params like everywhere else\n   for (auto &generic_param : trait_reference->get_generic_params ())\n     {\n       switch (generic_param.get ()->get_kind ())\n@@ -182,7 +185,11 @@ TraitResolver::resolve_trait (HIR::Trait *trait_reference)\n \n \t    if (typaram.get_type_representation ().compare (\"Self\") == 0)\n \t      {\n-\t\tself = param_type;\n+\t\trust_assert (param_type->get_kind () == TyTy::TypeKind::PARAM);\n+\t\tTyTy::ParamType *p\n+\t\t  = static_cast<TyTy::ParamType *> (param_type);\n+\t\tp->set_implicit_self_trait ();\n+\t\tself = p;\n \t      }\n \t  }\n \t  break;\n@@ -365,7 +372,7 @@ TraitItemReference::associated_type_set (TyTy::BaseType *ty) const\n }\n \n void\n-TraitItemReference::associated_type_reset () const\n+TraitItemReference::associated_type_reset (bool only_projections) const\n {\n   rust_assert (get_trait_item_type () == TraitItemType::TYPE);\n \n@@ -374,7 +381,21 @@ TraitItemReference::associated_type_reset () const\n   TyTy::PlaceholderType *placeholder\n     = static_cast<TyTy::PlaceholderType *> (item_ty);\n \n-  placeholder->clear_associated_type ();\n+  if (!only_projections)\n+    {\n+      placeholder->clear_associated_type ();\n+    }\n+  else\n+    {\n+      if (!placeholder->can_resolve ())\n+\treturn;\n+\n+      const TyTy::BaseType *r = placeholder->resolve ();\n+      if (r->get_kind () == TyTy::TypeKind::PROJECTION)\n+\t{\n+\t  placeholder->clear_associated_type ();\n+\t}\n+    }\n }\n \n TyTy::BaseType *"}, {"sha": "628bba5da20b14ca2f09c5c5299cb410f3e39a3c", "filename": "gcc/rust/typecheck/rust-hir-type-bounds.h", "status": "modified", "additions": 5, "deletions": 29, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b25fc15b925f87a20bb15fe5ffcfd33fca6fd32/gcc%2Frust%2Ftypecheck%2Frust-hir-type-bounds.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b25fc15b925f87a20bb15fe5ffcfd33fca6fd32/gcc%2Frust%2Ftypecheck%2Frust-hir-type-bounds.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-bounds.h?ref=4b25fc15b925f87a20bb15fe5ffcfd33fca6fd32", "patch": "@@ -30,42 +30,18 @@ class TypeBoundsProbe : public TypeCheckBase\n {\n public:\n   static std::vector<std::pair<TraitReference *, HIR::ImplBlock *>>\n-  Probe (const TyTy::BaseType *receiver)\n-  {\n-    TypeBoundsProbe probe (receiver);\n-    probe.scan ();\n-    return probe.trait_references;\n-  }\n+  Probe (const TyTy::BaseType *receiver);\n \n   static bool is_bound_satisfied_for_type (TyTy::BaseType *receiver,\n-\t\t\t\t\t   TraitReference *ref)\n-  {\n-    for (auto &bound : receiver->get_specified_bounds ())\n-      {\n-\tconst TraitReference *b = bound.get ();\n-\tif (b->is_equal (*ref))\n-\t  return true;\n-      }\n-\n-    std::vector<std::pair<TraitReference *, HIR::ImplBlock *>> bounds\n-      = Probe (receiver);\n-    for (auto &bound : bounds)\n-      {\n-\tconst TraitReference *b = bound.first;\n-\tif (b->is_equal (*ref))\n-\t  return true;\n-      }\n-\n-    return false;\n-  }\n+\t\t\t\t\t   TraitReference *ref);\n \n private:\n   void scan ();\n+  void assemble_sized_builtin ();\n+  void assemble_builtin_candidate (Analysis::RustLangItem::ItemType item);\n \n private:\n-  TypeBoundsProbe (const TyTy::BaseType *receiver)\n-    : TypeCheckBase (), receiver (receiver)\n-  {}\n+  TypeBoundsProbe (const TyTy::BaseType *receiver);\n \n   const TyTy::BaseType *receiver;\n   std::vector<std::pair<TraitReference *, HIR::ImplBlock *>> trait_references;"}, {"sha": "d4eea7ae954e708d39dc0a045529cf2d594feb0c", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.cc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b25fc15b925f87a20bb15fe5ffcfd33fca6fd32/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b25fc15b925f87a20bb15fe5ffcfd33fca6fd32/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc?ref=4b25fc15b925f87a20bb15fe5ffcfd33fca6fd32", "patch": "@@ -1095,6 +1095,7 @@ TypeCheckExpr::visit (HIR::MethodCallExpr &expr)\n       return;\n     }\n \n+  fn->prepare_higher_ranked_bounds ();\n   auto root = receiver_tyty->get_root ();\n   if (root->get_kind () == TyTy::TypeKind::ADT)\n     {\n@@ -1659,6 +1660,11 @@ TypeCheckExpr::resolve_operator_overload (\n   TyTy::FnType *fn = static_cast<TyTy::FnType *> (lookup);\n   rust_assert (fn->is_method ());\n \n+  fn->prepare_higher_ranked_bounds ();\n+  rust_debug_loc (expr.get_locus (), \"resolved operator overload to: {%u} {%s}\",\n+\t\t  candidate.candidate.ty->get_ref (),\n+\t\t  candidate.candidate.ty->debug_str ().c_str ());\n+\n   auto root = lhs->get_root ();\n   if (root->get_kind () == TyTy::TypeKind::ADT)\n     {"}, {"sha": "76d2eeff8ef5f9c70dd7b2f1a50bf7a7d526812b", "filename": "gcc/rust/typecheck/rust-tyty-bounds.cc", "status": "modified", "additions": 108, "deletions": 3, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b25fc15b925f87a20bb15fe5ffcfd33fca6fd32/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b25fc15b925f87a20bb15fe5ffcfd33fca6fd32/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc?ref=4b25fc15b925f87a20bb15fe5ffcfd33fca6fd32", "patch": "@@ -23,6 +23,41 @@\n namespace Rust {\n namespace Resolver {\n \n+TypeBoundsProbe::TypeBoundsProbe (const TyTy::BaseType *receiver)\n+  : TypeCheckBase (), receiver (receiver)\n+{}\n+\n+std::vector<std::pair<TraitReference *, HIR::ImplBlock *>>\n+TypeBoundsProbe::Probe (const TyTy::BaseType *receiver)\n+{\n+  TypeBoundsProbe probe (receiver);\n+  probe.scan ();\n+  return probe.trait_references;\n+}\n+\n+bool\n+TypeBoundsProbe::is_bound_satisfied_for_type (TyTy::BaseType *receiver,\n+\t\t\t\t\t      TraitReference *ref)\n+{\n+  for (auto &bound : receiver->get_specified_bounds ())\n+    {\n+      const TraitReference *b = bound.get ();\n+      if (b->is_equal (*ref))\n+\treturn true;\n+    }\n+\n+  std::vector<std::pair<TraitReference *, HIR::ImplBlock *>> bounds\n+    = Probe (receiver);\n+  for (auto &bound : bounds)\n+    {\n+      const TraitReference *b = bound.first;\n+      if (b->is_equal (*ref))\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n void\n TypeBoundsProbe::scan ()\n {\n@@ -57,6 +92,75 @@ TypeBoundsProbe::scan ()\n       if (!trait_ref->is_error ())\n \ttrait_references.push_back ({trait_ref, path.second});\n     }\n+\n+  // marker traits...\n+  assemble_sized_builtin ();\n+}\n+\n+void\n+TypeBoundsProbe::assemble_sized_builtin ()\n+{\n+  const TyTy::BaseType *raw = receiver->destructure ();\n+\n+  // does this thing actually implement sized?\n+  switch (raw->get_kind ())\n+    {\n+    case TyTy::ADT:\n+    case TyTy::STR:\n+    case TyTy::REF:\n+    case TyTy::POINTER:\n+    case TyTy::PARAM:\n+    case TyTy::ARRAY:\n+    case TyTy::SLICE:\n+    case TyTy::FNDEF:\n+    case TyTy::FNPTR:\n+    case TyTy::TUPLE:\n+    case TyTy::BOOL:\n+    case TyTy::CHAR:\n+    case TyTy::INT:\n+    case TyTy::UINT:\n+    case TyTy::FLOAT:\n+    case TyTy::USIZE:\n+    case TyTy::ISIZE:\n+      assemble_builtin_candidate (Analysis::RustLangItem::SIZED);\n+      break;\n+\n+      // not-sure about this.... FIXME\n+    case TyTy::INFER:\n+    case TyTy::NEVER:\n+    case TyTy::PLACEHOLDER:\n+    case TyTy::PROJECTION:\n+    case TyTy::DYNAMIC:\n+    case TyTy::CLOSURE:\n+    case TyTy::ERROR:\n+      break;\n+    }\n+}\n+\n+void\n+TypeBoundsProbe::assemble_builtin_candidate (\n+  Analysis::RustLangItem::ItemType lang_item)\n+{\n+  DefId id;\n+  bool found_lang_item = mappings->lookup_lang_item (lang_item, &id);\n+  if (!found_lang_item)\n+    return;\n+\n+  HIR::Item *item = mappings->lookup_defid (id);\n+  if (item == nullptr)\n+    return;\n+\n+  rust_assert (item->get_item_kind () == HIR::Item::ItemKind::Trait);\n+  HIR::Trait *trait = static_cast<HIR::Trait *> (item);\n+  const TyTy::BaseType *raw = receiver->destructure ();\n+\n+  // assemble the reference\n+  TraitReference *trait_ref = TraitResolver::Resolve (*trait);\n+  trait_references.push_back ({trait_ref, mappings->lookup_builtin_marker ()});\n+\n+  rust_debug (\"Added builtin lang_item: %s for %s\",\n+\t      Analysis::RustLangItem::ToString (lang_item).c_str (),\n+\t      raw->get_name ().c_str ());\n }\n \n TraitReference *\n@@ -101,7 +205,8 @@ TypeCheckBase::get_predicate_from_bound (HIR::TypePath &type_path)\n \t  = static_cast<HIR::TypePathSegmentFunction *> (final_seg.get ());\n \tauto &fn = final_function_seg->get_function_path ();\n \n-\t// we need to make implicit generic args which must be an implicit Tuple\n+\t// we need to make implicit generic args which must be an implicit\n+\t// Tuple\n \tauto crate_num = mappings->get_current_crate ();\n \tHirId implicit_args_id = mappings->get_next_hir_id ();\n \tAnalysis::NodeMapping mapping (crate_num,\n@@ -514,8 +619,8 @@ TypeBoundPredicate::lookup_associated_type (const std::string &search)\n {\n   TypeBoundPredicateItem item = lookup_associated_item (search);\n \n-  // only need to check that it is infact an associated type because other wise\n-  // if it was not found it will just be an error node anyway\n+  // only need to check that it is infact an associated type because other\n+  // wise if it was not found it will just be an error node anyway\n   if (!item.is_error ())\n     {\n       const auto raw = item.get_raw_item ();"}, {"sha": "d2f6cf607d1481ed4270c1ee25deca69fea50228", "filename": "gcc/rust/typecheck/rust-tyty-subst.cc", "status": "modified", "additions": 156, "deletions": 135, "changes": 291, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b25fc15b925f87a20bb15fe5ffcfd33fca6fd32/gcc%2Frust%2Ftypecheck%2Frust-tyty-subst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b25fc15b925f87a20bb15fe5ffcfd33fca6fd32/gcc%2Frust%2Ftypecheck%2Frust-tyty-subst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-subst.cc?ref=4b25fc15b925f87a20bb15fe5ffcfd33fca6fd32", "patch": "@@ -119,11 +119,6 @@ SubstitutionParamMapping::fill_param_ty (\n     {\n       type.inherit_bounds (*param);\n     }\n-  else\n-    {\n-      if (!param->bounds_compatible (type, locus, true))\n-\treturn false;\n-    }\n \n   if (type.get_kind () == TypeKind::PARAM)\n     {\n@@ -133,8 +128,15 @@ SubstitutionParamMapping::fill_param_ty (\n   else\n     {\n       // check the substitution is compatible with bounds\n-      if (!param->bounds_compatible (type, locus, true))\n-\treturn false;\n+      rust_debug_loc (locus,\n+\t\t      \"fill_param_ty bounds_compatible: param %s type %s\",\n+\t\t      param->get_name ().c_str (), type.get_name ().c_str ());\n+\n+      if (!param->is_implicit_self_trait ())\n+\t{\n+\t  if (!param->bounds_compatible (type, locus, true))\n+\t    return false;\n+\t}\n \n       // recursively pass this down to all HRTB's\n       for (auto &bound : param->get_specified_bounds ())\n@@ -870,10 +872,149 @@ SubstitutionRef::solve_missing_mappings_from_this (SubstitutionRef &ref,\n   return SubstitutionArgumentMappings (resolved_mappings, {}, locus);\n }\n \n+Resolver::AssociatedImplTrait *\n+SubstitutionRef::lookup_associated_impl (const SubstitutionParamMapping &subst,\n+\t\t\t\t\t const TypeBoundPredicate &bound,\n+\t\t\t\t\t const TyTy::BaseType *binding,\n+\t\t\t\t\t bool *error_flag) const\n+{\n+  auto context = Resolver::TypeCheckContext::get ();\n+  const Resolver::TraitReference *specified_bound_ref = bound.get ();\n+\n+  // setup any associated type mappings for the specified bonds and this\n+  // type\n+  auto candidates = Resolver::TypeBoundsProbe::Probe (binding);\n+  std::vector<Resolver::AssociatedImplTrait *> associated_impl_traits;\n+  for (auto &probed_bound : candidates)\n+    {\n+      const Resolver::TraitReference *bound_trait_ref = probed_bound.first;\n+      const HIR::ImplBlock *associated_impl = probed_bound.second;\n+\n+      HirId impl_block_id = associated_impl->get_mappings ().get_hirid ();\n+      Resolver::AssociatedImplTrait *associated = nullptr;\n+      bool found_impl_trait\n+\t= context->lookup_associated_trait_impl (impl_block_id, &associated);\n+      if (found_impl_trait)\n+\t{\n+\t  bool found_trait = specified_bound_ref->is_equal (*bound_trait_ref);\n+\t  bool found_self = associated->get_self ()->can_eq (binding, false);\n+\t  if (found_trait && found_self)\n+\t    {\n+\t      associated_impl_traits.push_back (associated);\n+\t    }\n+\t}\n+    }\n+\n+  if (associated_impl_traits.empty ())\n+    return nullptr;\n+\n+  // This code is important when you look at slices for example when\n+  // you have a slice such as:\n+  //\n+  // let slice = &array[1..3]\n+  //\n+  // the higher ranked bounds will end up having an Index trait\n+  // implementation for Range<usize> so we need this code to resolve\n+  // that we have an integer inference variable that needs to become\n+  // a usize\n+  //\n+  // The other complicated issue is that we might have an intrinsic\n+  // which requires the :Clone or Copy bound but the libcore adds\n+  // implementations for all the integral types so when there are\n+  // multiple candidates we need to resolve to the default\n+  // implementation for that type otherwise its an error for\n+  // ambiguous type bounds\n+\n+  // if we have a non-general inference variable we need to be\n+  // careful about the selection here\n+  bool is_infer_var = binding->get_kind () == TyTy::TypeKind::INFER;\n+  bool is_integer_infervar\n+    = is_infer_var\n+      && static_cast<const TyTy::InferType *> (binding)->get_infer_kind ()\n+\t   == TyTy::InferType::InferTypeKind::INTEGRAL;\n+  bool is_float_infervar\n+    = is_infer_var\n+      && static_cast<const TyTy::InferType *> (binding)->get_infer_kind ()\n+\t   == TyTy::InferType::InferTypeKind::FLOAT;\n+\n+  Resolver::AssociatedImplTrait *associate_impl_trait = nullptr;\n+  if (associated_impl_traits.size () == 1)\n+    {\n+      // just go for it\n+      associate_impl_trait = associated_impl_traits.at (0);\n+    }\n+  else if (is_integer_infervar)\n+    {\n+      TyTy::BaseType *type = nullptr;\n+      bool ok = context->lookup_builtin (\"i32\", &type);\n+      rust_assert (ok);\n+\n+      for (auto &impl : associated_impl_traits)\n+\t{\n+\t  bool found = impl->get_self ()->is_equal (*type);\n+\t  if (found)\n+\t    {\n+\t      associate_impl_trait = impl;\n+\t      break;\n+\t    }\n+\t}\n+    }\n+  else if (is_float_infervar)\n+    {\n+      TyTy::BaseType *type = nullptr;\n+      bool ok = context->lookup_builtin (\"f64\", &type);\n+      rust_assert (ok);\n+\n+      for (auto &impl : associated_impl_traits)\n+\t{\n+\t  bool found = impl->get_self ()->is_equal (*type);\n+\t  if (found)\n+\t    {\n+\t      associate_impl_trait = impl;\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  if (associate_impl_trait == nullptr)\n+    {\n+      // go for the first one? or error out?\n+      auto &mappings = *Analysis::Mappings::get ();\n+      const auto &type_param = subst.get_generic_param ();\n+      const auto *trait_ref = bound.get ();\n+\n+      RichLocation r (type_param.get_locus ());\n+      r.add_range (bound.get_locus ());\n+      r.add_range (mappings.lookup_location (binding->get_ref ()));\n+\n+      rust_error_at (r, \"ambiguous type bound for trait %s and type %s\",\n+\t\t     trait_ref->get_name ().c_str (),\n+\t\t     binding->get_name ().c_str ());\n+\n+      *error_flag = true;\n+      return nullptr;\n+    }\n+\n+  return associate_impl_trait;\n+}\n+\n+void\n+SubstitutionRef::prepare_higher_ranked_bounds ()\n+{\n+  for (const auto &subst : get_substs ())\n+    {\n+      const TyTy::ParamType *pty = subst.get_param_ty ();\n+      for (const auto &bound : pty->get_specified_bounds ())\n+\t{\n+\t  const auto ref = bound.get ();\n+\t  ref->clear_associated_type_projections ();\n+\t}\n+    }\n+}\n+\n bool\n SubstitutionRef::monomorphize ()\n {\n-  auto context = Resolver::TypeCheckContext::get ();\n   for (const auto &subst : get_substs ())\n     {\n       const TyTy::ParamType *pty = subst.get_param_ty ();\n@@ -887,136 +1028,16 @@ SubstitutionRef::monomorphize ()\n \n       for (const auto &bound : pty->get_specified_bounds ())\n \t{\n-\t  const Resolver::TraitReference *specified_bound_ref = bound.get ();\n-\n-\t  // setup any associated type mappings for the specified bonds and this\n-\t  // type\n-\t  auto candidates = Resolver::TypeBoundsProbe::Probe (binding);\n-\t  std::vector<Resolver::AssociatedImplTrait *> associated_impl_traits;\n-\t  for (auto &probed_bound : candidates)\n+\t  bool error_flag = false;\n+\t  auto associated\n+\t    = lookup_associated_impl (subst, bound, binding, &error_flag);\n+\t  if (associated != nullptr)\n \t    {\n-\t      const Resolver::TraitReference *bound_trait_ref\n-\t\t= probed_bound.first;\n-\t      const HIR::ImplBlock *associated_impl = probed_bound.second;\n-\n-\t      HirId impl_block_id\n-\t\t= associated_impl->get_mappings ().get_hirid ();\n-\t      Resolver::AssociatedImplTrait *associated = nullptr;\n-\t      bool found_impl_trait\n-\t\t= context->lookup_associated_trait_impl (impl_block_id,\n-\t\t\t\t\t\t\t &associated);\n-\t      if (found_impl_trait)\n-\t\t{\n-\t\t  bool found_trait\n-\t\t    = specified_bound_ref->is_equal (*bound_trait_ref);\n-\t\t  bool found_self\n-\t\t    = associated->get_self ()->can_eq (binding, false);\n-\t\t  if (found_trait && found_self)\n-\t\t    {\n-\t\t      associated_impl_traits.push_back (associated);\n-\t\t    }\n-\t\t}\n+\t      associated->setup_associated_types (binding, bound);\n \t    }\n \n-\t  if (!associated_impl_traits.empty ())\n-\t    {\n-\t      // This code is important when you look at slices for example when\n-\t      // you have a slice such as:\n-\t      //\n-\t      // let slice = &array[1..3]\n-\t      //\n-\t      // the higher ranked bounds will end up having an Index trait\n-\t      // implementation for Range<usize> so we need this code to resolve\n-\t      // that we have an integer inference variable that needs to become\n-\t      // a usize\n-\t      //\n-\t      // The other complicated issue is that we might have an intrinsic\n-\t      // which requires the :Clone or Copy bound but the libcore adds\n-\t      // implementations for all the integral types so when there are\n-\t      // multiple candidates we need to resolve to the default\n-\t      // implementation for that type otherwise its an error for\n-\t      // ambiguous type bounds\n-\n-\t      if (associated_impl_traits.size () == 1)\n-\t\t{\n-\t\t  Resolver::AssociatedImplTrait *associate_impl_trait\n-\t\t    = associated_impl_traits.at (0);\n-\t\t  associate_impl_trait->setup_associated_types (binding, bound);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  // if we have a non-general inference variable we need to be\n-\t\t  // careful about the selection here\n-\t\t  bool is_infer_var\n-\t\t    = binding->get_kind () == TyTy::TypeKind::INFER;\n-\t\t  bool is_integer_infervar\n-\t\t    = is_infer_var\n-\t\t      && static_cast<const TyTy::InferType *> (binding)\n-\t\t\t     ->get_infer_kind ()\n-\t\t\t   == TyTy::InferType::InferTypeKind::INTEGRAL;\n-\t\t  bool is_float_infervar\n-\t\t    = is_infer_var\n-\t\t      && static_cast<const TyTy::InferType *> (binding)\n-\t\t\t     ->get_infer_kind ()\n-\t\t\t   == TyTy::InferType::InferTypeKind::FLOAT;\n-\n-\t\t  Resolver::AssociatedImplTrait *associate_impl_trait = nullptr;\n-\t\t  if (is_integer_infervar)\n-\t\t    {\n-\t\t      TyTy::BaseType *type = nullptr;\n-\t\t      bool ok = context->lookup_builtin (\"i32\", &type);\n-\t\t      rust_assert (ok);\n-\n-\t\t      for (auto &impl : associated_impl_traits)\n-\t\t\t{\n-\t\t\t  bool found = impl->get_self ()->is_equal (*type);\n-\t\t\t  if (found)\n-\t\t\t    {\n-\t\t\t      associate_impl_trait = impl;\n-\t\t\t      break;\n-\t\t\t    }\n-\t\t\t}\n-\t\t    }\n-\t\t  else if (is_float_infervar)\n-\t\t    {\n-\t\t      TyTy::BaseType *type = nullptr;\n-\t\t      bool ok = context->lookup_builtin (\"f64\", &type);\n-\t\t      rust_assert (ok);\n-\n-\t\t      for (auto &impl : associated_impl_traits)\n-\t\t\t{\n-\t\t\t  bool found = impl->get_self ()->is_equal (*type);\n-\t\t\t  if (found)\n-\t\t\t    {\n-\t\t\t      associate_impl_trait = impl;\n-\t\t\t      break;\n-\t\t\t    }\n-\t\t\t}\n-\t\t    }\n-\n-\t\t  if (associate_impl_trait == nullptr)\n-\t\t    {\n-\t\t      // go for the first one? or error out?\n-\t\t      auto &mappings = *Analysis::Mappings::get ();\n-\t\t      const auto &type_param = subst.get_generic_param ();\n-\t\t      const auto *trait_ref = bound.get ();\n-\n-\t\t      RichLocation r (type_param.get_locus ());\n-\t\t      r.add_range (bound.get_locus ());\n-\t\t      r.add_range (\n-\t\t\tmappings.lookup_location (binding->get_ref ()));\n-\n-\t\t      rust_error_at (\n-\t\t\tr, \"ambiguous type bound for trait %s and type %s\",\n-\t\t\ttrait_ref->get_name ().c_str (),\n-\t\t\tbinding->get_name ().c_str ());\n-\n-\t\t      return false;\n-\t\t    }\n-\n-\t\t  associate_impl_trait->setup_associated_types (binding, bound);\n-\t\t}\n-\t    }\n+\t  if (error_flag)\n+\t    return false;\n \t}\n     }\n "}, {"sha": "365fdb6c042ea22c2bc7dca17b3cdcd1c46425e4", "filename": "gcc/rust/typecheck/rust-tyty-subst.h", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b25fc15b925f87a20bb15fe5ffcfd33fca6fd32/gcc%2Frust%2Ftypecheck%2Frust-tyty-subst.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b25fc15b925f87a20bb15fe5ffcfd33fca6fd32/gcc%2Frust%2Ftypecheck%2Frust-tyty-subst.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-subst.h?ref=4b25fc15b925f87a20bb15fe5ffcfd33fca6fd32", "patch": "@@ -298,7 +298,13 @@ class SubstitutionRef\n   // TODO comment\n   BaseType *infer_substitions (Location locus);\n \n-  // TODO comment\n+  // this clears any possible projections from higher ranked trait bounds which\n+  // could be hanging around from a previous resolution\n+  void prepare_higher_ranked_bounds ();\n+\n+  // FIXME\n+  // this is bad name for this, i think it should be something like\n+  // compute-higher-ranked-bounds\n   bool monomorphize ();\n \n   // TODO comment\n@@ -308,6 +314,10 @@ class SubstitutionRef\n   SubstitutionArgumentMappings get_used_arguments () const;\n \n protected:\n+  Resolver::AssociatedImplTrait *lookup_associated_impl (\n+    const SubstitutionParamMapping &subst, const TypeBoundPredicate &bound,\n+    const TyTy::BaseType *binding, bool *error_flag) const;\n+\n   std::vector<SubstitutionParamMapping> substitutions;\n   SubstitutionArgumentMappings used_arguments;\n };"}, {"sha": "d0d36ac0a11d4847681955ad4f5171002ce72c1b", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 76, "deletions": 6, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b25fc15b925f87a20bb15fe5ffcfd33fca6fd32/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b25fc15b925f87a20bb15fe5ffcfd33fca6fd32/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=4b25fc15b925f87a20bb15fe5ffcfd33fca6fd32", "patch": "@@ -31,6 +31,7 @@\n #include \"rust-hir-type-bounds.h\"\n #include \"rust-hir-trait-resolve.h\"\n #include \"rust-tyty-cmp.h\"\n+#include \"rust-type-util.h\"\n \n #include \"options.h\"\n \n@@ -266,6 +267,7 @@ BaseType::get_locus () const\n   return ident.locus;\n }\n \n+// FIXME this is missing locus\n bool\n BaseType::satisfies_bound (const TypeBoundPredicate &predicate) const\n {\n@@ -277,12 +279,67 @@ BaseType::satisfies_bound (const TypeBoundPredicate &predicate) const\n \treturn true;\n     }\n \n+  bool satisfied = false;\n   auto probed = Resolver::TypeBoundsProbe::Probe (this);\n   for (const auto &b : probed)\n     {\n       const Resolver::TraitReference *bound = b.first;\n       if (bound->satisfies_bound (*query))\n+\t{\n+\t  satisfied = true;\n+\t  break;\n+\t}\n+    }\n+\n+  if (!satisfied)\n+    return false;\n+\n+  for (const auto &b : probed)\n+    {\n+      const Resolver::TraitReference *bound = b.first;\n+      if (!bound->is_equal (*query))\n+\tcontinue;\n+\n+      // builtin ones have no impl-block this needs fixed and use a builtin node\n+      // of somekind\n+      if (b.second == nullptr)\n \treturn true;\n+\n+      // need to check that associated types can match as well\n+      const HIR::ImplBlock &impl = *(b.second);\n+      for (const auto &item : impl.get_impl_items ())\n+\t{\n+\t  TyTy::BaseType *impl_item_ty = nullptr;\n+\t  Analysis::NodeMapping i = item->get_impl_mappings ();\n+\t  bool query_ok = Resolver::query_type (i.get_hirid (), &impl_item_ty);\n+\t  if (!query_ok)\n+\t    return false;\n+\n+\t  std::string item_name = item->get_impl_item_name ();\n+\t  TypeBoundPredicateItem lookup\n+\t    = predicate.lookup_associated_item (item_name);\n+\t  if (lookup.is_error ())\n+\t    return false;\n+\n+\t  const auto *item_ref = lookup.get_raw_item ();\n+\t  TyTy::BaseType *bound_ty = item_ref->get_tyty ();\n+\n+\t  // compare the types\n+\t  if (!bound_ty->can_eq (impl_item_ty, false))\n+\t    {\n+\t      RichLocation r (mappings->lookup_location (get_ref ()));\n+\t      r.add_range (predicate.get_locus ());\n+\t      r.add_range (mappings->lookup_location (i.get_hirid ()));\n+\n+\t      rust_error_at (\n+\t\tr, \"expected %<%s%> got %<%s%>\",\n+\t\tbound_ty->destructure ()->get_name ().c_str (),\n+\t\timpl_item_ty->destructure ()->get_name ().c_str ());\n+\t      return false;\n+\t    }\n+\t}\n+\n+      return true;\n     }\n \n   return false;\n@@ -2827,18 +2884,18 @@ ParamType::ParamType (std::string symbol, Location locus, HirId ref,\n \t      {Resolver::CanonicalPath::new_seg (UNKNOWN_NODEID, symbol),\n \t       locus},\n \t      specified_bounds, refs),\n-    symbol (symbol), param (param)\n+    is_trait_self (false), symbol (symbol), param (param)\n {}\n \n-ParamType::ParamType (std::string symbol, Location locus, HirId ref,\n-\t\t      HirId ty_ref, HIR::GenericParam &param,\n+ParamType::ParamType (bool is_trait_self, std::string symbol, Location locus,\n+\t\t      HirId ref, HirId ty_ref, HIR::GenericParam &param,\n \t\t      std::vector<TypeBoundPredicate> specified_bounds,\n \t\t      std::set<HirId> refs)\n   : BaseType (ref, ty_ref, TypeKind::PARAM,\n \t      {Resolver::CanonicalPath::new_seg (UNKNOWN_NODEID, symbol),\n \t       locus},\n \t      specified_bounds, refs),\n-    symbol (symbol), param (param)\n+    is_trait_self (is_trait_self), symbol (symbol), param (param)\n {}\n \n HIR::GenericParam &\n@@ -2906,8 +2963,9 @@ ParamType::can_eq (const BaseType *other, bool emit_errors) const\n BaseType *\n ParamType::clone () const\n {\n-  return new ParamType (get_symbol (), ident.locus, get_ref (), get_ty_ref (),\n-\t\t\tparam, get_specified_bounds (), get_combined_refs ());\n+  return new ParamType (is_trait_self, get_symbol (), ident.locus, get_ref (),\n+\t\t\tget_ty_ref (), param, get_specified_bounds (),\n+\t\t\tget_combined_refs ());\n }\n \n BaseType *\n@@ -2997,6 +3055,18 @@ ParamType::handle_substitions (SubstitutionArgumentMappings &subst_mappings)\n   return p;\n }\n \n+void\n+ParamType::set_implicit_self_trait ()\n+{\n+  is_trait_self = true;\n+}\n+\n+bool\n+ParamType::is_implicit_self_trait () const\n+{\n+  return is_trait_self;\n+}\n+\n // StrType\n \n StrType::StrType (HirId ref, std::set<HirId> refs)"}, {"sha": "64b9379a1c07b95392ee708a5f2f1f8d26e4840b", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b25fc15b925f87a20bb15fe5ffcfd33fca6fd32/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b25fc15b925f87a20bb15fe5ffcfd33fca6fd32/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=4b25fc15b925f87a20bb15fe5ffcfd33fca6fd32", "patch": "@@ -267,8 +267,8 @@ class ParamType : public BaseType\n \t     std::vector<TypeBoundPredicate> specified_bounds,\n \t     std::set<HirId> refs = std::set<HirId> ());\n \n-  ParamType (std::string symbol, Location locus, HirId ref, HirId ty_ref,\n-\t     HIR::GenericParam &param,\n+  ParamType (bool is_trait_self, std::string symbol, Location locus, HirId ref,\n+\t     HirId ty_ref, HIR::GenericParam &param,\n \t     std::vector<TypeBoundPredicate> specified_bounds,\n \t     std::set<HirId> refs = std::set<HirId> ());\n \n@@ -298,7 +298,11 @@ class ParamType : public BaseType\n \n   ParamType *handle_substitions (SubstitutionArgumentMappings &mappings);\n \n+  void set_implicit_self_trait ();\n+  bool is_implicit_self_trait () const;\n+\n private:\n+  bool is_trait_self;\n   std::string symbol;\n   HIR::GenericParam &param;\n };"}, {"sha": "a968704014432d1d0f30d12b1235a3b6abcc44af", "filename": "gcc/rust/util/rust-hir-map.cc", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b25fc15b925f87a20bb15fe5ffcfd33fca6fd32/gcc%2Frust%2Futil%2Frust-hir-map.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b25fc15b925f87a20bb15fe5ffcfd33fca6fd32/gcc%2Frust%2Futil%2Frust-hir-map.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.cc?ref=4b25fc15b925f87a20bb15fe5ffcfd33fca6fd32", "patch": "@@ -96,9 +96,16 @@ static const HirId kDefaultCrateNumBegin = 0;\n Mappings::Mappings ()\n   : crateNumItr (kDefaultCrateNumBegin), currentCrateNum (UNKNOWN_CREATENUM),\n     hirIdIter (kDefaultHirIdBegin), nodeIdIter (kDefaultNodeIdBegin)\n-{}\n+{\n+  Analysis::NodeMapping node (0, 0, 0, 0);\n+  builtinMarker\n+    = new HIR::ImplBlock (node, {}, {}, nullptr, nullptr, HIR::WhereClause ({}),\n+\t\t\t  Positive,\n+\t\t\t  HIR::Visibility (HIR::Visibility::VisType::PUBLIC),\n+\t\t\t  {}, {}, Location ());\n+}\n \n-Mappings::~Mappings () {}\n+Mappings::~Mappings () { delete builtinMarker; }\n \n Mappings *\n Mappings::get ()\n@@ -1035,5 +1042,11 @@ Mappings::lookup_ast_item (NodeId id, AST::Item **result)\n   return true;\n }\n \n+HIR::ImplBlock *\n+Mappings::lookup_builtin_marker ()\n+{\n+  return builtinMarker;\n+}\n+\n } // namespace Analysis\n } // namespace Rust"}, {"sha": "9d6affa27e03309cb6143b651170fb56238ad9ff", "filename": "gcc/rust/util/rust-hir-map.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b25fc15b925f87a20bb15fe5ffcfd33fca6fd32/gcc%2Frust%2Futil%2Frust-hir-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b25fc15b925f87a20bb15fe5ffcfd33fca6fd32/gcc%2Frust%2Futil%2Frust-hir-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.h?ref=4b25fc15b925f87a20bb15fe5ffcfd33fca6fd32", "patch": "@@ -296,6 +296,8 @@ class Mappings\n   void insert_ast_item (AST::Item *item);\n   bool lookup_ast_item (NodeId id, AST::Item **result);\n \n+  HIR::ImplBlock *lookup_builtin_marker ();\n+\n private:\n   Mappings ();\n \n@@ -304,6 +306,7 @@ class Mappings\n   HirId hirIdIter;\n   NodeId nodeIdIter;\n   std::map<CrateNum, LocalDefId> localIdIter;\n+  HIR::ImplBlock *builtinMarker;\n \n   std::map<NodeId, CrateNum> crate_node_to_crate_num;\n   std::map<CrateNum, AST::Crate *> ast_crate_mappings;"}, {"sha": "1ace9fbbf3058f134dd2ba1920e4cb457f53f6d2", "filename": "gcc/testsuite/rust/compile/issue-1725-1.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b25fc15b925f87a20bb15fe5ffcfd33fca6fd32/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-1725-1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b25fc15b925f87a20bb15fe5ffcfd33fca6fd32/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-1725-1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-1725-1.rs?ref=4b25fc15b925f87a20bb15fe5ffcfd33fca6fd32", "patch": "@@ -0,0 +1,19 @@\n+mod core {\n+    mod ops {\n+        #[lang = \"add\"]\n+        pub trait Add<Rhs = Self> {\n+            type Output;\n+\n+            fn add(self, rhs: Rhs) -> Self::Output;\n+        }\n+    }\n+}\n+\n+pub fn foo<T: core::ops::Add<Output = i32>>(a: T) -> i32 {\n+    a + a\n+}\n+\n+pub fn main() {\n+    foo(123f32);\n+    // { dg-error \"bounds not satisfied for f32 .Add. is not satisfied\" \"\" { target *-*-* } .-1 }\n+}"}, {"sha": "8bfd0bbd92464cfd768c6e11dd33b501ecaa7f8d", "filename": "gcc/testsuite/rust/compile/issue-1725-2.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b25fc15b925f87a20bb15fe5ffcfd33fca6fd32/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-1725-2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b25fc15b925f87a20bb15fe5ffcfd33fca6fd32/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-1725-2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-1725-2.rs?ref=4b25fc15b925f87a20bb15fe5ffcfd33fca6fd32", "patch": "@@ -0,0 +1,28 @@\n+mod core {\n+    mod ops {\n+        #[lang = \"add\"]\n+        pub trait Add<Rhs = Self> {\n+            type Output;\n+\n+            fn add(self, rhs: Rhs) -> Self::Output;\n+        }\n+    }\n+}\n+\n+impl core::ops::Add for f32 {\n+    type Output = f32;\n+\n+    fn add(self, rhs: Self) -> Self::Output {\n+        self + rhs\n+    }\n+}\n+\n+pub fn foo<T: core::ops::Add<Output = i32>>(a: T) -> i32 {\n+    a + a\n+}\n+\n+pub fn main() {\n+    foo(123f32);\n+    // { dg-error \"expected .i32. got .f32.\" \"\" { target *-*-* } .-1 }\n+    // { dg-error \"bounds not satisfied for f32 .Add. is not satisfied\" \"\" { target *-*-* } .-2 }\n+}"}]}