{"sha": "f40f731b98bd4035eee5c9ceccaf9a324a280a9a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjQwZjczMWI5OGJkNDAzNWVlZTVjOWNlY2NhZjlhMzI0YTI4MGE5YQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-25T10:35:29Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-25T10:35:29Z"}, "message": "[multiple changes]\n\n2013-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* einfo.adb (Set_Abstract_States): The attribute now applies\n\tto generic packages.\n\t* sem_ch4.adb (Referenced): Moved to sem_util.\n\t* sem_ch7.adb (Unit_Requires_Body): A [generic] package with\n\ta non-null abstract state needs a body.\n\t* sem_prag.adb (Analyze_Depends_In_Decl_Part): Update the calls\n\tto Collect_Subprogram_Inputs_Outputs.\n\t(Analyze_Global_Item): Verify the proper usage of an item with mode\n\tIn_Out or Output relative to the enclosing context.\n\t(Analyze_Pragma): Abstract_State can now be applied to a generic\n\tpackage. Do not reset the Analyzed flag for pragmas Depends and Global\n\tas this is not needed.\n\t(Appears_In): Moved to library level.\n\t(Check_Mode_Restiction_In_Enclosing_Context): New routine.\n\t(Collect_Subprogram_Inputs_Outputs): Moved to library level. Add\n\tformal parameters Subp_Id, Subp_Inputs, Subp_Outputs and Global\n\tseen along with comments on usage.\n\t* sem_util.ads, sem_util.adb (Referenced): New routine.\n\n2013-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_ch6.adb (Expand_Contract_Cases): Generate\n\tdetailed error messages only when switch -gnateE is in effect.\n\n2013-04-25  Yannick Moy  <moy@adacore.com>\n\n\t* sem_attr.adb (Analyze_Attribute): Do not issue\n\tan error for a possibly misplaced 'Result or 'Old attribute when\n\tanalyzing the aspect.\n\nFrom-SVN: r198290", "tree": {"sha": "9c73dbaaa532510ffc0755b8caec4ded56bc313c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c73dbaaa532510ffc0755b8caec4ded56bc313c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f40f731b98bd4035eee5c9ceccaf9a324a280a9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f40f731b98bd4035eee5c9ceccaf9a324a280a9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f40f731b98bd4035eee5c9ceccaf9a324a280a9a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f40f731b98bd4035eee5c9ceccaf9a324a280a9a/comments", "author": null, "committer": null, "parents": [{"sha": "d1ec4768ad4fb2fd97d2651b2cfceb55bf37d83f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1ec4768ad4fb2fd97d2651b2cfceb55bf37d83f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1ec4768ad4fb2fd97d2651b2cfceb55bf37d83f"}], "stats": {"total": 641, "additions": 385, "deletions": 256}, "files": [{"sha": "669f06469a9b93b811877a23e64947268840e783", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40f731b98bd4035eee5c9ceccaf9a324a280a9a/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40f731b98bd4035eee5c9ceccaf9a324a280a9a/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f40f731b98bd4035eee5c9ceccaf9a324a280a9a", "patch": "@@ -1,3 +1,35 @@\n+2013-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* einfo.adb (Set_Abstract_States): The attribute now applies\n+\tto generic packages.\n+\t* sem_ch4.adb (Referenced): Moved to sem_util.\n+\t* sem_ch7.adb (Unit_Requires_Body): A [generic] package with\n+\ta non-null abstract state needs a body.\n+\t* sem_prag.adb (Analyze_Depends_In_Decl_Part): Update the calls\n+\tto Collect_Subprogram_Inputs_Outputs.\n+\t(Analyze_Global_Item): Verify the proper usage of an item with mode\n+\tIn_Out or Output relative to the enclosing context.\n+\t(Analyze_Pragma): Abstract_State can now be applied to a generic\n+\tpackage. Do not reset the Analyzed flag for pragmas Depends and Global\n+\tas this is not needed.\n+\t(Appears_In): Moved to library level.\n+\t(Check_Mode_Restiction_In_Enclosing_Context): New routine.\n+\t(Collect_Subprogram_Inputs_Outputs): Moved to library level. Add\n+\tformal parameters Subp_Id, Subp_Inputs, Subp_Outputs and Global\n+\tseen along with comments on usage.\n+\t* sem_util.ads, sem_util.adb (Referenced): New routine.\n+\n+2013-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_ch6.adb (Expand_Contract_Cases): Generate\n+\tdetailed error messages only when switch -gnateE is in effect.\n+\n+2013-04-25  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_attr.adb (Analyze_Attribute): Do not issue\n+\tan error for a possibly misplaced 'Result or 'Old attribute when\n+\tanalyzing the aspect.\n+\n 2013-04-25  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_ch12.adb, sem_util.adb, sem_ch4.adb: Minor reformatting."}, {"sha": "bfe5b37dad1042998e18929414e6288bd61f73fa", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40f731b98bd4035eee5c9ceccaf9a324a280a9a/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40f731b98bd4035eee5c9ceccaf9a324a280a9a/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=f40f731b98bd4035eee5c9ceccaf9a324a280a9a", "patch": "@@ -3233,7 +3233,7 @@ package body Einfo is\n \n    procedure Set_Abstract_States (Id : E; V : L) is\n    begin\n-      pragma Assert (Ekind (Id) = E_Package);\n+      pragma Assert (Ekind_In (Id, E_Generic_Package, E_Package));\n       Set_Elist25 (Id, V);\n    end Set_Abstract_States;\n "}, {"sha": "f52abe987028cfdeec86bb566139dfcfb512e1e8", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 31, "deletions": 13, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40f731b98bd4035eee5c9ceccaf9a324a280a9a/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40f731b98bd4035eee5c9ceccaf9a324a280a9a/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=f40f731b98bd4035eee5c9ceccaf9a324a280a9a", "patch": "@@ -4222,15 +4222,24 @@ package body Sem_Attr is\n             --  Check in postcondition, Test_Case or Contract_Cases\n \n             Prag := N;\n-            while not Nkind_In (Prag, N_Pragma,\n-                                      N_Function_Specification,\n-                                      N_Procedure_Specification,\n-                                      N_Subprogram_Body)\n+            while Present (Prag)\n+               and then not Nkind_In (Prag, N_Pragma,\n+                                            N_Function_Specification,\n+                                            N_Procedure_Specification,\n+                                            N_Aspect_Specification,\n+                                            N_Subprogram_Body)\n             loop\n                Prag := Parent (Prag);\n             end loop;\n \n-            if Nkind (Prag) /= N_Pragma then\n+            --  In ASIS mode, the aspect itself is analyzed, in addition to the\n+            --  corresponding pragma. Do not issue errors when analyzing the\n+            --  aspect.\n+\n+            if Nkind (Prag) = N_Aspect_Specification then\n+               null;\n+\n+            elsif Nkind (Prag) /= N_Pragma then\n                Error_Attr (\"% attribute can only appear in postcondition\", P);\n \n             elsif Get_Pragma_Id (Prag) = Pragma_Test_Case then\n@@ -4241,7 +4250,7 @@ package body Sem_Attr is\n \n                begin\n                   Arg := N;\n-                  while Arg /= Prag and Arg /= Arg_Ens loop\n+                  while Arg /= Prag and then Arg /= Arg_Ens loop\n                      Arg := Parent (Arg);\n                   end loop;\n \n@@ -4258,7 +4267,7 @@ package body Sem_Attr is\n \n                begin\n                   Arg := N;\n-                  while Arg /= Prag and Parent (Parent (Arg)) /= Aggr loop\n+                  while Arg /= Prag and then Parent (Parent (Arg)) /= Aggr loop\n                      Arg := Parent (Arg);\n                   end loop;\n \n@@ -4628,14 +4637,23 @@ package body Sem_Attr is\n             --  Check in postcondition, Test_Case or Contract_Cases of function\n \n             Prag := N;\n-            while not Nkind_In (Prag, N_Pragma,\n-                                      N_Function_Specification,\n-                                      N_Subprogram_Body)\n+            while Present (Prag)\n+               and then not Nkind_In (Prag, N_Pragma,\n+                                            N_Function_Specification,\n+                                            N_Aspect_Specification,\n+                                            N_Subprogram_Body)\n             loop\n                Prag := Parent (Prag);\n             end loop;\n \n-            if Nkind (Prag) /= N_Pragma then\n+            --  In ASIS mode, the aspect itself is analyzed, in addition to the\n+            --  corresponding pragma. Do not issue errors when analyzing the\n+            --  aspect.\n+\n+            if Nkind (Prag) = N_Aspect_Specification then\n+               null;\n+\n+            elsif Nkind (Prag) /= N_Pragma then\n                Error_Attr\n                  (\"% attribute can only appear in postcondition of function\",\n                   P);\n@@ -4648,7 +4666,7 @@ package body Sem_Attr is\n \n                begin\n                   Arg := N;\n-                  while Arg /= Prag and Arg /= Arg_Ens loop\n+                  while Arg /= Prag and then Arg /= Arg_Ens loop\n                      Arg := Parent (Arg);\n                   end loop;\n \n@@ -4665,7 +4683,7 @@ package body Sem_Attr is\n \n                begin\n                   Arg := N;\n-                  while Arg /= Prag and Parent (Parent (Arg)) /= Aggr loop\n+                  while Arg /= Prag and then Parent (Parent (Arg)) /= Aggr loop\n                      Arg := Parent (Arg);\n                   end loop;\n "}, {"sha": "04db9b0d39192608c1c67501d4c9ce34c25698c5", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40f731b98bd4035eee5c9ceccaf9a324a280a9a/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40f731b98bd4035eee5c9ceccaf9a324a280a9a/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=f40f731b98bd4035eee5c9ceccaf9a324a280a9a", "patch": "@@ -3510,10 +3510,6 @@ package body Sem_Ch4 is\n       --  Determine whether if expression If_Expr lacks an else part or if it\n       --  has one, it evaluates to True.\n \n-      function Referenced (Id : Entity_Id; Expr : Node_Id) return Boolean;\n-      --  Determine whether entity Id is referenced within expression Expr\n-      --  This should be moved to sem_util ???\n-\n       --------------------\n       -- Is_Empty_Range --\n       --------------------\n@@ -3565,43 +3561,6 @@ package body Sem_Ch4 is\n                        and then Is_True (Expr_Value (Else_Expr)));\n       end No_Else_Or_Trivial_True;\n \n-      ----------------\n-      -- Referenced --\n-      ----------------\n-\n-      function Referenced (Id : Entity_Id; Expr : Node_Id) return Boolean is\n-         Seen : Boolean := False;\n-\n-         function Is_Reference (N : Node_Id) return Traverse_Result;\n-         --  Determine whether node N denotes a reference to Id. If this is the\n-         --  case, set global flag Seen to True and stop the traversal.\n-\n-         ------------------\n-         -- Is_Reference --\n-         ------------------\n-\n-         function Is_Reference (N : Node_Id) return Traverse_Result is\n-         begin\n-            if Is_Entity_Name (N)\n-              and then Present (Entity (N))\n-              and then Entity (N) = Id\n-            then\n-               Seen := True;\n-               return Abandon;\n-            else\n-               return OK;\n-            end if;\n-         end Is_Reference;\n-\n-         procedure Inspect_Expression is new Traverse_Proc (Is_Reference);\n-\n-      --  Start of processing for Referenced\n-\n-      begin\n-         Inspect_Expression (Expr);\n-         return Seen;\n-      end Referenced;\n-\n       --  Local variables\n \n       Cond    : constant Node_Id := Condition (N);"}, {"sha": "1a97de24b3f3f4a412ea2d822834cd4ff0227ae5", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40f731b98bd4035eee5c9ceccaf9a324a280a9a/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40f731b98bd4035eee5c9ceccaf9a324a280a9a/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=f40f731b98bd4035eee5c9ceccaf9a324a280a9a", "patch": "@@ -11655,7 +11655,7 @@ package body Sem_Ch6 is\n \n                --  Check possible overlap between a case guard and \"others\"\n \n-               if Multiple_PCs then\n+               if Multiple_PCs and then Exception_Extra_Info then\n                   Case_Guard_Error\n                     (Decls     => Error_Decls,\n                      Flag      => Others_Flag,\n@@ -11695,7 +11695,7 @@ package body Sem_Ch6 is\n                --  Check whether this case guard overlaps with another case\n                --  guard.\n \n-               if Multiple_PCs then\n+               if Multiple_PCs and then Exception_Extra_Info then\n                   Case_Guard_Error\n                     (Decls     => Error_Decls,\n                      Flag      => Flag,"}, {"sha": "505fe9d9916d7cb84f834c82715a7bf63d87e8e0", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40f731b98bd4035eee5c9ceccaf9a324a280a9a/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40f731b98bd4035eee5c9ceccaf9a324a280a9a/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=f40f731b98bd4035eee5c9ceccaf9a324a280a9a", "patch": "@@ -2615,6 +2615,16 @@ package body Sem_Ch7 is\n                return True;\n             end if;\n          end;\n+\n+      --  A [generic] package that introduces at least one non-null abstract\n+      --  state requires completion. A null abstract state always appears as\n+      --  the sole element of the state list.\n+\n+      elsif Ekind_In (P, E_Generic_Package, E_Package)\n+        and then Present (Abstract_States (P))\n+        and then not Is_Null_State (Node (First_Elmt (Abstract_States (P))))\n+      then\n+         return True;\n       end if;\n \n       --  Otherwise search entity chain for entity requiring completion"}, {"sha": "0874528bf5d7d859b9d3f689e318240ec03204d1", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 272, "deletions": 199, "changes": 471, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40f731b98bd4035eee5c9ceccaf9a324a280a9a/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40f731b98bd4035eee5c9ceccaf9a324a280a9a/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=f40f731b98bd4035eee5c9ceccaf9a324a280a9a", "patch": "@@ -181,6 +181,22 @@ package body Sem_Prag is\n    --  to Uppercase or Lowercase, then a new string literal with appropriate\n    --  casing is constructed.\n \n+   function Appears_In (List : Elist_Id; Item_Id : Entity_Id) return Boolean;\n+   --  Subsidiary to the analysis of pragma Global and pragma Depends. Query\n+   --  whether a particular item appears in a mixed list of nodes and entities.\n+   --  It is assumed that all nodes in the list have entities.\n+\n+   procedure Collect_Subprogram_Inputs_Outputs\n+     (Subp_Id      : Entity_Id;\n+      Subp_Inputs  : in out Elist_Id;\n+      Subp_Outputs : in out Elist_Id;\n+      Global_Seen  : out Boolean);\n+   --  Subsidiary to the analysis of pragma Global and pragma Depends. Gather\n+   --  all inputs and outputs of subprogram Subp_Id in lists Subp_Inputs and\n+   --  Subp_Outputs. If the case where the subprogram has no inputs and/or\n+   --  outputs, the corresponding returned list is No_Elist. Flag Global_Seen\n+   --  is set when the related subprogram has aspect/pragma Global.\n+\n    function Find_Related_Subprogram\n      (Prag             : Node_Id;\n       Check_Duplicates : Boolean := False) return Node_Id;\n@@ -448,12 +464,6 @@ package body Sem_Prag is\n       --  Verify the legality of a single dependency clause. Flag Is_Last\n       --  denotes whether Clause is the last clause in the relation.\n \n-      function Appears_In\n-        (List    : Elist_Id;\n-         Item_Id : Entity_Id) return Boolean;\n-      --  Determine whether a particular item appears in a mixed list of nodes\n-      --  and entities.\n-\n       procedure Check_Function_Return;\n       --  Verify that Funtion'Result appears as one of the outputs\n \n@@ -476,10 +486,6 @@ package body Sem_Prag is\n       --  Verify that all items from Subp_Items appear in Used_Items. Emit an\n       --  error if this is not the case.\n \n-      procedure Collect_Subprogram_Inputs_Outputs;\n-      --  Gather all inputs and outputs of the subprogram. These are the formal\n-      --  parameters and entities classified in pragma Global.\n-\n       procedure Normalize_Clause (Clause : Node_Id);\n       --  Remove a self-dependency \"+\" from the input list of a clause.\n       --  Depending on the contents of the relation, either split the the\n@@ -787,38 +793,6 @@ package body Sem_Prag is\n          Analyze_Input_List (Inputs);\n       end Analyze_Dependency_Clause;\n \n-      ----------------\n-      -- Appears_In --\n-      ----------------\n-\n-      function Appears_In\n-        (List    : Elist_Id;\n-         Item_Id : Entity_Id) return Boolean\n-      is\n-         Elmt : Elmt_Id;\n-         Id   : Entity_Id;\n-\n-      begin\n-         if Present (List) then\n-            Elmt := First_Elmt (List);\n-            while Present (Elmt) loop\n-               if Nkind (Node (Elmt)) = N_Defining_Identifier then\n-                  Id := Node (Elmt);\n-               else\n-                  Id := Entity (Node (Elmt));\n-               end if;\n-\n-               if Id = Item_Id then\n-                  return True;\n-               end if;\n-\n-               Next_Elmt (Elmt);\n-            end loop;\n-         end if;\n-\n-         return False;\n-      end Appears_In;\n-\n       ----------------------------\n       --  Check_Function_Return --\n       ----------------------------\n@@ -961,138 +935,6 @@ package body Sem_Prag is\n          end loop;\n       end Check_Usage;\n \n-      ---------------------------------------\n-      -- Collect_Subprogram_Inputs_Outputs --\n-      ---------------------------------------\n-\n-      procedure Collect_Subprogram_Inputs_Outputs is\n-         procedure Collect_Global_List\n-           (List : Node_Id;\n-            Mode : Name_Id := Name_Input);\n-         --  Collect all relevant items from a global list\n-\n-         -------------------------\n-         -- Collect_Global_List --\n-         -------------------------\n-\n-         procedure Collect_Global_List\n-           (List : Node_Id;\n-            Mode : Name_Id := Name_Input)\n-         is\n-            procedure Collect_Global_Item\n-              (Item : Node_Id;\n-               Mode : Name_Id);\n-            --  Add an item to the proper subprogram input or output collection\n-\n-            -------------------------\n-            -- Collect_Global_Item --\n-            -------------------------\n-\n-            procedure Collect_Global_Item\n-              (Item : Node_Id;\n-               Mode : Name_Id)\n-            is\n-            begin\n-               if Nam_In (Mode, Name_In_Out, Name_Input) then\n-                  Add_Item (Item, Subp_Inputs);\n-               end if;\n-\n-               if Nam_In (Mode, Name_In_Out, Name_Output) then\n-                  Add_Item (Item, Subp_Outputs);\n-               end if;\n-            end Collect_Global_Item;\n-\n-            --  Local variables\n-\n-            Assoc : Node_Id;\n-            Item  : Node_Id;\n-\n-         --  Start of processing for Collect_Global_List\n-\n-         begin\n-            --  Single global item declaration\n-\n-            if Nkind_In (List, N_Identifier, N_Selected_Component) then\n-               Collect_Global_Item (List, Mode);\n-\n-            --  Simple global list or moded global list declaration\n-\n-            else\n-               if Present (Expressions (List)) then\n-                  Item := First (Expressions (List));\n-                  while Present (Item) loop\n-                     Collect_Global_Item (Item, Mode);\n-\n-                     Next (Item);\n-                  end loop;\n-\n-               else\n-                  Assoc := First (Component_Associations (List));\n-                  while Present (Assoc) loop\n-                     Collect_Global_List\n-                       (List => Expression (Assoc),\n-                        Mode => Chars (First (Choices (Assoc))));\n-\n-                     Next (Assoc);\n-                  end loop;\n-               end if;\n-            end if;\n-         end Collect_Global_List;\n-\n-         --  Local variables\n-\n-         Formal : Entity_Id;\n-         Global : Node_Id;\n-         List   : Node_Id;\n-\n-      --  Start of processing for Collect_Subprogram_Inputs_Outputs\n-\n-      begin\n-         --  Process all formal parameters\n-\n-         Formal := First_Formal (Subp_Id);\n-         while Present (Formal) loop\n-            if Ekind_In (Formal, E_In_Out_Parameter, E_In_Parameter) then\n-               Add_Item (Formal, Subp_Inputs);\n-            end if;\n-\n-            if Ekind_In (Formal, E_In_Out_Parameter, E_Out_Parameter) then\n-               Add_Item (Formal, Subp_Outputs);\n-            end if;\n-\n-            Next_Formal (Formal);\n-         end loop;\n-\n-         --  If the subprogram is subject to pragma Global, traverse all global\n-         --  lists and gather the relevant items.\n-\n-         Global := Find_Aspect (Subp_Id, Aspect_Global);\n-         if Present (Global) then\n-            Global_Seen := True;\n-\n-            --  Retrieve the pragma as it contains the analyzed lists\n-\n-            Global := Aspect_Rep_Item (Global);\n-\n-            --  The pragma may not have been analyzed because of the arbitrary\n-            --  declaration order of aspects. Make sure that it is analyzed for\n-            --  the purposes of item extraction.\n-\n-            if not Analyzed (Global) then\n-               Analyze_Global_In_Decl_Part (Global);\n-            end if;\n-\n-            List :=\n-              Expression (First (Pragma_Argument_Associations (Global)));\n-\n-            --  Nothing to be done for a null global list\n-\n-            if Nkind (List) /= N_Null then\n-               Collect_Global_List (List);\n-            end if;\n-         end if;\n-      end Collect_Subprogram_Inputs_Outputs;\n-\n       ----------------------\n       -- Normalize_Clause --\n       ----------------------\n@@ -1382,7 +1224,11 @@ package body Sem_Prag is\n          --  subprogram may depend on. These items are obtained from the\n          --  parameter profile or pragma Global (if available).\n \n-         Collect_Subprogram_Inputs_Outputs;\n+         Collect_Subprogram_Inputs_Outputs\n+           (Subp_Id      => Subp_Id,\n+            Subp_Inputs  => Subp_Inputs,\n+            Subp_Outputs => Subp_Outputs,\n+            Global_Seen  => Global_Seen);\n \n          --  Verify that every input or output of the subprogram appear in a\n          --  dependency.\n@@ -1402,7 +1248,11 @@ package body Sem_Prag is\n          --  subprogram may depend on. These items are obtained from the\n          --  parameter profile or pragma Global (if available).\n \n-         Collect_Subprogram_Inputs_Outputs;\n+         Collect_Subprogram_Inputs_Outputs\n+           (Subp_Id      => Subp_Id,\n+            Subp_Inputs  => Subp_Inputs,\n+            Subp_Outputs => Subp_Outputs,\n+            Global_Seen  => Global_Seen);\n \n          --  Ensure that the formal parameters are visible when analyzing all\n          --  clauses. This falls out of the general rule of aspects pertaining\n@@ -1505,6 +1355,14 @@ package body Sem_Prag is\n          --  processing a global list. This routine verifies that Mode is not a\n          --  duplicate mode and sets the flag Status.\n \n+         procedure Check_Mode_Restiction_In_Enclosing_Context\n+           (Item    : Node_Id;\n+            Item_Id : Entity_Id);\n+         --  Verify that an item of mode In_Out or Output does not appear as an\n+         --  input in the Global aspect of an enclosing subprogram. If this is\n+         --  the case, emit an error. Item and Item_Id are respectively the\n+         --  item and its entity.\n+\n          procedure Check_Mode_Restriction_In_Function (Mode : Node_Id);\n          --  Mode denotes either In_Out or Output. Depending on the kind of the\n          --  related subprogram, emit an error if those two modes apply to a\n@@ -1574,18 +1432,8 @@ package body Sem_Prag is\n                return;\n             end if;\n \n-            --  The same entity might be referenced through various way. Check\n-            --  the entity of the item rather than the item itself.\n-\n-            if Contains (Seen, Item_Id) then\n-               Error_Msg_N (\"duplicate global item\", Item);\n-\n-            --  Add the entity of the current item to the list of processed\n-            --  items.\n-\n-            else\n-               Add_Item (Item_Id, Seen);\n-            end if;\n+            --  At this point we know that the global item is one of the two\n+            --  valid choices. Perform mode- and usage-specific checks.\n \n             if Ekind (Item_Id) = E_Abstract_State\n               and then Is_Volatile_State (Item_Id)\n@@ -1611,6 +1459,26 @@ package body Sem_Prag is\n                      & \"Volatile Output state\", Item);\n                end if;\n             end if;\n+\n+            --  Verify that an output does not appear as an input in an\n+            --  enclosing subprogram.\n+\n+            if Nam_In (Global_Mode, Name_In_Out, Name_Output) then\n+               Check_Mode_Restiction_In_Enclosing_Context (Item, Item_Id);\n+            end if;\n+\n+            --  The same entity might be referenced through various way. Check\n+            --  the entity of the item rather than the item itself.\n+\n+            if Contains (Seen, Item_Id) then\n+               Error_Msg_N (\"duplicate global item\", Item);\n+\n+            --  Add the entity of the current item to the list of processed\n+            --  items.\n+\n+            else\n+               Add_Item (Item_Id, Seen);\n+            end if;\n          end Analyze_Global_Item;\n \n          --------------------------\n@@ -1629,6 +1497,53 @@ package body Sem_Prag is\n             Status := True;\n          end Check_Duplicate_Mode;\n \n+         ------------------------------------------------\n+         -- Check_Mode_Restiction_In_Enclosing_Context --\n+         ------------------------------------------------\n+\n+         procedure Check_Mode_Restiction_In_Enclosing_Context\n+           (Item    : Node_Id;\n+            Item_Id : Entity_Id)\n+         is\n+            Dummy   : Boolean;\n+            Inputs  : Elist_Id := No_Elist;\n+            Outputs : Elist_Id := No_Elist;\n+            Subp_Id : Entity_Id;\n+\n+         begin\n+            --  Traverse the scope stack looking for enclosing subprograms\n+            --  subject to aspect/pragma Global.\n+\n+            Subp_Id := Scope (Current_Scope);\n+            while Present (Subp_Id) and then Subp_Id /= Standard_Standard loop\n+               if Is_Subprogram (Subp_Id)\n+                 and then Has_Aspect (Subp_Id, Aspect_Global)\n+               then\n+                  Collect_Subprogram_Inputs_Outputs\n+                    (Subp_Id      => Subp_Id,\n+                     Subp_Inputs  => Inputs,\n+                     Subp_Outputs => Outputs,\n+                     Global_Seen  => Dummy);\n+\n+                  --  The item is classified as In_Out or Output but appears as\n+                  --  an Input in an enclosing subprogram.\n+\n+                  if Appears_In (Inputs, Item_Id)\n+                    and then not Appears_In (Outputs, Item_Id)\n+                  then\n+                     Error_Msg_NE\n+                       (\"global item & cannot have mode In_Out or Output\",\n+                        Item, Item_Id);\n+                     Error_Msg_NE\n+                       (\"\\item already appears as input of subprogram &\",\n+                        Item, Subp_Id);\n+                  end if;\n+               end if;\n+\n+               Subp_Id := Scope (Subp_Id);\n+            end loop;\n+         end Check_Mode_Restiction_In_Enclosing_Context;\n+\n          ----------------------------------------\n          -- Check_Mode_Restriction_In_Function --\n          ----------------------------------------\n@@ -8559,7 +8474,9 @@ package body Sem_Prag is\n                Par := Unit (Par);\n             end if;\n \n-            if Nkind (Par) /= N_Package_Declaration then\n+            if not Nkind_In (Par, N_Generic_Package_Declaration,\n+                                  N_Package_Declaration)\n+            then\n                Pragma_Misplaced;\n                return;\n             end if;\n@@ -10660,11 +10577,6 @@ package body Sem_Prag is\n \n             Subp_Id := Defining_Unit_Name (Specification (Subp_Decl));\n \n-            --  The pragma is analyzed at the end of the declarative part which\n-            --  contains the related subprogram. Reset the analyzed flag.\n-\n-            Set_Analyzed (N, False);\n-\n             --  When the aspect/pragma appears on a subprogram body, perform\n             --  the full analysis now.\n \n@@ -11906,11 +11818,6 @@ package body Sem_Prag is\n \n             Subp_Id := Defining_Unit_Name (Specification (Subp_Decl));\n \n-            --  The pragma is analyzed at the end of the declarative part which\n-            --  contains the related subprogram. Reset the analyzed flag.\n-\n-            Set_Analyzed (N, False);\n-\n             --  When the aspect/pragma appears on a subprogram body, perform\n             --  the full analysis now.\n \n@@ -17894,6 +17801,35 @@ package body Sem_Prag is\n       End_Scope;\n    end Analyze_Test_Case_In_Decl_Part;\n \n+   ----------------\n+   -- Appears_In --\n+   ----------------\n+\n+   function Appears_In (List : Elist_Id; Item_Id : Entity_Id) return Boolean is\n+      Elmt : Elmt_Id;\n+      Id   : Entity_Id;\n+\n+   begin\n+      if Present (List) then\n+         Elmt := First_Elmt (List);\n+         while Present (Elmt) loop\n+            if Nkind (Node (Elmt)) = N_Defining_Identifier then\n+               Id := Node (Elmt);\n+            else\n+               Id := Entity (Node (Elmt));\n+            end if;\n+\n+            if Id = Item_Id then\n+               return True;\n+            end if;\n+\n+            Next_Elmt (Elmt);\n+         end loop;\n+      end if;\n+\n+      return False;\n+   end Appears_In;\n+\n    ----------------\n    -- Check_Kind --\n    ----------------\n@@ -18007,6 +17943,143 @@ package body Sem_Prag is\n       end if;\n    end Check_Applicable_Policy;\n \n+   ---------------------------------------\n+   -- Collect_Subprogram_Inputs_Outputs --\n+   ---------------------------------------\n+\n+   procedure Collect_Subprogram_Inputs_Outputs\n+     (Subp_Id      : Entity_Id;\n+      Subp_Inputs  : in out Elist_Id;\n+      Subp_Outputs : in out Elist_Id;\n+      Global_Seen  : out Boolean)\n+   is\n+      procedure Collect_Global_List\n+        (List : Node_Id;\n+         Mode : Name_Id := Name_Input);\n+      --  Collect all relevant items from a global list\n+\n+      -------------------------\n+      -- Collect_Global_List --\n+      -------------------------\n+\n+      procedure Collect_Global_List\n+        (List : Node_Id;\n+         Mode : Name_Id := Name_Input)\n+      is\n+         procedure Collect_Global_Item\n+           (Item : Node_Id;\n+            Mode : Name_Id);\n+         --  Add an item to the proper subprogram input or output collection\n+\n+         -------------------------\n+         -- Collect_Global_Item --\n+         -------------------------\n+\n+         procedure Collect_Global_Item\n+           (Item : Node_Id;\n+            Mode : Name_Id)\n+         is\n+         begin\n+            if Nam_In (Mode, Name_In_Out, Name_Input) then\n+               Add_Item (Item, Subp_Inputs);\n+            end if;\n+\n+            if Nam_In (Mode, Name_In_Out, Name_Output) then\n+               Add_Item (Item, Subp_Outputs);\n+            end if;\n+         end Collect_Global_Item;\n+\n+         --  Local variables\n+\n+         Assoc : Node_Id;\n+         Item  : Node_Id;\n+\n+      --  Start of processing for Collect_Global_List\n+\n+      begin\n+         --  Single global item declaration\n+\n+         if Nkind_In (List, N_Identifier, N_Selected_Component) then\n+            Collect_Global_Item (List, Mode);\n+\n+         --  Simple global list or moded global list declaration\n+\n+         else\n+            if Present (Expressions (List)) then\n+               Item := First (Expressions (List));\n+               while Present (Item) loop\n+                  Collect_Global_Item (Item, Mode);\n+\n+                  Next (Item);\n+               end loop;\n+\n+            else\n+               Assoc := First (Component_Associations (List));\n+               while Present (Assoc) loop\n+                  Collect_Global_List\n+                    (List => Expression (Assoc),\n+                     Mode => Chars (First (Choices (Assoc))));\n+\n+                  Next (Assoc);\n+               end loop;\n+            end if;\n+         end if;\n+      end Collect_Global_List;\n+\n+      --  Local variables\n+\n+      Formal : Entity_Id;\n+      Global : Node_Id;\n+      List   : Node_Id;\n+\n+   --  Start of processing for Collect_Subprogram_Inputs_Outputs\n+\n+   begin\n+      Global_Seen := False;\n+\n+      --  Process all formal parameters\n+\n+      Formal := First_Formal (Subp_Id);\n+      while Present (Formal) loop\n+         if Ekind_In (Formal, E_In_Out_Parameter, E_In_Parameter) then\n+            Add_Item (Formal, Subp_Inputs);\n+         end if;\n+\n+         if Ekind_In (Formal, E_In_Out_Parameter, E_Out_Parameter) then\n+            Add_Item (Formal, Subp_Outputs);\n+         end if;\n+\n+         Next_Formal (Formal);\n+      end loop;\n+\n+      --  If the subprogram is subject to pragma Global, traverse all global\n+      --  lists and gather the relevant items.\n+\n+      Global := Find_Aspect (Subp_Id, Aspect_Global);\n+      if Present (Global) then\n+         Global_Seen := True;\n+\n+         --  Retrieve the pragma as it contains the analyzed lists\n+\n+         Global := Aspect_Rep_Item (Global);\n+         List   := Expression (First (Pragma_Argument_Associations (Global)));\n+\n+         --  The pragma may not have been analyzed because of the arbitrary\n+         --  declaration order of aspects. Make sure that it is analyzed for\n+         --  the purposes of item extraction.\n+\n+         if not Analyzed (List) then\n+            Analyze_Global_In_Decl_Part (Global);\n+         end if;\n+\n+         --  Nothing to be done for a null global list\n+\n+         if Nkind (List) /= N_Null then\n+            Collect_Global_List (List);\n+         end if;\n+      end if;\n+   end Collect_Subprogram_Inputs_Outputs;\n+\n    ---------------------------------\n    -- Delay_Config_Pragma_Analyze --\n    ---------------------------------"}, {"sha": "0d732d240a006d4e9d90a205f66da01c8822a54e", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40f731b98bd4035eee5c9ceccaf9a324a280a9a/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40f731b98bd4035eee5c9ceccaf9a324a280a9a/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=f40f731b98bd4035eee5c9ceccaf9a324a280a9a", "patch": "@@ -12964,6 +12964,40 @@ package body Sem_Util is\n       Set_Sloc (Endl, Loc);\n    end Process_End_Label;\n \n+   ----------------\n+   -- Referenced --\n+   ----------------\n+\n+   function Referenced (Id : Entity_Id; Expr : Node_Id) return Boolean is\n+      Seen : Boolean := False;\n+\n+      function Is_Reference (N : Node_Id) return Traverse_Result;\n+      --  Determine whether node N denotes a reference to Id. If this is the\n+      --  case, set global flag Seen to True and stop the traversal.\n+\n+      function Is_Reference (N : Node_Id) return Traverse_Result is\n+      begin\n+         if Is_Entity_Name (N)\n+           and then Present (Entity (N))\n+           and then Entity (N) = Id\n+         then\n+            Seen := True;\n+            return Abandon;\n+         else\n+            return OK;\n+         end if;\n+      end Is_Reference;\n+\n+      procedure Inspect_Expression is new Traverse_Proc (Is_Reference);\n+\n+   --  Start of processing for Referenced\n+\n+   begin\n+      Inspect_Expression (Expr);\n+\n+      return Seen;\n+   end Referenced;\n+\n    ------------------------------------\n    -- References_Generic_Formal_Type --\n    ------------------------------------"}, {"sha": "d6d1ecc2debb7fdebbc4448cf4c3faa41dec69be", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40f731b98bd4035eee5c9ceccaf9a324a280a9a/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40f731b98bd4035eee5c9ceccaf9a324a280a9a/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=f40f731b98bd4035eee5c9ceccaf9a324a280a9a", "patch": "@@ -1358,6 +1358,9 @@ package Sem_Util is\n    --  parameter Ent gives the entity to which the End_Label refers,\n    --  and to which cross-references are to be generated.\n \n+   function Referenced (Id : Entity_Id; Expr : Node_Id) return Boolean;\n+   --  Determine whether entity Id is referenced within expression Expr\n+\n    function References_Generic_Formal_Type (N : Node_Id) return Boolean;\n    --  Returns True if the expression Expr contains any references to a\n    --  generic type. This can only happen within a generic template."}]}