{"sha": "9b5485174b808986614d6d1d1f0ec319831c9ec4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWI1NDg1MTc0YjgwODk4NjYxNGQ2ZDFkMWYwZWMzMTk4MzFjOWVjNA==", "commit": {"author": {"name": "Andre Vehreschild", "email": "vehre@gmx.de", "date": "2015-01-17T18:08:38Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2015-01-17T18:08:38Z"}, "message": "re PR fortran/60357 ([F08] structure constructor with unspecified values for allocatable components)\n\n2015-01-17  Andre Vehreschild  <vehre@gmx.de>\n\n\tPR fortran/60357\n\t* primary.c (build_actual_constructor): Prevent warning.\n\t* trans-expr.c (alloc_scalar_allocatable_for_subcomponent_\n\tassignment): New function encapsulates treatment of allocatable\n\tcomponents.\n\t(gfc_trans_subcomponent_assign): Needed to distinguish between\n\tregular assignment and initilization.\n\t(gfc_trans_structure_assign): Same.\n\t(gfc_conv_structure): Same.\n\n\tPR fortran/61275\n\t* gfortran.h: deferred_parameter is not needed, because\n\tit artificial does the trick completely.\n\t* primary.c (build_actual_constructor): Same.\n\t(gfc_convert_to_structure_constructor): Same.\n\t* resolve.c (resolve_fl_derived0): Same.\n\t* trans-expr.c (gfc_conv_component_ref): Prevent treating\n\tallocatable deferred length char arrays here.\n\t(gfc_trans_subcomponent_assign): Same as above.\n\t* trans-types.c (gfc_sym_type): This is done in\n\tgfc_get_derived_type already.\n\n2015-01-17  Andre Vehreschild  <vehre@gmx.de>\n\n\tPR fortran/60357\n\t* gfortran.dg/alloc_comp_assign_13.f08: New test.\n\n\tPR fortran/61275\n\t* gfortran.dg/alloc_comp_assign_14.f08: New test.\n\n\tPR fortran/55932\n\t* gfortran.dg/alloc_comp_initializer_4.f03: New test.\n\nFrom-SVN: r219801", "tree": {"sha": "06544cb03384b136934c7ff6d2f7abc201fc2c56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/06544cb03384b136934c7ff6d2f7abc201fc2c56"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b5485174b808986614d6d1d1f0ec319831c9ec4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b5485174b808986614d6d1d1f0ec319831c9ec4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b5485174b808986614d6d1d1f0ec319831c9ec4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b5485174b808986614d6d1d1f0ec319831c9ec4/comments", "author": {"login": "vehre", "id": 4761547, "node_id": "MDQ6VXNlcjQ3NjE1NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4761547?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vehre", "html_url": "https://github.com/vehre", "followers_url": "https://api.github.com/users/vehre/followers", "following_url": "https://api.github.com/users/vehre/following{/other_user}", "gists_url": "https://api.github.com/users/vehre/gists{/gist_id}", "starred_url": "https://api.github.com/users/vehre/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vehre/subscriptions", "organizations_url": "https://api.github.com/users/vehre/orgs", "repos_url": "https://api.github.com/users/vehre/repos", "events_url": "https://api.github.com/users/vehre/events{/privacy}", "received_events_url": "https://api.github.com/users/vehre/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "33c2207d3fda2956ac036f306fc8bfc58b635da0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33c2207d3fda2956ac036f306fc8bfc58b635da0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33c2207d3fda2956ac036f306fc8bfc58b635da0"}], "stats": {"total": 326, "additions": 300, "deletions": 26}, "files": [{"sha": "41dd282a24d76abd2713b4a77685f134339096cb", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b5485174b808986614d6d1d1f0ec319831c9ec4/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b5485174b808986614d6d1d1f0ec319831c9ec4/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=9b5485174b808986614d6d1d1f0ec319831c9ec4", "patch": "@@ -1,3 +1,27 @@\n+2015-01-17  Andre Vehreschild  <vehre@gmx.de>\n+\n+\tPR fortran/60357\n+\t* primary.c (build_actual_constructor): Prevent warning.\n+\t* trans-expr.c (alloc_scalar_allocatable_for_subcomponent_\n+\tassignment): New function encapsulates treatment of allocatable\n+\tcomponents.\n+\t(gfc_trans_subcomponent_assign): Needed to distinguish between\n+\tregular assignment and initilization.\n+\t(gfc_trans_structure_assign): Same.\n+\t(gfc_conv_structure): Same.\n+\n+\tPR fortran/61275\n+\t* gfortran.h: deferred_parameter is not needed, because\n+\tit artificial does the trick completely.\n+\t* primary.c (build_actual_constructor): Same.\n+\t(gfc_convert_to_structure_constructor): Same.\n+\t* resolve.c (resolve_fl_derived0): Same.\n+\t* trans-expr.c (gfc_conv_component_ref): Prevent treating\n+\tallocatable deferred length char arrays here.\n+\t(gfc_trans_subcomponent_assign): Same as above.\n+\t* trans-types.c (gfc_sym_type): This is done in\n+\tgfc_get_derived_type already.\n+\n 2015-01-17  Andre Vehreschild  <vehre@gmx.de>\n \n \tPR fortran/60334"}, {"sha": "5049c2a5e3844cb59921c110f96b7a6dd26f021a", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b5485174b808986614d6d1d1f0ec319831c9ec4/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b5485174b808986614d6d1d1f0ec319831c9ec4/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=9b5485174b808986614d6d1d1f0ec319831c9ec4", "patch": "@@ -856,9 +856,6 @@ typedef struct\n   /* Attributes set by compiler extensions (!GCC$ ATTRIBUTES).  */\n   unsigned ext_attr:EXT_ATTR_NUM;\n \n-  /* Is a parameter associated with a deferred type component.  */\n-  unsigned deferred_parameter:1;\n-\n   /* The namespace where the attribute has been set.  */\n   struct gfc_namespace *volatile_ns, *asynchronous_ns;\n }"}, {"sha": "cbe7aa60e7b1cfe8788356113045bbc5556f2f1b", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b5485174b808986614d6d1d1f0ec319831c9ec4/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b5485174b808986614d6d1d1f0ec319831c9ec4/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=9b5485174b808986614d6d1d1f0ec319831c9ec4", "patch": "@@ -2367,14 +2367,16 @@ build_actual_constructor (gfc_structure_ctor_component **comp_head,\n \t\treturn false;\n \t      value = gfc_copy_expr (comp->initializer);\n \t    }\n-\t  else if (comp->attr.allocatable)\n+\t  else if (comp->attr.allocatable\n+\t\t   || (comp->ts.type == BT_CLASS\n+\t\t       && CLASS_DATA (comp)->attr.allocatable))\n \t    {\n \t      if (!gfc_notify_std (GFC_STD_F2008, \"No initializer for \"\n-\t\t  \"allocatable component '%s' given in the structure \"\n-\t\t  \"constructor at %C\", comp->name))\n+\t\t\t\t   \"allocatable component '%qs' given in the \"\n+\t\t\t\t   \"structure constructor at %C\", comp->name))\n \t\treturn false;\n \t    }\n-\t  else if (!comp->attr.deferred_parameter)\n+\t  else if (!comp->attr.artificial)\n \t    {\n \t      gfc_error (\"No initializer for component %qs given in the\"\n \t\t\t \" structure constructor at %C!\", comp->name);\n@@ -2456,7 +2458,7 @@ gfc_convert_to_structure_constructor (gfc_expr *e, gfc_symbol *sym, gfc_expr **c\n \t{\n \t  /* Components without name are not allowed after the first named\n \t     component initializer!  */\n-\t  if (!comp || comp->attr.deferred_parameter)\n+\t  if (!comp || comp->attr.artificial)\n \t    {\n \t      if (last_name)\n \t\tgfc_error (\"Component initializer without name after component\""}, {"sha": "7a16add06b826d8d55c332bccaeef7f539998926", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b5485174b808986614d6d1d1f0ec319831c9ec4/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b5485174b808986614d6d1d1f0ec319831c9ec4/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=9b5485174b808986614d6d1d1f0ec319831c9ec4", "patch": "@@ -12707,7 +12707,7 @@ resolve_fl_derived0 (gfc_symbol *sym)\n \t      strlen->ts.type = BT_INTEGER;\n \t      strlen->ts.kind = gfc_charlen_int_kind;\n \t      strlen->attr.access = ACCESS_PRIVATE;\n-\t      strlen->attr.deferred_parameter = 1;\n+\t      strlen->attr.artificial = 1;\n \t    }\n \t}\n "}, {"sha": "328ed008542a0c6745fe059bd937ff9116f4198c", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 150, "deletions": 10, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b5485174b808986614d6d1d1f0ec319831c9ec4/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b5485174b808986614d6d1d1f0ec319831c9ec4/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=9b5485174b808986614d6d1d1f0ec319831c9ec4", "patch": "@@ -1158,7 +1158,7 @@ realloc_lhs_warning (bt type, bool array, locus *where)\n }\n \n \n-static tree gfc_trans_structure_assign (tree dest, gfc_expr * expr);\n+static tree gfc_trans_structure_assign (tree dest, gfc_expr * expr, bool init);\n static void gfc_apply_interface_mapping_to_expr (gfc_interface_mapping *,\n \t\t\t\t\t\t gfc_expr *);\n \n@@ -1907,7 +1907,10 @@ gfc_conv_component_ref (gfc_se * se, gfc_ref * ref)\n \n   se->expr = tmp;\n \n-  if (c->ts.type == BT_CHARACTER && !c->attr.proc_pointer)\n+  /* Allocatable deferred char arrays are to be handled by the gfc_deferred_\n+     strlen () conditional below.  */\n+  if (c->ts.type == BT_CHARACTER && !c->attr.proc_pointer\n+      && !(c->attr.allocatable && c->ts.deferred))\n     {\n       tmp = c->ts.u.cl->backend_decl;\n       /* Components must always be constant length.  */\n@@ -6268,10 +6271,96 @@ gfc_trans_alloc_subarray_assign (tree dest, gfc_component * cm,\n }\n \n \n+/* Allocate or reallocate scalar component, as necessary.  */\n+\n+static void\n+alloc_scalar_allocatable_for_subcomponent_assignment (stmtblock_t *block,\n+\t\t\t\t\t\t      tree comp,\n+\t\t\t\t\t\t      gfc_component *cm,\n+\t\t\t\t\t\t      gfc_expr *expr2,\n+\t\t\t\t\t\t      gfc_symbol *sym)\n+{\n+  tree tmp;\n+  tree size;\n+  tree size_in_bytes;\n+  tree lhs_cl_size = NULL_TREE;\n+\n+  if (!comp)\n+    return;\n+\n+  if (!expr2 || expr2->rank)\n+    return;\n+\n+  realloc_lhs_warning (expr2->ts.type, false, &expr2->where);\n+\n+  if (cm->ts.type == BT_CHARACTER && cm->ts.deferred)\n+    {\n+      char name[GFC_MAX_SYMBOL_LEN+9];\n+      gfc_component *strlen;\n+      /* Use the rhs string length and the lhs element size.  */\n+      gcc_assert (expr2->ts.type == BT_CHARACTER);\n+      if (!expr2->ts.u.cl->backend_decl)\n+\t{\n+\t  gfc_conv_string_length (expr2->ts.u.cl, expr2, block);\n+\t  gcc_assert (expr2->ts.u.cl->backend_decl);\n+\t}\n+\n+      size = expr2->ts.u.cl->backend_decl;\n+\n+      /* Ensure that cm->ts.u.cl->backend_decl is a componentref to _%s_length\n+\t component.  */\n+      sprintf (name, \"_%s_length\", cm->name);\n+      strlen = gfc_find_component (sym, name, true, true);\n+      lhs_cl_size = fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t\t     gfc_charlen_type_node,\n+\t\t\t\t     TREE_OPERAND (comp, 0),\n+\t\t\t\t     strlen->backend_decl, NULL_TREE);\n+\n+      tmp = TREE_TYPE (gfc_typenode_for_spec (&cm->ts));\n+      tmp = TYPE_SIZE_UNIT (tmp);\n+      size_in_bytes = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t       TREE_TYPE (tmp), tmp,\n+\t\t\t\t       fold_convert (TREE_TYPE (tmp), size));\n+    }\n+  else\n+    {\n+      /* Otherwise use the length in bytes of the rhs.  */\n+      size = TYPE_SIZE_UNIT (gfc_typenode_for_spec (&cm->ts));\n+      size_in_bytes = size;\n+    }\n+\n+  size_in_bytes = fold_build2_loc (input_location, MAX_EXPR, size_type_node,\n+\t\t\t\t   size_in_bytes, size_one_node);\n+\n+  if (cm->ts.type == BT_DERIVED && cm->ts.u.derived->attr.alloc_comp)\n+    {\n+      tmp = build_call_expr_loc (input_location,\n+\t\t\t\t builtin_decl_explicit (BUILT_IN_CALLOC),\n+\t\t\t\t 2, build_one_cst (size_type_node),\n+\t\t\t\t size_in_bytes);\n+      tmp = fold_convert (TREE_TYPE (comp), tmp);\n+      gfc_add_modify (block, comp, tmp);\n+    }\n+  else\n+    {\n+      tmp = build_call_expr_loc (input_location,\n+\t\t\t\t builtin_decl_explicit (BUILT_IN_MALLOC),\n+\t\t\t\t 1, size_in_bytes);\n+      tmp = fold_convert (TREE_TYPE (comp), tmp);\n+      gfc_add_modify (block, comp, tmp);\n+    }\n+\n+  if (cm->ts.type == BT_CHARACTER && cm->ts.deferred)\n+    /* Update the lhs character length.  */\n+    gfc_add_modify (block, lhs_cl_size, size);\n+}\n+\n+\n /* Assign a single component of a derived type constructor.  */\n \n static tree\n-gfc_trans_subcomponent_assign (tree dest, gfc_component * cm, gfc_expr * expr)\n+gfc_trans_subcomponent_assign (tree dest, gfc_component * cm, gfc_expr * expr,\n+\t\t\t       gfc_symbol *sym, bool init)\n {\n   gfc_se se;\n   gfc_se lse;\n@@ -6282,6 +6371,7 @@ gfc_trans_subcomponent_assign (tree dest, gfc_component * cm, gfc_expr * expr)\n \n   if (cm->attr.pointer || cm->attr.proc_pointer)\n     {\n+      /* Only care about pointers here, not about allocatables.  */\n       gfc_init_se (&se, NULL);\n       /* Pointer component.  */\n       if ((cm->attr.dimension || cm->attr.codimension)\n@@ -6319,7 +6409,8 @@ gfc_trans_subcomponent_assign (tree dest, gfc_component * cm, gfc_expr * expr)\n     {\n       /* NULL initialization for CLASS components.  */\n       tmp = gfc_trans_structure_assign (dest,\n-\t\t\t\t\tgfc_class_initializer (&cm->ts, expr));\n+\t\t\t\t\tgfc_class_initializer (&cm->ts, expr),\n+\t\t\t\t\tfalse);\n       gfc_add_expr_to_block (&block, tmp);\n     }\n   else if ((cm->attr.dimension || cm->attr.codimension)\n@@ -6338,6 +6429,44 @@ gfc_trans_subcomponent_assign (tree dest, gfc_component * cm, gfc_expr * expr)\n \t  gfc_add_expr_to_block (&block, tmp);\n \t}\n     }\n+  else if (init && (cm->attr.allocatable\n+\t   || (cm->ts.type == BT_CLASS && CLASS_DATA (cm)->attr.allocatable)))\n+    {\n+      /* Take care about non-array allocatable components here.  The alloc_*\n+\t routine below is motivated by the alloc_scalar_allocatable_for_\n+\t assignment() routine, but with the realloc portions removed and\n+\t different input.  */\n+      alloc_scalar_allocatable_for_subcomponent_assignment (&block,\n+\t\t\t\t\t\t\t    dest,\n+\t\t\t\t\t\t\t    cm,\n+\t\t\t\t\t\t\t    expr,\n+\t\t\t\t\t\t\t    sym);\n+      /* The remainder of these instructions follow the if (cm->attr.pointer)\n+\t if (!cm->attr.dimension) part above.  */\n+      gfc_init_se (&se, NULL);\n+      gfc_conv_expr (&se, expr);\n+      gfc_add_block_to_block (&block, &se.pre);\n+\n+      if (expr->symtree && expr->symtree->n.sym->attr.proc_pointer\n+\t  && expr->symtree->n.sym->attr.dummy)\n+\tse.expr = build_fold_indirect_ref_loc (input_location, se.expr);\n+      tmp = build_fold_indirect_ref_loc (input_location, dest);\n+      /* For deferred strings insert a memcpy.  */\n+      if (cm->ts.type == BT_CHARACTER && cm->ts.deferred)\n+\t{\n+\t  tree size;\n+\t  gcc_assert (se.string_length || expr->ts.u.cl->backend_decl);\n+\t  size = size_of_string_in_bytes (cm->ts.kind, se.string_length\n+\t\t\t\t\t\t? se.string_length\n+\t\t\t\t\t\t: expr->ts.u.cl->backend_decl);\n+\t  tmp = gfc_build_memcpy_call (tmp, se.expr, size);\n+\t  gfc_add_expr_to_block (&block, tmp);\n+\t}\n+      else\n+\tgfc_add_modify (&block, tmp,\n+\t\t\tfold_convert (TREE_TYPE (tmp), se.expr));\n+      gfc_add_block_to_block (&block, &se.post);\n+    }\n   else if (expr->ts.type == BT_DERIVED && expr->ts.f90_type != BT_VOID)\n     {\n       if (expr->expr_type != EXPR_STRUCTURE)\n@@ -6352,7 +6481,7 @@ gfc_trans_subcomponent_assign (tree dest, gfc_component * cm, gfc_expr * expr)\n       else\n \t{\n \t  /* Nested constructors.  */\n-\t  tmp = gfc_trans_structure_assign (dest, expr);\n+\t  tmp = gfc_trans_structure_assign (dest, expr, expr->symtree != NULL);\n \t  gfc_add_expr_to_block (&block, tmp);\n \t}\n     }\n@@ -6389,7 +6518,7 @@ gfc_trans_subcomponent_assign (tree dest, gfc_component * cm, gfc_expr * expr)\n \t  gfc_add_expr_to_block (&block, tmp);\n \t}\n     }\n-  else if (!cm->attr.deferred_parameter)\n+  else if (!cm->attr.artificial)\n     {\n       /* Scalar component (excluding deferred parameters).  */\n       gfc_init_se (&se, NULL);\n@@ -6408,7 +6537,7 @@ gfc_trans_subcomponent_assign (tree dest, gfc_component * cm, gfc_expr * expr)\n /* Assign a derived type constructor to a variable.  */\n \n static tree\n-gfc_trans_structure_assign (tree dest, gfc_expr * expr)\n+gfc_trans_structure_assign (tree dest, gfc_expr * expr, bool init)\n {\n   gfc_constructor *c;\n   gfc_component *cm;\n@@ -6440,13 +6569,22 @@ gfc_trans_structure_assign (tree dest, gfc_expr * expr)\n        c; c = gfc_constructor_next (c), cm = cm->next)\n     {\n       /* Skip absent members in default initializers.  */\n-      if (!c->expr)\n+      if (!c->expr && !cm->attr.allocatable)\n \tcontinue;\n \n       field = cm->backend_decl;\n       tmp = fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (field),\n \t\t\t     dest, field, NULL_TREE);\n-      tmp = gfc_trans_subcomponent_assign (tmp, cm, c->expr);\n+      if (!c->expr)\n+\t{\n+\t  gfc_expr *e = gfc_get_null_expr (NULL);\n+\t  tmp = gfc_trans_subcomponent_assign (tmp, cm, e, expr->ts.u.derived,\n+\t\t\t\t\t       init);\n+\t  gfc_free_expr (e);\n+\t}\n+      else\n+        tmp = gfc_trans_subcomponent_assign (tmp, cm, c->expr,\n+                                             expr->ts.u.derived, init);\n       gfc_add_expr_to_block (&block, tmp);\n     }\n   return gfc_finish_block (&block);\n@@ -6473,7 +6611,9 @@ gfc_conv_structure (gfc_se * se, gfc_expr * expr, int init)\n     {\n       /* Create a temporary variable and fill it in.  */\n       se->expr = gfc_create_var (type, expr->ts.u.derived->name);\n-      tmp = gfc_trans_structure_assign (se->expr, expr);\n+      /* The symtree in expr is NULL, if the code to generate is for\n+\t initializing the static members only.  */\n+      tmp = gfc_trans_structure_assign (se->expr, expr, expr->symtree != NULL);\n       gfc_add_expr_to_block (&se->pre, tmp);\n       return;\n     }"}, {"sha": "1ee490e35f452f45c1254714d3a70660344d5e89", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b5485174b808986614d6d1d1f0ec319831c9ec4/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b5485174b808986614d6d1d1f0ec319831c9ec4/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=9b5485174b808986614d6d1d1f0ec319831c9ec4", "patch": "@@ -1112,12 +1112,7 @@ gfc_typenode_for_spec (gfc_typespec * spec)\n       break;\n \n     case BT_CHARACTER:\n-#if 0\n-      if (spec->deferred)\n-\tbasetype = gfc_get_character_type (spec->kind, NULL);\n-      else\n-#endif\n-\tbasetype = gfc_get_character_type (spec->kind, spec->u.cl);\n+      basetype = gfc_get_character_type (spec->kind, spec->u.cl);\n       break;\n \n     case BT_HOLLERITH:\n@@ -2163,7 +2158,9 @@ gfc_sym_type (gfc_symbol * sym)\n       && ((sym->attr.function && sym->attr.is_bind_c)\n \t  || (sym->attr.result\n \t      && sym->ns->proc_name\n-\t      && sym->ns->proc_name->attr.is_bind_c)))\n+\t      && sym->ns->proc_name->attr.is_bind_c)\n+\t  || (sym->ts.deferred && (!sym->ts.u.cl\n+\t\t\t\t   || !sym->ts.u.cl->backend_decl))))\n     type = gfc_character1_type_node;\n   else\n     type = gfc_typenode_for_spec (&sym->ts);"}, {"sha": "088c0f712f50b168bd2ccbfb196df159f3d66513", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b5485174b808986614d6d1d1f0ec319831c9ec4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b5485174b808986614d6d1d1f0ec319831c9ec4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9b5485174b808986614d6d1d1f0ec319831c9ec4", "patch": "@@ -1,3 +1,14 @@\n+2015-01-17  Andre Vehreschild  <vehre@gmx.de>\n+\n+\tPR fortran/60357\n+\t* gfortran.dg/alloc_comp_assign_13.f08: New test.\n+\n+\tPR fortran/61275\n+\t* gfortran.dg/alloc_comp_assign_14.f08: New test.\n+\n+\tPR fortran/55932\n+\t* gfortran.dg/alloc_comp_initializer_4.f03: New test.\n+\n 2015-01-17  Andre Vehreschild  <vehre@gmx.de>\n \n \tPR fortran/60334"}, {"sha": "fe697908a2dac780a3fc801ea34f9c2e3df52b71", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_assign_13.f08", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b5485174b808986614d6d1d1f0ec319831c9ec4/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_assign_13.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b5485174b808986614d6d1d1f0ec319831c9ec4/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_assign_13.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_assign_13.f08?ref=9b5485174b808986614d6d1d1f0ec319831c9ec4", "patch": "@@ -0,0 +1,43 @@\n+! { dg-do run }\n+! Test for allocatable scalar components and deferred length char arrays.\n+! Check that fix for pr60357 works.\n+! Contributed by Antony Lewis <antony@cosmologist.info> and\n+!                Andre Vehreschild <vehre@gmx.de>\n+!\n+program test_allocatable_components\n+    Type A\n+        integer :: X\n+        integer, allocatable :: y\n+        character(len=:), allocatable :: c\n+    end type A\n+    Type(A) :: Me\n+    Type(A) :: Ea\n+\n+    Me= A(X= 1, Y= 2, C=\"correctly allocated\")\n+\n+    if (Me%X /= 1) call abort()\n+    if (.not. allocated(Me%y) .or. Me%y /= 2) call abort()\n+    if (.not. allocated(Me%c)) call abort()\n+    if (len(Me%c) /= 19) call abort()\n+    if (Me%c /= \"correctly allocated\") call abort()\n+\n+    ! Now check explicitly allocated components.\n+    Ea%X = 9\n+    allocate(Ea%y)\n+    Ea%y = 42\n+    ! Implicit allocate on assign in the next line\n+    Ea%c = \"13 characters\"\n+\n+    if (Ea%X /= 9) call abort()\n+    if (.not. allocated(Ea%y) .or. Ea%y /= 42) call abort()\n+    if (.not. allocated(Ea%c)) call abort()\n+    if (len(Ea%c) /= 13) call abort()\n+    if (Ea%c /= \"13 characters\") call abort()\n+\n+    deallocate(Ea%y)\n+    deallocate(Ea%c)\n+    if (allocated(Ea%y)) call abort()\n+    if (allocated(Ea%c)) call abort()\n+end program\n+\n+! vim:ts=4:sts=4:sw=4:"}, {"sha": "0fd4d91f0c174861d14943299767beb45f77c026", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_assign_14.f08", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b5485174b808986614d6d1d1f0ec319831c9ec4/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_assign_14.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b5485174b808986614d6d1d1f0ec319831c9ec4/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_assign_14.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_assign_14.f08?ref=9b5485174b808986614d6d1d1f0ec319831c9ec4", "patch": "@@ -0,0 +1,46 @@\n+! { dg-do run }\n+! Test for allocatable scalar components and deferred length char arrays.\n+! Check that fix for pr61275 works.\n+! Contributed by Antony Lewis <antony@cosmologist.info> and\n+!                Andre Vehreschild <vehre@gmx.de>\n+!\n+module typeA\n+    Type A\n+        integer :: X\n+        integer, allocatable :: y\n+        character(len=:), allocatable :: c\n+    end type A\n+end module\n+\n+program test_allocatable_components\n+    use typeA\n+    Type(A) :: Me\n+    Type(A) :: Ea\n+\n+    Me= A(X= 1, Y= 2, C=\"correctly allocated\")\n+\n+    if (Me%X /= 1) call abort()\n+    if (.not. allocated(Me%y) .or. Me%y /= 2) call abort()\n+    if (.not. allocated(Me%c)) call abort()\n+    if (len(Me%c) /= 19) call abort()\n+    if (Me%c /= \"correctly allocated\") call abort()\n+\n+    ! Now check explicitly allocated components.\n+    Ea%X = 9\n+    allocate(Ea%y)\n+    Ea%y = 42\n+    ! Implicit allocate on assign in the next line\n+    Ea%c = \"13 characters\"\n+\n+    if (Ea%X /= 9) call abort()\n+    if (.not. allocated(Ea%y) .or. Ea%y /= 42) call abort()\n+    if (.not. allocated(Ea%c)) call abort()\n+    if (len(Ea%c) /= 13) call abort()\n+    if (Ea%c /= \"13 characters\") call abort()\n+\n+    deallocate(Ea%y)\n+    deallocate(Ea%c)\n+    if (allocated(Ea%y)) call abort()\n+    if (allocated(Ea%c)) call abort()\n+end program\n+"}, {"sha": "66a5553dec43d4a21c57c6d8fb95bd0eed85a327", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_initializer_4.f03", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b5485174b808986614d6d1d1f0ec319831c9ec4/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_initializer_4.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b5485174b808986614d6d1d1f0ec319831c9ec4/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_initializer_4.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_initializer_4.f03?ref=9b5485174b808986614d6d1d1f0ec319831c9ec4", "patch": "@@ -0,0 +1,14 @@\n+! { dg-do run }\n+! Fixed by the patch for PRs 60357 and 61275\n+!\n+! Contributed by Stefan Mauerberger  <stefan.mauerberger@gmail.com>\n+!\n+PROGRAM main\n+  IMPLICIT NONE\n+  TYPE :: test_typ\n+    REAL, ALLOCATABLE :: a\n+  END TYPE\n+  TYPE(test_typ) :: my_test_typ\n+  my_test_typ = test_typ (a = 1.0)\n+  if (abs (my_test_typ%a - 1.0) .gt. 1e-6) call abort\n+END PROGRAM main"}]}