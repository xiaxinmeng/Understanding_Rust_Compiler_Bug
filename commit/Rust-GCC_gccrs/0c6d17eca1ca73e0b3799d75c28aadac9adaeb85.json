{"sha": "0c6d17eca1ca73e0b3799d75c28aadac9adaeb85", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGM2ZDE3ZWNhMWNhNzNlMGIzNzk5ZDc1YzI4YWFkYWM5YWRhZWI4NQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2003-09-16T17:16:25Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-09-16T17:16:25Z"}, "message": "re PR bootstrap/12269 (Mainline failed to bootstrap on Linux/ia64)\n\n\n\tPR bootstrap/12269\n\t* simplify-rtx.c (simplify_gen_relational): Allow the cmp_mode\n\targument to be VOIDmode, taking the mode of the comparison from\n\tthe operands.  Only call simplify_relational_operation if we\n\tknow the mode of the comparison.  Honor FLOAT_STORE_FLAG_VALUE\n\tif comparison has a floating point result.  Ensure that the\n\tresult is always of the specified mode.\n\t(simplify_replace_rtx): Simplify call to simplify_gen_relational.\n\t(simplify_unary_operation): Ensure the correct mode and cmp_mode\n\tare always passed to simplify_gen_relational.  Simplify NOT of\n\tcomparison operator in any mode, not just BImode.\n\t(simplify_ternary_operation): Correct tests on the return value\n\tof simplify_relational_operation to use const_true_rtx, not\n\tconst1_rtx.  Abort if it ever returns a non-constant result.\n\n\t* cfgloopanal.c (count_strange_loop_iterations): Use the function\n\tsimplify_relational_operation, not simplify_gen_relational, if\n\twe're only interested in constant comparisons and will ignore\n\tnon-constant results.\n\nFrom-SVN: r71439", "tree": {"sha": "a192947f5361f11b60ac0e1c25f61e8c3c0526b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a192947f5361f11b60ac0e1c25f61e8c3c0526b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0c6d17eca1ca73e0b3799d75c28aadac9adaeb85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c6d17eca1ca73e0b3799d75c28aadac9adaeb85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c6d17eca1ca73e0b3799d75c28aadac9adaeb85", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c6d17eca1ca73e0b3799d75c28aadac9adaeb85/comments", "author": null, "committer": null, "parents": [{"sha": "37af03cba8d6cd7b1fd7830748e3d9d6e47f3009", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37af03cba8d6cd7b1fd7830748e3d9d6e47f3009", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37af03cba8d6cd7b1fd7830748e3d9d6e47f3009"}], "stats": {"total": 123, "additions": 76, "deletions": 47}, "files": [{"sha": "679fcfd8a2bee1c1cebcec709711dc94fdc0c78c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c6d17eca1ca73e0b3799d75c28aadac9adaeb85/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c6d17eca1ca73e0b3799d75c28aadac9adaeb85/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0c6d17eca1ca73e0b3799d75c28aadac9adaeb85", "patch": "@@ -1,3 +1,25 @@\n+2003-09-16  Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR bootstrap/12269\n+\t* simplify-rtx.c (simplify_gen_relational): Allow the cmp_mode\n+\targument to be VOIDmode, taking the mode of the comparison from\n+\tthe operands.  Only call simplify_relational_operation if we\n+\tknow the mode of the comparison.  Honor FLOAT_STORE_FLAG_VALUE\n+\tif comparison has a floating point result.  Ensure that the\n+\tresult is always of the specified mode.\n+\t(simplify_replace_rtx): Simplify call to simplify_gen_relational.\n+\t(simplify_unary_operation): Ensure the correct mode and cmp_mode\n+\tare always passed to simplify_gen_relational.  Simplify NOT of\n+\tcomparison operator in any mode, not just BImode.\n+\t(simplify_ternary_operation): Correct tests on the return value\n+\tof simplify_relational_operation to use const_true_rtx, not\n+\tconst1_rtx.  Abort if it ever returns a non-constant result.\n+\n+\t* cfgloopanal.c (count_strange_loop_iterations): Use the function\n+\tsimplify_relational_operation, not simplify_gen_relational, if\n+\twe're only interested in constant comparisons and will ignore\n+\tnon-constant results.\n+\n 2003-09-16  Roger Sayle  <roger@eyesopen.com>\n \n \t* fold-const.c (tree_swap_operands_p): New function to determine"}, {"sha": "57c3baceff487db379d09e777b3ab972d84a034d", "filename": "gcc/cfgloopanal.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c6d17eca1ca73e0b3799d75c28aadac9adaeb85/gcc%2Fcfgloopanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c6d17eca1ca73e0b3799d75c28aadac9adaeb85/gcc%2Fcfgloopanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopanal.c?ref=0c6d17eca1ca73e0b3799d75c28aadac9adaeb85", "patch": "@@ -470,7 +470,7 @@ count_strange_loop_iterations (rtx init, rtx lim, enum rtx_code cond,\n \n   /* If we are able to prove that we don't pass the first test, we are\n      done.  */\n-  rqmt = simplify_gen_relational (cond, SImode, mode, init, lim);\n+  rqmt = simplify_relational_operation (cond, mode, init, lim);\n   if (rqmt == const0_rtx)\n     return const0_rtx;\n \n@@ -560,7 +560,7 @@ count_strange_loop_iterations (rtx init, rtx lim, enum rtx_code cond,\n   /* If this is const_true_rtx and we did not take a conservative approximation\n      of after_wrap above, we might iterate the calculation (but of course we\n      would have to take care about infinite cases).  Ignore this for now.  */\n-  rqmt = simplify_gen_relational (cond, SImode, mode, after_wrap, lim);\n+  rqmt = simplify_relational_operation (cond, mode, after_wrap, lim);\n   if (rqmt != const0_rtx)\n     return NULL_RTX;\n "}, {"sha": "f2da9eef4d0659c1f7d7fda2f79b2520cc1efbfb", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 52, "deletions": 45, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c6d17eca1ca73e0b3799d75c28aadac9adaeb85/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c6d17eca1ca73e0b3799d75c28aadac9adaeb85/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=0c6d17eca1ca73e0b3799d75c28aadac9adaeb85", "patch": "@@ -197,38 +197,62 @@ simplify_gen_relational (enum rtx_code code, enum machine_mode mode,\n {\n   rtx tem;\n \n-  if ((tem = simplify_relational_operation (code, cmp_mode, op0, op1)) != 0)\n-    return tem;\n+  if (cmp_mode == VOIDmode)\n+    cmp_mode = GET_MODE (op0);\n+  if (cmp_mode == VOIDmode)\n+    cmp_mode = GET_MODE (op1);\n+\n+  if (cmp_mode != VOIDmode)\n+    {\n+      tem = simplify_relational_operation (code, cmp_mode, op0, op1);\n+\n+      if (tem)\n+\t{\n+#ifdef FLOAT_STORE_FLAG_VALUE\n+\t  if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n+\t    {\n+\t      REAL_VALUE_TYPE val;\n+\t      if (tem == const0_rtx)\n+\t\treturn CONST0_RTX (mode);\n+\t      if (tem != const_true_rtx)\n+\t\tabort ();\n+\t      val = FLOAT_STORE_FLAG_VALUE (mode);\n+\t      return CONST_DOUBLE_FROM_REAL_VALUE (val, mode);\n+\t    }\n+#endif\n+\t  return tem;\n+\t}\n+    }\n \n   /* For the following tests, ensure const0_rtx is op1.  */\n-  if (op0 == const0_rtx && swap_commutative_operands_p (op0, op1))\n+  if (swap_commutative_operands_p (op0, op1)\n+      || (op0 == const0_rtx && op1 != const0_rtx))\n     tem = op0, op0 = op1, op1 = tem, code = swap_condition (code);\n \n   /* If op0 is a compare, extract the comparison arguments from it.  */\n   if (GET_CODE (op0) == COMPARE && op1 == const0_rtx)\n-    op1 = XEXP (op0, 1), op0 = XEXP (op0, 0);\n+    return simplify_gen_relational (code, mode, VOIDmode,\n+\t\t\t\t    XEXP (op0, 0), XEXP (op0, 1));\n \n   /* If op0 is a comparison, extract the comparison arguments form it.  */\n-  if (code == NE && op1 == const0_rtx\n-      && GET_RTX_CLASS (GET_CODE (op0)) == '<')\n-    return op0;\n-  else if (code == EQ && op1 == const0_rtx)\n+  if (GET_RTX_CLASS (GET_CODE (op0)) == '<' && op1 == const0_rtx)\n     {\n-      /* The following tests GET_RTX_CLASS (GET_CODE (op0)) == '<'.  */\n-      enum rtx_code new = reversed_comparison_code (op0, NULL_RTX);\n-      if (new != UNKNOWN)\n-        {\n-\t  code = new;\n-\t  mode = cmp_mode;\n-\t  op1 = XEXP (op0, 1);\n-\t  op0 = XEXP (op0, 0);\n+      if (code == NE)\n+\t{\n+\t  if (GET_MODE (op0) == mode)\n+\t    return op0;\n+\t  return simplify_gen_relational (GET_CODE (op0), mode, VOIDmode,\n+\t\t\t\t\t  XEXP (op0, 0), XEXP (op0, 1));\n+\t}\n+      else if (code == EQ)\n+\t{\n+\t  enum rtx_code new = reversed_comparison_code (op0, NULL_RTX);\n+\t  if (new != UNKNOWN)\n+\t    return simplify_gen_relational (new, mode, VOIDmode,\n+\t\t\t\t\t    XEXP (op0, 0), XEXP (op0, 1));\n         }\n     }\n \n-  /* Put complex operands first and constants second.  */\n-  if (swap_commutative_operands_p (op0, op1))\n-    tem = op0, op0 = op1, op1 = tem, code = swap_condition (code);\n-\n   return gen_rtx_fmt_ee (code, mode, op0, op1);\n }\n \f\n@@ -272,24 +296,7 @@ simplify_replace_rtx (rtx x, rtx old, rtx new)\n \t\t\t\t     : GET_MODE (XEXP (x, 1)));\n \trtx op0 = simplify_replace_rtx (XEXP (x, 0), old, new);\n \trtx op1 = simplify_replace_rtx (XEXP (x, 1), old, new);\n-\trtx temp = simplify_gen_relational (code, mode,\n-\t\t\t\t\t    (op_mode != VOIDmode\n-\t\t\t\t\t     ? op_mode\n-\t\t\t\t\t     : GET_MODE (op0) != VOIDmode\n-\t\t\t\t\t       ? GET_MODE (op0)\n-\t\t\t\t\t       : GET_MODE (op1)),\n-\t\t\t\t\t    op0, op1);\n-#ifdef FLOAT_STORE_FLAG_VALUE\n-\tif (GET_MODE_CLASS (mode) == MODE_FLOAT)\n-\t{\n-\t  if (temp == const0_rtx)\n-\t    temp = CONST0_RTX (mode);\n-\t  else if (temp == const_true_rtx)\n-\t    temp = CONST_DOUBLE_FROM_REAL_VALUE (FLOAT_STORE_FLAG_VALUE (mode),\n-\t\t\t\t\t\t mode);\n-\t}\n-#endif\n-\treturn temp;\n+\treturn simplify_gen_relational (code, mode, op_mode, op0, op1);\n       }\n \n     case '3':\n@@ -800,10 +807,10 @@ simplify_unary_operation (enum rtx_code code, enum machine_mode mode,\n \t    return XEXP (op, 0);\n \n \t  /* (not (eq X Y)) == (ne X Y), etc.  */\n-\t  if (mode == BImode && GET_RTX_CLASS (GET_CODE (op)) == '<'\n+\t  if (GET_RTX_CLASS (GET_CODE (op)) == '<'\n \t      && ((reversed = reversed_comparison_code (op, NULL_RTX))\n \t\t  != UNKNOWN))\n-\t    return simplify_gen_relational (reversed, op_mode, op_mode,\n+\t    return simplify_gen_relational (reversed, mode, VOIDmode,\n \t\t\t\t\t    XEXP (op, 0), XEXP (op, 1));\n \n           /* (not (plus X -1)) can become (neg X).  */\n@@ -842,7 +849,7 @@ simplify_unary_operation (enum rtx_code code, enum machine_mode mode,\n \t      && GET_RTX_CLASS (GET_CODE (op)) == '<'\n \t      && (reversed = reversed_comparison_code (op, NULL_RTX))\n \t\t != UNKNOWN)\n-\t    return simplify_gen_relational (reversed, op_mode, op_mode,\n+\t    return simplify_gen_relational (reversed, mode, VOIDmode,\n \t\t\t\t\t    XEXP (op, 0), XEXP (op, 1));\n \n \t  /* (not (ashiftrt foo C)) where C is the number of bits in FOO\n@@ -853,8 +860,8 @@ simplify_unary_operation (enum rtx_code code, enum machine_mode mode,\n \t      && GET_CODE (op) == ASHIFTRT\n \t      && GET_CODE (XEXP (op, 1)) == CONST_INT\n \t      && INTVAL (XEXP (op, 1)) == GET_MODE_BITSIZE (mode) - 1)\n-\t    return simplify_gen_relational (GE, mode, mode, XEXP (op, 0),\n-\t\t\t\t\t    const0_rtx);\n+\t    return simplify_gen_relational (GE, mode, VOIDmode,\n+\t\t\t\t\t    XEXP (op, 0), const0_rtx);\n \n \t  break;\n \n@@ -2725,10 +2732,10 @@ simplify_ternary_operation (enum rtx_code code, enum machine_mode mode,\n \t  /* See if any simplifications were possible.  */\n \t  if (temp == const0_rtx)\n \t    return op2;\n-\t  else if (temp == const1_rtx)\n+\t  else if (temp == const_true_rtx)\n \t    return op1;\n \t  else if (temp)\n-\t    op0 = temp;\n+\t    abort ();\n \n \t  /* Look for happy constants in op1 and op2.  */\n \t  if (GET_CODE (op1) == CONST_INT && GET_CODE (op2) == CONST_INT)"}]}