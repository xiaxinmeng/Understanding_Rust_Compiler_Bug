{"sha": "5f83e90bb6f44cb079edf65b55f3caab34c42516", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWY4M2U5MGJiNmY0NGNiMDc5ZWRmNjViNTVmM2NhYWIzNGM0MjUxNg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2014-10-15T14:12:24Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2014-10-15T14:12:24Z"}, "message": "re PR c++/63455 (decltype of statement expression  internal compiler error: in cp_parser_abort_tentative_parse, at cp/parser.c:25062)\n\n\tPR c++/63455\nc-family/\n\t* c-common.h (CPP_PREPARSED_EXPR): New.\n\t(N_CP_TTYPES): Adjust.\ncp/\n\t* parser.c (struct saved_token_sentinel): New.\n\t(cp_parser_statement): Use it.\n\t(cp_parser_start_tentative_firewall): New.\n\t(cp_parser_end_tentative_firewall): New.\n\t(cp_parser_lambda_expression): Use them.\n\t(cp_parser_statement_expr): New.\n\t(cp_parser_primary_expression): Use it.\n\nFrom-SVN: r216260", "tree": {"sha": "d4540d6292cb29ad0a829b9d951b84d6a3058e85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d4540d6292cb29ad0a829b9d951b84d6a3058e85"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f83e90bb6f44cb079edf65b55f3caab34c42516", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f83e90bb6f44cb079edf65b55f3caab34c42516", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f83e90bb6f44cb079edf65b55f3caab34c42516", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f83e90bb6f44cb079edf65b55f3caab34c42516/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "327a79a52392f9fec4c92693278fe8d362bc7008", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/327a79a52392f9fec4c92693278fe8d362bc7008", "html_url": "https://github.com/Rust-GCC/gccrs/commit/327a79a52392f9fec4c92693278fe8d362bc7008"}], "stats": {"total": 254, "additions": 194, "deletions": 60}, "files": [{"sha": "7c5152810687f7be9718f9d0f1c72bd51417b26b", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f83e90bb6f44cb079edf65b55f3caab34c42516/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f83e90bb6f44cb079edf65b55f3caab34c42516/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=5f83e90bb6f44cb079edf65b55f3caab34c42516", "patch": "@@ -1,3 +1,9 @@\n+2014-10-14  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/63455\n+\t* c-common.h (CPP_PREPARSED_EXPR): New.\n+\t(N_CP_TTYPES): Adjust.\n+\n 2014-10-15  Marek Polacek  <polacek@redhat.com>\n \n \t* c-opts.c (c_common_init_options): Make -std=gnu11 the default for C."}, {"sha": "b45ccfce35be0b7e45b4f6b4b79ad05e267f8b63", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f83e90bb6f44cb079edf65b55f3caab34c42516/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f83e90bb6f44cb079edf65b55f3caab34c42516/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=5f83e90bb6f44cb079edf65b55f3caab34c42516", "patch": "@@ -361,8 +361,11 @@ struct c_common_resword\n /* A token type for pre-parsed C++0x decltype.  */\n #define CPP_DECLTYPE ((enum cpp_ttype) (CPP_NESTED_NAME_SPECIFIER + 1))\n \n+/* A token type for pre-parsed primary-expression (lambda- or statement-).  */\n+#define CPP_PREPARSED_EXPR ((enum cpp_ttype) (CPP_DECLTYPE + 1))\n+\n /* The number of token types, including C++-specific ones.  */\n-#define N_CP_TTYPES ((int) (CPP_DECLTYPE + 1))\n+#define N_CP_TTYPES ((int) (CPP_PREPARSED_EXPR + 1))\n \n /* Disable mask.  Keywords are disabled if (reswords[i].disable &\n    mask) is _true_.  Thus for keywords which are present in all"}, {"sha": "97b373c270362064468049ece81f0fa642bb565e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f83e90bb6f44cb079edf65b55f3caab34c42516/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f83e90bb6f44cb079edf65b55f3caab34c42516/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5f83e90bb6f44cb079edf65b55f3caab34c42516", "patch": "@@ -1,3 +1,14 @@\n+2014-10-14  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/63455\n+\t* parser.c (struct saved_token_sentinel): New.\n+\t(cp_parser_statement): Use it.\n+\t(cp_parser_start_tentative_firewall): New.\n+\t(cp_parser_end_tentative_firewall): New.\n+\t(cp_parser_lambda_expression): Use them.\n+\t(cp_parser_statement_expr): New.\n+\t(cp_parser_primary_expression): Use it.\n+\n 2014-10-14  DJ Delorie  <dj@redhat.com>\n \n \t* typeck.c (cp_common_type): Check for all __intN types, not just"}, {"sha": "c73099547ff9a3cd70a0d2869b7c83f26ef26741", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 158, "deletions": 55, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f83e90bb6f44cb079edf65b55f3caab34c42516/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f83e90bb6f44cb079edf65b55f3caab34c42516/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=5f83e90bb6f44cb079edf65b55f3caab34c42516", "patch": "@@ -1,4 +1,4 @@\n-/* C++ Parser.\n+/* -*- C++ -*- Parser.\n    Copyright (C) 2000-2014 Free Software Foundation, Inc.\n    Written by Mark Mitchell <mark@codesourcery.com>.\n \n@@ -1155,6 +1155,34 @@ cp_lexer_rollback_tokens (cp_lexer* lexer)\n   lexer->next_token = lexer->saved_tokens.pop ();\n }\n \n+/* RAII wrapper around the above functions, with sanity checking.  Creating\n+   a variable saves tokens, which are committed when the variable is\n+   destroyed unless they are explicitly rolled back by calling the rollback\n+   member function.  */\n+\n+struct saved_token_sentinel\n+{\n+  cp_lexer *lexer;\n+  unsigned len;\n+  bool commit;\n+  saved_token_sentinel(cp_lexer *lexer): lexer(lexer), commit(true)\n+  {\n+    len = lexer->saved_tokens.length ();\n+    cp_lexer_save_tokens (lexer);\n+  }\n+  void rollback ()\n+  {\n+    cp_lexer_rollback_tokens (lexer);\n+    commit = false;\n+  }\n+  ~saved_token_sentinel()\n+  {\n+    if (commit)\n+      cp_lexer_commit_tokens (lexer);\n+    gcc_assert (lexer->saved_tokens.length () == len);\n+  }\n+};\n+\n /* Print a representation of the TOKEN on the STREAM.  */\n \n static void\n@@ -4107,6 +4135,65 @@ complain_flags (bool decltype_p)\n   return complain;\n }\n \n+/* We're about to parse a collection of statements.  If we're currently\n+   parsing tentatively, set up a firewall so that any nested\n+   cp_parser_commit_to_tentative_parse won't affect the current context.  */\n+\n+static cp_token_position\n+cp_parser_start_tentative_firewall (cp_parser *parser)\n+{\n+  if (!cp_parser_uncommitted_to_tentative_parse_p (parser))\n+    return 0;\n+\n+  cp_parser_parse_tentatively (parser);\n+  cp_parser_commit_to_topmost_tentative_parse (parser);\n+  return cp_lexer_token_position (parser->lexer, false);\n+}\n+\n+/* We've finished parsing the collection of statements.  Wrap up the\n+   firewall and replace the relevant tokens with the parsed form.  */\n+\n+static void\n+cp_parser_end_tentative_firewall (cp_parser *parser, cp_token_position start,\n+\t\t\t\t  tree expr)\n+{\n+  if (!start)\n+    return;\n+\n+  /* Finish the firewall level.  */\n+  cp_parser_parse_definitely (parser);\n+  /* And remember the result of the parse for when we try again.  */\n+  cp_token *token = cp_lexer_token_at (parser->lexer, start);\n+  token->type = CPP_PREPARSED_EXPR;\n+  token->u.value = expr;\n+  token->keyword = RID_MAX;\n+  cp_lexer_purge_tokens_after (parser->lexer, start);\n+}\n+\n+/* Parse a GNU statement-expression, i.e. ({ stmts }), except for the\n+   enclosing parentheses.  */\n+\n+static tree\n+cp_parser_statement_expr (cp_parser *parser)\n+{\n+  cp_token_position start = cp_parser_start_tentative_firewall (parser);\n+\n+  /* Consume the '('.  */\n+  cp_lexer_consume_token (parser->lexer);\n+  /* Start the statement-expression.  */\n+  tree expr = begin_stmt_expr ();\n+  /* Parse the compound-statement.  */\n+  cp_parser_compound_statement (parser, expr, false, false);\n+  /* Finish up.  */\n+  expr = finish_stmt_expr (expr, false);\n+  /* Consume the ')'.  */\n+  if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+    cp_parser_skip_to_end_of_statement (parser);\n+\n+  cp_parser_end_tentative_firewall (parser, start, expr);\n+  return expr;\n+}\n+\n /* Expressions [gram.expr] */\n \n /* Parse a primary-expression.\n@@ -4193,6 +4280,7 @@ cp_parser_primary_expression (cp_parser *parser,\n     case CPP_CHAR32:\n     case CPP_WCHAR:\n     case CPP_NUMBER:\n+    case CPP_PREPARSED_EXPR:\n       if (TREE_CODE (token->u.value) == USERDEF_LITERAL)\n \treturn cp_parser_userdef_numeric_literal (parser);\n       token = cp_lexer_consume_token (parser->lexer);\n@@ -4272,6 +4360,36 @@ cp_parser_primary_expression (cp_parser *parser,\n \t\t\t\t       true);\n \n     case CPP_OPEN_PAREN:\n+      /* If we see `( { ' then we are looking at the beginning of\n+\t a GNU statement-expression.  */\n+      if (cp_parser_allow_gnu_extensions_p (parser)\n+\t  && cp_lexer_nth_token_is (parser->lexer, 2, CPP_OPEN_BRACE))\n+\t{\n+\t  /* Statement-expressions are not allowed by the standard.  */\n+\t  pedwarn (token->location, OPT_Wpedantic,\n+\t\t   \"ISO C++ forbids braced-groups within expressions\");\n+\n+\t  /* And they're not allowed outside of a function-body; you\n+\t     cannot, for example, write:\n+\n+\t     int i = ({ int j = 3; j + 1; });\n+\n+\t     at class or namespace scope.  */\n+\t  if (!parser->in_function_body\n+\t      || parser->in_template_argument_list_p)\n+\t    {\n+\t      error_at (token->location,\n+\t\t\t\"statement-expressions are not allowed outside \"\n+\t\t\t\"functions nor in template-argument lists\");\n+\t      cp_parser_skip_to_end_of_block_or_statement (parser);\n+\t      if (cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_PAREN))\n+\t\tcp_lexer_consume_token (parser->lexer);\n+\t      return error_mark_node;\n+\t    }\n+\t  else\n+\t    return cp_parser_statement_expr (parser);\n+\t}\n+      /* Otherwise it's a normal parenthesized expression.  */\n       {\n \ttree expr;\n \tbool saved_greater_than_is_operator_p;\n@@ -4283,57 +4401,22 @@ cp_parser_primary_expression (cp_parser *parser,\n \tsaved_greater_than_is_operator_p\n \t  = parser->greater_than_is_operator_p;\n \tparser->greater_than_is_operator_p = true;\n-\t/* If we see `( { ' then we are looking at the beginning of\n-\t   a GNU statement-expression.  */\n-\tif (cp_parser_allow_gnu_extensions_p (parser)\n-\t    && cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n-\t  {\n-\t    /* Statement-expressions are not allowed by the standard.  */\n-\t    pedwarn (token->location, OPT_Wpedantic, \n-\t\t     \"ISO C++ forbids braced-groups within expressions\");\n-\n-\t    /* And they're not allowed outside of a function-body; you\n-\t       cannot, for example, write:\n \n-\t\t int i = ({ int j = 3; j + 1; });\n+\t/* Parse the parenthesized expression.  */\n+\texpr = cp_parser_expression (parser, idk, cast_p, decltype_p);\n+\t/* Let the front end know that this expression was\n+\t   enclosed in parentheses. This matters in case, for\n+\t   example, the expression is of the form `A::B', since\n+\t   `&A::B' might be a pointer-to-member, but `&(A::B)' is\n+\t   not.  */\n+\texpr = finish_parenthesized_expr (expr);\n+\t/* DR 705: Wrapping an unqualified name in parentheses\n+\t   suppresses arg-dependent lookup.  We want to pass back\n+\t   CP_ID_KIND_QUALIFIED for suppressing vtable lookup\n+\t   (c++/37862), but none of the others.  */\n+\tif (*idk != CP_ID_KIND_QUALIFIED)\n+\t  *idk = CP_ID_KIND_NONE;\n \n-\t       at class or namespace scope.  */\n-\t    if (!parser->in_function_body\n-\t\t|| parser->in_template_argument_list_p)\n-\t      {\n-\t\terror_at (token->location,\n-\t\t\t  \"statement-expressions are not allowed outside \"\n-\t\t\t  \"functions nor in template-argument lists\");\n-\t\tcp_parser_skip_to_end_of_block_or_statement (parser);\n-\t\texpr = error_mark_node;\n-\t      }\n-\t    else\n-\t      {\n-\t\t/* Start the statement-expression.  */\n-\t\texpr = begin_stmt_expr ();\n-\t\t/* Parse the compound-statement.  */\n-\t\tcp_parser_compound_statement (parser, expr, false, false);\n-\t\t/* Finish up.  */\n-\t\texpr = finish_stmt_expr (expr, false);\n-\t      }\n-\t  }\n-\telse\n-\t  {\n-\t    /* Parse the parenthesized expression.  */\n-\t    expr = cp_parser_expression (parser, idk, cast_p, decltype_p);\n-\t    /* Let the front end know that this expression was\n-\t       enclosed in parentheses. This matters in case, for\n-\t       example, the expression is of the form `A::B', since\n-\t       `&A::B' might be a pointer-to-member, but `&(A::B)' is\n-\t       not.  */\n-\t    expr = finish_parenthesized_expr (expr);\n-\t    /* DR 705: Wrapping an unqualified name in parentheses\n-\t       suppresses arg-dependent lookup.  We want to pass back\n-\t       CP_ID_KIND_QUALIFIED for suppressing vtable lookup\n-\t       (c++/37862), but none of the others.  */\n-\t    if (*idk != CP_ID_KIND_QUALIFIED)\n-\t      *idk = CP_ID_KIND_NONE;\n-\t  }\n \t/* The `>' token might be the end of a template-id or\n \t   template-parameter-list now.  */\n \tparser->greater_than_is_operator_p\n@@ -8869,6 +8952,7 @@ cp_parser_lambda_expression (cp_parser* parser)\n   tree type;\n   bool ok = true;\n   cp_token *token = cp_lexer_peek_token (parser->lexer);\n+  cp_token_position start = 0;\n \n   LAMBDA_EXPR_LOCATION (lambda_expr) = token->location;\n \n@@ -8882,6 +8966,15 @@ cp_parser_lambda_expression (cp_parser* parser)\n \t}\n       ok = false;\n     }\n+  else if (parser->in_template_argument_list_p)\n+    {\n+      if (!token->error_reported)\n+\t{\n+\t  error_at (token->location, \"lambda-expression in template-argument\");\n+\t  token->error_reported = true;\n+\t}\n+      ok = false;\n+    }\n \n   /* We may be in the middle of deferred access check.  Disable\n      it now.  */\n@@ -8929,7 +9022,13 @@ cp_parser_lambda_expression (cp_parser* parser)\n     ok &= cp_parser_lambda_declarator_opt (parser, lambda_expr);\n \n     if (ok)\n-      cp_parser_lambda_body (parser, lambda_expr);\n+      {\n+\tif (!cp_parser_error_occurred (parser)\n+\t    && cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE)\n+\t    && cp_parser_start_tentative_firewall (parser))\n+\t  start = token;\n+\tcp_parser_lambda_body (parser, lambda_expr);\n+      }\n     else if (cp_parser_require (parser, CPP_OPEN_BRACE, RT_OPEN_BRACE))\n       {\n \tif (cp_parser_skip_to_closing_brace (parser))\n@@ -8967,9 +9066,13 @@ cp_parser_lambda_expression (cp_parser* parser)\n   insert_pending_capture_proxies ();\n \n   if (ok)\n-    return build_lambda_object (lambda_expr);\n+    lambda_expr = build_lambda_object (lambda_expr);\n   else\n-    return error_mark_node;\n+    lambda_expr = error_mark_node;\n+\n+  cp_parser_end_tentative_firewall (parser, start, lambda_expr);\n+\n+  return lambda_expr;\n }\n \n /* Parse the beginning of a lambda expression.\n@@ -9503,7 +9606,7 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n   /* There is no statement yet.  */\n   statement = NULL_TREE;\n \n-  cp_lexer_save_tokens (parser->lexer);\n+  saved_token_sentinel saved_tokens (parser->lexer);\n   attrs_location = cp_lexer_peek_token (parser->lexer)->location;\n   if (c_dialect_objc ())\n     /* In obj-c++, seeing '[[' might be the either the beginning of\n@@ -9668,7 +9771,7 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n \t    {\n \t      /*  Attributes should be parsed as part of the the\n \t\t  declaration, so let's un-parse them.  */\n-\t      cp_lexer_rollback_tokens (parser->lexer);\n+\t      saved_tokens.rollback();\n \t      std_attrs = NULL_TREE;\n \t    }\n "}, {"sha": "40abcb99a574c67882528f6ab3583ad4faf64b73", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-sfinae1.C", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f83e90bb6f44cb079edf65b55f3caab34c42516/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-sfinae1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f83e90bb6f44cb079edf65b55f3caab34c42516/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-sfinae1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-sfinae1.C?ref=5f83e90bb6f44cb079edf65b55f3caab34c42516", "patch": "@@ -8,9 +8,9 @@ struct AddRvalueReferenceImpl { typedef T type; };\n \n template <typename T>\n struct AddRvalueReferenceImpl<T, typename BoolSink<false &&\n-      [] {\n+      [] {\t\t\t// { dg-error \"lambda\" }\n          extern T &&tref;\n-      }>::type> {\t\t// { dg-error \"lambda\" }\n+      }>::type> {\n    typedef T &&type;\n };\n \n@@ -27,9 +27,9 @@ struct IsConstructibleImpl { enum { value = 0 }; };\n \n template <typename T, typename ...Args>\n struct IsConstructibleImpl<T, typename BoolSink<false &&\n-      [] {\n+      [] {\t\t\t// { dg-error \"lambda\" }\n          T t( ::ImplHelpers::create<Args>() ...);\n-      }>::type, Args ...> {\t// { dg-error \"lambda\" }\n+      }>::type, Args ...> {\n    enum { value = 1 };\n };\n \n@@ -53,3 +53,4 @@ static_assert(+IsConstructible<int &&, int &&>::value, \"error\");\n // { dg-prune-output \"expected\" }\n // { dg-prune-output \"does not name a class\" }\n // { dg-prune-output \"static assertion\" }\n+// { dg-prune-output \"template argument . is invalid\" }"}, {"sha": "ddce40c050dcf41fd09e20cb9b3929030d32b2cf", "filename": "gcc/testsuite/g++.dg/ext/stmtexpr16.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f83e90bb6f44cb079edf65b55f3caab34c42516/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fstmtexpr16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f83e90bb6f44cb079edf65b55f3caab34c42516/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fstmtexpr16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fstmtexpr16.C?ref=5f83e90bb6f44cb079edf65b55f3caab34c42516", "patch": "@@ -0,0 +1,10 @@\n+// PR c++/63455\n+// { dg-options \"-std=gnu++11\" }\n+\n+int main()\n+{\n+    int x = 0;\n+\n+    // without '+0', gcc 4.6 gives a different error (no ICE though)\n+    decltype(({ int y = x; y; })+0) v1 = 0;\n+}"}]}