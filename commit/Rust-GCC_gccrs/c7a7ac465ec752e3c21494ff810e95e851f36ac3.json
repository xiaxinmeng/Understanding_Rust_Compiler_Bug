{"sha": "c7a7ac465ec752e3c21494ff810e95e851f36ac3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzdhN2FjNDY1ZWM3NTJlM2MyMTQ5NGZmODEwZTk1ZTg1MWYzNmFjMw==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1994-11-29T00:58:52Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1994-11-29T00:58:52Z"}, "message": "(move_by_pieces, move_by_pieces_ninsns, emit_push_insn,\n\nexpand_assignment, store_field, expand_expr): Likewise.\n(SLOW_UNALIGNED_ACCESS): Default to STRICT_ALIGNMENT, not zero.\n\nFrom-SVN: r8569", "tree": {"sha": "3f4bb84d2368d5fb7264f736502448ed27cbb28e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f4bb84d2368d5fb7264f736502448ed27cbb28e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7a7ac465ec752e3c21494ff810e95e851f36ac3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7a7ac465ec752e3c21494ff810e95e851f36ac3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7a7ac465ec752e3c21494ff810e95e851f36ac3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7a7ac465ec752e3c21494ff810e95e851f36ac3/comments", "author": null, "committer": null, "parents": [{"sha": "5970d32e6e5e2df717f834c6783f79b9e69dbbb5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5970d32e6e5e2df717f834c6783f79b9e69dbbb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5970d32e6e5e2df717f834c6783f79b9e69dbbb5"}], "stats": {"total": 21, "additions": 11, "deletions": 10}, "files": [{"sha": "d3726923f3d223bb18fda09f40f085e1be515ff3", "filename": "gcc/expr.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7a7ac465ec752e3c21494ff810e95e851f36ac3/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7a7ac465ec752e3c21494ff810e95e851f36ac3/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=c7a7ac465ec752e3c21494ff810e95e851f36ac3", "patch": "@@ -215,7 +215,7 @@ enum insn_code movstr_optab[NUM_MACHINE_MODES];\n /* SLOW_UNALIGNED_ACCESS is non-zero if unaligned accesses are very slow. */\n \n #ifndef SLOW_UNALIGNED_ACCESS\n-#define SLOW_UNALIGNED_ACCESS 0\n+#define SLOW_UNALIGNED_ACCESS STRICT_ALIGNMENT\n #endif\n \n /* Register mappings for target machines without register windows.  */\n@@ -1447,7 +1447,7 @@ move_by_pieces (to, from, len, align)\n \tdata.to_addr = copy_addr_to_reg (to_addr);\n     }\n \n-  if (! (STRICT_ALIGNMENT || SLOW_UNALIGNED_ACCESS)\n+  if (! SLOW_UNALIGNED_ACCESS\n       || align > MOVE_MAX || align >= BIGGEST_ALIGNMENT / BITS_PER_UNIT)\n     align = MOVE_MAX;\n \n@@ -1492,7 +1492,7 @@ move_by_pieces_ninsns (l, align)\n   register int n_insns = 0;\n   int max_size = MOVE_MAX + 1;\n \n-  if (! (STRICT_ALIGNMENT || SLOW_UNALIGNED_ACCESS)\n+  if (! SLOW_UNALIGNED_ACCESS\n       || align > MOVE_MAX || align >= BIGGEST_ALIGNMENT / BITS_PER_UNIT)\n     align = MOVE_MAX;\n \n@@ -2152,7 +2152,7 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t  /* Here we avoid the case of a structure whose weak alignment\n \t     forces many pushes of a small amount of data,\n \t     and such small pushes do rounding that causes trouble.  */\n-\t  && ((! STRICT_ALIGNMENT && ! SLOW_UNALIGNED_ACCESS)\n+\t  && ((! SLOW_UNALIGNED_ACCESS)\n \t      || align >= BIGGEST_ALIGNMENT / BITS_PER_UNIT\n \t      || PUSH_ROUNDING (align) == align)\n \t  && PUSH_ROUNDING (INTVAL (size)) == INTVAL (size))\n@@ -2455,7 +2455,7 @@ expand_assignment (to, from, want_value, suggest_reg)\n       || (TREE_CODE (to) == ARRAY_REF\n \t  && ((TREE_CODE (TREE_OPERAND (to, 1)) == INTEGER_CST\n \t       && TREE_CODE (TYPE_SIZE (TREE_TYPE (to))) == INTEGER_CST)\n-\t      || (STRICT_ALIGNMENT && get_inner_unaligned_p (to)))))\n+\t      || (SLOW_UNALIGNED_ACCESS && get_inner_unaligned_p (to)))))\n     {\n       enum machine_mode mode1;\n       int bitsize;\n@@ -3165,9 +3165,9 @@ store_field (target, bitsize, bitpos, mode, exp, value_mode,\n       || GET_CODE (target) == SUBREG\n       /* If the field isn't aligned enough to store as an ordinary memref,\n \t store it as a bit field.  */\n-      || (STRICT_ALIGNMENT\n+      || (SLOW_UNALIGNED_ACCESS\n \t  && align * BITS_PER_UNIT < GET_MODE_ALIGNMENT (mode))\n-      || (STRICT_ALIGNMENT && bitpos % GET_MODE_ALIGNMENT (mode) != 0))\n+      || (SLOW_UNALIGNED_ACCESS && bitpos % GET_MODE_ALIGNMENT (mode) != 0))\n     {\n       rtx temp = expand_expr (exp, NULL_RTX, VOIDmode, 0);\n \n@@ -4376,7 +4376,7 @@ expand_expr (exp, target, tmode, modifier)\n \n \tif ((TREE_CODE (index) != INTEGER_CST\n \t     || TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n-\t    && (! STRICT_ALIGNMENT || ! get_inner_unaligned_p (exp)))\n+\t    && (! SLOW_UNALIGNED_ACCESS || ! get_inner_unaligned_p (exp)))\n \t  {\n \t    /* Nonconstant array index or nonconstant element size, and\n \t       not an array in an unaligned (packed) structure field.\n@@ -4584,9 +4584,10 @@ expand_expr (exp, target, tmode, modifier)\n \t    || GET_CODE (op0) == REG || GET_CODE (op0) == SUBREG\n \t    /* If the field isn't aligned enough to fetch as a memref,\n \t       fetch it as a bit field.  */\n-\t    || (STRICT_ALIGNMENT\n+\t    || (SLOW_UNALIGNED_ACCESS\n \t\t&& TYPE_ALIGN (TREE_TYPE (tem)) < GET_MODE_ALIGNMENT (mode))\n-\t    || (STRICT_ALIGNMENT && bitpos % GET_MODE_ALIGNMENT (mode) != 0))\n+\t    || (SLOW_UNALIGNED_ACCESS\n+\t\t&& bitpos % GET_MODE_ALIGNMENT (mode) != 0))\n \t  {\n \t    enum machine_mode ext_mode = mode;\n "}]}