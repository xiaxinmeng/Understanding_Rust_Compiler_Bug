{"sha": "59d7953a634a71f09d02b37ad3031b17ade60d15", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTlkNzk1M2E2MzRhNzFmMDlkMDJiMzdhZDMwMzFiMTdhZGU2MGQxNQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2017-10-30T22:07:25Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2017-10-30T22:07:25Z"}, "message": "re PR libfortran/80850 (Sourced allocate() fails to allocate a pointer)\n\n2017-10-30  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/80850\n\t* trans_expr.c (gfc_conv_procedure_call): When passing a class\n\targument to an unlimited polymorphic dummy, it is wrong to cast\n\tthe passed expression as unlimited, unless it is unlimited. The\n\tcorrect way is to assign to each of the fields and set the _len\n\tfield to zero.\n\n2017-10-30  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/80850\n\t* gfortran.dg/class_64_f90 : New test.\n\nFrom-SVN: r254244", "tree": {"sha": "287560dcf2ccf6975fc74b2fe5662da3698f6094", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/287560dcf2ccf6975fc74b2fe5662da3698f6094"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/59d7953a634a71f09d02b37ad3031b17ade60d15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59d7953a634a71f09d02b37ad3031b17ade60d15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59d7953a634a71f09d02b37ad3031b17ade60d15", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59d7953a634a71f09d02b37ad3031b17ade60d15/comments", "author": null, "committer": null, "parents": [{"sha": "8581ce0a9d73021b110849b3992df0fc88978b6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8581ce0a9d73021b110849b3992df0fc88978b6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8581ce0a9d73021b110849b3992df0fc88978b6c"}], "stats": {"total": 91, "additions": 86, "deletions": 5}, "files": [{"sha": "99f96dd159a256795f89ac5057500b3841705a40", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59d7953a634a71f09d02b37ad3031b17ade60d15/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59d7953a634a71f09d02b37ad3031b17ade60d15/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=59d7953a634a71f09d02b37ad3031b17ade60d15", "patch": "@@ -1,6 +1,15 @@\n+2017-10-30  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/80850\n+\t* trans_expr.c (gfc_conv_procedure_call): When passing a class\n+\targument to an unlimited polymorphic dummy, it is wrong to cast\n+\tthe passed expression as unlimited, unless it is unlimited. The\n+\tcorrect way is to assign to each of the fields and set the _len\n+\tfield to zero.\n+\n 2017-10-30  Steven G. Kargl   <kargl@gcc.gnu.org>\n \n-\t* resolve.c (resolve_transfer): Set derived to correct symbol for \n+\t* resolve.c (resolve_transfer): Set derived to correct symbol for\n \tBT_CLASS.\n \n 2017-10-29  Jim Wilson  <wilson@tuliptree.org>"}, {"sha": "1a3e3d45e4cf389c8d8bb1148540b705fc16faf2", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 33, "deletions": 4, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59d7953a634a71f09d02b37ad3031b17ade60d15/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59d7953a634a71f09d02b37ad3031b17ade60d15/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=59d7953a634a71f09d02b37ad3031b17ade60d15", "patch": "@@ -5173,10 +5173,39 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t\t}\n \t\t      else\n \t\t\t{\n-\t\t\t  gfc_add_modify (&parmse.pre, var,\n-\t\t\t\t\t  fold_build1_loc (input_location,\n-\t\t\t\t\t\t\t   VIEW_CONVERT_EXPR,\n-\t\t\t\t\t\t\t   type, parmse.expr));\n+\t\t\t  /* Since the internal representation of unlimited\n+\t\t\t     polymorphic expressions includes an extra field\n+\t\t\t     that other class objects do not, a cast to the\n+\t\t\t     formal type does not work.  */\n+\t\t\t  if (!UNLIMITED_POLY (e) && UNLIMITED_POLY (fsym))\n+\t\t\t    {\n+\t\t\t      tree efield;\n+\n+\t\t\t      /* Set the _data field.  */\n+\t\t\t      tmp = gfc_class_data_get (var);\n+\t\t\t      efield = fold_convert (TREE_TYPE (tmp),\n+\t\t\t\t\tgfc_class_data_get (parmse.expr));\n+\t\t\t      gfc_add_modify (&parmse.pre, tmp, efield);\n+\n+\t\t\t      /* Set the _vptr field.  */\n+\t\t\t      tmp = gfc_class_vptr_get (var);\n+\t\t\t      efield = fold_convert (TREE_TYPE (tmp),\n+\t\t\t\t\tgfc_class_vptr_get (parmse.expr));\n+\t\t\t      gfc_add_modify (&parmse.pre, tmp, efield);\n+\n+\t\t\t      /* Set the _len field.  */\n+\t\t\t      tmp = gfc_class_len_get (var);\n+\t\t\t      gfc_add_modify (&parmse.pre, tmp,\n+\t\t\t\t\t      build_int_cst (TREE_TYPE (tmp), 0));\n+\t\t\t    }\n+\t\t\t  else\n+\t\t\t    {\n+\t\t\t      tmp = fold_build1_loc (input_location,\n+\t\t\t\t\t\t     VIEW_CONVERT_EXPR,\n+\t\t\t\t\t\t     type, parmse.expr);\n+\t\t\t      gfc_add_modify (&parmse.pre, var, tmp);\n+\t\t\t\t\t      ;\n+\t\t\t    }\n \t\t\t  parmse.expr = gfc_build_addr_expr (NULL_TREE, var);\n \t\t\t}\n \t\t    }"}, {"sha": "e17c94dc5353ac9a8255782db6d8b341ffeee6a6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59d7953a634a71f09d02b37ad3031b17ade60d15/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59d7953a634a71f09d02b37ad3031b17ade60d15/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=59d7953a634a71f09d02b37ad3031b17ade60d15", "patch": "@@ -1,3 +1,8 @@\n+2017-10-30  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/80850\n+\t* gfortran.dg/class_64_f90 : New test.\n+\n 2017-10-30  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* g++.dg/pr82725.C: Move to ..."}, {"sha": "059ebaa8a01c733a4c1dd147c1f451237896d5d5", "filename": "gcc/testsuite/gfortran.dg/class_64.f90", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59d7953a634a71f09d02b37ad3031b17ade60d15/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_64.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59d7953a634a71f09d02b37ad3031b17ade60d15/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_64.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_64.f90?ref=59d7953a634a71f09d02b37ad3031b17ade60d15", "patch": "@@ -0,0 +1,38 @@\n+! { dg-do compile }\n+! { dg-options \"-fdump-tree-original\" }\n+!\n+! Test the fix for PR80850 in which the _len field was not being\n+! set for 'arg' in the call to 'foo'.\n+!\n+  type :: mytype\n+    integer :: i\n+  end type\n+  class (mytype), pointer :: c\n+\n+  allocate (c, source = mytype (99_8))\n+\n+  call foo(c)\n+  call bar(c)\n+\n+  deallocate (c)\n+\n+contains\n+\n+  subroutine foo (arg)\n+    class(*) :: arg\n+    select type (arg)\n+      type is (mytype)\n+        if (arg%i .ne. 99_8) call abort\n+    end select\n+  end subroutine\n+\n+  subroutine bar (arg)\n+    class(mytype) :: arg\n+    select type (arg)\n+      type is (mytype)\n+        if (arg%i .ne. 99_8) call abort\n+    end select\n+  end subroutine\n+\n+end\n+! { dg-final { scan-tree-dump-times \"arg.*._len\" 1 \"original\" } }"}]}