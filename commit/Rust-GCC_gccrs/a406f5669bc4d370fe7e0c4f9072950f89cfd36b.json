{"sha": "a406f5669bc4d370fe7e0c4f9072950f89cfd36b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTQwNmY1NjY5YmM0ZDM3MGZlN2UwYzRmOTA3Mjk1MGY4OWNmZDM2Yg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2004-04-01T23:30:25Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2004-04-01T23:30:25Z"}, "message": "re PR target/14040 (ARM cross compiler: error: could not split insn)\n\n\tPR target/14040\n\t* genemit.c (gen_split): Change prototype of generated code.\n\t* genrecog.c (write_action): Adjust prototype for and calls to\n\tgen_split_*.\n\t* gensupport.c (struct queue_elem): Add split field.\n\t(queue_pattern): Return a value.  Clear the split field.\n\t(process_rtx): Maintain an association between an insn and the\n\tsplit generated from it for a define_insn_and_split.\n\t(process_one_cond_exec): Generate a new split for a\n\tdefine_insn_and_split.\n\t* config/arm/arm-protos.h (arm_split_constant): Add insn\n\tparameter.\n\t(emit_constant_insn): New function.\n\t(arm_gen_constant): Use it.\n\t* config/arm/arm.md: Adjust calls to arm_split_constant.\n\nFrom-SVN: r80335", "tree": {"sha": "800c0614ebfab133a3ab5aa61799f6bcbbd0d6ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/800c0614ebfab133a3ab5aa61799f6bcbbd0d6ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a406f5669bc4d370fe7e0c4f9072950f89cfd36b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a406f5669bc4d370fe7e0c4f9072950f89cfd36b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a406f5669bc4d370fe7e0c4f9072950f89cfd36b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a406f5669bc4d370fe7e0c4f9072950f89cfd36b/comments", "author": null, "committer": null, "parents": [{"sha": "18c6ada9b2ee27a40db256f4c32779fc25872050", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18c6ada9b2ee27a40db256f4c32779fc25872050", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18c6ada9b2ee27a40db256f4c32779fc25872050"}], "stats": {"total": 337, "additions": 233, "deletions": 104}, "files": [{"sha": "eada5df2d2d743a029262b342db0d1680f5c5872", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a406f5669bc4d370fe7e0c4f9072950f89cfd36b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a406f5669bc4d370fe7e0c4f9072950f89cfd36b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a406f5669bc4d370fe7e0c4f9072950f89cfd36b", "patch": "@@ -1,3 +1,20 @@\n+2004-04-01  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* genemit.c (gen_split): Change prototype of generated code.\n+\t* genrecog.c (write_action): Adjust prototype for and calls to\n+\tgen_split_*.\n+\t* gensupport.c (struct queue_elem): Add split field.\n+\t(queue_pattern): Return a value.  Clear the split field.\n+\t(process_rtx): Maintain an association between an insn and the\n+\tsplit generated from it for a define_insn_and_split.\n+\t(process_one_cond_exec): Generate a new split for a\n+\tdefine_insn_and_split.\n+\t* config/arm/arm-protos.h (arm_split_constant): Add insn\n+\tparameter.\n+\t(emit_constant_insn): New function.\n+\t(arm_gen_constant): Use it.\n+\t* config/arm/arm.md: Adjust calls to arm_split_constant.\n+\n 2004-04-02  Jan Hubicka  <jh@suse.cz>\n \n \t* cgraph.c: Add overall comment."}, {"sha": "437455f452dd384fe0ccfe964a991fcca72d6f3a", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a406f5669bc4d370fe7e0c4f9072950f89cfd36b/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a406f5669bc4d370fe7e0c4f9072950f89cfd36b/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=a406f5669bc4d370fe7e0c4f9072950f89cfd36b", "patch": "@@ -46,8 +46,8 @@ extern void arm_encode_call_attribute (tree, int);\n #ifdef RTX_CODE\n extern int arm_hard_regno_mode_ok (unsigned int, enum machine_mode);\n extern int const_ok_for_arm (HOST_WIDE_INT);\n-extern int arm_split_constant (RTX_CODE, enum machine_mode, HOST_WIDE_INT, rtx,\n-\t\t\t       rtx, int);\n+extern int arm_split_constant (RTX_CODE, enum machine_mode, rtx,\n+\t\t\t       HOST_WIDE_INT, rtx, rtx, int);\n extern RTX_CODE arm_canonicalize_comparison (RTX_CODE, rtx *);\n extern int legitimate_pic_operand_p (rtx);\n extern rtx legitimize_pic_address (rtx, enum machine_mode, rtx);"}, {"sha": "b16836d5d698280ab04822e111e04961c5014f45", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 135, "deletions": 74, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a406f5669bc4d370fe7e0c4f9072950f89cfd36b/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a406f5669bc4d370fe7e0c4f9072950f89cfd36b/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=a406f5669bc4d370fe7e0c4f9072950f89cfd36b", "patch": "@@ -61,8 +61,8 @@ const struct attribute_spec arm_attribute_table[];\n /* Forward function declarations.  */\n static arm_stack_offsets *arm_get_frame_offsets (void);\n static void arm_add_gc_roots (void);\n-static int arm_gen_constant (enum rtx_code, enum machine_mode, HOST_WIDE_INT,\n-\t\t\t     rtx, rtx, int, int);\n+static int arm_gen_constant (enum rtx_code, enum machine_mode, rtx,\n+\t\t\t     HOST_WIDE_INT, rtx, rtx, int, int);\n static unsigned bit_count (unsigned long);\n static int arm_address_register_rtx_p (rtx, int);\n static int arm_legitimate_index_p (enum machine_mode, rtx, RTX_CODE, int);\n@@ -140,6 +140,7 @@ static rtx safe_vector_operand (rtx, enum machine_mode);\n static rtx arm_expand_binop_builtin (enum insn_code, tree, rtx);\n static rtx arm_expand_unop_builtin (enum insn_code, tree, rtx, int);\n static rtx arm_expand_builtin (tree, rtx, rtx, enum machine_mode, int);\n+static void emit_constant_insn (rtx cond, rtx pattern);\n \n #ifdef OBJECT_FORMAT_ELF\n static void arm_elf_asm_named_section (const char *, unsigned int);\n@@ -1343,9 +1344,16 @@ const_ok_for_op (HOST_WIDE_INT i, enum rtx_code code)\n    Return value is the number of insns emitted.  */\n \n int\n-arm_split_constant (enum rtx_code code, enum machine_mode mode,\n+arm_split_constant (enum rtx_code code, enum machine_mode mode, rtx insn,\n \t\t    HOST_WIDE_INT val, rtx target, rtx source, int subtargets)\n {\n+  rtx cond;\n+\n+  if (insn && GET_CODE (PATTERN (insn)) == COND_EXEC)\n+    cond = COND_EXEC_TEST (PATTERN (insn));\n+  else\n+    cond = NULL_RTX;\n+\n   if (subtargets || code == SET\n       || (GET_CODE (target) == REG && GET_CODE (source) == REG\n \t  && REGNO (target) != REGNO (source)))\n@@ -1360,7 +1368,9 @@ arm_split_constant (enum rtx_code code, enum machine_mode mode,\n \t Ref: gcc -O1 -mcpu=strongarm gcc.c-torture/compile/980506-2.c\n       */\n       if (!after_arm_reorg\n-\t  && (arm_gen_constant (code, mode, val, target, source, 1, 0)\n+\t  && !cond\n+\t  && (arm_gen_constant (code, mode, NULL_RTX, val, target, source, \n+\t\t\t\t1, 0)\n \t      > arm_constant_limit + (code != SET)))\n \t{\n \t  if (code == SET)\n@@ -1388,7 +1398,8 @@ arm_split_constant (enum rtx_code code, enum machine_mode mode,\n \t}\n     }\n \n-  return arm_gen_constant (code, mode, val, target, source, subtargets, 1);\n+  return arm_gen_constant (code, mode, cond, val, target, source, subtargets, \n+\t\t\t   1);\n }\n \n static int\n@@ -1418,11 +1429,23 @@ count_insns_for_constant (HOST_WIDE_INT remainder, int i)\n   return num_insns;\n }\n \n+/* Emit an instruction with the indicated PATTERN.  If COND is\n+   non-NULL, conditionalize the execution of the instruction on COND\n+   being true.  */\n+\n+static void\n+emit_constant_insn (rtx cond, rtx pattern)\n+{\n+  if (cond)\n+    pattern = gen_rtx_COND_EXEC (VOIDmode, copy_rtx (cond), pattern);\n+  emit_insn (pattern);\n+}\n+\n /* As above, but extra parameter GENERATE which, if clear, suppresses\n    RTL generation.  */\n \n static int\n-arm_gen_constant (enum rtx_code code, enum machine_mode mode,\n+arm_gen_constant (enum rtx_code code, enum machine_mode mode, rtx cond,\n \t\t  HOST_WIDE_INT val, rtx target, rtx source, int subtargets,\n \t\t  int generate)\n {\n@@ -1460,16 +1483,18 @@ arm_gen_constant (enum rtx_code code, enum machine_mode mode,\n       if (remainder == 0xffffffff)\n \t{\n \t  if (generate)\n-\t    emit_insn (gen_rtx_SET (VOIDmode, target,\n-\t\t\t\t    GEN_INT (ARM_SIGN_EXTEND (val))));\n+\t    emit_constant_insn (cond,\n+\t\t\t\tgen_rtx_SET (VOIDmode, target,\n+\t\t\t\t\t     GEN_INT (ARM_SIGN_EXTEND (val))));\n \t  return 1;\n \t}\n       if (remainder == 0)\n \t{\n \t  if (reload_completed && rtx_equal_p (target, source))\n \t    return 0;\n \t  if (generate)\n-\t    emit_insn (gen_rtx_SET (VOIDmode, target, source));\n+\t    emit_constant_insn (cond,\n+\t\t\t\tgen_rtx_SET (VOIDmode, target, source));\n \t  return 1;\n \t}\n       break;\n@@ -1478,15 +1503,17 @@ arm_gen_constant (enum rtx_code code, enum machine_mode mode,\n       if (remainder == 0)\n \t{\n \t  if (generate)\n-\t    emit_insn (gen_rtx_SET (VOIDmode, target, const0_rtx));\n+\t    emit_constant_insn (cond,\n+\t\t\t\tgen_rtx_SET (VOIDmode, target, const0_rtx));\n \t  return 1;\n \t}\n       if (remainder == 0xffffffff)\n \t{\n \t  if (reload_completed && rtx_equal_p (target, source))\n \t    return 0;\n \t  if (generate)\n-\t    emit_insn (gen_rtx_SET (VOIDmode, target, source));\n+\t    emit_constant_insn (cond,\n+\t\t\t\tgen_rtx_SET (VOIDmode, target, source));\n \t  return 1;\n \t}\n       can_invert = 1;\n@@ -1498,14 +1525,16 @@ arm_gen_constant (enum rtx_code code, enum machine_mode mode,\n \t  if (reload_completed && rtx_equal_p (target, source))\n \t    return 0;\n \t  if (generate)\n-\t    emit_insn (gen_rtx_SET (VOIDmode, target, source));\n+\t    emit_constant_insn (cond,\n+\t\t\t\tgen_rtx_SET (VOIDmode, target, source));\n \t  return 1;\n \t}\n       if (remainder == 0xffffffff)\n \t{\n \t  if (generate)\n-\t    emit_insn (gen_rtx_SET (VOIDmode, target,\n-\t\t\t\t    gen_rtx_NOT (mode, source)));\n+\t    emit_constant_insn (cond,\n+\t\t\t\tgen_rtx_SET (VOIDmode, target,\n+\t\t\t\t\t     gen_rtx_NOT (mode, source)));\n \t  return 1;\n \t}\n \n@@ -1518,16 +1547,18 @@ arm_gen_constant (enum rtx_code code, enum machine_mode mode,\n       if (remainder == 0)\n \t{\n \t  if (generate)\n-\t    emit_insn (gen_rtx_SET (VOIDmode, target,\n-\t\t\t\t    gen_rtx_NEG (mode, source)));\n+\t    emit_constant_insn (cond,\n+\t\t\t\tgen_rtx_SET (VOIDmode, target,\n+\t\t\t\t\t     gen_rtx_NEG (mode, source)));\n \t  return 1;\n \t}\n       if (const_ok_for_arm (val))\n \t{\n \t  if (generate)\n-\t    emit_insn (gen_rtx_SET (VOIDmode, target, \n-\t\t\t\t    gen_rtx_MINUS (mode, GEN_INT (val),\n-\t\t\t\t\t\t   source)));\n+\t    emit_constant_insn (cond,\n+\t\t\t\tgen_rtx_SET (VOIDmode, target, \n+\t\t\t\t\t     gen_rtx_MINUS (mode, GEN_INT (val),\n+\t\t\t\t\t\t\t    source)));\n \t  return 1;\n \t}\n       can_negate = 1;\n@@ -1544,10 +1575,12 @@ arm_gen_constant (enum rtx_code code, enum machine_mode mode,\n       || (can_invert && const_ok_for_arm (~val)))\n     {\n       if (generate)\n-\temit_insn (gen_rtx_SET (VOIDmode, target,\n-\t\t\t\t(source ? gen_rtx_fmt_ee (code, mode, source,\n-\t\t\t\t\t\t   GEN_INT (val))\n-\t\t\t\t : GEN_INT (val))));\n+\temit_constant_insn (cond,\n+\t\t\t    gen_rtx_SET (VOIDmode, target,\n+\t\t\t\t\t (source \n+\t\t\t\t\t  ? gen_rtx_fmt_ee (code, mode, source,\n+\t\t\t\t\t\t\t    GEN_INT (val))\n+\t\t\t\t\t  : GEN_INT (val))));\n       return 1;\n     }\n \n@@ -1600,10 +1633,12 @@ arm_gen_constant (enum rtx_code code, enum machine_mode mode,\n \t      if (generate)\n \t\t{\n \t\t  rtx new_src = subtargets ? gen_reg_rtx (mode) : target;\n-\t\t  emit_insn (gen_rtx_SET (VOIDmode, new_src, \n-\t\t\t\t\t  GEN_INT (temp1)));\n-\t\t  emit_insn (gen_ashrsi3 (target, new_src, \n-\t\t\t\t\t  GEN_INT (set_sign_bit_copies - 1)));\n+\t\t  emit_constant_insn (cond,\n+\t\t\t\t      gen_rtx_SET (VOIDmode, new_src, \n+\t\t\t\t\t\t   GEN_INT (temp1)));\n+\t\t  emit_constant_insn (cond,\n+\t\t\t\t      gen_ashrsi3 (target, new_src, \n+\t\t\t\t\t\t   GEN_INT (set_sign_bit_copies - 1)));\n \t\t}\n \t      return 2;\n \t    }\n@@ -1615,10 +1650,12 @@ arm_gen_constant (enum rtx_code code, enum machine_mode mode,\n \t      if (generate)\n \t\t{\n \t\t  rtx new_src = subtargets ? gen_reg_rtx (mode) : target;\n-\t\t  emit_insn (gen_rtx_SET (VOIDmode, new_src,\n-\t\t\t\t\t  GEN_INT (temp1)));\n-\t\t  emit_insn (gen_ashrsi3 (target, new_src, \n-\t\t\t\t\t  GEN_INT (set_sign_bit_copies - 1)));\n+\t\t  emit_constant_insn (cond,\n+\t\t\t\t      gen_rtx_SET (VOIDmode, new_src,\n+\t\t\t\t\t\t   GEN_INT (temp1)));\n+\t\t  emit_constant_insn (cond,\n+\t\t\t\t      gen_ashrsi3 (target, new_src, \n+\t\t\t\t\t\t   GEN_INT (set_sign_bit_copies - 1)));\n \t\t}\n \t      return 2;\n \t    }\n@@ -1643,16 +1680,18 @@ arm_gen_constant (enum rtx_code code, enum machine_mode mode,\n \t\t  rtx new_src = (subtargets\n \t\t\t\t ? (generate ? gen_reg_rtx (mode) : NULL_RTX)\n \t\t\t\t : target);\n-\t\t  insns = arm_gen_constant (code, mode, temp2, new_src,\n+\t\t  insns = arm_gen_constant (code, mode, cond, temp2, new_src,\n \t\t\t\t\t    source, subtargets, generate);\n \t\t  source = new_src;\n \t\t  if (generate)\n-\t\t    emit_insn (gen_rtx_SET\n-\t\t\t       (VOIDmode, target,\n-\t\t\t\tgen_rtx_IOR (mode,\n-\t\t\t\t\t     gen_rtx_ASHIFT (mode, source,\n-\t\t\t\t\t\t\t     GEN_INT (i)),\n-\t\t\t\t\t     source)));\n+\t\t    emit_constant_insn \n+\t\t      (cond,\n+\t\t       gen_rtx_SET\n+\t\t       (VOIDmode, target,\n+\t\t\tgen_rtx_IOR (mode,\n+\t\t\t\t     gen_rtx_ASHIFT (mode, source,\n+\t\t\t\t\t\t     GEN_INT (i)),\n+\t\t\t\t     source)));\n \t\t  return insns + 1;\n \t\t}\n \t    }\n@@ -1666,12 +1705,13 @@ arm_gen_constant (enum rtx_code code, enum machine_mode mode,\n \t\t  rtx new_src = (subtargets\n \t\t\t\t ? (generate ? gen_reg_rtx (mode) : NULL_RTX)\n \t\t\t\t : target);\n-\t\t  insns = arm_gen_constant (code, mode, temp1, new_src,\n+\t\t  insns = arm_gen_constant (code, mode, cond, temp1, new_src,\n \t\t\t\t\t    source, subtargets, generate);\n \t\t  source = new_src;\n \t\t  if (generate)\n-\t\t    emit_insn\n-\t\t      (gen_rtx_SET (VOIDmode, target,\n+\t\t    emit_constant_insn\n+\t\t      (cond,\n+\t\t       gen_rtx_SET (VOIDmode, target,\n \t\t\t\t    gen_rtx_IOR\n \t\t\t\t    (mode,\n \t\t\t\t     gen_rtx_LSHIFTRT (mode, source,\n@@ -1698,9 +1738,13 @@ arm_gen_constant (enum rtx_code code, enum machine_mode mode,\n \t\t{\n \t\t  rtx sub = subtargets ? gen_reg_rtx (mode) : target;\n \n-\t\t  emit_insn (gen_rtx_SET (VOIDmode, sub, GEN_INT (val)));\n-\t\t  emit_insn (gen_rtx_SET (VOIDmode, target, \n-\t\t\t\t\t  gen_rtx_fmt_ee (code, mode, source, sub)));\n+\t\t  emit_constant_insn (cond,\n+\t\t\t\t      gen_rtx_SET (VOIDmode, sub, \n+\t\t\t\t\t\t   GEN_INT (val)));\n+\t\t  emit_constant_insn (cond,\n+\t\t\t\t      gen_rtx_SET (VOIDmode, target, \n+\t\t\t\t\t\t   gen_rtx_fmt_ee (code, mode,\n+\t\t\t\t\t\t\t\t   source, sub)));\n \t\t}\n \t      return 2;\n \t    }\n@@ -1717,15 +1761,19 @@ arm_gen_constant (enum rtx_code code, enum machine_mode mode,\n \t      rtx sub = subtargets ? gen_reg_rtx (mode) : target;\n \t      rtx shift = GEN_INT (set_sign_bit_copies);\n \n-\t      emit_insn (gen_rtx_SET (VOIDmode, sub,\n-\t\t\t\t      gen_rtx_NOT (mode, \n-\t\t\t\t\t\t   gen_rtx_ASHIFT (mode,\n-\t\t\t\t\t\t\t\t   source, \n-\t\t\t\t\t\t\t\t   shift))));\n-\t      emit_insn (gen_rtx_SET (VOIDmode, target,\n-\t\t\t\t      gen_rtx_NOT (mode,\n-\t\t\t\t\t\t   gen_rtx_LSHIFTRT (mode, sub,\n-\t\t\t\t\t\t\t\t     shift))));\n+\t      emit_constant_insn \n+\t\t(cond,\n+\t\t gen_rtx_SET (VOIDmode, sub,\n+\t\t\t      gen_rtx_NOT (mode, \n+\t\t\t\t\t   gen_rtx_ASHIFT (mode,\n+\t\t\t\t\t\t\t   source, \n+\t\t\t\t\t\t\t   shift))));\n+\t      emit_constant_insn \n+\t\t(cond,\n+\t\t gen_rtx_SET (VOIDmode, target,\n+\t\t\t      gen_rtx_NOT (mode,\n+\t\t\t\t\t   gen_rtx_LSHIFTRT (mode, sub,\n+\t\t\t\t\t\t\t     shift))));\n \t    }\n \t  return 2;\n \t}\n@@ -1738,15 +1786,19 @@ arm_gen_constant (enum rtx_code code, enum machine_mode mode,\n \t      rtx sub = subtargets ? gen_reg_rtx (mode) : target;\n \t      rtx shift = GEN_INT (set_zero_bit_copies);\n \n-\t      emit_insn (gen_rtx_SET (VOIDmode, sub,\n-\t\t\t\t      gen_rtx_NOT (mode,\n-\t\t\t\t\t\t   gen_rtx_LSHIFTRT (mode,\n-\t\t\t\t\t\t\t\t     source,\n-\t\t\t\t\t\t\t\t     shift))));\n-\t      emit_insn (gen_rtx_SET (VOIDmode, target,\n-\t\t\t\t      gen_rtx_NOT (mode,\n-\t\t\t\t\t\t   gen_rtx_ASHIFT (mode, sub,\n-\t\t\t\t\t\t\t\t   shift))));\n+\t      emit_constant_insn\n+\t\t(cond,\n+\t\t gen_rtx_SET (VOIDmode, sub,\n+\t\t\t      gen_rtx_NOT (mode,\n+\t\t\t\t\t   gen_rtx_LSHIFTRT (mode,\n+\t\t\t\t\t\t\t     source,\n+\t\t\t\t\t\t\t     shift))));\n+\t      emit_constant_insn \n+\t\t(cond,\n+\t\t gen_rtx_SET (VOIDmode, target,\n+\t\t\t      gen_rtx_NOT (mode,\n+\t\t\t\t\t   gen_rtx_ASHIFT (mode, sub,\n+\t\t\t\t\t\t\t   shift))));\n \t    }\n \t  return 2;\n \t}\n@@ -1756,16 +1808,19 @@ arm_gen_constant (enum rtx_code code, enum machine_mode mode,\n \t  if (generate)\n \t    {\n \t      rtx sub = subtargets ? gen_reg_rtx (mode) : target;\n-\t      emit_insn (gen_rtx_SET (VOIDmode, sub,\n-\t\t\t\t      gen_rtx_NOT (mode, source)));\n+\t      emit_constant_insn (cond,\n+\t\t\t\t  gen_rtx_SET (VOIDmode, sub,\n+\t\t\t\t\t       gen_rtx_NOT (mode, source)));\n \t      source = sub;\n \t      if (subtargets)\n \t\tsub = gen_reg_rtx (mode);\n-\t      emit_insn (gen_rtx_SET (VOIDmode, sub,\n-\t\t\t\t      gen_rtx_AND (mode, source, \n-\t\t\t\t\t\t   GEN_INT (temp1))));\n-\t      emit_insn (gen_rtx_SET (VOIDmode, target,\n-\t\t\t\t      gen_rtx_NOT (mode, sub)));\n+\t      emit_constant_insn (cond,\n+\t\t\t\t  gen_rtx_SET (VOIDmode, sub,\n+\t\t\t\t\t       gen_rtx_AND (mode, source, \n+\t\t\t\t\t\t\t    GEN_INT (temp1))));\n+\t      emit_constant_insn (cond,\n+\t\t\t\t  gen_rtx_SET (VOIDmode, target,\n+\t\t\t\t\t       gen_rtx_NOT (mode, sub)));\n \t    }\n \t  return 3;\n \t}\n@@ -1784,14 +1839,16 @@ arm_gen_constant (enum rtx_code code, enum machine_mode mode,\n \t      if (generate)\n \t\t{\n \t\t  rtx new_src = subtargets ? gen_reg_rtx (mode) : target;\n-\t\t  insns = arm_gen_constant (AND, mode, remainder | shift_mask,\n+\t\t  insns = arm_gen_constant (AND, mode, cond, \n+\t\t\t\t\t    remainder | shift_mask,\n \t\t\t\t\t    new_src, source, subtargets, 1);\n \t\t  source = new_src;\n \t\t}\n \t      else\n \t\t{\n \t\t  rtx targ = subtargets ? NULL_RTX : target;\n-\t\t  insns = arm_gen_constant (AND, mode, remainder | shift_mask,\n+\t\t  insns = arm_gen_constant (AND, mode, cond,\n+\t\t\t\t\t    remainder | shift_mask,\n \t\t\t\t\t    targ, source, subtargets, 0);\n \t\t}\n \t    }\n@@ -1818,15 +1875,17 @@ arm_gen_constant (enum rtx_code code, enum machine_mode mode,\n \t\t{\n \t\t  rtx new_src = subtargets ? gen_reg_rtx (mode) : target;\n \n-\t\t  insns = arm_gen_constant (AND, mode, remainder | shift_mask,\n+\t\t  insns = arm_gen_constant (AND, mode, cond,\n+\t\t\t\t\t    remainder | shift_mask,\n \t\t\t\t\t    new_src, source, subtargets, 1);\n \t\t  source = new_src;\n \t\t}\n \t      else\n \t\t{\n \t\t  rtx targ = subtargets ? NULL_RTX : target;\n \n-\t\t  insns = arm_gen_constant (AND, mode, remainder | shift_mask,\n+\t\t  insns = arm_gen_constant (AND, mode, cond,\n+\t\t\t\t\t    remainder | shift_mask,\n \t\t\t\t\t    targ, source, subtargets, 0);\n \t\t}\n \t    }\n@@ -1971,7 +2030,9 @@ arm_gen_constant (enum rtx_code code, enum machine_mode mode,\n \t\telse\n \t\t  temp1_rtx = gen_rtx_fmt_ee (code, mode, source, temp1_rtx);\n \n-\t\temit_insn (gen_rtx_SET (VOIDmode, new_src, temp1_rtx));\n+\t\temit_constant_insn (cond,\n+\t\t\t\t    gen_rtx_SET (VOIDmode, new_src, \n+\t\t\t\t\t\t temp1_rtx));\n \t\tsource = new_src;\n \t      }\n "}, {"sha": "7255b325997ee99c351b210dd0b6b367ac95f9e1", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a406f5669bc4d370fe7e0c4f9072950f89cfd36b/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a406f5669bc4d370fe7e0c4f9072950f89cfd36b/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=a406f5669bc4d370fe7e0c4f9072950f89cfd36b", "patch": "@@ -454,8 +454,8 @@\n   \"\n   if (TARGET_ARM && GET_CODE (operands[2]) == CONST_INT)\n     {\n-      arm_split_constant (PLUS, SImode, INTVAL (operands[2]), operands[0],\n-\t\t\t  operands[1],\n+      arm_split_constant (PLUS, SImode, NULL_RTX,\n+\t                  INTVAL (operands[2]), operands[0], operands[1],\n \t\t\t  (no_new_pseudos ? 0 : preserve_subexpressions_p ()));\n       DONE;\n     }\n@@ -493,7 +493,8 @@\n         || const_ok_for_arm (-INTVAL (operands[2])))\"\n   [(clobber (const_int 0))]\n   \"\n-  arm_split_constant (PLUS, SImode, INTVAL (operands[2]), operands[0],\n+  arm_split_constant (PLUS, SImode, curr_insn,\n+\t              INTVAL (operands[2]), operands[0],\n \t\t      operands[1], 0);\n   DONE;\n   \"\n@@ -940,7 +941,8 @@\n     {\n       if (TARGET_ARM)\n         {\n-          arm_split_constant (MINUS, SImode, INTVAL (operands[1]), operands[0],\n+          arm_split_constant (MINUS, SImode, NULL_RTX,\n+\t                      INTVAL (operands[1]), operands[0],\n \t  \t\t      operands[2],\n \t\t\t      (no_new_pseudos ? 0\n \t\t\t       :  preserve_subexpressions_p ()));\n@@ -974,8 +976,8 @@\n    && !const_ok_for_arm (INTVAL (operands[1]))\"\n   [(clobber (const_int 0))]\n   \"\n-  arm_split_constant (MINUS, SImode, INTVAL (operands[1]), operands[0],\n-\t\t      operands[2], 0);\n+  arm_split_constant (MINUS, SImode, curr_insn,\n+                      INTVAL (operands[1]), operands[0], operands[2], 0);\n   DONE;\n   \"\n   [(set_attr \"length\" \"4,16\")\n@@ -1516,7 +1518,8 @@\n     {\n       if (GET_CODE (operands[2]) == CONST_INT)\n         {\n-          arm_split_constant (AND, SImode, INTVAL (operands[2]), operands[0],\n+          arm_split_constant (AND, SImode, NULL_RTX,\n+\t                      INTVAL (operands[2]), operands[0],\n \t\t\t      operands[1],\n \t\t\t      (no_new_pseudos\n \t\t\t       ? 0 : preserve_subexpressions_p ()));\n@@ -1583,8 +1586,8 @@\n \t|| const_ok_for_arm (~INTVAL (operands[2])))\"\n   [(clobber (const_int 0))]\n   \"\n-  arm_split_constant  (AND, SImode, INTVAL (operands[2]), operands[0],\n-\t\t       operands[1], 0);\n+  arm_split_constant  (AND, SImode, curr_insn, \n+\t               INTVAL (operands[2]), operands[0], operands[1], 0);\n   DONE;\n   \"\n   [(set_attr \"length\" \"4,4,16\")\n@@ -2069,8 +2072,8 @@\n     {\n       if (TARGET_ARM)\n         {\n-          arm_split_constant (IOR, SImode, INTVAL (operands[2]), operands[0],\n-\t\t \t      operands[1],\n+          arm_split_constant (IOR, SImode, NULL_RTX,\n+\t                      INTVAL (operands[2]), operands[0], operands[1],\n \t\t\t      (no_new_pseudos\n \t\t\t      ? 0 : preserve_subexpressions_p ()));\n           DONE;\n@@ -2094,8 +2097,8 @@\n    && !const_ok_for_arm (INTVAL (operands[2]))\"\n   [(clobber (const_int 0))]\n   \"\n-  arm_split_constant (IOR, SImode, INTVAL (operands[2]), operands[0],\n-\t\t      operands[1], 0);\n+  arm_split_constant (IOR, SImode, curr_insn, \n+                      INTVAL (operands[2]), operands[0], operands[1], 0);\n   DONE;\n   \"\n   [(set_attr \"length\" \"4,16\")\n@@ -4146,8 +4149,8 @@\n           && !(const_ok_for_arm (INTVAL (operands[1]))\n                || const_ok_for_arm (~INTVAL (operands[1]))))\n         {\n-           arm_split_constant (SET, SImode, INTVAL (operands[1]), operands[0],\n-\t\t    \t      NULL_RTX,\n+           arm_split_constant (SET, SImode, NULL_RTX,\n+\t                       INTVAL (operands[1]), operands[0], NULL_RTX,\n \t\t\t      (no_new_pseudos ? 0\n \t\t\t       : preserve_subexpressions_p ()));\n           DONE;\n@@ -4197,8 +4200,8 @@\n         || const_ok_for_arm (~INTVAL (operands[1]))))\"\n   [(clobber (const_int 0))]\n   \"\n-  arm_split_constant (SET, SImode, INTVAL (operands[1]), operands[0],\n-\t\t      NULL_RTX, 0);\n+  arm_split_constant (SET, SImode, NULL_RTX, \n+                      INTVAL (operands[1]), operands[0], NULL_RTX, 0);\n   DONE;\n   \"\n )"}, {"sha": "c31b1fb1909824891e65681081a6cdd7c45e1372", "filename": "gcc/genemit.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a406f5669bc4d370fe7e0c4f9072950f89cfd36b/gcc%2Fgenemit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a406f5669bc4d370fe7e0c4f9072950f89cfd36b/gcc%2Fgenemit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenemit.c?ref=a406f5669bc4d370fe7e0c4f9072950f89cfd36b", "patch": "@@ -599,8 +599,9 @@ gen_split (rtx split)\n     }\n   else\n     {\n-      printf (\"extern rtx gen_split_%d (rtx *);\\n\", insn_code_number);\n-      printf (\"rtx\\ngen_%s_%d (rtx *operands%s)\\n\", name, insn_code_number, unused);\n+      printf (\"extern rtx gen_split_%d (rtx, rtx *);\\n\", insn_code_number);\n+      printf (\"rtx\\ngen_split_%d (rtx curr_insn ATTRIBUTE_UNUSED, rtx *operands%s)\\n\", \n+\t      insn_code_number, unused);\n     }\n   printf (\"{\\n\");\n "}, {"sha": "2d4c0911cd958f78a1633862c91398623d1417eb", "filename": "gcc/genrecog.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a406f5669bc4d370fe7e0c4f9072950f89cfd36b/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a406f5669bc4d370fe7e0c4f9072950f89cfd36b/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=a406f5669bc4d370fe7e0c4f9072950f89cfd36b", "patch": "@@ -2086,7 +2086,7 @@ write_action (struct decision *p, struct decision_test *test,\n \t  break;\n \n \tcase SPLIT:\n-\t  printf (\"%sreturn gen_split_%d (operands);\\n\",\n+\t  printf (\"%sreturn gen_split_%d (insn, operands);\\n\",\n \t\t  indent, test->u.insn.code_number);\n \t  break;\n \n@@ -2583,7 +2583,7 @@ make_insn_sequence (rtx insn, enum routine_type type)\n \n     case SPLIT:\n       /* Define the subroutine we will call below and emit in genemit.  */\n-      printf (\"extern rtx gen_split_%d (rtx *);\\n\", next_insn_code);\n+      printf (\"extern rtx gen_split_%d (rtx, rtx *);\\n\", next_insn_code);\n       break;\n \n     case PEEPHOLE2:"}, {"sha": "6cc957863bdd9603017ab500225167faff11e1be", "filename": "gcc/gensupport.c", "status": "modified", "additions": 54, "deletions": 7, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a406f5669bc4d370fe7e0c4f9072950f89cfd36b/gcc%2Fgensupport.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a406f5669bc4d370fe7e0c4f9072950f89cfd36b/gcc%2Fgensupport.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.c?ref=a406f5669bc4d370fe7e0c4f9072950f89cfd36b", "patch": "@@ -58,6 +58,9 @@ struct queue_elem\n   const char *filename;\n   int lineno;\n   struct queue_elem *next;\n+  /* In a DEFINE_INSN that came from a DEFINE_INSN_AND_SPLIT, SPLIT\n+     points to the generated DEFINE_SPLIT.  */\n+  struct queue_elem *split;\n };\n \n static struct queue_elem *define_attr_queue;\n@@ -69,8 +72,8 @@ static struct queue_elem **define_cond_exec_tail = &define_cond_exec_queue;\n static struct queue_elem *other_queue;\n static struct queue_elem **other_tail = &other_queue;\n \n-static void queue_pattern (rtx, struct queue_elem ***,\n-\t\t\t   const char *, int);\n+static struct queue_elem *queue_pattern (rtx, struct queue_elem ***,\n+\t\t\t\t\t const char *, int);\n \n /* Current maximum length of directory names in the search path\n    for include files.  (Altered as we get more of them.)  */\n@@ -134,9 +137,10 @@ gen_rtx_CONST_INT (enum machine_mode mode ATTRIBUTE_UNUSED,\n   return rt;\n }\n \f\n-/* Queue PATTERN on LIST_TAIL.  */\n+/* Queue PATTERN on LIST_TAIL.  Return the address of the new queue\n+   element.  */\n \n-static void\n+static struct queue_elem *\n queue_pattern (rtx pattern, struct queue_elem ***list_tail,\n \t       const char *filename, int lineno)\n {\n@@ -145,8 +149,10 @@ queue_pattern (rtx pattern, struct queue_elem ***list_tail,\n   e->filename = filename;\n   e->lineno = lineno;\n   e->next = NULL;\n+  e->split = NULL;\n   **list_tail = e;\n   *list_tail = &e->next;\n+  return e;\n }\n \n /* Recursively remove constraints from an rtx.  */\n@@ -288,6 +294,8 @@ process_rtx (rtx desc, int lineno)\n \trtx split;\n \trtvec attr;\n \tint i;\n+\tstruct queue_elem *insn_elem;\n+\tstruct queue_elem *split_elem;\n \n \t/* Create a split with values from the insn_and_split.  */\n \tsplit = rtx_alloc (DEFINE_SPLIT);\n@@ -315,8 +323,12 @@ process_rtx (rtx desc, int lineno)\n \tXVEC (desc, 4) = attr;\n \n \t/* Queue them.  */\n-\tqueue_pattern (desc, &define_insn_tail, read_rtx_filename, lineno);\n-\tqueue_pattern (split, &other_tail, read_rtx_filename, lineno);\n+\tinsn_elem\n+\t  = queue_pattern (desc, &define_insn_tail, read_rtx_filename, \n+\t\t\t   lineno);\n+\tsplit_elem\n+\t  = queue_pattern (split, &other_tail, read_rtx_filename, lineno);\n+\tinsn_elem->split = split_elem;\n \tbreak;\n       }\n \n@@ -755,7 +767,8 @@ process_one_cond_exec (struct queue_elem *ce_elem)\n   for (insn_elem = define_insn_queue; insn_elem ; insn_elem = insn_elem->next)\n     {\n       int alternatives, max_operand;\n-      rtx pred, insn, pattern;\n+      rtx pred, insn, pattern, split;\n+      int i;\n \n       if (! is_predicable (insn_elem))\n \tcontinue;\n@@ -818,6 +831,40 @@ process_one_cond_exec (struct queue_elem *ce_elem)\n \n       queue_pattern (insn, &other_tail, insn_elem->filename,\n \t\t     insn_elem->lineno);\n+\n+      if (!insn_elem->split)\n+\tcontinue;\n+\n+      /* If the original insn came from a define_insn_and_split,\n+\t generate a new split to handle the predicated insn. */\n+      split = copy_rtx (insn_elem->split->data);\n+      /* Predicate the pattern matched by the split.  */\n+      pattern = rtx_alloc (COND_EXEC);\n+      XEXP (pattern, 0) = pred;\n+      if (XVECLEN (split, 0) == 1)\n+\t{\n+\t  XEXP (pattern, 1) = XVECEXP (split, 0, 0);\n+\t  XVECEXP (split, 0, 0) = pattern;\n+\t  PUT_NUM_ELEM (XVEC (split, 0), 1);\n+\t}\n+      else\n+\t{\n+\t  XEXP (pattern, 1) = rtx_alloc (PARALLEL);\n+\t  XVEC (XEXP (pattern, 1), 0) = XVEC (split, 0);\n+\t  XVEC (split, 0) = rtvec_alloc (1);\n+\t  XVECEXP (split, 0, 0) = pattern;\n+\t}\n+      /* Predicate all of the insns generated by the split.  */\n+      for (i = 0; i < XVECLEN (split, 2); i++)\n+\t{\n+\t  pattern = rtx_alloc (COND_EXEC);\n+\t  XEXP (pattern, 0) = pred;\n+\t  XEXP (pattern, 1) = XVECEXP (split, 2, i);\n+\t  XVECEXP (split, 2, i) = pattern;\n+\t}\n+      /* Add the new split to the queue.  */\n+      queue_pattern (split, &other_tail, read_rtx_filename, \n+\t\t     insn_elem->split->lineno);\n     }\n }\n "}]}