{"sha": "8597cd335e507057e7df5dcc0c157cbd9a5bcbdd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODU5N2NkMzM1ZTUwNzA1N2U3ZGY1ZGNjMGMxNTdjYmQ5YTViY2JkZA==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel@linux.vnet.ibm.com", "date": "2017-01-05T10:00:34Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2017-01-05T10:00:34Z"}, "message": "S/390: Unroll mvc/xc loop for memset with small constant\n lengths.\n\nWhen expanding a memset we emit a loop of MVCs/XCs instructions dealing\nwith 256 byte blocks.  This loop used to get unrolled with older GCCs\nwhen using constant length operands.  GCC lost this ability probably\nwhen more of the loop unrolling stuff has been moved to tree level.\n\nWith this patch the unrolling is done manually when emitting the RTL\ninsns.\n\n2017-01-05  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n\n\t* gcc.target/s390/memset-1.c: New test.\n\ngcc/ChangeLog:\n\n2017-01-05  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n\n\t* config/s390/s390.c (s390_expand_setmem): Unroll the loop for\n\tsmall constant length operands.\n\nFrom-SVN: r244097", "tree": {"sha": "359ae5f5295cafe8d655cb920cf57715057aa482", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/359ae5f5295cafe8d655cb920cf57715057aa482"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8597cd335e507057e7df5dcc0c157cbd9a5bcbdd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8597cd335e507057e7df5dcc0c157cbd9a5bcbdd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8597cd335e507057e7df5dcc0c157cbd9a5bcbdd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8597cd335e507057e7df5dcc0c157cbd9a5bcbdd/comments", "author": null, "committer": null, "parents": [{"sha": "587790e60d22605b9b3aa73e7313cc55a6417c30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/587790e60d22605b9b3aa73e7313cc55a6417c30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/587790e60d22605b9b3aa73e7313cc55a6417c30"}], "stats": {"total": 195, "additions": 173, "deletions": 22}, "files": [{"sha": "a3e3a6a7d8b32cf2e9c0e3ef0e9d8e910ef5c272", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8597cd335e507057e7df5dcc0c157cbd9a5bcbdd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8597cd335e507057e7df5dcc0c157cbd9a5bcbdd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8597cd335e507057e7df5dcc0c157cbd9a5bcbdd", "patch": "@@ -1,3 +1,8 @@\n+2017-01-05  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n+\n+\t* config/s390/s390.c (s390_expand_setmem): Unroll the loop for\n+\tsmall constant length operands.\n+\n 2017-01-05  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n \n \t* config/s390/s390.c (s390_expand_setmem): Avoid overlapping bytes"}, {"sha": "1266f45fb1f9e3628cc57c14f7a45f7a39ad8618", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 34, "deletions": 22, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8597cd335e507057e7df5dcc0c157cbd9a5bcbdd/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8597cd335e507057e7df5dcc0c157cbd9a5bcbdd/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=8597cd335e507057e7df5dcc0c157cbd9a5bcbdd", "patch": "@@ -5348,34 +5348,46 @@ s390_expand_setmem (rtx dst, rtx len, rtx val)\n {\n   const int very_unlikely = REG_BR_PROB_BASE / 100 - 1;\n \n-  if (GET_CODE (len) == CONST_INT && INTVAL (len) == 0)\n+  if (GET_CODE (len) == CONST_INT && INTVAL (len) <= 0)\n     return;\n \n   gcc_assert (GET_CODE (val) == CONST_INT || GET_MODE (val) == QImode);\n \n-  if (GET_CODE (len) == CONST_INT && INTVAL (len) > 0 && INTVAL (len) <= 257)\n+  /* Expand setmem/clrmem for a constant length operand without a\n+     loop if it will be shorter that way.\n+     With a constant length and without pfd argument a\n+     clrmem loop is 32 bytes -> 5.3 * xc\n+     setmem loop is 36 bytes -> 3.6 * (mvi/stc + mvc) */\n+  if (GET_CODE (len) == CONST_INT\n+      && ((INTVAL (len) <= 256 * 5 && val == const0_rtx)\n+\t  || INTVAL (len) <= 257 * 3)\n+      && (!TARGET_MVCLE || INTVAL (len) <= 256))\n     {\n-      if (val == const0_rtx && INTVAL (len) <= 256)\n-        emit_insn (gen_clrmem_short (dst, GEN_INT (INTVAL (len) - 1)));\n-      else\n-\t{\n-\t  /* Initialize memory by storing the first byte.  */\n-\t  emit_move_insn (adjust_address (dst, QImode, 0), val);\n+      HOST_WIDE_INT o, l;\n \n-\t  if (INTVAL (len) > 1)\n-\t    {\n-\t      /* Initiate 1 byte overlap move.\n-\t         The first byte of DST is propagated through DSTP1.\n-\t\t Prepare a movmem for:  DST+1 = DST (length = LEN - 1).\n-\t\t DST is set to size 1 so the rest of the memory location\n-\t\t does not count as source operand.  */\n-\t      rtx dstp1 = adjust_address (dst, VOIDmode, 1);\n-\t      set_mem_size (dst, 1);\n-\n-\t      emit_insn (gen_movmem_short (dstp1, dst,\n-\t\t\t\t\t   GEN_INT (INTVAL (len) - 2)));\n-\t    }\n-\t}\n+      if (val == const0_rtx)\n+\t/* clrmem: emit 256 byte blockwise XCs.  */\n+\tfor (l = INTVAL (len), o = 0; l > 0; l -= 256, o += 256)\n+\t  {\n+\t    rtx newdst = adjust_address (dst, BLKmode, o);\n+\t    emit_insn (gen_clrmem_short (newdst,\n+\t\t\t\t\t GEN_INT (l > 256 ? 255 : l - 1)));\n+\t  }\n+      else\n+\t/* setmem: emit 1(mvi) + 256(mvc) byte blockwise memsets by\n+\t   setting first byte to val and using a 256 byte mvc with one\n+\t   byte overlap to propagate the byte.  */\n+\tfor (l = INTVAL (len), o = 0; l > 0; l -= 257, o += 257)\n+\t  {\n+\t    rtx newdst = adjust_address (dst, BLKmode, o);\n+\t    emit_move_insn (adjust_address (dst, QImode, o), val);\n+\t    if (l > 1)\n+\t      {\n+\t\trtx newdstp1 = adjust_address (dst, BLKmode, o + 1);\n+\t\temit_insn (gen_movmem_short (newdstp1, newdst,\n+\t\t\t\t\t     GEN_INT (l > 257 ? 255 : l - 2)));\n+\t      }\n+\t  }\n     }\n \n   else if (TARGET_MVCLE)"}, {"sha": "7b43b97c2085780eae26222fdd74504721e7dea7", "filename": "gcc/testsuite/gcc.target/s390/memset-1.c", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8597cd335e507057e7df5dcc0c157cbd9a5bcbdd/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fmemset-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8597cd335e507057e7df5dcc0c157cbd9a5bcbdd/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fmemset-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fmemset-1.c?ref=8597cd335e507057e7df5dcc0c157cbd9a5bcbdd", "patch": "@@ -0,0 +1,134 @@\n+/* Make sure that short memset's with constant length are emitted\n+   without loop statements.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -mzarch\" } */\n+\n+/* 1 mvc */\n+void\n+*memset1(void *s, int c)\n+{\n+  return __builtin_memset (s, c, 42);\n+}\n+\n+/* 3 mvc */\n+void\n+*memset2(void *s, int c)\n+{\n+  return __builtin_memset (s, c, 700);\n+}\n+\n+/* nop */\n+void\n+*memset3(void *s, int c)\n+{\n+  return __builtin_memset (s, c, 0);\n+}\n+\n+/* mvc */\n+void\n+*memset4(void *s, int c)\n+{\n+  return __builtin_memset (s, c, 256);\n+}\n+\n+/* 2 mvc */\n+void\n+*memset5(void *s, int c)\n+{\n+  return __builtin_memset (s, c, 512);\n+}\n+\n+/* still 2 mvc through the additional first byte  */\n+void\n+*memset6(void *s, int c)\n+{\n+  return __builtin_memset (s, c, 514);\n+}\n+\n+/* 3 mvc */\n+void\n+*memset7(void *s, int c)\n+{\n+  return __builtin_memset (s, c, 515);\n+}\n+\n+/* still 3 mvc through the additional first byte  */\n+void\n+*memset8(void *s, int c)\n+{\n+  return __builtin_memset (s, c, 771);\n+}\n+\n+/* Use mvc loop: 2 mvc */\n+void\n+*memset9(void *s, int c)\n+{\n+  return __builtin_memset (s, c, 772);\n+}\n+\n+/* 3 mvc with displacement overflow after the first */\n+void\n+*memset10(void *s, int c)\n+{\n+  return __builtin_memset ((char*)s + 4000, c, 700);\n+}\n+\n+/* 1 xc */\n+void\n+*clrmem1(void *s)\n+{\n+  return __builtin_memset (s, 0, 42);\n+}\n+\n+/* 3 xc */\n+void\n+*clrmem2(void *s)\n+{\n+  return __builtin_memset (s, 0, 700);\n+}\n+\n+/* nop */\n+void\n+*clrmem3(void *s)\n+{\n+  return __builtin_memset (s, 0, 0);\n+}\n+\n+/* 1 xc */\n+void\n+*clrmem4(void *s)\n+{\n+  return __builtin_memset (s, 0, 256);\n+}\n+\n+/* 2 xc */\n+void\n+*clrmem5(void *s)\n+{\n+  return __builtin_memset (s, 0, 512);\n+}\n+\n+/* 3 xc */\n+void\n+*clrmem6(void *s)\n+{\n+  return __builtin_memset (s, 0, 768);\n+}\n+\n+/* start using xc loop */\n+void\n+*clrmem7(void *s)\n+{\n+  return __builtin_memset (s, 0, 1281);\n+}\n+\n+/* 3 xc with displacement overflow after the first */\n+void\n+*clrmem8(void *s)\n+{\n+  return __builtin_memset (s + 4000, 0, 700);\n+}\n+\n+/* { dg-final { scan-assembler-times \"mvc\" 19 } } */\n+/* { dg-final { scan-assembler-times \"xc\" 15 } } */"}]}