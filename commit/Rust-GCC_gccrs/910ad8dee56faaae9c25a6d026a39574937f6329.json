{"sha": "910ad8dee56faaae9c25a6d026a39574937f6329", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTEwYWQ4ZGVlNTZmYWFhZTljMjVhNmQwMjZhMzk1NzQ5MzdmNjMyOQ==", "commit": {"author": {"name": "Nathan Froyd", "email": "froydnj@codesourcery.com", "date": "2010-07-15T14:31:28Z"}, "committer": {"name": "Nathan Froyd", "email": "froydnj@gcc.gnu.org", "date": "2010-07-15T14:31:28Z"}, "message": "tree.h (DECL_CHAIN): Define.\n\ngcc/\n\t* tree.h (DECL_CHAIN): Define.\n\t* alias.c: Carefully replace TREE_CHAIN with DECL_CHAIN.\n\t* c-decl.c: Likewise.\n\t* c-parser.c: Likewise.\n\t* c-typeck.c: Likewise.\n\t* cfgexpand.c: Likewise.\n\t* cgraph.c: Likewise.\n\t* cgraphunit.c: Likewise.\n\t* combine.c: Likewise.\n\t* config/alpha/alpha.c: Likewise.\n\t* config/arm/arm.c: Likewise.\n\t* config/frv/frv.c: Likewise.\n\t* config/i386/i386.c: Likewise.\n\t* config/i386/winnt-cxx.c: Likewise.\n\t* config/ia64/ia64.c: Likewise.\n\t* config/iq2000/iq2000.c: Likewise.\n\t* config/mep/mep.c: Likewise.\n\t* config/mips/mips.c: Likewise.\n\t* config/pa/som.h: Likewise.\n\t* config/rs6000/rs6000.c: Likewise.\n\t* config/s390/s390.c: Likewise.\n\t* config/sh/sh.c: Likewise.\n\t* config/sh/symbian-cxx.c: Likewise.\n\t* config/sparc/sparc.c: Likewise.\n\t* config/spu/spu.c: Likewise.\n\t* config/stormy16/stormy16.c: Likewise.\n\t* config/vxworks.c: Likewise.\n\t* config/xtensa/xtensa.c: Likewise.\n\t* coverage.c: Likewise.\n\t* dbxout.c: Likewise.\n\t* dwarf2out.c: Likewise.\n\t* emit-rtl.c: Likewise.\n\t* expr.c: Likewise.\n\t* function.c: Likewise.\n\t* gimple-low.c: Likewise.\n\t* gimple-pretty-print.c: Likewise.\n\t* gimplify.c: Likewise.\n\t* integrate.c: Likewise.\n\t* ipa-inline.c: Likewise.\n\t* ipa-prop.c: Likewise.\n\t* ipa-split.c: Likewise.\n\t* ipa-struct-reorg.c: Likewise.\n\t* ipa-type-escape.c: Likewise.\n\t* langhooks.c: Likewise.\n\t* lto-cgraph.c: Likewise.\n\t* omp-low.c: Likewise.\n\t* stor-layout.c: Likewise.\n\t* tree-cfg.c: Likewise.\n\t* tree-complex.c: Likewise.\n\t* tree-dfa.c: Likewise.\n\t* tree-dump.c: Likewise.\n\t* tree-inline.c: Likewise.\n\t* tree-mudflap.c: Likewise.\n\t* tree-nested.c: Likewise.\n\t* tree-object-size.c: Likewise.\n\t* tree-pretty-print.c: Likewise.\n\t* tree-sra.c: Likewise.\n\t* tree-ssa-live.c: Likewise.\n\t* tree-ssa-loop-niter.c: Likewise.\n\t* tree-ssa-math-opts.c: Likewise.\n\t* tree-ssa-reassoc.c: Likewise.\n\t* tree-ssa-sccvn.c: Likewise.\n\t* tree-ssa-structalias.c: Likewise.\n\t* tree-tailcall.c: Likewise.\n\t* tree-vrp.c: Likewise.\n\t* tree.c: Likewise.\n\t* var-tracking.c: Likewise.\n\t* varasm.c: Likewise.\n\ngcc/ada/\n\t* gcc-interface/decl.c: Carefully replace TREE_CHAIN with DECL_CHAIN.\n\t* gcc-interface/trans.c: Likewise.\n\t* gcc-interface/utils.c: Likewise.\n\t* gcc-interface/utils2.c: Likewise.\n\ngcc/c-family/\n\t* c-common.c: Carefully replace TREE_CHAIN with DECL_CHAIN.\n\t* c-format.c: Likewise.\n\ngcc/cp/\n\t* cp-tree.h: Carefully replace TREE_CHAIN with DECL_CHAIN.\n\t* call.c: Likewise.\n\t* class.c: Likewise.\n\t* cp-gimplify.c: Likewise.\n\t* decl.c: Likewise.\n\t* decl2.c: Likewise.\n\t* init.c: Likewise.\n\t* mangle.c: Likewise.\n\t* name-lookup.c: Likewise.\n\t* optimize.c: Likewise.\n\t* parser.c: Likewise.\n\t* pt.c: Likewise.\n\t* rtti.c: Likewise.\n\t* search.c: Likewise.\n\t* semantics.c: Likewise.\n\t* typeck.c: Likewise.\n\t* typeck2.c: Likewise.\n\ngcc/fortran/\n\t* f95-lang.c: Carefully replace TREE_CHAIN with DECL_CHAIN.\n\t* trans-common.c: Likewise.\n\t* trans-decl.c: Likewise.\n\t* trans-types.c: Likewise.\n\t* trans.c: Likewise.\n\ngcc/java/\n\t* java-tree.h: Carefully replace TREE_CHAIN with DECL_CHAIN.\n\t* boehm.c: Likewise.\n\t* class.c: Likewise.\n\t* decl.c: Likewise.\n\t* expr.c: Likewise.\n\t* jcf-parse.c: Likewise.\n\t* typeck.c: Likewise.\n\t* verify-glue.c: Likewise.\n\ngcc/objc/\n\t* objc-act.c: Carefully replace TREE_CHAIN with DECL_CHAIN.\n\ngcc/testsuite/\n\t* g++.dg/plugin/attribute_plugin.c: Carefully replace TREE_CHAIN\n\twith DECL_CHAIN.\n\nFrom-SVN: r162223", "tree": {"sha": "44ed3312376cfb15e4d1e4daef8778e326affa24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44ed3312376cfb15e4d1e4daef8778e326affa24"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/910ad8dee56faaae9c25a6d026a39574937f6329", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/910ad8dee56faaae9c25a6d026a39574937f6329", "html_url": "https://github.com/Rust-GCC/gccrs/commit/910ad8dee56faaae9c25a6d026a39574937f6329", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/910ad8dee56faaae9c25a6d026a39574937f6329/comments", "author": null, "committer": null, "parents": [{"sha": "b05027be0c8c7ff62ae4372487161b3c6ce46947", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b05027be0c8c7ff62ae4372487161b3c6ce46947", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b05027be0c8c7ff62ae4372487161b3c6ce46947"}], "stats": {"total": 1689, "additions": 911, "deletions": 778}, "files": [{"sha": "8abc3fc39cbe7673801e42c0da02828f001f6324", "filename": "gcc/ChangeLog", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -1,3 +1,74 @@\n+2010-07-15  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* tree.h (DECL_CHAIN): Define.\n+\t* alias.c: Carefully replace TREE_CHAIN with DECL_CHAIN.\n+\t* c-decl.c: Likewise.\n+\t* c-parser.c: Likewise.\n+\t* c-typeck.c: Likewise.\n+\t* cfgexpand.c: Likewise.\n+\t* cgraph.c: Likewise.\n+\t* cgraphunit.c: Likewise.\n+\t* combine.c: Likewise.\n+\t* config/alpha/alpha.c: Likewise.\n+\t* config/arm/arm.c: Likewise.\n+\t* config/frv/frv.c: Likewise.\n+\t* config/i386/i386.c: Likewise.\n+\t* config/i386/winnt-cxx.c: Likewise.\n+\t* config/ia64/ia64.c: Likewise.\n+\t* config/iq2000/iq2000.c: Likewise.\n+\t* config/mep/mep.c: Likewise.\n+\t* config/mips/mips.c: Likewise.\n+\t* config/pa/som.h: Likewise.\n+\t* config/rs6000/rs6000.c: Likewise.\n+\t* config/s390/s390.c: Likewise.\n+\t* config/sh/sh.c: Likewise.\n+\t* config/sh/symbian-cxx.c: Likewise.\n+\t* config/sparc/sparc.c: Likewise.\n+\t* config/spu/spu.c: Likewise.\n+\t* config/stormy16/stormy16.c: Likewise.\n+\t* config/vxworks.c: Likewise.\n+\t* config/xtensa/xtensa.c: Likewise.\n+\t* coverage.c: Likewise.\n+\t* dbxout.c: Likewise.\n+\t* dwarf2out.c: Likewise.\n+\t* emit-rtl.c: Likewise.\n+\t* expr.c: Likewise.\n+\t* function.c: Likewise.\n+\t* gimple-low.c: Likewise.\n+\t* gimple-pretty-print.c: Likewise.\n+\t* gimplify.c: Likewise.\n+\t* integrate.c: Likewise.\n+\t* ipa-inline.c: Likewise.\n+\t* ipa-prop.c: Likewise.\n+\t* ipa-split.c: Likewise.\n+\t* ipa-struct-reorg.c: Likewise.\n+\t* ipa-type-escape.c: Likewise.\n+\t* langhooks.c: Likewise.\n+\t* lto-cgraph.c: Likewise.\n+\t* omp-low.c: Likewise.\n+\t* stor-layout.c: Likewise.\n+\t* tree-cfg.c: Likewise.\n+\t* tree-complex.c: Likewise.\n+\t* tree-dfa.c: Likewise.\n+\t* tree-dump.c: Likewise.\n+\t* tree-inline.c: Likewise.\n+\t* tree-mudflap.c: Likewise.\n+\t* tree-nested.c: Likewise.\n+\t* tree-object-size.c: Likewise.\n+\t* tree-pretty-print.c: Likewise.\n+\t* tree-sra.c: Likewise.\n+\t* tree-ssa-live.c: Likewise.\n+\t* tree-ssa-loop-niter.c: Likewise.\n+\t* tree-ssa-math-opts.c: Likewise.\n+\t* tree-ssa-reassoc.c: Likewise.\n+\t* tree-ssa-sccvn.c: Likewise.\n+\t* tree-ssa-structalias.c: Likewise.\n+\t* tree-tailcall.c: Likewise.\n+\t* tree-vrp.c: Likewise.\n+\t* tree.c: Likewise.\n+\t* var-tracking.c: Likewise.\n+\t* varasm.c: Likewise.\n+\n 2010-07-15  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n \n \tPR target/44877"}, {"sha": "d145b668a59666f44acef3e387577eed0c0e8227", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -1,3 +1,10 @@\n+2010-07-15  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* gcc-interface/decl.c: Carefully replace TREE_CHAIN with DECL_CHAIN.\n+\t* gcc-interface/trans.c: Likewise.\n+\t* gcc-interface/utils.c: Likewise.\n+\t* gcc-interface/utils2.c: Likewise.\n+\n 2010-07-13  Laurent GUERBY  <laurent@guerby.net>\n \n         PR bootstrap/44458"}, {"sha": "54d02225e01681e1e4c7fbeb9b4c6d97b6a8e54f", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -1049,7 +1049,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t: TYPE_FIELDS (gnu_type);\n \t    VEC(constructor_elt,gc) *v = VEC_alloc (constructor_elt, gc, 1);\n \t    tree t = build_template (TREE_TYPE (template_field),\n-\t\t\t\t     TREE_TYPE (TREE_CHAIN (template_field)),\n+\t\t\t\t     TREE_TYPE (DECL_CHAIN (template_field)),\n \t\t\t\t     NULL_TREE);\n \t    CONSTRUCTOR_APPEND_ELT (v, template_field, t);\n \t    gnu_expr = gnat_build_constructor (gnu_type, v);\n@@ -1207,7 +1207,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t    && TYPE_CONTAINS_TEMPLATE_P (gnu_alloc_type))\n \t\t  {\n \t\t    gnu_alloc_type\n-\t\t      = TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (gnu_alloc_type)));\n+\t\t      = TREE_TYPE (DECL_CHAIN (TYPE_FIELDS (gnu_alloc_type)));\n \n \t\t    if (TREE_CODE (gnu_expr) == CONSTRUCTOR\n \t\t\t&& 1 == VEC_length (constructor_elt,\n@@ -1217,7 +1217,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t      gnu_expr\n \t\t\t= build_component_ref\n \t\t\t    (gnu_expr, NULL_TREE,\n-\t\t\t     TREE_CHAIN (TYPE_FIELDS (TREE_TYPE (gnu_expr))),\n+\t\t\t     DECL_CHAIN (TYPE_FIELDS (TREE_TYPE (gnu_expr))),\n \t\t\t     false);\n \t\t  }\n \n@@ -1896,7 +1896,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t   fields once we build them.  */\n \ttem = build3 (COMPONENT_REF, gnu_ptr_template,\n \t\t      build0 (PLACEHOLDER_EXPR, gnu_fat_type),\n-\t\t      TREE_CHAIN (TYPE_FIELDS (gnu_fat_type)), NULL_TREE);\n+\t\t      DECL_CHAIN (TYPE_FIELDS (gnu_fat_type)), NULL_TREE);\n \tgnu_template_reference\n \t  = build_unary_op (INDIRECT_REF, gnu_template_type, tem);\n \tTREE_READONLY (gnu_template_reference) = 1;\n@@ -2435,7 +2435,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t  gnu_field = create_field_decl (gnu_index_name, gnu_index,\n \t\t\t\t\t\t gnu_bound_rec, NULL_TREE,\n \t\t\t\t\t\t NULL_TREE, 0, 0);\n-\t\t  TREE_CHAIN (gnu_field) = gnu_field_list;\n+\t\t  DECL_CHAIN (gnu_field) = gnu_field_list;\n \t\t  gnu_field_list = gnu_field;\n \t\t}\n \n@@ -2905,7 +2905,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t      if (!is_unchecked_union)\n \t\t{\n-\t\t  TREE_CHAIN (gnu_field) = gnu_field_list;\n+\t\t  DECL_CHAIN (gnu_field) = gnu_field_list;\n \t\t  gnu_field_list = gnu_field;\n \t\t}\n \t    }\n@@ -2950,8 +2950,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    for (gnu_field = TYPE_FIELDS (gnu_type),\n \t\t gnu_std_field = TYPE_FIELDS (except_type_node);\n \t\t gnu_field;\n-\t\t gnu_field = TREE_CHAIN (gnu_field),\n-\t\t gnu_std_field = TREE_CHAIN (gnu_std_field))\n+\t\t gnu_field = DECL_CHAIN (gnu_field),\n+\t\t gnu_std_field = DECL_CHAIN (gnu_std_field))\n \t      SET_DECL_ORIGINAL_FIELD_TO_FIELD (gnu_field, gnu_std_field);\n \t    gcc_assert (!gnu_std_field);\n \t  }\n@@ -3207,7 +3207,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t    /* Put it in one of the new variants directly.  */\n \t\t    if (gnu_cont_type != gnu_type)\n \t\t      {\n-\t\t\tTREE_CHAIN (gnu_field) = TYPE_FIELDS (gnu_cont_type);\n+\t\t\tDECL_CHAIN (gnu_field) = TYPE_FIELDS (gnu_cont_type);\n \t\t\tTYPE_FIELDS (gnu_cont_type) = gnu_field;\n \t\t      }\n \n@@ -3231,7 +3231,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t       the other fields.  */\n \t\t    else\n \t\t      {\n-\t\t\tTREE_CHAIN (gnu_field) = gnu_field_list;\n+\t\t\tDECL_CHAIN (gnu_field) = gnu_field_list;\n \t\t\tgnu_field_list = gnu_field;\n \t\t\tif (!gnu_last)\n \t\t\t  gnu_last = gnu_field;\n@@ -3248,7 +3248,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t    = create_variant_part_from (gnu_variant_part,\n \t\t\t\t\t\tgnu_variant_list, gnu_type,\n \t\t\t\t\t\tgnu_pos_list, gnu_subst_list);\n-\t\t  TREE_CHAIN (new_variant_part) = gnu_field_list;\n+\t\t  DECL_CHAIN (new_variant_part) = gnu_field_list;\n \t\t  gnu_field_list = new_variant_part;\n \t\t}\n \n@@ -3520,7 +3520,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t  = create_field_decl (get_identifier (\"P_ARRAY\"),\n \t\t\t\t       gnu_ptr_array, gnu_type,\n \t\t\t\t       NULL_TREE, NULL_TREE, 0, 0);\n-\t\tTREE_CHAIN (fields)\n+\t\tDECL_CHAIN (fields)\n \t\t  = create_field_decl (get_identifier (\"P_BOUNDS\"),\n \t\t\t\t       gnu_ptr_template, gnu_type,\n \t\t\t\t       NULL_TREE, NULL_TREE, 0, 0);\n@@ -4141,7 +4141,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t       0, 0);\n \t\tSloc_to_locus (Sloc (gnat_param),\n \t\t\t       &DECL_SOURCE_LOCATION (gnu_field));\n-\t\tTREE_CHAIN (gnu_field) = gnu_field_list;\n+\t\tDECL_CHAIN (gnu_field) = gnu_field_list;\n \t\tgnu_field_list = gnu_field;\n \t\tgnu_cico_list\n \t\t  = tree_cons (gnu_field, gnu_param, gnu_cico_list);\n@@ -6140,7 +6140,7 @@ make_packable_type (tree type, bool in_record)\n   /* Now copy the fields, keeping the position and size as we don't want\n      to change the layout by propagating the packedness downwards.  */\n   for (old_field = TYPE_FIELDS (type); old_field;\n-       old_field = TREE_CHAIN (old_field))\n+       old_field = DECL_CHAIN (old_field))\n     {\n       tree new_field_type = TREE_TYPE (old_field);\n       tree new_field, new_size;\n@@ -6155,7 +6155,7 @@ make_packable_type (tree type, bool in_record)\n       /* However, for the last field in a not already packed record type\n \t that is of an aggregate type, we need to use the RM size in the\n \t packable version of the record type, see finish_record_type.  */\n-      if (!TREE_CHAIN (old_field)\n+      if (!DECL_CHAIN (old_field)\n \t  && !TYPE_PACKED (type)\n \t  && (TREE_CODE (new_field_type) == RECORD_TYPE\n \t      || TREE_CODE (new_field_type) == UNION_TYPE\n@@ -6178,7 +6178,7 @@ make_packable_type (tree type, bool in_record)\n       if (TREE_CODE (new_type) == QUAL_UNION_TYPE)\n \tDECL_QUALIFIER (new_field) = DECL_QUALIFIER (old_field);\n \n-      TREE_CHAIN (new_field) = field_list;\n+      DECL_CHAIN (new_field) = field_list;\n       field_list = new_field;\n     }\n \n@@ -6831,7 +6831,7 @@ is_variable_size (tree type)\n       && TREE_CODE (type) != QUAL_UNION_TYPE)\n     return false;\n \n-  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+  for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n     if (is_variable_size (TREE_TYPE (field)))\n       return true;\n \n@@ -6929,14 +6929,14 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \t       fields except for the _Tag or _Parent field.  */\n \t    else if (gnat_name == Name_uController && gnu_last)\n \t      {\n-\t\tTREE_CHAIN (gnu_field) = TREE_CHAIN (gnu_last);\n-\t\tTREE_CHAIN (gnu_last) = gnu_field;\n+\t\tDECL_CHAIN (gnu_field) = DECL_CHAIN (gnu_last);\n+\t\tDECL_CHAIN (gnu_last) = gnu_field;\n \t      }\n \n \t    /* If this is a regular field, put it after the other fields.  */\n \t    else\n \t      {\n-\t\tTREE_CHAIN (gnu_field) = gnu_field_list;\n+\t\tDECL_CHAIN (gnu_field) = gnu_field_list;\n \t\tgnu_field_list = gnu_field;\n \t\tif (!gnu_last)\n \t\t  gnu_last = gnu_field;\n@@ -7035,7 +7035,7 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \t     use this field directly to match the layout of C unions.  */\n \t  if (unchecked_union\n \t      && TYPE_FIELDS (gnu_variant_type)\n-\t      && !TREE_CHAIN (TYPE_FIELDS (gnu_variant_type)))\n+\t      && !DECL_CHAIN (TYPE_FIELDS (gnu_variant_type)))\n \t    gnu_field = TYPE_FIELDS (gnu_variant_type);\n \t  else\n \t    {\n@@ -7067,7 +7067,7 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \t\tDECL_QUALIFIER (gnu_field) = gnu_qual;\n \t    }\n \n-\t  TREE_CHAIN (gnu_field) = gnu_variant_list;\n+\t  DECL_CHAIN (gnu_field) = gnu_variant_list;\n \t  gnu_variant_list = gnu_field;\n \t}\n \n@@ -7111,7 +7111,7 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \t\t\t\t union_field_packed, 0);\n \n \t  DECL_INTERNAL_P (gnu_union_field) = 1;\n-\t  TREE_CHAIN (gnu_union_field) = gnu_field_list;\n+\t  DECL_CHAIN (gnu_union_field) = gnu_field_list;\n \t  gnu_field_list = gnu_union_field;\n \t}\n     }\n@@ -7126,16 +7126,16 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n   gnu_last = NULL_TREE;\n   for (gnu_field = gnu_field_list; gnu_field; gnu_field = gnu_next)\n     {\n-      gnu_next = TREE_CHAIN (gnu_field);\n+      gnu_next = DECL_CHAIN (gnu_field);\n \n       if (DECL_FIELD_OFFSET (gnu_field))\n \t{\n \t  if (!gnu_last)\n \t    gnu_field_list = gnu_next;\n \t  else\n-\t    TREE_CHAIN (gnu_last) = gnu_next;\n+\t    DECL_CHAIN (gnu_last) = gnu_next;\n \n-\t  TREE_CHAIN (gnu_field) = gnu_our_rep_list;\n+\t  DECL_CHAIN (gnu_field) = gnu_our_rep_list;\n \t  gnu_our_rep_list = gnu_field;\n \t}\n       else\n@@ -7159,7 +7159,7 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \n       for (gnu_field = gnu_our_rep_list, i = 0;\n \t   gnu_field;\n-\t   gnu_field = TREE_CHAIN (gnu_field), i++)\n+\t   gnu_field = DECL_CHAIN (gnu_field), i++)\n \tgnu_arr[i] = gnu_field;\n \n       qsort (gnu_arr, len, sizeof (tree), compare_field_bitpos);\n@@ -7169,7 +7169,7 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n       gnu_our_rep_list = NULL_TREE;\n       for (i = len - 1; i >= 0; i--)\n \t{\n-\t  TREE_CHAIN (gnu_arr[i]) = gnu_our_rep_list;\n+\t  DECL_CHAIN (gnu_arr[i]) = gnu_our_rep_list;\n \t  gnu_our_rep_list = gnu_arr[i];\n \t  DECL_CONTEXT (gnu_arr[i]) = gnu_rep_type;\n \t}\n@@ -7353,7 +7353,7 @@ annotate_object (Entity_Id gnat_entity, tree gnu_type, tree size, bool by_ref)\n     {\n       if (TREE_CODE (gnu_type) == RECORD_TYPE\n \t  && TYPE_CONTAINS_TEMPLATE_P (gnu_type))\n-\tsize = TYPE_SIZE (TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (gnu_type))));\n+\tsize = TYPE_SIZE (TREE_TYPE (DECL_CHAIN (TYPE_FIELDS (gnu_type))));\n       else if (!size)\n \tsize = TYPE_SIZE (gnu_type);\n \n@@ -7469,7 +7469,7 @@ build_position_list (tree gnu_type, bool do_not_flatten_variant, tree gnu_pos,\n \n   for (gnu_field = TYPE_FIELDS (gnu_type);\n        gnu_field;\n-       gnu_field = TREE_CHAIN (gnu_field))\n+       gnu_field = DECL_CHAIN (gnu_field))\n     {\n       tree gnu_our_bitpos = size_binop (PLUS_EXPR, gnu_bitpos,\n \t\t\t\t\tDECL_FIELD_BIT_OFFSET (gnu_field));\n@@ -7555,7 +7555,7 @@ build_variant_list (tree qual_union_type, tree subst_list, tree gnu_list)\n \n   for (gnu_field = TYPE_FIELDS (qual_union_type);\n        gnu_field;\n-       gnu_field = TREE_CHAIN (gnu_field))\n+       gnu_field = DECL_CHAIN (gnu_field))\n     {\n       tree t, qual = DECL_QUALIFIER (gnu_field);\n \n@@ -8292,7 +8292,7 @@ get_variant_part (tree record_type)\n   tree field;\n \n   /* The variant part is the only internal field that is a qualified union.  */\n-  for (field = TYPE_FIELDS (record_type); field; field = TREE_CHAIN (field))\n+  for (field = TYPE_FIELDS (record_type); field; field = DECL_CHAIN (field))\n     if (DECL_INTERNAL_P (field)\n \t&& TREE_CODE (TREE_TYPE (field)) == QUAL_UNION_TYPE)\n       return field;\n@@ -8363,7 +8363,7 @@ create_variant_part_from (tree old_variant_part, tree variant_list,\n \t  tree new_variant_subpart\n \t    = create_variant_part_from (old_variant_subpart, variant_list,\n \t\t\t\t\tnew_variant, pos_list, subst_list);\n-\t  TREE_CHAIN (new_variant_subpart) = field_list;\n+\t  DECL_CHAIN (new_variant_subpart) = field_list;\n \t  field_list = new_variant_subpart;\n \t}\n \n@@ -8380,7 +8380,7 @@ create_variant_part_from (tree old_variant_part, tree variant_list,\n \t\t\t\t  pos_list, subst_list);\n       DECL_QUALIFIER (new_field) = TREE_VEC_ELT (TREE_VALUE (t), 1);\n       DECL_INTERNAL_P (new_field) = 1;\n-      TREE_CHAIN (new_field) = union_field_list;\n+      DECL_CHAIN (new_field) = union_field_list;\n       union_field_list = new_field;\n     }\n \n@@ -8401,7 +8401,7 @@ create_variant_part_from (tree old_variant_part, tree variant_list,\n      statically selected while outer ones are not; in this case, the list\n      of fields of the inner variant is not flattened and we end up with a\n      qualified union with a single member.  Drop the useless container.  */\n-  if (!TREE_CHAIN (union_field_list))\n+  if (!DECL_CHAIN (union_field_list))\n     {\n       DECL_CONTEXT (union_field_list) = record_type;\n       DECL_FIELD_OFFSET (union_field_list)\n@@ -8566,7 +8566,7 @@ substitute_in_type (tree t, tree f, tree r)\n \tnt = copy_type (t);\n \tTYPE_FIELDS (nt) = NULL_TREE;\n \n-\tfor (field = TYPE_FIELDS (t); field; field = TREE_CHAIN (field))\n+\tfor (field = TYPE_FIELDS (t); field; field = DECL_CHAIN (field))\n \t  {\n \t    tree new_field = copy_node (field), new_n;\n \n@@ -8598,7 +8598,7 @@ substitute_in_type (tree t, tree f, tree r)\n \t    DECL_CONTEXT (new_field) = nt;\n \t    SET_DECL_ORIGINAL_FIELD_TO_FIELD (new_field, field);\n \n-\t    TREE_CHAIN (new_field) = TYPE_FIELDS (nt);\n+\t    DECL_CHAIN (new_field) = TYPE_FIELDS (nt);\n \t    TYPE_FIELDS (nt) = new_field;\n \t  }\n \n@@ -8632,7 +8632,7 @@ rm_size (tree gnu_type)\n       && TYPE_CONTAINS_TEMPLATE_P (gnu_type))\n     return\n       size_binop (PLUS_EXPR,\n-\t\t  rm_size (TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (gnu_type)))),\n+\t\t  rm_size (TREE_TYPE (DECL_CHAIN (TYPE_FIELDS (gnu_type)))),\n \t\t  DECL_SIZE (TYPE_FIELDS (gnu_type)));\n \n   /* For record types, we store the size explicitly.  */"}, {"sha": "4bf89477d0dc5989814c886e815944202336e4d1", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -7362,7 +7362,7 @@ extract_values (tree values, tree record_type)\n   tree field, tem;\n   VEC(constructor_elt,gc) *v = NULL;\n \n-  for (field = TYPE_FIELDS (record_type); field; field = TREE_CHAIN (field))\n+  for (field = TYPE_FIELDS (record_type); field; field = DECL_CHAIN (field))\n     {\n       tree value = 0;\n "}, {"sha": "de0d25c4841e96ee9b4e22e04b453069fe19947a", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -461,7 +461,7 @@ gnat_pushdecl (tree decl, Node_Id gnat_node)\n \t}\n       else\n \t{\n-\t  TREE_CHAIN (decl) = BLOCK_VARS (current_binding_level->block);\n+\t  DECL_CHAIN (decl) = BLOCK_VARS (current_binding_level->block);\n \t  BLOCK_VARS (current_binding_level->block) = decl;\n \t}\n     }\n@@ -589,7 +589,7 @@ finish_record_type (tree record_type, tree field_list, int rep_level,\n   if (code == QUAL_UNION_TYPE)\n     field_list = nreverse (field_list);\n \n-  for (field = field_list; field; field = TREE_CHAIN (field))\n+  for (field = field_list; field; field = DECL_CHAIN (field))\n     {\n       tree type = TREE_TYPE (field);\n       tree pos = bit_position (field);\n@@ -741,7 +741,7 @@ rest_of_record_type_compilation (tree record_type)\n   enum tree_code code = TREE_CODE (record_type);\n   bool var_size = false;\n \n-  for (field = field_list; field; field = TREE_CHAIN (field))\n+  for (field = field_list; field; field = DECL_CHAIN (field))\n     {\n       /* We need to make an XVE/XVU record if any field has variable size,\n \t whether or not the record does.  For example, if we have a union,\n@@ -795,7 +795,7 @@ rest_of_record_type_compilation (tree record_type)\n       /* Now scan all the fields, replacing each field with a new\n \t field corresponding to the new encoding.  */\n       for (old_field = TYPE_FIELDS (record_type); old_field;\n-\t   old_field = TREE_CHAIN (old_field))\n+\t   old_field = DECL_CHAIN (old_field))\n \t{\n \t  tree field_type = TREE_TYPE (old_field);\n \t  tree field_name = DECL_NAME (old_field);\n@@ -911,7 +911,7 @@ rest_of_record_type_compilation (tree record_type)\n \t  new_field\n \t    = create_field_decl (field_name, field_type, new_record_type,\n \t\t\t\t DECL_SIZE (old_field), pos, 0, 0);\n-\t  TREE_CHAIN (new_field) = TYPE_FIELDS (new_record_type);\n+\t  DECL_CHAIN (new_field) = TYPE_FIELDS (new_record_type);\n \t  TYPE_FIELDS (new_record_type) = new_field;\n \n \t  /* If old_field is a QUAL_UNION_TYPE, take its size as being\n@@ -1079,7 +1079,7 @@ create_subprog_type (tree return_type, tree param_decl_list, tree cico_list,\n   tree param_type_list = NULL_TREE;\n   tree t, type;\n \n-  for (t = param_decl_list; t; t = TREE_CHAIN (t))\n+  for (t = param_decl_list; t; t = DECL_CHAIN (t))\n     param_type_list = tree_cons (NULL_TREE, TREE_TYPE (t), param_type_list);\n \n   /* The list of the function parameter types has to be terminated by the void\n@@ -1416,7 +1416,7 @@ aggregate_type_contains_array_p (tree type)\n     case QUAL_UNION_TYPE:\n       {\n \ttree field;\n-\tfor (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+\tfor (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n \t  if (AGGREGATE_TYPE_P (TREE_TYPE (field))\n \t      && aggregate_type_contains_array_p (TREE_TYPE (field)))\n \t    return true;\n@@ -1860,7 +1860,7 @@ begin_subprog_body (tree subprog_decl)\n   gnat_pushlevel ();\n \n   for (param_decl = DECL_ARGUMENTS (subprog_decl); param_decl;\n-       param_decl = TREE_CHAIN (param_decl))\n+       param_decl = DECL_CHAIN (param_decl))\n     DECL_CONTEXT (param_decl) = subprog_decl;\n \n   make_decl_rtl (subprog_decl);\n@@ -2246,7 +2246,7 @@ build_template (tree template_type, tree array_type, tree expr)\n        (bound_list\n \t? (bound_list = TREE_CHAIN (bound_list))\n \t: (array_type = TREE_TYPE (array_type))),\n-       field = TREE_CHAIN (TREE_CHAIN (field)))\n+       field = DECL_CHAIN (DECL_CHAIN (field)))\n     {\n       tree bounds, min, max;\n \n@@ -2265,15 +2265,15 @@ build_template (tree template_type, tree array_type, tree expr)\n \tgcc_unreachable ();\n \n       min = convert (TREE_TYPE (field), TYPE_MIN_VALUE (bounds));\n-      max = convert (TREE_TYPE (TREE_CHAIN (field)), TYPE_MAX_VALUE (bounds));\n+      max = convert (TREE_TYPE (DECL_CHAIN (field)), TYPE_MAX_VALUE (bounds));\n \n       /* If either MIN or MAX involve a PLACEHOLDER_EXPR, we must\n \t substitute it from OBJECT.  */\n       min = SUBSTITUTE_PLACEHOLDER_IN_EXPR (min, expr);\n       max = SUBSTITUTE_PLACEHOLDER_IN_EXPR (max, expr);\n \n       CONSTRUCTOR_APPEND_ELT (template_elts, field, min);\n-      CONSTRUCTOR_APPEND_ELT (template_elts, TREE_CHAIN (field), max);\n+      CONSTRUCTOR_APPEND_ELT (template_elts, DECL_CHAIN (field), max);\n     }\n \n   return gnat_build_constructor (template_type, template_elts);\n@@ -2929,9 +2929,9 @@ convert_vms_descriptor64 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n   tree desc_type = TREE_TYPE (TREE_TYPE (gnu_expr));\n   tree desc = build1 (INDIRECT_REF, desc_type, gnu_expr);\n   /* The CLASS field is the 3rd field in the descriptor.  */\n-  tree klass = TREE_CHAIN (TREE_CHAIN (TYPE_FIELDS (desc_type)));\n+  tree klass = DECL_CHAIN (DECL_CHAIN (TYPE_FIELDS (desc_type)));\n   /* The POINTER field is the 6th field in the descriptor.  */\n-  tree pointer = TREE_CHAIN (TREE_CHAIN (TREE_CHAIN (klass)));\n+  tree pointer = DECL_CHAIN (DECL_CHAIN (DECL_CHAIN (klass)));\n \n   /* Retrieve the value of the POINTER field.  */\n   tree gnu_expr64\n@@ -2962,7 +2962,7 @@ convert_vms_descriptor64 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n \tcase 15: /* Class SB */\n \t  /* Build {1, LENGTH} template; LENGTH64 is the 5th field.  */\n \t  v = VEC_alloc (constructor_elt, gc, 2);\n-\t  t = TREE_CHAIN (TREE_CHAIN (klass));\n+\t  t = DECL_CHAIN (DECL_CHAIN (klass));\n \t  t = build3 (COMPONENT_REF, TREE_TYPE (t), desc, t, NULL_TREE);\n \t  CONSTRUCTOR_APPEND_ELT (v, min_field,\n \t\t\t\t  convert (TREE_TYPE (min_field),\n@@ -2990,7 +2990,7 @@ convert_vms_descriptor64 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n \t  t = TREE_CHAIN (t);\n           ufield = build3 (COMPONENT_REF, TREE_TYPE (t), desc, t, NULL_TREE);\n           ufield = convert\n-           (TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (template_type))), ufield);\n+           (TREE_TYPE (DECL_CHAIN (TYPE_FIELDS (template_type))), ufield);\n \n \t  /* Build the template in the form of a constructor. */\n \t  v = VEC_alloc (constructor_elt, gc, 2);\n@@ -3009,7 +3009,7 @@ convert_vms_descriptor64 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n \tcase 4:  /* Class A */\n \t  /* The AFLAGS field is the 3rd field after the pointer in the\n              descriptor.  */\n-\t  t = TREE_CHAIN (TREE_CHAIN (TREE_CHAIN (pointer)));\n+\t  t = DECL_CHAIN (DECL_CHAIN (DECL_CHAIN (pointer)));\n \t  aflags = build3 (COMPONENT_REF, TREE_TYPE (t), desc, t, NULL_TREE);\n \t  /* The DIMCT field is the next field in the descriptor after\n              aflags.  */\n@@ -3030,20 +3030,20 @@ convert_vms_descriptor64 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n \t\t\t\t\t\tu));\n \t  /* There is already a template in the descriptor and it is located\n              in block 3.  The fields are 64bits so they must be repacked. */\n-\t  t = TREE_CHAIN (TREE_CHAIN (TREE_CHAIN (TREE_CHAIN (TREE_CHAIN\n+\t  t = DECL_CHAIN (DECL_CHAIN (DECL_CHAIN (DECL_CHAIN (DECL_CHAIN\n               (t)))));\n           lfield = build3 (COMPONENT_REF, TREE_TYPE (t), desc, t, NULL_TREE);\n           lfield = convert (TREE_TYPE (TYPE_FIELDS (template_type)), lfield);\n \n \t  t = TREE_CHAIN (t);\n           ufield = build3 (COMPONENT_REF, TREE_TYPE (t), desc, t, NULL_TREE);\n           ufield = convert\n-           (TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (template_type))), ufield);\n+           (TREE_TYPE (DECL_CHAIN (TYPE_FIELDS (template_type))), ufield);\n \n \t  /* Build the template in the form of a constructor. */\n \t  v = VEC_alloc (constructor_elt, gc, 2);\n \t  CONSTRUCTOR_APPEND_ELT (v, TYPE_FIELDS (template_type), lfield);\n-\t  CONSTRUCTOR_APPEND_ELT (v, TREE_CHAIN (TYPE_FIELDS (template_type)),\n+\t  CONSTRUCTOR_APPEND_ELT (v, DECL_CHAIN (TYPE_FIELDS (template_type)),\n \t\t\t\t  ufield);\n \t  template_tree = gnat_build_constructor (template_type, v);\n \t  template_tree = build3 (COND_EXPR, template_type, u,\n@@ -3064,7 +3064,7 @@ convert_vms_descriptor64 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n       /* Build the fat pointer in the form of a constructor.  */\n       v = VEC_alloc (constructor_elt, gc, 2);\n       CONSTRUCTOR_APPEND_ELT (v, TYPE_FIELDS (gnu_type), gnu_expr64);\n-      CONSTRUCTOR_APPEND_ELT (v, TREE_CHAIN (TYPE_FIELDS (gnu_type)),\n+      CONSTRUCTOR_APPEND_ELT (v, DECL_CHAIN (TYPE_FIELDS (gnu_type)),\n \t\t\t      template_addr);\n       return gnat_build_constructor (gnu_type, v);\n     }\n@@ -3083,9 +3083,9 @@ convert_vms_descriptor32 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n   tree desc_type = TREE_TYPE (TREE_TYPE (gnu_expr));\n   tree desc = build1 (INDIRECT_REF, desc_type, gnu_expr);\n   /* The CLASS field is the 3rd field in the descriptor.  */\n-  tree klass = TREE_CHAIN (TREE_CHAIN (TYPE_FIELDS (desc_type)));\n+  tree klass = DECL_CHAIN (DECL_CHAIN (TYPE_FIELDS (desc_type)));\n   /* The POINTER field is the 4th field in the descriptor.  */\n-  tree pointer = TREE_CHAIN (klass);\n+  tree pointer = DECL_CHAIN (klass);\n \n   /* Retrieve the value of the POINTER field.  */\n   tree gnu_expr32\n@@ -3147,7 +3147,7 @@ convert_vms_descriptor32 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n \n \tcase 4:  /* Class A */\n \t  /* The AFLAGS field is the 7th field in the descriptor.  */\n-\t  t = TREE_CHAIN (TREE_CHAIN (TREE_CHAIN (pointer)));\n+\t  t = DECL_CHAIN (DECL_CHAIN (DECL_CHAIN (pointer)));\n \t  aflags = build3 (COMPONENT_REF, TREE_TYPE (t), desc, t, NULL_TREE);\n \t  /* The DIMCT field is the 8th field in the descriptor.  */\n \t  t = TREE_CHAIN (t);\n@@ -3167,7 +3167,7 @@ convert_vms_descriptor32 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n \t\t\t\t\t\tu));\n \t  /* There is already a template in the descriptor and it is\n \t     located at the start of block 3 (12th field).  */\n-\t  t = TREE_CHAIN (TREE_CHAIN (TREE_CHAIN (TREE_CHAIN (t))));\n+\t  t = DECL_CHAIN (DECL_CHAIN (DECL_CHAIN (DECL_CHAIN (t))));\n \t  template_tree\n \t    = build3 (COMPONENT_REF, TREE_TYPE (t), desc, t, NULL_TREE);\n \t  template_tree = build3 (COND_EXPR, TREE_TYPE (t), u,\n@@ -3188,7 +3188,7 @@ convert_vms_descriptor32 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n       /* Build the fat pointer in the form of a constructor.  */\n       v = VEC_alloc (constructor_elt, gc, 2);\n       CONSTRUCTOR_APPEND_ELT (v, TYPE_FIELDS (gnu_type), gnu_expr32);\n-      CONSTRUCTOR_APPEND_ELT (v, TREE_CHAIN (TYPE_FIELDS (gnu_type)),\n+      CONSTRUCTOR_APPEND_ELT (v, DECL_CHAIN (TYPE_FIELDS (gnu_type)),\n \t\t\t      template_addr);\n \n       return gnat_build_constructor (gnu_type, v);\n@@ -3211,7 +3211,7 @@ convert_vms_descriptor (tree gnu_type, tree gnu_expr, tree gnu_expr_alt_type,\n   tree desc = build1 (INDIRECT_REF, desc_type, gnu_expr);\n   tree mbo = TYPE_FIELDS (desc_type);\n   const char *mbostr = IDENTIFIER_POINTER (DECL_NAME (mbo));\n-  tree mbmo = TREE_CHAIN (TREE_CHAIN (TREE_CHAIN (mbo)));\n+  tree mbmo = DECL_CHAIN (DECL_CHAIN (DECL_CHAIN (mbo)));\n   tree is64bit, gnu_expr32, gnu_expr64;\n \n   /* If the field name is not MBO, it must be 32-bit and no alternate.\n@@ -3321,7 +3321,7 @@ build_unc_object_type (tree template_type, tree object_type, tree name,\n \n   TYPE_NAME (type) = name;\n   TYPE_CONTAINS_TEMPLATE_P (type) = 1;\n-  TREE_CHAIN (template_field) = array_field;\n+  DECL_CHAIN (template_field) = array_field;\n   finish_record_type (type, template_field, 0, true);\n \n   /* Declare it now since it will never be declared otherwise.  This is\n@@ -3343,7 +3343,7 @@ build_unc_object_type_from_ptr (tree thin_fat_ptr_type, tree object_type,\n \n   template_type\n     = (TYPE_IS_FAT_POINTER_P (thin_fat_ptr_type)\n-       ? TREE_TYPE (TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (thin_fat_ptr_type))))\n+       ? TREE_TYPE (TREE_TYPE (DECL_CHAIN (TYPE_FIELDS (thin_fat_ptr_type))))\n        : TREE_TYPE (TYPE_FIELDS (TREE_TYPE (thin_fat_ptr_type))));\n \n   return\n@@ -3362,7 +3362,7 @@ shift_unc_components_for_thin_pointers (tree type)\n      that COMPONENT_REFs on (*thin_ptr) designate the proper location.  */\n \n   tree bounds_field = TYPE_FIELDS (type);\n-  tree array_field  = TREE_CHAIN (TYPE_FIELDS (type));\n+  tree array_field  = DECL_CHAIN (TYPE_FIELDS (type));\n \n   DECL_FIELD_OFFSET (bounds_field)\n     = size_binop (MINUS_EXPR, size_zero_node, byte_position (array_field));\n@@ -3481,12 +3481,12 @@ update_pointer_to (tree old_type, tree new_type)\n \treturn;\n \n       array_field = TYPE_FIELDS (ptr);\n-      bounds_field = TREE_CHAIN (array_field);\n+      bounds_field = DECL_CHAIN (array_field);\n \n       /* Make pointers to the dummy template point to the real template.  */\n       update_pointer_to\n \t(TREE_TYPE (TREE_TYPE (bounds_field)),\n-\t TREE_TYPE (TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (new_ptr)))));\n+\t TREE_TYPE (TREE_TYPE (DECL_CHAIN (TYPE_FIELDS (new_ptr)))));\n \n       /* The references to the template bounds present in the array type use\n \t the bounds field of NEW_PTR through a PLACEHOLDER_EXPR.  Since we\n@@ -3501,7 +3501,7 @@ update_pointer_to (tree old_type, tree new_type)\n       update_pointer_to\n \t(TREE_TYPE (TREE_TYPE (array_field)),\n \t substitute_in_type (TREE_TYPE (TREE_TYPE (TYPE_FIELDS (new_ptr))),\n-\t\t\t     TREE_CHAIN (TYPE_FIELDS (new_ptr)), new_ref));\n+\t\t\t     DECL_CHAIN (TYPE_FIELDS (new_ptr)), new_ref));\n \n       /* Merge PTR in NEW_PTR.  */\n       DECL_FIELD_CONTEXT (array_field) = new_ptr;\n@@ -3532,15 +3532,15 @@ update_pointer_to (tree old_type, tree new_type)\n \t points to.  Update all pointers from the old record into the new\n \t one, update the type of the array field, and recompute the size.  */\n       update_pointer_to (TYPE_OBJECT_RECORD_TYPE (old_type), new_obj_rec);\n-      TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (new_obj_rec)))\n+      TREE_TYPE (DECL_CHAIN (TYPE_FIELDS (new_obj_rec)))\n \t= TREE_TYPE (TREE_TYPE (array_field));\n \n       /* The size recomputation needs to account for alignment constraints, so\n \t we let layout_type work it out.  This will reset the field offsets to\n \t what they would be in a regular record, so we shift them back to what\n \t we want them to be for a thin pointer designated type afterwards.  */\n       DECL_SIZE (TYPE_FIELDS (new_obj_rec)) = NULL_TREE;\n-      DECL_SIZE (TREE_CHAIN (TYPE_FIELDS (new_obj_rec))) = NULL_TREE;\n+      DECL_SIZE (DECL_CHAIN (TYPE_FIELDS (new_obj_rec))) = NULL_TREE;\n       TYPE_SIZE (new_obj_rec) = NULL_TREE;\n       layout_type (new_obj_rec);\n       shift_unc_components_for_thin_pointers (new_obj_rec);\n@@ -3556,7 +3556,7 @@ update_pointer_to (tree old_type, tree new_type)\n static tree\n convert_to_fat_pointer (tree type, tree expr)\n {\n-  tree template_type = TREE_TYPE (TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (type))));\n+  tree template_type = TREE_TYPE (TREE_TYPE (DECL_CHAIN (TYPE_FIELDS (type))));\n   tree p_array_type = TREE_TYPE (TYPE_FIELDS (type));\n   tree etype = TREE_TYPE (expr);\n   tree template_tree;\n@@ -3568,7 +3568,7 @@ convert_to_fat_pointer (tree type, tree expr)\n     {\n       CONSTRUCTOR_APPEND_ELT (v, TYPE_FIELDS (type),\n \t\t\t      convert (p_array_type, expr));\n-      CONSTRUCTOR_APPEND_ELT (v, TREE_CHAIN (TYPE_FIELDS (type)),\n+      CONSTRUCTOR_APPEND_ELT (v, DECL_CHAIN (TYPE_FIELDS (type)),\n \t\t\t      convert (build_pointer_type (template_type),\n \t\t\t\t       expr));\n       return gnat_build_constructor (type, v);\n@@ -3588,7 +3588,7 @@ convert_to_fat_pointer (tree type, tree expr)\n       template_tree = build_component_ref (expr, NULL_TREE, fields, false);\n       expr = build_unary_op (ADDR_EXPR, NULL_TREE,\n \t\t\t     build_component_ref (expr, NULL_TREE,\n-\t\t\t\t\t\t  TREE_CHAIN (fields), false));\n+\t\t\t\t\t\t  DECL_CHAIN (fields), false));\n     }\n \n   /* Otherwise, build the constructor for the template.  */\n@@ -3609,7 +3609,7 @@ convert_to_fat_pointer (tree type, tree expr)\n      will only refer to the provided TEMPLATE_TYPE in this case.  */\n   CONSTRUCTOR_APPEND_ELT (v, TYPE_FIELDS (type),\n \t\t\t  convert (p_array_type, expr));\n-  CONSTRUCTOR_APPEND_ELT (v, TREE_CHAIN (TYPE_FIELDS (type)),\n+  CONSTRUCTOR_APPEND_ELT (v, DECL_CHAIN (TYPE_FIELDS (type)),\n \t\t\t  build_unary_op (ADDR_EXPR, NULL_TREE,\n \t\t\t\t\t  template_tree));\n   return gnat_build_constructor (type, v);\n@@ -3775,7 +3775,7 @@ convert (tree type, tree expr)\n      type and then build the template. */\n   if (code == RECORD_TYPE && TYPE_CONTAINS_TEMPLATE_P (type))\n     {\n-      tree obj_type = TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (type)));\n+      tree obj_type = TREE_TYPE (DECL_CHAIN (TYPE_FIELDS (type)));\n       VEC(constructor_elt,gc) *v = VEC_alloc (constructor_elt, gc, 2);\n \n       /* If the source already has a template, get a reference to the\n@@ -3786,7 +3786,7 @@ convert (tree type, tree expr)\n       CONSTRUCTOR_APPEND_ELT (v, TYPE_FIELDS (type),\n \t\t\t      build_template (TREE_TYPE (TYPE_FIELDS (type)),\n \t\t\t\t\t      obj_type, NULL_TREE));\n-      CONSTRUCTOR_APPEND_ELT (v, TREE_CHAIN (TYPE_FIELDS (type)),\n+      CONSTRUCTOR_APPEND_ELT (v, DECL_CHAIN (TYPE_FIELDS (type)),\n \t\t\t      convert (obj_type, expr));\n       return gnat_build_constructor (type, v);\n     }\n@@ -3882,8 +3882,8 @@ convert (tree type, tree expr)\n \t\t  && !initializer_constant_valid_for_bitfield_p (value))\n \t\tclear_constant = true;\n \n-\t      efield = TREE_CHAIN (efield);\n-\t      field = TREE_CHAIN (field);\n+\t      efield = DECL_CHAIN (efield);\n+\t      field = DECL_CHAIN (field);\n \t    }\n \n \t  /* If we have been able to match and convert all the input fields\n@@ -4264,14 +4264,14 @@ maybe_unconstrained_array (tree exp)\n \t      && TYPE_CONTAINS_TEMPLATE_P (TREE_TYPE (new_exp)))\n \t    return\n \t      build_component_ref (new_exp, NULL_TREE,\n-\t\t\t\t   TREE_CHAIN\n+\t\t\t\t   DECL_CHAIN\n \t\t\t\t   (TYPE_FIELDS (TREE_TYPE (new_exp))),\n \t\t\t\t   false);\n \t}\n       else if (TYPE_CONTAINS_TEMPLATE_P (TREE_TYPE (exp)))\n \treturn\n \t  build_component_ref (exp, NULL_TREE,\n-\t\t\t       TREE_CHAIN (TYPE_FIELDS (TREE_TYPE (exp))),\n+\t\t\t       DECL_CHAIN (TYPE_FIELDS (TREE_TYPE (exp))),\n \t\t\t       false);\n       break;\n "}, {"sha": "bd78686e2407134305f829e6717d6d65d607888a", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -1612,7 +1612,7 @@ build_simple_component_ref (tree record_variable, tree component,\n \n       /* First loop thru normal components.  */\n       for (new_field = TYPE_FIELDS (record_type); new_field;\n-\t   new_field = TREE_CHAIN (new_field))\n+\t   new_field = DECL_CHAIN (new_field))\n \tif (SAME_FIELD_P (field, new_field))\n \t  break;\n \n@@ -1622,7 +1622,7 @@ build_simple_component_ref (tree record_variable, tree component,\n          _Parent field.  */\n       if (!new_field)\n \tfor (new_field = TYPE_FIELDS (record_type); new_field;\n-\t     new_field = TREE_CHAIN (new_field))\n+\t     new_field = DECL_CHAIN (new_field))\n \t  if (DECL_INTERNAL_P (new_field))\n \t    {\n \t      tree field_ref\n@@ -1996,7 +1996,7 @@ build_allocator (tree type, tree init, tree result_type, Entity_Id gnat_proc,\n \n \t  CONSTRUCTOR_APPEND_ELT (v, TYPE_FIELDS (storage_type),\n \t\t\t\t  build_template (template_type, type, init));\n-\t  CONSTRUCTOR_APPEND_ELT (v, TREE_CHAIN (TYPE_FIELDS (storage_type)),\n+\t  CONSTRUCTOR_APPEND_ELT (v, DECL_CHAIN (TYPE_FIELDS (storage_type)),\n \t\t\t\t  init);\n \n \t  return convert\n@@ -2088,7 +2088,7 @@ fill_vms_descriptor (tree expr, Entity_Id gnat_formal, Node_Id gnat_actual)\n   expr = maybe_unconstrained_array (expr);\n   gnat_mark_addressable (expr);\n \n-  for (field = TYPE_FIELDS (record_type); field; field = TREE_CHAIN (field))\n+  for (field = TYPE_FIELDS (record_type); field; field = DECL_CHAIN (field))\n     {\n       tree conexpr = convert (TREE_TYPE (field),\n \t\t\t      SUBSTITUTE_PLACEHOLDER_IN_EXPR"}, {"sha": "2e28212f5b323066296d4c5604c28258c29a7fce", "filename": "gcc/alias.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -903,7 +903,7 @@ record_component_aliases (tree type)\n \t    record_alias_subset (superset,\n \t\t\t\t get_alias_set (BINFO_TYPE (base_binfo)));\n \t}\n-      for (field = TYPE_FIELDS (type); field != 0; field = TREE_CHAIN (field))\n+      for (field = TYPE_FIELDS (type); field != 0; field = DECL_CHAIN (field))\n \tif (TREE_CODE (field) == FIELD_DECL && !DECL_NONADDRESSABLE_P (field))\n \t  record_alias_subset (superset, get_alias_set (TREE_TYPE (field)));\n       break;"}, {"sha": "cd56513a66ba672652eaefdcd16b58796fdfc2f4", "filename": "gcc/c-decl.c", "status": "modified", "additions": 41, "deletions": 40, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -1076,7 +1076,7 @@ pop_scope (void)\n     {\n       tree file_decl = build_decl (UNKNOWN_LOCATION,\n \t  \t\t\t   TRANSLATION_UNIT_DECL, 0, 0);\n-      TREE_CHAIN (file_decl) = all_translation_units;\n+      DECL_CHAIN (file_decl) = all_translation_units;\n       all_translation_units = file_decl;\n       context = file_decl;\n     }\n@@ -1100,7 +1100,7 @@ pop_scope (void)\n \t    warn_for_unused_label (p);\n \n \t  /* Labels go in BLOCK_VARS.  */\n-\t  TREE_CHAIN (p) = BLOCK_VARS (block);\n+\t  DECL_CHAIN (p) = BLOCK_VARS (block);\n \t  BLOCK_VARS (block) = p;\n \t  gcc_assert (I_LABEL_BINDING (b->id) == b);\n \t  I_LABEL_BINDING (b->id) = b->shadowed;\n@@ -1188,7 +1188,7 @@ pop_scope (void)\n \t     binding in the home scope.  */\n \t  if (!b->nested)\n \t    {\n-\t      TREE_CHAIN (p) = BLOCK_VARS (block);\n+\t      DECL_CHAIN (p) = BLOCK_VARS (block);\n \t      BLOCK_VARS (block) = p;\n \t    }\n \t  else if (VAR_OR_FUNCTION_DECL_P (p))\n@@ -1211,7 +1211,7 @@ pop_scope (void)\n \t\t}\n \t      if (b->locus != UNKNOWN_LOCATION)\n \t\tDECL_SOURCE_LOCATION (extp) = b->locus;\n-\t      TREE_CHAIN (extp) = BLOCK_VARS (block);\n+\t      DECL_CHAIN (extp) = BLOCK_VARS (block);\n \t      BLOCK_VARS (block) = extp;\n \t    }\n \t  /* If this is the file scope, and we are processing more\n@@ -1293,7 +1293,7 @@ push_file_scope (void)\n \n   start_fname_decls ();\n \n-  for (decl = visible_builtins; decl; decl = TREE_CHAIN (decl))\n+  for (decl = visible_builtins; decl; decl = DECL_CHAIN (decl))\n     bind (DECL_NAME (decl), decl, file_scope,\n \t  /*invisible=*/false, /*nested=*/true, DECL_SOURCE_LOCATION (decl));\n }\n@@ -2400,7 +2400,7 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype)\n \t  DECL_STRUCT_FUNCTION (newdecl) = DECL_STRUCT_FUNCTION (olddecl);\n \t  DECL_SAVED_TREE (newdecl) = DECL_SAVED_TREE (olddecl);\n \t  DECL_ARGUMENTS (newdecl) = copy_list (DECL_ARGUMENTS (olddecl));\n-\t  for (t = DECL_ARGUMENTS (newdecl); t ; t = TREE_CHAIN (t))\n+\t  for (t = DECL_ARGUMENTS (newdecl); t ; t = DECL_CHAIN (t))\n \t    DECL_CONTEXT (t) = newdecl;\n \n \t  /* See if we've got a function to instantiate from.  */\n@@ -3567,7 +3567,7 @@ c_builtin_function (tree decl)\n      needing to be explicitly declared.  See push_file_scope.  */\n   if (name[0] == '_' && (name[1] == '_' || ISUPPER (name[1])))\n     {\n-      TREE_CHAIN (decl) = visible_builtins;\n+      DECL_CHAIN (decl) = visible_builtins;\n       visible_builtins = decl;\n     }\n \n@@ -3593,7 +3593,7 @@ c_builtin_function_ext_scope (tree decl)\n      needing to be explicitly declared.  See push_file_scope.  */\n   if (name[0] == '_' && (name[1] == '_' || ISUPPER (name[1])))\n     {\n-      TREE_CHAIN (decl) = visible_builtins;\n+      DECL_CHAIN (decl) = visible_builtins;\n       visible_builtins = decl;\n     }\n \n@@ -4061,7 +4061,7 @@ start_decl (struct c_declarator *declarator, struct c_declspecs *declspecs,\n       if (ce->kind == cdk_function)\n \t{\n \t  tree args = ce->u.arg_info->parms;\n-\t  for (; args; args = TREE_CHAIN (args))\n+\t  for (; args; args = DECL_CHAIN (args))\n \t    {\n \t      tree type = TREE_TYPE (args);\n \t      if (type && INTEGRAL_TYPE_P (type)\n@@ -4574,16 +4574,16 @@ flexible_array_type_p (tree type)\n       x = TYPE_FIELDS (type);\n       if (x == NULL_TREE)\n \treturn false;\n-      while (TREE_CHAIN (x) != NULL_TREE)\n-\tx = TREE_CHAIN (x);\n+      while (DECL_CHAIN (x) != NULL_TREE)\n+\tx = DECL_CHAIN (x);\n       if (TREE_CODE (TREE_TYPE (x)) == ARRAY_TYPE\n \t  && TYPE_SIZE (TREE_TYPE (x)) == NULL_TREE\n \t  && TYPE_DOMAIN (TREE_TYPE (x)) != NULL_TREE\n \t  && TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (x))) == NULL_TREE)\n \treturn true;\n       return false;\n     case UNION_TYPE:\n-      for (x = TYPE_FIELDS (type); x != NULL_TREE; x = TREE_CHAIN (x))\n+      for (x = TYPE_FIELDS (type); x != NULL_TREE; x = DECL_CHAIN (x))\n \t{\n \t  if (flexible_array_type_p (TREE_TYPE (x)))\n \t    return true;\n@@ -6125,7 +6125,7 @@ grokparms (struct c_arg_info *arg_info, bool funcdef_flag)\n \n       for (parm = arg_info->parms, typelt = arg_types, parmno = 1;\n \t   parm;\n-\t   parm = TREE_CHAIN (parm), typelt = TREE_CHAIN (typelt), parmno++)\n+\t   parm = DECL_CHAIN (parm), typelt = TREE_CHAIN (typelt), parmno++)\n \t{\n \t  type = TREE_VALUE (typelt);\n \t  if (type == error_mark_node)\n@@ -6272,7 +6272,7 @@ get_parm_info (bool ellipsis)\n \t  else\n \t    {\n \t      /* Valid parameter, add it to the list.  */\n-\t      TREE_CHAIN (decl) = parms;\n+\t      DECL_CHAIN (decl) = parms;\n \t      parms = decl;\n \n \t      /* Since there is a prototype, args are passed in their\n@@ -6336,7 +6336,7 @@ get_parm_info (bool ellipsis)\n \t  gcc_assert (TREE_CODE (decl) == FUNCTION_DECL\n \t\t      ? b->nested\n \t\t      : !b->nested);\n-\t  TREE_CHAIN (decl) = others;\n+\t  DECL_CHAIN (decl) = others;\n \t  others = decl;\n \t  /* fall through */\n \n@@ -6659,7 +6659,7 @@ detect_field_duplicates_hash (tree fieldlist, htab_t htab)\n   tree x, y;\n   void **slot;\n \n-  for (x = fieldlist; x ; x = TREE_CHAIN (x))\n+  for (x = fieldlist; x ; x = DECL_CHAIN (x))\n     if ((y = DECL_NAME (x)) != 0)\n       {\n \tslot = htab_find_slot (htab, y, INSERT);\n@@ -6688,7 +6688,7 @@ detect_field_duplicates (tree fieldlist)\n      This is trivially true if there are zero or one fields.  */\n   if (!fieldlist)\n     return;\n-  x = TREE_CHAIN (fieldlist);\n+  x = DECL_CHAIN (fieldlist);\n   if (!x)\n     return;\n   do {\n@@ -6697,15 +6697,16 @@ detect_field_duplicates (tree fieldlist)\n \t&& (TREE_CODE (TREE_TYPE (x)) == RECORD_TYPE\n \t    || TREE_CODE (TREE_TYPE (x)) == UNION_TYPE))\n       timeout = 0;\n-    x = TREE_CHAIN (x);\n+    x = DECL_CHAIN (x);\n   } while (timeout > 0 && x);\n \n   /* If there were \"few\" fields and no anonymous structures or unions,\n      avoid the overhead of allocating a hash table.  Instead just do\n      the nested traversal thing.  */\n   if (timeout > 0)\n     {\n-      for (x = TREE_CHAIN (fieldlist); x ; x = TREE_CHAIN (x))\n+      for (x = TREE_CHAIN (fieldlist); x ;\n+\t   x = TREE_CHAIN (x))\n \tif (DECL_NAME (x))\n \t  {\n \t    for (y = fieldlist; y != x; y = TREE_CHAIN (y))\n@@ -6760,7 +6761,7 @@ warn_cxx_compat_finish_struct (tree fieldlist)\n \t   ++ix)\n \tpointer_set_insert (tset, DECL_NAME (x));\n \n-      for (x = fieldlist; x != NULL_TREE; x = TREE_CHAIN (x))\n+      for (x = fieldlist; x != NULL_TREE; x = DECL_CHAIN (x))\n \t{\n \t  if (pointer_set_contains (tset, DECL_NAME (x)))\n \t    {\n@@ -6809,7 +6810,7 @@ finish_struct (location_t loc, tree t, tree fieldlist, tree attributes,\n \n   if (pedantic)\n     {\n-      for (x = fieldlist; x; x = TREE_CHAIN (x))\n+      for (x = fieldlist; x; x = DECL_CHAIN (x))\n \t{\n \t  if (DECL_NAME (x) != 0)\n \t    break;\n@@ -6846,7 +6847,7 @@ finish_struct (location_t loc, tree t, tree fieldlist, tree attributes,\n      until now.)  */\n \n   saw_named_field = 0;\n-  for (x = fieldlist; x; x = TREE_CHAIN (x))\n+  for (x = fieldlist; x; x = DECL_CHAIN (x))\n     {\n       if (TREE_TYPE (x) == error_mark_node)\n \tcontinue;\n@@ -6901,7 +6902,7 @@ finish_struct (location_t loc, tree t, tree fieldlist, tree attributes,\n \t\t\t\"flexible array member in union\");\n \t      TREE_TYPE (x) = error_mark_node;\n \t    }\n-\t  else if (TREE_CHAIN (x) != NULL_TREE)\n+\t  else if (DECL_CHAIN (x) != NULL_TREE)\n \t    {\n \t      error_at (DECL_SOURCE_LOCATION (x),\n \t\t\t\"flexible array member not at end of struct\");\n@@ -6954,7 +6955,7 @@ finish_struct (location_t loc, tree t, tree fieldlist, tree attributes,\n \t  DECL_INITIAL (*fieldlistp) = 0;\n \t}\n       else\n-\tfieldlistp = &TREE_CHAIN (*fieldlistp);\n+\tfieldlistp = &DECL_CHAIN (*fieldlistp);\n   }\n \n   /* Now we have the truly final field list.\n@@ -6968,7 +6969,7 @@ finish_struct (location_t loc, tree t, tree fieldlist, tree attributes,\n   {\n     int len = 0;\n \n-    for (x = fieldlist; x; x = TREE_CHAIN (x))\n+    for (x = fieldlist; x; x = DECL_CHAIN (x))\n       {\n \tif (len > 15 || DECL_NAME (x) == NULL)\n \t  break;\n@@ -6994,7 +6995,7 @@ finish_struct (location_t loc, tree t, tree fieldlist, tree attributes,\n \tlen = 0;\n \tspace->s = space2;\n \tfield_array = &space2->elts[0];\n-\tfor (x = fieldlist; x; x = TREE_CHAIN (x))\n+\tfor (x = fieldlist; x; x = DECL_CHAIN (x))\n \t  {\n \t    field_array[len++] = x;\n \n@@ -7666,7 +7667,7 @@ store_parm_decls_newstyle (tree fndecl, const struct c_arg_info *arg_info)\n \n   /* Now make all the parameter declarations visible in the function body.\n      We can bypass most of the grunt work of pushdecl.  */\n-  for (decl = arg_info->parms; decl; decl = TREE_CHAIN (decl))\n+  for (decl = arg_info->parms; decl; decl = DECL_CHAIN (decl))\n     {\n       DECL_CONTEXT (decl) = current_function_decl;\n       if (DECL_NAME (decl))\n@@ -7685,7 +7686,7 @@ store_parm_decls_newstyle (tree fndecl, const struct c_arg_info *arg_info)\n   DECL_ARGUMENTS (fndecl) = arg_info->parms;\n \n   /* Now make all the ancillary declarations visible, likewise.  */\n-  for (decl = arg_info->others; decl; decl = TREE_CHAIN (decl))\n+  for (decl = arg_info->others; decl; decl = DECL_CHAIN (decl))\n     {\n       DECL_CONTEXT (decl) = current_function_decl;\n       if (DECL_NAME (decl))\n@@ -7837,10 +7838,10 @@ store_parm_decls_oldstyle (tree fndecl, const struct c_arg_info *arg_info)\n       for (parm = TREE_CHAIN (parm); parm; parm = TREE_CHAIN (parm))\n \tif (TREE_PURPOSE (parm))\n \t  {\n-\t    TREE_CHAIN (last) = TREE_PURPOSE (parm);\n+\t    DECL_CHAIN (last) = TREE_PURPOSE (parm);\n \t    last = TREE_PURPOSE (parm);\n \t  }\n-      TREE_CHAIN (last) = 0;\n+      DECL_CHAIN (last) = 0;\n     }\n \n   pointer_set_destroy (seen_args);\n@@ -7856,7 +7857,7 @@ store_parm_decls_oldstyle (tree fndecl, const struct c_arg_info *arg_info)\n \t     type = current_function_prototype_arg_types;\n \t   parm || (type && TREE_VALUE (type) != error_mark_node\n                    && (TYPE_MAIN_VARIANT (TREE_VALUE (type)) != void_type_node));\n-\t   parm = TREE_CHAIN (parm), type = TREE_CHAIN (type))\n+\t   parm = DECL_CHAIN (parm), type = TREE_CHAIN (type))\n \t{\n \t  if (parm == 0 || type == 0\n \t      || TYPE_MAIN_VARIANT (TREE_VALUE (type)) == void_type_node)\n@@ -7947,7 +7948,7 @@ store_parm_decls_oldstyle (tree fndecl, const struct c_arg_info *arg_info)\n     {\n       tree actual = 0, last = 0, type;\n \n-      for (parm = DECL_ARGUMENTS (fndecl); parm; parm = TREE_CHAIN (parm))\n+      for (parm = DECL_ARGUMENTS (fndecl); parm; parm = DECL_CHAIN (parm))\n \t{\n \t  type = tree_cons (NULL_TREE, DECL_ARG_TYPE (parm), NULL_TREE);\n \t  if (last)\n@@ -8068,7 +8069,7 @@ finish_function (void)\n       && targetm.calls.promote_prototypes (TREE_TYPE (fndecl)))\n     {\n       tree args = DECL_ARGUMENTS (fndecl);\n-      for (; args; args = TREE_CHAIN (args))\n+      for (; args; args = DECL_CHAIN (args))\n \t{\n \t  tree type = TREE_TYPE (args);\n \t  if (INTEGRAL_TYPE_P (type)\n@@ -8131,7 +8132,7 @@ finish_function (void)\n \n       for (decl = DECL_ARGUMENTS (fndecl);\n \t   decl;\n-\t   decl = TREE_CHAIN (decl))\n+\t   decl = DECL_CHAIN (decl))\n \tif (TREE_USED (decl)\n \t    && TREE_CODE (decl) == PARM_DECL\n \t    && !DECL_READ_P (decl)\n@@ -9567,7 +9568,7 @@ c_write_global_declarations_1 (tree globals)\n   bool reconsider;\n \n   /* Process the decls in the order they were written.  */\n-  for (decl = globals; decl; decl = TREE_CHAIN (decl))\n+  for (decl = globals; decl; decl = DECL_CHAIN (decl))\n     {\n       /* Check for used but undefined static functions using the C\n \t standard's definition of \"used\", and set TREE_NO_WARNING so\n@@ -9588,12 +9589,12 @@ c_write_global_declarations_1 (tree globals)\n   do\n     {\n       reconsider = false;\n-      for (decl = globals; decl; decl = TREE_CHAIN (decl))\n+      for (decl = globals; decl; decl = DECL_CHAIN (decl))\n \treconsider |= wrapup_global_declaration_2 (decl);\n     }\n   while (reconsider);\n \n-  for (decl = globals; decl; decl = TREE_CHAIN (decl))\n+  for (decl = globals; decl; decl = DECL_CHAIN (decl))\n     check_global_declaration_1 (decl);\n }\n \n@@ -9605,7 +9606,7 @@ c_write_global_declarations_2 (tree globals)\n {\n   tree decl;\n \n-  for (decl = globals; decl ; decl = TREE_CHAIN (decl))\n+  for (decl = globals; decl ; decl = DECL_CHAIN (decl))\n     debug_hooks->global_decl (decl);\n }\n \n@@ -9689,7 +9690,7 @@ c_write_global_declarations (void)\n \n   /* Process all file scopes in this compilation, and the external_scope,\n      through wrapup_global_declarations and check_global_declarations.  */\n-  for (t = all_translation_units; t; t = TREE_CHAIN (t))\n+  for (t = all_translation_units; t; t = DECL_CHAIN (t))\n     c_write_global_declarations_1 (BLOCK_VARS (DECL_INITIAL (t)));\n   c_write_global_declarations_1 (BLOCK_VARS (ext_block));\n \n@@ -9702,7 +9703,7 @@ c_write_global_declarations (void)\n   if (!seen_error ())\n     {\n       timevar_push (TV_SYMOUT);\n-      for (t = all_translation_units; t; t = TREE_CHAIN (t))\n+      for (t = all_translation_units; t; t = DECL_CHAIN (t))\n \tc_write_global_declarations_2 (BLOCK_VARS (DECL_INITIAL (t)));\n       c_write_global_declarations_2 (BLOCK_VARS (ext_block));\n       timevar_pop (TV_SYMOUT);"}, {"sha": "b1d118fe6a1818062a588108a50b3b77079315e7", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -1,3 +1,8 @@\n+2010-07-15  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* c-common.c: Carefully replace TREE_CHAIN with DECL_CHAIN.\n+\t* c-format.c: Likewise.\n+\n 2010-07-08  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \t* c-common.h: Include diagnostic-core.h. Error if already"}, {"sha": "e2a0561c7c6185e78ea8751b092b3fdaa24b73b5", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -4022,7 +4022,7 @@ c_type_hash (const void *p)\n     default:\n       gcc_unreachable ();\n     }\n-  for (; t2; t2 = TREE_CHAIN (t2))\n+  for (; t2; t2 = DECL_CHAIN (t2))\n     i++;\n   /* We might have a VLA here.  */\n   if (TREE_CODE (TYPE_SIZE (t)) != INTEGER_CST)\n@@ -8390,8 +8390,8 @@ fold_offsetof_1 (tree expr, tree stop_ref)\n \t\t    if (TREE_CODE (TREE_TYPE (TREE_OPERAND (v, 0)))\n \t\t\t== RECORD_TYPE)\n \t\t      {\n-\t\t\ttree fld_chain = TREE_CHAIN (TREE_OPERAND (v, 1));\n-\t\t\tfor (; fld_chain; fld_chain = TREE_CHAIN (fld_chain))\n+\t\t\ttree fld_chain = DECL_CHAIN (TREE_OPERAND (v, 1));\n+\t\t\tfor (; fld_chain; fld_chain = DECL_CHAIN (fld_chain))\n \t\t\t  if (TREE_CODE (fld_chain) == FIELD_DECL)\n \t\t\t    break;\n "}, {"sha": "e7fd2295d52903b1cdb40b92acd433f6e505294d", "filename": "gcc/c-family/c-format.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fc-family%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fc-family%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-format.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -911,7 +911,7 @@ check_function_format (tree attrs, int nargs, tree *argarray)\n \t\t  tree args;\n \t\t  for (args = DECL_ARGUMENTS (current_function_decl);\n \t\t       args != 0;\n-\t\t       args = TREE_CHAIN (args))\n+\t\t       args = DECL_CHAIN (args))\n \t\t    {\n \t\t      if (TREE_CODE (TREE_TYPE (args)) == POINTER_TYPE\n \t\t\t  && (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (args)))"}, {"sha": "e773fe0d0fc421f0f0032a53e89e628210d74ab5", "filename": "gcc/c-parser.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -2229,7 +2229,7 @@ c_parser_struct_declaration (c_parser *parser)\n \t\t\t declarator, specs, width, &all_prefix_attrs);\n \t  decl_attributes (&d, chainon (postfix_attrs,\n \t\t\t\t\tall_prefix_attrs), 0);\n-\t  TREE_CHAIN (d) = decls;\n+\t  DECL_CHAIN (d) = decls;\n \t  decls = d;\n \t  if (c_parser_next_token_is_keyword (parser, RID_ATTRIBUTE))\n \t    all_prefix_attrs = chainon (c_parser_attributes (parser),\n@@ -6431,7 +6431,7 @@ c_parser_objc_class_instance_variables (c_parser *parser)\n \t/* Comma-separated instance variables are chained together in\n \t   reverse order; add them one by one.  */\n \ttree ivar = nreverse (decls);\n-\tfor (; ivar; ivar = TREE_CHAIN (ivar))\n+\tfor (; ivar; ivar = DECL_CHAIN (ivar))\n \t  objc_add_instance_variable (copy_node (ivar));\n       }\n       c_parser_skip_until_found (parser, CPP_SEMICOLON, \"expected %<;%>\");"}, {"sha": "edf0d8b2c9dc00ee18f3fda49b365d325bbc4bc3", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -555,7 +555,7 @@ composite_type (tree t1, tree t2)\n \t\t    && TREE_CODE (mv2) != ARRAY_TYPE)\n \t\t  mv2 = TYPE_MAIN_VARIANT (mv2);\n \t\tfor (memb = TYPE_FIELDS (TREE_VALUE (p1));\n-\t\t     memb; memb = TREE_CHAIN (memb))\n+\t\t     memb; memb = DECL_CHAIN (memb))\n \t\t  {\n \t\t    tree mv3 = TREE_TYPE (memb);\n \t\t    if (mv3 && mv3 != error_mark_node\n@@ -580,7 +580,7 @@ composite_type (tree t1, tree t2)\n \t\t    && TREE_CODE (mv1) != ARRAY_TYPE)\n \t\t  mv1 = TYPE_MAIN_VARIANT (mv1);\n \t\tfor (memb = TYPE_FIELDS (TREE_VALUE (p2));\n-\t\t     memb; memb = TREE_CHAIN (memb))\n+\t\t     memb; memb = DECL_CHAIN (memb))\n \t\t  {\n \t\t    tree mv3 = TREE_TYPE (memb);\n \t\t    if (mv3 && mv3 != error_mark_node\n@@ -1434,7 +1434,7 @@ tagged_types_tu_compatible_p (const_tree t1, const_tree t2,\n \n \t/*  Speed up the common case where the fields are in the same order. */\n \tfor (s1 = TYPE_FIELDS (t1), s2 = TYPE_FIELDS (t2); s1 && s2;\n-\t     s1 = TREE_CHAIN (s1), s2 = TREE_CHAIN (s2))\n+\t     s1 = DECL_CHAIN (s1), s2 = DECL_CHAIN (s2))\n \t  {\n \t    int result;\n \n@@ -1467,11 +1467,11 @@ tagged_types_tu_compatible_p (const_tree t1, const_tree t2,\n \t    return tu->val;\n \t  }\n \n-\tfor (s1 = TYPE_FIELDS (t1); s1; s1 = TREE_CHAIN (s1))\n+\tfor (s1 = TYPE_FIELDS (t1); s1; s1 = DECL_CHAIN (s1))\n \t  {\n \t    bool ok = false;\n \n-\t    for (s2 = TYPE_FIELDS (t2); s2; s2 = TREE_CHAIN (s2))\n+\t    for (s2 = TYPE_FIELDS (t2); s2; s2 = DECL_CHAIN (s2))\n \t      if (DECL_NAME (s1) == DECL_NAME (s2))\n \t\t{\n \t\t  int result;\n@@ -1514,7 +1514,7 @@ tagged_types_tu_compatible_p (const_tree t1, const_tree t2,\n \n \tfor (s1 = TYPE_FIELDS (t1), s2 = TYPE_FIELDS (t2);\n \t     s1 && s2;\n-\t     s1 = TREE_CHAIN (s1), s2 = TREE_CHAIN (s2))\n+\t     s1 = DECL_CHAIN (s1), s2 = DECL_CHAIN (s2))\n \t  {\n \t    int result;\n \t    if (TREE_CODE (s1) != TREE_CODE (s2)\n@@ -1684,7 +1684,7 @@ type_lists_compatible_p (const_tree args1, const_tree args2,\n \t    {\n \t      tree memb;\n \t      for (memb = TYPE_FIELDS (a1);\n-\t\t   memb; memb = TREE_CHAIN (memb))\n+\t\t   memb; memb = DECL_CHAIN (memb))\n \t\t{\n \t\t  tree mv3 = TREE_TYPE (memb);\n \t\t  if (mv3 && mv3 != error_mark_node\n@@ -1706,7 +1706,7 @@ type_lists_compatible_p (const_tree args1, const_tree args2,\n \t    {\n \t      tree memb;\n \t      for (memb = TYPE_FIELDS (a2);\n-\t\t   memb; memb = TREE_CHAIN (memb))\n+\t\t   memb; memb = DECL_CHAIN (memb))\n \t\t{\n \t\t  tree mv3 = TREE_TYPE (memb);\n \t\t  if (mv3 && mv3 != error_mark_node\n@@ -2081,7 +2081,7 @@ lookup_field (tree type, tree component)\n     }\n   else\n     {\n-      for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+      for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n \t{\n \t  if (DECL_NAME (field) == NULL_TREE\n \t      && (TREE_CODE (TREE_TYPE (field)) == RECORD_TYPE\n@@ -4560,7 +4560,7 @@ build_c_cast (location_t loc, tree type, tree expr)\n     {\n       tree field;\n \n-      for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+      for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n \tif (TREE_TYPE (field) != error_mark_node\n \t    && comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (field)),\n \t\t\t  TYPE_MAIN_VARIANT (TREE_TYPE (value))))\n@@ -5192,7 +5192,7 @@ convert_for_assignment (location_t location, tree type, tree rhs,\n     {\n       tree memb, marginal_memb = NULL_TREE;\n \n-      for (memb = TYPE_FIELDS (type); memb ; memb = TREE_CHAIN (memb))\n+      for (memb = TYPE_FIELDS (type); memb ; memb = DECL_CHAIN (memb))\n \t{\n \t  tree memb_type = TREE_TYPE (memb);\n \n@@ -6483,7 +6483,7 @@ really_start_incremental_init (tree type)\n       /* Skip any nameless bit fields at the beginning.  */\n       while (constructor_fields != 0 && DECL_C_BIT_FIELD (constructor_fields)\n \t     && DECL_NAME (constructor_fields) == 0)\n-\tconstructor_fields = TREE_CHAIN (constructor_fields);\n+\tconstructor_fields = DECL_CHAIN (constructor_fields);\n \n       constructor_unfilled_fields = constructor_fields;\n       constructor_bit_index = bitsize_zero_node;\n@@ -6802,7 +6802,7 @@ pop_init_level (int implicit, struct obstack * braced_init_obstack)\n \t  /* We have already issued an error message for the existence\n \t     of a flexible array member not at the end of the structure.\n \t     Discard the initializer so that we do not die later.  */\n-\t  if (TREE_CHAIN (constructor_fields) != NULL_TREE)\n+\t  if (DECL_CHAIN (constructor_fields) != NULL_TREE)\n \t    constructor_type = NULL_TREE;\n \t}\n     }\n@@ -6817,7 +6817,7 @@ pop_init_level (int implicit, struct obstack * braced_init_obstack)\n \twhile (constructor_unfilled_fields\n \t       && (!DECL_SIZE (constructor_unfilled_fields)\n \t\t   || integer_zerop (DECL_SIZE (constructor_unfilled_fields))))\n-\t  constructor_unfilled_fields = TREE_CHAIN (constructor_unfilled_fields);\n+\t  constructor_unfilled_fields = DECL_CHAIN (constructor_unfilled_fields);\n \n \t/* Do not warn if this level of the initializer uses member\n \t   designators; it is likely to be deliberate.  */\n@@ -7650,7 +7650,7 @@ output_init_element (tree value, tree origtype, bool strict_string, tree type,\n \t  || (COMPLETE_TYPE_P (TREE_TYPE (field))\n \t      && integer_zerop (TYPE_SIZE (TREE_TYPE (field)))\n \t      && (TREE_CODE (constructor_type) == ARRAY_TYPE\n-\t\t  || TREE_CHAIN (field)))))\n+\t\t  || DECL_CHAIN (field)))))\n     return;\n \n   if (semantic_type)\n@@ -7738,14 +7738,14 @@ output_init_element (tree value, tree origtype, bool strict_string, tree type,\n   else if (TREE_CODE (constructor_type) == RECORD_TYPE)\n     {\n       constructor_unfilled_fields\n-\t= TREE_CHAIN (constructor_unfilled_fields);\n+\t= DECL_CHAIN (constructor_unfilled_fields);\n \n       /* Skip any nameless bit fields.  */\n       while (constructor_unfilled_fields != 0\n \t     && DECL_C_BIT_FIELD (constructor_unfilled_fields)\n \t     && DECL_NAME (constructor_unfilled_fields) == 0)\n \tconstructor_unfilled_fields =\n-\t  TREE_CHAIN (constructor_unfilled_fields);\n+\t  DECL_CHAIN (constructor_unfilled_fields);\n     }\n   else if (TREE_CODE (constructor_type) == UNION_TYPE)\n     constructor_unfilled_fields = 0;\n@@ -8062,22 +8062,22 @@ process_init_element (struct c_expr value, bool implicit,\n \t\t it isn't now, so update.  */\n \t      if (constructor_unfilled_fields == constructor_fields)\n \t\t{\n-\t\t  constructor_unfilled_fields = TREE_CHAIN (constructor_fields);\n+\t\t  constructor_unfilled_fields = DECL_CHAIN (constructor_fields);\n \t\t  /* Skip any nameless bit fields.  */\n \t\t  while (constructor_unfilled_fields != 0\n \t\t\t && DECL_C_BIT_FIELD (constructor_unfilled_fields)\n \t\t\t && DECL_NAME (constructor_unfilled_fields) == 0)\n \t\t    constructor_unfilled_fields =\n-\t\t      TREE_CHAIN (constructor_unfilled_fields);\n+\t\t      DECL_CHAIN (constructor_unfilled_fields);\n \t\t}\n \t    }\n \n-\t  constructor_fields = TREE_CHAIN (constructor_fields);\n+\t  constructor_fields = DECL_CHAIN (constructor_fields);\n \t  /* Skip any nameless bit fields at the beginning.  */\n \t  while (constructor_fields != 0\n \t\t && DECL_C_BIT_FIELD (constructor_fields)\n \t\t && DECL_NAME (constructor_fields) == 0)\n-\t    constructor_fields = TREE_CHAIN (constructor_fields);\n+\t    constructor_fields = DECL_CHAIN (constructor_fields);\n \t}\n       else if (TREE_CODE (constructor_type) == UNION_TYPE)\n \t{"}, {"sha": "d8378ee14b6891a1e3539b607a98f8a712f85edf", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -344,7 +344,7 @@ aggregate_contains_union_type (tree type)\n   if (TREE_CODE (type) != RECORD_TYPE)\n     return false;\n \n-  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+  for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n     if (TREE_CODE (field) == FIELD_DECL)\n       if (aggregate_contains_union_type (TREE_TYPE (field)))\n \treturn true;\n@@ -1019,7 +1019,7 @@ expand_used_vars_for_block (tree block, bool toplevel)\n   old_sv_num = toplevel ? 0 : stack_vars_num;\n \n   /* Expand all variables at this level.  */\n-  for (t = BLOCK_VARS (block); t ; t = TREE_CHAIN (t))\n+  for (t = BLOCK_VARS (block); t ; t = DECL_CHAIN (t))\n     if (TREE_USED (t))\n       expand_one_var (t, toplevel, true);\n \n@@ -1051,7 +1051,7 @@ clear_tree_used (tree block)\n {\n   tree t;\n \n-  for (t = BLOCK_VARS (block); t ; t = TREE_CHAIN (t))\n+  for (t = BLOCK_VARS (block); t ; t = DECL_CHAIN (t))\n     /* if (!TREE_STATIC (t) && !DECL_EXTERNAL (t)) */\n       TREE_USED (t) = 0;\n \n@@ -1210,7 +1210,7 @@ account_used_vars_for_block (tree block, bool toplevel)\n   HOST_WIDE_INT size = 0;\n \n   /* Expand all variables at this level.  */\n-  for (t = BLOCK_VARS (block); t ; t = TREE_CHAIN (t))\n+  for (t = BLOCK_VARS (block); t ; t = DECL_CHAIN (t))\n     if (TREE_USED (t))\n       size += expand_one_var (t, toplevel, false);\n "}, {"sha": "63fed497b471be8eaa2fc1bed034f5fdbe32bf53", "filename": "gcc/cgraph.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -2302,7 +2302,7 @@ cgraph_create_virtual_clone (struct cgraph_node *old_node,\n       struct cgraph_node *orig_node;\n       for (orig_node = old_node; orig_node->clone_of; orig_node = orig_node->clone_of)\n         ;\n-      for (arg = DECL_ARGUMENTS (orig_node->decl); arg; arg = TREE_CHAIN (arg), oldi++)\n+      for (arg = DECL_ARGUMENTS (orig_node->decl); arg; arg = DECL_CHAIN (arg), oldi++)\n \t{\n \t  if (bitmap_bit_p (old_node->clone.combined_args_to_skip, oldi))\n \t    {"}, {"sha": "2367067af69ddd94faae92750a26265dc9375ab1", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -1527,7 +1527,7 @@ assemble_thunk (struct cgraph_node *node)\n             restmp = create_tmp_var_raw (restype, \"retval\");\n \t}\n \n-      for (arg = a; arg; arg = TREE_CHAIN (arg))\n+      for (arg = a; arg; arg = DECL_CHAIN (arg))\n         nargs++;\n       vargs = VEC_alloc (tree, heap, nargs);\n       if (this_adjusting)\n@@ -1537,7 +1537,7 @@ assemble_thunk (struct cgraph_node *node)\n \t\t\t\t      virtual_offset));\n       else\n         VEC_quick_push (tree, vargs, a);\n-      for (i = 1, arg = TREE_CHAIN (a); i < nargs; i++, arg = TREE_CHAIN (arg))\n+      for (i = 1, arg = DECL_CHAIN (a); i < nargs; i++, arg = DECL_CHAIN (arg))\n         VEC_quick_push (tree, vargs, arg);\n       call = gimple_build_call_vec (build_fold_addr_expr_loc (0, alias), vargs);\n       VEC_free (tree, heap, vargs);"}, {"sha": "0a1e787cbb712d8f81dbedc2a1074653a9122c1a", "filename": "gcc/combine.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -1341,7 +1341,7 @@ setup_incoming_promotions (rtx first)\n   bool strictly_local = false;\n \n   for (arg = DECL_ARGUMENTS (current_function_decl); arg;\n-       arg = TREE_CHAIN (arg))\n+       arg = DECL_CHAIN (arg))\n     {\n       rtx x, reg = DECL_INCOMING_RTL (arg);\n       int uns1, uns3;"}, {"sha": "336c107be513f95196c33444980ef800c1519cd2", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -5944,13 +5944,13 @@ alpha_build_builtin_va_list (void)\n \t\t    FIELD_DECL, get_identifier (\"__offset\"),\n \t\t    integer_type_node);\n   DECL_FIELD_CONTEXT (ofs) = record;\n-  TREE_CHAIN (ofs) = space;\n+  DECL_CHAIN (ofs) = space;\n \n   base = build_decl (BUILTINS_LOCATION,\n \t\t     FIELD_DECL, get_identifier (\"__base\"),\n \t\t     ptr_type_node);\n   DECL_FIELD_CONTEXT (base) = record;\n-  TREE_CHAIN (base) = ofs;\n+  DECL_CHAIN (base) = ofs;\n \n   TYPE_FIELDS (record) = base;\n   layout_type (record);\n@@ -6304,7 +6304,7 @@ alpha_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n   else\n     {\n       base_field = TYPE_FIELDS (TREE_TYPE (valist));\n-      offset_field = TREE_CHAIN (base_field);\n+      offset_field = DECL_CHAIN (base_field);\n \n       base_field = build3 (COMPONENT_REF, TREE_TYPE (base_field),\n \t\t\t   valist, base_field, NULL_TREE);\n@@ -6408,7 +6408,7 @@ alpha_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,\n     return std_gimplify_va_arg_expr (valist, type, pre_p, post_p);\n \n   base_field = TYPE_FIELDS (va_list_type_node);\n-  offset_field = TREE_CHAIN (base_field);\n+  offset_field = DECL_CHAIN (base_field);\n   base_field = build3 (COMPONENT_REF, TREE_TYPE (base_field),\n \t\t       valist, base_field, NULL_TREE);\n   offset_field = build3 (COMPONENT_REF, TREE_TYPE (offset_field),"}, {"sha": "7b01afb3136baf9273af2cd06f942bb3d0b6b8ba", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -3536,7 +3536,7 @@ arm_return_in_memory (const_tree type, const_tree fntype)\n \t have been created by C++.  */\n       for (field = TYPE_FIELDS (type);\n \t   field && TREE_CODE (field) != FIELD_DECL;\n-\t   field = TREE_CHAIN (field))\n+\t   field = DECL_CHAIN (field))\n \tcontinue;\n \n       if (field == NULL)\n@@ -3555,9 +3555,9 @@ arm_return_in_memory (const_tree type, const_tree fntype)\n \n       /* Now check the remaining fields, if any.  Only bitfields are allowed,\n \t since they are not addressable.  */\n-      for (field = TREE_CHAIN (field);\n+      for (field = DECL_CHAIN (field);\n \t   field;\n-\t   field = TREE_CHAIN (field))\n+\t   field = DECL_CHAIN (field))\n \t{\n \t  if (TREE_CODE (field) != FIELD_DECL)\n \t    continue;\n@@ -3577,7 +3577,7 @@ arm_return_in_memory (const_tree type, const_tree fntype)\n \t integral, or can be returned in an integer register.  */\n       for (field = TYPE_FIELDS (type);\n \t   field;\n-\t   field = TREE_CHAIN (field))\n+\t   field = DECL_CHAIN (field))\n \t{\n \t  if (TREE_CODE (field) != FIELD_DECL)\n \t    continue;\n@@ -3837,7 +3837,7 @@ aapcs_vfp_sub_candidate (const_tree type, enum machine_mode *modep)\n \tif (!COMPLETE_TYPE_P(type))\n \t  return -1;\n \n-\tfor (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+\tfor (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n \t  {\n \t    if (TREE_CODE (field) != FIELD_DECL)\n \t      continue;\n@@ -3869,7 +3869,7 @@ aapcs_vfp_sub_candidate (const_tree type, enum machine_mode *modep)\n \tif (!COMPLETE_TYPE_P(type))\n \t  return -1;\n \n-\tfor (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+\tfor (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n \t  {\n \t    if (TREE_CODE (field) != FIELD_DECL)\n \t      continue;"}, {"sha": "10768fb81c5b5871eaa161df2d473e627919e51e", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -1182,7 +1182,7 @@ frv_stack_info (void)\n       /* Find the last argument, and see if it is __builtin_va_alist.  */\n       for (cur_arg = DECL_ARGUMENTS (fndecl); cur_arg != (tree)0; cur_arg = next_arg)\n \t{\n-\t  next_arg = TREE_CHAIN (cur_arg);\n+\t  next_arg = DECL_CHAIN (cur_arg);\n \t  if (next_arg == (tree)0)\n \t    {\n \t      if (DECL_NAME (cur_arg)\n@@ -6634,7 +6634,7 @@ frv_adjust_field_align (tree field, int computed)\n       tree prev = NULL_TREE;\n       tree cur;\n \n-      for (cur = TYPE_FIELDS (parent); cur && cur != field; cur = TREE_CHAIN (cur))\n+      for (cur = TYPE_FIELDS (parent); cur && cur != field; cur = DECL_CHAIN (cur))\n \t{\n \t  if (TREE_CODE (cur) != FIELD_DECL)\n \t    continue;"}, {"sha": "beb263465a47d63ed0aa9a17157333a8fe3a0506", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -5475,7 +5475,7 @@ classify_argument (enum machine_mode mode, const_tree type,\n \t{\n \tcase RECORD_TYPE:\n \t  /* And now merge the fields of structure.  */\n-\t  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+\t  for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n \t    {\n \t      if (TREE_CODE (field) == FIELD_DECL)\n \t\t{\n@@ -5563,7 +5563,7 @@ classify_argument (enum machine_mode mode, const_tree type,\n \tcase QUAL_UNION_TYPE:\n \t  /* Unions are similar to RECORD_TYPE but offset is always 0.\n \t     */\n-\t  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+\t  for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n \t    {\n \t      if (TREE_CODE (field) == FIELD_DECL)\n \t\t{\n@@ -6532,7 +6532,7 @@ contains_aligned_value_p (tree type)\n \t    tree field;\n \n \t    /* Walk all the structure fields.  */\n-\t    for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+\t    for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n \t      {\n \t\tif (TREE_CODE (field) == FIELD_DECL\n \t\t    && contains_aligned_value_p (TREE_TYPE (field)))\n@@ -6998,9 +6998,9 @@ ix86_build_builtin_va_list_abi (enum calling_abi abi)\n   TREE_CHAIN (record) = type_decl;\n   TYPE_NAME (record) = type_decl;\n   TYPE_FIELDS (record) = f_gpr;\n-  TREE_CHAIN (f_gpr) = f_fpr;\n-  TREE_CHAIN (f_fpr) = f_ovf;\n-  TREE_CHAIN (f_ovf) = f_sav;\n+  DECL_CHAIN (f_gpr) = f_fpr;\n+  DECL_CHAIN (f_fpr) = f_ovf;\n+  DECL_CHAIN (f_ovf) = f_sav;\n \n   layout_type (record);\n \n@@ -7212,9 +7212,9 @@ ix86_va_start (tree valist, rtx nextarg)\n     }\n \n   f_gpr = TYPE_FIELDS (TREE_TYPE (sysv_va_list_type_node));\n-  f_fpr = TREE_CHAIN (f_gpr);\n-  f_ovf = TREE_CHAIN (f_fpr);\n-  f_sav = TREE_CHAIN (f_ovf);\n+  f_fpr = DECL_CHAIN (f_gpr);\n+  f_ovf = DECL_CHAIN (f_fpr);\n+  f_sav = DECL_CHAIN (f_ovf);\n \n   valist = build_simple_mem_ref (valist);\n   TREE_TYPE (valist) = TREE_TYPE (sysv_va_list_type_node);\n@@ -7299,9 +7299,9 @@ ix86_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,\n     return std_gimplify_va_arg_expr (valist, type, pre_p, post_p);\n \n   f_gpr = TYPE_FIELDS (TREE_TYPE (sysv_va_list_type_node));\n-  f_fpr = TREE_CHAIN (f_gpr);\n-  f_ovf = TREE_CHAIN (f_fpr);\n-  f_sav = TREE_CHAIN (f_ovf);\n+  f_fpr = DECL_CHAIN (f_gpr);\n+  f_ovf = DECL_CHAIN (f_fpr);\n+  f_sav = DECL_CHAIN (f_ovf);\n \n   gpr = build3 (COMPONENT_REF, TREE_TYPE (f_gpr),\n \t\tbuild_va_arg_indirect_ref (valist), f_gpr, NULL_TREE);"}, {"sha": "9191c08a676a159fc85bcf76067e75faa8a501af", "filename": "gcc/config/i386/winnt-cxx.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fconfig%2Fi386%2Fwinnt-cxx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fconfig%2Fi386%2Fwinnt-cxx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fwinnt-cxx.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -99,12 +99,12 @@ i386_pe_adjust_class_at_definition (tree t)\n   if (lookup_attribute (\"dllexport\", TYPE_ATTRIBUTES (t)) != NULL_TREE)\n     {\n       /* Check static VAR_DECL's.  */\n-      for (member = TYPE_FIELDS (t); member; member = TREE_CHAIN (member))\n+      for (member = TYPE_FIELDS (t); member; member = DECL_CHAIN (member))\n \tif (TREE_CODE (member) == VAR_DECL)     \n \t  maybe_add_dllexport (member);\n     \n       /* Check FUNCTION_DECL's.  */\n-      for (member = TYPE_METHODS (t); member;  member = TREE_CHAIN (member))\n+      for (member = TYPE_METHODS (t); member;  member = DECL_CHAIN (member))\n \tif (TREE_CODE (member) == FUNCTION_DECL)\n \t  {\n \t    tree thunk;\n@@ -116,7 +116,7 @@ i386_pe_adjust_class_at_definition (tree t)\n \t      maybe_add_dllexport (thunk);\n \t}\n       /* Check vtables  */\n-      for (member = CLASSTYPE_VTABLES (t); member;  member = TREE_CHAIN (member))\n+      for (member = CLASSTYPE_VTABLES (t); member;  member = DECL_CHAIN (member))\n \tif (TREE_CODE (member) == VAR_DECL) \n \t  maybe_add_dllexport (member);\n     }\n@@ -132,25 +132,25 @@ i386_pe_adjust_class_at_definition (tree t)\n \t definition.   */\n \n       /* Check static VAR_DECL's.  */\n-      for (member = TYPE_FIELDS (t); member; member = TREE_CHAIN (member))\n+      for (member = TYPE_FIELDS (t); member; member = DECL_CHAIN (member))\n \tif (TREE_CODE (member) == VAR_DECL)     \n \t  maybe_add_dllimport (member);\n     \n       /* Check FUNCTION_DECL's.  */\n-      for (member = TYPE_METHODS (t); member;  member = TREE_CHAIN (member))\n+      for (member = TYPE_METHODS (t); member;  member = DECL_CHAIN (member))\n \tif (TREE_CODE (member) == FUNCTION_DECL)\n \t  {\n \t    tree thunk;\n \t    maybe_add_dllimport (member);\n \t  \n \t    /* Also add the attribute to its thunks.  */\n \t    for (thunk = DECL_THUNKS (member); thunk;\n-\t\t thunk = TREE_CHAIN (thunk))\n+\t\t thunk = DECL_CHAIN (thunk))\n \t      maybe_add_dllimport (thunk);\n \t }\n  \n       /* Check vtables  */\n-      for (member = CLASSTYPE_VTABLES (t); member;  member = TREE_CHAIN (member))\n+      for (member = CLASSTYPE_VTABLES (t); member;  member = DECL_CHAIN (member))\n \tif (TREE_CODE (member) == VAR_DECL) \n \t  maybe_add_dllimport (member);\n "}, {"sha": "475f3d9b5873af06efa4655a51a111f5e215f9d4", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -4160,7 +4160,7 @@ hfa_element_mode (const_tree type, bool nested)\n     case RECORD_TYPE:\n     case UNION_TYPE:\n     case QUAL_UNION_TYPE:\n-      for (t = TYPE_FIELDS (type); t; t = TREE_CHAIN (t))\n+      for (t = TYPE_FIELDS (type); t; t = DECL_CHAIN (t))\n \t{\n \t  if (TREE_CODE (t) != FIELD_DECL)\n \t    continue;"}, {"sha": "71642099120402fae60ef449cfac4aa79227808f", "filename": "gcc/config/iq2000/iq2000.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -1274,7 +1274,7 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode, const_tree type,\n \t{\n \t  tree field;\n \n-\t  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+\t  for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n \t    if (TREE_CODE (field) == FIELD_DECL\n \t\t&& TREE_CODE (TREE_TYPE (field)) == REAL_TYPE\n \t\t&& TYPE_PRECISION (TREE_TYPE (field)) == BITS_PER_WORD\n@@ -1311,7 +1311,7 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode, const_tree type,\n \t\t{\n \t\t  rtx reg;\n \n-\t\t  for (; field; field = TREE_CHAIN (field))\n+\t\t  for (; field; field = DECL_CHAIN (field))\n \t\t    if (TREE_CODE (field) == FIELD_DECL\n \t\t\t&& int_bit_position (field) >= bitpos)\n \t\t      break;\n@@ -1901,7 +1901,7 @@ iq2000_expand_prologue (void)\n \t\t\t\t\t      PARM_DECL, NULL_TREE, type);\n \n       DECL_ARG_TYPE (function_result_decl) = type;\n-      TREE_CHAIN (function_result_decl) = fnargs;\n+      DECL_CHAIN (function_result_decl) = fnargs;\n       fnargs = function_result_decl;\n     }\n \n@@ -1930,7 +1930,7 @@ iq2000_expand_prologue (void)\n       entry_parm = FUNCTION_ARG (args_so_far, passed_mode, passed_type, 1);\n \n       FUNCTION_ARG_ADVANCE (args_so_far, passed_mode, passed_type, 1);\n-      next_arg = TREE_CHAIN (cur_arg);\n+      next_arg = DECL_CHAIN (cur_arg);\n \n       if (entry_parm && store_args_on_stack)\n \t{"}, {"sha": "1d83d8d76e2ede3298ec39be0f914626900414cd", "filename": "gcc/config/mep/mep.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fconfig%2Fmep%2Fmep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fconfig%2Fmep%2Fmep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmep%2Fmep.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -3611,9 +3611,9 @@ mep_build_builtin_va_list (void)\n   DECL_FIELD_CONTEXT (f_next_stack) = record;\n \n   TYPE_FIELDS (record) = f_next_gp;\n-  TREE_CHAIN (f_next_gp) = f_next_gp_limit;\n-  TREE_CHAIN (f_next_gp_limit) = f_next_cop;\n-  TREE_CHAIN (f_next_cop) = f_next_stack;\n+  DECL_CHAIN (f_next_gp) = f_next_gp_limit;\n+  DECL_CHAIN (f_next_gp_limit) = f_next_cop;\n+  DECL_CHAIN (f_next_cop) = f_next_stack;\n \n   layout_type (record);\n \n@@ -3631,9 +3631,9 @@ mep_expand_va_start (tree valist, rtx nextarg)\n   ns = cfun->machine->arg_regs_to_save;\n \n   f_next_gp = TYPE_FIELDS (va_list_type_node);\n-  f_next_gp_limit = TREE_CHAIN (f_next_gp);\n-  f_next_cop = TREE_CHAIN (f_next_gp_limit);\n-  f_next_stack = TREE_CHAIN (f_next_cop);\n+  f_next_gp_limit = DECL_CHAIN (f_next_gp);\n+  f_next_cop = DECL_CHAIN (f_next_gp_limit);\n+  f_next_stack = DECL_CHAIN (f_next_cop);\n \n   next_gp = build3 (COMPONENT_REF, TREE_TYPE (f_next_gp), valist, f_next_gp,\n \t\t    NULL_TREE);\n@@ -3697,9 +3697,9 @@ mep_gimplify_va_arg_expr (tree valist, tree type,\n   rsize = (size + UNITS_PER_WORD - 1) & -UNITS_PER_WORD;\n \n   f_next_gp = TYPE_FIELDS (va_list_type_node);\n-  f_next_gp_limit = TREE_CHAIN (f_next_gp);\n-  f_next_cop = TREE_CHAIN (f_next_gp_limit);\n-  f_next_stack = TREE_CHAIN (f_next_cop);\n+  f_next_gp_limit = DECL_CHAIN (f_next_gp);\n+  f_next_cop = DECL_CHAIN (f_next_gp_limit);\n+  f_next_stack = DECL_CHAIN (f_next_cop);\n \n   next_gp = build3 (COMPONENT_REF, TREE_TYPE (f_next_gp), valist, f_next_gp,\n \t\t    NULL_TREE);"}, {"sha": "3d4ffaeabeb3c85de80193a8356ea5ddba1cbaa3", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -4857,7 +4857,7 @@ mips_function_arg (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n       tree field;\n \n       /* First check to see if there is any such field.  */\n-      for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+      for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n \tif (TREE_CODE (field) == FIELD_DECL\n \t    && SCALAR_FLOAT_TYPE_P (TREE_TYPE (field))\n \t    && TYPE_PRECISION (TREE_TYPE (field)) == BITS_PER_WORD\n@@ -4884,7 +4884,7 @@ mips_function_arg (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t    {\n \t      rtx reg;\n \n-\t      for (; field; field = TREE_CHAIN (field))\n+\t      for (; field; field = DECL_CHAIN (field))\n \t\tif (TREE_CODE (field) == FIELD_DECL\n \t\t    && int_bit_position (field) >= bitpos)\n \t\t  break;\n@@ -5122,7 +5122,7 @@ mips_fpr_return_fields (const_tree valtype, tree *fields)\n     return 0;\n \n   i = 0;\n-  for (field = TYPE_FIELDS (valtype); field != 0; field = TREE_CHAIN (field))\n+  for (field = TYPE_FIELDS (valtype); field != 0; field = DECL_CHAIN (field))\n     {\n       if (TREE_CODE (field) != FIELD_DECL)\n \tcontinue;\n@@ -5444,11 +5444,11 @@ mips_build_builtin_va_list (void)\n       DECL_FIELD_CONTEXT (f_res) = record;\n \n       TYPE_FIELDS (record) = f_ovfl;\n-      TREE_CHAIN (f_ovfl) = f_gtop;\n-      TREE_CHAIN (f_gtop) = f_ftop;\n-      TREE_CHAIN (f_ftop) = f_goff;\n-      TREE_CHAIN (f_goff) = f_foff;\n-      TREE_CHAIN (f_foff) = f_res;\n+      DECL_CHAIN (f_ovfl) = f_gtop;\n+      DECL_CHAIN (f_gtop) = f_ftop;\n+      DECL_CHAIN (f_ftop) = f_goff;\n+      DECL_CHAIN (f_goff) = f_foff;\n+      DECL_CHAIN (f_foff) = f_res;\n \n       layout_type (record);\n       return record;\n@@ -5483,10 +5483,10 @@ mips_va_start (tree valist, rtx nextarg)\n \t= (MAX_ARGS_IN_REGISTERS - cum->num_fprs) * UNITS_PER_FPREG;\n \n       f_ovfl = TYPE_FIELDS (va_list_type_node);\n-      f_gtop = TREE_CHAIN (f_ovfl);\n-      f_ftop = TREE_CHAIN (f_gtop);\n-      f_goff = TREE_CHAIN (f_ftop);\n-      f_foff = TREE_CHAIN (f_goff);\n+      f_gtop = DECL_CHAIN (f_ovfl);\n+      f_ftop = DECL_CHAIN (f_gtop);\n+      f_goff = DECL_CHAIN (f_ftop);\n+      f_foff = DECL_CHAIN (f_goff);\n \n       ovfl = build3 (COMPONENT_REF, TREE_TYPE (f_ovfl), valist, f_ovfl,\n \t\t     NULL_TREE);\n@@ -5568,10 +5568,10 @@ mips_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,\n       tree t, u;\n \n       f_ovfl = TYPE_FIELDS (va_list_type_node);\n-      f_gtop = TREE_CHAIN (f_ovfl);\n-      f_ftop = TREE_CHAIN (f_gtop);\n-      f_goff = TREE_CHAIN (f_ftop);\n-      f_foff = TREE_CHAIN (f_goff);\n+      f_gtop = DECL_CHAIN (f_ovfl);\n+      f_ftop = DECL_CHAIN (f_gtop);\n+      f_goff = DECL_CHAIN (f_ftop);\n+      f_foff = DECL_CHAIN (f_goff);\n \n       /* Let:\n "}, {"sha": "8be8deffe32aa449508b42728231de66f0146a4b", "filename": "gcc/config/pa/som.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fconfig%2Fpa%2Fsom.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fconfig%2Fpa%2Fsom.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fsom.h?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -118,7 +118,7 @@ do {\t\t\t\t\t\t\t\t\\\n \t\t fputs (\",PRIV_LEV=3\", FILE);\t\t\t\t\\\n \t       }\t\t\t\t\t\t\t\\\n \t     for (parm = DECL_ARGUMENTS (DECL), i = 0; parm && i < 4;\t\\\n-\t\t  parm = TREE_CHAIN (parm))\t\t\t\t\\\n+\t\t  parm = DECL_CHAIN (parm))\t\t\t\t\\\n \t       {\t\t\t\t\t\t\t\\\n \t\t if (TYPE_MODE (DECL_ARG_TYPE (parm)) == SFmode\t\t\\\n \t\t     && ! TARGET_SOFT_FLOAT)\t\t\t\t\\"}, {"sha": "c6f67d433eab987f55f9fd984a020d0a2d71390a", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -5093,7 +5093,7 @@ rs6000_special_round_type_align (tree type, unsigned int computed,\n \n   /* Skip all non field decls */\n   while (field != NULL && TREE_CODE (field) != FIELD_DECL)\n-    field = TREE_CHAIN (field);\n+    field = DECL_CHAIN (field);\n \n   if (field != NULL && field != type)\n     {\n@@ -5125,7 +5125,7 @@ darwin_rs6000_special_round_type_align (tree type, unsigned int computed,\n     tree field = TYPE_FIELDS (type);\n     /* Skip all non field decls */\n     while (field != NULL && TREE_CODE (field) != FIELD_DECL)\n-      field = TREE_CHAIN (field);\n+      field = DECL_CHAIN (field);\n     if (! field)\n       break;\n     /* A packed field does not contribute any extra alignment.  */\n@@ -7574,7 +7574,7 @@ rs6000_darwin64_record_arg_advance_recurse (CUMULATIVE_ARGS *cum,\n {\n   tree f;\n \n-  for (f = TYPE_FIELDS (type); f ; f = TREE_CHAIN (f))\n+  for (f = TYPE_FIELDS (type); f ; f = DECL_CHAIN (f))\n     if (TREE_CODE (f) == FIELD_DECL)\n       {\n \tHOST_WIDE_INT bitpos = startbitpos;\n@@ -7974,7 +7974,7 @@ rs6000_darwin64_record_arg_recurse (CUMULATIVE_ARGS *cum, const_tree type,\n {\n   tree f;\n \n-  for (f = TYPE_FIELDS (type); f ; f = TREE_CHAIN (f))\n+  for (f = TYPE_FIELDS (type); f ; f = DECL_CHAIN (f))\n     if (TREE_CODE (f) == FIELD_DECL)\n       {\n \tHOST_WIDE_INT bitpos = startbitpos;\n@@ -8801,10 +8801,10 @@ rs6000_build_builtin_va_list (void)\n   TREE_CHAIN (record) = type_decl;\n   TYPE_NAME (record) = type_decl;\n   TYPE_FIELDS (record) = f_gpr;\n-  TREE_CHAIN (f_gpr) = f_fpr;\n-  TREE_CHAIN (f_fpr) = f_res;\n-  TREE_CHAIN (f_res) = f_ovf;\n-  TREE_CHAIN (f_ovf) = f_sav;\n+  DECL_CHAIN (f_gpr) = f_fpr;\n+  DECL_CHAIN (f_fpr) = f_res;\n+  DECL_CHAIN (f_res) = f_ovf;\n+  DECL_CHAIN (f_ovf) = f_sav;\n \n   layout_type (record);\n \n@@ -8829,10 +8829,10 @@ rs6000_va_start (tree valist, rtx nextarg)\n     }\n \n   f_gpr = TYPE_FIELDS (TREE_TYPE (va_list_type_node));\n-  f_fpr = TREE_CHAIN (f_gpr);\n-  f_res = TREE_CHAIN (f_fpr);\n-  f_ovf = TREE_CHAIN (f_res);\n-  f_sav = TREE_CHAIN (f_ovf);\n+  f_fpr = DECL_CHAIN (f_gpr);\n+  f_res = DECL_CHAIN (f_fpr);\n+  f_ovf = DECL_CHAIN (f_res);\n+  f_sav = DECL_CHAIN (f_ovf);\n \n   valist = build_va_arg_indirect_ref (valist);\n   gpr = build3 (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr, NULL_TREE);\n@@ -8950,10 +8950,10 @@ rs6000_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,\n     }\n \n   f_gpr = TYPE_FIELDS (TREE_TYPE (va_list_type_node));\n-  f_fpr = TREE_CHAIN (f_gpr);\n-  f_res = TREE_CHAIN (f_fpr);\n-  f_ovf = TREE_CHAIN (f_res);\n-  f_sav = TREE_CHAIN (f_ovf);\n+  f_fpr = DECL_CHAIN (f_gpr);\n+  f_res = DECL_CHAIN (f_fpr);\n+  f_ovf = DECL_CHAIN (f_res);\n+  f_sav = DECL_CHAIN (f_ovf);\n \n   valist = build_va_arg_indirect_ref (valist);\n   gpr = build3 (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr, NULL_TREE);\n@@ -14292,7 +14292,7 @@ rs6000_alloc_sdmode_stack_slot (void)\n       }\n \n   /* Check for any SDmode parameters of the function.  */\n-  for (t = DECL_ARGUMENTS (cfun->decl); t; t = TREE_CHAIN (t))\n+  for (t = DECL_ARGUMENTS (cfun->decl); t; t = DECL_CHAIN (t))\n     {\n       if (TREE_TYPE (t) == error_mark_node)\n \tcontinue;\n@@ -21002,7 +21002,7 @@ rs6000_output_function_epilogue (FILE *file,\n \t  int next_parm_info_bit = 31;\n \n \t  for (decl = DECL_ARGUMENTS (current_function_decl);\n-\t       decl; decl = TREE_CHAIN (decl))\n+\t       decl; decl = DECL_CHAIN (decl))\n \t    {\n \t      rtx parameter = DECL_INCOMING_RTL (decl);\n \t      enum machine_mode mode = GET_MODE (parameter);"}, {"sha": "56cbac2022c8f990941d4a3031e4d02b8e3ed7c1", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -8283,7 +8283,7 @@ s390_function_arg_float (enum machine_mode mode, tree type)\n     {\n       tree field, single = NULL_TREE;\n \n-      for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+      for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n \t{\n \t  if (TREE_CODE (field) != FIELD_DECL)\n \t    continue;\n@@ -8591,9 +8591,9 @@ s390_build_builtin_va_list (void)\n   TREE_CHAIN (record) = type_decl;\n   TYPE_NAME (record) = type_decl;\n   TYPE_FIELDS (record) = f_gpr;\n-  TREE_CHAIN (f_gpr) = f_fpr;\n-  TREE_CHAIN (f_fpr) = f_ovf;\n-  TREE_CHAIN (f_ovf) = f_sav;\n+  DECL_CHAIN (f_gpr) = f_fpr;\n+  DECL_CHAIN (f_fpr) = f_ovf;\n+  DECL_CHAIN (f_ovf) = f_sav;\n \n   layout_type (record);\n \n@@ -8623,9 +8623,9 @@ s390_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n   tree gpr, fpr, ovf, sav, t;\n \n   f_gpr = TYPE_FIELDS (TREE_TYPE (va_list_type_node));\n-  f_fpr = TREE_CHAIN (f_gpr);\n-  f_ovf = TREE_CHAIN (f_fpr);\n-  f_sav = TREE_CHAIN (f_ovf);\n+  f_fpr = DECL_CHAIN (f_gpr);\n+  f_ovf = DECL_CHAIN (f_fpr);\n+  f_sav = DECL_CHAIN (f_ovf);\n \n   valist = build_va_arg_indirect_ref (valist);\n   gpr = build3 (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr, NULL_TREE);\n@@ -8721,9 +8721,9 @@ s390_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,\n   tree lab_false, lab_over, addr;\n \n   f_gpr = TYPE_FIELDS (TREE_TYPE (va_list_type_node));\n-  f_fpr = TREE_CHAIN (f_gpr);\n-  f_ovf = TREE_CHAIN (f_fpr);\n-  f_sav = TREE_CHAIN (f_ovf);\n+  f_fpr = DECL_CHAIN (f_gpr);\n+  f_ovf = DECL_CHAIN (f_fpr);\n+  f_sav = DECL_CHAIN (f_ovf);\n \n   valist = build_va_arg_indirect_ref (valist);\n   gpr = build3 (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr, NULL_TREE);"}, {"sha": "8ace99c732cdd849931be19605f0e5bdb2ef2b03", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -7694,10 +7694,10 @@ sh_build_builtin_va_list (void)\n   TREE_CHAIN (record) = type_decl;\n   TYPE_NAME (record) = type_decl;\n   TYPE_FIELDS (record) = f_next_o;\n-  TREE_CHAIN (f_next_o) = f_next_o_limit;\n-  TREE_CHAIN (f_next_o_limit) = f_next_fp;\n-  TREE_CHAIN (f_next_fp) = f_next_fp_limit;\n-  TREE_CHAIN (f_next_fp_limit) = f_next_stack;\n+  DECL_CHAIN (f_next_o) = f_next_o_limit;\n+  DECL_CHAIN (f_next_o_limit) = f_next_fp;\n+  DECL_CHAIN (f_next_fp) = f_next_fp_limit;\n+  DECL_CHAIN (f_next_fp_limit) = f_next_stack;\n \n   layout_type (record);\n \n@@ -7729,10 +7729,10 @@ sh_va_start (tree valist, rtx nextarg)\n     }\n \n   f_next_o = TYPE_FIELDS (va_list_type_node);\n-  f_next_o_limit = TREE_CHAIN (f_next_o);\n-  f_next_fp = TREE_CHAIN (f_next_o_limit);\n-  f_next_fp_limit = TREE_CHAIN (f_next_fp);\n-  f_next_stack = TREE_CHAIN (f_next_fp_limit);\n+  f_next_o_limit = DECL_CHAIN (f_next_o);\n+  f_next_fp = DECL_CHAIN (f_next_o_limit);\n+  f_next_fp_limit = DECL_CHAIN (f_next_fp);\n+  f_next_stack = DECL_CHAIN (f_next_fp_limit);\n \n   next_o = build3 (COMPONENT_REF, TREE_TYPE (f_next_o), valist, f_next_o,\n \t\t   NULL_TREE);\n@@ -7791,7 +7791,7 @@ find_sole_member (tree type)\n {\n   tree field, member = NULL_TREE;\n \n-  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+  for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n     {\n       if (TREE_CODE (field) != FIELD_DECL)\n \tcontinue;\n@@ -7834,10 +7834,10 @@ sh_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,\n       tree member;\n \n       f_next_o = TYPE_FIELDS (va_list_type_node);\n-      f_next_o_limit = TREE_CHAIN (f_next_o);\n-      f_next_fp = TREE_CHAIN (f_next_o_limit);\n-      f_next_fp_limit = TREE_CHAIN (f_next_fp);\n-      f_next_stack = TREE_CHAIN (f_next_fp_limit);\n+      f_next_o_limit = DECL_CHAIN (f_next_o);\n+      f_next_fp = DECL_CHAIN (f_next_o_limit);\n+      f_next_fp_limit = DECL_CHAIN (f_next_fp);\n+      f_next_stack = DECL_CHAIN (f_next_fp_limit);\n \n       next_o = build3 (COMPONENT_REF, TREE_TYPE (f_next_o), valist, f_next_o,\n \t\t       NULL_TREE);"}, {"sha": "5f1ef93ca6e6605dc3b10f2fd4d35c6160374c13", "filename": "gcc/config/sh/symbian-cxx.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fconfig%2Fsh%2Fsymbian-cxx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fconfig%2Fsh%2Fsymbian-cxx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsymbian-cxx.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -630,7 +630,7 @@ sh_symbian_handle_dll_attribute (tree *pnode, tree name, tree args,\n \t  sh_symbian_add_attribute (function, attr);\n \n \t  /* Propagate the attribute to any function thunks as well.  */\n-\t  for (thunk = DECL_THUNKS (function); thunk; thunk = TREE_CHAIN (thunk))\n+\t  for (thunk = DECL_THUNKS (function); thunk; thunk = DECL_CHAIN (thunk))\n \t    if (TREE_CODE (thunk) == FUNCTION_DECL)\n \t      sh_symbian_add_attribute (thunk, attr);\n \t}\n@@ -639,7 +639,7 @@ sh_symbian_handle_dll_attribute (tree *pnode, tree name, tree args,\n   if (TREE_CODE (node) == FUNCTION_DECL && DECL_VIRTUAL_P (node))\n     {\n       /* Propagate the attribute to any thunks of this function.  */\n-      for (thunk = DECL_THUNKS (node); thunk; thunk = TREE_CHAIN (thunk))\n+      for (thunk = DECL_THUNKS (node); thunk; thunk = DECL_CHAIN (thunk))\n \tif (TREE_CODE (thunk) == FUNCTION_DECL)\n \t  sh_symbian_add_attribute (thunk, attr);\n     }"}, {"sha": "d476955403345bff150ac500a365d4d0e388b62b", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -4873,7 +4873,7 @@ scan_record_type (tree type, int *intregs_p, int *fpregs_p, int *packed_p)\n {\n   tree field;\n \n-  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+  for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n     {\n       if (TREE_CODE (field) == FIELD_DECL)\n \t{\n@@ -5093,7 +5093,7 @@ function_arg_record_value_1 (const_tree type, HOST_WIDE_INT startbitpos,\n       }\n \n   /* Compute how many registers we need.  */\n-  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+  for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n     {\n       if (TREE_CODE (field) == FIELD_DECL)\n \t{\n@@ -5232,7 +5232,7 @@ function_arg_record_value_2 (const_tree type, HOST_WIDE_INT startbitpos,\n   tree field;\n \n   if (! packed_p)\n-    for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+    for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n       {\n \tif (TREE_CODE (field) == FIELD_DECL && DECL_PACKED (field))\n \t  {\n@@ -5241,7 +5241,7 @@ function_arg_record_value_2 (const_tree type, HOST_WIDE_INT startbitpos,\n \t  }\n       }\n \n-  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+  for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n     {\n       if (TREE_CODE (field) == FIELD_DECL)\n \t{"}, {"sha": "689b50048ffa1f79efe2dd9e792a7bc18b1d0da7", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -4076,7 +4076,7 @@ spu_build_builtin_va_list (void)\n   TREE_CHAIN (record) = type_decl;\n   TYPE_NAME (record) = type_decl;\n   TYPE_FIELDS (record) = f_args;\n-  TREE_CHAIN (f_args) = f_skip;\n+  DECL_CHAIN (f_args) = f_skip;\n \n   /* We know this is being padded and we want it too.  It is an internal\n      type so hide the warnings from the user. */\n@@ -4111,7 +4111,7 @@ spu_va_start (tree valist, rtx nextarg)\n   tree args, skip, t;\n \n   f_args = TYPE_FIELDS (TREE_TYPE (va_list_type_node));\n-  f_skip = TREE_CHAIN (f_args);\n+  f_skip = DECL_CHAIN (f_args);\n \n   valist = build_va_arg_indirect_ref (valist);\n   args =\n@@ -4166,7 +4166,7 @@ spu_gimplify_va_arg_expr (tree valist, tree type, gimple_seq * pre_p,\n   bool pass_by_reference_p;\n \n   f_args = TYPE_FIELDS (TREE_TYPE (va_list_type_node));\n-  f_skip = TREE_CHAIN (f_args);\n+  f_skip = DECL_CHAIN (f_args);\n \n   valist = build_simple_mem_ref (valist);\n   args ="}, {"sha": "bdfd07d0c4cce56aeab916588ee1702665a6ddfa", "filename": "gcc/config/stormy16/stormy16.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -1317,7 +1317,7 @@ xstormy16_build_builtin_va_list (void)\n   TREE_CHAIN (record) = type_decl;\n   TYPE_NAME (record) = type_decl;\n   TYPE_FIELDS (record) = f_1;\n-  TREE_CHAIN (f_1) = f_2;\n+  DECL_CHAIN (f_1) = f_2;\n \n   layout_type (record);\n \n@@ -1340,7 +1340,7 @@ xstormy16_expand_builtin_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n     error (\"cannot use va_start in interrupt function\");\n \n   f_base = TYPE_FIELDS (va_list_type_node);\n-  f_count = TREE_CHAIN (f_base);\n+  f_count = DECL_CHAIN (f_base);\n \n   base = build3 (COMPONENT_REF, TREE_TYPE (f_base), valist, f_base, NULL_TREE);\n   count = build3 (COMPONENT_REF, TREE_TYPE (f_count), valist, f_count,\n@@ -1377,7 +1377,7 @@ xstormy16_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,\n   tree size_tree;\n \n   f_base = TYPE_FIELDS (va_list_type_node);\n-  f_count = TREE_CHAIN (f_base);\n+  f_count = DECL_CHAIN (f_base);\n \n   base = build3 (COMPONENT_REF, TREE_TYPE (f_base), valist, f_base, NULL_TREE);\n   count = build3 (COMPONENT_REF, TREE_TYPE (f_count), valist, f_count,"}, {"sha": "94e412d25b011f9f0dcd0cad2f1f9908f8712c62", "filename": "gcc/config/vxworks.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fconfig%2Fvxworks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fconfig%2Fvxworks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvxworks.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -78,13 +78,13 @@ vxworks_emutls_var_fields (tree type, tree *name)\n   field = build_decl (FIELD_DECL, get_identifier (\"module_id\"),\n \t\t      unsigned_type_node);\n   DECL_CONTEXT (field) = type;\n-  TREE_CHAIN (field) = next_field;\n+  DECL_CHAIN (field) = next_field;\n   next_field = field;\n \n   field = build_decl (FIELD_DECL, get_identifier (\"offset\"),\n \t\t      unsigned_type_node);\n   DECL_CONTEXT (field) = type;\n-  TREE_CHAIN (field) = next_field;\n+  DECL_CHAIN (field) = next_field;\n \n   return field;\n }\n@@ -108,12 +108,12 @@ vxworks_emutls_var_init (tree var, tree decl, tree tmpl_addr)\n   elt->value = fold_convert (TREE_TYPE (field), tmpl_addr);\n   \n   elt = VEC_quick_push (constructor_elt, v, NULL);\n-  field = TREE_CHAIN (field);\n+  field = DECL_CHAIN (field);\n   elt->index = field;\n   elt->value = build_int_cst (TREE_TYPE (field), 0);\n   \n   elt = VEC_quick_push (constructor_elt, v, NULL);\n-  field = TREE_CHAIN (field);\n+  field = DECL_CHAIN (field);\n   elt->index = field;\n   elt->value = fold_convert (TREE_TYPE (field), DECL_SIZE_UNIT (decl));\n   "}, {"sha": "610a2723cd21f0c7cb07c15629f37eeafb2702b6", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -2685,8 +2685,8 @@ xtensa_build_builtin_va_list (void)\n   TREE_CHAIN (record) = type_decl;\n   TYPE_NAME (record) = type_decl;\n   TYPE_FIELDS (record) = f_stk;\n-  TREE_CHAIN (f_stk) = f_reg;\n-  TREE_CHAIN (f_reg) = f_ndx;\n+  DECL_CHAIN (f_stk) = f_reg;\n+  DECL_CHAIN (f_reg) = f_ndx;\n \n   layout_type (record);\n   return record;\n@@ -2740,8 +2740,8 @@ xtensa_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n   arg_words = crtl->args.info.arg_words;\n \n   f_stk = TYPE_FIELDS (va_list_type_node);\n-  f_reg = TREE_CHAIN (f_stk);\n-  f_ndx = TREE_CHAIN (f_reg);\n+  f_reg = DECL_CHAIN (f_stk);\n+  f_ndx = DECL_CHAIN (f_reg);\n \n   stk = build3 (COMPONENT_REF, TREE_TYPE (f_stk), valist, f_stk, NULL_TREE);\n   reg = build3 (COMPONENT_REF, TREE_TYPE (f_reg), unshare_expr (valist),\n@@ -2810,8 +2810,8 @@ xtensa_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,\n     }\n \n   f_stk = TYPE_FIELDS (va_list_type_node);\n-  f_reg = TREE_CHAIN (f_stk);\n-  f_ndx = TREE_CHAIN (f_reg);\n+  f_reg = DECL_CHAIN (f_stk);\n+  f_ndx = DECL_CHAIN (f_reg);\n \n   stk = build3 (COMPONENT_REF, TREE_TYPE (f_stk), valist,\n \t\tf_stk, NULL_TREE);"}, {"sha": "20aaa1074ce138c6aa48c05888dbf1ab9c68b86b", "filename": "gcc/coverage.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -648,7 +648,7 @@ build_fn_info_type (unsigned int counters)\n   /* checksum */\n   field = build_decl (BUILTINS_LOCATION,\n \t\t      FIELD_DECL, NULL_TREE, get_gcov_unsigned_t ());\n-  TREE_CHAIN (field) = fields;\n+  DECL_CHAIN (field) = fields;\n   fields = field;\n \n   array_type = build_int_cst (NULL_TREE, counters - 1);\n@@ -658,7 +658,7 @@ build_fn_info_type (unsigned int counters)\n   /* counters */\n   field = build_decl (BUILTINS_LOCATION,\n \t\t      FIELD_DECL, NULL_TREE, array_type);\n-  TREE_CHAIN (field) = fields;\n+  DECL_CHAIN (field) = fields;\n   fields = field;\n \n   finish_builtin_struct (type, \"__gcov_fn_info\", fields, NULL_TREE);\n@@ -682,13 +682,13 @@ build_fn_info_value (const struct function_list *function, tree type)\n   CONSTRUCTOR_APPEND_ELT (v1, fields,\n \t\t\t  build_int_cstu (get_gcov_unsigned_t (),\n \t\t\t\t\t  function->ident));\n-  fields = TREE_CHAIN (fields);\n+  fields = DECL_CHAIN (fields);\n \n   /* checksum */\n   CONSTRUCTOR_APPEND_ELT (v1, fields,\n \t\t\t  build_int_cstu (get_gcov_unsigned_t (),\n \t\t\t\t\t  function->checksum));\n-  fields = TREE_CHAIN (fields);\n+  fields = DECL_CHAIN (fields);\n \n   /* counters */\n   for (ix = 0; ix != GCOV_COUNTERS; ix++)\n@@ -716,13 +716,13 @@ build_ctr_info_type (void)\n   /* counters */\n   field = build_decl (BUILTINS_LOCATION,\n \t\t      FIELD_DECL, NULL_TREE, get_gcov_unsigned_t ());\n-  TREE_CHAIN (field) = fields;\n+  DECL_CHAIN (field) = fields;\n   fields = field;\n \n   /* values */\n   field = build_decl (BUILTINS_LOCATION,\n \t\t      FIELD_DECL, NULL_TREE, gcov_ptr_type);\n-  TREE_CHAIN (field) = fields;\n+  DECL_CHAIN (field) = fields;\n   fields = field;\n \n   /* merge */\n@@ -733,7 +733,7 @@ build_ctr_info_type (void)\n   field = build_decl (BUILTINS_LOCATION,\n \t\t      FIELD_DECL, NULL_TREE,\n \t\t      build_pointer_type (gcov_merge_fn_type));\n-  TREE_CHAIN (field) = fields;\n+  DECL_CHAIN (field) = fields;\n   fields = field;\n \n   finish_builtin_struct (type, \"__gcov_ctr_info\", fields, NULL_TREE);\n@@ -756,7 +756,7 @@ build_ctr_info_value (unsigned int counter, tree type)\n   CONSTRUCTOR_APPEND_ELT (v, fields,\n \t\t\t  build_int_cstu (get_gcov_unsigned_t (),\n \t\t\t\t\t  prg_n_ctrs[counter]));\n-  fields = TREE_CHAIN (fields);\n+  fields = DECL_CHAIN (fields);\n \n   if (prg_n_ctrs[counter])\n     {\n@@ -779,7 +779,7 @@ build_ctr_info_value (unsigned int counter, tree type)\n     }\n   else\n     CONSTRUCTOR_APPEND_ELT (v, fields, null_pointer_node);\n-  fields = TREE_CHAIN (fields);\n+  fields = DECL_CHAIN (fields);\n \n   fn = build_decl (BUILTINS_LOCATION,\n \t\t   FUNCTION_DECL,\n@@ -826,22 +826,22 @@ build_gcov_info (void)\n   /* Version ident */\n   field = build_decl (BUILTINS_LOCATION,\n \t\t      FIELD_DECL, NULL_TREE, get_gcov_unsigned_t ());\n-  TREE_CHAIN (field) = fields;\n+  DECL_CHAIN (field) = fields;\n   fields = field;\n   CONSTRUCTOR_APPEND_ELT (v1, field,\n \t\t\t  build_int_cstu (TREE_TYPE (field), GCOV_VERSION));\n \n   /* next -- NULL */\n   field = build_decl (BUILTINS_LOCATION,\n \t\t      FIELD_DECL, NULL_TREE, build_pointer_type (const_type));\n-  TREE_CHAIN (field) = fields;\n+  DECL_CHAIN (field) = fields;\n   fields = field;\n   CONSTRUCTOR_APPEND_ELT (v1, field, null_pointer_node);\n \n   /* stamp */\n   field = build_decl (BUILTINS_LOCATION,\n \t\t      FIELD_DECL, NULL_TREE, get_gcov_unsigned_t ());\n-  TREE_CHAIN (field) = fields;\n+  DECL_CHAIN (field) = fields;\n   fields = field;\n   CONSTRUCTOR_APPEND_ELT (v1, field,\n \t\t\t  build_int_cstu (TREE_TYPE (field), local_tick));\n@@ -851,7 +851,7 @@ build_gcov_info (void)\n \t\t\t\t\t\t    TYPE_QUAL_CONST));\n   field = build_decl (BUILTINS_LOCATION,\n \t\t      FIELD_DECL, NULL_TREE, string_type);\n-  TREE_CHAIN (field) = fields;\n+  DECL_CHAIN (field) = fields;\n   fields = field;\n   da_file_name_len = strlen (da_file_name);\n   filename_string = build_string (da_file_name_len + 1, da_file_name);\n@@ -885,22 +885,22 @@ build_gcov_info (void)\n   /* number of functions */\n   field = build_decl (BUILTINS_LOCATION,\n \t\t      FIELD_DECL, NULL_TREE, get_gcov_unsigned_t ());\n-  TREE_CHAIN (field) = fields;\n+  DECL_CHAIN (field) = fields;\n   fields = field;\n   CONSTRUCTOR_APPEND_ELT (v1, field,\n \t\t\t  build_int_cstu (get_gcov_unsigned_t (), n_fns));\n \n   /* fn_info table */\n   field = build_decl (BUILTINS_LOCATION,\n \t\t      FIELD_DECL, NULL_TREE, fn_info_ptr_type);\n-  TREE_CHAIN (field) = fields;\n+  DECL_CHAIN (field) = fields;\n   fields = field;\n   CONSTRUCTOR_APPEND_ELT (v1, field, fn_info_value);\n \n   /* counter_mask */\n   field = build_decl (BUILTINS_LOCATION,\n \t\t      FIELD_DECL, NULL_TREE, get_gcov_unsigned_t ());\n-  TREE_CHAIN (field) = fields;\n+  DECL_CHAIN (field) = fields;\n   fields = field;\n   CONSTRUCTOR_APPEND_ELT (v1, field, \n \t\t\t  build_int_cstu (get_gcov_unsigned_t (),\n@@ -920,7 +920,7 @@ build_gcov_info (void)\n \n   field = build_decl (BUILTINS_LOCATION,\n \t\t      FIELD_DECL, NULL_TREE, ctr_info_ary_type);\n-  TREE_CHAIN (field) = fields;\n+  DECL_CHAIN (field) = fields;\n   fields = field;\n   CONSTRUCTOR_APPEND_ELT (v1, field, ctr_info_value);\n "}, {"sha": "8b1399c81e6e43324aaa3ffb0d78fd8a7ba19de8", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -1,3 +1,23 @@\n+2010-07-15  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* cp-tree.h: Carefully replace TREE_CHAIN with DECL_CHAIN.\n+\t* call.c: Likewise.\n+\t* class.c: Likewise.\n+\t* cp-gimplify.c: Likewise.\n+\t* decl.c: Likewise.\n+\t* decl2.c: Likewise.\n+\t* init.c: Likewise.\n+\t* mangle.c: Likewise.\n+\t* name-lookup.c: Likewise.\n+\t* optimize.c: Likewise.\n+\t* parser.c: Likewise.\n+\t* pt.c: Likewise.\n+\t* rtti.c: Likewise.\n+\t* search.c: Likewise.\n+\t* semantics.c: Likewise.\n+\t* typeck.c: Likewise.\n+\t* typeck2.c: Likewise.\n+\n 2010-07-14  Jason Merrill  <jason@redhat.com>\n \n \t* init.c (sort_mem_initializers): Rename \"field_type\" to \"ctx\"."}, {"sha": "8e259ee6e0ded62ea0c359a0c7908cbc06403e2e", "filename": "gcc/cp/call.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -641,7 +641,7 @@ build_aggr_conv (tree type, tree ctor, int flags)\n   tree field = next_initializable_field (TYPE_FIELDS (type));\n   tree empty_ctor = NULL_TREE;\n \n-  for (; field; field = next_initializable_field (TREE_CHAIN (field)))\n+  for (; field; field = next_initializable_field (DECL_CHAIN (field)))\n     {\n       if (i < CONSTRUCTOR_NELTS (ctor))\n \t{\n@@ -6095,7 +6095,7 @@ build_java_interface_fn_ref (tree fn, tree instance)\n \n   /* Determine the itable index of FN.  */\n   i = 1;\n-  for (method = TYPE_METHODS (iface); method; method = TREE_CHAIN (method))\n+  for (method = TYPE_METHODS (iface); method; method = DECL_CHAIN (method))\n     {\n       if (!DECL_VIRTUAL_P (method))\n \tcontinue;\n@@ -6227,7 +6227,7 @@ build_special_member_call (tree instance, tree name, VEC(tree,gc) **args,\n       /* If the current function is a complete object constructor\n \t or destructor, then we fetch the VTT directly.\n \t Otherwise, we look it up using the VTT we were given.  */\n-      vtt = TREE_CHAIN (CLASSTYPE_VTABLES (current_class_type));\n+      vtt = DECL_CHAIN (CLASSTYPE_VTABLES (current_class_type));\n       vtt = decay_conversion (vtt);\n       vtt = build3 (COND_EXPR, TREE_TYPE (vtt),\n \t\t    build2 (EQ_EXPR, boolean_type_node,"}, {"sha": "79b5a26d77522c3f420e4de54dbbddb6b5e2bc45", "filename": "gcc/cp/class.c", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -469,7 +469,7 @@ build_simple_base_path (tree expr, tree binfo)\n   expr = build_simple_base_path (expr, d_binfo);\n \n   for (field = TYPE_FIELDS (BINFO_TYPE (d_binfo));\n-       field; field = TREE_CHAIN (field))\n+       field; field = DECL_CHAIN (field))\n     /* Is this the base field created by build_base_field?  */\n     if (TREE_CODE (field) == FIELD_DECL\n \t&& DECL_FIELD_IS_BASE (field)\n@@ -1262,7 +1262,7 @@ check_bases (tree t,\n   seen_non_virtual_nearly_empty_base_p = 0;\n \n   if (!CLASSTYPE_NON_STD_LAYOUT (t))\n-    for (field = TYPE_FIELDS (t); field; field = TREE_CHAIN (field))\n+    for (field = TYPE_FIELDS (t); field; field = DECL_CHAIN (field))\n       if (TREE_CODE (field) == FIELD_DECL)\n \tbreak;\n \n@@ -1351,7 +1351,7 @@ check_bases (tree t,\n \t       members, or has no base classes with non-static data\n \t       members */\n \t    for (basefield = TYPE_FIELDS (basetype); basefield;\n-\t\t basefield = TREE_CHAIN (basefield))\n+\t\t basefield = DECL_CHAIN (basefield))\n \t      if (TREE_CODE (basefield) == FIELD_DECL)\n \t\t{\n \t\t  if (field)\n@@ -1609,7 +1609,7 @@ maybe_warn_about_overly_private_class (tree t)\n      functions are private.  (Since there are no friends or\n      non-private statics, we can't ever call any of the private member\n      functions.)  */\n-  for (fn = TYPE_METHODS (t); fn; fn = TREE_CHAIN (fn))\n+  for (fn = TYPE_METHODS (t); fn; fn = DECL_CHAIN (fn))\n     /* We're not interested in compiler-generated methods; they don't\n        provide any way to call private members.  */\n     if (!DECL_ARTIFICIAL (fn))\n@@ -1814,7 +1814,7 @@ finish_struct_methods (tree t)\n \n   /* Clear DECL_IN_AGGR_P for all functions.  */\n   for (fn_fields = TYPE_METHODS (t); fn_fields;\n-       fn_fields = TREE_CHAIN (fn_fields))\n+       fn_fields = DECL_CHAIN (fn_fields))\n     DECL_IN_AGGR_P (fn_fields) = 0;\n \n   /* Issue warnings about private constructors and such.  If there are\n@@ -2545,7 +2545,7 @@ finish_struct_anon (tree t)\n {\n   tree field;\n \n-  for (field = TYPE_FIELDS (t); field; field = TREE_CHAIN (field))\n+  for (field = TYPE_FIELDS (t); field; field = DECL_CHAIN (field))\n     {\n       if (TREE_STATIC (field))\n \tcontinue;\n@@ -2557,7 +2557,7 @@ finish_struct_anon (tree t)\n \t{\n \t  bool is_union = TREE_CODE (TREE_TYPE (field)) == UNION_TYPE;\n \t  tree elt = TYPE_FIELDS (TREE_TYPE (field));\n-\t  for (; elt; elt = TREE_CHAIN (elt))\n+\t  for (; elt; elt = DECL_CHAIN (elt))\n \t    {\n \t      /* We're generally only interested in entities the user\n \t\t declared, but we also find nested classes by noticing\n@@ -2750,7 +2750,7 @@ count_fields (tree fields)\n {\n   tree x;\n   int n_fields = 0;\n-  for (x = fields; x; x = TREE_CHAIN (x))\n+  for (x = fields; x; x = DECL_CHAIN (x))\n     {\n       if (TREE_CODE (x) == FIELD_DECL && ANON_AGGR_TYPE_P (TREE_TYPE (x)))\n \tn_fields += count_fields (TYPE_FIELDS (TREE_TYPE (x)));\n@@ -2767,7 +2767,7 @@ static int\n add_fields_to_record_type (tree fields, struct sorted_fields_type *field_vec, int idx)\n {\n   tree x;\n-  for (x = fields; x; x = TREE_CHAIN (x))\n+  for (x = fields; x; x = DECL_CHAIN (x))\n     {\n       if (TREE_CODE (x) == FIELD_DECL && ANON_AGGR_TYPE_P (TREE_TYPE (x)))\n \tidx = add_fields_to_record_type (TYPE_FIELDS (TREE_TYPE (x)), field_vec, idx);\n@@ -2874,7 +2874,7 @@ check_field_decl (tree field,\n     {\n       tree fields;\n \n-      for (fields = TYPE_FIELDS (type); fields; fields = TREE_CHAIN (fields))\n+      for (fields = TYPE_FIELDS (type); fields; fields = DECL_CHAIN (fields))\n \tif (TREE_CODE (fields) == FIELD_DECL && !DECL_C_BIT_FIELD (field))\n \t  check_field_decl (fields, t, cant_have_const_ctor,\n \t\t\t    no_const_asn_ref, any_default_members,\n@@ -2999,12 +2999,12 @@ check_field_decls (tree t, tree *access_decls,\n       tree type = TREE_TYPE (x);\n       int this_field_access;\n \n-      next = &TREE_CHAIN (x);\n+      next = &DECL_CHAIN (x);\n \n       if (TREE_CODE (x) == USING_DECL)\n \t{\n \t  /* Prune the access declaration from the list of fields.  */\n-\t  *field = TREE_CHAIN (x);\n+\t  *field = DECL_CHAIN (x);\n \n \t  /* Save the access declarations for our caller.  */\n \t  *access_decls = tree_cons (NULL_TREE, x, *access_decls);\n@@ -3439,7 +3439,7 @@ walk_subobject_offsets (tree type,\n \t}\n \n       /* Iterate through the fields of TYPE.  */\n-      for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+      for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n \tif (TREE_CODE (field) == FIELD_DECL && !DECL_ARTIFICIAL (field))\n \t  {\n \t    tree field_offset;\n@@ -3788,9 +3788,9 @@ build_base_field (record_layout_info rli, tree binfo,\n \t     objects of the same type at the same address.  */\n \t  layout_nonempty_base_or_field (rli, decl, binfo, offsets);\n \t  /* Add the new FIELD_DECL to the list of fields for T.  */\n-\t  TREE_CHAIN (decl) = *next_field;\n+\t  DECL_CHAIN (decl) = *next_field;\n \t  *next_field = decl;\n-\t  next_field = &TREE_CHAIN (decl);\n+\t  next_field = &DECL_CHAIN (decl);\n \t}\n     }\n   else\n@@ -3902,7 +3902,7 @@ check_methods (tree t)\n {\n   tree x;\n \n-  for (x = TYPE_METHODS (t); x; x = TREE_CHAIN (x))\n+  for (x = TYPE_METHODS (t); x; x = DECL_CHAIN (x))\n     {\n       check_for_override (x, t);\n       if (DECL_PURE_VIRTUAL_P (x) && ! DECL_VINDEX (x))\n@@ -3941,8 +3941,8 @@ build_clone (tree fn, tree name)\n   /* Remember where this function came from.  */\n   DECL_ABSTRACT_ORIGIN (clone) = fn;\n   /* Make it easy to find the CLONE given the FN.  */\n-  TREE_CHAIN (clone) = TREE_CHAIN (fn);\n-  TREE_CHAIN (fn) = clone;\n+  DECL_CHAIN (clone) = DECL_CHAIN (fn);\n+  DECL_CHAIN (fn) = clone;\n \n   /* If this is a template, do the rest on the DECL_TEMPLATE_RESULT.  */\n   if (TREE_CODE (clone) == TEMPLATE_DECL)\n@@ -4006,8 +4006,8 @@ build_clone (tree fn, tree name)\n   /* Remove the in-charge parameter.  */\n   if (DECL_HAS_IN_CHARGE_PARM_P (clone))\n     {\n-      TREE_CHAIN (DECL_ARGUMENTS (clone))\n-\t= TREE_CHAIN (TREE_CHAIN (DECL_ARGUMENTS (clone)));\n+      DECL_CHAIN (DECL_ARGUMENTS (clone))\n+\t= DECL_CHAIN (DECL_CHAIN (DECL_ARGUMENTS (clone)));\n       DECL_HAS_IN_CHARGE_PARM_P (clone) = 0;\n     }\n   /* And the VTT parm, in a complete [cd]tor.  */\n@@ -4017,13 +4017,13 @@ build_clone (tree fn, tree name)\n \tDECL_HAS_VTT_PARM_P (clone) = 1;\n       else\n \t{\n-\t  TREE_CHAIN (DECL_ARGUMENTS (clone))\n-\t    = TREE_CHAIN (TREE_CHAIN (DECL_ARGUMENTS (clone)));\n+\t  DECL_CHAIN (DECL_ARGUMENTS (clone))\n+\t    = DECL_CHAIN (DECL_CHAIN (DECL_ARGUMENTS (clone)));\n \t  DECL_HAS_VTT_PARM_P (clone) = 0;\n \t}\n     }\n \n-  for (parms = DECL_ARGUMENTS (clone); parms; parms = TREE_CHAIN (parms))\n+  for (parms = DECL_ARGUMENTS (clone); parms; parms = DECL_CHAIN (parms))\n     {\n       DECL_CONTEXT (parms) = clone;\n       cxx_dup_lang_specific_decl (parms);\n@@ -4086,8 +4086,8 @@ clone_function_decl (tree fn, int update_method_vec_p)\n   tree clone;\n \n   /* Avoid inappropriate cloning.  */\n-  if (TREE_CHAIN (fn)\n-      && DECL_CLONED_FUNCTION_P (TREE_CHAIN (fn)))\n+  if (DECL_CHAIN (fn)\n+      && DECL_CLONED_FUNCTION_P (DECL_CHAIN (fn)))\n     return;\n \n   if (DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (fn))\n@@ -4144,8 +4144,8 @@ adjust_clone_args (tree decl)\n {\n   tree clone;\n \n-  for (clone = TREE_CHAIN (decl); clone && DECL_CLONED_FUNCTION_P (clone);\n-       clone = TREE_CHAIN (clone))\n+  for (clone = DECL_CHAIN (decl); clone && DECL_CLONED_FUNCTION_P (clone);\n+       clone = DECL_CHAIN (clone))\n     {\n       tree orig_clone_parms = TYPE_ARG_TYPES (TREE_TYPE (clone));\n       tree orig_decl_parms = TYPE_ARG_TYPES (TREE_TYPE (decl));\n@@ -4416,9 +4416,9 @@ remove_zero_width_bit_fields (tree t)\n \t     check_bitfield_decl eventually sets DECL_SIZE (*fieldsp)\n \t     to that width.  */\n \t  && integer_zerop (DECL_SIZE (*fieldsp)))\n-\t*fieldsp = TREE_CHAIN (*fieldsp);\n+\t*fieldsp = DECL_CHAIN (*fieldsp);\n       else\n-\tfieldsp = &TREE_CHAIN (*fieldsp);\n+\tfieldsp = &DECL_CHAIN (*fieldsp);\n     }\n }\n \n@@ -4577,7 +4577,7 @@ check_bases_and_members (tree t)\n     {\n       tree field;\n \n-      for (field = TYPE_FIELDS (t); field; field = TREE_CHAIN (field))\n+      for (field = TYPE_FIELDS (t); field; field = DECL_CHAIN (field))\n \t{\n \t  tree type;\n \n@@ -4605,7 +4605,7 @@ check_bases_and_members (tree t)\n \n   /* Check defaulted declarations here so we have cant_have_const_ctor\n      and don't need to worry about clones.  */\n-  for (fn = TYPE_METHODS (t); fn; fn = TREE_CHAIN (fn))\n+  for (fn = TYPE_METHODS (t); fn; fn = DECL_CHAIN (fn))\n     if (DECL_DEFAULTED_IN_CLASS_P (fn))\n       {\n \tint copy = copy_fn_p (fn);\n@@ -4671,7 +4671,7 @@ create_vtable_ptr (tree t, tree* virtuals_p)\n   tree fn;\n \n   /* Collect the virtual functions declared in T.  */\n-  for (fn = TYPE_METHODS (t); fn; fn = TREE_CHAIN (fn))\n+  for (fn = TYPE_METHODS (t); fn; fn = DECL_CHAIN (fn))\n     if (DECL_VINDEX (fn) && !DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (fn)\n \t&& TREE_CODE (DECL_VINDEX (fn)) != INTEGER_CST)\n       {\n@@ -4806,7 +4806,7 @@ layout_virtual_bases (record_layout_info rli, splay_tree offsets)\n      bases will go after the last extant field to date.  */\n   next_field = &TYPE_FIELDS (t);\n   while (*next_field)\n-    next_field = &TREE_CHAIN (*next_field);\n+    next_field = &DECL_CHAIN (*next_field);\n \n   /* Go through the virtual bases, allocating space for each virtual\n      base that is not already a primary base class.  These are\n@@ -5047,9 +5047,9 @@ layout_class_type (tree t, tree *virtuals_p)\n   /* The vptr is always the first thing in the class.  */\n   if (vptr)\n     {\n-      TREE_CHAIN (vptr) = TYPE_FIELDS (t);\n+      DECL_CHAIN (vptr) = TYPE_FIELDS (t);\n       TYPE_FIELDS (t) = vptr;\n-      next_field = &TREE_CHAIN (vptr);\n+      next_field = &DECL_CHAIN (vptr);\n       place_field (rli, vptr);\n     }\n   else\n@@ -5061,7 +5061,7 @@ layout_class_type (tree t, tree *virtuals_p)\n   build_base_fields (rli, empty_base_offsets, next_field);\n \n   /* Layout the non-static data members.  */\n-  for (field = non_static_data_members; field; field = TREE_CHAIN (field))\n+  for (field = non_static_data_members; field; field = DECL_CHAIN (field))\n     {\n       tree type;\n       tree padding;\n@@ -5342,7 +5342,7 @@ layout_class_type (tree t, tree *virtuals_p)\n \n       /* Copy the fields from T.  */\n       next_field = &TYPE_FIELDS (base_t);\n-      for (field = TYPE_FIELDS (t); field; field = TREE_CHAIN (field))\n+      for (field = TYPE_FIELDS (t); field; field = DECL_CHAIN (field))\n \tif (TREE_CODE (field) == FIELD_DECL)\n \t  {\n \t    *next_field = build_decl (input_location,\n@@ -5355,7 +5355,7 @@ layout_class_type (tree t, tree *virtuals_p)\n \t      = DECL_FIELD_BIT_OFFSET (field);\n \t    DECL_SIZE (*next_field) = DECL_SIZE (field);\n \t    DECL_MODE (*next_field) = DECL_MODE (field);\n-\t    next_field = &TREE_CHAIN (*next_field);\n+\t    next_field = &DECL_CHAIN (*next_field);\n \t  }\n \n       /* Record the base version of the type.  */\n@@ -5402,7 +5402,7 @@ layout_class_type (tree t, tree *virtuals_p)\n   warn_about_ambiguous_bases (t);\n \n   /* Now that we're done with layout, give the base fields the real types.  */\n-  for (field = TYPE_FIELDS (t); field; field = TREE_CHAIN (field))\n+  for (field = TYPE_FIELDS (t); field; field = DECL_CHAIN (field))\n     if (DECL_ARTIFICIAL (field) && IS_FAKE_BASE_TYPE (TREE_TYPE (field)))\n       TREE_TYPE (field) = TYPE_CONTEXT (TREE_TYPE (field));\n \n@@ -5434,7 +5434,7 @@ determine_key_method (tree type)\n      key function may not be inline; those targets should not call\n      this function until the end of the translation unit.  */\n   for (method = TYPE_METHODS (type); method != NULL_TREE;\n-       method = TREE_CHAIN (method))\n+       method = DECL_CHAIN (method))\n     if (DECL_VINDEX (method) != NULL_TREE\n \t&& ! DECL_DECLARED_INLINE_P (method)\n \t&& ! DECL_PURE_VIRTUAL_P (method))\n@@ -5558,7 +5558,7 @@ finish_struct_1 (tree t)\n \n   /* Complete the rtl for any static member objects of the type we're\n      working on.  */\n-  for (x = TYPE_FIELDS (t); x; x = TREE_CHAIN (x))\n+  for (x = TYPE_FIELDS (t); x; x = DECL_CHAIN (x))\n     if (TREE_CODE (x) == VAR_DECL && TREE_STATIC (x)\n         && TREE_TYPE (x) != error_mark_node\n \t&& same_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (x)), t))\n@@ -5655,13 +5655,13 @@ unreverse_member_declarations (tree t)\n        x && TREE_CODE (x) != TYPE_DECL;\n        x = next)\n     {\n-      next = TREE_CHAIN (x);\n-      TREE_CHAIN (x) = prev;\n+      next = DECL_CHAIN (x);\n+      DECL_CHAIN (x) = prev;\n       prev = x;\n     }\n   if (prev)\n     {\n-      TREE_CHAIN (TYPE_FIELDS (t)) = x;\n+      DECL_CHAIN (TYPE_FIELDS (t)) = x;\n       if (prev)\n \tTYPE_FIELDS (t) = prev;\n     }\n@@ -5698,7 +5698,7 @@ finish_struct (tree t, tree attributes)\n \t CLASSTYPE_PURE_VIRTUALS contains the list of the inline friends\n \t (see CLASSTYPE_INLINE_FRIENDS) so we need to clear it.  */\n       CLASSTYPE_PURE_VIRTUALS (t) = NULL;\n-      for (x = TYPE_METHODS (t); x; x = TREE_CHAIN (x))\n+      for (x = TYPE_METHODS (t); x; x = DECL_CHAIN (x))\n \tif (DECL_PURE_VIRTUAL_P (x))\n \t  VEC_safe_push (tree, gc, CLASSTYPE_PURE_VIRTUALS (t), x);\n       complete_vars (t);\n@@ -6798,7 +6798,7 @@ is_really_empty_class (tree type)\n \t   BINFO_BASE_ITERATE (binfo, i, base_binfo); ++i)\n \tif (!is_really_empty_class (BINFO_TYPE (base_binfo)))\n \t  return false;\n-      for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+      for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n \tif (TREE_CODE (field) == FIELD_DECL\n \t    && !DECL_ARTIFICIAL (field)\n \t    && !is_really_empty_class (TREE_TYPE (field)))\n@@ -7251,8 +7251,8 @@ build_vtt (tree t)\n   vtt = build_vtable (t, mangle_vtt_for_type (t), type);\n   initialize_artificial_var (vtt, inits);\n   /* Add the VTT to the vtables list.  */\n-  TREE_CHAIN (vtt) = TREE_CHAIN (CLASSTYPE_VTABLES (t));\n-  TREE_CHAIN (CLASSTYPE_VTABLES (t)) = vtt;\n+  DECL_CHAIN (vtt) = DECL_CHAIN (CLASSTYPE_VTABLES (t));\n+  DECL_CHAIN (CLASSTYPE_VTABLES (t)) = vtt;\n \n   dump_vtt (t, vtt);\n }\n@@ -8082,7 +8082,7 @@ add_vcall_offset_vtbl_entries_1 (tree binfo, vtbl_init_data* vid)\n \t order.  G++ 3.2 used the order in the vtable.  */\n       for (orig_fn = TYPE_METHODS (BINFO_TYPE (binfo));\n \t   orig_fn;\n-\t   orig_fn = TREE_CHAIN (orig_fn))\n+\t   orig_fn = DECL_CHAIN (orig_fn))\n \tif (DECL_VINDEX (orig_fn))\n \t  add_vcall_offset (orig_fn, binfo, vid);\n     }"}, {"sha": "abd5bf37b6e733e644f635585624ad794302a24d", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -51,7 +51,7 @@ static tree\n begin_bc_block (enum bc_t bc)\n {\n   tree label = create_artificial_label (input_location);\n-  TREE_CHAIN (label) = bc_label[bc];\n+  DECL_CHAIN (label) = bc_label[bc];\n   bc_label[bc] = label;\n   return label;\n }\n@@ -73,8 +73,8 @@ finish_bc_block (enum bc_t bc, tree label, gimple_seq body)\n       gimple_seq_add_stmt (&body, gimple_build_label (label));\n     }\n \n-  bc_label[bc] = TREE_CHAIN (label);\n-  TREE_CHAIN (label) = NULL_TREE;\n+  bc_label[bc] = DECL_CHAIN (label);\n+  DECL_CHAIN (label) = NULL_TREE;\n   return body;\n }\n \n@@ -893,7 +893,7 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n \n \t  IMPORTED_DECL_ASSOCIATED_DECL (using_directive)\n \t    = TREE_OPERAND (stmt, 0);\n-\t  TREE_CHAIN (using_directive) = BLOCK_VARS (block);\n+\t  DECL_CHAIN (using_directive) = BLOCK_VARS (block);\n \t  BLOCK_VARS (block) = using_directive;\n \t}\n       /* The USING_STMT won't appear in GENERIC.  */\n@@ -921,7 +921,7 @@ cp_genericize (tree fndecl)\n   struct cp_genericize_data wtd;\n \n   /* Fix up the types of parms passed by invisible reference.  */\n-  for (t = DECL_ARGUMENTS (fndecl); t; t = TREE_CHAIN (t))\n+  for (t = DECL_ARGUMENTS (fndecl); t; t = DECL_CHAIN (t))\n     if (TREE_ADDRESSABLE (TREE_TYPE (t)))\n       {\n \t/* If a function's arguments are copied to create a thunk,\n@@ -1178,7 +1178,7 @@ cxx_omp_predetermined_sharing (tree decl)\n \t  tree var;\n \n \t  if (outer)\n-\t    for (var = BLOCK_VARS (outer); var; var = TREE_CHAIN (var))\n+\t    for (var = BLOCK_VARS (outer); var; var = DECL_CHAIN (var))\n \t      if (DECL_NAME (decl) == DECL_NAME (var)\n \t\t  && (TYPE_MAIN_VARIANT (type)\n \t\t      == TYPE_MAIN_VARIANT (TREE_TYPE (var))))"}, {"sha": "70915cbc4ddd87b4f899c09256841de8b172f6ce", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -2092,9 +2092,9 @@ struct GTY((variable_size)) lang_decl {\n   if (TREE_CODE (FN) == FUNCTION_DECL\t\t\t\\\n       && (DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (FN)\t\\\n \t  || DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (FN)))\t\\\n-     for (CLONE = TREE_CHAIN (FN);\t\t\t\\\n+     for (CLONE = DECL_CHAIN (FN);\t\t\t\\\n \t  CLONE && DECL_CLONED_FUNCTION_P (CLONE);\t\\\n-\t  CLONE = TREE_CHAIN (CLONE))\n+\t  CLONE = DECL_CHAIN (CLONE))\n \n /* Nonzero if NODE has DECL_DISCRIMINATOR and not DECL_ACCESS.  */\n #define DECL_DISCRIMINATOR_P(NODE)\t\\"}, {"sha": "0a9f255177e2074619a78e4f0131e8e4a6369060", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -393,7 +393,7 @@ pop_labels_1 (void **slot, void *data)\n \n   /* Put the labels into the \"variables\" of the top-level block,\n      so debugger can see them.  */\n-  TREE_CHAIN (ent->label_decl) = BLOCK_VARS (block);\n+  DECL_CHAIN (ent->label_decl) = BLOCK_VARS (block);\n   BLOCK_VARS (block) = ent->label_decl;\n \n   htab_clear_slot (named_labels, slot);\n@@ -474,7 +474,7 @@ poplevel_named_label_1 (void **slot, void *data)\n     {\n       tree decl;\n \n-      for (decl = ent->names_in_scope; decl; decl = TREE_CHAIN (decl))\n+      for (decl = ent->names_in_scope; decl; decl = DECL_CHAIN (decl))\n \tif (decl_jump_unsafe (decl))\n \t  VEC_safe_push (tree, gc, ent->bad_decls, decl);\n \n@@ -749,7 +749,7 @@ poplevel (int keep, int reverse, int functionbody)\n \t  if (TREE_CODE (*d) == TREE_LIST)\n \t    *d = TREE_CHAIN (*d);\n \t  else\n-\t    d = &TREE_CHAIN (*d);\n+\t    d = &DECL_CHAIN (*d);\n \t}\n     }\n \n@@ -822,7 +822,7 @@ walk_namespaces_r (tree name_space, walk_namespaces_fn f, void* data)\n \n   result |= (*f) (name_space, data);\n \n-  for (; current; current = TREE_CHAIN (current))\n+  for (; current; current = DECL_CHAIN (current))\n     result |= walk_namespaces_r (current, f, data);\n \n   return result;\n@@ -1726,7 +1726,7 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n \t      DECL_ARGUMENTS (old_result)\n \t\t= DECL_ARGUMENTS (new_result);\n \t      for (parm = DECL_ARGUMENTS (old_result); parm;\n-\t\t   parm = TREE_CHAIN (parm))\n+\t\t   parm = DECL_CHAIN (parm))\n \t\tDECL_CONTEXT (parm) = old_result;\n \t    }\n \t}\n@@ -1976,7 +1976,7 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n       for (oldarg = DECL_ARGUMENTS(olddecl), \n                newarg = DECL_ARGUMENTS(newdecl);\n            oldarg && newarg;\n-           oldarg = TREE_CHAIN(oldarg), newarg = TREE_CHAIN(newarg)) {\n+           oldarg = DECL_CHAIN(oldarg), newarg = DECL_CHAIN(newarg)) {\n           DECL_ATTRIBUTES (newarg)\n               = (*targetm.merge_decl_attributes) (oldarg, newarg);\n           DECL_ATTRIBUTES (oldarg) = DECL_ATTRIBUTES (newarg);\n@@ -2040,7 +2040,7 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n \n       /* Update newdecl's parms to point at olddecl.  */\n       for (parm = DECL_ARGUMENTS (newdecl); parm;\n-\t   parm = TREE_CHAIN (parm))\n+\t   parm = DECL_CHAIN (parm))\n \tDECL_CONTEXT (parm) = olddecl;\n \n       if (! types_match)\n@@ -2586,7 +2586,7 @@ check_previous_goto_1 (tree decl, struct cp_binding_level* level, tree names,\n       tree new_decls, old_decls = (b == level ? names : NULL_TREE);\n \n       for (new_decls = b->names; new_decls != old_decls;\n-\t   new_decls = TREE_CHAIN (new_decls))\n+\t   new_decls = DECL_CHAIN (new_decls))\n \t{\n \t  int problem = decl_jump_unsafe (new_decls);\n \t  if (! problem)\n@@ -3885,7 +3885,7 @@ fixup_anonymous_aggr (tree t)\n       if (DECL_ARTIFICIAL (*q))\n \t*q = TREE_CHAIN (*q);\n       else\n-\tq = &TREE_CHAIN (*q);\n+\tq = &DECL_CHAIN (*q);\n     }\n \n   /* ISO C++ 9.5.3.  Anonymous unions may not have function members.  */\n@@ -3909,7 +3909,7 @@ fixup_anonymous_aggr (tree t)\n     {\n       tree field, type;\n \n-      for (field = TYPE_FIELDS (t); field; field = TREE_CHAIN (field))\n+      for (field = TYPE_FIELDS (t); field; field = DECL_CHAIN (field))\n \tif (TREE_CODE (field) == FIELD_DECL)\n \t  {\n \t    type = TREE_TYPE (field);\n@@ -4811,7 +4811,7 @@ next_initializable_field (tree field)\n \t && (TREE_CODE (field) != FIELD_DECL\n \t     || (DECL_C_BIT_FIELD (field) && !DECL_NAME (field))\n \t     || DECL_ARTIFICIAL (field)))\n-    field = TREE_CHAIN (field);\n+    field = DECL_CHAIN (field);\n \n   return field;\n }\n@@ -4981,7 +4981,7 @@ reshape_init_class (tree type, reshape_iter *d, bool first_initializer_p)\n       if (TREE_CODE (type) == UNION_TYPE)\n \tbreak;\n \n-      field = next_initializable_field (TREE_CHAIN (field));\n+      field = next_initializable_field (DECL_CHAIN (field));\n     }\n \n   return new_init;\n@@ -6776,11 +6776,11 @@ grokfndecl (tree ctype,\n     {\n       tree parm;\n       parm = build_this_parm (type, quals);\n-      TREE_CHAIN (parm) = parms;\n+      DECL_CHAIN (parm) = parms;\n       parms = parm;\n     }\n   DECL_ARGUMENTS (decl) = parms;\n-  for (t = parms; t; t = TREE_CHAIN (t))\n+  for (t = parms; t; t = DECL_CHAIN (t))\n     DECL_CONTEXT (t) = decl;\n   /* Propagate volatile out from type to decl.  */\n   if (TYPE_VOLATILE (type))\n@@ -7280,7 +7280,7 @@ build_ptrmemfunc_type (tree type)\n \n   field = build_decl (input_location, FIELD_DECL, delta_identifier, \n \t\t      delta_type_node);\n-  TREE_CHAIN (field) = fields;\n+  DECL_CHAIN (field) = fields;\n   fields = field;\n \n   finish_builtin_struct (t, \"__ptrmemfunc_type\", fields, ptr_type_node);\n@@ -9204,7 +9204,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t{\n \t  tree decl = cp_build_parm_decl (NULL_TREE, TREE_VALUE (args));\n \n-\t  TREE_CHAIN (decl) = decls;\n+\t  DECL_CHAIN (decl) = decls;\n \t  decls = decl;\n \t}\n \n@@ -9836,7 +9836,7 @@ grokdeclarator (const cp_declarator *declarator,\n static void\n require_complete_types_for_parms (tree parms)\n {\n-  for (; parms; parms = TREE_CHAIN (parms))\n+  for (; parms; parms = DECL_CHAIN (parms))\n     {\n       if (dependent_type_p (TREE_TYPE (parms)))\n \tcontinue;\n@@ -10106,7 +10106,7 @@ grokparms (tree parmlist, tree *parms)\n           && TREE_CHAIN (parm) != void_list_node)\n         error (\"parameter packs must be at the end of the parameter list\");\n \n-      TREE_CHAIN (decl) = decls;\n+      DECL_CHAIN (decl) = decls;\n       decls = decl;\n       result = tree_cons (init, type, result);\n     }\n@@ -12111,11 +12111,11 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n \n       /* Constructors and destructors need to know whether they're \"in\n \t charge\" of initializing virtual base classes.  */\n-      t = TREE_CHAIN (t);\n+      t = DECL_CHAIN (t);\n       if (DECL_HAS_IN_CHARGE_PARM_P (decl1))\n \t{\n \t  current_in_charge_parm = t;\n-\t  t = TREE_CHAIN (t);\n+\t  t = DECL_CHAIN (t);\n \t}\n       if (DECL_HAS_VTT_PARM_P (decl1))\n \t{\n@@ -12326,7 +12326,7 @@ store_parm_decls (tree current_function_parms)\n \n       for (parm = specparms; parm; parm = next)\n \t{\n-\t  next = TREE_CHAIN (parm);\n+\t  next = DECL_CHAIN (parm);\n \t  if (TREE_CODE (parm) == PARM_DECL)\n \t    {\n \t      if (DECL_NAME (parm) == NULL_TREE\n@@ -12762,7 +12762,7 @@ finish_function (int flags)\n \n       for (decl = DECL_ARGUMENTS (fndecl);\n \t   decl;\n-\t   decl = TREE_CHAIN (decl))\n+\t   decl = DECL_CHAIN (decl))\n \tif (TREE_USED (decl)\n \t    && TREE_CODE (decl) == PARM_DECL\n \t    && !DECL_READ_P (decl)\n@@ -12905,7 +12905,7 @@ grokmethod (cp_decl_specifier_seq *declspecs,\n \n   if (! DECL_FRIEND_P (fndecl))\n     {\n-      if (TREE_CHAIN (fndecl))\n+      if (DECL_CHAIN (fndecl))\n \t{\n \t  fndecl = copy_node (fndecl);\n \t  TREE_CHAIN (fndecl) = NULL_TREE;\n@@ -13101,7 +13101,7 @@ revert_static_member_fn (tree decl)\n     error (\"static member function %q#D declared with type qualifiers\", decl);\n \n   if (DECL_ARGUMENTS (decl))\n-    DECL_ARGUMENTS (decl) = TREE_CHAIN (DECL_ARGUMENTS (decl));\n+    DECL_ARGUMENTS (decl) = DECL_CHAIN (DECL_ARGUMENTS (decl));\n   DECL_STATIC_FUNCTION_P (decl) = 1;\n }\n "}, {"sha": "a768877b1a8c214d8b1269e3f848396e35c35742", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -242,7 +242,7 @@ maybe_retrofit_in_chrg (tree fn)\n   basetype = TREE_TYPE (TREE_VALUE (arg_types));\n   arg_types = TREE_CHAIN (arg_types);\n \n-  parms = TREE_CHAIN (DECL_ARGUMENTS (fn));\n+  parms = DECL_CHAIN (DECL_ARGUMENTS (fn));\n \n   /* If this is a subobject constructor or destructor, our caller will\n      pass us a pointer to our VTT.  */\n@@ -251,7 +251,7 @@ maybe_retrofit_in_chrg (tree fn)\n       parm = build_artificial_parm (vtt_parm_identifier, vtt_parm_type);\n \n       /* First add it to DECL_ARGUMENTS between 'this' and the real args...  */\n-      TREE_CHAIN (parm) = parms;\n+      DECL_CHAIN (parm) = parms;\n       parms = parm;\n \n       /* ...and then to TYPE_ARG_TYPES.  */\n@@ -262,12 +262,12 @@ maybe_retrofit_in_chrg (tree fn)\n \n   /* Then add the in-charge parm (before the VTT parm).  */\n   parm = build_artificial_parm (in_charge_identifier, integer_type_node);\n-  TREE_CHAIN (parm) = parms;\n+  DECL_CHAIN (parm) = parms;\n   parms = parm;\n   arg_types = hash_tree_chain (integer_type_node, arg_types);\n \n   /* Insert our new parameter(s) into the list.  */\n-  TREE_CHAIN (DECL_ARGUMENTS (fn)) = parms;\n+  DECL_CHAIN (DECL_ARGUMENTS (fn)) = parms;\n \n   /* And rebuild the function type.  */\n   fntype = build_method_type_directly (basetype, TREE_TYPE (TREE_TYPE (fn)),\n@@ -1321,7 +1321,7 @@ build_anon_union_vars (tree type, tree object)\n \n   for (field = TYPE_FIELDS (type);\n        field != NULL_TREE;\n-       field = TREE_CHAIN (field))\n+       field = DECL_CHAIN (field))\n     {\n       tree decl;\n       tree ref;\n@@ -1826,7 +1826,7 @@ maybe_emit_vtables (tree ctype)\n     determine_key_method (ctype);\n \n   /* See if any of the vtables are needed.  */\n-  for (vtbl = CLASSTYPE_VTABLES (ctype); vtbl; vtbl = TREE_CHAIN (vtbl))\n+  for (vtbl = CLASSTYPE_VTABLES (ctype); vtbl; vtbl = DECL_CHAIN (vtbl))\n     {\n       import_export_decl (vtbl);\n       if (DECL_NOT_REALLY_EXTERN (vtbl) && decl_needed_p (vtbl))\n@@ -1845,7 +1845,7 @@ maybe_emit_vtables (tree ctype)\n \n   /* The ABI requires that we emit all of the vtables if we emit any\n      of them.  */\n-  for (vtbl = CLASSTYPE_VTABLES (ctype); vtbl; vtbl = TREE_CHAIN (vtbl))\n+  for (vtbl = CLASSTYPE_VTABLES (ctype); vtbl; vtbl = DECL_CHAIN (vtbl))\n     {\n       /* Mark entities references from the virtual table as used.  */\n       mark_vtable_entries (vtbl);\n@@ -2242,7 +2242,7 @@ constrain_class_visibility (tree type)\n   if (CLASSTYPE_VISIBILITY_SPECIFIED (type))\n     vis = VISIBILITY_INTERNAL;\n \n-  for (t = TYPE_FIELDS (type); t; t = TREE_CHAIN (t))\n+  for (t = TYPE_FIELDS (type); t; t = DECL_CHAIN (t))\n     if (TREE_CODE (t) == FIELD_DECL && TREE_TYPE (t) != error_mark_node)\n       {\n \ttree ftype = strip_pointer_or_array_types (TREE_TYPE (t));\n@@ -2868,7 +2868,7 @@ start_static_storage_duration_function (unsigned count)\n   DECL_CONTEXT (priority_decl) = ssdf_decl;\n   TREE_USED (priority_decl) = 1;\n \n-  TREE_CHAIN (initialize_p_decl) = priority_decl;\n+  DECL_CHAIN (initialize_p_decl) = priority_decl;\n   DECL_ARGUMENTS (ssdf_decl) = initialize_p_decl;\n \n   /* Put the function in the global scope.  */\n@@ -2966,7 +2966,7 @@ fix_temporary_vars_context_r (tree *node,\n     {\n       tree var;\n \n-      for (var = BIND_EXPR_VARS (*node); var; var = TREE_CHAIN (var))\n+      for (var = BIND_EXPR_VARS (*node); var; var = DECL_CHAIN (var))\n \tif (TREE_CODE (var) == VAR_DECL\n \t  && !DECL_NAME (var)\n \t  && DECL_ARTIFICIAL (var)"}, {"sha": "507da922b4c71f630adcf608d88f1fd2d9a7498d", "filename": "gcc/cp/init.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -184,7 +184,7 @@ build_zero_init (tree type, tree nelts, bool static_storage_p)\n       VEC(constructor_elt,gc) *v = NULL;\n \n       /* Iterate over the fields, building initializations.  */\n-      for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+      for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n \t{\n \t  if (TREE_CODE (field) != FIELD_DECL)\n \t    continue;\n@@ -337,7 +337,7 @@ build_value_init_noctor (tree type)\n \t  VEC(constructor_elt,gc) *v = NULL;\n \n \t  /* Iterate over the fields, building initializations.  */\n-\t  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+\t  for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n \t    {\n \t      tree ftype, value;\n \n@@ -562,7 +562,7 @@ build_field_list (tree t, tree list, int *uses_unions_p)\n   if (TREE_CODE (t) == UNION_TYPE)\n     *uses_unions_p = 1;\n \n-  for (fields = TYPE_FIELDS (t); fields; fields = TREE_CHAIN (fields))\n+  for (fields = TYPE_FIELDS (t); fields; fields = DECL_CHAIN (fields))\n     {\n       tree fieldtype;\n \n@@ -1030,7 +1030,7 @@ construct_virtual_base (tree vbase, tree arguments)\n      in the outer block.)  We trust the back end to figure out\n      that the FLAG will not change across initializations, and\n      avoid doing multiple tests.  */\n-  flag = TREE_CHAIN (DECL_ARGUMENTS (current_function_decl));\n+  flag = DECL_CHAIN (DECL_ARGUMENTS (current_function_decl));\n   inner_if_stmt = begin_if_stmt ();\n   finish_if_stmt_cond (flag, inner_if_stmt);\n \n@@ -1815,7 +1815,7 @@ diagnose_uninitialized_cst_or_ref_member_1 (tree type, tree origin,\n   if (type_has_user_provided_constructor (type))\n     return 0;\n \n-  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+  for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n     {\n       tree field_type;\n \n@@ -2578,7 +2578,7 @@ build_java_class_ref (tree type)\n   /* Mangle the class$ field.  */\n   {\n     tree field;\n-    for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+    for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n       if (DECL_NAME (field) == CL_suffix)\n \t{\n \t  mangle_decl (field);\n@@ -3383,7 +3383,7 @@ push_base_cleanups (void)\n     return;\n \n   for (member = TYPE_FIELDS (current_class_type); member;\n-       member = TREE_CHAIN (member))\n+       member = DECL_CHAIN (member))\n     {\n       tree this_type = TREE_TYPE (member);\n       if (this_type == error_mark_node"}, {"sha": "a47dfa8babf1b5a0d61bd52dda05a47a5c1d5a71", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -1289,7 +1289,7 @@ nested_anon_class_index (tree type)\n {\n   int index = 0;\n   tree member = TYPE_FIELDS (TYPE_CONTEXT (type));\n-  for (; member; member = TREE_CHAIN (member))\n+  for (; member; member = DECL_CHAIN (member))\n     if (DECL_IMPLICIT_TYPEDEF_P (member))\n       {\n \ttree memtype = TREE_TYPE (member);\n@@ -1719,7 +1719,7 @@ write_local_name (tree function, const tree local_entity,\n     {\n       tree t;\n       int i = 0;\n-      for (t = DECL_ARGUMENTS (function); t; t = TREE_CHAIN (t))\n+      for (t = DECL_ARGUMENTS (function); t; t = DECL_CHAIN (t))\n \t{\n \t  if (t == parm)\n \t    i = 1;\n@@ -2303,12 +2303,12 @@ write_method_parms (tree parm_types, const int method_p, const tree decl)\n   if (method_p)\n     {\n       parm_types = TREE_CHAIN (parm_types);\n-      parm_decl = parm_decl ? TREE_CHAIN (parm_decl) : NULL_TREE;\n+      parm_decl = parm_decl ? DECL_CHAIN (parm_decl) : NULL_TREE;\n \n       while (parm_decl && DECL_ARTIFICIAL (parm_decl))\n \t{\n \t  parm_types = TREE_CHAIN (parm_types);\n-\t  parm_decl = TREE_CHAIN (parm_decl);\n+\t  parm_decl = DECL_CHAIN (parm_decl);\n \t}\n     }\n "}, {"sha": "b9511f5a6289bfd3f4a69124fdb61a6162c212be", "filename": "gcc/cp/method.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -103,7 +103,7 @@ make_thunk (tree function, bool this_adjusting,\n   /* See if we already have the thunk in question.  For this_adjusting\n      thunks VIRTUAL_OFFSET will be an INTEGER_CST, for covariant thunks it\n      will be a BINFO.  */\n-  for (thunk = DECL_THUNKS (function); thunk; thunk = TREE_CHAIN (thunk))\n+  for (thunk = DECL_THUNKS (function); thunk; thunk = DECL_CHAIN (thunk))\n     if (DECL_THIS_THUNK_P (thunk) == this_adjusting\n \t&& THUNK_FIXED_OFFSET (thunk) == d\n \t&& !virtual_offset == !THUNK_VIRTUAL_OFFSET (thunk)\n@@ -156,7 +156,7 @@ make_thunk (tree function, bool this_adjusting,\n   DECL_TEMPLATE_INFO (thunk) = NULL;\n \n   /* Add it to the list of thunks associated with FUNCTION.  */\n-  TREE_CHAIN (thunk) = DECL_THUNKS (function);\n+  DECL_CHAIN (thunk) = DECL_THUNKS (function);\n   DECL_THUNKS (function) = thunk;\n \n   return thunk;\n@@ -188,7 +188,7 @@ finish_thunk (tree thunk)\n       tree cov_probe;\n \n       for (cov_probe = DECL_THUNKS (function);\n-\t   cov_probe; cov_probe = TREE_CHAIN (cov_probe))\n+\t   cov_probe; cov_probe = DECL_CHAIN (cov_probe))\n \tif (DECL_NAME (cov_probe) == name)\n \t  {\n \t    gcc_assert (!DECL_THUNKS (thunk));\n@@ -364,10 +364,10 @@ use_thunk (tree thunk_fndecl, bool emit_p)\n \n   /* Set up cloned argument trees for the thunk.  */\n   t = NULL_TREE;\n-  for (a = DECL_ARGUMENTS (function); a; a = TREE_CHAIN (a))\n+  for (a = DECL_ARGUMENTS (function); a; a = DECL_CHAIN (a))\n     {\n       tree x = copy_node (a);\n-      TREE_CHAIN (x) = t;\n+      DECL_CHAIN (x) = t;\n       DECL_CONTEXT (x) = thunk_fndecl;\n       SET_DECL_RTL (x, NULL);\n       DECL_HAS_VALUE_EXPR_P (x) = 0;\n@@ -529,7 +529,7 @@ do_build_copy_constructor (tree fndecl)\n \t\t\t member_init_list);\n \t}\n \n-      for (; fields; fields = TREE_CHAIN (fields))\n+      for (; fields; fields = DECL_CHAIN (fields))\n \t{\n \t  tree field = fields;\n \t  tree expr_type;\n@@ -579,7 +579,7 @@ do_build_copy_constructor (tree fndecl)\n static void\n do_build_copy_assign (tree fndecl)\n {\n-  tree parm = TREE_CHAIN (DECL_ARGUMENTS (fndecl));\n+  tree parm = DECL_CHAIN (DECL_ARGUMENTS (fndecl));\n   tree compound_stmt;\n   bool move_p = move_fn_p (fndecl);\n   bool trivial = trivial_fn_p (fndecl);\n@@ -630,7 +630,7 @@ do_build_copy_assign (tree fndecl)\n       /* Assign to each of the non-static data members.  */\n       for (fields = TYPE_FIELDS (current_class_type);\n \t   fields;\n-\t   fields = TREE_CHAIN (fields))\n+\t   fields = DECL_CHAIN (fields))\n \t{\n \t  tree comp = current_class_ref;\n \t  tree init = parm;\n@@ -953,7 +953,7 @@ walk_field_subobs (tree fields, tree fnname, special_function_kind sfk,\n \t\t   int flags, tsubst_flags_t complain)\n {\n   tree field;\n-  for (field = fields; field; field = TREE_CHAIN (field))\n+  for (field = fields; field; field = DECL_CHAIN (field))\n     {\n       tree mem_type, argtype, rval;\n \n@@ -1432,7 +1432,7 @@ implicitly_declare_fn (special_function_kind kind, tree type, bool const_p)\n     }\n   /* Add the \"this\" parameter.  */\n   this_parm = build_this_parm (fn_type, TYPE_UNQUALIFIED);\n-  TREE_CHAIN (this_parm) = DECL_ARGUMENTS (fn);\n+  DECL_CHAIN (this_parm) = DECL_ARGUMENTS (fn);\n   DECL_ARGUMENTS (fn) = this_parm;\n \n   grokclassfn (type, fn, kind == sfk_destructor ? DTOR_FLAG : NO_SPECIAL);\n@@ -1625,7 +1625,7 @@ lazily_declare_fn (special_function_kind sfk, tree type)\n \t\t \"and may change in a future version of GCC due to \"\n \t\t \"implicit virtual destructor\",\n \t\t type);\n-      TREE_CHAIN (fn) = TYPE_METHODS (type);\n+      DECL_CHAIN (fn) = TYPE_METHODS (type);\n       TYPE_METHODS (type) = fn;\n     }\n   maybe_add_class_template_decl_list (type, fn, /*friend_p=*/0);"}, {"sha": "c6e31c2944520bada98e1aad09458c49ccf29478", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -542,7 +542,7 @@ add_decl_to_level (tree decl, cxx_scope *b)\n   if (TREE_CODE (decl) == NAMESPACE_DECL\n       && !DECL_NAMESPACE_ALIAS (decl))\n     {\n-      TREE_CHAIN (decl) = b->namespaces;\n+      DECL_CHAIN (decl) = b->namespaces;\n       b->namespaces = decl;\n     }\n   else\n@@ -1993,15 +1993,15 @@ push_using_decl (tree scope, tree name)\n   timevar_push (TV_NAME_LOOKUP);\n   gcc_assert (TREE_CODE (scope) == NAMESPACE_DECL);\n   gcc_assert (TREE_CODE (name) == IDENTIFIER_NODE);\n-  for (decl = current_binding_level->usings; decl; decl = TREE_CHAIN (decl))\n+  for (decl = current_binding_level->usings; decl; decl = DECL_CHAIN (decl))\n     if (USING_DECL_SCOPE (decl) == scope && DECL_NAME (decl) == name)\n       break;\n   if (decl)\n     POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP,\n \t\t\t    namespace_bindings_p () ? decl : NULL_TREE);\n   decl = build_lang_decl (USING_DECL, name, NULL_TREE);\n   USING_DECL_SCOPE (decl) = scope;\n-  TREE_CHAIN (decl) = current_binding_level->usings;\n+  DECL_CHAIN (decl) = current_binding_level->usings;\n   current_binding_level->usings = decl;\n   POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, decl);\n }\n@@ -2157,7 +2157,7 @@ push_overloaded_decl (tree decl, int flags, bool is_friend)\n \n \t  for (d = &IDENTIFIER_BINDING (name)->scope->names;\n \t       *d;\n-\t       d = &TREE_CHAIN (*d))\n+\t       d = &DECL_CHAIN (*d))\n \t    if (*d == old\n \t\t|| (TREE_CODE (*d) == TREE_LIST\n \t\t    && TREE_VALUE (*d) == old))\n@@ -2168,7 +2168,7 @@ push_overloaded_decl (tree decl, int flags, bool is_friend)\n \t\telse\n \t\t  /* Build a TREE_LIST to wrap the OVERLOAD.  */\n \t\t  *d = tree_cons (NULL_TREE, new_binding,\n-\t\t\t\t  TREE_CHAIN (*d));\n+\t\t\t\t  DECL_CHAIN (*d));\n \n \t\t/* And update the cxx_binding node.  */\n \t\tIDENTIFIER_BINDING (name)->value = new_binding;\n@@ -2726,7 +2726,7 @@ pushdecl_class_level (tree x)\n \t aggregate, for naming purposes.  */\n       tree f;\n \n-      for (f = TYPE_FIELDS (TREE_TYPE (x)); f; f = TREE_CHAIN (f))\n+      for (f = TYPE_FIELDS (TREE_TYPE (x)); f; f = DECL_CHAIN (f))\n \t{\n \t  location_t save_location = input_location;\n \t  input_location = DECL_SOURCE_LOCATION (f);"}, {"sha": "302a1332d6676ea0b59223da202df6f7737a6122", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -282,16 +282,16 @@ maybe_clone_body (tree fn)\n       clone_parm = DECL_ARGUMENTS (clone);\n       /* Update the `this' parameter, which is always first.  */\n       update_cloned_parm (parm, clone_parm, first);\n-      parm = TREE_CHAIN (parm);\n-      clone_parm = TREE_CHAIN (clone_parm);\n+      parm = DECL_CHAIN (parm);\n+      clone_parm = DECL_CHAIN (clone_parm);\n       if (DECL_HAS_IN_CHARGE_PARM_P (fn))\n-\tparm = TREE_CHAIN (parm);\n+\tparm = DECL_CHAIN (parm);\n       if (DECL_HAS_VTT_PARM_P (fn))\n-\tparm = TREE_CHAIN (parm);\n+\tparm = DECL_CHAIN (parm);\n       if (DECL_HAS_VTT_PARM_P (clone))\n-\tclone_parm = TREE_CHAIN (clone_parm);\n+\tclone_parm = DECL_CHAIN (clone_parm);\n       for (; parm;\n-\t   parm = TREE_CHAIN (parm), clone_parm = TREE_CHAIN (clone_parm))\n+\t   parm = DECL_CHAIN (parm), clone_parm = DECL_CHAIN (clone_parm))\n \t/* Update this parameter.  */\n \tupdate_cloned_parm (parm, clone_parm, first);\n \n@@ -348,7 +348,7 @@ maybe_clone_body (tree fn)\n                 clone_parm = DECL_ARGUMENTS (clone);\n               parm;\n               ++parmno,\n-                parm = TREE_CHAIN (parm))\n+                parm = DECL_CHAIN (parm))\n             {\n               /* Map the in-charge parameter to an appropriate constant.  */\n               if (DECL_HAS_IN_CHARGE_PARM_P (fn) && parmno == 1)\n@@ -367,7 +367,7 @@ maybe_clone_body (tree fn)\n                     {\n                       DECL_ABSTRACT_ORIGIN (clone_parm) = parm;\n                       *pointer_map_insert (decl_map, parm) = clone_parm;\n-                      clone_parm = TREE_CHAIN (clone_parm);\n+                      clone_parm = DECL_CHAIN (clone_parm);\n                     }\n                   /* Otherwise, map the VTT parameter to `NULL'.  */\n                   else\n@@ -379,7 +379,7 @@ maybe_clone_body (tree fn)\n               else\n                 {\n                   *pointer_map_insert (decl_map, parm) = clone_parm;\n-                  clone_parm = TREE_CHAIN (clone_parm);\n+                  clone_parm = DECL_CHAIN (clone_parm);\n                 }\n             }\n "}, {"sha": "19a158f6350fd95289302b1bef858f9b36139793", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -2650,7 +2650,7 @@ cp_parser_diagnose_invalid_type_name (cp_parser *parser,\n \t\t  base_type = CLASSTYPE_PRIMARY_TEMPLATE_TYPE (base_type);\n \t\t  for (field = TYPE_FIELDS (base_type);\n \t\t       field;\n-\t\t       field = TREE_CHAIN (field))\n+\t\t       field = DECL_CHAIN (field))\n \t\t    if (TREE_CODE (field) == TYPE_DECL\n \t\t\t&& DECL_NAME (field) == id)\n \t\t      {\n@@ -7706,7 +7706,7 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)\n \n       /* The function parameters must be in scope all the way until after the\n          trailing-return-type in case of decltype.  */\n-      for (t = current_binding_level->names; t; t = TREE_CHAIN (t))\n+      for (t = current_binding_level->names; t; t = DECL_CHAIN (t))\n \tpop_binding (DECL_NAME (t), t);\n \n       leave_scope ();\n@@ -14378,7 +14378,7 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t\t}\n \n \t      /* Remove the function parms from scope.  */\n-\t      for (t = current_binding_level->names; t; t = TREE_CHAIN (t))\n+\t      for (t = current_binding_level->names; t; t = DECL_CHAIN (t))\n \t\tpop_binding (DECL_NAME (t), t);\n \t      leave_scope();\n \n@@ -19676,7 +19676,7 @@ cp_parser_late_parsing_default_args (cp_parser *parser, tree fn)\n \t parmdecl = DECL_ARGUMENTS (fn);\n        parm && parm != void_list_node;\n        parm = TREE_CHAIN (parm),\n-\t parmdecl = TREE_CHAIN (parmdecl))\n+\t parmdecl = DECL_CHAIN (parmdecl))\n     {\n       cp_token_cache *tokens;\n       tree default_arg = TREE_PURPOSE (parm);"}, {"sha": "ef6e8e94d6a646956b68090e635ffed531fb9549", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -2553,7 +2553,7 @@ check_explicit_specialization (tree declarator,\n \t\t     definition, not in the original declaration.  */\n \t\t  DECL_ARGUMENTS (result) = DECL_ARGUMENTS (decl);\n \t\t  for (parm = DECL_ARGUMENTS (result); parm;\n-\t\t       parm = TREE_CHAIN (parm))\n+\t\t       parm = DECL_CHAIN (parm))\n \t\t    DECL_CONTEXT (parm) = result;\n \t\t}\n \t      return register_specialization (tmpl, gen_tmpl, targs,\n@@ -4417,7 +4417,7 @@ push_template_decl_real (tree decl, bool is_friend)\n               TREE_VALUE (argtype) = error_mark_node;\n             }\n \n-          arg = TREE_CHAIN (arg);\n+          arg = DECL_CHAIN (arg);\n           argtype = TREE_CHAIN (argtype);\n         }\n \n@@ -8196,7 +8196,7 @@ instantiate_class_template (tree type)\n      any member functions.  We don't do this earlier because the\n      default arguments may reference members of the class.  */\n   if (!PRIMARY_TEMPLATE_P (templ))\n-    for (t = TYPE_METHODS (type); t; t = TREE_CHAIN (t))\n+    for (t = TYPE_METHODS (type); t; t = DECL_CHAIN (t))\n       if (TREE_CODE (t) == FUNCTION_DECL\n \t  /* Implicitly generated member functions will not have template\n \t     information; they are not instantiations, but instead are\n@@ -8261,7 +8261,7 @@ make_fnparm_pack (tree spec_parm)\n   /* Fill in PARMVEC and PARMTYPEVEC with all of the parameters.  */\n   parmvec = make_tree_vec (len);\n   parmtypevec = make_tree_vec (len);\n-  for (i = 0; i < len; i++, spec_parm = TREE_CHAIN (spec_parm))\n+  for (i = 0; i < len; i++, spec_parm = DECL_CHAIN (spec_parm))\n     {\n       TREE_VEC_ELT (parmvec, i) = spec_parm;\n       TREE_VEC_ELT (parmtypevec, i) = TREE_TYPE (spec_parm);\n@@ -8541,7 +8541,7 @@ get_pattern_parm (tree parm, tree tmpl)\n   if (DECL_ARTIFICIAL (parm))\n     {\n       for (patparm = DECL_ARGUMENTS (pattern);\n-\t   patparm; patparm = TREE_CHAIN (patparm))\n+\t   patparm; patparm = DECL_CHAIN (patparm))\n \tif (DECL_ARTIFICIAL (patparm)\n \t    && DECL_NAME (parm) == DECL_NAME (patparm))\n \t  break;\n@@ -8936,7 +8936,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t      RETURN (error_mark_node);\n \n \t    r = copy_decl (t);\n-\t    TREE_CHAIN (r) = NULL_TREE;\n+\t    DECL_CHAIN (r) = NULL_TREE;\n \t    TREE_TYPE (r) = new_type;\n \t    DECL_TEMPLATE_RESULT (r)\n \t      = build_decl (DECL_SOURCE_LOCATION (decl),\n@@ -8986,7 +8986,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t   than the old one.  */\n \tr = copy_decl (t);\n \tgcc_assert (DECL_LANG_SPECIFIC (r) != 0);\n-\tTREE_CHAIN (r) = NULL_TREE;\n+\tDECL_CHAIN (r) = NULL_TREE;\n \n \tDECL_TEMPLATE_INFO (r) = build_template_info (t, args);\n \n@@ -9196,7 +9196,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t   assigned to the instantiation.  */\n \tDECL_INTERFACE_KNOWN (r) = !TREE_PUBLIC (r);\n \tDECL_DEFER_OUTPUT (r) = 0;\n-\tTREE_CHAIN (r) = NULL_TREE;\n+\tDECL_CHAIN (r) = NULL_TREE;\n \tDECL_PENDING_INLINE_INFO (r) = 0;\n \tDECL_PENDING_INLINE_P (r) = 0;\n \tDECL_SAVED_TREE (r) = NULL_TREE;\n@@ -9395,12 +9395,12 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n             /* Build a proper chain of parameters when substituting\n                into a function parameter pack.  */\n             if (prev_r)\n-              TREE_CHAIN (prev_r) = r;\n+              DECL_CHAIN (prev_r) = r;\n           }\n \n-\tif (TREE_CHAIN (t))\n-\t  TREE_CHAIN (r) = tsubst (TREE_CHAIN (t), args,\n-\t\t\t\t   complain, TREE_CHAIN (t));\n+\tif (DECL_CHAIN (t))\n+\t  DECL_CHAIN (r) = tsubst (DECL_CHAIN (t), args,\n+\t\t\t\t   complain, DECL_CHAIN (t));\n \n         /* FIRST_R contains the start of the chain we've built.  */\n         r = first_r;\n@@ -9425,7 +9425,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t\t\t /*integral_constant_expression_p=*/true);\n \t/* We don't have to set DECL_CONTEXT here; it is set by\n \t   finish_member_declaration.  */\n-\tTREE_CHAIN (r) = NULL_TREE;\n+\tDECL_CHAIN (r) = NULL_TREE;\n \tif (VOID_TYPE_P (type))\n \t  error (\"instantiation of %q+D as type %qT\", r, type);\n \n@@ -9452,7 +9452,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n       else\n \t{\n \t  r = copy_node (t);\n-\t  TREE_CHAIN (r) = NULL_TREE;\n+\t  DECL_CHAIN (r) = NULL_TREE;\n \t}\n       break;\n \n@@ -9652,7 +9652,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \telse\n \t  register_local_specialization (r, t);\n \n-\tTREE_CHAIN (r) = NULL_TREE;\n+\tDECL_CHAIN (r) = NULL_TREE;\n \n \tapply_late_template_attributes (&r, DECL_ATTRIBUTES (r),\n \t\t\t\t\t/*flags=*/0,\n@@ -13123,7 +13123,7 @@ instantiate_template (tree tmpl, tree orig_args, tsubst_flags_t complain)\n      instantiate all the alternate entry points as well.  We do this\n      by cloning the instantiation of the main entry point, not by\n      instantiating the template clones.  */\n-  if (TREE_CHAIN (gen_tmpl) && DECL_CLONED_FUNCTION_P (TREE_CHAIN (gen_tmpl)))\n+  if (DECL_CHAIN (gen_tmpl) && DECL_CLONED_FUNCTION_P (DECL_CHAIN (gen_tmpl)))\n     clone_function_decl (fndecl, /*update_method_vec_p=*/0);\n \n   return fndecl;\n@@ -16392,12 +16392,12 @@ do_type_instantiation (tree t, tree storage, tsubst_flags_t complain)\n        interpretation is that it should be an explicit instantiation.  */\n \n     if (! static_p)\n-      for (tmp = TYPE_METHODS (t); tmp; tmp = TREE_CHAIN (tmp))\n+      for (tmp = TYPE_METHODS (t); tmp; tmp = DECL_CHAIN (tmp))\n \tif (TREE_CODE (tmp) == FUNCTION_DECL\n \t    && DECL_TEMPLATE_INSTANTIATION (tmp))\n \t  instantiate_class_member (tmp, extern_p);\n \n-    for (tmp = TYPE_FIELDS (t); tmp; tmp = TREE_CHAIN (tmp))\n+    for (tmp = TYPE_FIELDS (t); tmp; tmp = DECL_CHAIN (tmp))\n       if (TREE_CODE (tmp) == VAR_DECL && DECL_TEMPLATE_INSTANTIATION (tmp))\n \tinstantiate_class_member (tmp, extern_p);\n \n@@ -16485,8 +16485,8 @@ regenerate_decl_from_template (tree decl, tree tmpl)\n \t      DECL_ATTRIBUTES (decl_parm) = attributes;\n \t      cplus_decl_attributes (&decl_parm, attributes, /*flags=*/0);\n \t    }\n-\t  decl_parm = TREE_CHAIN (decl_parm);\n-\t  pattern_parm = TREE_CHAIN (pattern_parm);\n+\t  decl_parm = DECL_CHAIN (decl_parm);\n+\t  pattern_parm = DECL_CHAIN (pattern_parm);\n \t}\n       /* Merge any parameters that match with the function parameter\n          pack.  */\n@@ -16518,7 +16518,7 @@ regenerate_decl_from_template (tree decl, tree tmpl)\n                   DECL_ATTRIBUTES (decl_parm) = attributes;\n                   cplus_decl_attributes (&decl_parm, attributes, /*flags=*/0);\n                 }\n-              decl_parm = TREE_CHAIN (decl_parm);\n+              decl_parm = DECL_CHAIN (decl_parm);\n             }\n         }\n       /* Merge additional specifiers from the CODE_PATTERN.  */\n@@ -16928,16 +16928,16 @@ instantiate_decl (tree d, int defer_ok,\n       while (tmpl_parm && !FUNCTION_PARAMETER_PACK_P (tmpl_parm))\n \t{\n \t  register_local_specialization (spec_parm, tmpl_parm);\n-\t  tmpl_parm = TREE_CHAIN (tmpl_parm);\n-\t  spec_parm = TREE_CHAIN (spec_parm);\n+\t  tmpl_parm = DECL_CHAIN (tmpl_parm);\n+\t  spec_parm = DECL_CHAIN (spec_parm);\n \t}\n       if (tmpl_parm && FUNCTION_PARAMETER_PACK_P (tmpl_parm))\n         {\n           /* Register the (value) argument pack as a specialization of\n              TMPL_PARM, then move on.  */\n \t  tree argpack = make_fnparm_pack (spec_parm);\n           register_local_specialization (argpack, tmpl_parm);\n-          tmpl_parm = TREE_CHAIN (tmpl_parm);\n+          tmpl_parm = DECL_CHAIN (tmpl_parm);\n \t  spec_parm = NULL_TREE;\n         }\n       gcc_assert (!spec_parm);"}, {"sha": "c994683aae8e0e9d46a96db43d3df8661bdeb043", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -1210,7 +1210,7 @@ create_pseudo_type_info (int tk, const char *real_name, ...)\n   /* Now add the derived fields.  */\n   while ((field_decl = va_arg (ap, tree)))\n     {\n-      TREE_CHAIN (field_decl) = fields;\n+      DECL_CHAIN (field_decl) = fields;\n       fields = field_decl;\n     }\n \n@@ -1375,7 +1375,7 @@ create_tinfo_types (void)\n \n     field = build_decl (BUILTINS_LOCATION,\n \t\t\tFIELD_DECL, NULL_TREE, const_string_type_node);\n-    TREE_CHAIN (field) = fields;\n+    DECL_CHAIN (field) = fields;\n     fields = field;\n \n     ti = VEC_index (tinfo_s, tinfo_descs, TK_TYPE_INFO_TYPE);\n@@ -1415,7 +1415,7 @@ create_tinfo_types (void)\n \n     field = build_decl (BUILTINS_LOCATION,\n \t\t\tFIELD_DECL, NULL_TREE, integer_types[itk_long]);\n-    TREE_CHAIN (field) = fields;\n+    DECL_CHAIN (field) = fields;\n     fields = field;\n \n     ti = VEC_index (tinfo_s, tinfo_descs, TK_BASE_TYPE);"}, {"sha": "0249fb06d4801310215dd61ff82021d9687626a5", "filename": "gcc/cp/search.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -170,7 +170,7 @@ accessible_base_p (tree t, tree base, bool consider_local_p)\n      public typedef created in the scope of every class.  */\n   decl = TYPE_FIELDS (base);\n   while (!DECL_SELF_REFERENCE_P (decl))\n-    decl = TREE_CHAIN (decl);\n+    decl = DECL_CHAIN (decl);\n   while (ANON_AGGR_TYPE_P (t))\n     t = TYPE_CONTEXT (t);\n   return accessible_p (t, decl, consider_local_p);\n@@ -447,7 +447,7 @@ lookup_field_1 (tree type, tree name, bool want_type)\n #ifdef GATHER_STATISTICS\n   n_calls_lookup_field_1++;\n #endif /* GATHER_STATISTICS */\n-  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+  for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n     {\n #ifdef GATHER_STATISTICS\n       n_fields_searched++;"}, {"sha": "a39e0b8dc1f005aa12e46845f57ff1f21925bbf3", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -2418,7 +2418,7 @@ finish_member_declaration (tree decl)\n     return;\n \n   /* We should see only one DECL at a time.  */\n-  gcc_assert (TREE_CHAIN (decl) == NULL_TREE);\n+  gcc_assert (DECL_CHAIN (decl) == NULL_TREE);\n \n   /* Set up access control for DECL.  */\n   TREE_PRIVATE (decl)\n@@ -2460,7 +2460,7 @@ finish_member_declaration (tree decl)\n \t CLASSTYPE_METHOD_VEC.  */\n       if (add_method (current_class_type, decl, NULL_TREE))\n \t{\n-\t  TREE_CHAIN (decl) = TYPE_METHODS (current_class_type);\n+\t  DECL_CHAIN (decl) = TYPE_METHODS (current_class_type);\n \t  TYPE_METHODS (current_class_type) = decl;\n \n \t  maybe_add_class_template_decl_list (current_class_type, decl,\n@@ -2493,7 +2493,7 @@ finish_member_declaration (tree decl)\n \t  = chainon (TYPE_FIELDS (current_class_type), decl);\n       else\n \t{\n-\t  TREE_CHAIN (decl) = TYPE_FIELDS (current_class_type);\n+\t  DECL_CHAIN (decl) = TYPE_FIELDS (current_class_type);\n \t  TYPE_FIELDS (current_class_type) = decl;\n \t}\n \n@@ -3319,7 +3319,7 @@ emit_associated_thunks (tree fn)\n     {\n       tree thunk;\n \n-      for (thunk = DECL_THUNKS (fn); thunk; thunk = TREE_CHAIN (thunk))\n+      for (thunk = DECL_THUNKS (fn); thunk; thunk = DECL_CHAIN (thunk))\n \t{\n \t  if (!THUNK_ALIAS (thunk))\n \t    {\n@@ -3329,7 +3329,7 @@ emit_associated_thunks (tree fn)\n \t\t  tree probe;\n \n \t\t  for (probe = DECL_THUNKS (thunk);\n-\t\t       probe; probe = TREE_CHAIN (probe))\n+\t\t       probe; probe = DECL_CHAIN (probe))\n \t\t    use_thunk (probe, /*emit_p=*/1);\n \t\t}\n \t    }\n@@ -5850,8 +5850,8 @@ maybe_add_lambda_conv_op (tree type)\n   DECL_NOT_REALLY_EXTERN (fn) = 1;\n   DECL_DECLARED_INLINE_P (fn) = 1;\n   DECL_STATIC_FUNCTION_P (fn) = 1;\n-  DECL_ARGUMENTS (fn) = copy_list (TREE_CHAIN (DECL_ARGUMENTS (callop)));\n-  for (arg = DECL_ARGUMENTS (fn); arg; arg = TREE_CHAIN (arg))\n+  DECL_ARGUMENTS (fn) = copy_list (DECL_CHAIN (DECL_ARGUMENTS (callop)));\n+  for (arg = DECL_ARGUMENTS (fn); arg; arg = DECL_CHAIN (arg))\n     DECL_CONTEXT (arg) = fn;\n   if (nested)\n     DECL_INTERFACE_KNOWN (fn) = 1;\n@@ -5884,7 +5884,7 @@ maybe_add_lambda_conv_op (tree type)\n \t\tnull_pointer_node);\n   argvec = make_tree_vector ();\n   VEC_quick_push (tree, argvec, arg);\n-  for (arg = DECL_ARGUMENTS (statfn); arg; arg = TREE_CHAIN (arg))\n+  for (arg = DECL_ARGUMENTS (statfn); arg; arg = DECL_CHAIN (arg))\n     VEC_safe_push (tree, gc, argvec, arg);\n   call = build_call_a (callop, VEC_length (tree, argvec),\n \t\t       VEC_address (tree, argvec));"}, {"sha": "f51722a63cfe9df580435e92f597fd662aa3b0cf", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -2136,7 +2136,7 @@ lookup_anon_field (tree t, tree type)\n {\n   tree field;\n \n-  for (field = TYPE_FIELDS (t); field; field = TREE_CHAIN (field))\n+  for (field = TYPE_FIELDS (t); field; field = DECL_CHAIN (field))\n     {\n       if (TREE_STATIC (field))\n \tcontinue;\n@@ -6988,7 +6988,7 @@ build_ptrmemfunc1 (tree type, tree delta, tree pfn)\n \n   /* Pull the FIELD_DECLs out of the type.  */\n   pfn_field = TYPE_FIELDS (type);\n-  delta_field = TREE_CHAIN (pfn_field);\n+  delta_field = DECL_CHAIN (pfn_field);\n \n   /* Make sure DELTA has the type we want.  */\n   delta = convert_and_check (delta_type_node, delta);"}, {"sha": "efe7030dabd2903d3fb4db49157b552f838b7f51", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -1115,7 +1115,7 @@ process_init_constructor_record (tree type, tree init)\n   /* Generally, we will always have an index for each initializer (which is\n      a FIELD_DECL, put by reshape_init), but compound literals don't go trough\n      reshape_init. So we need to handle both cases.  */\n-  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+  for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n     {\n       tree next;\n       tree type;"}, {"sha": "7a66a78e8caf01c041b75ce66adf913232cb64b8", "filename": "gcc/dbxout.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -1099,7 +1099,7 @@ dbxout_init (const char *input_file_name)\n static void\n dbxout_typedefs (tree syms)\n {\n-  for (; syms != NULL_TREE; syms = TREE_CHAIN (syms))\n+  for (; syms != NULL_TREE; syms = DECL_CHAIN (syms))\n     {\n       if (TREE_CODE (syms) == TYPE_DECL)\n \t{\n@@ -1423,7 +1423,7 @@ dbxout_type_fields (tree type)\n \n   /* Output the name, type, position (in bits), size (in bits) of each\n      field that we can support.  */\n-  for (tem = TYPE_FIELDS (type); tem; tem = TREE_CHAIN (tem))\n+  for (tem = TYPE_FIELDS (type); tem; tem = DECL_CHAIN (tem))\n     {\n       /* If one of the nodes is an error_mark or its type is then\n \t return early.  */\n@@ -1566,7 +1566,7 @@ dbxout_type_methods (tree type)\n \t These differ in the types of the arguments.  */\n       for (last = NULL_TREE;\n \t   fndecl && (last == NULL_TREE || DECL_NAME (fndecl) == DECL_NAME (last));\n-\t   fndecl = TREE_CHAIN (fndecl))\n+\t   fndecl = DECL_CHAIN (fndecl))\n \t/* Output the name of the field (after overloading), as\n \t   well as the name of the field before overloading, along\n \t   with its parameter list */\n@@ -3307,7 +3307,7 @@ dbxout_syms (tree syms)\n       comm_prev = comm_new;\n \n       result += dbxout_symbol (syms, 1);\n-      syms = TREE_CHAIN (syms);\n+      syms = DECL_CHAIN (syms);\n     }\n \n   if (comm_prev != NULL)\n@@ -3334,7 +3334,7 @@ dbxout_parms (tree parms)\n   ++debug_nesting;\n   emit_pending_bincls_if_required ();\n \n-  for (; parms; parms = TREE_CHAIN (parms))\n+  for (; parms; parms = DECL_CHAIN (parms))\n     if (DECL_NAME (parms)\n \t&& TREE_TYPE (parms) != error_mark_node\n \t&& DECL_RTL_SET_P (parms)\n@@ -3536,7 +3536,7 @@ dbxout_reg_parms (tree parms)\n {\n   ++debug_nesting;\n \n-  for (; parms; parms = TREE_CHAIN (parms))\n+  for (; parms; parms = DECL_CHAIN (parms))\n     if (DECL_NAME (parms) && PARM_PASSED_IN_MEMORY (parms))\n       {\n \t/* Report parms that live in registers during the function"}, {"sha": "385d5da261cc0330f3bd4b8440d2e213a0bf70c7", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -16738,7 +16738,7 @@ native_encode_initializer (tree init, unsigned char *array, int size)\n \n \t  for (cnt = 0;\n \t       VEC_iterate (constructor_elt, CONSTRUCTOR_ELTS (init), cnt, ce);\n-\t       cnt++, field = field ? TREE_CHAIN (field) : 0)\n+\t       cnt++, field = field ? DECL_CHAIN (field) : 0)\n \t    {\n \t      tree val = ce->value;\n \t      int pos, fieldsize;\n@@ -18295,7 +18295,7 @@ gen_formal_parameter_pack_die  (tree parm_pack,\n   parm_pack_die = new_die (DW_TAG_GNU_formal_parameter_pack, subr_die, parm_pack);\n   add_src_coords_attributes (parm_pack_die, parm_pack);\n \n-  for (arg = pack_arg; arg; arg = TREE_CHAIN (arg))\n+  for (arg = pack_arg; arg; arg = DECL_CHAIN (arg))\n     {\n       if (! lang_hooks.decls.function_parm_expanded_from_pack_p (arg,\n \t\t\t\t\t\t\t\t parm_pack))\n@@ -18362,7 +18362,7 @@ gen_formal_types_die (tree function_or_method_type, dw_die_ref context_die)\n \n       link = TREE_CHAIN (link);\n       if (arg)\n-\targ = TREE_CHAIN (arg);\n+\targ = DECL_CHAIN (arg);\n     }\n \n   /* If this function type has an ellipsis, add a\n@@ -18871,11 +18871,11 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t  else if (parm)\n \t    {\n \t      gen_decl_die (parm, NULL, subr_die);\n-\t      parm = TREE_CHAIN (parm);\n+\t      parm = DECL_CHAIN (parm);\n \t    }\n \n \t  if (generic_decl_parm)\n-\t    generic_decl_parm = TREE_CHAIN (generic_decl_parm);\n+\t    generic_decl_parm = DECL_CHAIN (generic_decl_parm);\n \t}\n \n       /* Decide whether we need an unspecified_parameters DIE at the end.\n@@ -19577,7 +19577,7 @@ gen_member_die (tree type, dw_die_ref context_die)\n     }\n \n   /* Now output info about the data members and type members.  */\n-  for (member = TYPE_FIELDS (type); member; member = TREE_CHAIN (member))\n+  for (member = TYPE_FIELDS (type); member; member = DECL_CHAIN (member))\n     {\n       /* If we thought we were generating minimal debug info for TYPE\n \t and then changed our minds, some of the member declarations\n@@ -19592,7 +19592,7 @@ gen_member_die (tree type, dw_die_ref context_die)\n     }\n \n   /* Now output info about the function members (if any).  */\n-  for (member = TYPE_METHODS (type); member; member = TREE_CHAIN (member))\n+  for (member = TYPE_METHODS (type); member; member = DECL_CHAIN (member))\n     {\n       /* Don't include clones in the member list.  */\n       if (DECL_ABSTRACT_ORIGIN (member))\n@@ -20158,7 +20158,7 @@ decls_for_scope (tree stmt, dw_die_ref context_die, int depth)\n      declared directly within this block but not within any nested\n      sub-blocks.  Also, nested function and tag DIEs have been\n      generated with a parent of NULL; fix that up now.  */\n-  for (decl = BLOCK_VARS (stmt); decl != NULL; decl = TREE_CHAIN (decl))\n+  for (decl = BLOCK_VARS (stmt); decl != NULL; decl = DECL_CHAIN (decl))\n     process_scope_var (stmt, decl, NULL_TREE, context_die);\n   for (i = 0; i < BLOCK_NUM_NONLOCALIZED_VARS (stmt); i++)\n     process_scope_var (stmt, NULL, BLOCK_NONLOCALIZED_VAR (stmt, i),\n@@ -20939,7 +20939,7 @@ dwarf2out_ignore_block (const_tree block)\n   tree decl;\n   unsigned int i;\n \n-  for (decl = BLOCK_VARS (block); decl; decl = TREE_CHAIN (decl))\n+  for (decl = BLOCK_VARS (block); decl; decl = DECL_CHAIN (decl))\n     if (TREE_CODE (decl) == FUNCTION_DECL\n \t|| (TREE_CODE (decl) == TYPE_DECL && TYPE_DECL_IS_STUB (decl)))\n       return 0;"}, {"sha": "32741dc6b809af671e1e6e457f9f911699037379", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -2375,7 +2375,7 @@ unshare_all_rtl_again (rtx insn)\n   set_used_decls (DECL_INITIAL (cfun->decl));\n \n   /* Make sure that virtual parameters are not shared.  */\n-  for (decl = DECL_ARGUMENTS (cfun->decl); decl; decl = TREE_CHAIN (decl))\n+  for (decl = DECL_ARGUMENTS (cfun->decl); decl; decl = DECL_CHAIN (decl))\n     set_used_flags (DECL_RTL (decl));\n \n   reset_used_flags (stack_slot_list);\n@@ -2585,7 +2585,7 @@ set_used_decls (tree blk)\n   tree t;\n \n   /* Mark decls.  */\n-  for (t = BLOCK_VARS (blk); t; t = TREE_CHAIN (t))\n+  for (t = BLOCK_VARS (blk); t; t = DECL_CHAIN (t))\n     if (DECL_RTL_SET_P (t))\n       set_used_flags (DECL_RTL (t));\n "}, {"sha": "1ffe58977eec9b85500be2e3446917cebe7609e8", "filename": "gcc/expr.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -5054,7 +5054,7 @@ count_type_elements (const_tree type, bool allow_flexarr)\n \tHOST_WIDE_INT n = 0, t;\n \ttree f;\n \n-\tfor (f = TYPE_FIELDS (type); f ; f = TREE_CHAIN (f))\n+\tfor (f = TYPE_FIELDS (type); f ; f = DECL_CHAIN (f))\n \t  if (TREE_CODE (f) == FIELD_DECL)\n \t    {\n \t      t = count_type_elements (TREE_TYPE (f), false);\n@@ -5063,7 +5063,7 @@ count_type_elements (const_tree type, bool allow_flexarr)\n \t\t  /* Check for structures with flexible array member.  */\n \t\t  tree tf = TREE_TYPE (f);\n \t\t  if (allow_flexarr\n-\t\t      && TREE_CHAIN (f) == NULL\n+\t\t      && DECL_CHAIN (f) == NULL\n \t\t      && TREE_CODE (tf) == ARRAY_TYPE\n \t\t      && TYPE_DOMAIN (tf)\n \t\t      && TYPE_MIN_VALUE (TYPE_DOMAIN (tf))"}, {"sha": "d783ff511dfc91bc9df7406d7d0cdf3572426226", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -1,3 +1,11 @@\n+2010-07-15  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* f95-lang.c: Carefully replace TREE_CHAIN with DECL_CHAIN.\n+\t* trans-common.c: Likewise.\n+\t* trans-decl.c: Likewise.\n+\t* trans-types.c: Likewise.\n+\t* trans.c: Likewise.\n+\n 2010-07-15  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/44936"}, {"sha": "5b676214e6a60ce461ccb5210265b05e41dece9c", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -310,7 +310,7 @@ struct GTY(())\n binding_level {\n   /* A chain of ..._DECL nodes for all variables, constants, functions,\n      parameters and type declarations.  These ..._DECL nodes are chained\n-     through the TREE_CHAIN field. Note that these ..._DECL nodes are stored\n+     through the DECL_CHAIN field. Note that these ..._DECL nodes are stored\n      in the reverse of the order supplied to be compatible with the\n      back-end.  */\n   tree names;\n@@ -409,7 +409,7 @@ poplevel (int keep, int reverse, int functionbody)\n   /* Clear out the meanings of the local variables of this level.  */\n \n   for (subblock_node = decl_chain; subblock_node;\n-       subblock_node = TREE_CHAIN (subblock_node))\n+       subblock_node = DECL_CHAIN (subblock_node))\n     if (DECL_NAME (subblock_node) != 0)\n       /* If the identifier was used or addressed via a local extern decl,\n          don't forget that fact.  */\n@@ -467,7 +467,7 @@ pushdecl (tree decl)\n      order. The list will be reversed later if necessary.  This needs to be\n      this way for compatibility with the back-end.  */\n \n-  TREE_CHAIN (decl) = current_binding_level->names;\n+  DECL_CHAIN (decl) = current_binding_level->names;\n   current_binding_level->names = decl;\n \n   /* For the declaration of a type, set its name if it is not already set.  */"}, {"sha": "a19facb8317c6e70a4d91e8560725e0eaaf68203", "filename": "gcc/fortran/trans-common.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ffortran%2Ftrans-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ffortran%2Ftrans-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-common.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -432,7 +432,7 @@ build_common_decl (gfc_common_head *com, tree union_type, bool is_init)\n \t     what C will do.  */\n \t  tree field = NULL_TREE;\n \t  field = TYPE_FIELDS (TREE_TYPE (decl));\n-\t  if (TREE_CHAIN (field) == NULL_TREE)\n+\t  if (DECL_CHAIN (field) == NULL_TREE)\n \t    DECL_ALIGN (decl) = TYPE_ALIGN (TREE_TYPE (field));\n \t}\n       DECL_USER_ALIGN (decl) = 0;\n@@ -608,7 +608,7 @@ create_common (gfc_common_head *com, segment_info *head, bool saw_equiv)\n     {\n       is_init = true;\n       *field_link = field;\n-      field_link = &TREE_CHAIN (field);\n+      field_link = &DECL_CHAIN (field);\n     }\n \n   for (s = head; s; s = s->next)\n@@ -617,7 +617,7 @@ create_common (gfc_common_head *com, segment_info *head, bool saw_equiv)\n \n       /* Link the field into the type.  */\n       *field_link = s->field;\n-      field_link = &TREE_CHAIN (s->field);\n+      field_link = &DECL_CHAIN (s->field);\n \n       /* Has initial value.  */\n       if (s->sym->value)"}, {"sha": "bd7363d933d8414d9d69ba4e54ce089d803efcb9", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -174,7 +174,7 @@ gfc_add_decl_to_parent_function (tree decl)\n   gcc_assert (decl);\n   DECL_CONTEXT (decl) = DECL_CONTEXT (current_function_decl);\n   DECL_NONLOCAL (decl) = 1;\n-  TREE_CHAIN (decl) = saved_parent_function_decls;\n+  DECL_CHAIN (decl) = saved_parent_function_decls;\n   saved_parent_function_decls = decl;\n }\n \n@@ -184,7 +184,7 @@ gfc_add_decl_to_function (tree decl)\n   gcc_assert (decl);\n   TREE_USED (decl) = 1;\n   DECL_CONTEXT (decl) = current_function_decl;\n-  TREE_CHAIN (decl) = saved_function_decls;\n+  DECL_CHAIN (decl) = saved_function_decls;\n   saved_function_decls = decl;\n }\n \n@@ -194,7 +194,7 @@ add_decl_as_local (tree decl)\n   gcc_assert (decl);\n   TREE_USED (decl) = 1;\n   DECL_CONTEXT (decl) = current_function_decl;\n-  TREE_CHAIN (decl) = saved_local_decls;\n+  DECL_CHAIN (decl) = saved_local_decls;\n   saved_local_decls = decl;\n }\n \n@@ -960,7 +960,7 @@ gfc_nonlocal_dummy_array_decl (gfc_symbol *sym)\n   SET_DECL_VALUE_EXPR (decl, sym->backend_decl);\n   DECL_HAS_VALUE_EXPR_P (decl) = 1;\n   DECL_CONTEXT (decl) = DECL_CONTEXT (sym->backend_decl);\n-  TREE_CHAIN (decl) = nonlocal_dummy_decls;\n+  DECL_CHAIN (decl) = nonlocal_dummy_decls;\n   nonlocal_dummy_decls = decl;\n }\n \n@@ -1091,7 +1091,7 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n \t  /* For entry master function skip over the __entry\n \t     argument.  */\n \t  if (sym->ns->proc_name->attr.entry_master)\n-\t    sym->backend_decl = TREE_CHAIN (sym->backend_decl);\n+\t    sym->backend_decl = DECL_CHAIN (sym->backend_decl);\n \t}\n \n       /* Dummy variables should already have been created.  */\n@@ -2015,7 +2015,7 @@ build_entry_thunks (gfc_namespace * ns)\n \t      tree ref = DECL_ARGUMENTS (current_function_decl);\n \t      VEC_safe_push (tree, gc, args, ref);\n \t      if (ns->proc_name->ts.type == BT_CHARACTER)\n-\t\tVEC_safe_push (tree, gc, args, TREE_CHAIN (ref));\n+\t\tVEC_safe_push (tree, gc, args, DECL_CHAIN (ref));\n \t    }\n \t}\n \n@@ -2083,7 +2083,7 @@ build_entry_thunks (gfc_namespace * ns)\n \t  gfc_add_expr_to_block (&body, tmp);\n \n \t  for (field = TYPE_FIELDS (TREE_TYPE (union_decl));\n-\t       field; field = TREE_CHAIN (field))\n+\t       field; field = DECL_CHAIN (field))\n \t    if (strcmp (IDENTIFIER_POINTER (DECL_NAME (field)),\n \t\tthunk_sym->result->name) == 0)\n \t      break;\n@@ -2219,7 +2219,7 @@ gfc_get_fake_result_decl (gfc_symbol * sym, int parent_flag)\n \t  tree field;\n \n \t  for (field = TYPE_FIELDS (TREE_TYPE (decl));\n-\t       field; field = TREE_CHAIN (field))\n+\t       field; field = DECL_CHAIN (field))\n \t    if (strcmp (IDENTIFIER_POINTER (DECL_NAME (field)),\n \t\tsym->name) == 0)\n \t      break;\n@@ -2270,7 +2270,7 @@ gfc_get_fake_result_decl (gfc_symbol * sym, int parent_flag)\n \n       if (sym->ns->proc_name->backend_decl == this_function_decl\n \t  && sym->ns->proc_name->attr.entry_master)\n-\tdecl = TREE_CHAIN (decl);\n+\tdecl = DECL_CHAIN (decl);\n \n       TREE_USED (decl) = 1;\n       if (sym->as)\n@@ -4531,8 +4531,8 @@ gfc_generate_function_code (gfc_namespace * ns)\n     {\n       tree next;\n \n-      next = TREE_CHAIN (decl);\n-      TREE_CHAIN (decl) = NULL_TREE;\n+      next = DECL_CHAIN (decl);\n+      DECL_CHAIN (decl) = NULL_TREE;\n       pushdecl (decl);\n       decl = next;\n     }\n@@ -4710,8 +4710,8 @@ gfc_process_block_locals (gfc_namespace* ns)\n     {\n       tree next;\n \n-      next = TREE_CHAIN (decl);\n-      TREE_CHAIN (decl) = NULL_TREE;\n+      next = DECL_CHAIN (decl);\n+      DECL_CHAIN (decl) = NULL_TREE;\n       pushdecl (decl);\n       decl = next;\n     }"}, {"sha": "db3a165a3ed07748c318180ac70756ff5082a131", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -1849,14 +1849,14 @@ gfc_add_field_to_struct_1 (tree context, tree name, tree type, tree **chain)\n   tree decl = build_decl (input_location, FIELD_DECL, name, type);\n \n   DECL_CONTEXT (decl) = context;\n-  TREE_CHAIN (decl) = NULL_TREE;\n+  DECL_CHAIN (decl) = NULL_TREE;\n   if (TYPE_FIELDS (context) == NULL_TREE)\n     TYPE_FIELDS (context) = decl;\n   if (chain != NULL)\n     {\n       if (*chain != NULL)\n \t**chain = decl;\n-      *chain = &TREE_CHAIN (decl);\n+      *chain = &DECL_CHAIN (decl);\n     }\n \n   return decl;\n@@ -2539,16 +2539,16 @@ gfc_get_array_descr_info (const_tree type, struct array_descr_info *info)\n     elem_size = fold_convert (gfc_array_index_type, TYPE_SIZE_UNIT (etype));\n   field = TYPE_FIELDS (TYPE_MAIN_VARIANT (type));\n   data_off = byte_position (field);\n-  field = TREE_CHAIN (field);\n-  field = TREE_CHAIN (field);\n-  field = TREE_CHAIN (field);\n+  field = DECL_CHAIN (field);\n+  field = DECL_CHAIN (field);\n+  field = DECL_CHAIN (field);\n   dim_off = byte_position (field);\n   dim_size = TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (field)));\n   field = TYPE_FIELDS (TREE_TYPE (TREE_TYPE (field)));\n   stride_suboff = byte_position (field);\n-  field = TREE_CHAIN (field);\n+  field = DECL_CHAIN (field);\n   lower_suboff = byte_position (field);\n-  field = TREE_CHAIN (field);\n+  field = DECL_CHAIN (field);\n   upper_suboff = byte_position (field);\n \n   t = base_decl;"}, {"sha": "003f6090c2f38334515baa80ebb077b12f429166", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -57,7 +57,7 @@ gfc_advance_chain (tree t, int n)\n   for (; n > 0; n--)\n     {\n       gcc_assert (t != NULL_TREE);\n-      t = TREE_CHAIN (t);\n+      t = DECL_CHAIN (t);\n     }\n   return t;\n }\n@@ -218,8 +218,8 @@ gfc_merge_block_scope (stmtblock_t * block)\n   /* Add them to the parent scope.  */\n   while (decl != NULL_TREE)\n     {\n-      next = TREE_CHAIN (decl);\n-      TREE_CHAIN (decl) = NULL_TREE;\n+      next = DECL_CHAIN (decl);\n+      DECL_CHAIN (decl) = NULL_TREE;\n \n       pushdecl (decl);\n       decl = next;"}, {"sha": "a2b4814a582f499f0c5566b33d099398e11c1425", "filename": "gcc/function.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -1793,7 +1793,7 @@ instantiate_decls_1 (tree let)\n {\n   tree t;\n \n-  for (t = BLOCK_VARS (let); t; t = TREE_CHAIN (t))\n+  for (t = BLOCK_VARS (let); t; t = DECL_CHAIN (t))\n     {\n       if (DECL_RTL_SET_P (t))\n \tinstantiate_decl_rtl (DECL_RTL (t));\n@@ -1819,7 +1819,7 @@ instantiate_decls (tree fndecl)\n   unsigned ix;\n \n   /* Process all parameters of the function.  */\n-  for (decl = DECL_ARGUMENTS (fndecl); decl; decl = TREE_CHAIN (decl))\n+  for (decl = DECL_ARGUMENTS (fndecl); decl; decl = DECL_CHAIN (decl))\n     {\n       instantiate_decl_rtl (DECL_RTL (decl));\n       instantiate_decl_rtl (DECL_INCOMING_RTL (decl));\n@@ -2222,7 +2222,7 @@ assign_parms_augmented_arg_list (struct assign_parm_data_all *all)\n   VEC(tree, heap) *fnargs = NULL;\n   tree arg;\n \n-  for (arg = DECL_ARGUMENTS (fndecl); arg; arg = TREE_CHAIN (arg))\n+  for (arg = DECL_ARGUMENTS (fndecl); arg; arg = DECL_CHAIN (arg))\n     VEC_safe_push (tree, heap, fnargs, arg);\n \n   all->orig_fnargs = DECL_ARGUMENTS (fndecl);\n@@ -2241,7 +2241,7 @@ assign_parms_augmented_arg_list (struct assign_parm_data_all *all)\n       DECL_ARTIFICIAL (decl) = 1;\n       DECL_IGNORED_P (decl) = 1;\n \n-      TREE_CHAIN (decl) = all->orig_fnargs;\n+      DECL_CHAIN (decl) = all->orig_fnargs;\n       all->orig_fnargs = decl;\n       VEC_safe_insert (tree, heap, fnargs, 0, decl);\n \n@@ -2272,7 +2272,7 @@ assign_parm_find_data_types (struct assign_parm_data_all *all, tree parm,\n   /* NAMED_ARG is a misnomer.  We really mean 'non-variadic'. */\n   if (!cfun->stdarg)\n     data->named_arg = 1;  /* No variadic parms.  */\n-  else if (TREE_CHAIN (parm))\n+  else if (DECL_CHAIN (parm))\n     data->named_arg = 1;  /* Not the last non-variadic parm. */\n   else if (targetm.calls.strict_argument_naming (&all->args_so_far))\n     data->named_arg = 1;  /* Only variadic ones are unnamed.  */\n@@ -3245,7 +3245,7 @@ assign_parms (tree fndecl)\n \t    }\n \t}\n \n-      if (cfun->stdarg && !TREE_CHAIN (parm))\n+      if (cfun->stdarg && !DECL_CHAIN (parm))\n \tassign_parms_setup_varargs (&all, &data, false);\n \n       /* Find out where the parameter arrives in this function.  */\n@@ -3825,7 +3825,7 @@ setjmp_vars_warning (bitmap setjmp_crosses, tree block)\n {\n   tree decl, sub;\n \n-  for (decl = BLOCK_VARS (block); decl; decl = TREE_CHAIN (decl))\n+  for (decl = BLOCK_VARS (block); decl; decl = DECL_CHAIN (decl))\n     {\n       if (TREE_CODE (decl) == VAR_DECL\n \t  && DECL_RTL_SET_P (decl)\n@@ -3847,7 +3847,7 @@ setjmp_args_warning (bitmap setjmp_crosses)\n {\n   tree decl;\n   for (decl = DECL_ARGUMENTS (current_function_decl);\n-       decl; decl = TREE_CHAIN (decl))\n+       decl; decl = DECL_CHAIN (decl))\n     if (DECL_RTL (decl) != 0\n \t&& REG_P (DECL_RTL (decl))\n \t&& regno_clobbered_at_setjmp (setjmp_crosses, REGNO (DECL_RTL (decl))))\n@@ -4689,7 +4689,7 @@ do_warn_unused_parameter (tree fn)\n   tree decl;\n \n   for (decl = DECL_ARGUMENTS (fn);\n-       decl; decl = TREE_CHAIN (decl))\n+       decl; decl = DECL_CHAIN (decl))\n     if (!TREE_USED (decl) && TREE_CODE (decl) == PARM_DECL\n \t&& DECL_NAME (decl) && !DECL_ARTIFICIAL (decl)\n \t&& !TREE_NO_WARNING (decl))"}, {"sha": "1f7ae2ffdac23c9347651f02377098c60daaaaf3", "filename": "gcc/gimple-low.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fgimple-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fgimple-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -241,7 +241,7 @@ gimple_check_call_args (gimple stmt)\n     {\n       for (i = 0, p = DECL_ARGUMENTS (fndecl);\n \t   i < nargs;\n-\t   i++, p = TREE_CHAIN (p))\n+\t   i++, p = DECL_CHAIN (p))\n \t{\n \t  /* We cannot distinguish a varargs function from the case\n \t     of excess parameters, still deferring the inlining decision\n@@ -894,7 +894,7 @@ record_vars_into (tree vars, tree fn)\n   if (fn != current_function_decl)\n     push_cfun (DECL_STRUCT_FUNCTION (fn));\n \n-  for (; vars; vars = TREE_CHAIN (vars))\n+  for (; vars; vars = DECL_CHAIN (vars))\n     {\n       tree var = vars;\n "}, {"sha": "0c613e4a8bbc377120b205c33d6819524e104555", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -765,7 +765,7 @@ dump_gimple_bind (pretty_printer *buffer, gimple gs, int spc, int flags)\n     {\n       tree var;\n \n-      for (var = gimple_bind_vars (gs); var; var = TREE_CHAIN (var))\n+      for (var = gimple_bind_vars (gs); var; var = DECL_CHAIN (var))\n \t{\n           newline_and_indent (buffer, 2);\n \t  print_declaration (buffer, var, spc, flags);"}, {"sha": "8b97ee3d0e8e665d9a12a56bd594654c8a3104dc", "filename": "gcc/gimplify.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -653,7 +653,7 @@ declare_vars (tree vars, gimple scope, bool debug_info)\n       gcc_assert (!block || TREE_CODE (block) == BLOCK);\n       if (!block || !debug_info)\n \t{\n-\t  TREE_CHAIN (last) = gimple_bind_vars (scope);\n+\t  DECL_CHAIN (last) = gimple_bind_vars (scope);\n \t  gimple_bind_set_vars (scope, temps);\n \t}\n       else\n@@ -701,7 +701,7 @@ force_constant_size (tree var)\n void\n gimple_add_tmp_var (tree tmp)\n {\n-  gcc_assert (!TREE_CHAIN (tmp) && !DECL_SEEN_IN_BIND_EXPR_P (tmp));\n+  gcc_assert (!DECL_CHAIN (tmp) && !DECL_SEEN_IN_BIND_EXPR_P (tmp));\n \n   /* Later processing assumes that the object size is constant, which might\n      not be true at this point.  Force the use of a constant upper bound in\n@@ -714,7 +714,7 @@ gimple_add_tmp_var (tree tmp)\n \n   if (gimplify_ctxp)\n     {\n-      TREE_CHAIN (tmp) = gimplify_ctxp->temps;\n+      DECL_CHAIN (tmp) = gimplify_ctxp->temps;\n       gimplify_ctxp->temps = tmp;\n \n       /* Mark temporaries local within the nearest enclosing parallel.  */\n@@ -1133,7 +1133,7 @@ gimplify_bind_expr (tree *expr_p, gimple_seq *pre_p)\n   tree temp = voidify_wrapper_expr (bind_expr, NULL);\n \n   /* Mark variables seen in this bind expr.  */\n-  for (t = BIND_EXPR_VARS (bind_expr); t ; t = TREE_CHAIN (t))\n+  for (t = BIND_EXPR_VARS (bind_expr); t ; t = DECL_CHAIN (t))\n     {\n       if (TREE_CODE (t) == VAR_DECL)\n \t{\n@@ -1902,7 +1902,7 @@ gimplify_var_or_parm_decl (tree *expr_p)\n \t      SET_DECL_RTL (copy, 0);\n \t      TREE_USED (copy) = 1;\n \t      block = DECL_INITIAL (current_function_decl);\n-\t      TREE_CHAIN (copy) = BLOCK_VARS (block);\n+\t      DECL_CHAIN (copy) = BLOCK_VARS (block);\n \t      BLOCK_VARS (block) = copy;\n \t      SET_DECL_VALUE_EXPR (copy, unshare_expr (value_expr));\n \t      DECL_HAS_VALUE_EXPR_P (copy) = 1;\n@@ -5392,7 +5392,7 @@ omp_firstprivatize_type_sizes (struct gimplify_omp_ctx *ctx, tree type)\n     case QUAL_UNION_TYPE:\n       {\n \ttree field;\n-\tfor (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+\tfor (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n \t  if (TREE_CODE (field) == FIELD_DECL)\n \t    {\n \t      omp_firstprivatize_variable (ctx, DECL_FIELD_OFFSET (field));\n@@ -7532,7 +7532,7 @@ gimplify_type_sizes (tree type, gimple_seq *list_p)\n     case RECORD_TYPE:\n     case UNION_TYPE:\n     case QUAL_UNION_TYPE:\n-      for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+      for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n \tif (TREE_CODE (field) == FIELD_DECL)\n \t  {\n \t    gimplify_one_sizepos (&DECL_FIELD_OFFSET (field), list_p);\n@@ -7691,7 +7691,7 @@ gimplify_body (tree *body_p, tree fndecl, bool do_parms)\n       gimple_bind_set_body (outer_bind, parm_stmts);\n \n       for (parm = DECL_ARGUMENTS (current_function_decl);\n-\t   parm; parm = TREE_CHAIN (parm))\n+\t   parm; parm = DECL_CHAIN (parm))\n \tif (DECL_HAS_VALUE_EXPR_P (parm))\n \t  {\n \t    DECL_HAS_VALUE_EXPR_P (parm) = 0;\n@@ -7741,7 +7741,7 @@ gimplify_function_tree (tree fndecl)\n   else\n     push_struct_function (fndecl);\n \n-  for (parm = DECL_ARGUMENTS (fndecl); parm ; parm = TREE_CHAIN (parm))\n+  for (parm = DECL_ARGUMENTS (fndecl); parm ; parm = DECL_CHAIN (parm))\n     {\n       /* Preliminarily mark non-addressed complex variables as eligible\n          for promotion to gimple registers.  We'll transform their uses\n@@ -8037,7 +8037,7 @@ force_gimple_operand (tree expr, gimple_seq *stmts, bool simple, tree var)\n     }\n \n   if (gimple_referenced_vars (cfun))\n-    for (t = gimplify_ctxp->temps; t ; t = TREE_CHAIN (t))\n+    for (t = gimplify_ctxp->temps; t ; t = DECL_CHAIN (t))\n       add_referenced_var (t);\n \n   pop_gimplify_context (NULL);"}, {"sha": "dd75758c9aa510a9788f5086c64eead0bc7d0fd4", "filename": "gcc/integrate.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -112,7 +112,7 @@ set_block_origin_self (tree stmt)\n \n \tfor (local_decl = BLOCK_VARS (stmt);\n \t     local_decl != NULL_TREE;\n-\t     local_decl = TREE_CHAIN (local_decl))\n+\t     local_decl = DECL_CHAIN (local_decl))\n \t  set_decl_origin_self (local_decl);\t/* Potential recursion.  */\n       }\n \n@@ -148,7 +148,7 @@ set_decl_origin_self (tree decl)\n \t{\n \t  tree arg;\n \n-\t  for (arg = DECL_ARGUMENTS (decl); arg; arg = TREE_CHAIN (arg))\n+\t  for (arg = DECL_ARGUMENTS (decl); arg; arg = DECL_CHAIN (arg))\n \t    DECL_ABSTRACT_ORIGIN (arg) = arg;\n \t  if (DECL_INITIAL (decl) != NULL_TREE\n \t      && DECL_INITIAL (decl) != error_mark_node)\n@@ -173,7 +173,7 @@ set_block_abstract_flags (tree stmt, int setting)\n \n   for (local_decl = BLOCK_VARS (stmt);\n        local_decl != NULL_TREE;\n-       local_decl = TREE_CHAIN (local_decl))\n+       local_decl = DECL_CHAIN (local_decl))\n     set_decl_abstract_flags (local_decl, setting);\n \n   for (i = 0; i < BLOCK_NUM_NONLOCALIZED_VARS (stmt); i++)\n@@ -204,7 +204,7 @@ set_decl_abstract_flags (tree decl, int setting)\n     {\n       tree arg;\n \n-      for (arg = DECL_ARGUMENTS (decl); arg; arg = TREE_CHAIN (arg))\n+      for (arg = DECL_ARGUMENTS (decl); arg; arg = DECL_CHAIN (arg))\n \tDECL_ABSTRACT (arg) = setting;\n       if (DECL_INITIAL (decl) != NULL_TREE\n \t  && DECL_INITIAL (decl) != error_mark_node)"}, {"sha": "b9e684489539cf8e67c4f90a5c6e9a0f54a16720", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -1987,7 +1987,7 @@ estimate_function_body_sizes (struct cgraph_node *node)\n       time_inlining_benefit += cost;\n       size_inlining_benefit += cost;\n     }\n-  for (arg = DECL_ARGUMENTS (node->decl); arg; arg = TREE_CHAIN (arg))\n+  for (arg = DECL_ARGUMENTS (node->decl); arg; arg = DECL_CHAIN (arg))\n     if (!VOID_TYPE_P (TREE_TYPE (arg)))\n       {\n         int cost = estimate_move_cost (TREE_TYPE (arg));"}, {"sha": "77e84c11f7a1927dd942a74814752b15100faa25", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -154,7 +154,7 @@ ipa_populate_param_decls (struct cgraph_node *node,\n   fndecl = node->decl;\n   fnargs = DECL_ARGUMENTS (fndecl);\n   param_num = 0;\n-  for (parm = fnargs; parm; parm = TREE_CHAIN (parm))\n+  for (parm = fnargs; parm; parm = DECL_CHAIN (parm))\n     {\n       info->params[param_num].decl = parm;\n       param_num++;\n@@ -169,7 +169,7 @@ count_formal_params_1 (tree fndecl)\n   tree parm;\n   int count = 0;\n \n-  for (parm = DECL_ARGUMENTS (fndecl); parm; parm = TREE_CHAIN (parm))\n+  for (parm = DECL_ARGUMENTS (fndecl); parm; parm = DECL_CHAIN (parm))\n     count++;\n \n   return count;\n@@ -616,13 +616,13 @@ type_like_member_ptr_p (tree type, tree *method_ptr, tree *delta)\n   if (method_ptr)\n     *method_ptr = fld;\n \n-  fld = TREE_CHAIN (fld);\n+  fld = DECL_CHAIN (fld);\n   if (!fld || INTEGRAL_TYPE_P (fld))\n     return false;\n   if (delta)\n     *delta = fld;\n \n-  if (TREE_CHAIN (fld))\n+  if (DECL_CHAIN (fld))\n     return false;\n \n   return true;\n@@ -1932,7 +1932,7 @@ ipa_get_vector_of_formal_parms (tree fndecl)\n \n   count = count_formal_params_1 (fndecl);\n   args = VEC_alloc (tree, heap, count);\n-  for (parm = DECL_ARGUMENTS (fndecl); parm; parm = TREE_CHAIN (parm))\n+  for (parm = DECL_ARGUMENTS (fndecl); parm; parm = DECL_CHAIN (parm))\n     VEC_quick_push (tree, args, parm);\n \n   return args;\n@@ -2017,7 +2017,7 @@ ipa_modify_formal_parameters (tree fndecl, ipa_parm_adjustment_vec adjustments,\n \t\t\t\t\t\t\t     adj->base_index),\n \t\t\t\t       new_arg_types);\n \t  *link = parm;\n-\t  link = &TREE_CHAIN (parm);\n+\t  link = &DECL_CHAIN (parm);\n \t}\n       else if (!adj->remove_param)\n \t{\n@@ -2050,7 +2050,7 @@ ipa_modify_formal_parameters (tree fndecl, ipa_parm_adjustment_vec adjustments,\n \n \t  *link = new_parm;\n \n-\t  link = &TREE_CHAIN (new_parm);\n+\t  link = &DECL_CHAIN (new_parm);\n \t}\n     }\n "}, {"sha": "4bd3f05deb86fb53af2d051fb931ca18d78e3837", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -319,7 +319,7 @@ consider_split (struct split_point *current, bitmap non_ssa_vars,\n      call overhead.  */\n   call_overhead = eni_size_weights.call_cost;\n   for (parm = DECL_ARGUMENTS (current_function_decl); parm;\n-       parm = TREE_CHAIN (parm))\n+       parm = DECL_CHAIN (parm))\n     {\n       if (!is_gimple_reg (parm))\n \t{\n@@ -889,7 +889,7 @@ split_function (struct split_point *split_point)\n \n   /* Collect the parameters of new function and args_to_skip bitmap.  */\n   for (parm = DECL_ARGUMENTS (current_function_decl);\n-       parm; parm = TREE_CHAIN (parm), num++)\n+       parm; parm = DECL_CHAIN (parm), num++)\n     if (!is_gimple_reg (parm)\n \t|| !gimple_default_def (cfun, parm)\n \t|| !bitmap_bit_p (split_point->ssa_names_to_pass,"}, {"sha": "6f62b703c5e29bcd0dbcdc349e3a2aac4cb06a4b", "filename": "gcc/ipa-struct-reorg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fipa-struct-reorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fipa-struct-reorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-struct-reorg.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -2925,7 +2925,7 @@ exclude_types_passed_to_local_func (VEC (tree, heap) **unsuitable_types)\n \ttree fn = c_node->decl;\n \ttree arg;\n \n-\tfor (arg = DECL_ARGUMENTS (fn); arg; arg = TREE_CHAIN (arg))\n+\tfor (arg = DECL_ARGUMENTS (fn); arg; arg = DECL_CHAIN (arg))\n \t  {\n \t    tree type = TREE_TYPE (arg);\n "}, {"sha": "354e651c4768e6ff8b0d172dc069ff34e440f116", "filename": "gcc/ipa-type-escape.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fipa-type-escape.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fipa-type-escape.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-type-escape.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -1048,7 +1048,7 @@ check_function_parameter_and_return_types (tree fn, bool escapes)\n \t from the TYPE_ARG_LIST. However, Geoff is wrong, this code\n \t does seem to be live.  */\n \n-      for (arg = DECL_ARGUMENTS (fn); arg; arg = TREE_CHAIN (arg))\n+      for (arg = DECL_ARGUMENTS (fn); arg; arg = DECL_CHAIN (arg))\n \t{\n \t  tree type = get_canon_type (TREE_TYPE (arg), false, false);\n \t  if (escapes)\n@@ -1767,7 +1767,7 @@ close_type_seen (tree type)\n      subfields.  */\n   for (field = TYPE_FIELDS (type);\n        field;\n-       field = TREE_CHAIN (field))\n+       field = DECL_CHAIN (field))\n     {\n       tree field_type;\n       if (TREE_CODE (field) != FIELD_DECL)"}, {"sha": "372739ff5a71a1a6c3e7ed6e48aa55c6fb831e7a", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -1,3 +1,14 @@\n+2010-07-15  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* java-tree.h: Carefully replace TREE_CHAIN with DECL_CHAIN.\n+\t* boehm.c: Likewise.\n+\t* class.c: Likewise.\n+\t* decl.c: Likewise.\n+\t* expr.c: Likewise.\n+\t* jcf-parse.c: Likewise.\n+\t* typeck.c: Likewise.\n+\t* verify-glue.c: Likewise.\n+\n 2010-07-08  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \t* boehm.c: Include diagnostic-core.h in every file that includes"}, {"sha": "2a0690ce51d266858e30c7a9e95b549bf0911c66", "filename": "gcc/java/boehm.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fjava%2Fboehm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fjava%2Fboehm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fboehm.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -63,10 +63,10 @@ mark_reference_fields (tree field,\n \t\t\t     mask, ubit,\n \t\t\t     pointer_after_end, all_bits_set,\n \t\t\t     last_set_index, last_view_index);\n-      field = TREE_CHAIN (field);\n+      field = DECL_CHAIN (field);\n     }\n \n-  for (; field != NULL_TREE; field = TREE_CHAIN (field))\n+  for (; field != NULL_TREE; field = DECL_CHAIN (field))\n     {\n       HOST_WIDE_INT offset;\n       HOST_WIDE_INT size_bytes;"}, {"sha": "78f77ab2d264c794608ec19b64ee4f66f2254bdd", "filename": "gcc/java/class.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -782,7 +782,7 @@ add_method_1 (tree this_class, int access_flags, tree name, tree function_type)\n     DECL_FUNCTION_INITIALIZED_CLASS_TABLE (fndecl) =\n       htab_create_ggc (50, htab_hash_pointer, htab_eq_pointer, NULL);\n \n-  TREE_CHAIN (fndecl) = TYPE_METHODS (this_class);\n+  DECL_CHAIN (fndecl) = TYPE_METHODS (this_class);\n   TYPE_METHODS (this_class) = fndecl;\n \n   /* If pointers to member functions use the least significant bit to\n@@ -853,7 +853,7 @@ add_field (tree klass, tree name, tree field_type, int flags)\n   tree field;\n   field = build_decl (input_location,\n \t\t      is_static ? VAR_DECL : FIELD_DECL, name, field_type);\n-  TREE_CHAIN (field) = TYPE_FIELDS (klass);\n+  DECL_CHAIN (field) = TYPE_FIELDS (klass);\n   TYPE_FIELDS (klass) = field;\n   DECL_CONTEXT (field) = klass;\n   MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC (field);\n@@ -1460,7 +1460,7 @@ make_field_value (tree fdecl)\n       field_address = build_address_of (fdecl);\n \n     index = (FIELD_STATIC (fdecl)\n-\t     ? TREE_CHAIN (TYPE_FIELDS (field_info_union_node))\n+\t     ? DECL_CHAIN (TYPE_FIELDS (field_info_union_node))\n \t     : TYPE_FIELDS (field_info_union_node));\n     value = (FIELD_STATIC (fdecl)\n \t     ? field_address\n@@ -1599,7 +1599,7 @@ get_dispatch_vector (tree type)\n \t}\n \n       for (method = TYPE_METHODS (type);  method != NULL_TREE;\n-\t   method = TREE_CHAIN (method))\n+\t   method = DECL_CHAIN (method))\n \t{\n \t  tree method_index = get_method_index (method);\n \t  if (method_index != NULL_TREE\n@@ -1842,13 +1842,13 @@ make_class_data (tree type)\n   /* Build Field array. */\n   field = TYPE_FIELDS (type);\n   while (field && DECL_ARTIFICIAL (field))\n-    field = TREE_CHAIN (field);  /* Skip dummy fields.  */\n+    field = DECL_CHAIN (field);  /* Skip dummy fields.  */\n   if (field && DECL_NAME (field) == NULL_TREE)\n-    field = TREE_CHAIN (field);  /* Skip dummy field for inherited data. */\n+    field = DECL_CHAIN (field);  /* Skip dummy field for inherited data. */\n   first_real_field = field;\n \n   /* First count static and instance fields.  */\n-  for ( ; field != NULL_TREE; field = TREE_CHAIN (field))\n+  for ( ; field != NULL_TREE; field = DECL_CHAIN (field))\n     {\n       if (! DECL_ARTIFICIAL (field))\n \t{\n@@ -1877,7 +1877,7 @@ make_class_data (tree type)\n \n     for (i = 0, field = first_real_field; \n \t field != NULL_TREE; \n-\t field = TREE_CHAIN (field), i++)\n+\t field = DECL_CHAIN (field), i++)\n     {\n       if (! DECL_ARTIFICIAL (field))\n \t{\n@@ -1894,7 +1894,7 @@ make_class_data (tree type)\n   }\n \n   for (field = first_real_field; field != NULL_TREE; \n-       field = TREE_CHAIN (field))\n+       field = DECL_CHAIN (field))\n     {\n       if (! DECL_ARTIFICIAL (field))\n \t{\n@@ -1945,7 +1945,7 @@ make_class_data (tree type)\n \n   /* Build Method array. */\n   for (method = TYPE_METHODS (type);\n-       method != NULL_TREE; method = TREE_CHAIN (method))\n+       method != NULL_TREE; method = DECL_CHAIN (method))\n     {\n       tree init;\n       if (METHOD_PRIVATE (method)\n@@ -2390,7 +2390,7 @@ push_super_field (tree this_class, tree super_class)\n   base_decl = build_decl (input_location,\n \t\t\t  FIELD_DECL, NULL_TREE, super_class);\n   DECL_IGNORED_P (base_decl) = 1;\n-  TREE_CHAIN (base_decl) = TYPE_FIELDS (this_class);\n+  DECL_CHAIN (base_decl) = TYPE_FIELDS (this_class);\n   TYPE_FIELDS (this_class) = base_decl;\n   DECL_SIZE (base_decl) = TYPE_SIZE (super_class);\n   DECL_SIZE_UNIT (base_decl) = TYPE_SIZE_UNIT (super_class);\n@@ -2550,7 +2550,7 @@ add_miranda_methods (tree base_class, tree search_class)\n          will be correct.  This code must match similar layout code in the \n          runtime.  */\n       for (method_decl = TYPE_METHODS (elt);\n-\t   method_decl; method_decl = TREE_CHAIN (method_decl))\n+\t   method_decl; method_decl = DECL_CHAIN (method_decl))\n \t{\n \t  tree sig, override;\n \n@@ -2614,7 +2614,7 @@ layout_class_methods (tree this_class)\n   TYPE_METHODS (this_class) = nreverse (TYPE_METHODS (this_class));\n \n   for (method_decl = TYPE_METHODS (this_class);\n-       method_decl; method_decl = TREE_CHAIN (method_decl))\n+       method_decl; method_decl = DECL_CHAIN (method_decl))\n     dtable_count = layout_class_method (this_class, super_class,\n \t\t\t\t\tmethod_decl, dtable_count);\n \n@@ -2629,7 +2629,7 @@ get_interface_method_index (tree method, tree interface)\n   tree meth;\n   int i = 1;\n \n-  for (meth = TYPE_METHODS (interface); ; meth = TREE_CHAIN (meth))\n+  for (meth = TYPE_METHODS (interface); ; meth = DECL_CHAIN (meth))\n     {\n       if (meth == method)\n \treturn i;"}, {"sha": "36a2c2916e047fa5feb3207fcd30e52d9731b4f6", "filename": "gcc/java/decl.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -825,7 +825,7 @@ java_init_decl_processing (void)\n   if (! flag_hash_synchronization)\n     PUSH_FIELD (input_location, object_type_node, field, \"sync_info\",\n \t\tbuild_pointer_type (object_type_node));\n-  for (t = TYPE_FIELDS (object_type_node); t != NULL_TREE; t = TREE_CHAIN (t))\n+  for (t = TYPE_FIELDS (object_type_node); t != NULL_TREE; t = DECL_CHAIN (t))\n     FIELD_PRIVATE (t) = 1;\n   FINISH_RECORD (object_type_node);\n \n@@ -907,7 +907,7 @@ java_init_decl_processing (void)\n   PUSH_FIELD (input_location, class_type_node, field, \"engine\", ptr_type_node);\n   PUSH_FIELD (input_location,\n \t      class_type_node, field, \"reflection_data\", ptr_type_node);\n-  for (t = TYPE_FIELDS (class_type_node);  t != NULL_TREE;  t = TREE_CHAIN (t))\n+  for (t = TYPE_FIELDS (class_type_node);  t != NULL_TREE;  t = DECL_CHAIN (t))\n     FIELD_PRIVATE (t) = 1;\n   push_super_field (class_type_node, object_type_node);\n \n@@ -1215,7 +1215,7 @@ lookup_name_current_level (tree name)\n   if (IDENTIFIER_LOCAL_VALUE (name) == 0)\n     return 0;\n \n-  for (t = current_binding_level->names; t; t = TREE_CHAIN (t))\n+  for (t = current_binding_level->names; t; t = DECL_CHAIN (t))\n     if (DECL_NAME (t) == name)\n       break;\n \n@@ -1284,7 +1284,7 @@ pushdecl (tree x)\n \n   /* Put decls on list in reverse order.\n      We will reverse them later if necessary.  */\n-  TREE_CHAIN (x) = b->names;\n+  DECL_CHAIN (x) = b->names;\n   b->names = x;\n \n   return x;\n@@ -1435,7 +1435,7 @@ poplevel (int keep, int reverse, int functionbody)\n   else\n     decls = current_binding_level->names;\n \n-  for (decl = decls; decl; decl = TREE_CHAIN (decl))\n+  for (decl = decls; decl; decl = DECL_CHAIN (decl))\n     if (TREE_CODE (decl) == VAR_DECL\n \t&& DECL_LANG_SPECIFIC (decl) != NULL\n \t&& DECL_LOCAL_SLOT_NUMBER (decl))\n@@ -1468,11 +1468,11 @@ poplevel (int keep, int reverse, int functionbody)\n \t  /* Copy decls from names list, ignoring labels.  */\n \t  while (decl)\n \t    {\n-\t      tree next = TREE_CHAIN (decl);\n+\t      tree next = DECL_CHAIN (decl);\n \t      if (TREE_CODE (decl) != LABEL_DECL)\n \t\t{\n \t\t  *var = decl;\n-\t\t  var = &TREE_CHAIN (decl);\n+\t\t  var = &DECL_CHAIN (decl);\n \t\t}\n \t      decl = next;\n \t    }\n@@ -1508,7 +1508,7 @@ poplevel (int keep, int reverse, int functionbody)\n \n   /* Clear out the meanings of the local variables of this level.  */\n \n-  for (link = decls; link; link = TREE_CHAIN (link))\n+  for (link = decls; link; link = DECL_CHAIN (link))\n     {\n       tree name = DECL_NAME (link);\n       if (name != 0 && IDENTIFIER_LOCAL_VALUE (name) == link)\n@@ -1604,7 +1604,7 @@ maybe_pushlevels (int pc)\n       while (*ptr != NULL_TREE\n \t     && DECL_LOCAL_START_PC (*ptr) <= pc\n \t     && DECL_LOCAL_END_PC (*ptr) == end_pc)\n-\tptr = &TREE_CHAIN (*ptr);\n+\tptr = &DECL_CHAIN (*ptr);\n       pending_local_decls = *ptr;\n       *ptr = NULL_TREE;\n \n@@ -1614,7 +1614,7 @@ maybe_pushlevels (int pc)\n \t{\n \t  tree t;\n \t  end_pc = current_binding_level->end_pc;\n-\t  for (t = decl; t != NULL_TREE; t = TREE_CHAIN (t))\n+\t  for (t = decl; t != NULL_TREE; t = DECL_CHAIN (t))\n \t    DECL_LOCAL_END_PC (t) = end_pc;\n \t}\n \n@@ -1629,7 +1629,7 @@ maybe_pushlevels (int pc)\n \t{\n \t  int index = DECL_LOCAL_SLOT_NUMBER (decl);\n \t  tree base_decl;\n-\t  next = TREE_CHAIN (decl);\n+\t  next = DECL_CHAIN (decl);\n \t  push_jvm_slot (index, decl);\n \t  pushdecl (decl);\n \t  base_decl\n@@ -1757,8 +1757,8 @@ give_name_to_locals (JCF *jcf)\n \t\t && (DECL_LOCAL_START_PC (*ptr) > start_pc\n \t\t     || (DECL_LOCAL_START_PC (*ptr) == start_pc\n \t\t\t && DECL_LOCAL_END_PC (*ptr) < end_pc)))\n-\t    ptr = &TREE_CHAIN (*ptr);\n-\t  TREE_CHAIN (decl) = *ptr;\n+\t    ptr = &DECL_CHAIN (*ptr);\n+\t  DECL_CHAIN (decl) = *ptr;\n \t  *ptr = decl;\n \t}\n     }\n@@ -1767,7 +1767,7 @@ give_name_to_locals (JCF *jcf)\n \n   /* Fill in default names for the parameters. */ \n   for (parm = DECL_ARGUMENTS (current_function_decl), i = 0;\n-       parm != NULL_TREE;  parm = TREE_CHAIN (parm), i++)\n+       parm != NULL_TREE;  parm = DECL_CHAIN (parm), i++)\n     {\n       if (DECL_NAME (parm) == NULL_TREE)\n \t{\n@@ -1840,7 +1840,7 @@ start_java_method (tree fndecl)\n       DECL_ARG_TYPE (parm_decl) = parm_type;\n \n       *ptr = parm_decl;\n-      ptr = &TREE_CHAIN (parm_decl);\n+      ptr = &DECL_CHAIN (parm_decl);\n \n       /* Add parm_decl to the decl_map. */\n       push_jvm_slot (i, parm_decl);\n@@ -1993,15 +1993,15 @@ java_mark_class_local (tree klass)\n {\n   tree t;\n \n-  for (t = TYPE_FIELDS (klass); t ; t = TREE_CHAIN (t))\n+  for (t = TYPE_FIELDS (klass); t ; t = DECL_CHAIN (t))\n     if (FIELD_STATIC (t))\n       {\n \tif (DECL_EXTERNAL (t))\n \t  VEC_safe_push (tree, gc, pending_static_fields, t);\n \tjava_mark_decl_local (t);\n       }\n \n-  for (t = TYPE_METHODS (klass); t ; t = TREE_CHAIN (t))\n+  for (t = TYPE_METHODS (klass); t ; t = DECL_CHAIN (t))\n     if (!METHOD_ABSTRACT (t))\n       {\n \tif (METHOD_NATIVE (t) && !flag_jni)\n@@ -2089,7 +2089,7 @@ java_add_local_var (tree decl)\n {\n   tree *vars = &current_binding_level->names;\n   tree next = *vars;\n-  TREE_CHAIN (decl) = next;\n+  DECL_CHAIN (decl) = next;\n   *vars = decl;\n   DECL_CONTEXT (decl) = current_function_decl;\n   MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC (decl);"}, {"sha": "3c987c5fe822734cf9fd0ac583e6dab590f3cfb7", "filename": "gcc/java/expr.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -1634,7 +1634,7 @@ lookup_field (tree *typep, tree name)\n       tree save_field;\n       int i;\n \n-      for (field = TYPE_FIELDS (*typep); field; field = TREE_CHAIN (field))\n+      for (field = TYPE_FIELDS (*typep); field; field = DECL_CHAIN (field))\n \tif (DECL_NAME (field) == name)\n \t  return field;\n \n@@ -1952,7 +1952,7 @@ attach_init_test_initialization_flags (void **entry, void *ptr)\n       if (TREE_CODE (block) == BIND_EXPR)\n         {\n \t  tree body = BIND_EXPR_BODY (block);\n-\t  TREE_CHAIN (ite->value) = BIND_EXPR_VARS (block);\n+\t  DECL_CHAIN (ite->value) = BIND_EXPR_VARS (block);\n \t  BIND_EXPR_VARS (block) = ite->value;\n \t  body = build2 (COMPOUND_EXPR, void_type_node,\n \t\t\t build1 (DECL_EXPR, void_type_node, ite->value), body);\n@@ -2239,7 +2239,7 @@ build_known_method_ref (tree method, tree method_type ATTRIBUTE_UNUSED,\n \t\t    lookup_field (&class_type_node, methods_ident),\n \t\t    NULL_TREE);\n       for (meth = TYPE_METHODS (self_type);\n-\t   ; meth = TREE_CHAIN (meth))\n+\t   ; meth = DECL_CHAIN (meth))\n \t{\n \t  if (method == meth)\n \t    break;\n@@ -2643,7 +2643,7 @@ build_jni_stub (tree method)\n       res_var = build_decl (input_location, VAR_DECL, get_identifier (\"res\"),\n \t\t\t    TREE_TYPE (TREE_TYPE (method)));\n       DECL_CONTEXT (res_var) = method;\n-      TREE_CHAIN (env_var) = res_var;\n+      DECL_CHAIN (env_var) = res_var;\n     }\n \n   method_args = DECL_ARGUMENTS (method);\n@@ -2673,7 +2673,7 @@ build_jni_stub (tree method)\n   /* All the arguments to this method become arguments to the\n      underlying JNI function.  If we had to wrap object arguments in a\n      special way, we would do that here.  */\n-  for (tem = method_args; tem != NULL_TREE; tem = TREE_CHAIN (tem))\n+  for (tem = method_args; tem != NULL_TREE; tem = DECL_CHAIN (tem))\n     {\n       int arg_bits = TREE_INT_CST_LOW (TYPE_SIZE (TREE_TYPE (tem)));\n #ifdef PARM_BOUNDARY\n@@ -3779,7 +3779,7 @@ promote_arguments (void)\n   int i;\n   tree arg;\n   for (arg = DECL_ARGUMENTS (current_function_decl), i = 0;\n-       arg != NULL_TREE;  arg = TREE_CHAIN (arg), i++)\n+       arg != NULL_TREE;  arg = DECL_CHAIN (arg), i++)\n     {\n       tree arg_type = TREE_TYPE (arg);\n       if (INTEGRAL_TYPE_P (arg_type)"}, {"sha": "110eb83e00c9c4be428a87d567110fd678d687ff", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -1461,7 +1461,7 @@ extern tree *type_map;\n   if (TYPE_FIELDS (RTYPE) == NULL_TREE)\t\\\n     TYPE_FIELDS (RTYPE) = _field; \t\\\n   else\t\t\t\t\t\\\n-    TREE_CHAIN(FIELD) = _field;\t\t\\\n+    DECL_CHAIN(FIELD) = _field;\t\t\\\n   DECL_CONTEXT (_field) = (RTYPE);\t\\\n   DECL_ARTIFICIAL (_field) = 1;\t\t\\\n   FIELD = _field; }\n@@ -1485,7 +1485,7 @@ extern tree *type_map;\n   do \\\n     { \\\n       constructor_elt *_elt___ = VEC_last (constructor_elt, V); \\\n-      tree _next___ = TREE_CHAIN (_elt___->index); \\\n+      tree _next___ = DECL_CHAIN (_elt___->index); \\\n       gcc_assert (!DECL_NAME (_elt___->index)); \\\n       _elt___->value = VALUE; \\\n       CONSTRUCTOR_APPEND_ELT (V, _next___, NULL); \\\n@@ -1499,7 +1499,7 @@ extern tree *type_map;\n   do \\\n     { \\\n       constructor_elt *_elt___ = VEC_last (constructor_elt, V); \\\n-      tree _next___ = TREE_CHAIN (_elt___->index); \\\n+      tree _next___ = DECL_CHAIN (_elt___->index); \\\n       gcc_assert (strcmp (IDENTIFIER_POINTER (DECL_NAME (_elt___->index)), \\\n \t\t\t  NAME) == 0); \\\n       _elt___->value = VALUE; \\"}, {"sha": "c27d4b553d8fc6c22fdd913574aeb350c51a0b43", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -1571,7 +1571,7 @@ parse_class_file (void)\n   gen_indirect_dispatch_tables (current_class);\n \n   for (method = TYPE_METHODS (current_class);\n-       method != NULL_TREE; method = TREE_CHAIN (method))\n+       method != NULL_TREE; method = DECL_CHAIN (method))\n     {\n       JCF *jcf = current_jcf;\n "}, {"sha": "dca14ab5f8146b389fe3e3c3cef363793a5d834f", "filename": "gcc/java/typeck.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fjava%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fjava%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Ftypeck.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -211,7 +211,7 @@ java_array_type_length (tree array_type)\n   tree arfld;\n   if (TREE_CODE (array_type) == POINTER_TYPE)\n     array_type = TREE_TYPE (array_type);\n-  arfld = TREE_CHAIN (TREE_CHAIN (TYPE_FIELDS (array_type)));\n+  arfld = DECL_CHAIN (DECL_CHAIN (TYPE_FIELDS (array_type)));\n   if (arfld != NULL_TREE)\n     {\n       tree index_type = TYPE_DOMAIN (TREE_TYPE (arfld));\n@@ -306,7 +306,7 @@ build_java_array_type (tree element_type, HOST_WIDE_INT length)\n   arfld = build_decl (input_location,\n \t\t      FIELD_DECL, get_identifier (\"data\"), atype);\n   DECL_CONTEXT (arfld) = t;\n-  TREE_CHAIN (fld) = arfld;\n+  DECL_CHAIN (fld) = arfld;\n   DECL_ALIGN (arfld) = TYPE_ALIGN (element_type);\n \n   /* We could layout_class, but that loads java.lang.Object prematurely.\n@@ -644,7 +644,7 @@ shallow_find_method (tree searched_class, int flags, tree method_name,\n {\n   tree method;\n   for (method = TYPE_METHODS (searched_class);\n-       method != NULL_TREE;  method = TREE_CHAIN (method))\n+       method != NULL_TREE;  method = DECL_CHAIN (method))\n     {\n       tree method_sig = (*signature_builder) (TREE_TYPE (method));\n       if (DECL_NAME (method) == method_name && method_sig == signature)\n@@ -779,7 +779,7 @@ tree\n lookup_java_constructor (tree clas, tree method_signature)\n {\n   tree method = TYPE_METHODS (clas);\n-  for ( ; method != NULL_TREE;  method = TREE_CHAIN (method))\n+  for ( ; method != NULL_TREE;  method = DECL_CHAIN (method))\n     {\n       tree method_sig = build_java_signature (TREE_TYPE (method));\n       if (DECL_CONSTRUCTOR_P (method) && method_sig == method_signature)"}, {"sha": "78d35495478360e2226b5ad3f2ffff5782cfd777", "filename": "gcc/java/verify-glue.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fjava%2Fverify-glue.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fjava%2Fverify-glue.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fverify-glue.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -365,7 +365,7 @@ vfy_class_has_field (vfy_jclass klass, vfy_string name,\n       if (DECL_NAME (field) == name\n \t  && build_java_signature (TREE_TYPE (field)) == signature)\n \treturn true;\n-      field = TREE_CHAIN (field);\n+      field = DECL_CHAIN (field);\n     }\n   return false;\n }"}, {"sha": "f56b42b7786c74f1d2f3cbd8d152fe53a7e792f4", "filename": "gcc/langhooks.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Flanghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Flanghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -320,7 +320,7 @@ write_global_declarations (void)\n   /* Process the decls in reverse order--earliest first.\n      Put them into VEC from back to front, then take out from front.  */\n \n-  for (i = 0, decl = globals; i < len; i++, decl = TREE_CHAIN (decl))\n+  for (i = 0, decl = globals; i < len; i++, decl = DECL_CHAIN (decl))\n     vec[len - i - 1] = decl;\n \n   wrapup_global_declarations (vec, len);"}, {"sha": "9c7af2ba50731bbcbb7e86f0220debd42a16c301", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -1487,7 +1487,7 @@ output_node_opt_summary (struct output_block *ob,\n       tree parm;\n \n       for (parm_num = 0, parm = DECL_ARGUMENTS (node->decl); parm;\n-\t   parm = TREE_CHAIN (parm), parm_num++)\n+\t   parm = DECL_CHAIN (parm), parm_num++)\n \tif (map->old_tree == parm)\n \t  break;\n       /* At the moment we assume all old trees to be PARM_DECLs, because we have no\n@@ -1571,7 +1571,7 @@ input_node_opt_summary (struct cgraph_node *node,\n \n       VEC_safe_push (ipa_replace_map_p, gc, node->clone.tree_map, map);\n       for (parm_num = 0, parm = DECL_ARGUMENTS (node->decl); parm_num;\n-\t   parm = TREE_CHAIN (parm))\n+\t   parm = DECL_CHAIN (parm))\n \tparm_num --;\n       map->parm_num = lto_input_uleb128 (ib_main);\n       map->old_tree = NULL;"}, {"sha": "de6cbebd2ad05d9d95790556f3938234ed09eb7b", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -1,3 +1,7 @@\n+2010-07-15  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* objc-act.c: Carefully replace TREE_CHAIN with DECL_CHAIN.\n+\n 2010-07-10  Iain Sandoe  <iains@gcc.gnu.org>\n \n \tPR objc/44140"}, {"sha": "81aba84eb9742b23432f30419fe6e88f11e804a2", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -455,7 +455,7 @@ add_field_decl (tree type, const char *name, tree **chain)\n \n   if (*chain != NULL)\n     **chain = field;\n-  *chain = &TREE_CHAIN (field);\n+  *chain = &DECL_CHAIN (field);\n \n   return field;\n }\n@@ -851,9 +851,9 @@ objc_build_struct (tree klass, tree fields, tree super_name)\n \t\t\t      FIELD_DECL, NULL_TREE, super);\n       tree field = TYPE_FIELDS (super);\n \n-      while (field && TREE_CHAIN (field)\n-\t     && TREE_CODE (TREE_CHAIN (field)) == FIELD_DECL)\n-\tfield = TREE_CHAIN (field);\n+      while (field && DECL_CHAIN (field)\n+\t     && TREE_CODE (DECL_CHAIN (field)) == FIELD_DECL)\n+\tfield = DECL_CHAIN (field);\n \n       /* For ObjC ABI purposes, the \"packed\" size of a base class is\n \t the sum of the offset and the size (in bits) of the last field\n@@ -882,7 +882,7 @@ objc_build_struct (tree klass, tree fields, tree super_name)\n       if (fields)\n \tTREE_NO_WARNING (fields) = 1;\t/* Suppress C++ ABI warnings -- we   */\n #endif\t\t\t\t\t/* are following the ObjC ABI here.  */\n-      TREE_CHAIN (base) = fields;\n+      DECL_CHAIN (base) = fields;\n       fields = base;\n     }\n \n@@ -1848,11 +1848,11 @@ check_string_class_template (void)\n   if (!AT_LEAST_AS_LARGE_AS (field_decl, ptr_type_node))\n     return 0;\n \n-  field_decl = TREE_CHAIN (field_decl);\n+  field_decl = DECL_CHAIN (field_decl);\n   if (!AT_LEAST_AS_LARGE_AS (field_decl, ptr_type_node))\n     return 0;\n \n-  field_decl = TREE_CHAIN (field_decl);\n+  field_decl = DECL_CHAIN (field_decl);\n   return AT_LEAST_AS_LARGE_AS (field_decl, unsigned_type_node);\n \n #undef AT_LEAST_AS_LARGE_AS\n@@ -1873,10 +1873,10 @@ objc_build_internal_const_str_type (void)\n   tree field = build_decl (input_location,\n \t\t\t   FIELD_DECL, NULL_TREE, ptr_type_node);\n \n-  TREE_CHAIN (field) = fields; fields = field;\n+  DECL_CHAIN (field) = fields; fields = field;\n   field = build_decl (input_location,\n \t\t      FIELD_DECL, NULL_TREE, unsigned_type_node);\n-  TREE_CHAIN (field) = fields; fields = field;\n+  DECL_CHAIN (field) = fields; fields = field;\n   /* NB: The finish_builtin_struct() routine expects FIELD_DECLs in\n      reverse order!  */\n   finish_builtin_struct (type, \"__builtin_ObjCString\",\n@@ -2003,11 +2003,11 @@ objc_build_string_object (tree string)\n \t\t\t      ? build_unary_op (input_location,\n \t\t\t\t\t\tADDR_EXPR, string_class_decl, 0)\n \t\t\t      : build_int_cst (NULL_TREE, 0));\n-      fields = TREE_CHAIN (fields);\n+      fields = DECL_CHAIN (fields);\n       CONSTRUCTOR_APPEND_ELT (v, fields,\n \t\t\t      build_unary_op (input_location,\n \t\t\t\t\t      ADDR_EXPR, string, 1));\n-      fields = TREE_CHAIN (fields);\n+      fields = DECL_CHAIN (fields);\n       CONSTRUCTOR_APPEND_ELT (v, fields, build_int_cst (NULL_TREE, length));\n       constructor = objc_build_constructor (internal_const_str_type, v);\n \n@@ -2231,7 +2231,7 @@ init_objc_symtab (tree type)\n     {\n \n       tree field = TYPE_FIELDS (type);\n-      field = TREE_CHAIN (TREE_CHAIN (TREE_CHAIN (TREE_CHAIN (field))));\n+      field = DECL_CHAIN (DECL_CHAIN (DECL_CHAIN (DECL_CHAIN (field))));\n \n       CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, init_def_list (TREE_TYPE (field)));\n     }\n@@ -4253,7 +4253,7 @@ build_descriptor_table_initializer (tree type, tree entries)\n       CONSTRUCTOR_APPEND_ELT (inits, NULL_TREE,\n \t\t\t      objc_build_constructor (type, elts));\n \n-      entries = TREE_CHAIN (entries);\n+      entries = DECL_CHAIN (entries);\n     }\n   while (entries);\n \n@@ -4356,7 +4356,7 @@ encode_method_prototype (tree method_decl)\n   i = int_size_in_bytes (ptr_type_node);\n   parm_offset = 2 * i;\n   for (parms = METHOD_SEL_ARGS (method_decl); parms;\n-       parms = TREE_CHAIN (parms))\n+       parms = DECL_CHAIN (parms))\n     {\n       tree type = objc_method_parm_type (parms);\n       int sz = objc_encoded_type_size (type);\n@@ -4379,7 +4379,7 @@ encode_method_prototype (tree method_decl)\n   /* Argument types.  */\n   parm_offset = 2 * i;\n   for (parms = METHOD_SEL_ARGS (method_decl); parms;\n-       parms = TREE_CHAIN (parms))\n+       parms = DECL_CHAIN (parms))\n     {\n       tree type = objc_method_parm_type (parms);\n \n@@ -4695,7 +4695,7 @@ generate_protocols (void)\n \t      encoding = encode_method_prototype (nst_methods);\n \t      METHOD_ENCODING (nst_methods) = encoding;\n \t    }\n-\t  nst_methods = TREE_CHAIN (nst_methods);\n+\t  nst_methods = DECL_CHAIN (nst_methods);\n \t}\n \n       while (cls_methods)\n@@ -4706,7 +4706,7 @@ generate_protocols (void)\n \t      METHOD_ENCODING (cls_methods) = encoding;\n \t    }\n \n-\t  cls_methods = TREE_CHAIN (cls_methods);\n+\t  cls_methods = DECL_CHAIN (cls_methods);\n \t}\n       generate_method_descriptors (p);\n \n@@ -5016,8 +5016,8 @@ check_ivars (tree inter, tree imp)\n \t\t\t   intdecls);\n \t}\n \n-      intdecls = TREE_CHAIN (intdecls);\n-      impdecls = TREE_CHAIN (impdecls);\n+      intdecls = DECL_CHAIN (intdecls);\n+      impdecls = DECL_CHAIN (impdecls);\n     }\n }\n \n@@ -5165,7 +5165,7 @@ build_ivar_list_initializer (tree type, tree field_decl)\n       CONSTRUCTOR_APPEND_ELT (inits, NULL_TREE,\n \t\t\t      objc_build_constructor (type, ivar));\n       do\n-\tfield_decl = TREE_CHAIN (field_decl);\n+\tfield_decl = DECL_CHAIN (field_decl);\n       while (field_decl && TREE_CODE (field_decl) != FIELD_DECL);\n     }\n   while (field_decl);\n@@ -5198,7 +5198,7 @@ ivar_list_length (tree t)\n {\n   int count = 0;\n \n-  for (; t; t = TREE_CHAIN (t))\n+  for (; t; t = DECL_CHAIN (t))\n     if (TREE_CODE (t) == FIELD_DECL)\n       ++count;\n \n@@ -5281,7 +5281,7 @@ build_dispatch_table_initializer (tree type, tree entries)\n       CONSTRUCTOR_APPEND_ELT (inits, NULL_TREE,\n \t\t\t      objc_build_constructor (type, elems));\n \n-      entries = TREE_CHAIN (entries);\n+      entries = DECL_CHAIN (entries);\n     }\n   while (entries);\n \n@@ -5350,14 +5350,14 @@ mark_referenced_methods (void)\n       while (chain)\n \t{\n \t  cgraph_mark_needed_node (cgraph_node (METHOD_DEFINITION (chain)));\n-\t  chain = TREE_CHAIN (chain);\n+\t  chain = DECL_CHAIN (chain);\n \t}\n \n       chain = CLASS_NST_METHODS (impent->imp_context);\n       while (chain)\n \t{\n \t  cgraph_mark_needed_node (cgraph_node (METHOD_DEFINITION (chain)));\n-\t  chain = TREE_CHAIN (chain);\n+\t  chain = DECL_CHAIN (chain);\n \t}\n     }\n }\n@@ -5990,7 +5990,7 @@ get_arg_type_list (tree meth, int context, int superflag)\n     return arglist;\n \n   /* Build a list of argument types.  */\n-  for (akey = METHOD_SEL_ARGS (meth); akey; akey = TREE_CHAIN (akey))\n+  for (akey = METHOD_SEL_ARGS (meth); akey; akey = DECL_CHAIN (akey))\n     {\n       tree arg_type = TREE_VALUE (TREE_TYPE (akey));\n \n@@ -6822,7 +6822,7 @@ lookup_method (tree mchain, tree method)\n       if (METHOD_SEL_NAME (mchain) == key)\n \treturn mchain;\n \n-      mchain = TREE_CHAIN (mchain);\n+      mchain = DECL_CHAIN (mchain);\n     }\n   return NULL_TREE;\n }\n@@ -6934,12 +6934,12 @@ objc_add_method (tree klass, tree method, int is_class)\n       /* put method on list in reverse order */\n       if (is_class)\n \t{\n-\t  TREE_CHAIN (method) = CLASS_CLS_METHODS (klass);\n+\t  DECL_CHAIN (method) = CLASS_CLS_METHODS (klass);\n \t  CLASS_CLS_METHODS (klass) = method;\n \t}\n       else\n \t{\n-\t  TREE_CHAIN (method) = CLASS_NST_METHODS (klass);\n+\t  DECL_CHAIN (method) = CLASS_NST_METHODS (klass);\n \t  CLASS_NST_METHODS (klass) = method;\n \t}\n     }\n@@ -7151,7 +7151,7 @@ add_instance_variable (tree klass, int visibility, tree field_decl)\n static tree\n is_ivar (tree decl_chain, tree ident)\n {\n-  for ( ; decl_chain; decl_chain = TREE_CHAIN (decl_chain))\n+  for ( ; decl_chain; decl_chain = DECL_CHAIN (decl_chain))\n     if (DECL_NAME (decl_chain) == ident)\n       return decl_chain;\n   return NULL_TREE;\n@@ -7278,7 +7278,7 @@ check_methods (tree chain, tree list, int mtype)\n \t\t   mtype, METHOD_SEL_NAME (chain));\n \t}\n \n-      chain = TREE_CHAIN (chain);\n+      chain = DECL_CHAIN (chain);\n     }\n \n     return first;\n@@ -7952,7 +7952,7 @@ encode_aggregate_fields (tree type, int pointed_to, int curtype, int format)\n {\n   tree field = TYPE_FIELDS (type);\n \n-  for (; field; field = TREE_CHAIN (field))\n+  for (; field; field = DECL_CHAIN (field))\n     {\n #ifdef OBJCPLUS\n       /* C++ static members, and things that are not field at all,\n@@ -8301,9 +8301,9 @@ objc_get_parm_info (int have_ellipsis)\n   declare_parm_level ();\n   while (parm_info)\n     {\n-      tree next = TREE_CHAIN (parm_info);\n+      tree next = DECL_CHAIN (parm_info);\n \n-      TREE_CHAIN (parm_info) = NULL_TREE;\n+      DECL_CHAIN (parm_info) = NULL_TREE;\n       parm_info = pushdecl (parm_info);\n       finish_decl (parm_info, input_location, NULL_TREE, NULL_TREE, NULL_TREE);\n       parm_info = next;\n@@ -8381,7 +8381,7 @@ start_method_def (tree method)\n       parm = build_decl (input_location,\n \t\t\t PARM_DECL, KEYWORD_ARG_NAME (parmlist), type);\n       objc_push_parm (parm);\n-      parmlist = TREE_CHAIN (parmlist);\n+      parmlist = DECL_CHAIN (parmlist);\n     }\n \n   if (METHOD_ADD_ARGS (method))\n@@ -8614,8 +8614,8 @@ really_start_method (tree method,\n   /* Suppress unused warnings.  */\n   TREE_USED (self_decl) = 1;\n   DECL_READ_P (self_decl) = 1;\n-  TREE_USED (TREE_CHAIN (self_decl)) = 1;\n-  DECL_READ_P (TREE_CHAIN (self_decl)) = 1;\n+  TREE_USED (DECL_CHAIN (self_decl)) = 1;\n+  DECL_READ_P (DECL_CHAIN (self_decl)) = 1;\n #ifdef OBJCPLUS\n   pop_lang_context ();\n #endif\n@@ -8973,7 +8973,7 @@ gen_method_decl (tree method)\n \t  strcat (errbuf, \")\");\n \n \t  strcat (errbuf, IDENTIFIER_POINTER (KEYWORD_ARG_NAME (chain)));\n-\t  if ((chain = TREE_CHAIN (chain)))\n+\t  if ((chain = DECL_CHAIN (chain)))\n \t    strcat (errbuf, \" \");\n         }\n       while (chain);"}, {"sha": "723c2a7df3ac15704f7f9613ee49c5b49861c93f", "filename": "gcc/omp-low.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -841,7 +841,7 @@ omp_copy_decl_2 (tree var, tree name, tree type, omp_context *ctx)\n   tree copy = copy_var_decl (var, name, type);\n \n   DECL_CONTEXT (copy) = current_function_decl;\n-  TREE_CHAIN (copy) = ctx->block_vars;\n+  DECL_CHAIN (copy) = ctx->block_vars;\n   ctx->block_vars = copy;\n \n   return copy;\n@@ -1286,13 +1286,13 @@ delete_omp_context (splay_tree_value value)\n   if (ctx->record_type)\n     {\n       tree t;\n-      for (t = TYPE_FIELDS (ctx->record_type); t ; t = TREE_CHAIN (t))\n+      for (t = TYPE_FIELDS (ctx->record_type); t ; t = DECL_CHAIN (t))\n \tDECL_ABSTRACT_ORIGIN (t) = NULL;\n     }\n   if (ctx->srecord_type)\n     {\n       tree t;\n-      for (t = TYPE_FIELDS (ctx->srecord_type); t ; t = TREE_CHAIN (t))\n+      for (t = TYPE_FIELDS (ctx->srecord_type); t ; t = DECL_CHAIN (t))\n \tDECL_ABSTRACT_ORIGIN (t) = NULL;\n     }\n \n@@ -1314,7 +1314,7 @@ fixup_child_record_type (omp_context *ctx)\n      variably_modified_type_p doesn't work the way we expect for\n      record types.  Testing each field for whether it needs remapping\n      and creating a new record by hand works, however.  */\n-  for (f = TYPE_FIELDS (type); f ; f = TREE_CHAIN (f))\n+  for (f = TYPE_FIELDS (type); f ; f = DECL_CHAIN (f))\n     if (variably_modified_type_p (TREE_TYPE (f), ctx->cb.src_fn))\n       break;\n   if (f)\n@@ -1327,12 +1327,12 @@ fixup_child_record_type (omp_context *ctx)\n \t\t\t TYPE_DECL, name, type);\n       TYPE_NAME (type) = name;\n \n-      for (f = TYPE_FIELDS (ctx->record_type); f ; f = TREE_CHAIN (f))\n+      for (f = TYPE_FIELDS (ctx->record_type); f ; f = DECL_CHAIN (f))\n \t{\n \t  tree new_f = copy_node (f);\n \t  DECL_CONTEXT (new_f) = type;\n \t  TREE_TYPE (new_f) = remap_type (TREE_TYPE (f), &ctx->cb);\n-\t  TREE_CHAIN (new_f) = new_fields;\n+\t  DECL_CHAIN (new_f) = new_fields;\n \t  walk_tree (&DECL_SIZE (new_f), copy_tree_body_r, &ctx->cb, NULL);\n \t  walk_tree (&DECL_SIZE_UNIT (new_f), copy_tree_body_r,\n \t\t     &ctx->cb, NULL);\n@@ -1596,7 +1596,7 @@ create_omp_child_function (omp_context *ctx, bool task_copy)\n       DECL_CONTEXT (t) = current_function_decl;\n       TREE_USED (t) = 1;\n       TREE_ADDRESSABLE (t) = 1;\n-      TREE_CHAIN (t) = DECL_ARGUMENTS (decl);\n+      DECL_CHAIN (t) = DECL_ARGUMENTS (decl);\n       DECL_ARGUMENTS (decl) = t;\n     }\n \n@@ -1721,7 +1721,7 @@ scan_omp_task (gimple_stmt_iterator *gsi, omp_context *outer_ctx)\n \t    q = &TREE_CHAIN (*q);\n \t  }\n \telse\n-\t  p = &TREE_CHAIN (*p);\n+\t  p = &DECL_CHAIN (*p);\n       *p = vla_fields;\n       layout_type (ctx->record_type);\n       fixup_child_record_type (ctx);\n@@ -2009,7 +2009,7 @@ scan_omp_1_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n \n \t*handled_ops_p = false;\n \tif (ctx)\n-\t  for (var = gimple_bind_vars (stmt); var ; var = TREE_CHAIN (var))\n+\t  for (var = gimple_bind_vars (stmt); var ; var = DECL_CHAIN (var))\n \t    insert_decl_map (&ctx->cb, var, var);\n       }\n       break;\n@@ -2838,7 +2838,7 @@ lower_send_shared_vars (gimple_seq *ilist, gimple_seq *olist, omp_context *ctx)\n     return;\n \n   record_type = ctx->srecord_type ? ctx->srecord_type : ctx->record_type;\n-  for (f = TYPE_FIELDS (record_type); f ; f = TREE_CHAIN (f))\n+  for (f = TYPE_FIELDS (record_type); f ; f = DECL_CHAIN (f))\n     {\n       ovar = DECL_ABSTRACT_ORIGIN (f);\n       nvar = maybe_lookup_decl (ovar, ctx);\n@@ -3146,7 +3146,7 @@ vec2chain (VEC(tree,gc) *v)\n \n   FOR_EACH_VEC_ELT_REVERSE (tree, v, ix, t)\n     {\n-      TREE_CHAIN (t) = chain;\n+      DECL_CHAIN (t) = chain;\n       chain = t;\n     }\n \n@@ -3227,7 +3227,7 @@ remove_exit_barrier (struct omp_region *region)\n \t\t{\n \t\t  for (local_decls = BLOCK_VARS (block);\n \t\t       local_decls;\n-\t\t       local_decls = TREE_CHAIN (local_decls))\n+\t\t       local_decls = DECL_CHAIN (local_decls))\n \t\t    if (TREE_ADDRESSABLE (local_decls))\n \t\t      {\n \t\t\tany_addressable_vars = 1;\n@@ -3463,7 +3463,7 @@ expand_omp_taskreg (struct omp_region *region)\n       /* The gimplifier could record temporaries in parallel/task block\n \t rather than in containing function's local_decls chain,\n \t which would mean cgraph missed finalizing them.  Do it now.  */\n-      for (t = BLOCK_VARS (block); t; t = TREE_CHAIN (t))\n+      for (t = BLOCK_VARS (block); t; t = DECL_CHAIN (t))\n \tif (TREE_CODE (t) == VAR_DECL\n \t    && TREE_STATIC (t)\n \t    && !DECL_EXTERNAL (t))\n@@ -3473,7 +3473,7 @@ expand_omp_taskreg (struct omp_region *region)\n       TREE_USED (block) = 1;\n \n       /* Reset DECL_CONTEXT on function arguments.  */\n-      for (t = DECL_ARGUMENTS (child_fn); t; t = TREE_CHAIN (t))\n+      for (t = DECL_ARGUMENTS (child_fn); t; t = DECL_CHAIN (t))\n \tDECL_CONTEXT (t) = child_fn;\n \n       /* Split ENTRY_BB at GIMPLE_OMP_PARALLEL or GIMPLE_OMP_TASK,\n@@ -6221,7 +6221,7 @@ create_task_copyfn (gimple task_stmt, omp_context *ctx)\n   DECL_SAVED_TREE (child_fn) = alloc_stmt_list ();\n \n   /* Reset DECL_CONTEXT on function arguments.  */\n-  for (t = DECL_ARGUMENTS (child_fn); t; t = TREE_CHAIN (t))\n+  for (t = DECL_ARGUMENTS (child_fn); t; t = DECL_CHAIN (t))\n     DECL_CONTEXT (t) = child_fn;\n \n   /* Populate the function.  */\n@@ -6237,13 +6237,13 @@ create_task_copyfn (gimple task_stmt, omp_context *ctx)\n   /* Remap src and dst argument types if needed.  */\n   record_type = ctx->record_type;\n   srecord_type = ctx->srecord_type;\n-  for (f = TYPE_FIELDS (record_type); f ; f = TREE_CHAIN (f))\n+  for (f = TYPE_FIELDS (record_type); f ; f = DECL_CHAIN (f))\n     if (variably_modified_type_p (TREE_TYPE (f), ctx->cb.src_fn))\n       {\n \trecord_needs_remap = true;\n \tbreak;\n       }\n-  for (f = TYPE_FIELDS (srecord_type); f ; f = TREE_CHAIN (f))\n+  for (f = TYPE_FIELDS (srecord_type); f ; f = DECL_CHAIN (f))\n     if (variably_modified_type_p (TREE_TYPE (f), ctx->cb.src_fn))\n       {\n \tsrecord_needs_remap = true;\n@@ -6276,7 +6276,7 @@ create_task_copyfn (gimple task_stmt, omp_context *ctx)\n \n   arg = DECL_ARGUMENTS (child_fn);\n   TREE_TYPE (arg) = build_pointer_type (record_type);\n-  sarg = TREE_CHAIN (arg);\n+  sarg = DECL_CHAIN (arg);\n   TREE_TYPE (sarg) = build_pointer_type (srecord_type);\n \n   /* First pass: initialize temporaries used in record_type and srecord_type"}, {"sha": "d4b266282c7a3f3a379d3a52ab1979e3f6e2de89", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -313,7 +313,7 @@ self_referential_size (tree size)\n   sprintf (buf, \"SZ\"HOST_WIDE_INT_PRINT_UNSIGNED, fnno++);\n   fnname = get_file_function_name (buf);\n   fndecl = build_decl (input_location, FUNCTION_DECL, fnname, fntype);\n-  for (t = param_decl_list; t; t = TREE_CHAIN (t))\n+  for (t = param_decl_list; t; t = DECL_CHAIN (t))\n     DECL_CONTEXT (t) = fndecl;\n   DECL_ARGUMENTS (fndecl) = param_decl_list;\n   DECL_RESULT (fndecl)\n@@ -1429,8 +1429,8 @@ place_field (record_layout_info rli, tree field)\n \n       /* If we ended a bitfield before the full length of the type then\n \t pad the struct out to the full length of the last type.  */\n-      if ((TREE_CHAIN (field) == NULL\n-\t   || TREE_CODE (TREE_CHAIN (field)) != FIELD_DECL)\n+      if ((DECL_CHAIN (field) == NULL\n+\t   || TREE_CODE (DECL_CHAIN (field)) != FIELD_DECL)\n \t  && DECL_BIT_FIELD_TYPE (field)\n \t  && !integer_zerop (DECL_SIZE (field)))\n \trli->bitpos = size_binop (PLUS_EXPR, rli->bitpos,\n@@ -1551,7 +1551,7 @@ compute_record_mode (tree type)\n   /* A record which has any BLKmode members must itself be\n      BLKmode; it can't go in a register.  Unless the member is\n      BLKmode only because it isn't aligned.  */\n-  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+  for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n     {\n       if (TREE_CODE (field) != FIELD_DECL)\n \tcontinue;\n@@ -1746,8 +1746,8 @@ finish_builtin_struct (tree type, const char *name, tree fields,\n   for (tail = NULL_TREE; fields; tail = fields, fields = next)\n     {\n       DECL_FIELD_CONTEXT (fields) = type;\n-      next = TREE_CHAIN (fields);\n-      TREE_CHAIN (fields) = tail;\n+      next = DECL_CHAIN (fields);\n+      DECL_CHAIN (fields) = tail;\n     }\n   TYPE_FIELDS (type) = tail;\n \n@@ -2061,7 +2061,7 @@ layout_type (tree type)\n \t  TYPE_FIELDS (type) = nreverse (TYPE_FIELDS (type));\n \n \t/* Place all the fields.  */\n-\tfor (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+\tfor (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n \t  place_field (rli, field);\n \n \tif (TREE_CODE (type) == QUAL_UNION_TYPE)"}, {"sha": "d132920533370130b0dadb522df12f952b8c2d6e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -1,3 +1,8 @@\n+2010-07-15  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* g++.dg/plugin/attribute_plugin.c: Carefully replace TREE_CHAIN\n+\twith DECL_CHAIN.\n+\n 2010-07-15  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/44936"}, {"sha": "5bbb29c0697dc1fa4b5921080de954f720cc40a4", "filename": "gcc/testsuite/g++.dg/plugin/attribute_plugin.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fattribute_plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fattribute_plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fattribute_plugin.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -43,7 +43,7 @@ handle_pre_generic (void *event_data, void *data)\n {\n   tree fndecl = (tree) event_data;\n   tree arg;\n-  for (arg = DECL_ARGUMENTS(fndecl); arg; arg = TREE_CHAIN (arg)) {\n+  for (arg = DECL_ARGUMENTS(fndecl); arg; arg = DECL_CHAIN (arg)) {\n       tree attr;\n       for (attr = DECL_ATTRIBUTES (arg); attr; attr = TREE_CHAIN (attr)) {\n           tree attrname = TREE_PURPOSE (attr);"}, {"sha": "413d7a9fb9780f71cd84b368e3e9a6e9e9bbbd0e", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -6072,7 +6072,7 @@ replace_block_vars_by_duplicates (tree block, struct pointer_map_t *vars_map,\n {\n   tree *tp, t;\n \n-  for (tp = &BLOCK_VARS (block); *tp; tp = &TREE_CHAIN (*tp))\n+  for (tp = &BLOCK_VARS (block); *tp; tp = &DECL_CHAIN (*tp))\n     {\n       t = *tp;\n       if (TREE_CODE (t) != VAR_DECL && TREE_CODE (t) != CONST_DECL)\n@@ -6085,7 +6085,7 @@ replace_block_vars_by_duplicates (tree block, struct pointer_map_t *vars_map,\n \t      SET_DECL_VALUE_EXPR (t, DECL_VALUE_EXPR (*tp));\n \t      DECL_HAS_VALUE_EXPR_P (t) = 1;\n \t    }\n-\t  TREE_CHAIN (t) = TREE_CHAIN (*tp);\n+\t  DECL_CHAIN (t) = DECL_CHAIN (*tp);\n \t  *tp = t;\n \t}\n     }\n@@ -6337,9 +6337,9 @@ dump_function_to_file (tree fn, FILE *file, int flags)\n       print_generic_expr (file, arg, dump_flags);\n       if (flags & TDF_VERBOSE)\n \tprint_node (file, \"\", arg, 4);\n-      if (TREE_CHAIN (arg))\n+      if (DECL_CHAIN (arg))\n \tfprintf (file, \", \");\n-      arg = TREE_CHAIN (arg);\n+      arg = DECL_CHAIN (arg);\n     }\n   fprintf (file, \")\\n\");\n "}, {"sha": "49165713725ba2d17286d7f5dec1e386b23d2878", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -174,7 +174,7 @@ init_parameter_lattice_values (void)\n {\n   tree parm, ssa_name;\n \n-  for (parm = DECL_ARGUMENTS (cfun->decl); parm ; parm = TREE_CHAIN (parm))\n+  for (parm = DECL_ARGUMENTS (cfun->decl); parm ; parm = DECL_CHAIN (parm))\n     if (is_complex_reg (parm)\n \t&& var_ann (parm) != NULL\n \t&& (ssa_name = gimple_default_def (cfun, parm)) != NULL_TREE)\n@@ -680,7 +680,7 @@ update_parameter_components (void)\n   edge entry_edge = single_succ_edge (ENTRY_BLOCK_PTR);\n   tree parm;\n \n-  for (parm = DECL_ARGUMENTS (cfun->decl); parm ; parm = TREE_CHAIN (parm))\n+  for (parm = DECL_ARGUMENTS (cfun->decl); parm ; parm = DECL_CHAIN (parm))\n     {\n       tree type = TREE_TYPE (parm);\n       tree ssa_name, r, i;"}, {"sha": "37e15bf7ee23f5452373911c9203c48e919a07f3", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -770,9 +770,9 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n \t\t    && maxsize != -1)\n \t\t  {\n \t\t    tree stype = TREE_TYPE (TREE_OPERAND (exp, 0));\n-\t\t    tree next = TREE_CHAIN (field);\n+\t\t    tree next = DECL_CHAIN (field);\n \t\t    while (next && TREE_CODE (next) != FIELD_DECL)\n-\t\t      next = TREE_CHAIN (next);\n+\t\t      next = DECL_CHAIN (next);\n \t\t    if (!next\n \t\t\t|| TREE_CODE (stype) != RECORD_TYPE)\n \t\t      {"}, {"sha": "75fb7f72441913f6ae7d75e687f141fd7c94259a", "filename": "gcc/tree-dump.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ftree-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ftree-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -370,8 +370,8 @@ dequeue_and_dump (dump_info_p di)\n       if (CODE_CONTAINS_STRUCT (TREE_CODE (t), TS_DECL_COMMON)\n \t  && DECL_ARTIFICIAL (t))\n \tdump_string_field (di, \"note\", \"artificial\");\n-      if (TREE_CHAIN (t) && !dump_flag (di, TDF_SLIM, NULL))\n-\tdump_child (\"chan\", TREE_CHAIN (t));\n+      if (DECL_CHAIN (t) && !dump_flag (di, TDF_SLIM, NULL))\n+\tdump_child (\"chain\", DECL_CHAIN (t));\n     }\n   else if (code_class == tcc_type)\n     {"}, {"sha": "5b429eb5485f85428a7f2b4d8cc56e9834611d33", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -422,11 +422,11 @@ remap_type_1 (tree type, copy_body_data *id)\n       {\n \ttree f, nf = NULL;\n \n-\tfor (f = TYPE_FIELDS (new_tree); f ; f = TREE_CHAIN (f))\n+\tfor (f = TYPE_FIELDS (new_tree); f ; f = DECL_CHAIN (f))\n \t  {\n \t    t = remap_decl (f, id);\n \t    DECL_CONTEXT (t) = new_tree;\n-\t    TREE_CHAIN (t) = nf;\n+\t    DECL_CHAIN (t) = nf;\n \t    nf = t;\n \t  }\n \tTYPE_FIELDS (new_tree) = nreverse (nf);\n@@ -537,7 +537,7 @@ remap_decls (tree decls, VEC(tree,gc) **nonlocalized_list, copy_body_data *id)\n   tree new_decls = NULL_TREE;\n \n   /* Remap its variables.  */\n-  for (old_var = decls; old_var; old_var = TREE_CHAIN (old_var))\n+  for (old_var = decls; old_var; old_var = DECL_CHAIN (old_var))\n     {\n       tree new_var;\n \n@@ -573,7 +573,7 @@ remap_decls (tree decls, VEC(tree,gc) **nonlocalized_list, copy_body_data *id)\n       else\n \t{\n \t  gcc_assert (DECL_P (new_var));\n-\t  TREE_CHAIN (new_var) = new_decls;\n+\t  DECL_CHAIN (new_var) = new_decls;\n \t  new_decls = new_var;\n  \n \t  /* Also copy value-expressions.  */\n@@ -1595,7 +1595,7 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \t      size_t nargs = gimple_call_num_args (id->gimple_call);\n \t      size_t n;\n \n-\t      for (p = DECL_ARGUMENTS (id->src_fn); p; p = TREE_CHAIN (p))\n+\t      for (p = DECL_ARGUMENTS (id->src_fn); p; p = DECL_CHAIN (p))\n \t\tnargs--;\n \n \t      /* Create the new array of arguments.  */\n@@ -1642,7 +1642,7 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \t      tree count, p;\n \t      gimple new_stmt;\n \n-\t      for (p = DECL_ARGUMENTS (id->src_fn); p; p = TREE_CHAIN (p))\n+\t      for (p = DECL_ARGUMENTS (id->src_fn); p; p = DECL_CHAIN (p))\n \t\tnargs--;\n \n \t      count = build_int_cst (integer_type_node, nargs);\n@@ -2553,7 +2553,7 @@ setup_one_parameter (copy_body_data *id, tree p, tree value, tree fn,\n     }\n \n   /* Declare this new variable.  */\n-  TREE_CHAIN (var) = *vars;\n+  DECL_CHAIN (var) = *vars;\n   *vars = var;\n \n   /* Make gimplifier happy about this variable.  */\n@@ -2683,7 +2683,7 @@ initialize_inlined_parameters (copy_body_data *id, gimple stmt,\n \n   /* Loop through the parameter declarations, replacing each with an\n      equivalent VAR_DECL, appropriately initialized.  */\n-  for (p = parms, i = 0; p; p = TREE_CHAIN (p), i++)\n+  for (p = parms, i = 0; p; p = DECL_CHAIN (p), i++)\n     {\n       tree val;\n       val = i < gimple_call_num_args (stmt) ? gimple_call_arg (stmt, i) : NULL;\n@@ -2693,7 +2693,7 @@ initialize_inlined_parameters (copy_body_data *id, gimple stmt,\n      in a second loop over all parameters to appropriately remap\n      variable sized arrays when the size is specified in a\n      parameter following the array.  */\n-  for (p = parms, i = 0; p; p = TREE_CHAIN (p), i++)\n+  for (p = parms, i = 0; p; p = DECL_CHAIN (p), i++)\n     {\n       tree *varp = (tree *) pointer_map_contains (id->decl_map, p);\n       if (varp\n@@ -3505,7 +3505,7 @@ estimate_num_insns (gimple stmt, eni_weights *weights)\n \tif (decl && DECL_ARGUMENTS (decl) && !stdarg)\n \t  {\n \t    tree arg;\n-\t    for (arg = DECL_ARGUMENTS (decl); arg; arg = TREE_CHAIN (arg))\n+\t    for (arg = DECL_ARGUMENTS (decl); arg; arg = DECL_CHAIN (arg))\n \t      if (!VOID_TYPE_P (TREE_TYPE (arg)))\n \t        cost += estimate_move_cost (TREE_TYPE (arg));\n \t  }\n@@ -4663,7 +4663,7 @@ static void\n declare_inline_vars (tree block, tree vars)\n {\n   tree t;\n-  for (t = vars; t; t = TREE_CHAIN (t))\n+  for (t = vars; t; t = DECL_CHAIN (t))\n     {\n       DECL_SEEN_IN_BIND_EXPR_P (t) = 1;\n       gcc_assert (!TREE_STATIC (t) && !TREE_ASM_WRITTEN (t));\n@@ -4812,13 +4812,13 @@ copy_arguments_for_versioning (tree orig_parm, copy_body_data * id,\n \n   parg = &new_parm;\n \n-  for (arg = orig_parm; arg; arg = TREE_CHAIN (arg), i++)\n+  for (arg = orig_parm; arg; arg = DECL_CHAIN (arg), i++)\n     if (!args_to_skip || !bitmap_bit_p (args_to_skip, i))\n       {\n         tree new_tree = remap_decl (arg, id);\n         lang_hooks.dup_lang_specific_decl (new_tree);\n         *parg = new_tree;\n-\tparg = &TREE_CHAIN (new_tree);\n+\tparg = &DECL_CHAIN (new_tree);\n       }\n     else if (!pointer_map_contains (id->decl_map, arg))\n       {\n@@ -4830,7 +4830,7 @@ copy_arguments_for_versioning (tree orig_parm, copy_body_data * id,\n \tadd_referenced_var (var);\n \tinsert_decl_map (id, arg, var);\n         /* Declare this new variable.  */\n-        TREE_CHAIN (var) = *vars;\n+        DECL_CHAIN (var) = *vars;\n         *vars = var;\n       }\n   return new_parm;\n@@ -4843,11 +4843,11 @@ copy_static_chain (tree static_chain, copy_body_data * id)\n   tree *chain_copy, *pvar;\n \n   chain_copy = &static_chain;\n-  for (pvar = chain_copy; *pvar; pvar = &TREE_CHAIN (*pvar))\n+  for (pvar = chain_copy; *pvar; pvar = &DECL_CHAIN (*pvar))\n     {\n       tree new_tree = remap_decl (*pvar, id);\n       lang_hooks.dup_lang_specific_decl (new_tree);\n-      TREE_CHAIN (new_tree) = TREE_CHAIN (*pvar);\n+      DECL_CHAIN (new_tree) = DECL_CHAIN (*pvar);\n       *pvar = new_tree;\n     }\n   return static_chain;\n@@ -5081,7 +5081,7 @@ tree_function_versioning (tree old_decl, tree new_decl,\n \t      {\n \t\tint i = replace_info->parm_num;\n \t\ttree parm;\n-\t\tfor (parm = DECL_ARGUMENTS (old_decl); i; parm = TREE_CHAIN (parm))\n+\t\tfor (parm = DECL_ARGUMENTS (old_decl); i; parm = DECL_CHAIN (parm))\n \t\t  i --;\n \t\treplace_info->old_tree = parm;\n \t      }\n@@ -5220,7 +5220,7 @@ maybe_inline_call_in_expr (tree exp)\n       /* Remap the parameters.  */\n       for (param = DECL_ARGUMENTS (fn), arg = first_call_expr_arg (exp, &iter);\n \t   param;\n-\t   param = TREE_CHAIN (param), arg = next_call_expr_arg (&iter))\n+\t   param = DECL_CHAIN (param), arg = next_call_expr_arg (&iter))\n \t*pointer_map_insert (decl_map, param) = arg;\n \n       memset (&id, 0, sizeof (id));"}, {"sha": "b5a3e43f470bb8ffb65cc1305a0566604026f8f8", "filename": "gcc/tree-mudflap.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ftree-mudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ftree-mudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-mudflap.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -322,7 +322,7 @@ mf_make_mf_cache_struct_type (tree field_type)\n   tree struct_type = make_node (RECORD_TYPE);\n   DECL_CONTEXT (fieldlo) = struct_type;\n   DECL_CONTEXT (fieldhi) = struct_type;\n-  TREE_CHAIN (fieldlo) = fieldhi;\n+  DECL_CHAIN (fieldlo) = fieldhi;\n   TYPE_FIELDS (struct_type) = fieldlo;\n   TYPE_NAME (struct_type) = get_identifier (\"__mf_cache\");\n   layout_type (struct_type);\n@@ -622,7 +622,7 @@ mf_build_check_statement_for (tree base, tree limit,\n \n   u = build3 (COMPONENT_REF, mf_uintptr_type,\n               build1 (INDIRECT_REF, mf_cache_struct_type, mf_elem),\n-              TREE_CHAIN (TYPE_FIELDS (mf_cache_struct_type)), NULL_TREE);\n+              DECL_CHAIN (TYPE_FIELDS (mf_cache_struct_type)), NULL_TREE);\n \n   v = mf_limit;\n \n@@ -1114,7 +1114,7 @@ mx_register_decls (tree decl, gimple_seq seq, location_t location)\n           mf_mark (decl);\n         }\n \n-      decl = TREE_CHAIN (decl);\n+      decl = DECL_CHAIN (decl);\n     }\n \n   /* Actually, (initially_stmts!=NULL) <=> (finally_stmts!=NULL) */"}, {"sha": "81ae38f6f3aca38ab85bb0cb3a8bdb0aa9d9808f", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -148,7 +148,7 @@ create_tmp_var_for (struct nesting_info *info, tree type, const char *prefix)\n \n   tmp_var = create_tmp_var_raw (type, prefix);\n   DECL_CONTEXT (tmp_var) = info->context;\n-  TREE_CHAIN (tmp_var) = info->new_local_var_chain;\n+  DECL_CHAIN (tmp_var) = info->new_local_var_chain;\n   DECL_SEEN_IN_BIND_EXPR_P (tmp_var) = 1;\n   if (TREE_CODE (type) == COMPLEX_TYPE\n       || TREE_CODE (type) == VECTOR_TYPE)\n@@ -198,11 +198,11 @@ insert_field_into_struct (tree type, tree field)\n \n   DECL_CONTEXT (field) = type;\n \n-  for (p = &TYPE_FIELDS (type); *p ; p = &TREE_CHAIN (*p))\n+  for (p = &TYPE_FIELDS (type); *p ; p = &DECL_CHAIN (*p))\n     if (DECL_ALIGN (field) >= DECL_ALIGN (*p))\n       break;\n \n-  TREE_CHAIN (field) = *p;\n+  DECL_CHAIN (field) = *p;\n   *p = field;\n \n   /* Set correct alignment for frame struct type.  */\n@@ -698,7 +698,7 @@ check_for_nested_with_variably_modified (tree fndecl, tree orig_fndecl)\n \n   for (cgn = cgn->nested; cgn ; cgn = cgn->next_nested)\n     {\n-      for (arg = DECL_ARGUMENTS (cgn->decl); arg; arg = TREE_CHAIN (arg))\n+      for (arg = DECL_ARGUMENTS (cgn->decl); arg; arg = DECL_CHAIN (arg))\n \tif (variably_modified_type_p (TREE_TYPE (arg), orig_fndecl))\n \t  return true;\n \n@@ -875,7 +875,7 @@ get_nonlocal_debug_decl (struct nesting_info *info, tree decl)\n   DECL_HAS_VALUE_EXPR_P (new_decl) = 1;\n \n   *slot = new_decl;\n-  TREE_CHAIN (new_decl) = info->debug_var_chain;\n+  DECL_CHAIN (new_decl) = info->debug_var_chain;\n   info->debug_var_chain = new_decl;\n \n   if (!optimize\n@@ -1202,7 +1202,7 @@ note_nonlocal_block_vlas (struct nesting_info *info, tree block)\n {\n   tree var;\n \n-  for (var = BLOCK_VARS (block); var; var = TREE_CHAIN (var))\n+  for (var = BLOCK_VARS (block); var; var = DECL_CHAIN (var))\n     if (TREE_CODE (var) == VAR_DECL\n \t&& variably_modified_type_p (TREE_TYPE (var), NULL)\n \t&& DECL_HAS_VALUE_EXPR_P (var)\n@@ -1367,7 +1367,7 @@ get_local_debug_decl (struct nesting_info *info, tree decl, tree field)\n   DECL_HAS_VALUE_EXPR_P (new_decl) = 1;\n   *slot = new_decl;\n \n-  TREE_CHAIN (new_decl) = info->debug_var_chain;\n+  DECL_CHAIN (new_decl) = info->debug_var_chain;\n   info->debug_var_chain = new_decl;\n \n   /* Do not emit debug info twice.  */\n@@ -2196,7 +2196,7 @@ remap_vla_decls (tree block, struct nesting_info *root)\n        subblock = BLOCK_CHAIN (subblock))\n     remap_vla_decls (subblock, root);\n \n-  for (var = BLOCK_VARS (block); var; var = TREE_CHAIN (var))\n+  for (var = BLOCK_VARS (block); var; var = DECL_CHAIN (var))\n     {\n       if (TREE_CODE (var) == VAR_DECL\n \t  && variably_modified_type_p (TREE_TYPE (var), NULL)\n@@ -2217,7 +2217,7 @@ remap_vla_decls (tree block, struct nesting_info *root)\n   id.cb.decl_map = pointer_map_create ();\n   id.root = root;\n \n-  for (; var; var = TREE_CHAIN (var))\n+  for (; var; var = DECL_CHAIN (var))\n     if (TREE_CODE (var) == VAR_DECL\n \t&& variably_modified_type_p (TREE_TYPE (var), NULL)\n \t&& DECL_HAS_VALUE_EXPR_P (var))\n@@ -2308,11 +2308,11 @@ finalize_nesting_tree_1 (struct nesting_info *root)\n \t expression get substituted in instantiate_virtual_regs().  */\n       for (adjust = &root->new_local_var_chain;\n \t   *adjust != root->frame_decl;\n-\t   adjust = &TREE_CHAIN (*adjust))\n-\tgcc_assert (TREE_CHAIN (*adjust));\n-      *adjust = TREE_CHAIN (*adjust);\n+\t   adjust = &DECL_CHAIN (*adjust))\n+\tgcc_assert (DECL_CHAIN (*adjust));\n+      *adjust = DECL_CHAIN (*adjust);\n \n-      TREE_CHAIN (root->frame_decl) = NULL_TREE;\n+      DECL_CHAIN (root->frame_decl) = NULL_TREE;\n       declare_vars (root->frame_decl,\n \t\t    gimple_seq_first_stmt (gimple_body (context)), true);\n     }\n@@ -2323,7 +2323,7 @@ finalize_nesting_tree_1 (struct nesting_info *root)\n   if (root->any_parm_remapped)\n     {\n       tree p;\n-      for (p = DECL_ARGUMENTS (context); p ; p = TREE_CHAIN (p))\n+      for (p = DECL_ARGUMENTS (context); p ; p = DECL_CHAIN (p))\n \t{\n \t  tree field, x, y;\n \n@@ -2428,7 +2428,7 @@ finalize_nesting_tree_1 (struct nesting_info *root)\n       remap_vla_decls (DECL_INITIAL (root->context), root);\n \n       for (debug_var = root->debug_var_chain; debug_var;\n-\t   debug_var = TREE_CHAIN (debug_var))\n+\t   debug_var = DECL_CHAIN (debug_var))\n \tif (variably_modified_type_p (TREE_TYPE (debug_var), NULL))\n \t  break;\n \n@@ -2443,7 +2443,7 @@ finalize_nesting_tree_1 (struct nesting_info *root)\n \t  id.cb.decl_map = pointer_map_create ();\n \t  id.root = root;\n \n-\t  for (; debug_var; debug_var = TREE_CHAIN (debug_var))\n+\t  for (; debug_var; debug_var = DECL_CHAIN (debug_var))\n \t    if (variably_modified_type_p (TREE_TYPE (debug_var), NULL))\n \t      {\n \t\ttree type = TREE_TYPE (debug_var);"}, {"sha": "0ea5538640f657450ec8f81ad6d664bde3ea24d2", "filename": "gcc/tree-object-size.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ftree-object-size.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ftree-object-size.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-object-size.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -290,8 +290,8 @@ addr_object_size (struct object_size_info *osi, const_tree ptr,\n \t\t\t&& TREE_CODE (TREE_TYPE (TREE_OPERAND (v, 0)))\n \t\t\t   == RECORD_TYPE)\n \t\t      {\n-\t\t\ttree fld_chain = TREE_CHAIN (TREE_OPERAND (v, 1));\n-\t\t\tfor (; fld_chain; fld_chain = TREE_CHAIN (fld_chain))\n+\t\t\ttree fld_chain = DECL_CHAIN (TREE_OPERAND (v, 1));\n+\t\t\tfor (; fld_chain; fld_chain = DECL_CHAIN (fld_chain))\n \t\t\t  if (TREE_CODE (fld_chain) == FIELD_DECL)\n \t\t\t    break;\n "}, {"sha": "4c03fbed332eecde681dabc5f58c6db9335e43de", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -1432,7 +1432,7 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n \t    {\n \t      pp_newline (buffer);\n \n-\t      for (op0 = BIND_EXPR_VARS (node); op0; op0 = TREE_CHAIN (op0))\n+\t      for (op0 = BIND_EXPR_VARS (node); op0; op0 = DECL_CHAIN (op0))\n \t\t{\n \t\t  print_declaration (buffer, op0, spc+2, flags);\n \t\t  pp_newline (buffer);\n@@ -2432,7 +2432,7 @@ print_struct_decl (pretty_printer *buffer, const_tree node, int spc, int flags)\n \t    print_declaration (buffer, tmp, spc+2, flags);\n \t    pp_newline (buffer);\n \t  }\n-\ttmp = TREE_CHAIN (tmp);\n+\ttmp = DECL_CHAIN (tmp);\n       }\n   }\n   INDENT (spc);"}, {"sha": "e4971d2385b7cfc39baee24a578ce553e62928a7", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -634,7 +634,7 @@ type_internals_preclude_sra_p (tree type)\n     case RECORD_TYPE:\n     case UNION_TYPE:\n     case QUAL_UNION_TYPE:\n-      for (fld = TYPE_FIELDS (type); fld; fld = TREE_CHAIN (fld))\n+      for (fld = TYPE_FIELDS (type); fld; fld = DECL_CHAIN (fld))\n \tif (TREE_CODE (fld) == FIELD_DECL)\n \t  {\n \t    tree ft = TREE_TYPE (fld);\n@@ -697,7 +697,7 @@ mark_parm_dereference (tree base, HOST_WIDE_INT dist, gimple stmt)\n \n   for (parm = DECL_ARGUMENTS (current_function_decl);\n        parm && parm != base;\n-       parm = TREE_CHAIN (parm))\n+       parm = DECL_CHAIN (parm))\n     parm_index++;\n \n   gcc_assert (parm_index < func_param_count);\n@@ -821,7 +821,7 @@ type_consists_of_records_p (tree type)\n   if (TREE_CODE (type) != RECORD_TYPE)\n     return false;\n \n-  for (fld = TYPE_FIELDS (type); fld; fld = TREE_CHAIN (fld))\n+  for (fld = TYPE_FIELDS (type); fld; fld = DECL_CHAIN (fld))\n     if (TREE_CODE (fld) == FIELD_DECL)\n       {\n \ttree ft = TREE_TYPE (fld);\n@@ -849,7 +849,7 @@ completely_scalarize_record (tree base, tree decl, HOST_WIDE_INT offset)\n {\n   tree fld, decl_type = TREE_TYPE (decl);\n \n-  for (fld = TYPE_FIELDS (decl_type); fld; fld = TREE_CHAIN (fld))\n+  for (fld = TYPE_FIELDS (decl_type); fld; fld = DECL_CHAIN (fld))\n     if (TREE_CODE (fld) == FIELD_DECL)\n       {\n \tHOST_WIDE_INT pos = offset + int_bit_position (fld);\n@@ -1344,7 +1344,7 @@ build_ref_for_offset_1 (tree *res, tree type, HOST_WIDE_INT offset,\n \tcase UNION_TYPE:\n \tcase QUAL_UNION_TYPE:\n \tcase RECORD_TYPE:\n-\t  for (fld = TYPE_FIELDS (type); fld; fld = TREE_CHAIN (fld))\n+\t  for (fld = TYPE_FIELDS (type); fld; fld = DECL_CHAIN (fld))\n \t    {\n \t      HOST_WIDE_INT pos, size;\n \t      tree expr, *expr_ptr;\n@@ -2862,7 +2862,7 @@ initialize_parameter_reductions (void)\n \n   for (parm = DECL_ARGUMENTS (current_function_decl);\n        parm;\n-       parm = TREE_CHAIN (parm))\n+       parm = DECL_CHAIN (parm))\n     {\n       VEC (access_p, heap) *access_vec;\n       struct access *access;\n@@ -3101,7 +3101,7 @@ find_param_candidates (void)\n \n   for (parm = DECL_ARGUMENTS (current_function_decl);\n        parm;\n-       parm = TREE_CHAIN (parm))\n+       parm = DECL_CHAIN (parm))\n     {\n       tree type = TREE_TYPE (parm);\n \n@@ -3593,7 +3593,7 @@ splice_all_param_accesses (VEC (access_p, heap) **representatives)\n \n   for (parm = DECL_ARGUMENTS (current_function_decl);\n        parm;\n-       parm = TREE_CHAIN (parm))\n+       parm = DECL_CHAIN (parm))\n     {\n       if (is_unused_scalar_param (parm))\n \t{\n@@ -3678,7 +3678,7 @@ turn_representatives_into_adjustments (VEC (access_p, heap) *representatives,\n   parms = ipa_get_vector_of_formal_parms (current_function_decl);\n   adjustments = VEC_alloc (ipa_parm_adjustment_t, heap, adjustments_count);\n   parm = DECL_ARGUMENTS (current_function_decl);\n-  for (i = 0; i < func_param_count; i++, parm = TREE_CHAIN (parm))\n+  for (i = 0; i < func_param_count; i++, parm = DECL_CHAIN (parm))\n     {\n       struct access *repr = VEC_index (access_p, representatives, i);\n "}, {"sha": "e8194aa45ff9a766015a832b2363664c2eb63f72", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -436,7 +436,7 @@ remove_unused_scope_block_p (tree scope)\n \n   for (t = &BLOCK_VARS (scope); *t; t = next)\n     {\n-      next = &TREE_CHAIN (*t);\n+      next = &DECL_CHAIN (*t);\n \n       /* Debug info of nested function refers to the block of the\n \t function.  We might stil call it even if all statements\n@@ -460,7 +460,7 @@ remove_unused_scope_block_p (tree scope)\n       /* Remove everything we don't generate debug info for.  */\n       else if (DECL_IGNORED_P (*t))\n \t{\n-\t  *t = TREE_CHAIN (*t);\n+\t  *t = DECL_CHAIN (*t);\n \t  next = t;\n \t}\n \n@@ -503,7 +503,7 @@ remove_unused_scope_block_p (tree scope)\n \t;\n       else\n \t{\n-\t  *t = TREE_CHAIN (*t);\n+\t  *t = DECL_CHAIN (*t);\n \t  next = t;\n \t}\n     }\n@@ -626,7 +626,7 @@ dump_scope_block (FILE *file, int indent, tree scope, int flags)\n \t}\n     }\n   fprintf (file, \" \\n\");\n-  for (var = BLOCK_VARS (scope); var; var = TREE_CHAIN (var))\n+  for (var = BLOCK_VARS (scope); var; var = DECL_CHAIN (var))\n     {\n       bool used = false;\n       var_ann_t ann;"}, {"sha": "6ec0575990d31e1561bffe0d1f13b327ee836eb5", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -2641,7 +2641,7 @@ array_at_struct_end_p (tree ref)\n \n \t  /* Unless the field is at the end of the struct, we are done.  */\n \t  field = TREE_OPERAND (ref, 1);\n-\t  if (TREE_CHAIN (field))\n+\t  if (DECL_CHAIN (field))\n \t    return false;\n \t}\n "}, {"sha": "fe0b4f405283c91d81e6a70f63c8abb563e641d1", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -474,7 +474,7 @@ execute_cse_reciprocals (void)\n     gcc_assert (!bb->aux);\n #endif\n \n-  for (arg = DECL_ARGUMENTS (cfun->decl); arg; arg = TREE_CHAIN (arg))\n+  for (arg = DECL_ARGUMENTS (cfun->decl); arg; arg = DECL_CHAIN (arg))\n     if (gimple_default_def (cfun, arg)\n \t&& FLOAT_TYPE_P (TREE_TYPE (arg))\n \t&& is_gimple_reg (arg))"}, {"sha": "6cd3cebfe86559f59bc25d3adc022f326aab8b2e", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -2192,7 +2192,7 @@ init_reassoc (void)\n   /* Give each argument a distinct rank.   */\n   for (param = DECL_ARGUMENTS (current_function_decl);\n        param;\n-       param = TREE_CHAIN (param))\n+       param = DECL_CHAIN (param))\n     {\n       if (gimple_default_def (cfun, param) != NULL)\n \t{"}, {"sha": "9ce37f705e5cf81bdcbd63aa11f66f0d111a705d", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -3474,7 +3474,7 @@ run_scc_vn (void)\n \n   for (param = DECL_ARGUMENTS (current_function_decl);\n        param;\n-       param = TREE_CHAIN (param))\n+       param = DECL_CHAIN (param))\n     {\n       if (gimple_default_def (cfun, param) != NULL)\n \t{"}, {"sha": "cf5815f67e5064e12ea8088599499768a967591b", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -4987,7 +4987,7 @@ push_fields_onto_fieldstack (tree type, VEC(fieldoff_s,heap) **fieldstack,\n   if (VEC_length (fieldoff_s, *fieldstack) > MAX_FIELDS_FOR_FIELD_SENSITIVE)\n     return false;\n \n-  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+  for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n     if (TREE_CODE (field) == FIELD_DECL)\n       {\n \tbool push = false;\n@@ -5065,7 +5065,7 @@ count_num_arguments (tree decl, bool *is_varargs)\n \n   /* Capture named arguments for K&R functions.  They do not\n      have a prototype and thus no TYPE_ARG_TYPES.  */\n-  for (t = DECL_ARGUMENTS (decl); t; t = TREE_CHAIN (t))\n+  for (t = DECL_ARGUMENTS (decl); t; t = DECL_CHAIN (t))\n     ++num;\n \n   /* Check if the function has variadic arguments.  */\n@@ -5223,7 +5223,7 @@ create_function_info_for (tree decl, const char *name)\n       if (arg)\n \t{\n \t  insert_vi_for_tree (arg, argvi);\n-\t  arg = TREE_CHAIN (arg);\n+\t  arg = DECL_CHAIN (arg);\n \t}\n     }\n \n@@ -5495,7 +5495,7 @@ intra_create_variable_infos (void)\n   /* For each incoming pointer argument arg, create the constraint ARG\n      = NONLOCAL or a dummy variable if it is a restrict qualified\n      passed-by-reference argument.  */\n-  for (t = DECL_ARGUMENTS (current_function_decl); t; t = TREE_CHAIN (t))\n+  for (t = DECL_ARGUMENTS (current_function_decl); t; t = DECL_CHAIN (t))\n     {\n       varinfo_t p;\n "}, {"sha": "65eaa40cedb95fc7c4ee85f6bbb212688176d298", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -164,7 +164,7 @@ suitable_for_tail_call_opt_p (void)\n      but not in all cases.  See PR15387 and PR19616.  Revisit for 4.1.  */\n   for (param = DECL_ARGUMENTS (current_function_decl);\n        param;\n-       param = TREE_CHAIN (param))\n+       param = DECL_CHAIN (param))\n     if (TREE_ADDRESSABLE (param))\n       return false;\n \n@@ -423,7 +423,7 @@ find_tail_calls (basic_block bb, struct tailcall **ret)\n \n       for (param = DECL_ARGUMENTS (func), idx = 0;\n \t   param && idx < gimple_call_num_args (call);\n-\t   param = TREE_CHAIN (param), idx ++)\n+\t   param = DECL_CHAIN (param), idx ++)\n \t{\n \t  arg = gimple_call_arg (call, idx);\n \t  if (param != arg)\n@@ -808,7 +808,7 @@ eliminate_tail_call (struct tailcall *t)\n   for (param = DECL_ARGUMENTS (current_function_decl),\n \t idx = 0, gsi = gsi_start_phis (first);\n        param;\n-       param = TREE_CHAIN (param), idx++)\n+       param = DECL_CHAIN (param), idx++)\n     {\n       if (!arg_needs_copy_p (param))\n \tcontinue;\n@@ -965,7 +965,7 @@ tree_optimize_tail_calls_1 (bool opt_tailcalls)\n \t  /* Copy the args if needed.  */\n \t  for (param = DECL_ARGUMENTS (current_function_decl);\n \t       param;\n-\t       param = TREE_CHAIN (param))\n+\t       param = DECL_CHAIN (param))\n \t    if (arg_needs_copy_p (param))\n \t      {\n \t\ttree name = gimple_default_def (cfun, param);"}, {"sha": "fbb549febd52b06ae781fb19a6974c13cfeec19f", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -337,7 +337,7 @@ nonnull_arg_p (const_tree arg)\n   /* Get the position number for ARG in the function signature.  */\n   for (arg_num = 1, t = DECL_ARGUMENTS (current_function_decl);\n        t;\n-       t = TREE_CHAIN (t), arg_num++)\n+       t = DECL_CHAIN (t), arg_num++)\n     {\n       if (t == arg)\n \tbreak;\n@@ -5165,9 +5165,9 @@ check_array_ref (location_t location, tree ref, bool ignore_off_by_one)\n \n       cref = TREE_OPERAND (ref, 0);\n       if (TREE_CODE (TREE_TYPE (TREE_OPERAND (cref, 0))) == RECORD_TYPE)\n-\tfor (next = TREE_CHAIN (TREE_OPERAND (cref, 1));\n+\tfor (next = DECL_CHAIN (TREE_OPERAND (cref, 1));\n \t     next && TREE_CODE (next) != FIELD_DECL;\n-\t     next = TREE_CHAIN (next))\n+\t     next = DECL_CHAIN (next))\n \t  ;\n \n       /* If this is the last field in a struct type or a field in a"}, {"sha": "7f37d45fba28760a76fbe4e13c99c32214dad778", "filename": "gcc/tree.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -1991,7 +1991,7 @@ chain_member (const_tree elem, const_tree chain)\n     {\n       if (elem == chain)\n \treturn 1;\n-      chain = TREE_CHAIN (chain);\n+      chain = DECL_CHAIN (chain);\n     }\n \n   return 0;\n@@ -2032,7 +2032,7 @@ fields_length (const_tree type)\n   tree t = TYPE_FIELDS (type);\n   int count = 0;\n \n-  for (; t; t = TREE_CHAIN (t))\n+  for (; t; t = DECL_CHAIN (t))\n     if (TREE_CODE (t) == FIELD_DECL)\n       ++count;\n \n@@ -2860,7 +2860,7 @@ type_contains_placeholder_1 (const_tree type)\n       {\n \ttree field;\n \n-\tfor (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+\tfor (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n \t  if (TREE_CODE (field) == FIELD_DECL\n \t      && (CONTAINS_PLACEHOLDER_P (DECL_FIELD_OFFSET (field))\n \t\t  || (TREE_CODE (type) == QUAL_UNION_TYPE\n@@ -8169,7 +8169,7 @@ variably_modified_type_p (tree type, tree fn)\n \t definition we normally use, since that would produce infinite\n \t recursion via pointers.  */\n       /* This is variably modified if some field's type is.  */\n-      for (t = TYPE_FIELDS (type); t; t = TREE_CHAIN (t))\n+      for (t = TYPE_FIELDS (type); t; t = DECL_CHAIN (t))\n \tif (TREE_CODE (t) == FIELD_DECL)\n \t  {\n \t    RETURN_TRUE_IF_VAR (DECL_FIELD_OFFSET (t));\n@@ -10257,7 +10257,7 @@ walk_tree_1 (tree *tp, walk_tree_fn func, void *data,\n     case BIND_EXPR:\n       {\n \ttree decl;\n-\tfor (decl = BIND_EXPR_VARS (*tp); decl; decl = TREE_CHAIN (decl))\n+\tfor (decl = BIND_EXPR_VARS (*tp); decl; decl = DECL_CHAIN (decl))\n \t  {\n \t    /* Walk the DECL_INITIAL and DECL_SIZE.  We don't want to walk\n \t       into declarations that are just mentioned, rather than\n@@ -10372,7 +10372,7 @@ walk_tree_1 (tree *tp, walk_tree_fn func, void *data,\n \t      tree field;\n \n \t      for (field = TYPE_FIELDS (*type_p); field;\n-\t\t   field = TREE_CHAIN (field))\n+\t\t   field = DECL_CHAIN (field))\n \t\t{\n \t\t  /* We'd like to look at the type of the field, but we can\n \t\t     easily get infinite recursion.  So assume it's pointed\n@@ -10888,7 +10888,7 @@ get_binfo_at_offset (tree binfo, HOST_WIDE_INT offset, tree expected_type)\n       if (TREE_CODE (type) != RECORD_TYPE)\n \treturn NULL_TREE;\n \n-      for (fld = TYPE_FIELDS (type); fld; fld = TREE_CHAIN (fld))\n+      for (fld = TYPE_FIELDS (type); fld; fld = DECL_CHAIN (fld))\n \t{\n \t  if (TREE_CODE (fld) != FIELD_DECL)\n \t    continue;"}, {"sha": "daf6c2bf4c4b86a553e7e20b7e081e4391c71696", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -2494,6 +2494,7 @@ enum symbol_visibility\n \n struct function;\n \n+#define DECL_CHAIN(NODE) (TREE_CHAIN (DECL_MINIMAL_CHECK (NODE)))\n \n /* This is the name of the object as written by the user.\n    It is an IDENTIFIER_NODE.  */"}, {"sha": "f62b41f6e20d06e6511d1434b7815a3a89f92a42", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -8002,7 +8002,7 @@ vt_add_function_parameters (void)\n   tree parm;\n \n   for (parm = DECL_ARGUMENTS (current_function_decl);\n-       parm; parm = TREE_CHAIN (parm))\n+       parm; parm = DECL_CHAIN (parm))\n     {\n       rtx decl_rtl = DECL_RTL_IF_SET (parm);\n       rtx incoming = DECL_INCOMING_RTL (parm);"}, {"sha": "00b4af93a9f50f4a8a84944dc929341e691a9560", "filename": "gcc/varasm.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910ad8dee56faaae9c25a6d026a39574937f6329/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=910ad8dee56faaae9c25a6d026a39574937f6329", "patch": "@@ -246,21 +246,21 @@ default_emutls_var_fields (tree type, tree *name ATTRIBUTE_UNUSED)\n \t\t      FIELD_DECL, get_identifier (\"__offset\"),\n \t\t      ptr_type_node);\n   DECL_CONTEXT (field) = type;\n-  TREE_CHAIN (field) = next_field;\n+  DECL_CHAIN (field) = next_field;\n   next_field = field;\n \n   word_type_node = lang_hooks.types.type_for_mode (word_mode, 1);\n   field = build_decl (UNKNOWN_LOCATION,\n \t\t      FIELD_DECL, get_identifier (\"__align\"),\n \t\t      word_type_node);\n   DECL_CONTEXT (field) = type;\n-  TREE_CHAIN (field) = next_field;\n+  DECL_CHAIN (field) = next_field;\n   next_field = field;\n \n   field = build_decl (UNKNOWN_LOCATION,\n \t\t      FIELD_DECL, get_identifier (\"__size\"), word_type_node);\n   DECL_CONTEXT (field) = type;\n-  TREE_CHAIN (field) = next_field;\n+  DECL_CHAIN (field) = next_field;\n \n   return field;\n }\n@@ -2114,18 +2114,18 @@ default_emutls_var_init (tree to, tree decl, tree proxy)\n   elt->value = fold_convert (TREE_TYPE (field), DECL_SIZE_UNIT (decl));\n \n   elt = VEC_quick_push (constructor_elt, v, NULL);\n-  field = TREE_CHAIN (field);\n+  field = DECL_CHAIN (field);\n   elt->index = field;\n   elt->value = build_int_cst (TREE_TYPE (field),\n \t\t\t      DECL_ALIGN_UNIT (decl));\n \n   elt = VEC_quick_push (constructor_elt, v, NULL);\n-  field = TREE_CHAIN (field);\n+  field = DECL_CHAIN (field);\n   elt->index = field;\n   elt->value = null_pointer_node;\n \n   elt = VEC_quick_push (constructor_elt, v, NULL);\n-  field = TREE_CHAIN (field);\n+  field = DECL_CHAIN (field);\n   elt->index = field;\n   elt->value = proxy;\n \n@@ -2323,7 +2323,7 @@ contains_pointers_p (tree type)\n       {\n \ttree fields;\n \t/* For a type that has fields, see if the fields have pointers.  */\n-\tfor (fields = TYPE_FIELDS (type); fields; fields = TREE_CHAIN (fields))\n+\tfor (fields = TYPE_FIELDS (type); fields; fields = DECL_CHAIN (fields))\n \t  if (TREE_CODE (fields) == FIELD_DECL\n \t      && contains_pointers_p (TREE_TYPE (fields)))\n \t    return 1;\n@@ -5038,7 +5038,7 @@ output_constructor_regular_field (oc_local_state *local)\n \t  fieldsize = array_size_for_constructor (local->val);\n \t  /* Given a non-empty initialization, this field had\n \t     better be last.  */\n-\t  gcc_assert (!fieldsize || !TREE_CHAIN (local->field));\n+\t  gcc_assert (!fieldsize || !DECL_CHAIN (local->field));\n \t}\n       else if (DECL_SIZE_UNIT (local->field))\n \t{\n@@ -5303,7 +5303,7 @@ output_constructor (tree exp, unsigned HOST_WIDE_INT size,\n \n   for (cnt = 0;\n        VEC_iterate (constructor_elt, CONSTRUCTOR_ELTS (exp), cnt, ce);\n-       cnt++, local.field = local.field ? TREE_CHAIN (local.field) : 0)\n+       cnt++, local.field = local.field ? DECL_CHAIN (local.field) : 0)\n     {\n       local.val = ce->value;\n       local.index = NULL_TREE;"}]}