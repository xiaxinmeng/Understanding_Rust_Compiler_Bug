{"sha": "6f3d3f9c7c6db3468b8d0269bbca946df2c48d5f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmYzZDNmOWM3YzZkYjM0NjhiOGQwMjY5YmJjYTk0NmRmMmM0OGQ1Zg==", "commit": {"author": {"name": "Chung-Ju Wu", "email": "jasonwucj@gmail.com", "date": "2014-09-03T08:57:02Z"}, "committer": {"name": "Chung-Ju Wu", "email": "jasonwucj@gcc.gnu.org", "date": "2014-09-03T08:57:02Z"}, "message": "[NDS32] Consider varargs situation when creating stack operation assembly code.\n\n  -- In fact, we only need to take care of 'push.s' situation,\n     because we have to push all the nameless arguments into stack.\n  -- We do not have to use 'pop.s' to restore them back to registers,\n     because we can just adjust stack pointer to set frame location.\n     This operation should be done in epilogue expanding.\n  -- Because 'pop25' instruction also performs return operation, we will\n     not use v3push/v3pop on isr and vararg functions.\n     Therefore, their instruction length should be 4 bytes.\n\n\t* config/nds32/nds32-md-auxiliary.c (nds32_output_stack_push):\n\tCheck rtx for varargs implementation.\n\t(nds32_output_stack_pop): Likewise.\n\t* config/nds32/nds32-protos.h: Have a rtx argument for\n\tnds32_output_stack_push and nds32_output_stack_pop.\n\t* config/nds32/nds32.md: Likewise.\n\nFrom-SVN: r214856", "tree": {"sha": "3d780b782ef18d1f3a43d38cf23c58bca8ec5cfb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d780b782ef18d1f3a43d38cf23c58bca8ec5cfb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f3d3f9c7c6db3468b8d0269bbca946df2c48d5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f3d3f9c7c6db3468b8d0269bbca946df2c48d5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f3d3f9c7c6db3468b8d0269bbca946df2c48d5f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f3d3f9c7c6db3468b8d0269bbca946df2c48d5f/comments", "author": {"login": "jasonwucj", "id": 5520732, "node_id": "MDQ6VXNlcjU1MjA3MzI=", "avatar_url": "https://avatars.githubusercontent.com/u/5520732?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jasonwucj", "html_url": "https://github.com/jasonwucj", "followers_url": "https://api.github.com/users/jasonwucj/followers", "following_url": "https://api.github.com/users/jasonwucj/following{/other_user}", "gists_url": "https://api.github.com/users/jasonwucj/gists{/gist_id}", "starred_url": "https://api.github.com/users/jasonwucj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jasonwucj/subscriptions", "organizations_url": "https://api.github.com/users/jasonwucj/orgs", "repos_url": "https://api.github.com/users/jasonwucj/repos", "events_url": "https://api.github.com/users/jasonwucj/events{/privacy}", "received_events_url": "https://api.github.com/users/jasonwucj/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "126b11c6921e3e0b8eb29b60e5bf5b4dd83797d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/126b11c6921e3e0b8eb29b60e5bf5b4dd83797d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/126b11c6921e3e0b8eb29b60e5bf5b4dd83797d4"}], "stats": {"total": 86, "additions": 66, "deletions": 20}, "files": [{"sha": "a8d27bf6ac1b591da139a12e34b978d2c3001638", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f3d3f9c7c6db3468b8d0269bbca946df2c48d5f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f3d3f9c7c6db3468b8d0269bbca946df2c48d5f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6f3d3f9c7c6db3468b8d0269bbca946df2c48d5f", "patch": "@@ -1,3 +1,12 @@\n+2014-09-03  Chung-Ju Wu  <jasonwucj@gmail.com>\n+\n+\t* config/nds32/nds32-md-auxiliary.c (nds32_output_stack_push):\n+\tCheck rtx for varargs implementation.\n+\t(nds32_output_stack_pop): Likewise.\n+\t* config/nds32/nds32-protos.h: Have a rtx argument for\n+\tnds32_output_stack_push and nds32_output_stack_pop.\n+\t* config/nds32/nds32.md: Likewise.\n+\n 2014-09-03  Chung-Ju Wu  <jasonwucj@gmail.com>\n \n \t* config/nds32/nds32-isr.c (nds32_isr_function_p): Define new function"}, {"sha": "85a3a301bcd15c4abd9d4d217674d2698013813f", "filename": "gcc/config/nds32/nds32-md-auxiliary.c", "status": "modified", "additions": 47, "deletions": 14, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f3d3f9c7c6db3468b8d0269bbca946df2c48d5f/gcc%2Fconfig%2Fnds32%2Fnds32-md-auxiliary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f3d3f9c7c6db3468b8d0269bbca946df2c48d5f/gcc%2Fconfig%2Fnds32%2Fnds32-md-auxiliary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-md-auxiliary.c?ref=6f3d3f9c7c6db3468b8d0269bbca946df2c48d5f", "patch": "@@ -563,17 +563,44 @@ nds32_output_32bit_load_s (rtx *operands, int byte)\n /* Function to output stack push operation.\n    We need to deal with normal stack push multiple or stack v3push.  */\n const char *\n-nds32_output_stack_push (void)\n+nds32_output_stack_push (rtx par_rtx)\n {\n   /* A string pattern for output_asm_insn().  */\n   char pattern[100];\n   /* The operands array which will be used in output_asm_insn().  */\n   rtx operands[3];\n+  /* Pick up varargs first regno and last regno for further use.  */\n+  int rb_va_args = cfun->machine->va_args_first_regno;\n+  int re_va_args = cfun->machine->va_args_last_regno;\n+  int last_argument_regno = NDS32_FIRST_GPR_REGNUM\n+\t\t\t    + NDS32_MAX_GPR_REGS_FOR_ARGS\n+\t\t\t    - 1;\n   /* Pick up callee-saved first regno and last regno for further use.  */\n-  int rb_regno = cfun->machine->callee_saved_regs_first_regno;\n-  int re_regno = cfun->machine->callee_saved_regs_last_regno;\n+  int rb_callee_saved = cfun->machine->callee_saved_regs_first_regno;\n+  int re_callee_saved = cfun->machine->callee_saved_regs_last_regno;\n \n-  if (TARGET_V3PUSH)\n+  /* First we need to check if we are pushing argument registers not used\n+     for the named arguments.  If so, we have to create 'smw.adm' (push.s)\n+     instruction.  */\n+  if (reg_mentioned_p (gen_rtx_REG (SImode, last_argument_regno), par_rtx))\n+    {\n+      /* Set operands[0] and operands[1].  */\n+      operands[0] = gen_rtx_REG (SImode, rb_va_args);\n+      operands[1] = gen_rtx_REG (SImode, re_va_args);\n+      /* Create assembly code pattern: \"Rb, Re, { }\".  */\n+      snprintf (pattern, sizeof (pattern), \"push.s\\t%s\", \"%0, %1, { }\");\n+      /* We use output_asm_insn() to output assembly code by ourself.  */\n+      output_asm_insn (pattern, operands);\n+      return \"\";\n+    }\n+\n+  /* If we step here, we are going to do v3push or multiple push operation.  */\n+\n+  /* The v3push/v3pop instruction should only be applied on\n+     none-isr and none-variadic function.  */\n+  if (TARGET_V3PUSH\n+      && !nds32_isr_function_p (current_function_decl)\n+      && (cfun->machine->va_args_size == 0))\n     {\n       /* For stack v3push:\n            operands[0]: Re\n@@ -583,7 +610,7 @@ nds32_output_stack_push (void)\n       int sp_adjust;\n \n       /* Set operands[0].  */\n-      operands[0] = gen_rtx_REG (SImode, re_regno);\n+      operands[0] = gen_rtx_REG (SImode, re_callee_saved);\n \n       /* Check if we can generate 'push25 Re,imm8u',\n          otherwise, generate 'push25 Re,0'.  */\n@@ -611,8 +638,8 @@ nds32_output_stack_push (void)\n       int push_en4_only_p = 0;\n \n       /* Set operands[0] and operands[1].  */\n-      operands[0] = gen_rtx_REG (SImode, rb_regno);\n-      operands[1] = gen_rtx_REG (SImode, re_regno);\n+      operands[0] = gen_rtx_REG (SImode, rb_callee_saved);\n+      operands[1] = gen_rtx_REG (SImode, re_callee_saved);\n \n       /* 'smw.adm $sp,[$sp],$sp,0' means push nothing.  */\n       if (!cfun->machine->fp_size\n@@ -650,17 +677,23 @@ nds32_output_stack_push (void)\n /* Function to output stack pop operation.\n    We need to deal with normal stack pop multiple or stack v3pop.  */\n const char *\n-nds32_output_stack_pop (void)\n+nds32_output_stack_pop (rtx par_rtx ATTRIBUTE_UNUSED)\n {\n   /* A string pattern for output_asm_insn().  */\n   char pattern[100];\n   /* The operands array which will be used in output_asm_insn().  */\n   rtx operands[3];\n   /* Pick up callee-saved first regno and last regno for further use.  */\n-  int rb_regno = cfun->machine->callee_saved_regs_first_regno;\n-  int re_regno = cfun->machine->callee_saved_regs_last_regno;\n+  int rb_callee_saved = cfun->machine->callee_saved_regs_first_regno;\n+  int re_callee_saved = cfun->machine->callee_saved_regs_last_regno;\n+\n+  /* If we step here, we are going to do v3pop or multiple pop operation.  */\n \n-  if (TARGET_V3PUSH)\n+  /* The v3push/v3pop instruction should only be applied on\n+     none-isr and none-variadic function.  */\n+  if (TARGET_V3PUSH\n+      && !nds32_isr_function_p (current_function_decl)\n+      && (cfun->machine->va_args_size == 0))\n     {\n       /* For stack v3pop:\n            operands[0]: Re\n@@ -670,7 +703,7 @@ nds32_output_stack_pop (void)\n       int sp_adjust;\n \n       /* Set operands[0].  */\n-      operands[0] = gen_rtx_REG (SImode, re_regno);\n+      operands[0] = gen_rtx_REG (SImode, re_callee_saved);\n \n       /* Check if we can generate 'pop25 Re,imm8u',\n          otherwise, generate 'pop25 Re,0'.\n@@ -704,8 +737,8 @@ nds32_output_stack_pop (void)\n       int pop_en4_only_p = 0;\n \n       /* Set operands[0] and operands[1].  */\n-      operands[0] = gen_rtx_REG (SImode, rb_regno);\n-      operands[1] = gen_rtx_REG (SImode, re_regno);\n+      operands[0] = gen_rtx_REG (SImode, rb_callee_saved);\n+      operands[1] = gen_rtx_REG (SImode, re_callee_saved);\n \n       /* 'lmw.bim $sp,[$sp],$sp,0' means pop nothing.  */\n       if (!cfun->machine->fp_size"}, {"sha": "8984ea759773f9b919f77e680bd79f5681782d66", "filename": "gcc/config/nds32/nds32-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f3d3f9c7c6db3468b8d0269bbca946df2c48d5f/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f3d3f9c7c6db3468b8d0269bbca946df2c48d5f/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h?ref=6f3d3f9c7c6db3468b8d0269bbca946df2c48d5f", "patch": "@@ -117,8 +117,8 @@ extern const char *nds32_output_32bit_load_s (rtx *, int);\n \n /* Auxiliary functions to output stack push/pop instruction.  */\n \n-extern const char *nds32_output_stack_push (void);\n-extern const char *nds32_output_stack_pop (void);\n+extern const char *nds32_output_stack_push (rtx);\n+extern const char *nds32_output_stack_pop (rtx);\n \n /* Auxiliary functions to decide output alignment or not.  */\n "}, {"sha": "ccf33d9861ed52ab6c0801575090e980f69fb2ce", "filename": "gcc/config/nds32/nds32.md", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f3d3f9c7c6db3468b8d0269bbca946df2c48d5f/gcc%2Fconfig%2Fnds32%2Fnds32.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f3d3f9c7c6db3468b8d0269bbca946df2c48d5f/gcc%2Fconfig%2Fnds32%2Fnds32.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.md?ref=6f3d3f9c7c6db3468b8d0269bbca946df2c48d5f", "patch": "@@ -2025,12 +2025,14 @@ create_template:\n      ])]\n   \"\"\n {\n-  return nds32_output_stack_push ();\n+  return nds32_output_stack_push (operands[0]);\n }\n   [(set_attr \"type\" \"misc\")\n    (set_attr \"enabled\" \"1\")\n    (set (attr \"length\")\n-\t(if_then_else (match_test \"TARGET_V3PUSH\")\n+\t(if_then_else (match_test \"TARGET_V3PUSH\n+\t\t\t\t   && !nds32_isr_function_p (cfun->decl)\n+\t\t\t\t   && (cfun->machine->va_args_size == 0)\")\n \t\t      (const_int 2)\n \t\t      (const_int 4)))])\n \n@@ -2045,12 +2047,14 @@ create_template:\n      ])]\n   \"\"\n {\n-  return nds32_output_stack_pop ();\n+  return nds32_output_stack_pop (operands[0]);\n }\n   [(set_attr \"type\" \"misc\")\n    (set_attr \"enabled\" \"1\")\n    (set (attr \"length\")\n-\t(if_then_else (match_test \"TARGET_V3PUSH\")\n+\t(if_then_else (match_test \"TARGET_V3PUSH\n+\t\t\t\t   && !nds32_isr_function_p (cfun->decl)\n+\t\t\t\t   && (cfun->machine->va_args_size == 0)\")\n \t\t      (const_int 2)\n \t\t      (const_int 4)))])\n "}]}