{"sha": "f42f5a1b1ec954dd53ea998ff4188c1de8001b0d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjQyZjVhMWIxZWM5NTRkZDUzZWE5OThmZjQxODhjMWRlODAwMWIwZA==", "commit": {"author": {"name": "Bob Wilson", "email": "bwilson@gcc.gnu.org", "date": "2003-05-14T18:37:26Z"}, "committer": {"name": "Bob Wilson", "email": "bwilson@gcc.gnu.org", "date": "2003-05-14T18:37:26Z"}, "message": "lib2funcs.S (TRAMPOLINE_SIZE): Change from 49 to 59.\n\n        * config/xtensa/lib2funcs.S (TRAMPOLINE_SIZE): Change from 49 to 59.\n        * config/xtensa/xtensa-config.h (XCHAL_HAVE_CONST16,\n        XCHAL_HAVE_L32R): New.\n        * config/xtensa/xtensa-protos.h (non_const_move_operand,\n        xtensa_load_constant, xtensa_function_prologue,\n        xtensa_function_epilogue): Delete prototypes.\n        (xtensa_expand_prologue): New.\n        * config/xtensa/xtensa.c (frame_size_const,\n        TARGET_ASM_FUNCTION_PROLOGUE, TARGET_MACHINE_DEPENDENT_REORG,\n        non_const_move_operand, xtensa_load_constant, xtensa_reorg,\n        xtensa_function_prologue): Delete.\n        (add_operand, xtensa_mem_offset): Formatting.\n        (move_operand): If the const16 option is available, allow any SFmode\n        and SImode constants.\n        (xtensa_emit_move_sequence): Inline the former contents of\n        xtensa_load_constant with modifications to handle the const16 option.\n        (override_options): Add xtensa_char_to_class['W'] and set it to\n        the general register class only if the const16 option is enabled.\n        Fix formatting.  Disallow PIC when using the const16 option.\n        (print_operand): Reorganize to switch on \"letter\" instead of the\n        RTL code.  Add output_operand_lossage calls for invalid cases.\n        Add support for 't' and 'b' letters.\n        (xtensa_expand_prologue): New function to replace\n        xtensa_function_prologue and xtensa_reorg.\n        (xtensa_function_epilogue): Declare this as static.  Delete code\n        to print the retw.n or retw instruction.\n        (xtensa_return_addr): Use A0_REG instead of 0.\n        (xtensa_rtx_costs): Add costs for using the const16 option.\n        * config/xtensa/xtensa.h (MASK_CONST16, TARGET_CONST16): New.\n        (TARGET_DEFAULT): Add CONST16 if L32R instructions not available.\n        (TARGET_SWITCHES): Add \"const16\" and \"no-const16\".\n        (REG_CLASS_FROM_LETTER): Add comment about new 'W' letter.\n        (EXTRA_CONSTRAINT): Change 'T' constraint to only apply when not\n        using the const16 option.\n        (TRAMPOLINE_TEMPLATE): Rewrite to avoid hardwired use of l32r insn.\n        (TRAMPOLINE_SIZE): Change from 49 to 59.\n        (INITIALIZE_TRAMPOLINE): Adjust offsets to match new trampoline.\n        (GO_IF_LEGITIMATE_ADDRESS): Do not allow constant pool addresses\n        when using the const16 option.\n        (PREDICATE_CODES): Delete non_const_move_operand.\n        * config/xtensa/xtensa.md (define_constants): Add A1_REG, A8_REG, and\n        UNSPECV_ENTRY.\n        (movdi, movdf): If the source is a constant, always expand to a\n        sequence of movsi insns.\n        (movdi_internal, movdf_internal): Remove alternative using l32r insns.\n        (movsi_internal, movsf_internal): Add alternative using const16 insns.\n        (movsf): Add const16 support.\n        (entry, prologue, epilogue): New.\n        (set_frame_ptr): Add missing mode for unspec_volatile operation.\n        Likewise for subsequent split pattern.\n        * doc/invoke.texi (Option Summary, Xtensa Options): Document new\n        \"-mconst16\" and \"-mno-const16\" options.\n\nFrom-SVN: r66809", "tree": {"sha": "53e02cd6e93361aefa86a3f9c17e1833caeb547d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53e02cd6e93361aefa86a3f9c17e1833caeb547d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f42f5a1b1ec954dd53ea998ff4188c1de8001b0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f42f5a1b1ec954dd53ea998ff4188c1de8001b0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f42f5a1b1ec954dd53ea998ff4188c1de8001b0d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f42f5a1b1ec954dd53ea998ff4188c1de8001b0d/comments", "author": null, "committer": null, "parents": [{"sha": "ae49d6e592571b46ae39832868e53958e94e26b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae49d6e592571b46ae39832868e53958e94e26b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae49d6e592571b46ae39832868e53958e94e26b4"}], "stats": {"total": 802, "additions": 431, "deletions": 371}, "files": [{"sha": "b424d7611e439aaebfb7553a29a56bc10506df8c", "filename": "gcc/config/xtensa/lib2funcs.S", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f42f5a1b1ec954dd53ea998ff4188c1de8001b0d/gcc%2Fconfig%2Fxtensa%2Flib2funcs.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f42f5a1b1ec954dd53ea998ff4188c1de8001b0d/gcc%2Fconfig%2Fxtensa%2Flib2funcs.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Flib2funcs.S?ref=f42f5a1b1ec954dd53ea998ff4188c1de8001b0d", "patch": "@@ -151,7 +151,7 @@ __xtensa_nonlocal_goto:\n    make sure that the modified instructions are loaded into the instruction\n    fetch buffer. */\n \t\n-#define TRAMPOLINE_SIZE 49\n+#define TRAMPOLINE_SIZE 59\n \n \t.text\n \t.align\t4"}, {"sha": "a9c679f125ef05cde1ff81b2ff2fa5d62c43301b", "filename": "gcc/config/xtensa/xtensa-config.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f42f5a1b1ec954dd53ea998ff4188c1de8001b0d/gcc%2Fconfig%2Fxtensa%2Fxtensa-config.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f42f5a1b1ec954dd53ea998ff4188c1de8001b0d/gcc%2Fconfig%2Fxtensa%2Fxtensa-config.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa-config.h?ref=f42f5a1b1ec954dd53ea998ff4188c1de8001b0d", "patch": "@@ -1,5 +1,5 @@\n /* Xtensa configuration settings.\n-   Copyright (C) 2001,2002 Free Software Foundation, Inc.\n+   Copyright (C) 2001,2002,2003 Free Software Foundation, Inc.\n    Contributed by Bob Wilson (bwilson@tensilica.com) at Tensilica.\n \n ** NOTE: This file was automatically generated by the Xtensa Processor\n@@ -27,6 +27,8 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n \n #define XCHAL_HAVE_BE\t\t\t1\n #define XCHAL_HAVE_DENSITY\t\t1\n+#define XCHAL_HAVE_CONST16\t\t0\n+#define XCHAL_HAVE_L32R\t\t\t1\n #define XCHAL_HAVE_MAC16\t\t0\n #define XCHAL_HAVE_MUL16\t\t0\n #define XCHAL_HAVE_MUL32\t\t0"}, {"sha": "b5ca61144d05eb3add1eff8cd02816516d5eb181", "filename": "gcc/config/xtensa/xtensa-protos.h", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f42f5a1b1ec954dd53ea998ff4188c1de8001b0d/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f42f5a1b1ec954dd53ea998ff4188c1de8001b0d/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h?ref=f42f5a1b1ec954dd53ea998ff4188c1de8001b0d", "patch": "@@ -57,11 +57,9 @@ extern int smalloffset_mem_p PARAMS ((rtx));\n extern int smalloffset_double_mem_p PARAMS ((rtx));\n extern int constantpool_address_p PARAMS ((rtx));\n extern int constantpool_mem_p PARAMS ((rtx));\n-extern int non_const_move_operand PARAMS ((rtx, enum machine_mode));\n extern int const_float_1_operand PARAMS ((rtx, enum machine_mode));\n extern int fpmem_offset_operand PARAMS ((rtx, enum machine_mode));\n extern void xtensa_extend_reg PARAMS ((rtx, rtx));\n-extern void xtensa_load_constant PARAMS ((rtx, rtx));\n extern int branch_operator PARAMS ((rtx, enum machine_mode));\n extern int ubranch_operator PARAMS ((rtx, enum machine_mode));\n extern int boolean_operator PARAMS ((rtx, enum machine_mode));\n@@ -110,8 +108,7 @@ extern int xtensa_dbx_register_number PARAMS ((int));\n extern void override_options PARAMS ((void));\n extern long compute_frame_size PARAMS ((int));\n extern int xtensa_frame_pointer_required PARAMS ((void));\n-extern void xtensa_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n-extern void xtensa_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n+extern void xtensa_expand_prologue PARAMS ((void));\n extern void order_regs_for_local_alloc PARAMS ((void));\n \n #endif /* !__XTENSA_PROTOS_H__ */"}, {"sha": "25bf6475b4608ba33ff1e780b47e66be231e138f", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 240, "deletions": 244, "changes": 484, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f42f5a1b1ec954dd53ea998ff4188c1de8001b0d/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f42f5a1b1ec954dd53ea998ff4188c1de8001b0d/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=f42f5a1b1ec954dd53ea998ff4188c1de8001b0d", "patch": "@@ -198,29 +198,18 @@ static rtx gen_conditional_move PARAMS ((rtx));\n static rtx fixup_subreg_mem PARAMS ((rtx x));\n static enum machine_mode xtensa_find_mode_for_size PARAMS ((unsigned));\n static struct machine_function * xtensa_init_machine_status PARAMS ((void));\n-static void xtensa_reorg PARAMS ((void));\n static void printx PARAMS ((FILE *, signed int));\n+static void xtensa_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n static unsigned int xtensa_multibss_section_type_flags\n   PARAMS ((tree, const char *, int));\n static void xtensa_select_rtx_section\n   PARAMS ((enum machine_mode, rtx, unsigned HOST_WIDE_INT));\n static bool xtensa_rtx_costs PARAMS ((rtx, int, int, int *));\n \n-static rtx frame_size_const;\n static int current_function_arg_words;\n static const int reg_nonleaf_alloc_order[FIRST_PSEUDO_REGISTER] =\n   REG_ALLOC_ORDER;\n \f\n-/* This macro generates the assembly code for function entry.\n-   FILE is a stdio stream to output the code to.\n-   SIZE is an int: how many units of temporary storage to allocate.\n-   Refer to the array 'regs_ever_live' to determine which registers\n-   to save; 'regs_ever_live[I]' is nonzero if register number I\n-   is ever used in the function.  This macro is responsible for\n-   knowing which registers should not be saved even if used.  */\n-\n-#undef TARGET_ASM_FUNCTION_PROLOGUE\n-#define TARGET_ASM_FUNCTION_PROLOGUE xtensa_function_prologue\n \n /* This macro generates the assembly code for function exit,\n    on machines that need it.  If FUNCTION_EPILOGUE is not defined\n@@ -244,9 +233,6 @@ static const int reg_nonleaf_alloc_order[FIRST_PSEUDO_REGISTER] =\n #undef TARGET_ADDRESS_COST\n #define TARGET_ADDRESS_COST hook_int_rtx_0\n \n-#undef TARGET_MACHINE_DEPENDENT_REORG\n-#define TARGET_MACHINE_DEPENDENT_REORG xtensa_reorg\n-\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n \n@@ -412,8 +398,7 @@ add_operand (op, mode)\n      enum machine_mode mode;\n {\n   if (GET_CODE (op) == CONST_INT)\n-    return (xtensa_simm8 (INTVAL (op)) ||\n-\t    xtensa_simm8x256 (INTVAL (op)));\n+    return (xtensa_simm8 (INTVAL (op)) || xtensa_simm8x256 (INTVAL (op)));\n \n   return register_operand (op, mode);\n }\n@@ -610,19 +595,23 @@ move_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n-  if (register_operand (op, mode))\n+  if (register_operand (op, mode)\n+      || memory_operand (op, mode))\n     return TRUE;\n \n+  if (mode == SFmode)\n+    return TARGET_CONST16 && CONSTANT_P (op);\n+\n   /* Accept CONSTANT_P_RTX, since it will be gone by CSE1 and\n      result in 0/1.  */\n   if (GET_CODE (op) == CONSTANT_P_RTX)\n     return TRUE;\n \n-  if (GET_CODE (op) == CONST_INT)\n-    return xtensa_simm12b (INTVAL (op));\n+  if (GET_CODE (op) == CONST_INT && xtensa_simm12b (INTVAL (op)))\n+    return TRUE;\n \n-  if (GET_CODE (op) == MEM)\n-    return memory_address_p (mode, XEXP (op, 0));\n+  if (mode == SImode)\n+    return TARGET_CONST16 && CONSTANT_P (op);\n \n   return FALSE;\n }\n@@ -702,21 +691,6 @@ constantpool_mem_p (op)\n }\n \n \n-int\n-non_const_move_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  if (register_operand (op, mode))\n-    return 1;\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-  if (GET_CODE (op) == MEM)\n-    return memory_address_p (mode, XEXP (op, 0));\n-  return FALSE;\n-}\n-\n-\n /* Accept the floating point constant 1 in the appropriate mode.  */\n \n int\n@@ -778,32 +752,6 @@ xtensa_extend_reg (dst, src)\n }\n \n \n-void\n-xtensa_load_constant (dst, src)\n-     rtx dst;\n-     rtx src;\n-{\n-  enum machine_mode mode = GET_MODE (dst);\n-  src = force_const_mem (SImode, src);\n-\n-  /* PC-relative loads are always SImode so we have to add a SUBREG if that\n-     is not the desired mode */\n-\n-  if (mode != SImode)\n-    {\n-      if (register_operand (dst, mode))\n-\tdst = simplify_gen_subreg (SImode, dst, mode, 0);\n-      else\n-\t{\n-\t  src = force_reg (SImode, src);\n-\t  src = gen_lowpart_SUBREG (mode, src);\n-\t}\n-    }\n-\n-  emit_move_insn (dst, src);\n-}\n-\n-\n int\n branch_operator (x, mode)\n      rtx x;\n@@ -899,8 +847,8 @@ xtensa_mem_offset (v, mode)\n \t moved in < \"move_ratio\" pieces.  The worst case is when the block is\n \t aligned but has a size of (3 mod 4) (does this happen?) so that the\n \t last piece requires a byte load/store.  */\n-      return (xtensa_uimm8 (v) &&\n-\t      xtensa_uimm8 (v + MOVE_MAX * LARGEST_MOVE_RATIO));\n+      return (xtensa_uimm8 (v)\n+\t      && xtensa_uimm8 (v + MOVE_MAX * LARGEST_MOVE_RATIO));\n \n     case QImode:\n       return xtensa_uimm8 (v);\n@@ -1260,7 +1208,6 @@ xtensa_expand_scc (operands)\n \n \n /* Emit insns to move operands[1] into operands[0].\n-\n    Return 1 if we have written out everything that needs to be done to\n    do the move.  Otherwise, return 0 and the caller will emit the move\n    normally.  */\n@@ -1275,8 +1222,27 @@ xtensa_emit_move_sequence (operands, mode)\n       && (GET_CODE (operands[1]) != CONST_INT\n \t  || !xtensa_simm12b (INTVAL (operands[1]))))\n     {\n-      xtensa_load_constant (operands[0], operands[1]);\n-      return 1;\n+      if (!TARGET_CONST16)\n+\toperands[1] = force_const_mem (SImode, operands[1]);\n+\n+      /* PC-relative loads are always SImode, and CONST16 is only\n+\t supported in the movsi pattern, so add a SUBREG for any other\n+\t (smaller) mode.  */\n+\n+      if (mode != SImode)\n+\t{\n+\t  if (register_operand (operands[0], mode))\n+\t    {\n+\t      operands[0] = simplify_gen_subreg (SImode, operands[0], mode, 0);\n+\t      emit_move_insn (operands[0], operands[1]);\n+\t      return 1;\n+\t    }\n+\t  else\n+\t    {\n+\t      operands[1] = force_reg (SImode, operands[1]);\n+\t      operands[1] = gen_lowpart_SUBREG (mode, operands[1]);\n+\t    }\n+\t}\n     }\n \n   if (!(reload_in_progress | reload_completed))\n@@ -1299,6 +1265,7 @@ xtensa_emit_move_sequence (operands, mode)\n   return 0;\n }\n \n+\n static rtx\n fixup_subreg_mem (x)\n      rtx x;\n@@ -1848,6 +1815,7 @@ override_options ()\n   xtensa_char_to_class['C'] = ((TARGET_MUL16) ? GR_REGS: NO_REGS);\n   xtensa_char_to_class['D'] = ((TARGET_DENSITY) ? GR_REGS: NO_REGS);\n   xtensa_char_to_class['d'] = ((TARGET_DENSITY) ? AR_REGS: NO_REGS);\n+  xtensa_char_to_class['W'] = ((TARGET_CONST16) ? GR_REGS: NO_REGS);\n \n   /* Set up array giving whether a given register can hold a given mode.  */\n   for (mode = VOIDmode;\n@@ -1862,8 +1830,8 @@ override_options ()\n \t  int temp;\n \n \t  if (ACC_REG_P (regno))\n-\t    temp = (TARGET_MAC16 &&\n-\t\t    (class == MODE_INT) && (size <= UNITS_PER_WORD));\n+\t    temp = (TARGET_MAC16\n+\t\t    && (class == MODE_INT) && (size <= UNITS_PER_WORD));\n \t  else if (GP_REG_P (regno))\n \t    temp = ((regno & 1) == 0 || (size <= UNITS_PER_WORD));\n \t  else if (FP_REG_P (regno))\n@@ -1879,9 +1847,19 @@ override_options ()\n \n   init_machine_status = xtensa_init_machine_status;\n \n-  /* Check PIC settings.  There's no need for -fPIC on Xtensa and\n-     some targets need to always use PIC.  */\n-  if (flag_pic > 1 || (XTENSA_ALWAYS_PIC))\n+  /* Check PIC settings.  PIC is only supported when using L32R\n+     instructions, and some targets need to always use PIC.  */\n+  if (flag_pic && TARGET_CONST16)\n+    error (\"-f%s is not supported with CONST16 instructions\",\n+\t   (flag_pic > 1 ? \"PIC\" : \"pic\"));\n+  else if (XTENSA_ALWAYS_PIC)\n+    {\n+      if (TARGET_CONST16)\n+\terror (\"PIC is required but not supported with CONST16 instructions\");\n+      flag_pic = 1;\n+    }\n+  /* There's no need for -fPIC (as opposed to -fpic) on Xtensa.  */\n+  if (flag_pic > 1)\n     flag_pic = 1;\n }\n \n@@ -1918,6 +1896,8 @@ override_options ()\n    'D'  REG, print second register of double-word register operand\n    'N'  MEM, print address of next word following a memory operand\n    'v'  MEM, if memory reference is volatile, output a MEMW before it\n+   't'  any constant, add \"@h\" suffix for top 16 bits\n+   'b'  any constant, add \"@l\" suffix for bottom 16 bits\n */\n \n static void\n@@ -1936,94 +1916,146 @@ printx (file, val)\n \n \n void\n-print_operand (file, op, letter)\n+print_operand (file, x, letter)\n      FILE *file;\t\t/* file to write to */\n-     rtx op;\t\t/* operand to print */\n+     rtx x;\t\t\t/* operand to print */\n      int letter;\t\t/* %<letter> or 0 */\n {\n-  enum rtx_code code;\n-\n-  if (! op)\n+  if (!x)\n     error (\"PRINT_OPERAND null pointer\");\n \n-  code = GET_CODE (op);\n-  switch (code)\n+  switch (letter)\n     {\n-    case REG:\n-    case SUBREG:\n-      {\n-\tint regnum = xt_true_regnum (op);\n-\tif (letter == 'D')\n-\t  regnum++;\n-\tfprintf (file, \"%s\", reg_names[regnum]);\n-\tbreak;\n-      }\n+    case 'D':\n+      if (GET_CODE (x) == REG || GET_CODE (x) == SUBREG)\n+\tfprintf (file, \"%s\", reg_names[xt_true_regnum (x) + 1]);\n+      else\n+\toutput_operand_lossage (\"invalid %%D value\");\n+      break;\n \n-    case MEM:\n-      /* For a volatile memory reference, emit a MEMW before the\n-\t load or store.  */\n- \tif (letter == 'v')\n-\t  {\n-\t    if (MEM_VOLATILE_P (op) && TARGET_SERIALIZE_VOLATILE)\n-\t      fprintf (file, \"memw\\n\\t\");\n-\t    break;\n-\t  }\n- \telse if (letter == 'N')\n-\t  {\n-\t    enum machine_mode mode;\n-\t    switch (GET_MODE (op))\n-\t      {\n-\t      case DFmode: mode = SFmode; break;\n-\t      case DImode: mode = SImode; break;\n-\t      default: abort ();\n-\t      }\n-\t    op = adjust_address (op, mode, 4);\n-\t  }\n+    case 'v':\n+      if (GET_CODE (x) == MEM)\n+\t{\n+\t  /* For a volatile memory reference, emit a MEMW before the\n+\t     load or store.  */\n+\t  if (MEM_VOLATILE_P (x) && TARGET_SERIALIZE_VOLATILE)\n+\t    fprintf (file, \"memw\\n\\t\");\n+\t}\n+      else\n+\toutput_operand_lossage (\"invalid %%v value\");\n+      break;\n \n-\toutput_address (XEXP (op, 0));\n-\tbreak;\n+    case 'N':\n+      if (GET_CODE (x) == MEM\n+\t  && (GET_MODE (x) == DFmode || GET_MODE (x) == DImode))\n+\t{\n+\t  x = adjust_address (x, GET_MODE (x) == DFmode ? SFmode : SImode, 4);\n+\t  output_address (XEXP (x, 0));\n+\t}\n+      else\n+\toutput_operand_lossage (\"invalid %%N value\");\n+      break;\n \n-    case CONST_INT:\n-      switch (letter)\n+    case 'K':\n+      if (GET_CODE (x) == CONST_INT)\n \t{\n-\tcase 'K':\n-\t  {\n-\t    int num_bits = 0;\n-\t    unsigned val = INTVAL (op);\n-\t    while (val & 1)\n-\t      {\n-\t\tnum_bits += 1;\n-\t\tval = val >> 1;\n-\t      }\n-\t    if ((val != 0) || (num_bits == 0) || (num_bits > 16))\n-\t      fatal_insn (\"invalid mask\", op);\n+\t  int num_bits = 0;\n+\t  unsigned val = INTVAL (x);\n+\t  while (val & 1)\n+\t    {\n+\t      num_bits += 1;\n+\t      val = val >> 1;\n+\t    }\n+\t  if ((val != 0) || (num_bits == 0) || (num_bits > 16))\n+\t    fatal_insn (\"invalid mask\", x);\n \n-\t    fprintf (file, \"%d\", num_bits);\n-\t    break;\n-\t  }\n+\t  fprintf (file, \"%d\", num_bits);\n+\t}\n+      else\n+\toutput_operand_lossage (\"invalid %%K value\");\n+      break;\n \n-\tcase 'L':\n-\t  fprintf (file, \"%ld\", (32 - INTVAL (op)) & 0x1f);\n-\t  break;\n+    case 'L':\n+      if (GET_CODE (x) == CONST_INT)\n+\tfprintf (file, \"%ld\", (32 - INTVAL (x)) & 0x1f);\n+      else\n+\toutput_operand_lossage (\"invalid %%L value\");\n+      break;\n \n-\tcase 'R':\n-\t  fprintf (file, \"%ld\", INTVAL (op) & 0x1f);\n-\t  break;\n+    case 'R':\n+      if (GET_CODE (x) == CONST_INT)\n+\tfprintf (file, \"%ld\", INTVAL (x) & 0x1f);\n+      else\n+\toutput_operand_lossage (\"invalid %%R value\");\n+      break;\n \n-\tcase 'x':\n-\t  printx (file, INTVAL (op));\n-\t  break;\n+    case 'x':\n+      if (GET_CODE (x) == CONST_INT)\n+\tprintx (file, INTVAL (x));\n+      else\n+\toutput_operand_lossage (\"invalid %%x value\");\n+      break;\n \n-\tcase 'd':\n-\tdefault:\n-\t  fprintf (file, \"%ld\", INTVAL (op));\n-\t  break;\n+    case 'd':\n+      if (GET_CODE (x) == CONST_INT)\n+\tfprintf (file, \"%ld\", INTVAL (x));\n+      else\n+\toutput_operand_lossage (\"invalid %%d value\");\n+      break;\n \n+    case 't':\n+    case 'b':\n+      if (GET_CODE (x) == CONST_INT)\n+\t{\n+\t  printx (file, INTVAL (x));\n+\t  fputs (letter == 't' ? \"@h\" : \"@l\", file);\n+\t}\n+      else if (GET_CODE (x) == CONST_DOUBLE)\n+\t{\n+\t  REAL_VALUE_TYPE r;\n+\t  REAL_VALUE_FROM_CONST_DOUBLE (r, x);\n+\t  if (GET_MODE (x) == SFmode)\n+\t    {\n+\t      long l;\n+\t      REAL_VALUE_TO_TARGET_SINGLE (r, l);\n+\t      fprintf (file, \"0x%08lx@%c\", l, letter == 't' ? 'h' : 'l');\n+\t    }\n+\t  else\n+\t    output_operand_lossage (\"invalid %%t/%%b value\");\n+\t}\n+      else if (GET_CODE (x) == CONST)\n+\t{\n+\t  /* X must be a symbolic constant on ELF.  Write an expression\n+\t     suitable for 'const16' that sets the high or low 16 bits.  */\n+\t  if (GET_CODE (XEXP (x, 0)) != PLUS\n+\t      || (GET_CODE (XEXP (XEXP (x, 0), 0)) != SYMBOL_REF\n+\t\t  && GET_CODE (XEXP (XEXP (x, 0), 0)) != LABEL_REF)\n+\t      || GET_CODE (XEXP (XEXP (x, 0), 1)) != CONST_INT)\n+\t    output_operand_lossage (\"invalid %%t/%%b value\");\n+\t  print_operand (file, XEXP (XEXP (x, 0), 0), 0);\n+\t  fputs (letter == 't' ? \"@h\" : \"@l\", file);\n+\t  /* There must be a non-alphanumeric character between 'h' or 'l'\n+\t     and the number.  The '-' is added by print_operand() already.  */\n+\t  if (INTVAL (XEXP (XEXP (x, 0), 1)) >= 0)\n+\t    fputs (\"+\", file);\n+\t  print_operand (file, XEXP (XEXP (x, 0), 1), 0);\n+\t}\n+      else\n+\t{ \n+\t  output_addr_const (file, x);\n+\t  fputs (letter == 't' ? \"@h\" : \"@l\", file);\n \t}\n       break;\n \n     default:\n-      output_addr_const (file, op);\n+      if (GET_CODE (x) == REG || GET_CODE (x) == SUBREG)\n+\tfprintf (file, \"%s\", reg_names[xt_true_regnum (x)]);\n+      else if (GET_CODE (x) == MEM)\n+\toutput_address (XEXP (x, 0));\n+      else if (GET_CODE (x) == CONST_INT)\n+\tfprintf (file, \"%ld\", INTVAL (x));\n+      else\n+\toutput_addr_const (file, x);\n     }\n }\n \n@@ -2191,129 +2223,85 @@ xtensa_frame_pointer_required ()\n }\n \n \n-/* If the stack frame size is too big to fit in the immediate field of\n-   the ENTRY instruction, we need to store the frame size in the\n-   constant pool.  However, the code in xtensa_function_prologue runs too\n-   late to be able to add anything to the constant pool.  Since the\n-   final frame size isn't known until reload is complete, this seems\n-   like the best place to do it.\n+void\n+xtensa_expand_prologue ()\n+{\n+  HOST_WIDE_INT total_size;\n+  rtx size_rtx;\n \n-   There may also be some fixup required if there is an incoming argument\n-   in a7 and the function requires a frame pointer. */\n+  total_size = compute_frame_size (get_frame_size ());\n+  size_rtx = GEN_INT (total_size);\n \n-static void\n-xtensa_reorg ()\n-{\n-  rtx first, insn, set_frame_ptr_insn = 0;\n-    \n-  unsigned long tsize = compute_frame_size (get_frame_size ());\n-  first = get_insns ();\n-  if (tsize < (1 << (12+3)))\n-    frame_size_const = 0;\n+  if (total_size < (1 << (12+3)))\n+    emit_insn (gen_entry (size_rtx, size_rtx));\n   else\n     {\n-      frame_size_const = force_const_mem (SImode, GEN_INT (tsize - 16));;\n-\n-      /* make sure the constant is used so it doesn't get eliminated\n-\t from the constant pool */\n-      emit_insn_before (gen_rtx_USE (SImode, frame_size_const), first);\n+      /* Use a8 as a temporary since a0-a7 may be live.  */\n+      rtx tmp_reg = gen_rtx_REG (Pmode, A8_REG);\n+      emit_insn (gen_entry (size_rtx, GEN_INT (MIN_FRAME_SIZE)));\n+      emit_move_insn (tmp_reg, GEN_INT (total_size - MIN_FRAME_SIZE));\n+      emit_insn (gen_subsi3 (tmp_reg, stack_pointer_rtx, tmp_reg));\n+      emit_move_insn (stack_pointer_rtx, tmp_reg);\n     }\n \n-  if (!frame_pointer_needed)\n-    return;\n-\n-  /* Search all instructions, looking for the insn that sets up the\n-     frame pointer.  This search will fail if the function does not\n-     have an incoming argument in $a7, but in that case, we can just\n-     set up the frame pointer at the very beginning of the\n-     function.  */\n-\n-  for (insn = first; insn; insn = NEXT_INSN (insn))\n+  if (frame_pointer_needed)\n     {\n-      rtx pat;\n+      rtx first, insn, set_frame_ptr_insn = 0;\n \n-      if (!INSN_P (insn))\n-\tcontinue;\n+      push_topmost_sequence ();\n+      first = get_insns ();\n+      pop_topmost_sequence ();\n \n-      pat = PATTERN (insn);\n-      if (GET_CODE (pat) == SET\n-\t  && GET_CODE (SET_SRC (pat)) == UNSPEC_VOLATILE\n-\t  && (XINT (SET_SRC (pat), 1) == UNSPECV_SET_FP))\n-\t{\n-\t  set_frame_ptr_insn = insn;\n-\t  break;\n-\t}\n-    }\n+      /* Search all instructions, looking for the insn that sets up the\n+\t frame pointer.  This search will fail if the function does not\n+\t have an incoming argument in $a7, but in that case, we can just\n+\t set up the frame pointer at the very beginning of the\n+\t function.  */\n \n-  if (set_frame_ptr_insn)\n-    {\n-      /* for all instructions prior to set_frame_ptr_insn, replace\n-\t hard_frame_pointer references with stack_pointer */\n-      for (insn = first; insn != set_frame_ptr_insn; insn = NEXT_INSN (insn))\n+      for (insn = first; insn; insn = NEXT_INSN (insn))\n \t{\n-\t  if (INSN_P (insn))\n-\t    PATTERN (insn) = replace_rtx (copy_rtx (PATTERN (insn)),\n-\t\t\t\t\t  hard_frame_pointer_rtx,\n-\t\t\t\t\t  stack_pointer_rtx);\n-\t}\n-    }\n-  else\n-    {\n-      /* emit the frame pointer move immediately after the NOTE that starts\n-\t the function */\n-      emit_insn_after (gen_movsi (hard_frame_pointer_rtx,\n-\t\t\t\t  stack_pointer_rtx), first);\n-    }\n-}\n-\n+\t  rtx pat;\n \n-/* Set up the stack and frame (if desired) for the function.  */\n+\t  if (!INSN_P (insn))\n+\t    continue;\n \n-void\n-xtensa_function_prologue (file, size)\n-     FILE *file;\n-     HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n-{\n-  unsigned long tsize = compute_frame_size (get_frame_size ());\n-\n-  if (frame_pointer_needed)\n-    fprintf (file, \"\\t.frame\\ta7, %ld\\n\", tsize);\n-  else\n-    fprintf (file, \"\\t.frame\\tsp, %ld\\n\", tsize);\n- \n-\n-  if (tsize < (1 << (12+3)))\n-    {\n-      fprintf (file, \"\\tentry\\tsp, %ld\\n\", tsize);\n-    }\n-  else\n-    {\n-      fprintf (file, \"\\tentry\\tsp, 16\\n\");\n+\t  pat = PATTERN (insn);\n+\t  if (GET_CODE (pat) == SET\n+\t      && GET_CODE (SET_SRC (pat)) == UNSPEC_VOLATILE\n+\t      && (XINT (SET_SRC (pat), 1) == UNSPECV_SET_FP))\n+\t    {\n+\t      set_frame_ptr_insn = insn;\n+\t      break;\n+\t    }\n+\t}\n \n-      /* use a8 as a temporary since a0-a7 may be live */\n-      fprintf (file, \"\\tl32r\\ta8, \");\n-      print_operand (file, frame_size_const, 0);\n-      fprintf (file, \"\\n\\tsub\\ta8, sp, a8\\n\");\n-      fprintf (file, \"\\tmovsp\\tsp, a8\\n\");\n+      if (set_frame_ptr_insn)\n+\t{\n+\t  /* For all instructions prior to set_frame_ptr_insn, replace\n+\t     hard_frame_pointer references with stack_pointer.  */\n+\t  for (insn = first;\n+\t       insn != set_frame_ptr_insn;\n+\t       insn = NEXT_INSN (insn))\n+\t    {\n+\t      if (INSN_P (insn))\n+\t\tPATTERN (insn) = replace_rtx (copy_rtx (PATTERN (insn)),\n+\t\t\t\t\t      hard_frame_pointer_rtx,\n+\t\t\t\t\t      stack_pointer_rtx);\n+\t    }\n+\t}\n+      else\n+\temit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx);\n     }\n }\n \n \n-/* Do any necessary cleanup after a function to restore\n-   stack, frame, and regs.  */\n+/* Clear variables at function end.  */\n \n void\n xtensa_function_epilogue (file, size)\n-     FILE *file;\n+     FILE *file ATTRIBUTE_UNUSED;\n      HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n {\n-  rtx insn = get_last_insn ();\n-  /* If the last insn was a BARRIER, we don't have to write anything.  */\n-  if (GET_CODE (insn) == NOTE)\n-    insn = prev_nonnote_insn (insn);\n-  if (insn == 0 || GET_CODE (insn) != BARRIER)\n-    fprintf (file, TARGET_DENSITY ? \"\\tretw.n\\n\" : \"\\tretw\\n\");\n-\n   xtensa_current_frame_size = 0;\n }\n \n@@ -2326,7 +2314,7 @@ xtensa_return_addr (count, frame)\n   rtx result, retaddr;\n \n   if (count == -1)\n-    retaddr = gen_rtx_REG (Pmode, 0);\n+    retaddr = gen_rtx_REG (Pmode, A0_REG);\n   else\n     {\n       rtx addr = plus_constant (frame, -4 * UNITS_PER_WORD);\n@@ -2882,18 +2870,26 @@ xtensa_rtx_costs (x, code, outer_code, total)\n \t}\n       if (xtensa_simm12b (INTVAL (x)))\n \t*total = 5;\n+      else if (TARGET_CONST16)\n+\t*total = COSTS_N_INSNS (2);\n       else\n \t*total = 6;\n       return true;\n \n     case CONST:\n     case LABEL_REF:\n     case SYMBOL_REF:\n-      *total = 5;\n+      if (TARGET_CONST16)\n+\t*total = COSTS_N_INSNS (2);\n+      else\n+\t*total = 5;\n       return true;\n \n     case CONST_DOUBLE:\n-      *total = 7;\n+      if (TARGET_CONST16)\n+\t*total = COSTS_N_INSNS (4);\n+      else\n+\t*total = 7;\n       return true;\n \n     case MEM:"}, {"sha": "0cce6634f637e628d591cd488bf95fc83457aaab", "filename": "gcc/config/xtensa/xtensa.h", "status": "modified", "additions": 28, "deletions": 15, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f42f5a1b1ec954dd53ea998ff4188c1de8001b0d/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f42f5a1b1ec954dd53ea998ff4188c1de8001b0d/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.h?ref=f42f5a1b1ec954dd53ea998ff4188c1de8001b0d", "patch": "@@ -61,6 +61,7 @@ extern unsigned xtensa_current_frame_size;\n #define MASK_HARD_FLOAT_RSQRT\t0x00004000\t/* floating-point recip sqrt */\n #define MASK_NO_FUSED_MADD\t0x00008000\t/* avoid f-p mul/add */\n #define MASK_SERIALIZE_VOLATILE 0x00010000\t/* serialize volatile refs */\n+#define MASK_CONST16\t\t0x00020000\t/* use CONST16 instruction */\n \n /* Macros used in the machine description to test the flags.  */\n \n@@ -81,12 +82,14 @@ extern unsigned xtensa_current_frame_size;\n #define TARGET_HARD_FLOAT_RSQRT\t(target_flags & MASK_HARD_FLOAT_RSQRT)\n #define TARGET_NO_FUSED_MADD\t(target_flags & MASK_NO_FUSED_MADD)\n #define TARGET_SERIALIZE_VOLATILE (target_flags & MASK_SERIALIZE_VOLATILE)\n+#define TARGET_CONST16\t\t(target_flags & MASK_CONST16)\n \n /* Default target_flags if no switches are specified  */\n \n #define TARGET_DEFAULT (\t\t\t\t\t\t\\\n   (XCHAL_HAVE_BE\t? MASK_BIG_ENDIAN : 0) |\t\t\t\\\n   (XCHAL_HAVE_DENSITY\t? MASK_DENSITY : 0) |\t\t\t\t\\\n+  (XCHAL_HAVE_L32R\t? 0 : MASK_CONST16) |\t\t\t\t\\\n   (XCHAL_HAVE_MAC16\t? MASK_MAC16 : 0) |\t\t\t\t\\\n   (XCHAL_HAVE_MUL16\t? MASK_MUL16 : 0) |\t\t\t\t\\\n   (XCHAL_HAVE_MUL32\t? MASK_MUL32 : 0) |\t\t\t\t\\\n@@ -114,6 +117,10 @@ extern unsigned xtensa_current_frame_size;\n     N_(\"Use the Xtensa code density option\")},\t\t\t\t\\\n   {\"no-density\",\t\t-MASK_DENSITY,\t\t\t\t\\\n     N_(\"Do not use the Xtensa code density option\")},\t\t\t\\\n+  {\"const16\",\t\t\tMASK_CONST16,\t\t\t\t\\\n+    N_(\"Use CONST16 instruction to load constants\")},\t\t\t\\\n+  {\"no-const16\",\t\t-MASK_CONST16,\t\t\t\t\\\n+    N_(\"Use PC-relative L32R instruction to load constants\")},\t\t\\\n   {\"mac16\",\t\t\tMASK_MAC16,\t\t\t\t\\\n     N_(\"Use the Xtensa MAC16 option\")},\t\t\t\t\t\\\n   {\"no-mac16\",\t\t\t-MASK_MAC16,\t\t\t\t\\\n@@ -629,6 +636,7 @@ extern const enum reg_class xtensa_regno_to_class[FIRST_PSEUDO_REGISTER];\n    'A'\tMAC16 accumulator (only if MAC16 option enabled)\n    'B'\tgeneral-purpose registers (only if sext instruction enabled)\n    'C'  general-purpose registers (only if mul16 option enabled)\n+   'W'  general-purpose registers (only if const16 option enabled)\n    'b'\tcoprocessor boolean registers\n    'f'\tfloating-point registers\n */\n@@ -699,7 +707,7 @@ extern enum reg_class xtensa_char_to_class[256];\n         && REGNO (OP) >= FIRST_PSEUDO_REGISTER)\t\t\t\t\\\n    : ((CODE) == 'R') ? smalloffset_mem_p (OP)\t\t\t\t\\\n    : ((CODE) == 'S') ? smalloffset_double_mem_p (OP)\t\t\t\\\n-   : ((CODE) == 'T') ? constantpool_mem_p (OP)\t\t\t\t\\\n+   : ((CODE) == 'T') ? !TARGET_CONST16 && constantpool_mem_p (OP)\t\\\n    : ((CODE) == 'U') ? !constantpool_mem_p (OP)\t\t\t\t\\\n    : FALSE)\n \n@@ -968,24 +976,27 @@ typedef struct xtensa_args {\n     fprintf (STREAM, \"\\t.begin no-generics\\n\");\t\t\t\t\\\n     fprintf (STREAM, \"\\tentry\\tsp, %d\\n\", MIN_FRAME_SIZE);\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-    /* GCC isn't prepared to deal with data at the beginning of the\t\\\n-       trampoline, and the Xtensa l32r instruction requires that the\t\\\n-       constant pool be located before the code.  We put the constant\t\\\n-       pool in the middle of the trampoline and jump around it. */ \t\\\n+    /* save the return address */\t\t\t\t\t\\\n+    fprintf (STREAM, \"\\tmov\\ta10, a0\\n\");\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-    fprintf (STREAM, \"\\tj\\t.Lskipconsts\\n\");\t\t\t\t\\\n+    /* Use a CALL0 instruction to skip past the constants and in the\t\\\n+       process get the PC into A0.  This allows PC-relative access to\t\\\n+       the constants without relying on L32R, which may not always be\t\\\n+       available.  */\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    fprintf (STREAM, \"\\tcall0\\t.Lskipconsts\\n\");\t\t\t\\\n     fprintf (STREAM, \"\\t.align\\t4\\n\");\t\t\t\t\t\\\n-    fprintf (STREAM, \".Lfnaddr:%s0\\n\", integer_asm_op (4, TRUE));\t\\\n     fprintf (STREAM, \".Lchainval:%s0\\n\", integer_asm_op (4, TRUE));\t\\\n+    fprintf (STREAM, \".Lfnaddr:%s0\\n\", integer_asm_op (4, TRUE));\t\\\n     fprintf (STREAM, \".Lskipconsts:\\n\");\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n     /* store the static chain */\t\t\t\t\t\\\n-    fprintf (STREAM, \"\\tl32r\\ta8, .Lchainval\\n\");\t\t\t\\\n-    fprintf (STREAM, \"\\ts32i\\ta8, sp, %d\\n\",\t\t\t\t\\\n-\t     MIN_FRAME_SIZE - (5 * UNITS_PER_WORD));\t\t\t\\\n+    fprintf (STREAM, \"\\taddi\\ta0, a0, 3\\n\");\t\t\t\t\\\n+    fprintf (STREAM, \"\\tl32i\\ta8, a0, 0\\n\");\t\t\t\t\\\n+    fprintf (STREAM, \"\\ts32i\\ta8, sp, %d\\n\", MIN_FRAME_SIZE - 20);\t\\\n \t\t\t\t\t\t\t\t\t\\\n     /* set the proper stack pointer value */\t\t\t\t\\\n-    fprintf (STREAM, \"\\tl32r\\ta8, .Lfnaddr\\n\");\t\t\t\t\\\n+    fprintf (STREAM, \"\\tl32i\\ta8, a0, 4\\n\");\t\t\t\t\\\n     fprintf (STREAM, \"\\tl32i\\ta9, a8, 0\\n\");\t\t\t\t\\\n     fprintf (STREAM, \"\\textui\\ta9, a9, %d, 12\\n\",\t\t\t\\\n \t     TARGET_BIG_ENDIAN ? 8 : 12);\t\t\t\t\\\n@@ -994,14 +1005,17 @@ typedef struct xtensa_args {\n     fprintf (STREAM, \"\\tsub\\ta9, sp, a9\\n\");\t\t\t\t\\\n     fprintf (STREAM, \"\\tmovsp\\tsp, a9\\n\");\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n+    /* restore the return address */\t\t\t\t\t\\\n+    fprintf (STREAM, \"\\tmov\\ta0, a10\\n\");\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n     /* jump to the instruction following the entry */\t\t\t\\\n     fprintf (STREAM, \"\\taddi\\ta8, a8, 3\\n\");\t\t\t\t\\\n     fprintf (STREAM, \"\\tjx\\ta8\\n\");\t\t\t\t\t\\\n     fprintf (STREAM, \"\\t.end no-generics\\n\");\t\t\t\t\\\n   } while (0)\n \n /* Size in bytes of the trampoline, as an integer.  */\n-#define TRAMPOLINE_SIZE 49\n+#define TRAMPOLINE_SIZE 59\n \n /* Alignment required for trampolines, in bits.  */\n #define TRAMPOLINE_ALIGNMENT (32)\n@@ -1010,8 +1024,8 @@ typedef struct xtensa_args {\n #define INITIALIZE_TRAMPOLINE(ADDR, FUNC, CHAIN)\t\t\t\\\n   do {\t\t\t\t\t\t\t\t\t\\\n     rtx addr = ADDR;\t\t\t\t\t\t\t\\\n-    emit_move_insn (gen_rtx_MEM (SImode, plus_constant (addr, 8)), FUNC); \\\n     emit_move_insn (gen_rtx_MEM (SImode, plus_constant (addr, 12)), CHAIN); \\\n+    emit_move_insn (gen_rtx_MEM (SImode, plus_constant (addr, 16)), FUNC); \\\n     emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \"__xtensa_sync_caches\"), \\\n \t\t       0, VOIDmode, 1, addr, Pmode);\t\t\t\\\n   } while (0)\n@@ -1128,7 +1142,7 @@ typedef struct xtensa_args {\n \t\t\t\t\t\t\t\t\t\\\n     /* allow constant pool addresses */\t\t\t\t\t\\\n     if ((MODE) != BLKmode && GET_MODE_SIZE (MODE) >= UNITS_PER_WORD\t\\\n-\t&& constantpool_address_p (xinsn))\t\t\t\t\\\n+\t&& !TARGET_CONST16 && constantpool_address_p (xinsn))\t\t\\\n       goto LABEL;\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n     while (GET_CODE (xinsn) == SUBREG)\t\t\t\t\t\\\n@@ -1330,7 +1344,6 @@ typedef struct xtensa_args {\n   {\"call_insn_operand\",\t\t{ CONST_INT, CONST, SYMBOL_REF, REG }},\t\\\n   {\"move_operand\",\t\t{ REG, SUBREG, MEM, CONST_INT, CONST_DOUBLE, \\\n \t\t\t\t  CONST, SYMBOL_REF, LABEL_REF }},\t\\\n-  {\"non_const_move_operand\",\t{ REG, SUBREG, MEM }},\t\t\t\\\n   {\"const_float_1_operand\",\t{ CONST_DOUBLE }},\t\t\t\\\n   {\"branch_operator\",\t\t{ EQ, NE, LT, GE }},\t\t\t\\\n   {\"ubranch_operator\",\t\t{ LTU, GEU }},\t\t\t\t\\"}, {"sha": "aa5896ed51182a4eb2451d2fc5a208202dfe2d78", "filename": "gcc/config/xtensa/xtensa.md", "status": "modified", "additions": 147, "deletions": 106, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f42f5a1b1ec954dd53ea998ff4188c1de8001b0d/gcc%2Fconfig%2Fxtensa%2Fxtensa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f42f5a1b1ec954dd53ea998ff4188c1de8001b0d/gcc%2Fconfig%2Fxtensa%2Fxtensa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.md?ref=f42f5a1b1ec954dd53ea998ff4188c1de8001b0d", "patch": "@@ -29,13 +29,16 @@\n \n (define_constants [\n   (A0_REG\t\t0)\n+  (A1_REG\t\t1)\n   (A7_REG\t\t7)\n+  (A8_REG\t\t8)\n \n   (UNSPEC_NSAU\t\t1)\n   (UNSPEC_NOP\t\t2)\n   (UNSPEC_PLT\t\t3)\n   (UNSPEC_RET_ADDR\t4)\n   (UNSPECV_SET_FP\t1)\n+  (UNSPECV_ENTRY\t2)\n ])\n \n ;;\n@@ -919,21 +922,19 @@\n   \"\"\n   \"\n {\n-  if (CONSTANT_P (operands[1]))\n+  if (CONSTANT_P (operands[1])\n+      && register_operand (operands[0], DImode))\n     {\n       rtx src0, src1, dst0, dst1;\n-      if ((dst0 = operand_subword (operands[0], 0, 1, DImode))\n-\t  && (src0 = operand_subword (operands[1], 0, 1, DImode))\n-\t  && (dst1 = operand_subword (operands[0], 1, 1, DImode))\n-\t  && (src1 = operand_subword (operands[1], 1, 1, DImode)))\n-\t{\n-\t  emit_insn (gen_movsi (dst0, src0));\n-\t  emit_insn (gen_movsi (dst1, src1));\n-\t  DONE;\n-\t}\n-      else\n-\t/* any other constant will be loaded from memory */\n-\toperands[1] = force_const_mem (DImode, operands[1]);\n+      dst0 = operand_subword (operands[0], 0, 1, DImode);\n+      src0 = operand_subword (operands[1], 0, 1, DImode);\n+      dst1 = operand_subword (operands[0], 1, 1, DImode);\n+      src1 = operand_subword (operands[1], 1, 1, DImode);\n+      if (!dst0 || !src0 || !dst1 || !src1)\n+        abort ();\n+      emit_insn (gen_movsi (dst0, src0));\n+      emit_insn (gen_movsi (dst1, src1));\n+      DONE;\n     }\n \n   if (!(reload_in_progress | reload_completed))\n@@ -948,60 +949,56 @@\n }\")\n \n (define_insn \"movdi_internal\"\n-  [(set (match_operand:DI 0 \"nonimmed_operand\" \"=D,D,S,a,a,a,U\")\n-\t(match_operand:DI 1 \"non_const_move_operand\" \"d,S,d,r,T,U,r\"))]\n+  [(set (match_operand:DI 0 \"nonimmed_operand\" \"=D,D,S,a,a,U\")\n+\t(match_operand:DI 1 \"nonimmed_operand\" \"d,S,d,r,U,r\"))]\n   \"register_operand (operands[0], DImode)\n    || register_operand (operands[1], DImode)\"\n   \"*\n {\n+  rtx dstreg;\n   switch (which_alternative)\n     {\n     case 0: return \\\"mov.n\\\\t%0, %1\\;mov.n\\\\t%D0, %D1\\\";\n     case 2: return \\\"%v0s32i.n\\\\t%1, %0\\;s32i.n\\\\t%D1, %N0\\\";\n     case 3: return \\\"mov\\\\t%0, %1\\;mov\\\\t%D0, %D1\\\";\n-    case 6: return \\\"%v0s32i\\\\t%1, %0\\;s32i\\\\t%D1, %N0\\\";\n+    case 5: return \\\"%v0s32i\\\\t%1, %0\\;s32i\\\\t%D1, %N0\\\";\n \n     case 1:\n     case 4:\n-    case 5:\n-      {\n-\t/* Check if the first half of the destination register is used\n-\t   in the source address.  If so, reverse the order of the loads\n-\t   so that the source address doesn't get clobbered until it is\n-\t   no longer needed. */\n-\n-\trtx dstreg = operands[0];\n-\tif (GET_CODE (dstreg) == SUBREG)\n-\t  dstreg = SUBREG_REG (dstreg);\n-\tif (GET_CODE (dstreg) != REG)\n-\t  abort();\n-\n-\tif (reg_mentioned_p (dstreg, operands[1]))\n-\t  {\n-\t    switch (which_alternative)\n-\t      {\n-\t      case 1: return \\\"%v1l32i.n\\\\t%D0, %N1\\;l32i.n\\\\t%0, %1\\\";\n-\t      case 4: return \\\"%v1l32r\\\\t%D0, %N1\\;l32r\\\\t%0, %1\\\";\n-\t      case 5: return \\\"%v1l32i\\\\t%D0, %N1\\;l32i\\\\t%0, %1\\\";\n-\t      }\n-\t  }\n-\telse\n-\t  {\n-\t    switch (which_alternative)\n-\t      {\n-\t      case 1: return \\\"%v1l32i.n\\\\t%0, %1\\;l32i.n\\\\t%D0, %N1\\\";\n-\t      case 4: return \\\"%v1l32r\\\\t%0, %1\\;l32r\\\\t%D0, %N1\\\";\n-\t      case 5: return \\\"%v1l32i\\\\t%0, %1\\;l32i\\\\t%D0, %N1\\\";\n-\t      }\n-\t  }\n-      }\n+      /* Check if the first half of the destination register is used\n+\t in the source address.  If so, reverse the order of the loads\n+\t so that the source address doesn't get clobbered until it is\n+\t no longer needed. */\n+\n+      dstreg = operands[0];\n+      if (GET_CODE (dstreg) == SUBREG)\n+\tdstreg = SUBREG_REG (dstreg);\n+      if (GET_CODE (dstreg) != REG)\n+\tabort();\n+\n+      if (reg_mentioned_p (dstreg, operands[1]))\n+\t{\n+\t  switch (which_alternative)\n+\t    {\n+\t    case 1: return \\\"%v1l32i.n\\\\t%D0, %N1\\;l32i.n\\\\t%0, %1\\\";\n+\t    case 4: return \\\"%v1l32i\\\\t%D0, %N1\\;l32i\\\\t%0, %1\\\";\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  switch (which_alternative)\n+\t    {\n+\t    case 1: return \\\"%v1l32i.n\\\\t%0, %1\\;l32i.n\\\\t%D0, %N1\\\";\n+\t    case 4: return \\\"%v1l32i\\\\t%0, %1\\;l32i\\\\t%D0, %N1\\\";\n+\t    }\n+\t}\n     }\n   abort ();\n   return \\\"\\\";\n }\"\n-  [(set_attr \"type\"\t\"move,load,store,move,load,load,store\")\n+  [(set_attr \"type\"\t\"move,load,store,move,load,store\")\n    (set_attr \"mode\"\t\"DI\")\n-   (set_attr \"length\"\t\"4,4,4,6,6,6,6\")])\n+   (set_attr \"length\"\t\"4,4,4,6,6,6\")])\n \n \n ;; 32-bit Integer moves\n@@ -1017,8 +1014,8 @@\n }\")\n \n (define_insn \"movsi_internal\"\n-  [(set (match_operand:SI 0 \"nonimmed_operand\" \"=D,D,D,D,R,R,a,q,a,a,a,U,*a,*A\")\n-\t(match_operand:SI 1 \"move_operand\" \"M,D,d,R,D,d,r,r,I,T,U,r,*A,*r\"))]\n+  [(set (match_operand:SI 0 \"nonimmed_operand\" \"=D,D,D,D,R,R,a,q,a,W,a,a,U,*a,*A\")\n+\t(match_operand:SI 1 \"move_operand\" \"M,D,d,R,D,d,r,r,I,i,T,U,r,*A,*r\"))]\n   \"xtensa_valid_move (SImode, operands)\"\n   \"@\n    movi.n\\\\t%0, %x1\n@@ -1030,14 +1027,15 @@\n    mov\\\\t%0, %1\n    movsp\\\\t%0, %1\n    movi\\\\t%0, %x1\n+   const16\\\\t%0, %t1\\;const16\\\\t%0, %b1\n    %v1l32r\\\\t%0, %1\n    %v1l32i\\\\t%0, %1\n    %v0s32i\\\\t%1, %0\n    rsr\\\\t%0, 16 # ACCLO\n    wsr\\\\t%1, 16 # ACCLO\"\n-  [(set_attr \"type\"\t\"move,move,move,load,store,store,move,move,move,load,load,store,rsr,wsr\")\n+  [(set_attr \"type\" \"move,move,move,load,store,store,move,move,move,move,load,load,store,rsr,wsr\")\n    (set_attr \"mode\"\t\"SI\")\n-   (set_attr \"length\"\t\"2,2,2,2,2,2,3,3,3,3,3,3,3,3\")])\n+   (set_attr \"length\"\t\"2,2,2,2,2,2,3,3,3,6,3,3,3,3,3\")])\n \n ;; 16-bit Integer moves\n \n@@ -1105,15 +1103,16 @@\n   \"\"\n   \"\n {\n-  if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+  if (!TARGET_CONST16 && CONSTANT_P (operands[1]))\n     operands[1] = force_const_mem (SFmode, operands[1]);\n \n   if (!(reload_in_progress | reload_completed))\n     {\n-      if (((!register_operand (operands[0], SFmode)\n+      if ((!register_operand (operands[0], SFmode)\n \t   && !register_operand (operands[1], SFmode))\n \t  || (FP_REG_P (xt_true_regnum (operands[0]))\n-\t      && constantpool_mem_p (operands[1]))))\n+\t      && (constantpool_mem_p (operands[1])\n+\t          || CONSTANT_P (operands[1]))))\n \toperands[1] = force_reg (SFmode, operands[1]);\n \n       if (xtensa_copy_incoming_a7 (operands, SFmode))\n@@ -1122,14 +1121,12 @@\n }\")\n \n (define_insn \"movsf_internal\"\n-  [(set (match_operand:SF 0 \"nonimmed_operand\"\n-\t\t\t    \"=f,f,U,D,D,R,a,f,a,a,a,U\")\n-\t(match_operand:SF 1 \"non_const_move_operand\"\n-\t\t\t    \"f,U,f,d,R,d,r,r,f,T,U,r\"))]\n+  [(set (match_operand:SF 0 \"nonimmed_operand\" \"=f,f,U,D,D,R,a,f,a,W,a,a,U\")\n+\t(match_operand:SF 1 \"move_operand\" \"f,U,f,d,R,d,r,r,f,F,T,U,r\"))]\n   \"((register_operand (operands[0], SFmode)\n      || register_operand (operands[1], SFmode))\n-    && (!FP_REG_P (xt_true_regnum (operands[0]))\n-        || !constantpool_mem_p (operands[1])))\"\n+    && !(FP_REG_P (xt_true_regnum (operands[0]))\n+         && (constantpool_mem_p (operands[1]) || CONSTANT_P (operands[1]))))\"\n   \"@\n    mov.s\\\\t%0, %1\n    %v1lsi\\\\t%0, %1\n@@ -1140,12 +1137,13 @@\n    mov\\\\t%0, %1\n    wfr\\\\t%0, %1\n    rfr\\\\t%0, %1\n+   const16\\\\t%0, %t1\\;const16\\\\t%0, %b1\n    %v1l32r\\\\t%0, %1\n    %v1l32i\\\\t%0, %1\n    %v0s32i\\\\t%1, %0\"\n-  [(set_attr \"type\"\t\"farith,fload,fstore,move,load,store,move,farith,farith,load,load,store\")\n+  [(set_attr \"type\"\t\"farith,fload,fstore,move,load,store,move,farith,farith,move,load,load,store\")\n    (set_attr \"mode\"\t\"SF\")\n-   (set_attr \"length\"\t\"3,3,3,2,2,2,3,3,3,3,3,3\")])\n+   (set_attr \"length\"\t\"3,3,3,2,2,2,3,3,3,6,3,3,3\")])\n \n (define_insn \"*lsiu\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n@@ -1189,8 +1187,19 @@\n   \"\"\n   \"\n {\n-  if (GET_CODE (operands[1]) == CONST_DOUBLE)\n-    operands[1] = force_const_mem (DFmode, operands[1]);\n+  if (CONSTANT_P (operands[1]))\n+    {\n+      rtx src0, src1, dst0, dst1;\n+      dst0 = operand_subword (operands[0], 0, 1, DFmode);\n+      src0 = operand_subword (operands[1], 0, 1, DFmode);\n+      dst1 = operand_subword (operands[0], 1, 1, DFmode);\n+      src1 = operand_subword (operands[1], 1, 1, DFmode);\n+      if (!dst0 || !src0 || !dst1 || !src1)\n+        abort ();\n+      emit_insn (gen_movsi (dst0, src0));\n+      emit_insn (gen_movsi (dst1, src1));\n+      DONE;\n+    }\n \n   if (!(reload_in_progress | reload_completed))\n     {\n@@ -1204,60 +1213,56 @@\n }\")\n \n (define_insn \"movdf_internal\"\n-  [(set (match_operand:DF 0 \"nonimmed_operand\" \"=D,D,S,a,a,a,U\")\n-\t(match_operand:DF 1 \"non_const_move_operand\" \"d,S,d,r,T,U,r\"))]\n+  [(set (match_operand:DF 0 \"nonimmed_operand\" \"=D,D,S,a,a,U\")\n+\t(match_operand:DF 1 \"nonimmed_operand\" \"d,S,d,r,U,r\"))]\n   \"register_operand (operands[0], DFmode)\n    || register_operand (operands[1], DFmode)\"\n   \"*\n {\n+  rtx dstreg;\n   switch (which_alternative)\n     {\n     case 0: return \\\"mov.n\\\\t%0, %1\\;mov.n\\\\t%D0, %D1\\\";\n     case 2: return \\\"%v0s32i.n\\\\t%1, %0\\;s32i.n\\\\t%D1, %N0\\\";\n     case 3: return \\\"mov\\\\t%0, %1\\;mov\\\\t%D0, %D1\\\";\n-    case 6: return \\\"%v0s32i\\\\t%1, %0\\;s32i\\\\t%D1, %N0\\\";\n+    case 5: return \\\"%v0s32i\\\\t%1, %0\\;s32i\\\\t%D1, %N0\\\";\n \n     case 1:\n     case 4:\n-    case 5:\n-      {\n-\t/* Check if the first half of the destination register is used\n-\t   in the source address.  If so, reverse the order of the loads\n-\t   so that the source address doesn't get clobbered until it is\n-\t   no longer needed. */\n-\n-\trtx dstreg = operands[0];\n-\tif (GET_CODE (dstreg) == SUBREG)\n-\t  dstreg = SUBREG_REG (dstreg);\n-\tif (GET_CODE (dstreg) != REG)\n-\t  abort ();\n-\n-\tif (reg_mentioned_p (dstreg, operands[1]))\n-\t  {\n-\t    switch (which_alternative)\n-\t      {\n-\t      case 1: return \\\"%v1l32i.n\\\\t%D0, %N1\\;l32i.n\\\\t%0, %1\\\";\n-\t      case 4: return \\\"%v1l32r\\\\t%D0, %N1\\;l32r\\\\t%0, %1\\\";\n-\t      case 5: return \\\"%v1l32i\\\\t%D0, %N1\\;l32i\\\\t%0, %1\\\";\n-\t      }\n-\t  }\n-\telse\n-\t  {\n-\t    switch (which_alternative)\n-\t      {\n-\t      case 1: return \\\"%v1l32i.n\\\\t%0, %1\\;l32i.n\\\\t%D0, %N1\\\";\n-\t      case 4: return \\\"%v1l32r\\\\t%0, %1\\;l32r\\\\t%D0, %N1\\\";\n-\t      case 5: return \\\"%v1l32i\\\\t%0, %1\\;l32i\\\\t%D0, %N1\\\";\n-\t      }\n-\t  }\n-      }\n+      /* Check if the first half of the destination register is used\n+\t in the source address.  If so, reverse the order of the loads\n+\t so that the source address doesn't get clobbered until it is\n+\t no longer needed.  */\n+\n+      dstreg = operands[0];\n+      if (GET_CODE (dstreg) == SUBREG)\n+\tdstreg = SUBREG_REG (dstreg);\n+      if (GET_CODE (dstreg) != REG)\n+\tabort ();\n+\n+      if (reg_mentioned_p (dstreg, operands[1]))\n+\t{\n+\t  switch (which_alternative)\n+\t    {\n+\t    case 1: return \\\"%v1l32i.n\\\\t%D0, %N1\\;l32i.n\\\\t%0, %1\\\";\n+\t    case 4: return \\\"%v1l32i\\\\t%D0, %N1\\;l32i\\\\t%0, %1\\\";\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  switch (which_alternative)\n+\t    {\n+\t    case 1: return \\\"%v1l32i.n\\\\t%0, %1\\;l32i.n\\\\t%D0, %N1\\\";\n+\t    case 4: return \\\"%v1l32i\\\\t%0, %1\\;l32i\\\\t%D0, %N1\\\";\n+\t    }\n+\t}\n     }\n   abort ();\n   return \\\"\\\";\n }\"\n-  [(set_attr \"type\"\t\"move,load,store,move,load,load,store\")\n+  [(set_attr \"type\"\t\"move,load,store,move,load,store\")\n    (set_attr \"mode\"\t\"DF\")\n-   (set_attr \"length\"\t\"4,4,4,6,6,6,6\")])\n+   (set_attr \"length\"\t\"4,4,4,6,6,6\")])\n \n ;; Block moves\n \n@@ -2340,6 +2345,24 @@\n    (set_attr \"mode\"\t\"none\")\n    (set_attr \"length\"\t\"3\")])\n \n+(define_insn \"entry\"\n+  [(set (reg:SI A1_REG)\n+\t(unspec_volatile:SI [(match_operand:SI 0 \"const_int_operand\" \"i\")\n+\t\t\t     (match_operand:SI 1 \"const_int_operand\" \"i\")]\n+\t\t\t    UNSPECV_ENTRY))]\n+  \"\"\n+  \"*\n+{\n+  if (frame_pointer_needed)\n+    output_asm_insn (\\\".frame\\\\ta7, %0\\\", operands);\n+  else\n+    output_asm_insn (\\\".frame\\\\tsp, %0\\\", operands);\n+  return \\\"entry\\\\tsp, %1\\\";\n+}\"\n+  [(set_attr \"type\"\t\"move\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"3\")])\n+\n (define_insn \"return\"\n   [(return)\n    (use (reg:SI A0_REG))]\n@@ -2361,6 +2384,24 @@\n ;;  ....................\n ;;\n \n+(define_expand \"prologue\"\n+  [(const_int 0)]\n+  \"\"\n+  \"\n+{\n+  xtensa_expand_prologue ();\n+  DONE;\n+}\")\n+\n+(define_expand \"epilogue\"\n+  [(return)]\n+  \"\"\n+  \"\n+{\n+  emit_jump_insn (gen_return ());\n+  DONE;\n+}\")\n+\n (define_insn \"nop\"\n   [(const_int 0)]\n   \"\"\n@@ -2400,7 +2441,7 @@\n ;; to set up the frame pointer.\n \n (define_insn \"set_frame_ptr\"\n-  [(set (reg:SI A7_REG) (unspec_volatile [(const_int 0)] UNSPECV_SET_FP))]\n+  [(set (reg:SI A7_REG) (unspec_volatile:SI [(const_int 0)] UNSPECV_SET_FP))]\n   \"\"\n   \"*\n {\n@@ -2414,7 +2455,7 @@\n \n ;; Post-reload splitter to remove fp assignment when it's not needed.\n (define_split\n-  [(set (reg:SI A7_REG) (unspec_volatile [(const_int 0)] UNSPECV_SET_FP))]\n+  [(set (reg:SI A7_REG) (unspec_volatile:SI [(const_int 0)] UNSPECV_SET_FP))]\n   \"reload_completed && !frame_pointer_needed\"\n   [(unspec [(const_int 0)] UNSPEC_NOP)]\n   \"\")"}, {"sha": "47eb09ba39e50165478f783fe953e1556b779a0f", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f42f5a1b1ec954dd53ea998ff4188c1de8001b0d/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f42f5a1b1ec954dd53ea998ff4188c1de8001b0d/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=f42f5a1b1ec954dd53ea998ff4188c1de8001b0d", "patch": "@@ -632,6 +632,7 @@ in the following sections.\n @emph{Xtensa Options}\n @gccoptlist{-mbig-endian  -mlittle-endian @gol\n -mdensity  -mno-density @gol\n+-mconst16 -mno-const16 @gol\n -mmac16  -mno-mac16 @gol\n -mmul16  -mno-mul16 @gol\n -mmul32  -mno-mul32 @gol\n@@ -10649,6 +10650,16 @@ processor.\n @opindex mno-density\n Enable or disable use of the optional Xtensa code density instructions.\n \n+@item -mconst16\n+@itemx -mno-const16\n+@opindex mconst16\n+@opindex mno-const16\n+Enable or disable use of CONST16 instructions for loading constant values.\n+The CONST16 instruction is currently not a standard option from Tensilica.\n+When enabled, CONST16 instructions are always used in place of the standard\n+L32R instructions.  The use of CONST16 is enabled by default only if the\n+L32R instruction is not available.\n+\n @item -mmac16\n @itemx -mno-mac16\n @opindex mmac16"}]}