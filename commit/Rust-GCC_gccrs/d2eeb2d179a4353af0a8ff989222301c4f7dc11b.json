{"sha": "d2eeb2d179a4353af0a8ff989222301c4f7dc11b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDJlZWIyZDE3OWE0MzUzYWYwYThmZjk4OTIyMjMwMWM0ZjdkYzExYg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2012-11-18T17:34:06Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2012-11-18T17:34:06Z"}, "message": "gcc/\n\t* doc/md.texi (extv@var{m}, extvmisalign@var{m}, extzv@var{m})\n\t(extzvmisalign@var{m}, insv@var{m}, insvmisalign@var{m}): Document.\n\t(insv, extv, extzv): Deprecate.\n\t* optabs.def (insv_optab, extv_optab, extzv_optab)\n\t(insvmisalign_optab, extvmisalign_optab, extzvmisalign_optab):\n\tNew optabs.\n\t* optabs.c (get_optab_extraction_insn): New function.\n\t(get_extraction_insn): Use it.\n\t* config/mips/mips.md (extv): Split into...\n\t(extvmisalign<mode>, extv<mode>): ...these new patterns.  Rename\n\texisting extv<mode> pattern to...\n\t(*extv<mode>): ...this.\n\t(extzv): Split into...\n\t(extzvmisalign<mode>, extzv<mode>): ...these new patterns.  Rename\n\texisting extzv<mode> pattern to...\n\t(*extzv<mode>): ...this.\n\t(insv): Split into...\n\t(insvmisalign<mode>, insv<mode>): ...these new patterns.  Rename\n\texisting insv<mode> pattern to...\n\t(*insv<mode>): ...this.  Use const_int_operand rather than\n\timmediate_operand.\n\t* config/mips/mips.c (mips_block_move_straight): Use set_mem_size\n\tto set the size of BLKmode accesses.\n\t(mips_get_unaligned_mem): Require OP0 to be a BLKmode memory,\n\tturning it from an \"rtx *\" to an rtx.\n\t(mips_expand_ext_as_unaligned_load): Simplify for new optab\n\tinterface.  Update call to mips_get_unaligned_mem.\n\t(mips_expand_ins_as_unaligned_store): Update call to\n\tmips_get_unaligned_mem.\n\nFrom-SVN: r193606", "tree": {"sha": "2d71577e02e248f2a39d8d852e69ab9ea07433d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2d71577e02e248f2a39d8d852e69ab9ea07433d6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d2eeb2d179a4353af0a8ff989222301c4f7dc11b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2eeb2d179a4353af0a8ff989222301c4f7dc11b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2eeb2d179a4353af0a8ff989222301c4f7dc11b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2eeb2d179a4353af0a8ff989222301c4f7dc11b/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fcdd52b73c0b23bffd5ce5ba591f994547333429", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcdd52b73c0b23bffd5ce5ba591f994547333429", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fcdd52b73c0b23bffd5ce5ba591f994547333429"}], "stats": {"total": 304, "additions": 207, "deletions": 97}, "files": [{"sha": "d155a39f736783ed1e053e67a2661154141f3403", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2eeb2d179a4353af0a8ff989222301c4f7dc11b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2eeb2d179a4353af0a8ff989222301c4f7dc11b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d2eeb2d179a4353af0a8ff989222301c4f7dc11b", "patch": "@@ -1,3 +1,35 @@\n+2012-11-18  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* doc/md.texi (extv@var{m}, extvmisalign@var{m}, extzv@var{m})\n+\t(extzvmisalign@var{m}, insv@var{m}, insvmisalign@var{m}): Document.\n+\t(insv, extv, extzv): Deprecate.\n+\t* optabs.def (insv_optab, extv_optab, extzv_optab)\n+\t(insvmisalign_optab, extvmisalign_optab, extzvmisalign_optab):\n+\tNew optabs.\n+\t* optabs.c (get_optab_extraction_insn): New function.\n+\t(get_extraction_insn): Use it.\n+\t* config/mips/mips.md (extv): Split into...\n+\t(extvmisalign<mode>, extv<mode>): ...these new patterns.  Rename\n+\texisting extv<mode> pattern to...\n+\t(*extv<mode>): ...this.\n+\t(extzv): Split into...\n+\t(extzvmisalign<mode>, extzv<mode>): ...these new patterns.  Rename\n+\texisting extzv<mode> pattern to...\n+\t(*extzv<mode>): ...this.\n+\t(insv): Split into...\n+\t(insvmisalign<mode>, insv<mode>): ...these new patterns.  Rename\n+\texisting insv<mode> pattern to...\n+\t(*insv<mode>): ...this.  Use const_int_operand rather than\n+\timmediate_operand.\n+\t* config/mips/mips.c (mips_block_move_straight): Use set_mem_size\n+\tto set the size of BLKmode accesses.\n+\t(mips_get_unaligned_mem): Require OP0 to be a BLKmode memory,\n+\tturning it from an \"rtx *\" to an rtx.\n+\t(mips_expand_ext_as_unaligned_load): Simplify for new optab\n+\tinterface.  Update call to mips_get_unaligned_mem.\n+\t(mips_expand_ins_as_unaligned_store): Update call to\n+\tmips_get_unaligned_mem.\n+\n 2012-11-18  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* Makefile.in (recog.o): Add insn-codes.h."}, {"sha": "b6a22907b23e5d607bf71e8e82f80fc69447996c", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 11, "deletions": 37, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2eeb2d179a4353af0a8ff989222301c4f7dc11b/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2eeb2d179a4353af0a8ff989222301c4f7dc11b/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=d2eeb2d179a4353af0a8ff989222301c4f7dc11b", "patch": "@@ -7096,6 +7096,7 @@ mips_block_move_straight (rtx dest, rtx src, HOST_WIDE_INT length)\n       else\n \t{\n \t  rtx part = adjust_address (src, BLKmode, offset);\n+\t  set_mem_size (part, delta);\n \t  if (!mips_expand_ext_as_unaligned_load (regs[i], part, bits, 0, 0))\n \t    gcc_unreachable ();\n \t}\n@@ -7108,6 +7109,7 @@ mips_block_move_straight (rtx dest, rtx src, HOST_WIDE_INT length)\n     else\n       {\n \trtx part = adjust_address (dest, BLKmode, offset);\n+\tset_mem_size (part, delta);\n \tif (!mips_expand_ins_as_unaligned_store (part, regs[i], bits, 0))\n \t  gcc_unreachable ();\n       }\n@@ -7359,10 +7361,8 @@ mips_expand_atomic_qihi (union mips_gen_fn_ptrs generator,\n }\n \n /* Return true if it is possible to use left/right accesses for a\n-   bitfield of WIDTH bits starting BITPOS bits into *OP.  When\n-   returning true, update *OP, *LEFT and *RIGHT as follows:\n-\n-   *OP is a BLKmode reference to the whole field.\n+   bitfield of WIDTH bits starting BITPOS bits into BLKmode memory OP.\n+   When returning true, update *LEFT and *RIGHT as follows:\n \n    *LEFT is a QImode reference to the first byte if big endian or\n    the last byte if little endian.  This address can be used in the\n@@ -7372,16 +7372,11 @@ mips_expand_atomic_qihi (union mips_gen_fn_ptrs generator,\n    can be used in the patterning right-side instruction.  */\n \n static bool\n-mips_get_unaligned_mem (rtx *op, HOST_WIDE_INT width, HOST_WIDE_INT bitpos,\n+mips_get_unaligned_mem (rtx op, HOST_WIDE_INT width, HOST_WIDE_INT bitpos,\n \t\t\trtx *left, rtx *right)\n {\n   rtx first, last;\n \n-  /* Check that the operand really is a MEM.  Not all the extv and\n-     extzv predicates are checked.  */\n-  if (!MEM_P (*op))\n-    return false;\n-\n   /* Check that the size is valid.  */\n   if (width != 32 && (!TARGET_64BIT || width != 64))\n     return false;\n@@ -7394,20 +7389,12 @@ mips_get_unaligned_mem (rtx *op, HOST_WIDE_INT width, HOST_WIDE_INT bitpos,\n \n   /* Reject aligned bitfields: we want to use a normal load or store\n      instead of a left/right pair.  */\n-  if (MEM_ALIGN (*op) >= width)\n+  if (MEM_ALIGN (op) >= width)\n     return false;\n \n-  /* Create a copy of *OP that refers to the whole field.  This also has\n-     the effect of legitimizing *OP's address for BLKmode, possibly\n-     simplifying it.  */\n-  *op = copy_rtx (adjust_address (*op, BLKmode, 0));\n-  set_mem_size (*op, width / BITS_PER_UNIT);\n-\n-  /* Get references to both ends of the field.  We deliberately don't\n-     use the original QImode *OP for FIRST since the new BLKmode one\n-     might have a simpler address.  */\n-  first = adjust_address (*op, QImode, 0);\n-  last = adjust_address (*op, QImode, width / BITS_PER_UNIT - 1);\n+  /* Get references to both ends of the field.  */\n+  first = adjust_address (op, QImode, 0);\n+  last = adjust_address (op, QImode, width / BITS_PER_UNIT - 1);\n \n   /* Allocate to LEFT and RIGHT according to endianness.  LEFT should\n      correspond to the MSB and RIGHT to the LSB.  */\n@@ -7434,14 +7421,6 @@ mips_expand_ext_as_unaligned_load (rtx dest, rtx src, HOST_WIDE_INT width,\n   rtx left, right, temp;\n   rtx dest1 = NULL_RTX;\n \n-  /* If TARGET_64BIT, the destination of a 32-bit \"extz\" or \"extzv\" will\n-     be a paradoxical word_mode subreg.  This is the only case in which\n-     we allow the destination to be larger than the source.  */\n-  if (GET_CODE (dest) == SUBREG\n-      && GET_MODE (dest) == DImode\n-      && GET_MODE (SUBREG_REG (dest)) == SImode)\n-    dest = SUBREG_REG (dest);\n-\n   /* If TARGET_64BIT, the destination of a 32-bit \"extz\" or \"extzv\" will\n      be a DImode, create a new temp and emit a zero extend at the end.  */\n   if (GET_MODE (dest) == DImode\n@@ -7452,12 +7431,7 @@ mips_expand_ext_as_unaligned_load (rtx dest, rtx src, HOST_WIDE_INT width,\n       dest = gen_reg_rtx (SImode);\n     }\n \n-  /* After the above adjustment, the destination must be the same\n-     width as the source.  */\n-  if (GET_MODE_BITSIZE (GET_MODE (dest)) != width)\n-    return false;\n-\n-  if (!mips_get_unaligned_mem (&src, width, bitpos, &left, &right))\n+  if (!mips_get_unaligned_mem (src, width, bitpos, &left, &right))\n     return false;\n \n   temp = gen_reg_rtx (GET_MODE (dest));\n@@ -7499,7 +7473,7 @@ mips_expand_ins_as_unaligned_store (rtx dest, rtx src, HOST_WIDE_INT width,\n   rtx left, right;\n   enum machine_mode mode;\n \n-  if (!mips_get_unaligned_mem (&dest, width, bitpos, &left, &right))\n+  if (!mips_get_unaligned_mem (dest, width, bitpos, &left, &right))\n     return false;\n \n   mode = mode_for_size (width, MODE_INT, 0);"}, {"sha": "a3aa922198cf7fa2ede647977a5e7a6376c7c041", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 58, "deletions": 57, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2eeb2d179a4353af0a8ff989222301c4f7dc11b/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2eeb2d179a4353af0a8ff989222301c4f7dc11b/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=d2eeb2d179a4353af0a8ff989222301c4f7dc11b", "patch": "@@ -3777,34 +3777,34 @@\n \n ;; Bit field extract patterns which use lwl/lwr or ldl/ldr.\n \n-(define_expand \"extv\"\n-  [(set (match_operand 0 \"register_operand\")\n-\t(sign_extract (match_operand 1 \"nonimmediate_operand\")\n-\t\t      (match_operand 2 \"const_int_operand\")\n-\t\t      (match_operand 3 \"const_int_operand\")))]\n+(define_expand \"extvmisalign<mode>\"\n+  [(set (match_operand:GPR 0 \"register_operand\")\n+\t(sign_extract:GPR (match_operand:BLK 1 \"memory_operand\")\n+\t\t\t  (match_operand 2 \"const_int_operand\")\n+\t\t\t  (match_operand 3 \"const_int_operand\")))]\n   \"!TARGET_MIPS16\"\n {\n   if (mips_expand_ext_as_unaligned_load (operands[0], operands[1],\n \t\t\t\t\t INTVAL (operands[2]),\n \t\t\t\t\t INTVAL (operands[3]),\n \t\t\t\t\t /*unsigned=*/ false))\n     DONE;\n-  else if (register_operand (operands[1], GET_MODE (operands[0]))\n-\t   && ISA_HAS_EXTS && UINTVAL (operands[2]) <= 32)\n-    {\n-      if (GET_MODE (operands[0]) == DImode)\n-\temit_insn (gen_extvdi (operands[0], operands[1], operands[2],\n-\t\t\t       operands[3]));\n-      else\n-\temit_insn (gen_extvsi (operands[0], operands[1], operands[2],\n-\t\t\t       operands[3]));\n-      DONE;\n-    }\n   else\n     FAIL;\n })\n \n-(define_insn \"extv<mode>\"\n+(define_expand \"extv<mode>\"\n+  [(set (match_operand:GPR 0 \"register_operand\")\n+\t(sign_extract:GPR (match_operand:GPR 1 \"register_operand\")\n+\t\t\t  (match_operand 2 \"const_int_operand\")\n+\t\t\t  (match_operand 3 \"const_int_operand\")))]\n+  \"ISA_HAS_EXTS\"\n+{\n+  if (UINTVAL (operands[2]) > 32)\n+    FAIL;\n+})\n+\n+(define_insn \"*extv<mode>\"\n   [(set (match_operand:GPR 0 \"register_operand\" \"=d\")\n         (sign_extract:GPR (match_operand:GPR 1 \"register_operand\" \"d\")\n \t\t\t  (match_operand 2 \"const_int_operand\" \"\")\n@@ -3814,35 +3814,35 @@\n   [(set_attr \"type\"     \"arith\")\n    (set_attr \"mode\"     \"<MODE>\")])\n \n-\n-(define_expand \"extzv\"\n-  [(set (match_operand 0 \"register_operand\")\n-\t(zero_extract (match_operand 1 \"nonimmediate_operand\")\n-\t\t      (match_operand 2 \"const_int_operand\")\n-\t\t      (match_operand 3 \"const_int_operand\")))]\n+(define_expand \"extzvmisalign<mode>\"\n+  [(set (match_operand:GPR 0 \"register_operand\")\n+\t(zero_extract:GPR (match_operand:BLK 1 \"memory_operand\")\n+\t\t\t  (match_operand 2 \"const_int_operand\")\n+\t\t\t  (match_operand 3 \"const_int_operand\")))]\n   \"!TARGET_MIPS16\"\n {\n   if (mips_expand_ext_as_unaligned_load (operands[0], operands[1],\n \t\t\t\t\t INTVAL (operands[2]),\n \t\t\t\t\t INTVAL (operands[3]),\n-\t\t\t\t\t /*unsigned=*/true))\n+\t\t\t\t\t /*unsigned=*/ true))\n     DONE;\n-  else if (mips_use_ins_ext_p (operands[1], INTVAL (operands[2]),\n-\t\t\t       INTVAL (operands[3])))\n-    {\n-      if (GET_MODE (operands[0]) == DImode)\n-        emit_insn (gen_extzvdi (operands[0], operands[1], operands[2],\n-\t\t\t\toperands[3]));\n-      else\n-        emit_insn (gen_extzvsi (operands[0], operands[1], operands[2],\n-\t\t\t\toperands[3]));\n-      DONE;\n-    }\n   else\n     FAIL;\n })\n \n-(define_insn \"extzv<mode>\"\n+(define_expand \"extzv<mode>\"\n+  [(set (match_operand:GPR 0 \"register_operand\")\n+\t(zero_extract:GPR (match_operand:GPR 1 \"register_operand\")\n+\t\t\t  (match_operand 2 \"const_int_operand\")\n+\t\t\t  (match_operand 3 \"const_int_operand\")))]\n+  \"\"\n+{\n+  if (!mips_use_ins_ext_p (operands[1], INTVAL (operands[2]),\n+\t\t\t   INTVAL (operands[3])))\n+    FAIL;\n+})\n+\n+(define_insn \"*extzv<mode>\"\n   [(set (match_operand:GPR 0 \"register_operand\" \"=d\")\n \t(zero_extract:GPR (match_operand:GPR 1 \"register_operand\" \"d\")\n \t\t\t  (match_operand 2 \"const_int_operand\" \"\")\n@@ -3865,36 +3865,37 @@\n    (set_attr \"mode\"     \"SI\")])\n \n \n-(define_expand \"insv\"\n-  [(set (zero_extract (match_operand 0 \"nonimmediate_operand\")\n-\t\t      (match_operand 1 \"immediate_operand\")\n-\t\t      (match_operand 2 \"immediate_operand\"))\n-\t(match_operand 3 \"reg_or_0_operand\"))]\n+(define_expand \"insvmisalign<mode>\"\n+  [(set (zero_extract:GPR (match_operand:BLK 0 \"memory_operand\")\n+\t\t\t  (match_operand 1 \"const_int_operand\")\n+\t\t\t  (match_operand 2 \"const_int_operand\"))\n+\t(match_operand:GPR 3 \"reg_or_0_operand\"))]\n   \"!TARGET_MIPS16\"\n {\n   if (mips_expand_ins_as_unaligned_store (operands[0], operands[3],\n \t\t\t\t\t  INTVAL (operands[1]),\n \t\t\t\t\t  INTVAL (operands[2])))\n     DONE;\n-  else if (mips_use_ins_ext_p (operands[0], INTVAL (operands[1]),\n-\t\t\t       INTVAL (operands[2])))\n-    {\n-      if (GET_MODE (operands[0]) == DImode)\n-        emit_insn (gen_insvdi (operands[0], operands[1], operands[2],\n-\t\t\t       operands[3]));\n-      else\n-        emit_insn (gen_insvsi (operands[0], operands[1], operands[2],\n-\t\t\t       operands[3]));\n-      DONE;\n-   }\n-   else\n-     FAIL;\n+  else\n+    FAIL;\n+})\n+\n+(define_expand \"insv<mode>\"\n+  [(set (zero_extract:GPR (match_operand:GPR 0 \"register_operand\")\n+\t\t\t  (match_operand 1 \"const_int_operand\")\n+\t\t\t  (match_operand 2 \"const_int_operand\"))\n+\t(match_operand:GPR 3 \"reg_or_0_operand\"))]\n+  \"\"\n+{\n+  if (!mips_use_ins_ext_p (operands[0], INTVAL (operands[1]),\n+\t\t\t   INTVAL (operands[2])))\n+    FAIL;\n })\n \n-(define_insn \"insv<mode>\"\n+(define_insn \"*insv<mode>\"\n   [(set (zero_extract:GPR (match_operand:GPR 0 \"register_operand\" \"+d\")\n-\t\t\t  (match_operand:SI 1 \"immediate_operand\" \"I\")\n-\t\t\t  (match_operand:SI 2 \"immediate_operand\" \"I\"))\n+\t\t\t  (match_operand:SI 1 \"const_int_operand\" \"\")\n+\t\t\t  (match_operand:SI 2 \"const_int_operand\" \"\"))\n \t(match_operand:GPR 3 \"reg_or_0_operand\" \"dJ\"))]\n   \"mips_use_ins_ext_p (operands[0], INTVAL (operands[1]),\n \t\t       INTVAL (operands[2]))\""}, {"sha": "6c648eed178aac56c1a7363f51ecb3a26949cc21", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2eeb2d179a4353af0a8ff989222301c4f7dc11b/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2eeb2d179a4353af0a8ff989222301c4f7dc11b/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=d2eeb2d179a4353af0a8ff989222301c4f7dc11b", "patch": "@@ -5294,6 +5294,62 @@ Convert unsigned integer operand 1 of mode @var{m} to fixed-point mode\n When overflows or underflows happen, the instruction saturates the\n results to the maximum or the minimum.\n \n+@cindex @code{extv@var{m}} instruction pattern\n+@item @samp{extv@var{m}}\n+Extract a bit-field from register operand 1, sign-extend it, and store\n+it in operand 0.  Operand 2 specifies the width of the field in bits\n+and operand 3 the starting bit, which counts from the most significant\n+bit if @samp{BITS_BIG_ENDIAN} is true and from the least significant bit\n+otherwise.\n+\n+Operands 0 and 1 both have mode @var{m}.  Operands 2 and 3 have a\n+target-specific mode.\n+\n+@cindex @code{extvmisalign@var{m}} instruction pattern\n+@item @samp{extvmisalign@var{m}}\n+Extract a bit-field from memory operand 1, sign extend it, and store\n+it in operand 0.  Operand 2 specifies the width in bits and operand 3\n+the starting bit.  The starting bit is always somewhere in the first byte of\n+operand 1; it counts from the most significant bit if @samp{BITS_BIG_ENDIAN}\n+is true and from the least significant bit otherwise.\n+\n+Operand 0 has mode @var{m} while operand 1 has @code{BLK} mode.\n+Operands 2 and 3 have a target-specific mode.\n+\n+The instruction must not read beyond the last byte of the bit-field.\n+\n+@cindex @code{extzv@var{m}} instruction pattern\n+@item @samp{extzv@var{m}}\n+Like @samp{extv@var{m}} except that the bit-field value is zero-extended.\n+\n+@cindex @code{extzvmisalign@var{m}} instruction pattern\n+@item @samp{extzvmisalign@var{m}}\n+Like @samp{extvmisalign@var{m}} except that the bit-field value is\n+zero-extended.\n+\n+@cindex @code{insv@var{m}} instruction pattern\n+@item @samp{insv@var{m}}\n+Insert operand 3 into a bit-field of register operand 0.  Operand 1\n+specifies the width of the field in bits and operand 2 the starting bit,\n+which counts from the most significant bit if @samp{BITS_BIG_ENDIAN}\n+is true and from the least significant bit otherwise.\n+\n+Operands 0 and 3 both have mode @var{m}.  Operands 1 and 2 have a\n+target-specific mode.\n+\n+@cindex @code{insvmisalign@var{m}} instruction pattern\n+@item @samp{insvmisalign@var{m}}\n+Insert operand 3 into a bit-field of memory operand 0.  Operand 1\n+specifies the width of the field in bits and operand 2 the starting bit.\n+The starting bit is always somewhere in the first byte of operand 0;\n+it counts from the most significant bit if @samp{BITS_BIG_ENDIAN}\n+is true and from the least significant bit otherwise.\n+\n+Operand 3 has mode @var{m} while operand 0 has @code{BLK} mode.\n+Operands 1 and 2 have a target-specific mode.\n+\n+The instruction must not read or write beyond the last byte of the bit-field.\n+\n @cindex @code{extv} instruction pattern\n @item @samp{extv}\n Extract a bit-field from operand 1 (a register or memory operand), where\n@@ -5309,10 +5365,16 @@ for operands 2 and 3 and the constant is never zero for operand 2.\n The bit-field value is sign-extended to a full word integer\n before it is stored in operand 0.\n \n+This pattern is deprecated; please use @samp{extv@var{m}} and\n+@code{extvmisalign@var{m}} instead.\n+\n @cindex @code{extzv} instruction pattern\n @item @samp{extzv}\n Like @samp{extv} except that the bit-field value is zero-extended.\n \n+This pattern is deprecated; please use @samp{extzv@var{m}} and\n+@code{extzvmisalign@var{m}} instead.\n+\n @cindex @code{insv} instruction pattern\n @item @samp{insv}\n Store operand 3 (which must be valid for @code{word_mode}) into a\n@@ -5324,6 +5386,9 @@ Operands 1 and 2 must be valid for @code{word_mode}.\n The RTL generation pass generates this instruction only with constants\n for operands 1 and 2 and the constant is never zero for operand 1.\n \n+This pattern is deprecated; please use @samp{insv@var{m}} and\n+@code{insvmisalign@var{m}} instead.\n+\n @cindex @code{mov@var{mode}cc} instruction pattern\n @item @samp{mov@var{mode}cc}\n Conditionally move operand 2 or operand 3 into operand 0 according to the"}, {"sha": "353727f332488faad7d0ea29d374b1d92d36f590", "filename": "gcc/optabs.c", "status": "modified", "additions": 35, "deletions": 3, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2eeb2d179a4353af0a8ff989222301c4f7dc11b/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2eeb2d179a4353af0a8ff989222301c4f7dc11b/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=d2eeb2d179a4353af0a8ff989222301c4f7dc11b", "patch": "@@ -8294,6 +8294,35 @@ get_traditional_extraction_insn (extraction_insn *insn,\n   return true;\n }\n \n+/* Return true if an optab exists to perform an insertion or extraction\n+   of type TYPE in mode MODE.  Describe the instruction in *INSN if so.\n+\n+   REG_OPTAB is the optab to use for register structures and\n+   MISALIGN_OPTAB is the optab to use for misaligned memory structures.\n+   POS_OP is the operand number of the bit position.  */\n+\n+static bool\n+get_optab_extraction_insn (struct extraction_insn *insn,\n+\t\t\t   enum extraction_type type,\n+\t\t\t   enum machine_mode mode, direct_optab reg_optab,\n+\t\t\t   direct_optab misalign_optab, int pos_op)\n+{\n+  direct_optab optab = (type == ET_unaligned_mem ? misalign_optab : reg_optab);\n+  enum insn_code icode = direct_optab_handler (optab, mode);\n+  if (icode == CODE_FOR_nothing)\n+    return false;\n+\n+  const struct insn_data_d *data = &insn_data[icode];\n+\n+  insn->icode = icode;\n+  insn->field_mode = mode;\n+  insn->struct_mode = (type == ET_unaligned_mem ? BLKmode : mode);\n+  insn->pos_mode = data->operand[pos_op].mode;\n+  if (insn->pos_mode == VOIDmode)\n+    insn->pos_mode = word_mode;\n+  return true;\n+}\n+\n /* Return true if an instruction exists to perform an insertion or\n    extraction (PATTERN says which) of type TYPE in mode MODE.\n    Describe the instruction in *INSN if so.  */\n@@ -8311,21 +8340,24 @@ get_extraction_insn (extraction_insn *insn,\n \t  && get_traditional_extraction_insn (insn, type, mode,\n \t\t\t\t\t      CODE_FOR_insv, 0, 3))\n \treturn true;\n-      return false;\n+      return get_optab_extraction_insn (insn, type, mode, insv_optab,\n+\t\t\t\t\tinsvmisalign_optab, 2);\n \n     case EP_extv:\n       if (HAVE_extv\n \t  && get_traditional_extraction_insn (insn, type, mode,\n \t\t\t\t\t      CODE_FOR_extv, 1, 0))\n \treturn true;\n-      return false;\n+      return get_optab_extraction_insn (insn, type, mode, extv_optab,\n+\t\t\t\t\textvmisalign_optab, 3);\n \n     case EP_extzv:\n       if (HAVE_extzv\n \t  && get_traditional_extraction_insn (insn, type, mode,\n \t\t\t\t\t      CODE_FOR_extzv, 1, 0))\n \treturn true;\n-      return false;\n+      return get_optab_extraction_insn (insn, type, mode, extzv_optab,\n+\t\t\t\t\textzvmisalign_optab, 3);\n \n     default:\n       gcc_unreachable ();"}, {"sha": "559726b17d2a0c3251def329e7aff66a4346af6b", "filename": "gcc/optabs.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2eeb2d179a4353af0a8ff989222301c4f7dc11b/gcc%2Foptabs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2eeb2d179a4353af0a8ff989222301c4f7dc11b/gcc%2Foptabs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.def?ref=d2eeb2d179a4353af0a8ff989222301c4f7dc11b", "patch": "@@ -171,6 +171,12 @@ OPTAB_DC(mov_optab, \"mov$a\", SET)\n OPTAB_DC(movstrict_optab, \"movstrict$a\", STRICT_LOW_PART)\n OPTAB_D (movmisalign_optab, \"movmisalign$a\")\n OPTAB_D (storent_optab, \"storent$a\")\n+OPTAB_D (insv_optab, \"insv$a\")\n+OPTAB_D (extv_optab, \"extv$a\")\n+OPTAB_D (extzv_optab, \"extzv$a\")\n+OPTAB_D (insvmisalign_optab, \"insvmisalign$a\")\n+OPTAB_D (extvmisalign_optab, \"extvmisalign$a\")\n+OPTAB_D (extzvmisalign_optab, \"extzvmisalign$a\")\n OPTAB_D (push_optab, \"push$a1\")\n OPTAB_D (reload_in_optab, \"reload_in$a\")\n OPTAB_D (reload_out_optab, \"reload_out$a\")"}]}