{"sha": "53e52f00a4e5210e9b09df4ecdcfec734a811dfa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTNlNTJmMDBhNGU1MjEwZTliMDlkZjRlY2RjZmVjNzM0YTgxMWRmYQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-03-10T20:02:45Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-03-10T20:02:45Z"}, "message": "(main, finclude, check_precompiled): When safe_read returns a partial buffer, this means EOF has been reached...\n\n(main, finclude, check_precompiled): When safe_read returns a partial\nbuffer, this means EOF has been reached; don't try to read any more.\n\nFrom-SVN: r6738", "tree": {"sha": "59d94d9b0beb9e90b3c7b4adb96dc9d6976412b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/59d94d9b0beb9e90b3c7b4adb96dc9d6976412b2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/53e52f00a4e5210e9b09df4ecdcfec734a811dfa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53e52f00a4e5210e9b09df4ecdcfec734a811dfa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53e52f00a4e5210e9b09df4ecdcfec734a811dfa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53e52f00a4e5210e9b09df4ecdcfec734a811dfa/comments", "author": null, "committer": null, "parents": [{"sha": "cd86f81df5baae52f2da15e4a2582d66d5c69ca6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd86f81df5baae52f2da15e4a2582d66d5c69ca6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd86f81df5baae52f2da15e4a2582d66d5c69ca6"}], "stats": {"total": 78, "additions": 20, "deletions": 58}, "files": [{"sha": "a37ab311727683c62205ca519def2ab41b8be63b", "filename": "gcc/cccp.c", "status": "modified", "additions": 20, "deletions": 58, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53e52f00a4e5210e9b09df4ecdcfec734a811dfa/gcc%2Fcccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53e52f00a4e5210e9b09df4ecdcfec734a811dfa/gcc%2Fcccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcccp.c?ref=53e52f00a4e5210e9b09df4ecdcfec734a811dfa", "patch": "@@ -993,7 +993,9 @@ static int deps_column;\n static int ignore_srcdir;\n \f\n /* Read LEN bytes at PTR from descriptor DESC, for file FILENAME,\n-   retrying if necessary.  Return the actual number of bytes read.  */\n+   retrying if necessary.  Return a negative value if an error occurs,\n+   otherwise return the actual number of bytes read,\n+   which must be LEN unless end-of-file was reached.  */\n \n static int\n safe_read (desc, ptr, len)\n@@ -1942,41 +1944,25 @@ main (argc, argv)\n     int size;\n     int bsize;\n     int cnt;\n-    U_CHAR *bufp;\n \n     bsize = 2000;\n     size = 0;\n     fp->buf = (U_CHAR *) xmalloc (bsize + 2);\n-    bufp = fp->buf;\n     for (;;) {\n-      cnt = safe_read (f, bufp, bsize - size);\n+      cnt = safe_read (f, fp->buf + size, bsize - size);\n       if (cnt < 0) goto perror;\t/* error! */\n-      if (cnt == 0) break;\t/* End of file */\n       size += cnt;\n-      bufp += cnt;\n-      if (bsize == size) {\t/* Buffer is full! */\n-        bsize *= 2;\n-        fp->buf = (U_CHAR *) xrealloc (fp->buf, bsize + 2);\n-\tbufp = fp->buf + size;\t/* May have moved */\n-      }\n+      if (size != bsize) break;\t/* End of file */\n+      bsize *= 2;\n+      fp->buf = (U_CHAR *) xrealloc (fp->buf, bsize + 2);\n     }\n     fp->length = size;\n   } else {\n     /* Read a file whose size we can determine in advance.\n        For the sake of VMS, st_size is just an upper bound.  */\n-    long i;\n-    fp->length = 0;\n     fp->buf = (U_CHAR *) xmalloc (st_size + 2);\n-\n-    while (st_size > 0) {\n-      i = safe_read (f, fp->buf + fp->length, st_size);\n-      if (i <= 0) {\n-        if (i == 0) break;\n-\tgoto perror;\n-      }\n-      fp->length += i;\n-      st_size -= i;\n-    }\n+    fp->length = safe_read (f, fp->buf, st_size);\n+    if (fp->length < 0) goto perror;\n   }\n   fp->bufp = fp->buf;\n   fp->if_stack = if_stack;\n@@ -4563,15 +4549,8 @@ finclude (f, fname, op, system_header_p, dirptr)\n \n     /* Read the file contents, knowing that st_size is an upper bound\n        on the number of bytes we can read.  */\n-    while (st_size > 0) {\n-      i = safe_read (f, fp->buf + fp->length, st_size);\n-      if (i <= 0) {\n-\tif (i == 0) break;\n-\tgoto nope;\n-      }\n-      fp->length += i;\n-      st_size -= i;\n-    }\n+    fp->length = safe_read (f, fp->buf, st_size);\n+    if (fp->length < 0) goto nope;\n   }\n   else if (S_ISDIR (st_mode)) {\n     error (\"directory `%s' specified in #include\", fname);\n@@ -4582,29 +4561,20 @@ finclude (f, fname, op, system_header_p, dirptr)\n        First read the entire file into heap and\n        copy them into buffer on stack. */\n \n-    U_CHAR *bufp;\n-    U_CHAR *basep;\n     int bsize = 2000;\n \n     st_size = 0;\n-    basep = (U_CHAR *) xmalloc (bsize + 2);\n-    fp->buf = basep; /* So it will get freed, on error.  */\n-    bufp = basep;\n+    fp->buf = (U_CHAR *) xmalloc (bsize + 2);\n \n     for (;;) {\n-      i = safe_read (f, bufp, bsize - st_size);\n+      i = safe_read (f, fp->buf + st_size, bsize - st_size);\n       if (i < 0)\n \tgoto nope;      /* error! */\n-      if (i == 0)\n-\tbreak;\t/* End of file */\n       st_size += i;\n-      bufp += i;\n-      if (bsize == st_size) {\t/* Buffer is full! */\n-\t  bsize *= 2;\n-\t  basep = (U_CHAR *) xrealloc (basep, bsize + 2);\n-\t  fp->buf = basep;\n-\t  bufp = basep + st_size;\t/* May have moved */\n-\t}\n+      if (st_size != bsize)\n+\tbreak;\t/* End of file */\n+      bsize *= 2;\n+      fp->buf = (U_CHAR *) xrealloc (fp->buf, bsize + 2);\n     }\n     fp->bufp = fp->buf;\n     fp->length = st_size;\n@@ -4792,7 +4762,6 @@ check_precompiled (pcf, fname, limit)\n   long st_size;\n   int length = 0;\n   char *buf;\n-  int i;\n   char *cp;\n \n   if (pcp_outfile)\n@@ -4804,16 +4773,9 @@ check_precompiled (pcf, fname, limit)\n   if (S_ISREG (st_mode))\n     {\n       buf = xmalloc (st_size + 2);\n-      while (st_size > 0)\n-\t{\n-\t  i = safe_read (pcf, buf + length, st_size);\n-\t  if (i < 0)\n-\t    goto nope;\n-\t  if (i == 0)\n-\t    break;\n-\t  length += i;\n-\t  st_size -= i;\n-\t}\t  \n+      length = safe_read (pcf, buf, st_size);\n+      if (length < 0)\n+\tgoto nope;\n     }\n   else\n     abort ();"}]}