{"sha": "a93cdc5c6f1d56226c3ef7b69423a4074783de34", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTkzY2RjNWM2ZjFkNTYyMjZjM2VmN2I2OTQyM2E0MDc0NzgzZGUzNA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2016-10-07T09:33:47Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2016-10-07T09:33:47Z"}, "message": "re PR tree-optimization/77664 (Missed optimization: signed int >= 0 && < unsigned short)\n\n\tPR tree-optimization/77664\n\t* tree-ssa-reassoc.c (update_range_test): Also clear low and high\n\tfor the other ranges.\n\t(optimize_range_tests_diff): Fix up formatting.\n\t(optimize_range_tests_var_bound): New function.\n\t(optimize_range_tests): Use it.\n\n\t* gcc.dg/tree-ssa/pr77664.c: New test.\n\t* gcc.dg/pr77664.c: New test.\n\nFrom-SVN: r240858", "tree": {"sha": "834010f00642c9146308937f43b74e43fcdbbc0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/834010f00642c9146308937f43b74e43fcdbbc0a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a93cdc5c6f1d56226c3ef7b69423a4074783de34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a93cdc5c6f1d56226c3ef7b69423a4074783de34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a93cdc5c6f1d56226c3ef7b69423a4074783de34", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a93cdc5c6f1d56226c3ef7b69423a4074783de34/comments", "author": null, "committer": null, "parents": [{"sha": "533144bccdb4d411669b229f437c8cf193d47bb5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/533144bccdb4d411669b229f437c8cf193d47bb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/533144bccdb4d411669b229f437c8cf193d47bb5"}], "stats": {"total": 324, "additions": 319, "deletions": 5}, "files": [{"sha": "1be7817592a5912d91af78e5300c6354525df0c1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a93cdc5c6f1d56226c3ef7b69423a4074783de34/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a93cdc5c6f1d56226c3ef7b69423a4074783de34/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a93cdc5c6f1d56226c3ef7b69423a4074783de34", "patch": "@@ -1,3 +1,12 @@\n+2016-10-07  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/77664\n+\t* tree-ssa-reassoc.c (update_range_test): Also clear low and high\n+\tfor the other ranges.\n+\t(optimize_range_tests_diff): Fix up formatting.\n+\t(optimize_range_tests_var_bound): New function.\n+\t(optimize_range_tests): Use it.\n+\n 2016-10-07  Martin Liska  <mliska@suse.cz>\n \n \t* coverage.c (build_gcov_exit_decl): Fix priority what"}, {"sha": "5721cda85eb093359ea66894f4ef3e79f51da270", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a93cdc5c6f1d56226c3ef7b69423a4074783de34/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a93cdc5c6f1d56226c3ef7b69423a4074783de34/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a93cdc5c6f1d56226c3ef7b69423a4074783de34", "patch": "@@ -1,4 +1,10 @@\n-2016-10-06  Louis Krupp <louis.krupp@zoho.com>\n+2016-10-07  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/77664\n+\t* gcc.dg/tree-ssa/pr77664.c: New test.\n+\t* gcc.dg/pr77664.c: New test.\n+\n+2016-10-06  Louis Krupp  <louis.krupp@zoho.com>\n \n \t* gfortran.dg/pr69955.f90: New test.\n "}, {"sha": "bcf7b885608e0a71cae4fb4dd7e5b4e6adf2c8a0", "filename": "gcc/testsuite/gcc.dg/pr77664.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a93cdc5c6f1d56226c3ef7b69423a4074783de34/gcc%2Ftestsuite%2Fgcc.dg%2Fpr77664.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a93cdc5c6f1d56226c3ef7b69423a4074783de34/gcc%2Ftestsuite%2Fgcc.dg%2Fpr77664.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr77664.c?ref=a93cdc5c6f1d56226c3ef7b69423a4074783de34", "patch": "@@ -0,0 +1,55 @@\n+/* PR tree-optimization/77664 */\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+\n+#include \"tree-ssa/pr77664.c\"\n+\n+int cnt;\n+\n+__attribute__((noinline, noclone)) void\n+foo (void)\n+{\n+  cnt++;\n+}\n+\n+int\n+main ()\n+{\n+  fn1 (65534U, 65535U, 7); if (cnt != 1) __builtin_abort ();\n+  fn1 (65534U, 65535U, 0); if (cnt != 1) __builtin_abort ();\n+  fn1 (65535U, 65535U, 1); if (cnt != 1) __builtin_abort ();\n+  fn1 (0, 65535U, 1); if (cnt != 2) __builtin_abort ();\n+  fn1 (-1, 65535U, 1); if (cnt != 2) __builtin_abort ();\n+  fn1 (0, 0, 1); if (cnt != 2) __builtin_abort ();\n+  fn2 (65534U, 65535U, 7); if (cnt != 3) __builtin_abort ();\n+  fn2 (65534U, 65535U, 0); if (cnt != 3) __builtin_abort ();\n+  fn2 (65535U, 65535U, 0); if (cnt != 4) __builtin_abort ();\n+  fn2 (0, 65535U, 0); if (cnt != 4) __builtin_abort ();\n+  fn2 (-1, 65535U, 0); if (cnt != 5) __builtin_abort ();\n+  fn2 (0, 0, 0); if (cnt != 6) __builtin_abort ();\n+  fn3 (-1, 65534U); if (cnt != 7) __builtin_abort ();\n+  fn3 (0, 65534U); if (cnt != 7) __builtin_abort ();\n+  fn3 (65534U, 65534U); if (cnt != 7) __builtin_abort ();\n+  fn3 (65535U, 65534U); if (cnt != 8) __builtin_abort ();\n+  fn3 (0, 0); if (cnt != 8) __builtin_abort ();\n+  fn3 (1, 0); if (cnt != 9) __builtin_abort ();\n+  fn4 (-1, 65534U); if (cnt != 9) __builtin_abort ();\n+  fn4 (0, 65534U); if (cnt != 10) __builtin_abort ();\n+  fn4 (65534U, 65534U); if (cnt != 11) __builtin_abort ();\n+  fn4 (65535U, 65534U); if (cnt != 11) __builtin_abort ();\n+  fn4 (0, 0); if (cnt != 12) __builtin_abort ();\n+  fn4 (1, 0); if (cnt != 12) __builtin_abort ();\n+  fn5 (-1, 65534U); if (cnt != 13) __builtin_abort ();\n+  fn5 (0, 65534U); if (cnt != 13) __builtin_abort ();\n+  fn5 (65534U, 65534U); if (cnt != 13) __builtin_abort ();\n+  fn5 (65535U, 65534U); if (cnt != 14) __builtin_abort ();\n+  fn5 (0, 0); if (cnt != 14) __builtin_abort ();\n+  fn5 (1, 0); if (cnt != 15) __builtin_abort ();\n+  fn6 (-1, 65534U); if (cnt != 15) __builtin_abort ();\n+  fn6 (0, 65534U); if (cnt != 16) __builtin_abort ();\n+  fn6 (65534U, 65534U); if (cnt != 17) __builtin_abort ();\n+  fn6 (65535U, 65534U); if (cnt != 17) __builtin_abort ();\n+  fn6 (0, 0); if (cnt != 18) __builtin_abort ();\n+  fn6 (1, 0); if (cnt != 18) __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "e98945f00416ec33ae188b27e5b8c32ae20e6124", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr77664.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a93cdc5c6f1d56226c3ef7b69423a4074783de34/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr77664.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a93cdc5c6f1d56226c3ef7b69423a4074783de34/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr77664.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr77664.c?ref=a93cdc5c6f1d56226c3ef7b69423a4074783de34", "patch": "@@ -0,0 +1,49 @@\n+/* PR tree-optimization/77664 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-reassoc1-details\" } */\n+\n+extern void foo (void);\n+\n+/* { dg-final { scan-tree-dump-times \"Optimizing range test \\[^\\n\\r]* and comparison\" 6 \"reassoc1\" } } */\n+\n+__attribute__((noinline, noclone)) void\n+fn1 (long long int a, unsigned short b, int c)\n+{\n+  if (a >= 0 && c && a < b)\n+    foo ();\n+}\n+\n+__attribute__((noinline, noclone)) void\n+fn2 (long long int a, unsigned short b, int c)\n+{\n+  if (a < 0 || c || a >= b)\n+    foo ();\n+}\n+\n+__attribute__((noinline, noclone)) void\n+fn3 (long long int a, unsigned short b)\n+{\n+  if (a < 0 || b < a)\n+    foo ();\n+}\n+\n+__attribute__((noinline, noclone)) void\n+fn4 (long long int a, unsigned short b)\n+{\n+  if (a <= b && a >= 0)\n+    foo ();\n+}\n+\n+__attribute__((noinline, noclone)) void\n+fn5 (long long int a, unsigned short b)\n+{\n+  if (a < 0 | a > b)\n+    foo ();\n+}\n+\n+__attribute__((noinline, noclone)) void\n+fn6 (long long int a, unsigned short b)\n+{\n+  if (b >= a & a >= 0)\n+    foo ();\n+}"}, {"sha": "c5b36ef2cede468ff5bde32a71a68fd74c8d7807", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 199, "deletions": 4, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a93cdc5c6f1d56226c3ef7b69423a4074783de34/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a93cdc5c6f1d56226c3ef7b69423a4074783de34/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=a93cdc5c6f1d56226c3ef7b69423a4074783de34", "patch": "@@ -2428,6 +2428,8 @@ update_range_test (struct range_entry *range, struct range_entry *otherrange,\n       else\n \toe->op = error_mark_node;\n       range->exp = NULL_TREE;\n+      range->low = NULL_TREE;\n+      range->high = NULL_TREE;\n     }\n   return true;\n }\n@@ -2485,10 +2487,10 @@ optimize_range_tests_xor (enum tree_code opcode, tree type,\n    ((X - 43U) & ~(75U - 43U)) <= 3U.  */\n static bool\n optimize_range_tests_diff (enum tree_code opcode, tree type,\n-\t\t\t    tree lowi, tree lowj, tree highi, tree highj,\n-\t\t\t    vec<operand_entry *> *ops,\n-\t\t\t    struct range_entry *rangei,\n-\t\t\t    struct range_entry *rangej)\n+\t\t\t   tree lowi, tree lowj, tree highi, tree highj,\n+\t\t\t   vec<operand_entry *> *ops,\n+\t\t\t   struct range_entry *rangei,\n+\t\t\t   struct range_entry *rangej)\n {\n   tree tem1, tem2, mask;\n   /* Check highi - lowi == highj - lowj.  */\n@@ -2829,6 +2831,197 @@ optimize_range_tests_to_bit_test (enum tree_code opcode, int first, int length,\n   return any_changes;\n }\n \n+/* Attempt to optimize for signed a and b where b is known to be >= 0:\n+   a >= 0 && a < b into (unsigned) a < (unsigned) b\n+   a >= 0 && a <= b into (unsigned) a <= (unsigned) b  */\n+\n+static bool\n+optimize_range_tests_var_bound (enum tree_code opcode, int first, int length,\n+\t\t\t\tvec<operand_entry *> *ops,\n+\t\t\t\tstruct range_entry *ranges)\n+{\n+  int i;\n+  bool any_changes = false;\n+  hash_map<tree, int> *map = NULL;\n+\n+  for (i = first; i < length; i++)\n+    {\n+      if (ranges[i].exp == NULL_TREE || !ranges[i].in_p)\n+\tcontinue;\n+\n+      tree type = TREE_TYPE (ranges[i].exp);\n+      if (!INTEGRAL_TYPE_P (type)\n+\t  || TYPE_UNSIGNED (type)\n+\t  || ranges[i].low == NULL_TREE\n+\t  || !integer_zerop (ranges[i].low)\n+\t  || ranges[i].high != NULL_TREE)\n+\tcontinue;\n+      /* EXP >= 0 here.  */\n+      if (map == NULL)\n+\tmap = new hash_map <tree, int>;\n+      map->put (ranges[i].exp, i);\n+    }\n+\n+  if (map == NULL)\n+    return false;\n+\n+  for (i = 0; i < length; i++)\n+    {\n+      if (ranges[i].low == NULL_TREE\n+\t  || ranges[i].high == NULL_TREE\n+\t  || !integer_zerop (ranges[i].low)\n+\t  || !integer_zerop (ranges[i].high))\n+\tcontinue;\n+\n+      gimple *stmt;\n+      tree_code ccode;\n+      tree rhs1, rhs2;\n+      if (ranges[i].exp)\n+\t{\n+\t  stmt = SSA_NAME_DEF_STMT (ranges[i].exp);\n+\t  if (!is_gimple_assign (stmt))\n+\t    continue;\n+\t  ccode = gimple_assign_rhs_code (stmt);\n+\t  rhs1 = gimple_assign_rhs1 (stmt);\n+\t  rhs2 = gimple_assign_rhs2 (stmt);\n+\t}\n+      else\n+\t{\n+\t  operand_entry *oe = (*ops)[ranges[i].idx];\n+\t  stmt = last_stmt (BASIC_BLOCK_FOR_FN (cfun, oe->id));\n+\t  if (gimple_code (stmt) != GIMPLE_COND)\n+\t    continue;\n+\t  ccode = gimple_cond_code (stmt);\n+\t  rhs1 = gimple_cond_lhs (stmt);\n+\t  rhs2 = gimple_cond_rhs (stmt);\n+\t}\n+\n+      if (TREE_CODE (rhs1) != SSA_NAME\n+\t  || rhs2 == NULL_TREE\n+\t  || TREE_CODE (rhs2) != SSA_NAME)\n+\tcontinue;\n+\n+      switch (ccode)\n+\t{\n+\tcase GT_EXPR:\n+\tcase GE_EXPR:\n+\t  if (!ranges[i].in_p)\n+\t    std::swap (rhs1, rhs2);\n+\t  ccode = swap_tree_comparison (ccode);\n+\t  break;\n+\tcase LT_EXPR:\n+\tcase LE_EXPR:\n+\t  if (ranges[i].in_p)\n+\t    std::swap (rhs1, rhs2);\n+\t  break;\n+\tdefault:\n+\t  continue;\n+\t}\n+\n+      int *idx = map->get (rhs1);\n+      if (idx == NULL)\n+\tcontinue;\n+\n+      wide_int nz = get_nonzero_bits (rhs2);\n+      if (wi::neg_p (nz))\n+\tcontinue;\n+\n+      /* We have EXP < RHS2 or EXP <= RHS2 where EXP >= 0\n+\t and RHS2 is known to be RHS2 >= 0.  */\n+      tree utype = unsigned_type_for (TREE_TYPE (rhs1));\n+\n+      enum warn_strict_overflow_code wc = WARN_STRICT_OVERFLOW_COMPARISON;\n+      if ((ranges[*idx].strict_overflow_p\n+\t   || ranges[i].strict_overflow_p)\n+\t  && issue_strict_overflow_warning (wc))\n+\twarning_at (gimple_location (stmt), OPT_Wstrict_overflow,\n+\t\t    \"assuming signed overflow does not occur \"\n+\t\t    \"when simplifying range test\");\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  struct range_entry *r = &ranges[*idx];\n+\t  fprintf (dump_file, \"Optimizing range test \");\n+\t  print_generic_expr (dump_file, r->exp, 0);\n+\t  fprintf (dump_file, \" +[\");\n+\t  print_generic_expr (dump_file, r->low, 0);\n+\t  fprintf (dump_file, \", \");\n+\t  print_generic_expr (dump_file, r->high, 0);\n+\t  fprintf (dump_file, \"] and comparison \");\n+\t  print_generic_expr (dump_file, rhs1, 0);\n+\t  fprintf (dump_file, \" %s \", op_symbol_code (ccode));\n+\t  print_generic_expr (dump_file, rhs2, 0);\n+\t  fprintf (dump_file, \"\\n into (\");\n+\t  print_generic_expr (dump_file, utype, 0);\n+\t  fprintf (dump_file, \") \");\n+\t  print_generic_expr (dump_file, rhs1, 0);\n+\t  fprintf (dump_file, \" %s (\", op_symbol_code (ccode));\n+\t  print_generic_expr (dump_file, utype, 0);\n+\t  fprintf (dump_file, \") \");\n+\t  print_generic_expr (dump_file, rhs2, 0);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+\n+      if (ranges[i].in_p)\n+\tstd::swap (rhs1, rhs2);\n+\n+      unsigned int uid = gimple_uid (stmt);\n+      gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n+      gimple *g = gimple_build_assign (make_ssa_name (utype), NOP_EXPR, rhs1);\n+      gimple_set_uid (g, uid);\n+      rhs1 = gimple_assign_lhs (g);\n+      gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+      g = gimple_build_assign (make_ssa_name (utype), NOP_EXPR, rhs2);\n+      gimple_set_uid (g, uid);\n+      rhs2 = gimple_assign_lhs (g);\n+      gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+      if (tree_swap_operands_p (rhs1, rhs2, false))\n+\t{\n+\t  std::swap (rhs1, rhs2);\n+\t  ccode = swap_tree_comparison (ccode);\n+\t}\n+      if (gimple_code (stmt) == GIMPLE_COND)\n+\t{\n+\t  gcond *c = as_a <gcond *> (stmt);\n+\t  gimple_cond_set_code (c, ccode);\n+\t  gimple_cond_set_lhs (c, rhs1);\n+\t  gimple_cond_set_rhs (c, rhs2);\n+\t  update_stmt (stmt);\n+\t}\n+      else\n+\t{\n+\t  g = gimple_build_assign (make_ssa_name (TREE_TYPE (ranges[i].exp)),\n+\t\t\t\t   ccode, rhs1, rhs2);\n+\t  gimple_set_uid (g, uid);\n+\t  gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+\t  ranges[i].exp = gimple_assign_lhs (g);\n+\t  (*ops)[ranges[i].idx]->op = ranges[i].exp;\n+\t}\n+      ranges[i].strict_overflow_p = false;\n+      operand_entry *oe = (*ops)[ranges[*idx].idx];\n+      /* Now change all the other range test immediate uses, so that\n+\t those tests will be optimized away.  */\n+      if (opcode == ERROR_MARK)\n+\t{\n+\t  if (oe->op)\n+\t    oe->op = build_int_cst (TREE_TYPE (oe->op),\n+\t\t\t\t    oe->rank == BIT_IOR_EXPR ? 0 : 1);\n+\t  else\n+\t    oe->op = (oe->rank == BIT_IOR_EXPR\n+\t\t      ? boolean_false_node : boolean_true_node);\n+\t}\n+      else\n+\toe->op = error_mark_node;\n+      ranges[*idx].exp = NULL_TREE;\n+      ranges[*idx].low = NULL_TREE;\n+      ranges[*idx].high = NULL_TREE;\n+      any_changes = true;\n+    }\n+\n+  delete map;\n+  return any_changes;\n+}\n+\n /* Optimize range tests, similarly how fold_range_test optimizes\n    it on trees.  The tree code for the binary\n    operation between all the operands is OPCODE.\n@@ -2917,6 +3110,8 @@ optimize_range_tests (enum tree_code opcode,\n   if (lshift_cheap_p (optimize_function_for_speed_p (cfun)))\n     any_changes |= optimize_range_tests_to_bit_test (opcode, first, length,\n \t\t\t\t\t\t     ops, ranges);\n+  any_changes |= optimize_range_tests_var_bound (opcode, first, length, ops,\n+\t\t\t\t\t\t ranges);\n \n   if (any_changes && opcode != ERROR_MARK)\n     {"}]}