{"sha": "4bbae09f178ab7f11dbb4469604f347f615f686e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGJiYWUwOWYxNzhhYjdmMTFkYmI0NDY5NjA0ZjM0N2Y2MTVmNjg2ZQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@airs.com", "date": "2005-10-11T23:45:54Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2005-10-11T23:45:54Z"}, "message": "re PR rtl-optimization/13931 (combiner much slower on big basic blocks)\n\n\tPR rtl-optimization/13931\n\t* combine.c: Revert patch of 2003-05-14, and:\n\t(try_combine): Only set elim_i1 and elim_i2 if the destination is\n\tcompletely killed in the appropriate insn.\n\t(distribute_notes): Don't skip multiple hard register test for\n\telim_i1 and elim_i2.\n\nFrom-SVN: r105275", "tree": {"sha": "8946bf41e986a0c5163c45223fe9913547fc9cab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8946bf41e986a0c5163c45223fe9913547fc9cab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4bbae09f178ab7f11dbb4469604f347f615f686e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bbae09f178ab7f11dbb4469604f347f615f686e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bbae09f178ab7f11dbb4469604f347f615f686e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bbae09f178ab7f11dbb4469604f347f615f686e/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a2694f689cbb6c4780c2aba88c8462c8059cc182", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2694f689cbb6c4780c2aba88c8462c8059cc182", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2694f689cbb6c4780c2aba88c8462c8059cc182"}], "stats": {"total": 84, "additions": 66, "deletions": 18}, "files": [{"sha": "8fa4b88a3afa01bcef4b3bca7022ca7d1ea13fef", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bbae09f178ab7f11dbb4469604f347f615f686e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bbae09f178ab7f11dbb4469604f347f615f686e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4bbae09f178ab7f11dbb4469604f347f615f686e", "patch": "@@ -1,3 +1,12 @@\n+2005-10-11  Ian Lance Taylor  <ian@airs.com>\n+\n+\tPR rtl-optimization/13931\n+\t* combine.c: Revert patch of 2003-05-14, and:\n+\t(try_combine): Only set elim_i1 and elim_i2 if the destination is\n+\tcompletely killed in the appropriate insn.\n+\t(distribute_notes): Don't skip multiple hard register test for\n+\telim_i1 and elim_i2.\n+\n 2005-10-11  Richard Henderson  <rth@redhat.com>\n \n \tPR c/24255"}, {"sha": "3be34e4b44d5be6288a52b98531d9a2a68c89d16", "filename": "gcc/combine.c", "status": "modified", "additions": 57, "deletions": 18, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bbae09f178ab7f11dbb4469604f347f615f686e/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bbae09f178ab7f11dbb4469604f347f615f686e/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=4bbae09f178ab7f11dbb4469604f347f615f686e", "patch": "@@ -53,6 +53,10 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n    flow.c aren't completely updated:\n \n    - reg_live_length is not updated\n+   - reg_n_refs is not adjusted in the rare case when a register is\n+     no longer required in a computation\n+   - there are extremely rare cases (see distribute_regnotes) when a\n+     REG_DEAD note is lost\n    - a LOG_LINKS entry that refers to an insn with multiple SETs may be\n      removed because there is no way to know which register it was\n      linking\n@@ -410,7 +414,7 @@ static void reg_dead_at_p_1 (rtx, rtx, void *);\n static int reg_dead_at_p (rtx, rtx);\n static void move_deaths (rtx, rtx, int, rtx, rtx *);\n static int reg_bitfield_target_p (rtx, rtx);\n-static void distribute_notes (rtx, rtx, rtx, rtx);\n+static void distribute_notes (rtx, rtx, rtx, rtx, rtx, rtx);\n static void distribute_links (rtx);\n static void mark_used_regs_combine (rtx);\n static int insn_cuid (rtx);\n@@ -1730,6 +1734,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n   rtx i2pat;\n   /* Indicates if I2DEST or I1DEST is in I2SRC or I1_SRC.  */\n   int i2dest_in_i2src = 0, i1dest_in_i1src = 0, i2dest_in_i1src = 0;\n+  int i2dest_killed = 0, i1dest_killed = 0;\n   int i1_feeds_i3 = 0;\n   /* Notes that must be added to REG_NOTES in I3 and I2.  */\n   rtx new_i3_notes, new_i2_notes;\n@@ -1838,6 +1843,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \n \t      added_sets_2 = added_sets_1 = 0;\n \t      i2dest = SET_SRC (PATTERN (i3));\n+\t      i2dest_killed = dead_or_set_p (i2, i2dest);\n \n \t      /* Replace the dest in I2 with our dest and make the resulting\n \t\t insn the new pattern for I3.  Then skip to where we\n@@ -1912,6 +1918,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n       subst_low_cuid = INSN_CUID (i2);\n       added_sets_2 = added_sets_1 = 0;\n       i2dest = SET_DEST (temp);\n+      i2dest_killed = dead_or_set_p (i2, i2dest);\n \n       SUBST (SET_SRC (temp),\n \t     immed_double_const (lo, hi, GET_MODE (SET_DEST (temp))));\n@@ -1982,6 +1989,8 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n   i2dest_in_i2src = reg_overlap_mentioned_p (i2dest, i2src);\n   i1dest_in_i1src = i1 && reg_overlap_mentioned_p (i1dest, i1src);\n   i2dest_in_i1src = i1 && reg_overlap_mentioned_p (i2dest, i1src);\n+  i2dest_killed = dead_or_set_p (i2, i2dest);\n+  i1dest_killed = i1 && dead_or_set_p (i1, i1dest);\n \n   /* See if I1 directly feeds into I3.  It does if I1DEST is not used\n      in I2SRC.  */\n@@ -2737,7 +2746,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t  REG_N_DEATHS (REGNO (XEXP (note, 0)))++;\n \n       distribute_notes (new_other_notes, undobuf.other_insn,\n-\t\t\tundobuf.other_insn, NULL_RTX);\n+\t\t\tundobuf.other_insn, NULL_RTX, NULL_RTX, NULL_RTX);\n     }\n #ifdef HAVE_cc0\n   /* If I2 is the CC0 setter and I3 is the CC0 user then check whether\n@@ -2812,6 +2821,17 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n     rtx i3links, i2links, i1links = 0;\n     rtx midnotes = 0;\n     unsigned int regno;\n+    /* Compute which registers we expect to eliminate.  newi2pat may be setting\n+       either i3dest or i2dest, so we must check it.  Also, i1dest may be the\n+       same as i3dest, in which case newi2pat may be setting i1dest.  */\n+    rtx elim_i2 = ((newi2pat && reg_set_p (i2dest, newi2pat))\n+\t\t   || i2dest_in_i2src || i2dest_in_i1src\n+\t\t   || !i2dest_killed\n+\t\t   ? 0 : i2dest);\n+    rtx elim_i1 = (i1 == 0 || i1dest_in_i1src\n+\t\t   || (newi2pat && reg_set_p (i1dest, newi2pat))\n+\t\t   || !i1dest_killed\n+\t\t   ? 0 : i1dest);\n \n     /* Get the old REG_NOTES and LOG_LINKS from all our insns and\n        clear them.  */\n@@ -2936,13 +2956,17 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \n     /* Distribute all the LOG_LINKS and REG_NOTES from I1, I2, and I3.  */\n     if (i3notes)\n-      distribute_notes (i3notes, i3, i3, newi2pat ? i2 : NULL_RTX);\n+      distribute_notes (i3notes, i3, i3, newi2pat ? i2 : NULL_RTX,\n+\t\t\telim_i2, elim_i1);\n     if (i2notes)\n-      distribute_notes (i2notes, i2, i3, newi2pat ? i2 : NULL_RTX);\n+      distribute_notes (i2notes, i2, i3, newi2pat ? i2 : NULL_RTX,\n+\t\t\telim_i2, elim_i1);\n     if (i1notes)\n-      distribute_notes (i1notes, i1, i3, newi2pat ? i2 : NULL_RTX);\n+      distribute_notes (i1notes, i1, i3, newi2pat ? i2 : NULL_RTX,\n+\t\t\telim_i2, elim_i1);\n     if (midnotes)\n-      distribute_notes (midnotes, NULL_RTX, i3, newi2pat ? i2 : NULL_RTX);\n+      distribute_notes (midnotes, NULL_RTX, i3, newi2pat ? i2 : NULL_RTX,\n+\t\t\telim_i2, elim_i1);\n \n     /* Distribute any notes added to I2 or I3 by recog_for_combine.  We\n        know these are REG_UNUSED and want them to go to the desired insn,\n@@ -2955,7 +2979,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t  if (REG_P (XEXP (temp, 0)))\n \t    REG_N_DEATHS (REGNO (XEXP (temp, 0)))++;\n \n-\tdistribute_notes (new_i2_notes, i2, i2, NULL_RTX);\n+\tdistribute_notes (new_i2_notes, i2, i2, NULL_RTX, NULL_RTX, NULL_RTX);\n       }\n \n     if (new_i3_notes)\n@@ -2964,7 +2988,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t  if (REG_P (XEXP (temp, 0)))\n \t    REG_N_DEATHS (REGNO (XEXP (temp, 0)))++;\n \n-\tdistribute_notes (new_i3_notes, i3, i3, NULL_RTX);\n+\tdistribute_notes (new_i3_notes, i3, i3, NULL_RTX, NULL_RTX, NULL_RTX);\n       }\n \n     /* If I3DEST was used in I3SRC, it really died in I3.  We may need to\n@@ -2982,11 +3006,12 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \tif (newi2pat && reg_set_p (i3dest_killed, newi2pat))\n \t  distribute_notes (gen_rtx_EXPR_LIST (REG_DEAD, i3dest_killed,\n \t\t\t\t\t       NULL_RTX),\n-\t\t\t    NULL_RTX, i2, NULL_RTX);\n+\t\t\t    NULL_RTX, i2, NULL_RTX, elim_i2, elim_i1);\n \telse\n \t  distribute_notes (gen_rtx_EXPR_LIST (REG_DEAD, i3dest_killed,\n \t\t\t\t\t       NULL_RTX),\n-\t\t\t    NULL_RTX, i3, newi2pat ? i2 : NULL_RTX);\n+\t\t\t    NULL_RTX, i3, newi2pat ? i2 : NULL_RTX,\n+\t\t\t    elim_i2, elim_i1);\n       }\n \n     if (i2dest_in_i2src)\n@@ -2996,10 +3021,11 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \n \tif (newi2pat && reg_set_p (i2dest, newi2pat))\n \t  distribute_notes (gen_rtx_EXPR_LIST (REG_DEAD, i2dest, NULL_RTX),\n-\t\t\t    NULL_RTX, i2, NULL_RTX);\n+\t\t\t    NULL_RTX, i2, NULL_RTX, NULL_RTX, NULL_RTX);\n \telse\n \t  distribute_notes (gen_rtx_EXPR_LIST (REG_DEAD, i2dest, NULL_RTX),\n-\t\t\t    NULL_RTX, i3, newi2pat ? i2 : NULL_RTX);\n+\t\t\t    NULL_RTX, i3, newi2pat ? i2 : NULL_RTX,\n+\t\t\t    NULL_RTX, NULL_RTX);\n       }\n \n     if (i1dest_in_i1src)\n@@ -3009,10 +3035,11 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \n \tif (newi2pat && reg_set_p (i1dest, newi2pat))\n \t  distribute_notes (gen_rtx_EXPR_LIST (REG_DEAD, i1dest, NULL_RTX),\n-\t\t\t    NULL_RTX, i2, NULL_RTX);\n+\t\t\t    NULL_RTX, i2, NULL_RTX, NULL_RTX, NULL_RTX);\n \telse\n \t  distribute_notes (gen_rtx_EXPR_LIST (REG_DEAD, i1dest, NULL_RTX),\n-\t\t\t    NULL_RTX, i3, newi2pat ? i2 : NULL_RTX);\n+\t\t\t    NULL_RTX, i3, newi2pat ? i2 : NULL_RTX,\n+\t\t\t    NULL_RTX, NULL_RTX);\n       }\n \n     distribute_links (i3links);\n@@ -11906,11 +11933,16 @@ reg_bitfield_target_p (rtx x, rtx body)\n    as appropriate.  I3 and I2 are the insns resulting from the combination\n    insns including FROM (I2 may be zero).\n \n+   ELIM_I2 and ELIM_I1 are either zero or registers that we know will\n+   not need REG_DEAD notes because they are being substituted for.  This\n+   saves searching in the most common cases.\n+\n    Each note in the list is either ignored or placed on some insns, depending\n    on the type of note.  */\n \n static void\n-distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2)\n+distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2, rtx elim_i2,\n+\t\t  rtx elim_i1)\n {\n   rtx note, next_note;\n   rtx tem;\n@@ -12188,6 +12220,11 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2)\n \t\t   && reg_referenced_p (XEXP (note, 0), PATTERN (i2)))\n \t    place = i2;\n \n+\t  if (place == 0\n+\t      && (rtx_equal_p (XEXP (note, 0), elim_i2)\n+\t\t  || rtx_equal_p (XEXP (note, 0), elim_i1)))\n+\t    break;\n+\n \t  if (place == 0)\n \t    {\n \t      basic_block bb = this_basic_block;\n@@ -12249,7 +12286,8 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2)\n \t\t\t  PATTERN (tem) = pc_rtx;\n \t\t\t  REG_NOTES (tem) = NULL;\n \n-\t\t\t  distribute_notes (old_notes, tem, tem, NULL_RTX);\n+\t\t\t  distribute_notes (old_notes, tem, tem, NULL_RTX,\n+\t\t\t\t\t    NULL_RTX, NULL_RTX);\n \t\t\t  distribute_links (LOG_LINKS (tem));\n \n \t\t\t  SET_INSN_DELETED (tem);\n@@ -12263,7 +12301,8 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2)\n \t\t\t      REG_NOTES (cc0_setter) = NULL;\n \n \t\t\t      distribute_notes (old_notes, cc0_setter,\n-\t\t\t\t\t\tcc0_setter, NULL_RTX);\n+\t\t\t\t\t\tcc0_setter, NULL_RTX,\n+\t\t\t\t\t\tNULL_RTX, NULL_RTX);\n \t\t\t      distribute_links (LOG_LINKS (cc0_setter));\n \n \t\t\t      SET_INSN_DELETED (cc0_setter);\n@@ -12398,7 +12437,7 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2)\n \t\t\t\t= gen_rtx_EXPR_LIST (REG_DEAD, piece, NULL_RTX);\n \n \t\t\t      distribute_notes (new_note, place, place,\n-\t\t\t\t\t\tNULL_RTX);\n+\t\t\t\t\t\tNULL_RTX, NULL_RTX, NULL_RTX);\n \t\t\t    }\n \t\t\t  else if (! refers_to_regno_p (i, i + 1,\n \t\t\t\t\t\t\tPATTERN (place), 0)"}]}