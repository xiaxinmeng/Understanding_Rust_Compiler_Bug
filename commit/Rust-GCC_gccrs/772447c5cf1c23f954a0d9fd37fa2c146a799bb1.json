{"sha": "772447c5cf1c23f954a0d9fd37fa2c146a799bb1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzcyNDQ3YzVjZjFjMjNmOTU0YTBkOWZkMzdmYTJjMTQ2YTc5OWJiMQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-12-30T11:13:24Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-12-30T11:13:24Z"}, "message": "(invert_truthvalue, case TRUTH_XOR_EXPR): New case.\n\n(fold, case TRUTH_XOR_EXPR): New case.\n(fold, case TRUTH_OR_EXPR, TRUTH_AND_EXPR): Check for second operand\nof appropriate value to determine result whether or not first operand\nis a constant.\n\nFrom-SVN: r2997", "tree": {"sha": "a25739b6bc11a0e0fb3e68616a15dd400ac81948", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a25739b6bc11a0e0fb3e68616a15dd400ac81948"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/772447c5cf1c23f954a0d9fd37fa2c146a799bb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/772447c5cf1c23f954a0d9fd37fa2c146a799bb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/772447c5cf1c23f954a0d9fd37fa2c146a799bb1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/772447c5cf1c23f954a0d9fd37fa2c146a799bb1/comments", "author": null, "committer": null, "parents": [{"sha": "f7c8fb3f491c56f5b8b8fd04f9325149cd250ee8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7c8fb3f491c56f5b8b8fd04f9325149cd250ee8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7c8fb3f491c56f5b8b8fd04f9325149cd250ee8"}], "stats": {"total": 43, "additions": 36, "deletions": 7}, "files": [{"sha": "33d02531ec6790ece1956cd62ba14e7b2d5310f8", "filename": "gcc/fold-const.c", "status": "modified", "additions": 36, "deletions": 7, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/772447c5cf1c23f954a0d9fd37fa2c146a799bb1/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/772447c5cf1c23f954a0d9fd37fa2c146a799bb1/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=772447c5cf1c23f954a0d9fd37fa2c146a799bb1", "patch": "@@ -2034,6 +2034,20 @@ invert_truthvalue (arg)\n \t\t    invert_truthvalue (TREE_OPERAND (arg, 0)),\n \t\t    invert_truthvalue (TREE_OPERAND (arg, 1)));\n \n+    case TRUTH_XOR_EXPR:\n+      /* Here we can invert either operand.  We invert the first operand\n+\t unless the second operand is a TRUTH_NOT_EXPR in which case our\n+\t result is the XOR of the first operand with the inside of the\n+\t negation of the second operand.  */\n+\n+      if (TREE_CODE (TREE_OPERAND (arg, 1)) == TRUTH_NOT_EXPR)\n+\treturn build (TRUTH_XOR_EXPR, type, TREE_OPERAND (arg, 0),\n+\t\t      TREE_OPERAND (TREE_OPERAND (arg, 1), 0));\n+      else\n+\treturn build (TRUTH_XOR_EXPR, type,\n+\t\t      invert_truthvalue (TREE_OPERAND (arg, 0)),\n+\t\t      TREE_OPERAND (arg, 1));\n+\n     case TRUTH_ANDIF_EXPR:\n       return build (TRUTH_ORIF_EXPR, type,\n \t\t    invert_truthvalue (TREE_OPERAND (arg, 0)),\n@@ -3697,17 +3711,18 @@ fold (expr)\n \t and their values must be 0 or 1.\n \t (\"true\" is a fixed value perhaps depending on the language.)  */\n       /* If first arg is constant zero, return it.  */\n-      if (TREE_CODE (arg0) == INTEGER_CST && integer_zerop (arg0))\n+      if (integer_zerop (arg0))\n \treturn arg0;\n     case TRUTH_AND_EXPR:\n       /* If either arg is constant true, drop it.  */\n       if (TREE_CODE (arg0) == INTEGER_CST && ! integer_zerop (arg0))\n \treturn non_lvalue (arg1);\n       if (TREE_CODE (arg1) == INTEGER_CST && ! integer_zerop (arg1))\n \treturn non_lvalue (arg0);\n-      /* Both known to be zero => return zero.  */\n-      if (TREE_CODE (arg0) == INTEGER_CST && TREE_CODE (arg1) == INTEGER_CST)\n-\treturn arg0;\n+      /* If second arg is constant zero, result is zero, but first arg\n+\t must be evaluated.  */\n+      if (integer_zerop (arg1))\n+\treturn omit_one_operand (type, arg1, arg0);\n \n     truth_andor:\n       /* Check for the possibility of merging component references.  If our\n@@ -3742,11 +3757,25 @@ fold (expr)\n \treturn non_lvalue (arg1);\n       if (TREE_CODE (arg1) == INTEGER_CST && integer_zerop (arg1))\n \treturn non_lvalue (arg0);\n-      /* Both known to be true => return true.  */\n-      if (TREE_CODE (arg0) == INTEGER_CST && TREE_CODE (arg1) == INTEGER_CST)\n-\treturn arg0;\n+      /* If second arg is constant true, result is true, but we must\n+\t evaluate first arg.  */\n+      if (TREE_CODE (arg1) == INTEGER_CST && ! integer_zerop (arg1))\n+\treturn omit_one_operand (type, arg1, arg0);\n       goto truth_andor;\n \n+    case TRUTH_XOR_EXPR:\n+      /* If either arg is constant zero, drop it.  */\n+      if (integer_zerop (arg0))\n+\treturn non_lvalue (arg1);\n+      if (integer_zerop (arg1))\n+\treturn non_lvalue (arg0);\n+      /* If either arg is constant true, this is a logical inversion.  */\n+      if (integer_onep (arg0))\n+\treturn non_lvalue (invert_truthvalue (arg1));\n+      if (integer_onep (arg1))\n+\treturn non_lvalue (invert_truthvalue (arg0));\n+      break;\n+\n     case EQ_EXPR:\n     case NE_EXPR:\n     case LT_EXPR:"}]}