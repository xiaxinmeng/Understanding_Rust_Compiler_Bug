{"sha": "e90d5e5777bdcc2dde1f51b96bec050653a94eb1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTkwZDVlNTc3N2JkY2MyZGRlMWY1MWI5NmJlYzA1MDY1M2E5NGViMQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-09-09T21:51:14Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-09-09T21:51:14Z"}, "message": "Add port done awhile ago for the ARC cpu.\n\n        * arc/arc.h: New file.\n        * arc/arc.c: New file.\n        * arc/arc.md: New file.\n        * arc/initfini.c: New file.\n        * arc/lib1funcs.asm: New file.\n        * arc/t-arc: New file.\n        * arc/xm-arc.h: New file.\n        * ginclude/va-arc.h: New file.\n        * ginclude/stdarg.h: Include va-arc.h ifdef __arc__.\n        * ginclude/varargs.h: Likewise.\n        * Makefile.in (USER_H): Add va-arc.h.\n        * configure.in (arc-*-elf*): Recognize.\n        * longlong.h: Add ARC support.\nMostly so I can test changes in snapshot scripts.\n\n        * expr.c (clear_storage): Use CONST0_RTX instead of const0_rtx.\n        when clearing non-BLKmode data.\nFixes sparc problem.\n\nFrom-SVN: r15186", "tree": {"sha": "5a377ce22f012835bfff1332b8ffac735f5a87f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5a377ce22f012835bfff1332b8ffac735f5a87f6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e90d5e5777bdcc2dde1f51b96bec050653a94eb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e90d5e5777bdcc2dde1f51b96bec050653a94eb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e90d5e5777bdcc2dde1f51b96bec050653a94eb1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e90d5e5777bdcc2dde1f51b96bec050653a94eb1/comments", "author": null, "committer": null, "parents": [{"sha": "0143027a1fb84a5808f950fdb56ac8e613a01860", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0143027a1fb84a5808f950fdb56ac8e613a01860", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0143027a1fb84a5808f950fdb56ac8e613a01860"}], "stats": {"total": 2212, "additions": 2212, "deletions": 0}, "files": [{"sha": "c9e5411103c6d3362213adbd89ee77c9e09a7a42", "filename": "gcc/config/arc/arc.c", "status": "added", "additions": 2212, "deletions": 0, "changes": 2212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e90d5e5777bdcc2dde1f51b96bec050653a94eb1/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e90d5e5777bdcc2dde1f51b96bec050653a94eb1/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=e90d5e5777bdcc2dde1f51b96bec050653a94eb1", "patch": "@@ -0,0 +1,2212 @@\n+/* Subroutines used for code generation on the ARC cpu.\n+   Copyright (C) 1994, 1995, 1997 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* ??? This is an old port, and is undoubtedly suffering from bit rot.  */\n+\n+#include <stdio.h>\n+#include \"config.h\"\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"insn-flags.h\"\n+#include \"output.h\"\n+#include \"insn-attr.h\"\n+#include \"flags.h\"\n+#include \"expr.h\"\n+#include \"recog.h\"\n+\n+/* Which cpu we're compiling for (NULL(=base), ???).  */\n+char *arc_cpu_string;\n+int arc_cpu_type;\n+\n+/* Name of mangle string to add to symbols to separate code compiled for each\n+   cpu (or NULL).  */\n+char *arc_mangle_cpu;\n+\n+/* Save the operands last given to a compare for use when we\n+   generate a scc or bcc insn.  */\n+rtx arc_compare_op0, arc_compare_op1;\n+\n+/* Name of text, data, and rodata sections, as specified on command line.\n+   Selected by -m{text,data,rodata} flags.  */\n+char *arc_text_string = ARC_DEFAULT_TEXT_SECTION;\n+char *arc_data_string = ARC_DEFAULT_DATA_SECTION;\n+char *arc_rodata_string = ARC_DEFAULT_RODATA_SECTION;\n+\n+/* Name of text, data, and rodata sections used in varasm.c.  */\n+char *arc_text_section;\n+char *arc_data_section;\n+char *arc_rodata_section;\n+\n+/* Array of valid operand punctuation characters.  */\n+char arc_punct_chars[256];\n+\n+/* Variables used by arc_final_prescan_insn to implement conditional\n+   execution.  */\n+static int arc_ccfsm_state;\n+static int arc_ccfsm_current_cc;\n+static rtx arc_ccfsm_target_insn;\n+static int arc_ccfsm_target_label;\n+\n+/* The maximum number of insns skipped which will be conditionalised if\n+   possible.  */\n+#define MAX_INSNS_SKIPPED 3\n+\n+/* A nop is needed between a 4 byte insn that sets the condition codes and\n+   a branch that uses them (the same isn't true for an 8 byte insn that sets\n+   the condition codes).  Set by arc_final_prescan_insn.  Used by\n+   arc_print_operand.  */\n+static int last_insn_set_cc_p;\n+static int current_insn_set_cc_p;\n+static void record_cc_ref ();\n+\n+void arc_init_reg_tables ();\n+\n+/* Called by OVERRIDE_OPTIONS to initialize various things.  */\n+\n+void\n+arc_init (void)\n+{\n+  if (arc_cpu_string == 0\n+      || !strcmp (arc_cpu_string, \"base\"))\n+    {\n+      /* Ensure we have a printable value for the .cpu pseudo-op.  */\n+      arc_cpu_string = \"base\";\n+      arc_cpu_type = 0;\n+      arc_mangle_cpu = NULL;\n+    }\n+  else if (ARC_EXTENSION_CPU (arc_cpu_string))\n+    ; /* nothing to do */\n+  else\n+    {\n+      error (\"bad value (%s) for -mcpu switch\", arc_cpu_string);\n+      arc_cpu_string = \"base\";\n+      arc_cpu_type = 0;\n+      arc_mangle_cpu = NULL;\n+    }\n+\n+  /* Set the pseudo-ops for the various standard sections.  */\n+  arc_text_section = xmalloc (strlen (arc_text_string) + sizeof (ARC_SECTION_FORMAT) + 1);\n+  sprintf (arc_text_section, ARC_SECTION_FORMAT, arc_text_string);\n+  arc_data_section = xmalloc (strlen (arc_data_string) + sizeof (ARC_SECTION_FORMAT) + 1);\n+  sprintf (arc_data_section, ARC_SECTION_FORMAT, arc_data_string);\n+  arc_rodata_section = xmalloc (strlen (arc_rodata_string) + sizeof (ARC_SECTION_FORMAT) + 1);\n+  sprintf (arc_rodata_section, ARC_SECTION_FORMAT, arc_rodata_string);\n+\n+  arc_init_reg_tables ();\n+\n+  /* Initialize array for PRINT_OPERAND_PUNCT_VALID_P.  */\n+  memset (arc_punct_chars, 0, sizeof (arc_punct_chars));\n+  arc_punct_chars['#'] = 1;\n+  arc_punct_chars['*'] = 1;\n+  arc_punct_chars['?'] = 1;\n+  arc_punct_chars['!'] = 1;\n+  arc_punct_chars['~'] = 1;\n+}\n+\f\n+/* The condition codes of the ARC, and the inverse function.  */\n+static char *arc_condition_codes[] =\n+{\n+  \"al\", 0, \"eq\", \"ne\", \"p\", \"n\", \"c\", \"nc\", \"v\", \"nv\",\n+  \"gt\", \"le\", \"ge\", \"lt\", \"hi\", \"ls\", \"pnz\", 0\n+};\n+\n+#define ARC_INVERSE_CONDITION_CODE(X)  ((X) ^ 1)\n+\n+/* Returns the index of the ARC condition code string in\n+   `arc_condition_codes'.  COMPARISON should be an rtx like\n+   `(eq (...) (...))'.  */\n+\n+static int\n+get_arc_condition_code (comparison)\n+     rtx comparison;\n+{\n+  switch (GET_CODE (comparison))\n+    {\n+    case EQ : return 2;\n+    case NE : return 3;\n+    case GT : return 10;\n+    case LE : return 11;\n+    case GE : return 12;\n+    case LT : return 13;\n+    case GTU : return 14;\n+    case LEU : return 15;\n+    case LTU : return 6;\n+    case GEU : return 7;\n+    default : abort ();\n+    }\n+  /*NOTREACHED*/\n+  return (42);\n+}\n+\n+/* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n+   return the mode to be used for the comparison.  */\n+\n+enum machine_mode\n+arc_select_cc_mode (op, x, y)\n+     enum rtx_code op;\n+     rtx x, y;\n+{\n+  switch (op)\n+    {\n+    case EQ :\n+    case NE :\n+      return CCZNmode;\n+    default :\n+      switch (GET_CODE (x))\n+\t{\n+\tcase AND :\n+\tcase IOR :\n+\tcase XOR :\n+\tcase SIGN_EXTEND :\n+\tcase ZERO_EXTEND :\n+\t  return CCZNmode;\n+\tcase ASHIFT :\n+\tcase ASHIFTRT :\n+\tcase LSHIFTRT :\n+\t  return CCZNCmode;\n+\t}\n+    }\n+  return CCmode;\n+}\n+\f\n+/* Vectors to keep interesting information about registers where it can easily\n+   be got.  We use to use the actual mode value as the bit number, but there\n+   is (or may be) more than 32 modes now.  Instead we use two tables: one\n+   indexed by hard register number, and one indexed by mode.  */\n+\n+/* The purpose of arc_mode_class is to shrink the range of modes so that\n+   they all fit (as bit numbers) in a 32 bit word (again).  Each real mode is\n+   mapped into one arc_mode_class mode.  */\n+\n+enum arc_mode_class {\n+  C_MODE,\n+  S_MODE, D_MODE, T_MODE, O_MODE,\n+  SF_MODE, DF_MODE, TF_MODE, OF_MODE\n+};\n+\n+/* Modes for condition codes.  */\n+#define C_MODES (1 << (int) C_MODE)\n+\n+/* Modes for single-word and smaller quantities.  */\n+#define S_MODES ((1 << (int) S_MODE) | (1 << (int) SF_MODE))\n+\n+/* Modes for double-word and smaller quantities.  */\n+#define D_MODES (S_MODES | (1 << (int) D_MODE) | (1 << DF_MODE))\n+\n+/* Modes for quad-word and smaller quantities.  */\n+#define T_MODES (D_MODES | (1 << (int) T_MODE) | (1 << (int) TF_MODE))\n+\n+/* Value is 1 if register/mode pair is acceptable on arc.  */\n+\n+unsigned int arc_hard_regno_mode_ok[] = {\n+  T_MODES, T_MODES, T_MODES, T_MODES, T_MODES, T_MODES, T_MODES, T_MODES,\n+  T_MODES, T_MODES, T_MODES, T_MODES, T_MODES, T_MODES, T_MODES, T_MODES,\n+  T_MODES, T_MODES, T_MODES, T_MODES, T_MODES, T_MODES, T_MODES, D_MODES,\n+  D_MODES, S_MODES, S_MODES, S_MODES, S_MODES, S_MODES, S_MODES, S_MODES,\n+\n+  /* ??? Leave these as S_MODES for now.  */\n+  S_MODES, S_MODES, S_MODES, S_MODES, S_MODES, S_MODES, S_MODES, S_MODES,\n+  S_MODES, S_MODES, S_MODES, S_MODES, S_MODES, S_MODES, S_MODES, S_MODES,\n+  S_MODES, S_MODES, S_MODES, S_MODES, S_MODES, S_MODES, S_MODES, S_MODES,\n+  S_MODES, S_MODES, S_MODES, S_MODES, S_MODES, C_MODES\n+};\n+\n+unsigned int arc_mode_class [NUM_MACHINE_MODES];\n+\n+enum reg_class arc_regno_reg_class[FIRST_PSEUDO_REGISTER];\n+\n+void\n+arc_init_reg_tables ()\n+{\n+  int i;\n+\n+  for (i = 0; i < NUM_MACHINE_MODES; i++)\n+    {\n+      switch (GET_MODE_CLASS (i))\n+\t{\n+\tcase MODE_INT:\n+\tcase MODE_PARTIAL_INT:\n+\tcase MODE_COMPLEX_INT:\n+\t  if (GET_MODE_SIZE (i) <= 4)\n+\t    arc_mode_class[i] = 1 << (int) S_MODE;\n+\t  else if (GET_MODE_SIZE (i) == 8)\n+\t    arc_mode_class[i] = 1 << (int) D_MODE;\n+\t  else if (GET_MODE_SIZE (i) == 16)\n+\t    arc_mode_class[i] = 1 << (int) T_MODE;\n+\t  else if (GET_MODE_SIZE (i) == 32)\n+\t    arc_mode_class[i] = 1 << (int) O_MODE;\n+\t  else \n+\t    arc_mode_class[i] = 0;\n+\t  break;\n+\tcase MODE_FLOAT:\n+\tcase MODE_COMPLEX_FLOAT:\n+\t  if (GET_MODE_SIZE (i) <= 4)\n+\t    arc_mode_class[i] = 1 << (int) SF_MODE;\n+\t  else if (GET_MODE_SIZE (i) == 8)\n+\t    arc_mode_class[i] = 1 << (int) DF_MODE;\n+\t  else if (GET_MODE_SIZE (i) == 16)\n+\t    arc_mode_class[i] = 1 << (int) TF_MODE;\n+\t  else if (GET_MODE_SIZE (i) == 32)\n+\t    arc_mode_class[i] = 1 << (int) OF_MODE;\n+\t  else \n+\t    arc_mode_class[i] = 0;\n+\t  break;\n+\tcase MODE_CC:\n+\tdefault:\n+\t  /* mode_class hasn't been initialized yet for EXTRA_CC_MODES, so\n+\t     we must explicitly check for them here.  */\n+\t  if (i == (int) CCmode || i == (int) CCZNmode || i == (int) CCZNCmode)\n+\t    arc_mode_class[i] = 1 << (int) C_MODE;\n+\t  else\n+\t    arc_mode_class[i] = 0;\n+\t  break;\n+\t}\n+    }\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    {\n+      if (i < 60)\n+\tarc_regno_reg_class[i] = GENERAL_REGS;\n+      else if (i == 60)\n+\tarc_regno_reg_class[i] = LPCOUNT_REG;\n+      else if (i == 61)\n+\tarc_regno_reg_class[i] = NO_REGS /* CC_REG: must be NO_REGS */;\n+      else\n+\tarc_regno_reg_class[i] = NO_REGS;\n+    }\n+}\n+\f\n+/* ARC specific attribute support.\n+\n+   The ARC has these attributes:\n+   interrupt - for interrupt functions\n+*/\n+\n+/* Return nonzero if IDENTIFIER is a valid decl attribute.  */\n+\n+int\n+arc_valid_machine_decl_attribute (type, attributes, identifier, args)\n+     tree type;\n+     tree attributes;\n+     tree identifier;\n+     tree args;\n+{\n+  if (identifier == get_identifier (\"__interrupt__\")\n+      && list_length (args) == 1\n+      && TREE_CODE (TREE_VALUE (args)) == STRING_CST)\n+    {\n+      tree value = TREE_VALUE (args);\n+\n+      if (!strcmp (TREE_STRING_POINTER (value), \"ilink1\")\n+\t   || !strcmp (TREE_STRING_POINTER (value), \"ilink2\"))\n+\treturn 1;\n+    }\n+  return 0;\n+}\n+\n+/* Return zero if TYPE1 and TYPE are incompatible, one if they are compatible,\n+   and two if they are nearly compatible (which causes a warning to be\n+   generated).  */\n+\n+int\n+arc_comp_type_attributes (type1, type2)\n+     tree type1, type2;\n+{\n+  return 1;\n+}\n+\n+/* Set the default attributes for TYPE.  */\n+\n+void\n+arc_set_default_type_attributes (type)\n+     tree type;\n+{\n+}\n+\f\n+/* Acceptable arguments to the call insn.  */\n+\n+int\n+call_address_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (symbolic_operand (op, mode)\n+\t  || (GET_CODE (op) == CONST_INT && LEGITIMATE_CONSTANT_P (op))\n+\t  || (GET_CODE (op) == REG));\n+}\n+\n+int\n+call_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) != MEM)\n+    return 0;\n+  op = XEXP (op, 0);\n+  return call_address_operand (op, mode);\n+}\n+\n+/* Returns 1 if OP is a symbol reference.  */\n+\n+int\n+symbolic_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+    case CONST :\n+      return 1;\n+    default:\n+      return 0;\n+    }\n+}\n+\n+/* Return truth value of statement that OP is a symbolic memory\n+   operand of mode MODE.  */\n+\n+int\n+symbolic_memory_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+  if (GET_CODE (op) != MEM)\n+    return 0;\n+  op = XEXP (op, 0);\n+  return (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == CONST\n+\t  || GET_CODE (op) == LABEL_REF);\n+}\n+\n+/* Return true if OP is a short immediate (shimm) value.  */\n+\n+int\n+short_immediate_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) != CONST_INT)\n+    return 0;\n+  return SMALL_INT (INTVAL (op));\n+}\n+\n+/* Return true if OP will require a long immediate (limm) value.\n+   This is currently only used when calculating length attributes.  */\n+\n+int\n+long_immediate_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case SYMBOL_REF :\n+    case LABEL_REF :\n+    case CONST :\n+      return 1;\n+    case CONST_INT :\n+      return !SMALL_INT (INTVAL (op));\n+    case CONST_DOUBLE :\n+      /* These can happen because large unsigned 32 bit constants are\n+\t represented this way (the multiplication patterns can cause these\n+\t to be generated).  They also occur for SFmode values.  */\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+/* Return true if OP is a MEM that when used as a load or store address will\n+   require an 8 byte insn.\n+   Load and store instructions don't allow the same possibilities but they're\n+   similar enough that this one function will do.\n+   This is currently only used when calculating length attributes.  */\n+\n+int\n+long_immediate_loadstore_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) != MEM)\n+    return 0;\n+\n+  op = XEXP (op, 0);\n+  switch (GET_CODE (op))\n+    {\n+    case SYMBOL_REF :\n+    case LABEL_REF :\n+    case CONST :\n+      return 1;\n+    case CONST_INT :\n+      /* This must be handled as \"st c,[limm]\".  Ditto for load.\n+\t Technically, the assembler could translate some possibilities to\n+\t \"st c,[limm/2 + limm/2]\" if limm/2 will fit in a shimm, but we don't\n+\t assume that it does.  */\n+      return 1;\n+    case CONST_DOUBLE :\n+      /* These can happen because large unsigned 32 bit constants are\n+\t represented this way (the multiplication patterns can cause these\n+\t to be generated).  They also occur for SFmode values.  */\n+      return 1;\n+    case REG :\n+      return 0;\n+    case PLUS :\n+      if (GET_CODE (XEXP (op, 1)) == CONST_INT\n+\t  && !SMALL_INT (INTVAL (XEXP (op, 1))))\n+\treturn 1;\n+      return 0;\n+    }\n+  return 0;\n+}\n+\n+/* Return true if OP is an acceptable argument for a single word\n+   move source.  */\n+\n+int\n+move_src_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case SYMBOL_REF :\n+    case LABEL_REF :\n+    case CONST :\n+      return 1;\n+    case CONST_INT :\n+      return (LARGE_INT (INTVAL (op)));\n+    case CONST_DOUBLE :\n+      /* We can handle DImode integer constants in SImode if the value\n+\t (signed or unsigned) will fit in 32 bits.  This is needed because\n+\t large unsigned 32 bit constants are represented as CONST_DOUBLEs.  */\n+      if (mode == SImode)\n+\treturn arc_double_limm_p (op);\n+      /* We can handle 32 bit floating point constants.  */\n+      if (mode == SFmode)\n+\treturn GET_MODE (op) == SFmode;\n+      return 0;\n+    case REG :\n+      return register_operand (op, mode);\n+    case SUBREG :\n+      /* (subreg (mem ...) ...) can occur here if the inner part was once a\n+\t pseudo-reg and is now a stack slot.  */\n+      if (GET_CODE (SUBREG_REG (op)) == MEM)\n+\treturn address_operand (XEXP (SUBREG_REG (op), 0), mode);\n+      else\n+\treturn register_operand (op, mode);\n+    case MEM :\n+      return address_operand (XEXP (op, 0), mode);\n+    default :\n+      return 0;\n+    }\n+}\n+\n+/* Return true if OP is an acceptable argument for a double word\n+   move source.  */\n+\n+int\n+move_double_src_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case REG :\n+      return register_operand (op, mode);\n+    case SUBREG :\n+      /* (subreg (mem ...) ...) can occur here if the inner part was once a\n+\t pseudo-reg and is now a stack slot.  */\n+      if (GET_CODE (SUBREG_REG (op)) == MEM)\n+\treturn move_double_src_operand (SUBREG_REG (op), mode);\n+      else\n+\treturn register_operand (op, mode);\n+    case MEM :\n+      /* Disallow auto inc/dec for now.  */\n+      if (GET_CODE (XEXP (op, 0)) == PRE_DEC\n+\t  || GET_CODE (XEXP (op, 0)) == PRE_INC)\n+\treturn 0;\n+      return address_operand (XEXP (op, 0), mode);\n+    case CONST_INT :\n+    case CONST_DOUBLE :\n+      return 1;\n+    default :\n+      return 0;\n+    }\n+}\n+\n+/* Return true if OP is an acceptable argument for a move destination.  */\n+\n+int\n+move_dest_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case REG :\n+      return register_operand (op, mode);\n+    case SUBREG :\n+      /* (subreg (mem ...) ...) can occur here if the inner part was once a\n+\t pseudo-reg and is now a stack slot.  */\n+      if (GET_CODE (SUBREG_REG (op)) == MEM)\n+\treturn address_operand (XEXP (SUBREG_REG (op), 0), mode);\n+      else\n+\treturn register_operand (op, mode);\n+    case MEM :\n+      return address_operand (XEXP (op, 0), mode);\n+    default :\n+      return 0;\n+    }\n+}\n+\n+/* Return true if OP is valid load with update operand.  */\n+\n+int\n+load_update_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) != MEM\n+      || GET_MODE (op) != mode)\n+    return 0;\n+  op = XEXP (op, 0);\n+  if (GET_CODE (op) != PLUS\n+      || GET_MODE (op) != Pmode\n+      || !register_operand (XEXP (op, 0), Pmode)\n+      || !nonmemory_operand (XEXP (op, 1), Pmode))\n+    return 0;\n+  return 1;\n+}\n+\n+/* Return true if OP is valid store with update operand.  */\n+\n+int\n+store_update_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) != MEM\n+      || GET_MODE (op) != mode)\n+    return 0;\n+  op = XEXP (op, 0);\n+  if (GET_CODE (op) != PLUS\n+      || GET_MODE (op) != Pmode\n+      || !register_operand (XEXP (op, 0), Pmode)\n+      || !(GET_CODE (XEXP (op, 1)) == CONST_INT\n+\t   && SMALL_INT (INTVAL (XEXP (op, 1)))))\n+    return 0;\n+  return 1;\n+}\n+\n+/* Return true if OP is a non-volatile non-immediate operand.\n+   Volatile memory refs require a special \"cache-bypass\" instruction\n+   and only the standard movXX patterns are set up to handle them.  */\n+\n+int\n+nonvol_nonimm_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == MEM && MEM_VOLATILE_P (op))\n+    return 0;\n+  return nonimmediate_operand (op, mode);\n+}\n+\n+/* Accept integer operands in the range -0x80000000..0x7fffffff.  We have\n+   to check the range carefully since this predicate is used in DImode\n+   contexts.  */\n+\n+int\n+const_sint32_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  /* All allowed constants will fit a CONST_INT.  */\n+  return (GET_CODE (op) == CONST_INT\n+\t  && (INTVAL (op) >= (-0x7fffffff - 1) && INTVAL (op) <= 0x7fffffff));\n+}\n+\n+/* Accept integer operands in the range 0..0xffffffff.  We have to check the\n+   range carefully since this predicate is used in DImode contexts.  Also, we\n+   need some extra crud to make it work when hosted on 64-bit machines.  */\n+\n+int\n+const_uint32_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+#if HOST_BITS_PER_WIDE_INT > 32\n+  /* All allowed constants will fit a CONST_INT.  */\n+  return (GET_CODE (op) == CONST_INT\n+\t  && (INTVAL (op) >= 0 && INTVAL (op) <= 0xffffffffL));\n+#else\n+  return ((GET_CODE (op) == CONST_INT && INTVAL (op) >= 0)\n+\t  || (GET_CODE (op) == CONST_DOUBLE && CONST_DOUBLE_HIGH (op) == 0));\n+#endif\n+}\n+\n+/* Return 1 if OP is a comparison operator valid for the mode of CC.\n+   This allows the use of MATCH_OPERATOR to recognize all the branch insns.\n+\n+   Some insns only set a few bits in the condition code.  So only allow those\n+   comparisons that use the bits that are valid.  */\n+\n+int\n+proper_comparison_operator (op, mode)\n+    rtx op;\n+    enum machine_mode mode;\n+{\n+  enum rtx_code code = GET_CODE (op);\n+\n+  if (GET_RTX_CLASS (code) != '<')\n+    return 0;\n+\n+  if (GET_MODE (XEXP (op, 0)) == CCZNmode)\n+    return (code == EQ || code == NE);\n+  if (GET_MODE (XEXP (op, 0)) == CCZNCmode)\n+    return (code == EQ || code == NE\n+\t    || code == LTU || code == GEU || code == GTU || code == LEU);\n+  return 1;\n+}\n+\f\n+/* Misc. utilities.  */\n+\n+/* X and Y are two things to compare using CODE.  Emit the compare insn and\n+   return the rtx for the cc reg in the proper mode.  */\n+\n+rtx\n+gen_compare_reg (code, x, y)\n+     enum rtx_code code;\n+     rtx x, y;\n+{\n+  enum machine_mode mode = SELECT_CC_MODE (code, x, y);\n+  rtx cc_reg;\n+\n+  cc_reg = gen_rtx (REG, mode, 61);\n+\n+  emit_insn (gen_rtx (SET, VOIDmode, cc_reg,\n+\t\t      gen_rtx (COMPARE, mode, x, y)));\n+\n+  return cc_reg;\n+}\n+\n+/* Return 1 if VALUE, a const_double, will fit in a limm (4 byte number).\n+   We assume the value can be either signed or unsigned.  */\n+\n+int\n+arc_double_limm_p (value)\n+     rtx value;\n+{\n+  HOST_WIDE_INT low, high;\n+\n+  if (GET_CODE (value) != CONST_DOUBLE)\n+    abort ();\n+\n+  low = CONST_DOUBLE_LOW (value);\n+  high = CONST_DOUBLE_HIGH (value);\n+\n+  if (low & 0x80000000)\n+    {\n+      return (((unsigned HOST_WIDE_INT) low <= 0xffffffff && high == 0)\n+\t      || (((low & - (unsigned HOST_WIDE_INT) 0x80000000)\n+\t\t   == - (unsigned HOST_WIDE_INT) 0x80000000)\n+\t\t  && high == -1));\n+    }\n+  else\n+    {\n+      return (unsigned HOST_WIDE_INT) low <= 0x7fffffff && high == 0;\n+    }\n+}\n+\f\n+/* Do any needed setup for a variadic function.  For the ARC, we must\n+   create a register parameter block, and then copy any anonymous arguments\n+   in registers to memory.\n+\n+   CUM has not been updated for the last named argument which has type TYPE\n+   and mode MODE, and we rely on this fact.\n+\n+   We do things a little weird here.  We're supposed to only allocate space\n+   for the anonymous arguments.  However we need to keep the stack eight byte\n+   aligned.  So we round the space up if necessary, and leave it to va-arc.h\n+   to compensate.  */\n+\n+void\n+arc_setup_incoming_varargs (cum, mode, type, pretend_size, no_rtl)\n+     CUMULATIVE_ARGS *cum;\n+     enum machine_mode mode;\n+     tree type;\n+     int *pretend_size;\n+     int no_rtl;\n+{\n+  int first_anon_arg;\n+\n+  /* All BLKmode values are passed by reference.  */\n+  if (mode == BLKmode)\n+    abort ();\n+\n+  /* We must treat `__builtin_va_alist' as an anonymous arg.  */\n+  if (current_function_varargs)\n+    first_anon_arg = *cum;\n+  else\n+    first_anon_arg = *cum + ((GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1)\n+\t\t\t     / UNITS_PER_WORD);\n+\n+  if (first_anon_arg < MAX_ARC_PARM_REGS && !no_rtl)\n+    {\n+      /* Note that first_reg_offset < MAX_ARC_PARM_REGS.  */\n+      int first_reg_offset = first_anon_arg;\n+      /* Size in words to \"pretend\" allocate.  */\n+      int size = MAX_ARC_PARM_REGS - first_reg_offset;\n+      /* Extra slop to keep stack eight byte aligned.  */\n+      int align_slop = size & 1;\n+      rtx regblock;\n+\n+      regblock = gen_rtx (MEM, BLKmode,\n+\t\t\t  plus_constant (arg_pointer_rtx,\n+\t\t\t\t\t FIRST_PARM_OFFSET (0)\n+\t\t\t\t\t + align_slop * UNITS_PER_WORD));\n+      move_block_from_reg (first_reg_offset, regblock,\n+\t\t\t   MAX_ARC_PARM_REGS - first_reg_offset,\n+\t\t\t   ((MAX_ARC_PARM_REGS - first_reg_offset)\n+\t\t\t    * UNITS_PER_WORD));\n+\n+      *pretend_size = ((MAX_ARC_PARM_REGS - first_reg_offset + align_slop)\n+\t\t       * UNITS_PER_WORD);\n+    }\n+}\n+\f\n+/* Cost functions.  */\n+\n+/* Provide the costs of an addressing mode that contains ADDR.\n+   If ADDR is not a valid address, its cost is irrelevant.  */\n+\n+int\n+arc_address_cost (addr)\n+     rtx addr;\n+{\n+  switch (GET_CODE (addr))\n+    {\n+    case REG :\n+      /* This is handled in the macro that calls us.\n+\t It's here for documentation.  */\n+      return 1;\n+\n+    case LABEL_REF :\n+    case SYMBOL_REF :\n+    case CONST :\n+      return 2;\n+\n+    case PLUS :\n+      {\n+\tregister rtx plus0 = XEXP (addr, 0);\n+\tregister rtx plus1 = XEXP (addr, 1);\n+\n+\tif (GET_CODE (plus0) != REG)\n+\t  break;\n+\n+\tswitch (GET_CODE (plus1))\n+\t  {\n+\t  case CONST_INT :\n+\t    return SMALL_INT (plus1) ? 1 : 2;\n+\t  case CONST :\n+\t  case SYMBOL_REF :\n+\t  case LABEL_REF :\n+\t    return 2;\n+\t  default:\n+\t    break;\n+\t  }\n+\tbreak;\n+      }\n+    }\n+\n+  return 4;\n+}\n+\f\n+/* Function prologue/epilogue handlers.  */\n+\n+/* ARC stack frames look like:\n+\n+             Before call                       After call\n+        +-----------------------+       +-----------------------+\n+        |                       |       |                       |\n+   high |  local variables,     |       |  local variables,     |\n+   mem  |  reg save area, etc.  |       |  reg save area, etc.  |\n+        |                       |       |                       |\n+        +-----------------------+       +-----------------------+\n+        |                       |       |                       |\n+        |  arguments on stack.  |       |  arguments on stack.  |\n+        |                       |       |                       |\n+ SP+16->+-----------------------+FP+48->+-----------------------+\n+        | 4 word save area for  |       |  reg parm save area,  |\n+        | return addr, prev %fp |       |  only created for     |    \n+  SP+0->+-----------------------+       |  variable argument    |    \n+                                        |  functions            |    \n+                                 FP+16->+-----------------------+    \n+                                        | 4 word save area for  |    \n+                                        | return addr, prev %fp |    \n+                                  FP+0->+-----------------------+    \n+                                        |                       |    \n+                                        |  local variables      |    \n+                                        |                       |    \n+                                        +-----------------------+    \n+                                        |                       |    \n+                                        |  register save area   |    \n+                                        |                       |    \n+                                        +-----------------------+    \n+                                        |                       |    \n+                                        |  alloca allocations   |    \n+                                        |                       |    \n+                                        +-----------------------+    \n+                                        |                       |    \n+                                        |  arguments on stack   |    \n+                                        |                       |    \n+                                 SP+16->+-----------------------+\n+   low                                  | 4 word save area for  |    \n+   memory                               | return addr, prev %fp |    \n+                                  SP+0->+-----------------------+    \n+\n+Notes:\n+1) The \"reg parm save area\" does not exist for non variable argument fns.\n+   The \"reg parm save area\" can be eliminated completely if we created our\n+   own va-arc.h, but that has tradeoffs as well (so it's not done).  */\n+\n+/* Structure to be filled in by arc_compute_frame_size with register\n+   save masks, and offsets for the current function.  */\n+struct arc_frame_info\n+{\n+  unsigned int total_size;\t/* # bytes that the entire frame takes up.  */\n+  unsigned int extra_size;\t/* # bytes of extra stuff.  */\n+  unsigned int pretend_size;\t/* # bytes we push and pretend caller did.  */\n+  unsigned int args_size;\t/* # bytes that outgoing arguments take up.  */\n+  unsigned int reg_size;\t/* # bytes needed to store regs.  */\n+  unsigned int var_size;\t/* # bytes that variables take up.  */\n+  unsigned int reg_offset;\t/* Offset from new sp to store regs.  */\n+  unsigned int gmask;\t\t/* Mask of saved gp registers.  */\n+  int          initialized;\t/* Nonzero if frame size already calculated.  */\n+};\n+\n+/* Current frame information calculated by arc_compute_frame_size.  */\n+static struct arc_frame_info current_frame_info;\n+\n+/* Zero structure to initialize current_frame_info.  */\n+static struct arc_frame_info zero_frame_info;\n+\n+/* Type of function DECL.\n+\n+   The result is cached.  To reset the cache at the end of a function,\n+   call with DECL = NULL_TREE.  */\n+\n+enum arc_function_type\n+arc_compute_function_type (decl)\n+     tree decl;\n+{\n+  tree a;\n+  /* Cached value.  */\n+  static enum arc_function_type fn_type = ARC_FUNCTION_UNKNOWN;\n+  /* Last function we were called for.  */\n+  static tree last_fn = NULL_TREE;\n+\n+  /* Resetting the cached value?  */\n+  if (decl == NULL_TREE)\n+    {\n+      fn_type = ARC_FUNCTION_UNKNOWN;\n+      last_fn = NULL_TREE;\n+      return fn_type;\n+    }\n+\n+  if (decl == last_fn && fn_type != ARC_FUNCTION_UNKNOWN)\n+    return fn_type;\n+\n+  /* Assume we have a normal function (not an interrupt handler).  */\n+  fn_type = ARC_FUNCTION_NORMAL;\n+\n+  /* Now see if this is an interrupt handler.  */\n+  for (a = DECL_MACHINE_ATTRIBUTES (current_function_decl);\n+       a;\n+       a = TREE_CHAIN (a))\n+    {\n+      tree name = TREE_PURPOSE (a), args = TREE_VALUE (a);\n+\n+      if (name == get_identifier (\"__interrupt__\")\n+\t  && list_length (args) == 1\n+\t  && TREE_CODE (TREE_VALUE (args)) == STRING_CST)\n+\t{\n+\t  tree value = TREE_VALUE (args);\n+\n+\t  if (!strcmp (TREE_STRING_POINTER (value), \"ilink1\"))\n+\t    fn_type = ARC_FUNCTION_ILINK1;\n+\t  else if (!strcmp (TREE_STRING_POINTER (value), \"ilink2\"))\n+\t    fn_type = ARC_FUNCTION_ILINK2;\n+\t  else\n+\t    abort ();\n+\t  break;\n+\t}\n+    }\n+\n+  last_fn = decl;\n+  return fn_type;\n+}\n+\n+#define ILINK1_REGNUM 29\n+#define ILINK2_REGNUM 30\n+#define RETURN_ADDR_REGNUM 31\n+#define FRAME_POINTER_MASK (1 << (FRAME_POINTER_REGNUM))\n+#define RETURN_ADDR_MASK (1 << (RETURN_ADDR_REGNUM))\n+\n+/* Tell prologue and epilogue if register REGNO should be saved / restored.\n+   The return address and frame pointer are treated separately.\n+   Don't consider them here.  */\n+#define MUST_SAVE_REGISTER(regno, interrupt_p) \\\n+((regno) != RETURN_ADDR_REGNUM && (regno) != FRAME_POINTER_REGNUM \\\n+ && (regs_ever_live[regno] && (!call_used_regs[regno] || interrupt_p)))\n+\n+#define MUST_SAVE_RETURN_ADDR (regs_ever_live[RETURN_ADDR_REGNUM])\n+\n+/* Return the bytes needed to compute the frame pointer from the current\n+   stack pointer.\n+\n+   SIZE is the size needed for local variables.  */\n+\n+unsigned int\n+arc_compute_frame_size (size)\n+     int size;\t\t\t/* # of var. bytes allocated.  */\n+{\n+  int regno;\n+  unsigned int total_size, var_size, args_size, pretend_size, extra_size;\n+  unsigned int reg_size, reg_offset;\n+  unsigned int gmask;\n+  enum arc_function_type fn_type;\n+  int interrupt_p;\n+\n+  var_size\t= size;\n+  args_size\t= current_function_outgoing_args_size;\n+  pretend_size\t= current_function_pretend_args_size;\n+  extra_size\t= FIRST_PARM_OFFSET (0);\n+  total_size\t= extra_size + pretend_size + args_size + var_size;\n+  reg_offset\t= FIRST_PARM_OFFSET(0) + current_function_outgoing_args_size;\n+  reg_size\t= 0;\n+  gmask\t\t= 0;\n+\n+  /* See if this is an interrupt handler.  Call used registers must be saved\n+     for them too.  */\n+  fn_type = arc_compute_function_type (current_function_decl);\n+  interrupt_p = ARC_INTERRUPT_P (fn_type);\n+\n+  /* Calculate space needed for registers.\n+     ??? We ignore the extension registers for now.  */\n+\n+  for (regno = 0; regno <= 31; regno++)\n+    {\n+      if (MUST_SAVE_REGISTER (regno, interrupt_p))\n+\t{\n+\t  reg_size += UNITS_PER_WORD;\n+\t  gmask |= 1 << regno;\n+\t}\n+    }\n+\n+  total_size += reg_size;\n+\n+  /* If the only space to allocate is the fp/blink save area this is an\n+     empty frame.  However, if we'll be making a function call we need to\n+     allocate a stack frame for our callee's fp/blink save area.  */\n+  if (total_size == extra_size\n+      && !MUST_SAVE_RETURN_ADDR)\n+    total_size = extra_size = 0;\n+\n+  total_size = ARC_STACK_ALIGN (total_size);\n+\n+  /* Save computed information.  */\n+  current_frame_info.total_size   = total_size;\n+  current_frame_info.extra_size   = extra_size;\n+  current_frame_info.pretend_size = pretend_size;\n+  current_frame_info.var_size     = var_size;\n+  current_frame_info.args_size    = args_size;\n+  current_frame_info.reg_size\t  = reg_size;\n+  current_frame_info.reg_offset\t  = reg_offset;\n+  current_frame_info.gmask\t  = gmask;\n+  current_frame_info.initialized  = reload_completed;\n+\n+  /* Ok, we're done.  */\n+  return total_size;\n+}\n+\f\n+/* Common code to save/restore registers.  */\n+\n+void\n+arc_save_restore (file, base_reg, offset, gmask, op)\n+     FILE *file;\n+     char *base_reg;\n+     unsigned int offset;\n+     unsigned int gmask;\n+     char *op;\n+{\n+  int regno;\n+\n+  if (gmask == 0)\n+    return;\n+\n+  for (regno = 0; regno <= 31; regno++)\n+    {\n+      if ((gmask & (1L << regno)) != 0)\n+\t{\n+\t  fprintf (file, \"\\t%s %s,[%s,%d]\\n\",\n+\t\t     op, reg_names[regno], base_reg, offset);\n+\t  offset += UNITS_PER_WORD;\n+\t}\n+    }\n+}\n+\f\n+/* Set up the stack and frame pointer (if desired) for the function.  */\n+\n+void\n+arc_output_function_prologue (file, size)\n+     FILE *file;\n+     int size;\n+{\n+  char *sp_str = reg_names[STACK_POINTER_REGNUM];\n+  char *fp_str = reg_names[FRAME_POINTER_REGNUM];\n+  unsigned int gmask = current_frame_info.gmask;\n+  enum arc_function_type fn_type = arc_compute_function_type (current_function_decl);\n+\n+  /* If this is an interrupt handler, set up our stack frame.\n+     ??? Optimize later.  */\n+  if (ARC_INTERRUPT_P (fn_type))\n+    {\n+      fprintf (file, \"\\t%s interrupt handler\\n\",\n+\t       ASM_COMMENT_START);\n+      fprintf (file, \"\\tsub %s,%s,16\\n\", sp_str, sp_str);\n+    }\n+\n+  /* This is only for the human reader.  */\n+  fprintf (file, \"\\t%s BEGIN PROLOGUE %s vars= %d, regs= %d, args= %d, extra= %d\\n\",\n+\t   ASM_COMMENT_START, ASM_COMMENT_START,\n+\t   current_frame_info.var_size,\n+\t   current_frame_info.reg_size / 4,\n+\t   current_frame_info.args_size,\n+\t   current_frame_info.extra_size);\n+\n+  size = ARC_STACK_ALIGN (size);\n+  size = (! current_frame_info.initialized\n+\t   ? arc_compute_frame_size (size)\n+\t   : current_frame_info.total_size);\n+\n+  /* These cases shouldn't happen.  Catch them now.  */\n+  if (size == 0 && gmask)\n+    abort ();\n+\n+  /* Allocate space for register argumenets if this is a variadic function.  */\n+  if (current_frame_info.pretend_size != 0)\n+    fprintf (file, \"\\tsub %s,%s,%d\\n\",\n+\t     sp_str, sp_str, current_frame_info.pretend_size);\n+\n+  /* The home-grown ABI says link register is saved first.  */\n+  if (MUST_SAVE_RETURN_ADDR)\n+    fprintf (file, \"\\tst %s,[%s,%d]\\n\",\n+\t     reg_names[RETURN_ADDR_REGNUM], sp_str, UNITS_PER_WORD);\n+\n+  /* Set up the previous frame pointer next (if we need to).  */\n+  if (frame_pointer_needed)\n+    {\n+      fprintf (file, \"\\tst %s,[%s]\\n\", fp_str, sp_str);\n+      fprintf (file, \"\\tmov %s,%s\\n\", fp_str, sp_str);\n+    }\n+\n+  /* ??? We don't handle the case where the saved regs are more than 252\n+     bytes away from sp.  This can be handled by decrementing sp once, saving\n+     the regs, and then decrementing it again.  The epilogue doesn't have this\n+     problem as the `ld' insn takes reg+limm values (though it would be more\n+     efficient to avoid reg+limm).  */\n+\n+  /* Allocate the stack frame.  */\n+  if (size - current_frame_info.pretend_size > 0)\n+    fprintf (file, \"\\tsub %s,%s,%d\\n\",\n+\t     sp_str, sp_str, size - current_frame_info.pretend_size);\n+\n+  /* Save any needed call-saved regs (and call-used if this is an\n+     interrupt handler).  */\n+  arc_save_restore (file, sp_str, current_frame_info.reg_offset,\n+\t\t    /* The zeroing of these two bits is unnecessary,\n+\t\t       but leave this in for clarity.  */\n+\t\t    gmask & ~(FRAME_POINTER_MASK | RETURN_ADDR_MASK),\n+\t\t    \"st\");\n+\n+  fprintf (file, \"\\t%s END PROLOGUE\\n\", ASM_COMMENT_START);\n+}\n+\f\n+/* Do any necessary cleanup after a function to restore stack, frame,\n+   and regs. */\n+\n+void\n+arc_output_function_epilogue (file, size)\n+     FILE *file;\n+     int size;\n+{\n+  rtx epilogue_delay = current_function_epilogue_delay_list;\n+  int noepilogue = FALSE;\n+  enum arc_function_type fn_type = arc_compute_function_type (current_function_decl);\n+\n+  /* This is only for the human reader.  */\n+  fprintf (file, \"\\t%s EPILOGUE\\n\", ASM_COMMENT_START);\n+\n+  size = ARC_STACK_ALIGN (size);\n+  size = (!current_frame_info.initialized\n+\t   ? arc_compute_frame_size (size)\n+\t   : current_frame_info.total_size);\n+\n+  if (size == 0 && epilogue_delay == 0)\n+    {\n+      rtx insn = get_last_insn ();\n+\n+      /* If the last insn was a BARRIER, we don't have to write any code\n+\t because a jump (aka return) was put there.  */\n+      if (GET_CODE (insn) == NOTE)\n+\tinsn = prev_nonnote_insn (insn);\n+      if (insn && GET_CODE (insn) == BARRIER)\n+\tnoepilogue = TRUE;\n+    }\n+\n+  if (!noepilogue)\n+    {\n+      unsigned int pretend_size = current_frame_info.pretend_size;\n+      unsigned int frame_size = size - pretend_size;\n+      int restored, fp_restored_p;\n+      int can_trust_sp_p = !current_function_calls_alloca;\n+      char *sp_str = reg_names[STACK_POINTER_REGNUM];\n+      char *fp_str = reg_names[FRAME_POINTER_REGNUM];\n+\n+      /* ??? There are lots of optimizations that can be done here.\n+\t EG: Use fp to restore regs if it's closer.\n+\t Maybe in time we'll do them all.  For now, always restore regs from\n+\t sp, but don't restore sp if we don't have to.  */\n+\n+      if (!can_trust_sp_p)\n+\t{\n+\t  if (!frame_pointer_needed)\n+\t    abort ();\n+\t  fprintf (file,\"\\tsub %s,%s,%d\\t\\t%s sp not trusted here\\n\",\n+\t\t   sp_str, fp_str, frame_size, ASM_COMMENT_START);\n+\t}\n+\n+      /* Restore any saved registers.  */\n+      arc_save_restore (file, sp_str, current_frame_info.reg_offset,\n+\t\t\t/* The zeroing of these two bits is unnecessary,\n+\t\t\t   but leave this in for clarity.  */\n+\t\t\tcurrent_frame_info.gmask & ~(FRAME_POINTER_MASK | RETURN_ADDR_MASK),\n+\t\t\t\"ld\");\n+\n+      if (MUST_SAVE_RETURN_ADDR)\n+\tfprintf (file, \"\\tld %s,[%s,%d]\\n\",\n+\t\t reg_names[RETURN_ADDR_REGNUM],\n+\t\t frame_pointer_needed ? fp_str : sp_str,\n+\t\t UNITS_PER_WORD + (frame_pointer_needed ? 0 : frame_size));\n+\n+      /* Keep track of how much of the stack pointer we've restored.\n+\t It makes the following a lot more readable.  */\n+      restored = 0;\n+      fp_restored_p = 0;\n+\n+      /* We try to emit the epilogue delay slot insn right after the load\n+\t of the return address register so that it can execute with the\n+\t stack intact.  Secondly, loads are delayed.  */\n+      /* ??? If stack intactness is important, always emit now.  */\n+      if (MUST_SAVE_RETURN_ADDR && epilogue_delay != NULL_RTX)\n+\t{\n+\t  final_scan_insn (XEXP (epilogue_delay, 0), file, 1, -2, 1);\n+\t  epilogue_delay = NULL_RTX;\n+\t}\n+\n+      if (frame_pointer_needed)\n+\t{\n+\t  /* Try to restore the frame pointer in the delay slot.  We can't,\n+\t     however, if any of these is true.  */\n+\t  if (epilogue_delay != NULL_RTX\n+\t      || !SMALL_INT (frame_size)\n+\t      || pretend_size\n+\t      || ARC_INTERRUPT_P (fn_type))\n+\t    {\n+\t      /* Note that we restore fp and sp here!  */\n+\t      fprintf (file, \"\\tld.a %s,[%s,%d]\\n\", fp_str, sp_str, frame_size);\n+\t      restored += frame_size;\n+\t      fp_restored_p = 1;\n+\t    }\n+\t}\n+      else if (!SMALL_INT (size /* frame_size + pretend_size */)\n+\t       || ARC_INTERRUPT_P (fn_type))\n+\t{\n+\t  fprintf (file, \"\\tadd %s,%s,%d\\n\", sp_str, sp_str, frame_size);\n+\t  restored += frame_size;\n+\t}\n+\n+      /* These must be done before the return insn because the delay slot\n+\t does the final stack restore.  */\n+      if (ARC_INTERRUPT_P (fn_type))\n+\t{\n+\t  if (epilogue_delay)\n+\t    {\n+\t      final_scan_insn (XEXP (epilogue_delay, 0), file, 1, -2, 1);\n+\t    }\n+\t}\n+\n+      /* Emit the return instruction.  */\n+      {\n+\tstatic int regs[4] = {\n+\t  0, RETURN_ADDR_REGNUM, ILINK1_REGNUM, ILINK2_REGNUM\n+\t};\n+\tfprintf (file, \"\\tj.d %s\\n\", reg_names[regs[fn_type]]);\n+      }\n+\n+      /* If the only register saved is the return address, we need a\n+\t nop, unless we have an instruction to put into it.  Otherwise\n+\t we don't since reloading multiple registers doesn't reference\n+\t the register being loaded.  */\n+\n+      if (ARC_INTERRUPT_P (fn_type))\n+\tfprintf (file, \"\\tadd %s,%s,16\\n\", sp_str, sp_str);\n+      else if (epilogue_delay != NULL_RTX)\n+\t{\n+\t  if (frame_pointer_needed && !fp_restored_p)\n+\t    abort ();\n+\t  if (restored < size)\n+\t    abort ();\n+\t  final_scan_insn (XEXP (epilogue_delay, 0), file, 1, -2, 1);\n+\t}\n+      else if (frame_pointer_needed && !fp_restored_p)\n+\t{\n+\t  if (!SMALL_INT (frame_size))\n+\t    abort ();\n+\t  /* Note that we restore fp and sp here!  */\n+\t  fprintf (file, \"\\tld.a %s,[%s,%d]\\n\", fp_str, sp_str, frame_size);\n+\t}\n+      else if (restored < size)\n+\t{\n+\t  if (!SMALL_INT (size - restored))\n+\t    abort ();\n+\t  fprintf (file, \"\\tadd %s,%s,%d\\n\",\n+\t\t   sp_str, sp_str, size - restored);\n+\t}\n+      else\n+\tfprintf (file, \"\\tnop\\n\");\n+    }\n+\n+  /* Reset state info for each function.  */\n+  current_frame_info = zero_frame_info;\n+  arc_compute_function_type (NULL_TREE);\n+}\n+\f\n+/* Define the number of delay slots needed for the function epilogue.\n+\n+   Interrupt handlers can't have any epilogue delay slots (it's always needed\n+   for something else, I think).  For normal functions, we have to worry about\n+   using call-saved regs as they'll be restored before the delay slot insn.\n+   Functions with non-empty frames already have enough choices for the epilogue\n+   delay slot so for now we only consider functions with empty frames.  */\n+\n+int\n+arc_delay_slots_for_epilogue ()\n+{\n+  if (arc_compute_function_type (current_function_decl) != ARC_FUNCTION_NORMAL)\n+    return 0;\n+  if (!current_frame_info.initialized)\n+    (void) arc_compute_frame_size (get_frame_size ());\n+  if (current_frame_info.total_size == 0)\n+    return 1;\n+  return 0;\n+}\n+\n+/* Return true if TRIAL is a valid insn for the epilogue delay slot.\n+   Any single length instruction which doesn't reference the stack or frame\n+   pointer or any call-saved register is OK.  SLOT will always be 0.  */\n+\n+int\n+arc_eligible_for_epilogue_delay (trial, slot)\n+     rtx trial;\n+     int slot;\n+{\n+  if (slot != 0)\n+    abort ();\n+\n+  if (get_attr_length (trial) == 1\n+      /* If registers where saved, presumably there's more than enough\n+\t possibilities for the delay slot.  The alternative is something\n+\t more complicated (of course, if we expanded the epilogue as rtl\n+\t this problem would go away).  */\n+      /* ??? Note that this will always be true since only functions with\n+\t empty frames have epilogue delay slots.  See\n+\t arc_delay_slots_for_epilogue.  */\n+      && current_frame_info.gmask == 0\n+      && ! reg_mentioned_p (stack_pointer_rtx, PATTERN (trial))\n+      && ! reg_mentioned_p (frame_pointer_rtx, PATTERN (trial)))\n+    return 1;\n+  return 0;\n+}\n+\f\n+/* PIC */\n+\n+/* Set up PIC-specific rtl.  This should not cause any insns\n+   to be emitted.  */\n+\n+void\n+arc_initialize_pic ()\n+{\n+  /* nothing to do */\n+}\n+\n+/* Emit special PIC prologues and epilogues.  */\n+\n+void\n+arc_finalize_pic ()\n+{\n+  /* nothing to do */\n+}\n+\f\n+/* Return true if OP is a shift operator.  */\n+\n+int\n+shift_operator (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case ASHIFTRT:\n+    case LSHIFTRT:\n+    case ASHIFT:\n+      return 1;\n+    default:\n+      return 0;\n+    }\n+}\n+\n+/* Output the assembler code for doing a shift.\n+   We go to a bit of trouble to generate efficient code as the ARC only has\n+   single bit shifts.  This is taken from the h8300 port.  We only have one\n+   mode of shifting and can't access individual bytes like the h8300 can, so\n+   this is greatly simplified (at the expense of not generating hyper-\n+   efficient code).\n+\n+   This function is not used if the variable shift insns are present.  */\n+\n+/* ??? We assume the output operand is the same as operand 1.\n+   This can be optimized (deleted) in the case of 1 bit shifts.  */\n+/* ??? We use the loop register here.  We don't use it elsewhere (yet) and\n+   using it here will give us a chance to play with it.  */\n+\n+char *\n+output_shift (operands)\n+     rtx *operands;\n+{\n+  static int loopend_lab;\n+  rtx shift = operands[3];\n+  enum machine_mode mode = GET_MODE (shift);\n+  enum rtx_code code = GET_CODE (shift);\n+  char *shift_one;\n+\n+  if (mode != SImode)\n+    abort ();\n+\n+  switch (code)\n+    {\n+    case ASHIFT:   shift_one = \"asl %0,%0\"; break;\n+    case ASHIFTRT: shift_one = \"asr %0,%0\"; break;\n+    case LSHIFTRT: shift_one = \"lsr %0,%0\"; break;\n+    default:       abort ();\n+    }\n+\n+  if (GET_CODE (operands[2]) != CONST_INT)\n+    {\n+      if (optimize)\n+\toutput_asm_insn (\"mov lp_count,%2\", operands);\n+      else\n+\toutput_asm_insn (\"mov %4,%2\", operands);\n+      goto shiftloop;\n+    }\n+  else\n+    {\n+      int n = INTVAL (operands[2]);\n+\n+      /* If the count is negative, make it 0.  */\n+      if (n < 0)\n+\tn = 0;\n+      /* If the count is too big, truncate it.\n+         ANSI says shifts of GET_MODE_BITSIZE are undefined - we choose to\n+\t do the intuitive thing.  */\n+      else if (n > GET_MODE_BITSIZE (mode))\n+\tn = GET_MODE_BITSIZE (mode);\n+\n+      /* First see if we can do them inline.  */\n+      if (n <= 8)\n+\t{\n+\t  while (--n >= 0)\n+\t    output_asm_insn (shift_one, operands);\n+\t}\n+      /* See if we can use a rotate/and.  */\n+      else if (n == BITS_PER_WORD - 1)\n+\t{\n+\t  switch (code)\n+\t    {\n+\t    case ASHIFT :\n+\t      output_asm_insn (\"and %0,%0,1\\n\\tror %0,%0\", operands);\n+\t      break;\n+\t    case ASHIFTRT :\n+\t      /* The ARC doesn't have a rol insn.  Use something else.  */\n+\t      output_asm_insn (\"asl.f 0,%0\\n\\tsbc %0,0,0\", operands);\n+\t      break;\n+\t    case LSHIFTRT :\n+\t      /* The ARC doesn't have a rol insn.  Use something else.  */\n+\t      output_asm_insn (\"asl.f 0,%0\\n\\tadc %0,0,0\", operands);\n+\t      break;\n+\t    }\n+\t}\n+      /* Must loop.  */\n+      else\n+\t{\n+\t  char buf[100];\n+\n+\t  if (optimize)\n+\t    output_asm_insn (\"mov lp_count,%c2\", operands);\n+\t  else\n+\t    output_asm_insn (\"mov %4,%c2\", operands);\n+\tshiftloop:\n+\t  if (optimize)\n+\t    {\n+\t      if (flag_pic)\n+\t\tsprintf (\"lr %%4,[status]\\n\\tadd %%4,%%4,6\\t%s single insn loop start\",\n+\t\t\t ASM_COMMENT_START);\n+\t      else\n+\t\tsprintf (buf, \"mov %%4,%%%%st(1f)\\t%s (single insn loop start) >> 2\",\n+\t\t\t ASM_COMMENT_START);\n+\t      output_asm_insn (buf, operands);\n+\t      output_asm_insn (\"sr %4,[lp_start]\", operands);\n+\t      output_asm_insn (\"add %4,%4,1\", operands);\n+\t      output_asm_insn (\"sr %4,[lp_end]\", operands);\n+\t      output_asm_insn (\"nop\\n\\tnop\", operands);\n+\t      if (flag_pic)\n+\t\tasm_fprintf (asm_out_file, \"\\t%s single insn loop\\n\",\n+\t\t\t     ASM_COMMENT_START);\n+\t      else\n+\t\tasm_fprintf (asm_out_file, \"1:\\t%s single insn loop\\n\",\n+\t\t\t     ASM_COMMENT_START);\n+\t      output_asm_insn (shift_one, operands);\n+\t    }\n+\t  else \n+\t    {\n+\t      asm_fprintf (asm_out_file, \"1:\\t%s begin shift loop\\n\",\n+\t\t\t   ASM_COMMENT_START);\n+\t      output_asm_insn (\"sub.f %4,%4,1\", operands);\n+\t      output_asm_insn (\"nop\", operands);\n+\t      output_asm_insn (\"bn.nd 2f\", operands);\n+\t      output_asm_insn (shift_one, operands);\n+\t      output_asm_insn (\"b.nd 1b\", operands);\n+\t      asm_fprintf (asm_out_file, \"2:\\t%s end shift loop\\n\",\n+\t\t\t   ASM_COMMENT_START);\n+\t    }\n+\t}\n+    }\n+\n+  return \"\";\n+}\n+\f\n+/* Nested function support.  */\n+\n+/* Emit RTL insns to initialize the variable parts of a trampoline.\n+   FNADDR is an RTX for the address of the function's pure code.\n+   CXT is an RTX for the static chain value for the function.  */\n+\n+void\n+arc_initialize_trampoline (tramp, fnaddr, cxt)\n+     rtx tramp, fnaddr, cxt;\n+{\n+}\n+\f\n+/* Set the cpu type and print out other fancy things,\n+   at the top of the file.  */\n+\n+void\n+arc_asm_file_start (file)\n+     FILE *file;\n+{\n+  fprintf (file, \"\\t.cpu %s\\n\", arc_cpu_string);\n+}\n+\f\n+/* Print operand X (an rtx) in assembler syntax to file FILE.\n+   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n+   For `%' followed by punctuation, CODE is the punctuation and X is null.  */\n+\n+void\n+arc_print_operand (file, x, code)\n+     FILE *file;\n+     rtx x;\n+     int code;\n+{\n+  switch (code)\n+    {\n+    case '#' :\n+      /* Conditional brances.  For now these are equivalent.  */\n+    case '*' :\n+      /* Unconditional branches.  Output the appropriate delay slot suffix.  */\n+      if (!final_sequence || XVECLEN (final_sequence, 0) == 1)\n+\t{\n+\t  /* There's nothing in the delay slot.  */\n+\t  fputs (\".nd\", file);\n+\t}\n+      else\n+\t{\n+\t  rtx jump = XVECEXP (final_sequence, 0, 0);\n+\t  rtx delay = XVECEXP (final_sequence, 0, 1);\n+\t  if (INSN_ANNULLED_BRANCH_P (jump))\n+\t    fputs (INSN_FROM_TARGET_P (delay) ? \".jd\" : \".nd\", file);\n+\t  else\n+\t    fputs (\".d\", file);\n+\t}\n+      return;\n+    case '?' : /* with leading \".\" */\n+    case '!' : /* without leading \".\" */\n+      /* This insn can be conditionally executed.  See if the ccfsm machinery\n+\t says it should be conditionalized.  */\n+      if (arc_ccfsm_state == 3 || arc_ccfsm_state == 4)\n+\t{\n+\t  /* Is this insn in a delay slot?  */\n+\t  if (final_sequence && XVECLEN (final_sequence, 0) == 2)\n+\t    {\n+\t      rtx insn = XVECEXP (final_sequence, 0, 1);\n+\n+\t      /* If the insn is annulled and is from the target path, we need\n+\t\t to inverse the condition test.  */\n+\t      if (INSN_ANNULLED_BRANCH_P (insn))\n+\t\t{\n+\t\t  if (INSN_FROM_TARGET_P (insn))\n+\t\t    fprintf (file, \"%s%s\",\n+\t\t\t     code == '?' ? \".\" : \"\",\n+\t\t\t     arc_condition_codes[ARC_INVERSE_CONDITION_CODE (arc_ccfsm_current_cc)]);\n+\t\t  else\n+\t\t    fprintf (file, \"%s%s\",\n+\t\t\t     code == '?' ? \".\" : \"\",\n+\t\t\t     arc_condition_codes[arc_ccfsm_current_cc]);\n+\t\t}\n+\t      else\n+\t\t/* This insn is executed for either path, so don't\n+\t\t   conditionalize it at all.  */\n+\t\t; /* nothing to do */\n+\t    }\n+\t  else\n+\t    {\n+\t      /* This insn isn't in a delay slot.  */\n+\t      fprintf (file, \"%s%s\",\n+\t\t       code == '?' ? \".\" : \"\",\n+\t\t       arc_condition_codes[arc_ccfsm_current_cc]);\n+\t    }\n+\t}\n+      return;\n+    case '~' :\n+      /* Output a nop if we're between a set of the condition codes,\n+\t and a conditional branch.  */\n+      if (last_insn_set_cc_p)\n+\tfputs (\"nop\\n\\t\", file);\n+      return;\n+    case 'd' :\n+      fputs (arc_condition_codes[get_arc_condition_code (x)], file);\n+      return;\n+    case 'D' :\n+      fputs (arc_condition_codes[ARC_INVERSE_CONDITION_CODE\n+\t\t\t\t (get_arc_condition_code (x))],\n+\t     file);\n+      return;\n+    case 'R' :\n+      /* Write second word of DImode or DFmode reference,\n+\t register or memory.  */\n+      if (GET_CODE (x) == REG)\n+\tfputs (reg_names[REGNO (x)+1], file);\n+      else if (GET_CODE (x) == MEM)\n+\t{\n+\t  fputc ('[', file);\n+\t  /* Handle possible auto-increment.  Since it is pre-increment and\n+\t     we have already done it, we can just use an offset of four.  */\n+\t  /* ??? This is taken from rs6000.c I think.  I don't think it is\n+\t     currently necessary, but keep it around.  */\n+\t  if (GET_CODE (XEXP (x, 0)) == PRE_INC\n+\t      || GET_CODE (XEXP (x, 0)) == PRE_DEC)\n+\t    output_address (plus_constant (XEXP (XEXP (x, 0), 0), 4));\n+\t  else\n+\t    output_address (plus_constant (XEXP (x, 0), 4));\n+\t  fputc (']', file);\n+\t}\n+      else\n+\toutput_operand_lossage (\"invalid operand to %R code\");\n+      return;\n+    case 'S' :\n+      if ((GET_CODE (x) == SYMBOL_REF && SYMBOL_REF_FLAG (x))\n+\t  || GET_CODE (x) == LABEL_REF)\n+\t{\n+\t  fprintf (file, \"%%st(\");\n+\t  output_addr_const (file, x);\n+\t  fprintf (file, \")\");\n+\t  return;\n+\t}\n+      break;\n+    case 'H' :\n+    case 'L' :\n+      if (GET_CODE (x) == REG)\n+\t{\n+\t  /* L = least significant word, H = most significant word */\n+\t  if ((TARGET_BIG_ENDIAN != 0) ^ (code == 'L'))\n+\t    fputs (reg_names[REGNO (x)], file);\n+\t  else\n+\t    fputs (reg_names[REGNO (x)+1], file);\n+\t}\n+      else if (GET_CODE (x) == CONST_INT\n+\t       || GET_CODE (x) == CONST_DOUBLE)\n+\t{\n+\t  rtx first, second;\n+\n+\t  split_double (x, &first, &second);\n+\t  fprintf (file, \"0x%08lx\",\n+\t\t   code == 'L' ? INTVAL (first) : INTVAL (second));\n+\t}\n+      else\n+\toutput_operand_lossage (\"invalid operand to %H/%L code\");\n+      return;\n+    case 'A' :\n+      {\n+\tREAL_VALUE_TYPE d;\n+\tchar str[30];\n+\n+\tif (GET_CODE (x) != CONST_DOUBLE\n+\t    || GET_MODE_CLASS (GET_MODE (x)) != MODE_FLOAT)\n+\t  abort ();\n+\tREAL_VALUE_FROM_CONST_DOUBLE (d, x);\n+\tREAL_VALUE_TO_DECIMAL (d, \"%.20e\", str);\n+\tfprintf (file, \"%s\", str);\n+\treturn;\n+      }\n+    case 'U' :\n+      /* Output a load/store with update indicator if appropriate.  */\n+      if (GET_CODE (x) == MEM)\n+\t{\n+\t  if (GET_CODE (XEXP (x, 0)) == PRE_INC\n+\t      || GET_CODE (XEXP (x, 0)) == PRE_DEC)\n+\t    fputs (\".a\", file);\n+\t}\n+      else\n+\toutput_operand_lossage (\"invalid operand to %U code\");\n+      return;\n+    case 'V' :\n+      /* Output cache bypass indicator for a load/store insn.  Volatile memory\n+\t refs are defined to use the cache bypass mechanism.  */\n+      if (GET_CODE (x) == MEM)\n+\t{\n+\t  if (MEM_VOLATILE_P (x))\n+\t    fputs (\".di\", file);\n+\t}\n+      else\n+\toutput_operand_lossage (\"invalid operand to %V code\");\n+      return;\n+    case 0 :\n+      /* Do nothing special.  */\n+      break;\n+    default :\n+      /* Unknown flag.  */\n+      output_operand_lossage (\"invalid operand output code\");\n+    }\n+\n+  switch (GET_CODE (x))\n+    {\n+    case REG :\n+      fputs (reg_names[REGNO (x)], file);\n+      break;\n+    case MEM :\n+      fputc ('[', file);\n+      if (GET_CODE (XEXP (x, 0)) == PRE_INC)\n+\toutput_address (plus_constant (XEXP (XEXP (x, 0), 0),\n+\t\t\t\t       GET_MODE_SIZE (GET_MODE (x))));\n+      else if (GET_CODE (XEXP (x, 0)) == PRE_DEC)\n+\toutput_address (plus_constant (XEXP (XEXP (x, 0), 0),\n+\t\t\t\t       - GET_MODE_SIZE (GET_MODE (x))));\n+      else\n+\toutput_address (XEXP (x, 0));\n+      fputc (']', file);\n+      break;\n+    case CONST_DOUBLE :\n+      /* We handle SFmode constants here as output_addr_const doesn't.  */\n+      if (GET_MODE (x) == SFmode)\n+\t{\n+\t  REAL_VALUE_TYPE d;\n+\t  long l;\n+\n+\t  REAL_VALUE_FROM_CONST_DOUBLE (d, x);\n+\t  REAL_VALUE_TO_TARGET_SINGLE (d, l);\n+\t  fprintf (file, \"0x%08lx\", l);\n+\t  break;\n+\t}\n+      /* Fall through.  Let output_addr_const deal with it.  */\n+    default :\n+      output_addr_const (file, x);\n+      break;\n+    }\n+}\n+\n+/* Print a memory address as an operand to reference that memory location.  */\n+\n+void\n+arc_print_operand_address (file, addr)\n+     FILE *file;\n+     rtx addr;\n+{\n+  register rtx base, index = 0;\n+  int offset = 0;\n+\n+  switch (GET_CODE (addr))\n+    {\n+    case REG :\n+      fputs (reg_names[REGNO (addr)], file);\n+      break;\n+    case SYMBOL_REF :\n+      if (/*???*/ 0 && SYMBOL_REF_FLAG (addr))\n+\t{\n+\t  fprintf (file, \"%%st(\");\n+\t  output_addr_const (file, addr);\n+\t  fprintf (file, \")\");\n+\t}\n+      else\n+\toutput_addr_const (file, addr);\n+      break;\n+    case PLUS :\n+      if (GET_CODE (XEXP (addr, 0)) == CONST_INT)\n+\toffset = INTVAL (XEXP (addr, 0)), base = XEXP (addr, 1);\n+      else if (GET_CODE (XEXP (addr, 1)) == CONST_INT)\n+\toffset = INTVAL (XEXP (addr, 1)), base = XEXP (addr, 0);\n+      else\n+\tbase = XEXP (addr, 0), index = XEXP (addr, 1);\n+      if (GET_CODE (base) != REG)\n+\tabort ();\n+      fputs (reg_names[REGNO (base)], file);\n+      if (index == 0)\n+\t{\n+\t  if (offset != 0)\n+\t    fprintf (file, \",%d\", offset);\n+\t}\n+      else if (GET_CODE (index) == REG)\n+\tfprintf (file, \",%s\", reg_names[REGNO (index)]);\n+      else if (GET_CODE (index) == SYMBOL_REF)\n+\tfputc (',', file), output_addr_const (file, index);\n+      else\n+\tabort ();\n+      break;\n+    case PRE_INC :\n+    case PRE_DEC :\n+      /* We shouldn't get here as we've lost the mode of the memory object\n+\t (which says how much to inc/dec by.  */\n+      abort ();\n+      break;\n+    default :\n+      output_addr_const (file, addr);\n+      break;\n+    }\n+}\n+\n+/* Update compare/branch separation marker.  */\n+\n+static void\n+record_cc_ref (insn)\n+     rtx insn;\n+{\n+  last_insn_set_cc_p = current_insn_set_cc_p;\n+\n+  switch (get_attr_cond (insn))\n+    {\n+    case COND_SET :\n+    case COND_SET_ZN :\n+    case COND_SET_ZNC :\n+      if (get_attr_length (insn) == 1)\n+\tcurrent_insn_set_cc_p = 1;\n+      else\n+\tcurrent_insn_set_cc_p = 0;\n+      break;\n+    default :\n+      current_insn_set_cc_p = 0;\n+      break;\n+    }\n+}\n+\f\n+/* Conditional execution support.\n+\n+   This is based on the ARM port but for now is much simpler.\n+\n+   A finite state machine takes care of noticing whether or not instructions\n+   can be conditionally executed, and thus decrease execution time and code\n+   size by deleting branch instructions.  The fsm is controlled by\n+   final_prescan_insn, and controls the actions of PRINT_OPERAND.  The patterns\n+   in the .md file for the branch insns also have a hand in this.  */\n+\n+/* The state of the fsm controlling condition codes are:\n+   0: normal, do nothing special\n+   1: don't output this insn\n+   2: don't output this insn\n+   3: make insns conditional\n+   4: make insns conditional\n+\n+   State transitions (state->state by whom, under what condition):\n+   0 -> 1 final_prescan_insn, if insn is conditional branch\n+   0 -> 2 final_prescan_insn, if the `target' is an unconditional branch\n+   1 -> 3 branch patterns, after having not output the conditional branch\n+   2 -> 4 branch patterns, after having not output the conditional branch\n+   3 -> 0 ASM_OUTPUT_INTERNAL_LABEL, if the `target' label is reached\n+          (the target label has CODE_LABEL_NUMBER equal to\n+\t  arc_ccfsm_target_label).\n+   4 -> 0 final_prescan_insn, if `target' unconditional branch is reached\n+\n+   If the jump clobbers the conditions then we use states 2 and 4.\n+\n+   A similar thing can be done with conditional return insns.\n+\n+   We also handle separating branches from sets of the condition code.\n+   This is done here because knowledge of the ccfsm state is required,\n+   we may not be outputting the branch.  */\n+\n+void\n+arc_final_prescan_insn (insn, opvec, noperands)\n+     rtx insn;\n+     rtx *opvec;\n+     int noperands;\n+{\n+  /* BODY will hold the body of INSN.  */\n+  register rtx body = PATTERN (insn);\n+\n+  /* This will be 1 if trying to repeat the trick (ie: do the `else' part of\n+     an if/then/else), and things need to be reversed.  */\n+  int reverse = 0;\n+\n+  /* If we start with a return insn, we only succeed if we find another one. */\n+  int seeking_return = 0;\n+  \n+  /* START_INSN will hold the insn from where we start looking.  This is the\n+     first insn after the following code_label if REVERSE is true.  */\n+  rtx start_insn = insn;\n+\n+  /* Update compare/branch separation marker.  */\n+  record_cc_ref (insn);\n+\n+  /* Allow -mdebug-ccfsm to turn this off so we can see how well it does.\n+     We can't do this in macro FINAL_PRESCAN_INSN because it's called from\n+     final_scan_insn which has `optimize' as a local.  */\n+  if (optimize < 2 || TARGET_NO_COND_EXEC)\n+    return;\n+\n+  /* If in state 4, check if the target branch is reached, in order to\n+     change back to state 0.  */\n+  if (arc_ccfsm_state == 4)\n+    {\n+      if (insn == arc_ccfsm_target_insn)\n+\t{\n+\t  arc_ccfsm_target_insn = NULL;\n+\t  arc_ccfsm_state = 0;\n+\t}\n+      return;\n+    }\n+\n+  /* If in state 3, it is possible to repeat the trick, if this insn is an\n+     unconditional branch to a label, and immediately following this branch\n+     is the previous target label which is only used once, and the label this\n+     branch jumps to is not too far off.  Or in other words \"we've done the\n+     `then' part, see if we can do the `else' part.\"  */\n+  if (arc_ccfsm_state == 3)\n+    {\n+      if (simplejump_p (insn))\n+\t{\n+\t  start_insn = next_nonnote_insn (start_insn);\n+\t  if (GET_CODE (start_insn) == BARRIER)\n+\t    {\n+\t      /* ??? Isn't this always a barrier?  */\n+\t      start_insn = next_nonnote_insn (start_insn);\n+\t    }\n+\t  if (GET_CODE (start_insn) == CODE_LABEL\n+\t      && CODE_LABEL_NUMBER (start_insn) == arc_ccfsm_target_label\n+\t      && LABEL_NUSES (start_insn) == 1)\n+\t    reverse = TRUE;\n+\t  else\n+\t    return;\n+\t}\n+      else if (GET_CODE (body) == RETURN)\n+        {\n+\t  start_insn = next_nonnote_insn (start_insn);\n+\t  if (GET_CODE (start_insn) == BARRIER)\n+\t    start_insn = next_nonnote_insn (start_insn);\n+\t  if (GET_CODE (start_insn) == CODE_LABEL\n+\t      && CODE_LABEL_NUMBER (start_insn) == arc_ccfsm_target_label\n+\t      && LABEL_NUSES (start_insn) == 1)\n+\t    {\n+\t      reverse = TRUE;\n+\t      seeking_return = 1;\n+\t    }\n+\t  else\n+\t    return;\n+        }\n+      else\n+\treturn;\n+    }\n+\n+  if (GET_CODE (insn) != JUMP_INSN)\n+    return;\n+\n+  /* This jump might be paralled with a clobber of the condition codes,\n+     the jump should always come first.  */\n+  if (GET_CODE (body) == PARALLEL && XVECLEN (body, 0) > 0)\n+    body = XVECEXP (body, 0, 0);\n+\n+  if (reverse\n+      || (GET_CODE (body) == SET && GET_CODE (SET_DEST (body)) == PC\n+\t  && GET_CODE (SET_SRC (body)) == IF_THEN_ELSE))\n+    {\n+      int insns_skipped = 0, fail = FALSE, succeed = FALSE;\n+      /* Flag which part of the IF_THEN_ELSE is the LABEL_REF.  */\n+      int then_not_else = TRUE;\n+      /* Nonzero if next insn must be the target label.  */\n+      int next_must_be_target_label_p;\n+      rtx this_insn = start_insn, label = 0;\n+\n+      /* Register the insn jumped to.  */\n+      if (reverse)\n+        {\n+\t  if (!seeking_return)\n+\t    label = XEXP (SET_SRC (body), 0);\n+        }\n+      else if (GET_CODE (XEXP (SET_SRC (body), 1)) == LABEL_REF)\n+\tlabel = XEXP (XEXP (SET_SRC (body), 1), 0);\n+      else if (GET_CODE (XEXP (SET_SRC (body), 2)) == LABEL_REF)\n+\t{\n+\t  label = XEXP (XEXP (SET_SRC (body), 2), 0);\n+\t  then_not_else = FALSE;\n+\t}\n+      else if (GET_CODE (XEXP (SET_SRC (body), 1)) == RETURN)\n+\tseeking_return = 1;\n+      else if (GET_CODE (XEXP (SET_SRC (body), 2)) == RETURN)\n+        {\n+\t  seeking_return = 1;\n+\t  then_not_else = FALSE;\n+        }\n+      else\n+\tabort ();\n+\n+      /* See how many insns this branch skips, and what kind of insns.  If all\n+\t insns are okay, and the label or unconditional branch to the same\n+\t label is not too far away, succeed.  */\n+      for (insns_skipped = 0, next_must_be_target_label_p = FALSE;\n+\t   !fail && !succeed && insns_skipped < MAX_INSNS_SKIPPED;\n+\t   insns_skipped++)\n+\t{\n+\t  rtx scanbody;\n+\n+\t  this_insn = next_nonnote_insn (this_insn);\n+\t  if (!this_insn)\n+\t    break;\n+\n+\t  if (next_must_be_target_label_p)\n+\t    {\n+\t      if (GET_CODE (this_insn) == BARRIER)\n+\t\tcontinue;\n+\t      if (GET_CODE (this_insn) == CODE_LABEL\n+\t\t  && this_insn == label)\n+\t\t{\n+\t\t  arc_ccfsm_state = 1;\n+\t\t  succeed = TRUE;\n+\t\t}\n+\t      else\n+\t\tfail = TRUE;\n+\t      break;\n+\t    }\n+\n+\t  scanbody = PATTERN (this_insn);\n+\n+\t  switch (GET_CODE (this_insn))\n+\t    {\n+\t    case CODE_LABEL:\n+\t      /* Succeed if it is the target label, otherwise fail since\n+\t\t control falls in from somewhere else.  */\n+\t      if (this_insn == label)\n+\t\t{\n+\t\t  arc_ccfsm_state = 1;\n+\t\t  succeed = TRUE;\n+\t\t}\n+\t      else\n+\t\tfail = TRUE;\n+\t      break;\n+\n+\t    case BARRIER:\n+\t      /* Succeed if the following insn is the target label.\n+\t\t Otherwise fail.  \n+\t\t If return insns are used then the last insn in a function \n+\t\t will be a barrier. */\n+\t      next_must_be_target_label_p = TRUE;\n+\t      break;\n+\n+\t    case CALL_INSN:\n+\t      /* Can handle a call insn if there are no insns after it.\n+\t\t IE: The next \"insn\" is the target label.  We don't have to\n+\t\t worry about delay slots as such insns are SEQUENCE's inside\n+\t\t INSN's.  ??? It is possible to handle such insns though.  */\n+\t      if (get_attr_cond (this_insn) == COND_CANUSE)\n+\t\tnext_must_be_target_label_p = TRUE;\n+\t      else\n+\t\tfail = TRUE;\n+\t      break;\n+\n+\t    case JUMP_INSN:\n+      \t      /* If this is an unconditional branch to the same label, succeed.\n+\t\t If it is to another label, do nothing.  If it is conditional,\n+\t\t fail.  */\n+\t      /* ??? Probably, the test for the SET and the PC are unnecessary. */\n+\n+\t      if (GET_CODE (scanbody) == SET\n+\t\t  && GET_CODE (SET_DEST (scanbody)) == PC)\n+\t\t{\n+\t\t  if (GET_CODE (SET_SRC (scanbody)) == LABEL_REF\n+\t\t      && XEXP (SET_SRC (scanbody), 0) == label && !reverse)\n+\t\t    {\n+\t\t      arc_ccfsm_state = 2;\n+\t\t      succeed = TRUE;\n+\t\t    }\n+\t\t  else if (GET_CODE (SET_SRC (scanbody)) == IF_THEN_ELSE)\n+\t\t    fail = TRUE;\n+\t\t}\n+\t      else if (GET_CODE (scanbody) == RETURN\n+\t\t       && seeking_return)\n+\t        {\n+\t\t  arc_ccfsm_state = 2;\n+\t\t  succeed = TRUE;\n+\t        }\n+\t      else if (GET_CODE (scanbody) == PARALLEL)\n+\t        {\n+\t\t  if (get_attr_cond (this_insn) != COND_CANUSE)\n+\t\t    fail = TRUE;\n+\t\t}\n+\t      break;\n+\n+\t    case INSN:\n+\t      /* We can only do this with insns that can use the condition\n+\t\t codes (and don't set them).  */\n+\t      if (GET_CODE (scanbody) == SET\n+\t\t  || GET_CODE (scanbody) == PARALLEL)\n+\t\t{\n+\t\t  if (get_attr_cond (this_insn) != COND_CANUSE)\n+\t\t    fail = TRUE;\n+\t\t}\n+\t      /* We can't handle other insns like sequences.  */\n+\t      else\n+\t\tfail = TRUE;\n+\t      break;\n+\n+\t    default:\n+\t      break;\n+\t    }\n+\t}\n+\n+      if (succeed)\n+\t{\n+\t  if ((!seeking_return) && (arc_ccfsm_state == 1 || reverse))\n+\t    arc_ccfsm_target_label = CODE_LABEL_NUMBER (label);\n+\t  else if (seeking_return || arc_ccfsm_state == 2)\n+\t    {\n+\t      while (this_insn && GET_CODE (PATTERN (this_insn)) == USE)\n+\t        {\n+\t\t  this_insn = next_nonnote_insn (this_insn);\n+\t\t  if (this_insn && (GET_CODE (this_insn) == BARRIER\n+\t\t\t\t    || GET_CODE (this_insn) == CODE_LABEL))\n+\t\t    abort ();\n+\t        }\n+\t      if (!this_insn)\n+\t        {\n+\t\t  /* Oh dear! we ran off the end, give up.  */\n+\t\t  insn_extract (insn);\n+\t\t  arc_ccfsm_state = 0;\n+\t\t  arc_ccfsm_target_insn = NULL;\n+\t\t  return;\n+\t        }\n+\t      arc_ccfsm_target_insn = this_insn;\n+\t    }\n+\t  else\n+\t    abort ();\n+\n+\t  /* If REVERSE is true, ARM_CURRENT_CC needs to be inverted from\n+\t     what it was.  */\n+\t  if (!reverse)\n+\t    arc_ccfsm_current_cc = get_arc_condition_code (XEXP (SET_SRC (body),\n+\t\t\t\t\t\t\t\t 0));\n+\n+\t  if (reverse || then_not_else)\n+\t    arc_ccfsm_current_cc = ARC_INVERSE_CONDITION_CODE (arc_ccfsm_current_cc);\n+\t}\n+\n+      /* Restore recog_operand.  Getting the attributes of other insns can\n+\t destroy this array, but final.c assumes that it remains intact\n+\t accross this call; since the insn has been recognized already we\n+\t call insn_extract direct. */\n+      insn_extract (insn);\n+    }\n+}\n+\n+/* Record that we are currently outputting label NUM with prefix PREFIX.\n+   It it's the label we're looking for, reset the ccfsm machinery.\n+\n+   Called from ASM_OUTPUT_INTERNAL_LABEL.  */\n+\n+void\n+arc_ccfsm_at_label (prefix, num)\n+     char *prefix;\n+     int num;\n+{\n+  if (arc_ccfsm_state == 3 && arc_ccfsm_target_label == num\n+      && !strcmp (prefix, \"L\"))\n+    {\n+      arc_ccfsm_state = 0;\n+      arc_ccfsm_target_insn = NULL_RTX;\n+    }\n+}\n+\n+/* See if the current insn, which is a conditional branch, is to be\n+   deleted.  */\n+\n+int\n+arc_ccfsm_branch_deleted_p ()\n+{\n+  if (arc_ccfsm_state == 1 || arc_ccfsm_state == 2)\n+    return 1;\n+  return 0;\n+}\n+\n+/* Record a branch isn't output because subsequent insns can be\n+   conditionalized.  */\n+\n+void\n+arc_ccfsm_record_branch_deleted ()\n+{\n+  /* Indicate we're conditionalizing insns now.  */\n+  arc_ccfsm_state += 2;\n+\n+  /* If the next insn is a subroutine call, we still need a nop between the\n+     cc setter and user.  We need to undo the effect of calling record_cc_ref\n+     for the just deleted branch.  */\n+  current_insn_set_cc_p = last_insn_set_cc_p;\n+}"}]}