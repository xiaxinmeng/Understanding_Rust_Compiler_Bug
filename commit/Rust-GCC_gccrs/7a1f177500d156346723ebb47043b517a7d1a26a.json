{"sha": "7a1f177500d156346723ebb47043b517a7d1a26a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2ExZjE3NzUwMGQxNTYzNDY3MjNlYmI0NzA0M2I1MTdhN2QxYTI2YQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-01-04T09:18:25Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-01-04T09:18:25Z"}, "message": "[multiple changes]\n\n2013-01-04  Robert Dewar  <dewar@adacore.com>\n\n\t* table.adb: Minor reformatting.\n\n2013-01-04  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch10.adb (Check_Redundant_Withs): A with_clause that does\n\tnot come from source does not generate a warning for redundant\n\twith_clauses.\n\n2013-01-04  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* aspects.adb, aspects.ads: Add Aspect_Global to all relevant tables.\n\t* par-prag.adb: Add pragma Global to the list of pragmas that\n\tdo not need special processing by the parser.\n\t* sem_ch13.adb (Analyze_Aspect_Specifications): Convert aspect\n\tGlobal into a pragma without any form of legality checks. The\n\twork is done by Analyze_Pragma. The aspect and pragma are both\n\tmarked as needing delayed processing.  Insert the corresponding\n\tpragma of aspect Abstract_State in the visible declarations of the\n\trelated package.\n\t(Check_Aspect_At_Freeze_Point): Aspect Global\n\tdoes not need processing even though it is marked as delayed.\n\tAlphabetize the list on aspect names.\n\t* sem_prag.adb: Add a value for pragma Global in table Sig_Flags.\n\t(Analyze_Pragma): Add ??? comment about the grammar of pragma\n\tAbstract_State.  Move the error location from the pragma to the\n\tstate to improve the quality of error placement.  Add legality\n\tchecks for pragma Global.\n\t* snames.ads-tmpl Add the following specially recognized names\n\n2013-01-04  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* sem_ch3.adb: Fix minor typo.\n\n2013-01-04  Ed Schonberg  <schonberg@adacore.com>\n\n\t* par-ch13.adb (Aspect_Specifications_Present): In Strict mode,\n\taccept an aspect name followed by a comma, indicating a defaulted\n\tboolean aspect.\n\nFrom-SVN: r194890", "tree": {"sha": "97b58b4dab4215938b711cd0bb1c8982d80d7643", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/97b58b4dab4215938b711cd0bb1c8982d80d7643"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a1f177500d156346723ebb47043b517a7d1a26a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a1f177500d156346723ebb47043b517a7d1a26a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a1f177500d156346723ebb47043b517a7d1a26a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a1f177500d156346723ebb47043b517a7d1a26a/comments", "author": null, "committer": null, "parents": [{"sha": "2a328c94e12b2ff0e72f6b9831bf7591ecd2fd91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a328c94e12b2ff0e72f6b9831bf7591ecd2fd91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a328c94e12b2ff0e72f6b9831bf7591ecd2fd91"}], "stats": {"total": 502, "additions": 480, "deletions": 22}, "files": [{"sha": "0b0bdfde51a1a2440c9b7157c42ce1fea17a9c65", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a1f177500d156346723ebb47043b517a7d1a26a/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a1f177500d156346723ebb47043b517a7d1a26a/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=7a1f177500d156346723ebb47043b517a7d1a26a", "patch": "@@ -1,3 +1,44 @@\n+2013-01-04  Robert Dewar  <dewar@adacore.com>\n+\n+\t* table.adb: Minor reformatting.\n+\n+2013-01-04  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch10.adb (Check_Redundant_Withs): A with_clause that does\n+\tnot come from source does not generate a warning for redundant\n+\twith_clauses.\n+\n+2013-01-04  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* aspects.adb, aspects.ads: Add Aspect_Global to all relevant tables.\n+\t* par-prag.adb: Add pragma Global to the list of pragmas that\n+\tdo not need special processing by the parser.\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications): Convert aspect\n+\tGlobal into a pragma without any form of legality checks. The\n+\twork is done by Analyze_Pragma. The aspect and pragma are both\n+\tmarked as needing delayed processing.  Insert the corresponding\n+\tpragma of aspect Abstract_State in the visible declarations of the\n+\trelated package.\n+\t(Check_Aspect_At_Freeze_Point): Aspect Global\n+\tdoes not need processing even though it is marked as delayed.\n+\tAlphabetize the list on aspect names.\n+\t* sem_prag.adb: Add a value for pragma Global in table Sig_Flags.\n+\t(Analyze_Pragma): Add ??? comment about the grammar of pragma\n+\tAbstract_State.  Move the error location from the pragma to the\n+\tstate to improve the quality of error placement.  Add legality\n+\tchecks for pragma Global.\n+\t* snames.ads-tmpl Add the following specially recognized names\n+\n+2013-01-04  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* sem_ch3.adb: Fix minor typo.\n+\n+2013-01-04  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* par-ch13.adb (Aspect_Specifications_Present): In Strict mode,\n+\taccept an aspect name followed by a comma, indicating a defaulted\n+\tboolean aspect.\n+\n 2013-01-04  Joel Brobecker  <brobecker@adacore.com brobecker>\n \n \t* gnat_ugn.texi: Document procedure to codesign GDB on Darwin."}, {"sha": "523deaaa0ac509497b348b5a042afe1c042c52d1", "filename": "gcc/ada/aspects.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a1f177500d156346723ebb47043b517a7d1a26a/gcc%2Fada%2Faspects.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a1f177500d156346723ebb47043b517a7d1a26a/gcc%2Fada%2Faspects.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.adb?ref=7a1f177500d156346723ebb47043b517a7d1a26a", "patch": "@@ -269,6 +269,7 @@ package body Aspects is\n     Aspect_External_Name                => Aspect_External_Name,\n     Aspect_External_Tag                 => Aspect_External_Tag,\n     Aspect_Favor_Top_Level              => Aspect_Favor_Top_Level,\n+    Aspect_Global                       => Aspect_Global,\n     Aspect_Implicit_Dereference         => Aspect_Implicit_Dereference,\n     Aspect_Import                       => Aspect_Import,\n     Aspect_Independent                  => Aspect_Independent,"}, {"sha": "94c3c617827d6ed9be61f3343ced07eea2d1acaa", "filename": "gcc/ada/aspects.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a1f177500d156346723ebb47043b517a7d1a26a/gcc%2Fada%2Faspects.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a1f177500d156346723ebb47043b517a7d1a26a/gcc%2Fada%2Faspects.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.ads?ref=7a1f177500d156346723ebb47043b517a7d1a26a", "patch": "@@ -94,6 +94,7 @@ package Aspects is\n       Aspect_Dynamic_Predicate,\n       Aspect_External_Name,\n       Aspect_External_Tag,\n+      Aspect_Global,                        -- GNAT\n       Aspect_Implicit_Dereference,\n       Aspect_Input,\n       Aspect_Interrupt_Priority,\n@@ -231,6 +232,7 @@ package Aspects is\n                              Aspect_Dimension                => True,\n                              Aspect_Dimension_System         => True,\n                              Aspect_Favor_Top_Level          => True,\n+                             Aspect_Global                   => True,\n                              Aspect_Inline_Always            => True,\n                              Aspect_Lock_Free                => True,\n                              Aspect_Object_Size              => True,\n@@ -327,6 +329,7 @@ package Aspects is\n                         Aspect_Dynamic_Predicate       => Expression,\n                         Aspect_External_Name           => Expression,\n                         Aspect_External_Tag            => Expression,\n+                        Aspect_Global                  => Expression,\n                         Aspect_Implicit_Dereference    => Name,\n                         Aspect_Input                   => Name,\n                         Aspect_Interrupt_Priority      => Expression,\n@@ -404,6 +407,7 @@ package Aspects is\n      Aspect_External_Tag                 => Name_External_Tag,\n      Aspect_Export                       => Name_Export,\n      Aspect_Favor_Top_Level              => Name_Favor_Top_Level,\n+     Aspect_Global                       => Name_Global,\n      Aspect_Implicit_Dereference         => Name_Implicit_Dereference,\n      Aspect_Import                       => Name_Import,\n      Aspect_Independent                  => Name_Independent,"}, {"sha": "4d63d0e64a48b8753d84fe9e5d0f8f43eb0caaed", "filename": "gcc/ada/par-ch13.adb", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a1f177500d156346723ebb47043b517a7d1a26a/gcc%2Fada%2Fpar-ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a1f177500d156346723ebb47043b517a7d1a26a/gcc%2Fada%2Fpar-ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch13.adb?ref=7a1f177500d156346723ebb47043b517a7d1a26a", "patch": "@@ -105,6 +105,13 @@ package body Ch13 is\n             if Token = Tok_Arrow then\n                Result := True;\n \n+            --  The identifier may be the name of a boolean aspect with a\n+            --  defaulted True value. Further checks when analyzing aspect\n+            --  specification.\n+\n+            elsif Token = Tok_Comma then\n+               Result := True;\n+\n             elsif Token = Tok_Apostrophe then\n                Scan; -- past apostrophe\n "}, {"sha": "313567b6bd8add7a16df09131898d74ab6b8279e", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a1f177500d156346723ebb47043b517a7d1a26a/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a1f177500d156346723ebb47043b517a7d1a26a/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=7a1f177500d156346723ebb47043b517a7d1a26a", "patch": "@@ -1156,6 +1156,7 @@ begin\n            Pragma_Fast_Math                      |\n            Pragma_Finalize_Storage_Only          |\n            Pragma_Float_Representation           |\n+           Pragma_Global                         |\n            Pragma_Ident                          |\n            Pragma_Implementation_Defined         |\n            Pragma_Implemented                    |"}, {"sha": "2e04d60c50f7eb80d884f7fde6386c879c46dd2f", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a1f177500d156346723ebb47043b517a7d1a26a/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a1f177500d156346723ebb47043b517a7d1a26a/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=7a1f177500d156346723ebb47043b517a7d1a26a", "patch": "@@ -481,8 +481,15 @@ package body Sem_Ch10 is\n                --  In this case, the second with clause is redundant since\n                --  the pragma applies only to the first \"with Pack;\".\n \n+               --  Note that we only consider with_clauses that comes from\n+               --  source. In the case of renamings used as prefixes of names\n+               --  in with_clauses, we generate a with_clause for the prefix,\n+               --  which we do not treat as implicit because it is needed for\n+               --  visibility analysis, but is also not redundant.\n+\n                elsif Nkind (Cont_Item) = N_With_Clause\n                  and then not Implicit_With (Cont_Item)\n+                 and then Comes_From_Source (Cont_Item)\n                  and then not Limited_Present (Cont_Item)\n                  and then Cont_Item /= Clause\n                  and then Entity (Name (Cont_Item)) = Nam_Ent"}, {"sha": "f2bcfa84adb8ea945da3359577775f6f2941070a", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 50, "deletions": 15, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a1f177500d156346723ebb47043b517a7d1a26a/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a1f177500d156346723ebb47043b517a7d1a26a/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=7a1f177500d156346723ebb47043b517a7d1a26a", "patch": "@@ -1436,7 +1436,7 @@ package body Sem_Ch13 is\n                --  Case 2d : Aspects that correspond to a pragma with one\n                --  argument.\n \n-               when Aspect_Abstract_State        =>\n+               when Aspect_Abstract_State =>\n                   Aitem :=\n                     Make_Pragma (Loc,\n                       Pragma_Identifier            =>\n@@ -1447,7 +1447,20 @@ package body Sem_Ch13 is\n \n                   Delay_Required := False;\n \n-               when Aspect_Relative_Deadline     =>\n+               --  Aspect Global must be delayed because it can mention names\n+               --  and benefit from the forward visibility rules applicable to\n+               --  aspects of subprograms.\n+\n+               when Aspect_Global =>\n+                  Aitem :=\n+                    Make_Pragma (Loc,\n+                      Pragma_Identifier            =>\n+                        Make_Identifier (Sloc (Id), Name_Global),\n+                      Pragma_Argument_Associations => New_List (\n+                        Make_Pragma_Argument_Association (Loc,\n+                          Expression => Relocate_Node (Expr))));\n+\n+               when Aspect_Relative_Deadline =>\n                   Aitem :=\n                     Make_Pragma (Loc,\n                       Pragma_Argument_Associations => New_List (\n@@ -1950,6 +1963,20 @@ package body Sem_Ch13 is\n \n                      Prepend (Aitem, Declarations (N));\n \n+                  --  Aspect Abstract_State produces implicit declarations for\n+                  --  all state abstraction entities it defines. To emulate\n+                  --  this behavior, insert the pragma at the start of the\n+                  --  visible declarations of the related package.\n+\n+                  elsif Nam = Name_Abstract_State\n+                    and then Nkind (N) = N_Package_Declaration\n+                  then\n+                     if No (Visible_Declarations (Specification (N))) then\n+                        Set_Visible_Declarations (Specification (N), New_List);\n+                     end if;\n+\n+                     Prepend (Aitem, Visible_Declarations (Specification (N)));\n+\n                   else\n                      if No (Pragmas_After (Aux)) then\n                         Set_Pragmas_After (Aux, New_List);\n@@ -6887,32 +6914,32 @@ package body Sem_Ch13 is\n               Library_Unit_Aspects =>\n             T := Standard_Boolean;\n \n+         --  Aspects corresponding to attribute definition clauses\n+\n+         when Aspect_Address =>\n+            T := RTE (RE_Address);\n+\n          when Aspect_Attach_Handler =>\n             T := RTE (RE_Interrupt_ID);\n \n+         when Aspect_Bit_Order | Aspect_Scalar_Storage_Order =>\n+            T := RTE (RE_Bit_Order);\n+\n          when Aspect_Convention =>\n             return;\n \n-         --  Default_Value is resolved with the type entity in question\n-\n-         when Aspect_Default_Value =>\n-            T := Entity (ASN);\n+         when Aspect_CPU =>\n+            T := RTE (RE_CPU_Range);\n \n          --  Default_Component_Value is resolved with the component type\n \n          when Aspect_Default_Component_Value =>\n             T := Component_Type (Entity (ASN));\n \n-         --  Aspects corresponding to attribute definition clauses\n-\n-         when Aspect_Address =>\n-            T := RTE (RE_Address);\n-\n-         when Aspect_Bit_Order | Aspect_Scalar_Storage_Order =>\n-            T := RTE (RE_Bit_Order);\n+         --  Default_Value is resolved with the type entity in question\n \n-         when Aspect_CPU =>\n-            T := RTE (RE_CPU_Range);\n+         when Aspect_Default_Value =>\n+            T := Entity (ASN);\n \n          when Aspect_Dispatching_Domain =>\n             T := RTE (RE_Dispatching_Domain);\n@@ -6923,6 +6950,14 @@ package body Sem_Ch13 is\n          when Aspect_External_Name =>\n             T := Standard_String;\n \n+         --  Global is a delayed aspect because it may reference names that\n+         --  have not been declared yet. There is no action to be taken with\n+         --  respect to the aspect itself as the reference checking is done on\n+         --  the corresponding pragma.\n+\n+         when Aspect_Global =>\n+            return;\n+\n          when Aspect_Link_Name =>\n             T := Standard_String;\n "}, {"sha": "ead2e64e89d9e69efa34eb575347476186f150cb", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a1f177500d156346723ebb47043b517a7d1a26a/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a1f177500d156346723ebb47043b517a7d1a26a/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=7a1f177500d156346723ebb47043b517a7d1a26a", "patch": "@@ -10362,7 +10362,7 @@ package body Sem_Ch3 is\n          Set_Cloned_Subtype (Full, Full_Base);\n       end if;\n \n-      --  It is unsafe to share to bounds of a scalar type, because the Itype\n+      --  It is unsafe to share the bounds of a scalar type, because the Itype\n       --  is elaborated on demand, and if a bound is non-static then different\n       --  orders of elaboration in different units will lead to different\n       --  external symbols."}, {"sha": "2595b753ea6739e6db10a18c7b02e7b01aea8c81", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 362, "deletions": 1, "changes": 363, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a1f177500d156346723ebb47043b517a7d1a26a/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a1f177500d156346723ebb47043b517a7d1a26a/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=7a1f177500d156346723ebb47043b517a7d1a26a", "patch": "@@ -789,6 +789,8 @@ package body Sem_Prag is\n       procedure S14_Pragma;\n       --  Called for all pragmas defined for formal verification to check that\n       --  the S14_Extensions flag is set.\n+      --  This name needs fixing ??? There is no such thing as an\n+      --  \"S14_Extensions\" flag ???\n \n       function Is_Before_First_Decl\n         (Pragma_Node : Node_Id;\n@@ -6644,6 +6646,8 @@ package body Sem_Prag is\n          -- Abstract_State --\n          --------------------\n \n+         --  ??? no formal grammar available yet\n+\n          when Pragma_Abstract_State => Abstract_State : declare\n             Pack_Id : Entity_Id;\n \n@@ -6824,7 +6828,7 @@ package body Sem_Prag is\n                --  Any other attempt to declare a state is erroneous\n \n                else\n-                  Error_Msg_N (\"malformed abstract state declaration\", N);\n+                  Error_Msg_N (\"malformed abstract state declaration\", State);\n                end if;\n \n                --  Do not generate a state abstraction entity if it was not\n@@ -9946,6 +9950,362 @@ package body Sem_Prag is\n             end if;\n          end Float_Representation;\n \n+         ------------\n+         -- Global --\n+         ------------\n+\n+         --  ??? no formal grammar pragma available yet\n+\n+         when Pragma_Global => Global : declare\n+            Subp_Id : Entity_Id;\n+\n+            Seen : Elist_Id := No_Elist;\n+            --  A list containing the entities of all the items processed so\n+            --  far. It plays a role in detecting distinct entities.\n+\n+            --  Flags used to verify the consistency of modes\n+\n+            Contract_Seen : Boolean := False;\n+            In_Out_Seen   : Boolean := False;\n+            Input_Seen    : Boolean := False;\n+            Output_Seen   : Boolean := False;\n+\n+            procedure Analyze_Global_List\n+              (List        : Node_Id;\n+               Global_Mode : Name_Id := Name_Input);\n+            --  Verify the legality of a single global list declaration.\n+            --  Global_Mode denotes the current mode in effect.\n+\n+            -------------------------\n+            -- Analyze_Global_List --\n+            -------------------------\n+\n+            procedure Analyze_Global_List\n+              (List        : Node_Id;\n+               Global_Mode : Name_Id := Name_Input)\n+            is\n+               procedure Analyze_Global_Item\n+                 (Item        : Node_Id;\n+                  Global_Mode : Name_Id);\n+               --  Verify the legality of a single global item declaration.\n+               --  Global_Mode denotes the current mode in effect.\n+\n+               procedure Check_Duplicate_Mode\n+                 (Mode   : Node_Id;\n+                  Status : in out Boolean);\n+               --  Flag Status denotes whether a particular mode has been seen\n+               --  while processing a global list. This routine verifies that\n+               --  Mode is not a duplicate mode and sets the flag Status.\n+\n+               procedure Check_Mode_Restriction_In_Function (Mode : Node_Id);\n+               --  Mode denotes either In_Out or Output. Depending on the kind\n+               --  of the related subprogram, emit an error if those two modes\n+               --  apply to a function.\n+\n+               -------------------------\n+               -- Analyze_Global_Item --\n+               -------------------------\n+\n+               procedure Analyze_Global_Item\n+                 (Item        : Node_Id;\n+                  Global_Mode : Name_Id)\n+               is\n+                  function Is_Duplicate_Item (Id : Entity_Id) return Boolean;\n+                  --  Determine whether Id has already been processed\n+\n+                  -----------------------\n+                  -- Is_Duplicate_Item --\n+                  -----------------------\n+\n+                  function Is_Duplicate_Item (Id : Entity_Id) return Boolean is\n+                     Item_Elmt : Elmt_Id;\n+\n+                  begin\n+                     if Present (Seen) then\n+                        Item_Elmt := First_Elmt (Seen);\n+                        while Present (Item_Elmt) loop\n+                           if Node (Item_Elmt) = Id then\n+                              return True;\n+                           end if;\n+\n+                           Next_Elmt (Item_Elmt);\n+                        end loop;\n+                     end if;\n+\n+                     return False;\n+                  end Is_Duplicate_Item;\n+\n+                  --  Local declarations\n+\n+                  Id : Entity_Id;\n+\n+               --  Start of processing for Analyze_Global_Item\n+\n+               begin\n+                  --  Detect one of the following cases\n+\n+                  --    with Global => (null, Name)\n+                  --    with Global => (Name_1, null, Name_2)\n+                  --    with Global => (Name, null)\n+\n+                  if Nkind (Item) = N_Null then\n+                     Error_Msg_N\n+                       (\"cannot mix null and non-null global items\", Item);\n+                     return;\n+                  end if;\n+\n+                  --  Ensure that the formal parameters are visible when\n+                  --  processing an item. This falls out of the general rule\n+                  --  of aspects pertaining to subprogram declarations.\n+\n+                  Push_Scope (Subp_Id);\n+                  Install_Formals (Subp_Id);\n+                  Analyze (Item);\n+                  Pop_Scope;\n+\n+                  if Is_Entity_Name (Item) then\n+                     Id := Entity (Item);\n+\n+                     --  A global item cannot reference a formal parameter. Do\n+                     --  this check first to provide a better error diagnostic.\n+\n+                     if Is_Formal (Id) then\n+                        Error_Msg_N\n+                          (\"global item cannot reference formal parameter\",\n+                           Item);\n+                        return;\n+\n+                     --  The only legal references are those to abstract states\n+                     --  and variables.\n+\n+                     elsif not Ekind_In (Entity (Item), E_Abstract_State,\n+                                                        E_Variable)\n+                     then\n+                        Error_Msg_N\n+                          (\"global item must denote variable or state\", Item);\n+                        return;\n+                     end if;\n+\n+                  --  Some form of illegal construct masquerading as a name\n+\n+                  else\n+                     Error_Msg_N\n+                       (\"global item must denote variable or state\", Item);\n+                     return;\n+                  end if;\n+\n+                  --  The same entity might be referenced through various way.\n+                  --  Check the entity of the item rather than the item itself.\n+\n+                  if Is_Duplicate_Item (Id) then\n+                     Error_Msg_N (\"duplicate global item\", Item);\n+\n+                  --  Add the entity of the current item to the list of\n+                  --  processed items.\n+\n+                  else\n+                     if No (Seen) then\n+                        Seen := New_Elmt_List;\n+                     end if;\n+\n+                     Append_Elmt (Id, Seen);\n+                  end if;\n+\n+                  if Ekind (Id) = E_Abstract_State\n+                    and then Is_Volatile_State (Id)\n+                  then\n+                     --  A global item of mode In_Out or Output cannot denote a\n+                     --  volatile Input state.\n+\n+                     if Is_Input_State (Id)\n+                       and then (Global_Mode = Name_In_Out\n+                                   or else\n+                                 Global_Mode = Name_Output)\n+                     then\n+                        Error_Msg_N\n+                          (\"global item of mode In_Out or Output cannot \" &\n+                           \"reference Volatile Input state\", Item);\n+\n+                     --  A global item of mode In_Out or Input cannot reference\n+                     --  a volatile Output state.\n+\n+                     elsif Is_Output_State (Id)\n+                       and then (Global_Mode = Name_In_Out\n+                                   or else\n+                                 Global_Mode = Name_Input)\n+                     then\n+                        Error_Msg_N\n+                          (\"global item of mode In_Out or Input cannot \"\n+                           & \"reference Volatile Output state\", Item);\n+                     end if;\n+                  end if;\n+               end Analyze_Global_Item;\n+\n+               --------------------------\n+               -- Check_Duplicate_Mode --\n+               --------------------------\n+\n+               procedure Check_Duplicate_Mode\n+                 (Mode   : Node_Id;\n+                  Status : in out Boolean)\n+               is\n+               begin\n+                  if Status then\n+                     Error_Msg_N (\"duplicate global mode\", Mode);\n+                  end if;\n+\n+                  Status := True;\n+               end Check_Duplicate_Mode;\n+\n+               ----------------------------------------\n+               -- Check_Mode_Restriction_In_Function --\n+               ----------------------------------------\n+\n+               procedure Check_Mode_Restriction_In_Function (Mode : Node_Id) is\n+               begin\n+                  if Ekind (Subp_Id) = E_Function then\n+                     Error_Msg_Name_1 := Chars (Mode);\n+                     Error_Msg_N\n+                       (\"global mode % not applicable to functions\", Mode);\n+                  end if;\n+               end Check_Mode_Restriction_In_Function;\n+\n+               --  Local variables\n+\n+               Assoc : Node_Id;\n+               Item  : Node_Id;\n+               Mode  : Node_Id;\n+\n+            --  Start of processing for Analyze_Global_List\n+\n+            begin\n+               --  Single global item declaration\n+\n+               if Nkind_In (List, N_Identifier, N_Selected_Component) then\n+                  Analyze_Global_Item (List, Global_Mode);\n+\n+               --  Simple global list or moded global list declaration\n+\n+               elsif Nkind (List) = N_Aggregate then\n+\n+                  --  The declaration of a simple global list appear as a\n+                  --  collection of expressions.\n+\n+                  if Present (Expressions (List)) then\n+                     if Present (Component_Associations (List)) then\n+                        Error_Msg_N\n+                          (\"cannot mix moded and non-moded global lists\",\n+                           List);\n+                     end if;\n+\n+                     Item := First (Expressions (List));\n+                     while Present (Item) loop\n+                        Analyze_Global_Item (Item, Global_Mode);\n+\n+                        Next (Item);\n+                     end loop;\n+\n+                  --  The declaration of a moded global list appears as a\n+                  --  collection of component associations where individual\n+                  --  choices denote modes.\n+\n+                  elsif Present (Component_Associations (List)) then\n+                     if Present (Expressions (List)) then\n+                        Error_Msg_N\n+                          (\"cannot mix moded and non-moded global lists\",\n+                           List);\n+                     end if;\n+\n+                     Assoc := First (Component_Associations (List));\n+                     while Present (Assoc) loop\n+                           Mode := First (Choices (Assoc));\n+\n+                        if Nkind (Mode) = N_Identifier then\n+                           if Chars (Mode) = Name_Contract_In then\n+                                 Check_Duplicate_Mode (Mode, Contract_Seen);\n+\n+                           elsif Chars (Mode) = Name_In_Out then\n+                              Check_Duplicate_Mode (Mode, In_Out_Seen);\n+                                 Check_Mode_Restriction_In_Function (Mode);\n+\n+                           elsif Chars (Mode) = Name_Input then\n+                                 Check_Duplicate_Mode (Mode, Input_Seen);\n+\n+                           elsif Chars (Mode) = Name_Output then\n+                              Check_Duplicate_Mode (Mode, Output_Seen);\n+                                 Check_Mode_Restriction_In_Function (Mode);\n+\n+                           else\n+                              Error_Msg_N (\"invalid mode selector\", Mode);\n+                           end if;\n+\n+                        else\n+                           Error_Msg_N (\"invalid mode selector\", Mode);\n+                        end if;\n+\n+                        --  Items in a moded list appear as a collection of\n+                        --  expressions. Reuse the existing machinery to\n+                        --  analyze them.\n+\n+                        Analyze_Global_List\n+                          (List        => Expression (Assoc),\n+                           Global_Mode => Chars (Mode));\n+\n+                        Next (Assoc);\n+                     end loop;\n+\n+                  --  Something went horribly wrong, we have a malformed tree\n+\n+                  else\n+                     raise Program_Error;\n+                  end if;\n+\n+               --  Any other attempt to declare a global item is erroneous\n+\n+               else\n+                  Error_Msg_N (\"malformed global list declaration\", List);\n+               end if;\n+            end Analyze_Global_List;\n+\n+            --  Local variables\n+\n+            List : Node_Id;\n+            Subp : Node_Id;\n+\n+         --  Start of processing for Global\n+\n+         begin\n+            GNAT_Pragma;\n+            S14_Pragma;\n+            Check_Arg_Count (1);\n+\n+            --  Ensure the proper placement of the pragma. Global must be\n+            --  associated with a subprogram declaration.\n+\n+            Subp := Parent (Corresponding_Aspect (N));\n+\n+            if Nkind (Subp) /= N_Subprogram_Declaration then\n+               Pragma_Misplaced;\n+               return;\n+            end if;\n+\n+            Subp_Id := Defining_Unit_Name (Specification (Subp));\n+            List    := Expression (Arg1);\n+\n+            --  There is nothing to be done for a null global list\n+\n+            if Nkind (List) = N_Null then\n+               null;\n+\n+            --  Analyze the various forms of global lists and items. Note that\n+            --  some of these may be malformed in which case the analysis emits\n+            --  error messages.\n+\n+            else\n+               Analyze_Global_List (List);\n+            end if;\n+         end Global;\n+\n          -----------\n          -- Ident --\n          -----------\n@@ -16093,6 +16453,7 @@ package body Sem_Prag is\n       Pragma_Fast_Math                      => -1,\n       Pragma_Finalize_Storage_Only          =>  0,\n       Pragma_Float_Representation           =>  0,\n+      Pragma_Global                         => -1,\n       Pragma_Ident                          => -1,\n       Pragma_Implementation_Defined         => -1,\n       Pragma_Implemented                    => -1,"}, {"sha": "4fbf0690c394e57289867014ac1a4da0b615981d", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a1f177500d156346723ebb47043b517a7d1a26a/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a1f177500d156346723ebb47043b517a7d1a26a/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=7a1f177500d156346723ebb47043b517a7d1a26a", "patch": "@@ -494,6 +494,7 @@ package Snames is\n    Name_Export_Valued_Procedure        : constant Name_Id := N + $; -- GNAT\n    Name_External                       : constant Name_Id := N + $; -- GNAT\n    Name_Finalize_Storage_Only          : constant Name_Id := N + $; -- GNAT\n+   Name_Global                         : constant Name_Id := N + $; -- GNAT\n    Name_Ident                          : constant Name_Id := N + $; -- VMS\n    Name_Implementation_Defined         : constant Name_Id := N + $; -- GNAT\n    Name_Implemented                    : constant Name_Id := N + $; -- Ada 12\n@@ -673,6 +674,7 @@ package Snames is\n    Name_Code                           : constant Name_Id := N + $;\n    Name_Component                      : constant Name_Id := N + $;\n    Name_Component_Size_4               : constant Name_Id := N + $;\n+   Name_Contract_In                    : constant Name_Id := N + $;\n    Name_Copy                           : constant Name_Id := N + $;\n    Name_D_Float                        : constant Name_Id := N + $;\n    Name_Decreases                      : constant Name_Id := N + $;\n@@ -695,6 +697,7 @@ package Snames is\n    Name_GPL                            : constant Name_Id := N + $;\n    Name_IEEE_Float                     : constant Name_Id := N + $;\n    Name_Ignore                         : constant Name_Id := N + $;\n+   Name_In_Out                         : constant Name_Id := N + $;\n    Name_Increases                      : constant Name_Id := N + $;\n    Name_Info                           : constant Name_Id := N + $;\n    Name_Integrity                      : constant Name_Id := N + $;\n@@ -1771,6 +1774,7 @@ package Snames is\n       Pragma_Export_Valued_Procedure,\n       Pragma_External,\n       Pragma_Finalize_Storage_Only,\n+      Pragma_Global,\n       Pragma_Ident,\n       Pragma_Implementation_Defined,\n       Pragma_Implemented,"}, {"sha": "e6367af45a2970ddc0988c78bf987020f2fac22c", "filename": "gcc/ada/table.adb", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a1f177500d156346723ebb47043b517a7d1a26a/gcc%2Fada%2Ftable.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a1f177500d156346723ebb47043b517a7d1a26a/gcc%2Fada%2Ftable.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftable.adb?ref=7a1f177500d156346723ebb47043b517a7d1a26a", "patch": "@@ -188,15 +188,12 @@ package body Table is\n             --  for the use of 10 here is to ensure that the table does really\n             --  increase in size (which would not be the case for a table of\n             --  length 10 increased by 3% for instance). Do the intermediate\n-            --  calculation in Long_Long_Integer to avoid overflow. Note that\n-            --  Long_Integer has the same range as Integer on Windows, so we\n-            --  need Long_Long_.\n+            --  calculation in Long_Long_Integer to avoid overflow.\n \n             while Max < Last_Val loop\n                New_Length :=\n                  Long_Long_Integer (Length) *\n-                 (100 + Long_Long_Integer (Table_Increment))\n-                 / 100;\n+                    (100 + Long_Long_Integer (Table_Increment)) / 100;\n                Length := Int'Max (Int (New_Length), Length + 10);\n                Max := Min + Length - 1;\n             end loop;"}]}