{"sha": "03c83cf7aa1110e427beb00ea95767dfaf50d694", "node_id": "C_kwDOANBUbNoAKDAzYzgzY2Y3YWExMTEwZTQyN2JlYjAwZWE5NTc2N2RmYWY1MGQ2OTQ", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-03-12T20:00:49Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-03-12T20:00:49Z"}, "message": "c++: ICE with bad conversion shortcutting [PR104622]\n\nWhen shortcutting bad argument conversions during overload resolution,\nwe assume conversions get computed in sequential order and that therefore\nthe conversion array is incomplete iff the last conversion is missing.\nBut this assumption turns out to be wrong for templates, because during\ndeduction check_non_deducible_conversion can compute an argument\nconversion out of order.\n\nSo in the testcase below, at the end of add_template_candidate the\nconversion array looks like {bad_conv, NULL, good_conv} where the last\nconversion was computed during deduction and the first one later from\nadd_function_candidate.  We need to add this candidate to bad_fns since\nnot all of its argument conversions were computed, but we don't do so\nbecause the last conversion isn't missing.\n\nThis patch fixes this by checking for a missing conversion exhaustively\ninstead.  In passing, this cleans up check_non_deducible_conversion given\nthat the only values of 'strict' we expect to see here the enumerators\nof unification_kind_t.\n\n\tPR c++/104622\n\ngcc/cp/ChangeLog:\n\n\t* call.cc (missing_conversion_p): Define.\n\t(add_candidates): Use it.\n\t* pt.cc (check_non_deducible_conversion): Change type of strict\n\tparameter to unification_kind_t and directly test for DEDUCE_CALL.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/template/conv18.C: New test.", "tree": {"sha": "bda379f6a95aee2a948ea1e4d61f05971829c201", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bda379f6a95aee2a948ea1e4d61f05971829c201"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/03c83cf7aa1110e427beb00ea95767dfaf50d694", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03c83cf7aa1110e427beb00ea95767dfaf50d694", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03c83cf7aa1110e427beb00ea95767dfaf50d694", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03c83cf7aa1110e427beb00ea95767dfaf50d694/comments", "author": null, "committer": null, "parents": [{"sha": "9413bb55185b9e88d84e91d5145d59f9f83b884a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9413bb55185b9e88d84e91d5145d59f9f83b884a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9413bb55185b9e88d84e91d5145d59f9f83b884a"}], "stats": {"total": 33, "additions": 29, "deletions": 4}, "files": [{"sha": "8fe8ef306ea1d5eed8d60d00ebb3b040ea507428", "filename": "gcc/cp/call.cc", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03c83cf7aa1110e427beb00ea95767dfaf50d694/gcc%2Fcp%2Fcall.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03c83cf7aa1110e427beb00ea95767dfaf50d694/gcc%2Fcp%2Fcall.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.cc?ref=03c83cf7aa1110e427beb00ea95767dfaf50d694", "patch": "@@ -6023,6 +6023,17 @@ perfect_candidate_p (z_candidate *cand)\n   return true;\n }\n \n+/* True iff one of CAND's argument conversions is NULL.  */\n+\n+static bool\n+missing_conversion_p (const z_candidate *cand)\n+{\n+  for (unsigned i = 0; i < cand->num_convs; ++i)\n+    if (!cand->convs[i])\n+      return true;\n+  return false;\n+}\n+\n /* Add each of the viable functions in FNS (a FUNCTION_DECL or\n    OVERLOAD) to the CANDIDATES, returning an updated list of\n    CANDIDATES.  The ARGS are the arguments provided to the call;\n@@ -6200,7 +6211,7 @@ add_candidates (tree fns, tree first_arg, const vec<tree, va_gc> *args,\n \n       if (cand->viable == -1\n \t  && shortcut_bad_convs\n-\t  && !cand->convs[cand->reversed () ? 0 : cand->num_convs - 1])\n+\t  && missing_conversion_p (cand))\n \t{\n \t  /* This candidate has been tentatively marked non-strictly viable,\n \t     and we didn't compute all argument conversions for it (having"}, {"sha": "67a49c7c67b8289207d8edbcfadfd463b2de3578", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03c83cf7aa1110e427beb00ea95767dfaf50d694/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03c83cf7aa1110e427beb00ea95767dfaf50d694/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=03c83cf7aa1110e427beb00ea95767dfaf50d694", "patch": "@@ -152,7 +152,7 @@ static tree coerce_innermost_template_parms (tree, tree, tree, tsubst_flags_t,\n \t\t\t\t\t      bool, bool);\n static void tsubst_enum\t(tree, tree, tree);\n static bool check_instantiated_args (tree, tree, tsubst_flags_t);\n-static int check_non_deducible_conversion (tree, tree, int, int,\n+static int check_non_deducible_conversion (tree, tree, unification_kind_t, int,\n \t\t\t\t\t   struct conversion **, bool);\n static int maybe_adjust_types_for_deduction (tree, unification_kind_t,\n \t\t\t\t\t     tree*, tree*, tree);\n@@ -22287,7 +22287,7 @@ maybe_adjust_types_for_deduction (tree tparms,\n    unify_one_argument.  */\n \n static int\n-check_non_deducible_conversion (tree parm, tree arg, int strict,\n+check_non_deducible_conversion (tree parm, tree arg, unification_kind_t strict,\n \t\t\t\tint flags, struct conversion **conv_p,\n \t\t\t\tbool explain_p)\n {\n@@ -22307,7 +22307,7 @@ check_non_deducible_conversion (tree parm, tree arg, int strict,\n       if (can_convert_arg (type, parm, NULL_TREE, flags, complain))\n \treturn unify_success (explain_p);\n     }\n-  else if (strict != DEDUCE_EXACT)\n+  else if (strict == DEDUCE_CALL)\n     {\n       bool ok = false;\n       tree conv_arg = TYPE_P (arg) ? NULL_TREE : arg;"}, {"sha": "f59f6fda77c1076960ce2bbde88a2bada03b21c5", "filename": "gcc/testsuite/g++.dg/template/conv18.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03c83cf7aa1110e427beb00ea95767dfaf50d694/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fconv18.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03c83cf7aa1110e427beb00ea95767dfaf50d694/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fconv18.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fconv18.C?ref=03c83cf7aa1110e427beb00ea95767dfaf50d694", "patch": "@@ -0,0 +1,14 @@\n+// PR c++/104622\n+// { dg-additional-options \"-fpermissive\" }\n+\n+template<class T>\n+struct type_identity {\n+  typedef T type;\n+};\n+\n+template<class T> void f(typename type_identity<T>::type*, T, int*);\n+\n+int main() {\n+  const int p = 0;\n+  f(&p, 0, 0); // { dg-warning \"invalid conversion\" }\n+}"}]}