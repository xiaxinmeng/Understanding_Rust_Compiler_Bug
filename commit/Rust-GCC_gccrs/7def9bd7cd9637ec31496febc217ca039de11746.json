{"sha": "7def9bd7cd9637ec31496febc217ca039de11746", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2RlZjliZDdjZDk2MzdlYzMxNDk2ZmViYzIxN2NhMDM5ZGUxMTc0Ng==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2019-11-25T19:02:03Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2019-11-25T19:02:03Z"}, "message": "libstdc++: Add move_sentinel, common_iterator and counted_iterator\n\nThis implements most of the remaining C++20 additions to the <iterator>\nheader.\n\n\t* include/bits/iterator_concepts.h (ranges::iter_swap): Fix parameter\n\ttypes of poison pill overload. Use remove_reference_t when checking\n\tconstraints.\n\t* include/bits/stl_iterator.h (move_sentinel): Define for C++20.\n\t(move_iterator): Adjust definitions of nested types for C++20. Add\n\thidden friends for move_sentinel operations, iter_move and iter_swap.\n\t(common_iterator, counted_iterator): Define for C++20.\n\t* testsuite/24_iterators/move_iterator/cust.cc: New test.\n\t* testsuite/24_iterators/move_iterator/sentinel.cc: New test.\n\t* testsuite/24_iterators/common_iterator/1.cc: New test.\n\t* testsuite/24_iterators/counted_iterator/1.cc: New test.\n\nFrom-SVN: r278698", "tree": {"sha": "f17895c9f6ac7c20cb57016dfcf706c0cc70f8d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f17895c9f6ac7c20cb57016dfcf706c0cc70f8d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7def9bd7cd9637ec31496febc217ca039de11746", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7def9bd7cd9637ec31496febc217ca039de11746", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7def9bd7cd9637ec31496febc217ca039de11746", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7def9bd7cd9637ec31496febc217ca039de11746/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6039f5ce1b2110d458ededa6f8fa230927af772", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6039f5ce1b2110d458ededa6f8fa230927af772", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6039f5ce1b2110d458ededa6f8fa230927af772"}], "stats": {"total": 1114, "additions": 1105, "deletions": 9}, "files": [{"sha": "4ea06a37a1f9d18ec589eee4d908d3cb9383de08", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7def9bd7cd9637ec31496febc217ca039de11746/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7def9bd7cd9637ec31496febc217ca039de11746/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=7def9bd7cd9637ec31496febc217ca039de11746", "patch": "@@ -1,5 +1,17 @@\n 2019-11-25  Jonathan Wakely  <jwakely@redhat.com>\n \n+\t* include/bits/iterator_concepts.h (ranges::iter_swap): Fix parameter\n+\ttypes of poison pill overload. Use remove_reference_t when checking\n+\tconstraints.\n+\t* include/bits/stl_iterator.h (move_sentinel): Define for C++20.\n+\t(move_iterator): Adjust definitions of nested types for C++20. Add\n+\thidden friends for move_sentinel operations, iter_move and iter_swap.\n+\t(common_iterator, counted_iterator): Define for C++20.\n+\t* testsuite/24_iterators/move_iterator/cust.cc: New test.\n+\t* testsuite/24_iterators/move_iterator/sentinel.cc: New test.\n+\t* testsuite/24_iterators/common_iterator/1.cc: New test.\n+\t* testsuite/24_iterators/counted_iterator/1.cc: New test.\n+\n \tPR libstdc++/91786\n \t* include/bits/fs_path.h (filesystem_error): Move definition before\n \tthe use in u8path."}, {"sha": "97aed72e2554bcf33f9985dc72ca77e7d414685c", "filename": "libstdc++-v3/include/bits/iterator_concepts.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7def9bd7cd9637ec31496febc217ca039de11746/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fiterator_concepts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7def9bd7cd9637ec31496febc217ca039de11746/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fiterator_concepts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fiterator_concepts.h?ref=7def9bd7cd9637ec31496febc217ca039de11746", "patch": "@@ -700,7 +700,7 @@ namespace ranges\n   namespace __cust_iswap\n   {\n     template<typename _It1, typename _It2>\n-      void iter_swap(_It1&, _It2&) = delete;\n+      void iter_swap(_It1, _It2) = delete;\n \n     template<typename _Tp, typename _Up>\n       concept __adl_iswap\n@@ -744,7 +744,8 @@ namespace ranges\n     public:\n       template<typename _Tp, typename _Up>\n \trequires __adl_iswap<_Tp, _Up>\n-\t|| (readable<_Tp> && readable<_Up>\n+\t|| (readable<remove_reference_t<_Tp>>\n+\t    && readable<remove_reference_t<_Up>>\n \t    && swappable_with<iter_reference_t<_Tp>, iter_reference_t<_Up>>)\n \t|| (indirectly_movable_storable<_Tp, _Up>\n \t    && indirectly_movable_storable<_Up, _Tp>)"}, {"sha": "89cca64438ca92e291e7f83a3a8d343e39e90a1c", "filename": "libstdc++-v3/include/bits/stl_iterator.h", "status": "modified", "additions": 688, "deletions": 7, "changes": 695, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7def9bd7cd9637ec31496febc217ca039de11746/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7def9bd7cd9637ec31496febc217ca039de11746/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator.h?ref=7def9bd7cd9637ec31496febc217ca039de11746", "patch": "@@ -73,6 +73,11 @@\n # define __cpp_lib_array_constexpr 201803\n #endif\n \n+#if __cplusplus > 201703L\n+# include <compare>\n+# include <new>\n+#endif\n+\n namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n@@ -1055,12 +1060,61 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     { return __it.base(); }\n \n #if __cplusplus >= 201103L\n-\n   /**\n    * @addtogroup iterators\n    * @{\n    */\n \n+#if __cplusplus > 201703L && __cpp_lib_concepts\n+  template<semiregular _Sent>\n+    class move_sentinel\n+    {\n+    public:\n+      constexpr\n+      move_sentinel()\n+      noexcept(is_nothrow_default_constructible_v<_Sent>)\n+      : _M_last() { }\n+\n+      constexpr explicit\n+      move_sentinel(_Sent __s)\n+      noexcept(is_nothrow_move_constructible_v<_Sent>)\n+      : _M_last(std::move(__s)) { }\n+\n+      template<typename _S2> requires convertible_to<const _S2&, _Sent>\n+\tconstexpr\n+\tmove_sentinel(const move_sentinel<_S2>& __s)\n+\tnoexcept(is_nothrow_constructible_v<_Sent, const _S2&>)\n+\t: _M_last(__s.base())\n+\t{ }\n+\n+      template<typename _S2> requires assignable_from<_Sent&, const _S2&>\n+\tconstexpr move_sentinel&\n+\toperator=(const move_sentinel<_S2>& __s)\n+\tnoexcept(is_nothrow_assignable_v<_Sent, const _S2&>)\n+\t{\n+\t  _M_last = __s.base();\n+\t  return *this;\n+\t}\n+\n+      constexpr _Sent\n+      base() const\n+      noexcept(is_nothrow_copy_constructible_v<_Sent>)\n+      { return _M_last; }\n+\n+    private:\n+      _Sent _M_last;\n+    };\n+\n+  namespace __detail\n+  {\n+    // Weaken iterator_category _Cat to _Limit if it is derived from that,\n+    // otherwise use _Otherwise.\n+    template<typename _Cat, typename _Limit, typename _Otherwise = _Cat>\n+      using __clamp_iter_cat\n+\t= conditional_t<derived_from<_Cat, _Limit>, _Limit, _Otherwise>;\n+  }\n+#endif // C++20\n+\n   // 24.4.3  Move iterators\n   /**\n    *  Class template move_iterator is an iterator adapter with the same\n@@ -1073,14 +1127,27 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _Iterator>\n     class move_iterator\n     {\n-    protected:\n       _Iterator _M_current;\n \n-      typedef iterator_traits<_Iterator>\t\t__traits_type;\n-      typedef typename __traits_type::reference\t\t__base_ref;\n+      using __traits_type = iterator_traits<_Iterator>;\n+#if __cplusplus > 201703L && __cpp_lib_concepts\n+      using __base_cat = typename __traits_type::iterator_category;\n+#else\n+      using __base_ref = typename __traits_type::reference;\n+#endif\n \n     public:\n-      typedef _Iterator\t\t\t\t\titerator_type;\n+      using iterator_type = _Iterator;\n+\n+#if __cplusplus > 201703L && __cpp_lib_concepts\n+      using iterator_concept = input_iterator_tag;\n+      using iterator_category\n+\t= __detail::__clamp_iter_cat<__base_cat, random_access_iterator_tag>;\n+      using value_type = iter_value_t<_Iterator>;\n+      using difference_type = iter_difference_t<_Iterator>;\n+      using pointer = _Iterator;\n+      using reference = iter_rvalue_reference_t<_Iterator>;\n+#else\n       typedef typename __traits_type::iterator_category iterator_category;\n       typedef typename __traits_type::value_type  \tvalue_type;\n       typedef typename __traits_type::difference_type\tdifference_type;\n@@ -1091,6 +1158,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       typedef typename conditional<is_reference<__base_ref>::value,\n \t\t\t typename remove_reference<__base_ref>::type&&,\n \t\t\t __base_ref>::type\t\treference;\n+#endif\n \n       _GLIBCXX17_CONSTEXPR\n       move_iterator()\n@@ -1172,6 +1240,34 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _GLIBCXX17_CONSTEXPR reference\n       operator[](difference_type __n) const\n       { return std::move(_M_current[__n]); }\n+\n+#if __cplusplus > 201703L && __cpp_lib_concepts\n+      template<sentinel_for<_Iterator> _Sent>\n+\tfriend constexpr bool\n+\toperator==(const move_iterator& __x, const move_sentinel<_Sent>& __y)\n+\t{ return __x.base() == __y.base(); }\n+\n+      template<sized_sentinel_for<_Iterator> _Sent>\n+\tfriend constexpr iter_difference_t<_Iterator>\n+\toperator-(const move_sentinel<_Sent>& __x, const move_iterator& __y)\n+\t{ return __x.base() - __y.base(); }\n+\n+      template<sized_sentinel_for<_Iterator> _Sent>\n+\tfriend constexpr iter_difference_t<_Iterator>\n+\toperator-(const move_iterator& __x, const move_sentinel<_Sent>& __y)\n+\t{ return __x.base() - __y.base(); }\n+\n+      friend constexpr iter_rvalue_reference_t<_Iterator>\n+      iter_move(const move_iterator& __i)\n+      noexcept(noexcept(ranges::iter_move(__i._M_current)))\n+      { return ranges::iter_move(__i._M_current); }\n+\n+      template<indirectly_swappable<_Iterator> _Iter2>\n+\tfriend constexpr void\n+\titer_swap(const move_iterator& __x, const move_iterator<_Iter2>& __y)\n+\tnoexcept(noexcept(ranges::iter_swap(__x._M_current, __y._M_current)))\n+\t{ return ranges::iter_swap(__x._M_current, __y._M_current); }\n+#endif // C++20\n     };\n \n   // Note: See __normal_iterator operators note from Gaby to understand\n@@ -1285,6 +1381,592 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     __make_move_if_noexcept_iterator(_Tp* __i)\n     { return _ReturnType(__i); }\n \n+#if __cplusplus > 201703L && __cpp_lib_concepts\n+  // [iterators.common] Common iterators\n+\n+  namespace __detail\n+  {\n+    template<input_or_output_iterator _It>\n+      class _Common_iter_proxy\n+      {\n+\titer_value_t<_It> _M_keep;\n+\n+\t_Common_iter_proxy(iter_reference_t<_It>&& __x)\n+\t: _M_keep(std::move(__x)) { }\n+\n+\ttemplate<typename _Iter, typename _Sent>\n+\t  friend class common_iterator;\n+\n+      public:\n+\tconst iter_value_t<_It>*\n+\toperator->() const\n+\t{ return std::__addressof(_M_keep); }\n+      };\n+\n+    template<typename _It>\n+      concept __common_iter_has_arrow = readable<const _It>\n+\t&& (requires(const _It& __it) { __it.operator->(); }\n+\t    || is_reference_v<iter_reference_t<_It>>\n+\t    || constructible_from<iter_value_t<_It>, iter_reference_t<_It>>);\n+\n+  } // namespace __detail\n+\n+  /// An iterator/sentinel adaptor for representing a non-common range.\n+  template<input_or_output_iterator _It, sentinel_for<_It> _Sent>\n+    requires (!same_as<_It, _Sent>)\n+  class common_iterator\n+  {\n+    template<typename _Tp, typename _Up>\n+      static constexpr bool\n+      _S_noexcept1()\n+      {\n+\tif constexpr (is_trivially_default_constructible_v<_Tp>)\n+\t  return is_nothrow_assignable_v<_Tp, _Up>;\n+\telse\n+\t  return is_nothrow_constructible_v<_Tp, _Up>;\n+      }\n+\n+    template<typename _It2, typename _Sent2>\n+      static constexpr bool\n+      _S_noexcept()\n+      { return _S_noexcept1<_It, _It2>() && _S_noexcept1<_Sent, _Sent2>(); }\n+\n+  public:\n+    constexpr\n+    common_iterator()\n+    noexcept(is_nothrow_default_constructible_v<_It>)\n+    : _M_it(), _M_index(0)\n+    { }\n+\n+    constexpr\n+    common_iterator(_It __i)\n+    noexcept(is_nothrow_move_constructible_v<_It>)\n+    : _M_it(std::move(__i)), _M_index(0)\n+    { }\n+\n+    constexpr\n+    common_iterator(_Sent __s)\n+    noexcept(is_nothrow_move_constructible_v<_Sent>)\n+    : _M_sent(std::move(__s)), _M_index(1)\n+    { }\n+\n+    template<typename _It2, typename _Sent2>\n+      requires convertible_to<const _It2&, _It>\n+\t&& convertible_to<const _Sent2&, _Sent>\n+      constexpr\n+      common_iterator(const common_iterator<_It2, _Sent2>& __x)\n+      noexcept(_S_noexcept<const _It2&, const _Sent2&>())\n+      : _M_valueless(), _M_index(__x._M_index)\n+      {\n+\tif (_M_index == 0)\n+\t  {\n+\t    if constexpr (is_trivially_default_constructible_v<_It>)\n+\t      _M_it = std::move(__x._M_it);\n+\t    else\n+\t      ::new((void*)std::__addressof(_M_it)) _It(__x._M_it);\n+\t  }\n+\telse if (_M_index == 1)\n+\t  {\n+\t    if constexpr (is_trivially_default_constructible_v<_Sent>)\n+\t      _M_sent = std::move(__x._M_sent);\n+\t    else\n+\t      ::new((void*)std::__addressof(_M_sent)) _Sent(__x._M_sent);\n+\t  }\n+      }\n+\n+    constexpr\n+    common_iterator(const common_iterator& __x)\n+    noexcept(_S_noexcept<const _It&, const _Sent&>())\n+    : _M_valueless(), _M_index(__x._M_index)\n+    {\n+      if (_M_index == 0)\n+\t{\n+\t  if constexpr (is_trivially_default_constructible_v<_It>)\n+\t    _M_it = std::move(__x._M_it);\n+\t  else\n+\t    ::new((void*)std::__addressof(_M_it)) _It(__x._M_it);\n+\t}\n+      else if (_M_index == 1)\n+\t{\n+\t  if constexpr (is_trivially_default_constructible_v<_Sent>)\n+\t    _M_sent = std::move(__x._M_sent);\n+\t  else\n+\t    ::new((void*)std::__addressof(_M_sent)) _Sent(__x._M_sent);\n+\t}\n+    }\n+\n+    common_iterator&\n+    operator=(const common_iterator& __x)\n+    noexcept(is_nothrow_copy_assignable_v<_It>\n+\t     && is_nothrow_copy_assignable_v<_Sent>\n+\t     && is_nothrow_copy_constructible_v<_It>\n+\t     && is_nothrow_copy_constructible_v<_Sent>)\n+    {\n+      return this->operator=<_It, _Sent>(__x);\n+    }\n+\n+    template<typename _It2, typename _Sent2>\n+      requires convertible_to<const _It2&, _It>\n+\t&& convertible_to<const _Sent2&, _Sent>\n+\t&& assignable_from<_It&, const _It2&>\n+\t&& assignable_from<_Sent&, const _Sent2&>\n+      common_iterator&\n+      operator=(const common_iterator<_It2, _Sent2>& __x)\n+      noexcept(is_nothrow_constructible_v<_It, const _It2&>\n+\t       && is_nothrow_constructible_v<_Sent, const _Sent2&>\n+\t       && is_nothrow_assignable_v<_It, const _It2&>\n+\t       && is_nothrow_assignable_v<_Sent, const _Sent2&>)\n+      {\n+\tswitch(_M_index << 2 | __x._M_index)\n+\t  {\n+\t  case 0b0000:\n+\t    _M_it = __x._M_it;\n+\t    break;\n+\t  case 0b0101:\n+\t    _M_sent = __x._M_sent;\n+\t    break;\n+\t  case 0b0001:\n+\t    _M_it.~_It();\n+\t    _M_index = -1;\n+\t    [[fallthrough]];\n+\t  case 0b1001:\n+\t    ::new((void*)std::__addressof(_M_sent)) _Sent(__x._M_sent);\n+\t    _M_index = 1;\n+\t    break;\n+\t  case 0b0100:\n+\t    _M_sent.~_Sent();\n+\t    _M_index = -1;\n+\t    [[fallthrough]];\n+\t  case 0b1000:\n+\t    ::new((void*)std::__addressof(_M_it)) _It(__x._M_it);\n+\t    _M_index = 0;\n+\t    break;\n+\t  default:\n+\t    __glibcxx_assert(__x._M_has_value());\n+\t    __builtin_unreachable();\n+\t  }\n+\treturn *this;\n+      }\n+\n+    ~common_iterator()\n+    {\n+      switch (_M_index)\n+\t{\n+\tcase 0:\n+\t  _M_it.~_It();\n+\t  break;\n+\tcase 1:\n+\t  _M_sent.~_Sent();\n+\t  break;\n+\t}\n+    }\n+\n+    decltype(auto)\n+    operator*()\n+    {\n+      __glibcxx_assert(_M_index == 0);\n+      return *_M_it;\n+    }\n+\n+    decltype(auto)\n+    operator*() const requires __detail::__dereferenceable<const _It>\n+    {\n+      __glibcxx_assert(_M_index == 0);\n+      return *_M_it;\n+    }\n+\n+    decltype(auto)\n+    operator->() const requires __detail::__common_iter_has_arrow<_It>\n+    {\n+      __glibcxx_assert(_M_index == 0);\n+      if constexpr (is_pointer_v<_It> || requires { _M_it.operator->(); })\n+\treturn _M_it;\n+      else if constexpr (is_reference_v<iter_reference_t<_It>>)\n+\t{\n+\t  auto&& __tmp = *_M_it;\n+\t  return std::__addressof(__tmp);\n+\t}\n+      else\n+\treturn _Common_iter_proxy(*_M_it);\n+    }\n+\n+    common_iterator&\n+    operator++()\n+    {\n+      __glibcxx_assert(_M_index == 0);\n+      ++_M_it;\n+      return *this;\n+    }\n+\n+    decltype(auto)\n+    operator++(int)\n+    {\n+      __glibcxx_assert(_M_index == 0);\n+      if constexpr (forward_iterator<_It>)\n+\t{\n+\t  common_iterator __tmp = *this;\n+\t  ++*this;\n+\t  return __tmp;\n+\t}\n+      else\n+\treturn _M_it++;\n+    }\n+\n+    template<typename _It2, sentinel_for<_It> _Sent2>\n+      requires sentinel_for<_Sent, _It2>\n+      friend bool\n+      operator==(const common_iterator& __x,\n+\t\t const common_iterator<_It2, _Sent2>& __y)\n+      {\n+\tswitch(__x._M_index << 2 | __y._M_index)\n+\t  {\n+\t  case 0b0000:\n+\t  case 0b0101:\n+\t    return true;\n+\t  case 0b0001:\n+\t    return __x._M_it == __y._M_sent;\n+\t  case 0b0100:\n+\t    return __x._M_sent == __y._M_it;\n+\t  default:\n+\t    __glibcxx_assert(__x._M_has_value());\n+\t    __glibcxx_assert(__y._M_has_value());\n+\t    __builtin_unreachable();\n+\t  }\n+      }\n+\n+    template<typename _It2, sentinel_for<_It> _Sent2>\n+      requires sentinel_for<_Sent, _It2> && equality_comparable_with<_It, _It2>\n+      friend bool\n+      operator==(const common_iterator& __x,\n+\t\t const common_iterator<_It2, _Sent2>& __y)\n+      {\n+\tswitch(__x._M_index << 2 | __y._M_index)\n+\t  {\n+\t  case 0b0101:\n+\t    return true;\n+\t  case 0b0000:\n+\t    return __x._M_it == __y._M_it;\n+\t  case 0b0001:\n+\t    return __x._M_it == __y._M_sent;\n+\t  case 0b0100:\n+\t    return __x._M_sent == __y._M_it;\n+\t  default:\n+\t    __glibcxx_assert(__x._M_has_value());\n+\t    __glibcxx_assert(__y._M_has_value());\n+\t    __builtin_unreachable();\n+\t  }\n+      }\n+\n+    template<sized_sentinel_for<_It> _It2, sized_sentinel_for<_It> _Sent2>\n+      requires sized_sentinel_for<_Sent, _It2>\n+      friend iter_difference_t<_It2>\n+      operator-(const common_iterator& __x,\n+\t\tconst common_iterator<_It2, _Sent2>& __y)\n+      {\n+\tswitch(__x._M_index << 2 | __y._M_index)\n+\t  {\n+\t  case 0b0101:\n+\t    return 0;\n+\t  case 0b0000:\n+\t    return __x._M_it - __y._M_it;\n+\t  case 0b0001:\n+\t    return __x._M_it - __y._M_sent;\n+\t  case 0b0100:\n+\t    return __x._M_sent - __y._M_it;\n+\t  default:\n+\t    __glibcxx_assert(__x._M_has_value());\n+\t    __glibcxx_assert(__y._M_has_value());\n+\t    __builtin_unreachable();\n+\t  }\n+      }\n+\n+    friend iter_rvalue_reference_t<_It>\n+    iter_move(const common_iterator& __i)\n+    noexcept(noexcept(ranges::iter_move(std::declval<const _It&>())))\n+    requires input_iterator<_It>\n+    {\n+      __glibcxx_assert(__i._M_index == 0);\n+      return ranges::iter_move(__i._M_it);\n+    }\n+\n+    template<indirectly_swappable<_It> _It2, typename _Sent2>\n+      friend void\n+      iter_swap(const common_iterator& __x,\n+\t\tconst common_iterator<_It2, _Sent2>& __y)\n+      noexcept(noexcept(ranges::iter_swap(std::declval<const _It&>(),\n+\t\t\t\t\t  std::declval<const _It2&>())))\n+      {\n+\t__glibcxx_assert(__x._M_index == 0);\n+\t__glibcxx_assert(__y._M_index == 0);\n+\treturn ranges::iter_swap(__x._M_it, __y._M_it);\n+      }\n+\n+  private:\n+    template<input_or_output_iterator _It2, sentinel_for<_It2> _Sent2>\n+      friend class common_iterator;\n+\n+    bool _M_has_value() const noexcept { return _M_index < 2; }\n+\n+    union\n+    {\n+      _It _M_it;\n+      _Sent _M_sent;\n+      unsigned char _M_valueless;\n+    };\n+    unsigned char _M_index; // 0==_M_it, 1==_M_sent, 2==valueless\n+  };\n+\n+  template<typename _It, typename _Sent>\n+    struct incrementable_traits<common_iterator<_It, _Sent>>\n+    {\n+      using difference_type = iter_difference_t<_It>;\n+    };\n+\n+  namespace __detail\n+  {\n+    // FIXME: This has to be at namespace-scope because of PR 92078.\n+    template<typename _Iter>\n+      struct __common_iter_ptr\n+\t{\n+\t  using type = void;\n+\t};\n+\n+    template<typename _Iter>\n+      requires __detail::__common_iter_has_arrow<_Iter>\n+      struct __common_iter_ptr<_Iter>\n+      {\n+\tusing type = decltype(std::declval<const _Iter&>().operator->());\n+      };\n+  } // namespace __detail\n+\n+  template<input_iterator _It, typename _Sent>\n+    struct iterator_traits<common_iterator<_It, _Sent>>\n+    {\n+      using iterator_concept = conditional_t<forward_iterator<_It>,\n+\t    forward_iterator_tag, input_iterator_tag>;\n+      using iterator_category = __detail::__clamp_iter_cat<\n+\ttypename iterator_traits<_It>::iterator_category,\n+\tforward_iterator_tag, input_iterator_tag>;\n+      using value_type = iter_value_t<_It>;\n+      using difference_type = iter_difference_t<_It>;\n+      using pointer = typename\n+\t__detail::__common_iter_ptr<common_iterator<_It, _Sent>>::type;\n+      using reference = iter_reference_t<_It>;\n+    };\n+\n+  // [iterators.counted] Counted iterators\n+\n+  /// An iterator adaptor that keeps track of the distance to the end.\n+  template<input_or_output_iterator _It>\n+    class counted_iterator\n+    {\n+    public:\n+      using iterator_type = _It;\n+\n+      constexpr counted_iterator() = default;\n+\n+      constexpr\n+      counted_iterator(_It __i, iter_difference_t<_It> __n)\n+      : _M_current(__i), _M_length(__n)\n+      { __glibcxx_assert(__n >= 0); }\n+\n+      template<typename _It2>\n+\trequires convertible_to<const _It2&, _It>\n+\tconstexpr\n+\tcounted_iterator(const counted_iterator<_It2>& __x)\n+\t: _M_current(__x._M_current), _M_length(__x._M_length)\n+\t{ }\n+\n+      template<typename _It2>\n+\trequires assignable_from<_It&, const _It2&>\n+\tconstexpr counted_iterator&\n+\toperator=(const counted_iterator<_It2>& __x)\n+\t{\n+\t  _M_current = __x._M_current;\n+\t  _M_length = __x._M_length;\n+\t  return *this;\n+\t}\n+\n+      constexpr _It\n+      base() const &\n+      noexcept(is_nothrow_copy_constructible_v<_It>)\n+      requires copy_constructible<_It>\n+      { return _M_current; }\n+\n+      constexpr _It\n+      base() &&\n+      noexcept(is_nothrow_move_constructible_v<_It>)\n+      { return std::move(_M_current); }\n+\n+      constexpr iter_difference_t<_It>\n+      count() const noexcept { return _M_length; }\n+\n+      constexpr decltype(auto)\n+      operator*()\n+      noexcept(noexcept(*_M_current))\n+      { return *_M_current; }\n+\n+      constexpr decltype(auto)\n+      operator*() const\n+      noexcept(noexcept(*_M_current))\n+      requires __detail::__dereferenceable<const _It>\n+      { return *_M_current; }\n+\n+      constexpr counted_iterator&\n+      operator++()\n+      {\n+\t__glibcxx_assert(_M_length > 0);\n+\t++_M_current;\n+\t--_M_length;\n+\treturn *this;\n+      }\n+\n+      decltype(auto)\n+      operator++(int)\n+      {\n+\t__glibcxx_assert(_M_length > 0);\n+\t--_M_length;\n+\t__try\n+\t  {\n+\t    return _M_current++;\n+\t  } __catch(...) {\n+\t    ++_M_length;\n+\t    throw;\n+\t  }\n+\n+      }\n+\n+      constexpr counted_iterator\n+      operator++(int) requires forward_iterator<_It>\n+      {\n+\tauto __tmp = *this;\n+\t++*this;\n+\treturn __tmp;\n+      }\n+\n+      constexpr counted_iterator&\n+      operator--() requires bidirectional_iterator<_It>\n+      {\n+\t--_M_current;\n+\t++_M_length;\n+\treturn *this;\n+      }\n+\n+      constexpr counted_iterator\n+      operator--(int) requires bidirectional_iterator<_It>\n+      {\n+\tauto __tmp = *this;\n+\t--*this;\n+\treturn __tmp;\n+      }\n+\n+      constexpr counted_iterator\n+      operator+(iter_difference_t<_It> __n) const\n+\trequires random_access_iterator<_It>\n+      { return counted_iterator(_M_current + __n, _M_length - __n); }\n+\n+      friend constexpr counted_iterator\n+      operator+(iter_difference_t<_It> __n, const counted_iterator& __x)\n+      requires random_access_iterator<_It>\n+      { return __x + __n; }\n+\n+      constexpr counted_iterator&\n+      operator+=(iter_difference_t<_It> __n)\n+      requires random_access_iterator<_It>\n+      {\n+\t__glibcxx_assert(__n <= _M_length);\n+\t_M_current += __n;\n+\t_M_length -= __n;\n+\treturn *this;\n+      }\n+\n+      constexpr counted_iterator\n+      operator-(iter_difference_t<_It> __n) const\n+      requires random_access_iterator<_It>\n+      { return counted_iterator(_M_current - __n, _M_length + __n); }\n+\n+      template<common_with<_It> _It2>\n+\tfriend constexpr iter_difference_t<_It2>\n+\toperator-(const counted_iterator& __x,\n+\t\t  const counted_iterator<_It2>& __y)\n+\t{ return __y._M_length - __x._M_length; }\n+\n+      friend constexpr iter_difference_t<_It>\n+      operator-(const counted_iterator& __x, default_sentinel_t)\n+      { return -__x._M_length; }\n+\n+      friend constexpr iter_difference_t<_It>\n+      operator-(default_sentinel_t, const counted_iterator& __y)\n+      { return __y._M_length; }\n+\n+      constexpr counted_iterator&\n+      operator-=(iter_difference_t<_It> __n)\n+      requires random_access_iterator<_It>\n+      {\n+\t__glibcxx_assert(-__n <= _M_length);\n+\t_M_current -= __n;\n+\t_M_length += __n;\n+\treturn *this;\n+      }\n+\n+      constexpr decltype(auto)\n+      operator[](iter_difference_t<_It> __n) const\n+      noexcept(noexcept(_M_current[__n]))\n+      requires random_access_iterator<_It>\n+      {\n+\t__glibcxx_assert(__n < _M_length);\n+\treturn _M_current[__n];\n+      }\n+\n+      template<common_with<_It> _It2>\n+\tfriend constexpr bool\n+\toperator==(const counted_iterator& __x,\n+\t\t   const counted_iterator<_It2>& __y)\n+\t{ return __x._M_length == __y._M_length; }\n+\n+      friend constexpr bool\n+      operator==(const counted_iterator& __x, default_sentinel_t)\n+      { return __x._M_length == 0; }\n+\n+      template<common_with<_It> _It2>\n+\tfriend constexpr strong_ordering\n+\toperator<=>(const counted_iterator& __x,\n+\t\t    const counted_iterator<_It2>& __y)\n+\t{ return __y._M_length <=> __x._M_length; }\n+\n+      friend constexpr iter_rvalue_reference_t<_It>\n+      iter_move(const counted_iterator& __i)\n+      noexcept(noexcept(ranges::iter_move(__i._M_current)))\n+      requires input_iterator<_It>\n+      { return ranges::iter_move(__i._M_current); }\n+\n+      template<indirectly_swappable<_It> _It2>\n+\tfriend constexpr void\n+\titer_swap(const counted_iterator& __x,\n+\t\t  const counted_iterator<_It2>& __y)\n+\tnoexcept(noexcept(ranges::iter_swap(__x._M_current, __y._M_current)))\n+\t{ ranges::iter_swap(__x._M_current, __y._M_current); }\n+\n+    private:\n+      template<input_or_output_iterator _It2> friend class counted_iterator;\n+\n+      _It _M_current = _It();\n+      iter_difference_t<_It> _M_length = 0;\n+    };\n+\n+  template<typename _It>\n+    struct incrementable_traits<counted_iterator<_It>>\n+    {\n+      using difference_type = iter_difference_t<_It>;\n+    };\n+\n+  template<input_iterator _It>\n+    struct iterator_traits<counted_iterator<_It>> : iterator_traits<_It>\n+    {\n+      using pointer = void;\n+    };\n+#endif // C++20\n+\n   // @} group iterators\n \n   template<typename _Iterator>\n@@ -1332,8 +2014,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     using __iter_to_alloc_t =\n     pair<add_const_t<__iter_key_t<_InputIterator>>,\n \t __iter_val_t<_InputIterator>>;\n-\n-#endif\n+#endif // __cpp_deduction_guides\n \n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace"}, {"sha": "275ef53fe6a92abc89f9ae0bde7d6e9f78416b5c", "filename": "libstdc++-v3/testsuite/24_iterators/common_iterator/1.cc", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7def9bd7cd9637ec31496febc217ca039de11746/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fcommon_iterator%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7def9bd7cd9637ec31496febc217ca039de11746/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fcommon_iterator%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fcommon_iterator%2F1.cc?ref=7def9bd7cd9637ec31496febc217ca039de11746", "patch": "@@ -0,0 +1,160 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <iterator>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  using I = std::common_iterator<int*, const int*>;\n+  static_assert( std::is_default_constructible_v<I> );\n+  static_assert( std::is_copy_constructible_v<I> );\n+  static_assert( std::is_copy_assignable_v<I> );\n+  static_assert( std::is_constructible_v<I, int*> );\n+  static_assert( std::is_constructible_v<I, const int*> );\n+\n+  struct sentinel { operator int*() const { return nullptr; } };\n+  using K = std::common_iterator<int*, sentinel>;\n+  static_assert( std::is_constructible_v<I, const K&> );\n+  static_assert( std::is_assignable_v<I, const K&> );\n+\n+  struct sentinel2\n+  {\n+    const int* p;\n+    sentinel2(const int* p = 0) : p(p) { }\n+    bool operator==(const int* p) const { return p == this->p; }\n+  };\n+\n+  using J = std::common_iterator<const int*, sentinel2>;\n+  static_assert( std::is_constructible_v<J, const I&> );\n+  static_assert( std::is_convertible_v<const I&, J> );\n+}\n+\n+void\n+test02()\n+{\n+  struct sentinel { int limit; };\n+\n+  struct iterator\n+  {\n+    using iterator_category = std::input_iterator_tag;\n+    using value_type = int;\n+    using difference_type = std::ptrdiff_t;\n+    using reference = const int&;\n+\n+    const int& operator*() const { return counter; }\n+\n+    iterator& operator++() { ++counter; return *this; }\n+\n+    iterator operator++(int) { auto i = *this; ++counter; return i; }\n+\n+    bool operator==(sentinel s) const { return counter == s.limit; }\n+\n+    int counter = 0;\n+  };\n+\n+  static_assert( std::sentinel_for<sentinel, iterator> );\n+\n+  int out[5] = { };\n+  std::common_iterator<int*, const int*> obegin = std::begin(out);\n+  std::common_iterator<int*, const int*> oend = std::cend(out);\n+\n+  iterator i;\n+  sentinel s{5};\n+  std::common_iterator<iterator, sentinel> begin = i, end = s;\n+  while (begin != end)\n+    *obegin++ = *begin++;\n+\n+  VERIFY(obegin == oend);\n+  for (int& i : out)\n+    VERIFY( i == (&i - out) );\n+}\n+\n+void\n+test03()\n+{\n+  int arr[2] = { 1, 2 };\n+  std::common_iterator<int*, const int*> i = std::ranges::begin(arr);\n+  std::common_iterator<int*, const int*> end = std::ranges::cend(arr);\n+  VERIFY( i != end );\n+  VERIFY( (end - i) == 2 );\n+  VERIFY( (i - end) == -2 );\n+  auto j = i;\n+  VERIFY( j == i );\n+  VERIFY( (j - i) == 0 );\n+  j = end;\n+  VERIFY( j != i );\n+  VERIFY( j == end );\n+  j = std::ranges::next(i);\n+  VERIFY( j != i );\n+  VERIFY( j != end );\n+  VERIFY( (end - j) == 1 );\n+  VERIFY( (j - i) == 1 );\n+  VERIFY( (i - j) == -1 );\n+  ++j;\n+  VERIFY( j == end );\n+  VERIFY( (end - j) == 0 );\n+  j = i;\n+  VERIFY( j == i );\n+  VERIFY( (j - end) == -2 );\n+  VERIFY( (j - i) == 0 );\n+\n+  try\n+  {\n+    struct S { operator const int*() const { throw 1; } };\n+    i = std::common_iterator<int*, S>(S{});\n+    VERIFY( false );\n+  }\n+  catch (int)\n+  {\n+  }\n+}\n+\n+void\n+test04()\n+{\n+  struct X\n+  {\n+    X(int i) : i(i) { }\n+    X(X&& x) : i(x.i) { x.i = -1; }\n+    X& operator=(X&& x) { i = x.i; x.i = 0; return *this; }\n+    int i;\n+  };\n+\n+  X arr[] = { 1, 2 };\n+  std::common_iterator<X*, const X*> i(arr), j(arr+1);\n+  std::ranges::iter_swap(i, j);\n+  VERIFY( arr[0].i == 2 );\n+  VERIFY( arr[1].i == 1 );\n+\n+  X x = std::ranges::iter_move(i);\n+  VERIFY( arr[0].i == -1 );\n+  VERIFY( x.i == 2 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+}"}, {"sha": "b31469cdebfbe9925572a3de1350be1b5d675e1a", "filename": "libstdc++-v3/testsuite/24_iterators/counted_iterator/1.cc", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7def9bd7cd9637ec31496febc217ca039de11746/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fcounted_iterator%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7def9bd7cd9637ec31496febc217ca039de11746/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fcounted_iterator%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fcounted_iterator%2F1.cc?ref=7def9bd7cd9637ec31496febc217ca039de11746", "patch": "@@ -0,0 +1,101 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <iterator>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  using I = std::counted_iterator<int*>;\n+  static_assert( std::is_default_constructible_v<I> );\n+  static_assert( std::is_copy_constructible_v<I> );\n+  static_assert( std::is_copy_assignable_v<I> );\n+  static_assert( ! std::is_constructible_v<I, int*> );\n+  static_assert( std::is_constructible_v<I, int*, std::ptrdiff_t> );\n+\n+  using J = std::counted_iterator<const int*>;\n+  static_assert( std::is_constructible_v<J, const I&> );\n+  static_assert( std::is_convertible_v<const I&, J> );\n+}\n+\n+void\n+test02()\n+{\n+  int in[3] = { 1, 2, 3 };\n+  std::counted_iterator<const int*> in_iter(std::begin(in), std::ssize(in));\n+  VERIFY( in_iter.base() == in );\n+  VERIFY( (std::default_sentinel - in_iter) == 3 );\n+  VERIFY( (in_iter - std::default_sentinel) == -3 );\n+\n+  int out[4] = { };\n+  std::counted_iterator<int*> out_iter(std::begin(out), std::ssize(out));\n+  VERIFY( out_iter.base() == out );\n+  VERIFY( (std::default_sentinel - out_iter) == 4 );\n+  VERIFY( (out_iter - std::default_sentinel) == -4 );\n+\n+  while (in_iter != std::default_sentinel && out_iter != std::default_sentinel)\n+    *out_iter++ = *in_iter++;\n+\n+  VERIFY(in_iter == std::default_sentinel);\n+  VERIFY(out_iter != std::default_sentinel);\n+  VERIFY( out[0] == 1 );\n+  VERIFY( out[1] == 2 );\n+  VERIFY( out[2] == 3 );\n+  VERIFY( out[3] == 0 );\n+\n+  auto out2 = out_iter;\n+  out2 += 1;\n+  VERIFY( out2 == std::default_sentinel );\n+  VERIFY( (out2 <=> out_iter) == std::strong_ordering::greater );\n+  out2 -= 3;\n+  VERIFY( (out_iter - out2) == 2 );\n+  VERIFY( (out2 <=> out_iter) == std::strong_ordering::less );\n+}\n+\n+void\n+test03()\n+{\n+  struct X\n+  {\n+    X(int i) : i(i) { }\n+    X(X&& x) : i(x.i) { x.i = -1; }\n+    X& operator=(X&& x) { i = x.i; x.i = 0; return *this; }\n+    int i;\n+  };\n+\n+  X arr[] = { 1, 2 };\n+  std::counted_iterator<X*> i(arr, 2), j(arr + 1, 1);\n+  std::ranges::iter_swap(i, j);\n+  VERIFY( arr[0].i == 2 );\n+  VERIFY( arr[1].i == 1 );\n+\n+  X x = std::ranges::iter_move(i);\n+  VERIFY( arr[0].i == -1 );\n+  VERIFY( x.i == 2 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "6d0817dc2043474154a004c6e614450b428f5f2c", "filename": "libstdc++-v3/testsuite/24_iterators/move_iterator/cust.cc", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7def9bd7cd9637ec31496febc217ca039de11746/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fmove_iterator%2Fcust.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7def9bd7cd9637ec31496febc217ca039de11746/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fmove_iterator%2Fcust.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fmove_iterator%2Fcust.cc?ref=7def9bd7cd9637ec31496febc217ca039de11746", "patch": "@@ -0,0 +1,50 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <iterator>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  struct X\n+  {\n+    X(int i) : i(i) { }\n+    X(X&& x) : i(x.i) { x.i = -1; }\n+    X& operator=(X&& x) { i = x.i; x.i = 0; return *this; }\n+    int i;\n+  };\n+\n+  X arr[] = { 1, 2 };\n+  std::move_iterator<X*> i(arr), j(arr + 1);\n+  std::ranges::iter_swap(i, j);\n+  VERIFY( arr[0].i == 2 );\n+  VERIFY( arr[1].i == 1 );\n+\n+  X x = std::ranges::iter_move(i);\n+  VERIFY( arr[0].i == -1 );\n+  VERIFY( x.i == 2 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "875a8fc37c4ed6d5489cb497920e1064b1a3b79f", "filename": "libstdc++-v3/testsuite/24_iterators/move_iterator/sentinel.cc", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7def9bd7cd9637ec31496febc217ca039de11746/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fmove_iterator%2Fsentinel.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7def9bd7cd9637ec31496febc217ca039de11746/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fmove_iterator%2Fsentinel.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fmove_iterator%2Fsentinel.cc?ref=7def9bd7cd9637ec31496febc217ca039de11746", "patch": "@@ -0,0 +1,91 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <iterator>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  using S = std::move_sentinel<const int*>;\n+  using M = std::move_iterator<int*>;\n+\n+  static_assert( std::is_default_constructible_v<S> );\n+  static_assert( std::is_copy_constructible_v<S> );\n+  static_assert( std::is_copy_assignable_v<S> );\n+  static_assert( std::is_constructible_v<S, std::move_sentinel<int*>> );\n+  static_assert( std::is_assignable_v<S, std::move_sentinel<int*>> );\n+\n+  constexpr S s;\n+  static_assert( s.base() == nullptr );\n+\n+  constexpr M m;\n+  static_assert( m == s );\n+  static_assert( s == m );\n+  static_assert( !(m != s) );\n+  static_assert( !(s != m) );\n+\n+  int i = 0;\n+  M m2(&i);\n+  VERIFY( m2 != s );\n+  VERIFY( s != m2 );\n+  VERIFY( !(m2 == s) );\n+  VERIFY( !(s == m2) );\n+}\n+\n+void\n+test02()\n+{\n+  struct sentinel { int limit; };\n+\n+  struct iterator\n+  {\n+    using iterator_category = std::input_iterator_tag;\n+    using value_type = int;\n+    using difference_type = std::ptrdiff_t;\n+    using reference = const int&;\n+\n+    const int& operator*() const { return counter; }\n+\n+    iterator& operator++() { ++counter; return *this; }\n+\n+    iterator operator++(int) { auto i = *this; ++counter; return i; }\n+\n+    bool operator==(sentinel s) const { return counter == s.limit; }\n+\n+    int counter = 0;\n+  };\n+\n+  static_assert( std::sentinel_for<sentinel, iterator> );\n+\n+  iterator i;\n+  sentinel s{5};\n+  int count = 0;\n+  for (auto m = std::make_move_iterator(i); m != std::move_sentinel{s}; ++m)\n+    ++count;\n+  VERIFY( count == 5 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}]}