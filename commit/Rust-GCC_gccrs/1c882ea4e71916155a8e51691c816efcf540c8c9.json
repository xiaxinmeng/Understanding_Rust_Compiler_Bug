{"sha": "1c882ea4e71916155a8e51691c816efcf540c8c9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWM4ODJlYTRlNzE5MTYxNTVhOGU1MTY5MWM4MTZlZmNmNTQwYzhjOQ==", "commit": {"author": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2000-03-20T23:47:39Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2000-03-20T23:47:39Z"}, "message": "rs6000.md (bunordered): New expander.\n\n* config/rs6000/rs6000.md (bunordered): New expander.\n(bordered): New expander.\n(buneq): New expander.\n(bunge): New expander.\n(bungt): New expander.\n(bunle): New expander.\n(bunlt): New expander.\n(bltgt): New expander.\n\n* config/rs6000/rs6000.c (ccr_bit): Handle unordered comparisons.\n(ccr_bit_negated_p): New function.\n(print_operand): For %C, generate appropriate cror for UNEQ,\nUNLT, UNGT, and LTGT.  For %T and %t, use ccr_bit_negated_p.\n\nFrom-SVN: r32657", "tree": {"sha": "670d1a01fc1173ce2258821f8b73fbf48fb711c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/670d1a01fc1173ce2258821f8b73fbf48fb711c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1c882ea4e71916155a8e51691c816efcf540c8c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c882ea4e71916155a8e51691c816efcf540c8c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c882ea4e71916155a8e51691c816efcf540c8c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c882ea4e71916155a8e51691c816efcf540c8c9/comments", "author": null, "committer": null, "parents": [{"sha": "8c57aea6ec8a35c4fbb8f46eae50b278a602fa24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c57aea6ec8a35c4fbb8f46eae50b278a602fa24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c57aea6ec8a35c4fbb8f46eae50b278a602fa24"}], "stats": {"total": 237, "additions": 206, "deletions": 31}, "files": [{"sha": "c8b1268410ea0060bda3afd52b379ce662e11f8d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c882ea4e71916155a8e51691c816efcf540c8c9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c882ea4e71916155a8e51691c816efcf540c8c9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1c882ea4e71916155a8e51691c816efcf540c8c9", "patch": "@@ -1,3 +1,19 @@\n+2000-03-20  Geoff Keating  <geoffk@cygnus.com>\n+\n+\t* config/rs6000/rs6000.md (bunordered): New expander.\n+\t(bordered): New expander.\n+\t(buneq): New expander.\n+\t(bunge): New expander.\n+\t(bungt): New expander.\n+\t(bunle): New expander.\n+\t(bunlt): New expander.\n+\t(bltgt): New expander.\n+ \n+\t* config/rs6000/rs6000.c (ccr_bit): Handle unordered comparisons.\n+\t(ccr_bit_negated_p): New function.\n+\t(print_operand): For %C, generate appropriate cror for UNEQ,\n+\tUNLT, UNGT, and LTGT.  For %T and %t, use ccr_bit_negated_p.\n+\n 2000-03-20  Andreas Jaeger  <aj@suse.de>\n \n \t* sdbout.c (sdbout_one_type): Add braces to avoid \"ambigous else\"\n@@ -17126,7 +17142,7 @@ Fri Aug 20 18:53:43 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \tcopy_rtx_and_substitute, subst_constants, restore_constants):\n \tLikewise.\n \n-\t* jump.c  (mark_jump_label, invert_exp, redirect_exp,\n+\t* jump.c  (mark_jump_label, invert_exp, redirect_e\u0000\u0000\u0000xp,\n \trtx_renumbered_equal_p, rtx_equal_for_thread_p): Likewise.\n \n \t* local-alloc.c (contains_replace_regs, memref_referenced_p):\n@@ -17256,7 +17272,7 @@ Fri Aug 20 15:02:10 1999  Mark Mitchell  <mark@codesourcery.com>\n \n Fri Aug 20 22:32:17 1999  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n \n-\t* config/c4x/c4x.h (STARTFILE_SPEC): Don't define.\n+\t* config/c4x/c4x.h (STARTFILE_SPEC): Don't def.\n \n 1999-08-19 18:43 -0700  Zack Weinberg  <zack@bitmover.com>\n \n@@ -17966,7 +17982,7 @@ Mon Aug  9 10:08:50 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \t(unroll_loop): Access regno_pointer_* variables through\n \tcurrent_function.\n \n-\t* tree.h (struct tree_decl): Add elt f to saved_insns member.\n+\t* tree.h (struct tree_decl): Add elt f to saved_ins\u0000\u0000\u0000ns member.\n \t(DECL_SAVED_INSNS): use it.\n \t(expand_dummy_function_end): Declare.\n \t(init_function_for_compilation): Declare.\n@@ -18072,7 +18088,7 @@ Sat Aug  7 00:21:20 1999  Richard Henderson  <rth@cygnus.com>\n \n Sat Aug  7 00:06:54 1999  Jeffrey A Law  (law@cygnus.com)\n \n-\t* Makefile.in (TAROUTOPTS): Kill.\n+\t* Makefiin (TAROUTOPTS): Kill.\n \t(install-headers-tar): Use \"xpf\" for tar headerfile extraction\n \t* i370/x-oe (TAROUTOPTS): Delete.\n \t* m68k/x-apollo68 (TAROUTOPTS): Delete.\n@@ -18869,7 +18885,7 @@ Wed Jul 28 11:22:21 1999  Richard Henderson  <rth@cygnus.com>\n \n Wed Jul 28 11:20:19 1999  Richard Henderson  <rth@cygnus.com>\n \n-\t* mn10200.c (mn10200_va_arg): New.\n+\t* mn102\u0000\u0000\u000000.c (mn10200_va_arg): New.\n \t* mn10200.h (EXPAND_BUILTIN_VA_ARG): New.\n \n Wed Jul 28 11:19:06 1999  Richard Henderson  <rth@cygnus.com>\n@@ -18979,7 +18995,7 @@ Mon Jul 26 22:43:12 1999  Richard Henderson  <rth@cygnus.com>\n \n Mon Jul 26 18:51:34 1999  Richard Henderson  <rth@cygnus.com>\n \n-\t* except.c (start_dynamic_cleanup): Use force_operand on the\n+\t* except.c (st_dynamic_cleanup): Use force_operand on the\n \tbuffer's address.\n \n Mon Jul 26 16:43:26 1999  Richard Henderson  <rth@cygnus.com>"}, {"sha": "04539ee0c132c9f10d1469a50ecd03136f422ce3", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 64, "deletions": 25, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c882ea4e71916155a8e51691c816efcf540c8c9/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c882ea4e71916155a8e51691c816efcf540c8c9/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=1c882ea4e71916155a8e51691c816efcf540c8c9", "patch": "@@ -119,6 +119,7 @@ static int rs6000_sr_alias_set;\n static void rs6000_add_gc_roots PARAMS ((void));\n static int num_insns_constant_wide PARAMS ((HOST_WIDE_INT));\n static rtx expand_block_move_mem PARAMS ((enum machine_mode, rtx, rtx));\n+static int ccr_bit_negated_p PARAMS((rtx));\n static void rs6000_emit_stack_tie PARAMS ((void));\n static void rs6000_frame_related PARAMS ((rtx, rtx, HOST_WIDE_INT, rtx, rtx));\n static void rs6000_emit_allocate_stack PARAMS ((HOST_WIDE_INT, int));\n@@ -3172,10 +3173,12 @@ ccr_bit (op, scc_p)\n       return scc_p ? base_bit + 3 : base_bit + 2;\n     case EQ:\n       return base_bit + 2;\n-    case GT:  case GTU:\n+    case GT:  case GTU:  case UNLE:\n       return base_bit + 1;\n-    case LT:  case LTU:\n+    case LT:  case LTU:  case UNGE:\n       return base_bit;\n+    case ORDERED:  case UNORDERED:\n+      return base_bit + 3;\n \n     case GE:  case GEU:\n       /* If floating-point, we will have done a cror to put the bit in the\n@@ -3186,10 +3189,36 @@ ccr_bit (op, scc_p)\n     case LE:  case LEU:\n       return cc_mode == CCFPmode || scc_p ? base_bit + 3 : base_bit + 1;\n \n+    case UNEQ: case UNGT: case UNLT: case LTGT:\n+      return base_bit + 3;\n+\n     default:\n       abort ();\n     }\n }\n+\n+/* Given a comparison operation, say whether the bit tested (as returned\n+   by ccr_bit) should be negated.  */\n+\n+static int\n+ccr_bit_negated_p (op)\n+     rtx op;\n+{\n+  enum rtx_code code = GET_CODE (op);\n+  enum machine_mode mode = GET_MODE (XEXP (op, 0));\n+  \n+  if (code == EQ\n+      || code == LT || code == GT\n+      || code == LTU || code == GTU)\n+    return 0;\n+  else if (mode != CCFPmode\n+      || code == NE\n+      || code == ORDERED\n+      || code == UNGE || code == UNLE)\n+    return 1;\n+  else\n+    return 0;\n+}\n \f\n /* Return the GOT register.  */\n \n@@ -3322,16 +3351,36 @@ print_operand (file, x, code)\n       return;\n \n     case 'C':\n-      /* This is an optional cror needed for LE or GE floating-point\n-\t comparisons.  Otherwise write nothing.  */\n-      if ((GET_CODE (x) == LE || GET_CODE (x) == GE)\n-\t  && GET_MODE (XEXP (x, 0)) == CCFPmode)\n-\t{\n-\t  int base_bit = 4 * (REGNO (XEXP (x, 0)) - CR0_REGNO);\n-\n-\t  fprintf (file, \"cror %d,%d,%d\\n\\t\", base_bit + 3,\n-\t\t   base_bit + 2, base_bit + (GET_CODE (x) == GE));\n-\t}\n+      {\n+\tenum rtx_code code = GET_CODE (x);\n+\t\n+\t/* This is an optional cror needed for certain floating-point\n+\t   comparisons.  Otherwise write nothing.  */\n+\tif ((code == LE || code == GE\n+\t     || code == UNEQ || code == LTGT\n+\t     || code == UNGT || code == UNLT)\n+\t    && GET_MODE (XEXP (x, 0)) == CCFPmode)\n+\t  {\n+\t    int base_bit = 4 * (REGNO (XEXP (x, 0)) - CR0_REGNO);\n+\t    int bit0, bit1;\n+\t    \n+\t    if (code == UNEQ)\n+\t      bit0 = 2;\n+\t    else if (code == UNGT || code == GE)\n+\t      bit0 = 1;\n+\t    else\n+\t      bit0 = 0;\n+\t    if (code == LTGT)\n+\t      bit1 = 1;\n+\t    else if (code == LE || code == GE)\n+\t      bit1 = 2;\n+\t    else\n+\t      bit1 = 3;\n+\t    \n+\t    fprintf (file, \"cror %d,%d,%d\\n\\t\", base_bit + 3,\n+\t\t     base_bit + bit1, base_bit + bit0);\n+\t  }\n+      }\n       return;\n \n     case 'D':\n@@ -3675,17 +3724,11 @@ print_operand (file, x, code)\n \t}\n \n     case 't':\n-      /* Write 12 if this jump operation will branch if true, 4 otherwise. \n-\t All floating-point operations except NE branch true and integer\n-\t EQ, LT, GT, LTU and GTU also branch true.  */\n+      /* Write 12 if this jump operation will branch if true, 4 otherwise. */\n       if (GET_RTX_CLASS (GET_CODE (x)) != '<')\n \toutput_operand_lossage (\"invalid %%t value\");\n \n-      else if ((GET_MODE (XEXP (x, 0)) == CCFPmode\n-\t\t&& GET_CODE (x) != NE)\n-\t       || GET_CODE (x) == EQ\n-\t       || GET_CODE (x) == LT || GET_CODE (x) == GT\n-\t       || GET_CODE (x) == LTU || GET_CODE (x) == GTU)\n+      else if (! ccr_bit_negated_p (x))\n \tfputs (\"12\", file);\n       else\n \tputc ('4', file);\n@@ -3697,11 +3740,7 @@ print_operand (file, x, code)\n       if (GET_RTX_CLASS (GET_CODE (x)) != '<')\n \toutput_operand_lossage (\"invalid %%T value\");\n \n-      else if ((GET_MODE (XEXP (x, 0)) == CCFPmode\n-\t\t&& GET_CODE (x) != NE)\n-\t       || GET_CODE (x) == EQ\n-\t       || GET_CODE (x) == LT || GET_CODE (x) == GT\n-\t       || GET_CODE (x) == LTU || GET_CODE (x) == GTU)\n+      else if (! ccr_bit_negated_p (x))\n \tputc ('4', file);\n       else\n \tfputs (\"12\", file);"}, {"sha": "8d9d8a70f83e5cb0e4c3e4446541e2cb6f827b14", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c882ea4e71916155a8e51691c816efcf540c8c9/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c882ea4e71916155a8e51691c816efcf540c8c9/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=1c882ea4e71916155a8e51691c816efcf540c8c9", "patch": "@@ -10849,6 +10849,126 @@ operands[2] = GEN_INT (INTVAL (operands[1]) >> 32);\n   operands[2] = gen_reg_rtx (CCUNSmode);\n }\")\n \n+(define_expand \"bunordered\"\n+  [(set (match_dup 2) (match_dup 1))\n+   (set (pc)\n+\t(if_then_else (unordered (match_dup 2)\n+\t\t\t         (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{ if (!rs6000_compare_fp_p) FAIL;\n+  operands[1] = gen_rtx_COMPARE (CCFPmode,\n+\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n+  operands[2] = gen_reg_rtx (CCFPmode);\n+}\")\n+\n+(define_expand \"bordered\"\n+  [(set (match_dup 2) (match_dup 1))\n+   (set (pc)\n+\t(if_then_else (ordered (match_dup 2)\n+\t\t\t       (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{ if (!rs6000_compare_fp_p) FAIL;\n+  operands[1] = gen_rtx_COMPARE (CCFPmode,\n+\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n+  operands[2] = gen_reg_rtx (CCFPmode);\n+}\")\n+\n+(define_expand \"buneq\"\n+  [(set (match_dup 2) (match_dup 1))\n+   (set (pc)\n+\t(if_then_else (uneq (match_dup 2)\n+\t\t\t    (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{ if (!rs6000_compare_fp_p) FAIL;\n+  operands[1] = gen_rtx_COMPARE (CCFPmode,\n+\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n+  operands[2] = gen_reg_rtx (CCFPmode);\n+}\")\n+\n+(define_expand \"bunge\"\n+  [(set (match_dup 2) (match_dup 1))\n+   (set (pc)\n+\t(if_then_else (unge (match_dup 2)\n+\t\t\t    (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{ if (!rs6000_compare_fp_p) FAIL;\n+  operands[1] = gen_rtx_COMPARE (CCFPmode,\n+\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n+  operands[2] = gen_reg_rtx (CCFPmode);\n+}\")\n+\n+(define_expand \"bungt\"\n+  [(set (match_dup 2) (match_dup 1))\n+   (set (pc)\n+\t(if_then_else (ungt (match_dup 2)\n+\t\t\t    (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{ if (!rs6000_compare_fp_p) FAIL;\n+  operands[1] = gen_rtx_COMPARE (CCFPmode,\n+\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n+  operands[2] = gen_reg_rtx (CCFPmode);\n+}\")\n+\n+(define_expand \"bunle\"\n+  [(set (match_dup 2) (match_dup 1))\n+   (set (pc)\n+\t(if_then_else (unle (match_dup 2)\n+\t\t\t    (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{ if (!rs6000_compare_fp_p) FAIL;\n+  operands[1] = gen_rtx_COMPARE (CCFPmode,\n+\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n+  operands[2] = gen_reg_rtx (CCFPmode);\n+}\")\n+\n+(define_expand \"bunlt\"\n+  [(set (match_dup 2) (match_dup 1))\n+   (set (pc)\n+\t(if_then_else (unlt (match_dup 2)\n+\t\t\t    (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{ if (!rs6000_compare_fp_p) FAIL;\n+  operands[1] = gen_rtx_COMPARE (CCFPmode,\n+\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n+  operands[2] = gen_reg_rtx (CCFPmode);\n+}\")\n+\n+(define_expand \"bltgt\"\n+  [(set (match_dup 2) (match_dup 1))\n+   (set (pc)\n+\t(if_then_else (ltgt (match_dup 2)\n+\t\t\t    (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{ if (!rs6000_compare_fp_p) FAIL;\n+  operands[1] = gen_rtx_COMPARE (CCFPmode,\n+\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n+  operands[2] = gen_reg_rtx (CCFPmode);\n+}\")\n+\n ;; For SNE, we would prefer that the xor/abs sequence be used for integers.\n ;; For SEQ, likewise, except that comparisons with zero should be done\n ;; with an scc insns.  However, due to the order that combine see the"}]}