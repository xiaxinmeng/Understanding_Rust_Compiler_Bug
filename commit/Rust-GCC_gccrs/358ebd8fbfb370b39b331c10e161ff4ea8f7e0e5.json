{"sha": "358ebd8fbfb370b39b331c10e161ff4ea8f7e0e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzU4ZWJkOGZiZmIzNzBiMzliMzMxYzEwZTE2MWZmNGVhOGY3ZTBlNQ==", "commit": {"author": {"name": "Harald Anlauf", "email": "anlauf@gmx.de", "date": "2019-01-22T21:23:57Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2019-01-22T21:23:57Z"}, "message": "re PR fortran/88579 (Calculating power of powers of two)\n\n2019-01-22  Harald Anlauf  <anlauf@gmx.de>\n\n\tPR fortran/88579\n\t* trans-expr.c (gfc_conv_power_op): Handle cases of (2**e) ** integer\n\tand (- 2**e) ** integer.\n\n2019-01-22  Harald Anlauf  <anlauf@gmx.de>\n\n\tPR fortran/88579\n\t* gfortran.dg/power_8.f90: New test.\n\nFrom-SVN: r268163", "tree": {"sha": "993d7d58c2216414305fe145aee6f0353b20c007", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/993d7d58c2216414305fe145aee6f0353b20c007"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/358ebd8fbfb370b39b331c10e161ff4ea8f7e0e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/358ebd8fbfb370b39b331c10e161ff4ea8f7e0e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/358ebd8fbfb370b39b331c10e161ff4ea8f7e0e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/358ebd8fbfb370b39b331c10e161ff4ea8f7e0e5/comments", "author": {"login": "harald-anlauf", "id": 90786862, "node_id": "MDQ6VXNlcjkwNzg2ODYy", "avatar_url": "https://avatars.githubusercontent.com/u/90786862?v=4", "gravatar_id": "", "url": "https://api.github.com/users/harald-anlauf", "html_url": "https://github.com/harald-anlauf", "followers_url": "https://api.github.com/users/harald-anlauf/followers", "following_url": "https://api.github.com/users/harald-anlauf/following{/other_user}", "gists_url": "https://api.github.com/users/harald-anlauf/gists{/gist_id}", "starred_url": "https://api.github.com/users/harald-anlauf/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/harald-anlauf/subscriptions", "organizations_url": "https://api.github.com/users/harald-anlauf/orgs", "repos_url": "https://api.github.com/users/harald-anlauf/repos", "events_url": "https://api.github.com/users/harald-anlauf/events{/privacy}", "received_events_url": "https://api.github.com/users/harald-anlauf/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7a8c906ca4309e46f626b7e387c9cd2c474a29e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a8c906ca4309e46f626b7e387c9cd2c474a29e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a8c906ca4309e46f626b7e387c9cd2c474a29e7"}], "stats": {"total": 173, "additions": 136, "deletions": 37}, "files": [{"sha": "31a8b2c9aa2c767f06f6662f5a5242a2a3d99c4b", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358ebd8fbfb370b39b331c10e161ff4ea8f7e0e5/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358ebd8fbfb370b39b331c10e161ff4ea8f7e0e5/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=358ebd8fbfb370b39b331c10e161ff4ea8f7e0e5", "patch": "@@ -1,3 +1,9 @@\n+2019-01-22  Harald Anlauf  <anlauf@gmx.de>\n+\n+\tPR fortran/88579\n+\t* trans-expr.c (gfc_conv_power_op): Handle cases of (2**e) ** integer\n+\tand (- 2**e) ** integer.\n+\n 2019-01-19  Dominique d'Humieres  <dominiq@gcc.gnu.org>\n \n \tPR fortran/37835\n@@ -8,7 +14,7 @@\n \n \tPR fortran/77960\n \t* io.c (match_io_element): input-item cannot be an external function.\n- \n+\n 2018-01-19  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \tPaul Thomas  <pault@gcc.gnu.org>\n "}, {"sha": "328ffc97110bc582fb0b5402716b89359f5597e9", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 60, "deletions": 36, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358ebd8fbfb370b39b331c10e161ff4ea8f7e0e5/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358ebd8fbfb370b39b331c10e161ff4ea8f7e0e5/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=358ebd8fbfb370b39b331c10e161ff4ea8f7e0e5", "patch": "@@ -3060,47 +3060,70 @@ gfc_conv_power_op (gfc_se * se, gfc_expr * expr)\n       && TREE_CODE (TREE_TYPE (rse.expr)) == INTEGER_TYPE)\n     {\n       wi::tree_to_wide_ref wlhs = wi::to_wide (lse.expr);\n-      HOST_WIDE_INT v;\n+      HOST_WIDE_INT v, w;\n+      int kind, ikind, bit_size;\n+\n       v = wlhs.to_shwi ();\n+      w = abs (v);\n+\n+      kind = expr->value.op.op1->ts.kind;\n+      ikind = gfc_validate_kind (BT_INTEGER, kind, false);\n+      bit_size = gfc_integer_kinds[ikind].bit_size;\n+\n       if (v == 1)\n \t{\n \t  /* 1**something is always 1.  */\n \t  se->expr = build_int_cst (TREE_TYPE (lse.expr), 1);\n \t  return;\n \t}\n-      else if (v == 2 || v == 4 || v == 8 || v == 16)\n+      else if (v == -1)\n \t{\n-\t  /* 2**n = 1<<n, 4**n = 1<<(n+n), 8**n = 1 <<(3*n), 16**n =\n-\t   1<<(4*n), but we have to make sure to return zero if the\n-\t   number of bits is too large. */\n+\t  /* (-1)**n is 1 - ((n & 1) << 1) */\n+\t  tree type;\n+\t  tree tmp;\n+\n+\t  type = TREE_TYPE (lse.expr);\n+\t  tmp = fold_build2_loc (input_location, BIT_AND_EXPR, type,\n+\t\t\t\t rse.expr, build_int_cst (type, 1));\n+\t  tmp = fold_build2_loc (input_location, LSHIFT_EXPR, type,\n+\t\t\t\t tmp, build_int_cst (type, 1));\n+\t  tmp = fold_build2_loc (input_location, MINUS_EXPR, type,\n+\t\t\t\t build_int_cst (type, 1), tmp);\n+\t  se->expr = tmp;\n+\t  return;\n+\t}\n+      else if (w > 0 && ((w & (w-1)) == 0) && ((w >> (bit_size-1)) == 0))\n+\t{\n+\t  /* Here v is +/- 2**e.  The further simplification uses\n+\t     2**n = 1<<n, 4**n = 1<<(n+n), 8**n = 1 <<(3*n), 16**n =\n+\t     1<<(4*n), etc., but we have to make sure to return zero\n+\t     if the number of bits is too large. */\n \t  tree lshift;\n \t  tree type;\n \t  tree shift;\n \t  tree ge;\n \t  tree cond;\n \t  tree num_bits;\n \t  tree cond2;\n+\t  tree tmp1;\n \n \t  type = TREE_TYPE (lse.expr);\n \n-\t  if (v == 2)\n+\t  if (w == 2)\n \t    shift = rse.expr;\n-\t  else if (v == 4)\n+\t  else if (w == 4)\n \t    shift = fold_build2_loc (input_location, PLUS_EXPR,\n \t\t\t\t     TREE_TYPE (rse.expr),\n \t\t\t\t       rse.expr, rse.expr);\n-\t  else if (v == 8)\n-\t    shift = fold_build2_loc (input_location, MULT_EXPR,\n-\t\t\t\t     TREE_TYPE (rse.expr),\n-\t\t\t\t     build_int_cst (TREE_TYPE (rse.expr), 3),\n-\t\t\t\t     rse.expr);\n-\t  else if (v == 16)\n-\t    shift = fold_build2_loc (input_location, MULT_EXPR,\n-\t\t\t\t     TREE_TYPE (rse.expr),\n-\t\t\t\t     build_int_cst (TREE_TYPE (rse.expr), 4),\n-\t\t\t\t     rse.expr);\n \t  else\n-\t    gcc_unreachable ();\n+\t    {\n+\t      /* use popcount for fast log2(w) */\n+\t      int e = wi::popcount (w-1);\n+\t      shift = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t       TREE_TYPE (rse.expr),\n+\t\t\t\t       build_int_cst (TREE_TYPE (rse.expr), e),\n+\t\t\t\t       rse.expr);\n+\t    }\n \n \t  lshift = fold_build2_loc (input_location, LSHIFT_EXPR, type,\n \t\t\t\t    build_int_cst (type, 1), shift);\n@@ -3111,24 +3134,25 @@ gfc_conv_power_op (gfc_se * se, gfc_expr * expr)\n \t  num_bits = build_int_cst (TREE_TYPE (rse.expr), TYPE_PRECISION (type));\n \t  cond2 = fold_build2_loc (input_location, GE_EXPR, logical_type_node,\n \t\t\t\t   rse.expr, num_bits);\n-\t  se->expr = fold_build3_loc (input_location, COND_EXPR, type, cond2,\n-\t\t\t\t      build_int_cst (type, 0), cond);\n-\t  return;\n-\t}\n-      else if (v == -1)\n-\t{\n-\t  /* (-1)**n is 1 - ((n & 1) << 1) */\n-\t  tree type;\n-\t  tree tmp;\n-\n-\t  type = TREE_TYPE (lse.expr);\n-\t  tmp = fold_build2_loc (input_location, BIT_AND_EXPR, type,\n-\t\t\t\t rse.expr, build_int_cst (type, 1));\n-\t  tmp = fold_build2_loc (input_location, LSHIFT_EXPR, type,\n-\t\t\t\t tmp, build_int_cst (type, 1));\n-\t  tmp = fold_build2_loc (input_location, MINUS_EXPR, type,\n-\t\t\t\t build_int_cst (type, 1), tmp);\n-\t  se->expr = tmp;\n+\t  tmp1 = fold_build3_loc (input_location, COND_EXPR, type, cond2,\n+\t\t\t\t  build_int_cst (type, 0), cond);\n+\t  if (v > 0)\n+\t    {\n+\t      se->expr = tmp1;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* for v < 0, calculate v**n = |v|**n * (-1)**n */\n+\t      tree tmp2;\n+\t      tmp2 = fold_build2_loc (input_location, BIT_AND_EXPR, type,\n+\t\t\t\t      rse.expr, build_int_cst (type, 1));\n+\t      tmp2 = fold_build2_loc (input_location, LSHIFT_EXPR, type,\n+\t\t\t\t      tmp2, build_int_cst (type, 1));\n+\t      tmp2 = fold_build2_loc (input_location, MINUS_EXPR, type,\n+\t\t\t\t      build_int_cst (type, 1), tmp2);\n+\t      se->expr = fold_build2_loc (input_location, MULT_EXPR, type,\n+\t\t\t\t\t  tmp1, tmp2);\n+\t    }\n \t  return;\n \t}\n     }"}, {"sha": "66b692e7109453409eb9728c515ba2428e116f91", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358ebd8fbfb370b39b331c10e161ff4ea8f7e0e5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358ebd8fbfb370b39b331c10e161ff4ea8f7e0e5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=358ebd8fbfb370b39b331c10e161ff4ea8f7e0e5", "patch": "@@ -1,3 +1,8 @@\n+2019-01-22  Harald Anlauf  <anlauf@gmx.de>\n+\n+\tPR fortran/88579\n+\t* gfortran.dg/power_8.f90: New test.\n+\n 2019-01-22  Sandra Loosemore  <sandra@codesourcery.com>\n \n \t* g++.dg/lto/pr87906_0.C: Add dg-require-effective-target fpic."}, {"sha": "143063bdec9275060376a0e20e701a9dc45dc4b4", "filename": "gcc/testsuite/gfortran.dg/power_8.f90", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358ebd8fbfb370b39b331c10e161ff4ea8f7e0e5/gcc%2Ftestsuite%2Fgfortran.dg%2Fpower_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358ebd8fbfb370b39b331c10e161ff4ea8f7e0e5/gcc%2Ftestsuite%2Fgfortran.dg%2Fpower_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpower_8.f90?ref=358ebd8fbfb370b39b331c10e161ff4ea8f7e0e5", "patch": "@@ -0,0 +1,64 @@\n+! { dg-do run }\n+! { dg-additional-options \"-fdump-tree-original\" }\n+!\n+! PR88579 - Test optimizations for bases that are powers of 2 or -2.\n+program p\n+  implicit none\n+  integer(4) :: i, u\n+  integer(1) :: j, v\n+  integer(2) :: k, w\n+  integer(8) :: z\n+  ! Test selected positive bases\n+  u = 1\n+  do i=1,5\n+     u = u * 64_4\n+     if (u /= 64_4 ** i) stop 1\n+  end do\n+  z = 1\n+  do i=1,7\n+     z = z * 256_8\n+     if (z /= 256_8 ** i) stop 2\n+  end do\n+  z = 1\n+  do i=1,3\n+     z = z * 65536_8\n+     if (z /= 65536_8 ** i) stop 3\n+  end do\n+  ! Test selected negative bases and integer kind combinations\n+  u = 1\n+  do i=1,7\n+     u = u * (-2_1)\n+     if (u /= (-2_1) ** i) stop 4\n+  end do\n+  v = 1\n+  do j=1,7\n+     v = v * (-2_1)\n+     if (v /= (-2_1) ** j) stop 5\n+  end do\n+  v = 1\n+  do k=1,7\n+     v = v * (-2_1)\n+     if (v /= (-2_1) ** k) stop 6\n+  end do\n+  w = 1\n+  do k=1,7\n+     w = w * (-4_2)\n+     if (w /= (-4_2) ** k) stop 7\n+  end do\n+  w = 1\n+  do i=1,5\n+     w = w * (-8_2)\n+     if (w /= (-8_2) ** i) stop 8\n+  end do\n+  u = 1\n+  do i=1,1\n+     u = u * (-HUGE(1_4)/2-1)\n+     if (u /= (-HUGE(1_4)/2-1) ** i) stop 9\n+  end do\n+  z = 1\n+  do i=1,7\n+     z = z * (-512_8)\n+     if (z /= (-512_8) ** i) stop 10\n+  end do\n+end program p\n+! { dg-final { scan-tree-dump-not \"_gfortran_pow\" \"original\" } }"}]}