{"sha": "61ca4737a85b646c6f4f28e5a49e4f89fa44106b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjFjYTQ3MzdhODViNjQ2YzZmNGYyOGU1YTQ5ZTRmODlmYTQ0MTA2Yg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2011-06-17T20:08:01Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2011-06-17T20:08:01Z"}, "message": "re PR c++/43912 ([C++0x] lambda debug info does not describe captured variables)\n\n\tPR c++/43912\n\tGenerate proxy VAR_DECLs for better lambda debug info.\n\t* cp-tree.h (FUNCTION_NEEDS_BODY_BLOCK): Add lambda operator().\n\t(LAMBDA_EXPR_PENDING_PROXIES): New.\n\t(struct tree_lambda_expr): Add pending_proxies.\n\t* name-lookup.c (pushdecl_maybe_friend_1): Handle capture shadowing.\n\t(qualify_lookup): Use is_lambda_ignored_entity.\n\t* parser.c (cp_parser_lambda_expression): Don't adjust field names.\n\tCall insert_pending_capture_proxies.\n\t(cp_parser_lambda_introducer): Use this_identifier.\n\t(cp_parser_lambda_declarator_opt): Call the object parameter\n\tof the op() \"__closure\" instead of \"this\".\n\t(cp_parser_lambda_body): Call build_capture_proxy.\n\t* semantics.c (build_capture_proxy, is_lambda_ignored_entity): New.\n\t(insert_pending_capture_proxies, insert_capture_proxy): New.\n\t(is_normal_capture_proxy, is_capture_proxy): New.\n\t(add_capture): Add __ to field names here, return capture proxy.\n\t(add_default_capture): Use this_identifier, adjust to expect\n\tadd_capture to return a capture proxy.\n\t(outer_lambda_capture_p, thisify_lambda_field): Remove.\n\t(finish_id_expression, lambda_expr_this_capture): Adjust.\n\t(build_lambda_expr): Initialize LAMBDA_EXPR_PENDING_PROXIES.\n\t* pt.c (tsubst_copy_and_build): Check that LAMBDA_EXPR_PENDING_PROXIES\n\tis null.\n\nFrom-SVN: r175158", "tree": {"sha": "1cc558a7e679f551ed8af13589db5f793e8cd923", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1cc558a7e679f551ed8af13589db5f793e8cd923"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61ca4737a85b646c6f4f28e5a49e4f89fa44106b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61ca4737a85b646c6f4f28e5a49e4f89fa44106b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61ca4737a85b646c6f4f28e5a49e4f89fa44106b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61ca4737a85b646c6f4f28e5a49e4f89fa44106b/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7e7666aed8caa20d3351147e6875292ca27cf1d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e7666aed8caa20d3351147e6875292ca27cf1d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e7666aed8caa20d3351147e6875292ca27cf1d9"}], "stats": {"total": 380, "additions": 299, "deletions": 81}, "files": [{"sha": "f3fca847a082b6585466f5a3dda8f8354991607e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ca4737a85b646c6f4f28e5a49e4f89fa44106b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ca4737a85b646c6f4f28e5a49e4f89fa44106b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=61ca4737a85b646c6f4f28e5a49e4f89fa44106b", "patch": "@@ -1,5 +1,30 @@\n 2011-06-17  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/43912\n+\tGenerate proxy VAR_DECLs for better lambda debug info.\n+\t* cp-tree.h (FUNCTION_NEEDS_BODY_BLOCK): Add lambda operator().\n+\t(LAMBDA_EXPR_PENDING_PROXIES): New.\n+\t(struct tree_lambda_expr): Add pending_proxies.\n+\t* name-lookup.c (pushdecl_maybe_friend_1): Handle capture shadowing.\n+\t(qualify_lookup): Use is_lambda_ignored_entity.\n+\t* parser.c (cp_parser_lambda_expression): Don't adjust field names.\n+\tCall insert_pending_capture_proxies.\n+\t(cp_parser_lambda_introducer): Use this_identifier.\n+\t(cp_parser_lambda_declarator_opt): Call the object parameter\n+\tof the op() \"__closure\" instead of \"this\".\n+\t(cp_parser_lambda_body): Call build_capture_proxy.\n+\t* semantics.c (build_capture_proxy, is_lambda_ignored_entity): New.\n+\t(insert_pending_capture_proxies, insert_capture_proxy): New.\n+\t(is_normal_capture_proxy, is_capture_proxy): New.\n+\t(add_capture): Add __ to field names here, return capture proxy.\n+\t(add_default_capture): Use this_identifier, adjust to expect\n+\tadd_capture to return a capture proxy.\n+\t(outer_lambda_capture_p, thisify_lambda_field): Remove.\n+\t(finish_id_expression, lambda_expr_this_capture): Adjust.\n+\t(build_lambda_expr): Initialize LAMBDA_EXPR_PENDING_PROXIES.\n+\t* pt.c (tsubst_copy_and_build): Check that LAMBDA_EXPR_PENDING_PROXIES\n+\tis null.\n+\n \t* name-lookup.c (pushdecl_maybe_friend_1): Do check for shadowing\n \tof artificial locals.\n "}, {"sha": "12c01cb15f5069054bad65bdfc49b7763fa27046", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ca4737a85b646c6f4f28e5a49e4f89fa44106b/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ca4737a85b646c6f4f28e5a49e4f89fa44106b/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=61ca4737a85b646c6f4f28e5a49e4f89fa44106b", "patch": "@@ -442,6 +442,8 @@ DEFTREECODE (TRAIT_EXPR, \"trait_expr\", tcc_exceptional, 0)\n    none.\n    LAMBDA_EXPR_CAPTURE_LIST holds the capture-list, including `this'.\n    LAMBDA_EXPR_THIS_CAPTURE goes straight to the capture of `this', if it exists.\n+   LAMBDA_EXPR_PENDING_PROXIES is a vector of capture proxies which need to\n+   be pushed once scope returns to the lambda.\n    LAMBDA_EXPR_MUTABLE_P signals whether this lambda was declared mutable.\n    LAMBDA_EXPR_RETURN_TYPE holds the return type, if it was specified.  */\n DEFTREECODE (LAMBDA_EXPR, \"lambda_expr\", tcc_exceptional, 0)"}, {"sha": "2773e34de2314a9082f68eeb9c406bc4cfb9f986", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ca4737a85b646c6f4f28e5a49e4f89fa44106b/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ca4737a85b646c6f4f28e5a49e4f89fa44106b/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=61ca4737a85b646c6f4f28e5a49e4f89fa44106b", "patch": "@@ -268,7 +268,8 @@ typedef struct ptrmem_cst * ptrmem_cst_t;\n #define BIND_EXPR_BODY_BLOCK(NODE) \\\n   TREE_LANG_FLAG_3 (BIND_EXPR_CHECK (NODE))\n #define FUNCTION_NEEDS_BODY_BLOCK(NODE) \\\n-  (DECL_CONSTRUCTOR_P (NODE) || DECL_DESTRUCTOR_P (NODE))\n+  (DECL_CONSTRUCTOR_P (NODE) || DECL_DESTRUCTOR_P (NODE) \\\n+   || LAMBDA_FUNCTION_P (NODE))\n \n #define STATEMENT_LIST_NO_SCOPE(NODE) \\\n   TREE_LANG_FLAG_0 (STATEMENT_LIST_CHECK (NODE))\n@@ -661,13 +662,19 @@ enum cp_lambda_default_capture_mode_type {\n #define LAMBDA_EXPR_DISCRIMINATOR(NODE) \\\n   (((struct tree_lambda_expr *)LAMBDA_EXPR_CHECK (NODE))->discriminator)\n \n+/* During parsing of the lambda, a vector of capture proxies which need\n+   to be pushed once we're done processing a nested lambda.  */\n+#define LAMBDA_EXPR_PENDING_PROXIES(NODE) \\\n+  (((struct tree_lambda_expr *)LAMBDA_EXPR_CHECK (NODE))->pending_proxies)\n+\n struct GTY (()) tree_lambda_expr\n {\n   struct tree_typed typed;\n   tree capture_list;\n   tree this_capture;\n   tree return_type;\n   tree extra_scope;\n+  VEC(tree,gc)* pending_proxies;\n   location_t locus;\n   enum cp_lambda_default_capture_mode_type default_capture_mode;\n   int discriminator;\n@@ -5450,10 +5457,15 @@ extern tree lambda_function\t\t\t(tree);\n extern void apply_lambda_return_type            (tree, tree);\n extern tree add_capture                         (tree, tree, tree, bool, bool);\n extern tree add_default_capture                 (tree, tree, tree);\n+extern tree build_capture_proxy\t\t\t(tree);\n+extern void insert_pending_capture_proxies\t(void);\n+extern bool is_capture_proxy\t\t\t(tree);\n+extern bool is_normal_capture_proxy             (tree);\n extern void register_capture_members\t\t(tree);\n extern tree lambda_expr_this_capture            (tree);\n extern tree nonlambda_method_basetype\t\t(void);\n extern void maybe_add_lambda_conv_op            (tree);\n+extern bool is_lambda_ignored_entity            (tree);\n \n /* in tree.c */\n extern int cp_tree_operand_length\t\t(const_tree);"}, {"sha": "59c4a4c9d01665717a5e4347e6aa3bb5908a1af8", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ca4737a85b646c6f4f28e5a49e4f89fa44106b/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ca4737a85b646c6f4f28e5a49e4f89fa44106b/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=61ca4737a85b646c6f4f28e5a49e4f89fa44106b", "patch": "@@ -13060,7 +13060,8 @@ finish_destructor_body (void)\n /* Do the necessary processing for the beginning of a function body, which\n    in this case includes member-initializers, but not the catch clauses of\n    a function-try-block.  Currently, this means opening a binding level\n-   for the member-initializers (in a ctor) and member cleanups (in a dtor).  */\n+   for the member-initializers (in a ctor), member cleanups (in a dtor),\n+   and capture proxies (in a lambda operator()).  */\n \n tree\n begin_function_body (void)"}, {"sha": "953edd57f221719ab0a141669c12f213e07116ef", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ca4737a85b646c6f4f28e5a49e4f89fa44106b/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ca4737a85b646c6f4f28e5a49e4f89fa44106b/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=61ca4737a85b646c6f4f28e5a49e4f89fa44106b", "patch": "@@ -1089,6 +1089,10 @@ pushdecl_maybe_friend_1 (tree x, bool is_friend)\n \t\t  if (TREE_CODE (oldlocal) == PARM_DECL)\n \t\t    warning_at (input_location, OPT_Wshadow,\n \t\t\t\t\"declaration of %q#D shadows a parameter\", x);\n+\t\t  else if (is_capture_proxy (oldlocal))\n+\t\t    warning_at (input_location, OPT_Wshadow,\n+\t\t\t\t\"declaration of %qD shadows a lambda capture\",\n+\t\t\t\tx);\n \t\t  else\n \t\t    warning_at (input_location, OPT_Wshadow,\n \t\t\t\t\"declaration of %qD shadows a previous local\",\n@@ -4002,13 +4006,8 @@ qualify_lookup (tree val, int flags)\n     return true;\n   if (flags & (LOOKUP_PREFER_NAMESPACES | LOOKUP_PREFER_TYPES))\n     return false;\n-  /* In unevaluated context, look past normal capture fields.  */\n-  if (cp_unevaluated_operand && TREE_CODE (val) == FIELD_DECL\n-      && DECL_NORMAL_CAPTURE_P (val))\n-    return false;\n-  /* None of the lookups that use qualify_lookup want the op() from the\n-     lambda; they want the one from the enclosing class.  */\n-  if (TREE_CODE (val) == FUNCTION_DECL && LAMBDA_FUNCTION_P (val))\n+  /* Look through lambda things that we shouldn't be able to see.  */\n+  if (is_lambda_ignored_entity (val))\n     return false;\n   return true;\n }"}, {"sha": "49aa35e45b95eaec04ae66784272b6bbf67e9406", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ca4737a85b646c6f4f28e5a49e4f89fa44106b/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ca4737a85b646c6f4f28e5a49e4f89fa44106b/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=61ca4737a85b646c6f4f28e5a49e4f89fa44106b", "patch": "@@ -7396,26 +7396,9 @@ cp_parser_lambda_expression (cp_parser* parser)\n       for (elt = LAMBDA_EXPR_CAPTURE_LIST (lambda_expr);\n \t   elt; elt = next)\n \t{\n-\t  tree field = TREE_PURPOSE (elt);\n-\t  char *buf;\n-\n \t  next = TREE_CHAIN (elt);\n \t  TREE_CHAIN (elt) = newlist;\n \t  newlist = elt;\n-\n-\t  /* Also add __ to the beginning of the field name so that code\n-\t     outside the lambda body can't see the captured name.  We could\n-\t     just remove the name entirely, but this is more useful for\n-\t     debugging.  */\n-\t  if (field == LAMBDA_EXPR_THIS_CAPTURE (lambda_expr))\n-\t    /* The 'this' capture already starts with __.  */\n-\t    continue;\n-\n-\t  buf = (char *) alloca (IDENTIFIER_LENGTH (DECL_NAME (field)) + 3);\n-\t  buf[1] = buf[0] = '_';\n-\t  memcpy (buf + 2, IDENTIFIER_POINTER (DECL_NAME (field)),\n-\t\t  IDENTIFIER_LENGTH (DECL_NAME (field)) + 1);\n-\t  DECL_NAME (field) = get_identifier (buf);\n \t}\n       LAMBDA_EXPR_CAPTURE_LIST (lambda_expr) = newlist;\n     }\n@@ -7433,6 +7416,11 @@ cp_parser_lambda_expression (cp_parser* parser)\n   /* This field is only used during parsing of the lambda.  */\n   LAMBDA_EXPR_THIS_CAPTURE (lambda_expr) = NULL_TREE;\n \n+  /* This lambda shouldn't have any proxies left at this point.  */\n+  gcc_assert (LAMBDA_EXPR_PENDING_PROXIES (lambda_expr) == NULL);\n+  /* And now that we're done, push proxies for an enclosing lambda.  */\n+  insert_pending_capture_proxies ();\n+\n   if (ok)\n     return build_lambda_object (lambda_expr);\n   else\n@@ -7499,7 +7487,7 @@ cp_parser_lambda_introducer (cp_parser* parser, tree lambda_expr)\n \t{\n \t  cp_lexer_consume_token (parser->lexer);\n \t  add_capture (lambda_expr,\n-\t\t       /*id=*/get_identifier (\"__this\"),\n+\t\t       /*id=*/this_identifier,\n \t\t       /*initializer=*/finish_this_expr(),\n \t\t       /*by_reference_p=*/false,\n \t\t       explicit_init_p);\n@@ -7701,6 +7689,8 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)\n       {\n \tDECL_INITIALIZED_IN_CLASS_P (fco) = 1;\n \tDECL_ARTIFICIAL (fco) = 1;\n+\t/* Give the object parameter a different name.  */\n+\tDECL_NAME (DECL_ARGUMENTS (fco)) = get_identifier (\"__closure\");\n       }\n \n     finish_member_declaration (fco);\n@@ -7735,6 +7725,7 @@ cp_parser_lambda_body (cp_parser* parser, tree lambda_expr)\n     tree body;\n     bool done = false;\n     tree compound_stmt;\n+    tree cap;\n \n     /* Let the front end know that we are going to be defining this\n        function.  */\n@@ -7748,6 +7739,11 @@ cp_parser_lambda_body (cp_parser* parser, tree lambda_expr)\n     if (!cp_parser_require (parser, CPP_OPEN_BRACE, RT_OPEN_BRACE))\n       goto out;\n \n+    /* Push the proxies for any explicit captures.  */\n+    for (cap = LAMBDA_EXPR_CAPTURE_LIST (lambda_expr); cap;\n+\t cap = TREE_CHAIN (cap))\n+      build_capture_proxy (TREE_PURPOSE (cap));\n+\n     compound_stmt = begin_compound_stmt (0);\n \n     /* 5.1.1.4 of the standard says:"}, {"sha": "85f27497d9004d4d6f6f24269c14980c2d8a5bb3", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ca4737a85b646c6f4f28e5a49e4f89fa44106b/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ca4737a85b646c6f4f28e5a49e4f89fa44106b/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=61ca4737a85b646c6f4f28e5a49e4f89fa44106b", "patch": "@@ -13500,7 +13500,8 @@ tsubst_copy_and_build (tree t,\n \t  = RECUR (LAMBDA_EXPR_CAPTURE_LIST (t));\n \tLAMBDA_EXPR_EXTRA_SCOPE (r)\n \t  = RECUR (LAMBDA_EXPR_EXTRA_SCOPE (t));\n-\tgcc_assert (LAMBDA_EXPR_THIS_CAPTURE (t) == NULL_TREE);\n+\tgcc_assert (LAMBDA_EXPR_THIS_CAPTURE (t) == NULL_TREE\n+\t\t    && LAMBDA_EXPR_PENDING_PROXIES (t) == NULL);\n \n \t/* Do this again now that LAMBDA_EXPR_EXTRA_SCOPE is set.  */\n \tdetermine_visibility (TYPE_NAME (type));"}, {"sha": "76c186249208007bb2f88342213fcc90ac50add5", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 181, "deletions": 51, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ca4737a85b646c6f4f28e5a49e4f89fa44106b/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ca4737a85b646c6f4f28e5a49e4f89fa44106b/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=61ca4737a85b646c6f4f28e5a49e4f89fa44106b", "patch": "@@ -54,7 +54,6 @@ along with GCC; see the file COPYING3.  If not see\n static tree maybe_convert_cond (tree);\n static tree finalize_nrv_r (tree *, int *, void *);\n static tree capture_decltype (tree);\n-static tree thisify_lambda_field (tree);\n \n \n /* Deferred Access Checking Overview\n@@ -2830,18 +2829,6 @@ outer_automatic_var_p (tree decl)\n \t  && DECL_CONTEXT (decl) != current_function_decl);\n }\n \n-/* Returns true iff DECL is a capture field from a lambda that is not our\n-   immediate context.  */\n-\n-static bool\n-outer_lambda_capture_p (tree decl)\n-{\n-  return (TREE_CODE (decl) == FIELD_DECL\n-\t  && LAMBDA_TYPE_P (DECL_CONTEXT (decl))\n-\t  && (!current_class_type\n-\t      || !DERIVED_FROM_P (DECL_CONTEXT (decl), current_class_type)));\n-}\n-\n /* ID_EXPRESSION is a representation of parsed, but unprocessed,\n    id-expression.  (See cp_parser_id_expression for details.)  SCOPE,\n    if non-NULL, is the type or namespace used to explicitly qualify\n@@ -2946,8 +2933,7 @@ finish_id_expression (tree id_expression,\n \n       /* Disallow uses of local variables from containing functions, except\n \t within lambda-expressions.  */\n-      if ((outer_automatic_var_p (decl)\n-\t   || outer_lambda_capture_p (decl))\n+      if (outer_automatic_var_p (decl)\n \t  /* It's not a use (3.2) if we're in an unevaluated context.  */\n \t  && !cp_unevaluated_operand)\n \t{\n@@ -2967,13 +2953,6 @@ finish_id_expression (tree id_expression,\n \t  if (decl_constant_var_p (decl))\n \t    return integral_constant_value (decl);\n \n-\t  if (TYPE_P (context))\n-\t    {\n-\t      /* Implicit capture of an explicit capture.  */\n-\t      context = lambda_function (context);\n-\t      initializer = thisify_lambda_field (decl);\n-\t    }\n-\n \t  /* If we are in a lambda function, we can move out until we hit\n \t     1. the context,\n \t     2. a non-lambda function, or\n@@ -8122,6 +8101,7 @@ build_lambda_expr (void)\n   LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (lambda) = CPLD_NONE;\n   LAMBDA_EXPR_CAPTURE_LIST         (lambda) = NULL_TREE;\n   LAMBDA_EXPR_THIS_CAPTURE         (lambda) = NULL_TREE;\n+  LAMBDA_EXPR_PENDING_PROXIES      (lambda) = NULL;\n   LAMBDA_EXPR_RETURN_TYPE          (lambda) = NULL_TREE;\n   LAMBDA_EXPR_MUTABLE_P            (lambda) = false;\n   return lambda;\n@@ -8399,6 +8379,135 @@ capture_decltype (tree decl)\n   return type;\n }\n \n+/* Returns true iff DECL is a lambda capture proxy variable created by\n+   build_capture_proxy.  */\n+\n+bool\n+is_capture_proxy (tree decl)\n+{\n+  return (TREE_CODE (decl) == VAR_DECL\n+\t  && DECL_HAS_VALUE_EXPR_P (decl)\n+\t  && !DECL_ANON_UNION_VAR_P (decl)\n+\t  && LAMBDA_FUNCTION_P (DECL_CONTEXT (decl)));\n+}\n+\n+/* Returns true iff DECL is a capture proxy for a normal capture\n+   (i.e. without explicit initializer).  */\n+\n+bool\n+is_normal_capture_proxy (tree decl)\n+{\n+  tree val;\n+\n+  if (!is_capture_proxy (decl))\n+    /* It's not a capture proxy.  */\n+    return false;\n+\n+  /* It is a capture proxy, is it a normal capture?  */\n+  val = DECL_VALUE_EXPR (decl);\n+  gcc_assert (TREE_CODE (val) == COMPONENT_REF);\n+  val = TREE_OPERAND (val, 1);\n+  return DECL_NORMAL_CAPTURE_P (val);\n+}\n+\n+/* VAR is a capture proxy created by build_capture_proxy; add it to the\n+   current function, which is the operator() for the appropriate lambda.  */\n+\n+static inline void\n+insert_capture_proxy (tree var)\n+{\n+  cxx_scope *b;\n+  int skip;\n+  tree stmt_list;\n+\n+  /* Put the capture proxy in the extra body block so that it won't clash\n+     with a later local variable.  */\n+  b = current_binding_level;\n+  for (skip = 0; ; ++skip)\n+    {\n+      cxx_scope *n = b->level_chain;\n+      if (n->kind == sk_function_parms)\n+\tbreak;\n+      b = n;\n+    }\n+  pushdecl_with_scope (var, b, false);\n+\n+  /* And put a DECL_EXPR in the STATEMENT_LIST for the same block.  */\n+  var = build_stmt (DECL_SOURCE_LOCATION (var), DECL_EXPR, var);\n+  stmt_list = VEC_index (tree, stmt_list_stack,\n+\t\t\t VEC_length (tree, stmt_list_stack) - 1 - skip);\n+  gcc_assert (stmt_list);\n+  append_to_statement_list_force (var, &stmt_list);\n+}\n+\n+/* We've just finished processing a lambda; if the containing scope is also\n+   a lambda, insert any capture proxies that were created while processing\n+   the nested lambda.  */\n+\n+void\n+insert_pending_capture_proxies (void)\n+{\n+  tree lam;\n+  VEC(tree,gc) *proxies;\n+  unsigned i;\n+\n+  if (!current_function_decl || !LAMBDA_FUNCTION_P (current_function_decl))\n+    return;\n+\n+  lam = CLASSTYPE_LAMBDA_EXPR (DECL_CONTEXT (current_function_decl));\n+  proxies = LAMBDA_EXPR_PENDING_PROXIES (lam);\n+  for (i = 0; i < VEC_length (tree, proxies); ++i)\n+    {\n+      tree var = VEC_index (tree, proxies, i);\n+      insert_capture_proxy (var);\n+    }\n+  release_tree_vector (LAMBDA_EXPR_PENDING_PROXIES (lam));\n+  LAMBDA_EXPR_PENDING_PROXIES (lam) = NULL;\n+}\n+\n+/* MEMBER is a capture field in a lambda closure class.  Now that we're\n+   inside the operator(), build a placeholder var for future lookups and\n+   debugging.  */\n+\n+tree\n+build_capture_proxy (tree member)\n+{\n+  tree var, object, fn, closure, name, lam;\n+\n+  closure = DECL_CONTEXT (member);\n+  fn = lambda_function (closure);\n+  lam = CLASSTYPE_LAMBDA_EXPR (closure);\n+\n+  /* The proxy variable forwards to the capture field.  */\n+  object = build_fold_indirect_ref (DECL_ARGUMENTS (fn));\n+  object = finish_non_static_data_member (member, object, NULL_TREE);\n+  if (REFERENCE_REF_P (object))\n+    object = TREE_OPERAND (object, 0);\n+\n+  /* Remove the __ inserted by add_capture.  */\n+  name = get_identifier (IDENTIFIER_POINTER (DECL_NAME (member)) + 2);\n+\n+  var = build_decl (input_location, VAR_DECL, name, TREE_TYPE (object));\n+  SET_DECL_VALUE_EXPR (var, object);\n+  DECL_HAS_VALUE_EXPR_P (var) = 1;\n+  DECL_ARTIFICIAL (var) = 1;\n+  TREE_USED (var) = 1;\n+  DECL_CONTEXT (var) = fn;\n+\n+  if (name == this_identifier)\n+    {\n+      gcc_assert (LAMBDA_EXPR_THIS_CAPTURE (lam) == member);\n+      LAMBDA_EXPR_THIS_CAPTURE (lam) = var;\n+    }\n+\n+  if (fn == current_function_decl)\n+    insert_capture_proxy (var);\n+  else\n+    VEC_safe_push (tree, gc, LAMBDA_EXPR_PENDING_PROXIES (lam), var);\n+\n+  return var;\n+}\n+\n /* From an ID and INITIALIZER, create a capture (by reference if\n    BY_REFERENCE_P is true), add it to the capture-list for LAMBDA,\n    and return it.  */\n@@ -8419,7 +8528,18 @@ add_capture (tree lambda, tree id, tree initializer, bool by_reference_p,\n     }\n \n   /* Make member variable.  */\n-  member = build_lang_decl (FIELD_DECL, id, type);\n+  {\n+    /* Add __ to the beginning of the field name so that user code\n+       won't find the field with name lookup.  We can't just leave the name\n+       unset because template instantiation uses the name to find\n+       instantiated fields.  */\n+    char *buf = (char *) alloca (IDENTIFIER_LENGTH (id) + 3);\n+    buf[1] = buf[0] = '_';\n+    memcpy (buf + 2, IDENTIFIER_POINTER (id),\n+\t    IDENTIFIER_LENGTH (id) + 1);\n+    member = build_lang_decl (FIELD_DECL, get_identifier (buf), type);\n+  }\n+\n   if (!explicit_init_p)\n     /* Normal captures are invisible to name lookup but uses are replaced\n        with references to the capture field; we implement this by only\n@@ -8435,14 +8555,18 @@ add_capture (tree lambda, tree id, tree initializer, bool by_reference_p,\n   LAMBDA_EXPR_CAPTURE_LIST (lambda)\n     = tree_cons (member, initializer, LAMBDA_EXPR_CAPTURE_LIST (lambda));\n \n-  if (id == get_identifier (\"__this\"))\n+  if (id == this_identifier)\n     {\n       if (LAMBDA_EXPR_CAPTURES_THIS_P (lambda))\n         error (\"already captured %<this%> in lambda expression\");\n       LAMBDA_EXPR_THIS_CAPTURE (lambda) = member;\n     }\n \n-  return member;\n+  if (TREE_TYPE (lambda))\n+    return build_capture_proxy (member);\n+  /* For explicit captures we haven't started the function yet, so we wait\n+     and build the proxy from cp_parser_lambda_body.  */\n+  return NULL_TREE;\n }\n \n /* Register all the capture members on the list CAPTURES, which is the\n@@ -8457,31 +8581,16 @@ void register_capture_members (tree captures)\n     }\n }\n \n-/* Given a FIELD_DECL decl belonging to a closure type, return a\n-   COMPONENT_REF of it relative to the 'this' parameter of the op() for\n-   that type.  */\n-\n-static tree\n-thisify_lambda_field (tree decl)\n-{\n-  tree context = lambda_function (DECL_CONTEXT (decl));\n-  tree object = cp_build_indirect_ref (DECL_ARGUMENTS (context),\n-\t\t\t\t       RO_NULL,\n-\t\t\t\t       tf_warning_or_error);\n-  return finish_non_static_data_member (decl, object,\n-\t\t\t\t\t/*qualifying_scope*/NULL_TREE);\n-}\n-\n /* Similar to add_capture, except this works on a stack of nested lambdas.\n    BY_REFERENCE_P in this case is derived from the default capture mode.\n    Returns the capture for the lambda at the bottom of the stack.  */\n \n tree\n add_default_capture (tree lambda_stack, tree id, tree initializer)\n {\n-  bool this_capture_p = (id == get_identifier (\"__this\"));\n+  bool this_capture_p = (id == this_identifier);\n \n-  tree member = NULL_TREE;\n+  tree var = NULL_TREE;\n \n   tree saved_class_type = current_class_type;\n \n@@ -8494,20 +8603,20 @@ add_default_capture (tree lambda_stack, tree id, tree initializer)\n       tree lambda = TREE_VALUE (node);\n \n       current_class_type = TREE_TYPE (lambda);\n-      member = add_capture (lambda,\n+      var = add_capture (lambda,\n                             id,\n                             initializer,\n                             /*by_reference_p=*/\n \t\t\t    (!this_capture_p\n \t\t\t     && (LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (lambda)\n \t\t\t\t == CPLD_REFERENCE)),\n \t\t\t    /*explicit_init_p=*/false);\n-      initializer = thisify_lambda_field (member);\n+      initializer = convert_from_reference (var);\n     }\n \n   current_class_type = saved_class_type;\n \n-  return member;\n+  return var;\n }\n \n /* Return the capture pertaining to a use of 'this' in LAMBDA, in the form of an\n@@ -8540,8 +8649,7 @@ lambda_expr_this_capture (tree lambda)\n           if (LAMBDA_EXPR_THIS_CAPTURE (lambda))\n \t    {\n \t      /* An outer lambda has already captured 'this'.  */\n-\t      tree cap = LAMBDA_EXPR_THIS_CAPTURE (lambda);\n-\t      init = thisify_lambda_field (cap);\n+\t      init = LAMBDA_EXPR_THIS_CAPTURE (lambda);\n \t      break;\n \t    }\n \n@@ -8563,7 +8671,7 @@ lambda_expr_this_capture (tree lambda)\n \n       if (init)\n \tthis_capture = add_default_capture (lambda_stack,\n-\t\t\t\t\t    /*id=*/get_identifier (\"__this\"),\n+\t\t\t\t\t    /*id=*/this_identifier,\n \t\t\t\t\t    init);\n     }\n \n@@ -8577,9 +8685,7 @@ lambda_expr_this_capture (tree lambda)\n       /* To make sure that current_class_ref is for the lambda.  */\n       gcc_assert (TYPE_MAIN_VARIANT (TREE_TYPE (current_class_ref)) == TREE_TYPE (lambda));\n \n-      result = finish_non_static_data_member (this_capture,\n-                                              NULL_TREE,\n-                                              /*qualifying_scope=*/NULL_TREE);\n+      result = this_capture;\n \n       /* If 'this' is captured, each use of 'this' is transformed into an\n \t access to the corresponding unnamed data member of the closure\n@@ -8752,4 +8858,28 @@ maybe_add_lambda_conv_op (tree type)\n   if (nested)\n     pop_function_context ();\n }\n+\n+/* Returns true iff VAL is a lambda-related declaration which should\n+   be ignored by unqualified lookup.  */\n+\n+bool\n+is_lambda_ignored_entity (tree val)\n+{\n+  /* In unevaluated context, look past normal capture proxies.  */\n+  if (cp_unevaluated_operand && is_normal_capture_proxy (val))\n+    return true;\n+\n+  /* Always ignore lambda fields, their names are only for debugging.  */\n+  if (TREE_CODE (val) == FIELD_DECL\n+      && CLASSTYPE_LAMBDA_EXPR (DECL_CONTEXT (val)))\n+    return true;\n+\n+  /* None of the lookups that use qualify_lookup want the op() from the\n+     lambda; they want the one from the enclosing class.  */\n+  if (TREE_CODE (val) == FUNCTION_DECL && LAMBDA_FUNCTION_P (val))\n+    return true;\n+\n+  return false;\n+}\n+\n #include \"gt-cp-semantics.h\""}, {"sha": "805c5b178f1918406e8d3dead671eebdd87d6273", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ca4737a85b646c6f4f28e5a49e4f89fa44106b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ca4737a85b646c6f4f28e5a49e4f89fa44106b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=61ca4737a85b646c6f4f28e5a49e4f89fa44106b", "patch": "@@ -1,3 +1,8 @@\n+2011-06-17  Jason Merrill  <jason@redhat.com>\n+\n+\t* g++.dg/debug/dwarf2/lambda1.C: New.\n+\t* g++.dg/warn/Wshadow-6.C: Adjust.\n+\n 2011-06-17  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/48699"}, {"sha": "ee24eca22a480ad18478fbc61bdfd8253d7b565e", "filename": "gcc/testsuite/g++.dg/debug/dwarf2/lambda1.C", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ca4737a85b646c6f4f28e5a49e4f89fa44106b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Flambda1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ca4737a85b646c6f4f28e5a49e4f89fa44106b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Flambda1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Flambda1.C?ref=61ca4737a85b646c6f4f28e5a49e4f89fa44106b", "patch": "@@ -0,0 +1,35 @@\n+// PR c++/43912\n+// { dg-options \"-g -std=c++0x -dA -fno-merge-debug-strings -gno-strict-dwarf\" }\n+\n+// Check for the local alias variables that point to the members of the closure.\n+// { dg-final { scan-assembler-times \"DW_TAG_variable\\[^.\\]*\\.ascii \\\"j.0\\\"\" 4 } }\n+// { dg-final { scan-assembler-times \"DW_TAG_variable\\[^.\\]*\\.ascii \\\"this.0\\\"\" 2 } }\n+\n+struct A\n+{\n+  int i;\n+  int f()\n+  {\n+    int j;\n+    [&]() { j = i; }();\n+    return j;\n+  }\n+};\n+\n+template <class T>\n+struct B\n+{\n+  int i;\n+  int f()\n+  {\n+    int j;\n+    [&]() { j = i; }();\n+    return j;\n+  }\n+};\n+\n+int main()\n+{\n+  A().f();\n+  B<int>().f();\n+}"}, {"sha": "fdc37df31b4966242e351daa101f68bb249f13aa", "filename": "gcc/testsuite/g++.dg/warn/Wshadow-6.C", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ca4737a85b646c6f4f28e5a49e4f89fa44106b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWshadow-6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ca4737a85b646c6f4f28e5a49e4f89fa44106b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWshadow-6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWshadow-6.C?ref=61ca4737a85b646c6f4f28e5a49e4f89fa44106b", "patch": "@@ -33,7 +33,19 @@ void f2(struct S i, int j) {\n \n void f3(int i) {\n  [=]{\n-   int j = i;\n-   int i; // { dg-warning \"shadows a member of\" }\n+   int j = i;\t\t\t// { dg-warning \"shadowed declaration\" }\n+   int i;\t\t\t// { dg-warning \"shadows a lambda capture\" }\n+   i = 1;\n  };\n }\n+\n+template <class T>\n+void f4(int i) {\n+ [=]{\n+   int j = i;\t\t\t// { dg-warning \"shadowed declaration\" }\n+   int i;\t\t\t// { dg-warning \"shadows a lambda capture\" }\n+   i = 1;\n+ };\n+}\n+\n+template void f4<int>(int);"}]}