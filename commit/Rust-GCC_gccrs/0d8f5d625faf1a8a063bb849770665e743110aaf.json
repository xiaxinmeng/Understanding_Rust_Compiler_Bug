{"sha": "0d8f5d625faf1a8a063bb849770665e743110aaf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGQ4ZjVkNjI1ZmFmMWE4YTA2M2JiODQ5NzcwNjY1ZTc0MzExMGFhZg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2012-01-02T13:56:36Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2012-01-02T13:56:36Z"}, "message": "expr.h (move_by_pieces_ninsns): Declare.\n\ngcc/\n\t* expr.h (move_by_pieces_ninsns): Declare.\n\t* expr.c (move_by_pieces_ninsns): Make external.\n\t* config/mips/mips-protos.h (mips_move_by_pieces_p): Declare.\n\t(mips_store_by_pieces_p): Likewise.\n\t* config/mips/mips.h (MOVE_BY_PIECES_P): Call mips_move_by_pieces_p.\n\t(STORE_BY_PIECES_P): Likewise mips_store_by_pieces_p.\n\t* config/mips/mips.c (mips_move_by_pieces_p): New function.\n\t(mips_store_by_pieces_p): Likewise.\n\ngcc/testsuite/\n\t* gcc.dg/memcpy-4.c: Add nomips16 attribute for MIPS targets.\n\tIncrease copy to 5 bytes.  Look for at least two \"mem/s/u\"s,\n\trather than a specific number.\n\nFrom-SVN: r182801", "tree": {"sha": "39f96b35ec1e219ff6c91560fb53beab4a2ffdcc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/39f96b35ec1e219ff6c91560fb53beab4a2ffdcc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d8f5d625faf1a8a063bb849770665e743110aaf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d8f5d625faf1a8a063bb849770665e743110aaf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d8f5d625faf1a8a063bb849770665e743110aaf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d8f5d625faf1a8a063bb849770665e743110aaf/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9f929ce61f62c3dd84bb773b056652cadeebdec5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f929ce61f62c3dd84bb773b056652cadeebdec5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f929ce61f62c3dd84bb773b056652cadeebdec5"}], "stats": {"total": 152, "additions": 119, "deletions": 33}, "files": [{"sha": "4cdef41ddcaa5fe1baa9aab34e960e1be2c1bcbe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d8f5d625faf1a8a063bb849770665e743110aaf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d8f5d625faf1a8a063bb849770665e743110aaf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0d8f5d625faf1a8a063bb849770665e743110aaf", "patch": "@@ -1,3 +1,14 @@\n+2012-01-02  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* expr.h (move_by_pieces_ninsns): Declare.\n+\t* expr.c (move_by_pieces_ninsns): Make external.\n+\t* config/mips/mips-protos.h (mips_move_by_pieces_p): Declare.\n+\t(mips_store_by_pieces_p): Likewise.\n+\t* config/mips/mips.h (MOVE_BY_PIECES_P): Call mips_move_by_pieces_p.\n+\t(STORE_BY_PIECES_P): Likewise mips_store_by_pieces_p.\n+\t* config/mips/mips.c (mips_move_by_pieces_p): New function.\n+\t(mips_store_by_pieces_p): Likewise.\n+\n 2012-01-02  Jakub Jelinek  <jakub@redhat.com>\n \n \t* passes.c (register_one_dump_file): Free full_name."}, {"sha": "ca0fb5eba677f17774abd19f36989745941d8524", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d8f5d625faf1a8a063bb849770665e743110aaf/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d8f5d625faf1a8a063bb849770665e743110aaf/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=0d8f5d625faf1a8a063bb849770665e743110aaf", "patch": "@@ -239,6 +239,8 @@ extern void mips_split_call (rtx, rtx);\n extern bool mips_get_pic_call_symbol (rtx *, int);\n extern void mips_expand_fcc_reload (rtx, rtx, rtx);\n extern void mips_set_return_address (rtx, rtx);\n+extern bool mips_move_by_pieces_p (unsigned HOST_WIDE_INT, unsigned int);\n+extern bool mips_store_by_pieces_p (unsigned HOST_WIDE_INT, unsigned int);\n extern bool mips_expand_block_move (rtx, rtx, rtx);\n extern void mips_expand_synci_loop (rtx, rtx);\n "}, {"sha": "7b3b6852cc96156993740914165a9c7a9daa7fd6", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d8f5d625faf1a8a063bb849770665e743110aaf/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d8f5d625faf1a8a063bb849770665e743110aaf/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=0d8f5d625faf1a8a063bb849770665e743110aaf", "patch": "@@ -6537,6 +6537,92 @@ mips_expand_fcc_reload (rtx dest, rtx src, rtx scratch)\n   emit_insn (gen_slt_sf (dest, fp2, fp1));\n }\n \f\n+/* Implement MOVE_BY_PIECES_P.  */\n+\n+bool\n+mips_move_by_pieces_p (unsigned HOST_WIDE_INT size, unsigned int align)\n+{\n+  if (HAVE_movmemsi)\n+    {\n+      /* movmemsi is meant to generate code that is at least as good as\n+\t move_by_pieces.  However, movmemsi effectively uses a by-pieces\n+\t implementation both for moves smaller than a word and for\n+\t word-aligned moves of no more than MIPS_MAX_MOVE_BYTES_STRAIGHT\n+\t bytes.  We should allow the tree-level optimisers to do such\n+\t moves by pieces, as it often exposes other optimization\n+\t opportunities.  We might as well continue to use movmemsi at\n+\t the rtl level though, as it produces better code when\n+\t scheduling is disabled (such as at -O).  */\n+      if (currently_expanding_to_rtl)\n+\treturn false;\n+      if (align < BITS_PER_WORD)\n+\treturn size < UNITS_PER_WORD;\n+      return size <= MIPS_MAX_MOVE_BYTES_STRAIGHT;\n+    }\n+  /* The default value.  If this becomes a target hook, we should\n+     call the default definition instead.  */\n+  return (move_by_pieces_ninsns (size, align, MOVE_MAX_PIECES + 1)\n+\t  < (unsigned int) MOVE_RATIO (optimize_insn_for_speed_p ()));\n+}\n+\n+/* Implement STORE_BY_PIECES_P.  */\n+\n+bool\n+mips_store_by_pieces_p (unsigned HOST_WIDE_INT size, unsigned int align)\n+{\n+  /* Storing by pieces involves moving constants into registers\n+     of size MIN (ALIGN, BITS_PER_WORD), then storing them.\n+     We need to decide whether it is cheaper to load the address of\n+     constant data into a register and use a block move instead.  */\n+\n+  /* If the data is only byte aligned, then:\n+\n+     (a1) A block move of less than 4 bytes would involve three 3 LBs and\n+\t  3 SBs.  We might as well use 3 single-instruction LIs and 3 SBs\n+\t  instead.\n+\n+     (a2) A block move of 4 bytes from aligned source data can use an\n+\t  LW/SWL/SWR sequence.  This is often better than the 4 LIs and\n+\t  4 SBs that we would generate when storing by pieces.  */\n+  if (align <= BITS_PER_UNIT)\n+    return size < 4;\n+\n+  /* If the data is 2-byte aligned, then:\n+\n+     (b1) A block move of less than 4 bytes would use a combination of LBs,\n+\t  LHs, SBs and SHs.  We get better code by using single-instruction\n+\t  LIs, SBs and SHs instead.\n+\n+     (b2) A block move of 4 bytes from aligned source data would again use\n+\t  an LW/SWL/SWR sequence.  In most cases, loading the address of\n+\t  the source data would require at least one extra instruction.\n+\t  It is often more efficient to use 2 single-instruction LIs and\n+\t  2 SHs instead.\n+\n+     (b3) A block move of up to 3 additional bytes would be like (b1).\n+\n+     (b4) A block move of 8 bytes from aligned source data can use two\n+\t  LW/SWL/SWR sequences or a single LD/SDL/SDR sequence.  Both\n+\t  sequences are better than the 4 LIs and 4 SHs that we'd generate\n+\t  when storing by pieces.\n+\n+     The reasoning for higher alignments is similar:\n+\n+     (c1) A block move of less than 4 bytes would be the same as (b1).\n+\n+     (c2) A block move of 4 bytes would use an LW/SW sequence.  Again,\n+\t  loading the address of the source data would typically require\n+\t  at least one extra instruction.  It is generally better to use\n+\t  LUI/ORI/SW instead.\n+\n+     (c3) A block move of up to 3 additional bytes would be like (b1).\n+\n+     (c4) A block move of 8 bytes can use two LW/SW sequences or a single\n+\t  LD/SD sequence, and in these cases we've traditionally preferred\n+\t  the memory copy over the more bulky constant moves.  */\n+  return size < 8;\n+}\n+\n /* Emit straight-line code to move LENGTH bytes from SRC to DEST.\n    Assume that the areas do not overlap.  */\n "}, {"sha": "23d40baf9a6e76624550ed77258bfb07bb3fe840", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 4, "deletions": 27, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d8f5d625faf1a8a063bb849770665e743110aaf/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d8f5d625faf1a8a063bb849770665e743110aaf/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=0d8f5d625faf1a8a063bb849770665e743110aaf", "patch": "@@ -2782,23 +2782,8 @@ while (0)\n    ? MIPS_MAX_MOVE_BYTES_STRAIGHT / MOVE_MAX\t\t\\\n    : MIPS_CALL_RATIO / 2)\n \n-/* movmemsi is meant to generate code that is at least as good as\n-   move_by_pieces.  However, movmemsi effectively uses a by-pieces\n-   implementation both for moves smaller than a word and for word-aligned\n-   moves of no more than MIPS_MAX_MOVE_BYTES_STRAIGHT bytes.  We should\n-   allow the tree-level optimisers to do such moves by pieces, as it\n-   often exposes other optimization opportunities.  We might as well\n-   continue to use movmemsi at the rtl level though, as it produces\n-   better code when scheduling is disabled (such as at -O).  */\n-\n-#define MOVE_BY_PIECES_P(SIZE, ALIGN)\t\t\t\t\\\n-  (HAVE_movmemsi\t\t\t\t\t\t\\\n-   ? (!currently_expanding_to_rtl\t\t\t\t\\\n-      && ((ALIGN) < BITS_PER_WORD\t\t\t\t\\\n-\t  ? (SIZE) < UNITS_PER_WORD\t\t\t\t\\\n-\t  : (SIZE) <= MIPS_MAX_MOVE_BYTES_STRAIGHT))\t\t\\\n-   : (move_by_pieces_ninsns (SIZE, ALIGN, MOVE_MAX_PIECES + 1)\t\\\n-      < (unsigned int) MOVE_RATIO (false)))\n+#define MOVE_BY_PIECES_P(SIZE, ALIGN) \\\n+  mips_move_by_pieces_p (SIZE, ALIGN)\n \n /* For CLEAR_RATIO, when optimizing for size, give a better estimate\n    of the length of a memset call, but use the default otherwise.  */\n@@ -2813,16 +2798,8 @@ while (0)\n #define SET_RATIO(speed) \\\n   ((speed) ? 15 : MIPS_CALL_RATIO - 2)\n \n-/* STORE_BY_PIECES_P can be used when copying a constant string, but\n-   in that case each word takes 3 insns (lui, ori, sw), or more in\n-   64-bit mode, instead of 2 (lw, sw).  For now we always fail this\n-   and let the move_by_pieces code copy the string from read-only\n-   memory.  In the future, this could be tuned further for multi-issue\n-   CPUs that can issue stores down one pipe and arithmetic instructions\n-   down another; in that case, the lui/ori/sw combination would be a\n-   win for long enough strings.  */\n-\n-#define STORE_BY_PIECES_P(SIZE, ALIGN) 0\n+#define STORE_BY_PIECES_P(SIZE, ALIGN) \\\n+  mips_store_by_pieces_p (SIZE, ALIGN)\n \f\n #ifndef __mips16\n /* Since the bits of the _init and _fini function is spread across"}, {"sha": "9825d126df47d8f3d5ec0a04315d172e19a0222e", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d8f5d625faf1a8a063bb849770665e743110aaf/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d8f5d625faf1a8a063bb849770665e743110aaf/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=0d8f5d625faf1a8a063bb849770665e743110aaf", "patch": "@@ -123,9 +123,6 @@ struct store_by_pieces_d\n   int reverse;\n };\n \n-static unsigned HOST_WIDE_INT move_by_pieces_ninsns (unsigned HOST_WIDE_INT,\n-\t\t\t\t\t\t     unsigned int,\n-\t\t\t\t\t\t     unsigned int);\n static void move_by_pieces_1 (rtx (*) (rtx, ...), enum machine_mode,\n \t\t\t      struct move_by_pieces_d *);\n static bool block_move_libcall_safe_for_call_parm (void);\n@@ -1016,7 +1013,7 @@ move_by_pieces (rtx to, rtx from, unsigned HOST_WIDE_INT len,\n /* Return number of insns required to move L bytes by pieces.\n    ALIGN (in bits) is maximum alignment we can assume.  */\n \n-static unsigned HOST_WIDE_INT\n+unsigned HOST_WIDE_INT\n move_by_pieces_ninsns (unsigned HOST_WIDE_INT l, unsigned int align,\n \t\t       unsigned int max_size)\n {"}, {"sha": "0096367a7272bc2622a8c1835274c6bd75641e93", "filename": "gcc/expr.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d8f5d625faf1a8a063bb849770665e743110aaf/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d8f5d625faf1a8a063bb849770665e743110aaf/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=0d8f5d625faf1a8a063bb849770665e743110aaf", "patch": "@@ -367,6 +367,10 @@ extern bool set_storage_via_setmem (rtx, rtx, rtx, unsigned int,\n    succeed.  */\n extern int can_move_by_pieces (unsigned HOST_WIDE_INT, unsigned int);\n \n+extern unsigned HOST_WIDE_INT move_by_pieces_ninsns (unsigned HOST_WIDE_INT,\n+\t\t\t\t\t\t     unsigned int,\n+\t\t\t\t\t\t     unsigned int);\n+\n /* Return nonzero if it is desirable to store LEN bytes generated by\n    CONSTFUN with several move instructions by store_by_pieces\n    function.  CONSTFUNDATA is a pointer which will be passed as argument"}, {"sha": "dd29a88d25ed7e1d71994ee716539123187003ef", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d8f5d625faf1a8a063bb849770665e743110aaf/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d8f5d625faf1a8a063bb849770665e743110aaf/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0d8f5d625faf1a8a063bb849770665e743110aaf", "patch": "@@ -1,3 +1,9 @@\n+2012-01-02  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* gcc.dg/memcpy-4.c: Add nomips16 attribute for MIPS targets.\n+\tIncrease copy to 5 bytes.  Look for at least two \"mem/s/u\"s,\n+\trather than a specific number.\n+\n 2012-01-02  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/46262"}, {"sha": "80a943bdb78813d5c781c0dafe9cf5007a02b8d3", "filename": "gcc/testsuite/gcc.dg/memcpy-4.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d8f5d625faf1a8a063bb849770665e743110aaf/gcc%2Ftestsuite%2Fgcc.dg%2Fmemcpy-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d8f5d625faf1a8a063bb849770665e743110aaf/gcc%2Ftestsuite%2Fgcc.dg%2Fmemcpy-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fmemcpy-4.c?ref=0d8f5d625faf1a8a063bb849770665e743110aaf", "patch": "@@ -1,11 +1,14 @@\n /* { dg-do compile } */\n /* { dg-options \"-O2 -fdump-rtl-expand\" } */\n \n+#ifdef __mips\n+__attribute__((nomips16))\n+#endif\n void\n f1 (char *p)\n {\n-  __builtin_memcpy (p, \"123\", 3);\n+  __builtin_memcpy (p, \"12345\", 5);\n }\n \n-/* { dg-final { scan-rtl-dump-times \"mem/s/u\" 3 \"expand\" { target mips*-*-* } } } */\n+/* { dg-final { scan-rtl-dump \"mem/s/u.*mem/s/u\" \"expand\" { target mips*-*-* } } } */\n /* { dg-final { cleanup-rtl-dump \"expand\" } } */"}]}