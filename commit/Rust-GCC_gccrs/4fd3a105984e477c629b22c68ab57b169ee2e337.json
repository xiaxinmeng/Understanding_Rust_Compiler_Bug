{"sha": "4fd3a105984e477c629b22c68ab57b169ee2e337", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGZkM2ExMDU5ODRlNDc3YzYyOWIyMmM2OGFiNTdiMTY5ZWUyZTMzNw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2011-04-15T09:35:03Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2011-04-15T09:35:03Z"}, "message": "recog.h (insn_operand_data): Add an \"allows_mem\" field.\n\ngcc/\n\t* recog.h (insn_operand_data): Add an \"allows_mem\" field.\n\t* genoutput.c (output_operand_data): Initialize it.\n\t* optabs.c (maybe_legitimize_operand_same_code): New function.\n\t(maybe_legitimize_operand): Use it when matching the original\n\top->value.\n\nFrom-SVN: r172478", "tree": {"sha": "eb9aba60245750798ddf9fd86d5946bc2c46db01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb9aba60245750798ddf9fd86d5946bc2c46db01"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4fd3a105984e477c629b22c68ab57b169ee2e337", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fd3a105984e477c629b22c68ab57b169ee2e337", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fd3a105984e477c629b22c68ab57b169ee2e337", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fd3a105984e477c629b22c68ab57b169ee2e337/comments", "author": null, "committer": null, "parents": [{"sha": "b98b952feb6aea1e33371d0b64a9622603ac146e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b98b952feb6aea1e33371d0b64a9622603ac146e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b98b952feb6aea1e33371d0b64a9622603ac146e"}], "stats": {"total": 87, "additions": 71, "deletions": 16}, "files": [{"sha": "23f963d8e98ed11a4caf873ca59b005dcdd742a1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fd3a105984e477c629b22c68ab57b169ee2e337/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fd3a105984e477c629b22c68ab57b169ee2e337/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4fd3a105984e477c629b22c68ab57b169ee2e337", "patch": "@@ -1,3 +1,11 @@\n+2011-04-15  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* recog.h (insn_operand_data): Add an \"allows_mem\" field.\n+\t* genoutput.c (output_operand_data): Initialize it.\n+\t* optabs.c (maybe_legitimize_operand_same_code): New function.\n+\t(maybe_legitimize_operand): Use it when matching the original\n+\top->value.\n+\n 2011-04-15  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gimplify.c: Fix issues in comments throughout."}, {"sha": "621439f479acb4bf31cb45641ca7293ce252c30b", "filename": "gcc/genoutput.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fd3a105984e477c629b22c68ab57b169ee2e337/gcc%2Fgenoutput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fd3a105984e477c629b22c68ab57b169ee2e337/gcc%2Fgenoutput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenoutput.c?ref=4fd3a105984e477c629b22c68ab57b169ee2e337", "patch": "@@ -66,6 +66,8 @@ along with GCC; see the file COPYING3.  If not see\n      MATCH_OPERAND; it is zero for operands that should not be changed during\n      register elimination such as MATCH_OPERATORs.\n \n+     g. `allows_mem', is true for operands that accept MEM rtxes.\n+\n   The code number of an insn is simply its position in the machine\n   description; code numbers are assigned sequentially to entries in\n   the description, starting with code number 0.\n@@ -256,6 +258,8 @@ output_operand_data (void)\n \n   for (d = odata; d; d = d->next)\n     {\n+      struct pred_data *pred;\n+\n       printf (\"  {\\n\");\n \n       printf (\"    %s,\\n\",\n@@ -269,7 +273,12 @@ output_operand_data (void)\n \n       printf (\"    %d,\\n\", d->constraint == NULL ? 1 : 0);\n \n-      printf (\"    %d\\n\", d->eliminable);\n+      printf (\"    %d,\\n\", d->eliminable);\n+\n+      pred = NULL;\n+      if (d->predicate)\n+\tpred = lookup_predicate (d->predicate);\n+      printf (\"    %d\\n\", pred && pred->codes[MEM]);\n \n       printf(\"  },\\n\");\n     }"}, {"sha": "34bd731c3b3a92d67bf3520c15a148829c499cf2", "filename": "gcc/optabs.c", "status": "modified", "additions": 51, "deletions": 15, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fd3a105984e477c629b22c68ab57b169ee2e337/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fd3a105984e477c629b22c68ab57b169ee2e337/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=4fd3a105984e477c629b22c68ab57b169ee2e337", "patch": "@@ -7001,6 +7001,41 @@ insn_operand_matches (enum insn_code icode, unsigned int opno, rtx operand)\n \t      (operand, insn_data[(int) icode].operand[opno].mode)));\n }\n \f\n+/* Like maybe_legitimize_operand, but do not change the code of the\n+   current rtx value.  */\n+\n+static bool\n+maybe_legitimize_operand_same_code (enum insn_code icode, unsigned int opno,\n+\t\t\t\t    struct expand_operand *op)\n+{\n+  /* See if the operand matches in its current form.  */\n+  if (insn_operand_matches (icode, opno, op->value))\n+    return true;\n+\n+  /* If the operand is a memory whose address has no side effects,\n+     try forcing the address into a register.  The check for side\n+     effects is important because force_reg cannot handle things\n+     like auto-modified addresses.  */\n+  if (insn_data[(int) icode].operand[opno].allows_mem\n+      && MEM_P (op->value)\n+      && !side_effects_p (XEXP (op->value, 0)))\n+    {\n+      rtx addr, mem, last;\n+\n+      last = get_last_insn ();\n+      addr = force_reg (Pmode, XEXP (op->value, 0));\n+      mem = replace_equiv_address (op->value, addr);\n+      if (insn_operand_matches (icode, opno, mem))\n+\t{\n+\t  op->value = mem;\n+\t  return true;\n+\t}\n+      delete_insns_since (last);\n+    }\n+\n+  return false;\n+}\n+\n /* Try to make OP match operand OPNO of instruction ICODE.  Return true\n    on success, storing the new operand value back in OP.  */\n \n@@ -7011,32 +7046,36 @@ maybe_legitimize_operand (enum insn_code icode, unsigned int opno,\n   enum machine_mode mode, imode;\n   bool old_volatile_ok, result;\n \n-  old_volatile_ok = volatile_ok;\n   mode = op->mode;\n-  result = false;\n   switch (op->type)\n     {\n     case EXPAND_FIXED:\n+      old_volatile_ok = volatile_ok;\n       volatile_ok = true;\n-      break;\n+      result = maybe_legitimize_operand_same_code (icode, opno, op);\n+      volatile_ok = old_volatile_ok;\n+      return result;\n \n     case EXPAND_OUTPUT:\n       gcc_assert (mode != VOIDmode);\n-      if (!op->value\n-\t  || op->value == const0_rtx\n-\t  || GET_MODE (op->value) != mode\n-\t  || !insn_operand_matches (icode, opno, op->value))\n-\top->value = gen_reg_rtx (mode);\n+      if (op->value\n+\t  && op->value != const0_rtx\n+\t  && GET_MODE (op->value) == mode\n+\t  && maybe_legitimize_operand_same_code (icode, opno, op))\n+\treturn true;\n+\n+      op->value = gen_reg_rtx (mode);\n       break;\n \n     case EXPAND_INPUT:\n     input:\n       gcc_assert (mode != VOIDmode);\n       gcc_assert (GET_MODE (op->value) == VOIDmode\n \t\t  || GET_MODE (op->value) == mode);\n-      result = insn_operand_matches (icode, opno, op->value);\n-      if (!result)\n-\top->value = copy_to_mode_reg (mode, op->value);\n+      if (maybe_legitimize_operand_same_code (icode, opno, op))\n+\treturn true;\n+\n+      op->value = copy_to_mode_reg (mode, op->value);\n       break;\n \n     case EXPAND_CONVERT_TO:\n@@ -7070,10 +7109,7 @@ maybe_legitimize_operand (enum insn_code icode, unsigned int opno,\n \tgoto input;\n       break;\n     }\n-  if (!result)\n-    result = insn_operand_matches (icode, opno, op->value);\n-  volatile_ok = old_volatile_ok;\n-  return result;\n+  return insn_operand_matches (icode, opno, op->value);\n }\n \n /* Make OP describe an input operand that should have the same value"}, {"sha": "cce1321ad09d605e68963066f29039062b41f58a", "filename": "gcc/recog.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fd3a105984e477c629b22c68ab57b169ee2e337/gcc%2Frecog.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fd3a105984e477c629b22c68ab57b169ee2e337/gcc%2Frecog.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.h?ref=4fd3a105984e477c629b22c68ab57b169ee2e337", "patch": "@@ -272,6 +272,8 @@ struct insn_operand_data\n   const char is_operator;\n \n   const char eliminable;\n+\n+  const char allows_mem;\n };\n \n /* Legal values for insn_data.output_format.  Indicate what type of data"}]}