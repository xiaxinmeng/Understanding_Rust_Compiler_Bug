{"sha": "198c56052ea8cce4196e60c0dc3187bf3d67a786", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTk4YzU2MDUyZWE4Y2NlNDE5NmU2MGMwZGMzMTg3YmYzZDY3YTc4Ng==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-02-23T02:49:25Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-02-23T02:49:25Z"}, "message": "libstdc++: Fix endianness issue with IBM long double [PR98384]\n\nThe code in std::to_chars for extracting the high- and low-order parts\nof an IBM long double value does the right thing on powerpc64le, but not\non powerpc64be.  This patch makes the extraction endian-agnostic, which\nfixes the execution FAIL of to_chars/long_double.cc on powerpc64be.\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/98384\n\t* src/c++17/floating_to_chars.cc (get_ieee_repr): Extract\n\tthe high- and low-order parts from an IBM long double value\n\tin an endian-agnostic way.", "tree": {"sha": "d9010dc6e17481f992b1c04c2f49f1970febd20a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d9010dc6e17481f992b1c04c2f49f1970febd20a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/198c56052ea8cce4196e60c0dc3187bf3d67a786", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/198c56052ea8cce4196e60c0dc3187bf3d67a786", "html_url": "https://github.com/Rust-GCC/gccrs/commit/198c56052ea8cce4196e60c0dc3187bf3d67a786", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/198c56052ea8cce4196e60c0dc3187bf3d67a786/comments", "author": null, "committer": null, "parents": [{"sha": "635cf58ca34487ae044b5c7a04eb2bab6fdfddfe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/635cf58ca34487ae044b5c7a04eb2bab6fdfddfe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/635cf58ca34487ae044b5c7a04eb2bab6fdfddfe"}], "stats": {"total": 8, "additions": 4, "deletions": 4}, "files": [{"sha": "4b2f85c1c1ae8f59eacc41cb52ab589eadb27fc8", "filename": "libstdc++-v3/src/c++17/floating_to_chars.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/198c56052ea8cce4196e60c0dc3187bf3d67a786/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffloating_to_chars.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/198c56052ea8cce4196e60c0dc3187bf3d67a786/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffloating_to_chars.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffloating_to_chars.cc?ref=198c56052ea8cce4196e60c0dc3187bf3d67a786", "patch": "@@ -395,11 +395,11 @@ namespace\n       // of the high part, and we merge the mantissa of the high part with the\n       // mantissa (and the implicit leading bit) of the low part.\n       using uint_t = unsigned __int128;\n-      uint_t value_bits = 0;\n-      memcpy(&value_bits, &value, sizeof(value_bits));\n+      uint64_t value_bits[2] = {};\n+      memcpy(value_bits, &value, sizeof(value_bits));\n \n-      const uint64_t value_hi = value_bits;\n-      const uint64_t value_lo = value_bits >> 64;\n+      const uint64_t value_hi = value_bits[0];\n+      const uint64_t value_lo = value_bits[1];\n \n       uint64_t mantissa_hi = value_hi & ((1ull << 52) - 1);\n       unsigned exponent_hi = (value_hi >> 52) & ((1ull << 11) - 1);"}]}