{"sha": "53929c47c5c916744f34d54b63b1d984a3e2584f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTM5MjljNDdjNWM5MTY3NDRmMzRkNTRiNjNiMWQ5ODRhM2UyNTg0Zg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1998-07-21T18:16:09Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-07-21T18:16:09Z"}, "message": "tree.c (canonical_type_variant): New fn to handle arrays.\n\n\t* tree.c (canonical_type_variant): New fn to handle arrays.\n\t* cp-tree.h (CANONICAL_TYPE_VARIANT): Remove.\n\t* pt.c (unify, default case): Also fold arg.  Fix array bounds case.\n\t* method.c (process_overload_item): Use build_overload_value for\n\tarrays.\n\nFrom-SVN: r21324", "tree": {"sha": "0b2855de1f9510faeb9530706b33e1d2820ef2b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b2855de1f9510faeb9530706b33e1d2820ef2b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/53929c47c5c916744f34d54b63b1d984a3e2584f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53929c47c5c916744f34d54b63b1d984a3e2584f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53929c47c5c916744f34d54b63b1d984a3e2584f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53929c47c5c916744f34d54b63b1d984a3e2584f/comments", "author": null, "committer": null, "parents": [{"sha": "e675f62571a8c234341b972a5edcd051a25d8367", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e675f62571a8c234341b972a5edcd051a25d8367", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e675f62571a8c234341b972a5edcd051a25d8367"}], "stats": {"total": 119, "additions": 75, "deletions": 44}, "files": [{"sha": "d9cace222edc0d4443c715381767214a0a4bf7f0", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53929c47c5c916744f34d54b63b1d984a3e2584f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53929c47c5c916744f34d54b63b1d984a3e2584f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=53929c47c5c916744f34d54b63b1d984a3e2584f", "patch": "@@ -1,3 +1,11 @@\n+1998-07-21  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* tree.c (canonical_type_variant): New fn to handle arrays.\n+\t* cp-tree.h (CANONICAL_TYPE_VARIANT): Remove.\n+\t* pt.c (unify, default case): Also fold arg.  Fix array bounds case.\n+\t* method.c (process_overload_item): Use build_overload_value for\n+\tarrays.\n+\n 1998-07-20  Dave Brolley  <brolley@cygnus.com>\n \n \t* lex.c (mbchar.h): #include it."}, {"sha": "b844355f0ffef1ba4c54ebc7a3969dcaff001c5c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53929c47c5c916744f34d54b63b1d984a3e2584f/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53929c47c5c916744f34d54b63b1d984a3e2584f/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=53929c47c5c916744f34d54b63b1d984a3e2584f", "patch": "@@ -676,14 +676,6 @@ struct lang_type\n #define TYPE_HAS_ASSIGNMENT(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_assignment)\n #define TYPE_HAS_REAL_ASSIGNMENT(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_real_assignment)\n \n-/* Returns the canonical version of TYPE.  In other words, if TYPE is\n-   a typedef, returns the underlying type.  The cv-qualification of\n-   the type returned matches the type input; they will always be\n-   compatible types.  */\n-#define CANONICAL_TYPE_VARIANT(NODE) \t\t\t\t\t\\\n-  (cp_build_type_variant (TYPE_MAIN_VARIANT (NODE), \t\t\t\\\n-\t\t\t  TYPE_READONLY (NODE), TYPE_VOLATILE (NODE)))\n-\n /* Nonzero for _CLASSTYPE means that operator new and delete are defined,\n    respectively.  */\n #define TYPE_GETS_NEW(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.gets_new)\n@@ -1728,6 +1720,7 @@ extern void check_function_format\t\tPROTO((tree, tree, tree));\n    NOP_EXPR is used as a special case (see truthvalue_conversion).  */\n extern void binary_op_error                     PROTO((enum tree_code));\n extern tree cp_build_type_variant                PROTO((tree, int, int));\n+extern tree canonical_type_variant              PROTO((tree));\n extern void c_expand_expr_stmt                  PROTO((tree));\n /* Validate the expression after `case' and apply default promotions.  */\n extern tree check_case_value                    PROTO((tree));"}, {"sha": "986b8c0533673a3a10a89c0e6a6cdd9a1f63bb25", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53929c47c5c916744f34d54b63b1d984a3e2584f/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53929c47c5c916744f34d54b63b1d984a3e2584f/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=53929c47c5c916744f34d54b63b1d984a3e2584f", "patch": "@@ -3002,7 +3002,7 @@ duplicate_decls (newdecl, olddecl)\n       TREE_TYPE (newdecl) = TREE_TYPE (olddecl) = newtype;\n \n       /* Lay the type out, unless already done.  */\n-      if (newtype != CANONICAL_TYPE_VARIANT (oldtype)\n+      if (newtype != canonical_type_variant (oldtype)\n \t  && TREE_TYPE (newdecl) != error_mark_node\n \t  && !(processing_template_decl && uses_template_parms (newdecl)))\n \tlayout_type (TREE_TYPE (newdecl));"}, {"sha": "d718a44920b80788cb8938cb0b088702d91f823f", "filename": "gcc/cp/method.c", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53929c47c5c916744f34d54b63b1d984a3e2584f/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53929c47c5c916744f34d54b63b1d984a3e2584f/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=53929c47c5c916744f34d54b63b1d984a3e2584f", "patch": "@@ -1005,7 +1005,7 @@ build_mangled_name_for_type_with_Gcode (type, extra_Gcode)\n {\n   if (TYPE_PTRMEMFUNC_P (type))\n     type = TYPE_PTRMEMFUNC_FN_TYPE (type);\n-  type = CANONICAL_TYPE_VARIANT (type);\n+  type = canonical_type_variant (type);\n   process_modifiers (type);\n   process_overload_item (type, extra_Gcode);\n }\n@@ -1069,7 +1069,7 @@ build_mangled_name (parmtypes, begin, end)\n       for (; parmtypes && parmtypes != void_list_node;\n \t   parmtypes = TREE_CHAIN (parmtypes))\n \t{\n-\t  tree parmtype = CANONICAL_TYPE_VARIANT (TREE_VALUE (parmtypes));\n+\t  tree parmtype = canonical_type_variant (TREE_VALUE (parmtypes));\n \n \t  if (old_style_repeats)\n \t    {\n@@ -1245,12 +1245,18 @@ process_overload_item (parmtype, extra_Gcode)\n         if (TYPE_DOMAIN (parmtype) == NULL_TREE)\n           error(\"pointer/reference to array of unknown bound in parm type\");\n         else\n-          {\n-            length = array_type_nelts (parmtype);\n-            if (TREE_CODE (length) == INTEGER_CST)\n-              icat (TREE_INT_CST_LOW (length) + 1);\n-          }\n-        OB_PUTC ('_');\n+\t  {\n+\t    tree length = array_type_nelts (parmtype);\n+\t    if (TREE_CODE (length) != INTEGER_CST || flag_do_squangling)\n+\t      {\n+\t\tlength = fold (build (PLUS_EXPR, TREE_TYPE (length),\n+\t\t\t\t      length, integer_one_node));\n+\t\tSTRIP_NOPS (length);\n+\t      }\n+\t    build_overload_value (sizetype, length, 1);\n+\t  }\n+\tif (numeric_output_need_bar && ! flag_do_squangling)\n+\t  OB_PUTC ('_');\n         goto more;\n       }\n #else\n@@ -1611,7 +1617,7 @@ build_decl_overload_real (dname, parms, ret_type, tparms, targs,\n               tree temp = TREE_VALUE (t);\n               TREE_USED (temp) = 0;\n               /* clear out the type variant in case we used it */\n-              temp = CANONICAL_TYPE_VARIANT (temp);\n+              temp = canonical_type_variant (temp);\n               TREE_USED (temp) = 0;\n               t = TREE_CHAIN (t);\n             }"}, {"sha": "eaf73ef6f00c37e9524f0cf12cb7b7d7e616ea71", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53929c47c5c916744f34d54b63b1d984a3e2584f/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53929c47c5c916744f34d54b63b1d984a3e2584f/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=53929c47c5c916744f34d54b63b1d984a3e2584f", "patch": "@@ -6577,6 +6577,30 @@ unify (tparms, targs, parm, arg, strict, explicit_mask)\n       /* Matched cases are handled by the ARG == PARM test above.  */\n       return 1;\n \n+    case MINUS_EXPR:\n+      if (TREE_CODE (TREE_OPERAND (parm, 1)) == INTEGER_CST)\n+\t{\n+\t  /* We handle this case specially, since it comes up with\n+\t     arrays.  In particular, something like:\n+\n+\t     template <int N> void f(int (&x)[N]);\n+\n+\t     Here, we are trying to unify the range type, which\n+\t     looks like [0 ... (N - 1)].  */\n+\t  tree t, t1, t2;\n+\t  t1 = TREE_OPERAND (parm, 0);\n+\t  t2 = TREE_OPERAND (parm, 1);\n+\n+\t  /* Should this be a regular fold?  */\n+\t  t = maybe_fold_nontype_arg (build (PLUS_EXPR,\n+\t\t\t\t\t     integer_type_node,\n+\t\t\t\t\t     arg, t2));\n+\n+\t  return unify (tparms, targs, t1, t, UNIFY_ALLOW_NONE,\n+\t\t\texplicit_mask);\n+\t}\n+      /* else fall through */\n+\n     default:\n       if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (parm))))\n \t{\n@@ -6596,34 +6620,11 @@ unify (tparms, targs, parm, arg, strict, explicit_mask)\n \t     figuring it out.  */\n \t  tree t = \n \t    maybe_fold_nontype_arg (tsubst_expr (parm, targs, NULL_TREE)); \n-\t  enum tree_code tc = TREE_CODE (t);\n-\n-\t  if (tc == MINUS_EXPR \n-\t      && TREE_CODE (TREE_OPERAND (t, 0)) == TEMPLATE_PARM_INDEX\n-\t      && TREE_CODE (TREE_OPERAND (t, 1)) == INTEGER_CST)\n-\t    {\n-\t      /* We handle this case specially, since it comes up with\n-\t\t arrays.  In particular, something like:\n-\n-\t\t template <int N> void f(int (&x)[N]);\n-\n-\t\t Here, we are trying to unify the range type, which\n-\t\t looks like [0 ... (N - 1)].  */\n-\t      tree t1, t2;\n-\t      t1 = TREE_OPERAND (parm, 0);\n-\t      t2 = TREE_OPERAND (parm, 1);\n-\n-\t      t = maybe_fold_nontype_arg (build (PLUS_EXPR,\n-\t\t\t\t\t\t integer_type_node,\n-\t\t\t\t\t\t arg, t2));\n-\n-\t      return unify (tparms, targs, t1, t, UNIFY_ALLOW_NONE,\n-\t\t\t    explicit_mask);\n-\t    }\n+\t  tree a = maybe_fold_nontype_arg (arg);\n \n-\t  if (!IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (tc)))\n+\t  if (!IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (t))))\n \t    /* Good, we mangaged to simplify the exression.  */\n-\t    return unify (tparms, targs, t, arg, UNIFY_ALLOW_NONE,\n+\t    return unify (tparms, targs, t, a, UNIFY_ALLOW_NONE,\n \t\t\t  explicit_mask);\n \t  else\n \t    /* Bad, we couldn't simplify this.  Assume it doesn't"}, {"sha": "02243282e5e2bafdf54de888cfedd8db86e8724e", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53929c47c5c916744f34d54b63b1d984a3e2584f/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53929c47c5c916744f34d54b63b1d984a3e2584f/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=53929c47c5c916744f34d54b63b1d984a3e2584f", "patch": "@@ -546,6 +546,29 @@ cp_build_type_variant (type, constp, volatilep)\n     }\n   return build_type_variant (type, constp, volatilep);\n }\n+\n+/* Returns the canonical version of TYPE.  In other words, if TYPE is\n+   a typedef, returns the underlying type.  The cv-qualification of\n+   the type returned matches the type input; they will always be\n+   compatible types.  */\n+\n+tree\n+canonical_type_variant (t)\n+     tree t;\n+{\n+  int constp, volatilep;\n+  if (TREE_CODE (t) == ARRAY_TYPE)\n+    {\n+      constp = TYPE_READONLY (TREE_TYPE (t));\n+      volatilep = TYPE_VOLATILE (TREE_TYPE (t));\n+    }\n+  else\n+    {\n+      constp = TYPE_READONLY (t);\n+      volatilep = TYPE_VOLATILE (t);\n+    }\n+  return cp_build_type_variant (TYPE_MAIN_VARIANT (t), constp, volatilep);\n+}\n \f\n /* Add OFFSET to all base types of T.\n "}]}