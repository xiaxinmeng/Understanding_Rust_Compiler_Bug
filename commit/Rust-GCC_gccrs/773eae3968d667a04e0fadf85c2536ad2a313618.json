{"sha": "773eae3968d667a04e0fadf85c2536ad2a313618", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzczZWFlMzk2OGQ2NjdhMDRlMGZhZGY4NWMyNTM2YWQyYTMxMzYxOA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@libertysurf.fr", "date": "2003-04-03T19:20:06Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2003-04-03T19:20:06Z"}, "message": "re PR rtl-optimization/10157 ([Sparc] internal compiler error: in extract_insn, at recog.c:2188)\n\n\tPR optimization/10157\n\t* gcse.c (can_copy_p): Rename it to can_copy.\n\t(can_copy_init_p): Remove.\n\t(compute_can_copy): Use can_copy instead of can_copy_p.\n\t(can_copy_p): New exported function. Call compute_can_copy.\n\t(hash_scan_set): Use it.\n\t(gcse_main): Don't call compute_can_copy.\n\t(bypass_jumps): Don't call compute_can_copy.\n\t* rtl.h (can_copy_p): Declare.\n\t* loop.c (scan_loop): Don't move the source and add a reg-to-reg\n\tcopy if the mode doesn't support copy operations.\n\nFrom-SVN: r65210", "tree": {"sha": "da21670875e2f4f834c72f607c39c9fb2b81cb38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da21670875e2f4f834c72f607c39c9fb2b81cb38"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/773eae3968d667a04e0fadf85c2536ad2a313618", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/773eae3968d667a04e0fadf85c2536ad2a313618", "html_url": "https://github.com/Rust-GCC/gccrs/commit/773eae3968d667a04e0fadf85c2536ad2a313618", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/773eae3968d667a04e0fadf85c2536ad2a313618/comments", "author": {"login": "ebotcazou", "id": 48091907, "node_id": "MDQ6VXNlcjQ4MDkxOTA3", "avatar_url": "https://avatars.githubusercontent.com/u/48091907?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebotcazou", "html_url": "https://github.com/ebotcazou", "followers_url": "https://api.github.com/users/ebotcazou/followers", "following_url": "https://api.github.com/users/ebotcazou/following{/other_user}", "gists_url": "https://api.github.com/users/ebotcazou/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebotcazou/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebotcazou/subscriptions", "organizations_url": "https://api.github.com/users/ebotcazou/orgs", "repos_url": "https://api.github.com/users/ebotcazou/repos", "events_url": "https://api.github.com/users/ebotcazou/events{/privacy}", "received_events_url": "https://api.github.com/users/ebotcazou/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "613fa1469c1a9b5a8f27fe76a5731e154535c71e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/613fa1469c1a9b5a8f27fe76a5731e154535c71e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/613fa1469c1a9b5a8f27fe76a5731e154535c71e"}], "stats": {"total": 107, "additions": 74, "deletions": 33}, "files": [{"sha": "4b6dec2e7fbeb3c97a48f417c3d54d5b6f758452", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/773eae3968d667a04e0fadf85c2536ad2a313618/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/773eae3968d667a04e0fadf85c2536ad2a313618/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=773eae3968d667a04e0fadf85c2536ad2a313618", "patch": "@@ -1,3 +1,17 @@\n+2003-04-03  Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n+\tPR optimization/10157\n+\t* gcse.c (can_copy_p): Rename it to can_copy.\n+\t(can_copy_init_p): Remove.\n+\t(compute_can_copy): Use can_copy instead of can_copy_p.\n+\t(can_copy_p): New exported function. Call compute_can_copy.\n+\t(hash_scan_set): Use it.\n+\t(gcse_main): Don't call compute_can_copy.\n+\t(bypass_jumps): Don't call compute_can_copy.\n+\t* rtl.h (can_copy_p): Declare.\n+\t* loop.c (scan_loop): Don't move the source and add a reg-to-reg\n+\tcopy if the mode doesn't support copy operations.\n+\n 2003-04-03  Jason Merrill  <jason@redhat.com>\n \n \t* Makefile.in (unstrap): Also remove stage_last."}, {"sha": "5cd55adbf175a43f1188e61327a1a4a6d5dfe24a", "filename": "gcc/gcse.c", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/773eae3968d667a04e0fadf85c2536ad2a313618/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/773eae3968d667a04e0fadf85c2536ad2a313618/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=773eae3968d667a04e0fadf85c2536ad2a313618", "patch": "@@ -299,14 +299,6 @@ static FILE *debug_stderr;\n /* An obstack for our working variables.  */\n static struct obstack gcse_obstack;\n \n-/* Nonzero for each mode that supports (set (reg) (reg)).\n-   This is trivially true for integer and floating point values.\n-   It may or may not be true for condition codes.  */\n-static char can_copy_p[(int) NUM_MACHINE_MODES];\n-\n-/* Nonzero if can_copy_p has been initialized.  */\n-static int can_copy_init_p;\n-\n struct reg_use {rtx reg_rtx; };\n \n /* Hash table of expressions.  */\n@@ -786,13 +778,6 @@ gcse_main (f, file)\n       return 0;\n     }\n \n-  /* See what modes support reg/reg copy operations.  */\n-  if (! can_copy_init_p)\n-    {\n-      compute_can_copy ();\n-      can_copy_init_p = 1;\n-    }\n-\n   gcc_obstack_init (&gcse_obstack);\n   bytes_used = 0;\n \n@@ -925,6 +910,11 @@ gcse_main (f, file)\n \f\n /* Misc. utilities.  */\n \n+/* Nonzero for each mode that supports (set (reg) (reg)).\n+   This is trivially true for integer and floating point values.\n+   It may or may not be true for condition codes.  */\n+static char can_copy[(int) NUM_MACHINE_MODES];\n+\n /* Compute which modes support reg/reg copy operations.  */\n \n static void\n@@ -934,26 +924,43 @@ compute_can_copy ()\n #ifndef AVOID_CCMODE_COPIES\n   rtx reg, insn;\n #endif\n-  memset (can_copy_p, 0, NUM_MACHINE_MODES);\n+  memset (can_copy, 0, NUM_MACHINE_MODES);\n \n   start_sequence ();\n   for (i = 0; i < NUM_MACHINE_MODES; i++)\n     if (GET_MODE_CLASS (i) == MODE_CC)\n       {\n #ifdef AVOID_CCMODE_COPIES\n-\tcan_copy_p[i] = 0;\n+\tcan_copy[i] = 0;\n #else\n \treg = gen_rtx_REG ((enum machine_mode) i, LAST_VIRTUAL_REGISTER + 1);\n \tinsn = emit_insn (gen_rtx_SET (VOIDmode, reg, reg));\n \tif (recog (PATTERN (insn), insn, NULL) >= 0)\n-\t  can_copy_p[i] = 1;\n+\t  can_copy[i] = 1;\n #endif\n       }\n     else\n-      can_copy_p[i] = 1;\n+      can_copy[i] = 1;\n \n   end_sequence ();\n }\n+\n+/* Returns whether the mode supports reg/reg copy operations.  */\n+\n+bool\n+can_copy_p (mode)\n+     enum machine_mode mode;\n+{\n+  static bool can_copy_init_p = false;\n+\n+  if (! can_copy_init_p)\n+    {\n+      compute_can_copy ();\n+      can_copy_init_p = true;\n+    }\n+\n+  return can_copy[mode] != 0;\n+}\n \f\n /* Cover function to xmalloc to record bytes allocated.  */\n \n@@ -2211,7 +2218,7 @@ hash_scan_set (pat, insn, table)\n       if (! table->set_p\n \t  && regno >= FIRST_PSEUDO_REGISTER\n \t  /* Don't GCSE something if we can't do a reg/reg copy.  */\n-\t  && can_copy_p [GET_MODE (dest)]\n+\t  && can_copy_p (GET_MODE (dest))\n \t  /* GCSE commonly inserts instruction after the insn.  We can't\n \t     do that easily for EH_REGION notes so disable GCSE on these\n \t     for now.  */\n@@ -2247,7 +2254,7 @@ hash_scan_set (pat, insn, table)\n \t       && regno >= FIRST_PSEUDO_REGISTER\n \t       && ((GET_CODE (src) == REG\n \t\t    && REGNO (src) >= FIRST_PSEUDO_REGISTER\n-\t\t    && can_copy_p [GET_MODE (dest)]\n+\t\t    && can_copy_p (GET_MODE (dest))\n \t\t    && REGNO (src) != regno)\n \t\t   || gcse_constant_p (src))\n \t       /* A copy is not available if its src or dest is subsequently\n@@ -7878,13 +7885,6 @@ bypass_jumps (file)\n       return 0;\n     }\n \n-  /* See what modes support reg/reg copy operations.  */\n-  if (! can_copy_init_p)\n-    {\n-      compute_can_copy ();\n-      can_copy_init_p = 1;\n-    }\n-\n   gcc_obstack_init (&gcse_obstack);\n   bytes_used = 0;\n "}, {"sha": "d7ae3ea582361a20447f6fdb623c209c9484939f", "filename": "gcc/loop.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/773eae3968d667a04e0fadf85c2536ad2a313618/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/773eae3968d667a04e0fadf85c2536ad2a313618/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=773eae3968d667a04e0fadf85c2536ad2a313618", "patch": "@@ -824,7 +824,7 @@ scan_loop (loop, flags)\n \t\t   && (maybe_never\n \t\t       || loop_reg_used_before_p (loop, set, p)))\n \t\t/* It is unsafe to move the set.  However, it may be OK to\n-\t\t   move the source into a new psuedo, and subsitute a \n+\t\t   move the source into a new pseudo, and substitute a \n \t\t   reg-to-reg copy for the original insn.\n \n \t\t   This code used to consider it OK to move a set of a variable\n@@ -839,11 +839,15 @@ scan_loop (loop, flags)\n \t\t the benefit.  */\n \t      if (REGNO (SET_DEST (set)) >= max_reg_before_loop)\n \t\t;\n-\t      /* Don't move the source and add a reg-to-reg copy with -Os\n-\t\t (this certainly increases size) or if the source is\n-\t\t already a reg (the motion will gain nothing).  */\n+\t      /* Don't move the source and add a reg-to-reg copy:\n+\t\t - with -Os (this certainly increases size),\n+\t\t - if the mode doesn't support copy operations (obviously),\n+\t\t - if the source is already a reg (the motion will gain nothing),\n+\t\t - if the source is a legitimate constant (likewise).  */\n \t      else if (insert_temp \n-\t\t       && (optimize_size || GET_CODE (SET_SRC (set)) == REG\n+\t\t       && (optimize_size\n+\t\t\t   || ! can_copy_p (GET_MODE (SET_SRC (set)))\n+\t\t\t   || GET_CODE (SET_SRC (set)) == REG\n \t\t\t   || (CONSTANT_P (SET_SRC (set))\n \t\t\t       && LEGITIMATE_CONSTANT_P (SET_SRC (set)))))\n \t\t;"}, {"sha": "c03172bc39042d3b1855a154cdf4cb56cb2be327", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/773eae3968d667a04e0fadf85c2536ad2a313618/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/773eae3968d667a04e0fadf85c2536ad2a313618/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=773eae3968d667a04e0fadf85c2536ad2a313618", "patch": "@@ -2112,6 +2112,7 @@ extern rtx expand_mult_highpart\t\tPARAMS ((enum machine_mode, rtx,\n \t\t\t\t\t\tint, int));\n \n /* In gcse.c */\n+extern bool can_copy_p\t\t\tPARAMS ((enum machine_mode));\n #ifdef BUFSIZ\n extern int gcse_main\t\t\tPARAMS ((rtx, FILE *));\n extern int bypass_jumps\t\t\tPARAMS ((FILE *));"}, {"sha": "78d35b84cfd78021a2fe29c57619b3508e3ef736", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/773eae3968d667a04e0fadf85c2536ad2a313618/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/773eae3968d667a04e0fadf85c2536ad2a313618/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=773eae3968d667a04e0fadf85c2536ad2a313618", "patch": "@@ -1,3 +1,7 @@\n+2003-04-03  Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n+\t* gcc.dg/sparc-loop-1.c: New test.\n+\n 2003-04-02  Geoffrey Keating  <geoffk@apple.com>\n \n \tPR other/9274"}, {"sha": "8d5f7519b03fe3009cb9e5b0cb47d6b24078b291", "filename": "gcc/testsuite/gcc.dg/sparc-loop-1.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/773eae3968d667a04e0fadf85c2536ad2a313618/gcc%2Ftestsuite%2Fgcc.dg%2Fsparc-loop-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/773eae3968d667a04e0fadf85c2536ad2a313618/gcc%2Ftestsuite%2Fgcc.dg%2Fsparc-loop-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsparc-loop-1.c?ref=773eae3968d667a04e0fadf85c2536ad2a313618", "patch": "@@ -0,0 +1,18 @@\n+/* PR optimization/10157 */\n+/* Originator: Peter van Hoof <p.van-hoof@qub.ac.uk> */\n+/* { dg-do compile { target sparc*-*-* } } */\n+/* { dg-options \"-O2 -ffast-math\" } */\n+\n+/* Verify that the loop optimizer doesn't\n+   emit invalid reg-to-reg copy insns. */\n+\n+void g() {\n+  while(1) {\n+    int i,n;\n+    double p,r;\n+    for( i=0; i < n; i++ )\n+      if( p > 1. )\n+        for( i=0; i < n; i++ )\n+          r += 2.;\n+  }\n+}"}]}