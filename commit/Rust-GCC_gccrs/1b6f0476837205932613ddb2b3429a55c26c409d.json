{"sha": "1b6f0476837205932613ddb2b3429a55c26c409d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWI2ZjA0NzY4MzcyMDU5MzI2MTNkZGIyYjM0MjlhNTVjMjZjNDA5ZA==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2020-10-04T16:06:11Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2020-10-20T19:30:22Z"}, "message": "libstdc++: Refactor _Hashtable to prepare for custom pointers\n\nLimit usage of node pointers in _Hashtable implementation details so that when\nwe move to allocator custom pointer type we do not need to add an _Alloc\ntemplate parameter everywhere which would impact abi.\n\nThis is done by reviewing node type definition. It is now based on new basic\ntypes which are not pointer dependant. The _Hashtable helper\ntypes are now using those new node base types and do not receive node pointers.\n\nlibstdc++-v3/ChangeLog\n\n\t* include/bits/hashtable_policy.h\n\t(_Hash_node_value_base<>): Remove _Hash_node_base inheritance.\n\t(_Hash_node_code_cache<bool _Cache_hash_code>): New.\n\t(_Hash_node_value<typename _Value, bool _Cache_hash_code>): New.\n\t(_Hash_node<>): Inherits _Hash_node_base<> and _Hash_node_value<>.\n\t(_Map_base<>::__node_type): Remove.\n\t(_Map_base<>::iterator): Remove.\n\t(_Insert_base<>::__hash_cached): New.\n\t(_Insert_base<>::__constant_iterators): New.\n\t(_Insert_base<>::__hashtable_alloc): New.\n\t(_Insert_base<>::__node_type): Remove.\n\t(_Insert_base<>::__node_ptr): New.\n\t(_Hash_code_base<>): Remove specializations.\n\t(_Hash_code_base<>::__node_type): Remove.\n\t(_Hash_code_base<>::_M_bucket_index(const __node_type*, size_t)):\n\tReplace by...\n\t(_Hash_code_base<>::_M_bucket_index(const _Hash_node_value<>&, size_t)):\n\t...this.\n\t(_Hash_code_base<>::_M_store_code(__node_type*, __hash_code)):\n\tReplace by...\n\t(_Hash_code_base<>::_M_store_code(_Hash_node_code_cache<>&, __hash_code)):\n\t...this.\n\t(_Hash_code_base<>::_M_copy_code(__node_type*, const __node_type*)):\n\tReplace by...\n\t(_Hash_code_base<>::_M_copy_code(_Hash_node_code_cache<>&,\n\tconst _Hash_node_code_base<>&)): ...this.\n\t(_Hashtable_base<>::__constant_iterators): Remove.\n\t(_Hashtable_base<>::__unique_keys): Remove.\n\t(_Hashtable_base<>::__node_type): Remove.\n\t(_Hashtable_base<>::iterator): Remove.\n\t(_Hashtable_base<>::const_iterator): Remove.\n\t(_Hashtable_base<>::local_iterator): Remove.\n\t(_Hashtable_base<>::const_local_iterator): Remove.\n\t(_Hashtable_base<>::__ireturn_type): Remove.\n\t(_Hashtable_base<>::_Equal_hash_code<>::_S_equals): Replace by...\n\t(_Hashtable_base<>::_S_equals(__hash_code, const _Hash_node_code_hash<>&)):\n\t...this.\n\t(_Hashtable_base<>::_Equal_hash_code<>::_S_node_equals): Replace by...\n\t(_Hashtable_base<>::_S_node_equals(__hash_code,\n\tconst _Hash_node_code_hash<>&)): ...this.\n\t(_Hashtable_base<>::_Equal_hash_code<>): Remove.\n\t(_Hashtable_base<>::_M_equals): Adapt.\n\t(_Hashtable_baxe<>::_M_node_equals): Adapt.\n\t(_Equality<>::_M_equal): Adapt.\n\t(_Hashtable_alloc<>::__node_ptr): New.\n\t(_Hashtable_alloc<>::__bucket_type): Rename into...\n\t(_Hashtable_alloc<>::__node_base_ptr): ...this.\n\t(_Hashtable_alloc<>::__bucket_alloc_type): Rename into...\n\t(_Hashtable_alloc<>::__buckets_alloc_type): ...this.\n\t(_Hashtable_alloc<>::__bucket_alloc_traits): Rename into...\n\t(_Hashtable_alloc<>::__buckets_alloc_traits): ...this.\n\t(_Hashtable_alloc<>::__buckets_ptr): New.\n\t(_Hashtable_alloc<>::_M_allocate_node): Adapt.\n\t(_Hashtable_alloc<>::_M_deallocate_node): Adapt.\n\t(_Hashtable_alloc<>::_M_deallocate_node_ptr): Adapt.\n\t(_Hashtable_alloc<>::_M_deallocate_nodes): Adapt.\n\t(_Hashtable_alloc<>::_M_allocate_buckets): Adapt.\n\t(_Hashtable_alloc<>::_M_deallocate_buckets): Adapt.\n\t* include/bits/hashtable.h (_Hashtable<>): Adapt.", "tree": {"sha": "43f1f04a8138a699cdb17f4fa34623345782ab0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/43f1f04a8138a699cdb17f4fa34623345782ab0b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1b6f0476837205932613ddb2b3429a55c26c409d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b6f0476837205932613ddb2b3429a55c26c409d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b6f0476837205932613ddb2b3429a55c26c409d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b6f0476837205932613ddb2b3429a55c26c409d/comments", "author": null, "committer": null, "parents": [{"sha": "15b8e2af42168a41636186c53d1e833302195601", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15b8e2af42168a41636186c53d1e833302195601", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15b8e2af42168a41636186c53d1e833302195601"}], "stats": {"total": 677, "additions": 309, "deletions": 368}, "files": [{"sha": "6c6c5edde0b4d0df55c88c438e80981691b55e00", "filename": "libstdc++-v3/include/bits/hashtable.h", "status": "modified", "additions": 134, "deletions": 117, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b6f0476837205932613ddb2b3429a55c26c409d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b6f0476837205932613ddb2b3429a55c26c409d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h?ref=1b6f0476837205932613ddb2b3429a55c26c409d", "patch": "@@ -101,7 +101,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    *  - size_type       _M_bucket_count\n    *  - size_type       _M_element_count\n    *\n-   *  with _Bucket being _Hash_node* and _Hash_node containing:\n+   *  with _Bucket being _Hash_node_base* and _Hash_node containing:\n    *\n    *  - _Hash_node*   _M_next\n    *  - Tp            _M_value\n@@ -194,17 +194,27 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       using __traits_type = _Traits;\n       using __hash_cached = typename __traits_type::__hash_cached;\n+      using __constant_iterators = typename __traits_type::__constant_iterators;\n       using __node_type = __detail::_Hash_node<_Value, __hash_cached::value>;\n       using __node_alloc_type = __alloc_rebind<_Alloc, __node_type>;\n \n       using __hashtable_alloc = __detail::_Hashtable_alloc<__node_alloc_type>;\n \n+      using __node_value_type =\n+\t__detail::_Hash_node_value<_Value, __hash_cached::value>;\n+      using __node_ptr = typename __hashtable_alloc::__node_ptr;\n       using __value_alloc_traits =\n \ttypename __hashtable_alloc::__value_alloc_traits;\n       using __node_alloc_traits =\n \ttypename __hashtable_alloc::__node_alloc_traits;\n       using __node_base = typename __hashtable_alloc::__node_base;\n-      using __bucket_type = typename __hashtable_alloc::__bucket_type;\n+      using __node_base_ptr = typename __hashtable_alloc::__node_base_ptr;\n+      using __buckets_ptr = typename __hashtable_alloc::__buckets_ptr;\n+\n+      using __insert_base = __detail::_Insert<_Key, _Value, _Alloc, _ExtractKey,\n+\t\t\t\t\t      _Equal, _Hash,\n+\t\t\t\t\t      _RangeHash, _Unused,\n+\t\t\t\t\t      _RehashPolicy, _Traits>;\n \n     public:\n       typedef _Key\t\t\t\t\t\tkey_type;\n@@ -219,11 +229,24 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       typedef value_type&\t\t\t\t\treference;\n       typedef const value_type&\t\t\t\t\tconst_reference;\n \n+      using iterator = typename __insert_base::iterator;\n+\n+      using const_iterator = typename __insert_base::const_iterator;\n+\n+      using local_iterator = __detail::_Local_iterator<key_type, _Value,\n+\t\t\t_ExtractKey, _Hash, _RangeHash, _Unused,\n+\t\t\t\t\t     __constant_iterators::value,\n+\t\t\t\t\t     __hash_cached::value>;\n+\n+      using const_local_iterator = __detail::_Local_const_iterator<\n+\t\t\tkey_type, _Value,\n+\t\t\t_ExtractKey, _Hash, _RangeHash, _Unused,\n+\t\t\t__constant_iterators::value, __hash_cached::value>;\n+\n     private:\n       using __rehash_type = _RehashPolicy;\n       using __rehash_state = typename __rehash_type::_State;\n \n-      using __constant_iterators = typename __traits_type::__constant_iterators;\n       using __unique_keys = typename __traits_type::__unique_keys;\n \n       using __hashtable_base = __detail::\n@@ -232,7 +255,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       using __hash_code_base =  typename __hashtable_base::__hash_code_base;\n       using __hash_code =  typename __hashtable_base::__hash_code;\n-      using __ireturn_type = typename __hashtable_base::__ireturn_type;\n+      using __ireturn_type = typename __insert_base::__ireturn_type;\n \n       using __map_base = __detail::_Map_base<_Key, _Value, _Alloc, _ExtractKey,\n \t\t\t\t\t     _Equal, _Hash, _RangeHash, _Unused,\n@@ -256,7 +279,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       struct _Scoped_node\n       {\n \t// Take ownership of a node with a constructed element.\n-\t_Scoped_node(__node_type* __n, __hashtable_alloc* __h)\n+\t_Scoped_node(__node_ptr __n, __hashtable_alloc* __h)\n \t: _M_h(__h), _M_node(__n) { }\n \n \t// Allocate a node and construct an element within it.\n@@ -273,7 +296,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_Scoped_node& operator=(const _Scoped_node&) = delete;\n \n \t__hashtable_alloc* _M_h;\n-\t__node_type* _M_node;\n+\t__node_ptr _M_node;\n       };\n \n       template<typename _Ht>\n@@ -293,8 +316,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       // Getting a bucket index from a node shall not throw because it is used\n       // in methods (erase, swap...) that shall not throw.\n       static_assert(noexcept(declval<const __hash_code_base_access&>()\n-\t\t\t     ._M_bucket_index((const __node_type*)nullptr,\n-\t\t\t\t\t      (std::size_t)0)),\n+\t\t\t._M_bucket_index(declval<const __node_value_type&>(),\n+\t\t\t\t\t (std::size_t)0)),\n \t\t    \"Cache the hash code or qualify your functors involved\"\n \t\t    \" in hash code and bucket index computation with noexcept\");\n \n@@ -345,20 +368,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       using size_type = typename __hashtable_base::size_type;\n       using difference_type = typename __hashtable_base::difference_type;\n \n-      using iterator = typename __hashtable_base::iterator;\n-      using const_iterator = typename __hashtable_base::const_iterator;\n-\n-      using local_iterator = typename __hashtable_base::local_iterator;\n-      using const_local_iterator = typename __hashtable_base::\n-\t\t\t\t   const_local_iterator;\n-\n #if __cplusplus > 201402L\n       using node_type = _Node_handle<_Key, _Value, __node_alloc_type>;\n       using insert_return_type = _Node_insert_return<iterator, node_type>;\n #endif\n \n     private:\n-      __bucket_type*\t\t_M_buckets\t\t= &_M_single_bucket;\n+      __buckets_ptr\t\t_M_buckets\t\t= &_M_single_bucket;\n       size_type\t\t\t_M_bucket_count\t\t= 1;\n       __node_base\t\t_M_before_begin;\n       size_type\t\t\t_M_element_count\t= 0;\n@@ -370,24 +386,24 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       // qualified.\n       // Note that we can't leave hashtable with 0 bucket without adding\n       // numerous checks in the code to avoid 0 modulus.\n-      __bucket_type\t\t_M_single_bucket\t= nullptr;\n+      __node_base_ptr\t\t_M_single_bucket\t= nullptr;\n \n       void\n       _M_update_bbegin()\n       {\n \tif (_M_begin())\n-\t  _M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin;\n+\t  _M_buckets[_M_bucket_index(*_M_begin())] = &_M_before_begin;\n       }\n \n       void\n-      _M_update_bbegin(__node_type* __n)\n+      _M_update_bbegin(__node_ptr __n)\n       {\n \t_M_before_begin._M_nxt = __n;\n \t_M_update_bbegin();\n       }\n \n       bool\n-      _M_uses_single_bucket(__bucket_type* __bkts) const\n+      _M_uses_single_bucket(__buckets_ptr __bkts) const\n       { return __builtin_expect(__bkts == &_M_single_bucket, false); }\n \n       bool\n@@ -397,7 +413,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       __hashtable_alloc&\n       _M_base_alloc() { return *this; }\n \n-      __bucket_type*\n+      __buckets_ptr\n       _M_allocate_buckets(size_type __bkt_count)\n       {\n \tif (__builtin_expect(__bkt_count == 1, false))\n@@ -410,7 +426,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n \n       void\n-      _M_deallocate_buckets(__bucket_type* __bkts, size_type __bkt_count)\n+      _M_deallocate_buckets(__buckets_ptr __bkts, size_type __bkt_count)\n       {\n \tif (_M_uses_single_bucket(__bkts))\n \t  return;\n@@ -424,12 +440,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       // Gets bucket begin, deals with the fact that non-empty buckets contain\n       // their before begin node.\n-      __node_type*\n+      __node_ptr\n       _M_bucket_begin(size_type __bkt) const;\n \n-      __node_type*\n+      __node_ptr\n       _M_begin() const\n-      { return static_cast<__node_type*>(_M_before_begin._M_nxt); }\n+      { return static_cast<__node_ptr>(_M_before_begin._M_nxt); }\n \n       // Assign *this using another _Hashtable instance. Whether elements\n       // are copied or moved depends on the _Ht reference.\n@@ -711,7 +727,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     private:\n       // Bucket index computation helpers.\n       size_type\n-      _M_bucket_index(__node_type* __n) const noexcept\n+      _M_bucket_index(const __node_value_type& __n) const noexcept\n       { return __hash_code_base::_M_bucket_index(__n, _M_bucket_count); }\n \n       size_type\n@@ -720,44 +736,44 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       // Find and insert helper functions and types\n       // Find the node before the one matching the criteria.\n-      __node_base*\n+      __node_base_ptr\n       _M_find_before_node(size_type, const key_type&, __hash_code) const;\n \n-      __node_type*\n+      __node_ptr\n       _M_find_node(size_type __bkt, const key_type& __key,\n \t\t   __hash_code __c) const\n       {\n-\t__node_base* __before_n = _M_find_before_node(__bkt, __key, __c);\n+\t__node_base_ptr __before_n = _M_find_before_node(__bkt, __key, __c);\n \tif (__before_n)\n-\t  return static_cast<__node_type*>(__before_n->_M_nxt);\n+\t  return static_cast<__node_ptr>(__before_n->_M_nxt);\n \treturn nullptr;\n       }\n \n       // Insert a node at the beginning of a bucket.\n       void\n-      _M_insert_bucket_begin(size_type, __node_type*);\n+      _M_insert_bucket_begin(size_type, __node_ptr);\n \n       // Remove the bucket first node\n       void\n-      _M_remove_bucket_begin(size_type __bkt, __node_type* __next_n,\n+      _M_remove_bucket_begin(size_type __bkt, __node_ptr __next_n,\n \t\t\t     size_type __next_bkt);\n \n       // Get the node before __n in the bucket __bkt\n-      __node_base*\n-      _M_get_previous_node(size_type __bkt, __node_base* __n);\n+      __node_base_ptr\n+      _M_get_previous_node(size_type __bkt, __node_ptr __n);\n \n       // Insert node __n with hash code __code, in bucket __bkt if no\n       // rehash (assumes no element with same key already present).\n       // Takes ownership of __n if insertion succeeds, throws otherwise.\n       iterator\n       _M_insert_unique_node(size_type __bkt, __hash_code,\n-\t\t\t    __node_type* __n, size_type __n_elt = 1);\n+\t\t\t    __node_ptr __n, size_type __n_elt = 1);\n \n       // Insert node __n with key __k and hash code __code.\n       // Takes ownership of __n if insertion succeeds, throws otherwise.\n       iterator\n-      _M_insert_multi_node(__node_type* __hint,\n-\t\t\t   __hash_code __code, __node_type* __n);\n+      _M_insert_multi_node(__node_ptr __hint,\n+\t\t\t   __hash_code __code, __node_ptr __n);\n \n       template<typename... _Args>\n \tstd::pair<iterator, bool>\n@@ -814,7 +830,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_erase(false_type __uks, const key_type&);\n \n       iterator\n-      _M_erase(size_type __bkt, __node_base* __prev_n, __node_type* __n);\n+      _M_erase(size_type __bkt, __node_base_ptr __prev_n, __node_ptr __n);\n \n     public:\n       // Emplace\n@@ -874,7 +890,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    const key_type& __k = __nh._M_key();\n \t    __hash_code __code = this->_M_hash_code(__k);\n \t    size_type __bkt = _M_bucket_index(__code);\n-\t    if (__node_type* __n = _M_find_node(__bkt, __k, __code))\n+\t    if (__node_ptr __n = _M_find_node(__bkt, __k, __code))\n \t      {\n \t\t__ret.node = std::move(__nh);\n \t\t__ret.position = iterator(__n);\n@@ -910,15 +926,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n     private:\n       node_type\n-      _M_extract_node(size_t __bkt, __node_base* __prev_n)\n+      _M_extract_node(size_t __bkt, __node_base_ptr __prev_n)\n       {\n-\t__node_type* __n = static_cast<__node_type*>(__prev_n->_M_nxt);\n+\t__node_ptr __n = static_cast<__node_ptr>(__prev_n->_M_nxt);\n \tif (__prev_n == _M_buckets[__bkt])\n \t  _M_remove_bucket_begin(__bkt, __n->_M_next(),\n-\t     __n->_M_nxt ? _M_bucket_index(__n->_M_next()) : 0);\n+\t     __n->_M_nxt ? _M_bucket_index(*__n->_M_next()) : 0);\n \telse if (__n->_M_nxt)\n \t  {\n-\t    size_type __next_bkt = _M_bucket_index(__n->_M_next());\n+\t    size_type __next_bkt = _M_bucket_index(*__n->_M_next());\n \t    if (__next_bkt != __bkt)\n \t      _M_buckets[__next_bkt] = __prev_n;\n \t  }\n@@ -934,7 +950,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       node_type\n       extract(const_iterator __pos)\n       {\n-\tsize_t __bkt = _M_bucket_index(__pos._M_cur);\n+\tsize_t __bkt = _M_bucket_index(*__pos._M_cur);\n \treturn _M_extract_node(__bkt,\n \t\t\t       _M_get_previous_node(__bkt, __pos._M_cur));\n       }\n@@ -946,7 +962,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tnode_type __nh;\n \t__hash_code __code = this->_M_hash_code(__k);\n \tstd::size_t __bkt = _M_bucket_index(__code);\n-\tif (__node_base* __prev_node = _M_find_before_node(__bkt, __k, __code))\n+\tif (__node_base_ptr __prev_node = _M_find_before_node(__bkt, __k, __code))\n \t  __nh = _M_extract_node(__bkt, __prev_node);\n \treturn __nh;\n       }\n@@ -1016,10 +1032,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n     _M_bucket_begin(size_type __bkt) const\n-    -> __node_type*\n+    -> __node_ptr\n     {\n-      __node_base* __n = _M_buckets[__bkt];\n-      return __n ? static_cast<__node_type*>(__n->_M_nxt) : nullptr;\n+      __node_base_ptr __n = _M_buckets[__bkt];\n+      return __n ? static_cast<__node_ptr>(__n->_M_nxt) : nullptr;\n     }\n \n   template<typename _Key, typename _Value, typename _Alloc,\n@@ -1148,7 +1164,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n       _M_assign_elements(_Ht&& __ht)\n       {\n-\t__bucket_type* __former_buckets = nullptr;\n+\t__buckets_ptr __former_buckets = nullptr;\n \tstd::size_t __former_bucket_count = _M_bucket_count;\n \tconst __rehash_state& __former_state = _M_rehash_policy._M_state();\n \n@@ -1160,7 +1176,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  }\n \telse\n \t  __builtin_memset(_M_buckets, 0,\n-\t\t\t   _M_bucket_count * sizeof(__bucket_type));\n+\t\t\t   _M_bucket_count * sizeof(__node_base_ptr));\n \n \t__try\n \t  {\n@@ -1184,7 +1200,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t_M_bucket_count = __former_bucket_count;\n \t      }\n \t    __builtin_memset(_M_buckets, 0,\n-\t\t\t     _M_bucket_count * sizeof(__bucket_type));\n+\t\t\t     _M_bucket_count * sizeof(__node_base_ptr));\n \t    __throw_exception_again;\n \t  }\n       }\n@@ -1199,7 +1215,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n       _M_assign(_Ht&& __ht, const _NodeGenerator& __node_gen)\n       {\n-\t__bucket_type* __buckets = nullptr;\n+\t__buckets_ptr __buckets = nullptr;\n \tif (!_M_buckets)\n \t  _M_buckets = __buckets = _M_allocate_buckets(_M_bucket_count);\n \n@@ -1210,20 +1226,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n \t    // First deal with the special first node pointed to by\n \t    // _M_before_begin.\n-\t    __node_type* __ht_n = __ht._M_begin();\n-\t    __node_type* __this_n\n+\t    __node_ptr __ht_n = __ht._M_begin();\n+\t    __node_ptr __this_n\n \t      = __node_gen(__fwd_value_for<_Ht>(__ht_n->_M_v()));\n-\t    this->_M_copy_code(__this_n, __ht_n);\n+\t    this->_M_copy_code(*__this_n, *__ht_n);\n \t    _M_update_bbegin(__this_n);\n \n \t    // Then deal with other nodes.\n-\t    __node_base* __prev_n = __this_n;\n+\t    __node_ptr __prev_n = __this_n;\n \t    for (__ht_n = __ht_n->_M_next(); __ht_n; __ht_n = __ht_n->_M_next())\n \t      {\n \t\t__this_n = __node_gen(__fwd_value_for<_Ht>(__ht_n->_M_v()));\n \t\t__prev_n->_M_nxt = __this_n;\n-\t\tthis->_M_copy_code(__this_n, __ht_n);\n-\t\tsize_type __bkt = _M_bucket_index(__this_n);\n+\t\tthis->_M_copy_code(*__this_n, *__ht_n);\n+\t\tsize_type __bkt = _M_bucket_index(*__this_n);\n \t\tif (!_M_buckets[__bkt])\n \t\t  _M_buckets[__bkt] = __prev_n;\n \t\t__prev_n = __this_n;\n@@ -1538,7 +1554,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       // find any new equivalent value.\n       size_type __result = 1;\n       for (auto __ref = __it++;\n-\t   __it._M_cur && this->_M_node_equals(__ref._M_cur, __it._M_cur);\n+\t   __it._M_cur && this->_M_node_equals(*__ref._M_cur, *__it._M_cur);\n \t   ++__it)\n \t++__result;\n \n@@ -1566,7 +1582,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       // All equivalent values are next to each other, if we find a\n       // non-equivalent value after an equivalent one it means that we won't\n       // find any new equivalent value.\n-      while (__ite._M_cur && this->_M_node_equals(__beg._M_cur, __ite._M_cur))\n+      while (__ite._M_cur && this->_M_node_equals(*__beg._M_cur, *__ite._M_cur))\n \t++__ite;\n \n       return { __beg, __ite };\n@@ -1593,7 +1609,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       // All equivalent values are next to each other, if we find a\n       // non-equivalent value after an equivalent one it means that we won't\n       // find any new equivalent value.\n-      while (__ite._M_cur && this->_M_node_equals(__beg._M_cur, __ite._M_cur))\n+      while (__ite._M_cur && this->_M_node_equals(*__beg._M_cur, *__ite._M_cur))\n \t++__ite;\n \n       return { __beg, __ite };\n@@ -1610,19 +1626,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n     _M_find_before_node(size_type __bkt, const key_type& __k,\n \t\t\t__hash_code __code) const\n-    -> __node_base*\n+    -> __node_base_ptr\n     {\n-      __node_base* __prev_p = _M_buckets[__bkt];\n+      __node_base_ptr __prev_p = _M_buckets[__bkt];\n       if (!__prev_p)\n \treturn nullptr;\n \n-      for (__node_type* __p = static_cast<__node_type*>(__prev_p->_M_nxt);;\n+      for (__node_ptr __p = static_cast<__node_ptr>(__prev_p->_M_nxt);;\n \t   __p = __p->_M_next())\n \t{\n-\t  if (this->_M_equals(__k, __code, __p))\n+\t  if (this->_M_equals(__k, __code, *__p))\n \t    return __prev_p;\n \n-\t  if (!__p->_M_nxt || _M_bucket_index(__p->_M_next()) != __bkt)\n+\t  if (!__p->_M_nxt || _M_bucket_index(*__p->_M_next()) != __bkt)\n \t    break;\n \t  __prev_p = __p;\n \t}\n@@ -1637,7 +1653,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     void\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n-    _M_insert_bucket_begin(size_type __bkt, __node_type* __node)\n+    _M_insert_bucket_begin(size_type __bkt, __node_ptr __node)\n     {\n       if (_M_buckets[__bkt])\n \t{\n@@ -1657,7 +1673,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  if (__node->_M_nxt)\n \t    // We must update former begin bucket that is pointing to\n \t    // _M_before_begin.\n-\t    _M_buckets[_M_bucket_index(__node->_M_next())] = __node;\n+\t    _M_buckets[_M_bucket_index(*__node->_M_next())] = __node;\n \n \t  _M_buckets[__bkt] = &_M_before_begin;\n \t}\n@@ -1670,7 +1686,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     void\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n-    _M_remove_bucket_begin(size_type __bkt, __node_type* __next,\n+    _M_remove_bucket_begin(size_type __bkt, __node_ptr __next,\n \t\t\t   size_type __next_bkt)\n     {\n       if (!__next || __next_bkt != __bkt)\n@@ -1694,10 +1710,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     auto\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n-    _M_get_previous_node(size_type __bkt, __node_base* __n)\n-    -> __node_base*\n+    _M_get_previous_node(size_type __bkt, __node_ptr __n)\n+    -> __node_base_ptr\n     {\n-      __node_base* __prev_n = _M_buckets[__bkt];\n+      __node_base_ptr __prev_n = _M_buckets[__bkt];\n       while (__prev_n->_M_nxt != __n)\n \t__prev_n = __prev_n->_M_nxt;\n       return __prev_n;\n@@ -1719,7 +1735,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tconst key_type& __k = _ExtractKey{}(__node._M_node->_M_v());\n \t__hash_code __code = this->_M_hash_code(__k);\n \tsize_type __bkt = _M_bucket_index(__code);\n-\tif (__node_type* __p = _M_find_node(__bkt, __k, __code))\n+\tif (__node_ptr __p = _M_find_node(__bkt, __k, __code))\n \t  // There is already an equivalent node, no insertion\n \t  return std::make_pair(iterator(__p), false);\n \n@@ -1760,7 +1776,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n     _M_insert_unique_node(size_type __bkt, __hash_code __code,\n-\t\t\t  __node_type* __node, size_type __n_elt)\n+\t\t\t  __node_ptr __node, size_type __n_elt)\n     -> iterator\n     {\n       const __rehash_state& __saved_state = _M_rehash_policy._M_state();\n@@ -1774,7 +1790,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  __bkt = _M_bucket_index(__code);\n \t}\n \n-      this->_M_store_code(__node, __code);\n+      this->_M_store_code(*__node, __code);\n \n       // Always insert at the beginning of the bucket.\n       _M_insert_bucket_begin(__bkt, __node);\n@@ -1789,8 +1805,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     auto\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n-    _M_insert_multi_node(__node_type* __hint,\n-\t\t\t __hash_code __code, __node_type* __node)\n+    _M_insert_multi_node(__node_ptr __hint,\n+\t\t\t __hash_code __code, __node_ptr __node)\n     -> iterator\n     {\n       const __rehash_state& __saved_state = _M_rehash_policy._M_state();\n@@ -1800,17 +1816,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       if (__do_rehash.first)\n \t_M_rehash(__do_rehash.second, __saved_state);\n \n-      this->_M_store_code(__node, __code);\n+      this->_M_store_code(*__node, __code);\n       const key_type& __k = _ExtractKey{}(__node->_M_v());\n       size_type __bkt = _M_bucket_index(__code);\n \n       // Find the node before an equivalent one or use hint if it exists and\n       // if it is equivalent.\n-      __node_base* __prev\n+      __node_base_ptr __prev\n \t= __builtin_expect(__hint != nullptr, false)\n-\t  && this->_M_equals(__k, __code, __hint)\n+\t  && this->_M_equals(__k, __code, *__hint)\n \t    ? __hint\n \t    : _M_find_before_node(__bkt, __k, __code);\n+\n       if (__prev)\n \t{\n \t  // Insert after the node before the equivalent one.\n@@ -1820,9 +1837,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    // hint might be the last bucket node, in this case we need to\n \t    // update next bucket.\n \t    if (__node->_M_nxt\n-\t\t&& !this->_M_equals(__k, __code, __node->_M_next()))\n+\t\t&& !this->_M_equals(__k, __code, *__node->_M_next()))\n \t      {\n-\t\tsize_type __next_bkt = _M_bucket_index(__node->_M_next());\n+\t\tsize_type __next_bkt = _M_bucket_index(*__node->_M_next());\n \t\tif (__next_bkt != __bkt)\n \t\t  _M_buckets[__next_bkt] = __node;\n \t      }\n@@ -1853,7 +1870,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t__hash_code __code = this->_M_hash_code(__k);\n \tsize_type __bkt = _M_bucket_index(__code);\n \n-\tif (__node_type* __node = _M_find_node(__bkt, __k, __code))\n+\tif (__node_ptr __node = _M_find_node(__bkt, __k, __code))\n \t  return { iterator(__node), false };\n \n \t_Scoped_node __node{ __node_gen(std::forward<_Arg>(__v)), this };\n@@ -1899,13 +1916,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     erase(const_iterator __it)\n     -> iterator\n     {\n-      __node_type* __n = __it._M_cur;\n-      std::size_t __bkt = _M_bucket_index(__n);\n+      __node_ptr __n = __it._M_cur;\n+      std::size_t __bkt = _M_bucket_index(*__n);\n \n       // Look for previous node to unlink it from the erased one, this\n       // is why we need buckets to contain the before begin to make\n       // this search fast.\n-      __node_base* __prev_n = _M_get_previous_node(__bkt, __n);\n+      __node_base_ptr __prev_n = _M_get_previous_node(__bkt, __n);\n       return _M_erase(__bkt, __prev_n, __n);\n     }\n \n@@ -1916,15 +1933,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     auto\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n-    _M_erase(size_type __bkt, __node_base* __prev_n, __node_type* __n)\n+    _M_erase(size_type __bkt, __node_base_ptr __prev_n, __node_ptr __n)\n     -> iterator\n     {\n       if (__prev_n == _M_buckets[__bkt])\n \t_M_remove_bucket_begin(__bkt, __n->_M_next(),\n-\t   __n->_M_nxt ? _M_bucket_index(__n->_M_next()) : 0);\n+\t  __n->_M_nxt ? _M_bucket_index(*__n->_M_next()) : 0);\n       else if (__n->_M_nxt)\n \t{\n-\t  size_type __next_bkt = _M_bucket_index(__n->_M_next());\n+\t  size_type __next_bkt = _M_bucket_index(*__n->_M_next());\n \t  if (__next_bkt != __bkt)\n \t    _M_buckets[__next_bkt] = __prev_n;\n \t}\n@@ -1951,12 +1968,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       std::size_t __bkt = _M_bucket_index(__code);\n \n       // Look for the node before the first matching node.\n-      __node_base* __prev_n = _M_find_before_node(__bkt, __k, __code);\n+      __node_base_ptr __prev_n = _M_find_before_node(__bkt, __k, __code);\n       if (!__prev_n)\n \treturn 0;\n \n       // We found a matching node, erase it.\n-      __node_type* __n = static_cast<__node_type*>(__prev_n->_M_nxt);\n+      __node_ptr __n = static_cast<__node_ptr>(__prev_n->_M_nxt);\n       _M_erase(__bkt, __prev_n, __n);\n       return 1;\n     }\n@@ -1975,7 +1992,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       std::size_t __bkt = _M_bucket_index(__code);\n \n       // Look for the node before the first matching node.\n-      __node_base* __prev_n = _M_find_before_node(__bkt, __k, __code);\n+      __node_base_ptr __prev_n = _M_find_before_node(__bkt, __k, __code);\n       if (!__prev_n)\n \treturn 0;\n \n@@ -1985,18 +2002,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       // We use one loop to find all matching nodes and another to deallocate\n       // them so that the key stays valid during the first loop. It might be\n       // invalidated indirectly when destroying nodes.\n-      __node_type* __n = static_cast<__node_type*>(__prev_n->_M_nxt);\n-      __node_type* __n_last = __n->_M_next();\n-      while (__n_last && this->_M_node_equals(__n, __n_last))\n+      __node_ptr __n = static_cast<__node_ptr>(__prev_n->_M_nxt);\n+      __node_ptr __n_last = __n->_M_next();\n+      while (__n_last && this->_M_node_equals(*__n, *__n_last))\n \t__n_last = __n_last->_M_next();\n \n-      std::size_t __n_last_bkt = __n_last ? _M_bucket_index(__n_last) : __bkt;\n+      std::size_t __n_last_bkt = __n_last ? _M_bucket_index(*__n_last) : __bkt;\n \n       // Deallocate nodes.\n       size_type __result = 0;\n       do\n \t{\n-\t  __node_type* __p = __n->_M_next();\n+\t  __node_ptr __p = __n->_M_next();\n \t  this->_M_deallocate_node(__n);\n \t  __n = __p;\n \t  ++__result;\n@@ -2022,27 +2039,27 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     erase(const_iterator __first, const_iterator __last)\n     -> iterator\n     {\n-      __node_type* __n = __first._M_cur;\n-      __node_type* __last_n = __last._M_cur;\n+      __node_ptr __n = __first._M_cur;\n+      __node_ptr __last_n = __last._M_cur;\n       if (__n == __last_n)\n \treturn iterator(__n);\n \n-      std::size_t __bkt = _M_bucket_index(__n);\n+      std::size_t __bkt = _M_bucket_index(*__n);\n \n-      __node_base* __prev_n = _M_get_previous_node(__bkt, __n);\n+      __node_base_ptr __prev_n = _M_get_previous_node(__bkt, __n);\n       bool __is_bucket_begin = __n == _M_bucket_begin(__bkt);\n       std::size_t __n_bkt = __bkt;\n       for (;;)\n \t{\n \t  do\n \t    {\n-\t      __node_type* __tmp = __n;\n+\t      __node_ptr __tmp = __n;\n \t      __n = __n->_M_next();\n \t      this->_M_deallocate_node(__tmp);\n \t      --_M_element_count;\n \t      if (!__n)\n \t\tbreak;\n-\t      __n_bkt = _M_bucket_index(__n);\n+\t      __n_bkt = _M_bucket_index(*__n);\n \t    }\n \t  while (__n != __last_n && __n_bkt == __bkt);\n \t  if (__is_bucket_begin)\n@@ -2069,7 +2086,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     clear() noexcept\n     {\n       this->_M_deallocate_nodes(_M_begin());\n-      __builtin_memset(_M_buckets, 0, _M_bucket_count * sizeof(__bucket_type));\n+      __builtin_memset(_M_buckets, 0,\n+\t\t       _M_bucket_count * sizeof(__node_base_ptr));\n       _M_element_count = 0;\n       _M_before_begin._M_nxt = nullptr;\n     }\n@@ -2129,15 +2147,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n     _M_rehash_aux(size_type __bkt_count, true_type /* __uks */)\n     {\n-      __bucket_type* __new_buckets = _M_allocate_buckets(__bkt_count);\n-      __node_type* __p = _M_begin();\n+      __buckets_ptr __new_buckets = _M_allocate_buckets(__bkt_count);\n+      __node_ptr __p = _M_begin();\n       _M_before_begin._M_nxt = nullptr;\n       std::size_t __bbegin_bkt = 0;\n       while (__p)\n \t{\n-\t  __node_type* __next = __p->_M_next();\n+\t  __node_ptr __next = __p->_M_next();\n \t  std::size_t __bkt\n-\t    = __hash_code_base::_M_bucket_index(__p, __bkt_count);\n+\t    = __hash_code_base::_M_bucket_index(*__p, __bkt_count);\n \t  if (!__new_buckets[__bkt])\n \t    {\n \t      __p->_M_nxt = _M_before_begin._M_nxt;\n@@ -2172,20 +2190,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n     _M_rehash_aux(size_type __bkt_count, false_type /* __uks */)\n     {\n-      __bucket_type* __new_buckets = _M_allocate_buckets(__bkt_count);\n-\n-      __node_type* __p = _M_begin();\n+      __buckets_ptr __new_buckets = _M_allocate_buckets(__bkt_count);\n+      __node_ptr __p = _M_begin();\n       _M_before_begin._M_nxt = nullptr;\n       std::size_t __bbegin_bkt = 0;\n       std::size_t __prev_bkt = 0;\n-      __node_type* __prev_p = nullptr;\n+      __node_ptr __prev_p = nullptr;\n       bool __check_bucket = false;\n \n       while (__p)\n \t{\n-\t  __node_type* __next = __p->_M_next();\n+\t  __node_ptr __next = __p->_M_next();\n \t  std::size_t __bkt\n-\t    = __hash_code_base::_M_bucket_index(__p, __bkt_count);\n+\t    = __hash_code_base::_M_bucket_index(*__p, __bkt_count);\n \n \t  if (__prev_p && __prev_bkt == __bkt)\n \t    {\n@@ -2211,8 +2228,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t  if (__prev_p->_M_nxt)\n \t\t    {\n \t\t      std::size_t __next_bkt\n-\t\t\t= __hash_code_base::_M_bucket_index(__prev_p->_M_next(),\n-\t\t\t\t\t\t\t    __bkt_count);\n+\t\t\t= __hash_code_base::_M_bucket_index(\n+\t\t\t  *__prev_p->_M_next(), __bkt_count);\n \t\t      if (__next_bkt != __prev_bkt)\n \t\t\t__new_buckets[__next_bkt] = __prev_p;\n \t\t    }\n@@ -2242,7 +2259,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       if (__check_bucket && __prev_p->_M_nxt)\n \t{\n \t  std::size_t __next_bkt\n-\t    = __hash_code_base::_M_bucket_index(__prev_p->_M_next(),\n+\t    = __hash_code_base::_M_bucket_index(*__prev_p->_M_next(),\n \t\t\t\t\t\t__bkt_count);\n \t  if (__next_bkt != __prev_bkt)\n \t    __new_buckets[__next_bkt] = __prev_p;"}, {"sha": "f5ce7209957561959d53e044eb6fa727f9bce73b", "filename": "libstdc++-v3/include/bits/hashtable_policy.h", "status": "modified", "additions": 175, "deletions": 251, "changes": 426, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b6f0476837205932613ddb2b3429a55c26c409d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b6f0476837205932613ddb2b3429a55c26c409d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h?ref=1b6f0476837205932613ddb2b3429a55c26c409d", "patch": "@@ -226,7 +226,7 @@ namespace __detail\n    *  Node type with the value to store.\n    */\n   template<typename _Value>\n-    struct _Hash_node_value_base : _Hash_node_base\n+    struct _Hash_node_value_base\n     {\n       typedef _Value value_type;\n \n@@ -250,33 +250,32 @@ namespace __detail\n     };\n \n   /**\n-   *  Primary template struct _Hash_node.\n+   *  Primary template struct _Hash_node_code_cache.\n    */\n-  template<typename _Value, bool _Cache_hash_code>\n-    struct _Hash_node;\n+  template<bool _Cache_hash_code>\n+    struct _Hash_node_code_cache\n+    { };\n \n   /**\n-   *  Specialization for nodes with caches, struct _Hash_node.\n-   *\n-   *  Base class is __detail::_Hash_node_value_base.\n+   *  Specialization for node with cache, struct _Hash_node_code_cache.\n    */\n-  template<typename _Value>\n-    struct _Hash_node<_Value, true> : _Hash_node_value_base<_Value>\n-    {\n-      std::size_t  _M_hash_code;\n+  template<>\n+    struct _Hash_node_code_cache<true>\n+    { std::size_t  _M_hash_code; };\n \n-      _Hash_node*\n-      _M_next() const noexcept\n-      { return static_cast<_Hash_node*>(this->_M_nxt); }\n-    };\n+  template<typename _Value, bool _Cache_hash_code>\n+    struct _Hash_node_value\n+    : _Hash_node_value_base<_Value>\n+    , _Hash_node_code_cache<_Cache_hash_code>\n+    { };\n \n   /**\n-   *  Specialization for nodes without caches, struct _Hash_node.\n-   *\n-   *  Base class is __detail::_Hash_node_value_base.\n+   *  Primary template struct _Hash_node.\n    */\n-  template<typename _Value>\n-    struct _Hash_node<_Value, false> : _Hash_node_value_base<_Value>\n+  template<typename _Value, bool _Cache_hash_code>\n+    struct _Hash_node\n+    : _Hash_node_base\n+    , _Hash_node_value<_Value, _Cache_hash_code>\n     {\n       _Hash_node*\n       _M_next() const noexcept\n@@ -289,7 +288,7 @@ namespace __detail\n     {\n       using __node_type = _Hash_node<_Value, _Cache_hash_code>;\n \n-      __node_type*  _M_cur;\n+      __node_type* _M_cur;\n \n       _Node_iterator_base() = default;\n       _Node_iterator_base(__node_type* __p) noexcept\n@@ -327,10 +326,10 @@ namespace __detail\n       typedef std::forward_iterator_tag\t\t\titerator_category;\n \n       using pointer = typename std::conditional<__constant_iterators,\n-\t\t\t\t\t\tconst _Value*, _Value*>::type;\n+\t\t\t\t  const value_type*, value_type*>::type;\n \n       using reference = typename std::conditional<__constant_iterators,\n-\t\t\t\t\t\t  const _Value&, _Value&>::type;\n+\t\t\t\t  const value_type&, value_type&>::type;\n \n       _Node_iterator() noexcept\n       : __base_type(nullptr) { }\n@@ -377,8 +376,8 @@ namespace __detail\n       typedef std::ptrdiff_t\t\t\t\tdifference_type;\n       typedef std::forward_iterator_tag\t\t\titerator_category;\n \n-      typedef const _Value*\t\t\t\tpointer;\n-      typedef const _Value&\t\t\t\treference;\n+      typedef const value_type*\t\t\t\tpointer;\n+      typedef const value_type&\t\t\t\treference;\n \n       _Node_const_iterator() noexcept\n       : __base_type(nullptr) { }\n@@ -671,11 +670,9 @@ namespace __detail\n \t\t\t\t     _Unused, _RehashPolicy, _Traits>;\n \n       using __hash_code = typename __hashtable_base::__hash_code;\n-      using __node_type = typename __hashtable_base::__node_type;\n \n     public:\n       using key_type = typename __hashtable_base::key_type;\n-      using iterator = typename __hashtable_base::iterator;\n       using mapped_type = typename std::tuple_element<1, _Pair>::type;\n \n       mapped_type&\n@@ -705,7 +702,7 @@ namespace __detail\n       __hashtable* __h = static_cast<__hashtable*>(this);\n       __hash_code __code = __h->_M_hash_code(__k);\n       std::size_t __bkt = __h->_M_bucket_index(__code);\n-      if (__node_type* __node = __h->_M_find_node(__bkt, __k, __code))\n+      if (auto __node = __h->_M_find_node(__bkt, __k, __code))\n \treturn __node->_M_v().second;\n \n       typename __hashtable::_Scoped_node __node {\n@@ -732,7 +729,7 @@ namespace __detail\n       __hashtable* __h = static_cast<__hashtable*>(this);\n       __hash_code __code = __h->_M_hash_code(__k);\n       std::size_t __bkt = __h->_M_bucket_index(__code);\n-      if (__node_type* __node = __h->_M_find_node(__bkt, __k, __code))\n+      if (auto __node = __h->_M_find_node(__bkt, __k, __code))\n \treturn __node->_M_v().second;\n \n       typename __hashtable::_Scoped_node __node {\n@@ -801,15 +798,18 @@ namespace __detail\n \t\t\t\t     _Hash, _RangeHash,\n \t\t\t\t     _Unused, _RehashPolicy, _Traits>;\n \n+      using __hash_cached = typename _Traits::__hash_cached;\n+      using __constant_iterators = typename _Traits::__constant_iterators;\n+\n+      using __hashtable_alloc = _Hashtable_alloc<\n+\t__alloc_rebind<_Alloc, _Hash_node<_Value,\n+\t\t\t\t\t  __hash_cached::value>>>;\n+\n       using value_type = typename __hashtable_base::value_type;\n-      using iterator = typename __hashtable_base::iterator;\n-      using const_iterator =  typename __hashtable_base::const_iterator;\n       using size_type = typename __hashtable_base::size_type;\n \n-      using __unique_keys = typename __hashtable_base::__unique_keys;\n-      using __ireturn_type = typename __hashtable_base::__ireturn_type;\n-      using __node_type = _Hash_node<_Value, _Traits::__hash_cached::value>;\n-      using __node_alloc_type = __alloc_rebind<_Alloc, __node_type>;\n+      using __unique_keys = typename _Traits::__unique_keys;\n+      using __node_alloc_type = typename __hashtable_alloc::__node_alloc_type;\n       using __node_gen_type = _AllocNode<__node_alloc_type>;\n \n       __hashtable&\n@@ -827,6 +827,16 @@ namespace __detail\n \t\t\tconst _NodeGetter&, false_type __uks);\n \n     public:\n+      using iterator = _Node_iterator<_Value, __constant_iterators::value,\n+\t\t\t\t      __hash_cached::value>;\n+\n+      using const_iterator = _Node_const_iterator<_Value, __constant_iterators::value,\n+\t\t\t\t\t\t  __hash_cached::value>;\n+\n+      using __ireturn_type = typename std::conditional<__unique_keys::value,\n+\t\t\t\t\t\t     std::pair<iterator, bool>,\n+\t\t\t\t\t\t     iterator>::type;\n+\n       __ireturn_type\n       insert(const value_type& __v)\n       {\n@@ -850,7 +860,7 @@ namespace __detail\n \t  __hashtable& __h = _M_conjure_hashtable();\n \t  auto __code = __h._M_hash_code(__k);\n \t  std::size_t __bkt = __h._M_bucket_index(__code);\n-\t  if (__node_type* __node = __h._M_find_node(__bkt, __k, __code))\n+\t  if (auto __node = __h._M_find_node(__bkt, __k, __code))\n \t    return { iterator(__node), false };\n \n \t  typename __hashtable::_Scoped_node __node {\n@@ -958,16 +968,12 @@ namespace __detail\n \t\t\t\t       _Equal, _Hash, _RangeHash, _Unused,\n \t\t\t\t       _RehashPolicy, _Traits>;\n \n-      using __hashtable_base = _Hashtable_base<_Key, _Value, _ExtractKey,\n-\t\t\t\t\t       _Equal, _Hash, _RangeHash,\n-\t\t\t\t\t       _Unused, _Traits>;\n-\n       using value_type = typename __base_type::value_type;\n       using iterator = typename __base_type::iterator;\n       using const_iterator =  typename __base_type::const_iterator;\n+      using __ireturn_type = typename __base_type::__ireturn_type;\n \n       using __unique_keys = typename __base_type::__unique_keys;\n-      using __ireturn_type = typename __hashtable_base::__ireturn_type;\n       using __hashtable = typename __base_type::__hashtable;\n       using __node_gen_type = typename __base_type::__node_gen_type;\n \n@@ -1176,21 +1182,11 @@ namespace __detail\n    *  is inherited in some cases by the _Local_iterator_base type used\n    *  to implement local_iterator and const_local_iterator. As with\n    *  any iterator type we prefer to make it as small as possible.\n-   *\n-   *  Primary template is unused except as a hook for specializations.\n    */\n   template<typename _Key, typename _Value, typename _ExtractKey,\n \t   typename _Hash, typename _RangeHash, typename _Unused,\n \t   bool __cache_hash_code>\n-    struct _Hash_code_base;\n-\n-  /// Specialization: hash function and range-hashing function, no\n-  /// caching of hash codes.\n-  /// Provides typedef and accessor required by C++ 11.\n-  template<typename _Key, typename _Value, typename _ExtractKey,\n-\t   typename _Hash, typename _RangeHash, typename _Unused>\n-    struct _Hash_code_base<_Key, _Value, _ExtractKey, _Hash, _RangeHash,\n-\t\t\t   _Unused, false>\n+    struct _Hash_code_base\n     : private _Hashtable_ebo_helper<1, _Hash>\n     {\n     private:\n@@ -1209,7 +1205,6 @@ namespace __detail\n \n     protected:\n       typedef std::size_t \t\t\t\t__hash_code;\n-      typedef _Hash_node<_Value, false>\t\t\t__node_type;\n \n       // We need the default constructor for the local iterators and _Hashtable\n       // default constructor.\n@@ -1229,83 +1224,40 @@ namespace __detail\n       { return _RangeHash{}(__c, __bkt_count); }\n \n       std::size_t\n-      _M_bucket_index(const __node_type* __p, std::size_t __bkt_count) const\n+      _M_bucket_index(const _Hash_node_value<_Value, false>& __n,\n+\t\t      std::size_t __bkt_count) const\n \tnoexcept( noexcept(declval<const _Hash&>()(declval<const _Key&>()))\n \t\t  && noexcept(declval<const _RangeHash&>()((__hash_code)0,\n \t\t\t\t\t\t\t   (std::size_t)0)) )\n       {\n-\treturn _RangeHash{}(_M_hash()(_ExtractKey{}(__p->_M_v())),\n+\treturn _RangeHash{}(_M_hash_code(_ExtractKey{}(__n._M_v())),\n \t\t\t    __bkt_count);\n       }\n \n-      void\n-      _M_store_code(__node_type*, __hash_code) const\n-      { }\n+      std::size_t\n+      _M_bucket_index(const _Hash_node_value<_Value, true>& __n,\n+\t\t      std::size_t __bkt_count) const\n+\tnoexcept( noexcept(declval<const _RangeHash&>()((__hash_code)0,\n+\t\t\t\t\t\t\t(std::size_t)0)) )\n+      { return _RangeHash{}(__n._M_hash_code, __bkt_count); }\n \n       void\n-      _M_copy_code(__node_type*, const __node_type*) const\n+      _M_store_code(_Hash_node_code_cache<false>&, __hash_code) const\n       { }\n \n       void\n-      _M_swap(_Hash_code_base& __x)\n-      { std::swap(__ebo_hash::_M_get(), __x.__ebo_hash::_M_get()); }\n-\n-      const _Hash&\n-      _M_hash() const { return __ebo_hash::_M_cget(); }\n-    };\n-\n-  /// Specialization: hash function and range-hashing function,\n-  /// caching hash codes.  H is provided but ignored.  Provides\n-  /// typedef and accessor required by C++ 11.\n-  template<typename _Key, typename _Value, typename _ExtractKey,\n-\t   typename _Hash, typename _RangeHash, typename _Unused>\n-    struct _Hash_code_base<_Key, _Value, _ExtractKey, _Hash, _RangeHash,\n-\t\t\t   _Unused, true>\n-    : private _Hashtable_ebo_helper<1, _Hash>\n-    {\n-    private:\n-      using __ebo_hash = _Hashtable_ebo_helper<1, _Hash>;\n-\n-    public:\n-      typedef _Hash\t\t\t\t\thasher;\n-\n-      hasher\n-      hash_function() const\n-      { return _M_hash(); }\n-\n-    protected:\n-      typedef std::size_t \t\t\t\t__hash_code;\n-      typedef _Hash_node<_Value, true>\t\t\t__node_type;\n-\n-      // We need the default constructor for _Hashtable default constructor.\n-      _Hash_code_base() = default;\n-      _Hash_code_base(const _Hash& __hash) : __ebo_hash(__hash) { }\n-\n-      __hash_code\n-      _M_hash_code(const _Key& __k) const\n-      {\n-\tstatic_assert(__is_invocable<const _Hash&, const _Key&>{},\n-\t    \"hash function must be invocable with an argument of key type\");\n-\treturn _M_hash()(__k);\n-      }\n-\n-      std::size_t\n-      _M_bucket_index(__hash_code __c, std::size_t __bkt_count) const\n-      { return _RangeHash{}(__c, __bkt_count); }\n-\n-      std::size_t\n-      _M_bucket_index(const __node_type* __p, std::size_t __bkt_count) const\n-\tnoexcept( noexcept(declval<const _RangeHash&>()((__hash_code)0,\n-\t\t\t\t\t\t\t(std::size_t)0)) )\n-      { return _RangeHash{}(__p->_M_hash_code, __bkt_count); }\n+      _M_copy_code(_Hash_node_code_cache<false>&,\n+\t\t   const _Hash_node_code_cache<false>&) const\n+      { }\n \n       void\n-      _M_store_code(__node_type* __n, __hash_code __c) const\n-      { __n->_M_hash_code = __c; }\n+      _M_store_code(_Hash_node_code_cache<true>& __n, __hash_code __c) const\n+      { __n._M_hash_code = __c; }\n \n       void\n-      _M_copy_code(__node_type* __to, const __node_type* __from) const\n-      { __to->_M_hash_code = __from->_M_hash_code; }\n+      _M_copy_code(_Hash_node_code_cache<true>& __to,\n+\t\t   const _Hash_node_code_cache<true>& __from) const\n+      { __to._M_hash_code = __from._M_hash_code; }\n \n       void\n       _M_swap(_Hash_code_base& __x)\n@@ -1421,7 +1373,7 @@ namespace __detail\n       }\n \n       _Local_iterator_base(const _Local_iterator_base& __iter)\n-      : __node_iter_base(__iter), _M_bucket(__iter._M_bucket)\n+      : __node_iter_base(__iter._M_cur), _M_bucket(__iter._M_bucket)\n       , _M_bucket_count(__iter._M_bucket_count)\n       {\n \tif (_M_bucket_count != -1)\n@@ -1447,7 +1399,7 @@ namespace __detail\n \t__node_iter_base::_M_incr();\n \tif (this->_M_cur)\n \t  {\n-\t    std::size_t __bkt = this->_M_h()->_M_bucket_index(this->_M_cur,\n+\t    std::size_t __bkt = this->_M_h()->_M_bucket_index(*this->_M_cur,\n \t\t\t\t\t\t\t      _M_bucket_count);\n \t    if (__bkt != _M_bucket)\n \t      this->_M_cur = nullptr;\n@@ -1485,10 +1437,10 @@ namespace __detail\n     public:\n       typedef _Value\t\t\t\t\tvalue_type;\n       typedef typename std::conditional<__constant_iterators,\n-\t\t\t\t\tconst _Value*, _Value*>::type\n+\t\t\t\t\tconst value_type*, value_type*>::type\n \t\t\t\t\t\t\tpointer;\n       typedef typename std::conditional<__constant_iterators,\n-\t\t\t\t\tconst _Value&, _Value&>::type\n+\t\t\t\t\tconst value_type&, value_type&>::type\n \t\t\t\t\t\t\treference;\n       typedef std::ptrdiff_t\t\t\t\tdifference_type;\n       typedef std::forward_iterator_tag\t\t\titerator_category;\n@@ -1540,8 +1492,8 @@ namespace __detail\n \n     public:\n       typedef _Value\t\t\t\t\tvalue_type;\n-      typedef const _Value*\t\t\t\tpointer;\n-      typedef const _Value&\t\t\t\treference;\n+      typedef const value_type*\t\t\t\tpointer;\n+      typedef const value_type&\t\t\t\treference;\n       typedef std::ptrdiff_t\t\t\t\tdifference_type;\n       typedef std::forward_iterator_tag\t\t\titerator_category;\n \n@@ -1600,110 +1552,80 @@ namespace __detail\n     struct _Hashtable_base\n     : public _Hash_code_base<_Key, _Value, _ExtractKey, _Hash, _RangeHash,\n \t\t\t     _Unused, _Traits::__hash_cached::value>,\n-    private _Hashtable_ebo_helper<0, _Equal>\n-  {\n-  public:\n-    typedef _Key\t\t\t\t\tkey_type;\n-    typedef _Value\t\t\t\t\tvalue_type;\n-    typedef _Equal\t\t\t\t\tkey_equal;\n-    typedef std::size_t\t\t\t\t\tsize_type;\n-    typedef std::ptrdiff_t\t\t\t\tdifference_type;\n-\n-    using __traits_type = _Traits;\n-    using __hash_cached = typename __traits_type::__hash_cached;\n-    using __constant_iterators = typename __traits_type::__constant_iterators;\n-    using __unique_keys = typename __traits_type::__unique_keys;\n-\n-    using __hash_code_base = _Hash_code_base<_Key, _Value, _ExtractKey,\n-\t\t\t\t\t     _Hash, _RangeHash, _Unused,\n-\t\t\t\t\t     __hash_cached::value>;\n-\n-    using __hash_code = typename __hash_code_base::__hash_code;\n-    using __node_type = typename __hash_code_base::__node_type;\n-\n-    using iterator = _Node_iterator<value_type,\n-\t\t\t\t    __constant_iterators::value,\n-\t\t\t\t    __hash_cached::value>;\n-\n-    using const_iterator = _Node_const_iterator<value_type,\n-\t\t\t\t\t\t__constant_iterators::value,\n-\t\t\t\t\t\t__hash_cached::value>;\n-\n-    using local_iterator = _Local_iterator<key_type, value_type,\n-\t\t\t\t\t_ExtractKey, _Hash, _RangeHash, _Unused,\n-\t\t\t\t\t   __constant_iterators::value,\n-\t\t\t\t\t   __hash_cached::value>;\n-\n-    using const_local_iterator = _Local_const_iterator<key_type, value_type,\n-\t\t\t\t\t_ExtractKey, _Hash, _RangeHash, _Unused,\n-\t\t\t\t\t__constant_iterators::value,\n-\t\t\t\t\t\t       __hash_cached::value>;\n-\n-    using __ireturn_type = typename std::conditional<__unique_keys::value,\n-\t\t\t\t\t\t     std::pair<iterator, bool>,\n-\t\t\t\t\t\t     iterator>::type;\n-  private:\n-    using _EqualEBO = _Hashtable_ebo_helper<0, _Equal>;\n+      private _Hashtable_ebo_helper<0, _Equal>\n+    {\n+    public:\n+      typedef _Key\t\t\t\t\tkey_type;\n+      typedef _Value\t\t\t\t\tvalue_type;\n+      typedef _Equal\t\t\t\t\tkey_equal;\n+      typedef std::size_t\t\t\t\tsize_type;\n+      typedef std::ptrdiff_t\t\t\t\tdifference_type;\n \n-    template<typename _NodeT>\n-      struct _Equal_hash_code\n-      {\n-\tstatic bool\n-\t_S_equals(__hash_code, const _NodeT&)\n-\t{ return true; }\n+      using __traits_type = _Traits;\n+      using __hash_cached = typename __traits_type::__hash_cached;\n \n-\tstatic bool\n-\t_S_node_equals(const _NodeT&, const _NodeT&)\n-\t{ return true; }\n-      };\n+      using __hash_code_base = _Hash_code_base<_Key, _Value, _ExtractKey,\n+\t\t\t\t\t       _Hash, _RangeHash, _Unused,\n+\t\t\t\t\t       __hash_cached::value>;\n \n-    template<typename _Ptr2>\n-      struct _Equal_hash_code<_Hash_node<_Ptr2, true>>\n-      {\n-\tstatic bool\n-\t_S_equals(__hash_code __c, const _Hash_node<_Ptr2, true>& __n)\n-\t{ return __c == __n._M_hash_code; }\n-\n-\tstatic bool\n-\t_S_node_equals(const _Hash_node<_Ptr2, true>& __lhn,\n-\t\t       const _Hash_node<_Ptr2, true>& __rhn)\n-\t{ return __lhn._M_hash_code == __rhn._M_hash_code; }\n-      };\n+      using __hash_code = typename __hash_code_base::__hash_code;\n \n-  protected:\n-    _Hashtable_base() = default;\n-    _Hashtable_base(const _Hash& __hash, const _Equal& __eq)\n-    : __hash_code_base(__hash), _EqualEBO(__eq)\n-    { }\n+    private:\n+      using _EqualEBO = _Hashtable_ebo_helper<0, _Equal>;\n \n-    bool\n-    _M_equals(const _Key& __k, __hash_code __c, const __node_type* __n) const\n-    {\n-      static_assert(__is_invocable<const _Equal&, const _Key&, const _Key&>{},\n+      static bool\n+      _S_equals(__hash_code, const _Hash_node_code_cache<false>&)\n+      { return true; }\n+\n+      static bool\n+      _S_node_equals(const _Hash_node_code_cache<false>&,\n+\t\t     const _Hash_node_code_cache<false>&)\n+      { return true; }\n+\n+      static bool\n+      _S_equals(__hash_code __c, const _Hash_node_code_cache<true>& __n)\n+      { return __c == __n._M_hash_code; }\n+\n+      static bool\n+      _S_node_equals(const _Hash_node_code_cache<true>& __lhn,\n+\t\t     const _Hash_node_code_cache<true>& __rhn)\n+      { return __lhn._M_hash_code == __rhn._M_hash_code; }\n+\n+    protected:\n+      _Hashtable_base() = default;\n+      _Hashtable_base(const _Hash& __hash, const _Equal& __eq)\n+      : __hash_code_base(__hash), _EqualEBO(__eq)\n+      { }\n+\n+      bool\n+      _M_equals(const _Key& __k, __hash_code __c,\n+\t\tconst _Hash_node_value<_Value, __hash_cached::value>& __n) const\n+      {\n+\tstatic_assert(__is_invocable<const _Equal&, const _Key&, const _Key&>{},\n \t  \"key equality predicate must be invocable with two arguments of \"\n \t  \"key type\");\n-      return _Equal_hash_code<__node_type>::_S_equals(__c, *__n)\n-\t&& _M_eq()(__k, _ExtractKey{}(__n->_M_v()));\n-    }\n+\treturn _S_equals(__c, __n) && _M_eq()(__k, _ExtractKey{}(__n._M_v()));\n+      }\n \n-    bool\n-    _M_node_equals(const __node_type* __lhn, const __node_type* __rhn) const\n-    {\n-      return _Equal_hash_code<__node_type>::_S_node_equals(*__lhn, *__rhn)\n-\t&& _M_eq()(_ExtractKey{}(__lhn->_M_v()),\n-\t\t   _ExtractKey{}(__rhn->_M_v()));\n-    }\n+      bool\n+      _M_node_equals(\n+\tconst _Hash_node_value<_Value, __hash_cached::value>& __lhn,\n+\tconst _Hash_node_value<_Value, __hash_cached::value>& __rhn) const\n+      {\n+\treturn _S_node_equals(__lhn, __rhn)\n+\t  && _M_eq()(_ExtractKey{}(__lhn._M_v()), _ExtractKey{}(__rhn._M_v()));\n+      }\n \n-    void\n-    _M_swap(_Hashtable_base& __x)\n-    {\n-      __hash_code_base::_M_swap(__x);\n-      std::swap(_EqualEBO::_M_get(), __x._EqualEBO::_M_get());\n-    }\n+      void\n+      _M_swap(_Hashtable_base& __x)\n+      {\n+\t__hash_code_base::_M_swap(__x);\n+\tstd::swap(_EqualEBO::_M_get(), __x._EqualEBO::_M_get());\n+      }\n \n-    const _Equal&\n-    _M_eq() const { return _EqualEBO::_M_cget(); }\n-  };\n+      const _Equal&\n+      _M_eq() const { return _EqualEBO::_M_cget(); }\n+    };\n \n   /**\n    *  Primary class template  _Equality.\n@@ -1745,16 +1667,15 @@ namespace __detail\n \t      _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, true>::\n     _M_equal(const __hashtable& __other) const\n     {\n-      using __node_base = typename __hashtable::__node_base;\n       using __node_type = typename __hashtable::__node_type;\n       const __hashtable* __this = static_cast<const __hashtable*>(this);\n       if (__this->size() != __other.size())\n \treturn false;\n \n       for (auto __itx = __this->begin(); __itx != __this->end(); ++__itx)\n \t{\n-\t  std::size_t __ybkt = __other._M_bucket_index(__itx._M_cur);\n-\t  __node_base* __prev_n = __other._M_buckets[__ybkt];\n+\t  std::size_t __ybkt = __other._M_bucket_index(*__itx._M_cur);\n+\t  auto __prev_n = __other._M_buckets[__ybkt];\n \t  if (!__prev_n)\n \t    return false;\n \n@@ -1765,7 +1686,7 @@ namespace __detail\n \t\tbreak;\n \n \t      if (!__n->_M_nxt\n-\t\t  || __other._M_bucket_index(__n->_M_next()) != __ybkt)\n+\t\t  || __other._M_bucket_index(*__n->_M_next()) != __ybkt)\n \t\treturn false;\n \t    }\n \t}\n@@ -1798,7 +1719,6 @@ namespace __detail\n \t      _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, false>::\n     _M_equal(const __hashtable& __other) const\n     {\n-      using __node_base = typename __hashtable::__node_base;\n       using __node_type = typename __hashtable::__node_type;\n       const __hashtable* __this = static_cast<const __hashtable*>(this);\n       if (__this->size() != __other.size())\n@@ -1814,8 +1734,8 @@ namespace __detail\n \t       ++__itx_end)\n \t    ++__x_count;\n \n-\t  std::size_t __ybkt = __other._M_bucket_index(__itx._M_cur);\n-\t  __node_base* __y_prev_n = __other._M_buckets[__ybkt];\n+\t  std::size_t __ybkt = __other._M_bucket_index(*__itx._M_cur);\n+\t  auto __y_prev_n = __other._M_buckets[__ybkt];\n \t  if (!__y_prev_n)\n \t    return false;\n \n@@ -1826,12 +1746,12 @@ namespace __detail\n \t\t\t\t   _ExtractKey{}(*__itx)))\n \t\tbreak;\n \n-\t      __node_type* __y_ref_n = __y_n;\n+\t      auto __y_ref_n = __y_n;\n \t      for (__y_n = __y_n->_M_next(); __y_n; __y_n = __y_n->_M_next())\n-\t\tif (!__other._M_node_equals(__y_ref_n, __y_n))\n+\t\tif (!__other._M_node_equals(*__y_ref_n, *__y_n))\n \t\t  break;\n \n-\t      if (!__y_n || __other._M_bucket_index(__y_n) != __ybkt)\n+\t      if (!__y_n || __other._M_bucket_index(*__y_n) != __ybkt)\n \t\treturn false;\n \t    }\n \n@@ -1869,11 +1789,13 @@ namespace __detail\n       using __value_alloc_traits = typename __node_alloc_traits::template\n \trebind_traits<typename __node_type::value_type>;\n \n-      using __node_base = __detail::_Hash_node_base;\n-      using __bucket_type = __node_base*;      \n-      using __bucket_alloc_type =\n-\t__alloc_rebind<__node_alloc_type, __bucket_type>;\n-      using __bucket_alloc_traits = std::allocator_traits<__bucket_alloc_type>;\n+      using __node_ptr = __node_type*;\n+      using __node_base = _Hash_node_base;\n+      using __node_base_ptr = __node_base*;\n+      using __buckets_alloc_type =\n+\t__alloc_rebind<__node_alloc_type, __node_base_ptr>;\n+      using __buckets_alloc_traits = std::allocator_traits<__buckets_alloc_type>;\n+      using __buckets_ptr = __node_base_ptr*;\n \n       _Hashtable_alloc() = default;\n       _Hashtable_alloc(const _Hashtable_alloc&) = default;\n@@ -1894,27 +1816,27 @@ namespace __detail\n \n       // Allocate a node and construct an element within it.\n       template<typename... _Args>\n-\t__node_type*\n+\t__node_ptr\n \t_M_allocate_node(_Args&&... __args);\n \n       // Destroy the element within a node and deallocate the node.\n       void\n-      _M_deallocate_node(__node_type* __n);\n+      _M_deallocate_node(__node_ptr __n);\n \n       // Deallocate a node.\n       void\n-      _M_deallocate_node_ptr(__node_type* __n);\n+      _M_deallocate_node_ptr(__node_ptr __n);\n \n       // Deallocate the linked list of nodes pointed to by __n.\n       // The elements within the nodes are destroyed.\n       void\n-      _M_deallocate_nodes(__node_type* __n);\n+      _M_deallocate_nodes(__node_ptr __n);\n \n-      __bucket_type*\n+      __buckets_ptr\n       _M_allocate_buckets(std::size_t __bkt_count);\n \n       void\n-      _M_deallocate_buckets(__bucket_type*, std::size_t __bkt_count);\n+      _M_deallocate_buckets(__buckets_ptr, std::size_t __bkt_count);\n     };\n \n   // Definitions of class template _Hashtable_alloc's out-of-line member\n@@ -1923,10 +1845,10 @@ namespace __detail\n     template<typename... _Args>\n       auto\n       _Hashtable_alloc<_NodeAlloc>::_M_allocate_node(_Args&&... __args)\n-      -> __node_type*\n+      -> __node_ptr\n       {\n \tauto __nptr = __node_alloc_traits::allocate(_M_node_allocator(), 1);\n-\t__node_type* __n = std::__to_address(__nptr);\n+\t__node_ptr __n = std::__to_address(__nptr);\n \t__try\n \t  {\n \t    ::new ((void*)__n) __node_type;\n@@ -1944,15 +1866,15 @@ namespace __detail\n \n   template<typename _NodeAlloc>\n     void\n-    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_node(__node_type* __n)\n+    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_node(__node_ptr __n)\n     {\n       __node_alloc_traits::destroy(_M_node_allocator(), __n->_M_valptr());\n       _M_deallocate_node_ptr(__n);\n     }\n \n   template<typename _NodeAlloc>\n     void\n-    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_node_ptr(__node_type* __n)\n+    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_node_ptr(__node_ptr __n)\n     {\n       typedef typename __node_alloc_traits::pointer _Ptr;\n       auto __ptr = std::pointer_traits<_Ptr>::pointer_to(*__n);\n@@ -1962,37 +1884,39 @@ namespace __detail\n \n   template<typename _NodeAlloc>\n     void\n-    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_nodes(__node_type* __n)\n+    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_nodes(__node_ptr __n)\n     {\n       while (__n)\n \t{\n-\t  __node_type* __tmp = __n;\n+\t  __node_ptr __tmp = __n;\n \t  __n = __n->_M_next();\n \t  _M_deallocate_node(__tmp);\n \t}\n     }\n \n   template<typename _NodeAlloc>\n-    typename _Hashtable_alloc<_NodeAlloc>::__bucket_type*\n+    auto\n     _Hashtable_alloc<_NodeAlloc>::_M_allocate_buckets(std::size_t __bkt_count)\n+    -> __buckets_ptr\n     {\n-      __bucket_alloc_type __alloc(_M_node_allocator());\n+      __buckets_alloc_type __alloc(_M_node_allocator());\n \n-      auto __ptr = __bucket_alloc_traits::allocate(__alloc, __bkt_count);\n-      __bucket_type* __p = std::__to_address(__ptr);\n-      __builtin_memset(__p, 0, __bkt_count * sizeof(__bucket_type));\n+      auto __ptr = __buckets_alloc_traits::allocate(__alloc, __bkt_count);\n+      __buckets_ptr __p = std::__to_address(__ptr);\n+      __builtin_memset(__p, 0, __bkt_count * sizeof(__node_base_ptr));\n       return __p;\n     }\n \n   template<typename _NodeAlloc>\n     void\n-    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_buckets(__bucket_type* __bkts,\n-\t\t\t\t\t\t\tstd::size_t __bkt_count)\n+    _Hashtable_alloc<_NodeAlloc>::\n+    _M_deallocate_buckets(__buckets_ptr __bkts,\n+\t\t\t  std::size_t __bkt_count)\n     {\n-      typedef typename __bucket_alloc_traits::pointer _Ptr;\n+      typedef typename __buckets_alloc_traits::pointer _Ptr;\n       auto __ptr = std::pointer_traits<_Ptr>::pointer_to(*__bkts);\n-      __bucket_alloc_type __alloc(_M_node_allocator());\n-      __bucket_alloc_traits::deallocate(__alloc, __ptr, __bkt_count);\n+      __buckets_alloc_type __alloc(_M_node_allocator());\n+      __buckets_alloc_traits::deallocate(__alloc, __ptr, __bkt_count);\n     }\n \n  //@} hashtable-detail"}]}