{"sha": "ad2a084dbd3fbcacde8a5034ef381b1ee41d09e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWQyYTA4NGRiZDNmYmNhY2RlOGE1MDM0ZWYzODFiMWVlNDFkMDllNQ==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2000-12-17T00:13:54Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2000-12-17T00:13:54Z"}, "message": "c-lex.c: Move main_input_filename handling to FC_ENTER.\n\n        * c-lex.c: Move main_input_filename handling to FC_ENTER. Clean up.\n        * cpperror.c (print_containing_files): Get right line number.\n        (print_location): Output column of 1 if 0.\n        * cppfiles.c (stack_include_file): cpp_push_buffer handles\n        the callback.\n        * cpphash.h (_cpp_do_file_change): No longer external.\n        * cpplib.c (do_file_change): Now local to cpplib.c.\n        (do_line): Fake a buffer stack for preprocessed files.\n        (cpp_push_buffer): Create a file_change callback.  Handle faked\n        buffers.\n        (cpp_pop_buffer): Similarly.\n        * cpplib.h: BUF_FAKE: New buffer type.\n        * cppmain.c: Update to handle correct file renaming where a\n        #line is the first line of the main file, and produce only\n        the renamed file, not the original file, as output.\n\nFrom-SVN: r38319", "tree": {"sha": "dc9788c071208bc6125b57c49a68337f6a09eb53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc9788c071208bc6125b57c49a68337f6a09eb53"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ad2a084dbd3fbcacde8a5034ef381b1ee41d09e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad2a084dbd3fbcacde8a5034ef381b1ee41d09e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad2a084dbd3fbcacde8a5034ef381b1ee41d09e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad2a084dbd3fbcacde8a5034ef381b1ee41d09e5/comments", "author": null, "committer": null, "parents": [{"sha": "3b67042af8f91e658c6467d3dad4464c89c069ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b67042af8f91e658c6467d3dad4464c89c069ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b67042af8f91e658c6467d3dad4464c89c069ab"}], "stats": {"total": 249, "additions": 166, "deletions": 83}, "files": [{"sha": "74109d74d97828ab029265d23cb63ade98828eee", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad2a084dbd3fbcacde8a5034ef381b1ee41d09e5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad2a084dbd3fbcacde8a5034ef381b1ee41d09e5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ad2a084dbd3fbcacde8a5034ef381b1ee41d09e5", "patch": "@@ -1,3 +1,21 @@\n+2000-12-17  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+        * c-lex.c: Move main_input_filename handling to FC_ENTER. Clean up.\n+        * cpperror.c (print_containing_files): Get right line number.\n+        (print_location): Output column of 1 if 0.\n+        * cppfiles.c (stack_include_file): cpp_push_buffer handles\n+        the callback.\n+        * cpphash.h (_cpp_do_file_change): No longer external.\n+        * cpplib.c (do_file_change): Now local to cpplib.c.\n+        (do_line): Fake a buffer stack for preprocessed files.\n+        (cpp_push_buffer): Create a file_change callback.  Handle faked\n+        buffers.\n+        (cpp_pop_buffer): Similarly.\n+        * cpplib.h: BUF_FAKE: New buffer type.\n+        * cppmain.c: Update to handle correct file renaming where a\n+        #line is the first line of the main file, and produce only\n+        the renamed file, not the original file, as output.\n+\n 2000-12-17  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n \n \t* config/c4x/c4x.md: Remove redundant @s from output patterns."}, {"sha": "13e0ef2468cafc08c1095564839fa0283cb3a60b", "filename": "gcc/c-lex.c", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad2a084dbd3fbcacde8a5034ef381b1ee41d09e5/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad2a084dbd3fbcacde8a5034ef381b1ee41d09e5/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=ad2a084dbd3fbcacde8a5034ef381b1ee41d09e5", "patch": "@@ -234,14 +234,10 @@ cb_change_file (pfile, fc)\n      cpp_reader *pfile ATTRIBUTE_UNUSED;\n      const cpp_file_change *fc;\n {\n-  if (fc->from.filename == 0)\n-    main_input_filename = fc->to.filename;\n-  in_system_header = fc->sysp;\n-\n   /* Do the actions implied by the preceding numbers.  */\n   if (fc->reason == FC_ENTER)\n     {\n-      /* FIXME.  Don't stack the main buffer on the input stack.  */\n+      /* Don't stack the main buffer on the input stack.  */\n       if (fc->from.filename)\n \t{\n \t  lineno = lex_lineno;\n@@ -258,6 +254,8 @@ cb_change_file (pfile, fc)\n \t    }\n #endif\n \t}\n+      else\n+\tmain_input_filename = fc->to.filename;\n     }\n   else if (fc->reason == FC_LEAVE)\n     {\n@@ -288,11 +286,9 @@ cb_change_file (pfile, fc)\n       else\n \terror (\"leaving more files than we entered\");\n     }\n-  else if (fc->reason == FC_RENAME)\n-    input_filename = fc->to.filename;\n \n   update_header_times (fc->to.filename);\n-\n+  in_system_header = fc->sysp;\n   input_filename = fc->to.filename;\n   lex_lineno = fc->to.lineno;\n "}, {"sha": "6a48a2a7c972eb203c57bafbe2ccc244f0342608", "filename": "gcc/cpperror.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad2a084dbd3fbcacde8a5034ef381b1ee41d09e5/gcc%2Fcpperror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad2a084dbd3fbcacde8a5034ef381b1ee41d09e5/gcc%2Fcpperror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpperror.c?ref=ad2a084dbd3fbcacde8a5034ef381b1ee41d09e5", "patch": "@@ -69,7 +69,7 @@ print_containing_files (ip)\n \t   The trailing comma is at the beginning of this message,\n \t   and the trailing colon is not translated.  */\n \tfprintf (stderr, _(\",\\n                 from %s:%u\"),\n-\t\t ip->nominal_fname, CPP_BUF_LINE (ip) - 1);\n+\t\t ip->nominal_fname, CPP_BUF_LINE (ip));\n     }\n   fputs (\":\\n\", stderr);\n }\n@@ -111,6 +111,9 @@ print_location (pfile, filename, pos)\n \t      col = pos->col;\n \t    }\n \n+\t  if (col == 0)\n+\t    col = 1;\n+\n \t  /* Don't repeat the include stack unnecessarily.  */\n \t  if (buffer->prev && ! buffer->include_stack_listed)\n \t    {"}, {"sha": "96ce7e48511dabf31463ad42f4e328c3471de078", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad2a084dbd3fbcacde8a5034ef381b1ee41d09e5/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad2a084dbd3fbcacde8a5034ef381b1ee41d09e5/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=ad2a084dbd3fbcacde8a5034ef381b1ee41d09e5", "patch": "@@ -245,16 +245,8 @@ stack_include_file (pfile, inc)\n      cpp_reader *pfile;\n      struct include_file *inc;\n {\n-  const char *filename = 0;\n-  unsigned int lineno = 0;\n   cpp_buffer *fp;\n \n-  if (pfile->buffer)\n-    {\n-      filename = pfile->buffer->nominal_fname;\n-      lineno = pfile->buffer->lineno;\n-    }\n-\n   /* Not in cache?  */\n   if (! inc->buffer)\n     read_include_file (pfile, inc);\n@@ -268,7 +260,6 @@ stack_include_file (pfile, inc)\n     fp->rlimit += inc->st.st_size;\n   fp->cur = fp->buf;\n   fp->line_base = fp->buf;\n-  fp->lineno = 0;\t\t/* For _cpp_do_file_change.  */\n   fp->inc->refcnt++;\n   if (inc->foundhere)\n     fp->sysp = inc->foundhere->sysp;\n@@ -282,10 +273,6 @@ stack_include_file (pfile, inc)\n   pfile->mi_state = MI_OUTSIDE;\n   pfile->mi_cmacro = 0;\n   pfile->include_depth++;\n-\n-  _cpp_do_file_change (pfile, FC_ENTER, filename, lineno);\n-\n-  fp->lineno = 1;\n }\n \n /* Read the file referenced by INC into the file cache."}, {"sha": "a528f9127cd32f7e32e32dae258ecc894d444104", "filename": "gcc/cpphash.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad2a084dbd3fbcacde8a5034ef381b1ee41d09e5/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad2a084dbd3fbcacde8a5034ef381b1ee41d09e5/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=ad2a084dbd3fbcacde8a5034ef381b1ee41d09e5", "patch": "@@ -229,8 +229,6 @@ extern void _cpp_do__Pragma\tPARAMS ((cpp_reader *));\n extern void _cpp_init_stacks\tPARAMS ((cpp_reader *));\n extern void _cpp_cleanup_stacks\tPARAMS ((cpp_reader *));\n extern void _cpp_init_internal_pragmas PARAMS ((cpp_reader *));\n-extern void _cpp_do_file_change PARAMS ((cpp_reader *, enum cpp_fc_reason,\n-\t\t\t\t\t const char *, unsigned int));\n \n /* Utility routines and macros.  */\n #define DSC(str) (const U_CHAR *)str, sizeof str - 1"}, {"sha": "a032f7be24d777aae98348ffe4ce0ebc697d0fa9", "filename": "gcc/cpplib.c", "status": "modified", "additions": 122, "deletions": 48, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad2a084dbd3fbcacde8a5034ef381b1ee41d09e5/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad2a084dbd3fbcacde8a5034ef381b1ee41d09e5/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=ad2a084dbd3fbcacde8a5034ef381b1ee41d09e5", "patch": "@@ -108,6 +108,8 @@ static cpp_hashnode *parse_assertion PARAMS ((cpp_reader *, struct answer **,\n static struct answer ** find_answer PARAMS ((cpp_hashnode *,\n \t\t\t\t\t     const struct answer *));\n static void handle_assertion\tPARAMS ((cpp_reader *, const char *, int));\n+static void do_file_change\tPARAMS ((cpp_reader *, enum cpp_fc_reason,\n+\t\t\t\t\t const char *, unsigned int));\n \n /* This is the table of directive handlers.  It is ordered by\n    frequency of occurrence; the numbers at the end are directive\n@@ -721,7 +723,6 @@ do_line (pfile)\n       fname[len] = '\\0';\n     \n       _cpp_simplify_pathname (fname);\n-      buffer->nominal_fname = fname;\n \n       if (! pfile->state.line_extension)\n \tcheck_eol (pfile);\n@@ -748,8 +749,36 @@ do_line (pfile)\n \t\tsysp = 2, read_flag (pfile, flag);\n \t    }\n \n+\t  if (reason == FC_ENTER)\n+\t    {\n+\t      cpp_push_buffer (pfile, 0, 0, BUF_FAKE, fname);\n+\t      buffer = pfile->buffer;\n+\t    }\n+\t  else if (reason == FC_LEAVE)\n+\t    {\n+\t      if (buffer->type != BUF_FAKE)\n+\t\tcpp_warning (pfile, \"file \\\"%s\\\" left but not entered\",\n+\t\t\t     buffer->nominal_fname);\n+\t      else\n+\t\t{\n+\t\t  cpp_pop_buffer (pfile);\n+\t\t  buffer = pfile->buffer;\n+\t\t  if (strcmp (buffer->nominal_fname, fname))\n+\t\t    cpp_warning (pfile, \"expected to return to file \\\"%s\\\"\",\n+\t\t\t\t buffer->nominal_fname);\n+\t\t  if (buffer->lineno + 1 != new_lineno)\n+\t\t    cpp_warning (pfile, \"expected to return to line number %u\",\n+\t\t\t\t buffer->lineno + 1);\n+\t\t  if (buffer->sysp != sysp)\n+\t\t    cpp_warning (pfile, \"header flags for \\\"%s\\\" have changed\",\n+\t\t\t\t buffer->nominal_fname);\n+\t\t}\n+\t    }\n+\n \t  cpp_make_system_header (pfile, sysp, sysp == 2);\n \t}\n+\n+      buffer->nominal_fname = fname;\n     }\n   else if (token.type != CPP_EOF)\n     {\n@@ -760,13 +789,19 @@ do_line (pfile)\n \n   /* Our line number is incremented after the directive is processed.  */\n   buffer->lineno = new_lineno - 1;\n-  _cpp_do_file_change (pfile, reason, filename, lineno);\n+\n+  if (reason == FC_RENAME)\n+    {\n+      /* Special case for file \"foo.i\" with \"# 1 foo.c\" on first line.  */\n+      if (! buffer->prev && pfile->directive_pos.line == 1)\n+\tfilename = 0;\n+      do_file_change (pfile, reason, filename, lineno);\n+    }\n }\n \n-/* Arrange the file_change callback.  The assumption is that the\n-   current buffer's lineno is one less than the next line.  */\n-void\n-_cpp_do_file_change (pfile, reason, from_file, from_lineno)\n+/* Arrange the file_change callback.  */\n+static void\n+do_file_change (pfile, reason, from_file, from_lineno)\n      cpp_reader *pfile;\n      enum cpp_fc_reason reason;\n      const char *from_file;\n@@ -1622,9 +1657,7 @@ cpp_define (pfile, str)\n   run_directive (pfile, T_DEFINE, BUF_CL_OPTION, buf, count);\n }\n \n-/* Slight variant of the above for use by initialize_builtins, which (a)\n-   knows how to set up the buffer itself, (b) needs a different \"filename\"\n-   tag.  */\n+/* Slight variant of the above for use by initialize_builtins.  */\n void\n _cpp_define_builtin (pfile, str)\n      cpp_reader *pfile;\n@@ -1698,67 +1731,108 @@ cpp_push_buffer (pfile, buffer, len, type, filename)\n {\n   cpp_buffer *new = xobnew (pfile->buffer_ob, cpp_buffer);\n \n-  /* Clears, amongst other things, if_stack and mi_cmacro.  */\n-  memset (new, 0, sizeof (cpp_buffer));\n-\n-  switch (type)\n+  if (type == BUF_FAKE)\n+    {\n+      /* A copy of the current buffer, just with a new name and type.  */\n+      memcpy (new, pfile->buffer, sizeof (cpp_buffer));\n+      new->type = BUF_FAKE;\n+    }\n+  else\n     {\n-    case BUF_FILE:\tnew->nominal_fname = filename; break;\n-    case BUF_BUILTIN:\tnew->nominal_fname = _(\"<builtin>\"); break;\n-    case BUF_CL_OPTION:\tnew->nominal_fname = _(\"<command line>\"); break;\n-    case BUF_PRAGMA:\tnew->nominal_fname = _(\"<_Pragma>\"); break;\n+      if (type == BUF_BUILTIN)\n+\tfilename = _(\"<builtin>\");\n+      else if (type == BUF_CL_OPTION)\n+\tfilename = _(\"<command line>\");\n+      else if (type == BUF_PRAGMA)\n+\tfilename = \"<_Pragma>\";\n+\n+      /* Clears, amongst other things, if_stack and mi_cmacro.  */\n+      memset (new, 0, sizeof (cpp_buffer));\n+\n+      new->line_base = new->buf = new->cur = buffer;\n+      new->rlimit = buffer + len;\n+\n+      /* No read ahead or extra char initially.  */\n+      new->read_ahead = EOF;\n+      new->extra_char = EOF;\n+\n+      /* Preprocessed files, builtins, _Pragma and command line\n+\t options don't do trigraph and escaped newline processing.  */\n+      new->from_stage3 = type != BUF_FILE || CPP_OPTION (pfile, preprocessed);\n+\n+      pfile->lexer_pos.output_line = 1;\n     }\n+\n+  new->nominal_fname = filename;\n   new->type = type;\n-  new->line_base = new->buf = new->cur = buffer;\n-  new->rlimit = buffer + len;\n   new->prev = pfile->buffer;\n   new->pfile = pfile;\n-\n-  /* No read ahead or extra char initially.  */\n-  new->read_ahead = EOF;\n-  new->extra_char = EOF;\n-\n-  /* Preprocessed files, builtins, _Pragma and command line options\n-     don't do trigraph and escaped newline processing.  */\n-  new->from_stage3 = type != BUF_FILE || CPP_OPTION (pfile, preprocessed);\n+  new->include_stack_listed = 0;\n \n   pfile->state.next_bol = 1;\n   pfile->buffer_stack_depth++;\n-  pfile->lexer_pos.output_line = 1;\n   pfile->buffer = new;\n \n+  if (type == BUF_FILE || type == BUF_FAKE)\n+    {\n+      const char *filename = 0;\n+      unsigned int lineno = 0;\n+\n+      if (new->prev)\n+\t{\n+\t  filename = new->prev->nominal_fname;\n+\t  lineno = new->prev->lineno;\n+\t}\n+      new->lineno = 0;\n+      do_file_change (pfile, FC_ENTER, filename, lineno);\n+    }\n+\n+  new->lineno = 1;\n   return new;\n }\n \n cpp_buffer *\n cpp_pop_buffer (pfile)\n      cpp_reader *pfile;\n {\n-  cpp_buffer *buffer = pfile->buffer;\n-  const char *filename = buffer->nominal_fname;\n-  unsigned int lineno = buffer->lineno;\n-  struct if_stack *ifs = buffer->if_stack;\n-  int file_buffer_p = buffer->type == BUF_FILE;\n+  cpp_buffer *buffer;\n+  struct if_stack *ifs;\n+  int in_do_line = pfile->directive == &dtable[T_LINE];\n \n-  /* Walk back up the conditional stack till we reach its level at\n-     entry to this file, issuing error messages.  */\n-  for (ifs = buffer->if_stack; ifs; ifs = ifs->next)\n-    cpp_error_with_line (pfile, ifs->pos.line, ifs->pos.col,\n-\t\t\t \"unterminated #%s\", dtable[ifs->type].name);\n+  do\n+    {\n+      buffer = pfile->buffer;\n+      /* Walk back up the conditional stack till we reach its level at\n+\t entry to this file, issuing error messages.  */\n+      for (ifs = buffer->if_stack; ifs; ifs = ifs->next)\n+\tcpp_error_with_line (pfile, ifs->pos.line, ifs->pos.col,\n+\t\t\t     \"unterminated #%s\", dtable[ifs->type].name);\n+\n+      if (buffer->type == BUF_FAKE)\n+\t{\n+\t  if (!in_do_line)\n+\t    cpp_warning (pfile, \"file \\\"%s\\\" entered but not left\",\n+\t\t\t buffer->nominal_fname);\n \n-  if (file_buffer_p)\n-    _cpp_pop_file_buffer (pfile, buffer);\n+\t  buffer->prev->cur = buffer->cur;\n+\t}\n+      else if (buffer->type == BUF_FILE)\n+\t_cpp_pop_file_buffer (pfile, buffer);\n \n-  pfile->buffer = buffer->prev;\n-  obstack_free (pfile->buffer_ob, buffer);\n-  pfile->buffer_stack_depth--;\n+      pfile->buffer = buffer->prev;\n+      pfile->buffer_stack_depth--;\n \n-  if (pfile->buffer && file_buffer_p)\n-    {\n-      _cpp_do_file_change (pfile, FC_LEAVE, filename, lineno);\n-      pfile->buffer->include_stack_listed = 0;\n+      if ((buffer->type == BUF_FILE || buffer->type == BUF_FAKE)\n+\t  && pfile->buffer)\n+\t{\n+\t  do_file_change (pfile, FC_LEAVE, buffer->nominal_fname,\n+\t\t\t  buffer->lineno);\n+\t  pfile->buffer->include_stack_listed = 0;\n+\t}\n     }\n-  \n+  while (pfile->buffer && pfile->buffer->type == BUF_FAKE && !in_do_line);\n+\n+  obstack_free (pfile->buffer_ob, buffer);\n   return pfile->buffer;\n }\n "}, {"sha": "4c4b7e3a3200f52188141d346a3f6eeadcf41334", "filename": "gcc/cpplib.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad2a084dbd3fbcacde8a5034ef381b1ee41d09e5/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad2a084dbd3fbcacde8a5034ef381b1ee41d09e5/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=ad2a084dbd3fbcacde8a5034ef381b1ee41d09e5", "patch": "@@ -633,9 +633,10 @@ struct cpp_reader\n /* Name under which this program was invoked.  */\n extern const char *progname;\n \n-/* Where does this buffer come from?  A file, a builtin macro, a\n-   command-line option, or a _Pragma operator.  */\n-enum cpp_buffer_type {BUF_FILE, BUF_BUILTIN, BUF_CL_OPTION, BUF_PRAGMA};\n+/* Where does this buffer come from?  A faked include, a source file,\n+   a builtin macro, a command-line option, or a _Pragma operator.  */\n+enum cpp_buffer_type {BUF_FAKE, BUF_FILE, BUF_BUILTIN,\n+\t\t      BUF_CL_OPTION, BUF_PRAGMA};\n \n /* The structure of a node in the hash table.  The hash table has\n    entries for all identifiers: either macros defined by #define"}, {"sha": "7e12d6befc79340fde924a1b0205b30a77c63e7f", "filename": "gcc/cppmain.c", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad2a084dbd3fbcacde8a5034ef381b1ee41d09e5/gcc%2Fcppmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad2a084dbd3fbcacde8a5034ef381b1ee41d09e5/gcc%2Fcppmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmain.c?ref=ad2a084dbd3fbcacde8a5034ef381b1ee41d09e5", "patch": "@@ -263,7 +263,10 @@ maybe_print_line (line)\n   if (print.no_line_dirs)\n     return;\n \n-  if (line >= print.lineno && line < print.lineno + 8)\n+  /* print.lineno is zero if this is the first token of the file.  We\n+     handle this specially, so that a first line of \"# 1 \"foo.c\" in\n+     file foo.i outputs just the foo.c line, and not a foo.i line.  */\n+  if (line >= print.lineno && line < print.lineno + 8 && print.lineno)\n     {\n       while (line > print.lineno)\n \t{\n@@ -358,7 +361,6 @@ cb_change_file (pfile, fc)\n   if (fc->reason == FC_ENTER && fc->from.filename)\n     maybe_print_line (fc->from.lineno);\n \n-  print.lineno = fc->to.lineno;\n   print.last_fname = fc->to.filename;\n   if (fc->externc)\n     print.syshdr_flags = \" 3 4\";\n@@ -367,14 +369,18 @@ cb_change_file (pfile, fc)\n   else\n     print.syshdr_flags = \"\";\n \n-  switch (fc->reason)\n+  if (print.lineno)\n     {\n-    case FC_ENTER : flags = fc->from.filename ? \" 1\": \"\"; break;\n-    case FC_LEAVE : flags = \" 2\"; break;\n-    case FC_RENAME: flags = \"\"; break;\n-    }\n+      print.lineno = fc->to.lineno;\n+      switch (fc->reason)\n+\t{\n+\tcase FC_ENTER : flags = \" 1\"; break;\n+\tcase FC_LEAVE : flags = \" 2\"; break;\n+\tcase FC_RENAME: flags = \"\"; break;\n+\t}\n \n-  print_line (flags);\n+      print_line (flags);\n+    }\n }\n \n static void"}]}