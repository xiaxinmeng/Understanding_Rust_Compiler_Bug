{"sha": "89b3c97eed75c1e7c492bc727e0016003c5809cc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODliM2M5N2VlZDc1YzFlN2M0OTJiYzcyN2UwMDE2MDAzYzU4MDljYw==", "commit": {"author": {"name": "Kewen Lin", "email": "linkw@linux.ibm.com", "date": "2021-07-28T03:04:22Z"}, "committer": {"name": "Kewen Lin", "email": "linkw@linux.ibm.com", "date": "2021-07-28T03:04:22Z"}, "message": "vect: Fix wrong check in vect_recog_mulhs_pattern [PR101596]\n\nAs PR101596 showed, vect_recog_mulhs_pattern uses target_precision to\ncheck the scale_term is expected or not, it could be wrong when the\nprecision of the actual used new_type larger than target_precision as\nshown by the example.\n\nThis patch is to use precision of new_type instead of target_precision\nfor the scale_term matching check.\n\nBootstrapped & regtested on powerpc64le-linux-gnu P10,\npowerpc64-linux-gnu P8, x86_64-redhat-linux and aarch64-linux-gnu.\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/101596\n\t* tree-vect-patterns.c (vect_recog_mulhs_pattern): Fix wrong check\n\tby using new_type's precision instead.\n\ngcc/testsuite/ChangeLog:\n\n\tPR tree-optimization/101596\n\t* gcc.target/powerpc/pr101596-1.c: New test.\n\t* gcc.target/powerpc/pr101596-2.c: Likewise.\n\t* gcc.target/powerpc/pr101596-3.c: Likewise.", "tree": {"sha": "36b6702f3296a3dd1bbaccabde196cd61d1955f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/36b6702f3296a3dd1bbaccabde196cd61d1955f6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89b3c97eed75c1e7c492bc727e0016003c5809cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89b3c97eed75c1e7c492bc727e0016003c5809cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89b3c97eed75c1e7c492bc727e0016003c5809cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89b3c97eed75c1e7c492bc727e0016003c5809cc/comments", "author": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "872da9a6f664a06d73c987aa0cb2e5b830158a10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/872da9a6f664a06d73c987aa0cb2e5b830158a10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/872da9a6f664a06d73c987aa0cb2e5b830158a10"}], "stats": {"total": 181, "additions": 154, "deletions": 27}, "files": [{"sha": "ed09e5f96edd9dd2c5f3ead3ff62b67c1f64b36c", "filename": "gcc/testsuite/gcc.target/powerpc/pr101596-1.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89b3c97eed75c1e7c492bc727e0016003c5809cc/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr101596-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89b3c97eed75c1e7c492bc727e0016003c5809cc/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr101596-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr101596-1.c?ref=89b3c97eed75c1e7c492bc727e0016003c5809cc", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-require-effective-target power10_ok } */\n+/* { dg-options \"-mdejagnu-cpu=power10 -O2 -ftree-vectorize -fno-vect-cost-model -fdump-tree-vect-details\" } */\n+\n+/* Check vect_recog_mulhs_pattern can't be detected with shift count 48.  */\n+\n+#define N 128\n+\n+typedef signed long long sLL;\n+typedef unsigned long long uLL;\n+\n+signed int si_a[N], si_b[N];\n+unsigned int ui_a[N], ui_b[N];\n+signed short sh_c[N];\n+unsigned short uh_c[N];\n+\n+void\n+test1 ()\n+{\n+  for (int i = 0; i < N; i++)\n+    sh_c[i] = ((sLL) si_a[i] * (sLL) si_b[i]) >> 48;\n+}\n+\n+void\n+test2 ()\n+{\n+  for (int i = 0; i < N; i++)\n+    uh_c[i] = ((uLL) ui_a[i] * (uLL) ui_b[i]) >> 48;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"vect_recog_mulhs_pattern: detected\" \"vect\" } } */"}, {"sha": "5caa7ce4189ac39f3f3e39136470a68b5d275b61", "filename": "gcc/testsuite/gcc.target/powerpc/pr101596-2.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89b3c97eed75c1e7c492bc727e0016003c5809cc/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr101596-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89b3c97eed75c1e7c492bc727e0016003c5809cc/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr101596-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr101596-2.c?ref=89b3c97eed75c1e7c492bc727e0016003c5809cc", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-require-effective-target power10_ok } */\n+/* { dg-options \"-mdejagnu-cpu=power10 -O2 -ftree-vectorize -fno-vect-cost-model -fdump-tree-vect-details\" } */\n+\n+/* Check vect_recog_mulhs_pattern can be detected with shift count 32.  */\n+\n+#define N 128\n+\n+typedef signed long long sLL;\n+typedef unsigned long long uLL;\n+\n+signed int si_a[N], si_b[N];\n+unsigned int ui_a[N], ui_b[N];\n+signed short sh_c[N];\n+unsigned short uh_c[N];\n+\n+void\n+test1 ()\n+{\n+  for (int i = 0; i < N; i++)\n+    sh_c[i] = ((sLL) si_a[i] * (sLL) si_b[i]) >> 32;\n+}\n+\n+void\n+test2 ()\n+{\n+  for (int i = 0; i < N; i++)\n+    uh_c[i] = ((uLL) ui_a[i] * (uLL) ui_b[i]) >> 32;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vect_recog_mulhs_pattern: detected\" 2 \"vect\" } } */"}, {"sha": "4b92661412daa41d70ed011f3dfa5d2c98d5d86a", "filename": "gcc/testsuite/gcc.target/powerpc/pr101596-3.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89b3c97eed75c1e7c492bc727e0016003c5809cc/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr101596-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89b3c97eed75c1e7c492bc727e0016003c5809cc/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr101596-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr101596-3.c?ref=89b3c97eed75c1e7c492bc727e0016003c5809cc", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target power10_hw } */\n+/* { dg-options \"-mdejagnu-cpu=power10 -O2 -ftree-vectorize -fno-vect-cost-model\" } */\n+\n+/* Verify the execution goes well with shift count either 32 or 48.  */\n+\n+#define N 128\n+\n+typedef signed int si;\n+typedef signed short sh;\n+typedef signed long long sll;\n+typedef unsigned int ui;\n+typedef unsigned short uh;\n+typedef unsigned long long ull;\n+\n+si si_a[N], si_b[N];\n+ui ui_a[N], ui_b[N];\n+sh sh_c[N];\n+uh uh_c[N];\n+\n+#define TEST(NTYPE, TYPE, WTYPE, CNT)                                          \\\n+  void __attribute__ ((noipa)) test_##TYPE##CNT ()                             \\\n+  {                                                                            \\\n+    for (int i = 0; i < N; i++)                                                \\\n+      NTYPE##_c[i] = ((WTYPE) TYPE##_a[i] * (WTYPE) TYPE##_b[i]) >> CNT;       \\\n+  }                                                                            \\\n+                                                                               \\\n+  void __attribute__ ((noipa, optimize (\"O1\"))) check_##TYPE##CNT ()           \\\n+  {                                                                            \\\n+    test_##TYPE##CNT ();                                                       \\\n+    for (int i = 0; i < N; i++)                                                \\\n+      {                                                                        \\\n+\tNTYPE exp = ((WTYPE) TYPE##_a[i] * (WTYPE) TYPE##_b[i]) >> CNT;        \\\n+\tif (NTYPE##_c[i] != exp)                                               \\\n+\t  __builtin_abort ();                                                  \\\n+      }                                                                        \\\n+  }\n+\n+TEST (sh, si, sll, 32)\n+TEST (sh, si, sll, 48)\n+TEST (uh, ui, ull, 32)\n+TEST (uh, ui, ull, 48)\n+\n+int\n+main ()\n+{\n+\n+  for (int i = 0; i < N; i++)\n+    {\n+      ui_a[i] = si_a[i] = 0x12345678ULL + 0x1000ULL * (i * 3 - 1);\n+      ui_b[i] = si_b[i] = 0x87654321ULL - 0x500000ULL * (i * 5 + 1);\n+    }\n+\n+  check_si32 ();\n+  check_si48 ();\n+  check_ui32 ();\n+  check_ui48 ();\n+}"}, {"sha": "743fd3f541427177681096ea4557c2046ddf3ccb", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 36, "deletions": 27, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89b3c97eed75c1e7c492bc727e0016003c5809cc/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89b3c97eed75c1e7c492bc727e0016003c5809cc/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=89b3c97eed75c1e7c492bc727e0016003c5809cc", "patch": "@@ -1986,7 +1986,7 @@ vect_recog_mulhs_pattern (vec_info *vinfo,\n \n   stmt_vec_info mulh_stmt_info;\n   tree scale_term;\n-  internal_fn ifn;\n+  bool rounding_p = false;\n \n   /* Check for the presence of the rounding term.  */\n   if (gimple_assign_rhs_code (rshift_input_stmt) == PLUS_EXPR)\n@@ -2035,37 +2035,18 @@ vect_recog_mulhs_pattern (vec_info *vinfo,\n \n       /* Get the scaling term.  */\n       scale_term = gimple_assign_rhs2 (plus_input_stmt);\n-      /* Check that the scaling factor is correct.  */\n-      if (TREE_CODE (scale_term) != INTEGER_CST)\n-\treturn NULL;\n-\n-      /* Check pattern 2).  */\n-      if (wi::to_widest (scale_term) + target_precision + 2\n-\t  != TYPE_PRECISION (lhs_type))\n-\treturn NULL;\n-\n-      ifn = IFN_MULHRS;\n+      rounding_p = true;\n     }\n   else\n     {\n       mulh_stmt_info = rshift_input_stmt_info;\n       scale_term = gimple_assign_rhs2 (last_stmt);\n-      /* Check that the scaling factor is correct.  */\n-      if (TREE_CODE (scale_term) != INTEGER_CST)\n-\treturn NULL;\n-\n-      /* Check for pattern 1).  */\n-      if (wi::to_widest (scale_term) + target_precision + 1\n-\t  == TYPE_PRECISION (lhs_type))\n-\tifn = IFN_MULHS;\n-      /* Check for pattern 3).  */\n-      else if (wi::to_widest (scale_term) + target_precision\n-\t       == TYPE_PRECISION (lhs_type))\n-\tifn = IFN_MULH;\n-      else\n-\treturn NULL;\n     }\n \n+  /* Check that the scaling factor is constant.  */\n+  if (TREE_CODE (scale_term) != INTEGER_CST)\n+    return NULL;\n+\n   /* Check whether the scaling input term can be seen as two widened\n      inputs multiplied together.  */\n   vect_unpromoted_value unprom_mult[2];\n@@ -2076,13 +2057,41 @@ vect_recog_mulhs_pattern (vec_info *vinfo,\n   if (nops != 2)\n     return NULL;\n \n-  vect_pattern_detected (\"vect_recog_mulhs_pattern\", last_stmt);\n-\n   /* Adjust output precision.  */\n   if (TYPE_PRECISION (new_type) < target_precision)\n     new_type = build_nonstandard_integer_type\n       (target_precision, TYPE_UNSIGNED (new_type));\n \n+  unsigned mult_precision = TYPE_PRECISION (new_type);\n+  internal_fn ifn;\n+  /* Check that the scaling factor is expected.  Instead of\n+     target_precision, we should use the one that we actually\n+     use for internal function.  */\n+  if (rounding_p)\n+    {\n+      /* Check pattern 2).  */\n+      if (wi::to_widest (scale_term) + mult_precision + 2\n+\t  != TYPE_PRECISION (lhs_type))\n+\treturn NULL;\n+\n+      ifn = IFN_MULHRS;\n+    }\n+  else\n+    {\n+      /* Check for pattern 1).  */\n+      if (wi::to_widest (scale_term) + mult_precision + 1\n+\t  == TYPE_PRECISION (lhs_type))\n+\tifn = IFN_MULHS;\n+      /* Check for pattern 3).  */\n+      else if (wi::to_widest (scale_term) + mult_precision\n+\t       == TYPE_PRECISION (lhs_type))\n+\tifn = IFN_MULH;\n+      else\n+\treturn NULL;\n+    }\n+\n+  vect_pattern_detected (\"vect_recog_mulhs_pattern\", last_stmt);\n+\n   /* Check for target support.  */\n   tree new_vectype = get_vectype_for_scalar_type (vinfo, new_type);\n   if (!new_vectype"}]}