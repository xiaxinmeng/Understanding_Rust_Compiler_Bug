{"sha": "338d6484d186c86d64d6c551fdeeb5ae9df5a316", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzM4ZDY0ODRkMTg2Yzg2ZDY0ZDZjNTUxZmRlZWI1YWU5ZGY1YTMxNg==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2017-07-13T19:30:42Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2017-07-13T19:30:42Z"}, "message": "diagnostics: fix crash when consolidating out-of-order fix-it hints (PR c/81405)\n\nPR c/81405 identifies a crash when printing fix-it hints from\n-Wmissing-braces when there are excess elements.\n\nThe fix-it hints are bogus (which I've filed separately as PR c/81432),\nbut they lead to a crash within the fix-it consolidation logic I added\nin r247548, in line_corrections::add_hint.\n\nThe root cause is that some of the fix-it hints are out-of-order\nwith respect to the column numbers they affect, which can lead to negative\nvalues when computing the gap between the fix-it hints, leading to bogus\nmemcpy calls that generate out-of-bounds buffer accesses.\n\nThe fix is to sort the fix-it hints after filtering them, ensuring that\nthe gap >= 0.  The patch also adds numerous assertions to the code, both\ndirectly, and by moving the memcpy calls and their args behind\ninterfaces (themselves containing gcc_assert).\n\nThis fixes the crash; it doesn't fix the bug in -Wmissing-braces that\nleads to the bogus hints.\n\ngcc/ChangeLog:\n\tPR c/81405\n\t* diagnostic-show-locus.c (fixit_cmp): New function.\n\t(layout::layout): Sort m_fixit_hints.\n\t(column_range::column_range): Assert that the values are valid.\n\t(struct char_span): New struct.\n\t(correction::overwrite): New method.\n\t(struct source_line): New struct.\n\t(line_corrections::add_hint): Add assertions.  Reimplement memcpy\n\tcalls in terms of classes source_line and char_span, and\n\tcorrection::overwrite.\n\t(selftest::test_overlapped_fixit_printing_2): New function.\n\t(selftest::diagnostic_show_locus_c_tests): Call it.\n\ngcc/testsuite/ChangeLog:\n\tPR c/81405\n\t* gcc.dg/Wmissing-braces-fixits.c: Add coverage for PR c/81405.  */\n\nFrom-SVN: r250187", "tree": {"sha": "96c0f0573a7aa2751ad412eec2875d1bf5ba43bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/96c0f0573a7aa2751ad412eec2875d1bf5ba43bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/338d6484d186c86d64d6c551fdeeb5ae9df5a316", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/338d6484d186c86d64d6c551fdeeb5ae9df5a316", "html_url": "https://github.com/Rust-GCC/gccrs/commit/338d6484d186c86d64d6c551fdeeb5ae9df5a316", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/338d6484d186c86d64d6c551fdeeb5ae9df5a316/comments", "author": null, "committer": null, "parents": [{"sha": "1260d19905063540e560bda4924f09f1aff4bed5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1260d19905063540e560bda4924f09f1aff4bed5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1260d19905063540e560bda4924f09f1aff4bed5"}], "stats": {"total": 242, "additions": 227, "deletions": 15}, "files": [{"sha": "fd5b7bb951296b72af80ff8fc3cee9d228777a35", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/338d6484d186c86d64d6c551fdeeb5ae9df5a316/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/338d6484d186c86d64d6c551fdeeb5ae9df5a316/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=338d6484d186c86d64d6c551fdeeb5ae9df5a316", "patch": "@@ -1,4 +1,19 @@\n-\t2017-07-13  Will Schmidt  <will_schmidt@vnet.ibm.com>\n+2017-07-13  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR c/81405\n+\t* diagnostic-show-locus.c (fixit_cmp): New function.\n+\t(layout::layout): Sort m_fixit_hints.\n+\t(column_range::column_range): Assert that the values are valid.\n+\t(struct char_span): New struct.\n+\t(correction::overwrite): New method.\n+\t(struct source_line): New struct.\n+\t(line_corrections::add_hint): Add assertions.  Reimplement memcpy\n+\tcalls in terms of classes source_line and char_span, and\n+\tcorrection::overwrite.\n+\t(selftest::test_overlapped_fixit_printing_2): New function.\n+\t(selftest::diagnostic_show_locus_c_tests): Call it.\n+\n+2017-07-13  Will Schmidt  <will_schmidt@vnet.ibm.com>\n \n \t* config/rs6000/rs6000.c (rs6000_gimple_fold_builtin): Return\n \tearly if there is no lhs."}, {"sha": "b0e72e735bf3179508cce362931587887e81af88", "filename": "gcc/diagnostic-show-locus.c", "status": "modified", "additions": 180, "deletions": 13, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/338d6484d186c86d64d6c551fdeeb5ae9df5a316/gcc%2Fdiagnostic-show-locus.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/338d6484d186c86d64d6c551fdeeb5ae9df5a316/gcc%2Fdiagnostic-show-locus.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic-show-locus.c?ref=338d6484d186c86d64d6c551fdeeb5ae9df5a316", "patch": "@@ -756,6 +756,16 @@ compatible_locations_p (location_t loc_a, location_t loc_b)\n     }\n }\n \n+/* Comparator for sorting fix-it hints.  */\n+\n+static int\n+fixit_cmp (const void *p_a, const void *p_b)\n+{\n+  const fixit_hint * hint_a = *static_cast<const fixit_hint * const *> (p_a);\n+  const fixit_hint * hint_b = *static_cast<const fixit_hint * const *> (p_b);\n+  return hint_a->get_start_loc () - hint_b->get_start_loc ();\n+}\n+\n /* Implementation of class layout.  */\n \n /* Constructor for class layout.\n@@ -799,6 +809,9 @@ layout::layout (diagnostic_context * context,\n \tm_fixit_hints.safe_push (hint);\n     }\n \n+  /* Sort m_fixit_hints.  */\n+  m_fixit_hints.qsort (fixit_cmp);\n+\n   /* Populate m_line_spans.  */\n   calculate_line_spans ();\n \n@@ -1385,7 +1398,11 @@ layout::annotation_line_showed_range_p (int line, int start_column,\n \n struct column_range\n {\n-  column_range (int start_, int finish_) : start (start_), finish (finish_) {}\n+  column_range (int start_, int finish_) : start (start_), finish (finish_)\n+  {\n+    /* We must have either a range, or an insertion.  */\n+    gcc_assert (start <= finish || finish == start - 1);\n+  }\n \n   bool operator== (const column_range &other) const\n   {\n@@ -1427,6 +1444,26 @@ get_printed_columns (const fixit_hint *hint)\n     }\n }\n \n+/* A struct capturing the bounds of a buffer, to allow for run-time\n+   bounds-checking in a checked build.  */\n+\n+struct char_span\n+{\n+  char_span (const char *ptr, size_t n_elts) : m_ptr (ptr), m_n_elts (n_elts) {}\n+\n+  char_span subspan (int offset, int n_elts)\n+  {\n+    gcc_assert (offset >= 0);\n+    gcc_assert (offset < (int)m_n_elts);\n+    gcc_assert (n_elts >= 0);\n+    gcc_assert (offset + n_elts <= (int)m_n_elts);\n+    return char_span (m_ptr + offset, n_elts);\n+  }\n+\n+  const char *m_ptr;\n+  size_t m_n_elts;\n+};\n+\n /* A correction on a particular line.\n    This describes a plan for how to print one or more fixit_hint\n    instances that affected the line, potentially consolidating hints\n@@ -1455,6 +1492,14 @@ struct correction\n   void ensure_capacity (size_t len);\n   void ensure_terminated ();\n \n+  void overwrite (int dst_offset, const char_span &src_span)\n+  {\n+    gcc_assert (dst_offset >= 0);\n+    gcc_assert (dst_offset + src_span.m_n_elts < m_alloc_sz);\n+    memcpy (m_text + dst_offset, src_span.m_ptr,\n+\t    src_span.m_n_elts);\n+  }\n+\n   /* If insert, then start: the column before which the text\n      is to be inserted, and finish is offset by the length of\n      the replacement.\n@@ -1526,6 +1571,26 @@ line_corrections::~line_corrections ()\n     delete c;\n }\n \n+/* A struct wrapping a particular source line, allowing\n+   run-time bounds-checking of accesses in a checked build.  */\n+\n+struct source_line\n+{\n+  source_line (const char *filename, int line);\n+\n+  char_span as_span () { return char_span (chars, width); }\n+\n+  const char *chars;\n+  int width;\n+};\n+\n+/* source_line's ctor.  */\n+\n+source_line::source_line (const char *filename, int line)\n+{\n+  chars = location_get_source_line (filename, line, &width);\n+}\n+\n /* Add HINT to the corrections for this line.\n    Attempt to consolidate nearby hints so that they will not\n    overlap with printed.  */\n@@ -1541,6 +1606,14 @@ line_corrections::add_hint (const fixit_hint *hint)\n     {\n       correction *last_correction\n \t= m_corrections[m_corrections.length () - 1];\n+\n+      /* The following consolidation code assumes that the fix-it hints\n+\t have been sorted by start (done within layout's ctor).  */\n+      gcc_assert (affected_columns.start\n+\t\t  >= last_correction->m_affected_columns.start);\n+      gcc_assert (printed_columns.start\n+\t\t  >= last_correction->m_printed_columns.start);\n+\n       if (printed_columns.start <= last_correction->m_printed_columns.finish)\n \t{\n \t  /* We have two hints for which the printed forms of the hints\n@@ -1553,23 +1626,26 @@ line_corrections::add_hint (const fixit_hint *hint)\n \t\t\t\tprinted_columns.start - 1);\n \n \t  /* Try to read the source.  */\n-\t  int line_width;\n-\t  const char *line = location_get_source_line (m_filename, m_row,\n-\t\t\t\t\t\t       &line_width);\n-\t  if (line && between.finish < line_width)\n+\t  source_line line (m_filename, m_row);\n+\t  if (line.chars && between.finish < line.width)\n \t    {\n \t      /* Consolidate into the last correction:\n \t\t add a no-op \"replace\" of the \"between\" text, and\n \t\t add the text from the new hint.  */\n-\t      size_t old_len = last_correction->m_len;\n-\t      size_t between_len = between.finish + 1 - between.start;\n-\t      size_t new_len = old_len + between_len + hint->get_length ();\n+\t      int old_len = last_correction->m_len;\n+\t      gcc_assert (old_len >= 0);\n+\t      int between_len = between.finish + 1 - between.start;\n+\t      gcc_assert (between_len >= 0);\n+\t      int new_len = old_len + between_len + hint->get_length ();\n+\t      gcc_assert (new_len >= 0);\n \t      last_correction->ensure_capacity (new_len);\n-\t      memcpy (last_correction->m_text + old_len,\n-\t\t      line + between.start - 1,\n-\t\t      between.finish + 1 - between.start);\n-\t      memcpy (last_correction->m_text + old_len + between_len,\n-\t\t      hint->get_string (), hint->get_length ());\n+\t      last_correction->overwrite\n+\t\t(old_len,\n+\t\t line.as_span ().subspan (between.start - 1,\n+\t\t\t\t\t  between.finish + 1 - between.start));\n+\t      last_correction->overwrite (old_len + between_len,\n+\t\t\t\t\t  char_span (hint->get_string (),\n+\t\t\t\t\t\t     hint->get_length ()));\n \t      last_correction->m_len = new_len;\n \t      last_correction->ensure_terminated ();\n \t      last_correction->m_affected_columns.finish\n@@ -2791,6 +2867,96 @@ test_overlapped_fixit_printing (const line_table_case &case_)\n   }\n }\n \n+/* Verify that the line_corrections machinery correctly prints\n+   overlapping fixit-hints that have been added in the wrong\n+   order.\n+   Adapted from PR c/81405 seen on gcc.dg/init-excess-1.c*/\n+\n+static void\n+test_overlapped_fixit_printing_2 (const line_table_case &case_)\n+{\n+  /* Create a tempfile and write some text to it.\n+     ...000000000111111111122222222223333333333.\n+     ...123456789012345678901234567890123456789.  */\n+  const char *content\n+    = (\"int a5[][0][0] = { 1, 2 };\\n\");\n+  temp_source_file tmp (SELFTEST_LOCATION, \".c\", content);\n+  line_table_test ltt (case_);\n+\n+  const line_map_ordinary *ord_map\n+    = linemap_check_ordinary (linemap_add (line_table, LC_ENTER, false,\n+\t\t\t\t\t   tmp.get_filename (), 0));\n+\n+  linemap_line_start (line_table, 1, 100);\n+\n+  const location_t final_line_end\n+    = linemap_position_for_line_and_column (line_table, ord_map, 1, 100);\n+\n+  /* Don't attempt to run the tests if column data might be unavailable.  */\n+  if (final_line_end > LINE_MAP_MAX_LOCATION_WITH_COLS)\n+    return;\n+\n+  const location_t col_1\n+    = linemap_position_for_line_and_column (line_table, ord_map, 1, 1);\n+  const location_t col_20\n+    = linemap_position_for_line_and_column (line_table, ord_map, 1, 20);\n+  const location_t col_21\n+    = linemap_position_for_line_and_column (line_table, ord_map, 1, 21);\n+  const location_t col_23\n+    = linemap_position_for_line_and_column (line_table, ord_map, 1, 23);\n+  const location_t col_25\n+    = linemap_position_for_line_and_column (line_table, ord_map, 1, 25);\n+\n+  /* Two insertions, in the wrong order.  */\n+  {\n+    rich_location richloc (line_table, col_20);\n+    richloc.add_fixit_insert_before (col_23, \"{\");\n+    richloc.add_fixit_insert_before (col_21, \"}\");\n+\n+    /* These fixits should be accepted; they can't be consolidated.  */\n+    ASSERT_EQ (2, richloc.get_num_fixit_hints ());\n+    const fixit_hint *hint_0 = richloc.get_fixit_hint (0);\n+    ASSERT_EQ (column_range (23, 22), get_affected_columns (hint_0));\n+    ASSERT_EQ (column_range (23, 23), get_printed_columns (hint_0));\n+    const fixit_hint *hint_1 = richloc.get_fixit_hint (1);\n+    ASSERT_EQ (column_range (21, 20), get_affected_columns (hint_1));\n+    ASSERT_EQ (column_range (21, 21), get_printed_columns (hint_1));\n+\n+    /* Verify that they're printed correctly.  */\n+    test_diagnostic_context dc;\n+    diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n+    ASSERT_STREQ (\"\\n\"\n+\t\t  \" int a5[][0][0] = { 1, 2 };\\n\"\n+\t\t  \"                    ^\\n\"\n+\t\t  \"                     } {\\n\",\n+\t\t  pp_formatted_text (dc.printer));\n+  }\n+\n+  /* Various overlapping insertions, some occurring \"out of order\"\n+     (reproducing the fix-it hints from PR c/81405).  */\n+  {\n+    test_diagnostic_context dc;\n+    rich_location richloc (line_table, col_20);\n+\n+    richloc.add_fixit_insert_before (col_20, \"{{\");\n+    richloc.add_fixit_insert_before (col_21, \"}}\");\n+    richloc.add_fixit_insert_before (col_23, \"{\");\n+    richloc.add_fixit_insert_before (col_21, \"}\");\n+    richloc.add_fixit_insert_before (col_23, \"{{\");\n+    richloc.add_fixit_insert_before (col_25, \"}\");\n+    richloc.add_fixit_insert_before (col_21, \"}\");\n+    richloc.add_fixit_insert_before (col_1, \"{\");\n+    richloc.add_fixit_insert_before (col_25, \"}\");\n+    diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n+    ASSERT_STREQ (\"\\n\"\n+\t\t  \" int a5[][0][0] = { 1, 2 };\\n\"\n+\t\t  \"                    ^\\n\"\n+\t\t  \" {                  -----\\n\"\n+\t\t  \"                    {{1}}}}, {{{2 }}\\n\",\n+\t\t  pp_formatted_text (dc.printer));\n+  }\n+}\n+\n /* Insertion fix-it hint: adding a \"break;\" on a line by itself.  */\n \n static void\n@@ -3001,6 +3167,7 @@ diagnostic_show_locus_c_tests ()\n   for_each_line_table_case (test_diagnostic_show_locus_fixit_lines);\n   for_each_line_table_case (test_fixit_consolidation);\n   for_each_line_table_case (test_overlapped_fixit_printing);\n+  for_each_line_table_case (test_overlapped_fixit_printing_2);\n   for_each_line_table_case (test_fixit_insert_containing_newline);\n   for_each_line_table_case (test_fixit_insert_containing_newline_2);\n   for_each_line_table_case (test_fixit_replace_containing_newline);"}, {"sha": "41dca744045e015bd16e78ceb675c672dc4f11b8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/338d6484d186c86d64d6c551fdeeb5ae9df5a316/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/338d6484d186c86d64d6c551fdeeb5ae9df5a316/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=338d6484d186c86d64d6c551fdeeb5ae9df5a316", "patch": "@@ -1,4 +1,9 @@\n-\t2017-07-13  Will Schmidt  <will_schmidt@vnet.ibm.com>\n+2017-07-13  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR c/81405\n+\t* gcc.dg/Wmissing-braces-fixits.c: Add coverage for PR c/81405.  */\n+\n+2017-07-13  Will Schmidt  <will_schmidt@vnet.ibm.com>\n \n \t* gcc.target/powerpc/fold-vec-missing-lhs.c: New.\n "}, {"sha": "2cce217369c45ed3adc130c7f034e6b91de94151", "filename": "gcc/testsuite/gcc.dg/Wmissing-braces-fixits.c", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/338d6484d186c86d64d6c551fdeeb5ae9df5a316/gcc%2Ftestsuite%2Fgcc.dg%2FWmissing-braces-fixits.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/338d6484d186c86d64d6c551fdeeb5ae9df5a316/gcc%2Ftestsuite%2Fgcc.dg%2FWmissing-braces-fixits.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWmissing-braces-fixits.c?ref=338d6484d186c86d64d6c551fdeeb5ae9df5a316", "patch": "@@ -162,3 +162,28 @@ struct sa3 arr_4_sa3[4] = \\\n      6, 7, 8, 9, 10, 11};\n      {{     }}{{       }}\n      { dg-end-multiline-output \"\" } */\n+\n+/* PR c/81405.  */\n+int a5[][0][0] = { 1, 2 }; /* { dg-line pr_81405 } */\n+\n+  /* { dg-warning \"missing braces around initializer\" \"\" { target c } pr_81405 } */\n+  /* { dg-begin-multiline-output \"\" }\n+ int a5[][0][0] = { 1, 2 };\n+                  ^\n+ {                  -----\n+                    {{1}}}}, {{{2 }}\n+     { dg-end-multiline-output \"\" } */\n+\n+  /* { dg-warning \"excess elements\" \"\" { target c } pr_81405 } */\n+  /* { dg-begin-multiline-output \"\" }\n+ int a5[][0][0] = { 1, 2 };\n+                    ^\n+     { dg-end-multiline-output \"\" } */\n+  /* { dg-begin-multiline-output \"\" }\n+ int a5[][0][0] = { 1, 2 };\n+                       ^\n+     { dg-end-multiline-output \"\" } */\n+  /* { dg-begin-multiline-output \"\" }\n+ int a5[][0][0] = { 1, 2 };\n+ ^~~\n+     { dg-end-multiline-output \"\" } */"}]}