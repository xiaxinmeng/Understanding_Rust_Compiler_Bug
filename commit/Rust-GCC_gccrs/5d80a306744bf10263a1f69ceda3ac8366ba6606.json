{"sha": "5d80a306744bf10263a1f69ceda3ac8366ba6606", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQ4MGEzMDY3NDRiZjEwMjYzYTFmNjljZWRhM2FjODM2NmJhNjYwNg==", "commit": {"author": {"name": "Douglas Gregor", "email": "doug.gregor@gmail.com", "date": "2007-03-10T01:58:58Z"}, "committer": {"name": "Doug Gregor", "email": "dgregor@gcc.gnu.org", "date": "2007-03-10T01:58:58Z"}, "message": "re PR c++/20599 (variadic template support)\n\n2007-03-09  Douglas Gregor  <doug.gregor@gmail.com>\n\n\tPR c++/20599\n\t* typeck.c (check_return_expr): Check for bare parameter packs.\n\t(comptypes): Compare template parameter packs and\n\ttype pack expansions.\n\t* decl.c (grokdeclarator): Deal with the declaration of function\n\tparameter packs.\n\t(grokparms): Verify that the (optional) function parameter pack is\n\tat the end of the parameter list.\n\t(xref_basetypes): Handle pack expansions in the base class.\n\t(cp_tree_node_structure): Handle ARGUMENT_PACK_SELECT.\n\t* cp-tree.def (TYPE_ARGUMENT_PACK): New.\n\t(NONTYPE_ARGUMENT_PACK): New.\n\t(TYPE_PACK_EXPANSION): New.\n\t(EXPR_PACK_EXPANSION): New.\n\t(ARGUMENT_PACK_SELECT): New.\n\t* cp-objcp-common.c (cp_tree_size): Compute size of\n\t(NON)TYPE_ARGUMENT_PACK, (TYPE|EXPR)_PACK_EXPANSION, and\n\tARGUMENT_PACK_SELECT.\n\t* error.c (dump_template_argument): Print template argument packs.\n\t(dump_template_argument_list): Ditto.\n\t(dump_template_parameter): Dump `...' for template type parameter\n\tpacks.\n\t(dump_type): Dump TYPE_PACK_EXPANSION nodes.\n\t(dump_parameters): Print function parameter packs.\n\t(dump_template_parms): Print template argument packs.\n\t(dump_expr): Dump EXPR_PACK_EXPANSION nodes.\n\t(maybe_warn_variadic_templates): New.\n\t* operators.def: Add ellipsis operator for EXPR_PACK_EXPANSION.\n\t* tree.c (cp_walk_subtrees): Walk BASELINK, TYPE_ARGUMENT_PACK,\n\tNONTYPE_ARGUMENT_PACK, TYPE_PACK_EXPANSION, EXPR_PACK_EXPANSION,\n\tCAST_EXPR. \n\t* mangle.c (write_type): Mangle TYPE_PACK_EXPANSION.\n\t(write_template_arg): Write argument packs as separate arguments.\n\t* cp-tree.h (struct template_parm_index_s): Add flag that\n\tindicates that the template parameter is actually a parameter\n\tpack.\n\t(struct tree_argument_pack_select): New.\n\t(enum cp_tree_node_structure_enum): Add TS_CP_ARGUMENT_PACK_SELECT.\n\t(union lang_tree_node): Add argument_pack_select.\n\t(FUNCTION_PARAMETER_PACK_P): New.\n\t(PACK_EXPANSION_P): New.\n\t(PACK_EXPANSION_PATTERN): New.\n\t(SET_PACK_EXPANSION_PATTERN): New.\n\t(PACK_EXPANSION_PARAMETER_PACKS): New.\n\t(ARGUMENT_PACK_P): New.\n\t(ARGUMENT_PACK_ARGS): New.\n\t(SET_ARGUMENT_PACK_ARGS): New.\n\t(ARGUMENT_PACK_INCOMPLETE_P): New.\n\t(ARGUMENT_PACK_EXPLICIT_ARGS): New.\n\t(TEMPLATE_PARM_PARAMETER_PACK): New.\n\t(TEMPLATE_TYPE_PARAMETER_PACK): New.\n\t(ARGUMENT_PACK_SELECT_FROM_PACK): New.\n\t(ARGUMENT_PACK_SELECT_INDEX): New.\n\t(ARGUMENT_PACK_SELECT_ARG): New.\n\t(struct cp_declarator): Add parameter_pack_p flag.\n\t(maybe_warn_variadic_templates): Declare.\n\t(process_template_parm): Add bool parameter IS_PARAMETER_PACK, to\n\tindicate a template parameter pack. \n\t(uses_parameter_packs): Declare.\n\t(template_parameter_pack_p): Declare.\n\t(template_parms_variadic_p): Declare.\n\t(make_pack_expansion): Declare.\n\t(check_for_bare_parameter_packs): Declare.\n\t* cxx-pretty-print.c (pp_cxx_unary_expression): Print\n\tsizeof... expressions. \n\t(pp_cxx_expression): Print pack expansions and non-type argument\n\tpacks.\n\t(pp_cxx_exception_specification): Print pack expansions. \n\t(pp_cxx_direct_declarator): Print ellipsis for parameter packs.\n\t(pp_cxx_ctor_initializer): Print pack expansions.\n\t(pp_cxx_type_id): Print pack expansions.\n\t(pp_cxx_template_argument_list): Print argument packs.\n\t(pp_cxx_template_parameter): Print ellipsis for template parameter\n\tpacks.\n\t* pt.c (comp_template_parms): Compare template parameter packs.\n\t(template_parameter_pack_p): New.\n\t(template_parms_variadic_p): New.\n\t(template_args_variadic_p): New.\n\t(make_ith_pack_parameter_name): New.\n\t(struct find_parameter_pack_data): New.\n\t(find_parameter_packs_r): New.\n\t(uses_parameter_packs): New.\n\t(make_pack_expansion): New.\n\t(check_for_bare_parameter_packs): New.\n\t(expand_template_argument_pack): New.\n\t(reduce_template_parm_level): Propagate parameter pack flag.\n\t(process_template_parm): Add is_parameter_pack parameter to state\n\twhen the parameter is actually a parameter pack. Create template\n\tparameter packs when is_parameter_pack is true.\n\t(current_template_args): The argument for a template parameter\n\tpack is an argument pack containing a single pack expansion.\n\t(process_partial_specialization): When checking that non-type\n\targument expressions do not involve template parameters, loop over\n\tthe arguments in argument packs separately.\n\t(push_template_decl_real): Check that the type of the declaration\n\tdoes not have any bare parameter packs. Check that primary\n\ttemplates have no more than one parameter pack, and that it comes\n\tat the end of the template parameter list.\n\t(convert_template_argument): Handle coercions for pack expansion\n\texpressions by coercing the pattern then rebuilding the expansion.\n\t(coerce_template_parms): When coercing the arguments for a\n\tvariadic template, pack \"extra\" arguments into an argument pack.\n\t(coerce_template_template_parms): Cannot coerce between parameter\n\tpacks and non-pack parameters.\n\t(template_args_equal): Compare PACK_EXPANSION_P expressions.\n\t(comp_template_args): Expand all template arguments packs before\n\tcomparing template argument lists.\n\t(mangle_class_name_for_template): Make argument packs as separate\n\ttemplate arguments.\n\t(for_each_template_parm_r): No need to handle BASELINK. \n\t(instantiate_class_template): Handle pack expansions in the base\n\tclass list.\n\t(tsubst_pack_expansion): New.\n\t(tsubst_template_args): Handle substitutions of argument packs and\n\tpack expansion into template argument lists.\n\t(tsubst_decl): Expand function parameter packs into separate\n\tfunction parameters.\n\t(tsubst_arg_types): Expand a type pack expansion into separate\n\targument types.\n\t(tsubst_exception_specification): Handle pack expansions in\n\texception specifiers.\n\t(tsubst): See through ARGUMENT_PACK_SELECT arguments when \n\treplacing a template parameter with its argument. If we encounter\n\ta substitution for an argument pack, just return the parameter\n\titself. \n\t(tsubst_copy): sizeof(X...) returns the number of elements in\n\tparameter pack X.  See through ARGUMENT_PACK_SELECT when the\n\tPARM_DECL is a parameter pack.\n\t(tsubst_expr): Expression pack expansions and argument packs\n\tcannot show up here; they will all be handled through function\n\tcalls, sizeof, and template argument lists.\n\t(tsubst_copy_and_build): sizeof(X...) returns the number of\n\telements in parameter pack X.  Handle pack expansions in TREE_LIST\n\tand CONSTRUCTOR nodes.\n\t(fn_type_unification): Handle \"incomplete\" explicit template\n\targument lists that specify some of the arguments for a template\n\tparameter pack.\n\t(type_unification_real): Unify arguments against pack expansions.\n\t(template_parm_level_and_index): New, helper function.\n\t(unify_pack_expansion): New.\n\t(unify): Unify argument packs on an argument-by-argument basis,\n\thandling variadic argument packs as well.\n\t(more_specialized_fn): Handle unification of function parameter\n\tpacks. All things being equal, prefer non-variadic function\n\ttemplates to variadic function templates.\n\t(more_specialized_class): Prefer the variadic class template\n\tpartial specialization that binds fewer arguments to a parameter\n\tpack.\n\t(regenerate_decl_from_template): Expand function parameter packs\n\tinto separate parameters.\n\t(instantiate_decl): Ditto.\n\t(tsubst_initializer_list): Handle pack expansions for base-class\n\tinitializers.\n\t(dependent_type_p_r): Determine dependent types in argument packs\n\tand pack expansions.\n\t(value_dependent_expression_p): Determine value-dependence of\n\tnon-type argument packs.\n\t(dependent_template_arg_p): Handle argument packs.\n\t* semantics.c (finish_cond): Check for bare parameter packs.\n\t(finish_expr_stmt): Ditto.\n\t(finish_for_expr): Ditto.\n\t(finish_switch_cond): Ditto.\n\t(finish_mem_initializers): Ditto.\n\t* name-lookup.c (arg_assoc_type): Handle pack expansions and\n\targument packs.\n\t* decl2.c (cp_build_parm_decl): Mark function parameter packs.\n\t* parser.c (make_declarator): Declarator is not an expansion.\n\t(make_pointer_declarator): Transfer parameter pack flag to outer\n\tdeclarator.\n\t(make_reference_declarator): Ditto.\n\t(make_ptrmem_declarator): Ditto.\n\t(make_call_declarator): Ditto.\n\t(make_array_declarator): Ditto.\n\t(cp_parser_postfix_expression): Allow pack expansion expressions\n\tin the argument list for a call expression.\n\t(cp_parser_parenthesized_expression_list): Add new parameter\n\tALLOW_EXPANSION_P. When true, parse the ellipsis to mean \"expand\n\tinto separate arguments.\"\n\t(cp_parser_new_placement): Allow pack expansion expressions.\n\t(cp_parser_new_initializer): Ditto.\n\t(cp_parser_mem_initializer_list): Allow ellipsis to create a\n\tbase-class initializer expansion.\n\t(cp_parser_mem_initializer): Ditto.\n\t(cp_parser_template_parameter_list): Keep track of whether the\n\ttemplate parameter is a template parameter pack.\n\t(cp_parser_template_parameter): Parse the ellipsis to indicate a\n\ttemplate parameter pack.\n\t(cp_parser_type_parameter): Ditto.\n\t(cp_parser_template_argument_list): Parse the ellipsis to indicate\n\ta pack expansion.\n\t(cp_parser_direct_declarator): Parse the ellipsis to indicate that\n\tthis declarator is a parameter pack.\n\t(cp_parser_parameter_declaration): The ellipsis does not end the\n\tparameter declaration, because it might be a parameter pack. Parse\n\tthe ellipsis to indicate a parameter pack.\n\t(cp_parser_initializer): Allow pack expansions.\n\t(cp_parser_initializer_list): Allow ellipsis to create an\n\tinitializer expansion.\n\t(cp_parser_base_clause): Allow ellipsis to create a base specifier\n\texpansion.\n\t(cp_parser_type_id_list): Allow ellipsis to create an exception\n\tspecifier expansion.\n\t(cp_parser_attribute_list): Don't allow pack expansions.\n\t(cp_parser_functional_cast): Allow pack expansions.\n\t(cp_parser_sizeof_operand): Allow ellipsis following \"sizeof\" to\n\tcompute the length of a parameter pack.\n\t(cp_parser_next_token_ends_template_argument_p): An ellipsis can\n\tend a template argument.\n\t* tree.c (cp_walk_subtrees): Walk BASELINK, TYPE_ARGUMENT_PACK,\n\tNONTYPE_ARGUMENT_PACK, TYPE_PACK_EXPANSION, EXPR_PACK_EXPANSION,\n\tCAST_EXPR.\n\nFrom-SVN: r122788", "tree": {"sha": "5b5cbae80b3f073895daff4c00dc387a5f31c3bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b5cbae80b3f073895daff4c00dc387a5f31c3bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d80a306744bf10263a1f69ceda3ac8366ba6606", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d80a306744bf10263a1f69ceda3ac8366ba6606", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d80a306744bf10263a1f69ceda3ac8366ba6606", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d80a306744bf10263a1f69ceda3ac8366ba6606/comments", "author": {"login": "DougGregor", "id": 989428, "node_id": "MDQ6VXNlcjk4OTQyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/989428?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DougGregor", "html_url": "https://github.com/DougGregor", "followers_url": "https://api.github.com/users/DougGregor/followers", "following_url": "https://api.github.com/users/DougGregor/following{/other_user}", "gists_url": "https://api.github.com/users/DougGregor/gists{/gist_id}", "starred_url": "https://api.github.com/users/DougGregor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DougGregor/subscriptions", "organizations_url": "https://api.github.com/users/DougGregor/orgs", "repos_url": "https://api.github.com/users/DougGregor/repos", "events_url": "https://api.github.com/users/DougGregor/events{/privacy}", "received_events_url": "https://api.github.com/users/DougGregor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "706ca88ebbb5060d4fca826e94ec84a4cec9b96e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/706ca88ebbb5060d4fca826e94ec84a4cec9b96e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/706ca88ebbb5060d4fca826e94ec84a4cec9b96e"}], "stats": {"total": 3515, "additions": 3227, "deletions": 288}, "files": [{"sha": "886b305c4a8995ecbe0d6651afe52fe4dde98f67", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 214, "deletions": 0, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d80a306744bf10263a1f69ceda3ac8366ba6606/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d80a306744bf10263a1f69ceda3ac8366ba6606/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5d80a306744bf10263a1f69ceda3ac8366ba6606", "patch": "@@ -1,3 +1,217 @@\n+2007-03-09  Douglas Gregor  <doug.gregor@gmail.com>\n+\n+\tPR c++/20599\n+\t* typeck.c (check_return_expr): Check for bare parameter packs.\n+\t(comptypes): Compare template parameter packs and\n+\ttype pack expansions.\n+\t* decl.c (grokdeclarator): Deal with the declaration of function\n+\tparameter packs.\n+\t(grokparms): Verify that the (optional) function parameter pack is\n+\tat the end of the parameter list.\n+\t(xref_basetypes): Handle pack expansions in the base class.\n+\t(cp_tree_node_structure): Handle ARGUMENT_PACK_SELECT.\n+\t* cp-tree.def (TYPE_ARGUMENT_PACK): New.\n+\t(NONTYPE_ARGUMENT_PACK): New.\n+\t(TYPE_PACK_EXPANSION): New.\n+\t(EXPR_PACK_EXPANSION): New.\n+\t(ARGUMENT_PACK_SELECT): New.\n+\t* cp-objcp-common.c (cp_tree_size): Compute size of\n+\t(NON)TYPE_ARGUMENT_PACK, (TYPE|EXPR)_PACK_EXPANSION, and\n+\tARGUMENT_PACK_SELECT.\n+\t* error.c (dump_template_argument): Print template argument packs.\n+\t(dump_template_argument_list): Ditto.\n+\t(dump_template_parameter): Dump `...' for template type parameter\n+\tpacks.\n+\t(dump_type): Dump TYPE_PACK_EXPANSION nodes.\n+\t(dump_parameters): Print function parameter packs.\n+\t(dump_template_parms): Print template argument packs.\n+\t(dump_expr): Dump EXPR_PACK_EXPANSION nodes.\n+\t(maybe_warn_variadic_templates): New.\n+\t* operators.def: Add ellipsis operator for EXPR_PACK_EXPANSION.\n+\t* tree.c (cp_walk_subtrees): Walk BASELINK, TYPE_ARGUMENT_PACK,\n+\tNONTYPE_ARGUMENT_PACK, TYPE_PACK_EXPANSION, EXPR_PACK_EXPANSION,\n+\tCAST_EXPR. \n+\t* mangle.c (write_type): Mangle TYPE_PACK_EXPANSION.\n+\t(write_template_arg): Write argument packs as separate arguments.\n+\t* cp-tree.h (struct template_parm_index_s): Add flag that\n+\tindicates that the template parameter is actually a parameter\n+\tpack.\n+\t(struct tree_argument_pack_select): New.\n+\t(enum cp_tree_node_structure_enum): Add TS_CP_ARGUMENT_PACK_SELECT.\n+\t(union lang_tree_node): Add argument_pack_select.\n+\t(FUNCTION_PARAMETER_PACK_P): New.\n+\t(PACK_EXPANSION_P): New.\n+\t(PACK_EXPANSION_PATTERN): New.\n+\t(SET_PACK_EXPANSION_PATTERN): New.\n+\t(PACK_EXPANSION_PARAMETER_PACKS): New.\n+\t(ARGUMENT_PACK_P): New.\n+\t(ARGUMENT_PACK_ARGS): New.\n+\t(SET_ARGUMENT_PACK_ARGS): New.\n+\t(ARGUMENT_PACK_INCOMPLETE_P): New.\n+\t(ARGUMENT_PACK_EXPLICIT_ARGS): New.\n+\t(TEMPLATE_PARM_PARAMETER_PACK): New.\n+\t(TEMPLATE_TYPE_PARAMETER_PACK): New.\n+\t(ARGUMENT_PACK_SELECT_FROM_PACK): New.\n+\t(ARGUMENT_PACK_SELECT_INDEX): New.\n+\t(ARGUMENT_PACK_SELECT_ARG): New.\n+\t(struct cp_declarator): Add parameter_pack_p flag.\n+\t(maybe_warn_variadic_templates): Declare.\n+\t(process_template_parm): Add bool parameter IS_PARAMETER_PACK, to\n+\tindicate a template parameter pack. \n+\t(uses_parameter_packs): Declare.\n+\t(template_parameter_pack_p): Declare.\n+\t(template_parms_variadic_p): Declare.\n+\t(make_pack_expansion): Declare.\n+\t(check_for_bare_parameter_packs): Declare.\n+\t* cxx-pretty-print.c (pp_cxx_unary_expression): Print\n+\tsizeof... expressions. \n+\t(pp_cxx_expression): Print pack expansions and non-type argument\n+\tpacks.\n+\t(pp_cxx_exception_specification): Print pack expansions. \n+\t(pp_cxx_direct_declarator): Print ellipsis for parameter packs.\n+\t(pp_cxx_ctor_initializer): Print pack expansions.\n+\t(pp_cxx_type_id): Print pack expansions.\n+\t(pp_cxx_template_argument_list): Print argument packs.\n+\t(pp_cxx_template_parameter): Print ellipsis for template parameter\n+\tpacks.\n+\t* pt.c (comp_template_parms): Compare template parameter packs.\n+\t(template_parameter_pack_p): New.\n+\t(template_parms_variadic_p): New.\n+\t(template_args_variadic_p): New.\n+\t(make_ith_pack_parameter_name): New.\n+\t(struct find_parameter_pack_data): New.\n+\t(find_parameter_packs_r): New.\n+\t(uses_parameter_packs): New.\n+\t(make_pack_expansion): New.\n+\t(check_for_bare_parameter_packs): New.\n+\t(expand_template_argument_pack): New.\n+\t(reduce_template_parm_level): Propagate parameter pack flag.\n+\t(process_template_parm): Add is_parameter_pack parameter to state\n+\twhen the parameter is actually a parameter pack. Create template\n+\tparameter packs when is_parameter_pack is true.\n+\t(current_template_args): The argument for a template parameter\n+\tpack is an argument pack containing a single pack expansion.\n+\t(process_partial_specialization): When checking that non-type\n+\targument expressions do not involve template parameters, loop over\n+\tthe arguments in argument packs separately.\n+\t(push_template_decl_real): Check that the type of the declaration\n+\tdoes not have any bare parameter packs. Check that primary\n+\ttemplates have no more than one parameter pack, and that it comes\n+\tat the end of the template parameter list.\n+\t(convert_template_argument): Handle coercions for pack expansion\n+\texpressions by coercing the pattern then rebuilding the expansion.\n+\t(coerce_template_parms): When coercing the arguments for a\n+\tvariadic template, pack \"extra\" arguments into an argument pack.\n+\t(coerce_template_template_parms): Cannot coerce between parameter\n+\tpacks and non-pack parameters.\n+\t(template_args_equal): Compare PACK_EXPANSION_P expressions.\n+\t(comp_template_args): Expand all template arguments packs before\n+\tcomparing template argument lists.\n+\t(mangle_class_name_for_template): Make argument packs as separate\n+\ttemplate arguments.\n+\t(for_each_template_parm_r): No need to handle BASELINK. \n+\t(instantiate_class_template): Handle pack expansions in the base\n+\tclass list.\n+\t(tsubst_pack_expansion): New.\n+\t(tsubst_template_args): Handle substitutions of argument packs and\n+\tpack expansion into template argument lists.\n+\t(tsubst_decl): Expand function parameter packs into separate\n+\tfunction parameters.\n+\t(tsubst_arg_types): Expand a type pack expansion into separate\n+\targument types.\n+\t(tsubst_exception_specification): Handle pack expansions in\n+\texception specifiers.\n+\t(tsubst): See through ARGUMENT_PACK_SELECT arguments when \n+\treplacing a template parameter with its argument. If we encounter\n+\ta substitution for an argument pack, just return the parameter\n+\titself. \n+\t(tsubst_copy): sizeof(X...) returns the number of elements in\n+\tparameter pack X.  See through ARGUMENT_PACK_SELECT when the\n+\tPARM_DECL is a parameter pack.\n+\t(tsubst_expr): Expression pack expansions and argument packs\n+\tcannot show up here; they will all be handled through function\n+\tcalls, sizeof, and template argument lists.\n+\t(tsubst_copy_and_build): sizeof(X...) returns the number of\n+\telements in parameter pack X.  Handle pack expansions in TREE_LIST\n+\tand CONSTRUCTOR nodes.\n+\t(fn_type_unification): Handle \"incomplete\" explicit template\n+\targument lists that specify some of the arguments for a template\n+\tparameter pack.\n+\t(type_unification_real): Unify arguments against pack expansions.\n+\t(template_parm_level_and_index): New, helper function.\n+\t(unify_pack_expansion): New.\n+\t(unify): Unify argument packs on an argument-by-argument basis,\n+\thandling variadic argument packs as well.\n+\t(more_specialized_fn): Handle unification of function parameter\n+\tpacks. All things being equal, prefer non-variadic function\n+\ttemplates to variadic function templates.\n+\t(more_specialized_class): Prefer the variadic class template\n+\tpartial specialization that binds fewer arguments to a parameter\n+\tpack.\n+\t(regenerate_decl_from_template): Expand function parameter packs\n+\tinto separate parameters.\n+\t(instantiate_decl): Ditto.\n+\t(tsubst_initializer_list): Handle pack expansions for base-class\n+\tinitializers.\n+\t(dependent_type_p_r): Determine dependent types in argument packs\n+\tand pack expansions.\n+\t(value_dependent_expression_p): Determine value-dependence of\n+\tnon-type argument packs.\n+\t(dependent_template_arg_p): Handle argument packs.\n+\t* semantics.c (finish_cond): Check for bare parameter packs.\n+\t(finish_expr_stmt): Ditto.\n+\t(finish_for_expr): Ditto.\n+\t(finish_switch_cond): Ditto.\n+\t(finish_mem_initializers): Ditto.\n+\t* name-lookup.c (arg_assoc_type): Handle pack expansions and\n+\targument packs.\n+\t* decl2.c (cp_build_parm_decl): Mark function parameter packs.\n+\t* parser.c (make_declarator): Declarator is not an expansion.\n+\t(make_pointer_declarator): Transfer parameter pack flag to outer\n+\tdeclarator.\n+\t(make_reference_declarator): Ditto.\n+\t(make_ptrmem_declarator): Ditto.\n+\t(make_call_declarator): Ditto.\n+\t(make_array_declarator): Ditto.\n+\t(cp_parser_postfix_expression): Allow pack expansion expressions\n+\tin the argument list for a call expression.\n+\t(cp_parser_parenthesized_expression_list): Add new parameter\n+\tALLOW_EXPANSION_P. When true, parse the ellipsis to mean \"expand\n+\tinto separate arguments.\"\n+\t(cp_parser_new_placement): Allow pack expansion expressions.\n+\t(cp_parser_new_initializer): Ditto.\n+\t(cp_parser_mem_initializer_list): Allow ellipsis to create a\n+\tbase-class initializer expansion.\n+\t(cp_parser_mem_initializer): Ditto.\n+\t(cp_parser_template_parameter_list): Keep track of whether the\n+\ttemplate parameter is a template parameter pack.\n+\t(cp_parser_template_parameter): Parse the ellipsis to indicate a\n+\ttemplate parameter pack.\n+\t(cp_parser_type_parameter): Ditto.\n+\t(cp_parser_template_argument_list): Parse the ellipsis to indicate\n+\ta pack expansion.\n+\t(cp_parser_direct_declarator): Parse the ellipsis to indicate that\n+\tthis declarator is a parameter pack.\n+\t(cp_parser_parameter_declaration): The ellipsis does not end the\n+\tparameter declaration, because it might be a parameter pack. Parse\n+\tthe ellipsis to indicate a parameter pack.\n+\t(cp_parser_initializer): Allow pack expansions.\n+\t(cp_parser_initializer_list): Allow ellipsis to create an\n+\tinitializer expansion.\n+\t(cp_parser_base_clause): Allow ellipsis to create a base specifier\n+\texpansion.\n+\t(cp_parser_type_id_list): Allow ellipsis to create an exception\n+\tspecifier expansion.\n+\t(cp_parser_attribute_list): Don't allow pack expansions.\n+\t(cp_parser_functional_cast): Allow pack expansions.\n+\t(cp_parser_sizeof_operand): Allow ellipsis following \"sizeof\" to\n+\tcompute the length of a parameter pack.\n+\t(cp_parser_next_token_ends_template_argument_p): An ellipsis can\n+\tend a template argument.\n+\t* tree.c (cp_walk_subtrees): Walk BASELINK, TYPE_ARGUMENT_PACK,\n+\tNONTYPE_ARGUMENT_PACK, TYPE_PACK_EXPANSION, EXPR_PACK_EXPANSION,\n+\tCAST_EXPR. \n+\n 2007-03-09  Dirk Mueller  <dmueller@suse.de>\n \n \t* cp/call.c (build_new_op): Call warn_logical_operator."}, {"sha": "7b1841e3fa74dd75991fcf199cab8e7ffec6552f", "filename": "gcc/cp/cp-objcp-common.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d80a306744bf10263a1f69ceda3ac8366ba6606/gcc%2Fcp%2Fcp-objcp-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d80a306744bf10263a1f69ceda3ac8366ba6606/gcc%2Fcp%2Fcp-objcp-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.c?ref=5d80a306744bf10263a1f69ceda3ac8366ba6606", "patch": "@@ -124,6 +124,17 @@ cp_tree_size (enum tree_code code)\n     case DEFAULT_ARG:\t\treturn sizeof (struct tree_default_arg);\n     case OVERLOAD:\t\treturn sizeof (struct tree_overload);\n     case STATIC_ASSERT:         return sizeof (struct tree_static_assert);\n+    case TYPE_ARGUMENT_PACK:\n+    case TYPE_PACK_EXPANSION:\n+      return sizeof (struct tree_common);\n+\n+    case NONTYPE_ARGUMENT_PACK:\n+    case EXPR_PACK_EXPANSION:\n+      return sizeof (struct tree_exp);\n+\n+    case ARGUMENT_PACK_SELECT:\n+      return sizeof (struct tree_argument_pack_select);\n+\n     default:\n       gcc_unreachable ();\n     }"}, {"sha": "83e1e53cbc75402bad220638a064ec90ae980813", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d80a306744bf10263a1f69ceda3ac8366ba6606/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d80a306744bf10263a1f69ceda3ac8366ba6606/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=5d80a306744bf10263a1f69ceda3ac8366ba6606", "patch": "@@ -352,6 +352,76 @@ DEFTREECODE (UNARY_PLUS_EXPR, \"unary_plus_expr\", tcc_unary, 1)\n    literal) to be displayed if the condition fails to hold.  */\n DEFTREECODE (STATIC_ASSERT, \"static_assert\", tcc_exceptional, 0)\n \n+/* Represents an argument pack of types (or templates). An argument\n+   pack stores zero or more arguments that will be used to instantiate\n+   a parameter pack. \n+\n+   ARGUMENT_PACK_ARGS retrieves the arguments stored in the argument\n+   pack.\n+\n+   Example:\n+     template<typename... Values>\n+     class tuple { ... };\n+\n+     tuple<int, float, double> t;\n+\n+   Values is a (template) parameter pack. When tuple<int, float,\n+   double> is instantiated, the Values parameter pack is instantiated\n+   with the argment pack <int, float, double>. ARGUMENT_PACK_ARGS will\n+   be a TREE_VEC containing int, float, and double.  */\n+DEFTREECODE (TYPE_ARGUMENT_PACK, \"type_argument_pack\", tcc_type, 0)\n+\n+/* Represents an argument pack of values, which can be used either for\n+   non-type template arguments or function call arguments. \n+\n+   NONTYPE_ARGUMENT_PACK plays precisely the same role as\n+   TYPE_ARGUMENT_PACK, but will be used for packing non-type template\n+   arguments (e.g., \"int... Dimensions\") or function arguments (\"const\n+   Args&... args\"). */\n+DEFTREECODE (NONTYPE_ARGUMENT_PACK, \"nontype_argument_pack\", tcc_expression, 1)\n+\n+/* Represents a type expression that will be expanded into a list of\n+   types when instantiated with one or more argument packs.\n+\n+   PACK_EXPANSION_PATTERN retrieves the expansion pattern. This is\n+   the type or expression that we will substitute into with each\n+   argument in an argument pack.\n+\n+   SET_PACK_EXPANSION_PATTERN sets the expansion pattern.\n+\n+   PACK_EXPANSION_PARAMETER_PACKS contains a TREE_LIST of the parameter\n+   packs that are used in this pack expansion.\n+\n+   Example:\n+     template<typename... Values>\n+     struct tied : tuple<Values&...> { \n+       // ...\n+     };\n+\n+   The derivation from tuple contains a TYPE_PACK_EXPANSION for the\n+   template arguments. Its EXPR_PACK_EXPANSION is \"Values&\" and its\n+   PACK_EXPANSION_PARAMETER_PACKS will contain \"Values\".  */\n+DEFTREECODE (TYPE_PACK_EXPANSION, \"type_pack_expansion\", tcc_type, 0)\n+\n+/* Represents an expression that will be expanded into a list of\n+   expressions when instantiated with one or more argument packs.\n+\n+   EXPR_PACK_EXPANSION plays precisely the same role as TYPE_PACK_EXPANSION,\n+   but will be used for expressions.  */\n+DEFTREECODE (EXPR_PACK_EXPANSION, \"expr_pack_expansion\", tcc_expression, 1)\n+\n+/* Selects the Ith parameter out of an argument pack. This node will\n+   be used when instantiating pack expansions; see\n+   tsubst_pack_expansion. \n+\n+   ARGUMENT_PACK_SELECT_FROM_PACK contains the *_ARGUMENT_PACK node\n+   from which the argument will be selected.\n+\n+   ARGUMENT_PACK_SELECT_INDEX contains the index into the argument\n+   pack that will be returned by this ARGUMENT_PACK_SELECT node. The\n+   index is a machine integer.  */\n+DEFTREECODE (ARGUMENT_PACK_SELECT, \"argument_pack_select\", tcc_exceptional, 0)\n+\n /*\n Local variables:\n mode:c"}, {"sha": "c90d5290eb37ec5ccac2c4f63863f910e52227ae", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 107, "deletions": 2, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d80a306744bf10263a1f69ceda3ac8366ba6606/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d80a306744bf10263a1f69ceda3ac8366ba6606/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=5d80a306744bf10263a1f69ceda3ac8366ba6606", "patch": "@@ -103,6 +103,7 @@ struct diagnostic_context;\n    1: C_TYPEDEF_EXPLICITLY_SIGNED (in TYPE_DECL).\n       DECL_TEMPLATE_INSTANTIATED (in a VAR_DECL or a FUNCTION_DECL)\n       DECL_MEMBER_TEMPLATE_P (in TEMPLATE_DECL)\n+      FUNCTION_PARAMETER_PACK_P (in PARM_DECL)\n    2: DECL_THIS_EXTERN (in VAR_DECL or FUNCTION_DECL).\n       DECL_IMPLICIT_TYPEDEF_P (in a TYPE_DECL)\n    3: DECL_IN_AGGR_P.\n@@ -222,6 +223,10 @@ struct template_parm_index_s GTY(())\n   HOST_WIDE_INT level;\n   HOST_WIDE_INT orig_level;\n   tree decl;\n+\n+  /* When true, indicates that this parameter is actually a parameter\n+     pack, for variadic templates.  */\n+  BOOL_BITFIELD parameter_pack;\n };\n typedef struct template_parm_index_s template_parm_index;\n \n@@ -469,6 +474,13 @@ struct tree_static_assert GTY (())\n   location_t location;\n };\n \n+struct tree_argument_pack_select GTY (())\n+{\n+  struct tree_common common;\n+  tree argument_pack;\n+  int index;\n+};\n+\n enum cp_tree_node_structure_enum {\n   TS_CP_GENERIC,\n   TS_CP_IDENTIFIER,\n@@ -481,6 +493,7 @@ enum cp_tree_node_structure_enum {\n   TS_CP_WRAPPER,\n   TS_CP_DEFAULT_ARG,\n   TS_CP_STATIC_ASSERT,\n+  TS_CP_ARGUMENT_PACK_SELECT,\n   LAST_TS_CP_ENUM\n };\n \n@@ -499,6 +512,8 @@ union lang_tree_node GTY((desc (\"cp_tree_node_structure (&%h)\"),\n   struct lang_identifier GTY ((tag (\"TS_CP_IDENTIFIER\"))) identifier;\n   struct tree_static_assert GTY ((tag (\"TS_CP_STATIC_ASSERT\"))) \n     static_assertion;\n+  struct tree_argument_pack_select GTY ((tag (\"TS_CP_ARGUMENT_PACK_SELECT\")))\n+    argument_pack_select;\n };\n \n \f\n@@ -2188,7 +2203,7 @@ extern void decl_shadowed_for_var_insert (tree, tree);\n /* Nonzero if the template arguments is actually a vector of vectors,\n    rather than just a vector.  */\n #define TMPL_ARGS_HAVE_MULTIPLE_LEVELS(NODE)\t\t\\\n-  (NODE && TREE_VEC_ELT (NODE, 0)\t\t\t\\\n+  (NODE && TREE_VEC_ELT (NODE, 0)                       \\\n    && TREE_CODE (TREE_VEC_ELT (NODE, 0)) == TREE_VEC)\n \n /* The depth of a template argument vector.  When called directly by\n@@ -2295,6 +2310,84 @@ extern void decl_shadowed_for_var_insert (tree, tree);\n    the class definition is complete.  */\n #define TEMPLATE_PARMS_FOR_INLINE(NODE) TREE_LANG_FLAG_1 (NODE)\n \n+/* Determine if a parameter (i.e., a PARM_DECL) is a function\n+   parameter pack.  */\n+#define FUNCTION_PARAMETER_PACK_P(NODE) \\\n+  (DECL_LANG_FLAG_1 (PARM_DECL_CHECK (NODE)))\n+\n+/* Determines if NODE is an expansion of one or more parameter packs,\n+   e.g., a TYPE_PACK_EXPANSION or EXPR_PACK_EXPANSION.  */\n+#define PACK_EXPANSION_P(NODE)                 \\\n+  (TREE_CODE (NODE) == TYPE_PACK_EXPANSION     \\\n+   || TREE_CODE (NODE) == EXPR_PACK_EXPANSION)\n+\n+/* Extracts the type or expression pattern from a TYPE_PACK_EXPANSION or\n+   EXPR_PACK_EXPANSION.  */\n+#define PACK_EXPANSION_PATTERN(NODE)                            \\\n+  (TREE_CODE (NODE) == TYPE_PACK_EXPANSION? TREE_TYPE (NODE)    \\\n+   : TREE_OPERAND (NODE, 0))\n+\n+/* Sets the type or expression pattern for a TYPE_PACK_EXPANSION or\n+   EXPR_PACK_EXPANSION.  */\n+#define SET_PACK_EXPANSION_PATTERN(NODE,VALUE)  \\\n+  if (TREE_CODE (NODE) == TYPE_PACK_EXPANSION)  \\\n+    TREE_TYPE (NODE) = VALUE;                   \\\n+  else                                          \\\n+    TREE_OPERAND (NODE, 0) = VALUE\n+\n+/* The list of parameter packs used in the PACK_EXPANSION_* node. The\n+   TREE_VALUE of each TREE_LIST contains the parameter packs.  */\n+#define PACK_EXPANSION_PARAMETER_PACKS(NODE) TREE_CHAIN (NODE)\n+\n+/* Determine if this is an argument pack.  */\n+#define ARGUMENT_PACK_P(NODE)                          \\\n+  (TREE_CODE (NODE) == TYPE_ARGUMENT_PACK              \\\n+   || TREE_CODE (NODE) == NONTYPE_ARGUMENT_PACK)\n+\n+/* The arguments stored in an argument pack. Arguments are stored in a\n+   TREE_VEC, which may have length zero.  */\n+#define ARGUMENT_PACK_ARGS(NODE)                               \\\n+  (TREE_CODE (NODE) == TYPE_ARGUMENT_PACK? TREE_TYPE (NODE)    \\\n+   : TREE_OPERAND (NODE, 0))\n+\n+/* Set the arguments stored in an argument pack. VALUE must be a\n+   TREE_VEC.  */\n+#define SET_ARGUMENT_PACK_ARGS(NODE,VALUE)     \\\n+  if (TREE_CODE (NODE) == TYPE_ARGUMENT_PACK)  \\\n+    TREE_TYPE (NODE) = VALUE;                           \\\n+  else                                                  \\\n+    TREE_OPERAND (NODE, 0) = VALUE\n+\n+/* Whether the argument pack is \"incomplete\", meaning that more\n+   arguments can still be deduced. Incomplete argument packs are only\n+   used when the user has provided an explicit template argument list\n+   for a variadic function template. Some of the explicit template\n+   arguments will be placed into the beginning of the argument pack,\n+   but additional arguments might still be deduced.  */\n+#define ARGUMENT_PACK_INCOMPLETE_P(NODE)        \\\n+  TREE_LANG_FLAG_0 (ARGUMENT_PACK_ARGS (NODE))\n+\n+/* When ARGUMENT_PACK_INCOMPLETE_P, stores the explicit template\n+   arguments used to fill this pack.  */\n+#define ARGUMENT_PACK_EXPLICIT_ARGS(NODE)       \\\n+  TREE_TYPE (ARGUMENT_PACK_ARGS (NODE))\n+\n+/* In an ARGUMENT_PACK_SELECT, the argument pack from which an\n+   argument will be selected.  */\n+#define ARGUMENT_PACK_SELECT_FROM_PACK(NODE)\t\t\t\t\\\n+  (((struct tree_argument_pack_select *)ARGUMENT_PACK_SELECT_CHECK (NODE))->argument_pack)\n+\n+/* In an ARGUMENT_PACK_SELECT, the index of the argument we want to\n+   select.  */\n+#define ARGUMENT_PACK_SELECT_INDEX(NODE)\t\t\t\t\\\n+  (((struct tree_argument_pack_select *)ARGUMENT_PACK_SELECT_CHECK (NODE))->index)\n+  \n+/* In an ARGUMENT_PACK_SELECT, the actual underlying argument that the\n+   ARGUMENT_PACK_SELECT represents. */\n+#define ARGUMENT_PACK_SELECT_ARG(NODE)\t\t\t\t\t\\\n+  TREE_VEC_ELT (ARGUMENT_PACK_ARGS (ARGUMENT_PACK_SELECT_FROM_PACK (NODE)), \\\n+\t        ARGUMENT_PACK_SELECT_INDEX (NODE));\n+\n /* In a FUNCTION_DECL, the saved language-specific per-function data.  */\n #define DECL_SAVED_FUNCTION_DATA(NODE)\t\t\t\\\n   (DECL_LANG_SPECIFIC (FUNCTION_DECL_CHECK (NODE))\t\\\n@@ -3612,6 +3705,7 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, OP_FLAG, TYPENAME_FLAG };\n #define TEMPLATE_PARM_DESCENDANTS(NODE) (TREE_CHAIN (NODE))\n #define TEMPLATE_PARM_ORIG_LEVEL(NODE) (TEMPLATE_PARM_INDEX_CAST (NODE)->orig_level)\n #define TEMPLATE_PARM_DECL(NODE) (TEMPLATE_PARM_INDEX_CAST (NODE)->decl)\n+#define TEMPLATE_PARM_PARAMETER_PACK(NODE) (TEMPLATE_PARM_INDEX_CAST (NODE)->parameter_pack)\n \n /* These macros are for accessing the fields of TEMPLATE_TYPE_PARM,\n    TEMPLATE_TEMPLATE_PARM and BOUND_TEMPLATE_TEMPLATE_PARM nodes.  */\n@@ -3626,6 +3720,8 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, OP_FLAG, TYPENAME_FLAG };\n   (TEMPLATE_PARM_ORIG_LEVEL (TEMPLATE_TYPE_PARM_INDEX (NODE)))\n #define TEMPLATE_TYPE_DECL(NODE) \\\n   (TEMPLATE_PARM_DECL (TEMPLATE_TYPE_PARM_INDEX (NODE)))\n+#define TEMPLATE_TYPE_PARAMETER_PACK(NODE) \\\n+  (TEMPLATE_PARM_PARAMETER_PACK (TEMPLATE_TYPE_PARM_INDEX (NODE)))\n \n /* These constants can used as bit flags in the process of tree formatting.\n \n@@ -3812,6 +3908,9 @@ struct cp_declarator {\n      cdk_id and cdk_error, guaranteed to be NULL.  */\n   cp_declarator *declarator;\n   location_t id_loc; /* Currently only set for cdk_id. */\n+  /* Whether we parsed an ellipsis (`...') just before the declarator,\n+     to indicate this is a parameter pack.  */\n+  bool parameter_pack_p;\n   union {\n     /* For identifiers.  */\n     struct {\n@@ -4104,6 +4203,7 @@ extern const char *lang_decl_name\t\t(tree, int);\n extern const char *language_to_string\t\t(enum languages);\n extern const char *class_key_or_enum_as_string\t(tree);\n extern void print_instantiation_context\t\t(void);\n+extern void maybe_warn_variadic_templates       (void);\n \n /* in except.c */\n extern void init_exception_processing\t\t(void);\n@@ -4194,7 +4294,7 @@ extern void end_specialization\t\t\t(void);\n extern void begin_explicit_instantiation\t(void);\n extern void end_explicit_instantiation\t\t(void);\n extern tree check_explicit_specialization\t(tree, tree, int, int);\n-extern tree process_template_parm\t\t(tree, tree, bool);\n+extern tree process_template_parm\t\t(tree, tree, bool, bool);\n extern tree end_template_parm_list\t\t(tree);\n extern void end_template_decl\t\t\t(void);\n extern tree push_template_decl\t\t\t(tree);\n@@ -4215,6 +4315,11 @@ extern void do_decl_instantiation\t\t(tree, tree);\n extern void do_type_instantiation\t\t(tree, tree, tsubst_flags_t);\n extern tree instantiate_decl\t\t\t(tree, int, bool);\n extern int comp_template_parms\t\t\t(tree, tree);\n+extern bool uses_parameter_packs                (tree);\n+extern bool template_parameter_pack_p           (tree);\n+extern bool template_parms_variadic_p           (tree);\n+extern tree make_pack_expansion                 (tree);\n+extern void check_for_bare_parameter_packs      (tree);\n extern int template_class_depth\t\t\t(tree);\n extern int is_specialization_of\t\t\t(tree, tree);\n extern bool is_specialization_of_friend\t\t(tree, tree);"}, {"sha": "e250bf78a2fad3ecdf10f56c0c4af5e96a3509ff", "filename": "gcc/cp/cxx-pretty-print.c", "status": "modified", "additions": 114, "deletions": 18, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d80a306744bf10263a1f69ceda3ac8366ba6606/gcc%2Fcp%2Fcxx-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d80a306744bf10263a1f69ceda3ac8366ba6606/gcc%2Fcp%2Fcxx-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.c?ref=5d80a306744bf10263a1f69ceda3ac8366ba6606", "patch": "@@ -659,6 +659,7 @@ pp_cxx_delete_expression (cxx_pretty_printer *pp, tree t)\n       unary-operator cast-expression\n       sizeof unary-expression\n       sizeof ( type-id )\n+      sizeof ... ( identifier )\n       new-expression\n       delete-expression\n \n@@ -686,6 +687,21 @@ pp_cxx_unary_expression (cxx_pretty_printer *pp, tree t)\n       break;\n \n     case SIZEOF_EXPR:\n+      if (PACK_EXPANSION_P (TREE_OPERAND (t, 0)))\n+\t{\n+\t  pp_cxx_identifier (pp, \"sizeof\");\n+\t  pp_cxx_identifier (pp, \"...\");\n+\t  pp_cxx_whitespace (pp);\n+\t  pp_cxx_left_paren (pp);\n+\t  if (TYPE_P (TREE_OPERAND (t, 0)))\n+\t    pp_cxx_type_id (pp, TREE_OPERAND (t, 0));\n+\t  else\n+\t    pp_unary_expression (pp, TREE_OPERAND (t, 0));\n+\t  pp_cxx_right_paren (pp);\n+\t  break;\n+\t}\n+      /* Fall through  */\n+\n     case ALIGNOF_EXPR:\n       pp_cxx_identifier (pp, code == SIZEOF_EXPR ? \"sizeof\" : \"__alignof__\");\n       pp_cxx_whitespace (pp);\n@@ -1000,6 +1016,24 @@ pp_cxx_expression (cxx_pretty_printer *pp, tree t)\n       pp_cxx_expression (pp, t);\n       break;\n \n+    case EXPR_PACK_EXPANSION:\n+      pp_cxx_expression (pp, PACK_EXPANSION_PATTERN (t));\n+      pp_cxx_identifier (pp, \"...\");\n+      break;\n+\n+    case NONTYPE_ARGUMENT_PACK:\n+      {\n+\ttree args = ARGUMENT_PACK_ARGS (t);\n+\tint i, len = TREE_VEC_LENGTH (args);\n+\tfor (i = 0; i < len; ++i)\n+\t  {\n+\t    if (i > 0)\n+\t      pp_cxx_separate_with (pp, ',');\n+\t    pp_cxx_expression (pp, TREE_VEC_ELT (args, i));\n+\t  }\n+      }\n+      break;\n+\n     default:\n       pp_c_expression (pp_c_base (pp), t);\n       break;\n@@ -1290,16 +1324,36 @@ static void\n pp_cxx_exception_specification (cxx_pretty_printer *pp, tree t)\n {\n   tree ex_spec = TYPE_RAISES_EXCEPTIONS (t);\n+  bool need_comma = false;\n \n   if (!TYPE_NOTHROW_P (t) && ex_spec == NULL)\n     return;\n   pp_cxx_identifier (pp, \"throw\");\n   pp_cxx_left_paren (pp);\n   for (; ex_spec && TREE_VALUE (ex_spec); ex_spec = TREE_CHAIN (ex_spec))\n     {\n-      pp_cxx_type_id (pp, TREE_VALUE (ex_spec));\n-      if (TREE_CHAIN (ex_spec))\n-\tpp_cxx_separate_with (pp, ',');\n+      tree type = TREE_VALUE (ex_spec);\n+      tree argpack = NULL_TREE;\n+      int i, len = 1;\n+\n+      if (ARGUMENT_PACK_P (type))\n+\t{\n+\t  argpack = ARGUMENT_PACK_ARGS (type);\n+\t  len = TREE_VEC_LENGTH (argpack);\n+\t}\n+\n+      for (i = 0; i < len; ++i)\n+\t{\n+\t  if (argpack)\n+\t    type = TREE_VEC_ELT (argpack, i);\n+\n+\t  if (need_comma)\n+\t    pp_cxx_separate_with (pp, ',');\n+\t  else\n+\t    need_comma = true;\n+\n+\t  pp_cxx_type_id (pp, type);\n+\t}\n     }\n   pp_cxx_right_paren (pp);\n }\n@@ -1323,6 +1377,13 @@ pp_cxx_direct_declarator (cxx_pretty_printer *pp, tree t)\n       if (DECL_NAME (t))\n \t{\n \t  pp_cxx_space_for_pointer_operator (pp, TREE_TYPE (t));\n+\n+\t  if ((TREE_CODE (t) == PARM_DECL && FUNCTION_PARAMETER_PACK_P (t))\n+\t      || template_parameter_pack_p (t))\n+\t    /* A function parameter pack or non-type template\n+\t       parameter pack.  */\n+\t    pp_cxx_identifier (pp, \"...\");\n+\t\t      \n \t  pp_cxx_id_expression (pp, DECL_NAME (t));\n \t}\n       pp_cxx_abstract_declarator (pp, TREE_TYPE (t));\n@@ -1388,8 +1449,16 @@ pp_cxx_ctor_initializer (cxx_pretty_printer *pp, tree t)\n   pp_cxx_whitespace (pp);\n   for (; t; t = TREE_CHAIN (t))\n     {\n-      pp_cxx_primary_expression (pp, TREE_PURPOSE (t));\n+      tree purpose = TREE_PURPOSE (t);\n+      bool is_pack = PACK_EXPANSION_P (purpose);\n+\n+      if (is_pack)\n+\tpp_cxx_primary_expression (pp, PACK_EXPANSION_PATTERN (purpose));\n+      else\n+\tpp_cxx_primary_expression (pp, purpose);\n       pp_cxx_call_argument_list (pp, TREE_VALUE (t));\n+      if (is_pack)\n+\tpp_cxx_identifier (pp, \"...\");\n       if (TREE_CHAIN (t))\n \tpp_cxx_separate_with (pp, ',');\n     }\n@@ -1510,6 +1579,11 @@ pp_cxx_type_id (cxx_pretty_printer *pp, tree t)\n       pp_cxx_type_specifier_seq (pp, t);\n       break;\n \n+    case TYPE_PACK_EXPANSION:\n+      pp_cxx_type_id (pp, PACK_EXPANSION_PATTERN (t));\n+      pp_cxx_identifier (pp, \"...\");\n+      break;\n+\n     default:\n       pp_c_type_id (pp_c_base (pp), t);\n       break;\n@@ -1519,30 +1593,50 @@ pp_cxx_type_id (cxx_pretty_printer *pp, tree t)\n }\n \n /* template-argument-list:\n-      template-argument\n-      template-argument-list, template-argument\n+      template-argument ...(opt)\n+      template-argument-list, template-argument ...(opt)\n \n    template-argument:\n       assignment-expression\n       type-id\n-      template-name   */\n+      template-name  */\n \n static void\n pp_cxx_template_argument_list (cxx_pretty_printer *pp, tree t)\n {\n   int i;\n+  bool need_comma = false;\n+\n   if (t == NULL)\n     return;\n   for (i = 0; i < TREE_VEC_LENGTH (t); ++i)\n     {\n       tree arg = TREE_VEC_ELT (t, i);\n-      if (i != 0)\n-\tpp_cxx_separate_with (pp, ',');\n-      if (TYPE_P (arg) || (TREE_CODE (arg) == TEMPLATE_DECL\n-\t\t\t   && TYPE_P (DECL_TEMPLATE_RESULT (arg))))\n-\tpp_cxx_type_id (pp, arg);\n-      else\n-\tpp_cxx_expression (pp, arg);\n+      tree argpack = NULL_TREE;\n+      int idx, len = 1;\n+\n+      if (ARGUMENT_PACK_P (arg))\n+\t{\n+\t  argpack = ARGUMENT_PACK_ARGS (arg);\n+\t  len = TREE_VEC_LENGTH (argpack);\n+\t}\n+\n+      for (idx = 0; idx < len; idx++)\n+\t{\n+\t  if (argpack)\n+\t    arg = TREE_VEC_ELT (argpack, idx);\n+\t  \n+\t  if (need_comma)\n+\t    pp_cxx_separate_with (pp, ',');\n+\t  else\n+\t    need_comma = true;\n+\n+\t  if (TYPE_P (arg) || (TREE_CODE (arg) == TEMPLATE_DECL\n+\t\t\t       && TYPE_P (DECL_TEMPLATE_RESULT (arg))))\n+\t    pp_cxx_type_id (pp, arg);\n+\t  else\n+\t    pp_cxx_expression (pp, arg);\n+\t}\n     }\n }\n \n@@ -1837,11 +1931,11 @@ pp_cxx_template_parameter_list (cxx_pretty_printer *pp, tree t)\n       parameter-declaration\n \n    type-parameter:\n-     class identifier(opt)\n-     class identifier(op) = type-id\n+     class ...(opt) identifier(opt)\n+     class identifier(opt) = type-id\n      typename identifier(opt)\n-     typename identifier(opt) = type-id\n-     template < template-parameter-list > class identifier(opt)\n+     typename ...(opt) identifier(opt) = type-id\n+     template < template-parameter-list > class ...(opt) identifier(opt)\n      template < template-parameter-list > class identifier(opt) = template-name  */\n \n static void\n@@ -1852,6 +1946,8 @@ pp_cxx_template_parameter (cxx_pretty_printer *pp, tree t)\n     {\n     case TYPE_DECL:\n       pp_cxx_identifier (pp, \"class\");\n+      if (TEMPLATE_TYPE_PARAMETER_PACK (TREE_TYPE (t)))\n+\tpp_cxx_identifier (pp, \"...\");\n       if (DECL_NAME (parameter))\n \tpp_cxx_tree_identifier (pp, DECL_NAME (parameter));\n       /* FIXME: Chech if we should print also default argument.  */"}, {"sha": "318085a02b42a416269fa07028b2d8c40ac91bb0", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d80a306744bf10263a1f69ceda3ac8366ba6606/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d80a306744bf10263a1f69ceda3ac8366ba6606/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=5d80a306744bf10263a1f69ceda3ac8366ba6606", "patch": "@@ -6967,6 +6967,7 @@ grokdeclarator (const cp_declarator *declarator,\n   cp_storage_class storage_class;\n   bool unsigned_p, signed_p, short_p, long_p, thread_p;\n   bool type_was_error_mark_node = false;\n+  bool parameter_pack_p = declarator? declarator->parameter_pack_p : false;\n   bool set_no_warning = false;\n \n   signed_p = declspecs->specs[(int)ds_signed];\n@@ -7938,6 +7939,16 @@ grokdeclarator (const cp_declarator *declarator,\n \tattrlist = &returned_attrs;\n     }\n \n+  /* Handle parameter packs. */\n+  if (parameter_pack_p)\n+    {\n+      if (decl_context == PARM)\n+        /* Turn the type into a pack expansion.*/\n+        type = make_pack_expansion (type);\n+      else\n+        error (\"non-parameter %qs cannot be a parameter pack\", name);\n+    }\n+\n   /* Did array size calculations overflow?  */\n \n   if (TREE_CODE (type) == ARRAY_TYPE\n@@ -8940,6 +8951,11 @@ grokparms (cp_parameter_declarator *first_parm, tree *parms)\n \t    init = check_default_argument (decl, init);\n \t}\n \n+      if (TREE_CODE (decl) == PARM_DECL\n+          && FUNCTION_PARAMETER_PACK_P (decl)\n+          && parm->next)\n+        error (\"parameter packs must be at the end of the parameter list\");\n+\n       TREE_CHAIN (decl) = decls;\n       decls = decl;\n       result = tree_cons (init, type, result);\n@@ -9941,6 +9957,8 @@ xref_basetypes (tree ref, tree base_list)\n       if (access == access_default_node)\n \taccess = default_access;\n \n+      if (PACK_EXPANSION_P (basetype))\n+        basetype = PACK_EXPANSION_PATTERN (basetype);\n       if (TREE_CODE (basetype) == TYPE_DECL)\n \tbasetype = TREE_TYPE (basetype);\n       if (TREE_CODE (basetype) != RECORD_TYPE\n@@ -9986,6 +10004,11 @@ xref_basetypes (tree ref, tree base_list)\n \t    error (\"duplicate base type %qT invalid\", basetype);\n \t  return false;\n \t}\n+\n+      if (PACK_EXPANSION_P (TREE_VALUE (base_list)))\n+        /* Regenerate the pack expansion for the bases. */\n+        basetype = make_pack_expansion (basetype);\n+\n       TYPE_MARKED_P (basetype) = 1;\n \n       base_binfo = copy_binfo (base_binfo, basetype, ref,\n@@ -11695,6 +11718,7 @@ cp_tree_node_structure (union lang_tree_node * t)\n     case PTRMEM_CST:\t\treturn TS_CP_PTRMEM;\n     case BASELINK:\t\treturn TS_CP_BASELINK;\n     case STATIC_ASSERT:\t\treturn TS_CP_STATIC_ASSERT;\n+    case ARGUMENT_PACK_SELECT:  return TS_CP_ARGUMENT_PACK_SELECT;\n     default:\t\t\treturn TS_CP_GENERIC;\n     }\n }"}, {"sha": "bd078330b0a96742ab61437cc49bd4dfa57ac016", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d80a306744bf10263a1f69ceda3ac8366ba6606/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d80a306744bf10263a1f69ceda3ac8366ba6606/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=5d80a306744bf10263a1f69ceda3ac8366ba6606", "patch": "@@ -136,6 +136,12 @@ cp_build_parm_decl (tree name, tree type)\n      sees templates.  */\n   if (!processing_template_decl)\n     DECL_ARG_TYPE (parm) = type_passed_as (type);\n+\n+  /* If the type is a pack expansion, then we have a function\n+     parameter pack. */\n+  if (type && TREE_CODE (type) == TYPE_PACK_EXPANSION)\n+    FUNCTION_PARAMETER_PACK_P (parm) = 1;\n+\n   return parm;\n }\n "}, {"sha": "41a7e1d0d207aaae840c6571a76cf5f82d957ba9", "filename": "gcc/cp/error.c", "status": "modified", "additions": 66, "deletions": 14, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d80a306744bf10263a1f69ceda3ac8366ba6606/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d80a306744bf10263a1f69ceda3ac8366ba6606/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=5d80a306744bf10263a1f69ceda3ac8366ba6606", "patch": "@@ -138,7 +138,9 @@ dump_scope (tree scope, int flags)\n static void\n dump_template_argument (tree arg, int flags)\n {\n-  if (TYPE_P (arg) || TREE_CODE (arg) == TEMPLATE_DECL)\n+  if (ARGUMENT_PACK_P (arg))\n+    dump_template_argument_list (ARGUMENT_PACK_ARGS (arg), flags);\n+  else if (TYPE_P (arg) || TREE_CODE (arg) == TEMPLATE_DECL)\n     dump_type (arg, flags & ~TFF_CLASS_KEY_OR_ENUM);\n   else\n     dump_expr (arg, (flags | TFF_EXPR_IN_PARENS) & ~TFF_CLASS_KEY_OR_ENUM);\n@@ -156,9 +158,17 @@ dump_template_argument_list (tree args, int flags)\n \n   for (i = 0; i< n; ++i)\n     {\n-      if (need_comma)\n+      tree arg = TREE_VEC_ELT (args, i);\n+\n+      /* Only print a comma if we know there is an argument coming. In\n+         the case of an empty template argument pack, no actual\n+         argument will be printed.  */\n+      if (need_comma\n+          && (!ARGUMENT_PACK_P (arg)\n+              || TREE_VEC_LENGTH (ARGUMENT_PACK_ARGS (arg)) > 0))\n \tpp_separate_with_comma (cxx_pp);\n-      dump_template_argument (TREE_VEC_ELT (args, i), flags);\n+\n+      dump_template_argument (arg, flags);\n       need_comma = 1;\n     }\n }\n@@ -182,6 +192,8 @@ dump_template_parameter (tree parm, int flags)\n       if (flags & TFF_DECL_SPECIFIERS)\n \t{\n \t  pp_cxx_identifier (cxx_pp, \"class\");\n+          if (TEMPLATE_TYPE_PARAMETER_PACK (TREE_TYPE (p)))\n+            pp_cxx_identifier (cxx_pp, \"...\");\n \t  if (DECL_NAME (p))\n \t    pp_cxx_tree_identifier (cxx_pp, DECL_NAME (p));\n \t}\n@@ -378,6 +390,11 @@ dump_type (tree t, int flags)\n       pp_cxx_right_paren (cxx_pp);\n       break;\n \n+    case TYPE_PACK_EXPANSION:\n+      dump_type (PACK_EXPANSION_PATTERN (t), flags);\n+      pp_cxx_identifier (cxx_pp, \"...\");\n+      break;\n+\n     default:\n       pp_unsupported_tree (cxx_pp, t);\n       /* Fall through to error.  */\n@@ -1102,8 +1119,7 @@ dump_function_decl (tree t, int flags)\n static void\n dump_parameters (tree parmtypes, int flags)\n {\n-  int first;\n-\n+  int first = 1;\n   pp_cxx_left_paren (cxx_pp);\n \n   for (first = 1; parmtypes != void_list_node;\n@@ -1117,7 +1133,22 @@ dump_parameters (tree parmtypes, int flags)\n \t  pp_cxx_identifier (cxx_pp, \"...\");\n \t  break;\n \t}\n-      dump_type (TREE_VALUE (parmtypes), flags);\n+      if (ARGUMENT_PACK_P (TREE_VALUE (parmtypes)))\n+        {\n+          tree types = ARGUMENT_PACK_ARGS (TREE_VALUE (parmtypes));\n+          int i, len = TREE_VEC_LENGTH (types);\n+\t  first = 1;\n+          for (i = 0; i < len; ++i)\n+            {\n+              if (!first)\n+                pp_separate_with_comma (cxx_pp);\n+              first = 0;\n+              \n+              dump_type (TREE_VEC_ELT (types, i), flags);\n+            }\n+        }\n+      else\n+        dump_type (TREE_VALUE (parmtypes), flags);\n \n       if ((flags & TFF_FUNCTION_DEFAULT_ARGUMENTS) && TREE_PURPOSE (parmtypes))\n \t{\n@@ -1240,14 +1271,19 @@ dump_template_parms (tree info, int primary, int flags)\n \t{\n \t  tree arg = TREE_VEC_ELT (args, ix);\n \n-\t  if (ix)\n-\t    pp_separate_with_comma (cxx_pp);\n-\n-\t  if (!arg)\n-\t    pp_identifier (cxx_pp, \"<template parameter error>\");\n-\t  else\n-\t    dump_template_argument (arg, flags);\n-\t}\n+          /* Only print a comma if we know there is an argument coming. In\n+             the case of an empty template argument pack, no actual\n+             argument will be printed.  */\n+          if (ix\n+              && (!ARGUMENT_PACK_P (arg)\n+                  || TREE_VEC_LENGTH (ARGUMENT_PACK_ARGS (arg)) > 0))\n+            pp_separate_with_comma (cxx_pp);\n+          \n+          if (!arg)\n+            pp_identifier (cxx_pp, \"<template parameter error>\");\n+          else\n+            dump_template_argument (arg, flags);\n+        }\n     }\n   else if (primary)\n     {\n@@ -1946,6 +1982,11 @@ dump_expr (tree t, int flags)\n       dump_expr (TREE_OPERAND (t, 0), flags);\n       break;\n \n+    case EXPR_PACK_EXPANSION:\n+      dump_expr (PACK_EXPANSION_PATTERN (t), flags);\n+      pp_cxx_identifier (cxx_pp, \"...\");\n+      break;\n+\n       /*  This list is incomplete, but should suffice for now.\n \t  It is very important that `sorry' does not call\n \t  `report_error_function'.  That could cause an infinite loop.  */\n@@ -2464,3 +2505,14 @@ cp_cpp_error (cpp_reader *pfile ATTRIBUTE_UNUSED, int level,\n \t\t\t\t  input_location, dlevel);\n   report_diagnostic (&diagnostic);\n }\n+\n+/* Warn about the use of variadic templates when appropriate.  */\n+void\n+maybe_warn_variadic_templates (void)\n+{\n+  if ((!flag_cpp0x || flag_iso) && !in_system_header)\n+    /* We really want to surpress this warning in system headers,\n+       because libstdc++ uses variadic templates even when we aren't\n+       in C++0x mode. */\n+    pedwarn (\"ISO C++ does not include variadic templates\");\n+}"}, {"sha": "40c059ad63ceb38bbf05f338a565cacb3e59e897", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d80a306744bf10263a1f69ceda3ac8366ba6606/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d80a306744bf10263a1f69ceda3ac8366ba6606/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=5d80a306744bf10263a1f69ceda3ac8366ba6606", "patch": "@@ -1645,6 +1645,11 @@ write_type (tree type)\n \t  write_type (TREE_TYPE (type));\n \t  break;\n \n+        case TYPE_PACK_EXPANSION:\n+          write_string (\"U10__variadic\");\n+          write_type (PACK_EXPANSION_PATTERN (type));\n+          break;\n+\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -2302,7 +2307,15 @@ write_template_arg (tree node)\n \tG.need_abi_warning = 1;\n     }\n \n-  if (TYPE_P (node))\n+  if (ARGUMENT_PACK_P (node))\n+    {\n+      /* Expand the template argument pack. */\n+      tree args = ARGUMENT_PACK_ARGS (node);\n+      int i, length = TREE_VEC_LENGTH (args);\n+      for (i = 0; i < length; ++i)\n+        write_template_arg (TREE_VEC_ELT (args, i));\n+    }\n+  else if (TYPE_P (node))\n     write_type (node);\n   else if (code == TEMPLATE_DECL)\n     /* A template appearing as a template arg is a template template arg.  */"}, {"sha": "8efcfed28a42a016735b7e4ed5ca2a7accfc1f69", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d80a306744bf10263a1f69ceda3ac8366ba6606/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d80a306744bf10263a1f69ceda3ac8366ba6606/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=5d80a306744bf10263a1f69ceda3ac8366ba6606", "patch": "@@ -4563,6 +4563,18 @@ arg_assoc_type (struct arg_lookup *k, tree type)\n     case LANG_TYPE:\n       gcc_assert (type == unknown_type_node);\n       return false;\n+    case TYPE_PACK_EXPANSION:\n+      return arg_assoc_type (k, PACK_EXPANSION_PATTERN (type));\n+    case TYPE_ARGUMENT_PACK:\n+      {\n+        tree args = ARGUMENT_PACK_ARGS (type);\n+        int i, len = TREE_VEC_LENGTH (args);\n+        for (i = 0; i < len; i++)\n+          if (arg_assoc_type (k, TREE_VEC_ELT (args, i)))\n+            return true;\n+      }\n+      break;\n+\n     default:\n       gcc_unreachable ();\n     }"}, {"sha": "b8400cd33c3df0170da66f91757c93f7558370ec", "filename": "gcc/cp/operators.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d80a306744bf10263a1f69ceda3ac8366ba6606/gcc%2Fcp%2Foperators.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d80a306744bf10263a1f69ceda3ac8366ba6606/gcc%2Fcp%2Foperators.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foperators.def?ref=5d80a306744bf10263a1f69ceda3ac8366ba6606", "patch": "@@ -150,3 +150,6 @@ DEF_SIMPLE_OPERATOR (\"?:\", COND_EXPR, \"qu\", 3)\n \n /* Miscellaneous.  */\n DEF_SIMPLE_OPERATOR (\"()\", CALL_EXPR, \"cl\", -1)\n+\n+/* Variadic templates extension. */\n+DEF_SIMPLE_OPERATOR (\"...\", EXPR_PACK_EXPANSION, \"pu\", 1)"}, {"sha": "f81fbdf59047675843f852fb24da65b4e84d9962", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 338, "deletions": 32, "changes": 370, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d80a306744bf10263a1f69ceda3ac8366ba6606/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d80a306744bf10263a1f69ceda3ac8366ba6606/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=5d80a306744bf10263a1f69ceda3ac8366ba6606", "patch": "@@ -891,6 +891,7 @@ make_declarator (cp_declarator_kind kind)\n   declarator->kind = kind;\n   declarator->attributes = NULL_TREE;\n   declarator->declarator = NULL;\n+  declarator->parameter_pack_p = false;\n \n   return declarator;\n }\n@@ -928,7 +929,7 @@ make_id_declarator (tree qualifying_scope, tree unqualified_name,\n   declarator->u.id.qualifying_scope = qualifying_scope;\n   declarator->u.id.unqualified_name = unqualified_name;\n   declarator->u.id.sfk = sfk;\n-\n+  \n   return declarator;\n }\n \n@@ -945,6 +946,13 @@ make_pointer_declarator (cp_cv_quals cv_qualifiers, cp_declarator *target)\n   declarator->declarator = target;\n   declarator->u.pointer.qualifiers = cv_qualifiers;\n   declarator->u.pointer.class_type = NULL_TREE;\n+  if (target)\n+    {\n+      declarator->parameter_pack_p = target->parameter_pack_p;\n+      target->parameter_pack_p = false;\n+    }\n+  else\n+    declarator->parameter_pack_p = false;\n \n   return declarator;\n }\n@@ -960,6 +968,13 @@ make_reference_declarator (cp_cv_quals cv_qualifiers, cp_declarator *target)\n   declarator->declarator = target;\n   declarator->u.pointer.qualifiers = cv_qualifiers;\n   declarator->u.pointer.class_type = NULL_TREE;\n+  if (target)\n+    {\n+      declarator->parameter_pack_p = target->parameter_pack_p;\n+      target->parameter_pack_p = false;\n+    }\n+  else\n+    declarator->parameter_pack_p = false;\n \n   return declarator;\n }\n@@ -978,6 +993,14 @@ make_ptrmem_declarator (cp_cv_quals cv_qualifiers, tree class_type,\n   declarator->u.pointer.qualifiers = cv_qualifiers;\n   declarator->u.pointer.class_type = class_type;\n \n+  if (pointee)\n+    {\n+      declarator->parameter_pack_p = pointee->parameter_pack_p;\n+      pointee->parameter_pack_p = false;\n+    }\n+  else\n+    declarator->parameter_pack_p = false;\n+\n   return declarator;\n }\n \n@@ -999,6 +1022,13 @@ make_call_declarator (cp_declarator *target,\n   declarator->u.function.parameters = parms;\n   declarator->u.function.qualifiers = cv_qualifiers;\n   declarator->u.function.exception_specification = exception_specification;\n+  if (target)\n+    {\n+      declarator->parameter_pack_p = target->parameter_pack_p;\n+      target->parameter_pack_p = false;\n+    }\n+  else\n+    declarator->parameter_pack_p = false;\n \n   return declarator;\n }\n@@ -1014,6 +1044,13 @@ make_array_declarator (cp_declarator *element, tree bounds)\n   declarator = make_declarator (cdk_array);\n   declarator->declarator = element;\n   declarator->u.array.bounds = bounds;\n+  if (element)\n+    {\n+      declarator->parameter_pack_p = element->parameter_pack_p;\n+      element->parameter_pack_p = false;\n+    }\n+  else\n+    declarator->parameter_pack_p = false;\n \n   return declarator;\n }\n@@ -1518,7 +1555,7 @@ static tree cp_parser_postfix_open_square_expression\n static tree cp_parser_postfix_dot_deref_expression\n   (cp_parser *, enum cpp_ttype, tree, bool, cp_id_kind *);\n static tree cp_parser_parenthesized_expression_list\n-  (cp_parser *, bool, bool, bool *);\n+  (cp_parser *, bool, bool, bool, bool *);\n static void cp_parser_pseudo_destructor_name\n   (cp_parser *, tree *, tree *);\n static tree cp_parser_unary_expression\n@@ -1731,9 +1768,9 @@ static void cp_parser_template_declaration\n static tree cp_parser_template_parameter_list\n   (cp_parser *);\n static tree cp_parser_template_parameter\n-  (cp_parser *, bool *);\n+  (cp_parser *, bool *, bool *);\n static tree cp_parser_type_parameter\n-  (cp_parser *);\n+  (cp_parser *, bool *);\n static tree cp_parser_template_id\n   (cp_parser *, bool, bool, bool);\n static tree cp_parser_template_name\n@@ -4368,7 +4405,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p)\n \t      }\n \t    args = (cp_parser_parenthesized_expression_list\n \t\t    (parser, /*is_attribute_list=*/false,\n-\t\t     /*cast_p=*/false,\n+\t\t     /*cast_p=*/false, /*allow_expansion_p=*/true,\n \t\t     /*non_constant_p=*/NULL));\n \t    if (is_builtin_constant_p)\n \t      {\n@@ -4764,6 +4801,9 @@ cp_parser_postfix_dot_deref_expression (cp_parser *parser,\n \n    CAST_P is true if this expression is the target of a cast.\n \n+   ALLOW_EXPANSION_P is true if this expression allows expansion of an\n+   argument pack.\n+\n    Returns a TREE_LIST.  The TREE_VALUE of each node is a\n    representation of an assignment-expression.  Note that a TREE_LIST\n    is returned even if there is only a single expression in the list.\n@@ -4778,6 +4818,7 @@ static tree\n cp_parser_parenthesized_expression_list (cp_parser* parser,\n \t\t\t\t\t bool is_attribute_list,\n \t\t\t\t\t bool cast_p,\n+                                         bool allow_expansion_p,\n \t\t\t\t\t bool *non_constant_p)\n {\n   tree expression_list = NULL_TREE;\n@@ -4827,6 +4868,18 @@ cp_parser_parenthesized_expression_list (cp_parser* parser,\n \t    if (fold_expr_p)\n \t      expr = fold_non_dependent_expr (expr);\n \n+            /* If we have an ellipsis, then this is an expression\n+\t       expansion.  */\n+            if (allow_expansion_p\n+                && cp_lexer_next_token_is (parser->lexer, CPP_ELLIPSIS))\n+              {\n+                /* Consume the `...'.  */\n+                cp_lexer_consume_token (parser->lexer);\n+\n+                /* Build the argument pack.  */\n+                expr = make_pack_expansion (expr);\n+              }\n+\n \t     /* Add it to the list.  We add error_mark_node\n \t\texpressions to the list, so that we can still tell if\n \t\tthe correct form for a parenthesized expression-list\n@@ -5276,7 +5329,7 @@ cp_parser_new_placement (cp_parser* parser)\n \n   /* Parse the expression-list.  */\n   expression_list = (cp_parser_parenthesized_expression_list\n-\t\t     (parser, false, /*cast_p=*/false,\n+\t\t     (parser, false, /*cast_p=*/false, /*allow_expansion_p=*/true,\n \t\t      /*non_constant_p=*/NULL));\n \n   return expression_list;\n@@ -5481,7 +5534,7 @@ cp_parser_new_initializer (cp_parser* parser)\n   tree expression_list;\n \n   expression_list = (cp_parser_parenthesized_expression_list\n-\t\t     (parser, false, /*cast_p=*/false,\n+\t\t     (parser, false, /*cast_p=*/false, /*allow_expansion_p=*/true,\n \t\t      /*non_constant_p=*/NULL));\n   if (!expression_list)\n     expression_list = void_zero_node;\n@@ -8189,8 +8242,8 @@ cp_parser_ctor_initializer_opt (cp_parser* parser)\n /* Parse a mem-initializer-list.\n \n    mem-initializer-list:\n-     mem-initializer\n-     mem-initializer , mem-initializer-list  */\n+     mem-initializer ... [opt]\n+     mem-initializer ... [opt] , mem-initializer-list  */\n \n static void\n cp_parser_mem_initializer_list (cp_parser* parser)\n@@ -8209,6 +8262,26 @@ cp_parser_mem_initializer_list (cp_parser* parser)\n \n       /* Parse the mem-initializer.  */\n       mem_initializer = cp_parser_mem_initializer (parser);\n+      /* If the next token is a `...', we're expanding member initializers. */\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_ELLIPSIS))\n+        {\n+          /* Consume the `...'. */\n+          cp_lexer_consume_token (parser->lexer);\n+\n+          /* The TREE_PURPOSE must be a _TYPE, because base-specifiers\n+             can be expanded but members cannot. */\n+          if (mem_initializer != error_mark_node\n+              && !TYPE_P (TREE_PURPOSE (mem_initializer)))\n+            {\n+              error (\"cannot expand initializer for member %<%D%>\", \n+                     TREE_PURPOSE (mem_initializer));\n+              mem_initializer = error_mark_node;\n+            }\n+\n+          /* Construct the pack expansion type. */\n+          if (mem_initializer != error_mark_node)\n+            mem_initializer = make_pack_expansion (mem_initializer);\n+        }\n       /* Add it to the list, unless it was erroneous.  */\n       if (mem_initializer != error_mark_node)\n \t{\n@@ -8264,6 +8337,7 @@ cp_parser_mem_initializer (cp_parser* parser)\n   expression_list\n     = cp_parser_parenthesized_expression_list (parser, false,\n \t\t\t\t\t       /*cast_p=*/false,\n+                                               /*allow_expansion_p=*/true,\n \t\t\t\t\t       /*non_constant_p=*/NULL);\n   if (expression_list == error_mark_node)\n     return error_mark_node;\n@@ -8667,14 +8741,18 @@ cp_parser_template_parameter_list (cp_parser* parser)\n       tree parameter;\n       cp_token *token;\n       bool is_non_type;\n+      bool is_parameter_pack;\n \n       /* Parse the template-parameter.  */\n-      parameter = cp_parser_template_parameter (parser, &is_non_type);\n+      parameter = cp_parser_template_parameter (parser, \n+                                                &is_non_type,\n+                                                &is_parameter_pack);\n       /* Add it to the list.  */\n       if (parameter != error_mark_node)\n \tparameter_list = process_template_parm (parameter_list,\n \t\t\t\t\t\tparameter,\n-\t\t\t\t\t\tis_non_type);\n+\t\t\t\t\t\tis_non_type,\n+                                                is_parameter_pack);\n       else\n        {\n          tree err_parm = build_tree_list (parameter, parameter);\n@@ -8703,22 +8781,26 @@ cp_parser_template_parameter_list (cp_parser* parser)\n    If all goes well, returns a TREE_LIST.  The TREE_VALUE represents\n    the parameter.  The TREE_PURPOSE is the default value, if any.\n    Returns ERROR_MARK_NODE on failure.  *IS_NON_TYPE is set to true\n-   iff this parameter is a non-type parameter.  */\n+   iff this parameter is a non-type parameter.  *IS_PARAMETER_PACK is\n+   set to true iff this parameter is a parameter pack. */\n \n static tree\n-cp_parser_template_parameter (cp_parser* parser, bool *is_non_type)\n+cp_parser_template_parameter (cp_parser* parser, bool *is_non_type,\n+                              bool *is_parameter_pack)\n {\n   cp_token *token;\n   cp_parameter_declarator *parameter_declarator;\n   tree parm;\n \n   /* Assume it is a type parameter or a template parameter.  */\n   *is_non_type = false;\n+  /* Assume it not a parameter pack. */\n+  *is_parameter_pack = false;\n   /* Peek at the next token.  */\n   token = cp_lexer_peek_token (parser->lexer);\n   /* If it is `class' or `template', we have a type-parameter.  */\n   if (token->keyword == RID_TEMPLATE)\n-    return cp_parser_type_parameter (parser);\n+    return cp_parser_type_parameter (parser, is_parameter_pack);\n   /* If it is `class' or `typename' we do not know yet whether it is a\n      type parameter or a non-type parameter.  Consider:\n \n@@ -8736,6 +8818,10 @@ cp_parser_template_parameter (cp_parser* parser, bool *is_non_type)\n     {\n       /* Peek at the token after `class' or `typename'.  */\n       token = cp_lexer_peek_nth_token (parser->lexer, 2);\n+      /* If it's an ellipsis, we have a template type parameter\n+         pack. */\n+      if (token->type == CPP_ELLIPSIS)\n+        return cp_parser_type_parameter (parser, is_parameter_pack);\n       /* If it's an identifier, skip it.  */\n       if (token->type == CPP_NAME)\n \ttoken = cp_lexer_peek_nth_token (parser->lexer, 3);\n@@ -8744,7 +8830,7 @@ cp_parser_template_parameter (cp_parser* parser, bool *is_non_type)\n       if (token->type == CPP_COMMA\n \t  || token->type == CPP_EQ\n \t  || token->type == CPP_GREATER)\n-\treturn cp_parser_type_parameter (parser);\n+\treturn cp_parser_type_parameter (parser, is_parameter_pack);\n     }\n \n   /* Otherwise, it is a non-type parameter.\n@@ -8759,12 +8845,40 @@ cp_parser_template_parameter (cp_parser* parser, bool *is_non_type)\n   parameter_declarator\n      = cp_parser_parameter_declaration (parser, /*template_parm_p=*/true,\n \t\t\t\t\t/*parenthesized_p=*/NULL);\n+\n+  /* If the parameter declaration is marked as a parameter pack, set\n+     *IS_PARAMETER_PACK to notify the caller. Also, unmark the\n+     declarator's PACK_EXPANSION_P, otherwise we'll get errors from\n+     grokdeclarator. */\n+  if (parameter_declarator\n+      && parameter_declarator->declarator\n+      && parameter_declarator->declarator->parameter_pack_p)\n+    {\n+      *is_parameter_pack = true;\n+      parameter_declarator->declarator->parameter_pack_p = false;\n+    }\n+\n+  /* If the next token is an ellipsis, and we don't already have it\n+     marked as a parameter pack, then we have a parameter pack (that\n+     has no declarator); */\n+  if (!*is_parameter_pack\n+      && cp_lexer_next_token_is (parser->lexer, CPP_ELLIPSIS))\n+    {\n+\n+      /* Consume the `...'. */\n+      cp_lexer_consume_token (parser->lexer);\n+      maybe_warn_variadic_templates ();\n+      \n+      *is_parameter_pack = true;\n+    }\n+\n   parm = grokdeclarator (parameter_declarator->declarator,\n \t\t\t &parameter_declarator->decl_specifiers,\n \t\t\t PARM, /*initialized=*/0,\n \t\t\t /*attrlist=*/NULL);\n   if (parm == error_mark_node)\n     return error_mark_node;\n+\n   return build_tree_list (parameter_declarator->default_argument, parm);\n }\n \n@@ -8779,12 +8893,20 @@ cp_parser_template_parameter (cp_parser* parser, bool *is_non_type)\n      template < template-parameter-list > class identifier [opt]\n        = id-expression\n \n+   GNU Extension (variadic templates):\n+\n+   type-parameter:\n+     class ... identifier [opt]\n+     typename ... identifier [opt]\n+\n    Returns a TREE_LIST.  The TREE_VALUE is itself a TREE_LIST.  The\n    TREE_PURPOSE is the default-argument, if any.  The TREE_VALUE is\n-   the declaration of the parameter.  */\n+   the declaration of the parameter.\n+\n+   Sets *IS_PARAMETER_PACK if this is a template parameter pack. */\n \n static tree\n-cp_parser_type_parameter (cp_parser* parser)\n+cp_parser_type_parameter (cp_parser* parser, bool *is_parameter_pack)\n {\n   cp_token *token;\n   tree parameter;\n@@ -8803,6 +8925,17 @@ cp_parser_type_parameter (cp_parser* parser)\n \ttree identifier;\n \ttree default_argument;\n \n+        /* If the next token is an ellipsis, we have a template\n+           argument pack. */\n+        if (cp_lexer_next_token_is (parser->lexer, CPP_ELLIPSIS))\n+          {\n+            /* Consume the `...' token. */\n+            cp_lexer_consume_token (parser->lexer);\n+            maybe_warn_variadic_templates ();\n+\n+            *is_parameter_pack = true;\n+          }\n+\n \t/* If the next token is an identifier, then it names the\n \t   parameter.  */\n \tif (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n@@ -8821,6 +8954,18 @@ cp_parser_type_parameter (cp_parser* parser)\n \t    /* Parse the default-argument.  */\n \t    push_deferring_access_checks (dk_no_deferred);\n \t    default_argument = cp_parser_type_id (parser);\n+\n+            /* Template parameter packs cannot have default\n+               arguments. */\n+            if (*is_parameter_pack)\n+              {\n+                if (identifier)\n+                  error (\"template parameter pack %qD cannot have a default argument\", \n+                         identifier);\n+                else\n+                  error (\"template parameter packs cannot have default arguments\");\n+                default_argument = NULL_TREE;\n+              }\n \t    pop_deferring_access_checks ();\n \t  }\n \telse\n@@ -8846,6 +8991,16 @@ cp_parser_type_parameter (cp_parser* parser)\n \tcp_parser_require (parser, CPP_GREATER, \"`>'\");\n \t/* Look for the `class' keyword.  */\n \tcp_parser_require_keyword (parser, RID_CLASS, \"`class'\");\n+        /* If the next token is an ellipsis, we have a template\n+           argument pack. */\n+        if (cp_lexer_next_token_is (parser->lexer, CPP_ELLIPSIS))\n+          {\n+            /* Consume the `...' token. */\n+            cp_lexer_consume_token (parser->lexer);\n+            maybe_warn_variadic_templates ();\n+\n+            *is_parameter_pack = true;\n+          }\n \t/* If the next token is an `=', then there is a\n \t   default-argument.  If the next token is a `>', we are at\n \t   the end of the parameter-list.  If the next token is a `,',\n@@ -8900,6 +9055,18 @@ cp_parser_type_parameter (cp_parser* parser)\n \t    /* See if the default argument is valid.  */\n \t    default_argument\n \t      = check_template_template_default_arg (default_argument);\n+\n+            /* Template parameter packs cannot have default\n+               arguments. */\n+            if (*is_parameter_pack)\n+              {\n+                if (identifier)\n+                  error (\"template parameter pack %qD cannot have a default argument\", \n+                         identifier);\n+                else\n+                  error (\"template parameter packs cannot have default arguments\");\n+                default_argument = NULL_TREE;\n+              }\n \t    pop_deferring_access_checks ();\n \t  }\n \telse\n@@ -9316,8 +9483,8 @@ cp_parser_template_name (cp_parser* parser,\n /* Parse a template-argument-list.\n \n    template-argument-list:\n-     template-argument\n-     template-argument-list , template-argument\n+     template-argument ... [opt]\n+     template-argument-list , template-argument ... [opt]\n \n    Returns a TREE_VEC containing the arguments.  */\n \n@@ -9353,6 +9520,19 @@ cp_parser_template_argument_list (cp_parser* parser)\n \n       /* Parse the template-argument.  */\n       argument = cp_parser_template_argument (parser);\n+\n+      /* If the next token is an ellipsis, we're expanding a template\n+         argument pack. */\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_ELLIPSIS))\n+        {\n+          /* Consume the `...' token. */\n+          cp_lexer_consume_token (parser->lexer);\n+\n+          /* Make the argument into a TYPE_PACK_EXPANSION or\n+             EXPR_PACK_EXPANSION. */\n+          argument = make_pack_expansion (argument);\n+        }\n+\n       if (n_args == alloced)\n \t{\n \t  alloced *= 2;\n@@ -11878,17 +12058,47 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t  tree unqualified_name;\n \t  special_function_kind sfk;\n \t  bool abstract_ok;\n+          bool pack_expansion_p = false;\n \n \t  /* Parse a declarator-id */\n \t  abstract_ok = (dcl_kind == CP_PARSER_DECLARATOR_EITHER);\n \t  if (abstract_ok)\n-\t    cp_parser_parse_tentatively (parser);\n+            {\n+              cp_parser_parse_tentatively (parser);\n+\n+              /* If we see an ellipsis, we should be looking at a\n+                 parameter pack. */\n+              if (token->type == CPP_ELLIPSIS)\n+                {\n+                  /* Consume the `...' */\n+                  cp_lexer_consume_token (parser->lexer);\n+\n+                  pack_expansion_p = true;\n+                }\n+            }\n+\n \t  unqualified_name\n \t    = cp_parser_declarator_id (parser, /*optional_p=*/abstract_ok);\n \t  qualifying_scope = parser->scope;\n \t  if (abstract_ok)\n \t    {\n-\t      if (!cp_parser_parse_definitely (parser))\n+              bool okay = false;\n+\n+              if (!unqualified_name && pack_expansion_p)\n+                {\n+                  /* Check whether an error occurred. */\n+                  okay = !cp_parser_error_occurred (parser);\n+\n+                  /* We already consumed the ellipsis to mark a\n+                     parameter pack, but we have no way to report it,\n+                     so abort the tentative parse. We will be exiting\n+                     immediately anyway. */\n+                  cp_parser_abort_tentative_parse (parser);\n+                }\n+              else\n+                okay = cp_parser_parse_definitely (parser);\n+\n+\t      if (!okay)\n \t\tunqualified_name = error_mark_node;\n \t      else if (unqualified_name\n \t\t       && (qualifying_scope\n@@ -11905,6 +12115,8 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t  if (unqualified_name == error_mark_node)\n \t    {\n \t      declarator = cp_error_declarator;\n+              pack_expansion_p = false;\n+              declarator->parameter_pack_p = false;\n \t      break;\n \t    }\n \n@@ -11941,6 +12153,7 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t    }\n \n \t  sfk = sfk_none;\n+\n \t  if (unqualified_name)\n \t    {\n \t      tree class_type;\n@@ -12008,6 +12221,10 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t\t\t\t\t   unqualified_name,\n \t\t\t\t\t   sfk);\n \t  declarator->id_loc = token->location;\n+          declarator->parameter_pack_p = pack_expansion_p;\n+\n+          if (pack_expansion_p)\n+            maybe_warn_variadic_templates ();\n \n \thandle_declarator:;\n \t  scope = get_scope_of_declarator (declarator);\n@@ -12569,9 +12786,9 @@ cp_parser_parameter_declaration_list (cp_parser* parser, bool *is_error)\n /* Parse a parameter declaration.\n \n    parameter-declaration:\n-     decl-specifier-seq declarator\n+     decl-specifier-seq ... [opt] declarator\n      decl-specifier-seq declarator = assignment-expression\n-     decl-specifier-seq abstract-declarator [opt]\n+     decl-specifier-seq ... [opt] abstract-declarator [opt]\n      decl-specifier-seq abstract-declarator [opt] = assignment-expression\n \n    If TEMPLATE_PARM_P is TRUE, then this parameter-declaration\n@@ -12626,12 +12843,13 @@ cp_parser_parameter_declaration (cp_parser *parser,\n \n   /* Peek at the next token.  */\n   token = cp_lexer_peek_token (parser->lexer);\n+\n   /* If the next token is a `)', `,', `=', `>', or `...', then there\n-     is no declarator.  */\n+     is no declarator. However, when variadic templates are enabled,\n+     there may be a declarator following `...'.  */\n   if (token->type == CPP_CLOSE_PAREN\n       || token->type == CPP_COMMA\n       || token->type == CPP_EQ\n-      || token->type == CPP_ELLIPSIS\n       || token->type == CPP_GREATER)\n     {\n       declarator = NULL;\n@@ -12673,6 +12891,34 @@ cp_parser_parameter_declaration (cp_parser *parser,\n \t\t   cp_parser_attributes_opt (parser));\n     }\n \n+  /* If the next token is an ellipsis, and the type of the declarator\n+     contains parameter packs but it is not a TYPE_PACK_EXPANSION, then\n+     we actually have a parameter pack expansion expression. Otherwise,\n+     leave the ellipsis for a C-style variadic function. */\n+  token = cp_lexer_peek_token (parser->lexer);\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_ELLIPSIS))\n+    {\n+      tree type = decl_specifiers.type;\n+\n+      if (DECL_P (type))\n+        type = TREE_TYPE (type);\n+\n+      if (TREE_CODE (type) != TYPE_PACK_EXPANSION\n+          && (!declarator || !declarator->parameter_pack_p)\n+          && uses_parameter_packs (type))\n+        {\n+          /* Consume the `...'. */\n+          cp_lexer_consume_token (parser->lexer);\n+          maybe_warn_variadic_templates ();\n+          \n+          /* Build a pack expansion type */\n+          if (declarator)\n+            declarator->parameter_pack_p = true;\n+          else\n+            decl_specifiers.type = make_pack_expansion (type);\n+        }\n+    }\n+\n   /* The restriction on defining new types applies only to the type\n      of the parameter, not to the default argument.  */\n   parser->type_definition_forbidden_message = saved_message;\n@@ -12904,6 +13150,7 @@ cp_parser_initializer (cp_parser* parser, bool* is_parenthesized_init,\n   else if (token->type == CPP_OPEN_PAREN)\n     init = cp_parser_parenthesized_expression_list (parser, false,\n \t\t\t\t\t\t    /*cast_p=*/false,\n+                                                    /*allow_expansion_p=*/true,\n \t\t\t\t\t\t    non_constant_p);\n   else\n     {\n@@ -12979,8 +13226,8 @@ cp_parser_initializer_clause (cp_parser* parser, bool* non_constant_p)\n /* Parse an initializer-list.\n \n    initializer-list:\n-     initializer-clause\n-     initializer-list , initializer-clause\n+     initializer-clause ... [opt]\n+     initializer-list , initializer-clause ... [opt]\n \n    GNU Extension:\n \n@@ -13034,6 +13281,17 @@ cp_parser_initializer_list (cp_parser* parser, bool* non_constant_p)\n       if (clause_non_constant_p)\n \t*non_constant_p = true;\n \n+      /* If we have an ellipsis, this is an initializer pack\n+\t expansion.  */\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_ELLIPSIS))\n+        {\n+          /* Consume the `...'.  */\n+          cp_lexer_consume_token (parser->lexer);\n+\n+          /* Turn the initializer into an initializer expansion.  */\n+          initializer = make_pack_expansion (initializer);\n+        }\n+\n       /* Add it to the vector.  */\n       CONSTRUCTOR_APPEND_ELT(v, identifier, initializer);\n \n@@ -14335,8 +14593,8 @@ cp_parser_constant_initializer (cp_parser* parser)\n      : base-specifier-list\n \n    base-specifier-list:\n-     base-specifier\n-     base-specifier-list , base-specifier\n+     base-specifier ... [opt]\n+     base-specifier-list , base-specifier ... [opt]\n \n    Returns a TREE_LIST representing the base-classes, in the order in\n    which they were declared.  The representation of each node is as\n@@ -14358,12 +14616,28 @@ cp_parser_base_clause (cp_parser* parser)\n     {\n       cp_token *token;\n       tree base;\n+      bool pack_expansion_p = false;\n \n       /* Look for the base-specifier.  */\n       base = cp_parser_base_specifier (parser);\n+      /* Look for the (optional) ellipsis. */\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_ELLIPSIS))\n+        {\n+          /* Consume the `...'. */\n+          cp_lexer_consume_token (parser->lexer);\n+\n+          pack_expansion_p = true;\n+        }\n+\n       /* Add BASE to the front of the list.  */\n       if (base != error_mark_node)\n \t{\n+          if (pack_expansion_p)\n+            /* Make this a pack expansion type. */\n+            TREE_VALUE (base) = make_pack_expansion (TREE_VALUE (base));\n+          else\n+            check_for_bare_parameter_packs (TREE_VALUE (base));\n+\n \t  TREE_CHAIN (base) = bases;\n \t  bases = base;\n \t}\n@@ -14569,8 +14843,8 @@ cp_parser_exception_specification_opt (cp_parser* parser)\n /* Parse an (optional) type-id-list.\n \n    type-id-list:\n-     type-id\n-     type-id-list , type-id\n+     type-id ... [opt]\n+     type-id-list , type-id ... [opt]\n \n    Returns a TREE_LIST.  The TREE_VALUE of each node is a TYPE,\n    in the order that the types were presented.  */\n@@ -14587,6 +14861,15 @@ cp_parser_type_id_list (cp_parser* parser)\n \n       /* Get the next type-id.  */\n       type = cp_parser_type_id (parser);\n+      /* Parse the optional ellipsis. */\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_ELLIPSIS))\n+        {\n+          /* Consume the `...'. */\n+          cp_lexer_consume_token (parser->lexer);\n+\n+          /* Turn the type into a pack expansion expression. */\n+          type = make_pack_expansion (type);\n+        }\n       /* Add it to the list.  */\n       types = add_exception_specifier (types, type, /*complain=*/1);\n       /* Peek at the next token.  */\n@@ -15020,6 +15303,7 @@ cp_parser_attribute_list (cp_parser* parser)\n \t    {\n \t      arguments = cp_parser_parenthesized_expression_list\n \t\t\t  (parser, true, /*cast_p=*/false,\n+                           /*allow_expansion_p=*/false,\n \t\t\t   /*non_constant_p=*/NULL);\n \t      /* Save the arguments away.  */\n \t      TREE_VALUE (attribute) = arguments;\n@@ -16102,6 +16386,7 @@ cp_parser_functional_cast (cp_parser* parser, tree type)\n   expression_list\n     = cp_parser_parenthesized_expression_list (parser, false,\n \t\t\t\t\t       /*cast_p=*/true,\n+                                               /*allow_expansion_p=*/true,\n \t\t\t\t\t       /*non_constant_p=*/NULL);\n \n   cast = build_functional_cast (type, expression_list);\n@@ -16451,6 +16736,7 @@ cp_parser_sizeof_operand (cp_parser* parser, enum rid keyword)\n   const char *saved_message;\n   bool saved_integral_constant_expression_p;\n   bool saved_non_integral_constant_expression_p;\n+  bool pack_expansion_p = false;\n \n   /* Initialize FORMAT the first time we get here.  */\n   if (!format)\n@@ -16475,6 +16761,19 @@ cp_parser_sizeof_operand (cp_parser* parser, enum rid keyword)\n     = parser->non_integral_constant_expression_p;\n   parser->integral_constant_expression_p = false;\n \n+  /* If it's a `...', then we are computing the length of a parameter\n+     pack.  */\n+  if (keyword == RID_SIZEOF\n+      && cp_lexer_next_token_is (parser->lexer, CPP_ELLIPSIS))\n+    {\n+      /* Consume the `...'.  */\n+      cp_lexer_consume_token (parser->lexer);\n+      maybe_warn_variadic_templates ();\n+\n+      /* Note that this is an expansion.  */\n+      pack_expansion_p = true;\n+    }\n+\n   /* Do not actually evaluate the expression.  */\n   ++skip_evaluation;\n   /* If it's a `(', then we might be looking at the type-id\n@@ -16519,6 +16818,11 @@ cp_parser_sizeof_operand (cp_parser* parser, enum rid keyword)\n   if (!expr)\n     expr = cp_parser_unary_expression (parser, /*address_p=*/false,\n \t\t\t\t       /*cast_p=*/false);\n+\n+  if (pack_expansion_p)\n+    /* Build a pack expansion. */\n+    expr = make_pack_expansion (expr);\n+\n   /* Go back to evaluating expressions.  */\n   --skip_evaluation;\n \n@@ -16811,7 +17115,9 @@ cp_parser_next_token_ends_template_argument_p (cp_parser *parser)\n   cp_token *token;\n \n   token = cp_lexer_peek_token (parser->lexer);\n-  return (token->type == CPP_COMMA || token->type == CPP_GREATER);\n+  return (token->type == CPP_COMMA \n+          || token->type == CPP_GREATER\n+          || token->type == CPP_ELLIPSIS);\n }\n \n /* Returns TRUE iff the n-th token is a \"<\", or the n-th is a \"[\" and the"}, {"sha": "bf82f8c533028522895165cc820958b6d101d35a", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 2178, "deletions": 217, "changes": 2395, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d80a306744bf10263a1f69ceda3ac8366ba6606/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d80a306744bf10263a1f69ceda3ac8366ba6606/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=5d80a306744bf10263a1f69ceda3ac8366ba6606"}, {"sha": "f63ed2f47f7ed5d0cb30db306ccfd84ff72cbd5c", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d80a306744bf10263a1f69ceda3ac8366ba6606/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d80a306744bf10263a1f69ceda3ac8366ba6606/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=5d80a306744bf10263a1f69ceda3ac8366ba6606", "patch": "@@ -509,6 +509,8 @@ finish_cond (tree *cond_p, tree expr)\n       tree cond = pop_stmt_list (*cond_p);\n       if (TREE_CODE (cond) == DECL_EXPR)\n \texpr = cond;\n+\n+      check_for_bare_parameter_packs (expr);\n     }\n   *cond_p = expr;\n }\n@@ -618,6 +620,8 @@ finish_expr_stmt (tree expr)\n       else if (!type_dependent_expression_p (expr))\n \tconvert_to_void (build_non_dependent_expr (expr), \"statement\");\n \n+      check_for_bare_parameter_packs (expr);\n+\n       /* Simplification of inner statement expressions, compound exprs,\n \t etc can result in us already having an EXPR_STMT.  */\n       if (TREE_CODE (expr) != CLEANUP_POINT_EXPR)\n@@ -866,6 +870,7 @@ finish_for_expr (tree expr, tree for_stmt)\n   else if (!type_dependent_expression_p (expr))\n     convert_to_void (build_non_dependent_expr (expr), \"3rd expression in for\");\n   expr = maybe_cleanup_point_expr_void (expr);\n+  check_for_bare_parameter_packs (expr);\n   FOR_EXPR (for_stmt) = expr;\n }\n \n@@ -966,6 +971,7 @@ finish_switch_cond (tree cond, tree switch_stmt)\n   add_stmt (switch_stmt);\n   push_switch (switch_stmt);\n   SWITCH_STMT_BODY (switch_stmt) = push_stmt_list ();\n+  check_for_bare_parameter_packs (cond);\n }\n \n /* Finish the body of a switch-statement, which may be given by\n@@ -1362,7 +1368,22 @@ finish_mem_initializers (tree mem_inits)\n   mem_inits = nreverse (mem_inits);\n \n   if (processing_template_decl)\n-    add_stmt (build_min_nt (CTOR_INITIALIZER, mem_inits));\n+    {\n+      tree mem;\n+\n+      for (mem = mem_inits; mem; mem = TREE_CHAIN (mem))\n+        {\n+          /* If the TREE_PURPOSE is a TYPE_PACK_EXPANSION, skip the\n+             check for bare parameter packs in the TREE_VALUE, because\n+             any parameter packs in the TREE_VALUE have already been\n+             bound as part of the TREE_PURPOSE.  See\n+             make_pack_expansion for more information.  */\n+          if (TREE_CODE (TREE_PURPOSE (mem)) != TYPE_PACK_EXPANSION)\n+            check_for_bare_parameter_packs (TREE_VALUE (mem));\n+        }\n+\n+      add_stmt (build_min_nt (CTOR_INITIALIZER, mem_inits));\n+    }\n   else\n     emit_mem_initializers (mem_inits);\n }"}, {"sha": "d334a689e29b9ef2cac8e8854b8c87dbb80a7679", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d80a306744bf10263a1f69ceda3ac8366ba6606/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d80a306744bf10263a1f69ceda3ac8366ba6606/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=5d80a306744bf10263a1f69ceda3ac8366ba6606", "patch": "@@ -2233,12 +2233,16 @@ cp_walk_subtrees (tree *tp, int *walk_subtrees_p, walk_tree_fn func,\n     case TEMPLATE_TYPE_PARM:\n     case TYPENAME_TYPE:\n     case TYPEOF_TYPE:\n-    case BASELINK:\n       /* None of these have subtrees other than those already walked\n \t above.  */\n       *walk_subtrees_p = 0;\n       break;\n \n+    case BASELINK:\n+      WALK_SUBTREE (BASELINK_FUNCTIONS (*tp));\n+      *walk_subtrees_p = 0;\n+      break;\n+\n     case TINST_LEVEL:\n       WALK_SUBTREE (TINST_DECL (*tp));\n       *walk_subtrees_p = 0;\n@@ -2264,6 +2268,38 @@ cp_walk_subtrees (tree *tp, int *walk_subtrees_p, walk_tree_fn func,\n \tWALK_SUBTREE (TYPE_PTRMEMFUNC_FN_TYPE (*tp));\n       break;\n \n+    case TYPE_ARGUMENT_PACK:\n+    case NONTYPE_ARGUMENT_PACK:\n+      {\n+        tree args = ARGUMENT_PACK_ARGS (*tp);\n+        int i, len = TREE_VEC_LENGTH (args);\n+        for (i = 0; i < len; i++)\n+          WALK_SUBTREE (TREE_VEC_ELT (args, i));\n+      }\n+      break;\n+\n+    case TYPE_PACK_EXPANSION:\n+      WALK_SUBTREE (TREE_TYPE (*tp));\n+      *walk_subtrees_p = 0;\n+      break;\n+      \n+    case EXPR_PACK_EXPANSION:\n+      WALK_SUBTREE (TREE_OPERAND (*tp, 0));\n+      *walk_subtrees_p = 0;\n+      break;\n+\n+    case CAST_EXPR:\n+      if (TREE_TYPE (*tp))\n+\tWALK_SUBTREE (TREE_TYPE (*tp));\n+\n+      {\n+        int i;\n+        for (i = 0; i < TREE_CODE_LENGTH (TREE_CODE (*tp)); ++i)\n+\t  WALK_SUBTREE (TREE_OPERAND (*tp, i));\n+      }\n+      *walk_subtrees_p = 0;\n+      break;\n+\n     default:\n       input_location = save_locus;\n       return NULL_TREE;"}, {"sha": "c774671ef0d17aba4e2acd6ffa83eead39d3cbd7", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d80a306744bf10263a1f69ceda3ac8366ba6606/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d80a306744bf10263a1f69ceda3ac8366ba6606/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=5d80a306744bf10263a1f69ceda3ac8366ba6606", "patch": "@@ -991,7 +991,9 @@ structural_comptypes (tree t1, tree t2, int strict)\n     case TEMPLATE_TEMPLATE_PARM:\n     case BOUND_TEMPLATE_TEMPLATE_PARM:\n       if (TEMPLATE_TYPE_IDX (t1) != TEMPLATE_TYPE_IDX (t2)\n-\t  || TEMPLATE_TYPE_LEVEL (t1) != TEMPLATE_TYPE_LEVEL (t2))\n+\t  || TEMPLATE_TYPE_LEVEL (t1) != TEMPLATE_TYPE_LEVEL (t2)\n+          || (TEMPLATE_TYPE_PARAMETER_PACK (t1) \n+              != TEMPLATE_TYPE_PARAMETER_PACK (t2)))\n \treturn false;\n       if (!comp_template_parms\n \t  (DECL_TEMPLATE_PARMS (TEMPLATE_TEMPLATE_PARM_TEMPLATE_DECL (t1)),\n@@ -1050,7 +1052,9 @@ structural_comptypes (tree t1, tree t2, int strict)\n \n     case TEMPLATE_TYPE_PARM:\n       if (TEMPLATE_TYPE_IDX (t1) != TEMPLATE_TYPE_IDX (t2)\n-\t  || TEMPLATE_TYPE_LEVEL (t1) != TEMPLATE_TYPE_LEVEL (t2))\n+\t  || TEMPLATE_TYPE_LEVEL (t1) != TEMPLATE_TYPE_LEVEL (t2)\n+          || (TEMPLATE_TYPE_PARAMETER_PACK (t1) \n+              != TEMPLATE_TYPE_PARAMETER_PACK (t2)))\n \treturn false;\n       break;\n \n@@ -1080,6 +1084,10 @@ structural_comptypes (tree t1, tree t2, int strict)\n \treturn false;\n       break;\n \n+    case TYPE_PACK_EXPANSION:\n+      return same_type_p (PACK_EXPANSION_PATTERN (t1), \n+                          PACK_EXPANSION_PATTERN (t2));\n+\n     default:\n       return false;\n     }\n@@ -6543,6 +6551,7 @@ check_return_expr (tree retval, bool *no_warning)\n   if (processing_template_decl)\n     {\n       current_function_returns_value = 1;\n+      check_for_bare_parameter_packs (retval);\n       return retval;\n     }\n "}]}