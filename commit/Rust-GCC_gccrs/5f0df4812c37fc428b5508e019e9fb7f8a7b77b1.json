{"sha": "5f0df4812c37fc428b5508e019e9fb7f8a7b77b1", "node_id": "C_kwDOANBUbNoAKDVmMGRmNDgxMmMzN2ZjNDI4YjU1MDhlMDE5ZTlmYjdmOGE3Yjc3YjE", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-11-02T13:54:14Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-11-02T13:54:14Z"}, "message": "Merge #781\n\n781: Add missing typechecking for enums r=philberty a=philberty\n\nThis PR splits up the Algebraic data type into one which can support many variants which is what an enum is.\r\nIt then changes the type checking for construction of ADT's to use the VariantDef structures as required. This\r\ndoes not fully implement but does allow us to have most of the type checking in place to start code-generation work.\r\n\r\nThis combines work from Mark Wielaard (https://code.wildebeest.org/git/user/mjw/gccrs/commit/?h=enum-type) and Philip\r\n\r\nAddresses #79 \n\nCo-authored-by: Mark Wielaard <mark@klomp.org>\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "2a2bef1a866b93287a48990c09a4243d0ab41c0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a2bef1a866b93287a48990c09a4243d0ab41c0f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhgUMGCRBK7hj4Ov3rIwAAEQwIADXwPbtli9QamAt2iP8ARMO+\nK7PzrmoNG5fEnHpFgPUcDvqQ+hKpU6igkq3nNSkWMq91KzhS135AQWqk3jcsTAgw\njLULbk0A8e4JdLM1tLM6xKh3B1zx5rR6XPL/jzvpLVwwBcp60mDKRgSGYFjGEo7U\n5grP0KKETawwA6MtBhFpmTLbRqvK/LWwB7DGgtsYhuSJiN/s0LYml2DjayX+HOwM\nmOkQwGL43qy/UOOP7Tun+HGVZ2XZOxAr7uoA7YQSpk6zY5DqEmq5JCcsXswrbQB6\nzk3mfIve8+JIle9N0NmqprJ8WAma1xvTwwoo1+5f7chrmnOo4cUqUxpSv6nEJMY=\n=6c2e\n-----END PGP SIGNATURE-----\n", "payload": "tree 2a2bef1a866b93287a48990c09a4243d0ab41c0f\nparent 09af9b16b436606fa8ced0aa6cc111555bdc3da7\nparent fc5f8d746362a42adc52e538dec248bd2992a794\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1635861254 +0000\ncommitter GitHub <noreply@github.com> 1635861254 +0000\n\nMerge #781\n\n781: Add missing typechecking for enums r=philberty a=philberty\n\nThis PR splits up the Algebraic data type into one which can support many variants which is what an enum is.\r\nIt then changes the type checking for construction of ADT's to use the VariantDef structures as required. This\r\ndoes not fully implement but does allow us to have most of the type checking in place to start code-generation work.\r\n\r\nThis combines work from Mark Wielaard (https://code.wildebeest.org/git/user/mjw/gccrs/commit/?h=enum-type) and Philip\r\n\r\nAddresses #79 \n\nCo-authored-by: Mark Wielaard <mark@klomp.org>\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "09af9b16b436606fa8ced0aa6cc111555bdc3da7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09af9b16b436606fa8ced0aa6cc111555bdc3da7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09af9b16b436606fa8ced0aa6cc111555bdc3da7"}, {"sha": "fc5f8d746362a42adc52e538dec248bd2992a794", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc5f8d746362a42adc52e538dec248bd2992a794", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc5f8d746362a42adc52e538dec248bd2992a794"}], "stats": {"total": 1725, "additions": 1204, "deletions": 521}, "files": [{"sha": "15c0a8fa85d0626a381d9b43cae87b1baf28a085", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=5f0df4812c37fc428b5508e019e9fb7f8a7b77b1", "patch": "@@ -85,6 +85,7 @@ GRS_OBJS = \\\n     rust/rust-hir-trait-resolve.o \\\n     rust/rust-hir-const-fold.o \\\n     rust/rust-hir-type-check-type.o \\\n+    rust/rust-hir-type-check-struct.o \\\n     rust/rust-lint-marklive.o \\\n     rust/rust-hir-type-check-path.o \\\n     rust/rust-compile-intrinsic.o \\"}, {"sha": "551e0413007fd0b859d3361027a6ffca1a9fcaff", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=5f0df4812c37fc428b5508e019e9fb7f8a7b77b1", "patch": "@@ -431,10 +431,15 @@ class TyTyResolveCompile : public TyTy::TyConstVisitor\n     if (ctx->lookup_compiled_types (type.get_ty_ref (), &translated, &type))\n       return;\n \n+    // we dont support enums yet\n+    rust_assert (!type.is_enum ());\n+    rust_assert (type.number_of_variants () == 1);\n+\n+    TyTy::VariantDef &variant = *type.get_variants ().at (0);\n     std::vector<Backend::Btyped_identifier> fields;\n-    for (size_t i = 0; i < type.num_fields (); i++)\n+    for (size_t i = 0; i < variant.num_fields (); i++)\n       {\n-\tconst TyTy::StructFieldType *field = type.get_field (i);\n+\tconst TyTy::StructFieldType *field = variant.get_field_at_index (i);\n \tBtype *compiled_field_ty\n \t  = TyTyResolveCompile::compile (ctx, field->get_field_type ());\n "}, {"sha": "f43db501a56dace25892ef6ee74430334a0ee127", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=5f0df4812c37fc428b5508e019e9fb7f8a7b77b1", "patch": "@@ -698,7 +698,13 @@ class CompileExpr : public HIRCompileBase\n     if (receiver->get_kind () == TyTy::TypeKind::ADT)\n       {\n \tTyTy::ADTType *adt = static_cast<TyTy::ADTType *> (receiver);\n-\tadt->get_field (expr.get_field_name (), &field_index);\n+\trust_assert (!adt->is_enum ());\n+\trust_assert (adt->number_of_variants () == 1);\n+\n+\tTyTy::VariantDef *variant = adt->get_variants ().at (0);\n+\tbool ok = variant->lookup_field (expr.get_field_name (), nullptr,\n+\t\t\t\t\t &field_index);\n+\trust_assert (ok);\n       }\n     else if (receiver->get_kind () == TyTy::TypeKind::REF)\n       {\n@@ -707,9 +713,15 @@ class CompileExpr : public HIRCompileBase\n \trust_assert (b->get_kind () == TyTy::TypeKind::ADT);\n \n \tTyTy::ADTType *adt = static_cast<TyTy::ADTType *> (b);\n-\tadt->get_field (expr.get_field_name (), &field_index);\n-\tBtype *adt_tyty = TyTyResolveCompile::compile (ctx, adt);\n+\trust_assert (!adt->is_enum ());\n+\trust_assert (adt->number_of_variants () == 1);\n \n+\tTyTy::VariantDef *variant = adt->get_variants ().at (0);\n+\tbool ok = variant->lookup_field (expr.get_field_name (), nullptr,\n+\t\t\t\t\t &field_index);\n+\trust_assert (ok);\n+\n+\tBtype *adt_tyty = TyTyResolveCompile::compile (ctx, adt);\n \tBexpression *indirect\n \t  = ctx->get_backend ()->indirect_expression (adt_tyty, receiver_ref,\n \t\t\t\t\t\t      true, expr.get_locus ());"}, {"sha": "a5d32b191d31b829c4c6502e5351738042df333d", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=5f0df4812c37fc428b5508e019e9fb7f8a7b77b1", "patch": "@@ -73,6 +73,10 @@ CompileExpr::visit (HIR::CallExpr &expr)\n       TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (tyty);\n       Btype *compiled_adt_type = TyTyResolveCompile::compile (ctx, tyty);\n \n+      rust_assert (!adt->is_enum ());\n+      rust_assert (adt->number_of_variants () == 1);\n+      auto variant = adt->get_variants ().at (0);\n+\n       // this assumes all fields are in order from type resolution and if a\n       // base struct was specified those fields are filed via accesors\n       std::vector<Bexpression *> vals;\n@@ -83,7 +87,7 @@ CompileExpr::visit (HIR::CallExpr &expr)\n \n \t  // assignments are coercion sites so lets convert the rvalue if\n \t  // necessary\n-\t  auto respective_field = adt->get_field (i);\n+\t  auto respective_field = variant->get_field_at_index (i);\n \t  auto expected = respective_field->get_field_type ();\n \n \t  TyTy::BaseType *actual = nullptr;"}, {"sha": "c5a8d06a3da1c577d2aa7804068f1b1a672e4d9d", "filename": "gcc/rust/hir/tree/rust-hir-item.h", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h?ref=5f0df4812c37fc428b5508e019e9fb7f8a7b77b1", "patch": "@@ -1694,12 +1694,12 @@ class EnumItem : public Item\n     return std::unique_ptr<EnumItem> (clone_item_impl ());\n   }\n \n-  virtual std::string as_string () const;\n+  virtual std::string as_string () const override;\n \n   // not pure virtual as not abstract\n-  virtual void accept_vis (HIRVisitor &vis);\n+  virtual void accept_vis (HIRVisitor &vis) override;\n \n-  Location get_locus () const { return locus; }\n+  Location get_locus () const override { return locus; }\n \n   Identifier get_identifier () const { return variant_name; }\n \n@@ -1729,6 +1729,8 @@ class EnumItemTuple : public EnumItem\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  std::vector<TupleField> &get_tuple_fields () { return tuple_fields; }\n+\n protected:\n   // Clone function implementation as (not pure) virtual method\n   EnumItemTuple *clone_item_impl () const override\n@@ -1759,6 +1761,8 @@ class EnumItemStruct : public EnumItem\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  std::vector<StructField> &get_struct_fields () { return struct_fields; }\n+\n protected:\n   // Clone function implementation as (not pure) virtual method\n   EnumItemStruct *clone_item_impl () const override\n@@ -1805,6 +1809,8 @@ class EnumItemDiscriminant : public EnumItem\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  std::unique_ptr<Expr> &get_discriminant_expression () { return expression; }\n+\n protected:\n   // Clone function implementation as (not pure) virtual method\n   EnumItemDiscriminant *clone_item_impl () const override\n@@ -1899,6 +1905,16 @@ class Enum : public VisItem\n \n   Identifier get_identifier () const { return enum_name; }\n \n+  std::vector<std::unique_ptr<GenericParam>> &get_generic_params ()\n+  {\n+    return generic_params;\n+  }\n+\n+  const std::vector<std::unique_ptr<EnumItem>> &get_variants () const\n+  {\n+    return items;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n@@ -1989,14 +2005,7 @@ class Union : public VisItem\n \n   void accept_vis (HIRVisitor &vis) override;\n \n-  void iterate (std::function<bool (StructField &)> cb)\n-  {\n-    for (auto &variant : variants)\n-      {\n-\tif (!cb (variant))\n-\t  return;\n-      }\n-  }\n+  std::vector<StructField> &get_variants () { return variants; }\n \n   WhereClause &get_where_clause () { return where_clause; }\n "}, {"sha": "d7977b4f6f6dd3a4e0688d9ced9845c00e2740ac", "filename": "gcc/rust/hir/tree/rust-hir.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h?ref=5f0df4812c37fc428b5508e019e9fb7f8a7b77b1", "patch": "@@ -127,7 +127,7 @@ class Item : public Stmt\n     return std::unique_ptr<Item> (clone_item_impl ());\n   }\n \n-  std::string as_string () const;\n+  std::string as_string () const override;\n \n   /* Adds crate names to the vector passed by reference, if it can\n    * (polymorphism). */"}, {"sha": "ef207bc9d68ccc7fa7a55da8af0f786e8490299d", "filename": "gcc/rust/lint/rust-lint-marklive.cc", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Frust%2Flint%2Frust-lint-marklive.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Frust%2Flint%2Frust-lint-marklive.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flint%2Frust-lint-marklive.cc?ref=5f0df4812c37fc428b5508e019e9fb7f8a7b77b1", "patch": "@@ -228,11 +228,17 @@ MarkLive::visit (HIR::FieldAccessExpr &expr)\n     }\n \n   rust_assert (adt != nullptr);\n+  rust_assert (!adt->is_enum ());\n+  rust_assert (adt->number_of_variants () == 1);\n+\n+  TyTy::VariantDef *variant = adt->get_variants ().at (0);\n \n   // get the field index\n-  size_t index = 0;\n-  adt->get_field (expr.get_field_name (), &index);\n-  if (index >= adt->num_fields ())\n+  size_t index;\n+  TyTy::StructFieldType *field;\n+  bool ok = variant->lookup_field (expr.get_field_name (), &field, &index);\n+  rust_assert (ok);\n+  if (index >= variant->num_fields ())\n     {\n       rust_error_at (expr.get_receiver_expr ()->get_locus (),\n \t\t     \"cannot access struct %s by index: %ld\",\n@@ -241,7 +247,7 @@ MarkLive::visit (HIR::FieldAccessExpr &expr)\n     }\n \n   // get the field hir id\n-  HirId field_id = adt->get_field (index)->get_ref ();\n+  HirId field_id = field->get_ref ();\n   mark_hir_id (field_id);\n }\n "}, {"sha": "d318b9cc7676501df37980191467a464ec924578", "filename": "gcc/rust/typecheck/rust-hir-path-probe.h", "status": "modified", "additions": 48, "deletions": 23, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h?ref=5f0df4812c37fc428b5508e019e9fb7f8a7b77b1", "patch": "@@ -32,6 +32,8 @@ struct PathProbeCandidate\n {\n   enum CandidateType\n   {\n+    ENUM_VARIANT,\n+\n     IMPL_CONST,\n     IMPL_TYPE_ALIAS,\n     IMPL_FUNC,\n@@ -41,6 +43,12 @@ struct PathProbeCandidate\n     TRAIT_FUNC,\n   };\n \n+  struct EnumItemCandidate\n+  {\n+    const TyTy::ADTType *parent;\n+    const TyTy::VariantDef *variant;\n+  };\n+\n   struct ImplItemCandidate\n   {\n     HIR::ImplItem *impl_item;\n@@ -59,13 +67,20 @@ struct PathProbeCandidate\n   Location locus;\n   union Candidate\n   {\n+    EnumItemCandidate enum_field;\n     ImplItemCandidate impl;\n     TraitItemCandidate trait;\n \n+    Candidate (EnumItemCandidate enum_field) : enum_field (enum_field) {}\n     Candidate (ImplItemCandidate impl) : impl (impl) {}\n     Candidate (TraitItemCandidate trait) : trait (trait) {}\n   } item;\n \n+  PathProbeCandidate (CandidateType type, TyTy::BaseType *ty, Location locus,\n+\t\t      EnumItemCandidate enum_field)\n+    : type (type), ty (ty), item (enum_field)\n+  {}\n+\n   PathProbeCandidate (CandidateType type, TyTy::BaseType *ty, Location locus,\n \t\t      ImplItemCandidate impl)\n     : type (type), ty (ty), item (impl)\n@@ -81,34 +96,17 @@ struct PathProbeCandidate\n     return \"PathProbe candidate TODO - as_string\";\n   }\n \n+  bool is_enum_candidate () const { return type == ENUM_VARIANT; }\n+\n   bool is_impl_candidate () const\n   {\n-    switch (type)\n-      {\n-      case IMPL_CONST:\n-      case IMPL_TYPE_ALIAS:\n-      case IMPL_FUNC:\n-\treturn true;\n-\n-      default:\n-\treturn false;\n-      }\n-    gcc_unreachable ();\n+    return type == IMPL_CONST || type == IMPL_TYPE_ALIAS || type == IMPL_FUNC;\n   }\n \n   bool is_trait_candidate () const\n   {\n-    switch (type)\n-      {\n-      case TRAIT_ITEM_CONST:\n-      case TRAIT_TYPE_ALIAS:\n-      case TRAIT_FUNC:\n-\treturn true;\n-\n-      default:\n-\treturn false;\n-      }\n-    gcc_unreachable ();\n+    return type == TRAIT_ITEM_CONST || type == TRAIT_TYPE_ALIAS\n+\t   || type == TRAIT_FUNC;\n   }\n };\n \n@@ -125,7 +123,17 @@ class PathProbeType : public TypeCheckBase\n   {\n     PathProbeType probe (receiver, segment_name);\n     if (probe_impls)\n-      probe.process_impl_items_for_candidates ();\n+      {\n+\tif (receiver->get_kind () == TyTy::TypeKind::ADT)\n+\t  {\n+\t    const TyTy::ADTType *adt\n+\t      = static_cast<const TyTy::ADTType *> (receiver);\n+\t    if (adt->is_enum ())\n+\t      probe.process_enum_item_for_candiates (adt);\n+\t  }\n+\n+\tprobe.process_impl_items_for_candidates ();\n+      }\n \n     if (!probe_bounds)\n       return probe.candidates;\n@@ -211,6 +219,19 @@ class PathProbeType : public TypeCheckBase\n   }\n \n protected:\n+  void process_enum_item_for_candiates (const TyTy::ADTType *adt)\n+  {\n+    TyTy::VariantDef *v;\n+    if (!adt->lookup_variant (search.as_string (), &v))\n+      return;\n+\n+    PathProbeCandidate::EnumItemCandidate enum_item_candidate{adt, v};\n+    PathProbeCandidate candidate{\n+      PathProbeCandidate::CandidateType::ENUM_VARIANT, receiver->clone (),\n+      mappings->lookup_location (adt->get_ty_ref ()), enum_item_candidate};\n+    candidates.push_back (std::move (candidate));\n+  }\n+\n   void process_impl_items_for_candidates ()\n   {\n     mappings->iterate_impl_items ([&] (HirId id, HIR::ImplItem *item,\n@@ -422,6 +443,10 @@ class ReportMultipleCandidateError : private TypeCheckBase\n       {\n \tswitch (c.type)\n \t  {\n+\t  case PathProbeCandidate::CandidateType::ENUM_VARIANT:\n+\t    gcc_unreachable ();\n+\t    break;\n+\n \t  case PathProbeCandidate::CandidateType::IMPL_CONST:\n \t  case PathProbeCandidate::CandidateType::IMPL_TYPE_ALIAS:\n \t  case PathProbeCandidate::CandidateType::IMPL_FUNC:"}, {"sha": "e4dcaeb2326c1e358112316c1986beb9a06a44fe", "filename": "gcc/rust/typecheck/rust-hir-type-check-enumitem.h", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-enumitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-enumitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-enumitem.h?ref=5f0df4812c37fc428b5508e019e9fb7f8a7b77b1", "patch": "@@ -0,0 +1,153 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_TYPE_CHECK_ENUMITEM\n+#define RUST_HIR_TYPE_CHECK_ENUMITEM\n+\n+#include \"rust-hir-type-check-base.h\"\n+#include \"rust-hir-full.h\"\n+#include \"rust-hir-type-check-type.h\"\n+#include \"rust-hir-type-check-expr.h\"\n+\n+extern ::Backend *\n+rust_get_backend ();\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class TypeCheckEnumItem : public TypeCheckBase\n+{\n+  using Rust::Resolver::TypeCheckBase::visit;\n+\n+public:\n+  static TyTy::VariantDef *Resolve (HIR::EnumItem *item,\n+\t\t\t\t    int64_t last_discriminant)\n+  {\n+    TypeCheckEnumItem resolver (last_discriminant);\n+    item->accept_vis (resolver);\n+    return resolver.variant;\n+  }\n+\n+  void visit (HIR::EnumItem &item) override\n+  {\n+    if (last_discriminant == INT64_MAX)\n+      rust_error_at (item.get_locus (), \"discriminant too big\");\n+\n+    variant\n+      = new TyTy::VariantDef (item.get_mappings ().get_hirid (),\n+\t\t\t      item.get_identifier (), last_discriminant + 1);\n+  }\n+\n+  void visit (HIR::EnumItemDiscriminant &item) override\n+  {\n+    if (last_discriminant == INT64_MAX)\n+      rust_error_at (item.get_locus (), \"discriminant too big\");\n+\n+    auto &discriminant = item.get_discriminant_expression ();\n+    auto capacity_type = TypeCheckExpr::Resolve (discriminant.get (), false);\n+    if (capacity_type->get_kind () == TyTy::TypeKind::ERROR)\n+      return;\n+\n+    TyTy::USizeType *expected_ty\n+      = new TyTy::USizeType (discriminant->get_mappings ().get_hirid ());\n+    context->insert_type (discriminant->get_mappings (), expected_ty);\n+\n+    auto unified = expected_ty->unify (capacity_type);\n+    if (unified->get_kind () == TyTy::TypeKind::ERROR)\n+      return;\n+\n+    auto backend = rust_get_backend ();\n+    auto folded_discriminant\n+      = ConstFold::ConstFoldExpr::fold (discriminant.get ());\n+    if (folded_discriminant == nullptr\n+\t|| backend->is_error_expression (folded_discriminant))\n+      return;\n+\n+    size_t specified_discriminant;\n+    bool ok\n+      = backend->const_size_cast (folded_discriminant, &specified_discriminant);\n+    rust_assert (ok);\n+\n+    variant\n+      = new TyTy::VariantDef (item.get_mappings ().get_hirid (),\n+\t\t\t      item.get_identifier (), specified_discriminant);\n+  }\n+\n+  void visit (HIR::EnumItemTuple &item) override\n+  {\n+    if (last_discriminant == INT64_MAX)\n+      rust_error_at (item.get_locus (), \"discriminant too big\");\n+\n+    std::vector<TyTy::StructFieldType *> fields;\n+    size_t idx = 0;\n+    for (auto &field : item.get_tuple_fields ())\n+      {\n+\tTyTy::BaseType *field_type\n+\t  = TypeCheckType::Resolve (field.get_field_type ().get ());\n+\tTyTy::StructFieldType *ty_field\n+\t  = new TyTy::StructFieldType (field.get_mappings ().get_hirid (),\n+\t\t\t\t       std::to_string (idx), field_type);\n+\tfields.push_back (ty_field);\n+\tcontext->insert_type (field.get_mappings (),\n+\t\t\t      ty_field->get_field_type ());\n+\tidx++;\n+      }\n+\n+    variant\n+      = new TyTy::VariantDef (item.get_mappings ().get_hirid (),\n+\t\t\t      item.get_identifier (),\n+\t\t\t      TyTy::VariantDef::VariantType::TUPLE, fields);\n+  }\n+\n+  void visit (HIR::EnumItemStruct &item) override\n+  {\n+    if (last_discriminant == INT64_MAX)\n+      rust_error_at (item.get_locus (), \"discriminant too big\");\n+\n+    std::vector<TyTy::StructFieldType *> fields;\n+    for (auto &field : item.get_struct_fields ())\n+      {\n+\tTyTy::BaseType *field_type\n+\t  = TypeCheckType::Resolve (field.get_field_type ().get ());\n+\tTyTy::StructFieldType *ty_field\n+\t  = new TyTy::StructFieldType (field.get_mappings ().get_hirid (),\n+\t\t\t\t       field.get_field_name (), field_type);\n+\tfields.push_back (ty_field);\n+\tcontext->insert_type (field.get_mappings (),\n+\t\t\t      ty_field->get_field_type ());\n+      }\n+\n+    variant\n+      = new TyTy::VariantDef (item.get_mappings ().get_hirid (),\n+\t\t\t      item.get_identifier (),\n+\t\t\t      TyTy::VariantDef::VariantType::STRUCT, fields);\n+  }\n+\n+private:\n+  TypeCheckEnumItem (int64_t last_discriminant)\n+    : TypeCheckBase (), variant (nullptr), last_discriminant (last_discriminant)\n+  {}\n+\n+  TyTy::VariantDef *variant;\n+  int64_t last_discriminant;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_HIR_TYPE_CHECK_ENUMITEM"}, {"sha": "2a6bae9ca7d26c76f8514d0106e673d633d515bc", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 43, "deletions": 6, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=5f0df4812c37fc428b5508e019e9fb7f8a7b77b1", "patch": "@@ -113,14 +113,18 @@ class TypeCheckExpr : public TypeCheckBase\n       }\n \n     TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (resolved);\n+    rust_assert (!adt->is_enum ());\n+    rust_assert (adt->number_of_variants () == 1);\n+\n+    TyTy::VariantDef *variant = adt->get_variants ().at (0);\n     TupleIndex index = expr.get_tuple_index ();\n-    if ((size_t) index >= adt->num_fields ())\n+    if ((size_t) index >= variant->num_fields ())\n       {\n \trust_error_at (expr.get_locus (), \"unknown field at index %i\", index);\n \treturn;\n       }\n \n-    auto field_tyty = adt->get_field ((size_t) index);\n+    auto field_tyty = variant->get_field_at_index ((size_t) index);\n     if (field_tyty == nullptr)\n       {\n \trust_error_at (expr.get_locus (),\n@@ -194,7 +198,33 @@ class TypeCheckExpr : public TypeCheckBase\n \treturn;\n       }\n \n-    infered = TyTy::TypeCheckCallExpr::go (function_tyty, expr, context);\n+    TyTy::VariantDef &variant = TyTy::VariantDef::get_error_node ();\n+    if (function_tyty->get_kind () == TyTy::TypeKind::ADT)\n+      {\n+\tTyTy::ADTType *adt = static_cast<TyTy::ADTType *> (function_tyty);\n+\tif (adt->is_enum ())\n+\t  {\n+\t    // lookup variant id\n+\t    HirId variant_id;\n+\t    bool ok = context->lookup_variant_definition (\n+\t      expr.get_fnexpr ()->get_mappings ().get_hirid (), &variant_id);\n+\t    rust_assert (ok);\n+\n+\t    TyTy::VariantDef *lookup_variant = nullptr;\n+\t    ok = adt->lookup_variant_by_id (variant_id, &lookup_variant);\n+\t    rust_assert (ok);\n+\n+\t    variant = *lookup_variant;\n+\t  }\n+\telse\n+\t  {\n+\t    rust_assert (adt->number_of_variants () == 1);\n+\t    variant = *adt->get_variants ().at (0);\n+\t  }\n+      }\n+\n+    infered\n+      = TyTy::TypeCheckCallExpr::go (function_tyty, expr, variant, context);\n     if (infered == nullptr)\n       {\n \trust_error_at (expr.get_locus (), \"failed to lookup type to CallExpr\");\n@@ -984,16 +1014,23 @@ class TypeCheckExpr : public TypeCheckBase\n       }\n \n     TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (struct_base);\n-    auto resolved = adt->get_field (expr.get_field_name ());\n-    if (resolved == nullptr)\n+    rust_assert (!adt->is_enum ());\n+    rust_assert (adt->number_of_variants () == 1);\n+\n+    TyTy::VariantDef *vaiant = adt->get_variants ().at (0);\n+\n+    TyTy::StructFieldType *lookup = nullptr;\n+    bool found\n+      = vaiant->lookup_field (expr.get_field_name (), &lookup, nullptr);\n+    if (!found)\n       {\n \trust_error_at (expr.get_locus (), \"unknown field [%s] for type [%s]\",\n \t\t       expr.get_field_name ().c_str (),\n \t\t       adt->as_string ().c_str ());\n \treturn;\n       }\n \n-    infered = resolved->get_field_type ();\n+    infered = lookup->get_field_type ();\n   }\n \n   void visit (HIR::QualifiedPathInExpression &expr) override;"}, {"sha": "8aa4484f62816eb744bcf95c586eeb55b1ccd81f", "filename": "gcc/rust/typecheck/rust-hir-type-check-path.cc", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc?ref=5f0df4812c37fc428b5508e019e9fb7f8a7b77b1", "patch": "@@ -359,7 +359,24 @@ TypeCheckExpr::resolve_segments (NodeId root_resolved_node_id,\n       prev_segment = tyseg;\n       tyseg = candidate.ty;\n \n-      if (candidate.is_impl_candidate ())\n+      if (candidate.is_enum_candidate ())\n+\t{\n+\t  const TyTy::VariantDef *variant = candidate.item.enum_field.variant;\n+\n+\t  CrateNum crate_num = mappings->get_current_crate ();\n+\t  HirId variant_id = variant->get_id ();\n+\n+\t  HIR::Item *enum_item\n+\t    = mappings->lookup_hir_item (crate_num, variant_id);\n+\t  rust_assert (enum_item != nullptr);\n+\n+\t  resolved_node_id = enum_item->get_mappings ().get_nodeid ();\n+\n+\t  // insert the id of the variant we are resolved to\n+\t  context->insert_variant_definition (expr_mappings.get_hirid (),\n+\t\t\t\t\t      variant_id);\n+\t}\n+      else if (candidate.is_impl_candidate ())\n \t{\n \t  resolved_node_id\n \t    = candidate.item.impl.impl_item->get_impl_mappings ().get_nodeid ();"}, {"sha": "8df43d9a336f574965cbac82485b03dd7c8462a7", "filename": "gcc/rust/typecheck/rust-hir-type-check-stmt.h", "status": "modified", "additions": 85, "deletions": 15, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h?ref=5f0df4812c37fc428b5508e019e9fb7f8a7b77b1", "patch": "@@ -23,6 +23,7 @@\n #include \"rust-hir-full.h\"\n #include \"rust-hir-type-check-type.h\"\n #include \"rust-hir-type-check-expr.h\"\n+#include \"rust-hir-type-check-enumitem.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -155,7 +156,6 @@ class TypeCheckStmt : public TypeCheckBase\n       }\n \n     std::vector<TyTy::StructFieldType *> fields;\n-\n     size_t idx = 0;\n     for (auto &field : struct_decl.get_fields ())\n       {\n@@ -170,17 +170,75 @@ class TypeCheckStmt : public TypeCheckBase\n \tidx++;\n       }\n \n+    // there is only a single variant\n+    std::vector<TyTy::VariantDef *> variants;\n+    variants.push_back (new TyTy::VariantDef (\n+      struct_decl.get_mappings ().get_hirid (), struct_decl.get_identifier (),\n+      TyTy::VariantDef::VariantType::TUPLE, std::move (fields)));\n+\n     TyTy::BaseType *type\n       = new TyTy::ADTType (struct_decl.get_mappings ().get_hirid (),\n \t\t\t   mappings->get_next_hir_id (),\n \t\t\t   struct_decl.get_identifier (),\n \t\t\t   TyTy::ADTType::ADTKind::TUPLE_STRUCT,\n-\t\t\t   std::move (fields), std::move (substitutions));\n+\t\t\t   std::move (variants), std::move (substitutions));\n \n     context->insert_type (struct_decl.get_mappings (), type);\n     infered = type;\n   }\n \n+  void visit (HIR::Enum &enum_decl) override\n+  {\n+    std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+    if (enum_decl.has_generics ())\n+      {\n+\tfor (auto &generic_param : enum_decl.get_generic_params ())\n+\t  {\n+\t    switch (generic_param.get ()->get_kind ())\n+\t      {\n+\t      case HIR::GenericParam::GenericKind::LIFETIME:\n+\t\t// Skipping Lifetime completely until better handling.\n+\t\tbreak;\n+\n+\t\tcase HIR::GenericParam::GenericKind::TYPE: {\n+\t\t  auto param_type\n+\t\t    = TypeResolveGenericParam::Resolve (generic_param.get ());\n+\t\t  context->insert_type (generic_param->get_mappings (),\n+\t\t\t\t\tparam_type);\n+\n+\t\t  substitutions.push_back (TyTy::SubstitutionParamMapping (\n+\t\t    static_cast<HIR::TypeParam &> (*generic_param),\n+\t\t    param_type));\n+\t\t}\n+\t\tbreak;\n+\t      }\n+\t  }\n+      }\n+\n+    std::vector<TyTy::VariantDef *> variants;\n+    int64_t discriminant_value = 0;\n+    for (auto &variant : enum_decl.get_variants ())\n+      {\n+\tTyTy::VariantDef *field_type\n+\t  = TypeCheckEnumItem::Resolve (variant.get (), discriminant_value);\n+\n+\tvariants.push_back (field_type);\n+\tif (field_type->get_variant_type ()\n+\t    == TyTy::VariantDef::VariantType::NUM)\n+\t  discriminant_value = field_type->get_discriminant ();\n+      }\n+\n+    TyTy::BaseType *type\n+      = new TyTy::ADTType (enum_decl.get_mappings ().get_hirid (),\n+\t\t\t   mappings->get_next_hir_id (),\n+\t\t\t   enum_decl.get_identifier (),\n+\t\t\t   TyTy::ADTType::ADTKind::ENUM, std::move (variants),\n+\t\t\t   std::move (substitutions));\n+\n+    context->insert_type (enum_decl.get_mappings (), type);\n+    infered = type;\n+  }\n+\n   void visit (HIR::StructStruct &struct_decl) override\n   {\n     std::vector<TyTy::SubstitutionParamMapping> substitutions;\n@@ -222,12 +280,18 @@ class TypeCheckStmt : public TypeCheckBase\n \t\t\t      ty_field->get_field_type ());\n       }\n \n+    // there is only a single variant\n+    std::vector<TyTy::VariantDef *> variants;\n+    variants.push_back (new TyTy::VariantDef (\n+      struct_decl.get_mappings ().get_hirid (), struct_decl.get_identifier (),\n+      TyTy::VariantDef::VariantType::STRUCT, std::move (fields)));\n+\n     TyTy::BaseType *type\n       = new TyTy::ADTType (struct_decl.get_mappings ().get_hirid (),\n \t\t\t   mappings->get_next_hir_id (),\n \t\t\t   struct_decl.get_identifier (),\n \t\t\t   TyTy::ADTType::ADTKind::STRUCT_STRUCT,\n-\t\t\t   std::move (fields), std::move (substitutions));\n+\t\t\t   std::move (variants), std::move (substitutions));\n \n     context->insert_type (struct_decl.get_mappings (), type);\n     infered = type;\n@@ -261,18 +325,24 @@ class TypeCheckStmt : public TypeCheckBase\n \t  }\n       }\n \n-    std::vector<TyTy::StructFieldType *> variants;\n-    union_decl.iterate ([&] (HIR::StructField &variant) mutable -> bool {\n-      TyTy::BaseType *variant_type\n-\t= TypeCheckType::Resolve (variant.get_field_type ().get ());\n-      TyTy::StructFieldType *ty_variant\n-\t= new TyTy::StructFieldType (variant.get_mappings ().get_hirid (),\n-\t\t\t\t     variant.get_field_name (), variant_type);\n-      variants.push_back (ty_variant);\n-      context->insert_type (variant.get_mappings (),\n-\t\t\t    ty_variant->get_field_type ());\n-      return true;\n-    });\n+    std::vector<TyTy::StructFieldType *> fields;\n+    for (auto &variant : union_decl.get_variants ())\n+      {\n+\tTyTy::BaseType *variant_type\n+\t  = TypeCheckType::Resolve (variant.get_field_type ().get ());\n+\tTyTy::StructFieldType *ty_variant\n+\t  = new TyTy::StructFieldType (variant.get_mappings ().get_hirid (),\n+\t\t\t\t       variant.get_field_name (), variant_type);\n+\tfields.push_back (ty_variant);\n+\tcontext->insert_type (variant.get_mappings (),\n+\t\t\t      ty_variant->get_field_type ());\n+      }\n+\n+    // there is only a single variant\n+    std::vector<TyTy::VariantDef *> variants;\n+    variants.push_back (new TyTy::VariantDef (\n+      union_decl.get_mappings ().get_hirid (), union_decl.get_identifier (),\n+      TyTy::VariantDef::VariantType::STRUCT, std::move (fields)));\n \n     TyTy::BaseType *type\n       = new TyTy::ADTType (union_decl.get_mappings ().get_hirid (),"}, {"sha": "4c4b128fc98bf6903736ccfceaaf39fcf552999e", "filename": "gcc/rust/typecheck/rust-hir-type-check-struct-field.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct-field.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct-field.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct-field.h?ref=5f0df4812c37fc428b5508e019e9fb7f8a7b77b1", "patch": "@@ -51,14 +51,16 @@ class TypeCheckStructExpr : public TypeCheckBase\n   TypeCheckStructExpr (HIR::Expr *e)\n     : TypeCheckBase (),\n       resolved (new TyTy::ErrorType (e->get_mappings ().get_hirid ())),\n-      struct_path_resolved (nullptr)\n+      struct_path_resolved (nullptr),\n+      variant (&TyTy::VariantDef::get_error_node ())\n   {}\n \n   // result\n   TyTy::BaseType *resolved;\n \n   // internal state:\n   TyTy::ADTType *struct_path_resolved;\n+  TyTy::VariantDef *variant;\n   TyTy::BaseType *resolved_field_value_expr;\n   std::set<std::string> fields_assigned;\n   std::map<size_t, HIR::StructExprField *> adtFieldIndexToField;"}, {"sha": "78340c3f1824a18ce68cef539c61d91fcd8e03f7", "filename": "gcc/rust/typecheck/rust-hir-type-check-struct.cc", "status": "added", "additions": 298, "deletions": 0, "changes": 298, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct.cc?ref=5f0df4812c37fc428b5508e019e9fb7f8a7b77b1", "patch": "@@ -0,0 +1,298 @@\n+// Copyright (C) 2020-2021 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-type-check.h\"\n+#include \"rust-hir-full.h\"\n+#include \"rust-hir-type-check-expr.h\"\n+#include \"rust-hir-type-check-struct-field.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+void\n+TypeCheckStructExpr::visit (HIR::StructExprStructFields &struct_expr)\n+{\n+  TyTy::BaseType *struct_path_ty\n+    = TypeCheckExpr::Resolve (&struct_expr.get_struct_name (), false);\n+  if (struct_path_ty->get_kind () != TyTy::TypeKind::ADT)\n+    {\n+      rust_error_at (struct_expr.get_struct_name ().get_locus (),\n+\t\t     \"expected an ADT type for constructor\");\n+      return;\n+    }\n+\n+  struct_path_resolved = static_cast<TyTy::ADTType *> (struct_path_ty);\n+  TyTy::ADTType *struct_def = struct_path_resolved;\n+  if (struct_expr.has_struct_base ())\n+    {\n+      TyTy::BaseType *base_resolved\n+\t= TypeCheckExpr::Resolve (struct_expr.struct_base->base_struct.get (),\n+\t\t\t\t  false);\n+      struct_def\n+\t= (TyTy::ADTType *) struct_path_resolved->unify (base_resolved);\n+      if (struct_def == nullptr)\n+\t{\n+\t  rust_fatal_error (struct_expr.struct_base->base_struct->get_locus (),\n+\t\t\t    \"incompatible types for base struct reference\");\n+\t  return;\n+\t}\n+    }\n+\n+  // figure out the variant\n+  if (struct_path_resolved->is_enum ())\n+    {\n+      // lookup variant id\n+      HirId variant_id;\n+      bool ok = context->lookup_variant_definition (\n+\tstruct_expr.get_struct_name ().get_mappings ().get_hirid (),\n+\t&variant_id);\n+      rust_assert (ok);\n+\n+      ok = struct_path_resolved->lookup_variant_by_id (variant_id, &variant);\n+      rust_assert (ok);\n+    }\n+  else\n+    {\n+      rust_assert (struct_path_resolved->number_of_variants () == 1);\n+      variant = struct_path_resolved->get_variants ().at (0);\n+    }\n+\n+  std::vector<TyTy::StructFieldType *> infered_fields;\n+  bool ok = true;\n+\n+  for (auto &field : struct_expr.get_fields ())\n+    {\n+      resolved_field_value_expr = nullptr;\n+      field->accept_vis (*this);\n+      if (resolved_field_value_expr == nullptr)\n+\t{\n+\t  rust_fatal_error (field->get_locus (),\n+\t\t\t    \"failed to resolve type for field\");\n+\t  ok = false;\n+\t  break;\n+\t}\n+\n+      context->insert_type (field->get_mappings (), resolved_field_value_expr);\n+    }\n+\n+  // something failed setting up the fields\n+  if (!ok)\n+    {\n+      rust_error_at (struct_expr.get_locus (),\n+\t\t     \"constructor type resolution failure\");\n+      return;\n+    }\n+\n+  // check the arguments are all assigned and fix up the ordering\n+  if (fields_assigned.size () != variant->num_fields ())\n+    {\n+      if (struct_def->is_union ())\n+\t{\n+\t  if (fields_assigned.size () != 1 || struct_expr.has_struct_base ())\n+\t    {\n+\t      rust_error_at (\n+\t\tstruct_expr.get_locus (),\n+\t\t\"union must have exactly one field variant assigned\");\n+\t      return;\n+\t    }\n+\t}\n+      else if (!struct_expr.has_struct_base ())\n+\t{\n+\t  rust_error_at (struct_expr.get_locus (),\n+\t\t\t \"constructor is missing fields\");\n+\t  return;\n+\t}\n+      else\n+\t{\n+\t  // we have a struct base to assign the missing fields from.\n+\t  // the missing fields can be implicit FieldAccessExprs for the value\n+\t  std::set<std::string> missing_fields;\n+\t  for (auto &field : variant->get_fields ())\n+\t    {\n+\t      auto it = fields_assigned.find (field->get_name ());\n+\t      if (it == fields_assigned.end ())\n+\t\tmissing_fields.insert (field->get_name ());\n+\t    }\n+\n+\t  // we can generate FieldAccessExpr or TupleAccessExpr for the\n+\t  // values of the missing fields.\n+\t  for (auto &missing : missing_fields)\n+\t    {\n+\t      HIR::Expr *receiver\n+\t\t= struct_expr.struct_base->base_struct->clone_expr_impl ();\n+\n+\t      HIR::StructExprField *implicit_field = nullptr;\n+\n+\t      AST::AttrVec outer_attribs;\n+\t      auto crate_num = mappings->get_current_crate ();\n+\t      Analysis::NodeMapping mapping (\n+\t\tcrate_num,\n+\t\tstruct_expr.struct_base->base_struct->get_mappings ()\n+\t\t  .get_nodeid (),\n+\t\tmappings->get_next_hir_id (crate_num), UNKNOWN_LOCAL_DEFID);\n+\n+\t      HIR::Expr *field_value = new HIR::FieldAccessExpr (\n+\t\tmapping, std::unique_ptr<HIR::Expr> (receiver), missing,\n+\t\tstd::move (outer_attribs),\n+\t\tstruct_expr.struct_base->base_struct->get_locus ());\n+\n+\t      implicit_field = new HIR::StructExprFieldIdentifierValue (\n+\t\tmapping, missing, std::unique_ptr<HIR::Expr> (field_value),\n+\t\tstruct_expr.struct_base->base_struct->get_locus ());\n+\n+\t      size_t field_index;\n+\t      bool ok = variant->lookup_field (missing, nullptr, &field_index);\n+\t      rust_assert (ok);\n+\n+\t      adtFieldIndexToField[field_index] = implicit_field;\n+\t      struct_expr.get_fields ().push_back (\n+\t\tstd::unique_ptr<HIR::StructExprField> (implicit_field));\n+\t    }\n+\t}\n+    }\n+\n+  if (struct_def->is_union ())\n+    {\n+      // There is exactly one field in this constructor, we need to\n+      // figure out the field index to make sure we initialize the\n+      // right union field.\n+      for (size_t i = 0; i < adtFieldIndexToField.size (); i++)\n+\t{\n+\t  if (adtFieldIndexToField[i])\n+\t    {\n+\t      struct_expr.union_index = i;\n+\t      break;\n+\t    }\n+\t}\n+      rust_assert (struct_expr.union_index != -1);\n+    }\n+  else\n+    {\n+      // everything is ok, now we need to ensure all field values are ordered\n+      // correctly. The GIMPLE backend uses a simple algorithm that assumes each\n+      // assigned field in the constructor is in the same order as the field in\n+      // the type\n+      for (auto &field : struct_expr.get_fields ())\n+\tfield.release ();\n+\n+      std::vector<std::unique_ptr<HIR::StructExprField> > ordered_fields;\n+      for (size_t i = 0; i < adtFieldIndexToField.size (); i++)\n+\t{\n+\t  ordered_fields.push_back (\n+\t    std::unique_ptr<HIR::StructExprField> (adtFieldIndexToField[i]));\n+\t}\n+      struct_expr.set_fields_as_owner (std::move (ordered_fields));\n+    }\n+\n+  resolved = struct_def;\n+}\n+\n+void\n+TypeCheckStructExpr::visit (HIR::StructExprFieldIdentifierValue &field)\n+{\n+  auto it = fields_assigned.find (field.field_name);\n+  if (it != fields_assigned.end ())\n+    {\n+      rust_fatal_error (field.get_locus (), \"used more than once\");\n+      return;\n+    }\n+\n+  size_t field_index;\n+  TyTy::StructFieldType *field_type;\n+  bool ok = variant->lookup_field (field.field_name, &field_type, &field_index);\n+  if (!ok)\n+    {\n+      rust_error_at (field.get_locus (), \"unknown field\");\n+      return;\n+    }\n+\n+  TyTy::BaseType *value = TypeCheckExpr::Resolve (field.get_value (), false);\n+  resolved_field_value_expr = field_type->get_field_type ()->unify (value);\n+  if (resolved_field_value_expr != nullptr)\n+    {\n+      fields_assigned.insert (field.field_name);\n+      adtFieldIndexToField[field_index] = &field;\n+    }\n+}\n+\n+void\n+TypeCheckStructExpr::visit (HIR::StructExprFieldIndexValue &field)\n+{\n+  std::string field_name (std::to_string (field.get_tuple_index ()));\n+  auto it = fields_assigned.find (field_name);\n+  if (it != fields_assigned.end ())\n+    {\n+      rust_fatal_error (field.get_locus (), \"used more than once\");\n+      return;\n+    }\n+\n+  size_t field_index;\n+  TyTy::StructFieldType *field_type;\n+  bool ok = variant->lookup_field (field_name, &field_type, &field_index);\n+  if (!ok)\n+    {\n+      rust_error_at (field.get_locus (), \"unknown field\");\n+      return;\n+    }\n+\n+  TyTy::BaseType *value = TypeCheckExpr::Resolve (field.get_value (), false);\n+  resolved_field_value_expr = field_type->get_field_type ()->unify (value);\n+  if (resolved_field_value_expr != nullptr)\n+    {\n+      fields_assigned.insert (field_name);\n+      adtFieldIndexToField[field_index] = &field;\n+    }\n+}\n+\n+void\n+TypeCheckStructExpr::visit (HIR::StructExprFieldIdentifier &field)\n+{\n+  auto it = fields_assigned.find (field.get_field_name ());\n+  if (it != fields_assigned.end ())\n+    {\n+      rust_fatal_error (field.get_locus (), \"used more than once\");\n+      return;\n+    }\n+\n+  size_t field_index;\n+  TyTy::StructFieldType *field_type;\n+  bool ok = variant->lookup_field (field.get_field_name (), &field_type,\n+\t\t\t\t   &field_index);\n+  if (!ok)\n+    {\n+      rust_error_at (field.get_locus (), \"unknown field\");\n+      return;\n+    }\n+\n+  // we can make the field look like an identifier expr to take advantage of\n+  // existing code to figure out the type\n+  HIR::IdentifierExpr expr (field.get_mappings (), field.get_field_name (),\n+\t\t\t    field.get_locus ());\n+  TyTy::BaseType *value = TypeCheckExpr::Resolve (&expr, false);\n+\n+  resolved_field_value_expr = field_type->get_field_type ()->unify (value);\n+  if (resolved_field_value_expr != nullptr)\n+\n+    {\n+      fields_assigned.insert (field.field_name);\n+      adtFieldIndexToField[field_index] = &field;\n+    }\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "7b1dfc965e78bcd6348ae08eac19c5a3f1dd1d9c", "filename": "gcc/rust/typecheck/rust-hir-type-check-toplevel.h", "status": "modified", "additions": 84, "deletions": 15, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h?ref=5f0df4812c37fc428b5508e019e9fb7f8a7b77b1", "patch": "@@ -24,6 +24,7 @@\n #include \"rust-hir-type-check-implitem.h\"\n #include \"rust-hir-type-check-type.h\"\n #include \"rust-hir-type-check-expr.h\"\n+#include \"rust-hir-type-check-enumitem.h\"\n #include \"rust-tyty.h\"\n \n namespace Rust {\n@@ -87,7 +88,6 @@ class TypeCheckTopLevel : public TypeCheckBase\n       }\n \n     std::vector<TyTy::StructFieldType *> fields;\n-\n     size_t idx = 0;\n     for (auto &field : struct_decl.get_fields ())\n       {\n@@ -102,12 +102,18 @@ class TypeCheckTopLevel : public TypeCheckBase\n \tidx++;\n       }\n \n+    // there is only a single variant\n+    std::vector<TyTy::VariantDef *> variants;\n+    variants.push_back (new TyTy::VariantDef (\n+      struct_decl.get_mappings ().get_hirid (), struct_decl.get_identifier (),\n+      TyTy::VariantDef::VariantType::TUPLE, std::move (fields)));\n+\n     TyTy::BaseType *type\n       = new TyTy::ADTType (struct_decl.get_mappings ().get_hirid (),\n \t\t\t   mappings->get_next_hir_id (),\n \t\t\t   struct_decl.get_identifier (),\n \t\t\t   TyTy::ADTType::ADTKind::TUPLE_STRUCT,\n-\t\t\t   std::move (fields), std::move (substitutions));\n+\t\t\t   std::move (variants), std::move (substitutions));\n \n     context->insert_type (struct_decl.get_mappings (), type);\n   }\n@@ -165,16 +171,73 @@ class TypeCheckTopLevel : public TypeCheckBase\n \t\t\t      ty_field->get_field_type ());\n       }\n \n+    // there is only a single variant\n+    std::vector<TyTy::VariantDef *> variants;\n+    variants.push_back (new TyTy::VariantDef (\n+      struct_decl.get_mappings ().get_hirid (), struct_decl.get_identifier (),\n+      TyTy::VariantDef::VariantType::STRUCT, std::move (fields)));\n+\n     TyTy::BaseType *type\n       = new TyTy::ADTType (struct_decl.get_mappings ().get_hirid (),\n \t\t\t   mappings->get_next_hir_id (),\n \t\t\t   struct_decl.get_identifier (),\n \t\t\t   TyTy::ADTType::ADTKind::STRUCT_STRUCT,\n-\t\t\t   std::move (fields), std::move (substitutions));\n+\t\t\t   std::move (variants), std::move (substitutions));\n \n     context->insert_type (struct_decl.get_mappings (), type);\n   }\n \n+  void visit (HIR::Enum &enum_decl) override\n+  {\n+    std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+    if (enum_decl.has_generics ())\n+      {\n+\tfor (auto &generic_param : enum_decl.get_generic_params ())\n+\t  {\n+\t    switch (generic_param.get ()->get_kind ())\n+\t      {\n+\t      case HIR::GenericParam::GenericKind::LIFETIME:\n+\t\t// Skipping Lifetime completely until better handling.\n+\t\tbreak;\n+\n+\t\tcase HIR::GenericParam::GenericKind::TYPE: {\n+\t\t  auto param_type\n+\t\t    = TypeResolveGenericParam::Resolve (generic_param.get ());\n+\t\t  context->insert_type (generic_param->get_mappings (),\n+\t\t\t\t\tparam_type);\n+\n+\t\t  substitutions.push_back (TyTy::SubstitutionParamMapping (\n+\t\t    static_cast<HIR::TypeParam &> (*generic_param),\n+\t\t    param_type));\n+\t\t}\n+\t\tbreak;\n+\t      }\n+\t  }\n+      }\n+\n+    std::vector<TyTy::VariantDef *> variants;\n+    int64_t discriminant_value = 0;\n+    for (auto &variant : enum_decl.get_variants ())\n+      {\n+\tTyTy::VariantDef *field_type\n+\t  = TypeCheckEnumItem::Resolve (variant.get (), discriminant_value);\n+\n+\tvariants.push_back (field_type);\n+\tif (field_type->get_variant_type ()\n+\t    == TyTy::VariantDef::VariantType::NUM)\n+\t  discriminant_value = field_type->get_discriminant ();\n+      }\n+\n+    TyTy::BaseType *type\n+      = new TyTy::ADTType (enum_decl.get_mappings ().get_hirid (),\n+\t\t\t   mappings->get_next_hir_id (),\n+\t\t\t   enum_decl.get_identifier (),\n+\t\t\t   TyTy::ADTType::ADTKind::ENUM, std::move (variants),\n+\t\t\t   std::move (substitutions));\n+\n+    context->insert_type (enum_decl.get_mappings (), type);\n+  }\n+\n   void visit (HIR::Union &union_decl) override\n   {\n     std::vector<TyTy::SubstitutionParamMapping> substitutions;\n@@ -208,18 +271,24 @@ class TypeCheckTopLevel : public TypeCheckBase\n \tResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n       }\n \n-    std::vector<TyTy::StructFieldType *> variants;\n-    union_decl.iterate ([&] (HIR::StructField &variant) mutable -> bool {\n-      TyTy::BaseType *variant_type\n-\t= TypeCheckType::Resolve (variant.get_field_type ().get ());\n-      TyTy::StructFieldType *ty_variant\n-\t= new TyTy::StructFieldType (variant.get_mappings ().get_hirid (),\n-\t\t\t\t     variant.get_field_name (), variant_type);\n-      variants.push_back (ty_variant);\n-      context->insert_type (variant.get_mappings (),\n-\t\t\t    ty_variant->get_field_type ());\n-      return true;\n-    });\n+    std::vector<TyTy::StructFieldType *> fields;\n+    for (auto &variant : union_decl.get_variants ())\n+      {\n+\tTyTy::BaseType *variant_type\n+\t  = TypeCheckType::Resolve (variant.get_field_type ().get ());\n+\tTyTy::StructFieldType *ty_variant\n+\t  = new TyTy::StructFieldType (variant.get_mappings ().get_hirid (),\n+\t\t\t\t       variant.get_field_name (), variant_type);\n+\tfields.push_back (ty_variant);\n+\tcontext->insert_type (variant.get_mappings (),\n+\t\t\t      ty_variant->get_field_type ());\n+      }\n+\n+    // there is only a single variant\n+    std::vector<TyTy::VariantDef *> variants;\n+    variants.push_back (new TyTy::VariantDef (\n+      union_decl.get_mappings ().get_hirid (), union_decl.get_identifier (),\n+      TyTy::VariantDef::VariantType::STRUCT, std::move (fields)));\n \n     TyTy::BaseType *type\n       = new TyTy::ADTType (union_decl.get_mappings ().get_hirid (),"}, {"sha": "5237082461dd42c80903410f82f4e6fcd9475ec4", "filename": "gcc/rust/typecheck/rust-hir-type-check.cc", "status": "modified", "additions": 0, "deletions": 256, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc?ref=5f0df4812c37fc428b5508e019e9fb7f8a7b77b1", "patch": "@@ -120,262 +120,6 @@ TypeCheckExpr::visit (HIR::BlockExpr &expr)\n     infered = new TyTy::NeverType (expr.get_mappings ().get_hirid ());\n }\n \n-// RUST_HIR_TYPE_CHECK_STRUCT_FIELD\n-\n-void\n-TypeCheckStructExpr::visit (HIR::StructExprStructFields &struct_expr)\n-{\n-  TyTy::BaseType *struct_path_ty\n-    = TypeCheckExpr::Resolve (&struct_expr.get_struct_name (), false);\n-  if (struct_path_ty->get_kind () != TyTy::TypeKind::ADT)\n-    {\n-      rust_error_at (struct_expr.get_struct_name ().get_locus (),\n-\t\t     \"expected an ADT type for constructor\");\n-      return;\n-    }\n-\n-  struct_path_resolved = static_cast<TyTy::ADTType *> (struct_path_ty);\n-  TyTy::ADTType *struct_def = struct_path_resolved;\n-  if (struct_expr.has_struct_base ())\n-    {\n-      TyTy::BaseType *base_resolved\n-\t= TypeCheckExpr::Resolve (struct_expr.struct_base->base_struct.get (),\n-\t\t\t\t  false);\n-      struct_def\n-\t= (TyTy::ADTType *) struct_path_resolved->unify (base_resolved);\n-      if (struct_def == nullptr)\n-\t{\n-\t  rust_fatal_error (struct_expr.struct_base->base_struct->get_locus (),\n-\t\t\t    \"incompatible types for base struct reference\");\n-\t  return;\n-\t}\n-    }\n-\n-  std::vector<TyTy::StructFieldType *> infered_fields;\n-  bool ok = true;\n-\n-  for (auto &field : struct_expr.get_fields ())\n-    {\n-      resolved_field_value_expr = nullptr;\n-      field->accept_vis (*this);\n-      if (resolved_field_value_expr == nullptr)\n-\t{\n-\t  rust_fatal_error (field->get_locus (),\n-\t\t\t    \"failed to resolve type for field\");\n-\t  ok = false;\n-\t  break;\n-\t}\n-\n-      context->insert_type (field->get_mappings (), resolved_field_value_expr);\n-    }\n-\n-  // something failed setting up the fields\n-  if (!ok)\n-    {\n-      rust_error_at (struct_expr.get_locus (),\n-\t\t     \"constructor type resolution failure\");\n-      return;\n-    }\n-\n-  // check the arguments are all assigned and fix up the ordering\n-  if (fields_assigned.size () != struct_path_resolved->num_fields ())\n-    {\n-      if (struct_def->is_union ())\n-\t{\n-\t  if (fields_assigned.size () != 1 || struct_expr.has_struct_base ())\n-\t    {\n-\t      rust_error_at (\n-\t\tstruct_expr.get_locus (),\n-\t\t\"union must have exactly one field variant assigned\");\n-\t      return;\n-\t    }\n-\t}\n-      else if (!struct_expr.has_struct_base ())\n-\t{\n-\t  rust_error_at (struct_expr.get_locus (),\n-\t\t\t \"constructor is missing fields\");\n-\t  return;\n-\t}\n-      else\n-\t{\n-\t  // we have a struct base to assign the missing fields from.\n-\t  // the missing fields can be implicit FieldAccessExprs for the value\n-\t  std::set<std::string> missing_fields;\n-\t  struct_path_resolved->iterate_fields (\n-\t    [&] (TyTy::StructFieldType *field) mutable -> bool {\n-\t      auto it = fields_assigned.find (field->get_name ());\n-\t      if (it == fields_assigned.end ())\n-\t\tmissing_fields.insert (field->get_name ());\n-\t      return true;\n-\t    });\n-\n-\t  // we can generate FieldAccessExpr or TupleAccessExpr for the values\n-\t  // of the missing fields.\n-\t  for (auto &missing : missing_fields)\n-\t    {\n-\t      HIR::Expr *receiver\n-\t\t= struct_expr.struct_base->base_struct->clone_expr_impl ();\n-\n-\t      HIR::StructExprField *implicit_field = nullptr;\n-\n-\t      AST::AttrVec outer_attribs;\n-\t      auto crate_num = mappings->get_current_crate ();\n-\t      Analysis::NodeMapping mapping (\n-\t\tcrate_num,\n-\t\tstruct_expr.struct_base->base_struct->get_mappings ()\n-\t\t  .get_nodeid (),\n-\t\tmappings->get_next_hir_id (crate_num), UNKNOWN_LOCAL_DEFID);\n-\n-\t      HIR::Expr *field_value = new HIR::FieldAccessExpr (\n-\t\tmapping, std::unique_ptr<HIR::Expr> (receiver), missing,\n-\t\tstd::move (outer_attribs),\n-\t\tstruct_expr.struct_base->base_struct->get_locus ());\n-\n-\t      implicit_field = new HIR::StructExprFieldIdentifierValue (\n-\t\tmapping, missing, std::unique_ptr<HIR::Expr> (field_value),\n-\t\tstruct_expr.struct_base->base_struct->get_locus ());\n-\n-\t      size_t field_index;\n-\t      bool ok = struct_path_resolved->get_field (missing, &field_index);\n-\t      rust_assert (ok);\n-\n-\t      adtFieldIndexToField[field_index] = implicit_field;\n-\t      struct_expr.get_fields ().push_back (\n-\t\tstd::unique_ptr<HIR::StructExprField> (implicit_field));\n-\t    }\n-\t}\n-    }\n-\n-  if (struct_def->is_union ())\n-    {\n-      // There is exactly one field in this constructor, we need to\n-      // figure out the field index to make sure we initialize the\n-      // right union field.\n-      for (size_t i = 0; i < adtFieldIndexToField.size (); i++)\n-\t{\n-\t  if (adtFieldIndexToField[i])\n-\t    {\n-\t      struct_expr.union_index = i;\n-\t      break;\n-\t    }\n-\t}\n-      rust_assert (struct_expr.union_index != -1);\n-    }\n-  else\n-    {\n-      // everything is ok, now we need to ensure all field values are ordered\n-      // correctly. The GIMPLE backend uses a simple algorithm that assumes each\n-      // assigned field in the constructor is in the same order as the field in\n-      // the type\n-      for (auto &field : struct_expr.get_fields ())\n-\tfield.release ();\n-\n-      std::vector<std::unique_ptr<HIR::StructExprField> > ordered_fields;\n-      for (size_t i = 0; i < adtFieldIndexToField.size (); i++)\n-\t{\n-\t  ordered_fields.push_back (\n-\t    std::unique_ptr<HIR::StructExprField> (adtFieldIndexToField[i]));\n-\t}\n-      struct_expr.set_fields_as_owner (std::move (ordered_fields));\n-    }\n-\n-  resolved = struct_def;\n-}\n-\n-void\n-TypeCheckStructExpr::visit (HIR::StructExprFieldIdentifierValue &field)\n-{\n-  auto it = fields_assigned.find (field.field_name);\n-  if (it != fields_assigned.end ())\n-    {\n-      rust_fatal_error (field.get_locus (), \"used more than once\");\n-      return;\n-    }\n-\n-  size_t field_index;\n-  TyTy::StructFieldType *field_type\n-    = struct_path_resolved->get_field (field.field_name, &field_index);\n-  if (field_type == nullptr)\n-    {\n-      rust_error_at (field.get_locus (), \"unknown field\");\n-      return;\n-    }\n-\n-  TyTy::BaseType *value = TypeCheckExpr::Resolve (field.get_value (), false);\n-  resolved_field_value_expr = field_type->get_field_type ()->unify (value);\n-  if (resolved_field_value_expr != nullptr)\n-    {\n-      fields_assigned.insert (field.field_name);\n-      adtFieldIndexToField[field_index] = &field;\n-    }\n-}\n-\n-void\n-TypeCheckStructExpr::visit (HIR::StructExprFieldIndexValue &field)\n-{\n-  std::string field_name (std::to_string (field.get_tuple_index ()));\n-  auto it = fields_assigned.find (field_name);\n-  if (it != fields_assigned.end ())\n-    {\n-      rust_fatal_error (field.get_locus (), \"used more than once\");\n-      return;\n-    }\n-\n-  size_t field_index;\n-\n-  TyTy::StructFieldType *field_type\n-    = struct_path_resolved->get_field (field_name, &field_index);\n-  if (field_type == nullptr)\n-    {\n-      rust_error_at (field.get_locus (), \"unknown field\");\n-      return;\n-    }\n-\n-  TyTy::BaseType *value = TypeCheckExpr::Resolve (field.get_value (), false);\n-  resolved_field_value_expr = field_type->get_field_type ()->unify (value);\n-  if (resolved_field_value_expr != nullptr)\n-    {\n-      fields_assigned.insert (field_name);\n-      adtFieldIndexToField[field_index] = &field;\n-    }\n-}\n-\n-void\n-TypeCheckStructExpr::visit (HIR::StructExprFieldIdentifier &field)\n-{\n-  auto it = fields_assigned.find (field.get_field_name ());\n-  if (it != fields_assigned.end ())\n-    {\n-      rust_fatal_error (field.get_locus (), \"used more than once\");\n-      return;\n-    }\n-\n-  size_t field_index;\n-  TyTy::StructFieldType *field_type\n-    = struct_path_resolved->get_field (field.get_field_name (), &field_index);\n-  if (field_type == nullptr)\n-    {\n-      rust_error_at (field.get_locus (), \"unknown field\");\n-      return;\n-    }\n-\n-  // we can make the field look like an identifier expr to take advantage of\n-  // existing code to figure out the type\n-  HIR::IdentifierExpr expr (field.get_mappings (), field.get_field_name (),\n-\t\t\t    field.get_locus ());\n-  TyTy::BaseType *value = TypeCheckExpr::Resolve (&expr, false);\n-\n-  resolved_field_value_expr = field_type->get_field_type ()->unify (value);\n-  if (resolved_field_value_expr != nullptr)\n-\n-    {\n-      fields_assigned.insert (field.field_name);\n-      adtFieldIndexToField[field_index] = &field;\n-    }\n-}\n-\n-// rust-hir-type-check-type.h\n-\n void\n TypeCheckType::visit (HIR::ArrayType &type)\n {"}, {"sha": "aa10f411d015b5ab8a9779a6d06c6bc7d269c0eb", "filename": "gcc/rust/typecheck/rust-hir-type-check.h", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h?ref=5f0df4812c37fc428b5508e019e9fb7f8a7b77b1", "patch": "@@ -214,6 +214,24 @@ class TypeCheckContext\n     return true;\n   }\n \n+  void insert_variant_definition (HirId id, HirId variant)\n+  {\n+    auto it = variants.find (id);\n+    rust_assert (it == variants.end ());\n+\n+    variants[id] = variant;\n+  }\n+\n+  bool lookup_variant_definition (HirId id, HirId *variant)\n+  {\n+    auto it = variants.find (id);\n+    if (it == variants.end ())\n+      return false;\n+\n+    *variant = it->second;\n+    return true;\n+  }\n+\n private:\n   TypeCheckContext ();\n \n@@ -234,6 +252,9 @@ class TypeCheckContext\n \n   // adjustment mappings\n   std::map<HirId, std::vector<Adjustment>> autoderef_mappings;\n+\n+  // variants\n+  std::map<HirId, HirId> variants;\n };\n \n class TypeResolution"}, {"sha": "c11fd4d6da6b3adebe9567924ff3009da1cecae7", "filename": "gcc/rust/typecheck/rust-tyty-call.h", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h?ref=5f0df4812c37fc428b5508e019e9fb7f8a7b77b1", "patch": "@@ -32,9 +32,10 @@ class TypeCheckCallExpr : private TyVisitor\n {\n public:\n   static BaseType *go (BaseType *ref, HIR::CallExpr &call,\n+\t\t       TyTy::VariantDef &variant,\n \t\t       Resolver::TypeCheckContext *context)\n   {\n-    TypeCheckCallExpr checker (call, context);\n+    TypeCheckCallExpr checker (call, variant, context);\n     ref->accept_vis (checker);\n     return checker.resolved;\n   }\n@@ -58,23 +59,26 @@ class TypeCheckCallExpr : private TyVisitor\n   void visit (PlaceholderType &) override { gcc_unreachable (); }\n   void visit (ProjectionType &) override { gcc_unreachable (); }\n   void visit (DynamicObjectType &) override { gcc_unreachable (); }\n+  void visit (ClosureType &type) override { gcc_unreachable (); }\n \n   // tuple-structs\n   void visit (ADTType &type) override;\n \n   // call fns\n   void visit (FnType &type) override;\n   void visit (FnPtr &type) override;\n-  void visit (ClosureType &type) override { gcc_unreachable (); }\n \n private:\n-  TypeCheckCallExpr (HIR::CallExpr &c, Resolver::TypeCheckContext *context)\n-    : resolved (nullptr), call (c), context (context),\n+  TypeCheckCallExpr (HIR::CallExpr &c, TyTy::VariantDef &variant,\n+\t\t     Resolver::TypeCheckContext *context)\n+    : resolved (new TyTy::ErrorType (c.get_mappings ().get_hirid ())), call (c),\n+      variant (variant), context (context),\n       mappings (Analysis::Mappings::get ())\n   {}\n \n   BaseType *resolved;\n   HIR::CallExpr &call;\n+  TyTy::VariantDef &variant;\n   Resolver::TypeCheckContext *context;\n   Analysis::Mappings *mappings;\n };"}, {"sha": "aaa589beda38df568d319d669fced3554d477ad8", "filename": "gcc/rust/typecheck/rust-tyty-cast.h", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Frust%2Ftypecheck%2Frust-tyty-cast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Frust%2Ftypecheck%2Frust-tyty-cast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-cast.h?ref=5f0df4812c37fc428b5508e019e9fb7f8a7b77b1", "patch": "@@ -993,29 +993,47 @@ class ADTCastRules : public BaseCastRules\n \n   void visit (ADTType &type) override\n   {\n+    if (base->get_adt_kind () != type.get_adt_kind ())\n+      {\n+\tBaseCastRules::visit (type);\n+\treturn;\n+      }\n+\n     if (base->get_identifier ().compare (type.get_identifier ()) != 0)\n       {\n \tBaseCastRules::visit (type);\n \treturn;\n       }\n \n-    if (base->num_fields () != type.num_fields ())\n+    if (base->number_of_variants () != type.number_of_variants ())\n       {\n \tBaseCastRules::visit (type);\n \treturn;\n       }\n \n-    for (size_t i = 0; i < type.num_fields (); ++i)\n+    for (size_t i = 0; i < type.number_of_variants (); ++i)\n       {\n-\tTyTy::StructFieldType *base_field = base->get_field (i);\n-\tTyTy::StructFieldType *other_field = type.get_field (i);\n+\tTyTy::VariantDef *a = base->get_variants ().at (i);\n+\tTyTy::VariantDef *b = type.get_variants ().at (i);\n \n-\tTyTy::BaseType *this_field_ty = base_field->get_field_type ();\n-\tTyTy::BaseType *other_field_ty = other_field->get_field_type ();\n+\tif (a->num_fields () != b->num_fields ())\n+\t  {\n+\t    BaseCastRules::visit (type);\n+\t    return;\n+\t  }\n \n-\tBaseType *unified_ty = this_field_ty->unify (other_field_ty);\n-\tif (unified_ty->get_kind () == TyTy::TypeKind::ERROR)\n-\t  return;\n+\tfor (size_t j = 0; j < a->num_fields (); j++)\n+\t  {\n+\t    TyTy::StructFieldType *base_field = a->get_field_at_index (i);\n+\t    TyTy::StructFieldType *other_field = b->get_field_at_index (i);\n+\n+\t    TyTy::BaseType *this_field_ty = base_field->get_field_type ();\n+\t    TyTy::BaseType *other_field_ty = other_field->get_field_type ();\n+\n+\t    BaseType *unified_ty = this_field_ty->unify (other_field_ty);\n+\t    if (unified_ty->get_kind () == TyTy::TypeKind::ERROR)\n+\t      return;\n+\t  }\n       }\n \n     resolved = type.clone ();"}, {"sha": "4ab3df20fdcb53f8e596ce39b3a80c9ebc252497", "filename": "gcc/rust/typecheck/rust-tyty-cmp.h", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h?ref=5f0df4812c37fc428b5508e019e9fb7f8a7b77b1", "patch": "@@ -990,32 +990,50 @@ class ADTCmp : public BaseCmp\n \n   void visit (const ADTType &type) override\n   {\n-    if (base->get_identifier ().compare (type.get_identifier ()) != 0)\n+    if (base->get_adt_kind () != type.get_adt_kind ())\n       {\n \tBaseCmp::visit (type);\n \treturn;\n       }\n \n-    if (base->num_fields () != type.num_fields ())\n+    if (base->get_identifier ().compare (type.get_identifier ()) != 0)\n       {\n \tBaseCmp::visit (type);\n \treturn;\n       }\n \n-    for (size_t i = 0; i < type.num_fields (); ++i)\n+    if (base->number_of_variants () != type.number_of_variants ())\n       {\n-\tconst TyTy::StructFieldType *base_field = base->get_imm_field (i);\n-\tconst TyTy::StructFieldType *other_field = type.get_imm_field (i);\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n \n-\tTyTy::BaseType *this_field_ty = base_field->get_field_type ();\n-\tTyTy::BaseType *other_field_ty = other_field->get_field_type ();\n+    for (size_t i = 0; i < type.number_of_variants (); ++i)\n+      {\n+\tTyTy::VariantDef *a = base->get_variants ().at (i);\n+\tTyTy::VariantDef *b = type.get_variants ().at (i);\n \n-\tif (!this_field_ty->can_eq (other_field_ty, emit_error_flag,\n-\t\t\t\t    autoderef_mode_flag))\n+\tif (a->num_fields () != b->num_fields ())\n \t  {\n \t    BaseCmp::visit (type);\n \t    return;\n \t  }\n+\n+\tfor (size_t j = 0; j < a->num_fields (); j++)\n+\t  {\n+\t    TyTy::StructFieldType *base_field = a->get_field_at_index (i);\n+\t    TyTy::StructFieldType *other_field = b->get_field_at_index (i);\n+\n+\t    TyTy::BaseType *this_field_ty = base_field->get_field_type ();\n+\t    TyTy::BaseType *other_field_ty = other_field->get_field_type ();\n+\n+\t    if (!this_field_ty->can_eq (other_field_ty, emit_error_flag,\n+\t\t\t\t\tautoderef_mode_flag))\n+\t      {\n+\t\tBaseCmp::visit (type);\n+\t\treturn;\n+\t      }\n+\t  }\n       }\n \n     ok = true;"}, {"sha": "6525da3d372c2b29a0363191509277bd401aeb5f", "filename": "gcc/rust/typecheck/rust-tyty-coercion.h", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Frust%2Ftypecheck%2Frust-tyty-coercion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Frust%2Ftypecheck%2Frust-tyty-coercion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-coercion.h?ref=5f0df4812c37fc428b5508e019e9fb7f8a7b77b1", "patch": "@@ -1000,29 +1000,47 @@ class ADTCoercionRules : public BaseCoercionRules\n \n   void visit (ADTType &type) override\n   {\n+    if (base->get_adt_kind () != type.get_adt_kind ())\n+      {\n+\tBaseCoercionRules::visit (type);\n+\treturn;\n+      }\n+\n     if (base->get_identifier ().compare (type.get_identifier ()) != 0)\n       {\n \tBaseCoercionRules::visit (type);\n \treturn;\n       }\n \n-    if (base->num_fields () != type.num_fields ())\n+    if (base->number_of_variants () != type.number_of_variants ())\n       {\n \tBaseCoercionRules::visit (type);\n \treturn;\n       }\n \n-    for (size_t i = 0; i < type.num_fields (); ++i)\n+    for (size_t i = 0; i < type.number_of_variants (); ++i)\n       {\n-\tTyTy::StructFieldType *base_field = base->get_field (i);\n-\tTyTy::StructFieldType *other_field = type.get_field (i);\n+\tTyTy::VariantDef *a = base->get_variants ().at (i);\n+\tTyTy::VariantDef *b = type.get_variants ().at (i);\n \n-\tTyTy::BaseType *this_field_ty = base_field->get_field_type ();\n-\tTyTy::BaseType *other_field_ty = other_field->get_field_type ();\n+\tif (a->num_fields () != b->num_fields ())\n+\t  {\n+\t    BaseCoercionRules::visit (type);\n+\t    return;\n+\t  }\n \n-\tBaseType *unified_ty = this_field_ty->unify (other_field_ty);\n-\tif (unified_ty->get_kind () == TyTy::TypeKind::ERROR)\n-\t  return;\n+\tfor (size_t j = 0; j < a->num_fields (); j++)\n+\t  {\n+\t    TyTy::StructFieldType *base_field = a->get_field_at_index (i);\n+\t    TyTy::StructFieldType *other_field = b->get_field_at_index (i);\n+\n+\t    TyTy::BaseType *this_field_ty = base_field->get_field_type ();\n+\t    TyTy::BaseType *other_field_ty = other_field->get_field_type ();\n+\n+\t    BaseType *unified_ty = this_field_ty->unify (other_field_ty);\n+\t    if (unified_ty->get_kind () == TyTy::TypeKind::ERROR)\n+\t      return;\n+\t  }\n       }\n \n     resolved = type.clone ();"}, {"sha": "db86de9fd6bfe047bb618d99e46c30b189916ea9", "filename": "gcc/rust/typecheck/rust-tyty-rules.h", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h?ref=5f0df4812c37fc428b5508e019e9fb7f8a7b77b1", "patch": "@@ -1016,29 +1016,47 @@ class ADTRules : public BaseRules\n \n   void visit (ADTType &type) override\n   {\n+    if (base->get_adt_kind () != type.get_adt_kind ())\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n     if (base->get_identifier ().compare (type.get_identifier ()) != 0)\n       {\n \tBaseRules::visit (type);\n \treturn;\n       }\n \n-    if (base->num_fields () != type.num_fields ())\n+    if (base->number_of_variants () != type.number_of_variants ())\n       {\n \tBaseRules::visit (type);\n \treturn;\n       }\n \n-    for (size_t i = 0; i < type.num_fields (); ++i)\n+    for (size_t i = 0; i < type.number_of_variants (); ++i)\n       {\n-\tTyTy::StructFieldType *base_field = base->get_field (i);\n-\tTyTy::StructFieldType *other_field = type.get_field (i);\n+\tTyTy::VariantDef *a = base->get_variants ().at (i);\n+\tTyTy::VariantDef *b = type.get_variants ().at (i);\n \n-\tTyTy::BaseType *this_field_ty = base_field->get_field_type ();\n-\tTyTy::BaseType *other_field_ty = other_field->get_field_type ();\n+\tif (a->num_fields () != b->num_fields ())\n+\t  {\n+\t    BaseRules::visit (type);\n+\t    return;\n+\t  }\n \n-\tBaseType *unified_ty = this_field_ty->unify (other_field_ty);\n-\tif (unified_ty->get_kind () == TyTy::TypeKind::ERROR)\n-\t  return;\n+\tfor (size_t j = 0; j < a->num_fields (); j++)\n+\t  {\n+\t    TyTy::StructFieldType *base_field = a->get_field_at_index (i);\n+\t    TyTy::StructFieldType *other_field = b->get_field_at_index (i);\n+\n+\t    TyTy::BaseType *this_field_ty = base_field->get_field_type ();\n+\t    TyTy::BaseType *other_field_ty = other_field->get_field_type ();\n+\n+\t    BaseType *unified_ty = this_field_ty->unify (other_field_ty);\n+\t    if (unified_ty->get_kind () == TyTy::TypeKind::ERROR)\n+\t      return;\n+\t  }\n       }\n \n     resolved = type.clone ();"}, {"sha": "16cabc8bb1b9972b031b49ac5ebced1fc6cb137c", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 85, "deletions": 85, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=5f0df4812c37fc428b5508e019e9fb7f8a7b77b1", "patch": "@@ -590,35 +590,16 @@ ADTType::accept_vis (TyConstVisitor &vis) const\n std::string\n ADTType::as_string () const\n {\n-  if (num_fields () == 0)\n-    return identifier;\n-\n-  std::string fields_buffer;\n-  for (size_t i = 0; i < num_fields (); ++i)\n+  std::string variants_buffer;\n+  for (size_t i = 0; i < number_of_variants (); ++i)\n     {\n-      fields_buffer += get_field (i)->as_string ();\n-      if ((i + 1) < num_fields ())\n-\tfields_buffer += \", \";\n+      TyTy::VariantDef *variant = variants.at (i);\n+      variants_buffer += variant->as_string ();\n+      if ((i + 1) < number_of_variants ())\n+\tvariants_buffer += \", \";\n     }\n \n-  return identifier + subst_as_string () + \"{\" + fields_buffer + \"}\";\n-}\n-\n-const StructFieldType *\n-ADTType::get_field (size_t index) const\n-{\n-  return fields.at (index);\n-}\n-\n-const BaseType *\n-ADTType::get_field_type (size_t index) const\n-{\n-  const StructFieldType *ref = get_field (index);\n-  auto context = Resolver::TypeCheckContext::get ();\n-  BaseType *lookup = nullptr;\n-  bool ok = context->lookup_type (ref->get_field_type ()->get_ref (), &lookup);\n-  rust_assert (ok);\n-  return lookup;\n+  return identifier + subst_as_string () + \"{\" + variants_buffer + \"}\";\n }\n \n BaseType *\n@@ -657,7 +638,10 @@ ADTType::is_equal (const BaseType &other) const\n     return false;\n \n   auto other2 = static_cast<const ADTType &> (other);\n-  if (num_fields () != other2.num_fields ())\n+  if (get_adt_kind () != other2.get_adt_kind ())\n+    return false;\n+\n+  if (number_of_variants () != other2.number_of_variants ())\n     return false;\n \n   if (has_subsititions_defined () != other2.has_subsititions_defined ())\n@@ -683,9 +667,12 @@ ADTType::is_equal (const BaseType &other) const\n     }\n   else\n     {\n-      for (size_t i = 0; i < num_fields (); i++)\n+      for (size_t i = 0; i < number_of_variants (); i++)\n \t{\n-\t  if (!get_field (i)->is_equal (*other2.get_field (i)))\n+\t  const TyTy::VariantDef *a = get_variants ().at (i);\n+\t  const TyTy::VariantDef *b = other2.get_variants ().at (i);\n+\n+\t  if (!a->is_equal (*b))\n \t    return false;\n \t}\n     }\n@@ -696,15 +683,66 @@ ADTType::is_equal (const BaseType &other) const\n BaseType *\n ADTType::clone () const\n {\n-  std::vector<StructFieldType *> cloned_fields;\n-  for (auto &f : fields)\n-    cloned_fields.push_back ((StructFieldType *) f->clone ());\n+  std::vector<VariantDef *> cloned_variants;\n+  for (auto &variant : variants)\n+    cloned_variants.push_back (variant->clone ());\n \n   return new ADTType (get_ref (), get_ty_ref (), identifier, get_adt_kind (),\n-\t\t      cloned_fields, clone_substs (), used_arguments,\n+\t\t      cloned_variants, clone_substs (), used_arguments,\n \t\t      get_combined_refs ());\n }\n \n+static bool\n+handle_substitions (SubstitutionArgumentMappings &subst_mappings,\n+\t\t    StructFieldType *field)\n+{\n+  auto fty = field->get_field_type ();\n+  bool is_param_ty = fty->get_kind () == TypeKind::PARAM;\n+  if (is_param_ty)\n+    {\n+      ParamType *p = static_cast<ParamType *> (fty);\n+\n+      SubstitutionArg arg = SubstitutionArg::error ();\n+      bool ok = subst_mappings.get_argument_for_symbol (p, &arg);\n+      if (ok)\n+\t{\n+\t  auto argt = arg.get_tyty ();\n+\t  bool arg_is_param = argt->get_kind () == TyTy::TypeKind::PARAM;\n+\t  bool arg_is_concrete = argt->get_kind () != TyTy::TypeKind::INFER;\n+\n+\t  if (arg_is_param || arg_is_concrete)\n+\t    {\n+\t      auto new_field = argt->clone ();\n+\t      new_field->set_ref (fty->get_ref ());\n+\t      field->set_field_type (new_field);\n+\t    }\n+\t  else\n+\t    {\n+\t      field->get_field_type ()->set_ty_ref (argt->get_ref ());\n+\t    }\n+\t}\n+    }\n+  else if (fty->has_subsititions_defined () || fty->contains_type_parameters ())\n+    {\n+      BaseType *concrete\n+\t= Resolver::SubstMapperInternal::Resolve (fty, subst_mappings);\n+\n+      if (concrete->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  rust_error_at (subst_mappings.get_locus (),\n+\t\t\t \"Failed to resolve field substitution type: %s\",\n+\t\t\t fty->as_string ().c_str ());\n+\t  return false;\n+\t}\n+\n+      auto new_field = concrete->clone ();\n+      new_field->set_ref (fty->get_ref ());\n+      field->set_field_type (new_field);\n+    }\n+\n+  return true;\n+}\n+\n ADTType *\n ADTType::handle_substitions (SubstitutionArgumentMappings subst_mappings)\n {\n@@ -721,54 +759,15 @@ ADTType::handle_substitions (SubstitutionArgumentMappings subst_mappings)\n \tsub.fill_param_ty (*arg.get_tyty (), subst_mappings.get_locus ());\n     }\n \n-  adt->iterate_fields ([&] (StructFieldType *field) mutable -> bool {\n-    auto fty = field->get_field_type ();\n-    bool is_param_ty = fty->get_kind () == TypeKind::PARAM;\n-    if (is_param_ty)\n-      {\n-\tParamType *p = static_cast<ParamType *> (fty);\n-\n-\tSubstitutionArg arg = SubstitutionArg::error ();\n-\tbool ok = subst_mappings.get_argument_for_symbol (p, &arg);\n-\tif (ok)\n-\t  {\n-\t    auto argt = arg.get_tyty ();\n-\t    bool arg_is_param = argt->get_kind () == TyTy::TypeKind::PARAM;\n-\t    bool arg_is_concrete = argt->get_kind () != TyTy::TypeKind::INFER;\n-\n-\t    if (arg_is_param || arg_is_concrete)\n-\t      {\n-\t\tauto new_field = argt->clone ();\n-\t\tnew_field->set_ref (fty->get_ref ());\n-\t\tfield->set_field_type (new_field);\n-\t      }\n-\t    else\n-\t      {\n-\t\tfield->get_field_type ()->set_ty_ref (argt->get_ref ());\n-\t      }\n-\t  }\n-      }\n-    else if (fty->has_subsititions_defined ()\n-\t     || fty->contains_type_parameters ())\n-      {\n-\tBaseType *concrete\n-\t  = Resolver::SubstMapperInternal::Resolve (fty, subst_mappings);\n-\n-\tif (concrete->get_kind () == TyTy::TypeKind::ERROR)\n-\t  {\n-\t    rust_error_at (subst_mappings.get_locus (),\n-\t\t\t   \"Failed to resolve field substitution type: %s\",\n-\t\t\t   fty->as_string ().c_str ());\n-\t    return false;\n-\t  }\n-\n-\tauto new_field = concrete->clone ();\n-\tnew_field->set_ref (fty->get_ref ());\n-\tfield->set_field_type (new_field);\n-      }\n-\n-    return true;\n-  });\n+  for (auto &variant : adt->get_variants ())\n+    {\n+      for (auto &field : variant->get_fields ())\n+\t{\n+\t  bool ok = ::Rust::TyTy::handle_substitions (subst_mappings, field);\n+\t  if (!ok)\n+\t    return adt;\n+\t}\n+    }\n \n   return adt;\n }\n@@ -2538,7 +2537,8 @@ DynamicObjectType::get_object_items () const\n void\n TypeCheckCallExpr::visit (ADTType &type)\n {\n-  if (!type.is_tuple_struct ())\n+  rust_assert (!variant.is_error ());\n+  if (variant.get_variant_type () != TyTy::VariantDef::VariantType::TUPLE)\n     {\n       rust_error_at (\n \tcall.get_locus (),\n@@ -2547,18 +2547,18 @@ TypeCheckCallExpr::visit (ADTType &type)\n       return;\n     }\n \n-  if (call.num_params () != type.num_fields ())\n+  if (call.num_params () != variant.num_fields ())\n     {\n       rust_error_at (call.get_locus (),\n \t\t     \"unexpected number of arguments %lu expected %lu\",\n-\t\t     call.num_params (), type.num_fields ());\n+\t\t     call.num_params (), variant.num_fields ());\n       return;\n     }\n \n   size_t i = 0;\n   for (auto &argument : call.get_arguments ())\n     {\n-      StructFieldType *field = type.get_field (i);\n+      StructFieldType *field = variant.get_field_at_index (i);\n       BaseType *field_tyty = field->get_field_type ();\n \n       BaseType *arg = Resolver::TypeCheckExpr::Resolve (argument.get (), false);"}, {"sha": "5ffd95c29da719381fa57bc2412a00640fb5f0fd", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 191, "deletions": 47, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=5f0df4812c37fc428b5508e019e9fb7f8a7b77b1", "patch": "@@ -1009,6 +1009,150 @@ class SubstitutionRef\n   SubstitutionArgumentMappings used_arguments;\n };\n \n+// https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.VariantDef.html\n+class VariantDef\n+{\n+public:\n+  enum VariantType\n+  {\n+    NUM,\n+    TUPLE,\n+    STRUCT\n+  };\n+\n+  VariantDef (HirId id, std::string identifier, int discriminant)\n+    : id (id), identifier (identifier), discriminant (discriminant)\n+  {\n+    type = VariantType::NUM;\n+    fields = {};\n+  }\n+\n+  VariantDef (HirId id, std::string identifier, VariantType type,\n+\t      std::vector<StructFieldType *> fields)\n+    : id (id), identifier (identifier), type (type), fields (fields)\n+  {\n+    discriminant = 0;\n+    rust_assert (type == VariantType::TUPLE || type == VariantType::STRUCT);\n+  }\n+\n+  VariantDef (HirId id, std::string identifier, VariantType type,\n+\t      int discriminant, std::vector<StructFieldType *> fields)\n+    : id (id), identifier (identifier), type (type),\n+      discriminant (discriminant), fields (fields)\n+  {\n+    rust_assert ((type == VariantType::NUM && fields.empty ())\n+\t\t || (type == VariantType::TUPLE && discriminant == 0)\n+\t\t || (type == VariantType::STRUCT && discriminant == 0));\n+  }\n+\n+  static VariantDef &get_error_node ()\n+  {\n+    static VariantDef node = VariantDef (UNKNOWN_HIRID, \"\", -1);\n+    return node;\n+  }\n+\n+  bool is_error () const { return get_id () == UNKNOWN_HIRID; }\n+\n+  HirId get_id () const { return id; }\n+\n+  VariantType get_variant_type () const { return type; }\n+\n+  std::string get_identifier () const { return identifier; }\n+  int get_discriminant () const { return discriminant; }\n+\n+  size_t num_fields () const { return fields.size (); }\n+  StructFieldType *get_field_at_index (size_t index)\n+  {\n+    // FIXME this is not safe\n+    return fields.at (index);\n+  }\n+\n+  std::vector<StructFieldType *> &get_fields ()\n+  {\n+    rust_assert (type != NUM);\n+    return fields;\n+  }\n+\n+  bool lookup_field (const std::string &lookup, StructFieldType **field_lookup,\n+\t\t     size_t *index) const\n+  {\n+    size_t i = 0;\n+    for (auto &field : fields)\n+      {\n+\tif (field->get_name ().compare (lookup) == 0)\n+\t  {\n+\t    if (index != nullptr)\n+\t      *index = i;\n+\n+\t    if (field_lookup != nullptr)\n+\t      *field_lookup = field;\n+\n+\t    return true;\n+\t  }\n+\ti++;\n+      }\n+    return false;\n+  }\n+\n+  std::string as_string () const\n+  {\n+    if (type == VariantType::NUM)\n+      return identifier + \" = \" + std::to_string (discriminant);\n+\n+    std::string buffer;\n+    for (size_t i = 0; i < fields.size (); ++i)\n+      {\n+\tbuffer += fields.at (i)->as_string ();\n+\tif ((i + 1) < fields.size ())\n+\t  buffer += \", \";\n+      }\n+\n+    if (type == VariantType::TUPLE)\n+      return identifier + \" (\" + buffer + \")\";\n+    else\n+      return identifier + \" {\" + buffer + \"}\";\n+  }\n+\n+  bool is_equal (const VariantDef &other) const\n+  {\n+    if (type != other.type)\n+      return false;\n+\n+    if (identifier.compare (other.identifier) != 0)\n+      return false;\n+\n+    if (discriminant != other.discriminant)\n+      return false;\n+\n+    if (fields.size () != other.fields.size ())\n+      return false;\n+\n+    for (size_t i = 0; i < fields.size (); i++)\n+      {\n+\tif (!fields.at (i)->is_equal (*other.fields.at (i)))\n+\t  return false;\n+      }\n+\n+    return true;\n+  }\n+\n+  VariantDef *clone () const\n+  {\n+    std::vector<StructFieldType *> cloned_fields;\n+    for (auto &f : fields)\n+      cloned_fields.push_back ((StructFieldType *) f->clone ());\n+\n+    return new VariantDef (id, identifier, type, discriminant, cloned_fields);\n+  }\n+\n+private:\n+  HirId id;\n+  std::string identifier;\n+  VariantType type;\n+  int discriminant; /* Either discriminant or fields are valid.  */\n+  std::vector<StructFieldType *> fields;\n+};\n+\n class ADTType : public BaseType, public SubstitutionRef\n {\n public:\n@@ -1017,36 +1161,48 @@ class ADTType : public BaseType, public SubstitutionRef\n     STRUCT_STRUCT,\n     TUPLE_STRUCT,\n     UNION,\n-    // ENUM ?\n+    ENUM\n   };\n \n   ADTType (HirId ref, std::string identifier, ADTKind adt_kind,\n-\t   std::vector<StructFieldType *> fields,\n+\t   std::vector<VariantDef *> variants,\n \t   std::vector<SubstitutionParamMapping> subst_refs,\n \t   SubstitutionArgumentMappings generic_arguments\n \t   = SubstitutionArgumentMappings::error (),\n \t   std::set<HirId> refs = std::set<HirId> ())\n     : BaseType (ref, ref, TypeKind::ADT, refs),\n       SubstitutionRef (std::move (subst_refs), std::move (generic_arguments)),\n-      identifier (identifier), fields (fields), adt_kind (adt_kind)\n+      identifier (identifier), variants (variants), adt_kind (adt_kind)\n   {}\n \n   ADTType (HirId ref, HirId ty_ref, std::string identifier, ADTKind adt_kind,\n-\t   std::vector<StructFieldType *> fields,\n+\t   std::vector<VariantDef *> variants,\n \t   std::vector<SubstitutionParamMapping> subst_refs,\n \t   SubstitutionArgumentMappings generic_arguments\n \t   = SubstitutionArgumentMappings::error (),\n \t   std::set<HirId> refs = std::set<HirId> ())\n     : BaseType (ref, ty_ref, TypeKind::ADT, refs),\n       SubstitutionRef (std::move (subst_refs), std::move (generic_arguments)),\n-      identifier (identifier), fields (fields), adt_kind (adt_kind)\n+      identifier (identifier), variants (variants), adt_kind (adt_kind)\n   {}\n \n   ADTKind get_adt_kind () const { return adt_kind; }\n+\n+  bool is_struct_struct () const { return adt_kind == STRUCT_STRUCT; }\n   bool is_tuple_struct () const { return adt_kind == TUPLE_STRUCT; }\n   bool is_union () const { return adt_kind == UNION; }\n+  bool is_enum () const { return adt_kind == ENUM; }\n \n-  bool is_unit () const override { return this->fields.empty (); }\n+  bool is_unit () const override\n+  {\n+    if (number_of_variants () == 0)\n+      return true;\n+\n+    if (number_of_variants () == 1)\n+      return variants.at (0)->num_fields () == 0;\n+\n+    return false;\n+  }\n \n   void accept_vis (TyVisitor &vis) override;\n   void accept_vis (TyConstVisitor &vis) const override;\n@@ -1061,77 +1217,65 @@ class ADTType : public BaseType, public SubstitutionRef\n \n   bool is_equal (const BaseType &other) const override;\n \n-  size_t num_fields () const { return fields.size (); }\n-\n   std::string get_identifier () const { return identifier; }\n \n   std::string get_name () const override final\n   {\n     return identifier + subst_as_string ();\n   }\n \n-  BaseType *get_field_type (size_t index);\n-\n-  const BaseType *get_field_type (size_t index) const;\n+  BaseType *clone () const final override;\n \n-  const StructFieldType *get_field (size_t index) const;\n+  bool needs_generic_substitutions () const override final\n+  {\n+    return needs_substitution ();\n+  }\n \n-  StructFieldType *get_field (size_t index) { return fields.at (index); }\n+  bool supports_substitutions () const override final { return true; }\n \n-  const StructFieldType *get_imm_field (size_t index) const\n+  bool has_subsititions_defined () const override final\n   {\n-    return fields.at (index);\n+    return has_substitutions ();\n   }\n \n-  StructFieldType *get_field (const std::string &lookup,\n-\t\t\t      size_t *index = nullptr) const\n+  size_t number_of_variants () const { return variants.size (); }\n+\n+  std::vector<VariantDef *> &get_variants () { return variants; }\n+  const std::vector<VariantDef *> &get_variants () const { return variants; }\n+\n+  bool lookup_variant (const std::string &lookup,\n+\t\t       VariantDef **found_variant) const\n   {\n-    size_t i = 0;\n-    for (auto &field : fields)\n+    for (auto &variant : variants)\n       {\n-\tif (field->get_name ().compare (lookup) == 0)\n+\tif (variant->get_identifier ().compare (lookup) == 0)\n \t  {\n-\t    if (index != nullptr)\n-\t      *index = i;\n-\t    return field;\n+\t    *found_variant = variant;\n+\t    return true;\n \t  }\n-\ti++;\n       }\n-    return nullptr;\n+    return false;\n   }\n \n-  BaseType *clone () const final override;\n-\n-  std::vector<StructFieldType *> &get_fields () { return fields; }\n-  const std::vector<StructFieldType *> &get_fields () const { return fields; }\n-\n-  void iterate_fields (std::function<bool (StructFieldType *)> cb)\n+  bool lookup_variant_by_id (HirId id, VariantDef **found_variant) const\n   {\n-    for (auto &f : fields)\n+    for (auto &variant : variants)\n       {\n-\tif (!cb (f))\n-\t  return;\n+\tif (variant->get_id () == id)\n+\t  {\n+\t    *found_variant = variant;\n+\t    return true;\n+\t  }\n       }\n-  }\n-\n-  bool needs_generic_substitutions () const override final\n-  {\n-    return needs_substitution ();\n-  }\n-\n-  bool supports_substitutions () const override final { return true; }\n-\n-  bool has_subsititions_defined () const override final\n-  {\n-    return has_substitutions ();\n+    return false;\n   }\n \n   ADTType *\n   handle_substitions (SubstitutionArgumentMappings mappings) override final;\n \n private:\n   std::string identifier;\n-  std::vector<StructFieldType *> fields;\n+  std::vector<VariantDef *> variants;\n   ADTType::ADTKind adt_kind;\n };\n "}, {"sha": "0b8d999fec172310a7b14eb6634b43d9348e419d", "filename": "gcc/testsuite/rust/compile/func2.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Ftestsuite%2Frust%2Fcompile%2Ffunc2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Ftestsuite%2Frust%2Fcompile%2Ffunc2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ffunc2.rs?ref=5f0df4812c37fc428b5508e019e9fb7f8a7b77b1", "patch": "@@ -4,6 +4,4 @@ fn test(a: i32, b: i32) -> i32 {\n \n fn main() {\n     let a = test(1); // { dg-error \"unexpected number of arguments 1 expected 2\" }\n-    // { dg-error \"failed to lookup type to CallExpr\" \"\" { target *-*-* } .-1 }\n-    // { dg-error \"failed to type resolve expression\" \"\" { target *-*-* } .-2 }\n }"}, {"sha": "2a329476118748293b6244330a2f5ce859cf3d8e", "filename": "gcc/testsuite/rust/compile/func3.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Ftestsuite%2Frust%2Fcompile%2Ffunc3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Ftestsuite%2Frust%2Fcompile%2Ffunc3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ffunc3.rs?ref=5f0df4812c37fc428b5508e019e9fb7f8a7b77b1", "patch": "@@ -6,6 +6,4 @@ fn main() {\n     let a = test(1, true);\n     // { dg-error \"expected .i32. got .bool.\" \"\" { target *-*-* } .-1 }\n     // { dg-error \"Type Resolution failure on parameter\" \"\" { target *-*-* } .-2 }\n-    // { dg-error \"failed to lookup type to CallExpr\" \"\" { target *-*-* } .-3 }\n-    // { dg-error \"failed to type resolve expression\" \"\" { target *-*-* } .-4 }\n }"}, {"sha": "2f4cb4a353bba5bb9a55384bc9fa2ceb87f32a0f", "filename": "gcc/testsuite/rust/compile/tuple_struct1.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftuple_struct1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftuple_struct1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftuple_struct1.rs?ref=5f0df4812c37fc428b5508e019e9fb7f8a7b77b1", "patch": "@@ -5,6 +5,4 @@ struct Foo {\n \n fn main() {\n     let a = Foo(1, 2); // { dg-error \"expected function, tuple struct or tuple variant, found struct 'Foo'\" }\n-    // { dg-error \"failed to lookup type to CallExpr\" \"\" { target *-*-* } .-1 }\n-    // { dg-error \"failed to type resolve expression\" \"\" { target *-*-* } .-2 }\n }"}, {"sha": "1fc1896857738fd43ef1c4dad61dc6dc7310eae3", "filename": "gcc/testsuite/rust/compile/tuple_struct2.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftuple_struct2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftuple_struct2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftuple_struct2.rs?ref=5f0df4812c37fc428b5508e019e9fb7f8a7b77b1", "patch": "@@ -2,6 +2,4 @@ struct Bar(i32, i32, bool);\n \n fn main() {\n     let a = Bar(1, 2); // { dg-error \"unexpected number of arguments 2 expected 3\" }\n-    // { dg-error \"failed to lookup type to CallExpr\" \"\" { target *-*-* } .-1 }\n-    // { dg-error \"failed to type resolve expression\" \"\" { target *-*-* } .-2 }\n }"}, {"sha": "4af66b8370e23e59e4d01af8bce7bf0a1e74f6c1", "filename": "gcc/testsuite/rust/compile/tuple_struct3.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftuple_struct3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0df4812c37fc428b5508e019e9fb7f8a7b77b1/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftuple_struct3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftuple_struct3.rs?ref=5f0df4812c37fc428b5508e019e9fb7f8a7b77b1", "patch": "@@ -3,6 +3,4 @@ struct Foo(i32, i32, bool);\n fn main() {\n     let c = Foo(1, 2f32, true);\n     // { dg-error \"expected .i32. got .f32.\" \"\" { target *-*-* } .-1 }\n-    // { dg-error \"failed to lookup type to CallExpr\" \"\" { target *-*-* } .-2 }\n-    // { dg-error \"failed to type resolve expression\" \"\" { target *-*-* } .-3 }\n }"}]}