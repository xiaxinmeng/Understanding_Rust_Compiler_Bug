{"sha": "1230327b00075291801211e9edc06fd96a1cc0a1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTIzMDMyN2IwMDA3NTI5MTgwMTIxMWU5ZWRjMDZmZDk2YTFjYzBhMQ==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "amylaar@cygnus.co.uk", "date": "1998-02-05T16:34:02Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "1998-02-05T16:34:02Z"}, "message": "regmove.c: Update.\n\n\t* regmove.c: Update.\n\t* flags.h (flag_regmove): Declare.\n\t* rtl.h (optimize_reg_copy_1, optimize_reg_copy_2): Don't declare.\n\t* local-alloc.c (optimize_reg_copy_1, optimize_reg_copy_2):\n\tMoved into regmove; changed caller.\n\t* toplev.c (rest_of_compilation): Call regmove_optimize also for\n\texpensive_optimizations.\n\nFrom-SVN: r17669", "tree": {"sha": "d53fdc7c09c775cf4675b87dab49d13457f60606", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d53fdc7c09c775cf4675b87dab49d13457f60606"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1230327b00075291801211e9edc06fd96a1cc0a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1230327b00075291801211e9edc06fd96a1cc0a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1230327b00075291801211e9edc06fd96a1cc0a1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1230327b00075291801211e9edc06fd96a1cc0a1/comments", "author": null, "committer": null, "parents": [{"sha": "b1ad0392e441717466b32b316ec550aa31b62e44", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1ad0392e441717466b32b316ec550aa31b62e44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1ad0392e441717466b32b316ec550aa31b62e44"}], "stats": {"total": 571, "additions": 278, "deletions": 293}, "files": [{"sha": "e20370c8b80e120ee3a9ffce6ee05baf3fcc7552", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1230327b00075291801211e9edc06fd96a1cc0a1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1230327b00075291801211e9edc06fd96a1cc0a1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1230327b00075291801211e9edc06fd96a1cc0a1", "patch": "@@ -1,3 +1,13 @@\n+Fri Feb  6 00:27:36 1998  J\"orn Rennecke <amylaar@cygnus.co.uk>\n+\n+        * regmove.c: Update.\n+        * flags.h (flag_regmove): Declare.\n+\t* rtl.h (optimize_reg_copy_1, optimize_reg_copy_2): Don't declare.\n+        * local-alloc.c (optimize_reg_copy_1, optimize_reg_copy_2):\n+        Moved into regmove; changed caller.\n+        * toplev.c (rest_of_compilation): Call regmove_optimize also for\n+        expensive_optimizations.\n+\n Thu Feb 5 13:38:42 PST 1998 Jeff Law  (law@cygnus.com)\n \n \t* version.c: Bump for snapshot."}, {"sha": "d4b830879ba92a6bd3d94a384fbed86b0bc896fb", "filename": "gcc/flags.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1230327b00075291801211e9edc06fd96a1cc0a1/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1230327b00075291801211e9edc06fd96a1cc0a1/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=1230327b00075291801211e9edc06fd96a1cc0a1", "patch": "@@ -436,6 +436,9 @@ extern int flag_argument_noalias;\n /* Emit code to check for stack overflow; also may cause large objects\n    to be allocated dynamically.  */\n extern int flag_stack_check;\n+\n+/* Do the full regmove optimization pass.  */\n+extern int flag_regmove;\n \f\n /* Other basic status info about current function.  */\n "}, {"sha": "dc8357c68941c8e1b00ff66aea27dae03535bdc5", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 1, "deletions": 278, "changes": 279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1230327b00075291801211e9edc06fd96a1cc0a1/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1230327b00075291801211e9edc06fd96a1cc0a1/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=1230327b00075291801211e9edc06fd96a1cc0a1", "patch": "@@ -739,268 +739,6 @@ memref_used_between_p (memref, start, end)\n   return 0;\n }\n \f\n-/* INSN is a copy from SRC to DEST, both registers, and SRC does not die\n-   in INSN.\n-\n-   Search forward to see if SRC dies before either it or DEST is modified,\n-   but don't scan past the end of a basic block.  If so, we can replace SRC\n-   with DEST and let SRC die in INSN. \n-\n-   This will reduce the number of registers live in that range and may enable\n-   DEST to be tied to SRC, thus often saving one register in addition to a\n-   register-register copy.  */\n-\n-int\n-optimize_reg_copy_1 (insn, dest, src)\n-     rtx insn;\n-     rtx dest;\n-     rtx src;\n-{\n-  rtx p, q;\n-  rtx note;\n-  rtx dest_death = 0;\n-  int sregno = REGNO (src);\n-  int dregno = REGNO (dest);\n-\n-  if (sregno == dregno\n-      /* We don't want to mess with hard regs if register classes are small. */\n-      || (SMALL_REGISTER_CLASSES\n-\t  && (sregno < FIRST_PSEUDO_REGISTER\n-\t      || dregno < FIRST_PSEUDO_REGISTER))\n-      /* We don't see all updates to SP if they are in an auto-inc memory\n-\t reference, so we must disallow this optimization on them.  */\n-      || sregno == STACK_POINTER_REGNUM || dregno == STACK_POINTER_REGNUM)\n-    return 0;\n-\n-  for (p = NEXT_INSN (insn); p; p = NEXT_INSN (p))\n-    {\n-      if (GET_CODE (p) == CODE_LABEL || GET_CODE (p) == JUMP_INSN\n-\t  || (GET_CODE (p) == NOTE\n-\t      && (NOTE_LINE_NUMBER (p) == NOTE_INSN_LOOP_BEG\n-\t\t  || NOTE_LINE_NUMBER (p) == NOTE_INSN_LOOP_END)))\n-\tbreak;\n-\n-      if (GET_RTX_CLASS (GET_CODE (p)) != 'i')\n-\tcontinue;\n-\n-      if (reg_set_p (src, p) || reg_set_p (dest, p)\n-\t  /* Don't change a USE of a register.  */\n-\t  || (GET_CODE (PATTERN (p)) == USE\n-\t      && reg_overlap_mentioned_p (src, XEXP (PATTERN (p), 0))))\n-\tbreak;\n-\n-      /* See if all of SRC dies in P.  This test is slightly more\n-\t conservative than it needs to be.  */\n-      if ((note = find_regno_note (p, REG_DEAD, sregno)) != 0\n-\t  && GET_MODE (XEXP (note, 0)) == GET_MODE (src))\n-\t{\n-\t  int failed = 0;\n-\t  int length = 0;\n-\t  int d_length = 0;\n-\t  int n_calls = 0;\n-\t  int d_n_calls = 0;\n-\n-\t  /* We can do the optimization.  Scan forward from INSN again,\n-\t     replacing regs as we go.  Set FAILED if a replacement can't\n-\t     be done.  In that case, we can't move the death note for SRC.\n-\t     This should be rare.  */\n-\n-\t  /* Set to stop at next insn.  */\n-\t  for (q = next_real_insn (insn);\n-\t       q != next_real_insn (p);\n-\t       q = next_real_insn (q))\n-\t    {\n-\t      if (reg_overlap_mentioned_p (src, PATTERN (q)))\n-\t\t{\n-\t\t  /* If SRC is a hard register, we might miss some\n-\t\t     overlapping registers with validate_replace_rtx,\n-\t\t     so we would have to undo it.  We can't if DEST is\n-\t\t     present in the insn, so fail in that combination\n-\t\t     of cases.  */\n-\t\t  if (sregno < FIRST_PSEUDO_REGISTER\n-\t\t      && reg_mentioned_p (dest, PATTERN (q)))\n-\t\t    failed = 1;\n-\n-\t\t  /* Replace all uses and make sure that the register\n-\t\t     isn't still present.  */\n-\t\t  else if (validate_replace_rtx (src, dest, q)\n-\t\t\t   && (sregno >= FIRST_PSEUDO_REGISTER\n-\t\t\t       || ! reg_overlap_mentioned_p (src,\n-\t\t\t\t\t\t\t     PATTERN (q))))\n-\t\t    {\n-\t\t      /* We assume that a register is used exactly once per\n-\t\t\t insn in the updates below.  If this is not correct,\n-\t\t\t no great harm is done.  */\n-\t\t      if (sregno >= FIRST_PSEUDO_REGISTER)\n-\t\t\tREG_N_REFS (sregno) -= loop_depth;\n-\t\t      if (dregno >= FIRST_PSEUDO_REGISTER)\n-\t\t\tREG_N_REFS (dregno) += loop_depth;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      validate_replace_rtx (dest, src, q);\n-\t\t      failed = 1;\n-\t\t    }\n-\t\t}\n-\n-\t      /* Count the insns and CALL_INSNs passed.  If we passed the\n-\t\t death note of DEST, show increased live length.  */\n-\t      length++;\n-\t      if (dest_death)\n-\t\td_length++;\n-\n-\t      /* If the insn in which SRC dies is a CALL_INSN, don't count it\n-\t\t as a call that has been crossed.  Otherwise, count it.  */\n-\t      if (q != p && GET_CODE (q) == CALL_INSN)\n-\t\t{\n-\t\t  n_calls++;\n-\t\t  if (dest_death)\n-\t\t    d_n_calls++;\n-\t\t}\n-\n-\t      /* If DEST dies here, remove the death note and save it for\n-\t\t later.  Make sure ALL of DEST dies here; again, this is\n-\t\t overly conservative.  */\n-\t      if (dest_death == 0\n-\t\t  && (dest_death = find_regno_note (q, REG_DEAD, dregno)) != 0)\n-\t\t{\n-\t\t  if (GET_MODE (XEXP (dest_death, 0)) != GET_MODE (dest))\n-\t\t    failed = 1, dest_death = 0;\n-\t\t  else\n-\t\t    remove_note (q, dest_death);\n-\t\t}\n-\t    }\n-\n-\t  if (! failed)\n-\t    {\n-\t      if (sregno >= FIRST_PSEUDO_REGISTER)\n-\t\t{\n-\t\t  if (REG_LIVE_LENGTH (sregno) >= 0)\n-\t\t    {\n-\t\t      REG_LIVE_LENGTH (sregno) -= length;\n-\t\t      /* REG_LIVE_LENGTH is only an approximation after\n-\t\t\t combine if sched is not run, so make sure that we\n-\t\t\t still have a reasonable value.  */\n-\t\t      if (REG_LIVE_LENGTH (sregno) < 2)\n-\t\t\tREG_LIVE_LENGTH (sregno) = 2;\n-\t\t    }\n-\n-\t\t  REG_N_CALLS_CROSSED (sregno) -= n_calls;\n-\t\t}\n-\n-\t      if (dregno >= FIRST_PSEUDO_REGISTER)\n-\t\t{\n-\t\t  if (REG_LIVE_LENGTH (dregno) >= 0)\n-\t\t    REG_LIVE_LENGTH (dregno) += d_length;\n-\n-\t\t  REG_N_CALLS_CROSSED (dregno) += d_n_calls;\n-\t\t}\n-\n-\t      /* Move death note of SRC from P to INSN.  */\n-\t      remove_note (p, note);\n-\t      XEXP (note, 1) = REG_NOTES (insn);\n-\t      REG_NOTES (insn) = note;\n-\t    }\n-\n-\t  /* Put death note of DEST on P if we saw it die.  */\n-\t  if (dest_death)\n-\t    {\n-\t      XEXP (dest_death, 1) = REG_NOTES (p);\n-\t      REG_NOTES (p) = dest_death;\n-\t    }\n-\n-\t  return ! failed;\n-\t}\n-\n-      /* If SRC is a hard register which is set or killed in some other\n-\t way, we can't do this optimization.  */\n-      else if (sregno < FIRST_PSEUDO_REGISTER\n-\t       && dead_or_set_p (p, src))\n-\tbreak;\n-    }\n-  return 0;\n-}\n-\f\n-/* INSN is a copy of SRC to DEST, in which SRC dies.  See if we now have\n-   a sequence of insns that modify DEST followed by an insn that sets\n-   SRC to DEST in which DEST dies, with no prior modification of DEST.\n-   (There is no need to check if the insns in between actually modify\n-   DEST.  We should not have cases where DEST is not modified, but\n-   the optimization is safe if no such modification is detected.)\n-   In that case, we can replace all uses of DEST, starting with INSN and\n-   ending with the set of SRC to DEST, with SRC.  We do not do this\n-   optimization if a CALL_INSN is crossed unless SRC already crosses a\n-   call or if DEST dies before the copy back to SRC.\n-\n-   It is assumed that DEST and SRC are pseudos; it is too complicated to do\n-   this for hard registers since the substitutions we may make might fail.  */\n-\n-void\n-optimize_reg_copy_2 (insn, dest, src)\n-     rtx insn;\n-     rtx dest;\n-     rtx src;\n-{\n-  rtx p, q;\n-  rtx set;\n-  int sregno = REGNO (src);\n-  int dregno = REGNO (dest);\n-\n-  for (p = NEXT_INSN (insn); p; p = NEXT_INSN (p))\n-    {\n-      if (GET_CODE (p) == CODE_LABEL || GET_CODE (p) == JUMP_INSN\n-\t  || (GET_CODE (p) == NOTE\n-\t      && (NOTE_LINE_NUMBER (p) == NOTE_INSN_LOOP_BEG\n-\t\t  || NOTE_LINE_NUMBER (p) == NOTE_INSN_LOOP_END)))\n-\tbreak;\n-\n-      if (GET_RTX_CLASS (GET_CODE (p)) != 'i')\n-\tcontinue;\n-\n-      set = single_set (p);\n-      if (set && SET_SRC (set) == dest && SET_DEST (set) == src\n-\t  && find_reg_note (p, REG_DEAD, dest))\n-\t{\n-\t  /* We can do the optimization.  Scan forward from INSN again,\n-\t     replacing regs as we go.  */\n-\n-\t  /* Set to stop at next insn.  */\n-\t  for (q = insn; q != NEXT_INSN (p); q = NEXT_INSN (q))\n-\t    if (GET_RTX_CLASS (GET_CODE (q)) == 'i')\n-\t      {\n-\t\tif (reg_mentioned_p (dest, PATTERN (q)))\n-\t\t  {\n-\t\t    PATTERN (q) = replace_rtx (PATTERN (q), dest, src);\n-\n-\t\t    /* We assume that a register is used exactly once per\n-\t\t       insn in the updates below.  If this is not correct,\n-\t\t       no great harm is done.  */\n-\t\t    REG_N_REFS (dregno) -= loop_depth;\n-\t\t    REG_N_REFS (sregno) += loop_depth;\n-\t\t  }\n-\n-\n-\t      if (GET_CODE (q) == CALL_INSN)\n-\t\t{\n-\t\t  REG_N_CALLS_CROSSED (dregno)--;\n-\t\t  REG_N_CALLS_CROSSED (sregno)++;\n-\t\t}\n-\t      }\n-\n-\t  remove_note (p, find_reg_note (p, REG_DEAD, dest));\n-\t  REG_N_DEATHS (dregno)--;\n-\t  remove_note (insn, find_reg_note (insn, REG_DEAD, src));\n-\t  REG_N_DEATHS (sregno)--;\n-\t  return;\n-\t}\n-\n-      if (reg_set_p (src, p)\n-\t  || find_reg_note (p, REG_DEAD, dest)\n-\t  || (GET_CODE (p) == CALL_INSN && REG_N_CALLS_CROSSED (sregno) == 0))\n-\tbreak;\n-    }\n-}\n-\f\t      \n /* Find registers that are equivalent to a single value throughout the\n    compilation (either because they can be referenced in memory or are set once\n    from a single constant).  Lower their priority for a register.\n@@ -1085,22 +823,7 @@ update_equiv_regs ()\n \t  = gen_rtx_EXPR_LIST (REG_EQUIV, dest,\n \t\t\t       REG_NOTES (reg_equiv_init_insn[regno]));\n \n-      /* If this is a register-register copy where SRC is not dead, see if we\n-\t can optimize it.  */\n-      if (flag_expensive_optimizations && GET_CODE (dest) == REG\n-\t  && GET_CODE (SET_SRC (set)) == REG\n-\t  && ! find_reg_note (insn, REG_DEAD, SET_SRC (set)))\n-\toptimize_reg_copy_1 (insn, dest, SET_SRC (set));\n-\n-      /* Similarly for a pseudo-pseudo copy when SRC is dead.  */\n-      else if (flag_expensive_optimizations && GET_CODE (dest) == REG\n-\t       && REGNO (dest) >= FIRST_PSEUDO_REGISTER\n-\t       && GET_CODE (SET_SRC (set)) == REG\n-\t       && REGNO (SET_SRC (set)) >= FIRST_PSEUDO_REGISTER\n-\t       && find_reg_note (insn, REG_DEAD, SET_SRC (set)))\n-\toptimize_reg_copy_2 (insn, dest, SET_SRC (set));\n-\n-      /* Otherwise, we only handle the case of a pseudo register being set\n+      /* We only handle the case of a pseudo register being set\n \t once and only if neither the source nor the destination are\n \t in a register class that's likely to be spilled.  */\n       if (GET_CODE (dest) != REG"}, {"sha": "55c380a9c31fa99d1222677d4f0de6db8b3437a7", "filename": "gcc/regmove.c", "status": "modified", "additions": 263, "deletions": 10, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1230327b00075291801211e9edc06fd96a1cc0a1/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1230327b00075291801211e9edc06fd96a1cc0a1/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=1230327b00075291801211e9edc06fd96a1cc0a1", "patch": "@@ -44,18 +44,10 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"expr.h\"\n #include \"insn-flags.h\"\n \n-#ifndef REG_N_CALLS_CROSSED\n-#define REG_N_CALLS_CROSSED(x) (reg_n_calls_crossed[(x)])\n-#define REG_N_SETS(x) (reg_n_sets[(x)])\n-#define REG_N_REFS(x) (reg_n_refs[(x)])\n-#define REG_N_DEATHS(x) (reg_n_deaths[(x)])\n-#define REG_LIVE_LENGTH(x) (reg_live_length[(x)])\n-#endif\n-\n+static int optimize_reg_copy_1\tPROTO((rtx, rtx, rtx));\n+static void optimize_reg_copy_2\tPROTO((rtx, rtx, rtx));\n static void optimize_reg_copy_3\tPROTO((rtx, rtx, rtx));\n \n-extern int flag_regmove;\n-\n struct match {\n   int with[MAX_RECOG_OPERANDS];\n   enum { READ, WRITE, READWRITE } use[MAX_RECOG_OPERANDS];\n@@ -173,6 +165,267 @@ replacement_quality(reg)\n   return 2;\n }\n \n+/* INSN is a copy from SRC to DEST, both registers, and SRC does not die\n+   in INSN.\n+\n+   Search forward to see if SRC dies before either it or DEST is modified,\n+   but don't scan past the end of a basic block.  If so, we can replace SRC\n+   with DEST and let SRC die in INSN. \n+\n+   This will reduce the number of registers live in that range and may enable\n+   DEST to be tied to SRC, thus often saving one register in addition to a\n+   register-register copy.  */\n+\n+static int\n+optimize_reg_copy_1 (insn, dest, src)\n+     rtx insn;\n+     rtx dest;\n+     rtx src;\n+{\n+  rtx p, q;\n+  rtx note;\n+  rtx dest_death = 0;\n+  int sregno = REGNO (src);\n+  int dregno = REGNO (dest);\n+\n+  /* We don't want to mess with hard regs if register classes are small. */\n+  if (sregno == dregno\n+      || (SMALL_REGISTER_CLASSES\n+\t  && (sregno < FIRST_PSEUDO_REGISTER\n+\t      || dregno < FIRST_PSEUDO_REGISTER))\n+      /* We don't see all updates to SP if they are in an auto-inc memory\n+\t reference, so we must disallow this optimization on them.  */\n+      || sregno == STACK_POINTER_REGNUM || dregno == STACK_POINTER_REGNUM)\n+    return 0;\n+\n+  for (p = NEXT_INSN (insn); p; p = NEXT_INSN (p))\n+    {\n+      if (GET_CODE (p) == CODE_LABEL || GET_CODE (p) == JUMP_INSN\n+\t  || (GET_CODE (p) == NOTE\n+\t      && (NOTE_LINE_NUMBER (p) == NOTE_INSN_LOOP_BEG\n+\t\t  || NOTE_LINE_NUMBER (p) == NOTE_INSN_LOOP_END)))\n+\tbreak;\n+\n+      if (GET_RTX_CLASS (GET_CODE (p)) != 'i')\n+\tcontinue;\n+\n+      if (reg_set_p (src, p) || reg_set_p (dest, p)\n+\t  /* Don't change a USE of a register.  */\n+\t  || (GET_CODE (PATTERN (p)) == USE\n+\t      && reg_overlap_mentioned_p (src, XEXP (PATTERN (p), 0))))\n+\tbreak;\n+\n+      /* See if all of SRC dies in P.  This test is slightly more\n+\t conservative than it needs to be.  */\n+      if ((note = find_regno_note (p, REG_DEAD, sregno)) != 0\n+\t  && GET_MODE (XEXP (note, 0)) == GET_MODE (src))\n+\t{\n+\t  int failed = 0;\n+\t  int length = 0;\n+\t  int d_length = 0;\n+\t  int n_calls = 0;\n+\t  int d_n_calls = 0;\n+\n+\t  /* We can do the optimization.  Scan forward from INSN again,\n+\t     replacing regs as we go.  Set FAILED if a replacement can't\n+\t     be done.  In that case, we can't move the death note for SRC.\n+\t     This should be rare.  */\n+\n+\t  /* Set to stop at next insn.  */\n+\t  for (q = next_real_insn (insn);\n+\t       q != next_real_insn (p);\n+\t       q = next_real_insn (q))\n+\t    {\n+\t      if (reg_overlap_mentioned_p (src, PATTERN (q)))\n+\t\t{\n+\t\t  /* If SRC is a hard register, we might miss some\n+\t\t     overlapping registers with validate_replace_rtx,\n+\t\t     so we would have to undo it.  We can't if DEST is\n+\t\t     present in the insn, so fail in that combination\n+\t\t     of cases.  */\n+\t\t  if (sregno < FIRST_PSEUDO_REGISTER\n+\t\t      && reg_mentioned_p (dest, PATTERN (q)))\n+\t\t    failed = 1;\n+\n+\t\t  /* Replace all uses and make sure that the register\n+\t\t     isn't still present.  */\n+\t\t  else if (validate_replace_rtx (src, dest, q)\n+\t\t\t   && (sregno >= FIRST_PSEUDO_REGISTER\n+\t\t\t       || ! reg_overlap_mentioned_p (src,\n+\t\t\t\t\t\t\t     PATTERN (q))))\n+\t\t    {\n+\t\t      /* We assume that a register is used exactly once per\n+\t\t\t insn in the updates below.  If this is not correct,\n+\t\t\t no great harm is done.  */\n+\t\t      if (sregno >= FIRST_PSEUDO_REGISTER)\n+\t\t\tREG_N_REFS (sregno) -= loop_depth;\n+\t\t      if (dregno >= FIRST_PSEUDO_REGISTER)\n+\t\t\tREG_N_REFS (dregno) += loop_depth;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      validate_replace_rtx (dest, src, q);\n+\t\t      failed = 1;\n+\t\t    }\n+\t\t}\n+\n+\t      /* Count the insns and CALL_INSNs passed.  If we passed the\n+\t\t death note of DEST, show increased live length.  */\n+\t      length++;\n+\t      if (dest_death)\n+\t\td_length++;\n+\n+\t      /* If the insn in which SRC dies is a CALL_INSN, don't count it\n+\t\t as a call that has been crossed.  Otherwise, count it.  */\n+\t      if (q != p && GET_CODE (q) == CALL_INSN)\n+\t\t{\n+\t\t  n_calls++;\n+\t\t  if (dest_death)\n+\t\t    d_n_calls++;\n+\t\t}\n+\n+\t      /* If DEST dies here, remove the death note and save it for\n+\t\t later.  Make sure ALL of DEST dies here; again, this is\n+\t\t overly conservative.  */\n+\t      if (dest_death == 0\n+\t\t  && (dest_death = find_regno_note (q, REG_DEAD, dregno)) != 0)\n+\t\t{\n+\t\t  if (GET_MODE (XEXP (dest_death, 0)) != GET_MODE (dest))\n+\t\t    failed = 1, dest_death = 0;\n+\t\t  else\n+\t\t    remove_note (q, dest_death);\n+\t\t}\n+\t    }\n+\n+\t  if (! failed)\n+\t    {\n+\t      if (sregno >= FIRST_PSEUDO_REGISTER)\n+\t\t{\n+\t\t  if (REG_LIVE_LENGTH (sregno) >= 0)\n+\t\t    {\n+\t\t      REG_LIVE_LENGTH (sregno) -= length;\n+\t\t      /* REG_LIVE_LENGTH is only an approximation after\n+\t\t\t combine if sched is not run, so make sure that we\n+\t\t\t still have a reasonable value.  */\n+\t\t      if (REG_LIVE_LENGTH (sregno) < 2)\n+\t\t\tREG_LIVE_LENGTH (sregno) = 2;\n+\t\t    }\n+\n+\t\t  REG_N_CALLS_CROSSED (sregno) -= n_calls;\n+\t\t}\n+\n+\t      if (dregno >= FIRST_PSEUDO_REGISTER)\n+\t\t{\n+\t\t  if (REG_LIVE_LENGTH (dregno) >= 0)\n+\t\t    REG_LIVE_LENGTH (dregno) += d_length;\n+\n+\t\t  REG_N_CALLS_CROSSED (dregno) += d_n_calls;\n+\t\t}\n+\n+\t      /* Move death note of SRC from P to INSN.  */\n+\t      remove_note (p, note);\n+\t      XEXP (note, 1) = REG_NOTES (insn);\n+\t      REG_NOTES (insn) = note;\n+\t    }\n+\n+\t  /* Put death note of DEST on P if we saw it die.  */\n+\t  if (dest_death)\n+\t    {\n+\t      XEXP (dest_death, 1) = REG_NOTES (p);\n+\t      REG_NOTES (p) = dest_death;\n+\t    }\n+\n+\t  return ! failed;\n+\t}\n+\n+      /* If SRC is a hard register which is set or killed in some other\n+\t way, we can't do this optimization.  */\n+      else if (sregno < FIRST_PSEUDO_REGISTER\n+\t       && dead_or_set_p (p, src))\n+\tbreak;\n+    }\n+  return 0;\n+}\n+\f\n+/* INSN is a copy of SRC to DEST, in which SRC dies.  See if we now have\n+   a sequence of insns that modify DEST followed by an insn that sets\n+   SRC to DEST in which DEST dies, with no prior modification of DEST.\n+   (There is no need to check if the insns in between actually modify\n+   DEST.  We should not have cases where DEST is not modified, but\n+   the optimization is safe if no such modification is detected.)\n+   In that case, we can replace all uses of DEST, starting with INSN and\n+   ending with the set of SRC to DEST, with SRC.  We do not do this\n+   optimization if a CALL_INSN is crossed unless SRC already crosses a\n+   call or if DEST dies before the copy back to SRC.\n+\n+   It is assumed that DEST and SRC are pseudos; it is too complicated to do\n+   this for hard registers since the substitutions we may make might fail.  */\n+\n+static void\n+optimize_reg_copy_2 (insn, dest, src)\n+     rtx insn;\n+     rtx dest;\n+     rtx src;\n+{\n+  rtx p, q;\n+  rtx set;\n+  int sregno = REGNO (src);\n+  int dregno = REGNO (dest);\n+\n+  for (p = NEXT_INSN (insn); p; p = NEXT_INSN (p))\n+    {\n+      if (GET_CODE (p) == CODE_LABEL || GET_CODE (p) == JUMP_INSN\n+\t  || (GET_CODE (p) == NOTE\n+\t      && (NOTE_LINE_NUMBER (p) == NOTE_INSN_LOOP_BEG\n+\t\t  || NOTE_LINE_NUMBER (p) == NOTE_INSN_LOOP_END)))\n+\tbreak;\n+\n+      if (GET_RTX_CLASS (GET_CODE (p)) != 'i')\n+\tcontinue;\n+\n+      set = single_set (p);\n+      if (set && SET_SRC (set) == dest && SET_DEST (set) == src\n+\t  && find_reg_note (p, REG_DEAD, dest))\n+\t{\n+\t  /* We can do the optimization.  Scan forward from INSN again,\n+\t     replacing regs as we go.  */\n+\n+\t  /* Set to stop at next insn.  */\n+\t  for (q = insn; q != NEXT_INSN (p); q = NEXT_INSN (q))\n+\t    if (GET_RTX_CLASS (GET_CODE (q)) == 'i')\n+\t      {\n+\t\tif (reg_mentioned_p (dest, PATTERN (q)))\n+\t\t  {\n+\t\t    PATTERN (q) = replace_rtx (PATTERN (q), dest, src);\n+\n+\t\t    /* We assume that a register is used exactly once per\n+\t\t       insn in the updates below.  If this is not correct,\n+\t\t       no great harm is done.  */\n+\t\t    REG_N_REFS (dregno) -= loop_depth;\n+\t\t    REG_N_REFS (sregno) += loop_depth;\n+\t\t  }\n+\n+\n+\t      if (GET_CODE (q) == CALL_INSN)\n+\t\t{\n+\t\t  REG_N_CALLS_CROSSED (dregno)--;\n+\t\t  REG_N_CALLS_CROSSED (sregno)++;\n+\t\t}\n+\t      }\n+\n+\t  remove_note (p, find_reg_note (p, REG_DEAD, dest));\n+\t  REG_N_DEATHS (dregno)--;\n+\t  remove_note (insn, find_reg_note (insn, REG_DEAD, src));\n+\t  REG_N_DEATHS (sregno)--;\n+\t  return;\n+\t}\n+\n+      if (reg_set_p (src, p)\n+\t  || find_reg_note (p, REG_DEAD, dest)\n+\t  || (GET_CODE (p) == CALL_INSN && REG_N_CALLS_CROSSED (sregno) == 0))\n+\tbreak;\n+    }\n+}\n /* INSN is a ZERO_EXTEND or SIGN_EXTEND of SRC to DEST.\n    Look if SRC dies there, and if it is only set once, by loading\n    it from memory.  If so, try to encorporate the zero/sign extension"}, {"sha": "f75ca1b3984cae1e4aa7a702a5fc1fdfd75aa955", "filename": "gcc/rtl.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1230327b00075291801211e9edc06fd96a1cc0a1/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1230327b00075291801211e9edc06fd96a1cc0a1/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=1230327b00075291801211e9edc06fd96a1cc0a1", "patch": "@@ -1373,8 +1373,4 @@ extern void init_alias_once\t\tPROTO ((void));\n extern void init_alias_analysis\t\tPROTO ((void));\n extern void end_alias_analysis\t\tPROTO ((void));\n \n-/* In local-alloc.c */\n-extern int optimize_reg_copy_1  \tPROTO((rtx, rtx, rtx));\n-extern void optimize_reg_copy_2 \tPROTO((rtx, rtx, rtx));\n-\n #endif /* _RTL_H */"}, {"sha": "ab45028d07dd4bc49b0167a2af9fae1702530f02", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1230327b00075291801211e9edc06fd96a1cc0a1/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1230327b00075291801211e9edc06fd96a1cc0a1/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=1230327b00075291801211e9edc06fd96a1cc0a1", "patch": "@@ -3408,7 +3408,7 @@ rest_of_compilation (decl)\n \n   /* Register allocation pre-pass, to reduce number of moves\n      necessary for two-address machines.  */\n-  if (optimize > 0 && flag_regmove)\n+  if (optimize > 0 && (flag_regmove || flag_expensive_optimizations))\n     {\n       if (regmove_dump)\n \topen_dump_file (\".regmove\", decl_printable_name (decl, 2));"}]}