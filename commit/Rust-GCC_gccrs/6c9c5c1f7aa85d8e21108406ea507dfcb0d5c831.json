{"sha": "6c9c5c1f7aa85d8e21108406ea507dfcb0d5c831", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmM5YzVjMWY3YWE4NWQ4ZTIxMTA4NDA2ZWE1MDdkZmNiMGQ1YzgzMQ==", "commit": {"author": {"name": "Anthony Green", "email": "green@cygnus.com", "date": "1999-07-25T10:12:49Z"}, "committer": {"name": "Anthony Green", "email": "green@gcc.gnu.org", "date": "1999-07-25T10:12:49Z"}, "message": "gjavah.c (print_stub): New function.\n\n        * gjavah.c (print_stub): New function.\n        (METHOD_IS_NATIVE): New macro.\n        (print_mangled_classname): Make static.\n        (HANDLE_END_FIELD): Don't emit fields during stub generation.\n        (process_file): Perform stub generation.\n        (HANDLE_METHOD): Don't emit class decls during stub\n        generation.\n        (HANDLE_END_METHOD): Take into account stub generation.\n        (print_method_info): Handle stub generation.\n        (print_stub): New function.\n        (print_cxx_classname): Make signature consistant with others.\n        (help): Describe -stubs option.\n        (main): Create stub file.\n        (version): Use version.c.\n        (print_full_cxx_name): New function.\n        (print_c_decl): Use print_full_cxx_name.\n\nFrom-SVN: r28236", "tree": {"sha": "0984a5702f9f86b72f2fe325183cb944d50fa044", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0984a5702f9f86b72f2fe325183cb944d50fa044"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c9c5c1f7aa85d8e21108406ea507dfcb0d5c831", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c9c5c1f7aa85d8e21108406ea507dfcb0d5c831", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c9c5c1f7aa85d8e21108406ea507dfcb0d5c831", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c9c5c1f7aa85d8e21108406ea507dfcb0d5c831/comments", "author": null, "committer": null, "parents": [{"sha": "a08b508225e8b9194328642001208bf0170e969a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a08b508225e8b9194328642001208bf0170e969a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a08b508225e8b9194328642001208bf0170e969a"}], "stats": {"total": 348, "additions": 251, "deletions": 97}, "files": [{"sha": "cc4ce9872a182af2b6bec423453a954c4129ba6a", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c9c5c1f7aa85d8e21108406ea507dfcb0d5c831/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c9c5c1f7aa85d8e21108406ea507dfcb0d5c831/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=6c9c5c1f7aa85d8e21108406ea507dfcb0d5c831", "patch": "@@ -1,3 +1,22 @@\n+1999-07-25  Anthony Green  <green@cygnus.com>\n+\n+\t* gjavah.c (print_stub): New function.\n+\t(METHOD_IS_NATIVE): New macro.\n+\t(print_mangled_classname): Make static.\n+\t(HANDLE_END_FIELD): Don't emit fields during stub generation.\n+\t(process_file): Perform stub generation.\n+\t(HANDLE_METHOD): Don't emit class decls during stub\n+\tgeneration.\n+\t(HANDLE_END_METHOD): Take into account stub generation.\n+\t(print_method_info): Handle stub generation.\n+\t(print_stub): New function.\n+\t(print_cxx_classname): Make signature consistant with others.\n+\t(help): Describe -stubs option.\n+\t(main): Create stub file.\n+\t(version): Use version.c.\n+\t(print_full_cxx_name): New function.\n+\t(print_c_decl): Use print_full_cxx_name.\n+\n Thu Jul 22 12:41:12 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n \t* check-init.c (check_init): Handle MAX_EXPR."}, {"sha": "500aa2c817ed4c6df99944a1d25e0f6a31235a1d", "filename": "gcc/java/gjavah.c", "status": "modified", "additions": 232, "deletions": 97, "changes": 329, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c9c5c1f7aa85d8e21108406ea507dfcb0d5c831/gcc%2Fjava%2Fgjavah.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c9c5c1f7aa85d8e21108406ea507dfcb0d5c831/gcc%2Fjava%2Fgjavah.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fgjavah.c?ref=6c9c5c1f7aa85d8e21108406ea507dfcb0d5c831", "patch": "@@ -33,6 +33,8 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #include \"java-tree.h\"\n #include \"java-opcodes.h\"\n \n+#include \"version.c\"\n+\n /* The output file.  */\n FILE *out = NULL;\n \n@@ -88,6 +90,11 @@ static JCF_u2 last_access;\n #define METHOD_IS_FINAL(Class, Method) \\\n    (((Class) & ACC_FINAL) || ((Method) & (ACC_FINAL | ACC_PRIVATE)))\n \n+/* Pass this macro the flags for a method.  It will return true if the\n+   method is native.  */\n+#define METHOD_IS_NATIVE(Method) \\\n+   ((Method) & ACC_NATIVE)\n+\n /* We keep a linked list of all method names we have seen.  This lets\n    us determine if a method name and a field name are in conflict.  */\n struct method_name\n@@ -100,11 +107,15 @@ struct method_name\n /* List of method names we've seen.  */\n static struct method_name *method_name_list;\n \n-static void print_field_info PROTO ((FILE *, JCF*, int, int, JCF_u2));\n-static void print_method_info PROTO ((FILE *, JCF*, int, int, JCF_u2));\n+static void print_field_info PROTO ((FILE*, JCF*, int, int, JCF_u2));\n+static void print_mangled_classname PROTO ((FILE*, JCF*, const char*, int));\n+static int  print_cxx_classname PROTO ((FILE*, const char*, JCF*, int));\n+static void print_method_info PROTO ((FILE*, JCF*, int, int, JCF_u2));\n static void print_c_decl PROTO ((FILE*, JCF*, int, int, int, const char *));\n-static void decompile_method PROTO ((FILE *, JCF *, int));\n-static void add_class_decl PROTO ((FILE *, JCF *, JCF_u2));\n+static void print_stub PROTO ((FILE*, JCF*, int, int, int, const char *));\n+static void print_full_cxx_name PROTO ((FILE*, JCF*, int, int, int, const char *));\n+static void decompile_method PROTO ((FILE*, JCF*, int));\n+static void add_class_decl PROTO ((FILE*, JCF*, JCF_u2));\n \n static int java_float_finite PROTO ((jfloat));\n static int java_double_finite PROTO ((jdouble));\n@@ -130,13 +141,13 @@ static int method_pass;\n #define HANDLE_END_FIELD()\t\t\t\t\t\t      \\\n   if (field_pass)\t\t\t\t\t\t\t      \\\n     {\t\t\t\t\t\t\t\t\t      \\\n-      if (out)\t\t\t\t\t\t\t\t      \\\n+      if (out && ! stubs)\t\t\t\t\t\t      \\\n \tprint_field_info (out, jcf, current_field_name,\t\t\t      \\\n \t\t\t  current_field_signature,\t\t\t      \\\n \t\t\t  current_field_flags);\t\t\t\t      \\\n     }\t\t\t\t\t\t\t\t\t      \\\n   else\t\t\t\t\t\t\t\t\t      \\\n-    add_class_decl (out, jcf, current_field_signature);\n+    if (! stubs) add_class_decl (out, jcf, current_field_signature);\n \n #define HANDLE_CONSTANTVALUE(VALUEINDEX) current_field_value = (VALUEINDEX)\n \n@@ -151,14 +162,14 @@ static int method_printed = 0;\n         print_method_info (out, jcf, NAME, SIGNATURE, ACCESS_FLAGS);\t      \\\n     }\t\t\t\t\t\t\t\t\t      \\\n   else\t\t\t\t\t\t\t\t\t      \\\n-    add_class_decl (out, jcf, SIGNATURE);\n+    if (! stubs) add_class_decl (out, jcf, SIGNATURE);\n \n #define HANDLE_CODE_ATTRIBUTE(MAX_STACK, MAX_LOCALS, CODE_LENGTH) \\\n   if (out && method_declared) decompile_method (out, jcf, CODE_LENGTH);\n \n static int decompiled = 0;\n #define HANDLE_END_METHOD() \\\n-  if (out && method_printed) fputs (decompiled ? \"\\n\" : \";\\n\", out);\n+  if (out && method_printed) fputs (decompiled || stubs ? \"\\n\" : \";\\n\", out);\n \n #include \"jcf-reader.c\"\n \n@@ -562,24 +573,36 @@ DEFUN(print_method_info, (stream, jcf, name_index, sig_index, flags),\n \treturn;\n     }\n \n-  method_printed = 1;\n-  generate_access (stream, flags);\n-\n-  fputs (\"  \", out);\n-  if ((flags & ACC_STATIC))\n-    fputs (\"static \", out);\n-  else if (! METHOD_IS_FINAL (jcf->access_flags, flags))\n+  if (! stubs)\n     {\n-      /* Don't print `virtual' if we have a constructor.  */\n-      if (! is_init)\n-\tfputs (\"virtual \", out);\n-    }\n-  print_c_decl (out, jcf, name_index, sig_index, is_init, override);\n+      method_printed = 1;\n \n-  if ((flags & ACC_ABSTRACT))\n-    fputs (\" = 0\", out);\n+      generate_access (stream, flags);\n+      \n+      fputs (\"  \", out);\n+      if ((flags & ACC_STATIC))\n+\tfputs (\"static \", out);\n+      else if (! METHOD_IS_FINAL (jcf->access_flags, flags))\n+\t{\n+\t  /* Don't print `virtual' if we have a constructor.  */\n+\t  if (! is_init)\n+\t    fputs (\"virtual \", out);\n+\t}\n+      print_c_decl (out, jcf, name_index, sig_index, is_init, override);\n+      \n+      if ((flags & ACC_ABSTRACT))\n+\tfputs (\" = 0\", out);\n+      else\n+\tmethod_declared = 1;\n+    }\n   else\n-    method_declared = 1;\n+    {\n+      if (METHOD_IS_NATIVE(flags)) \n+\t{\n+\t  method_printed = 1;\n+\t  print_stub (out, jcf, name_index, sig_index, is_init, override);\n+\t}\n+    }\n }\n \n /* Try to decompile a method body.  Right now we just try to handle a\n@@ -791,40 +814,121 @@ DEFUN(print_c_decl, (stream, jcf, name_index, signature_index, is_init,\n       /* Now print the name of the thing.  */\n       if (need_space)\n \tfputs (\" \", stream);\n-      if (name_override)\n-\tfputs (name_override, stream);\n-      else if (name_index)\n+      print_full_cxx_name (stream, jcf, name_index, \n+\t\t\t   signature_index, is_init, name_override);\n+    }\n+}\n+\n+// Print the unqualified method name followed by the signature.\n+static void\n+DEFUN(print_full_cxx_name, (stream, jcf, name_index, signature_index, is_init, name_override),\n+      FILE* stream AND JCF* jcf\n+      AND int name_index AND int signature_index AND int is_init \n+      AND const char *name_override)\n+{\n+  int length = JPOOL_UTF_LENGTH (jcf, signature_index);\n+  unsigned char *str0 = JPOOL_UTF_DATA (jcf, signature_index);\n+  register  unsigned char *str = str0;\n+  unsigned char *limit = str + length;\n+  int need_space = 0;\n+  int is_method = str[0] == '(';\n+  unsigned char *next;\n+\n+  if (name_override)\n+    fputs (name_override, stream);\n+  else if (name_index)\n+    {\n+      /* Declare constructors specially.  */\n+      if (is_init)\n+\tprint_base_classname (stream, jcf, jcf->this_class);\n+      else\n+\tprint_name (stream, jcf, name_index);\n+    }\n+  \n+  if (is_method)\n+    {\n+      /* Have a method or a constructor.  Print signature pieces\n+\t until done.  */\n+      fputs (\" (\", stream);\n+      str = str0 + 1;\n+      while (str < limit && *str != ')')\n \t{\n-\t  /* Declare constructors specially.  */\n-\t  if (is_init)\n-\t    print_base_classname (stream, jcf, jcf->this_class);\n-\t  else\n-\t    print_name (stream, jcf, name_index);\n+\t  next = decode_signature_piece (stream, str, limit, &need_space);\n+\t  if (! next)\n+\t    {\n+\t      fprintf (stderr, \"unparseable signature: `%s'\\n\", str0);\n+\t      found_error = 1;\n+\t      return;\n+\t    }\n+\t  \n+\t  if (next < limit && *next != ')')\n+\t    fputs (\", \", stream);\n+\t  str = next;\n \t}\n+      \n+      fputs (\")\", stream);\n+    }\n+}\n+      \n+static void\n+DEFUN(print_stub, (stream, jcf, name_index, signature_index, is_init,\n+\t\t     name_override),\n+      FILE* stream AND JCF* jcf\n+      AND int name_index AND int signature_index\n+      AND int is_init AND const char *name_override)\n+{\n+  if (JPOOL_TAG (jcf, signature_index) != CONSTANT_Utf8)\n+    {\n+      fprintf (stream, \"<not a UTF8 constant>\");\n+      found_error = 1;\n+    }\n+  else\n+    {\n+      int length = JPOOL_UTF_LENGTH (jcf, signature_index);\n+      unsigned char *str0 = JPOOL_UTF_DATA (jcf, signature_index);\n+      register  unsigned char *str = str0;\n+      unsigned char *limit = str + length;\n+      int need_space = 0;\n+      int is_method = str[0] == '(';\n+      unsigned char *next;\n \n-      if (is_method)\n+      /* If printing a method, skip to the return signature and print\n+\t that first.  However, there is no return value if this is a\n+\t constructor.  */\n+      if (is_method && ! is_init)\n \t{\n-\t  /* Have a method or a constructor.  Print signature pieces\n-\t     until done.  */\n-\t  fputs (\" (\", stream);\n-\t  str = str0 + 1;\n-\t  while (str < limit && *str != ')')\n+\t  while (str < limit)\n \t    {\n-\t      next = decode_signature_piece (stream, str, limit, &need_space);\n-\t      if (! next)\n-\t\t{\n-\t\t  fprintf (stderr, \"unparseable signature: `%s'\\n\", str0);\n-\t\t  found_error = 1;\n-\t\t  return;\n-\t\t}\n-\n-\t      if (next < limit && *next != ')')\n-\t\tfputs (\", \", stream);\n-\t      str = next;\n+\t      int ch = *str++;\n+\t      if (ch == ')')\n+\t\tbreak;\n \t    }\n+\t}\n \n-\t  fputs (\")\", stream);\n+      /* If printing a field or an ordinary method, then print the\n+\t \"return value\" now.  */\n+      if (! is_method || ! is_init)\n+\t{\n+\t  next = decode_signature_piece (stream, str, limit, &need_space);\n+\t  if (! next)\n+\t    {\n+\t      fprintf (stderr, \"unparseable signature: `%s'\\n\", str0);\n+\t      found_error = 1;\n+\t      return;\n+\t    }\n \t}\n+\n+      /* Now print the name of the thing.  */\n+      print_cxx_classname (stream, \"\\n\", jcf, jcf->this_class);\n+      fputs (\"::\", stream);\n+      print_full_cxx_name (stream, jcf, name_index, \n+\t\t\t   signature_index, is_init, name_override);\n+      fputs (\"\\n{\\n  JvFail (\\\"\", stream);\n+      print_cxx_classname (stream, \"\", jcf, jcf->this_class);\n+      fputs (\"::\", stream);\n+      print_full_cxx_name (stream, jcf, name_index, \n+\t\t\t   signature_index, is_init, name_override);\n+      fputs (\" not implemented\\\");\\n}\\n\\n\", stream);\n     }\n }\n \n@@ -846,7 +950,7 @@ DEFUN(print_mangled_classname, (stream, jcf, prefix, index),\n static int\n print_cxx_classname (stream, prefix, jcf, index)\n      FILE *stream;\n-     char *prefix;\n+     const char *prefix;\n      JCF *jcf;\n      int index;\n {\n@@ -1204,30 +1308,49 @@ DEFUN(process_file, (jcf, out),\n   jcf_parse_class (jcf);\n \n   if (written_class_count++ == 0 && out)\n-    fputs (\"// DO NOT EDIT THIS FILE - it is machine generated -*- c++ -*-\\n\\n\",\n-\t   out);\n+    if (! stubs)\n+      fputs (\"// DO NOT EDIT THIS FILE - it is machine generated -*- c++ -*-\\n\\n\",\n+\t     out);\n+    else\n+      {\n+\tfputs (\"// This file was created by `gcjh -stubs'.  It is -*- c++ -*-.\n+//\n+// This file is intended to give you a head start on implementing native \n+// methods using CNI.  \n+// Be aware: running `gcjh -stubs' once more for this class may overwrite any \n+// edits you have made to this file.\\n\\n\", out);\n+      }\n \n   if (out)\n     {\n-      print_mangled_classname (out, jcf, \"#ifndef __\", jcf->this_class);\n-      fprintf (out, \"__\\n\");\n-\n-      print_mangled_classname (out, jcf, \"#define __\", jcf->this_class);\n-      fprintf (out, \"__\\n\\n\");\n-\n-      /* We do this to ensure that inline methods won't be `outlined'\n-\t by g++.  This works as long as method and fields are not\n-\t added by the user.  */\n-      fprintf (out, \"#pragma interface\\n\");\n-    }\n-\n-  if (jcf->super_class && out)\n-    {\n-      int super_length;\n-      unsigned char *supername = super_class_name (jcf, &super_length);\n-\n-      fputs (\"\\n\", out);\n-      print_include (out, supername, super_length);\n+      if (! stubs)\n+\t{\n+\t  print_mangled_classname (out, jcf, \"#ifndef __\", jcf->this_class);\n+\t  fprintf (out, \"__\\n\");\n+\t  \n+\t  print_mangled_classname (out, jcf, \"#define __\", jcf->this_class);\n+\t  fprintf (out, \"__\\n\\n\");\n+\t  \n+\t  /* We do this to ensure that inline methods won't be `outlined'\n+\t     by g++.  This works as long as method and fields are not\n+\t     added by the user.  */\n+\t  fprintf (out, \"#pragma interface\\n\");\n+\t  \n+\t  if (jcf->super_class)\n+\t    {\n+\t      int super_length;\n+\t      unsigned char *supername = super_class_name (jcf, &super_length);\n+\t      \n+\t      fputs (\"\\n\", out);\n+\t      print_include (out, supername, super_length);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* Strip off the \".class\" portion of the name when printing\n+\t     the include file name.  */\n+\t  print_include (out, jcf->classname, strlen (jcf->classname) - 6);\n+\t}\n     }\n \n   /* We want to parse the methods first.  But we need to find where\n@@ -1246,31 +1369,37 @@ DEFUN(process_file, (jcf, out),\n   if (out)\n     {\n       fputs (\"\\n\", out);\n-      print_class_decls (out, jcf, jcf->this_class);\n+\n+      if (! stubs)\n+\tprint_class_decls (out, jcf, jcf->this_class);\n \n       for (i = 0; i < prepend_count; ++i)\n \tfprintf (out, \"%s\\n\", prepend_specs[i]);\n       if (prepend_count > 0)\n \tfputc ('\\n', out);\n-    }\n-\n-  if (out && ! print_cxx_classname (out, \"class \", jcf, jcf->this_class))\n-    {\n-      fprintf (stderr, \"class is of array type\\n\");\n-      found_error = 1;\n-      return;\n-    }\n-  if (out && jcf->super_class)\n-    {\n-      if (! print_cxx_classname (out, \" : public \", jcf, jcf->super_class))\n+      \n+      if (! stubs)\n \t{\n-\t  fprintf (stderr, \"base class is of array type\\n\");\n-\t  found_error = 1;\n-\t  return;\n+\t  if (! print_cxx_classname (out, \"class \", jcf, jcf->this_class))\n+\t    {\n+\t      fprintf (stderr, \"class is of array type\\n\");\n+\t      found_error = 1;\n+\t      return;\n+\t    }\n+\t  if (jcf->super_class)\n+\t    {\n+\t      if (! print_cxx_classname (out, \" : public \", \n+\t\t\t\t\t jcf, jcf->super_class))\n+\t\t{\n+\t\t  fprintf (stderr, \"base class is of array type\\n\");\n+\t\t  found_error = 1;\n+\t\t  return;\n+\t\t}\n+\t    }\n+\n+\t  fputs (\"\\n{\\n\", out);\n \t}\n     }\n-  if (out)\n-    fputs (\"\\n{\\n\", out);\n \n   /* Now go back for second pass over methods and fields.  */\n   JCF_SEEK (jcf, method_start);\n@@ -1297,15 +1426,20 @@ DEFUN(process_file, (jcf, out),\n       for (i = 0; i < add_count; ++i)\n \tfprintf (out, \"  %s\\n\", add_specs[i]);\n \n-      fputs (\"};\\n\", out);\n+      if (! stubs)\n+\tfputs (\"};\\n\", out);\n \n       if (append_count > 0)\n \tfputc ('\\n', out);\n       for (i = 0; i < append_count; ++i)\n \tfprintf (out, \"%s\\n\", append_specs[i]);\n \n-      print_mangled_classname (out, jcf, \"\\n#endif /* __\", jcf->this_class);\n-      fprintf (out, \"__ */\\n\");\n+      if (!stubs)\n+\t{\n+\t  print_mangled_classname (out, jcf, \n+\t\t\t\t   \"\\n#endif /* __\", jcf->this_class);\n+\t  fprintf (out, \"__ */\\n\");\n+\t}\n     }\n }\n \n@@ -1327,6 +1461,7 @@ help ()\n   printf (\"  -d DIRECTORY            Set output directory name\\n\");\n   printf (\"  --help                  Print this help, then exit\\n\");\n   printf (\"  -o FILE                 Set output file name\\n\");\n+  printf (\"  -stubs                  Generate a C++ implementation stub file\\n\");\n   printf (\"  -td DIRECTORY           Set temporary directory name\\n\");\n   printf (\"  -v, --verbose           Print extra information while running\\n\");\n   printf (\"  --version               Print version number, then exit\\n\");\n@@ -1346,8 +1481,8 @@ static void\n version ()\n {\n   /* FIXME: use version.c?  */\n-  printf (\"gcjh (GNU gcc) 0.0\\n\\n\");\n-  printf (\"Copyright (C) 1998 Free Software Foundation, Inc.\\n\");\n+  printf (\"gcjh (%s)\\n\\n\", version_string);\n+  printf (\"Copyright (C) 1998, 1999 Free Software Foundation, Inc.\\n\");\n   printf (\"This is free software; see the source for copying conditions.  There is NO\\n\");\n   printf (\"warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\\n\");\n   exit (0);\n@@ -1548,7 +1683,7 @@ DEFUN(main, (argc, argv),\n \t{\n \t  int dir_len = strlen (output_directory);\n \t  int i, classname_length = strlen (classname);\n-\t  current_output_file = (char*) ALLOC (dir_len + classname_length + 4);\n+\t  current_output_file = (char*) ALLOC (dir_len + classname_length + 5);\n \t  strcpy (current_output_file, output_directory);\n \t  if (dir_len > 0 && output_directory[dir_len-1] != '/')\n \t    current_output_file[dir_len++] = '/';\n@@ -1574,7 +1709,8 @@ DEFUN(main, (argc, argv),\n \t\t  jcf_dependency_set_dep_file (current_output_file);\n \t\t}\n \t    }\n-\t  strcpy (current_output_file + dir_len, \".h\");\n+\t  strcpy (current_output_file + dir_len, \n+\t\t  stubs ? \".cc\" : \".h\");\n \t  jcf_dependency_set_target (current_output_file);\n \t  if (! suppress_output)\n \t    {\n@@ -1601,10 +1737,9 @@ DEFUN(main, (argc, argv),\n \n /* TODO:\n \n- * Do whatever the javah -stubs flag does.\n-\n  * Emit \"structure forward declarations\" when needed.\n \n  * Generate C headers, like javah\n \n  */\n+"}]}