{"sha": "28704289327e4295928663b5bab7953718f71bc1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjg3MDQyODkzMjdlNDI5NTkyODY2M2I1YmFiNzk1MzcxOGY3MWJjMQ==", "commit": {"author": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2011-11-07T21:28:50Z"}, "committer": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2011-11-07T21:28:50Z"}, "message": "PR c++/45114 - Support C++11 alias-declaration\n\ngcc/cp/\n\n\t* cp-tree.h (TYPE_DECL_ALIAS_P, TYPE_ALIAS_P)\n\t(DECL_TYPE_TEMPLATE_P, DECL_ALIAS_TEMPLATE_P): New accessor\n\tmacros.\n\t(TYPE_TEMPLATE_INFO): Get template info of an alias template\n\tspecializations from its TYPE_DECL.\n\t(SET_TYPE_TEMPLATE_INFO): Set template info of alias template\n\tspecializations into its TYPE_DECL.\n\t(DECL_CLASS_TEMPLATE_P): Re-write using the new\n\tDECL_TYPE_TEMPLATE_P.\n\t(enum cp_decl_spec): Add new ds_alias enumerator.\n\t(alias_type_or_template_p, alias_template_specialization_p):\n\tDeclare new functions.\n\t* parser.c (cp_parser_alias_declaration): New static function.\n\t(cp_parser_check_decl_spec): Add \"using\" name for the `alias'\n\tdeclspec.\n\t(cp_parser_type_name): Update comment.  Support simple-template-id\n\trepresenting alias template specializations in c++0x mode.\n\t(cp_parser_qualifying_entity): Update comment.  Use\n\tcp_parser_type_name.\n\t(cp_parser_block_declaration): Handle alias-declaration in c++11.\n\tUpdate comment.\n\t(cp_parser_template_id): Handle specializations of alias\n\ttemplates.\n\t(cp_parser_member_declaration): Add alias-declaration production\n\tto comment.  Support alias-declarations.\n\t(cp_parser_template_declaration_after_export): Handle alias\n\ttemplates in c++11.\n\t* decl.c (make_typename_type, make_unbound_class_template): Accept\n\talias templates.\n\t(grokdeclarator): Set TYPE_DECL_ALIAS_P on alias\n\tdeclarations.\n\t* decl2.c (grokfield): Move template creation after setting up the\n\tTYPE_DECL of the alias, so that the TEMPLATE_DECL of the alias\n\ttemplate actually carries the right type-id of the alias\n\tdeclaration.\n\t* pt.c (alias_type_or_template_p)\n\t(alias_template_specialization_p): Define new public functions.\n\t(maybe_process_partial_specialization): Reject partial\n\tspecializations of alias templates.\n\t(primary_template_instantiation_p): Consider alias template\n\tinstantiations.\n\t(push_template_decl_real): Assert that TYPE_DECLs of alias\n\ttemplates are different from those of class template.  Store\n\ttemplate info onto the TYPE_DECL of the alias template.\n\t(convert_template_argument): Strip aliases from template\n\targuments.\n\t(lookup_template_class_1): Handle the creation of the\n\tspecialization of an alias template.\n\t(tsubst_decl): Create a substituted copy of the TYPE_DECL of an\n\tmember alias template.\n\t(tsubst): Handle substituting into the type of an alias template.\n\tHandle substituting UNBOUND_CLASS_TEMPLATE into\n\tBOUND_TEMPLATE_TEMPLATE_PARM.\n\t(do_type_instantiation): Better diagnostics when trying to\n\texplicitely instantiate a non-class template.\n\t* search.c (lookup_field_1, lookup_field_r): Support looking up\n\talias templates.\n\t* semantics.c (finish_template_type): For instantiations of alias\n\ttemplates, return the TYPE_DECL of the actual alias and not the\n\tone of the aliased type.\n\t* error.c (dump_alias_template_specialization): New static\n\tfunction.\n\t(dump_type): Handle printing of alias templates and their\n\tspecializations.  templates.\n\t(dump_aggr_type): For specialization of alias templates, fetch\n\targuments from the right place.\n\t(dump_decl): Print an alias-declaration like `using decl = type;'\n\t(dump_template_decl):  Support printing of alias templates.\n\ngcc/testsuite/\n\n\t* g++.dg/cpp0x/alias-decl-0.C: New test case.\n\t* g++.dg/cpp0x/alias-decl-1.C: Likewise.\n\t* g++.dg/cpp0x/alias-decl-3.C: Likewise.\n\t* g++.dg/cpp0x/alias-decl-4.C: Likewise.\n\t* g++.dg/cpp0x/alias-decl-6.C: Likewise.\n\t* g++.dg/cpp0x/alias-decl-7.C: Likewise.\n\t* g++.dg/cpp0x/alias-decl-8.C: Likewise.\n\t* g++.dg/cpp0x/alias-decl-9.C: Likewise.\n\t* g++.dg/cpp0x/alias-decl-10.C: Likewise.\n\t* g++.dg/ext/alias-decl-attr1.C: Likewise.\n\t* g++.dg/ext/alias-decl-attr2.C: Likewise.\n\t* g++.dg/ext/alias-decl-attr3.C: Likewise.\n\t* g++.dg/ext/alias-decl-attr4.C: Likewise.\n\nFrom-SVN: r181118", "tree": {"sha": "2390bb8c86da49566597c517f894d572f55a9d35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2390bb8c86da49566597c517f894d572f55a9d35"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/28704289327e4295928663b5bab7953718f71bc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28704289327e4295928663b5bab7953718f71bc1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28704289327e4295928663b5bab7953718f71bc1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28704289327e4295928663b5bab7953718f71bc1/comments", "author": null, "committer": null, "parents": [{"sha": "bfd08c89025e9b3f2d09ddf6a4555160cedb294f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfd08c89025e9b3f2d09ddf6a4555160cedb294f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfd08c89025e9b3f2d09ddf6a4555160cedb294f"}], "stats": {"total": 967, "additions": 898, "deletions": 69}, "files": [{"sha": "72aa0513d96553e834c1ca624dec4c104cd68e3a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28704289327e4295928663b5bab7953718f71bc1/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28704289327e4295928663b5bab7953718f71bc1/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=28704289327e4295928663b5bab7953718f71bc1", "patch": "@@ -1,3 +1,77 @@\n+2011-11-07  Jason Merrill  <jason@redhat.com>\n+\t    Dodji Seketeli  <dodji@redhat.com>\n+\n+\tSupport C++11 alias-declaration\n+\tPR c++/45114\n+\t* cp-tree.h (TYPE_DECL_ALIAS_P, TYPE_ALIAS_P)\n+\t(DECL_TYPE_TEMPLATE_P, DECL_ALIAS_TEMPLATE_P): New accessor\n+\tmacros.\n+\t(TYPE_TEMPLATE_INFO): Get template info of an alias template\n+\tspecializations from its TYPE_DECL.\n+\t(SET_TYPE_TEMPLATE_INFO): Set template info of alias template\n+\tspecializations into its TYPE_DECL.\n+\t(DECL_CLASS_TEMPLATE_P): Re-write using the new\n+\tDECL_TYPE_TEMPLATE_P.\n+\t(enum cp_decl_spec): Add new ds_alias enumerator.\n+\t(alias_type_or_template_p, alias_template_specialization_p):\n+\tDeclare new functions.\n+\t* parser.c (cp_parser_alias_declaration): New static function.\n+\t(cp_parser_check_decl_spec): Add \"using\" name for the `alias'\n+\tdeclspec.\n+\t(cp_parser_type_name): Update comment.  Support simple-template-id\n+\trepresenting alias template specializations in c++0x mode.\n+\t(cp_parser_qualifying_entity): Update comment.  Use\n+\tcp_parser_type_name.\n+\t(cp_parser_block_declaration): Handle alias-declaration in c++11.\n+\tUpdate comment.\n+\t(cp_parser_template_id): Handle specializations of alias\n+\ttemplates.\n+\t(cp_parser_member_declaration): Add alias-declaration production\n+\tto comment.  Support alias-declarations.\n+\t(cp_parser_template_declaration_after_export): Handle alias\n+\ttemplates in c++11.\n+\t* decl.c (make_typename_type, make_unbound_class_template): Accept\n+\talias templates.\n+\t(grokdeclarator): Set TYPE_DECL_ALIAS_P on alias\n+\tdeclarations.\n+\t* decl2.c (grokfield): Move template creation after setting up the\n+\tTYPE_DECL of the alias, so that the TEMPLATE_DECL of the alias\n+\ttemplate actually carries the right type-id of the alias\n+\tdeclaration.\n+\t* pt.c (alias_type_or_template_p)\n+\t(alias_template_specialization_p): Define new public functions.\n+\t(maybe_process_partial_specialization): Reject partial\n+\tspecializations of alias templates.\n+\t(primary_template_instantiation_p): Consider alias template\n+\tinstantiations.\n+\t(push_template_decl_real): Assert that TYPE_DECLs of alias\n+\ttemplates are different from those of class template.  Store\n+\ttemplate info onto the TYPE_DECL of the alias template.\n+\t(convert_template_argument): Strip aliases from template\n+\targuments.\n+\t(lookup_template_class_1): Handle the creation of the\n+\tspecialization of an alias template.\n+\t(tsubst_decl): Create a substituted copy of the TYPE_DECL of an\n+\tmember alias template.\n+\t(tsubst): Handle substituting into the type of an alias template.\n+\tHandle substituting UNBOUND_CLASS_TEMPLATE into\n+\tBOUND_TEMPLATE_TEMPLATE_PARM.\n+\t(do_type_instantiation): Better diagnostics when trying to\n+\texplicitely instantiate a non-class template.\n+\t* search.c (lookup_field_1, lookup_field_r): Support looking up\n+\talias templates.\n+\t* semantics.c (finish_template_type): For instantiations of alias\n+\ttemplates, return the TYPE_DECL of the actual alias and not the\n+\tone of the aliased type.\n+\t* error.c (dump_alias_template_specialization): New static\n+\tfunction.\n+\t(dump_type): Handle printing of alias templates and their\n+\tspecializations.  templates.\n+\t(dump_aggr_type): For specialization of alias templates, fetch\n+\targuments from the right place.\n+\t(dump_decl): Print an alias-declaration like `using decl = type;'\n+\t(dump_template_decl):  Support printing of alias templates.\n+\n 2011-11-07  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/35688"}, {"sha": "177f10084afb52a43e25d92ee83179823cc1b98a", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 38, "deletions": 8, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28704289327e4295928663b5bab7953718f71bc1/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28704289327e4295928663b5bab7953718f71bc1/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=28704289327e4295928663b5bab7953718f71bc1", "patch": "@@ -139,6 +139,7 @@ c-common.h, not after.\n    5: DECL_INTERFACE_KNOWN.\n    6: DECL_THIS_STATIC (in VAR_DECL or FUNCTION_DECL).\n       DECL_FIELD_IS_BASE (in FIELD_DECL)\n+      TYPE_DECL_ALIAS_P (in TYPE_DECL)\n    7: DECL_DEAD_FOR_LOCAL (in VAR_DECL).\n       DECL_THUNK_P (in a member FUNCTION_DECL)\n       DECL_NORMAL_CAPTURE_P (in FIELD_DECL)\n@@ -2541,6 +2542,17 @@ extern void decl_shadowed_for_var_insert (tree, tree);\n #define DECL_PENDING_INLINE_INFO(NODE) \\\n   (LANG_DECL_FN_CHECK (NODE)->u.pending_inline_info)\n \n+/* Nonzero for TYPE_DECL means that it was written 'using name = type'.  */\n+#define TYPE_DECL_ALIAS_P(NODE) \\\n+  DECL_LANG_FLAG_6 (TYPE_DECL_CHECK (NODE))\n+\n+/* Nonzero for a type which is an alias for another type; i.e, a type\n+   which declaration was written 'using name-of-type =\n+   another-type'.  */\n+#define TYPE_ALIAS_P(NODE) \\\n+  (TYPE_P (NODE) \\\n+   && TYPE_DECL_ALIAS_P (TYPE_NAME (NODE)))\n+\n /* For a class type: if this structure has many fields, we'll sort them\n    and put them into a TREE_VEC.  */\n #define CLASSTYPE_SORTED_FIELDS(NODE) \\\n@@ -2597,16 +2609,20 @@ extern void decl_shadowed_for_var_insert (tree, tree);\n    ? ENUM_TEMPLATE_INFO (NODE) :\t\t\t\\\n    (TREE_CODE (NODE) == BOUND_TEMPLATE_TEMPLATE_PARM\t\\\n     ? TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (NODE) :\t\\\n-    (TYPE_LANG_SPECIFIC (NODE)\t\t\t\t\\\n+    ((CLASS_TYPE_P (NODE) && !TYPE_ALIAS_P (NODE))\t\\\n      ? CLASSTYPE_TEMPLATE_INFO (NODE)\t\t\t\\\n-     : NULL_TREE)))\n+     : (DECL_LANG_SPECIFIC (TYPE_NAME (NODE))\t\t\\\n+\t? (DECL_TEMPLATE_INFO (TYPE_NAME (NODE)))\t\\\n+\t: NULL_TREE))))\n \n /* Set the template information for an ENUMERAL_, RECORD_, or\n    UNION_TYPE to VAL.  */\n-#define SET_TYPE_TEMPLATE_INFO(NODE, VAL)\t\\\n-  (TREE_CODE (NODE) == ENUMERAL_TYPE\t\t\\\n-   ? (ENUM_TEMPLATE_INFO (NODE) = (VAL))\t\\\n-   : (CLASSTYPE_TEMPLATE_INFO (NODE) = (VAL)))\n+#define SET_TYPE_TEMPLATE_INFO(NODE, VAL)\t\t\t\t\\\n+  (TREE_CODE (NODE) == ENUMERAL_TYPE\t\t\t\t\t\\\n+   ? (ENUM_TEMPLATE_INFO (NODE) = (VAL))\t\t\t\t\\\n+   : ((CLASS_TYPE_P (NODE) && !TYPE_ALIAS_P (NODE))\t\t\t\\\n+      ? (CLASSTYPE_TEMPLATE_INFO (NODE) = (VAL))\t\t\t\\\n+      : (DECL_TEMPLATE_INFO (TYPE_NAME (NODE)) = (VAL))))\n \n #define TI_TEMPLATE(NODE) TREE_TYPE (TEMPLATE_INFO_CHECK (NODE))\n #define TI_ARGS(NODE) TREE_CHAIN (TEMPLATE_INFO_CHECK (NODE))\n@@ -3620,12 +3636,23 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n    && !DECL_UNBOUND_CLASS_TEMPLATE_P (NODE) \\\n    && TREE_CODE (DECL_TEMPLATE_RESULT (NODE)) == FUNCTION_DECL)\n \n-/* Nonzero for a DECL that represents a template class.  */\n-#define DECL_CLASS_TEMPLATE_P(NODE)\t\t\t\t\\\n+/* Nonzero for a DECL that represents a class template or alias\n+   template.  */\n+#define DECL_TYPE_TEMPLATE_P(NODE)\t\t\t\t\\\n   (TREE_CODE (NODE) == TEMPLATE_DECL\t\t\t\t\\\n    && DECL_TEMPLATE_RESULT (NODE) != NULL_TREE\t\t\t\\\n+   && TREE_CODE (DECL_TEMPLATE_RESULT (NODE)) == TYPE_DECL)\n+\n+/* Nonzero for a DECL that represents a class template.  */\n+#define DECL_CLASS_TEMPLATE_P(NODE)\t\t\t\t\\\n+  (DECL_TYPE_TEMPLATE_P (NODE)\t\t\t\t\t\\\n    && DECL_IMPLICIT_TYPEDEF_P (DECL_TEMPLATE_RESULT (NODE)))\n \n+/* Nonzero for a TEMPLATE_DECL that represents an alias template.  */\n+#define DECL_ALIAS_TEMPLATE_P(NODE)\t\t\t\\\n+  (DECL_TYPE_TEMPLATE_P (NODE)\t\t\t\t\\\n+   && !DECL_ARTIFICIAL (DECL_TEMPLATE_RESULT (NODE)))\n+\n /* Nonzero for a NODE which declares a type.  */\n #define DECL_DECLARES_TYPE_P(NODE) \\\n   (TREE_CODE (NODE) == TYPE_DECL || DECL_CLASS_TEMPLATE_P (NODE))\n@@ -4580,6 +4607,7 @@ typedef enum cp_decl_spec {\n   ds_explicit,\n   ds_friend,\n   ds_typedef,\n+  ds_alias,\n   ds_constexpr,\n   ds_complex,\n   ds_thread,\n@@ -5283,6 +5311,8 @@ extern tree build_non_dependent_expr\t\t(tree);\n extern void make_args_non_dependent\t\t(VEC(tree,gc) *);\n extern bool reregister_specialization\t\t(tree, tree, tree);\n extern tree fold_non_dependent_expr\t\t(tree);\n+extern bool alias_type_or_template_p            (tree);\n+extern bool alias_template_specialization_p     (tree);\n extern bool explicit_class_specialization_p     (tree);\n extern int push_tinst_level                     (tree);\n extern void pop_tinst_level                     (void);"}, {"sha": "e4b91cc533bfba104e016f26d80a9935bb1d8d8a", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28704289327e4295928663b5bab7953718f71bc1/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28704289327e4295928663b5bab7953718f71bc1/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=28704289327e4295928663b5bab7953718f71bc1", "patch": "@@ -3270,7 +3270,7 @@ make_typename_type (tree context, tree name, enum tag_types tag_type,\n       return error_mark_node;\n     }\n \n-  if (want_template && !DECL_CLASS_TEMPLATE_P (t))\n+  if (want_template && !DECL_TYPE_TEMPLATE_P (t))\n     {\n       if (complain & tf_error)\n \terror (\"%<typename %T::%D%> names %q#T, which is not a class template\",\n@@ -3338,7 +3338,7 @@ make_unbound_class_template (tree context, tree name, tree parm_list,\n       if (tmpl && TREE_CODE (tmpl) == TYPE_DECL)\n \ttmpl = maybe_get_template_decl_from_type_decl (tmpl);\n \n-      if (!tmpl || !DECL_CLASS_TEMPLATE_P (tmpl))\n+      if (!tmpl || !DECL_TYPE_TEMPLATE_P (tmpl))\n \t{\n \t  if (complain & tf_error)\n \t    error (\"no class template named %q#T in %q#T\", name, context);\n@@ -9747,6 +9747,11 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t      memfn_quals != TYPE_UNQUALIFIED,\n \t\t      inlinep, friendp, raises != NULL_TREE);\n \n+      if (declspecs->specs[(int)ds_alias])\n+\t/* Acknowledge that this was written:\n+\t     `using analias = atype;'.  */\n+\tTYPE_DECL_ALIAS_P (decl) = 1;\n+\n       return decl;\n     }\n "}, {"sha": "3dc5a69df5445ba62d6f81666f09af62e2ef95c3", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28704289327e4295928663b5bab7953718f71bc1/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28704289327e4295928663b5bab7953718f71bc1/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=28704289327e4295928663b5bab7953718f71bc1", "patch": "@@ -848,9 +848,6 @@ grokfield (const cp_declarator *declarator,\n       DECL_NONLOCAL (value) = 1;\n       DECL_CONTEXT (value) = current_class_type;\n \n-      if (processing_template_decl)\n-\tvalue = push_template_decl (value);\n-\n       if (attrlist)\n \t{\n \t  int attrflags = 0;\n@@ -869,6 +866,12 @@ grokfield (const cp_declarator *declarator,\n           && TYPE_NAME (TYPE_MAIN_VARIANT (TREE_TYPE (value))) != value)\n \tset_underlying_type (value);\n \n+      /* It's important that push_template_decl below follows\n+\t set_underlying_type above so that the created template\n+\t carries the properly set type of VALUE.  */\n+      if (processing_template_decl)\n+\tvalue = push_template_decl (value);\n+\n       record_locally_defined_typedef (value);\n       return value;\n     }"}, {"sha": "841366f58fa7bf408698efdf951cece83f60d8c0", "filename": "gcc/cp/error.c", "status": "modified", "additions": 47, "deletions": 8, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28704289327e4295928663b5bab7953718f71bc1/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28704289327e4295928663b5bab7953718f71bc1/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=28704289327e4295928663b5bab7953718f71bc1", "patch": "@@ -61,6 +61,7 @@ static const char *op_to_string\t(enum tree_code);\n static const char *parm_to_string (int);\n static const char *type_to_string (tree, int);\n \n+static void dump_alias_template_specialization (tree, int);\n static void dump_type (tree, int);\n static void dump_typename (tree, int);\n static void dump_simple_decl (tree, tree, int);\n@@ -330,6 +331,23 @@ dump_template_bindings (tree parms, tree args, VEC(tree,gc)* typenames)\n     }\n }\n \n+/* Dump a human-readable equivalent of the alias template\n+   specialization of T.  */\n+\n+static void\n+dump_alias_template_specialization (tree t, int flags)\n+{\n+  tree name;\n+\n+  gcc_assert (alias_template_specialization_p (t));\n+\n+  name = TYPE_IDENTIFIER (t);\n+  pp_cxx_tree_identifier (cxx_pp, name);\n+  dump_template_parms (TYPE_TEMPLATE_INFO (t),\n+\t\t       /*primary=*/false,\n+\t\t       flags & ~TFF_TEMPLATE_HEADER);\n+}\n+\n /* Dump a human-readable equivalent of TYPE.  FLAGS controls the\n    format.  */\n \n@@ -344,10 +362,15 @@ dump_type (tree t, int flags)\n     {\n       tree decl = TYPE_NAME (t);\n       if ((flags & TFF_CHASE_TYPEDEF)\n-\t  || DECL_SELF_REFERENCE_P (decl)\n-\t  || (!flag_pretty_templates\n-\t      && DECL_LANG_SPECIFIC (decl) && DECL_TEMPLATE_INFO (decl)))\n+\t       || DECL_SELF_REFERENCE_P (decl)\n+\t       || (!flag_pretty_templates\n+\t\t   && DECL_LANG_SPECIFIC (decl) && DECL_TEMPLATE_INFO (decl)))\n \tt = strip_typedefs (t);\n+      else if (alias_template_specialization_p (t))\n+\t{\n+\t  dump_alias_template_specialization (t, flags);\n+\t  return;\n+\t}\n       else if (same_type_p (t, TREE_TYPE (decl)))\n \tt = decl;\n       else\n@@ -588,7 +611,10 @@ dump_aggr_type (tree t, int flags)\n \n   if (name)\n     {\n-      typdef = !DECL_ARTIFICIAL (name);\n+      typdef = (!DECL_ARTIFICIAL (name)\n+\t\t/* An alias specialization is not considered to be a\n+\t\t   typedef.  */\n+\t\t&& !alias_template_specialization_p (t));\n \n       if ((typdef\n \t   && ((flags & TFF_CHASE_TYPEDEF)\n@@ -613,7 +639,7 @@ dump_aggr_type (tree t, int flags)\n \t{\n \t  /* Because the template names are mangled, we have to locate\n \t     the most general template, and use that name.  */\n-\t  tree tpl = CLASSTYPE_TI_TEMPLATE (t);\n+\t  tree tpl = TYPE_TI_TEMPLATE (t);\n \n \t  while (DECL_TEMPLATE_INFO (tpl))\n \t    tpl = DECL_TI_TEMPLATE (tpl);\n@@ -952,6 +978,18 @@ dump_decl (tree t, int flags)\n \t  dump_type (TREE_TYPE (t), flags);\n \t  break;\n \t}\n+      if (TYPE_DECL_ALIAS_P (t)\n+\t  && (flags & TFF_DECL_SPECIFIERS\n+\t      || flags & TFF_CLASS_KEY_OR_ENUM))\n+\t{\n+\t  pp_cxx_ws_string (cxx_pp, \"using\");\n+\t  dump_decl (DECL_NAME (t), flags);\n+\t  pp_cxx_whitespace (cxx_pp);\n+\t  pp_cxx_ws_string (cxx_pp, \"=\");\n+\t  pp_cxx_whitespace (cxx_pp);\n+\t  dump_type (DECL_ORIGINAL_TYPE (t), flags);\n+\t  break;\n+\t}\n       if ((flags & TFF_DECL_SPECIFIERS)\n \t  && !DECL_SELF_REFERENCE_P (t))\n \tpp_cxx_ws_string (cxx_pp, \"typedef\");\n@@ -1196,13 +1234,14 @@ dump_template_decl (tree t, int flags)\n \t}\n     }\n \n-  if (DECL_TEMPLATE_RESULT (t)\n-      && TREE_CODE (DECL_TEMPLATE_RESULT (t)) == TYPE_DECL)\n+  if (DECL_CLASS_TEMPLATE_P (t))\n     dump_type (TREE_TYPE (t),\n \t       ((flags & ~TFF_CLASS_KEY_OR_ENUM) | TFF_TEMPLATE_NAME\n \t\t| (flags & TFF_DECL_SPECIFIERS ? TFF_CLASS_KEY_OR_ENUM : 0)));\n   else if (DECL_TEMPLATE_RESULT (t)\n-           && TREE_CODE (DECL_TEMPLATE_RESULT (t)) == VAR_DECL)\n+           && (TREE_CODE (DECL_TEMPLATE_RESULT (t)) == VAR_DECL\n+\t       /* Alias template.  */\n+\t       || DECL_TYPE_TEMPLATE_P (t)))\n     dump_decl (DECL_TEMPLATE_RESULT (t), flags | TFF_TEMPLATE_NAME);\n   else\n     {"}, {"sha": "fa0117ec3e44b3fd20dc6dd4548932ba24a82152", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 129, "deletions": 12, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28704289327e4295928663b5bab7953718f71bc1/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28704289327e4295928663b5bab7953718f71bc1/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=28704289327e4295928663b5bab7953718f71bc1", "patch": "@@ -1935,6 +1935,8 @@ static bool cp_parser_using_declaration\n   (cp_parser *, bool);\n static void cp_parser_using_directive\n   (cp_parser *);\n+static tree cp_parser_alias_declaration\n+  (cp_parser *);\n static void cp_parser_asm_definition\n   (cp_parser *);\n static void cp_parser_linkage_specification\n@@ -2509,6 +2511,7 @@ cp_parser_check_decl_spec (cp_decl_specifier_seq *decl_specs,\n \t    \"explicit\",\n \t    \"friend\",\n \t    \"typedef\",\n+\t    \"using\",\n             \"constexpr\",\n \t    \"__complex\",\n \t    \"__thread\"\n@@ -5135,7 +5138,7 @@ cp_parser_nested_name_specifier (cp_parser *parser,\n    this is either a class-name or a namespace-name (which corresponds\n    to the class-or-namespace-name production in the grammar). For\n    C++0x, it can also be a type-name that refers to an enumeration\n-   type.\n+   type or a simple-template-id.\n \n    TYPENAME_KEYWORD_P is TRUE iff the `typename' keyword is in effect.\n    TEMPLATE_KEYWORD_P is TRUE iff the `template' keyword is in effect.\n@@ -5211,8 +5214,8 @@ cp_parser_qualifying_entity (cp_parser *parser,\n       /* Parse tentatively.  */\n       cp_parser_parse_tentatively (parser);\n      \n-      /* Parse a typedef-name or enum-name.  */\n-      scope = cp_parser_nonclass_name (parser);\n+      /* Parse a type-name  */\n+      scope = cp_parser_type_name (parser);\n \n       /* \"If the name found does not designate a namespace or a class,\n \t enumeration, or dependent type, the program is ill-formed.\"\n@@ -10150,8 +10153,8 @@ cp_parser_block_declaration (cp_parser *parser,\n      namespace-alias-definition.  */\n   else if (token1->keyword == RID_NAMESPACE)\n     cp_parser_namespace_alias_definition (parser);\n-  /* If the next keyword is `using', we have either a\n-     using-declaration or a using-directive.  */\n+  /* If the next keyword is `using', we have a\n+     using-declaration, a using-directive, or an alias-declaration.  */\n   else if (token1->keyword == RID_USING)\n     {\n       cp_token *token2;\n@@ -10163,6 +10166,14 @@ cp_parser_block_declaration (cp_parser *parser,\n       token2 = cp_lexer_peek_nth_token (parser->lexer, 2);\n       if (token2->keyword == RID_NAMESPACE)\n \tcp_parser_using_directive (parser);\n+      /* If the second token after 'using' is '=', then we have an\n+\t alias-declaration.  */\n+      else if (cxx_dialect >= cxx0x\n+\t       && token2->type == CPP_NAME\n+\t       && ((cp_lexer_peek_nth_token (parser->lexer, 3)->type == CPP_EQ)\n+\t\t   || (cp_lexer_peek_nth_token (parser->lexer, 3)->keyword\n+\t\t       == RID_ATTRIBUTE)))\n+\tcp_parser_alias_declaration (parser);\n       /* Otherwise, it's a using-declaration.  */\n       else\n \tcp_parser_using_declaration (parser,\n@@ -12343,7 +12354,7 @@ cp_parser_template_id (cp_parser *parser,\n   /* Build a representation of the specialization.  */\n   if (TREE_CODE (templ) == IDENTIFIER_NODE)\n     template_id = build_min_nt (TEMPLATE_ID_EXPR, templ, arguments);\n-  else if (DECL_CLASS_TEMPLATE_P (templ)\n+  else if (DECL_TYPE_TEMPLATE_P (templ)\n \t   || DECL_TEMPLATE_TEMPLATE_PARM_P (templ))\n     {\n       bool entering_scope;\n@@ -13611,6 +13622,7 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n      class-name\n      enum-name\n      typedef-name\n+     simple-template-id [in c++0x]\n \n    enum-name:\n      identifier\n@@ -13638,8 +13650,37 @@ cp_parser_type_name (cp_parser* parser)\n   /* If it's not a class-name, keep looking.  */\n   if (!cp_parser_parse_definitely (parser))\n     {\n-      /* It must be a typedef-name or an enum-name.  */\n-      return cp_parser_nonclass_name (parser);\n+      if (cxx_dialect < cxx0x)\n+\t/* It must be a typedef-name or an enum-name.  */\n+\treturn cp_parser_nonclass_name (parser);\n+\n+      cp_parser_parse_tentatively (parser);\n+      /* It is either a simple-template-id representing an\n+\t instantiation of an alias template...  */\n+      type_decl = cp_parser_template_id (parser,\n+\t\t\t\t\t /*template_keyword_p=*/false,\n+\t\t\t\t\t /*check_dependency_p=*/false,\n+\t\t\t\t\t /*is_declaration=*/false);\n+      /* Note that this must be an instantiation of an alias template\n+\t because [temp.names]/6 says:\n+\t \n+\t     A template-id that names an alias template specialization\n+\t     is a type-name.\n+\n+\t Whereas [temp.names]/7 says:\n+\t \n+\t     A simple-template-id that names a class template\n+\t     specialization is a class-name.  */\n+      if (type_decl != NULL_TREE\n+\t  && TREE_CODE (type_decl) == TYPE_DECL\n+\t  && TYPE_DECL_ALIAS_P (type_decl))\n+\tgcc_assert (DECL_TEMPLATE_INSTANTIATION (type_decl));\n+      else\n+\tcp_parser_simulate_error (parser);\n+\n+      if (!cp_parser_parse_definitely (parser))\n+\t/* ... Or a typedef-name or an enum-name.  */\n+\treturn cp_parser_nonclass_name (parser);\n     }\n \n   return type_decl;\n@@ -14835,6 +14876,63 @@ cp_parser_using_declaration (cp_parser* parser,\n   return true;\n }\n \n+/* Parse an alias-declaration.\n+\n+   alias-declaration:\n+     using identifier attribute-specifier-seq [opt] = type-id  */\n+\n+static tree\n+cp_parser_alias_declaration (cp_parser* parser)\n+{\n+  tree id, type, decl, dummy, attributes;\n+  location_t id_location;\n+  cp_declarator *declarator;\n+  cp_decl_specifier_seq decl_specs;\n+\n+  /* Look for the `using' keyword.  */\n+  cp_parser_require_keyword (parser, RID_USING, RT_USING);\n+  id_location = cp_lexer_peek_token (parser->lexer)->location;\n+  id = cp_parser_identifier (parser);\n+  attributes = cp_parser_attributes_opt (parser);\n+  cp_parser_require (parser, CPP_EQ, RT_EQ);\n+\n+  type = cp_parser_type_id (parser);\n+\n+  /* A typedef-name can also be introduced by an alias-declaration. The\n+     identifier following the using keyword becomes a typedef-name. It has\n+     the same semantics as if it were introduced by the typedef\n+     specifier. In particular, it does not define a new type and it shall\n+     not appear in the type-id.  */\n+\n+  clear_decl_specs (&decl_specs);\n+  decl_specs.type = type;\n+  decl_specs.attributes = attributes;\n+  ++decl_specs.specs[(int) ds_typedef];\n+  ++decl_specs.specs[(int) ds_alias];\n+\n+  declarator = make_id_declarator (NULL_TREE, id, sfk_none);\n+  declarator->id_loc = id_location;\n+\n+  if (at_class_scope_p ())\n+    decl = grokfield (declarator, &decl_specs, NULL_TREE, false,\n+\t\t      NULL_TREE, attributes);\n+  else\n+    decl = start_decl (declarator, &decl_specs, 0,\n+\t\t       attributes, NULL_TREE, &dummy);\n+  if (decl == error_mark_node)\n+    return decl;\n+\n+  cp_finish_decl (decl, NULL_TREE, 0, NULL_TREE, 0);\n+\n+  /* If decl is a template, return its TEMPLATE_DECL so that it gets\n+     added into the symbol table; otherwise, return the TYPE_DECL.  */\n+  if (DECL_LANG_SPECIFIC (decl)\n+      && DECL_TEMPLATE_INFO (decl)\n+      && PRIMARY_TEMPLATE_P (DECL_TI_TEMPLATE (decl)))\n+    decl = DECL_TI_TEMPLATE (decl);\n+  return decl;\n+}\n+\n /* Parse a using-directive.\n \n    using-directive:\n@@ -18532,6 +18630,7 @@ cp_parser_member_specification_opt (cp_parser* parser)\n      :: [opt] nested-name-specifier template [opt] unqualified-id ;\n      using-declaration\n      template-declaration\n+     alias-declaration\n \n    member-declarator-list:\n      member-declarator\n@@ -18599,10 +18698,25 @@ cp_parser_member_declaration (cp_parser* parser)\n   /* Check for a using-declaration.  */\n   if (cp_lexer_next_token_is_keyword (parser->lexer, RID_USING))\n     {\n-      /* Parse the using-declaration.  */\n-      cp_parser_using_declaration (parser,\n-\t\t\t\t   /*access_declaration_p=*/false);\n-      return;\n+      if (cxx_dialect < cxx0x)\n+\t{\n+\t  /* Parse the using-declaration.  */\n+\t  cp_parser_using_declaration (parser,\n+\t\t\t\t       /*access_declaration_p=*/false);\n+\t  return;\n+\t}\n+      else\n+\t{\n+\t  tree decl;\n+\t  cp_parser_parse_tentatively (parser);\n+\t  decl = cp_parser_alias_declaration (parser);\n+\t  if (cp_parser_parse_definitely (parser))\n+\t    finish_member_declaration (decl);\n+\t  else\n+\t    cp_parser_using_declaration (parser,\n+\t\t\t\t\t /*access_declaration_p=*/false);\n+\t  return;\n+\t}\n     }\n \n   /* Check for @defs.  */\n@@ -20893,6 +21007,9 @@ cp_parser_template_declaration_after_export (cp_parser* parser, bool member_p)\n   if (cp_lexer_next_token_is_keyword (parser->lexer,\n \t\t\t\t      RID_TEMPLATE))\n     cp_parser_template_declaration_after_export (parser, member_p);\n+  else if (cxx_dialect >= cxx0x\n+\t   && cp_lexer_next_token_is_keyword (parser->lexer, RID_USING))\n+    decl = cp_parser_alias_declaration (parser);\n   else\n     {\n       /* There are no access checks when parsing a template, as we do not"}, {"sha": "c8c8d91b930cb46f22cb02d253fb5f1b87b243e6", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 183, "deletions": 27, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28704289327e4295928663b5bab7953718f71bc1/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28704289327e4295928663b5bab7953718f71bc1/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=28704289327e4295928663b5bab7953718f71bc1", "patch": "@@ -814,7 +814,13 @@ maybe_process_partial_specialization (tree type)\n \n   context = TYPE_CONTEXT (type);\n \n-  if (CLASS_TYPE_P (type) && CLASSTYPE_USE_TEMPLATE (type))\n+  if ((CLASS_TYPE_P (type) && CLASSTYPE_USE_TEMPLATE (type))\n+      /* Consider non-class instantiations of alias templates as\n+\t well.  */\n+      || (TYPE_P (type)\n+\t  && TYPE_TEMPLATE_INFO (type)\n+\t  && DECL_LANG_SPECIFIC (TYPE_NAME (type))\n+\t  && DECL_USE_TEMPLATE (TYPE_NAME (type))))\n     {\n       /* This is for ordinary explicit specialization and partial\n \t specialization of a template class such as:\n@@ -827,7 +833,8 @@ maybe_process_partial_specialization (tree type)\n \n \t Make sure that `C<int>' and `C<T*>' are implicit instantiations.  */\n \n-      if (CLASSTYPE_IMPLICIT_INSTANTIATION (type)\n+      if (CLASS_TYPE_P (type)\n+\t  && CLASSTYPE_IMPLICIT_INSTANTIATION (type)\n \t  && !COMPLETE_TYPE_P (type))\n \t{\n \t  check_specialization_namespace (CLASSTYPE_TI_TEMPLATE (type));\n@@ -839,8 +846,16 @@ maybe_process_partial_specialization (tree type)\n \t\treturn error_mark_node;\n \t    }\n \t}\n-      else if (CLASSTYPE_TEMPLATE_INSTANTIATION (type))\n+      else if (CLASS_TYPE_P (type)\n+\t       && CLASSTYPE_TEMPLATE_INSTANTIATION (type))\n \terror (\"specialization of %qT after instantiation\", type);\n+\n+      if (DECL_ALIAS_TEMPLATE_P (TYPE_TI_TEMPLATE (type)))\n+\t{\n+\t  error (\"partial specialization of alias template %qD\",\n+\t\t TYPE_TI_TEMPLATE (type));\n+\t  return error_mark_node;\n+\t}\n     }\n   else if (CLASS_TYPE_P (type)\n \t   && !CLASSTYPE_USE_TEMPLATE (type)\n@@ -2842,8 +2857,8 @@ make_ith_pack_parameter_name (tree name, int i)\n   return get_identifier (newname);\n }\n \n-/* Return true if T is a primary function\n-   or class template instantiation.  */\n+/* Return true if T is a primary function, class or alias template\n+   instantiation.  */\n \n bool\n primary_template_instantiation_p (const_tree t)\n@@ -2858,6 +2873,11 @@ primary_template_instantiation_p (const_tree t)\n   else if (CLASS_TYPE_P (t))\n     return CLASSTYPE_TEMPLATE_INSTANTIATION (t)\n \t   && PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (t));\n+  else if (TYPE_P (t)\n+\t   && TYPE_TEMPLATE_INFO (t)\n+\t   && PRIMARY_TEMPLATE_P (TYPE_TI_TEMPLATE (t))\n+\t   && DECL_TEMPLATE_INSTANTIATION (TYPE_NAME (t)))\n+    return true;\n   return false;\n }\n \n@@ -4831,6 +4851,10 @@ push_template_decl_real (tree decl, bool is_friend)\n       else if (DECL_IMPLICIT_TYPEDEF_P (decl)\n \t       && CLASS_TYPE_P (TREE_TYPE (decl)))\n \t/* OK */;\n+      else if (TREE_CODE (decl) == TYPE_DECL\n+\t       && TYPE_DECL_ALIAS_P (decl))\n+\t/* alias-declaration */\n+\tgcc_assert (!DECL_ARTIFICIAL (decl));\n       else\n \t{\n \t  error (\"template declaration of %q#D\", decl);\n@@ -5095,8 +5119,13 @@ template arguments to %qD do not match original template %qD\",\n \n   if (DECL_IMPLICIT_TYPEDEF_P (decl))\n     SET_TYPE_TEMPLATE_INFO (TREE_TYPE (tmpl), info);\n-  else if (DECL_LANG_SPECIFIC (decl))\n-    DECL_TEMPLATE_INFO (decl) = info;\n+  else\n+    {\n+      if (primary && !DECL_LANG_SPECIFIC (decl))\n+\tretrofit_lang_decl (decl);\n+      if (DECL_LANG_SPECIFIC (decl))\n+\tDECL_TEMPLATE_INFO (decl) = info;\n+    }\n \n   return DECL_TEMPLATE_RESULT (tmpl);\n }\n@@ -5259,6 +5288,32 @@ fold_non_dependent_expr (tree expr)\n   return fold_non_dependent_expr_sfinae (expr, tf_error);\n }\n \n+/* Return TRUE iff T is a type alias, a TEMPLATE_DECL for an alias\n+   template declaration, or a TYPE_DECL for an alias declaration.  */\n+\n+bool\n+alias_type_or_template_p (tree t)\n+{\n+  if (t == NULL_TREE)\n+    return false;\n+  return ((TREE_CODE (t) == TYPE_DECL && TYPE_DECL_ALIAS_P (t))\n+\t  || (TYPE_P (t)\n+\t      && TYPE_NAME (t)\n+\t      && TYPE_DECL_ALIAS_P (TYPE_NAME (t)))\n+\t  || DECL_ALIAS_TEMPLATE_P (t));\n+}\n+\n+/* Return TRUE iff is a specialization of an alias template.  */\n+\n+bool\n+alias_template_specialization_p (tree t)\n+{\n+  if (t == NULL_TREE)\n+    return false;\n+  return (primary_template_instantiation_p (t)\n+\t  && DECL_ALIAS_TEMPLATE_P (TYPE_TI_TEMPLATE (t)));\n+}\n+\n /* Subroutine of convert_nontype_argument. Converts EXPR to TYPE, which\n    must be a function or a pointer-to-function type, as specified\n    in [temp.arg.nontype]: disambiguate EXPR if it is an overload set,\n@@ -7355,7 +7410,31 @@ lookup_template_class_1 (tree d1, tree arglist, tree in_decl, tree context,\n \t  ENUM_FIXED_UNDERLYING_TYPE_P (t)\n \t    = ENUM_FIXED_UNDERLYING_TYPE_P (template_type);\n \t}\n-      else\n+      else if (DECL_ALIAS_TEMPLATE_P (gen_tmpl))\n+\t{\n+\t  /* The user referred to a specialization of an alias\n+\t    template represented by GEN_TMPL.\n+\n+\t    [temp.alias]/2 says:\n+\n+\t        When a template-id refers to the specialization of an\n+\t\talias template, it is equivalent to the associated\n+\t\ttype obtained by substitution of its\n+\t\ttemplate-arguments for the template-parameters in the\n+\t\ttype-id of the alias template.  */\n+\n+\t  t = tsubst (TREE_TYPE (gen_tmpl), arglist, complain, in_decl);\n+\t  /* Note that the call above (by indirectly calling\n+\t     register_specialization in tsubst_decl) registers the\n+\t     TYPE_DECL representing the specialization of the alias\n+\t     template.  So next time someone substitutes ARGLIST for\n+\t     the template parms into the alias template (GEN_TMPL),\n+\t     she'll get that TYPE_DECL back.  */\n+\n+\t  if (t == error_mark_node)\n+\t    return t;\n+\t}\n+      else if (CLASS_TYPE_P (template_type))\n \t{\n \t  t = make_class_type (TREE_CODE (template_type));\n \t  CLASSTYPE_DECLARED_CLASS (t)\n@@ -7378,6 +7457,8 @@ lookup_template_class_1 (tree d1, tree arglist, tree in_decl, tree context,\n \t       structural equality testing. */\n \t    SET_TYPE_STRUCTURAL_EQUALITY (t);\n \t}\n+      else\n+\tgcc_unreachable ();\n \n       /* If we called start_enum or pushtag above, this information\n \t will already be set up.  */\n@@ -7393,14 +7474,17 @@ lookup_template_class_1 (tree d1, tree arglist, tree in_decl, tree context,\n       else\n \ttype_decl = TYPE_NAME (t);\n \n-      TREE_PRIVATE (type_decl)\n-\t= TREE_PRIVATE (TYPE_STUB_DECL (template_type));\n-      TREE_PROTECTED (type_decl)\n-\t= TREE_PROTECTED (TYPE_STUB_DECL (template_type));\n-      if (CLASSTYPE_VISIBILITY_SPECIFIED (template_type))\n+      if (CLASS_TYPE_P (template_type))\n \t{\n-\t  DECL_VISIBILITY_SPECIFIED (type_decl) = 1;\n-\t  DECL_VISIBILITY (type_decl) = CLASSTYPE_VISIBILITY (template_type);\n+\t  TREE_PRIVATE (type_decl)\n+\t    = TREE_PRIVATE (TYPE_STUB_DECL (template_type));\n+\t  TREE_PROTECTED (type_decl)\n+\t    = TREE_PROTECTED (TYPE_STUB_DECL (template_type));\n+\t  if (CLASSTYPE_VISIBILITY_SPECIFIED (template_type))\n+\t    {\n+\t      DECL_VISIBILITY_SPECIFIED (type_decl) = 1;\n+\t      DECL_VISIBILITY (type_decl) = CLASSTYPE_VISIBILITY (template_type);\n+\t    }\n \t}\n \n       /* Let's consider the explicit specialization of a member\n@@ -7456,7 +7540,7 @@ lookup_template_class_1 (tree d1, tree arglist, tree in_decl, tree context,\n \t  ++processing_template_decl;\n \t  partial_inst_args =\n \t    tsubst (INNERMOST_TEMPLATE_ARGS\n-\t\t\t(CLASSTYPE_TI_ARGS (TREE_TYPE (gen_tmpl))),\n+\t\t\t(TYPE_TI_ARGS (TREE_TYPE (gen_tmpl))),\n \t\t    arglist, complain, NULL_TREE);\n \t  --processing_template_decl;\n \t  TREE_VEC_LENGTH (arglist)++;\n@@ -7480,7 +7564,15 @@ lookup_template_class_1 (tree d1, tree arglist, tree in_decl, tree context,\n \t  TREE_VEC_LENGTH (arglist)--;\n \t  found = tsubst (gen_tmpl, arglist, complain, NULL_TREE);\n \t  TREE_VEC_LENGTH (arglist)++;\n-\t  found = CLASSTYPE_TI_TEMPLATE (found);\n+\t  /* FOUND is either a proper class type, or an alias\n+\t     template specialization.  In the later case, it's a\n+\t     TYPE_DECL, resulting from the substituting of arguments\n+\t     for parameters in the TYPE_DECL of the alias template\n+\t     done earlier.  So be careful while getting the template\n+\t     of FOUND.  */\n+\t  found = TREE_CODE (found) == TYPE_DECL\n+\t    ? TYPE_TI_TEMPLATE (TREE_TYPE (found))\n+\t    : CLASSTYPE_TI_TEMPLATE (found);\n \t}\n \n       SET_TYPE_TEMPLATE_INFO (t, build_template_info (found, arglist));\n@@ -7508,7 +7600,7 @@ lookup_template_class_1 (tree d1, tree arglist, tree in_decl, tree context,\n \t   the instantiation and exit above.  */\n \ttsubst_enum (template_type, t, arglist);\n \n-      if (is_dependent_type)\n+      if (CLASS_TYPE_P (template_type) && is_dependent_type)\n \t/* If the type makes use of template parameters, the\n \t   code that generates debugging information will crash.  */\n \tDECL_IGNORED_P (TYPE_STUB_DECL (t)) = 1;\n@@ -9845,7 +9937,8 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \n \tDECL_TEMPLATE_INFO (r) = build_template_info (t, args);\n \n-\tif (TREE_CODE (decl) == TYPE_DECL)\n+\tif (TREE_CODE (decl) == TYPE_DECL\n+\t    && !TYPE_DECL_ALIAS_P (decl))\n \t  {\n \t    tree new_type;\n \t    ++processing_template_decl;\n@@ -10378,8 +10471,15 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t\t   referencing a static data member within in its own\n \t\t   class.  We can use pointer equality, rather than\n \t\t   same_type_p, because DECL_CONTEXT is always\n-\t\t   canonical.  */\n-\t\tif (ctx == DECL_CONTEXT (t))\n+\t\t   canonical...  */\n+\t\tif (ctx == DECL_CONTEXT (t)\n+\t\t    && (TREE_CODE (t) != TYPE_DECL\n+\t\t\t/* ... unless T is a member template; in which\n+\t\t\t   case our caller can be willing to create a\n+\t\t\t   specialization of that template represented\n+\t\t\t   by T.  */\n+\t\t\t|| !(DECL_TI_TEMPLATE (t)\n+\t\t\t     && DECL_MEMBER_TEMPLATE_P (DECL_TI_TEMPLATE (t)))))\n \t\t  spec = t;\n \t      }\n \n@@ -10860,7 +10960,7 @@ tree\n tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n {\n   enum tree_code code;\n-  tree type, r;\n+  tree type, r = NULL_TREE;\n \n   if (t == NULL_TREE || t == error_mark_node\n       || t == integer_type_node\n@@ -10892,10 +10992,21 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       && typedef_variant_p (t))\n     {\n       tree decl = TYPE_NAME (t);\n-      \n-      if (DECL_CLASS_SCOPE_P (decl)\n-\t  && CLASSTYPE_TEMPLATE_INFO (DECL_CONTEXT (decl))\n-\t  && uses_template_parms (DECL_CONTEXT (decl)))\n+\n+      if (TYPE_DECL_ALIAS_P (decl)\n+\t  && DECL_LANG_SPECIFIC (decl)\n+\t  && DECL_TEMPLATE_INFO (decl)\n+\t  && PRIMARY_TEMPLATE_P (DECL_TI_TEMPLATE (decl)))\n+\t{\n+\t  /* DECL represents an alias template and we want to\n+\t     instantiate it.  Let's substitute our arguments for the\n+\t     template parameters into the declaration and get the\n+\t     resulting type.  */\n+\t  r = tsubst (decl, args, complain, decl);\n+\t}\n+      else if (DECL_CLASS_SCOPE_P (decl)\n+\t       && CLASSTYPE_TEMPLATE_INFO (DECL_CONTEXT (decl))\n+\t       && uses_template_parms (DECL_CONTEXT (decl)))\n \t{\n \t  tree tmpl = most_general_template (DECL_TI_TEMPLATE (decl));\n \t  tree gen_args = tsubst (DECL_TI_ARGS (decl), args, complain, in_decl);\n@@ -11045,6 +11156,46 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t\tif (argvec == error_mark_node)\n \t\t  return error_mark_node;\n \n+\t\tgcc_assert (TREE_CODE (arg) == TEMPLATE_TEMPLATE_PARM\n+\t\t\t    || TREE_CODE (arg) == TEMPLATE_DECL\n+\t\t\t    || TREE_CODE (arg) == UNBOUND_CLASS_TEMPLATE);\n+\n+\t\tif (TREE_CODE (arg) == UNBOUND_CLASS_TEMPLATE)\n+\t\t  /* Consider this code:\n+\n+\t\t\ttemplate <template <class> class Template>\n+\t\t\tstruct Internal {\n+\t\t\ttemplate <class Arg> using Bind = Template<Arg>;\n+\t\t\t};\n+\n+\t\t\ttemplate <template <class> class Template, class Arg>\n+\t\t\tusing Instantiate = Template<Arg>; //#0\n+\n+\t\t\ttemplate <template <class> class Template,\n+                                  class Argument>\n+\t\t\tusing Bind =\n+\t\t\t  Instantiate<Internal<Template>::template Bind,\n+\t\t\t\t      Argument>; //#1\n+\n+\t\t     When #1 is parsed, the\n+\t\t     BOUND_TEMPLATE_TEMPLATE_PARM representing the\n+\t\t     parameter `Template' in #0 matches the\n+\t\t     UNBOUND_CLASS_TEMPLATE representing the argument\n+\t\t     `Internal<Template>::template Bind'; We then want\n+\t\t     to assemble the type `Bind<Argument>' that can't\n+\t\t     be fully created right now, because\n+\t\t     `Internal<Template>' not being complete, the Bind\n+\t\t     template cannot be looked up in that context.  So\n+\t\t     we need to \"store\" `Bind<Argument>' for later\n+\t\t     when the context of Bind becomes complete.  Let's\n+\t\t     store that in a TYPENAME_TYPE.  */\n+\t\t  return make_typename_type (TYPE_CONTEXT (arg),\n+\t\t\t\t\t     build_nt (TEMPLATE_ID_EXPR,\n+\t\t\t\t\t\t       TYPE_IDENTIFIER (arg),\n+\t\t\t\t\t\t       argvec),\n+\t\t\t\t\t     typename_type,\n+\t\t\t\t\t     complain);\n+\n \t\t/* We can get a TEMPLATE_TEMPLATE_PARM here when we\n \t\t   are resolving nested-types in the signature of a\n \t\t   member function templates.  Otherwise ARG is a\n@@ -17610,7 +17761,12 @@ do_type_instantiation (tree t, tree storage, tsubst_flags_t complain)\n \n   if (! CLASS_TYPE_P (t) || ! CLASSTYPE_TEMPLATE_INFO (t))\n     {\n-      error (\"explicit instantiation of non-template type %qT\", t);\n+      tree tmpl =\n+\t(TYPE_TEMPLATE_INFO (t)) ? TYPE_TI_TEMPLATE (t) : NULL;\n+      if (tmpl)\n+\terror (\"explicit instantiation of non-class template %qD\", tmpl);\n+      else\n+\terror (\"explicit instantiation of non-template type %qT\", t);\n       return;\n     }\n "}, {"sha": "40af661e953993c0f8689a2b432ae9622bada20e", "filename": "gcc/cp/search.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28704289327e4295928663b5bab7953718f71bc1/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28704289327e4295928663b5bab7953718f71bc1/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=28704289327e4295928663b5bab7953718f71bc1", "patch": "@@ -427,7 +427,7 @@ lookup_field_1 (tree type, tree name, bool want_type)\n \t\t    field = fields[i--];\n \t\t  while (i >= lo && DECL_NAME (fields[i]) == name);\n \t\t  if (TREE_CODE (field) != TYPE_DECL\n-\t\t      && !DECL_CLASS_TEMPLATE_P (field))\n+\t\t      && !DECL_TYPE_TEMPLATE_P (field))\n \t\t    field = NULL_TREE;\n \t\t}\n \t      else\n@@ -478,7 +478,7 @@ lookup_field_1 (tree type, tree name, bool want_type)\n       if (DECL_NAME (field) == name\n \t  && (!want_type\n \t      || TREE_CODE (field) == TYPE_DECL\n-\t      || DECL_CLASS_TEMPLATE_P (field)))\n+\t      || DECL_TYPE_TEMPLATE_P (field)))\n \treturn field;\n     }\n   /* Not found.  */\n@@ -1046,7 +1046,7 @@ lookup_field_r (tree binfo, void *data)\n   /* If we're looking up a type (as with an elaborated type specifier)\n      we ignore all non-types we find.  */\n   if (lfi->want_type && TREE_CODE (nval) != TYPE_DECL\n-      && !DECL_CLASS_TEMPLATE_P (nval))\n+      && !DECL_TYPE_TEMPLATE_P (nval))\n     {\n       if (lfi->name == TYPE_IDENTIFIER (type))\n \t{"}, {"sha": "9d6bd316aa13886a1daabe04d7d866c40dfbbcee", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28704289327e4295928663b5bab7953718f71bc1/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28704289327e4295928663b5bab7953718f71bc1/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=28704289327e4295928663b5bab7953718f71bc1", "patch": "@@ -2733,15 +2733,17 @@ finish_template_decl (tree parms)\n tree\n finish_template_type (tree name, tree args, int entering_scope)\n {\n-  tree decl;\n+  tree type;\n \n-  decl = lookup_template_class (name, args,\n+  type = lookup_template_class (name, args,\n \t\t\t\tNULL_TREE, NULL_TREE, entering_scope,\n \t\t\t\ttf_warning_or_error | tf_user);\n-  if (decl != error_mark_node)\n-    decl = TYPE_STUB_DECL (decl);\n-\n-  return decl;\n+  if (type == error_mark_node)\n+    return type;\n+  else if (CLASS_TYPE_P (type) && !alias_type_or_template_p (type))\n+    return TYPE_STUB_DECL (type);\n+  else\n+    return TYPE_NAME (type);\n }\n \n /* Finish processing a BASE_CLASS with the indicated ACCESS_SPECIFIER."}, {"sha": "1560c27c25d103d585d3b910a252a3ce91a1e585", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28704289327e4295928663b5bab7953718f71bc1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28704289327e4295928663b5bab7953718f71bc1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=28704289327e4295928663b5bab7953718f71bc1", "patch": "@@ -1,3 +1,21 @@\n+2011-11-07  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tSupport C++11 alias-declaration\n+\tPR c++/45114\n+\t* g++.dg/cpp0x/alias-decl-0.C: New test case.\n+\t* g++.dg/cpp0x/alias-decl-1.C: Likewise.\n+\t* g++.dg/cpp0x/alias-decl-3.C: Likewise.\n+\t* g++.dg/cpp0x/alias-decl-4.C: Likewise.\n+\t* g++.dg/cpp0x/alias-decl-6.C: Likewise.\n+\t* g++.dg/cpp0x/alias-decl-7.C: Likewise.\n+\t* g++.dg/cpp0x/alias-decl-8.C: Likewise.\n+\t* g++.dg/cpp0x/alias-decl-9.C: Likewise.\n+\t* g++.dg/cpp0x/alias-decl-10.C: Likewise.\n+\t* g++.dg/ext/alias-decl-attr1.C: Likewise.\n+\t* g++.dg/ext/alias-decl-attr2.C: Likewise.\n+\t* g++.dg/ext/alias-decl-attr3.C: Likewise.\n+\t* g++.dg/ext/alias-decl-attr4.C: Likewise.\n+\n 2011-11-07  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc.dg/pragma-align-2.c: Compile with -std=gnu99."}, {"sha": "c5760cfe537b876cfdc12626b3fe7c4d07f5e510", "filename": "gcc/testsuite/g++.dg/cpp0x/alias-decl-0.C", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28704289327e4295928663b5bab7953718f71bc1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28704289327e4295928663b5bab7953718f71bc1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-0.C?ref=28704289327e4295928663b5bab7953718f71bc1", "patch": "@@ -0,0 +1,37 @@\n+// { dg-options \"-std=c++0x\" }\n+\n+template<template<class> class TT> struct X { };\n+template<class> struct Y { };\n+template<class T> using Z = Y<T>;\n+\n+void f(X<Y>);\n+void g(X<Z>);\n+\n+void\n+foo()\n+{\n+    // Below x and y don't have the same type, because Y and Z don't\n+    // designate the same template ...\n+    X<Y> y; \n+    X<Z> z;\n+\n+    // ... So these must fail to compile.\n+    f(z);   // { dg-error \"\" }\n+    g(y);   // { dg-error \"\" }\n+}\n+\n+template<class> struct A0 {};\n+template<class T> using AA0 = A0<T>;\n+template<class T> using AAA0 = AA0<T>;\n+\n+void f0(A0<int>);\n+void\n+g0()\n+{\n+  AA0<int> a;\n+  AAA0<int> b;\n+  f0(a);\n+  f0(b);\n+}\n+\n+"}, {"sha": "d0eda5ff1b9b7d25cd7ce8b5bc5e0b24a9cce044", "filename": "gcc/testsuite/g++.dg/cpp0x/alias-decl-1.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28704289327e4295928663b5bab7953718f71bc1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28704289327e4295928663b5bab7953718f71bc1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-1.C?ref=28704289327e4295928663b5bab7953718f71bc1", "patch": "@@ -0,0 +1,15 @@\n+// { dg-options \"-std=c++0x\" }\n+\n+// These also represent tests for printing alias declarations and\n+// their instantiations.\n+\n+template<class T, class U> struct A0 {};\n+template<class T, class U> using AA0 = A0<T, U>;\n+template<class T> struct AA0<int, T> {}; // { dg-error \"partial specialization\" }\n+\n+template <class U> using Ptr = U*;\n+template<class U> struct Ptr<U*> {}; // { dg-error \"partial specialization\" }\n+\n+struct A {\n+    using A = int;//{ dg-error \"nested|has|same name as|class|in which|declared\" }\n+};"}, {"sha": "856e4297af5548256773eb9e3feced8e3ef2fe5f", "filename": "gcc/testsuite/g++.dg/cpp0x/alias-decl-10.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28704289327e4295928663b5bab7953718f71bc1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28704289327e4295928663b5bab7953718f71bc1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-10.C?ref=28704289327e4295928663b5bab7953718f71bc1", "patch": "@@ -0,0 +1,18 @@\n+// { dg-options \"-std=c++0x\" }\n+\n+template <class T> using Ptr = T*;\n+Ptr<unsigned>; // { dg-error \"does not declare anything\" }\n+Ptr<char><int>; // { dg-error \"not a template|does not declare anything\" }\n+template class Ptr<int>;//{ dg-error \"explicit instantiation|non-class templ|does not decl|anything\" }\n+\n+template <class T> using Arg = T;\n+struct A {};\n+template class Arg<A>;// { dg-error \"explicit instantiation|non-class templ\" }\n+\n+template <template <class> class TT, class T> using Instantiate = TT<T>;\n+template <class> struct Vector {};\n+template class Instantiate<Vector, int>; // OK Vector<int> can be explicitely instantiated\n+\n+template <class T> struct S {};\n+template<class T> using SFor = S<T>;\n+template class SFor<int>; // OK, S<int> can be explicitely instantiated"}, {"sha": "2e03dd897b53cdd122dcbc0e9de557fecc1d139d", "filename": "gcc/testsuite/g++.dg/cpp0x/alias-decl-2.C", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28704289327e4295928663b5bab7953718f71bc1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28704289327e4295928663b5bab7953718f71bc1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-2.C?ref=28704289327e4295928663b5bab7953718f71bc1", "patch": "@@ -0,0 +1,33 @@\n+// { dg-options \"-std=c++0x\" }\n+\n+template<class T> struct S0 {};\n+template<class T> using AS0 = S0<T>;\n+\n+template<template<class> class TT>\n+void f(TT<int>);\n+\n+template class AS0<char>;\n+\n+void\n+foo()\n+{\n+  AS0<int> a;\n+  f(a);\n+}\n+\n+template<class T, class U> struct Vector{};\n+template<class T> struct Alloc {};\n+\n+template<class T> using Vec = Vector<T, Alloc<T> >;\n+\n+template<class T> void g(Vector<T, Alloc<T> >);\n+\n+template<template<class T> class TT> void h(TT<int>); // { dg-error \"provided for\" }\n+\n+void\n+bar()\n+{\n+  Vec<int> a;\n+  g(a);\n+  h(a); // { dg-error \"no matching function|wrong number of template arguments\" }\n+}"}, {"sha": "5484efce19eba012cce5325c4beb92157f1fadab", "filename": "gcc/testsuite/g++.dg/cpp0x/alias-decl-3.C", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28704289327e4295928663b5bab7953718f71bc1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28704289327e4295928663b5bab7953718f71bc1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-3.C?ref=28704289327e4295928663b5bab7953718f71bc1", "patch": "@@ -0,0 +1,42 @@\n+// { dg-options \"-std=c++0x\" }\n+\n+// Exercise some member alias templates ...\n+\n+template<class T, class U> class A0 {};\n+\n+template<class T>\n+struct A1 {\n+    template<class U> struct S {};\n+    template<class U> using AA0 = A0<T, U>;\n+\n+  void f(A0<T, int>);\n+\n+  void\n+  foo()\n+  {\n+    AA0<int> a;\n+    const AA0<int> b;\n+    f(a);\n+    f(b);\n+  }\n+};\n+\n+void\n+bar()\n+{\n+    A1<int> a1;\n+    a1.foo();\n+    A1<int>::AA0<int> a1aa0;\n+    a1.f(a1aa0);\n+}\n+\n+// ... some simple member alias ...\n+struct B {\n+    using A = int;\n+};\n+\n+B::A a;\n+\n+// ... and some simple alias\n+\n+using Int = int;"}, {"sha": "876944e23c3e0cbfb2156ee2b94b233087a10615", "filename": "gcc/testsuite/g++.dg/cpp0x/alias-decl-4.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28704289327e4295928663b5bab7953718f71bc1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28704289327e4295928663b5bab7953718f71bc1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-4.C?ref=28704289327e4295928663b5bab7953718f71bc1", "patch": "@@ -0,0 +1,14 @@\n+// { dg-options \"-std=c++0x\" }\n+\n+// [temp.alias]/3:\n+// The type-id in an alias template declaration shall not refer\n+// to the alias template being declared. The type produced by an\n+// alias template specialization shall not directly or indirectly\n+// make use of that specialization.\n+\n+template <class T> struct A;\n+template <class T> using B = typename A<T>::U; // { dg-error \"type\" }\n+template <class T> struct A {\n+    typedef B<T> U;\n+};\n+B<short> b; // { dg-error \"invalid type\" }"}, {"sha": "1a4cbd5e5bc9d0560bb00b7747167b081890c8b9", "filename": "gcc/testsuite/g++.dg/cpp0x/alias-decl-5.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28704289327e4295928663b5bab7953718f71bc1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28704289327e4295928663b5bab7953718f71bc1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-5.C?ref=28704289327e4295928663b5bab7953718f71bc1", "patch": "@@ -0,0 +1,34 @@\n+// { dg-options \"-std=c++0x\" }\n+\n+// alias template of a partial specialization\n+\n+template<class T, class U, class W> struct S0 {};\n+template<class T, class U> struct S0<T, U, char> {};\n+template<class T> using AS0 = S0<T, int, char>;\n+void foo(S0<bool, int, char>);\n+\n+AS0<bool> a; // OK\n+\n+void\n+f()\n+{\n+    foo(a); //OK\n+}\n+\n+// alias template of an explicit specialization of a member template\n+\n+template<class T>\n+struct S1 {\n+    template<class U>\n+    struct M {};\n+};\n+template<class T> using AM = S1<int>::M<T>;\n+void bar(S1<int>::M<bool>);\n+\n+AM<bool> b; //OK.\n+\n+void\n+g()\n+{\n+    bar(b); //OK\n+}"}, {"sha": "f60b2ea7fc0bd028ba36139ea2b226a87441a13e", "filename": "gcc/testsuite/g++.dg/cpp0x/alias-decl-6.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28704289327e4295928663b5bab7953718f71bc1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28704289327e4295928663b5bab7953718f71bc1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-6.C?ref=28704289327e4295928663b5bab7953718f71bc1", "patch": "@@ -0,0 +1,12 @@\n+// { dg-options \"-std=c++0x\" }\n+\n+// Alias template of non-class types.\n+\n+template <class T, class U> struct same;\n+template <class T> struct same<T,T> {};\n+\n+template <class T> using Ptr = T*;\n+template <template <class> class T> struct A {\n+  template <class U> using X = T<U>;\n+};\n+same<A<Ptr>::X<int>,int*> s;"}, {"sha": "96c349a0da6bb2dd112aca806aee02beb12f21c2", "filename": "gcc/testsuite/g++.dg/cpp0x/alias-decl-7.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28704289327e4295928663b5bab7953718f71bc1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28704289327e4295928663b5bab7953718f71bc1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-7.C?ref=28704289327e4295928663b5bab7953718f71bc1", "patch": "@@ -0,0 +1,23 @@\n+// { dg-options \"-std=c++0x\" }\n+\n+// Add arguments to unbound template template parameter.\n+\n+template <template <class> class Template>\n+struct Internal {\n+  template <class Arg> using Bind = Template<Arg>;\n+};\n+\n+template <template <class> class Template, class Arg>\n+using Instantiate = Template<Arg>; // After parsing #1, the\n+                                   // BOUND_TEMPLATE_TEMPLATE_PARM\n+                                   // parameter Template gets\n+                                   // the UNBOUND_CLASS_TEMPLATE\n+                                   // Internal<Template>::template Bind\n+                                   // as an argument, and the\n+                                   // parameter Arg gets Argument as\n+                                   // an argument.  And we build\n+                                   // 'Bind<Argument>'.\n+\n+template <template <class> class Template, class Argument>\n+using Bind = Instantiate<Internal<Template>::template Bind, Argument>; //#1\n+"}, {"sha": "c926df7539baf99d0ef96dac2cb78fb1f20e5ed2", "filename": "gcc/testsuite/g++.dg/cpp0x/alias-decl-8.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28704289327e4295928663b5bab7953718f71bc1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28704289327e4295928663b5bab7953718f71bc1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-8.C?ref=28704289327e4295928663b5bab7953718f71bc1", "patch": "@@ -0,0 +1,32 @@\n+// { dg-options \"-std=c++0x\" }\n+\n+struct A {\n+    template <class U> using C = U;\n+};\n+\n+// The particularity of the below struct is to have more than 7\n+// fields.  In this case, looking up a member here should exercise\n+// cp/search.c:lookup_field_1 in such a way that it finds it in the\n+// CLASSTYPE_SORTED_FIELDS of struct A7.\n+struct A7 {\n+  int f0;\n+  int f1;\n+  int f2;\n+  int f3;\n+  int f4;\n+  int f5;\n+  int f6;\n+  int f7;\n+  template <class U> using C = U;\n+};\n+\n+template <class T>\n+struct B {\n+    typename T::template C<int> n;  //#0\n+};\n+\n+// These should trigger the lookup\n+// of template C inside class A or\n+// A7, via #0.\n+B<A> b;\n+B<A7> c;"}, {"sha": "dcf642d7683e05f9e3c1297f0141c3de2a4a00ae", "filename": "gcc/testsuite/g++.dg/cpp0x/alias-decl-9.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28704289327e4295928663b5bab7953718f71bc1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28704289327e4295928663b5bab7953718f71bc1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-9.C?ref=28704289327e4295928663b5bab7953718f71bc1", "patch": "@@ -0,0 +1,9 @@\n+// { dg-options \"-std=c++0x\" }\n+\n+template <class T>\n+struct A {\n+    using Result = T;\n+};\n+template <class A> using Arg = typename A::Result;\n+Arg<A<int>> b;\n+"}, {"sha": "e83fe441275a26fcf310376eb462d54d9488ee61", "filename": "gcc/testsuite/g++.dg/ext/alias-decl-attr1.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28704289327e4295928663b5bab7953718f71bc1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Falias-decl-attr1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28704289327e4295928663b5bab7953718f71bc1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Falias-decl-attr1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Falias-decl-attr1.C?ref=28704289327e4295928663b5bab7953718f71bc1", "patch": "@@ -0,0 +1,19 @@\n+// { dg-options \"-std=c++0x\" }\n+\n+template <unsigned Len, unsigned Align>\n+struct aligned_storage\n+{\n+    using type __attribute__((aligned((Align)))) =\n+        char[Len];\n+};\n+\n+template<typename T>\n+struct X\n+{\n+  typename aligned_storage<sizeof(T),__alignof(T)>::type data;\n+};\n+\n+template<bool> struct StaticAssert;\n+template<> struct StaticAssert<true> {};\n+\n+StaticAssert<__alignof (X<double>) == __alignof (double)> dummy;"}, {"sha": "83e557c43fbff4bb5094a8fd5483fb0d55a757d5", "filename": "gcc/testsuite/g++.dg/ext/alias-decl-attr2.C", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28704289327e4295928663b5bab7953718f71bc1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Falias-decl-attr2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28704289327e4295928663b5bab7953718f71bc1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Falias-decl-attr2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Falias-decl-attr2.C?ref=28704289327e4295928663b5bab7953718f71bc1", "patch": "@@ -0,0 +1,42 @@\n+// { dg-options \"-std=c++0x\" }\n+\n+template<typename T>\n+struct X {\n+    using layout_type __attribute ((aligned(__alignof(double)))) =\n+        char[sizeof(T)];\n+    layout_type data;\n+};\n+\n+template<typename T>\n+struct Y {\n+    using layout_type  __attribute ((aligned(__alignof(T)))) =\n+        char[sizeof(T)];\n+    layout_type data;\n+};\n+\n+template<typename T>\n+struct Z {\n+    using layout_type __attribute ((aligned(__alignof(T)))) =\n+        char[sizeof(T)];\n+    struct Z2 {\n+        layout_type data;\n+    } in;\n+};\n+\n+template<typename T>\n+struct A;\n+\n+template <typename T>\n+struct A<T*> {\n+    using layout_type __attribute ((aligned(__alignof(T)))) =\n+        char[sizeof(T)];\n+  layout_type data;\n+};\n+\n+template<bool> struct StaticAssert;\n+template<> struct StaticAssert<true> {};\n+\n+StaticAssert<__alignof(X<double>) == __alignof(double)> d1;\n+StaticAssert<__alignof(Y<double>) == __alignof(double)> d2;\n+StaticAssert<__alignof(Z<double>) == __alignof(double)> d3;\n+StaticAssert<__alignof(A<double*>) == __alignof(double)> d4;"}, {"sha": "369aa10e65eed0b390e9609c0d7fc7ccdf89e12c", "filename": "gcc/testsuite/g++.dg/ext/alias-decl-attr3.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28704289327e4295928663b5bab7953718f71bc1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Falias-decl-attr3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28704289327e4295928663b5bab7953718f71bc1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Falias-decl-attr3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Falias-decl-attr3.C?ref=28704289327e4295928663b5bab7953718f71bc1", "patch": "@@ -0,0 +1,21 @@\n+// { dg-options \"-std=c++0x\" }\n+// { dg-do run }\n+\n+template <class T>\n+int\n+align_of_type_wide_array()\n+{\n+    using type_wide_array __attribute((aligned(__alignof(T))))\n+        = unsigned char[sizeof (T)];\n+\n+    return __alignof(type_wide_array);\n+}\n+\n+int\n+main ()\n+{\n+    if (align_of_type_wide_array<int>() == __alignof(int))\n+        return 0;\n+    else\n+        return 1;\n+}"}, {"sha": "c4dd048778964cee4732e5b5b490f3cb0109c073", "filename": "gcc/testsuite/g++.dg/ext/alias-decl-attr4.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28704289327e4295928663b5bab7953718f71bc1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Falias-decl-attr4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28704289327e4295928663b5bab7953718f71bc1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Falias-decl-attr4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Falias-decl-attr4.C?ref=28704289327e4295928663b5bab7953718f71bc1", "patch": "@@ -0,0 +1,34 @@\n+// { dg-options \"-std=c++0x\" }\n+// { dg-do run }\n+\n+using global_vector_type  __attribute__((vector_size(16))) = float;\n+\n+template <class T> struct A\n+{\n+    using type = T;\n+};\n+\n+template < typename Val > struct S\n+{\n+    using vector_type __attribute__((vector_size(16))) =\n+        typename A<Val>::type\n+        typedef Val vector_type2 __attribute__((vector_size(16)));\n+    int pr_size() { return sizeof(vector_type); }\n+    int pr_size2() { return sizeof(vector_type2); }\n+};\n+\n+int main()\n+{\n+  if (sizeof (S<float>::vector_type) != sizeof (global_vector_type))\n+    return 1;\n+  if (sizeof (S<float>::vector_type2) != sizeof (global_vector_type))\n+    return 2;\n+\n+  S<float> x;\n+  if (x.pr_size() != sizeof (global_vector_type))\n+    return 3;\n+  if (x.pr_size2() != sizeof (global_vector_type))\n+    return 4;\n+  \n+  return 0;\n+}"}]}