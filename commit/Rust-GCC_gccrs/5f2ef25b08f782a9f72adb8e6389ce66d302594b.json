{"sha": "5f2ef25b08f782a9f72adb8e6389ce66d302594b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWYyZWYyNWIwOGY3ODJhOWY3MmFkYjhlNjM4OWNlNjZkMzAyNTk0Yg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-06-03T15:46:15Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-06-03T15:56:59Z"}, "message": "Fix duplicate name issues in output of -fdump-ada-spec\n\nThe namespace rules are different in the C family of languages and\nin Ada, and a few adjustments are further needed in -fdump-ada-spec\nbecause of them.\n\ngcc/c-family/\n\t* c-ada-spec.c (dump_ada_enum_type): Dump a prefix for constants.\n\t(htable_t): New typedef.\n\t(overloaded_names): Use it.\n\t(add_name): New function.\n\t(init_overloaded_names): Use add_name to populate the table and add\n\tspecial cases for sigaction and stat.\n\t(overloaded_name_p): Rename into...\n\t(overloading_index): ...this.  Do not initialize overloaded_names table\n\there.  Return the index or zero.\n\t(dump_ada_declaration): Minor tweaks.  Do not skip overloaded functions\n\tbut add an overloading suffix instead.\n\t(dump_ada_specs): Initialize overloaded_names tables here.", "tree": {"sha": "5605164a49cc71afcea0793ad09df720f1abff14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5605164a49cc71afcea0793ad09df720f1abff14"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f2ef25b08f782a9f72adb8e6389ce66d302594b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f2ef25b08f782a9f72adb8e6389ce66d302594b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f2ef25b08f782a9f72adb8e6389ce66d302594b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f2ef25b08f782a9f72adb8e6389ce66d302594b/comments", "author": null, "committer": null, "parents": [{"sha": "04affb328c6a7e29427287c5192da38864f0dbca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04affb328c6a7e29427287c5192da38864f0dbca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04affb328c6a7e29427287c5192da38864f0dbca"}], "stats": {"total": 106, "additions": 64, "deletions": 42}, "files": [{"sha": "ef0c74c3f08284e8d5f1358d16b84bce598e2577", "filename": "gcc/c-family/c-ada-spec.c", "status": "modified", "additions": 64, "deletions": 42, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f2ef25b08f782a9f72adb8e6389ce66d302594b/gcc%2Fc-family%2Fc-ada-spec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f2ef25b08f782a9f72adb8e6389ce66d302594b/gcc%2Fc-family%2Fc-ada-spec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-ada-spec.c?ref=5f2ef25b08f782a9f72adb8e6389ce66d302594b", "patch": "@@ -2003,7 +2003,15 @@ dump_ada_enum_type (pretty_printer *buffer, tree node, tree type, tree parent,\n \t  pp_semicolon (buffer);\n \t  newline_and_indent (buffer, spc);\n \n+\t  if (TYPE_NAME (node))\n+\t    dump_ada_node (buffer, node, NULL_TREE, spc, false, true);\n+\t  else if (type)\n+\t    dump_ada_node (buffer, type, NULL_TREE, spc, false, true);\n+\t  else\n+\t    dump_anonymous_type_name (buffer, node, parent);\n+\t  pp_underscore (buffer);\n \t  pp_ada_tree_identifier (buffer, TREE_PURPOSE (value), node, false);\n+\n \t  pp_string (buffer, \" : constant \");\n \n \t  if (TYPE_NAME (node))\n@@ -2628,53 +2636,63 @@ struct overloaded_name_hasher : delete_ptr_hash<overloaded_name_hash>\n     { return a->name == b->name; }\n };\n \n-static hash_table<overloaded_name_hasher> *overloaded_names;\n+typedef hash_table<overloaded_name_hasher> htable_t;\n+\n+static htable_t *overloaded_names;\n+\n+/* Add an overloaded NAME with N occurrences to TABLE.  */\n+\n+static void\n+add_name (const char *name, unsigned int n, htable_t *table)\n+{\n+  struct overloaded_name_hash in, *h, **slot;\n+  tree id = get_identifier (name);\n+  hashval_t hash = htab_hash_pointer (id);\n+  in.hash = hash;\n+  in.name = id;\n+  slot = table->find_slot_with_hash (&in, hash, INSERT);\n+  h = new overloaded_name_hash;\n+  h->hash = hash;\n+  h->name = id;\n+  h->n = n;\n+  *slot = h;\n+}\n \n /* Initialize the table with the problematic overloaded names.  */\n \n-static hash_table<overloaded_name_hasher> *\n+static htable_t *\n init_overloaded_names (void)\n {\n   static const char *names[] =\n   /* The overloaded names from the /usr/include/string.h file.  */\n   { \"memchr\", \"rawmemchr\", \"memrchr\", \"strchr\", \"strrchr\", \"strchrnul\",\n     \"strpbrk\", \"strstr\", \"strcasestr\", \"index\", \"rindex\", \"basename\" };\n \n-  hash_table<overloaded_name_hasher> *table\n-    = new hash_table<overloaded_name_hasher> (64);\n+  htable_t *table = new htable_t (64);\n \n   for (unsigned int i = 0; i < ARRAY_SIZE (names); i++)\n-    {\n-      struct overloaded_name_hash in, *h, **slot;\n-      tree id = get_identifier (names[i]);\n-      hashval_t hash = htab_hash_pointer (id);\n-      in.hash = hash;\n-      in.name = id;\n-      slot = table->find_slot_with_hash (&in, hash, INSERT);\n-      h = new overloaded_name_hash;\n-      h->hash = hash;\n-      h->name = id;\n-      h->n = 0;\n-      *slot = h;\n-    }\n+    add_name (names[i], 0, table);\n+\n+  /* Consider that sigaction() is overloaded by struct sigaction for QNX.  */\n+  add_name (\"sigaction\", 1, table);\n+\n+  /* Consider that stat() is overloaded by struct stat for QNX.  */\n+  add_name (\"stat\", 1, table);\n \n   return table;\n }\n \n-/* Return whether NAME cannot be supported as overloaded name.  */\n+/* Return the overloading index of NAME or 0 if NAME is not overloaded.  */\n \n-static bool\n-overloaded_name_p (tree name)\n+static unsigned int\n+overloading_index (tree name)\n {\n-  if (!overloaded_names)\n-    overloaded_names = init_overloaded_names ();\n-\n   struct overloaded_name_hash in, *h;\n   hashval_t hash = htab_hash_pointer (name);\n   in.hash = hash;\n   in.name = name;\n   h = overloaded_names->find_with_hash (&in, hash);\n-  return h && ++h->n > 1;\n+  return h ? ++h->n : 0;\n }\n \n /* Dump in BUFFER constructor spec corresponding to T for TYPE.  */\n@@ -2798,14 +2816,17 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \t}\n \n       /* Skip unnamed or anonymous structs/unions/enum types.  */\n-      if (!orig && !decl_name && !name\n+      if (!orig\n \t  && (RECORD_OR_UNION_TYPE_P (TREE_TYPE (t))\n-\t      || TREE_CODE (TREE_TYPE (t)) == ENUMERAL_TYPE))\n+\t      || TREE_CODE (TREE_TYPE (t)) == ENUMERAL_TYPE)\n+\t  && !decl_name\n+\t  && !name)\n \treturn 0;\n \n-\t/* Skip anonymous enum types (duplicates of real types).  */\n+      /* Skip duplicates of structs/unions/enum types built in C++.  */\n       if (!orig\n-\t  && TREE_CODE (TREE_TYPE (t)) == ENUMERAL_TYPE\n+\t  && (RECORD_OR_UNION_TYPE_P (TREE_TYPE (t))\n+\t      || TREE_CODE (TREE_TYPE (t)) == ENUMERAL_TYPE)\n \t  && decl_name\n \t  && (*IDENTIFIER_POINTER (decl_name) == '.'\n \t      || *IDENTIFIER_POINTER (decl_name) == '$'))\n@@ -2826,16 +2847,6 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \t\treturn 1;\n \t      }\n \n-\t    if (decl_name\n-\t\t&& (*IDENTIFIER_POINTER (decl_name) == '.'\n-\t\t    || *IDENTIFIER_POINTER (decl_name) == '$'))\n-\t      {\n-\t\tpp_string (buffer, \"--  skipped anonymous struct \");\n-\t\tdump_ada_node (buffer, t, type, spc, false, true);\n-\t\tTREE_VISITED (t) = 1;\n-\t\treturn 1;\n-\t      }\n-\n \t    /* ??? Packed record layout is not supported.  */\n \t    if (TYPE_PACKED (TREE_TYPE (t)))\n \t      {\n@@ -2869,7 +2880,11 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \t  case POINTER_TYPE:\n \t  case REFERENCE_TYPE:\n \t    dump_forward_type (buffer, TREE_TYPE (TREE_TYPE (t)), t, spc);\n-\t    /* fallthrough */\n+\t    if (orig && TYPE_NAME (orig))\n+\t      pp_string (buffer, \"subtype \");\n+\t    else\n+\t      pp_string (buffer, \"type \");\n+\t    break;\n \n \t  case ARRAY_TYPE:\n \t    if ((orig && TYPE_NAME (orig)) || is_char_array (TREE_TYPE (t)))\n@@ -2945,17 +2960,17 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n     }\n   else if (TREE_CODE (t) == FUNCTION_DECL)\n     {\n+      tree decl_name = DECL_NAME (t);\n       bool is_abstract_class = false;\n       bool is_method = TREE_CODE (TREE_TYPE (t)) == METHOD_TYPE;\n-      tree decl_name = DECL_NAME (t);\n       bool is_abstract = false;\n       bool is_assignment_operator = false;\n       bool is_constructor = false;\n       bool is_destructor = false;\n       bool is_copy_constructor = false;\n       bool is_move_constructor = false;\n \n-      if (!decl_name || overloaded_name_p (decl_name))\n+      if (!decl_name)\n \treturn 0;\n \n       if (cpp_check)\n@@ -3018,7 +3033,12 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n       else if (is_assignment_operator)\n \tprint_assignment_operator (buffer, t, type);\n       else\n-\tdump_ada_decl_name (buffer, t, false);\n+\t{\n+\t  const unsigned int suffix = overloading_index (decl_name);\n+\t  pp_ada_tree_identifier (buffer, decl_name, t, false);\n+\t  if (suffix > 1)\n+\t    pp_decimal_int (buffer, suffix);\n+\t}\n \n       dump_ada_function_declaration\n \t(buffer, t, is_method, is_constructor, is_destructor, spc);\n@@ -3477,6 +3497,8 @@ dump_ada_specs (void (*collect_all_refs)(const char *),\n {\n   bitmap_obstack_initialize (NULL);\n \n+  overloaded_names = init_overloaded_names ();\n+\n   /* Iterate over the list of files to dump specs for.  */\n   for (int i = 0; i < source_refs_used; i++)\n     dump_ads (source_refs[i], collect_all_refs, check);"}]}