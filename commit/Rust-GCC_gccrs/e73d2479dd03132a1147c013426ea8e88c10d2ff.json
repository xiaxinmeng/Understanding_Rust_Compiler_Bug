{"sha": "e73d2479dd03132a1147c013426ea8e88c10d2ff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTczZDI0NzlkZDAzMTMyYTExNDdjMDEzNDI2ZWE4ZTg4YzEwZDJmZg==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2013-12-10T00:42:14Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2013-12-10T00:42:14Z"}, "message": "ffitarget.h: Import from upstream.\n\n\t* src/powerpc/ffitarget.h: Import from upstream.\n\t* src/powerpc/ffi_powerpc.h: Likewise.\n\t* src/powerpc/ffi.c: Likewise.\n\t* src/powerpc/ffi_sysv.c: Likewise.\n\t* src/powerpc/ffi_linux64.c: Likewise.\n\t* src/powerpc/sysv.S: Likewise.\n\t* src/powerpc/ppc_closure.S: Likewise.\n\t* src/powerpc/linux64.S: Likewise.\n\t* src/powerpc/linux64_closure.S: Likewise.\n\t* src/types.c: Likewise.\n\t* Makefile.am (EXTRA_DIST): Add new src/powerpc files.\n\t(nodist_libffi_la_SOURCES <POWERPC, POWERPC_FREEBSD>): Likewise.\n\t* configure.ac (HAVE_LONG_DOUBLE_VARIANT): Define for powerpc.\n\t* include/ffi.h.in (ffi_prep_types): Declare.\n\t* src/prep_cif.c (ffi_prep_cif_core): Call ffi_prep_types.\n\t* configure: Regenerate.\n\t* fficonfig.h.in: Regenerate.\n\t* Makefile.in: Regenerate.\n\t* man/Makefile.in: Regenerate.\n\t* include/Makefile.in: Regenerate.\n\t* testsuite/Makefile.in: Regenerate.\n\nFrom-SVN: r205844", "tree": {"sha": "c11e6385bf866d6954cff7942932cc7e897dc4d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c11e6385bf866d6954cff7942932cc7e897dc4d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e73d2479dd03132a1147c013426ea8e88c10d2ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e73d2479dd03132a1147c013426ea8e88c10d2ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e73d2479dd03132a1147c013426ea8e88c10d2ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e73d2479dd03132a1147c013426ea8e88c10d2ff/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3e0fc59aa0e1bca6f3c7ced40489cab2cf6df6e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e0fc59aa0e1bca6f3c7ced40489cab2cf6df6e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e0fc59aa0e1bca6f3c7ced40489cab2cf6df6e6"}], "stats": {"total": 3969, "additions": 2187, "deletions": 1782}, "files": [{"sha": "6d531de099a38b9cd6ec81f595f27f44bcfc3bdf", "filename": "libffi/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d2479dd03132a1147c013426ea8e88c10d2ff/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d2479dd03132a1147c013426ea8e88c10d2ff/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=e73d2479dd03132a1147c013426ea8e88c10d2ff", "patch": "@@ -1,3 +1,27 @@\n+2013-12-10  Alan Modra  <amodra@gmail.com>\n+\n+\t* src/powerpc/ffitarget.h: Import from upstream.\n+\t* src/powerpc/ffi_powerpc.h: Likewise.\n+\t* src/powerpc/ffi.c: Likewise.\n+\t* src/powerpc/ffi_sysv.c: Likewise.\n+\t* src/powerpc/ffi_linux64.c: Likewise.\n+\t* src/powerpc/sysv.S: Likewise.\n+\t* src/powerpc/ppc_closure.S: Likewise.\n+\t* src/powerpc/linux64.S: Likewise.\n+\t* src/powerpc/linux64_closure.S: Likewise.\n+\t* src/types.c: Likewise.\n+\t* Makefile.am (EXTRA_DIST): Add new src/powerpc files.\n+\t(nodist_libffi_la_SOURCES <POWERPC, POWERPC_FREEBSD>): Likewise.\n+\t* configure.ac (HAVE_LONG_DOUBLE_VARIANT): Define for powerpc.\n+\t* include/ffi.h.in (ffi_prep_types): Declare.\n+\t* src/prep_cif.c (ffi_prep_cif_core): Call ffi_prep_types.\n+\t* configure: Regenerate.\n+\t* fficonfig.h.in: Regenerate.\n+\t* Makefile.in: Regenerate.\n+\t* man/Makefile.in: Regenerate.\n+\t* include/Makefile.in: Regenerate.\n+\t* testsuite/Makefile.in: Regenerate.\n+\n 2013-11-18  Alan Modra  <amodra@gmail.com>\n \n \t* src/powerpc/ppc_closure.S: Don't bl .Luint128."}, {"sha": "645dc1243ebbc03cd673c54e2b4210c9fa1e0875", "filename": "libffi/Makefile.am", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d2479dd03132a1147c013426ea8e88c10d2ff/libffi%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d2479dd03132a1147c013426ea8e88c10d2ff/libffi%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FMakefile.am?ref=e73d2479dd03132a1147c013426ea8e88c10d2ff", "patch": "@@ -15,10 +15,12 @@ EXTRA_DIST = LICENSE ChangeLog.v1 ChangeLog.libgcj configure.host\t\\\n \t src/ia64/unix.S src/mips/ffi.c src/mips/n32.S src/mips/o32.S\t\\\n \t src/mips/ffitarget.h src/m32r/ffi.c src/m32r/sysv.S\t\t\\\n \t src/m32r/ffitarget.h src/m68k/ffi.c src/m68k/sysv.S\t\t\\\n-\t src/m68k/ffitarget.h src/powerpc/ffi.c src/powerpc/sysv.S\t\\\n-\t src/powerpc/linux64.S src/powerpc/linux64_closure.S\t\t\\\n-\t src/powerpc/ppc_closure.S src/powerpc/asm.h\t\t\t\\\n-\tsrc/powerpc/aix.S src/powerpc/darwin.S\t\t\t\t\\\n+\t src/m68k/ffitarget.h\t\t\t\t\t\t\\\n+\tsrc/powerpc/ffi.c src/powerpc/ffi_powerpc.h\t\t\t\\\n+\tsrc/powerpc/ffi_sysv.c src/powerpc/ffi_linux64.c\t\t\\\n+\tsrc/powerpc/sysv.S src/powerpc/linux64.S\t\t\t\\\n+\tsrc/powerpc/linux64_closure.S src/powerpc/ppc_closure.S\t\t\\\n+\tsrc/powerpc/asm.h src/powerpc/aix.S src/powerpc/darwin.S\t\\\n \tsrc/powerpc/aix_closure.S src/powerpc/darwin_closure.S\t\t\\\n \tsrc/powerpc/ffi_darwin.c src/powerpc/ffitarget.h\t\t\\\n \tsrc/s390/ffi.c src/s390/sysv.S src/s390/ffitarget.h\t\t\\\n@@ -179,7 +181,7 @@ if M68K\n nodist_libffi_la_SOURCES += src/m68k/ffi.c src/m68k/sysv.S\n endif\n if POWERPC\n-nodist_libffi_la_SOURCES += src/powerpc/ffi.c src/powerpc/sysv.S src/powerpc/ppc_closure.S src/powerpc/linux64.S src/powerpc/linux64_closure.S\n+nodist_libffi_la_SOURCES += src/powerpc/ffi.c src/powerpc/ffi_sysv.c src/powerpc/ffi_linux64.c src/powerpc/sysv.S src/powerpc/ppc_closure.S src/powerpc/linux64.S src/powerpc/linux64_closure.S\n endif\n if POWERPC_AIX\n nodist_libffi_la_SOURCES += src/powerpc/ffi_darwin.c src/powerpc/aix.S src/powerpc/aix_closure.S\n@@ -188,7 +190,7 @@ if POWERPC_DARWIN\n nodist_libffi_la_SOURCES += src/powerpc/ffi_darwin.c src/powerpc/darwin.S src/powerpc/darwin_closure.S\n endif\n if POWERPC_FREEBSD\n-nodist_libffi_la_SOURCES += src/powerpc/ffi.c src/powerpc/sysv.S src/powerpc/ppc_closure.S\n+nodist_libffi_la_SOURCES += src/powerpc/ffi.c src/powerpc/ffi_sysv.c src/powerpc/sysv.S src/powerpc/ppc_closure.S\n endif\n if AARCH64\n nodist_libffi_la_SOURCES += src/aarch64/sysv.S src/aarch64/ffi.c"}, {"sha": "9ac95d49bdfa0c8c0c8d34a4ed91ceb8e54adf88", "filename": "libffi/Makefile.in", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d2479dd03132a1147c013426ea8e88c10d2ff/libffi%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d2479dd03132a1147c013426ea8e88c10d2ff/libffi%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FMakefile.in?ref=e73d2479dd03132a1147c013426ea8e88c10d2ff", "patch": "@@ -48,10 +48,10 @@ target_triplet = @target@\n @IA64_TRUE@am__append_11 = src/ia64/ffi.c src/ia64/unix.S\n @M32R_TRUE@am__append_12 = src/m32r/sysv.S src/m32r/ffi.c\n @M68K_TRUE@am__append_13 = src/m68k/ffi.c src/m68k/sysv.S\n-@POWERPC_TRUE@am__append_14 = src/powerpc/ffi.c src/powerpc/sysv.S src/powerpc/ppc_closure.S src/powerpc/linux64.S src/powerpc/linux64_closure.S\n+@POWERPC_TRUE@am__append_14 = src/powerpc/ffi.c src/powerpc/ffi_sysv.c src/powerpc/ffi_linux64.c src/powerpc/sysv.S src/powerpc/ppc_closure.S src/powerpc/linux64.S src/powerpc/linux64_closure.S\n @POWERPC_AIX_TRUE@am__append_15 = src/powerpc/ffi_darwin.c src/powerpc/aix.S src/powerpc/aix_closure.S\n @POWERPC_DARWIN_TRUE@am__append_16 = src/powerpc/ffi_darwin.c src/powerpc/darwin.S src/powerpc/darwin_closure.S\n-@POWERPC_FREEBSD_TRUE@am__append_17 = src/powerpc/ffi.c src/powerpc/sysv.S src/powerpc/ppc_closure.S\n+@POWERPC_FREEBSD_TRUE@am__append_17 = src/powerpc/ffi.c src/powerpc/ffi_sysv.c src/powerpc/sysv.S src/powerpc/ppc_closure.S\n @AARCH64_TRUE@am__append_18 = src/aarch64/sysv.S src/aarch64/ffi.c\n @ARM_TRUE@am__append_19 = src/arm/sysv.S src/arm/ffi.c\n @ARM_TRUE@@FFI_EXEC_TRAMPOLINE_TABLE_TRUE@am__append_20 = src/arm/trampoline.S\n@@ -136,7 +136,9 @@ am_libffi_la_OBJECTS = src/prep_cif.lo src/types.lo src/raw_api.lo \\\n @IA64_TRUE@am__objects_11 = src/ia64/ffi.lo src/ia64/unix.lo\n @M32R_TRUE@am__objects_12 = src/m32r/sysv.lo src/m32r/ffi.lo\n @M68K_TRUE@am__objects_13 = src/m68k/ffi.lo src/m68k/sysv.lo\n-@POWERPC_TRUE@am__objects_14 = src/powerpc/ffi.lo src/powerpc/sysv.lo \\\n+@POWERPC_TRUE@am__objects_14 = src/powerpc/ffi.lo \\\n+@POWERPC_TRUE@\tsrc/powerpc/ffi_sysv.lo \\\n+@POWERPC_TRUE@\tsrc/powerpc/ffi_linux64.lo src/powerpc/sysv.lo \\\n @POWERPC_TRUE@\tsrc/powerpc/ppc_closure.lo \\\n @POWERPC_TRUE@\tsrc/powerpc/linux64.lo \\\n @POWERPC_TRUE@\tsrc/powerpc/linux64_closure.lo\n@@ -147,6 +149,7 @@ am_libffi_la_OBJECTS = src/prep_cif.lo src/types.lo src/raw_api.lo \\\n @POWERPC_DARWIN_TRUE@\tsrc/powerpc/darwin.lo \\\n @POWERPC_DARWIN_TRUE@\tsrc/powerpc/darwin_closure.lo\n @POWERPC_FREEBSD_TRUE@am__objects_17 = src/powerpc/ffi.lo \\\n+@POWERPC_FREEBSD_TRUE@\tsrc/powerpc/ffi_sysv.lo \\\n @POWERPC_FREEBSD_TRUE@\tsrc/powerpc/sysv.lo \\\n @POWERPC_FREEBSD_TRUE@\tsrc/powerpc/ppc_closure.lo\n @AARCH64_TRUE@am__objects_18 = src/aarch64/sysv.lo src/aarch64/ffi.lo\n@@ -319,6 +322,7 @@ FFI_EXEC_TRAMPOLINE_TABLE = @FFI_EXEC_TRAMPOLINE_TABLE@\n FGREP = @FGREP@\n GREP = @GREP@\n HAVE_LONG_DOUBLE = @HAVE_LONG_DOUBLE@\n+HAVE_LONG_DOUBLE_VARIANT = @HAVE_LONG_DOUBLE_VARIANT@\n INSTALL = @INSTALL@\n INSTALL_DATA = @INSTALL_DATA@\n INSTALL_PROGRAM = @INSTALL_PROGRAM@\n@@ -428,10 +432,12 @@ EXTRA_DIST = LICENSE ChangeLog.v1 ChangeLog.libgcj configure.host\t\\\n \t src/ia64/unix.S src/mips/ffi.c src/mips/n32.S src/mips/o32.S\t\\\n \t src/mips/ffitarget.h src/m32r/ffi.c src/m32r/sysv.S\t\t\\\n \t src/m32r/ffitarget.h src/m68k/ffi.c src/m68k/sysv.S\t\t\\\n-\t src/m68k/ffitarget.h src/powerpc/ffi.c src/powerpc/sysv.S\t\\\n-\t src/powerpc/linux64.S src/powerpc/linux64_closure.S\t\t\\\n-\t src/powerpc/ppc_closure.S src/powerpc/asm.h\t\t\t\\\n-\tsrc/powerpc/aix.S src/powerpc/darwin.S\t\t\t\t\\\n+\t src/m68k/ffitarget.h\t\t\t\t\t\t\\\n+\tsrc/powerpc/ffi.c src/powerpc/ffi_powerpc.h\t\t\t\\\n+\tsrc/powerpc/ffi_sysv.c src/powerpc/ffi_linux64.c\t\t\\\n+\tsrc/powerpc/sysv.S src/powerpc/linux64.S\t\t\t\\\n+\tsrc/powerpc/linux64_closure.S src/powerpc/ppc_closure.S\t\t\\\n+\tsrc/powerpc/asm.h src/powerpc/aix.S src/powerpc/darwin.S\t\\\n \tsrc/powerpc/aix_closure.S src/powerpc/darwin_closure.S\t\t\\\n \tsrc/powerpc/ffi_darwin.c src/powerpc/ffitarget.h\t\t\\\n \tsrc/s390/ffi.c src/s390/sysv.S src/s390/ffitarget.h\t\t\\\n@@ -752,6 +758,10 @@ src/powerpc/$(DEPDIR)/$(am__dirstamp):\n \t@: > src/powerpc/$(DEPDIR)/$(am__dirstamp)\n src/powerpc/ffi.lo: src/powerpc/$(am__dirstamp) \\\n \tsrc/powerpc/$(DEPDIR)/$(am__dirstamp)\n+src/powerpc/ffi_sysv.lo: src/powerpc/$(am__dirstamp) \\\n+\tsrc/powerpc/$(DEPDIR)/$(am__dirstamp)\n+src/powerpc/ffi_linux64.lo: src/powerpc/$(am__dirstamp) \\\n+\tsrc/powerpc/$(DEPDIR)/$(am__dirstamp)\n src/powerpc/sysv.lo: src/powerpc/$(am__dirstamp) \\\n \tsrc/powerpc/$(DEPDIR)/$(am__dirstamp)\n src/powerpc/ppc_closure.lo: src/powerpc/$(am__dirstamp) \\\n@@ -953,6 +963,10 @@ mostlyclean-compile:\n \t-rm -f src/powerpc/ffi.lo\n \t-rm -f src/powerpc/ffi_darwin.$(OBJEXT)\n \t-rm -f src/powerpc/ffi_darwin.lo\n+\t-rm -f src/powerpc/ffi_linux64.$(OBJEXT)\n+\t-rm -f src/powerpc/ffi_linux64.lo\n+\t-rm -f src/powerpc/ffi_sysv.$(OBJEXT)\n+\t-rm -f src/powerpc/ffi_sysv.lo\n \t-rm -f src/powerpc/linux64.$(OBJEXT)\n \t-rm -f src/powerpc/linux64.lo\n \t-rm -f src/powerpc/linux64_closure.$(OBJEXT)\n@@ -1050,6 +1064,8 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@src/powerpc/$(DEPDIR)/darwin_closure.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@src/powerpc/$(DEPDIR)/ffi.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@src/powerpc/$(DEPDIR)/ffi_darwin.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@src/powerpc/$(DEPDIR)/ffi_linux64.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@src/powerpc/$(DEPDIR)/ffi_sysv.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@src/powerpc/$(DEPDIR)/linux64.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@src/powerpc/$(DEPDIR)/linux64_closure.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@src/powerpc/$(DEPDIR)/ppc_closure.Plo@am__quote@"}, {"sha": "efb62cdeabd2736ff9f51852ec59454ad209b25d", "filename": "libffi/configure", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d2479dd03132a1147c013426ea8e88c10d2ff/libffi%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d2479dd03132a1147c013426ea8e88c10d2ff/libffi%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fconfigure?ref=e73d2479dd03132a1147c013426ea8e88c10d2ff", "patch": "@@ -613,6 +613,7 @@ TARGET\n FFI_EXEC_TRAMPOLINE_TABLE\n FFI_EXEC_TRAMPOLINE_TABLE_FALSE\n FFI_EXEC_TRAMPOLINE_TABLE_TRUE\n+HAVE_LONG_DOUBLE_VARIANT\n HAVE_LONG_DOUBLE\n ALLOCA\n TILE_FALSE\n@@ -10906,7 +10907,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 10909 \"configure\"\n+#line 10910 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -11012,7 +11013,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11015 \"configure\"\n+#line 11016 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -11449,6 +11450,7 @@ fi\n \n \n TARGETDIR=\"unknown\"\n+HAVE_LONG_DOUBLE_VARIANT=0\n case \"$host\" in\n   aarch64*-*-*)\n \tTARGET=AARCH64; TARGETDIR=aarch64\n@@ -11546,6 +11548,7 @@ case \"$host\" in\n \n   powerpc*-*-linux* | powerpc-*-sysv*)\n \tTARGET=POWERPC; TARGETDIR=powerpc\n+\tHAVE_LONG_DOUBLE_VARIANT=1\n \t;;\n   powerpc-*-amigaos*)\n \tTARGET=POWERPC; TARGETDIR=powerpc\n@@ -11561,6 +11564,7 @@ case \"$host\" in\n \t;;\n   powerpc-*-freebsd* | powerpc-*-openbsd*)\n \tTARGET=POWERPC_FREEBSD; TARGETDIR=powerpc\n+\tHAVE_LONG_DOUBLE_VARIANT=1\n \t;;\n   powerpc64-*-freebsd*)\n \tTARGET=POWERPC; TARGETDIR=powerpc\n@@ -12236,17 +12240,25 @@ _ACEOF\n # Also AC_SUBST this variable for ffi.h.\n if test -z \"$HAVE_LONG_DOUBLE\"; then\n   HAVE_LONG_DOUBLE=0\n-  if test $ac_cv_sizeof_double != $ac_cv_sizeof_long_double; then\n-    if test $ac_cv_sizeof_long_double != 0; then\n+  if test $ac_cv_sizeof_long_double != 0; then\n+    if test $HAVE_LONG_DOUBLE_VARIANT != 0; then\n+\n+$as_echo \"#define HAVE_LONG_DOUBLE_VARIANT 1\" >>confdefs.h\n+\n       HAVE_LONG_DOUBLE=1\n+    else\n+      if test $ac_cv_sizeof_double != $ac_cv_sizeof_long_double; then\n+        HAVE_LONG_DOUBLE=1\n \n $as_echo \"#define HAVE_LONG_DOUBLE 1\" >>confdefs.h\n \n+      fi\n     fi\n   fi\n fi\n \n \n+\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether byte ordering is bigendian\" >&5\n $as_echo_n \"checking whether byte ordering is bigendian... \" >&6; }\n if test \"${ac_cv_c_bigendian+set}\" = set; then :"}, {"sha": "438222775bc4a6aa2c97523785d1e8b7c08f8d45", "filename": "libffi/configure.ac", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d2479dd03132a1147c013426ea8e88c10d2ff/libffi%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d2479dd03132a1147c013426ea8e88c10d2ff/libffi%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fconfigure.ac?ref=e73d2479dd03132a1147c013426ea8e88c10d2ff", "patch": "@@ -65,6 +65,7 @@ dnl The -no-testsuite modules omit the test subdir.\n AM_CONDITIONAL(TESTSUBDIR, test -d $srcdir/testsuite)\n \n TARGETDIR=\"unknown\"\n+HAVE_LONG_DOUBLE_VARIANT=0\n case \"$host\" in\n   aarch64*-*-*)\n \tTARGET=AARCH64; TARGETDIR=aarch64\n@@ -162,6 +163,7 @@ case \"$host\" in\n \n   powerpc*-*-linux* | powerpc-*-sysv*)\n \tTARGET=POWERPC; TARGETDIR=powerpc\n+\tHAVE_LONG_DOUBLE_VARIANT=1\n \t;;\n   powerpc-*-amigaos*)\n \tTARGET=POWERPC; TARGETDIR=powerpc\n@@ -177,6 +179,7 @@ case \"$host\" in\n \t;;\n   powerpc-*-freebsd* | powerpc-*-openbsd*)\n \tTARGET=POWERPC_FREEBSD; TARGETDIR=powerpc\n+\tHAVE_LONG_DOUBLE_VARIANT=1\n \t;;\n   powerpc64-*-freebsd*)\n \tTARGET=POWERPC; TARGETDIR=powerpc\n@@ -273,14 +276,20 @@ AC_CHECK_SIZEOF(long double)\n # Also AC_SUBST this variable for ffi.h.\n if test -z \"$HAVE_LONG_DOUBLE\"; then\n   HAVE_LONG_DOUBLE=0\n-  if test $ac_cv_sizeof_double != $ac_cv_sizeof_long_double; then\n-    if test $ac_cv_sizeof_long_double != 0; then\n+  if test $ac_cv_sizeof_long_double != 0; then\n+    if test $HAVE_LONG_DOUBLE_VARIANT != 0; then\n+      AC_DEFINE(HAVE_LONG_DOUBLE_VARIANT, 1, [Define if you support more than one size of the long double type])\n       HAVE_LONG_DOUBLE=1\n-      AC_DEFINE(HAVE_LONG_DOUBLE, 1, [Define if you have the long double type and it is bigger than a double])\n+    else\n+      if test $ac_cv_sizeof_double != $ac_cv_sizeof_long_double; then\n+        HAVE_LONG_DOUBLE=1\n+        AC_DEFINE(HAVE_LONG_DOUBLE, 1, [Define if you have the long double type and it is bigger than a double])\n+      fi\n     fi\n   fi\n fi\n AC_SUBST(HAVE_LONG_DOUBLE)\n+AC_SUBST(HAVE_LONG_DOUBLE_VARIANT)\n \n AC_C_BIGENDIAN\n "}, {"sha": "19d66d02179f76bd6a5ea6f4c6c58ca71bdf588a", "filename": "libffi/fficonfig.h.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d2479dd03132a1147c013426ea8e88c10d2ff/libffi%2Ffficonfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d2479dd03132a1147c013426ea8e88c10d2ff/libffi%2Ffficonfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ffficonfig.h.in?ref=e73d2479dd03132a1147c013426ea8e88c10d2ff", "patch": "@@ -73,6 +73,9 @@\n /* Define if you have the long double type and it is bigger than a double */\n #undef HAVE_LONG_DOUBLE\n \n+/* Define if you support more than one size of the long double type */\n+#undef HAVE_LONG_DOUBLE_VARIANT\n+\n /* Define to 1 if you have the `memcpy' function. */\n #undef HAVE_MEMCPY\n "}, {"sha": "2a42902d398e2222b1d2ef66253a765fc831aafc", "filename": "libffi/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d2479dd03132a1147c013426ea8e88c10d2ff/libffi%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d2479dd03132a1147c013426ea8e88c10d2ff/libffi%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Finclude%2FMakefile.in?ref=e73d2479dd03132a1147c013426ea8e88c10d2ff", "patch": "@@ -115,6 +115,7 @@ FFI_EXEC_TRAMPOLINE_TABLE = @FFI_EXEC_TRAMPOLINE_TABLE@\n FGREP = @FGREP@\n GREP = @GREP@\n HAVE_LONG_DOUBLE = @HAVE_LONG_DOUBLE@\n+HAVE_LONG_DOUBLE_VARIANT = @HAVE_LONG_DOUBLE_VARIANT@\n INSTALL = @INSTALL@\n INSTALL_DATA = @INSTALL_DATA@\n INSTALL_PROGRAM = @INSTALL_PROGRAM@"}, {"sha": "380673b0b342b55a1df84af72ac8828495572ec2", "filename": "libffi/include/ffi.h.in", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d2479dd03132a1147c013426ea8e88c10d2ff/libffi%2Finclude%2Fffi.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d2479dd03132a1147c013426ea8e88c10d2ff/libffi%2Finclude%2Fffi.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Finclude%2Fffi.h.in?ref=e73d2479dd03132a1147c013426ea8e88c10d2ff", "patch": "@@ -207,6 +207,11 @@ typedef struct {\n #endif\n } ffi_cif;\n \n+#if HAVE_LONG_DOUBLE_VARIANT\n+/* Used to adjust size/alignment of ffi types.  */\n+void ffi_prep_types (ffi_abi abi);\n+# endif\n+\n /* Used internally, but overridden by some architectures */\n ffi_status ffi_prep_cif_core(ffi_cif *cif,\n \t\t\t     ffi_abi abi,"}, {"sha": "b5ed121df3dc7795b5a4edb29f0ae84119874cea", "filename": "libffi/man/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d2479dd03132a1147c013426ea8e88c10d2ff/libffi%2Fman%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d2479dd03132a1147c013426ea8e88c10d2ff/libffi%2Fman%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fman%2FMakefile.in?ref=e73d2479dd03132a1147c013426ea8e88c10d2ff", "patch": "@@ -113,6 +113,7 @@ FFI_EXEC_TRAMPOLINE_TABLE = @FFI_EXEC_TRAMPOLINE_TABLE@\n FGREP = @FGREP@\n GREP = @GREP@\n HAVE_LONG_DOUBLE = @HAVE_LONG_DOUBLE@\n+HAVE_LONG_DOUBLE_VARIANT = @HAVE_LONG_DOUBLE_VARIANT@\n INSTALL = @INSTALL@\n INSTALL_DATA = @INSTALL_DATA@\n INSTALL_PROGRAM = @INSTALL_PROGRAM@"}, {"sha": "efb441bbfc03fd036735bff340e27441cd742aa0", "filename": "libffi/src/powerpc/ffi.c", "status": "modified", "additions": 51, "deletions": 1715, "changes": 1766, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d2479dd03132a1147c013426ea8e88c10d2ff/libffi%2Fsrc%2Fpowerpc%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d2479dd03132a1147c013426ea8e88c10d2ff/libffi%2Fsrc%2Fpowerpc%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fffi.c?ref=e73d2479dd03132a1147c013426ea8e88c10d2ff", "patch": "@@ -1,5 +1,6 @@\n /* -----------------------------------------------------------------------\n-   ffi.c - Copyright (C) 2011 Anthony Green\n+   ffi.c - Copyright (C) 2013 IBM\n+           Copyright (C) 2011 Anthony Green\n            Copyright (C) 2011 Kyle Moffett\n            Copyright (C) 2008 Red Hat, Inc\n            Copyright (C) 2007, 2008 Free Software Foundation, Inc\n@@ -27,1112 +28,60 @@\n    OTHER DEALINGS IN THE SOFTWARE.\n    ----------------------------------------------------------------------- */\n \n-#include <ffi.h>\n-#include <ffi_common.h>\n-\n-#include <stdlib.h>\n-#include <stdio.h>\n-\n-\n-extern void ffi_closure_SYSV (void);\n-extern void FFI_HIDDEN ffi_closure_LINUX64 (void);\n-\n-enum {\n-  /* The assembly depends on these exact flags.  */\n-  FLAG_RETURNS_SMST\t= 1 << (31-31), /* Used for FFI_SYSV small structs.  */\n-  FLAG_RETURNS_NOTHING  = 1 << (31-30), /* These go in cr7 */\n-#ifndef __NO_FPRS__\n-  FLAG_RETURNS_FP       = 1 << (31-29),\n-#endif\n-  FLAG_RETURNS_64BITS   = 1 << (31-28),\n-\n-  FLAG_RETURNS_128BITS  = 1 << (31-27), /* cr6  */\n-\n-  FLAG_ARG_NEEDS_COPY   = 1 << (31- 7),\n-  FLAG_ARG_NEEDS_PSAVE  = FLAG_ARG_NEEDS_COPY, /* Used by ELFv2 */\n-#ifndef __NO_FPRS__\n-  FLAG_FP_ARGUMENTS     = 1 << (31- 6), /* cr1.eq; specified by ABI */\n-#endif\n-  FLAG_4_GPR_ARGUMENTS  = 1 << (31- 5),\n-  FLAG_RETVAL_REFERENCE = 1 << (31- 4)\n-};\n-\n-/* About the SYSV ABI.  */\n-#define ASM_NEEDS_REGISTERS 4\n-#define NUM_GPR_ARG_REGISTERS 8\n-#ifndef __NO_FPRS__\n-# define NUM_FPR_ARG_REGISTERS 8\n-#endif\n-\n-/* ffi_prep_args_SYSV is called by the assembly routine once stack space\n-   has been allocated for the function's arguments.\n-\n-   The stack layout we want looks like this:\n-\n-   |   Return address from ffi_call_SYSV 4bytes\t|\thigher addresses\n-   |--------------------------------------------|\n-   |   Previous backchain pointer\t4\t|       stack pointer here\n-   |--------------------------------------------|<+ <<<\ton entry to\n-   |   Saved r28-r31\t\t\t4*4\t| |\tffi_call_SYSV\n-   |--------------------------------------------| |\n-   |   GPR registers r3-r10\t\t8*4\t| |\tffi_call_SYSV\n-   |--------------------------------------------| |\n-   |   FPR registers f1-f8 (optional)\t8*8\t| |\n-   |--------------------------------------------| |\tstack\t|\n-   |   Space for copied structures\t\t| |\tgrows\t|\n-   |--------------------------------------------| |\tdown    V\n-   |   Parameters that didn't fit in registers  | |\n-   |--------------------------------------------| |\tlower addresses\n-   |   Space for callee's LR\t\t4\t| |\n-   |--------------------------------------------| |\tstack pointer here\n-   |   Current backchain pointer\t4\t|-/\tduring\n-   |--------------------------------------------|   <<<\tffi_call_SYSV\n-\n-*/\n-\n-void\n-ffi_prep_args_SYSV (extended_cif *ecif, unsigned *const stack)\n-{\n-  const unsigned bytes = ecif->cif->bytes;\n-  const unsigned flags = ecif->cif->flags;\n-\n-  typedef union {\n-    char *c;\n-    unsigned *u;\n-    long long *ll;\n-    float *f;\n-    double *d;\n-  } valp;\n-\n-  /* 'stacktop' points at the previous backchain pointer.  */\n-  valp stacktop;\n-\n-  /* 'gpr_base' points at the space for gpr3, and grows upwards as\n-     we use GPR registers.  */\n-  valp gpr_base;\n-  int intarg_count;\n-\n-#ifndef __NO_FPRS__\n-  /* 'fpr_base' points at the space for fpr1, and grows upwards as\n-     we use FPR registers.  */\n-  valp fpr_base;\n-  int fparg_count;\n-#endif\n-\n-  /* 'copy_space' grows down as we put structures in it.  It should\n-     stay 16-byte aligned.  */\n-  valp copy_space;\n-\n-  /* 'next_arg' grows up as we put parameters in it.  */\n-  valp next_arg;\n-\n-  int i;\n-  ffi_type **ptr;\n-#ifndef __NO_FPRS__\n-  double double_tmp;\n-#endif\n-  union {\n-    void **v;\n-    char **c;\n-    signed char **sc;\n-    unsigned char **uc;\n-    signed short **ss;\n-    unsigned short **us;\n-    unsigned int **ui;\n-    long long **ll;\n-    float **f;\n-    double **d;\n-  } p_argv;\n-  size_t struct_copy_size;\n-  unsigned gprvalue;\n-\n-  stacktop.c = (char *) stack + bytes;\n-  gpr_base.u = stacktop.u - ASM_NEEDS_REGISTERS - NUM_GPR_ARG_REGISTERS;\n-  intarg_count = 0;\n-#ifndef __NO_FPRS__\n-  fpr_base.d = gpr_base.d - NUM_FPR_ARG_REGISTERS;\n-  fparg_count = 0;\n-  copy_space.c = ((flags & FLAG_FP_ARGUMENTS) ? fpr_base.c : gpr_base.c);\n-#else\n-  copy_space.c = gpr_base.c;\n-#endif\n-  next_arg.u = stack + 2;\n-\n-  /* Check that everything starts aligned properly.  */\n-  FFI_ASSERT (((unsigned long) (char *) stack & 0xF) == 0);\n-  FFI_ASSERT (((unsigned long) copy_space.c & 0xF) == 0);\n-  FFI_ASSERT (((unsigned long) stacktop.c & 0xF) == 0);\n-  FFI_ASSERT ((bytes & 0xF) == 0);\n-  FFI_ASSERT (copy_space.c >= next_arg.c);\n-\n-  /* Deal with return values that are actually pass-by-reference.  */\n-  if (flags & FLAG_RETVAL_REFERENCE)\n-    {\n-      *gpr_base.u++ = (unsigned long) (char *) ecif->rvalue;\n-      intarg_count++;\n-    }\n-\n-  /* Now for the arguments.  */\n-  p_argv.v = ecif->avalue;\n-  for (ptr = ecif->cif->arg_types, i = ecif->cif->nargs;\n-       i > 0;\n-       i--, ptr++, p_argv.v++)\n-    {\n-      unsigned short typenum = (*ptr)->type;\n-\n-      /* We may need to handle some values depending on ABI */\n-      if (ecif->cif->abi == FFI_LINUX_SOFT_FLOAT) {\n-\t\tif (typenum == FFI_TYPE_FLOAT)\n-\t\t\ttypenum = FFI_TYPE_UINT32;\n-\t\tif (typenum == FFI_TYPE_DOUBLE)\n-\t\t\ttypenum = FFI_TYPE_UINT64;\n-\t\tif (typenum == FFI_TYPE_LONGDOUBLE)\n-\t\t\ttypenum = FFI_TYPE_UINT128;\n-      } else if (ecif->cif->abi != FFI_LINUX) {\n-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n-\t\tif (typenum == FFI_TYPE_LONGDOUBLE)\n-\t\t\ttypenum = FFI_TYPE_STRUCT;\n-#endif\n-      }\n-\n-      /* Now test the translated value */\n-      switch (typenum) {\n-#ifndef __NO_FPRS__\n-\tcase FFI_TYPE_FLOAT:\n-\t  /* With FFI_LINUX_SOFT_FLOAT floats are handled like UINT32.  */\n-\t  double_tmp = **p_argv.f;\n-\t  if (fparg_count >= NUM_FPR_ARG_REGISTERS)\n-\t    {\n-\t      *next_arg.f = (float) double_tmp;\n-\t      next_arg.u += 1;\n-\t      intarg_count++;\n-\t    }\n-\t  else\n-\t    *fpr_base.d++ = double_tmp;\n-\t  fparg_count++;\n-\t  FFI_ASSERT (flags & FLAG_FP_ARGUMENTS);\n-\t  break;\n-\n-\tcase FFI_TYPE_DOUBLE:\n-\t  /* With FFI_LINUX_SOFT_FLOAT doubles are handled like UINT64.  */\n-\t  double_tmp = **p_argv.d;\n-\n-\t  if (fparg_count >= NUM_FPR_ARG_REGISTERS)\n-\t    {\n-\t      if (intarg_count >= NUM_GPR_ARG_REGISTERS\n-\t\t  && intarg_count % 2 != 0)\n-\t\t{\n-\t\t  intarg_count++;\n-\t\t  next_arg.u++;\n-\t\t}\n-\t      *next_arg.d = double_tmp;\n-\t      next_arg.u += 2;\n-\t    }\n-\t  else\n-\t    *fpr_base.d++ = double_tmp;\n-\t  fparg_count++;\n-\t  FFI_ASSERT (flags & FLAG_FP_ARGUMENTS);\n-\t  break;\n-\n-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n-\tcase FFI_TYPE_LONGDOUBLE:\n-\t      double_tmp = (*p_argv.d)[0];\n-\n-\t      if (fparg_count >= NUM_FPR_ARG_REGISTERS - 1)\n-\t\t{\n-\t\t  if (intarg_count >= NUM_GPR_ARG_REGISTERS\n-\t\t      && intarg_count % 2 != 0)\n-\t\t    {\n-\t\t      intarg_count++;\n-\t\t      next_arg.u++;\n-\t\t    }\n-\t\t  *next_arg.d = double_tmp;\n-\t\t  next_arg.u += 2;\n-\t\t  double_tmp = (*p_argv.d)[1];\n-\t\t  *next_arg.d = double_tmp;\n-\t\t  next_arg.u += 2;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  *fpr_base.d++ = double_tmp;\n-\t\t  double_tmp = (*p_argv.d)[1];\n-\t\t  *fpr_base.d++ = double_tmp;\n-\t\t}\n-\n-\t      fparg_count += 2;\n-\t      FFI_ASSERT (flags & FLAG_FP_ARGUMENTS);\n-\t  break;\n-#endif\n-#endif /* have FPRs */\n-\n-\t/*\n-\t * The soft float ABI for long doubles works like this, a long double\n-\t * is passed in four consecutive GPRs if available.  A maximum of 2\n-\t * long doubles can be passed in gprs.  If we do not have 4 GPRs\n-\t * left, the long double is passed on the stack, 4-byte aligned.\n-\t */\n-\tcase FFI_TYPE_UINT128: {\n-\t\tunsigned int int_tmp = (*p_argv.ui)[0];\n-\t\tunsigned int ii;\n-\t\tif (intarg_count >= NUM_GPR_ARG_REGISTERS - 3) {\n-\t\t\tif (intarg_count < NUM_GPR_ARG_REGISTERS)\n-\t\t\t\tintarg_count += NUM_GPR_ARG_REGISTERS - intarg_count;\n-\t\t\t*(next_arg.u++) = int_tmp;\n-\t\t\tfor (ii = 1; ii < 4; ii++) {\n-\t\t\t\tint_tmp = (*p_argv.ui)[ii];\n-\t\t\t\t*(next_arg.u++) = int_tmp;\n-\t\t\t}\n-\t\t} else {\n-\t\t\t*(gpr_base.u++) = int_tmp;\n-\t\t\tfor (ii = 1; ii < 4; ii++) {\n-\t\t\t\tint_tmp = (*p_argv.ui)[ii];\n-\t\t\t\t*(gpr_base.u++) = int_tmp;\n-\t\t\t}\n-\t\t}\n-\t\tintarg_count += 4;\n-\t\tbreak;\n-\t}\n-\n-\tcase FFI_TYPE_UINT64:\n-\tcase FFI_TYPE_SINT64:\n-\t  if (intarg_count == NUM_GPR_ARG_REGISTERS-1)\n-\t    intarg_count++;\n-\t  if (intarg_count >= NUM_GPR_ARG_REGISTERS)\n-\t    {\n-\t      if (intarg_count % 2 != 0)\n-\t\t{\n-\t\t  intarg_count++;\n-\t\t  next_arg.u++;\n-\t\t}\n-\t      *next_arg.ll = **p_argv.ll;\n-\t      next_arg.u += 2;\n-\t    }\n-\t  else\n-\t    {\n-\t      /* whoops: abi states only certain register pairs\n-\t       * can be used for passing long long int\n-\t       * specifically (r3,r4), (r5,r6), (r7,r8),\n-\t       * (r9,r10) and if next arg is long long but\n-\t       * not correct starting register of pair then skip\n-\t       * until the proper starting register\n-\t       */\n-\t      if (intarg_count % 2 != 0)\n-\t\t{\n-\t\t  intarg_count ++;\n-\t\t  gpr_base.u++;\n-\t\t}\n-\t      *gpr_base.ll++ = **p_argv.ll;\n-\t    }\n-\t  intarg_count += 2;\n-\t  break;\n-\n-\tcase FFI_TYPE_STRUCT:\n-\t  struct_copy_size = ((*ptr)->size + 15) & ~0xF;\n-\t  copy_space.c -= struct_copy_size;\n-\t  memcpy (copy_space.c, *p_argv.c, (*ptr)->size);\n-\n-\t  gprvalue = (unsigned long) copy_space.c;\n-\n-\t  FFI_ASSERT (copy_space.c > next_arg.c);\n-\t  FFI_ASSERT (flags & FLAG_ARG_NEEDS_COPY);\n-\t  goto putgpr;\n-\n-\tcase FFI_TYPE_UINT8:\n-\t  gprvalue = **p_argv.uc;\n-\t  goto putgpr;\n-\tcase FFI_TYPE_SINT8:\n-\t  gprvalue = **p_argv.sc;\n-\t  goto putgpr;\n-\tcase FFI_TYPE_UINT16:\n-\t  gprvalue = **p_argv.us;\n-\t  goto putgpr;\n-\tcase FFI_TYPE_SINT16:\n-\t  gprvalue = **p_argv.ss;\n-\t  goto putgpr;\n-\n-\tcase FFI_TYPE_INT:\n-\tcase FFI_TYPE_UINT32:\n-\tcase FFI_TYPE_SINT32:\n-\tcase FFI_TYPE_POINTER:\n-\n-\t  gprvalue = **p_argv.ui;\n-\n-\tputgpr:\n-\t  if (intarg_count >= NUM_GPR_ARG_REGISTERS)\n-\t    *next_arg.u++ = gprvalue;\n-\t  else\n-\t    *gpr_base.u++ = gprvalue;\n-\t  intarg_count++;\n-\t  break;\n-\t}\n-    }\n-\n-  /* Check that we didn't overrun the stack...  */\n-  FFI_ASSERT (copy_space.c >= next_arg.c);\n-  FFI_ASSERT (gpr_base.u <= stacktop.u - ASM_NEEDS_REGISTERS);\n-  /* The assert below is testing that the number of integer arguments agrees\n-     with the number found in ffi_prep_cif_machdep().  However, intarg_count\n-     is incremented whenever we place an FP arg on the stack, so account for\n-     that before our assert test.  */\n-#ifndef __NO_FPRS__\n-  if (fparg_count > NUM_FPR_ARG_REGISTERS)\n-    intarg_count -= fparg_count - NUM_FPR_ARG_REGISTERS;\n-  FFI_ASSERT (fpr_base.u\n-\t      <= stacktop.u - ASM_NEEDS_REGISTERS - NUM_GPR_ARG_REGISTERS);\n-#endif\n-  FFI_ASSERT (flags & FLAG_4_GPR_ARGUMENTS || intarg_count <= 4);\n-}\n-\n-/* About the LINUX64 ABI.  */\n-enum {\n-  NUM_GPR_ARG_REGISTERS64 = 8,\n-  NUM_FPR_ARG_REGISTERS64 = 13\n-};\n-enum { ASM_NEEDS_REGISTERS64 = 4 };\n-\n-#if _CALL_ELF == 2\n-static unsigned int\n-discover_homogeneous_aggregate (const ffi_type *t, unsigned int *elnum)\n-{\n-  switch (t->type)\n-    {\n-    case FFI_TYPE_FLOAT:\n-    case FFI_TYPE_DOUBLE:\n-      *elnum = 1;\n-      return (int) t->type;\n-\n-    case FFI_TYPE_STRUCT:;\n-      {\n-\tunsigned int base_elt = 0, total_elnum = 0;\n-\tffi_type **el = t->elements;\n-\twhile (*el)\n-\t  {\n-\t    unsigned int el_elt, el_elnum = 0;\n-\t    el_elt = discover_homogeneous_aggregate (*el, &el_elnum);\n-\t    if (el_elt == 0\n-\t\t|| (base_elt && base_elt != el_elt))\n-\t      return 0;\n-\t    base_elt = el_elt;\n-\t    total_elnum += el_elnum;\n-\t    if (total_elnum > 8)\n-\t      return 0;\n-\t    el++;\n-\t  }\n-\t*elnum = total_elnum;\n-\treturn base_elt;\n-      }\n-\n-    default:\n-      return 0;\n-    }\n-}\n-#endif\n-\n-\n-/* ffi_prep_args64 is called by the assembly routine once stack space\n-   has been allocated for the function's arguments.\n-\n-   The stack layout we want looks like this:\n-\n-   |   Ret addr from ffi_call_LINUX64\t8bytes\t|\thigher addresses\n-   |--------------------------------------------|\n-   |   CR save area\t\t\t8bytes\t|\n-   |--------------------------------------------|\n-   |   Previous backchain pointer\t8\t|\tstack pointer here\n-   |--------------------------------------------|<+ <<<\ton entry to\n-   |   Saved r28-r31\t\t\t4*8\t| |\tffi_call_LINUX64\n-   |--------------------------------------------| |\n-   |   GPR registers r3-r10\t\t8*8\t| |\n-   |--------------------------------------------| |\n-   |   FPR registers f1-f13 (optional)\t13*8\t| |\n-   |--------------------------------------------| |\n-   |   Parameter save area\t\t        | |\n-   |--------------------------------------------| |\n-   |   TOC save area\t\t\t8\t| |\n-   |--------------------------------------------| |\tstack\t|\n-   |   Linker doubleword\t\t8\t| |\tgrows\t|\n-   |--------------------------------------------| |\tdown\tV\n-   |   Compiler doubleword\t\t8\t| |\n-   |--------------------------------------------| |\tlower addresses\n-   |   Space for callee's LR\t\t8\t| |\n-   |--------------------------------------------| |\n-   |   CR save area\t\t\t8\t| |\n-   |--------------------------------------------| |\tstack pointer here\n-   |   Current backchain pointer\t8\t|-/\tduring\n-   |--------------------------------------------|   <<<\tffi_call_LINUX64\n-\n-*/\n+#include \"ffi.h\"\n+#include \"ffi_common.h\"\n+#include \"ffi_powerpc.h\"\n \n+#if HAVE_LONG_DOUBLE_VARIANT\n+/* Adjust ffi_type_longdouble.  */\n void FFI_HIDDEN\n-ffi_prep_args64 (extended_cif *ecif, unsigned long *const stack)\n+ffi_prep_types (ffi_abi abi)\n {\n-  const unsigned long bytes = ecif->cif->bytes;\n-  const unsigned long flags = ecif->cif->flags;\n-\n-  typedef union {\n-    char *c;\n-    unsigned long *ul;\n-    float *f;\n-    double *d;\n-    size_t p;\n-  } valp;\n-\n-  /* 'stacktop' points at the previous backchain pointer.  */\n-  valp stacktop;\n-\n-  /* 'next_arg' points at the space for gpr3, and grows upwards as\n-     we use GPR registers, then continues at rest.  */\n-  valp gpr_base;\n-  valp gpr_end;\n-  valp rest;\n-  valp next_arg;\n-\n-  /* 'fpr_base' points at the space for fpr3, and grows upwards as\n-     we use FPR registers.  */\n-  valp fpr_base;\n-  unsigned int fparg_count;\n-\n-  unsigned int i, words, nargs, nfixedargs;\n-  ffi_type **ptr;\n-  double double_tmp;\n-  union {\n-    void **v;\n-    char **c;\n-    signed char **sc;\n-    unsigned char **uc;\n-    signed short **ss;\n-    unsigned short **us;\n-    signed int **si;\n-    unsigned int **ui;\n-    unsigned long **ul;\n-    float **f;\n-    double **d;\n-  } p_argv;\n-  unsigned long gprvalue;\n-#ifdef __STRUCT_PARM_ALIGN__\n-  unsigned long align;\n-#endif\n-\n-  stacktop.c = (char *) stack + bytes;\n-  gpr_base.ul = stacktop.ul - ASM_NEEDS_REGISTERS64 - NUM_GPR_ARG_REGISTERS64;\n-  gpr_end.ul = gpr_base.ul + NUM_GPR_ARG_REGISTERS64;\n-#if _CALL_ELF == 2\n-  rest.ul = stack + 4 + NUM_GPR_ARG_REGISTERS64;\n-#else\n-  rest.ul = stack + 6 + NUM_GPR_ARG_REGISTERS64;\n-#endif\n-  fpr_base.d = gpr_base.d - NUM_FPR_ARG_REGISTERS64;\n-  fparg_count = 0;\n-  next_arg.ul = gpr_base.ul;\n-\n-  /* Check that everything starts aligned properly.  */\n-  FFI_ASSERT (((unsigned long) (char *) stack & 0xF) == 0);\n-  FFI_ASSERT (((unsigned long) stacktop.c & 0xF) == 0);\n-  FFI_ASSERT ((bytes & 0xF) == 0);\n-\n-  /* Deal with return values that are actually pass-by-reference.  */\n-  if (flags & FLAG_RETVAL_REFERENCE)\n-    *next_arg.ul++ = (unsigned long) (char *) ecif->rvalue;\n-\n-  /* Now for the arguments.  */\n-  p_argv.v = ecif->avalue;\n-  nargs = ecif->cif->nargs;\n-  nfixedargs = ecif->cif->nfixedargs;\n-  for (ptr = ecif->cif->arg_types, i = 0;\n-       i < nargs;\n-       i++, ptr++, p_argv.v++)\n-    {\n-      unsigned int elt, elnum;\n-\n-      switch ((*ptr)->type)\n-\t{\n-\tcase FFI_TYPE_FLOAT:\n-\t  double_tmp = **p_argv.f;\n-\t  if (fparg_count < NUM_FPR_ARG_REGISTERS64 && i < nfixedargs)\n-\t    *fpr_base.d++ = double_tmp;\n-\t  else\n-\t    *next_arg.f = (float) double_tmp;\n-\t  if (++next_arg.ul == gpr_end.ul)\n-\t    next_arg.ul = rest.ul;\n-\t  fparg_count++;\n-\t  FFI_ASSERT (flags & FLAG_FP_ARGUMENTS);\n-\t  break;\n-\n-\tcase FFI_TYPE_DOUBLE:\n-\t  double_tmp = **p_argv.d;\n-\t  if (fparg_count < NUM_FPR_ARG_REGISTERS64 && i < nfixedargs)\n-\t    *fpr_base.d++ = double_tmp;\n-\t  else\n-\t    *next_arg.d = double_tmp;\n-\t  if (++next_arg.ul == gpr_end.ul)\n-\t    next_arg.ul = rest.ul;\n-\t  fparg_count++;\n-\t  FFI_ASSERT (flags & FLAG_FP_ARGUMENTS);\n-\t  break;\n-\n-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n-\tcase FFI_TYPE_LONGDOUBLE:\n-\t  double_tmp = (*p_argv.d)[0];\n-\t  if (fparg_count < NUM_FPR_ARG_REGISTERS64 && i < nfixedargs)\n-\t    *fpr_base.d++ = double_tmp;\n-\t  else\n-\t    *next_arg.d = double_tmp;\n-\t  if (++next_arg.ul == gpr_end.ul)\n-\t    next_arg.ul = rest.ul;\n-\t  fparg_count++;\n-\t  double_tmp = (*p_argv.d)[1];\n-\t  if (fparg_count < NUM_FPR_ARG_REGISTERS64 && i < nfixedargs)\n-\t    *fpr_base.d++ = double_tmp;\n-\t  else\n-\t    *next_arg.d = double_tmp;\n-\t  if (++next_arg.ul == gpr_end.ul)\n-\t    next_arg.ul = rest.ul;\n-\t  fparg_count++;\n-\t  FFI_ASSERT (__LDBL_MANT_DIG__ == 106);\n-\t  FFI_ASSERT (flags & FLAG_FP_ARGUMENTS);\n-\t  break;\n-#endif\n-\n-\tcase FFI_TYPE_STRUCT:\n-#ifdef __STRUCT_PARM_ALIGN__\n-\t  align = (*ptr)->alignment;\n-\t  if (align > __STRUCT_PARM_ALIGN__)\n-\t    align = __STRUCT_PARM_ALIGN__;\n-\t  if (align > 1)\n-\t    next_arg.p = ALIGN (next_arg.p, align);\n-#endif\n-\t  elt = 0;\n-#if _CALL_ELF == 2\n-\t  elt = discover_homogeneous_aggregate (*ptr, &elnum);\n-#endif\n-\t  if (elt)\n-\t    {\n-\t      union {\n-\t\tvoid *v;\n-\t\tfloat *f;\n-\t\tdouble *d;\n-\t      } arg;\n-\n-\t      arg.v = *p_argv.v;\n-\t      if (elt == FFI_TYPE_FLOAT)\n-\t\t{\n-\t\t  do\n-\t\t    {\n-\t\t      double_tmp = *arg.f++;\n-\t\t      if (fparg_count < NUM_FPR_ARG_REGISTERS64\n-\t\t\t  && i < nfixedargs)\n-\t\t\t*fpr_base.d++ = double_tmp;\n-\t\t      else\n-\t\t\t*next_arg.f = (float) double_tmp;\n-\t\t      if (++next_arg.f == gpr_end.f)\n-\t\t\tnext_arg.f = rest.f;\n-\t\t      fparg_count++;\n-\t\t    }\n-\t\t  while (--elnum != 0);\n-\t\t  if ((next_arg.p & 3) != 0)\n-\t\t    {\n-\t\t      if (++next_arg.f == gpr_end.f)\n-\t\t\tnext_arg.f = rest.f;\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\tdo\n-\t\t  {\n-\t\t    double_tmp = *arg.d++;\n-\t\t    if (fparg_count < NUM_FPR_ARG_REGISTERS64 && i < nfixedargs)\n-\t\t      *fpr_base.d++ = double_tmp;\n-\t\t    else\n-\t\t      *next_arg.d = double_tmp;\n-\t\t    if (++next_arg.d == gpr_end.d)\n-\t\t      next_arg.d = rest.d;\n-\t\t    fparg_count++;\n-\t\t  }\n-\t\twhile (--elnum != 0);\n-\t    }\n-\t  else\n-\t    {\n-\t      words = ((*ptr)->size + 7) / 8;\n-\t      if (next_arg.ul >= gpr_base.ul && next_arg.ul + words > gpr_end.ul)\n-\t\t{\n-\t\t  size_t first = gpr_end.c - next_arg.c;\n-\t\t  memcpy (next_arg.c, *p_argv.c, first);\n-\t\t  memcpy (rest.c, *p_argv.c + first, (*ptr)->size - first);\n-\t\t  next_arg.c = rest.c + words * 8 - first;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  char *where = next_arg.c;\n-\n-#ifndef __LITTLE_ENDIAN__\n-\t\t  /* Structures with size less than eight bytes are passed\n-\t\t     left-padded.  */\n-\t\t  if ((*ptr)->size < 8)\n-\t\t    where += 8 - (*ptr)->size;\n-#endif\n-\t\t  memcpy (where, *p_argv.c, (*ptr)->size);\n-\t\t  next_arg.ul += words;\n-\t\t  if (next_arg.ul == gpr_end.ul)\n-\t\t    next_arg.ul = rest.ul;\n-\t\t}\n-\t    }\n-\t  break;\n-\n-\tcase FFI_TYPE_UINT8:\n-\t  gprvalue = **p_argv.uc;\n-\t  goto putgpr;\n-\tcase FFI_TYPE_SINT8:\n-\t  gprvalue = **p_argv.sc;\n-\t  goto putgpr;\n-\tcase FFI_TYPE_UINT16:\n-\t  gprvalue = **p_argv.us;\n-\t  goto putgpr;\n-\tcase FFI_TYPE_SINT16:\n-\t  gprvalue = **p_argv.ss;\n-\t  goto putgpr;\n-\tcase FFI_TYPE_UINT32:\n-\t  gprvalue = **p_argv.ui;\n-\t  goto putgpr;\n-\tcase FFI_TYPE_INT:\n-\tcase FFI_TYPE_SINT32:\n-\t  gprvalue = **p_argv.si;\n-\t  goto putgpr;\n-\n-\tcase FFI_TYPE_UINT64:\n-\tcase FFI_TYPE_SINT64:\n-\tcase FFI_TYPE_POINTER:\n-\t  gprvalue = **p_argv.ul;\n-\tputgpr:\n-\t  *next_arg.ul++ = gprvalue;\n-\t  if (next_arg.ul == gpr_end.ul)\n-\t    next_arg.ul = rest.ul;\n-\t  break;\n-\t}\n-    }\n-\n-  FFI_ASSERT (flags & FLAG_4_GPR_ARGUMENTS\n-\t      || (next_arg.ul >= gpr_base.ul\n-\t\t  && next_arg.ul <= gpr_base.ul + 4));\n+# if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+#  ifdef POWERPC64\n+  ffi_prep_types_linux64 (abi);\n+#  else\n+  ffi_prep_types_sysv (abi);\n+#  endif\n+# endif\n }\n-\n-\n+#endif\n \n /* Perform machine dependent cif processing */\n-static ffi_status\n-ffi_prep_cif_machdep_core (ffi_cif *cif)\n+ffi_status FFI_HIDDEN\n+ffi_prep_cif_machdep (ffi_cif *cif)\n {\n-  /* All this is for the SYSV and LINUX64 ABI.  */\n-  ffi_type **ptr;\n-  unsigned bytes;\n-  unsigned i, fparg_count = 0, intarg_count = 0;\n-  unsigned flags = cif->flags;\n-  unsigned struct_copy_size = 0;\n-  unsigned type = cif->rtype->type;\n-  unsigned size = cif->rtype->size;\n-\n-  /* The machine-independent calculation of cif->bytes doesn't work\n-     for us.  Redo the calculation.  */\n-  if (cif->abi != FFI_LINUX64)\n-    {\n-      /* Space for the frame pointer, callee's LR, and the asm's temp regs.  */\n-      bytes = (2 + ASM_NEEDS_REGISTERS) * sizeof (int);\n-\n-      /* Space for the GPR registers.  */\n-      bytes += NUM_GPR_ARG_REGISTERS * sizeof (int);\n-    }\n-  else\n-    {\n-      /* 64-bit ABI.  */\n-#if _CALL_ELF == 2\n-      /* Space for backchain, CR, LR, TOC and the asm's temp regs.  */\n-      bytes = (4 + ASM_NEEDS_REGISTERS64) * sizeof (long);\n-\n-      /* Space for the general registers.  */\n-      bytes += NUM_GPR_ARG_REGISTERS64 * sizeof (long);\n-#else\n-      /* Space for backchain, CR, LR, cc/ld doubleword, TOC and the asm's temp\n-\t regs.  */\n-      bytes = (6 + ASM_NEEDS_REGISTERS64) * sizeof (long);\n-\n-      /* Space for the mandatory parm save area and general registers.  */\n-      bytes += 2 * NUM_GPR_ARG_REGISTERS64 * sizeof (long);\n-#endif\n-    }\n-\n-  /* Return value handling.  The rules for SYSV are as follows:\n-     - 32-bit (or less) integer values are returned in gpr3;\n-     - Structures of size <= 4 bytes also returned in gpr3;\n-     - 64-bit integer values and structures between 5 and 8 bytes are returned\n-     in gpr3 and gpr4;\n-     - Single/double FP values are returned in fpr1;\n-     - Larger structures are allocated space and a pointer is passed as\n-     the first argument.\n-     - long doubles (if not equivalent to double) are returned in\n-     fpr1,fpr2 for Linux and as for large structs for SysV.\n-     For LINUX64:\n-     - integer values in gpr3;\n-     - Structures/Unions by reference;\n-     - Single/double FP values in fpr1, long double in fpr1,fpr2.\n-     - soft-float float/doubles are treated as UINT32/UINT64 respectivley.\n-     - soft-float long doubles are returned in gpr3-gpr6.  */\n-  /* First translate for softfloat/nonlinux */\n-  if (cif->abi == FFI_LINUX_SOFT_FLOAT)\n-    {\n-      if (type == FFI_TYPE_FLOAT)\n-\ttype = FFI_TYPE_UINT32;\n-      if (type == FFI_TYPE_DOUBLE)\n-\ttype = FFI_TYPE_UINT64;\n-      if (type == FFI_TYPE_LONGDOUBLE)\n-\ttype = FFI_TYPE_UINT128;\n-    }\n-  else if (cif->abi != FFI_LINUX\n-\t   && cif->abi != FFI_LINUX64)\n-    {\n-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n-      if (type == FFI_TYPE_LONGDOUBLE)\n-\ttype = FFI_TYPE_STRUCT;\n-#endif\n-    }\n-\n-  switch (type)\n-    {\n-#ifndef __NO_FPRS__\n-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n-    case FFI_TYPE_LONGDOUBLE:\n-      flags |= FLAG_RETURNS_128BITS;\n-      /* Fall through.  */\n-#endif\n-    case FFI_TYPE_DOUBLE:\n-      flags |= FLAG_RETURNS_64BITS;\n-      /* Fall through.  */\n-    case FFI_TYPE_FLOAT:\n-      flags |= FLAG_RETURNS_FP;\n-      break;\n-#endif\n-\n-    case FFI_TYPE_UINT128:\n-      flags |= FLAG_RETURNS_128BITS;\n-      /* Fall through.  */\n-    case FFI_TYPE_UINT64:\n-    case FFI_TYPE_SINT64:\n-      flags |= FLAG_RETURNS_64BITS;\n-      break;\n-\n-    case FFI_TYPE_STRUCT:\n-      /*\n-       * The final SYSV ABI says that structures smaller or equal 8 bytes\n-       * are returned in r3/r4.  The FFI_GCC_SYSV ABI instead returns them\n-       * in memory.\n-       *\n-       * NOTE: The assembly code can safely assume that it just needs to\n-       *       store both r3 and r4 into a 8-byte word-aligned buffer, as\n-       *       we allocate a temporary buffer in ffi_call() if this flag is\n-       *       set.\n-       */\n-      if (cif->abi == FFI_SYSV && size <= 8)\n-\t{\n-\t  flags |= FLAG_RETURNS_SMST;\n-\t  break;\n-\t}\n-#if _CALL_ELF == 2\n-      if (cif->abi == FFI_LINUX64)\n-\t{\n-\t  unsigned int elt, elnum;\n-\t  elt = discover_homogeneous_aggregate (cif->rtype, &elnum);\n-\t  if (elt)\n-\t    {\n-\t      if (elt == FFI_TYPE_DOUBLE)\n-\t\tflags |= FLAG_RETURNS_64BITS;\n-\t      flags |= FLAG_RETURNS_FP | FLAG_RETURNS_SMST;\n-\t      break;\n-\t    }\n-\t  if (size <= 16)\n-\t    {\n-\t      flags |= FLAG_RETURNS_SMST;\n-\t      break;\n-\t    }\n-\t}\n-#endif\n-      intarg_count++;\n-      flags |= FLAG_RETVAL_REFERENCE;\n-      /* Fall through.  */\n-    case FFI_TYPE_VOID:\n-      flags |= FLAG_RETURNS_NOTHING;\n-      break;\n-\n-    default:\n-      /* Returns 32-bit integer, or similar.  Nothing to do here.  */\n-      break;\n-    }\n-\n-  if (cif->abi != FFI_LINUX64)\n-    /* The first NUM_GPR_ARG_REGISTERS words of integer arguments, and the\n-       first NUM_FPR_ARG_REGISTERS fp arguments, go in registers; the rest\n-       goes on the stack.  Structures and long doubles (if not equivalent\n-       to double) are passed as a pointer to a copy of the structure.\n-       Stuff on the stack needs to keep proper alignment.  */\n-    for (ptr = cif->arg_types, i = cif->nargs; i > 0; i--, ptr++)\n-      {\n-\tunsigned short typenum = (*ptr)->type;\n-\n-\t/* We may need to handle some values depending on ABI */\n-\tif (cif->abi == FFI_LINUX_SOFT_FLOAT) {\n-\t\tif (typenum == FFI_TYPE_FLOAT)\n-\t\t\ttypenum = FFI_TYPE_UINT32;\n-\t\tif (typenum == FFI_TYPE_DOUBLE)\n-\t\t\ttypenum = FFI_TYPE_UINT64;\n-\t\tif (typenum == FFI_TYPE_LONGDOUBLE)\n-\t\t\ttypenum = FFI_TYPE_UINT128;\n-\t} else if (cif->abi != FFI_LINUX && cif->abi != FFI_LINUX64) {\n-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n-\t\tif (typenum == FFI_TYPE_LONGDOUBLE)\n-\t\t\ttypenum = FFI_TYPE_STRUCT;\n-#endif\n-\t}\n-\n-\tswitch (typenum) {\n-#ifndef __NO_FPRS__\n-\t  case FFI_TYPE_FLOAT:\n-\t    fparg_count++;\n-\t    /* floating singles are not 8-aligned on stack */\n-\t    break;\n-\n-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n-\t  case FFI_TYPE_LONGDOUBLE:\n-\t    fparg_count++;\n-\t    /* Fall thru */\n-#endif\n-\t  case FFI_TYPE_DOUBLE:\n-\t    fparg_count++;\n-\t    /* If this FP arg is going on the stack, it must be\n-\t       8-byte-aligned.  */\n-\t    if (fparg_count > NUM_FPR_ARG_REGISTERS\n-\t\t&& intarg_count >= NUM_GPR_ARG_REGISTERS\n-\t\t&& intarg_count % 2 != 0)\n-\t      intarg_count++;\n-\t    break;\n-#endif\n-\t  case FFI_TYPE_UINT128:\n-\t\t/*\n-\t\t * A long double in FFI_LINUX_SOFT_FLOAT can use only a set\n-\t\t * of four consecutive gprs. If we do not have enough, we\n-\t\t * have to adjust the intarg_count value.\n-\t\t */\n-\t\tif (intarg_count >= NUM_GPR_ARG_REGISTERS - 3\n-\t\t\t\t&& intarg_count < NUM_GPR_ARG_REGISTERS)\n-\t\t\tintarg_count = NUM_GPR_ARG_REGISTERS;\n-\t\tintarg_count += 4;\n-\t\tbreak;\n-\n-\t  case FFI_TYPE_UINT64:\n-\t  case FFI_TYPE_SINT64:\n-\t    /* 'long long' arguments are passed as two words, but\n-\t       either both words must fit in registers or both go\n-\t       on the stack.  If they go on the stack, they must\n-\t       be 8-byte-aligned.\n-\n-\t       Also, only certain register pairs can be used for\n-\t       passing long long int -- specifically (r3,r4), (r5,r6),\n-\t       (r7,r8), (r9,r10).\n-\t    */\n-\t    if (intarg_count == NUM_GPR_ARG_REGISTERS-1\n-\t\t|| intarg_count % 2 != 0)\n-\t      intarg_count++;\n-\t    intarg_count += 2;\n-\t    break;\n-\n-\t  case FFI_TYPE_STRUCT:\n-\t    /* We must allocate space for a copy of these to enforce\n-\t       pass-by-value.  Pad the space up to a multiple of 16\n-\t       bytes (the maximum alignment required for anything under\n-\t       the SYSV ABI).  */\n-\t    struct_copy_size += ((*ptr)->size + 15) & ~0xF;\n-\t    /* Fall through (allocate space for the pointer).  */\n-\n-\t  case FFI_TYPE_POINTER:\n-\t  case FFI_TYPE_INT:\n-\t  case FFI_TYPE_UINT32:\n-\t  case FFI_TYPE_SINT32:\n-\t  case FFI_TYPE_UINT16:\n-\t  case FFI_TYPE_SINT16:\n-\t  case FFI_TYPE_UINT8:\n-\t  case FFI_TYPE_SINT8:\n-\t    /* Everything else is passed as a 4-byte word in a GPR, either\n-\t       the object itself or a pointer to it.  */\n-\t    intarg_count++;\n-\t    break;\n-\t  default:\n-\t\tFFI_ASSERT (0);\n-\t  }\n-      }\n-  else\n-    for (ptr = cif->arg_types, i = cif->nargs; i > 0; i--, ptr++)\n-      {\n-\tunsigned int elt, elnum;\n-#ifdef __STRUCT_PARM_ALIGN__\n-\tunsigned int align;\n-#endif\n-\n-\tswitch ((*ptr)->type)\n-\t  {\n-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n-\t  case FFI_TYPE_LONGDOUBLE:\n-\t    fparg_count += 2;\n-\t    intarg_count += 2;\n-\t    if (fparg_count > NUM_FPR_ARG_REGISTERS)\n-\t      flags |= FLAG_ARG_NEEDS_PSAVE;\n-\t    break;\n-#endif\n-\t  case FFI_TYPE_FLOAT:\n-\t  case FFI_TYPE_DOUBLE:\n-\t    fparg_count++;\n-\t    intarg_count++;\n-\t    if (fparg_count > NUM_FPR_ARG_REGISTERS)\n-\t      flags |= FLAG_ARG_NEEDS_PSAVE;\n-\t    break;\n-\n-\t  case FFI_TYPE_STRUCT:\n-#ifdef __STRUCT_PARM_ALIGN__\n-\t    align = (*ptr)->alignment;\n-\t    if (align > __STRUCT_PARM_ALIGN__)\n-\t      align = __STRUCT_PARM_ALIGN__;\n-\t    align = align / 8;\n-\t    if (align > 1)\n-\t      intarg_count = ALIGN (intarg_count, align);\n-#endif\n-\t    intarg_count += ((*ptr)->size + 7) / 8;\n-\t    elt = 0;\n-#if _CALL_ELF == 2\n-\t    elt = discover_homogeneous_aggregate (*ptr, &elnum);\n-#endif\n-\t    if (elt)\n-\t      {\n-\t\tfparg_count += elnum;\n-\t\tif (fparg_count > NUM_FPR_ARG_REGISTERS)\n-\t\t  flags |= FLAG_ARG_NEEDS_PSAVE;\n-\t      }\n-\t    else\n-\t      {\n-\t\tif (intarg_count > NUM_GPR_ARG_REGISTERS)\n-\t\t  flags |= FLAG_ARG_NEEDS_PSAVE;\n-\t      }\n-\t    break;\n-\n-\t  case FFI_TYPE_POINTER:\n-\t  case FFI_TYPE_UINT64:\n-\t  case FFI_TYPE_SINT64:\n-\t  case FFI_TYPE_INT:\n-\t  case FFI_TYPE_UINT32:\n-\t  case FFI_TYPE_SINT32:\n-\t  case FFI_TYPE_UINT16:\n-\t  case FFI_TYPE_SINT16:\n-\t  case FFI_TYPE_UINT8:\n-\t  case FFI_TYPE_SINT8:\n-\t    /* Everything else is passed as a 8-byte word in a GPR, either\n-\t       the object itself or a pointer to it.  */\n-\t    intarg_count++;\n-\t    if (intarg_count > NUM_GPR_ARG_REGISTERS)\n-\t      flags |= FLAG_ARG_NEEDS_PSAVE;\n-\t    break;\n-\t  default:\n-\t    FFI_ASSERT (0);\n-\t  }\n-      }\n-\n-#ifndef __NO_FPRS__\n-  if (fparg_count != 0)\n-    flags |= FLAG_FP_ARGUMENTS;\n-#endif\n-  if (intarg_count > 4)\n-    flags |= FLAG_4_GPR_ARGUMENTS;\n-  if (struct_copy_size != 0)\n-    flags |= FLAG_ARG_NEEDS_COPY;\n-\n-  if (cif->abi != FFI_LINUX64)\n-    {\n-#ifndef __NO_FPRS__\n-      /* Space for the FPR registers, if needed.  */\n-      if (fparg_count != 0)\n-\tbytes += NUM_FPR_ARG_REGISTERS * sizeof (double);\n-#endif\n-\n-      /* Stack space.  */\n-      if (intarg_count > NUM_GPR_ARG_REGISTERS)\n-\tbytes += (intarg_count - NUM_GPR_ARG_REGISTERS) * sizeof (int);\n-#ifndef __NO_FPRS__\n-      if (fparg_count > NUM_FPR_ARG_REGISTERS)\n-\tbytes += (fparg_count - NUM_FPR_ARG_REGISTERS) * sizeof (double);\n-#endif\n-    }\n-  else\n-    {\n-#ifndef __NO_FPRS__\n-      /* Space for the FPR registers, if needed.  */\n-      if (fparg_count != 0)\n-\tbytes += NUM_FPR_ARG_REGISTERS64 * sizeof (double);\n-#endif\n-\n-      /* Stack space.  */\n-#if _CALL_ELF == 2\n-      if ((flags & FLAG_ARG_NEEDS_PSAVE) != 0)\n-\tbytes += intarg_count * sizeof (long);\n+#ifdef POWERPC64\n+  return ffi_prep_cif_linux64 (cif);\n #else\n-      if (intarg_count > NUM_GPR_ARG_REGISTERS64)\n-\tbytes += (intarg_count - NUM_GPR_ARG_REGISTERS64) * sizeof (long);\n+  return ffi_prep_cif_sysv (cif);\n #endif\n-    }\n-\n-  /* The stack space allocated needs to be a multiple of 16 bytes.  */\n-  bytes = (bytes + 15) & ~0xF;\n-\n-  /* Add in the space for the copied structures.  */\n-  bytes += struct_copy_size;\n-\n-  cif->flags = flags;\n-  cif->bytes = bytes;\n-\n-  return FFI_OK;\n-}\n-\n-ffi_status\n-ffi_prep_cif_machdep (ffi_cif *cif)\n-{\n-  cif->nfixedargs = cif->nargs;\n-  return ffi_prep_cif_machdep_core (cif);\n }\n \n-ffi_status\n+ffi_status FFI_HIDDEN\n ffi_prep_cif_machdep_var (ffi_cif *cif,\n-\t\t\t  unsigned int nfixedargs,\n+\t\t\t  unsigned int nfixedargs MAYBE_UNUSED,\n \t\t\t  unsigned int ntotalargs MAYBE_UNUSED)\n {\n-  cif->nfixedargs = nfixedargs;\n-#if _CALL_ELF == 2\n-  if (cif->abi == FFI_LINUX64)\n-    cif->flags |= FLAG_ARG_NEEDS_PSAVE;\n+#ifdef POWERPC64\n+  return ffi_prep_cif_linux64_var (cif, nfixedargs, ntotalargs);\n+#else\n+  return ffi_prep_cif_sysv (cif);\n #endif\n-  return ffi_prep_cif_machdep_core (cif);\n }\n \n-extern void ffi_call_SYSV(extended_cif *, unsigned, unsigned, unsigned *,\n-\t\t\t  void (*fn)(void));\n-extern void FFI_HIDDEN ffi_call_LINUX64(extended_cif *, unsigned long,\n-\t\t\t\t\tunsigned long, unsigned long *,\n-\t\t\t\t\tvoid (*fn)(void));\n-\n void\n ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n {\n-  /*\n-   * The final SYSV ABI says that structures smaller or equal 8 bytes\n-   * are returned in r3/r4.  The FFI_GCC_SYSV ABI instead returns them\n-   * in memory.\n-   *\n-   * We bounce-buffer SYSV small struct return values so that sysv.S\n-   * can write r3 and r4 to memory without worrying about struct size.\n-   *\n-   * For ELFv2 ABI, use a bounce buffer for homogeneous structs too,\n-   * for similar reasons.\n-   */\n+  /* The final SYSV ABI says that structures smaller or equal 8 bytes\n+     are returned in r3/r4.  A draft ABI used by linux instead returns\n+     them in memory.\n+\n+     We bounce-buffer SYSV small struct return values so that sysv.S\n+     can write r3 and r4 to memory without worrying about struct size.\n+   \n+     For ELFv2 ABI, use a bounce buffer for homogeneous structs too,\n+     for similar reasons.  */\n   unsigned long smst_buffer[8];\n   extended_cif ecif;\n \n@@ -1147,26 +96,11 @@ ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n   else if (!rvalue && cif->rtype->type == FFI_TYPE_STRUCT)\n     ecif.rvalue = alloca (cif->rtype->size);\n \n-  switch (cif->abi)\n-    {\n-#ifndef POWERPC64\n-# ifndef __NO_FPRS__\n-    case FFI_SYSV:\n-    case FFI_GCC_SYSV:\n-    case FFI_LINUX:\n-# endif\n-    case FFI_LINUX_SOFT_FLOAT:\n-      ffi_call_SYSV (&ecif, -cif->bytes, cif->flags, ecif.rvalue, fn);\n-      break;\n+#ifdef POWERPC64\n+  ffi_call_LINUX64 (&ecif, -(long) cif->bytes, cif->flags, ecif.rvalue, fn);\n #else\n-    case FFI_LINUX64:\n-      ffi_call_LINUX64 (&ecif, -(long) cif->bytes, cif->flags, ecif.rvalue, fn);\n-      break;\n+  ffi_call_SYSV (&ecif, -cif->bytes, cif->flags, ecif.rvalue, fn);\n #endif\n-    default:\n-      FFI_ASSERT (0);\n-      break;\n-    }\n \n   /* Check for a bounce-buffered return value */\n   if (rvalue && ecif.rvalue == smst_buffer)\n@@ -1175,36 +109,23 @@ ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n #ifndef __LITTLE_ENDIAN__\n       /* The SYSV ABI returns a structure of up to 4 bytes in size\n \t left-padded in r3.  */\n-      if (cif->abi == FFI_SYSV && rsize <= 4)\n+# ifndef POWERPC64\n+      if (rsize <= 4)\n \tmemcpy (rvalue, (char *) smst_buffer + 4 - rsize, rsize);\n-      /* The SYSV ABI returns a structure of up to 8 bytes in size\n-\t left-padded in r3/r4, and the ELFv2 ABI similarly returns a\n-\t structure of up to 8 bytes in size left-padded in r3.  */\n-      else if (rsize <= 8)\n-\tmemcpy (rvalue, (char *) smst_buffer + 8 - rsize, rsize);\n       else\n+# endif\n+\t/* The SYSV ABI returns a structure of up to 8 bytes in size\n+\t   left-padded in r3/r4, and the ELFv2 ABI similarly returns a\n+\t   structure of up to 8 bytes in size left-padded in r3.  */\n+\tif (rsize <= 8)\n+\t  memcpy (rvalue, (char *) smst_buffer + 8 - rsize, rsize);\n+\telse\n #endif\n-\tmemcpy (rvalue, smst_buffer, rsize);\n+\t  memcpy (rvalue, smst_buffer, rsize);\n     }\n }\n \n \n-#if !defined POWERPC64 || _CALL_ELF == 2\n-#define MIN_CACHE_LINE_SIZE 8\n-\n-static void\n-flush_icache (char *wraddr, char *xaddr, int size)\n-{\n-  int i;\n-  for (i = 0; i < size; i += MIN_CACHE_LINE_SIZE)\n-    __asm__ volatile (\"icbi 0,%0;\" \"dcbf 0,%1;\"\n-\t\t      : : \"r\" (xaddr + i), \"r\" (wraddr + i) : \"memory\");\n-  __asm__ volatile (\"icbi 0,%0;\" \"dcbf 0,%1;\" \"sync;\" \"isync;\"\n-\t\t    : : \"r\"(xaddr + size - 1), \"r\"(wraddr + size - 1)\n-\t\t    : \"memory\");\n-}\n-#endif\n-\n ffi_status\n ffi_prep_closure_loc (ffi_closure *closure,\n \t\t      ffi_cif *cif,\n@@ -1213,593 +134,8 @@ ffi_prep_closure_loc (ffi_closure *closure,\n \t\t      void *codeloc)\n {\n #ifdef POWERPC64\n-# if _CALL_ELF == 2\n-  unsigned int *tramp = (unsigned int *) &closure->tramp[0];\n-\n-  if (cif->abi != FFI_LINUX64)\n-    return FFI_BAD_ABI;\n-\n-  tramp[0] = 0xe96c0018;\t/* 0:\tld\t11,2f-0b(12)\t*/\n-  tramp[1] = 0xe98c0010;\t/*\tld\t12,1f-0b(12)\t*/\n-  tramp[2] = 0x7d8903a6;\t/*\tmtctr\t12\t\t*/\n-  tramp[3] = 0x4e800420;\t/*\tbctr\t\t\t*/\n-\t\t\t\t/* 1:\t.quad\tfunction_addr\t*/\n-\t\t\t\t/* 2:\t.quad\tcontext\t\t*/\n-  *(void **) &tramp[4] = (void *) ffi_closure_LINUX64;\n-  *(void **) &tramp[6] = codeloc;\n-  flush_icache ((char *)tramp, (char *)codeloc, FFI_TRAMPOLINE_SIZE);\n-# else\n-  void **tramp = (void **) &closure->tramp[0];\n-\n-  if (cif->abi != FFI_LINUX64)\n-    return FFI_BAD_ABI;\n-  /* Copy function address and TOC from ffi_closure_LINUX64.  */\n-  memcpy (tramp, (char *) ffi_closure_LINUX64, 16);\n-  tramp[2] = codeloc;\n-# endif\n+  return ffi_prep_closure_loc_linux64 (closure, cif, fun, user_data, codeloc);\n #else\n-  unsigned int *tramp;\n-\n-  if (! (cif->abi == FFI_GCC_SYSV \n-\t || cif->abi == FFI_SYSV\n-\t || cif->abi == FFI_LINUX\n-\t || cif->abi == FFI_LINUX_SOFT_FLOAT))\n-    return FFI_BAD_ABI;\n-\n-  tramp = (unsigned int *) &closure->tramp[0];\n-  tramp[0] = 0x7c0802a6;  /*   mflr    r0 */\n-  tramp[1] = 0x4800000d;  /*   bl      10 <trampoline_initial+0x10> */\n-  tramp[4] = 0x7d6802a6;  /*   mflr    r11 */\n-  tramp[5] = 0x7c0803a6;  /*   mtlr    r0 */\n-  tramp[6] = 0x800b0000;  /*   lwz     r0,0(r11) */\n-  tramp[7] = 0x816b0004;  /*   lwz     r11,4(r11) */\n-  tramp[8] = 0x7c0903a6;  /*   mtctr   r0 */\n-  tramp[9] = 0x4e800420;  /*   bctr */\n-  *(void **) &tramp[2] = (void *) ffi_closure_SYSV; /* function */\n-  *(void **) &tramp[3] = codeloc;                   /* context */\n-\n-  /* Flush the icache.  */\n-  flush_icache ((char *)tramp, (char *)codeloc, FFI_TRAMPOLINE_SIZE);\n-#endif\n-\n-  closure->cif = cif;\n-  closure->fun = fun;\n-  closure->user_data = user_data;\n-\n-  return FFI_OK;\n-}\n-\n-typedef union\n-{\n-  float f;\n-  double d;\n-} ffi_dblfl;\n-\n-int ffi_closure_helper_SYSV (ffi_closure *, void *, unsigned long *,\n-\t\t\t     ffi_dblfl *, unsigned long *);\n-\n-/* Basically the trampoline invokes ffi_closure_SYSV, and on\n- * entry, r11 holds the address of the closure.\n- * After storing the registers that could possibly contain\n- * parameters to be passed into the stack frame and setting\n- * up space for a return value, ffi_closure_SYSV invokes the\n- * following helper function to do most of the work\n- */\n-\n-int\n-ffi_closure_helper_SYSV (ffi_closure *closure, void *rvalue,\n-\t\t\t unsigned long *pgr, ffi_dblfl *pfr,\n-\t\t\t unsigned long *pst)\n-{\n-  /* rvalue is the pointer to space for return value in closure assembly */\n-  /* pgr is the pointer to where r3-r10 are stored in ffi_closure_SYSV */\n-  /* pfr is the pointer to where f1-f8 are stored in ffi_closure_SYSV  */\n-  /* pst is the pointer to outgoing parameter stack in original caller */\n-\n-  void **          avalue;\n-  ffi_type **      arg_types;\n-  long             i, avn;\n-#ifndef __NO_FPRS__\n-  long             nf = 0;   /* number of floating registers already used */\n-#endif\n-  long             ng = 0;   /* number of general registers already used */\n-\n-  ffi_cif *cif = closure->cif;\n-  unsigned       size     = cif->rtype->size;\n-  unsigned short rtypenum = cif->rtype->type;\n-\n-  avalue = alloca (cif->nargs * sizeof (void *));\n-\n-  /* First translate for softfloat/nonlinux */\n-  if (cif->abi == FFI_LINUX_SOFT_FLOAT) {\n-\tif (rtypenum == FFI_TYPE_FLOAT)\n-\t\trtypenum = FFI_TYPE_UINT32;\n-\tif (rtypenum == FFI_TYPE_DOUBLE)\n-\t\trtypenum = FFI_TYPE_UINT64;\n-\tif (rtypenum == FFI_TYPE_LONGDOUBLE)\n-\t\trtypenum = FFI_TYPE_UINT128;\n-  } else if (cif->abi != FFI_LINUX && cif->abi != FFI_LINUX64) {\n-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n-\tif (rtypenum == FFI_TYPE_LONGDOUBLE)\n-\t\trtypenum = FFI_TYPE_STRUCT;\n-#endif\n-  }\n-\n-\n-  /* Copy the caller's structure return value address so that the closure\n-     returns the data directly to the caller.\n-     For FFI_SYSV the result is passed in r3/r4 if the struct size is less\n-     or equal 8 bytes.  */\n-  if (rtypenum == FFI_TYPE_STRUCT && ((cif->abi != FFI_SYSV) || (size > 8))) {\n-      rvalue = (void *) *pgr;\n-      ng++;\n-      pgr++;\n-    }\n-\n-  i = 0;\n-  avn = cif->nargs;\n-  arg_types = cif->arg_types;\n-\n-  /* Grab the addresses of the arguments from the stack frame.  */\n-  while (i < avn) {\n-      unsigned short typenum = arg_types[i]->type;\n-\n-      /* We may need to handle some values depending on ABI */\n-      if (cif->abi == FFI_LINUX_SOFT_FLOAT) {\n-\t\tif (typenum == FFI_TYPE_FLOAT)\n-\t\t\ttypenum = FFI_TYPE_UINT32;\n-\t\tif (typenum == FFI_TYPE_DOUBLE)\n-\t\t\ttypenum = FFI_TYPE_UINT64;\n-\t\tif (typenum == FFI_TYPE_LONGDOUBLE)\n-\t\t\ttypenum = FFI_TYPE_UINT128;\n-      } else if (cif->abi != FFI_LINUX && cif->abi != FFI_LINUX64) {\n-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n-\t\tif (typenum == FFI_TYPE_LONGDOUBLE)\n-\t\t\ttypenum = FFI_TYPE_STRUCT;\n+  return ffi_prep_closure_loc_sysv (closure, cif, fun, user_data, codeloc);\n #endif\n-      }\n-\n-      switch (typenum) {\n-#ifndef __NO_FPRS__\n-\tcase FFI_TYPE_FLOAT:\n-\t  /* unfortunately float values are stored as doubles\n-\t   * in the ffi_closure_SYSV code (since we don't check\n-\t   * the type in that routine).\n-\t   */\n-\n-\t  /* there are 8 64bit floating point registers */\n-\n-\t  if (nf < 8)\n-\t    {\n-\t      double temp = pfr->d;\n-\t      pfr->f = (float) temp;\n-\t      avalue[i] = pfr;\n-\t      nf++;\n-\t      pfr++;\n-\t    }\n-\t  else\n-\t    {\n-\t      /* FIXME? here we are really changing the values\n-\t       * stored in the original calling routines outgoing\n-\t       * parameter stack.  This is probably a really\n-\t       * naughty thing to do but...\n-\t       */\n-\t      avalue[i] = pst;\n-\t      pst += 1;\n-\t    }\n-\t  break;\n-\n-\tcase FFI_TYPE_DOUBLE:\n-\t  /* On the outgoing stack all values are aligned to 8 */\n-\t  /* there are 8 64bit floating point registers */\n-\n-\t  if (nf < 8)\n-\t    {\n-\t      avalue[i] = pfr;\n-\t      nf++;\n-\t      pfr++;\n-\t    }\n-\t  else\n-\t    {\n-\t      if (((long) pst) & 4)\n-\t\tpst++;\n-\t      avalue[i] = pst;\n-\t      pst += 2;\n-\t    }\n-\t  break;\n-\n-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n-\tcase FFI_TYPE_LONGDOUBLE:\n-\t  if (nf < 7)\n-\t    {\n-\t      avalue[i] = pfr;\n-\t      pfr += 2;\n-\t      nf += 2;\n-\t    }\n-\t  else\n-\t    {\n-\t      if (((long) pst) & 4)\n-\t\tpst++;\n-\t      avalue[i] = pst;\n-\t      pst += 4;\n-\t      nf = 8;\n-\t    }\n-\t  break;\n-#endif\n-#endif /* have FPRS */\n-\n-\tcase FFI_TYPE_UINT128:\n-\t\t/*\n-\t\t * Test if for the whole long double, 4 gprs are available.\n-\t\t * otherwise the stuff ends up on the stack.\n-\t\t */\n-\t\tif (ng < 5) {\n-\t\t\tavalue[i] = pgr;\n-\t\t\tpgr += 4;\n-\t\t\tng += 4;\n-\t\t} else {\n-\t\t\tavalue[i] = pst;\n-\t\t\tpst += 4;\n-\t\t\tng = 8+4;\n-\t\t}\n-\t\tbreak;\n-\n-\tcase FFI_TYPE_SINT8:\n-\tcase FFI_TYPE_UINT8:\n-#ifndef __LITTLE_ENDIAN__\n-\t  /* there are 8 gpr registers used to pass values */\n-\t  if (ng < 8)\n-\t    {\n-\t      avalue[i] = (char *) pgr + 3;\n-\t      ng++;\n-\t      pgr++;\n-\t    }\n-\t  else\n-\t    {\n-\t      avalue[i] = (char *) pst + 3;\n-\t      pst++;\n-\t    }\n-\t  break;\n-#endif\n-\n-\tcase FFI_TYPE_SINT16:\n-\tcase FFI_TYPE_UINT16:\n-#ifndef __LITTLE_ENDIAN__\n-\t  /* there are 8 gpr registers used to pass values */\n-\t  if (ng < 8)\n-\t    {\n-\t      avalue[i] = (char *) pgr + 2;\n-\t      ng++;\n-\t      pgr++;\n-\t    }\n-\t  else\n-\t    {\n-\t      avalue[i] = (char *) pst + 2;\n-\t      pst++;\n-\t    }\n-\t  break;\n-#endif\n-\n-\tcase FFI_TYPE_SINT32:\n-\tcase FFI_TYPE_UINT32:\n-\tcase FFI_TYPE_POINTER:\n-\t  /* there are 8 gpr registers used to pass values */\n-\t  if (ng < 8)\n-\t    {\n-\t      avalue[i] = pgr;\n-\t      ng++;\n-\t      pgr++;\n-\t    }\n-\t  else\n-\t    {\n-\t      avalue[i] = pst;\n-\t      pst++;\n-\t    }\n-\t  break;\n-\n-\tcase FFI_TYPE_STRUCT:\n-\t  /* Structs are passed by reference. The address will appear in a\n-\t     gpr if it is one of the first 8 arguments.  */\n-\t  if (ng < 8)\n-\t    {\n-\t      avalue[i] = (void *) *pgr;\n-\t      ng++;\n-\t      pgr++;\n-\t    }\n-\t  else\n-\t    {\n-\t      avalue[i] = (void *) *pst;\n-\t      pst++;\n-\t    }\n-\t  break;\n-\n-\tcase FFI_TYPE_SINT64:\n-\tcase FFI_TYPE_UINT64:\n-\t  /* passing long long ints are complex, they must\n-\t   * be passed in suitable register pairs such as\n-\t   * (r3,r4) or (r5,r6) or (r6,r7), or (r7,r8) or (r9,r10)\n-\t   * and if the entire pair aren't available then the outgoing\n-\t   * parameter stack is used for both but an alignment of 8\n-\t   * must will be kept.  So we must either look in pgr\n-\t   * or pst to find the correct address for this type\n-\t   * of parameter.\n-\t   */\n-\t  if (ng < 7)\n-\t    {\n-\t      if (ng & 0x01)\n-\t\t{\n-\t\t  /* skip r4, r6, r8 as starting points */\n-\t\t  ng++;\n-\t\t  pgr++;\n-\t\t}\n-\t      avalue[i] = pgr;\n-\t      ng += 2;\n-\t      pgr += 2;\n-\t    }\n-\t  else\n-\t    {\n-\t      if (((long) pst) & 4)\n-\t\tpst++;\n-\t      avalue[i] = pst;\n-\t      pst += 2;\n-\t      ng = 8;\n-\t    }\n-\t  break;\n-\n-\tdefault:\n-\t\tFFI_ASSERT (0);\n-\t}\n-\n-      i++;\n-    }\n-\n-\n-  (closure->fun) (cif, rvalue, avalue, closure->user_data);\n-\n-  /* Tell ffi_closure_SYSV how to perform return type promotions.\n-     Because the FFI_SYSV ABI returns the structures <= 8 bytes in r3/r4\n-     we have to tell ffi_closure_SYSV how to treat them. We combine the base\n-     type FFI_SYSV_TYPE_SMALL_STRUCT - 1  with the size of the struct.\n-     So a one byte struct gets the return type 16. Return type 1 to 15 are\n-     already used and we never have a struct with size zero. That is the reason\n-     for the subtraction of 1. See the comment in ffitarget.h about ordering.\n-  */\n-  if (cif->abi == FFI_SYSV && rtypenum == FFI_TYPE_STRUCT && size <= 8)\n-    return (FFI_SYSV_TYPE_SMALL_STRUCT - 1) + size;\n-  return rtypenum;\n-}\n-\n-int FFI_HIDDEN ffi_closure_helper_LINUX64 (ffi_closure *, void *,\n-\t\t\t\t\t   unsigned long *, ffi_dblfl *);\n-\n-int FFI_HIDDEN\n-ffi_closure_helper_LINUX64 (ffi_closure *closure, void *rvalue,\n-\t\t\t    unsigned long *pst, ffi_dblfl *pfr)\n-{\n-  /* rvalue is the pointer to space for return value in closure assembly */\n-  /* pst is the pointer to parameter save area\n-     (r3-r10 are stored into its first 8 slots by ffi_closure_LINUX64) */\n-  /* pfr is the pointer to where f1-f13 are stored in ffi_closure_LINUX64 */\n-\n-  void **avalue;\n-  ffi_type **arg_types;\n-  unsigned long i, avn, nfixedargs;\n-  ffi_cif *cif;\n-  ffi_dblfl *end_pfr = pfr + NUM_FPR_ARG_REGISTERS64;\n-#ifdef __STRUCT_PARM_ALIGN__\n-  unsigned long align;\n-#endif\n-\n-  cif = closure->cif;\n-  avalue = alloca (cif->nargs * sizeof (void *));\n-\n-  /* Copy the caller's structure return value address so that the\n-     closure returns the data directly to the caller.  */\n-  if (cif->rtype->type == FFI_TYPE_STRUCT\n-      && (cif->flags & FLAG_RETURNS_SMST) == 0)\n-    {\n-      rvalue = (void *) *pst;\n-      pst++;\n-    }\n-\n-  i = 0;\n-  avn = cif->nargs;\n-  nfixedargs = cif->nfixedargs;\n-  arg_types = cif->arg_types;\n-\n-  /* Grab the addresses of the arguments from the stack frame.  */\n-  while (i < avn)\n-    {\n-      unsigned int elt, elnum;\n-\n-      switch (arg_types[i]->type)\n-\t{\n-\tcase FFI_TYPE_SINT8:\n-\tcase FFI_TYPE_UINT8:\n-#ifndef __LITTLE_ENDIAN__\n-\t  avalue[i] = (char *) pst + 7;\n-\t  pst++;\n-\t  break;\n-#endif\n-\n-\tcase FFI_TYPE_SINT16:\n-\tcase FFI_TYPE_UINT16:\n-#ifndef __LITTLE_ENDIAN__\n-\t  avalue[i] = (char *) pst + 6;\n-\t  pst++;\n-\t  break;\n-#endif\n-\n-\tcase FFI_TYPE_SINT32:\n-\tcase FFI_TYPE_UINT32:\n-#ifndef __LITTLE_ENDIAN__\n-\t  avalue[i] = (char *) pst + 4;\n-\t  pst++;\n-\t  break;\n-#endif\n-\n-\tcase FFI_TYPE_SINT64:\n-\tcase FFI_TYPE_UINT64:\n-\tcase FFI_TYPE_POINTER:\n-\t  avalue[i] = pst;\n-\t  pst++;\n-\t  break;\n-\n-\tcase FFI_TYPE_STRUCT:\n-#ifdef __STRUCT_PARM_ALIGN__\n-\t  align = arg_types[i]->alignment;\n-\t  if (align > __STRUCT_PARM_ALIGN__)\n-\t    align = __STRUCT_PARM_ALIGN__;\n-\t  if (align > 1)\n-\t    pst = (unsigned long *) ALIGN ((size_t) pst, align);\n-#endif\n-\t  elt = 0;\n-#if _CALL_ELF == 2\n-\t  elt = discover_homogeneous_aggregate (arg_types[i], &elnum);\n-#endif\n-\t  if (elt)\n-\t    {\n-\t      union {\n-\t\tvoid *v;\n-\t\tunsigned long *ul;\n-\t\tfloat *f;\n-\t\tdouble *d;\n-\t\tsize_t p;\n-\t      } to, from;\n-\n-\t      /* Repackage the aggregate from its parts.  The\n-\t\t aggregate size is not greater than the space taken by\n-\t\t the registers so store back to the register/parameter\n-\t\t save arrays.  */\n-\t      if (pfr + elnum <= end_pfr)\n-\t\tto.v = pfr;\n-\t      else\n-\t\tto.v = pst;\n-\n-\t      avalue[i] = to.v;\n-\t      from.ul = pst;\n-\t      if (elt == FFI_TYPE_FLOAT)\n-\t\t{\n-\t\t  do\n-\t\t    {\n-\t\t      if (pfr < end_pfr && i < nfixedargs)\n-\t\t\t{\n-\t\t\t  *to.f = (float) pfr->d;\n-\t\t\t  pfr++;\n-\t\t\t}\n-\t\t      else\n-\t\t\t*to.f = *from.f;\n-\t\t      to.f++;\n-\t\t      from.f++;\n-\t\t    }\n-\t\t  while (--elnum != 0);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  do\n-\t\t    {\n-\t\t      if (pfr < end_pfr && i < nfixedargs)\n-\t\t\t{\n-\t\t\t  *to.d = pfr->d;\n-\t\t\t  pfr++;\n-\t\t\t}\n-\t\t      else\n-\t\t\t*to.d = *from.d;\n-\t\t      to.d++;\n-\t\t      from.d++;\n-\t\t    }\n-\t\t  while (--elnum != 0);\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-#ifndef __LITTLE_ENDIAN__\n-\t      /* Structures with size less than eight bytes are passed\n-\t\t left-padded.  */\n-\t      if (arg_types[i]->size < 8)\n-\t\tavalue[i] = (char *) pst + 8 - arg_types[i]->size;\n-\t      else\n-#endif\n-\t\tavalue[i] = pst;\n-\t    }\n-\t  pst += (arg_types[i]->size + 7) / 8;\n-\t  break;\n-\n-\tcase FFI_TYPE_FLOAT:\n-\t  /* unfortunately float values are stored as doubles\n-\t   * in the ffi_closure_LINUX64 code (since we don't check\n-\t   * the type in that routine).\n-\t   */\n-\n-\t  /* there are 13 64bit floating point registers */\n-\n-\t  if (pfr < end_pfr && i < nfixedargs)\n-\t    {\n-\t      double temp = pfr->d;\n-\t      pfr->f = (float) temp;\n-\t      avalue[i] = pfr;\n-\t      pfr++;\n-\t    }\n-\t  else\n-\t    avalue[i] = pst;\n-\t  pst++;\n-\t  break;\n-\n-\tcase FFI_TYPE_DOUBLE:\n-\t  /* On the outgoing stack all values are aligned to 8 */\n-\t  /* there are 13 64bit floating point registers */\n-\n-\t  if (pfr < end_pfr && i < nfixedargs)\n-\t    {\n-\t      avalue[i] = pfr;\n-\t      pfr++;\n-\t    }\n-\t  else\n-\t    avalue[i] = pst;\n-\t  pst++;\n-\t  break;\n-\n-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n-\tcase FFI_TYPE_LONGDOUBLE:\n-\t  if (pfr + 1 < end_pfr && i + 1 < nfixedargs)\n-\t    {\n-\t      avalue[i] = pfr;\n-\t      pfr += 2;\n-\t    }\n-\t  else\n-\t    {\n-\t      if (pfr < end_pfr && i < nfixedargs)\n-\t\t{\n-\t\t  /* Passed partly in f13 and partly on the stack.\n-\t\t     Move it all to the stack.  */\n-\t\t  *pst = *(unsigned long *) pfr;\n-\t\t  pfr++;\n-\t\t}\n-\t      avalue[i] = pst;\n-\t    }\n-\t  pst += 2;\n-\t  break;\n-#endif\n-\n-\tdefault:\n-\t  FFI_ASSERT (0);\n-\t}\n-\n-      i++;\n-    }\n-\n-\n-  (closure->fun) (cif, rvalue, avalue, closure->user_data);\n-\n-  /* Tell ffi_closure_LINUX64 how to perform return type promotions.  */\n-  if ((cif->flags & FLAG_RETURNS_SMST) != 0)\n-    {\n-      if ((cif->flags & FLAG_RETURNS_FP) == 0)\n-\treturn FFI_V2_TYPE_SMALL_STRUCT + cif->rtype->size - 1;\n-      else if ((cif->flags & FLAG_RETURNS_64BITS) != 0)\n-\treturn FFI_V2_TYPE_DOUBLE_HOMOG;\n-      else\n-\treturn FFI_V2_TYPE_FLOAT_HOMOG;\n-    }\n-  return cif->rtype->type;\n }"}, {"sha": "33f24b327b687291a10a9b3a22ef2aa47614d38a", "filename": "libffi/src/powerpc/ffi_linux64.c", "status": "added", "additions": 942, "deletions": 0, "changes": 942, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d2479dd03132a1147c013426ea8e88c10d2ff/libffi%2Fsrc%2Fpowerpc%2Fffi_linux64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d2479dd03132a1147c013426ea8e88c10d2ff/libffi%2Fsrc%2Fpowerpc%2Fffi_linux64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fffi_linux64.c?ref=e73d2479dd03132a1147c013426ea8e88c10d2ff", "patch": "@@ -0,0 +1,942 @@\n+/* -----------------------------------------------------------------------\n+   ffi_linux64.c - Copyright (C) 2013 IBM\n+                   Copyright (C) 2011 Anthony Green\n+                   Copyright (C) 2011 Kyle Moffett\n+                   Copyright (C) 2008 Red Hat, Inc\n+                   Copyright (C) 2007, 2008 Free Software Foundation, Inc\n+                   Copyright (c) 1998 Geoffrey Keating\n+\n+   PowerPC Foreign Function Interface\n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+   IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR\n+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+   OTHER DEALINGS IN THE SOFTWARE.\n+   ----------------------------------------------------------------------- */\n+\n+#include \"ffi.h\"\n+\n+#ifdef POWERPC64\n+#include \"ffi_common.h\"\n+#include \"ffi_powerpc.h\"\n+\n+\n+/* About the LINUX64 ABI.  */\n+enum {\n+  NUM_GPR_ARG_REGISTERS64 = 8,\n+  NUM_FPR_ARG_REGISTERS64 = 13\n+};\n+enum { ASM_NEEDS_REGISTERS64 = 4 };\n+\n+\n+#if HAVE_LONG_DOUBLE_VARIANT && FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+/* Adjust size of ffi_type_longdouble.  */\n+void FFI_HIDDEN\n+ffi_prep_types_linux64 (ffi_abi abi)\n+{\n+  if ((abi & (FFI_LINUX | FFI_LINUX_LONG_DOUBLE_128)) == FFI_LINUX)\n+    {\n+      ffi_type_longdouble.size = 8;\n+      ffi_type_longdouble.alignment = 8;\n+    }\n+  else\n+    {\n+      ffi_type_longdouble.size = 16;\n+      ffi_type_longdouble.alignment = 16;\n+    }\n+}\n+#endif\n+\n+\n+#if _CALL_ELF == 2\n+static unsigned int\n+discover_homogeneous_aggregate (const ffi_type *t, unsigned int *elnum)\n+{\n+  switch (t->type)\n+    {\n+    case FFI_TYPE_FLOAT:\n+    case FFI_TYPE_DOUBLE:\n+      *elnum = 1;\n+      return (int) t->type;\n+\n+    case FFI_TYPE_STRUCT:;\n+      {\n+\tunsigned int base_elt = 0, total_elnum = 0;\n+\tffi_type **el = t->elements;\n+\twhile (*el)\n+\t  {\n+\t    unsigned int el_elt, el_elnum = 0;\n+\t    el_elt = discover_homogeneous_aggregate (*el, &el_elnum);\n+\t    if (el_elt == 0\n+\t\t|| (base_elt && base_elt != el_elt))\n+\t      return 0;\n+\t    base_elt = el_elt;\n+\t    total_elnum += el_elnum;\n+\t    if (total_elnum > 8)\n+\t      return 0;\n+\t    el++;\n+\t  }\n+\t*elnum = total_elnum;\n+\treturn base_elt;\n+      }\n+\n+    default:\n+      return 0;\n+    }\n+}\n+#endif\n+\n+\n+/* Perform machine dependent cif processing */\n+static ffi_status\n+ffi_prep_cif_linux64_core (ffi_cif *cif)\n+{\n+  ffi_type **ptr;\n+  unsigned bytes;\n+  unsigned i, fparg_count = 0, intarg_count = 0;\n+  unsigned flags = cif->flags;\n+#if _CALL_ELF == 2\n+  unsigned int elt, elnum;\n+#endif\n+\n+#if FFI_TYPE_LONGDOUBLE == FFI_TYPE_DOUBLE\n+  /* If compiled without long double support..  */\n+  if ((cif->abi & FFI_LINUX_LONG_DOUBLE_128) != 0)\n+    return FFI_BAD_ABI;\n+#endif\n+\n+  /* The machine-independent calculation of cif->bytes doesn't work\n+     for us.  Redo the calculation.  */\n+#if _CALL_ELF == 2\n+  /* Space for backchain, CR, LR, TOC and the asm's temp regs.  */\n+  bytes = (4 + ASM_NEEDS_REGISTERS64) * sizeof (long);\n+\n+  /* Space for the general registers.  */\n+  bytes += NUM_GPR_ARG_REGISTERS64 * sizeof (long);\n+#else\n+  /* Space for backchain, CR, LR, cc/ld doubleword, TOC and the asm's temp\n+     regs.  */\n+  bytes = (6 + ASM_NEEDS_REGISTERS64) * sizeof (long);\n+\n+  /* Space for the mandatory parm save area and general registers.  */\n+  bytes += 2 * NUM_GPR_ARG_REGISTERS64 * sizeof (long);\n+#endif\n+\n+  /* Return value handling.  */\n+  switch (cif->rtype->type)\n+    {\n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+    case FFI_TYPE_LONGDOUBLE:\n+      if ((cif->abi & FFI_LINUX_LONG_DOUBLE_128) != 0)\n+\tflags |= FLAG_RETURNS_128BITS;\n+      /* Fall through.  */\n+#endif\n+    case FFI_TYPE_DOUBLE:\n+      flags |= FLAG_RETURNS_64BITS;\n+      /* Fall through.  */\n+    case FFI_TYPE_FLOAT:\n+      flags |= FLAG_RETURNS_FP;\n+      break;\n+\n+    case FFI_TYPE_UINT128:\n+      flags |= FLAG_RETURNS_128BITS;\n+      /* Fall through.  */\n+    case FFI_TYPE_UINT64:\n+    case FFI_TYPE_SINT64:\n+      flags |= FLAG_RETURNS_64BITS;\n+      break;\n+\n+    case FFI_TYPE_STRUCT:\n+#if _CALL_ELF == 2\n+      elt = discover_homogeneous_aggregate (cif->rtype, &elnum);\n+      if (elt)\n+\t{\n+\t  if (elt == FFI_TYPE_DOUBLE)\n+\t    flags |= FLAG_RETURNS_64BITS;\n+\t  flags |= FLAG_RETURNS_FP | FLAG_RETURNS_SMST;\n+\t  break;\n+\t}\n+      if (cif->rtype->size <= 16)\n+\t{\n+\t  flags |= FLAG_RETURNS_SMST;\n+\t  break;\n+\t}\n+#endif\n+      intarg_count++;\n+      flags |= FLAG_RETVAL_REFERENCE;\n+      /* Fall through.  */\n+    case FFI_TYPE_VOID:\n+      flags |= FLAG_RETURNS_NOTHING;\n+      break;\n+\n+    default:\n+      /* Returns 32-bit integer, or similar.  Nothing to do here.  */\n+      break;\n+    }\n+\n+  for (ptr = cif->arg_types, i = cif->nargs; i > 0; i--, ptr++)\n+    {\n+      unsigned int align;\n+\n+      switch ((*ptr)->type)\n+\t{\n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+\tcase FFI_TYPE_LONGDOUBLE:\n+\t  if ((cif->abi & FFI_LINUX_LONG_DOUBLE_128) != 0)\n+\t    {\n+\t      fparg_count++;\n+\t      intarg_count++;\n+\t    }\n+\t  /* Fall through.  */\n+#endif\n+\tcase FFI_TYPE_DOUBLE:\n+\tcase FFI_TYPE_FLOAT:\n+\t  fparg_count++;\n+\t  intarg_count++;\n+\t  if (fparg_count > NUM_FPR_ARG_REGISTERS64)\n+\t    flags |= FLAG_ARG_NEEDS_PSAVE;\n+\t  break;\n+\n+\tcase FFI_TYPE_STRUCT:\n+\t  if ((cif->abi & FFI_LINUX_STRUCT_ALIGN) != 0)\n+\t    {\n+\t      align = (*ptr)->alignment;\n+\t      if (align > 16)\n+\t\talign = 16;\n+\t      align = align / 8;\n+\t      if (align > 1)\n+\t\tintarg_count = ALIGN (intarg_count, align);\n+\t    }\n+\t  intarg_count += ((*ptr)->size + 7) / 8;\n+#if _CALL_ELF == 2\n+\t  elt = discover_homogeneous_aggregate (*ptr, &elnum);\n+\t  if (elt)\n+\t    {\n+\t      fparg_count += elnum;\n+\t      if (fparg_count > NUM_FPR_ARG_REGISTERS64)\n+\t\tflags |= FLAG_ARG_NEEDS_PSAVE;\n+\t    }\n+\t  else\n+#endif\n+\t    {\n+\t      if (intarg_count > NUM_GPR_ARG_REGISTERS64)\n+\t\tflags |= FLAG_ARG_NEEDS_PSAVE;\n+\t    }\n+\t  break;\n+\n+\tcase FFI_TYPE_POINTER:\n+\tcase FFI_TYPE_UINT64:\n+\tcase FFI_TYPE_SINT64:\n+\tcase FFI_TYPE_INT:\n+\tcase FFI_TYPE_UINT32:\n+\tcase FFI_TYPE_SINT32:\n+\tcase FFI_TYPE_UINT16:\n+\tcase FFI_TYPE_SINT16:\n+\tcase FFI_TYPE_UINT8:\n+\tcase FFI_TYPE_SINT8:\n+\t  /* Everything else is passed as a 8-byte word in a GPR, either\n+\t     the object itself or a pointer to it.  */\n+\t  intarg_count++;\n+\t  if (intarg_count > NUM_GPR_ARG_REGISTERS64)\n+\t    flags |= FLAG_ARG_NEEDS_PSAVE;\n+\t  break;\n+\tdefault:\n+\t  FFI_ASSERT (0);\n+\t}\n+    }\n+\n+  if (fparg_count != 0)\n+    flags |= FLAG_FP_ARGUMENTS;\n+  if (intarg_count > 4)\n+    flags |= FLAG_4_GPR_ARGUMENTS;\n+\n+  /* Space for the FPR registers, if needed.  */\n+  if (fparg_count != 0)\n+    bytes += NUM_FPR_ARG_REGISTERS64 * sizeof (double);\n+\n+  /* Stack space.  */\n+#if _CALL_ELF == 2\n+  if ((flags & FLAG_ARG_NEEDS_PSAVE) != 0)\n+    bytes += intarg_count * sizeof (long);\n+#else\n+  if (intarg_count > NUM_GPR_ARG_REGISTERS64)\n+    bytes += (intarg_count - NUM_GPR_ARG_REGISTERS64) * sizeof (long);\n+#endif\n+\n+  /* The stack space allocated needs to be a multiple of 16 bytes.  */\n+  bytes = (bytes + 15) & ~0xF;\n+\n+  cif->flags = flags;\n+  cif->bytes = bytes;\n+\n+  return FFI_OK;\n+}\n+\n+ffi_status FFI_HIDDEN\n+ffi_prep_cif_linux64 (ffi_cif *cif)\n+{\n+  if ((cif->abi & FFI_LINUX) != 0)\n+    cif->nfixedargs = cif->nargs;\n+#if _CALL_ELF != 2\n+  else if (cif->abi == FFI_COMPAT_LINUX64)\n+    {\n+      /* This call is from old code.  Don't touch cif->nfixedargs\n+\t since old code will be using a smaller cif.  */\n+      cif->flags |= FLAG_COMPAT;\n+      /* Translate to new abi value.  */\n+      cif->abi = FFI_LINUX | FFI_LINUX_LONG_DOUBLE_128;\n+    }\n+#endif\n+  else\n+    return FFI_BAD_ABI;\n+  return ffi_prep_cif_linux64_core (cif);\n+}\n+\n+ffi_status FFI_HIDDEN\n+ffi_prep_cif_linux64_var (ffi_cif *cif,\n+\t\t\t  unsigned int nfixedargs,\n+\t\t\t  unsigned int ntotalargs MAYBE_UNUSED)\n+{\n+  if ((cif->abi & FFI_LINUX) != 0)\n+    cif->nfixedargs = nfixedargs;\n+#if _CALL_ELF != 2\n+  else if (cif->abi == FFI_COMPAT_LINUX64)\n+    {\n+      /* This call is from old code.  Don't touch cif->nfixedargs\n+\t since old code will be using a smaller cif.  */\n+      cif->flags |= FLAG_COMPAT;\n+      /* Translate to new abi value.  */\n+      cif->abi = FFI_LINUX | FFI_LINUX_LONG_DOUBLE_128;\n+    }\n+#endif\n+  else\n+    return FFI_BAD_ABI;\n+#if _CALL_ELF == 2\n+  cif->flags |= FLAG_ARG_NEEDS_PSAVE;\n+#endif\n+  return ffi_prep_cif_linux64_core (cif);\n+}\n+\n+\n+/* ffi_prep_args64 is called by the assembly routine once stack space\n+   has been allocated for the function's arguments.\n+\n+   The stack layout we want looks like this:\n+\n+   |   Ret addr from ffi_call_LINUX64\t8bytes\t|\thigher addresses\n+   |--------------------------------------------|\n+   |   CR save area\t\t\t8bytes\t|\n+   |--------------------------------------------|\n+   |   Previous backchain pointer\t8\t|\tstack pointer here\n+   |--------------------------------------------|<+ <<<\ton entry to\n+   |   Saved r28-r31\t\t\t4*8\t| |\tffi_call_LINUX64\n+   |--------------------------------------------| |\n+   |   GPR registers r3-r10\t\t8*8\t| |\n+   |--------------------------------------------| |\n+   |   FPR registers f1-f13 (optional)\t13*8\t| |\n+   |--------------------------------------------| |\n+   |   Parameter save area\t\t        | |\n+   |--------------------------------------------| |\n+   |   TOC save area\t\t\t8\t| |\n+   |--------------------------------------------| |\tstack\t|\n+   |   Linker doubleword\t\t8\t| |\tgrows\t|\n+   |--------------------------------------------| |\tdown\tV\n+   |   Compiler doubleword\t\t8\t| |\n+   |--------------------------------------------| |\tlower addresses\n+   |   Space for callee's LR\t\t8\t| |\n+   |--------------------------------------------| |\n+   |   CR save area\t\t\t8\t| |\n+   |--------------------------------------------| |\tstack pointer here\n+   |   Current backchain pointer\t8\t|-/\tduring\n+   |--------------------------------------------|   <<<\tffi_call_LINUX64\n+\n+*/\n+\n+void FFI_HIDDEN\n+ffi_prep_args64 (extended_cif *ecif, unsigned long *const stack)\n+{\n+  const unsigned long bytes = ecif->cif->bytes;\n+  const unsigned long flags = ecif->cif->flags;\n+\n+  typedef union\n+  {\n+    char *c;\n+    unsigned long *ul;\n+    float *f;\n+    double *d;\n+    size_t p;\n+  } valp;\n+\n+  /* 'stacktop' points at the previous backchain pointer.  */\n+  valp stacktop;\n+\n+  /* 'next_arg' points at the space for gpr3, and grows upwards as\n+     we use GPR registers, then continues at rest.  */\n+  valp gpr_base;\n+  valp gpr_end;\n+  valp rest;\n+  valp next_arg;\n+\n+  /* 'fpr_base' points at the space for fpr3, and grows upwards as\n+     we use FPR registers.  */\n+  valp fpr_base;\n+  unsigned int fparg_count;\n+\n+  unsigned int i, words, nargs, nfixedargs;\n+  ffi_type **ptr;\n+  double double_tmp;\n+  union\n+  {\n+    void **v;\n+    char **c;\n+    signed char **sc;\n+    unsigned char **uc;\n+    signed short **ss;\n+    unsigned short **us;\n+    signed int **si;\n+    unsigned int **ui;\n+    unsigned long **ul;\n+    float **f;\n+    double **d;\n+  } p_argv;\n+  unsigned long gprvalue;\n+  unsigned long align;\n+\n+  stacktop.c = (char *) stack + bytes;\n+  gpr_base.ul = stacktop.ul - ASM_NEEDS_REGISTERS64 - NUM_GPR_ARG_REGISTERS64;\n+  gpr_end.ul = gpr_base.ul + NUM_GPR_ARG_REGISTERS64;\n+#if _CALL_ELF == 2\n+  rest.ul = stack + 4 + NUM_GPR_ARG_REGISTERS64;\n+#else\n+  rest.ul = stack + 6 + NUM_GPR_ARG_REGISTERS64;\n+#endif\n+  fpr_base.d = gpr_base.d - NUM_FPR_ARG_REGISTERS64;\n+  fparg_count = 0;\n+  next_arg.ul = gpr_base.ul;\n+\n+  /* Check that everything starts aligned properly.  */\n+  FFI_ASSERT (((unsigned long) (char *) stack & 0xF) == 0);\n+  FFI_ASSERT (((unsigned long) stacktop.c & 0xF) == 0);\n+  FFI_ASSERT ((bytes & 0xF) == 0);\n+\n+  /* Deal with return values that are actually pass-by-reference.  */\n+  if (flags & FLAG_RETVAL_REFERENCE)\n+    *next_arg.ul++ = (unsigned long) (char *) ecif->rvalue;\n+\n+  /* Now for the arguments.  */\n+  p_argv.v = ecif->avalue;\n+  nargs = ecif->cif->nargs;\n+#if _CALL_ELF != 2\n+  nfixedargs = (unsigned) -1;\n+  if ((flags & FLAG_COMPAT) == 0)\n+#endif\n+    nfixedargs = ecif->cif->nfixedargs;\n+  for (ptr = ecif->cif->arg_types, i = 0;\n+       i < nargs;\n+       i++, ptr++, p_argv.v++)\n+    {\n+#if _CALL_ELF == 2\n+      unsigned int elt, elnum;\n+#endif\n+\n+      switch ((*ptr)->type)\n+\t{\n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+\tcase FFI_TYPE_LONGDOUBLE:\n+\t  if ((ecif->cif->abi & FFI_LINUX_LONG_DOUBLE_128) != 0)\n+\t    {\n+\t      double_tmp = (*p_argv.d)[0];\n+\t      if (fparg_count < NUM_FPR_ARG_REGISTERS64 && i < nfixedargs)\n+\t\t{\n+\t\t  *fpr_base.d++ = double_tmp;\n+# if _CALL_ELF != 2\n+\t\t  if ((flags & FLAG_COMPAT) != 0)\n+\t\t    *next_arg.d = double_tmp;\n+# endif\n+\t\t}\n+\t      else\n+\t\t*next_arg.d = double_tmp;\n+\t      if (++next_arg.ul == gpr_end.ul)\n+\t\tnext_arg.ul = rest.ul;\n+\t      fparg_count++;\n+\t      double_tmp = (*p_argv.d)[1];\n+\t      if (fparg_count < NUM_FPR_ARG_REGISTERS64 && i < nfixedargs)\n+\t\t{\n+\t\t  *fpr_base.d++ = double_tmp;\n+# if _CALL_ELF != 2\n+\t\t  if ((flags & FLAG_COMPAT) != 0)\n+\t\t    *next_arg.d = double_tmp;\n+# endif\n+\t\t}\n+\t      else\n+\t\t*next_arg.d = double_tmp;\n+\t      if (++next_arg.ul == gpr_end.ul)\n+\t\tnext_arg.ul = rest.ul;\n+\t      fparg_count++;\n+\t      FFI_ASSERT (__LDBL_MANT_DIG__ == 106);\n+\t      FFI_ASSERT (flags & FLAG_FP_ARGUMENTS);\n+\t      break;\n+\t    }\n+\t  /* Fall through.  */\n+#endif\n+\tcase FFI_TYPE_DOUBLE:\n+\t  double_tmp = **p_argv.d;\n+\t  if (fparg_count < NUM_FPR_ARG_REGISTERS64 && i < nfixedargs)\n+\t    {\n+\t      *fpr_base.d++ = double_tmp;\n+#if _CALL_ELF != 2\n+\t      if ((flags & FLAG_COMPAT) != 0)\n+\t\t*next_arg.d = double_tmp;\n+#endif\n+\t    }\n+\t  else\n+\t    *next_arg.d = double_tmp;\n+\t  if (++next_arg.ul == gpr_end.ul)\n+\t    next_arg.ul = rest.ul;\n+\t  fparg_count++;\n+\t  FFI_ASSERT (flags & FLAG_FP_ARGUMENTS);\n+\t  break;\n+\n+\tcase FFI_TYPE_FLOAT:\n+\t  double_tmp = **p_argv.f;\n+\t  if (fparg_count < NUM_FPR_ARG_REGISTERS64 && i < nfixedargs)\n+\t    {\n+\t      *fpr_base.d++ = double_tmp;\n+#if _CALL_ELF != 2\n+\t      if ((flags & FLAG_COMPAT) != 0)\n+\t\t*next_arg.f = (float) double_tmp;\n+#endif\n+\t    }\n+\t  else\n+\t    *next_arg.f = (float) double_tmp;\n+\t  if (++next_arg.ul == gpr_end.ul)\n+\t    next_arg.ul = rest.ul;\n+\t  fparg_count++;\n+\t  FFI_ASSERT (flags & FLAG_FP_ARGUMENTS);\n+\t  break;\n+\n+\tcase FFI_TYPE_STRUCT:\n+\t  if ((ecif->cif->abi & FFI_LINUX_STRUCT_ALIGN) != 0)\n+\t    {\n+\t      align = (*ptr)->alignment;\n+\t      if (align > 16)\n+\t\talign = 16;\n+\t      if (align > 1)\n+\t\tnext_arg.p = ALIGN (next_arg.p, align);\n+\t    }\n+#if _CALL_ELF == 2\n+\t  elt = discover_homogeneous_aggregate (*ptr, &elnum);\n+\t  if (elt)\n+\t    {\n+\t      union {\n+\t\tvoid *v;\n+\t\tfloat *f;\n+\t\tdouble *d;\n+\t      } arg;\n+\n+\t      arg.v = *p_argv.v;\n+\t      if (elt == FFI_TYPE_FLOAT)\n+\t\t{\n+\t\t  do\n+\t\t    {\n+\t\t      double_tmp = *arg.f++;\n+\t\t      if (fparg_count < NUM_FPR_ARG_REGISTERS64\n+\t\t\t  && i < nfixedargs)\n+\t\t\t*fpr_base.d++ = double_tmp;\n+\t\t      else\n+\t\t\t*next_arg.f = (float) double_tmp;\n+\t\t      if (++next_arg.f == gpr_end.f)\n+\t\t\tnext_arg.f = rest.f;\n+\t\t      fparg_count++;\n+\t\t    }\n+\t\t  while (--elnum != 0);\n+\t\t  if ((next_arg.p & 3) != 0)\n+\t\t    {\n+\t\t      if (++next_arg.f == gpr_end.f)\n+\t\t\tnext_arg.f = rest.f;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\tdo\n+\t\t  {\n+\t\t    double_tmp = *arg.d++;\n+\t\t    if (fparg_count < NUM_FPR_ARG_REGISTERS64 && i < nfixedargs)\n+\t\t      *fpr_base.d++ = double_tmp;\n+\t\t    else\n+\t\t      *next_arg.d = double_tmp;\n+\t\t    if (++next_arg.d == gpr_end.d)\n+\t\t      next_arg.d = rest.d;\n+\t\t    fparg_count++;\n+\t\t  }\n+\t\twhile (--elnum != 0);\n+\t    }\n+\t  else\n+#endif\n+\t    {\n+\t      words = ((*ptr)->size + 7) / 8;\n+\t      if (next_arg.ul >= gpr_base.ul && next_arg.ul + words > gpr_end.ul)\n+\t\t{\n+\t\t  size_t first = gpr_end.c - next_arg.c;\n+\t\t  memcpy (next_arg.c, *p_argv.c, first);\n+\t\t  memcpy (rest.c, *p_argv.c + first, (*ptr)->size - first);\n+\t\t  next_arg.c = rest.c + words * 8 - first;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  char *where = next_arg.c;\n+\n+#ifndef __LITTLE_ENDIAN__\n+\t\t  /* Structures with size less than eight bytes are passed\n+\t\t     left-padded.  */\n+\t\t  if ((*ptr)->size < 8)\n+\t\t    where += 8 - (*ptr)->size;\n+#endif\n+\t\t  memcpy (where, *p_argv.c, (*ptr)->size);\n+\t\t  next_arg.ul += words;\n+\t\t  if (next_arg.ul == gpr_end.ul)\n+\t\t    next_arg.ul = rest.ul;\n+\t\t}\n+\t    }\n+\t  break;\n+\n+\tcase FFI_TYPE_UINT8:\n+\t  gprvalue = **p_argv.uc;\n+\t  goto putgpr;\n+\tcase FFI_TYPE_SINT8:\n+\t  gprvalue = **p_argv.sc;\n+\t  goto putgpr;\n+\tcase FFI_TYPE_UINT16:\n+\t  gprvalue = **p_argv.us;\n+\t  goto putgpr;\n+\tcase FFI_TYPE_SINT16:\n+\t  gprvalue = **p_argv.ss;\n+\t  goto putgpr;\n+\tcase FFI_TYPE_UINT32:\n+\t  gprvalue = **p_argv.ui;\n+\t  goto putgpr;\n+\tcase FFI_TYPE_INT:\n+\tcase FFI_TYPE_SINT32:\n+\t  gprvalue = **p_argv.si;\n+\t  goto putgpr;\n+\n+\tcase FFI_TYPE_UINT64:\n+\tcase FFI_TYPE_SINT64:\n+\tcase FFI_TYPE_POINTER:\n+\t  gprvalue = **p_argv.ul;\n+\tputgpr:\n+\t  *next_arg.ul++ = gprvalue;\n+\t  if (next_arg.ul == gpr_end.ul)\n+\t    next_arg.ul = rest.ul;\n+\t  break;\n+\t}\n+    }\n+\n+  FFI_ASSERT (flags & FLAG_4_GPR_ARGUMENTS\n+\t      || (next_arg.ul >= gpr_base.ul\n+\t\t  && next_arg.ul <= gpr_base.ul + 4));\n+}\n+\n+\n+#if _CALL_ELF == 2\n+#define MIN_CACHE_LINE_SIZE 8\n+\n+static void\n+flush_icache (char *wraddr, char *xaddr, int size)\n+{\n+  int i;\n+  for (i = 0; i < size; i += MIN_CACHE_LINE_SIZE)\n+    __asm__ volatile (\"icbi 0,%0;\" \"dcbf 0,%1;\"\n+\t\t      : : \"r\" (xaddr + i), \"r\" (wraddr + i) : \"memory\");\n+  __asm__ volatile (\"icbi 0,%0;\" \"dcbf 0,%1;\" \"sync;\" \"isync;\"\n+\t\t    : : \"r\"(xaddr + size - 1), \"r\"(wraddr + size - 1)\n+\t\t    : \"memory\");\n+}\n+#endif\n+\n+ffi_status\n+ffi_prep_closure_loc_linux64 (ffi_closure *closure,\n+\t\t\t      ffi_cif *cif,\n+\t\t\t      void (*fun) (ffi_cif *, void *, void **, void *),\n+\t\t\t      void *user_data,\n+\t\t\t      void *codeloc)\n+{\n+#if _CALL_ELF == 2\n+  unsigned int *tramp = (unsigned int *) &closure->tramp[0];\n+\n+  if (cif->abi < FFI_LINUX || cif->abi >= FFI_LAST_ABI)\n+    return FFI_BAD_ABI;\n+\n+  tramp[0] = 0xe96c0018;\t/* 0:\tld\t11,2f-0b(12)\t*/\n+  tramp[1] = 0xe98c0010;\t/*\tld\t12,1f-0b(12)\t*/\n+  tramp[2] = 0x7d8903a6;\t/*\tmtctr\t12\t\t*/\n+  tramp[3] = 0x4e800420;\t/*\tbctr\t\t\t*/\n+\t\t\t\t/* 1:\t.quad\tfunction_addr\t*/\n+\t\t\t\t/* 2:\t.quad\tcontext\t\t*/\n+  *(void **) &tramp[4] = (void *) ffi_closure_LINUX64;\n+  *(void **) &tramp[6] = codeloc;\n+  flush_icache ((char *)tramp, (char *)codeloc, FFI_TRAMPOLINE_SIZE);\n+#else\n+  void **tramp = (void **) &closure->tramp[0];\n+\n+  if (cif->abi < FFI_LINUX || cif->abi >= FFI_LAST_ABI)\n+    return FFI_BAD_ABI;\n+\n+  /* Copy function address and TOC from ffi_closure_LINUX64.  */\n+  memcpy (tramp, (char *) ffi_closure_LINUX64, 16);\n+  tramp[2] = codeloc;\n+#endif\n+\n+  closure->cif = cif;\n+  closure->fun = fun;\n+  closure->user_data = user_data;\n+\n+  return FFI_OK;\n+}\n+\n+\n+int FFI_HIDDEN\n+ffi_closure_helper_LINUX64 (ffi_closure *closure, void *rvalue,\n+\t\t\t    unsigned long *pst, ffi_dblfl *pfr)\n+{\n+  /* rvalue is the pointer to space for return value in closure assembly */\n+  /* pst is the pointer to parameter save area\n+     (r3-r10 are stored into its first 8 slots by ffi_closure_LINUX64) */\n+  /* pfr is the pointer to where f1-f13 are stored in ffi_closure_LINUX64 */\n+\n+  void **avalue;\n+  ffi_type **arg_types;\n+  unsigned long i, avn, nfixedargs;\n+  ffi_cif *cif;\n+  ffi_dblfl *end_pfr = pfr + NUM_FPR_ARG_REGISTERS64;\n+  unsigned long align;\n+\n+  cif = closure->cif;\n+  avalue = alloca (cif->nargs * sizeof (void *));\n+\n+  /* Copy the caller's structure return value address so that the\n+     closure returns the data directly to the caller.  */\n+  if (cif->rtype->type == FFI_TYPE_STRUCT\n+      && (cif->flags & FLAG_RETURNS_SMST) == 0)\n+    {\n+      rvalue = (void *) *pst;\n+      pst++;\n+    }\n+\n+  i = 0;\n+  avn = cif->nargs;\n+#if _CALL_ELF != 2\n+  nfixedargs = (unsigned) -1;\n+  if ((cif->flags & FLAG_COMPAT) == 0)\n+#endif\n+    nfixedargs = cif->nfixedargs;\n+  arg_types = cif->arg_types;\n+\n+  /* Grab the addresses of the arguments from the stack frame.  */\n+  while (i < avn)\n+    {\n+      unsigned int elt, elnum;\n+\n+      switch (arg_types[i]->type)\n+\t{\n+\tcase FFI_TYPE_SINT8:\n+\tcase FFI_TYPE_UINT8:\n+#ifndef __LITTLE_ENDIAN__\n+\t  avalue[i] = (char *) pst + 7;\n+\t  pst++;\n+\t  break;\n+#endif\n+\n+\tcase FFI_TYPE_SINT16:\n+\tcase FFI_TYPE_UINT16:\n+#ifndef __LITTLE_ENDIAN__\n+\t  avalue[i] = (char *) pst + 6;\n+\t  pst++;\n+\t  break;\n+#endif\n+\n+\tcase FFI_TYPE_SINT32:\n+\tcase FFI_TYPE_UINT32:\n+#ifndef __LITTLE_ENDIAN__\n+\t  avalue[i] = (char *) pst + 4;\n+\t  pst++;\n+\t  break;\n+#endif\n+\n+\tcase FFI_TYPE_SINT64:\n+\tcase FFI_TYPE_UINT64:\n+\tcase FFI_TYPE_POINTER:\n+\t  avalue[i] = pst;\n+\t  pst++;\n+\t  break;\n+\n+\tcase FFI_TYPE_STRUCT:\n+\t  if ((cif->abi & FFI_LINUX_STRUCT_ALIGN) != 0)\n+\t    {\n+\t      align = arg_types[i]->alignment;\n+\t      if (align > 16)\n+\t\talign = 16;\n+\t      if (align > 1)\n+\t\tpst = (unsigned long *) ALIGN ((size_t) pst, align);\n+\t    }\n+\t  elt = 0;\n+#if _CALL_ELF == 2\n+\t  elt = discover_homogeneous_aggregate (arg_types[i], &elnum);\n+#endif\n+\t  if (elt)\n+\t    {\n+\t      union {\n+\t\tvoid *v;\n+\t\tunsigned long *ul;\n+\t\tfloat *f;\n+\t\tdouble *d;\n+\t\tsize_t p;\n+\t      } to, from;\n+\n+\t      /* Repackage the aggregate from its parts.  The\n+\t\t aggregate size is not greater than the space taken by\n+\t\t the registers so store back to the register/parameter\n+\t\t save arrays.  */\n+\t      if (pfr + elnum <= end_pfr)\n+\t\tto.v = pfr;\n+\t      else\n+\t\tto.v = pst;\n+\n+\t      avalue[i] = to.v;\n+\t      from.ul = pst;\n+\t      if (elt == FFI_TYPE_FLOAT)\n+\t\t{\n+\t\t  do\n+\t\t    {\n+\t\t      if (pfr < end_pfr && i < nfixedargs)\n+\t\t\t{\n+\t\t\t  *to.f = (float) pfr->d;\n+\t\t\t  pfr++;\n+\t\t\t}\n+\t\t      else\n+\t\t\t*to.f = *from.f;\n+\t\t      to.f++;\n+\t\t      from.f++;\n+\t\t    }\n+\t\t  while (--elnum != 0);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  do\n+\t\t    {\n+\t\t      if (pfr < end_pfr && i < nfixedargs)\n+\t\t\t{\n+\t\t\t  *to.d = pfr->d;\n+\t\t\t  pfr++;\n+\t\t\t}\n+\t\t      else\n+\t\t\t*to.d = *from.d;\n+\t\t      to.d++;\n+\t\t      from.d++;\n+\t\t    }\n+\t\t  while (--elnum != 0);\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+#ifndef __LITTLE_ENDIAN__\n+\t      /* Structures with size less than eight bytes are passed\n+\t\t left-padded.  */\n+\t      if (arg_types[i]->size < 8)\n+\t\tavalue[i] = (char *) pst + 8 - arg_types[i]->size;\n+\t      else\n+#endif\n+\t\tavalue[i] = pst;\n+\t    }\n+\t  pst += (arg_types[i]->size + 7) / 8;\n+\t  break;\n+\n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+\tcase FFI_TYPE_LONGDOUBLE:\n+\t  if ((cif->abi & FFI_LINUX_LONG_DOUBLE_128) != 0)\n+\t    {\n+\t      if (pfr + 1 < end_pfr && i + 1 < nfixedargs)\n+\t\t{\n+\t\t  avalue[i] = pfr;\n+\t\t  pfr += 2;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (pfr < end_pfr && i < nfixedargs)\n+\t\t    {\n+\t\t      /* Passed partly in f13 and partly on the stack.\n+\t\t\t Move it all to the stack.  */\n+\t\t      *pst = *(unsigned long *) pfr;\n+\t\t      pfr++;\n+\t\t    }\n+\t\t  avalue[i] = pst;\n+\t\t}\n+\t      pst += 2;\n+\t      break;\n+\t    }\n+\t  /* Fall through.  */\n+#endif\n+\tcase FFI_TYPE_DOUBLE:\n+\t  /* On the outgoing stack all values are aligned to 8 */\n+\t  /* there are 13 64bit floating point registers */\n+\n+\t  if (pfr < end_pfr && i < nfixedargs)\n+\t    {\n+\t      avalue[i] = pfr;\n+\t      pfr++;\n+\t    }\n+\t  else\n+\t    avalue[i] = pst;\n+\t  pst++;\n+\t  break;\n+\n+\tcase FFI_TYPE_FLOAT:\n+\t  if (pfr < end_pfr && i < nfixedargs)\n+\t    {\n+\t      /* Float values are stored as doubles in the\n+\t\t ffi_closure_LINUX64 code.  Fix them here.  */\n+\t      pfr->f = (float) pfr->d;\n+\t      avalue[i] = pfr;\n+\t      pfr++;\n+\t    }\n+\t  else\n+\t    avalue[i] = pst;\n+\t  pst++;\n+\t  break;\n+\n+\tdefault:\n+\t  FFI_ASSERT (0);\n+\t}\n+\n+      i++;\n+    }\n+\n+\n+  (closure->fun) (cif, rvalue, avalue, closure->user_data);\n+\n+  /* Tell ffi_closure_LINUX64 how to perform return type promotions.  */\n+  if ((cif->flags & FLAG_RETURNS_SMST) != 0)\n+    {\n+      if ((cif->flags & FLAG_RETURNS_FP) == 0)\n+\treturn FFI_V2_TYPE_SMALL_STRUCT + cif->rtype->size - 1;\n+      else if ((cif->flags & FLAG_RETURNS_64BITS) != 0)\n+\treturn FFI_V2_TYPE_DOUBLE_HOMOG;\n+      else\n+\treturn FFI_V2_TYPE_FLOAT_HOMOG;\n+    }\n+  return cif->rtype->type;\n+}\n+#endif"}, {"sha": "2e61653d1a78b7992baed1fa171949f0b17a5e70", "filename": "libffi/src/powerpc/ffi_powerpc.h", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d2479dd03132a1147c013426ea8e88c10d2ff/libffi%2Fsrc%2Fpowerpc%2Fffi_powerpc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d2479dd03132a1147c013426ea8e88c10d2ff/libffi%2Fsrc%2Fpowerpc%2Fffi_powerpc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fffi_powerpc.h?ref=e73d2479dd03132a1147c013426ea8e88c10d2ff", "patch": "@@ -0,0 +1,77 @@\n+/* -----------------------------------------------------------------------\n+   ffi_powerpc.h - Copyright (C) 2013 IBM\n+                   Copyright (C) 2011 Anthony Green\n+                   Copyright (C) 2011 Kyle Moffett\n+                   Copyright (C) 2008 Red Hat, Inc\n+                   Copyright (C) 2007, 2008 Free Software Foundation, Inc\n+                   Copyright (c) 1998 Geoffrey Keating\n+\n+   PowerPC Foreign Function Interface\n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+   IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR\n+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+   OTHER DEALINGS IN THE SOFTWARE.\n+   ----------------------------------------------------------------------- */\n+\n+enum {\n+  /* The assembly depends on these exact flags.  */\n+  /* These go in cr7 */\n+  FLAG_RETURNS_SMST\t= 1 << (31-31), /* Used for FFI_SYSV small structs.  */\n+  FLAG_RETURNS_NOTHING  = 1 << (31-30),\n+  FLAG_RETURNS_FP       = 1 << (31-29),\n+  FLAG_RETURNS_64BITS   = 1 << (31-28),\n+\n+  /* This goes in cr6 */\n+  FLAG_RETURNS_128BITS  = 1 << (31-27),\n+\n+  FLAG_COMPAT\t\t= 1 << (31- 8), /* Not used by assembly */\n+\n+  /* These go in cr1 */\n+  FLAG_ARG_NEEDS_COPY   = 1 << (31- 7), /* Used by sysv code */\n+  FLAG_ARG_NEEDS_PSAVE  = FLAG_ARG_NEEDS_COPY, /* Used by linux64 code */\n+  FLAG_FP_ARGUMENTS     = 1 << (31- 6), /* cr1.eq; specified by ABI */\n+  FLAG_4_GPR_ARGUMENTS  = 1 << (31- 5),\n+  FLAG_RETVAL_REFERENCE = 1 << (31- 4)\n+};\n+\n+typedef union\n+{\n+  float f;\n+  double d;\n+} ffi_dblfl;\n+\n+void FFI_HIDDEN ffi_closure_SYSV (void);\n+void FFI_HIDDEN ffi_call_SYSV(extended_cif *, unsigned, unsigned, unsigned *,\n+\t\t\t      void (*)(void));\n+\n+void FFI_HIDDEN ffi_prep_types_sysv (ffi_abi);\n+ffi_status FFI_HIDDEN ffi_prep_cif_sysv (ffi_cif *);\n+int FFI_HIDDEN ffi_closure_helper_SYSV (ffi_closure *, void *, unsigned long *,\n+\t\t\t\t\tffi_dblfl *, unsigned long *);\n+\n+void FFI_HIDDEN ffi_call_LINUX64(extended_cif *, unsigned long, unsigned long,\n+\t\t\t\t unsigned long *, void (*)(void));\n+void FFI_HIDDEN ffi_closure_LINUX64 (void);\n+\n+void FFI_HIDDEN ffi_prep_types_linux64 (ffi_abi);\n+ffi_status FFI_HIDDEN ffi_prep_cif_linux64 (ffi_cif *);\n+ffi_status FFI_HIDDEN ffi_prep_cif_linux64_var (ffi_cif *, unsigned int,\n+\t\t\t\t\t\tunsigned int);\n+void FFI_HIDDEN ffi_prep_args64 (extended_cif *, unsigned long *const);\n+int FFI_HIDDEN ffi_closure_helper_LINUX64 (ffi_closure *, void *,\n+\t\t\t\t\t   unsigned long *, ffi_dblfl *);"}, {"sha": "fbe85fe91409c5982fa92ab65358d392bd3264ab", "filename": "libffi/src/powerpc/ffi_sysv.c", "status": "added", "additions": 931, "deletions": 0, "changes": 931, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d2479dd03132a1147c013426ea8e88c10d2ff/libffi%2Fsrc%2Fpowerpc%2Fffi_sysv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d2479dd03132a1147c013426ea8e88c10d2ff/libffi%2Fsrc%2Fpowerpc%2Fffi_sysv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fffi_sysv.c?ref=e73d2479dd03132a1147c013426ea8e88c10d2ff", "patch": "@@ -0,0 +1,931 @@\n+/* -----------------------------------------------------------------------\n+   ffi_sysv.c - Copyright (C) 2013 IBM\n+                Copyright (C) 2011 Anthony Green\n+                Copyright (C) 2011 Kyle Moffett\n+                Copyright (C) 2008 Red Hat, Inc\n+                Copyright (C) 2007, 2008 Free Software Foundation, Inc\n+                Copyright (c) 1998 Geoffrey Keating\n+\n+   PowerPC Foreign Function Interface\n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+   IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR\n+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+   OTHER DEALINGS IN THE SOFTWARE.\n+   ----------------------------------------------------------------------- */\n+\n+#include \"ffi.h\"\n+\n+#ifndef POWERPC64\n+#include \"ffi_common.h\"\n+#include \"ffi_powerpc.h\"\n+\n+\n+/* About the SYSV ABI.  */\n+#define ASM_NEEDS_REGISTERS 4\n+#define NUM_GPR_ARG_REGISTERS 8\n+#define NUM_FPR_ARG_REGISTERS 8\n+\n+\n+#if HAVE_LONG_DOUBLE_VARIANT && FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+/* Adjust size of ffi_type_longdouble.  */\n+void FFI_HIDDEN\n+ffi_prep_types_sysv (ffi_abi abi)\n+{\n+  if ((abi & (FFI_SYSV | FFI_SYSV_LONG_DOUBLE_128)) == FFI_SYSV)\n+    {\n+      ffi_type_longdouble.size = 8;\n+      ffi_type_longdouble.alignment = 8;\n+    }\n+  else\n+    {\n+      ffi_type_longdouble.size = 16;\n+      ffi_type_longdouble.alignment = 16;\n+    }\n+}\n+#endif\n+\n+/* Transform long double, double and float to other types as per abi.  */\n+static int\n+translate_float (int abi, int type)\n+{\n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+  if (type == FFI_TYPE_LONGDOUBLE\n+      && (abi & FFI_SYSV_LONG_DOUBLE_128) == 0)\n+    type = FFI_TYPE_DOUBLE;\n+#endif\n+  if ((abi & FFI_SYSV_SOFT_FLOAT) != 0)\n+    {\n+      if (type == FFI_TYPE_FLOAT)\n+\ttype = FFI_TYPE_UINT32;\n+      else if (type == FFI_TYPE_DOUBLE)\n+\ttype = FFI_TYPE_UINT64;\n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+      else if (type == FFI_TYPE_LONGDOUBLE)\n+\ttype = FFI_TYPE_UINT128;\n+    }\n+  else if ((abi & FFI_SYSV_IBM_LONG_DOUBLE) == 0)\n+    {\n+      if (type == FFI_TYPE_LONGDOUBLE)\n+\ttype = FFI_TYPE_STRUCT;\n+#endif\n+    }\n+  return type;\n+}\n+\n+/* Perform machine dependent cif processing */\n+static ffi_status\n+ffi_prep_cif_sysv_core (ffi_cif *cif)\n+{\n+  ffi_type **ptr;\n+  unsigned bytes;\n+  unsigned i, fparg_count = 0, intarg_count = 0;\n+  unsigned flags = cif->flags;\n+  unsigned struct_copy_size = 0;\n+  unsigned type = cif->rtype->type;\n+  unsigned size = cif->rtype->size;\n+\n+  /* The machine-independent calculation of cif->bytes doesn't work\n+     for us.  Redo the calculation.  */\n+\n+  /* Space for the frame pointer, callee's LR, and the asm's temp regs.  */\n+  bytes = (2 + ASM_NEEDS_REGISTERS) * sizeof (int);\n+\n+  /* Space for the GPR registers.  */\n+  bytes += NUM_GPR_ARG_REGISTERS * sizeof (int);\n+\n+  /* Return value handling.  The rules for SYSV are as follows:\n+     - 32-bit (or less) integer values are returned in gpr3;\n+     - Structures of size <= 4 bytes also returned in gpr3;\n+     - 64-bit integer values and structures between 5 and 8 bytes are returned\n+     in gpr3 and gpr4;\n+     - Larger structures are allocated space and a pointer is passed as\n+     the first argument.\n+     - Single/double FP values are returned in fpr1;\n+     - long doubles (if not equivalent to double) are returned in\n+     fpr1,fpr2 for Linux and as for large structs for SysV.  */\n+\n+  type = translate_float (cif->abi, type);\n+\n+  switch (type)\n+    {\n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+    case FFI_TYPE_LONGDOUBLE:\n+      flags |= FLAG_RETURNS_128BITS;\n+      /* Fall through.  */\n+#endif\n+    case FFI_TYPE_DOUBLE:\n+      flags |= FLAG_RETURNS_64BITS;\n+      /* Fall through.  */\n+    case FFI_TYPE_FLOAT:\n+      flags |= FLAG_RETURNS_FP;\n+#ifdef __NO_FPRS__\n+      return FFI_BAD_ABI;\n+#endif\n+      break;\n+\n+    case FFI_TYPE_UINT128:\n+      flags |= FLAG_RETURNS_128BITS;\n+      /* Fall through.  */\n+    case FFI_TYPE_UINT64:\n+    case FFI_TYPE_SINT64:\n+      flags |= FLAG_RETURNS_64BITS;\n+      break;\n+\n+    case FFI_TYPE_STRUCT:\n+      /* The final SYSV ABI says that structures smaller or equal 8 bytes\n+\t are returned in r3/r4.  A draft ABI used by linux instead\n+\t returns them in memory.  */\n+      if ((cif->abi & FFI_SYSV_STRUCT_RET) != 0 && size <= 8)\n+\t{\n+\t  flags |= FLAG_RETURNS_SMST;\n+\t  break;\n+\t}\n+      intarg_count++;\n+      flags |= FLAG_RETVAL_REFERENCE;\n+      /* Fall through.  */\n+    case FFI_TYPE_VOID:\n+      flags |= FLAG_RETURNS_NOTHING;\n+      break;\n+\n+    default:\n+      /* Returns 32-bit integer, or similar.  Nothing to do here.  */\n+      break;\n+    }\n+\n+  /* The first NUM_GPR_ARG_REGISTERS words of integer arguments, and the\n+     first NUM_FPR_ARG_REGISTERS fp arguments, go in registers; the rest\n+     goes on the stack.  Structures and long doubles (if not equivalent\n+     to double) are passed as a pointer to a copy of the structure.\n+     Stuff on the stack needs to keep proper alignment.  */\n+  for (ptr = cif->arg_types, i = cif->nargs; i > 0; i--, ptr++)\n+    {\n+      unsigned short typenum = (*ptr)->type;\n+\n+      typenum = translate_float (cif->abi, typenum);\n+\n+      switch (typenum)\n+\t{\n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+\tcase FFI_TYPE_LONGDOUBLE:\n+\t  fparg_count++;\n+\t  /* Fall thru */\n+#endif\n+\tcase FFI_TYPE_DOUBLE:\n+\t  fparg_count++;\n+\t  /* If this FP arg is going on the stack, it must be\n+\t     8-byte-aligned.  */\n+\t  if (fparg_count > NUM_FPR_ARG_REGISTERS\n+\t      && intarg_count >= NUM_GPR_ARG_REGISTERS\n+\t      && intarg_count % 2 != 0)\n+\t    intarg_count++;\n+#ifdef __NO_FPRS__\n+\t  return FFI_BAD_ABI;\n+#endif\n+\t  break;\n+\n+\tcase FFI_TYPE_FLOAT:\n+\t  fparg_count++;\n+#ifdef __NO_FPRS__\n+\t  return FFI_BAD_ABI;\n+#endif\n+\t  break;\n+\n+\tcase FFI_TYPE_UINT128:\n+\t  /* A long double in FFI_LINUX_SOFT_FLOAT can use only a set\n+\t     of four consecutive gprs. If we do not have enough, we\n+\t     have to adjust the intarg_count value.  */\n+\t  if (intarg_count >= NUM_GPR_ARG_REGISTERS - 3\n+\t      && intarg_count < NUM_GPR_ARG_REGISTERS)\n+\t    intarg_count = NUM_GPR_ARG_REGISTERS;\n+\t  intarg_count += 4;\n+\t  break;\n+\n+\tcase FFI_TYPE_UINT64:\n+\tcase FFI_TYPE_SINT64:\n+\t  /* 'long long' arguments are passed as two words, but\n+\t     either both words must fit in registers or both go\n+\t     on the stack.  If they go on the stack, they must\n+\t     be 8-byte-aligned.\n+\n+\t     Also, only certain register pairs can be used for\n+\t     passing long long int -- specifically (r3,r4), (r5,r6),\n+\t     (r7,r8), (r9,r10).  */\n+\t  if (intarg_count == NUM_GPR_ARG_REGISTERS-1\n+\t      || intarg_count % 2 != 0)\n+\t    intarg_count++;\n+\t  intarg_count += 2;\n+\t  break;\n+\n+\tcase FFI_TYPE_STRUCT:\n+\t  /* We must allocate space for a copy of these to enforce\n+\t     pass-by-value.  Pad the space up to a multiple of 16\n+\t     bytes (the maximum alignment required for anything under\n+\t     the SYSV ABI).  */\n+\t  struct_copy_size += ((*ptr)->size + 15) & ~0xF;\n+\t  /* Fall through (allocate space for the pointer).  */\n+\n+\tcase FFI_TYPE_POINTER:\n+\tcase FFI_TYPE_INT:\n+\tcase FFI_TYPE_UINT32:\n+\tcase FFI_TYPE_SINT32:\n+\tcase FFI_TYPE_UINT16:\n+\tcase FFI_TYPE_SINT16:\n+\tcase FFI_TYPE_UINT8:\n+\tcase FFI_TYPE_SINT8:\n+\t  /* Everything else is passed as a 4-byte word in a GPR, either\n+\t     the object itself or a pointer to it.  */\n+\t  intarg_count++;\n+\t  break;\n+\n+\tdefault:\n+\t  FFI_ASSERT (0);\n+\t}\n+    }\n+\n+  if (fparg_count != 0)\n+    flags |= FLAG_FP_ARGUMENTS;\n+  if (intarg_count > 4)\n+    flags |= FLAG_4_GPR_ARGUMENTS;\n+  if (struct_copy_size != 0)\n+    flags |= FLAG_ARG_NEEDS_COPY;\n+\n+  /* Space for the FPR registers, if needed.  */\n+  if (fparg_count != 0)\n+    bytes += NUM_FPR_ARG_REGISTERS * sizeof (double);\n+\n+  /* Stack space.  */\n+  if (intarg_count > NUM_GPR_ARG_REGISTERS)\n+    bytes += (intarg_count - NUM_GPR_ARG_REGISTERS) * sizeof (int);\n+  if (fparg_count > NUM_FPR_ARG_REGISTERS)\n+    bytes += (fparg_count - NUM_FPR_ARG_REGISTERS) * sizeof (double);\n+\n+  /* The stack space allocated needs to be a multiple of 16 bytes.  */\n+  bytes = (bytes + 15) & ~0xF;\n+\n+  /* Add in the space for the copied structures.  */\n+  bytes += struct_copy_size;\n+\n+  cif->flags = flags;\n+  cif->bytes = bytes;\n+\n+  return FFI_OK;\n+}\n+\n+ffi_status FFI_HIDDEN\n+ffi_prep_cif_sysv (ffi_cif *cif)\n+{\n+  if ((cif->abi & FFI_SYSV) == 0)\n+    {\n+      /* This call is from old code.  Translate to new ABI values.  */\n+      cif->flags |= FLAG_COMPAT;\n+      switch (cif->abi)\n+\t{\n+\tdefault:\n+\t  return FFI_BAD_ABI;\n+\n+\tcase FFI_COMPAT_SYSV:\n+\t  cif->abi = FFI_SYSV | FFI_SYSV_STRUCT_RET | FFI_SYSV_LONG_DOUBLE_128;\n+\t  break;\n+\n+\tcase FFI_COMPAT_GCC_SYSV:\n+\t  cif->abi = FFI_SYSV | FFI_SYSV_LONG_DOUBLE_128;\n+\t  break;\n+\n+\tcase FFI_COMPAT_LINUX:\n+\t  cif->abi = (FFI_SYSV | FFI_SYSV_IBM_LONG_DOUBLE\n+\t\t      | FFI_SYSV_LONG_DOUBLE_128);\n+\t  break;\n+\n+\tcase FFI_COMPAT_LINUX_SOFT_FLOAT:\n+\t  cif->abi = (FFI_SYSV | FFI_SYSV_SOFT_FLOAT | FFI_SYSV_IBM_LONG_DOUBLE\n+\t\t      | FFI_SYSV_LONG_DOUBLE_128);\n+\t  break;\n+\t}\n+    }\n+  return ffi_prep_cif_sysv_core (cif);\n+}\n+\n+/* ffi_prep_args_SYSV is called by the assembly routine once stack space\n+   has been allocated for the function's arguments.\n+\n+   The stack layout we want looks like this:\n+\n+   |   Return address from ffi_call_SYSV 4bytes\t|\thigher addresses\n+   |--------------------------------------------|\n+   |   Previous backchain pointer\t4\t|       stack pointer here\n+   |--------------------------------------------|<+ <<<\ton entry to\n+   |   Saved r28-r31\t\t\t4*4\t| |\tffi_call_SYSV\n+   |--------------------------------------------| |\n+   |   GPR registers r3-r10\t\t8*4\t| |\tffi_call_SYSV\n+   |--------------------------------------------| |\n+   |   FPR registers f1-f8 (optional)\t8*8\t| |\n+   |--------------------------------------------| |\tstack\t|\n+   |   Space for copied structures\t\t| |\tgrows\t|\n+   |--------------------------------------------| |\tdown    V\n+   |   Parameters that didn't fit in registers  | |\n+   |--------------------------------------------| |\tlower addresses\n+   |   Space for callee's LR\t\t4\t| |\n+   |--------------------------------------------| |\tstack pointer here\n+   |   Current backchain pointer\t4\t|-/\tduring\n+   |--------------------------------------------|   <<<\tffi_call_SYSV\n+\n+*/\n+\n+void FFI_HIDDEN\n+ffi_prep_args_SYSV (extended_cif *ecif, unsigned *const stack)\n+{\n+  const unsigned bytes = ecif->cif->bytes;\n+  const unsigned flags = ecif->cif->flags;\n+\n+  typedef union\n+  {\n+    char *c;\n+    unsigned *u;\n+    long long *ll;\n+    float *f;\n+    double *d;\n+  } valp;\n+\n+  /* 'stacktop' points at the previous backchain pointer.  */\n+  valp stacktop;\n+\n+  /* 'gpr_base' points at the space for gpr3, and grows upwards as\n+     we use GPR registers.  */\n+  valp gpr_base;\n+  int intarg_count;\n+\n+#ifndef __NO_FPRS__\n+  /* 'fpr_base' points at the space for fpr1, and grows upwards as\n+     we use FPR registers.  */\n+  valp fpr_base;\n+  int fparg_count;\n+#endif\n+\n+  /* 'copy_space' grows down as we put structures in it.  It should\n+     stay 16-byte aligned.  */\n+  valp copy_space;\n+\n+  /* 'next_arg' grows up as we put parameters in it.  */\n+  valp next_arg;\n+\n+  int i;\n+  ffi_type **ptr;\n+#ifndef __NO_FPRS__\n+  double double_tmp;\n+#endif\n+  union\n+  {\n+    void **v;\n+    char **c;\n+    signed char **sc;\n+    unsigned char **uc;\n+    signed short **ss;\n+    unsigned short **us;\n+    unsigned int **ui;\n+    long long **ll;\n+    float **f;\n+    double **d;\n+  } p_argv;\n+  size_t struct_copy_size;\n+  unsigned gprvalue;\n+\n+  stacktop.c = (char *) stack + bytes;\n+  gpr_base.u = stacktop.u - ASM_NEEDS_REGISTERS - NUM_GPR_ARG_REGISTERS;\n+  intarg_count = 0;\n+#ifndef __NO_FPRS__\n+  fpr_base.d = gpr_base.d - NUM_FPR_ARG_REGISTERS;\n+  fparg_count = 0;\n+  copy_space.c = ((flags & FLAG_FP_ARGUMENTS) ? fpr_base.c : gpr_base.c);\n+#else\n+  copy_space.c = gpr_base.c;\n+#endif\n+  next_arg.u = stack + 2;\n+\n+  /* Check that everything starts aligned properly.  */\n+  FFI_ASSERT (((unsigned long) (char *) stack & 0xF) == 0);\n+  FFI_ASSERT (((unsigned long) copy_space.c & 0xF) == 0);\n+  FFI_ASSERT (((unsigned long) stacktop.c & 0xF) == 0);\n+  FFI_ASSERT ((bytes & 0xF) == 0);\n+  FFI_ASSERT (copy_space.c >= next_arg.c);\n+\n+  /* Deal with return values that are actually pass-by-reference.  */\n+  if (flags & FLAG_RETVAL_REFERENCE)\n+    {\n+      *gpr_base.u++ = (unsigned long) (char *) ecif->rvalue;\n+      intarg_count++;\n+    }\n+\n+  /* Now for the arguments.  */\n+  p_argv.v = ecif->avalue;\n+  for (ptr = ecif->cif->arg_types, i = ecif->cif->nargs;\n+       i > 0;\n+       i--, ptr++, p_argv.v++)\n+    {\n+      unsigned int typenum = (*ptr)->type;\n+\n+      typenum = translate_float (ecif->cif->abi, typenum);\n+\n+      /* Now test the translated value */\n+      switch (typenum)\n+\t{\n+#ifndef __NO_FPRS__\n+# if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+\tcase FFI_TYPE_LONGDOUBLE:\n+\t  double_tmp = (*p_argv.d)[0];\n+\n+\t  if (fparg_count >= NUM_FPR_ARG_REGISTERS - 1)\n+\t    {\n+\t      if (intarg_count >= NUM_GPR_ARG_REGISTERS\n+\t\t  && intarg_count % 2 != 0)\n+\t\t{\n+\t\t  intarg_count++;\n+\t\t  next_arg.u++;\n+\t\t}\n+\t      *next_arg.d = double_tmp;\n+\t      next_arg.u += 2;\n+\t      double_tmp = (*p_argv.d)[1];\n+\t      *next_arg.d = double_tmp;\n+\t      next_arg.u += 2;\n+\t    }\n+\t  else\n+\t    {\n+\t      *fpr_base.d++ = double_tmp;\n+\t      double_tmp = (*p_argv.d)[1];\n+\t      *fpr_base.d++ = double_tmp;\n+\t    }\n+\n+\t  fparg_count += 2;\n+\t  FFI_ASSERT (flags & FLAG_FP_ARGUMENTS);\n+\t  break;\n+# endif\n+\tcase FFI_TYPE_DOUBLE:\n+\t  double_tmp = **p_argv.d;\n+\n+\t  if (fparg_count >= NUM_FPR_ARG_REGISTERS)\n+\t    {\n+\t      if (intarg_count >= NUM_GPR_ARG_REGISTERS\n+\t\t  && intarg_count % 2 != 0)\n+\t\t{\n+\t\t  intarg_count++;\n+\t\t  next_arg.u++;\n+\t\t}\n+\t      *next_arg.d = double_tmp;\n+\t      next_arg.u += 2;\n+\t    }\n+\t  else\n+\t    *fpr_base.d++ = double_tmp;\n+\t  fparg_count++;\n+\t  FFI_ASSERT (flags & FLAG_FP_ARGUMENTS);\n+\t  break;\n+\n+\tcase FFI_TYPE_FLOAT:\n+\t  double_tmp = **p_argv.f;\n+\t  if (fparg_count >= NUM_FPR_ARG_REGISTERS)\n+\t    {\n+\t      *next_arg.f = (float) double_tmp;\n+\t      next_arg.u += 1;\n+\t      intarg_count++;\n+\t    }\n+\t  else\n+\t    *fpr_base.d++ = double_tmp;\n+\t  fparg_count++;\n+\t  FFI_ASSERT (flags & FLAG_FP_ARGUMENTS);\n+\t  break;\n+#endif /* have FPRs */\n+\n+\tcase FFI_TYPE_UINT128:\n+\t  /* The soft float ABI for long doubles works like this, a long double\n+\t     is passed in four consecutive GPRs if available.  A maximum of 2\n+\t     long doubles can be passed in gprs.  If we do not have 4 GPRs\n+\t     left, the long double is passed on the stack, 4-byte aligned.  */\n+\t  {\n+\t    unsigned int int_tmp;\n+\t    unsigned int ii;\n+\t    if (intarg_count >= NUM_GPR_ARG_REGISTERS - 3)\n+\t      {\n+\t\tif (intarg_count < NUM_GPR_ARG_REGISTERS)\n+\t\t  intarg_count = NUM_GPR_ARG_REGISTERS;\n+\t\tfor (ii = 0; ii < 4; ii++)\n+\t\t  {\n+\t\t    int_tmp = (*p_argv.ui)[ii];\n+\t\t    *next_arg.u++ = int_tmp;\n+\t\t  }\n+\t      }\n+\t    else\n+\t      {\n+\t\tfor (ii = 0; ii < 4; ii++)\n+\t\t  {\n+\t\t    int_tmp = (*p_argv.ui)[ii];\n+\t\t    *gpr_base.u++ = int_tmp;\n+\t\t  }\n+\t      }\n+\t    intarg_count += 4;\n+\t    break;\n+\t  }\n+\n+\tcase FFI_TYPE_UINT64:\n+\tcase FFI_TYPE_SINT64:\n+\t  if (intarg_count == NUM_GPR_ARG_REGISTERS-1)\n+\t    intarg_count++;\n+\t  if (intarg_count >= NUM_GPR_ARG_REGISTERS)\n+\t    {\n+\t      if (intarg_count % 2 != 0)\n+\t\t{\n+\t\t  intarg_count++;\n+\t\t  next_arg.u++;\n+\t\t}\n+\t      *next_arg.ll = **p_argv.ll;\n+\t      next_arg.u += 2;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* The abi states only certain register pairs can be\n+\t\t used for passing long long int specifically (r3,r4),\n+\t\t (r5,r6), (r7,r8), (r9,r10).  If next arg is long long\n+\t\t but not correct starting register of pair then skip\n+\t\t until the proper starting register.  */\n+\t      if (intarg_count % 2 != 0)\n+\t\t{\n+\t\t  intarg_count ++;\n+\t\t  gpr_base.u++;\n+\t\t}\n+\t      *gpr_base.ll++ = **p_argv.ll;\n+\t    }\n+\t  intarg_count += 2;\n+\t  break;\n+\n+\tcase FFI_TYPE_STRUCT:\n+\t  struct_copy_size = ((*ptr)->size + 15) & ~0xF;\n+\t  copy_space.c -= struct_copy_size;\n+\t  memcpy (copy_space.c, *p_argv.c, (*ptr)->size);\n+\n+\t  gprvalue = (unsigned long) copy_space.c;\n+\n+\t  FFI_ASSERT (copy_space.c > next_arg.c);\n+\t  FFI_ASSERT (flags & FLAG_ARG_NEEDS_COPY);\n+\t  goto putgpr;\n+\n+\tcase FFI_TYPE_UINT8:\n+\t  gprvalue = **p_argv.uc;\n+\t  goto putgpr;\n+\tcase FFI_TYPE_SINT8:\n+\t  gprvalue = **p_argv.sc;\n+\t  goto putgpr;\n+\tcase FFI_TYPE_UINT16:\n+\t  gprvalue = **p_argv.us;\n+\t  goto putgpr;\n+\tcase FFI_TYPE_SINT16:\n+\t  gprvalue = **p_argv.ss;\n+\t  goto putgpr;\n+\n+\tcase FFI_TYPE_INT:\n+\tcase FFI_TYPE_UINT32:\n+\tcase FFI_TYPE_SINT32:\n+\tcase FFI_TYPE_POINTER:\n+\n+\t  gprvalue = **p_argv.ui;\n+\n+\tputgpr:\n+\t  if (intarg_count >= NUM_GPR_ARG_REGISTERS)\n+\t    *next_arg.u++ = gprvalue;\n+\t  else\n+\t    *gpr_base.u++ = gprvalue;\n+\t  intarg_count++;\n+\t  break;\n+\t}\n+    }\n+\n+  /* Check that we didn't overrun the stack...  */\n+  FFI_ASSERT (copy_space.c >= next_arg.c);\n+  FFI_ASSERT (gpr_base.u <= stacktop.u - ASM_NEEDS_REGISTERS);\n+  /* The assert below is testing that the number of integer arguments agrees\n+     with the number found in ffi_prep_cif_machdep().  However, intarg_count\n+     is incremented whenever we place an FP arg on the stack, so account for\n+     that before our assert test.  */\n+#ifndef __NO_FPRS__\n+  if (fparg_count > NUM_FPR_ARG_REGISTERS)\n+    intarg_count -= fparg_count - NUM_FPR_ARG_REGISTERS;\n+  FFI_ASSERT (fpr_base.u\n+\t      <= stacktop.u - ASM_NEEDS_REGISTERS - NUM_GPR_ARG_REGISTERS);\n+#endif\n+  FFI_ASSERT (flags & FLAG_4_GPR_ARGUMENTS || intarg_count <= 4);\n+}\n+\n+#define MIN_CACHE_LINE_SIZE 8\n+\n+static void\n+flush_icache (char *wraddr, char *xaddr, int size)\n+{\n+  int i;\n+  for (i = 0; i < size; i += MIN_CACHE_LINE_SIZE)\n+    __asm__ volatile (\"icbi 0,%0;\" \"dcbf 0,%1;\"\n+\t\t      : : \"r\" (xaddr + i), \"r\" (wraddr + i) : \"memory\");\n+  __asm__ volatile (\"icbi 0,%0;\" \"dcbf 0,%1;\" \"sync;\" \"isync;\"\n+\t\t    : : \"r\"(xaddr + size - 1), \"r\"(wraddr + size - 1)\n+\t\t    : \"memory\");\n+}\n+\n+ffi_status FFI_HIDDEN\n+ffi_prep_closure_loc_sysv (ffi_closure *closure,\n+\t\t\t   ffi_cif *cif,\n+\t\t\t   void (*fun) (ffi_cif *, void *, void **, void *),\n+\t\t\t   void *user_data,\n+\t\t\t   void *codeloc)\n+{\n+  unsigned int *tramp;\n+\n+  if (cif->abi < FFI_SYSV || cif->abi >= FFI_LAST_ABI)\n+    return FFI_BAD_ABI;\n+\n+  tramp = (unsigned int *) &closure->tramp[0];\n+  tramp[0] = 0x7c0802a6;  /*   mflr    r0 */\n+  tramp[1] = 0x4800000d;  /*   bl      10 <trampoline_initial+0x10> */\n+  tramp[4] = 0x7d6802a6;  /*   mflr    r11 */\n+  tramp[5] = 0x7c0803a6;  /*   mtlr    r0 */\n+  tramp[6] = 0x800b0000;  /*   lwz     r0,0(r11) */\n+  tramp[7] = 0x816b0004;  /*   lwz     r11,4(r11) */\n+  tramp[8] = 0x7c0903a6;  /*   mtctr   r0 */\n+  tramp[9] = 0x4e800420;  /*   bctr */\n+  *(void **) &tramp[2] = (void *) ffi_closure_SYSV; /* function */\n+  *(void **) &tramp[3] = codeloc;                   /* context */\n+\n+  /* Flush the icache.  */\n+  flush_icache ((char *)tramp, (char *)codeloc, FFI_TRAMPOLINE_SIZE);\n+\n+  closure->cif = cif;\n+  closure->fun = fun;\n+  closure->user_data = user_data;\n+\n+  return FFI_OK;\n+}\n+\n+/* Basically the trampoline invokes ffi_closure_SYSV, and on\n+   entry, r11 holds the address of the closure.\n+   After storing the registers that could possibly contain\n+   parameters to be passed into the stack frame and setting\n+   up space for a return value, ffi_closure_SYSV invokes the\n+   following helper function to do most of the work.  */\n+\n+int\n+ffi_closure_helper_SYSV (ffi_closure *closure, void *rvalue,\n+\t\t\t unsigned long *pgr, ffi_dblfl *pfr,\n+\t\t\t unsigned long *pst)\n+{\n+  /* rvalue is the pointer to space for return value in closure assembly */\n+  /* pgr is the pointer to where r3-r10 are stored in ffi_closure_SYSV */\n+  /* pfr is the pointer to where f1-f8 are stored in ffi_closure_SYSV  */\n+  /* pst is the pointer to outgoing parameter stack in original caller */\n+\n+  void **          avalue;\n+  ffi_type **      arg_types;\n+  long             i, avn;\n+#ifndef __NO_FPRS__\n+  long             nf = 0;   /* number of floating registers already used */\n+#endif\n+  long             ng = 0;   /* number of general registers already used */\n+\n+  ffi_cif *cif = closure->cif;\n+  unsigned       size     = cif->rtype->size;\n+  unsigned short rtypenum = cif->rtype->type;\n+\n+  avalue = alloca (cif->nargs * sizeof (void *));\n+\n+  /* First translate for softfloat/nonlinux */\n+  rtypenum = translate_float (cif->abi, rtypenum);\n+\n+  /* Copy the caller's structure return value address so that the closure\n+     returns the data directly to the caller.\n+     For FFI_SYSV the result is passed in r3/r4 if the struct size is less\n+     or equal 8 bytes.  */\n+  if (rtypenum == FFI_TYPE_STRUCT\n+      && !((cif->abi & FFI_SYSV_STRUCT_RET) != 0 && size <= 8))\n+    {\n+      rvalue = (void *) *pgr;\n+      ng++;\n+      pgr++;\n+    }\n+\n+  i = 0;\n+  avn = cif->nargs;\n+  arg_types = cif->arg_types;\n+\n+  /* Grab the addresses of the arguments from the stack frame.  */\n+  while (i < avn) {\n+    unsigned short typenum = arg_types[i]->type;\n+\n+    /* We may need to handle some values depending on ABI.  */\n+    typenum = translate_float (cif->abi, typenum);\n+\n+    switch (typenum)\n+      {\n+#ifndef __NO_FPRS__\n+      case FFI_TYPE_FLOAT:\n+\t/* Unfortunately float values are stored as doubles\n+\t   in the ffi_closure_SYSV code (since we don't check\n+\t   the type in that routine).  */\n+\tif (nf < NUM_FPR_ARG_REGISTERS)\n+\t  {\n+\t    /* FIXME? here we are really changing the values\n+\t       stored in the original calling routines outgoing\n+\t       parameter stack.  This is probably a really\n+\t       naughty thing to do but...  */\n+\t    double temp = pfr->d;\n+\t    pfr->f = (float) temp;\n+\t    avalue[i] = pfr;\n+\t    nf++;\n+\t    pfr++;\n+\t  }\n+\telse\n+\t  {\n+\t    avalue[i] = pst;\n+\t    pst += 1;\n+\t  }\n+\tbreak;\n+\n+      case FFI_TYPE_DOUBLE:\n+\tif (nf < NUM_FPR_ARG_REGISTERS)\n+\t  {\n+\t    avalue[i] = pfr;\n+\t    nf++;\n+\t    pfr++;\n+\t  }\n+\telse\n+\t  {\n+\t    if (((long) pst) & 4)\n+\t      pst++;\n+\t    avalue[i] = pst;\n+\t    pst += 2;\n+\t  }\n+\tbreak;\n+\n+# if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+      case FFI_TYPE_LONGDOUBLE:\n+\tif (nf < NUM_FPR_ARG_REGISTERS - 1)\n+\t  {\n+\t    avalue[i] = pfr;\n+\t    pfr += 2;\n+\t    nf += 2;\n+\t  }\n+\telse\n+\t  {\n+\t    if (((long) pst) & 4)\n+\t      pst++;\n+\t    avalue[i] = pst;\n+\t    pst += 4;\n+\t    nf = 8;\n+\t  }\n+\tbreak;\n+# endif\n+#endif\n+\n+      case FFI_TYPE_UINT128:\n+\t/* Test if for the whole long double, 4 gprs are available.\n+\t   otherwise the stuff ends up on the stack.  */\n+\tif (ng < NUM_GPR_ARG_REGISTERS - 3)\n+\t  {\n+\t    avalue[i] = pgr;\n+\t    pgr += 4;\n+\t    ng += 4;\n+\t  }\n+\telse\n+\t  {\n+\t    avalue[i] = pst;\n+\t    pst += 4;\n+\t    ng = 8+4;\n+\t  }\n+\tbreak;\n+\n+      case FFI_TYPE_SINT8:\n+      case FFI_TYPE_UINT8:\n+#ifndef __LITTLE_ENDIAN__\n+\tif (ng < NUM_GPR_ARG_REGISTERS)\n+\t  {\n+\t    avalue[i] = (char *) pgr + 3;\n+\t    ng++;\n+\t    pgr++;\n+\t  }\n+\telse\n+\t  {\n+\t    avalue[i] = (char *) pst + 3;\n+\t    pst++;\n+\t  }\n+\tbreak;\n+#endif\n+\n+      case FFI_TYPE_SINT16:\n+      case FFI_TYPE_UINT16:\n+#ifndef __LITTLE_ENDIAN__\n+\tif (ng < NUM_GPR_ARG_REGISTERS)\n+\t  {\n+\t    avalue[i] = (char *) pgr + 2;\n+\t    ng++;\n+\t    pgr++;\n+\t  }\n+\telse\n+\t  {\n+\t    avalue[i] = (char *) pst + 2;\n+\t    pst++;\n+\t  }\n+\tbreak;\n+#endif\n+\n+      case FFI_TYPE_SINT32:\n+      case FFI_TYPE_UINT32:\n+      case FFI_TYPE_POINTER:\n+\tif (ng < NUM_GPR_ARG_REGISTERS)\n+\t  {\n+\t    avalue[i] = pgr;\n+\t    ng++;\n+\t    pgr++;\n+\t  }\n+\telse\n+\t  {\n+\t    avalue[i] = pst;\n+\t    pst++;\n+\t  }\n+\tbreak;\n+\n+      case FFI_TYPE_STRUCT:\n+\t/* Structs are passed by reference. The address will appear in a\n+\t   gpr if it is one of the first 8 arguments.  */\n+\tif (ng < NUM_GPR_ARG_REGISTERS)\n+\t  {\n+\t    avalue[i] = (void *) *pgr;\n+\t    ng++;\n+\t    pgr++;\n+\t  }\n+\telse\n+\t  {\n+\t    avalue[i] = (void *) *pst;\n+\t    pst++;\n+\t  }\n+\tbreak;\n+\n+      case FFI_TYPE_SINT64:\n+      case FFI_TYPE_UINT64:\n+\t/* Passing long long ints are complex, they must\n+\t   be passed in suitable register pairs such as\n+\t   (r3,r4) or (r5,r6) or (r6,r7), or (r7,r8) or (r9,r10)\n+\t   and if the entire pair aren't available then the outgoing\n+\t   parameter stack is used for both but an alignment of 8\n+\t   must will be kept.  So we must either look in pgr\n+\t   or pst to find the correct address for this type\n+\t   of parameter.  */\n+\tif (ng < NUM_GPR_ARG_REGISTERS - 1)\n+\t  {\n+\t    if (ng & 1)\n+\t      {\n+\t\t/* skip r4, r6, r8 as starting points */\n+\t\tng++;\n+\t\tpgr++;\n+\t      }\n+\t    avalue[i] = pgr;\n+\t    ng += 2;\n+\t    pgr += 2;\n+\t  }\n+\telse\n+\t  {\n+\t    if (((long) pst) & 4)\n+\t      pst++;\n+\t    avalue[i] = pst;\n+\t    pst += 2;\n+\t    ng = NUM_GPR_ARG_REGISTERS;\n+\t  }\n+\tbreak;\n+\n+      default:\n+\tFFI_ASSERT (0);\n+      }\n+\n+    i++;\n+  }\n+\n+  (closure->fun) (cif, rvalue, avalue, closure->user_data);\n+\n+  /* Tell ffi_closure_SYSV how to perform return type promotions.\n+     Because the FFI_SYSV ABI returns the structures <= 8 bytes in\n+     r3/r4 we have to tell ffi_closure_SYSV how to treat them.  We\n+     combine the base type FFI_SYSV_TYPE_SMALL_STRUCT with the size of\n+     the struct less one.  We never have a struct with size zero.\n+     See the comment in ffitarget.h about ordering.  */\n+  if (rtypenum == FFI_TYPE_STRUCT\n+      && (cif->abi & FFI_SYSV_STRUCT_RET) != 0 && size <= 8)\n+    return FFI_SYSV_TYPE_SMALL_STRUCT - 1 + size;\n+  return rtypenum;\n+}\n+#endif"}, {"sha": "b47b0f5d3a2d7673536a7124d746ed95db0880a1", "filename": "libffi/src/powerpc/ffitarget.h", "status": "modified", "additions": 61, "deletions": 32, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d2479dd03132a1147c013426ea8e88c10d2ff/libffi%2Fsrc%2Fpowerpc%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d2479dd03132a1147c013426ea8e88c10d2ff/libffi%2Fsrc%2Fpowerpc%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fffitarget.h?ref=e73d2479dd03132a1147c013426ea8e88c10d2ff", "patch": "@@ -60,45 +60,76 @@ typedef signed long            ffi_sarg;\n typedef enum ffi_abi {\n   FFI_FIRST_ABI = 0,\n \n-#ifdef POWERPC\n-  FFI_SYSV,\n-  FFI_GCC_SYSV,\n-  FFI_LINUX64,\n-  FFI_LINUX,\n-  FFI_LINUX_SOFT_FLOAT,\n-# if defined(POWERPC64)\n-  FFI_DEFAULT_ABI = FFI_LINUX64,\n-# elif defined(__NO_FPRS__)\n-  FFI_DEFAULT_ABI = FFI_LINUX_SOFT_FLOAT,\n-# elif (__LDBL_MANT_DIG__ == 106)\n-  FFI_DEFAULT_ABI = FFI_LINUX,\n-# else\n-  FFI_DEFAULT_ABI = FFI_GCC_SYSV,\n-# endif\n-#endif\n-\n-#ifdef POWERPC_AIX\n+#if defined (POWERPC_AIX)\n   FFI_AIX,\n   FFI_DARWIN,\n   FFI_DEFAULT_ABI = FFI_AIX,\n-#endif\n+  FFI_LAST_ABI\n \n-#ifdef POWERPC_DARWIN\n+#elif defined (POWERPC_DARWIN)\n   FFI_AIX,\n   FFI_DARWIN,\n   FFI_DEFAULT_ABI = FFI_DARWIN,\n-#endif\n+  FFI_LAST_ABI\n \n-#ifdef POWERPC_FREEBSD\n-  FFI_SYSV,\n-  FFI_GCC_SYSV,\n-  FFI_LINUX64,\n-  FFI_LINUX,\n-  FFI_LINUX_SOFT_FLOAT,\n-  FFI_DEFAULT_ABI = FFI_SYSV,\n+#else\n+  /* The FFI_COMPAT values are used by old code.  Since libffi may be\n+     a shared library we have to support old values for backwards\n+     compatibility.  */\n+  FFI_COMPAT_SYSV,\n+  FFI_COMPAT_GCC_SYSV,\n+  FFI_COMPAT_LINUX64,\n+  FFI_COMPAT_LINUX,\n+  FFI_COMPAT_LINUX_SOFT_FLOAT,\n+\n+# if defined (POWERPC64)\n+  /* This bit, always set in new code, must not be set in any of the\n+     old FFI_COMPAT values that might be used for 64-bit linux.  We\n+     only need worry about FFI_COMPAT_LINUX64, but to be safe avoid\n+     all old values.  */\n+  FFI_LINUX = 8,\n+  /* This and following bits can reuse FFI_COMPAT values.  */\n+  FFI_LINUX_STRUCT_ALIGN = 1,\n+  FFI_LINUX_LONG_DOUBLE_128 = 2,\n+  FFI_DEFAULT_ABI = (FFI_LINUX\n+#  ifdef __STRUCT_PARM_ALIGN__\n+\t\t     | FFI_LINUX_STRUCT_ALIGN\n+#  endif\n+#  ifdef __LONG_DOUBLE_128__\n+\t\t     | FFI_LINUX_LONG_DOUBLE_128\n+#  endif\n+\t\t     ),\n+  FFI_LAST_ABI = 12\n+\n+# else\n+  /* This bit, always set in new code, must not be set in any of the\n+     old FFI_COMPAT values that might be used for 32-bit linux/sysv/bsd.  */\n+  FFI_SYSV = 8,\n+  /* This and following bits can reuse FFI_COMPAT values.  */\n+  FFI_SYSV_SOFT_FLOAT = 1,\n+  FFI_SYSV_STRUCT_RET = 2,\n+  FFI_SYSV_IBM_LONG_DOUBLE = 4,\n+  FFI_SYSV_LONG_DOUBLE_128 = 16,\n+\n+  FFI_DEFAULT_ABI = (FFI_SYSV\n+#  ifdef __NO_FPRS__\n+\t\t     | FFI_SYSV_SOFT_FLOAT\n+#  endif\n+#  if (defined (__SVR4_STRUCT_RETURN)\t\t\t\t\t\\\n+       || defined (POWERPC_FREEBSD) && !defined (__AIX_STRUCT_RETURN))\n+\t\t     | FFI_SYSV_STRUCT_RET\n+#  endif\n+#  if __LDBL_MANT_DIG__ == 106\n+\t\t     | FFI_SYSV_IBM_LONG_DOUBLE\n+#  endif\n+#  ifdef __LONG_DOUBLE_128__\n+\t\t     | FFI_SYSV_LONG_DOUBLE_128\n+#  endif\n+\t\t     ),\n+  FFI_LAST_ABI = 32\n+# endif\n #endif\n \n-  FFI_LAST_ABI\n } ffi_abi;\n #endif\n \n@@ -117,9 +148,7 @@ typedef enum ffi_abi {\n /* Needed for soft-float long-double-128 support.  */\n #define FFI_TYPE_UINT128 (FFI_TYPE_LAST + 1)\n \n-/* Needed for FFI_SYSV small structure returns.\n-   We use two flag bits, (FLAG_SYSV_SMST_R3, FLAG_SYSV_SMST_R4) which are\n-   defined in ffi.c, to determine the exact return type and its size.  */\n+/* Needed for FFI_SYSV small structure returns.  */\n #define FFI_SYSV_TYPE_SMALL_STRUCT (FFI_TYPE_LAST + 2)\n \n /* Used by ELFv2 for homogenous structure returns.  */"}, {"sha": "c4d01d8e3f7a77211af2b70c38bc0058e54cf3c4", "filename": "libffi/src/powerpc/linux64.S", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d2479dd03132a1147c013426ea8e88c10d2ff/libffi%2Fsrc%2Fpowerpc%2Flinux64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d2479dd03132a1147c013426ea8e88c10d2ff/libffi%2Fsrc%2Fpowerpc%2Flinux64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Flinux64.S?ref=e73d2479dd03132a1147c013426ea8e88c10d2ff", "patch": "@@ -29,7 +29,7 @@\n #include <fficonfig.h>\n #include <ffi.h>\n \n-#ifdef __powerpc64__\n+#ifdef POWERPC64\n \t.hidden\tffi_call_LINUX64\n \t.globl\tffi_call_LINUX64\n # if _CALL_ELF == 2"}, {"sha": "46a9ddfcd6b0129e9a17bf25b6934d25545fd008", "filename": "libffi/src/powerpc/linux64_closure.S", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d2479dd03132a1147c013426ea8e88c10d2ff/libffi%2Fsrc%2Fpowerpc%2Flinux64_closure.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d2479dd03132a1147c013426ea8e88c10d2ff/libffi%2Fsrc%2Fpowerpc%2Flinux64_closure.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Flinux64_closure.S?ref=e73d2479dd03132a1147c013426ea8e88c10d2ff", "patch": "@@ -30,7 +30,7 @@\n \n \t.file\t\"linux64_closure.S\"\n \n-#ifdef __powerpc64__\n+#ifdef POWERPC64\n \tFFI_HIDDEN (ffi_closure_LINUX64)\n \t.globl  ffi_closure_LINUX64\n # if _CALL_ELF == 2\n@@ -60,13 +60,11 @@ ffi_closure_LINUX64:\n # endif\n \n # if _CALL_ELF == 2\n-#  32 byte special reg save area + 64 byte parm save area and retval\n-#  + 13*8 fpr save area + round to 16\n-#  define STACKFRAME 208\n+#  32 byte special reg save area + 64 byte parm save area\n+#  + 64 byte retval area + 13*8 fpr save area + round to 16\n+#  define STACKFRAME 272\n #  define PARMSAVE 32\n-#  No parameter save area is needed for the call to ffi_closure_helper_LINUX64,\n-#  so return value can start there.\n-#  define RETVAL PARMSAVE\n+#  define RETVAL PARMSAVE+64\n # else\n #  48 bytes special reg save area + 64 bytes parm save area\n #  + 16 bytes retval area + 13*8 bytes fpr save area + round to 16\n@@ -85,8 +83,8 @@ ffi_closure_LINUX64:\n \tbt\t7, .Lparmsave\n \t# Our caller has not allocated a parameter save area.\n \t# We need to allocate one here and use it to pass gprs to\n-\t# ffi_closure_helper_LINUX64.  The return value area will do.\n-\taddi\t%r12, %r1, -STACKFRAME+RETVAL\n+\t# ffi_closure_helper_LINUX64.\n+\taddi\t%r12, %r1, -STACKFRAME+PARMSAVE\n .Lparmsave:\n \tstd\t%r0, 16(%r1)\n \t# Save general regs into parm save area"}, {"sha": "0507128501e3f5b18c3293be99e746cbc9f3ac96", "filename": "libffi/src/powerpc/ppc_closure.S", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d2479dd03132a1147c013426ea8e88c10d2ff/libffi%2Fsrc%2Fpowerpc%2Fppc_closure.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d2479dd03132a1147c013426ea8e88c10d2ff/libffi%2Fsrc%2Fpowerpc%2Fppc_closure.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fppc_closure.S?ref=e73d2479dd03132a1147c013426ea8e88c10d2ff", "patch": "@@ -31,7 +31,7 @@\n \n \t.file   \"ppc_closure.S\"\n \n-#ifndef __powerpc64__\n+#ifndef POWERPC64\n \n ENTRY(ffi_closure_SYSV)\n .LFB1:\n@@ -378,8 +378,7 @@ END(ffi_closure_SYSV)\n \t.align 2\n .LEFDE1:\n \n-#endif\n-\n #if defined __ELF__ && defined __linux__\n \t.section\t.note.GNU-stack,\"\",@progbits\n #endif\n+#endif"}, {"sha": "fed2380c9fac6635c9592582a93fa421ff51a998", "filename": "libffi/src/powerpc/sysv.S", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d2479dd03132a1147c013426ea8e88c10d2ff/libffi%2Fsrc%2Fpowerpc%2Fsysv.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d2479dd03132a1147c013426ea8e88c10d2ff/libffi%2Fsrc%2Fpowerpc%2Fsysv.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fsysv.S?ref=e73d2479dd03132a1147c013426ea8e88c10d2ff", "patch": "@@ -30,7 +30,7 @@\n #include <ffi.h>\n #include <powerpc/asm.h>\n \n-#ifndef __powerpc64__\n+#ifndef POWERPC64\n \t.globl ffi_prep_args_SYSV\n ENTRY(ffi_call_SYSV)\n .LFB1:\n@@ -213,8 +213,8 @@ END(ffi_call_SYSV)\n       .uleb128  0x1c\n       .align 2\n .LEFDE1:\n-#endif\n \n #if defined __ELF__ && defined __linux__\n \t.section\t.note.GNU-stack,\"\",@progbits\n #endif\n+#endif"}, {"sha": "866ed3471e319dc5cf90e8a21d1a5f96f2e9b2ff", "filename": "libffi/src/prep_cif.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d2479dd03132a1147c013426ea8e88c10d2ff/libffi%2Fsrc%2Fprep_cif.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d2479dd03132a1147c013426ea8e88c10d2ff/libffi%2Fsrc%2Fprep_cif.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fprep_cif.c?ref=e73d2479dd03132a1147c013426ea8e88c10d2ff", "patch": "@@ -126,6 +126,10 @@ ffi_status FFI_HIDDEN ffi_prep_cif_core(ffi_cif *cif, ffi_abi abi,\n \n   cif->flags = 0;\n \n+#if HAVE_LONG_DOUBLE_VARIANT\n+  ffi_prep_types (abi);\n+#endif\n+\n   /* Initialize the return type if necessary */\n   if ((cif->rtype->size == 0) && (initialize_aggregate(cif->rtype) != FFI_OK))\n     return FFI_BAD_TYPEDEF;"}, {"sha": "0de59942396c0d05923b81c6ecdb77f158057046", "filename": "libffi/src/types.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d2479dd03132a1147c013426ea8e88c10d2ff/libffi%2Fsrc%2Ftypes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d2479dd03132a1147c013426ea8e88c10d2ff/libffi%2Fsrc%2Ftypes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Ftypes.c?ref=e73d2479dd03132a1147c013426ea8e88c10d2ff", "patch": "@@ -44,6 +44,17 @@ const ffi_type ffi_type_##name = {\t\t\\\n   id, NULL\t\t\t\t\t\\\n }\n \n+#define FFI_NONCONST_TYPEDEF(name, type, id)\t\\\n+struct struct_align_##name {\t\t\t\\\n+  char c;\t\t\t\t\t\\\n+  type x;\t\t\t\t\t\\\n+};\t\t\t\t\t\t\\\n+ffi_type ffi_type_##name = {\t\t\t\\\n+  sizeof(type),\t\t\t\t\t\\\n+  offsetof(struct struct_align_##name, x),\t\\\n+  id, NULL\t\t\t\t\t\\\n+}\n+\n /* Size and alignment are fake here. They must not be 0. */\n const ffi_type ffi_type_void = {\n   1, 1, FFI_TYPE_VOID, NULL\n@@ -73,5 +84,9 @@ FFI_TYPEDEF(double, double, FFI_TYPE_DOUBLE);\n # endif\n const ffi_type ffi_type_longdouble = { 16, 16, 4, NULL };\n #elif FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+# if HAVE_LONG_DOUBLE_VARIANT\n+FFI_NONCONST_TYPEDEF(longdouble, long double, FFI_TYPE_LONGDOUBLE);\n+# else\n FFI_TYPEDEF(longdouble, long double, FFI_TYPE_LONGDOUBLE);\n+# endif\n #endif"}, {"sha": "540ab66d48c989e82082c6fe90d98103750413b6", "filename": "libffi/testsuite/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73d2479dd03132a1147c013426ea8e88c10d2ff/libffi%2Ftestsuite%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73d2479dd03132a1147c013426ea8e88c10d2ff/libffi%2Ftestsuite%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2FMakefile.in?ref=e73d2479dd03132a1147c013426ea8e88c10d2ff", "patch": "@@ -90,6 +90,7 @@ FFI_EXEC_TRAMPOLINE_TABLE = @FFI_EXEC_TRAMPOLINE_TABLE@\n FGREP = @FGREP@\n GREP = @GREP@\n HAVE_LONG_DOUBLE = @HAVE_LONG_DOUBLE@\n+HAVE_LONG_DOUBLE_VARIANT = @HAVE_LONG_DOUBLE_VARIANT@\n INSTALL = @INSTALL@\n INSTALL_DATA = @INSTALL_DATA@\n INSTALL_PROGRAM = @INSTALL_PROGRAM@"}]}