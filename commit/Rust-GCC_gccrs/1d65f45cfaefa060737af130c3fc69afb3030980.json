{"sha": "1d65f45cfaefa060737af130c3fc69afb3030980", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWQ2NWY0NWNmYWVmYTA2MDczN2FmMTMwYzNmYzY5YWZiMzAzMDk4MA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2009-09-14T19:18:58Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2009-09-14T19:18:58Z"}, "message": "Squash commit of EH in gimple\n\nFrom-SVN: r151696", "tree": {"sha": "2fcbbb5f99b13293753d83230cf9f4e0893a9b51", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2fcbbb5f99b13293753d83230cf9f4e0893a9b51"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1d65f45cfaefa060737af130c3fc69afb3030980", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d65f45cfaefa060737af130c3fc69afb3030980", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d65f45cfaefa060737af130c3fc69afb3030980", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d65f45cfaefa060737af130c3fc69afb3030980/comments", "author": null, "committer": null, "parents": [{"sha": "0c433c31b31f25e3f18e58bd8d404c02722d7f7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c433c31b31f25e3f18e58bd8d404c02722d7f7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c433c31b31f25e3f18e58bd8d404c02722d7f7c"}], "stats": {"total": 9453, "additions": 4565, "deletions": 4888}, "files": [{"sha": "cc048311c99e715cd36412c9cdef1374a913198f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 340, "deletions": 0, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -1,3 +1,343 @@\n+2009-09-14  Richard Henderson  <rth@redhat.com>\n+\n+\t* except.h: Update declarations.\n+\t(struct pointer_map_t): Forward declare.\n+\t(ERT_UNKNOWN, ERT_THROW, ERT_CATCH): Remove.\n+\t(struct eh_landing_pad_d, eh_landing_pad): New.\n+\t(struct eh_catch_d, eh_catch): New.\n+\t(struct eh_region_d): Remove next_region_sharing_label, aka,\n+\tlabel, tree_label, landing_pad, post_landing_pad, resume,\n+\tmay_contain_throw.  Rename region_number to index.  Remove\n+\tu.eh_catch, u.eh_throw.  Rename u.eh_try.eh_catch to first_catch.\n+\tAdd u.must_not_throw, landing_pads, exc_ptr_reg, filter_reg.\n+\t(VEC(eh_landing_pad,gc)): New.\n+\t(struct eh_status): Remove last_region_number.  Add lp_array,\n+\tthrow_stmt_table, ttype_data, ehspec_data.\n+\t(ehr_next, FOR_ALL_EH_REGION_AT): New.\n+\t(FOR_ALL_EH_REGION_FN, FOR_ALL_EH_REGION): New.\n+\t* except.c (lang_protect_cleanup_actions): Return tree.\n+\t(struct ehl_map_entry): Remove.\n+\t(init_eh_for_function): Push zero entries for region and lp_array.\n+\t(gen_eh_region): Add to region_array immediately.\n+\t(gen_eh_region_catch): Operate on eh_catch objects.\n+\t(gen_eh_landing_pad): New.\n+\t(get_eh_region_may_contain_throw, get_eh_region_tree_label): Remove.\n+\t(get_eh_region_no_tree_label, set_eh_region_tree_label): Remove.\n+\t(get_eh_region_from_number, get_eh_region_from_number_fn): New.\n+\t(get_eh_landing_pad_from_number_fn): New.\n+\t(get_eh_landing_pad_from_number): New.\n+\t(get_eh_region_from_lp_number_fn): New.\n+\t(get_eh_region_from_lp_number): New.\n+\t(expand_resx_stmt, note_eh_region_may_contain_throw): Remove.\n+\t(get_exception_pointer, get_exception_filter): Remove.\n+\t(collect_eh_region_array, can_be_reached_by_runtime): Remove.\n+\t(current_function_has_exception_handlers): Simplify.\n+\t(bring_to_root, eh_region_replaceable_by_p): Remove.\n+\t(replace_region, hash_type_list, hash_eh_region): Remove.\n+\t(eh_regions_equal_p, merge_peers, remove_unreachable_regions): Remove.\n+\t(label_to_region_map, num_eh_regions): Remove.\n+\t(get_next_region_sharing_label, must_not_throw_labels): Remove.\n+\t(find_exception_handler_labels): Remove.\n+\t(duplicate_eh_regions_0, find_prev_try): Remove.\n+\t(struct duplicate_eh_regions_data): New.\n+\t(duplicate_eh_regions_1): Rewrite.\n+\t(duplicate_eh_regions): Return a pointer map instead of an\n+\tinteger offset.\n+\t(copy_eh_region_1, copy_eh_region, push_reachable_handler): Remove.\n+\t(redirect_eh_edge_to_label): Remove.\n+\t(eh_region_outermost): Rewrite using eh_region pointers\n+\tinstead of integers.\n+\t(add_ttypes_entry): Update for ttype_data move to eh_status.\n+\t(add_ehspec_entry): Rewrite with VEC instead of varray.\n+\t(assign_filter_values): Likewise.  Export.\n+\t(build_post_landing_pads, connect_post_landing_pads): Remove.\n+\t(dw2_build_landing_pads): Rewrite to use lp_array.\n+\t(struct sjlj_lp_info, sjlj_find_directly_reachable_regions): Remove.\n+\t(sjlj_assign_call_site_values): Rewrite to use lp_array.\n+\t(sjlj_emit_dispatch_table, sjlj_build_landing_pads): Likewise.\n+\t(sjlj_mark_call_sites): Update for landing pad numbers.\n+\t(finish_eh_generation): Rewrite.\n+\t(gate_handle_eh): Do nothing for no eh tree.\n+\t(pass_rtl_eh): Move up near finish_eh_generation.\n+\t(remove_eh_landing_pad): New.\n+\t(remove_eh_handler): Export.\n+\t(remove_eh_region, remove_eh_handler_and_replace): Remove.\n+\t(for_each_eh_label): Rewrite to use lp_array.\n+\t(make_reg_eh_region_note): New.\n+\t(make_reg_eh_region_note_nothrow_nononlocal): New.\n+\t(insn_could_throw_p): New.\n+\t(copy_reg_eh_region_note_forward): New.\n+\t(copy_reg_eh_region_note_backward): New.\n+\t(check_handled, add_reachable_handler): Remove.\n+\t(reachable_next_level, foreach_reachable_handler): Remove.\n+\t(arh_to_landing_pad, arh_to_label, reachable_handlers): Remove.\n+\t(get_eh_region_and_lp_from_rtx): New.\n+\t(get_eh_region_from_rtx): New.\n+\t(can_throw_internal_1, can_throw_external_1): Remove.\n+\t(can_throw_internal): Use get_eh_region_from_rtx.\n+\t(can_throw_external): Use get_eh_region_and_lp_from_rtx.\n+\t(insn_nothrow_p, can_nonlocal_goto): New.\n+\t(expand_builtin_eh_common, expand_builtin_eh_pointer): New.\n+\t(expand_builtin_eh_filter, expand_builtin_eh_copy_values): New.\n+\t(add_action_record): Use VEC not varray.\n+\t(collect_one_action_chain): Update for eh_region changes.\n+\t(convert_to_eh_region_ranges): Make static.  Use VEC not varray.\n+\tUse get_eh_region_and_lp_from_rtx.\n+\t(gate_convert_to_eh_region_ranges): New.\n+\t(pass_convert_to_eh_region_ranges): Use it.\n+\t(push_uleb128, push_sleb128): Use VEC not varray.\n+\t(output_one_function_exception_table): Likewise.\n+\t(dump_eh_tree): Update for eh_region changes.\n+\t(verify_eh_tree): Likewise.\n+\t(verify_eh_region, default_init_unwind_resume_libfunc): Remove.\n+\t* tree-eh.c: Include target.h.\n+\t(add_stmt_to_eh_lp_fn): Rename from add_stmt_to_eh_region_fn.\n+\tDon't disallow GIMPLE_RESX; adjust argument check.\n+\t(add_stmt_to_eh_lp): Rename from add_stmt_to_eh_region.\n+\t(record_stmt_eh_region): Update for landing pad numbers;\n+\tgenerate a landing pad if necessary.\n+\t(remove_stmt_from_eh_lp): Rename from remove_stmt_from_eh_region.\n+\t(remove_stmt_from_eh_lp_fn): Similarly.\n+\t(lookup_stmt_eh_lp_fn): Rename from lookup_stmt_eh_region_fn.\n+\tUpdate for lp numbers; don't special case missing throw_stmt_table.\n+\t(lookup_expr_eh_lp): Similarly.\n+\t(lookup_stmt_eh_lp): Rename from lookup_stmt_eh_region.\n+\t(eh_seq, eh_region_may_contain_throw): New.\n+\t(struct leh_state): Add ehp_region.\n+\t(struct leh_tf_state): Remove eh_label.\n+\t(emit_post_landing_pad): New.\n+\t(emit_resx, emit_eh_dispatch): New.\n+\t(note_eh_region_may_contain_throw): New.\n+\t(frob_into_branch_around): Take eh_region not eh label;\n+\temit eh code into eh_seq.\n+\t(honor_protect_cleanup_actions): Early exit for no actions.  Don't\n+\thandle EXC_PTR_EXPR, FILTER_EXPR.  Use gimple_build_eh_must_not_throw,\n+\tlower_eh_must_not_throw.  Emit code to eh_seq.\n+\t(lower_try_finally_nofallthru): Emit eh code to eh_seq.\n+\t(lower_try_finally_onedest): Likewise.\n+\t(lower_try_finally_copy): Likewise.\n+\t(lower_try_finally_switch): Likewise.\n+\t(lower_try_finally): Initialize ehp_region.\n+\t(lower_catch): Update for eh_catch objects.\n+\t(lower_eh_filter): Don't handle must_not_throw.\n+\t(lower_eh_must_not_throw): New.\n+\t(lower_cleanup): Don't set eh_label.\n+\t(lower_eh_constructs_2): Resolve eh builtins.\n+\tHandle GIMPLE_EH_MUST_NOT_THROW.\n+\t(lower_eh_constructs): Initialize eh_region_may_contain_throw.\n+\tAdd eh_seq to the end of the function body.\n+\t(make_eh_dispatch_edges): New.\n+\t(make_eh_edge): Remove.\n+\t(make_eh_edges): Simplify for landing pads.\n+\t(redirect_eh_edge_1): New.\n+\t(redirect_eh_edge): Use it.\n+\t(redirect_eh_dispatch_edge): New.\n+\t(stmt_could_throw_p): Use a switch.  Allow RESX.\n+\t(stmt_can_throw_external): Use lookup_stmt_eh_lp.\n+\t(stmt_can_throw_internal): Likewise.\n+\t(maybe_clean_eh_stmt_fn, maybe_clean_eh_stmt): New.\n+\t(maybe_clean_or_replace_eh_stmt): Update for landing pads.\n+\t(maybe_duplicate_eh_stmt_fn, maybe_duplicate_eh_stmt): New.\n+\t(gate_refactor_eh): New.\n+\t(pass_refactor_eh): Use it.\n+\t(lower_resx, execute_lower_resx, pass_lower_resx): New.\n+\t(lower_eh_dispatch, execute_lower_eh_dispatch): New.\n+\t(gate_lower_ehcontrol, pass_lower_eh_dispatch): New.\n+\t(remove_unreachable_handlers): Rename from\n+\ttree_remove_unreachable_handlers; rewrite for landing pads;\n+\tcall remove_eh_handler directly.\n+\t(remove_unreachable_handlers_no_lp): New.\n+\t(unsplit_eh, unsplit_all_eh): New.\n+\t(tree_empty_eh_handler_p, all_phis_safe_to_merge): Remove.\n+\t(cleanup_empty_eh_merge_phis, cleanup_empty_eh_move_lp): New.\n+\t(cleanup_empty_eh_unsplit): New.\n+\t(cleanup_empty_eh): Rewrite.\n+\t(cleanup_all_empty_eh): New.\n+\t(execute_cleanup_eh): Rename from cleanup_eh.  Remove unreachable\n+\thandlers first.  Use unsplit_all_eh, cleanup_all_empty_eh.\n+\t(gate_cleanup_eh): New.\n+\t(pass_cleanup_eh): Use it.\n+\t(verify_eh_edges): Move later in file.  Expect one EH edge.\n+\t(verify_eh_dispatch_edge): New.\n+\n+\t* Makefile.in (FUNCTION_H): Use vecprim.h, not varray.h.\n+\t(gtype-desc.o): Add TARGET_H.\n+\t(tree.o): Use EXCEPT_H, not except.h.\n+\t(cfgbuild.o): Add EXPR_H.\n+\t(GTFILES): Add vecprim.h.\n+\t* builtins.c (expand_builtin): Handle BUILT_IN_EH_POINTER,\n+\tBUILT_IN_EH_FILTER, BUILT_IN_EH_COPY_VALUES.\n+\t* builtins.def (BUILT_IN_UNWIND_RESUME, BUILT_IN_EH_POINTER,\n+\tBUILT_IN_EH_FILTER, BUILT_IN_EH_COPY_VALUES): New.\n+\t* calls.c (emit_call_1): Use make_reg_eh_region_note.\n+\t* cfgbuild.c (control_flow_insn_p): Use can_nonlocal_goto; tidy\n+\tcalls to can_throw_internal.\n+\t(rtl_make_eh_edge): Use get_eh_landing_pad_from_rtx.\n+\t(make_edges): Don't handle RESX; use can_nonlocal_goto.\n+\t* cfgexpand.c (expand_gimple_stmt_1): Don't handle RESX.\n+\t(expand_gimple_stmt): Use make_reg_eh_region_note.\n+\t(expand_debug_expr): Don't handle EXC_PTR_EXPR and FILTER_EXPR.\n+\t(gimple_expand_cfg): Don't call convert_from_eh_region_ranges,\n+\tor find_exception_handler_labels.\n+\t* cfgrtl.c (rtl_verify_flow_info_1): Don't handle RESX.  Assert\n+\tthere is exacly one EH edge.  Use can_nonlocal_goto and\n+\tcan_throw_internal.\n+\t* cgraphunit.c (update_call_expr): Use maybe_clean_eh_stmt_fn.\n+\t(cgraph_materialize_all_clones): Use maybe_clean_or_replace_eh_stmt.\n+\t* combine.c (can_combine_p, try_combine): Use insn_nothrow_p.\n+\t* cse.c (count_reg_usage, insn_live_p): Use insn_could_throw_p.\n+\t* dce.c (deletable_insn_p_1): Don't test may_trap_p.\n+\t(deletable_insn_p): Use insn_nothrow_p; reorder nonjump insn test.\n+\t* dse.c (scan_insn): Use insn_could_throw_p.\n+\t* emit-rtl.c (try_split): Use copy_reg_eh_region_note_backward.\n+\t* expr.c (expand_expr_real): Use make_reg_eh_region_note.\n+\t(expand_expr_real_1): Don't handle RESX, EXC_PTR, or FILTER_EXPR.\n+\t* fold-const.c (tree_expr_nonnegative_warnv_p): Don't handle\n+\tEXC_PTR_EXPR or FILTER_EXPR.\n+\t(tree_expr_nonzero_warnv_p): Likewise.\n+\t* function.h: Include vecprim.h, not varray.h\n+\t(struct rtl_eh): Remove filter, exc_ptr, built_landing_pad members;\n+\tmove ttype_data and ehspec_data members to struct eh_status; change\n+\taction_record_data member to a VEC.\n+\t* gcse.c (hash_scan_set): Use can_throw_internal.\n+\t* gengtype.c (open_base_files): Add target.h to gtype-desc.c.\n+\t* gimple-iterator.c (gsi_replace): Use maybe_clean_or_replace_eh_stmt.\n+\t* gimple-low.c (lower_stmt): Handle GIMPLE_EH_MUST_NOT_THROW.\n+\t(block_may_fallthru): Don't handle RESX_EXPR.\n+\t* gimple-pretty-print.c (dump_gimple_label): Dump EH_LANDING_PAD_NR.\n+\t(dump_gimple_eh_must_not_throw, dump_gimple_eh_dispatch): New.\n+\t(dump_gimple_stmt): Dump landing pad information with TDF_EH;\n+\thandle GIMPLE_EH_MUST_NOT_THROW, GIMPLE_EH_DISPATCH.\n+\t* gimple.c (gss_for_code): Handle GIMPLE_EH_MUST_NOT_THROW,\n+\tGIMPLE_EH_DISPATCH, GIMPLE_RESX.\n+\t(gimple_size): Likewise.\n+\t(gimple_build_eh_dispatch, gimple_build_eh_must_not_throw): New.\n+\t(gimple_build_resx): Use gimple_build_with_ops.\n+\t(DEFTREECODE): Don't handle EXC_PTR_EXPR, FILTER_EXPR.\n+\t(is_gimple_val): Likewise.\n+\t(is_gimple_stmt): Remove RESX_EXPR.\n+\t* gimple.def (GIMPLE_EH_MUST_NOT_THROW, GIMPLE_EH_DISPATCH): New.\n+\t(GIMPLE_RESX): Reorder with other EH constructs.\n+\t* gimple.h (struct gimple_statement_eh_mnt): New.\n+\t(struct gimple_statement_eh_ctrl): Rename from gimple_statement_resx.\n+\t(gimple_eh_filter_must_not_throw): Remove.\n+\t(gimple_eh_filter_set_must_not_throw): Remove.\n+\t(gimple_eh_must_not_throw_fndecl): New.\n+\t(gimple_eh_dispatch_region, gimple_eh_dispatch_set_region): New.\n+\t(is_gimple_resx): New.\n+\t* gimplify.c (gimplify_expr): Don't handle EXC_PTR_EXPR, RESX_EXPR.\n+\tDon't copy EH_FILTER_MUST_NOT_THROW.\n+\t* gsstruct.def (GSS_EH_MNT, GSS_EHCONTROL): New.\n+\t* ipa-inline.c (estimate_function_body_sizes): Don't try to\n+\thandle must_not_throw_labels specially.\n+\t* ipa-pure-const.c (check_call): Update debug statement for LP.\n+\t* ipa-type-escape.c (check_operand): Don't handle EXC_PTR or FILTER.\n+\t* ipa-utils.c (get_base_var): Likewise.\n+\t* libfunc.h (LTI_unwind_resume, unwind_resume_libfunc): Remove.\n+\t* lower-subreg.c (move_eh_region_note): Remove.\n+\t(resolve_simple_move): Use copy_reg_eh_region_note_forward.\n+\t* omp-low.c (new_omp_context): Update for eh_lp_nr.\n+\t(create_task_copyfn): Likewise.\n+\t(maybe_catch_exception): Use gimple_build_eh_filter.\n+\t* optabs.c (emit_libcall_block): Update test for no-nonlocal-goto\n+\tREG_EH_REGION.  Use make_reg_eh_region_note_nothrow_nononlocal.\n+\t* passes.c (init_optimization_passes): Add pass_lower_eh_dispatch\n+\tand pass_lower_resx.\n+\t* print-tree.c (print_node): Dump EH_LANDING_PAD_NR.\n+\t* recog.c (peephole2_optimize): Use copy_reg_eh_region_note_backward,\n+\tcan_throw_internal, can_nonlocal_goto.\n+\t* reload1.c (fixup_eh_region_note): Use insn_could_throw_p,\n+\tcopy_reg_eh_region_note_forward.\n+\t(emit_input_reload_insns): Use copy_reg_eh_region_note_forward.\n+\t(emit_output_reload_insns): Likewise.\n+\t(copy_eh_notes): Remove.\n+\t* rtl.def (RESX): Remove.\n+\t* rtl.h: Update declarations.\n+\t* sese.c (graphite_copy_stmts_from_block): Use maybe_duplicate_eh_stmt.\n+\t* tree-cfg.c (make_edges): Handle GIMPLE_EH_DISPATCH.\n+\t(update_eh_label): Remove.\n+\t(cleanup_dead_labels_eh): New.\n+\t(cleanup_deal_labels): Use it instead of update_eh_label.\n+\t(gimple_merge_blocks): Update landing pad data structure when\n+\tremoving a landing pad label.\n+\t(remove_useless_stmts_tc): Remove gimple_eh_filter_must_not_throw\n+\ttest; handle GIMPLE_EH_MUST_NOT_THROW.\n+\t(is_ctrl_altering_stmt): Handle GIMPLE_EH_DISPATCH.\n+\t(verify_gimple_assign_single): Don't handle EXC_PTR or FILTER_EXPR.\n+\t(verify_types_in_gimple_stmt): Handle GIMPLE_EH_DISPATCH.\n+\t(verify_stmt): Likewise.  Verify landing pads.\n+\t(gimple_redirect_edge_and_branch): Handle GIMPLE_EH_DISPATCH.\n+\t(gimple_duplicate_bb): Use maybe_duplicate_eh_stmt.\n+\t(struct move_stmt_d): Add eh_map.\n+\t(move_stmt_eh_region_nr, move_stmt_eh_region_tree_nr): New.\n+\t(move_stmt_r): Remap eh region numbers in builtin calls,\n+\tresx and eh_dispatch.\n+\t(move_block_to_fn): Remove eh_offset parameter.  Use\n+\tmaybe_duplicate_eh_stmt_fn.\n+\t(find_outermost_region_in_block): Operate on eh_region pointers\n+\tinstead of region numbers.\n+\t(move_sese_region_to_fn): Expect eh_map instead of eh_offset from\n+\tduplicate_eh_regions.\n+\t* tree-cfgcleanup.c (tree_forwarder_block_p): Move entry block edge\n+\ttest earlier.  Disallow EH landing pads.\n+\t* tree-cfa.c (create_tree_common_ann): Don't set ann->rn.\n+\t* tree-flow.h: Update declarations.\n+\t(struct tree_ann_common_d): Replace rn with lp_nr.\n+\t* tree-inline.c (copy_tree_body_r): Don't handle RESX_EXPR.\n+\t(remap_eh_region_nr, remap_eh_region_tree_nr): New.\n+\t(remap_gimple_stmt): Remap eh region numbers in builtin calls,\n+\tresx and eh_dispatch.\n+\t(copy_bb): Use maybe_duplicate_eh_stmt_fn.\n+\t(copy_edges_for_bb): Use make_eh_dispatch_edges.\n+\t(copy_cfg_body): Expect eh_map instead of eh_region_offset\n+\tfrom duplicate_eh_regions.\n+\t(estimate_num_insns): Don't handle EXC_PTR_EXPR or FILTER_EXPR;\n+\tupdate RESX; handle EH_DISPATCH.\n+\t(expand_call_inline): Set eh_lp_nr, not eh_region.\n+\t(maybe_inline_call_in_expr): Likewise.\n+\t* tree-inline.h (struct copy_body_data): Replace eh_region with\n+\teh_lp_nr, eh_region_offset with eh_map.\n+\t* tree-optimize.c (execute_fixup_cfg): Use maybe_clean_eh_stmt.\n+\t* tree-pass.h (pass_lower_eh_dispatch, pass_lower_resx): New.\n+\t* tree-pretty-print.c (dump_generic_node): Don't handle\n+\tEXC_PTR_EXPR, FILTER_EXPR, RESX_EXPR.\n+\t* tree-sra.c (scan_function): Use maybe_clean_eh_stmt.\n+\t* tree-ssa-alias.c (ref_maybe_used_by_call_p_1): Don't handle\n+\tEXC_PTR_EXPR, FILTER_EXPR.\n+\t* tree-ssa-operands.c (get_expr_operands): Likewise.\n+\t* tree-ssa-propagate.c (valid_gimple_rhs_p): Likewise.\n+\t* tree-ssa-sccvn.c (copy_reference_ops_from_ref): Likewise.\n+\t(ao_ref_init_from_vn_reference): Likewise.\n+\t* tree-ssa-sink.c (statement_sink_location): Likewise.\n+\t* tree-ssa-dce.c (mark_stmt_if_obviously_necessary): Likewise.\n+\t(mark_virtual_phi_result_for_renaming): Export.  Tidy.\n+\t* tree-ssa-pre.c (get_or_alloc_expr_for): Don't handle\n+\tEXC_PTR_EXPR, FILTER_EXPR.\n+\t(is_exception_related): Remove.\n+\t(compute_avail): Don't call it.\n+\t* tree-ssa-structalias.c: Remove VEC definitions for int and unsigned.\n+\t* tree.c (find_decls_types_in_eh_region): Update for eh_region changes.\n+\t(find_decls_types_in_node): Use FOR_ALL_EH_REGION_FN.\n+\t(build_common_builtin_nodes): Add enable_cxa_end_cleanup parameter.\n+\tBuild EH builtins.\n+\t(build_resx): Remove.\n+\t* tree.def (EXC_PTR_EXPR, FILTER_EXPR, RESX_EXPR): Remove.\n+\t* tree.h: Update declarations.\n+\t(EH_FILTER_MUST_NOT_THROW): Remove.\n+\t(struct tree_label_decl): Add eh_landing_pad_nr.\n+\t(EH_LANDING_PAD_NR): New.\n+\t* value-prof.c (gimple_ic): Tidy variable names.  Update for\n+\tlanding pad numbers.\n+\t(gimple_stringop_fixed_value): Tidy variable names.  Assert\n+\tthat neither call stmt can throw.\n+\t* vecprim.h (uchar): New.\n+\t(VEC(uchar,heap), VEC(uchar,gc)): New.\n+\n+\t* c-common.c (c_define_builtins): Update call to\n+\tbuild_common_builtin_nodes.\n+\t* c-parser.c (c_parse_file): Don't call\n+\tdefault_init_unwind_resume_libfunc.\n+\n 2009-09-14  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* config/mips/mips-protos.h (mips_cfun_has_cprestore_slot_p): Declare."}, {"sha": "2e406b6c63af2b772ded7ee64316b1bbf27c467d", "filename": "gcc/Makefile.in", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -856,7 +856,7 @@ RECOG_H = recog.h\n ALIAS_H = alias.h coretypes.h\n EMIT_RTL_H = emit-rtl.h\n FLAGS_H = flags.h options.h\n-FUNCTION_H = function.h $(TREE_H) $(HASHTAB_H) varray.h\n+FUNCTION_H = function.h $(TREE_H) $(HASHTAB_H) vecprim.h\n EXPR_H = expr.h insn-config.h $(FUNCTION_H) $(RTL_H) $(FLAGS_H) $(TREE_H) $(MACHMODE_H) $(EMIT_RTL_H)\n OPTABS_H = optabs.h insn-codes.h\n REGS_H = regs.h varray.h $(MACHMODE_H) $(OBSTACK_H) $(BASIC_BLOCK_H) $(FUNCTION_H)\n@@ -2127,7 +2127,7 @@ gtype-desc.o: gtype-desc.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n \thard-reg-set.h $(BASIC_BLOCK_H) cselib.h $(INSN_ADDR_H) $(OPTABS_H) \\\n \tlibfuncs.h debug.h $(GGC_H) $(CGRAPH_H) $(TREE_FLOW_H) reload.h \\\n \t$(CPP_ID_DATA_H) tree-chrec.h $(CFGLAYOUT_H) $(EXCEPT_H) output.h \\\n-\t$(CFGLOOP_H)\n+\t$(CFGLOOP_H) $(TARGET_H)\n \n ggc-common.o: ggc-common.c $(CONFIG_H) $(SYSTEM_H) coretypes.h\t\t\\\n \t$(GGC_H) $(HASHTAB_H) $(TOPLEV_H) $(PARAMS_H) hosthooks.h\t\\\n@@ -2163,10 +2163,11 @@ langhooks.o : langhooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    intl.h $(GIMPLE_H)\n tree.o : tree.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    all-tree.def $(FLAGS_H) $(FUNCTION_H) $(PARAMS_H) \\\n-   $(TOPLEV_H) $(GGC_H) $(HASHTAB_H) $(TARGET_H) output.h $(TM_P_H) langhooks.h \\\n-   $(REAL_H) gt-tree.h $(TREE_INLINE_H) tree-iterator.h $(BASIC_BLOCK_H) \\\n-   $(TREE_FLOW_H) $(OBSTACK_H) pointer-set.h fixed-value.h tree-pass.h \\\n-   langhooks-def.h $(DIAGNOSTIC_H) $(CGRAPH_H) $(TIMEVAR_H) except.h debug.h\n+   $(TOPLEV_H) $(GGC_H) $(HASHTAB_H) $(TARGET_H) output.h $(TM_P_H) \\\n+   langhooks.h $(REAL_H) gt-tree.h $(TREE_INLINE_H) tree-iterator.h \\\n+   $(BASIC_BLOCK_H) $(TREE_FLOW_H) $(OBSTACK_H) pointer-set.h fixed-value.h \\\n+   tree-pass.h langhooks-def.h $(DIAGNOSTIC_H) $(CGRAPH_H) $(TIMEVAR_H) \\\n+   $(EXCEPT_H) debug.h\n tree-dump.o: tree-dump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) langhooks.h $(TOPLEV_H) $(SPLAY_TREE_H) $(TREE_DUMP_H) \\\n    tree-iterator.h $(TREE_PASS_H) $(DIAGNOSTIC_H) $(REAL_H) fixed-value.h\n@@ -2972,7 +2973,7 @@ cfganal.o : cfganal.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TIMEVAR_H) $(OBSTACK_H) $(TOPLEV_H) vecprim.h\n cfgbuild.o : cfgbuild.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(FLAGS_H) $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h $(TOPLEV_H) \\\n-   $(FUNCTION_H) $(EXCEPT_H) $(TIMEVAR_H) $(TREE_H)\n+   $(FUNCTION_H) $(EXCEPT_H) $(TIMEVAR_H) $(TREE_H) $(EXPR_H)\n cfgcleanup.o : cfgcleanup.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(TIMEVAR_H) hard-reg-set.h output.h $(FLAGS_H) $(RECOG_H) \\\n    $(TOPLEV_H) insn-config.h cselib.h $(TARGET_H) $(TM_P_H) $(PARAMS_H) \\\n@@ -3460,6 +3461,7 @@ GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(host_xm_file_list) \\\n   $(tm_file_list) $(HASHTAB_H) $(SPLAY_TREE_H) $(srcdir)/bitmap.h \\\n   $(srcdir)/alias.h $(srcdir)/coverage.c $(srcdir)/rtl.h \\\n+  $(srcdir)/vecprim.h \\\n   $(srcdir)/optabs.h $(srcdir)/tree.h $(srcdir)/varray.h $(srcdir)/libfuncs.h $(SYMTAB_H) \\\n   $(srcdir)/real.h $(srcdir)/function.h $(srcdir)/insn-addr.h $(srcdir)/hwint.h \\\n   $(srcdir)/fixed-value.h \\"}, {"sha": "5747227dc2b1032958286d2a6e9ab0183a51a005", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -1,3 +1,12 @@\n+2009-09-14  Richard Henderson  <rth@redhat.com>\n+\n+\t* gcc-interface/misc.c (gnat_init_gcc_eh): Don't call\n+\tdefault_init_unwind_resume_libfunc.\n+\t* gcc-interface/trans.c (Exception_Handler_to_gnu_zcx): Use\n+\t__builtin_eh_pointer.\n+\t* gcc-interface/utils.c (gnat_install_builtins): Update call\n+\tto build_common_builtin_nodes.\n+\n 2009-09-13  Richard Guenther  <rguenther@suse.de>\n \t    Rafael Avila de Espindola  <espindola@google.com>\n "}, {"sha": "26df68de581261d289d95bb346083bfcb4e0a1b8", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -435,7 +435,6 @@ gnat_init_gcc_eh (void)\n   using_eh_for_cleanups ();\n \n   lang_eh_type_covers = gnat_eh_type_covers;\n-  default_init_unwind_resume_libfunc ();\n \n   /* Turn on -fexceptions and -fnon-call-exceptions. The first one triggers\n      the generation of the necessary exception runtime tables. The second one"}, {"sha": "61a3aea8c689ccf347db7574cb1156183e833ad0", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -3304,15 +3304,18 @@ Exception_Handler_to_gnu_zcx (Node_Id gnat_node)\n      a new occurrence on top of the stack, which means that this top does not\n      necessarily match the occurrence this handler was dealing with.\n \n-     The EXC_PTR_EXPR object references the exception occurrence being\n+     __builtin_eh_pointer references the exception occurrence being\n      propagated. Upon handler entry, this is the exception for which the\n      handler is triggered. This might not be the case upon handler exit,\n      however, as we might have a new occurrence propagated by the handler's\n      body, and the end_handler hook called as a cleanup in this context.\n \n      We use a local variable to retrieve the incoming value at handler entry\n      time, and reuse it to feed the end_handler hook's argument at exit.  */\n-  gnu_current_exc_ptr = build0 (EXC_PTR_EXPR, ptr_type_node);\n+\n+  gnu_current_exc_ptr\n+    = build_call_expr (built_in_decls [BUILT_IN_EH_POINTER],\n+\t\t       1, integer_zero_node);\n   gnu_incoming_exc_ptr = create_var_decl (get_identifier (\"EXPTR\"), NULL_TREE,\n \t\t\t\t\t  ptr_type_node, gnu_current_exc_ptr,\n \t\t\t\t\t  false, false, false, false, NULL,"}, {"sha": "bd6a840b2455ee74b8c92d388b54ac623bb37baf", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -5439,7 +5439,7 @@ gnat_install_builtins (void)\n      know about internal specificities and control attributes accordingly, for\n      instance __builtin_alloca vs no-throw and -fstack-check.  We will ignore\n      the generic definition from builtins.def.  */\n-  build_common_builtin_nodes ();\n+  build_common_builtin_nodes (false);\n \n   /* Now, install the target specific builtins, such as the AltiVec family on\n      ppc, and the common set as exposed by builtins.def.  */"}, {"sha": "ee6417d61d6fdef3106be465e3de05d5ff7819fc", "filename": "gcc/builtins.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -6940,6 +6940,12 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n #endif\n     case BUILT_IN_EXTEND_POINTER:\n       return expand_builtin_extend_pointer (CALL_EXPR_ARG (exp, 0));\n+    case BUILT_IN_EH_POINTER:\n+      return expand_builtin_eh_pointer (exp);\n+    case BUILT_IN_EH_FILTER:\n+      return expand_builtin_eh_filter (exp);\n+    case BUILT_IN_EH_COPY_VALUES:\n+      return expand_builtin_eh_copy_values (exp);\n \n     case BUILT_IN_VA_START:\n       return expand_builtin_va_start (exp);"}, {"sha": "00287c7548a1e3d758378c927924f165a86928f3", "filename": "gcc/builtins.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -759,6 +759,12 @@ DEF_BUILTIN (BUILT_IN_EMUTLS_REGISTER_COMMON,\n \t     true, true, true, ATTR_NOTHROW_LIST, false,\n \t     !targetm.have_tls)\n \n+/* Exception support.  */\n+DEF_BUILTIN_STUB (BUILT_IN_UNWIND_RESUME, \"__builtin_unwind_resume\")\n+DEF_BUILTIN_STUB (BUILT_IN_EH_POINTER, \"__builtin_eh_pointer\")\n+DEF_BUILTIN_STUB (BUILT_IN_EH_FILTER, \"__builtin_eh_filter\")\n+DEF_BUILTIN_STUB (BUILT_IN_EH_COPY_VALUES, \"__builtin_eh_copy_values\")\n+\n /* Synchronization Primitives.  */\n #include \"sync-builtins.def\"\n "}, {"sha": "25c0c0137d1a0bbe8ac68d691768ec810a4954fb", "filename": "gcc/c-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -4574,7 +4574,7 @@ c_define_builtins (tree va_list_ref_type_node, tree va_list_arg_type_node)\n \n   targetm.init_builtins ();\n \n-  build_common_builtin_nodes ();\n+  build_common_builtin_nodes (c_dialect_cxx ());\n \n   if (flag_mudflap)\n     mudflap_init ();"}, {"sha": "feec8a4e6240cbabe51ef66aea74408b3e6996f7", "filename": "gcc/c-parser.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -8604,10 +8604,7 @@ c_parse_file (void)\n \n   /* Initialize EH, if we've been told to do so.  */\n   if (flag_exceptions)\n-    {\n-      default_init_unwind_resume_libfunc ();\n-      using_eh_for_cleanups ();\n-    }\n+    using_eh_for_cleanups ();\n \n   c_parser_translation_unit (the_parser);\n   the_parser = NULL;"}, {"sha": "16229cc4defb95390d669a75de47632e1b44a025", "filename": "gcc/calls.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -376,10 +376,8 @@ emit_call_1 (rtx funexp, tree fntree ATTRIBUTE_UNUSED, tree fndecl ATTRIBUTE_UNU\n   if (ecf_flags & ECF_LOOPING_CONST_OR_PURE)\n     RTL_LOOPING_CONST_OR_PURE_CALL_P (call_insn) = 1;\n \n-  /* If this call can't throw, attach a REG_EH_REGION reg note to that\n-     effect.  */\n-  if (ecf_flags & ECF_NOTHROW)\n-    add_reg_note (call_insn, REG_EH_REGION, const0_rtx);\n+  /* Create a nothrow REG_EH_REGION note, if needed.  */\n+  make_reg_eh_region_note (call_insn, ecf_flags, 0);\n \n   if (ecf_flags & ECF_NORETURN)\n     add_reg_note (call_insn, REG_NORETURN, const0_rtx);"}, {"sha": "7d87a7a184e4ed619871b340014f545cd9abb531", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 31, "deletions": 57, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -33,6 +33,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"output.h\"\n #include \"function.h\"\n #include \"except.h\"\n+#include \"expr.h\"\n #include \"toplev.h\"\n #include \"timevar.h\"\n \n@@ -80,8 +81,6 @@ inside_basic_block_p (const_rtx insn)\n bool\n control_flow_insn_p (const_rtx insn)\n {\n-  rtx note;\n-\n   switch (GET_CODE (insn))\n     {\n     case NOTE:\n@@ -101,21 +100,20 @@ control_flow_insn_p (const_rtx insn)\n \t   || find_reg_note (insn, REG_NORETURN, 0))\n \t  && GET_CODE (PATTERN (insn)) != COND_EXEC)\n \treturn true;\n+\n       /* Call insn may return to the nonlocal goto handler.  */\n-      return ((nonlocal_goto_handler_labels\n-\t       && (0 == (note = find_reg_note (insn, REG_EH_REGION,\n-\t\t\t\t\t       NULL_RTX))\n-\t\t   || INTVAL (XEXP (note, 0)) >= 0))\n-\t      /* Or may trap.  */\n-\t      || can_throw_internal (insn));\n+      if (can_nonlocal_goto (insn))\n+\treturn true;\n+      break;\n \n     case INSN:\n       /* Treat trap instructions like noreturn calls (same provision).  */\n       if (GET_CODE (PATTERN (insn)) == TRAP_IF\n \t  && XEXP (PATTERN (insn), 0) == const1_rtx)\n \treturn true;\n-\n-      return (flag_non_call_exceptions && can_throw_internal (insn));\n+      if (!flag_non_call_exceptions)\n+\treturn false;\n+      break;\n \n     case BARRIER:\n       /* It is nonsense to reach barrier when looking for the\n@@ -126,6 +124,8 @@ control_flow_insn_p (const_rtx insn)\n     default:\n       gcc_unreachable ();\n     }\n+\n+  return can_throw_internal (insn);\n }\n \n \f\n@@ -155,16 +155,23 @@ make_label_edge (sbitmap edge_cache, basic_block src, rtx label, int flags)\n void\n rtl_make_eh_edge (sbitmap edge_cache, basic_block src, rtx insn)\n {\n-  int is_call = CALL_P (insn) ? EDGE_ABNORMAL_CALL : 0;\n-  rtx handlers, i;\n+  eh_landing_pad lp = get_eh_landing_pad_from_rtx (insn);\n \n-  handlers = reachable_handlers (insn);\n+  if (lp)\n+    {\n+      rtx label = lp->landing_pad;\n \n-  for (i = handlers; i; i = XEXP (i, 1))\n-    make_label_edge (edge_cache, src, XEXP (i, 0),\n-\t\t     EDGE_ABNORMAL | EDGE_EH | is_call);\n+      /* During initial rtl generation, use the post_landing_pad.  */\n+      if (label == NULL)\n+\t{\n+\t  gcc_assert (lp->post_landing_pad);\n+\t  label = label_rtx (lp->post_landing_pad);\n+\t}\n \n-  free_INSN_LIST_list (&handlers);\n+      make_label_edge (edge_cache, src, label,\n+\t\t       EDGE_ABNORMAL | EDGE_EH\n+\t\t       | (CALL_P (insn) ? EDGE_ABNORMAL_CALL : 0));\n+    }\n }\n \n /* States of basic block as seen by find_many_sub_basic_blocks.  */\n@@ -253,13 +260,9 @@ make_edges (basic_block min, basic_block max, int update_p)\n \t{\n \t  rtx tmp;\n \n-\t  /* Recognize exception handling placeholders.  */\n-\t  if (GET_CODE (PATTERN (insn)) == RESX)\n-\t    rtl_make_eh_edge (edge_cache, bb, insn);\n-\n \t  /* Recognize a non-local goto as a branch outside the\n \t     current function.  */\n-\t  else if (find_reg_note (insn, REG_NON_LOCAL_GOTO, NULL_RTX))\n+\t  if (find_reg_note (insn, REG_NON_LOCAL_GOTO, NULL_RTX))\n \t    ;\n \n \t  /* Recognize a tablejump and do the right thing.  */\n@@ -333,12 +336,7 @@ make_edges (basic_block min, basic_block max, int update_p)\n \t\t gotos do not have their addresses taken, then only calls to\n \t\t those functions or to other nested functions that use them\n \t\t could possibly do nonlocal gotos.  */\n-\n-\t      /* We do know that a REG_EH_REGION note with a value less\n-\t\t than 0 is guaranteed not to perform a non-local goto.  */\n-\t      rtx note = find_reg_note (insn, REG_EH_REGION, NULL_RTX);\n-\n-\t      if (!note || INTVAL (XEXP (note, 0)) >=  0)\n+\t      if (can_nonlocal_goto (insn))\n \t\tfor (x = nonlocal_goto_handler_labels; x; x = XEXP (x, 1))\n \t\t  make_label_edge (edge_cache, bb, XEXP (x, 0),\n \t\t\t\t   EDGE_ABNORMAL | EDGE_ABNORMAL_CALL);\n@@ -446,8 +444,10 @@ find_bb_boundaries (basic_block bb)\n     {\n       enum rtx_code code = GET_CODE (insn);\n \n-      /* On code label, split current basic block.  */\n-      if (code == CODE_LABEL)\n+      /* In case we've previously seen an insn that effects a control\n+\t flow transfer, split the block.  */\n+      if ((flow_transfer_insn || code == CODE_LABEL)\n+\t  && inside_basic_block_p (insn))\n \t{\n \t  fallthru = split_block (bb, PREV_INSN (insn));\n \t  if (flow_transfer_insn)\n@@ -465,36 +465,10 @@ find_bb_boundaries (basic_block bb)\n \t  bb = fallthru->dest;\n \t  remove_edge (fallthru);\n \t  flow_transfer_insn = NULL_RTX;\n-\t  if (LABEL_ALT_ENTRY_P (insn))\n+\t  if (code == CODE_LABEL && LABEL_ALT_ENTRY_P (insn))\n \t    make_edge (ENTRY_BLOCK_PTR, bb, 0);\n \t}\n \n-      /* __builtin_unreachable () may cause a barrier to be emitted in\n-\t the middle of a BB.  We need to split it in the same manner\n-\t as if the barrier were preceded by a control_flow_insn_p\n-\t insn.  */\n-      if (code == BARRIER && !flow_transfer_insn)\n-\tflow_transfer_insn = prev_nonnote_insn_bb (insn);\n-\n-      /* In case we've previously seen an insn that effects a control\n-\t flow transfer, split the block.  */\n-      if (flow_transfer_insn && inside_basic_block_p (insn))\n-\t{\n-\t  fallthru = split_block (bb, PREV_INSN (insn));\n-\t  BB_END (bb) = flow_transfer_insn;\n-\n-\t  /* Clean up the bb field for the insns between the blocks.  */\n-\t  for (x = NEXT_INSN (flow_transfer_insn);\n-\t       x != BB_HEAD (fallthru->dest);\n-\t       x = NEXT_INSN (x))\n-\t    if (!BARRIER_P (x))\n-\t      set_block_for_insn (x, NULL);\n-\n-\t  bb = fallthru->dest;\n-\t  remove_edge (fallthru);\n-\t  flow_transfer_insn = NULL_RTX;\n-\t}\n-\n       if (control_flow_insn_p (insn))\n \tflow_transfer_insn = insn;\n       if (insn == end)"}, {"sha": "0ed6bd5903db5254c309833222185972e472ccb0", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 6, "deletions": 21, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -1820,9 +1820,6 @@ expand_gimple_stmt_1 (gimple stmt)\n     case GIMPLE_NOP:\n     case GIMPLE_PREDICT:\n       break;\n-    case GIMPLE_RESX:\n-      expand_resx_stmt (stmt);\n-      break;\n     case GIMPLE_SWITCH:\n       expand_case (stmt);\n       break;\n@@ -1961,7 +1958,7 @@ expand_gimple_stmt_1 (gimple stmt)\n static rtx\n expand_gimple_stmt (gimple stmt)\n {\n-  int rn = -1;\n+  int lp_nr = 0;\n   rtx last = NULL;\n   location_t saved_location = input_location;\n \n@@ -1993,8 +1990,8 @@ expand_gimple_stmt (gimple stmt)\n   input_location = saved_location;\n \n   /* Mark all insns that may trap.  */\n-  rn = lookup_stmt_eh_region (stmt);\n-  if (rn >= 0)\n+  lp_nr = lookup_stmt_eh_lp (stmt);\n+  if (lp_nr)\n     {\n       rtx insn;\n       for (insn = next_real_insn (last); insn;\n@@ -2005,9 +2002,8 @@ expand_gimple_stmt (gimple stmt)\n \t\t may_trap_p instruction may throw.  */\n \t      && GET_CODE (PATTERN (insn)) != CLOBBER\n \t      && GET_CODE (PATTERN (insn)) != USE\n-\t      && (CALL_P (insn)\n-\t\t  || (flag_non_call_exceptions && may_trap_p (PATTERN (insn)))))\n-\t    add_reg_note (insn, REG_EH_REGION, GEN_INT (rn));\n+\t      && insn_could_throw_p (insn))\n+\t    make_reg_eh_region_note (insn, 0, lp_nr);\n \t}\n     }\n \n@@ -2540,15 +2536,6 @@ expand_debug_expr (tree exp)\n \t\t\t\t     op0, GEN_INT (bitsize), GEN_INT (bitpos));\n       }\n \n-    case EXC_PTR_EXPR:\n-      /* ??? Do not call get_exception_pointer(), we don't want to gen\n-\t it if it hasn't been created yet.  */\n-      return get_exception_pointer ();\n-\n-    case FILTER_EXPR:\n-      /* Likewise get_exception_filter().  */\n-      return get_exception_filter ();\n-\n     case ABS_EXPR:\n       return gen_rtx_ABS (mode, op0);\n \n@@ -3556,12 +3543,10 @@ gimple_expand_cfg (void)\n   set_curr_insn_block (DECL_INITIAL (current_function_decl));\n   insn_locators_finalize ();\n \n-  /* Convert tree EH labels to RTL EH labels and zap the tree EH table.  */\n-  convert_from_eh_region_ranges ();\n+  /* Zap the tree EH table.  */\n   set_eh_throw_stmt_table (cfun, NULL);\n \n   rebuild_jump_labels (get_insns ());\n-  find_exception_handler_labels ();\n \n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n     {"}, {"sha": "a7e93dd4c672c91c6716faf1b138aa8750141748", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 27, "deletions": 28, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -1873,12 +1873,16 @@ rtl_verify_flow_info_1 (void)\n \t    n_abnormal++;\n \t}\n \n-      if (n_eh && GET_CODE (PATTERN (BB_END (bb))) != RESX\n-\t  && !find_reg_note (BB_END (bb), REG_EH_REGION, NULL_RTX))\n+      if (n_eh && !find_reg_note (BB_END (bb), REG_EH_REGION, NULL_RTX))\n \t{\n \t  error (\"missing REG_EH_REGION note in the end of bb %i\", bb->index);\n \t  err = 1;\n \t}\n+      if (n_eh > 1)\n+\t{\n+\t  error (\"too many eh edges %i\", bb->index);\n+\t  err = 1;\n+\t}\n       if (n_branch\n \t  && (!JUMP_P (BB_END (bb))\n \t      || (n_branch > 1 && (any_uncondjump_p (BB_END (bb))\n@@ -1894,7 +1898,8 @@ rtl_verify_flow_info_1 (void)\n \t}\n       if (n_branch != 1 && any_uncondjump_p (BB_END (bb)))\n \t{\n-\t  error (\"wrong amount of branch edges after unconditional jump %i\", bb->index);\n+\t  error (\"wrong number of branch edges after unconditional jump %i\",\n+\t\t bb->index);\n \t  err = 1;\n \t}\n       if (n_branch != 1 && any_condjump_p (BB_END (bb))\n@@ -2217,39 +2222,33 @@ purge_dead_edges (basic_block bb)\n   /* Cleanup abnormal edges caused by exceptions or non-local gotos.  */\n   for (ei = ei_start (bb->succs); (e = ei_safe_edge (ei)); )\n     {\n+      bool remove = false;\n+\n       /* There are three types of edges we need to handle correctly here: EH\n \t edges, abnormal call EH edges, and abnormal call non-EH edges.  The\n \t latter can appear when nonlocal gotos are used.  */\n-      if (e->flags & EDGE_EH)\n+      if (e->flags & EDGE_ABNORMAL_CALL)\n \t{\n-\t  if (can_throw_internal (insn)\n-\t      /* If this is a call edge, verify that this is a call insn.  */\n-\t      && (! (e->flags & EDGE_ABNORMAL_CALL)\n-\t\t  || CALL_P (insn)))\n-\t    {\n-\t      ei_next (&ei);\n-\t      continue;\n-\t    }\n+\t  if (!CALL_P (insn))\n+\t    remove = true;\n+\t  else if (can_nonlocal_goto (insn))\n+\t    ;\n+\t  else if ((e->flags & EDGE_EH) && can_throw_internal (insn))\n+\t    ;\n+\t  else\n+\t    remove = true;\n \t}\n-      else if (e->flags & EDGE_ABNORMAL_CALL)\n+      else if (e->flags & EDGE_EH)\n+\tremove = !can_throw_internal (insn);\n+\n+      if (remove)\n \t{\n-\t  if (CALL_P (insn)\n-\t      && (! (note = find_reg_note (insn, REG_EH_REGION, NULL))\n-\t\t  || INTVAL (XEXP (note, 0)) >= 0))\n-\t    {\n-\t      ei_next (&ei);\n-\t      continue;\n-\t    }\n+\t  remove_edge (e);\n+\t  df_set_bb_dirty (bb);\n+\t  purged = true;\n \t}\n       else\n-\t{\n-\t  ei_next (&ei);\n-\t  continue;\n-\t}\n-\n-      remove_edge (e);\n-      df_set_bb_dirty (bb);\n-      purged = true;\n+\tei_next (&ei);\n     }\n \n   if (JUMP_P (insn))"}, {"sha": "2ad07187e04a2fbd163a970afea8fabec6478aed", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -1561,10 +1561,7 @@ update_call_expr (struct cgraph_node *new_version)\n     {\n       struct function *inner_function = DECL_STRUCT_FUNCTION (e->caller->decl);\n       gimple_call_set_fndecl (e->call_stmt, new_version->decl);\n-      /* Update EH information too, just in case.  */\n-      if (!stmt_could_throw_p (e->call_stmt)\n-          && lookup_stmt_eh_region_fn (inner_function, e->call_stmt))\n-        remove_stmt_from_eh_region_fn (inner_function, e->call_stmt);\n+      maybe_clean_eh_stmt_fn (inner_function, e->call_stmt);\n     }\n }\n \n@@ -1909,9 +1906,7 @@ cgraph_materialize_all_clones (void)\n \t\tgsi_replace (&gsi, new_stmt, true);\n \n \t\t/* Update EH information too, just in case.  */\n-\t\tif (!stmt_could_throw_p (new_stmt)\n-\t\t    && lookup_stmt_eh_region (new_stmt))\n-\t\t  remove_stmt_from_eh_region (new_stmt);\n+\t\tmaybe_clean_or_replace_eh_stmt (e->call_stmt, new_stmt);\n \n \t\tcgraph_set_call_stmt_including_clones (node, e->call_stmt, new_stmt);\n "}, {"sha": "6b507c2991d1e04fa157bf1511869be3c8a00c98", "filename": "gcc/combine.c", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -1562,7 +1562,6 @@ can_combine_p (rtx insn, rtx i3, rtx pred ATTRIBUTE_UNUSED, rtx succ,\n       for (i = 0; i < XVECLEN (PATTERN (insn), 0); i++)\n \t{\n \t  rtx elt = XVECEXP (PATTERN (insn), 0, i);\n-\t  rtx note;\n \n \t  switch (GET_CODE (elt))\n \t    {\n@@ -1613,9 +1612,8 @@ can_combine_p (rtx insn, rtx i3, rtx pred ATTRIBUTE_UNUSED, rtx succ,\n \t      /* Ignore SETs whose result isn't used but not those that\n \t\t have side-effects.  */\n \t      if (find_reg_note (insn, REG_UNUSED, SET_DEST (elt))\n-\t\t  && (!(note = find_reg_note (insn, REG_EH_REGION, NULL_RTX))\n-\t\t      || INTVAL (XEXP (note, 0)) <= 0)\n-\t\t  && ! side_effects_p (elt))\n+\t\t  && insn_nothrow_p (insn)\n+\t\t  && !side_effects_p (elt))\n \t\tbreak;\n \n \t      /* If we have already found a SET, this is a second one and\n@@ -3108,15 +3106,13 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n     {\n       rtx set0 = XVECEXP (newpat, 0, 0);\n       rtx set1 = XVECEXP (newpat, 0, 1);\n-      rtx note;\n \n       if (((REG_P (SET_DEST (set1))\n \t    && find_reg_note (i3, REG_UNUSED, SET_DEST (set1)))\n \t   || (GET_CODE (SET_DEST (set1)) == SUBREG\n \t       && find_reg_note (i3, REG_UNUSED, SUBREG_REG (SET_DEST (set1)))))\n-\t  && (!(note = find_reg_note (i3, REG_EH_REGION, NULL_RTX))\n-\t      || INTVAL (XEXP (note, 0)) <= 0)\n-\t  && ! side_effects_p (SET_SRC (set1)))\n+\t  && insn_nothrow_p (i3)\n+\t  && !side_effects_p (SET_SRC (set1)))\n \t{\n \t  newpat = set0;\n \t  insn_code_number = recog_for_combine (&newpat, i3, &new_i3_notes);\n@@ -3127,9 +3123,8 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t\t|| (GET_CODE (SET_DEST (set0)) == SUBREG\n \t\t    && find_reg_note (i3, REG_UNUSED,\n \t\t\t\t      SUBREG_REG (SET_DEST (set0)))))\n-\t       && (!(note = find_reg_note (i3, REG_EH_REGION, NULL_RTX))\n-\t\t   || INTVAL (XEXP (note, 0)) <= 0)\n-\t       && ! side_effects_p (SET_SRC (set0)))\n+\t       && insn_nothrow_p (i3)\n+\t       && !side_effects_p (SET_SRC (set0)))\n \t{\n \t  newpat = set1;\n \t  insn_code_number = recog_for_combine (&newpat, i3, &new_i3_notes);"}, {"sha": "4a17a77dbec9a4b057e7190a2aab014528ea3c89", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -1,3 +1,11 @@\n+2009-09-14  Richard Henderson  <rth@redhat.com>\n+\n+\t* except.c (init_exception_processing): Don't call\n+\tdefault_init_unwind_resume_libfunc.\n+\t(cp_protect_cleanup_actions): Return the decl to call.\n+\t(build_exc_ptr): Use __builtin_eh_pointer.\n+\t* optimize.c (clone_body): Set eh_lp_nr, not eh_region.\n+\n 2009-09-13  Richard Guenther  <rguenther@suse.de>\n \tRafael Avila de Espindola  <espindola@google.com>\n "}, {"sha": "1b13819ed67496bc747cddb6b69417e4006b056e", "filename": "gcc/cp/except.c", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -53,7 +53,7 @@ static tree wrap_cleanups_r (tree *, int *, void *);\n static int complete_ptr_ref_or_void_ptr_p (tree, tree);\n static bool is_admissible_throw_operand (tree);\n static int can_convert_eh (tree, tree);\n-static gimple cp_protect_cleanup_actions (void);\n+static tree cp_protect_cleanup_actions (void);\n \n /* Sets up all the global eh stuff that needs to be initialized at the\n    start of compilation.  */\n@@ -77,25 +77,20 @@ init_exception_processing (void)\n   call_unexpected_node\n     = push_throw_library_fn (get_identifier (\"__cxa_call_unexpected\"), tmp);\n \n-  if (targetm.arm_eabi_unwinder)\n-    unwind_resume_libfunc = init_one_libfunc (\"__cxa_end_cleanup\");\n-  else\n-    default_init_unwind_resume_libfunc ();\n-\n   lang_protect_cleanup_actions = &cp_protect_cleanup_actions;\n }\n \n /* Returns an expression to be executed if an unhandled exception is\n    propagated out of a cleanup region.  */\n \n-static gimple\n+static tree\n cp_protect_cleanup_actions (void)\n {\n   /* [except.terminate]\n \n      When the destruction of an object during stack unwinding exits\n      using an exception ... void terminate(); is called.  */\n-  return gimple_build_call (terminate_node, 0);\n+  return terminate_node;\n }\n \n static tree\n@@ -154,7 +149,8 @@ build_eh_type_type (tree type)\n tree\n build_exc_ptr (void)\n {\n-  return build0 (EXC_PTR_EXPR, ptr_type_node);\n+  return build_call_n (built_in_decls [BUILT_IN_EH_POINTER],\n+\t\t       1, integer_zero_node);\n }\n \n /* Declare a function NAME, returning RETURN_TYPE, taking a single"}, {"sha": "58d5b9001d2646f23bf7b1723a86740adf238e18", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -99,7 +99,7 @@ clone_body (tree clone, tree fn, void *arg_map)\n   id.transform_lang_insert_block = NULL;\n \n   /* We're not inside any EH region.  */\n-  id.eh_region = -1;\n+  id.eh_lp_nr = 0;\n \n   stmts = DECL_SAVED_TREE (fn);\n   walk_tree (&stmts, copy_tree_body_r, &id, NULL);"}, {"sha": "8f49a9af9f582131add5300e73b2997f9e89c0ad", "filename": "gcc/cse.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -6544,9 +6544,9 @@ count_reg_usage (rtx x, int *counts, rtx dest, int incr)\n     case CALL_INSN:\n     case INSN:\n     case JUMP_INSN:\n-    /* We expect dest to be NULL_RTX here.  If the insn may trap, mark\n-       this fact by setting DEST to pc_rtx.  */\n-      if (flag_non_call_exceptions && may_trap_p (PATTERN (x)))\n+      /* We expect dest to be NULL_RTX here.  If the insn may trap, mark\n+         this fact by setting DEST to pc_rtx.  */\n+      if (insn_could_throw_p (x))\n \tdest = pc_rtx;\n       if (code == CALL_INSN)\n \tcount_reg_usage (CALL_INSN_FUNCTION_USAGE (x), counts, dest, incr);\n@@ -6658,7 +6658,7 @@ static bool\n insn_live_p (rtx insn, int *counts)\n {\n   int i;\n-  if (flag_non_call_exceptions && may_trap_p (PATTERN (insn)))\n+  if (insn_could_throw_p (insn))\n     return true;\n   else if (GET_CODE (PATTERN (insn)) == SET)\n     return set_live_p (PATTERN (insn), insn, counts);"}, {"sha": "b937dd44a190c6af421d9d00c55feac4b8da2a10", "filename": "gcc/dce.c", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdce.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -79,13 +79,7 @@ deletable_insn_p_1 (rtx body)\n       return false;\n \n     default:\n-      if (volatile_refs_p (body))\n-\treturn false;\n-\n-      if (flag_non_call_exceptions && may_trap_p (body))\n-\treturn false;\n-\n-      return true;\n+      return !volatile_refs_p (body);\n     }\n }\n \n@@ -99,6 +93,14 @@ deletable_insn_p (rtx insn, bool fast, bitmap arg_stores)\n   rtx body, x;\n   int i;\n \n+  /* Don't delete jumps, notes and the like.  */\n+  if (!NONJUMP_INSN_P (insn))\n+    return false;\n+\n+  /* Don't delete insns that can throw.  */\n+  if (!insn_nothrow_p (insn))\n+    return false;\n+\n   if (CALL_P (insn)\n       /* We cannot delete calls inside of the recursive dce because\n \t this may cause basic blocks to be deleted and this messes up\n@@ -113,13 +115,6 @@ deletable_insn_p (rtx insn, bool fast, bitmap arg_stores)\n \t  && !RTL_LOOPING_CONST_OR_PURE_CALL_P (insn)))\n     return find_call_stack_args (insn, false, fast, arg_stores);\n \n-  if (!NONJUMP_INSN_P (insn))\n-    return false;\n-\n-  /* Similarly, we cannot delete other insns that can throw either.  */\n-  if (df_in_progress && flag_non_call_exceptions && can_throw_internal (insn))\n-    return false;\n-\n   body = PATTERN (insn);\n   switch (GET_CODE (body))\n     {"}, {"sha": "9d3e2c07ed61c3a5b78cfd7b52c90679543843a1", "filename": "gcc/dse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -2531,7 +2531,7 @@ scan_insn (bb_info_t bb_info, rtx insn)\n      them.  */\n   if ((GET_CODE (PATTERN (insn)) == CLOBBER)\n       || volatile_refs_p (PATTERN (insn))\n-      || (flag_non_call_exceptions && may_trap_p (PATTERN (insn)))\n+      || insn_could_throw_p (insn)\n       || (RTX_FRAME_RELATED_P (insn))\n       || find_reg_note (insn, REG_FRAME_RELATED_EXPR, NULL_RTX))\n     insn_info->cannot_delete = true;"}, {"sha": "9ed36b332119f8cbdce46c7d559899059b567bd0", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -3492,13 +3492,7 @@ try_split (rtx pat, rtx trial, int last)\n       switch (REG_NOTE_KIND (note))\n \t{\n \tcase REG_EH_REGION:\n-\t  for (insn = insn_last; insn != NULL_RTX; insn = PREV_INSN (insn))\n-\t    {\n-\t      if (CALL_P (insn)\n-\t\t  || (flag_non_call_exceptions && INSN_P (insn)\n-\t\t      && may_trap_p (PATTERN (insn))))\n-\t\tadd_reg_note (insn, REG_EH_REGION, XEXP (note, 0));\n-\t    }\n+\t  copy_reg_eh_region_note_backward (note, insn_last, NULL);\n \t  break;\n \n \tcase REG_NORETURN:"}, {"sha": "c916a18089b9c56f68eeb5b246aa975de906f1dd", "filename": "gcc/except.c", "status": "modified", "additions": 1252, "deletions": 2859, "changes": 4111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980"}, {"sha": "3e9a39cbb5f1fd8b960ba2225c2316c4b7de6e98", "filename": "gcc/except.h", "status": "modified", "additions": 208, "deletions": 104, "changes": 312, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -23,20 +23,96 @@ along with GCC; see the file COPYING3.  If not see\n #include \"vecprim.h\"\n \n struct function;\n+struct eh_region_d;\n+struct pointer_map_t;\n \n /* The type of an exception region.  */\n enum eh_region_type\n {\n-  ERT_UNKNOWN = 0,\n+  /* CLEANUP regions implement e.g. destructors run when exiting a block.\n+     They can be generated from both GIMPLE_TRY_FINALLY and GIMPLE_TRY_CATCH\n+     nodes.  It is expected by the runtime that cleanup regions will *not*\n+     resume normal program flow, but will continue propagation of the\n+     exception.  */\n   ERT_CLEANUP,\n+\n+  /* TRY regions implement catching an exception.  The list of types associated\n+     with the attached catch handlers is examined in order by the runtime and\n+     control is transfered to the appropriate handler.  Note that a NULL type\n+     list is a catch-all handler, and that it will catch *all* exceptions\n+     including those originating from a different language.  */\n   ERT_TRY,\n-  ERT_CATCH,\n+\n+  /* ALLOWED_EXCEPTIONS regions implement exception filtering, e.g. the\n+     throw(type-list) specification that can be added to C++ functions.\n+     The runtime examines the thrown exception vs the type list, and if\n+     the exception does not match, transfers control to the handler.  The\n+     normal handler for C++ calls __cxa_call_unexpected.  */\n   ERT_ALLOWED_EXCEPTIONS,\n-  ERT_MUST_NOT_THROW,\n-  ERT_THROW\n+\n+  /* MUST_NOT_THROW regions prevent all exceptions from propagating.  This\n+     region type is used in C++ to surround destructors being run inside a\n+     CLEANUP region.  This differs from an ALLOWED_EXCEPTIONS region with\n+     an empty type list in that the runtime is prepared to terminate the\n+     program directly.  We only generate code for MUST_NOT_THROW regions\n+     along control paths that are already handling an exception within the\n+     current function.  */\n+  ERT_MUST_NOT_THROW\n+};\n+\n+\n+/* A landing pad for a given exception region.  Any transfer of control\n+   from the EH runtime to the function happens at a landing pad.  */\n+\n+struct GTY(()) eh_landing_pad_d\n+{\n+  /* The linked list of all landing pads associated with the region.  */\n+  struct eh_landing_pad_d *next_lp;\n+\n+  /* The region with which this landing pad is associated.  */\n+  struct eh_region_d *region;\n+\n+  /* At the gimple level, the location to which control will be transfered\n+     for this landing pad.  There can be both EH and normal edges into the\n+     block containing the post-landing-pad label.  */\n+  tree post_landing_pad;\n+\n+  /* At the rtl level, the location to which the runtime will transfer\n+     control.  This differs from the post-landing-pad in that the target's\n+     EXCEPTION_RECEIVER pattern will be expanded here, as well as other\n+     bookkeeping specific to exceptions.  There must not be normal edges\n+     into the block containing the landing-pad label.  */\n+  rtx landing_pad;\n+\n+  /* The index of this landing pad within fun->eh->lp_array.  */\n+  int index;\n+};\n+\n+/* A catch handler associated with an ERT_TRY region.  */\n+\n+struct GTY(()) eh_catch_d\n+{\n+  /* The double-linked list of all catch handlers for the region.  */\n+  struct eh_catch_d *next_catch;\n+  struct eh_catch_d *prev_catch;\n+\n+  /* A TREE_LIST of runtime type objects that this catch handler\n+     will catch, or NULL if all exceptions are caught.  */\n+  tree type_list;\n+\n+  /* A TREE_LIST of INTEGER_CSTs that correspond to the type_list entries,\n+     having been mapped by assign_filter_values.  These integers are to be\n+     compared against the __builtin_eh_filter value.  */\n+  tree filter_list;\n+\n+  /* The code that should be executed if this catch handler matches the\n+     thrown exception.  This label is only maintained until\n+     pass_lower_eh_dispatch, at which point it is cleared.  */\n+  tree label;\n };\n \n /* Describes one exception region.  */\n+\n struct GTY(()) eh_region_d\n {\n   /* The immediately surrounding region.  */\n@@ -46,124 +122,123 @@ struct GTY(()) eh_region_d\n   struct eh_region_d *inner;\n   struct eh_region_d *next_peer;\n \n-  /* List of regions sharing label.  */\n-  struct eh_region_d *next_region_sharing_label;\n-\n-  /* An identifier for this region.  */\n-  int region_number;\n-\n-  /* When a region is deleted, its parents inherit the REG_EH_REGION\n-     numbers already assigned.  */\n-  bitmap aka;\n+  /* The index of this region within fun->eh->region_array.  */\n+  int index;\n \n   /* Each region does exactly one thing.  */\n   enum eh_region_type type;\n \n   /* Holds the action to perform based on the preceding type.  */\n   union eh_region_u {\n-    /* A list of catch blocks, a surrounding try block,\n-       and the label for continuing after a catch.  */\n     struct eh_region_u_try {\n-      struct eh_region_d *eh_catch;\n-      struct eh_region_d *last_catch;\n+      /* The double-linked list of all catch handlers for this region.  */\n+      struct eh_catch_d *first_catch;\n+      struct eh_catch_d *last_catch;\n     } GTY ((tag (\"ERT_TRY\"))) eh_try;\n \n-    /* The list through the catch handlers, the list of type objects\n-       matched, and the list of associated filters.  */\n-    struct eh_region_u_catch {\n-      struct eh_region_d *next_catch;\n-      struct eh_region_d *prev_catch;\n-      tree type_list;\n-      tree filter_list;\n-    } GTY ((tag (\"ERT_CATCH\"))) eh_catch;\n-\n-    /* A tree_list of allowed types.  */\n     struct eh_region_u_allowed {\n+      /* A TREE_LIST of runtime type objects allowed to pass.  */\n       tree type_list;\n+      /* The code that should be executed if the thrown exception does\n+\t not match the type list.  This label is only maintained until\n+\t pass_lower_eh_dispatch, at which point it is cleared.  */\n+      tree label;\n+      /* The integer that will be passed by the runtime to signal that\n+\t we should execute the code at LABEL.  This integer is assigned\n+\t by assign_filter_values and is to be compared against the\n+\t __builtin_eh_filter value.  */\n       int filter;\n     } GTY ((tag (\"ERT_ALLOWED_EXCEPTIONS\"))) allowed;\n \n-    /* The type given by a call to \"throw foo();\", or discovered\n-       for a throw.  */\n-    struct eh_region_u_throw {\n-      tree type;\n-    } GTY ((tag (\"ERT_THROW\"))) eh_throw;\n+    struct eh_region_u_must_not_throw {\n+      /* A function decl to be invoked if this region is actually reachable\n+\t from within the function, rather than implementable from the runtime.\n+\t The normal way for this to happen is for there to be a CLEANUP region\n+\t contained within this MUST_NOT_THROW region.  Note that if the\n+\t runtime handles the MUST_NOT_THROW region, we have no control over\n+\t what termination function is called; it will be decided by the \n+\t personality function in effect for this CIE.  */\n+      tree failure_decl;\n+      /* The location assigned to the call of FAILURE_DECL, if expanded.  */\n+      location_t failure_loc;\n+    } GTY ((tag (\"ERT_MUST_NOT_THROW\"))) must_not_throw;\n   } GTY ((desc (\"%0.type\"))) u;\n \n-  /* Entry point for this region's handler before landing pads are built.  */\n-  rtx label;\n-  tree tree_label;\n-\n-  /* Entry point for this region's handler from the runtime eh library.  */\n-  rtx landing_pad;\n-\n-  /* Entry point for this region's handler from an inner region.  */\n-  rtx post_landing_pad;\n+  /* The list of landing pads associated with this region.  */\n+  struct eh_landing_pad_d *landing_pads;\n \n-  /* The RESX insn for handing off control to the next outermost handler,\n-     if appropriate.  */\n-  rtx resume;\n-\n-  /* True if something in this region may throw.  */\n-  unsigned may_contain_throw : 1;\n+  /* EXC_PTR and FILTER values copied from the runtime for this region.\n+     Each region gets its own psuedos so that if there are nested exceptions\n+     we do not overwrite the values of the first exception.  */\n+  rtx exc_ptr_reg, filter_reg;\n };\n \n+typedef struct eh_landing_pad_d *eh_landing_pad;\n+typedef struct eh_catch_d *eh_catch;\n typedef struct eh_region_d *eh_region;\n+\n DEF_VEC_P(eh_region);\n DEF_VEC_ALLOC_P(eh_region, gc);\n DEF_VEC_ALLOC_P(eh_region, heap);\n \n-/* Per-function EH data.  Used to save exception status for each\n-   function.  */\n+DEF_VEC_P(eh_landing_pad);\n+DEF_VEC_ALLOC_P(eh_landing_pad, gc);\n+\n+\n+/* The exception status for each function.  */\n+\n struct GTY(()) eh_status\n {\n   /* The tree of all regions for this function.  */\n-  struct eh_region_d *region_tree;\n+  eh_region region_tree;\n \n   /* The same information as an indexable array.  */\n   VEC(eh_region,gc) *region_array;\n-  int last_region_number;\n \n+  /* The landing pads as an indexable array.  */\n+  VEC(eh_landing_pad,gc) *lp_array;\n+\n+  /* At the gimple level, a mapping from gimple statement to landing pad\n+     or must-not-throw region.  See record_stmt_eh_region.  */\n   htab_t GTY((param_is (struct throw_stmt_node))) throw_stmt_table;\n+\n+  /* All of the runtime type data used by the function.  These objects\n+     are emitted to the lang-specific-data-area for the function.  */\n+  VEC(tree,gc) *ttype_data;\n+\n+  /* The table of all action chains.  These encode the eh_region tree in\n+     a compact form for use by the runtime, and is also emitted to the\n+     lang-specific-data-area.  Note that the ARM EABI uses a different\n+     format for the encoding than all other ports.  */\n+  union eh_status_u {\n+    VEC(tree,gc) * GTY((tag (\"1\"))) arm_eabi;\n+    VEC(uchar,gc) * GTY((tag (\"0\"))) other;\n+  } GTY ((desc (\"targetm.arm_eabi_unwinder\"))) ehspec_data;\n };\n \n \n /* Test: is exception handling turned on?  */\n extern int doing_eh (int);\n \n-/* Note that the current EH region (if any) may contain a throw, or a\n-   call to a function which itself may contain a throw.  */\n-extern void note_eh_region_may_contain_throw (struct eh_region_d *);\n-\n /* Invokes CALLBACK for every exception handler label.  Only used by old\n    loop hackery; should not be used by new code.  */\n extern void for_each_eh_label (void (*) (rtx));\n \n-/* Invokes CALLBACK for every exception region in the current function.  */\n-extern void for_each_eh_region (void (*) (struct eh_region_d *));\n-\n-/* Determine if the given INSN can throw an exception.  */\n-extern bool can_throw_internal_1 (int, bool, bool);\n-extern bool can_throw_internal (const_rtx);\n-extern bool can_throw_external_1 (int, bool, bool);\n-extern bool can_throw_external (const_rtx);\n-\n /* Set TREE_NOTHROW and cfun->all_throwers_are_sibcalls.  */\n extern unsigned int set_nothrow_function_flags (void);\n \n extern void init_eh (void);\n extern void init_eh_for_function (void);\n \n-extern rtx reachable_handlers (rtx);\n-extern void remove_eh_region (int);\n-extern void remove_eh_region_and_replace_by_outer_of (int, int);\n+extern void remove_eh_landing_pad (eh_landing_pad);\n+extern void remove_eh_handler (eh_region);\n \n-extern void convert_from_eh_region_ranges (void);\n-extern unsigned int convert_to_eh_region_ranges (void);\n-extern void find_exception_handler_labels (void);\n extern bool current_function_has_exception_handlers (void);\n extern void output_function_exception_table (const char *);\n \n+extern rtx expand_builtin_eh_pointer (tree);\n+extern rtx expand_builtin_eh_filter (tree);\n+extern rtx expand_builtin_eh_copy_values (tree);\n extern void expand_builtin_unwind_init (void);\n extern rtx expand_builtin_eh_return_data_regno (tree);\n extern rtx expand_builtin_extract_return_addr (tree);\n@@ -173,46 +248,50 @@ extern rtx expand_builtin_dwarf_sp_column (void);\n extern void expand_builtin_eh_return (tree, tree);\n extern void expand_eh_return (void);\n extern rtx expand_builtin_extend_pointer (tree);\n-extern rtx get_exception_pointer (void);\n-extern rtx get_exception_filter (void);\n+\n typedef tree (*duplicate_eh_regions_map) (tree, void *);\n-extern int duplicate_eh_regions (struct function *, duplicate_eh_regions_map,\n-\t\t\t\t void *, int, int);\n+extern struct pointer_map_t *duplicate_eh_regions\n+  (struct function *, eh_region, int, duplicate_eh_regions_map, void *);\n \n extern void sjlj_emit_function_exit_after (rtx);\n-extern void default_init_unwind_resume_libfunc (void);\n-\n-extern struct eh_region_d *gen_eh_region_cleanup (struct eh_region_d *);\n-extern struct eh_region_d *gen_eh_region_try (struct eh_region_d *);\n-extern struct eh_region_d *gen_eh_region_catch (struct eh_region_d *, tree);\n-extern struct eh_region_d *gen_eh_region_allowed (struct eh_region_d *, tree);\n-extern struct eh_region_d *gen_eh_region_must_not_throw (struct eh_region_d *);\n-extern int get_eh_region_number (struct eh_region_d *);\n-extern bool get_eh_region_may_contain_throw (struct eh_region_d *);\n-extern tree get_eh_region_no_tree_label (int);\n-extern tree get_eh_region_tree_label (struct eh_region_d *);\n-extern void set_eh_region_tree_label (struct eh_region_d *, tree);\n-\n-extern void foreach_reachable_handler (int, bool, bool,\n-\t\t\t\t       void (*) (struct eh_region_d *, void *),\n-\t\t\t\t       void *);\n-\n-extern void collect_eh_region_array (void);\n-extern void expand_resx_stmt (gimple);\n+\n+extern eh_region gen_eh_region_cleanup (eh_region);\n+extern eh_region gen_eh_region_try (eh_region);\n+extern eh_region gen_eh_region_allowed (eh_region, tree);\n+extern eh_region gen_eh_region_must_not_throw (eh_region);\n+\n+extern eh_catch gen_eh_region_catch (eh_region, tree);\n+extern eh_landing_pad gen_eh_landing_pad (eh_region);\n+\n+extern eh_region get_eh_region_from_number_fn (struct function *, int);\n+extern eh_region get_eh_region_from_number (int);\n+extern eh_landing_pad get_eh_landing_pad_from_number_fn (struct function*,int);\n+extern eh_landing_pad get_eh_landing_pad_from_number (int);\n+extern eh_region get_eh_region_from_lp_number_fn (struct function *, int);\n+extern eh_region get_eh_region_from_lp_number (int);\n+\n+extern eh_region eh_region_outermost (struct function *, eh_region, eh_region);\n+\n+extern void make_reg_eh_region_note (rtx insn, int ecf_flags, int lp_nr);\n+extern void make_reg_eh_region_note_nothrow_nononlocal (rtx);\n+\n extern void verify_eh_tree (struct function *);\n extern void dump_eh_tree (FILE *, struct function *);\n void debug_eh_tree (struct function *);\n-extern int eh_region_outermost (struct function *, int, int);\n extern void add_type_for_runtime (tree);\n extern tree lookup_type_for_runtime (tree);\n+extern void assign_filter_values (void);\n+\n+extern eh_region get_eh_region_from_rtx (const_rtx);\n+extern eh_landing_pad get_eh_landing_pad_from_rtx (const_rtx);\n \n-/* If non-NULL, this is a function that returns an expression to be\n+/* If non-NULL, this is a function that returns a function decl to be\n    executed if an unhandled exception is propagated out of a cleanup\n    region.  For example, in C++, an exception thrown by a destructor\n    during stack unwinding is required to result in a call to\n    `std::terminate', so the C++ version of this function returns a\n-   CALL_EXPR for `std::terminate'.  */\n-extern gimple (*lang_protect_cleanup_actions) (void);\n+   FUNCTION_DECL for `std::terminate'.  */\n+extern tree (*lang_protect_cleanup_actions) (void);\n \n /* Return true if type A catches type B.  */\n extern int (*lang_eh_type_covers) (tree a, tree b);\n@@ -263,17 +342,11 @@ extern int (*lang_eh_type_covers) (tree a, tree b);\n \n struct GTY(()) throw_stmt_node {\n   gimple stmt;\n-  int region_nr;\n+  int lp_nr;\n };\n \n extern struct htab *get_eh_throw_stmt_table (struct function *);\n extern void set_eh_throw_stmt_table (struct function *, struct htab *);\n-extern void remove_unreachable_regions (sbitmap, sbitmap);\n-extern VEC(int,heap) * label_to_region_map (void);\n-extern int num_eh_regions (void);\n-extern bitmap must_not_throw_labels (void);\n-extern struct eh_region_d *redirect_eh_edge_to_label (struct edge_def *, tree, bool, bool, int);\n-extern int get_next_region_sharing_label (int);\n \n enum eh_personality_kind {\n   eh_personality_none,\n@@ -283,3 +356,34 @@ enum eh_personality_kind {\n \n extern enum eh_personality_kind\n function_needs_eh_personality (struct function *);\n+\n+/* Pre-order iteration within the eh_region tree.  */\n+\n+static inline eh_region\n+ehr_next (eh_region r, eh_region start)\n+{\n+  if (r->inner)\n+    r = r->inner;\n+  else if (r->next_peer && r != start)\n+    r = r->next_peer;\n+  else\n+    {\n+      do\n+\t{\n+\t  r = r->outer;\n+\t  if (r == start)\n+\t    return NULL;\n+\t}\n+      while (r->next_peer == NULL);\n+      r = r->next_peer;\n+    }\n+  return r;\n+}\n+\n+#define FOR_ALL_EH_REGION_AT(R, START) \\\n+  for ((R) = (START); (R) != NULL; (R) = ehr_next (R, START))\n+\n+#define FOR_ALL_EH_REGION_FN(R, FN) \\\n+  for ((R) = (FN)->eh->region_tree; (R) != NULL; (R) = ehr_next (R, NULL))\n+\n+#define FOR_ALL_EH_REGION(R) FOR_ALL_EH_REGION_FN (R, cfun)"}, {"sha": "5d18435a99a9af53565aba39e20d7e0b3d15d507", "filename": "gcc/expr.c", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -7110,7 +7110,7 @@ rtx\n expand_expr_real (tree exp, rtx target, enum machine_mode tmode,\n \t\t  enum expand_modifier modifier, rtx *alt_rtl)\n {\n-  int rn = -1;\n+  int lp_nr = 0;\n   rtx ret, last = NULL;\n \n   /* Handle ERROR_MARK before anybody tries to access its type.  */\n@@ -7123,10 +7123,8 @@ expand_expr_real (tree exp, rtx target, enum machine_mode tmode,\n \n   if (flag_non_call_exceptions)\n     {\n-      rn = lookup_expr_eh_region (exp);\n-\n-      /* If rn < 0, then either (1) tree-ssa not used or (2) doesn't throw.  */\n-      if (rn >= 0)\n+      lp_nr = lookup_expr_eh_lp (exp);\n+      if (lp_nr)\n \tlast = get_last_insn ();\n     }\n \n@@ -7159,7 +7157,7 @@ expand_expr_real (tree exp, rtx target, enum machine_mode tmode,\n   /* If using non-call exceptions, mark all insns that may trap.\n      expand_call() will mark CALL_INSNs before we get to this code,\n      but it doesn't handle libcalls, and these may trap.  */\n-  if (rn >= 0)\n+  if (lp_nr)\n     {\n       rtx insn;\n       for (insn = next_real_insn (last); insn;\n@@ -7170,8 +7168,8 @@ expand_expr_real (tree exp, rtx target, enum machine_mode tmode,\n \t\t may_trap_p instruction may throw.  */\n \t      && GET_CODE (PATTERN (insn)) != CLOBBER\n \t      && GET_CODE (PATTERN (insn)) != USE\n-\t      && (CALL_P (insn) || may_trap_p (PATTERN (insn))))\n-\t    add_reg_note (insn, REG_EH_REGION, GEN_INT (rn));\n+\t      && insn_could_throw_p (insn))\n+\t    make_reg_eh_region_note (insn, 0, lp_nr);\n \t}\n     }\n \n@@ -7239,6 +7237,7 @@ expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n \n   switch (code)\n     {\n+    case NON_LVALUE_EXPR:\n     case PAREN_EXPR:\n     CASE_CONVERT:\n       if (treeop0 == error_mark_node)\n@@ -9490,7 +9489,6 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n     case GOTO_EXPR:\n     case SWITCH_EXPR:\n     case ASM_EXPR:\n-    case RESX_EXPR:\n       /* Expanded in cfgexpand.c.  */\n       gcc_unreachable ();\n \n@@ -9519,12 +9517,6 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       /* Lowered by gimplify.c.  */\n       gcc_unreachable ();\n \n-    case EXC_PTR_EXPR:\n-      return get_exception_pointer ();\n-\n-    case FILTER_EXPR:\n-      return get_exception_filter ();\n-\n     case FDESC_EXPR:\n       /* Function descriptors are not valid except for as\n \t initialization constants, and should not be expanded.  */"}, {"sha": "1ce0013ef354234f0ea5195a6e88c0d0cbe256eb", "filename": "gcc/fold-const.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -15224,9 +15224,7 @@ tree_expr_nonnegative_warnv_p (tree t, bool *strict_overflow_p)\n     case ASSERT_EXPR:\n     case ADDR_EXPR:\n     case WITH_SIZE_EXPR:\n-    case EXC_PTR_EXPR:\n     case SSA_NAME:\n-    case FILTER_EXPR:\n       return tree_single_nonnegative_warnv_p (t, strict_overflow_p);\n \n     default:\n@@ -15518,9 +15516,7 @@ tree_expr_nonzero_warnv_p (tree t, bool *strict_overflow_p)\n     case ASSERT_EXPR:\n     case ADDR_EXPR:\n     case WITH_SIZE_EXPR:\n-    case EXC_PTR_EXPR:\n     case SSA_NAME:\n-    case FILTER_EXPR:\n       return tree_single_nonzero_warnv_p (t, strict_overflow_p);\n \n     case COMPOUND_EXPR:"}, {"sha": "b8586c2c0bc2e930fc7b4a8a5b4d74b47dde24ec", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -1,3 +1,10 @@\n+2009-09-14  Richard Henderson  <rth@redhat.com>\n+\n+\t* f95-lang.c (gfc_init_builtin_functions): Update call to\n+\tbuild_common_builtin_nodes.\n+\t(gfc_maybe_initialize_eh): Don't call\n+\tdefault_init_unwind_resume_libfunc.\n+\n 2009-09-13  Richard Guenther  <rguenther@suse.de>\n \tRafael Avila de Espindola  <espindola@google.com>\n "}, {"sha": "a21044c64ae48a0de059ef79a5a6dd846a3c5bd3", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -1131,7 +1131,7 @@ gfc_init_builtin_functions (void)\n \t\t      BUILT_IN_EMUTLS_REGISTER_COMMON,\n \t\t      \"__emutls_register_common\", false);\n \n-  build_common_builtin_nodes ();\n+  build_common_builtin_nodes (false);\n   targetm.init_builtins ();\n }\n \n@@ -1155,7 +1155,6 @@ gfc_maybe_initialize_eh (void)\n     return;\n \n   gfc_eh_initialized_p = true;\n-  default_init_unwind_resume_libfunc ();\n   using_eh_for_cleanups ();\n }\n "}, {"sha": "72aad0006dc54c33818fb1ee2af10eec8fa2474a", "filename": "gcc/function.h", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -24,7 +24,7 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"tree.h\"\n #include \"hashtab.h\"\n-#include \"varray.h\"\n+#include \"vecprim.h\"\n \n /* Stack of pending (incomplete) sequences saved by `start_sequence'.\n    Each element describes one pending sequence.\n@@ -144,21 +144,14 @@ DEF_VEC_ALLOC_P(call_site_record, gc);\n \n /* RTL representation of exception handling.  */\n struct GTY(()) rtl_eh {\n-  rtx filter;\n-  rtx exc_ptr;\n-\n-  int built_landing_pads;\n-\n   rtx ehr_stackadj;\n   rtx ehr_handler;\n   rtx ehr_label;\n \n   rtx sjlj_fc;\n   rtx sjlj_exit_after;\n \n-  VEC(tree,gc) *ttype_data;\n-  varray_type ehspec_data;\n-  varray_type action_record_data;\n+  VEC(uchar,gc) *action_record_data;\n \n   VEC(call_site_record,gc) *call_site_record[2];\n };"}, {"sha": "803ab3e5a148a91d4dd3d87c8182f119403a2017", "filename": "gcc/gcse.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -1353,9 +1353,11 @@ hash_scan_set (rtx pat, rtx insn, struct hash_table_d *table)\n \t  /* Don't GCSE something if we can't do a reg/reg copy.  */\n \t  && can_copy_p (GET_MODE (dest))\n \t  /* GCSE commonly inserts instruction after the insn.  We can't\n-\t     do that easily for EH_REGION notes so disable GCSE on these\n-\t     for now.  */\n-\t  && !find_reg_note (insn, REG_EH_REGION, NULL_RTX)\n+\t     do that easily for EH edges so disable GCSE on these for now.  */\n+\t  /* ??? We can now easily create new EH landing pads at the\n+\t     gimple level, for splitting edges; there's no reason we\n+\t     can't do the same thing at the rtl level.  */\n+\t  && !can_throw_internal (insn)\n \t  /* Is SET_SRC something we want to gcse?  */\n \t  && want_to_gcse_p (src)\n \t  /* Don't CSE a nop.  */\n@@ -1415,9 +1417,8 @@ hash_scan_set (rtx pat, rtx insn, struct hash_table_d *table)\n \t   /* Don't GCSE something if we can't do a reg/reg copy.  */\n \t   && can_copy_p (GET_MODE (src))\n \t   /* GCSE commonly inserts instruction after the insn.  We can't\n-\t      do that easily for EH_REGION notes so disable GCSE on these\n-\t      for now.  */\n-\t   && ! find_reg_note (insn, REG_EH_REGION, NULL_RTX)\n+\t      do that easily for EH edges so disable GCSE on these for now.  */\n+\t   && !can_throw_internal (insn)\n \t   /* Is SET_DEST something we want to gcse?  */\n \t   && want_to_gcse_p (dest)\n \t   /* Don't CSE a nop.  */"}, {"sha": "69fa68ddb42e038e92071428feef0c8bebdd8a31", "filename": "gcc/gengtype.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -1567,7 +1567,8 @@ open_base_files (void)\n       \"hard-reg-set.h\", \"basic-block.h\", \"cselib.h\", \"insn-addr.h\",\n       \"optabs.h\", \"libfuncs.h\", \"debug.h\", \"ggc.h\", \"cgraph.h\",\n       \"tree-flow.h\", \"reload.h\", \"cpp-id-data.h\", \"tree-chrec.h\",\n-      \"cfglayout.h\", \"except.h\", \"output.h\", \"gimple.h\", \"cfgloop.h\", NULL\n+      \"cfglayout.h\", \"except.h\", \"output.h\", \"gimple.h\", \"cfgloop.h\",\n+      \"target.h\", NULL\n     };\n     const char *const *ifp;\n     outf_p gtype_desc_c;"}, {"sha": "66927d67c2c88f42b52d968980b9600796bae47e", "filename": "gcc/gimple-iterator.c", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fgimple-iterator.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fgimple-iterator.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-iterator.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -363,7 +363,6 @@ gsi_split_seq_before (gimple_stmt_iterator *i)\n void\n gsi_replace (gimple_stmt_iterator *gsi, gimple stmt, bool update_eh_info)\n {\n-  int eh_region;\n   gimple orig_stmt = gsi_stmt (*gsi);\n \n   if (stmt == orig_stmt)\n@@ -375,14 +374,7 @@ gsi_replace (gimple_stmt_iterator *gsi, gimple stmt, bool update_eh_info)\n   /* Preserve EH region information from the original statement, if\n      requested by the caller.  */\n   if (update_eh_info)\n-    {\n-      eh_region = lookup_stmt_eh_region (orig_stmt);\n-      if (eh_region >= 0)\n-\t{\n-\t  remove_stmt_from_eh_region (orig_stmt);\n-\t  add_stmt_to_eh_region (stmt, eh_region);\n-\t}\n-    }\n+    maybe_clean_or_replace_eh_stmt (orig_stmt, stmt);\n \n   gimple_duplicate_stmt_histograms (cfun, stmt, cfun, orig_stmt);\n   gimple_remove_stmt_histograms (cfun, orig_stmt);\n@@ -485,7 +477,7 @@ gsi_remove (gimple_stmt_iterator *i, bool remove_permanently)\n \n   if (remove_permanently)\n     {\n-      remove_stmt_from_eh_region (stmt);\n+      remove_stmt_from_eh_lp (stmt);\n       gimple_remove_stmt_histograms (cfun, stmt);\n     }\n "}, {"sha": "b58fd7b42f5f5df9d53ff9be195fc009d290eb21", "filename": "gcc/gimple-low.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fgimple-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fgimple-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -360,6 +360,7 @@ lower_stmt (gimple_stmt_iterator *gsi, struct lower_data *data)\n     case GIMPLE_PREDICT:\n     case GIMPLE_LABEL:\n     case GIMPLE_SWITCH:\n+    case GIMPLE_EH_MUST_NOT_THROW:\n     case GIMPLE_OMP_FOR:\n     case GIMPLE_OMP_SECTIONS:\n     case GIMPLE_OMP_SECTIONS_SWITCH:\n@@ -497,8 +498,8 @@ try_catch_may_fallthru (const_tree stmt)\n     default:\n       /* This case represents statements to be executed when an\n \t exception occurs.  Those statements are implicitly followed\n-\t by a RESX_EXPR to resume execution after the exception.  So\n-\t in this case the TRY_CATCH never falls through.  */\n+\t by a RESX statement to resume execution after the exception.\n+\t So in this case the TRY_CATCH never falls through.  */\n       return false;\n     }\n }\n@@ -571,7 +572,6 @@ block_may_fallthru (const_tree block)\n     {\n     case GOTO_EXPR:\n     case RETURN_EXPR:\n-    case RESX_EXPR:\n       /* Easy cases.  If the last statement of the block implies \n \t control transfer, then we can't fall through.  */\n       return false;"}, {"sha": "8903c66195600ecf29faa23021a06fbd2231dd14", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 44, "deletions": 4, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -626,6 +626,8 @@ dump_gimple_label (pretty_printer *buffer, gimple gs, int spc, int flags)\n     }\n   if (DECL_NONLOCAL (label))\n     pp_string (buffer, \" [non-local]\");\n+  if ((flags & TDF_EH) && EH_LANDING_PAD_NR (label))\n+    pp_printf (buffer, \" [LP %d]\", EH_LANDING_PAD_NR (label));\n }\n \n /* Dump a GIMPLE_GOTO tuple on the pretty_printer BUFFER, SPC\n@@ -766,6 +768,21 @@ dump_gimple_eh_filter (pretty_printer *buffer, gimple gs, int spc, int flags)\n }\n \n \n+/* Dump a GIMPLE_EH_MUST_NOT_THROW tuple.  */\n+\n+static void\n+dump_gimple_eh_must_not_throw (pretty_printer *buffer, gimple gs,\n+\t\t\t       int spc, int flags)\n+{\n+  if (flags & TDF_RAW)\n+    dump_gimple_fmt (buffer, spc, flags, \"%G <%T>\", gs,\n+\t\t     gimple_eh_must_not_throw_fndecl (gs));\n+  else\n+    dump_gimple_fmt (buffer, spc, flags, \"<<<eh_must_not_throw (%T)>>>\",\n+\t\t     gimple_eh_must_not_throw_fndecl (gs));\n+}\n+\n+\n /* Dump a GIMPLE_RESX tuple on the pretty_printer BUFFER, SPC spaces of\n    indent.  FLAGS specifies details to show in the dump (see TDF_* in\n    tree-pass.h).  */\n@@ -775,11 +792,24 @@ dump_gimple_resx (pretty_printer *buffer, gimple gs, int spc, int flags)\n {\n   if (flags & TDF_RAW)\n     dump_gimple_fmt (buffer, spc, flags, \"%G <%d>\", gs,\n-                     gimple_resx_region (gs));\n+\t\t     gimple_resx_region (gs));\n   else\n     dump_gimple_fmt (buffer, spc, flags, \"resx %d\", gimple_resx_region (gs));\n }\n \n+/* Dump a GIMPLE_EH_DISPATCH tuple on the pretty_printer BUFFER.  */\n+\n+static void\n+dump_gimple_eh_dispatch (pretty_printer *buffer, gimple gs, int spc, int flags)\n+{\n+  if (flags & TDF_RAW)\n+    dump_gimple_fmt (buffer, spc, flags, \"%G <%d>\", gs,\n+\t\t     gimple_eh_dispatch_region (gs));\n+  else\n+    dump_gimple_fmt (buffer, spc, flags, \"eh_dispatch %d\",\n+\t\t     gimple_eh_dispatch_region (gs));\n+}\n+\n /* Dump a GIMPLE_DEBUG tuple on the pretty_printer BUFFER, SPC spaces\n    of indent.  FLAGS specifies details to show in the dump (see TDF_*\n    in tree-pass.h).  */\n@@ -1427,9 +1457,11 @@ dump_gimple_stmt (pretty_printer *buffer, gimple gs, int spc, int flags)\n \n   if (flags & TDF_EH)\n     {\n-      int eh_region = lookup_stmt_eh_region_fn (cfun, gs);\n-      if (eh_region >= 0)\n-\tpp_printf (buffer, \"[EH #%d] \", eh_region);\n+      int lp_nr = lookup_stmt_eh_lp (gs);\n+      if (lp_nr > 0)\n+\tpp_printf (buffer, \"[LP %d] \", lp_nr);\n+      else if (lp_nr < 0)\n+\tpp_printf (buffer, \"[MNT %d] \", -lp_nr);\n     }\n \n   if ((flags & (TDF_VOPS|TDF_MEMSYMS))\n@@ -1545,10 +1577,18 @@ dump_gimple_stmt (pretty_printer *buffer, gimple gs, int spc, int flags)\n       dump_gimple_eh_filter (buffer, gs, spc, flags);\n       break;\n \n+    case GIMPLE_EH_MUST_NOT_THROW:\n+      dump_gimple_eh_must_not_throw (buffer, gs, spc, flags);\n+      break;\n+\n     case GIMPLE_RESX:\n       dump_gimple_resx (buffer, gs, spc, flags);\n       break;\n \n+    case GIMPLE_EH_DISPATCH:\n+      dump_gimple_eh_dispatch (buffer, gs, spc, flags);\n+      break;\n+\n     case GIMPLE_DEBUG:\n       dump_gimple_debug (buffer, gs, spc, flags);\n       break;"}, {"sha": "33daafc6ad0b7795cb145b53ef5694ea0c38cf42", "filename": "gcc/gimple.c", "status": "modified", "additions": 42, "deletions": 31, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -627,6 +627,20 @@ gimple_build_eh_filter (tree types, gimple_seq failure)\n   return p;\n }\n \n+/* Build a GIMPLE_EH_MUST_NOT_THROW statement.  */\n+\n+gimple\n+gimple_build_eh_must_not_throw (tree decl)\n+{\n+  gimple p = gimple_alloc (GIMPLE_EH_MUST_NOT_THROW, 1);\n+\n+  gcc_assert (TREE_CODE (decl) == FUNCTION_DECL);\n+  gcc_assert (flags_from_decl_or_type (decl) & ECF_NORETURN);\n+  p->gimple_eh_mnt.fndecl = decl;\n+\n+  return p;\n+}\n+\n /* Build a GIMPLE_TRY statement.\n \n    EVAL is the expression to evaluate.\n@@ -666,16 +680,13 @@ gimple_build_wce (gimple_seq cleanup)\n }\n \n \n-/* Build a GIMPLE_RESX statement.\n-\n-   REGION is the region number from which this resx causes control flow to \n-   leave.  */\n+/* Build a GIMPLE_RESX statement.  */\n \n gimple\n gimple_build_resx (int region)\n {\n-  gimple p = gimple_alloc (GIMPLE_RESX, 0);\n-  gimple_resx_set_region (p, region);\n+  gimple p = gimple_build_with_ops (GIMPLE_RESX, ERROR_MARK, 0);\n+  p->gimple_eh_ctrl.region = region;\n   return p;\n }\n \n@@ -685,14 +696,15 @@ gimple_build_resx (int region)\n    NLABELS is the number of labels in the switch excluding the default.\n    DEFAULT_LABEL is the default label for the switch statement.  */\n \n-static inline gimple \n-gimple_build_switch_1 (unsigned nlabels, tree index, tree default_label)\n+gimple \n+gimple_build_switch_nlabels (unsigned nlabels, tree index, tree default_label)\n {\n   /* nlabels + 1 default label + 1 index.  */\n   gimple p = gimple_build_with_ops (GIMPLE_SWITCH, ERROR_MARK,\n-\t\t\t\t    nlabels + 1 + 1);\n+\t\t\t\t    1 + (default_label != NULL) + nlabels);\n   gimple_switch_set_index (p, index);\n-  gimple_switch_set_default_label (p, default_label);\n+  if (default_label)\n+    gimple_switch_set_default_label (p, default_label);\n   return p;\n }\n \n@@ -707,15 +719,14 @@ gimple\n gimple_build_switch (unsigned nlabels, tree index, tree default_label, ...)\n {\n   va_list al;\n-  unsigned i;\n-  gimple p;\n-  \n-  p = gimple_build_switch_1 (nlabels, index, default_label);\n+  unsigned i, offset;\n+  gimple p = gimple_build_switch_nlabels (nlabels, index, default_label);\n \n   /* Store the rest of the labels.  */\n   va_start (al, default_label);\n-  for (i = 1; i <= nlabels; i++)\n-    gimple_switch_set_label (p, i, va_arg (al, tree));\n+  offset = (default_label != NULL);\n+  for (i = 0; i < nlabels; i++)\n+    gimple_switch_set_label (p, i + offset, va_arg (al, tree));\n   va_end (al);\n \n   return p;\n@@ -731,18 +742,26 @@ gimple_build_switch (unsigned nlabels, tree index, tree default_label, ...)\n gimple\n gimple_build_switch_vec (tree index, tree default_label, VEC(tree, heap) *args)\n {\n-  unsigned i;\n-  unsigned nlabels = VEC_length (tree, args);\n-  gimple p = gimple_build_switch_1 (nlabels, index, default_label);\n+  unsigned i, offset, nlabels = VEC_length (tree, args);\n+  gimple p = gimple_build_switch_nlabels (nlabels, index, default_label);\n \n-  /*  Put labels in labels[1 - (nlabels + 1)].\n-     Default label is in labels[0].  */\n-  for (i = 1; i <= nlabels; i++)\n-    gimple_switch_set_label (p, i, VEC_index (tree, args, i - 1));\n+  /* Copy the labels from the vector to the switch statement.  */\n+  offset = (default_label != NULL);\n+  for (i = 0; i < nlabels; i++)\n+    gimple_switch_set_label (p, i + offset, VEC_index (tree, args, i));\n \n   return p;\n }\n \n+/* Build a GIMPLE_EH_DISPATCH statement.  */\n+\n+gimple\n+gimple_build_eh_dispatch (int region)\n+{\n+  gimple p = gimple_build_with_ops (GIMPLE_EH_DISPATCH, ERROR_MARK, 0);\n+  p->gimple_eh_ctrl.region = region;\n+  return p;\n+}\n \n /* Build a new GIMPLE_DEBUG_BIND statement.\n \n@@ -2394,9 +2413,7 @@ get_gimple_rhs_num_ops (enum tree_code code)\n       || (SYM) == ASSERT_EXPR\t\t\t\t\t\t    \\\n       || (SYM) == ADDR_EXPR\t\t\t\t\t\t    \\\n       || (SYM) == WITH_SIZE_EXPR\t\t\t\t\t    \\\n-      || (SYM) == EXC_PTR_EXPR\t\t\t\t\t\t    \\\n       || (SYM) == SSA_NAME\t\t\t\t\t\t    \\\n-      || (SYM) == FILTER_EXPR\t\t\t\t\t\t    \\\n       || (SYM) == POLYNOMIAL_CHREC\t\t\t\t\t    \\\n       || (SYM) == DOT_PROD_EXPR\t\t\t\t\t\t    \\\n       || (SYM) == VEC_COND_EXPR\t\t\t\t\t\t    \\\n@@ -2658,7 +2675,6 @@ is_gimple_stmt (tree t)\n     case EH_FILTER_EXPR:\n     case CATCH_EXPR:\n     case ASM_EXPR:\n-    case RESX_EXPR:\n     case STATEMENT_LIST:\n     case OMP_PARALLEL:\n     case OMP_FOR:\n@@ -2784,11 +2800,6 @@ is_gimple_val (tree t)\n       && !is_gimple_reg (t))\n     return false;\n \n-  /* FIXME make these decls.  That can happen only when we expose the\n-     entire landing-pad construct at the tree level.  */\n-  if (TREE_CODE (t) == EXC_PTR_EXPR || TREE_CODE (t) == FILTER_EXPR)\n-    return true;\n-\n   return (is_gimple_variable (t) || is_gimple_min_invariant (t));\n }\n "}, {"sha": "603d97eeafc1d2e0ff19cb911eff2324fa9ac066", "filename": "gcc/gimple.def", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fgimple.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fgimple.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.def?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -1,6 +1,6 @@\n /* This file contains the definitions of the GIMPLE IR tuples used in GCC.\n \n-   Copyright (C) 2007, 2008 Free Software Foundation, Inc.\n+   Copyright (C) 2007, 2008, 2009 Free Software Foundation, Inc.\n    Contributed by Aldy Hernandez <aldyh@redhat.com>\n \n This file is part of GCC.\n@@ -145,6 +145,18 @@ DEFGSCODE(GIMPLE_CATCH, \"gimple_catch\", GSS_CATCH)\n    sequence of statements to execute on failure.  */\n DEFGSCODE(GIMPLE_EH_FILTER, \"gimple_eh_filter\", GSS_EH_FILTER)\n \n+/* GIMPLE_EH_MUST_NOT_THROW <DECL> represents an exception barrier.\n+   DECL is a noreturn function decl taking no arguments that will\n+   be invoked if an exception propagates to this point.  */\n+DEFGSCODE(GIMPLE_EH_MUST_NOT_THROW, \"gimple_eh_must_not_throw\", GSS_EH_MNT)\n+\n+/* GIMPLE_RESX resumes execution after an exception.  */\n+DEFGSCODE(GIMPLE_RESX, \"gimple_resx\", GSS_EH_CTRL)\n+\n+/* GIMPLE_EH_DISPATCH demultiplexes an exception edge based on\n+   the FILTER argument.  */\n+DEFGSCODE(GIMPLE_EH_DISPATCH, \"gimple_eh_dispatch\", GSS_EH_CTRL)\n+\n /* GIMPLE_PHI <RESULT, ARG1, ..., ARGN> represents the PHI node\n \n    RESULT = PHI <ARG1, ..., ARGN>\n@@ -157,10 +169,6 @@ DEFGSCODE(GIMPLE_EH_FILTER, \"gimple_eh_filter\", GSS_EH_FILTER)\n    tree node of class tcc_constant.  */\n DEFGSCODE(GIMPLE_PHI, \"gimple_phi\", GSS_PHI)\n \n-/* GIMPLE_RESX <REGION> resumes execution after an exception.\n-   REGION is the region number being left.  */\n-DEFGSCODE(GIMPLE_RESX, \"gimple_resx\", GSS_RESX)\n-\n /* GIMPLE_TRY <TRY_KIND, EVAL, CLEANUP>\n    represents a try/catch or a try/finally statement.\n "}, {"sha": "b5396235f6be4e0bb23fab20d1611ffad2019a22", "filename": "gcc/gimple.h", "status": "modified", "additions": 50, "deletions": 24, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -444,9 +444,6 @@ struct GTY(()) gimple_statement_eh_filter {\n   /* [ WORD 1-4 ]  */\n   struct gimple_statement_base gsbase;\n \n-  /* Subcode: EH_FILTER_MUST_NOT_THROW.  A boolean flag analogous to\n-     the tree counterpart.  */\n-\n   /* [ WORD 5 ]\n      Filter types.  */\n   tree types;\n@@ -457,6 +454,16 @@ struct GTY(()) gimple_statement_eh_filter {\n };\n \n \n+/* GIMPLE_EH_MUST_NOT_THROW */\n+\n+struct GTY(()) gimple_statement_eh_mnt {\n+  /* [ WORD 1-4 ]  */\n+  struct gimple_statement_base gsbase;\n+\n+  /* [ WORD 5 ] Abort function decl.  */\n+  tree fndecl;\n+};\n+\n /* GIMPLE_PHI */\n \n struct GTY(()) gimple_statement_phi {\n@@ -475,9 +482,10 @@ struct GTY(()) gimple_statement_phi {\n };\n \n \n-/* GIMPLE_RESX */\n+/* GIMPLE_RESX, GIMPLE_EH_DISPATCH */\n \n-struct GTY(()) gimple_statement_resx {\n+struct GTY(()) gimple_statement_eh_ctrl\n+{\n   /* [ WORD 1-4 ]  */\n   struct gimple_statement_base gsbase;\n \n@@ -733,8 +741,9 @@ union GTY ((desc (\"gimple_statement_structure (&%h)\"))) gimple_statement_d {\n   struct gimple_statement_bind GTY ((tag (\"GSS_BIND\"))) gimple_bind;\n   struct gimple_statement_catch GTY ((tag (\"GSS_CATCH\"))) gimple_catch;\n   struct gimple_statement_eh_filter GTY ((tag (\"GSS_EH_FILTER\"))) gimple_eh_filter;\n+  struct gimple_statement_eh_mnt GTY ((tag (\"GSS_EH_MNT\"))) gimple_eh_mnt;\n   struct gimple_statement_phi GTY ((tag (\"GSS_PHI\"))) gimple_phi;\n-  struct gimple_statement_resx GTY ((tag (\"GSS_RESX\"))) gimple_resx;\n+  struct gimple_statement_eh_ctrl GTY ((tag (\"GSS_EH_CTRL\"))) gimple_eh_ctrl;\n   struct gimple_statement_try GTY ((tag (\"GSS_TRY\"))) gimple_try;\n   struct gimple_statement_wce GTY ((tag (\"GSS_WCE\"))) gimple_wce;\n   struct gimple_statement_asm GTY ((tag (\"GSS_ASM\"))) gimple_asm;\n@@ -788,9 +797,12 @@ gimple gimple_build_asm_vec (const char *, VEC(tree,gc) *, VEC(tree,gc) *,\n                              VEC(tree,gc) *);\n gimple gimple_build_catch (tree, gimple_seq);\n gimple gimple_build_eh_filter (tree, gimple_seq);\n+gimple gimple_build_eh_must_not_throw (tree);\n gimple gimple_build_try (gimple_seq, gimple_seq, enum gimple_try_flags);\n gimple gimple_build_wce (gimple_seq);\n gimple gimple_build_resx (int);\n+gimple gimple_build_eh_dispatch (int);\n+gimple gimple_build_switch_nlabels (unsigned, tree, tree);\n gimple gimple_build_switch (unsigned, tree, tree, ...);\n gimple gimple_build_switch_vec (tree, tree, VEC(tree,heap) *);\n gimple gimple_build_omp_parallel (gimple_seq, tree, tree, tree);\n@@ -2863,26 +2875,15 @@ gimple_eh_filter_set_failure (gimple gs, gimple_seq failure)\n   gs->gimple_eh_filter.failure = failure;\n }\n \n-/* Return the EH_FILTER_MUST_NOT_THROW flag.  */\n+/* Get the function decl to be called by the MUST_NOT_THROW region.  */\n \n-static inline bool\n-\n-gimple_eh_filter_must_not_throw (gimple gs)\n-{\n-  GIMPLE_CHECK (gs, GIMPLE_EH_FILTER);\n-  return gs->gsbase.subcode != 0;\n-}\n-\n-/* Set the EH_FILTER_MUST_NOT_THROW flag to the value MNTP.  */\n-\n-static inline void\n-gimple_eh_filter_set_must_not_throw (gimple gs, bool mntp)\n+static inline tree\n+gimple_eh_must_not_throw_fndecl (gimple gs)\n {\n-  GIMPLE_CHECK (gs, GIMPLE_EH_FILTER);\n-  gs->gsbase.subcode = (unsigned int) mntp;\n+  GIMPLE_CHECK (gs, GIMPLE_EH_MUST_NOT_THROW);\n+  return gs->gimple_eh_mnt.fndecl;\n }\n \n-\n /* GIMPLE_TRY accessors. */\n \n /* Return the kind of try block represented by GIMPLE_TRY GS.  This is\n@@ -3092,7 +3093,7 @@ static inline int\n gimple_resx_region (const_gimple gs)\n {\n   GIMPLE_CHECK (gs, GIMPLE_RESX);\n-  return gs->gimple_resx.region;\n+  return gs->gimple_eh_ctrl.region;\n }\n \n /* Set REGION to be the region number for GIMPLE_RESX GS.  */\n@@ -3101,9 +3102,26 @@ static inline void\n gimple_resx_set_region (gimple gs, int region)\n {\n   GIMPLE_CHECK (gs, GIMPLE_RESX);\n-  gs->gimple_resx.region = region;\n+  gs->gimple_eh_ctrl.region = region;\n }\n \n+/* Return the region number for GIMPLE_EH_DISPATCH GS.  */\n+\n+static inline int\n+gimple_eh_dispatch_region (const_gimple gs)\n+{\n+  GIMPLE_CHECK (gs, GIMPLE_EH_DISPATCH);\n+  return gs->gimple_eh_ctrl.region;\n+}\n+\n+/* Set REGION to be the region number for GIMPLE_EH_DISPATCH GS.  */\n+\n+static inline void\n+gimple_eh_dispatch_set_region (gimple gs, int region)\n+{\n+  GIMPLE_CHECK (gs, GIMPLE_EH_DISPATCH);\n+  gs->gimple_eh_ctrl.region = region;\n+}\n \n /* Return the number of labels associated with the switch statement GS.  */\n \n@@ -4253,6 +4271,14 @@ gimple_nop_p (const_gimple g)\n }\n \n \n+/* Return true if GS is a GIMPLE_RESX.  */\n+\n+static inline bool\n+is_gimple_resx (const_gimple gs)\n+{\n+  return gimple_code (gs) == GIMPLE_RESX;\n+}\n+\n /* Return the predictor of GIMPLE_PREDICT statement GS.  */\n \n static inline enum br_predictor"}, {"sha": "381e611bc8f330b3151a327b961a216d2b0a7cde", "filename": "gcc/gimplify.c", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -6645,11 +6645,6 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t  ret = gimplify_decl_expr (expr_p, pre_p);\n \t  break;\n \n-\tcase EXC_PTR_EXPR:\n-\t  /* FIXME make this a decl.  */\n-\t  ret = GS_ALL_DONE;\n-\t  break;\n-\n \tcase BIND_EXPR:\n \t  ret = gimplify_bind_expr (expr_p, pre_p);\n \t  break;\n@@ -6841,8 +6836,6 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t    gimplify_and_add (EH_FILTER_FAILURE (*expr_p), &failure);\n \t    ehf = gimple_build_eh_filter (EH_FILTER_TYPES (*expr_p), failure);\n \t    gimple_set_no_warning (ehf, TREE_NO_WARNING (*expr_p));\n-\t    gimple_eh_filter_set_must_not_throw\n-\t      (ehf, EH_FILTER_MUST_NOT_THROW (*expr_p));\n \t    gimplify_seq_add_stmt (pre_p, ehf);\n \t    ret = GS_ALL_DONE;\n \t    break;\n@@ -7178,7 +7171,6 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t\t  && code != GOTO_EXPR\n \t\t  && code != LABEL_EXPR\n \t\t  && code != LOOP_EXPR\n-\t\t  && code != RESX_EXPR\n \t\t  && code != SWITCH_EXPR\n \t\t  && code != TRY_FINALLY_EXPR\n \t\t  && code != OMP_CRITICAL"}, {"sha": "29cb90d913c65cc456a3b4cc55d653a5afb994ec", "filename": "gcc/gsstruct.def", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fgsstruct.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fgsstruct.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgsstruct.def?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -34,7 +34,8 @@ DEFGSSTRUCT(GSS_PHI, gimple_statement_phi, false)\n DEFGSSTRUCT(GSS_TRY, gimple_statement_try, false)\n DEFGSSTRUCT(GSS_CATCH, gimple_statement_catch, false)\n DEFGSSTRUCT(GSS_EH_FILTER, gimple_statement_eh_filter, false)\n-DEFGSSTRUCT(GSS_RESX, gimple_statement_resx, false)\n+DEFGSSTRUCT(GSS_EH_MNT, gimple_statement_eh_mnt, false)\n+DEFGSSTRUCT(GSS_EH_CTRL, gimple_statement_eh_ctrl, false)\n DEFGSSTRUCT(GSS_WCE, gimple_statement_wce, false)\n DEFGSSTRUCT(GSS_OMP, gimple_statement_omp, false)\n DEFGSSTRUCT(GSS_OMP_CRITICAL, gimple_statement_omp_critical, false)"}, {"sha": "c6bbece3ace8107a8063419c96fd0088ce62c953", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 8, "deletions": 25, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -1735,7 +1735,6 @@ estimate_function_body_sizes (struct cgraph_node *node)\n   tree arg;\n   int freq;\n   tree funtype = TREE_TYPE (node->decl);\n-  bitmap must_not_throw = must_not_throw_labels ();\n \n   if (dump_file)\n     {\n@@ -1748,35 +1747,20 @@ estimate_function_body_sizes (struct cgraph_node *node)\n       freq = compute_call_stmt_bb_frequency (node->decl, bb);\n       for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n \t{\n-\t  int this_size = estimate_num_insns (gsi_stmt (bsi), &eni_size_weights);\n-\t  int this_time = estimate_num_insns (gsi_stmt (bsi), &eni_time_weights);\n-\n-\t  /* MUST_NOT_THROW is usually handled by runtime calling terminate and stopping\n-\t     stacking unwinding.  However when there is local cleanup that can resume\n-\t     to MUST_NOT_THROW then we generate explicit handler containing\n-\t     std::terminate () call.\n-\t     \n-\t     Because inlining of function can introduce new cleanup region, prior\n-\t     inlining we keep std::terinate () calls for every MUST_NOT_THROW containing\n-\t     function call.  Wast majority of these will be eliminated after inlining\n-\t     and crossjumping will inify possible duplicated calls.  So ignore\n-\t     the handlers for function body estimates.  */\n-\t  if (gimple_code (gsi_stmt (bsi)) == GIMPLE_LABEL\n-\t      && bitmap_bit_p (must_not_throw, \n-\t      \t\t       LABEL_DECL_UID (gimple_label_label (gsi_stmt (bsi)))))\n-\t    {\n-\t      if (dump_file)\n-\t        fprintf (dump_file, \"  MUST_NOT_THROW landing pad.  Ignoring whole BB.\\n\");\n-\t    }\n+\t  gimple stmt = gsi_stmt (bsi);\n+\t  int this_size = estimate_num_insns (stmt, &eni_size_weights);\n+\t  int this_time = estimate_num_insns (stmt, &eni_time_weights);\n+\n \t  if (dump_file)\n \t    {\n-\t      fprintf (dump_file, \"  freq:%6i size:%3i time:%3i \", freq, this_size, this_time);\n-\t      print_gimple_stmt (dump_file, gsi_stmt (bsi), 0, 0);\n+\t      fprintf (dump_file, \"  freq:%6i size:%3i time:%3i \",\n+\t\t       freq, this_size, this_time);\n+\t      print_gimple_stmt (dump_file, stmt, 0, 0);\n \t    }\n \t  this_time *= freq;\n \t  time += this_time;\n \t  size += this_size;\n-\t  if (likely_eliminated_by_inlining_p (gsi_stmt (bsi)))\n+\t  if (likely_eliminated_by_inlining_p (stmt))\n \t    {\n \t      size_inlining_benefit += this_size;\n \t      time_inlining_benefit += this_time;\n@@ -1825,7 +1809,6 @@ estimate_function_body_sizes (struct cgraph_node *node)\n     }\n   inline_summary (node)->time_inlining_benefit = time_inlining_benefit;\n   inline_summary (node)->size_inlining_benefit = size_inlining_benefit;\n-  BITMAP_FREE (must_not_throw);\n }\n \n /* Compute parameters of functions used by inliner.  */"}, {"sha": "e5ff3a7725346121b75c31e7aa92aa44b4585f99", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -346,8 +346,8 @@ check_call (funct_state local, gimple call, bool ipa)\n         {\n \t  if (dump_file)\n \t    {\n-\t      fprintf (dump_file, \"    can throw externally in region %i\\n\",\n-\t      \t       lookup_stmt_eh_region (call));\n+\t      fprintf (dump_file, \"    can throw externally to lp %i\\n\",\n+\t      \t       lookup_stmt_eh_lp (call));\n \t      if (callee_t)\n \t\tfprintf (dump_file, \"     callee:%s\\n\",\n \t\t\t IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (callee_t)));"}, {"sha": "edfaab0a0f89668330223bf81925147e8d30b6a2", "filename": "gcc/ipa-type-escape.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fipa-type-escape.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fipa-type-escape.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-type-escape.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -1128,9 +1128,6 @@ check_operand (tree t)\n static void\n check_tree (tree t)\n {\n-  if ((TREE_CODE (t) == EXC_PTR_EXPR) || (TREE_CODE (t) == FILTER_EXPR))\n-    return;\n-\n   /* We want to catch here also REALPART_EXPR and IMAGEPART_EXPR,\n      but they already included in handled_component_p.  */\n   while (handled_component_p (t))"}, {"sha": "0b7ec66ab2c04206d785262aa6d30e82c3284d88", "filename": "gcc/ipa-utils.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fipa-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fipa-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -215,10 +215,6 @@ ipa_utils_reduced_inorder (struct cgraph_node **order,\n tree\n get_base_var (tree t)\n {\n-  if (TREE_CODE (t) == EXC_PTR_EXPR\n-      || TREE_CODE (t) == FILTER_EXPR)\n-    return t;\n-\n   while (!SSA_VAR_P (t) \n \t && (!CONSTANT_CLASS_P (t))\n \t && TREE_CODE (t) != LABEL_DECL"}, {"sha": "6c58a99b4c171869a6d7cd3cc23c95c6397d9117", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -1,3 +1,16 @@\n+2009-09-14  Richard Henderson  <rth@redhat.com>\n+\n+\t* builtins.c (initialize_builtins): Update call to\n+\tbuild_common_builtin_nodes.\n+\t* decl.c (java_init_decl_processing): Don't call\n+\tdefault_init_unwind_resume_libfunc.\n+\t* except.c: Include tree-iterator.h.\n+\t(build_exception_object_var): New.\n+\t(build_exception_object_ref): Use it.\n+\t(expand_end_java_handler): Initialize it from __builtin_eh_pointer.\n+\tAttach all CATCH_EXPRs to a single TRY_CATCH_EXPR.\n+\t* java-tree.h (DECL_FUNCTION_EXC_OBJ): New.\n+\n 2009-09-13  Richard Guenther  <rguenther@suse.de>\n \tRafael Avila de Espindola  <espindola@google.com>\n "}, {"sha": "a05ff53ceb99c93e8922d37809584817e76541f7", "filename": "gcc/java/builtins.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fjava%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fjava%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fbuiltins.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -584,7 +584,7 @@ initialize_builtins (void)\n \t\t  build_function_type_list (ptr_type_node, int_type_node, NULL_TREE),\n \t\t  \"__builtin_return_address\", BUILTIN_NOTHROW);\n \n-  build_common_builtin_nodes ();\n+  build_common_builtin_nodes (true);\n }\n \n /* If the call matches a builtin, return the"}, {"sha": "c593b53df5cef54c1a6c03fb44e1947a7f06a7d1", "filename": "gcc/java/decl.c", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -1,7 +1,7 @@\n /* Process declarations and variables for the GNU compiler for the\n    Java(TM) language.\n    Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2007,\n-   2005, 2006, 2007, 2008 Free Software Foundation, Inc.\n+   2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -1188,14 +1188,8 @@ java_init_decl_processing (void)\n \t\t\t    build_function_type (long_type_node, t),\n \t\t\t    0, NOT_BUILT_IN, NULL, NULL_TREE);\n \n-  /* Initialize variables for except.c.  */\n-\n-  if (targetm.arm_eabi_unwinder)\n-    unwind_resume_libfunc = init_one_libfunc (\"__cxa_end_cleanup\");\n-  else\n-    default_init_unwind_resume_libfunc ();\n-\n   initialize_builtins ();\n+\n   soft_fmod_node = built_in_decls[BUILT_IN_FMOD];\n \n   parse_version ();"}, {"sha": "4e4651421d491936c3b693e550935ad187d36edc", "filename": "gcc/java/except.c", "status": "modified", "additions": 64, "deletions": 22, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fjava%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fjava%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexcept.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -1,6 +1,6 @@\n /* Handle exceptions for GNU compiler for the Java(TM) language.\n    Copyright (C) 1997, 1998, 1999, 2000, 2002, 2003, 2004, 2005,\n-   2007, 2008 Free Software Foundation, Inc.\n+   2007, 2008, 2009 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -37,6 +37,8 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #include \"except.h\"\n #include \"java-except.h\"\n #include \"toplev.h\"\n+#include \"tree-iterator.h\"\n+\n \n static void expand_start_java_handler (struct eh_range *);\n static struct eh_range *find_handler_in_range (int, struct eh_range *,\n@@ -457,6 +459,26 @@ java_expand_catch_classes (tree this_class)\n        expand_catch_class, NULL);\n }\n \n+/* Build and push the variable that will hold the exception object\n+   within this function.  */\n+\n+static tree\n+build_exception_object_var (void)\n+{\n+  tree decl = DECL_FUNCTION_EXC_OBJ (current_function_decl);\n+  if (decl == NULL)\n+    {\n+      decl = build_decl (DECL_SOURCE_LOCATION (current_function_decl),\n+\t\t\t VAR_DECL, get_identifier (\"#exc_obj\"), ptr_type_node);\n+      DECL_IGNORED_P (decl) = 1;\n+      DECL_ARTIFICIAL (decl) = 1;\n+\n+      DECL_FUNCTION_EXC_OBJ (current_function_decl) = decl;\n+      pushdecl_function_level (decl);\n+    }\n+  return decl;\n+}\n+\n /* Build a reference to the jthrowable object being carried in the\n    exception header.  */\n \n@@ -467,7 +489,8 @@ build_exception_object_ref (tree type)\n \n   /* Java only passes object via pointer and doesn't require adjusting.\n      The java object is immediately before the generic exception header.  */\n-  obj = build0 (EXC_PTR_EXPR, build_pointer_type (type));\n+  obj = build_exception_object_var ();\n+  obj = fold_convert (build_pointer_type (type), obj);\n   obj = build2 (POINTER_PLUS_EXPR, TREE_TYPE (obj), obj,\n \t\tfold_build1 (NEGATE_EXPR, sizetype,\n \t\t\t     TYPE_SIZE_UNIT (TREE_TYPE (obj))));\n@@ -482,29 +505,48 @@ void\n expand_end_java_handler (struct eh_range *range)\n {  \n   tree handler = range->handlers;\n-\n-  for ( ; handler != NULL_TREE; handler = TREE_CHAIN (handler))\n+  if (handler)\n     {\n-      /* For bytecode we treat exceptions a little unusually.  A\n-\t `finally' clause looks like an ordinary exception handler for\n-\t Throwable.  The reason for this is that the bytecode has\n-\t already expanded the finally logic, and we would have to do\n-\t extra (and difficult) work to get this to look like a\n-\t gcc-style finally clause.  */\n-      tree type = TREE_PURPOSE (handler);\n-      if (type == NULL)\n-\ttype = throwable_type_node;\n-      type = prepare_eh_table_type (type);\n+      tree exc_obj = build_exception_object_var ();\n+      tree catches = make_node (STATEMENT_LIST);\n+      tree_stmt_iterator catches_i = tsi_last (catches);\n+      tree *body;\n \n-      {\n-\ttree catch_expr = build2 (CATCH_EXPR, void_type_node, type,\n-\t\t\t\t  build1 (GOTO_EXPR, void_type_node,\n-\t\t\t\t\t  TREE_VALUE (handler)));\n-\ttree try_catch_expr = build2 (TRY_CATCH_EXPR, void_type_node,\n-\t\t\t\t      *get_stmts (), catch_expr);\t\n-\t*get_stmts () = try_catch_expr;\n-      }\n+      for (; handler; handler = TREE_CHAIN (handler))\n+\t{\n+\t  tree type, eh_type, x;\n+\t  tree stmts = make_node (STATEMENT_LIST);\n+\t  tree_stmt_iterator stmts_i = tsi_last (stmts);\n+\n+\t  type = TREE_PURPOSE (handler);\n+\t  if (type == NULL)\n+\t    type = throwable_type_node;\n+\t  eh_type = prepare_eh_table_type (type);\n+\n+\t  x = build_call_expr (built_in_decls[BUILT_IN_EH_POINTER],\n+\t\t\t\t1, integer_zero_node);\n+\t  x = build2 (MODIFY_EXPR, void_type_node, exc_obj, x);\n+\t  tsi_link_after (&stmts_i, x, TSI_CONTINUE_LINKING);\n+\n+\t  x = build1 (GOTO_EXPR, void_type_node, TREE_VALUE (handler));\n+\t  tsi_link_after (&stmts_i, x, TSI_CONTINUE_LINKING);\n+\n+\t  x = build2 (CATCH_EXPR, void_type_node, eh_type, stmts);\n+\t  tsi_link_after (&catches_i, x, TSI_CONTINUE_LINKING);\n+\n+\t  /* Throwable can match anything in Java, and therefore\n+\t     any subsequent handlers are unreachable.  */\n+\t  /* ??? If we're assured of no foreign language exceptions,\n+\t     we'd be better off using NULL as the exception type\n+\t     for the catch.  */\n+\t  if (type == throwable_type_node)\n+\t    break;\n+\t}\n+\n+      body = get_stmts ();\n+      *body = build2 (TRY_CATCH_EXPR, void_type_node, *body, catches);\n     }\n+\n #if defined(DEBUG_JAVA_BINDING_LEVELS)\n   indent ();\n   fprintf (stderr, \"expand end handler pc %d <-- %d\\n\","}, {"sha": "8ffe24229678facc66a2279dad1260b89cdabbe9", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -714,6 +714,8 @@ union GTY((desc (\"TREE_CODE (&%h.generic) == IDENTIFIER_NODE\"),\n /* List of checked thrown exceptions, as specified with the `throws'\n    keyword */\n #define DECL_FUNCTION_THROWS(DECL) (DECL_LANG_SPECIFIC(DECL)->u.f.throws_list)\n+/* VAR_DECL containing the caught exception object.  */\n+#define DECL_FUNCTION_EXC_OBJ(DECL) (DECL_LANG_SPECIFIC(DECL)->u.f.exc_obj)\n /* For each function decl, init_test_table contains a hash table whose\n    entries are keyed on class names, and whose values are local\n    boolean decls.  The variables are intended to be TRUE when the\n@@ -785,6 +787,7 @@ struct GTY(()) lang_decl_func {\n   int arg_slot_count;\n   source_location last_line;\t/* End line number for a function decl */\n   tree throws_list;\t\t/* Exception specified by `throws' */\n+  tree exc_obj;\t\t\t/* Decl holding the exception object.  */\n \n   /* Class initialization test variables  */\n   htab_t GTY ((param_is (struct treetreehash_entry))) init_test_table;"}, {"sha": "d3e69e3e2414a0d9808b7aaa3b76921660272686", "filename": "gcc/libfuncs.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Flibfuncs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Flibfuncs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibfuncs.h?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -30,7 +30,6 @@ enum libfunc_index\n   LTI_memset,\n   LTI_setbits,\n \n-  LTI_unwind_resume,\n   LTI_setjmp,\n   LTI_longjmp,\n   LTI_unwind_sjlj_register,\n@@ -59,7 +58,6 @@ extern GTY(()) rtx libfunc_table[LTI_MAX];\n #define memset_libfunc\t(libfunc_table[LTI_memset])\n #define setbits_libfunc\t(libfunc_table[LTI_setbits])\n \n-#define unwind_resume_libfunc\t(libfunc_table[LTI_unwind_resume])\n #define setjmp_libfunc\t(libfunc_table[LTI_setjmp])\n #define longjmp_libfunc\t(libfunc_table[LTI_longjmp])\n #define unwind_sjlj_register_libfunc (libfunc_table[LTI_unwind_sjlj_register])"}, {"sha": "3ce714b2bf8e54a02307c2a752c2c1b6ccabea98", "filename": "gcc/lower-subreg.c", "status": "modified", "additions": 1, "deletions": 25, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Flower-subreg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Flower-subreg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flower-subreg.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -559,30 +559,6 @@ adjust_decomposed_uses (rtx *px, void *data ATTRIBUTE_UNUSED)\n   return 0;\n }\n \n-/* We are deleting INSN.  Move any EH_REGION notes to INSNS.  */\n-\n-static void\n-move_eh_region_note (rtx insn, rtx insns)\n-{\n-  rtx note, p;\n-\n-  note = find_reg_note (insn, REG_EH_REGION, NULL_RTX);\n-  if (note == NULL_RTX)\n-    return;\n-\n-  gcc_assert (CALL_P (insn)\n-\t      || (flag_non_call_exceptions && may_trap_p (PATTERN (insn))));\n-\n-  for (p = insns; p != NULL_RTX; p = NEXT_INSN (p))\n-    {\n-      if (CALL_P (p)\n-\t  || (flag_non_call_exceptions\n-\t      && INSN_P (p)\n-\t      && may_trap_p (PATTERN (p))))\n-\tadd_reg_note (p, REG_EH_REGION, XEXP (note, 0));\n-    }\n-}\n-\n /* Resolve any decomposed registers which appear in register notes on\n    INSN.  */\n \n@@ -847,7 +823,7 @@ resolve_simple_move (rtx set, rtx insn)\n   insns = get_insns ();\n   end_sequence ();\n \n-  move_eh_region_note (insn, insns);\n+  copy_reg_eh_region_note_forward (insn, insns, NULL_RTX);\n \n   emit_insn_before (insns, insn);\n "}, {"sha": "70f841be2bacad1c8a0af5daedc16f1937e5f2c7", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -1,3 +1,9 @@\n+2009-09-14  Richard Henderson  <rth@redhat.com>\n+\n+\t* objc-act.c (objc_init_exceptions): Don't call\n+\tdefault_init_unwind_resume_libfunc.\n+\t(objc_build_exc_ptr): Use __builtin_eh_pointer.\n+\n 2009-09-13  Richard Guenther  <rguenther@suse.de>\n \tRafael Avila de Espindola  <espindola@google.com>\n "}, {"sha": "eac7ff02f0937de90b8abf12c83453cc0a8b625e", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -3475,7 +3475,7 @@ struct objc_try_context\n   /* The CATCH_EXPR of an open @catch clause.  */\n   tree current_catch;\n \n-  /* The VAR_DECL holding the Darwin equivalent of EXC_PTR_EXPR.  */\n+  /* The VAR_DECL holding the Darwin equivalent of __builtin_eh_pointer.  */\n   tree caught_decl;\n   tree stack_decl;\n   tree rethrow_decl;\n@@ -3510,9 +3510,9 @@ objc_eh_personality (void)\n }\n #endif\n \n-/* Build an EXC_PTR_EXPR, or the moral equivalent.  In the case of Darwin,\n-   we'll arrange for it to be initialized (and associated with a binding)\n-   later.  */\n+/* Build __builtin_eh_pointer, or the moral equivalent.  In the case\n+   of Darwin, we'll arrange for it to be initialized (and associated\n+   with a binding) later.  */\n \n static tree\n objc_build_exc_ptr (void)\n@@ -3528,7 +3528,12 @@ objc_build_exc_ptr (void)\n       return var;\n     }\n   else\n-    return build0 (EXC_PTR_EXPR, objc_object_type);\n+    {\n+      tree t;\n+      t = built_in_decls[BUILT_IN_EH_POINTER];\n+      t = build_call_expr (t, 1, integer_zero_node);\n+      return fold_convert (objc_object_type, t);\n+    }\n }\n \n /* Build \"objc_exception_try_exit(&_stack)\".  */"}, {"sha": "5cd9463c1226bbec42fba5c48e2a12409b8f680e", "filename": "gcc/omp-low.c", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -1214,7 +1214,7 @@ new_omp_context (gimple stmt, omp_context *outer_ctx)\n       ctx->cb.dst_node = ctx->cb.src_node;\n       ctx->cb.src_cfun = cfun;\n       ctx->cb.copy_decl = omp_copy_decl;\n-      ctx->cb.eh_region = -1;\n+      ctx->cb.eh_lp_nr = 0;\n       ctx->cb.transform_call_graph_edges = CB_CGE_MOVE;\n       ctx->depth = 1;\n     }\n@@ -3114,23 +3114,22 @@ expand_task_call (basic_block bb, gimple entry_stmt)\n static gimple_seq\n maybe_catch_exception (gimple_seq body)\n {\n-  gimple f, t;\n+  gimple g;\n+  tree decl;\n \n   if (!flag_exceptions)\n     return body;\n \n   if (lang_protect_cleanup_actions)\n-    t = lang_protect_cleanup_actions ();\n+    decl = lang_protect_cleanup_actions ();\n   else\n-    t = gimple_build_call (built_in_decls[BUILT_IN_TRAP], 0);\n+    decl = built_in_decls[BUILT_IN_TRAP];\n \n-  f = gimple_build_eh_filter (NULL, gimple_seq_alloc_with_stmt (t));\n-  gimple_eh_filter_set_must_not_throw (f, true);\n-\n-  t = gimple_build_try (body, gimple_seq_alloc_with_stmt (f),\n+  g = gimple_build_eh_must_not_throw (decl);\n+  g = gimple_build_try (body, gimple_seq_alloc_with_stmt (g),\n       \t\t\tGIMPLE_TRY_CATCH);\n \n- return gimple_seq_alloc_with_stmt (t);\n+ return gimple_seq_alloc_with_stmt (g);\n }\n \n /* Chain all the DECLs in LIST by their TREE_CHAIN fields.  */\n@@ -6244,7 +6243,7 @@ create_task_copyfn (gimple task_stmt, omp_context *ctx)\n       tcctx.cb.dst_node = tcctx.cb.src_node;\n       tcctx.cb.src_cfun = ctx->cb.src_cfun;\n       tcctx.cb.copy_decl = task_copyfn_copy_decl;\n-      tcctx.cb.eh_region = -1;\n+      tcctx.cb.eh_lp_nr = 0;\n       tcctx.cb.transform_call_graph_edges = CB_CGE_MOVE;\n       tcctx.cb.decl_map = pointer_map_create ();\n       tcctx.ctx = ctx;"}, {"sha": "a1adc581dc12462e9fdde3e2b71ff9caa505eaa3", "filename": "gcc/optabs.c", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -3858,32 +3858,31 @@ emit_libcall_block (rtx insns, rtx target, rtx result, rtx equiv)\n \n   /* If we're using non-call exceptions, a libcall corresponding to an\n      operation that may trap may also trap.  */\n+  /* ??? See the comment in front of make_reg_eh_region_note.  */\n   if (flag_non_call_exceptions && may_trap_p (equiv))\n     {\n       for (insn = insns; insn; insn = NEXT_INSN (insn))\n \tif (CALL_P (insn))\n \t  {\n \t    rtx note = find_reg_note (insn, REG_EH_REGION, NULL_RTX);\n-\n-\t    if (note != 0 && INTVAL (XEXP (note, 0)) <= 0)\n-\t      remove_note (insn, note);\n+\t    if (note)\n+\t      {\n+\t\tint lp_nr = INTVAL (XEXP (note, 0));\n+\t\tif (lp_nr == 0 || lp_nr == INT_MIN)\n+\t\t  remove_note (insn, note);\n+\t      }\n \t  }\n     }\n   else\n-  /* look for any CALL_INSNs in this sequence, and attach a REG_EH_REGION\n-     reg note to indicate that this call cannot throw or execute a nonlocal\n-     goto (unless there is already a REG_EH_REGION note, in which case\n-     we update it).  */\n-    for (insn = insns; insn; insn = NEXT_INSN (insn))\n-      if (CALL_P (insn))\n-\t{\n-\t  rtx note = find_reg_note (insn, REG_EH_REGION, NULL_RTX);\n-\n-\t  if (note != 0)\n-\t    XEXP (note, 0) = constm1_rtx;\n-\t  else\n-\t    add_reg_note (insn, REG_EH_REGION, constm1_rtx);\n-\t}\n+    {\n+      /* Look for any CALL_INSNs in this sequence, and attach a REG_EH_REGION\n+\t reg note to indicate that this call cannot throw or execute a nonlocal\n+\t goto (unless there is already a REG_EH_REGION note, in which case\n+\t we update it).  */\n+      for (insn = insns; insn; insn = NEXT_INSN (insn))\n+\tif (CALL_P (insn))\n+\t  make_reg_eh_region_note_nothrow_nononlocal (insn);\n+    }\n \n   /* First emit all insns that set pseudos.  Remove them from the list as\n      we go.  Avoid insns that set pseudos which were referenced in previous"}, {"sha": "fa2de0376120b72ab33909cd9fea42784922752a", "filename": "gcc/passes.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -590,6 +590,7 @@ init_optimization_passes (void)\n   /* These passes are run after IPA passes on every function that is being\n      output to the assembler file.  */\n   p = &all_passes;\n+  NEXT_PASS (pass_lower_eh_dispatch);\n   NEXT_PASS (pass_all_optimizations);\n     {\n       struct opt_pass **p = &pass_all_optimizations.pass.sub;\n@@ -713,6 +714,7 @@ init_optimization_passes (void)\n       NEXT_PASS (pass_local_pure_const);\n     }\n   NEXT_PASS (pass_cleanup_eh);\n+  NEXT_PASS (pass_lower_resx);\n   NEXT_PASS (pass_nrv);\n   NEXT_PASS (pass_mudflap_2);\n   NEXT_PASS (pass_cleanup_cfg_post_optimizing);"}, {"sha": "1d66769a1f768ccd03ec8be7833f8996d17b7934", "filename": "gcc/print-tree.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -393,6 +393,8 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n \n       if (code == LABEL_DECL && DECL_ERROR_ISSUED (node))\n \tfputs (\" error-issued\", file);\n+      if (code == LABEL_DECL && EH_LANDING_PAD_NR (node))\n+\tfprintf (file, \" landing-pad:%d\", EH_LANDING_PAD_NR (node));\n \n       if (code == VAR_DECL && DECL_IN_TEXT_SECTION (node))\n \tfputs (\" in-text-section\", file);"}, {"sha": "bfca43b4552564fd8f3cb9913c06e518c55ae6de", "filename": "gcc/recog.c", "status": "modified", "additions": 29, "deletions": 31, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -3234,37 +3234,35 @@ peephole2_optimize (void)\n \t\t\tif (eh_edge->flags & (EDGE_EH | EDGE_ABNORMAL_CALL))\n \t\t\t  break;\n \n-\t\t      for (x = attempt ; x != before_try ; x = PREV_INSN (x))\n-\t\t\tif (CALL_P (x)\n-\t\t\t    || (flag_non_call_exceptions\n-\t\t\t\t&& may_trap_p (PATTERN (x))\n-\t\t\t\t&& !find_reg_note (x, REG_EH_REGION, NULL)))\n-\t\t\t  {\n-\t\t\t    if (note)\n-\t\t\t      add_reg_note (x, REG_EH_REGION, XEXP (note, 0));\n-\n-\t\t\t    if (x != BB_END (bb) && eh_edge)\n-\t\t\t      {\n-\t\t\t\tedge nfte, nehe;\n-\t\t\t\tint flags;\n-\n-\t\t\t\tnfte = split_block (bb, x);\n-\t\t\t\tflags = (eh_edge->flags\n-\t\t\t\t\t & (EDGE_EH | EDGE_ABNORMAL));\n-\t\t\t\tif (CALL_P (x))\n-\t\t\t\t  flags |= EDGE_ABNORMAL_CALL;\n-\t\t\t\tnehe = make_edge (nfte->src, eh_edge->dest,\n-\t\t\t\t\t\t  flags);\n-\n-\t\t\t\tnehe->probability = eh_edge->probability;\n-\t\t\t\tnfte->probability\n-\t\t\t\t  = REG_BR_PROB_BASE - nehe->probability;\n-\n-\t\t\t        do_cleanup_cfg |= purge_dead_edges (nfte->dest);\n-\t\t\t\tbb = nfte->src;\n-\t\t\t\teh_edge = nehe;\n-\t\t\t      }\n-\t\t\t  }\n+\t\t      if (note)\n+\t\t\tcopy_reg_eh_region_note_backward (note, attempt,\n+\t\t\t\t\t\t\t  before_try);\n+\n+\t\t      if (eh_edge)\n+\t\t\tfor (x = attempt ; x != before_try ; x = PREV_INSN (x))\n+\t\t\t  if (x != BB_END (bb)\n+\t\t\t      && (can_throw_internal (x)\n+\t\t\t\t  || can_nonlocal_goto (x)))\n+\t\t\t    {\n+\t\t\t      edge nfte, nehe;\n+\t\t\t      int flags;\n+\n+\t\t\t      nfte = split_block (bb, x);\n+\t\t\t      flags = (eh_edge->flags\n+\t\t\t\t       & (EDGE_EH | EDGE_ABNORMAL));\n+\t\t\t      if (CALL_P (x))\n+\t\t\t\tflags |= EDGE_ABNORMAL_CALL;\n+\t\t\t      nehe = make_edge (nfte->src, eh_edge->dest,\n+\t\t\t\t\t\tflags);\n+\n+\t\t\t      nehe->probability = eh_edge->probability;\n+\t\t\t      nfte->probability\n+\t\t\t\t= REG_BR_PROB_BASE - nehe->probability;\n+\n+\t\t\t      do_cleanup_cfg |= purge_dead_edges (nfte->dest);\n+\t\t\t      bb = nfte->src;\n+\t\t\t      eh_edge = nehe;\n+\t\t\t    }\n \n \t\t      /* Converting possibly trapping insn to non-trapping is\n \t\t\t possible.  Zap dummy outgoing edges.  */"}, {"sha": "984913a5fc123e6dbd003e4f691f2329a756000b", "filename": "gcc/reload1.c", "status": "modified", "additions": 4, "deletions": 26, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -447,7 +447,6 @@ static rtx inc_for_reload (rtx, rtx, rtx, int);\n #ifdef AUTO_INC_DEC\n static void add_auto_inc_notes (rtx, rtx);\n #endif\n-static void copy_eh_notes (rtx, rtx);\n static void substitute (rtx *, const_rtx, rtx);\n static bool gen_reload_chain_without_interm_reg_p (int, int);\n static int reloads_conflict (int, int);\n@@ -4132,17 +4131,11 @@ static void\n fixup_eh_region_note (rtx insn, rtx prev, rtx next)\n {\n   rtx note = find_reg_note (insn, REG_EH_REGION, NULL_RTX);\n-  rtx i;\n-\n   if (note == NULL)\n     return;\n-\n-  if (! may_trap_p (PATTERN (insn)))\n+  if (!insn_could_throw_p (insn))\n     remove_note (insn, note);\n-\n-  for (i = NEXT_INSN (prev); i != next; i = NEXT_INSN (i))\n-    if (INSN_P (i) && i != insn && may_trap_p (PATTERN (i)))\n-      add_reg_note (i, REG_EH_REGION, XEXP (note, 0));\n+  copy_reg_eh_region_note_forward (note, NEXT_INSN (prev), next);\n }\n \n /* Reload pseudo-registers into hard regs around each insn as needed.\n@@ -7294,7 +7287,7 @@ emit_input_reload_insns (struct insn_chain *chain, struct reload *rl,\n     }\n \n   if (flag_non_call_exceptions)\n-    copy_eh_notes (insn, get_insns ());\n+    copy_reg_eh_region_note_forward (insn, get_insns (), NULL);\n \n   /* End this sequence.  */\n   *where = get_insns ();\n@@ -7514,7 +7507,7 @@ emit_output_reload_insns (struct insn_chain *chain, struct reload *rl,\n     output_reload_insns[rl->opnum] = get_insns ();\n \n   if (flag_non_call_exceptions)\n-    copy_eh_notes (insn, get_insns ());\n+    copy_reg_eh_region_note_forward (insn, get_insns (), NULL);\n \n   end_sequence ();\n }\n@@ -8890,21 +8883,6 @@ add_auto_inc_notes (rtx insn, rtx x)\n }\n #endif\n \n-/* Copy EH notes from an insn to its reloads.  */\n-static void\n-copy_eh_notes (rtx insn, rtx x)\n-{\n-  rtx eh_note = find_reg_note (insn, REG_EH_REGION, NULL_RTX);\n-  if (eh_note)\n-    {\n-      for (; x != 0; x = NEXT_INSN (x))\n-\t{\n-\t  if (may_trap_p (PATTERN (x)))\n-\t    add_reg_note (x, REG_EH_REGION, XEXP (eh_note, 0));\n-\t}\n-    }\n-}\n-\n /* This is used by reload pass, that does emit some instructions after\n    abnormal calls moving basic block end, but in fact it wants to emit\n    them on the edge.  Looks for abnormal call edges, find backward the"}, {"sha": "d1c079353d3e7fe34faae3b37a33c229484f46b2", "filename": "gcc/rtl.def", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -301,11 +301,6 @@ DEF_RTL_EXPR(EH_RETURN, \"eh_return\", \"\", RTX_EXTRA)\n    For an unconditional trap, make the condition (const_int 1).  */\n DEF_RTL_EXPR(TRAP_IF, \"trap_if\", \"ee\", RTX_EXTRA)\n \n-/* Placeholder for _Unwind_Resume before we know if a function call\n-   or a branch is needed.  Operand 1 is the exception region from\n-   which control is flowing.  */\n-DEF_RTL_EXPR(RESX, \"resx\", \"i\", RTX_EXTRA)\n-\n /* ----------------------------------------------------------------------\n    Primitive values for use in expressions.\n    ---------------------------------------------------------------------- */"}, {"sha": "d3acebe5f571069e343645bc92a9702dd4aebb1b", "filename": "gcc/rtl.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -1841,6 +1841,13 @@ extern int volatile_insn_p (const_rtx);\n extern int may_trap_p_1 (const_rtx, unsigned);\n extern int may_trap_p (const_rtx);\n extern int may_trap_or_fault_p (const_rtx);\n+extern bool can_throw_internal (const_rtx);\n+extern bool can_throw_external (const_rtx);\n+extern bool insn_could_throw_p (const_rtx);\n+extern bool insn_nothrow_p (const_rtx);\n+extern bool can_nonlocal_goto (const_rtx);\n+extern void copy_reg_eh_region_note_forward (rtx, rtx, rtx);\n+extern void copy_reg_eh_region_note_backward(rtx, rtx, rtx);\n extern int inequality_comparisons_p (const_rtx);\n extern rtx replace_rtx (rtx, rtx, rtx);\n extern int replace_label (rtx *, void *);"}, {"sha": "e2c9eb8848f4fcfb1c6f43afd37ccac51408cd2a", "filename": "gcc/sese.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fsese.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fsese.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -1186,7 +1186,6 @@ graphite_copy_stmts_from_block (basic_block bb, basic_block new_bb, htab_t map)\n     {\n       def_operand_p def_p;\n       ssa_op_iter op_iter;\n-      int region;\n       gimple stmt = gsi_stmt (gsi);\n       gimple copy;\n \n@@ -1199,9 +1198,7 @@ graphite_copy_stmts_from_block (basic_block bb, basic_block new_bb, htab_t map)\n       gsi_insert_after (&gsi_tgt, copy, GSI_NEW_STMT);\n       mark_sym_for_renaming (gimple_vop (cfun));\n \n-      region = lookup_stmt_eh_region (stmt);\n-      if (region >= 0)\n-\tadd_stmt_to_eh_region (copy, region);\n+      maybe_duplicate_eh_stmt (copy, stmt);\n       gimple_duplicate_stmt_histograms (cfun, copy, cfun, stmt);\n \n       /* Create new names for all the definitions created by COPY and"}, {"sha": "db86cf687401be2aacfd4b7569c332a86d7861d2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -1,3 +1,8 @@\n+2009-09-14  Richard Henderson  <rth@redhat.com>\n+\n+\t* g++.dg/eh/builtin1.C: Update resx pattern match.\n+\t* g++.dg/eh/builtin2.C, g++.dg/eh/builtin3.C: Likewise.\n+\n 2009-09-14  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* gcc.target/mips/branch-helper.h: New file."}, {"sha": "ed49e9a962a034d235d136fb2d812295adb794e5", "filename": "gcc/testsuite/g++.dg/eh/builtin1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fbuiltin1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fbuiltin1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fbuiltin1.C?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -22,5 +22,5 @@ bar ()\n   __builtin_printf (\"foo %d\\n\", a.i);\n }\n \n-/* { dg-final { scan-tree-dump-times \"resx 1\" 2 \"eh\" } } */\n+/* { dg-final { scan-tree-dump-times \"resx\" 2 \"eh\" } } */\n /* { dg-final { cleanup-tree-dump \"eh\" } } */"}, {"sha": "fe0c4de6b3eb51a124331be5b7fad136002d66b1", "filename": "gcc/testsuite/g++.dg/eh/builtin2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fbuiltin2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fbuiltin2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fbuiltin2.C?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -21,5 +21,5 @@ bar ()\n   __builtin_printf (\"foo %d\\n\", a.i);\n }\n \n-/* { dg-final { scan-tree-dump-times \"resx 1\" 0 \"eh\" } } */\n+/* { dg-final { scan-tree-dump-times \"resx\" 0 \"eh\" } } */\n /* { dg-final { cleanup-tree-dump \"eh\" } } */"}, {"sha": "45809b81553771acac1e662e35c36de17fab176e", "filename": "gcc/testsuite/g++.dg/eh/builtin3.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fbuiltin3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fbuiltin3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fbuiltin3.C?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -12,5 +12,5 @@ bar ()\n   __builtin_printf (\"foo %d\\n\", a.i);\n }\n \n-/* { dg-final { scan-tree-dump-times \"resx 1\" 1 \"eh\" } } */\n+/* { dg-final { scan-tree-dump-times \"resx\" 1 \"eh\" } } */\n /* { dg-final { cleanup-tree-dump \"eh\" } } */"}, {"sha": "8dfaa52b6bb7b684fdad8b4e218a308dc701d9af", "filename": "gcc/testsuite/g++.dg/tree-ssa/ehcleanup-1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fehcleanup-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fehcleanup-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fehcleanup-1.C?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -19,6 +19,6 @@ t (void)\n // { dg-final { scan-tree-dump-times \"Empty EH handler\" 1 \"ehcleanup1\" } }\n //\n // And as a result also contained control flow.\n-// { dg-final { scan-tree-dump-times \"Removing unreachable\" 1 \"ehcleanup1\" } }\n+// { dg-final { scan-tree-dump-times \"Removing unreachable\" 2 \"ehcleanup1\" } }\n //\n // { dg-final { cleanup-tree-dump \"ehcleanup1\" } }"}, {"sha": "fb24cc48a4a521175e261033cc355960a7e0204a", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 247, "deletions": 98, "changes": 345, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -545,6 +545,9 @@ make_edges (void)\n \t      make_eh_edges (last);\n \t      fallthru = false;\n \t      break;\n+\t    case GIMPLE_EH_DISPATCH:\n+\t      fallthru = make_eh_dispatch_edges (last);\n+\t      break;\n \n \t    case GIMPLE_CALL:\n \t      /* If this function receives a nonlocal goto, then we need to\n@@ -565,9 +568,7 @@ make_edges (void)\n \t       /* A GIMPLE_ASSIGN may throw internally and thus be considered\n \t\t  control-altering. */\n \t      if (is_ctrl_altering_stmt (last))\n-\t\t{\n-\t\t  make_eh_edges (last);\n-\t\t}\n+\t\tmake_eh_edges (last);\n \t      fallthru = true;\n \t      break;\n \n@@ -1033,29 +1034,6 @@ static struct label_record\n   bool used;\n } *label_for_bb;\n \n-/* Callback for for_each_eh_region.  Helper for cleanup_dead_labels.  */\n-static void\n-update_eh_label (struct eh_region_d *region)\n-{\n-  tree old_label = get_eh_region_tree_label (region);\n-  if (old_label)\n-    {\n-      tree new_label;\n-      basic_block bb = label_to_block (old_label);\n-\n-      /* ??? After optimizing, there may be EH regions with labels\n-\t that have already been removed from the function body, so\n-\t there is no basic block for them.  */\n-      if (! bb)\n-\treturn;\n-\n-      new_label = label_for_bb[bb->index].label;\n-      label_for_bb[bb->index].used = true;\n-      set_eh_region_tree_label (region, new_label);\n-    }\n-}\n-\n-\n /* Given LABEL return the first label in the same basic block.  */\n \n static tree\n@@ -1075,6 +1053,58 @@ main_block_label (tree label)\n   return main_label;\n }\n \n+/* Clean up redundant labels within the exception tree.  */\n+\n+static void\n+cleanup_dead_labels_eh (void)\n+{\n+  eh_landing_pad lp;\n+  eh_region r;\n+  tree lab;\n+  int i;\n+\n+  if (cfun->eh == NULL)\n+    return;\n+\n+  for (i = 1; VEC_iterate (eh_landing_pad, cfun->eh->lp_array, i, lp); ++i)\n+    if (lp && lp->post_landing_pad)\n+      {\n+\tlab = main_block_label (lp->post_landing_pad);\n+\tif (lab != lp->post_landing_pad)\n+\t  {\n+\t    EH_LANDING_PAD_NR (lp->post_landing_pad) = 0;\n+\t    EH_LANDING_PAD_NR (lab) = lp->index;\n+\t  }\n+      }\n+\n+  FOR_ALL_EH_REGION (r)\n+    switch (r->type)\n+      {\n+      case ERT_CLEANUP:\n+      case ERT_MUST_NOT_THROW:\n+\tbreak;\n+\n+      case ERT_TRY:\n+\t{\n+\t  eh_catch c;\n+\t  for (c = r->u.eh_try.first_catch; c ; c = c->next_catch)\n+\t    {\n+\t      lab = c->label;\n+\t      if (lab)\n+\t\tc->label = main_block_label (lab);\n+\t    }\n+\t}\n+\tbreak;\n+\n+      case ERT_ALLOWED_EXCEPTIONS:\n+\tlab = r->u.allowed.label;\n+\tif (lab)\n+\t  r->u.allowed.label = main_block_label (lab);\n+\tbreak;\n+      }\n+}\n+\n+\n /* Cleanup redundant labels.  This is a three-step process:\n      1) Find the leading label for each block.\n      2) Redirect all references to labels to the leading labels.\n@@ -1173,7 +1203,8 @@ cleanup_dead_labels (void)\n       }\n     }\n \n-  for_each_eh_region (update_eh_label);\n+  /* Do the same for the exception region tree labels.  */\n+  cleanup_dead_labels_eh ();\n \n   /* Finally, purge dead labels.  All user-defined labels and labels that\n      can be the target of non-local gotos and labels which have their\n@@ -1584,9 +1615,11 @@ gimple_merge_blocks (basic_block a, basic_block b)\n   /* Remove labels from B and set gimple_bb to A for other statements.  */\n   for (gsi = gsi_start_bb (b); !gsi_end_p (gsi);)\n     {\n-      if (gimple_code (gsi_stmt (gsi)) == GIMPLE_LABEL)\n+      gimple stmt = gsi_stmt (gsi);\n+      if (gimple_code (stmt) == GIMPLE_LABEL)\n \t{\n-\t  gimple label = gsi_stmt (gsi);\n+\t  tree label = gimple_label_label (stmt);\n+\t  int lp_nr;\n \n \t  gsi_remove (&gsi, false);\n \n@@ -1596,15 +1629,22 @@ gimple_merge_blocks (basic_block a, basic_block b)\n \t     used in other ways (think about the runtime checking for\n \t     Fortran assigned gotos).  So we can not just delete the\n \t     label.  Instead we move the label to the start of block A.  */\n-\t  if (FORCED_LABEL (gimple_label_label (label)))\n+\t  if (FORCED_LABEL (label))\n \t    {\n \t      gimple_stmt_iterator dest_gsi = gsi_start_bb (a);\n-\t      gsi_insert_before (&dest_gsi, label, GSI_NEW_STMT);\n+\t      gsi_insert_before (&dest_gsi, stmt, GSI_NEW_STMT);\n+\t    }\n+\n+\t  lp_nr = EH_LANDING_PAD_NR (label);\n+\t  if (lp_nr)\n+\t    {\n+\t      eh_landing_pad lp = get_eh_landing_pad_from_number (lp_nr);\n+\t      lp->post_landing_pad = NULL;\n \t    }\n \t}\n       else\n \t{\n-\t  gimple_set_bb (gsi_stmt (gsi), a);\n+\t  gimple_set_bb (stmt, a);\n \t  gsi_next (&gsi);\n \t}\n     }\n@@ -1917,17 +1957,18 @@ remove_useless_stmts_tc (gimple_stmt_iterator *gsi, struct rus_data *data)\n       break;\n \n     case GIMPLE_EH_FILTER:\n-      /* If the first element is an eh_filter, it should stand alone.  */\n-      if (gimple_eh_filter_must_not_throw (stmt))\n-\tthis_may_throw = false;\n-      else if (gimple_eh_filter_types (stmt) == NULL)\n+      if (gimple_eh_filter_types (stmt) == NULL)\n \tthis_may_throw = false;\n       failure_seq = gimple_eh_filter_failure (stmt);\n       failure_gsi = gsi_start (failure_seq);\n       remove_useless_stmts_1 (&failure_gsi, data);\n       gsi_next (gsi);\n       break;\n \n+    case GIMPLE_EH_MUST_NOT_THROW:\n+      this_may_throw = false;\n+      break;\n+\n     default:\n       /* Otherwise this is a list of cleanup statements.  */\n       remove_useless_stmts_1 (&cleanup_gsi, data);\n@@ -2774,6 +2815,12 @@ is_ctrl_altering_stmt (gimple t)\n       }\n       break;\n \n+    case GIMPLE_EH_DISPATCH:\n+      /* EH_DISPATCH branches to the individual catch handlers at\n+\t this level of a try or allowed-exceptions region.  It can\n+\t fallthru to the next statement as well.  */\n+      return true;\n+\n     CASE_GIMPLE_OMP:\n       /* OpenMP directives alter control flow.  */\n       return true;\n@@ -4039,8 +4086,6 @@ verify_gimple_assign_single (gimple stmt)\n     case OBJ_TYPE_REF:\n     case ASSERT_EXPR:\n     case WITH_SIZE_EXPR:\n-    case EXC_PTR_EXPR:\n-    case FILTER_EXPR:\n     case POLYNOMIAL_CHREC:\n     case DOT_PROD_EXPR:\n     case VEC_COND_EXPR:\n@@ -4248,8 +4293,9 @@ verify_types_in_gimple_stmt (gimple stmt)\n \n     /* Tuples that do not have tree operands.  */\n     case GIMPLE_NOP:\n-    case GIMPLE_RESX:\n     case GIMPLE_PREDICT:\n+    case GIMPLE_RESX:\n+    case GIMPLE_EH_DISPATCH:\n       return false;\n \n     CASE_GIMPLE_OMP:\n@@ -4334,6 +4380,7 @@ verify_stmt (gimple_stmt_iterator *gsi)\n   struct walk_stmt_info wi;\n   bool last_in_block = gsi_one_before_end_p (*gsi);\n   gimple stmt = gsi_stmt (*gsi);\n+  int lp_nr;\n \n   if (is_gimple_omp (stmt))\n     {\n@@ -4388,17 +4435,21 @@ verify_stmt (gimple_stmt_iterator *gsi)\n      have optimizations that simplify statements such that we prove\n      that they cannot throw, that we update other data structures\n      to match.  */\n-  if (lookup_stmt_eh_region (stmt) >= 0)\n+  lp_nr = lookup_stmt_eh_lp (stmt);\n+  if (lp_nr != 0)\n     {\n-      /* During IPA passes, ipa-pure-const sets nothrow flags on calls\n-         and they are updated on statements only after fixup_cfg\n-\t is executed at beggining of expansion stage.  */\n-      if (!stmt_could_throw_p (stmt) && cgraph_state != CGRAPH_STATE_IPA_SSA)\n+      if (!stmt_could_throw_p (stmt))\n \t{\n-\t  error (\"statement marked for throw, but doesn%'t\");\n-\t  goto fail;\n+\t  /* During IPA passes, ipa-pure-const sets nothrow flags on calls\n+\t     and they are updated on statements only after fixup_cfg\n+\t     is executed at beggining of expansion stage.  */\n+\t  if (cgraph_state != CGRAPH_STATE_IPA_SSA)\n+\t    {\n+\t      error (\"statement marked for throw, but doesn%'t\");\n+\t      goto fail;\n+\t    }\n \t}\n-      if (!last_in_block && stmt_can_throw_internal (stmt))\n+      else if (lp_nr > 0 && !last_in_block && stmt_can_throw_internal (stmt))\n \t{\n \t  error (\"statement marked for throw in middle of block\");\n \t  goto fail;\n@@ -4586,9 +4637,20 @@ verify_stmts (void)\n \t      if (uid == -1\n \t\t  || VEC_index (basic_block, label_to_block_map, uid) != bb)\n \t\t{\n-\t\t  error (\"incorrect entry in label_to_block_map.\\n\");\n+\t\t  error (\"incorrect entry in label_to_block_map\");\n \t\t  err |= true;\n \t\t}\n+\n+\t      uid = EH_LANDING_PAD_NR (decl);\n+\t      if (uid)\n+\t\t{\n+\t\t  eh_landing_pad lp = get_eh_landing_pad_from_number (uid);\n+\t\t  if (decl != lp->post_landing_pad)\n+\t\t    {\n+\t\t      error (\"incorrect setting of landing pad number\");\n+\t\t      err |= true;\n+\t\t    }\n+\t\t}\n \t    }\n \n \t  err |= verify_stmt (&gsi);\n@@ -4735,6 +4797,9 @@ gimple_verify_flow_info (void)\n \n       stmt = gsi_stmt (gsi);\n \n+      if (gimple_code (stmt) == GIMPLE_LABEL)\n+\tcontinue;\n+\n       err |= verify_eh_edges (stmt);\n \n       if (is_ctrl_stmt (stmt))\n@@ -4904,8 +4969,14 @@ gimple_verify_flow_info (void)\n \t    FOR_EACH_EDGE (e, ei, bb->succs)\n \t      e->dest->aux = (void *)0;\n \t  }\n+\t  break;\n+\n+\tcase GIMPLE_EH_DISPATCH:\n+\t  err |= verify_eh_dispatch_edge (stmt);\n+\t  break;\n \n-\tdefault: ;\n+\tdefault:\n+\t  break;\n \t}\n     }\n \n@@ -5129,6 +5200,11 @@ gimple_redirect_edge_and_branch (edge e, basic_block dest)\n       /* The edges from OMP constructs can be simply redirected.  */\n       break;\n \n+    case GIMPLE_EH_DISPATCH:\n+      if (!(e->flags & EDGE_FALLTHRU))\n+\tredirect_eh_dispatch_edge (stmt, e, dest);\n+      break;\n+\n     default:\n       /* Otherwise it must be a fallthru edge, and we don't need to\n \t do anything besides redirecting it.  */\n@@ -5278,7 +5354,6 @@ gimple_duplicate_bb (basic_block bb)\n     {\n       def_operand_p def_p;\n       ssa_op_iter op_iter;\n-      int region;\n \n       stmt = gsi_stmt (gsi);\n       if (gimple_code (stmt) == GIMPLE_LABEL)\n@@ -5288,9 +5363,8 @@ gimple_duplicate_bb (basic_block bb)\n \t operands.  */\n       copy = gimple_copy (stmt);\n       gsi_insert_after (&gsi_tgt, copy, GSI_NEW_STMT);\n-      region = lookup_stmt_eh_region (stmt);\n-      if (region >= 0)\n-\tadd_stmt_to_eh_region (copy, region);\n+\n+      maybe_duplicate_eh_stmt (copy, stmt);\n       gimple_duplicate_stmt_histograms (cfun, copy, cfun, stmt);\n \n       /* Create new names for all the definitions created by COPY and\n@@ -5818,6 +5892,7 @@ struct move_stmt_d\n   tree to_context;\n   struct pointer_map_t *vars_map;\n   htab_t new_label_map;\n+  struct pointer_map_t *eh_map;\n   bool remap_decls_p;\n };\n \n@@ -5883,6 +5958,35 @@ move_stmt_op (tree *tp, int *walk_subtrees, void *data)\n   return NULL_TREE;\n }\n \n+/* Helper for move_stmt_r.  Given an EH region number for the source\n+   function, map that to the duplicate EH regio number in the dest.  */\n+\n+static int\n+move_stmt_eh_region_nr (int old_nr, struct move_stmt_d *p)\n+{\n+  eh_region old_r, new_r;\n+  void **slot;\n+\n+  old_r = get_eh_region_from_number (old_nr);\n+  slot = pointer_map_contains (p->eh_map, old_r);\n+  new_r = (eh_region) *slot;\n+\n+  return new_r->index;\n+}\n+\n+/* Similar, but operate on INTEGER_CSTs.  */\n+\n+static tree\n+move_stmt_eh_region_tree_nr (tree old_t_nr, struct move_stmt_d *p)\n+{\n+  int old_nr, new_nr;\n+\n+  old_nr = tree_low_cst (old_t_nr, 0);\n+  new_nr = move_stmt_eh_region_nr (old_nr, p);\n+\n+  return build_int_cst (NULL, new_nr);\n+}\n+\n /* Like move_stmt_op, but for gimple statements.\n \n    Helper for move_block_to_fn.  Set GIMPLE_BLOCK in every expression\n@@ -5911,21 +6015,70 @@ move_stmt_r (gimple_stmt_iterator *gsi_p, bool *handled_ops_p,\n     }\n #endif\n \n-  if (is_gimple_omp (stmt)\n-      && gimple_code (stmt) != GIMPLE_OMP_RETURN\n-      && gimple_code (stmt) != GIMPLE_OMP_CONTINUE)\n+  switch (gimple_code (stmt))\n     {\n-      /* Do not remap variables inside OMP directives.  Variables\n-\t referenced in clauses and directive header belong to the\n-\t parent function and should not be moved into the child\n-\t function.  */\n-      bool save_remap_decls_p = p->remap_decls_p;\n-      p->remap_decls_p = false;\n-      *handled_ops_p = true;\n+    case GIMPLE_CALL:\n+      /* Remap the region numbers for __builtin_eh_{pointer,filter}.  */\n+      {\n+\ttree r, fndecl = gimple_call_fndecl (stmt);\n+\tif (fndecl && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL)\n+\t  switch (DECL_FUNCTION_CODE (fndecl))\n+\t    {\n+\t    case BUILT_IN_EH_COPY_VALUES:\n+\t      r = gimple_call_arg (stmt, 1);\n+\t      r = move_stmt_eh_region_tree_nr (r, p);\n+\t      gimple_call_set_arg (stmt, 1, r);\n+\t      /* FALLTHRU */\n+\n+\t    case BUILT_IN_EH_POINTER:\n+\t    case BUILT_IN_EH_FILTER:\n+\t      r = gimple_call_arg (stmt, 0);\n+\t      r = move_stmt_eh_region_tree_nr (r, p);\n+\t      gimple_call_set_arg (stmt, 0, r);\n+\t      break;\n \n-      walk_gimple_seq (gimple_omp_body (stmt), move_stmt_r, move_stmt_op, wi);\n+\t    default:\n+\t      break;\n+\t    }\n+      }\n+      break;\n+\n+    case GIMPLE_RESX:\n+      {\n+\tint r = gimple_resx_region (stmt);\n+\tr = move_stmt_eh_region_nr (r, p);\n+\tgimple_resx_set_region (stmt, r);\n+      }\n+      break;\n \n-      p->remap_decls_p = save_remap_decls_p;\n+    case GIMPLE_EH_DISPATCH:\n+      {\n+\tint r = gimple_eh_dispatch_region (stmt);\n+\tr = move_stmt_eh_region_nr (r, p);\n+\tgimple_eh_dispatch_set_region (stmt, r);\n+      }\n+      break;\n+\n+    case GIMPLE_OMP_RETURN:\n+    case GIMPLE_OMP_CONTINUE:\n+      break;\n+    default:\n+      if (is_gimple_omp (stmt))\n+\t{\n+\t  /* Do not remap variables inside OMP directives.  Variables\n+\t     referenced in clauses and directive header belong to the\n+\t     parent function and should not be moved into the child\n+\t     function.  */\n+\t  bool save_remap_decls_p = p->remap_decls_p;\n+\t  p->remap_decls_p = false;\n+\t  *handled_ops_p = true;\n+\n+\t  walk_gimple_seq (gimple_omp_body (stmt), move_stmt_r,\n+\t\t\t   move_stmt_op, wi);\n+\n+\t  p->remap_decls_p = save_remap_decls_p;\n+\t}\n+      break;\n     }\n \n   return NULL_TREE;\n@@ -5959,7 +6112,7 @@ mark_virtual_ops_in_bb (basic_block bb)\n static void\n move_block_to_fn (struct function *dest_cfun, basic_block bb,\n \t\t  basic_block after, bool update_edge_count_p,\n-\t\t  struct move_stmt_d *d, int eh_offset)\n+\t\t  struct move_stmt_d *d)\n {\n   struct control_flow_graph *cfg;\n   edge_iterator ei;\n@@ -6035,7 +6188,6 @@ move_block_to_fn (struct function *dest_cfun, basic_block bb,\n   for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n     {\n       gimple stmt = gsi_stmt (si);\n-      int region;\n       struct walk_stmt_info wi;\n \n       memset (&wi, 0, sizeof (wi));\n@@ -6065,17 +6217,12 @@ move_block_to_fn (struct function *dest_cfun, basic_block bb,\n \t  if (uid >= dest_cfun->cfg->last_label_uid)\n \t    dest_cfun->cfg->last_label_uid = uid + 1;\n \t}\n-      else if (gimple_code (stmt) == GIMPLE_RESX && eh_offset != 0)\n-\tgimple_resx_set_region (stmt, gimple_resx_region (stmt) + eh_offset);\n \n-      region = lookup_stmt_eh_region (stmt);\n-      if (region >= 0)\n-\t{\n-\t  add_stmt_to_eh_region_fn (dest_cfun, stmt, region + eh_offset);\n-\t  remove_stmt_from_eh_region (stmt);\n-\t  gimple_duplicate_stmt_histograms (dest_cfun, stmt, cfun, stmt);\n-          gimple_remove_stmt_histograms (cfun, stmt);\n-\t}\n+      maybe_duplicate_eh_stmt_fn (dest_cfun, stmt, cfun, stmt, d->eh_map, 0);\n+      remove_stmt_from_eh_lp_fn (cfun, stmt);\n+\n+      gimple_duplicate_stmt_histograms (dest_cfun, stmt, cfun, stmt);\n+      gimple_remove_stmt_histograms (cfun, stmt);\n \n       /* We cannot leave any operands allocated from the operand caches of\n \t the current function.  */\n@@ -6106,29 +6253,28 @@ move_block_to_fn (struct function *dest_cfun, basic_block bb,\n /* Examine the statements in BB (which is in SRC_CFUN); find and return\n    the outermost EH region.  Use REGION as the incoming base EH region.  */\n \n-static int\n+static eh_region\n find_outermost_region_in_block (struct function *src_cfun,\n-\t\t\t\tbasic_block bb, int region)\n+\t\t\t\tbasic_block bb, eh_region region)\n {\n   gimple_stmt_iterator si;\n \n   for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n     {\n       gimple stmt = gsi_stmt (si);\n-      int stmt_region;\n+      eh_region stmt_region;\n+      int lp_nr;\n \n-      if (gimple_code (stmt) == GIMPLE_RESX)\n-\tstmt_region = gimple_resx_region (stmt);\n-      else\n-\tstmt_region = lookup_stmt_eh_region_fn (src_cfun, stmt);\n-      if (stmt_region > 0)\n+      lp_nr = lookup_stmt_eh_lp_fn (src_cfun, stmt);\n+      stmt_region = get_eh_region_from_lp_number_fn (src_cfun, lp_nr);\n+      if (stmt_region)\n \t{\n-\t  if (region < 0)\n+\t  if (region == NULL)\n \t    region = stmt_region;\n \t  else if (stmt_region != region)\n \t    {\n \t      region = eh_region_outermost (src_cfun, stmt_region, region);\n-\t      gcc_assert (region != -1);\n+\t      gcc_assert (region != NULL);\n \t    }\n \t}\n     }\n@@ -6218,13 +6364,13 @@ move_sese_region_to_fn (struct function *dest_cfun, basic_block entry_bb,\n   basic_block dom_entry = get_immediate_dominator (CDI_DOMINATORS, entry_bb);\n   basic_block after, bb, *entry_pred, *exit_succ, abb;\n   struct function *saved_cfun = cfun;\n-  int *entry_flag, *exit_flag, eh_offset;\n+  int *entry_flag, *exit_flag;\n   unsigned *entry_prob, *exit_prob;\n   unsigned i, num_entry_edges, num_exit_edges;\n   edge e;\n   edge_iterator ei;\n   htab_t new_label_map;\n-  struct pointer_map_t *vars_map;\n+  struct pointer_map_t *vars_map, *eh_map;\n   struct loop *loop = entry_bb->loop_father;\n   struct move_stmt_d d;\n \n@@ -6294,21 +6440,21 @@ move_sese_region_to_fn (struct function *dest_cfun, basic_block entry_bb,\n   init_empty_tree_cfg ();\n \n   /* Initialize EH information for the new function.  */\n-  eh_offset = 0;\n+  eh_map = NULL;\n   new_label_map = NULL;\n   if (saved_cfun->eh)\n     {\n-      int region = -1;\n+      eh_region region = NULL;\n \n       for (i = 0; VEC_iterate (basic_block, bbs, i, bb); i++)\n \tregion = find_outermost_region_in_block (saved_cfun, bb, region);\n \n       init_eh_for_function ();\n-      if (region != -1)\n+      if (region != NULL)\n \t{\n \t  new_label_map = htab_create (17, tree_map_hash, tree_map_eq, free);\n-\t  eh_offset = duplicate_eh_regions (saved_cfun, new_label_mapper,\n-\t\t\t\t\t    new_label_map, region, 0);\n+\t  eh_map = duplicate_eh_regions (saved_cfun, region, 0,\n+\t\t\t\t\t new_label_mapper, new_label_map);\n \t}\n     }\n \n@@ -6320,20 +6466,21 @@ move_sese_region_to_fn (struct function *dest_cfun, basic_block entry_bb,\n   vars_map = pointer_map_create ();\n \n   memset (&d, 0, sizeof (d));\n-  d.vars_map = vars_map;\n+  d.orig_block = orig_block;\n+  d.new_block = DECL_INITIAL (dest_cfun->decl);\n   d.from_context = cfun->decl;\n   d.to_context = dest_cfun->decl;\n+  d.vars_map = vars_map;\n   d.new_label_map = new_label_map;\n+  d.eh_map = eh_map;\n   d.remap_decls_p = true;\n-  d.orig_block = orig_block;\n-  d.new_block = DECL_INITIAL (dest_cfun->decl);\n \n   for (i = 0; VEC_iterate (basic_block, bbs, i, bb); i++)\n     {\n       /* No need to update edge counts on the last block.  It has\n \t already been updated earlier when we detached the region from\n \t the original CFG.  */\n-      move_block_to_fn (dest_cfun, bb, after, bb != exit_bb, &d, eh_offset);\n+      move_block_to_fn (dest_cfun, bb, after, bb != exit_bb, &d);\n       after = bb;\n     }\n \n@@ -6356,6 +6503,8 @@ move_sese_region_to_fn (struct function *dest_cfun, basic_block entry_bb,\n \n   if (new_label_map)\n     htab_delete (new_label_map);\n+  if (eh_map)\n+    pointer_map_destroy (eh_map);\n   pointer_map_destroy (vars_map);\n \n   /* Rewire the entry and exit blocks.  The successor to the entry"}, {"sha": "d3a8ca91aa993ab262be2b29298ed2d941a1e3da", "filename": "gcc/tree-cfgcleanup.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftree-cfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftree-cfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfgcleanup.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -239,6 +239,16 @@ tree_forwarder_block_p (basic_block bb, bool phi_wanted)\n   gcc_assert (bb != ENTRY_BLOCK_PTR);\n #endif\n \n+  /* There should not be an edge coming from entry, or an EH edge.  */\n+  {\n+    edge_iterator ei;\n+    edge e;\n+\n+    FOR_EACH_EDGE (e, ei, bb->preds)\n+      if (e->src == ENTRY_BLOCK_PTR || (e->flags & EDGE_EH))\n+\treturn false;\n+  }\n+\n   /* Now walk through the statements backward.  We can ignore labels,\n      anything else means this is not a forwarder block.  */\n   for (gsi = gsi_last_bb (bb); !gsi_end_p (gsi); gsi_prev (&gsi))\n@@ -262,9 +272,6 @@ tree_forwarder_block_p (basic_block bb, bool phi_wanted)\n \t}\n     }\n \n-  if (find_edge (ENTRY_BLOCK_PTR, bb))\n-    return false;\n-\n   if (current_loops)\n     {\n       basic_block dest;"}, {"sha": "e9a645ef7f237da1562586290103bb751a441585", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -201,7 +201,6 @@ create_tree_common_ann (tree t)\n   ann = GGC_CNEW (struct tree_ann_common_d);\n \n   ann->type = TREE_ANN_COMMON;\n-  ann->rn = -1;\n   t->base.ann = (tree_ann_t) ann;\n \n   return ann;"}, {"sha": "a1aa4b21571a315ad480f2a3a2e842789b442aa6", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 1641, "deletions": 996, "changes": 2637, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980"}, {"sha": "b93e2f4a373e86a891eb458c52071e4118de5f22", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -134,9 +134,9 @@ struct GTY(()) tree_ann_common_d {\n   /* Annotation type.  */\n   enum tree_ann_type type;\n \n-  /* Record EH region number into a statement tree created during RTL\n-     expansion (see gimple_to_tree).  */\n-  int rn;\n+  /* Record EH landing pad number into a statement tree created\n+     during RTL expansion (see gimple_to_tree).  */\n+  int lp_nr;\n \n   /* Pointer to original GIMPLE statement.  Used during RTL expansion\n      (see gimple_to_tree).  */\n@@ -807,6 +807,9 @@ bool contains_abnormal_ssa_name_p (tree);\n bool stmt_dominates_stmt_p (gimple, gimple);\n void mark_virtual_ops_for_renaming (gimple);\n \n+/* In tree-ssa-dce.c */\n+void mark_virtual_phi_result_for_renaming (gimple);\n+\n /* In tree-ssa-threadedge.c */\n extern void threadedge_initialize_values (void);\n extern void threadedge_finalize_values (void);\n@@ -842,6 +845,9 @@ static inline bool array_ref_contains_indirect_ref (const_tree);\n \n /* In tree-eh.c  */\n extern void make_eh_edges (gimple);\n+extern bool make_eh_dispatch_edges (gimple);\n+extern edge redirect_eh_edge (edge, basic_block);\n+extern void redirect_eh_dispatch_edge (gimple, edge, basic_block);\n extern bool tree_could_trap_p (tree);\n extern bool operation_could_trap_helper_p (enum tree_code, bool, bool, bool,\n \t\t\t\t\t   bool, tree, bool *);\n@@ -850,16 +856,22 @@ extern bool stmt_could_throw_p (gimple);\n extern bool tree_could_throw_p (tree);\n extern bool stmt_can_throw_internal (gimple);\n extern bool stmt_can_throw_external (gimple);\n-extern void add_stmt_to_eh_region (gimple, int);\n-extern bool remove_stmt_from_eh_region (gimple);\n+extern void add_stmt_to_eh_lp_fn (struct function *, gimple, int);\n+extern void add_stmt_to_eh_lp (gimple, int);\n+extern bool remove_stmt_from_eh_lp (gimple);\n+extern bool remove_stmt_from_eh_lp_fn (struct function *, gimple);\n+extern int lookup_stmt_eh_lp_fn (struct function *, gimple);\n+extern int lookup_expr_eh_lp (tree);\n+extern int lookup_stmt_eh_lp (gimple);\n+extern bool maybe_clean_eh_stmt_fn (struct function *, gimple);\n+extern bool maybe_clean_eh_stmt (gimple);\n extern bool maybe_clean_or_replace_eh_stmt (gimple, gimple);\n-extern void add_stmt_to_eh_region_fn (struct function *, gimple, int);\n-extern bool remove_stmt_from_eh_region_fn (struct function *, gimple);\n-extern int lookup_stmt_eh_region_fn (struct function *, gimple);\n-extern int lookup_expr_eh_region (tree);\n-extern int lookup_stmt_eh_region (gimple);\n+extern bool maybe_duplicate_eh_stmt_fn (struct function *, gimple,\n+\t\t\t\t\tstruct function *, gimple,\n+\t\t\t\t\tstruct pointer_map_t *, int);\n+extern bool maybe_duplicate_eh_stmt (gimple, gimple);\n extern bool verify_eh_edges (gimple);\n-\n+extern bool verify_eh_dispatch_edge (gimple);\n \n /* In tree-ssa-pre.c  */\n struct pre_expr_d;\n@@ -926,6 +938,5 @@ unsigned int execute_fixup_cfg (void);\n void swap_tree_operands (gimple, tree *, tree *);\n \n int least_common_multiple (int, int);\n-edge redirect_eh_edge (edge e, basic_block new_bb);\n \n #endif /* _TREE_FLOW_H  */"}, {"sha": "5ada378700fb05ab4c06b74c169bff760824e344", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 109, "deletions": 70, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -64,7 +64,7 @@ along with GCC; see the file COPYING3.  If not see\n    MODIFY_EXPRs that store to a dedicated returned-value variable.\n    The duplicated eh_region info of the copy will later be appended\n    to the info for the caller; the eh_region info in copied throwing\n-   statements and RESX_EXPRs is adjusted accordingly.\n+   statements and RESX statements are adjusted accordingly.\n \n    Cloning: (only in C++) We have one body for a con/de/structor, and\n    multiple function decls, each with a unique parameter list.\n@@ -1105,12 +1105,6 @@ copy_tree_body_r (tree *tp, int *walk_subtrees, void *data)\n \t  TREE_BLOCK (*tp) = new_block;\n \t}\n \n-      if (TREE_CODE (*tp) == RESX_EXPR && id->eh_region_offset)\n-\tTREE_OPERAND (*tp, 0) =\n-\t  build_int_cst (NULL_TREE,\n-\t\t\t id->eh_region_offset\n-\t\t\t + TREE_INT_CST_LOW (TREE_OPERAND (*tp, 0)));\n-\n       if (TREE_CODE (*tp) != OMP_CLAUSE)\n \tTREE_TYPE (*tp) = remap_type (TREE_TYPE (*tp), id);\n \n@@ -1150,6 +1144,35 @@ copy_tree_body_r (tree *tp, int *walk_subtrees, void *data)\n   return NULL_TREE;\n }\n \n+/* Helper for remap_gimple_stmt.  Given an EH region number for the\n+   source function, map that to the duplicate EH region number in\n+   the destination function.  */\n+\n+static int\n+remap_eh_region_nr (int old_nr, copy_body_data *id)\n+{\n+  eh_region old_r, new_r;\n+  void **slot;\n+\n+  old_r = get_eh_region_from_number_fn (id->src_cfun, old_nr);\n+  slot = pointer_map_contains (id->eh_map, old_r);\n+  new_r = (eh_region) *slot;\n+\n+  return new_r->index;\n+}\n+\n+/* Similar, but operate on INTEGER_CSTs.  */\n+\n+static tree\n+remap_eh_region_tree_nr (tree old_t_nr, copy_body_data *id)\n+{\n+  int old_nr, new_nr;\n+\n+  old_nr = tree_low_cst (old_t_nr, 0);\n+  new_nr = remap_eh_region_nr (old_nr, id);\n+\n+  return build_int_cst (NULL, new_nr);\n+}\n \n /* Helper for copy_bb.  Remap statement STMT using the inlining\n    information in ID.  Return the new statement copy.  */\n@@ -1339,9 +1362,59 @@ remap_gimple_stmt (gimple stmt, copy_body_data *id)\n \t  VEC_safe_push (gimple, heap, id->debug_stmts, copy);\n \t  return copy;\n \t}\n-      else\n-\t/* Create a new deep copy of the statement.  */\n-\tcopy = gimple_copy (stmt);\n+\n+      /* Create a new deep copy of the statement.  */\n+      copy = gimple_copy (stmt);\n+\n+      /* Remap the region numbers for __builtin_eh_{pointer,filter},\n+\t RESX and EH_DISPATCH.  */\n+      if (id->eh_map)\n+\tswitch (gimple_code (copy))\n+\t  {\n+\t  case GIMPLE_CALL:\n+\t    {\n+\t      tree r, fndecl = gimple_call_fndecl (copy);\n+\t      if (fndecl && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL)\n+\t\tswitch (DECL_FUNCTION_CODE (fndecl))\n+\t\t  {\n+\t\t  case BUILT_IN_EH_COPY_VALUES:\n+\t\t    r = gimple_call_arg (copy, 1);\n+\t\t    r = remap_eh_region_tree_nr (r, id);\n+\t\t    gimple_call_set_arg (copy, 1, r);\n+\t\t    /* FALLTHRU */\n+\n+\t\t  case BUILT_IN_EH_POINTER:\n+\t\t  case BUILT_IN_EH_FILTER:\n+\t\t    r = gimple_call_arg (copy, 0);\n+\t\t    r = remap_eh_region_tree_nr (r, id);\n+\t\t    gimple_call_set_arg (copy, 0, r);\n+\t\t    break;\n+\n+\t\t  default:\n+\t\t    break;\n+\t\t  }\n+\t    }\n+\t    break;\n+\n+\t  case GIMPLE_RESX:\n+\t    {\n+\t      int r = gimple_resx_region (copy);\n+\t      r = remap_eh_region_nr (r, id);\n+\t      gimple_resx_set_region (copy, r);\n+\t    }\n+\t    break;\n+\n+\t  case GIMPLE_EH_DISPATCH:\n+\t    {\n+\t      int r = gimple_eh_dispatch_region (copy);\n+\t      r = remap_eh_region_nr (r, id);\n+\t      gimple_eh_dispatch_set_region (copy, r);\n+\t    }\n+\t    break;\n+\n+\t  default:\n+\t    break;\n+\t  }\n     }\n \n   /* If STMT has a block defined, map it to the newly constructed\n@@ -1377,12 +1450,6 @@ remap_gimple_stmt (gimple stmt, copy_body_data *id)\n       gimple_set_vuse (copy, NULL_TREE);\n     }\n \n-  /* We have to handle EH region remapping of GIMPLE_RESX specially because\n-     the region number is not an operand.  */\n-  if (gimple_code (stmt) == GIMPLE_RESX && id->eh_region_offset)\n-    {\n-      gimple_resx_set_region (copy, gimple_resx_region (stmt) + id->eh_region_offset);\n-    }\n   return copy;\n }\n \n@@ -1617,43 +1684,8 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \t\tcfun->calls_setjmp = true;\n \t    }\n \n-\t  /* If you think we can abort here, you are wrong.\n-\t     There is no region 0 in gimple.  */\n-\t  gcc_assert (lookup_stmt_eh_region_fn (id->src_cfun, orig_stmt) != 0);\n-\n-\t  if (stmt_could_throw_p (stmt)\n-\t      /* When we are cloning for inlining, we are supposed to\n-\t\t construct a clone that calls precisely the same functions\n-\t\t as original.  However IPA optimizers might've proved\n-\t\t earlier some function calls as non-trapping that might\n-\t\t render some basic blocks dead that might become\n-\t\t unreachable.\n-\n-\t\t We can't update SSA with unreachable blocks in CFG and thus\n-\t\t we prevent the scenario by preserving even the \"dead\" eh\n-\t\t edges until the point they are later removed by\n-\t\t fixup_cfg pass.  */\n-\t      || (id->transform_call_graph_edges == CB_CGE_MOVE_CLONES\n-\t\t  && lookup_stmt_eh_region_fn (id->src_cfun, orig_stmt) > 0))\n-\t    {\n-\t      int region = lookup_stmt_eh_region_fn (id->src_cfun, orig_stmt);\n-\n-\t      /* Add an entry for the copied tree in the EH hashtable.\n-\t\t When cloning or versioning, use the hashtable in\n-\t\t cfun, and just copy the EH number.  When inlining, use the\n-\t\t hashtable in the caller, and adjust the region number.  */\n-\t      if (region > 0)\n-\t\tadd_stmt_to_eh_region (stmt, region + id->eh_region_offset);\n-\n-\t      /* If this tree doesn't have a region associated with it,\n-\t\t and there is a \"current region,\"\n-\t\t then associate this tree with the current region\n-\t\t and add edges associated with this region.  */\n-\t      if (lookup_stmt_eh_region_fn (id->src_cfun, orig_stmt) <= 0\n-\t\t  && id->eh_region > 0\n-\t\t  && stmt_could_throw_p (stmt))\n-\t\tadd_stmt_to_eh_region (stmt, id->eh_region);\n-\t    }\n+\t  maybe_duplicate_eh_stmt_fn (cfun, stmt, id->src_cfun, orig_stmt,\n+\t\t\t\t      id->eh_map, id->eh_lp_nr);\n \n \t  if (gimple_in_ssa_p (cfun) && !is_gimple_debug (stmt))\n \t    {\n@@ -1822,7 +1854,9 @@ copy_edges_for_bb (basic_block bb, gcov_type count_scale, basic_block ret_bb)\n \t    }\n \t}\n \n-      if (can_throw)\n+      if (gimple_code (copy_stmt) == GIMPLE_EH_DISPATCH)\n+\tmake_eh_dispatch_edges (copy_stmt);\n+      else if (can_throw)\n \tmake_eh_edges (copy_stmt);\n \n       if (nonlocal_goto)\n@@ -2025,11 +2059,8 @@ copy_cfg_body (copy_body_data * id, gcov_type count, int frequency,\n \n   /* Duplicate any exception-handling regions.  */\n   if (cfun->eh)\n-    {\n-      id->eh_region_offset\n-\t= duplicate_eh_regions (cfun_to_copy, remap_decl_1, id,\n-\t\t\t\t0, id->eh_region);\n-    }\n+    id->eh_map = duplicate_eh_regions (cfun_to_copy, NULL, id->eh_lp_nr,\n+\t\t\t\t       remap_decl_1, id);\n \n   /* Use aux pointers to map the original blocks to copy.  */\n   FOR_EACH_BB_FN (bb, cfun_to_copy)\n@@ -2062,6 +2093,12 @@ copy_cfg_body (copy_body_data * id, gcov_type count, int frequency,\n   entry_block_map->aux = NULL;\n   exit_block_map->aux = NULL;\n \n+  if (id->eh_map)\n+    {\n+      pointer_map_destroy (id->eh_map);\n+      id->eh_map = NULL;\n+    }\n+\n   return new_fndecl;\n }\n \n@@ -3190,14 +3227,6 @@ estimate_num_insns (gimple stmt, eni_weights *weights)\n       lhs = gimple_assign_lhs (stmt);\n       rhs = gimple_assign_rhs1 (stmt);\n \n-      /* EH magic stuff is most probably going to be optimized out.\n-         We rarely really need to save EH info for unwinding\n-         nested exceptions.  */\n-      if (TREE_CODE (lhs) == FILTER_EXPR\n-\t  || TREE_CODE (lhs) == EXC_PTR_EXPR\n-          || TREE_CODE (rhs) == FILTER_EXPR\n-\t  || TREE_CODE (rhs) == EXC_PTR_EXPR)\n-\treturn 0;\n       if (is_gimple_reg (lhs))\n \tcost = 0;\n       else\n@@ -3308,9 +3337,19 @@ estimate_num_insns (gimple stmt, eni_weights *weights)\n       return 0;\n \n     case GIMPLE_ASM:\n-    case GIMPLE_RESX:\n       return 1;\n \n+    case GIMPLE_RESX:\n+      /* This is either going to be an external function call with one\n+\t argument, or two register copy statements plus a goto.  */\n+      return 2;\n+\n+    case GIMPLE_EH_DISPATCH:\n+      /* ??? This is going to turn into a switch statement.  Ideally\n+\t we'd have a look at the eh region and estimate the number of\n+\t edges involved.  */\n+      return 10;\n+\n     case GIMPLE_BIND:\n       return estimate_num_insns_seq (gimple_bind_body (stmt), weights);\n \n@@ -3551,7 +3590,7 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n #endif\n \n   /* We will be inlining this callee.  */\n-  id->eh_region = lookup_stmt_eh_region (stmt);\n+  id->eh_lp_nr = lookup_stmt_eh_lp (stmt);\n \n   /* Update the callers EH personality.  */\n   if (DECL_FUNCTION_PERSONALITY (cg_edge->callee->decl))\n@@ -4935,7 +4974,7 @@ maybe_inline_call_in_expr (tree exp)\n       id.do_not_unshare = true;\n \n       /* We're not inside any EH region.  */\n-      id.eh_region = -1;\n+      id.eh_lp_nr = 0;\n \n       t = copy_tree_body (&id);\n       pointer_map_destroy (decl_map);"}, {"sha": "29932e84e38aa11b06e0b8d0b6b8a8cf88ad054f", "filename": "gcc/tree-inline.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftree-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftree-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.h?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -77,12 +77,12 @@ typedef struct copy_body_data\n      is not.  */\n   gimple gimple_call;\n \n-  /* Exception region the inlined call lie in.  */\n-  int eh_region;\n+  /* Exception landing pad the inlined call lies in.  */\n+  int eh_lp_nr;\n \n-  /* Take region number in the function being copied, add this value and\n-     get eh region number of the duplicate in the function we inline into.  */\n-  int eh_region_offset;\n+  /* Maps region and landing pad structures from the function being copied\n+     to duplicates created within the function we inline into.  */\n+  struct pointer_map_t *eh_map;\n \n   /* We use the same mechanism do all sorts of different things.  Rather\n      than enumerating the different cases, we categorize the behavior"}, {"sha": "73eacf6c2f2bebe62c1426cd3963aaff697b531c", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -269,8 +269,7 @@ execute_fixup_cfg (void)\n \t\t  }\n \t      }\n \n-\t    if (!stmt_could_throw_p (stmt) && lookup_stmt_eh_region (stmt))\n-\t      remove_stmt_from_eh_region (stmt);\n+\t    maybe_clean_eh_stmt (stmt);\n \t  }\n \n \tif (gimple_purge_dead_eh_edges (bb))"}, {"sha": "9ea70e35fb7e2906ae4e02508c665fff90f16266", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -316,6 +316,8 @@ extern struct gimple_opt_pass pass_remove_useless_stmts;\n extern struct gimple_opt_pass pass_lower_cf;\n extern struct gimple_opt_pass pass_refactor_eh;\n extern struct gimple_opt_pass pass_lower_eh;\n+extern struct gimple_opt_pass pass_lower_eh_dispatch;\n+extern struct gimple_opt_pass pass_lower_resx;\n extern struct gimple_opt_pass pass_build_cfg;\n extern struct gimple_opt_pass pass_tree_profile;\n extern struct gimple_opt_pass pass_early_tree_profile;"}, {"sha": "a325d75d91442cfba71c783c7d506dd2aa6cce05", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -1687,14 +1687,6 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n \tpp_string (buffer, \" [non-local]\");\n       break;\n \n-    case EXC_PTR_EXPR:\n-      pp_string (buffer, \"<<<exception object>>>\");\n-      break;\n-\n-    case FILTER_EXPR:\n-      pp_string (buffer, \"<<<filter object>>>\");\n-      break;\n-\n     case LOOP_EXPR:\n       pp_string (buffer, \"while (1)\");\n       if (!(flags & TDF_SLIM))\n@@ -1795,11 +1787,6 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       dump_generic_node (buffer, op0, spc, flags, false);\n       break;\n \n-    case RESX_EXPR:\n-      pp_string (buffer, \"resx \");\n-      dump_generic_node (buffer, TREE_OPERAND (node, 0), spc, flags, false);\n-      break;\n-\n     case ASM_EXPR:\n       pp_string (buffer, \"__asm__\");\n       if (ASM_VOLATILE_P (node))"}, {"sha": "00686c8a2190a6731276f883913be1150f3fefbc", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -890,8 +890,7 @@ scan_function (bool (*scan_expr) (tree *, gimple_stmt_iterator *, bool, void *),\n \t      if (!analysis_stage)\n \t\t{\n \t\t  update_stmt (stmt);\n-\t\t  if (!stmt_could_throw_p (stmt))\n-\t\t    remove_stmt_from_eh_region (stmt);\n+\t\t  maybe_clean_eh_stmt (stmt);\n \t\t}\n \t    }\n \t  if (deleted)"}, {"sha": "9522b28c5484cb5b8caa717f205033759bcae8b7", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -1028,10 +1028,6 @@ ref_maybe_used_by_call_p_1 (gimple call, ao_ref *ref)\n     {\n       tree op = gimple_call_arg (call, i);\n \n-      if (TREE_CODE (op) == EXC_PTR_EXPR\n-\t  || TREE_CODE (op) == FILTER_EXPR)\n-\tcontinue;\n-\n       if (TREE_CODE (op) == WITH_SIZE_EXPR)\n \top = TREE_OPERAND (op, 0);\n "}, {"sha": "67d0472cc59668c603900702bc87d06b1dfd2b8c", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -322,15 +322,6 @@ mark_stmt_if_obviously_necessary (gimple stmt, bool aggressive)\n     case GIMPLE_ASSIGN:\n       if (!lhs)\n         lhs = gimple_assign_lhs (stmt);\n-      /* These values are mildly magic bits of the EH runtime.  We can't\n-\t see the entire lifetime of these values until landing pads are\n-\t generated.  */\n-      if (TREE_CODE (lhs) == EXC_PTR_EXPR\n-\t  || TREE_CODE (lhs) == FILTER_EXPR)\n-\t{\n-\t  mark_stmt_necessary (stmt, true);\n-\t  return;\n-\t}\n       break;\n \n     case GIMPLE_DEBUG:\n@@ -817,28 +808,33 @@ propagate_necessity (struct edge_list *el)\n /* Replace all uses of result of PHI by underlying variable and mark it\n    for renaming.  */\n \n-static void\n+void\n mark_virtual_phi_result_for_renaming (gimple phi)\n {\n   bool used = false;\n   imm_use_iterator iter;\n   use_operand_p use_p;\n   gimple stmt;\n+  tree result_ssa, result_var;\n+\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"Marking result for renaming : \");\n       print_gimple_stmt (dump_file, phi, 0, TDF_SLIM);\n       fprintf (dump_file, \"\\n\");\n     }\n-  FOR_EACH_IMM_USE_STMT (stmt, iter, gimple_phi_result (phi))\n+\n+  result_ssa = gimple_phi_result (phi);\n+  result_var = SSA_NAME_VAR (result_ssa);\n+  FOR_EACH_IMM_USE_STMT (stmt, iter, result_ssa)\n     {\n       FOR_EACH_IMM_USE_ON_STMT (use_p, iter)\n-        SET_USE (use_p, SSA_NAME_VAR (gimple_phi_result (phi)));\n+        SET_USE (use_p, result_var);\n       update_stmt (stmt);\n       used = true;\n     }\n   if (used)\n-    mark_sym_for_renaming (SSA_NAME_VAR (PHI_RESULT (phi)));\n+    mark_sym_for_renaming (result_var);\n }\n \n /* Remove dead PHI nodes from block BB.  */"}, {"sha": "28e6ec65826f164edfd203932fd270f559391e2a", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -1000,8 +1000,6 @@ get_expr_operands (gimple stmt, tree *expr_p, int flags)\n     case LABEL_DECL:\n     case CONST_DECL:\n     case CASE_LABEL_EXPR:\n-    case FILTER_EXPR:\n-    case EXC_PTR_EXPR:\n       /* Expressions that make no memory references.  */\n       return;\n "}, {"sha": "5da6c63b4003e6a3465295433688138f5ad3cb58", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -1068,9 +1068,7 @@ get_or_alloc_expr_for (tree t)\n {\n   if (TREE_CODE (t) == SSA_NAME)\n     return get_or_alloc_expr_for_name (t);\n-  else if (is_gimple_min_invariant (t)\n-\t   || TREE_CODE (t) == EXC_PTR_EXPR\n-\t   || TREE_CODE (t) == FILTER_EXPR)\n+  else if (is_gimple_min_invariant (t))\n     return get_or_alloc_expr_for_constant (t);\n   else\n     {\n@@ -2549,17 +2547,6 @@ can_value_number_call (gimple stmt)\n   return false;\n }\n \n-/* Return true if OP is an exception handler related operation, such as\n-   FILTER_EXPR or EXC_PTR_EXPR.  */\n-\n-static bool\n-is_exception_related (gimple stmt)\n-{\n-  return (is_gimple_assign (stmt)\n-\t  && (gimple_assign_rhs_code (stmt) == FILTER_EXPR\n-\t      || gimple_assign_rhs_code (stmt) == EXC_PTR_EXPR));\n-}\n-\n /* Return true if OP is a tree which we can perform PRE on.\n    This may not match the operations we can value number, but in\n    a perfect world would.  */\n@@ -3885,8 +3872,6 @@ compute_avail (void)\n \t\tswitch (TREE_CODE_CLASS (gimple_assign_rhs_code (stmt)))\n \t\t  {\n \t\t  case tcc_unary:\n-\t\t    if (is_exception_related (stmt))\n-\t\t      continue;\n \t\t  case tcc_binary:\n \t\t  case tcc_comparison:\n \t\t    {"}, {"sha": "42d89e919202fd8d1a23eaef65428dfec72f12d5", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -617,10 +617,6 @@ valid_gimple_rhs_p (tree expr)\n \t    return false;\n \t  break;\n \n-\tcase EXC_PTR_EXPR:\n-\tcase FILTER_EXPR:\n-\t  break;\n-\n \tdefault:\n \t  return false;\n \t}"}, {"sha": "4158fbd88dfa44cbd6bf4a5e09cfdb4107cfc753", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -576,8 +576,6 @@ copy_reference_ops_from_ref (tree ref, VEC(vn_reference_op_s, heap) **result)\n \tcase CONST_DECL:\n \tcase RESULT_DECL:\n \tcase SSA_NAME:\n-\tcase EXC_PTR_EXPR:\n-\tcase FILTER_EXPR:\n \t  temp.op0 = ref;\n \t  break;\n \tcase ADDR_EXPR:\n@@ -688,8 +686,6 @@ ao_ref_init_from_vn_reference (ao_ref *ref,\n \tcase PARM_DECL:\n \tcase RESULT_DECL:\n \tcase SSA_NAME:\n-\tcase FILTER_EXPR:\n-\tcase EXC_PTR_EXPR:\n \t  *op0_p = op->op0;\n \t  break;\n "}, {"sha": "a9b4b67679b431fb29aef36c56fb8b036527d2df", "filename": "gcc/tree-ssa-sink.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftree-ssa-sink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftree-ssa-sink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sink.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -323,8 +323,6 @@ statement_sink_location (gimple stmt, basic_block frombb,\n   code = gimple_assign_rhs_code (stmt);\n   if (stmt_ends_bb_p (stmt)\n       || gimple_has_side_effects (stmt)\n-      || code == EXC_PTR_EXPR\n-      || code == FILTER_EXPR\n       || is_hidden_global_store (stmt)\n       || gimple_has_volatile_ops (stmt)\n       || gimple_vuse (stmt)"}, {"sha": "e5f4a292855ae521af8e0ac2eeb0a482ad870650", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -425,10 +425,6 @@ struct constraint\n static VEC(constraint_t,heap) *constraints;\n static alloc_pool constraint_pool;\n \n-\n-DEF_VEC_I(int);\n-DEF_VEC_ALLOC_I(int, heap);\n-\n /* The constraint graph is represented as an array of bitmaps\n    containing successor nodes.  */\n \n@@ -1287,10 +1283,6 @@ build_succ_graph (void)\n static unsigned int changed_count;\n static sbitmap changed;\n \n-DEF_VEC_I(unsigned);\n-DEF_VEC_ALLOC_I(unsigned,heap);\n-\n-\n /* Strongly Connected Component visitation info.  */\n \n struct scc_info"}, {"sha": "d2243e5d1bd474444084e38bfd7f4d7e4d197725", "filename": "gcc/tree.c", "status": "modified", "additions": 81, "deletions": 37, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -4667,23 +4667,36 @@ get_eh_types_for_runtime (tree list)\n static void\n find_decls_types_in_eh_region (eh_region r, struct free_lang_data_d *fld)\n {\n-  if (r == NULL)\n-    return;\n-\n-  /* The types referenced in R must first be changed to the EH types\n-     used at runtime.  This removes references to FE types in the\n-     region.  */\n-  if (r->type == ERT_CATCH)\n+  switch (r->type)\n     {\n-      tree list = r->u.eh_catch.type_list;\n-      r->u.eh_catch.type_list = get_eh_types_for_runtime (list);\n-      find_decls_types (r->u.eh_catch.type_list, fld);\n-    }\n-  else if (r->type == ERT_ALLOWED_EXCEPTIONS)\n-    {\n-      tree list = r->u.allowed.type_list;\n-      r->u.allowed.type_list = get_eh_types_for_runtime (list);\n-      find_decls_types (r->u.allowed.type_list, fld);\n+    case ERT_CLEANUP:\n+      break;\n+\n+    case ERT_TRY:\n+      {\n+\teh_catch c;\n+\n+\t/* The types referenced in each catch must first be changed to the\n+\t   EH types used at runtime.  This removes references to FE types\n+\t   in the region.  */\n+\tfor (c = r->u.eh_try.first_catch; c ; c = c->next_catch)\n+\t  {\n+\t    c->type_list = get_eh_types_for_runtime (c->type_list);\n+\t    walk_tree (&c->type_list, find_decls_types_r, fld, fld->pset);\n+\t  }\n+      }\n+      break;\n+\n+    case ERT_ALLOWED_EXCEPTIONS:\n+      r->u.allowed.type_list\n+\t= get_eh_types_for_runtime (r->u.allowed.type_list);\n+      walk_tree (&r->u.allowed.type_list, find_decls_types_r, fld, fld->pset);\n+      break;\n+\n+    case ERT_MUST_NOT_THROW:\n+      walk_tree (&r->u.must_not_throw.failure_decl,\n+\t\t find_decls_types_r, fld, fld->pset);\n+      break;\n     }\n }\n \n@@ -4715,14 +4728,11 @@ find_decls_types_in_node (struct cgraph_node *n, struct free_lang_data_d *fld)\n     find_decls_types (TREE_VALUE (t), fld);\n \n   /* Traverse EH regions in FN.  */\n-  if (fn->eh->region_array)\n-    {\n-      unsigned i;\n-      eh_region r;\n-\n-      for (i = 0; VEC_iterate (eh_region, fn->eh->region_array, i, r); i++)\n-\tfind_decls_types_in_eh_region (r, fld);\n-    }\n+  {\n+    eh_region r;\n+    FOR_ALL_EH_REGION_FN (r, fn)\n+      find_decls_types_in_eh_region (r, fld);\n+  }\n \n   /* Traverse every statement in FN.  */\n   FOR_EACH_BB_FN (bb, fn)\n@@ -8880,12 +8890,15 @@ local_define_builtin (const char *name, tree type, enum built_in_function code,\n \n /* Call this function after instantiating all builtins that the language\n    front end cares about.  This will build the rest of the builtins that\n-   are relied upon by the tree optimizers and the middle-end.  */\n+   are relied upon by the tree optimizers and the middle-end.\n+\n+   ENABLE_CXA_END_CLEANUP should be true for C++ and Java, where the ARM\n+   EABI requires a slightly different implementation of _Unwind_Resume.  */\n \n void\n-build_common_builtin_nodes (void)\n+build_common_builtin_nodes (bool enable_cxa_end_cleanup)\n {\n-  tree tmp, ftype;\n+  tree tmp, tmp2, ftype;\n \n   if (built_in_decls[BUILT_IN_MEMCPY] == NULL\n       || built_in_decls[BUILT_IN_MEMMOVE] == NULL)\n@@ -8990,6 +9003,47 @@ build_common_builtin_nodes (void)\n   local_define_builtin (\"__builtin_profile_func_exit\", ftype,\n \t\t\tBUILT_IN_PROFILE_FUNC_EXIT, \"profile_func_exit\", 0);\n \n+  if (enable_cxa_end_cleanup && targetm.arm_eabi_unwinder)\n+    {\n+      ftype = build_function_type (void_type_node, void_list_node);\n+      local_define_builtin (\"__builtin_unwind_resume\", ftype,\n+\t\t\t    BUILT_IN_UNWIND_RESUME,\n+\t\t\t    \"__cxa_end_cleanup\", ECF_NORETURN);\n+    }\n+  else\n+    {\n+      tmp = tree_cons (NULL_TREE, ptr_type_node, void_list_node);\n+      ftype = build_function_type (void_type_node, tmp);\n+      local_define_builtin (\"__builtin_unwind_resume\", ftype,\n+\t\t\t    BUILT_IN_UNWIND_RESUME,\n+\t\t\t    (USING_SJLJ_EXCEPTIONS\n+\t\t\t     ? \"_Unwind_SjLj_Resume\" : \"_Unwind_Resume\"),\n+\t\t\t    ECF_NORETURN);\n+    }\n+\n+  /* The exception object and filter values from the runtime.  The argument\n+     must be zero before exception lowering, i.e. from the front end.  After\n+     exception lowering, it will be the region number for the exception\n+     landing pad.  These functions are PURE instead of CONST to prevent\n+     them from being hoisted past the exception edge that will initialize\n+     its value in the landing pad.  */\n+  tmp = tree_cons (NULL_TREE, integer_type_node, void_list_node);\n+  ftype = build_function_type (ptr_type_node, tmp);\n+  local_define_builtin (\"__builtin_eh_pointer\", ftype, BUILT_IN_EH_POINTER,\n+\t\t\t\"__builtin_eh_pointer\", ECF_PURE | ECF_NOTHROW);\n+\n+  tmp2 = lang_hooks.types.type_for_mode (targetm.eh_return_filter_mode (), 0);\n+  ftype = build_function_type (tmp2, tmp);\n+  local_define_builtin (\"__builtin_eh_filter\", ftype, BUILT_IN_EH_FILTER,\n+\t\t\t\"__builtin_eh_filter\", ECF_PURE | ECF_NOTHROW);\n+\n+  tmp = tree_cons (NULL_TREE, integer_type_node, void_list_node);\n+  tmp = tree_cons (NULL_TREE, integer_type_node, tmp);\n+  ftype = build_function_type (void_type_node, tmp);\n+  local_define_builtin (\"__builtin_eh_copy_values\", ftype,\n+\t\t\tBUILT_IN_EH_COPY_VALUES,\n+\t\t\t\"__builtin_eh_copy_values\", ECF_NOTHROW);\n+\n   /* Complex multiplication and division.  These are handled as builtins\n      rather than optabs because emit_library_call_value doesn't support\n      complex.  Further, we can do slightly better with folding these \n@@ -9151,16 +9205,6 @@ build_opaque_vector_type (tree innertype, int nunits)\n }\n \n \n-/* Build RESX_EXPR with given REGION_NUMBER.  */\n-tree\n-build_resx (int region_number)\n-{\n-  tree t;\n-  t = build1 (RESX_EXPR, void_type_node,\n-\t      build_int_cst (NULL_TREE, region_number));\n-  return t;\n-}\n-\n /* Given an initializer INIT, return TRUE if INIT is zero or some\n    aggregate of zeros.  Otherwise return FALSE.  */\n bool"}, {"sha": "71987ef1d4d9b5e43ce5b424478fa67c9664041f", "filename": "gcc/tree.def", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -440,12 +440,6 @@ DEFTREECODE (MISALIGNED_INDIRECT_REF, \"misaligned_indirect_ref\", tcc_reference,\n    identifier or a vtable index.  */\n DEFTREECODE (OBJ_TYPE_REF, \"obj_type_ref\", tcc_expression, 3)\n \n-/* The exception object from the runtime.  */\n-DEFTREECODE (EXC_PTR_EXPR, \"exc_ptr_expr\", tcc_expression, 0)\n-\n-/* The filter object from the runtime.  */\n-DEFTREECODE (FILTER_EXPR, \"filter_expr\", tcc_expression, 0)\n-\n /* Constructor: return an aggregate value made from specified components.\n    In C, this is used only for structure and array initializers.\n    The operand is a sequence of component values made out of a VEC of\n@@ -878,10 +872,6 @@ DEFTREECODE (SWITCH_EXPR, \"switch_expr\", tcc_statement, 3)\n    label.  CASE_LABEL is the corresponding LABEL_DECL.  */\n DEFTREECODE (CASE_LABEL_EXPR, \"case_label_expr\", tcc_statement, 3)\n \n-/* RESX.  Resume execution after an exception.  Operand 0 is a\n-   number indicating the exception region that is being left.  */\n-DEFTREECODE (RESX_EXPR, \"resx_expr\", tcc_statement, 1)\n-\n /* Used to represent an inline assembly statement.  ASM_STRING returns a\n    STRING_CST for the instruction (e.g., \"mov x, y\"). ASM_OUTPUTS,\n    ASM_INPUTS, and ASM_CLOBBERS represent the outputs, inputs, and clobbers"}, {"sha": "b9404c7da1889d5fd72737dfa82a8fef833f1218", "filename": "gcc/tree.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -444,9 +444,6 @@ struct GTY(()) tree_common {\n        ASM_INPUT_P in\n            ASM_EXPR\n \n-       EH_FILTER_MUST_NOT_THROW in\n-           EH_FILTER_EXPR\n-\n        TYPE_REF_CAN_ALIAS_ALL in\n            POINTER_TYPE, REFERENCE_TYPE\n \n@@ -1659,8 +1656,6 @@ extern void protected_set_expr_location (tree, location_t);\n /* EH_FILTER_EXPR accessors.  */\n #define EH_FILTER_TYPES(NODE)\tTREE_OPERAND (EH_FILTER_EXPR_CHECK (NODE), 0)\n #define EH_FILTER_FAILURE(NODE)\tTREE_OPERAND (EH_FILTER_EXPR_CHECK (NODE), 1)\n-#define EH_FILTER_MUST_NOT_THROW(NODE) \\\n-  (EH_FILTER_EXPR_CHECK (NODE)->base.static_flag)\n \n /* OBJ_TYPE_REF accessors.  */\n #define OBJ_TYPE_REF_EXPR(NODE)\t  TREE_OPERAND (OBJ_TYPE_REF_CHECK (NODE), 0)\n@@ -2796,6 +2791,11 @@ struct GTY(()) tree_field_decl {\n #define LABEL_DECL_UID(NODE) \\\n   (LABEL_DECL_CHECK (NODE)->label_decl.label_decl_uid)\n \n+/* In a LABEL_DECL, the EH region number for which the label is the\n+   post_landing_pad.  */\n+#define EH_LANDING_PAD_NR(NODE) \\\n+  (LABEL_DECL_CHECK (NODE)->label_decl.eh_landing_pad_nr)\n+\n /* In LABEL_DECL nodes, nonzero means that an error message about\n    jumping into such a binding contour has been printed for this label.  */\n #define DECL_ERROR_ISSUED(NODE) \\\n@@ -2804,6 +2804,7 @@ struct GTY(()) tree_field_decl {\n struct GTY(()) tree_label_decl {\n   struct tree_decl_with_rtl common;\n   int label_decl_uid;\n+  int eh_landing_pad_nr;\n };\n \n struct GTY(()) tree_result_decl {\n@@ -3914,7 +3915,6 @@ extern tree build_method_type_directly (tree, tree, tree);\n extern tree build_method_type (tree, tree);\n extern tree build_offset_type (tree, tree);\n extern tree build_complex_type (tree);\n-extern tree build_resx (int);\n extern tree array_type_nelts (const_tree);\n extern bool in_array_bounds_p (tree);\n extern bool range_in_array_bounds_p (tree);\n@@ -4937,7 +4937,7 @@ extern int real_minus_onep (const_tree);\n extern void init_ttree (void);\n extern void build_common_tree_nodes (bool, bool);\n extern void build_common_tree_nodes_2 (int);\n-extern void build_common_builtin_nodes (void);\n+extern void build_common_builtin_nodes (bool);\n extern tree build_nonstandard_integer_type (unsigned HOST_WIDE_INT, int);\n extern tree build_range_type (tree, tree, tree);\n extern bool subrange_type_for_debug_p (const_tree, tree *, tree *);"}, {"sha": "9109286587c64802bbcef4abfb7819f27be3e1eb", "filename": "gcc/value-prof.c", "status": "modified", "additions": 111, "deletions": 119, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -1087,84 +1087,86 @@ find_func_by_pid (int\tpid)\n  */\n \n static gimple\n-gimple_ic (gimple stmt, gimple call, struct cgraph_node *direct_call, \n+gimple_ic (gimple icall_stmt, struct cgraph_node *direct_call, \n \t   int prob, gcov_type count, gcov_type all)\n {\n-  gimple stmt1, stmt2, stmt3;\n+  gimple dcall_stmt, load_stmt, cond_stmt;\n   tree tmp1, tmpv, tmp;\n-  gimple bb1end, bb2end, bb3end;\n-  basic_block bb, bb2, bb3, bb4;\n+  basic_block cond_bb, dcall_bb, icall_bb, join_bb;\n   tree optype = build_pointer_type (void_type_node);\n-  edge e12, e13, e23, e24, e34;\n+  edge e_cd, e_ci, e_di, e_dj, e_ij;\n   gimple_stmt_iterator gsi;\n-  int region;\n+  int lp_nr;\n \n-  bb = gimple_bb (stmt);\n-  gsi = gsi_for_stmt (stmt);\n+  cond_bb = gimple_bb (icall_stmt);\n+  gsi = gsi_for_stmt (icall_stmt);\n \n   tmpv = create_tmp_var (optype, \"PROF\");\n   tmp1 = create_tmp_var (optype, \"PROF\");\n-  stmt1 = gimple_build_assign (tmpv, unshare_expr (gimple_call_fn (call)));\n+  tmp = unshare_expr (gimple_call_fn (icall_stmt));\n+  load_stmt = gimple_build_assign (tmpv, tmp);\n+  gsi_insert_before (&gsi, load_stmt, GSI_SAME_STMT);\n \n   tmp = fold_convert (optype, build_addr (direct_call->decl, \n \t\t\t\t\t  current_function_decl));\n-  stmt2 = gimple_build_assign (tmp1, tmp);\n-  stmt3 = gimple_build_cond (NE_EXPR, tmp1, tmpv, NULL_TREE, NULL_TREE);\n-  gsi_insert_before (&gsi, stmt1, GSI_SAME_STMT);\n-  gsi_insert_before (&gsi, stmt2, GSI_SAME_STMT);\n-  gsi_insert_before (&gsi, stmt3, GSI_SAME_STMT);\n-  bb1end = stmt3;\n+  load_stmt = gimple_build_assign (tmp1, tmp);\n+  gsi_insert_before (&gsi, load_stmt, GSI_SAME_STMT);\n \n-  stmt1 = gimple_copy (stmt);\n-  gimple_call_set_fndecl (stmt1, direct_call->decl);\n-  gsi_insert_before (&gsi, stmt1, GSI_SAME_STMT);\n-  bb2end = stmt1;\n-  bb3end = stmt;\n+  cond_stmt = gimple_build_cond (EQ_EXPR, tmp1, tmpv, NULL_TREE, NULL_TREE);\n+  gsi_insert_before (&gsi, cond_stmt, GSI_SAME_STMT);\n+\n+  dcall_stmt = gimple_copy (icall_stmt);\n+  gimple_call_set_fndecl (dcall_stmt, direct_call->decl);\n+  gsi_insert_before (&gsi, dcall_stmt, GSI_SAME_STMT);\n \n   /* Fix CFG. */\n-  /* Edge e23 connects bb2 to bb3, etc. */\n-  e12 = split_block (bb, bb1end);\n-  bb2 = e12->dest;\n-  bb2->count = count;\n-  e23 = split_block (bb2, bb2end);\n-  bb3 = e23->dest;\n-  bb3->count = all - count;\n-  e34 = split_block (bb3, bb3end);\n-  bb4 = e34->dest;\n-  bb4->count = all;\n+  /* Edge e_cd connects cond_bb to dcall_bb, etc; note the first letters. */\n+  e_cd = split_block (cond_bb, cond_stmt);\n+  dcall_bb = e_cd->dest;\n+  dcall_bb->count = count;\n \n-  e12->flags &= ~EDGE_FALLTHRU;\n-  e12->flags |= EDGE_FALSE_VALUE;\n-  e12->probability = prob;\n-  e12->count = count;\n+  e_di = split_block (dcall_bb, dcall_stmt);\n+  icall_bb = e_di->dest;\n+  icall_bb->count = all - count;\n \n-  e13 = make_edge (bb, bb3, EDGE_TRUE_VALUE);\n-  e13->probability = REG_BR_PROB_BASE - prob;\n-  e13->count = all - count;\n+  e_ij = split_block (icall_bb, icall_stmt);\n+  join_bb = e_ij->dest;\n+  join_bb->count = all;\n \n-  remove_edge (e23);\n+  e_cd->flags = (e_cd->flags & ~EDGE_FALLTHRU) | EDGE_TRUE_VALUE;\n+  e_cd->probability = prob;\n+  e_cd->count = count;\n+\n+  e_ci = make_edge (cond_bb, icall_bb, EDGE_FALSE_VALUE);\n+  e_ci->probability = REG_BR_PROB_BASE - prob;\n+  e_ci->count = all - count;\n+\n+  remove_edge (e_di);\n   \n-  e24 = make_edge (bb2, bb4, EDGE_FALLTHRU);\n-  e24->probability = REG_BR_PROB_BASE;\n-  e24->count = count;\n-  e34->probability = REG_BR_PROB_BASE;\n-  e34->count = all - count;\n+  e_dj = make_edge (dcall_bb, join_bb, EDGE_FALLTHRU);\n+  e_dj->probability = REG_BR_PROB_BASE;\n+  e_dj->count = count;\n+\n+  e_ij->probability = REG_BR_PROB_BASE;\n+  e_ij->count = all - count;\n \n   /* Fix eh edges */\n-  region = lookup_stmt_eh_region (stmt);\n-  if (region >= 0 && stmt_could_throw_p (stmt1))\n+  lp_nr = lookup_stmt_eh_lp (icall_stmt);\n+  if (lp_nr != 0)\n     {\n-      add_stmt_to_eh_region (stmt1, region);\n-      make_eh_edges (stmt1);\n-    }\n+      gimple_purge_dead_eh_edges (join_bb);\n \n-  if (region >= 0 && stmt_could_throw_p (stmt))\n-    {\n-      gimple_purge_dead_eh_edges (bb4);\n-      make_eh_edges (stmt);\n+      if (stmt_could_throw_p (dcall_stmt))\n+\t{\n+\t  add_stmt_to_eh_lp (dcall_stmt, lp_nr);\n+\t  make_eh_edges (dcall_stmt);\n+\t}\n+\n+      gcc_assert (stmt_could_throw_p (icall_stmt));\n+      make_eh_edges (icall_stmt);\n     }\n \n-  return stmt1;\n+  return dcall_stmt;\n }\n \n /*\n@@ -1220,7 +1222,7 @@ gimple_ic_transform (gimple stmt)\n   if (direct_call == NULL)\n     return false;\n \n-  modify = gimple_ic (stmt, stmt, direct_call, prob, count, all);\n+  modify = gimple_ic (stmt, direct_call, prob, count, all);\n \n   if (dump_file)\n     {\n@@ -1266,89 +1268,79 @@ interesting_stringop_to_profile_p (tree fndecl, gimple call)\n     }\n }\n \n-/* Convert   stringop (..., size)\n+/* Convert   stringop (..., vcall_size)\n    into \n-   if (size == VALUE)\n-     stringop (...., VALUE);\n+   if (vcall_size == icall_size)\n+     stringop (..., icall_size);\n    else\n-     stringop (...., size);\n-   assuming constant propagation of VALUE will happen later.\n-*/\n+     stringop (..., vcall_size);\n+   assuming we'll propagate a true constant into ICALL_SIZE later.  */\n+\n static void\n-gimple_stringop_fixed_value (gimple stmt, tree value, int prob, gcov_type count,\n-\t\t\t   gcov_type all)\n+gimple_stringop_fixed_value (gimple vcall_stmt, tree icall_size, int prob,\n+\t\t\t     gcov_type count, gcov_type all)\n {\n-  gimple stmt1, stmt2, stmt3;\n-  tree tmp1, tmpv;\n-  gimple bb1end, bb2end;\n-  basic_block bb, bb2, bb3, bb4;\n-  edge e12, e13, e23, e24, e34;\n+  gimple tmp_stmt, cond_stmt, icall_stmt;\n+  tree tmp1, tmpv, vcall_size, optype;\n+  basic_block cond_bb, icall_bb, vcall_bb, join_bb;\n+  edge e_ci, e_cv, e_iv, e_ij, e_vj;\n   gimple_stmt_iterator gsi;\n-  tree blck_size = gimple_call_arg (stmt, 2);\n-  tree optype = TREE_TYPE (blck_size);\n-  int region;\n \n-  bb = gimple_bb (stmt);\n-  gsi = gsi_for_stmt (stmt);\n+  cond_bb = gimple_bb (vcall_stmt);\n+  gsi = gsi_for_stmt (vcall_stmt);\n \n-  if (gsi_end_p (gsi))\n-    {\n-      edge_iterator ei;\n-      for (ei = ei_start (bb->succs); (e34 = ei_safe_edge (ei)); )\n-\tif (!(e34->flags & EDGE_ABNORMAL))\n-\t  break;\n-    }\n-  else\n-    {\n-      e34 = split_block (bb, stmt);\n-      gsi = gsi_for_stmt (stmt);\n-    }\n-  bb4 = e34->dest;\n+  vcall_size = gimple_call_arg (vcall_stmt, 2);\n+  optype = TREE_TYPE (vcall_size);\n \n   tmpv = create_tmp_var (optype, \"PROF\");\n   tmp1 = create_tmp_var (optype, \"PROF\");\n-  stmt1 = gimple_build_assign (tmpv, fold_convert (optype, value));\n-  stmt2 = gimple_build_assign (tmp1, blck_size);\n-  stmt3 = gimple_build_cond (NE_EXPR, tmp1, tmpv, NULL_TREE, NULL_TREE);\n-  gsi_insert_before (&gsi, stmt1, GSI_SAME_STMT);\n-  gsi_insert_before (&gsi, stmt2, GSI_SAME_STMT);\n-  gsi_insert_before (&gsi, stmt3, GSI_SAME_STMT);\n-  bb1end = stmt3;\n+  tmp_stmt = gimple_build_assign (tmpv, fold_convert (optype, icall_size));\n+  gsi_insert_before (&gsi, tmp_stmt, GSI_SAME_STMT);\n \n-  stmt1 = gimple_copy (stmt);\n-  gimple_call_set_arg (stmt1, 2, value);\n-  gsi_insert_before (&gsi, stmt1, GSI_SAME_STMT);\n-  region = lookup_stmt_eh_region (stmt);\n-  if (region >= 0)\n-    add_stmt_to_eh_region (stmt1, region);\n-  bb2end = stmt1;\n+  tmp_stmt = gimple_build_assign (tmp1, vcall_size);\n+  gsi_insert_before (&gsi, tmp_stmt, GSI_SAME_STMT);\n+\n+  cond_stmt = gimple_build_cond (EQ_EXPR, tmp1, tmpv, NULL_TREE, NULL_TREE);\n+  gsi_insert_before (&gsi, cond_stmt, GSI_SAME_STMT);\n+\n+  icall_stmt = gimple_copy (vcall_stmt);\n+  gimple_call_set_arg (icall_stmt, 2, icall_size);\n+  gsi_insert_before (&gsi, icall_stmt, GSI_SAME_STMT);\n \n   /* Fix CFG. */\n-  /* Edge e23 connects bb2 to bb3, etc. */\n-  e12 = split_block (bb, bb1end);\n-  bb2 = e12->dest;\n-  bb2->count = count;\n-  e23 = split_block (bb2, bb2end);\n-  bb3 = e23->dest;\n-  bb3->count = all - count;\n+  /* Edge e_ci connects cond_bb to icall_bb, etc. */\n+  e_ci = split_block (cond_bb, cond_stmt);\n+  icall_bb = e_ci->dest;\n+  icall_bb->count = count;\n \n-  e12->flags &= ~EDGE_FALLTHRU;\n-  e12->flags |= EDGE_FALSE_VALUE;\n-  e12->probability = prob;\n-  e12->count = count;\n+  e_iv = split_block (icall_bb, icall_stmt);\n+  vcall_bb = e_iv->dest;\n+  vcall_bb->count = all - count;\n \n-  e13 = make_edge (bb, bb3, EDGE_TRUE_VALUE);\n-  e13->probability = REG_BR_PROB_BASE - prob;\n-  e13->count = all - count;\n+  e_vj = split_block (vcall_bb, vcall_stmt);\n+  join_bb = e_vj->dest;\n+  join_bb->count = all;\n \n-  remove_edge (e23);\n+  e_ci->flags = (e_ci->flags & ~EDGE_FALLTHRU) | EDGE_TRUE_VALUE;\n+  e_ci->probability = prob;\n+  e_ci->count = count;\n+\n+  e_cv = make_edge (cond_bb, vcall_bb, EDGE_FALSE_VALUE);\n+  e_cv->probability = REG_BR_PROB_BASE - prob;\n+  e_cv->count = all - count;\n+\n+  remove_edge (e_iv);\n   \n-  e24 = make_edge (bb2, bb4, EDGE_FALLTHRU);\n-  e24->probability = REG_BR_PROB_BASE;\n-  e24->count = count;\n+  e_ij = make_edge (icall_bb, join_bb, EDGE_FALLTHRU);\n+  e_ij->probability = REG_BR_PROB_BASE;\n+  e_ij->count = count;\n \n-  e34->probability = REG_BR_PROB_BASE;\n-  e34->count = all - count;\n+  e_vj->probability = REG_BR_PROB_BASE;\n+  e_vj->count = all - count;\n+\n+  /* Because these are all string op builtins, they're all nothrow.  */\n+  gcc_assert (!stmt_could_throw_p (vcall_stmt));\n+  gcc_assert (!stmt_could_throw_p (icall_stmt));\n }\n \n /* Find values inside STMT for that we want to measure histograms for"}, {"sha": "e9ccc52bcb09e93142973e30dd7ed5750f297e66", "filename": "gcc/vecprim.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fvecprim.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d65f45cfaefa060737af130c3fc69afb3030980/gcc%2Fvecprim.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvecprim.h?ref=1d65f45cfaefa060737af130c3fc69afb3030980", "patch": "@@ -23,6 +23,11 @@ along with GCC; see the file COPYING3.  If not see\n DEF_VEC_I(char);\n DEF_VEC_ALLOC_I(char,heap);\n \n+typedef unsigned char uchar;\n+DEF_VEC_I(uchar);\n+DEF_VEC_ALLOC_I(uchar,heap);\n+DEF_VEC_ALLOC_I(uchar,gc);\n+\n DEF_VEC_I(int);\n DEF_VEC_ALLOC_I(int,heap);\n "}]}