{"sha": "34019e282b8c0d82660f64fc69726098178d4ea2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQwMTllMjgyYjhjMGQ4MjY2MGY2NGZjNjk3MjYwOTgxNzhkNGVhMg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2011-03-25T15:05:00Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2011-03-25T15:05:00Z"}, "message": "tree-flow.h (verify_stmts): Rename to verify_gimple_in_cfg.\n\n2011-03-25  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-flow.h (verify_stmts): Rename to verify_gimple_in_cfg.\n\t(verify_types_in_gimple_seq): Rename to verify_gimple_in_seq.\n\t(verify_gimple): Remove.\n\t* tree-cfg.c (verify_gimple_call): Merge verification\n\tfrom verify_stmts.\n\t(verify_gimple_phi): Merge verification from verify_stmts.\n\t(verify_gimple_label): New function.\n\t(verify_types_in_gimple_seq_2): Rename to verify_gimple_in_seq_2.\n\t(verify_types_in_gimple_seq): Rename to verify_gimple_in_seq.\n\t(verify_stmt): Merge into verify_gimple_in_cfg and callees.\n\t(verify_stmts): Rename to verify_gimple_in_cfg.\n\t(verify_gimple_in_cfg): New function.\n\t* passes.c (execute_function_todo): Call verify_gimple_in_cfg.\n\t* tree-ssa.c (verify_ssa): Likewise.\n\t* gimplify.c (gimplify_body): Call verify_gimple_in_seq.\n\nFrom-SVN: r171453", "tree": {"sha": "7ad81eb13f0ec002f0cb3343910aae30054ce13c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ad81eb13f0ec002f0cb3343910aae30054ce13c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/34019e282b8c0d82660f64fc69726098178d4ea2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34019e282b8c0d82660f64fc69726098178d4ea2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34019e282b8c0d82660f64fc69726098178d4ea2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34019e282b8c0d82660f64fc69726098178d4ea2/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1bcce263a7257de484931932d1a7a971a45f54e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bcce263a7257de484931932d1a7a971a45f54e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1bcce263a7257de484931932d1a7a971a45f54e0"}], "stats": {"total": 468, "additions": 219, "deletions": 249}, "files": [{"sha": "2001e374e800864ec2bb726bb303cbc7084cc270", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34019e282b8c0d82660f64fc69726098178d4ea2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34019e282b8c0d82660f64fc69726098178d4ea2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=34019e282b8c0d82660f64fc69726098178d4ea2", "patch": "@@ -1,3 +1,21 @@\n+2011-03-25  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-flow.h (verify_stmts): Rename to verify_gimple_in_cfg.\n+\t(verify_types_in_gimple_seq): Rename to verify_gimple_in_seq.\n+\t(verify_gimple): Remove.\n+\t* tree-cfg.c (verify_gimple_call): Merge verification\n+\tfrom verify_stmts.\n+\t(verify_gimple_phi): Merge verification from verify_stmts.\n+\t(verify_gimple_label): New function.\n+\t(verify_types_in_gimple_seq_2): Rename to verify_gimple_in_seq_2.\n+\t(verify_types_in_gimple_seq): Rename to verify_gimple_in_seq.\n+\t(verify_stmt): Merge into verify_gimple_in_cfg and callees.\n+\t(verify_stmts): Rename to verify_gimple_in_cfg.\n+\t(verify_gimple_in_cfg): New function.\n+\t* passes.c (execute_function_todo): Call verify_gimple_in_cfg.\n+\t* tree-ssa.c (verify_ssa): Likewise.\n+\t* gimplify.c (gimplify_body): Call verify_gimple_in_seq.\n+\n 2011-03-25  Richard Guenther  <rguenther@suse.de>\n \n \t* passes.c (init_optimization_passes): Add FRE pass after"}, {"sha": "633e613da9f88080f55063c781900ca42a11e9f0", "filename": "gcc/gimplify.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34019e282b8c0d82660f64fc69726098178d4ea2/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34019e282b8c0d82660f64fc69726098178d4ea2/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=34019e282b8c0d82660f64fc69726098178d4ea2", "patch": "@@ -7769,10 +7769,8 @@ gimplify_body (tree *body_p, tree fndecl, bool do_parms)\n   pop_gimplify_context (outer_bind);\n   gcc_assert (gimplify_ctxp == NULL);\n \n-#ifdef ENABLE_TYPES_CHECKING\n   if (!seen_error ())\n-    verify_types_in_gimple_seq (gimple_bind_body (outer_bind));\n-#endif\n+    verify_gimple_in_seq (gimple_bind_body (outer_bind));\n \n   timevar_pop (TV_TREE_GIMPLIFY);\n   input_location = saved_location;"}, {"sha": "ffe4ff7b846060ad4436af1de07ce6f397530822", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34019e282b8c0d82660f64fc69726098178d4ea2/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34019e282b8c0d82660f64fc69726098178d4ea2/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=34019e282b8c0d82660f64fc69726098178d4ea2", "patch": "@@ -1240,7 +1240,7 @@ execute_function_todo (void *data)\n   if (flags & TODO_verify_flow)\n     verify_flow_info ();\n   if (flags & TODO_verify_stmts)\n-    verify_stmts ();\n+    verify_gimple_in_cfg (cfun);\n   if (current_loops && loops_state_satisfies_p (LOOP_CLOSED_SSA))\n     verify_loop_closed_ssa (false);\n   if (flags & TODO_verify_rtl_sharing)"}, {"sha": "c218825454c4ccc77d7f462d579b042d599cabed", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 196, "deletions": 241, "changes": 437, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34019e282b8c0d82660f64fc69726098178d4ea2/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34019e282b8c0d82660f64fc69726098178d4ea2/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=34019e282b8c0d82660f64fc69726098178d4ea2", "patch": "@@ -3043,11 +3043,10 @@ static bool\n verify_gimple_call (gimple stmt)\n {\n   tree fn = gimple_call_fn (stmt);\n-  tree fntype;\n+  tree fntype, fndecl;\n   unsigned i;\n \n-  if (TREE_CODE (fn) != OBJ_TYPE_REF\n-      && !is_gimple_val (fn))\n+  if (!is_gimple_call_addr (fn))\n     {\n       error (\"invalid function in gimple call\");\n       debug_generic_stmt (fn);\n@@ -3062,6 +3061,17 @@ verify_gimple_call (gimple stmt)\n       return true;\n     }\n \n+   fndecl = gimple_call_fndecl (stmt);\n+   if (fndecl\n+       && TREE_CODE (fndecl) == FUNCTION_DECL\n+       && DECL_LOOPING_CONST_OR_PURE_P (fndecl)\n+       && !DECL_PURE_P (fndecl)\n+       && !TREE_READONLY (fndecl))\n+     {\n+       error (\"invalid pure const state for function\");\n+       return true;\n+     }\n+\n   if (gimple_call_lhs (stmt)\n       && (!is_gimple_lvalue (gimple_call_lhs (stmt))\n \t  || verify_types_in_gimple_reference (gimple_call_lhs (stmt), true)))\n@@ -3912,46 +3922,6 @@ verify_gimple_switch (gimple stmt)\n }\n \n \n-/* Verify the contents of a GIMPLE_PHI.  Returns true if there is a problem,\n-   and false otherwise.  */\n-\n-static bool\n-verify_gimple_phi (gimple stmt)\n-{\n-  tree type = TREE_TYPE (gimple_phi_result (stmt));\n-  unsigned i;\n-\n-  if (TREE_CODE (gimple_phi_result (stmt)) != SSA_NAME)\n-    {\n-      error (\"invalid PHI result\");\n-      return true;\n-    }\n-\n-  for (i = 0; i < gimple_phi_num_args (stmt); i++)\n-    {\n-      tree arg = gimple_phi_arg_def (stmt, i);\n-      if ((is_gimple_reg (gimple_phi_result (stmt))\n-\t   && !is_gimple_val (arg))\n-\t  || (!is_gimple_reg (gimple_phi_result (stmt))\n-\t      && !is_gimple_addressable (arg)))\n-\t{\n-\t  error (\"invalid PHI argument\");\n-\t  debug_generic_stmt (arg);\n-\t  return true;\n-\t}\n-      if (!useless_type_conversion_p (type, TREE_TYPE (arg)))\n-\t{\n-\t  error (\"incompatible types in PHI argument %u\", i);\n-\t  debug_generic_stmt (type);\n-\t  debug_generic_stmt (TREE_TYPE (arg));\n-\t  return true;\n-\t}\n-    }\n-\n-  return false;\n-}\n-\n-\n /* Verify a gimple debug statement STMT.\n    Returns true if anything is wrong.  */\n \n@@ -3967,20 +3937,56 @@ verify_gimple_debug (gimple stmt ATTRIBUTE_UNUSED)\n   return false;\n }\n \n+/* Verify a gimple label statement STMT.\n+   Returns true if anything is wrong.  */\n+\n+static bool\n+verify_gimple_label (gimple stmt)\n+{\n+  tree decl = gimple_label_label (stmt);\n+  int uid;\n+  bool err = false;\n+\n+  if (TREE_CODE (decl) != LABEL_DECL)\n+    return true;\n+\n+  uid = LABEL_DECL_UID (decl);\n+  if (cfun->cfg\n+      && (uid == -1\n+\t  || VEC_index (basic_block,\n+\t\t\tlabel_to_block_map, uid) != gimple_bb (stmt)))\n+    {\n+      error (\"incorrect entry in label_to_block_map\");\n+      err |= true;\n+    }\n+\n+  uid = EH_LANDING_PAD_NR (decl);\n+  if (uid)\n+    {\n+      eh_landing_pad lp = get_eh_landing_pad_from_number (uid);\n+      if (decl != lp->post_landing_pad)\n+\t{\n+\t  error (\"incorrect setting of landing pad number\");\n+\t  err |= true;\n+\t}\n+    }\n+\n+  return err;\n+}\n \n /* Verify the GIMPLE statement STMT.  Returns true if there is an\n    error, otherwise false.  */\n \n static bool\n-verify_types_in_gimple_stmt (gimple stmt)\n+verify_gimple_stmt (gimple stmt)\n {\n   switch (gimple_code (stmt))\n     {\n     case GIMPLE_ASSIGN:\n       return verify_gimple_assign (stmt);\n \n     case GIMPLE_LABEL:\n-      return TREE_CODE (gimple_label_label (stmt)) != LABEL_DECL;\n+      return verify_gimple_label (stmt);\n \n     case GIMPLE_CALL:\n       return verify_gimple_call (stmt);\n@@ -4016,9 +4022,6 @@ verify_types_in_gimple_stmt (gimple stmt)\n     case GIMPLE_ASM:\n       return false;\n \n-    case GIMPLE_PHI:\n-      return verify_gimple_phi (stmt);\n-\n     /* Tuples that do not have tree operands.  */\n     case GIMPLE_NOP:\n     case GIMPLE_PREDICT:\n@@ -4044,10 +4047,74 @@ verify_types_in_gimple_stmt (gimple stmt)\n     }\n }\n \n+/* Verify the contents of a GIMPLE_PHI.  Returns true if there is a problem,\n+   and false otherwise.  */\n+\n+static bool\n+verify_gimple_phi (gimple phi)\n+{\n+  bool err = false;\n+  unsigned i;\n+  tree phi_result = gimple_phi_result (phi);\n+  bool virtual_p;\n+\n+  if (!phi_result)\n+    {\n+      error (\"invalid PHI result\");\n+      return true;\n+    }\n+\n+  virtual_p = !is_gimple_reg (phi_result);\n+  if (TREE_CODE (phi_result) != SSA_NAME\n+      || (virtual_p\n+\t  && SSA_NAME_VAR (phi_result) != gimple_vop (cfun)))\n+    {\n+      error (\"invalid PHI result\");\n+      err = true;\n+    }\n+\n+  for (i = 0; i < gimple_phi_num_args (phi); i++)\n+    {\n+      tree t = gimple_phi_arg_def (phi, i);\n+\n+      if (!t)\n+\t{\n+\t  error (\"missing PHI def\");\n+\t  err |= true;\n+\t  continue;\n+\t}\n+      /* Addressable variables do have SSA_NAMEs but they\n+\t are not considered gimple values.  */\n+      else if ((TREE_CODE (t) == SSA_NAME\n+\t\t&& virtual_p != !is_gimple_reg (t))\n+\t       || (virtual_p\n+\t\t   && (TREE_CODE (t) != SSA_NAME\n+\t\t       || SSA_NAME_VAR (t) != gimple_vop (cfun)))\n+\t       || (!virtual_p\n+\t\t   && !is_gimple_val (t)))\n+\t{\n+\t  error (\"invalid PHI argument\");\n+\t  debug_generic_expr (t);\n+\t  err |= true;\n+\t}\n+#ifdef ENABLE_TYPES_CHECKING\n+      if (!useless_type_conversion_p (TREE_TYPE (phi_result), TREE_TYPE (t)))\n+\t{\n+\t  error (\"incompatible types in PHI argument %u\", i);\n+\t  debug_generic_stmt (TREE_TYPE (phi_result));\n+\t  debug_generic_stmt (TREE_TYPE (t));\n+\t  err |= true;\n+\t}\n+#endif\n+    }\n+\n+  return err;\n+}\n+\n /* Verify the GIMPLE statements inside the sequence STMTS.  */\n \n static bool\n-verify_types_in_gimple_seq_2 (gimple_seq stmts)\n+verify_gimple_in_seq_2 (gimple_seq stmts)\n {\n   gimple_stmt_iterator ittr;\n   bool err = false;\n@@ -4059,25 +4126,25 @@ verify_types_in_gimple_seq_2 (gimple_seq stmts)\n       switch (gimple_code (stmt))\n         {\n \tcase GIMPLE_BIND:\n-\t  err |= verify_types_in_gimple_seq_2 (gimple_bind_body (stmt));\n+\t  err |= verify_gimple_in_seq_2 (gimple_bind_body (stmt));\n \t  break;\n \n \tcase GIMPLE_TRY:\n-\t  err |= verify_types_in_gimple_seq_2 (gimple_try_eval (stmt));\n-\t  err |= verify_types_in_gimple_seq_2 (gimple_try_cleanup (stmt));\n+\t  err |= verify_gimple_in_seq_2 (gimple_try_eval (stmt));\n+\t  err |= verify_gimple_in_seq_2 (gimple_try_cleanup (stmt));\n \t  break;\n \n \tcase GIMPLE_EH_FILTER:\n-\t  err |= verify_types_in_gimple_seq_2 (gimple_eh_filter_failure (stmt));\n+\t  err |= verify_gimple_in_seq_2 (gimple_eh_filter_failure (stmt));\n \t  break;\n \n \tcase GIMPLE_CATCH:\n-\t  err |= verify_types_in_gimple_seq_2 (gimple_catch_handler (stmt));\n+\t  err |= verify_gimple_in_seq_2 (gimple_catch_handler (stmt));\n \t  break;\n \n \tdefault:\n \t  {\n-\t    bool err2 = verify_types_in_gimple_stmt (stmt);\n+\t    bool err2 = verify_gimple_stmt (stmt);\n \t    if (err2)\n \t      debug_gimple_stmt (stmt);\n \t    err |= err2;\n@@ -4091,102 +4158,15 @@ verify_types_in_gimple_seq_2 (gimple_seq stmts)\n \n /* Verify the GIMPLE statements inside the statement list STMTS.  */\n \n-void\n-verify_types_in_gimple_seq (gimple_seq stmts)\n+DEBUG_FUNCTION void\n+verify_gimple_in_seq (gimple_seq stmts)\n {\n-  if (verify_types_in_gimple_seq_2 (stmts))\n+  timevar_push (TV_TREE_STMT_VERIFY);\n+  if (verify_gimple_in_seq_2 (stmts))\n     internal_error (\"verify_gimple failed\");\n+  timevar_pop (TV_TREE_STMT_VERIFY);\n }\n \n-\n-/* Verify STMT, return true if STMT is not in GIMPLE form.\n-   TODO: Implement type checking.  */\n-\n-static bool\n-verify_stmt (gimple_stmt_iterator *gsi)\n-{\n-  tree addr;\n-  struct walk_stmt_info wi;\n-  bool last_in_block = gsi_one_before_end_p (*gsi);\n-  gimple stmt = gsi_stmt (*gsi);\n-  int lp_nr;\n-\n-  if (is_gimple_omp (stmt))\n-    {\n-      /* OpenMP directives are validated by the FE and never operated\n-\t on by the optimizers.  Furthermore, GIMPLE_OMP_FOR may contain\n-\t non-gimple expressions when the main index variable has had\n-\t its address taken.  This does not affect the loop itself\n-\t because the header of an GIMPLE_OMP_FOR is merely used to determine\n-\t how to setup the parallel iteration.  */\n-      return false;\n-    }\n-\n-  /* FIXME.  The C frontend passes unpromoted arguments in case it\n-     didn't see a function declaration before the call.  */\n-  if (is_gimple_call (stmt))\n-    {\n-      tree decl;\n-\n-      if (!is_gimple_call_addr (gimple_call_fn (stmt)))\n-\t{\n-\t  error (\"invalid function in call statement\");\n-\t  return true;\n-\t}\n-\n-      decl = gimple_call_fndecl (stmt);\n-      if (decl\n-\t  && TREE_CODE (decl) == FUNCTION_DECL\n-\t  && DECL_LOOPING_CONST_OR_PURE_P (decl)\n-\t  && (!DECL_PURE_P (decl))\n-\t  && (!TREE_READONLY (decl)))\n-\t{\n-\t  error (\"invalid pure const state for function\");\n-\t  return true;\n-\t}\n-    }\n-\n-  if (is_gimple_debug (stmt))\n-    return false;\n-\n-  memset (&wi, 0, sizeof (wi));\n-  addr = walk_gimple_op (gsi_stmt (*gsi), verify_expr, &wi);\n-  if (addr)\n-    {\n-      debug_generic_expr (addr);\n-      inform (gimple_location (gsi_stmt (*gsi)), \"in statement\");\n-      debug_gimple_stmt (stmt);\n-      return true;\n-    }\n-\n-  /* If the statement is marked as part of an EH region, then it is\n-     expected that the statement could throw.  Verify that when we\n-     have optimizations that simplify statements such that we prove\n-     that they cannot throw, that we update other data structures\n-     to match.  */\n-  lp_nr = lookup_stmt_eh_lp (stmt);\n-  if (lp_nr != 0)\n-    {\n-      if (!stmt_could_throw_p (stmt))\n-\t{\n-\t  error (\"statement marked for throw, but doesn%'t\");\n-\t  goto fail;\n-\t}\n-      else if (lp_nr > 0 && !last_in_block && stmt_can_throw_internal (stmt))\n-\t{\n-\t  error (\"statement marked for throw in middle of block\");\n-\t  goto fail;\n-\t}\n-    }\n-\n-  return false;\n-\n- fail:\n-  debug_gimple_stmt (stmt);\n-  return true;\n-}\n-\n-\n /* Return true when the T can be shared.  */\n \n bool\n@@ -4215,7 +4195,6 @@ tree_node_can_be_shared (tree t)\n   return false;\n }\n \n-\n /* Called via walk_gimple_stmt.  Verify tree sharing.  */\n \n static tree\n@@ -4236,7 +4215,6 @@ verify_node_sharing (tree *tp, int *walk_subtrees, void *data)\n   return NULL;\n }\n \n-\n static bool eh_error_found;\n static int\n verify_eh_throw_stmt_node (void **slot, void *data)\n@@ -4253,147 +4231,124 @@ verify_eh_throw_stmt_node (void **slot, void *data)\n   return 1;\n }\n \n-\n-/* Verify the GIMPLE statements in every basic block.  */\n+/* Verify the GIMPLE statements in the CFG of FN.  */\n \n DEBUG_FUNCTION void\n-verify_stmts (void)\n+verify_gimple_in_cfg (struct function *fn)\n {\n   basic_block bb;\n-  gimple_stmt_iterator gsi;\n   bool err = false;\n   struct pointer_set_t *visited, *visited_stmts;\n-  tree addr;\n-  struct walk_stmt_info wi;\n \n   timevar_push (TV_TREE_STMT_VERIFY);\n   visited = pointer_set_create ();\n   visited_stmts = pointer_set_create ();\n \n-  memset (&wi, 0, sizeof (wi));\n-  wi.info = (void *) visited;\n-\n-  FOR_EACH_BB (bb)\n+  FOR_EACH_BB_FN (bb, fn)\n     {\n-      gimple phi;\n-      size_t i;\n+      gimple_stmt_iterator gsi;\n \n       for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n-\t  phi = gsi_stmt (gsi);\n+\t  gimple phi = gsi_stmt (gsi);\n+\t  bool err2 = false;\n+\t  unsigned i;\n+\n \t  pointer_set_insert (visited_stmts, phi);\n+\n \t  if (gimple_bb (phi) != bb)\n \t    {\n \t      error (\"gimple_bb (phi) is set to a wrong basic block\");\n-\t      err |= true;\n+\t      err2 = true;\n \t    }\n \n+\t  err2 |= verify_gimple_phi (phi);\n+\n \t  for (i = 0; i < gimple_phi_num_args (phi); i++)\n \t    {\n-\t      tree t = gimple_phi_arg_def (phi, i);\n-\t      tree addr;\n-\n-\t      if (!t)\n-\t\t{\n-\t\t  error (\"missing PHI def\");\n-\t\t  debug_gimple_stmt (phi);\n-\t\t  err |= true;\n-\t\t  continue;\n-\t\t}\n-\t      /* Addressable variables do have SSA_NAMEs but they\n-\t\t are not considered gimple values.  */\n-\t      else if (TREE_CODE (t) != SSA_NAME\n-\t\t       && TREE_CODE (t) != FUNCTION_DECL\n-\t\t       && !is_gimple_min_invariant (t))\n-\t\t{\n-\t\t  error (\"PHI argument is not a GIMPLE value\");\n-\t\t  debug_gimple_stmt (phi);\n-\t\t  debug_generic_expr (t);\n-\t\t  err |= true;\n-\t\t}\n-\n-\t      addr = walk_tree (&t, verify_node_sharing, visited, NULL);\n+\t      tree arg = gimple_phi_arg_def (phi, i);\n+\t      tree addr = walk_tree (&arg, verify_node_sharing, visited, NULL);\n \t      if (addr)\n \t\t{\n \t\t  error (\"incorrect sharing of tree nodes\");\n-\t\t  debug_gimple_stmt (phi);\n \t\t  debug_generic_expr (addr);\n-\t\t  err |= true;\n+\t\t  err2 |= true;\n \t\t}\n \t    }\n \n-#ifdef ENABLE_TYPES_CHECKING\n-\t  if (verify_gimple_phi (phi))\n-\t    {\n-\t      debug_gimple_stmt (phi);\n-\t      err |= true;\n-\t    }\n-#endif\n+\t  if (err2)\n+\t    debug_gimple_stmt (phi);\n+\t  err |= err2;\n \t}\n \n-      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); )\n+      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n \t  gimple stmt = gsi_stmt (gsi);\n-\n-\t  if (gimple_code (stmt) == GIMPLE_WITH_CLEANUP_EXPR\n-\t      || gimple_code (stmt) == GIMPLE_BIND)\n-\t    {\n-\t      error (\"invalid GIMPLE statement\");\n-\t      debug_gimple_stmt (stmt);\n-\t      err |= true;\n-\t    }\n+\t  bool err2 = false;\n+\t  struct walk_stmt_info wi;\n+\t  tree addr;\n+\t  int lp_nr;\n \n \t  pointer_set_insert (visited_stmts, stmt);\n \n \t  if (gimple_bb (stmt) != bb)\n \t    {\n \t      error (\"gimple_bb (stmt) is set to a wrong basic block\");\n-\t      debug_gimple_stmt (stmt);\n-\t      err |= true;\n+\t      err2 = true;\n \t    }\n \n-\t  if (gimple_code (stmt) == GIMPLE_LABEL)\n+\t  err2 |= verify_gimple_stmt (stmt);\n+\n+\t  memset (&wi, 0, sizeof (wi));\n+\t  wi.info = (void *) visited;\n+\t  addr = walk_gimple_op (stmt, verify_node_sharing, &wi);\n+\t  if (addr)\n \t    {\n-\t      tree decl = gimple_label_label (stmt);\n-\t      int uid = LABEL_DECL_UID (decl);\n+\t      error (\"incorrect sharing of tree nodes\");\n+\t      debug_generic_expr (addr);\n+\t      err2 |= true;\n+\t    }\n \n-\t      if (uid == -1\n-\t\t  || VEC_index (basic_block, label_to_block_map, uid) != bb)\n+\t  /* ???  Instead of not checking these stmts at all the walker\n+\t     should know its context via wi.  */\n+\t  if (!is_gimple_debug (stmt)\n+\t      && !is_gimple_omp (stmt))\n+\t    {\n+\t      memset (&wi, 0, sizeof (wi));\n+\t      addr = walk_gimple_op (stmt, verify_expr, &wi);\n+\t      if (addr)\n \t\t{\n-\t\t  error (\"incorrect entry in label_to_block_map\");\n-\t\t  err |= true;\n+\t\t  debug_generic_expr (addr);\n+\t\t  inform (gimple_location (stmt), \"in statement\");\n+\t\t  err2 |= true;\n \t\t}\n+\t    }\n \n-\t      uid = EH_LANDING_PAD_NR (decl);\n-\t      if (uid)\n+\t  /* If the statement is marked as part of an EH region, then it is\n+\t     expected that the statement could throw.  Verify that when we\n+\t     have optimizations that simplify statements such that we prove\n+\t     that they cannot throw, that we update other data structures\n+\t     to match.  */\n+\t  lp_nr = lookup_stmt_eh_lp (stmt);\n+\t  if (lp_nr != 0)\n+\t    {\n+\t      if (!stmt_could_throw_p (stmt))\n \t\t{\n-\t\t  eh_landing_pad lp = get_eh_landing_pad_from_number (uid);\n-\t\t  if (decl != lp->post_landing_pad)\n-\t\t    {\n-\t\t      error (\"incorrect setting of landing pad number\");\n-\t\t      err |= true;\n-\t\t    }\n+\t\t  error (\"statement marked for throw, but doesn%'t\");\n+\t\t  err2 |= true;\n+\t\t}\n+\t      else if (lp_nr > 0\n+\t\t       && !gsi_one_before_end_p (gsi)\n+\t\t       && stmt_can_throw_internal (stmt))\n+\t\t{\n+\t\t  error (\"statement marked for throw in middle of block\");\n+\t\t  err2 |= true;\n \t\t}\n \t    }\n \n-\t  err |= verify_stmt (&gsi);\n-\n-#ifdef ENABLE_TYPES_CHECKING\n-\t  if (verify_types_in_gimple_stmt (gsi_stmt (gsi)))\n-\t    {\n-\t      debug_gimple_stmt (stmt);\n-\t      err |= true;\n-\t    }\n-#endif\n-\t  addr = walk_gimple_op (gsi_stmt (gsi), verify_node_sharing, &wi);\n-\t  if (addr)\n-\t    {\n-\t      error (\"incorrect sharing of tree nodes\");\n-\t      debug_gimple_stmt (stmt);\n-\t      debug_generic_expr (addr);\n-\t      err |= true;\n-\t    }\n-\t  gsi_next (&gsi);\n+\t  if (err2)\n+\t    debug_gimple_stmt (stmt);\n+\t  err |= err2;\n \t}\n     }\n \n@@ -4403,8 +4358,8 @@ verify_stmts (void)\n \t\t   verify_eh_throw_stmt_node,\n \t\t   visited_stmts);\n \n-  if (err | eh_error_found)\n-    internal_error (\"verify_stmts failed\");\n+  if (err || eh_error_found)\n+    internal_error (\"verify_gimple failed\");\n \n   pointer_set_destroy (visited);\n   pointer_set_destroy (visited_stmts);"}, {"sha": "3c887e2ee1083b5769244f285a8a9da57a2211e1", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34019e282b8c0d82660f64fc69726098178d4ea2/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34019e282b8c0d82660f64fc69726098178d4ea2/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=34019e282b8c0d82660f64fc69726098178d4ea2", "patch": "@@ -426,9 +426,8 @@ extern basic_block label_to_block_fn (struct function *, tree);\n #define label_to_block(t) (label_to_block_fn (cfun, t))\n extern void notice_special_calls (gimple);\n extern void clear_special_calls (void);\n-extern void verify_stmts (void);\n-extern void verify_gimple (void);\n-extern void verify_types_in_gimple_seq (gimple_seq);\n+extern void verify_gimple_in_seq (gimple_seq);\n+extern void verify_gimple_in_cfg (struct function *);\n extern tree gimple_block_label (basic_block);\n extern void extract_true_false_edges_from_block (basic_block, edge *, edge *);\n extern bool gimple_duplicate_sese_region (edge, edge, basic_block *, unsigned,"}, {"sha": "5a41818c575cfee8b4d8f762571348bdaacefa9c", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34019e282b8c0d82660f64fc69726098178d4ea2/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34019e282b8c0d82660f64fc69726098178d4ea2/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=34019e282b8c0d82660f64fc69726098178d4ea2", "patch": "@@ -881,7 +881,7 @@ verify_ssa (bool check_modified_stmt)\n \n   gcc_assert (!need_ssa_update_p (cfun));\n \n-  verify_stmts ();\n+  verify_gimple_in_cfg (cfun);\n \n   timevar_push (TV_TREE_SSA_VERIFY);\n "}]}