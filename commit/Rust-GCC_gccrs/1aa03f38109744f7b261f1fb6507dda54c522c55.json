{"sha": "1aa03f38109744f7b261f1fb6507dda54c522c55", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWFhMDNmMzgxMDk3NDRmN2IyNjFmMWZiNjUwN2RkYTU0YzUyMmM1NQ==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "joern.rennecke@superh.com", "date": "2003-03-12T16:33:20Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2003-03-12T16:33:20Z"}, "message": "sh.c: Include basic-block.h.\n\n\t* sh.c: Include basic-block.h.\n\t(sh_output_mi_thunk, emit_load_ptr): New functions.\n\t(TARGET_ASM_OUTPUT_MI_THUNK, TARGET_ASM_CAN_OUTPUT_MI_THUNK): Redefine.\n\nFrom-SVN: r64248", "tree": {"sha": "10cc627a45028fca2af7620ff20100e092ff82f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/10cc627a45028fca2af7620ff20100e092ff82f0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1aa03f38109744f7b261f1fb6507dda54c522c55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1aa03f38109744f7b261f1fb6507dda54c522c55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1aa03f38109744f7b261f1fb6507dda54c522c55", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1aa03f38109744f7b261f1fb6507dda54c522c55/comments", "author": null, "committer": null, "parents": [{"sha": "68566610afdbfd7f946eea2c4a262586160d9282", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68566610afdbfd7f946eea2c4a262586160d9282", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68566610afdbfd7f946eea2c4a262586160d9282"}], "stats": {"total": 198, "additions": 198, "deletions": 0}, "files": [{"sha": "0e3c4a74b9886b6078e24dd0f9f2444b6c5f5e7d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1aa03f38109744f7b261f1fb6507dda54c522c55/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1aa03f38109744f7b261f1fb6507dda54c522c55/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1aa03f38109744f7b261f1fb6507dda54c522c55", "patch": "@@ -1,3 +1,9 @@\n+Wed Mar 12 16:30:25 2003  J\"orn Rennecke <joern.rennecke@superh.com>\n+\n+\t* sh.c: Include basic-block.h.\n+\t(sh_output_mi_thunk, emit_load_ptr): New functions.\n+\t(TARGET_ASM_OUTPUT_MI_THUNK, TARGET_ASM_CAN_OUTPUT_MI_THUNK): Redefine.\n+\n 2003-03-12  Nick Clifton  <nickc@redhat.com>\n \n \t* config/arm/pe.h (FIXED_REGISTERS): Add Maverick registers."}, {"sha": "501e1daeb898bd1f0d354738caabcb7a48406216", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1aa03f38109744f7b261f1fb6507dda54c522c55/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1aa03f38109744f7b261f1fb6507dda54c522c55/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=1aa03f38109744f7b261f1fb6507dda54c522c55", "patch": "@@ -45,6 +45,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"target-def.h\"\n #include \"real.h\"\n #include \"langhooks.h\"\n+#include \"basic-block.h\"\n \n int code_for_indirect_jump_scratch = CODE_FOR_indirect_jump_scratch;\n \n@@ -212,6 +213,8 @@ static const char *sh_strip_name_encoding PARAMS ((const char *));\n static void sh_init_builtins PARAMS ((void));\n static void sh_media_init_builtins PARAMS ((void));\n static rtx sh_expand_builtin PARAMS ((tree, rtx, rtx, enum machine_mode, int));\n+static void sh_output_mi_thunk PARAMS ((FILE *, tree, HOST_WIDE_INT,\n+\t\t\t\t\tHOST_WIDE_INT, tree));\n static int flow_dependent_p PARAMS ((rtx, rtx));\n static void flow_dependent_p_1 PARAMS ((rtx, rtx, void *));\n static int shiftcosts PARAMS ((rtx));\n@@ -242,6 +245,12 @@ static int sh_address_cost PARAMS ((rtx));\n #undef TARGET_ASM_FUNCTION_EPILOGUE\n #define TARGET_ASM_FUNCTION_EPILOGUE sh_output_function_epilogue\n \n+#undef TARGET_ASM_OUTPUT_MI_THUNK\n+#define TARGET_ASM_OUTPUT_MI_THUNK sh_output_mi_thunk\n+\n+#undef TARGET_ASM_CAN_OUTPUT_MI_THUNK\n+#define TARGET_ASM_CAN_OUTPUT_MI_THUNK hook_bool_tree_hwi_hwi_tree_true\n+\n #undef TARGET_INSERT_ATTRIBUTES\n #define TARGET_INSERT_ATTRIBUTES sh_insert_attributes\n \n@@ -8368,4 +8377,187 @@ sh_register_operand (op, mode)\n   return register_operand (op, mode);\n }\n \n+static rtx emit_load_ptr PARAMS ((rtx, rtx));\n+\n+static rtx\n+emit_load_ptr (reg, addr)\n+     rtx reg, addr;\n+{\n+  rtx mem = gen_rtx_MEM (ptr_mode, addr);\n+\n+  if (Pmode != ptr_mode)\n+    mem = gen_rtx_SIGN_EXTEND (Pmode, mem);\n+  return emit_move_insn (reg, mem);\n+}\n+\n+void\n+sh_output_mi_thunk (file, thunk_fndecl, delta, vcall_offset, function)\n+     FILE *file;\n+     tree thunk_fndecl ATTRIBUTE_UNUSED;\n+     HOST_WIDE_INT delta;\n+     HOST_WIDE_INT vcall_offset;\n+     tree function;\n+{\n+  CUMULATIVE_ARGS cum;\n+  int structure_value_byref = 0;\n+  rtx this, this_value, sibcall, insns, funexp;\n+  tree funtype = TREE_TYPE (function);\n+  int simple_add\n+    = (TARGET_SHMEDIA ? CONST_OK_FOR_J (delta) : CONST_OK_FOR_I (delta));\n+  int did_load = 0;\n+  rtx scratch0, scratch1, scratch2;\n+\n+  reload_completed = 1;\n+  no_new_pseudos = 1;\n+  current_function_uses_only_leaf_regs = 1;\n+\n+  emit_note (NULL, NOTE_INSN_PROLOGUE_END);\n+\n+  /* Find the \"this\" pointer.  We have such a wide range of ABIs for the\n+     SH that it's best to do this completely machine independently.\n+     \"this\" is passed as first argument, unless a structure return pointer \n+     comes first, in which case \"this\" comes second.  */\n+  INIT_CUMULATIVE_ARGS (cum, funtype, NULL_RTX, 0);\n+#ifndef PCC_STATIC_STRUCT_RETURN\n+  if (aggregate_value_p (TREE_TYPE (TREE_TYPE (function))))\n+    structure_value_byref = 1;\n+#endif /* not PCC_STATIC_STRUCT_RETURN */\n+  if (structure_value_byref && struct_value_rtx == 0)\n+    { \n+      tree ptype = build_pointer_type (TREE_TYPE (funtype));\n+\n+      FUNCTION_ARG_ADVANCE (cum, Pmode, ptype, 1);\n+    }\n+  this = FUNCTION_ARG (cum, Pmode, ptr_type_node, 1);\n+\n+  /* For SHcompact, we only have r0 for a scratch register: r1 is the\n+     static chain pointer (even if you can't have nested virtual functions\n+     right now, someone might implement them sometime), and the rest of the\n+     registers are used for argument passing, are callee-saved, or reserved.  */\n+  scratch0 = scratch1 = scratch2 = gen_rtx_REG (Pmode, 0);\n+  if (! TARGET_SH5)\n+    {\n+      scratch1 = gen_rtx_REG (ptr_mode, 1);\n+      /* N.B., if not TARGET_HITACHI, register 2 is used to pass the pointer\n+\t pointing where to return struct values.  */\n+      scratch2 = gen_rtx_REG (Pmode, 3);\n+    }\n+  else if (TARGET_SHMEDIA)\n+    {\n+      scratch1 = gen_rtx_REG (ptr_mode, 21);\n+      scratch2 = gen_rtx_REG (Pmode, TR0_REG);\n+    }\n+\n+  this_value = plus_constant (this, delta);\n+  if (vcall_offset\n+      && (simple_add || scratch0 != scratch1)\n+      && strict_memory_address_p (ptr_mode, this_value))\n+    {\n+      emit_load_ptr (scratch0, this_value);\n+      did_load = 1;\n+    }\n+\n+  if (!delta)\n+    ; /* Do nothing.  */\n+  else if (simple_add)\n+    emit_move_insn (this, this_value);\n+  else\n+    {\n+      emit_move_insn (scratch1, GEN_INT (delta));\n+      emit_insn (gen_add2_insn (this, scratch1));\n+    }\n+\n+  if (vcall_offset)\n+    {\n+      rtx offset_addr;\n+\n+      if (!did_load)\n+\temit_load_ptr (scratch0, this);\n+\n+      offset_addr = plus_constant (scratch0, vcall_offset);\n+      if (strict_memory_address_p (ptr_mode, offset_addr))\n+\t; /* Do nothing.  */\n+      else if (! TARGET_SH5)\n+\t{\n+\t  /* scratch0 != scratch1, and we have indexed loads.  Get better\n+\t     schedule by loading the offset into r1 and using an indexed\n+\t     load - then the load of r1 can issue before the load from\n+             (this + delta) finishes.  */\n+\t  emit_move_insn (scratch1, GEN_INT (vcall_offset));\n+\t  offset_addr = gen_rtx_PLUS (Pmode, scratch0, scratch1);\n+\t}\n+      else if (TARGET_SHMEDIA\n+\t       ? CONST_OK_FOR_J (vcall_offset)\n+\t       : CONST_OK_FOR_I (vcall_offset))\n+\t{\n+\t  emit_insn (gen_add2_insn (scratch0, GEN_INT (vcall_offset)));\n+\t  offset_addr = scratch0;\n+\t}\n+      else if (scratch0 != scratch1)\n+\t{\n+\t  emit_move_insn (scratch1, GEN_INT (vcall_offset));\n+\t  emit_insn (gen_add2_insn (scratch0, scratch1));\n+\t  offset_addr = scratch0;\n+\t}\n+      else\n+\tabort (); /* FIXME */\n+      emit_load_ptr (scratch0, offset_addr);\n+\n+     if (Pmode != ptr_mode)\n+\tscratch0 = gen_rtx_TRUNCATE (ptr_mode, scratch0);\n+      emit_insn (gen_add2_insn (this, scratch0));\n+    }\n+\n+  /* Generate a tail call to the target function.  */\n+  if (! TREE_USED (function))\n+    {\n+      assemble_external (function);\n+      TREE_USED (function) = 1;\n+    }\n+  funexp = XEXP (DECL_RTL (function), 0);\n+  emit_move_insn (scratch2, funexp);\n+  funexp = gen_rtx_MEM (FUNCTION_MODE, scratch2);\n+  sibcall = emit_call_insn (gen_sibcall (funexp, const0_rtx, NULL_RTX));\n+  SIBLING_CALL_P (sibcall) = 1;\n+  use_reg (&CALL_INSN_FUNCTION_USAGE (sibcall), this);\n+  emit_barrier ();\n+\n+    /* Run just enough of rest_of_compilation to do scheduling and get\n+     the insns emitted.  Note that use_thunk calls\n+     assemble_start_function and assemble_end_function.  */\n+  insns = get_insns ();\n+\n+  if (optimize > 0 && flag_schedule_insns_after_reload)\n+    {\n+\n+      find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n+      life_analysis (insns, rtl_dump_file, PROP_FINAL);\n+\n+      split_all_insns (1);\n+\n+      schedule_insns (rtl_dump_file);\n+    }\n+\n+  MACHINE_DEPENDENT_REORG (insns);\n+\n+  if (optimize > 0 && flag_delayed_branch)\n+      dbr_schedule (insns, rtl_dump_file);\n+  shorten_branches (insns);\n+  final_start_function (insns, file, 1);\n+  final (insns, file, 1, 0);\n+  final_end_function ();\n+\n+  if (optimize > 0 && flag_schedule_insns_after_reload)\n+    {\n+      /* Release all memory allocated by flow.  */\n+      free_basic_block_vars (0);\n+\n+      /* Release all memory held by regsets now.  */\n+      regset_release_memory ();\n+    }\n+\n+  reload_completed = 0;\n+  no_new_pseudos = 0;\n+}\n+\n #include \"gt-sh.h\""}]}