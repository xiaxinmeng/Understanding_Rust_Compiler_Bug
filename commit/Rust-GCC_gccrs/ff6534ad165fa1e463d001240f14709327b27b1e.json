{"sha": "ff6534ad165fa1e463d001240f14709327b27b1e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmY2NTM0YWQxNjVmYTFlNDYzZDAwMTI0MGYxNDcwOTMyN2IyN2IxZQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.co.uk", "date": "2000-11-24T17:40:09Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2000-11-24T17:40:09Z"}, "message": "Fix code that substitutes reloadreg into SET_DEST of previous insn.\n\nFrom-SVN: r37711", "tree": {"sha": "0b623f3cbe02997e8644f25b4cc6df8c34e3987b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b623f3cbe02997e8644f25b4cc6df8c34e3987b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff6534ad165fa1e463d001240f14709327b27b1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff6534ad165fa1e463d001240f14709327b27b1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff6534ad165fa1e463d001240f14709327b27b1e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff6534ad165fa1e463d001240f14709327b27b1e/comments", "author": null, "committer": null, "parents": [{"sha": "176f9a7b1c1a668cde299dc350b949c88658b84c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/176f9a7b1c1a668cde299dc350b949c88658b84c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/176f9a7b1c1a668cde299dc350b949c88658b84c"}], "stats": {"total": 21, "additions": 21, "deletions": 0}, "files": [{"sha": "2c12a963f0d2d48d179e3efd4941c2a139d8909b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6534ad165fa1e463d001240f14709327b27b1e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6534ad165fa1e463d001240f14709327b27b1e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ff6534ad165fa1e463d001240f14709327b27b1e", "patch": "@@ -1,5 +1,9 @@\n 2000-11-24  Bernd Schmidt  <bernds@redhat.co.uk>\n \n+\t* reload1.c (conflicts_with_override): New function.\n+\t(emit_input_reload_insns): Use it to tighten test for validity\n+\tof substituting into output of previous insn.\n+\n \t* haifa-sched.c (struct ready_list): New.\n \t(ready_lastpos, ready_add, ready_remove_first, ready_sort): New static\n \tfunctions."}, {"sha": "60eac681ddf4f072e3bd96c04e5b150eeedf2756", "filename": "gcc/reload1.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6534ad165fa1e463d001240f14709327b27b1e/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6534ad165fa1e463d001240f14709327b27b1e/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=ff6534ad165fa1e463d001240f14709327b27b1e", "patch": "@@ -417,6 +417,7 @@ static int reload_reg_reaches_end_p\tPARAMS ((unsigned int, int,\n \t\t\t\t\t\t enum reload_type));\n static int allocate_reload_reg\t\tPARAMS ((struct insn_chain *, int,\n \t\t\t\t\t\t int));\n+static int conflicts_with_override\tPARAMS ((rtx));\n static void failed_reload\t\tPARAMS ((rtx, int));\n static int set_reload_reg\t\tPARAMS ((int, int));\n static void choose_reload_regs_init\tPARAMS ((struct insn_chain *, rtx *));\n@@ -4882,6 +4883,21 @@ reload_reg_free_for_value_p (regno, opnum, type, value, out, reloadnum,\n   return 1;\n }\n \n+/* Determine whether the reload reg X overlaps any rtx'es used for\n+   overriding inheritance.  Return nonzero if so.  */\n+\n+static int\n+conflicts_with_override (x)\n+     rtx x;\n+{\n+  int i;\n+  for (i = 0; i < n_reloads; i++)\n+    if (reload_override_in[i]\n+\t&& reg_overlap_mentioned_p (x, reload_override_in[i]))\n+      return 1;\n+  return 0;\n+}\n+\f\n /* Give an error message saying we failed to find a reload for INSN,\n    and clear out reload R.  */\n static void\n@@ -6215,6 +6231,7 @@ emit_input_reload_insns (chain, rl, old, j)\n \t   && dead_or_set_p (insn, old)\n \t   /* This is unsafe if some other reload\n \t      uses the same reg first.  */\n+\t   && ! conflicts_with_override (reloadreg)\n \t   && reload_reg_free_for_value_p (REGNO (reloadreg),\n \t\t\t\t\t   rl->opnum,\n \t\t\t\t\t   rl->when_needed,"}]}