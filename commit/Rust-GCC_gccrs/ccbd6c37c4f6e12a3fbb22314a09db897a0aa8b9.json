{"sha": "ccbd6c37c4f6e12a3fbb22314a09db897a0aa8b9", "node_id": "C_kwDOANBUbNoAKGNjYmQ2YzM3YzRmNmUxMmEzZmJiMjIzMTRhMDlkYjg5N2EwYWE4Yjk", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-10-26T08:52:44Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-10-26T08:59:08Z"}, "message": "Turn vect_create_addr_base_for_vector_ref offset into a byte offset\n\nThis changes the offset in elements for vect_create_addr_base_for_vector_ref\nand vect_create_data_ref_ptr to an offset in bytes, easing a following\nrefactoring.\n\n2021-10-26  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vect-data-refs.c (vect_create_addr_base_for_vector_ref):\n\tTake offset in bytes.\n\t(vect_create_data_ref_ptr): Likewise.\n\t* tree-vect-loop-manip.c (get_misalign_in_elems): Multiply\n\toffset by element size.\n\t(vect_create_cond_for_align_checks): Likewise.\n\t* tree-vect-stmts.c (get_negative_load_store_type): Likewise.\n\t(vectorizable_load): Remove duplicate leftover from merge\n\tconflict.", "tree": {"sha": "a9987059f424dda9a1c3031d373e75c0f8163417", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a9987059f424dda9a1c3031d373e75c0f8163417"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ccbd6c37c4f6e12a3fbb22314a09db897a0aa8b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccbd6c37c4f6e12a3fbb22314a09db897a0aa8b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ccbd6c37c4f6e12a3fbb22314a09db897a0aa8b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccbd6c37c4f6e12a3fbb22314a09db897a0aa8b9/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a31a3d0421f0cf1f7eefacfec8cbf37e7f91600d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a31a3d0421f0cf1f7eefacfec8cbf37e7f91600d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a31a3d0421f0cf1f7eefacfec8cbf37e7f91600d"}], "stats": {"total": 34, "additions": 19, "deletions": 15}, "files": [{"sha": "46360c50bd4b8639d8b4486ff309250ee9d68312", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccbd6c37c4f6e12a3fbb22314a09db897a0aa8b9/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccbd6c37c4f6e12a3fbb22314a09db897a0aa8b9/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=ccbd6c37c4f6e12a3fbb22314a09db897a0aa8b9", "patch": "@@ -4753,8 +4753,7 @@ vect_duplicate_ssa_name_ptr_info (tree name, dr_vec_info *dr_info)\n \t    if LOOP=i_loop:\t&in\t\t(relative to i_loop)\n \t    if LOOP=j_loop: \t&in+i*2B\t(relative to j_loop)\n    BYTE_OFFSET: Optional, defaulted to NULL.  If supplied, it is added to the\n-\t    initial address.  Unlike OFFSET, which is number of elements to\n-\t    be added, BYTE_OFFSET is measured in bytes.\n+\t    initial address.  Both OFFSET and BYTE_OFFSET are measured in bytes.\n \n    Output:\n    1. Return an SSA_NAME whose value is the address of the memory location of\n@@ -4777,7 +4776,6 @@ vect_create_addr_base_for_vector_ref (vec_info *vinfo, stmt_vec_info stmt_info,\n   tree dest;\n   gimple_seq seq = NULL;\n   tree vect_ptr_type;\n-  tree step = TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dr)));\n   loop_vec_info loop_vinfo = dyn_cast <loop_vec_info> (vinfo);\n   innermost_loop_behavior *drb = vect_dr_behavior (vinfo, dr_info);\n \n@@ -4801,8 +4799,7 @@ vect_create_addr_base_for_vector_ref (vec_info *vinfo, stmt_vec_info stmt_info,\n \n   if (offset)\n     {\n-      offset = fold_build2 (MULT_EXPR, sizetype,\n-\t\t\t    fold_convert (sizetype, offset), step);\n+      offset = fold_convert (sizetype, offset);\n       base_offset = fold_build2 (PLUS_EXPR, sizetype,\n \t\t\t\t base_offset, offset);\n     }\n@@ -4860,8 +4857,8 @@ vect_create_addr_base_for_vector_ref (vec_info *vinfo, stmt_vec_info stmt_info,\n    2. AGGR_TYPE: the type of the reference, which should be either a vector\n         or an array.\n    3. AT_LOOP: the loop where the vector memref is to be created.\n-   4. OFFSET (optional): an offset to be added to the initial address accessed\n-\tby the data-ref in STMT_INFO.\n+   4. OFFSET (optional): a byte offset to be added to the initial address\n+\taccessed by the data-ref in STMT_INFO.\n    5. BSI: location where the new stmts are to be placed if there is no loop\n    6. ONLY_INIT: indicate if ap is to be updated in the loop, or remain\n         pointing to the initial address.\n@@ -4885,7 +4882,7 @@ vect_create_addr_base_for_vector_ref (vec_info *vinfo, stmt_vec_info stmt_info,\n       if OFFSET is not supplied:\n          initial_address = &a[init];\n       if OFFSET is supplied:\n-         initial_address = &a[init + OFFSET];\n+\t initial_address = &a[init] + OFFSET;\n       if BYTE_OFFSET is supplied:\n \t initial_address = &a[init] + BYTE_OFFSET;\n \n@@ -5031,7 +5028,7 @@ vect_create_data_ref_ptr (vec_info *vinfo, stmt_vec_info stmt_info,\n   /* (2) Calculate the initial address of the aggregate-pointer, and set\n      the aggregate-pointer to point to it before the loop.  */\n \n-  /* Create: (&(base[init_val+offset]+byte_offset) in the loop preheader.  */\n+  /* Create: (&(base[init_val]+offset+byte_offset) in the loop preheader.  */\n \n   new_temp = vect_create_addr_base_for_vector_ref (vinfo,\n \t\t\t\t\t\t   stmt_info, &new_stmt_list,"}, {"sha": "72d583189c47639fa6965be68e2a3ea0c126fd38", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccbd6c37c4f6e12a3fbb22314a09db897a0aa8b9/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccbd6c37c4f6e12a3fbb22314a09db897a0aa8b9/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=ccbd6c37c4f6e12a3fbb22314a09db897a0aa8b9", "patch": "@@ -1625,7 +1625,9 @@ get_misalign_in_elems (gimple **seq, loop_vec_info loop_vinfo)\n   bool negative = tree_int_cst_compare (DR_STEP (dr_info->dr),\n \t\t\t\t\tsize_zero_node) < 0;\n   tree offset = (negative\n-\t\t ? size_int (-TYPE_VECTOR_SUBPARTS (vectype) + 1)\n+\t\t ? size_int ((-TYPE_VECTOR_SUBPARTS (vectype) + 1)\n+\t\t\t     * TREE_INT_CST_LOW\n+\t\t\t\t (TYPE_SIZE_UNIT (TREE_TYPE (vectype))))\n \t\t : size_zero_node);\n   tree start_addr = vect_create_addr_base_for_vector_ref (loop_vinfo,\n \t\t\t\t\t\t\t  stmt_info, seq,\n@@ -3227,7 +3229,9 @@ vect_create_cond_for_align_checks (loop_vec_info loop_vinfo,\n       bool negative = tree_int_cst_compare\n \t(DR_STEP (STMT_VINFO_DATA_REF (stmt_info)), size_zero_node) < 0;\n       tree offset = negative\n-\t? size_int (-TYPE_VECTOR_SUBPARTS (vectype) + 1) : size_zero_node;\n+\t? size_int ((-TYPE_VECTOR_SUBPARTS (vectype) + 1)\n+\t\t    * TREE_INT_CST_LOW (TYPE_SIZE_UNIT (TREE_TYPE (vectype))))\n+\t: size_zero_node;\n \n       /* create: addr_tmp = (int)(address_of_first_vector) */\n       addr_base ="}, {"sha": "1f56e10709e8f27d768c04f7ef914e2cd9347c36", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccbd6c37c4f6e12a3fbb22314a09db897a0aa8b9/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccbd6c37c4f6e12a3fbb22314a09db897a0aa8b9/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=ccbd6c37c4f6e12a3fbb22314a09db897a0aa8b9", "patch": "@@ -1996,6 +1996,11 @@ get_negative_load_store_type (vec_info *vinfo,\n       return VMAT_ELEMENTWISE;\n     }\n \n+  /* For backward running DRs the first access in vectype actually is\n+     N-1 elements before the address of the DR.  */\n+  *poffset = ((-TYPE_VECTOR_SUBPARTS (vectype) + 1)\n+\t      * TREE_INT_CST_LOW (TYPE_SIZE_UNIT (TREE_TYPE (vectype))));\n+\n   int misalignment = dr_misalignment (dr_info, vectype);\n   alignment_support_scheme\n     = vect_supportable_dr_alignment (vinfo, dr_info, vectype, misalignment);\n@@ -2006,6 +2011,7 @@ get_negative_load_store_type (vec_info *vinfo,\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"negative step but alignment required.\\n\");\n       return VMAT_ELEMENTWISE;\n+      *poffset = 0;\n     }\n \n   if (vls_type == VLS_STORE_INVARIANT)\n@@ -2014,7 +2020,6 @@ get_negative_load_store_type (vec_info *vinfo,\n \tdump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t \"negative step with invariant source;\"\n \t\t\t \" no permute needed.\\n\");\n-      *poffset = -TYPE_VECTOR_SUBPARTS (vectype) + 1;\n       return VMAT_CONTIGUOUS_DOWN;\n     }\n \n@@ -2023,10 +2028,10 @@ get_negative_load_store_type (vec_info *vinfo,\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"negative step and reversing not supported.\\n\");\n+      *poffset = 0;\n       return VMAT_ELEMENTWISE;\n     }\n \n-  *poffset = -TYPE_VECTOR_SUBPARTS (vectype) + 1;\n   return VMAT_CONTIGUOUS_REVERSE;\n }\n \n@@ -9315,8 +9320,6 @@ vectorizable_load (vec_info *vinfo,\n   tree offset = NULL_TREE;\n   if (!known_eq (poffset, 0))\n     offset = size_int (poffset);\n-  if (memory_access_type == VMAT_CONTIGUOUS_REVERSE)\n-    offset = size_int (-TYPE_VECTOR_SUBPARTS (vectype) + 1);\n \n   tree bump;\n   tree vec_offset = NULL_TREE;"}]}