{"sha": "8cd2462c1b395eb8c82a66bbb26ec01474b4c263", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGNkMjQ2MmMxYjM5NWViOGM4MmE2NmJiYjI2ZWMwMTQ3NGI0YzI2Mw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2003-07-02T00:12:10Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2003-07-02T00:12:10Z"}, "message": "decl2.c (defer_fn): Set DECL_DEFER_OUTPUT.\n\n\t* decl2.c (defer_fn): Set DECL_DEFER_OUTPUT.\n\t(finish-file): Do not process function with DECL_DEFER_OUTPUT clear;\n\tclear DECL_DEFER_OUTPUT once function is processed; avoid flags\n\tmassaging.\n\n\t* cp-tree.h (DECL_NEEDED_P): Support unit-at-a-time\n\t(expand_or_defer_fn): Declare.\n\t(lower_function): Declare.\n\t* decl.c (start_cleanup_fn): Use expand_or_defer_fn.\n\t* decl2.c: Include cgraph.h and varpool.h\n\t(maybe_emit_vtables):  Make explicit instantations as needed.\n\t(mark_member_pointers, lower_function): New functions.\n\t(finish_file): Do unit-at-a-time.\n\t* method.c (synthesize_method): Use expand_or_defer_fn.\n\t* optimize.c (maybe_clone_body): Use expand_or_defer_fn.\n\t* parser.c (cp_parser_function_definition_after_decl): Use\n\texpand_or_defer_fn.\n\t* pt.c (instantiate_decl): Likewise.\n\t* semantics.c: Include cgraph.h\n\t(expand_or_defer_fn): Break out from ...\n\t(expand_body): ... here; deal with unit-at-a-time.\n\t* cp-lang.c (LANG_HOOKS_CALLGRAPH_EXPAND_FUNCTION,\n\tLANG_HOOKS_CALLGRAPH_LOWER_FUNCTION): Define.\n\nFrom-SVN: r68801", "tree": {"sha": "d82da478d6e68af51bc19afef90a24c9d944ca98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d82da478d6e68af51bc19afef90a24c9d944ca98"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8cd2462c1b395eb8c82a66bbb26ec01474b4c263", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cd2462c1b395eb8c82a66bbb26ec01474b4c263", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8cd2462c1b395eb8c82a66bbb26ec01474b4c263", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cd2462c1b395eb8c82a66bbb26ec01474b4c263/comments", "author": null, "committer": null, "parents": [{"sha": "093354e08f1df0a1023dbde82f6c67cd30d85aa3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/093354e08f1df0a1023dbde82f6c67cd30d85aa3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/093354e08f1df0a1023dbde82f6c67cd30d85aa3"}], "stats": {"total": 282, "additions": 192, "deletions": 90}, "files": [{"sha": "1c0585073d6ee1301c364e6599e4e0c42c7be8ea", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd2462c1b395eb8c82a66bbb26ec01474b4c263/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd2462c1b395eb8c82a66bbb26ec01474b4c263/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8cd2462c1b395eb8c82a66bbb26ec01474b4c263", "patch": "@@ -1,3 +1,29 @@\n+Wed Jul  2 00:36:48 CEST 2003  Jan Hubicka  <jh@suse.cz>\n+\n+\t* decl2.c (defer_fn): Set DECL_DEFER_OUTPUT.\n+\t(finish-file): Do not process function with DECL_DEFER_OUTPUT clear;\n+\tclear DECL_DEFER_OUTPUT once function is processed; avoid flags\n+\tmassaging.\n+\n+\t* cp-tree.h (DECL_NEEDED_P): Support unit-at-a-time\n+\t(expand_or_defer_fn): Declare.\n+\t(lower_function): Declare.\n+\t* decl.c (start_cleanup_fn): Use expand_or_defer_fn.\n+\t* decl2.c: Include cgraph.h and varpool.h\n+\t(maybe_emit_vtables):  Make explicit instantations as needed.\n+\t(mark_member_pointers, lower_function): New functions.\n+\t(finish_file): Do unit-at-a-time.\n+\t* method.c (synthesize_method): Use expand_or_defer_fn.\n+\t* optimize.c (maybe_clone_body): Use expand_or_defer_fn.\n+\t* parser.c (cp_parser_function_definition_after_decl): Use\n+\texpand_or_defer_fn.\n+\t* pt.c (instantiate_decl): Likewise.\n+\t* semantics.c: Include cgraph.h\n+\t(expand_or_defer_fn): Break out from ...\n+\t(expand_body): ... here; deal with unit-at-a-time.\n+\t* cp-lang.c (LANG_HOOKS_CALLGRAPH_EXPAND_FUNCTION,\n+\tLANG_HOOKS_CALLGRAPH_LOWER_FUNCTION): Define.\n+\n 2003-07-01  Mark Mitchell  <mark@codesourcery.com>\n \n \t* call.c (resolve_scoped_fn_name): Return error_mark_node for"}, {"sha": "d6b871a981d07d1ba7cbd46374cf6ad554c5fb65", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd2462c1b395eb8c82a66bbb26ec01474b4c263/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd2462c1b395eb8c82a66bbb26ec01474b4c263/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=8cd2462c1b395eb8c82a66bbb26ec01474b4c263", "patch": "@@ -240,7 +240,7 @@ cp/decl.o: cp/decl.c $(CXX_TREE_H) $(TM_H) flags.h cp/lex.h cp/decl.h stack.h \\\n   cp/operators.def $(TM_P_H) tree-inline.h diagnostic.h c-pragma.h \\\n   debug.h gt-cp-decl.h gtype-cp.h timevar.h\n cp/decl2.o: cp/decl2.c $(CXX_TREE_H) $(TM_H) flags.h cp/lex.h cp/decl.h $(EXPR_H) \\\n-  output.h except.h toplev.h $(RTL_H) c-common.h gt-cp-decl2.h\n+  output.h except.h toplev.h $(RTL_H) c-common.h gt-cp-decl2.h cgraph.h\n cp/typeck2.o: cp/typeck2.c $(CXX_TREE_H) $(TM_H) flags.h toplev.h output.h $(TM_P_H) \\\n    diagnostic.h\n cp/typeck.o: cp/typeck.c $(CXX_TREE_H) $(TM_H) flags.h $(RTL_H) $(EXPR_H) toplev.h \\\n@@ -271,7 +271,7 @@ cp/repo.o: cp/repo.c $(CXX_TREE_H) $(TM_H) toplev.h diagnostic.h \\\n   gt-cp-repo.h\n cp/semantics.o: cp/semantics.c $(CXX_TREE_H) $(TM_H) cp/lex.h except.h toplev.h \\\n   flags.h debug.h output.h $(RTL_H) $(TIMEVAR_H) $(EXPR_H) \\\n-  tree-inline.h\n+  tree-inline.h cgraph.h\n cp/dump.o: cp/dump.c $(CXX_TREE_H) $(TM_H) tree-dump.h\n cp/optimize.o: cp/optimize.c $(CXX_TREE_H) $(TM_H) rtl.h integrate.h insn-config.h \\\n   input.h $(PARAMS_H) debug.h tree-inline.h"}, {"sha": "6e5bc8f5d4943c654d0457af6464d3af229b26d9", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd2462c1b395eb8c82a66bbb26ec01474b4c263/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd2462c1b395eb8c82a66bbb26ec01474b4c263/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=8cd2462c1b395eb8c82a66bbb26ec01474b4c263", "patch": "@@ -2749,7 +2749,7 @@ build_user_type_conversion (tree totype, tree expr, int flags)\n tree\n resolve_scoped_fn_name (tree scope, tree name)\n {\n-  tree fn;\n+  tree fn = NULL_TREE;\n   tree template_args = NULL_TREE;\n   bool is_template_id = TREE_CODE (name) == TEMPLATE_ID_EXPR;\n   "}, {"sha": "78a4e6ba3e38602eace9c690f01313619aeb26b5", "filename": "gcc/cp/cp-lang.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd2462c1b395eb8c82a66bbb26ec01474b4c263/gcc%2Fcp%2Fcp-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd2462c1b395eb8c82a66bbb26ec01474b4c263/gcc%2Fcp%2Fcp-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-lang.c?ref=8cd2462c1b395eb8c82a66bbb26ec01474b4c263", "patch": "@@ -150,6 +150,11 @@ static bool cp_var_mod_type_p (tree);\n #undef LANG_HOOKS_PREPARE_ASSEMBLE_VARIABLE \n #define LANG_HOOKS_PREPARE_ASSEMBLE_VARIABLE prepare_assemble_variable\n \n+#undef LANG_HOOKS_CALLGRAPH_EXPAND_FUNCTION\n+#define LANG_HOOKS_CALLGRAPH_EXPAND_FUNCTION expand_body\n+#undef LANG_HOOKS_CALLGRAPH_LOWER_FUNCTION\n+#define LANG_HOOKS_CALLGRAPH_LOWER_FUNCTION lower_function\n+\n #undef LANG_HOOKS_MAKE_TYPE\n #define LANG_HOOKS_MAKE_TYPE cxx_make_type\n #undef LANG_HOOKS_TYPE_FOR_MODE"}, {"sha": "8612b8cee20a22ca305262466d2dc7400533864f", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd2462c1b395eb8c82a66bbb26ec01474b4c263/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd2462c1b395eb8c82a66bbb26ec01474b4c263/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=8cd2462c1b395eb8c82a66bbb26ec01474b4c263", "patch": "@@ -1746,7 +1746,7 @@ struct lang_decl GTY(())\n   ((at_eof && TREE_PUBLIC (DECL) && !DECL_COMDAT (DECL))\t\\\n    || (DECL_ASSEMBLER_NAME_SET_P (DECL)\t\t\t\t\\\n        && TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (DECL)))\t\\\n-   || (flag_syntax_only && TREE_USED (DECL)))\n+   || (((flag_syntax_only || flag_unit_at_a_time) && TREE_USED (DECL))))\n \n /* For a FUNCTION_DECL or a VAR_DECL, the language linkage for the\n    declaration.  Some entities (like a member function in a local\n@@ -3800,6 +3800,7 @@ extern tree get_guard (tree);\n extern tree get_guard_cond (tree);\n extern tree set_guard (tree);\n extern void prepare_assemble_variable (tree);\n+extern void lower_function (tree);\n \n extern void cp_error_at\t\t(const char *msgid, ...);\n extern void cp_warning_at\t(const char *msgid, ...);\n@@ -4151,6 +4152,7 @@ extern void clear_out_block                     (void);\n extern tree begin_global_stmt_expr              (void);\n extern tree finish_global_stmt_expr             (tree);\n extern tree check_template_template_default_arg (tree);\n+extern void expand_or_defer_fn\t\t\t(tree);\n \n /* in tree.c */\n extern void lang_check_failed\t\t\t(const char *, int,"}, {"sha": "863a21dced1bac484aea84e2f7c920dac29a7354", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd2462c1b395eb8c82a66bbb26ec01474b4c263/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd2462c1b395eb8c82a66bbb26ec01474b4c263/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=8cd2462c1b395eb8c82a66bbb26ec01474b4c263", "patch": "@@ -8446,7 +8446,7 @@ start_cleanup_fn (void)\n static void\n end_cleanup_fn (void)\n {\n-  expand_body (finish_function (0));\n+  expand_or_defer_fn (finish_function (0));\n \n   pop_from_top_level ();\n }"}, {"sha": "a440c064478ebfc9ebe28dd59c5d5762daae0692", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 43, "deletions": 17, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd2462c1b395eb8c82a66bbb26ec01474b4c263/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd2462c1b395eb8c82a66bbb26ec01474b4c263/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=8cd2462c1b395eb8c82a66bbb26ec01474b4c263", "patch": "@@ -46,6 +46,8 @@ Boston, MA 02111-1307, USA.  */\n #include \"cpplib.h\"\n #include \"target.h\"\n #include \"c-common.h\"\n+#include \"cgraph.h\"\n+#include \"tree-inline.h\"\n extern cpp_reader *parse_in;\n \n /* This structure contains information about the initializations\n@@ -1187,6 +1189,7 @@ defer_fn (tree fn)\n   if (DECL_DEFERRED_FN (fn))\n     return;\n   DECL_DEFERRED_FN (fn) = 1;\n+  DECL_DEFER_OUTPUT (fn) = 1;\n   if (!deferred_fns)\n     VARRAY_TREE_INIT (deferred_fns, 32, \"deferred_fns\");\n \n@@ -1671,6 +1674,11 @@ maybe_emit_vtables (tree ctype)\n       /* Write it out.  */\n       import_export_vtable (vtbl, ctype, 1);\n       mark_vtable_entries (vtbl);\n+\n+      /* If we know that DECL is needed, mark it as such for the varpool.  */\n+      if (CLASSTYPE_EXPLICIT_INSTANTIATION (ctype))\n+\tcgraph_varpool_mark_needed_node (cgraph_varpool_node (vtbl));\n+\n       if (TREE_TYPE (DECL_INITIAL (vtbl)) == 0)\n \tstore_init_value (vtbl, DECL_INITIAL (vtbl));\n \n@@ -2010,7 +2018,7 @@ finish_objects (int method_type, int initp, tree body)\n   /* Finish up.  */\n   finish_compound_stmt (/*has_no_scope=*/0, body);\n   fn = finish_function (0);\n-  expand_body (fn);\n+  expand_or_defer_fn (fn);\n \n   /* When only doing semantic analysis, and no RTL generation, we\n      can't call functions that directly emit assembly code; there is\n@@ -2163,7 +2171,7 @@ finish_static_storage_duration_function (tree body)\n {\n   /* Close out the function.  */\n   finish_compound_stmt (/*has_no_scope=*/0, body);\n-  expand_body (finish_function (0));\n+  expand_or_defer_fn (finish_function (0));\n }\n \n /* Return the information about the indicated PRIORITY level.  If no\n@@ -2550,6 +2558,26 @@ generate_ctor_and_dtor_functions_for_priority (splay_tree_node n, void * data)\n   return 0;\n }\n \n+/* Callgraph code does not understand the member pointers.  Mark the methods\n+   referenced as used.  */\n+static tree\n+mark_member_pointers (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n+\t\t      void *data ATTRIBUTE_UNUSED)\n+{\n+  if (TREE_CODE (*tp) == PTRMEM_CST)\n+    cgraph_mark_needed_node (cgraph_node (PTRMEM_CST_MEMBER (*tp)), 1);\n+  return 0;\n+}\n+\n+/* Called via LANGHOOK_CALLGRAPH_LOWER_FUNCTION.  It is supposed to lower\n+   frontend specific constructs that would otherwise confuse the middle end.  */\n+void\n+lower_function (tree fn)\n+{\n+  walk_tree_without_duplicates (&DECL_SAVED_TREE (fn), mark_member_pointers,\n+\t\t\t\tNULL);\n+}\n+\n /* This routine is called from the last rule in yyparse ().\n    Its job is to create all the code needed to initialize and\n    destroy the global aggregates.  We do the destruction\n@@ -2787,20 +2815,16 @@ finish_file ()\n \t  if (!DECL_EXTERNAL (decl)\n \t      && DECL_NEEDED_P (decl)\n \t      && DECL_SAVED_TREE (decl)\n-\t      && !TREE_ASM_WRITTEN (decl))\n+\t      && !TREE_ASM_WRITTEN (decl)\n+\t      && (!flag_unit_at_a_time \n+\t\t  || !cgraph_node (decl)->local.finalized))\n \t    {\n-\t      int saved_not_really_extern;\n-\n-\t      /* When we call finish_function in expand_body, it will\n-\t\t try to reset DECL_NOT_REALLY_EXTERN so we save and\n-\t\t restore it here.  */\n-\t      saved_not_really_extern = DECL_NOT_REALLY_EXTERN (decl);\n+\t      /* We will output the function; no longer consider it in this\n+\t\t loop.  */\n+\t      DECL_DEFER_OUTPUT (decl) = 0;\n \t      /* Generate RTL for this function now that we know we\n \t\t need it.  */\n-\t      expand_body (decl);\n-\t      /* Undo the damage done by finish_function.  */\n-\t      DECL_EXTERNAL (decl) = 0;\n-\t      DECL_NOT_REALLY_EXTERN (decl) = saved_not_really_extern;\n+\t      expand_or_defer_fn (decl);\n \t      /* If we're compiling -fsyntax-only pretend that this\n \t\t function has been written out so that we don't try to\n \t\t expand it again.  */\n@@ -2810,10 +2834,6 @@ finish_file ()\n \t    }\n \t}\n \n-      if (deferred_fns_used\n-\t  && wrapup_global_declarations (&VARRAY_TREE (deferred_fns, 0),\n-\t\t\t\t\t deferred_fns_used))\n-\treconsider = true;\n       if (walk_namespaces (wrapup_globals_for_namespace, /*data=*/0))\n \treconsider = true;\n \n@@ -2883,6 +2903,12 @@ finish_file ()\n      linkage now.  */\n   pop_lang_context ();\n \n+  if (flag_unit_at_a_time)\n+    {\n+      cgraph_finalize_compilation_unit ();\n+      cgraph_optimize ();\n+    }\n+\n   /* Now, issue warnings about static, but not defined, functions,\n      etc., and emit debugging information.  */\n   walk_namespaces (wrapup_globals_for_namespace, /*data=*/&reconsider);"}, {"sha": "e179d1532fe0783f9df9d7d8919c809be98ac37d", "filename": "gcc/cp/method.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd2462c1b395eb8c82a66bbb26ec01474b4c263/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd2462c1b395eb8c82a66bbb26ec01474b4c263/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=8cd2462c1b395eb8c82a66bbb26ec01474b4c263", "patch": "@@ -581,7 +581,7 @@ use_thunk (tree thunk_fndecl, bool emit_p)\n       /* Re-enable access control.  */\n       pop_deferring_access_checks ();\n \n-      expand_body (finish_function (0));\n+      expand_or_defer_fn (finish_function (0));\n     }\n \n   pop_from_top_level ();\n@@ -862,7 +862,7 @@ synthesize_method (tree fndecl)\n     }\n \n   finish_function_body (stmt);\n-  expand_body (finish_function (0));\n+  expand_or_defer_fn (finish_function (0));\n \n   extract_interface_info ();\n   if (! context)"}, {"sha": "4be829e818bdc52e4ea0e177d0e526182dcffdb1", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd2462c1b395eb8c82a66bbb26ec01474b4c263/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd2462c1b395eb8c82a66bbb26ec01474b4c263/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=8cd2462c1b395eb8c82a66bbb26ec01474b4c263", "patch": "@@ -265,7 +265,7 @@ maybe_clone_body (tree fn)\n       /* Now, expand this function into RTL, if appropriate.  */\n       finish_function (0);\n       BLOCK_ABSTRACT_ORIGIN (DECL_INITIAL (clone)) = DECL_INITIAL (fn);\n-      expand_body (clone);\n+      expand_or_defer_fn (clone);\n       pop_from_top_level ();\n     }\n "}, {"sha": "3654adbe0a84509d9a41eb4cd2e199a821e6a7a5", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd2462c1b395eb8c82a66bbb26ec01474b4c263/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd2462c1b395eb8c82a66bbb26ec01474b4c263/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=8cd2462c1b395eb8c82a66bbb26ec01474b4c263", "patch": "@@ -13855,7 +13855,7 @@ cp_parser_function_definition_after_declarator (cp_parser* parser,\n   fn = finish_function ((ctor_initializer_p ? 1 : 0) | \n \t\t\t(inline_p ? 2 : 0));\n   /* Generate code for it, if necessary.  */\n-  expand_body (fn);\n+  expand_or_defer_fn (fn);\n   /* Restore the saved values.  */\n   parser->in_unbraced_linkage_specification_p \n     = saved_in_unbraced_linkage_specification_p;"}, {"sha": "43fc5ab08609ba1f82acccf7ec88fedddc9e65e1", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd2462c1b395eb8c82a66bbb26ec01474b4c263/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd2462c1b395eb8c82a66bbb26ec01474b4c263/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=8cd2462c1b395eb8c82a66bbb26ec01474b4c263", "patch": "@@ -10942,7 +10942,7 @@ instantiate_decl (tree d, int defer_ok)\n \n       /* Finish the function.  */\n       d = finish_function (0);\n-      expand_body (d);\n+      expand_or_defer_fn (d);\n     }\n \n   /* We're not deferring instantiation any more.  */"}, {"sha": "382bee509b9c6cba9f56c107cdb0436bf9ca0517", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 106, "deletions": 63, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd2462c1b395eb8c82a66bbb26ec01474b4c263/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd2462c1b395eb8c82a66bbb26ec01474b4c263/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=8cd2462c1b395eb8c82a66bbb26ec01474b4c263", "patch": "@@ -41,6 +41,7 @@\n #include \"output.h\"\n #include \"timevar.h\"\n #include \"debug.h\"\n+#include \"cgraph.h\"\n \n /* There routines provide a modular interface to perform many parsing\n    operations.  They may therefore be used during actual parsing, or\n@@ -2279,69 +2280,9 @@ expand_body (tree fn)\n {\n   location_t saved_loc;\n   tree saved_function;\n-\n-  /* When the parser calls us after finishing the body of a template\n-     function, we don't really want to expand the body.  When we're\n-     processing an in-class definition of an inline function,\n-     PROCESSING_TEMPLATE_DECL will no longer be set here, so we have\n-     to look at the function itself.  */\n-  if (processing_template_decl\n-      || (DECL_LANG_SPECIFIC (fn) \n-\t  && DECL_TEMPLATE_INFO (fn)\n-\t  && uses_template_parms (DECL_TI_ARGS (fn))))\n-    {\n-      /* Normally, collection only occurs in rest_of_compilation.  So,\n-\t if we don't collect here, we never collect junk generated\n-\t during the processing of templates until we hit a\n-\t non-template function.  */\n-      ggc_collect ();\n-      return;\n-    }\n-\n-  /* Replace AGGR_INIT_EXPRs with appropriate CALL_EXPRs.  */\n-  walk_tree_without_duplicates (&DECL_SAVED_TREE (fn),\n-\t\t\t\tsimplify_aggr_init_exprs_r,\n-\t\t\t\tNULL);\n-\n-  /* If this is a constructor or destructor body, we have to clone\n-     it.  */\n-  if (maybe_clone_body (fn))\n-    {\n-      /* We don't want to process FN again, so pretend we've written\n-\t it out, even though we haven't.  */\n-      TREE_ASM_WRITTEN (fn) = 1;\n-      return;\n-    }\n-\n-  /* There's no reason to do any of the work here if we're only doing\n-     semantic analysis; this code just generates RTL.  */\n-  if (flag_syntax_only)\n-    return;\n-\n-  /* If possible, avoid generating RTL for this function.  Instead,\n-     just record it as an inline function, and wait until end-of-file\n-     to decide whether to write it out or not.  */\n-  if (/* We have to generate RTL if it's not an inline function.  */\n-      (DECL_INLINE (fn) || DECL_COMDAT (fn))\n-      /* Or if we have to emit code for inline functions anyhow.  */\n-      && !flag_keep_inline_functions\n-      /* Or if we actually have a reference to the function.  */\n-      && !DECL_NEEDED_P (fn))\n-    {\n-      /* Set DECL_EXTERNAL so that assemble_external will be called as\n-\t necessary.  We'll clear it again in finish_file.  */\n-      if (!DECL_EXTERNAL (fn))\n-\t{\n-\t  DECL_NOT_REALLY_EXTERN (fn) = 1;\n-\t  DECL_EXTERNAL (fn) = 1;\n-\t}\n-      /* Remember this function.  In finish_file we'll decide if\n-\t we actually need to write this function out.  */\n-      defer_fn (fn);\n-      /* Let the back-end know that this function exists.  */\n-      (*debug_hooks->deferred_inline_function) (fn);\n-      return;\n-    }\n+  \n+  if (flag_unit_at_a_time && !cgraph_global_info_ready)\n+    abort ();\n \n   /* Compute the appropriate object-file linkage for inline\n      functions.  */\n@@ -2413,6 +2354,108 @@ expand_body (tree fn)\n   emit_associated_thunks (fn);\n }\n \n+/* Generate RTL for FN.  */\n+\n+void\n+expand_or_defer_fn (fn)\n+     tree fn;\n+{\n+  /* When the parser calls us after finishing the body of a template\n+     function, we don't really want to expand the body.  When we're\n+     processing an in-class definition of an inline function,\n+     PROCESSING_TEMPLATE_DECL will no longer be set here, so we have\n+     to look at the function itself.  */\n+  if (processing_template_decl\n+      || (DECL_LANG_SPECIFIC (fn) \n+\t  && DECL_TEMPLATE_INFO (fn)\n+\t  && uses_template_parms (DECL_TI_ARGS (fn))))\n+    {\n+      /* Normally, collection only occurs in rest_of_compilation.  So,\n+\t if we don't collect here, we never collect junk generated\n+\t during the processing of templates until we hit a\n+\t non-template function.  */\n+      ggc_collect ();\n+      return;\n+    }\n+\n+  /* Replace AGGR_INIT_EXPRs with appropriate CALL_EXPRs.  */\n+  walk_tree_without_duplicates (&DECL_SAVED_TREE (fn),\n+\t\t\t\tsimplify_aggr_init_exprs_r,\n+\t\t\t\tNULL);\n+\n+  /* If this is a constructor or destructor body, we have to clone\n+     it.  */\n+  if (maybe_clone_body (fn))\n+    {\n+      /* We don't want to process FN again, so pretend we've written\n+\t it out, even though we haven't.  */\n+      TREE_ASM_WRITTEN (fn) = 1;\n+      return;\n+    }\n+\n+  /* There's no reason to do any of the work here if we're only doing\n+     semantic analysis; this code just generates RTL.  */\n+  if (flag_syntax_only)\n+    return;\n+\n+  if (flag_unit_at_a_time && cgraph_global_info_ready)\n+    abort ();\n+\n+  if (flag_unit_at_a_time && !cgraph_global_info_ready)\n+    {\n+      if (at_eof)\n+\t{\n+\t  /* Compute the appropriate object-file linkage for inline\n+\t     functions.  */\n+\t  if (DECL_DECLARED_INLINE_P (fn))\n+\t    import_export_decl (fn);\n+\t  cgraph_finalize_function (fn, DECL_SAVED_TREE (fn));\n+\t}\n+      else\n+\t{\n+\t  if (!DECL_EXTERNAL (fn))\n+\t    {\n+\t      DECL_NOT_REALLY_EXTERN (fn) = 1;\n+\t      DECL_EXTERNAL (fn) = 1;\n+\t    }\n+\t  /* Remember this function.  In finish_file we'll decide if\n+\t     we actually need to write this function out.  */\n+\t  defer_fn (fn);\n+\t  /* Let the back-end know that this function exists.  */\n+\t  (*debug_hooks->deferred_inline_function) (fn);\n+\t}\n+      return;\n+    }\n+\n+\n+  /* If possible, avoid generating RTL for this function.  Instead,\n+     just record it as an inline function, and wait until end-of-file\n+     to decide whether to write it out or not.  */\n+  if (/* We have to generate RTL if it's not an inline function.  */\n+      (DECL_INLINE (fn) || DECL_COMDAT (fn))\n+      /* Or if we have to emit code for inline functions anyhow.  */\n+      && !flag_keep_inline_functions\n+      /* Or if we actually have a reference to the function.  */\n+      && !DECL_NEEDED_P (fn))\n+    {\n+      /* Set DECL_EXTERNAL so that assemble_external will be called as\n+\t necessary.  We'll clear it again in finish_file.  */\n+      if (!DECL_EXTERNAL (fn))\n+\t{\n+\t  DECL_NOT_REALLY_EXTERN (fn) = 1;\n+\t  DECL_EXTERNAL (fn) = 1;\n+\t}\n+      /* Remember this function.  In finish_file we'll decide if\n+\t we actually need to write this function out.  */\n+      defer_fn (fn);\n+      /* Let the back-end know that this function exists.  */\n+      (*debug_hooks->deferred_inline_function) (fn);\n+      return;\n+    }\n+\n+  expand_body (fn);\n+}\n+\n /* Helper function for walk_tree, used by finish_function to override all\n    the RETURN_STMTs and pertinent CLEANUP_STMTs for the named return\n    value optimization.  */"}]}