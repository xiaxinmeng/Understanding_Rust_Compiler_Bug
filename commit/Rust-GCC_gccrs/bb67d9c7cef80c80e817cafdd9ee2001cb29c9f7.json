{"sha": "bb67d9c7cef80c80e817cafdd9ee2001cb29c9f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmI2N2Q5YzdjZWY4MGM4MGU4MTdjYWZkZDllZTIwMDFjYjI5YzlmNw==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-10-07T14:36:38Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-10-07T14:36:38Z"}, "message": "machmode.h (mode_for_vector): Declare.\n\n2010-10-07  Richard Guenther  <rguenther@suse.de>\n\n\t* machmode.h (mode_for_vector): Declare.\n\t* stor-layout.c (mode_for_vector): New function, split out from ...\n\t(layout_type): ... here.\n\t* tree-vectorizer.h (current_vector_size): Declare.\n\t* tree-vect-stmts.c (perm_mask_for_reverse): Check if the\n\tmask vector type is available.\n\t(get_vectype_for_scalar_type): Rename to ...\n\t(get_vectype_for_scalar_type_and_size): ... this.  Get a vector\n\tsize argument.\n\t(get_vectype_for_scalar_type): New wrapper around\n\tget_vectype_for_scalar_type_and_size using current_vector_size.\n\t(get_same_sized_vectype): Use get_vectype_for_scalar_type_and_size.\n\t* tree-vect-loop.c (vect_analyze_loop_2): Split out core part\n\tof vect_analyze_loop here.\n\t(vect_analyze_loop): Loop over vector sizes calling vect_analyze_loop_3.\n\t* tree-vect-slp.c (vect_slp_analyze_bb): Set current_vector_size\n\tto autodetect.\n\t* config/i386/i386.c (ix86_vectorize_builtin_conversion): Fix\n\tV8SF to V8SI conversion builtin.\n\nFrom-SVN: r165116", "tree": {"sha": "2b9ac40e2ddfd76e458ab91dc73fbb371682b0f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b9ac40e2ddfd76e458ab91dc73fbb371682b0f1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bb67d9c7cef80c80e817cafdd9ee2001cb29c9f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb67d9c7cef80c80e817cafdd9ee2001cb29c9f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb67d9c7cef80c80e817cafdd9ee2001cb29c9f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb67d9c7cef80c80e817cafdd9ee2001cb29c9f7/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "767f865fb828fba54459911661d15289e1a42930", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/767f865fb828fba54459911661d15289e1a42930", "html_url": "https://github.com/Rust-GCC/gccrs/commit/767f865fb828fba54459911661d15289e1a42930"}], "stats": {"total": 276, "additions": 182, "deletions": 94}, "files": [{"sha": "ffc280eff7d5c0c531ec2096b2a8ad9ef847730f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb67d9c7cef80c80e817cafdd9ee2001cb29c9f7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb67d9c7cef80c80e817cafdd9ee2001cb29c9f7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bb67d9c7cef80c80e817cafdd9ee2001cb29c9f7", "patch": "@@ -1,3 +1,25 @@\n+2010-10-07  Richard Guenther  <rguenther@suse.de>\n+\n+\t* machmode.h (mode_for_vector): Declare.\n+\t* stor-layout.c (mode_for_vector): New function, split out from ...\n+\t(layout_type): ... here.\n+\t* tree-vectorizer.h (current_vector_size): Declare.\n+\t* tree-vect-stmts.c (perm_mask_for_reverse): Check if the\n+\tmask vector type is available.\n+\t(get_vectype_for_scalar_type): Rename to ...\n+\t(get_vectype_for_scalar_type_and_size): ... this.  Get a vector\n+\tsize argument.\n+\t(get_vectype_for_scalar_type): New wrapper around\n+\tget_vectype_for_scalar_type_and_size using current_vector_size.\n+\t(get_same_sized_vectype): Use get_vectype_for_scalar_type_and_size.\n+\t* tree-vect-loop.c (vect_analyze_loop_2): Split out core part\n+\tof vect_analyze_loop here.\n+\t(vect_analyze_loop): Loop over vector sizes calling vect_analyze_loop_3.\n+\t* tree-vect-slp.c (vect_slp_analyze_bb): Set current_vector_size\n+\tto autodetect.\n+\t* config/i386/i386.c (ix86_vectorize_builtin_conversion): Fix\n+\tV8SF to V8SI conversion builtin.\n+\n 2010-10-07  Richard Guenther  <rguenther@suse.de>\n \n \t* target.def (autovectorize_vector_sizes): New target hook."}, {"sha": "33510a77c59f0106c043166203b2652c15c5379d", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb67d9c7cef80c80e817cafdd9ee2001cb29c9f7/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb67d9c7cef80c80e817cafdd9ee2001cb29c9f7/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=bb67d9c7cef80c80e817cafdd9ee2001cb29c9f7", "patch": "@@ -26272,7 +26272,7 @@ ix86_vectorize_builtin_conversion (unsigned int code,\n \t    case V8SFmode:\n \t      return (TYPE_UNSIGNED (src_type)\n \t\t      ? NULL_TREE\n-\t\t      : ix86_builtins[IX86_BUILTIN_CVTDQ2PS]);\n+\t\t      : ix86_builtins[IX86_BUILTIN_CVTDQ2PS256]);\n \t    default:\n \t      return NULL_TREE;\n \t    }"}, {"sha": "3ab7a8101ec4b46a17b73f3b8b54e056f305c17d", "filename": "gcc/machmode.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb67d9c7cef80c80e817cafdd9ee2001cb29c9f7/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb67d9c7cef80c80e817cafdd9ee2001cb29c9f7/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=bb67d9c7cef80c80e817cafdd9ee2001cb29c9f7", "patch": "@@ -241,6 +241,11 @@ extern enum machine_mode smallest_mode_for_size (unsigned int,\n \n extern enum machine_mode int_mode_for_mode (enum machine_mode);\n \n+/* Return a mode that is suitable for representing a vector,\n+   or BLKmode on failure.  */\n+\n+extern enum machine_mode mode_for_vector (enum machine_mode, unsigned);\n+\n /* Find the best mode to use to access a bit field.  */\n \n extern enum machine_mode get_best_mode (int, int, unsigned int,"}, {"sha": "5796ea1f09a1641185fa0baf3eed1fa598688b0b", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 46, "deletions": 38, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb67d9c7cef80c80e817cafdd9ee2001cb29c9f7/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb67d9c7cef80c80e817cafdd9ee2001cb29c9f7/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=bb67d9c7cef80c80e817cafdd9ee2001cb29c9f7", "patch": "@@ -470,6 +470,50 @@ int_mode_for_mode (enum machine_mode mode)\n   return mode;\n }\n \n+/* Find a mode that is suitable for representing a vector with\n+   NUNITS elements of mode INNERMODE.  Returns BLKmode if there\n+   is no suitable mode.  */\n+\n+enum machine_mode\n+mode_for_vector (enum machine_mode innermode, unsigned nunits)\n+{\n+  enum machine_mode mode;\n+\n+  /* First, look for a supported vector type.  */\n+  if (SCALAR_FLOAT_MODE_P (innermode))\n+    mode = MIN_MODE_VECTOR_FLOAT;\n+  else if (SCALAR_FRACT_MODE_P (innermode))\n+    mode = MIN_MODE_VECTOR_FRACT;\n+  else if (SCALAR_UFRACT_MODE_P (innermode))\n+    mode = MIN_MODE_VECTOR_UFRACT;\n+  else if (SCALAR_ACCUM_MODE_P (innermode))\n+    mode = MIN_MODE_VECTOR_ACCUM;\n+  else if (SCALAR_UACCUM_MODE_P (innermode))\n+    mode = MIN_MODE_VECTOR_UACCUM;\n+  else\n+    mode = MIN_MODE_VECTOR_INT;\n+\n+  /* Do not check vector_mode_supported_p here.  We'll do that\n+     later in vector_type_mode.  */\n+  for (; mode != VOIDmode ; mode = GET_MODE_WIDER_MODE (mode))\n+    if (GET_MODE_NUNITS (mode) == nunits\n+\t&& GET_MODE_INNER (mode) == innermode)\n+      break;\n+\n+  /* For integers, try mapping it to a same-sized scalar mode.  */\n+  if (mode == VOIDmode\n+      && GET_MODE_CLASS (innermode) == MODE_INT)\n+    mode = mode_for_size (nunits * GET_MODE_BITSIZE (innermode),\n+\t\t\t  MODE_INT, 0);\n+\n+  if (mode == VOIDmode\n+      || (GET_MODE_CLASS (mode) == MODE_INT\n+\t  && !have_regs_of_mode[mode]))\n+    return BLKmode;\n+\n+  return mode;\n+}\n+\n /* Return the alignment of MODE. This will be bounded by 1 and\n    BIGGEST_ALIGNMENT.  */\n \n@@ -1848,44 +1892,8 @@ layout_type (tree type)\n \n \t/* Find an appropriate mode for the vector type.  */\n \tif (TYPE_MODE (type) == VOIDmode)\n-\t  {\n-\t    enum machine_mode innermode = TYPE_MODE (innertype);\n-\t    enum machine_mode mode;\n-\n-\t    /* First, look for a supported vector type.  */\n-\t    if (SCALAR_FLOAT_MODE_P (innermode))\n-\t      mode = MIN_MODE_VECTOR_FLOAT;\n-\t    else if (SCALAR_FRACT_MODE_P (innermode))\n-\t      mode = MIN_MODE_VECTOR_FRACT;\n-\t    else if (SCALAR_UFRACT_MODE_P (innermode))\n-\t      mode = MIN_MODE_VECTOR_UFRACT;\n-\t    else if (SCALAR_ACCUM_MODE_P (innermode))\n-\t      mode = MIN_MODE_VECTOR_ACCUM;\n-\t    else if (SCALAR_UACCUM_MODE_P (innermode))\n-\t      mode = MIN_MODE_VECTOR_UACCUM;\n-\t    else\n-\t      mode = MIN_MODE_VECTOR_INT;\n-\n-\t    /* Do not check vector_mode_supported_p here.  We'll do that\n-\t       later in vector_type_mode.  */\n-\t    for (; mode != VOIDmode ; mode = GET_MODE_WIDER_MODE (mode))\n-\t      if (GET_MODE_NUNITS (mode) == nunits\n-\t  \t  && GET_MODE_INNER (mode) == innermode)\n-\t        break;\n-\n-\t    /* For integers, try mapping it to a same-sized scalar mode.  */\n-\t    if (mode == VOIDmode\n-\t        && GET_MODE_CLASS (innermode) == MODE_INT)\n-\t      mode = mode_for_size (nunits * GET_MODE_BITSIZE (innermode),\n-\t\t\t\t    MODE_INT, 0);\n-\n-\t    if (mode == VOIDmode ||\n-\t\t(GET_MODE_CLASS (mode) == MODE_INT\n-\t\t && !have_regs_of_mode[mode]))\n-\t      SET_TYPE_MODE (type, BLKmode);\n-\t    else\n-\t      SET_TYPE_MODE (type, mode);\n-\t  }\n+\t  SET_TYPE_MODE (type,\n+\t\t\t mode_for_vector (TYPE_MODE (innertype), nunits));\n \n \tTYPE_SATURATING (type) = TYPE_SATURATING (TREE_TYPE (type));\n         TYPE_UNSIGNED (type) = TYPE_UNSIGNED (TREE_TYPE (type));"}, {"sha": "d7a864a0196dfcb73ff67d166386aef9a69beace", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 72, "deletions": 47, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb67d9c7cef80c80e817cafdd9ee2001cb29c9f7/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb67d9c7cef80c80e817cafdd9ee2001cb29c9f7/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=bb67d9c7cef80c80e817cafdd9ee2001cb29c9f7", "patch": "@@ -1371,41 +1371,18 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo)\n }\n \n \n-/* Function vect_analyze_loop.\n+/* Function vect_analyze_loop_2.\n \n    Apply a set of analyses on LOOP, and create a loop_vec_info struct\n    for it.  The different analyses will record information in the\n    loop_vec_info struct.  */\n-loop_vec_info\n-vect_analyze_loop (struct loop *loop)\n+static bool\n+vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n {\n   bool ok, dummy;\n-  loop_vec_info loop_vinfo;\n   int max_vf = MAX_VECTORIZATION_FACTOR;\n   int min_vf = 2;\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"===== analyze_loop_nest =====\");\n-\n-  if (loop_outer (loop)\n-      && loop_vec_info_for_loop (loop_outer (loop))\n-      && LOOP_VINFO_VECTORIZABLE_P (loop_vec_info_for_loop (loop_outer (loop))))\n-    {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"outer-loop already vectorized.\");\n-      return NULL;\n-    }\n-\n-  /* Check the CFG characteristics of the loop (nesting, entry/exit, etc.  */\n-\n-  loop_vinfo = vect_analyze_loop_form (loop);\n-  if (!loop_vinfo)\n-    {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"bad loop form.\");\n-      return NULL;\n-    }\n-\n   /* Find all data references in the loop (which correspond to vdefs/vuses)\n      and analyze their evolution in the loop.  Also adjust the minimal\n      vectorization factor according to the loads and stores.\n@@ -1418,8 +1395,7 @@ vect_analyze_loop (struct loop *loop)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"bad data references.\");\n-      destroy_loop_vec_info (loop_vinfo, true);\n-      return NULL;\n+      return false;\n     }\n \n   /* Classify all cross-iteration scalar data-flow cycles.\n@@ -1436,8 +1412,7 @@ vect_analyze_loop (struct loop *loop)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"unexpected pattern.\");\n-      destroy_loop_vec_info (loop_vinfo, true);\n-      return NULL;\n+      return false;\n     }\n \n   /* Analyze data dependences between the data-refs in the loop\n@@ -1451,24 +1426,21 @@ vect_analyze_loop (struct loop *loop)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"bad data dependence.\");\n-      destroy_loop_vec_info (loop_vinfo, true);\n-      return NULL;\n+      return false;\n     }\n \n   ok = vect_determine_vectorization_factor (loop_vinfo);\n   if (!ok)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"can't determine vectorization factor.\");\n-      destroy_loop_vec_info (loop_vinfo, true);\n-      return NULL;\n+      return false;\n     }\n   if (max_vf < LOOP_VINFO_VECT_FACTOR (loop_vinfo))\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"bad data dependence.\");\n-      destroy_loop_vec_info (loop_vinfo, true);\n-      return NULL;\n+      return false;\n     }\n \n   /* Analyze the alignment of the data-refs in the loop.\n@@ -1479,8 +1451,7 @@ vect_analyze_loop (struct loop *loop)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"bad data alignment.\");\n-      destroy_loop_vec_info (loop_vinfo, true);\n-      return NULL;\n+      return false;\n     }\n \n   /* Analyze the access patterns of the data-refs in the loop (consecutive,\n@@ -1491,8 +1462,7 @@ vect_analyze_loop (struct loop *loop)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"bad data access.\");\n-      destroy_loop_vec_info (loop_vinfo, true);\n-      return NULL;\n+      return false;\n     }\n \n   /* Prune the list of ddrs to be tested at run-time by versioning for alias.\n@@ -1504,8 +1474,7 @@ vect_analyze_loop (struct loop *loop)\n       if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"too long list of versioning for alias \"\n \t\t\t    \"run-time tests.\");\n-      destroy_loop_vec_info (loop_vinfo, true);\n-      return NULL;\n+      return false;\n     }\n \n   /* This pass will decide on using loop versioning and/or loop peeling in\n@@ -1516,8 +1485,7 @@ vect_analyze_loop (struct loop *loop)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"bad data alignment.\");\n-      destroy_loop_vec_info (loop_vinfo, true);\n-      return NULL;\n+      return false;\n     }\n \n   /* Check the SLP opportunities in the loop, analyze and build SLP trees.  */\n@@ -1539,13 +1507,70 @@ vect_analyze_loop (struct loop *loop)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"bad operation or unsupported loop bound.\");\n-      destroy_loop_vec_info (loop_vinfo, true);\n+      return false;\n+    }\n+\n+  return true;\n+}\n+\n+/* Function vect_analyze_loop.\n+\n+   Apply a set of analyses on LOOP, and create a loop_vec_info struct\n+   for it.  The different analyses will record information in the\n+   loop_vec_info struct.  */\n+loop_vec_info\n+vect_analyze_loop (struct loop *loop)\n+{\n+  loop_vec_info loop_vinfo;\n+  unsigned int vector_sizes;\n+\n+  /* Autodetect first vector size we try.  */\n+  current_vector_size = 0;\n+  vector_sizes = targetm.vectorize.autovectorize_vector_sizes ();\n+\n+  if (vect_print_dump_info (REPORT_DETAILS))\n+    fprintf (vect_dump, \"===== analyze_loop_nest =====\");\n+\n+  if (loop_outer (loop)\n+      && loop_vec_info_for_loop (loop_outer (loop))\n+      && LOOP_VINFO_VECTORIZABLE_P (loop_vec_info_for_loop (loop_outer (loop))))\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+\tfprintf (vect_dump, \"outer-loop already vectorized.\");\n       return NULL;\n     }\n \n-  LOOP_VINFO_VECTORIZABLE_P (loop_vinfo) = 1;\n+  while (1)\n+    {\n+      /* Check the CFG characteristics of the loop (nesting, entry/exit).  */\n+      loop_vinfo = vect_analyze_loop_form (loop);\n+      if (!loop_vinfo)\n+\t{\n+\t  if (vect_print_dump_info (REPORT_DETAILS))\n+\t    fprintf (vect_dump, \"bad loop form.\");\n+\t  return NULL;\n+\t}\n \n-  return loop_vinfo;\n+      if (vect_analyze_loop_2 (loop_vinfo))\n+\t{\n+\t  LOOP_VINFO_VECTORIZABLE_P (loop_vinfo) = 1;\n+\n+\t  return loop_vinfo;\n+\t}\n+\n+      destroy_loop_vec_info (loop_vinfo, true);\n+\n+      vector_sizes &= ~current_vector_size;\n+      if (vector_sizes == 0\n+\t  || current_vector_size == 0)\n+\treturn NULL;\n+\n+      /* Try the next biggest vector size.  */\n+      current_vector_size = 1 << floor_log2 (vector_sizes);\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+\tfprintf (vect_dump, \"***** Re-trying analysis with \"\n+\t\t \"vector size %d\\n\", current_vector_size);\n+    }\n }\n \n "}, {"sha": "2dbe328ba2502be689193adda1e1d2c280de7e34", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb67d9c7cef80c80e817cafdd9ee2001cb29c9f7/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb67d9c7cef80c80e817cafdd9ee2001cb29c9f7/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=bb67d9c7cef80c80e817cafdd9ee2001cb29c9f7", "patch": "@@ -1643,6 +1643,7 @@ vect_slp_analyze_bb (basic_block bb)\n   int max_vf = MAX_VECTORIZATION_FACTOR;\n   bool data_dependence_in_bb = false;\n \n+  current_vector_size = 0;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"===vect_slp_analyze_bb===\\n\");"}, {"sha": "6d0c1126d59ee2091e80ccbe69c32460a419389f", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 34, "deletions": 8, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb67d9c7cef80c80e817cafdd9ee2001cb29c9f7/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb67d9c7cef80c80e817cafdd9ee2001cb29c9f7/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=bb67d9c7cef80c80e817cafdd9ee2001cb29c9f7", "patch": "@@ -3455,7 +3455,8 @@ perm_mask_for_reverse (tree vectype, tree *mask)\n \n   mask_type = get_vectype_for_scalar_type (mask_element_type);\n   nunits = TYPE_VECTOR_SUBPARTS (vectype);\n-  if (TYPE_VECTOR_SUBPARTS (vectype) != TYPE_VECTOR_SUBPARTS (mask_type))\n+  if (!mask_type\n+      || TYPE_VECTOR_SUBPARTS (vectype) != TYPE_VECTOR_SUBPARTS (mask_type))\n     return NULL;\n \n   for (i = 0; i < nunits; i++)\n@@ -4784,13 +4785,13 @@ free_stmt_vec_info (gimple stmt)\n }\n \n \n-/* Function get_vectype_for_scalar_type.\n+/* Function get_vectype_for_scalar_type_and_size.\n \n-   Returns the vector type corresponding to SCALAR_TYPE as supported\n+   Returns the vector type corresponding to SCALAR_TYPE  and SIZE as supported\n    by the target.  */\n \n-tree\n-get_vectype_for_scalar_type (tree scalar_type)\n+static tree\n+get_vectype_for_scalar_type_and_size (tree scalar_type, unsigned size)\n {\n   enum machine_mode inner_mode = TYPE_MODE (scalar_type);\n   enum machine_mode simd_mode;\n@@ -4818,7 +4819,12 @@ get_vectype_for_scalar_type (tree scalar_type)\n       && GET_MODE_CLASS (inner_mode) != MODE_FLOAT)\n     return NULL_TREE;\n \n-  simd_mode = targetm.vectorize.preferred_simd_mode (inner_mode);\n+  /* If no size was supplied use the mode the target prefers.   Otherwise\n+     lookup a vector mode of the specified size.  */\n+  if (size == 0)\n+    simd_mode = targetm.vectorize.preferred_simd_mode (inner_mode);\n+  else\n+    simd_mode = mode_for_vector (inner_mode, size / nbytes);\n   nunits = GET_MODE_SIZE (simd_mode) / nbytes;\n   if (nunits <= 1)\n     return NULL_TREE;\n@@ -4850,15 +4856,35 @@ get_vectype_for_scalar_type (tree scalar_type)\n   return vectype;\n }\n \n+unsigned int current_vector_size;\n+\n+/* Function get_vectype_for_scalar_type.\n+\n+   Returns the vector type corresponding to SCALAR_TYPE as supported\n+   by the target.  */\n+\n+tree\n+get_vectype_for_scalar_type (tree scalar_type)\n+{\n+  tree vectype;\n+  vectype = get_vectype_for_scalar_type_and_size (scalar_type,\n+\t\t\t\t\t\t  current_vector_size);\n+  if (vectype\n+      && current_vector_size == 0)\n+    current_vector_size = GET_MODE_SIZE (TYPE_MODE (vectype));\n+  return vectype;\n+}\n+\n /* Function get_same_sized_vectype\n \n    Returns a vector type corresponding to SCALAR_TYPE of size\n    VECTOR_TYPE if supported by the target.  */\n \n tree\n-get_same_sized_vectype (tree scalar_type, tree vector_type ATTRIBUTE_UNUSED)\n+get_same_sized_vectype (tree scalar_type, tree vector_type)\n {\n-  return get_vectype_for_scalar_type (scalar_type);\n+  return get_vectype_for_scalar_type_and_size\n+\t   (scalar_type, GET_MODE_SIZE (TYPE_MODE (vector_type)));\n }\n \n /* Function vect_is_simple_use."}, {"sha": "389e80a0551c70ceae1c9afbefe3d852dc0b00b3", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb67d9c7cef80c80e817cafdd9ee2001cb29c9f7/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb67d9c7cef80c80e817cafdd9ee2001cb29c9f7/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=bb67d9c7cef80c80e817cafdd9ee2001cb29c9f7", "patch": "@@ -779,6 +779,7 @@ extern LOC find_loop_location (struct loop *);\n extern bool vect_can_advance_ivs_p (loop_vec_info);\n \n /* In tree-vect-stmts.c.  */\n+extern unsigned int current_vector_size;\n extern tree get_vectype_for_scalar_type (tree);\n extern tree get_same_sized_vectype (tree, tree);\n extern bool vect_is_simple_use (tree, loop_vec_info, bb_vec_info, gimple *,"}]}