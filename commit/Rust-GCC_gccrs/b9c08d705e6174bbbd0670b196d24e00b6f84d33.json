{"sha": "b9c08d705e6174bbbd0670b196d24e00b6f84d33", "node_id": "C_kwDOANBUbNoAKGI5YzA4ZDcwNWU2MTc0YmJiZDA2NzBiMTk2ZDI0ZTAwYjZmODRkMzM", "commit": {"author": {"name": "Faisal Abbas", "email": "90.abbasfaisal@gmail.com", "date": "2022-07-07T10:31:32Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-25T11:40:23Z"}, "message": "gccrs const folding port: continue porting potential_constant_expression_1()\n\nFollowing functions are ported in this changeset:\n - type_memfn_quals\n - find_parameter_pack_data\n - conv_type_hasher\n - make_conv_op_name\n - builtin_pack_fn_p\n - builtin_pack_call_p\n - has_extra_args_mechanism_p\n - find_parameter_packs_r\n - type_memfn_rqual\n - maybe_add_lang_type_raw\n - type_of_this_parm\n - class_of_this_parm\n\nFollowing structs, classes and enums are ported in this changeset:\n - cxx_binding\n - c_common_identifier\n - lang_identifier\n - cp_ref_qualifier\n - find_parameter_pack_data\n - conv_type_hasher\n\nSigned-off-by: Faisal Abbas <90.abbasfaisal@gmail.com>", "tree": {"sha": "087dffb5586d272009b331fa5c8b263b8fe66a32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/087dffb5586d272009b331fa5c8b263b8fe66a32"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b9c08d705e6174bbbd0670b196d24e00b6f84d33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9c08d705e6174bbbd0670b196d24e00b6f84d33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9c08d705e6174bbbd0670b196d24e00b6f84d33", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9c08d705e6174bbbd0670b196d24e00b6f84d33/comments", "author": {"login": "abbasfaisal", "id": 9428333, "node_id": "MDQ6VXNlcjk0MjgzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/9428333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/abbasfaisal", "html_url": "https://github.com/abbasfaisal", "followers_url": "https://api.github.com/users/abbasfaisal/followers", "following_url": "https://api.github.com/users/abbasfaisal/following{/other_user}", "gists_url": "https://api.github.com/users/abbasfaisal/gists{/gist_id}", "starred_url": "https://api.github.com/users/abbasfaisal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/abbasfaisal/subscriptions", "organizations_url": "https://api.github.com/users/abbasfaisal/orgs", "repos_url": "https://api.github.com/users/abbasfaisal/repos", "events_url": "https://api.github.com/users/abbasfaisal/events{/privacy}", "received_events_url": "https://api.github.com/users/abbasfaisal/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6f1984c3e483e7c00ef8822d310d98ea752d92a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6f1984c3e483e7c00ef8822d310d98ea752d92a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6f1984c3e483e7c00ef8822d310d98ea752d92a"}], "stats": {"total": 453, "additions": 439, "deletions": 14}, "files": [{"sha": "4359c3de98793b0334bbe9408a13971a7a0025ef", "filename": "gcc/rust/backend/rust-tree.cc", "status": "modified", "additions": 301, "deletions": 3, "changes": 304, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9c08d705e6174bbbd0670b196d24e00b6f84d33/gcc%2Frust%2Fbackend%2Frust-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9c08d705e6174bbbd0670b196d24e00b6f84d33/gcc%2Frust%2Fbackend%2Frust-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.cc?ref=b9c08d705e6174bbbd0670b196d24e00b6f84d33", "patch": "@@ -1117,9 +1117,6 @@ is_overloaded_fn (tree x)\n   if (TREE_CODE (x) == COMPONENT_REF)\n     x = TREE_OPERAND (x, 1);\n \n-  if ((TREE_CODE (x) == OVERLOAD && !OVL_SINGLE_P (x)))\n-    return 2;\n-\n   return OVL_P (x);\n }\n \n@@ -1165,4 +1162,305 @@ lookup_add (tree fns, tree lookup)\n \n   return lookup;\n }\n+\n+// forked from gcc/cp/typeck.cc type_memfn_quals\n+\n+/* Returns the function-cv-quals for TYPE, which must be a FUNCTION_TYPE or\n+   METHOD_TYPE.  */\n+\n+int\n+type_memfn_quals (const_tree type)\n+{\n+  if (TREE_CODE (type) == FUNCTION_TYPE)\n+    return TYPE_QUALS (type);\n+  else if (TREE_CODE (type) == METHOD_TYPE)\n+    return rs_type_quals (class_of_this_parm (type));\n+  else\n+    gcc_unreachable ();\n+}\n+\n+// forked from gcc/cp/pt.cc find_parameter_pack_data\n+\n+/* Structure used to track the progress of find_parameter_packs_r.  */\n+struct find_parameter_pack_data\n+{\n+  /* TREE_LIST that will contain all of the parameter packs found by\n+     the traversal.  */\n+  tree *parameter_packs;\n+\n+  /* Set of AST nodes that have been visited by the traversal.  */\n+  hash_set<tree> *visited;\n+\n+  /* True iff we're making a type pack expansion.  */\n+  bool type_pack_expansion_p;\n+\n+  /* True iff we found a subtree that has the extra args mechanism.  */\n+  bool found_extra_args_tree_p = false;\n+};\n+\n+// forked from gcc/cp/lex.cc conv_type_hasher\n+\n+/* Hasher for the conversion operator name hash table.  */\n+struct conv_type_hasher : ggc_ptr_hash<tree_node>\n+{\n+  /* Hash NODE, an identifier node in the table.  TYPE_UID is\n+     suitable, as we're not concerned about matching canonicalness\n+     here.  */\n+  static hashval_t hash (tree node)\n+  {\n+    return (hashval_t) TYPE_UID (TREE_TYPE (node));\n+  }\n+\n+  /* Compare NODE, an identifier node in the table, against TYPE, an\n+     incoming TYPE being looked up.  */\n+  static bool equal (tree node, tree type) { return TREE_TYPE (node) == type; }\n+};\n+\n+static GTY (()) hash_table<conv_type_hasher> *conv_type_names;\n+\n+// forked from gcc/cp/lex.cc make_conv_op_name\n+\n+/* Return an identifier for a conversion operator to TYPE.  We can get\n+   from the returned identifier to the type.  We store TYPE, which is\n+   not necessarily the canonical type,  which allows us to report the\n+   form the user used in error messages.  All these identifiers are\n+   not in the identifier hash table, and have the same string name.\n+   These IDENTIFIERS are not in the identifier hash table, and all\n+   have the same IDENTIFIER_STRING.  */\n+\n+tree\n+make_conv_op_name (tree type)\n+{\n+  if (type == error_mark_node)\n+    return error_mark_node;\n+\n+  if (conv_type_names == NULL)\n+    conv_type_names = hash_table<conv_type_hasher>::create_ggc (31);\n+\n+  tree *slot\n+    = conv_type_names->find_slot_with_hash (type, (hashval_t) TYPE_UID (type),\n+\t\t\t\t\t    INSERT);\n+  tree identifier = *slot;\n+  if (!identifier)\n+    {\n+      /* Create a raw IDENTIFIER outside of the identifier hash\n+\t table.  */\n+      identifier = copy_node (conv_op_identifier);\n+\n+      /* Just in case something managed to bind.  */\n+      IDENTIFIER_BINDING (identifier) = NULL;\n+\n+      /* Hang TYPE off the identifier so it can be found easily later\n+\t when performing conversions.  */\n+      TREE_TYPE (identifier) = type;\n+\n+      *slot = identifier;\n+    }\n+\n+  return identifier;\n+}\n+\n+// forked from gcc/cp/pt.cc builtin_pack_fn_p\n+\n+/* True iff FN is a function representing a built-in variadic parameter\n+   pack.  */\n+\n+bool\n+builtin_pack_fn_p (tree fn)\n+{\n+  if (!fn || TREE_CODE (fn) != FUNCTION_DECL\n+      || !DECL_IS_UNDECLARED_BUILTIN (fn))\n+    return false;\n+\n+  if (id_equal (DECL_NAME (fn), \"__integer_pack\"))\n+    return true;\n+\n+  return false;\n+}\n+\n+// forked from gcc/cp/pt.cc builtin_pack_call_p\n+\n+/* True iff CALL is a call to a function representing a built-in variadic\n+   parameter pack.  */\n+\n+static bool\n+builtin_pack_call_p (tree call)\n+{\n+  if (TREE_CODE (call) != CALL_EXPR)\n+    return false;\n+  return builtin_pack_fn_p (CALL_EXPR_FN (call));\n+}\n+\n+// forked from gcc/cp/pt.cc has_extra_args_mechanism_p\n+\n+/* Return true if the tree T has the extra args mechanism for\n+   avoiding partial instantiation.  */\n+\n+static bool\n+has_extra_args_mechanism_p (const_tree t)\n+{\n+  return false;\n+}\n+\n+// forked from gcc/cp/pt.cc find_parameter_packs_r\n+\n+/* Identifies all of the argument packs that occur in a template\n+   argument and appends them to the TREE_LIST inside DATA, which is a\n+   find_parameter_pack_data structure. This is a subroutine of\n+   make_pack_expansion and uses_parameter_packs.  */\n+static tree\n+find_parameter_packs_r (tree *tp, int *walk_subtrees, void *data)\n+{\n+  tree t = *tp;\n+  struct find_parameter_pack_data *ppd\n+    = (struct find_parameter_pack_data *) data;\n+  bool parameter_pack_p = false;\n+\n+#define WALK_SUBTREE(NODE)                                                     \\\n+  rs_walk_tree (&(NODE), &find_parameter_packs_r, ppd, ppd->visited)\n+\n+  /* Don't look through typedefs; we are interested in whether a\n+     parameter pack is actually written in the expression/type we're\n+     looking at, not the target type.  */\n+  if (TYPE_P (t) && typedef_variant_p (t))\n+    {\n+      *walk_subtrees = 0;\n+      return NULL_TREE;\n+    }\n+\n+  /* Identify whether this is a parameter pack or not.  */\n+  switch (TREE_CODE (t))\n+    {\n+    case FIELD_DECL:\n+    case PARM_DECL:\n+      break;\n+\n+    case VAR_DECL:\n+      break;\n+\n+    case CALL_EXPR:\n+      if (builtin_pack_call_p (t))\n+\tparameter_pack_p = true;\n+      break;\n+\n+    case BASES:\n+      parameter_pack_p = true;\n+      break;\n+    default:\n+      /* Not a parameter pack.  */\n+      break;\n+    }\n+\n+  if (parameter_pack_p)\n+    {\n+      /* Add this parameter pack to the list.  */\n+      *ppd->parameter_packs = tree_cons (NULL_TREE, t, *ppd->parameter_packs);\n+    }\n+\n+  if (TYPE_P (t))\n+    rs_walk_tree (&TYPE_CONTEXT (t), &find_parameter_packs_r, ppd,\n+\t\t  ppd->visited);\n+\n+  /* This switch statement will return immediately if we don't find a\n+     parameter pack.  ??? Should some of these be in cp_walk_subtrees?  */\n+  switch (TREE_CODE (t))\n+    {\n+      case DECL_EXPR: {\n+\ttree decl = DECL_EXPR_DECL (t);\n+\tif (is_typedef_decl (decl))\n+\t  /* Since we stop at typedefs above, we need to look through them at\n+\t     the point of the DECL_EXPR.  */\n+\t  rs_walk_tree (&DECL_ORIGINAL_TYPE (decl), &find_parameter_packs_r,\n+\t\t\tppd, ppd->visited);\n+\treturn NULL_TREE;\n+      }\n+\n+    case INTEGER_TYPE:\n+      rs_walk_tree (&TYPE_MAX_VALUE (t), &find_parameter_packs_r, ppd,\n+\t\t    ppd->visited);\n+      *walk_subtrees = 0;\n+      return NULL_TREE;\n+\n+    case IDENTIFIER_NODE:\n+      rs_walk_tree (&TREE_TYPE (t), &find_parameter_packs_r, ppd, ppd->visited);\n+      *walk_subtrees = 0;\n+      return NULL_TREE;\n+\n+      case DECLTYPE_TYPE: {\n+\t/* When traversing a DECLTYPE_TYPE_EXPR, we need to set\n+\t   type_pack_expansion_p to false so that any placeholders\n+\t   within the expression don't get marked as parameter packs.  */\n+\tbool type_pack_expansion_p = ppd->type_pack_expansion_p;\n+\tppd->type_pack_expansion_p = false;\n+\trs_walk_tree (&DECLTYPE_TYPE_EXPR (t), &find_parameter_packs_r, ppd,\n+\t\t      ppd->visited);\n+\tppd->type_pack_expansion_p = type_pack_expansion_p;\n+\t*walk_subtrees = 0;\n+\treturn NULL_TREE;\n+      }\n+\n+    case IF_STMT:\n+      rs_walk_tree (&IF_COND (t), &find_parameter_packs_r, ppd, ppd->visited);\n+      rs_walk_tree (&THEN_CLAUSE (t), &find_parameter_packs_r, ppd,\n+\t\t    ppd->visited);\n+      rs_walk_tree (&ELSE_CLAUSE (t), &find_parameter_packs_r, ppd,\n+\t\t    ppd->visited);\n+      /* Don't walk into IF_STMT_EXTRA_ARGS.  */\n+      *walk_subtrees = 0;\n+      return NULL_TREE;\n+\n+    case FUNCTION_TYPE:\n+    case METHOD_TYPE:\n+      WALK_SUBTREE (TYPE_RAISES_EXCEPTIONS (t));\n+      break;\n+\n+    default:\n+      return NULL_TREE;\n+    }\n+\n+#undef WALK_SUBTREE\n+\n+  return NULL_TREE;\n+}\n+\n+// forked from gcc/cp/typeck.cc type_memfn_rqual\n+\n+/* Returns the function-ref-qualifier for TYPE */\n+\n+rs_ref_qualifier\n+type_memfn_rqual (const_tree type)\n+{\n+  gcc_assert (FUNC_OR_METHOD_TYPE_P (type));\n+\n+  if (!FUNCTION_REF_QUALIFIED (type))\n+    return REF_QUAL_NONE;\n+  else if (FUNCTION_RVALUE_QUALIFIED (type))\n+    return REF_QUAL_RVALUE;\n+  else\n+    return REF_QUAL_LVALUE;\n+}\n+\n+// forked from gcc/cp/lex.cc maybe_add_lang_type_raw\n+\n+/* Add a raw lang_type to T, a type, should it need one.  */\n+\n+bool\n+maybe_add_lang_type_raw (tree t)\n+{\n+  if (!RECORD_OR_UNION_CODE_P (TREE_CODE (t)))\n+    return false;\n+\n+  auto *lt = (struct lang_type *) (ggc_internal_cleared_alloc (\n+    sizeof (struct lang_type)));\n+  TYPE_LANG_SPECIFIC (t) = lt;\n+\n+  if (GATHER_STATISTICS)\n+    {\n+      tree_node_counts[(int) lang_type] += 1;\n+      tree_node_sizes[(int) lang_type] += sizeof (struct lang_type);\n+    }\n+\n+  return true;\n+}\n+\n } // namespace Rust"}, {"sha": "99ec33c640d1cecf3c25a751f033e8f3858a27d9", "filename": "gcc/rust/backend/rust-tree.h", "status": "modified", "additions": 138, "deletions": 11, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9c08d705e6174bbbd0670b196d24e00b6f84d33/gcc%2Frust%2Fbackend%2Frust-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9c08d705e6174bbbd0670b196d24e00b6f84d33/gcc%2Frust%2Fbackend%2Frust-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.h?ref=b9c08d705e6174bbbd0670b196d24e00b6f84d33", "patch": "@@ -22,6 +22,7 @@\n #include \"rust-system.h\"\n #include \"coretypes.h\"\n #include \"tree.h\"\n+#include \"cpplib.h\"\n \n /* Returns true if NODE is a pointer.  */\n #define TYPE_PTR_P(NODE) (TREE_CODE (NODE) == POINTER_TYPE)\n@@ -664,6 +665,74 @@ extern GTY (()) tree cp_global_trees[CPTI_MAX];\n    order.  */\n #define MAYBE_CLASS_TYPE_P(T) (WILDCARD_TYPE_P (T) || CLASS_TYPE_P (T))\n \n+/* 1 iff FUNCTION_TYPE or METHOD_TYPE has a ref-qualifier (either & or &&). */\n+#define FUNCTION_REF_QUALIFIED(NODE)                                           \\\n+  TREE_LANG_FLAG_4 (FUNC_OR_METHOD_CHECK (NODE))\n+\n+/* 1 iff FUNCTION_TYPE or METHOD_TYPE has &&-ref-qualifier.  */\n+#define FUNCTION_RVALUE_QUALIFIED(NODE)                                        \\\n+  TREE_LANG_FLAG_5 (FUNC_OR_METHOD_CHECK (NODE))\n+\n+/* Get the POINTER_TYPE to the METHOD_TYPE associated with this\n+   pointer to member function.  TYPE_PTRMEMFUNC_P _must_ be true,\n+   before using this macro.  */\n+#define TYPE_PTRMEMFUNC_FN_TYPE(NODE)                                          \\\n+  (cp_build_qualified_type (TREE_TYPE (TYPE_FIELDS (NODE)),                    \\\n+\t\t\t    rs_type_quals (NODE)))\n+\n+/* As above, but can be used in places that want an lvalue at the expense\n+   of not necessarily having the correct cv-qualifiers.  */\n+#define TYPE_PTRMEMFUNC_FN_TYPE_RAW(NODE) (TREE_TYPE (TYPE_FIELDS (NODE)))\n+\n+/* True if this type is dependent.  This predicate is only valid if\n+   TYPE_DEPENDENT_P_VALID is true.  */\n+#define TYPE_DEPENDENT_P(NODE) TYPE_LANG_FLAG_0 (NODE)\n+\n+/* True if dependent_type_p has been called for this type, with the\n+   result that TYPE_DEPENDENT_P is valid.  */\n+#define TYPE_DEPENDENT_P_VALID(NODE) TYPE_LANG_FLAG_6 (NODE)\n+\n+/* Nonzero for _TYPE node means that this type does not have a trivial\n+   destructor.  Therefore, destroying an object of this type will\n+   involve a call to a destructor.  This can apply to objects of\n+   ARRAY_TYPE if the type of the elements needs a destructor.  */\n+#define TYPE_HAS_NONTRIVIAL_DESTRUCTOR(NODE) (TYPE_LANG_FLAG_4 (NODE))\n+\n+/* For FUNCTION_TYPE or METHOD_TYPE, a list of the exceptions that\n+   this type can raise.  Each TREE_VALUE is a _TYPE.  The TREE_VALUE\n+   will be NULL_TREE to indicate a throw specification of `()', or\n+   no exceptions allowed.  For a noexcept specification, TREE_VALUE\n+   is NULL_TREE and TREE_PURPOSE is the constant-expression.  For\n+   a deferred noexcept-specification, TREE_PURPOSE is a DEFERRED_NOEXCEPT\n+   (for templates) or an OVERLOAD list of functions (for implicitly\n+   declared functions).  */\n+#define TYPE_RAISES_EXCEPTIONS(NODE)                                           \\\n+  TYPE_LANG_SLOT_1 (FUNC_OR_METHOD_CHECK (NODE))\n+\n+/* Identifiers map directly to block or class-scope bindings.\n+   Namespace-scope bindings are held in hash tables on the respective\n+   namespaces.  The identifier bindings are the innermost active\n+   binding, from whence you can get the decl and/or implicit-typedef\n+   of an elaborated type.   When not bound to a local entity the\n+   values are NULL.  */\n+#define IDENTIFIER_BINDING(NODE) (LANG_IDENTIFIER_CAST (NODE)->bindings)\n+\n+#define LANG_IDENTIFIER_CAST(NODE)                                             \\\n+  ((struct lang_identifier *) IDENTIFIER_NODE_CHECK (NODE))\n+\n+/* IF_STMT accessors. These give access to the condition of the if\n+   statement, the then block of the if statement, and the else block\n+   of the if statement if it exists.  */\n+#define IF_COND(NODE) TREE_OPERAND (IF_STMT_CHECK (NODE), 0)\n+#define THEN_CLAUSE(NODE) TREE_OPERAND (IF_STMT_CHECK (NODE), 1)\n+#define ELSE_CLAUSE(NODE) TREE_OPERAND (IF_STMT_CHECK (NODE), 2)\n+#define IF_SCOPE(NODE) TREE_OPERAND (IF_STMT_CHECK (NODE), 3)\n+#define IF_STMT_CONSTEXPR_P(NODE) TREE_LANG_FLAG_0 (IF_STMT_CHECK (NODE))\n+#define IF_STMT_CONSTEVAL_P(NODE) TREE_LANG_FLAG_2 (IF_STMT_CHECK (NODE))\n+\n+/* The expression in question for a DECLTYPE_TYPE.  */\n+#define DECLTYPE_TYPE_EXPR(NODE) (TYPE_VALUES_RAW (DECLTYPE_TYPE_CHECK (NODE)))\n+\n // Below macros are copied from gcc/c-family/c-common.h\n \n /* In a FIELD_DECL, nonzero if the decl was originally a bitfield.  */\n@@ -689,17 +758,6 @@ extern GTY (()) tree cp_global_trees[CPTI_MAX];\n   ((rs_type_quals (NODE) & (TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE))             \\\n    == TYPE_QUAL_CONST)\n \n-/* [basic.fundamental]\n-\n-   Types  bool, char, wchar_t, and the signed and unsigned integer types\n-   are collectively called integral types.\n-\n-   Note that INTEGRAL_TYPE_P, as defined in tree.h, allows enumeration\n-   types as well, which is incorrect in C++.  Keep these checks in\n-   ascending code order.  */\n-#define RS_INTEGRAL_TYPE_P(TYPE)                                               \\\n-  (TREE_CODE (TYPE) == BOOLEAN_TYPE || TREE_CODE (TYPE) == INTEGER_TYPE)\n-\n /* Returns true if TYPE is an integral or enumeration name.  Keep\n    these checks in ascending code order.  */\n #define INTEGRAL_OR_ENUMERATION_TYPE_P(TYPE)                                   \\\n@@ -740,6 +798,44 @@ extern GTY (()) tree cp_global_trees[CPTI_MAX];\n \n // Above macros are copied from gcc/cp/name-lookup.cc\n \n+// forked from gcc/cp/name-lookup.h\n+\n+/* Datatype that represents binding established by a declaration between\n+   a name and a C++ entity.  */\n+struct GTY (()) cxx_binding\n+{\n+  /* Link to chain together various bindings for this name.  */\n+  cxx_binding *previous;\n+  /* The non-type entity this name is bound to.  */\n+  tree value;\n+  /* The type entity this name is bound to.  */\n+  tree type;\n+\n+  bool value_is_inherited : 1;\n+  bool is_local : 1;\n+  bool type_is_hidden : 1;\n+};\n+\n+// forked from gcc/c-family/c-common.h c_common_identifier\n+\n+/* Identifier part common to the C front ends.  Inherits from\n+   tree_identifier, despite appearances.  */\n+struct GTY (()) c_common_identifier\n+{\n+  struct tree_common common;\n+  struct cpp_hashnode node; // from cpplib.h\n+};\n+\n+// forked from gcc/cp/cp-tree.h lang_identifier\n+\n+/* Language-dependent contents of an identifier.  */\n+\n+struct GTY (()) lang_identifier\n+{\n+  struct c_common_identifier c_common;\n+  cxx_binding *bindings;\n+};\n+\n // forked from gcc/cp/cp-tree.h tree_overload\n \n /* OVL_HIDDEN_P nodes come before other nodes.  */\n@@ -953,6 +1049,15 @@ struct GTY (()) lang_type\n \n namespace Rust {\n \n+// forked from gcc/cp/cp-tree.h cp_ref_qualifier\n+\n+enum rs_ref_qualifier\n+{\n+  REF_QUAL_NONE = 0,\n+  REF_QUAL_LVALUE = 1,\n+  REF_QUAL_RVALUE = 2\n+};\n+\n // forked from gcc/cp/cp-tree.h tsubst_flags\n \n /* Bitmask flags to control type substitution.  */\n@@ -1227,6 +1332,28 @@ ovl_first (tree node)\n   return node;\n }\n \n+// forked from gcc/cp/cp-tree.h type_of_this_parm\n+\n+/* Return the type of the `this' parameter of FNTYPE.  */\n+\n+inline tree\n+type_of_this_parm (const_tree fntype)\n+{\n+  function_args_iterator iter;\n+  gcc_assert (TREE_CODE (fntype) == METHOD_TYPE);\n+  function_args_iter_init (&iter, fntype);\n+  return function_args_iter_cond (&iter);\n+}\n+\n+// forked from gcc/cp/cp-tree.h class_of_this_parm\n+\n+/* Return the class of the `this' parameter of FNTYPE.  */\n+\n+inline tree\n+class_of_this_parm (const_tree fntype)\n+{\n+  return TREE_TYPE (type_of_this_parm (fntype));\n+}\n } // namespace Rust\n \n #endif // RUST_TREE"}]}