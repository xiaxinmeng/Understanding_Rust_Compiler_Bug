{"sha": "c5decc83e4eb06103c801fd4f8215301ce746109", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzVkZWNjODNlNGViMDYxMDNjODAxZmQ0ZjgyMTUzMDFjZTc0NjEwOQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-02-26T19:15:50Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-02-26T20:19:13Z"}, "message": "libgo: update to final Go1.14 release\n\nReviewed-on: https://go-review.googlesource.com/c/gofrontend/+/221158", "tree": {"sha": "5443f7ec2e16fac152fe1af564d10b0d29ff1b95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5443f7ec2e16fac152fe1af564d10b0d29ff1b95"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5decc83e4eb06103c801fd4f8215301ce746109", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5decc83e4eb06103c801fd4f8215301ce746109", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5decc83e4eb06103c801fd4f8215301ce746109", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5decc83e4eb06103c801fd4f8215301ce746109/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "051b9873e78fe1acb1a3fecd0c6e5685b6c12fb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/051b9873e78fe1acb1a3fecd0c6e5685b6c12fb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/051b9873e78fe1acb1a3fecd0c6e5685b6c12fb3"}], "stats": {"total": 277, "additions": 225, "deletions": 52}, "files": [{"sha": "a62c8292e0a1827ca4b70fc2301a049e0a81d649", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5decc83e4eb06103c801fd4f8215301ce746109/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5decc83e4eb06103c801fd4f8215301ce746109/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=c5decc83e4eb06103c801fd4f8215301ce746109", "patch": "@@ -1,4 +1,4 @@\n-658fe4f48374167bf8688e8dbd5f85eee155749e\n+5fc21bb0d91d916940c21e6d4a3e10ad3f45343d\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "233492ada69ba877029691817b47cabb224ba24d", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5decc83e4eb06103c801fd4f8215301ce746109/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5decc83e4eb06103c801fd4f8215301ce746109/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=c5decc83e4eb06103c801fd4f8215301ce746109", "patch": "@@ -1,4 +1,4 @@\n-a068054af141c01df5a4519844f4b77273605f4e\n+20a838ab94178c55bc4dc23ddc332fce8545a493\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "f000507a7fe7649efb56eaf39972338864860451", "filename": "libgo/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5decc83e4eb06103c801fd4f8215301ce746109/libgo%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5decc83e4eb06103c801fd4f8215301ce746109/libgo%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FVERSION?ref=c5decc83e4eb06103c801fd4f8215301ce746109", "patch": "@@ -1 +1 @@\n-go1.14rc1\n+go1.14"}, {"sha": "d72d0cacd68ddafdc2723c00ca3d7f04a7aa62bc", "filename": "libgo/go/cmd/go/internal/modcmd/mod.go", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5decc83e4eb06103c801fd4f8215301ce746109/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fmod.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5decc83e4eb06103c801fd4f8215301ce746109/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fmod.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fmod.go?ref=c5decc83e4eb06103c801fd4f8215301ce746109", "patch": "@@ -7,7 +7,6 @@ package modcmd\n \n import (\n \t\"cmd/go/internal/base\"\n-\t\"cmd/go/internal/cfg\"\n )\n \n var CmdMod = &base.Command{\n@@ -32,7 +31,3 @@ See 'go help modules' for an overview of module functionality.\n \t\tcmdWhy,\n \t},\n }\n-\n-func addModFlags(cmd *base.Command) {\n-\tcmd.Flag.StringVar(&cfg.ModFile, \"modfile\", \"\", \"\")\n-}"}, {"sha": "d7fca8fd2c5c9f15b3a348f2dea279ca9757fd50", "filename": "libgo/go/cmd/go/internal/modload/import.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5decc83e4eb06103c801fd4f8215301ce746109/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5decc83e4eb06103c801fd4f8215301ce746109/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport.go?ref=c5decc83e4eb06103c801fd4f8215301ce746109", "patch": "@@ -184,8 +184,9 @@ func Import(path string) (m module.Version, dir string, err error) {\n \t\tif !pathIsStd {\n \t\t\tif cfg.BuildModReason == \"\" {\n \t\t\t\tqueryErr = fmt.Errorf(\"import lookup disabled by -mod=%s\", cfg.BuildMod)\n+\t\t\t} else {\n+\t\t\t\tqueryErr = fmt.Errorf(\"import lookup disabled by -mod=%s\\n\\t(%s)\", cfg.BuildMod, cfg.BuildModReason)\n \t\t\t}\n-\t\t\tqueryErr = fmt.Errorf(\"import lookup disabled by -mod=%s\\n\\t(%s)\", cfg.BuildMod, cfg.BuildModReason)\n \t\t}\n \t\treturn module.Version{}, \"\", &ImportMissingError{Path: path, QueryErr: queryErr}\n \t}"}, {"sha": "4e09c0fb9c92e3ceaa7132be04cde28bb680bae8", "filename": "libgo/go/cmd/go/internal/vet/vet.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5decc83e4eb06103c801fd4f8215301ce746109/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvet.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5decc83e4eb06103c801fd4f8215301ce746109/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvet.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvet.go?ref=c5decc83e4eb06103c801fd4f8215301ce746109", "patch": "@@ -51,7 +51,9 @@ func runVet(cmd *base.Command, args []string) {\n \n \twork.BuildInit()\n \twork.VetFlags = vetFlags\n-\twork.VetExplicit = true\n+\tif len(vetFlags) > 0 {\n+\t\twork.VetExplicit = true\n+\t}\n \tif vetTool != \"\" {\n \t\tvar err error\n \t\twork.VetTool, err = filepath.Abs(vetTool)"}, {"sha": "209ed6861a154619cbd79d8f30fadba3a727e087", "filename": "libgo/go/cmd/go/internal/web/api.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5decc83e4eb06103c801fd4f8215301ce746109/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fapi.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5decc83e4eb06103c801fd4f8215301ce746109/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fapi.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fapi.go?ref=c5decc83e4eb06103c801fd4f8215301ce746109", "patch": "@@ -3,7 +3,7 @@\n // license that can be found in the LICENSE file.\n \n // Package web defines minimal helper routines for accessing HTTP/HTTPS\n-// resources without requiring external dependenicies on the net package.\n+// resources without requiring external dependencies on the net package.\n //\n // If the cmd_go_bootstrap build tag is present, web avoids the use of the net\n // package and returns errors for all network operations."}, {"sha": "948496241e916911e752a12fe6a0b9f491d8dd6c", "filename": "libgo/go/cmd/go/testdata/script/mod_gobuild_import.txt", "status": "modified", "additions": 48, "deletions": 11, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5decc83e4eb06103c801fd4f8215301ce746109/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_gobuild_import.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5decc83e4eb06103c801fd4f8215301ce746109/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_gobuild_import.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_gobuild_import.txt?ref=c5decc83e4eb06103c801fd4f8215301ce746109", "patch": "@@ -2,49 +2,67 @@\n \n # go/build's Import should find modules by invoking the go command\n \n-go build -o $WORK/testimport.exe ./testimport\n+go build -o $WORK ./testimport ./testfindonly\n \n # GO111MODULE=off\n env GO111MODULE=off\n-! exec $WORK/testimport.exe gobuild.example.com/x/y/z/w .\n+! exec $WORK/testimport$GOEXE gobuild.example.com/x/y/z/w .\n \n # GO111MODULE=auto in GOPATH/src\n env GO111MODULE=auto\n-exec $WORK/testimport.exe gobuild.example.com/x/y/z/w .\n+exec $WORK/testimport$GOEXE gobuild.example.com/x/y/z/w .\n \n # GO111MODULE=auto outside GOPATH/src\n cd $GOPATH/other\n env GO111MODULE=auto\n-exec $WORK/testimport.exe other/x/y/z/w .\n+exec $WORK/testimport$GOEXE other/x/y/z/w .\n stdout w2.go\n \n-! exec $WORK/testimport.exe gobuild.example.com/x/y/z/w .\n+! exec $WORK/testimport$GOEXE gobuild.example.com/x/y/z/w .\n stderr 'cannot find module providing package gobuild.example.com/x/y/z/w'\n \n cd z\n-exec $WORK/testimport.exe other/x/y/z/w .\n+exec $WORK/testimport$GOEXE other/x/y/z/w .\n stdout w2.go\n \n # GO111MODULE=on outside GOPATH/src\n env GO111MODULE=\n-exec $WORK/testimport.exe other/x/y/z/w .\n+exec $WORK/testimport$GOEXE other/x/y/z/w .\n stdout w2.go\n env GO111MODULE=on\n-exec $WORK/testimport.exe other/x/y/z/w .\n+exec $WORK/testimport$GOEXE other/x/y/z/w .\n stdout w2.go\n \n # GO111MODULE=on in GOPATH/src\n cd $GOPATH/src\n env GO111MODULE=\n-exec $WORK/testimport.exe gobuild.example.com/x/y/z/w .\n+exec $WORK/testimport$GOEXE gobuild.example.com/x/y/z/w .\n stdout w1.go\n env GO111MODULE=on\n-exec $WORK/testimport.exe gobuild.example.com/x/y/z/w .\n+exec $WORK/testimport$GOEXE gobuild.example.com/x/y/z/w .\n stdout w1.go\n cd w\n-exec $WORK/testimport.exe gobuild.example.com/x/y/z/w ..\n+exec $WORK/testimport$GOEXE gobuild.example.com/x/y/z/w ..\n stdout w1.go\n \n+# go/build's Import in FindOnly mode should find directories by invoking the go command\n+#\n+# Calling build.Import in build.FindOnly mode on an import path of a Go package\n+# that produces errors when loading (e.g., due to build constraints not matching\n+# the current build context) should return the package directory and nil error.\n+\n+# Issue 31603: Import with non-empty srcDir should work.\n+env GO111MODULE=on\n+exec $WORK/testfindonly$GOEXE gobuild.example.com/x/y/z/i $WORK\n+! stdout 'build constraints'\n+stdout '^dir=\\$WORK.+i err=<nil>$'\n+\n+# Issue 37153: Import with empty srcDir should work.\n+env GO111MODULE=on\n+exec $WORK/testfindonly$GOEXE gobuild.example.com/x/y/z/i ''\n+! stdout 'build constraints'\n+stdout '^dir=\\$WORK.+i err=<nil>$'\n+\n -- go.mod --\n module gobuild.example.com/x/y/z\n \n@@ -54,6 +72,11 @@ package z\n -- w/w1.go --\n package w\n \n+-- i/i.go --\n+// +build i\n+\n+package i\n+\n -- testimport/x.go --\n package main\n \n@@ -89,6 +112,20 @@ func main() {\n \tfmt.Printf(\"%s\\n%s\\n\", p1.Dir, strings.Join(p1.GoFiles, \" \"))\n }\n \n+-- testfindonly/x.go --\n+package main\n+\n+import (\n+\t\"fmt\"\n+\t\"go/build\"\n+\t\"os\"\n+)\n+\n+func main() {\n+\tp, err := build.Import(os.Args[1], os.Args[2], build.FindOnly)\n+\tfmt.Printf(\"dir=%s err=%v\\n\", p.Dir, err)\n+}\n+\n -- $GOPATH/other/go.mod --\n module other/x/y\n "}, {"sha": "751f6e645e11de78cb2883327118ee047b7406ab", "filename": "libgo/go/cmd/go/testdata/script/mod_readonly.txt", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5decc83e4eb06103c801fd4f8215301ce746109/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_readonly.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5decc83e4eb06103c801fd4f8215301ce746109/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_readonly.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_readonly.txt?ref=c5decc83e4eb06103c801fd4f8215301ce746109", "patch": "@@ -7,6 +7,7 @@ go mod edit -fmt\n cp go.mod go.mod.empty\n ! go list all\n stderr '^can''t load package: x.go:2:8: cannot find module providing package rsc\\.io/quote: import lookup disabled by -mod=readonly'\n+! stderr '\\(\\)' # If we don't have a reason for -mod=readonly, don't log an empty one.\n cmp go.mod go.mod.empty\n \n # -mod=readonly should be set implicitly if the go.mod file is read-only"}, {"sha": "2d790c1ac99a614262f19607d7e18ee49572babe", "filename": "libgo/go/cmd/go/testdata/script/vet_flags.txt", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5decc83e4eb06103c801fd4f8215301ce746109/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fvet_flags.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5decc83e4eb06103c801fd4f8215301ce746109/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fvet_flags.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fvet_flags.txt?ref=c5decc83e4eb06103c801fd4f8215301ce746109", "patch": "@@ -9,6 +9,17 @@ go vet -n -unreachable=false encoding/binary\n stderr '-unreachable=false'\n ! stderr '-unsafeptr=false'\n \n+# Issue 37030: \"go vet <std package>\" without other flags should disable the\n+# unsafeptr check by default.\n+go vet -n encoding/binary\n+stderr '-unsafeptr=false'\n+! stderr '-unreachable=false'\n+\n+# However, it should be enabled if requested explicitly.\n+go vet -n -unsafeptr encoding/binary\n+stderr '-unsafeptr'\n+! stderr '-unsafeptr=false'\n+\n [short] stop\n env GOCACHE=$WORK/gocache\n env GOTMPDIR=$WORK/tmp"}, {"sha": "ba0af84a9d09d6c7966476796c83f6a6bd53928b", "filename": "libgo/go/crypto/cipher/gcm.go", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5decc83e4eb06103c801fd4f8215301ce746109/libgo%2Fgo%2Fcrypto%2Fcipher%2Fgcm.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5decc83e4eb06103c801fd4f8215301ce746109/libgo%2Fgo%2Fcrypto%2Fcipher%2Fgcm.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fgcm.go?ref=c5decc83e4eb06103c801fd4f8215301ce746109", "patch": "@@ -86,7 +86,8 @@ func NewGCM(cipher Block) (AEAD, error) {\n }\n \n // NewGCMWithNonceSize returns the given 128-bit, block cipher wrapped in Galois\n-// Counter Mode, which accepts nonces of the given length.\n+// Counter Mode, which accepts nonces of the given length. The length must not\n+// be zero.\n //\n // Only use this function if you require compatibility with an existing\n // cryptosystem that uses non-standard nonce lengths. All other users should use\n@@ -112,6 +113,10 @@ func newGCMWithNonceAndTagSize(cipher Block, nonceSize, tagSize int) (AEAD, erro\n \t\treturn nil, errors.New(\"cipher: incorrect tag size given to GCM\")\n \t}\n \n+\tif nonceSize <= 0 {\n+\t\treturn nil, errors.New(\"cipher: the nonce can't have zero length, or the security of the key will be immediately compromised\")\n+\t}\n+\n \tif cipher, ok := cipher.(gcmAble); ok {\n \t\treturn cipher.NewGCM(nonceSize, tagSize)\n \t}"}, {"sha": "0d53e471f95836467bf773e7d2fef0cee7c0af83", "filename": "libgo/go/crypto/cipher/gcm_test.go", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5decc83e4eb06103c801fd4f8215301ce746109/libgo%2Fgo%2Fcrypto%2Fcipher%2Fgcm_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5decc83e4eb06103c801fd4f8215301ce746109/libgo%2Fgo%2Fcrypto%2Fcipher%2Fgcm_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fgcm_test.go?ref=c5decc83e4eb06103c801fd4f8215301ce746109", "patch": "@@ -217,6 +217,13 @@ var aesGCMTests = []struct {\n \t\t\"2b9680b886b3efb7c6354b38c63b5373\",\n \t\t\"e2b7e5ed5ff27fc8664148f5a628a46dcbf2015184fffb82f2651c36\",\n \t},\n+\t{\n+\t\t\"11754cd72aec309bf52f7687212e8957\",\n+\t\t\"\",\n+\t\t\"\",\n+\t\t\"\",\n+\t\t\"250327c674aaf477aef2675748cf6971\",\n+\t},\n }\n \n func TestAESGCM(t *testing.T) {\n@@ -234,14 +241,22 @@ func TestAESGCM(t *testing.T) {\n \n \t\tvar aesgcm cipher.AEAD\n \t\tswitch {\n-\t\t// Handle non-standard nonce sizes\n+\t\t// Handle non-standard tag sizes\n \t\tcase tagSize != 16:\n \t\t\taesgcm, err = cipher.NewGCMWithTagSize(aes, tagSize)\n \t\t\tif err != nil {\n \t\t\t\tt.Fatal(err)\n \t\t\t}\n \n-\t\t// Handle non-standard tag sizes\n+\t\t// Handle 0 nonce size (expect error and continue)\n+\t\tcase len(nonce) == 0:\n+\t\t\taesgcm, err = cipher.NewGCMWithNonceSize(aes, 0)\n+\t\t\tif err == nil {\n+\t\t\t\tt.Fatal(\"expected error for zero nonce size\")\n+\t\t\t}\n+\t\t\tcontinue\n+\n+\t\t// Handle non-standard nonce sizes\n \t\tcase len(nonce) != 12:\n \t\t\taesgcm, err = cipher.NewGCMWithNonceSize(aes, len(nonce))\n \t\t\tif err != nil {"}, {"sha": "e2f71cdb63babf2fcd72bacff4acafdcd5264b60", "filename": "libgo/go/crypto/elliptic/elliptic.go", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5decc83e4eb06103c801fd4f8215301ce746109/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5decc83e4eb06103c801fd4f8215301ce746109/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic.go?ref=c5decc83e4eb06103c801fd4f8215301ce746109", "patch": "@@ -372,23 +372,36 @@ func initP521() {\n \tp521.BitSize = 521\n }\n \n-// P256 returns a Curve which implements P-256 (see FIPS 186-3, section D.2.3)\n+// P256 returns a Curve which implements NIST P-256 (FIPS 186-3, section D.2.3),\n+// also known as secp256r1 or prime256v1. The CurveParams.Name of this Curve is\n+// \"P-256\".\n+//\n+// Multiple invocations of this function will return the same value, so it can\n+// be used for equality checks and switch statements.\n //\n // The cryptographic operations are implemented using constant-time algorithms.\n func P256() Curve {\n \tinitonce.Do(initAll)\n \treturn p256\n }\n \n-// P384 returns a Curve which implements P-384 (see FIPS 186-3, section D.2.4)\n+// P384 returns a Curve which implements NIST P-384 (FIPS 186-3, section D.2.4),\n+// also known as secp384r1. The CurveParams.Name of this Curve is \"P-384\".\n+//\n+// Multiple invocations of this function will return the same value, so it can\n+// be used for equality checks and switch statements.\n //\n // The cryptographic operations do not use constant-time algorithms.\n func P384() Curve {\n \tinitonce.Do(initAll)\n \treturn p384\n }\n \n-// P521 returns a Curve which implements P-521 (see FIPS 186-3, section D.2.5)\n+// P521 returns a Curve which implements NIST P-521 (FIPS 186-3, section D.2.5),\n+// also known as secp521r1. The CurveParams.Name of this Curve is \"P-521\".\n+//\n+// Multiple invocations of this function will return the same value, so it can\n+// be used for equality checks and switch statements.\n //\n // The cryptographic operations do not use constant-time algorithms.\n func P521() Curve {"}, {"sha": "ec4ab10c5733f54d6608e87148a2455072d560d3", "filename": "libgo/go/crypto/x509/pkcs8.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5decc83e4eb06103c801fd4f8215301ce746109/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkcs8.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5decc83e4eb06103c801fd4f8215301ce746109/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkcs8.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkcs8.go?ref=c5decc83e4eb06103c801fd4f8215301ce746109", "patch": "@@ -79,7 +79,7 @@ func ParsePKCS8PrivateKey(der []byte) (key interface{}, err error) {\n \t}\n }\n \n-// MarshalPKCS8PrivateKey converts an RSA private key to PKCS#8, ASN.1 DER form.\n+// MarshalPKCS8PrivateKey converts a private key to PKCS#8, ASN.1 DER form.\n //\n // The following key types are currently supported: *rsa.PrivateKey, *ecdsa.PrivateKey\n // and ed25519.PrivateKey. Unsupported key types result in an error."}, {"sha": "d5987dd861e06e13d41c06cd3091d821c858387f", "filename": "libgo/go/go/build/build.go", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5decc83e4eb06103c801fd4f8215301ce746109/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5decc83e4eb06103c801fd4f8215301ce746109/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go?ref=c5decc83e4eb06103c801fd4f8215301ce746109", "patch": "@@ -1017,8 +1017,6 @@ var errNoModules = errors.New(\"not using modules\")\n // Then we reinvoke it for every dependency. But this is still better than not working at all.\n // See golang.org/issue/26504.\n func (ctxt *Context) importGo(p *Package, path, srcDir string, mode ImportMode) error {\n-\tconst debugImportGo = false\n-\n \t// To invoke the go command,\n \t// we must not being doing special things like AllowBinary or IgnoreVendor,\n \t// and all the file system callbacks must be nil (we're meant to use the local file system).\n@@ -1137,15 +1135,15 @@ func (ctxt *Context) importGo(p *Package, path, srcDir string, mode ImportMode)\n \t}\n \tdir := f[0]\n \terrStr := strings.TrimSpace(f[4])\n-\tif errStr != \"\" && p.Dir == \"\" {\n-\t\t// If 'go list' could not locate the package, return the same error that\n-\t\t// 'go list' reported.\n-\t\t// If 'go list' did locate the package (p.Dir is not empty), ignore the\n-\t\t// error. It was probably related to loading source files, and we'll\n-\t\t// encounter it ourselves shortly.\n+\tif errStr != \"\" && dir == \"\" {\n+\t\t// If 'go list' could not locate the package (dir is empty),\n+\t\t// return the same error that 'go list' reported.\n \t\treturn errors.New(errStr)\n \t}\n \n+\t// If 'go list' did locate the package, ignore the error.\n+\t// It was probably related to loading source files, and we'll\n+\t// encounter it ourselves shortly if the FindOnly flag isn't set.\n \tp.Dir = dir\n \tp.ImportPath = f[1]\n \tp.Root = f[2]"}, {"sha": "79d38998e7b51164eb427dfa819049584947837f", "filename": "libgo/go/go/doc/doc.go", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5decc83e4eb06103c801fd4f8215301ce746109/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5decc83e4eb06103c801fd4f8215301ce746109/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc.go?ref=c5decc83e4eb06103c801fd4f8215301ce746109", "patch": "@@ -138,9 +138,12 @@ func New(pkg *ast.Package, importPath string, mode Mode) *Package {\n // NewFromFiles computes documentation for a package.\n //\n // The package is specified by a list of *ast.Files and corresponding\n-// file set, which must not be nil. NewFromFiles does not skip files\n-// based on build constraints, so it is the caller's responsibility to\n-// provide only the files that are matched by the build context.\n+// file set, which must not be nil.\n+// NewFromFiles uses all provided files when computing documentation,\n+// so it is the caller's responsibility to provide only the files that\n+// match the desired build context. \"go/build\".Context.MatchFile can\n+// be used for determining whether a file matches a build context with\n+// the desired GOOS and GOARCH values, and other build constraints.\n // The import path of the package is specified by importPath.\n //\n // Examples found in _test.go files are associated with the corresponding"}, {"sha": "071dc04b5489566720e0725ac631f541f4ff8a38", "filename": "libgo/go/hash/maphash/maphash.go", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5decc83e4eb06103c801fd4f8215301ce746109/libgo%2Fgo%2Fhash%2Fmaphash%2Fmaphash.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5decc83e4eb06103c801fd4f8215301ce746109/libgo%2Fgo%2Fhash%2Fmaphash%2Fmaphash.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhash%2Fmaphash%2Fmaphash.go?ref=c5decc83e4eb06103c801fd4f8215301ce746109", "patch": "@@ -5,10 +5,13 @@\n // Package maphash provides hash functions on byte sequences.\n // These hash functions are intended to be used to implement hash tables or\n // other data structures that need to map arbitrary strings or byte\n-// sequences to a uniform distribution of integers.\n+// sequences to a uniform distribution on unsigned 64-bit integers.\n //\n // The hash functions are collision-resistant but not cryptographically secure.\n // (See crypto/sha256 and crypto/sha512 for cryptographic use.)\n+//\n+// The hash value of a given byte sequence is consistent within a\n+// single process, but will be different in different processes.\n package maphash\n \n import \"unsafe\"\n@@ -66,7 +69,7 @@ type Hash struct {\n // which does call h.initSeed.)\n func (h *Hash) initSeed() {\n \tif h.seed.s == 0 {\n-\t\th.SetSeed(MakeSeed())\n+\t\th.setSeed(MakeSeed())\n \t}\n }\n \n@@ -121,12 +124,17 @@ func (h *Hash) Seed() Seed {\n // Two Hash objects with different seeds will very likely behave differently.\n // Any bytes added to h before this call will be discarded.\n func (h *Hash) SetSeed(seed Seed) {\n+\th.setSeed(seed)\n+\th.n = 0\n+}\n+\n+// setSeed sets seed without discarding accumulated data.\n+func (h *Hash) setSeed(seed Seed) {\n \tif seed.s == 0 {\n \t\tpanic(\"maphash: use of uninitialized Seed\")\n \t}\n \th.seed = seed\n \th.state = seed\n-\th.n = 0\n }\n \n // Reset discards all bytes added to h."}, {"sha": "0164a9e20ae48212c553b93d00f9efed4fa7ade2", "filename": "libgo/go/hash/maphash/maphash_test.go", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5decc83e4eb06103c801fd4f8215301ce746109/libgo%2Fgo%2Fhash%2Fmaphash%2Fmaphash_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5decc83e4eb06103c801fd4f8215301ce746109/libgo%2Fgo%2Fhash%2Fmaphash%2Fmaphash_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhash%2Fmaphash%2Fmaphash_test.go?ref=c5decc83e4eb06103c801fd4f8215301ce746109", "patch": "@@ -83,6 +83,29 @@ func TestHashHighBytes(t *testing.T) {\n \t}\n }\n \n+func TestRepeat(t *testing.T) {\n+\th1 := new(Hash)\n+\th1.WriteString(\"testing\")\n+\tsum1 := h1.Sum64()\n+\n+\th1.Reset()\n+\th1.WriteString(\"testing\")\n+\tsum2 := h1.Sum64()\n+\n+\tif sum1 != sum2 {\n+\t\tt.Errorf(\"different sum after reseting: %#x != %#x\", sum1, sum2)\n+\t}\n+\n+\th2 := new(Hash)\n+\th2.SetSeed(h1.Seed())\n+\th2.WriteString(\"testing\")\n+\tsum3 := h2.Sum64()\n+\n+\tif sum1 != sum3 {\n+\t\tt.Errorf(\"different sum on the same seed: %#x != %#x\", sum1, sum3)\n+\t}\n+}\n+\n // Make sure a Hash implements the hash.Hash and hash.Hash64 interfaces.\n var _ hash.Hash = &Hash{}\n var _ hash.Hash64 = &Hash{}"}, {"sha": "18f122e953c45a5b314d95d6fff564db02d18fe4", "filename": "libgo/go/math/big/int.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5decc83e4eb06103c801fd4f8215301ce746109/libgo%2Fgo%2Fmath%2Fbig%2Fint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5decc83e4eb06103c801fd4f8215301ce746109/libgo%2Fgo%2Fmath%2Fbig%2Fint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Fint.go?ref=c5decc83e4eb06103c801fd4f8215301ce746109", "patch": "@@ -505,8 +505,8 @@ func (z *Int) Exp(x, y, m *Int) *Int {\n // GCD sets z to the greatest common divisor of a and b and returns z.\n // If x or y are not nil, GCD sets their value such that z = a*x + b*y.\n //\n-// a and b may be positive, zero or negative.\n-// Regardless of the signs of a and b, z is always >= 0.\n+// a and b may be positive, zero or negative. (Before Go 1.14 both had\n+// to be > 0.) Regardless of the signs of a and b, z is always >= 0.\n //\n // If a == b == 0, GCD sets z = x = y = 0.\n //"}, {"sha": "266f5eba747ba09a7cee4e17526a774b47709b76", "filename": "libgo/go/runtime/malloc.go", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5decc83e4eb06103c801fd4f8215301ce746109/libgo%2Fgo%2Fruntime%2Fmalloc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5decc83e4eb06103c801fd4f8215301ce746109/libgo%2Fgo%2Fruntime%2Fmalloc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmalloc.go?ref=c5decc83e4eb06103c801fd4f8215301ce746109", "patch": "@@ -62,9 +62,10 @@\n // Allocating and freeing a large object uses the mheap\n // directly, bypassing the mcache and mcentral.\n //\n-// Free object slots in an mspan are zeroed only if mspan.needzero is\n-// false. If needzero is true, objects are zeroed as they are\n-// allocated. There are various benefits to delaying zeroing this way:\n+// If mspan.needzero is false, then free object slots in the mspan are\n+// already zeroed. Otherwise if needzero is true, objects are zeroed as\n+// they are allocated. There are various benefits to delaying zeroing\n+// this way:\n //\n //\t1. Stack frame allocation can avoid zeroing altogether.\n //"}, {"sha": "31b6f5cbac3ad1b9319dcb4fe1d3840dfcf12445", "filename": "libgo/go/runtime/mkpreempt.go", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5decc83e4eb06103c801fd4f8215301ce746109/libgo%2Fgo%2Fruntime%2Fmkpreempt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5decc83e4eb06103c801fd4f8215301ce746109/libgo%2Fgo%2Fruntime%2Fmkpreempt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmkpreempt.go?ref=c5decc83e4eb06103c801fd4f8215301ce746109", "patch": "@@ -244,6 +244,15 @@ func genAMD64() {\n \n \t// TODO: MXCSR register?\n \n+\t// Apparently, the signal handling code path in darwin kernel leaves\n+\t// the upper bits of Y registers in a dirty state, which causes\n+\t// many SSE operations (128-bit and narrower) become much slower.\n+\t// Clear the upper bits to get to a clean state. See issue #37174.\n+\t// It is safe here as Go code don't use the upper bits of Y registers.\n+\tp(\"#ifdef GOOS_darwin\")\n+\tp(\"VZEROUPPER\")\n+\tp(\"#endif\")\n+\n \tp(\"PUSHQ BP\")\n \tp(\"MOVQ SP, BP\")\n \tp(\"// Save flags before clobbering them\")"}, {"sha": "f86f2f61748ed8c78fb8b647a191f14431915c00", "filename": "libgo/go/runtime/netpoll_stub.go", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5decc83e4eb06103c801fd4f8215301ce746109/libgo%2Fgo%2Fruntime%2Fnetpoll_stub.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5decc83e4eb06103c801fd4f8215301ce746109/libgo%2Fgo%2Fruntime%2Fnetpoll_stub.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fnetpoll_stub.go?ref=c5decc83e4eb06103c801fd4f8215301ce746109", "patch": "@@ -13,16 +13,23 @@ var netpollWaiters uint32\n \n var netpollStubLock mutex\n var netpollNote note\n-var netpollBroken uint32\n+\n+// netpollBroken, protected by netpollBrokenLock, avoids a double notewakeup.\n+var netpollBrokenLock mutex\n+var netpollBroken bool\n \n func netpollGenericInit() {\n \tatomic.Store(&netpollInited, 1)\n }\n \n func netpollBreak() {\n-\tif atomic.Cas(&netpollBroken, 0, 1) {\n+\tlock(&netpollBrokenLock)\n+\tbroken := netpollBroken\n+\tnetpollBroken = true\n+\tif !broken {\n \t\tnotewakeup(&netpollNote)\n \t}\n+\tunlock(&netpollBrokenLock)\n }\n \n // Polls for ready network connections.\n@@ -34,8 +41,12 @@ func netpoll(delay int64) gList {\n \t\t// This lock ensures that only one goroutine tries to use\n \t\t// the note. It should normally be completely uncontended.\n \t\tlock(&netpollStubLock)\n+\n+\t\tlock(&netpollBrokenLock)\n \t\tnoteclear(&netpollNote)\n-\t\tatomic.Store(&netpollBroken, 0)\n+\t\tnetpollBroken = false\n+\t\tunlock(&netpollBrokenLock)\n+\n \t\tnotetsleep(&netpollNote, delay)\n \t\tunlock(&netpollStubLock)\n \t}"}, {"sha": "88ba0f024203fa70d9fb5f97f74b179b36bd5d6d", "filename": "libgo/go/testing/benchmark.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5decc83e4eb06103c801fd4f8215301ce746109/libgo%2Fgo%2Ftesting%2Fbenchmark.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5decc83e4eb06103c801fd4f8215301ce746109/libgo%2Fgo%2Ftesting%2Fbenchmark.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Fbenchmark.go?ref=c5decc83e4eb06103c801fd4f8215301ce746109", "patch": "@@ -179,6 +179,7 @@ func (b *B) ReportAllocs() {\n func (b *B) runN(n int) {\n \tbenchmarkLock.Lock()\n \tdefer benchmarkLock.Unlock()\n+\tdefer b.runCleanup(normalPanic)\n \t// Try to get a comparable environment for each run\n \t// by clearing garbage from previous runs.\n \truntime.GC()"}, {"sha": "95f8220f815fe08834e566224f67a5caee93df20", "filename": "libgo/go/testing/sub_test.go", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5decc83e4eb06103c801fd4f8215301ce746109/libgo%2Fgo%2Ftesting%2Fsub_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5decc83e4eb06103c801fd4f8215301ce746109/libgo%2Fgo%2Ftesting%2Fsub_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Fsub_test.go?ref=c5decc83e4eb06103c801fd4f8215301ce746109", "patch": "@@ -613,6 +613,46 @@ func TestBRun(t *T) {\n \t\t\t\tt.Errorf(\"MemBytes was %v; want %v\", got, 2*bufSize)\n \t\t\t}\n \t\t},\n+\t}, {\n+\t\tdesc: \"cleanup is called\",\n+\t\tf: func(b *B) {\n+\t\t\tvar calls, cleanups, innerCalls, innerCleanups int\n+\t\t\tb.Run(\"\", func(b *B) {\n+\t\t\t\tcalls++\n+\t\t\t\tb.Cleanup(func() {\n+\t\t\t\t\tcleanups++\n+\t\t\t\t})\n+\t\t\t\tb.Run(\"\", func(b *B) {\n+\t\t\t\t\tb.Cleanup(func() {\n+\t\t\t\t\t\tinnerCleanups++\n+\t\t\t\t\t})\n+\t\t\t\t\tinnerCalls++\n+\t\t\t\t})\n+\t\t\t\twork(b)\n+\t\t\t})\n+\t\t\tif calls == 0 || calls != cleanups {\n+\t\t\t\tt.Errorf(\"mismatched cleanups; got %d want %d\", cleanups, calls)\n+\t\t\t}\n+\t\t\tif innerCalls == 0 || innerCalls != innerCleanups {\n+\t\t\t\tt.Errorf(\"mismatched cleanups; got %d want %d\", cleanups, calls)\n+\t\t\t}\n+\t\t},\n+\t}, {\n+\t\tdesc:   \"cleanup is called on failure\",\n+\t\tfailed: true,\n+\t\tf: func(b *B) {\n+\t\t\tvar calls, cleanups int\n+\t\t\tb.Run(\"\", func(b *B) {\n+\t\t\t\tcalls++\n+\t\t\t\tb.Cleanup(func() {\n+\t\t\t\t\tcleanups++\n+\t\t\t\t})\n+\t\t\t\tb.Fatalf(\"failure\")\n+\t\t\t})\n+\t\t\tif calls == 0 || calls != cleanups {\n+\t\t\t\tt.Errorf(\"mismatched cleanups; got %d want %d\", cleanups, calls)\n+\t\t\t}\n+\t\t},\n \t}}\n \tfor _, tc := range testCases {\n \t\tvar ok bool"}, {"sha": "0891142d2c48ea7fe3d8b2e4aa044f714ab5f2f0", "filename": "libgo/go/testing/testing.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5decc83e4eb06103c801fd4f8215301ce746109/libgo%2Fgo%2Ftesting%2Ftesting.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5decc83e4eb06103c801fd4f8215301ce746109/libgo%2Fgo%2Ftesting%2Ftesting.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Ftesting.go?ref=c5decc83e4eb06103c801fd4f8215301ce746109", "patch": "@@ -571,7 +571,6 @@ var _ TB = (*T)(nil)\n var _ TB = (*B)(nil)\n \n // T is a type passed to Test functions to manage test state and support formatted test logs.\n-// Logs are accumulated during execution and dumped to standard output when done.\n //\n // A test ends when its Test function returns or calls any of the methods\n // FailNow, Fatal, Fatalf, SkipNow, Skip, or Skipf. Those methods, as well as"}]}