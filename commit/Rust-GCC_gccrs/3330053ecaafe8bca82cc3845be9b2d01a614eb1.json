{"sha": "3330053ecaafe8bca82cc3845be9b2d01a614eb1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzMzMDA1M2VjYWFmZThiY2E4MmNjMzg0NWJlOWIyZDAxYTYxNGViMQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2018-06-30T13:56:34Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-06-30T13:56:34Z"}, "message": "[13/n] PR85694: Try to avoid vectorising casts of invariants\n\nvect_recog_rotate_pattern had code to prevent operations\non invariants being vectorised unnecessarily:\n\n  if (dt == vect_external_def\n      && TREE_CODE (oprnd1) == SSA_NAME\n      && is_a <loop_vec_info> (vinfo))\n    {\n      struct loop *loop = as_a <loop_vec_info> (vinfo)->loop;\n      ext_def = loop_preheader_edge (loop);\n      if (!SSA_NAME_IS_DEFAULT_DEF (oprnd1))\n        {\n          basic_block bb = gimple_bb (SSA_NAME_DEF_STMT (oprnd1));\n          if (bb == NULL\n              || !dominated_by_p (CDI_DOMINATORS, ext_def->dest, bb))\n            ext_def = NULL;\n        }\n    }\n  [..]\n      if (ext_def)\n        {\n          basic_block new_bb\n            = gsi_insert_on_edge_immediate (ext_def, def_stmt);\n          gcc_assert (!new_bb);\n        }\n\nThis patch reuses the same idea for casts of invariants created\nduring widening optimisations.\n\nOne hitch was that vect_loop_versioning asserted that the vector loop\npreheader was still empty, although the cfg transformation it's doing\nshould be correct either way.\n\n2018-06-30  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-vect-patterns.c (vect_get_external_def_edge): New function,\n\tsplit out from...\n\t(vect_recog_rotate_pattern): ...here.\n\t(vect_convert_input): Try to insert casts of invariants in the\n\tpreheader.\n\t* tree-vect-loop-manip.c (vect_loop_versioning): Don't require the\n\tpreheader to be empty.\n\ngcc/testsuite/\n\t* gcc.dg/vect/vect-widen-mult-extern-1.c: New test.\n\nFrom-SVN: r262277", "tree": {"sha": "9ced16ed568b3208366e3c98d23fc84ffd77cacb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ced16ed568b3208366e3c98d23fc84ffd77cacb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3330053ecaafe8bca82cc3845be9b2d01a614eb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3330053ecaafe8bca82cc3845be9b2d01a614eb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3330053ecaafe8bca82cc3845be9b2d01a614eb1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3330053ecaafe8bca82cc3845be9b2d01a614eb1/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "003479340f5ae6b7407b5c92e3e1915101552377", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/003479340f5ae6b7407b5c92e3e1915101552377", "html_url": "https://github.com/Rust-GCC/gccrs/commit/003479340f5ae6b7407b5c92e3e1915101552377"}], "stats": {"total": 83, "additions": 68, "deletions": 15}, "files": [{"sha": "d63e3ba99b9896cbb13ccfd37b417152f9d8aa9d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3330053ecaafe8bca82cc3845be9b2d01a614eb1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3330053ecaafe8bca82cc3845be9b2d01a614eb1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3330053ecaafe8bca82cc3845be9b2d01a614eb1", "patch": "@@ -1,3 +1,13 @@\n+2018-06-30  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vect-patterns.c (vect_get_external_def_edge): New function,\n+\tsplit out from...\n+\t(vect_recog_rotate_pattern): ...here.\n+\t(vect_convert_input): Try to insert casts of invariants in the\n+\tpreheader.\n+\t* tree-vect-loop-manip.c (vect_loop_versioning): Don't require the\n+\tpreheader to be empty.\n+\n 2018-06-30  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-vect-patterns.c (append_pattern_def_seq): Take an optional"}, {"sha": "88fd3c802198a68dc9fb8a6c8ddb08068986afb9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3330053ecaafe8bca82cc3845be9b2d01a614eb1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3330053ecaafe8bca82cc3845be9b2d01a614eb1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3330053ecaafe8bca82cc3845be9b2d01a614eb1", "patch": "@@ -1,3 +1,7 @@\n+2018-06-30  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* gcc.dg/vect/vect-widen-mult-extern-1.c: New test.\n+\n 2018-06-30  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* gcc.dg/vect/vect-widen-mult-sum.c: Remove xfail."}, {"sha": "2ac3be0c242832f78e11da504c0537100d3460a9", "filename": "gcc/testsuite/gcc.dg/vect/vect-widen-mult-extern-1.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3330053ecaafe8bca82cc3845be9b2d01a614eb1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-extern-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3330053ecaafe8bca82cc3845be9b2d01a614eb1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-extern-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-extern-1.c?ref=3330053ecaafe8bca82cc3845be9b2d01a614eb1", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+\n+#define N 1024\n+\n+void\n+f (unsigned int *x1, unsigned int *x2, unsigned short *y, unsigned char z)\n+{\n+  unsigned short zu = z;\n+  for (int i = 0; i < N; ++i)\n+    {\n+      unsigned short yi = y[i];\n+      x1[i] = x1[i] > 10 ? yi * zu : x1[i] + 1;\n+      x2[i] += 1;\n+    }\n+}"}, {"sha": "01d1850276bb9d75de58452754ff03b2167e9390", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3330053ecaafe8bca82cc3845be9b2d01a614eb1/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3330053ecaafe8bca82cc3845be9b2d01a614eb1/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=3330053ecaafe8bca82cc3845be9b2d01a614eb1", "patch": "@@ -3038,8 +3038,9 @@ vect_loop_versioning (loop_vec_info loop_vinfo,\n \t while we need to move it above LOOP's preheader.  */\n       e = loop_preheader_edge (loop);\n       scalar_e = loop_preheader_edge (scalar_loop);\n-      gcc_assert (empty_block_p (e->src)\n-\t\t  && single_pred_p (e->src));\n+      /* The vector loop preheader might not be empty, since new\n+\t invariants could have been created while analyzing the loop.  */\n+      gcc_assert (single_pred_p (e->src));\n       gcc_assert (empty_block_p (scalar_e->src)\n \t\t  && single_pred_p (scalar_e->src));\n       gcc_assert (single_pred_p (condition_bb));"}, {"sha": "2b1ab7bf57580bb105d40eb5e1b8a3b58a0b382f", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 36, "deletions": 13, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3330053ecaafe8bca82cc3845be9b2d01a614eb1/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3330053ecaafe8bca82cc3845be9b2d01a614eb1/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=3330053ecaafe8bca82cc3845be9b2d01a614eb1", "patch": "@@ -123,6 +123,30 @@ new_pattern_def_seq (stmt_vec_info stmt_info, gimple *stmt)\n   append_pattern_def_seq (stmt_info, stmt);\n }\n \n+/* The caller wants to perform new operations on vect_external variable\n+   VAR, so that the result of the operations would also be vect_external.\n+   Return the edge on which the operations can be performed, if one exists.\n+   Return null if the operations should instead be treated as part of\n+   the pattern that needs them.  */\n+\n+static edge\n+vect_get_external_def_edge (vec_info *vinfo, tree var)\n+{\n+  edge e = NULL;\n+  if (loop_vec_info loop_vinfo = dyn_cast <loop_vec_info> (vinfo))\n+    {\n+      e = loop_preheader_edge (loop_vinfo->loop);\n+      if (!SSA_NAME_IS_DEFAULT_DEF (var))\n+\t{\n+\t  basic_block bb = gimple_bb (SSA_NAME_DEF_STMT (var));\n+\t  if (bb == NULL\n+\t      || !dominated_by_p (CDI_DOMINATORS, e->dest, bb))\n+\t    e = NULL;\n+\t}\n+    }\n+  return e;\n+}\n+\n /* Return true if the target supports a vector version of CODE,\n    where CODE is known to map to a direct optab.  ITYPE specifies\n    the type of (some of) the scalar inputs and OTYPE specifies the\n@@ -628,6 +652,16 @@ vect_convert_input (stmt_vec_info stmt_info, tree type,\n   tree new_op = vect_recog_temp_ssa_var (type, NULL);\n   gassign *new_stmt = gimple_build_assign (new_op, NOP_EXPR, unprom->op);\n \n+  /* If OP is an external value, see if we can insert the new statement\n+     on an incoming edge.  */\n+  if (unprom->dt == vect_external_def)\n+    if (edge e = vect_get_external_def_edge (stmt_info->vinfo, unprom->op))\n+      {\n+\tbasic_block new_bb = gsi_insert_on_edge_immediate (e, new_stmt);\n+\tgcc_assert (!new_bb);\n+\treturn new_op;\n+      }\n+\n   /* As a (common) last resort, add the statement to the pattern itself.  */\n   append_pattern_def_seq (stmt_info, new_stmt, vectype);\n   return new_op;\n@@ -1821,19 +1855,8 @@ vect_recog_rotate_pattern (vec<gimple *> *stmts, tree *type_out)\n   *type_out = vectype;\n \n   if (dt == vect_external_def\n-      && TREE_CODE (oprnd1) == SSA_NAME\n-      && is_a <loop_vec_info> (vinfo))\n-    {\n-      struct loop *loop = as_a <loop_vec_info> (vinfo)->loop;\n-      ext_def = loop_preheader_edge (loop);\n-      if (!SSA_NAME_IS_DEFAULT_DEF (oprnd1))\n-\t{\n-\t  basic_block bb = gimple_bb (SSA_NAME_DEF_STMT (oprnd1));\n-\t  if (bb == NULL\n-\t      || !dominated_by_p (CDI_DOMINATORS, ext_def->dest, bb))\n-\t    ext_def = NULL;\n-\t}\n-    }\n+      && TREE_CODE (oprnd1) == SSA_NAME)\n+    ext_def = vect_get_external_def_edge (vinfo, oprnd1);\n \n   def = NULL_TREE;\n   scalar_int_mode mode = SCALAR_INT_TYPE_MODE (type);"}]}