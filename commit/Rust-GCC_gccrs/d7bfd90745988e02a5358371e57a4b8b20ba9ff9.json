{"sha": "d7bfd90745988e02a5358371e57a4b8b20ba9ff9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDdiZmQ5MDc0NTk4OGUwMmE1MzU4MzcxZTU3YTRiOGIyMGJhOWZmOQ==", "commit": {"author": {"name": "Maxim Kuvyrkov", "email": "mkuvyrkov@ispras.ru", "date": "2006-10-06T21:49:07Z"}, "committer": {"name": "Maxim Kuvyrkov", "email": "mkuvyrkov@gcc.gnu.org", "date": "2006-10-06T21:49:07Z"}, "message": "sched-int.h (IS_SPECULATION_CHECK_P, [...]): New macros.\n\n2006-10-06  Maxim Kuvyrkov  <mkuvyrkov@ispras.ru>\n\n\t* sched-int.h (IS_SPECULATION_CHECK_P, IS_SPECULATION_SIMPLE_CHECK_P):\n\tNew macros.\n\t* sched-ebb.c (begin_schedule_ready): Use them.\n\t* haifa-sched.c (schedule_insn, move_insn, try_ready,\n\tadd_to_speculative_block, create_check_block_twin, speculate_insn,\n\tfix_jump_move, move_block_after_check): Ditto.\n\t* sched-rgn.c (new_ready): Ditto.\n\nFrom-SVN: r117516", "tree": {"sha": "60dc0f53dee19449b88f58b49e331407b4b3a60b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/60dc0f53dee19449b88f58b49e331407b4b3a60b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d7bfd90745988e02a5358371e57a4b8b20ba9ff9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7bfd90745988e02a5358371e57a4b8b20ba9ff9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7bfd90745988e02a5358371e57a4b8b20ba9ff9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7bfd90745988e02a5358371e57a4b8b20ba9ff9/comments", "author": null, "committer": null, "parents": [{"sha": "7ea84dc44cd48f9b7833248a2f0b716bbf37df2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ea84dc44cd48f9b7833248a2f0b716bbf37df2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ea84dc44cd48f9b7833248a2f0b716bbf37df2b"}], "stats": {"total": 53, "additions": 34, "deletions": 19}, "files": [{"sha": "e23ff15245fb2773eec164a18e64fabc6057fd74", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7bfd90745988e02a5358371e57a4b8b20ba9ff9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7bfd90745988e02a5358371e57a4b8b20ba9ff9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d7bfd90745988e02a5358371e57a4b8b20ba9ff9", "patch": "@@ -1,3 +1,13 @@\n+2006-10-06  Maxim Kuvyrkov  <mkuvyrkov@ispras.ru>\n+\n+\t* sched-int.h (IS_SPECULATION_CHECK_P, IS_SPECULATION_SIMPLE_CHECK_P):\n+\tNew macros.\n+\t* sched-ebb.c (begin_schedule_ready): Use them.\n+\t* haifa-sched.c (schedule_insn, move_insn, try_ready,\n+\tadd_to_speculative_block, create_check_block_twin, speculate_insn,\n+\tfix_jump_move, move_block_after_check): Ditto.\n+\t* sched-rgn.c (new_ready): Ditto.\n+\n 2006-10-06  Maxim Kuvyrkov  <mkuvyrkov@ispras.ru>\n \n \tPR rtl-optimization/29128"}, {"sha": "ebe7f24ebb53466468e4a536d42936e471449e80", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7bfd90745988e02a5358371e57a4b8b20ba9ff9/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7bfd90745988e02a5358371e57a4b8b20ba9ff9/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=d7bfd90745988e02a5358371e57a4b8b20ba9ff9", "patch": "@@ -1190,8 +1190,7 @@ schedule_insn (rtx insn)\n \n       resolve_dep (next, insn);\n \n-      if (!RECOVERY_BLOCK (insn)\n-\t  || RECOVERY_BLOCK (insn) == EXIT_BLOCK_PTR)\n+      if (!IS_SPECULATION_BRANCHY_CHECK_P (insn))\n \t{\n \t  int effective_cost;      \n \t  \n@@ -1960,8 +1959,7 @@ move_insn (rtx insn)\n \n \t  gcc_assert (!jump_p\n \t\t      || ((current_sched_info->flags & SCHED_RGN)\n-\t\t\t  && RECOVERY_BLOCK (insn)\n-\t\t\t  && RECOVERY_BLOCK (insn) != EXIT_BLOCK_PTR)\n+\t\t\t  && IS_SPECULATION_BRANCHY_CHECK_P (insn))\n \t\t      || (current_sched_info->flags & SCHED_EBB));\n \t  \n \t  gcc_assert (BLOCK_FOR_INSN (PREV_INSN (insn)) == bb);\n@@ -3115,8 +3113,7 @@ try_ready (rtx next)\n      or we simply don't care (*ts & HARD_DEP).  */\n   \n   gcc_assert (!ORIG_PAT (next)\n-\t      || !RECOVERY_BLOCK (next)\n-\t      || RECOVERY_BLOCK (next) == EXIT_BLOCK_PTR);\n+\t      || !IS_SPECULATION_BRANCHY_CHECK_P (next));\n   \n   if (*ts & HARD_DEP)\n     {\n@@ -3128,11 +3125,11 @@ try_ready (rtx next)\n       change_queue_index (next, QUEUE_NOWHERE);\n       return -1;\n     }\n-  else if (!(*ts & BEGIN_SPEC) && ORIG_PAT (next) && !RECOVERY_BLOCK (next))\n+  else if (!(*ts & BEGIN_SPEC) && ORIG_PAT (next) && !IS_SPECULATION_CHECK_P (next))\n     /* We should change pattern of every previously speculative \n        instruction - and we determine if NEXT was speculative by using\n-       ORIG_PAT field.  Except one case - simple checks have ORIG_PAT\n-       pat too, hence we also check for the RECOVERY_BLOCK.  */\n+       ORIG_PAT field.  Except one case - speculation checks have ORIG_PAT\n+       pat too, so skip them.  */\n     {\n       change_pattern (next, ORIG_PAT (next));\n       ORIG_PAT (next) = 0;\n@@ -3444,7 +3441,7 @@ add_to_speculative_block (rtx insn)\n \n       check = XEXP (link, 0);\n \n-      if (RECOVERY_BLOCK (check))\n+      if (IS_SPECULATION_SIMPLE_CHECK_P (check))\n \t{\n \t  create_check_block_twin (check, true);\n \t  link = LOG_LINKS (insn);\n@@ -3466,7 +3463,8 @@ add_to_speculative_block (rtx insn)\n \t\t  && (DEP_STATUS (link) & DEP_TYPES) == DEP_TRUE);\n \n       check = XEXP (link, 0);\n-      gcc_assert (!RECOVERY_BLOCK (check) && !ORIG_PAT (check)\n+\n+      gcc_assert (!IS_SPECULATION_CHECK_P (check) && !ORIG_PAT (check)\n \t\t  && QUEUE_INDEX (check) == QUEUE_NOWHERE);\n       \n       rec = BLOCK_FOR_INSN (check);\n@@ -3718,7 +3716,7 @@ create_check_block_twin (rtx insn, bool mutate_p)\n \n   gcc_assert (ORIG_PAT (insn)\n \t      && (!mutate_p \n-\t\t  || (RECOVERY_BLOCK (insn) == EXIT_BLOCK_PTR\n+\t\t  || (IS_SPECULATION_SIMPLE_CHECK_P (insn)\n \t\t      && !(TODO_SPEC (insn) & SPECULATIVE))));\n \n   /* Create recovery block.  */\n@@ -4091,7 +4089,7 @@ speculate_insn (rtx insn, ds_t request, rtx *new_pat)\n       || (request & spec_info->mask) != request)    \n     return -1;\n   \n-  gcc_assert (!RECOVERY_BLOCK (insn));\n+  gcc_assert (!IS_SPECULATION_CHECK_P (insn));\n \n   if (request & BE_IN_SPEC)\n     {            \n@@ -4299,8 +4297,7 @@ fix_jump_move (rtx jump)\n   jump_bb_next = jump_bb->next_bb;\n \n   gcc_assert (current_sched_info->flags & SCHED_EBB\n-\t      || (RECOVERY_BLOCK (jump)\n-\t\t  && RECOVERY_BLOCK (jump) != EXIT_BLOCK_PTR));\n+\t      || IS_SPECULATION_BRANCHY_CHECK_P (jump));\n   \n   if (!NOTE_INSN_BASIC_BLOCK_P (BB_END (jump_bb_next)))\n     /* if jump_bb_next is not empty.  */\n@@ -4333,8 +4330,8 @@ move_block_after_check (rtx jump)\n   \n   update_bb_for_insn (jump_bb);\n   \n-  gcc_assert (RECOVERY_BLOCK (jump)\n-\t      || RECOVERY_BLOCK (BB_END (jump_bb_next)));\n+  gcc_assert (IS_SPECULATION_CHECK_P (jump)\n+\t      || IS_SPECULATION_CHECK_P (BB_END (jump_bb_next)));\n \n   unlink_block (jump_bb_next);\n   link_block (jump_bb_next, bb);"}, {"sha": "b2e82b591824c180c95c2b3187c4fddbc47e488a", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7bfd90745988e02a5358371e57a4b8b20ba9ff9/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7bfd90745988e02a5358371e57a4b8b20ba9ff9/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=d7bfd90745988e02a5358371e57a4b8b20ba9ff9", "patch": "@@ -145,7 +145,7 @@ begin_schedule_ready (rtx insn, rtx last)\n       gcc_assert (!e || !(e->flags & EDGE_COMPLEX));\t    \n \n       gcc_assert (BLOCK_FOR_INSN (insn) == last_bb\n-\t\t  && !RECOVERY_BLOCK (insn)\n+\t\t  && !IS_SPECULATION_CHECK_P (insn)\n \t\t  && BB_HEAD (last_bb) != insn\n \t\t  && BB_END (last_bb) == insn);\n "}, {"sha": "ab9147803646a2d08e552fbb1aaf14456fa37fcd", "filename": "gcc/sched-int.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7bfd90745988e02a5358371e57a4b8b20ba9ff9/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7bfd90745988e02a5358371e57a4b8b20ba9ff9/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=d7bfd90745988e02a5358371e57a4b8b20ba9ff9", "patch": "@@ -359,6 +359,14 @@ extern regset *glat_start, *glat_end;\n #define RECOVERY_BLOCK(INSN)    (h_i_d[INSN_UID (INSN)].recovery_block)\n #define ORIG_PAT(INSN)          (h_i_d[INSN_UID (INSN)].orig_pat)\n \n+/* INSN is either a simple or a branchy speculation check.  */\n+#define IS_SPECULATION_CHECK_P(INSN) (RECOVERY_BLOCK (INSN) != NULL)\n+\n+/* INSN is a speculation check that will simply reexecute the speculatively\n+   scheduled instruction if the speculation fail.  */\n+#define IS_SPECULATION_SIMPLE_CHECK_P(INSN) \\\n+  (RECOVERY_BLOCK (INSN) == EXIT_BLOCK_PTR)\n+\n /* INSN is a speculation check that will branch to RECOVERY_BLOCK if the\n    speculation fail.  Insns in that block will reexecute the speculatively\n    scheduled code and then will return immediatelly after INSN thus preserving"}, {"sha": "4c9c0dec2c26af1a181274c7733c35ccf81420bd", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7bfd90745988e02a5358371e57a4b8b20ba9ff9/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7bfd90745988e02a5358371e57a4b8b20ba9ff9/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=d7bfd90745988e02a5358371e57a4b8b20ba9ff9", "patch": "@@ -2089,7 +2089,7 @@ new_ready (rtx next, ds_t ts)\n \t      && ((recog_memoized (next) >= 0\n \t\t   && min_insn_conflict_delay (curr_state, next, next) \n                    > PARAM_VALUE (PARAM_MAX_SCHED_INSN_CONFLICT_DELAY))\n-                  || RECOVERY_BLOCK (next)\n+                  || IS_SPECULATION_CHECK_P (next)\n \t\t  || !check_live (next, INSN_BB (next))\n \t\t  || (not_ex_free = !is_exception_free (next, INSN_BB (next),\n \t\t\t\t\t\t\ttarget_bb)))))"}]}