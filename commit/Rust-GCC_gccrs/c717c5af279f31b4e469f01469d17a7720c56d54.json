{"sha": "c717c5af279f31b4e469f01469d17a7720c56d54", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzcxN2M1YWYyNzlmMzFiNGU0NjlmMDE0NjlkMTdhNzcyMGM1NmQ1NA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2003-03-30T22:30:54Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2003-03-30T22:30:54Z"}, "message": "re PR c++/7647 (ICE when data member has the name of the enclosing class)\n\n\tPR c++/7647\n\t* decl.c (grokdeclarator): Tidy, slightly.\n\t* search.c (lookup_field_1): Add want_type parameter.\n\t(lookup_field_r): Adjust call to lookup_field_1.\n\n\tPR c++/7647\n\t* g++.dg/lookup-class-member-2.C: New test.\n\nFrom-SVN: r65057", "tree": {"sha": "c662afcd8166ca7d165f9e1bd25793596732a999", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c662afcd8166ca7d165f9e1bd25793596732a999"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c717c5af279f31b4e469f01469d17a7720c56d54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c717c5af279f31b4e469f01469d17a7720c56d54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c717c5af279f31b4e469f01469d17a7720c56d54", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c717c5af279f31b4e469f01469d17a7720c56d54/comments", "author": null, "committer": null, "parents": [{"sha": "ececa172241797d42e5f98652b54fdd0d00e23d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ececa172241797d42e5f98652b54fdd0d00e23d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ececa172241797d42e5f98652b54fdd0d00e23d9"}], "stats": {"total": 80, "additions": 55, "deletions": 25}, "files": [{"sha": "93df69d34a70fa7632f924828f84deb563d5f320", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c717c5af279f31b4e469f01469d17a7720c56d54/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c717c5af279f31b4e469f01469d17a7720c56d54/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c717c5af279f31b4e469f01469d17a7720c56d54", "patch": "@@ -1,3 +1,10 @@\n+2003-03-30  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/7647\n+\t* decl.c (grokdeclarator): Tidy, slightly.\n+\t* search.c (lookup_field_1): Add want_type parameter.\n+\t(lookup_field_r): Adjust call to lookup_field_1.\n+\n 2003-03-30  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n \n \t* Make-lang.in (cp/name-lookup.o): Add more dependencies."}, {"sha": "e2dc018a23a4bea1f79079bd26372db089836338", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c717c5af279f31b4e469f01469d17a7720c56d54/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c717c5af279f31b4e469f01469d17a7720c56d54/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=c717c5af279f31b4e469f01469d17a7720c56d54", "patch": "@@ -11551,18 +11551,15 @@ grokdeclarator (tree declarator,\n \t\t  return void_type_node;\n \t      }\n \n-\t    /* 9.2p13 [class.mem] */\n-\t    if (constructor_name_p (declarator, current_class_type)\n-\t\t/* The standard does not allow non-static data members\n-\t\t   here either, but we agreed at the 10/99 meeting\n-\t\t   to change that in TC 1 so that they are allowed in\n-\t\t   classes with no user-defined constructors.  */\n-\t\t&& staticp)\n-\t      pedwarn (\"ISO C++ forbids static data member `%D' with same name as enclosing class\",\n-\t\t\t  declarator);\n-\n \t    if (staticp)\n \t      {\n+\t\t/* [class.mem] forbids static data members with the\n+\t\t   same name as the enclosing class.  Non-static data\n+\t\t   members are checked in check_field_decls.  */\n+\t\tif (constructor_name_p (declarator, current_class_type))\n+\t\t  pedwarn (\"ISO C++ forbids static data member `%D' with same name as enclosing class\",\n+\t\t\t   declarator);\n+\t\t  \n \t\t/* C++ allows static class members.  All other work\n \t\t   for this is done by grokfield.  */\n \t\tdecl = build_lang_decl (VAR_DECL, declarator, type);"}, {"sha": "9fc84311d38d45ba25f9841ad13cdf180671f632", "filename": "gcc/cp/search.c", "status": "modified", "additions": 29, "deletions": 15, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c717c5af279f31b4e469f01469d17a7720c56d54/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c717c5af279f31b4e469f01469d17a7720c56d54/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=c717c5af279f31b4e469f01469d17a7720c56d54", "patch": "@@ -81,7 +81,7 @@ struct vbase_info\n   tree inits;\n };\n \n-static tree lookup_field_1 (tree, tree);\n+static tree lookup_field_1 (tree, tree, bool);\n static tree dfs_check_overlap (tree, void *);\n static tree dfs_no_overlap_yet (tree, int, void *);\n static base_kind lookup_base_r (tree, tree, base_access,\n@@ -420,17 +420,18 @@ get_dynamic_cast_base_type (tree subtype, tree target)\n   return offset;\n }\n \n-/* Search for a member with name NAME in a multiple inheritance lattice\n-   specified by TYPE.  If it does not exist, return NULL_TREE.\n+/* Search for a member with name NAME in a multiple inheritance\n+   lattice specified by TYPE.  If it does not exist, return NULL_TREE.\n    If the member is ambiguously referenced, return `error_mark_node'.\n-   Otherwise, return the FIELD_DECL.  */\n+   Otherwise, return a DECL with the indicated name.  If WANT_TYPE is\n+   true, type declarations are preferred.  */\n \n /* Do a 1-level search for NAME as a member of TYPE.  The caller must\n    figure out whether it can access this field.  (Since it is only one\n    level, this is reasonable.)  */\n \n static tree\n-lookup_field_1 (tree type, tree name)\n+lookup_field_1 (tree type, tree name, bool want_type)\n {\n   register tree field;\n \n@@ -467,14 +468,24 @@ lookup_field_1 (tree type, tree name)\n \t    lo = i + 1;\n \t  else\n \t    {\n+\t      field = NULL_TREE;\n+\n \t      /* We might have a nested class and a field with the\n \t\t same name; we sorted them appropriately via\n \t\t field_decl_cmp, so just look for the last field with\n \t\t this name.  */\n-\t      while (i + 1 < hi\n-\t\t     && DECL_NAME (fields[i+1]) == name)\n-\t\t++i;\n-\t      return fields[i];\n+\t      while (true)\n+\t\t{\n+\t\t  if (!want_type \n+\t\t      || TREE_CODE (fields[i]) == TYPE_DECL\n+\t\t      || DECL_CLASS_TEMPLATE_P (fields[i]))\n+\t\t    field = fields[i];\n+\t\t  if (i + 1 == hi || DECL_NAME (fields[i+1]) != name)\n+\t\t    break;\n+\t\t  i++;\n+\t\t}\n+\n+\t      return field;\n \t    }\n \t}\n       return NULL_TREE;\n@@ -485,7 +496,7 @@ lookup_field_1 (tree type, tree name)\n #ifdef GATHER_STATISTICS\n   n_calls_lookup_field_1++;\n #endif /* GATHER_STATISTICS */\n-  while (field)\n+  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n     {\n #ifdef GATHER_STATISTICS\n       n_fields_searched++;\n@@ -494,7 +505,7 @@ lookup_field_1 (tree type, tree name)\n       if (DECL_NAME (field) == NULL_TREE\n \t  && ANON_AGGR_TYPE_P (TREE_TYPE (field)))\n \t{\n-\t  tree temp = lookup_field_1 (TREE_TYPE (field), name);\n+\t  tree temp = lookup_field_1 (TREE_TYPE (field), name, want_type);\n \t  if (temp)\n \t    return temp;\n \t}\n@@ -504,10 +515,13 @@ lookup_field_1 (tree type, tree name)\n \t   to return a USING_DECL, and the rest of the compiler can't\n \t   handle it.  Once the class is defined, these are purged\n \t   from TYPE_FIELDS anyhow; see handle_using_decl.  */\n-\t;\n-      else if (DECL_NAME (field) == name)\n+\tcontinue;\n+\n+      if (DECL_NAME (field) == name\n+\t  && (!want_type \n+\t      || TREE_CODE (field) == TYPE_DECL\n+\t      || DECL_CLASS_TEMPLATE_P (field)))\n \treturn field;\n-      field = TREE_CHAIN (field);\n     }\n   /* Not found.  */\n   if (name == vptr_identifier)\n@@ -1079,7 +1093,7 @@ lookup_field_r (tree binfo, void *data)\n \n   if (!nval)\n     /* Look for a data member or type.  */\n-    nval = lookup_field_1 (type, lfi->name);\n+    nval = lookup_field_1 (type, lfi->name, lfi->want_type);\n \n   /* If there is no declaration with the indicated name in this type,\n      then there's nothing to do.  */"}, {"sha": "1eb28366e537b987f1f5728f9406f609c932f796", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c717c5af279f31b4e469f01469d17a7720c56d54/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c717c5af279f31b4e469f01469d17a7720c56d54/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c717c5af279f31b4e469f01469d17a7720c56d54", "patch": "@@ -1,3 +1,8 @@\n+2003-03-30  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/7647\n+\t* g++.dg/lookup-class-member-2.C: New test.\n+\n 2003-03-30  Glen Nakamura  <glen@imodulo.com>\n \n         * gcc.dg/20030324-1.c: Add comments and abort if test fails."}, {"sha": "8e4dbe72d7ad9f0405756bc33f6c2fbebd55c6a2", "filename": "gcc/testsuite/g++.dg/lookup/class-member-2.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c717c5af279f31b4e469f01469d17a7720c56d54/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fclass-member-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c717c5af279f31b4e469f01469d17a7720c56d54/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fclass-member-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fclass-member-2.C?ref=c717c5af279f31b4e469f01469d17a7720c56d54", "patch": "@@ -0,0 +1,7 @@\n+template <typename T> struct A\n+{\n+  void foo () const {}\n+  char A;\n+};\n+\n+void bar() { A<void>().foo(); }"}]}