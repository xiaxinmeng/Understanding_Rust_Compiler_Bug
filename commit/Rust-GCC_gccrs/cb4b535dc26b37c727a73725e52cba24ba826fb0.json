{"sha": "cb4b535dc26b37c727a73725e52cba24ba826fb0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2I0YjUzNWRjMjZiMzdjNzI3YTczNzI1ZTUyY2JhMjRiYTgyNmZiMA==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2000-07-03T15:06:12Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2000-07-03T15:06:12Z"}, "message": "fp-bit.h: New file.\n\n\t* fp-bit.h: New file.\n\n\t* fp-bit.c: Move common code, prototypes, etc into fp-bit.h.\n\tComment #endif statements.\n\t(__thenan_sf, __thenan_df): Add missing braces around initializer.\n\nFrom-SVN: r34844", "tree": {"sha": "10808bc00c8747aab9a1d6cd1497e028adfa74e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/10808bc00c8747aab9a1d6cd1497e028adfa74e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb4b535dc26b37c727a73725e52cba24ba826fb0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb4b535dc26b37c727a73725e52cba24ba826fb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb4b535dc26b37c727a73725e52cba24ba826fb0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb4b535dc26b37c727a73725e52cba24ba826fb0/comments", "author": null, "committer": null, "parents": [{"sha": "d9b531423e1dda0ae17f0b7dfc81dedd17afacac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9b531423e1dda0ae17f0b7dfc81dedd17afacac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9b531423e1dda0ae17f0b7dfc81dedd17afacac"}], "stats": {"total": 762, "additions": 446, "deletions": 316}, "files": [{"sha": "04e7c145726adfa6ca8e4ba7435772e44f91a6aa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb4b535dc26b37c727a73725e52cba24ba826fb0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb4b535dc26b37c727a73725e52cba24ba826fb0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cb4b535dc26b37c727a73725e52cba24ba826fb0", "patch": "@@ -1,3 +1,11 @@\n+2000-07-03  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* fp-bit.h: New file.\n+\n+\t* fp-bit.c: Move common code, prototypes, etc into fp-bit.h.\n+\tComment #endif statements.\n+\t(__thenan_sf, __thenan_df): Add missing braces around initializer.\n+\n Mon Jul  3 00:32:47 2000  Jeffrey A Law  (law@cygnus.com)\n \n \t* gcse.c (compute_pre_data): Compute ae_kill using other local"}, {"sha": "70a3f254ccdc1ed91ecd02d873b6c01a66ee7c6b", "filename": "gcc/config/fp-bit.c", "status": "modified", "additions": 29, "deletions": 316, "changes": 345, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb4b535dc26b37c727a73725e52cba24ba826fb0/gcc%2Fconfig%2Ffp-bit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb4b535dc26b37c727a73725e52cba24ba826fb0/gcc%2Fconfig%2Ffp-bit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffp-bit.c?ref=cb4b535dc26b37c727a73725e52cba24ba826fb0", "patch": "@@ -44,61 +44,7 @@ Boston, MA 02111-1307, USA.  */\n /* The intended way to use this file is to make two copies, add `#define FLOAT'\n    to one copy, then compile both copies and add them to libgcc.a.  */\n \n-/* Defining FINE_GRAINED_LIBRARIES allows one to select which routines\n-   from this file are compiled via additional -D options.\n-\n-   This avoids the need to pull in the entire fp emulation library\n-   when only a small number of functions are needed.\n-\n-   If FINE_GRAINED_LIBRARIES is not defined, then compile every \n-   suitable routine.  */\n-#ifndef FINE_GRAINED_LIBRARIES\n-#define L_pack_df\n-#define L_unpack_df\n-#define L_pack_sf\n-#define L_unpack_sf\n-#define L_addsub_sf\n-#define L_addsub_df\n-#define L_mul_sf\n-#define L_mul_df\n-#define L_div_sf\n-#define L_div_df\n-#define L_fpcmp_parts_sf\n-#define L_fpcmp_parts_df\n-#define L_compare_sf\n-#define L_compare_df\n-#define L_eq_sf\n-#define L_eq_df\n-#define L_ne_sf\n-#define L_ne_df\n-#define L_gt_sf\n-#define L_gt_df\n-#define L_ge_sf\n-#define L_ge_df\n-#define L_lt_sf\n-#define L_lt_df\n-#define L_le_sf\n-#define L_le_df\n-#define L_unord_sf\n-#define L_unord_df\n-#define L_si_to_sf\n-#define L_si_to_df\n-#define L_sf_to_si\n-#define L_df_to_si\n-#define L_f_to_usi\n-#define L_df_to_usi\n-#define L_negate_sf\n-#define L_negate_df\n-#define L_make_sf\n-#define L_make_df\n-#define L_sf_to_df\n-#define L_df_to_sf\n-#ifdef FLOAT\n-#define L_thenan_sf\n-#else\n-#define L_thenan_df\n-#endif\n-#endif\n+#include \"fp-bit.h\"\n \n /* The following macros can be defined to change the behaviour of this file:\n    FLOAT: Implement a `float', aka SFmode, fp library.  If this is not\n@@ -164,233 +110,6 @@ __fixxfsi (){ abort(); }\n __floatsixf (){ abort(); }\n #else\t/* !EXTENDED_FLOAT_STUBS, rest of file */\n \n-\n-typedef float SFtype __attribute__ ((mode (SF)));\n-typedef float DFtype __attribute__ ((mode (DF)));\n-\n-typedef int HItype __attribute__ ((mode (HI)));\n-typedef int SItype __attribute__ ((mode (SI)));\n-typedef int DItype __attribute__ ((mode (DI)));\n-\n-/* The type of the result of a fp compare */\n-#ifndef CMPtype\n-#define CMPtype SItype\n-#endif\n-\n-typedef unsigned int UHItype __attribute__ ((mode (HI)));\n-typedef unsigned int USItype __attribute__ ((mode (SI)));\n-typedef unsigned int UDItype __attribute__ ((mode (DI)));\n-\n-#define MAX_SI_INT   ((SItype) ((unsigned) (~0)>>1))\n-#define MAX_USI_INT  ((USItype) ~0)\n-\n-\n-#ifdef FLOAT_ONLY\n-#define NO_DI_MODE\n-#endif\n-\n-#ifdef FLOAT\n-#\tdefine NGARDS    7L\n-#\tdefine GARDROUND 0x3f\n-#\tdefine GARDMASK  0x7f\n-#\tdefine GARDMSB   0x40\n-#\tdefine EXPBITS 8\n-#\tdefine EXPBIAS 127\n-#\tdefine FRACBITS 23\n-#\tdefine EXPMAX (0xff)\n-#\tdefine QUIET_NAN 0x100000L\n-#\tdefine FRAC_NBITS 32\n-#\tdefine FRACHIGH  0x80000000L\n-#\tdefine FRACHIGH2 0xc0000000L\n-#\tdefine pack_d __pack_f\n-#\tdefine unpack_d __unpack_f\n-#\tdefine __fpcmp_parts __fpcmp_parts_f\n-\ttypedef USItype fractype;\n-\ttypedef UHItype halffractype;\n-\ttypedef SFtype FLO_type;\n-\ttypedef SItype intfrac;\n-\n-#else\n-#\tdefine PREFIXFPDP dp\n-#\tdefine PREFIXSFDF df\n-#\tdefine NGARDS 8L\n-#\tdefine GARDROUND 0x7f\n-#\tdefine GARDMASK  0xff\n-#\tdefine GARDMSB   0x80\n-#\tdefine EXPBITS 11\n-#\tdefine EXPBIAS 1023\n-#\tdefine FRACBITS 52\n-#\tdefine EXPMAX (0x7ff)\n-#\tdefine QUIET_NAN 0x8000000000000LL\n-#\tdefine FRAC_NBITS 64\n-#\tdefine FRACHIGH  0x8000000000000000LL\n-#\tdefine FRACHIGH2 0xc000000000000000LL\n-#\tdefine pack_d __pack_d\n-#\tdefine unpack_d __unpack_d\n-#\tdefine __fpcmp_parts __fpcmp_parts_d\n-\ttypedef UDItype fractype;\n-\ttypedef USItype halffractype;\n-\ttypedef DFtype FLO_type;\n-\ttypedef DItype intfrac;\n-#endif\n-\n-#ifdef US_SOFTWARE_GOFAST\n-#\tifdef FLOAT\n-#\t\tdefine add \t\tfpadd\n-#\t\tdefine sub \t\tfpsub\n-#\t\tdefine multiply \tfpmul\n-#\t\tdefine divide \t\tfpdiv\n-#\t\tdefine compare \t\tfpcmp\n-#\t\tdefine si_to_float \tsitofp\n-#\t\tdefine float_to_si \tfptosi\n-#\t\tdefine float_to_usi \tfptoui\n-#\t\tdefine negate \t\t__negsf2\n-#\t\tdefine sf_to_df\t\tfptodp\n-#\t\tdefine dptofp \t\tdptofp\n-#else\n-#\t\tdefine add \t\tdpadd\n-#\t\tdefine sub \t\tdpsub\n-#\t\tdefine multiply \tdpmul\n-#\t\tdefine divide \t\tdpdiv\n-#\t\tdefine compare \t\tdpcmp\n-#\t\tdefine si_to_float \tlitodp\n-#\t\tdefine float_to_si \tdptoli\n-#\t\tdefine float_to_usi \tdptoul\n-#\t\tdefine negate \t\t__negdf2\n-#\t\tdefine df_to_sf \tdptofp\n-#endif\n-#else\n-#\tifdef FLOAT\n-#\t\tdefine add \t\t__addsf3\n-#\t\tdefine sub \t\t__subsf3\n-#\t\tdefine multiply \t__mulsf3\n-#\t\tdefine divide \t\t__divsf3\n-#\t\tdefine compare \t\t__cmpsf2\n-#\t\tdefine _eq_f2 \t\t__eqsf2\n-#\t\tdefine _ne_f2 \t\t__nesf2\n-#\t\tdefine _gt_f2 \t\t__gtsf2\n-#\t\tdefine _ge_f2 \t\t__gesf2\n-#\t\tdefine _lt_f2 \t\t__ltsf2\n-#\t\tdefine _le_f2 \t\t__lesf2\n-#\t\tdefine _unord_f2\t__unordsf2\n-#\t\tdefine si_to_float \t__floatsisf\n-#\t\tdefine float_to_si \t__fixsfsi\n-#\t\tdefine float_to_usi \t__fixunssfsi\n-#\t\tdefine negate \t\t__negsf2\n-#\t\tdefine sf_to_df\t\t__extendsfdf2\n-#else\n-#\t\tdefine add \t\t__adddf3\n-#\t\tdefine sub \t\t__subdf3\n-#\t\tdefine multiply \t__muldf3\n-#\t\tdefine divide \t\t__divdf3\n-#\t\tdefine compare \t\t__cmpdf2\n-#\t\tdefine _eq_f2 \t\t__eqdf2\n-#\t\tdefine _ne_f2 \t\t__nedf2\n-#\t\tdefine _gt_f2 \t\t__gtdf2\n-#\t\tdefine _ge_f2 \t\t__gedf2\n-#\t\tdefine _lt_f2 \t\t__ltdf2\n-#\t\tdefine _le_f2 \t\t__ledf2\n-#\t\tdefine _unord_f2\t__unorddf2\n-#\t\tdefine si_to_float \t__floatsidf\n-#\t\tdefine float_to_si \t__fixdfsi\n-#\t\tdefine float_to_usi \t__fixunsdfsi\n-#\t\tdefine negate \t\t__negdf2\n-#\t\tdefine df_to_sf\t\t__truncdfsf2\n-#\tendif\n-#endif\n-\n-\n-#ifndef INLINE\n-#define INLINE __inline__\n-#endif\n-\n-/* Preserve the sticky-bit when shifting fractions to the right.  */\n-#define LSHIFT(a) { a = (a & 1) | (a >> 1); }\n-\n-/* numeric parameters */\n-/* F_D_BITOFF is the number of bits offset between the MSB of the mantissa\n-   of a float and of a double. Assumes there are only two float types.\n-   (double::FRAC_BITS+double::NGARDS-(float::FRAC_BITS-float::NGARDS))\n- */\n-#define F_D_BITOFF (52+8-(23+7))\n-\n-\n-#define NORMAL_EXPMIN (-(EXPBIAS)+1)\n-#define IMPLICIT_1 (1LL<<(FRACBITS+NGARDS))\n-#define IMPLICIT_2 (1LL<<(FRACBITS+1+NGARDS))\n-\n-/* common types */\n-\n-typedef enum\n-{\n-  CLASS_SNAN,\n-  CLASS_QNAN,\n-  CLASS_ZERO,\n-  CLASS_NUMBER,\n-  CLASS_INFINITY\n-} fp_class_type;\n-\n-typedef struct\n-{\n-#ifdef SMALL_MACHINE\n-  char class;\n-  unsigned char sign;\n-  short normal_exp;\n-#else\n-  fp_class_type class;\n-  unsigned int sign;\n-  int normal_exp;\n-#endif\n-\n-  union\n-    {\n-      fractype ll;\n-      halffractype l[2];\n-    } fraction;\n-} fp_number_type;\n-\n-typedef union\n-{\n-  FLO_type value;\n-  fractype value_raw;\n-\n-#ifndef FLOAT\n-  halffractype words[2];\n-#endif\n-\n-#ifdef FLOAT_BIT_ORDER_MISMATCH\n-  struct\n-    {\n-      fractype fraction:FRACBITS __attribute__ ((packed));\n-      unsigned int exp:EXPBITS __attribute__ ((packed));\n-      unsigned int sign:1 __attribute__ ((packed));\n-    }\n-  bits;\n-#endif\n-\n-#ifdef _DEBUG_BITFLOAT\n-  struct\n-    {\n-      unsigned int sign:1 __attribute__ ((packed));\n-      unsigned int exp:EXPBITS __attribute__ ((packed));\n-      fractype fraction:FRACBITS __attribute__ ((packed));\n-    }\n-  bits_big_endian;\n-\n-  struct\n-    {\n-      fractype fraction:FRACBITS __attribute__ ((packed));\n-      unsigned int exp:EXPBITS __attribute__ ((packed));\n-      unsigned int sign:1 __attribute__ ((packed));\n-    }\n-  bits_little_endian;\n-#endif\n-}\n-FLO_union_type;\n-\n-\n-/* end of header */\n-\n /* IEEE \"special\" number predicates */\n \n #ifdef NO_NANS\n@@ -401,9 +120,9 @@ FLO_union_type;\n #else\n \n #if   defined L_thenan_sf\n-const fp_number_type __thenan_sf = { CLASS_SNAN, 0, 0, (fractype) 0 };\n+const fp_number_type __thenan_sf = { CLASS_SNAN, 0, 0, {(fractype) 0} };\n #elif defined L_thenan_df\n-const fp_number_type __thenan_df = { CLASS_SNAN, 0, 0, (fractype) 0 };\n+const fp_number_type __thenan_df = { CLASS_SNAN, 0, 0, {(fractype) 0} };\n #elif defined FLOAT\n extern const fp_number_type __thenan_sf;\n #else\n@@ -412,7 +131,7 @@ extern const fp_number_type __thenan_df;\n \n INLINE\n static fp_number_type *\n-nan ()\n+nan (void)\n {\n   /* Discard the const qualifier... */\n #ifdef FLOAT  \n@@ -436,7 +155,7 @@ isinf ( fp_number_type *  x)\n   return x->class == CLASS_INFINITY;\n }\n \n-#endif\n+#endif /* NO_NANS */\n \n INLINE\n static int\n@@ -580,8 +299,6 @@ pack_d ( fp_number_type *  src)\n }\n #endif\n \n-extern void unpack_d (FLO_union_type *, fp_number_type *);\n-\n #if defined(L_unpack_df) || defined(L_unpack_sf)\n void\n unpack_d (FLO_union_type * src, fp_number_type * dst)\n@@ -674,7 +391,7 @@ unpack_d (FLO_union_type * src, fp_number_type * dst)\n       dst->fraction.ll = (fraction << NGARDS) | IMPLICIT_1;\n     }\n }\n-#endif\n+#endif /* L_unpack_df || L_unpack_sf */\n \n #if defined(L_addsub_sf) || defined(L_addsub_df)\n static fp_number_type *\n@@ -858,7 +575,7 @@ sub (FLO_type arg_a, FLO_type arg_b)\n \n   return pack_d (res);\n }\n-#endif\n+#endif /* L_addsub_sf || L_addsub_df */\n \n #if defined(L_mul_sf) || defined(L_mul_df)\n static INLINE fp_number_type *\n@@ -1050,7 +767,7 @@ multiply (FLO_type arg_a, FLO_type arg_b)\n \n   return pack_d (res);\n }\n-#endif\n+#endif /* L_mul_sf || L_mul_df */\n \n #if defined(L_div_sf) || defined(L_div_df)\n static INLINE fp_number_type *\n@@ -1160,9 +877,7 @@ divide (FLO_type arg_a, FLO_type arg_b)\n \n   return pack_d (res);\n }\n-#endif\n-\n-int __fpcmp_parts (fp_number_type * a, fp_number_type *b);\n+#endif /* L_div_sf || L_div_df */\n \n #if defined(L_fpcmp_parts_sf) || defined(L_fpcmp_parts_df)\n /* according to the demo, fpcmp returns a comparison with 0... thus\n@@ -1265,7 +980,7 @@ compare (FLO_type arg_a, FLO_type arg_b)\n \n   return __fpcmp_parts (&a, &b);\n }\n-#endif\n+#endif /* L_compare_sf || L_compare_df */\n \n #ifndef US_SOFTWARE_GOFAST\n \n@@ -1290,7 +1005,7 @@ _eq_f2 (FLO_type arg_a, FLO_type arg_b)\n \n   return __fpcmp_parts (&a, &b) ;\n }\n-#endif\n+#endif /* L_eq_sf || L_eq_df */\n \n #if defined(L_ne_sf) || defined(L_ne_df)\n CMPtype\n@@ -1311,7 +1026,7 @@ _ne_f2 (FLO_type arg_a, FLO_type arg_b)\n \n   return  __fpcmp_parts (&a, &b) ;\n }\n-#endif\n+#endif /* L_ne_sf || L_ne_df */\n \n #if defined(L_gt_sf) || defined(L_gt_df)\n CMPtype\n@@ -1332,7 +1047,7 @@ _gt_f2 (FLO_type arg_a, FLO_type arg_b)\n \n   return __fpcmp_parts (&a, &b);\n }\n-#endif\n+#endif /* L_gt_sf || L_gt_df */\n \n #if defined(L_ge_sf) || defined(L_ge_df)\n CMPtype\n@@ -1352,7 +1067,7 @@ _ge_f2 (FLO_type arg_a, FLO_type arg_b)\n     return -1;\t\t\t/* false, truth >= 0 */\n   return __fpcmp_parts (&a, &b) ;\n }\n-#endif\n+#endif /* L_ge_sf || L_ge_df */\n \n #if defined(L_lt_sf) || defined(L_lt_df)\n CMPtype\n@@ -1373,7 +1088,7 @@ _lt_f2 (FLO_type arg_a, FLO_type arg_b)\n \n   return __fpcmp_parts (&a, &b);\n }\n-#endif\n+#endif /* L_lt_sf || L_lt_df */\n \n #if defined(L_le_sf) || defined(L_le_df)\n CMPtype\n@@ -1394,7 +1109,7 @@ _le_f2 (FLO_type arg_a, FLO_type arg_b)\n \n   return __fpcmp_parts (&a, &b) ;\n }\n-#endif\n+#endif /* L_le_sf || L_le_df */\n \n #if defined(L_unord_sf) || defined(L_unord_df)\n CMPtype\n@@ -1412,7 +1127,7 @@ _unord_f2 (FLO_type arg_a, FLO_type arg_b)\n \n   return (isnan (&a) || isnan (&b));\n }\n-#endif\n+#endif /* L_unord_sf || L_unord_df */\n \n #endif /* ! US_SOFTWARE_GOFAST */\n \n@@ -1452,7 +1167,7 @@ si_to_float (SItype arg_a)\n     }\n   return pack_d (&in);\n }\n-#endif\n+#endif /* L_si_to_sf || L_si_to_df */\n \n #if defined(L_sf_to_si) || defined(L_df_to_si)\n SItype\n@@ -1480,7 +1195,7 @@ float_to_si (FLO_type arg_a)\n   tmp = a.fraction.ll >> ((FRACBITS + NGARDS) - a.normal_exp);\n   return a.sign ? (-tmp) : (tmp);\n }\n-#endif\n+#endif /* L_sf_to_si || L_df_to_si */\n \n #if defined(L_sf_to_usi) || defined(L_df_to_usi)\n #ifdef US_SOFTWARE_GOFAST\n@@ -1519,8 +1234,8 @@ float_to_usi (FLO_type arg_a)\n   else\n     return a.fraction.ll >> ((FRACBITS + NGARDS) - a.normal_exp);\n }\n-#endif\n-#endif\n+#endif /* US_SOFTWARE_GOFAST */\n+#endif /* L_sf_to_usi || L_df_to_usi */\n \n #if defined(L_negate_sf) || defined(L_negate_df)\n FLO_type\n@@ -1535,7 +1250,7 @@ negate (FLO_type arg_a)\n   flip_sign (&a);\n   return pack_d (&a);\n }\n-#endif\n+#endif /* L_negate_sf || L_negate_df */\n \n #ifdef FLOAT\n \n@@ -1554,7 +1269,7 @@ __make_fp(fp_class_type class,\n   in.fraction.ll = frac;\n   return pack_d (&in);\n }\n-#endif\n+#endif /* L_make_sf */\n \n #ifndef FLOAT_ONLY\n \n@@ -1563,8 +1278,6 @@ __make_fp(fp_class_type class,\n    This is needed for some 8-bit ports that can't handle well values that\n    are 8-bytes in size, so we just don't support double for them at all.  */\n \n-extern DFtype __make_dp (fp_class_type, unsigned int, int, UDItype frac);\n-\n #if defined(L_sf_to_df)\n DFtype\n sf_to_df (SFtype arg_a)\n@@ -1578,10 +1291,10 @@ sf_to_df (SFtype arg_a)\n   return __make_dp (in.class, in.sign, in.normal_exp,\n \t\t    ((UDItype) in.fraction.ll) << F_D_BITOFF);\n }\n-#endif\n+#endif /* L_sf_to_df */\n \n-#endif\n-#endif\n+#endif /* ! FLOAT_ONLY */\n+#endif /* FLOAT */\n \n #ifndef FLOAT\n \n@@ -1599,7 +1312,7 @@ __make_dp (fp_class_type class, unsigned int sign, int exp, UDItype frac)\n   in.fraction.ll = frac;\n   return pack_d (&in);\n }\n-#endif\n+#endif /* L_make_df */\n \n #if defined(L_df_to_sf)\n SFtype\n@@ -1621,7 +1334,7 @@ df_to_sf (DFtype arg_a)\n \n   return __make_fp (in.class, in.sign, in.normal_exp, sffrac);\n }\n-#endif\n+#endif /* L_df_to_sf */\n \n-#endif\n+#endif /* ! FLOAT */\n #endif /* !EXTENDED_FLOAT_STUBS */"}, {"sha": "0a020e1f41030524c581152a8f6eff268447b68e", "filename": "gcc/config/fp-bit.h", "status": "added", "additions": 409, "deletions": 0, "changes": 409, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb4b535dc26b37c727a73725e52cba24ba826fb0/gcc%2Fconfig%2Ffp-bit.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb4b535dc26b37c727a73725e52cba24ba826fb0/gcc%2Fconfig%2Ffp-bit.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffp-bit.h?ref=cb4b535dc26b37c727a73725e52cba24ba826fb0", "patch": "@@ -0,0 +1,409 @@\n+/* Header file for fp-bit.c.  */\n+/* Copyright (C) 2000\n+   Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with other files,\n+   some of which are compiled with GCC, to produce an executable,\n+   this library does not by itself cause the resulting executable\n+   to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License.  */\n+\n+#ifndef __FP_BIT_H__\n+#define __FP_BIT_H__\n+\n+/* Defining FINE_GRAINED_LIBRARIES allows one to select which routines\n+   from this file are compiled via additional -D options.\n+\n+   This avoids the need to pull in the entire fp emulation library\n+   when only a small number of functions are needed.\n+\n+   If FINE_GRAINED_LIBRARIES is not defined, then compile every \n+   suitable routine.  */\n+#ifndef FINE_GRAINED_LIBRARIES\n+#define L_pack_df\n+#define L_unpack_df\n+#define L_pack_sf\n+#define L_unpack_sf\n+#define L_addsub_sf\n+#define L_addsub_df\n+#define L_mul_sf\n+#define L_mul_df\n+#define L_div_sf\n+#define L_div_df\n+#define L_fpcmp_parts_sf\n+#define L_fpcmp_parts_df\n+#define L_compare_sf\n+#define L_compare_df\n+#define L_eq_sf\n+#define L_eq_df\n+#define L_ne_sf\n+#define L_ne_df\n+#define L_gt_sf\n+#define L_gt_df\n+#define L_ge_sf\n+#define L_ge_df\n+#define L_lt_sf\n+#define L_lt_df\n+#define L_le_sf\n+#define L_le_df\n+#define L_unord_sf\n+#define L_unord_df\n+#define L_si_to_sf\n+#define L_si_to_df\n+#define L_sf_to_si\n+#define L_df_to_si\n+#define L_f_to_usi\n+#define L_df_to_usi\n+#define L_negate_sf\n+#define L_negate_df\n+#define L_make_sf\n+#define L_make_df\n+#define L_sf_to_df\n+#define L_df_to_sf\n+#ifdef FLOAT\n+#define L_thenan_sf\n+#else\n+#define L_thenan_df\n+#endif\n+#endif /* ! FINE_GRAINED_LIBRARIES */\n+\n+typedef float SFtype __attribute__ ((mode (SF)));\n+typedef float DFtype __attribute__ ((mode (DF)));\n+\n+typedef int HItype __attribute__ ((mode (HI)));\n+typedef int SItype __attribute__ ((mode (SI)));\n+typedef int DItype __attribute__ ((mode (DI)));\n+\n+/* The type of the result of a fp compare */\n+#ifndef CMPtype\n+#define CMPtype SItype\n+#endif\n+\n+typedef unsigned int UHItype __attribute__ ((mode (HI)));\n+typedef unsigned int USItype __attribute__ ((mode (SI)));\n+typedef unsigned int UDItype __attribute__ ((mode (DI)));\n+\n+#define MAX_SI_INT   ((SItype) ((unsigned) (~0)>>1))\n+#define MAX_USI_INT  ((USItype) ~0)\n+\n+\n+#ifdef FLOAT_ONLY\n+#define NO_DI_MODE\n+#endif\n+\n+#ifdef FLOAT\n+#\tdefine NGARDS    7L\n+#\tdefine GARDROUND 0x3f\n+#\tdefine GARDMASK  0x7f\n+#\tdefine GARDMSB   0x40\n+#\tdefine EXPBITS 8\n+#\tdefine EXPBIAS 127\n+#\tdefine FRACBITS 23\n+#\tdefine EXPMAX (0xff)\n+#\tdefine QUIET_NAN 0x100000L\n+#\tdefine FRAC_NBITS 32\n+#\tdefine FRACHIGH  0x80000000L\n+#\tdefine FRACHIGH2 0xc0000000L\n+#\tdefine pack_d __pack_f\n+#\tdefine unpack_d __unpack_f\n+#\tdefine __fpcmp_parts __fpcmp_parts_f\n+\ttypedef USItype fractype;\n+\ttypedef UHItype halffractype;\n+\ttypedef SFtype FLO_type;\n+\ttypedef SItype intfrac;\n+\n+#else\n+#\tdefine PREFIXFPDP dp\n+#\tdefine PREFIXSFDF df\n+#\tdefine NGARDS 8L\n+#\tdefine GARDROUND 0x7f\n+#\tdefine GARDMASK  0xff\n+#\tdefine GARDMSB   0x80\n+#\tdefine EXPBITS 11\n+#\tdefine EXPBIAS 1023\n+#\tdefine FRACBITS 52\n+#\tdefine EXPMAX (0x7ff)\n+#\tdefine QUIET_NAN 0x8000000000000LL\n+#\tdefine FRAC_NBITS 64\n+#\tdefine FRACHIGH  0x8000000000000000LL\n+#\tdefine FRACHIGH2 0xc000000000000000LL\n+#\tdefine pack_d __pack_d\n+#\tdefine unpack_d __unpack_d\n+#\tdefine __fpcmp_parts __fpcmp_parts_d\n+\ttypedef UDItype fractype;\n+\ttypedef USItype halffractype;\n+\ttypedef DFtype FLO_type;\n+\ttypedef DItype intfrac;\n+#endif /* FLOAT */\n+\n+#ifdef US_SOFTWARE_GOFAST\n+#\tifdef FLOAT\n+#\t\tdefine add \t\tfpadd\n+#\t\tdefine sub \t\tfpsub\n+#\t\tdefine multiply \tfpmul\n+#\t\tdefine divide \t\tfpdiv\n+#\t\tdefine compare \t\tfpcmp\n+#\t\tdefine si_to_float \tsitofp\n+#\t\tdefine float_to_si \tfptosi\n+#\t\tdefine float_to_usi \tfptoui\n+#\t\tdefine negate \t\t__negsf2\n+#\t\tdefine sf_to_df\t\tfptodp\n+#\t\tdefine dptofp \t\tdptofp\n+#else\n+#\t\tdefine add \t\tdpadd\n+#\t\tdefine sub \t\tdpsub\n+#\t\tdefine multiply \tdpmul\n+#\t\tdefine divide \t\tdpdiv\n+#\t\tdefine compare \t\tdpcmp\n+#\t\tdefine si_to_float \tlitodp\n+#\t\tdefine float_to_si \tdptoli\n+#\t\tdefine float_to_usi \tdptoul\n+#\t\tdefine negate \t\t__negdf2\n+#\t\tdefine df_to_sf \tdptofp\n+#\tendif /* FLOAT */\n+#else\n+#\tifdef FLOAT\n+#\t\tdefine add \t\t__addsf3\n+#\t\tdefine sub \t\t__subsf3\n+#\t\tdefine multiply \t__mulsf3\n+#\t\tdefine divide \t\t__divsf3\n+#\t\tdefine compare \t\t__cmpsf2\n+#\t\tdefine _eq_f2 \t\t__eqsf2\n+#\t\tdefine _ne_f2 \t\t__nesf2\n+#\t\tdefine _gt_f2 \t\t__gtsf2\n+#\t\tdefine _ge_f2 \t\t__gesf2\n+#\t\tdefine _lt_f2 \t\t__ltsf2\n+#\t\tdefine _le_f2 \t\t__lesf2\n+#\t\tdefine _unord_f2\t__unordsf2\n+#\t\tdefine si_to_float \t__floatsisf\n+#\t\tdefine float_to_si \t__fixsfsi\n+#\t\tdefine float_to_usi \t__fixunssfsi\n+#\t\tdefine negate \t\t__negsf2\n+#\t\tdefine sf_to_df\t\t__extendsfdf2\n+#else\n+#\t\tdefine add \t\t__adddf3\n+#\t\tdefine sub \t\t__subdf3\n+#\t\tdefine multiply \t__muldf3\n+#\t\tdefine divide \t\t__divdf3\n+#\t\tdefine compare \t\t__cmpdf2\n+#\t\tdefine _eq_f2 \t\t__eqdf2\n+#\t\tdefine _ne_f2 \t\t__nedf2\n+#\t\tdefine _gt_f2 \t\t__gtdf2\n+#\t\tdefine _ge_f2 \t\t__gedf2\n+#\t\tdefine _lt_f2 \t\t__ltdf2\n+#\t\tdefine _le_f2 \t\t__ledf2\n+#\t\tdefine _unord_f2\t__unorddf2\n+#\t\tdefine si_to_float \t__floatsidf\n+#\t\tdefine float_to_si \t__fixdfsi\n+#\t\tdefine float_to_usi \t__fixunsdfsi\n+#\t\tdefine negate \t\t__negdf2\n+#\t\tdefine df_to_sf\t\t__truncdfsf2\n+#\tendif /* FLOAT */\n+#endif /* US_SOFTWARE_GOFAST */\n+\n+#ifndef INLINE\n+#define INLINE __inline__\n+#endif\n+\n+/* Preserve the sticky-bit when shifting fractions to the right.  */\n+#define LSHIFT(a) { a = (a & 1) | (a >> 1); }\n+\n+/* numeric parameters */\n+/* F_D_BITOFF is the number of bits offset between the MSB of the mantissa\n+   of a float and of a double. Assumes there are only two float types.\n+   (double::FRAC_BITS+double::NGARDS-(float::FRAC_BITS-float::NGARDS))\n+ */\n+#define F_D_BITOFF (52+8-(23+7))\n+\n+\n+#define NORMAL_EXPMIN (-(EXPBIAS)+1)\n+#define IMPLICIT_1 (1LL<<(FRACBITS+NGARDS))\n+#define IMPLICIT_2 (1LL<<(FRACBITS+1+NGARDS))\n+\n+/* common types */\n+\n+typedef enum\n+{\n+  CLASS_SNAN,\n+  CLASS_QNAN,\n+  CLASS_ZERO,\n+  CLASS_NUMBER,\n+  CLASS_INFINITY\n+} fp_class_type;\n+\n+typedef struct\n+{\n+#ifdef SMALL_MACHINE\n+  char class;\n+  unsigned char sign;\n+  short normal_exp;\n+#else\n+  fp_class_type class;\n+  unsigned int sign;\n+  int normal_exp;\n+#endif\n+\n+  union\n+    {\n+      fractype ll;\n+      halffractype l[2];\n+    } fraction;\n+} fp_number_type;\n+\n+typedef union\n+{\n+  FLO_type value;\n+  fractype value_raw;\n+\n+#ifndef FLOAT\n+  halffractype words[2];\n+#endif\n+\n+#ifdef FLOAT_BIT_ORDER_MISMATCH\n+  struct\n+    {\n+      fractype fraction:FRACBITS __attribute__ ((packed));\n+      unsigned int exp:EXPBITS __attribute__ ((packed));\n+      unsigned int sign:1 __attribute__ ((packed));\n+    }\n+  bits;\n+#endif\n+\n+#ifdef _DEBUG_BITFLOAT\n+  struct\n+    {\n+      unsigned int sign:1 __attribute__ ((packed));\n+      unsigned int exp:EXPBITS __attribute__ ((packed));\n+      fractype fraction:FRACBITS __attribute__ ((packed));\n+    }\n+  bits_big_endian;\n+\n+  struct\n+    {\n+      fractype fraction:FRACBITS __attribute__ ((packed));\n+      unsigned int exp:EXPBITS __attribute__ ((packed));\n+      unsigned int sign:1 __attribute__ ((packed));\n+    }\n+  bits_little_endian;\n+#endif\n+}\n+FLO_union_type;\n+\n+/* Prototypes */\n+\n+#if defined(L_pack_df) || defined(L_pack_sf)\n+extern FLO_type pack_d (fp_number_type *);\n+#endif\n+\n+extern void unpack_d (FLO_union_type *, fp_number_type *);\n+\n+#if defined(L_addsub_sf) || defined(L_addsub_df)\n+extern FLO_type add (FLO_type, FLO_type);\n+extern FLO_type sub (FLO_type, FLO_type);\n+#endif\n+\n+#if defined(L_mul_sf) || defined(L_mul_df)\n+extern FLO_type multiply (FLO_type, FLO_type);\n+#endif\n+\n+#if defined(L_div_sf) || defined(L_div_df)\n+extern FLO_type divide (FLO_type, FLO_type);\n+#endif\n+\n+extern int __fpcmp_parts (fp_number_type *, fp_number_type *);\n+\n+#if defined(L_compare_sf) || defined(L_compare_df)\n+extern CMPtype compare (FLO_type, FLO_type);\n+#endif\n+\n+#ifndef US_SOFTWARE_GOFAST\n+\n+#if defined(L_eq_sf) || defined(L_eq_df)\n+extern CMPtype _eq_f2 (FLO_type, FLO_type);\n+#endif\n+\n+#if defined(L_ne_sf) || defined(L_ne_df)\n+extern CMPtype _ne_f2 (FLO_type, FLO_type);\n+#endif\n+\n+#if defined(L_gt_sf) || defined(L_gt_df)\n+extern CMPtype _gt_f2 (FLO_type, FLO_type);\n+#endif\n+\n+#if defined(L_ge_sf) || defined(L_ge_df)\n+extern CMPtype _ge_f2 (FLO_type, FLO_type);\n+#endif\n+\n+#if defined(L_lt_sf) || defined(L_lt_df)\n+extern CMPtype _lt_f2 (FLO_type, FLO_type);\n+#endif\n+\n+#if defined(L_le_sf) || defined(L_le_df)\n+extern CMPtype _le_f2 (FLO_type, FLO_type);\n+#endif\n+\n+#if defined(L_unord_sf) || defined(L_unord_df)\n+extern CMPtype _unord_f2 (FLO_type, FLO_type);\n+#endif\n+\n+#endif /* ! US_SOFTWARE_GOFAST */\n+\n+#if defined(L_si_to_sf) || defined(L_si_to_df)\n+extern FLO_type si_to_float (SItype);\n+#endif\n+\n+#if defined(L_sf_to_si) || defined(L_df_to_si)\n+extern SItype float_to_si (FLO_type);\n+#endif\n+\n+#if defined(L_sf_to_usi) || defined(L_df_to_usi)\n+#ifdef US_SOFTWARE_GOFAST\n+extern USItype float_to_usi (FLO_type);\n+#endif\n+#endif\n+\n+#if defined(L_negate_sf) || defined(L_negate_df)\n+extern FLO_type negate (FLO_type);\n+#endif\n+\n+#ifdef FLOAT\n+#if defined(L_make_sf)\n+extern SFtype __make_fp (fp_class_type, unsigned int, int, USItype);\n+#endif\n+#ifndef FLOAT_ONLY\n+extern DFtype __make_dp (fp_class_type, unsigned int, int, UDItype);\n+#if defined(L_sf_to_df)\n+extern DFtype sf_to_df (SFtype);\n+#endif\n+#endif /* ! FLOAT_ONLY */\n+#endif /* FLOAT */\n+\n+#ifndef FLOAT\n+extern SFtype __make_fp (fp_class_type, unsigned int, int, USItype);\n+#if defined(L_make_df)\n+extern DFtype __make_dp (fp_class_type, unsigned int, int, UDItype);\n+#endif\n+#if defined(L_df_to_sf)\n+extern SFtype df_to_sf (DFtype);\n+#endif\n+#endif /* ! FLOAT */\n+\n+#endif /* __FP_BIT_H__ */"}]}