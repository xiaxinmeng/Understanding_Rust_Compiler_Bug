{"sha": "54a8809004eeb0b163b28d2034e4eb90b72cb067", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTRhODgwOTAwNGVlYjBiMTYzYjI4ZDIwMzRlNGViOTBiNzJjYjA2Nw==", "commit": {"author": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2007-04-10T22:41:28Z"}, "committer": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2007-04-10T22:41:28Z"}, "message": "i386.h (X87_FLOAT_MODE_P): New.\n\n2007-04-10  Eric Christopher  <echristo@apple.com>\n\n\t    * config/i386/i386.h (X87_FLOAT_MODE_P): New.\n\t    * config/i386/i386.md (*cmpfp0): Use.\n\t    (*cmpfp_u, *cmpfp_<mode>, *cmpfp_i_i387): Ditto.\n\t    (*cmpfp_iu_387, fix_trunc<mode>_fisttp_i386_1): Ditto.\n\t    (fix_trunc<mode>_i386_fisttp): Ditto.\n\t    (fix_trunc<mode>_i387_fisttp_with_temp): Ditto.\n\t    (*fix_trunc<mode>_i387_1, fix_truncdi_i387): Ditto.\n\t    (fix_truncdi_i387_with_temp, fix_trunc<mode>_i387): Ditto.\n\t    (fix_trunc<mode>_i387_with_temp, *fp_jcc_1_387): Ditto.\n\t    (*fp_jcc_2_387, *fp_jcc_5_387, *fp_jcc_6_387): Ditto.\n\t    (*fp_jcc_7_387, *fp_jcc_8<mode>_387): Ditto.\n\t    (unnamed_splitters): Ditto.\n\t    * config/i386/i386.c (output_fix_trunc): Assert that\n\t    we're not being passed a TFmode operand.\n\nFrom-SVN: r123700", "tree": {"sha": "4a187164b30ac64a6458291dd187d186440ff88e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4a187164b30ac64a6458291dd187d186440ff88e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/54a8809004eeb0b163b28d2034e4eb90b72cb067", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54a8809004eeb0b163b28d2034e4eb90b72cb067", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54a8809004eeb0b163b28d2034e4eb90b72cb067", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54a8809004eeb0b163b28d2034e4eb90b72cb067/comments", "author": null, "committer": null, "parents": [{"sha": "7c57be853dae318a1d32ccd81dca000439b45853", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c57be853dae318a1d32ccd81dca000439b45853", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c57be853dae318a1d32ccd81dca000439b45853"}], "stats": {"total": 75, "additions": 49, "deletions": 26}, "files": [{"sha": "d5f2ac7b5a66256aa0bacd89b63cc4ea57007fc4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a8809004eeb0b163b28d2034e4eb90b72cb067/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a8809004eeb0b163b28d2034e4eb90b72cb067/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=54a8809004eeb0b163b28d2034e4eb90b72cb067", "patch": "@@ -1,3 +1,20 @@\n+2007-04-10  Eric Christopher  <echristo@apple.com>\n+\n+\t* config/i386/i386.h (X87_FLOAT_MODE_P): New.\n+\t* config/i386/i386.md (*cmpfp0): Use.\n+\t(*cmpfp_u, *cmpfp_<mode>, *cmpfp_i_i387): Ditto.\n+\t(*cmpfp_iu_387, fix_trunc<mode>_fisttp_i386_1): Ditto.\n+\t(fix_trunc<mode>_i386_fisttp): Ditto.\n+\t(fix_trunc<mode>_i387_fisttp_with_temp): Ditto.\n+\t(*fix_trunc<mode>_i387_1, fix_truncdi_i387): Ditto.\n+\t(fix_truncdi_i387_with_temp, fix_trunc<mode>_i387): Ditto.\n+\t(fix_trunc<mode>_i387_with_temp, *fp_jcc_1_387): Ditto.\n+\t(*fp_jcc_2_387, *fp_jcc_5_387, *fp_jcc_6_387): Ditto.\n+\t(*fp_jcc_7_387, *fp_jcc_8<mode>_387): Ditto.\n+\t(unnamed_splitters): Ditto.\n+\t* config/i386/i386.c (output_fix_trunc): Assert that\n+\twe're not being passed a TFmode operand.\n+\n 2007-04-10  Zdenek Dvorak  <dvorakz@suse.cz>\n \n \tPR tree-optimization/31526\n@@ -121,7 +138,7 @@\n 2007-04-07  Anatoly Sokolov <aesok@post.ru>\n \n \tPR target/30289\n-\t* config/avr/avr.md (*clrmemqi, *clrmemhi): Mark operand 4 as \n+\t* config/avr/avr.md (*clrmemqi, *clrmemhi): Mark operand 4 as\n \tearlyclobber.\n \n 2007-04-07  Bruce Korb  <bkorb@gnu.org>\n@@ -199,7 +216,7 @@\n \t* langhooks.h (lang_hooks): Remove safe_from_p.\n \t(lhd_safe_from_p): Remove prototype.\n \t* langhooks.c (lhd_safe_from_p): Remove.\n-\t\n+\n 2007-04-06  Jan Hubicka  <jh@suse.cz>\n \n \t* cgraphunit.c (decide_is_function_needed): Do not keep always_inline\n@@ -305,7 +322,7 @@\n 2007-04-05  Anatoly Sokolov <aesok@post.ru>\n \n \tPR target/25448\n-\t* config/avr/avr.c (avr_handle_fndecl_attribute): Use the \n+\t* config/avr/avr.c (avr_handle_fndecl_attribute): Use the\n \tDECL_ASSEMBLER_NAME, not the DECL_NAME.\n \n 2007-04-05  H.J. Lu  <hongjiu.lu@intel.com>"}, {"sha": "1acca3bb5531e0220ee6ee362a0d1a2b8afbfbff", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a8809004eeb0b163b28d2034e4eb90b72cb067/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a8809004eeb0b163b28d2034e4eb90b72cb067/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=54a8809004eeb0b163b28d2034e4eb90b72cb067", "patch": "@@ -1037,7 +1037,7 @@ unsigned int ix86_tune_features[X86_TUNE_LAST] = {\n \n   /* X86_TUNE_DOUBLE_WITH_ADD */\n   ~m_386,\n-  \n+\n   /* X86_TUNE_USE_SAHF */\n   m_PPRO | m_K6_GEODE | m_K8 | m_AMDFAM10 | m_PENT4\n   | m_NOCONA | m_CORE2 | m_GENERIC,\n@@ -1059,7 +1059,7 @@ unsigned int ix86_tune_features[X86_TUNE_LAST] = {\n \n   /* X86_TUNE_PARTIAL_FLAG_REG_STALL */\n   m_CORE2 | m_GENERIC,\n-  \n+\n   /* X86_TUNE_USE_HIMODE_FIOP */\n   m_386 | m_486 | m_K6_GEODE,\n \n@@ -1068,7 +1068,7 @@ unsigned int ix86_tune_features[X86_TUNE_LAST] = {\n \n   /* X86_TUNE_USE_MOV0 */\n   m_K6,\n-  \n+\n   /* X86_TUNE_USE_CLTD */\n   ~(m_PENT | m_K6 | m_CORE2 | m_GENERIC),\n \n@@ -1093,10 +1093,10 @@ unsigned int ix86_tune_features[X86_TUNE_LAST] = {\n \n   /* X86_TUNE_SINGLE_STRINGOP */\n   m_386 | m_PENT4 | m_NOCONA,\n-  \n+\n   /* X86_TUNE_QIMODE_MATH */\n   ~0,\n-  \n+\n   /* X86_TUNE_HIMODE_MATH: On PPro this flag is meant to avoid partial\n      register stalls.  Just like X86_TUNE_PARTIAL_REG_STALL this option\n      might be considered for Generic32 if our scheme for avoiding partial\n@@ -9261,6 +9261,7 @@ output_fix_trunc (rtx insn, rtx *operands, int fisttp)\n \n   gcc_assert (STACK_TOP_P (operands[1]));\n   gcc_assert (MEM_P (operands[0]));\n+  gcc_assert (GET_MODE (operands[1]) != TFmode);\n \n   if (fisttp)\n       output_asm_insn (\"fisttp%z0\\t%0\", operands);\n@@ -9293,7 +9294,7 @@ output_387_ffreep (rtx *operands ATTRIBUTE_UNUSED, int opno)\n     {\n       static char retval[] = \".word\\t0xc_df\";\n       int regno = REGNO (operands[opno]);\n-      \n+\n       gcc_assert (FP_REGNO_P (regno));\n \n       retval[9] = '0' + (regno - FIRST_STACK_REG);\n@@ -9683,7 +9684,7 @@ ix86_expand_vector_move (enum machine_mode mode, rtx operands[])\n        movlpd mem, reg      (gas syntax)\n      else\n        movsd mem, reg\n- \n+\n    Code generation for unaligned packed loads of single precision data\n    (x86_sse_unaligned_move_optimal overrides x86_sse_partial_reg_dependency):\n      if (x86_sse_unaligned_move_optimal)\n@@ -9872,7 +9873,7 @@ ix86_expand_push (enum machine_mode mode, rtx x)\n \n /* Helper function of ix86_fixup_binary_operands to canonicalize\n    operand order.  Returns true if the operands should be swapped.  */\n-   \n+\n static bool\n ix86_swap_binary_operands_p (enum rtx_code code, enum machine_mode mode,\n \t\t\t     rtx operands[])\n@@ -10267,7 +10268,7 @@ ix86_expand_convert_sign_didf_sse (rtx target, rtx input)\n {\n   REAL_VALUE_TYPE TWO32r;\n   rtx fp_lo, fp_hi, x;\n-  \n+\n   fp_lo = gen_reg_rtx (DFmode);\n   fp_hi = gen_reg_rtx (DFmode);\n \n@@ -12686,11 +12687,11 @@ ix86_expand_sse_unpack (rtx operands[2], bool unsigned_p, bool high_p)\n     case V4SImode:\n       if (high_p)\n         unpack = gen_vec_interleave_highv4si;\n-      else \n+      else\n         unpack = gen_vec_interleave_lowv4si;\n       break;\n     default:\n-      gcc_unreachable (); \n+      gcc_unreachable ();\n     }\n \n   dest = gen_lowpart (imode, operands[0]);\n@@ -13566,7 +13567,7 @@ counter_mode (rtx count_exp)\n \n    The size is rounded down to whole number of chunk size moved at once.\n    SRCMEM and DESTMEM provide MEMrtx to feed proper aliasing info.  */\n-  \n+\n \n static void\n expand_set_or_movmem_via_loop (rtx destmem, rtx srcmem,\n@@ -13610,7 +13611,7 @@ expand_set_or_movmem_via_loop (rtx destmem, rtx srcmem,\n       srcmem = change_address (srcmem, mode, y_addr);\n \n       /* When unrolling for chips that reorder memory reads and writes,\n-\t we can save registers by using single temporary.  \n+\t we can save registers by using single temporary.\n \t Also using 4 temporaries is overkill in 32bit mode.  */\n       if (!TARGET_64BIT && 0)\n \t{\n@@ -13694,7 +13695,7 @@ expand_set_or_movmem_via_loop (rtx destmem, rtx srcmem,\n   emit_label (out_label);\n }\n \n-/* Output \"rep; mov\" instruction.  \n+/* Output \"rep; mov\" instruction.\n    Arguments have same meaning as for previous function */\n static void\n expand_movmem_via_rep_mov (rtx destmem, rtx srcmem,\n@@ -13734,7 +13735,7 @@ expand_movmem_via_rep_mov (rtx destmem, rtx srcmem,\n \t\t\t  destexp, srcexp));\n }\n \n-/* Output \"rep; stos\" instruction.  \n+/* Output \"rep; stos\" instruction.\n    Arguments have same meaning as for previous function */\n static void\n expand_setmem_via_rep_stos (rtx destmem, rtx destptr, rtx value,\n@@ -14182,7 +14183,7 @@ decide_alg (HOST_WIDE_INT count, HOST_WIDE_INT expected_size, bool memset,\n   /* When asked to inline the call anyway, try to pick meaningful choice.\n      We look for maximal size of block that is faster to copy by hand and\n      take blocks of at most of that size guessing that average size will\n-     be roughly half of the block.  \n+     be roughly half of the block.\n \n      If this turns out to be bad, we might simply specify the preferred\n      choice in ix86_costs.  */\n@@ -14292,7 +14293,7 @@ smallest_pow2_greater_than (int val)\n \n    4) Epilogue: code copying tail of the block that is too small to be\n       handled by main body (or up to size guarded by prologue guard).  */\n-   \n+\n int\n ix86_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp,\n \t\t    rtx expected_align_exp, rtx expected_size_exp)\n@@ -14484,7 +14485,7 @@ ix86_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp,\n  \t while we want to copy only COUNT_EXP & SIZE_NEEDED bytes.\n \t Epilogue code will actually copy COUNT_EXP & EPILOGUE_SIZE_NEEDED\n \t bytes. Compensate if needed.  */\n-\t \n+\n       if (size_needed < epilogue_size_needed)\n \t{\n \t  tmp =\n@@ -14680,7 +14681,7 @@ ix86_expand_setmem (rtx dst, rtx count_exp, rtx val_exp, rtx align_exp,\n \tmode = DImode;\n       count_exp = force_reg (mode, count_exp);\n     }\n-  /* Do the cheap promotion to allow better CSE across the \n+  /* Do the cheap promotion to allow better CSE across the\n      main loop and epilogue (ie one load of the big constant in the\n      front of all code.  */\n   if (CONST_INT_P (val_exp))\n@@ -17414,11 +17415,11 @@ ix86_init_mmx_sse_builtins (void)\n \t       IX86_BUILTIN_PALIGNR);\n \n   /* AMDFAM10 SSE4A New built-ins  */\n-  def_builtin (MASK_SSE4A, \"__builtin_ia32_movntsd\", \n+  def_builtin (MASK_SSE4A, \"__builtin_ia32_movntsd\",\n                void_ftype_pdouble_v2df, IX86_BUILTIN_MOVNTSD);\n-  def_builtin (MASK_SSE4A, \"__builtin_ia32_movntss\", \n+  def_builtin (MASK_SSE4A, \"__builtin_ia32_movntss\",\n                void_ftype_pfloat_v4sf, IX86_BUILTIN_MOVNTSS);\n-  def_builtin (MASK_SSE4A, \"__builtin_ia32_extrqi\", \n+  def_builtin (MASK_SSE4A, \"__builtin_ia32_extrqi\",\n                v2di_ftype_v2di_unsigned_unsigned, IX86_BUILTIN_EXTRQI);\n   def_builtin (MASK_SSE4A, \"__builtin_ia32_extrq\",\n                v2di_ftype_v2di_v16qi,  IX86_BUILTIN_EXTRQ);\n@@ -18647,7 +18648,7 @@ ix86_builtin_conversion (enum tree_code code, tree type)\n {\n   if (TREE_CODE (type) != VECTOR_TYPE)\n     return NULL_TREE;\n-  \n+\n   switch (code)\n     {\n     case FLOAT_EXPR:"}, {"sha": "859bcee887a7c648a233286ec47817825e2fd4b3", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a8809004eeb0b163b28d2034e4eb90b72cb067/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a8809004eeb0b163b28d2034e4eb90b72cb067/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=54a8809004eeb0b163b28d2034e4eb90b72cb067", "patch": "@@ -1362,6 +1362,11 @@ enum reg_class\n #define ANY_FP_REG_P(X) (REG_P (X) && ANY_FP_REGNO_P (REGNO (X)))\n #define ANY_FP_REGNO_P(N) (FP_REGNO_P (N) || SSE_REGNO_P (N))\n \n+#define X87_FLOAT_MODE_P(MODE)\t\\\n+  ((MODE) == SFmode\t\t\\\n+   || (MODE) == DFmode\t\t\\\n+   || (MODE) == XFmode)\n+\n #define SSE_REG_P(N) (REG_P (N) && SSE_REGNO_P (REGNO (N)))\n #define SSE_REGNO_P(N)\t\t\t\t\t\t\\\n   (IN_RANGE ((N), FIRST_SSE_REG, LAST_SSE_REG)\t\t\t\\"}]}