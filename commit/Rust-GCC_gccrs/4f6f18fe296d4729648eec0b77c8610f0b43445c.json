{"sha": "4f6f18fe296d4729648eec0b77c8610f0b43445c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGY2ZjE4ZmUyOTZkNDcyOTY0OGVlYzBiNzdjODYxMGYwYjQzNDQ1Yw==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-01-18T21:42:53Z"}, "committer": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2021-01-20T09:59:22Z"}, "message": "Support struct base reference in constructors\n\nThis creates implicit FieldAccessExpr or TupleIndexExprs for the missing\nfields in the constructor using the base struct as the receiver.", "tree": {"sha": "a3897a28c43df3381df8bee90ab0a9501f32dd68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a3897a28c43df3381df8bee90ab0a9501f32dd68"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f6f18fe296d4729648eec0b77c8610f0b43445c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f6f18fe296d4729648eec0b77c8610f0b43445c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f6f18fe296d4729648eec0b77c8610f0b43445c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f6f18fe296d4729648eec0b77c8610f0b43445c/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03"}], "stats": {"total": 175, "additions": 156, "deletions": 19}, "files": [{"sha": "29b56915e3f6ba4f63d5a7eadb82bd478de0660f", "filename": "gcc/rust/hir/tree/rust-hir-expr.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f6f18fe296d4729648eec0b77c8610f0b43445c/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f6f18fe296d4729648eec0b77c8610f0b43445c/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h?ref=4f6f18fe296d4729648eec0b77c8610f0b43445c", "patch": "@@ -1669,6 +1669,16 @@ class StructExprStructFields : public StructExprStruct\n       }\n   }\n \n+  std::vector<std::unique_ptr<StructExprField> > &get_fields ()\n+  {\n+    return fields;\n+  };\n+\n+  const std::vector<std::unique_ptr<StructExprField> > &get_fields () const\n+  {\n+    return fields;\n+  };\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "fabc31d0446fa44cefe1e6a5951da91fa5a209c1", "filename": "gcc/rust/hir/tree/rust-hir.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f6f18fe296d4729648eec0b77c8610f0b43445c/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f6f18fe296d4729648eec0b77c8610f0b43445c/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h?ref=4f6f18fe296d4729648eec0b77c8610f0b43445c", "patch": "@@ -819,16 +819,16 @@ class Expr\n \n   const Analysis::NodeMapping &get_mappings () const { return mappings; }\n \n+  // Clone function implementation as pure virtual method\n+  virtual Expr *clone_expr_impl () const = 0;\n+\n protected:\n   // Constructor\n   Expr (Analysis::NodeMapping mappings,\n \tstd::vector<Attribute> outer_attribs = std::vector<Attribute> ())\n     : outer_attrs (std::move (outer_attribs)), mappings (std::move (mappings))\n   {}\n \n-  // Clone function implementation as pure virtual method\n-  virtual Expr *clone_expr_impl () const = 0;\n-\n   // TODO: think of less hacky way to implement this kind of thing\n   // Sets outer attributes.\n   void set_outer_attrs (std::vector<Attribute> outer_attrs_to_set)"}, {"sha": "181124aadd67ed83db8bf0b9711fec2ba3e687ef", "filename": "gcc/rust/resolve/rust-ast-resolve-expr.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f6f18fe296d4729648eec0b77c8610f0b43445c/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f6f18fe296d4729648eec0b77c8610f0b43445c/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h?ref=4f6f18fe296d4729648eec0b77c8610f0b43445c", "patch": "@@ -179,6 +179,14 @@ class ResolveExpr : public ResolverBase\n   {\n     ResolveExpr::go (&struct_expr.get_struct_name (),\n \t\t     struct_expr.get_node_id ());\n+\n+    if (struct_expr.has_struct_base ())\n+      {\n+\tAST::StructBase &base = struct_expr.get_struct_base ();\n+\tResolveExpr::go (base.get_base_struct ().get (),\n+\t\t\t struct_expr.get_node_id ());\n+      }\n+\n     struct_expr.iterate (\n       [&] (AST::StructExprField *struct_field) mutable -> bool {\n \tResolveStructExprField::go (struct_field, struct_expr.get_node_id ());"}, {"sha": "4c0999261ffedc9ead1654b1049335a64ce80ce7", "filename": "gcc/rust/typecheck/rust-hir-type-check.cc", "status": "modified", "additions": 99, "deletions": 16, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f6f18fe296d4729648eec0b77c8610f0b43445c/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f6f18fe296d4729648eec0b77c8610f0b43445c/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc?ref=4f6f18fe296d4729648eec0b77c8610f0b43445c", "patch": "@@ -89,42 +89,125 @@ TypeCheckStructExpr::visit (HIR::StructExprStructFields &struct_expr)\n       return;\n     }\n \n+  resolved = struct_path_resolved;\n+  if (struct_expr.has_struct_base ())\n+    {\n+      TyTy::TyBase *base_resolved\n+\t= TypeCheckExpr::Resolve (struct_expr.struct_base->base_struct.get ());\n+      resolved = struct_path_resolved->combine (base_resolved);\n+      if (resolved == nullptr)\n+\t{\n+\t  rust_fatal_error (\n+\t    struct_expr.struct_base->base_struct->get_locus_slow (),\n+\t    \"incompatible types for base struct reference\");\n+\t  return;\n+\t}\n+    }\n+\n+  bool ok = true;\n   struct_expr.iterate ([&] (HIR::StructExprField *field) mutable -> bool {\n     resolved_field = nullptr;\n     field->accept_vis (*this);\n     if (resolved_field == nullptr)\n       {\n \trust_fatal_error (field->get_locus (),\n \t\t\t  \"failed to resolve type for field\");\n+\tok = false;\n \treturn false;\n       }\n \n     context->insert_type (field->get_mappings ().get_hirid (), resolved_field);\n     return true;\n   });\n \n-  TyTy::TyBase *expr_type = struct_path_resolved;\n-  if (struct_expr.has_struct_base ())\n+  // something failed setting up the fields\n+  if (!ok)\n+    return;\n+\n+  // check the arguments are all assigned and fix up the ordering\n+  if (fields_assigned.size () != struct_path_resolved->num_fields ())\n     {\n-      TyTy::TyBase *base_resolved\n-\t= TypeCheckExpr::Resolve (struct_expr.struct_base->base_struct.get ());\n-      expr_type = expr_type->combine (base_resolved);\n-      if (resolved == nullptr)\n+      if (!struct_expr.has_struct_base ())\n \t{\n-\t  rust_fatal_error (\n-\t    struct_expr.struct_base->base_struct->get_locus_slow (),\n-\t    \"incompatible types for base struct reference\");\n+\t  rust_error_at (struct_expr.get_locus (),\n+\t\t\t \"constructor is missing fields\");\n \t  return;\n \t}\n+      else\n+\t{\n+\t  // we have a struct base to assign the missing fields from.\n+\t  // the missing fields can be implicit FieldAccessExprs for the value\n+\t  std::set<std::string> missing_fields;\n+\t  struct_path_resolved->iterate_fields (\n+\t    [&] (TyTy::StructFieldType *field) mutable -> bool {\n+\t      auto it = fields_assigned.find (field->get_name ());\n+\t      if (it == fields_assigned.end ())\n+\t\tmissing_fields.insert (field->get_name ());\n+\t      return true;\n+\t    });\n+\n+\t  // we can generate FieldAccessExpr or TupleAccessExpr for the values\n+\t  // of the missing fields.\n+\t  for (auto &missing : missing_fields)\n+\t    {\n+\t      HIR::Expr *receiver\n+\t\t= struct_expr.struct_base->base_struct->clone_expr_impl ();\n+\n+\t      HIR::StructExprField *implicit_field = nullptr;\n+\t      if (struct_path_resolved->is_tuple_struct ())\n+\t\t{\n+\t\t  std::vector<HIR::Attribute> outer_attribs;\n+\t\t  TupleIndex tuple_index = std::stoi (missing);\n+\n+\t\t  auto crate_num = mappings->get_current_crate ();\n+\t\t  Analysis::NodeMapping mapping (\n+\t\t    crate_num,\n+\t\t    struct_expr.struct_base->base_struct->get_mappings ()\n+\t\t      .get_nodeid (),\n+\t\t    mappings->get_next_hir_id (crate_num), UNKNOWN_LOCAL_DEFID);\n+\n+\t\t  HIR::Expr *field_value = new HIR::TupleIndexExpr (\n+\t\t    mapping, std::unique_ptr<HIR::Expr> (receiver), tuple_index,\n+\t\t    std::move (outer_attribs),\n+\t\t    struct_expr.struct_base->base_struct->get_locus_slow ());\n+\n+\t\t  implicit_field = new HIR::StructExprFieldIndexValue (\n+\t\t    mapping, tuple_index,\n+\t\t    std::unique_ptr<HIR::Expr> (field_value),\n+\t\t    struct_expr.struct_base->base_struct->get_locus_slow ());\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  std::vector<HIR::Attribute> outer_attribs;\n+\t\t  auto crate_num = mappings->get_current_crate ();\n+\t\t  Analysis::NodeMapping mapping (\n+\t\t    crate_num,\n+\t\t    struct_expr.struct_base->base_struct->get_mappings ()\n+\t\t      .get_nodeid (),\n+\t\t    mappings->get_next_hir_id (crate_num), UNKNOWN_LOCAL_DEFID);\n+\n+\t\t  HIR::Expr *field_value = new HIR::FieldAccessExpr (\n+\t\t    mapping, std::unique_ptr<HIR::Expr> (receiver), missing,\n+\t\t    std::move (outer_attribs),\n+\t\t    struct_expr.struct_base->base_struct->get_locus_slow ());\n+\n+\t\t  implicit_field = new HIR::StructExprFieldIdentifierValue (\n+\t\t    mapping, missing, std::unique_ptr<HIR::Expr> (field_value),\n+\t\t    struct_expr.struct_base->base_struct->get_locus_slow ());\n+\t\t}\n+\n+\t      struct_expr.get_fields ().push_back (\n+\t\tstd::unique_ptr<HIR::StructExprField> (implicit_field));\n+\t    }\n+\t}\n     }\n-  else if (fields_assigned.size () != struct_path_resolved->num_fields ())\n-    {\n-      rust_fatal_error (struct_expr.get_locus (),\n-\t\t\t\"some fields are not fully assigned\");\n-      return;\n-    }\n \n-  resolved = expr_type;\n+  // everything is ok, now we need to ensure all field values are ordered\n+  // correctly. The GIMPLE backend uses a simple algorithm that assumes each\n+  // assigned field in the constructor is in the same order as the field in the\n+  // type\n+\n+  // TODO\n }\n \n void"}, {"sha": "c32ac02faebdf825b6e5e34f6a71fb7df8d123e7", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f6f18fe296d4729648eec0b77c8610f0b43445c/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f6f18fe296d4729648eec0b77c8610f0b43445c/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=4f6f18fe296d4729648eec0b77c8610f0b43445c", "patch": "@@ -219,6 +219,15 @@ class ADTType : public TyBase\n   std::vector<StructFieldType *> &get_fields () { return fields; }\n   const std::vector<StructFieldType *> &get_fields () const { return fields; }\n \n+  void iterate_fields (std::function<bool (StructFieldType *)> cb)\n+  {\n+    for (auto &f : fields)\n+      {\n+\tif (!cb (f))\n+\t  return;\n+      }\n+  }\n+\n private:\n   std::string identifier;\n   bool is_tuple;"}, {"sha": "2cc8a19917d4a18419d244320a6121c7e7e9c1e0", "filename": "gcc/testsuite/rust.test/compilable/struct_init_4.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f6f18fe296d4729648eec0b77c8610f0b43445c/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fstruct_init_4.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f6f18fe296d4729648eec0b77c8610f0b43445c/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fstruct_init_4.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fstruct_init_4.rs?ref=4f6f18fe296d4729648eec0b77c8610f0b43445c", "patch": "@@ -0,0 +1,9 @@\n+struct Foo {\n+    a: i32,\n+    b: i32,\n+}\n+\n+fn main() {\n+    let a = Foo { a: 1, b: 2 };\n+    let b = Foo { a: 3, b: 4, ..a };\n+}"}, {"sha": "c79ea7145bf5eb19bda3e3679b3ab69c33ae4443", "filename": "gcc/testsuite/rust.test/compilable/struct_init_5.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f6f18fe296d4729648eec0b77c8610f0b43445c/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fstruct_init_5.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f6f18fe296d4729648eec0b77c8610f0b43445c/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fstruct_init_5.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fstruct_init_5.rs?ref=4f6f18fe296d4729648eec0b77c8610f0b43445c", "patch": "@@ -0,0 +1,9 @@\n+struct Foo {\n+    a: i32,\n+    b: i32,\n+}\n+\n+fn main() {\n+    let a = Foo { a: 1, b: 2 };\n+    let b = Foo { ..a };\n+}"}, {"sha": "51b90bc8b857301cf6769f7c82ab595bd3a3610e", "filename": "gcc/testsuite/rust.test/compilable/struct_init_6.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f6f18fe296d4729648eec0b77c8610f0b43445c/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fstruct_init_6.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f6f18fe296d4729648eec0b77c8610f0b43445c/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fstruct_init_6.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fstruct_init_6.rs?ref=4f6f18fe296d4729648eec0b77c8610f0b43445c", "patch": "@@ -0,0 +1,9 @@\n+struct Foo {\n+    a: i32,\n+    b: i32,\n+}\n+\n+fn main() {\n+    let a = Foo { a: 1, b: 2 };\n+    let b = Foo { a: 1, ..a };\n+}"}]}