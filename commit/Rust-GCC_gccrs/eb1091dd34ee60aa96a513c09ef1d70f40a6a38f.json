{"sha": "eb1091dd34ee60aa96a513c09ef1d70f40a6a38f", "node_id": "C_kwDOANBUbNoAKGViMTA5MWRkMzRlZTYwYWE5NmE1MTNjMDllZjFkNzBmNDBhNmEzOGY", "commit": {"author": {"name": "Steve Baird", "email": "baird@adacore.com", "date": "2022-04-29T21:55:38Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-06-01T08:43:17Z"}, "message": "[Ada] Missing discriminant checks when accessing variant field\n\nIn some cases, the compiler would incorrectly fail to generate\ndiscriminant checks when accessing fields declared in a variant part.\nCorrect some such cases; detect the remaining cases and flag them as\nunsupported. The formerly-problematic cases that are now handled\ncorrectly involve component references occurring in a predicate\nexpression (e.g., the expression of a Dynamic_Predicate aspect\nspecification) for a type declaration (not for a subtype declaration).\nThe cases which are now flagged as unsupported involve expression\nfunctions declared before the discriminated type in question has been\nfrozen.\n\ngcc/ada/\n\n\t* exp_ch3.ads: Replace visible Build_Discr_Checking_Funcs (which\n\tdid not need to be visible - it was not referenced outside this\n\tpackage) with Build_Or_Copy_Discr_Checking_Funcs.\n\t* exp_ch3.adb: Refactor existing code into 3 procedures -\n\tBuild_Discr_Checking_Funcs, Copy_Discr_Checking_Funcs, and\n\tBuild_Or_Copy_Discr_Checking_Funcs. This refactoring is intended\n\tto be semantics-preserving.\n\t* exp_ch4.adb (Expand_N_Selected_Component): Detect case where a\n\tcall should be generated to the Discriminant_Checking_Func for\n\tthe component in question, but that subprogram does not yet\n\texist.\n\t* sem_ch13.adb (Freeze_Entity_Checks): Immediately before\n\tcalling Build_Predicate_Function, add a call to\n\tExp_Ch3.Build_Or_Copy_Discr_Checking_Funcs in order to ensure\n\tthat Discriminant_Checking_Func attributes are already set when\n\tBuild_Predicate_Function is called.\n\t* sem_ch6.adb (Analyze_Expression_Function): If the expression\n\tof a static expression function has been transformed into an\n\tN_Raise_xxx_Error node, then we need to copy the original\n\texpression in order to check the requirement that the expression\n\tmust be a potentially static expression. We also want to set\n\taside a copy the untransformed expression for later use in\n\tchecking calls to the expression function via\n\tInline_Static_Function_Call.  So introduce a new function,\n\tMake_Expr_Copy, for use in these situations.\n\t* sem_res.adb (Preanalyze_And_Resolve): When analyzing certain\n\texpressions (e.g., a default parameter expression in a\n\tsubprogram declaration) we want to suppress checks. However, we\n\tdo not want to suppress checks for the expression of an\n\texpression function.", "tree": {"sha": "543602dc3a30c7e95ba44f52254dcf10c0a1b1a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/543602dc3a30c7e95ba44f52254dcf10c0a1b1a8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eb1091dd34ee60aa96a513c09ef1d70f40a6a38f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb1091dd34ee60aa96a513c09ef1d70f40a6a38f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb1091dd34ee60aa96a513c09ef1d70f40a6a38f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb1091dd34ee60aa96a513c09ef1d70f40a6a38f/comments", "author": {"login": "swbaird", "id": 50751052, "node_id": "MDQ6VXNlcjUwNzUxMDUy", "avatar_url": "https://avatars.githubusercontent.com/u/50751052?v=4", "gravatar_id": "", "url": "https://api.github.com/users/swbaird", "html_url": "https://github.com/swbaird", "followers_url": "https://api.github.com/users/swbaird/followers", "following_url": "https://api.github.com/users/swbaird/following{/other_user}", "gists_url": "https://api.github.com/users/swbaird/gists{/gist_id}", "starred_url": "https://api.github.com/users/swbaird/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/swbaird/subscriptions", "organizations_url": "https://api.github.com/users/swbaird/orgs", "repos_url": "https://api.github.com/users/swbaird/repos", "events_url": "https://api.github.com/users/swbaird/events{/privacy}", "received_events_url": "https://api.github.com/users/swbaird/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c2674cc0d725783a501a78cdc1256642448c159", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c2674cc0d725783a501a78cdc1256642448c159", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c2674cc0d725783a501a78cdc1256642448c159"}], "stats": {"total": 197, "additions": 128, "deletions": 69}, "files": [{"sha": "03ff9258926426e15565a9e15712097881b5ebca", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 54, "deletions": 34, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb1091dd34ee60aa96a513c09ef1d70f40a6a38f/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb1091dd34ee60aa96a513c09ef1d70f40a6a38f/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=eb1091dd34ee60aa96a513c09ef1d70f40a6a38f", "patch": "@@ -106,6 +106,13 @@ package body Exp_Ch3 is\n    --  types with discriminants. Otherwise new identifiers are created,\n    --  with the source names of the discriminants.\n \n+   procedure Build_Discr_Checking_Funcs (N : Node_Id);\n+   --  For each variant component, builds a function which checks whether\n+   --  the component name is consistent with the current discriminants\n+   --  and sets the component's Dcheck_Function attribute to refer to it.\n+   --  N is the full type declaration node; the discriminant checking\n+   --  functions are inserted after this node.\n+\n    function Build_Equivalent_Array_Aggregate (T : Entity_Id) return Node_Id;\n    --  This function builds a static aggregate that can serve as the initial\n    --  value for an array type whose bounds are static, and whose component\n@@ -152,6 +159,12 @@ package body Exp_Ch3 is\n    --  needed after an initialization. Typ is the component type, and Proc_Id\n    --  the initialization procedure for the enclosing composite type.\n \n+   procedure Copy_Discr_Checking_Funcs (N : Node_Id);\n+   --  For a derived untagged type, copy the attributes that were set\n+   --  for the components of the parent type onto the components of the\n+   --  derived type. No new subprograms are constructed.\n+   --  N is the full type declaration node, as for Build_Discr_Checking_Funcs.\n+\n    procedure Expand_Freeze_Array_Type (N : Node_Id);\n    --  Freeze an array type. Deals with building the initialization procedure,\n    --  creating the packed array type for a packed array and also with the\n@@ -1219,6 +1232,25 @@ package body Exp_Ch3 is\n       end if;\n    end Build_Discr_Checking_Funcs;\n \n+   ----------------------------------------\n+   -- Build_Or_Copy_Discr_Checking_Funcs --\n+   ----------------------------------------\n+\n+   procedure Build_Or_Copy_Discr_Checking_Funcs (N : Node_Id) is\n+      Typ : constant Entity_Id := Defining_Identifier (N);\n+   begin\n+      if Is_Unchecked_Union (Typ) or else not Has_Discriminants (Typ) then\n+         null;\n+      elsif not Is_Derived_Type (Typ)\n+        or else Has_New_Non_Standard_Rep (Typ)\n+        or else Is_Tagged_Type (Typ)\n+      then\n+         Build_Discr_Checking_Funcs (N);\n+      else\n+         Copy_Discr_Checking_Funcs (N);\n+      end if;\n+   end Build_Or_Copy_Discr_Checking_Funcs;\n+\n    --------------------------------\n    -- Build_Discriminant_Formals --\n    --------------------------------\n@@ -4842,6 +4874,27 @@ package body Exp_Ch3 is\n       end if;\n    end Clean_Task_Names;\n \n+   -------------------------------\n+   -- Copy_Discr_Checking_Funcs --\n+   -------------------------------\n+\n+   procedure Copy_Discr_Checking_Funcs (N : Node_Id) is\n+      Typ      : constant Entity_Id := Defining_Identifier (N);\n+      Comp     : Entity_Id := First_Component (Typ);\n+      Old_Comp : Entity_Id := First_Component\n+                                (Base_Type (Underlying_Type (Etype (Typ))));\n+   begin\n+      while Present (Comp) loop\n+         if Chars (Comp) = Chars (Old_Comp) then\n+            Set_Discriminant_Checking_Func\n+              (Comp, Discriminant_Checking_Func (Old_Comp));\n+         end if;\n+\n+         Next_Component (Old_Comp);\n+         Next_Component (Comp);\n+      end loop;\n+   end Copy_Discr_Checking_Funcs;\n+\n    ----------------------------------------\n    -- Ensure_Activation_Chain_And_Master --\n    ----------------------------------------\n@@ -5527,40 +5580,7 @@ package body Exp_Ch3 is\n       --  we copy explicitly the discriminant checking functions from the\n       --  parent into the components of the derived type.\n \n-      if not Is_Derived_Type (Typ)\n-        or else Has_New_Non_Standard_Rep (Typ)\n-        or else Is_Tagged_Type (Typ)\n-      then\n-         Build_Discr_Checking_Funcs (Typ_Decl);\n-\n-      elsif Is_Derived_Type (Typ)\n-        and then not Is_Tagged_Type (Typ)\n-\n-        --  If we have a derived Unchecked_Union, we do not inherit the\n-        --  discriminant checking functions from the parent type since the\n-        --  discriminants are non existent.\n-\n-        and then not Is_Unchecked_Union (Typ)\n-        and then Has_Discriminants (Typ)\n-      then\n-         declare\n-            Old_Comp : Entity_Id;\n-\n-         begin\n-            Old_Comp :=\n-              First_Component (Base_Type (Underlying_Type (Etype (Typ))));\n-            Comp := First_Component (Typ);\n-            while Present (Comp) loop\n-               if Chars (Comp) = Chars (Old_Comp) then\n-                  Set_Discriminant_Checking_Func\n-                    (Comp, Discriminant_Checking_Func (Old_Comp));\n-               end if;\n-\n-               Next_Component (Old_Comp);\n-               Next_Component (Comp);\n-            end loop;\n-         end;\n-      end if;\n+      Build_Or_Copy_Discr_Checking_Funcs (Typ_Decl);\n \n       if Is_Derived_Type (Typ)\n         and then Is_Limited_Type (Typ)"}, {"sha": "ca8a55076748cdd67445ae168c30d18a886dde24", "filename": "gcc/ada/exp_ch3.ads", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb1091dd34ee60aa96a513c09ef1d70f40a6a38f/gcc%2Fada%2Fexp_ch3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb1091dd34ee60aa96a513c09ef1d70f40a6a38f/gcc%2Fada%2Fexp_ch3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.ads?ref=eb1091dd34ee60aa96a513c09ef1d70f40a6a38f", "patch": "@@ -56,10 +56,15 @@ package Exp_Ch3 is\n    --  checks on the relevant aspects. The wrapper body could be simplified to\n    --  a null body when expansion is disabled ???\n \n-   procedure Build_Discr_Checking_Funcs (N : Node_Id);\n-   --  Builds function which checks whether the component name is consistent\n-   --  with the current discriminants. N is the full type declaration node,\n-   --  and the discriminant checking functions are inserted after this node.\n+   procedure Build_Or_Copy_Discr_Checking_Funcs (N : Node_Id);\n+   --  For each variant component, builds a function that checks whether\n+   --  the component name is consistent with the current discriminants\n+   --  and sets the component's Dcheck_Function attribute to refer to it.\n+   --  N is the full type declaration node; the discriminant checking\n+   --  functions are inserted after this node.\n+   --  In the case of a derived untagged type, copy the attributes that were\n+   --  set for the components of the parent type onto the components of the\n+   --  derived type; no new subprograms are constructed in this case.\n \n    function Build_Initialization_Call\n      (Loc                 : Source_Ptr;"}, {"sha": "140789a3f17ae0b52a16fd91a2a86bf9ab0a0f62", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb1091dd34ee60aa96a513c09ef1d70f40a6a38f/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb1091dd34ee60aa96a513c09ef1d70f40a6a38f/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=eb1091dd34ee60aa96a513c09ef1d70f40a6a38f", "patch": "@@ -46,6 +46,7 @@ with Exp_Tss;        use Exp_Tss;\n with Exp_Util;       use Exp_Util;\n with Freeze;         use Freeze;\n with Inline;         use Inline;\n+with Lib;            use Lib;\n with Namet;          use Namet;\n with Nlists;         use Nlists;\n with Nmake;          use Nmake;\n@@ -11008,6 +11009,16 @@ package body Exp_Ch4 is\n          --  actually performed.\n \n          else\n+            if (not Is_Unchecked_Union\n+                     (Implementation_Base_Type (Etype (Prefix (N)))))\n+              and then not Is_Predefined_Unit (Get_Source_Unit (N))\n+            then\n+               Error_Msg_N\n+                 (\"sorry - unable to generate discriminant check for\" &\n+                    \" reference to variant component &\",\n+                  Selector_Name (N));\n+            end if;\n+\n             Set_Do_Discriminant_Check (N, False);\n          end if;\n       end if;"}, {"sha": "57ff450ebc875dc708a0dfb9d17879e3ce2e3140", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb1091dd34ee60aa96a513c09ef1d70f40a6a38f/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb1091dd34ee60aa96a513c09ef1d70f40a6a38f/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=eb1091dd34ee60aa96a513c09ef1d70f40a6a38f", "patch": "@@ -33,6 +33,7 @@ with Einfo.Entities; use Einfo.Entities;\n with Einfo.Utils;    use Einfo.Utils;\n with Elists;         use Elists;\n with Errout;         use Errout;\n+with Exp_Ch3;        use Exp_Ch3;\n with Exp_Disp;       use Exp_Disp;\n with Exp_Tss;        use Exp_Tss;\n with Exp_Util;       use Exp_Util;\n@@ -13138,12 +13139,20 @@ package body Sem_Ch13 is\n             end if;\n          end;\n \n+         --  Before we build a predicate function, ensure that discriminant\n+         --  checking functions are available. The predicate function might\n+         --  need to call these functions if the predicate references\n+         --  any components declared in a variant part.\n+         if Ekind (E) = E_Record_Type and then Has_Discriminants (E) then\n+            Build_Or_Copy_Discr_Checking_Funcs (Parent (E));\n+         end if;\n+\n          Build_Predicate_Function (E, N);\n       end if;\n \n       --  If type has delayed aspects, this is where we do the preanalysis at\n       --  the freeze point, as part of the consistent visibility check. Note\n-      --  that this must be done after calling Build_Predicate_Functions or\n+      --  that this must be done after calling Build_Predicate_Function or\n       --  Build_Invariant_Procedure since these subprograms fix occurrences of\n       --  the subtype name in the saved expression so that they will not cause\n       --  trouble in the preanalysis."}, {"sha": "5a3692cc91455856227ba1089f7bf917d36469db", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 39, "deletions": 29, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb1091dd34ee60aa96a513c09ef1d70f40a6a38f/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb1091dd34ee60aa96a513c09ef1d70f40a6a38f/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=eb1091dd34ee60aa96a513c09ef1d70f40a6a38f", "patch": "@@ -570,42 +570,52 @@ package body Sem_Ch6 is\n          --  RM in 4.9(3.2/5-3.4/5) and we flag an error.\n \n          if Is_Static_Function (Def_Id) then\n-            if not Is_Static_Expression (Expr) then\n-               declare\n-                  Exp_Copy : constant Node_Id := New_Copy_Tree (Expr);\n-               begin\n-                  Set_Checking_Potentially_Static_Expression (True);\n+            declare\n+               --  If a potentially static expr like \"Parameter / 0\"\n+               --  is transformed into \"(raise Constraint_Error)\", then we\n+               --  need to copy the Original_Node.\n+               function Make_Expr_Copy return Node_Id is\n+                 (New_Copy_Tree (if Expr in N_Raise_xxx_Error_Id\n+                                 then Original_Node (Expr)\n+                                 else Expr));\n+            begin\n+               if not Is_Static_Expression (Expr) then\n+                  declare\n+                     Exp_Copy : constant Node_Id := Make_Expr_Copy;\n+                  begin\n+                     Set_Checking_Potentially_Static_Expression (True);\n \n-                  Preanalyze_Formal_Expression (Exp_Copy, Typ);\n+                     Preanalyze_Formal_Expression (Exp_Copy, Typ);\n \n-                  if not Is_Static_Expression (Exp_Copy) then\n-                     Error_Msg_N\n-                       (\"static expression function requires \"\n-                          & \"potentially static expression\", Expr);\n-                  end if;\n+                     if not Is_Static_Expression (Exp_Copy) then\n+                        Error_Msg_N\n+                          (\"static expression function requires \"\n+                             & \"potentially static expression\", Expr);\n+                     end if;\n \n-                  Set_Checking_Potentially_Static_Expression (False);\n-               end;\n-            end if;\n+                     Set_Checking_Potentially_Static_Expression (False);\n+                  end;\n+               end if;\n \n-            --  We also make an additional copy of the expression and\n-            --  replace the expression of the expression function with\n-            --  this copy, because the currently present expression is\n-            --  now associated with the body created for the static\n-            --  expression function, which will later be analyzed and\n-            --  possibly rewritten, and we need to have the separate\n-            --  unanalyzed copy available for use with later static\n-            --  calls.\n+               --  We also make an additional copy of the expression and\n+               --  replace the expression of the expression function with\n+               --  this copy, because the currently present expression is\n+               --  now associated with the body created for the static\n+               --  expression function, which will later be analyzed and\n+               --  possibly rewritten, and we need to have the separate\n+               --  unanalyzed copy available for use with later static\n+               --  calls.\n \n-            Set_Expression\n-              (Original_Node (Subprogram_Spec (Def_Id)),\n-               New_Copy_Tree (Expr));\n+               Set_Expression\n+                 (Original_Node (Subprogram_Spec (Def_Id)),\n+                  Make_Expr_Copy);\n \n-            --  Mark static expression functions as inlined, to ensure\n-            --  that even calls with nonstatic actuals will be inlined.\n+               --  Mark static expression functions as inlined, to ensure\n+               --  that even calls with nonstatic actuals will be inlined.\n \n-            Set_Has_Pragma_Inline (Def_Id);\n-            Set_Is_Inlined (Def_Id);\n+               Set_Has_Pragma_Inline (Def_Id);\n+               Set_Is_Inlined (Def_Id);\n+            end;\n          end if;\n       end if;\n "}, {"sha": "ad6d4674f24c3d629574089578b7d0e2f1bfa73c", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb1091dd34ee60aa96a513c09ef1d70f40a6a38f/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb1091dd34ee60aa96a513c09ef1d70f40a6a38f/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=eb1091dd34ee60aa96a513c09ef1d70f40a6a38f", "patch": "@@ -2060,7 +2060,11 @@ package body Sem_Res is\n       --  case of Ada 2012 constructs such as quantified expressions, which are\n       --  expanded in two separate steps.\n \n-      if GNATprove_Mode then\n+      --  We also do not want to suppress checks if we are not dealing\n+      --  with a default expression. One such case that is known to reach\n+      --  this point is the expression of an expression function.\n+\n+      if GNATprove_Mode or Nkind (Parent (N)) = N_Simple_Return_Statement then\n          Analyze_And_Resolve (N, T);\n       else\n          Analyze_And_Resolve (N, T, Suppress => All_Checks);"}]}