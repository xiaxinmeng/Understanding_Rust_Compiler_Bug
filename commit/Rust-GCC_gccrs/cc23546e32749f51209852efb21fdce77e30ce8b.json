{"sha": "cc23546e32749f51209852efb21fdce77e30ce8b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2MyMzU0NmUzMjc0OWY1MTIwOTg1MmVmYjIxZmRjZTc3ZTMwY2U4Yg==", "commit": {"author": {"name": "Jeffrey D. Oldham", "email": "oldham@codesourcery.com", "date": "2003-01-16T22:06:04Z"}, "committer": {"name": "Jeffrey D. Oldham", "email": "oldham@gcc.gnu.org", "date": "2003-01-16T22:06:04Z"}, "message": "cp-tree.h (tsubst_copy_and_build): New declaration.\n\n2003-01-16  Jeffrey D. Oldham  <oldham@codesourcery.com>\n\n\t* cp-tree.h (tsubst_copy_and_build): New declaration.\n\t* pt.c (tsubst_copy): Remove 'build_expr_from_tree' from comment.\n\t(tsubst_expr): Use 'tsubst_copy_and_build'.  Update initial comment.\n\t(tsubst_copy_and_build): New function.\n\nFrom-SVN: r61409", "tree": {"sha": "2825cb39844697c8b48feb8259808caec5a5e81a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2825cb39844697c8b48feb8259808caec5a5e81a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc23546e32749f51209852efb21fdce77e30ce8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc23546e32749f51209852efb21fdce77e30ce8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc23546e32749f51209852efb21fdce77e30ce8b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc23546e32749f51209852efb21fdce77e30ce8b/comments", "author": null, "committer": null, "parents": [{"sha": "f411c7397a06c22f1d925019b6fdf8014e6e4dc5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f411c7397a06c22f1d925019b6fdf8014e6e4dc5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f411c7397a06c22f1d925019b6fdf8014e6e4dc5"}], "stats": {"total": 524, "additions": 517, "deletions": 7}, "files": [{"sha": "54d66be0600c9f01819080e93be8ed58e57ad342", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc23546e32749f51209852efb21fdce77e30ce8b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc23546e32749f51209852efb21fdce77e30ce8b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=cc23546e32749f51209852efb21fdce77e30ce8b", "patch": "@@ -1,3 +1,10 @@\n+2003-01-16  Jeffrey D. Oldham  <oldham@codesourcery.com>\n+\n+\t* cp-tree.h (tsubst_copy_and_build): New declaration.\n+\t* pt.c (tsubst_copy): Remove 'build_expr_from_tree' from comment.\n+\t(tsubst_expr): Use 'tsubst_copy_and_build'.  Update initial comment.\n+\t(tsubst_copy_and_build): New function.\n+\n 2003-01-16  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.h (lang_type_class): Remove is_partial_instantiation."}, {"sha": "9d0676358aca8d37eaf6f9b650aa3d748088a888", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc23546e32749f51209852efb21fdce77e30ce8b/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc23546e32749f51209852efb21fdce77e30ce8b/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=cc23546e32749f51209852efb21fdce77e30ce8b", "patch": "@@ -4025,6 +4025,7 @@ extern tree get_innermost_template_args         (tree, int);\n extern tree tsubst\t\t\t\t(tree, tree, tsubst_flags_t, tree);\n extern tree tsubst_expr\t\t\t\t(tree, tree, tsubst_flags_t, tree);\n extern tree tsubst_copy\t\t\t\t(tree, tree, tsubst_flags_t, tree);\n+extern tree tsubst_copy_and_build\t\t(tree, tree, tsubst_flags_t, tree);\n extern void maybe_begin_member_template_processing (tree);\n extern void maybe_end_member_template_processing (void);\n extern tree finish_member_template_decl         (tree);"}, {"sha": "c0376765132787aeb6a50c3a0014223991762e5d", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 509, "deletions": 7, "changes": 516, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc23546e32749f51209852efb21fdce77e30ce8b/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc23546e32749f51209852efb21fdce77e30ce8b/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=cc23546e32749f51209852efb21fdce77e30ce8b", "patch": "@@ -1,6 +1,6 @@\n /* Handle parameterized types (templates) for GNU C++.\n    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,\n-   2001, 2002  Free Software Foundation, Inc.\n+   2001, 2002, 2003  Free Software Foundation, Inc.\n    Written by Ken Raeburn (raeburn@cygnus.com) while at Watchmaker Computing.\n    Rewritten by Jason Merrill (jason@cygnus.com).\n \n@@ -7360,11 +7360,10 @@ tsubst_copy (t, args, complain, in_decl)\n \t NULL_TREE);\n \n     case STMT_EXPR:\n-      /* This processing should really occur in tsubst_expr, However,\n+      /* This processing should really occur in tsubst_expr.  However,\n \t tsubst_expr does not recurse into expressions, since it\n-\t assumes that there aren't any statements inside them.\n-\t Instead, it simply calls build_expr_from_tree.  So, we need\n-\t to expand the STMT_EXPR here.  */\n+\t assumes that there aren't any statements inside them.  So, we\n+\t need to expand the STMT_EXPR here.  */\n       if (!processing_template_decl)\n \t{\n \t  tree stmt_expr = begin_stmt_expr ();\n@@ -7501,7 +7500,8 @@ tsubst_copy (t, args, complain, in_decl)\n     }\n }\n \n-/* Like tsubst_copy, but also does semantic processing.  */\n+/* Like tsubst_copy for expressions, etc. but also does semantic\n+   processing.  */\n \n tree\n tsubst_expr (t, args, complain, in_decl)\n@@ -7518,7 +7518,7 @@ tsubst_expr (t, args, complain, in_decl)\n     return tsubst_copy (t, args, complain, in_decl);\n \n   if (!statement_code_p (TREE_CODE (t)))\n-    return build_expr_from_tree (tsubst_copy (t, args, complain, in_decl));\n+    return tsubst_copy_and_build (t, args, complain, in_decl);\n     \n   switch (TREE_CODE (t))\n     {\n@@ -7827,6 +7827,508 @@ tsubst_expr (t, args, complain, in_decl)\n   return tsubst_expr (TREE_CHAIN (t), args, complain, in_decl);\n }\n \n+/* Like tsubst but deals with expressions and performs semantic\n+   analysis.  */\n+\n+tree\n+tsubst_copy_and_build (t, args, complain, in_decl)\n+     tree t, args;\n+     tsubst_flags_t complain;\n+     tree in_decl;\n+{\n+  if (t == NULL_TREE || t == error_mark_node)\n+    return t;\n+\n+  switch (TREE_CODE (t))\n+    {\n+    case IDENTIFIER_NODE:\n+      if (IDENTIFIER_TYPENAME_P (t))\n+\t{\n+\t  tree new_type = tsubst (TREE_TYPE (t), args, complain, in_decl);\n+\t  return do_identifier (mangle_conv_op_name_for_type (new_type),\n+\t\t\t\tNULL_TREE);\n+\t}\n+      else\n+\treturn do_identifier (t, NULL_TREE);\n+\n+    case LOOKUP_EXPR:\n+      {\n+\tif (LOOKUP_EXPR_GLOBAL (t))\n+\t  {\n+\t    tree token\n+\t      = tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl);\n+\t    return do_scoped_id (token, IDENTIFIER_GLOBAL_VALUE (token));\n+\t  }\n+\telse\n+\t  {\n+\t    t = do_identifier\n+\t      (tsubst_copy\n+\t       (TREE_OPERAND (t, 0), args, complain, in_decl),\n+\t       NULL_TREE);\n+\t    if (TREE_CODE (t) == ALIAS_DECL)\n+\t      t = DECL_INITIAL (t);\n+\t    return t;\n+\t  }\n+      }\n+\n+    case TEMPLATE_ID_EXPR:\n+      {\n+\ttree object;\n+\ttree template\n+\t  = tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl);\n+\t\n+\tif (TREE_CODE (template) == COMPONENT_REF)\n+\t  {\n+\t    object = TREE_OPERAND (template, 0);\n+\t    template = TREE_OPERAND (template, 1);\n+\t  }\n+\telse\n+\t  object = NULL_TREE;\n+\n+\ttemplate = lookup_template_function\n+\t  (template,\n+\t   tsubst_copy (TREE_OPERAND (t, 1), args, complain, in_decl));\n+\t\n+\tif (object)\n+\t  return build (COMPONENT_REF, TREE_TYPE (template), \n+\t\t\tobject, template);\n+\telse\n+\t  return template;\n+      }\n+\n+    case INDIRECT_REF:\n+      return build_x_indirect_ref\n+\t(tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain, in_decl),\n+\t \"unary *\");\n+\n+    case CAST_EXPR:\n+      return build_functional_cast\n+\t(tsubst (TREE_TYPE (t), args, complain, in_decl),\n+\t tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain, in_decl));\n+\n+    case REINTERPRET_CAST_EXPR:\n+      return build_reinterpret_cast\n+\t(tsubst (TREE_TYPE (t), args, complain, in_decl),\n+\t tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain, in_decl));\n+\n+    case CONST_CAST_EXPR:\n+      return build_const_cast\n+\t(tsubst (TREE_TYPE (t), args, complain, in_decl),\n+\t tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain, in_decl));\n+\n+    case DYNAMIC_CAST_EXPR:\n+      return build_dynamic_cast\n+\t(tsubst (TREE_TYPE (t), args, complain, in_decl),\n+\t tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain, in_decl));\n+\n+    case STATIC_CAST_EXPR:\n+      return build_static_cast\n+\t(tsubst (TREE_TYPE (t), args, complain, in_decl),\n+\t tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain, in_decl));\n+\n+    case PREDECREMENT_EXPR:\n+    case PREINCREMENT_EXPR:\n+    case POSTDECREMENT_EXPR:\n+    case POSTINCREMENT_EXPR:\n+      if (TREE_TYPE (t))\n+\treturn tsubst_copy (t, args, complain, in_decl);\n+      else\n+\treturn build_x_unary_op\n+\t  (TREE_CODE (t),\n+\t   tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain,\n+\t\t\t\t  in_decl));\n+\n+    case NEGATE_EXPR:\n+    case BIT_NOT_EXPR:\n+      if (TREE_TYPE (t))\n+\treturn tsubst_copy (t, args, complain, in_decl);\n+      else\n+\treturn build_x_unary_op\n+\t  (TREE_CODE (t),\n+\t   tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain,\n+\t\t\t\t  in_decl));\n+\n+    case ABS_EXPR:\n+      if (TREE_TYPE (t))\n+\treturn t;\n+      return build_x_unary_op\n+\t(TREE_CODE (t),\n+\t tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain, in_decl));\n+\n+    case TRUTH_NOT_EXPR:\n+    case ADDR_EXPR:\n+    case CONVERT_EXPR:  /* Unary + */\n+    case REALPART_EXPR:\n+    case IMAGPART_EXPR:\n+      if (TREE_TYPE (t))\n+\treturn tsubst_copy (t, args, complain, in_decl);\n+      else\n+\treturn build_x_unary_op\n+\t  (TREE_CODE (t),\n+\t   tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain,\n+\t\t\t\t  in_decl));\n+\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+    case MULT_EXPR:\n+    case TRUNC_DIV_EXPR:\n+    case CEIL_DIV_EXPR:\n+    case FLOOR_DIV_EXPR:\n+    case ROUND_DIV_EXPR:\n+    case EXACT_DIV_EXPR:\n+    case BIT_AND_EXPR:\n+    case BIT_ANDTC_EXPR:\n+    case BIT_IOR_EXPR:\n+    case BIT_XOR_EXPR:\n+    case TRUNC_MOD_EXPR:\n+    case FLOOR_MOD_EXPR:\n+    case TRUTH_ANDIF_EXPR:\n+    case TRUTH_ORIF_EXPR:\n+    case TRUTH_AND_EXPR:\n+    case TRUTH_OR_EXPR:\n+    case RSHIFT_EXPR:\n+    case LSHIFT_EXPR:\n+    case RROTATE_EXPR:\n+    case LROTATE_EXPR:\n+    case EQ_EXPR:\n+    case NE_EXPR:\n+    case MAX_EXPR:\n+    case MIN_EXPR:\n+    case LE_EXPR:\n+    case GE_EXPR:\n+    case LT_EXPR:\n+    case GT_EXPR:\n+    case MEMBER_REF:\n+      return build_x_binary_op\n+\t(TREE_CODE (t), \n+\t tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain, in_decl),\n+\t tsubst_copy_and_build (TREE_OPERAND (t, 1), args, complain, in_decl));\n+\n+    case DOTSTAR_EXPR:\n+      return build_m_component_ref\n+\t(tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain, in_decl),\n+\t tsubst_copy_and_build (TREE_OPERAND (t, 1), args, complain, in_decl));\n+\n+    case SCOPE_REF:\n+      return build_offset_ref\n+\t(tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl),\n+\t tsubst_copy (TREE_OPERAND (t, 1), args, complain, in_decl));\n+\n+    case ARRAY_REF:\n+      {\n+\tif (tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl)\n+\t    == NULL_TREE)\n+\t  /* new-type-id */\n+\t  return build_nt\n+\t    (ARRAY_REF, NULL_TREE,\n+\t     tsubst_copy_and_build (TREE_OPERAND (t, 1), args, complain,\n+\t\t\t\t    in_decl));\n+\t\n+\treturn grok_array_decl\n+\t  (tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain,\n+\t\t\t\t  in_decl),\n+\t   tsubst_copy_and_build (TREE_OPERAND (t, 1), args, complain,\n+\t\t\t\t  in_decl));\n+      }\n+\n+    case SIZEOF_EXPR:\n+    case ALIGNOF_EXPR:\n+      {\n+\ttree r =\n+\t  tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain, in_decl);\n+\tif (!TYPE_P (r))\n+\t  return TREE_CODE (t) == SIZEOF_EXPR ?\n+\t    expr_sizeof (r) : c_alignof_expr (r);\n+\telse\n+\t  return cxx_sizeof_or_alignof_type (r, TREE_CODE (t), true);\n+      }\n+\n+    case MODOP_EXPR:\n+      return build_x_modify_expr\n+\t(tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain, in_decl),\n+\t TREE_CODE (TREE_OPERAND (t, 1)),\n+\t tsubst_copy_and_build (TREE_OPERAND (t, 2), args, complain, in_decl));\n+\n+    case ARROW_EXPR:\n+      return build_x_arrow\n+\t(tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain, in_decl));\n+\n+    case NEW_EXPR:\n+      return build_new\n+\t(tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain, in_decl),\n+\t tsubst_copy_and_build (TREE_OPERAND (t, 1), args, complain, in_decl),\n+\t tsubst_copy_and_build (TREE_OPERAND (t, 2), args, complain, in_decl),\n+\t NEW_EXPR_USE_GLOBAL (t));\n+\n+    case DELETE_EXPR:\n+     return delete_sanity\n+       (tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain, in_decl),\n+\ttsubst_copy_and_build (TREE_OPERAND (t, 1), args, complain, in_decl),\n+\tDELETE_EXPR_USE_VEC (t),\n+\tDELETE_EXPR_USE_GLOBAL (t));\n+\n+    case COMPOUND_EXPR:\n+      {\n+\tif (tsubst_copy (TREE_OPERAND (t, 1), args, complain, in_decl)\n+\t    == NULL_TREE)\n+\t  return build_x_compound_expr\n+\t    (tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain,\n+\t\t\t\t    in_decl));\n+\telse\n+\t  abort ();\n+      }\n+\n+    case METHOD_CALL_EXPR:\n+      {\n+\ttree method\n+\t  = tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl);\n+\t\n+\tif (TREE_CODE (method) == SCOPE_REF)\n+\t  {\n+\t    tree name = TREE_OPERAND (method, 1);\n+\t  \n+\t    if (TREE_CODE (name) == TEMPLATE_ID_EXPR)\n+\t      name = build_nt (TEMPLATE_ID_EXPR,\n+\t\t\t       TREE_OPERAND (name, 0),\n+\t\t\t       TREE_OPERAND (name, 1));\n+\t    \n+\t    return build_scoped_method_call\n+\t      (tsubst_copy_and_build\n+\t       (TREE_OPERAND (t, 1), args, complain, in_decl),\n+\t       TREE_OPERAND (method, 0),\n+\t       name,\n+\t       tsubst_copy_and_build\n+\t       (TREE_OPERAND (t, 2), args, complain, in_decl));\n+\t  }\n+\telse \n+\t  {\n+\t    /* We can get a TEMPLATE_ID_EXPR here on code like:\n+\n+\t    x->f<2>();\n+\t      \n+\t    so we must resolve that.  However, we can also get things\n+\t    like a BIT_NOT_EXPR here, when referring to a destructor,\n+\t    and things like that are not correctly resolved by this\n+\t    function so just use it when we really need it.  */\n+\t    if (TREE_CODE (method) == TEMPLATE_ID_EXPR)\n+\t      method = lookup_template_function\n+\t\t(TREE_OPERAND (method, 0),\n+\t\t TREE_OPERAND (method, 1));\n+\n+\t    return build_method_call\n+\t      (tsubst_copy_and_build\n+\t       (TREE_OPERAND (t, 1), args, complain, in_decl),\n+\t       method,\n+\t       tsubst_copy_and_build\n+\t       (TREE_OPERAND (t, 2), args, complain, in_decl),\n+\t       NULL_TREE, LOOKUP_NORMAL);\n+\t  }\n+      }\n+\n+    case CALL_EXPR:\n+      {\n+\ttree function\n+\t  = tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl);\n+\tif (TREE_CODE (function) == SCOPE_REF)\n+\t  {\n+\t    tree name = TREE_OPERAND (function, 1);\n+\t    if (TREE_CODE (name) == TEMPLATE_ID_EXPR)\n+\t      name = build_nt (TEMPLATE_ID_EXPR,\n+\t\t\t       TREE_OPERAND (name, 0),\n+\t\t\t       TREE_OPERAND (name, 1));\n+\n+\t    return build_call_from_tree\n+\t      (resolve_scoped_fn_name (TREE_OPERAND (function, 0), name),\n+\t       tsubst_copy_and_build (TREE_OPERAND (t, 1), args, complain,\n+\t\t\t\t      in_decl),\n+\t       1);\n+\t  }\n+\telse\n+\t  {\n+\t    tree name = function;\n+\t    tree id;\n+\t    tree copy_args = tsubst_copy_and_build\n+\t      (TREE_OPERAND (t, 1), args, complain, in_decl);\n+\t    if (copy_args != NULL_TREE && TREE_CODE (name) == LOOKUP_EXPR\n+\t\t&& !LOOKUP_EXPR_GLOBAL (name)\n+\t\t&& (TREE_CODE ((id = TREE_OPERAND (name, 0)))\n+\t\t    == IDENTIFIER_NODE)\n+\t\t&& (!current_class_type\n+\t\t    || !lookup_member (current_class_type, id, 0, 0)))\n+\t      {\n+\t\t/* Do Koenig lookup if there are no class members.  */\n+\t\tname = do_identifier (id, copy_args);\n+\t      }\n+\t    else if (TREE_CODE (name) == TEMPLATE_ID_EXPR\n+\t\t     || ! really_overloaded_fn (name))\n+\t      name = build_expr_from_tree (name);\n+\n+\t    if (TREE_CODE (name) == OFFSET_REF)\n+\t      return build_offset_ref_call_from_tree (name, copy_args);\n+\t    if (TREE_CODE (name) == COMPONENT_REF)\n+\t      return finish_object_call_expr (TREE_OPERAND (name, 1),\n+\t\t\t\t\t      TREE_OPERAND (name, 0),\n+\t\t\t\t\t      copy_args);\n+\t    name = convert_from_reference (name);\n+\t    return build_call_from_tree (name, copy_args, \n+\t\t\t\t\t /*disallow_virtual=*/false);\n+\t  }\n+      }\n+\n+    case COND_EXPR:\n+      return build_x_conditional_expr\n+\t(tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain, in_decl),\n+\t tsubst_copy_and_build (TREE_OPERAND (t, 1), args, complain, in_decl),\n+\t tsubst_copy_and_build (TREE_OPERAND (t, 2), args, complain, in_decl));\n+\n+    case PSEUDO_DTOR_EXPR:\n+      return finish_pseudo_destructor_expr \n+\t(tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain, in_decl),\n+\t tsubst_copy_and_build (TREE_OPERAND (t, 1), args, complain, in_decl),\n+\t tsubst_copy_and_build (TREE_OPERAND (t, 2), args, complain, in_decl));\n+\n+    case TREE_LIST:\n+      {\n+\ttree purpose, value, chain;\n+\n+\tif (t == void_list_node)\n+\t  return t;\n+\n+\tpurpose = TREE_PURPOSE (t);\n+\tif (purpose)\n+\t  purpose = tsubst_copy_and_build (purpose, args, complain, in_decl);\n+\tvalue = TREE_VALUE (t);\n+\tif (value)\n+\t  value = tsubst_copy_and_build (value, args, complain, in_decl);\n+\tchain = TREE_CHAIN (t);\n+\tif (chain && chain != void_type_node)\n+\t  chain = tsubst_copy_and_build (chain, args, complain, in_decl);\n+\tif (purpose == TREE_PURPOSE (t)\n+\t    && value == TREE_VALUE (t)\n+\t    && chain == TREE_CHAIN (t))\n+\t  return t;\n+\treturn tree_cons (purpose, value, chain);\n+      }\n+\n+    case COMPONENT_REF:\n+      {\n+\ttree object =\n+\t  tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain, in_decl);\n+\ttree member =\n+\t  tsubst_copy (TREE_OPERAND (t, 1), args, complain, in_decl);\n+\n+\tif (!CLASS_TYPE_P (TREE_TYPE (object)))\n+\t  {\n+\t    if (TREE_CODE (member) == BIT_NOT_EXPR)\n+\t      return finish_pseudo_destructor_expr (object, \n+\t\t\t\t\t\t    NULL_TREE,\n+\t\t\t\t\t\t    TREE_TYPE (object));\n+\t    else if (TREE_CODE (member) == SCOPE_REF\n+\t\t     && (TREE_CODE (TREE_OPERAND (member, 1)) == BIT_NOT_EXPR))\n+\t      return finish_pseudo_destructor_expr (object, \n+\t\t\t\t\t\t    object,\n+\t\t\t\t\t\t    TREE_TYPE (object));\n+\t  }\n+\telse if (TREE_CODE (member) == SCOPE_REF\n+\t\t && TREE_CODE (TREE_OPERAND (member, 1)) == TEMPLATE_ID_EXPR)\n+\t  {\n+\t    tree tmpl;\n+\t    tree args;\n+\t\n+\t    /* Lookup the template functions now that we know what the\n+\t       scope is.  */\n+\t    tmpl = TREE_OPERAND (TREE_OPERAND (member, 1), 0);\n+\t    args = TREE_OPERAND (TREE_OPERAND (member, 1), 1);\n+\t    member = lookup_qualified_name (TREE_OPERAND (member, 0),\n+\t\t\t\t\t    tmpl, \n+\t\t\t\t\t    /*is_type=*/0,\n+\t\t\t\t\t    /*flags=*/0);\n+\t    if (BASELINK_P (member))\n+\t      BASELINK_FUNCTIONS (member) \n+\t\t= build_nt (TEMPLATE_ID_EXPR, BASELINK_FUNCTIONS (member),\n+\t\t\t    args);\n+\t    else\n+\t      {\n+\t\terror (\"`%D' is not a member of `%T'\",\n+\t\t       tmpl, TREE_TYPE (object));\n+\t\treturn error_mark_node;\n+\t      }\n+\t  }\n+\n+\treturn finish_class_member_access_expr (object, member);\n+      }\n+\n+    case THROW_EXPR:\n+      return build_throw\n+\t(tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain, in_decl));\n+\n+    case CONSTRUCTOR:\n+      {\n+\ttree r;\n+\ttree elts;\n+\ttree type = tsubst (TREE_TYPE (t), args, complain, in_decl);\n+\tbool purpose_p;\n+\n+\t/* digest_init will do the wrong thing if we let it.  */\n+\tif (type && TYPE_PTRMEMFUNC_P (type))\n+\t  return t;\n+\n+\tr = NULL_TREE;\n+\t/* We do not want to process the purpose of aggregate\n+\t   initializers as they are identifier nodes which will be\n+\t   looked up by digest_init.  */\n+\tpurpose_p = !(type && IS_AGGR_TYPE (type));\n+\tfor (elts = tsubst_copy (CONSTRUCTOR_ELTS (t), args, complain,\n+\t\t\t\t in_decl);\n+\t     elts;\n+\t     elts = TREE_CHAIN (elts))\n+\t  {\n+\t    tree purpose = TREE_PURPOSE (elts);\n+\t    tree value = TREE_VALUE (elts);\n+\t    \n+\t    if (purpose && purpose_p)\n+\t      purpose\n+\t\t= tsubst_copy_and_build (purpose, args, complain, in_decl);\n+\t    value = tsubst_copy_and_build (value, args, complain, in_decl);\n+\t    r = tree_cons (purpose, value, r);\n+\t  }\n+\t\n+\tr = build_nt (CONSTRUCTOR, NULL_TREE, nreverse (r));\n+\tTREE_HAS_CONSTRUCTOR (r) = TREE_HAS_CONSTRUCTOR (t);\n+\n+\tif (type)\n+\t  return digest_init (type, r, 0);\n+\treturn r;\n+      }\n+\n+    case TYPEID_EXPR:\n+      {\n+\ttree operand_0\n+\t  = tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain,\n+\t\t\t\t   in_decl);\n+\t\n+\tif (TYPE_P (operand_0))\n+\t  return get_typeid (operand_0);\n+\treturn build_typeid (operand_0);\n+      }\n+\n+    case PARM_DECL:\n+      return convert_from_reference (tsubst_copy (t, args, complain, in_decl));\n+\n+    case VAR_DECL:\n+      return convert_from_reference (tsubst_copy (t, args, complain, in_decl));\n+\n+    case VA_ARG_EXPR:\n+\treturn build_x_va_arg\n+\t  (tsubst_copy_and_build\n+\t   (TREE_OPERAND (t, 0), args, complain, in_decl),\n+\t   tsubst_copy (TREE_TYPE (t), args, complain, in_decl));\n+\n+    default:\n+      return tsubst_copy (t, args, complain, in_decl);\n+    }\n+}\n+\n /* Instantiate the indicated variable or function template TMPL with\n    the template arguments in TARG_PTR.  */\n "}]}