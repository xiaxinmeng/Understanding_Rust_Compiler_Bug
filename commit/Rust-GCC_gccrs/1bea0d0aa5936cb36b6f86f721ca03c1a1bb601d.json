{"sha": "1bea0d0aa5936cb36b6f86f721ca03c1a1bb601d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWJlYTBkMGFhNTkzNmNiMzZiNmY4NmY3MjFjYTAzYzFhMWJiNjAxZA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-11-20T11:28:34Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-11-20T11:28:34Z"}, "message": "c++: Add __builtin_clear_padding builtin - C++20 P0528R3 compiler side [PR88101]\n\nThe following patch implements __builtin_clear_padding builtin that clears\nthe padding bits in object representation (but preserves value\nrepresentation).  Inside of unions it clears only those padding bits that\nare padding for all the union members (so that it never alters value\nrepresentation).\n\nIt handles trailing padding, padding in the middle of structs including\nbitfields (PDP11 unhandled, I've never figured out how those bitfields\nwork), VLAs (doesn't handle variable length structures, but I think almost\nnobody uses them and it isn't worth the extra complexity).  For VLAs and\nsufficiently large arrays it uses runtime clearing loop instead of emitting\nstraight-line code (unless arrays are inside of a union).\n\nThe way I think this can be used for atomics is e.g. if the structures\nare power of two sized and small enough that we use the hw atomics\nfor say compare_exchange __builtin_clear_padding could be called first on\nthe address of expected and desired arguments (for desired only if we want\nto ensure that most of the time the atomic memory will have padding bits\ncleared), then perform the weak cmpxchg and if that fails, we got the\nvalue from the atomic memory; we can call __builtin_clear_padding on a copy\nof that and then compare it with expected, and if it is the same with the\npadding bits masked off, we can use the original with whatever random\npadding bits in it as the new expected for next cmpxchg.\n__builtin_clear_padding itself is not atomic and therefore it shouldn't\nbe called on the atomic memory itself, but compare_exchange*'s expected\nargument is a reference and normally the implementation may store there\nthe current value from memory, so padding bits can be cleared in that,\nand desired is passed by value rather than reference, so clearing is fine\ntoo.\nWhen using libatomic, we can use it either that way, or add new libatomic\nAPIs that accept another argument, pointer to the padding bit bitmask,\nand construct that in the template as\n  alignas (_T) unsigned char _mask[sizeof (_T)];\n  std::memset (_mask, ~0, sizeof (_mask));\n  __builtin_clear_padding ((_T *) _mask);\nwhich will have bits cleared for padding bits and set for bits taking part\nin the value representation.  Then libatomic could internally instead\nof using memcmp compare\nfor (i = 0; i < N; i++) if ((val1[i] & mask[i]) != (val2[i] & mask[i]))\n\n2020-11-20  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR libstdc++/88101\ngcc/\n\t* builtins.def (BUILT_IN_CLEAR_PADDING): New built-in function.\n\t* gimplify.c (gimplify_call_expr): Rewrite single argument\n\tBUILT_IN_CLEAR_PADDING into two-argument variant.\n\t* gimple-fold.c (clear_padding_unit, clear_padding_buf_size): New\n\tconst variables.\n\t(struct clear_padding_struct): New type.\n\t(clear_padding_flush, clear_padding_add_padding,\n\tclear_padding_emit_loop, clear_padding_type,\n\tclear_padding_union, clear_padding_real_needs_padding_p,\n\tclear_padding_type_may_have_padding_p,\n\tgimple_fold_builtin_clear_padding): New functions.\n\t(gimple_fold_builtin): Handle BUILT_IN_CLEAR_PADDING.\n\t* doc/extend.texi (__builtin_clear_padding): Document.\ngcc/c-family/\n\t* c-common.c (check_builtin_function_arguments): Handle\n\tBUILT_IN_CLEAR_PADDING.\ngcc/testsuite/\n\t* c-c++-common/builtin-clear-padding-1.c: New test.\n\t* c-c++-common/torture/builtin-clear-padding-1.c: New test.\n\t* c-c++-common/torture/builtin-clear-padding-2.c: New test.\n\t* c-c++-common/torture/builtin-clear-padding-3.c: New test.\n\t* c-c++-common/torture/builtin-clear-padding-4.c: New test.\n\t* c-c++-common/torture/builtin-clear-padding-5.c: New test.\n\t* g++.dg/torture/builtin-clear-padding-1.C: New test.\n\t* g++.dg/torture/builtin-clear-padding-2.C: New test.\n\t* gcc.dg/builtin-clear-padding-1.c: New test.", "tree": {"sha": "db6975161a73f1ae9aa492f44112ee55a5ea3e59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db6975161a73f1ae9aa492f44112ee55a5ea3e59"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1bea0d0aa5936cb36b6f86f721ca03c1a1bb601d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bea0d0aa5936cb36b6f86f721ca03c1a1bb601d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1bea0d0aa5936cb36b6f86f721ca03c1a1bb601d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bea0d0aa5936cb36b6f86f721ca03c1a1bb601d/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "410b8f6f41920dad200cd709f9f3de8b840a995c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/410b8f6f41920dad200cd709f9f3de8b840a995c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/410b8f6f41920dad200cd709f9f3de8b840a995c"}], "stats": {"total": 1094, "additions": 1094, "deletions": 0}, "files": [{"sha": "04dbe7909437fce699a33b2b6838b1e98d64dd38", "filename": "gcc/builtins.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bea0d0aa5936cb36b6f86f721ca03c1a1bb601d/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bea0d0aa5936cb36b6f86f721ca03c1a1bb601d/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=1bea0d0aa5936cb36b6f86f721ca03c1a1bb601d", "patch": "@@ -839,6 +839,7 @@ DEF_EXT_LIB_BUILTIN    (BUILT_IN_CLEAR_CACHE, \"__clear_cache\", BT_FN_VOID_PTR_PT\n /* [trans-mem]: Adjust BUILT_IN_TM_CALLOC if BUILT_IN_CALLOC is changed.  */\n DEF_LIB_BUILTIN        (BUILT_IN_CALLOC, \"calloc\", BT_FN_PTR_SIZE_SIZE, ATTR_MALLOC_WARN_UNUSED_RESULT_SIZE_1_2_NOTHROW_LEAF_LIST)\n DEF_GCC_BUILTIN        (BUILT_IN_CLASSIFY_TYPE, \"classify_type\", BT_FN_INT_VAR, ATTR_LEAF_LIST)\n+DEF_GCC_BUILTIN        (BUILT_IN_CLEAR_PADDING, \"clear_padding\", BT_FN_VOID_VAR, ATTR_NOTHROW_NONNULL_TYPEGENERIC_LEAF)\n DEF_GCC_BUILTIN        (BUILT_IN_CLZ, \"clz\", BT_FN_INT_UINT, ATTR_CONST_NOTHROW_LEAF_LIST)\n DEF_GCC_BUILTIN        (BUILT_IN_CLZIMAX, \"clzimax\", BT_FN_INT_UINTMAX, ATTR_CONST_NOTHROW_LEAF_LIST)\n DEF_GCC_BUILTIN        (BUILT_IN_CLZL, \"clzl\", BT_FN_INT_ULONG, ATTR_CONST_NOTHROW_LEAF_LIST)"}, {"sha": "5d1e4ef289c481267aaa857b8b8125d899eb10d6", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bea0d0aa5936cb36b6f86f721ca03c1a1bb601d/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bea0d0aa5936cb36b6f86f721ca03c1a1bb601d/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=1bea0d0aa5936cb36b6f86f721ca03c1a1bb601d", "patch": "@@ -6178,6 +6178,39 @@ check_builtin_function_arguments (location_t loc, vec<location_t> arg_loc,\n \t}\n       return false;\n \n+    case BUILT_IN_CLEAR_PADDING:\n+      if (builtin_function_validate_nargs (loc, fndecl, nargs, 1))\n+\t{\n+\t  if (!POINTER_TYPE_P (TREE_TYPE (args[0])))\n+\t    {\n+\t      error_at (ARG_LOCATION (0), \"argument %u in call to function \"\n+\t\t\t\"%qE does not have pointer type\", 1, fndecl);\n+\t      return false;\n+\t    }\n+\t  else if (!COMPLETE_TYPE_P (TREE_TYPE (TREE_TYPE (args[0]))))\n+\t    {\n+\t      error_at (ARG_LOCATION (0), \"argument %u in call to function \"\n+\t\t\t\"%qE points to incomplete type\", 1, fndecl);\n+\t      return false;\n+\t    }\n+\t  else if (TYPE_READONLY (TREE_TYPE (TREE_TYPE (args[0]))))\n+\t    {\n+\t      error_at (ARG_LOCATION (0), \"argument %u in call to function %qE \"\n+\t\t\t\"has pointer to %qs type (%qT)\", 1, fndecl, \"const\",\n+\t\t\tTREE_TYPE (args[0]));\n+\t      return false;\n+\t    }\n+\t  else if (TYPE_ATOMIC (TREE_TYPE (TREE_TYPE (args[0]))))\n+\t    {\n+\t      error_at (ARG_LOCATION (0), \"argument %u in call to function %qE \"\n+\t\t\t\"has pointer to %qs type (%qT)\", 1, fndecl,\n+\t\t\t\"_Atomic\", TREE_TYPE (args[0]));\n+\t      return false;\n+\t    }\n+\t  return true;\n+\t}\n+      return false;\n+\n     default:\n       return true;\n     }"}, {"sha": "f0269422ca21aeb95cf697e7fff87b161b8b7a42", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bea0d0aa5936cb36b6f86f721ca03c1a1bb601d/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bea0d0aa5936cb36b6f86f721ca03c1a1bb601d/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=1bea0d0aa5936cb36b6f86f721ca03c1a1bb601d", "patch": "@@ -13564,6 +13564,19 @@ initializers of variables usable in constant expressions.   For more details\n refer to the latest revision of the C++ standard.\n @end deftypefn\n \n+@deftypefn {Built-in Function} void __builtin_clear_padding (@var{ptr})\n+The built-in function @code{__builtin_clear_padding} function clears\n+padding bits inside of the object representation of object pointed by\n+@var{ptr}, which has to be a pointer.  The value representation of the\n+object is not affected.  The type of the object is assumed to be the type\n+the pointer points to.  Inside of a union, the only cleared bits are\n+bits that are padding bits for all the union members.\n+\n+This built-in-function is useful if the padding bits of an object might\n+have intederminate values and the object representation needs to be\n+bitwise compared to some other object, for example for atomic operations.\n+@end deftypefn\n+\n @deftypefn {Built-in Function} long __builtin_expect (long @var{exp}, long @var{c})\n @opindex fprofile-arcs\n You may use @code{__builtin_expect} to provide the compiler with"}, {"sha": "5d60bef285a0c69ecb47108845d8299e53260a0c", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 695, "deletions": 0, "changes": 695, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bea0d0aa5936cb36b6f86f721ca03c1a1bb601d/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bea0d0aa5936cb36b6f86f721ca03c1a1bb601d/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=1bea0d0aa5936cb36b6f86f721ca03c1a1bb601d", "patch": "@@ -3948,6 +3948,698 @@ gimple_fold_builtin_realloc (gimple_stmt_iterator *gsi)\n   return false;\n }\n \n+/* Number of bytes into which any type but aggregate or vector types\n+   should fit.  */\n+static constexpr size_t clear_padding_unit\n+  = MAX_BITSIZE_MODE_ANY_MODE / BITS_PER_UNIT;\n+/* Buffer size on which __builtin_clear_padding folding code works.  */\n+static const size_t clear_padding_buf_size = 32 * clear_padding_unit;\n+\n+/* Data passed through __builtin_clear_padding folding.  */\n+struct clear_padding_struct {\n+  location_t loc;\n+  tree base;\n+  tree alias_type;\n+  gimple_stmt_iterator *gsi;\n+  /* Alignment of buf->base + 0.  */\n+  unsigned align;\n+  /* Offset from buf->base.  Should be always a multiple of UNITS_PER_WORD.  */\n+  HOST_WIDE_INT off;\n+  /* Number of padding bytes before buf->off that don't have padding clear\n+     code emitted yet.  */\n+  HOST_WIDE_INT padding_bytes;\n+  /* The size of the whole object.  Never emit code to touch\n+     buf->base + buf->sz or following bytes.  */\n+  HOST_WIDE_INT sz;\n+  /* Number of bytes recorded in buf->buf.  */\n+  size_t size;\n+  /* When inside union, instead of emitting code we and bits inside of\n+     the union_ptr array.  */\n+  unsigned char *union_ptr;\n+  /* Set bits mean padding bits that need to be cleared by the builtin.  */\n+  unsigned char buf[clear_padding_buf_size + clear_padding_unit];\n+};\n+\n+/* Emit code to clear padding requested in BUF->buf - set bits\n+   in there stand for padding that should be cleared.  FULL is true\n+   if everything from the buffer should be flushed, otherwise\n+   it can leave up to 2 * clear_padding_unit bytes for further\n+   processing.  */\n+\n+static void\n+clear_padding_flush (clear_padding_struct *buf, bool full)\n+{\n+  gcc_assert ((clear_padding_unit % UNITS_PER_WORD) == 0);\n+  if (!full && buf->size < 2 * clear_padding_unit)\n+    return;\n+  gcc_assert ((buf->off % UNITS_PER_WORD) == 0);\n+  size_t end = buf->size;\n+  if (!full)\n+    end = ((end - clear_padding_unit - 1) / clear_padding_unit\n+\t   * clear_padding_unit);\n+  size_t padding_bytes = buf->padding_bytes;\n+  if (buf->union_ptr)\n+    {\n+      /* Inside of a union, instead of emitting any code, instead\n+\t clear all bits in the union_ptr buffer that are clear\n+\t in buf.  Whole padding bytes don't clear anything.  */\n+      for (size_t i = 0; i < end; i++)\n+\t{\n+\t  if (buf->buf[i] == (unsigned char) ~0)\n+\t    padding_bytes++;\n+\t  else\n+\t    {\n+\t      padding_bytes = 0;\n+\t      buf->union_ptr[buf->off + i] &= buf->buf[i];\n+\t    }\n+\t}\n+      if (full)\n+\t{\n+\t  buf->off = 0;\n+\t  buf->size = 0;\n+\t  buf->padding_bytes = 0;\n+\t}\n+      else\n+\t{\n+\t  memmove (buf->buf, buf->buf + end, buf->size - end);\n+\t  buf->off += end;\n+\t  buf->size -= end;\n+\t  buf->padding_bytes = padding_bytes;\n+\t}\n+      return;\n+    }\n+  size_t wordsize = UNITS_PER_WORD;\n+  for (size_t i = 0; i < end; i += wordsize)\n+    {\n+      size_t nonzero_first = wordsize;\n+      size_t nonzero_last = 0;\n+      bool all_ones = true;\n+      if ((unsigned HOST_WIDE_INT) (buf->off + i + wordsize)\n+\t  > (unsigned HOST_WIDE_INT) buf->sz)\n+\t{\n+\t  gcc_assert (wordsize > 1);\n+\t  wordsize /= 2;\n+\t  i -= wordsize;\n+\t  continue;\n+\t}\n+      for (size_t j = i; j < i + wordsize && j < end; j++)\n+\t{\n+\t  if (buf->buf[j])\n+\t    {\n+\t      if (nonzero_first == wordsize)\n+\t\t{\n+\t\t  nonzero_first = j - i;\n+\t\t  nonzero_last = j - i;\n+\t\t}\n+\t      if (nonzero_last != j - i)\n+\t\tall_ones = false;\n+\t      nonzero_last = j + 1 - i;\n+\t    }\n+\t  if (buf->buf[j] != 0 && buf->buf[j] != (unsigned char) ~0)\n+\t    all_ones = false;\n+\t}\n+      if (padding_bytes)\n+\t{\n+\t  if (nonzero_first == 0\n+\t      && nonzero_last == wordsize\n+\t      && all_ones)\n+\t    {\n+\t      /* All bits are padding and we had some padding\n+\t\t before too.  Just extend it.  */\n+\t      padding_bytes += wordsize;\n+\t      continue;\n+\t    }\n+\t  size_t padding_end = i;\n+\t  if (all_ones && nonzero_first == 0)\n+\t    {\n+\t      padding_bytes += nonzero_last;\n+\t      padding_end += nonzero_last;\n+\t      nonzero_first = wordsize;\n+\t      nonzero_last = 0;\n+\t    }\n+\t  tree atype = build_array_type_nelts (char_type_node, padding_bytes);\n+\t  tree dst = build2_loc (buf->loc, MEM_REF, atype, buf->base,\n+\t\t\t\t build_int_cst (buf->alias_type,\n+\t\t\t\t\t\tbuf->off + padding_end\n+\t\t\t\t\t\t- padding_bytes));\n+\t  tree src = build_constructor (atype, NULL);\n+\t  gimple *g = gimple_build_assign (dst, src);\n+\t  gimple_set_location (g, buf->loc);\n+\t  gsi_insert_before (buf->gsi, g, GSI_SAME_STMT);\n+\t  padding_bytes = 0;\n+\t  buf->padding_bytes = 0;\n+\t}\n+      if (nonzero_first == wordsize)\n+\t/* All bits in a word are 0, there are no padding bits.  */\n+\tcontinue;\n+      if (all_ones && nonzero_last == wordsize)\n+\t{\n+\t  /* All bits between nonzero_first and end of word are padding\n+\t     bits, start counting padding_bytes.  */\n+\t  padding_bytes = nonzero_last - nonzero_first;\n+\t  continue;\n+\t}\n+      for (size_t eltsz = 1; eltsz <= wordsize; eltsz <<= 1)\n+\t{\n+\t  if (nonzero_last - nonzero_first <= eltsz\n+\t      && ((nonzero_first & ~(eltsz - 1))\n+\t\t  == ((nonzero_last - 1) & ~(eltsz - 1))))\n+\t    {\n+\t      tree type;\n+\t      if (eltsz == 1)\n+\t\ttype = char_type_node;\n+\t      else\n+\t\ttype = lang_hooks.types.type_for_size (eltsz * BITS_PER_UNIT,\n+\t\t\t\t\t\t       0);\n+\t      size_t start = nonzero_first & ~(eltsz - 1);\n+\t      HOST_WIDE_INT off = buf->off + i + start;\n+\t      tree atype = type;\n+\t      if (eltsz > 1 && buf->align < TYPE_ALIGN (type))\n+\t\tatype = build_aligned_type (type, buf->align);\n+\t      tree dst = build2_loc (buf->loc, MEM_REF, atype, buf->base,\n+\t\t\t\t     build_int_cst (buf->alias_type, off));\n+\t      tree src;\n+\t      gimple *g;\n+\t      if (all_ones\n+\t\t  && nonzero_first == start\n+\t\t  && nonzero_last == start + eltsz)\n+\t\tsrc = build_zero_cst (type);\n+\t      else\n+\t\t{\n+\t\t  src = make_ssa_name (type);\n+\t\t  g = gimple_build_assign (src, unshare_expr (dst));\n+\t\t  gimple_set_location (g, buf->loc);\n+\t\t  gsi_insert_before (buf->gsi, g, GSI_SAME_STMT);\n+\t\t  tree mask = native_interpret_expr (type,\n+\t\t\t\t\t\t     buf->buf + i + start,\n+\t\t\t\t\t\t     eltsz);\n+\t\t  gcc_assert (mask && TREE_CODE (mask) == INTEGER_CST);\n+\t\t  mask = fold_build1 (BIT_NOT_EXPR, type, mask);\n+\t\t  tree src_masked = make_ssa_name (type);\n+\t\t  g = gimple_build_assign (src_masked, BIT_AND_EXPR,\n+\t\t\t\t\t   src, mask);\n+\t\t  gimple_set_location (g, buf->loc);\n+\t\t  gsi_insert_before (buf->gsi, g, GSI_SAME_STMT);\n+\t\t  src = src_masked;\n+\t\t}\n+\t      g = gimple_build_assign (dst, src);\n+\t      gimple_set_location (g, buf->loc);\n+\t      gsi_insert_before (buf->gsi, g, GSI_SAME_STMT);\n+\t      break;\n+\t    }\n+\t}\n+    }\n+  if (full)\n+    {\n+      if (padding_bytes)\n+\t{\n+\t  tree atype = build_array_type_nelts (char_type_node, padding_bytes);\n+\t  tree dst = build2_loc (buf->loc, MEM_REF, atype, buf->base,\n+\t\t\t\t build_int_cst (buf->alias_type,\n+\t\t\t\t\t\tbuf->off + end\n+\t\t\t\t\t\t- padding_bytes));\n+\t  tree src = build_constructor (atype, NULL);\n+\t  gimple *g = gimple_build_assign (dst, src);\n+\t  gimple_set_location (g, buf->loc);\n+\t  gsi_insert_before (buf->gsi, g, GSI_SAME_STMT);\n+\t}\n+      size_t end_rem = end % UNITS_PER_WORD;\n+      buf->off += end - end_rem;\n+      buf->size = end_rem;\n+      memset (buf->buf, 0, buf->size);\n+      buf->padding_bytes = 0;\n+    }\n+  else\n+    {\n+      memmove (buf->buf, buf->buf + end, buf->size - end);\n+      buf->off += end;\n+      buf->size -= end;\n+      buf->padding_bytes = padding_bytes;\n+    }\n+}\n+\n+/* Append PADDING_BYTES padding bytes.  */\n+\n+static void\n+clear_padding_add_padding (clear_padding_struct *buf,\n+\t\t\t   HOST_WIDE_INT padding_bytes)\n+{\n+  if (padding_bytes == 0)\n+    return;\n+  if ((unsigned HOST_WIDE_INT) padding_bytes + buf->size\n+      > (unsigned HOST_WIDE_INT) clear_padding_buf_size)\n+    clear_padding_flush (buf, false);\n+  if ((unsigned HOST_WIDE_INT) padding_bytes + buf->size\n+      > (unsigned HOST_WIDE_INT) clear_padding_buf_size)\n+    {\n+      memset (buf->buf + buf->size, ~0, clear_padding_buf_size - buf->size);\n+      padding_bytes -= clear_padding_buf_size - buf->size;\n+      buf->size = clear_padding_buf_size;\n+      clear_padding_flush (buf, false);\n+      gcc_assert (buf->padding_bytes);\n+      /* At this point buf->buf[0] through buf->buf[buf->size - 1]\n+\t is guaranteed to be all ones.  */\n+      padding_bytes += buf->size;\n+      buf->size = padding_bytes % UNITS_PER_WORD;\n+      memset (buf->buf, ~0, buf->size);\n+      buf->off += padding_bytes - buf->size;\n+      buf->padding_bytes += padding_bytes - buf->size;\n+    }\n+  else\n+    {\n+      memset (buf->buf + buf->size, ~0, padding_bytes);\n+      buf->size += padding_bytes;\n+    }\n+}\n+\n+static void clear_padding_type (clear_padding_struct *, tree, HOST_WIDE_INT);\n+\n+/* Clear padding bits of union type TYPE.  */\n+\n+static void\n+clear_padding_union (clear_padding_struct *buf, tree type, HOST_WIDE_INT sz)\n+{\n+  clear_padding_struct *union_buf;\n+  HOST_WIDE_INT start_off = 0, next_off = 0;\n+  size_t start_size = 0;\n+  if (buf->union_ptr)\n+    {\n+      start_off = buf->off + buf->size;\n+      next_off = start_off + sz;\n+      start_size = start_off % UNITS_PER_WORD;\n+      start_off -= start_size;\n+      clear_padding_flush (buf, true);\n+      union_buf = buf;\n+    }\n+  else\n+    {\n+      if (sz + buf->size > clear_padding_buf_size)\n+\tclear_padding_flush (buf, false);\n+      union_buf = XALLOCA (clear_padding_struct);\n+      union_buf->loc = buf->loc;\n+      union_buf->base = NULL_TREE;\n+      union_buf->alias_type = NULL_TREE;\n+      union_buf->gsi = NULL;\n+      union_buf->align = 0;\n+      union_buf->off = 0;\n+      union_buf->padding_bytes = 0;\n+      union_buf->sz = sz;\n+      union_buf->size = 0;\n+      if (sz + buf->size <= clear_padding_buf_size)\n+\tunion_buf->union_ptr = buf->buf + buf->size;\n+      else\n+\tunion_buf->union_ptr = XNEWVEC (unsigned char, sz);\n+      memset (union_buf->union_ptr, ~0, sz);\n+    }\n+\n+  for (tree field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n+    if (TREE_CODE (field) == FIELD_DECL)\n+      {\n+\tHOST_WIDE_INT fldsz = tree_to_shwi (DECL_SIZE_UNIT (field));\n+\tgcc_assert (union_buf->size == 0);\n+\tunion_buf->off = start_off;\n+\tunion_buf->size = start_size;\n+\tmemset (union_buf->buf, ~0, start_size);\n+\tclear_padding_type (union_buf, TREE_TYPE (field), fldsz);\n+\tclear_padding_add_padding (union_buf, sz - fldsz);\n+\tclear_padding_flush (union_buf, true);\n+      }\n+\n+  if (buf == union_buf)\n+    {\n+      buf->off = next_off;\n+      buf->size = next_off % UNITS_PER_WORD;\n+      buf->off -= buf->size;\n+      memset (buf->buf, ~0, buf->size);\n+    }\n+  else if (sz + buf->size <= clear_padding_buf_size)\n+    buf->size += sz;\n+  else\n+    {\n+      unsigned char *union_ptr = union_buf->union_ptr;\n+      while (sz)\n+\t{\n+\t  clear_padding_flush (buf, false);\n+\t  HOST_WIDE_INT this_sz\n+\t    = MIN ((unsigned HOST_WIDE_INT) sz,\n+\t\t   clear_padding_buf_size - buf->size);\n+\t  memcpy (buf->buf + buf->size, union_ptr, this_sz);\n+\t  buf->size += this_sz;\n+\t  union_ptr += this_sz;\n+\t  sz -= this_sz;\n+\t}\n+      XDELETE (union_buf->union_ptr);\n+    }\n+}\n+\n+/* The only known floating point formats with padding bits are the\n+   IEEE extended ones.  */\n+\n+static bool\n+clear_padding_real_needs_padding_p (tree type)\n+{\n+  const struct real_format *fmt = REAL_MODE_FORMAT (TYPE_MODE (type));\n+  return (fmt->b == 2\n+\t  && fmt->signbit_ro == fmt->signbit_rw\n+\t  && (fmt->signbit_ro == 79 || fmt->signbit_ro == 95));\n+}\n+\n+/* Return true if TYPE might contain any padding bits.  */\n+\n+static bool\n+clear_padding_type_may_have_padding_p (tree type)\n+{\n+  switch (TREE_CODE (type))\n+    {\n+    case RECORD_TYPE:\n+    case UNION_TYPE:\n+      return true;\n+    case ARRAY_TYPE:\n+    case COMPLEX_TYPE:\n+    case VECTOR_TYPE:\n+      return clear_padding_type_may_have_padding_p (TREE_TYPE (type));\n+    case REAL_TYPE:\n+      return clear_padding_real_needs_padding_p (type);\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Emit a runtime loop:\n+   for (; buf.base != end; buf.base += sz)\n+     __builtin_clear_padding (buf.base);  */\n+\n+static void\n+clear_padding_emit_loop (clear_padding_struct *buf, tree type, tree end)\n+{\n+  tree l1 = create_artificial_label (buf->loc);\n+  tree l2 = create_artificial_label (buf->loc);\n+  tree l3 = create_artificial_label (buf->loc);\n+  gimple *g = gimple_build_goto (l2);\n+  gimple_set_location (g, buf->loc);\n+  gsi_insert_before (buf->gsi, g, GSI_SAME_STMT);\n+  g = gimple_build_label (l1);\n+  gimple_set_location (g, buf->loc);\n+  gsi_insert_before (buf->gsi, g, GSI_SAME_STMT);\n+  clear_padding_type (buf, type, buf->sz);\n+  clear_padding_flush (buf, true);\n+  g = gimple_build_assign (buf->base, POINTER_PLUS_EXPR, buf->base,\n+\t\t\t   size_int (buf->sz));\n+  gimple_set_location (g, buf->loc);\n+  gsi_insert_before (buf->gsi, g, GSI_SAME_STMT);\n+  g = gimple_build_label (l2);\n+  gimple_set_location (g, buf->loc);\n+  gsi_insert_before (buf->gsi, g, GSI_SAME_STMT);\n+  g = gimple_build_cond (NE_EXPR, buf->base, end, l1, l3);\n+  gimple_set_location (g, buf->loc);\n+  gsi_insert_before (buf->gsi, g, GSI_SAME_STMT);\n+  g = gimple_build_label (l3);\n+  gimple_set_location (g, buf->loc);\n+  gsi_insert_before (buf->gsi, g, GSI_SAME_STMT);\n+}\n+\n+/* Clear padding bits for TYPE.  Called recursively from\n+   gimple_fold_builtin_clear_padding.  */\n+\n+static void\n+clear_padding_type (clear_padding_struct *buf, tree type, HOST_WIDE_INT sz)\n+{\n+  switch (TREE_CODE (type))\n+    {\n+    case RECORD_TYPE:\n+      HOST_WIDE_INT cur_pos;\n+      cur_pos = 0;\n+      for (tree field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n+\tif (TREE_CODE (field) == FIELD_DECL)\n+\t  {\n+\t    if (DECL_BIT_FIELD (field))\n+\t      {\n+\t\tif (DECL_NAME (field) == NULL_TREE)\n+\t\t  continue;\n+\t\tHOST_WIDE_INT fldsz = TYPE_PRECISION (TREE_TYPE (field));\n+\t\tif (fldsz == 0)\n+\t\t  continue;\n+\t\tHOST_WIDE_INT pos = int_byte_position (field);\n+\t\tHOST_WIDE_INT bpos\n+\t\t  = tree_to_uhwi (DECL_FIELD_BIT_OFFSET (field));\n+\t\tbpos %= BITS_PER_UNIT;\n+\t\tHOST_WIDE_INT end\n+\t\t  = ROUND_UP (bpos + fldsz, BITS_PER_UNIT) / BITS_PER_UNIT;\n+\t\tif (pos + end > cur_pos)\n+\t\t  {\n+\t\t    clear_padding_add_padding (buf, pos + end - cur_pos);\n+\t\t    cur_pos = pos + end;\n+\t\t  }\n+\t\tgcc_assert (cur_pos > pos\n+\t\t\t    && ((unsigned HOST_WIDE_INT) buf->size\n+\t\t\t\t>= (unsigned HOST_WIDE_INT) cur_pos - pos));\n+\t\tunsigned char *p = buf->buf + buf->size - (cur_pos - pos);\n+\t\tif (BYTES_BIG_ENDIAN != WORDS_BIG_ENDIAN)\n+\t\t  sorry_at (buf->loc, \"PDP11 bit-field handling unsupported\"\n+\t\t\t\t      \" in %qs\", \"__builtin_clear_padding\");\n+\t\telse if (BYTES_BIG_ENDIAN)\n+\t\t  {\n+\t\t    /* Big endian.  */\n+\t\t    if (bpos + fldsz <= BITS_PER_UNIT)\n+\t\t      *p &= ~(((1 << fldsz) - 1)\n+\t\t\t      << (BITS_PER_UNIT - bpos - fldsz));\n+\t\t    else\n+\t\t      {\n+\t\t\tif (bpos)\n+\t\t\t  {\n+\t\t\t    *p &= ~(((1U << BITS_PER_UNIT) - 1) >> bpos);\n+\t\t\t    p++;\n+\t\t\t    fldsz -= BITS_PER_UNIT - bpos;\n+\t\t\t  }\n+\t\t\tmemset (p, 0, fldsz / BITS_PER_UNIT);\n+\t\t\tp += fldsz / BITS_PER_UNIT;\n+\t\t\tfldsz %= BITS_PER_UNIT;\n+\t\t\tif (fldsz)\n+\t\t\t  *p &= ((1U << BITS_PER_UNIT) - 1) >> fldsz;\n+\t\t      }\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    /* Little endian.  */\n+\t\t    if (bpos + fldsz <= BITS_PER_UNIT)\n+\t\t      *p &= ~(((1 << fldsz) - 1) << bpos);\n+\t\t    else\n+\t\t      {\n+\t\t\tif (bpos)\n+\t\t\t  {\n+\t\t\t    *p &= ~(((1 << BITS_PER_UNIT) - 1) << bpos);\n+\t\t\t    p++;\n+\t\t\t    fldsz -= BITS_PER_UNIT - bpos;\n+\t\t\t  }\n+\t\t\tmemset (p, 0, fldsz / BITS_PER_UNIT);\n+\t\t\tp += fldsz / BITS_PER_UNIT;\n+\t\t\tfldsz %= BITS_PER_UNIT;\n+\t\t\tif (fldsz)\n+\t\t\t  *p &= ~((1 << fldsz) - 1);\n+\t\t      }\n+\t\t  }\n+\t      }\n+\t    else\n+\t      {\n+\t\tHOST_WIDE_INT pos = int_byte_position (field);\n+\t\tHOST_WIDE_INT fldsz = tree_to_shwi (DECL_SIZE_UNIT (field));\n+\t\tgcc_assert (pos >= 0 && fldsz >= 0 && pos >= cur_pos);\n+\t\tclear_padding_add_padding (buf, pos - cur_pos);\n+\t\tcur_pos = pos;\n+\t\tclear_padding_type (buf, TREE_TYPE (field), fldsz);\n+\t\tcur_pos += fldsz;\n+\t      }\n+\t  }\n+      gcc_assert (sz >= cur_pos);\n+      clear_padding_add_padding (buf, sz - cur_pos);\n+      break;\n+    case ARRAY_TYPE:\n+      HOST_WIDE_INT nelts, fldsz;\n+      fldsz = int_size_in_bytes (TREE_TYPE (type));\n+      nelts = sz / fldsz;\n+      if (nelts > 1\n+\t  && sz > 8 * UNITS_PER_WORD\n+\t  && buf->union_ptr == NULL\n+\t  && clear_padding_type_may_have_padding_p (TREE_TYPE (type)))\n+\t{\n+\t  /* For sufficiently large array of more than one elements,\n+\t     emit a runtime loop to keep code size manageable.  */\n+\t  tree base = buf->base;\n+\t  unsigned int prev_align = buf->align;\n+\t  HOST_WIDE_INT off = buf->off + buf->size;\n+\t  HOST_WIDE_INT prev_sz = buf->sz;\n+\t  clear_padding_flush (buf, true);\n+\t  tree elttype = TREE_TYPE (type);\n+\t  buf->base = create_tmp_var (build_pointer_type (elttype));\n+\t  tree end = make_ssa_name (TREE_TYPE (buf->base));\n+\t  gimple *g = gimple_build_assign (buf->base, POINTER_PLUS_EXPR,\n+\t\t\t\t\t   base, size_int (off));\n+\t  gimple_set_location (g, buf->loc);\n+\t  gsi_insert_before (buf->gsi, g, GSI_SAME_STMT);\n+\t  g = gimple_build_assign (end, POINTER_PLUS_EXPR, buf->base,\n+\t\t\t\t   size_int (sz));\n+\t  gimple_set_location (g, buf->loc);\n+\t  gsi_insert_before (buf->gsi, g, GSI_SAME_STMT);\n+\t  buf->sz = fldsz;\n+\t  buf->align = TYPE_ALIGN (elttype);\n+\t  buf->off = 0;\n+\t  buf->size = 0;\n+\t  clear_padding_emit_loop (buf, elttype, end);\n+\t  buf->base = base;\n+\t  buf->sz = prev_sz;\n+\t  buf->align = prev_align;\n+\t  buf->size = off % UNITS_PER_WORD;\n+\t  buf->off = off - buf->size;\n+\t  memset (buf->buf, 0, buf->size);\n+\t  break;\n+\t}\n+      for (HOST_WIDE_INT i = 0; i < nelts; i++)\n+\tclear_padding_type (buf, TREE_TYPE (type), fldsz);\n+      break;\n+    case UNION_TYPE:\n+      clear_padding_union (buf, type, sz);\n+      break;\n+    case REAL_TYPE:\n+      gcc_assert ((size_t) sz <= clear_padding_unit);\n+      if ((unsigned HOST_WIDE_INT) sz + buf->size > clear_padding_buf_size)\n+\tclear_padding_flush (buf, false);\n+      if (clear_padding_real_needs_padding_p (type))\n+\t{\n+\t  /* Use native_interpret_expr + native_encode_expr to figure out\n+\t     which bits are padding.  */\n+\t  memset (buf->buf + buf->size, ~0, sz);\n+\t  tree cst = native_interpret_expr (type, buf->buf + buf->size, sz);\n+\t  gcc_assert (cst && TREE_CODE (cst) == REAL_CST);\n+\t  int len = native_encode_expr (cst, buf->buf + buf->size, sz);\n+\t  gcc_assert (len > 0 && (size_t) len == (size_t) sz);\n+\t  for (size_t i = 0; i < (size_t) sz; i++)\n+\t    buf->buf[buf->size + i] ^= ~0;\n+\t}\n+      else\n+\tmemset (buf->buf + buf->size, 0, sz);\n+      buf->size += sz;\n+      break;\n+    case COMPLEX_TYPE:\n+      fldsz = int_size_in_bytes (TREE_TYPE (type));\n+      clear_padding_type (buf, TREE_TYPE (type), fldsz);\n+      clear_padding_type (buf, TREE_TYPE (type), fldsz);\n+      break;\n+    case VECTOR_TYPE:\n+      nelts = TYPE_VECTOR_SUBPARTS (type).to_constant ();\n+      fldsz = int_size_in_bytes (TREE_TYPE (type));\n+      for (HOST_WIDE_INT i = 0; i < nelts; i++)\n+\tclear_padding_type (buf, TREE_TYPE (type), fldsz);\n+      break;\n+    case NULLPTR_TYPE:\n+      gcc_assert ((size_t) sz <= clear_padding_unit);\n+      if ((unsigned HOST_WIDE_INT) sz + buf->size > clear_padding_buf_size)\n+\tclear_padding_flush (buf, false);\n+      memset (buf->buf + buf->size, ~0, sz);\n+      buf->size += sz;\n+      break;\n+    default:\n+      gcc_assert ((size_t) sz <= clear_padding_unit);\n+      if ((unsigned HOST_WIDE_INT) sz + buf->size > clear_padding_buf_size)\n+\tclear_padding_flush (buf, false);\n+      memset (buf->buf + buf->size, 0, sz);\n+      buf->size += sz;\n+      break;\n+    }\n+}\n+\n+/* Fold __builtin_clear_padding builtin.  */\n+\n+static bool\n+gimple_fold_builtin_clear_padding (gimple_stmt_iterator *gsi)\n+{\n+  gimple *stmt = gsi_stmt (*gsi);\n+  gcc_assert (gimple_call_num_args (stmt) == 2);\n+  tree ptr = gimple_call_arg (stmt, 0);\n+  tree typearg = gimple_call_arg (stmt, 1);\n+  tree type = TREE_TYPE (TREE_TYPE (typearg));\n+  location_t loc = gimple_location (stmt);\n+  clear_padding_struct buf;\n+  gimple_stmt_iterator gsiprev = *gsi;\n+  /* This should be folded during the lower pass.  */\n+  gcc_assert (!gimple_in_ssa_p (cfun) && cfun->cfg == NULL);\n+  gcc_assert (COMPLETE_TYPE_P (type));\n+  gsi_prev (&gsiprev);\n+\n+  buf.loc = loc;\n+  buf.base = ptr;\n+  buf.alias_type = NULL_TREE;\n+  buf.gsi = gsi;\n+  buf.align = get_pointer_alignment (ptr);\n+  unsigned int talign = min_align_of_type (type) * BITS_PER_UNIT;\n+  buf.align = MAX (buf.align, talign);\n+  buf.off = 0;\n+  buf.padding_bytes = 0;\n+  buf.size = 0;\n+  buf.sz = int_size_in_bytes (type);\n+  buf.union_ptr = NULL;\n+  if (buf.sz < 0 && int_size_in_bytes (strip_array_types (type)) < 0)\n+    sorry_at (loc, \"%s not supported for variable length aggregates\",\n+\t      \"__builtin_clear_padding\");\n+  /* The implementation currently assumes 8-bit host and target\n+     chars which is the case for all currently supported targets\n+     and hosts and is required e.g. for native_{encode,interpret}* APIs.  */\n+  else if (CHAR_BIT != 8 || BITS_PER_UNIT != 8)\n+    sorry_at (loc, \"%s not supported on this target\",\n+\t      \"__builtin_clear_padding\");\n+  else if (!clear_padding_type_may_have_padding_p (type))\n+    ;\n+  else if (TREE_CODE (type) == ARRAY_TYPE && buf.sz < 0)\n+    {\n+      tree sz = TYPE_SIZE_UNIT (type);\n+      tree elttype = type;\n+      /* Only supports C/C++ VLAs and flattens all the VLA levels.  */\n+      while (TREE_CODE (elttype) == ARRAY_TYPE\n+\t     && int_size_in_bytes (elttype) < 0)\n+\telttype = TREE_TYPE (elttype);\n+      HOST_WIDE_INT eltsz = int_size_in_bytes (elttype);\n+      gcc_assert (eltsz >= 0);\n+      if (eltsz)\n+\t{\n+\t  buf.base = create_tmp_var (build_pointer_type (elttype));\n+\t  tree end = make_ssa_name (TREE_TYPE (buf.base));\n+\t  gimple *g = gimple_build_assign (buf.base, ptr);\n+\t  gimple_set_location (g, loc);\n+\t  gsi_insert_before (gsi, g, GSI_SAME_STMT);\n+\t  g = gimple_build_assign (end, POINTER_PLUS_EXPR, buf.base, sz);\n+\t  gimple_set_location (g, loc);\n+\t  gsi_insert_before (gsi, g, GSI_SAME_STMT);\n+\t  buf.sz = eltsz;\n+\t  buf.align = TYPE_ALIGN (elttype);\n+\t  buf.alias_type = build_pointer_type (elttype);\n+\t  clear_padding_emit_loop (&buf, elttype, end);\n+\t}\n+    }\n+  else\n+    {\n+      if (!is_gimple_mem_ref_addr (buf.base))\n+\t{\n+\t  buf.base = make_ssa_name (TREE_TYPE (ptr));\n+\t  gimple *g = gimple_build_assign (buf.base, ptr);\n+\t  gimple_set_location (g, loc);\n+\t  gsi_insert_before (gsi, g, GSI_SAME_STMT);\n+\t}\n+      buf.alias_type = build_pointer_type (type);\n+      clear_padding_type (&buf, type, buf.sz);\n+      clear_padding_flush (&buf, true);\n+    }\n+\n+  gimple_stmt_iterator gsiprev2 = *gsi;\n+  gsi_prev (&gsiprev2);\n+  if (gsi_stmt (gsiprev) == gsi_stmt (gsiprev2))\n+    gsi_replace (gsi, gimple_build_nop (), true);\n+  else\n+    {\n+      gsi_remove (gsi, true);\n+      *gsi = gsiprev2;\n+    }\n+  return true;\n+}\n+\n /* Fold the non-target builtin at *GSI and return whether any simplification\n    was made.  */\n \n@@ -4105,6 +4797,9 @@ gimple_fold_builtin (gimple_stmt_iterator *gsi)\n     case BUILT_IN_REALLOC:\n       return gimple_fold_builtin_realloc (gsi);\n \n+    case BUILT_IN_CLEAR_PADDING:\n+      return gimple_fold_builtin_clear_padding (gsi);\n+\n     default:;\n     }\n "}, {"sha": "53ec9ecdb643d817add8675b5b141146089c1baf", "filename": "gcc/gimplify.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bea0d0aa5936cb36b6f86f721ca03c1a1bb601d/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bea0d0aa5936cb36b6f86f721ca03c1a1bb601d/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=1bea0d0aa5936cb36b6f86f721ca03c1a1bb601d", "patch": "@@ -3384,6 +3384,20 @@ gimplify_call_expr (tree *expr_p, gimple_seq *pre_p, bool want_value)\n \tcfun->calls_eh_return = true;\n \tbreak;\n \n+      case BUILT_IN_CLEAR_PADDING:\n+\tif (call_expr_nargs (*expr_p) == 1)\n+\t  {\n+\t    /* Remember the original type of the argument in an internal\n+\t       dummy second argument, as in GIMPLE pointer conversions are\n+\t       useless.  */\n+\t    p = CALL_EXPR_ARG (*expr_p, 0);\n+\t    *expr_p\n+\t      = build_call_expr_loc (EXPR_LOCATION (*expr_p), fndecl, 2, p,\n+\t\t\t\t     build_zero_cst (TREE_TYPE (p)));\n+\t    return GS_OK;\n+\t  }\n+\tbreak;\n+\n       default:\n         ;\n       }"}, {"sha": "8b036bf405edcadc7e709bb457d540c4cd91fd85", "filename": "gcc/testsuite/c-c++-common/builtin-clear-padding-1.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bea0d0aa5936cb36b6f86f721ca03c1a1bb601d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-clear-padding-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bea0d0aa5936cb36b6f86f721ca03c1a1bb601d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-clear-padding-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-clear-padding-1.c?ref=1bea0d0aa5936cb36b6f86f721ca03c1a1bb601d", "patch": "@@ -0,0 +1,19 @@\n+/* PR libstdc++/88101 */\n+/* { dg-do compile } */\n+\n+struct S;\n+struct T { char a; long long b; };\n+\n+void\n+foo (struct S *p, void *q, char *r, const struct T *s)\n+{\n+  __builtin_clear_padding ();\t\t/* { dg-error \"too few arguments to function '__builtin_clear_padding'\" } */\n+  __builtin_clear_padding (1);\t\t/* { dg-error \"argument 1 in call to function '__builtin_clear_padding' does not have pointer type\" } */\n+  __builtin_clear_padding (&p);\n+  __builtin_clear_padding (&p, 1);\t/* { dg-error \"too many arguments to function '__builtin_clear_padding'\" } */\n+  __builtin_clear_padding (&p, &p);\t/* { dg-error \"too many arguments to function '__builtin_clear_padding'\" } */\n+  __builtin_clear_padding (p);\t\t/* { dg-error \"argument 1 in call to function '__builtin_clear_padding' points to incomplete type\" } */\n+  __builtin_clear_padding (q);\t\t/* { dg-error \"argument 1 in call to function '__builtin_clear_padding' points to incomplete type\" } */\n+  __builtin_clear_padding (r);\n+  __builtin_clear_padding (s);\t\t/* { dg-error \"argument 1 in call to function '__builtin_clear_padding' has pointer to 'const' type\" } */\n+}"}, {"sha": "6b01a5614b53ee4a8779021a48f19f245295fe58", "filename": "gcc/testsuite/c-c++-common/torture/builtin-clear-padding-1.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bea0d0aa5936cb36b6f86f721ca03c1a1bb601d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-clear-padding-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bea0d0aa5936cb36b6f86f721ca03c1a1bb601d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-clear-padding-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-clear-padding-1.c?ref=1bea0d0aa5936cb36b6f86f721ca03c1a1bb601d", "patch": "@@ -0,0 +1,47 @@\n+/* PR libstdc++/88101 */\n+\n+int i1, i2;\n+long double l1, l2;\n+struct S { char a; short b; char c; int d; char e; long long f; char g; long double h; } s1, s2;\n+struct T { int a; struct S b[3]; int c; } t1, t2;\n+struct U { int a : 3; int : 2; int b : 15; int : 14; int c : 1; int : 0; int : 3; int d : 2; int : 3; int e : 13; int : 3; signed char f; } u1, u2;\n+\n+__attribute__((noipa)) void\n+foo (int *i, long double *l, struct S *s, struct T *t, struct U *u)\n+{\n+  *i = 123;\n+  *l = -123.456L;\n+  s->a = 1; s->b = 2; s->c = 3; s->d = 4; s->e = 5; s->f = 6; s->g = 7; s->h = 18.52L;\n+  t->a = 8; t->c = 9;\n+  t->b[0].a = 11; t->b[0].b = 12; t->b[0].c = 13; t->b[0].d = 14;\n+  t->b[0].e = 15; t->b[0].f = 16; t->b[0].g = 17; t->b[0].h = 18.26L;\n+  t->b[1].a = 21; t->b[1].b = 22; t->b[1].c = 23; t->b[1].d = 24;\n+  t->b[1].e = 25; t->b[1].f = 26; t->b[1].g = 27; t->b[1].h = 28.26L;\n+  t->b[2].a = 31; t->b[2].b = 32; t->b[2].c = 33; t->b[2].d = 34;\n+  t->b[2].e = 35; t->b[2].f = 36; t->b[2].g = 37; t->b[2].h = 38.26L;\n+  u->a = -1; u->b = -1; u->c = -1; u->d = -1; u->e = -1; u->f = -1;\n+}\n+\n+int\n+main ()\n+{\n+  __builtin_memset (&i2, -1, sizeof (i2));\n+  __builtin_memset (&l2, -1, sizeof (i2));\n+  __builtin_memset (&s2, -1, sizeof (s2));\n+  __builtin_memset (&t2, -1, sizeof (t2));\n+  __builtin_memset (&u2, -1, sizeof (u2));\n+  foo (&i1, &l1, &s1, &t1, &u1);\n+  foo (&i2, &l2, &s2, &t2, &u2);\n+  __builtin_clear_padding (&i2);\n+  __builtin_clear_padding (&l2);\n+  __builtin_clear_padding (&s2);\n+  __builtin_clear_padding (&t2);\n+  __builtin_clear_padding (&u2);\n+  if (__builtin_memcmp (&i1, &i2, sizeof (i1))\n+      || __builtin_memcmp (&l1, &l2, sizeof (l1))\n+      || __builtin_memcmp (&s1, &s2, sizeof (s1))\n+      || __builtin_memcmp (&t1, &t2, sizeof (t1))\n+      || __builtin_memcmp (&u1, &u2, sizeof (u1)))\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "1188bc07ed2746e61d212510e04fcd1488a0ef09", "filename": "gcc/testsuite/c-c++-common/torture/builtin-clear-padding-2.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bea0d0aa5936cb36b6f86f721ca03c1a1bb601d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-clear-padding-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bea0d0aa5936cb36b6f86f721ca03c1a1bb601d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-clear-padding-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-clear-padding-2.c?ref=1bea0d0aa5936cb36b6f86f721ca03c1a1bb601d", "patch": "@@ -0,0 +1,24 @@\n+/* PR libstdc++/88101 */\n+\n+typedef int T __attribute__((aligned (16384)));\n+struct S { char a; short b; long double c; T d; T e; long long f; };\n+\n+__attribute__((noipa)) void\n+foo (struct S *s)\n+{\n+  s->a = -1; s->b = -1; s->c = -18.52L; s->d = -1; s->e = -1; s->f = -1;\n+}\n+\n+int\n+main ()\n+{\n+  struct S s1, s2;\n+  __builtin_memset (&s1, 0, sizeof (s1));\n+  __builtin_memset (&s2, -1, sizeof (s2));\n+  foo (&s1);\n+  foo (&s2);\n+  __builtin_clear_padding (&s2);\n+  if (__builtin_memcmp (&s1, &s2, sizeof (s1)))\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "edb7c8eb555ae7765b133bc0f63b3fdb905cf2cf", "filename": "gcc/testsuite/c-c++-common/torture/builtin-clear-padding-3.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bea0d0aa5936cb36b6f86f721ca03c1a1bb601d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-clear-padding-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bea0d0aa5936cb36b6f86f721ca03c1a1bb601d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-clear-padding-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-clear-padding-3.c?ref=1bea0d0aa5936cb36b6f86f721ca03c1a1bb601d", "patch": "@@ -0,0 +1,65 @@\n+/* PR libstdc++/88101 */\n+\n+union V { char a; signed char b; unsigned char c; };\n+struct T { char a; int b; union V c; };\n+union U { int a; long double b; struct T c; };\n+struct S { char a; union U b; long long c; char d; } s1, s2;\n+\n+__attribute__((noipa)) void\n+foo (struct S *s, int x)\n+{\n+  s->a = -1; s->c = -1; s->d = -1;\n+  switch (x)\n+    {\n+    case 0:\n+      s->b.a = -1;\n+      break;\n+    case 1:\n+      s->b.b = -12345.25L;\n+      break;\n+    case 2:\n+      s->b.c.a = -1;\n+      s->b.c.b = -1;\n+      s->b.c.c.b = -1;\n+      break;\n+    }\n+}\n+\n+int\n+main ()\n+{\n+  __builtin_memset (&s1, 0, sizeof (s1));\n+  __builtin_memset (&s2, -1, sizeof (s2));\n+  foo (&s1, 0);\n+  foo (&s2, 0);\n+  __builtin_clear_padding (&s2);\n+  if (s2.b.a != (char) -1)\n+    __builtin_abort ();\n+  __builtin_clear_padding (&s2.b.a);\n+  __builtin_memset (&s2.b.a + 1, 0, sizeof (union U) - sizeof (s2.b.a));\n+  if (__builtin_memcmp (&s1, &s2, sizeof (s1)))\n+    __builtin_abort ();\n+  __builtin_memset (&s1, 0, sizeof (s1));\n+  __builtin_memset (&s2, -1, sizeof (s2));\n+  foo (&s1, 1);\n+  foo (&s2, 1);\n+  __builtin_clear_padding (&s2);\n+  if (s2.b.b != -12345.25L)\n+    __builtin_abort ();\n+  __builtin_clear_padding (&s2.b.b);\n+  __builtin_memset (&s2.b.b + 1, 0, sizeof (union U) - sizeof (s2.b.b));\n+  if (__builtin_memcmp (&s1, &s2, sizeof (s1)))\n+    __builtin_abort ();\n+  __builtin_memset (&s1, 0, sizeof (s1));\n+  __builtin_memset (&s2, -1, sizeof (s2));\n+  foo (&s1, 2);\n+  foo (&s2, 2);\n+  __builtin_clear_padding (&s2);\n+  if (s2.b.c.a != (char) -1 || s2.b.c.b != -1 || s2.b.c.c.b != -1)\n+    __builtin_abort ();\n+  __builtin_clear_padding (&s2.b.c);\n+  __builtin_memset (&s2.b.c + 1, 0, sizeof (union U) - sizeof (s2.b.c));\n+  if (__builtin_memcmp (&s1, &s2, sizeof (s1)))\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "d24f3b59d7b895e59b01930b21db59ceaed16a32", "filename": "gcc/testsuite/c-c++-common/torture/builtin-clear-padding-4.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bea0d0aa5936cb36b6f86f721ca03c1a1bb601d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-clear-padding-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bea0d0aa5936cb36b6f86f721ca03c1a1bb601d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-clear-padding-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-clear-padding-4.c?ref=1bea0d0aa5936cb36b6f86f721ca03c1a1bb601d", "patch": "@@ -0,0 +1,59 @@\n+/* PR libstdc++/88101 */\n+\n+struct S { char a; short b; char c; };\n+\n+__attribute__((noipa)) void\n+foo (int m, int n, int o)\n+{\n+  long double a1[m];\n+  long double a2[m];\n+  struct S b1[m][n];\n+  struct S b2[m][n];\n+  struct S c1[m][n][o];\n+  struct S c2[m][n][o];\n+  int i, j, k;\n+  __builtin_memset (&a1, 0, sizeof (a1));\n+  __builtin_memset (&a2, ~0, sizeof (a2));\n+  __builtin_memset (&b1, 0, sizeof (b1));\n+  __builtin_memset (&b2, ~0, sizeof (b2));\n+  __builtin_memset (&c1, 0, sizeof (c1));\n+  __builtin_memset (&c2, ~0, sizeof (c2));\n+  for (i = 0; i < m; i++)\n+    {\n+      a1[i] = 13.132L;\n+      a2[i] = 13.132L;\n+      for (j = 0; j < n; j++)\n+\t{\n+\t  b1[i][j].a = -1;\n+\t  b1[i][j].b = -1;\n+\t  b1[i][j].c = -1;\n+\t  b2[i][j].a = -1;\n+\t  b2[i][j].b = -1;\n+\t  b2[i][j].c = -1;\n+\t  for (k = 0; k < o; k++)\n+\t    {\n+\t      c1[i][j][k].a = -1;\n+\t      c1[i][j][k].b = -1;\n+\t      c1[i][j][k].c = -1;\n+\t      c2[i][j][k].a = -1;\n+\t      c2[i][j][k].b = -1;\n+\t      c2[i][j][k].c = -1;\n+\t    }\n+\t}\n+    }\n+  __builtin_clear_padding (&a2);\n+  __builtin_clear_padding (&b2);\n+  __builtin_clear_padding (&c2);\n+  if (__builtin_memcmp (&a1, &a2, sizeof (a1))\n+      || __builtin_memcmp (&b1, &b2, sizeof (b1))\n+      || __builtin_memcmp (&c1, &c2, sizeof (c1)))\n+    __builtin_abort ();\n+}\n+\n+int\n+main ()\n+{\n+  foo (5, 3, 4);\n+  foo (17, 2, 1);\n+  return 0;\n+}"}, {"sha": "d5dbafe1c748e57261bc6e9f45b7d8d2f0c53ca8", "filename": "gcc/testsuite/c-c++-common/torture/builtin-clear-padding-5.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bea0d0aa5936cb36b6f86f721ca03c1a1bb601d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-clear-padding-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bea0d0aa5936cb36b6f86f721ca03c1a1bb601d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-clear-padding-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-clear-padding-5.c?ref=1bea0d0aa5936cb36b6f86f721ca03c1a1bb601d", "patch": "@@ -0,0 +1,49 @@\n+/* PR libstdc++/88101 */\n+\n+struct S { char a; short b; char c; } s1[24], s2[24];\n+struct T { char a; long long b; char c; struct S d[3]; long long e; char f; } t1, t2;\n+struct U { char a; long long b; char c; struct S d[25]; long long e; char f; } u1, u2;\n+\n+__attribute__((noipa)) void\n+foo (struct S *s, struct T *t, struct U *u)\n+{\n+  int i;\n+  t->a = -1; t->b = -1; t->c = -1; t->e = -1; t->f = -1;\n+  u->a = -1; u->b = -1; u->c = -1; u->e = -1; u->f = -1;\n+  for (i = 0; i < 24; i++)\n+    {\n+      s[i].a = -1;\n+      s[i].b = -1;\n+      s[i].c = -1;\n+    }\n+  for (i = 0; i < 3; i++)\n+    {\n+      t->d[i].a = -1;\n+      t->d[i].b = -1;\n+      t->d[i].c = -1;\n+    }\n+  for (i = 0; i < 25; i++)\n+    {\n+      u->d[i].a = -1;\n+      u->d[i].b = -1;\n+      u->d[i].c = -1;\n+    }\n+}\n+\n+int\n+main ()\n+{\n+  __builtin_memset (&s2, -1, sizeof (s2));\n+  __builtin_memset (&t2, -1, sizeof (t2));\n+  __builtin_memset (&u2, -1, sizeof (u2));\n+  foo (&s1[0], &t1, &u1);\n+  foo (&s2[0], &t2, &u2);\n+  __builtin_clear_padding (&s2);\n+  __builtin_clear_padding (&t2);\n+  __builtin_clear_padding (&u2);\n+  if (__builtin_memcmp (&s1, &s2, sizeof (s1))\n+      || __builtin_memcmp (&t1, &t2, sizeof (t1))\n+      || __builtin_memcmp (&u1, &u2, sizeof (u1)))\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "625a047ab1c71a8595f5b75aec110cf699b182e0", "filename": "gcc/testsuite/g++.dg/torture/builtin-clear-padding-1.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bea0d0aa5936cb36b6f86f721ca03c1a1bb601d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fbuiltin-clear-padding-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bea0d0aa5936cb36b6f86f721ca03c1a1bb601d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fbuiltin-clear-padding-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fbuiltin-clear-padding-1.C?ref=1bea0d0aa5936cb36b6f86f721ca03c1a1bb601d", "patch": "@@ -0,0 +1,31 @@\n+/* PR libstdc++/88101 */\n+\n+struct S {} s1, s2;\n+struct T : public S { char a; short b; char c; } t1, t2;\n+struct U : public T { char d; long long e; char f; } u1, u2;\n+\n+__attribute__((noipa)) void\n+foo (T *t, U *u)\n+{\n+  int i;\n+  t->a = -1; t->b = -1; t->c = -1;\n+  u->a = -1; u->b = -1; u->c = -1; u->d = -1; u->e = -1; u->f = -1;\n+}\n+\n+int\n+main ()\n+{\n+  __builtin_memset (&s2, -1, sizeof (s2));\n+  __builtin_memset (&t2, -1, sizeof (t2));\n+  __builtin_memset (&u2, -1, sizeof (u2));\n+  foo (&t1, &u1);\n+  foo (&t2, &u2);\n+  __builtin_clear_padding (&s2);\n+  __builtin_clear_padding (&t2);\n+  __builtin_clear_padding (&u2);\n+  if (__builtin_memcmp (&s1, &s2, sizeof (s1))\n+      || __builtin_memcmp (&t1, &t2, sizeof (t1))\n+      || __builtin_memcmp (&u1, &u2, sizeof (u1)))\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "19cc78f6610406e18284cc87bb7a20ec750046d1", "filename": "gcc/testsuite/g++.dg/torture/builtin-clear-padding-2.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bea0d0aa5936cb36b6f86f721ca03c1a1bb601d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fbuiltin-clear-padding-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bea0d0aa5936cb36b6f86f721ca03c1a1bb601d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fbuiltin-clear-padding-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fbuiltin-clear-padding-2.C?ref=1bea0d0aa5936cb36b6f86f721ca03c1a1bb601d", "patch": "@@ -0,0 +1,34 @@\n+/* PR libstdc++/88101 */\n+\n+#include <new>\n+\n+struct S { char a; short b; char c; long long d; char e; decltype (nullptr) f; char g; };\n+alignas (S) unsigned char buf1[sizeof (S)];\n+alignas (S) unsigned char buf2[sizeof (S)];\n+\n+template <int N>\n+void\n+foo ()\n+{\n+  __builtin_clear_padding ((S *) buf2);\n+}\n+\n+void\n+bar (S *s)\n+{\n+  s->a = -1; s->b = -1; s->c = -1; s->d = -1; s->e = -1; s->g = -1;\n+}\n+\n+int\n+main ()\n+{\n+  S *s1 = new (buf1) S;\n+  S *s2 = new (buf2) S;\n+  __builtin_memset (s1, 0, sizeof (S));\n+  __builtin_memset (s2, ~0, sizeof (S));\n+  bar (s1);\n+  bar (s2);\n+  foo <0> ();\n+  if (__builtin_memcmp (s1, s2, sizeof (S)) != 0)\n+    __builtin_abort ();\n+}"}, {"sha": "27ffc0a57ce0348981505d85aa3b3e11357bacfb", "filename": "gcc/testsuite/gcc.dg/builtin-clear-padding-1.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bea0d0aa5936cb36b6f86f721ca03c1a1bb601d/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-clear-padding-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bea0d0aa5936cb36b6f86f721ca03c1a1bb601d/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-clear-padding-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-clear-padding-1.c?ref=1bea0d0aa5936cb36b6f86f721ca03c1a1bb601d", "patch": "@@ -0,0 +1,10 @@\n+/* PR libstdc++/88101 */\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+\n+void\n+foo (int n)\n+{\n+  struct S { char a; int b[n]; long long c; } s;\n+  __builtin_clear_padding (&s);\t\t/* { dg-message \"unimplemented: __builtin_clear_padding not supported for variable length aggregates\" } */\n+}"}]}