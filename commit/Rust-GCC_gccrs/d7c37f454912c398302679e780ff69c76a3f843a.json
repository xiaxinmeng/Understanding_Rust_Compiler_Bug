{"sha": "d7c37f454912c398302679e780ff69c76a3f843a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDdjMzdmNDU0OTEyYzM5ODMwMjY3OWU3ODBmZjY5Yzc2YTNmODQzYQ==", "commit": {"author": {"name": "Steve Baird", "email": "baird@adacore.com", "date": "2019-12-13T09:03:23Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-12-13T09:03:23Z"}, "message": "[Ada] Implement AI12-0101\n\n2019-12-13  Steve Baird  <baird@adacore.com>\n\ngcc/ada/\n\n\t* exp_ch4.adb (Expand_N_Op_Eq.Is_Equality): Move this function\n\tfrom within Expand_N_Op_Eq.Find_Equality out to immediately\n\twithin Expand_N_Op_Eq in order to give it greater visibility.\n\tAdd a new Typ parameter (defaulted to Empty) which, if\n\tnon-empty, means the function will return False in the case of\n\tan equality op for some other type.\n\t* (Expand_N_Op_Eq.User_Defined_Primitive_Equality_Op): A new\n\tfunction. Given an untagged record type, finds the corresponding\n\tuser-defined primitive equality op (if any).  May return Empty.\n\tIgnores visibility.\n\t* (Expand_N_Op): For Ada2012 or later, check for presence of a\n\tuser-defined primitive equality op before falling back on the\n\tusual predefined component-by-component comparison. If found,\n\tthen call the user-defined op instead.\n\nFrom-SVN: r279341", "tree": {"sha": "cc993cb5ae5c6ea6313b482185f3bb896799859e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc993cb5ae5c6ea6313b482185f3bb896799859e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d7c37f454912c398302679e780ff69c76a3f843a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7c37f454912c398302679e780ff69c76a3f843a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7c37f454912c398302679e780ff69c76a3f843a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7c37f454912c398302679e780ff69c76a3f843a/comments", "author": {"login": "swbaird", "id": 50751052, "node_id": "MDQ6VXNlcjUwNzUxMDUy", "avatar_url": "https://avatars.githubusercontent.com/u/50751052?v=4", "gravatar_id": "", "url": "https://api.github.com/users/swbaird", "html_url": "https://github.com/swbaird", "followers_url": "https://api.github.com/users/swbaird/followers", "following_url": "https://api.github.com/users/swbaird/following{/other_user}", "gists_url": "https://api.github.com/users/swbaird/gists{/gist_id}", "starred_url": "https://api.github.com/users/swbaird/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/swbaird/subscriptions", "organizations_url": "https://api.github.com/users/swbaird/orgs", "repos_url": "https://api.github.com/users/swbaird/repos", "events_url": "https://api.github.com/users/swbaird/events{/privacy}", "received_events_url": "https://api.github.com/users/swbaird/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "08f4f1721a05c77c8ee0cbd437c944d7c795f0d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08f4f1721a05c77c8ee0cbd437c944d7c795f0d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08f4f1721a05c77c8ee0cbd437c944d7c795f0d5"}], "stats": {"total": 151, "additions": 115, "deletions": 36}, "files": [{"sha": "402933b8ab14d8131e5ca840153f9646ee6e6ed6", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c37f454912c398302679e780ff69c76a3f843a/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c37f454912c398302679e780ff69c76a3f843a/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d7c37f454912c398302679e780ff69c76a3f843a", "patch": "@@ -1,3 +1,20 @@\n+2019-12-13  Steve Baird  <baird@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_N_Op_Eq.Is_Equality): Move this function\n+\tfrom within Expand_N_Op_Eq.Find_Equality out to immediately\n+\twithin Expand_N_Op_Eq in order to give it greater visibility.\n+\tAdd a new Typ parameter (defaulted to Empty) which, if\n+\tnon-empty, means the function will return False in the case of\n+\tan equality op for some other type.\n+\t* (Expand_N_Op_Eq.User_Defined_Primitive_Equality_Op): A new\n+\tfunction. Given an untagged record type, finds the corresponding\n+\tuser-defined primitive equality op (if any).  May return Empty.\n+\tIgnores visibility.\n+\t* (Expand_N_Op): For Ada2012 or later, check for presence of a\n+\tuser-defined primitive equality op before falling back on the\n+\tusual predefined component-by-component comparison. If found,\n+\tthen call the user-defined op instead.\n+\n 2019-12-13  Justin Squirek  <squirek@adacore.com>\n \n \t* sem_ch6.adb (Check_Overriding_Indicator): Modify condition to"}, {"sha": "19558236e0cf5b91d08c3063e8a98829cde5a22a", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 98, "deletions": 36, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c37f454912c398302679e780ff69c76a3f843a/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c37f454912c398302679e780ff69c76a3f843a/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=d7c37f454912c398302679e780ff69c76a3f843a", "patch": "@@ -7520,10 +7520,21 @@ package body Exp_Ch4 is\n       --  build and analyze call, adding conversions if the operation is\n       --  inherited.\n \n+      function Is_Equality (Subp : Entity_Id;\n+                            Typ  : Entity_Id := Empty) return Boolean;\n+      --  Determine whether arbitrary Entity_Id denotes a function with the\n+      --  right name and profile for an equality op, specifically for the\n+      --  base type Typ if Typ is nonempty.\n+\n       function Find_Equality (Prims : Elist_Id) return Entity_Id;\n       --  Find a primitive equality function within primitive operation list\n       --  Prims.\n \n+      function User_Defined_Primitive_Equality_Op\n+        (Typ : Entity_Id) return Entity_Id;\n+      --  Find a user-defined primitive equality function for a given untagged\n+      --  record type, ignoring visibility. Return Empty if no such op found.\n+\n       function Has_Unconstrained_UU_Component (Typ : Entity_Id) return Boolean;\n       --  Determines whether a type has a subcomponent of an unconstrained\n       --  Unchecked_Union subtype. Typ is a record type.\n@@ -7772,6 +7783,43 @@ package body Exp_Ch4 is\n          Analyze_And_Resolve (N, Standard_Boolean, Suppress => All_Checks);\n       end Build_Equality_Call;\n \n+      -----------------\n+      -- Is_Equality --\n+      -----------------\n+\n+      function Is_Equality (Subp : Entity_Id;\n+                            Typ  : Entity_Id := Empty) return Boolean is\n+         Formal_1 : Entity_Id;\n+         Formal_2 : Entity_Id;\n+      begin\n+         --  The equality function carries name \"=\", returns Boolean, and has\n+         --  exactly two formal parameters of an identical type.\n+\n+         if Ekind (Subp) = E_Function\n+           and then Chars (Subp) = Name_Op_Eq\n+           and then Base_Type (Etype (Subp)) = Standard_Boolean\n+         then\n+            Formal_1 := First_Formal (Subp);\n+            Formal_2 := Empty;\n+\n+            if Present (Formal_1) then\n+               Formal_2 := Next_Formal (Formal_1);\n+            end if;\n+\n+            return\n+              Present (Formal_1)\n+                and then Present (Formal_2)\n+                and then No (Next_Formal (Formal_2))\n+                and then Base_Type (Etype (Formal_1)) =\n+                         Base_Type (Etype (Formal_2))\n+                and then\n+                  (not Present (Typ)\n+                    or else Implementation_Base_Type (Etype (Formal_1)) = Typ);\n+         end if;\n+\n+         return False;\n+      end Is_Equality;\n+\n       -------------------\n       -- Find_Equality --\n       -------------------\n@@ -7781,9 +7829,6 @@ package body Exp_Ch4 is\n          --  Find an equality in a possible alias chain starting from primitive\n          --  operation Prim.\n \n-         function Is_Equality (Id : Entity_Id) return Boolean;\n-         --  Determine whether arbitrary entity Id denotes an equality\n-\n          ---------------------------\n          -- Find_Aliased_Equality --\n          ---------------------------\n@@ -7807,39 +7852,6 @@ package body Exp_Ch4 is\n             return Empty;\n          end Find_Aliased_Equality;\n \n-         -----------------\n-         -- Is_Equality --\n-         -----------------\n-\n-         function Is_Equality (Id : Entity_Id) return Boolean is\n-            Formal_1 : Entity_Id;\n-            Formal_2 : Entity_Id;\n-\n-         begin\n-            --  The equality function carries name \"=\", returns Boolean, and\n-            --  has exactly two formal parameters of an identical type.\n-\n-            if Ekind (Id) = E_Function\n-              and then Chars (Id) = Name_Op_Eq\n-              and then Base_Type (Etype (Id)) = Standard_Boolean\n-            then\n-               Formal_1 := First_Formal (Id);\n-               Formal_2 := Empty;\n-\n-               if Present (Formal_1) then\n-                  Formal_2 := Next_Formal (Formal_1);\n-               end if;\n-\n-               return\n-                 Present (Formal_1)\n-                   and then Present (Formal_2)\n-                   and then Etype (Formal_1) = Etype (Formal_2)\n-                   and then No (Next_Formal (Formal_2));\n-            end if;\n-\n-            return False;\n-         end Is_Equality;\n-\n          --  Local variables\n \n          Eq_Prim   : Entity_Id;\n@@ -7869,6 +7881,47 @@ package body Exp_Ch4 is\n          return Eq_Prim;\n       end Find_Equality;\n \n+      ----------------------------------------\n+      -- User_Defined_Primitive_Equality_Op --\n+      ----------------------------------------\n+\n+      function User_Defined_Primitive_Equality_Op\n+        (Typ : Entity_Id) return Entity_Id\n+      is\n+         Enclosing_Scope : constant Node_Id := Scope (Typ);\n+         E : Entity_Id;\n+      begin\n+         --  Prune this search by somehow not looking at decls that precede\n+         --  the declaration of the first view of Typ (which might be a partial\n+         --  view)???\n+\n+         for Private_Entities in Boolean loop\n+            if Private_Entities then\n+               if Ekind (Enclosing_Scope) /= E_Package then\n+                  exit;\n+               end if;\n+               E := First_Private_Entity (Enclosing_Scope);\n+\n+            else\n+               E := First_Entity (Enclosing_Scope);\n+            end if;\n+\n+            while Present (E) loop\n+               if Is_Equality (E, Typ) then\n+                  return E;\n+               end if;\n+               E := Next_Entity (E);\n+            end loop;\n+         end loop;\n+\n+         if Is_Derived_Type (Typ) then\n+            return User_Defined_Primitive_Equality_Op\n+                     (Implementation_Base_Type (Etype (Typ)));\n+         end if;\n+\n+         return Empty;\n+      end User_Defined_Primitive_Equality_Op;\n+\n       ------------------------------------\n       -- Has_Unconstrained_UU_Component --\n       ------------------------------------\n@@ -8190,6 +8243,15 @@ package body Exp_Ch4 is\n                  (Find_Equality (Primitive_Operations (Typl)));\n             end if;\n \n+         --  See AI12-0101 (which only removes a legality rule) and then\n+         --  AI05-0123 (which then applies in the previously illegal case).\n+         --  AI12-0101 is a binding interpretation.\n+\n+         elsif Ada_Version >= Ada_2012\n+           and then Present (User_Defined_Primitive_Equality_Op (Typl))\n+         then\n+            Build_Equality_Call (User_Defined_Primitive_Equality_Op (Typl));\n+\n          --  Ada 2005 (AI-216): Program_Error is raised when evaluating the\n          --  predefined equality operator for a type which has a subcomponent\n          --  of an Unchecked_Union type whose nominal subtype is unconstrained."}]}