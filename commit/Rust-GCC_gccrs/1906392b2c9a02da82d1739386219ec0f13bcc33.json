{"sha": "1906392b2c9a02da82d1739386219ec0f13bcc33", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTkwNjM5MmIyYzlhMDJkYTgyZDE3MzkzODYyMTllYzBmMTNiY2MzMw==", "commit": {"author": {"name": "Andrew Sutton", "email": "asutton@lock3software.com", "date": "2019-11-27T14:02:49Z"}, "committer": {"name": "Andrew Sutton", "email": "asutton@gcc.gnu.org", "date": "2019-11-27T14:02:49Z"}, "message": "Diagnose certain constraint errors as hard errors, but otherwise treat them the same as normal SFINAE-type errors.\n\n2019-11-27  Andrew Sutton  <asutton@lock3software.com>\n\n\tDiagnose certain constraint errors as hard errors, but otherwise treat\n\tthem the same as normal SFINAE-type errors. Also, generally clean up\n\tthe satisfaction functions.\n\ngcc/cp/\n\t* constexpr.c (cxx_eval_constant_expression): Use\n\tevaluate_concept_check.\n\t* constraint.cc (normalize_concept_definition): Accept a diagnostic\n\tflag and only cache when not diagnosing errors.\n\t(decl_satisfied_cache): Map to trees instead of bools.\n\t(satisfy_atom): Guarantee a location for the errors, propagate complain\n\tflags to force_rvalue, and emit errors for non-boolean constraints.\n\t(get_normalized_constraints_and_args): New overloads. Factored out of\n\tsatisfy_constraint_expression and satisfy_declaration_constraints.\n\t(satisfy_constraint_expression): Propagate diagnostic info to\n\tnormalization.\n\t(satisfy_declaration_constraints): New. Factored out of\n\tconstraints_satisfied_p.\n\t(constraint_satisfaction_value): New. Calls\n\tsatisfy_constraint_expression or satisfy_declaration_constraints.\n\t(constraints_satisfied_p): Call constraint_satisfaction_value.\n\t(evaluate_concept_check): Don't take tsubst_falgs_t. Replay\n\tsatisfaction if an error is encountered.\n\t(current_failed_constraint): Moved from pt.c.\n\t(diagnose_constraints): Call constraint_satisfaction_value.\n\t* cp-tree.h: Update declarations.\n\t* pt.c (current_failed_constraint): Moved to constraint.cc.\n\t* semantics.c (finish_id_expression_1): Remove a duplicate case.\n\ngcc/testsuite/\n\t* g++.dg/concepts/pr84330.C: Update diagnostics.\n\t* g++.dg/cpp2a/concepts-requires2.C: Likewise.\n\nFrom-SVN: r278768", "tree": {"sha": "a7fc0e30e92fb6d419ec84c49136bf5c86cd753d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a7fc0e30e92fb6d419ec84c49136bf5c86cd753d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1906392b2c9a02da82d1739386219ec0f13bcc33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1906392b2c9a02da82d1739386219ec0f13bcc33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1906392b2c9a02da82d1739386219ec0f13bcc33", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1906392b2c9a02da82d1739386219ec0f13bcc33/comments", "author": {"login": "asutton", "id": 570796, "node_id": "MDQ6VXNlcjU3MDc5Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/570796?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asutton", "html_url": "https://github.com/asutton", "followers_url": "https://api.github.com/users/asutton/followers", "following_url": "https://api.github.com/users/asutton/following{/other_user}", "gists_url": "https://api.github.com/users/asutton/gists{/gist_id}", "starred_url": "https://api.github.com/users/asutton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asutton/subscriptions", "organizations_url": "https://api.github.com/users/asutton/orgs", "repos_url": "https://api.github.com/users/asutton/repos", "events_url": "https://api.github.com/users/asutton/events{/privacy}", "received_events_url": "https://api.github.com/users/asutton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "45a454883eef8acbdad75c0f376aaf22ec7416ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45a454883eef8acbdad75c0f376aaf22ec7416ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45a454883eef8acbdad75c0f376aaf22ec7416ff"}], "stats": {"total": 261, "additions": 145, "deletions": 116}, "files": [{"sha": "5f770e939d8e50620f9babb7ab000bafa0b48ba4", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1906392b2c9a02da82d1739386219ec0f13bcc33/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1906392b2c9a02da82d1739386219ec0f13bcc33/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=1906392b2c9a02da82d1739386219ec0f13bcc33", "patch": "@@ -1,3 +1,33 @@\n+2019-11-27  Andrew Sutton  <asutton@lock3software.com>\n+\n+\tDiagnose certain constraint errors as hard errors, but otherwise treat\n+\tthem the same as normal SFINAE-type errors. Also, generally clean up\n+\tthe satisfaction functions.\n+\n+\t* constexpr.c (cxx_eval_constant_expression): Use\n+\tevaluate_concept_check.\n+\t* constraint.cc (normalize_concept_definition): Accept a diagnostic\n+\tflag and only cache when not diagnosing errors.\n+\t(decl_satisfied_cache): Map to trees instead of bools.\n+\t(satisfy_atom): Guarantee a location for the errors, propagate complain\n+\tflags to force_rvalue, and emit errors for non-boolean constraints.\n+\t(get_normalized_constraints_and_args): New overloads. Factored out of\n+\tsatisfy_constraint_expression and satisfy_declaration_constraints.\n+\t(satisfy_constraint_expression): Propagate diagnostic info to\n+\tnormalization.\n+\t(satisfy_declaration_constraints): New. Factored out of\n+\tconstraints_satisfied_p.\n+\t(constraint_satisfaction_value): New. Calls\n+\tsatisfy_constraint_expression or satisfy_declaration_constraints.\n+\t(constraints_satisfied_p): Call constraint_satisfaction_value.\n+\t(evaluate_concept_check): Don't take tsubst_falgs_t. Replay\n+\tsatisfaction if an error is encountered.\n+\t(current_failed_constraint): Moved from pt.c.\n+\t(diagnose_constraints): Call constraint_satisfaction_value.\n+\t* cp-tree.h: Update declarations.\n+\t* pt.c (current_failed_constraint): Moved to constraint.cc.\n+\t* semantics.c (finish_id_expression_1): Remove a duplicate case.\n+\n 2019-11-27  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/92524"}, {"sha": "32d929b82f3d489dd42854e5d4fbf4ad32246aea", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1906392b2c9a02da82d1739386219ec0f13bcc33/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1906392b2c9a02da82d1739386219ec0f13bcc33/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=1906392b2c9a02da82d1739386219ec0f13bcc33", "patch": "@@ -5649,7 +5649,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t  internal_error (\"unexpected template-id %qE\", t);\n \n \tif (!processing_template_decl)\n-\t  return satisfy_constraint_expression (t);\n+\t  return evaluate_concept_check (t, tf_warning_or_error);\n \telse\n \t  *non_constant_p = true;\n \treturn t;"}, {"sha": "d29c33a9bbfc24bd7be029a5cc1dba2ef068bebb", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 96, "deletions": 94, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1906392b2c9a02da82d1739386219ec0f13bcc33/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1906392b2c9a02da82d1739386219ec0f13bcc33/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=1906392b2c9a02da82d1739386219ec0f13bcc33", "patch": "@@ -849,21 +849,26 @@ get_normalized_constraints_from_decl (tree d, bool diag = false)\n /* Returns the normal form of TMPL's definition.  */\n \n static tree\n-normalize_concept_definition (tree tmpl)\n+normalize_concept_definition (tree tmpl, bool diag = false)\n {\n-  if (tree *p = hash_map_safe_get (normalized_map, tmpl))\n-    return *p;\n+  if (!diag)\n+    if (tree *p = hash_map_safe_get (normalized_map, tmpl))\n+      return *p;\n+\n   gcc_assert (concept_definition_p (tmpl));\n   if (OVL_P (tmpl))\n     tmpl = OVL_FIRST (tmpl);\n   gcc_assert (TREE_CODE (tmpl) == TEMPLATE_DECL);\n   tree args = generic_targs_for (tmpl);\n   tree def = get_concept_definition (DECL_TEMPLATE_RESULT (tmpl));\n   ++processing_template_decl;\n-  norm_info info (tmpl, tf_none);\n+  norm_info info (tmpl, diag ? tf_norm : tf_none);\n   tree norm = get_normalized_constraints (def, args, info);\n   --processing_template_decl;\n-  hash_map_safe_put<hm_ggc> (normalized_map, tmpl, norm);\n+\n+  if (!diag)\n+    hash_map_safe_put<hm_ggc> (normalized_map, tmpl, norm);\n+\n   return norm;\n }\n \n@@ -2231,8 +2236,8 @@ struct sat_hasher : ggc_ptr_hash<sat_entry>\n /* Cache the result of satisfy_atom.  */\n static GTY((deletable)) hash_table<sat_hasher> *sat_cache;\n \n-/* Cache the result of constraints_satisfied_p.  */\n-static GTY((deletable)) hash_map<tree,bool> *decl_satisfied_cache;\n+/* Cache the result of constraint_satisfaction_value.  */\n+static GTY((deletable)) hash_map<tree, tree> *decl_satisfied_cache;\n \n static tree\n get_satisfaction (tree constr, tree args)\n@@ -2481,21 +2486,17 @@ satisfy_atom (tree t, tree args, subst_info info)\n       return cache.save (boolean_false_node);\n     }\n \n-  location_t loc = cp_expr_location (expr);\n+  location_t loc = cp_expr_loc_or_input_loc (expr);\n \n   /* [17.4.1.2] ... lvalue-to-value conversion is performed as necessary,\n      and EXPR shall be a constant expression of type bool.  */\n-  result = force_rvalue (result, tf_error);\n+  result = force_rvalue (result, info.complain);\n   if (result == error_mark_node)\n-    {\n-      if (info.noisy ())\n-        inform (loc, \"cannot convert constraint to rvalue\");\n-      return cache.save (error_mark_node);\n-    }\n+    return cache.save (error_mark_node);\n   if (!same_type_p (TREE_TYPE (result), boolean_type_node))\n     {\n       if (info.noisy ())\n-\tinform (loc, \"constraint does not have type %<bool%>\");\n+\terror_at (loc, \"constraint does not have type %<bool%>\");\n       return cache.save (error_mark_node);\n     }\n \n@@ -2560,7 +2561,7 @@ satisfy_constraint (tree t, tree args, subst_info info)\n static tree\n satisfy_associated_constraints (tree t, tree args, subst_info info)\n {\n-  /* If there are no constraints then this is trivially satisfied. */\n+  /* If there are no constraints then this is trivially satisfied.  */\n   if (!t)\n     return boolean_true_node;\n \n@@ -2576,24 +2577,31 @@ satisfy_associated_constraints (tree t, tree args, subst_info info)\n    satisfaction value. */\n \n static tree\n-satisfy_constraint_expression (tree expr, tree args, subst_info info)\n+satisfy_constraint_expression (tree t, tree args, subst_info info)\n {\n-  /* Normalize the expression before satisfaction testing.  */\n+  if (t == error_mark_node)\n+    return error_mark_node;\n+\n+  gcc_assert (EXPR_P (t));\n+\n+  /* Get the normalized constraints.  */\n   tree norm;\n-  if (args == NULL_TREE && concept_check_p (expr))\n+  if (args == NULL_TREE && concept_check_p (t))\n     {\n-      tree id = unpack_concept_check (expr);\n+      tree id = unpack_concept_check (t);\n       args = TREE_OPERAND (id, 1);\n       tree tmpl = get_concept_check_template (id);\n-      norm = normalize_concept_definition (tmpl);\n+      norm = normalize_concept_definition (tmpl, info.noisy ());\n     }\n   else\n-    norm = normalize_constraint_expression (expr);\n+    norm = normalize_constraint_expression (t, info.noisy ());\n+\n+  /* Perform satisfaction.  */\n   return satisfy_constraint (norm, args, info);\n }\n \n-/* Used to evaluate concept checks and requires-expressions during\n-   constant expression evaluation.  */\n+/* Used only to evaluate requires-expressions during constant expression\n+   evaluation.  */\n \n tree\n satisfy_constraint_expression (tree expr)\n@@ -2602,20 +2610,10 @@ satisfy_constraint_expression (tree expr)\n   return satisfy_constraint_expression (expr, NULL_TREE, info);\n }\n \n-/* True if T is satisfied for ARGS.  */\n-\n-static bool\n-constraint_expression_satisfied_p (tree t, tree args, subst_info info)\n-{\n-  tree r = satisfy_constraint_expression (t, args, info);\n-  return r == boolean_true_node;\n-}\n-\n-static bool\n-constraints_satisfied_p (tree t, subst_info info)\n+static tree\n+satisfy_declaration_constraints (tree t, subst_info info)\n {\n-  if (!DECL_P (t))\n-    return constraint_expression_satisfied_p (t, NULL_TREE, info);\n+  gcc_assert (DECL_P (t));\n \n   /* For inherited constructors, consider the original declaration;\n      it has the correct template information attached. */\n@@ -2626,21 +2624,19 @@ constraints_satisfied_p (tree t, subst_info info)\n   info.in_decl = t;\n \n   if (info.quiet ())\n-    if (bool *p = hash_map_safe_get (decl_satisfied_cache, t))\n-      return *p;\n+    if (tree *result = hash_map_safe_get (decl_satisfied_cache, t))\n+      return *result;\n \n-  /* Get the constraints to check for satisfaction. This depends\n-     on whether we're looking at a template specialization or not. */\n+  /* Get the normalized constraints.  */\n   tree norm = NULL_TREE;\n   tree args = NULL_TREE;\n-  tree ti = DECL_TEMPLATE_INFO (t);\n-  if (ti)\n+  if (tree ti = DECL_TEMPLATE_INFO (t))\n     {\n       tree tmpl = TI_TEMPLATE (ti);\n       norm = normalize_template_requirements (tmpl, info.noisy ());\n \n       /* The initial parameter mapping is the complete set of\n-         template arguments substituted into the declaration.  */\n+\t template arguments substituted into the declaration.  */\n       args = TI_ARGS (ti);\n     }\n   else\n@@ -2649,44 +2645,23 @@ constraints_satisfied_p (tree t, subst_info info)\n       norm = normalize_nontemplate_requirements (t, info.noisy ());\n     }\n \n-  bool r = true;\n+  tree result = boolean_true_node;\n   if (norm)\n     {\n       push_access_scope (t);\n-      tree eval = satisfy_associated_constraints (norm, args, info);\n+      result = satisfy_associated_constraints (norm, args, info);\n       pop_access_scope (t);\n-      r = (eval == boolean_true_node);\n     }\n \n   if (info.quiet ())\n-    hash_map_safe_put<hm_ggc> (decl_satisfied_cache, t, r);\n-\n-  return r;\n-}\n+    hash_map_safe_put<hm_ggc> (decl_satisfied_cache, t, result);\n \n-/* Returns true if the T's constraints are satisfied, of if T is an expression,\n-   if T is satisfied. This is used in cases where the arguments can be\n-   determined from the declaration or expression.\n-\n-   Note that T is typically a template specialization.  */\n-\n-bool\n-constraints_satisfied_p (tree t)\n-{\n-  subst_info info (tf_none, NULL_TREE);\n-  return constraints_satisfied_p (t, info);\n+  return result;\n }\n \n-/* Returns true if the expression or constrained declaration T is\n-   satisfied by ARGS.  In this case, we don't have a specialization\n-   where we can cache the results (e.g., alias templates).  */\n-\n-static bool\n-constraints_satisfied_p (tree t, tree args, subst_info info)\n+static tree\n+satisfy_declaration_constraints (tree t, tree args, subst_info info)\n {\n-  if (!DECL_P (t))\n-    return constraint_expression_satisfied_p (t, args, info);\n-\n   /* Update the declaration for diagnostics.  */\n   info.in_decl = t;\n \n@@ -2695,46 +2670,72 @@ constraints_satisfied_p (tree t, tree args, subst_info info)\n     {\n       tree pattern = DECL_TEMPLATE_RESULT (t);\n       push_access_scope (pattern);\n-      tree eval = satisfy_associated_constraints (norm, args, info);\n+      tree result = satisfy_associated_constraints (norm, args, info);\n       pop_access_scope (pattern);\n-      return eval == boolean_true_node;\n+      return result;\n     }\n \n-  return true;\n+  return boolean_true_node;\n }\n \n+static tree\n+constraint_satisfaction_value (tree t, tsubst_flags_t complain)\n+{\n+  subst_info info (complain, NULL_TREE);\n+  if (DECL_P (t))\n+    return satisfy_declaration_constraints (t, info);\n+  else\n+    return satisfy_constraint_expression (t, NULL_TREE, info);\n+}\n+\n+static tree\n+constraint_satisfaction_value (tree t, tree args, tsubst_flags_t complain)\n+{\n+  subst_info info (complain, NULL_TREE);\n+  if (DECL_P (t))\n+    return satisfy_declaration_constraints (t, args, info);\n+  else\n+    return satisfy_constraint_expression (t, args, info);\n+}\n+\n+/* True iff the result of satisfying T is BOOLEAN_TRUE_NODE and false\n+   otherwise, even in the case of errors.  */\n+\n+bool\n+constraints_satisfied_p (tree t)\n+{\n+  return constraint_satisfaction_value (t, tf_none) == boolean_true_node;\n+}\n+\n+/* True iff the result of satisfying T with ARGS is BOOLEAN_TRUE_NODE\n+    and false otherwise, even in the case of errors.  */\n+\n bool\n constraints_satisfied_p (tree t, tree args)\n {\n-  subst_info info (tf_none, NULL);\n-  return constraints_satisfied_p (t, args, info);\n+  return constraint_satisfaction_value (t, args, tf_none) == boolean_true_node;\n }\n \n-/* Evaluate a concept check of the form C<ARGS>, returning either TRUE\n-   or FALSE. If ARGS contains any template parameters, this returns the\n-   check. If satisfaction yields a hard error, diagnose the error.  */\n+/* Evaluate a concept check of the form C<ARGS>. This is only used for the\n+   evaluation of template-ids as id-expressions.  */\n \n tree\n evaluate_concept_check (tree check, tsubst_flags_t complain)\n {\n-  /* FIXME we ought to be able to pass complain into subst_info rather\n-     than repeat satisfaction, but currently that will complain about\n-     non-satisfaction as well as errors.  */\n   if (check == error_mark_node)\n     return error_mark_node;\n \n   gcc_assert (concept_check_p (check));\n \n-  subst_info info (tf_none, NULL_TREE);\n-  tree result = satisfy_constraint_expression (check, NULL_TREE, info);\n+  /* Check for satisfaction without diagnostics.  */\n+  subst_info quiet (tf_none, NULL_TREE);\n+  tree result = satisfy_constraint_expression (check, NULL_TREE, quiet);\n   if (result == error_mark_node && (complain & tf_error))\n-    {\n-      location_t loc = cp_expr_loc_or_input_loc (check);\n-      error_at (loc, \"concept satisfaction failed\");\n-      info.complain = complain;\n-      satisfy_constraint_expression (check, NULL_TREE, info);\n-    }\n-\n+  {\n+    /* Replay the error with re-normalized requirements.  */\n+    subst_info noisy (tf_warning_or_error, NULL_TREE);\n+    satisfy_constraint_expression (check, NULL_TREE, noisy);\n+  }\n   return result;\n }\n \n@@ -3275,6 +3276,8 @@ diagnose_atomic_constraint (tree t, tree args, subst_info info)\n     }\n }\n \n+GTY(()) tree current_failed_constraint;\n+\n diagnosing_failed_constraint::\n diagnosing_failed_constraint (tree t, tree args, bool diag)\n   : diagnosing_error (diag)\n@@ -3299,11 +3302,10 @@ diagnose_constraints (location_t loc, tree t, tree args)\n   inform (loc, \"constraints not satisfied\");\n \n   /* Replay satisfaction, but diagnose errors.  */\n-  subst_info info (tf_warning_or_error, NULL_TREE);\n   if (!args)\n-    constraints_satisfied_p (t, info);\n+    constraint_satisfaction_value (t, tf_warning_or_error);\n   else\n-    constraints_satisfied_p (t, args, info);\n+    constraint_satisfaction_value (t, args, tf_warning_or_error);\n }\n \n #include \"gt-cp-constraint.h\""}, {"sha": "4b4bc245d8104b235e3e8d9ba1fcff28254067c0", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1906392b2c9a02da82d1739386219ec0f13bcc33/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1906392b2c9a02da82d1739386219ec0f13bcc33/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=1906392b2c9a02da82d1739386219ec0f13bcc33", "patch": "@@ -7821,8 +7821,8 @@ extern bool processing_constraint_expression_p\t();\n extern tree unpack_concept_check\t\t(tree);\n extern tree evaluate_concept_check              (tree, tsubst_flags_t);\n extern tree satisfy_constraint_expression\t(tree);\n-extern bool constraints_satisfied_p             (tree);\n-extern bool constraints_satisfied_p             (tree, tree);\n+extern bool constraints_satisfied_p\t\t(tree);\n+extern bool constraints_satisfied_p\t\t(tree, tree);\n extern void clear_satisfaction_cache\t\t();\n extern bool* lookup_subsumption_result          (tree, tree);\n extern bool save_subsumption_result             (tree, tree, bool);"}, {"sha": "4261d3c4cc934736964bb1123375211564bfb048", "filename": "gcc/cp/error.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1906392b2c9a02da82d1739386219ec0f13bcc33/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1906392b2c9a02da82d1739386219ec0f13bcc33/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=1906392b2c9a02da82d1739386219ec0f13bcc33", "patch": "@@ -3358,6 +3358,9 @@ cp_print_error_function (diagnostic_context *context,\n      to be wrong, so just rely on print_instantiation_full_context.  */\n   if (current_instantiation ())\n     return;\n+  /* The above is true for constraint satisfaction also.  */\n+  if (current_failed_constraint)\n+    return;\n   if (diagnostic_last_function_changed (context, diagnostic))\n     {\n       char *old_prefix = pp_take_prefix (context->printer);"}, {"sha": "eb907c5638502bb942badf17e4e8d87bcf3e1165", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1906392b2c9a02da82d1739386219ec0f13bcc33/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1906392b2c9a02da82d1739386219ec0f13bcc33/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=1906392b2c9a02da82d1739386219ec0f13bcc33", "patch": "@@ -28736,8 +28736,6 @@ convert_generic_types_to_packs (tree parm, int start_idx, int end_idx)\n   return tsubst (parm, replacement, tf_none, NULL_TREE);\n }\n \n-GTY(()) tree current_failed_constraint;\n-\n /* __integer_pack(N) in a pack expansion expands to a sequence of numbers from\n    0..N-1.  */\n "}, {"sha": "6c4785c6858df154a9d25358f1f7b53f9d482b90", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1906392b2c9a02da82d1739386219ec0f13bcc33/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1906392b2c9a02da82d1739386219ec0f13bcc33/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=1906392b2c9a02da82d1739386219ec0f13bcc33", "patch": "@@ -3970,16 +3970,6 @@ finish_id_expression_1 (tree id_expression,\n \n \t  decl = baselink_for_fns (decl);\n \t}\n-      else if (concept_check_p (decl))\n-\t{\n-\t  /* If this is a standard or variable concept check, potentially\n-\t     evaluate it. Function concepts need to be called as functions,\n-\t     so don't try evaluating them here.  */\n-\t  tree tmpl = TREE_OPERAND (decl, 0);\n-\t  tree args = TREE_OPERAND (decl, 1);\n-\t  if (!function_concept_p (tmpl) && !uses_template_parms (args))\n-\t    decl = evaluate_concept_check (decl, tf_warning_or_error);\n-\t}\n       else\n \t{\n \t  if (DECL_P (decl) && DECL_NONLOCAL (decl)"}, {"sha": "4c01d147bf710b64f51594ce190a2c92f986f5b3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1906392b2c9a02da82d1739386219ec0f13bcc33/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1906392b2c9a02da82d1739386219ec0f13bcc33/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1906392b2c9a02da82d1739386219ec0f13bcc33", "patch": "@@ -1,3 +1,9 @@\n+2019-11-27  Andrew Sutton  <asutton@lock3software.com>\n+\n+\tEmit hard errors for certain satisfaction errors.\n+\t* g++.dg/concepts/pr84330.C: Update diagnostics.\n+\t* g++.dg/cpp2a/concepts-requires2.C: Likewise.\n+\n 2019-11-27  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/92690"}, {"sha": "ba035d02555cee7417b8405d915532a137403a73", "filename": "gcc/testsuite/g++.dg/concepts/pr84330.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1906392b2c9a02da82d1739386219ec0f13bcc33/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr84330.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1906392b2c9a02da82d1739386219ec0f13bcc33/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr84330.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr84330.C?ref=1906392b2c9a02da82d1739386219ec0f13bcc33", "patch": "@@ -5,7 +5,7 @@\n struct A\n {\n   template<typename T>\n-    requires (sizeof(T) >> 0)\n+    requires (sizeof(T) >> 0) // { dg-error \"constraint does not have type 'bool'\" }\n   void foo(T);\n \n   void bar()"}, {"sha": "8643f46a16d513bd36c369f1bc3eb48433edbf65", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-requires2.C", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1906392b2c9a02da82d1739386219ec0f13bcc33/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1906392b2c9a02da82d1739386219ec0f13bcc33/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires2.C?ref=1906392b2c9a02da82d1739386219ec0f13bcc33", "patch": "@@ -12,7 +12,7 @@ template<typename T> constexpr fool p1() { return {}; }\n template<typename T> constexpr fool p2() { return {}; }\n \n template<typename T>\n-concept Bad = p1<T>() && p2<T>();\n+concept Bad = p1<T>() && p2<T>(); // { dg-error \"does not have type 'bool'\" }\n \n template<typename T> requires Bad<T> void bad(T x) { }\n \n@@ -26,14 +26,14 @@ struct X { };\n int operator==(X, X) { return 0; }\n \n template<typename T>\n-concept C1 = (X());\n+concept C1 = (X()); // { dg-error \"does not have type 'bool'\" }\n \n template<typename T>\n-concept C2 = (X() == X());\n+concept C2 = (X() == X()); // { dg-error \"does not have type 'bool'\" }\n \n template<typename T>\n   requires C1<T>\n-void h1(T) { } \n+void h1(T) { }\n \n template<typename T>\n   requires C2<T>\n@@ -42,12 +42,12 @@ void h2(T);\n void driver_3()\n {\n   h1(0); // { dg-error \"\" }\n-  h2(0); // { dg-error \"\" } \n+  h2(0); // { dg-error \"\" }\n }\n \n // req7.C\n template<bool B>\n-struct boolean_constant \n+struct boolean_constant\n {\n   constexpr operator bool() const { return B; }\n };"}]}