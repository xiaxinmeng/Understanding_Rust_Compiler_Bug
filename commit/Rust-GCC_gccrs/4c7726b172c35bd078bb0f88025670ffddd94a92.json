{"sha": "4c7726b172c35bd078bb0f88025670ffddd94a92", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGM3NzI2YjE3MmMzNWJkMDc4YmIwZjg4MDI1NjcwZmZkZGQ5NGE5Mg==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@waitaki.otago.ac.nz", "date": "2001-10-16T09:01:40Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2001-10-16T09:01:40Z"}, "message": "Makefile.am, [...]: Imported GC 6.1 Alpha 1 and merged local changes.\n\n\t* Makefile.am, acinclude.m4, configure.in: Imported GC 6.1 Alpha 1\n\tand merged local changes.\n\nFrom-SVN: r46283", "tree": {"sha": "483dc5098530e605b23e445c94fcdfdfec0d9b23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/483dc5098530e605b23e445c94fcdfdfec0d9b23"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4c7726b172c35bd078bb0f88025670ffddd94a92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c7726b172c35bd078bb0f88025670ffddd94a92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c7726b172c35bd078bb0f88025670ffddd94a92", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c7726b172c35bd078bb0f88025670ffddd94a92/comments", "author": null, "committer": null, "parents": [{"sha": "107abb2f61f6e53ebb7aa05b78fdd9234ee7877c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/107abb2f61f6e53ebb7aa05b78fdd9234ee7877c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/107abb2f61f6e53ebb7aa05b78fdd9234ee7877c"}], "stats": {"total": 1025, "additions": 669, "deletions": 356}, "files": [{"sha": "f91eab38474bfbc9337883846617ffb6f8d62ab9", "filename": "boehm-gc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FChangeLog?ref=4c7726b172c35bd078bb0f88025670ffddd94a92", "patch": "@@ -1,3 +1,8 @@\n+2001-10-16  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>\n+\n+\t* Makefile.am, acinclude.m4, configure.in: Imported GC 6.1 Alpha 1 and\n+\tmerged local changes.\n+\n 2001-09-26  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>\n \n \t* solaris_threads.c (MAX_ORIG_STACK_SIZE) [I386]: Provide special"}, {"sha": "5cbba052eb75c080381eefd314c195fd7e6239a5", "filename": "boehm-gc/Makefile.am", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMakefile.am?ref=4c7726b172c35bd078bb0f88025670ffddd94a92", "patch": "@@ -42,7 +42,7 @@ libgcjgc_la_LDFLAGS = -version-info 1:1:0 -rpath $(toolexeclibdir)\n EXTRA_libgcjgc_la_SOURCES = alpha_mach_dep.s \\\n mips_sgi_mach_dep.s mips_ultrix_mach_dep.s powerpc_macosx_mach_dep.s \\\n rs6000_mach_dep.s sparc_mach_dep.s sparc_netbsd_mach_dep.s \\\n-sparc_sunos4_mach_dep.s\n+sparc_sunos4_mach_dep.s ia64_save_regs_in_stack.s\n \n AM_CXXFLAGS = @GC_CFLAGS@\n AM_CFLAGS = @GC_CFLAGS@\n@@ -51,7 +51,9 @@ check_PROGRAMS = gctest\n # The following hack produces a warning from automake, but we need it in order \n # to build a file from a subdirectory. FIXME.\n test.o:\ttests/test.c\n-\t$(COMPILE) -c $<\n+\t$(COMPILE) -c tests/test.c\n+# \tUsing $< in the above seems to fail with the HP/UX on Itanium make.\n+\n gctest_OBJECTS = test.o\n gctest_LDADD = ./libgcjgc.la $(THREADLIBS) $(EXTRA_TEST_LIBS)\n gctest_LDFLAGS = -shared-libgcc"}, {"sha": "7aadaf34b449981d52562a390ab6da1267354d99", "filename": "boehm-gc/Makefile.dj", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2FMakefile.dj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2FMakefile.dj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMakefile.dj?ref=4c7726b172c35bd078bb0f88025670ffddd94a92", "patch": "@@ -5,6 +5,8 @@\n # Primary targets:\n # gc.a - builds basic library\n # libgc.a - builds library for use with g++ \"-fgc-keyword\" extension\n+#\t    -fgc-keyword was never really available.  Historical\n+#\t    interest only.\n # c++ - adds C++ interface to library\n # cords - adds cords (heavyweight strings) to library\n # test - prints porting information, then builds basic version of gc.a,"}, {"sha": "1dd426f78760e1b5f2ca032dd02d97067d547086", "filename": "boehm-gc/Makefile.in", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMakefile.in?ref=4c7726b172c35bd078bb0f88025670ffddd94a92", "patch": "@@ -1,4 +1,4 @@\n-# Makefile.in generated automatically by automake 1.4 from Makefile.am\n+# Makefile.in generated automatically by automake 1.4-p1 from Makefile.am\n \n # Copyright (C) 1994, 1995-8, 1999 Free Software Foundation, Inc.\n # This Makefile.in is free software; the Free Software Foundation\n@@ -120,14 +120,16 @@ libgcjgc_la_LIBADD = @addobjs@ $(THREADLIBS)\n libgcjgc_la_DEPENDENCIES = @addobjs@\n libgcjgc_la_LDFLAGS = -version-info 1:1:0 -rpath $(toolexeclibdir)\n \n-EXTRA_libgcjgc_la_SOURCES = alpha_mach_dep.s mips_sgi_mach_dep.s mips_ultrix_mach_dep.s powerpc_macosx_mach_dep.s rs6000_mach_dep.s sparc_mach_dep.s sparc_netbsd_mach_dep.s sparc_sunos4_mach_dep.s\n+EXTRA_libgcjgc_la_SOURCES = alpha_mach_dep.s mips_sgi_mach_dep.s mips_ultrix_mach_dep.s powerpc_macosx_mach_dep.s rs6000_mach_dep.s sparc_mach_dep.s sparc_netbsd_mach_dep.s sparc_sunos4_mach_dep.s ia64_save_regs_in_stack.s\n \n \n AM_CXXFLAGS = @GC_CFLAGS@\n \n AM_CFLAGS = @GC_CFLAGS@\n \n check_PROGRAMS = gctest\n+# \tUsing $< in the above seems to fail with the HP/UX on Itanium make.\n+\n gctest_OBJECTS = test.o\n gctest_LDADD = ./libgcjgc.la $(THREADLIBS) $(EXTRA_TEST_LIBS)\n gctest_LDFLAGS = -shared-libgcc\n@@ -548,7 +550,7 @@ mostlyclean distclean maintainer-clean\n # The following hack produces a warning from automake, but we need it in order \n # to build a file from a subdirectory. FIXME.\n test.o:\ttests/test.c\n-\t$(COMPILE) -c $<\n+\t$(COMPILE) -c tests/test.c\n $(all_objs) : include/private/gcconfig.h include/private/gc_priv.h \\\n include/private/gc_hdrs.h include/gc.h include/gc_gcj.h include/gc_mark.h\n "}, {"sha": "5f0b5462427db7a24abf786c844b8ba97ecb2e29", "filename": "boehm-gc/NT_THREADS_MAKEFILE", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2FNT_THREADS_MAKEFILE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2FNT_THREADS_MAKEFILE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FNT_THREADS_MAKEFILE?ref=4c7726b172c35bd078bb0f88025670ffddd94a92", "patch": "@@ -114,10 +114,10 @@ CLEAN :\n \n CPP=cl.exe\n # ADD BASE CPP /nologo /MT /W3 /GX /O2 /D \"WIN32\" /D \"NDEBUG\" /D \"_WINDOWS\" /YX /c\n-# ADD CPP /nologo /MD /W3 /GX /O2 /I include /D \"NDEBUG\" /D \"SILENT\" /D \"GC_BUILD\" /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"WIN32_THREADS\" /FR /YX /c\n+# ADD CPP /nologo /MD /W3 /GX /O2 /I include /D \"NDEBUG\" /D \"SILENT\" /D \"GC_BUILD\" /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"GC_WIN32_THREADS\" /FR /YX /c\n CPP_PROJ=/nologo /MD /W3 /GX /O2 /I include /D \"NDEBUG\" /D \"SILENT\" /D \"GC_BUILD\" /D\\\n  \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D\\\n- \"WIN32_THREADS\" /FR\"$(INTDIR)/\" /Fp\"$(INTDIR)/gc.pch\" /YX /Fo\"$(INTDIR)/\" /c \n+ \"GC_WIN32_THREADS\" /FR\"$(INTDIR)/\" /Fp\"$(INTDIR)/gc.pch\" /YX /Fo\"$(INTDIR)/\" /c \n CPP_OBJS=.\\Release/\n CPP_SBRS=.\\Release/\n \n@@ -296,10 +296,10 @@ CLEAN :\n \n CPP=cl.exe\n # ADD BASE CPP /nologo /MTd /W3 /Gm /GX /Zi /Od /D \"WIN32\" /D \"_DEBUG\" /D \"_WINDOWS\" /YX /c\n-# ADD CPP /nologo /MDd /W3 /Gm /GX /Zi /Od /I include /D \"_DEBUG\" /D \"SILENT\" /D \"GC_BUILD\" /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"WIN32_THREADS\" /FR /YX /c\n+# ADD CPP /nologo /MDd /W3 /Gm /GX /Zi /Od /I include /D \"_DEBUG\" /D \"SILENT\" /D \"GC_BUILD\" /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"GC_WIN32_THREADS\" /FR /YX /c\n CPP_PROJ=/nologo /MDd /W3 /Gm /GX /Zi /Od /I include /D \"_DEBUG\" /D \"SILENT\" /D \"GC_BUILD\"\\\n  /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D\\\n- \"WIN32_THREADS\" /FR\"$(INTDIR)/\" /Fp\"$(INTDIR)/gc.pch\" /YX /Fo\"$(INTDIR)/\"\\\n+ \"GC_WIN32_THREADS\" /FR\"$(INTDIR)/\" /Fp\"$(INTDIR)/gc.pch\" /YX /Fo\"$(INTDIR)/\"\\\n  /Fd\"$(INTDIR)/\" /c \n CPP_OBJS=.\\Debug/\n CPP_SBRS=.\\Debug/\n@@ -430,9 +430,9 @@ test.c : tests\\test.c\n \n CPP=cl.exe\n # ADD BASE CPP /nologo /W3 /GX /O2 /D \"WIN32\" /D \"NDEBUG\" /D \"_WINDOWS\" /YX /c\n-# ADD CPP /nologo /MD /W3 /GX /O2 /I include /D \"NDEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"WIN32_THREADS\" /YX /c\n+# ADD CPP /nologo /MD /W3 /GX /O2 /I include /D \"NDEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"GC_WIN32_THREADS\" /YX /c\n CPP_PROJ=/nologo /MD /W3 /GX /O2 /I include /D \"NDEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D\\\n- \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"WIN32_THREADS\"\\\n+ \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"GC_WIN32_THREADS\"\\\n  /Fp\"$(INTDIR)/gctest.pch\" /YX /Fo\"$(INTDIR)/\" /c \n CPP_OBJS=.\\gctest\\Release/\n CPP_SBRS=.\\.\n@@ -516,9 +516,9 @@ CLEAN :\n \n CPP=cl.exe\n # ADD BASE CPP /nologo /W3 /Gm /GX /Zi /Od /D \"WIN32\" /D \"_DEBUG\" /D \"_WINDOWS\" /YX /c\n-# ADD CPP /nologo /MDd /W3 /Gm /GX /Zi /Od /D \"_DEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"WIN32_THREADS\" /FR /YX /c\n+# ADD CPP /nologo /MDd /W3 /Gm /GX /Zi /Od /D \"_DEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"GC_WIN32_THREADS\" /FR /YX /c\n CPP_PROJ=/nologo /MDd /W3 /Gm /GX /Zi /Od /I include /D \"_DEBUG\" /D \"WIN32\" /D \"_WINDOWS\"\\\n- /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"WIN32_THREADS\" /FR\"$(INTDIR)/\"\\\n+ /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"GC_WIN32_THREADS\" /FR\"$(INTDIR)/\"\\\n  /Fp\"$(INTDIR)/gctest.pch\" /YX /Fo\"$(INTDIR)/\" /Fd\"$(INTDIR)/\" /c \n CPP_OBJS=.\\gctest\\Debug/\n CPP_SBRS=.\\gctest\\Debug/"}, {"sha": "ce61e6c3a97fdcf4e21aae3a8d2b9ab3ab70469d", "filename": "boehm-gc/acinclude.m4", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Facinclude.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Facinclude.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Facinclude.m4?ref=4c7726b172c35bd078bb0f88025670ffddd94a92", "patch": "@@ -55,7 +55,7 @@ AC_CANONICAL_SYSTEM\n mkinstalldirs=\"`cd $ac_aux_dir && pwd`/mkinstalldirs\"\n AC_SUBST(mkinstalldirs)\n \n-AM_INIT_AUTOMAKE(gc, 6.0, no-define)\n+AM_INIT_AUTOMAKE(gc, 6.1a1, no-define)\n \n # FIXME: We temporarily define our own version of AC_PROG_CC.  This is\n # copied from autoconf 2.12, but does not call AC_PROG_CC_WORKS.  We"}, {"sha": "06582ec792ec7fa72f35b17e9cdd97b29c8a8191", "filename": "boehm-gc/allchblk.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Fallchblk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Fallchblk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fallchblk.c?ref=4c7726b172c35bd078bb0f88025670ffddd94a92", "patch": "@@ -774,6 +774,7 @@ signed_word size;\n       if (HBLK_IS_FREE(hhdr)) {\n         GC_printf1(\"Duplicate large block deallocation of 0x%lx\\n\",\n         \t   (unsigned long) hbp);\n+\tABORT(\"Duplicate large block deallocation\");\n       }\n \n     GC_ASSERT(IS_MAPPED(hhdr));"}, {"sha": "6a82392666851cf07036279799843856df97ffb3", "filename": "boehm-gc/configure", "status": "modified", "additions": 100, "deletions": 67, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fconfigure?ref=4c7726b172c35bd078bb0f88025670ffddd94a92", "patch": "@@ -40,6 +40,8 @@ ac_help=\"$ac_help\n   --enable-parallel-mark\tparallelize marking and free list construction\"\n ac_help=\"$ac_help\n   --with-ecos             enable runtime eCos target support\"\n+ac_help=\"$ac_help\n+  --enable-shared[=PKGS]  build shared libraries [default=no]\"\n ac_help=\"$ac_help\n   --enable-full-debug\tinclude full support for pointer backtracing etc.\"\n \n@@ -585,7 +587,7 @@ ac_configure=$ac_aux_dir/configure # This should be Cygnus configure.\n # SVR4 /usr/ucb/install, which tries to use the nonexistent group \"staff\"\n # ./install, which can be erroneously created by make from ./install.sh.\n echo $ac_n \"checking for a BSD compatible install\"\"... $ac_c\" 1>&6\n-echo \"configure:589: checking for a BSD compatible install\" >&5\n+echo \"configure:591: checking for a BSD compatible install\" >&5\n if test -z \"$INSTALL\"; then\n if eval \"test \\\"`echo '$''{'ac_cv_path_install'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n@@ -638,7 +640,7 @@ test -z \"$INSTALL_SCRIPT\" && INSTALL_SCRIPT='${INSTALL_PROGRAM}'\n test -z \"$INSTALL_DATA\" && INSTALL_DATA='${INSTALL} -m 644'\n \n echo $ac_n \"checking whether build environment is sane\"\"... $ac_c\" 1>&6\n-echo \"configure:642: checking whether build environment is sane\" >&5\n+echo \"configure:644: checking whether build environment is sane\" >&5\n # Just in case\n sleep 1\n echo timestamp > conftestfile\n@@ -695,7 +697,7 @@ test \"$program_suffix\" != NONE &&\n test \"$program_transform_name\" = \"\" && program_transform_name=\"s,x,x,\"\n \n echo $ac_n \"checking whether ${MAKE-make} sets \\${MAKE}\"\"... $ac_c\" 1>&6\n-echo \"configure:699: checking whether ${MAKE-make} sets \\${MAKE}\" >&5\n+echo \"configure:701: checking whether ${MAKE-make} sets \\${MAKE}\" >&5\n set dummy ${MAKE-make}; ac_make=`echo \"$2\" | sed 'y%./+-%__p_%'`\n if eval \"test \\\"`echo '$''{'ac_cv_prog_make_${ac_make}_set'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n@@ -728,12 +730,12 @@ else\n fi\n \n echo $ac_n \"checking for Cygwin environment\"\"... $ac_c\" 1>&6\n-echo \"configure:732: checking for Cygwin environment\" >&5\n+echo \"configure:734: checking for Cygwin environment\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_cygwin'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 737 \"configure\"\n+#line 739 \"configure\"\n #include \"confdefs.h\"\n \n int main() {\n@@ -744,7 +746,7 @@ int main() {\n return __CYGWIN__;\n ; return 0; }\n EOF\n-if { (eval echo configure:748: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:750: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_cygwin=yes\n else\n@@ -761,19 +763,19 @@ echo \"$ac_t\"\"$ac_cv_cygwin\" 1>&6\n CYGWIN=\n test \"$ac_cv_cygwin\" = yes && CYGWIN=yes\n echo $ac_n \"checking for mingw32 environment\"\"... $ac_c\" 1>&6\n-echo \"configure:765: checking for mingw32 environment\" >&5\n+echo \"configure:767: checking for mingw32 environment\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_mingw32'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 770 \"configure\"\n+#line 772 \"configure\"\n #include \"confdefs.h\"\n \n int main() {\n return __MINGW32__;\n ; return 0; }\n EOF\n-if { (eval echo configure:777: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:779: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_mingw32=yes\n else\n@@ -884,7 +886,7 @@ else { echo \"configure: error: can not run $ac_config_sub\" 1>&2; exit 1; }\n fi\n \n echo $ac_n \"checking host system type\"\"... $ac_c\" 1>&6\n-echo \"configure:888: checking host system type\" >&5\n+echo \"configure:890: checking host system type\" >&5\n \n host_alias=$host\n case \"$host_alias\" in\n@@ -905,7 +907,7 @@ host_os=`echo $host | sed 's/^\\([^-]*\\)-\\([^-]*\\)-\\(.*\\)$/\\3/'`\n echo \"$ac_t\"\"$host\" 1>&6\n \n echo $ac_n \"checking target system type\"\"... $ac_c\" 1>&6\n-echo \"configure:909: checking target system type\" >&5\n+echo \"configure:911: checking target system type\" >&5\n \n target_alias=$target\n case \"$target_alias\" in\n@@ -923,7 +925,7 @@ target_os=`echo $target | sed 's/^\\([^-]*\\)-\\([^-]*\\)-\\(.*\\)$/\\3/'`\n echo \"$ac_t\"\"$target\" 1>&6\n \n echo $ac_n \"checking build system type\"\"... $ac_c\" 1>&6\n-echo \"configure:927: checking build system type\" >&5\n+echo \"configure:929: checking build system type\" >&5\n \n build_alias=$build\n case \"$build_alias\" in\n@@ -963,7 +965,7 @@ fi\n \n missing_dir=`cd $ac_aux_dir && pwd`\n echo $ac_n \"checking for working aclocal\"\"... $ac_c\" 1>&6\n-echo \"configure:967: checking for working aclocal\" >&5\n+echo \"configure:969: checking for working aclocal\" >&5\n # Run test in a subshell; some versions of sh will print an error if\n # an executable is not found, even if stderr is redirected.\n # Redirect stdin to placate older versions of autoconf.  Sigh.\n@@ -976,7 +978,7 @@ else\n fi\n \n echo $ac_n \"checking for working autoconf\"\"... $ac_c\" 1>&6\n-echo \"configure:980: checking for working autoconf\" >&5\n+echo \"configure:982: checking for working autoconf\" >&5\n # Run test in a subshell; some versions of sh will print an error if\n # an executable is not found, even if stderr is redirected.\n # Redirect stdin to placate older versions of autoconf.  Sigh.\n@@ -989,7 +991,7 @@ else\n fi\n \n echo $ac_n \"checking for working automake\"\"... $ac_c\" 1>&6\n-echo \"configure:993: checking for working automake\" >&5\n+echo \"configure:995: checking for working automake\" >&5\n # Run test in a subshell; some versions of sh will print an error if\n # an executable is not found, even if stderr is redirected.\n # Redirect stdin to placate older versions of autoconf.  Sigh.\n@@ -1002,7 +1004,7 @@ else\n fi\n \n echo $ac_n \"checking for working autoheader\"\"... $ac_c\" 1>&6\n-echo \"configure:1006: checking for working autoheader\" >&5\n+echo \"configure:1008: checking for working autoheader\" >&5\n # Run test in a subshell; some versions of sh will print an error if\n # an executable is not found, even if stderr is redirected.\n # Redirect stdin to placate older versions of autoconf.  Sigh.\n@@ -1015,7 +1017,7 @@ else\n fi\n \n echo $ac_n \"checking for working makeinfo\"\"... $ac_c\" 1>&6\n-echo \"configure:1019: checking for working makeinfo\" >&5\n+echo \"configure:1021: checking for working makeinfo\" >&5\n # Run test in a subshell; some versions of sh will print an error if\n # an executable is not found, even if stderr is redirected.\n # Redirect stdin to placate older versions of autoconf.  Sigh.\n@@ -1041,7 +1043,7 @@ fi\n # Extract the first word of \"gcc\", so it can be a program name with args.\n set dummy gcc; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1045: checking for $ac_word\" >&5\n+echo \"configure:1047: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CC'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1071,7 +1073,7 @@ if test -z \"$CC\"; then\n   # Extract the first word of \"cc\", so it can be a program name with args.\n set dummy cc; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1075: checking for $ac_word\" >&5\n+echo \"configure:1077: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CC'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1120,7 +1122,7 @@ fi\n fi\n \n echo $ac_n \"checking whether we are using GNU C\"\"... $ac_c\" 1>&6\n-echo \"configure:1124: checking whether we are using GNU C\" >&5\n+echo \"configure:1126: checking whether we are using GNU C\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_gcc'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1129,7 +1131,7 @@ else\n   yes;\n #endif\n EOF\n-if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:1133: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then\n+if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:1135: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then\n   ac_cv_prog_gcc=yes\n else\n   ac_cv_prog_gcc=no\n@@ -1144,7 +1146,7 @@ if test $ac_cv_prog_gcc = yes; then\n   ac_save_CFLAGS=\"$CFLAGS\"\n   CFLAGS=\n   echo $ac_n \"checking whether ${CC-cc} accepts -g\"\"... $ac_c\" 1>&6\n-echo \"configure:1148: checking whether ${CC-cc} accepts -g\" >&5\n+echo \"configure:1150: checking whether ${CC-cc} accepts -g\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_cc_g'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1181,7 +1183,7 @@ do\n # Extract the first word of \"$ac_prog\", so it can be a program name with args.\n set dummy $ac_prog; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1185: checking for $ac_word\" >&5\n+echo \"configure:1187: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CXX'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1214,7 +1216,7 @@ test -n \"$CXX\" || CXX=\"gcc\"\n test -z \"$CXX\" && { echo \"configure: error: no acceptable c++ found in \\$PATH\" 1>&2; exit 1; }\n \n echo $ac_n \"checking whether we are using GNU C++\"\"... $ac_c\" 1>&6\n-echo \"configure:1218: checking whether we are using GNU C++\" >&5\n+echo \"configure:1220: checking whether we are using GNU C++\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_gxx'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1223,7 +1225,7 @@ else\n   yes;\n #endif\n EOF\n-if { ac_try='${CXX-g++} -E conftest.C'; { (eval echo configure:1227: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then\n+if { ac_try='${CXX-g++} -E conftest.C'; { (eval echo configure:1229: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then\n   ac_cv_prog_gxx=yes\n else\n   ac_cv_prog_gxx=no\n@@ -1238,7 +1240,7 @@ if test $ac_cv_prog_gxx = yes; then\n   ac_save_CXXFLAGS=\"$CXXFLAGS\"\n   CXXFLAGS=\n   echo $ac_n \"checking whether ${CXX-g++} accepts -g\"\"... $ac_c\" 1>&6\n-echo \"configure:1242: checking whether ${CXX-g++} accepts -g\" >&5\n+echo \"configure:1244: checking whether ${CXX-g++} accepts -g\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_cxx_g'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1271,7 +1273,7 @@ fi\n # NEWLIB_CONFIGURE, which doesn't work because that means that it will\n # be run before AC_CANONICAL_HOST.\n echo $ac_n \"checking build system type\"\"... $ac_c\" 1>&6\n-echo \"configure:1275: checking build system type\" >&5\n+echo \"configure:1277: checking build system type\" >&5\n \n build_alias=$build\n case \"$build_alias\" in\n@@ -1292,7 +1294,7 @@ echo \"$ac_t\"\"$build\" 1>&6\n # Extract the first word of \"${ac_tool_prefix}as\", so it can be a program name with args.\n set dummy ${ac_tool_prefix}as; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1296: checking for $ac_word\" >&5\n+echo \"configure:1298: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_AS'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1324,7 +1326,7 @@ fi\n # Extract the first word of \"${ac_tool_prefix}ar\", so it can be a program name with args.\n set dummy ${ac_tool_prefix}ar; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1328: checking for $ac_word\" >&5\n+echo \"configure:1330: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_AR'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1356,7 +1358,7 @@ fi\n # Extract the first word of \"${ac_tool_prefix}ranlib\", so it can be a program name with args.\n set dummy ${ac_tool_prefix}ranlib; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1360: checking for $ac_word\" >&5\n+echo \"configure:1362: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1388,7 +1390,7 @@ if test -n \"$ac_tool_prefix\"; then\n   # Extract the first word of \"ranlib\", so it can be a program name with args.\n set dummy ranlib; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1392: checking for $ac_word\" >&5\n+echo \"configure:1394: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1433,7 +1435,7 @@ fi\n # SVR4 /usr/ucb/install, which tries to use the nonexistent group \"staff\"\n # ./install, which can be erroneously created by make from ./install.sh.\n echo $ac_n \"checking for a BSD compatible install\"\"... $ac_c\" 1>&6\n-echo \"configure:1437: checking for a BSD compatible install\" >&5\n+echo \"configure:1439: checking for a BSD compatible install\" >&5\n if test -z \"$INSTALL\"; then\n if eval \"test \\\"`echo '$''{'ac_cv_path_install'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n@@ -1487,7 +1489,7 @@ test -z \"$INSTALL_DATA\" && INSTALL_DATA='${INSTALL} -m 644'\n \n \n echo $ac_n \"checking whether to enable maintainer-specific portions of Makefiles\"\"... $ac_c\" 1>&6\n-echo \"configure:1491: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n+echo \"configure:1493: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n     # Check whether --enable-maintainer-mode or --disable-maintainer-mode was given.\n if test \"${enable_maintainer_mode+set}\" = set; then\n   enableval=\"$enable_maintainer_mode\"\n@@ -1525,7 +1527,7 @@ if false; then\n   \n \n echo $ac_n \"checking for executable suffix\"\"... $ac_c\" 1>&6\n-echo \"configure:1529: checking for executable suffix\" >&5\n+echo \"configure:1531: checking for executable suffix\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_exeext'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1535,7 +1537,7 @@ else\n   rm -f conftest*\n   echo 'int main () { return 0; }' > conftest.$ac_ext\n   ac_cv_exeext=\n-  if { (eval echo configure:1539: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; }; then\n+  if { (eval echo configure:1541: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; }; then\n     for file in conftest.*; do\n       case $file in\n       *.c | *.o | *.obj) ;;\n@@ -1657,7 +1659,7 @@ ac_prog=ld\n if test \"$GCC\" = yes; then\n   # Check if gcc -print-prog-name=ld gives a path.\n   echo $ac_n \"checking for ld used by GCC\"\"... $ac_c\" 1>&6\n-echo \"configure:1661: checking for ld used by GCC\" >&5\n+echo \"configure:1663: checking for ld used by GCC\" >&5\n   case $host in\n   *-*-mingw*)\n     # gcc leaves a trailing carriage return which upsets mingw\n@@ -1687,10 +1689,10 @@ echo \"configure:1661: checking for ld used by GCC\" >&5\n   esac\n elif test \"$with_gnu_ld\" = yes; then\n   echo $ac_n \"checking for GNU ld\"\"... $ac_c\" 1>&6\n-echo \"configure:1691: checking for GNU ld\" >&5\n+echo \"configure:1693: checking for GNU ld\" >&5\n else\n   echo $ac_n \"checking for non-GNU ld\"\"... $ac_c\" 1>&6\n-echo \"configure:1694: checking for non-GNU ld\" >&5\n+echo \"configure:1696: checking for non-GNU ld\" >&5\n fi\n if eval \"test \\\"`echo '$''{'lt_cv_path_LD'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n@@ -1725,7 +1727,7 @@ else\n fi\n test -z \"$LD\" && { echo \"configure: error: no acceptable ld found in \\$PATH\" 1>&2; exit 1; }\n echo $ac_n \"checking if the linker ($LD) is GNU ld\"\"... $ac_c\" 1>&6\n-echo \"configure:1729: checking if the linker ($LD) is GNU ld\" >&5\n+echo \"configure:1731: checking if the linker ($LD) is GNU ld\" >&5\n if eval \"test \\\"`echo '$''{'lt_cv_prog_gnu_ld'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1742,7 +1744,7 @@ with_gnu_ld=$lt_cv_prog_gnu_ld\n \n \n echo $ac_n \"checking for $LD option to reload object files\"\"... $ac_c\" 1>&6\n-echo \"configure:1746: checking for $LD option to reload object files\" >&5\n+echo \"configure:1748: checking for $LD option to reload object files\" >&5\n if eval \"test \\\"`echo '$''{'lt_cv_ld_reload_flag'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1754,7 +1756,7 @@ reload_flag=$lt_cv_ld_reload_flag\n test -n \"$reload_flag\" && reload_flag=\" $reload_flag\"\n \n echo $ac_n \"checking for BSD-compatible nm\"\"... $ac_c\" 1>&6\n-echo \"configure:1758: checking for BSD-compatible nm\" >&5\n+echo \"configure:1760: checking for BSD-compatible nm\" >&5\n if eval \"test \\\"`echo '$''{'lt_cv_path_NM'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1792,7 +1794,7 @@ NM=\"$lt_cv_path_NM\"\n echo \"$ac_t\"\"$NM\" 1>&6\n \n echo $ac_n \"checking whether ln -s works\"\"... $ac_c\" 1>&6\n-echo \"configure:1796: checking whether ln -s works\" >&5\n+echo \"configure:1798: checking whether ln -s works\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_LN_S'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1813,7 +1815,7 @@ else\n fi\n \n echo $ac_n \"checking how to recognise dependant libraries\"\"... $ac_c\" 1>&6\n-echo \"configure:1817: checking how to recognise dependant libraries\" >&5\n+echo \"configure:1819: checking how to recognise dependant libraries\" >&5\n if eval \"test \\\"`echo '$''{'lt_cv_deplibs_check_method'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1977,13 +1979,13 @@ file_magic_cmd=$lt_cv_file_magic_cmd\n deplibs_check_method=$lt_cv_deplibs_check_method\n \n echo $ac_n \"checking for object suffix\"\"... $ac_c\" 1>&6\n-echo \"configure:1981: checking for object suffix\" >&5\n+echo \"configure:1983: checking for object suffix\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_objext'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   rm -f conftest*\n echo 'int i = 1;' > conftest.$ac_ext\n-if { (eval echo configure:1987: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:1989: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   for ac_file in conftest.*; do\n     case $ac_file in\n     *.c) ;;\n@@ -2007,7 +2009,7 @@ case $deplibs_check_method in\n file_magic*)\n   if test \"$file_magic_cmd\" = '$MAGIC_CMD'; then\n     echo $ac_n \"checking for ${ac_tool_prefix}file\"\"... $ac_c\" 1>&6\n-echo \"configure:2011: checking for ${ac_tool_prefix}file\" >&5\n+echo \"configure:2013: checking for ${ac_tool_prefix}file\" >&5\n if eval \"test \\\"`echo '$''{'lt_cv_path_MAGIC_CMD'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2069,7 +2071,7 @@ fi\n if test -z \"$lt_cv_path_MAGIC_CMD\"; then\n   if test -n \"$ac_tool_prefix\"; then\n     echo $ac_n \"checking for file\"\"... $ac_c\" 1>&6\n-echo \"configure:2073: checking for file\" >&5\n+echo \"configure:2075: checking for file\" >&5\n if eval \"test \\\"`echo '$''{'lt_cv_path_MAGIC_CMD'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2140,7 +2142,7 @@ esac\n # Extract the first word of \"${ac_tool_prefix}ranlib\", so it can be a program name with args.\n set dummy ${ac_tool_prefix}ranlib; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:2144: checking for $ac_word\" >&5\n+echo \"configure:2146: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2172,7 +2174,7 @@ if test -n \"$ac_tool_prefix\"; then\n   # Extract the first word of \"ranlib\", so it can be a program name with args.\n set dummy ranlib; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:2176: checking for $ac_word\" >&5\n+echo \"configure:2178: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2207,7 +2209,7 @@ fi\n # Extract the first word of \"${ac_tool_prefix}strip\", so it can be a program name with args.\n set dummy ${ac_tool_prefix}strip; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:2211: checking for $ac_word\" >&5\n+echo \"configure:2213: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_STRIP'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2239,7 +2241,7 @@ if test -n \"$ac_tool_prefix\"; then\n   # Extract the first word of \"strip\", so it can be a program name with args.\n set dummy strip; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:2243: checking for $ac_word\" >&5\n+echo \"configure:2245: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_STRIP'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2306,8 +2308,8 @@ test x\"$pic_mode\" = xno && libtool_flags=\"$libtool_flags --prefer-non-pic\"\n case $host in\n *-*-irix6*)\n   # Find out which ABI we are using.\n-  echo '#line 2310 \"configure\"' > conftest.$ac_ext\n-  if { (eval echo configure:2311: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+  echo '#line 2312 \"configure\"' > conftest.$ac_ext\n+  if { (eval echo configure:2313: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n     case `/usr/bin/file conftest.$ac_objext` in\n     *32-bit*)\n       LD=\"${LD-ld} -32\"\n@@ -2328,7 +2330,7 @@ case $host in\n   SAVE_CFLAGS=\"$CFLAGS\"\n   CFLAGS=\"$CFLAGS -belf\"\n   echo $ac_n \"checking whether the C compiler needs -belf\"\"... $ac_c\" 1>&6\n-echo \"configure:2332: checking whether the C compiler needs -belf\" >&5\n+echo \"configure:2334: checking whether the C compiler needs -belf\" >&5\n if eval \"test \\\"`echo '$''{'lt_cv_cc_needs_belf'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2341,14 +2343,14 @@ ac_link='${CC-cc} -o conftest${ac_exeext} $CFLAGS $CPPFLAGS $LDFLAGS conftest.$a\n cross_compiling=$ac_cv_prog_cc_cross\n \n      cat > conftest.$ac_ext <<EOF\n-#line 2345 \"configure\"\n+#line 2347 \"configure\"\n #include \"confdefs.h\"\n \n int main() {\n \n ; return 0; }\n EOF\n-if { (eval echo configure:2352: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:2354: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   lt_cv_cc_needs_belf=yes\n else\n@@ -2378,7 +2380,7 @@ echo \"$ac_t\"\"$lt_cv_cc_needs_belf\" 1>&6\n esac\n \n echo $ac_n \"checking how to run the C++ preprocessor\"\"... $ac_c\" 1>&6\n-echo \"configure:2382: checking how to run the C++ preprocessor\" >&5\n+echo \"configure:2384: checking how to run the C++ preprocessor\" >&5\n if test -z \"$CXXCPP\"; then\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CXXCPP'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n@@ -2391,12 +2393,12 @@ ac_link='${CXX-g++} -o conftest${ac_exeext} $CXXFLAGS $CPPFLAGS $LDFLAGS conftes\n cross_compiling=$ac_cv_prog_cxx_cross\n   CXXCPP=\"${CXX-g++} -E\"\n   cat > conftest.$ac_ext <<EOF\n-#line 2395 \"configure\"\n+#line 2397 \"configure\"\n #include \"confdefs.h\"\n #include <stdlib.h>\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:2400: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:2402: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n if test -z \"$ac_err\"; then\n   :\n@@ -2543,7 +2545,7 @@ fi\n \n \n echo $ac_n \"checking whether to enable maintainer-specific portions of Makefiles\"\"... $ac_c\" 1>&6\n-echo \"configure:2547: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n+echo \"configure:2549: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n     # Check whether --enable-maintainer-mode or --disable-maintainer-mode was given.\n if test \"${enable_maintainer_mode+set}\" = set; then\n   enableval=\"$enable_maintainer_mode\"\n@@ -2576,7 +2578,7 @@ if false; then\n   \n \n echo $ac_n \"checking for executable suffix\"\"... $ac_c\" 1>&6\n-echo \"configure:2580: checking for executable suffix\" >&5\n+echo \"configure:2582: checking for executable suffix\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_exeext'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2586,7 +2588,7 @@ else\n   rm -f conftest*\n   echo 'int main () { return 0; }' > conftest.$ac_ext\n   ac_cv_exeext=\n-  if { (eval echo configure:2590: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; }; then\n+  if { (eval echo configure:2592: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; }; then\n     for file in conftest.*; do\n       case $file in\n       *.c | *.o | *.obj) ;;\n@@ -2609,7 +2611,7 @@ ac_exeext=$EXEEXT\n fi\n \n echo $ac_n \"checking for thread model used by GCC\"\"... $ac_c\" 1>&6\n-echo \"configure:2613: checking for thread model used by GCC\" >&5\n+echo \"configure:2615: checking for thread model used by GCC\" >&5\n THREADS=`$CC -v 2>&1 | sed -n 's/^Thread model: //p'`\n if test -z \"$THREADS\"; then\n    THREADS=no\n@@ -2693,7 +2695,7 @@ EOF\n      *-*-freebsd*)\n \techo \"configure: warning: \"FreeBSD does not yet fully support threads with Boehm GC.\"\" 1>&2\n \tcat >> confdefs.h <<\\EOF\n-#define FREEBSD_THREADS 1\n+#define GC_FREEBSD_THREADS 1\n EOF\n \n \tINCLUDES=\"$INCLUDES -pthread\"\n@@ -2730,15 +2732,15 @@ esac\n \n \n echo $ac_n \"checking for dlopen in -ldl\"\"... $ac_c\" 1>&6\n-echo \"configure:2734: checking for dlopen in -ldl\" >&5\n+echo \"configure:2736: checking for dlopen in -ldl\" >&5\n ac_lib_var=`echo dl'_'dlopen | sed 'y%./+-%__p_%'`\n if eval \"test \\\"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   ac_save_LIBS=\"$LIBS\"\n LIBS=\"-ldl  $LIBS\"\n cat > conftest.$ac_ext <<EOF\n-#line 2742 \"configure\"\n+#line 2744 \"configure\"\n #include \"confdefs.h\"\n /* Override any gcc2 internal prototype to avoid an error.  */\n /* We use char because int might match the return type of a gcc2\n@@ -2749,7 +2751,7 @@ int main() {\n dlopen()\n ; return 0; }\n EOF\n-if { (eval echo configure:2753: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:2755: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_lib_$ac_lib_var=yes\"\n else\n@@ -2807,6 +2809,34 @@ case \"$host\" in\n  alpha*-*-*)\n     machdep=\"alpha_mach_dep.lo\"\n     ;;\n+ alpha-*-openbsd*)\n+    if test x\"${ac_cv_lib_dl_dlopen}\" != xyes ; then\n+       echo \"configure: warning: OpenBSD/Alpha without dlopen(). Shared library support is disabled\" 1>&2\n+       # Check whether --enable-shared or --disable-shared was given.\n+if test \"${enable_shared+set}\" = set; then\n+  enableval=\"$enable_shared\"\n+  p=${PACKAGE-default}\n+case $enableval in\n+yes) enable_shared=yes ;;\n+no) enable_shared=no ;;\n+*)\n+  enable_shared=no\n+  # Look at the argument we got.  We use all the common list separators.\n+  IFS=\"${IFS= \t}\"; ac_save_ifs=\"$IFS\"; IFS=\"${IFS}:,\"\n+  for pkg in $enableval; do\n+    if test \"X$pkg\" = \"X$p\"; then\n+      enable_shared=yes\n+    fi\n+  done\n+  IFS=\"$ac_save_ifs\"\n+  ;;\n+esac\n+else\n+  enable_shared=no\n+fi\n+\n+    fi\n+    ;;\n  i?86-*-solaris2.[89]*)\n     cat >> confdefs.h <<\\EOF\n #define SOLARIS25_PROC_VDB_BUG_FIXED 1\n@@ -2839,6 +2869,9 @@ EOF\n #define SUNOS53_SHARED_LIB 1\n EOF\n \n+    ;;\n+ ia64-*-hpux*)\n+    machdep=\"mach_dep.lo ia64_save_regs_in_stack.lo\"\n     ;;\n esac\n if test x\"$machdep\" = x; then"}, {"sha": "ce6b7250c7023adcb269510f3dee5ffa3c4eeaf6", "filename": "boehm-gc/configure.in", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fconfigure.in?ref=4c7726b172c35bd078bb0f88025670ffddd94a92", "patch": "@@ -91,7 +91,7 @@ case \"$THREADS\" in\n \t;;\n      *-*-freebsd*)\n \tAC_MSG_WARN(\"FreeBSD does not yet fully support threads with Boehm GC.\")\n-\tAC_DEFINE(FREEBSD_THREADS)\n+\tAC_DEFINE(GC_FREEBSD_THREADS)\n \tINCLUDES=\"$INCLUDES -pthread\"\n \tTHREADLIBS=-pthread\n       \t;;\n@@ -153,6 +153,12 @@ case \"$host\" in\n  alpha*-*-*)\n     machdep=\"alpha_mach_dep.lo\"\n     ;;\n+ alpha-*-openbsd*)\n+    if test x\"${ac_cv_lib_dl_dlopen}\" != xyes ; then\n+       AC_MSG_WARN(OpenBSD/Alpha without dlopen(). Shared library support is disabled)\n+       AM_DISABLE_SHARED\n+    fi\n+    ;;\n  i?86-*-solaris2.[[89]]*)\n     AC_DEFINE(SOLARIS25_PROC_VDB_BUG_FIXED)\n     ;;\n@@ -171,6 +177,9 @@ case \"$host\" in\n  sparc-sun-solaris2.3*)\n     AC_DEFINE(SUNOS53_SHARED_LIB)\n     ;;\n+ ia64-*-hpux*)\n+    machdep=\"mach_dep.lo ia64_save_regs_in_stack.lo\"\n+    ;;\n esac\n if test x\"$machdep\" = x; then\n    machdep=\"mach_dep.lo\""}, {"sha": "b1bb941ccf81241f4b23b213bcae83764329b3bc", "filename": "boehm-gc/dbg_mlc.c", "status": "modified", "additions": 52, "deletions": 7, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Fdbg_mlc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Fdbg_mlc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdbg_mlc.c?ref=4c7726b172c35bd078bb0f88025670ffddd94a92", "patch": "@@ -40,7 +40,7 @@ ptr_t p;\n     register word sz = GC_size((ptr_t) ohdr);\n     \n     if (HBLKPTR((ptr_t)ohdr) != HBLKPTR((ptr_t)body)\n-        || sz < sizeof (oh)) {\n+        || sz < DEBUG_BYTES + EXTRA_BYTES) {\n         return(FALSE);\n     }\n     if (ohdr -> oh_sz == sz) {\n@@ -890,6 +890,28 @@ struct closure {\n     (*(cl -> cl_fn))((GC_PTR)((char *)obj + sizeof(oh)), cl -> cl_data);\n } \n \n+/* Set ofn and ocd to reflect the values we got back.\t*/\n+static void store_old (obj, my_old_fn, my_old_cd, ofn, ocd)\n+GC_PTR obj;\n+GC_finalization_proc my_old_fn;\n+struct closure * my_old_cd;\n+GC_finalization_proc *ofn;\n+GC_PTR *ocd;\n+{\n+    if (0 != my_old_fn) {\n+      if (my_old_fn != GC_debug_invoke_finalizer) {\n+        GC_err_printf1(\"Debuggable object at 0x%lx had non-debug finalizer.\\n\",\n+\t\t       obj);\n+        /* This should probably be fatal. */\n+      } else {\n+        if (ofn) *ofn = my_old_cd -> cl_fn;\n+        if (ocd) *ocd = my_old_cd -> cl_data;\n+      }\n+    } else {\n+      if (ofn) *ofn = 0;\n+      if (ocd) *ocd = 0;\n+    }\n+}\n \n # ifdef __STDC__\n     void GC_debug_register_finalizer(GC_PTR obj, GC_finalization_proc fn,\n@@ -904,14 +926,21 @@ struct closure {\n     GC_PTR *ocd;\n # endif\n {\n+    GC_finalization_proc my_old_fn;\n+    GC_PTR my_old_cd;\n     ptr_t base = GC_base(obj);\n     if (0 == base || (ptr_t)obj - base != sizeof(oh)) {\n         GC_err_printf1(\n \t    \"GC_register_finalizer called with non-base-pointer 0x%lx\\n\",\n \t    obj);\n     }\n-    GC_register_finalizer(base, GC_debug_invoke_finalizer,\n-    \t\t\t  GC_make_closure(fn,cd), ofn, ocd);\n+    if (0 == fn) {\n+      GC_register_finalizer(base, 0, 0, &my_old_fn, &my_old_cd);\n+    } else {\n+      GC_register_finalizer(base, GC_debug_invoke_finalizer,\n+    \t\t\t    GC_make_closure(fn,cd), &my_old_fn, &my_old_cd);\n+    }\n+    store_old(obj, my_old_fn, (struct closure *)my_old_cd, ofn, ocd);\n }\n \n # ifdef __STDC__\n@@ -929,14 +958,22 @@ struct closure {\n     GC_PTR *ocd;\n # endif\n {\n+    GC_finalization_proc my_old_fn;\n+    GC_PTR my_old_cd;\n     ptr_t base = GC_base(obj);\n     if (0 == base || (ptr_t)obj - base != sizeof(oh)) {\n         GC_err_printf1(\n \t  \"GC_register_finalizer_no_order called with non-base-pointer 0x%lx\\n\",\n \t  obj);\n     }\n-    GC_register_finalizer_no_order(base, GC_debug_invoke_finalizer,\n-     \t\t\t  \t      GC_make_closure(fn,cd), ofn, ocd);\n+    if (0 == fn) {\n+      GC_register_finalizer_no_order(base, 0, 0, &my_old_fn, &my_old_cd);\n+    } else {\n+      GC_register_finalizer_no_order(base, GC_debug_invoke_finalizer,\n+    \t\t\t    \t     GC_make_closure(fn,cd), &my_old_fn,\n+\t\t\t\t     &my_old_cd);\n+    }\n+    store_old(obj, my_old_fn, (struct closure *)my_old_cd, ofn, ocd);\n  }\n \n # ifdef __STDC__\n@@ -954,14 +991,22 @@ struct closure {\n     GC_PTR *ocd;\n # endif\n {\n+    GC_finalization_proc my_old_fn;\n+    GC_PTR my_old_cd;\n     ptr_t base = GC_base(obj);\n     if (0 == base || (ptr_t)obj - base != sizeof(oh)) {\n         GC_err_printf1(\n \t    \"GC_register_finalizer_ignore_self called with non-base-pointer 0x%lx\\n\",\n \t    obj);\n     }\n-    GC_register_finalizer_ignore_self(base, GC_debug_invoke_finalizer,\n-    \t\t\t  \t      GC_make_closure(fn,cd), ofn, ocd);\n+    if (0 == fn) {\n+      GC_register_finalizer_ignore_self(base, 0, 0, &my_old_fn, &my_old_cd);\n+    } else {\n+      GC_register_finalizer_ignore_self(base, GC_debug_invoke_finalizer,\n+    \t\t\t    \t     GC_make_closure(fn,cd), &my_old_fn,\n+\t\t\t\t     &my_old_cd);\n+    }\n+    store_old(obj, my_old_fn, (struct closure *)my_old_cd, ofn, ocd);\n }\n \n #ifdef GC_ADD_CALLER"}, {"sha": "b161ccf4a4652fefd35d124fcbd02f0d1aadb47c", "filename": "boehm-gc/doc/README", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Fdoc%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Fdoc%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME?ref=4c7726b172c35bd078bb0f88025670ffddd94a92", "patch": "@@ -27,7 +27,7 @@ are GPL'ed, but with an exception that should cover all uses in the\n collector.  (If you are concerned about such things, I recommend you look\n at the notice in config.guess or ltmain.sh.)\n \n-This is version 6.0 of a conservative garbage collector for C and C++.\n+This is version 6.1alpha1 of a conservative garbage collector for C and C++.\n \n You might find a more recent version of this at\n "}, {"sha": "8c00e938b5fed33fc18b4721022db6ef2d41d7a2", "filename": "boehm-gc/doc/README.changes", "status": "modified", "additions": 37, "deletions": 6, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Fdoc%2FREADME.changes", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Fdoc%2FREADME.changes", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.changes?ref=4c7726b172c35bd078bb0f88025670ffddd94a92", "patch": "@@ -1360,7 +1360,7 @@ Since 6.0alpha8:\n    it on untested platforms.\n  - Integrated initial GNU HURD port. (Thanks to Chris Lingard and Igor\n    Khavkine.)\n- - A few more fixes for Digital Mars compiler.\n+ - A few more fixes for Digital Mars compiler (Walter Bright).\n  - Fixed gcc version recognition.  Renamed OPERATOR_NEW_ARRAY to\n    GC_OPERATOR_NEW_ARRAY.  Changed GC_OPERATOR_NEW_ARRAY to be the default.\n    It can be overridden with -DGC_NO_OPERATOR_NEW_ARRAY.  (Thanks to\n@@ -1378,16 +1378,47 @@ Since 6.0alpha9:\n  - Fixed a stack clearing problem that resulted in SIGILL with a\n    misaligned stack pointer for multithreaded SPARC builds.\n  - Integrated another HURD patch (thanks to Igor Khavkine).\n+\n+Since 6.0:\n+ - Non-debug, atomic allocations could result in bogus smashed object\n+   reports with debugging on.  (Thanks to Patrick Doyle for the small\n+   test case.)\n+ - Fixed GC_get_register_stack_base (Itanium only) to work around a glibc\n+   2.2.4 bug.\n+ - Initial port to HP/UX on Itanium.  Thread support and both 32 and 64\n+   bit ABIs appear to work.  Parallel mark support doesn't yet, due to\n+   some inline assembly code issues.  Thread local allocation does appear\n+   to work.\n+ - ifdef'ed out glibc2.1/Itanium workaround.  I suspect nobody is using\n+   that combination anymore.\n+ - Added a patch to make new_gc_alloc.h usable with gcc3.0.  (Thanks to\n+   Dimitris Vyzovitis for the patch.)\n+ - Debugged 64-bit support on HP/UX PA-RISC.\n+ - Turned on dynamic loading support for FreeBSD/ELF.  (Thanks to Peter\n+   Housel.)\n+ - Unregistering of finalizers with debugging allocation was broken.\n+   (Thanks to Jani Kajala for the test case.)\n+ - Old finalizers were not returned correctly from GC_debug_register_finalizer.\n+ - Disabled MPROTECT_VDB for Linux/M68K based on a report that it doesn't work.\n+ - Cleaned up some statistics gathering code in reclaim.c (Thanks to Walter\n+   Bright.)\n+ - Added some support for OpenBSD/ELF/Linux.  (Thanks to Suzuki Toshiya.)\n+ - Added Jakub Jelinek's patch to use dl_iterate_phdr for dynamic library\n+   traversal to dyn_load.c.  Changed it to weakly reference dl_iterate_phdr,\n+   so that the old code is stilll used with old versions of glibc.\n+ - Cleaned up feature test macros for various threads packages and\n+   integrated (partially functional) FreeBSD threads code from Loren Rittle.\n+   It's likely that the cleanup broke something, since it touched lots of\n+   code.  It's also likelly that it fixed some unreported bugs in the\n+   less common thread implementations, since some of the original code\n+   didn't stand up to close scrutiny.  Support for the next pthreads\n+   implementation should be easier to add.\n  \n \n To do:\n  - There seem to be outstanding issues on Solaris/X86, possibly with\n    finding the data segment starting address.  Information/patches would\n-   ne appreciated.\n- - New_gc_alloc.h is apparently no longer compatible with the latest C++\n-   standard library in gcc3.0.  (This isn't technically a bug, since it only\n-   claimed compatibility with the SGI STL.  But we may need a new C++ STL\n-   allocator interface.)\n+   be appreciated.\n  - Very large root set sizes (> 16 MB or so) could cause the collector\n    to abort with an unexpected mark stack overflow.  (Thanks again to\n    Peter Chubb.)  NOT YET FIXED.  Workaround is to increase the initial"}, {"sha": "7dfe66712302110c7aad2bfff1c800e7bbfc8fc6", "filename": "boehm-gc/dyn_load.c", "status": "modified", "additions": 101, "deletions": 10, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Fdyn_load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Fdyn_load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdyn_load.c?ref=4c7726b172c35bd078bb0f88025670ffddd94a92", "patch": "@@ -26,15 +26,18 @@\n  * None of this is safe with dlclose and incremental collection.\n  * But then not much of anything is safe in the presence of dlclose.\n  */\n+#if defined(__linux__) && !defined(_GNU_SOURCE)\n+    /* Can't test LINUX, since this must be define before other includes */\n+#   define _GNU_SOURCE\n+#endif\n #if !defined(MACOS) && !defined(_WIN32_WCE)\n #  include <sys/types.h>\n #endif\n #include \"private/gc_priv.h\"\n \n-/* BTL: avoid circular redefinition of dlopen if SOLARIS_THREADS defined */\n-# if (defined(LINUX_THREADS) || defined(SOLARIS_THREADS) \\\n-      || defined(HPUX_THREADS) || defined(IRIX_THREADS)) && defined(dlopen) \\\n-     && !defined(GC_USE_LD_WRAP)\n+/* BTL: avoid circular redefinition of dlopen if GC_SOLARIS_THREADS defined */\n+# if (defined(GC_PTHREADS) || defined(GC_SOLARIS_THREADS)) \\\n+      && defined(dlopen) && !defined(GC_USE_LD_WRAP)\n     /* To support threads in Solaris, gc.h interposes on dlopen by       */\n     /* defining \"dlopen\" to be \"GC_dlopen\", which is implemented below.  */\n     /* However, both GC_FirstDLOpenedLinkMap() and GC_dlopen() use the   */\n@@ -53,6 +56,7 @@\n     !(defined(ALPHA) && defined(OSF1)) && \\\n     !defined(HPUX) && !(defined(LINUX) && defined(__ELF__)) && \\\n     !defined(RS6000) && !defined(SCO_ELF) && \\\n+    !(defined(FREEBSD) && defined(__ELF__)) && \\\n     !(defined(NETBSD) && defined(__ELF__)) && !defined(HURD)\n  --> We only know how to find data segments of dynamic libraries for the\n  --> above.  Additional SVR4 variants might not be too\n@@ -124,7 +128,7 @@ GC_FirstDLOpenedLinkMap()\n \n #endif /* SUNOS5DL ... */\n \n-/* BTL: added to fix circular dlopen definition if SOLARIS_THREADS defined */\n+/* BTL: added to fix circular dlopen definition if GC_SOLARIS_THREADS defined */\n # if defined(GC_must_restore_redefined_dlopen)\n #   define dlopen GC_dlopen\n # endif\n@@ -171,7 +175,7 @@ static ptr_t GC_first_common()\n \n # if defined(SUNOS4) || defined(SUNOS5DL)\n /* Add dynamic library data sections to the root set.\t\t*/\n-# if !defined(PCR) && !defined(SOLARIS_THREADS) && defined(THREADS)\n+# if !defined(PCR) && !defined(GC_SOLARIS_THREADS) && defined(THREADS)\n #   ifndef SRC_M3\n \t--> fix mutual exclusion with dlopen\n #   endif  /* We assume M3 programs don't call dlopen for now */\n@@ -243,6 +247,7 @@ void GC_register_dynamic_libraries()\n # endif /* SUNOS */\n \n #if defined(LINUX) && defined(__ELF__) || defined(SCO_ELF) || \\\n+    (defined(FREEBSD) && defined(__ELF__)) || \\\n     (defined(NETBSD) && defined(__ELF__)) || defined(HURD)\n \n \n@@ -417,20 +422,100 @@ static char *parse_map_entry(char *buf_ptr, word *start, word *end,\n     return buf_ptr;\n }\n \n-#else /* !USE_PROC_FOR_LIBRARIES */\n+#endif /* USE_PROC_FOR_LIBRARIES */\n+\n+#if !defined(USE_PROC_FOR_LIBRARIES)\n+/* The following is the preferred way to walk dynamic libraries\t*/\n+/* For glibc 2.2.4+.  Unfortunately, it doesn't work for older\t*/\n+/* versions.  Thanks to Jakub Jelinek for most of the code.\t*/\n+\n+#include <stddef.h>\n+#include <elf.h>\n+#include <link.h>\n+\n+# if defined(LINUX) /* Are others OK here, too? */ \\\n+     && (__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ > 2) \\\n+         || (__GLIBC__ == 2 && __GLIBC_MINOR__ == 2 && defined(DT_CONFIG))) \n+\n+/* We have the header files for a glibc that includes dl_iterate_phdr.\t*/\n+/* It may still not be available in the library on the target system.   */\n+/* Thus we also treat it as a weak symbol.\t\t\t\t*/\n+#define HAVE_DL_ITERATE_PHDR\n+\n+static int GC_register_dynlib_callback(info, size, ptr)\n+     struct dl_phdr_info * info;\n+     size_t size;\n+     void * ptr;\n+{\n+  const ElfW(Phdr) * p;\n+  char * start;\n+  register int i;\n+\n+  /* Make sure struct dl_phdr_info is at least as big as we need.  */\n+  if (size < offsetof (struct dl_phdr_info, dlpi_phnum)\n+      + sizeof (info->dlpi_phnum))\n+    return -1;\n+\n+  /* Skip the first object - it is the main program.  */\n+  if (*(int *)ptr == 0)\n+    {\n+      *(int *)ptr = 1;\n+      return 0;\n+    }\n+\n+  p = info->dlpi_phdr;\n+  for( i = 0; i < (int)(info->dlpi_phnum); ((i++),(p++)) ) {\n+    switch( p->p_type ) {\n+      case PT_LOAD:\n+\t{\n+\t  if( !(p->p_flags & PF_W) ) break;\n+\t  start = ((char *)(p->p_vaddr)) + info->dlpi_addr;\n+\t  GC_add_roots_inner(start, start + p->p_memsz, TRUE);\n+\t}\n+      break;\n+      default:\n+\tbreak;\n+    }\n+  }\n+\n+  return 0;\n+}     \n+\n+/* Return TRUE if we succeed, FALSE if dl_iterate_phdr wasn't there. */\n+\n+#pragma weak dl_iterate_phdr\n+\n+GC_bool GC_register_dynamic_libraries_dl_iterate_phdr()\n+{\n+  int tmp = 0;\n+\n+  if (dl_iterate_phdr) {\n+    dl_iterate_phdr(GC_register_dynlib_callback, &tmp);\n+    return TRUE;\n+  } else {\n+    return FALSE;\n+  }\n+}\n+\n+# else /* !LINUX || version(glibc) < 2.2.4 */\n \n /* Dynamic loading code for Linux running ELF. Somewhat tested on\n  * Linux/x86, untested but hopefully should work on Linux/Alpha. \n  * This code was derived from the Solaris/ELF support. Thanks to\n  * whatever kind soul wrote that.  - Patrick Bridges */\n \n+/* This doesn't necessarily work in all cases, e.g. with preloaded\n+ * dynamic libraries.\t\t\t\t\t\t*/\n+\n #if defined(NETBSD)\n #  include <sys/exec_elf.h>\n #else\n #  include <elf.h>\n #endif\n #include <link.h>\n \n+# endif\n+\n /* Newer versions of Linux/Alpha and Linux/x86 define this macro.  We\n  * define it for those older versions that don't.  */\n #  ifndef ElfW\n@@ -472,9 +557,15 @@ GC_FirstDLOpenedLinkMap()\n \n void GC_register_dynamic_libraries()\n {\n-  struct link_map *lm = GC_FirstDLOpenedLinkMap();\n+  struct link_map *lm;\n   \n \n+# ifdef HAVE_DL_ITERATE_PHDR\n+    if (GC_register_dynamic_libraries_dl_iterate_phdr()) {\n+\treturn;\n+    }\n+# endif\n+  lm = GC_FirstDLOpenedLinkMap();\n   for (lm = GC_FirstDLOpenedLinkMap();\n        lm != (struct link_map *) 0;  lm = lm->l_next)\n     {\n@@ -648,7 +739,7 @@ void GC_register_dynamic_libraries()\n   \n   extern GC_bool GC_is_heap_base (ptr_t p);\n \n-# ifdef WIN32_THREADS\n+# ifdef GC_WIN32_THREADS\n     extern void GC_get_next_stack(char *start, char **lo, char **hi);\n     void GC_cond_add_roots(char *base, char * limit)\n     {\n@@ -863,7 +954,7 @@ void GC_register_dynamic_libraries()\n \n       /* Check if this is the end of the list or if some error occured */\n         if (status != 0) {\n-#\t ifdef HPUX_THREADS\n+#\t ifdef GC_HPUX_THREADS\n \t   /* I've seen errno values of 0.  The man page is not clear\t*/\n \t   /* as to whether errno should get set on a -1 return.\t*/\n \t   break;"}, {"sha": "d69ba6f1e2276a667a3ac95d2ef279b3dcf67e97", "filename": "boehm-gc/finalize.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Ffinalize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Ffinalize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ffinalize.c?ref=4c7726b172c35bd078bb0f88025670ffddd94a92", "patch": "@@ -207,7 +207,7 @@ signed_word * log_size_ptr;\n \tUNLOCK();\n     \tENABLE_SIGNALS();\n #     endif\n-      new_dl == GC_oom_fn(sizeof(struct disappearing_link));\n+      new_dl = GC_oom_fn(sizeof(struct disappearing_link));\n       if (0 == new_dl) {\n \tGC_finalization_failures++;\n \treturn(0);\n@@ -433,7 +433,7 @@ finalization_mark_proc * mp;\n \tUNLOCK();\n     \tENABLE_SIGNALS();\n #     endif\n-      new_fo == GC_oom_fn(sizeof(struct finalizable_object));\n+      new_fo = GC_oom_fn(sizeof(struct finalizable_object));\n       if (0 == new_fo) {\n \tGC_finalization_failures++;\n \treturn;"}, {"sha": "5f0b5462427db7a24abf786c844b8ba97ecb2e29", "filename": "boehm-gc/gc.mak", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Fgc.mak", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Fgc.mak", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgc.mak?ref=4c7726b172c35bd078bb0f88025670ffddd94a92", "patch": "@@ -114,10 +114,10 @@ CLEAN :\n \n CPP=cl.exe\n # ADD BASE CPP /nologo /MT /W3 /GX /O2 /D \"WIN32\" /D \"NDEBUG\" /D \"_WINDOWS\" /YX /c\n-# ADD CPP /nologo /MD /W3 /GX /O2 /I include /D \"NDEBUG\" /D \"SILENT\" /D \"GC_BUILD\" /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"WIN32_THREADS\" /FR /YX /c\n+# ADD CPP /nologo /MD /W3 /GX /O2 /I include /D \"NDEBUG\" /D \"SILENT\" /D \"GC_BUILD\" /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"GC_WIN32_THREADS\" /FR /YX /c\n CPP_PROJ=/nologo /MD /W3 /GX /O2 /I include /D \"NDEBUG\" /D \"SILENT\" /D \"GC_BUILD\" /D\\\n  \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D\\\n- \"WIN32_THREADS\" /FR\"$(INTDIR)/\" /Fp\"$(INTDIR)/gc.pch\" /YX /Fo\"$(INTDIR)/\" /c \n+ \"GC_WIN32_THREADS\" /FR\"$(INTDIR)/\" /Fp\"$(INTDIR)/gc.pch\" /YX /Fo\"$(INTDIR)/\" /c \n CPP_OBJS=.\\Release/\n CPP_SBRS=.\\Release/\n \n@@ -296,10 +296,10 @@ CLEAN :\n \n CPP=cl.exe\n # ADD BASE CPP /nologo /MTd /W3 /Gm /GX /Zi /Od /D \"WIN32\" /D \"_DEBUG\" /D \"_WINDOWS\" /YX /c\n-# ADD CPP /nologo /MDd /W3 /Gm /GX /Zi /Od /I include /D \"_DEBUG\" /D \"SILENT\" /D \"GC_BUILD\" /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"WIN32_THREADS\" /FR /YX /c\n+# ADD CPP /nologo /MDd /W3 /Gm /GX /Zi /Od /I include /D \"_DEBUG\" /D \"SILENT\" /D \"GC_BUILD\" /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"GC_WIN32_THREADS\" /FR /YX /c\n CPP_PROJ=/nologo /MDd /W3 /Gm /GX /Zi /Od /I include /D \"_DEBUG\" /D \"SILENT\" /D \"GC_BUILD\"\\\n  /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D\\\n- \"WIN32_THREADS\" /FR\"$(INTDIR)/\" /Fp\"$(INTDIR)/gc.pch\" /YX /Fo\"$(INTDIR)/\"\\\n+ \"GC_WIN32_THREADS\" /FR\"$(INTDIR)/\" /Fp\"$(INTDIR)/gc.pch\" /YX /Fo\"$(INTDIR)/\"\\\n  /Fd\"$(INTDIR)/\" /c \n CPP_OBJS=.\\Debug/\n CPP_SBRS=.\\Debug/\n@@ -430,9 +430,9 @@ test.c : tests\\test.c\n \n CPP=cl.exe\n # ADD BASE CPP /nologo /W3 /GX /O2 /D \"WIN32\" /D \"NDEBUG\" /D \"_WINDOWS\" /YX /c\n-# ADD CPP /nologo /MD /W3 /GX /O2 /I include /D \"NDEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"WIN32_THREADS\" /YX /c\n+# ADD CPP /nologo /MD /W3 /GX /O2 /I include /D \"NDEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"GC_WIN32_THREADS\" /YX /c\n CPP_PROJ=/nologo /MD /W3 /GX /O2 /I include /D \"NDEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D\\\n- \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"WIN32_THREADS\"\\\n+ \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"GC_WIN32_THREADS\"\\\n  /Fp\"$(INTDIR)/gctest.pch\" /YX /Fo\"$(INTDIR)/\" /c \n CPP_OBJS=.\\gctest\\Release/\n CPP_SBRS=.\\.\n@@ -516,9 +516,9 @@ CLEAN :\n \n CPP=cl.exe\n # ADD BASE CPP /nologo /W3 /Gm /GX /Zi /Od /D \"WIN32\" /D \"_DEBUG\" /D \"_WINDOWS\" /YX /c\n-# ADD CPP /nologo /MDd /W3 /Gm /GX /Zi /Od /D \"_DEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"WIN32_THREADS\" /FR /YX /c\n+# ADD CPP /nologo /MDd /W3 /Gm /GX /Zi /Od /D \"_DEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"GC_WIN32_THREADS\" /FR /YX /c\n CPP_PROJ=/nologo /MDd /W3 /Gm /GX /Zi /Od /I include /D \"_DEBUG\" /D \"WIN32\" /D \"_WINDOWS\"\\\n- /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"WIN32_THREADS\" /FR\"$(INTDIR)/\"\\\n+ /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"GC_WIN32_THREADS\" /FR\"$(INTDIR)/\"\\\n  /Fp\"$(INTDIR)/gctest.pch\" /YX /Fo\"$(INTDIR)/\" /Fd\"$(INTDIR)/\" /c \n CPP_OBJS=.\\gctest\\Debug/\n CPP_SBRS=.\\gctest\\Debug/"}, {"sha": "eafaa2b1b46c383abfebe682fd632e959353557d", "filename": "boehm-gc/gc_dlopen.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Fgc_dlopen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Fgc_dlopen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgc_dlopen.c?ref=4c7726b172c35bd078bb0f88025670ffddd94a92", "patch": "@@ -24,8 +24,7 @@\n \n #include \"private/gc_priv.h\"\n \n-# if defined(LINUX_THREADS) || defined(SOLARIS_THREADS) \\\n-     || defined(HPUX_THREADS) || defined(IRIX_THREADS)\n+# if defined(GC_PTHREADS) || defined(GC_SOLARIS_THREADS)\n \n # if defined(dlopen) && !defined(GC_USE_LD_WRAP)\n     /* To support various threads pkgs, gc.h interposes on dlopen by     */\n@@ -90,7 +89,7 @@\n #   endif\n     return(result);\n }\n-# endif  /* LINUX_THREADS || SOLARIS_THREADS || ... */\n+# endif  /* GC_PTHREADS || GC_SOLARIS_THREADS ... */\n \n \n "}, {"sha": "3c8f7fb63e74424bfeb869910a4e457766fae670", "filename": "boehm-gc/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2FMakefile.in?ref=4c7726b172c35bd078bb0f88025670ffddd94a92", "patch": "@@ -1,4 +1,4 @@\n-# Makefile.in generated automatically by automake 1.4 from Makefile.am\n+# Makefile.in generated automatically by automake 1.4-p1 from Makefile.am\n \n # Copyright (C) 1994, 1995-8, 1999 Free Software Foundation, Inc.\n # This Makefile.in is free software; the Free Software Foundation"}, {"sha": "8ac709b9b5de370d1e205936b5bffe909bf55e3c", "filename": "boehm-gc/include/gc.h", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Finclude%2Fgc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Finclude%2Fgc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc.h?ref=4c7726b172c35bd078bb0f88025670ffddd94a92", "patch": "@@ -30,13 +30,9 @@\n \n # define _GC_H\n \n-#if defined(_SOLARIS_PTHREADS) && !defined(SOLARIS_THREADS)\n-#   define SOLARIS_THREADS\n-#endif\n-\n /*\n  * Some tests for old macros.  These violate our namespace rules and will\n- * disappear shortly.\n+ * disappear shortly.  Use the GC_ names.\n  */\n #if defined(SOLARIS_THREADS) || defined(_SOLARIS_THREADS)\n # define GC_SOLARIS_THREADS\n@@ -72,6 +68,16 @@\n \t/* depend on this were previously included.\t\t\t*/\n #endif\n \n+#if defined(GC_SOLARIS_PTHREADS) && !defined(GC_SOLARIS_THREADS)\n+#   define GC_SOLARIS_THREADS\n+#endif\n+\n+# if defined(GC_SOLARIS_PTHREADS) || defined(GC_FREEBSD_THREADS) || \\\n+\tdefined(GC_IRIX_THREADS) || defined(GC_LINUX_THREADS) || \\\n+\tdefined(GC_HPUX_THREADS) || defined(GC_OSF1_THREADS)\n+#   define GC_PTHREADS\n+# endif\n+\n # define __GC\n # include <stddef.h>\n # ifdef _WIN32_WCE\n@@ -80,7 +86,7 @@\n     typedef long ptrdiff_t;\t/* ptrdiff_t is not defined */\n # endif\n \n-#if defined(__MINGW32__) && defined(WIN32_THREADS)\n+#if defined(__MINGW32__) && defined(GC_WIN32_THREADS)\n # ifdef GC_BUILD\n #   define GC_API __declspec(dllexport)\n # else\n@@ -815,16 +821,12 @@ GC_API void (*GC_is_visible_print_proc)\n /* thread library calls.  We do that here by macro defining them.\t*/\n \n #if !defined(GC_USE_LD_WRAP) && \\\n-    (defined(GC_LINUX_THREADS) || defined(GC_HPUX_THREADS) || \\\n-     defined(GC_IRIX_THREADS) || defined(GC_SOLARIS_PTHREADS) || \\\n-     defined(GC_SOLARIS_THREADS) || defined(GC_OSF1_THREADS))\n+    (defined(GC_PTHREADS) || defined(GC_SOLARIS_THREADS))\n # include \"gc_pthread_redirects.h\"\n #endif\n \n # if defined(PCR) || defined(GC_SOLARIS_THREADS) || \\\n-     defined(GC_SOLARIS_PTHREADS) || defined(GC_WIN32_THREADS) || \\\n-     defined(GC_IRIX_THREADS) || defined(GC_LINUX_THREADS) || \\\n-     defined(GC_HPUX_THREADS)\n+     defined(GC_PTHREADS) || defined(GC_WIN32_THREADS)\n    \t/* Any flavor of threads except SRC_M3.\t*/\n /* This returns a list of objects, linked through their first\t\t*/\n /* word.  Its use can greatly reduce lock contention problems, since\t*/\n@@ -839,7 +841,7 @@ extern void GC_thr_init();\t/* Needed for Solaris/X86\t*/\n \n #endif /* THREADS && !SRC_M3 */\n \n-#if defined(WIN32_THREADS) && defined(_WIN32_WCE)\n+#if defined(GC_WIN32_THREADS) && defined(_WIN32_WCE)\n # include <windows.h>\n \n   /*"}, {"sha": "5e932afe8d05e791f98bb0583b08801cdc9ed770", "filename": "boehm-gc/include/gc_gcj.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Finclude%2Fgc_gcj.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Finclude%2Fgc_gcj.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_gcj.h?ref=4c7726b172c35bd078bb0f88025670ffddd94a92", "patch": "@@ -47,8 +47,6 @@\n /* The following allocators signal an out of memory condition with\t*/\n /* return GC_oom_fn(bytes);\t\t\t\t\t\t*/\n \n-extern void * (*GC_oom_action)(void);\n-\n /* The following function must be called before the gcj allocators\t*/\n /* can be invoked.\t\t\t\t\t\t\t*/\n /* mp_index and mp are the index and mark_proc (see gc_mark.h)\t\t*/"}, {"sha": "aad9446543e0ccb13f2a2f6cfadadd1e0ecb4669", "filename": "boehm-gc/include/new_gc_alloc.h", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Finclude%2Fnew_gc_alloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Finclude%2Fnew_gc_alloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fnew_gc_alloc.h?ref=4c7726b172c35bd078bb0f88025670ffddd94a92", "patch": "@@ -50,7 +50,20 @@\n #ifndef GC_ALLOC_H\n \n #include \"gc.h\"\n-#include <stack>  // A more portable way to get stl_alloc.h .\n+\n+#if (__GNUC__ < 3)\n+# include <stack>  // A more portable way to get stl_alloc.h .\n+#else\n+# include <bits/stl_alloc.h>\n+# ifndef __STL_BEGIN_NAMESPACE\n+# define __STL_BEGIN_NAMESPACE namespace std {\n+# define __STL_END_NAMESPACE };\n+# endif\n+#ifndef __STL_USE_STD_ALLOCATORS\n+#define __STL_USE_STD_ALLOCATORS\n+#endif\n+#endif\n+\n \n #define GC_ALLOC_H\n "}, {"sha": "5ea1e543e768ef5d3706c81b04703dad449d32a1", "filename": "boehm-gc/include/private/gc_locks.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Finclude%2Fprivate%2Fgc_locks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Finclude%2Fprivate%2Fgc_locks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fgc_locks.h?ref=4c7726b172c35bd078bb0f88025670ffddd94a92", "patch": "@@ -76,7 +76,7 @@\n #    define LOCK() RT0u__inCritical++\n #    define UNLOCK() RT0u__inCritical--\n #  endif\n-#  ifdef SOLARIS_THREADS\n+#  ifdef GC_SOLARIS_THREADS\n #    include <thread.h>\n #    include <signal.h>\n      extern mutex_t GC_allocate_ml;\n@@ -261,8 +261,8 @@\n #    define USE_PTHREAD_LOCKS\n #  endif\n \n-#  if defined(LINUX_THREADS) || defined(OSF1_THREADS) \\\n-      || defined(HPUX_THREADS)\n+#  if defined(GC_PTHREADS) && !defined(GC_SOLARIS_THREADS) \\\n+      && !defined(GC_IRIX_THREADS)\n #    define NO_THREAD (pthread_t)(-1)\n #    include <pthread.h>\n #    if defined(PARALLEL_MARK) \n@@ -412,8 +412,8 @@\n #   ifdef GC_ASSERTIONS\n       extern pthread_t GC_mark_lock_holder;\n #   endif\n-#  endif /* LINUX_THREADS || OSF1_THREADS  || HPUX_THREADS */\n-#  if defined(IRIX_THREADS)\n+#  endif /* GC_PTHREADS with linux_threads.c implementation */\n+#  if defined(GC_IRIX_THREADS)\n #    include <pthread.h>\n      /* This probably should never be included, but I can't test\t*/\n      /* on Irix anymore.\t\t\t\t\t\t*/\n@@ -439,8 +439,8 @@\n \t\t    GC_collecting = 1; \\\n \t\t}\n #    define EXIT_GC() GC_collecting = 0;\n-#  endif /* IRIX_THREADS */\n-#  ifdef WIN32_THREADS\n+#  endif /* GC_IRIX_THREADS */\n+#  ifdef GC_WIN32_THREADS\n #    include <windows.h>\n      GC_API CRITICAL_SECTION GC_allocate_ml;\n #    define LOCK() EnterCriticalSection(&GC_allocate_ml);"}, {"sha": "ad204e99267bfb30f7ab66c1092381659734837b", "filename": "boehm-gc/include/private/gc_priv.h", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Finclude%2Fprivate%2Fgc_priv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Finclude%2Fprivate%2Fgc_priv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fgc_priv.h?ref=4c7726b172c35bd078bb0f88025670ffddd94a92", "patch": "@@ -443,18 +443,21 @@ struct hblk;\t/* See below.\t*/\n /* clear on that point).  Standard malloc implementations are usually\t*/\n /* neither interruptable nor thread-safe, and thus correspond to\t*/\n /* empty definitions.\t\t\t\t\t\t\t*/\n+/* It probably doesn't make any sense to declare these to be nonempty\t*/\n+/* if the code is being optimized, since signal safety relies on some\t*/\n+/* ordering constraints that are typically not obeyed by optimizing\t*/\n+/* compilers.\t\t\t\t\t\t\t\t*/\n # ifdef PCR\n #   define DISABLE_SIGNALS() \\\n \t\t PCR_Th_SetSigMask(PCR_allSigsBlocked,&GC_old_sig_mask)\n #   define ENABLE_SIGNALS() \\\n \t\tPCR_Th_SetSigMask(&GC_old_sig_mask, NIL)\n # else\n-#   if defined(SRC_M3) || defined(AMIGA) || defined(SOLARIS_THREADS) \\\n+#   if defined(THREADS) || defined(AMIGA)  \\\n \t|| defined(MSWIN32) || defined(MSWINCE) || defined(MACOS) \\\n-\t|| defined(DJGPP) || defined(NO_SIGNALS) || defined(IRIX_THREADS) \\\n-\t|| defined(LINUX_THREADS) \n+\t|| defined(DJGPP) || defined(NO_SIGNALS) \n \t\t\t/* Also useful for debugging.\t\t*/\n-\t/* Should probably use thr_sigsetmask for SOLARIS_THREADS. */\n+\t/* Should probably use thr_sigsetmask for GC_SOLARIS_THREADS. */\n #     define DISABLE_SIGNALS()\n #     define ENABLE_SIGNALS()\n #   else\n@@ -479,9 +482,8 @@ struct hblk;\t/* See below.\t*/\n  \t\t\t\t   PCR_allSigsBlocked, \\\n  \t\t\t\t   PCR_waitForever);\n # else\n-#   if defined(SOLARIS_THREADS) || defined(WIN32_THREADS) \\\n-\t|| defined(IRIX_THREADS) || defined(LINUX_THREADS) \\\n-\t|| defined(HPUX_THREADS)\n+#   if defined(GC_SOLARIS_THREADS) || defined(GC_WIN32_THREADS) \\\n+\t|| defined(GC_PTHREADS)\n       void GC_stop_world();\n       void GC_start_world();\n #     define STOP_WORLD() GC_stop_world()\n@@ -566,7 +568,8 @@ extern GC_warn_proc GC_current_warn_proc;\n # ifdef SMALL_CONFIG\n #   define CPP_LOG_HBLKSIZE 10\n # else\n-#   if CPP_WORDSZ == 32\n+#   if (CPP_WORDSZ == 32) || (defined(HPUX) && defined(HP_PA))\n+      /* HPUX/PA seems to use 4K pages with the 64 bit ABI */\n #     define CPP_LOG_HBLKSIZE 12\n #   else\n #     define CPP_LOG_HBLKSIZE 13\n@@ -1903,25 +1906,24 @@ void GC_err_puts GC_PROTO((GC_CONST char *s));\n \t\t/* some other reason.\t\t\t\t\t*/\n # endif /* PARALLEL_MARK */\n \n-# if defined(LINUX_THREADS) || defined(IRIX_THREADS) \\\n-     || defined(HPUX_THREADS) || defined(OSF1_THREADS)\n+# if defined(GC_PTHREADS) && !defined(GC_SOLARIS_THREADS)\n   /* We define the thread suspension signal here, so that we can refer\t*/\n   /* to it in the dirty bit implementation, if necessary.  Ideally we\t*/\n   /* would allocate a (real-time ?) signal using the standard mechanism.*/\n   /* unfortunately, there is no standard mechanism.  (There is one \t*/\n   /* in Linux glibc, but it's not exported.)  Thus we continue to use\t*/\n   /* the same hard-coded signals we've always used.\t\t\t*/\n #  if !defined(SIG_SUSPEND)\n-#   if defined(LINUX_THREADS)\n+#   if defined(GC_LINUX_THREADS)\n #    if defined(SPARC) && !defined(SIGPWR)\n        /* SPARC/Linux doesn't properly define SIGPWR in <signal.h>.\n         * It is aliased to SIGLOST in asm/signal.h, though.\t\t*/\n #      define SIG_SUSPEND SIGLOST\n #    else\n-       /* Linuxthreads uses SIGUSR1 and SIGUSR2.\t\t\t*/\n+       /* Linuxthreads itself uses SIGUSR1 and SIGUSR2.\t\t\t*/\n #      define SIG_SUSPEND SIGPWR\n #    endif\n-#   else  /* !LINUX_THREADS */\n+#   else  /* !GC_LINUX_THREADS */\n #    define SIG_SUSPEND _SIGRTMIN + 6\n #   endif\n #  endif /* !SIG_SUSPEND */"}, {"sha": "e92f2a4eb0cb3f0f8cfac323e6b83afc24d612df", "filename": "boehm-gc/include/private/gcconfig.h", "status": "modified", "additions": 94, "deletions": 59, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Finclude%2Fprivate%2Fgcconfig.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Finclude%2Fprivate%2Fgcconfig.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fgcconfig.h?ref=4c7726b172c35bd078bb0f88025670ffddd94a92", "patch": "@@ -33,6 +33,11 @@\n #    define NETBSD\n # endif\n \n+/* And one for OpenBSD: */\n+# if defined(__OpenBSD__)\n+#    define OPENBSD\n+# endif\n+\n /* Determine the machine type: */\n # if defined(sun) && defined(mc68000)\n #    define M68K\n@@ -44,25 +49,23 @@\n #    define HP\n #    define mach_type_known\n # endif\n-# if defined(__OpenBSD__) && defined(m68k)\n+# if defined(OPENBSD) && defined(m68k)\n #    define M68K\n-#    define OPENBSD\n #    define mach_type_known\n # endif\n-# if defined(__OpenBSD__) && defined(__sparc__)\n+# if defined(OPENBSD) && defined(__sparc__)\n #    define SPARC\n-#    define OPENBSD\n #    define mach_type_known\n # endif\n-# if defined(__NetBSD__) && defined(m68k)\n+# if defined(NETBSD) && defined(m68k)\n #    define M68K\n #    define mach_type_known\n # endif\n-# if defined(__NetBSD__) && defined(__powerpc__)\n+# if defined(NETBSD) && defined(__powerpc__)\n #    define POWERPC\n #    define mach_type_known\n # endif\n-# if defined(__NetBSD__) && defined(__arm32__)\n+# if defined(NETBSD) && defined(__arm32__)\n #    define ARM32\n #    define mach_type_known\n # endif\n@@ -161,6 +164,11 @@\n #   endif\n #   define mach_type_known\n # endif\n+# if defined(__ia64) && defined(_HPUX_SOURCE)\n+#   define IA64\n+#   define HPUX\n+#   define mach_type_known\n+# endif\n # if defined(__BEOS__) && defined(_X86_)\n #    define I386\n #    define BEOS\n@@ -196,7 +204,7 @@\n # endif\n # if defined(__alpha) || defined(__alpha__)\n #   define ALPHA\n-#   if !defined(LINUX) && !defined(NETBSD)\n+#   if !defined(LINUX) && !defined(NETBSD) && !defined(OPENBSD)\n #     define OSF1\t/* a.k.a Digital Unix */\n #   endif\n #   define mach_type_known\n@@ -386,7 +394,7 @@\n                     /*\t\t   RS6000     ==> IBM RS/6000 AIX3.X\t*/\n                     /*\t\t   RT\t      ==> IBM PC/RT\t\t*/\n                     /*\t\t   HP_PA      ==> HP9000/700 & /800\t*/\n-                    /*\t\t\t\t  HP/UX, LINUX\t\t\t*/\n+                    /*\t\t\t\t  HP/UX, LINUX\t\t*/\n \t\t    /*\t\t   SPARC      ==> SPARC\tv7/v8/v9\t*/\n \t\t    /*\t\t\t(SUNOS4, SUNOS5, LINUX,\t\t*/\n \t\t    /*\t\t\t DRSNX variants)\t\t*/\n@@ -398,8 +406,11 @@\n \t\t    /* \t\t\trunning Amdahl UTS4\t\t*/\n \t\t    /*\t\t\tor a 390 running LINUX\t\t*/\n \t\t    /* \t\t   ARM32      ==> Intel StrongARM\t*/\n-\t\t    /* \t\t   IA64\t      ==> Intel IA64\t\t*/\n+\t\t    /* \t\t   IA64\t      ==> Intel IPF\t\t*/\n \t\t    /*\t\t\t\t  (e.g. Itanium)\t*/\n+\t\t    /*\t\t\t(LINUX and HPUX)\t        */\n+\t\t    /* \t\t   IA64_32    ==> IA64 w/32 bit ABI\t*/\n+\t\t    /* \t\t\t(HPUX)\t\t\t\t*/\n \t\t    /*\t\t   SH\t      ==> Hitachi SuperH\t*/\n \t\t    /* \t\t\t(LINUX & MSWINCE)\t\t*/\n \n@@ -533,7 +544,7 @@\n #   ifdef LINUX\n #       define OS_TYPE \"LINUX\"\n #       define STACKBOTTOM ((ptr_t)0xf0000000)\n-#       define MPROTECT_VDB\n+/* #       define MPROTECT_VDB - Reported to not work  9/17/01 */\n #       ifdef __ELF__\n #            define DYNAMIC_LOADING\n #\t     include <features.h>\n@@ -891,7 +902,7 @@\n \t  /* with 2GB physical memory will usually move the user\t*/\n \t  /* address space limit, and hence initial SP to 0x80000000.\t*/\n #       endif\n-#       if !defined(LINUX_THREADS) || !defined(REDIRECT_MALLOC)\n+#       if !defined(GC_LINUX_THREADS) || !defined(REDIRECT_MALLOC)\n #\t    define MPROTECT_VDB\n #\telse\n \t    /* We seem to get random errors in incremental mode,\t*/\n@@ -1008,6 +1019,9 @@\n #\tdefine OS_TYPE \"FREEBSD\"\n #\tdefine MPROTECT_VDB\n #\tdefine FREEBSD_STACKBOTTOM\n+#\tifdef __ELF__\n+#\t    define DYNAMIC_LOADING\n+#\tendif\n #   endif\n #   ifdef NETBSD\n #\tdefine OS_TYPE \"NETBSD\"\n@@ -1164,7 +1178,6 @@\n \n # ifdef HP_PA\n #   define MACH_TYPE \"HP_PA\"\n-#   define OS_TYPE \"HPUX\"\n #   ifdef __LP64__\n #     define CPP_WORDSZ 64\n #     define ALIGNMENT 8\n@@ -1173,8 +1186,7 @@\n #     define ALIGNMENT 4\n #     define ALIGN_DOUBLE\n #   endif\n-#   if !defined(GC_HPUX_THREADS) && !defined(HPUX_THREADS) \\\n-       && !defined(GC_LINUX_THREADS) && !defined(LINUX_THREADS)\n+#   if !defined(GC_HPUX_THREADS) && !defined(GC_LINUX_THREADS)\n #     ifndef LINUX /* For now. */\n #       define MPROTECT_VDB\n #     endif\n@@ -1189,6 +1201,7 @@\n #   endif\n #   define STACK_GROWS_UP\n #   ifdef HPUX\n+#     define OS_TYPE \"HPUX\"\n       extern int __data_start;\n #     define DATASTART ((ptr_t)(&__data_start))\n #     if 0\n@@ -1240,6 +1253,19 @@\n #   \tdefine CPP_WORDSZ 64\n #       define DYNAMIC_LOADING\n #   endif\n+#   ifdef OPENBSD\n+#\tdefine OS_TYPE \"OPENBSD\"\n+#\tdefine HEURISTIC2\n+#   \tdefine CPP_WORDSZ 64\n+#   \tifdef __ELF__\t/* since OpenBSD/Alpha 2.9 */\n+#\t   define DATASTART GC_data_start\n+#   \t   define ELFCLASS32 32\n+#   \t   define ELFCLASS64 64\n+#   \t   define ELF_CLASS ELFCLASS64\n+#       else\t\t/* ECOFF, until OpenBSD/Alpha 2.7 */\n+#   \t   define DATASTART ((ptr_t) 0x140000000)\n+#   \tendif\n+#   endif\n #   ifdef OSF1\n #\tdefine OS_TYPE \"OSF1\"\n #   \tdefine DATASTART ((ptr_t) 0x140000000)\n@@ -1282,9 +1308,6 @@\n \n # ifdef IA64\n #   define MACH_TYPE \"IA64\"\n-#   define ALIGN_DOUBLE\n-\t/* Requires 16 byte alignment for malloc */\n-#   define ALIGNMENT 8\n #   define USE_GENERIC_PUSH_REGS\n \t/* We need to get preserved registers in addition to register   */\n \t/* windows.   That's easiest to do with setjmp.\t\t\t*/\n@@ -1294,11 +1317,47 @@\n \t    /* setting mark bits.\t\t\t\t\t*/\n #   endif\n #   ifdef HPUX\n-\t--> needs work\n+#\tifdef _ILP32\n+#\t  define CPP_WORDSZ 32\n+#         define ALIGN_DOUBLE\n+\t    /* Requires 8 byte alignment for malloc */\n+#   \t  define ALIGNMENT 4\n+#       else\n+#\t  ifndef _LP64\n+\t\t---> unknown ABI\n+#         endif\n+#\t  define CPP_WORDSZ 64\n+#   \t  define ALIGN_DOUBLE\n+\t    /* Requires 16 byte alignment for malloc */\n+#         define ALIGNMENT 8\n+#       endif\n+#       define OS_TYPE \"HPUX\"\t\n+        extern int __data_start;\n+#       define DATASTART ((ptr_t)(&__data_start))\n+        /* Gustavo Rodriguez-Rivera suggested changing HEURISTIC2\t*/\n+        /* to this.  Note that the GC must be initialized before the\t*/\n+    \t/* first putenv call.\t\t\t\t\t\t*/\n+\textern char ** environ;\n+#       define STACKBOTTOM ((ptr_t)environ)\n+#       define DYNAMIC_LOADING\n+#       include <unistd.h>\n+#       define GETPAGESIZE() sysconf(_SC_PAGE_SIZE)\n+ \t/* The following was empirically determined, and is probably\t*/\n+\t/* not very robust.\t\t\t\t\t\t*/\n+\t/* Note that the backing store base seems to be at a nice \t*/\n+\t/* address minus one page.\t\t\t\t\t*/\n+#\tdefine BACKING_STORE_DISPLACEMENT 0x1000000\n+#\tdefine BACKING_STORE_ALIGNMENT 0x1000\n+#       define BACKING_STORE_BASE \\\n+\t  (ptr_t)(((word)GC_stackbottom - BACKING_STORE_DISPLACEMENT - 1) \\\n+\t\t\t& ~(BACKING_STORE_ALIGNMENT - 1))\n #   endif\n #   ifdef LINUX\n+#   \tdefine CPP_WORDSZ 64\n+#   \tdefine ALIGN_DOUBLE\n+\t  /* Requires 16 byte alignment for malloc */\n+#   \tdefine ALIGNMENT 8\n #       define OS_TYPE \"LINUX\"\n-#       define CPP_WORDSZ 64\n \t/* The following works on NUE and older kernels:\t*/\n /* #       define STACKBOTTOM ((ptr_t) 0xa000000000000000l)\t*/\n \t/* This does not work on NUE:\t\t\t\t*/\n@@ -1579,57 +1638,33 @@\n \t((word*)x)[1] = 0;\n # endif /* CLEAR_DOUBLE */\n \n-/* Internally to the collector we test only the XXX_THREADS macros\t*/\n-/* not the GC_XXX_THREADS versions.  Here we make sure the latter\t*/\n-/* are treated as equivalent.\t\t\t\t\t\t*/\n-#if defined(GC_SOLARIS_THREADS) && !defined(_SOLARIS_THREADS)\n-#   define _SOLARIS_THREADS\n-#endif\n-#if defined(GC_SOLARIS_THREADS) && !defined(_SOLARIS_PTHREADS)\n-#   define _SOLARIS_PTHREADS\n-#endif\n-#if defined(GC_IRIX_THREADS) && !defined(IRIX_THREADS)\n-#   define IRIX_THREADS\n-#endif\n-#if defined(GC_LINUX_THREADS) && !defined(LINUX_THREADS)\n-#   define LINUX_THREADS\n-#endif\n-#if defined(GC_WIN32_THREADS) && !defined(WIN32_THREADS)\n-#   define WIN32_THREADS\n-#endif\n-#if defined(GC_HPUX_THREADS) && !defined(HPUX_THREADS)\n-#   define HPUX_THREADS\n-#endif\n-#if defined(GC_OSF1_THREADS) && !defined(OSF1_THREADS)\n-#   define OSF1_THREADS\n-#endif\n-\n-/* Internally we use SOLARIS_THREADS to test for either old or pthreads. */\n-# if defined(_SOLARIS_PTHREADS) && !defined(SOLARIS_THREADS)\n-#   define SOLARIS_THREADS\n+/* Internally we use GC_SOLARIS_THREADS to test for either old or pthreads. */\n+# if defined(GC_SOLARIS_PTHREADS) && !defined(GC_SOLARIS_THREADS)\n+#   define GC_SOLARIS_THREADS\n # endif\n-# if defined(IRIX_THREADS) && !defined(IRIX5)\n+\n+# if defined(GC_IRIX_THREADS) && !defined(IRIX5)\n --> inconsistent configuration\n # endif\n-# if defined(LINUX_THREADS) && !defined(LINUX)\n+# if defined(GC_LINUX_THREADS) && !defined(LINUX)\n --> inconsistent configuration\n # endif\n-# if defined(SOLARIS_THREADS) && !defined(SUNOS5)\n+# if defined(GC_SOLARIS_THREADS) && !defined(SUNOS5)\n --> inconsistent configuration\n # endif\n-# if defined(HPUX_THREADS) && !defined(HPUX)\n+# if defined(GC_HPUX_THREADS) && !defined(HPUX)\n --> inconsistent configuration\n # endif\n-# if defined(WIN32_THREADS) && !defined(MSWIN32)\n-    /* Ideally CYGWIN32 should work, in addition to MSWIN32.  I suspect the necessary code\t*/\n-    /* is mostly there, but nobody has actually made sure the right combination of pieces is\t*/\n-    /* compiled in, etc.\t\t\t\t\t\t\t\t\t*/\n+# if defined(GC_WIN32_THREADS) && !defined(MSWIN32)\n+    /* Ideally CYGWIN32 should work, in addition to MSWIN32.  I suspect\t*/\n+    /* the necessary code is mostly there, but nobody has actually made */\n+    /* sure the right combination of pieces is compiled in, etc.\t*/\n --> inconsistent configuration\n # endif\n+\n # if defined(PCR) || defined(SRC_M3) || \\\n-\tdefined(SOLARIS_THREADS) || defined(WIN32_THREADS) || \\\n-\tdefined(IRIX_THREADS) || defined(LINUX_THREADS) || \\\n-\tdefined(HPUX_THREADS) || defined(OSF1_THREADS)\n+\tdefined(GC_SOLARIS_THREADS) || defined(GC_WIN32_THREADS) || \\\n+\tdefined(GC_PTHREADS)\n #   define THREADS\n # endif\n "}, {"sha": "c894a31006dd34604568e8c2a1d223cd384618ab", "filename": "boehm-gc/irix_threads.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Firix_threads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Firix_threads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Firix_threads.c?ref=4c7726b172c35bd078bb0f88025670ffddd94a92", "patch": "@@ -21,11 +21,11 @@\n  * HP/UX 11.\n  *\n  * Note that there is a lot of code duplication between linux_threads.c\n- * and hpux_irix_threads.c; any changes made here may need to be reflected\n+ * and irix_threads.c; any changes made here may need to be reflected\n  * there too.\n  */\n \n-# if defined(GC_IRIX_THREADS) || defined(IRIX_THREADS)\n+# if defined(GC_IRIX_THREADS)\n \n # include \"private/gc_priv.h\"\n # include <pthread.h>\n@@ -725,5 +725,5 @@ void GC_lock()\n   int GC_no_Irix_threads;\n #endif\n \n-# endif /* IRIX_THREADS */\n+# endif /* GC_IRIX_THREADS */\n "}, {"sha": "f52eab8c1247ae37313771242a777126a710a14c", "filename": "boehm-gc/linux_threads.c", "status": "modified", "additions": 36, "deletions": 14, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Flinux_threads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Flinux_threads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Flinux_threads.c?ref=4c7726b172c35bd078bb0f88025670ffddd94a92", "patch": "@@ -50,13 +50,14 @@\n \n /* ANSI C requires that a compilation unit contains something */\n \n-# if defined(GC_LINUX_THREADS) || defined(LINUX_THREADS) \\\n-     || defined(GC_HPUX_THREADS) || defined(HPUX_THREADS) \\\n-     || defined(GC_OSF1_THREADS) || defined(OSF1_THREADS) \\\n+# include \"gc.h\"\n+\n+# if defined(GC_PTHREADS) && !defined(GC_SOLARIS_THREADS) \\\n+     && !defined(GC_IRIX_THREADS)\n \n # include \"private/gc_priv.h\"\n \n-# if defined(HPUX_THREADS) && !defined(USE_PTHREAD_SPECIFIC) \\\n+# if defined(GC_HPUX_THREADS) && !defined(USE_PTHREAD_SPECIFIC) \\\n      && !defined(USE_HPUX_TLS)\n #   define USE_HPUX_TLS\n # endif\n@@ -449,7 +450,7 @@ GC_PTR GC_local_gcj_malloc(size_t bytes,\n  */\n \n #ifndef SIG_THR_RESTART\n-#  if defined(HPUX_THREADS) || defined(GC_OSF1_THREADS)\n+#  if defined(GC_HPUX_THREADS) || defined(GC_OSF1_THREADS)\n #   define SIG_THR_RESTART _SIGRTMIN + 5\n #  else\n #   define SIG_THR_RESTART SIGXCPU\n@@ -458,16 +459,19 @@ GC_PTR GC_local_gcj_malloc(size_t bytes,\n \n sem_t GC_suspend_ack_sem;\n \n-#if !defined(HPUX_THREADS) && !defined(GC_OSF1_THREADS)\n+#if 0\n /*\n To make sure that we're using LinuxThreads and not some other thread\n package, we generate a dummy reference to `pthread_kill_other_threads_np'\n (was `__pthread_initial_thread_bos' but that disappeared),\n which is a symbol defined in LinuxThreads, but (hopefully) not in other\n thread packages.\n+\n+We no longer do this, since this code is now portable enough that it might\n+actually work for something else.\n */\n void (*dummy_var_to_force_linux_threads)() = pthread_kill_other_threads_np;\n-#endif /* !HPUX_THREADS */\n+#endif /* 0 */\n \n #if defined(SPARC) || defined(IA64)\n   extern word GC_save_regs_in_stack();\n@@ -530,6 +534,24 @@ static void start_mark_threads()\n \t\n     if (0 != pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED))\n \tABORT(\"pthread_attr_setdetachstate failed\");\n+\n+#   ifdef HPUX\n+      /* Default stack size is usually too small: fix it. */\n+      /* Otherwise marker threads or GC may run out of\t  */\n+      /* space.\t\t\t\t\t\t  */\n+#     define MIN_STACK_SIZE (8*HBLKSIZE*sizeof(word))\n+      {\n+\tsize_t old_size;\n+\tint code;\n+\n+        if (pthread_attr_getstacksize(&attr, &old_size) != 0)\n+\t  ABORT(\"pthread_attr_getstacksize failed\\n\");\n+\tif (old_size < MIN_STACK_SIZE) {\n+\t  if (pthread_attr_setstacksize(&attr, MIN_STACK_SIZE) != 0)\n+\t    ABORT(\"pthread_attr_getstacksize failed\\n\");\n+\t}\n+      }\n+#   endif /* HPUX */\n #   ifdef CONDPRINT\n       if (GC_print_stats) {\n \tGC_printf1(\"Starting %ld marker threads\\n\", GC_markers - 1);\n@@ -970,7 +992,7 @@ int GC_segment_is_thread_stack(ptr_t lo, ptr_t hi)\n }\n #endif /* USE_PROC_FOR_LIBRARIES */\n \n-#ifdef LINUX_THREADS\n+#ifdef GC_LINUX_THREADS\n /* Return the number of processors, or i<= 0 if it can't be determined.\t*/\n int GC_get_nprocs()\n {\n@@ -1006,7 +1028,7 @@ int GC_get_nprocs()\n     }\n     return result;\n }\n-#endif /* LINUX_THREADS */\n+#endif /* GC_LINUX_THREADS */\n \n /* We hold the allocation lock.\t*/\n void GC_thr_init()\n@@ -1064,13 +1086,13 @@ void GC_thr_init()\n \tif (nprocs_string != NULL) GC_nprocs = atoi(nprocs_string);\n       }\n       if (GC_nprocs <= 0) {\n-#       if defined(HPUX_THREADS)\n+#       if defined(GC_HPUX_THREADS)\n \t  GC_nprocs = pthread_num_processors_np();\n #       endif\n-#       if defined(OSF1_THREADS)\n+#       if defined(GC_OSF1_THREADS) || defined(GC_FREEBSD_THREADS)\n           GC_nprocs = 1;\n #       endif\n-#\tifdef LINUX_THREADS\n+#\tif defined(GC_LINUX_THREADS)\n           GC_nprocs = GC_get_nprocs();\n #\tendif\n       }\n@@ -1585,7 +1607,7 @@ void GC_lock()\n   pthread_t GC_mark_lock_holder = NO_THREAD;\n #endif\n \n-#ifdef IA64\n+#if 0\n   /* Ugly workaround for a linux threads bug in the final versions      */\n   /* of glibc2.1.  Pthread_mutex_trylock sets the mutex owner           */\n   /* field even when it fails to acquire the mutex.  This causes        */\n@@ -1692,5 +1714,5 @@ void GC_notify_all_marker()\n \n #endif /* PARALLEL_MARK */\n \n-# endif /* LINUX_THREADS */\n+# endif /* GC_LINUX_THREADS and friends */\n "}, {"sha": "35e9264bd851870fe7972158a7a1bc78173115f7", "filename": "boehm-gc/mach_dep.c", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Fmach_dep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Fmach_dep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmach_dep.c?ref=4c7726b172c35bd078bb0f88025670ffddd94a92", "patch": "@@ -492,8 +492,9 @@ ptr_t cold_gc_frame;\n /* On IA64, we also need to flush register windows.  But they end\t*/\n /* up on the other side of the stack segment.\t\t\t\t*/\n /* Returns the backing store pointer for the register stack.\t\t*/\n+/* We implement this as a separate file in HP/UX.\t\t\t*/\n # ifdef IA64\n-#   ifdef __GNUC__\n+#   ifdef LINUX\n \tasm(\"        .text\");\n \tasm(\"        .psr abi64\");\n \tasm(\"        .psr lsb\");\n@@ -510,12 +511,25 @@ ptr_t cold_gc_frame;\n \tasm(\"        mov r8=ar.bsp\");\n \tasm(\"        br.ret.sptk.few rp\");\n \tasm(\"        .endp GC_save_regs_in_stack\");\n-#   else\n-\tvoid GC_save_regs_in_stack() {\n-\t  asm(\"        flushrs\");\n-\t  asm(\"        ;;\");\n-\t  asm(\"        mov r8=ar.bsp\");\n-\t  asm(\"        br.ret.sptk.few rp\");\n+#   endif /* LINUX */\n+#   if 0 /* Other alternatives that don't work on HP/UX */\n+\tword GC_save_regs_in_stack() {\n+#\t  if USE_BUILTINS\n+\t    __builtin_ia64_flushrs();\n+\t    return __builtin_ia64_bsp();\n+#\t  else\n+#\t    ifdef HPUX\n+\t      _asm(\"        flushrs\");\n+\t      _asm(\"        ;;\");\n+\t      _asm(\"        mov r8=ar.bsp\");\n+\t      _asm(\"        br.ret.sptk.few rp\");\n+#\t    else\n+\t      asm(\"        flushrs\");\n+\t      asm(\"        ;;\");\n+\t      asm(\"        mov r8=ar.bsp\");\n+\t      asm(\"        br.ret.sptk.few rp\");\n+#\t    endif\n+#\t  endif\n \t}\n #   endif\n # endif"}, {"sha": "943f27d337c846bb14511fd791d7f0450521dde9", "filename": "boehm-gc/malloc.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Fmalloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Fmalloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmalloc.c?ref=4c7726b172c35bd078bb0f88025670ffddd94a92", "patch": "@@ -315,7 +315,7 @@ DCL_LOCK_STATE;\n     /* It might help to manually inline the GC_malloc call here.\t*/\n     /* But any decent compiler should reduce the extra procedure call\t*/\n     /* to at most a jump instruction in this case.\t\t\t*/\n-#   if defined(I386) && defined(SOLARIS_THREADS)\n+#   if defined(I386) && defined(GC_SOLARIS_THREADS)\n       /*\n        * Thread initialisation can call malloc before\n        * we're ready for it.\n@@ -324,7 +324,7 @@ DCL_LOCK_STATE;\n        * inopportune times.\n        */\n       if (!GC_is_initialized) return sbrk(lb);\n-#   endif /* I386 && SOLARIS_THREADS */\n+#   endif /* I386 && GC_SOLARIS_THREADS */\n     return((GC_PTR)REDIRECT_MALLOC(lb));\n   }\n \n@@ -360,7 +360,7 @@ DCL_LOCK_STATE;\n     h = HBLKPTR(p);\n     hhdr = HDR(h);\n #   if defined(REDIRECT_MALLOC) && \\\n-\t(defined(SOLARIS_THREADS) || defined(LINUX_THREADS) \\\n+\t(defined(GC_SOLARIS_THREADS) || defined(GC_LINUX_THREADS) \\\n \t || defined(__MINGW32__)) /* Should this be MSWIN32 in general? */\n \t/* For Solaris, we have to redirect malloc calls during\t\t*/\n \t/* initialization.  For the others, this seems to happen \t*/"}, {"sha": "a082e2b2e06904b815418e22c7aaaa89fc1c65b6", "filename": "boehm-gc/mark_rts.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Fmark_rts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Fmark_rts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmark_rts.c?ref=4c7726b172c35bd078bb0f88025670ffddd94a92", "patch": "@@ -568,11 +568,11 @@ ptr_t cold_gc_frame;\n      */\n #   if !defined(USE_GENERIC_PUSH_REGS)\n \tGC_push_current_stack(cold_gc_frame);\n-\t/* IN the threads case, this only pushes collector frames.      */\n+\t/* In the threads case, this only pushes collector frames.      */\n \t/* In the USE_GENERIC_PUSH_REGS case, this is done inside\t*/\n \t/* GC_push_regs, so that we catch callee-save registers saved\t*/\n \t/* inside the GC_push_regs frame.\t\t\t\t*/\n-\t/* In the case of linux threads on Ia64, the hot section of\t*/\n+\t/* In the case of linux threads on IA64, the hot section of\t*/\n \t/* the main stack is marked here, but the register stack\t*/\n \t/* backing store is handled in the threads-specific code.\t*/\n #   endif"}, {"sha": "2bb93f3dd57c79505817065dfa0e6d9c22b6cc0d", "filename": "boehm-gc/misc.c", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmisc.c?ref=4c7726b172c35bd078bb0f88025670ffddd94a92", "patch": "@@ -22,7 +22,7 @@\n #define I_HIDE_POINTERS\t/* To make GC_call_with_alloc_lock visible */\n #include \"private/gc_pmark.h\"\n \n-#ifdef SOLARIS_THREADS\n+#ifdef GC_SOLARIS_THREADS\n # include <sys/syscall.h>\n #endif\n #if defined(MSWIN32) || defined(MSWINCE)\n@@ -41,29 +41,27 @@\n \t/* Critical section counter is defined in the M3 runtime \t*/\n \t/* That's all we use.\t\t\t\t\t\t*/\n #     else\n-#\tifdef SOLARIS_THREADS\n+#\tifdef GC_SOLARIS_THREADS\n \t  mutex_t GC_allocate_ml;\t/* Implicitly initialized.\t*/\n #\telse\n-#          ifdef WIN32_THREADS\n+#          ifdef GC_WIN32_THREADS\n #\t      if !defined(GC_NOT_DLL) && (defined(_DLL) || defined(GC_DLL))\n \t\t __declspec(dllexport) CRITICAL_SECTION GC_allocate_ml;\n #\t      else\n \t\t CRITICAL_SECTION GC_allocate_ml;\n #\t      endif\n #          else\n-#             if defined(IRIX_THREADS) \\\n-\t\t || (defined(LINUX_THREADS) && defined(USE_SPIN_LOCK))\n-\t        pthread_t GC_lock_holder = NO_THREAD;\n-#\t      else\n-#\t        if defined(HPUX_THREADS) \\\n-\t\t   || defined(LINUX_THREADS) && !defined(USE_SPIN_LOCK)\n+#             if defined(GC_PTHREADS) && !defined(GC_SOLARIS_THREADS)\n+#\t\tif defined(USE_SPIN_LOCK)\n+\t          pthread_t GC_lock_holder = NO_THREAD;\n+#\t        else\n \t\t  pthread_mutex_t GC_allocate_ml = PTHREAD_MUTEX_INITIALIZER;\n \t          pthread_t GC_lock_holder = NO_THREAD;\n \t\t\t/* Used only for assertions, and to prevent\t */\n \t\t\t/* recursive reentry in the system call wrapper. */\n-#\t\telse \n+#\t\tendif \n+#    \t      else\n \t          --> declare allocator lock here\n-#\t\tendif\n #\t      endif\n #\t   endif\n #\tendif\n@@ -524,20 +522,18 @@ void GC_init_inner()\n #   if defined(SEARCH_FOR_DATA_START)\n \tGC_init_linux_data_start();\n #   endif\n-#   if defined(NETBSD) && defined(__ELF__)\n+#   if (defined(NETBSD) || defined(OPENBSD)) && defined(__ELF__)\n \tGC_init_netbsd_elf();\n #   endif\n-#   if defined(IRIX_THREADS) || defined(LINUX_THREADS) \\\n-       || defined(HPUX_THREADS) || defined(SOLARIS_THREADS)\n+#   if defined(GC_PTHREADS) || defined(GC_SOLARIS_THREADS)\n         GC_thr_init();\n #   endif\n-#   ifdef SOLARIS_THREADS\n+#   ifdef GC_SOLARIS_THREADS\n \t/* We need dirty bits in order to find live stack sections.\t*/\n         GC_dirty_init();\n #   endif\n-#   if !defined(THREADS) || defined(SOLARIS_THREADS) || defined(WIN32_THREADS) \\\n-       || defined(IRIX_THREADS) || defined(LINUX_THREADS) \\\n-       || defined(HPUX_THREADS)\n+#   if !defined(THREADS) || defined(GC_PTHREADS) || defined(GC_WIN32_THREADS) \\\n+\t|| defined(GC_SOLARIS_THREADS)\n       if (GC_stackbottom == 0) {\n \tGC_stackbottom = GC_get_stack_base();\n #       if defined(LINUX) && defined(IA64)\n@@ -652,7 +648,7 @@ void GC_enable_incremental GC_PROTO(())\n \tif (GC_is_win32s()) goto out;\n       }\n #   endif /* MSWIN32 */\n-#   ifndef SOLARIS_THREADS\n+#   ifndef GC_SOLARIS_THREADS\n         GC_dirty_init();\n #   endif\n     if (!GC_is_initialized) {\n@@ -753,7 +749,7 @@ size_t len;\n      register int result;\n      \n      while (bytes_written < len) {\n-#\tifdef SOLARIS_THREADS\n+#\tifdef GC_SOLARIS_THREADS\n \t    result = syscall(SYS_write, fd, buf + bytes_written,\n \t    \t\t\t  \t    len - bytes_written);\n #\telse"}, {"sha": "1aa2c7a125320a485ea1d545b1fc58234c10b971", "filename": "boehm-gc/new_hblk.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Fnew_hblk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Fnew_hblk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fnew_hblk.c?ref=4c7726b172c35bd078bb0f88025670ffddd94a92", "patch": "@@ -247,6 +247,7 @@ int kind;\n \t    ABORT(\"HBLK SZ inconsistency\");\n         }\n #   endif\n+  if (GC_debugging_started) clear = TRUE;\n \n   /* Allocate a new heap block */\n     h = GC_allochblk(sz, kind, 0);"}, {"sha": "cc816dff07f84287b218c27faf31e763754af5c8", "filename": "boehm-gc/os_dep.c", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Fos_dep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Fos_dep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fos_dep.c?ref=4c7726b172c35bd078bb0f88025670ffddd94a92", "patch": "@@ -71,10 +71,6 @@\n #   define NEED_FIND_LIMIT\n # endif\n \n-# if defined(IRIX_THREADS) || defined(HPUX_THREADS)\n-#   define NEED_FIND_LIMIT\n-# endif\n-\n # if (defined(SUNOS4) && defined(DYNAMIC_LOADING)) && !defined(PCR)\n #   define NEED_FIND_LIMIT\n # endif\n@@ -219,7 +215,7 @@ static void *tiny_sbrk(ptrdiff_t increment)\n #define sbrk tiny_sbrk\n # endif /* ECOS */\n \n-#if defined(NETBSD) && defined(__ELF__)\n+#if (defined(NETBSD) || defined(OPENBSD)) && defined(__ELF__)\n   ptr_t GC_data_start;\n \n   void GC_init_netbsd_elf()\n@@ -562,7 +558,7 @@ ptr_t GC_get_stack_base()\n           /* signal mask.                                               */\n \n \t  (void) sigemptyset(&act.sa_mask);\n-#\t  ifdef IRIX_THREADS\n+#\t  ifdef GC_IRIX_THREADS\n \t\t/* Older versions have a bug related to retrieving and\t*/\n \t\t/* and setting a handler at the same time.\t\t*/\n \t        (void) sigaction(SIGSEGV, 0, &old_segv_act);\n@@ -576,7 +572,7 @@ ptr_t GC_get_stack_base()\n \t\t    /* don't have to worry in the threads case.\t\t*/\n \t\t    (void) sigaction(SIGBUS, &act, &old_bus_act);\n #\t\tendif\n-#\t  endif\t/* IRIX_THREADS */\n+#\t  endif\t/* GC_IRIX_THREADS */\n #\telse\n     \t  old_segv_handler = signal(SIGSEGV, h);\n #\t  ifdef SIGBUS\n@@ -680,7 +676,12 @@ ptr_t GC_get_stack_base()\n \n     ptr_t GC_get_register_stack_base(void)\n     {\n-      if (0 != &__libc_ia64_register_backing_store_base) {\n+      if (0 != &__libc_ia64_register_backing_store_base\n+\t  && 0 != __libc_ia64_register_backing_store_base) {\n+\t/* Glibc 2.2.4 has a bug such that for dynamically linked\t*/\n+\t/* executables __libc_ia64_register_backing_store_base is \t*/\n+\t/* defined but ininitialized during constructor calls.  \t*/\n+\t/* Hence we check for both nonzero address and value.\t\t*/\n \treturn __libc_ia64_register_backing_store_base;\n       } else {\n \tword result = (word)GC_stackbottom - BACKING_STORE_DISPLACEMENT;\n@@ -1090,7 +1091,7 @@ void GC_register_data_segments()\n {\n #   if !defined(PCR) && !defined(SRC_M3) && !defined(NEXT) && !defined(MACOS) \\\n        && !defined(MACOSX)\n-#     if defined(REDIRECT_MALLOC) && defined(SOLARIS_THREADS)\n+#     if defined(REDIRECT_MALLOC) && defined(GC_SOLARIS_THREADS)\n \t/* As of Solaris 2.3, the Solaris threads implementation\t*/\n \t/* allocates the data structure for the initial thread with\t*/\n \t/* sbrk at process startup.  It needs to be scanned, so that\t*/\n@@ -1651,9 +1652,8 @@ void GC_default_push_other_roots GC_PROTO((void))\n \n # endif /* SRC_M3 */\n \n-# if defined(SOLARIS_THREADS) || defined(WIN32_THREADS) \\\n-     || defined(IRIX_THREADS) || defined(LINUX_THREADS) \\\n-     || defined(HPUX_THREADS)\n+# if defined(GC_SOLARIS_THREADS) || defined(GC_PTHREADS) || \\\n+     defined(GC_WIN32_THREADS)\n \n extern void GC_push_all_stacks();\n \n@@ -1662,11 +1662,11 @@ void GC_default_push_other_roots GC_PROTO((void))\n     GC_push_all_stacks();\n }\n \n-# endif /* SOLARIS_THREADS || ... */\n+# endif /* GC_SOLARIS_THREADS || GC_PTHREADS */\n \n void (*GC_push_other_roots) GC_PROTO((void)) = GC_default_push_other_roots;\n \n-#endif\n+#endif /* THREADS */\n \n /*\n  * Routines for accessing dirty  bits on virtual pages.\n@@ -2410,7 +2410,7 @@ void GC_dirty_init()\n #   if defined(SUNOS5SIGS) || defined(IRIX5) || defined(LINUX) \\\n        || defined(OSF1) || defined(HURD)\n       /* SUNOS5SIGS includes HPUX */\n-#     if defined(IRIX_THREADS)\n+#     if defined(GC_IRIX_THREADS)\n       \tsigaction(SIGSEGV, 0, &oldact);\n       \tsigaction(SIGSEGV, &act, 0);\n #     else\n@@ -2548,7 +2548,7 @@ word len;\n     \t      ((ptr_t)end_block - (ptr_t)start_block) + HBLKSIZE);\n }\n \n-#if !defined(MSWIN32) && !defined(MSWINCE) && !defined(LINUX_THREADS) \\\n+#if !defined(MSWIN32) && !defined(MSWINCE) && !defined(GC_LINUX_THREADS) \\\n     && !defined(GC_USE_LD_WRAP)\n /* Replacement for UNIX system call.\t */\n /* Other calls that write to the heap\t */\n@@ -2572,7 +2572,7 @@ word len;\n     \n     GC_begin_syscall();\n     GC_unprotect_range(buf, (word)nbyte);\n-#   if defined(IRIX5) || defined(LINUX_THREADS)\n+#   if defined(IRIX5) || defined(GC_LINUX_THREADS)\n \t/* Indirect system call may not always be easily available.\t*/\n \t/* We could call _read, but that would interfere with the\t*/\n \t/* libpthread interception of read.\t\t\t\t*/\n@@ -2598,7 +2598,7 @@ word len;\n     GC_end_syscall();\n     return(result);\n }\n-#endif /* !MSWIN32 && !MSWINCE && !LINUX_THREADS */\n+#endif /* !MSWIN32 && !MSWINCE && !GC_LINUX_THREADS */\n \n #ifdef GC_USE_LD_WRAP\n     /* We use the GNU ld call wrapping facility.\t\t\t*/\n@@ -2671,7 +2671,7 @@ word n;\n word GC_proc_buf_size = INITIAL_BUF_SZ;\n char *GC_proc_buf;\n \n-#ifdef SOLARIS_THREADS\n+#ifdef GC_SOLARIS_THREADS\n /* We don't have exact sp values for threads.  So we count on\t*/\n /* occasionally declaring stack pages to be fresh.  Thus we \t*/\n /* need a real implementation of GC_is_fresh.  We can't clear\t*/\n@@ -2726,7 +2726,7 @@ void GC_dirty_init()\n     \tABORT(\"/proc ioctl failed\");\n     }\n     GC_proc_buf = GC_scratch_alloc(GC_proc_buf_size);\n-#   ifdef SOLARIS_THREADS\n+#   ifdef GC_SOLARIS_THREADS\n \tGC_fresh_pages = (struct hblk **)\n \t  GC_scratch_alloc(MAX_FRESH_PAGES * sizeof (struct hblk *));\n \tif (GC_fresh_pages == 0) {\n@@ -2744,7 +2744,7 @@ struct hblk *h;\n {\n }\n \n-#ifdef SOLARIS_THREADS\n+#ifdef GC_SOLARIS_THREADS\n #   define READ(fd,buf,nbytes) syscall(SYS_read, fd, buf, nbytes)\n #else\n #   define READ(fd,buf,nbytes) read(fd, buf, nbytes)\n@@ -2783,7 +2783,7 @@ int dummy;\n                 /* Punt:\t*/\n         \tmemset(GC_grungy_pages, 0xff, sizeof (page_hash_table));\n \t\tmemset(GC_written_pages, 0xff, sizeof(page_hash_table));\n-#\t\tifdef SOLARIS_THREADS\n+#\t\tifdef GC_SOLARIS_THREADS\n \t\t    BZERO(GC_fresh_pages,\n \t\t    \t  MAX_FRESH_PAGES * sizeof (struct hblk *)); \n #\t\tendif\n@@ -2813,7 +2813,7 @@ int dummy;\n \t                register word index = PHT_HASH(h);\n \t                \n \t                set_pht_entry_from_index(GC_grungy_pages, index);\n-#\t\t\tifdef SOLARIS_THREADS\n+#\t\t\tifdef GC_SOLARIS_THREADS\n \t\t\t  {\n \t\t\t    register int slot = FRESH_PAGE_SLOT(h);\n \t\t\t    \n@@ -2831,7 +2831,7 @@ int dummy;\n \t}\n     /* Update GC_written_pages. */\n         GC_or_pages(GC_written_pages, GC_grungy_pages);\n-#   ifdef SOLARIS_THREADS\n+#   ifdef GC_SOLARIS_THREADS\n       /* Make sure that old stacks are considered completely clean\t*/\n       /* unless written again.\t\t\t\t\t\t*/\n \tGC_old_stacks_are_fresh();\n@@ -2847,7 +2847,7 @@ struct hblk *h;\n     register GC_bool result;\n     \n     result = get_pht_entry_from_index(GC_grungy_pages, index);\n-#   ifdef SOLARIS_THREADS\n+#   ifdef GC_SOLARIS_THREADS\n \tif (result && PAGE_IS_FRESH(h)) result = FALSE;\n \t/* This happens only if page was declared fresh since\t*/\n \t/* the read_dirty call, e.g. because it's in an unused  */\n@@ -2865,7 +2865,7 @@ struct hblk *h;\n     register GC_bool result;\n     \n     result = get_pht_entry_from_index(GC_written_pages, index);\n-#   ifdef SOLARIS_THREADS\n+#   ifdef GC_SOLARIS_THREADS\n \tif (result && PAGE_IS_FRESH(h)) result = FALSE;\n #   endif\n     return(result);\n@@ -2879,7 +2879,7 @@ word n;\n \n     register word index;\n     \n-#   ifdef SOLARIS_THREADS\n+#   ifdef GC_SOLARIS_THREADS\n       register word i;\n       \n       if (GC_fresh_pages != 0) {"}, {"sha": "48db1e292a37100f486d17aa9cce54a03bf4c526", "filename": "boehm-gc/reclaim.c", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Freclaim.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Freclaim.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Freclaim.c?ref=4c7726b172c35bd078bb0f88025670ffddd94a92", "patch": "@@ -702,7 +702,8 @@ COUNT_DECL\n     if (report_if_found) {\n \tGC_reclaim_check(hbp, hhdr, sz);\n     } else {\n-        *flh = GC_reclaim_generic(hbp, hhdr, sz, ok -> ok_init,\n+        *flh = GC_reclaim_generic(hbp, hhdr, sz,\n+\t\t\t\t  (ok -> ok_init || GC_debugging_started),\n \t \t\t\t  *flh MEM_FOUND_ADDR);\n     }\n }\n@@ -774,8 +775,12 @@ COUNT_DECL\n /* Routines to gather and print heap block info \t*/\n /* intended for debugging.  Otherwise should be called\t*/\n /* with lock.\t\t\t\t\t\t*/\n-static size_t number_of_blocks;\n-static size_t total_bytes;\n+\n+struct Print_stats\n+{\n+\tsize_t number_of_blocks;\n+\tsize_t total_bytes;\n+};\n \n #ifdef USE_MARK_BYTES\n \n@@ -834,25 +839,30 @@ hdr * hhdr;\n {\n     register hdr * hhdr = HDR(h);\n     register size_t bytes = WORDS_TO_BYTES(hhdr -> hb_sz);\n+    struct Print_stats *ps;\n     \n     GC_printf3(\"(%lu:%lu,%lu)\", (unsigned long)(hhdr -> hb_obj_kind),\n     \t\t\t        (unsigned long)bytes,\n     \t\t\t        (unsigned long)(GC_n_set_marks(hhdr)));\n     bytes += HBLKSIZE-1;\n     bytes &= ~(HBLKSIZE-1);\n-    total_bytes += bytes;\n-    number_of_blocks++;\n+\n+    ps = (struct Print_stats *)dummy;\n+    ps->total_bytes += bytes;\n+    ps->number_of_blocks++;\n }\n \n void GC_print_block_list()\n {\n+    struct Print_stats pstats;\n+\n     GC_printf0(\"(kind(0=ptrfree,1=normal,2=unc.,3=stubborn):size_in_bytes, #_marks_set)\\n\");\n-    number_of_blocks = 0;\n-    total_bytes = 0;\n-    GC_apply_to_all_blocks(GC_print_block_descr, (word)0);\n+    pstats.number_of_blocks = 0;\n+    pstats.total_bytes = 0;\n+    GC_apply_to_all_blocks(GC_print_block_descr, (word)&pstats);\n     GC_printf2(\"\\nblocks = %lu, bytes = %lu\\n\",\n-    \t       (unsigned long)number_of_blocks,\n-    \t       (unsigned long)total_bytes);\n+    \t       (unsigned long)pstats.number_of_blocks,\n+    \t       (unsigned long)pstats.total_bytes);\n }\n \n #endif /* NO_DEBUGGING */"}, {"sha": "b07dd9b0a0471c0d34bf41ab73b0d0c7b54cfe80", "filename": "boehm-gc/solaris_pthreads.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Fsolaris_pthreads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Fsolaris_pthreads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fsolaris_pthreads.c?ref=4c7726b172c35bd078bb0f88025670ffddd94a92", "patch": "@@ -17,7 +17,7 @@\n  */\n /* Boehm, September 14, 1994 4:44 pm PDT */\n \n-# if defined(GC_SOLARIS_PTHREADS) || defined(_SOLARIS_PTHREADS)\n+# if defined(GC_SOLARIS_PTHREADS)\n # include \"private/gc_priv.h\"\n # include <pthread.h>\n # include <thread.h>\n@@ -175,5 +175,5 @@ GC_pthread_create(pthread_t *new_thread,\n   int GC_no_sunOS_pthreads;\n #endif\n \n-# endif /* SOLARIS_THREADS */\n+# endif /* GC_SOLARIS_PTHREADS */\n "}, {"sha": "11b0e0375f6c85bde7e9c74190f24ae4c9075494", "filename": "boehm-gc/solaris_threads.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Fsolaris_threads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Fsolaris_threads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fsolaris_threads.c?ref=4c7726b172c35bd078bb0f88025670ffddd94a92", "patch": "@@ -16,7 +16,7 @@\n  */\n /* Boehm, September 14, 1994 4:44 pm PDT */\n \n-# if defined(GC_SOLARIS_THREADS) || defined(SOLARIS_THREADS)\n+# if defined(GC_SOLARIS_THREADS)\n \n # include \"private/gc_priv.h\"\n # include \"private/solaris_threads.h\"\n@@ -949,7 +949,7 @@ GC_thr_create(void *stack_base, size_t stack_size,\n     return(result);\n }\n \n-# else /* SOLARIS_THREADS */\n+# else /* !GC_SOLARIS_THREADS */\n \n #ifndef LINT\n   int GC_no_sunOS_threads;"}, {"sha": "48b53ac9f8ce86c710d400e4e45f6a0cbf5be989", "filename": "boehm-gc/specific.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Fspecific.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Fspecific.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fspecific.c?ref=4c7726b172c35bd078bb0f88025670ffddd94a92", "patch": "@@ -11,7 +11,7 @@\n  * modified is included with the above copyright notice.\n  */\n \n-#if defined(LINUX_THREADS) || defined(GC_LINUX_THREADS)\n+#if defined(GC_LINUX_THREADS)\n \n #include \"private/gc_priv.h\" /* For GC_compare_and_exchange, GC_memory_barrier */\n #include \"private/specific.h\"\n@@ -105,4 +105,4 @@ void *  PREFIXED(slow_getspecific) (tsd * key, unsigned long qtid,\n     return entry -> value;\n }\n \n-#endif /* LINUX_THREADS */\n+#endif /* GC_LINUX_THREADS */"}, {"sha": "35cb1357883a6dc8f5959b9e269571dce8662ad8", "filename": "boehm-gc/tests/test.c", "status": "modified", "additions": 40, "deletions": 35, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Ftests%2Ftest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Ftests%2Ftest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ftests%2Ftest.c?ref=4c7726b172c35bd078bb0f88025670ffddd94a92", "patch": "@@ -59,16 +59,16 @@\n #   define GC_printf1 printf\n # endif\n \n-# ifdef SOLARIS_THREADS\n+# if defined(GC_SOLARIS_THREADS) && !defined(GC_SOLARIS_PTHREADS)\n #   include <thread.h>\n #   include <synch.h>\n # endif\n \n-# if defined(IRIX_THREADS) || defined(LINUX_THREADS) || defined(HPUX_THREADS)\n+# if defined(GC_PTHREADS)\n #   include <pthread.h>\n # endif\n \n-# ifdef WIN32_THREADS\n+# ifdef GC_WIN32_THREADS\n #   ifndef MSWINCE\n #     include <process.h>\n #     define GC_CreateThread(a,b,c,d,e,f) ((HANDLE) _beginthreadex(a,b,c,d,e,f))\n@@ -447,7 +447,7 @@ struct {\n  */\n #ifdef THREADS\n \n-# ifdef WIN32_THREADS\n+# ifdef GC_WIN32_THREADS\n     unsigned __stdcall tiny_reverse_test(void * arg)\n # else\n     void * tiny_reverse_test(void * arg)\n@@ -457,8 +457,7 @@ struct {\n     return 0;\n }\n \n-# if defined(IRIX_THREADS) || defined(LINUX_THREADS) \\\n-     || defined(SOLARIS_PTHREADS) || defined(HPUX_THREADS)\n+# if defined(GC_PTHREADS)\n     void fork_a_thread()\n     {\n       pthread_t t;\n@@ -475,7 +474,7 @@ struct {\n       }\n     }\n \n-# elif defined(WIN32_THREADS)\n+# elif defined(GC_WIN32_THREADS)\n     void fork_a_thread()\n     {\n   \tunsigned thread_id;\n@@ -493,7 +492,7 @@ struct {\n     \t}\n     }\n \n-/* # elif defined(SOLARIS_THREADS) */\n+/* # elif defined(GC_SOLARIS_THREADS) */\n \n # else\n \n@@ -649,15 +648,15 @@ VOLATILE int dropped_something = 0;\n # ifdef PCR\n      PCR_ThCrSec_EnterSys();\n # endif\n-# ifdef SOLARIS_THREADS\n+# if defined(GC_SOLARIS_THREADS) && !defined(GC_SOLARIS_PTHREADS)\n     static mutex_t incr_lock;\n     mutex_lock(&incr_lock);\n # endif\n-# if  defined(IRIX_THREADS) || defined(LINUX_THREADS) || defined(HPUX_THREADS)\n+# if  defined(GC_PTHREADS)\n     static pthread_mutex_t incr_lock = PTHREAD_MUTEX_INITIALIZER;\n     pthread_mutex_lock(&incr_lock);\n # endif\n-# ifdef WIN32_THREADS\n+# ifdef GC_WIN32_THREADS\n     EnterCriticalSection(&incr_cs);\n # endif\n   if ((int)(GC_word)client_data != t -> level) {\n@@ -668,13 +667,13 @@ VOLATILE int dropped_something = 0;\n # ifdef PCR\n     PCR_ThCrSec_ExitSys();\n # endif\n-# ifdef SOLARIS_THREADS\n+# if defined(GC_SOLARIS_THREADS) && !defined(GC_SOLARIS_PTHREADS)\n     mutex_unlock(&incr_lock);\n # endif\n-# if defined(IRIX_THREADS) || defined(LINUX_THREADS) || defined(HPUX_THREADS)\n+# if defined(GC_PTHREADS)\n     pthread_mutex_unlock(&incr_lock);\n # endif\n-# ifdef WIN32_THREADS\n+# ifdef GC_WIN32_THREADS\n     LeaveCriticalSection(&incr_cs);\n # endif\n }\n@@ -740,16 +739,15 @@ int n;\n #\t  ifdef PCR\n  \t    PCR_ThCrSec_EnterSys();\n #\t  endif\n-#\t  ifdef SOLARIS_THREADS\n+#\t  if defined(GC_SOLARIS_THREADS) && !defined(GC_SOLARIS_PTHREADS)\n \t    static mutex_t incr_lock;\n \t    mutex_lock(&incr_lock);\n #\t  endif\n-#         if defined(IRIX_THREADS) || defined(LINUX_THREADS) \\\n-\t     || defined(HPUX_THREADS)\n+#         if defined(GC_PTHREADS)\n             static pthread_mutex_t incr_lock = PTHREAD_MUTEX_INITIALIZER;\n             pthread_mutex_lock(&incr_lock);\n #         endif\n-#         ifdef WIN32_THREADS\n+#         ifdef GC_WIN32_THREADS\n             EnterCriticalSection(&incr_cs);\n #         endif\n \t\t/* Losing a count here causes erroneous report of failure. */\n@@ -758,14 +756,13 @@ int n;\n #\t  ifdef PCR\n  \t    PCR_ThCrSec_ExitSys();\n #\t  endif\n-#\t  ifdef SOLARIS_THREADS\n+#\t  if defined(GC_SOLARIS_THREADS) && !defined(GC_SOLARIS_PTHREADS)\n \t    mutex_unlock(&incr_lock);\n #\t  endif\n-#\t  if defined(IRIX_THREADS) || defined(LINUX_THREADS) \\\n-\t     || defined(HPUX_THREADS)\n+#\t  if defined(GC_PTHREADS)\n \t    pthread_mutex_unlock(&incr_lock);\n #\t  endif\n-#         ifdef WIN32_THREADS\n+#         ifdef GC_WIN32_THREADS\n             LeaveCriticalSection(&incr_cs);\n #         endif\n \t}\n@@ -825,7 +822,7 @@ int n;\n     chktree(t -> rchild, n-1);\n }\n \n-# if defined(SOLARIS_THREADS) && !defined(_SOLARIS_PTHREADS)\n+# if defined(GC_SOLARIS_THREADS) && !defined(GC_SOLARIS_PTHREADS)\n thread_key_t fl_key;\n \n void * alloc8bytes()\n@@ -866,9 +863,7 @@ void * alloc8bytes()\n \n #else\n \n-# if defined(GC_SOLARIS_PTHREADS) || defined(GC_IRIX_THREADS) \\\n-     || defined(GC_LINUX_THREADS) || defined(GC_HPUX_THREADS) \\\n-     || defined(GC_SOLARIS_THREADS)\n+# if defined(GC_PTHREADS)\n pthread_key_t fl_key;\n \n void * alloc8bytes()\n@@ -1319,9 +1314,8 @@ void SetMinimumStack(long minSize)\n \n \n #if !defined(PCR) && !defined(GC_SOLARIS_THREADS) \\\n-    && !defined(GC_WIN32_THREADS) \\\n-    && !defined(GC_IRIX_THREADS) && !defined(GC_LINUX_THREADS) \\\n-    && !defined(GC_HPUX_THREADS) || defined(LINT)\n+    && !defined(GC_WIN32_THREADS) && !defined(GC_PTHREADS) \\\n+    || defined(LINT)\n #if defined(MSWIN32) && !defined(__MINGW32__)\n   int APIENTRY WinMain(HINSTANCE instance, HINSTANCE prev, LPTSTR cmd, int n)\n #else\n@@ -1557,8 +1551,7 @@ test()\n }\n #endif\n \n-#if defined(GC_SOLARIS_THREADS) || defined(GC_IRIX_THREADS) \\\n- || defined(GC_HPUX_THREADS) || defined(GC_LINUX_THREADS)\n+#if defined(GC_SOLARIS_THREADS) || defined(GC_PTHREADS)\n void * thr_run_one_test(void * arg)\n {\n     run_one_test();\n@@ -1569,7 +1562,7 @@ void * thr_run_one_test(void * arg)\n #  define GC_free GC_debug_free\n #endif\n \n-#ifdef GC_SOLARIS_THREADS\n+#if defined(GC_SOLARIS_THREADS) && !defined(GC_SOLARIS_PTHREADS)\n main()\n {\n     thread_t th1;\n@@ -1606,6 +1599,11 @@ main()\n     return(0);\n }\n #else /* pthreads */\n+\n+#ifndef GC_PTHREADS\n+  --> bad news\n+#endif\n+\n main()\n {\n     pthread_t th1;\n@@ -1618,8 +1616,15 @@ main()\n \t/* Since the initial cant always grow later.\t*/\n \t*((volatile char *)&code - 1024*1024) = 0;      /* Require 1 Mb */\n #   endif /* GC_IRIX_THREADS */\n+#   if defined(GC_HPUX_THREADS)\n+\t/* Default stack size is too small, especially with the 64 bit ABI */\n+\t/* Increase it.\t\t\t\t\t\t\t   */\n+\tif (pthread_default_stacksize_np(1024*1024, 0) != 0) {\n+          (void)GC_printf0(\"pthread_default_stacksize_np failed.\\n\");\n+\t}\n+#   endif\t/* GC_HPUX_THREADS */\n     pthread_attr_init(&attr);\n-#   if defined(GC_IRIX_THREADS) || defined(GC_HPUX_THREADS)\n+#   if defined(GC_IRIX_THREADS)\n     \tpthread_attr_setstacksize(&attr, 1000000);\n #   endif\n     n_tests = 0;\n@@ -1656,5 +1661,5 @@ main()\n     GC_printf1(\"Completed %d collections\\n\", GC_gc_no);\n     return(0);\n }\n-#endif /* pthreads */\n-#endif /* SOLARIS_THREADS || IRIX_THREADS || LINUX_THREADS || HPUX_THREADS */\n+#endif /* GC_PTHREADS */\n+#endif /* GC_SOLARIS_THREADS || GC_PTHREADS */"}, {"sha": "991647ee8490df30919001baf74a82fdf6a74031", "filename": "boehm-gc/threadlibs.c", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Fthreadlibs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Fthreadlibs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fthreadlibs.c?ref=4c7726b172c35bd078bb0f88025670ffddd94a92", "patch": "@@ -9,20 +9,15 @@ int main()\n \t       \"-Wl,--wrap -Wl,pthread_detach \"\n \t       \"-Wl,--wrap -Wl,pthread_sigmask -Wl,--wrap -Wl,sleep\\n\");\n #   endif\n-#   if defined(LINUX_THREADS)\n-      printf(\"-lpthread\\n\");\n+#   if defined(GC_LINUX_THREADS) || defined(GC_IRIX_THREADS) \\\n+\t|| defined(GC_FREEBSD_THREADS)\n+        printf(\"-lpthread\\n\");\n #   endif\n-#   if defined(IRIX_THREADS)\n-\tprintf(\"-lpthread\\n\");\n-#   endif\n-#   if defined(HPUX_THREADS)\n+#   if defined(GC_HPUX_THREADS) || defined(GC_OSF1_THREADS)\n \tprintf(\"-lpthread -lrt\\n\");\n #   endif\n-#   ifdef SOLARIS_THREADS\n+#   if defined(GC_SOLARIS_THREADS)\n         printf(\"-lthread -ldl\\n\");\n-#   endif\n-#   ifdef GC_OSF1_THREADS\n-\tprintf(\"-lpthread -lrt\\n\");\n #   endif\n     return 0;\n }"}, {"sha": "d4e692345c534bbb1f603c9470c42652286cbfb9", "filename": "boehm-gc/version.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Fversion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Fversion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fversion.h?ref=4c7726b172c35bd078bb0f88025670ffddd94a92", "patch": "@@ -1,6 +1,6 @@\n #define GC_VERSION_MAJOR 6\n-#define GC_VERSION_MINOR 0\n-#define GC_ALPHA_VERSION GC_NOT_ALPHA\n+#define GC_VERSION_MINOR 1\n+#define GC_ALPHA_VERSION 1\n \n #   define GC_NOT_ALPHA 0xff\n "}, {"sha": "533b6a4dd9ea8952a2414881235bf9578e7bb0de", "filename": "boehm-gc/win32_threads.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Fwin32_threads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c7726b172c35bd078bb0f88025670ffddd94a92/boehm-gc%2Fwin32_threads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fwin32_threads.c?ref=4c7726b172c35bd078bb0f88025670ffddd94a92", "patch": "@@ -1,4 +1,4 @@\n-#if defined(GC_WIN32_THREADS) || defined(WIN32_THREADS)\n+#if defined(GC_WIN32_THREADS)\n \n #include \"private/gc_priv.h\"\n \n@@ -614,4 +614,4 @@ BOOL WINAPI DllMain(HINSTANCE inst, ULONG reason, LPVOID reserved)\n \n # endif /* !MSWINCE */\n \n-#endif /* WIN32_THREADS */\n+#endif /* GC_WIN32_THREADS */"}]}