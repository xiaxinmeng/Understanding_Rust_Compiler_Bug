{"sha": "c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzVjZWMyZmU3MWIyNDNhM2E0ZTc2ZWY0MWIyZWQ2YjM2YTNkNTQzYw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-10-31T14:49:31Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-10-31T14:49:31Z"}, "message": "2014-10-31  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* aspects.adb Add an entry for aspect Ghost in table\n\tCanonical_Aspect.\n\t* aspects.ads Add an entry for aspect Ghost in tables\n\tAspect_Argument, Aspect_Delay, Aspect_Id, Aspect_Names and\n\tImplementation_Defined_Aspect.\n\t* einfo.adb: Flags 277 and 278 are now in use.\n\t(Is_Checked_Ghost_Entity): New routine.\n\t(Is_Ghost_Entity): Removed.\n\t(Is_Ghost_Subprogram): Removed.\n\t(Is_Ignored_Ghost_Entity): New routine.\n\t(Set_Is_Checked_Ghost_Entity): New routine.\n\t(Set_Is_Ignored_Ghost_Entity): New routine.\n\t(Write_Entity_Flags): Output flags Is_Checked_Ghost_Entity and\n\tIs_Ignored_Ghost_Entity.\n\t* einfo.ads: Add new flags Is_Checked_Ghost_Entity\n\tand Is_Ignored_Ghost_Entity along with usage in nodes.\n\t(Is_Checked_Ghost_Entity): New routine and pragma Inline.\n\t(Is_Ghost_Entity): Removed along with synthesized flag\n\tdescription and usage in nodes.\n\t(Is_Ghost_Subprogram): Removed along with synthesized flag description\n\tand usage in nodes.\n\t(Is_Ignored_Ghost_Entity): New routine and pragma Inline.\n\t(Set_Is_Checked_Ghost_Entity): New routine and pragma Inline.\n\t(Set_Is_Ignored_Ghost_Entity): New routine and pragma Inline.\n\t* freeze.adb (Freeze_Entity): A Ghost type cannot be effectively\n\tvolatile.\n\t* par-prag.adb Pragma Ghost does not need special handling by\n\tthe parser.\n\t* repinfo.adb (List_Mechanisms): Remove the entry for convention Ghost.\n\t* sem_attr.adb (Analyze_Access_Attribute): Remove obsolete check.\n\t* sem_ch3.adb (Analyze_Full_Type_Declaration): Mark\n\tthe type as Ghost when its enclosing context is Ghost.\n\t(Analyze_Incomplete_Type_Decl): Mark the type as Ghost when\n\tits enclosing context is Ghost.\n\t(Analyze_Number_Declaration): Mark the number as Ghost when its\n\tenclosing context is Ghost.\n\t(Analyze_Object_Declaration): Mark the object as Ghost when its\n\tenclosing context is Ghost. Verify the Ghost policy between\n\tinitial declaration and completion of a deferred constant.\n\t(Analyze_Object_Contract): A Ghost variable cannot be effectively\n\tvolatile, imported or exported.\n\t(Build_Derived_Record_Type): Mark a type extension as Ghost when it\n\timplements a Ghost interface.\n\t(Build_Record_Type): Inherit volatility and \"ghostness\" from\n\tthe parent type.\n\t(Check_Completion): A Ghost entity declared\n\tin a non-Ghost package does not require completion in a body.\n\t(Implements_Ghost_Interface): New routine.\n\t(Process_Full_View): Inherit \"ghostness\" from the partial view. Verify\n\tthe Ghost policy between the partial and full views. Verify the\n\tcompletion of a Ghost type extension.\n\t* sem_ch4.adb (Check_Ghost_Subprogram_Call): Removed.\n\t* sem_ch5.adb (Analyze_Assignment): Analyze the left hand side first.\n\t* sem_ch6.adb (Analyze_Abstract_Subprogram_Declaration): Mark\n\tthe subprogram as Ghost when its enclosing context is Ghost.\n\t(Analyze_Generic_Subprogram_Body): Mark the generic body as Ghost\n\twhen its enclosing context is Ghost. Verify the Ghost policy\n\tbetween the spec and body.\n\t(Analyze_Subprogram_Body_Helper): Mark the body as Ghost when its\n\tenclosing context is Ghost. Verify the Ghost policy between the spec\n\tand body.\n\t(Check_Conformance): A Ghost subprogram profile and a non-Ghost\n\tsubprogram profile are not subtype conformant.\n\t(Convention_Of): Removed.\n\t* sem_ch7.adb (Analyze_Package_Body_Helper): Inherit the\n\t\"ghostness\" from the spec. Verify the Ghost policy between\n\tthe spec and body.\n\t(Analyze_Private_Type_Declaration): Mark the type as Ghost when its\n\tenclosing context is Ghost.\n\t(Requires_Completion_In_Body): New routine.\n\t(Unit_Requires_Body): Use Requires_Completion_In_Body.\n\t(Unit_Requires_Body_Info): Rename formal parameter P to Pack_Id, update\n\tcomment on usage and all uses of P in the body. Use\n\tRequires_Completion_In_Body.\n\t* sem_ch7.ads (Unit_Requires_Body): Rename formal parameter P\n\tto Pack_Id, update comment on usage and all uses of P in the body.\n\t* sem_ch8.adb (Analyze_Exception_Renaming): Inherit the \"ghostness\"\n\tfrom the renamed excention.\n\t(Analyze_Generic_Renaming): Inherit the \"ghostness\" from the\n\trenamed generic subprogram.\n\t(Analyze_Object_Renaming): Inherit the \"ghostness\" from the renamed\n\tobject.\n\t(Analyze_Package_Renaming): Inherit the \"ghostness\" from the\n\trenamed package.\n\t(Analyze_Subprogram_Renaming): Inherit the \"ghostness\" from the\n\trenamed subprogram.\n\t* sem_ch11.adb (Analyze_Exception_Declaration): Mark an exception\n\tas Ghost when its enclosing context is Ghost.\n\t* sem_ch12.adb (Analyze_Generic_Package_Declaration,\n\tAnalyze_Generic_Subprogram_Declaration): Mark an exception as\n\tGhost when its enclosing context is Ghost.\n\t(Preanalyze_Actuals): Remove obsolete check.\n\t* sem_ch13.adb (Analyze_Aspect_Specifications): Add processing\n\tfor aspect Ghost.\n\t(Check_Aspect_At_Freeze_Point): Aspects\n\tDepends and Global do no need special checking at freeze point.\n\t(Insert_After_SPARK_Mode): Update comment on usage.\n\t* sem_mech.adb (Set_Mechanisms): Remove the entry for convention Ghost.\n\t* sem_prag.adb Add an entry for pragma Ghost in table Sig_Flags.\n\t(Analyze_Abstract_State): Update the grammar of the pragma. Add\n\tformal parameter Pack_Id along with comment on usage. Mark an\n\tabstract state as Ghost when its enclosing context is Ghost. Add\n\tprocessing for option Ghost.\n\t(Analyze_Constituent): Verify\n\tthat a Ghost abstract state is refined by Ghost constituents.\n\t(Analyze_Pragma): \"Ghost\" is now a valid policy. Add checks\n\trelated to the use and placement of Check_Policy Ghost. Add\n\tprocessing for pragma Ghost.\n\t(Check_Ghost_Constituent): New routine.\n\t(Is_Valid_Assertion_Kind): \"Ghost\" is now a valid assertion.\n\t(Process_Convention): Remove obsolete check.\n\t(Set_Convention_From_Pragma): Remove the processing for convention\n\tGhost.\n\t* sem_res.adb (Check_Ghost_Context): New routine.\n\t(Resolve_Call): Verify that a reference to a Ghost entity appears in a\n\tsuitable context. Verify the Ghost polity between point of declaration\n\tand point of use.\n\t(Resolve_Entity_Name): Verify that a reference to\n\ta Ghost entity appears in a suitable context. Verify the Ghost\n\tpolity between point of declaration and point of use.\n\t* sem_util.adb (Check_Ghost_Completion): New routine.\n\t(Check_Ghost_Derivation): New routine.\n\t(Incomplete_Or_Partial_View): New routine.\n\t(Incomplete_Or_Private_View): Removed.\n\t(Is_Ghost_Entity): New routine.\n\t(Is_Ghost_Statement_Or_Pragma): New routine.\n\t(Is_Subject_To_Ghost): New routine.\n\t(Policy_In_Effect): New routine.\n\t(Set_Is_Ghost_Entity): New routine.\n\t(Within_Ghost_Scope): New routine.\n\t* sem_util.ads (Check_Ghost_Completion): New routine.\n\t(Check_Ghost_Derivation): New routine.\n\t(Incomplete_Or_Partial_View): New routine.\n\t(Incomplete_Or_Private_View): Removed.\n\t(Is_Ghost_Entity): New routine.\n\t(Is_Ghost_Statement_Or_Pragma): New routine.\n\t(Is_Subject_To_Ghost): New routine.\n\t(Policy_In_Effect): New routine.\n\t(Set_Is_Ghost_Entity): New routine.\n\t(Within_Ghost_Scope): New routine.\n\t* snames.adb-tmpl (Get_Convention_Id): Remove the entry for\n\tconvention Ghost.\n\t(Get_Convention_Name): Remove the entry for convention Ghost.\n\t* snames.ads-tmpl Remove the convention id for Ghost. Add a\n\tpragma id for Ghost.\n\n2014-10-31  Sergey Rybin  <rybin@adacore.com frybin>\n\n\t* gnat_ugn.texi: Add description of --RTS option for ASIS tools.\n\nFrom-SVN: r216981", "tree": {"sha": "636aa165c396f5df62a1398f50e4e2f8c434337b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/636aa165c396f5df62a1398f50e4e2f8c434337b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/comments", "author": null, "committer": null, "parents": [{"sha": "51a054353d7e1db425ea7d3e01c2b150b19e9694", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51a054353d7e1db425ea7d3e01c2b150b19e9694", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51a054353d7e1db425ea7d3e01c2b150b19e9694"}], "stats": {"total": 2378, "additions": 1873, "deletions": 505}, "files": [{"sha": "1a12ce3f451bc6b613c703531d884a3f95777895", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c", "patch": "@@ -1,3 +1,155 @@\n+2014-10-31  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* aspects.adb Add an entry for aspect Ghost in table\n+\tCanonical_Aspect.\n+\t* aspects.ads Add an entry for aspect Ghost in tables\n+\tAspect_Argument, Aspect_Delay, Aspect_Id, Aspect_Names and\n+\tImplementation_Defined_Aspect.\n+\t* einfo.adb: Flags 277 and 278 are now in use.\n+\t(Is_Checked_Ghost_Entity): New routine.\n+\t(Is_Ghost_Entity): Removed.\n+\t(Is_Ghost_Subprogram): Removed.\n+\t(Is_Ignored_Ghost_Entity): New routine.\n+\t(Set_Is_Checked_Ghost_Entity): New routine.\n+\t(Set_Is_Ignored_Ghost_Entity): New routine.\n+\t(Write_Entity_Flags): Output flags Is_Checked_Ghost_Entity and\n+\tIs_Ignored_Ghost_Entity.\n+\t* einfo.ads: Add new flags Is_Checked_Ghost_Entity\n+\tand Is_Ignored_Ghost_Entity along with usage in nodes.\n+\t(Is_Checked_Ghost_Entity): New routine and pragma Inline.\n+\t(Is_Ghost_Entity): Removed along with synthesized flag\n+\tdescription and usage in nodes.\n+\t(Is_Ghost_Subprogram): Removed along with synthesized flag description\n+\tand usage in nodes.\n+\t(Is_Ignored_Ghost_Entity): New routine and pragma Inline.\n+\t(Set_Is_Checked_Ghost_Entity): New routine and pragma Inline.\n+\t(Set_Is_Ignored_Ghost_Entity): New routine and pragma Inline.\n+\t* freeze.adb (Freeze_Entity): A Ghost type cannot be effectively\n+\tvolatile.\n+\t* par-prag.adb Pragma Ghost does not need special handling by\n+\tthe parser.\n+\t* repinfo.adb (List_Mechanisms): Remove the entry for convention Ghost.\n+\t* sem_attr.adb (Analyze_Access_Attribute): Remove obsolete check.\n+\t* sem_ch3.adb (Analyze_Full_Type_Declaration): Mark\n+\tthe type as Ghost when its enclosing context is Ghost.\n+\t(Analyze_Incomplete_Type_Decl): Mark the type as Ghost when\n+\tits enclosing context is Ghost.\n+\t(Analyze_Number_Declaration): Mark the number as Ghost when its\n+\tenclosing context is Ghost.\n+\t(Analyze_Object_Declaration): Mark the object as Ghost when its\n+\tenclosing context is Ghost. Verify the Ghost policy between\n+\tinitial declaration and completion of a deferred constant.\n+\t(Analyze_Object_Contract): A Ghost variable cannot be effectively\n+\tvolatile, imported or exported.\n+\t(Build_Derived_Record_Type): Mark a type extension as Ghost when it\n+\timplements a Ghost interface.\n+\t(Build_Record_Type): Inherit volatility and \"ghostness\" from\n+\tthe parent type.\n+\t(Check_Completion): A Ghost entity declared\n+\tin a non-Ghost package does not require completion in a body.\n+\t(Implements_Ghost_Interface): New routine.\n+\t(Process_Full_View): Inherit \"ghostness\" from the partial view. Verify\n+\tthe Ghost policy between the partial and full views. Verify the\n+\tcompletion of a Ghost type extension.\n+\t* sem_ch4.adb (Check_Ghost_Subprogram_Call): Removed.\n+\t* sem_ch5.adb (Analyze_Assignment): Analyze the left hand side first.\n+\t* sem_ch6.adb (Analyze_Abstract_Subprogram_Declaration): Mark\n+\tthe subprogram as Ghost when its enclosing context is Ghost.\n+\t(Analyze_Generic_Subprogram_Body): Mark the generic body as Ghost\n+\twhen its enclosing context is Ghost. Verify the Ghost policy\n+\tbetween the spec and body.\n+\t(Analyze_Subprogram_Body_Helper): Mark the body as Ghost when its\n+\tenclosing context is Ghost. Verify the Ghost policy between the spec\n+\tand body.\n+\t(Check_Conformance): A Ghost subprogram profile and a non-Ghost\n+\tsubprogram profile are not subtype conformant.\n+\t(Convention_Of): Removed.\n+\t* sem_ch7.adb (Analyze_Package_Body_Helper): Inherit the\n+\t\"ghostness\" from the spec. Verify the Ghost policy between\n+\tthe spec and body.\n+\t(Analyze_Private_Type_Declaration): Mark the type as Ghost when its\n+\tenclosing context is Ghost.\n+\t(Requires_Completion_In_Body): New routine.\n+\t(Unit_Requires_Body): Use Requires_Completion_In_Body.\n+\t(Unit_Requires_Body_Info): Rename formal parameter P to Pack_Id, update\n+\tcomment on usage and all uses of P in the body. Use\n+\tRequires_Completion_In_Body.\n+\t* sem_ch7.ads (Unit_Requires_Body): Rename formal parameter P\n+\tto Pack_Id, update comment on usage and all uses of P in the body.\n+\t* sem_ch8.adb (Analyze_Exception_Renaming): Inherit the \"ghostness\"\n+\tfrom the renamed excention.\n+\t(Analyze_Generic_Renaming): Inherit the \"ghostness\" from the\n+\trenamed generic subprogram.\n+\t(Analyze_Object_Renaming): Inherit the \"ghostness\" from the renamed\n+\tobject.\n+\t(Analyze_Package_Renaming): Inherit the \"ghostness\" from the\n+\trenamed package.\n+\t(Analyze_Subprogram_Renaming): Inherit the \"ghostness\" from the\n+\trenamed subprogram.\n+\t* sem_ch11.adb (Analyze_Exception_Declaration): Mark an exception\n+\tas Ghost when its enclosing context is Ghost.\n+\t* sem_ch12.adb (Analyze_Generic_Package_Declaration,\n+\tAnalyze_Generic_Subprogram_Declaration): Mark an exception as\n+\tGhost when its enclosing context is Ghost.\n+\t(Preanalyze_Actuals): Remove obsolete check.\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications): Add processing\n+\tfor aspect Ghost.\n+\t(Check_Aspect_At_Freeze_Point): Aspects\n+\tDepends and Global do no need special checking at freeze point.\n+\t(Insert_After_SPARK_Mode): Update comment on usage.\n+\t* sem_mech.adb (Set_Mechanisms): Remove the entry for convention Ghost.\n+\t* sem_prag.adb Add an entry for pragma Ghost in table Sig_Flags.\n+\t(Analyze_Abstract_State): Update the grammar of the pragma. Add\n+\tformal parameter Pack_Id along with comment on usage. Mark an\n+\tabstract state as Ghost when its enclosing context is Ghost. Add\n+\tprocessing for option Ghost.\n+\t(Analyze_Constituent): Verify\n+\tthat a Ghost abstract state is refined by Ghost constituents.\n+\t(Analyze_Pragma): \"Ghost\" is now a valid policy. Add checks\n+\trelated to the use and placement of Check_Policy Ghost. Add\n+\tprocessing for pragma Ghost.\n+\t(Check_Ghost_Constituent): New routine.\n+\t(Is_Valid_Assertion_Kind): \"Ghost\" is now a valid assertion.\n+\t(Process_Convention): Remove obsolete check.\n+\t(Set_Convention_From_Pragma): Remove the processing for convention\n+\tGhost.\n+\t* sem_res.adb (Check_Ghost_Context): New routine.\n+\t(Resolve_Call): Verify that a reference to a Ghost entity appears in a\n+\tsuitable context. Verify the Ghost polity between point of declaration\n+\tand point of use.\n+\t(Resolve_Entity_Name): Verify that a reference to\n+\ta Ghost entity appears in a suitable context. Verify the Ghost\n+\tpolity between point of declaration and point of use.\n+\t* sem_util.adb (Check_Ghost_Completion): New routine.\n+\t(Check_Ghost_Derivation): New routine.\n+\t(Incomplete_Or_Partial_View): New routine.\n+\t(Incomplete_Or_Private_View): Removed.\n+\t(Is_Ghost_Entity): New routine.\n+\t(Is_Ghost_Statement_Or_Pragma): New routine.\n+\t(Is_Subject_To_Ghost): New routine.\n+\t(Policy_In_Effect): New routine.\n+\t(Set_Is_Ghost_Entity): New routine.\n+\t(Within_Ghost_Scope): New routine.\n+\t* sem_util.ads (Check_Ghost_Completion): New routine.\n+\t(Check_Ghost_Derivation): New routine.\n+\t(Incomplete_Or_Partial_View): New routine.\n+\t(Incomplete_Or_Private_View): Removed.\n+\t(Is_Ghost_Entity): New routine.\n+\t(Is_Ghost_Statement_Or_Pragma): New routine.\n+\t(Is_Subject_To_Ghost): New routine.\n+\t(Policy_In_Effect): New routine.\n+\t(Set_Is_Ghost_Entity): New routine.\n+\t(Within_Ghost_Scope): New routine.\n+\t* snames.adb-tmpl (Get_Convention_Id): Remove the entry for\n+\tconvention Ghost.\n+\t(Get_Convention_Name): Remove the entry for convention Ghost.\n+\t* snames.ads-tmpl Remove the convention id for Ghost. Add a\n+\tpragma id for Ghost.\n+\n+2014-10-31  Sergey Rybin  <rybin@adacore.com frybin>\n+\n+\t* gnat_ugn.texi: Add description of --RTS option for ASIS tools.\n+\n 2014-10-31  Olivier Hainque  <hainque@adacore.com>\n \n \t* gcc-interface/Makefile.in (arm-vxworks): Update target pairs."}, {"sha": "19e49b52220f3a7641877c39273bd00690852143", "filename": "gcc/ada/aspects.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2Faspects.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2Faspects.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.adb?ref=c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c", "patch": "@@ -527,6 +527,7 @@ package body Aspects is\n     Aspect_External_Name                => Aspect_External_Name,\n     Aspect_External_Tag                 => Aspect_External_Tag,\n     Aspect_Favor_Top_Level              => Aspect_Favor_Top_Level,\n+    Aspect_Ghost                        => Aspect_Ghost,\n     Aspect_Global                       => Aspect_Global,\n     Aspect_Implicit_Dereference         => Aspect_Implicit_Dereference,\n     Aspect_Import                       => Aspect_Import,"}, {"sha": "0e01beba7a2c67acffc42f2ae10f5deae2a63e8d", "filename": "gcc/ada/aspects.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2Faspects.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2Faspects.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.ads?ref=c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c", "patch": "@@ -98,6 +98,7 @@ package Aspects is\n       Aspect_Extensions_Visible,            -- GNAT\n       Aspect_External_Name,\n       Aspect_External_Tag,\n+      Aspect_Ghost,                         -- GNAT\n       Aspect_Global,                        -- GNAT\n       Aspect_Implicit_Dereference,\n       Aspect_Initial_Condition,             -- GNAT\n@@ -234,6 +235,7 @@ package Aspects is\n       Aspect_Effective_Writes         => True,\n       Aspect_Extensions_Visible       => True,\n       Aspect_Favor_Top_Level          => True,\n+      Aspect_Ghost                    => True,\n       Aspect_Global                   => True,\n       Aspect_Inline_Always            => True,\n       Aspect_Invariant                => True,\n@@ -325,6 +327,7 @@ package Aspects is\n       Aspect_Extensions_Visible        => Optional_Expression,\n       Aspect_External_Name             => Expression,\n       Aspect_External_Tag              => Expression,\n+      Aspect_Ghost                     => Optional_Expression,\n       Aspect_Global                    => Expression,\n       Aspect_Implicit_Dereference      => Name,\n       Aspect_Initial_Condition         => Expression,\n@@ -419,6 +422,7 @@ package Aspects is\n       Aspect_External_Name                => Name_External_Name,\n       Aspect_External_Tag                 => Name_External_Tag,\n       Aspect_Favor_Top_Level              => Name_Favor_Top_Level,\n+      Aspect_Ghost                        => Name_Ghost,\n       Aspect_Global                       => Name_Global,\n       Aspect_Implicit_Dereference         => Name_Implicit_Dereference,\n       Aspect_Import                       => Name_Import,\n@@ -698,6 +702,7 @@ package Aspects is\n       Aspect_Effective_Reads              => Never_Delay,\n       Aspect_Effective_Writes             => Never_Delay,\n       Aspect_Extensions_Visible           => Never_Delay,\n+      Aspect_Ghost                        => Never_Delay,\n       Aspect_Global                       => Never_Delay,\n       Aspect_Initial_Condition            => Never_Delay,\n       Aspect_Initializes                  => Never_Delay,"}, {"sha": "53ba3db919344d448d4bb34c91ba4e53745cdd92", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 47, "deletions": 36, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c", "patch": "@@ -569,15 +569,12 @@ package body Einfo is\n    --    (Has_Protected)                 Flag271\n    --    (SSO_Set_Low_By_Default)        Flag272\n    --    (SSO_Set_High_By_Default)       Flag273\n-\n    --    Is_Generic_Actual_Subprogram    Flag274\n    --    No_Predicate_On_Actual          Flag275\n    --    No_Dynamic_Predicate_On_Actual  Flag276\n+   --    Is_Checked_Ghost_Entity         Flag277\n+   --    Is_Ignored_Ghost_Entity         Flag278\n \n-   --    (unused)                        Flag275\n-   --    (unused)                        Flag276\n-   --    (unused)                        Flag277\n-   --    (unused)                        Flag278\n    --    (unused)                        Flag279\n    --    (unused)                        Flag280\n \n@@ -1926,6 +1923,12 @@ package body Einfo is\n       return Flag63 (Id);\n    end Is_Character_Type;\n \n+   function Is_Checked_Ghost_Entity (Id : E) return B is\n+   begin\n+      pragma Assert (Nkind (Id) in N_Entity);\n+      return Flag277 (Id);\n+   end Is_Checked_Ghost_Entity;\n+\n    function Is_Child_Unit (Id : E) return B is\n    begin\n       return Flag73 (Id);\n@@ -2090,6 +2093,12 @@ package body Einfo is\n       return Flag171 (Id);\n    end Is_Hidden_Open_Scope;\n \n+   function Is_Ignored_Ghost_Entity (Id : E) return B is\n+   begin\n+      pragma Assert (Nkind (Id) in N_Entity);\n+      return Flag278 (Id);\n+   end Is_Ignored_Ghost_Entity;\n+\n    function Is_Immediately_Visible (Id : E) return B is\n    begin\n       pragma Assert (Nkind (Id) in N_Entity);\n@@ -4729,6 +4738,21 @@ package body Einfo is\n       Set_Flag63 (Id, V);\n    end Set_Is_Character_Type;\n \n+   procedure Set_Is_Checked_Ghost_Entity (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Is_Formal (Id)\n+        or else Is_Object (Id)\n+        or else Is_Package_Or_Generic_Package (Id)\n+        or else Is_Subprogram_Or_Generic_Subprogram (Id)\n+        or else Is_Type (Id)\n+        or else Ekind (Id) = E_Abstract_State\n+        or else Ekind (Id) = E_Component\n+        or else Ekind (Id) = E_Discriminant\n+        or else Ekind (Id) = E_Package_Body\n+        or else Ekind (Id) = E_Subprogram_Body);\n+      Set_Flag277 (Id, V);\n+   end Set_Is_Checked_Ghost_Entity;\n+\n    procedure Set_Is_Child_Unit (Id : E; V : B := True) is\n    begin\n       Set_Flag73 (Id, V);\n@@ -4871,7 +4895,7 @@ package body Einfo is\n \n    procedure Set_Is_Generic_Actual_Subprogram (Id : E; V : B := True) is\n    begin\n-      pragma Assert (Ekind (Id) = E_Function or else Ekind (Id) = E_Procedure);\n+      pragma Assert (Ekind_In (Id, E_Function, E_Procedure));\n       Set_Flag274 (Id, V);\n    end Set_Is_Generic_Actual_Subprogram;\n \n@@ -4908,6 +4932,21 @@ package body Einfo is\n       Set_Flag171 (Id, V);\n    end Set_Is_Hidden_Open_Scope;\n \n+   procedure Set_Is_Ignored_Ghost_Entity (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Is_Formal (Id)\n+        or else Is_Object (Id)\n+        or else Is_Package_Or_Generic_Package (Id)\n+        or else Is_Subprogram_Or_Generic_Subprogram (Id)\n+        or else Is_Type (Id)\n+        or else Ekind (Id) = E_Abstract_State\n+        or else Ekind (Id) = E_Component\n+        or else Ekind (Id) = E_Discriminant\n+        or else Ekind (Id) = E_Package_Body\n+        or else Ekind (Id) = E_Subprogram_Body);\n+      Set_Flag278 (Id, V);\n+   end Set_Is_Ignored_Ghost_Entity;\n+\n    procedure Set_Is_Immediately_Visible (Id : E; V : B := True) is\n    begin\n       pragma Assert (Nkind (Id) in N_Entity);\n@@ -7156,36 +7195,6 @@ package body Einfo is\n       return Ekind (Id) = E_Procedure and then Chars (Id) = Name_uFinalizer;\n    end Is_Finalizer;\n \n-   ---------------------\n-   -- Is_Ghost_Entity --\n-   ---------------------\n-\n-   --  Note: coding below allows for ghost variables. They are not currently\n-   --  implemented, so we will always get False for variables, but that is\n-   --  expected to change in the future.\n-\n-   function Is_Ghost_Entity (Id : E) return B is\n-   begin\n-      if Present (Id) and then Ekind (Id) = E_Variable then\n-         return Convention (Id) = Convention_Ghost;\n-      else\n-         return Is_Ghost_Subprogram (Id);\n-      end if;\n-   end Is_Ghost_Entity;\n-\n-   -------------------------\n-   -- Is_Ghost_Subprogram --\n-   -------------------------\n-\n-   function Is_Ghost_Subprogram (Id : E) return B is\n-   begin\n-      if Present (Id) and then Ekind_In (Id, E_Function, E_Procedure) then\n-         return Convention (Id) = Convention_Ghost;\n-      else\n-         return False;\n-      end if;\n-   end Is_Ghost_Subprogram;\n-\n    -------------------\n    -- Is_Null_State --\n    -------------------\n@@ -8479,6 +8488,7 @@ package body Einfo is\n       W (\"Is_CPP_Class\",                    Flag74  (Id));\n       W (\"Is_Called\",                       Flag102 (Id));\n       W (\"Is_Character_Type\",               Flag63  (Id));\n+      W (\"Is_Checked_Ghost_Entity\",         Flag277 (Id));\n       W (\"Is_Child_Unit\",                   Flag73  (Id));\n       W (\"Is_Class_Wide_Equivalent_Type\",   Flag35  (Id));\n       W (\"Is_Compilation_Unit\",             Flag149 (Id));\n@@ -8510,6 +8520,7 @@ package body Einfo is\n       W (\"Is_Hidden\",                       Flag57  (Id));\n       W (\"Is_Hidden_Non_Overridden_Subpgm\", Flag2   (Id));\n       W (\"Is_Hidden_Open_Scope\",            Flag171 (Id));\n+      W (\"Is_Ignored_Ghost_Entity\",         Flag278 (Id));\n       W (\"Is_Immediately_Visible\",          Flag7   (Id));\n       W (\"Is_Implementation_Defined\",       Flag254 (Id));\n       W (\"Is_Imported\",                     Flag24  (Id));"}, {"sha": "d20624dd07abc5490ec11226c25cbe2f32733470", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c", "patch": "@@ -2188,6 +2188,13 @@ package Einfo is\n --       Defined in all entities. Set for character types and subtypes,\n --       i.e. enumeration types that have at least one character literal.\n \n+--    Is_Checked_Ghost_Entity (Flag277)\n+--       Applies to all entities. Set for abstract states, [generic] packages,\n+--       [generic] subprograms, components, discriminants, formal parameters,\n+--       objects, package bodies, subprogram bodies, and [sub]types subject to\n+--       pragma Ghost or inherit \"ghostness\" from an enclosing construct, and\n+--       subject to Assertion_Policy Ghost => Check.\n+\n --    Is_Child_Unit (Flag73)\n --       Defined in all entities. Set only for defining entities of program\n --       units that are child units (but False for subunits).\n@@ -2425,18 +2432,6 @@ package Einfo is\n --       package, generic function, generic procedure), and False for all\n --       other entities.\n \n---    Is_Ghost_Entity (synthesized)\n---       Applies to all entities. Yields True for a subprogram or a whole\n---       object that has convention Ghost. For now only functions can have\n---       Ghost convention, so this will be false for other than functions,\n---       but we expect that to change in the future.\n-\n---    Is_Ghost_Subprogram (synthesized)\n---       Applies to all entities. Yields True for a subprogram that has a Ghost\n---       convention. Note: for now, only ghost functions are allowed, so this\n---       will always be false for procedures, but that is expected to change in\n---       the future.\n-\n --    Is_Hidden (Flag57)\n --       Defined in all entities. Set for all entities declared in the\n --       private part or body of a package. Also marks generic formals of a\n@@ -2458,6 +2453,13 @@ package Einfo is\n --       instantiation of a child unit, and whose entities are not visible\n --       during analysis of the instance.\n \n+--    Is_Ignored_Ghost_Entity (Flag278)\n+--       Applies to all entities. Set for abstract states, [generic] packages,\n+--       [generic] subprograms, components, discriminants, formal parameters,\n+--       objects, package bodies, subprogram bodies, and [sub]types subject to\n+--       pragma Ghost or inherit \"ghostness\" from an enclosing construct, and\n+--       subject to Assertion_Policy Ghost => Ignore.\n+\n --    Is_Immediately_Visible (Flag7)\n --       Defined in all entities. Set if entity is immediately visible, i.e.\n --       is defined in some currently open scope (RM 8.3(4)).\n@@ -5178,6 +5180,7 @@ package Einfo is\n    --    Is_Bit_Packed_Array                 (Flag122)  (base type only)\n    --    Is_Aliased                          (Flag15)\n    --    Is_Character_Type                   (Flag63)\n+   --    Is_Checked_Ghost_Entity             (Flag277)\n    --    Is_Child_Unit                       (Flag73)\n    --    Is_Compilation_Unit                 (Flag149)\n    --    Is_Completely_Hidden                (Flag103)\n@@ -5194,6 +5197,7 @@ package Einfo is\n    --    Is_Generic_Type                     (Flag13)\n    --    Is_Hidden                           (Flag57)\n    --    Is_Hidden_Open_Scope                (Flag171)\n+   --    Is_Ignored_Ghost_Entity             (Flag278)\n    --    Is_Immediately_Visible              (Flag7)\n    --    Is_Implementation_Defined           (Flag254)\n    --    Is_Imported                         (Flag24)\n@@ -5740,8 +5744,6 @@ package Einfo is\n    --    Address_Clause                      (synth)\n    --    First_Formal                        (synth)\n    --    First_Formal_With_Extras            (synth)\n-   --    Is_Ghost_Entity                     (synth)    (non-generic case only)\n-   --    Is_Ghost_Subprogram                 (synth)    (non-generic case only)\n    --    Last_Formal                         (synth)\n    --    Number_Formals                      (synth)\n    --    Scope_Depth                         (synth)\n@@ -6037,8 +6039,6 @@ package Einfo is\n    --    First_Formal                        (synth)\n    --    First_Formal_With_Extras            (synth)\n    --    Is_Finalizer                        (synth)\n-   --    Is_Ghost_Entity                     (synth)    (non-generic case only)\n-   --    Is_Ghost_Subprogram                 (synth)    (non-generic case only)\n    --    Last_Formal                         (synth)\n    --    Number_Formals                      (synth)\n \n@@ -6249,7 +6249,6 @@ package Einfo is\n    --    Treat_As_Volatile                   (Flag41)\n    --    Address_Clause                      (synth)\n    --    Alignment_Clause                    (synth)\n-   --    Is_Ghost_Entity                     (synth)\n    --    Size_Clause                         (synth)\n \n    --  E_Void\n@@ -6704,6 +6703,7 @@ package Einfo is\n    function Is_CPP_Class                        (Id : E) return B;\n    function Is_Called                           (Id : E) return B;\n    function Is_Character_Type                   (Id : E) return B;\n+   function Is_Checked_Ghost_Entity             (Id : E) return B;\n    function Is_Child_Unit                       (Id : E) return B;\n    function Is_Class_Wide_Equivalent_Type       (Id : E) return B;\n    function Is_Compilation_Unit                 (Id : E) return B;\n@@ -6730,6 +6730,7 @@ package Einfo is\n    function Is_Hidden                           (Id : E) return B;\n    function Is_Hidden_Non_Overridden_Subpgm     (Id : E) return B;\n    function Is_Hidden_Open_Scope                (Id : E) return B;\n+   function Is_Ignored_Ghost_Entity             (Id : E) return B;\n    function Is_Immediately_Visible              (Id : E) return B;\n    function Is_Implementation_Defined           (Id : E) return B;\n    function Is_Imported                         (Id : E) return B;\n@@ -7012,8 +7013,6 @@ package Einfo is\n    function Is_Dynamic_Scope                    (Id : E) return B;\n    function Is_External_State                   (Id : E) return B;\n    function Is_Finalizer                        (Id : E) return B;\n-   function Is_Ghost_Entity                     (Id : E) return B;\n-   function Is_Ghost_Subprogram                 (Id : E) return B;\n    function Is_Null_State                       (Id : E) return B;\n    function Is_Package_Or_Generic_Package       (Id : E) return B;\n    function Is_Packed_Array                     (Id : E) return B;\n@@ -7343,6 +7342,7 @@ package Einfo is\n    procedure Set_Is_CPP_Class                    (Id : E; V : B := True);\n    procedure Set_Is_Called                       (Id : E; V : B := True);\n    procedure Set_Is_Character_Type               (Id : E; V : B := True);\n+   procedure Set_Is_Checked_Ghost_Entity         (Id : E; V : B := True);\n    procedure Set_Is_Child_Unit                   (Id : E; V : B := True);\n    procedure Set_Is_Class_Wide_Equivalent_Type   (Id : E; V : B := True);\n    procedure Set_Is_Compilation_Unit             (Id : E; V : B := True);\n@@ -7374,6 +7374,7 @@ package Einfo is\n    procedure Set_Is_Hidden                       (Id : E; V : B := True);\n    procedure Set_Is_Hidden_Non_Overridden_Subpgm (Id : E; V : B := True);\n    procedure Set_Is_Hidden_Open_Scope            (Id : E; V : B := True);\n+   procedure Set_Is_Ignored_Ghost_Entity         (Id : E; V : B := True);\n    procedure Set_Is_Immediately_Visible          (Id : E; V : B := True);\n    procedure Set_Is_Implementation_Defined       (Id : E; V : B := True);\n    procedure Set_Is_Imported                     (Id : E; V : B := True);\n@@ -8101,6 +8102,7 @@ package Einfo is\n    pragma Inline (Is_CPP_Class);\n    pragma Inline (Is_Called);\n    pragma Inline (Is_Character_Type);\n+   pragma Inline (Is_Checked_Ghost_Entity);\n    pragma Inline (Is_Child_Unit);\n    pragma Inline (Is_Class_Wide_Equivalent_Type);\n    pragma Inline (Is_Class_Wide_Type);\n@@ -8149,6 +8151,7 @@ package Einfo is\n    pragma Inline (Is_Hidden);\n    pragma Inline (Is_Hidden_Non_Overridden_Subpgm);\n    pragma Inline (Is_Hidden_Open_Scope);\n+   pragma Inline (Is_Ignored_Ghost_Entity);\n    pragma Inline (Is_Immediately_Visible);\n    pragma Inline (Is_Implementation_Defined);\n    pragma Inline (Is_Imported);\n@@ -8580,6 +8583,7 @@ package Einfo is\n    pragma Inline (Set_Is_CPP_Class);\n    pragma Inline (Set_Is_Called);\n    pragma Inline (Set_Is_Character_Type);\n+   pragma Inline (Set_Is_Checked_Ghost_Entity);\n    pragma Inline (Set_Is_Child_Unit);\n    pragma Inline (Set_Is_Class_Wide_Equivalent_Type);\n    pragma Inline (Set_Is_Compilation_Unit);\n@@ -8611,6 +8615,7 @@ package Einfo is\n    pragma Inline (Set_Is_Hidden);\n    pragma Inline (Set_Is_Hidden_Non_Overridden_Subpgm);\n    pragma Inline (Set_Is_Hidden_Open_Scope);\n+   pragma Inline (Set_Is_Ignored_Ghost_Entity);\n    pragma Inline (Set_Is_Immediately_Visible);\n    pragma Inline (Set_Is_Implementation_Defined);\n    pragma Inline (Set_Is_Imported);"}, {"sha": "2079271eae15be10bc2e976e4e9751428984061c", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c", "patch": "@@ -4815,6 +4815,14 @@ package body Freeze is\n             end if;\n          end;\n \n+         --  A Ghost type cannot be effectively volatile (SPARK RM 6.9(8))\n+\n+         if Is_Ghost_Entity (E)\n+           and then Is_Effectively_Volatile (E)\n+         then\n+            SPARK_Msg_N (\"ghost type & cannot be volatile\", E);\n+         end if;\n+\n          --  Deal with special cases of freezing for subtype\n \n          if E /= Base_Type (E) then"}, {"sha": "1da339ad38fa1e9b4c62939b7436df5dced476c3", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 29, "deletions": 3, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c", "patch": "@@ -10942,6 +10942,11 @@ Indicates that external variable @var{name} in the argument project\n has the value @var{value}. Has no effect if no project is specified as\n tool argument.\n \n+@item --RTS=@var{rts-path}\n+@cindex @option{--RTS} (@command{gnatelim})\n+Specifies the default location of the runtime library. Same meaning as the\n+equivalent @command{gnatmake} flag (@pxref{Switches for gnatmake}).\n+\n @item -files=@var{filename}\n @cindex @option{-files} (@code{gnatelim})\n Take the argument source files from the specified file. This file should be an\n@@ -13998,9 +14003,6 @@ uses the same switches as the GNAT compiler, with the same effects:\n @item -gnatec=@var{path}\n @cindex @option{-gnatec} (@command{gnatpp})\n \n-@item --RTS=@var{path}\n-@cindex @option{--RTS} (@command{gnatpp})\n-\n @end table\n \n @node Output File Control\n@@ -14148,6 +14150,11 @@ Indicates that external variable @var{name} in the argument project\n has the value @var{value}. Has no effect if no project is specified as\n tool argument.\n \n+@item --RTS=@var{rts-path}\n+@cindex @option{--RTS} (@command{gnatpp})\n+Specifies the default location of the runtime library. Same meaning as the\n+equivalent @command{gnatmake} flag (@pxref{Switches for gnatmake}).\n+\n @item --incremental\n @cindex @option{--incremental} @command{gnatpp}\n Incremental processing on a per-file basis. Source files are only\n@@ -14586,6 +14593,10 @@ options:\n       the argument project has the value @var{value}. Has no effect if no\n       project is specified as tool argument.\n \n+--RTS=@var{rts-path}  -- Specifies the default location of the runtime\n+      library. Same meaning as the equivalent @command{gnatmake} flag\n+      (@pxref{Switches for gnatmake}).\n+\n --incremental -- incremental processing on a per-file basis. Source files are\n       only processed if they have been modified, or if files they depend\n       on have been modified. This is similar to the way gnatmake/gprbuild\n@@ -15939,6 +15950,11 @@ Indicates that external variable @var{name} in the argument project\n has the value @var{value}. Has no effect if no project is specified as\n tool argument.\n \n+@item --RTS=@var{rts-path}\n+@cindex @option{--RTS} (@command{gnatmetric})\n+Specifies the default location of the runtime library. Same meaning as the\n+equivalent @command{gnatmake} flag (@pxref{Switches for gnatmake}).\n+\n @item --subdirs=@var{dir}\n @cindex @option{--subdirs=@var{dir}} @command{gnatmetric}\n Use the specified subdirectory of the project objects file (or of the\n@@ -18763,6 +18779,11 @@ Indicates that external variable @var{name} in the argument project\n has the value @var{value}. Has no effect if no project is specified as\n tool argument.\n \n+@item --RTS=@var{rts-path}\n+@cindex @option{--RTS} (@command{gnatstub})\n+Specifies the default location of the runtime library. Same meaning as the\n+equivalent @command{gnatmake} flag (@pxref{Switches for gnatmake}).\n+\n @item --subunits\n @cindex @option{--subunits} (@command{gnatstub})\n Generate subunits for body stubs. If this switch is specified,\n@@ -19066,6 +19087,11 @@ Recursively consider all sources from all projects.\n @cindex @option{-X} (@command{gnattest})\n Indicate that external variable @var{name} has the value @var{value}.\n \n+@item --RTS=@var{rts-path}\n+@cindex @option{--RTS} (@command{gnattest})\n+Specifies the default location of the runtime library. Same meaning as the\n+equivalent @command{gnatmake} flag (@pxref{Switches for gnatmake}).\n+\n @item -q\n @cindex @option{-q} (@command{gnattest})\n Suppresses noncritical output messages."}, {"sha": "93cbf94cadbe2ba3fe39f3f72b2747136bdc1c2c", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c", "patch": "@@ -1226,6 +1226,7 @@ begin\n            Pragma_Favor_Top_Level                |\n            Pragma_Fast_Math                      |\n            Pragma_Finalize_Storage_Only          |\n+           Pragma_Ghost                          |\n            Pragma_Global                         |\n            Pragma_Ident                          |\n            Pragma_Implementation_Defined         |"}, {"sha": "d6f3dde734971dcc06cb374732c1e9dfbff81559", "filename": "gcc/ada/repinfo.adb", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2Frepinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2Frepinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frepinfo.adb?ref=c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c", "patch": "@@ -720,8 +720,6 @@ package body Repinfo is\n             Write_Line (\"Intrinsic\");\n          when Convention_Entry                 =>\n             Write_Line (\"Entry\");\n-         when Convention_Ghost                 =>\n-            Write_Line (\"Ghost\");\n          when Convention_Protected             =>\n             Write_Line (\"Protected\");\n          when Convention_Assembler             =>"}, {"sha": "e80531453b7a35079cb77d8149db894fba23fb10", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c", "patch": "@@ -773,10 +773,6 @@ package body Sem_Attr is\n \n             elsif Aname = Name_Unchecked_Access then\n                Error_Attr (\"attribute% cannot be applied to a subprogram\", P);\n-\n-            elsif Is_Ghost_Subprogram (Entity (P)) then\n-               Error_Attr_P\n-                 (\"prefix of % attribute cannot be a ghost subprogram\");\n             end if;\n \n             --  Issue an error if the prefix denotes an eliminated subprogram"}, {"sha": "2e3dbd9fe87b17d94c720a950dcaadadeaab39ea", "filename": "gcc/ada/sem_ch11.adb", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2Fsem_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2Fsem_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch11.adb?ref=c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c", "patch": "@@ -64,6 +64,13 @@ package body Sem_Ch11 is\n       Set_Is_Statically_Allocated (Id);\n       Set_Is_Pure                 (Id, PF);\n \n+      --  An exception declared within a Ghost scope is automatically Ghost\n+      --  (SPARK RM 6.9(2)).\n+\n+      if Within_Ghost_Scope then\n+         Set_Is_Ghost_Entity (Id);\n+      end if;\n+\n       if Has_Aspects (N) then\n          Analyze_Aspect_Specifications (N, Id);\n       end if;"}, {"sha": "f982359c749b734f23cc2faefb165bb466a13fbf", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c", "patch": "@@ -3380,6 +3380,13 @@ package body Sem_Ch12 is\n       Set_Etype    (Id, Standard_Void_Type);\n       Set_Contract (Id, Make_Contract (Sloc (Id)));\n \n+      --  A generic package declared within a Ghost scope is rendered Ghost\n+      --  (SPARK RM 6.9(2)).\n+\n+      if Within_Ghost_Scope then\n+         Set_Is_Ghost_Entity (Id);\n+      end if;\n+\n       --  Analyze aspects now, so that generated pragmas appear in the\n       --  declarations before building and analyzing the generic copy.\n \n@@ -3580,6 +3587,13 @@ package body Sem_Ch12 is\n          Set_Etype (Id, Standard_Void_Type);\n       end if;\n \n+      --  A generic subprogram declared within a Ghost scope is rendered Ghost\n+      --  (SPARK RM 6.9(2)).\n+\n+      if Within_Ghost_Scope then\n+         Set_Is_Ghost_Entity (Id);\n+      end if;\n+\n       --  For a library unit, we have reconstructed the entity for the unit,\n       --  and must reset it in the library tables. We also make sure that\n       --  Body_Required is set properly in the original compilation unit node.\n@@ -13040,16 +13054,7 @@ package body Sem_Ch12 is\n                Analyze (Act);\n             end if;\n \n-            --  Ensure that a ghost subprogram does not act as generic actual\n-\n-            if Is_Entity_Name (Act)\n-              and then Is_Ghost_Subprogram (Entity (Act))\n-            then\n-               Error_Msg_N\n-                 (\"ghost subprogram & cannot act as generic actual\", Act);\n-               Abandon_Instantiation (Act);\n-\n-            elsif Errs /= Serious_Errors_Detected then\n+            if Errs /= Serious_Errors_Detected then\n \n                --  Do a minimal analysis of the generic, to prevent spurious\n                --  warnings complaining about the generic being unreferenced,"}, {"sha": "da2d6e34d8dfca8832807a4603b00a2a3f8dac58", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 72, "deletions": 32, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c", "patch": "@@ -1188,10 +1188,11 @@ package body Sem_Ch13 is\n         (Prag    : Node_Id;\n          Ins_Nod : Node_Id;\n          Decls   : List_Id);\n-      --  Subsidiary to the analysis of aspects Abstract_State, Initializes,\n-      --  Initial_Condition and Refined_State. Insert node Prag before node\n-      --  Ins_Nod. If Ins_Nod is for pragma SPARK_Mode, then skip SPARK_Mode.\n-      --  Decls is the associated declarative list where Prag is to reside.\n+      --  Subsidiary to the analysis of aspects Abstract_State, Ghost,\n+      --  Initializes, Initial_Condition and Refined_State. Insert node Prag\n+      --  before node Ins_Nod. If Ins_Nod is for pragma SPARK_Mode, then skip\n+      --  SPARK_Mode. Decls is the associated declarative list where Prag is to\n+      --  reside.\n \n       procedure Insert_Pragma (Prag : Node_Id);\n       --  Subsidiary to the analysis of aspects Attach_Handler, Contract_Cases,\n@@ -2190,10 +2191,11 @@ package body Sem_Ch13 is\n                            end loop;\n                         end if;\n \n-                        --  Pragma Abstract_State must be inserted after pragma\n-                        --  SPARK_Mode in the tree. This ensures that any error\n-                        --  messages dependent on SPARK_Mode will be properly\n-                        --  enabled/suppressed.\n+                        --  When aspects Abstract_State, Ghost,\n+                        --  Initial_Condition and Initializes are out of order,\n+                        --  ensure that pragma SPARK_Mode is always at the top\n+                        --  of the declarations to properly enabled/suppress\n+                        --  errors.\n \n                         Insert_After_SPARK_Mode\n                           (Prag    => Aitem,\n@@ -2285,6 +2287,57 @@ package body Sem_Ch13 is\n                   Insert_Pragma (Aitem);\n                   goto Continue;\n \n+               --  Aspect Ghost is never delayed because it is equivalent to a\n+               --  source pragma which appears at the top of [generic] package\n+               --  declarations or after an object, a [generic] subprogram, or\n+               --  a type declaration.\n+\n+               when Aspect_Ghost => Ghost : declare\n+                  Decls : List_Id;\n+\n+               begin\n+                  Make_Aitem_Pragma\n+                    (Pragma_Argument_Associations => New_List (\n+                       Make_Pragma_Argument_Association (Loc,\n+                         Expression => Relocate_Node (Expr))),\n+                     Pragma_Name                  => Name_Ghost);\n+\n+                  Decorate (Aspect, Aitem);\n+\n+                  --  When the aspect applies to a [generic] package, insert\n+                  --  the pragma at the top of the visible declarations. This\n+                  --  emulates the placement of a source pragma.\n+\n+                  if Nkind_In (N, N_Generic_Package_Declaration,\n+                                  N_Package_Declaration)\n+                  then\n+                     Decls := Visible_Declarations (Specification (N));\n+\n+                     if No (Decls) then\n+                        Decls := New_List;\n+                        Set_Visible_Declarations (N, Decls);\n+                     end if;\n+\n+                     --  When aspects Abstract_State, Ghost, Initial_Condition\n+                     --  and Initializes are out of order, ensure that pragma\n+                     --  SPARK_Mode is always at the top of the declarations to\n+                     --  properly enabled/suppress errors.\n+\n+                     Insert_After_SPARK_Mode\n+                       (Prag    => Aitem,\n+                        Ins_Nod => First (Decls),\n+                        Decls   => Decls);\n+\n+                  --  Otherwise the context is an object, [generic] subprogram\n+                  --  or type declaration.\n+\n+                  else\n+                     Insert_Pragma (Aitem);\n+                  end if;\n+\n+                  goto Continue;\n+               end Ghost;\n+\n                --  Global\n \n                --  Aspect Global is never delayed because it is equivalent to\n@@ -2346,10 +2399,10 @@ package body Sem_Ch13 is\n                         Set_Visible_Declarations (Context, Decls);\n                      end if;\n \n-                     --  When aspects Abstract_State, Initial_Condition and\n-                     --  Initializes are out of order, ensure that pragma\n-                     --  SPARK_Mode is always at the top of the declarative\n-                     --  list to properly enable/suppress errors.\n+                     --  When aspects Abstract_State, Ghost, Initial_Condition\n+                     --  and Initializes are out of order, ensure that pragma\n+                     --  SPARK_Mode is always at the top of the declarations to\n+                     --  properly enabled/suppress errors.\n \n                      Insert_After_SPARK_Mode\n                        (Prag    => Aitem,\n@@ -2404,10 +2457,10 @@ package body Sem_Ch13 is\n                         Set_Visible_Declarations (Context, Decls);\n                      end if;\n \n-                     --  When aspects Abstract_State, Initial_Condition and\n-                     --  Initializes are out of order, ensure that pragma\n-                     --  SPARK_Mode is always at the top of the declarative\n-                     --  list to properly enable/suppress errors.\n+                     --  When aspects Abstract_State, Ghost, Initial_Condition\n+                     --  and Initializes are out of order, ensure that pragma\n+                     --  SPARK_Mode is always at the top of the declarations to\n+                     --  properly enabled/suppress errors.\n \n                      Insert_After_SPARK_Mode\n                        (Prag    => Aitem,\n@@ -8715,14 +8768,6 @@ package body Sem_Ch13 is\n          when Aspect_Default_Value =>\n             T := Entity (ASN);\n \n-         --  Depends is a delayed aspect because it mentiones names first\n-         --  introduced by aspect Global which is already delayed. There is\n-         --  no action to be taken with respect to the aspect itself as the\n-         --  analysis is done by the corresponding pragma.\n-\n-         when Aspect_Depends =>\n-            return;\n-\n          when Aspect_Dispatching_Domain =>\n             T := RTE (RE_Dispatching_Domain);\n \n@@ -8732,14 +8777,6 @@ package body Sem_Ch13 is\n          when Aspect_External_Name =>\n             T := Standard_String;\n \n-         --  Global is a delayed aspect because it may reference names that\n-         --  have not been declared yet. There is no action to be taken with\n-         --  respect to the aspect itself as the reference checking is done\n-         --  on the corresponding pragma.\n-\n-         when Aspect_Global =>\n-            return;\n-\n          when Aspect_Link_Name =>\n             T := Standard_String;\n \n@@ -8847,9 +8884,12 @@ package body Sem_Ch13 is\n               Aspect_Annotate                  |\n               Aspect_Contract_Cases            |\n               Aspect_Default_Initial_Condition |\n+              Aspect_Depends                   |\n               Aspect_Dimension                 |\n               Aspect_Dimension_System          |\n               Aspect_Extensions_Visible        |\n+              Aspect_Ghost                     |\n+              Aspect_Global                    |\n               Aspect_Implicit_Dereference      |\n               Aspect_Initial_Condition         |\n               Aspect_Initializes               |"}, {"sha": "8579e0833135aca5f2c566bfa58aa199d9fc3956", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 190, "deletions": 24, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c", "patch": "@@ -2617,7 +2617,6 @@ package body Sem_Ch3 is\n          Set_Analyzed (T);\n \n          case Nkind (Def) is\n-\n             when N_Access_To_Subprogram_Definition =>\n                Access_Subprogram_Declaration (T, Def);\n \n@@ -2705,13 +2704,20 @@ package body Sem_Ch3 is\n          Check_SPARK_05_Restriction (\"controlled type is not allowed\", N);\n       end if;\n \n+      --  A type declared within a Ghost scope is automatically Ghost\n+      --  (SPARK RM 6.9(2)).\n+\n+      if Comes_From_Source (T) and then Within_Ghost_Scope then\n+         Set_Is_Ghost_Entity (T);\n+      end if;\n+\n       --  Some common processing for all types\n \n       Set_Depends_On_Private (T, Has_Private_Component (T));\n       Check_Ops_From_Incomplete_Type;\n \n-      --  Both the declared entity, and its anonymous base type if one\n-      --  was created, need freeze nodes allocated.\n+      --  Both the declared entity, and its anonymous base type if one was\n+      --  created, need freeze nodes allocated.\n \n       declare\n          B : constant Entity_Id := Base_Type (T);\n@@ -2850,6 +2856,13 @@ package body Sem_Ch3 is\n       Set_Is_First_Subtype (T, True);\n       Set_Etype (T, T);\n \n+      --  An incomplete type declared within a Ghost scope is automatically\n+      --  Ghost (SPARK RM 6.9(2)).\n+\n+      if Within_Ghost_Scope then\n+         Set_Is_Ghost_Entity (T);\n+      end if;\n+\n       --  Ada 2005 (AI-326): Minimum decoration to give support to tagged\n       --  incomplete types.\n \n@@ -2960,6 +2973,13 @@ package body Sem_Ch3 is\n       Generate_Definition (Id);\n       Enter_Name (Id);\n \n+      --  A number declared within a Ghost scope is automatically Ghost\n+      --  (SPARK RM 6.9(2)).\n+\n+      if Within_Ghost_Scope then\n+         Set_Is_Ghost_Entity (Id);\n+      end if;\n+\n       --  This is an optimization of a common case of an integer literal\n \n       if Nkind (E) = N_Integer_Literal then\n@@ -3099,6 +3119,13 @@ package body Sem_Ch3 is\n       Seen    : Boolean := False;\n \n    begin\n+      --  The loop parameter in an element iterator over a formal container\n+      --  is declared with an object declaration but no contracts apply.\n+\n+      if Ekind (Obj_Id) = E_Loop_Parameter then\n+         return;\n+      end if;\n+\n       if Ekind (Obj_Id) = E_Constant then\n \n          --  A constant cannot be effectively volatile. This check is only\n@@ -3113,12 +3140,6 @@ package body Sem_Ch3 is\n             Error_Msg_N (\"constant cannot be volatile\", Obj_Id);\n          end if;\n \n-      --  The loop parameter in an element iterator over a formal container\n-      --  is declared with an object declaration but no contracts apply.\n-\n-      elsif Ekind (Obj_Id) = E_Loop_Parameter then\n-         null;\n-\n       else pragma Assert (Ekind (Obj_Id) = E_Variable);\n \n          --  The following checks are only relevant when SPARK_Mode is on as\n@@ -3164,6 +3185,25 @@ package body Sem_Ch3 is\n                      Obj_Id);\n                end if;\n             end if;\n+\n+            if Is_Ghost_Entity (Obj_Id) then\n+\n+               --  A Ghost object cannot be effectively volatile\n+               --  (SPARK RM 6.9(8)).\n+\n+               if Is_Effectively_Volatile (Obj_Id) then\n+                  SPARK_Msg_N (\"ghost variable & cannot be volatile\", Obj_Id);\n+\n+               --  A Ghost object cannot be imported or exported\n+               --  (SPARK RM 6.9(8)).\n+\n+               elsif Is_Imported (Obj_Id) then\n+                  SPARK_Msg_N (\"ghost object & cannot be imported\", Obj_Id);\n+\n+               elsif Is_Exported (Obj_Id) then\n+                  SPARK_Msg_N (\"ghost object & cannot be exported\", Obj_Id);\n+               end if;\n+            end if;\n          end if;\n \n          --  Analyze all external properties\n@@ -3211,6 +3251,17 @@ package body Sem_Ch3 is\n             Check_Missing_Part_Of (Obj_Id);\n          end if;\n       end if;\n+\n+      --  A ghost object cannot be imported or exported (SPARK RM 6.9(8))\n+\n+      if Is_Ghost_Entity (Obj_Id) then\n+         if Is_Exported (Obj_Id) then\n+            SPARK_Msg_N (\"ghost object & cannot be exported\", Obj_Id);\n+\n+         elsif Is_Imported (Obj_Id) then\n+            SPARK_Msg_N (\"ghost object & cannot be imported\", Obj_Id);\n+         end if;\n+      end if;\n    end Analyze_Object_Contract;\n \n    --------------------------------\n@@ -3522,8 +3573,7 @@ package body Sem_Ch3 is\n       --  and must not be unconstrained. (The only exception to this is the\n       --  acceptance of declarations of constants of type String.)\n \n-      if not\n-        Nkind_In (Object_Definition (N), N_Identifier, N_Expanded_Name)\n+      if not Nkind_In (Object_Definition (N), N_Expanded_Name, N_Identifier)\n       then\n          Check_SPARK_05_Restriction\n            (\"subtype mark required\", Object_Definition (N));\n@@ -3869,6 +3919,23 @@ package body Sem_Ch3 is\n                   Set_Ekind (Id, E_Variable);\n                end if;\n \n+               --  An object declared within a Ghost scope is automatically\n+               --  Ghost (SPARK RM 6.9(2)).\n+\n+               if Comes_From_Source (Id) and then Within_Ghost_Scope then\n+                  Set_Is_Ghost_Entity (Id);\n+\n+                  --  The Ghost policy in effect at the point of declaration\n+                  --  and at the point of completion must match\n+                  --  (SPARK RM 6.9(14)).\n+\n+                  if Present (Prev_Entity)\n+                    and then Is_Ghost_Entity (Prev_Entity)\n+                  then\n+                     Check_Ghost_Completion (Prev_Entity, Id);\n+                  end if;\n+               end if;\n+\n                Rewrite (N,\n                  Make_Object_Renaming_Declaration (Loc,\n                    Defining_Identifier => Id,\n@@ -3991,7 +4058,7 @@ package body Sem_Ch3 is\n       --  true for variables so far (will be reset for a variable if and when\n       --  we encounter a modification in the source).\n \n-      Set_Never_Set_In_Source (Id, True);\n+      Set_Never_Set_In_Source (Id);\n \n       --  Now establish the proper kind and type of the object\n \n@@ -4021,7 +4088,7 @@ package body Sem_Ch3 is\n          --  the case of exception choice variables, it will already be true).\n \n          if Present (E) then\n-            Set_Has_Initial_Value (Id, True);\n+            Set_Has_Initial_Value (Id);\n          end if;\n \n          Set_Contract (Id, Make_Contract (Sloc (Id)));\n@@ -4033,6 +4100,27 @@ package body Sem_Ch3 is\n       Init_Esize                   (Id);\n       Set_Optimize_Alignment_Flags (Id);\n \n+      --  An object declared within a Ghost scope is automatically Ghost\n+      --  (SPARK RM 6.9(2)). This property is also inherited when its type\n+      --  is Ghost or the previous declaration of the deferred constant is\n+      --  Ghost.\n+\n+      if Comes_From_Source (Id)\n+        and then (Is_Ghost_Entity (T)\n+                   or else (Present (Prev_Entity)\n+                             and then Is_Ghost_Entity (Prev_Entity))\n+                   or else Within_Ghost_Scope)\n+      then\n+         Set_Is_Ghost_Entity (Id);\n+\n+         --  The Ghost policy in effect at the point of declaration and at the\n+         --  point of completion must match (SPARK RM 6.9(14)).\n+\n+         if Present (Prev_Entity) and then Is_Ghost_Entity (Prev_Entity) then\n+            Check_Ghost_Completion (Prev_Entity, Id);\n+         end if;\n+      end if;\n+\n       --  Deal with aliased case\n \n       if Aliased_Present (N) then\n@@ -7636,6 +7724,34 @@ package body Sem_Ch3 is\n       Derived_Type : Entity_Id;\n       Derive_Subps : Boolean := True)\n    is\n+      function Implements_Ghost_Interface (Typ : Entity_Id) return Boolean;\n+      --  Determine whether type Typ implements at least one Ghost interface\n+\n+      --------------------------------\n+      -- Implements_Ghost_Interface --\n+      --------------------------------\n+\n+      function Implements_Ghost_Interface (Typ : Entity_Id) return Boolean is\n+         Iface_Elmt : Elmt_Id;\n+      begin\n+         --  Traverse the list of interfaces looking for a Ghost interface\n+\n+         if Is_Tagged_Type (Typ) and then Present (Interfaces (Typ)) then\n+            Iface_Elmt := First_Elmt (Interfaces (Typ));\n+            while Present (Iface_Elmt) loop\n+               if Is_Ghost_Entity (Node (Iface_Elmt)) then\n+                  return True;\n+               end if;\n+\n+               Next_Elmt (Iface_Elmt);\n+            end loop;\n+         end if;\n+\n+         return False;\n+      end Implements_Ghost_Interface;\n+\n+      --  Local variables\n+\n       Discriminant_Specs : constant Boolean :=\n                              Present (Discriminant_Specifications (N));\n       Is_Tagged          : constant Boolean := Is_Tagged_Type (Parent_Type);\n@@ -7663,6 +7779,8 @@ package body Sem_Ch3 is\n       --  An empty Discs list means that there were no constraints in the\n       --  subtype indication or that there was an error processing it.\n \n+   --  Start of processing for Build_Derived_Record_Type\n+\n    begin\n       if Ekind (Parent_Type) = E_Record_Type_With_Private\n         and then Present (Full_View (Parent_Type))\n@@ -8214,7 +8332,7 @@ package body Sem_Ch3 is\n \n                declare\n                   Corr_Disc : constant Entity_Id :=\n-                      Corresponding_Discriminant (Discrim);\n+                                Corresponding_Discriminant (Discrim);\n                   Disc_Type : constant Entity_Id := Etype (Discrim);\n                   Corr_Type : Entity_Id;\n \n@@ -8496,7 +8614,7 @@ package body Sem_Ch3 is\n                if Is_Itype (Derived_Type) then\n                   declare\n                      Def : constant Node_Id :=\n-                       Associated_Node_For_Itype (Derived_Type);\n+                             Associated_Node_For_Itype (Derived_Type);\n                   begin\n                      if Present (Def)\n                        and then Nkind (Def) = N_Full_Type_Declaration\n@@ -8506,6 +8624,16 @@ package body Sem_Ch3 is\n                      end if;\n                   end;\n                end if;\n+\n+               --  A type extension is automatically Ghost when one of its\n+               --  progenitors is Ghost (SPARK RM 6.9(9)). This property is\n+               --  also inherited when the parent type is Ghost, but this is\n+               --  done in Build_Derived_Type as the mechanism also handles\n+               --  untagged derivations.\n+\n+               if Implements_Ghost_Interface (Derived_Type) then\n+                  Set_Is_Ghost_Entity (Derived_Type);\n+               end if;\n             end;\n          end if;\n \n@@ -8700,6 +8828,7 @@ package body Sem_Ch3 is\n       Set_RM_Size        (Derived_Type, RM_Size        (Parent_Type));\n       Set_Is_Controlled  (Derived_Type, Is_Controlled  (Parent_Type));\n       Set_Is_Tagged_Type (Derived_Type, Is_Tagged_Type (Parent_Type));\n+      Set_Is_Volatile    (Derived_Type, Is_Volatile    (Parent_Type));\n \n       if Is_Tagged_Type (Derived_Type) then\n          Set_No_Tagged_Streams_Pragma\n@@ -8716,7 +8845,7 @@ package body Sem_Ch3 is\n       --  type may be set in the private part, and not propagated to the\n       --  subtype until later, so we obtain the convention from the base type.\n \n-      Set_Convention (Derived_Type, Convention     (Parent_Base));\n+      Set_Convention (Derived_Type, Convention (Parent_Base));\n \n       --  Set SSO default for record or array type\n \n@@ -8759,6 +8888,13 @@ package body Sem_Ch3 is\n          Set_May_Inherit_Delayed_Rep_Aspects (Derived_Type);\n       end if;\n \n+      --  Propagate the attributes related to pragma Ghost from the parent type\n+      --  to the derived type or type extension (SPARK RM 6.9(9)).\n+\n+      if Is_Ghost_Entity (Parent_Type) then\n+         Set_Is_Ghost_Entity (Derived_Type);\n+      end if;\n+\n       --  Type dependent processing\n \n       case Ekind (Parent_Type) is\n@@ -10646,14 +10782,24 @@ package body Sem_Ch3 is\n          end if;\n       end Post_Error;\n \n+      --  Local variables\n+\n+      Pack_Id : constant Entity_Id := Current_Scope;\n+\n    --  Start of processing for Check_Completion\n \n    begin\n-      E := First_Entity (Current_Scope);\n+      E := First_Entity (Pack_Id);\n       while Present (E) loop\n          if Is_Intrinsic_Subprogram (E) then\n             null;\n \n+         --  A Ghost entity declared in a non-Ghost package does not force the\n+         --  need for a body (SPARK RM 6.9(11)).\n+\n+         elsif not Is_Ghost_Entity (Pack_Id) and then Is_Ghost_Entity (E) then\n+            null;\n+\n          --  The following situation requires special handling: a child unit\n          --  that appears in the context clause of the body of its parent:\n \n@@ -10678,10 +10824,10 @@ package body Sem_Ch3 is\n          --  this kind is reserved for predefined operators, that are\n          --  intrinsic and do not need completion.\n \n-         elsif  Ekind_In (E, E_Function,\n-                             E_Procedure,\n-                             E_Generic_Function,\n-                             E_Generic_Procedure)\n+         elsif Ekind_In (E, E_Function,\n+                            E_Procedure,\n+                            E_Generic_Function,\n+                            E_Generic_Procedure)\n          then\n             if Has_Completion (E) then\n                null;\n@@ -11834,8 +11980,7 @@ package body Sem_Ch3 is\n          then\n             Error_Msg_Sloc := Sloc (Prev);\n             Error_Msg_N\n-              (\"full constant for declaration#\"\n-               & \" must be in private part\", N);\n+              (\"full constant for declaration # must be in private part\", N);\n \n          elsif Ekind (Current_Scope) = E_Package\n            and then\n@@ -14581,7 +14726,8 @@ package body Sem_Ch3 is\n                              and then Designated_Type (Etype (New_Subp)) =\n                                                         Derived_Type\n                              and then not Is_Null_Extension (Derived_Type))\n-                   or else Is_EVF_Procedure (Alias (New_Subp)))\n+                   or else (Comes_From_Source (Alias (New_Subp))\n+                             and then Is_EVF_Procedure (Alias (New_Subp))))\n         and then No (Actual_Subp)\n       then\n          if not Is_Tagged_Type (Derived_Type)\n@@ -19636,6 +19782,26 @@ package body Sem_Ch3 is\n             Private_To_Full_View => True);\n       end if;\n \n+      --  Propagate the attributes related to pragma Ghost from the private to\n+      --  the full view.\n+\n+      if Is_Ghost_Entity (Priv_T) then\n+         Set_Is_Ghost_Entity (Full_T);\n+\n+         --  The Ghost policy in effect at the point of declaration and at the\n+         --  point of completion must match (SPARK RM 6.9(14)).\n+\n+         Check_Ghost_Completion (Priv_T, Full_T);\n+\n+         --  In the case where the private view of a tagged type lacks a parent\n+         --  type and is subject to pragma Ghost, ensure that the parent type\n+         --  specified by the full view is also Ghost (SPARK RM 6.9(9)).\n+\n+         if Is_Derived_Type (Full_T) then\n+            Check_Ghost_Derivation (Full_T);\n+         end if;\n+      end if;\n+\n       --  Propagate invariants to full type\n \n       if Has_Invariants (Priv_T) then"}, {"sha": "0167f90565d460b13a7a1b80653765ba6c803ace", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c", "patch": "@@ -854,11 +854,6 @@ package body Sem_Ch4 is\n       --  Flag indicates whether an interpretation of the prefix is a\n       --  parameterless call that returns an access_to_subprogram.\n \n-      procedure Check_Ghost_Subprogram_Call;\n-      --  Verify the legality of a call to a ghost subprogram. Such calls can\n-      --  appear only in assertion expressions except subtype predicates or\n-      --  from within another ghost subprogram.\n-\n       procedure Check_Mixed_Parameter_And_Named_Associations;\n       --  Check that parameter and named associations are not mixed. This is\n       --  a restriction in SPARK mode.\n@@ -873,53 +868,6 @@ package body Sem_Ch4 is\n       procedure No_Interpretation;\n       --  Output error message when no valid interpretation exists\n \n-      ---------------------------------\n-      -- Check_Ghost_Subprogram_Call --\n-      ---------------------------------\n-\n-      procedure Check_Ghost_Subprogram_Call is\n-         S : Entity_Id;\n-\n-      begin\n-         --  Do not perform the check while preanalyzing the enclosing context\n-         --  because the call is not in its final place. Premature attempts to\n-         --  verify the placement lead to bogus errors.\n-\n-         if In_Spec_Expression then\n-            return;\n-\n-         --  The ghost subprogram appears inside an assertion expression which\n-         --  is one of the allowed cases.\n-\n-         elsif In_Assertion_Expression_Pragma (N) then\n-            return;\n-\n-         --  Otherwise see if it inside another ghost subprogram\n-\n-         else\n-            --  Loop to climb scopes\n-\n-            S := Current_Scope;\n-            while Present (S) and then S /= Standard_Standard loop\n-\n-               --  The call appears inside another ghost subprogram\n-\n-               if Is_Ghost_Subprogram (S) then\n-                  return;\n-               end if;\n-\n-               S := Scope (S);\n-            end loop;\n-\n-            --  If we fall through the loop it was not within another\n-            --  ghost subprogram, so we have bad placement.\n-\n-            Error_Msg_N\n-              (\"call to ghost subprogram must appear in assertion expression \"\n-               & \"or another ghost subprogram\", N);\n-         end if;\n-      end Check_Ghost_Subprogram_Call;\n-\n       --------------------------------------------------\n       -- Check_Mixed_Parameter_And_Named_Associations --\n       --------------------------------------------------\n@@ -1308,13 +1256,6 @@ package body Sem_Ch4 is\n \n          End_Interp_List;\n       end if;\n-\n-      --  A call to a ghost subprogram is allowed only in assertion expressions\n-      --  excluding subtype predicates or from within another ghost subprogram.\n-\n-      if Is_Ghost_Subprogram (Get_Subprogram_Entity (N)) then\n-         Check_Ghost_Subprogram_Call;\n-      end if;\n    end Analyze_Call;\n \n    -----------------------------"}, {"sha": "0e09a02acf739537982e2a41e6ead943c9e4f2eb", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c", "patch": "@@ -273,8 +273,12 @@ package body Sem_Ch5 is\n    begin\n       Mark_Coextensions (N, Rhs);\n \n-      Analyze (Rhs);\n+      --  Analyze the target of the assignment first in case the expression\n+      --  contains references to Ghost entities. The checks that verify the\n+      --  proper use of a Ghost entity need to know the enclosing context.\n+\n       Analyze (Lhs);\n+      Analyze (Rhs);\n \n       --  Ensure that we never do an assignment on a variable marked as\n       --  as Safe_To_Reevaluate."}, {"sha": "1ef29c553870e2162c60fa0542a144152d707cdf", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 50, "deletions": 25, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c", "patch": "@@ -223,6 +223,13 @@ package body Sem_Ch6 is\n \n       Set_Categorization_From_Scope (Designator, Scop);\n \n+      --  An abstract subprogram declared within a Ghost scope is automatically\n+      --  Ghost (SPARK RM 6.9(2)).\n+\n+      if Comes_From_Source (Designator) and then Within_Ghost_Scope then\n+         Set_Is_Ghost_Entity (Designator);\n+      end if;\n+\n       if Ekind (Scope (Designator)) = E_Protected_Type then\n          Error_Msg_N\n            (\"abstract subprogram not allowed in protected type\", N);\n@@ -1204,6 +1211,20 @@ package body Sem_Ch6 is\n          Set_Convention     (Body_Id, Convention (Gen_Id));\n          Set_Is_Obsolescent (Body_Id, Is_Obsolescent (Gen_Id));\n          Set_Scope          (Body_Id, Scope (Gen_Id));\n+\n+         --  Inherit the \"ghostness\" of the generic spec. Note that this\n+         --  property is not directly inherited as the body may be subject\n+         --  to a different Ghost assertion policy.\n+\n+         if Is_Ghost_Entity (Gen_Id) or else Within_Ghost_Scope then\n+            Set_Is_Ghost_Entity (Body_Id);\n+\n+            --  The Ghost policy in effect at the point of declaration and at\n+            --  the point of completion must match (SPARK RM 6.9(14)).\n+\n+            Check_Ghost_Completion (Gen_Id, Body_Id);\n+         end if;\n+\n          Check_Fully_Conformant (Body_Id, Gen_Id, Body_Id);\n \n          if Nkind (N) = N_Subprogram_Body_Stub then\n@@ -3309,6 +3330,19 @@ package body Sem_Ch6 is\n             Set_Convention (Body_Id, Convention (Spec_Id));\n             Set_Has_Completion (Spec_Id);\n \n+            --  Inherit the \"ghostness\" of the subprogram spec. Note that this\n+            --  property is not directly inherited as the body may be subject\n+            --  to a different Ghost assertion policy.\n+\n+            if Is_Ghost_Entity (Spec_Id) or else Within_Ghost_Scope then\n+               Set_Is_Ghost_Entity (Body_Id);\n+\n+               --  The Ghost policy in effect at the point of declaration and\n+               --  at the point of completion must match (SPARK RM 6.9(14)).\n+\n+               Check_Ghost_Completion (Spec_Id, Body_Id);\n+            end if;\n+\n             if Is_Protected_Type (Scope (Spec_Id)) then\n                Prot_Typ := Scope (Spec_Id);\n             end if;\n@@ -4195,6 +4229,13 @@ package body Sem_Ch6 is\n       Set_SPARK_Pragma (Designator, SPARK_Mode_Pragma);\n       Set_SPARK_Pragma_Inherited (Designator, True);\n \n+      --  A subprogram declared within a Ghost scope is automatically Ghost\n+      --  (SPARK RM 6.9(2)).\n+\n+      if Comes_From_Source (Designator) and then Within_Ghost_Scope then\n+         Set_Is_Ghost_Entity (Designator);\n+      end if;\n+\n       if Debug_Flag_C then\n          Write_Str (\"==> subprogram spec \");\n          Write_Name (Chars (Designator));\n@@ -4640,7 +4681,6 @@ package body Sem_Ch6 is\n       if Old_Type /= Standard_Void_Type\n         and then New_Type /= Standard_Void_Type\n       then\n-\n          --  If we are checking interface conformance we omit controlling\n          --  arguments and result, because we are only checking the conformance\n          --  of the remaining parameters.\n@@ -4719,6 +4759,13 @@ package body Sem_Ch6 is\n          then\n             Conformance_Error (\"\\formal subprograms not allowed!\");\n             return;\n+\n+         --  Pragma Ghost behaves as a convention in the context of subtype\n+         --  conformance (SPARK RM 6.9(5)).\n+\n+         elsif Is_Ghost_Entity (Old_Id) /= Is_Ghost_Entity (New_Id) then\n+            Conformance_Error (\"\\ghost modes do not match!\");\n+            return;\n          end if;\n       end if;\n \n@@ -5143,42 +5190,20 @@ package body Sem_Ch6 is\n       ----------------------\n \n       procedure Check_Convention (Op : Entity_Id) is\n-         function Convention_Of (Id : Entity_Id) return Convention_Id;\n-         --  Given an entity, return its convention. The function treats Ghost\n-         --  as convention Ada because the two have the same dynamic semantics.\n-\n-         -------------------\n-         -- Convention_Of --\n-         -------------------\n-\n-         function Convention_Of (Id : Entity_Id) return Convention_Id is\n-            Conv : constant Convention_Id := Convention (Id);\n-         begin\n-            if Conv = Convention_Ghost then\n-               return Convention_Ada;\n-            else\n-               return Conv;\n-            end if;\n-         end Convention_Of;\n-\n-         --  Local variables\n-\n-         Op_Conv         : constant Convention_Id := Convention_Of (Op);\n+         Op_Conv         : constant Convention_Id := Convention (Op);\n          Iface_Conv      : Convention_Id;\n          Iface_Elmt      : Elmt_Id;\n          Iface_Prim_Elmt : Elmt_Id;\n          Iface_Prim      : Entity_Id;\n \n-      --  Start of processing for Check_Convention\n-\n       begin\n          Iface_Elmt := First_Elmt (Ifaces_List);\n          while Present (Iface_Elmt) loop\n             Iface_Prim_Elmt :=\n               First_Elmt (Primitive_Operations (Node (Iface_Elmt)));\n             while Present (Iface_Prim_Elmt) loop\n                Iface_Prim := Node (Iface_Prim_Elmt);\n-               Iface_Conv := Convention_Of (Iface_Prim);\n+               Iface_Conv := Convention (Iface_Prim);\n \n                if Is_Interface_Conformant (Typ, Iface_Prim, Op)\n                  and then Iface_Conv /= Op_Conv"}, {"sha": "b96c27af43e737029efc6099cdaaa7ab257c4e09", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 161, "deletions": 169, "changes": 330, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c", "patch": "@@ -108,20 +108,6 @@ package body Sem_Ch7 is\n    --  created at the beginning of the corresponding package body and inserted\n    --  before other body declarations.\n \n-   procedure Install_Package_Entity (Id : Entity_Id);\n-   --  Supporting procedure for Install_{Visible,Private}_Declarations. Places\n-   --  one entity on its visibility chain, and recurses on the visible part if\n-   --  the entity is an inner package.\n-\n-   function Is_Private_Base_Type (E : Entity_Id) return Boolean;\n-   --  True for a private type that is not a subtype\n-\n-   function Is_Visible_Dependent (Dep : Entity_Id) return Boolean;\n-   --  If the private dependent is a private type whose full view is derived\n-   --  from the parent type, its full properties are revealed only if we are in\n-   --  the immediate scope of the private dependent. Should this predicate be\n-   --  tightened further???\n-\n    procedure Declare_Inherited_Private_Subprograms (Id : Entity_Id);\n    --  Called upon entering the private part of a public child package and the\n    --  body of a nested package, to potentially declare certain inherited\n@@ -137,10 +123,31 @@ package body Sem_Ch7 is\n    --  inherited private operation has been overridden, then it's replaced by\n    --  the overriding operation.\n \n-   procedure Unit_Requires_Body_Info (P : Entity_Id);\n-   --  Outputs info messages showing why package specification P requires a\n-   --  body. Caller has checked that the switch requesting this information\n-   --  is set, and that the package does indeed require a body.\n+   procedure Install_Package_Entity (Id : Entity_Id);\n+   --  Supporting procedure for Install_{Visible,Private}_Declarations. Places\n+   --  one entity on its visibility chain, and recurses on the visible part if\n+   --  the entity is an inner package.\n+\n+   function Is_Private_Base_Type (E : Entity_Id) return Boolean;\n+   --  True for a private type that is not a subtype\n+\n+   function Is_Visible_Dependent (Dep : Entity_Id) return Boolean;\n+   --  If the private dependent is a private type whose full view is derived\n+   --  from the parent type, its full properties are revealed only if we are in\n+   --  the immediate scope of the private dependent. Should this predicate be\n+   --  tightened further???\n+\n+   function Requires_Completion_In_Body\n+     (Id      : Entity_Id;\n+      Pack_Id : Entity_Id) return Boolean;\n+   --  Subsidiary to routines Unit_Requires_Body and Unit_Requires_Body_Info.\n+   --  Determine whether entity Id declared in package spec Pack_Id requires\n+   --  completion in a package body.\n+\n+   procedure Unit_Requires_Body_Info (Pack_Id : Entity_Id);\n+   --  Outputs info messages showing why package Pack_Id requires a body. The\n+   --  caller has checked that the switch requesting this information is set,\n+   --  and that the package does indeed require a body.\n \n    --------------------------\n    -- Analyze_Package_Body --\n@@ -588,13 +595,14 @@ package body Sem_Ch7 is\n       --  been set.\n \n       if Present (Corresponding_Spec (N)) then\n-         Spec_Id := Corresponding_Spec (N);\n+         Spec_Id   := Corresponding_Spec (N);\n          Pack_Decl := Unit_Declaration_Node (Spec_Id);\n \n       else\n          Spec_Id := Current_Entity_In_Scope (Defining_Entity (N));\n \n-         if Present (Spec_Id) and then Is_Package_Or_Generic_Package (Spec_Id)\n+         if Present (Spec_Id)\n+           and then Is_Package_Or_Generic_Package (Spec_Id)\n          then\n             Pack_Decl := Unit_Declaration_Node (Spec_Id);\n \n@@ -719,6 +727,19 @@ package body Sem_Ch7 is\n          Set_SPARK_Aux_Pragma_Inherited (Body_Id, True);\n       end if;\n \n+      --  Inherit the \"ghostness\" of the subprogram spec. Note that this\n+      --  property is not directly inherited as the body may be subject to a\n+      --  different Ghost assertion policy.\n+\n+      if Is_Ghost_Entity (Spec_Id) or else Within_Ghost_Scope then\n+         Set_Is_Ghost_Entity (Body_Id);\n+\n+         --  The Ghost policy in effect at the point of declaration and at the\n+         --  point of completion must match (SPARK RM 6.9(14)).\n+\n+         Check_Ghost_Completion (Spec_Id, Body_Id);\n+      end if;\n+\n       Set_Categorization_From_Pragmas (N);\n \n       Install_Visible_Declarations (Spec_Id);\n@@ -1754,6 +1775,13 @@ package body Sem_Ch7 is\n       New_Private_Type (N, Id, N);\n       Set_Depends_On_Private (Id);\n \n+      --  A type declared within a Ghost scope is automatically Ghost\n+      --  (SPARK RM 6.9(2)).\n+\n+      if Within_Ghost_Scope then\n+         Set_Is_Ghost_Entity (Id);\n+      end if;\n+\n       if Has_Aspects (N) then\n          Analyze_Aspect_Specifications (N, Id);\n       end if;\n@@ -2410,6 +2438,82 @@ package body Sem_Ch7 is\n       end if;\n    end New_Private_Type;\n \n+   ---------------------------------\n+   -- Requires_Completion_In_Body --\n+   ---------------------------------\n+\n+   function Requires_Completion_In_Body\n+     (Id      : Entity_Id;\n+      Pack_Id : Entity_Id) return Boolean is\n+   begin\n+      --  Always ignore child units. Child units get added to the entity list\n+      --  of a parent unit, but are not original entities of the parent, and\n+      --  so do not affect whether the parent needs a body.\n+\n+      if Is_Child_Unit (Id) then\n+         return False;\n+\n+      --  Ignore formal packages and their renamings\n+\n+      elsif Ekind (Id) = E_Package\n+        and then Nkind (Original_Node (Unit_Declaration_Node (Id))) =\n+                                                   N_Formal_Package_Declaration\n+      then\n+         return False;\n+\n+      --  A Ghost entity declared in a non-Ghost package does not force the\n+      --  need for a body (SPARK RM 6.9(11)).\n+\n+      elsif not Is_Ghost_Entity (Pack_Id) and then Is_Ghost_Entity (Id) then\n+         return False;\n+\n+      --  Otherwise test to see if entity requires a completion. Note that\n+      --  subprogram entities whose declaration does not come from source are\n+      --  ignored here on the basis that we assume the expander will provide an\n+      --  implicit completion at some point.\n+\n+      elsif (Is_Overloadable (Id)\n+              and then Ekind (Id) /= E_Enumeration_Literal\n+              and then Ekind (Id) /= E_Operator\n+              and then not Is_Abstract_Subprogram (Id)\n+              and then not Has_Completion (Id)\n+              and then Comes_From_Source (Parent (Id)))\n+\n+        or else\n+          (Ekind (Id) = E_Package\n+            and then Id /= Pack_Id\n+            and then not Has_Completion (Id)\n+            and then Unit_Requires_Body (Id))\n+\n+        or else\n+          (Ekind (Id) = E_Incomplete_Type\n+            and then No (Full_View (Id))\n+            and then not Is_Generic_Type (Id))\n+\n+        or else\n+          (Ekind_In (Id, E_Task_Type, E_Protected_Type)\n+            and then not Has_Completion (Id))\n+\n+        or else\n+          (Ekind (Id) = E_Generic_Package\n+            and then Id /= Pack_Id\n+            and then not Has_Completion (Id)\n+            and then Unit_Requires_Body (Id))\n+\n+        or else\n+          (Is_Generic_Subprogram (Id)\n+            and then not Has_Completion (Id))\n+\n+      then\n+         return True;\n+\n+      --  Otherwise the entity does not require completion in a package body\n+\n+      else\n+         return False;\n+      end if;\n+   end Requires_Completion_In_Body;\n+\n    ----------------------------\n    -- Uninstall_Declarations --\n    ----------------------------\n@@ -2859,7 +2963,7 @@ package body Sem_Ch7 is\n    ------------------------\n \n    function Unit_Requires_Body\n-     (P                     : Entity_Id;\n+     (Pack_Id               : Entity_Id;\n       Ignore_Abstract_State : Boolean := False) return Boolean\n    is\n       E : Entity_Id;\n@@ -2869,30 +2973,30 @@ package body Sem_Ch7 is\n       --  be imported, but perhaps in the future we will allow import of\n       --  packages.\n \n-      if Is_Imported (P) then\n+      if Is_Imported (Pack_Id) then\n          return False;\n \n       --  Body required if library package with pragma Elaborate_Body\n \n-      elsif Has_Pragma_Elaborate_Body (P) then\n+      elsif Has_Pragma_Elaborate_Body (Pack_Id) then\n          return True;\n \n       --  Body required if subprogram\n \n-      elsif Is_Subprogram_Or_Generic_Subprogram (P) then\n+      elsif Is_Subprogram_Or_Generic_Subprogram (Pack_Id) then\n          return True;\n \n       --  Treat a block as requiring a body\n \n-      elsif Ekind (P) = E_Block then\n+      elsif Ekind (Pack_Id) = E_Block then\n          return True;\n \n-      elsif Ekind (P) = E_Package\n-        and then Nkind (Parent (P)) = N_Package_Specification\n-        and then Present (Generic_Parent (Parent (P)))\n+      elsif Ekind (Pack_Id) = E_Package\n+        and then Nkind (Parent (Pack_Id)) = N_Package_Specification\n+        and then Present (Generic_Parent (Parent (Pack_Id)))\n       then\n          declare\n-            G_P : constant Entity_Id := Generic_Parent (Parent (P));\n+            G_P : constant Entity_Id := Generic_Parent (Parent (Pack_Id));\n          begin\n             if Has_Pragma_Elaborate_Body (G_P) then\n                return True;\n@@ -2906,78 +3010,21 @@ package body Sem_Ch7 is\n       --  provided). If Ignore_Abstract_State is True, we don't do this check\n       --  (so we can use Unit_Requires_Body to check for some other reason).\n \n-      elsif Ekind_In (P, E_Generic_Package, E_Package)\n+      elsif Ekind_In (Pack_Id, E_Generic_Package, E_Package)\n         and then not Ignore_Abstract_State\n-        and then Present (Abstract_States (P))\n-        and then not Is_Null_State (Node (First_Elmt (Abstract_States (P))))\n+        and then Present (Abstract_States (Pack_Id))\n+        and then not Is_Null_State\n+                       (Node (First_Elmt (Abstract_States (Pack_Id))))\n       then\n          return True;\n       end if;\n \n       --  Otherwise search entity chain for entity requiring completion\n \n-      E := First_Entity (P);\n+      E := First_Entity (Pack_Id);\n       while Present (E) loop\n-\n-         --  Always ignore child units. Child units get added to the entity\n-         --  list of a parent unit, but are not original entities of the\n-         --  parent, and so do not affect whether the parent needs a body.\n-\n-         if Is_Child_Unit (E) then\n-            null;\n-\n-         --  Ignore formal packages and their renamings\n-\n-         elsif Ekind (E) = E_Package\n-           and then Nkind (Original_Node (Unit_Declaration_Node (E))) =\n-                                                N_Formal_Package_Declaration\n-         then\n-            null;\n-\n-         --  Otherwise test to see if entity requires a completion.\n-         --  Note that subprogram entities whose declaration does not come\n-         --  from source are ignored here on the basis that we assume the\n-         --  expander will provide an implicit completion at some point.\n-\n-         elsif (Is_Overloadable (E)\n-                 and then Ekind (E) /= E_Enumeration_Literal\n-                 and then Ekind (E) /= E_Operator\n-                 and then not Is_Abstract_Subprogram (E)\n-                 and then not Has_Completion (E)\n-                 and then Comes_From_Source (Parent (E)))\n-\n-           or else\n-             (Ekind (E) = E_Package\n-               and then E /= P\n-               and then not Has_Completion (E)\n-               and then Unit_Requires_Body (E))\n-\n-           or else\n-             (Ekind (E) = E_Incomplete_Type\n-               and then No (Full_View (E))\n-               and then not Is_Generic_Type (E))\n-\n-           or else\n-             (Ekind_In (E, E_Task_Type, E_Protected_Type)\n-               and then not Has_Completion (E))\n-\n-           or else\n-             (Ekind (E) = E_Generic_Package\n-               and then E /= P\n-               and then not Has_Completion (E)\n-               and then Unit_Requires_Body (E))\n-\n-           or else\n-             (Is_Generic_Subprogram (E)\n-               and then not Has_Completion (E))\n-\n-         then\n+         if Requires_Completion_In_Body (E, Pack_Id) then\n             return True;\n-\n-         --  Entity that does not require completion\n-\n-         else\n-            null;\n          end if;\n \n          Next_Entity (E);\n@@ -2990,40 +3037,40 @@ package body Sem_Ch7 is\n    -- Unit_Requires_Body_Info --\n    -----------------------------\n \n-   procedure Unit_Requires_Body_Info (P : Entity_Id) is\n+   procedure Unit_Requires_Body_Info (Pack_Id : Entity_Id) is\n       E : Entity_Id;\n \n    begin\n-      --  Imported entity never requires body. Right now, only subprograms can\n-      --  be imported, but perhaps in the future we will allow import of\n+      --  An imported entity never requires body. Right now, only subprograms\n+      --  can be imported, but perhaps in the future we will allow import of\n       --  packages.\n \n-      if Is_Imported (P) then\n+      if Is_Imported (Pack_Id) then\n          return;\n \n       --  Body required if library package with pragma Elaborate_Body\n \n-      elsif Has_Pragma_Elaborate_Body (P) then\n-         Error_Msg_N (\"info: & requires body (Elaborate_Body)?Y?\", P);\n+      elsif Has_Pragma_Elaborate_Body (Pack_Id) then\n+         Error_Msg_N (\"info: & requires body (Elaborate_Body)?Y?\", Pack_Id);\n \n       --  Body required if subprogram\n \n-      elsif Is_Subprogram_Or_Generic_Subprogram (P) then\n-         Error_Msg_N (\"info: & requires body (subprogram case)?Y?\", P);\n+      elsif Is_Subprogram_Or_Generic_Subprogram (Pack_Id) then\n+         Error_Msg_N (\"info: & requires body (subprogram case)?Y?\", Pack_Id);\n \n       --  Body required if generic parent has Elaborate_Body\n \n-      elsif Ekind (P) = E_Package\n-        and then Nkind (Parent (P)) = N_Package_Specification\n-        and then Present (Generic_Parent (Parent (P)))\n+      elsif Ekind (Pack_Id) = E_Package\n+        and then Nkind (Parent (Pack_Id)) = N_Package_Specification\n+        and then Present (Generic_Parent (Parent (Pack_Id)))\n       then\n          declare\n-            G_P : constant Entity_Id := Generic_Parent (Parent (P));\n+            G_P : constant Entity_Id := Generic_Parent (Parent (Pack_Id));\n          begin\n             if Has_Pragma_Elaborate_Body (G_P) then\n                Error_Msg_N\n                  (\"info: & requires body (generic parent Elaborate_Body)?Y?\",\n-                  P);\n+                  Pack_Id);\n             end if;\n          end;\n \n@@ -3034,79 +3081,24 @@ package body Sem_Ch7 is\n       --  provided). If Ignore_Abstract_State is True, we don't do this check\n       --  (so we can use Unit_Requires_Body to check for some other reason).\n \n-      elsif Ekind_In (P, E_Generic_Package, E_Package)\n-        and then Present (Abstract_States (P))\n-        and then not Is_Null_State (Node (First_Elmt (Abstract_States (P))))\n+      elsif Ekind_In (Pack_Id, E_Generic_Package, E_Package)\n+        and then Present (Abstract_States (Pack_Id))\n+        and then not Is_Null_State\n+                       (Node (First_Elmt (Abstract_States (Pack_Id))))\n       then\n          Error_Msg_N\n-           (\"info: & requires body (non-null abstract state aspect)?Y?\", P);\n+           (\"info: & requires body (non-null abstract state aspect)?Y?\",\n+            Pack_Id);\n       end if;\n \n       --  Otherwise search entity chain for entity requiring completion\n \n-      E := First_Entity (P);\n+      E := First_Entity (Pack_Id);\n       while Present (E) loop\n-\n-         --  Always ignore child units. Child units get added to the entity\n-         --  list of a parent unit, but are not original entities of the\n-         --  parent, and so do not affect whether the parent needs a body.\n-\n-         if Is_Child_Unit (E) then\n-            null;\n-\n-         --  Ignore formal packages and their renamings\n-\n-         elsif Ekind (E) = E_Package\n-           and then Nkind (Original_Node (Unit_Declaration_Node (E))) =\n-                                                N_Formal_Package_Declaration\n-         then\n-            null;\n-\n-         --  Otherwise test to see if entity requires a completion.\n-         --  Note that subprogram entities whose declaration does not come\n-         --  from source are ignored here on the basis that we assume the\n-         --  expander will provide an implicit completion at some point.\n-\n-         elsif (Is_Overloadable (E)\n-                 and then Ekind (E) /= E_Enumeration_Literal\n-                 and then Ekind (E) /= E_Operator\n-                 and then not Is_Abstract_Subprogram (E)\n-                 and then not Has_Completion (E)\n-                 and then Comes_From_Source (Parent (E)))\n-\n-           or else\n-             (Ekind (E) = E_Package\n-               and then E /= P\n-               and then not Has_Completion (E)\n-               and then Unit_Requires_Body (E))\n-\n-           or else\n-             (Ekind (E) = E_Incomplete_Type\n-               and then No (Full_View (E))\n-               and then not Is_Generic_Type (E))\n-\n-           or else\n-             (Ekind_In (E, E_Task_Type, E_Protected_Type)\n-               and then not Has_Completion (E))\n-\n-           or else\n-             (Ekind (E) = E_Generic_Package\n-               and then E /= P\n-               and then not Has_Completion (E)\n-               and then Unit_Requires_Body (E))\n-\n-           or else\n-             (Is_Generic_Subprogram (E)\n-               and then not Has_Completion (E))\n-         then\n+         if Requires_Completion_In_Body (E, Pack_Id) then\n             Error_Msg_Node_2 := E;\n             Error_Msg_NE\n-              (\"info: & requires body (& requires completion)?Y?\", E, P);\n-\n-         --  Entity that does not require completion\n-\n-         else\n-            null;\n+              (\"info: & requires body (& requires completion)?Y?\", E, Pack_Id);\n          end if;\n \n          Next_Entity (E);"}, {"sha": "a243ac5f3dc4233991916552e0428afbe3a54465", "filename": "gcc/ada/sem_ch7.ads", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2Fsem_ch7.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2Fsem_ch7.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.ads?ref=c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -67,17 +67,17 @@ package Sem_Ch7 is\n    --  child for public child packages.\n \n    function Unit_Requires_Body\n-     (P                     : Entity_Id;\n+     (Pack_Id               : Entity_Id;\n       Ignore_Abstract_State : Boolean := False) return Boolean;\n-   --  Check if a unit requires a body. A specification requires a body if it\n-   --  contains declarations that require completion in a body. If the flag\n-   --  Ignore_Abstract_State is set True, then the test for a non-null abstract\n-   --  state (which normally requires a body) is not carried out. This allows\n-   --  the use of this routine to tell if there is some other reason that a\n-   --  body is required (as is required for analyzing Abstract_State). This\n-   --  is not currently used, but may be useful in future if we implement a\n-   --  compatibility mode which warns about possible incompatibilities if a\n-   --  SPARK 2014 program is compiled with a SPARK-unaware compiler.\n+   --  Determine whether package Pack_Id requires a body. A specification needs\n+   --  a body if it contains declarations that require completion in the body.\n+   --  A non-Ghost [generic] package does not require a body when it declares\n+   --  Ghost entities exclusively. If flag Ignore_Abstract_State is True, then\n+   --  the test for a non-null abstract state (which normally requires a body)\n+   --  is not carried out. The flag is not currently used, but may be useful\n+   --  in the future if we implement a compatibility mode which warns about\n+   --  possible incompatibilities if a SPARK 2014 program is compiled with a\n+   --  SPARK-unaware compiler.\n \n    procedure May_Need_Implicit_Body (E : Entity_Id);\n    --  If a package declaration contains tasks or RACWs and does not require"}, {"sha": "21d9e73d425f6894b8654d6f7c8590ce3c5a9c49", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 41, "deletions": 3, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c", "patch": "@@ -561,8 +561,8 @@ package body Sem_Ch8 is\n       Set_Etype          (Id, Standard_Exception_Type);\n       Set_Is_Pure        (Id, Is_Pure (Current_Scope));\n \n-      if not Is_Entity_Name (Nam) or else\n-        Ekind (Entity (Nam)) /= E_Exception\n+      if not Is_Entity_Name (Nam)\n+        or else Ekind (Entity (Nam)) /= E_Exception\n       then\n          Error_Msg_N (\"invalid exception name in renaming\", Nam);\n       else\n@@ -571,6 +571,13 @@ package body Sem_Ch8 is\n          else\n             Set_Renamed_Object (Id, Entity (Nam));\n          end if;\n+\n+         --  An exception renaming is Ghost if the renamed entity is Ghost or\n+         --  the construct appears within a Ghost scope.\n+\n+         if Is_Ghost_Entity (Entity (Nam)) or else Within_Ghost_Scope then\n+            Set_Is_Ghost_Entity (Id);\n+         end if;\n       end if;\n \n       --  Implementation-defined aspect specifications can appear in a renaming\n@@ -701,6 +708,13 @@ package body Sem_Ch8 is\n          Set_Etype (New_P, Etype (Old_P));\n          Set_Has_Completion (New_P);\n \n+         --  An generic renaming is Ghost if the renamed entity is Ghost or the\n+         --  construct appears within a Ghost scope.\n+\n+         if Is_Ghost_Entity (Old_P) or else Within_Ghost_Scope then\n+            Set_Is_Ghost_Entity (New_P);\n+         end if;\n+\n          if In_Open_Scopes (Old_P) then\n             Error_Msg_N (\"within its scope, generic denotes its instance\", N);\n          end if;\n@@ -849,7 +863,7 @@ package body Sem_Ch8 is\n \n       if Nkind (Nam) = N_Selected_Component and then Analyzed (Nam) then\n          T := Etype (Nam);\n-         Dec :=  Build_Actual_Subtype_Of_Component (Etype (Nam), Nam);\n+         Dec := Build_Actual_Subtype_Of_Component (Etype (Nam), Nam);\n \n          if Present (Dec) then\n             Insert_Action (N, Dec);\n@@ -1295,6 +1309,16 @@ package body Sem_Ch8 is\n          Set_Is_True_Constant    (Id, True);\n       end if;\n \n+      --  An object renaming is Ghost if the renamed entity is Ghost or the\n+      --  construct appears within a Ghost scope.\n+\n+      if (Is_Entity_Name (Nam)\n+           and then Is_Ghost_Entity (Entity (Nam)))\n+        or else Within_Ghost_Scope\n+      then\n+         Set_Is_Ghost_Entity (Id);\n+      end if;\n+\n       --  The entity of the renaming declaration needs to reflect whether the\n       --  renamed object is volatile. Is_Volatile is set if the renamed object\n       --  is volatile in the RM legality sense.\n@@ -1409,6 +1433,13 @@ package body Sem_Ch8 is\n          Check_Library_Unit_Renaming (N, Old_P);\n          Generate_Reference (Old_P, Name (N));\n \n+         --  A package renaming is Ghost if the renamed entity is Ghost or\n+         --  the construct appears within a Ghost scope.\n+\n+         if Is_Ghost_Entity (Old_P) or else Within_Ghost_Scope then\n+            Set_Is_Ghost_Entity (New_P);\n+         end if;\n+\n          --  If the renaming is in the visible part of a package, then we set\n          --  Renamed_In_Spec for the renamed package, to prevent giving\n          --  warnings about no entities referenced. Such a warning would be\n@@ -2992,6 +3023,13 @@ package body Sem_Ch8 is\n          Set_Is_Pure          (New_S, Is_Pure          (Entity (Nam)));\n          Set_Is_Preelaborated (New_S, Is_Preelaborated (Entity (Nam)));\n \n+         --  A subprogram renaming is Ghost if the renamed entity is Ghost or\n+         --  the construct appears within a Ghost scope.\n+\n+         if Is_Ghost_Entity (Entity (Nam)) or else Within_Ghost_Scope then\n+            Set_Is_Ghost_Entity (New_S);\n+         end if;\n+\n          --  Ada 2005 (AI-423): Check the consistency of null exclusions\n          --  between a subprogram and its correct renaming.\n "}, {"sha": "2347bff46a0acff5f8cd83477b5cf35588e4adbe", "filename": "gcc/ada/sem_mech.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2Fsem_mech.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2Fsem_mech.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_mech.adb?ref=c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c", "patch": "@@ -149,7 +149,6 @@ package body Sem_Mech is\n                when Convention_Ada       |\n                     Convention_Intrinsic |\n                     Convention_Entry     |\n-                    Convention_Ghost     |\n                     Convention_Protected |\n                     Convention_Stubbed   =>\n "}, {"sha": "e5c3d855c750194ba1dd9d4e4c26c518e2417bde", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 350, "deletions": 58, "changes": 408, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c", "patch": "@@ -6514,11 +6514,7 @@ package body Sem_Prag is\n         (C   : out Convention_Id;\n          Ent : out Entity_Id)\n       is\n-         Id        : Node_Id;\n-         E         : Entity_Id;\n-         E1        : Entity_Id;\n-         Cname     : Name_Id;\n-         Comp_Unit : Unit_Number_Type;\n+         Cname : Name_Id;\n \n          procedure Diagnose_Multiple_Pragmas (S : Entity_Id);\n          --  Called if we have more than one Export/Import/Convention pragma.\n@@ -6698,17 +6694,6 @@ package body Sem_Prag is\n \n          procedure Set_Convention_From_Pragma (E : Entity_Id) is\n          begin\n-            --  Ghost convention is allowed only for functions\n-\n-            if Ekind (E) /= E_Function and then C = Convention_Ghost then\n-               Error_Msg_N\n-                 (\"& may not have Ghost convention\", E);\n-               Error_Msg_N\n-                 (\"\\only functions are permitted to have Ghost convention\",\n-                  E);\n-               return;\n-            end if;\n-\n             --  Ada 2005 (AI-430): Check invalid attempt to change convention\n             --  for an overridden dispatching operation. Technically this is\n             --  an amendment and should only be done in Ada 2005 mode. However,\n@@ -6719,16 +6704,9 @@ package body Sem_Prag is\n               and then Present (Overridden_Operation (E))\n               and then C /= Convention (Overridden_Operation (E))\n             then\n-               --  An attempt to override a function with a ghost function\n-               --  appears as a mismatch in conventions.\n-\n-               if C = Convention_Ghost then\n-                  Error_Msg_N (\"ghost function & cannot be overriding\", E);\n-               else\n-                  Error_Pragma_Arg\n-                    (\"cannot change convention for overridden dispatching \"\n-                     & \"operation\", Arg1);\n-               end if;\n+               Error_Pragma_Arg\n+                 (\"cannot change convention for overridden dispatching \"\n+                  & \"operation\", Arg1);\n             end if;\n \n             --  Special checks for Convention_Stdcall\n@@ -6858,6 +6836,13 @@ package body Sem_Prag is\n             end if;\n          end Set_Convention_From_Pragma;\n \n+         --  Local variables\n+\n+         Comp_Unit : Unit_Number_Type;\n+         E         : Entity_Id;\n+         E1        : Entity_Id;\n+         Id        : Node_Id;\n+\n       --  Start of processing for Process_Convention\n \n       begin\n@@ -6919,11 +6904,10 @@ package body Sem_Prag is\n                  (\"convention `Ada_Pass_By_Copy` not allowed for by-reference \"\n                   & \"type\", Arg1);\n             end if;\n-         end if;\n \n          --  Ada_Pass_By_Reference special checking\n \n-         if C = Convention_Ada_Pass_By_Reference then\n+         elsif C = Convention_Ada_Pass_By_Reference then\n             if not Is_First_Subtype (E) then\n                Error_Pragma_Arg\n                  (\"convention `Ada_Pass_By_Reference` only allowed for types\",\n@@ -6937,14 +6921,6 @@ package body Sem_Prag is\n             end if;\n          end if;\n \n-         --  Ghost special checking\n-\n-         if Is_Ghost_Subprogram (E)\n-           and then Present (Overridden_Operation (E))\n-         then\n-            Error_Msg_N (\"ghost function & cannot be overriding\", E);\n-         end if;\n-\n          --  Go to renamed subprogram if present, since convention applies to\n          --  the actual renamed entity, not to the renaming entity. If the\n          --  subprogram is inherited, go to parent subprogram.\n@@ -6974,9 +6950,8 @@ package body Sem_Prag is\n             end if;\n          end if;\n \n-         --  Check that we are not applying this to a specless body\n-         --  Relax this check if Relaxed_RM_Semantics to accomodate other Ada\n-         --  compilers.\n+         --  Check that we are not applying this to a specless body. Relax this\n+         --  check if Relaxed_RM_Semantics to accomodate other Ada compilers.\n \n          if Is_Subprogram (E)\n            and then Nkind (Parent (Declaration_Node (E))) = N_Subprogram_Body\n@@ -9914,7 +9889,7 @@ package body Sem_Prag is\n          --    SIMPLE_OPTION\n          --  | NAME_VALUE_OPTION\n \n-         --  SIMPLE_OPTION ::= identifier\n+         --  SIMPLE_OPTION ::= Ghost\n \n          --  NAME_VALUE_OPTION ::=\n          --    Part_Of => ABSTRACT_STATE\n@@ -9945,20 +9920,22 @@ package body Sem_Prag is\n             Non_Null_Seen : Boolean := False;\n             Null_Seen     : Boolean := False;\n \n-            Pack_Id : Entity_Id;\n-            --  Entity of related package when pragma Abstract_State appears\n-\n-            procedure Analyze_Abstract_State (State : Node_Id);\n+            procedure Analyze_Abstract_State\n+              (State   : Node_Id;\n+               Pack_Id : Entity_Id);\n             --  Verify the legality of a single state declaration. Create and\n             --  decorate a state abstraction entity and introduce it into the\n-            --  visibility chain.\n+            --  visibility chain. Pack_Id denotes the entity or the related\n+            --  package where pragma Abstract_State appears.\n \n             ----------------------------\n             -- Analyze_Abstract_State --\n             ----------------------------\n \n-            procedure Analyze_Abstract_State (State : Node_Id) is\n-\n+            procedure Analyze_Abstract_State\n+              (State   : Node_Id;\n+               Pack_Id : Entity_Id)\n+            is\n                --  Flags used to verify the consistency of options\n \n                AR_Seen       : Boolean := False;\n@@ -10301,6 +10278,13 @@ package body Sem_Prag is\n                   Set_Refinement_Constituents (State_Id, New_Elmt_List);\n                   Set_Part_Of_Constituents    (State_Id, New_Elmt_List);\n \n+                  --  An abstract state declared within a Ghost scope becomes\n+                  --  Ghost (SPARK RM 6.9(2)).\n+\n+                  if Within_Ghost_Scope then\n+                     Set_Is_Ghost_Entity (State_Id);\n+                  end if;\n+\n                   --  Establish a link between the state declaration and the\n                   --  abstract state entity. Note that a null state remains as\n                   --  N_Null and does not carry any linkages.\n@@ -10382,16 +10366,19 @@ package body Sem_Prag is\n                         Ancestor_Part (State));\n                   end if;\n \n-                  --  Catch an attempt to introduce a simple option which is\n-                  --  currently not allowed. An exception to this is External\n-                  --  defined without any properties.\n+                  --  Options External and Ghost appear as expressions\n \n                   Opt := First (Expressions (State));\n                   while Present (Opt) loop\n                      if Nkind (Opt) = N_Identifier then\n                         if Chars (Opt) = Name_External then\n                            Analyze_External_Option (Opt);\n \n+                        elsif Chars (Opt) = Name_Ghost then\n+                           if Present (State_Id) then\n+                              Set_Is_Ghost_Entity (State_Id);\n+                           end if;\n+\n                         --  Option Part_Of without an encapsulating state is\n                         --  illegal. (SPARK RM 7.1.4(9)).\n \n@@ -10514,6 +10501,7 @@ package body Sem_Prag is\n             --  Local variables\n \n             Context : constant Node_Id := Parent (Parent (N));\n+            Pack_Id : Entity_Id;\n             State   : Node_Id;\n \n          --  Start of processing for Abstract_State\n@@ -10537,20 +10525,28 @@ package body Sem_Prag is\n             State   := Expression (Arg1);\n             Pack_Id := Defining_Entity (Context);\n \n+            --  Mark the associated package as Ghost if it is subject to aspect\n+            --  or pragma Ghost as this affects the declaration of an abstract\n+            --  state.\n+\n+            if Is_Subject_To_Ghost (Unit_Declaration_Node (Pack_Id)) then\n+               Set_Is_Ghost_Entity (Pack_Id);\n+            end if;\n+\n             --  Multiple non-null abstract states appear as an aggregate\n \n             if Nkind (State) = N_Aggregate then\n                State := First (Expressions (State));\n                while Present (State) loop\n-                  Analyze_Abstract_State (State);\n+                  Analyze_Abstract_State (State, Pack_Id);\n                   Next (State);\n                end loop;\n \n             --  Various forms of a single abstract state. Note that these may\n             --  include malformed state declarations.\n \n             else\n-               Analyze_Abstract_State (State);\n+               Analyze_Abstract_State (State, Pack_Id);\n             end if;\n \n             --  Save the pragma for retrieval by other tools\n@@ -11073,6 +11069,7 @@ package body Sem_Prag is\n          --                        Contract_Cases            |\n          --                        Debug                     |\n          --                        Default_Initial_Condition |\n+         --                        Ghost                     |\n          --                        Initial_Condition         |\n          --                        Loop_Invariant            |\n          --                        Loop_Variant              |\n@@ -11916,7 +11913,8 @@ package body Sem_Prag is\n          --  new form syntax.\n \n          when Pragma_Check_Policy => Check_Policy : declare\n-            Kind : Node_Id;\n+            Ident : Node_Id;\n+            Kind  : Node_Id;\n \n          begin\n             GNAT_Pragma;\n@@ -11936,7 +11934,7 @@ package body Sem_Prag is\n             --  identifier is Name.\n \n             if Nkind (Arg1) /= N_Pragma_Argument_Association\n-               or else Nam_In (Chars (Arg1), No_Name, Name_Name)\n+              or else Nam_In (Chars (Arg1), No_Name, Name_Name)\n             then\n                --  Old syntax\n \n@@ -11950,8 +11948,8 @@ package body Sem_Prag is\n \n                if Nam_In (Chars (Kind), Name_Name, Name_Policy) then\n                   Error_Msg_Name_2 := Chars (Kind);\n-                     Error_Pragma_Arg\n-                       (\"pragma% does not allow% as check name\", Arg1);\n+                  Error_Pragma_Arg\n+                    (\"pragma% does not allow% as check name\", Arg1);\n                end if;\n \n                --  Check policy\n@@ -11960,6 +11958,29 @@ package body Sem_Prag is\n                Check_Arg_Is_One_Of\n                  (Arg2,\n                   Name_On, Name_Off, Name_Check, Name_Disable, Name_Ignore);\n+               Ident := Get_Pragma_Arg (Arg2);\n+\n+               if Chars (Kind) = Name_Ghost then\n+\n+                  --  Pragma Check_Policy specifying a Ghost policy cannot\n+                  --  occur within a ghost subprogram or package.\n+\n+                  if Within_Ghost_Scope then\n+                     Error_Pragma\n+                       (\"pragma % cannot appear within ghost subprogram or \"\n+                        & \"package\");\n+\n+                  --  The policy identifier of pragma Ghost must be either\n+                  --  Check or Ignore (SPARK RM 6.9(7)).\n+\n+                  elsif not Nam_In (Chars (Ident), Name_Check,\n+                                                   Name_Ignore)\n+                  then\n+                     Error_Pragma_Arg\n+                       (\"argument of pragma % Ghost must be Check or Ignore\",\n+                        Arg2);\n+                  end if;\n+               end if;\n \n                --  And chain pragma on the Check_Policy_List for search\n \n@@ -13910,7 +13931,7 @@ package body Sem_Prag is\n          begin\n             GNAT_Pragma;\n             Check_No_Identifiers;\n-            Check_At_Most_N_Arguments  (1);\n+            Check_At_Most_N_Arguments (1);\n \n             Subp := Empty;\n             Stmt := Prev (N);\n@@ -13955,7 +13976,8 @@ package body Sem_Prag is\n             --  enclosing construct is the proper context. This check is done\n             --  after the traversal above to allow for duplicate detection.\n \n-            if Nkind (Context) = N_Subprogram_Body\n+            if No (Subp)\n+              and then Nkind (Context) = N_Subprogram_Body\n               and then No (Corresponding_Spec (Context))\n             then\n                Subp := Defining_Entity (Context);\n@@ -14187,6 +14209,212 @@ package body Sem_Prag is\n             end if;\n          end Finalize_Storage;\n \n+         -----------\n+         -- Ghost --\n+         -----------\n+\n+         --  pragma Ghost [ (boolean_EXPRESSION) ];\n+\n+         when Pragma_Ghost => Ghost : declare\n+            Context   : constant Node_Id := Parent (N);\n+            Expr      : Node_Id;\n+            Id        : Entity_Id;\n+            Orig_Stmt : Node_Id;\n+            Prev_Id   : Entity_Id;\n+            Stmt      : Node_Id;\n+\n+         begin\n+            GNAT_Pragma;\n+            Check_No_Identifiers;\n+            Check_At_Most_N_Arguments (1);\n+\n+            Id   := Empty;\n+            Stmt := Prev (N);\n+            while Present (Stmt) loop\n+\n+               --  Skip prior pragmas, but check for duplicates\n+\n+               if Nkind (Stmt) = N_Pragma then\n+                  if Pragma_Name (Stmt) = Pname then\n+                     Error_Msg_Name_1 := Pname;\n+                     Error_Msg_Sloc   := Sloc (Stmt);\n+                     Error_Msg_N (\"pragma % duplicates pragma declared#\", N);\n+                  end if;\n+\n+               --  Protected and task types cannot be subject to pragma Ghost\n+\n+               elsif Nkind (Stmt) = N_Protected_Type_Declaration then\n+                  Error_Pragma (\"pragma % cannot apply to a protected type\");\n+                  return;\n+\n+               elsif Nkind (Stmt) = N_Task_Type_Declaration then\n+                  Error_Pragma (\"pragma % cannot apply to a task type\");\n+                  return;\n+\n+               --  Skip internally generated code\n+\n+               elsif not Comes_From_Source (Stmt) then\n+                  Orig_Stmt := Original_Node (Stmt);\n+\n+                  --  When pragma Ghost applies to an untagged derivation, the\n+                  --  derivation is transformed into a [sub]type declaration.\n+\n+                  if Nkind_In (Stmt, N_Full_Type_Declaration,\n+                                     N_Subtype_Declaration)\n+                    and then Comes_From_Source (Orig_Stmt)\n+                    and then Nkind (Orig_Stmt) = N_Full_Type_Declaration\n+                    and then Nkind (Type_Definition (Orig_Stmt)) =\n+                               N_Derived_Type_Definition\n+                  then\n+                     Id := Defining_Entity (Stmt);\n+                     exit;\n+\n+                  --  When pragma Ghost applies to an expression function, the\n+                  --  expression function is transformed into a subprogram.\n+\n+                  elsif Nkind (Stmt) = N_Subprogram_Declaration\n+                    and then Comes_From_Source (Orig_Stmt)\n+                    and then Nkind (Orig_Stmt) = N_Expression_Function\n+                  then\n+                     Id := Defining_Entity (Stmt);\n+                     exit;\n+                  end if;\n+\n+               --  The pragma applies to a legal construct, stop the traversal\n+\n+               elsif Nkind_In (Stmt, N_Abstract_Subprogram_Declaration,\n+                                     N_Full_Type_Declaration,\n+                                     N_Generic_Subprogram_Declaration,\n+                                     N_Object_Declaration,\n+                                     N_Private_Extension_Declaration,\n+                                     N_Private_Type_Declaration,\n+                                     N_Subprogram_Declaration,\n+                                     N_Subtype_Declaration)\n+               then\n+                  Id := Defining_Entity (Stmt);\n+                  exit;\n+\n+               --  The pragma does not apply to a legal construct, issue an\n+               --  error and stop the analysis.\n+\n+               else\n+                  Error_Pragma\n+                    (\"pragma % must apply to an object, package, subprogram \"\n+                     & \"or type\");\n+                  return;\n+               end if;\n+\n+               Stmt := Prev (Stmt);\n+            end loop;\n+\n+            if No (Id) then\n+\n+               --  When pragma Ghost is associated with a [generic] package, it\n+               --  appears in the visible declarations.\n+\n+               if Nkind (Context) = N_Package_Specification\n+                 and then Present (Visible_Declarations (Context))\n+                 and then List_Containing (N) = Visible_Declarations (Context)\n+               then\n+                  Id := Defining_Entity (Context);\n+\n+               --  Pragma Ghost applies to a stand alone subprogram body\n+\n+               elsif Nkind (Context) = N_Subprogram_Body\n+                 and then No (Corresponding_Spec (Context))\n+               then\n+                  Id := Defining_Entity (Context);\n+               end if;\n+            end if;\n+\n+            if No (Id) then\n+               Error_Pragma\n+                 (\"pragma % must apply to an object, package, subprogram or \"\n+                  & \"type\");\n+               return;\n+            end if;\n+\n+            --  A derived type or type extension cannot be subject to pragma\n+            --  Ghost if either the parent type or one of the progenitor types\n+            --  is not Ghost (SPARK RM 6.9(9)).\n+\n+            if Is_Derived_Type (Id) then\n+               Check_Ghost_Derivation (Id);\n+            end if;\n+\n+            --  Handle completions of types and constants that are subject to\n+            --  pragma Ghost.\n+\n+            if Is_Record_Type (Id) or else Ekind (Id) = E_Constant then\n+               Prev_Id := Incomplete_Or_Partial_View (Id);\n+\n+               if Present (Prev_Id) and then not Is_Ghost_Entity (Prev_Id) then\n+                  Error_Msg_Name_1 := Pname;\n+\n+                  --  The full declaration of a deferred constant cannot be\n+                  --  subject to pragma Ghost unless the deferred declaration\n+                  --  is also Ghost (SPARK RM 6.9(10)).\n+\n+                  if Ekind (Prev_Id) = E_Constant then\n+                     Error_Msg_Name_1 := Pname;\n+                     Error_Msg_NE (Fix_Error\n+                       (\"pragma % must apply to declaration of deferred \"\n+                        & \"constant &\"), N, Id);\n+                     return;\n+\n+                  --  Pragma Ghost may appear on the full view of an incomplete\n+                  --  type because the incomplete declaration lacks aspects and\n+                  --  cannot be subject to pragma Ghost.\n+\n+                  elsif Ekind (Prev_Id) = E_Incomplete_Type then\n+                     null;\n+\n+                  --  The full declaration of a type cannot be subject to\n+                  --  pragma Ghost unless the partial view is also Ghost\n+                  --  (SPARK RM 6.9(10)).\n+\n+                  else\n+                     Error_Msg_NE (Fix_Error\n+                       (\"pragma % must apply to partial view of type &\"),\n+                        N, Id);\n+                     return;\n+                  end if;\n+               end if;\n+            end if;\n+\n+            --  Analyze the Boolean expression (if any)\n+\n+            if Present (Arg1) then\n+               Expr := Get_Pragma_Arg (Arg1);\n+\n+               Analyze_And_Resolve (Expr, Standard_Boolean);\n+\n+               if Is_OK_Static_Expression (Expr) then\n+\n+                  --  \"Ghostness\" cannot be turned off once enabled within a\n+                  --  region (SPARK RM 6.9(7)).\n+\n+                  if Is_False (Expr_Value (Expr))\n+                    and then Within_Ghost_Scope\n+                  then\n+                     Error_Pragma\n+                       (\"pragma % with value False cannot appear in enabled \"\n+                        & \"ghost region\");\n+                     return;\n+                  end if;\n+\n+               --  Otherwie the expression is not static\n+\n+               else\n+                  Error_Pragma_Arg\n+                    (\"expression of pragma % must be static\", Expr);\n+                  return;\n+               end if;\n+            end if;\n+\n+            Set_Is_Ghost_Entity (Id);\n+         end Ghost;\n+\n          ------------\n          -- Global --\n          ------------\n@@ -23087,6 +23315,12 @@ package body Sem_Prag is\n          -------------------------\n \n          procedure Analyze_Constituent (Constit : Node_Id) is\n+            procedure Check_Ghost_Constituent (Constit_Id : Entity_Id);\n+            --  Verify that the constituent Constit_Id is a Ghost entity if the\n+            --  abstract state being refined is also Ghost. If this is the case\n+            --  verify that the Ghost policy in effect at the point of state\n+            --  and constituent declaration is the same.\n+\n             procedure Check_Matching_Constituent (Constit_Id : Entity_Id);\n             --  Determine whether constituent Constit denoted by its entity\n             --  Constit_Id appears in Hidden_States. Emit an error when the\n@@ -23169,6 +23403,7 @@ package body Sem_Prag is\n \n                if Present (Encapsulating_State (Constit_Id)) then\n                   if Encapsulating_State (Constit_Id) = State_Id then\n+                     Check_Ghost_Constituent (Constit_Id);\n                      Remove (Part_Of_Constits, Constit_Id);\n                      Collect_Constituent;\n \n@@ -23197,6 +23432,8 @@ package body Sem_Prag is\n                         --  been encountered.\n \n                         if Node (State_Elmt) = Constit_Id then\n+                           Check_Ghost_Constituent (Constit_Id);\n+\n                            Remove_Elmt (Body_States, State_Elmt);\n                            Collect_Constituent;\n                            return;\n@@ -23217,6 +23454,59 @@ package body Sem_Prag is\n                end if;\n             end Check_Matching_Constituent;\n \n+            -----------------------------\n+            -- Check_Ghost_Constituent --\n+            -----------------------------\n+\n+            procedure Check_Ghost_Constituent (Constit_Id : Entity_Id) is\n+            begin\n+               if Is_Ghost_Entity (State_Id) then\n+                  if Is_Ghost_Entity (Constit_Id) then\n+\n+                     --  The Ghost policy in effect at the point of abstract\n+                     --  state declaration and constituent must match\n+                     --  (SPARK RM 6.9(15)).\n+\n+                     if Is_Checked_Ghost_Entity (State_Id)\n+                       and then Is_Ignored_Ghost_Entity (Constit_Id)\n+                     then\n+                        Error_Msg_Sloc := Sloc (Constit);\n+\n+                        SPARK_Msg_N\n+                          (\"incompatible ghost policies in effect\", State);\n+                        SPARK_Msg_NE\n+                          (\"\\abstract state & declared with ghost policy \"\n+                           & \"Check\", State, State_Id);\n+                        SPARK_Msg_NE\n+                          (\"\\constituent & declared # with ghost policy \"\n+                           & \"Ignore\", State, Constit_Id);\n+\n+                     elsif Is_Ignored_Ghost_Entity (State_Id)\n+                       and then Is_Checked_Ghost_Entity (Constit_Id)\n+                     then\n+                        Error_Msg_Sloc := Sloc (Constit);\n+\n+                        SPARK_Msg_N\n+                          (\"incompatible ghost policies in effect\", State);\n+                        SPARK_Msg_NE\n+                          (\"\\abstract state & declared with ghost policy \"\n+                           & \"Ignore\", State, State_Id);\n+                        SPARK_Msg_NE\n+                          (\"\\constituent & declared # with ghost policy \"\n+                           & \"Check\", State, Constit_Id);\n+                     end if;\n+\n+                  --  A constituent of a Ghost abstract state must be a Ghost\n+                  --  entity (SPARK RM 7.2.2(12)).\n+\n+                  else\n+                     SPARK_Msg_NE\n+                       (\"constituent of ghost state & must be ghost\",\n+                        Constit, State_Id);\n+                  end if;\n+               end if;\n+            end Check_Ghost_Constituent;\n+\n             --  Local variables\n \n             Constit_Id : Entity_Id;\n@@ -25075,6 +25365,7 @@ package body Sem_Prag is\n       Pragma_External_Name_Casing           =>  0,\n       Pragma_Fast_Math                      =>  0,\n       Pragma_Finalize_Storage_Only          =>  0,\n+      Pragma_Ghost                          =>  0,\n       Pragma_Global                         => -1,\n       Pragma_Ident                          => -1,\n       Pragma_Implementation_Defined         => -1,\n@@ -25466,6 +25757,7 @@ package body Sem_Prag is\n             Name_Contract_Cases            |\n             Name_Debug                     |\n             Name_Default_Initial_Condition |\n+            Name_Ghost                     |\n             Name_Initial_Condition         |\n             Name_Invariant                 |\n             Name_uInvariant                |"}, {"sha": "893e1e15ed8897b518e0f3cb4bbcd9a2ee07d341", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 234, "deletions": 27, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c", "patch": "@@ -109,6 +109,10 @@ package body Sem_Res is\n       Pref : Node_Id);\n    --  Check that the type of the prefix of a dereference is not incomplete\n \n+   procedure Check_Ghost_Context (Ghost_Id : Entity_Id; Ghost_Ref : Node_Id);\n+   --  Determine whether node Ghost_Ref appears within a Ghost-friendly context\n+   --  where Ghost entity Ghost_Id can safely reside.\n+\n    function Check_Infinite_Recursion (N : Node_Id) return Boolean;\n    --  Given a call node, N, which is known to occur immediately within the\n    --  subprogram being called, determines whether it is a detectable case of\n@@ -688,6 +692,193 @@ package body Sem_Res is\n       end if;\n    end Check_Fully_Declared_Prefix;\n \n+   -------------------------\n+   -- Check_Ghost_Context --\n+   -------------------------\n+\n+   procedure Check_Ghost_Context (Ghost_Id : Entity_Id; Ghost_Ref : Node_Id) is\n+      procedure Check_Ghost_Policy (Id : Entity_Id; Err_N : Node_Id);\n+      --  Verify that the Ghost policy at the point of declaration of entity Id\n+      --  matches the policy at the point of reference. If this is not the case\n+      --  emit an error at Err_N.\n+\n+      function Is_OK_Ghost_Context (Context : Node_Id) return Boolean;\n+      --  Determine whether node Context denotes a Ghost-friendly context where\n+      --  a Ghost entity can safely reside.\n+\n+      -------------------------\n+      -- Is_OK_Ghost_Context --\n+      -------------------------\n+\n+      function Is_OK_Ghost_Context (Context : Node_Id) return Boolean is\n+         function Is_Ghost_Declaration (Decl : Node_Id) return Boolean;\n+         --  Determine whether node Decl is a Ghost declaration or appears\n+         --  within a Ghost declaration.\n+\n+         --------------------------\n+         -- Is_Ghost_Declaration --\n+         --------------------------\n+\n+         function Is_Ghost_Declaration (Decl : Node_Id) return Boolean is\n+            Par       : Node_Id;\n+            Subp_Decl : Node_Id;\n+            Subp_Id   : Entity_Id;\n+\n+         begin\n+            --  Climb the parent chain looking for an object declaration\n+\n+            Par := Decl;\n+            while Present (Par) loop\n+               case Nkind (Par) is\n+                  when N_Abstract_Subprogram_Declaration        |\n+                       N_Exception_Declaration                  |\n+                       N_Exception_Renaming_Declaration         |\n+                       N_Full_Type_Declaration                  |\n+                       N_Generic_Function_Renaming_Declaration  |\n+                       N_Generic_Package_Declaration            |\n+                       N_Generic_Package_Renaming_Declaration   |\n+                       N_Generic_Procedure_Renaming_Declaration |\n+                       N_Generic_Subprogram_Declaration         |\n+                       N_Number_Declaration                     |\n+                       N_Object_Declaration                     |\n+                       N_Object_Renaming_Declaration            |\n+                       N_Package_Declaration                    |\n+                       N_Package_Renaming_Declaration           |\n+                       N_Private_Extension_Declaration          |\n+                       N_Private_Type_Declaration               |\n+                       N_Subprogram_Declaration                 |\n+                       N_Subprogram_Renaming_Declaration        |\n+                       N_Subtype_Declaration                    =>\n+                     return Is_Subject_To_Ghost (Par);\n+\n+                  when others                                   =>\n+                     null;\n+               end case;\n+\n+               --  Special cases\n+\n+               --  A reference to a Ghost entity may appear as the default\n+               --  expression of a formal parameter of a subprogram body. This\n+               --  context must be treated as suitable because the relation\n+               --  between the spec and the body has not been established and\n+               --  the body is not marked as Ghost yet. The real check was\n+               --  performed on the spec.\n+\n+               if Nkind (Par) = N_Parameter_Specification\n+                 and then Nkind (Parent (Parent (Par))) = N_Subprogram_Body\n+               then\n+                  return True;\n+\n+               --  References to Ghost entities may be relocated in internally\n+               --  generated bodies.\n+\n+               elsif Nkind (Par) = N_Subprogram_Body\n+                 and then not Comes_From_Source (Par)\n+               then\n+                  Subp_Id := Corresponding_Spec (Par);\n+\n+                  --  The original context is an expression function that has\n+                  --  been split into a spec and a body. The context is OK as\n+                  --  long as the the initial declaration is Ghost.\n+\n+                  if Present (Subp_Id) then\n+                     Subp_Decl :=\n+                       Original_Node (Unit_Declaration_Node (Subp_Id));\n+\n+                     if Nkind (Subp_Decl) = N_Expression_Function then\n+                        return Is_Subject_To_Ghost (Subp_Decl);\n+                     end if;\n+                  end if;\n+\n+                  --  Otherwise this is either an internal body or an internal\n+                  --  completion. Both are OK because the real check was done\n+                  --  before expansion activities.\n+\n+                  return True;\n+               end if;\n+\n+               --  Prevent the search from going too far\n+\n+               if Is_Body_Or_Package_Declaration (Par) then\n+                  return False;\n+               end if;\n+\n+               Par := Parent (Par);\n+            end loop;\n+\n+            return False;\n+         end Is_Ghost_Declaration;\n+\n+      --  Start of processing for Is_OK_Ghost_Context\n+\n+      begin\n+         --  The Ghost entity appears within an assertion expression\n+\n+         if In_Assertion_Expr > 0 then\n+            return True;\n+\n+         --  The Ghost entity is part of a declaration or its completion\n+\n+         elsif Is_Ghost_Declaration (Context) then\n+            return True;\n+\n+         --  The Ghost entity is referenced within a Ghost statement\n+\n+         elsif Is_Ghost_Statement_Or_Pragma (Context) then\n+            return True;\n+\n+         else\n+            return False;\n+         end if;\n+      end Is_OK_Ghost_Context;\n+\n+      ------------------------\n+      -- Check_Ghost_Policy --\n+      ------------------------\n+\n+      procedure Check_Ghost_Policy (Id : Entity_Id; Err_N : Node_Id) is\n+         Policy : constant Name_Id := Policy_In_Effect (Name_Ghost);\n+\n+      begin\n+         --  The Ghost policy in effect a the point of declaration and at the\n+         --  point of use must match (SPARK RM 6.9(13)).\n+\n+         if Is_Checked_Ghost_Entity (Id) and then Policy = Name_Ignore then\n+            Error_Msg_Sloc := Sloc (Err_N);\n+\n+            SPARK_Msg_N  (\"incompatible ghost policies in effect\", Err_N);\n+            SPARK_Msg_NE (\"\\& declared with ghost policy Check\", Err_N, Id);\n+            SPARK_Msg_NE (\"\\& used # with ghost policy Ignore\", Err_N, Id);\n+\n+         elsif Is_Ignored_Ghost_Entity (Id) and then Policy = Name_Check then\n+            Error_Msg_Sloc := Sloc (Err_N);\n+\n+            SPARK_Msg_N  (\"incompatible ghost policies in effect\", Err_N);\n+            SPARK_Msg_NE (\"\\& declared with ghost policy Ignore\", Err_N, Id);\n+            SPARK_Msg_NE (\"\\& used # with ghost policy Check\", Err_N, Id);\n+         end if;\n+      end Check_Ghost_Policy;\n+\n+   --  Start of processing for Check_Ghost_Context\n+\n+   begin\n+      --  Once it has been established that the reference to the Ghost entity\n+      --  is within a suitable context, ensure that the policy at the point of\n+      --  declaration and at the point of use match.\n+\n+      if Is_OK_Ghost_Context (Ghost_Ref) then\n+         Check_Ghost_Policy (Ghost_Id, Ghost_Ref);\n+\n+      --  Otherwise the Ghost entity appears in a non-Ghost context and affects\n+      --  its behavior or value.\n+\n+      else\n+         SPARK_Msg_N\n+           (\"ghost entity cannot appear in this context (SPARK RM 6.9(12))\",\n+            Ghost_Ref);\n+      end if;\n+   end Check_Ghost_Context;\n+\n    ------------------------------\n    -- Check_Infinite_Recursion --\n    ------------------------------\n@@ -5545,9 +5736,9 @@ package body Sem_Res is\n       end if;\n \n       if Is_Access_Subprogram_Type (Base_Type (Etype (Nam)))\n-         and then not Is_Access_Subprogram_Type (Base_Type (Typ))\n-         and then Nkind (Subp) /= N_Explicit_Dereference\n-         and then Present (Parameter_Associations (N))\n+        and then not Is_Access_Subprogram_Type (Base_Type (Typ))\n+        and then Nkind (Subp) /= N_Explicit_Dereference\n+        and then Present (Parameter_Associations (N))\n       then\n          --  The prefix is a parameterless function call that returns an access\n          --  to subprogram. If parameters are present in the current call, add\n@@ -5808,6 +5999,12 @@ package body Sem_Res is\n       Set_Is_Overloaded (Subp, False);\n       Set_Is_Overloaded (N, False);\n \n+      --  A Ghost entity must appear in a specific context\n+\n+      if Is_Ghost_Entity (Nam) and then Comes_From_Source (N) then\n+         Check_Ghost_Context (Nam, N);\n+      end if;\n+\n       --  If we are calling the current subprogram from immediately within its\n       --  body, then that is the case where we can sometimes detect cases of\n       --  infinite recursion statically. Do not try this in case restriction\n@@ -6855,38 +7052,48 @@ package body Sem_Res is\n          Par := Parent (Par);\n       end if;\n \n-      --  An effectively volatile object subject to enabled properties\n-      --  Async_Writers or Effective_Reads must appear in a specific context.\n       --  The following checks are only relevant when SPARK_Mode is on as they\n       --  are not standard Ada legality rules.\n \n-      if SPARK_Mode = On\n-        and then Is_Object (E)\n-        and then Is_Effectively_Volatile (E)\n-        and then Comes_From_Source (E)\n-        and then\n-          (Async_Writers_Enabled (E) or else Effective_Reads_Enabled (E))\n-      then\n-         --  The effectively volatile objects appears in a \"non-interfering\n-         --  context\" as defined in SPARK RM 7.1.3(13).\n+      if SPARK_Mode = On then\n \n-         if Is_OK_Volatile_Context (Par, N) then\n-            null;\n+         --  An effectively volatile object subject to enabled properties\n+         --  Async_Writers or Effective_Reads must appear in a specific\n+         --  context.\n+\n+         if Is_Object (E)\n+           and then Is_Effectively_Volatile (E)\n+           and then\n+             (Async_Writers_Enabled (E) or else Effective_Reads_Enabled (E))\n+           and then Comes_From_Source (N)\n+         then\n+            --  The effectively volatile objects appears in a \"non-interfering\n+            --  context\" as defined in SPARK RM 7.1.3(13).\n \n-         --  Assume that references to effectively volatile objects that appear\n-         --  as actual parameters in a procedure call are always legal. A full\n-         --  legality check is done when the actuals are resolved.\n+            if Is_OK_Volatile_Context (Par, N) then\n+               null;\n \n-         elsif Nkind (Par) = N_Procedure_Call_Statement then\n-            null;\n+            --  Assume that references to effectively volatile objects that\n+            --  appear as actual parameters in a procedure call are always\n+            --  legal. A full legality check is done when the actuals are\n+            --  resolved.\n \n-         --  Otherwise the context causes a side effect with respect to the\n-         --  effectively volatile object.\n+            elsif Nkind (Par) = N_Procedure_Call_Statement then\n+               null;\n \n-         else\n-            Error_Msg_N\n-              (\"volatile object cannot appear in this context \"\n-               & \"(SPARK RM 7.1.3(13))\", N);\n+            --  Otherwise the context causes a side effect with respect to the\n+            --  effectively volatile object.\n+\n+            else\n+               SPARK_Msg_N\n+                 (\"volatile object cannot appear in this context \"\n+                  & \"(SPARK RM 7.1.3(13))\", N);\n+            end if;\n+\n+         --  A Ghost entity must appear in a specific context\n+\n+         elsif Is_Ghost_Entity (E) and then Comes_From_Source (N) then\n+            Check_Ghost_Context (E, N);\n          end if;\n       end if;\n    end Resolve_Entity_Name;"}, {"sha": "793120f0bf664847aa81d905bc5a0e3944d1ab8e", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 420, "deletions": 12, "changes": 432, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c", "patch": "@@ -2669,6 +2669,82 @@ package body Sem_Util is\n       end if;\n    end Check_Function_Writable_Actuals;\n \n+   ----------------------------\n+   -- Check_Ghost_Completion --\n+   ----------------------------\n+\n+   procedure Check_Ghost_Completion\n+     (Partial_View : Entity_Id;\n+      Full_View    : Entity_Id)\n+   is\n+      Policy : constant Name_Id := Policy_In_Effect (Name_Ghost);\n+\n+   begin\n+      --  The Ghost policy in effect at the point of declaration and at the\n+      --  point of completion must match (SPARK RM 6.9(14)).\n+\n+      if Is_Checked_Ghost_Entity (Partial_View)\n+        and then Policy = Name_Ignore\n+      then\n+         Error_Msg_Sloc := Sloc (Full_View);\n+\n+         SPARK_Msg_N (\"incompatible ghost policies in effect\",   Partial_View);\n+         SPARK_Msg_N (\"\\& declared with ghost policy Check\",     Partial_View);\n+         SPARK_Msg_N (\"\\& completed # with ghost policy Ignore\", Partial_View);\n+\n+      elsif Is_Ignored_Ghost_Entity (Partial_View)\n+        and then Policy = Name_Check\n+      then\n+         Error_Msg_Sloc := Sloc (Full_View);\n+\n+         SPARK_Msg_N (\"incompatible ghost policies in effect\",  Partial_View);\n+         SPARK_Msg_N (\"\\& declared with ghost policy Ignore\",   Partial_View);\n+         SPARK_Msg_N (\"\\& completed # with ghost policy Check\", Partial_View);\n+      end if;\n+   end Check_Ghost_Completion;\n+\n+   ----------------------------\n+   -- Check_Ghost_Derivation --\n+   ----------------------------\n+\n+   procedure Check_Ghost_Derivation (Typ : Entity_Id) is\n+      Parent_Typ : constant Entity_Id := Etype (Typ);\n+      Iface      : Entity_Id;\n+      Iface_Elmt : Elmt_Id;\n+\n+   begin\n+      --  Allow untagged derivations from predefined types such as Integer as\n+      --  those are not Ghost by definition.\n+\n+      if Is_Scalar_Type (Typ) and then Parent_Typ = Base_Type (Typ) then\n+         null;\n+\n+      --  The parent type of a Ghost type extension must be Ghost\n+\n+      elsif not Is_Ghost_Entity (Parent_Typ) then\n+         SPARK_Msg_N  (\"type extension & cannot be ghost\", Typ);\n+         SPARK_Msg_NE (\"\\parent type & is not ghost\", Typ, Parent_Typ);\n+         return;\n+      end if;\n+\n+      --  All progenitors (if any) must be Ghost as well\n+\n+      if Is_Tagged_Type (Typ) and then Present (Interfaces (Typ)) then\n+         Iface_Elmt := First_Elmt (Interfaces (Typ));\n+         while Present (Iface_Elmt) loop\n+            Iface := Node (Iface_Elmt);\n+\n+            if not Is_Ghost_Entity (Iface) then\n+               SPARK_Msg_N  (\"type extension & cannot be ghost\", Typ);\n+               SPARK_Msg_NE (\"\\interface type & is not ghost\", Typ, Iface);\n+               return;\n+            end if;\n+\n+            Next_Elmt (Iface_Elmt);\n+         end loop;\n+      end if;\n+   end Check_Ghost_Derivation;\n+\n    --------------------------------\n    -- Check_Implicit_Dereference --\n    --------------------------------\n@@ -9306,15 +9382,15 @@ package body Sem_Util is\n    end In_Visible_Part;\n \n    --------------------------------\n-   -- Incomplete_Or_Private_View --\n+   -- Incomplete_Or_Partial_View --\n    --------------------------------\n \n-   function Incomplete_Or_Private_View (Typ : Entity_Id) return Entity_Id is\n+   function Incomplete_Or_Partial_View (Id : Entity_Id) return Entity_Id is\n       function Inspect_Decls\n         (Decls : List_Id;\n          Taft  : Boolean := False) return Entity_Id;\n-      --  Check whether a declarative region contains the incomplete or private\n-      --  view of Typ.\n+      --  Check whether a declarative region contains the incomplete or partial\n+      --  view of Id.\n \n       -------------------\n       -- Inspect_Decls --\n@@ -9347,7 +9423,7 @@ package body Sem_Util is\n \n             if Present (Match)\n               and then Present (Full_View (Match))\n-              and then Full_View (Match) = Typ\n+              and then Full_View (Match) = Id\n             then\n                return Match;\n             end if;\n@@ -9365,22 +9441,22 @@ package body Sem_Util is\n    --  Start of processing for Incomplete_Or_Partial_View\n \n    begin\n-      --  Incomplete type case\n+      --  Deferred constant or incomplete type case\n \n-      Prev := Current_Entity_In_Scope (Typ);\n+      Prev := Current_Entity_In_Scope (Id);\n \n       if Present (Prev)\n-        and then Is_Incomplete_Type (Prev)\n+        and then (Is_Incomplete_Type (Prev) or else Ekind (Prev) = E_Constant)\n         and then Present (Full_View (Prev))\n-        and then Full_View (Prev) = Typ\n+        and then Full_View (Prev) = Id\n       then\n          return Prev;\n       end if;\n \n       --  Private or Taft amendment type case\n \n       declare\n-         Pkg      : constant Entity_Id := Scope (Typ);\n+         Pkg      : constant Entity_Id := Scope (Id);\n          Pkg_Decl : Node_Id := Pkg;\n \n       begin\n@@ -9394,7 +9470,7 @@ package body Sem_Util is\n             --  of this is when the two views have been exchanged - the full\n             --  appears earlier than the private.\n \n-            if Has_Private_Declaration (Typ) then\n+            if Has_Private_Declaration (Id) then\n                Prev := Inspect_Decls (Visible_Declarations (Pkg_Decl));\n \n                --  Exchanged view case, look in the private declarations\n@@ -9418,7 +9494,7 @@ package body Sem_Util is\n       --  The type has no incomplete or private view\n \n       return Empty;\n-   end Incomplete_Or_Private_View;\n+   end Incomplete_Or_Partial_View;\n \n    -----------------------------------------\n    -- Inherit_Default_Init_Cond_Procedure --\n@@ -11085,6 +11161,110 @@ package body Sem_Util is\n       end if;\n    end Is_Fully_Initialized_Variant;\n \n+   ---------------------\n+   -- Is_Ghost_Entity --\n+   ---------------------\n+\n+   function Is_Ghost_Entity (Id : Entity_Id) return Boolean is\n+   begin\n+      return Is_Checked_Ghost_Entity (Id) or else Is_Ignored_Ghost_Entity (Id);\n+   end Is_Ghost_Entity;\n+\n+   ----------------------------------\n+   -- Is_Ghost_Statement_Or_Pragma --\n+   ----------------------------------\n+\n+   function Is_Ghost_Statement_Or_Pragma (N : Node_Id) return Boolean is\n+      function Is_Ghost_Entity_Reference (N : Node_Id) return Boolean;\n+      --  Determine whether an arbitrary node denotes a reference to a Ghost\n+      --  entity.\n+\n+      -------------------------------\n+      -- Is_Ghost_Entity_Reference --\n+      -------------------------------\n+\n+      function Is_Ghost_Entity_Reference (N : Node_Id) return Boolean is\n+         Ref : Node_Id;\n+\n+      begin\n+         Ref := N;\n+\n+         --  When the reference extracts a subcomponent, recover the related\n+         --  object (SPARK RM 6.9(1)).\n+\n+         while Nkind_In (Ref, N_Explicit_Dereference,\n+                              N_Indexed_Component,\n+                              N_Selected_Component,\n+                              N_Slice)\n+         loop\n+            Ref := Prefix (Ref);\n+         end loop;\n+\n+         return\n+           Is_Entity_Name (Ref)\n+             and then Present (Entity (Ref))\n+             and then Is_Ghost_Entity (Entity (Ref));\n+      end Is_Ghost_Entity_Reference;\n+\n+      --  Local variables\n+\n+      Arg  : Node_Id;\n+      Stmt : Node_Id;\n+\n+   --  Start of processing for Is_Ghost_Statement_Or_Pragma\n+\n+   begin\n+      if Nkind (N) = N_Pragma then\n+\n+         --  A pragma is Ghost when it appears within a Ghost package or\n+         --  subprogram.\n+\n+         if Within_Ghost_Scope then\n+            return True;\n+         end if;\n+\n+         --  A pragma is Ghost when it mentions a Ghost entity\n+\n+         Arg := First (Pragma_Argument_Associations (N));\n+         while Present (Arg) loop\n+            if Is_Ghost_Entity_Reference (Get_Pragma_Arg (Arg)) then\n+               return True;\n+            end if;\n+\n+            Next (Arg);\n+         end loop;\n+      end if;\n+\n+      Stmt := N;\n+      while Present (Stmt) loop\n+\n+         --  A statement is Ghost when it appears within a Ghost package or\n+         --  subprogram.\n+\n+         if Is_Statement (Stmt) and then Within_Ghost_Scope then\n+            return True;\n+\n+         --  An assignment statement is Ghost when the target is a Ghost\n+         --  variable. A procedure call is Ghost when the invoked procedure\n+         --  is Ghost.\n+\n+         elsif Nkind_In (Stmt, N_Assignment_Statement,\n+                               N_Procedure_Call_Statement)\n+         then\n+            return Is_Ghost_Entity_Reference (Name (Stmt));\n+\n+         --  Prevent the search from going too far\n+\n+         elsif Is_Body_Or_Package_Declaration (Stmt) then\n+            return False;\n+         end if;\n+\n+         Stmt := Parent (Stmt);\n+      end loop;\n+\n+      return False;\n+   end Is_Ghost_Statement_Or_Pragma;\n+\n    ----------------------------\n    -- Is_Inherited_Operation --\n    ----------------------------\n@@ -12177,6 +12357,123 @@ package body Sem_Util is\n           or else Nkind (N) = N_Procedure_Call_Statement;\n    end Is_Statement;\n \n+   -------------------------\n+   -- Is_Subject_To_Ghost --\n+   -------------------------\n+\n+   function Is_Subject_To_Ghost (N : Node_Id) return Boolean is\n+      function Enables_Ghostness (Arg : Node_Id) return Boolean;\n+      --  Determine whether aspect or pragma argument Arg enables \"ghostness\"\n+\n+      -----------------------\n+      -- Enables_Ghostness --\n+      -----------------------\n+\n+      function Enables_Ghostness (Arg : Node_Id) return Boolean is\n+         Expr : Node_Id;\n+\n+      begin\n+         Expr := Arg;\n+\n+         if Nkind (Expr) = N_Pragma_Argument_Association then\n+            Expr := Get_Pragma_Arg (Expr);\n+         end if;\n+\n+         --  Determine whether the expression of the aspect is static and\n+         --  denotes True.\n+\n+         if Present (Expr) then\n+            Preanalyze_And_Resolve (Expr);\n+\n+            return\n+              Is_OK_Static_Expression (Expr)\n+                and then Is_True (Expr_Value (Expr));\n+\n+         --  Otherwise Ghost defaults to True\n+\n+         else\n+            return True;\n+         end if;\n+      end Enables_Ghostness;\n+\n+      --  Local variables\n+\n+      Id      : constant Entity_Id := Defining_Entity (N);\n+      Asp     : Node_Id;\n+      Decl    : Node_Id;\n+      Prev_Id : Entity_Id;\n+\n+   --  Start of processing for Is_Subject_To_Ghost\n+\n+   begin\n+      if Is_Ghost_Entity (Id) then\n+         return True;\n+\n+      --  The completion of a type or a constant is not fully analyzed when the\n+      --  reference to the Ghost entity is resolved. Because the completion is\n+      --  not marked as Ghost yet, inspect the partial view.\n+\n+      elsif Is_Record_Type (Id)\n+        or else Ekind (Id) = E_Constant\n+        or else (Nkind (N) = N_Object_Declaration\n+                  and then Constant_Present (N))\n+      then\n+         Prev_Id := Incomplete_Or_Partial_View (Id);\n+\n+         if Present (Prev_Id) and then Is_Ghost_Entity (Prev_Id) then\n+            return True;\n+         end if;\n+      end if;\n+\n+      --  Examine the aspect specifications (if any) looking for aspect Ghost\n+\n+      if Permits_Aspect_Specifications (N) then\n+         Asp := First (Aspect_Specifications (N));\n+         while Present (Asp) loop\n+            if Chars (Identifier (Asp)) = Name_Ghost then\n+               return Enables_Ghostness (Expression (Asp));\n+            end if;\n+\n+            Next (Asp);\n+         end loop;\n+      end if;\n+\n+      Decl := Empty;\n+\n+      --  When the context is a [generic] package declaration, pragma Ghost\n+      --  resides in the visible declarations.\n+\n+      if Nkind_In (N, N_Generic_Package_Declaration,\n+                      N_Package_Declaration)\n+      then\n+         Decl := First (Visible_Declarations (Specification (N)));\n+\n+      --  Otherwise pragma Ghost appears in the declarations following N\n+\n+      elsif Is_List_Member (N) then\n+         Decl := Next (N);\n+      end if;\n+\n+      while Present (Decl) loop\n+         if Nkind (Decl) = N_Pragma\n+           and then Pragma_Name (Decl) = Name_Ghost\n+         then\n+            return\n+              Enables_Ghostness (First (Pragma_Argument_Associations (Decl)));\n+\n+         --  A source construct ends the region where pragma Ghost may appear,\n+         --  stop the traversal.\n+\n+         elsif Comes_From_Source (Decl) then\n+            exit;\n+         end if;\n+\n+         Next (Decl);\n+      end loop;\n+\n+      return False;\n+   end Is_Subject_To_Ghost;\n+\n    --------------------------------------------------\n    -- Is_Subprogram_Stub_Without_Prior_Declaration --\n    --------------------------------------------------\n@@ -15316,6 +15613,77 @@ package body Sem_Util is\n       end if;\n    end Original_Corresponding_Operation;\n \n+   ----------------------\n+   -- Policy_In_Effect --\n+   ----------------------\n+\n+   function Policy_In_Effect (Policy : Name_Id) return Name_Id is\n+      function Policy_In_List (List : Node_Id) return Name_Id;\n+      --  Determine the the mode of a policy in a N_Pragma list\n+\n+      --------------------\n+      -- Policy_In_List --\n+      --------------------\n+\n+      function Policy_In_List (List : Node_Id) return Name_Id is\n+         Arg  : Node_Id;\n+         Expr : Node_Id;\n+         Prag : Node_Id;\n+\n+      begin\n+         Prag := List;\n+         while Present (Prag) loop\n+            Arg  := First (Pragma_Argument_Associations (Prag));\n+            Expr := Get_Pragma_Arg (Arg);\n+\n+            --  The current Check_Policy pragma matches the requested policy,\n+            --  return the second argument which denotes the policy identifier.\n+\n+            if Chars (Expr) = Policy then\n+               return Chars (Get_Pragma_Arg (Next (Arg)));\n+            end if;\n+\n+            Prag := Next_Pragma (Prag);\n+         end loop;\n+\n+         return No_Name;\n+      end Policy_In_List;\n+\n+      --  Local variables\n+\n+      Kind : Name_Id;\n+\n+   --  Start of processing for Policy_In_Effect\n+\n+   begin\n+      if not Is_Valid_Assertion_Kind (Policy) then\n+         raise Program_Error;\n+      end if;\n+\n+      --  Inspect all policy pragmas that appear within scopes (if any)\n+\n+      Kind := Policy_In_List (Check_Policy_List);\n+\n+      --  Inspect all configuration policy pragmas (if any)\n+\n+      if Kind = No_Name then\n+         Kind := Policy_In_List (Check_Policy_List_Config);\n+      end if;\n+\n+      --  The context lacks policy pragmas, determine the mode based on whether\n+      --  assertions are enabled.\n+\n+      if Kind = No_Name then\n+         if Assertions_Enabled then\n+            Kind := Name_Check;\n+         else\n+            Kind := Name_Ignore;\n+         end if;\n+      end if;\n+\n+      return Kind;\n+   end Policy_In_Effect;\n+\n    ----------------------------------\n    -- Predicate_Tests_On_Arguments --\n    ----------------------------------\n@@ -16825,6 +17193,22 @@ package body Sem_Util is\n       Set_Entity (N, Val);\n    end Set_Entity_With_Checks;\n \n+   -------------------------\n+   -- Set_Is_Ghost_Entity --\n+   -------------------------\n+\n+   procedure Set_Is_Ghost_Entity (Id : Entity_Id) is\n+      Policy : constant Name_Id := Policy_In_Effect (Name_Ghost);\n+\n+   begin\n+      if Policy = Name_Check then\n+         Set_Is_Checked_Ghost_Entity (Id);\n+\n+      elsif Policy = Name_Ignore then\n+         Set_Is_Ignored_Ghost_Entity (Id);\n+      end if;\n+   end Set_Is_Ghost_Entity;\n+\n    ------------------------\n    -- Set_Name_Entity_Id --\n    ------------------------\n@@ -17718,6 +18102,30 @@ package body Sem_Util is\n       return List_1;\n    end Visible_Ancestors;\n \n+   ------------------------\n+   -- Within_Ghost_Scope --\n+   ------------------------\n+\n+   function Within_Ghost_Scope\n+     (Id : Entity_Id := Current_Scope) return Boolean\n+   is\n+      S : Entity_Id;\n+\n+   begin\n+      --  Climb the scope stack looking for a Ghost scope\n+\n+      S := Id;\n+      while Present (S) and then S /= Standard_Standard loop\n+         if Is_Ghost_Entity (S) then\n+            return True;\n+         end if;\n+\n+         S := Scope (S);\n+      end loop;\n+\n+      return False;\n+   end Within_Ghost_Scope;\n+\n    ----------------------\n    -- Within_Init_Proc --\n    ----------------------"}, {"sha": "ff9c1697f94b1a37f183dc52f7f56ba4e4dbc110", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 47, "deletions": 4, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c", "patch": "@@ -285,6 +285,17 @@ package Sem_Util is\n    --  the one containing C2, that is known to refer to the same object (RM\n    --  6.4.1(6.17/3)).\n \n+   procedure Check_Ghost_Completion\n+     (Partial_View : Entity_Id;\n+      Full_View    : Entity_Id);\n+   --  Verify that the Ghost policy of a full view or a completion is the same\n+   --  as the Ghost policy of the partial view. Emit an error if this is not\n+   --  the case.\n+\n+   procedure Check_Ghost_Derivation (Typ : Entity_Id);\n+   --  Verify that the parent type and all progenitors of derived type or type\n+   --  extension Typ are Ghost. If this is not the case, issue an error.\n+\n    procedure Check_Implicit_Dereference (N : Node_Id; Typ : Entity_Id);\n    --  AI05-139-2: Accessors and iterators for containers. This procedure\n    --  checks whether T is a reference type, and if so it adds an interprettion\n@@ -1097,10 +1108,10 @@ package Sem_Util is\n    --  package specification. The package must be on the scope stack, and the\n    --  corresponding private part must not.\n \n-   function Incomplete_Or_Private_View (Typ : Entity_Id) return Entity_Id;\n-   --  Given the entity of a type, retrieve the incomplete or private view of\n-   --  the same type. Note that Typ may not have a partial view to begin with,\n-   --  in that case the function returns Empty.\n+   function Incomplete_Or_Partial_View (Id : Entity_Id) return Entity_Id;\n+   --  Given the entity of a constant or a type, retrieve the incomplete or\n+   --  partial view of the same entity. Note that Id may not have a partial\n+   --  view in which case the function returns Empty.\n \n    procedure Inherit_Default_Init_Cond_Procedure (Typ : Entity_Id);\n    --  Inherit the default initial condition procedure from the parent type of\n@@ -1268,6 +1279,18 @@ package Sem_Util is\n    --  means that the result returned is not crucial, but should err on the\n    --  side of thinking things are fully initialized if it does not know.\n \n+   function Is_Ghost_Entity (Id : Entity_Id) return Boolean;\n+   --  Determine whether entity Id is Ghost. To qualify as such, the entity\n+   --  must be subject to Convention Ghost.\n+\n+   function Is_Ghost_Statement_Or_Pragma (N : Node_Id) return Boolean;\n+   --  Determine whether statement or pragma N is ghost. To qualify as such, N\n+   --  must either\n+   --    1) Occur within a ghost subprogram or package\n+   --    2) Denote a call to a ghost procedure\n+   --    3) Denote an assignment statement whose target is a ghost variable\n+   --    4) Denote a pragma that mentions a ghost entity\n+\n    function Is_Inherited_Operation (E : Entity_Id) return Boolean;\n    --  E is a subprogram. Return True is E is an implicit operation inherited\n    --  by a derived type declaration.\n@@ -1396,6 +1419,12 @@ package Sem_Util is\n    --  the N_Statement_Other_Than_Procedure_Call subtype from Sinfo).\n    --  Note that a label is *not* a statement, and will return False.\n \n+   function Is_Subject_To_Ghost (N : Node_Id) return Boolean;\n+   --  Determine whether declarative node N is subject to aspect or pragma\n+   --  Ghost. Use this routine in cases where [source] pragma Ghost has not\n+   --  been analyzed yet, but the context needs to establish the \"ghostness\"\n+   --  of N.\n+\n    function Is_Subprogram_Stub_Without_Prior_Declaration\n      (N : Node_Id) return Boolean;\n    --  Return True if N is a subprogram stub with no prior subprogram\n@@ -1680,6 +1709,10 @@ package Sem_Util is\n    --  Name_uPre, Name_uPost, Name_uInvariant, or Name_uType_Invariant being\n    --  returned to represent the corresponding aspects with x'Class names.\n \n+   function Policy_In_Effect (Policy : Name_Id) return Name_Id;\n+   --  Given a policy, return the policy identifier associated with it. If no\n+   --  such policy is in effect, the value returned is No_Name.\n+\n    function Predicate_Tests_On_Arguments (Subp : Entity_Id) return Boolean;\n    --  Subp is the entity for a subprogram call. This function returns True if\n    --  predicate tests are required for the arguments in this call (this is the\n@@ -1881,6 +1914,10 @@ package Sem_Util is\n    --    If restriction No_Implementation_Identifiers is set, then it checks\n    --    that the entity is not implementation defined.\n \n+   procedure Set_Is_Ghost_Entity (Id : Entity_Id);\n+   --  Set the relevant ghost attribute of entity Id depending on the current\n+   --  Ghost assertion policy in effect.\n+\n    procedure Set_Name_Entity_Id (Id : Name_Id; Val : Entity_Id);\n    pragma Inline (Set_Name_Entity_Id);\n    --  Sets the Entity_Id value associated with the given name, which is the\n@@ -2008,6 +2045,12 @@ package Sem_Util is\n    --  generate the list of visible ancestors; otherwise their partial\n    --  view is added to the resulting list.\n \n+   function Within_Ghost_Scope\n+     (Id : Entity_Id := Current_Scope) return Boolean;\n+   --  Determine whether an arbitrary entity is either a scope or within a\n+   --  scope subject to convention Ghost or one that inherits \"ghostness\" from\n+   --  an enclosing construct.\n+\n    function Within_Init_Proc return Boolean;\n    --  Determines if Current_Scope is within an init proc\n "}, {"sha": "a198c428af55576ab22f93c569c12759d6b84822", "filename": "gcc/ada/snames.adb-tmpl", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2Fsnames.adb-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2Fsnames.adb-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.adb-tmpl?ref=c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c", "patch": "@@ -155,7 +155,6 @@ package body Snames is\n          when Name_COBOL                 => return Convention_COBOL;\n          when Name_CPP                   => return Convention_CPP;\n          when Name_Fortran               => return Convention_Fortran;\n-         when Name_Ghost                 => return Convention_Ghost;\n          when Name_Intrinsic             => return Convention_Intrinsic;\n          when Name_Java                  => return Convention_Java;\n          when Name_Stdcall               => return Convention_Stdcall;\n@@ -193,7 +192,6 @@ package body Snames is\n          when Convention_CPP                   => return Name_CPP;\n          when Convention_Entry                 => return Name_Entry;\n          when Convention_Fortran               => return Name_Fortran;\n-         when Convention_Ghost                 => return Name_Ghost;\n          when Convention_Intrinsic             => return Name_Intrinsic;\n          when Convention_Java                  => return Name_Java;\n          when Convention_Protected             => return Name_Protected;"}, {"sha": "16ebf6ab142ced3b8b7bea7cbf4f8812024e68e3", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=c5cec2fe71b243a3a4e76ef41b2ed6b36a3d543c", "patch": "@@ -497,6 +497,7 @@ package Snames is\n    Name_Extensions_Visible             : constant Name_Id := N + $; -- GNAT\n    Name_External                       : constant Name_Id := N + $; -- GNAT\n    Name_Finalize_Storage_Only          : constant Name_Id := N + $; -- GNAT\n+   Name_Ghost                          : constant Name_Id := N + $; -- GNAT\n    Name_Global                         : constant Name_Id := N + $; -- GNAT\n    Name_Ident                          : constant Name_Id := N + $; -- GNAT\n    Name_Implementation_Defined         : constant Name_Id := N + $; -- GNAT\n@@ -650,7 +651,6 @@ package Snames is\n    Name_COBOL                          : constant Name_Id := N + $;\n    Name_CPP                            : constant Name_Id := N + $;\n    Name_Fortran                        : constant Name_Id := N + $;\n-   Name_Ghost                          : constant Name_Id := N + $;\n    Name_Intrinsic                      : constant Name_Id := N + $;\n    Name_Java                           : constant Name_Id := N + $;\n    Name_Stdcall                        : constant Name_Id := N + $;\n@@ -1651,12 +1651,11 @@ package Snames is\n    type Convention_Id is (\n \n       --  The native-to-Ada (non-foreign) conventions come first. These include\n-      --  the ones defined in the RM, plus Ghost and Stubbed.\n+      --  the ones defined in the RM, plus Stubbed.\n \n       Convention_Ada,\n       Convention_Intrinsic,\n       Convention_Entry,\n-      Convention_Ghost,\n       Convention_Protected,\n       Convention_Stubbed,\n \n@@ -1832,6 +1831,7 @@ package Snames is\n       Pragma_Extensions_Visible,\n       Pragma_External,\n       Pragma_Finalize_Storage_Only,\n+      Pragma_Ghost,\n       Pragma_Global,\n       Pragma_Ident,\n       Pragma_Implementation_Defined,"}]}