{"sha": "ac3cbee587c9d65ba8d5be751c8c74ad9ba4c930", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWMzY2JlZTU4N2M5ZDY1YmE4ZDViZTc1MWM4Yzc0YWQ5YmE0YzkzMA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2009-07-22T08:43:19Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2009-07-22T08:43:19Z"}, "message": "re PR c++/40799 (Revision 149750 failed 483.xalancbmk in SPEC CPU 2006)\n\n2009-07-22  Richard Guenther  <rguenther@suse.de>\n\n\tPR c++/40799\n\t* cp-gimplify.c (cp_gimplify_expr): Move handling of using\n\trelated exprs to ...\n\t(cp_genericize_r): ... genericization stage.\n\t(cp_genericize): Adjust.\n\n\t* g++.dg/lookup/using21.C: New testcase.\n\nFrom-SVN: r149919", "tree": {"sha": "f9a913388a71cb7931fe2fcf827fa9ae741cca2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f9a913388a71cb7931fe2fcf827fa9ae741cca2c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac3cbee587c9d65ba8d5be751c8c74ad9ba4c930", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac3cbee587c9d65ba8d5be751c8c74ad9ba4c930", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac3cbee587c9d65ba8d5be751c8c74ad9ba4c930", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac3cbee587c9d65ba8d5be751c8c74ad9ba4c930/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "43ce5e5260d0e439a7a4896625e7c3e7c4464bce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43ce5e5260d0e439a7a4896625e7c3e7c4464bce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43ce5e5260d0e439a7a4896625e7c3e7c4464bce"}], "stats": {"total": 144, "additions": 105, "deletions": 39}, "files": [{"sha": "c86770ed2ef5d5483600886fd53f3bcf49e33c4f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac3cbee587c9d65ba8d5be751c8c74ad9ba4c930/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac3cbee587c9d65ba8d5be751c8c74ad9ba4c930/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ac3cbee587c9d65ba8d5be751c8c74ad9ba4c930", "patch": "@@ -1,3 +1,11 @@\n+2009-07-22  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR c++/40799\n+\t* cp-gimplify.c (cp_gimplify_expr): Move handling of using\n+\trelated exprs to ...\n+\t(cp_genericize_r): ... genericization stage.\n+\t(cp_genericize): Adjust.\n+\n 2009-07-21  Jason Merrill  <jason@redhat.com>\n \n \tCore issue 934"}, {"sha": "184ae9e3072f713c9b4ab8df67636f0d81c00887", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 66, "deletions": 39, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac3cbee587c9d65ba8d5be751c8c74ad9ba4c930/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac3cbee587c9d65ba8d5be751c8c74ad9ba4c930/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=ac3cbee587c9d65ba8d5be751c8c74ad9ba4c930", "patch": "@@ -503,8 +503,6 @@ cp_gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n   int saved_stmts_are_full_exprs_p = 0;\n   enum tree_code code = TREE_CODE (*expr_p);\n   enum gimplify_status ret;\n-  tree block = NULL;\n-  VEC(gimple, heap) *bind_expr_stack = NULL;\n \n   if (STATEMENT_CODE_P (code))\n     {\n@@ -571,37 +569,7 @@ cp_gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n       break;\n \n     case USING_STMT:\n-      /* Get the innermost inclosing GIMPLE_BIND that has a non NULL\n-         BLOCK, and append an IMPORTED_DECL to its\n-\t BLOCK_VARS chained list.  */\n-\n-      bind_expr_stack = gimple_bind_expr_stack ();\n-      if (bind_expr_stack)\n-\t{\n-\t  int i;\n-\t  for (i = VEC_length (gimple, bind_expr_stack) - 1; i >= 0; i--)\n-\t    if ((block = gimple_bind_block (VEC_index (gimple,\n-\t\t\t\t\t\t       bind_expr_stack,\n-\t\t\t\t\t\t       i))))\n-\t      break;\n-\t}\n-      if (block)\n-\t{\n-\t  tree using_directive;\n-\t  gcc_assert (TREE_OPERAND (*expr_p, 0));\n-\n-\t  using_directive = make_node (IMPORTED_DECL);\n-\t  TREE_TYPE (using_directive) = void_type_node;\n-\n-\t  IMPORTED_DECL_ASSOCIATED_DECL (using_directive)\n-\t    = TREE_OPERAND (*expr_p, 0);\n-\t  TREE_CHAIN (using_directive) = BLOCK_VARS (block);\n-\t  BLOCK_VARS (block) = using_directive;\n-\t}\n-      /* The USING_STMT won't appear in GIMPLE.  */\n-      *expr_p = NULL;\n-      ret = GS_ALL_DONE;\n-      break;\n+      gcc_unreachable ();\n \n     case FOR_STMT:\n       gimplify_for_stmt (expr_p, pre_p);\n@@ -693,14 +661,21 @@ cxx_int_tree_map_hash (const void *item)\n   return ((const struct cxx_int_tree_map *)item)->uid;\n }\n \n+struct cp_genericize_data\n+{\n+  struct pointer_set_t *p_set;\n+  VEC (tree, heap) *bind_expr_stack;\n+};\n+\n /* Perform any pre-gimplification lowering of C++ front end trees to\n    GENERIC.  */\n \n static tree\n cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n {\n   tree stmt = *stmt_p;\n-  struct pointer_set_t *p_set = (struct pointer_set_t*) data;\n+  struct cp_genericize_data *wtd = (struct cp_genericize_data *) data;\n+  struct pointer_set_t *p_set = wtd->p_set;\n \n   if (is_invisiref_parm (stmt)\n       /* Don't dereference parms in a thunk, pass the references through. */\n@@ -759,7 +734,7 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n \t    *walk_subtrees = 0;\n \t    if (OMP_CLAUSE_LASTPRIVATE_STMT (stmt))\n \t      cp_walk_tree (&OMP_CLAUSE_LASTPRIVATE_STMT (stmt),\n-\t\t\t    cp_genericize_r, p_set, NULL);\n+\t\t\t    cp_genericize_r, data, NULL);\n \t  }\n \tbreak;\n       case OMP_CLAUSE_PRIVATE:\n@@ -829,6 +804,56 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n \t}\n     }\n \n+  else if (TREE_CODE (stmt) == BIND_EXPR)\n+    {\n+      VEC_safe_push (tree, heap, wtd->bind_expr_stack, stmt);\n+      cp_walk_tree (&BIND_EXPR_BODY (stmt),\n+\t\t    cp_genericize_r, data, NULL);\n+      VEC_pop (tree, wtd->bind_expr_stack);\n+      *walk_subtrees = 0;\n+    }\n+\n+  else if (TREE_CODE (stmt) == USING_STMT)\n+    {\n+      tree block = NULL_TREE;\n+\n+      /* Get the innermost inclosing GIMPLE_BIND that has a non NULL\n+         BLOCK, and append an IMPORTED_DECL to its\n+\t BLOCK_VARS chained list.  */\n+      if (wtd->bind_expr_stack)\n+\t{\n+\t  int i;\n+\t  for (i = VEC_length (tree, wtd->bind_expr_stack) - 1; i >= 0; i--)\n+\t    if ((block = BIND_EXPR_BLOCK (VEC_index (tree,\n+\t\t\t\t\t\t     wtd->bind_expr_stack, i))))\n+\t      break;\n+\t}\n+      if (block)\n+\t{\n+\t  tree using_directive;\n+\t  gcc_assert (TREE_OPERAND (stmt, 0));\n+\n+\t  using_directive = make_node (IMPORTED_DECL);\n+\t  TREE_TYPE (using_directive) = void_type_node;\n+\n+\t  IMPORTED_DECL_ASSOCIATED_DECL (using_directive)\n+\t    = TREE_OPERAND (stmt, 0);\n+\t  TREE_CHAIN (using_directive) = BLOCK_VARS (block);\n+\t  BLOCK_VARS (block) = using_directive;\n+\t}\n+      /* The USING_STMT won't appear in GENERIC.  */\n+      *stmt_p = build1 (NOP_EXPR, void_type_node, integer_zero_node);\n+      *walk_subtrees = 0;\n+    }\n+\n+  else if (TREE_CODE (stmt) == DECL_EXPR\n+\t   && TREE_CODE (DECL_EXPR_DECL (stmt)) == USING_DECL)\n+    {\n+      /* Using decls inside DECL_EXPRs are just dropped on the floor.  */\n+      *stmt_p = build1 (NOP_EXPR, void_type_node, integer_zero_node);\n+      *walk_subtrees = 0;\n+    }\n+\n   pointer_set_insert (p_set, *stmt_p);\n \n   return NULL;\n@@ -838,7 +863,7 @@ void\n cp_genericize (tree fndecl)\n {\n   tree t;\n-  struct pointer_set_t *p_set;\n+  struct cp_genericize_data wtd;\n \n   /* Fix up the types of parms passed by invisible reference.  */\n   for (t = DECL_ARGUMENTS (fndecl); t; t = TREE_CHAIN (t))\n@@ -872,9 +897,11 @@ cp_genericize (tree fndecl)\n \n   /* We do want to see every occurrence of the parms, so we can't just use\n      walk_tree's hash functionality.  */\n-  p_set = pointer_set_create ();\n-  cp_walk_tree (&DECL_SAVED_TREE (fndecl), cp_genericize_r, p_set, NULL);\n-  pointer_set_destroy (p_set);\n+  wtd.p_set = pointer_set_create ();\n+  wtd.bind_expr_stack = NULL;\n+  cp_walk_tree (&DECL_SAVED_TREE (fndecl), cp_genericize_r, &wtd, NULL);\n+  pointer_set_destroy (wtd.p_set);\n+  VEC_free (tree, heap, wtd.bind_expr_stack);\n \n   /* Do everything else.  */\n   c_genericize (fndecl);"}, {"sha": "4f4e247c1bb8e1c5c7f14787f2b07a12ffa01b64", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac3cbee587c9d65ba8d5be751c8c74ad9ba4c930/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac3cbee587c9d65ba8d5be751c8c74ad9ba4c930/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ac3cbee587c9d65ba8d5be751c8c74ad9ba4c930", "patch": "@@ -1,3 +1,8 @@\n+2009-07-22  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR c++/40799\n+\t* g++.dg/lookup/using21.C: New testcase.\n+\n 2009-07-21  Jason Merrill  <jason@redhat.com>\n \n \t* g++.dg/init/aggr4.C: New."}, {"sha": "30f18c59e34e4df0012bf40da2a6a661a5a3abde", "filename": "gcc/testsuite/g++.dg/lookup/using21.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac3cbee587c9d65ba8d5be751c8c74ad9ba4c930/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fusing21.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac3cbee587c9d65ba8d5be751c8c74ad9ba4c930/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fusing21.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fusing21.C?ref=ac3cbee587c9d65ba8d5be751c8c74ad9ba4c930", "patch": "@@ -0,0 +1,26 @@\n+// PR c++/40799\n+\n+namespace Bar {\n+  typedef int A;\n+}\n+class CollectionDeleteGuard {\n+public:\n+  CollectionDeleteGuard(int);\n+};\n+CollectionDeleteGuard::CollectionDeleteGuard(int)\n+{\n+  using Bar::A;\n+}\n+// PR c++/40799\n+\n+namespace Bar {\n+  typedef int A;\n+};\n+class CollectionDeleteGuard {\n+public:\n+  CollectionDeleteGuard(int);\n+};\n+CollectionDeleteGuard::CollectionDeleteGuard(int)\n+{\n+  using Bar::A;\n+}"}]}