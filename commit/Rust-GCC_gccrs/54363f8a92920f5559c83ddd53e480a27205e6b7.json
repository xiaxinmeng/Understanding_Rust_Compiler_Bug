{"sha": "54363f8a92920f5559c83ddd53e480a27205e6b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQzNjNmOGE5MjkyMGY1NTU5YzgzZGRkNTNlNDgwYTI3MjA1ZTZiNw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-12-09T23:28:01Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-12-09T23:28:01Z"}, "message": "re PR lto/61886 (LTO breaks fread with _FORTIFY_SOURCE=2)\n\n\n\tPR ipa/61886\n\tPR middle-end/25140\n\t* tree-ssa-alias.c (ptr_deref_may_alias_decl_p): Use compare_base_decls\n\t(nonoverlapping_component_refs_of_decl_p): Update sanity check.\n\t(decl_refs_may_alias_p): Use compare_base_decls.\n\t* alias.c: Include cgraph.h\n\t(rtx_equal_for_memref_p): Use rtx_equal_for_memref_p.\n\t(compare_base_decls): New function.\n\t(base_alias_check): Likewise.\n\t(memrefs_conflict_p): Likewise.\n\t(nonoverlapping_memrefs_p): Likewise.\n\t* alias.h (compare_base_decls): Declare.\n\n\t* gcc.c-torture/execute/alias-2.c: New testcase.\n\nFrom-SVN: r231478", "tree": {"sha": "8ef2dd128c31080dac218b7c43d96a8c2b68c98a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8ef2dd128c31080dac218b7c43d96a8c2b68c98a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/54363f8a92920f5559c83ddd53e480a27205e6b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54363f8a92920f5559c83ddd53e480a27205e6b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54363f8a92920f5559c83ddd53e480a27205e6b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54363f8a92920f5559c83ddd53e480a27205e6b7/comments", "author": null, "committer": null, "parents": [{"sha": "da20571a7c2a7e44ccd5999356b1131f9aa6b2de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da20571a7c2a7e44ccd5999356b1131f9aa6b2de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da20571a7c2a7e44ccd5999356b1131f9aa6b2de"}], "stats": {"total": 133, "additions": 126, "deletions": 7}, "files": [{"sha": "13d31852a9077145741c802e8186606720f05619", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54363f8a92920f5559c83ddd53e480a27205e6b7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54363f8a92920f5559c83ddd53e480a27205e6b7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=54363f8a92920f5559c83ddd53e480a27205e6b7", "patch": "@@ -1,3 +1,18 @@\n+2015-12-08  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR ipa/61886\n+\tPR middle-end/25140\n+\t* tree-ssa-alias.c (ptr_deref_may_alias_decl_p): Use compare_base_decls\n+\t(nonoverlapping_component_refs_of_decl_p): Update sanity check.\n+\t(decl_refs_may_alias_p): Use compare_base_decls.\n+\t* alias.c: Include cgraph.h\n+\t(rtx_equal_for_memref_p): Use rtx_equal_for_memref_p.\n+\t(compare_base_decls): New function.\n+\t(base_alias_check): Likewise.\n+\t(memrefs_conflict_p): Likewise.\n+\t(nonoverlapping_memrefs_p): Likewise.\n+\t* alias.h (compare_base_decls): Declare.\n+\n 2015-12-08  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR ipa/61886"}, {"sha": "095b2ade180b7cd09f8c0473201b7945b4fc8256", "filename": "gcc/alias.c", "status": "modified", "additions": 86, "deletions": 3, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54363f8a92920f5559c83ddd53e480a27205e6b7/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54363f8a92920f5559c83ddd53e480a27205e6b7/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=54363f8a92920f5559c83ddd53e480a27205e6b7", "patch": "@@ -37,6 +37,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"langhooks.h\"\n #include \"cfganal.h\"\n #include \"rtl-iter.h\"\n+#include \"cgraph.h\"\n \n /* The aliasing API provided here solves related but different problems:\n \n@@ -990,6 +991,14 @@ get_alias_set (tree t)\n \t   || TREE_CODE (p) == VECTOR_TYPE;\n \t   p = TREE_TYPE (p))\n \t{\n+\t  /* Ada supports recusive pointers.  Instead of doing recrusion check\n+\t     just give up once the preallocated space of 8 elements is up.\n+\t     In this case just punt to void * alias set.  */\n+\t  if (reference.length () == 8)\n+\t    {\n+\t      p = ptr_type_node;\n+\t      break;\n+\t    }\n \t  if (TREE_CODE (p) == REFERENCE_TYPE)\n \t    /* In LTO we want languages that use references to be compatible\n  \t       with languages that use pointers.  */\n@@ -1747,7 +1756,15 @@ rtx_equal_for_memref_p (const_rtx x, const_rtx y)\n       return LABEL_REF_LABEL (x) == LABEL_REF_LABEL (y);\n \n     case SYMBOL_REF:\n-      return XSTR (x, 0) == XSTR (y, 0);\n+      {\n+\ttree x_decl = SYMBOL_REF_DECL (x);\n+\ttree y_decl = SYMBOL_REF_DECL (y);\n+\n+\tif (!x_decl || !y_decl)\n+\t  return XSTR (x, 0) == XSTR (y, 0);\n+\telse\n+\t  return compare_base_decls (x_decl, y_decl) == 1;\n+      }\n \n     case ENTRY_VALUE:\n       /* This is magic, don't go through canonicalization et al.  */\n@@ -2010,6 +2027,31 @@ may_be_sp_based_p (rtx x)\n   return !base || base == static_reg_base_value[STACK_POINTER_REGNUM];\n }\n \n+/* BASE1 and BASE2 are decls.  Return 1 if they refer to same object, 0\n+   if they refer to different objects and -1 if we can not decide.  */\n+\n+int\n+compare_base_decls (tree base1, tree base2)\n+{\n+  int ret;\n+  gcc_checking_assert (DECL_P (base1) && DECL_P (base2));\n+  if (base1 == base2)\n+    return 1;\n+\n+  bool in_symtab1 = decl_in_symtab_p (base1);\n+  bool in_symtab2 = decl_in_symtab_p (base2);\n+\n+  /* Declarations of non-automatic variables may have aliases.  All other\n+     decls are unique.  */\n+  if (in_symtab1 != in_symtab2 || !in_symtab1)\n+    return 0;\n+  ret = symtab_node::get_create (base1)->equal_address_to\n+\t\t (symtab_node::get_create (base2), true);\n+  if (ret == 2)\n+    return -1;\n+  return ret;\n+}\n+\n /* Return 0 if the addresses X and Y are known to point to different\n    objects, 1 if they might be pointers to the same object.  */\n \n@@ -2047,6 +2089,17 @@ base_alias_check (rtx x, rtx x_base, rtx y, rtx y_base,\n   if (rtx_equal_p (x_base, y_base))\n     return 1;\n \n+  if (GET_CODE (x_base) == SYMBOL_REF && GET_CODE (y_base) == SYMBOL_REF)\n+    {\n+      tree x_decl = SYMBOL_REF_DECL (x_base);\n+      tree y_decl = SYMBOL_REF_DECL (y_base);\n+\n+      /* We can assume that no stores are made to labels.  */\n+      if (!x_decl || !y_decl)\n+\treturn 0;\n+      return compare_base_decls (x_decl, y_decl) != 0;\n+    }\n+\n   /* The base addresses are different expressions.  If they are not accessed\n      via AND, there is no conflict.  We can bring knowledge of object\n      alignment into play here.  For example, on alpha, \"char a, b;\" can\n@@ -2268,7 +2321,33 @@ memrefs_conflict_p (int xsize, rtx x, int ysize, rtx y, HOST_WIDE_INT c)\n   else\n     y = addr_side_effect_eval (y, abs (ysize), 0);\n \n-  if (rtx_equal_for_memref_p (x, y))\n+  if (GET_CODE (x) == SYMBOL_REF && GET_CODE (y) == SYMBOL_REF)\n+    {\n+      tree x_decl = SYMBOL_REF_DECL (x);\n+      tree y_decl = SYMBOL_REF_DECL (y);\n+      int cmp;\n+\n+      if (!x_decl || !y_decl)\n+\t{\n+\t  /* Label and normal symbol are never the same. */\n+\t  if (x_decl != y_decl)\n+\t    return 0;\n+\t  return offset_overlap_p (c, xsize, ysize);\n+\t}\n+      else\n+        cmp = compare_base_decls (x_decl, y_decl);\n+\n+      /* If both decls are the same, decide by offsets.  */\n+      if (cmp == 1)\n+        return offset_overlap_p (c, xsize, ysize);\n+      /* If decls are different or we know by offsets that there is no overlap,\n+\t we win.  */\n+      if (!cmp || !offset_overlap_p (c, xsize, ysize))\n+\treturn 0;\n+      /* Decls may or may not be different and offsets overlap....*/\n+      return -1;\n+    }\n+  else if (rtx_equal_for_memref_p (x, y))\n     {\n       return offset_overlap_p (c, xsize, ysize);\n     }\n@@ -2636,7 +2715,7 @@ nonoverlapping_memrefs_p (const_rtx x, const_rtx y, bool loop_invariant)\n      are constants or if one is a constant and the other a pointer into the\n      stack frame.  Otherwise a different base means we can't tell if they\n      overlap or not.  */\n-  if (! rtx_equal_p (basex, basey))\n+  if (compare_base_decls (exprx, expry) == 0)\n     return ((CONSTANT_P (basex) && CONSTANT_P (basey))\n \t    || (CONSTANT_P (basex) && REG_P (basey)\n \t\t&& REGNO_PTR_FRAME_P (REGNO (basey)))\n@@ -2647,6 +2726,10 @@ nonoverlapping_memrefs_p (const_rtx x, const_rtx y, bool loop_invariant)\n   if (loop_invariant)\n     return 0;              \n \n+  /* Offset based disambiguation is OK even if we do not know that the\n+     declarations are necessarily different\n+    (i.e. compare_base_decls (exprx, expry) == -1)  */\n+\n   sizex = (!MEM_P (rtlx) ? (int) GET_MODE_SIZE (GET_MODE (rtlx))\n \t   : MEM_SIZE_KNOWN_P (rtlx) ? MEM_SIZE (rtlx)\n \t   : -1);"}, {"sha": "45cbb1b60dc33e414958f3aa8f602a22160bae74", "filename": "gcc/alias.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54363f8a92920f5559c83ddd53e480a27205e6b7/gcc%2Falias.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54363f8a92920f5559c83ddd53e480a27205e6b7/gcc%2Falias.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.h?ref=54363f8a92920f5559c83ddd53e480a27205e6b7", "patch": "@@ -36,6 +36,7 @@ extern int nonoverlapping_memrefs_p (const_rtx, const_rtx, bool);\n extern void dump_alias_stats_in_alias_c (FILE *s);\n tree reference_alias_ptr_type (tree);\n bool alias_ptr_types_compatible_p (tree, tree);\n+int compare_base_decls (tree, tree);\n \n /* This alias set can be used to force a memory to conflict with all\n    other memories, creating a barrier across which no memory reference"}, {"sha": "ef7857a393597453dd563b721c5b7ebea86b5736", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54363f8a92920f5559c83ddd53e480a27205e6b7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54363f8a92920f5559c83ddd53e480a27205e6b7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=54363f8a92920f5559c83ddd53e480a27205e6b7", "patch": "@@ -1,3 +1,9 @@\n+2015-12-08  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR ipa/61886\n+\tPR middle-end/25140\n+\t* gcc.c-torture/execute/alias-2.c: New testcase.\n+\n 2015-12-09  Tobias Burnus  <burnus@net-b.de>\n \t    Alessandro Fanfarillo <fanfarillo.gcc@gmail.com>\n "}, {"sha": "c62d5068ee98131cbca63f13af976f42ac4da6dd", "filename": "gcc/testsuite/gcc.c-torture/execute/alias-2.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54363f8a92920f5559c83ddd53e480a27205e6b7/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Falias-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54363f8a92920f5559c83ddd53e480a27205e6b7/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Falias-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Falias-2.c?ref=54363f8a92920f5559c83ddd53e480a27205e6b7", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-require-alias \"\" } */\n+int a[10]={};\n+extern int b[10] __attribute__ ((alias(\"a\")));\n+int off;\n+main()\n+{\n+  b[off]=1;\n+  a[off]=2;\n+  if (b[off]!=2)\n+   __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "b5165461bc4370b1f0a0e834478362b5904fd607", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54363f8a92920f5559c83ddd53e480a27205e6b7/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54363f8a92920f5559c83ddd53e480a27205e6b7/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=54363f8a92920f5559c83ddd53e480a27205e6b7", "patch": "@@ -194,7 +194,7 @@ ptr_deref_may_alias_decl_p (tree ptr, tree decl)\n \tptr = TREE_OPERAND (base, 0);\n       else if (base\n \t       && DECL_P (base))\n-\treturn base == decl;\n+\treturn compare_base_decls (base, decl) != 0;\n       else if (base\n \t       && CONSTANT_CLASS_P (base))\n \treturn false;\n@@ -805,8 +805,10 @@ nonoverlapping_component_refs_of_decl_p (tree ref1, tree ref2)\n       ref2 = TREE_OPERAND (TREE_OPERAND (ref2, 0), 0);\n     }\n \n-  /* We must have the same base DECL.  */\n-  gcc_assert (ref1 == ref2);\n+  /* Bases must be either same or uncomparable.  */\n+  gcc_checking_assert (ref1 == ref2\n+\t\t       || (DECL_P (ref1) && DECL_P (ref2)\n+\t\t\t   && compare_base_decls (ref1, ref2) != 0));\n \n   /* Pop the stacks in parallel and examine the COMPONENT_REFs of the same\n      rank.  This is sufficient because we start from the same DECL and you\n@@ -989,7 +991,7 @@ decl_refs_may_alias_p (tree ref1, tree base1,\n   gcc_checking_assert (DECL_P (base1) && DECL_P (base2));\n \n   /* If both references are based on different variables, they cannot alias.  */\n-  if (base1 != base2)\n+  if (compare_base_decls (base1, base2) == 0)\n     return false;\n \n   /* If both references are based on the same variable, they cannot alias if"}]}