{"sha": "aadcdb458c68197f3da9a0c25ca839321c96f6bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWFkY2RiNDU4YzY4MTk3ZjNkYTlhMGMyNWNhODM5MzIxYzk2ZjZiZg==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1993-04-06T00:52:19Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1993-04-06T00:52:19Z"}, "message": "pa.c (print_stw, print_ldw): Delete.\n\n\t* pa.c (print_stw, print_ldw): Delete.\n\t(eligible_for_epilogue_delay): Delete.\n\t(hppa_epilogue_delay_slots): Delete.\n\t(store_reg, load_reg, set_reg_plus_d): New helper functions.\n\t(output_function_prologue): Only emit assembler pseudo-ops\n\tto denote the start of a function.  Place the correct\n\tvalue into hp_profile_label_name if profiling.\n\t(output_function_epilogue): Only emit assembler pseudo-ops\n\tto deonte the end of a function.\n\t(hppa_expand_prologue): New function to emit all prologue\n\tcode as RTL.\n\t(hppa_expand_epilogue): Likewise for the epilogue.\n\t(compute_frame_size): Update to account for using %r4 as an\n\tallocatable register if the frame pointer was eliminated.\n\nFrom-SVN: r4025", "tree": {"sha": "05b0af3625644f6faefce835aa0bc59278b730ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/05b0af3625644f6faefce835aa0bc59278b730ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aadcdb458c68197f3da9a0c25ca839321c96f6bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aadcdb458c68197f3da9a0c25ca839321c96f6bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aadcdb458c68197f3da9a0c25ca839321c96f6bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aadcdb458c68197f3da9a0c25ca839321c96f6bf/comments", "author": null, "committer": null, "parents": [{"sha": "527986c952469138145b5ff7206c7660d7a795a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/527986c952469138145b5ff7206c7660d7a795a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/527986c952469138145b5ff7206c7660d7a795a9"}], "stats": {"total": 590, "additions": 324, "deletions": 266}, "files": [{"sha": "1ee230a4e618370edbf178860434a89261bd88ca", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 324, "deletions": 266, "changes": 590, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aadcdb458c68197f3da9a0c25ca839321c96f6bf/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aadcdb458c68197f3da9a0c25ca839321c96f6bf/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=aadcdb458c68197f3da9a0c25ca839321c96f6bf", "patch": "@@ -1597,29 +1597,94 @@ output_ascii (file, p, size)\n        \n */\n \n-/* Helper functions */\n-void\n-print_stw (file, r, disp, base)\n-     FILE *file;\n-     int r, disp, base;\n+/* Emit RTL to store REG at the memory location specified by BASE+DISP.\n+   Handle case where DISP > 8k by using the add_high_const pattern.\n+\n+   Note in DISP > 8k case, we will leave the high part of the address\n+   in %r1.  There is code in expand_hppa_{prologue,epilogue} that knows this.*/\n+static void\n+store_reg (reg, disp, base)\n+     int reg, disp, base;\n {\n   if (VAL_14_BITS_P (disp))\n-    fprintf (file, \"\\tstw %%r%d,%d(0,%%r%d)\\n\", r, disp, base);\n+    {\n+      emit_move_insn (gen_rtx (MEM, SImode, \n+\t\t\t       gen_rtx (PLUS, SImode, \n+\t\t\t\t        gen_rtx (REG, SImode, base),\n+\t\t\t\t        GEN_INT (disp))),\n+\t\t      gen_rtx (REG, SImode, reg));\n+    }\n   else\n-    fprintf (file, \"\\taddil L'%d,%%r%d\\n\\tstw %%r%d,R'%d(0,%%r1)\\n\", disp, base,\n-\t     r, disp);\n+    {\n+      emit_insn (gen_add_high_const (gen_rtx (REG, SImode, 1), \n+\t\t\t\t     gen_rtx (REG, SImode, base), \n+\t\t\t\t     GEN_INT (disp)));\n+      emit_move_insn (gen_rtx (MEM, SImode,\n+\t\t\t       gen_rtx (LO_SUM, SImode, \n+\t\t\t\t\tgen_rtx (REG, SImode, 1),\n+\t\t\t\t\tGEN_INT (disp))),\n+\t\t      gen_rtx (REG, SImode, reg));\n+    }\n }\n \n-void\n-print_ldw (file, r, disp, base)\n-     FILE *file;\n-     int r, disp, base;\n+/* Emit RTL to load REG from the memory location specified by BASE+DISP.\n+   Handle case where DISP > 8k by using the add_high_const pattern.\n+\n+   Note in DISP > 8k case, we will leave the high part of the address\n+   in %r1.  There is code in expand_hppa_{prologue,epilogue} that knows this.*/\n+static void\n+load_reg (reg, disp, base)\n+     int reg, disp, base;\n+{\n+  if (VAL_14_BITS_P (disp))\n+    {\n+      emit_move_insn (gen_rtx (REG, SImode, reg),\n+\t\t      gen_rtx (MEM, SImode, \n+\t\t\t       gen_rtx (PLUS, SImode, \n+\t\t\t\t        gen_rtx (REG, SImode, base),\n+\t\t\t\t        GEN_INT (disp))));\n+\t\t      \n+    }\n+  else\n+    {\n+      emit_insn (gen_add_high_const (gen_rtx (REG, SImode, 1), \n+\t\t\t\t     gen_rtx (REG, SImode, base),\n+\t\t\t\t     GEN_INT (disp)));\n+      emit_move_insn (gen_rtx (REG, SImode, reg),\n+\t\t      gen_rtx (MEM, SImode,\n+\t\t\t       gen_rtx (LO_SUM, SImode, \n+\t\t\t\t\tgen_rtx (REG, SImode, 1), \n+\t\t\t\t\tGEN_INT (disp))));\n+    }\n+}\n+\n+/* Emit RTL to set REG to the value specified by BASE+DISP.\n+   Handle case where DISP > 8k by using the add_high_const pattern.\n+\n+   Note in DISP > 8k case, we will leave the high part of the address\n+   in %r1.  There is code in expand_hppa_{prologue,epilogue} that knows this.*/\n+static void\n+set_reg_plus_d(reg, base, disp)\n+     int reg, base, disp;\n {\n   if (VAL_14_BITS_P (disp))\n-    fprintf (file, \"\\tldw %d(0,%d),%d\\n\", disp, base, r);\n+    {\n+      emit_move_insn (gen_rtx (REG, SImode, reg),\n+\t\t      gen_rtx (PLUS, SImode, \n+\t\t\t       gen_rtx (REG, SImode, base),\n+\t\t\t       GEN_INT (disp)));\n+      \n+    }\n   else\n-    fprintf (file, \"\\taddil L'%d,%d\\n\\tldw R'%d(0,%%r1),%d\\n\", disp, base,\n-\t     disp, r);\n+    {\n+      emit_insn (gen_add_high_const (gen_rtx (REG, SImode, 1), \n+\t\t\t\t     gen_rtx (REG, SImode, base),\n+\t\t\t\t     GEN_INT (disp)));\n+      emit_move_insn (gen_rtx (REG, SImode, reg),\n+\t\t      gen_rtx (LO_SUM, SImode, \n+\t\t\t\t\tgen_rtx (REG, SImode, 1),\n+\t\t\t\t\tGEN_INT (disp)));\n+    }\n }\n \n /* Global variables set by FUNCTION_PROLOGUE.  */\n@@ -1641,12 +1706,21 @@ compute_frame_size (size, fregs_live)\n   fsize = size + (size || frame_pointer_needed ? 8 : 0);\n \n   /* fp is stored in a special place. */\n-  for (i = 18; i >= 5; i--)\n-    if (regs_ever_live[i])\n-      fsize += 4;\n+  if (frame_pointer_needed)\n+    {\n+      for (i = 18; i >= 5; i--)\n+\tif (regs_ever_live[i])\n+\t  fsize += 4;\n \n-  if (regs_ever_live[3])\n-    fsize += 4;\n+      if (regs_ever_live[3])\n+\tfsize += 4;\n+    }\n+  else\n+    {\n+      for (i = 18; i >= 3; i--)\n+\tif (regs_ever_live[i])\n+\t  fsize += 4;\n+    }\n   fsize = (fsize + 7) & ~7;\n \n   if (!TARGET_SNAKE)\n@@ -1675,156 +1749,200 @@ compute_frame_size (size, fregs_live)\n   return TARGET_SNAKE ? (fsize + 63 & ~63) : fsize;\n }\n      \n+rtx hp_profile_label_rtx;\n+static char hp_profile_label_name[8];\n void\n output_function_prologue (file, size)\n      FILE *file;\n      int size;\n {\n+\n+  /* hppa_expand_prologue does the dirty work now.  We just need\n+     to output the assembler directives which denote the start\n+     of a function.  */\n+  fprintf (file, \"\\t.PROC\\n\\t.CALLINFO FRAME=%d\", actual_fsize);\n+  if (regs_ever_live[2] || profile_flag)\n+    fprintf (file, \",CALLS,SAVE_RP\\n\");\n+  else\n+    fprintf (file, \",NO_CALLS\\n\");\n+  fprintf (file, \"\\t.ENTRY\\n\");\n+\n+  /* Horrid hack.  emit_function_prologue will modify this RTL in\n+     place to get the expected results.  */\n+  if (profile_flag)\n+    sprintf(hp_profile_label_name, \"LP$%04d\", hp_profile_labelno);\n+}\n+\n+hppa_expand_prologue()\n+{\n+\n   extern char call_used_regs[];\n-  extern int frame_pointer_needed;\n-  extern int current_function_returns_struct;\n-  int i, offset;\n+  int size = get_frame_size ();\n   int merge_sp_adjust_with_store = 0;\n+  int i, offset;\n+  rtx tmpreg, size_rtx;\n+\n \n   save_fregs = 0;\n   local_fsize =  size + (size || frame_pointer_needed ? 8 : 0);\n   actual_fsize = compute_frame_size (size, &save_fregs);\n \n-  /* Let's not try to bullshit more than we need to here. */\n-  /* This might be right a lot of the time */\n-  fprintf (file, \"\\t.PROC\\n\\t.CALLINFO FRAME=%d\", actual_fsize);\n-    if (regs_ever_live[2] || profile_flag)\n-      fprintf (file, \",CALLS,SAVE_RP\\n\");\n-    else\n-      fprintf (file, \",NO_CALLS\\n\");\n-  fprintf (file, \"\\t.ENTRY\\n\");\n-\n-  /* Some registers have places to go in the current stack\n-     structure.  */\n+  /* Compute a few things we will use often.  */\n+  tmpreg = gen_rtx (REG, SImode, 1);\n+  size_rtx = GEN_INT (actual_fsize);\n \n+  /* Save RP first.  The calling conventions manual states RP will \n+     always be stored into the caller's frame at sp-20.  */\n   if (regs_ever_live[2] || profile_flag)\n-    fprintf (file, \"\\tstw %%r2,-20(0,%%r30)\\n\");\n-\n-  /* Reserve space for local variables.  */\n+    store_reg (2, -20, STACK_POINTER_REGNUM);  \n+    \n+  /* Allocate the local frame and set up the frame pointer if needed.  */\n   if (actual_fsize)\n     if (frame_pointer_needed)\n       {\n+\t/* Copy the old frame pointer temporarily into %r1.  Set up the\n+\t   new stack pointer, then store away the saved old frame pointer\n+\t   into the stack at sp+actual_fsize and at the same time update\n+\t   the stack pointer by actual_fsize bytes.  Two versions, first\n+\t   handles small (<8k) frames.  The second handles large (>8k)\n+\t   frames.  */\n+\temit_move_insn (tmpreg, frame_pointer_rtx);\n+\temit_move_insn (frame_pointer_rtx, stack_pointer_rtx);\n \tif (VAL_14_BITS_P (actual_fsize))\n-\t  fprintf (file, \"\\tcopy %%r4,%%r1\\n\\tcopy %%r30,%%r4\\n\\tstwm %%r1,%d(0,%%r30)\\n\",\n-\t\t   actual_fsize);\n+\t  emit_insn (gen_post_stwm (stack_pointer_rtx,\n+\t\t\t\t    stack_pointer_rtx,\n+\t\t\t\t    size_rtx, tmpreg));\n \telse\n \t  {\n-\t    fprintf (file, \"\\tcopy %%r4,%%r1\\n\\tcopy %%r30,%%r4\\n\\tstw %%r1,0(0,%%r4)\\n\");\n-\t    fprintf (file, \"\\taddil L'%d,%%r30\\n\\tldo R'%d(%%r1),%%r30\\n\",\n-\t\t     actual_fsize, actual_fsize);\n+\t    store_reg (1, 0, FRAME_POINTER_REGNUM);\n+\t    set_reg_plus_d (STACK_POINTER_REGNUM,\n+\t\t\t    STACK_POINTER_REGNUM,\n+\t\t\t    actual_fsize);\n \t  }\n       }\n+    /* no frame pointer needed.  */\n     else\n       {\n-\tif (VAL_14_BITS_P (-actual_fsize)\n-\t    && local_fsize == 0 && ! flag_pic && ! profile_flag)\n+\t/* In some cases we can perform the first callee register save\n+\t   and allocating the stack frame at the same time.   If so, just\n+\t   make a note of it and defer allocating the frame until saving\n+\t   the callee registers.  */\n+\tif (VAL_14_BITS_P (-actual_fsize) \n+\t    && local_fsize == 0 \n+\t    && ! profile_flag\n+\t    && ! flag_pic)\n \t  merge_sp_adjust_with_store = 1;\n-\telse if (VAL_14_BITS_P (actual_fsize))\n-\t  fprintf (file, \"\\tldo %d(%%r30),%%r30\\n\", actual_fsize);\n-\telse\n-\t  fprintf (file, \"\\taddil L'%d,%%r30\\n\\tldo R'%d(%%r1),%%r30\\n\",\n-\t\t   actual_fsize, actual_fsize);\n+\t/* Can not optimize.  Adjust the stack frame by actual_fsize bytes.  */\n+\telse if (actual_fsize != 0)\n+\t  set_reg_plus_d (STACK_POINTER_REGNUM,\n+\t\t\t  STACK_POINTER_REGNUM,\n+\t\t\t  actual_fsize);\n       }\n   /* The hppa calling conventions say that that %r19, the pic offset\n-     register, is saved at sp - 32 (in this function's frame) */\n+     register, is saved at sp - 32 (in this function's frame)  when\n+     generating PIC code.  */\n   if (flag_pic)\n-    {\n-      fprintf (file, \"\\tstw %%r19,-32(0,%%r30)\\n\");\n-    }\n-  /* Instead of taking one argument, the counter label, as most normal\n-     mcounts do, _mcount appears to behave differently on the HPPA. It\n-     takes the return address of the caller, the address of this\n-     routine, and the address of the label. Also, it isn't magic, so\n-     argument registers have to be preserved. */\n+    store_reg (19, -32, STACK_POINTER_REGNUM);  \n \n+  /* Profiling code.\n+\n+     Instead of taking one argument, the counter label, as most normal\n+     mcounts do, _mcount appears to behave differently on the HPPA.  It\n+     takes the return address of the caller, the address of this routine,\t\n+     and the address of the label.  Also, it isn't magic, so \n+     argument registre hsave to be preserved.  */\n   if (profile_flag)\n     {\n-      unsigned int pc_offset =\n-\t(4 + (frame_pointer_needed\n-\t      ? (VAL_14_BITS_P (actual_fsize) ? 12 : 20)\n-\t      : (VAL_14_BITS_P (actual_fsize) ? 4 : 8)));\n-      int i, arg_offset;\n-      int basereg, offsetadj;\n+      int pc_offset, i, arg_offset, basereg, offsetadj;\n+\n+      pc_offset = 4 + (frame_pointer_needed\n+\t\t       ? (VAL_14_BITS_P (actual_fsize) ? 12 : 20)\n+\t\t       : (VAL_14_BITS_P (actual_fsize) ? 4 : 8));\n \n-      /* When the function has a frame pointer, use that as the base \n-\t register for saving/restoring registers.  Else use the stack\n-\t pointer.  Adjust the offset according to the frame size if this\n-\t function does not have a frame pointer.  */\n+      /* When the function has a frame pointer, use it as the base\n+\t register for saving/restore registers.  Else use the stack\n+\t pointer.  Adjust the offset according to the frame size if\n+\t this function does not have a frame pointer.  */\n \n       basereg = frame_pointer_needed ? FRAME_POINTER_REGNUM\n \t\t\t\t     : STACK_POINTER_REGNUM;\n       offsetadj = frame_pointer_needed ? 0 : actual_fsize;\n \n+      /* Horrid hack.  emit_function_prologue will modify this RTL in\n+\t place to get the expected results.   sprintf here is just to\n+\t put something in the name.  */\n+      sprintf(hp_profile_label_name, \"LP$%04d\", -1);\n+      hp_profile_label_rtx = gen_rtx (SYMBOL_REF, SImode,\n+\t\t\t\t      hp_profile_label_name);\n       if (current_function_returns_struct)\n-\tprint_stw (file, STRUCT_VALUE_REGNUM, - 12 - offsetadj, basereg);\n+\tstore_reg (STRUCT_VALUE_REGNUM, - 12 - offsetadj, basereg);\n+\n       for (i = 26, arg_offset = -36 - offsetadj; i >= 23; i--, arg_offset -= 4)\n-\tif (regs_ever_live[i])\n+\tif (regs_ever_live [i])\n \t  {\n-\t    print_stw (file, i, arg_offset, basereg);\n-\t    /* It is possible for the arg_offset not to fit in 14 bits \n-               when profiling a function without a frame pointer.  Deal\n-\t       with such cases.  */\n+\t    store_reg (i, arg_offset, basereg);\n+\t    /* Deal with arg_offset not fitting in 14 bits.  */\n \t    pc_offset += VAL_14_BITS_P (arg_offset) ? 4 : 8;\n \t  }\n-      fprintf (file,\n-\t       \"\\tcopy %%r2,%%r26\\n\\taddil L'LP$%04d-$global$,%%r27\\n\\tldo R'LP$%04d-$global$(%%r1),%%r24\\n\\tbl _mcount,%%r2\\n\\tldo %d(%%r2),%%r25\\n\",\n-\t       hp_profile_labelno, hp_profile_labelno, -pc_offset - 12 - 8);\n+\n+      emit_move_insn (gen_rtx (REG, SImode, 26), gen_rtx (REG, SImode, 2));\n+      emit_move_insn (tmpreg, gen_rtx (HIGH, SImode, hp_profile_label_rtx));\n+      emit_move_insn (gen_rtx (REG, SImode, 24),\n+\t\t      gen_rtx (LO_SUM, SImode, tmpreg, hp_profile_label_rtx));\n+      /* %r25 is set from within the output pattern.  */\n+      emit_insn (gen_call_profiler (GEN_INT (- pc_offset - 20)));\n+\n+      /* Restore argument registers.  */\n       for (i = 26, arg_offset = -36 - offsetadj; i >= 23; i--, arg_offset -= 4)\n-\tif (regs_ever_live[i])\n-\t  print_ldw (file, i, arg_offset, basereg);\n+\tif (regs_ever_live [i])\n+\t  load_reg (i, arg_offset, basereg);\n+\n       if (current_function_returns_struct)\n-\tprint_ldw (file, STRUCT_VALUE_REGNUM, - 12 - offsetadj, basereg);\n+\tload_reg (STRUCT_VALUE_REGNUM, -12 - offsetadj, basereg);\n+\n     }\n \n-  /* Normal register save. */\n+  /* Normal register save. \n+\n+     Do not save the frame pointer in the frame_pointer_needed case.  It\n+     was done earlier.  */\n   if (frame_pointer_needed)\n     {\n-      for (i = 18, offset = local_fsize; i >= 5; i--)\n-\tif (regs_ever_live[i] && ! call_used_regs[i])\n+      for (i = 18, offset = local_fsize; i >= 3; i--)\n+\tif (regs_ever_live[i] && ! call_used_regs[i]\n+\t    && i != FRAME_POINTER_REGNUM)\n \t  {\n-\t    print_stw (file, i, offset, 4);  offset += 4;\n+\t    store_reg (i, offset, FRAME_POINTER_REGNUM);  \n+\t    offset += 4;\n \t  }\n-      if (regs_ever_live[3] && ! call_used_regs[3])\n-\t{\n-\t  print_stw (file, 3, offset, 4);  offset += 4;\n-\t}\n     }\n+  /* No frame pointer needed.  */\n   else\n     {\n-      for (i = 18, offset = local_fsize - actual_fsize; i >= 5; i--)\n+      for (i = 18, offset = local_fsize - actual_fsize; i >= 3; i--)\n       \tif (regs_ever_live[i] && ! call_used_regs[i])\n \t  {\n \t    /* If merge_sp_adjust_with_store is nonzero, then we can \n \t       optimize the first GR save.  */\n \t    if (merge_sp_adjust_with_store)\n \t      {\n \t\tmerge_sp_adjust_with_store = 0;\n-    \t\tfprintf (file, \"\\tstwm %d,%d(0,%d)\\n\", i, -offset, 30);\n+\t        emit_insn (gen_post_stwm (stack_pointer_rtx,\n+\t\t\t\t\t  stack_pointer_rtx,\n+\t\t\t\t\t  GEN_INT (-offset),\n+\t\t\t\t\t  gen_rtx (REG, SImode, i)));\n \t      }\n \t    else\n-\t      print_stw (file, i, offset, 30);  offset += 4;\n+\t      store_reg (i, offset, STACK_POINTER_REGNUM);\n+\t    offset += 4;\n \t  }\n-      if (regs_ever_live[3] && ! call_used_regs[3])\n-\t{\n-\t    /* If merge_sp_adjust_with_store is nonzero, then we can \n-\t       optimize the first GR save.  */\n-\t  if (merge_sp_adjust_with_store)\n-\t    {\n-\t      merge_sp_adjust_with_store = 0;\n-    \t      fprintf (file, \"\\tstwm %%r3,%d(0,%%r30)\\n\", -offset);\n-\t    }\n-\t  else\n-\t    print_stw (file, 3, offset, 30);  offset += 4;\n-\t}\n+\n       /* If we wanted to merge the SP adjustment with a GR save, but we never\n-\t did any GR saves, then just output the adjustment here.  */\n+\t did any GR saves, then just emit the adjustment here.  */\n       if (merge_sp_adjust_with_store)\n-\tfprintf (file, \"\\tldo %d(%%r30),%%r30\\n\", actual_fsize);\n+\tset_reg_plus_d (STACK_POINTER_REGNUM,\n+\t\t\tSTACK_POINTER_REGNUM,\n+\t\t\tactual_fsize);\n     }\n       \n   /* Align pointer properly (doubleword boundary).  */\n@@ -1833,228 +1951,168 @@ output_function_prologue (file, size)\n   /* Floating point register store.  */\n   if (save_fregs)\n     {\n+\n+      /* First get the frame or stack pointer to the start of the FP register\n+\t save area.  */\n       if (frame_pointer_needed)\n-\t{\n-\t  if (VAL_14_BITS_P (offset))\n-\t    fprintf (file, \"\\tldo %d(%%r4),%%r1\\n\", offset);\n-\t  else\n-\t    fprintf (file, \"\\taddil L'%d,%%r4\\n\\tldo R'%d(%%r1),%%r1\\n\",\n-\t\t     offset, offset);\n-\t}\n+\tset_reg_plus_d (1, FRAME_POINTER_REGNUM, offset);\n       else\n-\t{\n-\t  if (VAL_14_BITS_P (offset))\n-\t    fprintf (file, \"\\tldo %d(%%r30),%%r1\\n\", offset);\n-\t  else\n-\t    fprintf (file, \"\\taddil L'%d,%%r30\\n\\tldo R'%d(%%r1),%%r1\\n\",\n-\t\t     offset, offset);\n-\t}\n-      if (!TARGET_SNAKE)\n+\tset_reg_plus_d (1, STACK_POINTER_REGNUM, offset);\n+\n+      /* Now actually save the FP registers.  */\n+      if (! TARGET_SNAKE)\n \t{\n \t  for (i = 43; i >= 40; i--)\n \t    {\n \t      if (regs_ever_live[i])\n-\t\tfprintf (file, \"\\tfstds,ma %s,8(0,%%r1)\\n\", reg_names[i]);\n+\t\temit_move_insn (gen_rtx (MEM, DFmode, \n+\t\t\t\t\t gen_rtx (POST_INC, DFmode, tmpreg)),\n+\t\t\t\tgen_rtx (REG, DFmode, i));\n \t    }\n \t}\n       else\n \t{\n \t  for (i = 78; i >= 60; i -= 2)\n \t    if (regs_ever_live[i] || regs_ever_live[i + 1])\n \t      {\n-\t\tfprintf (file, \"\\tfstds,ma %s,8(0,%%r1)\\n\", reg_names[i]);\n+\t\temit_move_insn (gen_rtx (MEM, DFmode, \n+\t\t\t\t\t gen_rtx (POST_INC, DFmode, tmpreg)),\n+\t\t\t\tgen_rtx (REG, DFmode, i));\n \t      }\n \t}\n     }\n }\n \n+\n void\n output_function_epilogue (file, size)\n      FILE *file;\n      int size;\n {\n-  extern char call_used_regs[];\n-  extern int frame_pointer_needed;\n-  int  i, offset;\n-  int merge_sp_adjust_with_load = 0;\n+  /* hppa_expand_epilogue does the dirty work now.  We just need\n+     to output the assembler directives which denote the end\n+     of a function.  */\n+  fprintf (file, \"\\t.EXIT\\n\\t.PROCEND\\n\");\n+}\n \n-  /* In the common cases restore RP early to avoid load/use interlock when\n-     RP gets used in the bv instruction.  */\n+void\n+hppa_expand_epilogue()\n+{\n+  rtx tmpreg; \n+  int offset,i;\n+  int merge_sp_adjust_with_load  = 0;\n+\n+  /* We will use this often.  */\n+  tmpreg = gen_rtx (REG, SImode, 1);\n+\n+  /* Try to restore RP early to avoid load/use interlocks when\n+     RP gets used in the return (bv) instruction.  This appears to still\n+     be necessary even when we schedule the prologue and epilogue. */\n   if (frame_pointer_needed\n       && (regs_ever_live [2] || profile_flag))\n-    fprintf (file, \"\\tldw -20(%%r4),%%r2\\n\");\n-  else if (VAL_14_BITS_P (actual_fsize + 20)\n-\t   && (regs_ever_live [2] || profile_flag))\n-    fprintf(file,\"\\tldw %d(0,%%r30),%%r2\\n\", - (actual_fsize + 20));\n+    load_reg (2, -20, FRAME_POINTER_REGNUM);\n \n+  /* No frame pointer, and stack is smaller than 8k.  */\n+  else if (! frame_pointer_needed\n+\t   && VAL_14_BITS_P (actual_fsize + 20)\n+\t   && (regs_ever_live[2] || profile_flag))\n+    load_reg (2, - (actual_fsize + 20), STACK_POINTER_REGNUM);\n+\n+  /* General register restores.  */\n   if (frame_pointer_needed)\n     {\n-      for (i = 18, offset = local_fsize; i >= 5; i--)\n-\tif (regs_ever_live[i] && ! call_used_regs[i])\n+      for (i = 18, offset = local_fsize; i >= 3; i--)\n+\tif (regs_ever_live[i] && ! call_used_regs[i]\n+\t    && i != FRAME_POINTER_REGNUM)\n \t  {\n-\t    print_ldw (file, i, offset, 4);  offset += 4;\n+\t    load_reg (i, offset, FRAME_POINTER_REGNUM);\n+\t    offset += 4;\n \t  }\n-      if (regs_ever_live[3] && ! call_used_regs[3])\n-\t{\n-\t  print_ldw (file, 3, offset, 4);  offset += 4;\t  \n-\t}\n     }\n   else\n     {\n-      for (i = 18, offset = local_fsize - actual_fsize; i >= 5; i--)\n-      \tif (regs_ever_live[i] && ! call_used_regs[i])\n+      for (i = 18, offset = local_fsize - actual_fsize; i >= 3; i--)\n+\tif (regs_ever_live[i] && ! call_used_regs[i])\n \t  {\n-\t    /* Only for first load.  And not if profiling.  \n-\t       merge_sp_adjust_with_load holds the register load with\n-\t       which we will merge the sp adjustment with.*/\n+\t    /* Only for the first load.\n+\t       merge_sp_adjust_with_load holds the register load\n+\t       with which we will merge the sp adjustment.  */\n \t    if (VAL_14_BITS_P (actual_fsize + 20)\n \t\t&& local_fsize == 0\n-\t\t&& ! profile_flag \n \t\t&& ! merge_sp_adjust_with_load)\n \t      merge_sp_adjust_with_load = i;\n-\t    else \n-\t      print_ldw (file, i, offset, 30);  offset += 4;\n+\t    else\n+\t      load_reg (i, offset, STACK_POINTER_REGNUM);\n+\t    offset += 4;\n \t  }\n-      if (regs_ever_live[3] && ! call_used_regs[3])\n-\t{\n-\t  /* Only for first load.  And not if profiling.  \n-\t     merge_sp_adjust_with_load holds the register load with\n-\t     which we will merge the sp adjustment with.*/\n-\t  if (VAL_14_BITS_P (actual_fsize + 20)\n-\t      && local_fsize == 0\n-\t      && ! profile_flag\n-\t      && ! merge_sp_adjust_with_load)\n-\t    merge_sp_adjust_with_load = 3;\n-\t  else\n-\t    print_ldw (file, 3, offset, 30);  offset += 4;\n-\t}\n     }\n-      \n+\n   /* Align pointer properly (doubleword boundary).  */\n   offset = (offset + 7) & ~7;\n \n-  /* Floating point register restore.  */\n+  /* FP register restores.  */\n   if (save_fregs)\n     {\n+      /* Adjust the register to index off of.  */\n       if (frame_pointer_needed)\n-\t{\n-\t  if (VAL_14_BITS_P (offset))\n-\t    fprintf (file, \"\\tldo %d(%%r4),%%r1\\n\", offset);\n-\t  else\n-\t    fprintf (file, \"\\taddil L'%d,%%r4\\n\\tldo R'%d(%%r1),%%r1\\n\",\n-\t\t     offset, offset);\n-\t}\n+\tset_reg_plus_d (1, FRAME_POINTER_REGNUM, offset);\n       else\n-\t{\n-\t  if (VAL_14_BITS_P (offset))\n-\t    fprintf (file, \"\\tldo %d(%%r30),%%r1\\n\", offset);\n-\t  else\n-\t    fprintf (file, \"\\taddil L'%d,%%r30\\n\\tldo R'%d(%%r1),%%r1\\n\",\n-\t\t     offset, offset);\n-\t}\n-      if (!TARGET_SNAKE)\n+\tset_reg_plus_d (1, STACK_POINTER_REGNUM, offset);\n+\n+      /* Actually do the restores now.  */\n+      if (! TARGET_SNAKE)\n \t{\n \t  for (i = 43; i >= 40; i--)\n-\t    {\n-\t      if (regs_ever_live[i])\n-\t\tfprintf (file, \"\\tfldds,ma 8(0,%%r1),%s\\n\", reg_names[i]);\n-\t    }\n+\t    if (regs_ever_live[i])\n+\t      emit_move_insn (gen_rtx (REG, DFmode, i),\n+\t\t\t      gen_rtx (MEM, DFmode, \n+\t\t\t\t       gen_rtx (POST_INC, DFmode, tmpreg)));\n+\t      \n \t}\n       else\n \t{\n \t  for (i = 78; i >= 60; i -= 2)\n \t    if (regs_ever_live[i] || regs_ever_live[i + 1])\n-\t      {\n-\t\tfprintf (file, \"\\tfldds,ma 8(0,%%r1),%s\\n\", reg_names[i]);\n-\t      }\n+\t      emit_move_insn (gen_rtx (REG, DFmode, i),\n+\t\t\t      gen_rtx (MEM, DFmode, \n+\t\t\t\t       gen_rtx (POST_INC, DFmode, tmpreg)));\n \t}\n     }\n+\n+  /* No frame pointer, but we have a stack greater than 8k.  We restore\n+     %r2 very late in this case.  (all other cases are restored as early\n+     as possible.  */\n+  if (! frame_pointer_needed\n+      && ! VAL_14_BITS_P (actual_fsize + 20)\n+      && (regs_ever_live[2] || profile_flag))\n+    {\n+      set_reg_plus_d (STACK_POINTER_REGNUM,\n+\t\t      STACK_POINTER_REGNUM,\n+\t\t      - actual_fsize);\n+      /* Uses value left over in %r1 by set_reg_plus_d.  */\n+      load_reg (2, - (actual_fsize + 20 + ((- actual_fsize) & ~0x7ff)), 1);\n+    }\n+\n   /* Reset stack pointer (and possibly frame pointer).  The stack */\n-  /* pointer is initially set to fp + 64 to avoid a race condition. \n+  /* pointer is initially set to fp + 64 to avoid a race condition.\n      ??? What race condition?!?  */\n-  if (frame_pointer_needed)\n-    {\n-      /* RP has already been restored in this case.  */\n-      fprintf (file, \"\\tldo 64(%%r4),%%r30\\n\");\n-      fprintf (file, \"\\tbv 0(%%r2)\\n\\tldwm -64(0,%%r30),%%r4\\n\");\n-    }\n-  else if (actual_fsize)\n-    {\n-      if (regs_ever_live[2] || profile_flag)\n-          \n-\t{\n-\t  /* In this case RP has already been restored! */\n-\t  if (VAL_14_BITS_P (actual_fsize + 20))\n-\t    {\n-\t      /* Optimize load and sp adjustment.  */\n-\t      if (merge_sp_adjust_with_load)\n-\t\tfprintf (file, \"\\tbv 0(%%r2)\\n\\tldwm %d(0,%%r30),%d\\n\",\n-\t\t\t -actual_fsize, merge_sp_adjust_with_load);\n-\t      else\n-\t\tfprintf (file, \"\\tbv 0(%%r2)\\n\\tldo %d(%%r30),%%r30\\n\", -actual_fsize);\n-\t    }\n-\t  /* Large frame.  Uncommon and not worth extra hair to avoid\n-\t     load/use delay for RP.  */\n-\t  else\n-\t    fprintf (file,\n-\t\t     \"\\taddil L'%d,%%r30\\n\\tldw %d(0,%%r1),%%r2\\n\\tbv 0(%%r2)\\n\\tldo R'%d(%%r1),%%r30\\n\",\n-\t\t     - actual_fsize,\n-\t\t     - (actual_fsize + 20 + ((-actual_fsize) & ~0x7ff)),\n-\t\t     - actual_fsize);\n-\t}\n-      /* Merge load with SP adjustment.  */\n-      else if (merge_sp_adjust_with_load)\n-\tfprintf (file, \"\\tbv 0(%%r2)\\n\\tldwm %d(0,%%r30),%d\\n\", \n-\t\t - actual_fsize, merge_sp_adjust_with_load);\n-      else if (VAL_14_BITS_P (actual_fsize))\n-\tfprintf (file, \"\\tbv 0(%%r2)\\n\\tldo %d(%%r30),%%r30\\n\", - actual_fsize);\n-      else\n-\tfprintf (file, \"\\taddil L'%d,%%r30\\n\\tbv 0(%%r2)\\n\\tldo R'%d(%%r1),%%r30\\n\",\n-\t\t - actual_fsize, - actual_fsize);\n-    }\n-  else if (current_function_epilogue_delay_list)\n+  else if (frame_pointer_needed)\n     {\n-      fprintf (file, \"\\tbv 0(%%r2)\\n\");\n-      final_scan_insn (XEXP (current_function_epilogue_delay_list, 0), file,\n-\t\t       1, 0, 1);\n+      set_reg_plus_d (STACK_POINTER_REGNUM, FRAME_POINTER_REGNUM, 64);\n+      emit_insn (gen_pre_ldwm (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t       GEN_INT (-64), frame_pointer_rtx));\n     }\n-  else\n-    fprintf (file, \"\\tbv,n 0(%%r2)\\n\");\n-  fprintf (file, \"\\t.EXIT\\n\\t.PROCEND\\n\");\n-}\n-\n-/* If there's a frame, it will be deallocated in the delay slot of the \n-   bv 0(2) return instruction. */\n-\n-int\n-hppa_epilogue_delay_slots ()\n-{\n-  return (compute_frame_size (get_frame_size (), 0) ? 0 : 1);\n-}\n-\n-/* Return nonzero if TRIAL can go into the function epilogue's\n-   delay slot.  SLOT is the slot we are trying to fill.  */\n-\n-int\n-eligible_for_epilogue_delay (trial, slot)\n-     rtx trial;\n-     int slot;\n-{\n-  if (slot >= 1)\n-    return 0;\n-  if (GET_CODE (trial) != INSN\n-      || GET_CODE (PATTERN (trial)) != SET)\n-    return 0;\n-  if (get_attr_length (trial) != 1)\n-    return 0;\n-\n-  /* The epilogue clobbers whatever value is in %r2 before the \n-     delay slot executes, so insns which use %r2 can not be\n-     used to fill the epilogue's delay slot.  */\n-  if (refers_to_regno_p (2, 3, PATTERN (trial), NULL_PTR))\n-    return 0;\n-\n-  return (get_attr_in_branch_delay (trial) == IN_BRANCH_DELAY_TRUE);\n+  /* If we were deferring a callee register restore, do it now.  */\n+  else if (! frame_pointer_needed  && merge_sp_adjust_with_load)\n+    emit_insn (gen_pre_ldwm (stack_pointer_rtx,\n+\t\t\t     stack_pointer_rtx,\n+\t\t\t     GEN_INT (- actual_fsize),\n+\t\t\t     gen_rtx (REG, SImode, \n+\t\t\t     merge_sp_adjust_with_load)));\n+  else if (actual_fsize != 0)\n+    set_reg_plus_d (STACK_POINTER_REGNUM,\n+\t\t    STACK_POINTER_REGNUM,\n+\t\t    - actual_fsize);\n }\n \n /* This is only valid once reload has completed because it depends on"}]}