{"sha": "94de45d9fe364fefd0cea5352c486306e68d704b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTRkZTQ1ZDlmZTM2NGZlZmQwY2VhNTM1MmM0ODYzMDZlNjhkNzA0Yg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2003-04-11T10:38:57Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2003-04-11T10:38:57Z"}, "message": "Makefile.in (loop-init.o): Do not depend on gcov-io.h, gcov-iov.h.\n\n\t* Makefile.in (loop-init.o): Do not depend on gcov-io.h,\n\tgcov-iov.h.\n\n\tSimplify interface to gcov reading and writing.\n\t* gcov-io.h (gcov_file, gcov_position, gcov_length, gcov_buffer,\n\tgcov_alloc, gcov_modified, gcov_errored): Move into ...\n\t(struct gcov_var gcov_var): ... this static structure.\n\t(gcov_write_unsigned, gcov_write_counter, gcov_write_string):\n\tReturn void.\n\t(gcov_read_unsigned, gcov_read_couter, gcov_read_string): Return\n\tread object.\n\t(gcov_read_bytes, gcov_write_bytes): Set error flag on error.\n\t(gcov_reserve_length): Remove.\n\t(gcov_write_tag): New.\n\t(gcov_write_length): Adjust.\n\t(gcov_read_summary, gcov_write_summary): Adjust.\n\t(gcov_eof, gcov_ok): Rename to ...\n\t(gcov_is_eof, gcov_is_error): ... here. Return error code.\n\t(gcov_save_position, gcov_resync): Rename to ...\n\t(gcov_position, gcov_seek): ... here.\n\t(gcov_skip, gcov_skip_string): Remove.\n\t(gcov_error): Remove.\n\t(gcov_open, gcov_close): Adjust.\n\t* gcov.c (find_source): Take const char *, copy it on allocation.\n\t(read_graph_file): Adjust.\n\t(read_count_file): Adjust.\n\t* libgcov.c (gcov_exit): Adjust.\n\t* gcov-dump.c (tag_function, tag_blocks, tag_arcs, tag_lines,\n\ttag_arc_counts, tag_summary): Return void. Adjust.\n\t(struct tag_format): Adjust proc member.\n\t(dump_file): Adjust gcov calls.\n\nFrom-SVN: r65464", "tree": {"sha": "7661c471f34c22626015acd1801aa486d1a6f9c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7661c471f34c22626015acd1801aa486d1a6f9c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/94de45d9fe364fefd0cea5352c486306e68d704b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94de45d9fe364fefd0cea5352c486306e68d704b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94de45d9fe364fefd0cea5352c486306e68d704b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94de45d9fe364fefd0cea5352c486306e68d704b/comments", "author": null, "committer": null, "parents": [{"sha": "7a615b25793c2201a7b92c8fd3425567b96b22ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a615b25793c2201a7b92c8fd3425567b96b22ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a615b25793c2201a7b92c8fd3425567b96b22ce"}], "stats": {"total": 1170, "additions": 516, "deletions": 654}, "files": [{"sha": "ca5529516e0f099add1d2eb882391726146806fc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94de45d9fe364fefd0cea5352c486306e68d704b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94de45d9fe364fefd0cea5352c486306e68d704b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=94de45d9fe364fefd0cea5352c486306e68d704b", "patch": "@@ -1,3 +1,37 @@\n+2003-04-11  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* Makefile.in (loop-init.o): Do not depend on gcov-io.h,\n+\tgcov-iov.h.\n+\n+\tSimplify interface to gcov reading and writing.\n+\t* gcov-io.h (gcov_file, gcov_position, gcov_length, gcov_buffer,\n+\tgcov_alloc, gcov_modified, gcov_errored): Move into ...\n+\t(struct gcov_var gcov_var): ... this static structure.\n+\t(gcov_write_unsigned, gcov_write_counter, gcov_write_string):\n+\tReturn void.\n+\t(gcov_read_unsigned, gcov_read_couter, gcov_read_string): Return\n+\tread object.\n+\t(gcov_read_bytes, gcov_write_bytes): Set error flag on error.\n+\t(gcov_reserve_length): Remove.\n+\t(gcov_write_tag): New.\n+\t(gcov_write_length): Adjust.\n+\t(gcov_read_summary, gcov_write_summary): Adjust.\n+\t(gcov_eof, gcov_ok): Rename to ...\n+\t(gcov_is_eof, gcov_is_error): ... here. Return error code.\n+\t(gcov_save_position, gcov_resync): Rename to ...\n+\t(gcov_position, gcov_seek): ... here.\n+\t(gcov_skip, gcov_skip_string): Remove.\n+\t(gcov_error): Remove.\n+\t(gcov_open, gcov_close): Adjust.\n+\t* gcov.c (find_source): Take const char *, copy it on allocation.\n+\t(read_graph_file): Adjust.\n+\t(read_count_file): Adjust.\n+\t* libgcov.c (gcov_exit): Adjust.\n+\t* gcov-dump.c (tag_function, tag_blocks, tag_arcs, tag_lines,\n+\ttag_arc_counts, tag_summary): Return void. Adjust.\n+\t(struct tag_format): Adjust proc member.\n+\t(dump_file): Adjust gcov calls.\n+\n 2003-04-11  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* Makefile.in (fixinc.sh): Pass BUILD_LIBERTY as LIBERTY to"}, {"sha": "1ab232f3c3df848f69164d5d0daa4d99586933c9", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94de45d9fe364fefd0cea5352c486306e68d704b/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94de45d9fe364fefd0cea5352c486306e68d704b/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=94de45d9fe364fefd0cea5352c486306e68d704b", "patch": "@@ -1652,8 +1652,8 @@ cfgloopanal.o : cfgloopanal.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h cfgloop.h $(EXPR_H) coretypes.h $(TM_H)\n cfgloopmanip.o : cfgloopmanip.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h cfgloop.h cfglayout.h output.h coretypes.h $(TM_H)\n-loop-init.o : loop-init.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) gcov-io.h \\\n-   gcov-iov.h $(BASIC_BLOCK_H) hard-reg-set.h cfgloop.h cfglayout.h profile.h \\\n+loop-init.o : loop-init.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \\\n+   $(BASIC_BLOCK_H) hard-reg-set.h cfgloop.h cfglayout.h profile.h \\\n    coretypes.h $(TM_H)\n loop-unswitch.o : loop-unswitch.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TM_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h cfgloop.h cfglayout.h params.h \\"}, {"sha": "ba56fee7e378ec3df7f0caf436014c5655e43e79", "filename": "gcc/gcov-dump.c", "status": "modified", "additions": 60, "deletions": 107, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94de45d9fe364fefd0cea5352c486306e68d704b/gcc%2Fgcov-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94de45d9fe364fefd0cea5352c486306e68d704b/gcc%2Fgcov-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-dump.c?ref=94de45d9fe364fefd0cea5352c486306e68d704b", "patch": "@@ -30,19 +30,19 @@ static void dump_file PARAMS ((const char *));\n static void print_prefix PARAMS ((const char *, unsigned));\n static void print_usage PARAMS ((void));\n static void print_version PARAMS ((void));\n-static int tag_function PARAMS ((const char *, unsigned, unsigned));\n-static int tag_blocks PARAMS ((const char *, unsigned, unsigned));\n-static int tag_arcs PARAMS ((const char *, unsigned, unsigned));\n-static int tag_lines PARAMS ((const char *, unsigned, unsigned));\n-static int tag_arc_counts PARAMS ((const char *, unsigned, unsigned));\n-static int tag_summary PARAMS ((const char *, unsigned, unsigned));\n+static void tag_function PARAMS ((const char *, unsigned, unsigned));\n+static void tag_blocks PARAMS ((const char *, unsigned, unsigned));\n+static void tag_arcs PARAMS ((const char *, unsigned, unsigned));\n+static void tag_lines PARAMS ((const char *, unsigned, unsigned));\n+static void tag_arc_counts PARAMS ((const char *, unsigned, unsigned));\n+static void tag_summary PARAMS ((const char *, unsigned, unsigned));\n extern int main PARAMS ((int, char **));\n \n typedef struct tag_format\n {\n   unsigned tag;\n   char const *name;\n-  int (*proc) (const char *, unsigned, unsigned);\n+  void (*proc) (const char *, unsigned, unsigned);\n } tag_format_t;\n \n static int flag_dump_contents = 0;\n@@ -140,25 +140,17 @@ dump_file (filename)\n {\n   unsigned tags[4];\n   unsigned depth = 0;\n-  unsigned magic, version;\n-  unsigned tag, length;\n   \n   if (!gcov_open (filename, 1))\n     {\n       fprintf (stderr, \"%s:cannot open\\n\", filename);\n       return;\n     }\n   \n-  if (gcov_read_unsigned (&magic) || gcov_read_unsigned (&version))\n-    {\n-    read_error:;\n-      printf (\"%s:read error at %lu\\n\", filename, gcov_save_position ());\n-      gcov_close ();\n-      return;\n-    }\n-\n   /* magic */\n   {\n+    unsigned magic = gcov_read_unsigned ();\n+    unsigned version = gcov_read_unsigned ();\n     const char *type = NULL;\n     char e[4], v[4], m[4];\n     unsigned expected = GCOV_VERSION;\n@@ -187,13 +179,14 @@ dump_file (filename)\n       printf (\"%s:warning:current version is `%.4s'\\n\", filename, e);\n   }\n \n-  while (!gcov_read_unsigned (&tag) && !gcov_read_unsigned (&length))\n+  while (!gcov_is_eof ())\n     {\n+      unsigned tag = gcov_read_unsigned ();\n+      unsigned length = gcov_read_unsigned ();\n+      unsigned long base = gcov_position ();\n       tag_format_t const *format;\n       unsigned tag_depth;\n-      long base, end;\n-      \n-      base = gcov_save_position ();\n+      int error;\n       \n       if (!tag)\n \ttag_depth = depth;\n@@ -231,57 +224,53 @@ dump_file (filename)\n       print_prefix (filename, tag_depth);\n       printf (\"%08x:%4u:%s\", tag, length, format->name);\n       if (format->proc)\n-\tif ((*format->proc) (filename, tag, length))\n-\t  goto read_error;\n+\t(*format->proc) (filename, tag, length);\n+      \n       printf (\"\\n\");\n-      end = gcov_save_position ();\n-      gcov_resync (base, length);\n-      if (format->proc && end != base + (long)length)\n+      if (flag_dump_contents && format->proc)\n \t{\n-\t  if (end > base + (long)length)\n+\t  unsigned long actual_length = gcov_position () - base;\n+\t  \n+\t  if (actual_length > length)\n \t    printf (\"%s:record size mismatch %lu bytes overread\\n\",\n-\t\t    filename, (end - base) - length);\n-\t  else\n+\t\t    filename, actual_length - length);\n+\t  else if (length > actual_length)\n \t    printf (\"%s:record size mismatch %lu bytes unread\\n\",\n-\t\t    filename, length - (end - base));\n+\t\t    filename, length - actual_length);\n+\t}\n+      gcov_seek (base, length);\n+      if ((error = gcov_is_error ()))\n+\t{\n+\t  printf (error < 0 ? \"%s:counter overflow at %lu\\n\" :\n+\t\t  \"%s:read error at %lu\\n\", filename, gcov_position ());\n+\t  break;\n \t}\n     }\n-  if (!gcov_eof ())\n-    goto read_error;\n   gcov_close ();\n }\n \n-static int\n+static void\n tag_function (filename, tag, length)\n      const char *filename ATTRIBUTE_UNUSED;\n      unsigned tag ATTRIBUTE_UNUSED;\n      unsigned length ATTRIBUTE_UNUSED;\n {\n-  char *name = NULL;\n-  unsigned checksum;\n-  char *src = NULL;\n-  unsigned lineno = 0;\n-  unsigned long pos = gcov_save_position ();\n+  const char *name;\n+  unsigned long pos = gcov_position ();\n   \n-  if (gcov_read_string (&name)\n-      || gcov_read_unsigned (&checksum))\n-    return 1;\n-\n-  if (gcov_save_position () - pos != length\n-      && (gcov_read_string (&src)\n-\t  || gcov_read_unsigned (&lineno)))\n-    return 1;\n+  name = gcov_read_string ();\n+  printf (\" `%s'\", name ? name : \"NULL\");\n+  printf (\" checksum=0x%08x\", gcov_read_unsigned ());\n \n-  printf (\" `%s' checksum=0x%08x\", name, checksum);\n-  if (src)\n-    printf (\" %s:%u\", src, lineno);\n-  free (name);\n-  free (src);\n-  \n-  return 0;\n+  if (gcov_position () - pos < length)\n+    {\n+      name = gcov_read_string ();\n+      printf (\" %s\", name ? name : \"NULL\");\n+      printf (\":%u\", gcov_read_unsigned ());\n+    }\n }\n \n-static int\n+static void\n tag_blocks (filename, tag, length)\n      const char *filename ATTRIBUTE_UNUSED;\n      unsigned tag ATTRIBUTE_UNUSED;\n@@ -297,22 +286,14 @@ tag_blocks (filename, tag, length)\n \n       for (ix = 0; ix != n_blocks; ix++)\n \t{\n-\t  unsigned flags;\n-\t  if (gcov_read_unsigned (&flags))\n-\t    return 1;\n \t  if (!(ix & 7))\n \t    printf (\"\\n%s:\\t\\t%u\", filename, ix);\n-\t  printf (\" %04x\", flags);\n+\t  printf (\" %04x\", gcov_read_unsigned ());\n \t}\n-      \n     }\n-  else\n-    gcov_skip (n_blocks * 4);\n-  \n-  return 0;\n }\n \n-static int\n+static void\n tag_arcs (filename, tag, length)\n      const char *filename ATTRIBUTE_UNUSED;\n      unsigned tag ATTRIBUTE_UNUSED;\n@@ -324,64 +305,47 @@ tag_arcs (filename, tag, length)\n   if (flag_dump_contents)\n     {\n       unsigned ix;\n-      unsigned blockno;\n-\n-      if (gcov_read_unsigned (&blockno))\n-\treturn 1;\n+      unsigned blockno = gcov_read_unsigned ();\n \n       for (ix = 0; ix != n_arcs; ix++)\n \t{\n-\t  unsigned dst, flags;\n+\t  unsigned dst = gcov_read_unsigned ();\n+\t  unsigned flags = gcov_read_unsigned ();\n \t  \n-\t  if (gcov_read_unsigned (&dst) || gcov_read_unsigned (&flags))\n-\t    return 1;\n \t  if (!(ix & 3))\n-\t    printf (\"\\n%s:\\t\\t%u:\", filename, blockno);\n+\t    printf (\"\\n%s:\\tblock %u:\", filename, blockno);\n \t  printf (\" %u:%04x\", dst, flags);\n \t}\n     }\n-  else\n-    gcov_skip (4 + n_arcs * 8);\n-  \n-  return 0;\n }\n \n-static int\n+static void\n tag_lines (filename, tag, length)\n      const char *filename ATTRIBUTE_UNUSED;\n      unsigned tag ATTRIBUTE_UNUSED;\n      unsigned length ATTRIBUTE_UNUSED;\n {\n   if (flag_dump_contents)\n     {\n-      char *source = NULL;\n-      unsigned blockno;\n+      unsigned blockno = gcov_read_unsigned ();\n       char const *sep = NULL;\n \n-      if (gcov_read_unsigned (&blockno))\n-\treturn 1;\n-      \n       while (1)\n \t{\n-\t  unsigned lineno;\n+\t  const char *source = NULL;\n+\t  unsigned lineno = gcov_read_unsigned ();\n \t  \n-\t  if (gcov_read_unsigned (&lineno))\n-\t    {\n-\t      free (source);\n-\t      return 1;\n-\t    }\n \t  if (!lineno)\n \t    {\n-\t      if (gcov_read_string (&source))\n-\t\treturn 1;\n+\t      source = gcov_read_string ();\n \t      if (!source)\n \t\tbreak;\n \t      sep = NULL;\n \t    }\n \t  \n \t  if (!sep)\n \t    {\n-\t      printf (\"\\n%s:\\t\\t%u:\", filename, blockno);\n+\t      printf (\"\\n%s:\\tblock %u:\", filename, blockno);\n \t      sep = \"\";\n \t    }\n \t  if (lineno)\n@@ -396,13 +360,9 @@ tag_lines (filename, tag, length)\n \t    }\n \t}\n     }\n-  else\n-    gcov_skip (length);\n-  \n-  return 0;\n }\n \n-static int\n+static void\n tag_arc_counts (filename, tag, length)\n      const char *filename ATTRIBUTE_UNUSED;\n      unsigned tag ATTRIBUTE_UNUSED;\n@@ -417,32 +377,26 @@ tag_arc_counts (filename, tag, length)\n \n       for (ix = 0; ix != n_counts; ix++)\n \t{\n-\t  gcov_type count;\n+\t  gcov_type count = gcov_read_counter ();\n \t  \n-\t  if (gcov_read_counter (&count))\n-\t    return 1;\n \t  if (!(ix & 7))\n \t    printf (\"\\n%s:\\t\\t%u\", filename, ix);\n \t  printf (\" \");\n \t  printf (HOST_WIDEST_INT_PRINT_DEC, count);\n \t}\n     }\n-  else\n-    gcov_skip (n_counts * 8);\n-  \n-  return 0;\n }\n \n-static int\n+static void\n tag_summary (filename, tag, length)\n      const char *filename ATTRIBUTE_UNUSED;\n      unsigned tag ATTRIBUTE_UNUSED;\n      unsigned length ATTRIBUTE_UNUSED;\n {\n   struct gcov_summary summary;\n \n-  if (gcov_read_summary (&summary))\n-    return 1;\n+  gcov_read_summary (&summary);\n+  \n   printf (\" checksum=0x%08x\", summary.checksum);\n   \n   printf (\"\\n%s:\\t\\truns=%u, arcs=%u\", filename,\n@@ -459,5 +413,4 @@ tag_summary (filename, tag, length)\n   printf (\", sum_max=\");\n   printf (HOST_WIDEST_INT_PRINT_DEC, \n \t  (HOST_WIDEST_INT)summary.arc_sum_max);\n-  return 0;\n }"}, {"sha": "3bd2729d9d2e9618fe4a6c39e402cd2dbc58928c", "filename": "gcc/gcov-io.h", "status": "modified", "additions": 229, "deletions": 251, "changes": 480, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94de45d9fe364fefd0cea5352c486306e68d704b/gcc%2Fgcov-io.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94de45d9fe364fefd0cea5352c486306e68d704b/gcc%2Fgcov-io.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.h?ref=94de45d9fe364fefd0cea5352c486306e68d704b", "patch": "@@ -287,45 +287,44 @@ extern void __gcov_flush (void);\n /* Because small reads and writes, interspersed with seeks cause lots\n    of disk activity, we buffer the entire count files.  */\n \n-static FILE *gcov_file;\n-static size_t gcov_position;\n-static size_t gcov_length;\n-static unsigned char *gcov_buffer;\n-static size_t gcov_alloc;\n-static int gcov_modified;\n-static int gcov_errored = 1;\n+static struct gcov_var\n+{\n+  FILE *file;\n+  size_t position;\n+  size_t length;\n+  size_t alloc;\n+  unsigned modified;\n+  int error;\n+  unsigned char *buffer;\n+} gcov_var;\n \n /* Functions for reading and writing gcov files.  */\n static int gcov_open (const char */*name*/, int /*truncate*/);\n static int gcov_close (void);\n #if !IN_GCOV\n static unsigned char *gcov_write_bytes (unsigned);\n-static int gcov_write_unsigned (unsigned);\n+static void gcov_write_unsigned (unsigned);\n #if IN_LIBGCOV\n-static int gcov_write_counter (gcov_type);\n+static void gcov_write_counter (gcov_type);\n #endif\n-static int gcov_write_string (const char *);\n-static unsigned long gcov_reserve_length (void);\n-static int gcov_write_length (unsigned long /*position*/);\n+static void gcov_write_string (const char *);\n+static unsigned long gcov_write_tag (unsigned);\n+static void gcov_write_length (unsigned long /*position*/);\n #if IN_LIBGCOV\n-static int gcov_write_summary (unsigned, const struct gcov_summary *);\n+static void gcov_write_summary (unsigned, const struct gcov_summary *);\n #endif\n #endif /* !IN_GCOV */\n static const unsigned char *gcov_read_bytes (unsigned);\n-static int gcov_read_unsigned (unsigned *);\n-static int gcov_read_counter (gcov_type *);\n-#if !IN_LIBGCOV\n-static int gcov_read_string (char **);\n-#endif\n-static int gcov_read_summary (struct gcov_summary *);\n-static unsigned long gcov_save_position (void);\n-static int gcov_resync (unsigned long /*base*/, unsigned /*length */);\n+static unsigned gcov_read_unsigned (void);\n+static gcov_type gcov_read_counter (void);\n+static const char *gcov_read_string (void);\n+static void gcov_read_summary (struct gcov_summary *);\n+\n+static unsigned long gcov_position (void);\n+static void gcov_seek (unsigned long /*base*/, unsigned /*length */);\n static unsigned long gcov_seek_end (void);\n-static int gcov_skip (unsigned /*length*/);\n-static int gcov_skip_string (unsigned /*length*/);\n-static int gcov_ok (void);\n-static int gcov_error (void);\n-static int gcov_eof (void);\n+static int gcov_is_eof (void);\n+static int gcov_is_error (void);\n #if IN_GCOV > 0\n static time_t gcov_time (void);\n #endif\n@@ -353,62 +352,63 @@ gcov_open (const char *name, int mode)\n   s_flock.l_pid = getpid ();\n #endif\n   \n-  if (gcov_file)\n+  if (gcov_var.file)\n     abort ();\n-  gcov_position = gcov_length = 0;\n-  gcov_errored = gcov_modified = 0;\n+  gcov_var.position = gcov_var.length = 0;\n+  gcov_var.error = gcov_var.modified = 0;\n   if (mode >= 0)\n-    gcov_file = fopen (name, \"r+b\");\n-  if (!gcov_file && mode <= 0)\n+    gcov_var.file = fopen (name, \"r+b\");\n+  if (!gcov_var.file && mode <= 0)\n     {\n       result = -1;\n-      gcov_file = fopen (name, \"w+b\");\n+      gcov_var.file = fopen (name, \"w+b\");\n     }\n-  if (!gcov_file)\n+  if (!gcov_var.file)\n     return 0;\n \n #if defined (TARGET_HAS_F_SETLKW) && IN_LIBGCOV\n-  while (fcntl (fileno (gcov_file), F_SETLKW, &s_flock)\n+  while (fcntl (fileno (gcov_var.file), F_SETLKW, &s_flock)\n \t && errno == EINTR)\n     continue;\n #endif\n \n   if (result >= 0)\n     {\n-      if (fseek (gcov_file, 0, SEEK_END))\n+      if (fseek (gcov_var.file, 0, SEEK_END))\n \t{\n-\t  fclose (gcov_file);\n-\t  gcov_file = 0;\n+\t  fclose (gcov_var.file);\n+\t  gcov_var.file = 0;\n \t  return 0;\n \t}\n-      gcov_length = ftell (gcov_file);\n-      fseek (gcov_file, 0, SEEK_SET);\n-      alloc += gcov_length;\n+      gcov_var.length = ftell (gcov_var.file);\n+      fseek (gcov_var.file, 0, SEEK_SET);\n+      alloc += gcov_var.length;\n     }\n-  if (alloc > gcov_alloc)\n+  if (alloc > gcov_var.alloc)\n     {\n-      if (gcov_buffer)\n-\tfree (gcov_buffer);\n-      gcov_alloc = alloc;\n+      if (gcov_var.buffer)\n+\tfree (gcov_var.buffer);\n+      gcov_var.alloc = alloc;\n #if IN_LIBGCOV\n-      gcov_buffer = malloc (gcov_alloc);\n-      if (!gcov_buffer)\n+      gcov_var.buffer = malloc (gcov_var.alloc);\n+      if (!gcov_var.buffer)\n \t{\n-\t  fclose (gcov_file);\n-\t  gcov_file = 0;\n-\t  gcov_length = 0;\n-\t  gcov_alloc = 0;\n+\t  fclose (gcov_var.file);\n+\t  gcov_var.file = 0;\n+\t  gcov_var.length = 0;\n+\t  gcov_var.alloc = 0;\n \t  return 0;\n \t}\n #else\n-      gcov_buffer = xmalloc (gcov_alloc);\n+      gcov_var.buffer = xmalloc (gcov_var.alloc);\n #endif\n     }\n-  if (result >= 0 && fread (gcov_buffer, gcov_length, 1, gcov_file) != 1)\n+  if (result >= 0\n+      && fread (gcov_var.buffer, gcov_var.length, 1, gcov_var.file) != 1)\n     {\n-      fclose (gcov_file);\n-      gcov_file = 0;\n-      gcov_length = 0;\n+      fclose (gcov_var.file);\n+      gcov_var.file = 0;\n+      gcov_var.length = 0;\n       return 0;\n     }\n   return result;\n@@ -422,17 +422,23 @@ gcov_close ()\n {\n   int result = 0;\n   \n-  if (gcov_file)\n+  if (gcov_var.file)\n     {\n-      if (gcov_modified\n-\t  && (fseek (gcov_file, 0, SEEK_SET)\n-\t      || fwrite (gcov_buffer, gcov_length, 1, gcov_file) != 1))\n-\tresult = -1;\n-      fclose (gcov_file);\n-      gcov_file = 0;\n-      gcov_length = 0;\n+      if (gcov_var.modified\n+\t  && (fseek (gcov_var.file, 0, SEEK_SET)\n+\t      || fwrite (gcov_var.buffer, gcov_var.length,\n+\t\t\t 1, gcov_var.file) != 1))\n+\tresult = 1;\n+      fclose (gcov_var.file);\n+      gcov_var.file = 0;\n+      gcov_var.length = 0;\n     }\n-  return result || gcov_errored;\n+#if !IN_LIBGCOV\n+  free (gcov_var.buffer);\n+  gcov_var.alloc = 0;\n+  gcov_var.buffer = 0;\n+#endif\n+  return result ? 1 : gcov_var.error;\n }\n \n #if !IN_GCOV\n@@ -444,167 +450,177 @@ gcov_write_bytes (unsigned bytes)\n {\n   char unsigned *result;\n \n-  if (gcov_position + bytes > gcov_alloc)\n+  if (gcov_var.position + bytes > gcov_var.alloc)\n     {\n-      size_t new_size = (gcov_alloc + bytes) * 3 / 2;\n+      size_t new_size = (gcov_var.alloc + bytes) * 3 / 2;\n \n-      if (!gcov_buffer)\n+      if (!gcov_var.buffer)\n \treturn 0;\n #if IN_LIBGCOV\n-      result = realloc (gcov_buffer, new_size);\n+      result = realloc (gcov_var.buffer, new_size);\n       if (!result)\n \t{\n-\t  free (gcov_buffer);\n-\t  gcov_buffer = 0;\n-\t  gcov_alloc = 0;\n-\t  gcov_position = gcov_length = 0;\n+\t  free (gcov_var.buffer);\n+\t  gcov_var.buffer = 0;\n+\t  gcov_var.alloc = 0;\n+\t  gcov_var.position = gcov_var.length = 0;\n+\t  gcov_var.error = 1;\n \t  return 0;\n \t}\n #else\n-      result = xrealloc (gcov_buffer, new_size);\n+      result = xrealloc (gcov_var.buffer, new_size);\n #endif\n-      gcov_alloc = new_size;\n-      gcov_buffer = result;\n+      gcov_var.alloc = new_size;\n+      gcov_var.buffer = result;\n     }\n   \n-  result = &gcov_buffer[gcov_position];\n-  gcov_position += bytes;\n-  gcov_modified = 1;\n-  if (gcov_position > gcov_length)\n-    gcov_length = gcov_position;\n+  result = &gcov_var.buffer[gcov_var.position];\n+  gcov_var.position += bytes;\n+  gcov_var.modified = 1;\n+  if (gcov_var.position > gcov_var.length)\n+    gcov_var.length = gcov_var.position;\n   return result;\n }\n \n-/* Write VALUE to coverage file.  Return nonzero if failed due to\n-   file i/o error, or value error.  */\n+/* Write unsigned VALUE to coverage file.  Sets error flag\n+   appropriately.  */\n \n-static int\n+static void\n gcov_write_unsigned (unsigned value)\n {\n   unsigned char *buffer = gcov_write_bytes (4);\n   unsigned ix;\n \n   if (!buffer)\n-    return 1;\n-  \n+    return;\n   for (ix = 4; ix--; )\n     {\n       buffer[ix] = value;\n       value >>= 8;\n     }\n-  return sizeof (value) > 4 && value;\n+  if (sizeof (value) > 4 && value)\n+    gcov_var.error = -1;\n+\n+  return;\n }\n \n-/* Write VALUE to coverage file.  Return nonzero if failed due to\n-   file i/o error, or value error.  Negative values are not checked\n-   here -- they are checked in gcov_read_counter.  */\n+/* Write counter VALUE to coverage file.  Sets error flag\n+   appropriately.  */\n \n #if IN_LIBGCOV\n-static int\n+static void\n gcov_write_counter (gcov_type value)\n {\n   unsigned char *buffer = gcov_write_bytes (8);\n   unsigned ix;\n \n   if (!buffer)\n-    return 1;\n-  \n+    return;\n   for (ix = 8; ix--; )\n     {\n       buffer[ix] = value;\n       value >>= 8;\n     }\n-  return sizeof (value) > 8 && value;\n+  if ((sizeof (value) > 8 && value) || value < 0)\n+    gcov_var.error = -1;\n+  return;\n }\n #endif /* IN_LIBGCOV */\n \n-/* Write VALUE to coverage file.  Return nonzero if failed due to\n-   file i/o error, or value error.  */\n+/* Write STRING to coverage file.  Sets error flag on file\n+   error, overflow flag on overflow */\n \n-static int\n+static void\n gcov_write_string (const char *string)\n {\n+  unsigned length = 0;\n+  unsigned pad = 0;\n+  unsigned rem = 0;\n+  unsigned char *buffer;\n+\n   if (string)\n     {\n-      unsigned length = strlen (string);\n-      unsigned pad = 0;\n-      unsigned rem = 4 - (length & 3);\n-      unsigned char *buffer;\n-\n-      if (gcov_write_unsigned (length))\n-\treturn 1;\n-      buffer = gcov_write_bytes (length + rem);\n-      if (!buffer)\n-\treturn 1;\n-      memcpy (buffer, string, length);\n-      memcpy (buffer + length, &pad, rem);\n-      return 0;\n+      length = strlen (string);\n+      rem = 4 - (length & 3);\n+    }\n+  \n+  buffer = gcov_write_bytes (4 + length + rem);\n+  if (buffer)\n+    {\n+      unsigned ix;\n+      unsigned value = length;\n+      \n+      for (ix = 4; ix--; )\n+\t{\n+\t  buffer[ix] = value;\n+\t  value >>= 8;\n+\t}\n+      memcpy (buffer + 4, string, length);\n+      memcpy (buffer + 4 + length, &pad, rem);\n     }\n-  else\n-    return gcov_write_unsigned (0);\n }\n \n-/* Allocate space to write a record tag length.  Return a value to be\n-   used for gcov_write_length.  */\n+/* Write a tag TAG and reserve space for the record length. Return a\n+   value to be used for gcov_write_length.  */\n \n static unsigned long\n-gcov_reserve_length (void)\n+gcov_write_tag (unsigned tag)\n {\n-  unsigned long result = gcov_position;\n-  unsigned char *buffer = gcov_write_bytes (4);\n+  unsigned long result = gcov_var.position;\n+  unsigned char *buffer = gcov_write_bytes (8);\n+  unsigned ix;\n \n   if (!buffer)\n     return 0;\n-  memset (buffer, 0, 4);\n+  for (ix = 4; ix--; )\n+    {\n+      buffer[ix] = tag;\n+      tag >>= 8;\n+    }\n+  memset (buffer + 4, 0, 4);\n   return result;\n }\n \n-/* Write a record length at PLACE.  The current file position is the\n-   end of the record, and is restored before returning.  Returns\n-   nonzero on failure.  */\n+/* Write a record length using POSITION, which was returned by\n+   gcov_write_tag.  The current file position is the end of the\n+   record, and is restored before returning.  Returns nonzero on\n+   overflow.  */\n \n-static int\n+static void\n gcov_write_length (unsigned long position)\n {\n-  unsigned length = gcov_position - position - 4;\n-  unsigned char *buffer = &gcov_buffer[position];\n-  unsigned ix;\n-\n-  if (!position)\n-    return 1;\n-  for (ix = 4; ix--; )\n+  if (position)\n     {\n-      buffer[ix] = length;\n-      length >>= 8;\n+      unsigned length = gcov_var.position - position - 8;\n+      unsigned char *buffer = &gcov_var.buffer[position + 4];\n+      unsigned ix;\n+      \n+      for (ix = 4; ix--; )\n+\t{\n+\t  buffer[ix] = length;\n+\t  length >>= 8;\n+\t}\n     }\n-  return 0;\n }\n \n #if IN_LIBGCOV\n-/* Write a summary structure to the gcov file.  */\n+/* Write a summary structure to the gcov file.  Return non-zero on\n+   overflow.  */\n \n-static int\n+static void\n gcov_write_summary (unsigned tag, const struct gcov_summary *summary)\n {\n-  volatile unsigned long base; /* volatile is necessary to work around\n-\t\t\t\t  a compiler bug. */\n-\n-  if (gcov_write_unsigned (tag))\n-    return 1;\n-  base = gcov_reserve_length ();\n-  if (gcov_write_unsigned (summary->checksum))\n-    return 1;\n-  if (gcov_write_unsigned (summary->runs)\n-      || gcov_write_unsigned (summary->arcs))\n-    return 1;\n-  if (gcov_write_counter (summary->arc_sum)\n-      || gcov_write_counter (summary->arc_max_one)\n-      || gcov_write_counter (summary->arc_max_sum)\n-      || gcov_write_counter (summary->arc_sum_max))\n-    return 1;\n-  if (gcov_write_length (base))\n-    return 1;\n-  return 0;\n+  unsigned long base;\n+\n+  base = gcov_write_tag (tag);\n+  gcov_write_unsigned (summary->checksum);\n+  gcov_write_unsigned (summary->runs);\n+  gcov_write_unsigned (summary->arcs);\n+  gcov_write_counter (summary->arc_sum);\n+  gcov_write_counter (summary->arc_max_one);\n+  gcov_write_counter (summary->arc_max_sum);\n+  gcov_write_counter (summary->arc_sum_max);\n+  gcov_write_length (base);\n }\n #endif /* IN_LIBGCOV */\n \n@@ -618,181 +634,143 @@ gcov_read_bytes (unsigned bytes)\n {\n   const unsigned char *result;\n   \n-  if (gcov_position + bytes > gcov_length)\n-    return 0;\n-  result = &gcov_buffer[gcov_position];\n-  gcov_position += bytes;\n+  if (gcov_var.position + bytes > gcov_var.length)\n+    {\n+      gcov_var.error = 1;\n+      return 0;\n+    }\n+  \n+  result = &gcov_var.buffer[gcov_var.position];\n+  gcov_var.position += bytes;\n   return result;\n }\n \n-/* Read *VALUE_P from coverage file.  Return nonzero if failed\n-   due to file i/o error, or range error.  */\n+/* Read unsigned value from a coverage file. Sets error flag on file\n+   error, overflow flag on overflow */\n \n-static int\n-gcov_read_unsigned (unsigned *value_p)\n+static unsigned\n+gcov_read_unsigned ()\n {\n   unsigned value = 0;\n   unsigned ix;\n   const unsigned char *buffer = gcov_read_bytes (4);\n \n   if (!buffer)\n-    return 1;\n+    return 0;\n   for (ix = sizeof (value); ix < 4; ix++)\n     if (buffer[ix])\n-      return 1;\n+      gcov_var.error = -1;\n   for (ix = 0; ix != 4; ix++)\n     {\n       value <<= 8;\n       value |= buffer[ix];\n     }\n-  *value_p = value;\n-  return 0;\n+  return value;\n }\n \n-/* Read *VALUE_P from coverage file.  Return nonzero if failed\n-   due to file i/o error, or range error.  */\n+/* Read counter value from a coverage file. Sets error flag on file\n+   error, overflow flag on overflow */\n \n-static int\n-gcov_read_counter (gcov_type *value_p)\n+static gcov_type\n+gcov_read_counter ()\n {\n   gcov_type value = 0;\n   unsigned ix;\n   const unsigned char *buffer = gcov_read_bytes (8);\n \n   if (!buffer)\n-    return 1;\n+    return 0;\n   for (ix = sizeof (value); ix < 8; ix++)\n     if (buffer[ix])\n-      return 1;\n+      gcov_var.error = -1;\n   for (ix = 0; ix != 8; ix++)\n     {\n       value <<= 8;\n       value |= buffer[ix];\n     }\n-\n-  *value_p = value;\n-  return value < 0;\n+  if (value < 0)\n+    gcov_var.error = -1;\n+  return value;\n }\n \n-#if !IN_LIBGCOV\n-\n-/* Read string from coverage file.  A buffer is allocated and returned\n-   in *STRING_P.  Return nonzero if failed due to file i/o error, or\n-   range error.  Uses xmalloc to allocate the string buffer.  */\n+/* Read string from coverage file. Returns a pointer to a static\n+   buffer, or NULL on empty string. You must copy the string before\n+   calling another gcov function.  */\n \n-static int\n-gcov_read_string (char **string_p)\n+static const char *\n+gcov_read_string ()\n {\n-  unsigned length;\n-  const unsigned char *buffer;\n-\n-  if (gcov_read_unsigned (&length))\n-    return 1;\n-\n-  free (*string_p);\n-  *string_p = NULL;\n+  unsigned length = gcov_read_unsigned ();\n+  \n   if (!length)\n     return 0;\n \n   length += 4 - (length & 3);\n-  buffer = gcov_read_bytes (length);\n-  if (!buffer)\n-    return 1;\n-  \n-  *string_p = xmalloc (length);\n-  if (!*string_p)\n-    return 1;\n-\n-  memcpy (*string_p, buffer, length);\n-  return 0;\n+  return (const char *) gcov_read_bytes (length);\n }\n \n-#endif /* !IN_LIBGCOV */\n-\n #define GCOV_SUMMARY_LENGTH 44\n-static int\n+static void\n gcov_read_summary (struct gcov_summary *summary)\n {\n-  return (gcov_read_unsigned (&summary->checksum)\n-\t  || gcov_read_unsigned (&summary->runs)\n-\t  || gcov_read_unsigned (&summary->arcs)\n-\t  || gcov_read_counter (&summary->arc_sum)\n-\t  || gcov_read_counter (&summary->arc_max_one)\n-\t  || gcov_read_counter (&summary->arc_max_sum)\n-\t  || gcov_read_counter (&summary->arc_sum_max));\n+  summary->checksum = gcov_read_unsigned ();\n+  summary->runs = gcov_read_unsigned ();\n+  summary->arcs = gcov_read_unsigned ();\n+  summary->arc_sum = gcov_read_counter ();\n+  summary->arc_max_one = gcov_read_counter ();\n+  summary->arc_max_sum =  gcov_read_counter ();\n+  summary->arc_sum_max = gcov_read_counter ();\n }\n \n /* Save the current position in the gcov file.  */\n \n static inline unsigned long\n-gcov_save_position (void)\n+gcov_position (void)\n {\n-  return gcov_position;\n+  return gcov_var.position;\n }\n \n /* Reset to a known position.  BASE should have been obtained from\n    gcov_save_position, LENGTH should be a record length, or zero.  */\n \n-static inline int\n-gcov_resync (unsigned long base, unsigned length)\n+static inline void\n+gcov_seek (unsigned long base, unsigned length)\n {\n-  if (gcov_buffer)\n-    gcov_position = base + length;\n-  return 0;\n+  if (gcov_var.buffer)\n+    {\n+      base += length;\n+      if (gcov_var.length < base)\n+\t{\n+\t  gcov_var.error = 1;\n+\t  base = gcov_var.length;\n+\t}\n+      gcov_var.position = base;\n+    }\n }\n \n /* Move to the end of the gcov file.  */\n \n static inline unsigned long\n gcov_seek_end ()\n {\n-  gcov_position = gcov_length;\n-  return gcov_position;\n-}\n-\n-/* Skip LENGTH bytes in the file.  */\n-\n-static inline int\n-gcov_skip (unsigned length)\n-{\n-  if (gcov_length < gcov_position + length)\n-    return 1;\n-  gcov_position += length;\n-  return 0;\n-}\n-\n-/* Skip a string of LENGTH bytes.  */\n-\n-static inline int\n-gcov_skip_string (unsigned length)\n-{\n-  return gcov_skip (length + 4 - (length & 3));\n+  gcov_var.position = gcov_var.length;\n+  return gcov_var.position;\n }\n \n /* Tests whether we have reached end of .da file.  */\n \n static inline int\n-gcov_eof ()\n+gcov_is_eof ()\n {\n-  return gcov_position == gcov_length;\n+  return gcov_var.position == gcov_var.length;\n }\n \n /* Return non-zero if the error flag is set.  */\n \n static inline int\n-gcov_ok ()\n+gcov_is_error ()\n {\n-  return gcov_file != 0 && !gcov_errored;\n-}\n-\n-/* Set the error flag. */\n-static inline int\n-gcov_error ()\n-{\n-  int error = gcov_errored;\n-  \n-  gcov_errored = 1;\n-  return error;\n+  return gcov_var.file ? gcov_var.error : 1;\n }\n \n #if IN_GCOV > 0\n@@ -803,7 +781,7 @@ gcov_time ()\n {\n   struct stat status;\n   \n-  if (fstat (fileno (gcov_file), &status))\n+  if (fstat (fileno (gcov_var.file), &status))\n     return 0;\n   else\n     return status.st_mtime;"}, {"sha": "b6cbbc80b74e63b8df6cfab27da7d0fd5a063f4d", "filename": "gcc/gcov.c", "status": "modified", "additions": 74, "deletions": 119, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94de45d9fe364fefd0cea5352c486306e68d704b/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94de45d9fe364fefd0cea5352c486306e68d704b/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=94de45d9fe364fefd0cea5352c486306e68d704b", "patch": "@@ -321,7 +321,7 @@ static void print_usage PARAMS ((int)) ATTRIBUTE_NORETURN;\n static void print_version PARAMS ((void)) ATTRIBUTE_NORETURN;\n static void process_file PARAMS ((const char *));\n static void create_file_names PARAMS ((const char *));\n-static source_t *find_source PARAMS ((char *));\n+static source_t *find_source PARAMS ((const char *));\n static int read_graph_file PARAMS ((void));\n static int read_count_file PARAMS ((void));\n static void solve_flow_graph PARAMS ((function_t *));\n@@ -673,31 +673,29 @@ create_file_names (file_name)\n   return;\n }\n \n-/* Find or create a source file structure for FILE_NAME. Free\n-   FILE_NAME appropriately */\n+/* Find or create a source file structure for FILE_NAME. Copies\n+   FILE_NAME on creation */\n \n static source_t *\n find_source (file_name)\n-     char *file_name;\n+     const char *file_name;\n {\n-\n   source_t *src;\n+\n+  if (!file_name)\n+    file_name = \"<unknown>\";\n   \n   for (src = sources; src; src = src->next)\n     if (!strcmp (file_name, src->name))\n-      {\n-\tfree (file_name);\n-\tbreak;\n-      }\n-  if (!src)\n-    {\n-      src = (source_t *)xcalloc (1, sizeof (source_t));\n-      src->name = file_name;\n-      src->coverage.name = file_name;\n-      src->index = sources ? sources->index + 1 : 1;\n-      src->next = sources;\n-      sources = src;\n-    }\n+      return src;\n+  \n+  src = (source_t *)xcalloc (1, sizeof (source_t));\n+  src->name = xstrdup (file_name);\n+  src->coverage.name = src->name;\n+  src->index = sources ? sources->index + 1 : 1;\n+  src->next = sources;\n+  sources = src;\n+\n   return src;\n }\n \n@@ -706,9 +704,8 @@ find_source (file_name)\n static int\n read_graph_file ()\n {\n-  unsigned magic, version;\n+  unsigned version;\n   unsigned current_tag = 0;\n-  unsigned tag;\n   struct function_info *fn = NULL;\n   source_t *src = NULL;\n   unsigned ix;\n@@ -719,52 +716,46 @@ read_graph_file ()\n       return 1;\n     }\n   bbg_file_time = gcov_time ();\n-  if (gcov_read_unsigned (&magic) || magic != GCOV_GRAPH_MAGIC)\n+  if (gcov_read_unsigned () != GCOV_GRAPH_MAGIC)\n     {\n       fnotice (stderr, \"%s:not a gcov graph file\\n\", bbg_file_name);\n       gcov_close ();\n       return 1;\n     }\n \n-  if (gcov_read_unsigned (&version) || version != GCOV_VERSION)\n+  version = gcov_read_unsigned ();\n+  if (version != GCOV_VERSION)\n     {\n       char v[4], e[4];\n-\n-      magic = GCOV_VERSION;\n+      unsigned required = GCOV_VERSION;\n       \n-      for (ix = 4; ix--; magic >>= 8, version >>= 8)\n+      for (ix = 4; ix--; required >>= 8, version >>= 8)\n \t{\n \t  v[ix] = version;\n-\t  e[ix] = magic;\n+\t  e[ix] = required;\n \t}\n       fnotice (stderr, \"%s:version `%.4s', prefer `%.4s'\\n\",\n \t       bbg_file_name, v, e);\n     }\n   \n-  while (!gcov_read_unsigned (&tag))\n+  while (!gcov_is_eof ())\n     {\n-      unsigned length;\n-      long base;\n-\n-      if (gcov_read_unsigned (&length))\n-\tgoto corrupt;\n-\n-      base = gcov_save_position ();\n-\n+      unsigned tag = gcov_read_unsigned ();\n+      unsigned length = gcov_read_unsigned ();\n+      unsigned long base = gcov_position ();\n+      \n       if (tag == GCOV_TAG_FUNCTION)\n \t{\n-\t  char *function_name = NULL;\n-\t  char *function_file = NULL;\n+\t  char *function_name;\n \t  unsigned checksum, lineno;\n \t  source_t *src;\n \t  function_t *probe, *prev;\n \n-\t  if (gcov_read_string (&function_name)\n-\t      || gcov_read_unsigned (&checksum)\n-\t      || gcov_read_string (&function_file)\n-\t      || gcov_read_unsigned (&lineno))\n-\t    goto corrupt;\n-\t  src = find_source (function_file);\n+\t  function_name = xstrdup (gcov_read_string ());\n+\t  checksum = gcov_read_unsigned ();\n+\t  src = find_source (gcov_read_string ());\n+\t  lineno = gcov_read_unsigned ();\n+\t  \n \t  fn = (function_t *)xcalloc (1, sizeof (function_t));\n \t  fn->name = function_name;\n \t  fn->checksum = checksum;\n@@ -803,33 +794,24 @@ read_graph_file ()\n \t      fn->blocks\n \t\t= (block_t *)xcalloc (fn->num_blocks, sizeof (block_t));\n \t      for (ix = 0; ix != num_blocks; ix++)\n-\t\t{\n-\t\t  unsigned flags;\n-\t\t  \n-\t\t  if (gcov_read_unsigned (&flags))\n-\t\t    goto corrupt;\n-\t\t  fn->blocks[ix].flags = flags;\n-\t\t}\n+\t\tfn->blocks[ix].flags = gcov_read_unsigned ();\n \t    }\n \t}\n       else if (fn && tag == GCOV_TAG_ARCS)\n \t{\n-\t  unsigned src;\n+\t  unsigned src = gcov_read_unsigned ();\n \t  unsigned num_dests = (length - 4) / 8;\n-\t  unsigned dest, flags;\n \n-\t  if (gcov_read_unsigned (&src)\n-\t      || src >= fn->num_blocks\n-\t      || fn->blocks[src].succ)\n+\t  if (src >= fn->num_blocks || fn->blocks[src].succ)\n \t    goto corrupt;\n \t  \n \t  while (num_dests--)\n \t    {\n \t      struct arc_info *arc;\n+\t      unsigned dest = gcov_read_unsigned ();\n+\t      unsigned flags = gcov_read_unsigned ();\n \t      \n-\t      if (gcov_read_unsigned (&dest)\n-\t\t  || gcov_read_unsigned (&flags)\n-\t\t  || dest >= fn->num_blocks)\n+\t      if (dest >= fn->num_blocks)\n \t\tgoto corrupt;\n \t      arc = (arc_t *) xcalloc (1, sizeof (arc_t));\n \t      \n@@ -875,21 +857,17 @@ read_graph_file ()\n \t}\n       else if (fn && tag == GCOV_TAG_LINES)\n \t{\n-\t  unsigned blockno;\n+\t  unsigned blockno = gcov_read_unsigned ();\n \t  unsigned *line_nos\n \t    = (unsigned *)xcalloc ((length - 4) / 4, sizeof (unsigned));\n \n-\t  if (gcov_read_unsigned (&blockno)\n-\t      || blockno >= fn->num_blocks\n-\t      || fn->blocks[blockno].u.line.encoding)\n+\t  if (blockno >= fn->num_blocks || fn->blocks[blockno].u.line.encoding)\n \t    goto corrupt;\n \t  \n \t  for (ix = 0; ;  )\n \t    {\n-\t      unsigned lineno;\n+\t      unsigned lineno = gcov_read_unsigned ();\n \t      \n-\t      if (gcov_read_unsigned (&lineno))\n-\t\tgoto corrupt;\n \t      if (lineno)\n \t\t{\n \t\t  if (!ix)\n@@ -903,10 +881,8 @@ read_graph_file ()\n \t\t}\n \t      else\n \t\t{\n-\t\t  char *file_name = NULL;\n+\t\t  const char *file_name = gcov_read_string ();\n \t\t  \n-\t\t  if (gcov_read_string (&file_name))\n-\t\t    goto corrupt;\n \t\t  if (!file_name)\n \t\t    break;\n \t\t  src = find_source (file_name);\n@@ -924,7 +900,8 @@ read_graph_file ()\n \t  fn = NULL;\n \t  current_tag = 0;\n \t}\n-      if (gcov_resync (base, length))\n+      gcov_seek (base, length);\n+      if (gcov_is_error ())\n \t{\n \tcorrupt:;\n \t  fnotice (stderr, \"%s:corrupted\\n\", bbg_file_name);\n@@ -994,72 +971,52 @@ static int\n read_count_file ()\n {\n   unsigned ix;\n-  char *function_name_buffer = NULL;\n-  unsigned magic, version;\n+  unsigned version;\n   function_t *fn = NULL;\n \n   if (!gcov_open (da_file_name, 1))\n     {\n       fnotice (stderr, \"%s:cannot open data file\\n\", da_file_name);\n       return 1;\n     }\n-  if (gcov_read_unsigned (&magic) || magic != GCOV_DATA_MAGIC)\n+  if (gcov_read_unsigned () != GCOV_DATA_MAGIC)\n     {\n       fnotice (stderr, \"%s:not a gcov data file\\n\", da_file_name);\n     cleanup:;\n-      free (function_name_buffer);\n       gcov_close ();\n       return 1;\n     }\n-  if (gcov_read_unsigned (&version) || version != GCOV_VERSION)\n+  version = gcov_read_unsigned ();\n+  if (version != GCOV_VERSION)\n     {\n       char v[4], e[4];\n+      unsigned desired = GCOV_VERSION;\n       \n-      magic = GCOV_VERSION;\n-      for (ix = 4; ix--; magic >>= 8, version >>= 8)\n+      for (ix = 4; ix--; desired >>= 8, version >>= 8)\n \t{\n \t  v[ix] = version;\n-\t  e[ix] = magic;\n+\t  e[ix] = desired;\n \t}\n       fnotice (stderr, \"%s:version `%.4s', prefer version `%.4s'\\n\",\n \t       da_file_name, v, e);\n     }\n   \n-  while (1)\n+  while (!gcov_is_eof ())\n     {\n-      unsigned tag, length;\n-      long base;\n-      \n-      if (gcov_read_unsigned (&tag)\n-\t  || gcov_read_unsigned (&length))\n-\t{\n-\t  if (gcov_eof ())\n-\t    break;\n-\t  \n-\tcorrupt:;\n-\t  fnotice (stderr, \"%s:corrupted\\n\", da_file_name);\n-\t  goto cleanup;\n-\t}\n-      base = gcov_save_position ();\n+      unsigned tag = gcov_read_unsigned ();\n+      unsigned length = gcov_read_unsigned ();\n+      unsigned long base = gcov_position ();\n+      int error;\n+\n       if (tag == GCOV_TAG_OBJECT_SUMMARY)\n-\t{\n-\t  if (gcov_read_summary (&object_summary))\n-\t    goto corrupt;\n-\t}\n+\tgcov_read_summary (&object_summary);\n       else if (tag == GCOV_TAG_PROGRAM_SUMMARY\n \t       || tag == GCOV_TAG_INCORRECT_SUMMARY)\n-\t{\n-\t  program_count++;\n-\t  gcov_resync (base, length);\n-\t}\n+\tprogram_count++;\n       else if (tag == GCOV_TAG_FUNCTION)\n \t{\n-\t  unsigned checksum;\n+\t  const char *function_name = gcov_read_string ();\n \t  struct function_info *fn_n = functions;\n-\t  \n-\t  if (gcov_read_string (&function_name_buffer)\n-\t      || gcov_read_unsigned (&checksum))\n-\t    goto corrupt;\n \n \t  for (fn = fn ? fn->next : NULL; ; fn = fn->next)\n \t    {\n@@ -1070,20 +1027,20 @@ read_count_file ()\n \t      else\n \t\t{\n \t\t  fnotice (stderr, \"%s:unknown function `%s'\\n\",\n-\t\t\t   da_file_name, function_name_buffer);\n+\t\t\t   da_file_name, function_name);\n \t\t  break;\n \t\t}\n-\t      if (!strcmp (fn->name, function_name_buffer))\n+\t      if (!strcmp (fn->name, function_name))\n \t\tbreak;\n \t    }\n \n \t  if (!fn)\n \t    ;\n-\t  else if (checksum != fn->checksum)\n+\t  else if (gcov_read_unsigned () != fn->checksum)\n \t    {\n \t    mismatch:;\n \t      fnotice (stderr, \"%s:profile mismatch for `%s'\\n\",\n-\t\t       da_file_name, function_name_buffer);\n+\t\t       da_file_name, fn->name);\n \t      goto cleanup;\n \t    }\n \t}\n@@ -1097,20 +1054,18 @@ read_count_file ()\n \t      = (gcov_type *)xcalloc (fn->num_counts, sizeof (gcov_type));\n \t  \n \t  for (ix = 0; ix != fn->num_counts; ix++)\n-\t    {\n-\t      gcov_type count;\n-\t      \n-\t      if (gcov_read_counter (&count))\n-\t\tgoto corrupt;\n-\t      fn->counts[ix] += count;\n-\t    }\n+\t    fn->counts[ix] += gcov_read_counter ();\n+\t}\n+      gcov_seek (base, length);\n+      if ((error = gcov_is_error ()))\n+\t{\n+\t  fnotice (stderr, error < 0\n+\t\t   ? \"%s:overflowed\\n\" : \"%s:corrupted\\n\", da_file_name);\n+\t  goto cleanup;\n \t}\n-      else\n-\tgcov_resync (base, length);\n     }\n \n   gcov_close ();\n-  free (function_name_buffer);\n   return 0;\n }\n "}, {"sha": "ea197f826529cfb338a31dae155b9bb681cc9cfc", "filename": "gcc/libgcov.c", "status": "modified", "additions": 55, "deletions": 86, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94de45d9fe364fefd0cea5352c486306e68d704b/gcc%2Flibgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94de45d9fe364fefd0cea5352c486306e68d704b/gcc%2Flibgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcov.c?ref=94de45d9fe364fefd0cea5352c486306e68d704b", "patch": "@@ -110,14 +110,14 @@ gcov_exit (void)\n     {\n       struct gcov_summary object;\n       struct gcov_summary local_prg;\n+      int error;\n       int merging;\n-      long base;\n+      unsigned long base;\n       const struct function_info *fn_info;\n       gcov_type **counters;\n       gcov_type *count_ptr;\n       gcov_type object_max_one = 0;\n-      gcov_type count;\n-      unsigned tag, length, flength, checksum;\n+      unsigned tag, length;\n       unsigned arc_data_index, f_sect_index, sect_index;\n \n       ptr->wkspc = 0;\n@@ -167,7 +167,7 @@ gcov_exit (void)\n       if (merging > 0)\n \t{\n \t  /* Merge data from file.  */\n-\t  if (gcov_read_unsigned (&tag) || tag != GCOV_DATA_MAGIC)\n+\t  if (gcov_read_unsigned () != GCOV_DATA_MAGIC)\n \t    {\n \t      fprintf (stderr, \"profiling:%s:Not a gcov data file\\n\",\n \t\t       ptr->filename);\n@@ -176,7 +176,8 @@ gcov_exit (void)\n \t      ptr->filename = 0;\n \t      continue;\n \t    }\n-\t  if (gcov_read_unsigned (&length) || length != GCOV_VERSION)\n+\t  length = gcov_read_unsigned ();\n+\t  if (length != GCOV_VERSION)\n \t    {\n \t      gcov_version_mismatch (ptr, length);\n \t      goto read_fatal;\n@@ -186,13 +187,8 @@ gcov_exit (void)\n \t  for (ix = ptr->n_functions, fn_info = ptr->functions;\n \t       ix--; fn_info++)\n \t    {\n-\t      if (gcov_read_unsigned (&tag) || gcov_read_unsigned (&length))\n-\t\t{\n-\t\tread_error:;\n-\t\t  fprintf (stderr, \"profiling:%s:Error merging\\n\",\n-\t\t\t   ptr->filename);\n-\t\t  goto read_fatal;\n-\t\t}\n+\t      tag = gcov_read_unsigned ();\n+\t      length = gcov_read_unsigned ();\n \n \t      /* Check function */\n \t      if (tag != GCOV_TAG_FUNCTION)\n@@ -203,12 +199,8 @@ gcov_exit (void)\n \t\t  goto read_fatal;\n \t\t}\n \n-\t      if (gcov_read_unsigned (&flength)\n-\t\t  || gcov_skip_string (flength)\n-\t\t  || gcov_read_unsigned (&checksum))\n-\t\tgoto read_error;\n-\t      if (flength != strlen (fn_info->name)\n-\t\t  || checksum != fn_info->checksum)\n+\t      if (strcmp (gcov_read_string (), fn_info->name)\n+\t\t  || gcov_read_unsigned () != fn_info->checksum)\n \t\tgoto read_mismatch;\n \n \t      /* Counters.  */\n@@ -218,9 +210,9 @@ gcov_exit (void)\n \t\t{\n \t\t  unsigned n_counters;\n \n-\t\t  if (gcov_read_unsigned (&tag)\n-\t\t      || gcov_read_unsigned (&length))\n-\t\t    goto read_error;\n+\t\t  tag = gcov_read_unsigned ();\n+\t\t  length = gcov_read_unsigned ();\n+\t\t  \n \t\t  for (sect_index = 0;\n \t\t       sect_index < ptr->n_counter_sections;\n \t\t       sect_index++)\n@@ -235,40 +227,42 @@ gcov_exit (void)\n \t\t    goto read_mismatch;\n \t\t \n \t\t  for (jx = 0; jx < n_counters; jx++)\n-\t    \t    if (gcov_read_counter (&count))\n-    \t\t      goto read_error;\n-\t\t    else\n-\t\t      counters[sect_index][jx] += count;\n+\t\t    counters[sect_index][jx] += gcov_read_counter ();\n+\t\t  \n \t\t  counters[sect_index] += n_counters;\n \t\t}\n+\t      if ((error = gcov_is_error ()))\n+\t\tgoto read_error;\n \t    }\n \n \t  /* Check object summary */\n-\t  if (gcov_read_unsigned (&tag) || gcov_read_unsigned (&length))\n-\t    goto read_error;\n-\t  if (tag != GCOV_TAG_OBJECT_SUMMARY)\n+\t  if (gcov_read_unsigned () != GCOV_TAG_OBJECT_SUMMARY)\n \t    goto read_mismatch;\n-\t  if (gcov_read_summary (&object))\n-\t    goto read_error;\n+\t  gcov_read_unsigned ();\n+\t  gcov_read_summary (&object);\n \n \t  /* Check program summary */\n-\t  while (1)\n+\t  while (!gcov_is_eof ())\n \t    {\n-\t      long base = gcov_save_position ();\n+\t      unsigned long base = gcov_position ();\n \t      \n-\t      if (gcov_read_unsigned (&tag)\n-\t\t  || gcov_read_unsigned (&length))\n-\t\t{\n-\t\t  if (gcov_eof ())\n-\t\t    break;\n-\t\t  goto read_error;\n-\t\t}\n+\t      tag = gcov_read_unsigned ();\n+\t      gcov_read_unsigned ();\n \t      if (tag != GCOV_TAG_PROGRAM_SUMMARY\n \t\t  && tag != GCOV_TAG_PLACEHOLDER_SUMMARY\n \t\t  && tag != GCOV_TAG_INCORRECT_SUMMARY)\n \t\tgoto read_mismatch;\n-\t      if (gcov_read_summary (&local_prg))\n-\t\tgoto read_error;\n+\t      gcov_read_summary (&local_prg);\n+\t      if ((error = gcov_is_error ()))\n+\t\t{\n+\t\tread_error:;\n+\t\t  fprintf (stderr, error < 0 ?\n+\t\t\t   \"profiling:%s:Overflow merging\\n\" :\n+\t\t\t   \"profiling:%s:Error merging\\n\",\n+\t\t\t   ptr->filename);\n+\t\t  goto read_fatal;\n+\t\t}\n+\t      \n \t      if (local_prg.checksum != program.checksum)\n \t\tcontinue;\n \t      if (tag == GCOV_TAG_PLACEHOLDER_SUMMARY)\n@@ -294,7 +288,7 @@ gcov_exit (void)\n \t      ptr->wkspc = base;\n \t      break;\n \t    }\n-\t  gcov_resync (0, 0);\n+\t  gcov_seek (0, 0);\n \t}\n \n       object.runs++;\n@@ -305,32 +299,19 @@ gcov_exit (void)\n       object.arc_sum_max += object_max_one;\n       \n       /* Write out the data.  */\n-      if (/* magic */\n-\t  gcov_write_unsigned (GCOV_DATA_MAGIC)\n-\t  /* version number */\n-\t  || gcov_write_unsigned (GCOV_VERSION))\n-\t{\n-\twrite_error:;\n-\t  gcov_close ();\n-\t  fprintf (stderr, \"profiling:%s:Error writing\\n\", ptr->filename);\n-\t  ptr->filename = 0;\n-\t  continue;\n-\t}\n+      gcov_write_unsigned (GCOV_DATA_MAGIC);\n+      gcov_write_unsigned (GCOV_VERSION);\n       \n       /* Write execution counts for each function.  */\n       for (ix = 0; ix < ptr->n_counter_sections; ix++)\n \tcounters[ix] = ptr->counter_sections[ix].counters;\n       for (ix = ptr->n_functions, fn_info = ptr->functions; ix--; fn_info++)\n \t{\n \t  /* Announce function.  */\n-\t  if (gcov_write_unsigned (GCOV_TAG_FUNCTION)\n-\t      || !(base = gcov_reserve_length ())\n-\t      /* function name */\n-\t      || gcov_write_string (fn_info->name)\n-\t      /* function checksum */\n-\t      || gcov_write_unsigned (fn_info->checksum)\n-\t      || gcov_write_length (base))\n-\t    goto write_error;\n+\t  base = gcov_write_tag (GCOV_TAG_FUNCTION);\n+\t  gcov_write_string (fn_info->name);\n+\t  gcov_write_unsigned (fn_info->checksum);\n+\t  gcov_write_length (base);\n \n \t  /* counters.  */\n \t  for (f_sect_index = 0;\n@@ -346,10 +327,7 @@ gcov_exit (void)\n \t      if (sect_index == ptr->n_counter_sections)\n \t\tabort ();\n \n-\t      if (gcov_write_unsigned (tag)\n-\t\t  || !(base = gcov_reserve_length ()))\n-\t\tgoto write_error;\n-\t  \n+\t      base = gcov_write_tag (tag);\n     \t      for (jx = fn_info->counter_sections[f_sect_index].n_counters; jx--;)\n \t\t{\n \t\t  gcov_type count = *counters[sect_index]++;\n@@ -360,41 +338,33 @@ gcov_exit (void)\n \t\t      if (object.arc_max_sum < count)\n \t\t\tobject.arc_max_sum = count;\n \t\t    }\n-\t\t  if (gcov_write_counter (count))\n-\t\t    goto write_error; /* RIP Edsger Dijkstra */\n+\t\t  gcov_write_counter (count);\n \t\t}\n-\t      if (gcov_write_length (base))\n-\t\tgoto write_error;\n+\t      gcov_write_length (base);\n \t    }\n \t}\n \n       /* Object file summary.  */\n-      if (gcov_write_summary (GCOV_TAG_OBJECT_SUMMARY, &object))\n-\tgoto write_error;\n+      gcov_write_summary (GCOV_TAG_OBJECT_SUMMARY, &object);\n \n       if (merging)\n \t{\n \t  ptr->wkspc = gcov_seek_end ();\n-\t  if (gcov_write_summary (GCOV_TAG_PLACEHOLDER_SUMMARY,\n-\t\t\t\t  &program))\n-\t    goto write_error;\n+\t  gcov_write_summary (GCOV_TAG_PLACEHOLDER_SUMMARY, &program);\n \t}\n       else if (ptr->wkspc)\n \t{\n \t  /* Zap trailing program summary */\n-\t  if (gcov_resync (ptr->wkspc, 0))\n-\t    goto write_error;\n+\t  gcov_seek (ptr->wkspc, 0);\n \t  if (!local_prg.runs)\n \t    ptr->wkspc = 0;\n-\t  if (gcov_write_unsigned (local_prg.runs\n-\t\t\t\t   ? GCOV_TAG_PLACEHOLDER_SUMMARY\n-\t\t\t\t   : GCOV_TAG_INCORRECT_SUMMARY))\n-\t    goto write_error;\n+\t  gcov_write_unsigned (local_prg.runs\n+\t\t\t       ? GCOV_TAG_PLACEHOLDER_SUMMARY\n+\t\t\t       : GCOV_TAG_INCORRECT_SUMMARY);\n \t}\n-\n       if (gcov_close ())\n \t{\n-\t  fprintf (stderr, \"profiling:%s:Error closing\\n\", ptr->filename);\n+\t  fprintf (stderr, \"profiling:%s:Error writing\\n\", ptr->filename);\n \t  ptr->filename = 0;\n \t}\n       else\n@@ -427,11 +397,10 @@ gcov_exit (void)\n \t    continue;\n \t  }\n \t\n-\tif (gcov_resync (ptr->wkspc, 0)\n- \t    || gcov_write_summary (GCOV_TAG_PROGRAM_SUMMARY, &program))\n- \t  fprintf (stderr, \"profiling:%s:Error writing\\n\", ptr->filename);\n+\tgcov_seek (ptr->wkspc, 0);\n+\tgcov_write_summary (GCOV_TAG_PROGRAM_SUMMARY, &program);\n \tif (gcov_close ())\n-\t  fprintf (stderr, \"profiling:%s:Error closing\\n\", ptr->filename);\n+\t  fprintf (stderr, \"profiling:%s:Error writing\\n\", ptr->filename);\n       }\n }\n "}, {"sha": "759314451dea6d85129da18b368bad0164125f2a", "filename": "gcc/profile.c", "status": "modified", "additions": 62, "deletions": 89, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94de45d9fe364fefd0cea5352c486306e68d704b/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94de45d9fe364fefd0cea5352c486306e68d704b/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=94de45d9fe364fefd0cea5352c486306e68d704b", "patch": "@@ -274,7 +274,7 @@ static void\n read_counts_file (const char *name)\n {\n   char *function_name_buffer = NULL;\n-  unsigned magic, version, ix, checksum;\n+  unsigned version, ix, checksum;\n   counts_entry_t *summaried = NULL;\n   unsigned seen_summary = 0;\n   \n@@ -284,21 +284,21 @@ read_counts_file (const char *name)\n       return;\n     }\n   \n-  if (gcov_read_unsigned (&magic) || magic != GCOV_DATA_MAGIC)\n+  if (gcov_read_unsigned () != GCOV_DATA_MAGIC)\n     {\n       warning (\"`%s' is not a gcov data file\", name);\n       gcov_close ();\n       return;\n     }\n-  else if (gcov_read_unsigned (&version) || version != GCOV_VERSION)\n+  else if ((version = gcov_read_unsigned ()) != GCOV_VERSION)\n     {\n       char v[4], e[4];\n-      magic = GCOV_VERSION;\n+      unsigned required = GCOV_VERSION;\n       \n-      for (ix = 4; ix--; magic >>= 8, version >>= 8)\n+      for (ix = 4; ix--; required >>= 8, version >>= 8)\n \t{\n \t  v[ix] = version;\n-\t  e[ix] = magic;\n+\t  e[ix] = required;\n \t}\n       warning (\"`%s' is version `%.4s', expected version `%.4s'\", name, v, e);\n       gcov_close ();\n@@ -308,27 +308,21 @@ read_counts_file (const char *name)\n   counts_hash = htab_create (10,\n \t\t\t     htab_counts_entry_hash, htab_counts_entry_eq,\n \t\t\t     htab_counts_entry_del);\n-  while (1)\n+  while (!gcov_is_eof ())\n     {\n       unsigned tag, length;\n-      long offset;\n+      unsigned long offset;\n+      int error;\n       \n-      offset = gcov_save_position ();\n-      if (gcov_read_unsigned (&tag) || gcov_read_unsigned (&length))\n-\t{\n-\t  if (gcov_eof ())\n-\t    break;\n-\tcorrupt:;\n-\t  warning (\"`%s' is corrupted\", name);\n-\tcleanup:\n-\t  htab_delete (counts_hash);\n-\t  break;\n-\t}\n+      tag = gcov_read_unsigned ();\n+      length = gcov_read_unsigned ();\n+      offset = gcov_position ();\n       if (tag == GCOV_TAG_FUNCTION)\n \t{\n-\t  if (gcov_read_string (&function_name_buffer)\n-\t      || gcov_read_unsigned (&checksum))\n-\t    goto corrupt;\n+\t  const char *string = gcov_read_string ();\n+\t  free (function_name_buffer);\n+\t  function_name_buffer = string ? xstrdup (string) : NULL;\n+\t  checksum = gcov_read_unsigned ();\n \t  if (seen_summary)\n \t    {\n \t      /* We have already seen a summary, this means that this\n@@ -352,10 +346,7 @@ read_counts_file (const char *name)\n \t  counts_entry_t *entry;\n \t  struct gcov_summary summary;\n \t  \n-\t  if (length != GCOV_SUMMARY_LENGTH\n-\t      || gcov_read_summary (&summary))\n-\t    goto corrupt;\n-\n+\t  gcov_read_summary (&summary);\n \t  seen_summary = 1;\n \t  for (entry = summaried; entry; entry = entry->chain)\n \t    {\n@@ -370,7 +361,6 @@ read_counts_file (const char *name)\n \t  counts_entry_t **slot, *entry, elt;\n \t  unsigned n_counts = length / 8;\n \t  unsigned ix;\n-\t  gcov_type count;\n \n \t  elt.function_name = function_name_buffer;\n \t  elt.section = tag;\n@@ -390,7 +380,8 @@ read_counts_file (const char *name)\n \t  else if (entry->checksum != checksum || entry->n_counts != n_counts)\n \t    {\n \t      warning (\"profile mismatch for `%s'\", function_name_buffer);\n-\t      goto cleanup;\n+\t      htab_delete (counts_hash);\n+\t      break;\n \t    }\n \t  \n \t  /* This should always be true for a just allocated entry,\n@@ -402,15 +393,16 @@ read_counts_file (const char *name)\n \t      summaried = entry;\n \t    }\n \t  for (ix = 0; ix != n_counts; ix++)\n-\t    {\n-\t      if (gcov_read_counter (&count))\n-\t\tgoto corrupt;\n-\t      entry->counts[ix] += count;\n-\t    }\n+\t    entry->counts[ix] += gcov_read_counter ();\n+\t}\n+      gcov_seek (offset, length);\n+      if ((error = gcov_is_error ()))\n+\t{\n+\t  warning (error < 0 ? \"`%s' has overflowed\" : \"`%s' is corrupted\",\n+\t\t   name);\n+\t  htab_delete (counts_hash);\n+\t  break;\n \t}\n-      else\n-\tif (gcov_skip (length))\n-\t  goto corrupt;\n     }\n \n   free (function_name_buffer);\n@@ -1007,42 +999,34 @@ branch_prob ()\n      edge output the source and target basic block numbers.\n      NOTE: The format of this file must be compatible with gcov.  */\n \n-  if (gcov_ok ())\n+  if (!gcov_is_error ())\n     {\n       long offset;\n       const char *file = DECL_SOURCE_FILE (current_function_decl);\n       unsigned line = DECL_SOURCE_LINE (current_function_decl);\n       \n       /* Announce function */\n-      if (gcov_write_unsigned (GCOV_TAG_FUNCTION)\n-\t  || !(offset = gcov_reserve_length ())\n-\t  || gcov_write_string (name)\n-\t  || gcov_write_unsigned (profile_info.current_function_cfg_checksum)\n-\t  || gcov_write_string (file)\n-\t  || gcov_write_unsigned (line)\n-\t  || gcov_write_length (offset))\n-\tgoto bbg_error;\n+      offset = gcov_write_tag (GCOV_TAG_FUNCTION);\n+      gcov_write_string (name);\n+      gcov_write_unsigned (profile_info.current_function_cfg_checksum);\n+      gcov_write_string (file);\n+      gcov_write_unsigned (line);\n+      gcov_write_length (offset);\n \n       /* Basic block flags */\n-      if (gcov_write_unsigned (GCOV_TAG_BLOCKS)\n-\t  || !(offset = gcov_reserve_length ()))\n-\tgoto bbg_error;\n+      offset = gcov_write_tag (GCOV_TAG_BLOCKS);\n       for (i = 0; i != (unsigned) (n_basic_blocks + 2); i++)\n-\tif (gcov_write_unsigned (0))\n-\t  goto bbg_error;\n-      if (gcov_write_length (offset))\n-\tgoto bbg_error;\n+\tgcov_write_unsigned (0);\n+      gcov_write_length (offset);\n       \n       /* Arcs */\n       FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n \t{\n \t  edge e;\n \n-\t  if (gcov_write_unsigned (GCOV_TAG_ARCS)\n-\t      || !(offset = gcov_reserve_length ())\n-\t      || gcov_write_unsigned (BB_TO_GCOV_INDEX (bb)))\n-\t    goto bbg_error;\n-\n+\t  offset = gcov_write_tag (GCOV_TAG_ARCS);\n+\t  gcov_write_unsigned (BB_TO_GCOV_INDEX (bb));\n+\t  \n \t  for (e = bb->succ; e; e = e->succ_next)\n \t    {\n \t      struct edge_info *i = EDGE_INFO (e);\n@@ -1057,14 +1041,12 @@ branch_prob ()\n \t\t  if (e->flags & EDGE_FALLTHRU)\n \t\t    flag_bits |= GCOV_ARC_FALLTHROUGH;\n \n-\t\t  if (gcov_write_unsigned (BB_TO_GCOV_INDEX (e->dest))\n-\t\t      || gcov_write_unsigned (flag_bits))\n-\t\t    goto bbg_error;\n+\t\t  gcov_write_unsigned (BB_TO_GCOV_INDEX (e->dest));\n+\t\t  gcov_write_unsigned (flag_bits);\n \t        }\n \t    }\n \n-\t  if (gcov_write_length (offset))\n-\t    goto bbg_error;\n+\t  gcov_write_length (offset);\n \t}\n \n       /* Output line number information about each basic block for\n@@ -1104,42 +1086,37 @@ branch_prob ()\n \t\t      ignore_next_note = 0;\n \t\t    else\n \t\t      {\n-\t\t\tif (offset)\n-\t\t\t  /*NOP*/;\n-\t\t\telse if (gcov_write_unsigned (GCOV_TAG_LINES)\n-\t\t\t\t || !(offset = gcov_reserve_length ())\n-\t\t\t\t || (gcov_write_unsigned\n-\t\t\t\t     (BB_TO_GCOV_INDEX (bb))))\n-\t\t\t  goto bbg_error;\n+\t\t\tif (!offset)\n+\t\t\t  {\n+\t\t\t    offset = gcov_write_tag (GCOV_TAG_LINES);\n+\t\t\t    gcov_write_unsigned (BB_TO_GCOV_INDEX (bb));\n+\t\t\t  }\n+\n \t\t\t/* If this is a new source file, then output\n \t\t\t   the file's name to the .bb file.  */\n \t\t\tif (!prev_file_name\n \t\t\t    || strcmp (NOTE_SOURCE_FILE (insn),\n \t\t\t\t       prev_file_name))\n \t\t\t  {\n \t\t\t    prev_file_name = NOTE_SOURCE_FILE (insn);\n-\t\t\t    if (gcov_write_unsigned (0)\n-\t\t\t\t|| gcov_write_string (prev_file_name))\n-\t\t\t      goto bbg_error;\n+\t\t\t    gcov_write_unsigned (0);\n+\t\t\t    gcov_write_string (prev_file_name);\n \t\t\t  }\n-\t\t\tif (gcov_write_unsigned (NOTE_LINE_NUMBER (insn)))\n-\t\t\t  goto bbg_error;\n+\t\t\tgcov_write_unsigned (NOTE_LINE_NUMBER (insn));\n \t\t      }\n \t\t  }\n \t\tinsn = NEXT_INSN (insn);\n \t      }\n \n \t    if (offset)\n \t      {\n-\t\tif (gcov_write_unsigned (0)\n-\t\t    || gcov_write_string (NULL)\n-\t\t    || gcov_write_length (offset))\n-\t\t  {\n-\t\t  bbg_error:;\n-\t\t    warning (\"error writing `%s'\", bbg_file_name);\n-\t\t    gcov_error ();\n-\t\t  }\n+\t\t/* A file of NULL indicates the end of run.  */\n+\t\tgcov_write_unsigned (0);\n+\t\tgcov_write_string (NULL);\n+\t\tgcov_write_length (offset);\n \t      }\n+\t    if (gcov_is_error ())\n+\t      warning (\"error writing `%s'\", bbg_file_name);\n \t  }\n       }\n     }\n@@ -1328,13 +1305,9 @@ init_branch_prob (filename)\n       strcpy (bbg_file_name, filename);\n       strcat (bbg_file_name, GCOV_GRAPH_SUFFIX);\n       if (!gcov_open (bbg_file_name, -1))\n-\t{\n-\t  error (\"cannot open %s\", bbg_file_name);\n-\t  gcov_error ();\n-\t}\n-      else if (gcov_write_unsigned (GCOV_GRAPH_MAGIC)\n-\t       || gcov_write_unsigned (GCOV_VERSION))\n-\tgcov_error ();\n+\terror (\"cannot open %s\", bbg_file_name);\n+      gcov_write_unsigned (GCOV_GRAPH_MAGIC);\n+      gcov_write_unsigned (GCOV_VERSION);\n     }\n \n   if (profile_arc_flag)"}]}