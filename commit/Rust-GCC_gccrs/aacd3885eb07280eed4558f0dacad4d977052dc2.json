{"sha": "aacd3885eb07280eed4558f0dacad4d977052dc2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWFjZDM4ODVlYjA3MjgwZWVkNDU1OGYwZGFjYWQ0ZDk3NzA1MmRjMg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard@codesourcery.com", "date": "2006-02-18T22:06:53Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2006-02-18T22:06:53Z"}, "message": "re PR target/9703 ([arm] Accessing data through constant pool more times could be solved in less instructions)\n\n\t* cselib.c (cselib_init): Change RTX_SIZE to RTX_CODE_SIZE.\n\t* emit-rtl.c (copy_rtx_if_shared_1): Use shallow_copy_rtx.\n\t(copy_insn_1): Likewise.  Don't copy each field individually.\n\tReindent.\n\t* read-rtl.c (apply_macro_to_rtx): Use RTX_CODE_SIZE instead\n\tof RTX_SIZE.\n\t* reload1.c (eliminate_regs): Use shallow_copy_rtx.\n\t* rtl.c (rtx_size): Rename variable to...\n\t(rtx_code_size): ...this.\n\t(rtx_size): New function.\n\t(rtx_alloc_stat): Use RTX_CODE_SIZE instead of RTX_SIZE.\n\t(copy_rtx): Use shallow_copy_rtx.  Don't copy each field individually.\n\tReindent.\n\t(shallow_copy_rtx_stat): Use rtx_size instead of RTX_SIZE.\n\t* rtl.h (rtx_code_size): New variable.\n\t(rtx_size): Change from a variable to a function.\n\t(RTX_SIZE): Rename to...\n\t(RTX_CODE_SIZE): ...this.\n\n\tPR target/9703\n\tPR tree-optimization/17106\n\t* doc/tm.texi (TARGET_USE_BLOCKS_FOR_CONSTANT_P): Document.\n\t(Anchored Addresses): New section.\n\t* doc/invoke.texi (-fsection-anchors): Document.\n\t* doc/rtl.texi (SYMBOL_REF_IN_BLOCK_P, SYMBOL_FLAG_IN_BLOCK): Likewise.\n\t(SYMBOL_REF_ANCHOR_P, SYMBOL_FLAG_ANCHOR): Likewise.\n\t(SYMBOL_REF_BLOCK, SYMBOL_REF_BLOCK_OFFSET): Likewise.\n\t* hooks.c (hook_bool_mode_rtx_false): New function.\n\t* hooks.h (hook_bool_mode_rtx_false): Declare.\n\t* gengtype.c (create_optional_field): New function.\n\t(adjust_field_rtx_def): Add the \"block_sym\" field for SYMBOL_REFs when\n\tSYMBOL_REF_IN_BLOCK_P is true.\n\t* target.h (output_anchor, use_blocks_for_constant_p): New hooks.\n\t(min_anchor_offset, max_anchor_offset): Likewise.\n\t(use_anchors_for_symbol_p): New hook.\n\t* toplev.c (compile_file): Call output_object_blocks.\n\t(target_supports_section_anchors_p): New function.\n\t(process_options): Check that -fsection-anchors is only used on\n\ttargets that support it and when -funit-at-a-time is in effect.\n\t* tree-ssa-loop-ivopts.c (prepare_decl_rtl): Only create DECL_RTL\n\tif the decl doesn't have one.\n\t* dwarf2out.c: Remove instantiations of VEC(rtx,gc).\n\t* expr.c (emit_move_multi_word, emit_move_insn): Pass the result\n\tof force_const_mem through use_anchored_address.\n\t(expand_expr_constant): New function.\n\t(expand_expr_addr_expr_1): Call it.  Use the same modifier when\n\tcalling expand_expr for INDIRECT_REF.\n\t(expand_expr_real_1): Pass DECL_RTL through use_anchored_address\n\tfor all modifiers except EXPAND_INITIALIZER.  Use expand_expr_constant.\n\t* expr.h (use_anchored_address): Declare.\n\t* loop-unroll.c: Don't declare rtx vectors here.\n\t* explow.c: Include output.h.\n\t(validize_mem): Call use_anchored_address.\n\t(use_anchored_address): New function.\n\t* common.opt (-fsection-anchors): New switch.\n\t* varasm.c (object_block_htab, anchor_labelno): New variables.\n\t(hash_section, object_block_entry_eq, object_block_entry_hash)\n\t(use_object_blocks_p, get_block_for_section, create_block_symbol)\n\t(use_blocks_for_decl_p, change_symbol_section): New functions.\n\t(get_variable_section): New function, split out from assemble_variable.\n\t(make_decl_rtl): Create a block symbol if use_object_blocks_p and\n\tuse_blocks_for_decl_p say so.  Use change_symbol_section if the\n\tsymbol has already been created.\n\t(assemble_variable_contents): New function, split out from...\n\t(assemble_variable): ...here.  Don't output any code for\n\tblock symbols; just pass them to place_block_symbol.\n\tUse get_variable_section and assemble_variable_contents.\n\t(get_constant_alignment, get_constant_section, get_constant_size): New\n\tfunctions, split from output_constant_def_contents.\n\t(build_constant_desc): Create a block symbol if use_object_blocks_p\n\tsays so.  Or into SYMBOL_REF_FLAGS.\n\t(assemble_constant_contents): New function, split from...\n\t(output_constant_def_contents): ...here.  Don't output any code\n\tfor block symbols; just pass them to place_section_symbol.\n\tUse get_constant_section and get_constant_alignment.\n\t(force_const_mem): Create a block symbol if use_object_blocks_p and\n\tuse_blocks_for_constant_p say so.  Or into SYMBOL_REF_FLAGS.\n\t(output_constant_pool_1): Add an explicit alignment argument.\n\tDon't switch sections here.\n\t(output_constant_pool): Adjust call to output_constant_pool_1.\n\tSwitch sections here instead.  Don't output anything for block symbols;\n\tjust pass them to place_block_symbol.\n\t(init_varasm_once): Initialize object_block_htab.\n\t(default_encode_section_info): Keep the old SYMBOL_FLAG_IN_BLOCK.\n\t(default_asm_output_anchor, default_use_aenchors_for_symbol_p)\n\t(place_block_symbol, get_section_anchor, output_object_block)\n\t(output_object_block_htab, output_object_blocks): New functions.\n\t* target-def.h (TARGET_ASM_OUTPUT_ANCHOR): New macro.\n\t(TARGET_ASM_OUT): Include it.\n\t(TARGET_USE_BLOCKS_FOR_CONSTANT_P): New macro.\n\t(TARGET_MIN_ANCHOR_OFFSET, TARGET_MAX_ANCHOR_OFFSET): New macros.\n\t(TARGET_USE_ANCHORS_FOR_SYMBOL_P): New macro.\n\t(TARGET_INITIALIZER): Include them.\n\t* rtl.c (rtl_check_failed_block_symbol): New function.\n\t* rtl.h: Include vec.h.  Declare heap and gc rtx vectors.\n\t(block_symbol, object_block): New structures.\n\t(rtx_def): Add a block_symbol field to the union.\n\t(BLOCK_SYMBOL_CHECK): New macro.\n\t(rtl_check_failed_block_symbol): Declare.\n\t(SYMBOL_FLAG_IN_BLOCK, SYMBOL_FLAG_ANCHOR): New SYMBOL_REF flags.\n\t(SYMBOL_REF_IN_BLOCK_P, SYMBOL_REF_ANCHOR_P): New predicates.\n\t(SYMBOL_FLAG_MACH_DEP_SHIFT): Bump by 2.\n\t(SYMBOL_REF_BLOCK, SYMBOL_REF_BLOCK_OFFSET): New accessors.\n\t* output.h (output_section_symbols): Declare.\n\t(object_block): Name structure.\n\t(place_section_symbol, get_section_anchor, default_asm_output_anchor)\n\t(default_use_anchors_for_symbol_p): Declare.\n\t* Makefile.in (RTL_BASE_H): Add vec.h.\n\t(explow.o): Depend on output.h.\n\t* config/rs6000/rs6000.c (TARGET_MIN_ANCHOR_OFFSET): Override default.\n\t(TARGET_MAX_ANCHOR_OFFSET): Likewise.\n\t(TARGET_USE_BLOCKS_FOR_CONSTANT_P): Likewise.\n\t(rs6000_use_blocks_for_constant_p): New function.\n\nFrom-SVN: r111254", "tree": {"sha": "b8f39049c93e479153dfa0a8aa3f5539993a4a56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b8f39049c93e479153dfa0a8aa3f5539993a4a56"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aacd3885eb07280eed4558f0dacad4d977052dc2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aacd3885eb07280eed4558f0dacad4d977052dc2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aacd3885eb07280eed4558f0dacad4d977052dc2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aacd3885eb07280eed4558f0dacad4d977052dc2/comments", "author": null, "committer": null, "parents": [{"sha": "dcf966bd82b34172175ca8ff4aa39f91729a9dbb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcf966bd82b34172175ca8ff4aa39f91729a9dbb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dcf966bd82b34172175ca8ff4aa39f91729a9dbb"}], "stats": {"total": 1528, "additions": 1300, "deletions": 228}, "files": [{"sha": "4305859024ea8602a19f62b99030076d0f9eb817", "filename": "gcc/ChangeLog", "status": "modified", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aacd3885eb07280eed4558f0dacad4d977052dc2", "patch": "@@ -1,3 +1,119 @@\n+2005-02-18  Richard Sandiford  <richard@codesourcery.com>\n+\n+\t* cselib.c (cselib_init): Change RTX_SIZE to RTX_CODE_SIZE.\n+\t* emit-rtl.c (copy_rtx_if_shared_1): Use shallow_copy_rtx.\n+\t(copy_insn_1): Likewise.  Don't copy each field individually.\n+\tReindent.\n+\t* read-rtl.c (apply_macro_to_rtx): Use RTX_CODE_SIZE instead\n+\tof RTX_SIZE.\n+\t* reload1.c (eliminate_regs): Use shallow_copy_rtx.\n+\t* rtl.c (rtx_size): Rename variable to...\n+\t(rtx_code_size): ...this.\n+\t(rtx_size): New function.\n+\t(rtx_alloc_stat): Use RTX_CODE_SIZE instead of RTX_SIZE.\n+\t(copy_rtx): Use shallow_copy_rtx.  Don't copy each field individually.\n+\tReindent.\n+\t(shallow_copy_rtx_stat): Use rtx_size instead of RTX_SIZE.\n+\t* rtl.h (rtx_code_size): New variable.\n+\t(rtx_size): Change from a variable to a function.\n+\t(RTX_SIZE): Rename to...\n+\t(RTX_CODE_SIZE): ...this.\n+\n+\tPR target/9703\n+\tPR tree-optimization/17106\n+\t* doc/tm.texi (TARGET_USE_BLOCKS_FOR_CONSTANT_P): Document.\n+\t(Anchored Addresses): New section.\n+\t* doc/invoke.texi (-fsection-anchors): Document.\n+\t* doc/rtl.texi (SYMBOL_REF_IN_BLOCK_P, SYMBOL_FLAG_IN_BLOCK): Likewise.\n+\t(SYMBOL_REF_ANCHOR_P, SYMBOL_FLAG_ANCHOR): Likewise.\n+\t(SYMBOL_REF_BLOCK, SYMBOL_REF_BLOCK_OFFSET): Likewise.\n+\t* hooks.c (hook_bool_mode_rtx_false): New function.\n+\t* hooks.h (hook_bool_mode_rtx_false): Declare.\n+\t* gengtype.c (create_optional_field): New function.\n+\t(adjust_field_rtx_def): Add the \"block_sym\" field for SYMBOL_REFs when\n+\tSYMBOL_REF_IN_BLOCK_P is true.\n+\t* target.h (output_anchor, use_blocks_for_constant_p): New hooks.\n+\t(min_anchor_offset, max_anchor_offset): Likewise.\n+\t(use_anchors_for_symbol_p): New hook.\n+\t* toplev.c (compile_file): Call output_object_blocks.\n+\t(target_supports_section_anchors_p): New function.\n+\t(process_options): Check that -fsection-anchors is only used on\n+\ttargets that support it and when -funit-at-a-time is in effect.\n+\t* tree-ssa-loop-ivopts.c (prepare_decl_rtl): Only create DECL_RTL\n+\tif the decl doesn't have one.\n+\t* dwarf2out.c: Remove instantiations of VEC(rtx,gc).\n+\t* expr.c (emit_move_multi_word, emit_move_insn): Pass the result\n+\tof force_const_mem through use_anchored_address.\n+\t(expand_expr_constant): New function.\n+\t(expand_expr_addr_expr_1): Call it.  Use the same modifier when\n+\tcalling expand_expr for INDIRECT_REF.\n+\t(expand_expr_real_1): Pass DECL_RTL through use_anchored_address\n+\tfor all modifiers except EXPAND_INITIALIZER.  Use expand_expr_constant.\n+\t* expr.h (use_anchored_address): Declare.\n+\t* loop-unroll.c: Don't declare rtx vectors here.\n+\t* explow.c: Include output.h.\n+\t(validize_mem): Call use_anchored_address.\n+\t(use_anchored_address): New function.\n+\t* common.opt (-fsection-anchors): New switch.\n+\t* varasm.c (object_block_htab, anchor_labelno): New variables.\n+\t(hash_section, object_block_entry_eq, object_block_entry_hash)\n+\t(use_object_blocks_p, get_block_for_section, create_block_symbol)\n+\t(use_blocks_for_decl_p, change_symbol_section): New functions.\n+\t(get_variable_section): New function, split out from assemble_variable.\n+\t(make_decl_rtl): Create a block symbol if use_object_blocks_p and\n+\tuse_blocks_for_decl_p say so.  Use change_symbol_section if the\n+\tsymbol has already been created.\n+\t(assemble_variable_contents): New function, split out from...\n+\t(assemble_variable): ...here.  Don't output any code for\n+\tblock symbols; just pass them to place_block_symbol.\n+\tUse get_variable_section and assemble_variable_contents.\n+\t(get_constant_alignment, get_constant_section, get_constant_size): New\n+\tfunctions, split from output_constant_def_contents.\n+\t(build_constant_desc): Create a block symbol if use_object_blocks_p\n+\tsays so.  Or into SYMBOL_REF_FLAGS.\n+\t(assemble_constant_contents): New function, split from...\n+\t(output_constant_def_contents): ...here.  Don't output any code\n+\tfor block symbols; just pass them to place_section_symbol.\n+\tUse get_constant_section and get_constant_alignment.\n+\t(force_const_mem): Create a block symbol if use_object_blocks_p and\n+\tuse_blocks_for_constant_p say so.  Or into SYMBOL_REF_FLAGS.\n+\t(output_constant_pool_1): Add an explicit alignment argument.\n+\tDon't switch sections here.\n+\t(output_constant_pool): Adjust call to output_constant_pool_1.\n+\tSwitch sections here instead.  Don't output anything for block symbols;\n+\tjust pass them to place_block_symbol.\n+\t(init_varasm_once): Initialize object_block_htab.\n+\t(default_encode_section_info): Keep the old SYMBOL_FLAG_IN_BLOCK.\n+\t(default_asm_output_anchor, default_use_aenchors_for_symbol_p)\n+\t(place_block_symbol, get_section_anchor, output_object_block)\n+\t(output_object_block_htab, output_object_blocks): New functions.\n+\t* target-def.h (TARGET_ASM_OUTPUT_ANCHOR): New macro.\n+\t(TARGET_ASM_OUT): Include it.\n+\t(TARGET_USE_BLOCKS_FOR_CONSTANT_P): New macro.\n+\t(TARGET_MIN_ANCHOR_OFFSET, TARGET_MAX_ANCHOR_OFFSET): New macros.\n+\t(TARGET_USE_ANCHORS_FOR_SYMBOL_P): New macro.\n+\t(TARGET_INITIALIZER): Include them.\n+\t* rtl.c (rtl_check_failed_block_symbol): New function.\n+\t* rtl.h: Include vec.h.  Declare heap and gc rtx vectors.\n+\t(block_symbol, object_block): New structures.\n+\t(rtx_def): Add a block_symbol field to the union.\n+\t(BLOCK_SYMBOL_CHECK): New macro.\n+\t(rtl_check_failed_block_symbol): Declare.\n+\t(SYMBOL_FLAG_IN_BLOCK, SYMBOL_FLAG_ANCHOR): New SYMBOL_REF flags.\n+\t(SYMBOL_REF_IN_BLOCK_P, SYMBOL_REF_ANCHOR_P): New predicates.\n+\t(SYMBOL_FLAG_MACH_DEP_SHIFT): Bump by 2.\n+\t(SYMBOL_REF_BLOCK, SYMBOL_REF_BLOCK_OFFSET): New accessors.\n+\t* output.h (output_section_symbols): Declare.\n+\t(object_block): Name structure.\n+\t(place_section_symbol, get_section_anchor, default_asm_output_anchor)\n+\t(default_use_anchors_for_symbol_p): Declare.\n+\t* Makefile.in (RTL_BASE_H): Add vec.h.\n+\t(explow.o): Depend on output.h.\n+\t* config/rs6000/rs6000.c (TARGET_MIN_ANCHOR_OFFSET): Override default.\n+\t(TARGET_MAX_ANCHOR_OFFSET): Likewise.\n+\t(TARGET_USE_BLOCKS_FOR_CONSTANT_P): Likewise.\n+\t(rs6000_use_blocks_for_constant_p): New function.\n+\n 2006-02-18  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \t* doc/install.texi (hppa*-hp-hpux*): Update for 4.1.0."}, {"sha": "82987c17cd6698e23888b0b39d439aba4b1cd98f", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=aacd3885eb07280eed4558f0dacad4d977052dc2", "patch": "@@ -735,7 +735,7 @@ HOSTHOOKS_DEF_H = hosthooks-def.h $(HOOKS_H)\n LANGHOOKS_DEF_H = langhooks-def.h $(HOOKS_H)\n TARGET_DEF_H = target-def.h $(HOOKS_H)\n RTL_BASE_H = rtl.h rtl.def $(MACHMODE_H) reg-notes.def insn-notes.def \\\n-  input.h real.h statistics.h\n+  input.h real.h statistics.h vec.h\n RTL_H = $(RTL_BASE_H) genrtl.h\n PARAMS_H = params.h params.def\n BUILTINS_DEF = builtins.def sync-builtins.def omp-builtins.def\n@@ -2198,7 +2198,8 @@ expmed.o : expmed.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_\n    toplev.h $(TM_P_H) langhooks.h\n explow.o : explow.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n    $(FLAGS_H) hard-reg-set.h insn-config.h $(EXPR_H) $(OPTABS_H) $(RECOG_H) \\\n-   toplev.h $(FUNCTION_H) $(GGC_H) $(TM_P_H) langhooks.h gt-explow.h target.h\n+   toplev.h $(FUNCTION_H) $(GGC_H) $(TM_P_H) langhooks.h gt-explow.h target.h \\\n+   output.h\n optabs.o : optabs.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(FLAGS_H) insn-config.h $(EXPR_H) $(OPTABS_H) libfuncs.h \\\n    $(RECOG_H) reload.h toplev.h $(GGC_H) real.h $(TM_P_H) except.h \\"}, {"sha": "c7e689942349f80a2030d42be16253133503ff30", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=aacd3885eb07280eed4558f0dacad4d977052dc2", "patch": "@@ -787,6 +787,10 @@ fsched-stalled-insns-dep=\n Common RejectNegative Joined UInteger\n -fsched-stalled-insns-dep=<number>\tSet dependence distance checking in premature scheduling of queued insns\n \n+fsection-anchors\n+Common Report Var(flag_section_anchors)\n+Access data in the same section from shared anchor points\n+\n frtl-abstract-sequences\n Common Report Var(flag_rtl_seqabstr)\n Perform sequence abstraction optimization on RTL"}, {"sha": "a7b8f4068378041ab69420b18804cce830c5c4e3", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=aacd3885eb07280eed4558f0dacad4d977052dc2", "patch": "@@ -623,6 +623,7 @@ static section *rs6000_elf_select_rtx_section (enum machine_mode, rtx,\n static void rs6000_elf_encode_section_info (tree, rtx, int)\n      ATTRIBUTE_UNUSED;\n #endif\n+static bool rs6000_use_blocks_for_constant_p (enum machine_mode, rtx);\n #if TARGET_XCOFF\n static void rs6000_xcoff_asm_globalize_label (FILE *, const char *);\n static void rs6000_xcoff_asm_init_sections (void);\n@@ -1021,6 +1022,20 @@ static const char alt_reg_names[][8] =\n #define TARGET_ASM_OUTPUT_DWARF_DTPREL rs6000_output_dwarf_dtprel\n #endif\n \n+/* Use a 32-bit anchor range.  This leads to sequences like:\n+\n+\taddis\ttmp,anchor,high\n+\tadd\tdest,tmp,low\n+\n+   where tmp itself acts as an anchor, and can be shared between\n+   accesses to the same 64k page.  */\n+#undef TARGET_MIN_ANCHOR_OFFSET\n+#define TARGET_MIN_ANCHOR_OFFSET -0x7fffffff - 1\n+#undef TARGET_MAX_ANCHOR_OFFSET\n+#define TARGET_MAX_ANCHOR_OFFSET 0x7fffffff\n+#undef TARGET_USE_BLOCKS_FOR_CONSTANT_P\n+#define TARGET_USE_BLOCKS_FOR_CONSTANT_P rs6000_use_blocks_for_constant_p\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n \n@@ -17648,7 +17663,14 @@ rs6000_elf_in_small_data_p (tree decl)\n }\n \n #endif /* USING_ELFOS_H */\n+\f\n+/* Implement TARGET_USE_BLOCKS_FOR_CONSTANT_P.  */\n \n+static bool\n+rs6000_use_blocks_for_constant_p (enum machine_mode mode, rtx x)\n+{\n+  return !ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (x, mode);\n+}\n \f\n /* Return a REG that occurs in ADDR with coefficient 1.\n    ADDR can be effectively incremented by incrementing REG."}, {"sha": "0fc8aeef2cfa7f38e0226f5beafb0acdbe925f85", "filename": "gcc/cselib.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=aacd3885eb07280eed4558f0dacad4d977052dc2", "patch": "@@ -1453,8 +1453,7 @@ cselib_init (bool record_memory)\n \t\t\t\t         sizeof (struct elt_loc_list), 10);\n   cselib_val_pool = create_alloc_pool (\"cselib_val_list\", \n \t\t\t\t       sizeof (cselib_val), 10);\n-  value_pool = create_alloc_pool (\"value\", \n-\t\t\t\t  RTX_SIZE (VALUE), 100);\n+  value_pool = create_alloc_pool (\"value\", RTX_CODE_SIZE (VALUE), 100);\n   cselib_record_memory = record_memory;\n   /* This is only created once.  */\n   if (! callmem)"}, {"sha": "4b8bf5939e6d700547acca13f3e9b498de9e26b2", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=aacd3885eb07280eed4558f0dacad4d977052dc2", "patch": "@@ -333,7 +333,7 @@ Objective-C and Objective-C++ Dialects}.\n -fsched-stalled-insns=@var{n} -fsched-stalled-insns-dep=@var{n} @gol\n -fsched2-use-superblocks @gol\n -fsched2-use-traces -freschedule-modulo-scheduled-loops @gol\n--fsignaling-nans -fsingle-precision-constant  @gol\n+-fsection-anchors  -fsignaling-nans  -fsingle-precision-constant @gol\n -fstack-protector  -fstack-protector-all @gol\n -fstrength-reduce  -fstrict-aliasing  -ftracer  -fthread-jumps @gol\n -funroll-all-loops  -funroll-loops  -fpeel-loops @gol\n@@ -5773,6 +5773,35 @@ If a guard check fails, an error message is printed and the program exits.\n @item -fstack-protector-all\n Like @option{-fstack-protector} except that all functions are protected.\n \n+@item -fsection-anchors\n+@opindex fsection-anchors\n+Try to reduce the number of symbolic address calculations by using\n+shared ``anchor'' symbols to address nearby objects.  This transformation\n+can help to reduce the number of GOT entries and GOT accesses on some\n+targets.\n+\n+For example, the implementation of the following function @code{foo}:\n+\n+@smallexample\n+static int a, b, c;\n+int foo (void) @{ return a + b + c; @}\n+@end smallexample\n+\n+would usually calculate the addresses of all three variables, but if you\n+compile it with @option{-fsection-anchors}, it will access the variables\n+from a common anchor point instead.  The effect is similar to the\n+following pseudocode (which isn't valid C):\n+\n+@smallexample\n+int foo (void)\n+@{\n+  register int *xr = &x;\n+  return xr[&a - &x] + xr[&b - &x] + xr[&c - &x];\n+@}\n+@end smallexample\n+\n+Not all targets support this option.\n+\n @item --param @var{name}=@var{value}\n @opindex param\n In some places, GCC uses various constants to control the amount of"}, {"sha": "de4a8e7394f4eb3cc7b569c8bb7adaf7b7b28b5b", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=aacd3885eb07280eed4558f0dacad4d977052dc2", "patch": "@@ -501,11 +501,40 @@ See @code{TARGET_IN_SMALL_DATA_P}.\n This is a multi-bit field accessor that returns the @code{tls_model}\n to be used for a thread-local storage symbol.  It returns zero for\n non-thread-local symbols.\n+\n+@findex SYMBOL_REF_IN_BLOCK_P\n+@findex SYMBOL_FLAG_IN_BLOCK\n+@item SYMBOL_FLAG_IN_BLOCK\n+Set if the symbol has been assigned to an @code{object_block} structure.\n+@code{SYMBOL_REF_BLOCK} and @code{SYMBOL_REF_BLOCK_OFFSET} provide more\n+information about such symbols.\n+\n+@findex SYMBOL_REF_ANCHOR_P\n+@findex SYMBOL_FLAG_ANCHOR\n+@cindex @option{-fsection-anchors}\n+@item SYMBOL_FLAG_ANCHOR\n+Set if the symbol is used as a section anchor.  ``Section anchors''\n+are symbols that have a known position within an @code{object_block}\n+and that can be used to access nearby members of that block.\n+They are used to implement @option{-fsection-anchors}.\n+\n+If this flag is set, then @code{SYMBOL_FLAG_IN_BLOCK} will be too.\n @end table\n \n Bits beginning with @code{SYMBOL_FLAG_MACH_DEP} are available for\n the target's use.\n @end table\n+\n+@findex SYMBOL_REF_BLOCK\n+@item SYMBOL_REF_BLOCK (@var{x})\n+If @samp{SYMBOL_REF_IN_BLOCK_P (@var{x})}, this is the @samp{object_block}\n+structure to which the symbol belongs.  The value is always nonnull.\n+\n+@findex SYMBOL_REF_BLOCK_OFFSET\n+@item SYMBOL_REF_BLOCK_OFFSET (@var{x})\n+If @samp{SYMBOL_REF_IN_BLOCK_P (@var{x})}, this is the offset of @var{x}\n+from the first object in @samp{SYMBOL_REF_BLOCK (@var{x})}.  The value is\n+negative if @var{x} has not yet been assigned an offset.\n @end table\n \n @node Flags"}, {"sha": "4c32cf62380920dcba69b724d015c58f8d7635c9", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=aacd3885eb07280eed4558f0dacad4d977052dc2", "patch": "@@ -38,6 +38,7 @@ through the macros defined in the @file{.h} file.\n * Trampolines::         Code set up at run time to enter a nested function.\n * Library Calls::       Controlling how library routines are implicitly called.\n * Addressing Modes::    Defining addressing modes valid for memory operands.\n+* Anchored Addresses::  Defining how @option{-fsection-anchors} should work.\n * Condition Code::      Defining how insns update the condition code.\n * Costs::               Defining relative costs of different operations.\n * Scheduling::          Adjusting the behavior of the instruction scheduler.\n@@ -5207,6 +5208,14 @@ holding the constant.  This restriction is often true of addresses\n of TLS symbols for various targets.\n @end deftypefn\n \n+@deftypefn {Target Hook} bool TARGET_USE_BLOCKS_FOR_CONSTANT_P (enum machine_mode @var{mode}, rtx @var{x})\n+This hook should return true if pool entries for constant @var{x} can\n+be placed in an @code{object_block} structure.  @var{mode} is the mode\n+of @var{x}.\n+\n+The default version returns false for all constants.\n+@end deftypefn\n+\n @deftypefn {Target Hook} tree TARGET_VECTORIZE_BUILTIN_MASK_FOR_LOAD (void)\n This hook should return the DECL of a function @var{f} that given an\n address @var{addr} as an argument returns a mask @var{m} that can be\n@@ -5236,6 +5245,76 @@ the argument @var{OFF} to @code{REALIGN_LOAD}, in which case the low\n log2(@var{VS})-1 bits of @var{addr} will be considered.\n @end deftypefn\n \n+@node Anchored Addresses\n+@section Anchored Addresses\n+@cindex anchored addresses\n+@cindex @option{-fsection-anchors}\n+\n+GCC usually addresses every static object as a separate entity.\n+For example, if we have:\n+\n+@smallexample\n+static int a, b, c;\n+int foo (void) @{ return a + b + c; @}\n+@end smallexample\n+\n+the code for @code{foo} will usually calculate three separate symbolic\n+addresses: those of @code{a}, @code{b} and @code{c}.  On some targets,\n+it would be better to calculate just one symbolic address and access\n+the three variables relative to it.  The equivalent pseudocode would\n+be something like:\n+\n+@smallexample\n+int foo (void)\n+@{\n+  register int *xr = &x;\n+  return xr[&a - &x] + xr[&b - &x] + xr[&c - &x];\n+@}\n+@end smallexample\n+\n+(which isn't valid C).  We refer to shared addresses like @code{x} as\n+``section anchors''.  Their use is controlled by @option{-fsection-anchors}.\n+\n+The hooks below describe the target properties that GCC needs to know\n+in order to make effective use of section anchors.  It won't use\n+section anchors at all unless either @code{TARGET_MIN_ANCHOR_OFFSET}\n+or @code{TARGET_MAX_ANCHOR_OFFSET} is set to a nonzero value.\n+\n+@deftypevar {Target Hook} HOST_WIDE_INT TARGET_MIN_ANCHOR_OFFSET\n+The minimum offset that should be applied to a section anchor.\n+On most targets, it should be the smallest offset that can be\n+applied to a base register while still giving a legitimate address\n+for every mode.  The default value is 0.\n+@end deftypevar\n+\n+@deftypevar {Target Hook} HOST_WIDE_INT TARGET_MAX_ANCHOR_OFFSET\n+Like @code{TARGET_MIN_ANCHOR_OFFSET}, but the maximum (inclusive)\n+offset that should be applied to section anchors.  The default\n+value is 0.\n+@end deftypevar\n+\n+@deftypefn {Target Hook} void TARGET_ASM_OUTPUT_ANCHOR (rtx @var{x})\n+Write the assembly code to define section anchor @var{x}, which is a\n+@code{SYMBOL_REF} for which @samp{SYMBOL_REF_ANCHOR_P (@var{x})} is true.\n+The hook is called with the assembly output position set to the beginning\n+of @code{SYMBOL_REF_BLOCK (@var{x})}.\n+\n+If @code{ASM_OUTPUT_DEF} is available, the hook's default definition uses\n+it to define the symbol as @samp{. + SYMBOL_REF_BLOCK_OFFSET (@var{x})}.\n+If @code{ASM_OUTPUT_DEF} is not available, the hook's default definition\n+is @code{NULL}, which disables the use of section anchors altogether.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} bool TARGET_USE_ANCHORS_FOR_SYMBOL_P (rtx @var{x})\n+Return true if GCC should attempt to use anchors to access @code{SYMBOL_REF}\n+@var{x}.  You can assume @samp{SYMBOL_REF_IN_BLOCK_P (@var{x})} and\n+@samp{!SYMBOL_REF_ANCHOR_P (@var{x})}.\n+\n+The default version is correct for most targets, but you might need to\n+intercept this hook to handle things like target-specific attributes\n+or target-specific sections.\n+@end deftypefn\n+\n @node Condition Code\n @section Condition Code Status\n @cindex condition code status"}, {"sha": "ed318b587067abb697ffbd411244e45a77c61563", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=aacd3885eb07280eed4558f0dacad4d977052dc2", "patch": "@@ -124,9 +124,6 @@ dwarf2out_do_frame (void)\n #define PTR_SIZE (POINTER_SIZE / BITS_PER_UNIT)\n #endif\n \n-DEF_VEC_P(rtx);\n-DEF_VEC_ALLOC_P(rtx,gc);\n-\n /* Array of RTXes referenced by the debugging information, which therefore\n    must be kept around forever.  */\n static GTY(()) VEC(rtx,gc) *used_rtx_array;"}, {"sha": "f1613ad9fb77054860afc47b484dce4878953e3e", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 35, "deletions": 44, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=aacd3885eb07280eed4558f0dacad4d977052dc2", "patch": "@@ -2467,11 +2467,7 @@ copy_rtx_if_shared_1 (rtx *orig1)\n \n   if (RTX_FLAG (x, used))\n     {\n-      rtx copy;\n-\n-      copy = rtx_alloc (code);\n-      memcpy (copy, x, RTX_SIZE (code));\n-      x = copy;\n+      x = shallow_copy_rtx (x);\n       copied = 1;\n     }\n   RTX_FLAG (x, used) = 1;\n@@ -4978,13 +4974,11 @@ copy_insn_1 (rtx orig)\n       break;\n     }\n \n-  copy = rtx_alloc (code);\n-\n-  /* Copy the various flags, and other information.  We assume that\n-     all fields need copying, and then clear the fields that should\n+  /* Copy the various flags, fields, and other information.  We assume\n+     that all fields need copying, and then clear the fields that should\n      not be copied.  That is the sensible default behavior, and forces\n      us to explicitly document why we are *not* copying a flag.  */\n-  memcpy (copy, orig, RTX_HDR_SIZE);\n+  copy = shallow_copy_rtx (orig);\n \n   /* We do not copy the USED flag, which is used as a mark bit during\n      walks over the RTL.  */\n@@ -5001,43 +4995,40 @@ copy_insn_1 (rtx orig)\n   format_ptr = GET_RTX_FORMAT (GET_CODE (copy));\n \n   for (i = 0; i < GET_RTX_LENGTH (GET_CODE (copy)); i++)\n-    {\n-      copy->u.fld[i] = orig->u.fld[i];\n-      switch (*format_ptr++)\n-\t{\n-\tcase 'e':\n-\t  if (XEXP (orig, i) != NULL)\n-\t    XEXP (copy, i) = copy_insn_1 (XEXP (orig, i));\n-\t  break;\n+    switch (*format_ptr++)\n+      {\n+      case 'e':\n+\tif (XEXP (orig, i) != NULL)\n+\t  XEXP (copy, i) = copy_insn_1 (XEXP (orig, i));\n+\tbreak;\n \n-\tcase 'E':\n-\tcase 'V':\n-\t  if (XVEC (orig, i) == orig_asm_constraints_vector)\n-\t    XVEC (copy, i) = copy_asm_constraints_vector;\n-\t  else if (XVEC (orig, i) == orig_asm_operands_vector)\n-\t    XVEC (copy, i) = copy_asm_operands_vector;\n-\t  else if (XVEC (orig, i) != NULL)\n-\t    {\n-\t      XVEC (copy, i) = rtvec_alloc (XVECLEN (orig, i));\n-\t      for (j = 0; j < XVECLEN (copy, i); j++)\n-\t\tXVECEXP (copy, i, j) = copy_insn_1 (XVECEXP (orig, i, j));\n-\t    }\n-\t  break;\n+      case 'E':\n+      case 'V':\n+\tif (XVEC (orig, i) == orig_asm_constraints_vector)\n+\t  XVEC (copy, i) = copy_asm_constraints_vector;\n+\telse if (XVEC (orig, i) == orig_asm_operands_vector)\n+\t  XVEC (copy, i) = copy_asm_operands_vector;\n+\telse if (XVEC (orig, i) != NULL)\n+\t  {\n+\t    XVEC (copy, i) = rtvec_alloc (XVECLEN (orig, i));\n+\t    for (j = 0; j < XVECLEN (copy, i); j++)\n+\t      XVECEXP (copy, i, j) = copy_insn_1 (XVECEXP (orig, i, j));\n+\t  }\n+\tbreak;\n \n-\tcase 't':\n-\tcase 'w':\n-\tcase 'i':\n-\tcase 's':\n-\tcase 'S':\n-\tcase 'u':\n-\tcase '0':\n-\t  /* These are left unchanged.  */\n-\t  break;\n+      case 't':\n+      case 'w':\n+      case 'i':\n+      case 's':\n+      case 'S':\n+      case 'u':\n+      case '0':\n+\t/* These are left unchanged.  */\n+\tbreak;\n \n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-    }\n+      default:\n+\tgcc_unreachable ();\n+      }\n \n   if (code == SCRATCH)\n     {"}, {"sha": "b56373ca42a3d095d4f3656dfbbbf44b3496b8e5", "filename": "gcc/explow.c", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=aacd3885eb07280eed4558f0dacad4d977052dc2", "patch": "@@ -39,6 +39,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"recog.h\"\n #include \"langhooks.h\"\n #include \"target.h\"\n+#include \"output.h\"\n \n static rtx break_out_memory_refs (rtx);\n static void emit_stack_probe (rtx);\n@@ -527,13 +528,68 @@ validize_mem (rtx ref)\n {\n   if (!MEM_P (ref))\n     return ref;\n+  ref = use_anchored_address (ref);\n   if (! (flag_force_addr && CONSTANT_ADDRESS_P (XEXP (ref, 0)))\n       && memory_address_p (GET_MODE (ref), XEXP (ref, 0)))\n     return ref;\n \n   /* Don't alter REF itself, since that is probably a stack slot.  */\n   return replace_equiv_address (ref, XEXP (ref, 0));\n }\n+\n+/* If X is a memory reference to a member of an object block, try rewriting\n+   it to use an anchor instead.  Return the new memory reference on success\n+   and the old one on failure.  */\n+\n+rtx\n+use_anchored_address (rtx x)\n+{\n+  rtx base;\n+  HOST_WIDE_INT offset;\n+\n+  if (!flag_section_anchors)\n+    return x;\n+\n+  if (!MEM_P (x))\n+    return x;\n+\n+  /* Split the address into a base and offset.  */\n+  base = XEXP (x, 0);\n+  offset = 0;\n+  if (GET_CODE (base) == CONST\n+      && GET_CODE (XEXP (base, 0)) == PLUS\n+      && GET_CODE (XEXP (XEXP (base, 0), 1)) == CONST_INT)\n+    {\n+      offset += INTVAL (XEXP (XEXP (base, 0), 1));\n+      base = XEXP (XEXP (base, 0), 0);\n+    }\n+\n+  /* Check whether BASE is suitable for anchors.  */\n+  if (GET_CODE (base) != SYMBOL_REF\n+      || !SYMBOL_REF_IN_BLOCK_P (base)\n+      || SYMBOL_REF_ANCHOR_P (base)\n+      || !targetm.use_anchors_for_symbol_p (base))\n+    return x;\n+\n+  /* Decide where BASE is going to be.  */\n+  place_block_symbol (base);\n+\n+  /* Get the anchor we need to use.  */\n+  offset += SYMBOL_REF_BLOCK_OFFSET (base);\n+  base = get_section_anchor (SYMBOL_REF_BLOCK (base), offset,\n+\t\t\t     SYMBOL_REF_TLS_MODEL (base));\n+\n+  /* Work out the offset from the anchor.  */\n+  offset -= SYMBOL_REF_BLOCK_OFFSET (base);\n+\n+  /* If we're going to run a CSE pass, force the anchor into a register.\n+     We will then be able to reuse registers for several accesses, if the\n+     target costs say that that's worthwhile.  */\n+  if (!cse_not_expected)\n+    base = force_reg (GET_MODE (base), base);\n+\n+  return replace_equiv_address (x, plus_constant (base, offset));\n+}\n \f\n /* Copy the value or contents of X to a new temp reg and return that reg.  */\n "}, {"sha": "0107f2a9dc112612fda516a92c614ebc6db051ad", "filename": "gcc/expr.c", "status": "modified", "additions": 40, "deletions": 26, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=aacd3885eb07280eed4558f0dacad4d977052dc2", "patch": "@@ -3081,7 +3081,7 @@ emit_move_multi_word (enum machine_mode mode, rtx x, rtx y)\n \t be able to get a part of Y.  */\n       if (ypart == 0 && CONSTANT_P (y))\n \t{\n-\t  y = force_const_mem (mode, y);\n+\t  y = use_anchored_address (force_const_mem (mode, y));\n \t  ypart = operand_subword (y, i, 1, mode);\n \t}\n       else if (ypart == 0)\n@@ -3194,6 +3194,8 @@ emit_move_insn (rtx x, rtx y)\n \t     of the non-legitimate constant.  */\n \t  if (!y)\n \t    y = y_cst;\n+\t  else\n+\t    y = use_anchored_address (y);\n \t}\n     }\n \n@@ -6280,6 +6282,20 @@ expand_operands (tree exp0, tree exp1, rtx target, rtx *op0, rtx *op1,\n }\n \n \f\n+/* Return a MEM that constains constant EXP.  DEFER is as for\n+   output_constant_def and MODIFIER is as for expand_expr.  */\n+\n+static rtx\n+expand_expr_constant (tree exp, int defer, enum expand_modifier modifier)\n+{\n+  rtx mem;\n+\n+  mem = output_constant_def (exp, defer);\n+  if (modifier != EXPAND_INITIALIZER)\n+    mem = use_anchored_address (mem);\n+  return mem;\n+}\n+\n /* A subroutine of expand_expr_addr_expr.  Evaluate the address of EXP.\n    The TARGET, TMODE and MODIFIER arguments are as for expand_expr.  */\n \n@@ -6301,14 +6317,14 @@ expand_expr_addr_expr_1 (tree exp, rtx target, enum machine_mode tmode,\n      exception here is STRING_CST.  */\n   if (TREE_CODE (exp) == CONSTRUCTOR\n       || CONSTANT_CLASS_P (exp))\n-    return XEXP (output_constant_def (exp, 0), 0);\n+    return XEXP (expand_expr_constant (exp, 0, modifier), 0);\n \n   /* Everything must be something allowed by is_gimple_addressable.  */\n   switch (TREE_CODE (exp))\n     {\n     case INDIRECT_REF:\n       /* This case will happen via recursion for &a->b.  */\n-      return expand_expr (TREE_OPERAND (exp, 0), target, tmode, EXPAND_NORMAL);\n+      return expand_expr (TREE_OPERAND (exp, 0), target, tmode, modifier);\n \n     case CONST_DECL:\n       /* Recurse and make the output_constant_def clause above handle this.  */\n@@ -6579,7 +6595,7 @@ static rtx\n expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t    enum expand_modifier modifier, rtx *alt_rtl)\n {\n-  rtx op0, op1, temp;\n+  rtx op0, op1, temp, decl_rtl;\n   tree type = TREE_TYPE (exp);\n   int unsignedp;\n   enum machine_mode mode;\n@@ -6701,7 +6717,8 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \n     case FUNCTION_DECL:\n     case RESULT_DECL:\n-      gcc_assert (DECL_RTL (exp));\n+      decl_rtl = DECL_RTL (exp);\n+      gcc_assert (decl_rtl);\n \n       /* Ensure variable marked as used even if it doesn't go through\n \t a parser.  If it hasn't be used yet, write out an external\n@@ -6728,27 +6745,24 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t from its initializer, while the initializer is still being parsed.\n \t See expand_decl.  */\n \n-      if (MEM_P (DECL_RTL (exp))\n-\t       && REG_P (XEXP (DECL_RTL (exp), 0)))\n-\ttemp = validize_mem (DECL_RTL (exp));\n+      if (MEM_P (decl_rtl) && REG_P (XEXP (decl_rtl, 0)))\n+\ttemp = validize_mem (decl_rtl);\n \n       /* If DECL_RTL is memory, we are in the normal case and either\n \t the address is not valid or it is not a register and -fforce-addr\n \t is specified, get the address into a register.  */\n \n-      else if (MEM_P (DECL_RTL (exp))\n-\t       && modifier != EXPAND_CONST_ADDRESS\n-\t       && modifier != EXPAND_SUM\n-\t       && modifier != EXPAND_INITIALIZER\n-\t       && (! memory_address_p (DECL_MODE (exp),\n-\t\t\t\t       XEXP (DECL_RTL (exp), 0))\n-\t\t   || (flag_force_addr\n-\t\t       && !REG_P (XEXP (DECL_RTL (exp), 0)))))\n+      else if (MEM_P (decl_rtl) && modifier != EXPAND_INITIALIZER)\n \t{\n \t  if (alt_rtl)\n-\t    *alt_rtl = DECL_RTL (exp);\n-\t  temp = replace_equiv_address (DECL_RTL (exp),\n-\t\t\t\t\tcopy_rtx (XEXP (DECL_RTL (exp), 0)));\n+\t    *alt_rtl = decl_rtl;\n+\t  decl_rtl = use_anchored_address (decl_rtl);\n+\t  if (modifier != EXPAND_CONST_ADDRESS\n+\t      && modifier != EXPAND_SUM\n+\t      && (!memory_address_p (DECL_MODE (exp), XEXP (decl_rtl, 0))\n+\t\t  || (flag_force_addr && !REG_P (XEXP (decl_rtl, 0)))))\n+\t    temp = replace_equiv_address (decl_rtl,\n+\t\t\t\t\t  copy_rtx (XEXP (decl_rtl, 0)));\n \t}\n \n       /* If we got something, return it.  But first, set the alignment\n@@ -6765,8 +6779,8 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t must be a promoted value.  We return a SUBREG of the wanted mode,\n \t but mark it so that we know that it was already extended.  */\n \n-      if (REG_P (DECL_RTL (exp))\n-\t  && GET_MODE (DECL_RTL (exp)) != DECL_MODE (exp))\n+      if (REG_P (decl_rtl)\n+\t  && GET_MODE (decl_rtl) != DECL_MODE (exp))\n \t{\n \t  enum machine_mode pmode;\n \t  \n@@ -6775,15 +6789,15 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t  pmode = promote_mode (type, DECL_MODE (exp), &unsignedp,\n \t\t\t\t(TREE_CODE (exp) == RESULT_DECL\n \t\t\t\t || TREE_CODE (exp) == PARM_DECL) ? 1 : 0);\n-\t  gcc_assert (GET_MODE (DECL_RTL (exp)) == pmode);\n+\t  gcc_assert (GET_MODE (decl_rtl) == pmode);\n \n-\t  temp = gen_lowpart_SUBREG (mode, DECL_RTL (exp));\n+\t  temp = gen_lowpart_SUBREG (mode, decl_rtl);\n \t  SUBREG_PROMOTED_VAR_P (temp) = 1;\n \t  SUBREG_PROMOTED_UNSIGNED_SET (temp, unsignedp);\n \t  return temp;\n \t}\n \n-      return DECL_RTL (exp);\n+      return decl_rtl;\n \n     case INTEGER_CST:\n       temp = immed_double_const (TREE_INT_CST_LOW (exp),\n@@ -6852,7 +6866,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       /* ... fall through ...  */\n \n     case STRING_CST:\n-      temp = output_constant_def (exp, 1);\n+      temp = expand_expr_constant (exp, 1, modifier);\n \n       /* temp contains a constant address.\n \t On RISC machines where a constant address isn't valid,\n@@ -6953,7 +6967,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t    || modifier == EXPAND_CONST_ADDRESS)\n \t\t   && TREE_CONSTANT (exp)))\n \t{\n-\t  rtx constructor = output_constant_def (exp, 1);\n+\t  rtx constructor = expand_expr_constant (exp, 1, modifier);\n \n \t  if (modifier != EXPAND_CONST_ADDRESS\n \t      && modifier != EXPAND_INITIALIZER"}, {"sha": "3188e9474614c682823f486a0716170da3a07beb", "filename": "gcc/expr.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=aacd3885eb07280eed4558f0dacad4d977052dc2", "patch": "@@ -647,6 +647,8 @@ extern rtx widen_memory_access (rtx, enum machine_mode, HOST_WIDE_INT);\n    valid address.  */\n extern rtx validize_mem (rtx);\n \n+extern rtx use_anchored_address (rtx);\n+\n /* Given REF, a MEM, and T, either the type of X or the expression\n    corresponding to REF, set the memory attributes.  OBJECTP is nonzero\n    if we are making a new object of this type.  */"}, {"sha": "0ec45c54c74c184d5faea0ce8604ce5f8cee0eb7", "filename": "gcc/gengtype.c", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=aacd3885eb07280eed4558f0dacad4d977052dc2", "patch": "@@ -354,6 +354,33 @@ create_field (pair_p next, type_p type, const char *name)\n   return field;\n }\n \n+/* Like create_field, but the field is only valid when condition COND\n+   is true.  */\n+\n+static pair_p\n+create_optional_field (pair_p next, type_p type, const char *name,\n+\t\t       const char *cond)\n+{\n+  static int id = 1;\n+  pair_p union_fields, field;\n+  type_p union_type;\n+\n+  /* Create a fake union type with a single nameless field of type TYPE.\n+     The field has a tag of \"1\".  This allows us to make the presence\n+     of a field of type TYPE depend on some boolean \"desc\" being true.  */\n+  union_fields = create_field (NULL, type, \"\");\n+  union_fields->opt = create_option (union_fields->opt, \"dot\", \"\");\n+  union_fields->opt = create_option (union_fields->opt, \"tag\", \"1\");\n+  union_type = new_structure (xasprintf (\"%s_%d\", \"fake_union\", id++), 1,\n+\t\t\t      &lexer_line, union_fields, NULL);\n+\n+  /* Create the field and give it the new fake union type.  Add a \"desc\"\n+     tag that specifies the condition under which the field is valid.  */\n+  field = create_field (next, union_type, name);\n+  field->opt = create_option (field->opt, \"desc\", cond);\n+  return field;\n+}\n+\n /* We don't care how long a CONST_DOUBLE is.  */\n #define CONST_DOUBLE_FORMAT \"ww\"\n /* We don't want to see codes that are only for generator files.  */\n@@ -646,6 +673,14 @@ adjust_field_rtx_def (type_p t, options_p ARG_UNUSED (opt))\n \t\t\t\t\t    \"CONSTANT_POOL_ADDRESS_P (&%0)\");\n \t}\n \n+      if (i == SYMBOL_REF)\n+\t{\n+\t  /* Add the \"block_sym\" field if SYMBOL_REF_IN_BLOCK_P holds.  */\n+\t  type_p field_tp = find_structure (\"block_symbol\", 0);\n+\t  subfields = create_optional_field (subfields, field_tp, \"block_sym\",\n+\t\t\t\t\t     \"SYMBOL_REF_IN_BLOCK_P (&%0)\");\n+\t}\n+\n       sname = xasprintf (\"rtx_def_%s\", rtx_name[i]);\n       substruct = new_structure (sname, 0, &lexer_line, subfields, NULL);\n "}, {"sha": "8a708777113e7e601251b88692c939ff02f11f07", "filename": "gcc/hooks.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2Fhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2Fhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.c?ref=aacd3885eb07280eed4558f0dacad4d977052dc2", "patch": "@@ -69,6 +69,14 @@ hook_bool_mode_false (enum machine_mode mode ATTRIBUTE_UNUSED)\n   return false;\n }\n \n+/* Generic hook that takes (enum machine_mode, rtx) and returns false.  */\n+bool\n+hook_bool_mode_rtx_false (enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t  rtx value ATTRIBUTE_UNUSED)\n+{\n+  return false;\n+}\n+\n /* Generic hook that takes (FILE *, const char *) and does nothing.  */\n void\n hook_void_FILEptr_constcharptr (FILE *a ATTRIBUTE_UNUSED, const char *b ATTRIBUTE_UNUSED)"}, {"sha": "a1053e9875fe4e315da53b3c449c9f73e5b1472e", "filename": "gcc/hooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2Fhooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2Fhooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.h?ref=aacd3885eb07280eed4558f0dacad4d977052dc2", "patch": "@@ -28,6 +28,7 @@ extern bool hook_bool_void_false (void);\n extern bool hook_bool_void_true (void);\n extern bool hook_bool_bool_false (bool);\n extern bool hook_bool_mode_false (enum machine_mode);\n+extern bool hook_bool_mode_rtx_false (enum machine_mode, rtx);\n extern bool hook_bool_tree_false (tree);\n extern bool hook_bool_tree_true (tree);\n extern bool hook_bool_tree_hwi_hwi_tree_false (tree, HOST_WIDE_INT, HOST_WIDE_INT,"}, {"sha": "6ef594766578a9224420fb7f52220b383d9aa29e", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=aacd3885eb07280eed4558f0dacad4d977052dc2", "patch": "@@ -84,9 +84,6 @@ struct iv_to_split\n \t\t\t   XEXP (XEXP (single_set, loc[0]), loc[1]).  */ \n };\n \n-DEF_VEC_P(rtx);\n-DEF_VEC_ALLOC_P(rtx,heap);\n-\n /* Information about accumulators to expand.  */\n \n struct var_to_expand"}, {"sha": "5fda5eaa3fce5d5c119067aec9af34b01612800c", "filename": "gcc/output.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=aacd3885eb07280eed4558f0dacad4d977052dc2", "patch": "@@ -275,6 +275,8 @@ extern rtx peephole (rtx);\n /* Write all the constants in the constant pool.  */\n extern void output_constant_pool (const char *, tree);\n \n+extern void output_object_blocks (void);\n+\n /* Return nonzero if VALUE is a valid constant-valued expression\n    for use in initializing a static variable; one that can be an\n    element of a \"constant\" initializer.\n@@ -483,6 +485,8 @@ union section GTY ((desc (\"(%h).common.flags & SECTION_NAMED\")))\n   struct unnamed_section GTY ((tag (\"0\"))) unnamed;\n };\n \n+struct object_block;\n+\n /* Special well-known sections.  */\n extern GTY(()) section *text_section;\n extern GTY(()) section *data_section;\n@@ -502,6 +506,9 @@ extern section *get_unnamed_section (unsigned int, void (*) (const void *),\n \t\t\t\t     const void *);\n extern section *get_section (const char *, unsigned int, tree);\n extern section *get_named_section (tree, const char *, int);\n+extern void place_block_symbol (rtx);\n+extern rtx get_section_anchor (struct object_block *, HOST_WIDE_INT,\n+\t\t\t       enum tls_model);\n extern section *mergeable_constant_section (enum machine_mode,\n \t\t\t\t\t    unsigned HOST_WIDE_INT,\n \t\t\t\t\t    unsigned int);\n@@ -546,6 +553,8 @@ extern section *default_elf_select_rtx_section (enum machine_mode, rtx,\n \t\t\t\t\t\tunsigned HOST_WIDE_INT);\n extern void default_encode_section_info (tree, rtx, int);\n extern const char *default_strip_name_encoding (const char *);\n+extern void default_asm_output_anchor (rtx);\n+extern bool default_use_anchors_for_symbol_p (rtx);\n extern bool default_binds_local_p (tree);\n extern bool default_binds_local_p_1 (tree, int);\n extern void default_globalize_label (FILE *, const char *);"}, {"sha": "4fdda4bca33e041c18f8d950af35babff96c67cb", "filename": "gcc/read-rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2Fread-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2Fread-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-rtl.c?ref=aacd3885eb07280eed4558f0dacad4d977052dc2", "patch": "@@ -437,7 +437,7 @@ apply_macro_to_rtx (rtx original, struct mapping *macro, int value,\n   /* Create a shallow copy of ORIGINAL.  */\n   bellwether_code = BELLWETHER_CODE (GET_CODE (original));\n   x = rtx_alloc (bellwether_code);\n-  memcpy (x, original, RTX_SIZE (bellwether_code));\n+  memcpy (x, original, RTX_CODE_SIZE (bellwether_code));\n \n   /* Change the mode or code itself.  */\n   group = macro->group;"}, {"sha": "d7f59d89b29dba665002c1bfb5d31488c7b8e2de", "filename": "gcc/reload1.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=aacd3885eb07280eed4558f0dacad4d977052dc2", "patch": "@@ -2607,9 +2607,7 @@ eliminate_regs_1 (rtx x, enum machine_mode mem_mode, rtx insn,\n \t  new = eliminate_regs_1 (XEXP (x, i), mem_mode, insn, false);\n \t  if (new != XEXP (x, i) && ! copied)\n \t    {\n-\t      rtx new_x = rtx_alloc (code);\n-\t      memcpy (new_x, x, RTX_SIZE (code));\n-\t      x = new_x;\n+\t      x = shallow_copy_rtx (x);\n \t      copied = 1;\n \t    }\n \t  XEXP (x, i) = new;\n@@ -2626,9 +2624,7 @@ eliminate_regs_1 (rtx x, enum machine_mode mem_mode, rtx insn,\n \t\t\t\t\t     XVEC (x, i)->elem);\n \t\t  if (! copied)\n \t\t    {\n-\t\t      rtx new_x = rtx_alloc (code);\n-\t\t      memcpy (new_x, x, RTX_SIZE (code));\n-\t\t      x = new_x;\n+\t\t      x = shallow_copy_rtx (x);\n \t\t      copied = 1;\n \t\t    }\n \t\t  XVEC (x, i) = new_v;"}, {"sha": "fca8ffa6cfcf9dbd35c09ecdf972c71d33c52051", "filename": "gcc/rtl.c", "status": "modified", "additions": 63, "deletions": 46, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=aacd3885eb07280eed4558f0dacad4d977052dc2", "patch": "@@ -109,7 +109,7 @@ const enum rtx_class rtx_class[NUM_RTX_CODE] = {\n \n /* Indexed by rtx code, gives the size of the rtx in bytes.  */\n \n-const unsigned char rtx_size[NUM_RTX_CODE] = {\n+const unsigned char rtx_code_size[NUM_RTX_CODE] = {\n #define DEF_RTL_EXPR(ENUM, NAME, FORMAT, CLASS)\t\t\t\t\\\n   ((ENUM) == CONST_INT || (ENUM) == CONST_DOUBLE\t\t\t\\\n    ? RTX_HDR_SIZE + (sizeof FORMAT - 1) * sizeof (HOST_WIDE_INT)\t\\\n@@ -170,6 +170,16 @@ rtvec_alloc (int n)\n   return rt;\n }\n \n+/* Return the number of bytes occupied by rtx value X.  */\n+\n+unsigned int\n+rtx_size (rtx x)\n+{\n+  if (GET_CODE (x) == SYMBOL_REF && SYMBOL_REF_IN_BLOCK_P (x))\n+    return RTX_HDR_SIZE + sizeof (struct block_symbol);\n+  return RTX_CODE_SIZE (GET_CODE (x));\n+}\n+\n /* Allocate an rtx of code CODE.  The CODE is stored in the rtx;\n    all the rest is initialized to zero.  */\n \n@@ -178,7 +188,7 @@ rtx_alloc_stat (RTX_CODE code MEM_STAT_DECL)\n {\n   rtx rt;\n \n-  rt = (rtx) ggc_alloc_zone_pass_stat (RTX_SIZE (code), &rtl_zone);\n+  rt = (rtx) ggc_alloc_zone_pass_stat (RTX_CODE_SIZE (code), &rtl_zone);\n \n   /* We want to clear everything up to the FLD array.  Normally, this\n      is one int, but we don't want to assume that and it isn't very\n@@ -189,7 +199,7 @@ rtx_alloc_stat (RTX_CODE code MEM_STAT_DECL)\n \n #ifdef GATHER_STATISTICS\n   rtx_alloc_counts[code]++;\n-  rtx_alloc_sizes[code] += RTX_SIZE (code);\n+  rtx_alloc_sizes[code] += RTX_CODE_SIZE (code);\n #endif\n \n   return rt;\n@@ -246,13 +256,11 @@ copy_rtx (rtx orig)\n       break;\n     }\n \n-  copy = rtx_alloc (code);\n-\n-  /* Copy the various flags, and other information.  We assume that\n-     all fields need copying, and then clear the fields that should\n+  /* Copy the various flags, fields, and other information.  We assume\n+     that all fields need copying, and then clear the fields that should\n      not be copied.  That is the sensible default behavior, and forces\n      us to explicitly document why we are *not* copying a flag.  */\n-  memcpy (copy, orig, RTX_HDR_SIZE);\n+  copy = shallow_copy_rtx (orig);\n \n   /* We do not copy the USED flag, which is used as a mark bit during\n      walks over the RTL.  */\n@@ -267,41 +275,38 @@ copy_rtx (rtx orig)\n   format_ptr = GET_RTX_FORMAT (GET_CODE (copy));\n \n   for (i = 0; i < GET_RTX_LENGTH (GET_CODE (copy)); i++)\n-    {\n-      copy->u.fld[i] = orig->u.fld[i];\n-      switch (*format_ptr++)\n-\t{\n-\tcase 'e':\n-\t  if (XEXP (orig, i) != NULL)\n-\t    XEXP (copy, i) = copy_rtx (XEXP (orig, i));\n-\t  break;\n-\n-\tcase 'E':\n-\tcase 'V':\n-\t  if (XVEC (orig, i) != NULL)\n-\t    {\n-\t      XVEC (copy, i) = rtvec_alloc (XVECLEN (orig, i));\n-\t      for (j = 0; j < XVECLEN (copy, i); j++)\n-\t\tXVECEXP (copy, i, j) = copy_rtx (XVECEXP (orig, i, j));\n-\t    }\n-\t  break;\n-\n-\tcase 't':\n-\tcase 'w':\n-\tcase 'i':\n-\tcase 's':\n-\tcase 'S':\n-\tcase 'T':\n-\tcase 'u':\n-\tcase 'B':\n-\tcase '0':\n-\t  /* These are left unchanged.  */\n-\t  break;\n-\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-    }\n+    switch (*format_ptr++)\n+      {\n+      case 'e':\n+\tif (XEXP (orig, i) != NULL)\n+\t  XEXP (copy, i) = copy_rtx (XEXP (orig, i));\n+\tbreak;\n+\n+      case 'E':\n+      case 'V':\n+\tif (XVEC (orig, i) != NULL)\n+\t  {\n+\t    XVEC (copy, i) = rtvec_alloc (XVECLEN (orig, i));\n+\t    for (j = 0; j < XVECLEN (copy, i); j++)\n+\t      XVECEXP (copy, i, j) = copy_rtx (XVECEXP (orig, i, j));\n+\t  }\n+\tbreak;\n+\n+      case 't':\n+      case 'w':\n+      case 'i':\n+      case 's':\n+      case 'S':\n+      case 'T':\n+      case 'u':\n+      case 'B':\n+      case '0':\n+\t/* These are left unchanged.  */\n+\tbreak;\n+\n+      default:\n+\tgcc_unreachable ();\n+      }\n   return copy;\n }\n \n@@ -310,11 +315,12 @@ copy_rtx (rtx orig)\n rtx\n shallow_copy_rtx_stat (rtx orig MEM_STAT_DECL)\n {\n+  unsigned int size;\n   rtx copy;\n \n-  copy = (rtx) ggc_alloc_zone_pass_stat (RTX_SIZE (GET_CODE (orig)),\n-\t\t\t\t\t &rtl_zone);\n-  memcpy (copy, orig, RTX_SIZE (GET_CODE (orig)));\n+  size = rtx_size (orig);\n+  copy = (rtx) ggc_alloc_zone_pass_stat (size, &rtl_zone);\n+  memcpy (copy, orig, size);\n   return copy;\n }\n \f\n@@ -530,6 +536,17 @@ rtl_check_failed_code_mode (rtx r, enum rtx_code code, enum machine_mode mode,\n \t\t  func, trim_filename (file), line);\n }\n \n+/* Report that line LINE of FILE tried to access the block symbol fields\n+   of a non-block symbol.  FUNC is the function that contains the line.  */\n+\n+void\n+rtl_check_failed_block_symbol (const char *file, int line, const char *func)\n+{\n+  internal_error\n+    (\"RTL check: attempt to treat non-block symbol as a block symbol \"\n+     \"in %s, at %s:%d\", func, trim_filename (file), line);\n+}\n+\n /* XXX Maybe print the vector?  */\n void\n rtvec_check_failed_bounds (rtvec r, int n, const char *file, int line,"}, {"sha": "45fe6a0b35b34271833bc294ebbc1da92557e851", "filename": "gcc/rtl.h", "status": "modified", "additions": 88, "deletions": 3, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=aacd3885eb07280eed4558f0dacad4d977052dc2", "patch": "@@ -26,6 +26,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"machmode.h\"\n #include \"input.h\"\n #include \"real.h\"\n+#include \"vec.h\"\n \n #undef FFS  /* Some systems predefine this symbol; don't let it interfere.  */\n #undef FLOAT /* Likewise.  */\n@@ -104,7 +105,7 @@ extern const char * const rtx_format[NUM_RTX_CODE];\n extern const enum rtx_class rtx_class[NUM_RTX_CODE];\n #define GET_RTX_CLASS(CODE)\t\t(rtx_class[(int) (CODE)])\n \n-extern const unsigned char rtx_size[NUM_RTX_CODE];\n+extern const unsigned char rtx_code_size[NUM_RTX_CODE];\n extern const unsigned char rtx_next[NUM_RTX_CODE];\n \f\n /* The flags and bitfields of an ADDR_DIFF_VEC.  BASE is the base label\n@@ -175,6 +176,59 @@ union rtunion_def\n };\n typedef union rtunion_def rtunion;\n \n+/* This structure remembers the position of a SYMBOL_REF within an\n+   object_block structure.  A SYMBOL_REF only provides this information\n+   if SYMBOL_REF_IN_BLOCK_P is true.  */\n+struct block_symbol GTY(()) {\n+  /* The usual SYMBOL_REF fields.  */\n+  rtunion GTY ((skip)) fld[3];\n+\n+  /* The block that contains this object.  */\n+  struct object_block *block;\n+\n+  /* The offset of this object from the start of its block.  It is negative\n+     if the symbol has not yet been assigned an offset.  */\n+  HOST_WIDE_INT offset;\n+};\n+\n+DEF_VEC_P(rtx);\n+DEF_VEC_ALLOC_P(rtx,heap);\n+DEF_VEC_ALLOC_P(rtx,gc);\n+\n+/* Describes a group of objects that are to be placed together in such\n+   a way that their relative positions are known.  */\n+struct object_block GTY(())\n+{\n+  /* The section in which these objects should be placed.  */\n+  section *sect;\n+\n+  /* The alignment of the first object, measured in bits.  */\n+  unsigned int alignment;\n+\n+  /* The total size of the objects, measured in bytes.  */\n+  HOST_WIDE_INT size;\n+\n+  /* The SYMBOL_REFs for each object.  The vector is sorted in\n+     order of increasing offset and the following conditions will\n+     hold for each element X:\n+\n+\t SYMBOL_REF_IN_BLOCK_P (X)\n+\t !SYMBOL_REF_ANCHOR_P (X)\n+\t SYMBOL_REF_BLOCK (X) == [address of this structure]\n+\t SYMBOL_REF_BLOCK_OFFSET (X) >= 0.  */\n+  VEC(rtx,gc) *objects;\n+\n+  /* All the anchor SYMBOL_REFs used to address these objects, sorted\n+     in order of increasing offset, and then increasing TLS model.\n+     The following conditions will hold for each element X in this vector:\n+\n+\t SYMBOL_REF_IN_BLOCK_P (X)\n+\t SYMBOL_REF_ANCHOR_P (X)\n+\t SYMBOL_REF_BLOCK (X) == [address of this structure]\n+\t SYMBOL_REF_BLOCK_OFFSET (X) >= 0.  */\n+  VEC(rtx,gc) *anchors;\n+};\n+\n /* RTL expression (\"rtx\").  */\n \n struct rtx_def GTY((chain_next (\"RTX_NEXT (&%h)\"),\n@@ -251,6 +305,7 @@ struct rtx_def GTY((chain_next (\"RTX_NEXT (&%h)\"),\n   union u {\n     rtunion fld[1];\n     HOST_WIDE_INT hwint[1];\n+    struct block_symbol block_sym;\n     struct real_value rv;\n   } GTY ((special (\"rtx_def\"), desc (\"GET_CODE (&%0)\"))) u;\n };\n@@ -259,7 +314,7 @@ struct rtx_def GTY((chain_next (\"RTX_NEXT (&%h)\"),\n #define RTX_HDR_SIZE offsetof (struct rtx_def, u)\n \n /* The size in bytes of an rtx with code CODE.  */\n-#define RTX_SIZE(CODE) rtx_size[CODE]\n+#define RTX_CODE_SIZE(CODE) rtx_code_size[CODE]\n \n #define NULL_RTX (rtx) 0\n \n@@ -471,6 +526,14 @@ struct rtvec_def GTY(()) {\n \t\t\t\t __LINE__, __FUNCTION__);\t\t\\\n    &_rtx->u.rv; })\n \n+#define BLOCK_SYMBOL_CHECK(RTX) __extension__\t\t\t\t\\\n+({ rtx const _symbol = (RTX);\t\t\t\t\t\t\\\n+   unsigned int flags = RTL_CHECKC1 (_symbol, 1, SYMBOL_REF).rt_int;\t\\\n+   if ((flags & SYMBOL_FLAG_IN_BLOCK) == 0)\t\t\t\t\\\n+     rtl_check_failed_block_symbol (__FILE__, __LINE__,\t\t\t\\\n+\t\t\t\t    __FUNCTION__);\t\t\t\\\n+   &_symbol->u.block_sym; })\n+\n extern void rtl_check_failed_bounds (rtx, int, const char *, int,\n \t\t\t\t     const char *)\n     ATTRIBUTE_NORETURN;\n@@ -489,6 +552,8 @@ extern void rtl_check_failed_code2 (rtx, enum rtx_code, enum rtx_code,\n extern void rtl_check_failed_code_mode (rtx, enum rtx_code, enum machine_mode,\n \t\t\t\t\tbool, const char *, int, const char *)\n     ATTRIBUTE_NORETURN;\n+extern void rtl_check_failed_block_symbol (const char *, int, const char *)\n+    ATTRIBUTE_NORETURN;\n extern void rtvec_check_failed_bounds (rtvec, int, const char *, int,\n \t\t\t\t       const char *)\n     ATTRIBUTE_NORETURN;\n@@ -505,6 +570,7 @@ extern void rtvec_check_failed_bounds (rtvec, int, const char *, int,\n #define XCMWINT(RTX, N, C, M)\t    ((RTX)->u.hwint[N])\n #define XCNMWINT(RTX, N, C, M)\t    ((RTX)->u.hwint[N])\n #define XCNMPRV(RTX, C, M)\t    (&(RTX)->u.rv)\n+#define BLOCK_SYMBOL_CHECK(RTX)\t    (&(RTX)->u.block_sym)\n \n #endif\n \n@@ -1249,11 +1315,29 @@ do {\t\t\t\t\t\t\\\n #define SYMBOL_FLAG_EXTERNAL\t(1 << 6)\n #define SYMBOL_REF_EXTERNAL_P(RTX) \\\n   ((SYMBOL_REF_FLAGS (RTX) & SYMBOL_FLAG_EXTERNAL) != 0)\n+/* Set if this symbol has a block_symbol structure associated with it.  */\n+#define SYMBOL_FLAG_IN_BLOCK\t(1 << 7)\n+#define SYMBOL_REF_IN_BLOCK_P(RTX) \\\n+  ((SYMBOL_REF_FLAGS (RTX) & SYMBOL_FLAG_IN_BLOCK) != 0)\n+/* Set if this symbol is a section anchor.  SYMBOL_REF_ANCHOR_P implies\n+   SYMBOL_REF_IN_BLOCK_P.  */\n+#define SYMBOL_FLAG_ANCHOR\t(1 << 8)\n+#define SYMBOL_REF_ANCHOR_P(RTX) \\\n+  ((SYMBOL_REF_FLAGS (RTX) & SYMBOL_FLAG_ANCHOR) != 0)\n \n /* Subsequent bits are available for the target to use.  */\n-#define SYMBOL_FLAG_MACH_DEP_SHIFT\t7\n+#define SYMBOL_FLAG_MACH_DEP_SHIFT\t9\n #define SYMBOL_FLAG_MACH_DEP\t\t(1 << SYMBOL_FLAG_MACH_DEP_SHIFT)\n \n+/* The block to which the given SYMBOL_REF belongs.  Only valid if\n+   SYMBOL_REF_IN_BLOCK_P (RTX).  */\n+#define SYMBOL_REF_BLOCK(RTX) (BLOCK_SYMBOL_CHECK (RTX)->block)\n+\n+/* The byte offset of the given SYMBOL_REF from the start of its block,\n+   or a negative value if the symbol has not yet been assigned a position.\n+   Only valid if SYMBOL_REF_IN_BLOCK_P (RTX).  */\n+#define SYMBOL_REF_BLOCK_OFFSET(RTX) (BLOCK_SYMBOL_CHECK (RTX)->offset)\n+\n /* Define a macro to look for REG_INC notes,\n    but save time on machines where they never exist.  */\n \n@@ -1384,6 +1468,7 @@ extern void dump_rtx_statistics (void);\n extern rtx copy_rtx_if_shared (rtx);\n \n /* In rtl.c */\n+extern unsigned int rtx_size (rtx);\n extern rtx shallow_copy_rtx_stat (rtx MEM_STAT_DECL);\n #define shallow_copy_rtx(a) shallow_copy_rtx_stat (a MEM_STAT_INFO)\n extern int rtx_equal_p (rtx, rtx);"}, {"sha": "c29256712f9ce904dcb5718c2375fbcacb7014bb", "filename": "gcc/target-def.h", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=aacd3885eb07280eed4558f0dacad4d977052dc2", "patch": "@@ -205,6 +205,14 @@ Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n #define TARGET_ASM_MARK_DECL_PRESERVED hook_void_constcharptr\n #endif\n \n+#ifndef TARGET_ASM_OUTPUT_ANCHOR\n+#ifdef ASM_OUTPUT_DEF\n+#define TARGET_ASM_OUTPUT_ANCHOR default_asm_output_anchor\n+#else\n+#define TARGET_ASM_OUTPUT_ANCHOR NULL\n+#endif\n+#endif\n+\n #ifndef TARGET_ASM_OUTPUT_DWARF_DTPREL\n #define TARGET_ASM_OUTPUT_DWARF_DTPREL NULL\n #endif\n@@ -252,6 +260,7 @@ Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n                         TARGET_ASM_FILE_END,\t\t\t\\\n \t\t\tTARGET_ASM_EXTERNAL_LIBCALL,            \\\n                         TARGET_ASM_MARK_DECL_PRESERVED,\t\t\\\n+\t\t\tTARGET_ASM_OUTPUT_ANCHOR,\t\t\\\n \t\t\tTARGET_ASM_OUTPUT_DWARF_DTPREL}\n \n /* Scheduler hooks.  All of these default to null pointers, which\n@@ -373,6 +382,10 @@ Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n #define TARGET_CANNOT_COPY_INSN_P NULL\n #define TARGET_COMMUTATIVE_P hook_bool_rtx_commutative_p\n #define TARGET_DELEGITIMIZE_ADDRESS hook_rtx_rtx_identity\n+#define TARGET_USE_BLOCKS_FOR_CONSTANT_P hook_bool_mode_rtx_false\n+#define TARGET_MIN_ANCHOR_OFFSET 0\n+#define TARGET_MAX_ANCHOR_OFFSET 0\n+#define TARGET_USE_ANCHORS_FOR_SYMBOL_P default_use_anchors_for_symbol_p\n #define TARGET_FUNCTION_OK_FOR_SIBCALL hook_bool_tree_tree_false\n #define TARGET_COMP_TYPE_ATTRIBUTES hook_int_tree_tree_1\n #define TARGET_SET_DEFAULT_TYPE_ATTRIBUTES hook_void_tree\n@@ -592,6 +605,10 @@ Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n   TARGET_CANNOT_COPY_INSN_P,\t\t\t\\\n   TARGET_COMMUTATIVE_P,\t\t\t\t\\\n   TARGET_DELEGITIMIZE_ADDRESS,\t\t\t\\\n+  TARGET_USE_BLOCKS_FOR_CONSTANT_P,\t\t\\\n+  TARGET_MIN_ANCHOR_OFFSET,\t\t\t\\\n+  TARGET_MAX_ANCHOR_OFFSET,\t\t\t\\\n+  TARGET_USE_ANCHORS_FOR_SYMBOL_P,\t\t\\\n   TARGET_FUNCTION_OK_FOR_SIBCALL,\t\t\\\n   TARGET_IN_SMALL_DATA_P,\t\t\t\\\n   TARGET_BINDS_LOCAL_P,\t\t\t\t\\"}, {"sha": "63f5d4efb792e72954e1921e9ee07632f374ce8d", "filename": "gcc/target.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=aacd3885eb07280eed4558f0dacad4d977052dc2", "patch": "@@ -198,6 +198,9 @@ struct gcc_target\n \tlinker to not dead code strip this symbol.  */\n     void (*mark_decl_preserved) (const char *);\n \n+    /* Output the definition of a section anchor.  */\n+    void (*output_anchor) (rtx);\n+\n     /* Output a DTP-relative reference to a TLS symbol.  */\n     void (*output_dwarf_dtprel) (FILE *file, int size, rtx x);\n \n@@ -421,6 +424,16 @@ struct gcc_target\n   /* Given an address RTX, undo the effects of LEGITIMIZE_ADDRESS.  */\n   rtx (* delegitimize_address) (rtx);\n \n+  /* True if the given constant can be put into an object_block.  */\n+  bool (* use_blocks_for_constant_p) (enum machine_mode, rtx);\n+\n+  /* The minimum and maximum byte offsets for anchored addresses.  */\n+  HOST_WIDE_INT min_anchor_offset;\n+  HOST_WIDE_INT max_anchor_offset;\n+\n+  /* True if section anchors can be used to access the given symbol.  */\n+  bool (* use_anchors_for_symbol_p) (rtx);\n+\n   /* True if it is OK to do sibling call optimization for the specified\n      call expression EXP.  DECL will be the called function, or NULL if\n      this is an indirect call.  */"}, {"sha": "bd8260b8c6dada34702138c63f1bb34ba29126d4", "filename": "gcc/toplev.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=aacd3885eb07280eed4558f0dacad4d977052dc2", "patch": "@@ -1022,6 +1022,8 @@ compile_file (void)\n   if (flag_mudflap)\n     mudflap_finish_file ();\n \n+  output_object_blocks ();\n+\n   /* Write out any pending weak symbol declarations.  */\n \n   weak_finish ();\n@@ -1498,6 +1500,20 @@ general_init (const char *argv0)\n   init_optimization_passes ();\n }\n \n+/* Return true if the current target supports -fsection-anchors.  */\n+\n+static bool\n+target_supports_section_anchors_p (void)\n+{\n+  if (targetm.min_anchor_offset == 0 && targetm.max_anchor_offset == 0)\n+    return false;\n+\n+  if (targetm.asm_out.output_anchor == NULL)\n+    return false;\n+\n+  return true;\n+}\n+\n /* Process the options that have been parsed.  */\n static void\n process_options (void)\n@@ -1520,6 +1536,13 @@ process_options (void)\n   OVERRIDE_OPTIONS;\n #endif\n \n+  if (flag_section_anchors && !target_supports_section_anchors_p ())\n+    {\n+      warning (OPT_fsection_anchors,\n+\t       \"this target does not support %qs\", \"-fsection-anchors\");\n+      flag_section_anchors = 0;\n+    }\n+\n   if (flag_short_enums == 2)\n     flag_short_enums = targetm.default_short_enums ();\n \n@@ -1578,6 +1601,9 @@ process_options (void)\n   if (flag_unit_at_a_time && ! lang_hooks.callgraph.expand_function)\n     flag_unit_at_a_time = 0;\n \n+  if (!flag_unit_at_a_time)\n+    flag_section_anchors = 0;\n+\n   if (flag_value_profile_transformations)\n     flag_profile_values = 1;\n "}, {"sha": "ab13dbb6817024487dd98ea26fd03cd24cc48d23", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=aacd3885eb07280eed4558f0dacad4d977052dc2", "patch": "@@ -2416,7 +2416,7 @@ prepare_decl_rtl (tree *expr_p, int *ws, void *data)\n \t   expr_p = &TREE_OPERAND (*expr_p, 0))\n \tcontinue;\n       obj = *expr_p;\n-      if (DECL_P (obj))\n+      if (DECL_P (obj) && !DECL_RTL_SET_P (obj))\n         x = produce_memory_decl_rtl (obj, regno);\n       break;\n "}, {"sha": "9801b1f8eba1b22b7cfa93e2036dbd15d2326c23", "filename": "gcc/varasm.c", "status": "modified", "additions": 619, "deletions": 90, "changes": 709, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacd3885eb07280eed4558f0dacad4d977052dc2/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=aacd3885eb07280eed4558f0dacad4d977052dc2", "patch": "@@ -184,6 +184,12 @@ static GTY(()) section *unnamed_sections;\n /* Hash table of named sections.  */\n static GTY((param_is (section))) htab_t section_htab;\n \n+/* A table of object_blocks, indexed by section.  */\n+static GTY((param_is (struct object_block))) htab_t object_block_htab;\n+\n+/* The next number to use for internal anchor labels.  */\n+static GTY(()) int anchor_labelno;\n+\n /* Helper routines for maintaining section_htab.  */\n \n static int\n@@ -202,6 +208,34 @@ section_entry_hash (const void *p)\n   return htab_hash_string (old->named.name);\n }\n \n+/* Return a hash value for section SECT.  */\n+\n+static hashval_t\n+hash_section (section *sect)\n+{\n+  if (sect->common.flags & SECTION_NAMED)\n+    return htab_hash_string (sect->named.name);\n+  return sect->common.flags;\n+}\n+\n+/* Helper routines for maintaining object_block_htab.  */\n+\n+static int\n+object_block_entry_eq (const void *p1, const void *p2)\n+{\n+  const struct object_block *old = p1;\n+  const section *new = p2;\n+\n+  return old->sect == new;\n+}\n+\n+static hashval_t\n+object_block_entry_hash (const void *p)\n+{\n+  const struct object_block *old = p;\n+  return hash_section (old->sect);\n+}\n+\n /* Return a new unnamed section with the given fields.  */\n \n section *\n@@ -256,6 +290,66 @@ get_section (const char *name, unsigned int flags, tree decl)\n   return sect;\n }\n \n+/* Return true if the current compilation mode benefits from having\n+   objects grouped into blocks.  */\n+\n+static bool\n+use_object_blocks_p (void)\n+{\n+  return flag_section_anchors;\n+}\n+\n+/* Return the object_block structure for section SECT.  Create a new\n+   structure if we haven't created one already.  */\n+\n+static struct object_block *\n+get_block_for_section (section *sect)\n+{\n+  struct object_block *block;\n+  void **slot;\n+\n+  slot = htab_find_slot_with_hash (object_block_htab, sect,\n+\t\t\t\t   hash_section (sect), INSERT);\n+  block = (struct object_block *) *slot;\n+  if (block == NULL)\n+    {\n+      block = (struct object_block *)\n+\tggc_alloc_cleared (sizeof (struct object_block));\n+      block->sect = sect;\n+      *slot = block;\n+    }\n+  return block;\n+}\n+\n+/* Create a symbol with label LABEL and place it at byte offset\n+   OFFSET in BLOCK.  OFFSET can be negative if the symbol's offset\n+   is not yet known.  LABEL must be a garbage-collected string.  */\n+\n+static rtx\n+create_block_symbol (const char *label, struct object_block *block,\n+\t\t     HOST_WIDE_INT offset)\n+{\n+  rtx symbol;\n+  unsigned int size;\n+\n+  /* Create the extended SYMBOL_REF.  */\n+  size = RTX_HDR_SIZE + sizeof (struct block_symbol);\n+  symbol = ggc_alloc_zone (size, &rtl_zone);\n+\n+  /* Initialize the normal SYMBOL_REF fields.  */\n+  memset (symbol, 0, size);\n+  PUT_CODE (symbol, SYMBOL_REF);\n+  PUT_MODE (symbol, Pmode);\n+  XSTR (symbol, 0) = label;\n+  SYMBOL_REF_FLAGS (symbol) = SYMBOL_FLAG_IN_BLOCK;\n+\n+  /* Initialize the block_symbol stuff.  */\n+  SYMBOL_REF_BLOCK (symbol) = block;\n+  SYMBOL_REF_BLOCK_OFFSET (symbol) = offset;\n+\n+  return symbol;\n+}\n+\n static void\n initialize_cold_section_name (void)\n {\n@@ -705,6 +799,83 @@ decode_reg_name (const char *asmspec)\n   return -1;\n }\n \f\n+/* Return true if it is possible to put DECL in an object_block.  */\n+\n+static bool\n+use_blocks_for_decl_p (tree decl)\n+{\n+  /* Only data DECLs can be placed into object blocks.  */\n+  if (TREE_CODE (decl) != VAR_DECL && TREE_CODE (decl) != CONST_DECL)\n+    return false;\n+\n+  if (TREE_CODE (decl) == VAR_DECL)\n+    {\n+      /* The object must be defined in this translation unit.  */\n+      if (DECL_EXTERNAL (decl))\n+\treturn false;\n+\n+      /* There's no point using object blocks for something that is\n+\t isolated by definition.  */\n+      if (DECL_ONE_ONLY (decl))\n+\treturn false;\n+\n+      /* Symbols that use .common cannot be put into blocks.  */\n+      if (DECL_COMMON (decl) && DECL_INITIAL (decl) == NULL)\n+\treturn false;\n+    }\n+\n+  /* We can only calculate block offsets if the decl has a known\n+     constant size.  */\n+  if (DECL_SIZE_UNIT (decl) == NULL)\n+    return false;\n+  if (!host_integerp (DECL_SIZE_UNIT (decl), 1))\n+    return false;\n+\n+  /* Detect decls created by dw2_force_const_mem.  Such decls are\n+     special because DECL_INITIAL doesn't specify the decl's true value.\n+     dw2_output_indirect_constants will instead call assemble_variable\n+     with dont_output_data set to 1 and then print the contents itself.  */\n+  if (DECL_INITIAL (decl) == decl)\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Make sure block symbol SYMBOL is in section SECT, moving it to a\n+   different block if necessary.  */\n+\n+static void\n+change_symbol_section (rtx symbol, section *sect)\n+{\n+  if (sect != SYMBOL_REF_BLOCK (symbol)->sect)\n+    {\n+      gcc_assert (SYMBOL_REF_BLOCK_OFFSET (symbol) < 0);\n+      SYMBOL_REF_BLOCK (symbol) = get_block_for_section (sect);\n+    }\n+}\n+\n+/* Return the section into which the given VAR_DECL or CONST_DECL\n+   should be placed.  */\n+\n+static section *\n+get_variable_section (tree decl)\n+{\n+  int reloc;\n+\n+  if (DECL_INITIAL (decl) == error_mark_node)\n+    reloc = contains_pointers_p (TREE_TYPE (decl)) ? 3 : 0;\n+  else if (DECL_INITIAL (decl))\n+    reloc = compute_reloc_for_constant (DECL_INITIAL (decl));\n+  else\n+    reloc = 0;\n+\n+  resolve_unique_section (decl, reloc, flag_data_sections);\n+  if (IN_NAMED_SECTION (decl))\n+    return get_named_section (decl, NULL, reloc);\n+  else\n+    return targetm.asm_out.select_section (decl, reloc, DECL_ALIGN (decl));\n+}\n+\n /* Create the DECL_RTL for a VAR_DECL or FUNCTION_DECL.  DECL should\n    have static storage duration.  In other words, it should not be an\n    automatic variable, including PARM_DECLs.\n@@ -741,9 +912,9 @@ make_decl_rtl (tree decl)\n   if (DECL_RTL_SET_P (decl))\n     {\n       /* If the old RTL had the wrong mode, fix the mode.  */\n-      if (GET_MODE (DECL_RTL (decl)) != DECL_MODE (decl))\n-\tSET_DECL_RTL (decl, adjust_address_nv (DECL_RTL (decl),\n-\t\t\t\t\t       DECL_MODE (decl), 0));\n+      x = DECL_RTL (decl);\n+      if (GET_MODE (x) != DECL_MODE (decl))\n+\tSET_DECL_RTL (decl, adjust_address_nv (x, DECL_MODE (decl), 0));\n \n       if (TREE_CODE (decl) != FUNCTION_DECL && DECL_REGISTER (decl))\n \treturn;\n@@ -758,6 +929,13 @@ make_decl_rtl (tree decl)\n \t decl attribute overrides another.  */\n       targetm.encode_section_info (decl, DECL_RTL (decl), false);\n \n+      /* If the old address was assigned to an object block, see whether\n+\t that block is still in the right section.  */\n+      if (MEM_P (x)\n+\t  && GET_CODE (XEXP (x, 0)) == SYMBOL_REF\n+\t  && SYMBOL_REF_IN_BLOCK_P (XEXP (x, 0)))\n+\tchange_symbol_section (XEXP (x, 0), get_variable_section (decl));\n+\n       /* Make this function static known to the mudflap runtime.  */\n       if (flag_mudflap && TREE_CODE (decl) == VAR_DECL)\n \tmudflap_enqueue_decl (decl);\n@@ -854,7 +1032,13 @@ make_decl_rtl (tree decl)\n   if (TREE_CODE (decl) == VAR_DECL && DECL_WEAK (decl))\n     DECL_COMMON (decl) = 0;\n \n-  x = gen_rtx_SYMBOL_REF (Pmode, name);\n+  if (use_object_blocks_p () && use_blocks_for_decl_p (decl))\n+    {\n+      section *sect = get_variable_section (decl);\n+      x = create_block_symbol (name, get_block_for_section (sect), -1);\n+    }\n+  else\n+    x = gen_rtx_SYMBOL_REF (Pmode, name);\n   SYMBOL_REF_WEAK (x) = DECL_WEAK (decl);\n   SET_SYMBOL_REF_DECL (x, decl);\n \n@@ -1407,6 +1591,38 @@ asm_emit_uninitialised (tree decl, const char *name,\n   return true;\n }\n \n+/* A subroutine of assemble_variable.  Output the label and contents of\n+   DECL, whose address is a SYMBOL_REF with name NAME.  DONT_OUTPUT_DATA\n+   is as for assemble_variable.  */\n+\n+static void\n+assemble_variable_contents (tree decl, const char *name,\n+\t\t\t    bool dont_output_data)\n+{\n+  /* Do any machine/system dependent processing of the object.  */\n+#ifdef ASM_DECLARE_OBJECT_NAME\n+  last_assemble_variable_decl = decl;\n+  ASM_DECLARE_OBJECT_NAME (asm_out_file, name, decl);\n+#else\n+  /* Standard thing is just output label for the object.  */\n+  ASM_OUTPUT_LABEL (asm_out_file, name);\n+#endif /* ASM_DECLARE_OBJECT_NAME */\n+\n+  if (!dont_output_data)\n+    {\n+      if (DECL_INITIAL (decl)\n+\t  && DECL_INITIAL (decl) != error_mark_node\n+\t  && !initializer_zerop (DECL_INITIAL (decl)))\n+\t/* Output the actual data.  */\n+\toutput_constant (DECL_INITIAL (decl),\n+\t\t\t tree_low_cst (DECL_SIZE_UNIT (decl), 1),\n+\t\t\t DECL_ALIGN (decl));\n+      else\n+\t/* Leave space for it.  */\n+\tassemble_zeros (tree_low_cst (DECL_SIZE_UNIT (decl), 1));\n+    }\n+}\n+\n /* Assemble everything that is needed for a variable or function declaration.\n    Not used for automatic variables, and not used for function definitions.\n    Should not be called for variables of incomplete structure type.\n@@ -1423,8 +1639,8 @@ assemble_variable (tree decl, int top_level ATTRIBUTE_UNUSED,\n {\n   const char *name;\n   unsigned int align;\n-  int reloc = 0;\n   rtx decl_rtl;\n+  bool in_block_p;\n \n   if (lang_hooks.decls.prepare_assemble_variable)\n     lang_hooks.decls.prepare_assemble_variable (decl);\n@@ -1494,6 +1710,9 @@ assemble_variable (tree decl, int top_level ATTRIBUTE_UNUSED,\n       return;\n     }\n \n+  gcc_assert (MEM_P (decl_rtl));\n+  gcc_assert (GET_CODE (XEXP (decl_rtl, 0)) == SYMBOL_REF);\n+  in_block_p = SYMBOL_REF_IN_BLOCK_P (XEXP (decl_rtl, 0));\n   name = XSTR (XEXP (decl_rtl, 0), 0);\n   if (TREE_PUBLIC (decl) && DECL_NAME (decl))\n     notice_global_symbol (decl);\n@@ -1563,6 +1782,10 @@ assemble_variable (tree decl, int top_level ATTRIBUTE_UNUSED,\n #endif\n \t}\n     }\n+  /* Do not handle decls as common if they will be assigned a\n+     specific section position.  */\n+  else if (in_block_p)\n+    ;\n   else if (DECL_INITIAL (decl) == 0\n \t   || DECL_INITIAL (decl) == error_mark_node\n \t   || (flag_zero_initialized_in_bss\n@@ -1605,47 +1828,27 @@ assemble_variable (tree decl, int top_level ATTRIBUTE_UNUSED,\n     globalize_decl (decl);\n \n   /* Output any data that we will need to use the address of.  */\n-  if (DECL_INITIAL (decl) == error_mark_node)\n-    reloc = contains_pointers_p (TREE_TYPE (decl)) ? 3 : 0;\n-  else if (DECL_INITIAL (decl))\n-    {\n-      reloc = compute_reloc_for_constant (DECL_INITIAL (decl));\n-      output_addressed_constants (DECL_INITIAL (decl));\n-    }\n-\n-  /* Switch to the appropriate section.  */\n-  resolve_unique_section (decl, reloc, flag_data_sections);\n-  variable_section (decl, reloc);\n+  if (DECL_INITIAL (decl) && DECL_INITIAL (decl) != error_mark_node)\n+    output_addressed_constants (DECL_INITIAL (decl));\n \n   /* dbxout.c needs to know this.  */\n   if (in_section && (in_section->common.flags & SECTION_CODE) != 0)\n     DECL_IN_TEXT_SECTION (decl) = 1;\n \n-  /* Output the alignment of this data.  */\n-  if (align > BITS_PER_UNIT)\n-    ASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (DECL_ALIGN_UNIT (decl)));\n-\n-  /* Do any machine/system dependent processing of the object.  */\n-#ifdef ASM_DECLARE_OBJECT_NAME\n-  last_assemble_variable_decl = decl;\n-  ASM_DECLARE_OBJECT_NAME (asm_out_file, name, decl);\n-#else\n-  /* Standard thing is just output label for the object.  */\n-  ASM_OUTPUT_LABEL (asm_out_file, name);\n-#endif /* ASM_DECLARE_OBJECT_NAME */\n-\n-  if (!dont_output_data)\n+  /* If the decl is part of an object_block, make sure that the decl\n+     has been positioned within its block, but do not write out its\n+     definition yet.  output_object_blocks will do that later.  */\n+  if (in_block_p)\n     {\n-      if (DECL_INITIAL (decl)\n-\t  && DECL_INITIAL (decl) != error_mark_node\n-\t  && !initializer_zerop (DECL_INITIAL (decl)))\n-\t/* Output the actual data.  */\n-\toutput_constant (DECL_INITIAL (decl),\n-\t\t\t tree_low_cst (DECL_SIZE_UNIT (decl), 1),\n-\t\t\t align);\n-      else\n-\t/* Leave space for it.  */\n-\tassemble_zeros (tree_low_cst (DECL_SIZE_UNIT (decl), 1));\n+      gcc_assert (!dont_output_data);\n+      place_block_symbol (XEXP (decl_rtl, 0));\n+    }\n+  else\n+    {\n+      switch_to_section (get_variable_section (decl));\n+      if (align > BITS_PER_UNIT)\n+\tASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (DECL_ALIGN_UNIT (decl)));\n+      assemble_variable_contents (decl, name, dont_output_data);\n     }\n }\n \n@@ -2554,6 +2757,46 @@ copy_constant (tree exp)\n     }\n }\n \f\n+/* Return the alignment of constant EXP in bits.  */\n+\n+static unsigned int\n+get_constant_alignment (tree exp)\n+{\n+  unsigned int align;\n+\n+  align = TYPE_ALIGN (TREE_TYPE (exp));\n+#ifdef CONSTANT_ALIGNMENT\n+  align = CONSTANT_ALIGNMENT (exp, align);\n+#endif\n+  return align;\n+}\n+\n+/* Return the section into which constant EXP should be placed.  */\n+\n+static section *\n+get_constant_section (tree exp)\n+{\n+  if (IN_NAMED_SECTION (exp))\n+    return get_named_section (exp, NULL, compute_reloc_for_constant (exp));\n+  else\n+    return targetm.asm_out.select_section (exp,\n+\t\t\t\t\t   compute_reloc_for_constant (exp),\n+\t\t\t\t\t   get_constant_alignment (exp));\n+}\n+\n+/* Return the size of constant EXP in bytes.  */\n+\n+static HOST_WIDE_INT\n+get_constant_size (tree exp)\n+{\n+  HOST_WIDE_INT size;\n+\n+  size = int_size_in_bytes (TREE_TYPE (exp));\n+  if (TREE_CODE (exp) == STRING_CST)\n+    size = MAX (TREE_STRING_LENGTH (exp), size);\n+  return size;\n+}\n+\n /* Subroutine of output_constant_def:\n    No constant equal to EXP is known to have been output.\n    Make a constant descriptor to enter EXP in the hash table.\n@@ -2582,8 +2825,15 @@ build_constant_desc (tree exp)\n   ASM_GENERATE_INTERNAL_LABEL (label, \"LC\", labelno);\n \n   /* We have a symbol name; construct the SYMBOL_REF and the MEM.  */\n-  symbol = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (label));\n-  SYMBOL_REF_FLAGS (symbol) = SYMBOL_FLAG_LOCAL;\n+  if (use_object_blocks_p ())\n+    {\n+      section *sect = get_constant_section (exp);\n+      symbol = create_block_symbol (ggc_strdup (label),\n+\t\t\t\t    get_block_for_section (sect), -1);\n+    }\n+  else\n+    symbol = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (label));\n+  SYMBOL_REF_FLAGS (symbol) |= SYMBOL_FLAG_LOCAL;\n   SET_SYMBOL_REF_DECL (symbol, desc->value);\n   TREE_CONSTANT_POOL_ADDRESS_P (symbol) = 1;\n \n@@ -2676,54 +2926,57 @@ maybe_output_constant_def_contents (struct constant_descriptor_tree *desc,\n   output_constant_def_contents (symbol);\n }\n \n+/* Subroutine of output_constant_def_contents.  Output the definition\n+   of constant EXP, which is pointed to by label LABEL.  ALIGN is the\n+   constant's alignment in bits.  */\n+\n+static void\n+assemble_constant_contents (tree exp, const char *label, unsigned int align)\n+{\n+  HOST_WIDE_INT size;\n+\n+  size = get_constant_size (exp);\n+\n+  /* Do any machine/system dependent processing of the constant.  */\n+#ifdef ASM_DECLARE_CONSTANT_NAME\n+  ASM_DECLARE_CONSTANT_NAME (asm_out_file, label, exp, size);\n+#else\n+  /* Standard thing is just output label for the constant.  */\n+  ASM_OUTPUT_LABEL (asm_out_file, label);\n+#endif /* ASM_DECLARE_CONSTANT_NAME */\n+\n+  /* Output the value of EXP.  */\n+  output_constant (exp, size, align);\n+}\n+\n /* We must output the constant data referred to by SYMBOL; do so.  */\n \n static void\n output_constant_def_contents (rtx symbol)\n {\n   tree exp = SYMBOL_REF_DECL (symbol);\n-  const char *label = XSTR (symbol, 0);\n-  HOST_WIDE_INT size;\n+  unsigned int align;\n \n   /* Make sure any other constants whose addresses appear in EXP\n      are assigned label numbers.  */\n-  int reloc = compute_reloc_for_constant (exp);\n-\n-  /* Align the location counter as required by EXP's data type.  */\n-  unsigned int align = TYPE_ALIGN (TREE_TYPE (exp));\n-#ifdef CONSTANT_ALIGNMENT\n-  align = CONSTANT_ALIGNMENT (exp, align);\n-#endif\n-\n   output_addressed_constants (exp);\n \n   /* We are no longer deferring this constant.  */\n   TREE_ASM_WRITTEN (exp) = 1;\n \n-  if (IN_NAMED_SECTION (exp))\n-    switch_to_section (get_named_section (exp, NULL, reloc));\n+  /* If the constant is part of an object block, make sure that the\n+     decl has been positioned within its block, but do not write out\n+     its definition yet.  output_object_blocks will do that later.  */\n+  if (SYMBOL_REF_IN_BLOCK_P (symbol))\n+    place_block_symbol (symbol);\n   else\n-    switch_to_section (targetm.asm_out.select_section (exp, reloc, align));\n-\n-  if (align > BITS_PER_UNIT)\n     {\n-      ASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (align / BITS_PER_UNIT));\n+      switch_to_section (get_constant_section (exp));\n+      align = get_constant_alignment (exp);\n+      if (align > BITS_PER_UNIT)\n+\tASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (align / BITS_PER_UNIT));\n+      assemble_constant_contents (exp, XSTR (symbol, 0), align);\n     }\n-\n-  size = int_size_in_bytes (TREE_TYPE (exp));\n-  if (TREE_CODE (exp) == STRING_CST)\n-    size = MAX (TREE_STRING_LENGTH (exp), size);\n-\n-  /* Do any machine/system dependent processing of the constant.  */\n-#ifdef ASM_DECLARE_CONSTANT_NAME\n-  ASM_DECLARE_CONSTANT_NAME (asm_out_file, label, exp, size);\n-#else\n-  /* Standard thing is just output label for the constant.  */\n-  ASM_OUTPUT_LABEL (asm_out_file, label);\n-#endif /* ASM_DECLARE_CONSTANT_NAME */\n-\n-  /* Output the value of EXP.  */\n-  output_constant (exp, size, align);\n   if (flag_mudflap)\n     mudflap_enqueue_constant (exp);\n }\n@@ -2987,8 +3240,16 @@ force_const_mem (enum machine_mode mode, rtx x)\n \n   /* Construct the SYMBOL_REF.  Make sure to mark it as belonging to\n      the constants pool.  */\n-  desc->sym = symbol = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (label));\n-  SYMBOL_REF_FLAGS (symbol) = SYMBOL_FLAG_LOCAL;\n+  if (use_object_blocks_p () && targetm.use_blocks_for_constant_p (mode, x))\n+    {\n+      section *sect = targetm.asm_out.select_rtx_section (mode, x, align);\n+      symbol = create_block_symbol (ggc_strdup (label),\n+\t\t\t\t    get_block_for_section (sect), -1);\n+    }\n+  else\n+    symbol = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (label));\n+  desc->sym = symbol;\n+  SYMBOL_REF_FLAGS (symbol) |= SYMBOL_FLAG_LOCAL;\n   CONSTANT_POOL_ADDRESS_P (symbol) = 1;\n   SET_SYMBOL_REF_CONSTANT (symbol, desc);\n   current_function_uses_const_pool = 1;\n@@ -3090,15 +3351,15 @@ output_constant_pool_2 (enum machine_mode mode, rtx x, unsigned int align)\n     }\n }\n \n-/* Worker function for output_constant_pool.  Emit POOL.  */\n+/* Worker function for output_constant_pool.  Emit constant DESC,\n+   giving it ALIGN bits of alignment.  */\n \n static void\n-output_constant_pool_1 (struct constant_descriptor_rtx *desc)\n+output_constant_pool_1 (struct constant_descriptor_rtx *desc,\n+\t\t\tunsigned int align)\n {\n   rtx x, tmp;\n \n-  if (!desc->mark)\n-    return;\n   x = desc->constant;\n \n   /* See if X is a LABEL_REF (or a CONST referring to a LABEL_REF)\n@@ -3131,29 +3392,25 @@ output_constant_pool_1 (struct constant_descriptor_rtx *desc)\n       break;\n     }\n \n-  /* First switch to correct section.  */\n-  switch_to_section (targetm.asm_out.select_rtx_section (desc->mode, x,\n-\t\t\t\t\t\t\t desc->align));\n-\n #ifdef ASM_OUTPUT_SPECIAL_POOL_ENTRY\n   ASM_OUTPUT_SPECIAL_POOL_ENTRY (asm_out_file, x, desc->mode,\n-\t\t\t\t desc->align, desc->labelno, done);\n+\t\t\t\t align, desc->labelno, done);\n #endif\n \n-  assemble_align (desc->align);\n+  assemble_align (align);\n \n   /* Output the label.  */\n   targetm.asm_out.internal_label (asm_out_file, \"LC\", desc->labelno);\n \n   /* Output the data.  */\n-  output_constant_pool_2 (desc->mode, x, desc->align);\n+  output_constant_pool_2 (desc->mode, x, align);\n \n   /* Make sure all constants in SECTION_MERGE and not SECTION_STRINGS\n      sections have proper size.  */\n-  if (desc->align > GET_MODE_BITSIZE (desc->mode)\n+  if (align > GET_MODE_BITSIZE (desc->mode)\n       && in_section\n       && (in_section->common.flags & SECTION_MERGE))\n-    assemble_align (desc->align);\n+    assemble_align (align);\n \n #ifdef ASM_OUTPUT_SPECIAL_POOL_ENTRY\n  done:\n@@ -3265,7 +3522,21 @@ output_constant_pool (const char *fnname ATTRIBUTE_UNUSED,\n #endif\n \n   for (desc = pool->first; desc ; desc = desc->next)\n-    output_constant_pool_1 (desc);\n+    if (desc->mark)\n+      {\n+\t/* If the constant is part of an object_block, make sure that\n+\t   the constant has been positioned within its block, but do not\n+\t   write out its definition yet.  output_object_blocks will do\n+\t   that later.  */\n+\tif (SYMBOL_REF_IN_BLOCK_P (desc->sym))\n+\t  place_block_symbol (desc->sym);\n+\telse\n+\t  {\n+\t    switch_to_section (targetm.asm_out.select_rtx_section\n+\t\t\t       (desc->mode, desc->constant, desc->align));\n+\t    output_constant_pool_1 (desc, desc->align);\n+\t  }\n+      }\n \n #ifdef ASM_OUTPUT_POOL_EPILOGUE\n   ASM_OUTPUT_POOL_EPILOGUE (asm_out_file, fnname, fndecl, pool->offset);\n@@ -4805,6 +5076,8 @@ init_varasm_once (void)\n {\n   section_htab = htab_create_ggc (31, section_entry_hash,\n \t\t\t\t  section_entry_eq, NULL);\n+  object_block_htab = htab_create_ggc (31, object_block_entry_hash,\n+\t\t\t\t       object_block_entry_eq, NULL);\n   const_desc_htab = htab_create_ggc (1009, const_desc_hash,\n \t\t\t\t     const_desc_eq, NULL);\n \n@@ -5413,7 +5686,7 @@ default_encode_section_info (tree decl, rtx rtl, int first ATTRIBUTE_UNUSED)\n   if (GET_CODE (symbol) != SYMBOL_REF)\n     return;\n \n-  flags = 0;\n+  flags = SYMBOL_REF_FLAGS (symbol) & SYMBOL_FLAG_IN_BLOCK;\n   if (TREE_CODE (decl) == FUNCTION_DECL)\n     flags |= SYMBOL_FLAG_FUNCTION;\n   if (targetm.binds_local_p (decl))\n@@ -5440,6 +5713,59 @@ default_strip_name_encoding (const char *str)\n   return str + (*str == '*');\n }\n \n+#ifdef ASM_OUTPUT_DEF\n+/* The default implementation of TARGET_ASM_OUTPUT_ANCHOR.  Define the\n+   anchor relative to \".\", the current section position.  */\n+\n+void\n+default_asm_output_anchor (rtx symbol)\n+{\n+  char buffer[100];\n+\n+  sprintf (buffer, \". + \" HOST_WIDE_INT_PRINT_DEC,\n+\t   SYMBOL_REF_BLOCK_OFFSET (symbol));\n+  ASM_OUTPUT_DEF (asm_out_file, XSTR (symbol, 0), buffer);\n+}\n+#endif\n+\n+/* The default implementation of TARGET_USE_ANCHORS_FOR_SYMBOL_P.  */\n+\n+bool\n+default_use_anchors_for_symbol_p (rtx symbol)\n+{\n+  section *sect;\n+  tree decl;\n+\n+  /* Don't use anchors for mergeable sections.  The linker might move\n+     the objects around.  */\n+  sect = SYMBOL_REF_BLOCK (symbol)->sect;\n+  if (sect->common.flags & SECTION_MERGE)\n+    return false;\n+\n+  /* Don't use anchors for small data sections.  The small data register\n+     acts as an anchor for such sections.  */\n+  if (sect->common.flags & SECTION_SMALL)\n+    return false;\n+\n+  decl = SYMBOL_REF_DECL (symbol);\n+  if (decl && DECL_P (decl))\n+    {\n+      /* Don't use section anchors for decls that might be defined by\n+\t other modules.  */\n+      if (!targetm.binds_local_p (decl))\n+\treturn false;\n+\n+      /* Don't use section anchors for decls that will be placed in a\n+\t small data section.  */\n+      /* ??? Ideally, this check would be redundant with the SECTION_SMALL\n+\t one above.  The problem is that we only use SECTION_SMALL for\n+\t sections that should be marked as small in the section directive.  */\n+      if (targetm.in_small_data_p (decl))\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n /* Assume ELF-ish defaults, since that's pretty much the most liberal\n    wrt cross-module name binding.  */\n \n@@ -5620,4 +5946,207 @@ switch_to_section (section *new_section)\n   new_section->common.flags |= SECTION_DECLARED;\n }\n \n+/* If block symbol SYMBOL has not yet been assigned an offset, place\n+   it at the end of its block.  */\n+\n+void\n+place_block_symbol (rtx symbol)\n+{\n+  unsigned HOST_WIDE_INT size, mask, offset;\n+  struct constant_descriptor_rtx *desc;\n+  unsigned int alignment;\n+  struct object_block *block;\n+  tree decl;\n+\n+  if (SYMBOL_REF_BLOCK_OFFSET (symbol) >= 0)\n+    return;\n+\n+  /* Work out the symbol's size and alignment.  */\n+  if (CONSTANT_POOL_ADDRESS_P (symbol))\n+    {\n+      desc = SYMBOL_REF_CONSTANT (symbol);\n+      alignment = desc->align;\n+      size = GET_MODE_SIZE (desc->mode);\n+    }\n+  else if (TREE_CONSTANT_POOL_ADDRESS_P (symbol))\n+    {\n+      decl = SYMBOL_REF_DECL (symbol);\n+      alignment = get_constant_alignment (decl);\n+      size = get_constant_size (decl);\n+    }\n+  else\n+    {\n+      decl = SYMBOL_REF_DECL (symbol);\n+      alignment = DECL_ALIGN (decl);\n+      size = tree_low_cst (DECL_SIZE_UNIT (decl), 1);\n+    }\n+\n+  /* Calculate the object's offset from the start of the block.  */\n+  block = SYMBOL_REF_BLOCK (symbol);\n+  mask = alignment / BITS_PER_UNIT - 1;\n+  offset = (block->size + mask) & ~mask;\n+  SYMBOL_REF_BLOCK_OFFSET (symbol) = offset;\n+\n+  /* Record the block's new alignment and size.  */\n+  block->alignment = MAX (block->alignment, alignment);\n+  block->size = offset + size;\n+\n+  VEC_safe_push (rtx, gc, block->objects, symbol);\n+}\n+\n+/* Return the anchor that should be used to address byte offset OFFSET\n+   from the first object in BLOCK.  MODEL is the TLS model used\n+   to access it.  */\n+\n+rtx\n+get_section_anchor (struct object_block *block, HOST_WIDE_INT offset,\n+\t\t    enum tls_model model)\n+{\n+  char label[100];\n+  unsigned int begin, middle, end;\n+  unsigned HOST_WIDE_INT min_offset, max_offset, range, bias, delta;\n+  rtx anchor;\n+\n+  /* Work out the anchor's offset.  Use an offset of 0 for the first\n+     anchor so that we don't pessimize the case where we take the address\n+     of a variable at the beginning of the block.  This is particularly\n+     useful when a block has only one variable assigned to it.\n+\n+     We try to place anchors RANGE bytes apart, so there can then be\n+     anchors at +/-RANGE, +/-2 * RANGE, and so on, up to the limits of\n+     a ptr_mode offset.  With some target settings, the lowest such\n+     anchor might be out of range for the lowest ptr_mode offset;\n+     likewise the highest anchor for the highest offset.  Use anchors\n+     at the extreme ends of the ptr_mode range in such cases.\n+\n+     All arithmetic uses unsigned integers in order to avoid\n+     signed overflow.  */\n+  max_offset = (unsigned HOST_WIDE_INT) targetm.max_anchor_offset;\n+  min_offset = (unsigned HOST_WIDE_INT) targetm.min_anchor_offset;\n+  range = max_offset - min_offset + 1;\n+  if (range == 0)\n+    offset = 0;\n+  else\n+    {\n+      bias = 1 << (GET_MODE_BITSIZE (ptr_mode) - 1);\n+      if (offset < 0)\n+\t{\n+\t  delta = -(unsigned HOST_WIDE_INT) offset + max_offset;\n+\t  delta -= delta % range;\n+\t  if (delta > bias)\n+\t    delta = bias;\n+\t  offset = (HOST_WIDE_INT) (-delta);\n+\t}\n+      else\n+\t{\n+\t  delta = (unsigned HOST_WIDE_INT) offset - min_offset;\n+\t  delta -= delta % range;\n+\t  if (delta > bias - 1)\n+\t    delta = bias - 1;\n+\t  offset = (HOST_WIDE_INT) delta;\n+\t}\n+    }\n+\n+  /* Do a binary search to see if there's already an anchor we can use.\n+     Set BEGIN to the new anchor's index if not.  */\n+  begin = 0;\n+  end = VEC_length (rtx, block->anchors);\n+  while (begin != end)\n+    {\n+      middle = (end + begin) / 2;\n+      anchor = VEC_index (rtx, block->anchors, middle);\n+      if (SYMBOL_REF_BLOCK_OFFSET (anchor) > offset)\n+\tend = middle;\n+      else if (SYMBOL_REF_BLOCK_OFFSET (anchor) < offset)\n+\tbegin = middle + 1;\n+      else if (SYMBOL_REF_TLS_MODEL (anchor) > model)\n+\tend = middle;\n+      else if (SYMBOL_REF_TLS_MODEL (anchor) < model)\n+\tbegin = middle + 1;\n+      else\n+\treturn anchor;\n+    }\n+\n+  /* Create a new anchor with a unique label.  */\n+  ASM_GENERATE_INTERNAL_LABEL (label, \"LANCHOR\", anchor_labelno++);\n+  anchor = create_block_symbol (ggc_strdup (label), block, offset);\n+  SYMBOL_REF_FLAGS (anchor) |= SYMBOL_FLAG_LOCAL | SYMBOL_FLAG_ANCHOR;\n+  SYMBOL_REF_FLAGS (anchor) |= model << SYMBOL_FLAG_TLS_SHIFT;\n+\n+  /* Insert it at index BEGIN.  */\n+  VEC_safe_insert (rtx, gc, block->anchors, begin, anchor);\n+  return anchor;\n+}\n+\n+/* Output the objects in BLOCK.  */\n+\n+static void\n+output_object_block (struct object_block *block)\n+{\n+  struct constant_descriptor_rtx *desc;\n+  unsigned int i;\n+  HOST_WIDE_INT offset;\n+  tree decl;\n+  rtx symbol;\n+\n+  if (block->objects == NULL)\n+    return;\n+\n+  /* Switch to the section and make sure that the first byte is\n+     suitably aligned.  */\n+  switch_to_section (block->sect);\n+  assemble_align (block->alignment);\n+\n+  /* Define the values of all anchors relative to the current section\n+     position.  */\n+  for (i = 0; VEC_iterate (rtx, block->anchors, i, symbol); i++)\n+    targetm.asm_out.output_anchor (symbol);\n+\n+  /* Output the objects themselves.  */\n+  offset = 0;\n+  for (i = 0; VEC_iterate (rtx, block->objects, i, symbol); i++)\n+    {\n+      /* Move to the object's offset, padding with zeros if necessary.  */\n+      assemble_zeros (SYMBOL_REF_BLOCK_OFFSET (symbol) - offset);\n+      offset = SYMBOL_REF_BLOCK_OFFSET (symbol);\n+      if (CONSTANT_POOL_ADDRESS_P (symbol))\n+\t{\n+\t  desc = SYMBOL_REF_CONSTANT (symbol);\n+\t  output_constant_pool_1 (desc, 1);\n+\t  offset += GET_MODE_SIZE (desc->mode);\n+\t}\n+      else if (TREE_CONSTANT_POOL_ADDRESS_P (symbol))\n+\t{\n+\t  decl = SYMBOL_REF_DECL (symbol);\n+\t  assemble_constant_contents (decl, XSTR (symbol, 0),\n+\t\t\t\t      get_constant_alignment (decl));\n+\t  offset += get_constant_size (decl);\n+\t}\n+      else\n+\t{\n+\t  decl = SYMBOL_REF_DECL (symbol);\n+\t  assemble_variable_contents (decl, XSTR (symbol, 0), false);\n+\t  offset += tree_low_cst (DECL_SIZE_UNIT (decl), 1);\n+\t}\n+    }\n+}\n+\n+/* A htab_traverse callback used to call output_object_block for\n+   each member of object_block_htab.  */\n+\n+static int\n+output_object_block_htab (void **slot, void *data ATTRIBUTE_UNUSED)\n+{\n+  output_object_block ((struct object_block *) (*slot));\n+  return 1;\n+}\n+\n+/* Output the definitions of all object_blocks.  */\n+\n+void\n+output_object_blocks (void)\n+{\n+  htab_traverse (object_block_htab, output_object_block_htab, NULL);\n+}\n+\n #include \"gt-varasm.h\""}]}