{"sha": "3c0fca12828829ee5a8c277c1792f59dfd868fef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2MwZmNhMTI4Mjg4MjllZTVhOGMyNzdjMTc5MmY1OWRmZDg2OGZlZg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-03-16T17:42:06Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-03-16T17:42:06Z"}, "message": "* calls.c: Revert last two changes.\n\nFrom-SVN: r32592", "tree": {"sha": "ba29e89a8ac28cfe750236466fdfd87b9c8a61fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba29e89a8ac28cfe750236466fdfd87b9c8a61fd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3c0fca12828829ee5a8c277c1792f59dfd868fef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c0fca12828829ee5a8c277c1792f59dfd868fef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c0fca12828829ee5a8c277c1792f59dfd868fef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c0fca12828829ee5a8c277c1792f59dfd868fef/comments", "author": null, "committer": null, "parents": [{"sha": "ae23f3ed01aea900e9c046cddaa9f0b632d1c932", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae23f3ed01aea900e9c046cddaa9f0b632d1c932", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae23f3ed01aea900e9c046cddaa9f0b632d1c932"}], "stats": {"total": 903, "additions": 668, "deletions": 235}, "files": [{"sha": "264a0bcbbd0eb3585ec28b424cf07131f72d3fc0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c0fca12828829ee5a8c277c1792f59dfd868fef/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c0fca12828829ee5a8c277c1792f59dfd868fef/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3c0fca12828829ee5a8c277c1792f59dfd868fef", "patch": "@@ -1,3 +1,7 @@\n+2000-03-16  Richard Henderson  <rth@cygnus.com>\n+\n+\t* calls.c: Revert last two changes.\n+\n 2000-03-16  Bernd Schmidt  <bernds@cygnus.co.uk>\n \n \t* fp-bit.c (_unpack_d): If NO_DENORMALS is defined, anything that"}, {"sha": "7ae7b3d60f33dcc545782b6f6e985f30f16a4d04", "filename": "gcc/calls.c", "status": "modified", "additions": 664, "deletions": 235, "changes": 899, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c0fca12828829ee5a8c277c1792f59dfd868fef/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c0fca12828829ee5a8c277c1792f59dfd868fef/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=3c0fca12828829ee5a8c277c1792f59dfd868fef", "patch": "@@ -163,9 +163,6 @@ static void compute_argument_addresses\t\tPARAMS ((struct arg_data *,\n static rtx rtx_for_function_call\t\tPARAMS ((tree, tree));\n static void load_register_parameters\t\tPARAMS ((struct arg_data *,\n \t\t\t\t\t\t\t int, rtx *));\n-static rtx emit_library_call_value_1 \t\tPARAMS ((int, rtx, rtx, int,\n-\t\t\t\t\t\t\t enum machine_mode,\n-\t\t\t\t\t\t\t int, va_list));\n static int libfunc_nothrow\t\t\tPARAMS ((rtx));\n \n #if defined(ACCUMULATE_OUTGOING_ARGS) && defined(REG_PARM_STACK_SPACE)\n@@ -1710,7 +1707,6 @@ expand_call (exp, target, ignore)\n   rtx old_stack_level = 0;\n   int old_pending_adj = 0;\n   int old_inhibit_defer_pop = inhibit_defer_pop;\n-  int old_arg_space_so_far = arg_space_so_far;\n   rtx call_fusage = 0;\n   register tree p;\n   register int i;\n@@ -2384,10 +2380,7 @@ expand_call (exp, target, ignore)\n   /* If we pushed args in forward order, perform stack alignment\n      after pushing the last arg.  */\n   if (argblock == 0)\n-    {\n-      anti_adjust_stack (GEN_INT (args_size.constant - unadjusted_args_size));\n-      arg_space_so_far += args_size.constant - unadjusted_args_size;\n-    }\n+    anti_adjust_stack (GEN_INT (args_size.constant - unadjusted_args_size));\n #endif\n #endif\n \n@@ -2439,10 +2432,6 @@ expand_call (exp, target, ignore)\n \t       FUNCTION_ARG (args_so_far, VOIDmode, void_type_node, 1),\n \t       valreg, old_inhibit_defer_pop, call_fusage, is_const, nothrow);\n \n-  /* Stack pointer ought to be restored to the value before call.  */\n-  if (old_arg_space_so_far != arg_space_so_far)\n-    abort();\n-\n   /* If call is cse'able, make appropriate pair of reg-notes around it.\n      Test valreg so we don't crash; may safely ignore `const'\n      if return type is void.  Disable for PARALLEL return values, because\n@@ -2704,21 +2693,38 @@ libfunc_nothrow (fun)\n \n   return 1;\n }\n-\f\n-/* Emit a library call to function FUN (a SYMBOL_REF rtx).\n-   The RETVAL parameter specifies whether return value needs to be saved, other \n-   parameters are documented in the emit_library_call function bellow.  */\n \n-static rtx\n-emit_library_call_value_1 (retval, orgfun, value, no_queue, outmode, nargs, p)\n-     int retval;\n-     rtx orgfun;\n-     rtx value;\n-     int no_queue;\n-     enum machine_mode outmode;\n-     int nargs;\n-     va_list p;\n+/* Output a library call to function FUN (a SYMBOL_REF rtx)\n+   (emitting the queue unless NO_QUEUE is nonzero),\n+   for a value of mode OUTMODE,\n+   with NARGS different arguments, passed as alternating rtx values\n+   and machine_modes to convert them to.\n+   The rtx values should have been passed through protect_from_queue already.\n+\n+   NO_QUEUE will be true if and only if the library call is a `const' call\n+   which will be enclosed in REG_LIBCALL/REG_RETVAL notes; it is equivalent\n+   to the variable is_const in expand_call.\n+\n+   NO_QUEUE must be true for const calls, because if it isn't, then\n+   any pending increment will be emitted between REG_LIBCALL/REG_RETVAL notes,\n+   and will be lost if the libcall sequence is optimized away.\n+\n+   NO_QUEUE must be false for non-const calls, because if it isn't, the\n+   call insn will have its CONST_CALL_P bit set, and it will be incorrectly\n+   optimized.  For instance, the instruction scheduler may incorrectly\n+   move memory references across the non-const call.  */\n+\n+void\n+emit_library_call VPARAMS((rtx orgfun, int no_queue, enum machine_mode outmode,\n+\t\t\t   int nargs, ...))\n {\n+#ifndef ANSI_PROTOTYPES\n+  rtx orgfun;\n+  int no_queue;\n+  enum machine_mode outmode;\n+  int nargs;\n+#endif\n+  va_list p;\n   /* Total size in bytes of all the stack-parms scanned so far.  */\n   struct args_size args_size;\n   /* Size of arguments before any adjustments (such as rounding).  */\n@@ -2734,18 +2740,9 @@ emit_library_call_value_1 (retval, orgfun, value, no_queue, outmode, nargs, p)\n \t       struct args_size offset; struct args_size size; rtx save_area; };\n   struct arg *argvec;\n   int old_inhibit_defer_pop = inhibit_defer_pop;\n-  int old_arg_space_so_far = arg_space_so_far;\n   rtx call_fusage = 0;\n-  rtx mem_value = 0;\n-  int pcc_struct_value = 0;\n-  int struct_value_size = 0;\n-  int is_const;\n   int reg_parm_stack_space = 0;\n   int nothrow;\n-#ifdef ACCUMULATE_OUTGOING_ARGS\n-  int needed;\n-#endif\n-\n #if defined(ACCUMULATE_OUTGOING_ARGS) && defined(REG_PARM_STACK_SPACE)\n   /* Define the boundary of the register parm stack space that needs to be\n      save, if any.  */\n@@ -2754,56 +2751,32 @@ emit_library_call_value_1 (retval, orgfun, value, no_queue, outmode, nargs, p)\n #endif\n \n #ifdef ACCUMULATE_OUTGOING_ARGS\n-  /* Size of the stack reserved for parameter registers.  */\n   int initial_highest_arg_in_use = highest_outgoing_arg_in_use;\n   char *initial_stack_usage_map = stack_usage_map;\n+  int needed;\n #endif\n \n #ifdef REG_PARM_STACK_SPACE\n+  /* Size of the stack reserved for parameter registers.  */\n #ifdef MAYBE_REG_PARM_STACK_SPACE\n   reg_parm_stack_space = MAYBE_REG_PARM_STACK_SPACE;\n #else\n   reg_parm_stack_space = REG_PARM_STACK_SPACE ((tree) 0);\n #endif\n #endif\n \n-  is_const = no_queue;\n-  fun = orgfun;\n-\n-  nothrow = libfunc_nothrow (fun);\n-\n-#ifdef PREFERRED_STACK_BOUNDARY\n-  /* Ensure current function's preferred stack boundary is at least\n-     what we need.  */\n-  if (cfun->preferred_stack_boundary < PREFERRED_STACK_BOUNDARY)\n-    cfun->preferred_stack_boundary = PREFERRED_STACK_BOUNDARY;\n-#endif\n+  VA_START (p, nargs);\n \n-  /* If this kind of value comes back in memory,\n-     decide where in memory it should come back.  */\n-  if (outmode != VOIDmode && aggregate_value_p (type_for_mode (outmode, 0)))\n-    {\n-#ifdef PCC_STATIC_STRUCT_RETURN\n-      rtx pointer_reg\n-\t= hard_function_value (build_pointer_type (type_for_mode (outmode, 0)),\n-\t\t\t       0, 0);\n-      mem_value = gen_rtx_MEM (outmode, pointer_reg);\n-      pcc_struct_value = 1;\n-      if (value == 0)\n-\tvalue = gen_reg_rtx (outmode);\n-#else /* not PCC_STATIC_STRUCT_RETURN */\n-      struct_value_size = GET_MODE_SIZE (outmode);\n-      if (value != 0 && GET_CODE (value) == MEM)\n-\tmem_value = value;\n-      else\n-\tmem_value = assign_stack_temp (outmode, GET_MODE_SIZE (outmode), 0);\n+#ifndef ANSI_PROTOTYPES\n+  orgfun = va_arg (p, rtx);\n+  no_queue = va_arg (p, int);\n+  outmode = va_arg (p, enum machine_mode);\n+  nargs = va_arg (p, int);\n #endif\n \n-      /* This call returns a big structure.  */\n-      is_const = 0;\n-    }\n+  fun = orgfun;\n \n-  /* ??? Unfinished: must pass the memory address as an argument.  */\n+  nothrow = libfunc_nothrow (fun);\n \n   /* Copy all the libcall-arguments out of the varargs data\n      and into a vector ARGVEC.\n@@ -2812,56 +2785,25 @@ emit_library_call_value_1 (retval, orgfun, value, no_queue, outmode, nargs, p)\n      of the full argument passing conventions to limit complexity here since\n      library functions shouldn't have many args.  */\n \n-  argvec = (struct arg *) alloca ((nargs + 1) * sizeof (struct arg));\n-  bzero ((char *) argvec, (nargs + 1) * sizeof (struct arg));\n+  argvec = (struct arg *) alloca (nargs * sizeof (struct arg));\n+  bzero ((char *) argvec, nargs * sizeof (struct arg));\n+\n \n   INIT_CUMULATIVE_ARGS (args_so_far, NULL_TREE, fun, 0);\n \n   args_size.constant = 0;\n   args_size.var = 0;\n \n-  count = 0;\n-\n   push_temp_slots ();\n \n-  /* If there's a structure value address to be passed,\n-     either pass it in the special place, or pass it as an extra argument.  */\n-  if (mem_value && struct_value_rtx == 0 && ! pcc_struct_value)\n-    {\n-      rtx addr = XEXP (mem_value, 0);\n-      nargs++;\n-\n-      /* Make sure it is a reasonable operand for a move or push insn.  */\n-      if (GET_CODE (addr) != REG && GET_CODE (addr) != MEM\n-\t  && ! (CONSTANT_P (addr) && LEGITIMATE_CONSTANT_P (addr)))\n-\taddr = force_operand (addr, NULL_RTX);\n-\n-      argvec[count].value = addr;\n-      argvec[count].mode = Pmode;\n-      argvec[count].partial = 0;\n-\n-      argvec[count].reg = FUNCTION_ARG (args_so_far, Pmode, NULL_TREE, 1);\n-#ifdef FUNCTION_ARG_PARTIAL_NREGS\n-      if (FUNCTION_ARG_PARTIAL_NREGS (args_so_far, Pmode, NULL_TREE, 1))\n-\tabort ();\n+#ifdef PREFERRED_STACK_BOUNDARY\n+  /* Ensure current function's preferred stack boundary is at least\n+     what we need.  */\n+  if (cfun->preferred_stack_boundary < PREFERRED_STACK_BOUNDARY)\n+    cfun->preferred_stack_boundary = PREFERRED_STACK_BOUNDARY;\n #endif\n \n-      locate_and_pad_parm (Pmode, NULL_TREE,\n-\t\t\t   argvec[count].reg && argvec[count].partial == 0,\n-\t\t\t   NULL_TREE, &args_size, &argvec[count].offset,\n-\t\t\t   &argvec[count].size, &alignment_pad);\n-\n-\n-      if (argvec[count].reg == 0 || argvec[count].partial != 0\n-\t  || reg_parm_stack_space > 0)\n-\targs_size.constant += argvec[count].size.constant;\n-\n-      FUNCTION_ARG_ADVANCE (args_so_far, Pmode, (tree) 0, 1);\n-\n-      count++;\n-    }\n-\n-  for (; count < nargs; count++)\n+  for (count = 0; count < nargs; count++)\n     {\n       rtx val = va_arg (p, rtx);\n       enum machine_mode mode = va_arg (p, enum machine_mode);\n@@ -2928,25 +2870,21 @@ emit_library_call_value_1 (retval, orgfun, value, no_queue, outmode, nargs, p)\n \n       FUNCTION_ARG_ADVANCE (args_so_far, mode, (tree) 0, 1);\n     }\n+  va_end (p);\n \n #ifdef FINAL_REG_PARM_STACK_SPACE\n   reg_parm_stack_space = FINAL_REG_PARM_STACK_SPACE (args_size.constant,\n \t\t\t\t\t\t     args_size.var);\n #endif\n+      \n   /* If this machine requires an external definition for library\n      functions, write one out.  */\n   assemble_external_libcall (fun);\n \n   original_args_size = args_size;\n #ifdef PREFERRED_STACK_BOUNDARY\n-  args_size.constant = (((args_size.constant\n-\t\t\t  + arg_space_so_far\n-\t\t\t  + pending_stack_adjust\n-\t\t\t  + STACK_BYTES - 1)\n-\t\t\t / STACK_BYTES\n-\t\t\t * STACK_BYTES)\n-\t\t\t- arg_space_so_far\n-\t\t\t- pending_stack_adjust);\n+  args_size.constant = (((args_size.constant + (STACK_BYTES - 1))\n+\t\t\t / STACK_BYTES) * STACK_BYTES);\n #endif\n \n   args_size.constant = MAX (args_size.constant,\n@@ -3016,11 +2954,8 @@ emit_library_call_value_1 (retval, orgfun, value, no_queue, outmode, nargs, p)\n   /* If we push args individually in reverse order, perform stack alignment\n      before the first push (the last arg).  */\n   if (argblock == 0)\n-    {\n-      anti_adjust_stack (GEN_INT (args_size.constant\n-\t\t\t\t  - original_args_size.constant));\n-      arg_space_so_far += args_size.constant - original_args_size.constant;\n-    }\n+    anti_adjust_stack (GEN_INT (args_size.constant\n+\t\t\t\t- original_args_size.constant));\n #endif\n #endif\n \n@@ -3143,15 +3078,14 @@ emit_library_call_value_1 (retval, orgfun, value, no_queue, outmode, nargs, p)\n \t\t   (save_mode,\n \t\t    plus_constant (argblock,\n \t\t\t\t   argvec[argnum].offset.constant)));\n-\t      argvec[argnum].save_area = gen_reg_rtx (save_mode);\n \n+\t      argvec[argnum].save_area = gen_reg_rtx (save_mode);\n \t      emit_move_insn (argvec[argnum].save_area, stack_area);\n \t    }\n #endif\n \t  emit_push_insn (val, mode, NULL_TREE, NULL_RTX, 0, partial, reg, 0,\n \t\t\t  argblock, GEN_INT (argvec[argnum].offset.constant),\n \t\t\t  reg_parm_stack_space, ARGS_SIZE_RTX (alignment_pad));\n-\t  arg_space_so_far += argvec[argnum].size.constant;\n \n #ifdef ACCUMULATE_OUTGOING_ARGS\n \t  /* Now mark the segment we just used.  */\n@@ -3168,11 +3102,8 @@ emit_library_call_value_1 (retval, orgfun, value, no_queue, outmode, nargs, p)\n   /* If we pushed args in forward order, perform stack alignment\n      after pushing the last arg.  */\n   if (argblock == 0)\n-    {\n-      anti_adjust_stack (GEN_INT (args_size.constant\n-\t\t\t\t  - original_args_size.constant));\n-      arg_space_so_far += args_size.constant - unadjusted_args_size;\n-    }\n+    anti_adjust_stack (GEN_INT (args_size.constant\n+\t\t\t\t- original_args_size.constant));\n #endif\n #endif\n \n@@ -3206,79 +3137,45 @@ emit_library_call_value_1 (retval, orgfun, value, no_queue, outmode, nargs, p)\n       NO_DEFER_POP;\n     }\n \n-#if 0\n   /* For version 1.37, try deleting this entirely.  */\n   if (! no_queue)\n     emit_queue ();\n-#endif\n \n   /* Any regs containing parms remain in use through the call.  */\n   for (count = 0; count < nargs; count++)\n     {\n       rtx reg = argvec[count].reg;\n-      if (reg != 0 && GET_CODE (reg) == PARALLEL)\n+      if (reg != 0 && GET_CODE (argvec[count].reg) == PARALLEL)\n \tuse_group_regs (&call_fusage, reg);\n       else if (reg != 0)\n \tuse_reg (&call_fusage, reg);\n     }\n \n-  /* Pass the function the address in which to return a structure value.  */\n-  if (mem_value != 0 && struct_value_rtx != 0 && ! pcc_struct_value)\n-    {\n-      emit_move_insn (struct_value_rtx,\n-\t\t      force_reg (Pmode,\n-\t\t\t\t force_operand (XEXP (mem_value, 0),\n-\t\t\t\t\t\tNULL_RTX)));\n-      if (GET_CODE (struct_value_rtx) == REG)\n-\t  use_reg (&call_fusage, struct_value_rtx);\n-    }\n-\n   /* Don't allow popping to be deferred, since then\n      cse'ing of library calls could delete a call and leave the pop.  */\n   NO_DEFER_POP;\n \n   /* We pass the old value of inhibit_defer_pop + 1 to emit_call_1, which\n      will set inhibit_defer_pop to that value.  */\n+\n   /* The return type is needed to decide how many bytes the function pops.\n      Signedness plays no role in that, so for simplicity, we pretend it's\n      always signed.  We also assume that the list of arguments passed has\n      no impact, so we pretend it is unknown.  */\n \n   emit_call_1 (fun, \n-               get_identifier (XSTR (orgfun, 0)),\n+               get_identifier (XSTR (orgfun, 0)), \n \t       build_function_type (outmode == VOIDmode ? void_type_node\n \t\t\t\t    : type_for_mode (outmode, 0), NULL_TREE),\n-               original_args_size.constant, args_size.constant,\n-\t       struct_value_size,\n+\t       original_args_size.constant, args_size.constant, 0,\n \t       FUNCTION_ARG (args_so_far, VOIDmode, void_type_node, 1),\n-\t       (mem_value == 0 && outmode != VOIDmode\n-\t\t? hard_libcall_value (outmode) : NULL_RTX),\n-\t       old_inhibit_defer_pop + 1, call_fusage, is_const, nothrow);\n-\n-  /* Now restore inhibit_defer_pop to its actual original value.  */\n-  OK_DEFER_POP;\n+\t       outmode != VOIDmode ? hard_libcall_value (outmode) : NULL_RTX,\n+\t       old_inhibit_defer_pop + 1, call_fusage, no_queue, nothrow);\n \n   pop_temp_slots ();\n \n-  /* Stack pointer ought to be restored to the value before call.  */\n-  if (old_arg_space_so_far != arg_space_so_far)\n-    abort();\n-\n-  /* Copy the value to the right place.  */\n-  if (outmode != VOIDmode && retval)\n-    {\n-      if (mem_value)\n-\t{\n-\t  if (value == 0)\n-\t    value = mem_value;\n-\t  if (value != mem_value)\n-\t    emit_move_insn (value, mem_value);\n-\t}\n-      else if (value != 0)\n-\temit_move_insn (value, hard_libcall_value (outmode));\n-      else\n-\tvalue = hard_libcall_value (outmode);\n-    }\n+  /* Now restore inhibit_defer_pop to its actual original value.  */\n+  OK_DEFER_POP;\n \n #ifdef ACCUMULATE_OUTGOING_ARGS\n #ifdef REG_PARM_STACK_SPACE\n@@ -3290,19 +3187,20 @@ emit_library_call_value_1 (retval, orgfun, value, no_queue, outmode, nargs, p)\n \t= gen_rtx_MEM (save_mode,\n \t\t       memory_address (save_mode,\n \t\t\t\t       plus_constant (argblock,\n-\t\t\t\t\t\t      - high_to_save)));\n+\t\t\t\t\t\t       - high_to_save)));\n #else\n       rtx stack_area\n \t= gen_rtx_MEM (save_mode,\n \t\t       memory_address (save_mode,\n \t\t\t\t       plus_constant (argblock, low_to_save)));\n #endif\n+\n       if (save_mode != BLKmode)\n \temit_move_insn (stack_area, save_area);\n       else\n \temit_block_move (stack_area, validize_mem (save_area),\n \t\t\t GEN_INT (high_to_save - low_to_save + 1),\n-\t\t\t     PARM_BOUNDARY / BITS_PER_UNIT);\n+\t\t\t PARM_BOUNDARY / BITS_PER_UNIT);\n     }\n #endif\n \t  \n@@ -3324,55 +3222,6 @@ emit_library_call_value_1 (retval, orgfun, value, no_queue, outmode, nargs, p)\n   highest_outgoing_arg_in_use = initial_highest_arg_in_use;\n   stack_usage_map = initial_stack_usage_map;\n #endif\n-\n-  return value;\n-\n-}\n-\f\n-/* Output a library call to function FUN (a SYMBOL_REF rtx)\n-   (emitting the queue unless NO_QUEUE is nonzero),\n-   for a value of mode OUTMODE,\n-   with NARGS different arguments, passed as alternating rtx values\n-   and machine_modes to convert them to.\n-   The rtx values should have been passed through protect_from_queue already.\n-\n-   NO_QUEUE will be true if and only if the library call is a `const' call\n-   which will be enclosed in REG_LIBCALL/REG_RETVAL notes; it is equivalent\n-   to the variable is_const in expand_call.\n-\n-   NO_QUEUE must be true for const calls, because if it isn't, then\n-   any pending increment will be emitted between REG_LIBCALL/REG_RETVAL notes,\n-   and will be lost if the libcall sequence is optimized away.\n-\n-   NO_QUEUE must be false for non-const calls, because if it isn't, the\n-   call insn will have its CONST_CALL_P bit set, and it will be incorrectly\n-   optimized.  For instance, the instruction scheduler may incorrectly\n-   move memory references across the non-const call.  */\n-\n-void\n-emit_library_call VPARAMS((rtx orgfun, int no_queue, enum machine_mode outmode,\n-\t\t\t   int nargs, ...))\n-{\n-#ifndef ANSI_PROTOTYPES\n-  rtx orgfun;\n-  int no_queue;\n-  enum machine_mode outmode;\n-  int nargs;\n-#endif\n-  va_list p;\n-\n-  VA_START (p, nargs);\n-\n-#ifndef ANSI_PROTOTYPES\n-  orgfun = va_arg (p, rtx);\n-  no_queue = va_arg (p, int);\n-  outmode = va_arg (p, enum machine_mode);\n-  nargs = va_arg (p, int);\n-#endif\n-\n-  emit_library_call_value_1 (0, orgfun, NULL_RTX, no_queue, outmode, nargs, p);\n-\n-  va_end (p);\n }\n \f\n /* Like emit_library_call except that an extra argument, VALUE,\n@@ -3395,20 +3244,600 @@ emit_library_call_value VPARAMS((rtx orgfun, rtx value, int no_queue,\n   int nargs;\n #endif\n   va_list p;\n-\n-  VA_START (p, nargs);\n-\n-#ifndef ANSI_PROTOTYPES\n-  orgfun = va_arg (p, rtx);\n-  value = va_arg (p, rtx);\n-  no_queue = va_arg (p, int);\n-  outmode = va_arg (p, enum machine_mode);\n-  nargs = va_arg (p, int);\n-#endif\n-\n-  value = emit_library_call_value_1 (1, orgfun, value, no_queue, outmode, nargs, p);\n-\n-  va_end (p);\n+  /* Total size in bytes of all the stack-parms scanned so far.  */\n+  struct args_size args_size;\n+  /* Size of arguments before any adjustments (such as rounding).  */\n+  struct args_size original_args_size;\n+  register int argnum;\n+  rtx fun;\n+  int inc;\n+  int count;\n+  struct args_size alignment_pad;\n+  rtx argblock = 0;\n+  CUMULATIVE_ARGS args_so_far;\n+  struct arg { rtx value; enum machine_mode mode; rtx reg; int partial;\n+\t       struct args_size offset; struct args_size size; rtx save_area; };\n+  struct arg *argvec;\n+  int old_inhibit_defer_pop = inhibit_defer_pop;\n+  rtx call_fusage = 0;\n+  rtx mem_value = 0;\n+  int pcc_struct_value = 0;\n+  int struct_value_size = 0;\n+  int is_const;\n+  int reg_parm_stack_space = 0;\n+  int nothrow;\n+#ifdef ACCUMULATE_OUTGOING_ARGS\n+  int needed;\n+#endif\n+\n+#if defined(ACCUMULATE_OUTGOING_ARGS) && defined(REG_PARM_STACK_SPACE)\n+  /* Define the boundary of the register parm stack space that needs to be\n+     save, if any.  */\n+  int low_to_save = -1, high_to_save = 0;\n+  rtx save_area = 0;            /* Place that it is saved */\n+#endif\n+\n+#ifdef ACCUMULATE_OUTGOING_ARGS\n+  /* Size of the stack reserved for parameter registers.  */\n+  int initial_highest_arg_in_use = highest_outgoing_arg_in_use;\n+  char *initial_stack_usage_map = stack_usage_map;\n+#endif\n+\n+#ifdef REG_PARM_STACK_SPACE\n+#ifdef MAYBE_REG_PARM_STACK_SPACE\n+  reg_parm_stack_space = MAYBE_REG_PARM_STACK_SPACE;\n+#else\n+  reg_parm_stack_space = REG_PARM_STACK_SPACE ((tree) 0);\n+#endif\n+#endif\n+\n+  VA_START (p, nargs);\n+\n+#ifndef ANSI_PROTOTYPES\n+  orgfun = va_arg (p, rtx);\n+  value = va_arg (p, rtx);\n+  no_queue = va_arg (p, int);\n+  outmode = va_arg (p, enum machine_mode);\n+  nargs = va_arg (p, int);\n+#endif\n+\n+  is_const = no_queue;\n+  fun = orgfun;\n+\n+  nothrow = libfunc_nothrow (fun);\n+\n+#ifdef PREFERRED_STACK_BOUNDARY\n+  /* Ensure current function's preferred stack boundary is at least\n+     what we need.  */\n+  if (cfun->preferred_stack_boundary < PREFERRED_STACK_BOUNDARY)\n+    cfun->preferred_stack_boundary = PREFERRED_STACK_BOUNDARY;\n+#endif\n+\n+  /* If this kind of value comes back in memory,\n+     decide where in memory it should come back.  */\n+  if (aggregate_value_p (type_for_mode (outmode, 0)))\n+    {\n+#ifdef PCC_STATIC_STRUCT_RETURN\n+      rtx pointer_reg\n+\t= hard_function_value (build_pointer_type (type_for_mode (outmode, 0)),\n+\t\t\t       0, 0);\n+      mem_value = gen_rtx_MEM (outmode, pointer_reg);\n+      pcc_struct_value = 1;\n+      if (value == 0)\n+\tvalue = gen_reg_rtx (outmode);\n+#else /* not PCC_STATIC_STRUCT_RETURN */\n+      struct_value_size = GET_MODE_SIZE (outmode);\n+      if (value != 0 && GET_CODE (value) == MEM)\n+\tmem_value = value;\n+      else\n+\tmem_value = assign_stack_temp (outmode, GET_MODE_SIZE (outmode), 0);\n+#endif\n+\n+      /* This call returns a big structure.  */\n+      is_const = 0;\n+    }\n+\n+  /* ??? Unfinished: must pass the memory address as an argument.  */\n+\n+  /* Copy all the libcall-arguments out of the varargs data\n+     and into a vector ARGVEC.\n+\n+     Compute how to pass each argument.  We only support a very small subset\n+     of the full argument passing conventions to limit complexity here since\n+     library functions shouldn't have many args.  */\n+\n+  argvec = (struct arg *) alloca ((nargs + 1) * sizeof (struct arg));\n+  bzero ((char *) argvec, (nargs + 1) * sizeof (struct arg));\n+\n+  INIT_CUMULATIVE_ARGS (args_so_far, NULL_TREE, fun, 0);\n+\n+  args_size.constant = 0;\n+  args_size.var = 0;\n+\n+  count = 0;\n+\n+  push_temp_slots ();\n+\n+  /* If there's a structure value address to be passed,\n+     either pass it in the special place, or pass it as an extra argument.  */\n+  if (mem_value && struct_value_rtx == 0 && ! pcc_struct_value)\n+    {\n+      rtx addr = XEXP (mem_value, 0);\n+      nargs++;\n+\n+      /* Make sure it is a reasonable operand for a move or push insn.  */\n+      if (GET_CODE (addr) != REG && GET_CODE (addr) != MEM\n+\t  && ! (CONSTANT_P (addr) && LEGITIMATE_CONSTANT_P (addr)))\n+\taddr = force_operand (addr, NULL_RTX);\n+\n+      argvec[count].value = addr;\n+      argvec[count].mode = Pmode;\n+      argvec[count].partial = 0;\n+\n+      argvec[count].reg = FUNCTION_ARG (args_so_far, Pmode, NULL_TREE, 1);\n+#ifdef FUNCTION_ARG_PARTIAL_NREGS\n+      if (FUNCTION_ARG_PARTIAL_NREGS (args_so_far, Pmode, NULL_TREE, 1))\n+\tabort ();\n+#endif\n+\n+      locate_and_pad_parm (Pmode, NULL_TREE,\n+\t\t\t   argvec[count].reg && argvec[count].partial == 0,\n+\t\t\t   NULL_TREE, &args_size, &argvec[count].offset,\n+\t\t\t   &argvec[count].size, &alignment_pad);\n+\n+\n+      if (argvec[count].reg == 0 || argvec[count].partial != 0\n+\t  || reg_parm_stack_space > 0)\n+\targs_size.constant += argvec[count].size.constant;\n+\n+      FUNCTION_ARG_ADVANCE (args_so_far, Pmode, (tree) 0, 1);\n+\n+      count++;\n+    }\n+\n+  for (; count < nargs; count++)\n+    {\n+      rtx val = va_arg (p, rtx);\n+      enum machine_mode mode = va_arg (p, enum machine_mode);\n+\n+      /* We cannot convert the arg value to the mode the library wants here;\n+\t must do it earlier where we know the signedness of the arg.  */\n+      if (mode == BLKmode\n+\t  || (GET_MODE (val) != mode && GET_MODE (val) != VOIDmode))\n+\tabort ();\n+\n+      /* On some machines, there's no way to pass a float to a library fcn.\n+\t Pass it as a double instead.  */\n+#ifdef LIBGCC_NEEDS_DOUBLE\n+      if (LIBGCC_NEEDS_DOUBLE && mode == SFmode)\n+\tval = convert_modes (DFmode, SFmode, val, 0), mode = DFmode;\n+#endif\n+\n+      /* There's no need to call protect_from_queue, because\n+\t either emit_move_insn or emit_push_insn will do that.  */\n+\n+      /* Make sure it is a reasonable operand for a move or push insn.  */\n+      if (GET_CODE (val) != REG && GET_CODE (val) != MEM\n+\t  && ! (CONSTANT_P (val) && LEGITIMATE_CONSTANT_P (val)))\n+\tval = force_operand (val, NULL_RTX);\n+\n+#ifdef FUNCTION_ARG_PASS_BY_REFERENCE\n+      if (FUNCTION_ARG_PASS_BY_REFERENCE (args_so_far, mode, NULL_TREE, 1))\n+\t{\n+\t  /* We do not support FUNCTION_ARG_CALLEE_COPIES here since it can\n+\t     be viewed as just an efficiency improvement.  */\n+\t  rtx slot = assign_stack_temp (mode, GET_MODE_SIZE (mode), 0);\n+\t  emit_move_insn (slot, val);\n+\t  val = XEXP (slot, 0);\n+\t  mode = Pmode;\n+\t}\n+#endif\n+\n+      argvec[count].value = val;\n+      argvec[count].mode = mode;\n+\n+      argvec[count].reg = FUNCTION_ARG (args_so_far, mode, NULL_TREE, 1);\n+\n+#ifdef FUNCTION_ARG_PARTIAL_NREGS\n+      argvec[count].partial\n+\t= FUNCTION_ARG_PARTIAL_NREGS (args_so_far, mode, NULL_TREE, 1);\n+#else\n+      argvec[count].partial = 0;\n+#endif\n+\n+      locate_and_pad_parm (mode, NULL_TREE,\n+\t\t\t   argvec[count].reg && argvec[count].partial == 0,\n+\t\t\t   NULL_TREE, &args_size, &argvec[count].offset,\n+\t\t\t   &argvec[count].size, &alignment_pad);\n+\n+      if (argvec[count].size.var)\n+\tabort ();\n+\n+      if (reg_parm_stack_space == 0 && argvec[count].partial)\n+\targvec[count].size.constant -= argvec[count].partial * UNITS_PER_WORD;\n+\n+      if (argvec[count].reg == 0 || argvec[count].partial != 0\n+\t  || reg_parm_stack_space > 0)\n+\targs_size.constant += argvec[count].size.constant;\n+\n+      FUNCTION_ARG_ADVANCE (args_so_far, mode, (tree) 0, 1);\n+    }\n+  va_end (p);\n+\n+#ifdef FINAL_REG_PARM_STACK_SPACE\n+  reg_parm_stack_space = FINAL_REG_PARM_STACK_SPACE (args_size.constant,\n+\t\t\t\t\t\t     args_size.var);\n+#endif\n+  /* If this machine requires an external definition for library\n+     functions, write one out.  */\n+  assemble_external_libcall (fun);\n+\n+  original_args_size = args_size;\n+#ifdef PREFERRED_STACK_BOUNDARY\n+  args_size.constant = (((args_size.constant + (STACK_BYTES - 1))\n+\t\t\t / STACK_BYTES) * STACK_BYTES);\n+#endif\n+\n+  args_size.constant = MAX (args_size.constant,\n+\t\t\t    reg_parm_stack_space);\n+\n+#ifndef OUTGOING_REG_PARM_STACK_SPACE\n+  args_size.constant -= reg_parm_stack_space;\n+#endif\n+\n+  if (args_size.constant > current_function_outgoing_args_size)\n+    current_function_outgoing_args_size = args_size.constant;\n+\n+#ifdef ACCUMULATE_OUTGOING_ARGS\n+  /* Since the stack pointer will never be pushed, it is possible for\n+     the evaluation of a parm to clobber something we have already\n+     written to the stack.  Since most function calls on RISC machines\n+     do not use the stack, this is uncommon, but must work correctly.\n+\n+     Therefore, we save any area of the stack that was already written\n+     and that we are using.  Here we set up to do this by making a new\n+     stack usage map from the old one.\n+\n+     Another approach might be to try to reorder the argument\n+     evaluations to avoid this conflicting stack usage.  */\n+\n+  needed = args_size.constant;\n+\n+#ifndef OUTGOING_REG_PARM_STACK_SPACE\n+  /* Since we will be writing into the entire argument area, the\n+     map must be allocated for its entire size, not just the part that\n+     is the responsibility of the caller.  */\n+  needed += reg_parm_stack_space;\n+#endif\n+\n+#ifdef ARGS_GROW_DOWNWARD\n+  highest_outgoing_arg_in_use = MAX (initial_highest_arg_in_use,\n+\t\t\t\t     needed + 1);\n+#else\n+  highest_outgoing_arg_in_use = MAX (initial_highest_arg_in_use,\n+\t\t\t\t     needed);\n+#endif\n+  stack_usage_map = (char *) alloca (highest_outgoing_arg_in_use);\n+\n+  if (initial_highest_arg_in_use)\n+    bcopy (initial_stack_usage_map, stack_usage_map,\n+\t   initial_highest_arg_in_use);\n+\n+  if (initial_highest_arg_in_use != highest_outgoing_arg_in_use)\n+    bzero (&stack_usage_map[initial_highest_arg_in_use],\n+\t   highest_outgoing_arg_in_use - initial_highest_arg_in_use);\n+  needed = 0;\n+\n+  /* The address of the outgoing argument list must not be copied to a\n+     register here, because argblock would be left pointing to the\n+     wrong place after the call to allocate_dynamic_stack_space below.\n+     */\n+\n+  argblock = virtual_outgoing_args_rtx;\n+#else /* not ACCUMULATE_OUTGOING_ARGS */\n+#ifndef PUSH_ROUNDING\n+  argblock = push_block (GEN_INT (args_size.constant), 0, 0);\n+#endif\n+#endif\n+\n+#ifdef PUSH_ARGS_REVERSED\n+#ifdef PREFERRED_STACK_BOUNDARY\n+  /* If we push args individually in reverse order, perform stack alignment\n+     before the first push (the last arg).  */\n+  if (argblock == 0)\n+    anti_adjust_stack (GEN_INT (args_size.constant\n+\t\t\t\t- original_args_size.constant));\n+#endif\n+#endif\n+\n+#ifdef PUSH_ARGS_REVERSED\n+  inc = -1;\n+  argnum = nargs - 1;\n+#else\n+  inc = 1;\n+  argnum = 0;\n+#endif\n+\n+#if defined(ACCUMULATE_OUTGOING_ARGS) && defined(REG_PARM_STACK_SPACE)\n+  /* The argument list is the property of the called routine and it\n+     may clobber it.  If the fixed area has been used for previous\n+     parameters, we must save and restore it.\n+\n+     Here we compute the boundary of the that needs to be saved, if any.  */\n+\n+#ifdef ARGS_GROW_DOWNWARD\n+  for (count = 0; count < reg_parm_stack_space + 1; count++)\n+#else\n+  for (count = 0; count < reg_parm_stack_space; count++)\n+#endif\n+    {\n+      if (count >=  highest_outgoing_arg_in_use\n+\t  || stack_usage_map[count] == 0)\n+\tcontinue;\n+\n+      if (low_to_save == -1)\n+\tlow_to_save = count;\n+\n+      high_to_save = count;\n+    }\n+\n+  if (low_to_save >= 0)\n+    {\n+      int num_to_save = high_to_save - low_to_save + 1;\n+      enum machine_mode save_mode\n+\t= mode_for_size (num_to_save * BITS_PER_UNIT, MODE_INT, 1);\n+      rtx stack_area;\n+\n+      /* If we don't have the required alignment, must do this in BLKmode.  */\n+      if ((low_to_save & (MIN (GET_MODE_SIZE (save_mode),\n+\t\t\t       BIGGEST_ALIGNMENT / UNITS_PER_WORD) - 1)))\n+\tsave_mode = BLKmode;\n+\n+#ifdef ARGS_GROW_DOWNWARD\n+      stack_area = gen_rtx_MEM (save_mode,\n+\t\t\t\tmemory_address (save_mode,\n+\t\t\t\t\t\tplus_constant (argblock,\n+\t\t\t\t\t\t\t       - high_to_save)));\n+#else\n+      stack_area = gen_rtx_MEM (save_mode,\n+\t\t\t\tmemory_address (save_mode,\n+\t\t\t\t\t\tplus_constant (argblock,\n+\t\t\t\t\t\t\t       low_to_save)));\n+#endif\n+      if (save_mode == BLKmode)\n+\t{\n+\t  save_area = assign_stack_temp (BLKmode, num_to_save, 0);\n+\t  emit_block_move (validize_mem (save_area), stack_area,\n+\t\t\t   GEN_INT (num_to_save),\n+\t\t\t   PARM_BOUNDARY / BITS_PER_UNIT);\n+\t}\n+      else\n+\t{\n+\t  save_area = gen_reg_rtx (save_mode);\n+\t  emit_move_insn (save_area, stack_area);\n+\t}\n+    }\n+#endif\n+\t  \n+  /* Push the args that need to be pushed.  */\n+\n+  /* ARGNUM indexes the ARGVEC array in the order in which the arguments\n+     are to be pushed.  */\n+  for (count = 0; count < nargs; count++, argnum += inc)\n+    {\n+      register enum machine_mode mode = argvec[argnum].mode;\n+      register rtx val = argvec[argnum].value;\n+      rtx reg = argvec[argnum].reg;\n+      int partial = argvec[argnum].partial;\n+#ifdef ACCUMULATE_OUTGOING_ARGS\n+      int lower_bound, upper_bound, i;\n+#endif\n+\n+      if (! (reg != 0 && partial == 0))\n+\t{\n+#ifdef ACCUMULATE_OUTGOING_ARGS\n+\t  /* If this is being stored into a pre-allocated, fixed-size, stack\n+\t     area, save any previous data at that location.  */\n+\n+#ifdef ARGS_GROW_DOWNWARD\n+\t  /* stack_slot is negative, but we want to index stack_usage_map\n+\t     with positive values.  */\n+\t  upper_bound = -argvec[argnum].offset.constant + 1;\n+\t  lower_bound = upper_bound - argvec[argnum].size.constant;\n+#else\n+\t  lower_bound = argvec[argnum].offset.constant;\n+\t  upper_bound = lower_bound + argvec[argnum].size.constant;\n+#endif\n+\n+\t  for (i = lower_bound; i < upper_bound; i++)\n+\t    if (stack_usage_map[i]\n+\t\t/* Don't store things in the fixed argument area at this point;\n+\t\t   it has already been saved.  */\n+\t\t&& i > reg_parm_stack_space)\n+\t      break;\n+\n+\t  if (i != upper_bound)\n+\t    {\n+\t      /* We need to make a save area.  See what mode we can make it. */\n+\t      enum machine_mode save_mode\n+\t\t= mode_for_size (argvec[argnum].size.constant * BITS_PER_UNIT,\n+\t\t\t\t MODE_INT, 1);\n+\t      rtx stack_area\n+\t\t= gen_rtx_MEM\n+\t\t  (save_mode,\n+\t\t   memory_address\n+\t\t   (save_mode,\n+\t\t    plus_constant (argblock,\n+\t\t\t\t   argvec[argnum].offset.constant)));\n+\t      argvec[argnum].save_area = gen_reg_rtx (save_mode);\n+\n+\t      emit_move_insn (argvec[argnum].save_area, stack_area);\n+\t    }\n+#endif\n+\t  emit_push_insn (val, mode, NULL_TREE, NULL_RTX, 0, partial, reg, 0,\n+\t\t\t  argblock, GEN_INT (argvec[argnum].offset.constant),\n+\t\t\t  reg_parm_stack_space, ARGS_SIZE_RTX (alignment_pad));\n+\n+#ifdef ACCUMULATE_OUTGOING_ARGS\n+\t  /* Now mark the segment we just used.  */\n+\t  for (i = lower_bound; i < upper_bound; i++)\n+\t    stack_usage_map[i] = 1;\n+#endif\n+\n+\t  NO_DEFER_POP;\n+\t}\n+    }\n+\n+#ifndef PUSH_ARGS_REVERSED\n+#ifdef PREFERRED_STACK_BOUNDARY\n+  /* If we pushed args in forward order, perform stack alignment\n+     after pushing the last arg.  */\n+  if (argblock == 0)\n+    anti_adjust_stack (GEN_INT (args_size.constant\n+\t\t\t\t- original_args_size.constant));\n+#endif\n+#endif\n+\n+#ifdef PUSH_ARGS_REVERSED\n+  argnum = nargs - 1;\n+#else\n+  argnum = 0;\n+#endif\n+\n+  fun = prepare_call_address (fun, NULL_TREE, &call_fusage, 0);\n+\n+  /* Now load any reg parms into their regs.  */\n+\n+  /* ARGNUM indexes the ARGVEC array in the order in which the arguments\n+     are to be pushed.  */\n+  for (count = 0; count < nargs; count++, argnum += inc)\n+    {\n+      register rtx val = argvec[argnum].value;\n+      rtx reg = argvec[argnum].reg;\n+      int partial = argvec[argnum].partial;\n+\n+      /* Handle calls that pass values in multiple non-contiguous\n+\t locations.  The PA64 has examples of this for library calls.  */\n+      if (reg != 0 && GET_CODE (reg) == PARALLEL)\n+\temit_group_load (reg, val,\n+\t\t\t GET_MODE_SIZE (GET_MODE (val)),\n+\t\t\t GET_MODE_ALIGNMENT (GET_MODE (val)));\n+      else if (reg != 0 && partial == 0)\n+\temit_move_insn (reg, val);\n+\n+      NO_DEFER_POP;\n+    }\n+\n+#if 0\n+  /* For version 1.37, try deleting this entirely.  */\n+  if (! no_queue)\n+    emit_queue ();\n+#endif\n+\n+  /* Any regs containing parms remain in use through the call.  */\n+  for (count = 0; count < nargs; count++)\n+    {\n+      rtx reg = argvec[count].reg;\n+      if (reg != 0 && GET_CODE (reg) == PARALLEL)\n+\tuse_group_regs (&call_fusage, reg);\n+      else if (reg != 0)\n+\tuse_reg (&call_fusage, reg);\n+    }\n+\n+  /* Pass the function the address in which to return a structure value.  */\n+  if (mem_value != 0 && struct_value_rtx != 0 && ! pcc_struct_value)\n+    {\n+      emit_move_insn (struct_value_rtx,\n+\t\t      force_reg (Pmode,\n+\t\t\t\t force_operand (XEXP (mem_value, 0),\n+\t\t\t\t\t\tNULL_RTX)));\n+      if (GET_CODE (struct_value_rtx) == REG)\n+\t  use_reg (&call_fusage, struct_value_rtx);\n+    }\n+\n+  /* Don't allow popping to be deferred, since then\n+     cse'ing of library calls could delete a call and leave the pop.  */\n+  NO_DEFER_POP;\n+\n+  /* We pass the old value of inhibit_defer_pop + 1 to emit_call_1, which\n+     will set inhibit_defer_pop to that value.  */\n+  /* See the comment in emit_library_call about the function type we build\n+     and pass here.  */\n+\n+  emit_call_1 (fun, \n+               get_identifier (XSTR (orgfun, 0)),\n+\t       build_function_type (type_for_mode (outmode, 0), NULL_TREE),\n+               original_args_size.constant, args_size.constant,\n+\t       struct_value_size,\n+\t       FUNCTION_ARG (args_so_far, VOIDmode, void_type_node, 1),\n+\t       mem_value == 0 ? hard_libcall_value (outmode) : NULL_RTX,\n+\t       old_inhibit_defer_pop + 1, call_fusage, is_const, nothrow);\n+\n+  /* Now restore inhibit_defer_pop to its actual original value.  */\n+  OK_DEFER_POP;\n+\n+  pop_temp_slots ();\n+\n+  /* Copy the value to the right place.  */\n+  if (outmode != VOIDmode)\n+    {\n+      if (mem_value)\n+\t{\n+\t  if (value == 0)\n+\t    value = mem_value;\n+\t  if (value != mem_value)\n+\t    emit_move_insn (value, mem_value);\n+\t}\n+      else if (value != 0)\n+\temit_move_insn (value, hard_libcall_value (outmode));\n+      else\n+\tvalue = hard_libcall_value (outmode);\n+    }\n+\n+#ifdef ACCUMULATE_OUTGOING_ARGS\n+#ifdef REG_PARM_STACK_SPACE\n+  if (save_area)\n+    {\n+      enum machine_mode save_mode = GET_MODE (save_area);\n+#ifdef ARGS_GROW_DOWNWARD\n+      rtx stack_area\n+\t= gen_rtx_MEM (save_mode,\n+\t\t       memory_address (save_mode,\n+\t\t\t\t       plus_constant (argblock,\n+\t\t\t\t\t\t      - high_to_save)));\n+#else\n+      rtx stack_area\n+\t= gen_rtx_MEM (save_mode,\n+\t\t       memory_address (save_mode,\n+\t\t\t\t       plus_constant (argblock, low_to_save)));\n+#endif\n+      if (save_mode != BLKmode)\n+\temit_move_insn (stack_area, save_area);\n+      else\n+\temit_block_move (stack_area, validize_mem (save_area),\n+\t\t\t GEN_INT (high_to_save - low_to_save + 1),\n+\t\t\t     PARM_BOUNDARY / BITS_PER_UNIT);\n+    }\n+#endif\n+\t  \n+  /* If we saved any argument areas, restore them.  */\n+  for (count = 0; count < nargs; count++)\n+    if (argvec[count].save_area)\n+      {\n+\tenum machine_mode save_mode = GET_MODE (argvec[count].save_area);\n+\trtx stack_area\n+\t  = gen_rtx_MEM (save_mode,\n+\t\t\t memory_address\n+\t\t\t (save_mode,\n+\t\t\t  plus_constant (argblock,\n+\t\t\t\t\t argvec[count].offset.constant)));\n+\n+\temit_move_insn (stack_area, argvec[count].save_area);\n+      }\n+\n+  highest_outgoing_arg_in_use = initial_highest_arg_in_use;\n+  stack_usage_map = initial_stack_usage_map;\n+#endif\n \n   return value;\n }"}]}