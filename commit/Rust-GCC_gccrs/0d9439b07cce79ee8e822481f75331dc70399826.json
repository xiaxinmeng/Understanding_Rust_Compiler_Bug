{"sha": "0d9439b07cce79ee8e822481f75331dc70399826", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGQ5NDM5YjA3Y2NlNzllZThlODIyNDgxZjc1MzMxZGM3MDM5OTgyNg==", "commit": {"author": {"name": "Sergey Grechanik", "email": "mouseentity@ispras.ru", "date": "2011-08-11T11:50:27Z"}, "committer": {"name": "Alexander Monakov", "email": "amonakov@gcc.gnu.org", "date": "2011-08-11T11:50:27Z"}, "message": "sel-sched-ir.c (get_seqno_of_a_pred): Rename to get_seqno_for_a_jump.\n\n2011-08-11  Sergey Grechanik  <mouseentity@ispras.ru>\n\n\t* sel-sched-ir.c (get_seqno_of_a_pred): Rename to\n\tget_seqno_for_a_jump.  Update the caller.\n\t(get_seqno_by_succs): New.  Use it ...\n\t(get_seqno_for_a_jump): ... here to find a seqno if looking at\n\tpredecessors was not sufficient.\n\t(get_seqno_by_preds): Include head in iteration range, exclude insn.\n\nFrom-SVN: r177656", "tree": {"sha": "cbe8ad3a6a9c34b18d7bef9e1bef3a4bef007976", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cbe8ad3a6a9c34b18d7bef9e1bef3a4bef007976"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d9439b07cce79ee8e822481f75331dc70399826", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d9439b07cce79ee8e822481f75331dc70399826", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d9439b07cce79ee8e822481f75331dc70399826", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d9439b07cce79ee8e822481f75331dc70399826/comments", "author": null, "committer": null, "parents": [{"sha": "5c416724e03238da11ea0d37e029ccd25824fa18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c416724e03238da11ea0d37e029ccd25824fa18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c416724e03238da11ea0d37e029ccd25824fa18"}], "stats": {"total": 66, "additions": 58, "deletions": 8}, "files": [{"sha": "50c9378b491f7f2b492ff281194f5498e378b61f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d9439b07cce79ee8e822481f75331dc70399826/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d9439b07cce79ee8e822481f75331dc70399826/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0d9439b07cce79ee8e822481f75331dc70399826", "patch": "@@ -1,3 +1,12 @@\n+2011-08-11  Sergey Grechanik  <mouseentity@ispras.ru>\n+\n+\t* sel-sched-ir.c (get_seqno_of_a_pred): Rename to\n+\tget_seqno_for_a_jump.  Update the caller.\n+\t(get_seqno_by_succs): New.  Use it ...\n+\t(get_seqno_for_a_jump): ... here to find a seqno if looking at\n+\tpredecessors was not sufficient.\n+\t(get_seqno_by_preds): Include head in iteration range, exclude insn.\n+\n 2011-08-11  Dmitry Melnik  <dm@ispras.ru>\n \n \t* sel-sched-ir.c (invalidate_av_set): Remove the assert."}, {"sha": "c7e365a9904b151cb68a99b7dd92faab09a43ffc", "filename": "gcc/sel-sched-ir.c", "status": "modified", "additions": 49, "deletions": 8, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d9439b07cce79ee8e822481f75331dc70399826/gcc%2Fsel-sched-ir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d9439b07cce79ee8e822481f75331dc70399826/gcc%2Fsel-sched-ir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.c?ref=0d9439b07cce79ee8e822481f75331dc70399826", "patch": "@@ -3940,9 +3940,39 @@ sel_luid_for_non_insn (rtx x)\n   return -1;\n }\n \n-/* Return seqno of the only predecessor of INSN.  */\n+/*  Find the proper seqno for inserting at INSN by successors.\n+    Return -1 if no successors with positive seqno exist.  */\n static int\n-get_seqno_of_a_pred (insn_t insn)\n+get_seqno_by_succs (rtx insn)\n+{\n+  basic_block bb = BLOCK_FOR_INSN (insn);\n+  rtx tmp = insn, end = BB_END (bb);\n+  int seqno;\n+  insn_t succ = NULL;\n+  succ_iterator si;\n+\n+  while (tmp != end)\n+    {\n+      tmp = NEXT_INSN (tmp);\n+      if (INSN_P (tmp))\n+        return INSN_SEQNO (tmp);\n+    }\n+\n+  seqno = INT_MAX;\n+\n+  FOR_EACH_SUCC_1 (succ, si, end, SUCCS_NORMAL)\n+    if (INSN_SEQNO (succ) > 0)\n+      seqno = MIN (seqno, INSN_SEQNO (succ));\n+\n+  if (seqno == INT_MAX)\n+    return -1;\n+\n+  return seqno;\n+}\n+\n+/* Compute seqno for INSN by its preds or succs.  */\n+static int\n+get_seqno_for_a_jump (insn_t insn)\n {\n   int seqno;\n \n@@ -3982,14 +4012,24 @@ get_seqno_of_a_pred (insn_t insn)\n \t  int n;\n \n \t  cfg_preds (BLOCK_FOR_INSN (insn), &preds, &n);\n-\t  gcc_assert (n == 1);\n \n-\t  seqno = INSN_SEQNO (preds[0]);\n+\t  gcc_assert (n > 0);\n+\t  /* For one predecessor, use simple method.  */\n+\t  if (n == 1)\n+\t    seqno = INSN_SEQNO (preds[0]);\n+\t  else\n+\t    seqno = get_seqno_by_preds (insn);\n \n \t  free (preds);\n \t}\n     }\n \n+  /* We were unable to find a good seqno among preds.  */\n+  if (seqno < 0)\n+    seqno = get_seqno_by_succs (insn);\n+\n+  gcc_assert (seqno >= 0);\n+\n   return seqno;\n }\n \n@@ -4004,10 +4044,11 @@ get_seqno_by_preds (rtx insn)\n   int n, i, seqno;\n \n   while (tmp != head)\n-    if (INSN_P (tmp))\n-      return INSN_SEQNO (tmp);\n-    else\n+    {\n       tmp = PREV_INSN (tmp);\n+      if (INSN_P (tmp))\n+        return INSN_SEQNO (tmp);\n+    }\n \n   cfg_preds (bb, &preds, &n);\n   for (i = 0, seqno = -1; i < n; i++)\n@@ -4179,7 +4220,7 @@ init_simplejump_data (insn_t insn)\n   init_expr (INSN_EXPR (insn), vinsn_create (insn, false), 0,\n \t     REG_BR_PROB_BASE, 0, 0, 0, 0, 0, 0, NULL, true, false, false,\n \t     false, true);\n-  INSN_SEQNO (insn) = get_seqno_of_a_pred (insn);\n+  INSN_SEQNO (insn) = get_seqno_for_a_jump (insn);\n   init_first_time_insn_data (insn);\n }\n "}]}