{"sha": "d0c9ca44614f088e42a3305551a5f87adc4607af", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDBjOWNhNDQ2MTRmMDg4ZTQyYTMzMDU1NTFhNWY4N2FkYzQ2MDdhZg==", "commit": {"author": {"name": "Tom de Vries", "email": "tom@codesourcery.com", "date": "2015-10-31T08:08:39Z"}, "committer": {"name": "Tom de Vries", "email": "vries@gcc.gnu.org", "date": "2015-10-31T08:08:39Z"}, "message": "Add initial constraints in create_function_info_for\n\n2015-10-31  Tom de Vries  <tom@codesourcery.com>\n\n\t* tree-ssa-structalias.c (ipa_pta_execute): Add extra arg to call to\n\tcreate_function_info_for.  Dump constraints generated during\n\tcreate_function_info_for. Move intra_create_variable_infos call and\n\tfunction-return-values-escape bit to ...\n\t(create_function_info_for): ... here, and merge\n\tintra_create_variable_infos call with argument loop.  Add and handle\n\tnonlocal_p parameter.\n\nFrom-SVN: r229619", "tree": {"sha": "b8884a8e49bfab4834e4fe6c84968a8fb6c38691", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b8884a8e49bfab4834e4fe6c84968a8fb6c38691"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d0c9ca44614f088e42a3305551a5f87adc4607af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0c9ca44614f088e42a3305551a5f87adc4607af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0c9ca44614f088e42a3305551a5f87adc4607af", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0c9ca44614f088e42a3305551a5f87adc4607af/comments", "author": null, "committer": null, "parents": [{"sha": "2ce4413c7ffa8e528658b658573c2a41ce625d99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ce4413c7ffa8e528658b658573c2a41ce625d99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ce4413c7ffa8e528658b658573c2a41ce625d99"}], "stats": {"total": 91, "additions": 65, "deletions": 26}, "files": [{"sha": "c4d833bbb5126b902541a0f3b040a8c0c2496a5f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0c9ca44614f088e42a3305551a5f87adc4607af/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0c9ca44614f088e42a3305551a5f87adc4607af/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d0c9ca44614f088e42a3305551a5f87adc4607af", "patch": "@@ -1,3 +1,13 @@\n+2015-10-31  Tom de Vries  <tom@codesourcery.com>\n+\n+\t* tree-ssa-structalias.c (ipa_pta_execute): Add extra arg to call to\n+\tcreate_function_info_for.  Dump constraints generated during\n+\tcreate_function_info_for. Move intra_create_variable_infos call and\n+\tfunction-return-values-escape bit to ...\n+\t(create_function_info_for): ... here, and merge\n+\tintra_create_variable_infos call with argument loop.  Add and handle\n+\tnonlocal_p parameter.\n+\n 2015-10-31  Tom de Vries  <tom@codesourcery.com>\n \n \t* tree-ssa-structalias.c (create_function_info_for): Make sure prev_vi"}, {"sha": "7b6553cd99fbeb87b9facee581c1406b8b65dc5e", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 55, "deletions": 26, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0c9ca44614f088e42a3305551a5f87adc4607af/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0c9ca44614f088e42a3305551a5f87adc4607af/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=d0c9ca44614f088e42a3305551a5f87adc4607af", "patch": "@@ -5409,10 +5409,12 @@ count_num_arguments (tree decl, bool *is_varargs)\n }\n \n /* Creation function node for DECL, using NAME, and return the index\n-   of the variable we've created for the function.  */\n+   of the variable we've created for the function.  If NONLOCAL_p, create\n+   initial constraints.  */\n \n static varinfo_t\n-create_function_info_for (tree decl, const char *name, bool add_id)\n+create_function_info_for (tree decl, const char *name, bool add_id,\n+\t\t\t  bool nonlocal_p)\n {\n   struct function *fn = DECL_STRUCT_FUNCTION (decl);\n   varinfo_t vi, prev_vi;\n@@ -5493,6 +5495,10 @@ create_function_info_for (tree decl, const char *name, bool add_id)\n \n       insert_vi_for_tree (fn->static_chain_decl, chainvi);\n \n+      if (nonlocal_p\n+\t  && chainvi->may_have_pointers)\n+\tmake_constraint_from (chainvi, nonlocal_id);\n+\n       gcc_assert (prev_vi->offset < chainvi->offset);\n       prev_vi->next = chainvi->id;\n       prev_vi = chainvi;\n@@ -5530,6 +5536,18 @@ create_function_info_for (tree decl, const char *name, bool add_id)\n       prev_vi = resultvi;\n     }\n \n+  /* We also need to make function return values escape.  Nothing\n+     escapes by returning from main though.  */\n+  if (nonlocal_p\n+      && !MAIN_NAME_P (DECL_NAME (decl)))\n+    {\n+      varinfo_t fi, rvi;\n+      fi = lookup_vi_for_tree (decl);\n+      rvi = first_vi_for_offset (fi, fi_result);\n+      if (rvi && rvi->offset == fi_result)\n+\tmake_copy_constraint (get_varinfo (escaped_id), rvi->id);\n+    }\n+\n   /* Set up variables for each argument.  */\n   arg = DECL_ARGUMENTS (decl);\n   for (i = 0; i < num_args; i++)\n@@ -5557,6 +5575,10 @@ create_function_info_for (tree decl, const char *name, bool add_id)\n       if (arg)\n \tinsert_vi_for_tree (arg, argvi);\n \n+      if (nonlocal_p\n+\t  && argvi->may_have_pointers)\n+\tmake_constraint_from (argvi, nonlocal_id);\n+\n       gcc_assert (prev_vi->offset < argvi->offset);\n       prev_vi->next = argvi->id;\n       prev_vi = argvi;\n@@ -5586,6 +5608,10 @@ create_function_info_for (tree decl, const char *name, bool add_id)\n       argvi->is_heap_var = true;\n       argvi->fullsize = vi->fullsize;\n \n+      if (nonlocal_p\n+\t  && argvi->may_have_pointers)\n+\tmake_constraint_from (argvi, nonlocal_id);\n+\n       gcc_assert (prev_vi->offset < argvi->offset);\n       prev_vi->next = argvi->id;\n       prev_vi = argvi;\n@@ -7312,8 +7338,34 @@ ipa_pta_execute (void)\n \n       gcc_assert (!node->clone_of);\n \n+      /* For externally visible or attribute used annotated functions use\n+\t local constraints for their arguments.\n+\t For local functions we see all callers and thus do not need initial\n+\t constraints for parameters.  */\n+      bool nonlocal_p = (node->used_from_other_partition\n+\t\t\t || node->externally_visible\n+\t\t\t || node->force_output\n+\t\t\t || node->address_taken);\n+\n       vi = create_function_info_for (node->decl,\n-\t\t\t\t     alias_get_name (node->decl), false);\n+\t\t\t\t     alias_get_name (node->decl), false,\n+\t\t\t\t     nonlocal_p);\n+      if (dump_file\n+\t  && from != constraints.length ())\n+\t{\n+\t  fprintf (dump_file,\n+\t\t   \"Generating intial constraints for %s\", node->name ());\n+\t  if (DECL_ASSEMBLER_NAME_SET_P (node->decl))\n+\t    fprintf (dump_file, \" (%s)\",\n+\t\t     IDENTIFIER_POINTER\n+\t\t       (DECL_ASSEMBLER_NAME (node->decl)));\n+\t  fprintf (dump_file, \"\\n\\n\");\n+\t  dump_constraints (dump_file, from);\n+\t  fprintf (dump_file, \"\\n\");\n+\n+\t  from = constraints.length ();\n+\t}\n+\n       node->call_for_symbol_thunks_and_aliases\n \t(associate_varinfo_to_alias, vi, true);\n     }\n@@ -7360,29 +7412,6 @@ ipa_pta_execute (void)\n       func = DECL_STRUCT_FUNCTION (node->decl);\n       gcc_assert (cfun == NULL);\n \n-      /* For externally visible or attribute used annotated functions use\n-\t local constraints for their arguments.\n-\t For local functions we see all callers and thus do not need initial\n-\t constraints for parameters.  */\n-      if (node->used_from_other_partition\n-\t  || node->externally_visible\n-\t  || node->force_output\n-\t  || node->address_taken)\n-\t{\n-\t  intra_create_variable_infos (func);\n-\n-\t  /* We also need to make function return values escape.  Nothing\n-\t     escapes by returning from main though.  */\n-\t  if (!MAIN_NAME_P (DECL_NAME (node->decl)))\n-\t    {\n-\t      varinfo_t fi, rvi;\n-\t      fi = lookup_vi_for_tree (node->decl);\n-\t      rvi = first_vi_for_offset (fi, fi_result);\n-\t      if (rvi && rvi->offset == fi_result)\n-\t\tmake_copy_constraint (get_varinfo (escaped_id), rvi->id);\n-\t    }\n-\t}\n-\n       /* Build constriants for the function body.  */\n       FOR_EACH_BB_FN (bb, func)\n \t{"}]}