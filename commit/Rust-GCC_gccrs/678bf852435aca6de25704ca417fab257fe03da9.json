{"sha": "678bf852435aca6de25704ca417fab257fe03da9", "node_id": "C_kwDOANBUbNoAKDY3OGJmODUyNDM1YWNhNmRlMjU3MDRjYTQxN2ZhYjI1N2ZlMDNkYTk", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-10-19T17:02:36Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-10-20T15:10:15Z"}, "message": "Closure support at CallExpr\n\nClosures's need to generate their specific function and setup their\nargument passing based on the signiture specified in libcore. We can get\nthis information based on the specified bound on the closure.\n\nAddresses #195", "tree": {"sha": "7eb78257e1d85eb7f2086e06867091f71a22cc34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7eb78257e1d85eb7f2086e06867091f71a22cc34"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/678bf852435aca6de25704ca417fab257fe03da9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/678bf852435aca6de25704ca417fab257fe03da9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/678bf852435aca6de25704ca417fab257fe03da9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/678bf852435aca6de25704ca417fab257fe03da9/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "feaa40602b7ecad36de8dcb6c387e686d04ce207", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/feaa40602b7ecad36de8dcb6c387e686d04ce207", "html_url": "https://github.com/Rust-GCC/gccrs/commit/feaa40602b7ecad36de8dcb6c387e686d04ce207"}], "stats": {"total": 373, "additions": 361, "deletions": 12}, "files": [{"sha": "658b9a3f595faace4978af15e2dd5fb5d3fdf19e", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/678bf852435aca6de25704ca417fab257fe03da9/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/678bf852435aca6de25704ca417fab257fe03da9/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=678bf852435aca6de25704ca417fab257fe03da9", "patch": "@@ -147,6 +147,35 @@ class Context\n     mono_fns[dId].push_back ({ref, fn});\n   }\n \n+  void insert_closure_decl (const TyTy::ClosureType *ref, tree fn)\n+  {\n+    auto dId = ref->get_def_id ();\n+    auto it = mono_closure_fns.find (dId);\n+    if (it == mono_closure_fns.end ())\n+      mono_closure_fns[dId] = {};\n+\n+    mono_closure_fns[dId].push_back ({ref, fn});\n+  }\n+\n+  tree lookup_closure_decl (const TyTy::ClosureType *ref)\n+  {\n+    auto dId = ref->get_def_id ();\n+    auto it = mono_closure_fns.find (dId);\n+    if (it == mono_closure_fns.end ())\n+      return error_mark_node;\n+\n+    for (auto &i : it->second)\n+      {\n+\tconst TyTy::ClosureType *t = i.first;\n+\ttree fn = i.second;\n+\n+\tif (ref->is_equal (*t))\n+\t  return fn;\n+      }\n+\n+    return error_mark_node;\n+  }\n+\n   bool lookup_function_decl (HirId id, tree *fn, DefId dId = UNKNOWN_DEFID,\n \t\t\t     const TyTy::BaseType *ref = nullptr,\n \t\t\t     const std::string &asm_name = std::string ())\n@@ -343,6 +372,8 @@ class Context\n   std::vector<tree> loop_begin_labels;\n   std::map<DefId, std::vector<std::pair<const TyTy::BaseType *, tree>>>\n     mono_fns;\n+  std::map<DefId, std::vector<std::pair<const TyTy::ClosureType *, tree>>>\n+    mono_closure_fns;\n   std::map<HirId, tree> implicit_pattern_bindings;\n   std::map<hashval_t, tree> main_variants;\n "}, {"sha": "738c7b10fa356c0965729755995a44f31de0dc43", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 272, "deletions": 8, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/678bf852435aca6de25704ca417fab257fe03da9/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/678bf852435aca6de25704ca417fab257fe03da9/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=678bf852435aca6de25704ca417fab257fe03da9", "patch": "@@ -1589,9 +1589,7 @@ CompileExpr::visit (HIR::CallExpr &expr)\n     }\n \n   // must be a tuple constructor\n-  bool is_fn = tyty->get_kind () == TyTy::TypeKind::FNDEF\n-\t       || tyty->get_kind () == TyTy::TypeKind::FNPTR;\n-  bool is_adt_ctor = !is_fn;\n+  bool is_adt_ctor = tyty->get_kind () == TyTy::TypeKind::ADT;\n   if (is_adt_ctor)\n     {\n       rust_assert (tyty->get_kind () == TyTy::TypeKind::ADT);\n@@ -1692,20 +1690,71 @@ CompileExpr::visit (HIR::CallExpr &expr)\n     return true;\n   };\n \n+  auto fn_address = CompileExpr::Compile (expr.get_fnexpr (), ctx);\n+\n+  // is this a closure call?\n+  if (RS_CLOSURE_TYPE_P (TREE_TYPE (fn_address)))\n+    {\n+      rust_assert (tyty->get_kind () == TyTy::TypeKind::CLOSURE);\n+      TyTy::ClosureType *closure = static_cast<TyTy::ClosureType *> (tyty);\n+\n+      std::vector<tree> tuple_arg_vals;\n+      for (auto &argument : expr.get_arguments ())\n+\t{\n+\t  auto rvalue = CompileExpr::Compile (argument.get (), ctx);\n+\t  tuple_arg_vals.push_back (rvalue);\n+\t}\n+\n+      tree tuple_args_tyty\n+\t= TyTyResolveCompile::compile (ctx, &closure->get_parameters ());\n+      tree tuple_args\n+\t= ctx->get_backend ()->constructor_expression (tuple_args_tyty, false,\n+\t\t\t\t\t\t       tuple_arg_vals, -1,\n+\t\t\t\t\t\t       expr.get_locus ());\n+\n+      // need to apply any autoderef's to the self argument\n+      HirId autoderef_mappings_id = expr.get_mappings ().get_hirid ();\n+      std::vector<Resolver::Adjustment> *adjustments = nullptr;\n+      bool ok\n+\t= ctx->get_tyctx ()->lookup_autoderef_mappings (autoderef_mappings_id,\n+\t\t\t\t\t\t\t&adjustments);\n+      rust_assert (ok);\n+\n+      // apply adjustments for the fn call\n+      tree self\n+\t= resolve_adjustements (*adjustments, fn_address, expr.get_locus ());\n+\n+      // args are always self, and the tuple of the args we are passing where\n+      // self is the path of the call-expr in this case the fn_address\n+      std::vector<tree> args;\n+      args.push_back (self);\n+      args.push_back (tuple_args);\n+\n+      // get the fn call address\n+      tree closure_call_site = ctx->lookup_closure_decl (closure);\n+      tree closure_call_address\n+\t= address_expression (closure_call_site, expr.get_locus ());\n+      translated\n+\t= ctx->get_backend ()->call_expression (closure_call_address, args,\n+\t\t\t\t\t\tnullptr /* static chain ?*/,\n+\t\t\t\t\t\texpr.get_locus ());\n+      return;\n+    }\n+\n   bool is_varadic = false;\n   if (tyty->get_kind () == TyTy::TypeKind::FNDEF)\n     {\n       const TyTy::FnType *fn = static_cast<const TyTy::FnType *> (tyty);\n       is_varadic = fn->is_varadic ();\n     }\n \n-  size_t required_num_args;\n+  size_t required_num_args = expr.get_arguments ().size ();\n   if (tyty->get_kind () == TyTy::TypeKind::FNDEF)\n     {\n       const TyTy::FnType *fn = static_cast<const TyTy::FnType *> (tyty);\n       required_num_args = fn->num_params ();\n     }\n-  else\n+  else if (tyty->get_kind () == TyTy::TypeKind::FNPTR)\n     {\n       const TyTy::FnPtr *fn = static_cast<const TyTy::FnPtr *> (tyty);\n       required_num_args = fn->num_params ();\n@@ -1746,8 +1795,7 @@ CompileExpr::visit (HIR::CallExpr &expr)\n       args.push_back (rvalue);\n     }\n \n-  // must be a call to a function\n-  auto fn_address = CompileExpr::Compile (expr.get_fnexpr (), ctx);\n+  // must be a regular call to a function\n   translated = ctx->get_backend ()->call_expression (fn_address, args, nullptr,\n \t\t\t\t\t\t     expr.get_locus ());\n }\n@@ -2801,7 +2849,223 @@ CompileExpr::visit (HIR::ArrayIndexExpr &expr)\n void\n CompileExpr::visit (HIR::ClosureExpr &expr)\n {\n-  gcc_unreachable ();\n+  TyTy::BaseType *closure_expr_ty = nullptr;\n+  if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n+\t\t\t\t       &closure_expr_ty))\n+    {\n+      rust_fatal_error (expr.get_locus (),\n+\t\t\t\"did not resolve type for this ClosureExpr\");\n+      return;\n+    }\n+  rust_assert (closure_expr_ty->get_kind () == TyTy::TypeKind::CLOSURE);\n+  TyTy::ClosureType *closure_tyty\n+    = static_cast<TyTy::ClosureType *> (closure_expr_ty);\n+  tree compiled_closure_tyty = TyTyResolveCompile::compile (ctx, closure_tyty);\n+\n+  // generate closure function\n+  generate_closure_function (expr, *closure_tyty, compiled_closure_tyty);\n+\n+  // lets ignore state capture for now we need to instantiate the struct anyway\n+  // then generate the function\n+\n+  std::vector<tree> vals;\n+  // TODO\n+  // setup argument captures based on the mode?\n+\n+  translated\n+    = ctx->get_backend ()->constructor_expression (compiled_closure_tyty, false,\n+\t\t\t\t\t\t   vals, -1, expr.get_locus ());\n+}\n+\n+tree\n+CompileExpr::generate_closure_function (HIR::ClosureExpr &expr,\n+\t\t\t\t\tTyTy::ClosureType &closure_tyty,\n+\t\t\t\t\ttree compiled_closure_tyty)\n+{\n+  TyTy::FnType *fn_tyty = nullptr;\n+  tree compiled_fn_type\n+    = generate_closure_fntype (expr, closure_tyty, compiled_closure_tyty,\n+\t\t\t       &fn_tyty);\n+  if (compiled_fn_type == error_mark_node)\n+    return error_mark_node;\n+\n+  const Resolver::CanonicalPath &parent_canonical_path\n+    = closure_tyty.get_ident ().path;\n+  Resolver::CanonicalPath path = parent_canonical_path.append (\n+    Resolver::CanonicalPath::new_seg (UNKNOWN_NODEID, \"{{closure}}\"));\n+\n+  std::string ir_symbol_name = path.get ();\n+  std::string asm_name = ctx->mangle_item (&closure_tyty, path);\n+\n+  unsigned int flags = 0;\n+  tree fndecl\n+    = ctx->get_backend ()->function (compiled_fn_type, ir_symbol_name, asm_name,\n+\t\t\t\t     flags, expr.get_locus ());\n+\n+  // insert into the context\n+  ctx->insert_function_decl (fn_tyty, fndecl);\n+  ctx->insert_closure_decl (&closure_tyty, fndecl);\n+\n+  // setup the parameters\n+  std::vector<Bvariable *> param_vars;\n+\n+  // closure self\n+  Bvariable *self_param\n+    = ctx->get_backend ()->parameter_variable (fndecl, \"$closure\",\n+\t\t\t\t\t       compiled_closure_tyty,\n+\t\t\t\t\t       expr.get_locus ());\n+  DECL_ARTIFICIAL (self_param->get_decl ()) = 1;\n+  param_vars.push_back (self_param);\n+\n+  // setup the implicit argument captures\n+  // TODO\n+\n+  // args tuple\n+  tree args_type\n+    = TyTyResolveCompile::compile (ctx, &closure_tyty.get_parameters ());\n+  Bvariable *args_param\n+    = ctx->get_backend ()->parameter_variable (fndecl, \"args\", args_type,\n+\t\t\t\t\t       expr.get_locus ());\n+  param_vars.push_back (args_param);\n+\n+  // setup the implicit mappings for the arguments. Since argument passing to\n+  // closure functions is done via passing a tuple but the closure body expects\n+  // just normal arguments this means we need to destructure them similar to\n+  // what we do in MatchExpr's. This means when we have a closure-param of a we\n+  // actually setup the destructure to take from the args tuple\n+\n+  tree args_param_expr = args_param->get_tree (expr.get_locus ());\n+  size_t i = 0;\n+  for (auto &closure_param : expr.get_params ())\n+    {\n+      tree compiled_param_var = ctx->get_backend ()->struct_field_expression (\n+\targs_param_expr, i, closure_param.get_locus ());\n+\n+      const HIR::Pattern &param_pattern = *closure_param.get_pattern ();\n+      ctx->insert_pattern_binding (\n+\tparam_pattern.get_pattern_mappings ().get_hirid (), compiled_param_var);\n+      i++;\n+    }\n+\n+  if (!ctx->get_backend ()->function_set_parameters (fndecl, param_vars))\n+    return error_mark_node;\n+\n+  // lookup locals\n+  HIR::Expr *function_body = expr.get_expr ().get ();\n+  auto body_mappings = function_body->get_mappings ();\n+  Resolver::Rib *rib = nullptr;\n+  bool ok\n+    = ctx->get_resolver ()->find_name_rib (body_mappings.get_nodeid (), &rib);\n+  rust_assert (ok);\n+\n+  std::vector<Bvariable *> locals\n+    = compile_locals_for_block (ctx, *rib, fndecl);\n+\n+  tree enclosing_scope = NULL_TREE;\n+  Location start_location = function_body->get_locus ();\n+  Location end_location = function_body->get_locus ();\n+  bool is_block_expr\n+    = function_body->get_expression_type () == HIR::Expr::ExprType::Block;\n+  if (is_block_expr)\n+    {\n+      HIR::BlockExpr *body = static_cast<HIR::BlockExpr *> (function_body);\n+      start_location = body->get_locus ();\n+      end_location = body->get_end_locus ();\n+    }\n+\n+  tree code_block = ctx->get_backend ()->block (fndecl, enclosing_scope, locals,\n+\t\t\t\t\t\tstart_location, end_location);\n+  ctx->push_block (code_block);\n+\n+  TyTy::BaseType *tyret = &closure_tyty.get_result_type ();\n+  bool function_has_return = !closure_tyty.get_result_type ().is_unit ();\n+  Bvariable *return_address = nullptr;\n+  if (function_has_return)\n+    {\n+      tree return_type = TyTyResolveCompile::compile (ctx, tyret);\n+\n+      bool address_is_taken = false;\n+      tree ret_var_stmt = NULL_TREE;\n+\n+      return_address = ctx->get_backend ()->temporary_variable (\n+\tfndecl, code_block, return_type, NULL, address_is_taken,\n+\texpr.get_locus (), &ret_var_stmt);\n+\n+      ctx->add_statement (ret_var_stmt);\n+    }\n+\n+  ctx->push_fn (fndecl, return_address);\n+\n+  if (is_block_expr)\n+    {\n+      HIR::BlockExpr *body = static_cast<HIR::BlockExpr *> (function_body);\n+      compile_function_body (ctx, fndecl, *body, true);\n+    }\n+  else\n+    {\n+      tree value = CompileExpr::Compile (function_body, ctx);\n+      tree return_expr\n+\t= ctx->get_backend ()->return_statement (fndecl, {value},\n+\t\t\t\t\t\t function_body->get_locus ());\n+      ctx->add_statement (return_expr);\n+    }\n+\n+  tree bind_tree = ctx->pop_block ();\n+\n+  gcc_assert (TREE_CODE (bind_tree) == BIND_EXPR);\n+  DECL_SAVED_TREE (fndecl) = bind_tree;\n+\n+  ctx->pop_fn ();\n+  ctx->push_function (fndecl);\n+\n+  return fndecl;\n+}\n+\n+tree\n+CompileExpr::generate_closure_fntype (HIR::ClosureExpr &expr,\n+\t\t\t\t      const TyTy::ClosureType &closure_tyty,\n+\t\t\t\t      tree compiled_closure_tyty,\n+\t\t\t\t      TyTy::FnType **fn_tyty)\n+{\n+  // grab the specified_bound\n+  rust_assert (closure_tyty.num_specified_bounds () == 1);\n+  const TyTy::TypeBoundPredicate &predicate\n+    = *closure_tyty.get_specified_bounds ().begin ();\n+\n+  // ensure the fn_once_output associated type is set\n+  closure_tyty.setup_fn_once_output ();\n+\n+  // the function signature is based on the trait bound that the closure\n+  // implements which is determined at the type resolution time\n+  //\n+  // https://github.com/rust-lang/rust/blob/7807a694c2f079fd3f395821bcc357eee8650071/library/core/src/ops/function.rs#L54-L71\n+\n+  TyTy::TypeBoundPredicateItem item = TyTy::TypeBoundPredicateItem::error ();\n+  if (predicate.get_name ().compare (\"FnOnce\") == 0)\n+    {\n+      item = predicate.lookup_associated_item (\"call_once\");\n+    }\n+  else if (predicate.get_name ().compare (\"FnMut\") == 0)\n+    {\n+      item = predicate.lookup_associated_item (\"call_mut\");\n+    }\n+  else if (predicate.get_name ().compare (\"Fn\") == 0)\n+    {\n+      item = predicate.lookup_associated_item (\"call\");\n+    }\n+  else\n+    {\n+      // FIXME error message?\n+      gcc_unreachable ();\n+      return error_mark_node;\n+    }\n+\n+  rust_assert (!item.is_error ());\n+\n+  TyTy::BaseType *item_tyty = item.get_tyty_for_receiver (&closure_tyty);\n+  rust_assert (item_tyty->get_kind () == TyTy::TypeKind::FNDEF);\n+  *fn_tyty = static_cast<TyTy::FnType *> (item_tyty);\n+  return TyTyResolveCompile::compile (ctx, item_tyty);\n }\n \n } // namespace Compile"}, {"sha": "6938c9362404a6fd71718fe9aeed13f6cc21dab0", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/678bf852435aca6de25704ca417fab257fe03da9/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/678bf852435aca6de25704ca417fab257fe03da9/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=678bf852435aca6de25704ca417fab257fe03da9", "patch": "@@ -142,6 +142,16 @@ class CompileExpr : private HIRCompileBase, protected HIR::HIRExpressionVisitor\n \t\t\t  const TyTy::ArrayType &array_tyty, tree array_type,\n \t\t\t  HIR::ArrayElemsCopied &elems);\n \n+protected:\n+  tree generate_closure_function (HIR::ClosureExpr &expr,\n+\t\t\t\t  TyTy::ClosureType &closure_tyty,\n+\t\t\t\t  tree compiled_closure_tyty);\n+\n+  tree generate_closure_fntype (HIR::ClosureExpr &expr,\n+\t\t\t\tconst TyTy::ClosureType &closure_tyty,\n+\t\t\t\ttree compiled_closure_tyty,\n+\t\t\t\tTyTy::FnType **fn_tyty);\n+\n private:\n   CompileExpr (Context *ctx);\n "}, {"sha": "5e56e0a0b5d15b896165dd0dd7b7b2c128bfd212", "filename": "gcc/rust/backend/rust-compile-type.cc", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/678bf852435aca6de25704ca417fab257fe03da9/gcc%2Frust%2Fbackend%2Frust-compile-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/678bf852435aca6de25704ca417fab257fe03da9/gcc%2Frust%2Fbackend%2Frust-compile-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-type.cc?ref=678bf852435aca6de25704ca417fab257fe03da9", "patch": "@@ -97,9 +97,15 @@ TyTyResolveCompile::visit (const TyTy::InferType &)\n }\n \n void\n-TyTyResolveCompile::visit (const TyTy::ClosureType &)\n+TyTyResolveCompile::visit (const TyTy::ClosureType &type)\n {\n-  gcc_unreachable ();\n+  std::vector<Backend::typed_identifier> fields;\n+  tree type_record = ctx->get_backend ()->struct_type (fields);\n+  RS_CLOSURE_FLAG (type_record) = 1;\n+\n+  std::string named_struct_str = type.get_ident ().path.get () + \"{{closure}}\";\n+  translated = ctx->get_backend ()->named_type (named_struct_str, type_record,\n+\t\t\t\t\t\ttype.get_ident ().locus);\n }\n \n void"}, {"sha": "83aefa7997a84d16b77ffe018444ee117e7ec136", "filename": "gcc/rust/backend/rust-mangle.cc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/678bf852435aca6de25704ca417fab257fe03da9/gcc%2Frust%2Fbackend%2Frust-mangle.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/678bf852435aca6de25704ca417fab257fe03da9/gcc%2Frust%2Fbackend%2Frust-mangle.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-mangle.cc?ref=678bf852435aca6de25704ca417fab257fe03da9", "patch": "@@ -13,6 +13,8 @@ static const std::string kMangledRef = \"$RF$\";\n static const std::string kMangledPtr = \"$BP$\";\n static const std::string kMangledLeftSqParen = \"$u5b$\";\t // [\n static const std::string kMangledRightSqParen = \"$u5d$\"; // ]\n+static const std::string kMangledLeftBrace = \"$u7b$\";\t // {\n+static const std::string kMangledRightBrace = \"$u7d$\";\t // }\n static const std::string kQualPathBegin = \"_\" + kMangledSubstBegin;\n static const std::string kMangledComma = \"$C$\";\n \n@@ -66,6 +68,10 @@ legacy_mangle_name (const std::string &name)\n \tm = kMangledLeftSqParen;\n       else if (c == ']')\n \tm = kMangledRightSqParen;\n+      else if (c == '{')\n+\tm = kMangledLeftBrace;\n+      else if (c == '}')\n+\tm = kMangledRightBrace;\n       else if (c == ',')\n \tm = kMangledComma;\n       else if (c == ':')"}, {"sha": "4a110163fd836a20024f89b7262ccdbd5ea57786", "filename": "gcc/rust/backend/rust-tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/678bf852435aca6de25704ca417fab257fe03da9/gcc%2Frust%2Fbackend%2Frust-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/678bf852435aca6de25704ca417fab257fe03da9/gcc%2Frust%2Fbackend%2Frust-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.h?ref=678bf852435aca6de25704ca417fab257fe03da9", "patch": "@@ -82,6 +82,11 @@\n #define SLICE_TYPE_P(TYPE)                                                     \\\n   (TREE_CODE (TYPE) == RECORD_TYPE && TREE_LANG_FLAG_0 (TYPE))\n \n+// lambda?\n+#define RS_CLOSURE_FLAG TREE_LANG_FLAG_1\n+#define RS_CLOSURE_TYPE_P(TYPE)                                                \\\n+  (TREE_CODE (TYPE) == RECORD_TYPE && TREE_LANG_FLAG_1 (TYPE))\n+\n /* Returns true if NODE is a pointer to member function type.  */\n #define TYPE_PTRMEMFUNC_P(NODE)                                                \\\n   (TREE_CODE (NODE) == RECORD_TYPE && TYPE_PTRMEMFUNC_FLAG (NODE))"}, {"sha": "e56bdd17b873cb6002f9f978ffed8c61d1b0b727", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/678bf852435aca6de25704ca417fab257fe03da9/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/678bf852435aca6de25704ca417fab257fe03da9/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=678bf852435aca6de25704ca417fab257fe03da9", "patch": "@@ -1696,8 +1696,17 @@ ClosureType::can_eq (const BaseType *other, bool emit_errors) const\n bool\n ClosureType::is_equal (const BaseType &other) const\n {\n-  gcc_unreachable ();\n-  return false;\n+  if (other.get_kind () != TypeKind::CLOSURE)\n+    return false;\n+\n+  const ClosureType &other2 = static_cast<const ClosureType &> (other);\n+  if (get_def_id () != other2.get_def_id ())\n+    return false;\n+\n+  if (!get_parameters ().is_equal (other2.get_parameters ()))\n+    return false;\n+\n+  return get_result_type ().is_equal (other2.get_result_type ());\n }\n \n BaseType *"}, {"sha": "62afa78a038d9a4f55d7f6c8dee138e01563ba11", "filename": "gcc/testsuite/rust/execute/torture/closure1.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/678bf852435aca6de25704ca417fab257fe03da9/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fclosure1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/678bf852435aca6de25704ca417fab257fe03da9/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fclosure1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fclosure1.rs?ref=678bf852435aca6de25704ca417fab257fe03da9", "patch": "@@ -0,0 +1,18 @@\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+#[lang = \"fn_once\"]\n+pub trait FnOnce<Args> {\n+    #[lang = \"fn_once_output\"]\n+    type Output;\n+\n+    extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n+}\n+\n+fn main() -> i32 {\n+    let closure_annotated = |i: i32| -> i32 { i + 1 };\n+\n+    let i = 1;\n+    closure_annotated(i) - 2\n+}"}]}