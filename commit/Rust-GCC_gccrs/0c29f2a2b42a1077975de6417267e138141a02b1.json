{"sha": "0c29f2a2b42a1077975de6417267e138141a02b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGMyOWYyYTJiNDJhMTA3Nzk3NWRlNjQxNzI2N2UxMzgxNDFhMDJiMQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-09-05T20:21:01Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-09-05T20:21:01Z"}, "message": "name-lookup.c (do_class_using_decl): Elide read-once temps.\n\n\t* name-lookup.c (do_class_using_decl): Elide read-once temps.\n\tMove declarations to initializations.\n\nFrom-SVN: r251738", "tree": {"sha": "d7f4cba8a372309b65205148f75e5ed7a5269b86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d7f4cba8a372309b65205148f75e5ed7a5269b86"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0c29f2a2b42a1077975de6417267e138141a02b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c29f2a2b42a1077975de6417267e138141a02b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c29f2a2b42a1077975de6417267e138141a02b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c29f2a2b42a1077975de6417267e138141a02b1/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fcaf306523baa9883c680a3a894bb5ff43092073", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcaf306523baa9883c680a3a894bb5ff43092073", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fcaf306523baa9883c680a3a894bb5ff43092073"}], "stats": {"total": 47, "additions": 18, "deletions": 29}, "files": [{"sha": "20213890bb2aef9ae1fcb98b416cf366b09d0623", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c29f2a2b42a1077975de6417267e138141a02b1/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c29f2a2b42a1077975de6417267e138141a02b1/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0c29f2a2b42a1077975de6417267e138141a02b1", "patch": "@@ -1,5 +1,8 @@\n 2017-09-05  Nathan Sidwell  <nathan@acm.org>\n \n+\t* name-lookup.c (do_class_using_decl): Elide read-once temps.\n+\tMove declarations to initializations.\n+\n \t* class.c (add_method): Move slot search and insertion to ...\n \t* name-lookup.c (get_method_slot): ... this new function.\n \t(lookup_fnfields_slot_nolazy): Cope with NULL slot."}, {"sha": "a9ed429e42733a8fe8bff1c2c0329512112224be", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 15, "deletions": 29, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c29f2a2b42a1077975de6417267e138141a02b1/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c29f2a2b42a1077975de6417267e138141a02b1/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=0c29f2a2b42a1077975de6417267e138141a02b1", "patch": "@@ -4560,20 +4560,6 @@ push_class_level_binding (tree name, tree x)\n tree\n do_class_using_decl (tree scope, tree name)\n {\n-  /* The USING_DECL returned by this function.  */\n-  tree value;\n-  /* The declaration (or declarations) name by this using\n-     declaration.  NULL if we are in a template and cannot figure out\n-     what has been named.  */\n-  tree decl;\n-  /* True if SCOPE is a dependent type.  */\n-  bool scope_dependent_p;\n-  /* True if SCOPE::NAME is dependent.  */\n-  bool name_dependent_p;\n-  /* True if any of the bases of CURRENT_CLASS_TYPE are dependent.  */\n-  bool bases_dependent_p;\n-  tree binfo;\n-\n   if (name == error_mark_node)\n     return NULL_TREE;\n \n@@ -4589,6 +4575,7 @@ do_class_using_decl (tree scope, tree name)\n       error (\"%<%T::%D%> names destructor\", scope, name);\n       return NULL_TREE;\n     }\n+\n   /* Using T::T declares inheriting ctors, even if T is a typedef.  */\n   if (MAYBE_CLASS_TYPE_P (scope)\n       && (name == TYPE_IDENTIFIER (scope)\n@@ -4598,22 +4585,15 @@ do_class_using_decl (tree scope, tree name)\n       name = ctor_identifier;\n       CLASSTYPE_NON_AGGREGATE (current_class_type) = true;\n     }\n+\n+  /* Cannot introduce a constructor name.  */\n   if (constructor_name_p (name, current_class_type))\n     {\n       error (\"%<%T::%D%> names constructor in %qT\",\n \t     scope, name, current_class_type);\n       return NULL_TREE;\n     }\n \n-  scope_dependent_p = dependent_scope_p (scope);\n-  name_dependent_p = (scope_dependent_p\n-\t\t      || (IDENTIFIER_CONV_OP_P (name)\n-\t\t\t  && dependent_type_p (TREE_TYPE (name))));\n-\n-  bases_dependent_p = any_dependent_bases_p ();\n-\n-  decl = NULL_TREE;\n-\n   /* From [namespace.udecl]:\n \n        A using-declaration used as a member-declaration shall refer to a\n@@ -4624,14 +4604,18 @@ do_class_using_decl (tree scope, tree name)\n      class type. Morover, if SCOPE is dependent, it might match a\n      non-dependent base.  */\n \n-  if (!scope_dependent_p)\n+  tree decl = NULL_TREE;\n+  if (!dependent_scope_p (scope))\n     {\n       base_kind b_kind;\n-      binfo = lookup_base (current_class_type, scope, ba_any, &b_kind,\n-\t\t\t   tf_warning_or_error);\n+      tree binfo = lookup_base (current_class_type, scope, ba_any, &b_kind,\n+\t\t\t\ttf_warning_or_error);\n       if (b_kind < bk_proper_base)\n \t{\n-\t  if (!bases_dependent_p || b_kind == bk_same_type)\n+\t  /* If there are dependent bases, scope might resolve at\n+\t     instantiation time, even if it isn't exactly one of the\n+\t     dependent bases.  */\n+\t  if (b_kind == bk_same_type || !any_dependent_bases_p ())\n \t    {\n \t      error_not_base_type (scope, current_class_type);\n \t      return NULL_TREE;\n@@ -4642,7 +4626,8 @@ do_class_using_decl (tree scope, tree name)\n \t  error (\"cannot inherit constructors from indirect base %qT\", scope);\n \t  return NULL_TREE;\n \t}\n-      else if (!name_dependent_p)\n+      else if (!IDENTIFIER_CONV_OP_P (name)\n+\t       || !dependent_type_p (TREE_TYPE (name)))\n \t{\n \t  decl = lookup_member (binfo, name, 0, false, tf_warning_or_error);\n \t  if (!decl)\n@@ -4651,13 +4636,14 @@ do_class_using_decl (tree scope, tree name)\n \t\t     scope);\n \t      return NULL_TREE;\n \t    }\n+\n \t  /* The binfo from which the functions came does not matter.  */\n \t  if (BASELINK_P (decl))\n \t    decl = BASELINK_FUNCTIONS (decl);\n \t}\n     }\n \n-  value = build_lang_decl (USING_DECL, name, NULL_TREE);\n+  tree value = build_lang_decl (USING_DECL, name, NULL_TREE);\n   USING_DECL_DECLS (value) = decl;\n   USING_DECL_SCOPE (value) = scope;\n   DECL_DEPENDENT_P (value) = !decl;"}]}