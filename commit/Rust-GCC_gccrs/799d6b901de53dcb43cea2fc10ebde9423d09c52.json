{"sha": "799d6b901de53dcb43cea2fc10ebde9423d09c52", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzk5ZDZiOTAxZGU1M2RjYjQzY2VhMmZjMTBlYmRlOTQyM2QwOWM1Mg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-03T21:46:30Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-03T21:46:30Z"}, "message": "Improve spilling for variable-width slots\n\nOnce SVE is enabled, a general AArch64 spill slot offset will be\n\n  A + B * VL\n\nwhere A is a constant and B is a multiple of the SVE vector length.\nThe offsets in SVE load and store instructions are a multiple of VL\n(and so can encode some values of B), while offsets for standard AArch64\nload and store instructions aren't (and encode some values of A).\n\nWe therefore get better spill code if variable-sized slots are grouped\ntogether separately from constant-sized slots, and if variable-sized\nslots are not reused for constant-sized data.  Then, spills to the\nconstant-sized slots can add B * VL to the offset first, creating a\ncommon anchor point for spills with the same B component but different\nA components.  Similarly, spills to variable-sized slots can add A to\nthe offset first, creating a common anchor point for spills with the same\nA component but different B components.\n\nThis patch implements the sorting and grouping side of the optimisation.\nA later patch creates the anchor points.\n\nThe patch is a no-op on other targets.\n\n2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* lra-spills.c (pseudo_reg_slot_compare): Sort slots by whether\n\tthey are variable or constant sized.\n\t(assign_stack_slot_num_and_sort_pseudos): Don't reuse variable-sized\n\tslots for constant-sized data.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256208", "tree": {"sha": "9e41cc032c83a2afb4464fb5e265e99100225c7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9e41cc032c83a2afb4464fb5e265e99100225c7e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/799d6b901de53dcb43cea2fc10ebde9423d09c52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/799d6b901de53dcb43cea2fc10ebde9423d09c52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/799d6b901de53dcb43cea2fc10ebde9423d09c52", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/799d6b901de53dcb43cea2fc10ebde9423d09c52/comments", "author": null, "committer": null, "parents": [{"sha": "6a3c127cc4e198bd20ae32c37c93cdf7defb0871", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a3c127cc4e198bd20ae32c37c93cdf7defb0871", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a3c127cc4e198bd20ae32c37c93cdf7defb0871"}], "stats": {"total": 36, "additions": 33, "deletions": 3}, "files": [{"sha": "a151f622738a0253a8a5c024276f81b9ecee26ef", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/799d6b901de53dcb43cea2fc10ebde9423d09c52/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/799d6b901de53dcb43cea2fc10ebde9423d09c52/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=799d6b901de53dcb43cea2fc10ebde9423d09c52", "patch": "@@ -1,3 +1,12 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* lra-spills.c (pseudo_reg_slot_compare): Sort slots by whether\n+\tthey are variable or constant sized.\n+\t(assign_stack_slot_num_and_sort_pseudos): Don't reuse variable-sized\n+\tslots for constant-sized data.\n+\n 2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "67675d9f1c4c3c82b6f74a809b64d155d55260df", "filename": "gcc/lra-spills.c", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/799d6b901de53dcb43cea2fc10ebde9423d09c52/gcc%2Flra-spills.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/799d6b901de53dcb43cea2fc10ebde9423d09c52/gcc%2Flra-spills.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-spills.c?ref=799d6b901de53dcb43cea2fc10ebde9423d09c52", "patch": "@@ -174,9 +174,17 @@ regno_freq_compare (const void *v1p, const void *v2p)\n }\n \n /* Sort pseudos according to their slots, putting the slots in the order\n-   that they should be allocated.  Slots with lower numbers have the highest\n-   priority and should get the smallest displacement from the stack or\n-   frame pointer (whichever is being used).\n+   that they should be allocated.\n+\n+   First prefer to group slots with variable sizes together and slots\n+   with constant sizes together, since that usually makes them easier\n+   to address from a common anchor point.  E.g. loads of polynomial-sized\n+   registers tend to take polynomial offsets while loads of constant-sized\n+   registers tend to take constant (non-polynomial) offsets.\n+\n+   Next, slots with lower numbers have the highest priority and should\n+   get the smallest displacement from the stack or frame pointer\n+   (whichever is being used).\n \n    The first allocated slot is always closest to the frame pointer,\n    so prefer lower slot numbers when frame_pointer_needed.  If the stack\n@@ -194,6 +202,10 @@ pseudo_reg_slot_compare (const void *v1p, const void *v2p)\n \n   slot_num1 = pseudo_slots[regno1].slot_num;\n   slot_num2 = pseudo_slots[regno2].slot_num;\n+  diff = (int (slots[slot_num1].size.is_constant ())\n+\t  - int (slots[slot_num2].size.is_constant ()));\n+  if (diff != 0)\n+    return diff;\n   if ((diff = slot_num1 - slot_num2) != 0)\n     return (frame_pointer_needed\n \t    || (!FRAME_GROWS_DOWNWARD) == STACK_GROWS_DOWNWARD ? diff : -diff);\n@@ -356,8 +368,17 @@ assign_stack_slot_num_and_sort_pseudos (int *pseudo_regnos, int n)\n \tj = slots_num;\n       else\n \t{\n+\t  machine_mode mode\n+\t    = wider_subreg_mode (PSEUDO_REGNO_MODE (regno),\n+\t\t\t\t lra_reg_info[regno].biggest_mode);\n \t  for (j = 0; j < slots_num; j++)\n \t    if (slots[j].hard_regno < 0\n+\t\t/* Although it's possible to share slots between modes\n+\t\t   with constant and non-constant widths, we usually\n+\t\t   get better spill code by keeping the constant and\n+\t\t   non-constant areas separate.  */\n+\t\t&& (GET_MODE_SIZE (mode).is_constant ()\n+\t\t    == slots[j].size.is_constant ())\n \t\t&& ! (lra_intersected_live_ranges_p\n \t\t      (slots[j].live_ranges,\n \t\t       lra_reg_info[regno].live_ranges)))"}]}