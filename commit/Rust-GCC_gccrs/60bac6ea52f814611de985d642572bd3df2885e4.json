{"sha": "60bac6ea52f814611de985d642572bd3df2885e4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjBiYWM2ZWE1MmY4MTQ2MTFkZTk4NWQ2NDI1NzJiZDNkZjI4ODVlNA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-07-14T03:38:36Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-07-14T03:38:36Z"}, "message": "(expand_builtin): For fsqrt, always use the special insn, then test for nan.\n\nIn case of nan, set errno directly or call the library function.\n\nFrom-SVN: r1586", "tree": {"sha": "74585272d6ab4bd5796d7fd554fd90cc641b6a36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74585272d6ab4bd5796d7fd554fd90cc641b6a36"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/60bac6ea52f814611de985d642572bd3df2885e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60bac6ea52f814611de985d642572bd3df2885e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60bac6ea52f814611de985d642572bd3df2885e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60bac6ea52f814611de985d642572bd3df2885e4/comments", "author": null, "committer": null, "parents": [{"sha": "3f31889abb324ef69138d2d1f9cc22715eb985d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f31889abb324ef69138d2d1f9cc22715eb985d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f31889abb324ef69138d2d1f9cc22715eb985d6"}], "stats": {"total": 72, "additions": 40, "deletions": 32}, "files": [{"sha": "e0a6a806e739d56ad95c38da55ca62e2457ef9de", "filename": "gcc/expr.c", "status": "modified", "additions": 40, "deletions": 32, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60bac6ea52f814611de985d642572bd3df2885e4/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60bac6ea52f814611de985d642572bd3df2885e4/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=60bac6ea52f814611de985d642572bd3df2885e4", "patch": "@@ -4980,7 +4980,7 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n   tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n   tree arglist = TREE_OPERAND (exp, 1);\n   rtx op0;\n-  rtx lab1, lab2, insns;\n+  rtx lab1, insns;\n   enum machine_mode value_mode = TYPE_MODE (TREE_TYPE (exp));\n \n   switch (DECL_FUNCTION_CODE (fndecl))\n@@ -5015,39 +5015,10 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n       /* Make a suitable register to place result in.  */\n       target = gen_reg_rtx (TYPE_MODE (TREE_TYPE (exp)));\n \n-      /* Test the argument to make sure it is in the proper domain for\n-\t the sqrt function.  If it is not in the domain, branch to a \n-\t library call.  */\n       emit_queue ();\n       start_sequence ();\n-      lab1 = gen_label_rtx ();\n-      lab2 = gen_label_rtx ();\n \n-      /* By default check the arguments.  If flag_fast_math is turned on,\n-\t then assume sqrt will always be called with valid arguments. \n-\t Note changing the test below from \"> 0\" to \">= 0\" would cause\n-\t incorrect results when computing sqrt(-0.0).  */\n-\n-      if (! flag_fast_math) \n-\t{\n-\t  /* By checking op > 0 we are able to catch all of the\n-             IEEE special cases with a single if conditional.  */\n-          emit_cmp_insn (op0, CONST0_RTX (GET_MODE (op0)), GT, NULL_RTX,\n-\t\t\t GET_MODE (op0), 0, 0);\n-          emit_jump_insn (gen_bgt (lab1));\n-\n-          /* The argument was not in the domain; do this via library call.\n-\t     Pop the arguments right away in case the call gets deleted. */\n-\t  NO_DEFER_POP;\n-          expand_call (exp, target, 0);\n-\t  OK_DEFER_POP;\n-\n-          /* Branch around open coded version */\n-          emit_jump_insn (gen_jump (lab2));\n-\t}\n-\n-      emit_label (lab1);\n-      /* Arg is in the domain, compute sqrt, into TARGET. \n+      /* Compute sqrt into TARGET. \n \t Set TARGET to wherever the result comes back.  */\n       target = expand_unop (TYPE_MODE (TREE_TYPE (TREE_VALUE (arglist))),\n \t\t\t    sqrt_optab, op0, target, 0);\n@@ -5060,8 +5031,45 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \t  end_sequence ();\n \t  break;\n         }\n-      emit_label (lab2);\n \n+      /* Check the results by default.  But if flag_fast_math is turned on,\n+\t then assume sqrt will always be called with valid arguments.  */\n+\n+      if (! flag_fast_math)\n+\t{\n+\t  /* Don't define the sqrt instructions\n+\t     if your machine is not IEEE.  */\n+\t  if (TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT)\n+\t    abort ();\n+\n+\t  lab1 = gen_label_rtx ();\n+\n+\t  /* Test the result; if it is NaN, set errno=EDOM because\n+\t     the argument was not in the domain.  */\n+\t  emit_cmp_insn (target, target, EQ, 0, GET_MODE (target), 0, 0);\n+\t  emit_jump_insn (gen_beq (lab1));\n+\n+#if TARGET_EDOM\n+\t  {\n+#ifdef GEN_ERRNO_RTX\n+\t    rtx errno_rtx = GEN_ERRNO_RTX;\n+#else\n+\t    rtx errno_rtx\n+\t      = gen_rtx (MEM, word_mode, gen_rtx (SYMBOL_REF, Pmode, \"*errno\"));\n+#endif\n+\n+\t    emit_move_insn (errno_rtx, GEN_INT (TARGET_EDOM));\n+\t  }\n+#else\n+\t  /* We can't set errno=EDOM directly; let the library call do it.\n+\t     Pop the arguments right away in case the call gets deleted. */\n+\t  NO_DEFER_POP;\n+\t  expand_call (exp, target, 0);\n+\t  OK_DEFER_POP;\n+#endif\n+\n+\t  emit_label (lab1);\n+\t}\n \n       /* Output the entire sequence. */\n       insns = get_insns ();"}]}