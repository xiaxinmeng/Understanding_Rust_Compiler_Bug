{"sha": "51d3c11a7c79294599c1e9088c80f7417566a75e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTFkM2MxMWE3Yzc5Mjk0NTk5YzFlOTA4OGM4MGY3NDE3NTY2YTc1ZQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2019-04-10T19:24:04Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2019-04-10T19:24:04Z"}, "message": "Update documentation regarding bogus memory leaks in libstdc++\n\n\t* doc/xml/faq.xml: Add information about emergency EH pool.\n\t* doc/xml/manual/debug.xml: Update list of memory debugging tools.\n\tMove outdated information on mt_allocator to a separate section.\n\t* doc/xml/manual/evolution.xml: Clarify that GLIBCXX_FORCE_NEW\n\tdoesn't affect the default allocator.\n\nFrom-SVN: r270264", "tree": {"sha": "182e2679d85ccd016d3345d802c8481830851885", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/182e2679d85ccd016d3345d802c8481830851885"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/51d3c11a7c79294599c1e9088c80f7417566a75e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51d3c11a7c79294599c1e9088c80f7417566a75e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51d3c11a7c79294599c1e9088c80f7417566a75e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51d3c11a7c79294599c1e9088c80f7417566a75e/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7f8aa3ee7ed60fdf37d3e2557389504f5a8a5f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7f8aa3ee7ed60fdf37d3e2557389504f5a8a5f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7f8aa3ee7ed60fdf37d3e2557389504f5a8a5f0"}], "stats": {"total": 118, "additions": 76, "deletions": 42}, "files": [{"sha": "6148f5ce944053ca4630e723fc17c347fb2d11f8", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51d3c11a7c79294599c1e9088c80f7417566a75e/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51d3c11a7c79294599c1e9088c80f7417566a75e/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=51d3c11a7c79294599c1e9088c80f7417566a75e", "patch": "@@ -1,5 +1,11 @@\n 2019-04-10  Jonathan Wakely  <jwakely@redhat.com>\n \n+\t* doc/xml/faq.xml: Add information about emergency EH pool.\n+\t* doc/xml/manual/debug.xml: Update list of memory debugging tools.\n+\tMove outdated information on mt_allocator to a separate section.\n+\t* doc/xml/manual/evolution.xml: Clarify that GLIBCXX_FORCE_NEW\n+\tdoesn't affect the default allocator.\n+\n \t* testsuite/lib/libstdc++.exp (check_v3_target_parallel_mode): Fix\n \ttypo.\n "}, {"sha": "b4bf333e26ad24a1e70602186711dc5947c6d1cc", "filename": "libstdc++-v3/doc/xml/faq.xml", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51d3c11a7c79294599c1e9088c80f7417566a75e/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Ffaq.xml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51d3c11a7c79294599c1e9088c80f7417566a75e/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Ffaq.xml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Ffaq.xml?ref=51d3c11a7c79294599c1e9088c80f7417566a75e", "patch": "@@ -1001,21 +1001,31 @@\n <qandaentry xml:id=\"faq.memory_leaks\">\n   <question xml:id=\"q-memory_leaks\">\n     <para>\n-      <quote>Memory leaks</quote> in containers\n+      <quote>Memory leaks</quote> in libstdc++\n     </para>\n   </question>\n   <answer xml:id=\"a-memory_leaks\">\n-    <note>\n-      <para>This answer is old and probably no longer be relevant.</para>\n-    </note>\n     <para>\n-    A few people have reported that the standard containers appear\n+    Since GCC 5.1.0, libstdc++ automatically allocates a pool\n+    of a few dozen kilobytes on startup. This pool is used to ensure it's\n+    possible to throw exceptions (such as <classname>bad_alloc</classname>)\n+    even when <code>malloc</code> is unable to allocate any more memory.\n+    With some versions of <link xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"http://valgrind.org/\"><command>valgrind</command></link>\n+    this pool will be shown as \"still reachable\" when the process exits, e.g.\n+    <code>still reachable: 72,704 bytes in 1 blocks</code>.\n+    This memory is not a leak, because it's still in use by libstdc++,\n+    and the memory will be returned to the OS when the process exits.\n+    Later versions of <command>valgrind</command> know how to free this\n+    pool as the process exits, and so won't show any \"still reachable\" memory.\n+    </para>\n+    <para>\n+    In the past, a few people reported that the standard containers appear\n     to leak memory when tested with memory checkers such as\n     <link xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"http://valgrind.org/\"><command>valgrind</command></link>.\n     Under some (non-default) configurations the library's allocators keep\n     free memory in a\n-    pool for later reuse, rather than returning it to the OS.  Although\n-    this memory is always reachable by the library and is never\n+    pool for later reuse, rather than deallocating it with <code>delete</code>\n+    Although this memory is always reachable by the library and is never\n     lost, memory debugging tools can report it as a leak.  If you\n     want to test the library for memory leaks please read\n     <link linkend=\"debug.memory\">Tips for memory leak hunting</link>"}, {"sha": "091e0b6914cacf27afa0ea407216a587af3f53dc", "filename": "libstdc++-v3/doc/xml/manual/debug.xml", "status": "modified", "additions": 48, "deletions": 31, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51d3c11a7c79294599c1e9088c80f7417566a75e/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fdebug.xml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51d3c11a7c79294599c1e9088c80f7417566a75e/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fdebug.xml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fdebug.xml?ref=51d3c11a7c79294599c1e9088c80f7417566a75e", "patch": "@@ -94,50 +94,35 @@\n \n <section xml:id=\"debug.memory\"><info><title>Memory Leak Hunting</title></info>\n \n+<para>\n+  On many targets GCC supports AddressSanitizer, a fast memory error detector,\n+  which is enabled by the <option>-fsanitize=address</option> option.\n+</para>\n \n <para>\n-  There are various third party memory tracing and debug utilities\n+  There are also various third party memory tracing and debug utilities\n   that can be used to provide detailed memory allocation information\n   about C++ code. An exhaustive list of tools is not going to be\n   attempted, but includes <code>mtrace</code>, <code>valgrind</code>,\n-  <code>mudflap</code>, and the non-free commercial product\n-  <code>purify</code>. In addition, <code>libcwd</code> has a\n-  replacement for the global new and delete operators that can track\n-  memory allocation and deallocation and provide useful memory\n-  statistics.\n-</para>\n-\n-<para>\n-  Regardless of the memory debugging tool being used, there is one\n-  thing of great importance to keep in mind when debugging C++ code\n-  that uses <code>new</code> and <code>delete</code>: there are\n-  different kinds of allocation schemes that can be used by <code>\n-  std::allocator</code>. For implementation details, see the <link linkend=\"manual.ext.allocator.mt\">mt allocator</link> documentation and\n-  look specifically for <code>GLIBCXX_FORCE_NEW</code>.\n-</para>\n-\n-<para>\n-  In a nutshell, the optional <classname>mt_allocator</classname>\n-  is a high-performance pool allocator, and can\n-  give the mistaken impression that in a suspect executable, memory is\n-  being leaked, when in reality the memory \"leak\" is a pool being used\n-  by the library's allocator and is reclaimed after program\n-  termination.\n+  <code>mudflap</code> (no longer supported since GCC 4.9.0), ElectricFence,\n+  and the non-free commercial product <code>purify</code>.\n+  In addition, <code>libcwd</code>, jemalloc and TCMalloc have replacements\n+  for the global <code>new</code> and <code>delete</code> operators\n+  that can track memory allocation and deallocation and provide useful\n+  memory statistics.\n </para>\n \n <para>\n   For valgrind, there are some specific items to keep in mind. First\n   of all, use a version of valgrind that will work with current GNU\n   C++ tools: the first that can do this is valgrind 1.0.4, but later\n-  versions should work at least as well. Second of all, use a\n-  completely unoptimized build to avoid confusing valgrind. Third, use\n-  GLIBCXX_FORCE_NEW to keep extraneous pool allocation noise from\n-  cluttering debug information.\n+  versions should work better. Second, using an unoptimized build\n+  might avoid confusing valgrind.\n </para>\n \n <para>\n-  Fourth, it may be necessary to force deallocation in other libraries\n-  as well, namely the \"C\" library. On linux, this can be accomplished\n+  Third, it may be necessary to force deallocation in other libraries\n+  as well, namely the \"C\" library. On GNU/Linux, this can be accomplished\n   with the appropriate use of the <code>__cxa_atexit</code> or\n   <code>atexit</code> functions.\n </para>\n@@ -157,7 +142,6 @@\n    }\n </programlisting>\n \n-\n <para>or, using <code>__cxa_atexit</code>:</para>\n \n <programlisting>\n@@ -184,6 +168,39 @@\n    valgrind -v --num-callers=20 --leak-check=yes --leak-resolution=high --show-reachable=yes a.out\n </programlisting>\n \n+<section xml:id=\"debug.memory.mtalloc\">\n+<info><title>Non-memory leaks in Pool and MT allocators</title></info>\n+\n+<para>\n+  There are different kinds of allocation schemes that can be used by\n+  <code>std::allocator</code>. Prior to GCC 3.4.0 the default was to use\n+  a pooling allocator, <classname>pool_allocator</classname>,\n+  which is still available as the optional\n+  <classname>__pool_alloc</classname> extension.\n+  Another optional extension, <classname>__mt_alloc</classname>,\n+  is a high-performance pool allocator.\n+</para>\n+\n+<para>\n+  In a suspect executable these pooling allocators can give\n+  the mistaken impression that memory is being leaked,\n+  when in reality the memory \"leak\" is a pool being used\n+  by the library's allocator and is reclaimed after program\n+  termination.\n+</para>\n+\n+<para>\n+  If you're using memory debugging tools on a program that uses\n+  one of these pooling allocators, you can set the environment variable\n+  <literal>GLIBCXX_FORCE_NEW</literal> to keep extraneous pool allocation\n+  noise from cluttering debug information.\n+  For more details, see the\n+  <link linkend=\"manual.ext.allocator.mt\">mt allocator</link>\n+  documentation and look specifically for <code>GLIBCXX_FORCE_NEW</code>.\n+</para>\n+\n+</section>\n+\n </section>\n \n <section xml:id=\"debug.races\"><info><title>Data Race Hunting</title></info>"}, {"sha": "c7efb8f0f8ab18ccffedf847102b086ee4e44ac0", "filename": "libstdc++-v3/doc/xml/manual/evolution.xml", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51d3c11a7c79294599c1e9088c80f7417566a75e/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fevolution.xml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51d3c11a7c79294599c1e9088c80f7417566a75e/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fevolution.xml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fevolution.xml?ref=51d3c11a7c79294599c1e9088c80f7417566a75e", "patch": "@@ -79,11 +79,12 @@ Removal of <filename class=\"headerfile\">&lt;ext/tree&gt;</filename>, moved to <f\n \n    <para> For GCC releases from 2.95 through the 3.1 series, defining\n    <literal>__USE_MALLOC</literal> on the gcc command line would change the\n-   default allocation strategy to instead use <code> malloc</code> and\n-   <function>free</function>. For the 3.2 and 3.3 release series the same\n+   default allocation strategy to instead use <code>malloc</code> and\n+   <code>free</code>. For the 3.2 and 3.3 release series the same\n    functionality was spelled <literal>_GLIBCXX_FORCE_NEW</literal>. From\n-   GCC 3.4 onwards the functionality is enabled by setting\n-   <literal>GLIBCXX_FORCE_NEW</literal> in the environment, see\n+   GCC 3.4 onwards the default allocator uses <code>new</code> anyway,\n+   but for the optional pooling allocators the functionality is enabled by\n+   setting <literal>GLIBCXX_FORCE_NEW</literal> in the environment, see\n    <link linkend=\"manual.ext.allocator.mt\">the mt allocator chapter</link>\n    for details.\n    </para>"}]}