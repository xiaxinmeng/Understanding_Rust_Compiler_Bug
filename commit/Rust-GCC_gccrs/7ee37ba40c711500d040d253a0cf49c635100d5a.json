{"sha": "7ee37ba40c711500d040d253a0cf49c635100d5a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2VlMzdiYTQwYzcxMTUwMGQwNDBkMjUzYTBjZjQ5YzYzNTEwMGQ1YQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-02-21T18:30:37Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-02-21T18:30:37Z"}, "message": "genattrtab.c (check_attr_value): Allow negative const_int if negative_ok.\n\n        * genattrtab.c (check_attr_value): Allow negative const_int if\n        negative_ok.  Accept integral arithmetic operators.  Accept\n        direct references to other attributes.  Accept symbol_ref in\n        non-constant attributes.\n        (max_attr_value): Add new argument `unknownp'.  Update all callers.\n        (or_attr_value): Likewise.\n        (simplify_knowing): Don't optimize if max_attr_value unknown.\n        (write_length_unit_log): Likewise with or_attr_value.\n        (find_and_mark_used_attributes): Don't fallthru case.\n        (write_attr_set): Pass thru all non-cond expressions.\n        (write_attr_value): Handle symbol_ref, attr, and arithmetic.\n\nFrom-SVN: r25348", "tree": {"sha": "d06b5d850ee53d4ec20bbdfc14b0cbeb32def76c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d06b5d850ee53d4ec20bbdfc14b0cbeb32def76c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ee37ba40c711500d040d253a0cf49c635100d5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ee37ba40c711500d040d253a0cf49c635100d5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ee37ba40c711500d040d253a0cf49c635100d5a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ee37ba40c711500d040d253a0cf49c635100d5a/comments", "author": null, "committer": null, "parents": [{"sha": "0301787454dd52a66d62d421f8a4015ab62686ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0301787454dd52a66d62d421f8a4015ab62686ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0301787454dd52a66d62d421f8a4015ab62686ae"}], "stats": {"total": 249, "additions": 175, "deletions": 74}, "files": [{"sha": "6d9e04f70d31190b5c3d10addbd8d8ef781beba3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ee37ba40c711500d040d253a0cf49c635100d5a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ee37ba40c711500d040d253a0cf49c635100d5a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7ee37ba40c711500d040d253a0cf49c635100d5a", "patch": "@@ -1,3 +1,17 @@\n+Sun Feb 21 17:11:18 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* genattrtab.c (check_attr_value): Allow negative const_int if\n+\tnegative_ok.  Accept integral arithmetic operators.  Accept\n+\tdirect references to other attributes.  Accept symbol_ref in\n+\tnon-constant attributes.\n+\t(max_attr_value): Add new argument `unknownp'.  Update all callers.\n+\t(or_attr_value): Likewise.\n+\t(simplify_knowing): Don't optimize if max_attr_value unknown.\n+\t(write_length_unit_log): Likewise with or_attr_value.\n+\t(find_and_mark_used_attributes): Don't fallthru case.\n+\t(write_attr_set): Pass thru all non-cond expressions.\n+\t(write_attr_value): Handle symbol_ref, attr, and arithmetic.\n+\n Sun Feb 21 13:16:44 1999  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n \n \t* regmove.c (discover_flags_reg): Use word_mode instead of SImode."}, {"sha": "f6008df07f7513c8fdce5672837e9a15e9c4eb1b", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 161, "deletions": 74, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ee37ba40c711500d040d253a0cf49c635100d5a/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ee37ba40c711500d040d253a0cf49c635100d5a/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=7ee37ba40c711500d040d253a0cf49c635100d5a", "patch": "@@ -426,8 +426,8 @@ static void gen_insn\t\tPROTO((rtx));\n static void gen_delay\t\tPROTO((rtx));\n static void gen_unit\t\tPROTO((rtx));\n static void write_test_expr\tPROTO((rtx, int));\n-static int max_attr_value\tPROTO((rtx));\n-static int or_attr_value\tPROTO((rtx));\n+static int max_attr_value\tPROTO((rtx, int*));\n+static int or_attr_value\tPROTO((rtx, int*));\n static void walk_attr_value\tPROTO((rtx));\n static void write_attr_get\tPROTO((struct attr_desc *));\n static rtx eliminate_known_true PROTO((rtx, rtx, int, int));\n@@ -1083,7 +1083,7 @@ check_attr_value (exp, attr)\n \tfatal (\"CONST_INT not valid for non-numeric `%s' attribute\",\n \t       attr->name);\n \n-      if (INTVAL (exp) < 0)\n+      if (INTVAL (exp) < 0 && ! attr->negative_ok)\n \tfatal (\"Negative numeric value specified for `%s' attribute\",\n \t       attr->name);\n \n@@ -1123,6 +1123,16 @@ check_attr_value (exp, attr)\n       XEXP (exp, 2) = check_attr_value (XEXP (exp, 2), attr);\n       break;\n \n+    case PLUS:\n+    case MINUS:\n+    case MULT:\n+    case DIV:\n+    case MOD:\n+      if (attr && !attr->is_numeric)\n+\tfatal (\"Invalid operation `%s' for non-numeric attribute value\",\n+\t       GET_RTX_NAME (GET_CODE (exp)));\n+      /* FALLTHRU */\n+\n     case IOR:\n     case AND:\n       XEXP (exp, 0) = check_attr_value (XEXP (exp, 0), attr);\n@@ -1148,12 +1158,27 @@ check_attr_value (exp, attr)\n       XEXP (exp, 1) = check_attr_value (XEXP (exp, 1), attr);\n       break;\n \n+    case ATTR:\n+      {\n+\tstruct attr_desc *attr2 = find_attr (XSTR (exp, 0), 0);\n+\tif (attr2 == NULL)\n+\t  fatal (\"Unknown attribute `%s' in ATTR\", XSTR (exp, 0));\n+\telse if ((attr && attr->is_const) && ! attr2->is_const)\n+\t  fatal (\"Non-constant attribute `%s' referenced from `%s'\",\n+\t\t XSTR (exp, 0), attr->name);\n+\telse if (attr \n+\t\t && (attr->is_numeric != attr2->is_numeric\n+\t\t     || (! attr->negative_ok && attr2->negative_ok)))\n+\t  fatal (\"Numeric attribute mismatch calling `%s' from `%s'\",\n+\t\t XSTR (exp, 0), attr->name);\n+      }\n+      break;\n+\n     case SYMBOL_REF:\n-      if (attr && attr->is_const)\n-\t/* A constant SYMBOL_REF is valid as a constant attribute test and\n-\t   is expanded later by make_canonical into a COND.  */\n-\treturn attr_rtx (SYMBOL_REF, XSTR (exp, 0));\n-      /* Otherwise, fall through...  */\n+      /* A constant SYMBOL_REF is valid as a constant attribute test and\n+         is expanded later by make_canonical into a COND.  In a non-constant\n+         attribute test, it is left be.  */\n+      return attr_rtx (SYMBOL_REF, XSTR (exp, 0));\n \n     default:\n       fatal (\"Invalid operation `%s' for attribute value\",\n@@ -2101,7 +2126,10 @@ expand_units ()\n \t    }\n \n \t  /* Record MAX (BLOCKAGE (*,*)).  */\n-\t  unit->max_blockage = max_attr_value (max_blockage);\n+\t  {\n+\t    int unknown;\n+\t    unit->max_blockage = max_attr_value (max_blockage, &unknown);\n+\t  }\n \n \t  /* See if the upper and lower bounds of BLOCKAGE (E,*) are the\n \t     same.  If so, the blockage function carries no additional\n@@ -2186,9 +2214,14 @@ simplify_knowing (exp, known_true)\n {\n   if (GET_CODE (exp) != CONST_STRING)\n     {\n-      exp = attr_rtx (IF_THEN_ELSE, known_true, exp,\n-\t\t      make_numeric_value (max_attr_value (exp)));\n-      exp = simplify_by_exploding (exp);\n+      int unknown, max;\n+      max = max_attr_value (exp, &unknown);\n+      if (! unknown)\n+\t{\n+\t  exp = attr_rtx (IF_THEN_ELSE, known_true, exp,\n+\t\t          make_numeric_value (max));\n+          exp = simplify_by_exploding (exp);\n+\t}\n     }\n   return exp;\n }\n@@ -2458,7 +2491,8 @@ static rtx\n max_fn (exp)\n      rtx exp;\n {\n-  return make_numeric_value (max_attr_value (exp));\n+  int unknown;\n+  return make_numeric_value (max_attr_value (exp, &unknown));\n }\n \n static void\n@@ -2468,16 +2502,23 @@ write_length_unit_log ()\n   struct attr_value *av;\n   struct insn_ent *ie;\n   unsigned int length_unit_log, length_or;\n+  int unknown = 0;\n \n   if (length_attr == 0)\n     return;\n-  length_or = or_attr_value (length_attr->default_val->value);\n-    for (av = length_attr->first_value; av; av = av->next)\n-      for (ie = av->first_insn; ie; ie = ie->next)\n-\tlength_or |= or_attr_value (av->value);\n-  length_or = ~length_or;\n-  for (length_unit_log = 0; length_or & 1; length_or >>= 1)\n-    length_unit_log++;\n+  length_or = or_attr_value (length_attr->default_val->value, &unknown);\n+  for (av = length_attr->first_value; av; av = av->next)\n+    for (ie = av->first_insn; ie; ie = ie->next)\n+      length_or |= or_attr_value (av->value, &unknown);\n+\n+  if (unknown)\n+    length_unit_log = 0;\n+  else\n+    {\n+      length_or = ~length_or;\n+      for (length_unit_log = 0; length_or & 1; length_or >>= 1)\n+        length_unit_log++;\n+    }\n   printf (\"int length_unit_log = %u;\\n\", length_unit_log);\n }\n \f\n@@ -3703,6 +3744,8 @@ find_and_mark_used_attributes (exp, terms, nterms)\n \t  *nterms += 1;\n \t  MEM_VOLATILE_P (exp) = 1;\n \t}\n+      return 1;\n+\n     case CONST_STRING:\n     case CONST_INT:\n       return 1;\n@@ -4106,7 +4149,7 @@ gen_attr (exp)\n     fatal (\"Duplicate definition for `%s' attribute\", attr->name);\n \n   if (*XSTR (exp, 1) == '\\0')\n-      attr->is_numeric = 1;\n+    attr->is_numeric = 1;\n   else\n     {\n       name_ptr = XSTR (exp, 1);\n@@ -4652,80 +4695,83 @@ write_test_expr (exp, flags)\n }\n \f\n /* Given an attribute value, return the maximum CONST_STRING argument\n-   encountered.  It is assumed that they are all numeric.  */\n+   encountered.  Set *UNKNOWNP and return INT_MAX if the value is unknown.  */\n \n static int\n-max_attr_value (exp)\n+max_attr_value (exp, unknownp)\n      rtx exp;\n+     int *unknownp;\n {\n-  int current_max = 0;\n-  int n;\n-  int i;\n-\n-  if (GET_CODE (exp) == CONST_STRING)\n-    return atoi (XSTR (exp, 0));\n+  int current_max;\n+  int i, n;\n \n-  else if (GET_CODE (exp) == COND)\n+  switch (GET_CODE (exp))\n     {\n+    case CONST_STRING:\n+      current_max = atoi (XSTR (exp, 0));\n+      break;\n+\n+    case COND:\n+      current_max = max_attr_value (XEXP (exp, 1), unknownp);\n       for (i = 0; i < XVECLEN (exp, 0); i += 2)\n \t{\n-\t  n = max_attr_value (XVECEXP (exp, 0, i + 1));\n+\t  n = max_attr_value (XVECEXP (exp, 0, i + 1), unknownp);\n \t  if (n > current_max)\n \t    current_max = n;\n \t}\n+      break;\n \n-      n = max_attr_value (XEXP (exp, 1));\n+    case IF_THEN_ELSE:\n+      current_max = max_attr_value (XEXP (exp, 1), unknownp);\n+      n = max_attr_value (XEXP (exp, 2), unknownp);\n       if (n > current_max)\n \tcurrent_max = n;\n-    }\n+      break;\n \n-  else if (GET_CODE (exp) == IF_THEN_ELSE)\n-    {\n-      current_max = max_attr_value (XEXP (exp, 1));\n-      n = max_attr_value (XEXP (exp, 2));\n-      if (n > current_max)\n-\tcurrent_max = n;\n+    default:\n+      *unknownp = 1;\n+      current_max = INT_MAX;\n+      break;\n     }\n \n-  else\n-    abort ();\n-\n   return current_max;\n }\n \n /* Given an attribute value, return the result of ORing together all\n-   CONST_STRING arguments encountered.  It is assumed that they are\n-   all numeric.  */\n+   CONST_STRING arguments encountered.  Set *UNKNOWNP and return -1\n+   if the numeric value is not known.  */\n \n static int\n-or_attr_value (exp)\n+or_attr_value (exp, unknownp)\n      rtx exp;\n+     int *unknownp;\n {\n-  int current_or = 0;\n+  int current_or;\n   int i;\n \n-  if (GET_CODE (exp) == CONST_STRING)\n-    return atoi (XSTR (exp, 0));\n-\n-  else if (GET_CODE (exp) == COND)\n+  switch (GET_CODE (exp))\n     {\n+    case CONST_STRING:\n+      current_or = atoi (XSTR (exp, 0));\n+      break;\n+\n+    case COND:\n+      current_or = or_attr_value (XEXP (exp, 1), unknownp);\n       for (i = 0; i < XVECLEN (exp, 0); i += 2)\n-\t{\n-\t  current_or |= or_attr_value (XVECEXP (exp, 0, i + 1));\n-\t}\n+\tcurrent_or |= or_attr_value (XVECEXP (exp, 0, i + 1), unknownp);\n+      break;\n \n-      current_or |= or_attr_value (XEXP (exp, 1));\n-    }\n+    case IF_THEN_ELSE:\n+      current_or = or_attr_value (XEXP (exp, 1), unknownp);\n+      current_or |= or_attr_value (XEXP (exp, 2), unknownp);\n+      break;\n \n-  else if (GET_CODE (exp) == IF_THEN_ELSE)\n-    {\n-      current_or = or_attr_value (XEXP (exp, 1));\n-      current_or |= or_attr_value (XEXP (exp, 2));\n+    default:\n+      *unknownp = 1;\n+      current_or = -1;\n+      break;\n     }\n \n-  else\n-    abort ();\n-\n   return current_or;\n }\n \f\n@@ -4928,14 +4974,7 @@ write_attr_set (attr, indent, value, prefix, suffix, known_true,\n      rtx known_true;\n      int insn_code, insn_index;\n {\n-  if (GET_CODE (value) == CONST_STRING)\n-    {\n-      write_indent (indent);\n-      printf (\"%s \", prefix);\n-      write_attr_value (attr, value);\n-      printf (\"%s\\n\", suffix);\n-    }\n-  else if (GET_CODE (value) == COND)\n+  if (GET_CODE (value) == COND)\n     {\n       /* Assume the default value will be the default of the COND unless we\n \t find an always true expression.  */\n@@ -5009,7 +5048,12 @@ write_attr_set (attr, indent, value, prefix, suffix, known_true,\n \t}\n     }\n   else\n-    abort ();\n+    {\n+      write_indent (indent);\n+      printf (\"%s \", prefix);\n+      write_attr_value (attr, value);\n+      printf (\"%s\\n\", suffix);\n+    }\n }\n \f\n /* Write out the computation for one attribute value.  */\n@@ -5244,10 +5288,53 @@ write_attr_value (attr, value)\n      struct attr_desc *attr;\n      rtx value;\n {\n-  if (GET_CODE (value) != CONST_STRING)\n-    abort ();\n+  int op;\n+\n+  switch (GET_CODE (value))\n+    {\n+    case CONST_STRING:\n+      write_attr_valueq (attr, XSTR (value, 0));\n+      break;\n+\n+    case SYMBOL_REF:\n+      fputs (XSTR (value, 0), stdout);\n+      break;\n+\n+    case ATTR:\n+      {\n+\tstruct attr_desc *attr2 = find_attr (XSTR (value, 0), 0);\n+\tprintf (\"get_attr_%s (%s)\", attr2->name, \n+\t\t(attr2->is_const ? \"\" : \"insn\"));\n+      }\n+      break;\n \n-  write_attr_valueq (attr, XSTR (value, 0));\n+    case PLUS:\n+      op = '+';\n+      goto do_operator;\n+    case MINUS:\n+      op = '-';\n+      goto do_operator;\n+    case MULT:\n+      op = '*';\n+      goto do_operator;\n+    case DIV:\n+      op = '/';\n+      goto do_operator;\n+    case MOD:\n+      op = '%';\n+      goto do_operator;\n+\n+    do_operator:\n+      write_attr_value (attr, XEXP (value, 0));\n+      putchar (' ');\n+      putchar (op);\n+      putchar (' ');\n+      write_attr_value (attr, XEXP (value, 1));\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n }\n \n static void"}]}