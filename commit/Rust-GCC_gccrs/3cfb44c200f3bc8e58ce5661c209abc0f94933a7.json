{"sha": "3cfb44c200f3bc8e58ce5661c209abc0f94933a7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2NmYjQ0YzIwMGYzYmM4ZTU4Y2U1NjYxYzIwOWFiYzBmOTQ5MzNhNw==", "commit": {"author": {"name": "Stefan Olsson", "email": "stefan@snon.net", "date": "2004-01-24T00:21:02Z"}, "committer": {"name": "Loren J. Rittle", "email": "ljrittle@gcc.gnu.org", "date": "2004-01-24T00:21:02Z"}, "message": "mt_allocator.h: Reduce lock contention.\n\n2004-01-23  Stefan Olsson  <stefan@snon.net>\n\n\t* include/ext/mt_allocator.h: Reduce lock contention.\n\nFrom-SVN: r76474", "tree": {"sha": "2969b383dc7f005845add6f17c10218fc9828d8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2969b383dc7f005845add6f17c10218fc9828d8c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3cfb44c200f3bc8e58ce5661c209abc0f94933a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cfb44c200f3bc8e58ce5661c209abc0f94933a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3cfb44c200f3bc8e58ce5661c209abc0f94933a7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cfb44c200f3bc8e58ce5661c209abc0f94933a7/comments", "author": null, "committer": null, "parents": [{"sha": "b4eb7029c3d69eb773a91985bdc1d908602a8a95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4eb7029c3d69eb773a91985bdc1d908602a8a95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4eb7029c3d69eb773a91985bdc1d908602a8a95"}], "stats": {"total": 188, "additions": 121, "deletions": 67}, "files": [{"sha": "43123eeabf6040a2fd557da8c720bcf16e840831", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cfb44c200f3bc8e58ce5661c209abc0f94933a7/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cfb44c200f3bc8e58ce5661c209abc0f94933a7/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=3cfb44c200f3bc8e58ce5661c209abc0f94933a7", "patch": "@@ -1,3 +1,7 @@\n+2004-01-23  Stefan Olsson  <stefan@snon.net>\n+\n+\t* include/ext/mt_allocator.h: Reduce lock contention.\n+\n 2004-01-23  Paolo Carlini  <pcarlini@suse.de>\n \n \tPR libstdc++/13831"}, {"sha": "5fe758a2feaf23433b8b86ec8049be90df9ce9f6", "filename": "libstdc++-v3/include/ext/mt_allocator.h", "status": "modified", "additions": 117, "deletions": 67, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cfb44c200f3bc8e58ce5661c209abc0f94933a7/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cfb44c200f3bc8e58ce5661c209abc0f94933a7/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h?ref=3cfb44c200f3bc8e58ce5661c209abc0f94933a7", "patch": "@@ -269,7 +269,7 @@ namespace __gnu_cxx\n         size_t thread_id = 0;\n #endif\n \n-        block_record* block;\n+        block_record* block = NULL;\n \n         /*\n          * Find out if we have blocks on our freelist.\n@@ -280,9 +280,11 @@ namespace __gnu_cxx\n           {\n             /*\n              * Are we using threads?\n-             * - Yes, lock and check if there are free blocks on the global\n-             *   list (and if not add new ones), get the first one\n-             *   and change owner.\n+             * - Yes, check if there are free blocks on the global\n+             *   list. If so, grab up to block_count blocks in one\n+             *   lock and change ownership. If the global list is \n+             *   empty, we allocate a new chunk and add those blocks \n+             *   directly to our own freelist (with us as owner).\n              * - No, all operations are made directly to global pool 0\n              *   no need to lock or change ownership but check for free\n              *   blocks on global list (and if not add new ones) and\n@@ -291,57 +293,83 @@ namespace __gnu_cxx\n #ifdef __GTHREADS\n             if (__gthread_active_p())\n               {\n+                size_t bin_t = 1 << bin;\n+                size_t block_count =\n+                  _S_chunk_size /(bin_t + sizeof(block_record));\n+\n                 __gthread_mutex_lock(_S_bin[bin].mutex);\n \n                 if (_S_bin[bin].first[0] == NULL)\n                   {\n-                    _S_bin[bin].first[0] =\n-                      (block_record*)malloc(_S_chunk_size);\n+                    /*\n+                     * No need to hold the lock when we are adding a\n+                     * whole chunk to our own list\n+                     */\n+                    __gthread_mutex_unlock(_S_bin[bin].mutex);\n \n-                    if (!_S_bin[bin].first[0])\n-                      {\n-                        __gthread_mutex_unlock(_S_bin[bin].mutex);\n-                        __throw_bad_alloc();\n-                      }\n+                    _S_bin[bin].first[thread_id] =\n+                      (block_record*)malloc(_S_chunk_size);\n \n-                    size_t bin_t = 1 << bin;\n-                    size_t block_count =\n-                      _S_chunk_size /(bin_t + sizeof(block_record));\n+                    if (!_S_bin[bin].first[thread_id])\n+                      __throw_bad_alloc();\n \n-                    _S_bin[bin].free[0] = block_count;\n+                    _S_bin[bin].free[thread_id] = block_count;\n \n                     block_count--;\n-                    block = _S_bin[bin].first[0];\n+                    block = _S_bin[bin].first[thread_id];\n \n                     while (block_count > 0)\n                       {\n                         block->next = (block_record*)((char*)block +\n                                       (bin_t + sizeof(block_record)));\n+                        block->thread_id = thread_id;\n                         block = block->next;\n                         block_count--;\n                       }\n \n                     block->next = NULL;\n-                    _S_bin[bin].last[0] = block;\n+                    block->thread_id = thread_id;\n+                    _S_bin[bin].last[thread_id] = block;\n                   }\n+                else\n+                  {\n+                    size_t global_count = 0;\n \n-                block = _S_bin[bin].first[0];\n+                    while( _S_bin[bin].first[0] != NULL &&\n+                           global_count < block_count )\n+                      {\n+                        block = _S_bin[bin].first[0];\n \n-                /*\n-                 * Remove from list and count down the available counter on\n-                 * global pool 0.\n-                 */\n-                _S_bin[bin].first[0] = _S_bin[bin].first[0]->next;\n-                _S_bin[bin].free[0]--;\n+                        if (_S_bin[bin].first[thread_id] == NULL)\n+                          _S_bin[bin].first[thread_id] = block;\n+                        else\n+                          _S_bin[bin].last[thread_id]->next = block;\n \n-                __gthread_mutex_unlock(_S_bin[bin].mutex);\n+                        _S_bin[bin].last[thread_id] = block;\n+\n+                        block->thread_id = thread_id;\n+\n+                        _S_bin[bin].free[thread_id]++;\n+\n+                        _S_bin[bin].first[0] = _S_bin[bin].first[0]->next;\n+\n+                        global_count++;\n+                      }\n+\n+                    block->next = NULL;\n+\n+                    __gthread_mutex_unlock(_S_bin[bin].mutex);\n+                  }\n \n                 /*\n-                 * Now that we have removed the block from the global\n-                 * freelist we can change owner and update the used\n-                 * counter for this thread without locking.\n+                 * Return the first newly added block in our list and\n+                 * update the counters\n                  */\n-                block->thread_id = thread_id;\n+                block = _S_bin[bin].first[thread_id];\n+                _S_bin[bin].first[thread_id] = \n+                  _S_bin[bin].first[thread_id]->next;\n+\n+                _S_bin[bin].free[thread_id]--;\n                 _S_bin[bin].used[thread_id]++;\n               }\n             else\n@@ -354,9 +382,7 @@ namespace __gnu_cxx\n \n                 size_t bin_t = 1 << bin;\n                 size_t block_count = \n-\t\t  _S_chunk_size / (bin_t + sizeof(block_record));\n-\n-                _S_bin[bin].free[0] = block_count;\n+                  _S_chunk_size / (bin_t + sizeof(block_record));\n \n                 block_count--;\n                 block = _S_bin[bin].first[0];\n@@ -375,12 +401,9 @@ namespace __gnu_cxx\n                 block = _S_bin[bin].first[0];\n \n                 /*\n-                 * Remove from list and count down the available counter on\n-                 * global pool 0 and increase it's used counter.\n+                 * Remove from list\n                  */\n                 _S_bin[bin].first[0] = _S_bin[bin].first[0]->next;\n-                _S_bin[bin].free[0]--;\n-                _S_bin[bin].used[0]++;\n               }\n           }\n         else\n@@ -392,8 +415,14 @@ namespace __gnu_cxx\n             block = _S_bin[bin].first[thread_id];\n \n             _S_bin[bin].first[thread_id] = _S_bin[bin].first[thread_id]->next;\n-            _S_bin[bin].free[thread_id]--;\n-            _S_bin[bin].used[thread_id]++;\n+\n+#ifdef __GTHREADS\n+            if (__gthread_active_p())\n+              {\n+                _S_bin[bin].free[thread_id]--;\n+                _S_bin[bin].used[thread_id]++;\n+              }\n+#endif\n           }\n \n         return static_cast<_Tp*>(static_cast<void*>((char*)block + sizeof(block_record)));\n@@ -424,7 +453,7 @@ namespace __gnu_cxx\n #endif\n \n         block_record* block = (block_record*)((char*)__p\n-\t\t\t\t\t      - sizeof(block_record));\n+                                             - sizeof(block_record));\n \n         /*\n          * This block will always be at the back of a list and thus\n@@ -465,7 +494,6 @@ namespace __gnu_cxx\n                     _S_bin[bin].first[thread_id] =\n                       _S_bin[bin].first[thread_id]->next;\n \n-                    _S_bin[bin].free[0]++;\n                     _S_bin[bin].free[thread_id]--;\n \n                     remove--;\n@@ -509,9 +537,6 @@ namespace __gnu_cxx\n               _S_bin[bin].last[0]->next = block;\n \n             _S_bin[bin].last[0] = block;\n-\n-            _S_bin[bin].free[0]++;\n-            _S_bin[bin].used[0]--;\n           }\n       }\n     };\n@@ -564,7 +589,7 @@ namespace __gnu_cxx\n #ifdef __GTHREADS\n       if (__gthread_active_p())\n         {\n-\t  _S_thread_freelist_first =\n+          _S_thread_freelist_first =\n             (thread_record*)malloc(sizeof(thread_record) * _S_max_threads);\n \n           if (!_S_thread_freelist_first)\n@@ -578,7 +603,7 @@ namespace __gnu_cxx\n           for (i = 1; i < _S_max_threads; i++)\n             {\n               _S_thread_freelist_first[i - 1].next = \n-\t\t&_S_thread_freelist_first[i];\n+                &_S_thread_freelist_first[i];\n \n               _S_thread_freelist_first[i - 1].id = i;\n             }\n@@ -605,52 +630,65 @@ namespace __gnu_cxx\n       if (!_S_bin)\n         __throw_bad_alloc();\n \n-       for (size_t bin = 0; bin < _S_no_of_bins; bin++)\n-        {\n-\t  std::size_t __n = _S_max_threads + 1;\n+      std::size_t __n = 1;\n+\n+#ifdef __GTHREADS\n+      if (__gthread_active_p())\n+        __n = _S_max_threads + 1;\n+#endif\n \n+      for (size_t bin = 0; bin < _S_no_of_bins; bin++)\n+        {\n           _S_bin[bin].first = (block_record**) \n-\t    malloc(sizeof(block_record*) * __n);\n+            malloc(sizeof(block_record*) * __n);\n \n           if (!_S_bin[bin].first)\n             __throw_bad_alloc();\n \n           _S_bin[bin].last = (block_record**) \n-\t    malloc(sizeof(block_record*) * __n);\n+            malloc(sizeof(block_record*) * __n);\n \n           if (!_S_bin[bin].last)\n             __throw_bad_alloc();\n \n-          _S_bin[bin].free = (size_t*) malloc(sizeof(size_t) * __n);\n+#ifdef __GTHREADS\n+          if (__gthread_active_p())\n+            {\n+              _S_bin[bin].free = (size_t*) malloc(sizeof(size_t) * __n);\n \n-          if (!_S_bin[bin].free)\n-            __throw_bad_alloc();\n+              if (!_S_bin[bin].free)\n+                __throw_bad_alloc();\n \n-          _S_bin[bin].used = (size_t*) malloc(sizeof(size_t) * __n);\n+              _S_bin[bin].used = (size_t*) malloc(sizeof(size_t) * __n);\n \n-          if (!_S_bin[bin].used)\n-            __throw_bad_alloc();\n+              if (!_S_bin[bin].used)\n+                __throw_bad_alloc();\n \n-#ifdef __GTHREADS\n-          _S_bin[bin].mutex =(__gthread_mutex_t*) malloc(sizeof(__gthread_mutex_t));\n+              _S_bin[bin].mutex =(__gthread_mutex_t*) malloc(sizeof(__gthread_mutex_t));\n \n #ifdef __GTHREAD_MUTEX_INIT\n-\t  {\n-\t    // Do not copy a POSIX/gthr mutex once in use.\n-\t    __gthread_mutex_t __tmp = __GTHREAD_MUTEX_INIT;\n-\t    *_S_bin[bin].mutex = __tmp;\n-\t  }\n+              {\n+                // Do not copy a POSIX/gthr mutex once in use.\n+                __gthread_mutex_t __tmp = __GTHREAD_MUTEX_INIT;\n+                *_S_bin[bin].mutex = __tmp;\n+              }\n #else\n-\t  { __GTHREAD_MUTEX_INIT_FUNCTION (_S_bin[bin].mutex); }\n+              { __GTHREAD_MUTEX_INIT_FUNCTION (_S_bin[bin].mutex); }\n #endif\n+            }\n #endif\n \n-          for (size_t thread = 0; thread <= _S_max_threads; thread++)\n+          for (size_t thread = 0; thread < __n; thread++)\n             {\n               _S_bin[bin].first[thread] = NULL;\n               _S_bin[bin].last[thread] = NULL;\n-              _S_bin[bin].free[thread] = 0;\n-              _S_bin[bin].used[thread] = 0;\n+#ifdef __GTHREADS\n+              if (__gthread_active_p())\n+                {\n+                  _S_bin[bin].free[thread] = 0;\n+                  _S_bin[bin].used[thread] = 0;\n+                }\n+#endif\n             }\n         }\n \n@@ -783,6 +821,18 @@ namespace __gnu_cxx\n \n   template<typename _Tp> typename __mt_alloc<_Tp>::bin_record*\n   volatile __mt_alloc<_Tp>::_S_bin = NULL;\n+\n+  template<typename _Tp>\n+    inline bool\n+    operator==(const __mt_alloc<_Tp>&,\n+               const __mt_alloc<_Tp>&)\n+    { return true; }\n+  \n+  template<typename _Tp>\n+    inline bool\n+    operator!=(const __mt_alloc<_Tp>&,\n+               const __mt_alloc<_Tp>&)\n+    { return false; }\n } // namespace __gnu_cxx\n \n #endif"}]}