{"sha": "0f75b66845b1ae16de13f02234d4c9be8193f49e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGY3NWI2Njg0NWIxYWUxNmRlMTNmMDIyMzRkNGM5YmU4MTkzZjQ5ZQ==", "commit": {"author": {"name": "Claudiu Zissulescu", "email": "claziss@synopsys.com", "date": "2017-06-01T09:41:46Z"}, "committer": {"name": "Claudiu Zissulescu", "email": "claziss@gcc.gnu.org", "date": "2017-06-01T09:41:46Z"}, "message": "[ARC] Avoid use of hard registers before reg-alloc.\n\ngcc/\n2017-06-01  Claudiu Zissulescu  <claziss@synopsys.com>\n\n\t* config/arc/arc.md (mulsi3): Avoid use of hard registers before\n\treg-alloc when having mul64 or mul32x16 instructions.\n\t(mulsidi3): Likewise.\n\t(umulsidi3): Likewise.\n\t(mulsi32x16): New pattern.\n\t(mulsi64): Likewise.\n\t(mulsidi64): Likewise.\n\t(umulsidi64): Likewise.\n\t(MUL32x16_REG): Define.\n\t(mul64_600): Use MUL32x16_REG.\n\t(mac64_600): Likewise.\n\t(umul64_600): Likewise.\n\t(umac64_600): Likewise.\n\nFrom-SVN: r248777", "tree": {"sha": "30ac40dcf9e874f7249d0d1abdf2d6d5543ab823", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/30ac40dcf9e874f7249d0d1abdf2d6d5543ab823"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f75b66845b1ae16de13f02234d4c9be8193f49e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f75b66845b1ae16de13f02234d4c9be8193f49e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f75b66845b1ae16de13f02234d4c9be8193f49e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f75b66845b1ae16de13f02234d4c9be8193f49e/comments", "author": {"login": "claziss", "id": 2761368, "node_id": "MDQ6VXNlcjI3NjEzNjg=", "avatar_url": "https://avatars.githubusercontent.com/u/2761368?v=4", "gravatar_id": "", "url": "https://api.github.com/users/claziss", "html_url": "https://github.com/claziss", "followers_url": "https://api.github.com/users/claziss/followers", "following_url": "https://api.github.com/users/claziss/following{/other_user}", "gists_url": "https://api.github.com/users/claziss/gists{/gist_id}", "starred_url": "https://api.github.com/users/claziss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/claziss/subscriptions", "organizations_url": "https://api.github.com/users/claziss/orgs", "repos_url": "https://api.github.com/users/claziss/repos", "events_url": "https://api.github.com/users/claziss/events{/privacy}", "received_events_url": "https://api.github.com/users/claziss/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f533fdf6cc37bdc5b1dec5c622733da97a09f97e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f533fdf6cc37bdc5b1dec5c622733da97a09f97e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f533fdf6cc37bdc5b1dec5c622733da97a09f97e"}], "stats": {"total": 184, "additions": 135, "deletions": 49}, "files": [{"sha": "909c1dd8e93967e3f42c6e5046e15e2ba649c692", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f75b66845b1ae16de13f02234d4c9be8193f49e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f75b66845b1ae16de13f02234d4c9be8193f49e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0f75b66845b1ae16de13f02234d4c9be8193f49e", "patch": "@@ -1,3 +1,19 @@\n+2017-06-01  Claudiu Zissulescu  <claziss@synopsys.com>\n+\n+\t* config/arc/arc.md (mulsi3): Avoid use of hard registers before\n+\treg-alloc when having mul64 or mul32x16 instructions.\n+\t(mulsidi3): Likewise.\n+\t(umulsidi3): Likewise.\n+\t(mulsi32x16): New pattern.\n+\t(mulsi64): Likewise.\n+\t(mulsidi64): Likewise.\n+\t(umulsidi64): Likewise.\n+\t(MUL32x16_REG): Define.\n+\t(mul64_600): Use MUL32x16_REG.\n+\t(mac64_600): Likewise.\n+\t(umul64_600): Likewise.\n+\t(umac64_600): Likewise.\n+\n 2017-06-01  Claudiu Zissulescu  <claziss@synopsys.com>\n \n \t* config/arc/arc.md (mulsi3_700): Make it commutative."}, {"sha": "3628efcc098a2d1db1258a5cfd9c90bd7c9f4aab", "filename": "gcc/config/arc/arc.md", "status": "modified", "additions": 119, "deletions": 49, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f75b66845b1ae16de13f02234d4c9be8193f49e/gcc%2Fconfig%2Farc%2Farc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f75b66845b1ae16de13f02234d4c9be8193f49e/gcc%2Fconfig%2Farc%2Farc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.md?ref=0f75b66845b1ae16de13f02234d4c9be8193f49e", "patch": "@@ -176,6 +176,7 @@\n    (ILINK2_REGNUM 30)\n    (RETURN_ADDR_REGNUM 31)\n    (MUL64_OUT_REG 58)\n+   (MUL32x16_REG 56)\n    (ARCV2_ACC 58)\n \n    (LP_COUNT 60)\n@@ -1940,29 +1941,17 @@\n     }\n   else if (TARGET_MUL64_SET)\n     {\n-      emit_insn (gen_mulsi_600 (operands[1], operands[2],\n-\t\t\t\tgen_mlo (), gen_mhi ()));\n-      emit_move_insn (operands[0], gen_mlo ());\n-      DONE;\n+     rtx tmp = gen_reg_rtx (SImode);\n+     emit_insn (gen_mulsi64 (tmp, operands[1], operands[2]));\n+     emit_move_insn (operands[0], tmp);\n+     DONE;\n     }\n   else if (TARGET_MULMAC_32BY16_SET)\n     {\n-      if (immediate_operand (operands[2], SImode)\n-\t  && INTVAL (operands[2]) >= 0\n-\t  && INTVAL (operands[2]) <= 65535)\n-\t{\n-\t  emit_insn (gen_umul_600 (operands[1], operands[2],\n-\t\t\t\t     gen_acc2 (), gen_acc1 ()));\n-\t  emit_move_insn (operands[0], gen_acc2 ());\n-\t  DONE;\n-\t}\n-      operands[2] = force_reg (SImode, operands[2]);\n-      emit_insn (gen_umul_600 (operands[1], operands[2],\n-\t\t\t       gen_acc2 (), gen_acc1 ()));\n-      emit_insn (gen_mac_600 (operands[1], operands[2],\n-\t\t\t       gen_acc2 (), gen_acc1 ()));\n-      emit_move_insn (operands[0], gen_acc2 ());\n-      DONE;\n+     rtx tmp = gen_reg_rtx (SImode);\n+     emit_insn (gen_mulsi32x16 (tmp, operands[1], operands[2]));\n+     emit_move_insn (operands[0], tmp);\n+     DONE;\n     }\n   else\n     {\n@@ -1974,6 +1963,35 @@\n     }\n })\n \n+(define_insn_and_split \"mulsi32x16\"\n+ [(set (match_operand:SI 0 \"register_operand\"            \"=w\")\n+\t(mult:SI (match_operand:SI 1 \"register_operand\"  \"%c\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"ci\")))\n+  (clobber (reg:DI MUL32x16_REG))]\n+ \"TARGET_MULMAC_32BY16_SET\"\n+ \"#\"\n+ \"TARGET_MULMAC_32BY16_SET && reload_completed\"\n+ [(const_int 0)]\n+ {\n+  if (immediate_operand (operands[2], SImode)\n+    && INTVAL (operands[2]) >= 0\n+    && INTVAL (operands[2]) <= 65535)\n+     {\n+      emit_insn (gen_umul_600 (operands[1], operands[2],\n+\t\t\t\t       gen_acc2 (), gen_acc1 ()));\n+      emit_move_insn (operands[0], gen_acc2 ());\n+      DONE;\n+     }\n+   emit_insn (gen_umul_600 (operands[1], operands[2],\n+\t\t\t\t   gen_acc2 (), gen_acc1 ()));\n+   emit_insn (gen_mac_600 (operands[1], operands[2],\n+\t\t\t\t   gen_acc2 (), gen_acc1 ()));\n+   emit_move_insn (operands[0], gen_acc2 ());\n+   DONE;\n+  }\n+ [(set_attr \"type\" \"multi\")\n+  (set_attr \"length\" \"8\")])\n+\n ; mululw conditional execution without a LIMM clobbers an input register;\n ; we'd need a different pattern to describe this.\n ; To make the conditional execution valid for the LIMM alternative, we\n@@ -2011,6 +2029,24 @@\n    (set_attr \"predicable\" \"no, no, yes\")\n    (set_attr \"cond\" \"nocond, canuse_limm, canuse\")])\n \n+(define_insn_and_split \"mulsi64\"\n+ [(set (match_operand:SI 0 \"register_operand\"            \"=w\")\n+\t(mult:SI (match_operand:SI 1 \"register_operand\"  \"%c\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"ci\")))\n+  (clobber (reg:DI MUL64_OUT_REG))]\n+ \"TARGET_MUL64_SET\"\n+ \"#\"\n+ \"TARGET_MUL64_SET && reload_completed\"\n+  [(const_int 0)]\n+{\n+  emit_insn (gen_mulsi_600 (operands[1], operands[2],\n+\t\t\tgen_mlo (), gen_mhi ()));\n+  emit_move_insn (operands[0], gen_mlo ());\n+  DONE;\n+}\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"8\")])\n+\n (define_insn \"mulsi_600\"\n   [(set (match_operand:SI 2 \"mlo_operand\" \"\")\n \t(mult:SI (match_operand:SI 0 \"register_operand\"  \"%Rcq#q,c,c,c\")\n@@ -2155,8 +2191,7 @@\n \t(mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"\"))\n \t\t (sign_extend:DI (match_operand:SI 2 \"nonmemory_operand\" \"\"))))]\n   \"TARGET_ANY_MPY\"\n-\"\n-{\n+  {\n   if (TARGET_PLUS_MACD)\n     {\n      if (CONST_INT_P (operands[2]))\n@@ -2189,18 +2224,37 @@\n     }\n   else if (TARGET_MULMAC_32BY16_SET)\n     {\n-      rtx result_hi = gen_highpart(SImode, operands[0]);\n-      rtx result_low = gen_lowpart(SImode, operands[0]);\n-\n-      emit_insn (gen_mul64_600 (operands[1], operands[2]));\n-      emit_insn (gen_mac64_600 (result_hi, operands[1], operands[2]));\n-      emit_move_insn (result_low, gen_acc2 ());\n+      operands[2] = force_reg (SImode, operands[2]);\n+      emit_insn (gen_mulsidi64 (operands[0], operands[1], operands[2]));\n       DONE;\n     }\n-}\")\n+  operands[2] = force_reg (SImode, operands[2]);\n+  })\n+\n+(define_insn_and_split \"mulsidi64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=w\")\n+\t(mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"%c\"))\n+\t\t (sign_extend:DI (match_operand:SI 2 \"extend_operand\" \"ci\"))))\n+   (clobber (reg:DI MUL32x16_REG))]\n+  \"TARGET_MULMAC_32BY16_SET\"\n+  \"#\"\n+  \"TARGET_MULMAC_32BY16_SET && reload_completed\"\n+  [(const_int 0)]\n+  {\n+   rtx result_hi = gen_highpart (SImode, operands[0]);\n+   rtx result_low = gen_lowpart (SImode, operands[0]);\n+\n+   emit_insn (gen_mul64_600 (operands[1], operands[2]));\n+   emit_insn (gen_mac64_600 (result_hi, operands[1], operands[2]));\n+   emit_move_insn (result_low, gen_acc2 ());\n+   DONE;\n+  }\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"8\")])\n+\n \n (define_insn \"mul64_600\"\n-  [(set (reg:DI 56)\n+  [(set (reg:DI MUL32x16_REG)\n \t(mult:DI (sign_extend:DI (match_operand:SI 0 \"register_operand\"\n \t\t\t\t  \"c,c,c\"))\n \t\t (zero_extract:DI (match_operand:SI 1 \"nonmemory_operand\"\n@@ -2218,14 +2272,14 @@\n \n ;; ??? check if this is canonical rtl\n (define_insn \"mac64_600\"\n-  [(set (reg:DI 56)\n+  [(set (reg:DI MUL32x16_REG)\n \t(plus:DI\n \t  (mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"c,c,c\"))\n \t\t   (ashift:DI\n \t\t     (sign_extract:DI (match_operand:SI 2 \"nonmemory_operand\" \"c,L,Cal\")\n \t\t\t\t      (const_int 16) (const_int 16))\n \t\t     (const_int 16)))\n-\t  (reg:DI 56)))\n+\t  (reg:DI MUL32x16_REG)))\n    (set (match_operand:SI 0 \"register_operand\" \"=w,w,w\")\n \t(zero_extract:SI\n \t  (plus:DI\n@@ -2234,7 +2288,7 @@\n \t\t       (sign_extract:DI (match_dup 2)\n \t\t\t\t\t(const_int 16) (const_int 16))\n \t\t\t  (const_int 16)))\n-\t    (reg:DI 56))\n+\t    (reg:DI MUL32x16_REG))\n \t  (const_int 32) (const_int 32)))]\n   \"TARGET_MULMAC_32BY16_SET\"\n   \"machlw%? %0, %1, %2\"\n@@ -2428,20 +2482,14 @@\n     }\n   else if (TARGET_MUL64_SET)\n     {\n-      emit_insn (gen_umulsidi_600 (operands[0], operands[1], operands[2]));\n+     operands[2] = force_reg (SImode, operands[2]);\n+     emit_insn (gen_umulsidi_600 (operands[0], operands[1], operands[2]));\n       DONE;\n     }\n   else if (TARGET_MULMAC_32BY16_SET)\n     {\n-      rtx result_hi = gen_reg_rtx (SImode);\n-      rtx result_low = gen_reg_rtx (SImode);\n-\n-      result_hi = gen_highpart(SImode , operands[0]);\n-      result_low = gen_lowpart(SImode , operands[0]);\n-\n-      emit_insn (gen_umul64_600 (operands[1], operands[2]));\n-      emit_insn (gen_umac64_600 (result_hi, operands[1], operands[2]));\n-      emit_move_insn (result_low, gen_acc2 ());\n+     operands[2] = force_reg (SImode, operands[2]);\n+     emit_insn (gen_umulsidi64 (operands[0], operands[1], operands[2]));\n       DONE;\n     }\n   else\n@@ -2454,8 +2502,32 @@\n     }\n })\n \n+(define_insn_and_split \"umulsidi64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=w\")\n+\t(mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"%c\"))\n+\t\t (zero_extend:DI (match_operand:SI 2 \"extend_operand\" \"ci\"))))\n+   (clobber (reg:DI MUL32x16_REG))]\n+  \"TARGET_MULMAC_32BY16_SET\"\n+  \"#\"\n+  \"TARGET_MULMAC_32BY16_SET && reload_completed\"\n+  [(const_int 0)]\n+  {\n+   rtx result_hi;\n+   rtx result_low;\n+\n+   result_hi = gen_highpart (SImode, operands[0]);\n+   result_low = gen_lowpart (SImode, operands[0]);\n+\n+   emit_insn (gen_umul64_600 (operands[1], operands[2]));\n+   emit_insn (gen_umac64_600 (result_hi, operands[1], operands[2]));\n+   emit_move_insn (result_low, gen_acc2 ());\n+   DONE;\n+   }\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"8\")])\n+\n (define_insn \"umul64_600\"\n-  [(set (reg:DI 56)\n+  [(set (reg:DI MUL32x16_REG)\n \t(mult:DI (zero_extend:DI (match_operand:SI 0 \"register_operand\"\n \t\t\t\t  \"c,c,c\"))\n \t\t (zero_extract:DI (match_operand:SI 1 \"nonmemory_operand\"\n@@ -2472,14 +2544,14 @@\n \n \n (define_insn \"umac64_600\"\n-  [(set (reg:DI 56)\n+  [(set (reg:DI MUL32x16_REG)\n \t(plus:DI\n \t  (mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"c,c,c\"))\n \t\t   (ashift:DI\n \t\t     (zero_extract:DI (match_operand:SI 2 \"nonmemory_operand\" \"c,L,Cal\")\n \t\t\t\t      (const_int 16) (const_int 16))\n \t\t     (const_int 16)))\n-\t  (reg:DI 56)))\n+\t  (reg:DI MUL32x16_REG)))\n    (set (match_operand:SI 0 \"register_operand\" \"=w,w,w\")\n \t(zero_extract:SI\n \t  (plus:DI\n@@ -2488,7 +2560,7 @@\n \t\t       (zero_extract:DI (match_dup 2)\n \t\t\t\t\t(const_int 16) (const_int 16))\n \t\t\t  (const_int 16)))\n-\t    (reg:DI 56))\n+\t    (reg:DI MUL32x16_REG))\n \t  (const_int 32) (const_int 32)))]\n   \"TARGET_MULMAC_32BY16_SET\"\n   \"machulw%? %0, %1, %2\"\n@@ -2497,8 +2569,6 @@\n    (set_attr \"predicable\" \"no,no,yes\")\n    (set_attr \"cond\" \"nocond, canuse_limm, canuse\")])\n \n-\n-\n ;; DI <- DI(unsigned SI) * DI(unsigned SI)\n (define_insn_and_split \"umulsidi3_700\"\n   [(set (match_operand:DI 0 \"dest_reg_operand\" \"=&r\")"}]}