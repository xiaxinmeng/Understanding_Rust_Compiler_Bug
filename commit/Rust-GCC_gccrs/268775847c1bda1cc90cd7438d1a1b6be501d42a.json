{"sha": "268775847c1bda1cc90cd7438d1a1b6be501d42a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjY4Nzc1ODQ3YzFiZGExY2M5MGNkNzQzOGQxYTFiNmJlNTAxZDQyYQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1998-07-15T04:38:53Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-07-15T04:38:53Z"}, "message": "method.c (build_decl_overload_real): Fix namespace handling.\n\n\t* method.c (build_decl_overload_real): Fix namespace handling.\n\t* typeck.c (build_unary_op): Extract a lone function from an\n\tOVERLOAD.\n\t* call.c (build_scoped_method_call): Handle getting a namespace\n\tfor basetype in a destructor call.\n\t(check_dtor_name): Handle enums.\n\t* parse.y (using_directive): New nonterminal.\n\t(extdef, simple_stmt): Use it.\n\nFrom-SVN: r21174", "tree": {"sha": "b92a219486412be8543c51da01be00e225f6766a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b92a219486412be8543c51da01be00e225f6766a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/268775847c1bda1cc90cd7438d1a1b6be501d42a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/268775847c1bda1cc90cd7438d1a1b6be501d42a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/268775847c1bda1cc90cd7438d1a1b6be501d42a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/268775847c1bda1cc90cd7438d1a1b6be501d42a/comments", "author": null, "committer": null, "parents": [{"sha": "8508a96d6b018899c83cdeebf2fd2ef46f39605d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8508a96d6b018899c83cdeebf2fd2ef46f39605d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8508a96d6b018899c83cdeebf2fd2ef46f39605d"}], "stats": {"total": 8598, "additions": 4318, "deletions": 4280}, "files": [{"sha": "9b4b7af4649f69025c61057a02214e10c32a41ce", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268775847c1bda1cc90cd7438d1a1b6be501d42a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268775847c1bda1cc90cd7438d1a1b6be501d42a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=268775847c1bda1cc90cd7438d1a1b6be501d42a", "patch": "@@ -1,3 +1,17 @@\n+1998-07-15  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* method.c (build_decl_overload_real): Fix namespace handling.\n+\n+\t* typeck.c (build_unary_op): Extract a lone function from an\n+\tOVERLOAD.\n+\n+\t* call.c (build_scoped_method_call): Handle getting a namespace\n+\tfor basetype in a destructor call.\n+\t(check_dtor_name): Handle enums.\n+\n+\t* parse.y (using_directive): New nonterminal.\n+\t(extdef, simple_stmt): Use it.\n+\n 1998-07-14  Martin von L\ufffdwis  <loewis@informatik.hu-berlin.de>\n \n \t* decl2.c (add_function): Move error message ..."}, {"sha": "3e11a741fa5ccdf5329dd2c75d00bfe56cf54a97", "filename": "gcc/cp/call.c", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268775847c1bda1cc90cd7438d1a1b6be501d42a/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268775847c1bda1cc90cd7438d1a1b6be501d42a/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=268775847c1bda1cc90cd7438d1a1b6be501d42a", "patch": "@@ -356,7 +356,9 @@ check_dtor_name (basetype, name)\n     /* OK */;\n   else if (TREE_CODE (name) == IDENTIFIER_NODE)\n     {\n-      if (IS_AGGR_TYPE (basetype) && name == constructor_name (basetype))\n+      if ((IS_AGGR_TYPE (basetype) && name == constructor_name (basetype))\n+\t  || (TREE_CODE (basetype) == ENUMERAL_TYPE\n+\t      && name == TYPE_IDENTIFIER (basetype)))\n \tname = basetype;\n       else\n \tname = get_type_value (name);\n@@ -414,20 +416,29 @@ build_scoped_method_call (exp, basetype, name, parms)\n     binfo = NULL_TREE;\n \n   /* Check the destructor call syntax.  */\n-  if (TREE_CODE (name) == BIT_NOT_EXPR && ! check_dtor_name (basetype, name))\n-    cp_error (\"qualified type `%T' does not match destructor name `~%T'\",\n-\t      basetype, TREE_OPERAND (name, 0));\n-\n-  /* Destructors can be \"called\" for simple types; see 5.2.4 and 12.4 Note\n-     that explicit ~int is caught in the parser; this deals with typedefs\n-     and template parms.  */\n-  if (TREE_CODE (name) == BIT_NOT_EXPR && ! IS_AGGR_TYPE (basetype))\n+  if (TREE_CODE (name) == BIT_NOT_EXPR)\n     {\n-      if (TYPE_MAIN_VARIANT (type) != TYPE_MAIN_VARIANT (basetype))\n-\tcp_error (\"type of `%E' does not match destructor type `%T' (type was `%T')\",\n-\t\t  exp, basetype, type);\n-      \n-      return cp_convert (void_type_node, exp);\n+      /* We can get here if someone writes their destructor call like\n+\t `obj.NS::~T()'; this isn't really a scoped method call, so hand\n+\t it off.  */\n+      if (TREE_CODE (basetype) == NAMESPACE_DECL)\n+\treturn build_method_call (exp, name, parms, NULL_TREE, LOOKUP_NORMAL);\n+\n+      if (! check_dtor_name (basetype, name))\n+\tcp_error (\"qualified type `%T' does not match destructor name `~%T'\",\n+\t\t  basetype, TREE_OPERAND (name, 0));\n+\n+      /* Destructors can be \"called\" for simple types; see 5.2.4 and 12.4 Note\n+\t that explicit ~int is caught in the parser; this deals with typedefs\n+\t and template parms.  */\n+      if (! IS_AGGR_TYPE (basetype))\n+\t{\n+\t  if (TYPE_MAIN_VARIANT (type) != TYPE_MAIN_VARIANT (basetype))\n+\t    cp_error (\"type of `%E' does not match destructor type `%T' (type was `%T')\",\n+\t\t      exp, basetype, type);\n+\n+\t  return cp_convert (void_type_node, exp);\n+\t}\n     }\n \n   if (! is_aggr_type (basetype, 1))"}, {"sha": "6c4fd46d192814c49a732abf2f9941c4a91a8ca3", "filename": "gcc/cp/method.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268775847c1bda1cc90cd7438d1a1b6be501d42a/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268775847c1bda1cc90cd7438d1a1b6be501d42a/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=268775847c1bda1cc90cd7438d1a1b6be501d42a", "patch": "@@ -1539,7 +1539,8 @@ build_decl_overload_real (dname, parms, ret_type, tparms, targs,\n        as the declaration. Unfortunately, we don't have the _DECL,\n        only its name */\n     OB_PUTC ('F');\n-  else if (!for_method)\n+\n+  if (!for_method && current_namespace != global_namespace)\n     /* qualify with namespace */\n     build_qualified_name (current_namespace);\n "}, {"sha": "fe60dd06ef98dad3353c1a3f78a56462dbdbc984", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 4251, "deletions": 4246, "changes": 8497, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268775847c1bda1cc90cd7438d1a1b6be501d42a/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268775847c1bda1cc90cd7438d1a1b6be501d42a/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=268775847c1bda1cc90cd7438d1a1b6be501d42a"}, {"sha": "f08393cde58e9938f69899a1333a4bb7ed1f6fd5", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268775847c1bda1cc90cd7438d1a1b6be501d42a/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268775847c1bda1cc90cd7438d1a1b6be501d42a/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=268775847c1bda1cc90cd7438d1a1b6be501d42a", "patch": "@@ -405,7 +405,7 @@ extdef:\n \t\t{ pop_namespace (); }\n \t| NAMESPACE identifier '=' \n                 { begin_only_namespace_names (); }\n-                any_id ';'\n+          any_id ';'\n \t\t{\n \t\t  end_only_namespace_names ();\n \t\t  if (lastiddecl)\n@@ -414,18 +414,7 @@ extdef:\n \t\t}\n \t| using_decl ';'\n \t\t{ do_toplevel_using_decl ($1); }\n-\t| USING NAMESPACE\n-\t\t{ begin_only_namespace_names (); }\n-\t\tany_id ';'\n-\t\t{\n-\t\t  end_only_namespace_names ();\n-\t\t  /* If no declaration was found, the using-directive is\n-\t\t     invalid. Since that was not reported, we need the\n-\t\t     identifier for the error message. */\n-\t\t  if (TREE_CODE ($4) == IDENTIFIER_NODE && lastiddecl)\n-\t\t    $4 = lastiddecl;\n-\t\t  do_using_directive ($4);\n-\t\t}\n+\t| using_directive\n \t| extension extdef\n \t\t{ pedantic = $<itype>1; }\n \t;\n@@ -448,6 +437,21 @@ namespace_using_decl:\n \t        { $$ = build_parse_node (SCOPE_REF, $3, $4); }\n \t;\n \n+using_directive:\n+\t  USING NAMESPACE\n+\t\t{ begin_only_namespace_names (); }\n+\t  any_id ';'\n+\t\t{\n+\t\t  end_only_namespace_names ();\n+\t\t  /* If no declaration was found, the using-directive is\n+\t\t     invalid. Since that was not reported, we need the\n+\t\t     identifier for the error message. */\n+\t\t  if (TREE_CODE ($4) == IDENTIFIER_NODE && lastiddecl)\n+\t\t    $4 = lastiddecl;\n+\t\t  do_using_directive ($4);\n+\t\t}\n+\t;\n+\n namespace_qualifier:\n \t  NSNAME SCOPE\n \t\t{\n@@ -3281,12 +3285,7 @@ simple_stmt:\n \t| ';'\n \t\t{ finish_stmt (); }\n \t| try_block\n-\t| USING NAMESPACE any_id ';'\n-\t\t{ \n-\t\t  if (TREE_CODE ($3) == IDENTIFIER_NODE && lastiddecl)\n-\t\t    $3 = lastiddecl;\n-\t\t  do_using_directive ($3); \n-\t\t}\n+\t| using_directive\n \t| namespace_using_decl\n \t        { do_local_using_decl ($1); }\n \t;"}, {"sha": "7ac9cf1f6c0674ba05e6fd1fcad8420f829b0a76", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268775847c1bda1cc90cd7438d1a1b6be501d42a/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268775847c1bda1cc90cd7438d1a1b6be501d42a/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=268775847c1bda1cc90cd7438d1a1b6be501d42a", "patch": "@@ -4547,6 +4547,14 @@ build_unary_op (code, xarg, noconvert)\n \t  return build1 (ADDR_EXPR, unknown_type_node, arg);\n \t}\n \n+      /* If we have a single function from a using decl, pull it out.  */\n+      if (TREE_CODE (arg) == OVERLOAD\n+\t  && ! really_overloaded_fn (arg))\n+\t{\n+\t  arg = OVL_FUNCTION (arg);\n+\t  argtype = TREE_TYPE (arg);\n+\t}\n+\n       if (TREE_CODE (arg) == OVERLOAD \n \t  || (TREE_CODE (arg) == OFFSET_REF\n \t      && TREE_CODE (TREE_OPERAND (arg, 1)) == TEMPLATE_ID_EXPR))"}]}