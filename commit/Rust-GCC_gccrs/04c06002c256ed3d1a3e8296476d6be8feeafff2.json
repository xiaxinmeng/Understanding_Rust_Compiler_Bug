{"sha": "04c06002c256ed3d1a3e8296476d6be8feeafff2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDRjMDYwMDJjMjU2ZWQzZDFhM2U4Mjk2NDc2ZDZiZThmZWVhZmZmMg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2003-10-22T23:42:47Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2003-10-22T23:42:47Z"}, "message": "call.c: Fix comment formatting.\n\n\t* call.c: Fix comment formatting.\n\t* class.c: Likewise.\n\t* cxx-pretty-print.c: Likewise.\n\t* init.c: Likewise.\n\t* parser.c: Likewise.\n\t* pt.c: Likewise.\n\t* semantics.c: Likewise.\n\t* tree.c: Likewise.\n\t* typeck.c: Likewise.\n\t* typeck2.c: Likewise.\n\nFrom-SVN: r72828", "tree": {"sha": "f72ffc26c6ebb119ba1601c12a4684c2b5d067d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f72ffc26c6ebb119ba1601c12a4684c2b5d067d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/04c06002c256ed3d1a3e8296476d6be8feeafff2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04c06002c256ed3d1a3e8296476d6be8feeafff2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04c06002c256ed3d1a3e8296476d6be8feeafff2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04c06002c256ed3d1a3e8296476d6be8feeafff2/comments", "author": null, "committer": null, "parents": [{"sha": "3cfa37023cc9d77ec91331d215387c1429e442b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cfa37023cc9d77ec91331d215387c1429e442b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3cfa37023cc9d77ec91331d215387c1429e442b3"}], "stats": {"total": 61, "additions": 37, "deletions": 24}, "files": [{"sha": "5096f74d4f1a30fd6f1f861e598fb5c02c6c0962", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04c06002c256ed3d1a3e8296476d6be8feeafff2/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04c06002c256ed3d1a3e8296476d6be8feeafff2/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=04c06002c256ed3d1a3e8296476d6be8feeafff2", "patch": "@@ -1,3 +1,16 @@\n+2003-10-22  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* call.c: Fix comment formatting.\n+\t* class.c: Likewise.\n+\t* cxx-pretty-print.c: Likewise.\n+\t* init.c: Likewise.\n+\t* parser.c: Likewise.\n+\t* pt.c: Likewise.\n+\t* semantics.c: Likewise.\n+\t* tree.c: Likewise.\n+\t* typeck.c: Likewise.\n+\t* typeck2.c: Likewise.\n+\n 2003-10-21  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/11962"}, {"sha": "e7bbd22fc452f69c7a8dc1e85e5fa3d882e8a6bf", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04c06002c256ed3d1a3e8296476d6be8feeafff2/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04c06002c256ed3d1a3e8296476d6be8feeafff2/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=04c06002c256ed3d1a3e8296476d6be8feeafff2", "patch": "@@ -619,7 +619,7 @@ standard_conversion (tree to, tree from, tree expr)\n   else if (fromref || (expr && lvalue_p (expr)))\n     conv = build_conv (RVALUE_CONV, from, conv);\n \n-   /* Allow conversion between `__complex__' data types  */\n+   /* Allow conversion between `__complex__' data types.  */\n   if (tcode == COMPLEX_TYPE && fcode == COMPLEX_TYPE)\n     {\n       /* The standard conversion sequence to convert FROM to TO is"}, {"sha": "da9a1250830e5c855c8443d79ed852dfcf070041", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04c06002c256ed3d1a3e8296476d6be8feeafff2/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04c06002c256ed3d1a3e8296476d6be8feeafff2/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=04c06002c256ed3d1a3e8296476d6be8feeafff2", "patch": "@@ -6051,7 +6051,7 @@ instantiate_type (tree lhstype, tree rhs, tsubst_flags_t flags)\n \n \tif (addr != error_mark_node\n \t    && TREE_SIDE_EFFECTS (TREE_OPERAND (rhs, 0)))\n-\t  /* Do not lose object's side effects. */\n+\t  /* Do not lose object's side effects.  */\n \t  addr = build (COMPOUND_EXPR, TREE_TYPE (addr),\n \t\t\tTREE_OPERAND (rhs, 0), addr);\n \treturn addr;"}, {"sha": "ca8c603c0e3f9818f10049169ef173ed91f43992", "filename": "gcc/cp/cxx-pretty-print.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04c06002c256ed3d1a3e8296476d6be8feeafff2/gcc%2Fcp%2Fcxx-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04c06002c256ed3d1a3e8296476d6be8feeafff2/gcc%2Fcp%2Fcxx-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.c?ref=04c06002c256ed3d1a3e8296476d6be8feeafff2", "patch": "@@ -91,7 +91,7 @@ pp_cxx_colon_colon (cxx_pretty_printer *pp)\n }\n \n \n-/* Expressions. */\n+/* Expressions.  */\n \n static inline bool\n is_destructor_name (tree name)\n@@ -1584,7 +1584,7 @@ pp_cxx_canonical_template_parameter (cxx_pretty_printer *pp, tree parm)\n {\n   const enum tree_code code = TREE_CODE (parm);\n \n-  /* Brings type template parameters to the canonical forms  */\n+  /* Brings type template parameters to the canonical forms.  */\n   if (code == TEMPLATE_TYPE_PARM || code == TEMPLATE_TEMPLATE_PARM\n       || code == BOUND_TEMPLATE_TEMPLATE_PARM)\n     parm = TEMPLATE_TYPE_PARM_INDEX (parm);"}, {"sha": "735215377a3b6f02d59f6361e065b1ea4f42ff58", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04c06002c256ed3d1a3e8296476d6be8feeafff2/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04c06002c256ed3d1a3e8296476d6be8feeafff2/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=04c06002c256ed3d1a3e8296476d6be8feeafff2", "patch": "@@ -2713,7 +2713,7 @@ build_vec_init (tree base, tree maxindex, tree init, int from_array)\n \n   stmt_expr = finish_init_stmts (is_global, stmt_expr, compound_stmt);\n \n-  /* Now convert make the result have the correct type. */\n+  /* Now convert make the result have the correct type.  */\n   atype = build_pointer_type (atype);\n   stmt_expr = build1 (NOP_EXPR, atype, stmt_expr);\n   stmt_expr = build_indirect_ref (stmt_expr, NULL);"}, {"sha": "5a0c96ebf9ebf79f1ba271e061c062237bbccdfe", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04c06002c256ed3d1a3e8296476d6be8feeafff2/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04c06002c256ed3d1a3e8296476d6be8feeafff2/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=04c06002c256ed3d1a3e8296476d6be8feeafff2", "patch": "@@ -1054,7 +1054,7 @@ typedef enum cp_parser_declarator_kind\n   CP_PARSER_DECLARATOR_ABSTRACT,\n   /* We want a named declarator.  */\n   CP_PARSER_DECLARATOR_NAMED,\n-  /* We don't mind, but the name must be an unqualified-id  */\n+  /* We don't mind, but the name must be an unqualified-id.  */\n   CP_PARSER_DECLARATOR_EITHER\n } cp_parser_declarator_kind;\n \n@@ -1260,7 +1260,7 @@ typedef struct cp_parser GTY(())\n   unsigned num_template_parameter_lists;\n } cp_parser;\n \n-/* The type of a function that parses some kind of expression  */\n+/* The type of a function that parses some kind of expression.  */\n typedef tree (*cp_parser_expression_fn) (cp_parser *);\n \n /* Prototypes.  */\n@@ -5294,7 +5294,7 @@ cp_parser_expression_statement (cp_parser* parser, bool in_statement_expr_p)\n   tree statement = NULL_TREE;\n \n   /* If the next token is a ';', then there is no expression\n-     statement. */\n+     statement.  */\n   if (cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n     statement = cp_parser_expression (parser);\n   \n@@ -7735,7 +7735,7 @@ cp_parser_template_name (cp_parser* parser,\n      template-argument\n      template-argument-list , template-argument\n \n-   Returns a TREE_VEC containing the arguments.   */\n+   Returns a TREE_VEC containing the arguments.  */\n \n static tree\n cp_parser_template_argument_list (cp_parser* parser)\n@@ -7751,7 +7751,7 @@ cp_parser_template_argument_list (cp_parser* parser)\n       tree argument;\n \n       if (n_args)\n-\t/* Consume the comma. */\n+\t/* Consume the comma.  */\n \tcp_lexer_consume_token (parser->lexer);\n       \n       /* Parse the template-argument.  */\n@@ -7864,7 +7864,7 @@ cp_parser_template_argument (cp_parser* parser)\n \n      -- the address of an object or function with external linkage...\n \n-     -- a pointer to member... */\n+     -- a pointer to member...  */\n   /* Look for a non-type template parameter.  */\n   if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n     {\n@@ -7941,7 +7941,7 @@ cp_parser_template_argument (cp_parser* parser)\n       cp_parser_error (parser, \"invalid non-type template argument\");\n       return error_mark_node;\n     }\n-  /* The argument must be a constant-expression. */\n+  /* The argument must be a constant-expression.  */\n   argument = cp_parser_constant_expression (parser, \n \t\t\t\t\t    /*allow_non_constant_p=*/false,\n \t\t\t\t\t    /*non_constant_p=*/NULL);\n@@ -8306,7 +8306,7 @@ cp_parser_simple_type_specifier (cp_parser* parser, cp_parser_flags flags,\n \n \t/* Consume the `typeof' token.  */\n \tcp_lexer_consume_token (parser->lexer);\n-\t/* Parse the operand to `typeof'  */\n+\t/* Parse the operand to `typeof'.  */\n \toperand = cp_parser_sizeof_operand (parser, RID_TYPEOF);\n \t/* If it is not already a TYPE, take its type.  */\n \tif (!TYPE_P (operand))\n@@ -12045,7 +12045,7 @@ cp_parser_member_declaration (cp_parser* parser)\n \t\t\t\t\t       CPP_SEMICOLON))\n \t    {\n \t      cp_parser_error (parser, \"expected `;'\");\n-\t      /* Skip tokens until we find a `;'  */\n+\t      /* Skip tokens until we find a `;'.  */\n \t      cp_parser_skip_to_end_of_statement (parser);\n \n \t      break;"}, {"sha": "0b2be7a57d66653efc64ed3ceed83b45af9cd4a1", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04c06002c256ed3d1a3e8296476d6be8feeafff2/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04c06002c256ed3d1a3e8296476d6be8feeafff2/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=04c06002c256ed3d1a3e8296476d6be8feeafff2", "patch": "@@ -3631,7 +3631,7 @@ coerce_template_parms (tree parms,\n       if (i < nargs)\n \targ = TREE_VEC_ELT (inner_args, i);\n       else if (require_all_arguments)\n-\t/* There must be a default arg in this case. */\n+\t/* There must be a default arg in this case.  */\n \targ = tsubst_template_arg (TREE_PURPOSE (parm), new_args,\n \t\t\t\t   complain, in_decl);\n       else\n@@ -7045,7 +7045,7 @@ tsubst_baselink (tree baselink, tree object_type,\n        class, rather than the instantiated class.  \n \n        In addition, lookups that were not ambiguous before may be\n-       ambiguous now.  Therefore, we perform the lookup again. */\n+       ambiguous now.  Therefore, we perform the lookup again.  */\n     qualifying_scope = BINFO_TYPE (BASELINK_ACCESS_BINFO (baselink));\n     fns = BASELINK_FUNCTIONS (baselink);\n     if (TREE_CODE (fns) == TEMPLATE_ID_EXPR)\n@@ -7902,7 +7902,7 @@ tsubst_copy_and_build (tree t,\n     {\n     case USING_DECL:\n       t = DECL_NAME (t);\n-      /* Fallthrough. */\n+      /* Fallthrough.  */\n     case IDENTIFIER_NODE:\n       {\n \ttree decl;\n@@ -11383,7 +11383,7 @@ dependent_type_p_r (tree type)\n   if (TREE_CODE (type) == BOUND_TEMPLATE_TEMPLATE_PARM)\n     return true;\n   /* ... or any of the template arguments is a dependent type or\n-\tan expression that is type-dependent or value-dependent.   */\n+\tan expression that is type-dependent or value-dependent.  */\n   else if (CLASS_TYPE_P (type) && CLASSTYPE_TEMPLATE_INFO (type)\n \t   && (any_dependent_template_arguments_p \n \t       (INNERMOST_TEMPLATE_ARGS (CLASSTYPE_TI_ARGS (type)))))"}, {"sha": "bdbf8ef3a4232c001b5adefab6157bb7f34d96af", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04c06002c256ed3d1a3e8296476d6be8feeafff2/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04c06002c256ed3d1a3e8296476d6be8feeafff2/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=04c06002c256ed3d1a3e8296476d6be8feeafff2", "patch": "@@ -1009,7 +1009,7 @@ begin_compound_stmt (bool has_no_scope)\n   return r;\n }\n \n-/* Finish a compound-statement, which is given by COMPOUND_STMT. */\n+/* Finish a compound-statement, which is given by COMPOUND_STMT.  */\n \n tree\n finish_compound_stmt (tree compound_stmt)"}, {"sha": "bfcf741563be7e341ce78ecfe0b187030d973447", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04c06002c256ed3d1a3e8296476d6be8feeafff2/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04c06002c256ed3d1a3e8296476d6be8feeafff2/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=04c06002c256ed3d1a3e8296476d6be8feeafff2", "patch": "@@ -1353,7 +1353,7 @@ build_min_non_dep (enum tree_code code, tree non_dep, ...)\n \n   if (code == COMPOUND_EXPR && TREE_CODE (non_dep) != COMPOUND_EXPR)\n     /* This should not be considered a COMPOUND_EXPR, because it\n-       resolves to an overload. */\n+       resolves to an overload.  */\n     COMPOUND_EXPR_OVERLOADED (t) = 1;\n   \n   va_end (p);"}, {"sha": "26c6f2c33a63c240c410c6bbb20f51670ed693fe", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04c06002c256ed3d1a3e8296476d6be8feeafff2/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04c06002c256ed3d1a3e8296476d6be8feeafff2/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=04c06002c256ed3d1a3e8296476d6be8feeafff2", "patch": "@@ -4302,7 +4302,7 @@ build_x_conditional_expr (tree ifexp, tree op1, tree op2)\n }\n \f\n /* Given a list of expressions, return a compound expression\n-   that performs them all and returns the value of the last of them. */\n+   that performs them all and returns the value of the last of them.  */\n \n tree build_x_compound_expr_from_list (tree list, const char *msg)\n {\n@@ -4348,7 +4348,7 @@ build_x_compound_expr (tree op1, tree op2)\n   return result;\n }\n \n-/* Build a compound expression. */\n+/* Build a compound expression.  */\n \n tree\n build_compound_expr (tree lhs, tree rhs)\n@@ -4754,7 +4754,7 @@ build_c_cast (tree type, tree expr)\n     {\n       tree t = build_min (CAST_EXPR, type,\n \t\t\t  tree_cons (NULL_TREE, value, NULL_TREE));\n-      /* We don't know if it will or will not have side effects. */\n+      /* We don't know if it will or will not have side effects.  */\n       TREE_SIDE_EFFECTS (t) = 1;\n       return t;\n     }"}, {"sha": "859fc26f63bb985d3f7929cf0d63f3d73e618b95", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04c06002c256ed3d1a3e8296476d6be8feeafff2/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04c06002c256ed3d1a3e8296476d6be8feeafff2/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=04c06002c256ed3d1a3e8296476d6be8feeafff2", "patch": "@@ -1025,7 +1025,7 @@ build_x_arrow (tree expr)\n       if (processing_template_decl)\n \t{\n \t  expr = build_min_non_dep (ARROW_EXPR, last_rval, orig_expr);\n-\t  /* It will be dereferenced. */\n+\t  /* It will be dereferenced.  */\n \t  TREE_TYPE (expr) = TREE_TYPE (TREE_TYPE (last_rval));\n \t  return expr;\n \t}"}]}