{"sha": "7fc61626174d8fa80e2af1ff693b7075da4cf039", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2ZjNjE2MjYxNzRkOGZhODBlMmFmMWZmNjkzYjcwNzVkYTRjZjAzOQ==", "commit": {"author": {"name": "Fritz Reese", "email": "fritzoreese@gmail.com", "date": "2016-08-15T21:19:09Z"}, "committer": {"name": "Fritz Reese", "email": "foreese@gcc.gnu.org", "date": "2016-08-15T21:19:09Z"}, "message": "lang.opt, [...]: New flag -finit-derived.\n\n2016-08-15  Fritz Reese  <fritzoreese@gmail.com>\n\n\tgcc/fortran/\n\t* lang.opt, invoke.texi: New flag -finit-derived.\n\t* gfortran.h (gfc_build_default_init_expr, gfc_apply_init,\n\tgfc_generate_initializer): New prototypes.\n\t* expr.c (gfc_build_default_init_expr, gfc_apply_init,\n\tcomponent_initializer, gfc_generate_initializer): New functions.\n\t* expr.c (gfc_default_initializer): Wrap gfc_generate_initializer.\n\t* decl.c (build_struct): Move common code to gfc_apply_init.\n\t* resolve.c (can_generate_init): New function.\n\t* resolve.c (build_default_init_expr): Wrap gfc_build_default_init_expr.\n\t* resolve.c (apply_default_init, resolve_fl_variable_derived): Use\n\tgfc_generate_initializer.\n\t* trans-decl.c (gfc_generate_function_code): Use\n\tgfc_generate_initializer.\n\n\tgcc/testsuite/gfortran.dg/\n\t* init_flag_13.f90: New testcase.\n\t* init_flag_14.f90: Ditto.\n\t* init_flag_15.f03: Ditto.\n\t* dec_init_1.f90: Ditto.\n\t* dec_init_2.f90: Ditto.\n\nFrom-SVN: r239489", "tree": {"sha": "fdbf0c01463438b4e88470ff54f74cbb32cfe8b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fdbf0c01463438b4e88470ff54f74cbb32cfe8b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7fc61626174d8fa80e2af1ff693b7075da4cf039", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fc61626174d8fa80e2af1ff693b7075da4cf039", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7fc61626174d8fa80e2af1ff693b7075da4cf039", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fc61626174d8fa80e2af1ff693b7075da4cf039/comments", "author": {"login": "fritzr", "id": 2230564, "node_id": "MDQ6VXNlcjIyMzA1NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2230564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fritzr", "html_url": "https://github.com/fritzr", "followers_url": "https://api.github.com/users/fritzr/followers", "following_url": "https://api.github.com/users/fritzr/following{/other_user}", "gists_url": "https://api.github.com/users/fritzr/gists{/gist_id}", "starred_url": "https://api.github.com/users/fritzr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fritzr/subscriptions", "organizations_url": "https://api.github.com/users/fritzr/orgs", "repos_url": "https://api.github.com/users/fritzr/repos", "events_url": "https://api.github.com/users/fritzr/events{/privacy}", "received_events_url": "https://api.github.com/users/fritzr/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "874be74ab3d68a57e7938900e9e1364b8101ade9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/874be74ab3d68a57e7938900e9e1364b8101ade9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/874be74ab3d68a57e7938900e9e1364b8101ade9"}], "stats": {"total": 837, "additions": 623, "deletions": 214}, "files": [{"sha": "c6d1ff3859866f060f46d652b86be14e3a6737af", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fc61626174d8fa80e2af1ff693b7075da4cf039/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fc61626174d8fa80e2af1ff693b7075da4cf039/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=7fc61626174d8fa80e2af1ff693b7075da4cf039", "patch": "@@ -1,3 +1,20 @@\n+2016-08-15  Fritz Reese  <fritzoreese@gmail.com>\n+\n+\tgcc/fortran/\n+\t* lang.opt, invoke.texi: New flag -finit-derived.\n+\t* gfortran.h (gfc_build_default_init_expr, gfc_apply_init,\n+\tgfc_generate_initializer): New prototypes.\n+\t* expr.c (gfc_build_default_init_expr, gfc_apply_init,\n+\tcomponent_initializer, gfc_generate_initializer): New functions.\n+\t* expr.c (gfc_default_initializer): Wrap gfc_generate_initializer.\n+\t* decl.c (build_struct): Move common code to gfc_apply_init.\n+\t* resolve.c (can_generate_init): New function.\n+\t* resolve.c (build_default_init_expr): Wrap gfc_build_default_init_expr.\n+\t* resolve.c (apply_default_init, resolve_fl_variable_derived): Use\n+\tgfc_generate_initializer.\n+\t* trans-decl.c (gfc_generate_function_code): Use\n+\tgfc_generate_initializer.\n+\n 2016-08-15  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \t* frontend-passes.c (create_var):  Set ts.deferred for"}, {"sha": "ce5ebb763bae703c4570f076c41e7367a41bc1a5", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 1, "deletions": 47, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fc61626174d8fa80e2af1ff693b7075da4cf039/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fc61626174d8fa80e2af1ff693b7075da4cf039/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=7fc61626174d8fa80e2af1ff693b7075da4cf039", "patch": "@@ -1910,53 +1910,7 @@ build_struct (const char *name, gfc_charlen *cl, gfc_expr **init,\n     }\n   *as = NULL;\n \n-  /* Should this ever get more complicated, combine with similar section\n-     in add_init_expr_to_sym into a separate function.  */\n-  if (c->ts.type == BT_CHARACTER && !c->attr.pointer && c->initializer\n-      && c->ts.u.cl\n-      && c->ts.u.cl->length && c->ts.u.cl->length->expr_type == EXPR_CONSTANT)\n-    {\n-      int len;\n-\n-      gcc_assert (c->ts.u.cl && c->ts.u.cl->length);\n-      gcc_assert (c->ts.u.cl->length->expr_type == EXPR_CONSTANT);\n-      gcc_assert (c->ts.u.cl->length->ts.type == BT_INTEGER);\n-\n-      len = mpz_get_si (c->ts.u.cl->length->value.integer);\n-\n-      if (c->initializer->expr_type == EXPR_CONSTANT)\n-\tgfc_set_constant_character_len (len, c->initializer, -1);\n-      else if (c->initializer\n-\t\t&& c->initializer->ts.u.cl\n-\t\t&& mpz_cmp (c->ts.u.cl->length->value.integer,\n-\t\t\t    c->initializer->ts.u.cl->length->value.integer))\n-\t{\n-\t  gfc_constructor *ctor;\n-\t  ctor = gfc_constructor_first (c->initializer->value.constructor);\n-\n-\t  if (ctor)\n-\t    {\n-\t      int first_len;\n-\t      bool has_ts = (c->initializer->ts.u.cl\n-\t\t\t     && c->initializer->ts.u.cl->length_from_typespec);\n-\n-\t      /* Remember the length of the first element for checking\n-\t\t that all elements *in the constructor* have the same\n-\t\t length.  This need not be the length of the LHS!  */\n-\t      gcc_assert (ctor->expr->expr_type == EXPR_CONSTANT);\n-\t      gcc_assert (ctor->expr->ts.type == BT_CHARACTER);\n-\t      first_len = ctor->expr->value.character.length;\n-\n-\t      for ( ; ctor; ctor = gfc_constructor_next (ctor))\n-\t\tif (ctor->expr->expr_type == EXPR_CONSTANT)\n-\t\t{\n-\t\t  gfc_set_constant_character_len (len, ctor->expr,\n-\t\t\t\t\t\t  has_ts ? -1 : first_len);\n-\t\t  ctor->expr->ts.u.cl->length = gfc_copy_expr (c->ts.u.cl->length);\n-\t\t}\n-\t    }\n-\t}\n-    }\n+  gfc_apply_init (&c->ts, &c->attr, c->initializer);\n \n   /* Check array components.  */\n   if (!c->attr.dimension)"}, {"sha": "8e2b892fc249e42d40b51e5f91ee00cabf5041d9", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 267, "deletions": 12, "changes": 279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fc61626174d8fa80e2af1ff693b7075da4cf039/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fc61626174d8fa80e2af1ff693b7075da4cf039/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=7fc61626174d8fa80e2af1ff693b7075da4cf039", "patch": "@@ -3918,6 +3918,212 @@ gfc_check_assign_symbol (gfc_symbol *sym, gfc_component *comp, gfc_expr *rvalue)\n }\n \n \n+/* Build an initializer for a local integer, real, complex, logical, or\n+   character variable, based on the command line flags finit-local-zero,\n+   finit-integer=, finit-real=, finit-logical=, and finit-character=.  */\n+\n+gfc_expr *\n+gfc_build_default_init_expr (gfc_typespec *ts, locus *where)\n+{\n+  int char_len;\n+  gfc_expr *init_expr;\n+  int i;\n+\n+  /* Try to build an initializer expression.  */\n+  init_expr = gfc_get_constant_expr (ts->type, ts->kind, where);\n+\n+  /* We will only initialize integers, reals, complex, logicals, and\n+     characters, and only if the corresponding command-line flags\n+     were set.  Otherwise, we free init_expr and return null.  */\n+  switch (ts->type)\n+    {\n+    case BT_INTEGER:\n+      if (gfc_option.flag_init_integer != GFC_INIT_INTEGER_OFF)\n+        mpz_set_si (init_expr->value.integer,\n+                         gfc_option.flag_init_integer_value);\n+      else\n+        {\n+          gfc_free_expr (init_expr);\n+          init_expr = NULL;\n+        }\n+      break;\n+\n+    case BT_REAL:\n+      switch (flag_init_real)\n+        {\n+        case GFC_INIT_REAL_SNAN:\n+          init_expr->is_snan = 1;\n+          /* Fall through.  */\n+        case GFC_INIT_REAL_NAN:\n+          mpfr_set_nan (init_expr->value.real);\n+          break;\n+\n+        case GFC_INIT_REAL_INF:\n+          mpfr_set_inf (init_expr->value.real, 1);\n+          break;\n+\n+        case GFC_INIT_REAL_NEG_INF:\n+          mpfr_set_inf (init_expr->value.real, -1);\n+          break;\n+\n+        case GFC_INIT_REAL_ZERO:\n+          mpfr_set_ui (init_expr->value.real, 0.0, GFC_RND_MODE);\n+          break;\n+\n+        default:\n+          gfc_free_expr (init_expr);\n+          init_expr = NULL;\n+          break;\n+        }\n+      break;\n+\n+    case BT_COMPLEX:\n+      switch (flag_init_real)\n+        {\n+        case GFC_INIT_REAL_SNAN:\n+          init_expr->is_snan = 1;\n+          /* Fall through.  */\n+        case GFC_INIT_REAL_NAN:\n+          mpfr_set_nan (mpc_realref (init_expr->value.complex));\n+          mpfr_set_nan (mpc_imagref (init_expr->value.complex));\n+          break;\n+\n+        case GFC_INIT_REAL_INF:\n+          mpfr_set_inf (mpc_realref (init_expr->value.complex), 1);\n+          mpfr_set_inf (mpc_imagref (init_expr->value.complex), 1);\n+          break;\n+\n+        case GFC_INIT_REAL_NEG_INF:\n+          mpfr_set_inf (mpc_realref (init_expr->value.complex), -1);\n+          mpfr_set_inf (mpc_imagref (init_expr->value.complex), -1);\n+          break;\n+\n+        case GFC_INIT_REAL_ZERO:\n+          mpc_set_ui (init_expr->value.complex, 0, GFC_MPC_RND_MODE);\n+          break;\n+\n+        default:\n+          gfc_free_expr (init_expr);\n+          init_expr = NULL;\n+          break;\n+        }\n+      break;\n+\n+    case BT_LOGICAL:\n+      if (gfc_option.flag_init_logical == GFC_INIT_LOGICAL_FALSE)\n+        init_expr->value.logical = 0;\n+      else if (gfc_option.flag_init_logical == GFC_INIT_LOGICAL_TRUE)\n+        init_expr->value.logical = 1;\n+      else\n+        {\n+          gfc_free_expr (init_expr);\n+          init_expr = NULL;\n+        }\n+      break;\n+\n+    case BT_CHARACTER:\n+      /* For characters, the length must be constant in order to\n+         create a default initializer.  */\n+      if (gfc_option.flag_init_character == GFC_INIT_CHARACTER_ON\n+          && ts->u.cl->length\n+          && ts->u.cl->length->expr_type == EXPR_CONSTANT)\n+        {\n+          char_len = mpz_get_si (ts->u.cl->length->value.integer);\n+          init_expr->value.character.length = char_len;\n+          init_expr->value.character.string = gfc_get_wide_string (char_len+1);\n+          for (i = 0; i < char_len; i++)\n+            init_expr->value.character.string[i]\n+              = (unsigned char) gfc_option.flag_init_character_value;\n+        }\n+      else\n+        {\n+          gfc_free_expr (init_expr);\n+          init_expr = NULL;\n+        }\n+      if (!init_expr && gfc_option.flag_init_character == GFC_INIT_CHARACTER_ON\n+          && ts->u.cl->length && flag_max_stack_var_size != 0)\n+        {\n+          gfc_actual_arglist *arg;\n+          init_expr = gfc_get_expr ();\n+          init_expr->where = *where;\n+          init_expr->ts = *ts;\n+          init_expr->expr_type = EXPR_FUNCTION;\n+          init_expr->value.function.isym =\n+                gfc_intrinsic_function_by_id (GFC_ISYM_REPEAT);\n+          init_expr->value.function.name = \"repeat\";\n+          arg = gfc_get_actual_arglist ();\n+          arg->expr = gfc_get_character_expr (ts->kind, where, NULL, 1);\n+          arg->expr->value.character.string[0] =\n+            gfc_option.flag_init_character_value;\n+          arg->next = gfc_get_actual_arglist ();\n+          arg->next->expr = gfc_copy_expr (ts->u.cl->length);\n+          init_expr->value.function.actual = arg;\n+        }\n+      break;\n+\n+    default:\n+     gfc_free_expr (init_expr);\n+     init_expr = NULL;\n+    }\n+\n+  return init_expr;\n+}\n+\n+/* Apply an initialization expression to a typespec. Can be used for symbols or\n+   components. Similar to add_init_expr_to_sym in decl.c; could probably be\n+   combined with some effort.  */\n+\n+void\n+gfc_apply_init (gfc_typespec *ts, symbol_attribute *attr, gfc_expr *init)\n+{\n+  if (ts->type == BT_CHARACTER && !attr->pointer && init\n+      && ts->u.cl\n+      && ts->u.cl->length && ts->u.cl->length->expr_type == EXPR_CONSTANT)\n+    {\n+      int len;\n+\n+      gcc_assert (ts->u.cl && ts->u.cl->length);\n+      gcc_assert (ts->u.cl->length->expr_type == EXPR_CONSTANT);\n+      gcc_assert (ts->u.cl->length->ts.type == BT_INTEGER);\n+\n+      len = mpz_get_si (ts->u.cl->length->value.integer);\n+\n+      if (init->expr_type == EXPR_CONSTANT)\n+        gfc_set_constant_character_len (len, init, -1);\n+      else if (init\n+               && init->ts.u.cl\n+               && mpz_cmp (ts->u.cl->length->value.integer,\n+                           init->ts.u.cl->length->value.integer))\n+        {\n+          gfc_constructor *ctor;\n+          ctor = gfc_constructor_first (init->value.constructor);\n+\n+          if (ctor)\n+            {\n+              int first_len;\n+              bool has_ts = (init->ts.u.cl\n+                             && init->ts.u.cl->length_from_typespec);\n+\n+              /* Remember the length of the first element for checking\n+                 that all elements *in the constructor* have the same\n+                 length.  This need not be the length of the LHS!  */\n+              gcc_assert (ctor->expr->expr_type == EXPR_CONSTANT);\n+              gcc_assert (ctor->expr->ts.type == BT_CHARACTER);\n+              first_len = ctor->expr->value.character.length;\n+\n+              for ( ; ctor; ctor = gfc_constructor_next (ctor))\n+                if (ctor->expr->expr_type == EXPR_CONSTANT)\n+                {\n+                  gfc_set_constant_character_len (len, ctor->expr,\n+                                                  has_ts ? -1 : first_len);\n+                  ctor->expr->ts.u.cl->length = gfc_copy_expr (ts->u.cl->length);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+\n /* Check for default initializer; sym->value is not enough\n    as it is also set for EXPR_NULL of allocatables.  */\n \n@@ -3946,21 +4152,66 @@ gfc_has_default_initializer (gfc_symbol *der)\n }\n \n \n-/* Get an expression for a default initializer.  */\n+/* Fetch or generate an initializer for the given component.\n+   Only generate an initializer if generate is true.  */\n+\n+static gfc_expr *\n+component_initializer (gfc_typespec *ts, gfc_component *c, bool generate)\n+{\n+  gfc_expr *init = NULL;\n+\n+  /* See if we can find the initializer immediately.  */\n+  if (c->initializer || !generate\n+      || (ts->type == BT_CLASS && !c->attr.allocatable))\n+    return c->initializer;\n+\n+  /* Recursively handle derived type components.  */\n+  if (c->ts.type == BT_DERIVED || c->ts.type == BT_CLASS)\n+    init = gfc_generate_initializer (&c->ts, true);\n+\n+  /* Treat simple components like locals.  */\n+  else\n+    {\n+      init = gfc_build_default_init_expr (&c->ts, &c->loc);\n+      gfc_apply_init (&c->ts, &c->attr, init);\n+    }\n+\n+  return init;\n+}\n+\n+\n+/* Get an expression for a default initializer of a derived type.  */\n \n gfc_expr *\n gfc_default_initializer (gfc_typespec *ts)\n {\n-  gfc_expr *init;\n+  return gfc_generate_initializer (ts, false);\n+}\n+\n+\n+/* Get or generate an expression for a default initializer of a derived type. \n+   If -finit-derived is specified, generate default initialization expressions\n+   for components that lack them when generate is set.  */\n+\n+gfc_expr *\n+gfc_generate_initializer (gfc_typespec *ts, bool generate)\n+{\n+  gfc_expr *init, *tmp;\n   gfc_component *comp;\n+  generate = flag_init_derived && generate;\n \n   /* See if we have a default initializer in this, but not in nested\n-     types (otherwise we could use gfc_has_default_initializer()).  */\n-  for (comp = ts->u.derived->components; comp; comp = comp->next)\n-    if (comp->initializer || comp->attr.allocatable\n-\t|| (comp->ts.type == BT_CLASS && CLASS_DATA (comp)\n-\t    && CLASS_DATA (comp)->attr.allocatable))\n-      break;\n+     types (otherwise we could use gfc_has_default_initializer()).\n+     We don't need to check if we are going to generate them.  */\n+  comp = ts->u.derived->components;\n+  if (!generate)\n+    {\n+      for (; comp; comp = comp->next)\n+        if (comp->initializer || comp->attr.allocatable\n+            || (comp->ts.type == BT_CLASS && CLASS_DATA (comp)\n+                && CLASS_DATA (comp)->attr.allocatable))\n+          break;\n+    }\n \n   if (!comp)\n     return NULL;\n@@ -3973,15 +4224,19 @@ gfc_default_initializer (gfc_typespec *ts)\n     {\n       gfc_constructor *ctor = gfc_constructor_get();\n \n-      if (comp->initializer)\n+      /* Fetch or generate an initializer for the component.  */\n+      tmp = component_initializer (ts, comp, generate);\n+      if (tmp)\n \t{\n \t  /* Save the component ref for STRUCTUREs and UNIONs.  */\n \t  if (ts->u.derived->attr.flavor == FL_STRUCT\n \t      || ts->u.derived->attr.flavor == FL_UNION)\n \t    ctor->n.component = comp;\n-\t  ctor->expr = gfc_copy_expr (comp->initializer);\n-\t  if ((comp->ts.type != comp->initializer->ts.type\n-\t       || comp->ts.kind != comp->initializer->ts.kind)\n+\n+          /* If the initializer was not generated, we need a copy.  */\n+          ctor->expr = comp->initializer ? gfc_copy_expr (tmp) : tmp;\n+\t  if ((comp->ts.type != tmp->ts.type\n+\t       || comp->ts.kind != tmp->ts.kind)\n \t      && !comp->attr.pointer && !comp->attr.proc_pointer)\n \t    gfc_convert_type_warn (ctor->expr, &comp->ts, 2, false);\n \t}"}, {"sha": "813f7d9f10aaaf1aef1b35715c0af41740c8c8d4", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fc61626174d8fa80e2af1ff693b7075da4cf039/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fc61626174d8fa80e2af1ff693b7075da4cf039/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=7fc61626174d8fa80e2af1ff693b7075da4cf039", "patch": "@@ -3041,8 +3041,11 @@ bool gfc_check_assign (gfc_expr *, gfc_expr *, int);\n bool gfc_check_pointer_assign (gfc_expr *, gfc_expr *);\n bool gfc_check_assign_symbol (gfc_symbol *, gfc_component *, gfc_expr *);\n \n+gfc_expr *gfc_build_default_init_expr (gfc_typespec *, locus *);\n+void gfc_apply_init (gfc_typespec *, symbol_attribute *, gfc_expr *);\n bool gfc_has_default_initializer (gfc_symbol *);\n gfc_expr *gfc_default_initializer (gfc_typespec *);\n+gfc_expr *gfc_generate_initializer (gfc_typespec *, bool);\n gfc_expr *gfc_get_variable_expr (gfc_symtree *);\n void gfc_add_full_array_ref (gfc_expr *, gfc_array_spec *);\n gfc_expr * gfc_lval_expr_from_sym (gfc_symbol *);"}, {"sha": "15c131ac86571e64da05e46ff93743e2c3ed4dc6", "filename": "gcc/fortran/invoke.texi", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fc61626174d8fa80e2af1ff693b7075da4cf039/gcc%2Ffortran%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fc61626174d8fa80e2af1ff693b7075da4cf039/gcc%2Ffortran%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finvoke.texi?ref=7fc61626174d8fa80e2af1ff693b7075da4cf039", "patch": "@@ -178,6 +178,7 @@ and warnings}.\n -fcoarray=@var{<none|single|lib>} -fexternal-blas -ff2c\n -ffrontend-optimize @gol\n -finit-character=@var{n} -finit-integer=@var{n} -finit-local-zero @gol\n+-finit-derived @gol\n -finit-logical=@var{<true|false>}\n -finit-real=@var{<zero|inf|-inf|nan|snan>} @gol\n -finline-matmul-limit=@var{n} @gol\n@@ -1610,11 +1611,13 @@ on the stack. This flag cannot be used together with\n @option{-fmax-stack-var-size=} or @option{-fno-automatic}.\n \n @item -finit-local-zero\n+@itemx -finit-derived\n @itemx -finit-integer=@var{n}\n @itemx -finit-real=@var{<zero|inf|-inf|nan|snan>}\n @itemx -finit-logical=@var{<true|false>}\n @itemx -finit-character=@var{n}\n @opindex @code{finit-local-zero}\n+@opindex @code{finit-derived}\n @opindex @code{finit-integer}\n @opindex @code{finit-real}\n @opindex @code{finit-logical}\n@@ -1629,13 +1632,13 @@ initialization options are provided by the\n the real and imaginary parts of local @code{COMPLEX} variables),\n @option{-finit-logical=@var{<true|false>}}, and\n @option{-finit-character=@var{n}} (where @var{n} is an ASCII character\n-value) options.  These options do not initialize\n+value) options.  Components of derived type variables will be initialized\n+according to these flags only with @option{-finit-derived}.  These options do\n+not initialize\n @itemize @bullet\n @item\n allocatable arrays\n @item\n-components of derived type variables\n-@item\n variables that appear in an @code{EQUIVALENCE} statement.\n @end itemize\n (These limitations may be removed in future releases)."}, {"sha": "8ec5400ec95ae7f9440d6e62c17c6c187110305a", "filename": "gcc/fortran/lang.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fc61626174d8fa80e2af1ff693b7075da4cf039/gcc%2Ffortran%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fc61626174d8fa80e2af1ff693b7075da4cf039/gcc%2Ffortran%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Flang.opt?ref=7fc61626174d8fa80e2af1ff693b7075da4cf039", "patch": "@@ -528,6 +528,10 @@ finit-character=\n Fortran RejectNegative Joined UInteger\n -finit-character=<n>\tInitialize local character variables to ASCII value n.\n \n+finit-derived\n+Fortran Var(flag_init_derived)\n+Initialize components of derived type variables according to other init flags.\n+\n finit-integer=\n Fortran RejectNegative Joined\n -finit-integer=<n>\tInitialize local integer variables to n."}, {"sha": "7763f9c734501ab7a63f25bcdcf2d72a67956359", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 41, "deletions": 151, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fc61626174d8fa80e2af1ff693b7075da4cf039/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fc61626174d8fa80e2af1ff693b7075da4cf039/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=7fc61626174d8fa80e2af1ff693b7075da4cf039", "patch": "@@ -11138,6 +11138,39 @@ build_init_assign (gfc_symbol *sym, gfc_expr *init)\n   init_st->expr2 = init;\n }\n \n+\n+/* Whether or not we can generate a default initializer for a symbol.  */\n+\n+static bool\n+can_generate_init (gfc_symbol *sym)\n+{\n+  symbol_attribute *a;\n+  if (!sym)\n+    return false;\n+  a = &sym->attr;\n+\n+  /* These symbols should never have a default initialization.  */\n+  return !(\n+       a->allocatable\n+    || a->external\n+    || a->pointer\n+    || (sym->ts.type == BT_CLASS && CLASS_DATA (sym)\n+        && (CLASS_DATA (sym)->attr.class_pointer\n+            || CLASS_DATA (sym)->attr.proc_pointer))\n+    || a->in_equivalence\n+    || a->in_common\n+    || a->data\n+    || sym->module\n+    || a->cray_pointee\n+    || a->cray_pointer\n+    || sym->assoc\n+    || (!a->referenced && !a->result)\n+    || (a->dummy && a->intent != INTENT_OUT)\n+    || (a->function && sym != sym->result)\n+  );\n+}\n+\n+\n /* Assign the default initializer to a derived type variable or result.  */\n \n static void\n@@ -11149,7 +11182,7 @@ apply_default_init (gfc_symbol *sym)\n     return;\n \n   if (sym->ts.type == BT_DERIVED && sym->ts.u.derived)\n-    init = gfc_default_initializer (&sym->ts);\n+    init = gfc_generate_initializer (&sym->ts, can_generate_init (sym));\n \n   if (init == NULL && sym->ts.type != BT_CLASS)\n     return;\n@@ -11158,17 +11191,13 @@ apply_default_init (gfc_symbol *sym)\n   sym->attr.referenced = 1;\n }\n \n-/* Build an initializer for a local integer, real, complex, logical, or\n-   character variable, based on the command line flags finit-local-zero,\n-   finit-integer=, finit-real=, finit-logical=, and finit-runtime.  Returns\n-   null if the symbol should not have a default initialization.  */\n+\n+/* Build an initializer for a local. Returns null if the symbol should not have\n+   a default initialization.  */\n+\n static gfc_expr *\n build_default_init_expr (gfc_symbol *sym)\n {\n-  int char_len;\n-  gfc_expr *init_expr;\n-  int i;\n-\n   /* These symbols should never have a default initialization.  */\n   if (sym->attr.allocatable\n       || sym->attr.external\n@@ -11183,145 +11212,8 @@ build_default_init_expr (gfc_symbol *sym)\n       || sym->assoc)\n     return NULL;\n \n-  /* Now we'll try to build an initializer expression.  */\n-  init_expr = gfc_get_constant_expr (sym->ts.type, sym->ts.kind,\n-\t\t\t\t     &sym->declared_at);\n-\n-  /* We will only initialize integers, reals, complex, logicals, and\n-     characters, and only if the corresponding command-line flags\n-     were set.  Otherwise, we free init_expr and return null.  */\n-  switch (sym->ts.type)\n-    {\n-    case BT_INTEGER:\n-      if (gfc_option.flag_init_integer != GFC_INIT_INTEGER_OFF)\n-\tmpz_set_si (init_expr->value.integer,\n-\t\t\t gfc_option.flag_init_integer_value);\n-      else\n-\t{\n-\t  gfc_free_expr (init_expr);\n-\t  init_expr = NULL;\n-\t}\n-      break;\n-\n-    case BT_REAL:\n-      switch (flag_init_real)\n-\t{\n-\tcase GFC_INIT_REAL_SNAN:\n-\t  init_expr->is_snan = 1;\n-\t  /* Fall through.  */\n-\tcase GFC_INIT_REAL_NAN:\n-\t  mpfr_set_nan (init_expr->value.real);\n-\t  break;\n-\n-\tcase GFC_INIT_REAL_INF:\n-\t  mpfr_set_inf (init_expr->value.real, 1);\n-\t  break;\n-\n-\tcase GFC_INIT_REAL_NEG_INF:\n-\t  mpfr_set_inf (init_expr->value.real, -1);\n-\t  break;\n-\n-\tcase GFC_INIT_REAL_ZERO:\n-\t  mpfr_set_ui (init_expr->value.real, 0.0, GFC_RND_MODE);\n-\t  break;\n-\n-\tdefault:\n-\t  gfc_free_expr (init_expr);\n-\t  init_expr = NULL;\n-\t  break;\n-\t}\n-      break;\n-\n-    case BT_COMPLEX:\n-      switch (flag_init_real)\n-\t{\n-\tcase GFC_INIT_REAL_SNAN:\n-\t  init_expr->is_snan = 1;\n-\t  /* Fall through.  */\n-\tcase GFC_INIT_REAL_NAN:\n-\t  mpfr_set_nan (mpc_realref (init_expr->value.complex));\n-\t  mpfr_set_nan (mpc_imagref (init_expr->value.complex));\n-\t  break;\n-\n-\tcase GFC_INIT_REAL_INF:\n-\t  mpfr_set_inf (mpc_realref (init_expr->value.complex), 1);\n-\t  mpfr_set_inf (mpc_imagref (init_expr->value.complex), 1);\n-\t  break;\n-\n-\tcase GFC_INIT_REAL_NEG_INF:\n-\t  mpfr_set_inf (mpc_realref (init_expr->value.complex), -1);\n-\t  mpfr_set_inf (mpc_imagref (init_expr->value.complex), -1);\n-\t  break;\n-\n-\tcase GFC_INIT_REAL_ZERO:\n-\t  mpc_set_ui (init_expr->value.complex, 0, GFC_MPC_RND_MODE);\n-\t  break;\n-\n-\tdefault:\n-\t  gfc_free_expr (init_expr);\n-\t  init_expr = NULL;\n-\t  break;\n-\t}\n-      break;\n-\n-    case BT_LOGICAL:\n-      if (gfc_option.flag_init_logical == GFC_INIT_LOGICAL_FALSE)\n-\tinit_expr->value.logical = 0;\n-      else if (gfc_option.flag_init_logical == GFC_INIT_LOGICAL_TRUE)\n-\tinit_expr->value.logical = 1;\n-      else\n-\t{\n-\t  gfc_free_expr (init_expr);\n-\t  init_expr = NULL;\n-\t}\n-      break;\n-\n-    case BT_CHARACTER:\n-      /* For characters, the length must be constant in order to\n-\t create a default initializer.  */\n-      if (gfc_option.flag_init_character == GFC_INIT_CHARACTER_ON\n-\t  && sym->ts.u.cl->length\n-\t  && sym->ts.u.cl->length->expr_type == EXPR_CONSTANT)\n-\t{\n-\t  char_len = mpz_get_si (sym->ts.u.cl->length->value.integer);\n-\t  init_expr->value.character.length = char_len;\n-\t  init_expr->value.character.string = gfc_get_wide_string (char_len+1);\n-\t  for (i = 0; i < char_len; i++)\n-\t    init_expr->value.character.string[i]\n-\t      = (unsigned char) gfc_option.flag_init_character_value;\n-\t}\n-      else\n-\t{\n-\t  gfc_free_expr (init_expr);\n-\t  init_expr = NULL;\n-\t}\n-      if (!init_expr && gfc_option.flag_init_character == GFC_INIT_CHARACTER_ON\n-\t  && sym->ts.u.cl->length && flag_max_stack_var_size != 0)\n-\t{\n-\t  gfc_actual_arglist *arg;\n-\t  init_expr = gfc_get_expr ();\n-\t  init_expr->where = sym->declared_at;\n-\t  init_expr->ts = sym->ts;\n-\t  init_expr->expr_type = EXPR_FUNCTION;\n-\t  init_expr->value.function.isym =\n-\t\tgfc_intrinsic_function_by_id (GFC_ISYM_REPEAT);\n-\t  init_expr->value.function.name = \"repeat\";\n-\t  arg = gfc_get_actual_arglist ();\n-\t  arg->expr = gfc_get_character_expr (sym->ts.kind, &sym->declared_at,\n-\t\t\t\t\t      NULL, 1);\n-\t  arg->expr->value.character.string[0]\n-\t\t= gfc_option.flag_init_character_value;\n-\t  arg->next = gfc_get_actual_arglist ();\n-\t  arg->next->expr = gfc_copy_expr (sym->ts.u.cl->length);\n-\t  init_expr->value.function.actual = arg;\n-\t}\n-      break;\n-\n-    default:\n-     gfc_free_expr (init_expr);\n-     init_expr = NULL;\n-    }\n-  return init_expr;\n+  /* Get the appropriate init expression.  */\n+  return gfc_build_default_init_expr (&sym->ts, &sym->declared_at);\n }\n \n /* Add an initialization expression to a local variable.  */\n@@ -11504,9 +11396,7 @@ resolve_fl_variable_derived (gfc_symbol *sym, int no_init_flag)\n   /* Assign default initializer.  */\n   if (!(sym->value || sym->attr.pointer || sym->attr.allocatable)\n       && (!no_init_flag || sym->attr.intent == INTENT_OUT))\n-    {\n-      sym->value = gfc_default_initializer (&sym->ts);\n-    }\n+    sym->value = gfc_generate_initializer (&sym->ts, can_generate_init (sym));\n \n   return true;\n }"}, {"sha": "6cf7f573bf616154c653cee1fb11e379d8860b7d", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fc61626174d8fa80e2af1ff693b7075da4cf039/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fc61626174d8fa80e2af1ff693b7075da4cf039/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=7fc61626174d8fa80e2af1ff693b7075da4cf039", "patch": "@@ -6256,7 +6256,8 @@ gfc_generate_function_code (gfc_namespace * ns)\n \t      /* Arrays are not initialized using the default initializer of\n \t\t their elements.  Therefore only check if a default\n \t\t initializer is available when the result is scalar.  */\n-\t      init_exp = rsym->as ? NULL : gfc_default_initializer (&rsym->ts);\n+              init_exp = rsym->as ? NULL\n+                                  : gfc_generate_initializer (&rsym->ts, true);\n \t      if (init_exp)\n \t\t{\n \t\t  tmp = gfc_trans_structure_assign (result, init_exp, 0);"}, {"sha": "810aca1a4a8fa8ff569d9256da998a2f4d48cd36", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fc61626174d8fa80e2af1ff693b7075da4cf039/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fc61626174d8fa80e2af1ff693b7075da4cf039/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7fc61626174d8fa80e2af1ff693b7075da4cf039", "patch": "@@ -1,3 +1,11 @@\n+2016-08-15  Fritz Reese  <fritzoreese@gmail.com>\n+\n+\t* gfortran.dg/init_flag_13.f90: New testcase.\n+\t* gfortran.dg/init_flag_14.f90: Ditto.\n+\t* gfortran.dg/init_flag_15.f03: Ditto.\n+\t* gfortran.dg/dec_init_1.f90: Ditto.\n+\t* gfortran.dg/dec_init_2.f90: Ditto.\n+\n 2016-08-15  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/72867"}, {"sha": "91f16f85294534649a3d44ce7cf5fd4323297705", "filename": "gcc/testsuite/gfortran.dg/dec_init_1.f90", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fc61626174d8fa80e2af1ff693b7075da4cf039/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_init_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fc61626174d8fa80e2af1ff693b7075da4cf039/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_init_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_init_1.f90?ref=7fc61626174d8fa80e2af1ff693b7075da4cf039", "patch": "@@ -0,0 +1,62 @@\n+! { dg-do run }\n+! { dg-options \"-fdec-structure -finit-derived -finit-local-zero -fdump-tree-original\" }\n+!\n+! Test -finit-derived with DEC structure and union.\n+!\n+\n+subroutine dummy(i1,r1,c1,l1,i2,r2,c2,l2)\n+  implicit none\n+  integer, intent(in) :: i1\n+  real, intent(in) :: r1\n+  character, intent(in) :: c1\n+  logical, intent(in) :: l1\n+  integer, intent(inout) :: i2\n+  real, intent(inout) :: r2\n+  character, intent(inout) :: c2\n+  logical, intent(inout) :: l2\n+  print *, i1, i2, l1, l2, c1, c2, r1, r2\n+  if ( i1 .ne. 0 .or. i2 .ne. 0 ) call abort()\n+  if ( l1 .or. l2 ) call abort()\n+  if ( c1 .ne. achar(0) .or. c2 .ne. achar(0) ) call abort()\n+  if ( r1 .ne. 0.0 .or. r2 .ne. 0.0 ) call abort()\n+end subroutine\n+\n+structure /s3/\n+  union\n+    map\n+      integer m11\n+      real m12\n+      character m13\n+      logical m14\n+    end map\n+    map\n+      logical m21\n+      character m22\n+      real m23\n+      integer m24\n+    end map\n+  end union\n+end structure\n+\n+structure /s2/\n+  integer i2\n+  real r2\n+  character c2\n+  logical l2\n+end structure\n+\n+structure /s1/\n+  logical l1\n+  real r1\n+  character c1\n+  integer i1\n+  record /s2/ y\n+end structure\n+\n+record /s1/ x\n+record /s3/ y\n+\n+call dummy (x.i1, x.r1, x.c1, x.l1, x.y.i2, x.y.r2, x.y.c2, x.y.l2)\n+call dummy (y.m11, y.m12, y.m13, y.m14, y.m24, y.m23, y.m22, y.m21)\n+\n+end"}, {"sha": "0efcdf96ad1639323d4caf0e5e6adb3a6f2adceb", "filename": "gcc/testsuite/gfortran.dg/dec_init_2.f90", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fc61626174d8fa80e2af1ff693b7075da4cf039/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_init_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fc61626174d8fa80e2af1ff693b7075da4cf039/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_init_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_init_2.f90?ref=7fc61626174d8fa80e2af1ff693b7075da4cf039", "patch": "@@ -0,0 +1,46 @@\n+! { dg-do run }\n+! { dg-options \"-fdec-structure -finit-derived -finit-integer=42 -finit-real=nan -finit-logical=true -finit-character=32 -fdump-tree-original\" }\n+!\n+! Test -finit-derived with DEC structure and union.\n+!\n+\n+subroutine dummy(i1,r1,c1,l1,i2,r2,c2,l2)\n+  implicit none\n+  integer, intent(in) :: i1\n+  real, intent(in) :: r1\n+  character, intent(in) :: c1\n+  logical, intent(in) :: l1\n+  integer, intent(inout) :: i2\n+  real, intent(inout) :: r2\n+  character, intent(inout) :: c2\n+  logical, intent(inout) :: l2\n+  print *, i1, i2, l1, l2, c1, c2, r1, r2\n+  if ( i1 .ne. 42 .or. i2 .ne. 42 ) call abort()\n+  if ( (.not. l1) .or. (.not. l2) ) call abort()\n+  if ( c1 .ne. achar(32) .or. c2 .ne. achar(32) ) call abort()\n+  if ( (.not. isnan(r1)) .or. (.not. isnan(r2)) ) call abort()\n+end subroutine\n+\n+! Nb. the current implementation decides the -finit-* flags are meaningless\n+! with components of a union, so we omit the union test here.\n+\n+structure /s2/\n+  integer i2\n+  real r2\n+  character c2\n+  logical l2\n+end structure\n+\n+structure /s1/\n+  logical l1\n+  real r1\n+  character c1\n+  integer i1\n+  record /s2/ y\n+end structure\n+\n+record /s1/ x\n+\n+call dummy (x.i1, x.r1, x.c1, x.l1, x.y.i2, x.y.r2, x.y.c2, x.y.l2)\n+\n+end"}, {"sha": "cdd039af78c3031d6987c55bc8f333d7f3fb1b64", "filename": "gcc/testsuite/gfortran.dg/init_flag_13.f90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fc61626174d8fa80e2af1ff693b7075da4cf039/gcc%2Ftestsuite%2Fgfortran.dg%2Finit_flag_13.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fc61626174d8fa80e2af1ff693b7075da4cf039/gcc%2Ftestsuite%2Fgfortran.dg%2Finit_flag_13.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finit_flag_13.f90?ref=7fc61626174d8fa80e2af1ff693b7075da4cf039", "patch": "@@ -0,0 +1,51 @@\n+! { dg-do compile }\n+! { dg-options \"-finit-local-zero -finit-derived -fdump-tree-original\" }\n+!\n+! Make sure -finit-derived initializes components of local derived type\n+! variables to zero with -finit-local-zero.\n+!\n+\n+subroutine dummy(i1,r1,c1,l1,i2,r2,c2,l2)\n+  implicit none\n+  integer, intent(in) :: i1\n+  real, intent(in) :: r1\n+  character, intent(in) :: c1\n+  logical, intent(in) :: l1\n+  integer, intent(out) :: i2\n+  real, intent(out) :: r2\n+  character, intent(out) :: c2\n+  logical, intent(out) :: l2\n+end subroutine\n+\n+type t2\n+  integer i2\n+  real r2\n+  character c2\n+  logical l2\n+end type\n+\n+type t1\n+  logical l1\n+  real r1\n+  character c1\n+  integer i1\n+  type (t2) y\n+end type\n+\n+type (t1) :: x\n+\n+call dummy (x%i1, x%r1, x%c1, x%l1, x%y%i2, x%y%r2, x%y%c2, x%y%l2)\n+\n+end\n+\n+! We expect to see each component initialized exactly once in MAIN.\n+! NB. the \"once\" qualifier also tests that the dummy variables aren't\n+! given an extraneous initializer.\n+! { dg-final { scan-tree-dump-times \"i1= *0\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"r1= *0\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"c1= *\\\"\\\"\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"l1= *0\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"i2= *0\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"r2= *0\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"c2= *\\\"\\\"\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"l2= *0\" 1 \"original\" } }"}, {"sha": "13991f826d75b60620068014b63352c5dd7ce239", "filename": "gcc/testsuite/gfortran.dg/init_flag_14.f90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fc61626174d8fa80e2af1ff693b7075da4cf039/gcc%2Ftestsuite%2Fgfortran.dg%2Finit_flag_14.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fc61626174d8fa80e2af1ff693b7075da4cf039/gcc%2Ftestsuite%2Fgfortran.dg%2Finit_flag_14.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finit_flag_14.f90?ref=7fc61626174d8fa80e2af1ff693b7075da4cf039", "patch": "@@ -0,0 +1,51 @@\n+! { dg-do compile }\n+! { dg-options \"-finit-derived -finit-integer=42 -finit-real=inf -finit-logical=true -finit-character=32 -fdump-tree-original\" }\n+!\n+! Make sure -finit-derived initializes components of local derived type\n+! variables according to other -finit-* flags.\n+!\n+\n+subroutine dummy(i1,r1,c1,l1,i2,r2,c2,l2)\n+  implicit none\n+  integer, intent(in) :: i1\n+  real, intent(in) :: r1\n+  character, intent(in) :: c1\n+  logical, intent(in) :: l1\n+  integer, intent(out) :: i2\n+  real, intent(out) :: r2\n+  character, intent(out) :: c2\n+  logical, intent(out) :: l2\n+end subroutine\n+\n+type t2\n+  integer i2\n+  real r2\n+  character c2\n+  logical l2\n+end type\n+\n+type t1\n+  logical l1\n+  real r1\n+  character c1\n+  integer i1\n+  type (t2) y\n+end type\n+\n+type (t1) :: x\n+\n+call dummy (x%i1, x%r1, x%c1, x%l1, x%y%i2, x%y%r2, x%y%c2, x%y%l2)\n+\n+end\n+\n+! We expect to see each component initialized exactly once in MAIN.\n+! NB. the \"once\" qualifier also tests that the dummy variables aren't\n+! given an extraneous initializer.\n+! { dg-final { scan-tree-dump-times \"i1= *42\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"r1= *\\[iI]nf\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"c1= *\\\" \\\"\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"l1= *1\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"i2= *42\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"r2= *\\[iI]nf\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"c2= *\\\" \\\"\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"l2= *1\" 1 \"original\" } }"}, {"sha": "fef9442dd50fda1a43c25d6328e10cd6a1a39c1f", "filename": "gcc/testsuite/gfortran.dg/init_flag_15.f03", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fc61626174d8fa80e2af1ff693b7075da4cf039/gcc%2Ftestsuite%2Fgfortran.dg%2Finit_flag_15.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fc61626174d8fa80e2af1ff693b7075da4cf039/gcc%2Ftestsuite%2Fgfortran.dg%2Finit_flag_15.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finit_flag_15.f03?ref=7fc61626174d8fa80e2af1ff693b7075da4cf039", "patch": "@@ -0,0 +1,64 @@\n+! { dg-do run }\n+! { dg-options \"-finit-derived -finit-integer=1\" }\n+!\n+! Make sure -finit-derived works on class variables.\n+! Based on class_result_1.f03\n+!\n+\n+module points_2i\n+\n+  implicit none\n+\n+  type point2i\n+      integer :: x, y\n+  end type\n+\n+contains\n+\n+ subroutine print( point )\n+   class(point2i) :: point\n+   write(*,'(2i4)') point%x, point%y\n+ end subroutine\n+\n+ subroutine set_vector( point, rx, ry )\n+   class(point2i) :: point\n+   integer :: rx, ry\n+   point%x = rx\n+   point%y = ry\n+ end subroutine\n+\n+ function add_vector( point, vector )\n+   class(point2i), intent(in)  :: point, vector\n+   class(point2i), allocatable :: add_vector\n+   allocate( add_vector )\n+   add_vector%x = point%x + vector%x\n+   add_vector%y = point%y + vector%y\n+ end function\n+\n+end module\n+\n+\n+program init_flag_15\n+\n+  use points_2i\n+  implicit none\n+\n+  type(point2i), target   :: point_2i, vector_2i\n+  class(point2i), pointer :: point, vector\n+  type(point2i) :: vsum\n+  integer :: i\n+\n+  point  => point_2i ! = (1, 1) due to -finit-integer\n+  vector => vector_2i\n+  call set_vector(vector, 2, 2)\n+  vsum = add_vector(point, vector)\n+\n+  call print(point)\n+  call print(vector)\n+  call print(vsum)\n+\n+  if (vsum%x .ne. 3 .or. vsum%y .ne. 3) then\n+    call abort()\n+  endif\n+\n+end program"}]}