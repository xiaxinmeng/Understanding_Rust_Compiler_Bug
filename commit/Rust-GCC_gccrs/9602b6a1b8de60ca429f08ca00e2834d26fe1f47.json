{"sha": "9602b6a1b8de60ca429f08ca00e2834d26fe1f47", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTYwMmI2YTFiOGRlNjBjYTQyOWYwOGNhMDBlMjgzNGQyNmZlMWY0Nw==", "commit": {"author": {"name": "Andreas Krebbel", "email": "Andreas.Krebbel@de.ibm.com", "date": "2010-04-13T09:04:31Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2010-04-13T09:04:31Z"}, "message": "s390.md: Replace TARGET_64BIT with TARGET_ZARCH.\n\n2010-04-13  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n            Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n\t\n\t* gcc/config/s390/s390.md: Replace TARGET_64BIT with TARGET_ZARCH.\n\t* gcc/config/s390/s390.c: Replace UNTIS_PER_WORD with\n\tUNITS_PER_LONG where it is ABI relevant.\t\n\t(s390_return_addr_rtx): Likewise.\n\t(s390_back_chain_rtx): Likewise.\n\t(s390_frame_area): Likewise.\n\t(s390_frame_info): Likewise.\n\t(s390_initial_elimination_offset): Likewise.\n\t(save_gprs): Likewise.\n\t(s390_emit_prologue): Likewise.\n\t(s390_emit_epilogue): Likewise.\n\t(s390_function_arg_advance): Likewise.\n\t(s390_function_arg): Likewise.\n\t(s390_va_start): Likewise.\n\t(s390_gimplify_va_arg): Likewise.\n\t(s390_function_profiler): Likewise.\n\t(s390_optimize_prologue): Likewise.\n\t(s390_rtx_costs): Likewise.\n\t(s390_secondary_reload): Likewise.\n\t(s390_promote_function_mode): Likewise.\n\t(s390_hard_regno_mode_ok): Replace TARGET_64BIT with TARGET_ZARCH.\n\t(s390_scalar_mode_supported_p): Disallow TImode if no 64 bit\n\tregisters available.\n\t(s390_unwind_word_mode): New function.\n\t(s390_function_value): Split 64 bit values into register pair if\n\tused as return value.\n\t(s390_call_saved_register_used): Don't use HARD_REGNO_NREGS for\n\tfunction call parameters.  Handle parallels.\n\t(TARGET_SCALAR_MODE_SUPPORTED_P): New macro.\n\t(HARD_REGNO_CALL_PART_CLOBBERED): New macro.\n\t(DWARF_CIE_DATA_ALIGNMENT): New macro.\n\t(s390_expand_setmem): Remove unused variable src_addr.\n\t* gcc/longlong.h: Make smul_ppmm and sdiv_qrnnd inline asms to\n\tdeal with 64 bit registers.\t\n\t* gcc/config/s390/s390.h: Define __zarch__ predefined macro.\n\tReplace UNITS_PER_WORD with UNITS_PER_LONG where it is ABI relevant.\n\t(UNITS_PER_LONG): New macro.\n\t* libjava/include/s390-signal.h: Define extended ucontext\n\tstructure containing the upper halfs of the 64 bit registers.\n\n\nCo-Authored-By: Ulrich Weigand <uweigand@de.ibm.com>\n\nFrom-SVN: r158257", "tree": {"sha": "374b7f6023d6c98f017b4c6b7e2f6508841d2326", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/374b7f6023d6c98f017b4c6b7e2f6508841d2326"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9602b6a1b8de60ca429f08ca00e2834d26fe1f47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9602b6a1b8de60ca429f08ca00e2834d26fe1f47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9602b6a1b8de60ca429f08ca00e2834d26fe1f47", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9602b6a1b8de60ca429f08ca00e2834d26fe1f47/comments", "author": null, "committer": null, "parents": [{"sha": "3b123595194847e323c1312c502266caf61d67f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b123595194847e323c1312c502266caf61d67f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b123595194847e323c1312c502266caf61d67f7"}], "stats": {"total": 773, "additions": 531, "deletions": 242}, "files": [{"sha": "be1bed710c9785449dc81879f20e699e9e34a9fe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9602b6a1b8de60ca429f08ca00e2834d26fe1f47/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9602b6a1b8de60ca429f08ca00e2834d26fe1f47/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9602b6a1b8de60ca429f08ca00e2834d26fe1f47", "patch": "@@ -1,3 +1,46 @@\n+2010-04-13  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n+            Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n+\t\n+\t* gcc/config/s390/s390.md: Replace TARGET_64BIT with TARGET_ZARCH.\n+\t* gcc/config/s390/s390.c: Replace UNTIS_PER_WORD with\n+\tUNITS_PER_LONG where it is ABI relevant.\t\n+\t(s390_return_addr_rtx): Likewise.\n+\t(s390_back_chain_rtx): Likewise.\n+\t(s390_frame_area): Likewise.\n+\t(s390_frame_info): Likewise.\n+\t(s390_initial_elimination_offset): Likewise.\n+\t(save_gprs): Likewise.\n+\t(s390_emit_prologue): Likewise.\n+\t(s390_emit_epilogue): Likewise.\n+\t(s390_function_arg_advance): Likewise.\n+\t(s390_function_arg): Likewise.\n+\t(s390_va_start): Likewise.\n+\t(s390_gimplify_va_arg): Likewise.\n+\t(s390_function_profiler): Likewise.\n+\t(s390_optimize_prologue): Likewise.\n+\t(s390_rtx_costs): Likewise.\n+\t(s390_secondary_reload): Likewise.\n+\t(s390_promote_function_mode): Likewise.\n+\t(s390_hard_regno_mode_ok): Replace TARGET_64BIT with TARGET_ZARCH.\n+\t(s390_scalar_mode_supported_p): Disallow TImode if no 64 bit\n+\tregisters available.\n+\t(s390_unwind_word_mode): New function.\n+\t(s390_function_value): Split 64 bit values into register pair if\n+\tused as return value.\n+\t(s390_call_saved_register_used): Don't use HARD_REGNO_NREGS for\n+\tfunction call parameters.  Handle parallels.\n+\t(TARGET_SCALAR_MODE_SUPPORTED_P): New macro.\n+\t(HARD_REGNO_CALL_PART_CLOBBERED): New macro.\n+\t(DWARF_CIE_DATA_ALIGNMENT): New macro.\n+\t(s390_expand_setmem): Remove unused variable src_addr.\n+\t* gcc/longlong.h: Make smul_ppmm and sdiv_qrnnd inline asms to\n+\tdeal with 64 bit registers.\t\n+\t* gcc/config/s390/s390.h: Define __zarch__ predefined macro.\n+\tReplace UNITS_PER_WORD with UNITS_PER_LONG where it is ABI relevant.\n+\t(UNITS_PER_LONG): New macro.\n+\t* libjava/include/s390-signal.h: Define extended ucontext\n+\tstructure containing the upper halfs of the 64 bit registers.\n+\n 2010-04-13  Simon Baldwin  <simonb@google.com>\n \n \t* cfgexpand.c (gimple_expand_cfg): Clarify warning message text."}, {"sha": "d0fbe5a65b94a37473023c39989765016ac1d305", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 131, "deletions": 52, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9602b6a1b8de60ca429f08ca00e2834d26fe1f47/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9602b6a1b8de60ca429f08ca00e2834d26fe1f47/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=9602b6a1b8de60ca429f08ca00e2834d26fe1f47", "patch": "@@ -324,7 +324,7 @@ struct GTY(()) machine_function\n #define cfun_frame_layout (cfun->machine->frame_layout)\n #define cfun_save_high_fprs_p (!!cfun_frame_layout.high_fprs)\n #define cfun_gprs_save_area_size ((cfun_frame_layout.last_save_gpr_slot -           \\\n-  cfun_frame_layout.first_save_gpr_slot + 1) * UNITS_PER_WORD)\n+  cfun_frame_layout.first_save_gpr_slot + 1) * UNITS_PER_LONG)\n #define cfun_set_fpr_bit(BITNUM) (cfun->machine->frame_layout.fpr_bitmap |=    \\\n   (1 << (BITNUM)))\n #define cfun_fpr_bit_p(BITNUM) (!!(cfun->machine->frame_layout.fpr_bitmap &    \\\n@@ -365,14 +365,25 @@ s390_libgcc_shift_count_mode (void)\n   return TARGET_64BIT ? DImode : SImode;\n }\n \n+static enum machine_mode\n+s390_unwind_word_mode (void)\n+{\n+  return TARGET_64BIT ? DImode : SImode;\n+}\n+\n /* Return true if the back end supports mode MODE.  */\n static bool\n s390_scalar_mode_supported_p (enum machine_mode mode)\n {\n+  /* In contrast to the default implementation reject TImode constants on 31bit\n+     TARGET_ZARCH for ABI compliance.  */\n+  if (!TARGET_64BIT && TARGET_ZARCH && mode == TImode)\n+    return false;\n+\n   if (DECIMAL_FLOAT_MODE_P (mode))\n     return default_decimal_float_supported_p ();\n-  else\n-    return default_scalar_mode_supported_p (mode);\n+\n+  return default_scalar_mode_supported_p (mode);\n }\n \n /* Set the has_landing_pad_p flag in struct machine_function to VALUE.  */\n@@ -2407,7 +2418,7 @@ s390_rtx_costs (rtx x, int code, int outer_code, int *total,\n \t  {\n \t    rtx left = XEXP (x, 0);\n \t    rtx right = XEXP (x, 1);\n-\t    if (TARGET_64BIT)\n+\t    if (TARGET_ZARCH)\n \t      {\n \t\tif (GET_CODE (right) == CONST_INT\n \t\t    && CONST_OK_FOR_K (INTVAL (right)))\n@@ -2468,7 +2479,7 @@ s390_rtx_costs (rtx x, int code, int outer_code, int *total,\n \t{\n \t  rtx right = XEXP (x, 1);\n \t  if (GET_CODE (right) == ZERO_EXTEND) /* 64 by 32 bit division */\n-\t    if (TARGET_64BIT)\n+\t    if (TARGET_ZARCH)\n \t      *total = s390_cost->dsgfr;\n \t    else\n \t      *total = s390_cost->dr;\n@@ -2960,7 +2971,7 @@ s390_secondary_reload (bool in_p, rtx x, enum reg_class rclass,\n       if (MEM_P (x)\n \t  && s390_symref_operand_p (XEXP (x, 0), NULL, NULL)\n \t  && (mode == QImode || mode == TImode || FLOAT_MODE_P (mode)\n-\t      || (!TARGET_64BIT && mode == DImode)\n+\t      || (!TARGET_ZARCH && mode == DImode)\n \t      || ((mode == HImode || mode == SImode || mode == DImode)\n \t\t  && (!s390_check_symref_alignment (XEXP (x, 0),\n \t\t\t\t\t\t    GET_MODE_SIZE (mode))))))\n@@ -4033,7 +4044,7 @@ s390_expand_setmem (rtx dst, rtx len, rtx val)\n \n   else\n     {\n-      rtx dst_addr, src_addr, count, blocks, temp, dstp1 = NULL_RTX;\n+      rtx dst_addr, count, blocks, temp, dstp1 = NULL_RTX;\n       rtx loop_start_label = gen_label_rtx ();\n       rtx loop_end_label = gen_label_rtx ();\n       rtx end_label = gen_label_rtx ();\n@@ -4044,7 +4055,6 @@ s390_expand_setmem (rtx dst, rtx len, rtx val)\n         mode = Pmode;\n \n       dst_addr = gen_reg_rtx (Pmode);\n-      src_addr = gen_reg_rtx (Pmode);\n       count = gen_reg_rtx (mode);\n       blocks = gen_reg_rtx (mode);\n \n@@ -5412,7 +5422,6 @@ s390_first_cycle_multipass_dfa_lookahead (void)\n   return 4;\n }\n \n-\n /* Annotate every literal pool reference in X by an UNSPEC_LTREF expression.\n    Fix up MEMs as required.  */\n \n@@ -6810,9 +6819,9 @@ s390_return_addr_rtx (int count, rtx frame ATTRIBUTE_UNUSED)\n     }\n \n   if (TARGET_PACKED_STACK)\n-    offset = -2 * UNITS_PER_WORD;\n+    offset = -2 * UNITS_PER_LONG;\n   else\n-    offset = RETURN_REGNUM * UNITS_PER_WORD;\n+    offset = RETURN_REGNUM * UNITS_PER_LONG;\n \n   addr = plus_constant (frame, offset);\n   addr = memory_address (Pmode, addr);\n@@ -6831,7 +6840,7 @@ s390_back_chain_rtx (void)\n \n   if (TARGET_PACKED_STACK)\n     chain = plus_constant (stack_pointer_rtx,\n-\t\t\t   STACK_POINTER_OFFSET - UNITS_PER_WORD);\n+\t\t\t   STACK_POINTER_OFFSET - UNITS_PER_LONG);\n   else\n     chain = stack_pointer_rtx;\n \n@@ -6956,9 +6965,9 @@ s390_frame_area (int *area_bottom, int *area_top)\n   if (cfun_frame_layout.first_restore_gpr != -1)\n     {\n       b = (cfun_frame_layout.gprs_offset\n-\t   + cfun_frame_layout.first_restore_gpr * UNITS_PER_WORD);\n+\t   + cfun_frame_layout.first_restore_gpr * UNITS_PER_LONG);\n       t = b + (cfun_frame_layout.last_restore_gpr\n-\t       - cfun_frame_layout.first_restore_gpr + 1) * UNITS_PER_WORD;\n+\t       - cfun_frame_layout.first_restore_gpr + 1) * UNITS_PER_LONG;\n     }\n \n   if (TARGET_64BIT && cfun_save_high_fprs_p)\n@@ -7153,20 +7162,20 @@ s390_frame_info (void)\n   if (!TARGET_PACKED_STACK)\n     {\n       cfun_frame_layout.backchain_offset = 0;\n-      cfun_frame_layout.f0_offset = 16 * UNITS_PER_WORD;\n+      cfun_frame_layout.f0_offset = 16 * UNITS_PER_LONG;\n       cfun_frame_layout.f4_offset = cfun_frame_layout.f0_offset + 2 * 8;\n       cfun_frame_layout.f8_offset = -cfun_frame_layout.high_fprs * 8;\n       cfun_frame_layout.gprs_offset = (cfun_frame_layout.first_save_gpr_slot\n-\t\t\t\t       * UNITS_PER_WORD);\n+\t\t\t\t       * UNITS_PER_LONG);\n     }\n   else if (TARGET_BACKCHAIN) /* kernel stack layout */\n     {\n       cfun_frame_layout.backchain_offset = (STACK_POINTER_OFFSET\n-\t\t\t\t\t    - UNITS_PER_WORD);\n+\t\t\t\t\t    - UNITS_PER_LONG);\n       cfun_frame_layout.gprs_offset\n \t= (cfun_frame_layout.backchain_offset\n \t   - (STACK_POINTER_REGNUM - cfun_frame_layout.first_save_gpr_slot + 1)\n-\t   * UNITS_PER_WORD);\n+\t   * UNITS_PER_LONG);\n \n       if (TARGET_64BIT)\n \t{\n@@ -7221,7 +7230,7 @@ s390_frame_info (void)\n   else\n     {\n       if (TARGET_BACKCHAIN)\n-\tcfun_frame_layout.frame_size += UNITS_PER_WORD;\n+\tcfun_frame_layout.frame_size += UNITS_PER_LONG;\n \n       /* No alignment trouble here because f8-f15 are only saved under\n \t 64 bit.  */\n@@ -7340,7 +7349,7 @@ s390_hard_regno_mode_ok (unsigned int regno, enum machine_mode mode)\n     case GENERAL_REGS:\n       if (REGNO_PAIR_OK (regno, mode))\n \t{\n-\t  if (TARGET_64BIT\n+\t  if (TARGET_ZARCH\n \t      || (mode != TFmode && mode != TCmode && mode != TDmode))\n \t    return true;\n \t}\n@@ -7471,7 +7480,7 @@ s390_initial_elimination_offset (int from, int to)\n       index = RETURN_REGNUM - cfun_frame_layout.first_save_gpr_slot;\n       gcc_assert (index >= 0);\n       offset = cfun_frame_layout.frame_size + cfun_frame_layout.gprs_offset;\n-      offset += index * UNITS_PER_WORD;\n+      offset += index * UNITS_PER_LONG;\n       break;\n \n     case BASE_REGNUM:\n@@ -7607,7 +7616,7 @@ save_gprs (rtx base, int offset, int first, int last)\n       if (start > last)\n \treturn insn;\n \n-      addr = plus_constant (base, offset + (start - first) * UNITS_PER_WORD);\n+      addr = plus_constant (base, offset + (start - first) * UNITS_PER_LONG);\n       note = gen_store_multiple (gen_rtx_MEM (Pmode, addr),\n \t\t\t\t gen_rtx_REG (Pmode, start),\n \t\t\t\t GEN_INT (last - start + 1));\n@@ -7756,7 +7765,7 @@ s390_emit_prologue (void)\n     {\n       insn = save_gprs (stack_pointer_rtx,\n \t\t\tcfun_frame_layout.gprs_offset +\n-\t\t\tUNITS_PER_WORD * (cfun_frame_layout.first_save_gpr\n+\t\t\tUNITS_PER_LONG * (cfun_frame_layout.first_save_gpr\n \t\t\t\t\t  - cfun_frame_layout.first_save_gpr_slot),\n \t\t\tcfun_frame_layout.first_save_gpr,\n \t\t\tcfun_frame_layout.last_save_gpr);\n@@ -8153,7 +8162,7 @@ s390_emit_epilogue (bool sibcall)\n \t      addr = plus_constant (frame_pointer,\n \t\t\t\t    offset + cfun_frame_layout.gprs_offset\n \t\t\t\t    + (i - cfun_frame_layout.first_save_gpr_slot)\n-\t\t\t\t    * UNITS_PER_WORD);\n+\t\t\t\t    * UNITS_PER_LONG);\n \t      addr = gen_rtx_MEM (Pmode, addr);\n \t      set_mem_alias_set (addr, get_frame_alias_set ());\n \t      emit_move_insn (addr, gen_rtx_REG (Pmode, i));\n@@ -8182,7 +8191,7 @@ s390_emit_epilogue (bool sibcall)\n \t\t\t\t    offset + cfun_frame_layout.gprs_offset\n \t\t\t\t    + (RETURN_REGNUM\n \t\t\t\t       - cfun_frame_layout.first_save_gpr_slot)\n-\t\t\t\t    * UNITS_PER_WORD);\n+\t\t\t\t    * UNITS_PER_LONG);\n \t      addr = gen_rtx_MEM (Pmode, addr);\n \t      set_mem_alias_set (addr, get_frame_alias_set ());\n \t      emit_move_insn (return_reg, addr);\n@@ -8193,7 +8202,7 @@ s390_emit_epilogue (bool sibcall)\n \t\t\t   offset + cfun_frame_layout.gprs_offset\n \t\t\t   + (cfun_frame_layout.first_restore_gpr\n \t\t\t      - cfun_frame_layout.first_save_gpr_slot)\n-\t\t\t   * UNITS_PER_WORD,\n+\t\t\t   * UNITS_PER_LONG,\n \t\t\t   cfun_frame_layout.first_restore_gpr,\n \t\t\t   cfun_frame_layout.last_restore_gpr);\n       insn = emit_insn (insn);\n@@ -8357,7 +8366,7 @@ s390_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n   else if (s390_function_arg_integer (mode, type))\n     {\n       int size = s390_function_arg_size (mode, type);\n-      cum->gprs += ((size + UNITS_PER_WORD-1) / UNITS_PER_WORD);\n+      cum->gprs += ((size + UNITS_PER_LONG - 1) / UNITS_PER_LONG);\n     }\n   else\n     gcc_unreachable ();\n@@ -8396,12 +8405,25 @@ s390_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type,\n   else if (s390_function_arg_integer (mode, type))\n     {\n       int size = s390_function_arg_size (mode, type);\n-      int n_gprs = (size + UNITS_PER_WORD-1) / UNITS_PER_WORD;\n+      int n_gprs = (size + UNITS_PER_LONG - 1) / UNITS_PER_LONG;\n \n       if (cum->gprs + n_gprs > GP_ARG_NUM_REG)\n \treturn 0;\n-      else\n+      else if (n_gprs == 1 || UNITS_PER_WORD == UNITS_PER_LONG)\n \treturn gen_rtx_REG (mode, cum->gprs + 2);\n+      else if (n_gprs == 2)\n+\t{\n+\t  rtvec p = rtvec_alloc (2);\n+\n+\t  RTVEC_ELT (p, 0)\n+\t    = gen_rtx_EXPR_LIST (SImode, gen_rtx_REG (SImode, cum->gprs + 2),\n+\t\t\t\t\t const0_rtx);\n+\t  RTVEC_ELT (p, 1)\n+\t    = gen_rtx_EXPR_LIST (SImode, gen_rtx_REG (SImode, cum->gprs + 3),\n+\t\t\t\t\t GEN_INT (4));\n+\n+\t  return gen_rtx_PARALLEL (mode, p);\n+\t}\n     }\n \n   /* After the real arguments, expand_call calls us once again\n@@ -8451,7 +8473,7 @@ s390_promote_function_mode (const_tree type, enum machine_mode mode,\n                             int for_return ATTRIBUTE_UNUSED)\n {\n   if (INTEGRAL_MODE_P (mode)\n-      && GET_MODE_SIZE (mode) < UNITS_PER_WORD)\n+      && GET_MODE_SIZE (mode) < UNITS_PER_LONG)\n     {\n       if (POINTER_TYPE_P (type))\n \t*punsignedp = POINTERS_EXTEND_UNSIGNED;\n@@ -8479,8 +8501,22 @@ s390_function_value (const_tree type, const_tree fn, enum machine_mode mode)\n \n   if (TARGET_HARD_FLOAT && SCALAR_FLOAT_MODE_P (mode))\n     return gen_rtx_REG (mode, 16);\n-  else\n+  else if (GET_MODE_SIZE (mode) <= UNITS_PER_LONG\n+\t   || UNITS_PER_LONG == UNITS_PER_WORD)\n     return gen_rtx_REG (mode, 2);\n+  else if (GET_MODE_SIZE (mode) == 2 * UNITS_PER_LONG)\n+    {\n+      rtvec p = rtvec_alloc (2);\n+\n+      RTVEC_ELT (p, 0)\n+\t= gen_rtx_EXPR_LIST (SImode, gen_rtx_REG (SImode, 2), const0_rtx);\n+      RTVEC_ELT (p, 1)\n+\t= gen_rtx_EXPR_LIST (SImode, gen_rtx_REG (SImode, 3), GEN_INT (4));\n+\n+      return gen_rtx_PARALLEL (mode, p);\n+    }\n+\n+  gcc_unreachable ();\n }\n \n \n@@ -8628,7 +8664,7 @@ s390_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n     {\n       t = make_tree (TREE_TYPE (sav), return_address_pointer_rtx);\n       t = build2 (POINTER_PLUS_EXPR, TREE_TYPE (sav), t,\n-\t          size_int (-RETURN_REGNUM * UNITS_PER_WORD));\n+\t          size_int (-RETURN_REGNUM * UNITS_PER_LONG));\n \n       t = build2 (MODIFY_EXPR, TREE_TYPE (sav), sav, t);\n       TREE_SIDE_EFFECTS (t) = 1;\n@@ -8702,9 +8738,9 @@ s390_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,\n       /* kernel stack layout on 31 bit: It is assumed here that no padding\n \t will be added by s390_frame_info because for va_args always an even\n \t number of gprs has to be saved r15-r2 = 14 regs.  */\n-      sav_ofs = 2 * UNITS_PER_WORD;\n-      sav_scale = UNITS_PER_WORD;\n-      size = UNITS_PER_WORD;\n+      sav_ofs = 2 * UNITS_PER_LONG;\n+      sav_scale = UNITS_PER_LONG;\n+      size = UNITS_PER_LONG;\n       max_reg = GP_ARG_NUM_REG - n_reg;\n     }\n   else if (s390_function_arg_float (TYPE_MODE (type), type))\n@@ -8719,7 +8755,7 @@ s390_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,\n       indirect_p = 0;\n       reg = fpr;\n       n_reg = 1;\n-      sav_ofs = 16 * UNITS_PER_WORD;\n+      sav_ofs = 16 * UNITS_PER_LONG;\n       sav_scale = 8;\n       max_reg = FP_ARG_NUM_REG - n_reg;\n     }\n@@ -8734,17 +8770,17 @@ s390_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,\n       /* Otherwise into GP registers.  */\n       indirect_p = 0;\n       reg = gpr;\n-      n_reg = (size + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+      n_reg = (size + UNITS_PER_LONG - 1) / UNITS_PER_LONG;\n \n       /* kernel stack layout on 31 bit: It is assumed here that no padding\n \t will be added by s390_frame_info because for va_args always an even\n \t number of gprs has to be saved r15-r2 = 14 regs.  */\n-      sav_ofs = 2 * UNITS_PER_WORD;\n+      sav_ofs = 2 * UNITS_PER_LONG;\n \n-      if (size < UNITS_PER_WORD)\n-\tsav_ofs += UNITS_PER_WORD - size;\n+      if (size < UNITS_PER_LONG)\n+\tsav_ofs += UNITS_PER_LONG - size;\n \n-      sav_scale = UNITS_PER_WORD;\n+      sav_scale = UNITS_PER_LONG;\n       max_reg = GP_ARG_NUM_REG - n_reg;\n     }\n \n@@ -8776,9 +8812,9 @@ s390_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,\n   /* ... Otherwise out of the overflow area.  */\n \n   t = ovf;\n-  if (size < UNITS_PER_WORD)\n+  if (size < UNITS_PER_LONG)\n     t = build2 (POINTER_PLUS_EXPR, ptr_type_node, t,\n-\t\tsize_int (UNITS_PER_WORD - size));\n+\t\tsize_int (UNITS_PER_LONG - size));\n \n   gimplify_expr (&t, pre_p, NULL, is_gimple_val, fb_rvalue);\n \n@@ -9002,7 +9038,7 @@ s390_function_profiler (FILE *file, int labelno)\n \n   op[0] = gen_rtx_REG (Pmode, RETURN_REGNUM);\n   op[1] = gen_rtx_REG (Pmode, STACK_POINTER_REGNUM);\n-  op[1] = gen_rtx_MEM (Pmode, plus_constant (op[1], UNITS_PER_WORD));\n+  op[1] = gen_rtx_MEM (Pmode, plus_constant (op[1], UNITS_PER_LONG));\n \n   op[2] = gen_rtx_REG (Pmode, 1);\n   op[3] = gen_rtx_SYMBOL_REF (Pmode, label);\n@@ -9408,14 +9444,50 @@ s390_call_saved_register_used (tree call_expr)\n \n        s390_function_arg_advance (&cum, mode, type, 0);\n \n-       if (parm_rtx && REG_P (parm_rtx))\n+       if (!parm_rtx)\n+\t continue;\n+\n+       if (REG_P (parm_rtx))\n+  \t {\n+\t   int n_regs;\n+\n+\t   /* Only integer registers (r6) are call saved and used for\n+\t      parameter passing.  */\n+\t   if (REGNO_REG_CLASS (REGNO (parm_rtx)) == FP_REGS)\n+\t     continue;\n+\n+\t   n_regs = ((GET_MODE_SIZE (GET_MODE (parm_rtx)) + UNITS_PER_LONG - 1)\n+\t\t     / UNITS_PER_LONG);\n+\n+\t   for (reg = 0; reg < n_regs; reg++)\n+\t     if (!call_used_regs[reg + REGNO (parm_rtx)])\n+ \t       return true;\n+\t }\n+\n+       if (GET_CODE (parm_rtx) == PARALLEL)\n \t {\n-\t   for (reg = 0;\n-\t\treg < HARD_REGNO_NREGS (REGNO (parm_rtx), GET_MODE (parm_rtx));\n-\t\treg++)\n-\t     if (! call_used_regs[reg + REGNO (parm_rtx)])\n-\t       return true;\n+\t   int i;\n+\t   for (i = 0; i < XVECLEN (parm_rtx, 0); i++)\n+\t     {\n+\t       rtx r = XEXP (XVECEXP (parm_rtx, 0, i), 0);\n+\t       int n_regs;\n+\n+\t       gcc_assert (REG_P (r));\n+\n+\t       /* Only integer registers (r6) are call saved and used\n+\t\t  for parameter passing.  */\n+\t       if (REGNO_REG_CLASS (REGNO (r)) == FP_REGS)\n+\t\t continue;\n+\n+\t       n_regs = ((GET_MODE_SIZE (GET_MODE (r)) + UNITS_PER_LONG - 1)\n+\t\t\t / UNITS_PER_LONG);\n+\n+\t       for (reg = 0; reg < n_regs; reg++)\n+\t\t if (!call_used_regs[reg + REGNO (r)])\n+\t\t   return true;\n+\t     }\n \t }\n+\n     }\n   return false;\n }\n@@ -9661,7 +9733,7 @@ s390_optimize_prologue (void)\n \t    {\n \t      new_insn \t= save_gprs (base,\n \t\t\t\t     off + (cfun_frame_layout.first_save_gpr\n-\t\t\t\t\t    - first) * UNITS_PER_WORD,\n+\t\t\t\t\t    - first) * UNITS_PER_LONG,\n \t\t\t\t     cfun_frame_layout.first_save_gpr,\n \t\t\t\t     cfun_frame_layout.last_save_gpr);\n \t      new_insn = emit_insn_before (new_insn, insn);\n@@ -9722,7 +9794,7 @@ s390_optimize_prologue (void)\n \t    {\n \t      new_insn = restore_gprs (base,\n \t\t\t\t       off + (cfun_frame_layout.first_restore_gpr\n-\t\t\t\t\t      - first) * UNITS_PER_WORD,\n+\t\t\t\t\t      - first) * UNITS_PER_LONG,\n \t\t\t\t       cfun_frame_layout.first_restore_gpr,\n \t\t\t\t       cfun_frame_layout.last_restore_gpr);\n \t      new_insn = emit_insn_before (new_insn, insn);\n@@ -10319,12 +10391,16 @@ s390_loop_unroll_adjust (unsigned nunroll, struct loop *loop)\n \n #undef TARGET_DEFAULT_TARGET_FLAGS\n #define TARGET_DEFAULT_TARGET_FLAGS (TARGET_DEFAULT | MASK_FUSED_MADD)\n+\n #undef TARGET_HANDLE_OPTION\n #define TARGET_HANDLE_OPTION s390_handle_option\n \n #undef\tTARGET_ENCODE_SECTION_INFO\n #define TARGET_ENCODE_SECTION_INFO s390_encode_section_info\n \n+#undef TARGET_SCALAR_MODE_SUPPORTED_P\n+#define TARGET_SCALAR_MODE_SUPPORTED_P s390_scalar_mode_supported_p\n+\n #ifdef HAVE_AS_TLS\n #undef TARGET_HAVE_TLS\n #define TARGET_HAVE_TLS true\n@@ -10438,6 +10514,9 @@ s390_loop_unroll_adjust (unsigned nunroll, struct loop *loop)\n #undef TARGET_TRAMPOLINE_INIT\n #define TARGET_TRAMPOLINE_INIT s390_trampoline_init\n \n+#undef TARGET_UNWIND_WORD_MODE\n+#define TARGET_UNWIND_WORD_MODE s390_unwind_word_mode\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #include \"gt-s390.h\""}, {"sha": "5acdd5860581b02df2535e5c48437ee8bfcde350", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 46, "deletions": 22, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9602b6a1b8de60ca429f08ca00e2834d26fe1f47/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9602b6a1b8de60ca429f08ca00e2834d26fe1f47/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=9602b6a1b8de60ca429f08ca00e2834d26fe1f47", "patch": "@@ -108,6 +108,8 @@ extern int s390_arch_flags;\n       builtin_assert (\"cpu=s390\");\t\t\t\\\n       builtin_assert (\"machine=s390\");\t\t\t\\\n       builtin_define (\"__s390__\");\t\t\t\\\n+      if (TARGET_ZARCH)\t\t\t\t\t\\\n+\tbuiltin_define (\"__zarch__\");\t\t\t\\\n       if (TARGET_64BIT)\t\t\t\t\t\\\n         builtin_define (\"__s390x__\");\t\t\t\\\n       if (TARGET_LONG_DOUBLE_128)\t\t\t\\\n@@ -185,30 +187,40 @@ extern int s390_arch_flags;\n #define S390_TDC_INFINITY (S390_TDC_POSITIVE_INFINITY \\\n \t\t\t  | S390_TDC_NEGATIVE_INFINITY )\n \n-/* In libgcc2, determine target settings as compile-time constants.  */\n-#ifdef IN_LIBGCC2\n-#undef TARGET_64BIT\n-#ifdef __s390x__\n-#define TARGET_64BIT 1\n-#else\n-#define TARGET_64BIT 0\n-#endif\n-#endif\n-\n-\n /* Target machine storage layout.  */\n \n /* Everything is big-endian.  */\n #define BITS_BIG_ENDIAN 1\n #define BYTES_BIG_ENDIAN 1\n #define WORDS_BIG_ENDIAN 1\n \n-/* Width of a word, in units (bytes).  */\n-#define UNITS_PER_WORD (TARGET_64BIT ? 8 : 4)\n+#define STACK_SIZE_MODE (Pmode)\n+\n #ifndef IN_LIBGCC2\n-#define MIN_UNITS_PER_WORD 4\n+\n+/* Width of a word, in units (bytes).  */\n+  #define UNITS_PER_WORD (TARGET_ZARCH ? 8 : 4)\n+\n+/* Width of a pointer.  To be used instead of UNITS_PER_WORD in\n+   ABI-relevant contexts.  This always matches\n+   GET_MODE_SIZE (Pmode).  */\n+  #define UNITS_PER_LONG (TARGET_64BIT ? 8 : 4)\n+  #define MIN_UNITS_PER_WORD 4\n+  #define MAX_BITS_PER_WORD 64\n+#else\n+\n+  /* In libgcc, UNITS_PER_WORD has ABI-relevant effects, e.g. whether\n+     the library should export TImode functions or not.  Thus, we have\n+     to redefine UNITS_PER_WORD depending on __s390x__ for libgcc.  */\n+  #ifdef __s390x__\n+    #define UNITS_PER_WORD 8\n+  #else\n+    #define UNITS_PER_WORD 4\n+  #endif\n #endif\n-#define MAX_BITS_PER_WORD 64\n+\n+/* Width of a pointer, in bits.  */\n+#define POINTER_SIZE (TARGET_64BIT ? 64 : 32)\n \n /* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n #define PARM_BOUNDARY (TARGET_64BIT ? 64 : 32)\n@@ -402,6 +414,15 @@ extern int s390_arch_flags;\n    (((MODE1) == SFmode || (MODE1) == DFmode)\t\\\n    == ((MODE2) == SFmode || (MODE2) == DFmode))\n \n+/* When generating code that runs in z/Architecture mode,\n+   but conforms to the 31-bit ABI, GPRs can hold 8 bytes;\n+   the ABI guarantees only that the lower 4 bytes are\n+   saved across calls, however.  */\n+#define HARD_REGNO_CALL_PART_CLOBBERED(REGNO, MODE)\t\t\\\n+  (!TARGET_64BIT && TARGET_ZARCH\t\t\t\t\\\n+   && GET_MODE_SIZE (MODE) > 4\t\t\t\t\t\\\n+   && (((REGNO) >= 6 && (REGNO) <= 15) || (REGNO) == 32))\n+\n /* Maximum number of registers to represent a value of mode MODE\n    in a register of class CLASS.  */\n #define CLASS_MAX_NREGS(CLASS, MODE)   \t\t\t\t\t\\\n@@ -573,7 +594,7 @@ extern const enum reg_class regclass_map[FIRST_PSEUDO_REGISTER];\n    the corresponding RETURN_REGNUM register was saved.  */\n #define DYNAMIC_CHAIN_ADDRESS(FRAME)                                          \\\n   (TARGET_PACKED_STACK ?                                                      \\\n-   plus_constant ((FRAME), STACK_POINTER_OFFSET - UNITS_PER_WORD) : (FRAME))\n+   plus_constant ((FRAME), STACK_POINTER_OFFSET - UNITS_PER_LONG) : (FRAME))\n \n /* For -mpacked-stack this adds 160 - 8 (96 - 4) to the output of\n    builtin_frame_address.  Otherwise arg pointer -\n@@ -609,6 +630,9 @@ extern const enum reg_class regclass_map[FIRST_PSEUDO_REGISTER];\n     ? ((GLOBAL) ? DW_EH_PE_indirect : 0) | DW_EH_PE_pcrel | DW_EH_PE_sdata4 \\\n    : DW_EH_PE_absptr)\n \n+/* Register save slot alignment.  */\n+#define DWARF_CIE_DATA_ALIGNMENT (-UNITS_PER_LONG)\n+\n \n /* Frame registers.  */\n \n@@ -790,19 +814,19 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n /* The maximum number of bytes that a single instruction can move quickly\n    between memory and registers or between two memory locations.  */\n-#define MOVE_MAX (TARGET_64BIT ? 16 : 8)\n-#define MOVE_MAX_PIECES (TARGET_64BIT ? 8 : 4)\n+#define MOVE_MAX (TARGET_ZARCH ? 16 : 8)\n+#define MOVE_MAX_PIECES (TARGET_ZARCH ? 8 : 4)\n #define MAX_MOVE_MAX 16\n \n /* Determine whether to use move_by_pieces or block move insn.  */\n #define MOVE_BY_PIECES_P(SIZE, ALIGN)\t\t\\\n   ( (SIZE) == 1 || (SIZE) == 2 || (SIZE) == 4\t\\\n-    || (TARGET_64BIT && (SIZE) == 8) )\n+    || (TARGET_ZARCH && (SIZE) == 8) )\n \n /* Determine whether to use clear_by_pieces or block clear insn.  */\n #define CLEAR_BY_PIECES_P(SIZE, ALIGN)\t\t\\\n   ( (SIZE) == 1 || (SIZE) == 2 || (SIZE) == 4\t\\\n-    || (TARGET_64BIT && (SIZE) == 8) )\n+    || (TARGET_ZARCH && (SIZE) == 8) )\n \n /* This macro is used to determine whether store_by_pieces should be\n    called to \"memcpy\" storage when the source is a constant string.  */\n@@ -907,7 +931,7 @@ do {\t\t\t\t\t\t\t\\\n #define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)\t\t\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n   char buf[32];\t\t\t\t\t\t\t\t\\\n-  fputs (integer_asm_op (UNITS_PER_WORD, TRUE), (FILE));\t\t\\\n+  fputs (integer_asm_op (UNITS_PER_LONG, TRUE), (FILE));\t\t\\\n   ASM_GENERATE_INTERNAL_LABEL (buf, \"L\", (VALUE));\t\t\t\\\n   assemble_name ((FILE), buf);\t\t\t\t\t\t\\\n   fputc ('\\n', (FILE));\t\t\t\t\t\t\t\\\n@@ -917,7 +941,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n   char buf[32];\t\t\t\t\t\t\t\t\\\n-  fputs (integer_asm_op (UNITS_PER_WORD, TRUE), (FILE));\t\t\\\n+  fputs (integer_asm_op (UNITS_PER_LONG, TRUE), (FILE));\t\t\\\n   ASM_GENERATE_INTERNAL_LABEL (buf, \"L\", (VALUE));\t\t\t\\\n   assemble_name ((FILE), buf);\t\t\t\t\t\t\\\n   fputc ('-', (FILE));\t\t\t\t\t\t\t\\"}, {"sha": "40668984f02cef803fcb0b4cce84ddc707edc992", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 217, "deletions": 165, "changes": 382, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9602b6a1b8de60ca429f08ca00e2834d26fe1f47/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9602b6a1b8de60ca429f08ca00e2834d26fe1f47/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=9602b6a1b8de60ca429f08ca00e2834d26fe1f47", "patch": "@@ -337,21 +337,25 @@\n \n ;; These mode iterators allow 31-bit and 64-bit GPR patterns to be generated\n ;; from the same template.\n-(define_mode_iterator GPR [(DI \"TARGET_64BIT\") SI])\n+(define_mode_iterator GPR [(DI \"TARGET_ZARCH\") SI])\n (define_mode_iterator DSI [DI SI])\n \n ;; These mode iterators allow :P to be used for patterns that operate on\n ;; pointer-sized quantities.  Exactly one of the two alternatives will match.\n-(define_mode_iterator DP  [(TI \"TARGET_64BIT\") (DI \"!TARGET_64BIT\")])\n (define_mode_iterator P [(DI \"TARGET_64BIT\") (SI \"!TARGET_64BIT\")])\n \n+;; These macros refer to the actual word_mode of the configuration. This is equal\n+;; to Pmode except on 31-bit machines in zarch mode.\n+(define_mode_iterator DW [(TI \"TARGET_ZARCH\") (DI \"!TARGET_ZARCH\")])\n+(define_mode_iterator W  [(DI \"TARGET_ZARCH\") (SI \"!TARGET_ZARCH\")])\n+\n ;; This mode iterator allows the QI and HI patterns to be defined from\n ;; the same template.\n (define_mode_iterator HQI [HI QI])\n \n ;; This mode iterator allows the integer patterns to be defined from the\n ;; same template.\n-(define_mode_iterator INT [(DI \"TARGET_64BIT\") SI HI QI])\n+(define_mode_iterator INT [(DI \"TARGET_ZARCH\") SI HI QI])\n (define_mode_iterator INTALL [TI DI SI HI QI])\n \n ;; This iterator allows some 'ashift' and 'lshiftrt' pattern to be defined from\n@@ -455,7 +459,7 @@\n ;; variant for long displacements.\n (define_mode_attr y [(DI \"g\") (SI \"y\")])\n \n-;; In DP templates, a string like \"cds<g>\" will expand to \"cdsg\" in TImode\n+;; In DW templates, a string like \"cds<g>\" will expand to \"cdsg\" in TImode\n ;; and \"cds\" in DImode.\n (define_mode_attr tg [(TI \"g\") (DI \"\")])\n \n@@ -506,7 +510,7 @@\n                          (match_operand:DI 1 \"immediate_operand\"\n \t\t\t\t\t     \"N0HD0,N1HD0,N2HD0,N3HD0\"))\n                  (match_operand:DI 2 \"immediate_operand\" \"n,n,n,n\")))]\n-  \"TARGET_64BIT\n+  \"TARGET_ZARCH\n    && s390_match_ccmode (insn, s390_tm_ccmode (operands[1], operands[2], true))\n    && s390_single_part (operands[1], DImode, HImode, 0) >= 0\"\n   \"@\n@@ -556,7 +560,7 @@\n \t  (match_operand:DI 1 \"const0_operand\" \"\")))\n    (set (match_operand:DI 2 \"register_operand\" \"=d,d\")\n         (sign_extend:DI (match_dup 0)))]\n-  \"s390_match_ccmode(insn, CCSmode) && TARGET_64BIT\"\n+  \"s390_match_ccmode(insn, CCSmode) && TARGET_ZARCH\"\n   \"ltgfr\\t%2,%0\n    ltgf\\t%2,%0\"\n   [(set_attr \"op_type\"      \"RRE,RXY\")\n@@ -596,7 +600,7 @@\n                  (match_operand:DI 1 \"const0_operand\" \"\")))\n    (set (match_operand:DI 2 \"register_operand\" \"=d\")\n         (match_dup 0))]\n-  \"s390_match_ccmode(insn, CCSmode) && TARGET_64BIT && !TARGET_EXTIMM\"\n+  \"s390_match_ccmode(insn, CCSmode) && TARGET_ZARCH && !TARGET_EXTIMM\"\n   \"ltgr\\t%2,%0\"\n   [(set_attr \"op_type\" \"RRE\")\n    (set_attr \"z10prop\" \"z10_fr_E1\")])\n@@ -632,7 +636,7 @@\n   [(set (reg CC_REGNUM)\n         (compare (match_operand:DI 0 \"register_operand\" \"d\")\n                  (match_operand:DI 1 \"const0_operand\" \"\")))]\n-  \"s390_match_ccmode(insn, CCSmode) && !TARGET_64BIT\"\n+  \"s390_match_ccmode(insn, CCSmode) && !TARGET_ZARCH\"\n   \"srda\\t%0,0\"\n   [(set_attr \"op_type\" \"RS\")\n    (set_attr \"atype\"   \"reg\")])\n@@ -720,7 +724,7 @@\n   [(set (reg CC_REGNUM)\n         (compare (match_operand:DI 0 \"nonimmediate_operand\" \"%d,d,d,d,Q\")\n                  (match_operand:DI 1 \"general_operand\" \"d,K,Os,RT,BQ\")))]\n-  \"s390_match_ccmode (insn, CCTmode) && TARGET_64BIT\"\n+  \"s390_match_ccmode (insn, CCTmode) && TARGET_ZARCH\"\n   \"@\n    cgr\\t%0,%1\n    cghi\\t%0,%h1\n@@ -752,7 +756,7 @@\n         (compare (sign_extend:DI (match_operand:SI 1 \"nonimmediate_operand\"\n \t\t\t\t\t\t     \"d,RT,b\"))\n                  (match_operand:DI 0 \"register_operand\" \"d, d,d\")))]\n-  \"s390_match_ccmode(insn, CCSRmode) && TARGET_64BIT\"\n+  \"s390_match_ccmode(insn, CCSRmode) && TARGET_ZARCH\"\n   \"@\n    cgfr\\t%0,%1\n    cgf\\t%0,%1\n@@ -847,7 +851,7 @@\n         (compare (zero_extend:DI (match_operand:SI 1 \"nonimmediate_operand\"\n                                                         \"d,RT,b\"))\n                  (match_operand:DI 0 \"register_operand\" \"d, d,d\")))]\n-  \"s390_match_ccmode (insn, CCURmode) && TARGET_64BIT\"\n+  \"s390_match_ccmode (insn, CCURmode) && TARGET_ZARCH\"\n   \"@\n    clgfr\\t%0,%1\n    clgf\\t%0,%1\n@@ -863,7 +867,7 @@\n                                      \"d, d,d,Q, d, Q,BQ\")\n                  (match_operand:DI 1 \"general_operand\"\n                                      \"d,Op,b,D,RT,BQ,Q\")))]\n-  \"s390_match_ccmode (insn, CCUmode) && TARGET_64BIT\"\n+  \"s390_match_ccmode (insn, CCUmode) && TARGET_ZARCH\"\n   \"@\n    clgr\\t%0,%1\n    clgfi\\t%0,%1\n@@ -1115,7 +1119,7 @@\n (define_insn \"movti\"\n   [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=d,QS,d,o\")\n         (match_operand:TI 1 \"general_operand\" \"QS,d,dPRT,d\"))]\n-  \"TARGET_64BIT\"\n+  \"TARGET_ZARCH\"\n   \"@\n    lmg\\t%0,%N0,%S1\n    stmg\\t%1,%N1,%S0\n@@ -1127,7 +1131,7 @@\n (define_split\n   [(set (match_operand:TI 0 \"nonimmediate_operand\" \"\")\n         (match_operand:TI 1 \"general_operand\" \"\"))]\n-  \"TARGET_64BIT && reload_completed\n+  \"TARGET_ZARCH && reload_completed\n    && s390_split_ok_p (operands[0], operands[1], TImode, 0)\"\n   [(set (match_dup 2) (match_dup 4))\n    (set (match_dup 3) (match_dup 5))]\n@@ -1141,7 +1145,7 @@\n (define_split\n   [(set (match_operand:TI 0 \"nonimmediate_operand\" \"\")\n         (match_operand:TI 1 \"general_operand\" \"\"))]\n-  \"TARGET_64BIT && reload_completed\n+  \"TARGET_ZARCH && reload_completed\n    && s390_split_ok_p (operands[0], operands[1], TImode, 1)\"\n   [(set (match_dup 2) (match_dup 4))\n    (set (match_dup 3) (match_dup 5))]\n@@ -1155,11 +1159,12 @@\n (define_split\n   [(set (match_operand:TI 0 \"register_operand\" \"\")\n         (match_operand:TI 1 \"memory_operand\" \"\"))]\n-  \"TARGET_64BIT && reload_completed\n+  \"TARGET_ZARCH && reload_completed\n    && !s_operand (operands[1], VOIDmode)\"\n   [(set (match_dup 0) (match_dup 1))]\n {\n   rtx addr = operand_subword (operands[0], 1, 0, TImode);\n+  addr = gen_lowpart (Pmode, addr);\n   s390_load_address (addr, XEXP (operands[1], 0));\n   operands[1] = replace_equiv_address (operands[1], addr);\n })\n@@ -1308,7 +1313,7 @@\n         (match_operand:DI 1 \"general_operand\"\n                             \"K,N0HD0,N1HD0,N2HD0,N3HD0,Os,N0SD0,N1SD0,d,f,L,b,d,RT,\n                              d,*f,R,T,*f,*f,d,K,t,d,t,Q\"))]\n-  \"TARGET_64BIT\"\n+  \"TARGET_ZARCH\"\n   \"@\n    lghi\\t%0,%h1\n    llihh\\t%0,%i1\n@@ -1375,7 +1380,7 @@\n (define_split\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n         (match_operand:DI 1 \"register_operand\" \"\"))]\n-  \"TARGET_64BIT && ACCESS_REG_P (operands[1])\"\n+  \"TARGET_ZARCH && ACCESS_REG_P (operands[1])\"\n   [(set (match_dup 2) (match_dup 3))\n    (set (match_dup 0) (ashift:DI (match_dup 0) (const_int 32)))\n    (set (strict_low_part (match_dup 2)) (match_dup 4))]\n@@ -1385,7 +1390,7 @@\n (define_split\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n         (match_operand:DI 1 \"register_operand\" \"\"))]\n-  \"TARGET_64BIT && ACCESS_REG_P (operands[0])\n+  \"TARGET_ZARCH && ACCESS_REG_P (operands[0])\n    && dead_or_set_p (insn, operands[1])\"\n   [(set (match_dup 3) (match_dup 2))\n    (set (match_dup 1) (lshiftrt:DI (match_dup 1) (const_int 32)))\n@@ -1396,7 +1401,7 @@\n (define_split\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n         (match_operand:DI 1 \"register_operand\" \"\"))]\n-  \"TARGET_64BIT && ACCESS_REG_P (operands[0])\n+  \"TARGET_ZARCH && ACCESS_REG_P (operands[0])\n    && !dead_or_set_p (insn, operands[1])\"\n   [(set (match_dup 3) (match_dup 2))\n    (set (match_dup 1) (rotate:DI (match_dup 1) (const_int 32)))\n@@ -1410,7 +1415,7 @@\n                             \"=d,d,Q,S,d   ,o,!*f,!*f,!*f,!R,!T,d\")\n         (match_operand:DI 1 \"general_operand\"\n                             \" Q,S,d,d,dPRT,d, *f,  R,  T,*f,*f,b\"))]\n-  \"!TARGET_64BIT\"\n+  \"!TARGET_ZARCH\"\n   \"@\n    lm\\t%0,%N0,%S1\n    lmy\\t%0,%N0,%S1\n@@ -1433,7 +1438,7 @@\n (define_split\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n         (match_operand:DI 1 \"memory_operand\" \"\"))]\n-  \"!TARGET_64BIT && reload_completed && TARGET_Z10\n+  \"!TARGET_ZARCH && reload_completed && TARGET_Z10\n    && larl_operand (XEXP (operands[1], 0), SImode)\"\n   [(set (match_dup 2) (match_dup 3))\n    (set (match_dup 0) (match_dup 1))]\n@@ -1446,7 +1451,7 @@\n (define_split\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n         (match_operand:DI 1 \"general_operand\" \"\"))]\n-  \"!TARGET_64BIT && reload_completed\n+  \"!TARGET_ZARCH && reload_completed\n    && s390_split_ok_p (operands[0], operands[1], DImode, 0)\"\n   [(set (match_dup 2) (match_dup 4))\n    (set (match_dup 3) (match_dup 5))]\n@@ -1460,7 +1465,7 @@\n (define_split\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n         (match_operand:DI 1 \"general_operand\" \"\"))]\n-  \"!TARGET_64BIT && reload_completed\n+  \"!TARGET_ZARCH && reload_completed\n    && s390_split_ok_p (operands[0], operands[1], DImode, 1)\"\n   [(set (match_dup 2) (match_dup 4))\n    (set (match_dup 3) (match_dup 5))]\n@@ -1474,7 +1479,7 @@\n (define_split\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n         (match_operand:DI 1 \"memory_operand\" \"\"))]\n-  \"!TARGET_64BIT && reload_completed\n+  \"!TARGET_ZARCH && reload_completed\n    && !FP_REG_P (operands[0])\n    && !s_operand (operands[1], VOIDmode)\"\n   [(set (match_dup 0) (match_dup 1))]\n@@ -1487,7 +1492,7 @@\n (define_peephole2\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n         (mem:DI (match_operand 1 \"address_operand\" \"\")))]\n-  \"TARGET_64BIT\n+  \"TARGET_ZARCH\n    && !FP_REG_P (operands[0])\n    && GET_CODE (operands[1]) == SYMBOL_REF\n    && CONSTANT_POOL_ADDRESS_P (operands[1])\n@@ -1826,8 +1831,8 @@\n       && register_operand (operands[0], VOIDmode)\n       && GET_CODE (operands[1]) == MEM)\n     {\n-      rtx tmp = gen_reg_rtx (word_mode);\n-      rtx ext = gen_rtx_ZERO_EXTEND (word_mode, operands[1]);\n+      rtx tmp = gen_reg_rtx (DImode);\n+      rtx ext = gen_rtx_ZERO_EXTEND (DImode, operands[1]);\n       emit_insn (gen_rtx_SET (VOIDmode, tmp, ext));\n       operands[1] = gen_lowpart (QImode, tmp);\n     }\n@@ -1905,7 +1910,7 @@\n (define_insn \"movstrictsi\"\n   [(set (strict_low_part (match_operand:SI 0 \"register_operand\" \"+d,d,d,d\"))\n                          (match_operand:SI 1 \"general_operand\" \"d,R,T,t\"))]\n-  \"TARGET_64BIT\"\n+  \"TARGET_ZARCH\"\n   \"@\n    lr\\t%0,%1\n    l\\t%0,%1\n@@ -1928,7 +1933,7 @@\n (define_insn \"*mov<mode>_64\"\n   [(set (match_operand:TD_TF 0 \"nonimmediate_operand\" \"=f,f,f,o, d,QS,  d,o\")\n         (match_operand:TD_TF 1 \"general_operand\"      \" G,f,o,f,QS, d,dRT,d\"))]\n-  \"TARGET_64BIT\"\n+  \"TARGET_ZARCH\"\n   \"@\n    lzxr\\t%0\n    lxr\\t%0,%1\n@@ -1944,7 +1949,7 @@\n (define_insn \"*mov<mode>_31\"\n   [(set (match_operand:TD_TF 0 \"nonimmediate_operand\" \"=f,f,f,o\")\n         (match_operand:TD_TF 1 \"general_operand\"      \" G,f,o,f\"))]\n-  \"!TARGET_64BIT\"\n+  \"!TARGET_ZARCH\"\n   \"@\n    lzxr\\t%0\n    lxr\\t%0,%1\n@@ -1958,7 +1963,7 @@\n (define_split\n   [(set (match_operand:TD_TF 0 \"nonimmediate_operand\" \"\")\n         (match_operand:TD_TF 1 \"general_operand\"      \"\"))]\n-  \"TARGET_64BIT && reload_completed\n+  \"TARGET_ZARCH && reload_completed\n    && s390_split_ok_p (operands[0], operands[1], <MODE>mode, 0)\"\n   [(set (match_dup 2) (match_dup 4))\n    (set (match_dup 3) (match_dup 5))]\n@@ -1972,7 +1977,7 @@\n (define_split\n   [(set (match_operand:TD_TF 0 \"nonimmediate_operand\" \"\")\n         (match_operand:TD_TF 1 \"general_operand\"      \"\"))]\n-  \"TARGET_64BIT && reload_completed\n+  \"TARGET_ZARCH && reload_completed\n    && s390_split_ok_p (operands[0], operands[1], <MODE>mode, 1)\"\n   [(set (match_dup 2) (match_dup 4))\n    (set (match_dup 3) (match_dup 5))]\n@@ -1986,7 +1991,7 @@\n (define_split\n   [(set (match_operand:TD_TF 0 \"register_operand\" \"\")\n         (match_operand:TD_TF 1 \"memory_operand\"   \"\"))]\n-  \"TARGET_64BIT && reload_completed\n+  \"TARGET_ZARCH && reload_completed\n    && !FP_REG_P (operands[0])\n    && !s_operand (operands[1], VOIDmode)\"\n   [(set (match_dup 0) (match_dup 1))]\n@@ -2045,7 +2050,7 @@\n \t\t\t       \"=f,f,f,d,f,f,R,T,d, d,RT\")\n         (match_operand:DD_DF 1 \"general_operand\"\n \t\t\t       \" G,f,d,f,R,T,f,f,d,RT, d\"))]\n-  \"TARGET_64BIT && TARGET_DFP\"\n+  \"TARGET_DFP\"\n   \"@\n    lzdr\\t%0\n    ldr\\t%0,%1\n@@ -2077,7 +2082,7 @@\n (define_insn \"*mov<mode>_64\"\n   [(set (match_operand:DD_DF 0 \"nonimmediate_operand\" \"=f,f,f,f,R,T,d, d,RT\")\n         (match_operand:DD_DF 1 \"general_operand\"       \"G,f,R,T,f,f,d,RT, d\"))]\n-  \"TARGET_64BIT\"\n+  \"TARGET_ZARCH\"\n   \"@\n    lzdr\\t%0\n    ldr\\t%0,%1\n@@ -2106,7 +2111,7 @@\n                                \"=f,f,f,f,R,T,d,d,Q,S,   d,o\")\n         (match_operand:DD_DF 1 \"general_operand\"\n                                \" G,f,R,T,f,f,Q,S,d,d,dPRT,d\"))]\n-  \"!TARGET_64BIT\"\n+  \"!TARGET_ZARCH\"\n   \"@\n    lzdr\\t%0\n    ldr\\t%0,%1\n@@ -2127,7 +2132,7 @@\n (define_split\n   [(set (match_operand:DD_DF 0 \"nonimmediate_operand\" \"\")\n         (match_operand:DD_DF 1 \"general_operand\" \"\"))]\n-  \"!TARGET_64BIT && reload_completed\n+  \"!TARGET_ZARCH && reload_completed\n    && s390_split_ok_p (operands[0], operands[1], <MODE>mode, 0)\"\n   [(set (match_dup 2) (match_dup 4))\n    (set (match_dup 3) (match_dup 5))]\n@@ -2141,7 +2146,7 @@\n (define_split\n   [(set (match_operand:DD_DF 0 \"nonimmediate_operand\" \"\")\n         (match_operand:DD_DF 1 \"general_operand\" \"\"))]\n-  \"!TARGET_64BIT && reload_completed\n+  \"!TARGET_ZARCH && reload_completed\n    && s390_split_ok_p (operands[0], operands[1], <MODE>mode, 1)\"\n   [(set (match_dup 2) (match_dup 4))\n    (set (match_dup 3) (match_dup 5))]\n@@ -2155,7 +2160,7 @@\n (define_split\n   [(set (match_operand:DD_DF 0 \"register_operand\" \"\")\n         (match_operand:DD_DF 1 \"memory_operand\" \"\"))]\n-  \"!TARGET_64BIT && reload_completed\n+  \"!TARGET_ZARCH && reload_completed\n    && !FP_REG_P (operands[0])\n    && !s_operand (operands[1], VOIDmode)\"\n   [(set (match_dup 0) (match_dup 1))]\n@@ -2304,7 +2309,7 @@\n   count = INTVAL (operands[2]);\n   regno = REGNO (operands[0]);\n   mode = GET_MODE (operands[0]);\n-  if (mode != SImode && mode != word_mode)\n+  if (mode != SImode && (!TARGET_ZARCH || mode != DImode))\n     FAIL;\n \n   operands[3] = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (count));\n@@ -2342,7 +2347,7 @@\n   [(match_parallel 0 \"load_multiple_operation\"\n \t\t   [(set (match_operand:DI 1 \"register_operand\" \"=r\")\n \t\t\t (match_operand:DI 2 \"s_operand\" \"QS\"))])]\n-  \"reload_completed && word_mode == DImode\"\n+  \"reload_completed && TARGET_ZARCH\"\n {\n   int words = XVECLEN (operands[0], 0);\n   operands[0] = gen_rtx_REG (DImode, REGNO (operands[1]) + words - 1);\n@@ -2393,7 +2398,7 @@\n   count = INTVAL (operands[2]);\n   regno = REGNO (operands[1]);\n   mode = GET_MODE (operands[1]);\n-  if (mode != SImode && mode != word_mode)\n+  if (mode != SImode && (!TARGET_ZARCH || mode != DImode))\n     FAIL;\n \n   operands[3] = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (count));\n@@ -2433,7 +2438,7 @@\n   [(match_parallel 0 \"store_multiple_operation\"\n \t\t   [(set (match_operand:DI 1 \"s_operand\" \"=QS\")\n \t\t\t (match_operand:DI 2 \"register_operand\" \"r\"))])]\n-  \"reload_completed && word_mode == DImode\"\n+  \"reload_completed && TARGET_ZARCH\"\n {\n   int words = XVECLEN (operands[0], 0);\n   operands[0] = gen_rtx_REG (DImode, REGNO (operands[2]) + words - 1);\n@@ -2715,11 +2720,12 @@\n      (clobber (reg:CC CC_REGNUM))])]\n   \"\"\n {\n-  enum machine_mode dword_mode = word_mode == DImode ? TImode : DImode;\n-  rtx reg0 = gen_reg_rtx (dword_mode);\n-  rtx reg1 = gen_reg_rtx (dword_mode);\n-  rtx addr0 = gen_lowpart (Pmode, gen_highpart (word_mode, reg0));\n-  rtx addr1 = gen_lowpart (Pmode, gen_highpart (word_mode, reg1));\n+  enum machine_mode sreg_mode = TARGET_ZARCH ? DImode : SImode;\n+  enum machine_mode dreg_mode = TARGET_ZARCH ? TImode : DImode;\n+  rtx reg0 = gen_reg_rtx (dreg_mode);\n+  rtx reg1 = gen_reg_rtx (dreg_mode);\n+  rtx addr0 = gen_lowpart (Pmode, gen_highpart (sreg_mode, reg0));\n+  rtx addr1 = gen_lowpart (Pmode, gen_highpart (sreg_mode, reg1));\n   rtx len0 = gen_lowpart (Pmode, reg0);\n   rtx len1 = gen_lowpart (Pmode, reg1);\n \n@@ -2745,7 +2751,20 @@\n    (use (match_dup 2))\n    (use (match_dup 3))\n    (clobber (reg:CC CC_REGNUM))]\n-  \"\"\n+  \"TARGET_64BIT || !TARGET_ZARCH\"\n+  \"mvcle\\t%0,%1,0\\;jo\\t.-4\"\n+  [(set_attr \"length\" \"8\")\n+   (set_attr \"type\" \"vs\")])\n+\n+(define_insn \"*movmem_long_31z\"\n+  [(clobber (match_operand:TI 0 \"register_operand\" \"=d\"))\n+   (clobber (match_operand:TI 1 \"register_operand\" \"=d\"))\n+   (set (mem:BLK (subreg:SI (match_operand:TI 2 \"register_operand\" \"0\") 4))\n+        (mem:BLK (subreg:SI (match_operand:TI 3 \"register_operand\" \"1\") 4)))\n+   (use (match_dup 2))\n+   (use (match_dup 3))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"!TARGET_64BIT && TARGET_ZARCH\"\n   \"mvcle\\t%0,%1,0\\;jo\\t.-4\"\n   [(set_attr \"length\" \"8\")\n    (set_attr \"type\" \"vs\")])\n@@ -2917,10 +2936,11 @@\n      (clobber (reg:CC CC_REGNUM))])]\n   \"\"\n {\n-  enum machine_mode dword_mode = word_mode == DImode ? TImode : DImode;\n-  rtx reg0 = gen_reg_rtx (dword_mode);\n-  rtx reg1 = gen_reg_rtx (dword_mode);\n-  rtx addr0 = gen_lowpart (Pmode, gen_highpart (word_mode, reg0));\n+  enum machine_mode sreg_mode = TARGET_ZARCH ? DImode : SImode;\n+  enum machine_mode dreg_mode = TARGET_ZARCH ? TImode : DImode;\n+  rtx reg0 = gen_reg_rtx (dreg_mode);\n+  rtx reg1 = gen_reg_rtx (dreg_mode);\n+  rtx addr0 = gen_lowpart (Pmode, gen_highpart (sreg_mode, reg0));\n   rtx len0 = gen_lowpart (Pmode, reg0);\n \n   emit_clobber (reg0);\n@@ -2941,7 +2961,7 @@\n    (use (match_dup 3))\n    (use (match_operand:<DBL> 1 \"register_operand\" \"d\"))\n    (clobber (reg:CC CC_REGNUM))]\n-  \"\"\n+  \"TARGET_64BIT || !TARGET_ZARCH\"\n   \"mvcle\\t%0,%1,%Y2\\;jo\\t.-4\"\n   [(set_attr \"length\" \"8\")\n    (set_attr \"type\" \"vs\")])\n@@ -2954,10 +2974,24 @@\n    (use (match_dup 3))\n    (use (match_operand:<DBL> 1 \"register_operand\" \"d\"))\n    (clobber (reg:CC CC_REGNUM))]\n-  \"(INTVAL (operands[4]) & 255) == 255\"\n+  \"(TARGET_64BIT || !TARGET_ZARCH) &&\n+   (INTVAL (operands[4]) & 255) == 255\"\n+  \"mvcle\\t%0,%1,%Y2\\;jo\\t.-4\"\n+  [(set_attr \"length\" \"8\")\n+   (set_attr \"type\" \"vs\")])\n+\n+(define_insn \"*setmem_long_31z\"\n+  [(clobber (match_operand:TI 0 \"register_operand\" \"=d\"))\n+   (set (mem:BLK (subreg:SI (match_operand:TI 3 \"register_operand\" \"0\") 4))\n+        (match_operand 2 \"shift_count_or_setmem_operand\" \"Y\"))\n+   (use (match_dup 3))\n+   (use (match_operand:TI 1 \"register_operand\" \"d\"))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"!TARGET_64BIT && TARGET_ZARCH\"\n   \"mvcle\\t%0,%1,%Y2\\;jo\\t.-4\"\n   [(set_attr \"length\" \"8\")\n    (set_attr \"type\" \"vs\")])\n+\n ;\n ; cmpmemM instruction pattern(s).\n ;\n@@ -3071,11 +3105,12 @@\n      (use (match_dup 3))])]\n   \"\"\n {\n-  enum machine_mode dword_mode = word_mode == DImode ? TImode : DImode;\n-  rtx reg0 = gen_reg_rtx (dword_mode);\n-  rtx reg1 = gen_reg_rtx (dword_mode);\n-  rtx addr0 = gen_lowpart (Pmode, gen_highpart (word_mode, reg0));\n-  rtx addr1 = gen_lowpart (Pmode, gen_highpart (word_mode, reg1));\n+  enum machine_mode sreg_mode = TARGET_ZARCH ? DImode : SImode;\n+  enum machine_mode dreg_mode = TARGET_ZARCH ? TImode : DImode;\n+  rtx reg0 = gen_reg_rtx (dreg_mode);\n+  rtx reg1 = gen_reg_rtx (dreg_mode);\n+  rtx addr0 = gen_lowpart (Pmode, gen_highpart (sreg_mode, reg0));\n+  rtx addr1 = gen_lowpart (Pmode, gen_highpart (sreg_mode, reg1));\n   rtx len0 = gen_lowpart (Pmode, reg0);\n   rtx len1 = gen_lowpart (Pmode, reg1);\n \n@@ -3101,11 +3136,25 @@\n                      (mem:BLK (subreg:P (match_operand:<DBL> 3 \"register_operand\" \"1\") 0))))\n    (use (match_dup 2))\n    (use (match_dup 3))]\n-  \"\"\n+  \"TARGET_64BIT || !TARGET_ZARCH\"\n   \"clcle\\t%0,%1,0\\;jo\\t.-4\"\n   [(set_attr \"length\" \"8\")\n    (set_attr \"type\" \"vs\")])\n \n+(define_insn \"*cmpmem_long_31z\"\n+  [(clobber (match_operand:TI 0 \"register_operand\" \"=d\"))\n+   (clobber (match_operand:TI 1 \"register_operand\" \"=d\"))\n+   (set (reg:CCU CC_REGNUM)\n+        (compare:CCU (mem:BLK (subreg:SI (match_operand:TI 2 \"register_operand\" \"0\") 4))\n+                     (mem:BLK (subreg:SI (match_operand:TI 3 \"register_operand\" \"1\") 4))))\n+   (use (match_dup 2))\n+   (use (match_dup 3))]\n+  \"!TARGET_64BIT && TARGET_ZARCH\"\n+  \"clcle\\t%0,%1,0\\;jo\\t.-4\"\n+  [(set_attr \"op_type\" \"NN\")\n+   (set_attr \"type\"    \"vs\")\n+   (set_attr \"length\"  \"8\")])\n+\n ; Convert CCUmode condition code to integer.\n ; Result is zero if EQ, positive if LTU, negative if GTU.\n \n@@ -3147,7 +3196,7 @@\n         (sign_extend:DI (unspec:SI [(match_operand:CCU 1 \"register_operand\" \"0\")]\n                                    UNSPEC_CCU_TO_INT)))\n    (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_64BIT\"\n+  \"TARGET_ZARCH\"\n   \"#\"\n   \"&& reload_completed\"\n   [(set (match_dup 0) (ashift:DI (match_dup 0) (const_int 34)))\n@@ -3164,7 +3213,7 @@\n                  (const_int 0)))\n    (set (match_operand:DI 0 \"register_operand\" \"=d\")\n         (sign_extend:DI (unspec:SI [(match_dup 1)] UNSPEC_CCU_TO_INT)))]\n-  \"s390_match_ccmode (insn, CCSmode) && TARGET_64BIT\"\n+  \"s390_match_ccmode (insn, CCSmode) && TARGET_ZARCH\"\n   \"#\"\n   \"&& reload_completed\"\n   [(set (match_dup 0) (ashift:DI (match_dup 0) (const_int 34)))\n@@ -3199,7 +3248,7 @@\n \t(unspec:DI [(match_operand:BLK 1 \"s_operand\" \"QS\")\n \t\t    (match_operand 2 \"const_int_operand\" \"n\")] UNSPEC_ICM))\n    (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_64BIT\"\n+  \"TARGET_ZARCH\"\n   \"icmh\\t%0,%2,%S1\"\n   [(set_attr \"op_type\" \"RSY\")\n    (set_attr \"z10prop\" \"z10_super\")])\n@@ -3209,7 +3258,7 @@\n \t(unspec:DI [(match_operand:BLK 1 \"s_operand\" \"Q,S\")\n \t\t    (match_operand 2 \"const_int_operand\" \"n,n\")] UNSPEC_ICM))\n    (clobber (reg:CC CC_REGNUM))]\n-  \"!TARGET_64BIT\"\n+  \"!TARGET_ZARCH\"\n   \"@\n    icm\\t%0,%2,%S1\n    icmy\\t%0,%2,%S1\"\n@@ -3365,10 +3414,10 @@\n   [(set_attr \"op_type\" \"RIE\")])\n \n (define_insn \"*insv<mode>_mem_reg\"\n-  [(set (zero_extract:P (match_operand:QI 0 \"memory_operand\" \"+Q,S\")\n+  [(set (zero_extract:W (match_operand:QI 0 \"memory_operand\" \"+Q,S\")\n \t\t\t(match_operand 1 \"const_int_operand\" \"n,n\")\n \t\t\t(const_int 0))\n-\t(match_operand:P 2 \"register_operand\" \"d,d\"))]\n+\t(match_operand:W 2 \"register_operand\" \"d,d\"))]\n   \"INTVAL (operands[1]) > 0\n    && INTVAL (operands[1]) <= GET_MODE_BITSIZE (SImode)\n    && INTVAL (operands[1]) % BITS_PER_UNIT == 0\"\n@@ -3388,7 +3437,7 @@\n \t\t\t (const_int 0))\n \t(lshiftrt:DI (match_operand:DI 2 \"register_operand\" \"d\")\n \t\t     (const_int 32)))]\n-  \"TARGET_64BIT\n+  \"TARGET_ZARCH\n    && INTVAL (operands[1]) > 0\n    && INTVAL (operands[1]) <= GET_MODE_BITSIZE (SImode)\n    && INTVAL (operands[1]) % BITS_PER_UNIT == 0\"\n@@ -3401,11 +3450,11 @@\n [(set_attr \"op_type\" \"RSY\")\n  (set_attr \"z10prop\" \"z10_super\")])\n \n-(define_insn \"*insv<mode>_reg_imm\"\n-  [(set (zero_extract:P (match_operand:P 0 \"register_operand\" \"+d\")\n-\t\t\t(const_int 16)\n-\t\t\t(match_operand 1 \"const_int_operand\" \"n\"))\n-\t(match_operand:P 2 \"const_int_operand\" \"n\"))]\n+(define_insn \"*insvdi_reg_imm\"\n+  [(set (zero_extract:DI (match_operand:DI 0 \"register_operand\" \"+d\")\n+\t\t\t (const_int 16)\n+\t\t\t (match_operand 1 \"const_int_operand\" \"n\"))\n+\t(match_operand:DI 2 \"const_int_operand\" \"n\"))]\n   \"TARGET_ZARCH\n    && INTVAL (operands[1]) >= 0\n    && INTVAL (operands[1]) < BITS_PER_WORD\n@@ -3455,7 +3504,7 @@\n         (sign_extend:DI (match_operand:SI 1 \"nonimmediate_operand\" \"\")))]\n   \"\"\n {\n-  if (!TARGET_64BIT)\n+  if (!TARGET_ZARCH)\n     {\n       emit_clobber (operands[0]);\n       emit_move_insn (gen_highpart (SImode, operands[0]), operands[1]);\n@@ -3468,7 +3517,7 @@\n (define_insn \"*extendsidi2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d,d,d\")\n         (sign_extend:DI (match_operand:SI 1 \"nonimmediate_operand\" \"d,RT,b\")))]\n-  \"TARGET_64BIT\"\n+  \"TARGET_ZARCH\"\n   \"@\n    lgfr\\t%0,%1\n    lgf\\t%0,%1\n@@ -3487,7 +3536,7 @@\n         (sign_extend:DSI (match_operand:HQI 1 \"nonimmediate_operand\" \"\")))]\n   \"\"\n {\n-  if (<DSI:MODE>mode == DImode && !TARGET_64BIT)\n+  if (<DSI:MODE>mode == DImode && !TARGET_ZARCH)\n     {\n       rtx tmp = gen_reg_rtx (SImode);\n       emit_insn (gen_extend<HQI:mode>si2 (tmp, operands[1]));\n@@ -3513,7 +3562,7 @@\n (define_insn \"*extendhidi2_extimm\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d,d,d\")\n         (sign_extend:DI (match_operand:HI 1 \"general_operand\" \"d,RT,b\")))]\n-  \"TARGET_64BIT && TARGET_EXTIMM\"\n+  \"TARGET_ZARCH && TARGET_EXTIMM\"\n   \"@\n    lghr\\t%0,%1\n    lgh\\t%0,%1\n@@ -3526,7 +3575,7 @@\n (define_insn \"*extendhidi2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n         (sign_extend:DI (match_operand:HI 1 \"memory_operand\" \"RT\")))]\n-  \"TARGET_64BIT\"\n+  \"TARGET_ZARCH\"\n   \"lgh\\t%0,%1\"\n   [(set_attr \"op_type\" \"RXY\")\n    (set_attr \"z10prop\" \"z10_super_E1\")])\n@@ -3612,7 +3661,7 @@\n         (zero_extend:DI (match_operand:SI 1 \"nonimmediate_operand\" \"\")))]\n   \"\"\n {\n-  if (!TARGET_64BIT)\n+  if (!TARGET_ZARCH)\n     {\n       emit_clobber (operands[0]);\n       emit_move_insn (gen_lowpart (SImode, operands[0]), operands[1]);\n@@ -3624,7 +3673,7 @@\n (define_insn \"*zero_extendsidi2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d,d,d\")\n         (zero_extend:DI (match_operand:SI 1 \"nonimmediate_operand\" \"d,RT,b\")))]\n-  \"TARGET_64BIT\"\n+  \"TARGET_ZARCH\"\n   \"@\n    llgfr\\t%0,%1\n    llgf\\t%0,%1\n@@ -3642,7 +3691,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n         (and:DI (subreg:DI (match_operand:SI 1 \"memory_operand\" \"RT\") 0)\n \t\t(const_int 2147483647)))]\n-  \"TARGET_64BIT\"\n+  \"TARGET_ZARCH\"\n   \"llgt\\t%0,%1\"\n   [(set_attr \"op_type\"  \"RXE\")\n    (set_attr \"z10prop\" \"z10_super_E1\")])\n@@ -3652,7 +3701,7 @@\n         (and:DI (subreg:DI (match_operand:SI 1 \"memory_operand\" \"RT\") 0)\n \t\t(const_int 2147483647)))\n    (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_64BIT\"\n+  \"TARGET_ZARCH\"\n   \"#\"\n   \"&& reload_completed\"\n   [(set (match_dup 0)\n@@ -3675,21 +3724,21 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=d,d\")\n         (and:DI (match_operand:DI 1 \"nonimmediate_operand\" \"d,o\")\n                 (const_int 2147483647)))]\n-  \"TARGET_64BIT\"\n+  \"TARGET_ZARCH\"\n   \"@\n    llgtr\\t%0,%1\n    llgt\\t%0,%N1\"\n   [(set_attr \"op_type\"  \"RRE,RXE\")\n    (set_attr \"z10prop\" \"z10_super_E1,z10_super_E1\")])\n \n (define_split\n-  [(set (match_operand:GPR 0 \"register_operand\" \"\")\n-        (and:GPR (match_operand:GPR 1 \"nonimmediate_operand\" \"\")\n+  [(set (match_operand:DSI 0 \"register_operand\" \"\")\n+        (and:DSI (match_operand:DSI 1 \"nonimmediate_operand\" \"\")\n                  (const_int 2147483647)))\n    (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_ZARCH && reload_completed\"\n   [(set (match_dup 0)\n-        (and:GPR (match_dup 1)\n+        (and:DSI (match_dup 1)\n                  (const_int 2147483647)))]\n   \"\")\n \n@@ -3702,7 +3751,7 @@\n         (zero_extend:DI (match_operand:HQI 1 \"nonimmediate_operand\" \"\")))]\n   \"\"\n {\n-  if (!TARGET_64BIT)\n+  if (!TARGET_ZARCH)\n     {\n       rtx tmp = gen_reg_rtx (SImode);\n       emit_insn (gen_zero_extend<mode>si2 (tmp, operands[1]));\n@@ -3954,7 +4003,7 @@\n (define_expand \"fix_trunc<mode>di2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n         (fix:DI (match_operand:DFP 1 \"nonimmediate_operand\" \"\")))]\n-  \"TARGET_64BIT && TARGET_HARD_DFP\"\n+  \"TARGET_ZARCH && TARGET_HARD_DFP\"\n {\n   operands[1] = force_reg (<MODE>mode, operands[1]);\n   emit_insn (gen_fix_trunc<mode>di2_dfp (operands[0], operands[1],\n@@ -3968,7 +4017,7 @@\n         (fix:DI (match_operand:DFP 1 \"register_operand\" \"f\")))\n    (unspec:DI [(match_operand:DI 2 \"immediate_operand\" \"K\")] UNSPEC_ROUND)\n    (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_64BIT && TARGET_HARD_DFP\"\n+  \"TARGET_ZARCH && TARGET_HARD_DFP\"\n   \"cg<DFP:xde>tr\\t%0,%h2,%1\"\n   [(set_attr \"op_type\" \"RRF\")\n    (set_attr \"type\"    \"ftoidfp\")])\n@@ -3995,7 +4044,7 @@\n (define_insn \"floatdi<mode>2\"\n   [(set (match_operand:FP 0 \"register_operand\" \"=f\")\n         (float:FP (match_operand:DI 1 \"register_operand\" \"d\")))]\n-  \"TARGET_64BIT && TARGET_HARD_FLOAT\"\n+  \"TARGET_ZARCH && TARGET_HARD_FLOAT\"\n   \"c<xde>g<bt>r\\t%0,%1\"\n   [(set_attr \"op_type\" \"RRE\")\n    (set_attr \"type\"    \"itof<mode>\" )])\n@@ -4237,7 +4286,7 @@\n         (plus:TI (match_operand:TI 1 \"nonimmediate_operand\" \"%0\")\n                  (match_operand:TI 2 \"general_operand\" \"do\") ) )\n    (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_64BIT\"\n+  \"TARGET_ZARCH\"\n   \"#\"\n   \"&& reload_completed\"\n   [(parallel\n@@ -4275,7 +4324,7 @@\n         (plus:DI (sign_extend:DI (match_operand:SI 2 \"general_operand\" \"d,RT\"))\n                  (match_operand:DI 1 \"register_operand\" \"0,0\")))\n    (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_64BIT\"\n+  \"TARGET_ZARCH\"\n   \"@\n    agfr\\t%0,%2\n    agf\\t%0,%2\"\n@@ -4288,7 +4337,7 @@\n                  (const_int 0)))\n    (set (match_operand:DI 0 \"register_operand\" \"=d,d\")\n         (plus:DI (zero_extend:DI (match_dup 2)) (match_dup 1)))]\n-  \"s390_match_ccmode (insn, CCLmode) && TARGET_64BIT\"\n+  \"s390_match_ccmode (insn, CCLmode) && TARGET_ZARCH\"\n   \"@\n    algfr\\t%0,%2\n    algf\\t%0,%2\"\n@@ -4301,7 +4350,7 @@\n                           (match_operand:DI 1 \"register_operand\" \"0,0\"))\n                  (const_int 0)))\n    (clobber (match_scratch:DI 0 \"=d,d\"))]\n-  \"s390_match_ccmode (insn, CCLmode) && TARGET_64BIT\"\n+  \"s390_match_ccmode (insn, CCLmode) && TARGET_ZARCH\"\n   \"@\n    algfr\\t%0,%2\n    algf\\t%0,%2\"\n@@ -4313,7 +4362,7 @@\n         (plus:DI (zero_extend:DI (match_operand:SI 2 \"general_operand\" \"d,RT\"))\n                  (match_operand:DI 1 \"register_operand\" \"0,0\")))\n    (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_64BIT\"\n+  \"TARGET_ZARCH\"\n   \"@\n    algfr\\t%0,%2\n    algf\\t%0,%2\"\n@@ -4325,7 +4374,7 @@\n         (plus:DI (match_operand:DI 1 \"nonimmediate_operand\" \"%0\")\n                  (match_operand:DI 2 \"general_operand\" \"do\") ) )\n    (clobber (reg:CC CC_REGNUM))]\n-  \"!TARGET_64BIT && TARGET_CPU_ZARCH\"\n+  \"!TARGET_ZARCH && TARGET_CPU_ZARCH\"\n   \"#\"\n   \"&& reload_completed\"\n   [(parallel\n@@ -4645,7 +4694,7 @@\n         (minus:TI (match_operand:TI 1 \"register_operand\" \"0\")\n                   (match_operand:TI 2 \"general_operand\" \"do\") ) )\n    (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_64BIT\"\n+  \"TARGET_ZARCH\"\n   \"#\"\n   \"&& reload_completed\"\n   [(parallel\n@@ -4682,7 +4731,7 @@\n         (minus:DI (match_operand:DI 1 \"register_operand\" \"0,0\")\n                   (sign_extend:DI (match_operand:SI 2 \"general_operand\" \"d,RT\"))))\n    (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_64BIT\"\n+  \"TARGET_ZARCH\"\n   \"@\n    sgfr\\t%0,%2\n    sgf\\t%0,%2\"\n@@ -4696,7 +4745,7 @@\n                  (const_int 0)))\n    (set (match_operand:DI 0 \"register_operand\" \"=d,d\")\n         (minus:DI (match_dup 1) (zero_extend:DI (match_dup 2))))]\n-  \"s390_match_ccmode (insn, CCLmode) && TARGET_64BIT\"\n+  \"s390_match_ccmode (insn, CCLmode) && TARGET_ZARCH\"\n   \"@\n    slgfr\\t%0,%2\n    slgf\\t%0,%2\"\n@@ -4709,7 +4758,7 @@\n                            (zero_extend:DI (match_operand:SI 2 \"general_operand\" \"d,RT\")))\n                  (const_int 0)))\n    (clobber (match_scratch:DI 0 \"=d,d\"))]\n-  \"s390_match_ccmode (insn, CCLmode) && TARGET_64BIT\"\n+  \"s390_match_ccmode (insn, CCLmode) && TARGET_ZARCH\"\n   \"@\n    slgfr\\t%0,%2\n    slgf\\t%0,%2\"\n@@ -4721,7 +4770,7 @@\n         (minus:DI (match_operand:DI 1 \"register_operand\" \"0,0\")\n                   (zero_extend:DI (match_operand:SI 2 \"general_operand\" \"d,RT\"))))\n    (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_64BIT\"\n+  \"TARGET_ZARCH\"\n   \"@\n    slgfr\\t%0,%2\n    slgf\\t%0,%2\"\n@@ -4733,7 +4782,7 @@\n         (minus:DI (match_operand:DI 1 \"register_operand\" \"0\")\n                   (match_operand:DI 2 \"general_operand\" \"do\") ) )\n    (clobber (reg:CC CC_REGNUM))]\n-  \"!TARGET_64BIT && TARGET_CPU_ZARCH\"\n+  \"!TARGET_ZARCH && TARGET_CPU_ZARCH\"\n   \"#\"\n   \"&& reload_completed\"\n   [(parallel\n@@ -5197,7 +5246,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=d,d\")\n         (mult:DI (sign_extend:DI (match_operand:SI 2 \"general_operand\" \"d,RT\"))\n                  (match_operand:DI 1 \"register_operand\" \"0,0\")))]\n-  \"TARGET_64BIT\"\n+  \"TARGET_ZARCH\"\n   \"@\n    msgfr\\t%0,%2\n    msgf\\t%0,%2\"\n@@ -5208,7 +5257,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=d,d,d,d\")\n         (mult:DI (match_operand:DI 1 \"nonimmediate_operand\" \"%0,0,0,0\")\n                  (match_operand:DI 2 \"general_operand\" \"d,K,RT,Os\")))]\n-  \"TARGET_64BIT\"\n+  \"TARGET_ZARCH\"\n   \"@\n    msgr\\t%0,%2\n    mghi\\t%0,%h2\n@@ -5259,7 +5308,7 @@\n \t           (match_operand:SI 1 \"register_operand\" \"%0,0,0\"))\n                  (sign_extend:DI\n \t           (match_operand:SI 2 \"nonimmediate_operand\" \"d,R,T\"))))]\n-  \"!TARGET_64BIT\"\n+  \"!TARGET_ZARCH\"\n   \"@\n    mr\\t%0,%2\n    m\\t%0,%2\n@@ -5278,7 +5327,7 @@\n \t           (match_operand:SI 1 \"register_operand\" \"%0,0\"))\n                  (zero_extend:DI\n \t           (match_operand:SI 2 \"nonimmediate_operand\" \"d,RT\"))))]\n-  \"!TARGET_64BIT && TARGET_CPU_ZARCH\"\n+  \"!TARGET_ZARCH && TARGET_CPU_ZARCH\"\n   \"@\n    mlr\\t%0,%2\n    ml\\t%0,%2\"\n@@ -5342,7 +5391,7 @@\n \t      (set (match_operand:DI 3 \"general_operand\" \"\")\n \t\t   (mod:DI (match_dup 1) (match_dup 2)))])\n    (clobber (match_dup 4))]\n-  \"TARGET_64BIT\"\n+  \"TARGET_ZARCH\"\n {\n   rtx insn, div_equal, mod_equal;\n \n@@ -5370,7 +5419,7 @@\n                       (match_operand:DI 2 \"general_operand\" \"d,RT\")))\n             (const_int 64))\n           (zero_extend:TI (div:DI (match_dup 1) (match_dup 2)))))]\n-  \"TARGET_64BIT\"\n+  \"TARGET_ZARCH\"\n   \"@\n    dsgr\\t%0,%2\n    dsg\\t%0,%2\"\n@@ -5388,7 +5437,7 @@\n             (const_int 64))\n           (zero_extend:TI\n             (div:DI (match_dup 1) (sign_extend:DI (match_dup 2))))))]\n-  \"TARGET_64BIT\"\n+  \"TARGET_ZARCH\"\n   \"@\n    dsgfr\\t%0,%2\n    dsgf\\t%0,%2\"\n@@ -5406,7 +5455,7 @@\n \t      (set (match_operand:DI 3 \"general_operand\" \"\")\n \t\t   (umod:DI (match_dup 1) (match_dup 2)))])\n    (clobber (match_dup 4))]\n-  \"TARGET_64BIT\"\n+  \"TARGET_ZARCH\"\n {\n   rtx insn, div_equal, mod_equal, equal;\n \n@@ -5448,7 +5497,7 @@\n           (zero_extend:TI\n             (truncate:DI\n               (udiv:TI (match_dup 1) (zero_extend:TI (match_dup 2)))))))]\n-  \"TARGET_64BIT\"\n+  \"TARGET_ZARCH\"\n   \"@\n    dlgr\\t%0,%2\n    dlg\\t%0,%2\"\n@@ -5466,7 +5515,7 @@\n \t      (set (match_operand:SI 3 \"general_operand\" \"\")\n \t\t   (mod:SI (match_dup 1) (match_dup 2)))])\n    (clobber (match_dup 4))]\n-  \"!TARGET_64BIT\"\n+  \"!TARGET_ZARCH\"\n {\n   rtx insn, div_equal, mod_equal, equal;\n \n@@ -5506,7 +5555,7 @@\n           (zero_extend:DI\n             (truncate:SI\n               (div:DI (match_dup 1) (sign_extend:DI (match_dup 2)))))))]\n-  \"!TARGET_64BIT\"\n+  \"!TARGET_ZARCH\"\n   \"@\n    dr\\t%0,%2\n    d\\t%0,%2\"\n@@ -5524,7 +5573,7 @@\n \t      (set (match_operand:SI 3 \"general_operand\" \"\")\n \t\t   (umod:SI (match_dup 1) (match_dup 2)))])\n    (clobber (match_dup 4))]\n-  \"!TARGET_64BIT && TARGET_CPU_ZARCH\"\n+  \"!TARGET_ZARCH && TARGET_CPU_ZARCH\"\n {\n   rtx insn, div_equal, mod_equal, equal;\n \n@@ -5566,7 +5615,7 @@\n           (zero_extend:DI\n             (truncate:SI\n               (udiv:DI (match_dup 1) (zero_extend:DI (match_dup 2)))))))]\n-  \"!TARGET_64BIT && TARGET_CPU_ZARCH\"\n+  \"!TARGET_ZARCH && TARGET_CPU_ZARCH\"\n   \"@\n    dlr\\t%0,%2\n    dl\\t%0,%2\"\n@@ -5578,7 +5627,7 @@\n         (udiv:SI (match_operand:SI 1 \"general_operand\" \"\")\n                  (match_operand:SI 2 \"general_operand\" \"\")))\n    (clobber (match_dup 3))]\n-  \"!TARGET_64BIT && !TARGET_CPU_ZARCH\"\n+  \"!TARGET_ZARCH && !TARGET_CPU_ZARCH\"\n {\n   rtx insn, udiv_equal, umod_equal, equal;\n \n@@ -5664,7 +5713,7 @@\n         (umod:SI (match_operand:SI 1 \"nonimmediate_operand\" \"\")\n                  (match_operand:SI 2 \"nonimmediate_operand\" \"\")))\n    (clobber (match_dup 3))]\n-  \"!TARGET_64BIT && !TARGET_CPU_ZARCH\"\n+  \"!TARGET_ZARCH && !TARGET_CPU_ZARCH\"\n {\n   rtx insn, udiv_equal, umod_equal, equal;\n \n@@ -5785,7 +5834,7 @@\n                  (const_int 0)))\n    (set (match_operand:DI 0 \"register_operand\" \"=d,d\")\n         (and:DI (match_dup 1) (match_dup 2)))]\n-  \"s390_match_ccmode(insn, CCTmode) && TARGET_64BIT\"\n+  \"s390_match_ccmode(insn, CCTmode) && TARGET_ZARCH\"\n   \"@\n    ngr\\t%0,%2\n    ng\\t%0,%2\"\n@@ -5798,7 +5847,7 @@\n                          (match_operand:DI 2 \"general_operand\" \"d,RT\"))\n                  (const_int 0)))\n    (clobber (match_scratch:DI 0 \"=d,d\"))]\n-  \"s390_match_ccmode(insn, CCTmode) && TARGET_64BIT\n+  \"s390_match_ccmode(insn, CCTmode) && TARGET_ZARCH\n    /* Do not steal TM patterns.  */\n    && s390_single_part (operands[2], DImode, HImode, 0) < 0\"\n   \"@\n@@ -5814,7 +5863,7 @@\n                 (match_operand:DI 2 \"general_operand\"\n                                     \"M,M,N0HDF,N1HDF,N2HDF,N3HDF,N0SDF,N1SDF,d,RT,NxQDF,Q\")))\n    (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_64BIT && s390_logical_operator_ok_p (operands)\"\n+  \"TARGET_ZARCH && s390_logical_operator_ok_p (operands)\"\n   \"@\n    #\n    #\n@@ -6104,7 +6153,7 @@\n                  (const_int 0)))\n    (set (match_operand:DI 0 \"register_operand\" \"=d,d\")\n         (ior:DI (match_dup 1) (match_dup 2)))]\n-  \"s390_match_ccmode(insn, CCTmode) && TARGET_64BIT\"\n+  \"s390_match_ccmode(insn, CCTmode) && TARGET_ZARCH\"\n   \"@\n    ogr\\t%0,%2\n    og\\t%0,%2\"\n@@ -6117,7 +6166,7 @@\n                          (match_operand:DI 2 \"general_operand\" \"d,RT\"))\n                  (const_int 0)))\n    (clobber (match_scratch:DI 0 \"=d,d\"))]\n-  \"s390_match_ccmode(insn, CCTmode) && TARGET_64BIT\"\n+  \"s390_match_ccmode(insn, CCTmode) && TARGET_ZARCH\"\n   \"@\n    ogr\\t%0,%2\n    og\\t%0,%2\"\n@@ -6130,7 +6179,7 @@\n                 (match_operand:DI 2 \"general_operand\"\n                                     \"N0HD0,N1HD0,N2HD0,N3HD0,N0SD0,N1SD0,d,RT,NxQD0,Q\")))\n    (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_64BIT && s390_logical_operator_ok_p (operands)\"\n+  \"TARGET_ZARCH && s390_logical_operator_ok_p (operands)\"\n   \"@\n    oihh\\t%0,%i2\n    oihl\\t%0,%i2\n@@ -6404,7 +6453,7 @@\n                  (const_int 0)))\n    (set (match_operand:DI 0 \"register_operand\" \"=d,d\")\n         (xor:DI (match_dup 1) (match_dup 2)))]\n-  \"s390_match_ccmode(insn, CCTmode) && TARGET_64BIT\"\n+  \"s390_match_ccmode(insn, CCTmode) && TARGET_ZARCH\"\n   \"@\n    xgr\\t%0,%2\n    xg\\t%0,%2\"\n@@ -6417,7 +6466,7 @@\n                          (match_operand:DI 2 \"general_operand\" \"d,RT\"))\n                  (const_int 0)))\n    (clobber (match_scratch:DI 0 \"=d,d\"))]\n-  \"s390_match_ccmode(insn, CCTmode) && TARGET_64BIT\"\n+  \"s390_match_ccmode(insn, CCTmode) && TARGET_ZARCH\"\n   \"@\n    xgr\\t%0,%2\n    xg\\t%0,%2\"\n@@ -6429,7 +6478,7 @@\n         (xor:DI (match_operand:DI 1 \"nonimmediate_operand\" \"%0,0,0,0,0,0\")\n                 (match_operand:DI 2 \"general_operand\" \"N0SD0,N1SD0,d,RT,NxQD0,Q\")))\n    (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_64BIT && s390_logical_operator_ok_p (operands)\"\n+  \"TARGET_ZARCH && s390_logical_operator_ok_p (operands)\"\n   \"@\n    xihf\\t%0,%k2\n    xilf\\t%0,%k2\n@@ -6676,7 +6725,7 @@\n                  (const_int 0)))\n    (set (match_operand:DI 0 \"register_operand\" \"=d\")\n         (neg:DI (sign_extend:DI (match_dup 1))))]\n-  \"TARGET_64BIT && s390_match_ccmode (insn, CCAmode)\"\n+  \"TARGET_ZARCH && s390_match_ccmode (insn, CCAmode)\"\n   \"lcgfr\\t%0,%1\"\n   [(set_attr \"op_type\"  \"RRE\")\n    (set_attr \"z10prop\" \"z10_c\")])\n@@ -6685,7 +6734,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n         (neg:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"d\"))))\n    (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_64BIT\"\n+  \"TARGET_ZARCH\"\n   \"lcgfr\\t%0,%1\"\n   [(set_attr \"op_type\"  \"RRE\")\n    (set_attr \"z10prop\" \"z10_c\")])\n@@ -6727,7 +6776,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n         (neg:DI (match_operand:DI 1 \"register_operand\" \"d\")))\n    (clobber (reg:CC CC_REGNUM))]\n-  \"!TARGET_64BIT\"\n+  \"!TARGET_ZARCH\"\n   \"#\"\n   \"&& reload_completed\"\n   [(parallel\n@@ -6822,7 +6871,7 @@\n                  (const_int 0)))\n    (set (match_operand:DI 0 \"register_operand\" \"=d\")\n         (abs:DI (sign_extend:DI (match_dup 1))))]\n-  \"TARGET_64BIT && s390_match_ccmode (insn, CCAmode)\"\n+  \"TARGET_ZARCH && s390_match_ccmode (insn, CCAmode)\"\n   \"lpgfr\\t%0,%1\"\n   [(set_attr \"op_type\"  \"RRE\")\n    (set_attr \"z10prop\" \"z10_c\")])\n@@ -6831,7 +6880,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n         (abs:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"d\"))))\n    (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_64BIT\"\n+  \"TARGET_ZARCH\"\n   \"lpgfr\\t%0,%1\"\n   [(set_attr \"op_type\"  \"RRE\")\n    (set_attr \"z10prop\" \"z10_c\")])\n@@ -6940,7 +6989,7 @@\n                  (const_int 0)))\n    (set (match_operand:DI 0 \"register_operand\" \"=d\")\n         (neg:DI (abs:DI (sign_extend:DI (match_dup 1)))))]\n-  \"TARGET_64BIT && s390_match_ccmode (insn, CCAmode)\"\n+  \"TARGET_ZARCH && s390_match_ccmode (insn, CCAmode)\"\n   \"lngfr\\t%0,%1\"\n   [(set_attr \"op_type\"  \"RRE\")\n    (set_attr \"z10prop\" \"z10_c\")])\n@@ -6950,7 +6999,7 @@\n \t(neg:DI (abs:DI (sign_extend:DI\n                           (match_operand:SI 1 \"register_operand\" \"d\")))))\n    (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_64BIT\"\n+  \"TARGET_ZARCH\"\n   \"lngfr\\t%0,%1\"\n   [(set_attr \"op_type\" \"RRE\")\n    (set_attr \"z10prop\" \"z10_c\")])\n@@ -7079,7 +7128,7 @@\n (define_expand \"clzdi2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n \t(clz:DI (match_operand:DI 1 \"register_operand\" \"d\")))]\n-  \"TARGET_EXTIMM && TARGET_64BIT\"\n+  \"TARGET_EXTIMM && TARGET_ZARCH\"\n {\n   rtx insn, clz_equal;\n   rtx wide_reg = gen_reg_rtx (TImode);\n@@ -7109,7 +7158,7 @@\n    (clobber (reg:CC CC_REGNUM))]\n   \"(unsigned HOST_WIDE_INT) INTVAL (operands[2])\n    == (unsigned HOST_WIDE_INT) 1 << 63\n-   && TARGET_EXTIMM && TARGET_64BIT\"\n+   && TARGET_EXTIMM && TARGET_ZARCH\"\n   \"flogr\\t%0,%1\"\n   [(set_attr \"op_type\"  \"RRE\")])\n \n@@ -7166,7 +7215,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n         (SHIFT:DI (match_operand:DI 1 \"register_operand\" \"0\")\n                   (match_operand:SI 2 \"shift_count_or_setmem_operand\" \"Y\")))]\n-  \"!TARGET_64BIT\"\n+  \"!TARGET_ZARCH\"\n   \"s<lr>dl\\t%0,%Y2\"\n   [(set_attr \"op_type\"  \"RS\")\n    (set_attr \"atype\"    \"reg\")])\n@@ -7188,7 +7237,7 @@\n         (SHIFT:DI (match_operand:DI 1 \"register_operand\" \"0\")\n                   (and:SI (match_operand:SI 2 \"shift_count_or_setmem_operand\" \"Y\")\n \t\t\t  (match_operand:SI 3 \"const_int_operand\"   \"n\"))))]\n-  \"!TARGET_64BIT && (INTVAL (operands[3]) & 63) == 63\"\n+  \"!TARGET_ZARCH && (INTVAL (operands[3]) & 63) == 63\"\n   \"s<lr>dl\\t%0,%Y2\"\n   [(set_attr \"op_type\"  \"RS\")\n    (set_attr \"atype\"    \"reg\")])\n@@ -7225,7 +7274,7 @@\n                  (const_int 0)))\n    (set (match_operand:DI 0 \"register_operand\" \"=d\")\n         (ashiftrt:DI (match_dup 1) (match_dup 2)))]\n-  \"!TARGET_64BIT && s390_match_ccmode(insn, CCSmode)\"\n+  \"!TARGET_ZARCH && s390_match_ccmode(insn, CCSmode)\"\n   \"srda\\t%0,%Y2\"\n   [(set_attr \"op_type\"  \"RS\")\n    (set_attr \"atype\"    \"reg\")])\n@@ -7236,7 +7285,7 @@\n                               (match_operand:SI 2 \"shift_count_or_setmem_operand\" \"Y\"))\n                  (const_int 0)))\n    (clobber (match_scratch:DI 0 \"=d\"))]\n-  \"!TARGET_64BIT && s390_match_ccmode(insn, CCSmode)\"\n+  \"!TARGET_ZARCH && s390_match_ccmode(insn, CCSmode)\"\n   \"srda\\t%0,%Y2\"\n   [(set_attr \"op_type\"  \"RS\")\n    (set_attr \"atype\"    \"reg\")])\n@@ -7246,7 +7295,7 @@\n         (ashiftrt:DI (match_operand:DI 1 \"register_operand\" \"0\")\n                      (match_operand:SI 2 \"shift_count_or_setmem_operand\" \"Y\")))\n    (clobber (reg:CC CC_REGNUM))]\n-  \"!TARGET_64BIT\"\n+  \"!TARGET_ZARCH\"\n   \"srda\\t%0,%Y2\"\n   [(set_attr \"op_type\"  \"RS\")\n    (set_attr \"atype\"    \"reg\")])\n@@ -7301,7 +7350,7 @@\n \t\t (const_int 0)))\n    (set (match_operand:DI 0 \"register_operand\" \"=d\")\n         (ashiftrt:DI (match_dup 1) (and:SI (match_dup 2) (match_dup 3))))]\n-  \"!TARGET_64BIT && s390_match_ccmode(insn, CCSmode)\n+  \"!TARGET_ZARCH && s390_match_ccmode(insn, CCSmode)\n    && (INTVAL (operands[3]) & 63) == 63\"\n   \"srda\\t%0,%Y2\"\n   [(set_attr \"op_type\"  \"RS\")\n@@ -7314,7 +7363,7 @@\n \t\t\t\t      (match_operand:SI 3 \"const_int_operand\"   \"n\")))\n                  (const_int 0)))\n    (clobber (match_scratch:DI 0 \"=d\"))]\n-  \"!TARGET_64BIT && s390_match_ccmode(insn, CCSmode)\n+  \"!TARGET_ZARCH && s390_match_ccmode(insn, CCSmode)\n    && (INTVAL (operands[3]) & 63) == 63\"\n   \"srda\\t%0,%Y2\"\n   [(set_attr \"op_type\"  \"RS\")\n@@ -7326,7 +7375,7 @@\n                      (and:SI (match_operand:SI 2 \"shift_count_or_setmem_operand\" \"Y\")\n \t\t\t     (match_operand:SI 3 \"const_int_operand\"   \"n\"))))\n    (clobber (reg:CC CC_REGNUM))]\n-  \"!TARGET_64BIT && (INTVAL (operands[3]) & 63) == 63\"\n+  \"!TARGET_ZARCH && (INTVAL (operands[3]) & 63) == 63\"\n   \"srda\\t%0,%Y2\"\n   [(set_attr \"op_type\"  \"RS\")\n    (set_attr \"atype\"    \"reg\")])\n@@ -7680,7 +7729,7 @@\n \t\t (subreg:DI (match_dup 2) 0)))\n    (clobber (match_scratch:DI 4 \"=X,&1,&?d\"))\n    (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_64BIT\"\n+  \"TARGET_ZARCH\"\n {\n   if (which_alternative != 0)\n     return \"#\";\n@@ -7723,7 +7772,7 @@\n \t\t (subreg:SI (match_dup 2) 4)))\n    (clobber (match_scratch:SI 4 \"=X,&1,&?d\"))\n    (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_64BIT\"\n+  \"TARGET_ZARCH\"\n {\n   if (which_alternative != 0)\n     return \"#\";\n@@ -7766,7 +7815,7 @@\n \t\t (subreg:SI (match_dup 2) 0)))\n    (clobber (match_scratch:SI 4 \"=X,&1,&?d\"))\n    (clobber (reg:CC CC_REGNUM))]\n-  \"!TARGET_64BIT && TARGET_CPU_ZARCH\"\n+  \"!TARGET_ZARCH && TARGET_CPU_ZARCH\"\n {\n   if (which_alternative != 0)\n     return \"#\";\n@@ -7808,7 +7857,7 @@\n     emit_jump_insn (gen_doloop_si31 (operands[4], operands[0], operands[0]));\n   else if (GET_MODE (operands[0]) == SImode && TARGET_CPU_ZARCH)\n     emit_jump_insn (gen_doloop_si64 (operands[4], operands[0], operands[0]));\n-  else if (GET_MODE (operands[0]) == DImode && TARGET_64BIT)\n+  else if (GET_MODE (operands[0]) == DImode && TARGET_ZARCH)\n     emit_jump_insn (gen_doloop_di (operands[4], operands[0], operands[0]));\n   else\n     FAIL;\n@@ -7939,7 +7988,7 @@\n         (plus:DI (match_dup 1) (const_int -1)))\n    (clobber (match_scratch:DI 3 \"=X,&1,&?d\"))\n    (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_64BIT\"\n+  \"TARGET_ZARCH\"\n {\n   if (which_alternative != 0)\n     return \"#\";\n@@ -8497,13 +8546,13 @@\n \n ; cds, cdsg\n (define_insn \"*sync_compare_and_swap<mode>\"\n-  [(set (match_operand:DP 0 \"register_operand\" \"=r\")\n-\t(match_operand:DP 1 \"memory_operand\" \"+Q\"))\n+  [(set (match_operand:DW 0 \"register_operand\" \"=r\")\n+\t(match_operand:DW 1 \"memory_operand\" \"+Q\"))\n    (set (match_dup 1)\n-\t(unspec_volatile:DP\n+\t(unspec_volatile:DW\n \t  [(match_dup 1)\n-\t   (match_operand:DP 2 \"register_operand\" \"0\")\n-\t   (match_operand:DP 3 \"register_operand\" \"r\")]\n+\t   (match_operand:DW 2 \"register_operand\" \"0\")\n+\t   (match_operand:DW 3 \"register_operand\" \"r\")]\n \t  UNSPECV_CAS))\n    (set (reg:CCZ1 CC_REGNUM)\n \t(compare:CCZ1 (match_dup 1) (match_dup 2)))]\n@@ -8646,20 +8695,20 @@\n    (match_operand 1 \"register_operand\" \"\")]\n   \"\"\n {\n-  enum machine_mode mode = TARGET_64BIT ? OImode : TImode;\n   rtx base = gen_rtx_REG (Pmode, BASE_REGNUM);\n \n   /* Copy the backchain to the first word, sp to the second and the\n      literal pool base to the third.  */\n \n+  rtx save_bc = adjust_address (operands[0], Pmode, 0);\n+  rtx save_sp = adjust_address (operands[0], Pmode, GET_MODE_SIZE (Pmode));\n+  rtx save_bp = adjust_address (operands[0], Pmode, 2 * GET_MODE_SIZE (Pmode));\n+\n   if (TARGET_BACKCHAIN)\n-    {\n-      rtx temp = force_reg (Pmode, s390_back_chain_rtx ());\n-      emit_move_insn (operand_subword (operands[0], 0, 0, mode), temp);\n-    }\n+    emit_move_insn (save_bc, force_reg (Pmode, s390_back_chain_rtx ()));\n \n-  emit_move_insn (operand_subword (operands[0], 1, 0, mode), operands[1]);\n-  emit_move_insn (operand_subword (operands[0], 2, 0, mode), base);\n+  emit_move_insn (save_sp, operands[1]);\n+  emit_move_insn (save_bp, base);\n \n   DONE;\n })\n@@ -8669,18 +8718,21 @@\n    (match_operand 1 \"memory_operand\" \"\")]\n   \"\"\n {\n-  enum machine_mode mode = TARGET_64BIT ? OImode : TImode;\n   rtx base = gen_rtx_REG (Pmode, BASE_REGNUM);\n   rtx temp = NULL_RTX;\n \n   /* Restore the backchain from the first word, sp from the second and the\n      literal pool base from the third.  */\n \n+  rtx save_bc = adjust_address (operands[1], Pmode, 0);\n+  rtx save_sp = adjust_address (operands[1], Pmode, GET_MODE_SIZE (Pmode));\n+  rtx save_bp = adjust_address (operands[1], Pmode, 2 * GET_MODE_SIZE (Pmode));\n+\n   if (TARGET_BACKCHAIN)\n-    temp = force_reg (Pmode, operand_subword (operands[1], 0, 0, mode));\n+    temp = force_reg (Pmode, save_bc);\n \n-  emit_move_insn (base, operand_subword (operands[1], 2, 0, mode));\n-  emit_move_insn (operands[0], operand_subword (operands[1], 1, 0, mode));\n+  emit_move_insn (base, save_bp);\n+  emit_move_insn (operands[0], save_sp);\n \n   if (temp)\n     emit_move_insn (s390_back_chain_rtx (), temp);"}, {"sha": "49daa6e4255cae7e42a116df2a8f3c83b25a047f", "filename": "gcc/longlong.h", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9602b6a1b8de60ca429f08ca00e2834d26fe1f47/gcc%2Flonglong.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9602b6a1b8de60ca429f08ca00e2834d26fe1f47/gcc%2Flonglong.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flonglong.h?ref=9602b6a1b8de60ca429f08ca00e2834d26fe1f47", "patch": "@@ -318,6 +318,7 @@ UDItype __umulsidi3 (USItype, USItype);\n #endif\n \n #if (defined (__i370__) || defined (__s390__) || defined (__mvs__)) && W_TYPE_SIZE == 32\n+#if !defined (__zarch__)\n #define smul_ppmm(xh, xl, m0, m1) \\\n   do {\t\t\t\t\t\t\t\t\t\\\n     union {DItype __ll;\t\t\t\t\t\t\t\\\n@@ -339,6 +340,28 @@ UDItype __umulsidi3 (USItype, USItype);\n \t     : \"0\" (__x.__ll), \"r\" (d));\t\t\t\t\\\n     (q) = __x.__i.__l; (r) = __x.__i.__h;\t\t\t\t\\\n   } while (0)\n+#else\n+#define smul_ppmm(xh, xl, m0, m1) \\\n+  do {                                                                  \\\n+    register SItype r0 __asm__ (\"0\");                                   \\\n+    register SItype r1 __asm__ (\"1\") = m0;                              \\\n+                                                                        \\\n+    __asm__ (\"mr\\t%%r0,%3\"                                              \\\n+             : \"=r\" (r0), \"=r\" (r1)                                     \\\n+             : \"r\"  (r1),  \"r\" (m1));                                   \\\n+    (xh) = r1; (xl) = r0;                                               \\\n+  } while (0)\n+#define sdiv_qrnnd(q, r, n1, n0, d) \\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    register SItype r0 __asm__ (\"0\") = n0;                              \\\n+    register SItype r1 __asm__ (\"1\") = n1;                              \\\n+                                                                        \\\n+    __asm__ (\"dr\\t%%r0,%3\"\t\t\t\t\t\t\\\n+\t     : \"=r\" (r0), \"=r\" (r1)\t\t         \t\t\\\n+\t     : \"r\" (r0), \"r\" (r1), \"r\" (d));\t\t\t\t\\\n+    (q) = r0; (r) = r1;                  \t\t\t\t\\\n+  } while (0)\n+#endif /* __zarch__ */\n #endif\n \n #if (defined (__i386__) || defined (__i486__)) && W_TYPE_SIZE == 32"}, {"sha": "4b0a61eee0a3973052e7161bbfbfd5b87cb2d84a", "filename": "libjava/include/s390-signal.h", "status": "modified", "additions": 71, "deletions": 3, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9602b6a1b8de60ca429f08ca00e2834d26fe1f47/libjava%2Finclude%2Fs390-signal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9602b6a1b8de60ca429f08ca00e2834d26fe1f47/libjava%2Finclude%2Fs390-signal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fs390-signal.h?ref=9602b6a1b8de60ca429f08ca00e2834d26fe1f47", "patch": "@@ -39,6 +39,7 @@ static void _name (int, siginfo_t *_si __attribute__((unused)), \\\n    and if dividend and divisor are as above, we simply return from the signal\n    handler.  This causes execution to continue after the instruction.  \n    Before returning, we the set result registers as expected.  */\n+#define UC_EXTENDED\t0x00000001\n \n #define HANDLE_DIVIDE_OVERFLOW\t\t\t\t\t\t\\\n do\t\t\t\t\t\t\t\t\t\\\n@@ -47,6 +48,15 @@ do\t\t\t\t\t\t\t\t\t\\\n     __builtin_extract_return_addr (_si->si_addr);\t\t\t\\\n   unsigned long *_regs = _uc->uc_mcontext.gregs;\t\t\t\\\n   int _r1, _r2, _d2, _x2, _b2;\t\t\t\t\t\t\\\n+  struct                                                                \\\n+  {                                                                     \\\n+    unsigned long int uc_flags;                                         \\\n+    struct ucontext *uc_link;                                           \\\n+    stack_t uc_stack;                                                   \\\n+    mcontext_t uc_mcontext;                                             \\\n+    unsigned long sigmask[2];                                           \\\n+    unsigned long ext_regs[16];\t\t\t\t\t\t\\\n+  } *_uc_ext = (typeof(_uc_ext))_uc;\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   /* First, a couple of helper routines to decode instructions.  */\t\\\n   struct _decode \t\t\t\t\t\t\t\\\n@@ -119,8 +129,16 @@ do\t\t\t\t\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n \treturn _d + (_x? _regs[_x] : 0) + (_b? _regs[_b] : 0);\t\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n-    };\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n+      static inline int is_long_long_min_p (unsigned long *_regs,       \\\n+\t\t\t\t\t    unsigned long *_ext_regs,   \\\n+\t\t\t\t\t    int _r)\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\treturn ((long long)_regs[_r]\t\t\t\t\t\\\n+\t\t| (long long)_ext_regs[_r] << 32) ==\t\t\t\\\n+\t  LONG_LONG_MIN;\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  };\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   /* DR r1,r2 */\t\t\t\t\t\t\t\\\n   if (_decode::_is_rr (_eip, 0x1d, &_r1, &_r2)\t\t\t\t\\\n@@ -175,8 +193,58 @@ do\t\t\t\t\t\t\t\t\t\\\n       _regs[_r1] = 0;\t\t\t\t\t\t\t\\\n       return;\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-}\t\t\t\t\t\t\t\t\t\\\n+                                                                        \\\n+  /* The extended ucontext contains the upper halfs of the 64bit\t\\\n+     registers in 31bit applications.  */\t\t\t\t\\\n+  if (_uc->uc_flags & 1 == 1)\t\t\t\t\t\t\\\n+    {             \t\t\t\t\t\t\t\\\n+      /* DSGR r1,r2 */\t\t\t\t\t\t\t\\\n+      if (_decode::_is_rre (_eip, 0xb9, 0x0d, &_r1, &_r2)\t\t\\\n+\t  && (int) _regs[_r2] == -1\t\t\t\t\t\\\n+\t  && (int) _uc_ext->ext_regs[_r2] == -1\t\t\t\t\\\n+\t  && _decode::is_long_long_min_p (_regs, _uc_ext->ext_regs,\t\\\n+\t\t\t\t\t  _r1 + 1))\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  _regs[_r1] = 0;\t\t\t\t\t\t\\\n+\t  _uc_ext->ext_regs[_r1] = 0;\t\t\t\t\t\\\n+\t  return;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      \t\t\t\t\t\t\t\t\t\\\n+      /* DSGFR r1,r2 */\t\t\t\t\t\t\t\\\n+      if (_decode::_is_rre (_eip, 0xb9, 0x1d, &_r1, &_r2)\t\t\\\n+\t  && (int) _regs[_r2] == -1\t\t\t\t\t\\\n+\t  && _decode::is_long_long_min_p (_regs, _uc_ext->ext_regs,\t\\\n+\t\t\t\t\t  _r1 + 1))\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  _regs[_r1] = 0;\t\t\t\t\t\t\\\n+\t  _uc_ext->ext_regs[_r1] = 0;\t\t\t\t\t\\\n+\t  return;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      \t\t\t\t\t\t\t\t\t\\\n+      /* DSG r1,d2(x2,b2) */\t\t\t\t\t\t\\\n+      if (_decode::_is_rxy (_eip, 0xe3, 0x0d, &_r1, &_d2, &_x2, &_b2)\t\\\n+\t  && *(int *) _decode::_eff (_regs, _d2, _x2, _b2) == -1\t\\\n+\t  && *(int *) _decode::_eff (_regs, _d2 + 4, _x2, _b2) == -1\t\\\n+\t  && _decode::is_long_long_min_p (_regs, _uc_ext->ext_regs,\t\\\n+\t\t\t\t\t  _r1 + 1))\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  _regs[_r1] = 0;\t\t\t\t\t\t\\\n+\t  _uc_ext->ext_regs[_r1] = 0;\t\t\t\t\t\\\n+\t  return;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+\t      \t\t\t\t\t\t\t\t\\\n+      /* DSGF r1,d2(x2,b2) */\t\t\t\t\t\t\\\n+      if (_decode::_is_rxy (_eip, 0xe3, 0x1d, &_r1, &_d2, &_x2, &_b2)\t\\\n+\t  && *(int *) _decode::_eff (_regs, _d2, _x2, _b2) == -1\t\\\n+\t  && _decode::is_long_long_min_p (_regs, _uc_ext->ext_regs,\t\\\n+\t\t\t\t\t  _r1 + 1))\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  _regs[_r1] = 0;\t\t\t\t\t\t\\\n+\t  _uc_ext->ext_regs[_r1] = 0;\t\t\t\t\t\\\n+\t  return;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+ }                                                                      \\\n while (0)\n \n /* For an explanation why we cannot simply use sigaction to"}]}