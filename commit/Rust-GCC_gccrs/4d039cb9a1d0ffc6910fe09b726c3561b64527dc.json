{"sha": "4d039cb9a1d0ffc6910fe09b726c3561b64527dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQwMzljYjlhMWQwZmZjNjkxMGZlMDliNzI2YzM1NjFiNjQ1MjdkYw==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-09-24T16:35:52Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-11-13T23:08:35Z"}, "message": "libstdc++: Use custom timespec in system calls [PR 93421]\n\nOn 32-bit targets where userspace has switched to 64-bit time_t, we\ncannot pass struct timespec to SYS_futex or SYS_clock_gettime, because\nthe userspace definition of struct timespec will not match what the\nkernel expects.\n\nWe use the existence of the SYS_futex_time64 or SYS_clock_gettime_time64\nmacros to imply that userspace *might* have switched to the new timespec\ndefinition.  This is a conservative assumption. It's possible that the\nnew syscall numbers are defined in the libc headers but that timespec\nhasn't been updated yet (as is the case for glibc currently). But using\nthe alternative struct with two longs is still OK, it's just redundant\nif userspace timespec still uses a 32-bit time_t.\n\nWe also check that SYS_futex_time64 != SYS_futex so that we don't try\nto use a 32-bit tv_sec on modern targets that only support the 64-bit\nsystem calls and define the old macro to the same value as the new one.\n\nWe could possibly check #ifdef __USE_TIME_BITS64 to see whether\nuserspace has actually been updated, but it's not clear if user code\nis meant to inspect that or if it's only for libc internal use.\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/93421\n\t* src/c++11/chrono.cc [_GLIBCXX_USE_CLOCK_GETTIME_SYSCALL]\n\t(syscall_timespec): Define a type suitable for SYS_clock_gettime\n\tcalls.\n\t(system_clock::now(), steady_clock::now()): Use syscall_timespec\n\tinstead of timespec.\n\t* src/c++11/futex.cc (syscall_timespec): Define a type suitable\n\tfor SYS_futex and SYS_clock_gettime calls.\n\t(relative_timespec): Use syscall_timespec instead of timespec.\n\t(__atomic_futex_unsigned_base::_M_futex_wait_until): Likewise.\n\t(__atomic_futex_unsigned_base::_M_futex_wait_until_steady):\n\tLikewise.", "tree": {"sha": "0005ec05f087505ddf42f286a9134e3bc3e9f2d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0005ec05f087505ddf42f286a9134e3bc3e9f2d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d039cb9a1d0ffc6910fe09b726c3561b64527dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d039cb9a1d0ffc6910fe09b726c3561b64527dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d039cb9a1d0ffc6910fe09b726c3561b64527dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d039cb9a1d0ffc6910fe09b726c3561b64527dc/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8d36dcc917e8a06d8c20b9f5ecc920ed2b9e947", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8d36dcc917e8a06d8c20b9f5ecc920ed2b9e947", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8d36dcc917e8a06d8c20b9f5ecc920ed2b9e947"}], "stats": {"total": 40, "additions": 32, "deletions": 8}, "files": [{"sha": "f10be7d8c073b21b062242c421dc34fee3c4a96b", "filename": "libstdc++-v3/src/c++11/chrono.cc", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d039cb9a1d0ffc6910fe09b726c3561b64527dc/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fchrono.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d039cb9a1d0ffc6910fe09b726c3561b64527dc/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fchrono.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fchrono.cc?ref=4d039cb9a1d0ffc6910fe09b726c3561b64527dc", "patch": "@@ -35,6 +35,17 @@\n #ifdef _GLIBCXX_USE_CLOCK_GETTIME_SYSCALL\n #include <unistd.h>\n #include <sys/syscall.h>\n+\n+# if defined(SYS_clock_gettime_time64) \\\n+  && SYS_clock_gettime_time64 != SYS_clock_gettime\n+  // Userspace knows about the new time64 syscalls, so it's possible that\n+  // userspace has also updated timespec to use a 64-bit tv_sec.\n+  // The SYS_clock_gettime syscall still uses the old definition\n+  // of timespec where tv_sec is 32 bits, so define a type that matches that.\n+  struct syscall_timespec { long tv_sec; long tv_nsec; };\n+# else\n+  using syscall_timespec = ::timespec;\n+# endif\n #endif\n \n namespace std _GLIBCXX_VISIBILITY(default)\n@@ -52,11 +63,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     system_clock::now() noexcept\n     {\n #ifdef _GLIBCXX_USE_CLOCK_REALTIME\n-      timespec tp;\n       // -EINVAL, -EFAULT\n #ifdef _GLIBCXX_USE_CLOCK_GETTIME_SYSCALL\n+      syscall_timespec tp;\n       syscall(SYS_clock_gettime, CLOCK_REALTIME, &tp);\n #else\n+      timespec tp;\n       clock_gettime(CLOCK_REALTIME, &tp);\n #endif\n       return time_point(duration(chrono::seconds(tp.tv_sec)\n@@ -80,11 +92,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     steady_clock::now() noexcept\n     {\n #ifdef _GLIBCXX_USE_CLOCK_MONOTONIC\n-      timespec tp;\n       // -EINVAL, -EFAULT\n #ifdef _GLIBCXX_USE_CLOCK_GETTIME_SYSCALL\n+      syscall_timespec tp;\n       syscall(SYS_clock_gettime, CLOCK_MONOTONIC, &tp);\n #else\n+      timespec tp;\n       clock_gettime(CLOCK_MONOTONIC, &tp);\n #endif\n       return time_point(duration(chrono::seconds(tp.tv_sec)"}, {"sha": "9adfb898b4f1adf883b1c3b0addf0944e245ba9d", "filename": "libstdc++-v3/src/c++11/futex.cc", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d039cb9a1d0ffc6910fe09b726c3561b64527dc/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Ffutex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d039cb9a1d0ffc6910fe09b726c3561b64527dc/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Ffutex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Ffutex.cc?ref=4d039cb9a1d0ffc6910fe09b726c3561b64527dc", "patch": "@@ -58,13 +58,23 @@ namespace\n   std::atomic<bool> futex_clock_realtime_unavailable;\n   std::atomic<bool> futex_clock_monotonic_unavailable;\n \n+#if defined(SYS_futex_time64) && SYS_futex_time64 != SYS_futex\n+  // Userspace knows about the new time64 syscalls, so it's possible that\n+  // userspace has also updated timespec to use a 64-bit tv_sec.\n+  // The SYS_futex and SYS_clock_gettime syscalls still use the old definition\n+  // of timespec where tv_sec is 32 bits, so define a type that matches that.\n+  struct syscall_timespec { long tv_sec; long tv_nsec; };\n+#else\n+  using syscall_timespec = ::timespec;\n+#endif\n+\n   // Return the relative duration from (now_s + now_ns) to (abs_s + abs_ns)\n-  // as a timespec.\n-  struct timespec\n+  // as a timespec suitable for syscalls.\n+  syscall_timespec\n   relative_timespec(chrono::seconds abs_s, chrono::nanoseconds abs_ns,\n \t\t    time_t now_s, long now_ns)\n   {\n-    struct timespec rt;\n+    syscall_timespec rt;\n \n     // Did we already time out?\n     if (now_s > abs_s.count())\n@@ -119,7 +129,7 @@ namespace\n \t    if (__s.count() < 0)\n \t      return false;\n \n-\t    struct timespec rt;\n+\t    syscall_timespec rt;\n \t    if (__s.count() > __int_traits<time_t>::__max) [[unlikely]]\n \t      rt.tv_sec = __int_traits<time_t>::__max;\n \t    else\n@@ -195,7 +205,7 @@ namespace\n \t    if (__s.count() < 0) [[unlikely]]\n \t      return false;\n \n-\t    struct timespec rt;\n+\t    syscall_timespec rt;\n \t    if (__s.count() > __int_traits<time_t>::__max) [[unlikely]]\n \t      rt.tv_sec = __int_traits<time_t>::__max;\n \t    else\n@@ -224,10 +234,11 @@ namespace\n \n \t// We only get to here if futex_clock_monotonic_unavailable was\n \t// true or has just been set to true.\n-\tstruct timespec ts;\n #ifdef _GLIBCXX_USE_CLOCK_GETTIME_SYSCALL\n+\tsyscall_timespec ts;\n \tsyscall(SYS_clock_gettime, CLOCK_MONOTONIC, &ts);\n #else\n+\tstruct timespec ts;\n \tclock_gettime(CLOCK_MONOTONIC, &ts);\n #endif\n "}]}