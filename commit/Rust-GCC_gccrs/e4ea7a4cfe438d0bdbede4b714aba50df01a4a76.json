{"sha": "e4ea7a4cfe438d0bdbede4b714aba50df01a4a76", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTRlYTdhNGNmZTQzOGQwYmRiZWRlNGI3MTRhYmE1MGRmMDFhNGE3Ng==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-05-23T16:03:34Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-05-23T16:03:34Z"}, "message": "cp-tree.h (DECL_HIDDEN_P): New.\n\n\tgcc/cp/\n\t* cp-tree.h (DECL_HIDDEN_P): New.\n\t* name-lookup.c (set_decl_context)\n\tset_local_extern_decl_linkage):\tNew, broken out of ...\n\t(pushdecl_maybe_friend_1): ... here.  Call them.\n\n\tgcc/testsuite/\n\t* g++.dg/parse/ctor9.C: Adjust expected error.\n(--This line, and those below, will be ignored--\n\nM    cp/name-lookup.c\nM    cp/ChangeLog\nM    cp/cp-tree.h\nM    testsuite/ChangeLog\nM    testsuite/g++.dg/parse/ctor9.C\n\nFrom-SVN: r248373", "tree": {"sha": "8316666990b99a7bfca2daaef08f1fc10111e6dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8316666990b99a7bfca2daaef08f1fc10111e6dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e4ea7a4cfe438d0bdbede4b714aba50df01a4a76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4ea7a4cfe438d0bdbede4b714aba50df01a4a76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4ea7a4cfe438d0bdbede4b714aba50df01a4a76", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4ea7a4cfe438d0bdbede4b714aba50df01a4a76/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8a4674bb23450c036861f56aa88ad7c979c2dd38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a4674bb23450c036861f56aa88ad7c979c2dd38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a4674bb23450c036861f56aa88ad7c979c2dd38"}], "stats": {"total": 236, "additions": 153, "deletions": 83}, "files": [{"sha": "2e2415c130e928abb682f1d2a4e2d43cf7f7aed9", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4ea7a4cfe438d0bdbede4b714aba50df01a4a76/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4ea7a4cfe438d0bdbede4b714aba50df01a4a76/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e4ea7a4cfe438d0bdbede4b714aba50df01a4a76", "patch": "@@ -1,3 +1,10 @@\n+2017-05-23  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* cp-tree.h (DECL_HIDDEN_P): New.\n+\t* name-lookup.c (set_decl_context,\n+\tset_local_extern_decl_linkage):\tNew, broken out of ...\n+\t(pushdecl_maybe_friend_1): ... here.  Call them.\n+\n 2017-05-23  Thomas Schwinge  <thomas@codesourcery.com>\n \n \t* parser.c (OACC_KERNELS_CLAUSE_MASK): Add"}, {"sha": "bbb75d4c456b736cca24ddfc82b12b3c89a60c4b", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4ea7a4cfe438d0bdbede4b714aba50df01a4a76/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4ea7a4cfe438d0bdbede4b714aba50df01a4a76/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=e4ea7a4cfe438d0bdbede4b714aba50df01a4a76", "patch": "@@ -3775,6 +3775,11 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n   (DECL_LANG_SPECIFIC (TYPE_FUNCTION_OR_TEMPLATE_DECL_CHECK (NODE)) \\\n    ->u.base.anticipated_p)\n \n+/* Is DECL NODE a hidden name?  */\n+#define DECL_HIDDEN_P(NODE) \\\n+  (DECL_LANG_SPECIFIC (NODE) && TYPE_FUNCTION_OR_TEMPLATE_DECL_P (NODE) \\\n+   && DECL_ANTICIPATED (NODE))\n+\n /* True if this is a hidden class type.    */\n #define TYPE_HIDDEN_P(NODE) \\\n   (DECL_LANG_SPECIFIC (TYPE_NAME (NODE)) \\"}, {"sha": "388d02704e6d5b28145c362b776d49e31213c95c", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 136, "deletions": 82, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4ea7a4cfe438d0bdbede4b714aba50df01a4a76/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4ea7a4cfe438d0bdbede4b714aba50df01a4a76/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=e4ea7a4cfe438d0bdbede4b714aba50df01a4a76", "patch": "@@ -1534,6 +1534,137 @@ check_local_shadow (tree decl)\n   inform (DECL_SOURCE_LOCATION (shadowed), \"shadowed declaration is here\");\n }\n \n+\n+/* DECL is being pushed inside function CTX.  Set its context, if\n+   needed.  */\n+\n+static void\n+set_decl_context_in_fn (tree ctx, tree decl)\n+{\n+  if (!DECL_CONTEXT (decl)\n+      /* A local declaration for a function doesn't constitute\n+\t nesting.  */\n+      && TREE_CODE (decl) != FUNCTION_DECL\n+      /* A local declaration for an `extern' variable is in the\n+\t scope of the current namespace, not the current\n+\t function.  */\n+      && !(VAR_P (decl) && DECL_EXTERNAL (decl))\n+      /* When parsing the parameter list of a function declarator,\n+\t don't set DECL_CONTEXT to an enclosing function.  When we\n+\t push the PARM_DECLs in order to process the function body,\n+\t current_binding_level->this_entity will be set.  */\n+      && !(TREE_CODE (decl) == PARM_DECL\n+\t   && current_binding_level->kind == sk_function_parms\n+\t   && current_binding_level->this_entity == NULL))\n+    DECL_CONTEXT (decl) = ctx;\n+\n+  /* If this is the declaration for a namespace-scope function,\n+     but the declaration itself is in a local scope, mark the\n+     declaration.  */\n+  if (TREE_CODE (decl) == FUNCTION_DECL && DECL_NAMESPACE_SCOPE_P (decl))\n+    DECL_LOCAL_FUNCTION_P (decl) = 1;\n+}\n+\n+/* DECL is a local-scope decl with linkage.  SHADOWED is true if the\n+   name is already bound at the current level.\n+\n+   [basic.link] If there is a visible declaration of an entity with\n+   linkage having the same name and type, ignoring entities declared\n+   outside the innermost enclosing namespace scope, the block scope\n+   declaration declares that same entity and receives the linkage of\n+   the previous declaration.\n+\n+   Also, make sure that this decl matches any existing external decl\n+   in the enclosing namespace.  */\n+\n+static void\n+set_local_extern_decl_linkage (tree decl, bool shadowed)\n+{\n+  tree ns_value = decl; /* Unique marker.  */\n+\n+  if (!shadowed)\n+    {\n+      tree loc_value = innermost_non_namespace_value (DECL_NAME (decl));\n+      if (!loc_value)\n+\t{\n+\t  ns_value\n+\t    = get_namespace_binding (current_namespace, DECL_NAME (decl));\n+\t  loc_value = ns_value;\n+\t}\n+      if (loc_value == error_mark_node)\n+\tloc_value = NULL_TREE;\n+\n+      for (ovl_iterator iter (loc_value); iter; ++iter)\n+\tif (!DECL_HIDDEN_P (*iter)\n+\t    && (TREE_STATIC (*iter) || DECL_EXTERNAL (*iter))\n+\t    && decls_match (*iter, decl))\n+\t  {\n+\t    /* The standard only says that the local extern inherits\n+\t       linkage from the previous decl; in particular, default\n+\t       args are not shared.  Add the decl into a hash table to\n+\t       make sure only the previous decl in this case is seen\n+\t       by the middle end.  */\n+\t    struct cxx_int_tree_map *h;\n+\n+\t    /* We inherit the outer decl's linkage.  But we're a\n+\t       different decl.  */\n+\t    TREE_PUBLIC (decl) = TREE_PUBLIC (*iter);\n+\n+\t    if (cp_function_chain->extern_decl_map == NULL)\n+\t      cp_function_chain->extern_decl_map\n+\t\t= hash_table<cxx_int_tree_map_hasher>::create_ggc (20);\n+\n+\t    h = ggc_alloc<cxx_int_tree_map> ();\n+\t    h->uid = DECL_UID (decl);\n+\t    h->to = *iter;\n+\t    cxx_int_tree_map **loc = cp_function_chain->extern_decl_map\n+\t      ->find_slot (h, INSERT);\n+\t    *loc = h;\n+\t    break;\n+\t  }\n+    }\n+\n+  if (TREE_PUBLIC (decl))\n+    {\n+      /* DECL is externally visible.  Make sure it matches a matching\n+\t decl in the namespace scpe.  We only really need to check\n+\t this when inserting the decl, not when we find an existing\n+\t match in the current scope.  However, in practice we're\n+\t going to be inserting a new decl in the majority of cases --\n+\t who writes multiple extern decls for the same thing in the\n+\t same local scope?  Doing it here often avoids a duplicate\n+\t namespace lookup.  */\n+\n+      /* Avoid repeating a lookup.  */\n+      if (ns_value == decl)\n+\tns_value = get_namespace_binding (current_namespace, DECL_NAME (decl));\n+\n+      if (ns_value == error_mark_node)\n+\tns_value = NULL_TREE;\n+\n+      for (ovl_iterator iter (ns_value); iter; ++iter)\n+\t{\n+\t  tree other = *iter;\n+\n+\t  if (!(TREE_PUBLIC (other) || DECL_EXTERNAL (other)))\n+\t    ; /* Not externally visible.   */\n+\t  else if (DECL_EXTERN_C_P (decl) && DECL_EXTERN_C_P (other))\n+\t    ; /* Both are extern \"C\", we'll check via that mechanism.  */\n+\t  else if (TREE_CODE (other) != TREE_CODE (decl)\n+\t\t   || ((VAR_P (decl) || matching_fn_p (other, decl))\n+\t\t       && !comptypes (TREE_TYPE (decl), TREE_TYPE (other),\n+\t\t\t\t      COMPARE_REDECLARATION)))\n+\t    {\n+\t      if (permerror (DECL_SOURCE_LOCATION (decl),\n+\t\t\t     \"local external declaration %q#D\", decl))\n+\t\tinform (DECL_SOURCE_LOCATION (other),\n+\t\t\t\"does not match previous declaration %q#D\", other);\n+\t      break;\n+\t    }\n+\t}\n+    }\n+}\n+\n /* Record a decl-node X as belonging to the current lexical scope.\n    Check for errors (such as an incompatible declaration for the same\n    name already seen in the same scope).  IS_FRIEND is true if X is\n@@ -1555,45 +1686,12 @@ pushdecl_maybe_friend_1 (tree x, bool is_friend)\n \n   need_new_binding = 1;\n \n-  if (DECL_TEMPLATE_PARM_P (x))\n-    /* Template parameters have no context; they are not X::T even\n-       when declared within a class or namespace.  */\n-    ;\n-  else\n-    {\n-      if (current_function_decl && x != current_function_decl\n-\t  /* A local declaration for a function doesn't constitute\n-\t     nesting.  */\n-\t  && TREE_CODE (x) != FUNCTION_DECL\n-\t  /* A local declaration for an `extern' variable is in the\n-\t     scope of the current namespace, not the current\n-\t     function.  */\n-\t  && !(VAR_P (x) && DECL_EXTERNAL (x))\n-\t  /* When parsing the parameter list of a function declarator,\n-\t     don't set DECL_CONTEXT to an enclosing function.  When we\n-\t     push the PARM_DECLs in order to process the function body,\n-\t     current_binding_level->this_entity will be set.  */\n-\t  && !(TREE_CODE (x) == PARM_DECL\n-\t       && current_binding_level->kind == sk_function_parms\n-\t       && current_binding_level->this_entity == NULL)\n-\t  && !DECL_CONTEXT (x))\n-\tDECL_CONTEXT (x) = current_function_decl;\n-\n-      /* If this is the declaration for a namespace-scope function,\n-\t but the declaration itself is in a local scope, mark the\n-\t declaration.  */\n-      if (TREE_CODE (x) == FUNCTION_DECL\n-\t  && DECL_NAMESPACE_SCOPE_P (x)\n-\t  && current_function_decl\n-\t  && x != current_function_decl)\n-\tDECL_LOCAL_FUNCTION_P (x) = 1;\n-    }\n+  if (!DECL_TEMPLATE_PARM_P (x) && current_function_decl)\n+    set_decl_context_in_fn (current_function_decl, x);\n \n   name = DECL_NAME (x);\n   if (name)\n     {\n-      int different_binding_level = 0;\n-\n       if (TREE_CODE (name) == TEMPLATE_ID_EXPR)\n \tname = TREE_OPERAND (name, 0);\n \n@@ -1604,27 +1702,9 @@ pushdecl_maybe_friend_1 (tree x, bool is_friend)\n       else\n \tt = lookup_name_innermost_nonclass_level (name);\n \n-      /* [basic.link] If there is a visible declaration of an entity\n-\t with linkage having the same name and type, ignoring entities\n-\t declared outside the innermost enclosing namespace scope, the\n-\t block scope declaration declares that same entity and\n-\t receives the linkage of the previous declaration.  */\n-      if (! t && current_function_decl && x != current_function_decl\n-\t  && VAR_OR_FUNCTION_DECL_P (x)\n+      if (current_function_decl && VAR_OR_FUNCTION_DECL_P (x)\n \t  && DECL_EXTERNAL (x))\n-\t{\n-\t  /* Look in block scope.  */\n-\t  t = innermost_non_namespace_value (name);\n-\t  /* Or in the innermost namespace.  */\n-\t  if (! t)\n-\t    t = get_namespace_binding (DECL_CONTEXT (x), name);\n-\t  /* Does it have linkage?  Note that if this isn't a DECL, it's an\n-\t     OVERLOAD, which is OK.  */\n-\t  if (t && DECL_P (t) && ! (TREE_STATIC (t) || DECL_EXTERNAL (t)))\n-\t    t = NULL_TREE;\n-\t  if (t)\n-\t    different_binding_level = 1;\n-\t}\n+\tset_local_extern_decl_linkage (x, t != NULL_TREE);\n \n       /* If we are declaring a function, and the result of name-lookup\n \t was an OVERLOAD, look for an overloaded instance that is\n@@ -1653,33 +1733,7 @@ pushdecl_maybe_friend_1 (tree x, bool is_friend)\n \n       if (t && t != error_mark_node)\n \t{\n-\t  if (different_binding_level)\n-\t    {\n-\t      if (decls_match (x, t))\n-\t\t/* The standard only says that the local extern\n-\t\t   inherits linkage from the previous decl; in\n-\t\t   particular, default args are not shared.  Add\n-\t\t   the decl into a hash table to make sure only\n-\t\t   the previous decl in this case is seen by the\n-\t\t   middle end.  */\n-\t\t{\n-\t\t  struct cxx_int_tree_map *h;\n-\n-\t\t  TREE_PUBLIC (x) = TREE_PUBLIC (t);\n-\n-\t\t  if (cp_function_chain->extern_decl_map == NULL)\n-\t\t    cp_function_chain->extern_decl_map\n-\t\t      = hash_table<cxx_int_tree_map_hasher>::create_ggc (20);\n-\n-\t\t  h = ggc_alloc<cxx_int_tree_map> ();\n-\t\t  h->uid = DECL_UID (x);\n-\t\t  h->to = t;\n-\t\t  cxx_int_tree_map **loc = cp_function_chain->extern_decl_map\n-\t\t    ->find_slot (h, INSERT);\n-\t\t  *loc = h;\n-\t\t}\n-\t    }\n-\t  else if (TREE_CODE (t) == PARM_DECL)\n+\t  if (TREE_CODE (t) == PARM_DECL)\n \t    {\n \t      /* Check for duplicate params.  */\n \t      tree d = duplicate_decls (x, t, is_friend);"}, {"sha": "9877c76a0e500da775cdc8dbef9e7753d8b9e600", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4ea7a4cfe438d0bdbede4b714aba50df01a4a76/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4ea7a4cfe438d0bdbede4b714aba50df01a4a76/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e4ea7a4cfe438d0bdbede4b714aba50df01a4a76", "patch": "@@ -1,3 +1,7 @@\n+2017-05-23  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* g++.dg/parse/ctor9.C: Adjust expected error.\n+\n 2017-05-23  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libgfortran/80256"}, {"sha": "6df2595e1440cbbc545749f46ff62035dac17923", "filename": "gcc/testsuite/g++.dg/parse/ctor9.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4ea7a4cfe438d0bdbede4b714aba50df01a4a76/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fctor9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4ea7a4cfe438d0bdbede4b714aba50df01a4a76/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fctor9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fctor9.C?ref=e4ea7a4cfe438d0bdbede4b714aba50df01a4a76", "patch": "@@ -3,5 +3,5 @@\n \n struct A\n {\n-  A() { void A(); } /* { dg-error \"return type specification for constructor invalid|non-class scope\" } */\n+  A() { void A(); } /* { dg-error \"return type specification for constructor invalid|non-class scope|local external\" } */\n };"}]}