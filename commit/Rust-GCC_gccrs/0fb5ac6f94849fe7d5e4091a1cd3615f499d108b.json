{"sha": "0fb5ac6f94849fe7d5e4091a1cd3615f499d108b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGZiNWFjNmY5NDg0OWZlN2Q1ZTQwOTFhMWNkMzYxNWY0OTlkMTA4Yg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1992-07-22T15:20:56Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1992-07-22T15:20:56Z"}, "message": "Cleanup, and make prologue issue schedulable insns.\n\nFrom-SVN: r1660", "tree": {"sha": "d4a0199950f7814d9044032abc3dd58da79c9c3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d4a0199950f7814d9044032abc3dd58da79c9c3e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0fb5ac6f94849fe7d5e4091a1cd3615f499d108b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fb5ac6f94849fe7d5e4091a1cd3615f499d108b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fb5ac6f94849fe7d5e4091a1cd3615f499d108b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fb5ac6f94849fe7d5e4091a1cd3615f499d108b/comments", "author": null, "committer": null, "parents": [{"sha": "207cdd07635f7c3dc1db6e32cfcc91730b81cfca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/207cdd07635f7c3dc1db6e32cfcc91730b81cfca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/207cdd07635f7c3dc1db6e32cfcc91730b81cfca"}], "stats": {"total": 589, "additions": 442, "deletions": 147}, "files": [{"sha": "994642c7f25c123be75e942f2c40bc80f92d0330", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 259, "deletions": 113, "changes": 372, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb5ac6f94849fe7d5e4091a1cd3615f499d108b/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb5ac6f94849fe7d5e4091a1cd3615f499d108b/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=0fb5ac6f94849fe7d5e4091a1cd3615f499d108b", "patch": "@@ -62,37 +62,38 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #define STAB_CODE_TYPE int\n #endif\n \n-extern char *getenv ();\n-\n-extern char *permalloc ();\n-extern void  debug_rtx ();\n-extern void  abort_with_insn ();\n-extern rtx   copy_to_reg ();\n-extern rtx   adj_offsettable_operand ();\n-extern int   offsettable_address_p ();\n-extern tree  lookup_name ();\n-\n-extern rtx gen_movqi ();\n-extern rtx gen_movhi ();\n-extern rtx gen_movsi ();\n-extern rtx gen_movsi_ulw ();\n-extern rtx gen_movsi_usw ();\n-extern rtx gen_movstrsi_internal ();\n-extern rtx gen_addsi3 ();\n-extern rtx gen_iorsi3 ();\n-extern rtx gen_andsi3 ();\n-extern rtx gen_bne ();\n-extern rtx gen_beq ();\n-extern rtx gen_cmpsi ();\n-extern rtx gen_jump ();\n-\n-extern char   call_used_regs[];\n-extern char  *asm_file_name;\n-extern FILE  *asm_out_file;\n+extern void   abort ();\n+extern int    atoi ();\n+extern char  *getenv ();\n+extern char  *mktemp ();\n+ \n+extern rtx    adj_offsettable_operand ();\n+extern rtx    copy_to_reg ();\n+extern void   error ();\n+extern void   fatal ();\n+extern tree   lookup_name ();\n+extern void   pfatal_with_name ();\n+extern void   warning ();\n+\n+extern rtx    gen_addsi3 ();\n+extern rtx    gen_andsi3 ();\n+extern rtx    gen_beq ();\n+extern rtx    gen_bne ();\n+extern rtx    gen_cmpsi ();\n+extern rtx    gen_indirect_jump ();\n+extern rtx    gen_iorsi3 ();\n+extern rtx    gen_jump ();\n+extern rtx    gen_movhi ();\n+extern rtx    gen_movqi ();\n+extern rtx    gen_movsi ();\n+extern rtx    gen_movsi_ulw ();\n+extern rtx    gen_movsi_usw ();\n+extern rtx    gen_movstrsi_internal ();\n+extern rtx    gen_return_internal ();\n+extern rtx    gen_subsi3 ();\n+\n extern tree   current_function_decl;\n-extern char **save_argv;\n-extern char  *version_string;\n-extern char  *language_string;\n+extern FILE  *asm_out_file;\n \n /* Enumeration for all of the relational tests, so that we can build\n    arrays indexed by the test type, and not worry about the order\n@@ -447,6 +448,9 @@ reg_or_0_operand (op, mode)\n {\n   switch (GET_CODE (op))\n     {\n+    default:\n+      break;\n+\n     case CONST_INT:\n       return (INTVAL (op) == 0);\n \n@@ -558,6 +562,9 @@ simple_memory_operand (op, mode)\n   addr = XEXP (op, 0);\n   switch (GET_CODE (addr))\n     {\n+    default:\n+      break;\n+\n     case REG:\n       return TRUE;\n \n@@ -819,6 +826,9 @@ mips_count_memory_refs (op, num)\n       looping = FALSE;\n       switch (GET_CODE (addr))\n \t{\n+\tdefault:\n+\t  break;\n+\n \tcase REG:\n \tcase CONST_INT:\n \t  break;\n@@ -1013,6 +1023,7 @@ mips_move_1word (operands, insn, unsignedp)\n \t\t target, so zero/sign extend can use this code as well.  */\n \t      switch (GET_MODE (op1))\n \t\t{\n+\t\tdefault:      break;\n \t\tcase SFmode: ret = \"lw\\t%0,%1\"; break;\n \t\tcase SImode: ret = \"lw\\t%0,%1\"; break;\n \t\tcase HImode: ret = (unsignedp) ? \"lhu\\t%0,%1\" : \"lh\\t%0,%1\"; break;\n@@ -1049,7 +1060,7 @@ mips_move_1word (operands, insn, unsignedp)\n \t    }\n \n \t  else if (GP_REG_P (regno0))\n-\t    ret = (INTVAL (op1) < 0) ? \"li\\t%0,%1\\t\\t# %X1\" : \"li\\t%0,%X1\\t\\t# %1\";\n+\t    ret = (INTVAL (op1) < 0) ? \"li\\t%0,%1\\t\\t\\t# %X1\" : \"li\\t%0,%X1\\t\\t# %1\";\n \t}\n \n       else if (code1 == CONST_DOUBLE && mode == SFmode)\n@@ -1121,6 +1132,7 @@ mips_move_1word (operands, insn, unsignedp)\n \t    {\n \t      switch (mode)\n \t\t{\n+\t\tdefault: break;\n \t\tcase SFmode: ret = \"sw\\t%1,%0\"; break;\n \t\tcase SImode: ret = \"sw\\t%1,%0\"; break;\n \t\tcase HImode: ret = \"sh\\t%1,%0\"; break;\n@@ -1136,6 +1148,7 @@ mips_move_1word (operands, insn, unsignedp)\n \t{\n \t  switch (mode)\n \t    {\n+\t    default: break;\n \t    case SFmode: ret = \"sw\\t%z1,%0\"; break;\n \t    case SImode: ret = \"sw\\t%z1,%0\"; break;\n \t    case HImode: ret = \"sh\\t%z1,%0\"; break;\n@@ -1147,6 +1160,7 @@ mips_move_1word (operands, insn, unsignedp)\n \t{\n \t  switch (mode)\n \t    {\n+\t    default: break;\n \t    case SFmode: ret = \"sw\\t%.,%0\"; break;\n \t    case SImode: ret = \"sw\\t%.,%0\"; break;\n \t    case HImode: ret = \"sh\\t%.,%0\"; break;\n@@ -1274,8 +1288,8 @@ mips_move_2words (operands, insn)\n \n \t      else\n \t\t{\n-\t\t  operands[2] = gen_rtx (CONST_INT, VOIDmode, CONST_DOUBLE_LOW (op1));\n-\t\t  operands[3] = gen_rtx (CONST_INT, VOIDmode, CONST_DOUBLE_HIGH (op1));\n+\t\t  operands[2] = GEN_INT (CONST_DOUBLE_LOW (op1));\n+\t\t  operands[3] = GEN_INT (CONST_DOUBLE_HIGH (op1));\n \t\t  ret = \"li\\t%M0,%3\\n\\tli\\t%L0,%2\";\n \t\t}\n \t    }\n@@ -1311,7 +1325,7 @@ mips_move_2words (operands, insn)\n \t\n       else if (code1 == CONST_INT && GET_MODE (op0) == DImode && GP_REG_P (regno0))\n \t{\n-\t  operands[2] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[1]) >= 0 ? 0 : -1);\n+\t  operands[2] = GEN_INT (INTVAL (operands[1]) >= 0 ? 0 : -1);\n \t  ret = \"li\\t%M0,%2\\n\\tli\\t%L0,%1\";\n \t}\n \n@@ -1412,6 +1426,9 @@ mips_address_cost (addr)\n {\n   switch (GET_CODE (addr))\n     {\n+    default:\n+      break;\n+\n     case LO_SUM:\n     case HIGH:\n       return 1;\n@@ -1453,6 +1470,9 @@ mips_address_cost (addr)\n \n \tswitch (GET_CODE (plus1))\n \t  {\n+\t  default:\n+\t    break;\n+\n \t  case CONST_INT:\n \t    {\n \t      int value = INTVAL (plus1);\n@@ -1483,6 +1503,7 @@ map_test_to_internal_test (test_code)\n \n   switch (test_code)\n     {\n+    default:\t\t\tbreak;\n     case EQ:  test = ITEST_EQ;  break;\n     case NE:  test = ITEST_NE;  break;\n     case GT:  test = ITEST_GT;  break;\n@@ -1645,7 +1666,7 @@ gen_int_relational (test_code, result, cmp0, cmp1, p_invert)\n   if (GET_CODE (cmp1) == CONST_INT)\n     {\n       if (p_info->const_add != 0)\n-\tcmp1 = gen_rtx (CONST_INT, VOIDmode, INTVAL (cmp1) + p_info->const_add);\n+\tcmp1 = GEN_INT (INTVAL (cmp1) + p_info->const_add);\n     }\n   else if (p_info->reverse_regs)\n     {\n@@ -1809,6 +1830,7 @@ gen_conditional_branch (operands, test_code)\n /* Internal code to generate the load and store of one word/short/byte.\n    The load is emitted directly, and the store insn is returned.  */\n \n+#if 0\n static rtx\n block_move_load_store (dest_reg, src_reg, p_bytes, p_offset, align, orig_src)\n      rtx src_reg;\t\t/* register holding source memory address */\n@@ -1881,8 +1903,8 @@ block_move_load_store (dest_reg, src_reg, p_bytes, p_offset, align, orig_src)\n     }\n   else\n     {\n-      src_addr  = gen_rtx (PLUS, Pmode, src_reg,  gen_rtx (CONST_INT, VOIDmode, offset));\n-      dest_addr = gen_rtx (PLUS, Pmode, dest_reg, gen_rtx (CONST_INT, VOIDmode, offset));\n+      src_addr  = gen_rtx (PLUS, Pmode, src_reg,  GEN_INT (offset));\n+      dest_addr = gen_rtx (PLUS, Pmode, dest_reg, GEN_INT (offset));\n     }\n \n   reg = gen_reg_rtx (mode);\n@@ -1895,6 +1917,7 @@ block_move_load_store (dest_reg, src_reg, p_bytes, p_offset, align, orig_src)\n \n   return (*store_func) (gen_rtx (MEM, mode, dest_addr), reg);\n }\n+#endif\n \n \f\n /* Write a series of loads/stores to move some bytes.  Generate load/stores as follows:\n@@ -1913,6 +1936,7 @@ block_move_load_store (dest_reg, src_reg, p_bytes, p_offset, align, orig_src)\n    two temp registers are needed.  Two delay slots are used\n    in deference to the R4000.  */\n \n+#if 0\n static void\n block_move_sequence (dest_reg, src_reg, bytes, align, orig_src)\n      rtx dest_reg;\t\t/* register holding destination address */\n@@ -1949,6 +1973,7 @@ block_move_sequence (dest_reg, src_reg, bytes, align, orig_src)\n   if (cur_store)\n     emit_insn (cur_store);\n }\n+#endif\n \n \f\n /* Write a loop to move a constant number of bytes.  Generate load/stores as follows:\n@@ -1986,11 +2011,10 @@ block_move_loop (dest_reg, src_reg, bytes, align, orig_src)\n {\n   rtx dest_mem\t\t= gen_rtx (MEM, BLKmode, dest_reg);\n   rtx src_mem\t\t= gen_rtx (MEM, BLKmode, src_reg);\n-  rtx align_rtx\t\t= gen_rtx (CONST_INT, VOIDmode, align);\n+  rtx align_rtx\t\t= GEN_INT (align);\n   rtx label;\n   rtx final_src;\n   rtx bytes_rtx;\n-  int i;\n   int leftover;\n \n   if (bytes < 2*MAX_MOVE_BYTES)\n@@ -2001,7 +2025,7 @@ block_move_loop (dest_reg, src_reg, bytes, align, orig_src)\n \n   label = gen_label_rtx ();\n   final_src = gen_reg_rtx (Pmode);\n-  bytes_rtx = gen_rtx (CONST_INT, VOIDmode, bytes);\n+  bytes_rtx = GEN_INT (bytes);\n \n   if (bytes > 0x7fff)\n     {\n@@ -2013,7 +2037,7 @@ block_move_loop (dest_reg, src_reg, bytes, align, orig_src)\n \n   emit_label (label);\n \n-  bytes_rtx = gen_rtx (CONST_INT, VOIDmode, MAX_MOVE_BYTES);\n+  bytes_rtx = GEN_INT (MAX_MOVE_BYTES);\n   emit_insn (gen_movstrsi_internal (dest_mem, src_mem, bytes_rtx, align_rtx));\n   emit_insn (gen_addsi3 (src_reg, src_reg, bytes_rtx));\n   emit_insn (gen_addsi3 (dest_reg, dest_reg, bytes_rtx));\n@@ -2022,7 +2046,7 @@ block_move_loop (dest_reg, src_reg, bytes, align, orig_src)\n \n   if (leftover)\n     emit_insn (gen_movstrsi_internal (dest_mem, src_mem,\n-\t\t\t\t      gen_rtx (CONST_INT, VOIDmode, leftover),\n+\t\t\t\t      GEN_INT (leftover),\n \t\t\t\t      align_rtx));\n }\n \n@@ -2111,7 +2135,7 @@ expand_block_move (operands)\n       bytes -= leftover;\n \n       emit_insn (gen_iorsi3 (temp, src_reg, dest_reg));\n-      emit_insn (gen_andsi3 (temp, temp, gen_rtx (CONST_INT, VOIDmode, UNITS_PER_WORD-1)));\n+      emit_insn (gen_andsi3 (temp, temp, GEN_INT (UNITS_PER_WORD-1)));\n       emit_insn (gen_cmpsi (temp, const0_rtx));\n       emit_jump_insn (gen_beq (aligned_label));\n \n@@ -2136,8 +2160,8 @@ expand_block_move (operands)\n #endif\n \t    emit_insn (gen_movstrsi_internal (gen_rtx (MEM, BLKmode, dest_reg),\n \t\t\t\t\t      gen_rtx (MEM, BLKmode, src_reg),\n-\t\t\t\t\t      gen_rtx (CONST_INT, VOIDmode, leftover),\n-\t\t\t\t\t      gen_rtx (CONST_INT, VOIDmode, align)));\n+\t\t\t\t\t      GEN_INT (leftover),\n+\t\t\t\t\t      GEN_INT (align)));\n \t}\n     }\n \n@@ -2458,6 +2482,7 @@ function_arg_advance (cum, mode, type, named)\n      CUMULATIVE_ARGS *cum;\t/* current arg information */\n      enum machine_mode mode;\t/* current arg mode */\n      tree type;\t\t\t/* type of the argument or 0 if lib support */\n+     int named;\t\t\t/* whether or not the argument was named */\n {\n   if (TARGET_DEBUG_E_MODE)\n     fprintf (stderr,\n@@ -3569,7 +3594,6 @@ final_prescan_insn (insn, opvec, noperands)\n {\n   if (dslots_number_nops > 0)\n     {\n-      enum machine_mode mode = GET_MODE (mips_load_reg);\n       rtx pattern = PATTERN (insn);\n       int length = get_attr_length (insn);\n \n@@ -3892,6 +3916,8 @@ compute_frame_size (size)\n   current_frame_info.mask\t = mask;\n   current_frame_info.fmask\t = fmask;\n   current_frame_info.initialized = reload_completed;\n+  current_frame_info.num_gp\t = gp_reg_size / UNITS_PER_WORD;\n+  current_frame_info.num_fp\t = fp_reg_size / (2*UNITS_PER_WORD);\n \n   if (mask)\n     {\n@@ -3912,7 +3938,7 @@ compute_frame_size (size)\n }\n \n \f\n-/* Common code to save/restore registers.  */\n+/* Save/restore registers printing out the instructions to a file.  */\n \n void\n save_restore (file, gp_op, gp_2word_op, fp_op)\n@@ -3986,6 +4012,89 @@ save_restore (file, gp_op, gp_2word_op, fp_op)\n     }\n }\n \n+\f\n+/* Common code to emit the insns to save/restore registers.  */\n+\n+static void\n+save_restore_insns (store_p)\n+     int store_p;\t\t/* true if this is prologue */\n+{\n+  int regno;\n+  rtx base_reg_rtx\t  = stack_pointer_rtx;\n+  unsigned long mask\t  = current_frame_info.mask;\n+  unsigned long fmask\t  = current_frame_info.fmask;\n+  unsigned long gp_offset;\n+  unsigned long fp_offset;\n+  unsigned long max_offset;\n+\n+  if (mask == 0 && fmask == 0)\n+    return;\n+\n+  gp_offset  = current_frame_info.gp_sp_offset;\n+  fp_offset  = current_frame_info.fp_sp_offset;\n+  max_offset = (gp_offset > fp_offset) ? gp_offset : fp_offset;\n+\n+  /* Deal with calling functions with a large structure.  */\n+  if (max_offset >= 32768)\n+    {\n+      base_reg_rtx = gen_rtx (REG, Pmode, MIPS_TEMP2_REGNUM);\n+      emit_move_insn (base_reg_rtx, GEN_INT (max_offset));\n+      emit_insn (gen_addsi3 (base_reg_rtx, base_reg_rtx, stack_pointer_rtx));\n+      gp_offset = max_offset - gp_offset;\n+      fp_offset = max_offset - fp_offset;\n+    }\n+\n+  /* Save registers starting from high to low.  The debuggers prefer\n+     at least the return register be stored at func+4, and also it\n+     allows us not to need a nop in the epilog if at least one\n+     register is reloaded in addition to return address.  */\n+\n+  if (mask || frame_pointer_needed)\n+    {\n+      for  (regno = GP_REG_LAST; regno >= GP_REG_FIRST; regno--)\n+\t{\n+\t  if ((mask & (1L << (regno - GP_REG_FIRST))) != 0\n+\t      || (regno == FRAME_POINTER_REGNUM && frame_pointer_needed))\n+\t    {\n+\t      rtx reg_rtx = gen_rtx (REG, Pmode, regno);\n+\t      rtx mem_rtx = gen_rtx (MEM, Pmode,\n+\t\t\t\t     gen_rtx (PLUS, Pmode, base_reg_rtx,\n+\t\t\t\t\t      GEN_INT (gp_offset)));\n+\n+\t      if (store_p)\n+\t\temit_move_insn (mem_rtx, reg_rtx);\n+\t      else\n+\t\temit_move_insn (reg_rtx, mem_rtx);\n+\n+\t      gp_offset -= UNITS_PER_WORD;\n+\t    }\n+\t}\n+    }\n+\n+  if (fmask)\n+    {\n+      int fp_inc = (TARGET_FLOAT64) ? 1 : 2;\n+\n+      for  (regno = FP_REG_LAST-1; regno >= FP_REG_FIRST; regno -= fp_inc)\n+\t{\n+\t  if ((fmask & (1L << (regno - FP_REG_FIRST))) != 0)\n+\t    {\n+\t      rtx reg_rtx = gen_rtx (REG, DFmode, regno);\n+\t      rtx mem_rtx = gen_rtx (MEM, DFmode,\n+\t\t\t\t     gen_rtx (PLUS, Pmode, base_reg_rtx,\n+\t\t\t\t\t      GEN_INT (fp_offset)));\n+\n+\t      if (store_p)\n+\t\temit_move_insn (mem_rtx, reg_rtx);\n+\t      else\n+\t\temit_move_insn (reg_rtx, mem_rtx);\n+\n+\t      fp_offset -= 2*UNITS_PER_WORD;\n+\t    }\n+\t}\n+    }\n+}\n+\n \f\n /* Set up the stack and frame (if desired) for the function.  */\n \n@@ -3994,21 +4103,9 @@ function_prologue (file, size)\n      FILE *file;\n      int size;\n {\n-  int regno;\n-  int tsize;\n-  char *sp_str = reg_names[STACK_POINTER_REGNUM];\n-  char *fp_str = (!frame_pointer_needed)\n-\t\t\t? sp_str\n-\t\t\t: reg_names[FRAME_POINTER_REGNUM];\n-  tree fndecl = current_function_decl; /* current... is tooo long */\n-  tree fntype = TREE_TYPE (fndecl);\n-  tree fnargs = (TREE_CODE (fntype) != METHOD_TYPE)\n-\t\t\t? DECL_ARGUMENTS (fndecl)\n-\t\t\t: 0;\n-  tree next_arg;\n-  tree cur_arg;\n-  char *arg_name = (char *)0;\n-  CUMULATIVE_ARGS args_so_far;\n+  int tsize = current_frame_info.total_size;\n+  int vframe;\n+  int vreg;\n \n   ASM_OUTPUT_SOURCE_FILENAME (file, DECL_SOURCE_FILE (current_function_decl));\n   ASM_OUTPUT_SOURCE_LINE (file, DECL_SOURCE_LINE (current_function_decl));\n@@ -4025,6 +4122,57 @@ function_prologue (file, size)\n \t     \"\\t.set\\tnoreorder\\n\\t.cpload\\t%s\\n\\t.set\\treorder\\n\",\n \t     reg_names[ GP_REG_FIRST + 25 ]);\n \n+  tsize = current_frame_info.total_size;\n+  if (tsize > 0 && TARGET_ABICALLS)\n+    fprintf (file, \"\\t.cprestore %d\\n\", tsize + STARTING_FRAME_OFFSET);\n+\n+  if (frame_pointer_needed)\n+    {\n+      vframe = 0;\n+      vreg   = FRAME_POINTER_REGNUM;\n+    }\n+  else\n+    {\n+      vframe = tsize;\n+      vreg   = STACK_POINTER_REGNUM;\n+    }\n+\n+  fprintf (file, \"\\t.frame\\t%s,%d,%s\\t\\t# vars= %d, regs= %d/%d, args = %d, extra= %d\\n\",\n+\t   reg_names[ vreg ],\n+\t   vframe,\n+\t   reg_names[31 + GP_REG_FIRST],\n+\t   current_frame_info.var_size,\n+\t   current_frame_info.num_gp,\n+\t   current_frame_info.num_fp,\n+\t   current_function_outgoing_args_size,\n+\t   current_frame_info.extra_size);\n+\n+  fprintf (file, \"\\t.mask\\t0x%08lx,%d\\n\\t.fmask\\t0x%08lx,%d\\n\",\n+\t   current_frame_info.mask,\n+\t   current_frame_info.gp_save_offset,\n+\t   current_frame_info.fmask,\n+\t   current_frame_info.fp_save_offset);\n+}\n+\n+\f\n+/* Expand the prologue into a bunch of separate insns.  */\n+\n+void\n+mips_expand_prologue ()\n+{\n+  int regno;\n+  int size;\n+  int tsize;\n+  tree fndecl = current_function_decl; /* current... is tooo long */\n+  tree fntype = TREE_TYPE (fndecl);\n+  tree fnargs = (TREE_CODE (fntype) != METHOD_TYPE)\n+\t\t\t? DECL_ARGUMENTS (fndecl)\n+\t\t\t: 0;\n+  tree next_arg;\n+  tree cur_arg;\n+  char *arg_name = (char *)0;\n+  CUMULATIVE_ARGS args_so_far;\n+\n   /* Determine the last argument, and get its name.  */\n   for (cur_arg = fnargs; cur_arg != (tree)0; cur_arg = next_arg)\n     {\n@@ -4084,68 +4232,37 @@ function_prologue (file, size)\n \t\t\t\tDECL_ARG_TYPE (parm), 1);\n \t}\n \n-      if (regno <= GP_ARG_LAST && (regno & 1) != 0)\n+      for (; regno <= GP_ARG_LAST; regno++)\n \t{\n-\t  fprintf (file, \"\\tsw\\t%s,%d(%s)\\t\\t# varargs home register\\n\",\n-\t\t   reg_names[regno], (regno - 4) * 4, sp_str);\n-\t  regno++;\n-\t}\n+\t  rtx ptr = stack_pointer_rtx;\n+\t  if (regno != GP_ARG_FIRST)\n+\t    ptr = gen_rtx (PLUS, Pmode, ptr,\n+\t\t\t   GEN_INT ((regno - GP_ARG_FIRST) * UNITS_PER_WORD));\n \n-      for (; regno <= GP_ARG_LAST; regno += 2)\n-\t{\n-\t  fprintf (file, \"\\tsd\\t%s,%d(%s)\\t\\t# varargs home register\\n\",\n-\t\t   reg_names[regno], (regno - 4) * 4, sp_str);\n+\t  emit_move_insn (gen_rtx (MEM, Pmode, ptr), gen_rtx (REG, Pmode, regno));\n \t}\n     }\n \n-  size = MIPS_STACK_ALIGN (size);\n-  tsize = (!current_frame_info.initialized)\n-\t\t? compute_frame_size (size)\n-\t\t: current_frame_info.total_size;\n+  size  = MIPS_STACK_ALIGN (get_frame_size ());\n+  tsize = compute_frame_size (size);\n \n   if (tsize > 0)\n     {\n-      if (tsize <= 32767)\n-\tfprintf (file,\n-\t\t \"\\tsubu\\t%s,%s,%d\\t\\t# vars= %d, regs= %d/%d, args = %d, extra= %d\\n\",\n-\t\t sp_str, sp_str, tsize, current_frame_info.var_size,\n-\t\t current_frame_info.gp_reg_size / 4,\n-\t\t current_frame_info.fp_reg_size / 8,\n-\t\t current_function_outgoing_args_size,\n-\t\t current_frame_info.extra_size);\n-      else\n-\tfprintf (file,\n-\t\t \"\\tli\\t%s,%d\\n\\tsubu\\t%s,%s,%s\\t\\t# vars= %d, regs= %d/%d, args = %d, sfo= %d\\n\",\n-\t\t reg_names[MIPS_TEMP1_REGNUM], tsize, sp_str, sp_str,\n-\t\t reg_names[MIPS_TEMP1_REGNUM], current_frame_info.var_size,\n-\t\t current_frame_info.gp_reg_size / 4,\n-\t\t current_frame_info.fp_reg_size / 8,\n-\t\t current_function_outgoing_args_size,\n-\t\t current_frame_info.extra_size);\n-    }\n+      rtx tsize_rtx = GEN_INT (tsize);\n \n-  if (TARGET_ABICALLS)\n-    fprintf (file, \"\\t.cprestore %d\\n\", tsize + STARTING_FRAME_OFFSET);\n-\n-  fprintf (file, \"\\t.frame\\t%s,%d,%s\\n\\t.mask\\t0x%08lx,%d\\n\\t.fmask\\t0x%08lx,%d\\n\",\n-\t   fp_str,\n-\t   (frame_pointer_needed) ? 0 : tsize,\n-\t   reg_names[31 + GP_REG_FIRST],\n-\t   current_frame_info.mask,\n-\t   current_frame_info.gp_save_offset,\n-\t   current_frame_info.fmask,\n-\t   current_frame_info.fp_save_offset);\n+      if (tsize > 32767)\n+\t{\n+\t  rtx tmp_rtx = gen_rtx (REG, SImode, MIPS_TEMP1_REGNUM);\n+\t  emit_move_insn (tmp_rtx, tsize_rtx);\n+\t  tsize_rtx = tmp_rtx;\n+\t}\n \n-  save_restore (file, \"sw\", \"sd\", \"s.d\");\n+      emit_insn (gen_subsi3 (stack_pointer_rtx, stack_pointer_rtx, tsize_rtx));\n \n-  if (frame_pointer_needed)\n-    {\n-      if (tsize <= 32767)\n-\tfprintf (file, \"\\taddu\\t%s,%s,%d\\t\\t# set up frame pointer\\n\", fp_str, sp_str, tsize);\n+      save_restore_insns (TRUE);\n \n-      else\n-\tfprintf (file, \"\\taddu\\t%s,%s,%s\\t\\t# set up frame pointer\\n\", fp_str, sp_str,\n-\t\t reg_names[MIPS_TEMP1_REGNUM]);\n+      if (frame_pointer_needed)\n+\temit_insn (gen_addsi3 (frame_pointer_rtx, stack_pointer_rtx, tsize_rtx));\n     }\n }\n \n@@ -4390,6 +4507,35 @@ function_epilogue (file, size)\n     asm_out_file = asm_out_data_file;\n }\n \n+\f\n+/* Expand the epilogue into a bunch of separate insns.  */\n+\n+void\n+mips_expand_epilogue ()\n+{\n+  int tsize = current_frame_info.total_size;\n+  rtx tsize_rtx = GEN_INT (tsize);\n+\n+  if (tsize > 32767)\n+    {\n+      rtx tmp_rtx = gen_rtx (REG, SImode, MIPS_TEMP1_REGNUM);\n+      emit_move_insn (tmp_rtx, tsize_rtx);\n+      tsize_rtx = tmp_rtx;\n+    }\n+\n+  if (tsize > 0)\n+    {\n+      if (frame_pointer_needed)\n+\temit_insn (gen_subsi3 (stack_pointer_rtx, frame_pointer_rtx, tsize_rtx));\n+\n+      save_restore_insns (FALSE);\n+\n+      emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx, tsize_rtx));\n+    }\n+\n+  emit_jump_insn (gen_return_internal (gen_rtx (REG, Pmode, GP_REG_FIRST+31)));\n+}\n+\n \f\n /* Define the number of delay slots needed for the function epilogue.\n \n@@ -4417,7 +4563,7 @@ mips_epilogue_delay_slots ()\n    was created.  */\n \n int\n-null_epilogue ()\n+simple_epilogue_p ()\n {\n   if (!reload_completed)\n     return 0;"}, {"sha": "c0bf9475cc58bacc09f274f0bd21ed4ee9c5dac4", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 71, "deletions": 16, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb5ac6f94849fe7d5e4091a1cd3615f499d108b/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb5ac6f94849fe7d5e4091a1cd3615f499d108b/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=0fb5ac6f94849fe7d5e4091a1cd3615f499d108b", "patch": "@@ -28,12 +28,17 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n /* Standard GCC variables that we reference.  */\n \n-extern int target_flags;\n-extern int optimize;\n-extern int may_call_alloca;\n-extern int current_function_calls_alloca;\n-extern int frame_pointer_needed;\n-extern int flag_omit_frame_pointer;\n+extern char    *asm_file_name;\n+extern char\tcall_used_regs[];\n+extern int\tcurrent_function_calls_alloca;\n+extern int\tflag_omit_frame_pointer;\n+extern int\tframe_pointer_needed;\n+extern char    *language_string;\n+extern int\tmay_call_alloca;\n+extern int\toptimize;\n+extern char   **save_argv;\n+extern int\ttarget_flags;\n+extern char    *version_string;\n \n /* MIPS external variables defined in mips.c.  */\n \n@@ -140,11 +145,13 @@ extern int\t\tmd_register_operand ();\n extern int\t\tmips_address_cost ();\n extern void\t\tmips_asm_file_end ();\n extern void\t\tmips_asm_file_start ();\n-extern void\t\tmips_declare_object ();\n extern int\t\tmips_const_double_ok ();\n extern void\t\tmips_count_memory_refs ();\n extern int\t\tmips_debugger_offset ();\n+extern void\t\tmips_declare_object ();\n extern int\t\tmips_epilogue_delay_slots ();\n+extern void\t\tmips_expand_epilogue ();\n+extern void\t\tmips_expand_prologue ();\n extern char\t       *mips_fill_delay_slot ();\n extern char\t       *mips_move_1word ();\n extern char\t       *mips_move_2words ();\n@@ -160,19 +167,50 @@ extern void\t\tprint_operand_address ();\n extern void\t\tprint_operand ();\n extern void\t\tprint_options ();\n extern int\t\treg_or_0_operand ();\n+extern int\t\tsimple_epilogue_p ();\n extern int\t\tsimple_memory_operand ();\n extern int\t\tsmall_int ();\n extern void\t\ttrace();\n extern int\t\tuns_arith_operand ();\n extern int\t\tuns_cmp_op ();\n \n-/* Functions in varasm.c that we reference.  */\n+/* Recognition functions that return if a condition is true.  */\n+extern int\t\taddress_operand ();\n+extern int\t\tconst_double_operand ();\n+extern int\t\tconst_int_operand ();\n+extern int\t\tgeneral_operand ();\n+extern int\t\timmediate_operand ();\n+extern int\t\tmemory_address_p ();\n+extern int\t\tmemory_operand ();\n+extern int\t\tnonimmediate_operand ();\n+extern int\t\tnonmemory_operand ();\n+extern int\t\tregister_operand ();\n+extern int\t\tscratch_operand ();\n+\n+/* Functions to change what output section we are using.  */\n extern void\t\tdata_section ();\n extern void\t\trdata_section ();\n extern void\t\treadonly_data_section ();\n extern void\t\tsdata_section ();\n extern void\t\ttext_section ();\n \n+/* Functions in the rest of the compiler that we reference.  */\n+extern void\t\tabort_with_insn ();\n+extern void\t\tdebug_rtx ();\n+extern void\t\tfatal_io_error ();\n+extern int\t\tget_frame_size ();\n+extern int\t\toffsettable_address_p ();\n+extern void\t\toutput_address ();\n+extern char\t       *permalloc ();\n+extern int\t\treg_mentioned_p ();\n+\n+/* Functions in the standard library that we reference.  */\n+extern void\t\tabort ();\n+extern int\t\tatoi ();\n+extern char\t       *getenv ();\n+extern char\t       *mktemp ();\n+\n+\n /* Stubs for half-pic support if not OSF/1 reference platform.  */\n \n #ifndef HALF_PIC_P\n@@ -435,7 +473,7 @@ while (0)\n \f\n /* Print subsidiary information on the compiler version in use.  */\n \n-#define MIPS_VERSION \"[AL 1.1, MM 21]\"\n+#define MIPS_VERSION \"[AL 1.1, MM 22]\"\n \n #ifndef MACHINE_TYPE\n #define MACHINE_TYPE \"BSD Mips\"\n@@ -1143,13 +1181,13 @@ extern char mips_hard_regno_mode_ok[][FIRST_PSEUDO_REGISTER];\n /* #define PC_REGNUM xx\t\t\t\t*/\n \n /* Register to use for pushing function arguments.  */\n-#define STACK_POINTER_REGNUM 29\n+#define STACK_POINTER_REGNUM (GP_REG_FIRST + 29)\n \n /* Offset from the stack pointer to the first available location.  */\n #define STACK_POINTER_OFFSET 0\n \n /* Base register for access to local variables of the function.  */\n-#define FRAME_POINTER_REGNUM 30\n+#define FRAME_POINTER_REGNUM (GP_REG_FIRST + 30)\n \n /* Value should be nonzero if functions must have frame pointers.\n    Zero means the frame pointer need not be set up (and parms\n@@ -1161,19 +1199,19 @@ extern char mips_hard_regno_mode_ok[][FIRST_PSEUDO_REGISTER];\n #define ARG_POINTER_REGNUM FRAME_POINTER_REGNUM\n \n /* Register in which static-chain is passed to a function.  */\n-#define STATIC_CHAIN_REGNUM 2\n+#define STATIC_CHAIN_REGNUM (GP_REG_FIRST + 2)\n \n /* Register in which address to store a structure value\n    is passed to a function.  */\n-#define STRUCT_VALUE_REGNUM 4\n+#define STRUCT_VALUE_REGNUM (GP_REG_FIRST + 4)\n \n /* Mips registers used in prologue/epilogue code when the stack frame\n    is larger than 32K bytes.  These registers must come from the\n    scratch register set, and not used for passing and returning\n    arguments and any other information used in the calling sequence\n    (such as pic).  */\n-#define MIPS_TEMP1_REGNUM 8\n-#define MIPS_TEMP2_REGNUM 9\n+#define MIPS_TEMP1_REGNUM (GP_REG_FIRST + 8)\n+#define MIPS_TEMP2_REGNUM (GP_REG_FIRST + 9)\n \n /* Define this macro if it is as good or better to call a constant\n    function address than to call an address kept in a register.  */\n@@ -1191,7 +1229,7 @@ extern char mips_hard_regno_mode_ok[][FIRST_PSEUDO_REGISTER];\n    once, as with the stack pointer and frame pointer registers.  If\n    this macro is not defined, it is up to the machine-dependent\n    files to allocate such a register (if necessary).  */\n-#define PIC_OFFSET_TABLE_REGNUM 28\n+#define PIC_OFFSET_TABLE_REGNUM (GP_REG_FIRST + 28)\n \n \f\n /* Define the classes of registers for register constraints in the\n@@ -1400,6 +1438,21 @@ extern enum reg_class mips_char_to_class[];\n \t\t? GR_REGS\t\t\t\t\t\t\\\n \t\t: CLASS))\n \n+/* Certain machines have the property that some registers cannot be\n+   copied to some other registers without using memory.  Define this\n+   macro on those machines to be a C expression that is non-zero if\n+   objects of mode MODE in registers of CLASS1 can only be copied to\n+   registers of class CLASS2 by storing a register of CLASS1 into\n+   memory and loading that memory location into a register of CLASS2.\n+\n+   Do not define this macro if its value would always be zero.  */\n+\n+#define SECONDARY_MEMORY_NEEDED(CLASS1, CLASS2, MODE)\t\t\t\\\n+  (!TARGET_DEBUG_H_MODE\t\t\t\t\t\t\t\\\n+   && GET_MODE_CLASS (MODE) == MODE_INT\t\t\t\t\t\\\n+   && ((CLASS1 == FP_REGS && CLASS2 == GR_REGS)\t\t\t\t\\\n+       || (CLASS1 == GR_REGS && CLASS2 == FP_REGS)))\n+\n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.  */\n \n@@ -1458,6 +1511,8 @@ struct mips_frame_info\n   unsigned long gp_sp_offset;\t/* offset from new sp to store gp registers */\n   unsigned long fp_sp_offset;\t/* offset from new sp to store fp registers */\n   int\t\tinitialized;\t/* != 0 if frame size already calculated */\n+  int\t\tnum_gp;\t\t/* number of gp registers saved */\n+  int\t\tnum_fp;\t\t/* number of fp registers saved */\n };\n \n extern struct mips_frame_info current_frame_info;"}, {"sha": "0d56e2f59650facc0a043efde6a5b9f3d3f636a8", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 112, "deletions": 18, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb5ac6f94849fe7d5e4091a1cd3615f499d108b/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb5ac6f94849fe7d5e4091a1cd3615f499d108b/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=0fb5ac6f94849fe7d5e4091a1cd3615f499d108b", "patch": "@@ -1892,47 +1892,97 @@ move\\\\t%0,%z4\\\\n\\\\\n     }\n }\")\n \n-(define_insn \"movsi_internal\"\n+;; The difference between these two is whether or not ints are allowed\n+;; in FP registers (off by default, use -mdebugh to enable).\n+\n+(define_insn \"movsi_internal1\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,d,d,d,d,d,R,m,*d,*fz,*f,*f,*f,*R,*m,*x,*d\")\n \t(match_operand:SI 1 \"general_operand\" \"d,S,IKL,Mnis,R,m,dJ,dJ,*fz,*d,*f,*R,*m,*f,*f,*d,*x\"))]\n-  \"\"\n+  \"TARGET_DEBUG_H_MODE\"\n   \"* return mips_move_1word (operands, insn, TRUE);\"\n   [(set_attr \"type\"\t\"move,pic,arith,arith,load,load,store,store,xfer,xfer,move,load,load,store,store,hilo,hilo\")\n    (set_attr \"mode\"\t\"SI\")\n    (set_attr \"length\"\t\"1,4,1,2,1,2,1,2,1,1,1,1,2,1,2,1,1\")])\n \n+(define_insn \"movsi_internal2\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,d,d,d,d,d,R,m,*d,*z,*d,*x\")\n+\t(match_operand:SI 1 \"general_operand\" \"d,S,IKL,Mnis,R,m,dJ,dJ,*z,*d,*x,*d\"))]\n+  \"!TARGET_DEBUG_H_MODE\"\n+  \"* return mips_move_1word (operands, insn, TRUE);\"\n+  [(set_attr \"type\"\t\"move,pic,arith,arith,load,load,store,store,xfer,xfer,hilo,hilo\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"1,4,1,2,1,2,1,2,1,1,1,1\")])\n+\n+\n ;; 16-bit Integer moves\n \n ;; Unlike most other insns, the move insns can't be split with\n ;; different predicates, because register spilling and other parts of\n ;; the compiler, have memoized the insn number already.\n ;; Unsigned loads are used because BYTE_LOADS_ZERO_EXTEND is defined\n \n-(define_insn \"movhi\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d,d,d,d,R,m,*d,*f,*f,*x,*d\")\n-\t(match_operand:HI 1 \"general_operand\"       \"d,IK,R,m,dJ,dJ,*fz,*d,*f,*d,*x\"))]\n+(define_expand \"movhi\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:HI 1 \"general_operand\" \"\"))]\n   \"\"\n+  \"\")\n+\n+;; The difference between these two is whether or not ints are allowed\n+;; in FP registers (off by default, use -mdebugh to enable).\n+\n+(define_insn \"movhi_internal1\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d,d,d,d,R,m,*d,*f,*fz,*x,*d\")\n+\t(match_operand:HI 1 \"general_operand\"       \"d,IK,R,m,dJ,dJ,*fz,*d,*f,*d,*x\"))]\n+  \"TARGET_DEBUG_H_MODE\"\n   \"* return mips_move_1word (operands, insn, TRUE);\"\n   [(set_attr \"type\"\t\"move,arith,load,load,store,store,xfer,xfer,move,hilo,hilo\")\n    (set_attr \"mode\"\t\"HI\")\n    (set_attr \"length\"\t\"1,1,1,2,1,2,1,1,1,1,1\")])\n \n+(define_insn \"movhi_internal2\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d,d,d,d,R,m,*d,*z,*x,*d\")\n+\t(match_operand:HI 1 \"general_operand\"       \"d,IK,R,m,dJ,dJ,*z,*d,*d,*x\"))]\n+  \"!TARGET_DEBUG_H_MODE\"\n+  \"* return mips_move_1word (operands, insn, TRUE);\"\n+  [(set_attr \"type\"\t\"move,arith,load,load,store,store,xfer,xfer,hilo,hilo\")\n+   (set_attr \"mode\"\t\"HI\")\n+   (set_attr \"length\"\t\"1,1,1,2,1,2,1,1,1,1\")])\n+\n+\n ;; 8-bit Integer moves\n \n ;; Unlike most other insns, the move insns can't be split with\n ;; different predicates, because register spilling and other parts of\n ;; the compiler, have memoized the insn number already.\n ;; Unsigned loads are used because BYTE_LOADS_ZERO_EXTEND is defined\n \n-(define_insn \"movqi\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d,d,d,d,R,m,*d,*f,*f,*x,*d\")\n-\t(match_operand:QI 1 \"general_operand\"       \"d,IK,R,m,dJ,dJ,*fz,*d,*f,*d,*x\"))]\n+(define_expand \"movqi\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:QI 1 \"general_operand\" \"\"))]\n   \"\"\n+  \"\")\n+\n+;; The difference between these two is whether or not ints are allowed\n+;; in FP registers (off by default, use -mdebugh to enable).\n+\n+(define_insn \"movqi_internal1\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d,d,d,d,R,m,*d,*fz,*f,*x,*d\")\n+\t(match_operand:QI 1 \"general_operand\"       \"d,IK,R,m,dJ,dJ,*fz,*d,*f,*d,*x\"))]\n+  \"TARGET_DEBUG_H_MODE\"\n   \"* return mips_move_1word (operands, insn, TRUE);\"\n   [(set_attr \"type\"\t\"move,arith,load,load,store,store,xfer,xfer,move,hilo,hilo\")\n    (set_attr \"mode\"\t\"QI\")\n    (set_attr \"length\"\t\"1,1,1,2,1,2,1,1,1,1,1\")])\n \n+(define_insn \"movqi_internal2\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d,d,d,d,R,m,*d,*z,*x,*d\")\n+\t(match_operand:QI 1 \"general_operand\"       \"d,IK,R,m,dJ,dJ,*z,*d,*d,*x\"))]\n+  \"!TARGET_DEBUG_H_MODE\"\n+  \"* return mips_move_1word (operands, insn, TRUE);\"\n+  [(set_attr \"type\"\t\"move,arith,load,load,store,store,xfer,xfer,hilo,hilo\")\n+   (set_attr \"mode\"\t\"QI\")\n+   (set_attr \"length\"\t\"1,1,1,2,1,2,1,1,1,1\")])\n+\n \n ;; 32-bit floating point moves\n \n@@ -2117,7 +2167,7 @@ move\\\\t%0,%z4\\\\n\\\\\n \n \n (define_insn \"ashldi3_internal\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+  [(set (match_operand:DI 0 \"register_operand\" \"=&d\")\n \t(ashift:DI (match_operand:DI 1 \"register_operand\" \"d\")\n \t\t   (match_operand:SI 2 \"register_operand\" \"d\")))\n    (clobber (match_operand:SI 3 \"register_operand\" \"=d\"))]\n@@ -2317,7 +2367,7 @@ move\\\\t%0,%z4\\\\n\\\\\n \n \n (define_insn \"ashrdi3_internal\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+  [(set (match_operand:DI 0 \"register_operand\" \"=&d\")\n \t(ashiftrt:DI (match_operand:DI 1 \"register_operand\" \"d\")\n \t\t     (match_operand:SI 2 \"register_operand\" \"d\")))\n    (clobber (match_operand:SI 3 \"register_operand\" \"=d\"))]\n@@ -3843,18 +3893,62 @@ move\\\\t%0,%z4\\\\n\\\\\n ;; Function return, only allow after optimization, so that we can\n ;; eliminate jumps to jumps if no stack space is used.\n \n-(define_insn \"return\"\n-  [(return)]\n-  \"null_epilogue ()\"\n-  \"*\n-{\n-  operands[0] = gen_rtx (REG, SImode, GP_REG_FIRST + 31);\n-  return \\\"%*j\\\\t%0\\\";\n-}\"\n+;; (define_expand \"return\"\n+;;   [(set (pc) (reg:SI 31))]\n+;;   \"simple_epilogue_p ()\"\n+;;   \"\")\n+\n+(define_expand \"return\"\n+  [(parallel [(return)\n+\t      (use (reg:SI 31))])]\n+  \"simple_epilogue_p ()\"\n+  \"\")\n+\n+(define_insn \"return_internal\"\n+  [(parallel [(return)\n+              (use (match_operand:SI 0 \"register_operand\" \"d\"))])]\n+  \"\"\n+  \"%*j\\\\t%0\"\n   [(set_attr \"type\"\t\"jump\")\n    (set_attr \"mode\"\t\"none\")\n    (set_attr \"length\"\t\"1\")])\n \n+\f\n+;;\n+;;  ....................\n+;;\n+;;\tFunction prologue/epilogue\n+;;\n+;;  ....................\n+;;\n+\n+(define_expand \"prologue\"\n+  [(const_int 1)]\n+  \"\"\n+  \"\n+{\n+  if (mips_isa >= 0)\t\t/* avoid unused code warnings */\n+    {\n+      mips_expand_prologue ();\n+      DONE;\n+    }\n+}\")\n+\n+;; At present, don't expand the epilogue, reorg.c will clobber the\n+;; return register in compiling gen_lowpart (emit-rtl.c).\n+;; \n+;; (define_expand \"epilogue\"\n+;;   [(const_int 2)]\n+;;   \"\"\n+;;   \"\n+;; {\n+;;   if (mips_isa >= 0)            /* avoid unused code warnings */\n+;;     {\n+;;       mips_expand_epilogue ();\n+;;       DONE;\n+;;     }\n+;; }\")\n+\n \f\n ;;\n ;;  ...................."}]}