{"sha": "502f194fa0b65cb5e3bcd62e19567fa097176af3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTAyZjE5NGZhMGI2NWNiNWUzYmNkNjJlMTk1NjdmYTA5NzE3NmFmMw==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-12-12T21:48:09Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-12-12T21:48:09Z"}, "message": "Loks of changes so we can better compile from source.\n\n \nLoks of changes so we can better compile from source.  See ChangeLog.\n\nFrom-SVN: r24279", "tree": {"sha": "7e0395b38ff17bb5d7800306934ed2d74d459e1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e0395b38ff17bb5d7800306934ed2d74d459e1b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/502f194fa0b65cb5e3bcd62e19567fa097176af3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/502f194fa0b65cb5e3bcd62e19567fa097176af3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/502f194fa0b65cb5e3bcd62e19567fa097176af3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/502f194fa0b65cb5e3bcd62e19567fa097176af3/comments", "author": null, "committer": null, "parents": [{"sha": "091c8dfd4c09098d29f8bd129d993e8a7788d61a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/091c8dfd4c09098d29f8bd129d993e8a7788d61a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/091c8dfd4c09098d29f8bd129d993e8a7788d61a"}], "stats": {"total": 246, "additions": 113, "deletions": 133}, "files": [{"sha": "9dd6853e6dfdb9ed147632b7aba4c89aaf57f720", "filename": "gcc/java/jcf-io.c", "status": "modified", "additions": 113, "deletions": 133, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/502f194fa0b65cb5e3bcd62e19567fa097176af3/gcc%2Fjava%2Fjcf-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/502f194fa0b65cb5e3bcd62e19567fa097176af3/gcc%2Fjava%2Fjcf-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-io.c?ref=502f194fa0b65cb5e3bcd62e19567fa097176af3", "patch": "@@ -29,11 +29,6 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #include <sys/stat.h>\n #include <sys/wait.h>\n \n-/* This is true if the user specified a `.java' file on the command\n-   line.  Otherwise it is 0.  FIXME: this is temporary, until our\n-   .java parser is fully working.  */\n-int saw_java_source = 0;\n-\n /* DOS brain-damage */\n #ifndef O_BINARY\n #define O_BINARY 0 /* MS-DOS brain-damage */\n@@ -94,56 +89,76 @@ DEFUN(jcf_filbuf_from_stdio, (jcf, count),\n \n struct ZipFileCache *SeenZipFiles = NULL;\n \n+/* Open a zip file with the given name, and cache directory and file\n+   descriptor.  If the file is missing, treat it as an empty archive.\n+   Return NULL if the .zip file is malformed.\n+*/\n+\n+ZipFile *\n+DEFUN(opendir_in_zip, (zipfile, is_system),\n+      const char *zipfile AND int is_system)\n+{\n+  struct ZipFileCache* zipf;\n+  char magic [4];\n+  int fd;\n+  for (zipf = SeenZipFiles;  zipf != NULL;  zipf = zipf->next)\n+    {\n+      if (strcmp (zipf->name, zipfile) == 0)\n+\treturn &zipf->z;\n+    }\n+\n+  zipf = ALLOC (sizeof (struct ZipFileCache) + strlen (zipfile) + 1);\n+  zipf->next = SeenZipFiles;\n+  zipf->name = (char*)(zipf+1);\n+  strcpy (zipf->name, zipfile);\n+  SeenZipFiles = zipf;\n+  fd = open (zipfile, O_RDONLY | O_BINARY);\n+  zipf->z.fd = fd;\n+  if (fd < 0)\n+    {\n+      /* A missing zip file is not considered an error.\n+       We may want to re-consider that.  FIXME. */\n+      zipf->z.count = 0;\n+      zipf->z.dir_size = 0;\n+      zipf->z.central_directory = NULL;\n+    }\n+  else\n+    {\n+      jcf_dependency_add_file (zipfile, is_system);\n+      if (read (fd, magic, 4) != 4 || GET_u4 (magic) != (JCF_u4)ZIPMAGIC)\n+\treturn NULL;\n+      lseek (fd, 0L, SEEK_SET);\n+      if (read_zip_archive (&zipf->z) != 0)\n+\treturn NULL;\n+    }\n+  return &zipf->z;\n+}\n+\n+/* Returns:\n+   0:  OK - zipmember found.\n+   -1: Not found.\n+   -2: Malformed archive.\n+*/\n+\n int\n-DEFUN(open_in_zip, (jcf, zipfile, zipmember),\n+DEFUN(open_in_zip, (jcf, zipfile, zipmember, is_system),\n       JCF *jcf AND const char *zipfile AND const char *zipmember\n       AND int is_system)\n {\n-  struct ZipFileCache* zipf;\n   ZipDirectory *zipd;\n   int i, len;\n-  for (zipf = SeenZipFiles; ; zipf = zipf->next)\n-    {\n-      if (zipf == NULL)\n-\t{\n-\t  char magic [4];\n-\t  int fd = open (zipfile, O_RDONLY | O_BINARY);\n-\t  jcf_dependency_add_file (zipfile, is_system);\n-\t  if (read (fd, magic, 4) != 4 || GET_u4 (magic) != (JCF_u4)ZIPMAGIC)\n-\t    return -1;\n-\t  lseek (fd, 0L, SEEK_SET);\n-\t  zipf = ALLOC (sizeof (struct ZipFileCache) + strlen (zipfile) + 1);\n-\t  zipf->next = SeenZipFiles;\n-\t  zipf->name = (char*)(zipf+1);\n-\t  strcpy (zipf->name, zipfile);\n-\t  SeenZipFiles = zipf;\n-\t  zipf->z.fd = fd;\n-\t  if (fd == -1)\n-\t    {\n-\t      /* A missing zip file is not considered an error. */\n-\t      zipf->z.count = 0;\n-\t      zipf->z.dir_size = 0;\n-\t      zipf->z.central_directory = NULL;\n-\t      return -1;\n-\t    }\n-\t  else\n-\t    {\n-\t      if (read_zip_archive (&zipf->z) != 0)\n-\t\treturn -2; /* This however should be an error - FIXME */\n-\t    }\n-\t  break;\n-\t}\n-      if (strcmp (zipf->name, zipfile) == 0)\n-\tbreak;\n-    }\n+  ZipFile *zipf = opendir_in_zip (zipfile, is_system);\n+\n+  if (zipf == NULL)\n+    return -2;\n \n   if (!zipmember)\n     return 0;\n \n   len = strlen (zipmember);\n   \n-  zipd = (struct ZipDirectory*) zipf->z.central_directory;\n-  for (i = 0; i < zipf->z.count; i++, zipd = ZIPDIR_NEXT (zipd))\n+  zipd = (struct ZipDirectory*) zipf->central_directory;\n+  for (i = 0; i < zipf->count; i++, zipd = ZIPDIR_NEXT (zipd))\n     {\n       if (len == zipd->filename_length &&\n \t  strncmp (ZIPDIR_FILENAME (zipd), zipmember, len) == 0)\n@@ -157,8 +172,8 @@ DEFUN(open_in_zip, (jcf, zipfile, zipmember),\n \t  jcf->filename = strdup (zipfile);\n \t  jcf->classname = strdup (zipmember);\n \t  jcf->zipd = (void *)zipd;\n-\t  if (lseek (zipf->z.fd, zipd->filestart, 0) < 0\n-\t      || read (zipf->z.fd, jcf->buffer, zipd->size) != zipd->size)\n+\t  if (lseek (zipf->fd, zipd->filestart, 0) < 0\n+\t      || read (zipf->fd, jcf->buffer, zipd->size) != zipd->size)\n \t    return -2;\n \t  return 0;\n \t}\n@@ -244,25 +259,23 @@ DEFUN(find_classfile, (filename, jcf, dep_name),\n \n /* Returns a freshly malloc'd string with the fully qualified pathname\n    of the .class file for the class CLASSNAME.  Returns NULL on\n-   failure.  If JCF != NULL, it is suitably initialized.  With\n-   DO_CLASS_FILE set to 1, search a .class/.java file named after\n-   CLASSNAME, otherwise, search a ZIP directory entry named after\n-   CLASSNAME.  */\n+   failure.  If JCF != NULL, it is suitably initialized.\n+   SOURCE_OK is true if we should also look for .java file. */\n \n char *\n-DEFUN(find_class, (classname, classname_length, jcf, do_class_file),\n-      const char *classname AND int classname_length AND JCF *jcf AND int do_class_file)\n+DEFUN(find_class, (classname, classname_length, jcf, source_ok),\n+      const char *classname AND int classname_length AND JCF *jcf AND int source_ok)\n \n {\n #if JCF_USE_STDIO\n   FILE *stream;\n #else\n   int fd;\n #endif\n-  int i, k, java, class = -1;\n+  int i, k, java = -1, class = -1;\n   struct stat java_buf, class_buf;\n   char *dep_file;\n-  void *entry, *java_entry;\n+  void *entry;\n   char *java_buffer;\n \n   /* Allocate and zero out the buffer, since we don't explicitly put a\n@@ -277,99 +290,66 @@ DEFUN(find_class, (classname, classname_length, jcf, do_class_file),\n \n   for (entry = jcf_path_start (); entry != NULL; entry = jcf_path_next (entry))\n     {\n-      int dir_len;\n+      char *path_name = jcf_path_name (entry);\n+      if (class != 0)\n+\t{\n+\t  int dir_len;\n \n-      strcpy (buffer, jcf_path_name (entry));\n-      i = strlen (buffer);\n+\t  strcpy (buffer, path_name);\n+\t  i = strlen (buffer);\n \n-      /* This is right because we know that `.zip' entries will have a\n-\t trailing slash.  See jcf-path.c.  */\n-      dir_len = i - 1;\n+\t  /* This is right because we know that `.zip' entries will have a\n+\t     trailing slash.  See jcf-path.c.  */\n+\t  dir_len = i - 1;\n \n-      for (k = 0; k < classname_length; k++, i++)\n-\t{\n-\t  char ch = classname[k];\n-\t  buffer[i] = ch == '.' ? '/' : ch;\n-\t}\n-      if (do_class_file)\n-\tstrcpy (buffer+i, \".class\");\n+\t  for (k = 0; k < classname_length; k++, i++)\n+\t    {\n+\t      char ch = classname[k];\n+\t      buffer[i] = ch == '.' ? '/' : ch;\n+\t    }\n+\t  strcpy (buffer+i, \".class\");\n \n-      if (jcf_path_is_zipfile (entry))\n-\t{\n-\t  int err_code;\n-\t  JCF _jcf;\n-\t  if (!do_class_file)\n-\t    strcpy (buffer+i, \"/\");\n-\t  buffer[dir_len] = '\\0';\n-\t  if (do_class_file)\n-\t    SOURCE_FRONTEND_DEBUG \n-\t      ((\"Trying [...%s]:%s\", \n-\t\t&buffer[dir_len-(dir_len > 15 ? 15 : dir_len)], \n-\t\tbuffer+dir_len+1));\n-\t  if (jcf == NULL)\n-\t    jcf = &_jcf;\n-\t  err_code = open_in_zip (jcf, buffer, buffer+dir_len+1,\n-\t\t\t\t  jcf_path_is_system (entry));\n-\t  if (err_code == 0)\n+\t  if (jcf_path_is_zipfile (entry))\n \t    {\n-\t      if (!do_class_file)\n-\t\tjcf->seen_in_zip = 1;\n-\t      else\n+\t      int err_code;\n+\t      JCF _jcf;\n+\t      buffer[dir_len] = '\\0';\n+\t      SOURCE_FRONTEND_DEBUG \n+\t\t((\"Trying [...%s]:%s\", \n+\t\t  &buffer[dir_len-(dir_len > 15 ? 15 : dir_len)], \n+\t\t  buffer+dir_len+1));\n+\t      if (jcf == NULL)\n+\t\tjcf = &_jcf;\n+\t      err_code = open_in_zip (jcf, buffer, buffer+dir_len+1,\n+\t\t\t\t      jcf_path_is_system (entry));\n+\t      if (err_code == 0)\n \t\t{\n+\t\t  /* Should we check if .zip is out-of-date wrt .java? */\n \t\t  buffer[dir_len] = '(';\n \t\t  strcpy (buffer+i, \".class)\");\n+\t\t  if (jcf == &_jcf)\n+\t\t    JCF_FINISH (jcf);\n+\t\t  return buffer;\n \t\t}\n-\t      if (jcf == &_jcf)\n-\t\tJCF_FINISH (jcf);\n-\t      return buffer;\n+\t      else\n+\t\tcontinue;\n \t    }\n-\t  else\n-\t    continue;\n+\t  class = stat (buffer, &class_buf);\n \t}\n \n-      /* If we do directories, do them here */\n-      if (!do_class_file)\n+      if (source_ok)\n \t{\n-\t  struct stat dir_buff;\n-\t  int dir;\n-\t  buffer[i] = '\\0';\t/* Was previously unterminated here. */\n-\t  if (!(dir = stat (buffer, &dir_buff)))\n-\t    {\n-\t      jcf->seen_in_zip = 0;\n-\t      goto found;\n-\t    }\n+\t  /* Compute name of .java file.  */\n+\t  int l, m;\n+\t  strcpy (java_buffer, path_name);\n+\t  l = strlen (java_buffer);\n+\t  for (m = 0; m < classname_length; ++m)\n+\t    java_buffer[m + l] = (classname[m] == '.' ? '/' : classname[m]);\n+\t  strcpy (java_buffer + m + l, \".java\");\n+\t  java = stat (java_buffer, &java_buf);\n+\t  if (java == 0)\n+\t    break;\n \t}\n-\n-      class = stat (buffer, &class_buf);\n-      if (class == 0)\n-\tbreak;\n-    }\n-\n-  /* Check for out of synch .class/.java files.  */\n-  java = 1;\n-  for (java_entry = jcf_path_start ();\n-       java && java_entry != NULL;\n-       java_entry = jcf_path_next (java_entry))\n-    {\n-      int m, l;\n-\n-      if (jcf_path_is_zipfile (java_entry))\n-\tcontinue;\n-\n-      /* Compute name of .java file.  */\n-      strcpy (java_buffer, jcf_path_name (java_entry));\n-      l = strlen (java_buffer);\n-      for (m = 0; m < classname_length; ++m)\n-\tjava_buffer[m + l] = (classname[m] == '.' ? '/' : classname[m]);\n-      strcpy (java_buffer + m + l, \".java\");\n-\n-      /* FIXME: until the `.java' parser is fully working, we only\n-\t look for a .java file when one was mentioned on the\n-\t command line.  This lets us test the .java parser fairly\n-\t easily, without compromising our ability to use the\n-\t .class parser without fear.  */\n-      if (saw_java_source)\n-\tjava = stat (java_buffer, &java_buf);\n     }\n \n   if (! java && ! class && java_buf.st_mtime >= class_buf.st_mtime)\n@@ -437,7 +417,7 @@ DEFUN(find_class, (classname, classname_length, jcf, do_class_file),\n       jcf->filename = (char *) strdup (buffer);\n       close (fd);\t\t/* We use STDIO for source file */\n     }\n-  else if (do_class_file)\n+  else\n     buffer = open_class (buffer, jcf, fd, dep_file);\n   jcf->classname = (char *) ALLOC (classname_length + 1);\n   strncpy (jcf->classname, classname, classname_length + 1);"}]}