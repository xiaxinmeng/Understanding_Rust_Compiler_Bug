{"sha": "4376b7cf2b7d906c1952205ec3242e689f84f671", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDM3NmI3Y2YyYjdkOTA2YzE5NTIyMDVlYzMyNDJlNjg5Zjg0ZjY3MQ==", "commit": {"author": {"name": "Francois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2007-08-29T12:44:32Z"}, "committer": {"name": "Fran\u00e7ois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2007-08-29T12:44:32Z"}, "message": "builtin-types.def (BT_FN_PTR_PTR_SIZE): New type.\n\n\t* builtin-types.def (BT_FN_PTR_PTR_SIZE): New type.\n\t* builtins.def (BUILT_IN_REALLOC): New builtin.\n\n\t* trans-array.c (gfc_grow_array): Use gfc_call_realloc.\n\t(gfc_array_allocate): Use gfc_allocate_with_status and\n\tgfc_allocate_array_with_status.\n\t(gfc_array_deallocate): Use gfc_deallocate_with_status.\n\t(gfc_trans_dealloc_allocated): Use gfc_deallocate_with_status.\n\t* trans-stmt.c (gfc_trans_allocate): Use gfc_allocate_with_status.\n\t(gfc_trans_deallocate): Use gfc_deallocate_with_status.\n\t* trans.c (gfc_allocate_with_status, gfc_allocate_array_with_status,\n\tgfc_deallocate_with_status, gfc_call_realloc): New functions.\n\t* trans.h (gfc_allocate_with_status, gfc_allocate_array_with_status,\n\tgfc_deallocate_with_status, gfc_call_realloc): New prototypes.\n\t(gfor_fndecl_internal_realloc, gfor_fndecl_allocate,\n\tgfor_fndecl_allocate_array, gfor_fndecl_deallocate): Remove.\n\t* f95-lang.c (gfc_init_builtin_functions): Create decl for\n\tBUILT_IN_REALLOC.\n\t* trans-decl.c (gfor_fndecl_internal_realloc,\n\tgfor_fndecl_allocate, gfor_fndecl_allocate_array,\n\tgfor_fndecl_deallocate): Remove function decls.\n\t(gfc_build_builtin_function_decls): Likewise.\n\n\t* runtime/memory.c (internal_realloc, allocate, allocate_array,\n\tdeallocate): Remove functions.\n\t* gfortran.map (_gfortran_allocate, _gfortran_allocate_array,\n\t_gfortran_deallocate, _gfortran_internal_realloc): Remove symbols.\n\t* libgfortran.h (error_codes): Add comment.\n\n\t* gfortran.dg/alloc_comp_basics_1.f90: Update check.\n\t* gfortran.dg/alloc_comp_constructor_1.f90: Update check.\n\nFrom-SVN: r127897", "tree": {"sha": "01404bd7b2cf9f1674f08538ac495ecf3cd28d04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/01404bd7b2cf9f1674f08538ac495ecf3cd28d04"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4376b7cf2b7d906c1952205ec3242e689f84f671", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4376b7cf2b7d906c1952205ec3242e689f84f671", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4376b7cf2b7d906c1952205ec3242e689f84f671", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4376b7cf2b7d906c1952205ec3242e689f84f671/comments", "author": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "31fa49984f6d6b2a6f90296867004265ea395e07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31fa49984f6d6b2a6f90296867004265ea395e07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31fa49984f6d6b2a6f90296867004265ea395e07"}], "stats": {"total": 657, "additions": 452, "deletions": 205}, "files": [{"sha": "c649ee24f2be04b689e79433b749d13b0cef2f09", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4376b7cf2b7d906c1952205ec3242e689f84f671/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4376b7cf2b7d906c1952205ec3242e689f84f671/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4376b7cf2b7d906c1952205ec3242e689f84f671", "patch": "@@ -1,3 +1,8 @@\n+2007-08-29  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\t* gcc/builtin-types.def (BT_FN_PTR_PTR_SIZE): New type.\n+\t* gcc/builtins.def (BUILT_IN_REALLOC): New builtin.\n+\n 2007-08-29  Douglas Gregor  <doug.gregor@gmail.com>\n \n \tPR c++/33194"}, {"sha": "081a33f04674d26f49021c08de1963a88d67ce7f", "filename": "gcc/builtin-types.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4376b7cf2b7d906c1952205ec3242e689f84f671/gcc%2Fbuiltin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4376b7cf2b7d906c1952205ec3242e689f84f671/gcc%2Fbuiltin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltin-types.def?ref=4376b7cf2b7d906c1952205ec3242e689f84f671", "patch": "@@ -289,6 +289,8 @@ DEF_FUNCTION_TYPE_2 (BT_FN_INT_CONST_STRING_VALIST_ARG,\n \t\t     BT_INT, BT_CONST_STRING, BT_VALIST_ARG)\n DEF_FUNCTION_TYPE_2 (BT_FN_PTR_SIZE_SIZE,\n \t\t     BT_PTR, BT_SIZE, BT_SIZE)\n+DEF_FUNCTION_TYPE_2 (BT_FN_PTR_PTR_SIZE,\n+\t\t     BT_PTR, BT_PTR, BT_SIZE)\n DEF_FUNCTION_TYPE_2 (BT_FN_COMPLEX_FLOAT_COMPLEX_FLOAT_COMPLEX_FLOAT,\n \t\t     BT_COMPLEX_FLOAT, BT_COMPLEX_FLOAT, BT_COMPLEX_FLOAT)\n DEF_FUNCTION_TYPE_2 (BT_FN_COMPLEX_DOUBLE_COMPLEX_DOUBLE_COMPLEX_DOUBLE,"}, {"sha": "8bedfbf30e93f3a251602cd015a4f7647b3e45bc", "filename": "gcc/builtins.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4376b7cf2b7d906c1952205ec3242e689f84f671/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4376b7cf2b7d906c1952205ec3242e689f84f671/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=4376b7cf2b7d906c1952205ec3242e689f84f671", "patch": "@@ -687,6 +687,7 @@ DEF_GCC_BUILTIN        (BUILT_IN_POPCOUNTIMAX, \"popcountimax\", BT_FN_INT_UINTMAX\n DEF_GCC_BUILTIN        (BUILT_IN_POPCOUNTL, \"popcountl\", BT_FN_INT_ULONG, ATTR_CONST_NOTHROW_LIST)\n DEF_GCC_BUILTIN        (BUILT_IN_POPCOUNTLL, \"popcountll\", BT_FN_INT_ULONGLONG, ATTR_CONST_NOTHROW_LIST)\n DEF_GCC_BUILTIN        (BUILT_IN_PREFETCH, \"prefetch\", BT_FN_VOID_CONST_PTR_VAR, ATTR_NOVOPS_LIST)\n+DEF_LIB_BUILTIN        (BUILT_IN_REALLOC, \"realloc\", BT_FN_PTR_PTR_SIZE, ATTR_NOTHROW_LIST)\n DEF_GCC_BUILTIN        (BUILT_IN_RETURN, \"return\", BT_FN_VOID_PTR, ATTR_NORETURN_NOTHROW_LIST)\n DEF_GCC_BUILTIN        (BUILT_IN_RETURN_ADDRESS, \"return_address\", BT_FN_PTR_UINT, ATTR_NULL)\n DEF_GCC_BUILTIN        (BUILT_IN_SAVEREGS, \"saveregs\", BT_FN_PTR_VAR, ATTR_NULL)"}, {"sha": "b523e8aa0071812d29b150d2466a4e10690433b1", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4376b7cf2b7d906c1952205ec3242e689f84f671/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4376b7cf2b7d906c1952205ec3242e689f84f671/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=4376b7cf2b7d906c1952205ec3242e689f84f671", "patch": "@@ -1,3 +1,25 @@\n+2007-08-29  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\t* trans-array.c (gfc_grow_array): Use gfc_call_realloc.\n+\t(gfc_array_allocate): Use gfc_allocate_with_status and\n+\tgfc_allocate_array_with_status.\n+\t(gfc_array_deallocate): Use gfc_deallocate_with_status.\n+\t(gfc_trans_dealloc_allocated): Use gfc_deallocate_with_status.\n+\t* trans-stmt.c (gfc_trans_allocate): Use gfc_allocate_with_status.\n+\t(gfc_trans_deallocate): Use gfc_deallocate_with_status.\n+\t* trans.c (gfc_allocate_with_status, gfc_allocate_array_with_status,\n+\tgfc_deallocate_with_status, gfc_call_realloc): New functions.\n+\t* trans.h (gfc_allocate_with_status, gfc_allocate_array_with_status,\n+\tgfc_deallocate_with_status, gfc_call_realloc): New prototypes.\n+\t(gfor_fndecl_internal_realloc, gfor_fndecl_allocate,\n+\tgfor_fndecl_allocate_array, gfor_fndecl_deallocate): Remove.\n+\t* f95-lang.c (gfc_init_builtin_functions): Create decl for\n+\tBUILT_IN_REALLOC.\n+\t* trans-decl.c (gfor_fndecl_internal_realloc,\n+\tgfor_fndecl_allocate, gfor_fndecl_allocate_array,\n+\tgfor_fndecl_deallocate): Remove function decls.\n+\t(gfc_build_builtin_function_decls): Likewise.\n+\n 2007-08-28  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR fortran/33055"}, {"sha": "05f6750218db3141f63fd69f46ecad895443e4de", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4376b7cf2b7d906c1952205ec3242e689f84f671/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4376b7cf2b7d906c1952205ec3242e689f84f671/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=4376b7cf2b7d906c1952205ec3242e689f84f671", "patch": "@@ -1036,6 +1036,12 @@ gfc_init_builtin_functions (void)\n \t\t      \"malloc\", false);\n   DECL_IS_MALLOC (built_in_decls[BUILT_IN_MALLOC]) = 1;\n \n+  tmp = tree_cons (NULL_TREE, pvoid_type_node, void_list_node);\n+  tmp = tree_cons (NULL_TREE, size_type_node, tmp);\n+  ftype = build_function_type (pvoid_type_node, tmp);\n+  gfc_define_builtin (\"__builtin_realloc\", ftype, BUILT_IN_REALLOC,\n+\t\t      \"realloc\", false);\n+\n   tmp = tree_cons (NULL_TREE, void_type_node, void_list_node);\n   ftype = build_function_type (integer_type_node, tmp);\n   gfc_define_builtin (\"__builtin_isnan\", ftype, BUILT_IN_ISNAN,"}, {"sha": "09d20cd42913905ef7c96a03001c3bd570bb230d", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 9, "deletions": 30, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4376b7cf2b7d906c1952205ec3242e689f84f671/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4376b7cf2b7d906c1952205ec3242e689f84f671/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=4376b7cf2b7d906c1952205ec3242e689f84f671", "patch": "@@ -843,17 +843,11 @@ gfc_grow_array (stmtblock_t * pblock, tree desc, tree extra)\n   /* Calculate the new array size.  */\n   size = TYPE_SIZE_UNIT (gfc_get_element_type (TREE_TYPE (desc)));\n   tmp = build2 (PLUS_EXPR, gfc_array_index_type, ubound, gfc_index_one_node);\n-  arg1 = build2 (MULT_EXPR, gfc_array_index_type, tmp,\n-\t\t fold_convert (gfc_array_index_type, size));\n+  arg1 = build2 (MULT_EXPR, size_type_node, fold_convert (size_type_node, tmp),\n+\t\t fold_convert (size_type_node, size));\n \n-  /* Pick the realloc function.  */\n-  if (gfc_index_integer_kind == 4 || gfc_index_integer_kind == 8)\n-    tmp = gfor_fndecl_internal_realloc;\n-  else\n-    gcc_unreachable ();\n-\n-  /* Set the new data pointer.  */\n-  tmp = build_call_expr (tmp, 2, arg0, arg1);\n+  /* Call the realloc() function.  */\n+  tmp = gfc_call_realloc (pblock, arg0, arg1);\n   gfc_conv_descriptor_data_set (pblock, desc, tmp);\n }\n \n@@ -3571,7 +3565,6 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree pstat)\n {\n   tree tmp;\n   tree pointer;\n-  tree allocate;\n   tree offset;\n   tree size;\n   gfc_expr **lower;\n@@ -3629,22 +3622,11 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree pstat)\n   pointer = gfc_conv_descriptor_data_get (se->expr);\n   STRIP_NOPS (pointer);\n \n-  if (TYPE_PRECISION (gfc_array_index_type) == 32 ||\n-      TYPE_PRECISION (gfc_array_index_type) == 64)\n-    {\n-      if (allocatable_array)\n-\tallocate = gfor_fndecl_allocate_array;\n-      else\n-\tallocate = gfor_fndecl_allocate;\n-    }\n-  else\n-    gcc_unreachable ();\n-\n   /* The allocate_array variants take the old pointer as first argument.  */\n   if (allocatable_array)\n-    tmp = build_call_expr (allocate, 3, pointer, size, pstat);\n+    tmp = gfc_allocate_array_with_status (&se->pre, pointer, size, pstat);\n   else\n-    tmp = build_call_expr (allocate, 2, size, pstat);\n+    tmp = gfc_allocate_with_status (&se->pre, size, pstat);\n   tmp = build2 (MODIFY_EXPR, void_type_node, pointer, tmp);\n   gfc_add_expr_to_block (&se->pre, tmp);\n \n@@ -3680,7 +3662,7 @@ gfc_array_deallocate (tree descriptor, tree pstat)\n   STRIP_NOPS (var);\n \n   /* Parameter is the address of the data component.  */\n-  tmp = build_call_expr (gfor_fndecl_deallocate, 2, var, pstat);\n+  tmp = gfc_deallocate_with_status (var, pstat, false);\n   gfc_add_expr_to_block (&block, tmp);\n \n   /* Zero the data pointer.  */\n@@ -4998,21 +4980,18 @@ tree\n gfc_trans_dealloc_allocated (tree descriptor)\n { \n   tree tmp;\n-  tree ptr;\n   tree var;\n   stmtblock_t block;\n \n   gfc_start_block (&block);\n \n   var = gfc_conv_descriptor_data_get (descriptor);\n   STRIP_NOPS (var);\n-  tmp = gfc_create_var (gfc_array_index_type, NULL);\n-  ptr = build_fold_addr_expr (tmp);\n \n-  /* Call array_deallocate with an int* present in the second argument.\n+  /* Call array_deallocate with an int * present in the second argument.\n      Although it is ignored here, it's presence ensures that arrays that\n      are already deallocated are ignored.  */\n-  tmp = build_call_expr (gfor_fndecl_deallocate, 2, var, ptr);\n+  tmp = gfc_deallocate_with_status (var, NULL_TREE, true);\n   gfc_add_expr_to_block (&block, tmp);\n \n   /* Zero the data pointer.  */"}, {"sha": "8ea25fc253290ff5495ce0937a6701ed6fdf39d6", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4376b7cf2b7d906c1952205ec3242e689f84f671/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4376b7cf2b7d906c1952205ec3242e689f84f671/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=4376b7cf2b7d906c1952205ec3242e689f84f671", "patch": "@@ -73,10 +73,6 @@ tree gfc_static_ctors;\n \n /* Function declarations for builtin library functions.  */\n \n-tree gfor_fndecl_internal_realloc;\n-tree gfor_fndecl_allocate;\n-tree gfor_fndecl_allocate_array;\n-tree gfor_fndecl_deallocate;\n tree gfor_fndecl_pause_numeric;\n tree gfor_fndecl_pause_string;\n tree gfor_fndecl_stop_numeric;\n@@ -2273,35 +2269,10 @@ void\n gfc_build_builtin_function_decls (void)\n {\n   tree gfc_int4_type_node = gfc_get_int_type (4);\n-  tree gfc_pint4_type_node = build_pointer_type (gfc_int4_type_node);\n-\n-  gfor_fndecl_internal_realloc =\n-    gfc_build_library_function_decl (get_identifier\n-\t\t\t\t     (PREFIX(\"internal_realloc\")),\n-\t\t\t\t     pvoid_type_node, 2, pvoid_type_node,\n-\t\t\t\t     gfc_array_index_type);\n-\n-  gfor_fndecl_allocate =\n-    gfc_build_library_function_decl (get_identifier (PREFIX(\"allocate\")),\n-\t\t\t\t     pvoid_type_node, 2,\n-\t\t\t\t     gfc_array_index_type, gfc_pint4_type_node);\n-  DECL_IS_MALLOC (gfor_fndecl_allocate) = 1;\n-\n-  gfor_fndecl_allocate_array =\n-    gfc_build_library_function_decl (get_identifier (PREFIX(\"allocate_array\")),\n-\t\t\t\t     pvoid_type_node, 3, pvoid_type_node,\n-\t\t\t\t     gfc_array_index_type, gfc_pint4_type_node);\n-  DECL_IS_MALLOC (gfor_fndecl_allocate_array) = 1;\n-\n-  gfor_fndecl_deallocate =\n-    gfc_build_library_function_decl (get_identifier (PREFIX(\"deallocate\")),\n-\t\t\t\t     void_type_node, 2, pvoid_type_node,\n-\t\t\t\t     gfc_pint4_type_node);\n \n   gfor_fndecl_stop_numeric =\n     gfc_build_library_function_decl (get_identifier (PREFIX(\"stop_numeric\")),\n \t\t\t\t     void_type_node, 1, gfc_int4_type_node);\n-\n   /* Stop doesn't return.  */\n   TREE_THIS_VOLATILE (gfor_fndecl_stop_numeric) = 1;\n "}, {"sha": "f900ec52f4b3914525bd9a086d9d0c8786baa59c", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4376b7cf2b7d906c1952205ec3242e689f84f671/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4376b7cf2b7d906c1952205ec3242e689f84f671/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=4376b7cf2b7d906c1952205ec3242e689f84f671", "patch": "@@ -3565,11 +3565,7 @@ gfc_trans_allocate (gfc_code * code)\n       TREE_USED (error_label) = 1;\n     }\n   else\n-    {\n-      pstat = integer_zero_node;\n-      stat = error_label = NULL_TREE;\n-    }\n-\n+    pstat = stat = error_label = NULL_TREE;\n \n   for (al = code->ext.alloc_list; al != NULL; al = al->next)\n     {\n@@ -3590,7 +3586,7 @@ gfc_trans_allocate (gfc_code * code)\n \t  if (expr->ts.type == BT_CHARACTER && tmp == NULL_TREE)\n \t    tmp = se.string_length;\n \n-\t  tmp = build_call_expr (gfor_fndecl_allocate, 2, tmp, pstat);\n+\t  tmp = gfc_allocate_with_status (&se.pre, tmp, pstat);\n \t  tmp = build2 (MODIFY_EXPR, void_type_node, se.expr,\n \t\t\tfold_convert (TREE_TYPE (se.expr), tmp));\n \t  gfc_add_expr_to_block (&se.pre, tmp);\n@@ -3679,10 +3675,7 @@ gfc_trans_deallocate (gfc_code * code)\n       gfc_add_modify_expr (&block, astat, build_int_cst (TREE_TYPE (astat), 0));\n     }\n   else\n-    {\n-      pstat = apstat = null_pointer_node;\n-      stat = astat = NULL_TREE;\n-    }\n+    pstat = apstat = stat = astat = NULL_TREE;\n \n   for (al = code->ext.alloc_list; al != NULL; al = al->next)\n     {\n@@ -3720,7 +3713,7 @@ gfc_trans_deallocate (gfc_code * code)\n \ttmp = gfc_array_deallocate (se.expr, pstat);\n       else\n \t{\n-\t  tmp = build_call_expr (gfor_fndecl_deallocate, 2, se.expr, pstat);\n+\t  tmp = gfc_deallocate_with_status (se.expr, pstat, false);\n \t  gfc_add_expr_to_block (&se.pre, tmp);\n \n \t  tmp = build2 (MODIFY_EXPR, void_type_node,"}, {"sha": "1113e80fdc3c69e08947289ee1e0eb44a1c113fc", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 373, "deletions": 0, "changes": 373, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4376b7cf2b7d906c1952205ec3242e689f84f671/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4376b7cf2b7d906c1952205ec3242e689f84f671/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=4376b7cf2b7d906c1952205ec3242e689f84f671", "patch": "@@ -473,6 +473,222 @@ gfc_call_malloc (stmtblock_t * block, tree type, tree size)\n   return res;\n }\n \n+/* The status variable of allocate statement is set to ERROR_ALLOCATION \n+   when the allocation wasn't successful. This value needs to be kept in\n+   sync with libgfortran/libgfortran.h.  */\n+#define ERROR_ALLOCATION 5014\n+\n+/* Allocate memory, using an optional status argument.\n+ \n+   This function follows the following pseudo-code:\n+\n+    void *\n+    allocate (size_t size, integer_type* stat)\n+    {\n+      void *newmem;\n+    \n+      if (stat)\n+        *stat = 0;\n+\n+      // The only time this can happen is the size wraps around.\n+      if (size < 0)\n+      {\n+        if (stat)\n+        {\n+          *stat = ERROR_ALLOCATION;\n+          newmem = NULL;\n+        }\n+        else\n+          runtime_error (\"Attempt to allocate negative amount of memory. \"\n+                         \"Possible integer overflow\");\n+      }\n+      else\n+      {\n+        newmem = malloc (MAX (size, 1));\n+        if (newmem == NULL)\n+        {\n+          if (stat)\n+            *stat = ERROR_ALLOCATION;\n+          else\n+            runtime_error (\"Out of memory\");\n+        }\n+      }\n+\n+      return newmem;\n+    }  */\n+tree\n+gfc_allocate_with_status (stmtblock_t * block, tree size, tree status)\n+{\n+  stmtblock_t alloc_block;\n+  tree res, tmp, error, msg, cond;\n+  tree status_type = status ? TREE_TYPE (TREE_TYPE (status)) : NULL_TREE;\n+\n+  /* Evaluate size only once, and make sure it has the right type.  */\n+  size = gfc_evaluate_now (size, block);\n+  if (TREE_TYPE (size) != TREE_TYPE (size_type_node))\n+    size = fold_convert (size_type_node, size);\n+\n+  /* Create a variable to hold the result.  */\n+  res = gfc_create_var (pvoid_type_node, NULL);\n+\n+  /* Set the optional status variable to zero.  */\n+  if (status != NULL_TREE && !integer_zerop (status))\n+    {\n+      tmp = fold_build2 (MODIFY_EXPR, status_type,\n+\t\t\t build1 (INDIRECT_REF, status_type, status),\n+\t\t\t build_int_cst (status_type, 0));\n+      tmp = fold_build3 (COND_EXPR, void_type_node,\n+\t\t\t fold_build2 (NE_EXPR, boolean_type_node,\n+\t\t\t\t      status, build_int_cst (status_type, 0)),\n+\t\t\t tmp, build_empty_stmt ());\n+      gfc_add_expr_to_block (block, tmp);\n+    }\n+\n+  /* Generate the block of code handling (size < 0).  */\n+  msg = gfc_build_addr_expr (pchar_type_node, gfc_build_cstring_const\n+\t\t\t(\"Attempt to allocate negative amount of memory. \"\n+\t\t\t \"Possible integer overflow\"));\n+  error = build_call_expr (gfor_fndecl_runtime_error, 1, msg);\n+\n+  if (status != NULL_TREE && !integer_zerop (status))\n+    {\n+      /* Set the status variable if it's present.  */\n+      stmtblock_t set_status_block;\n+\n+      gfc_start_block (&set_status_block);\n+      gfc_add_modify_expr (&set_status_block,\n+\t\t\t   build1 (INDIRECT_REF, status_type, status),\n+\t\t\t   build_int_cst (status_type, ERROR_ALLOCATION));\n+      gfc_add_modify_expr (&set_status_block, res,\n+\t\t\t   build_int_cst (pvoid_type_node, 0));\n+\n+      tmp = fold_build2 (EQ_EXPR, boolean_type_node, status,\n+\t\t\t build_int_cst (status_type, 0));\n+      error = fold_build3 (COND_EXPR, void_type_node, tmp, error,\n+\t\t\t   gfc_finish_block (&set_status_block));\n+    }\n+\n+  /* The allocation itself.  */\n+  gfc_start_block (&alloc_block);\n+  gfc_add_modify_expr (&alloc_block, res,\n+\t\t       build_call_expr (built_in_decls[BUILT_IN_MALLOC], 1,\n+\t\t\t\t\tfold_build2 (MAX_EXPR, size_type_node,\n+\t\t\t\t\t\t     size,\n+\t\t\t\t\t\t     build_int_cst (size_type_node, 1))));\n+\n+  msg = gfc_build_addr_expr (pchar_type_node,\n+\t\t\t     gfc_build_cstring_const (\"Out of memory\"));\n+  tmp = build_call_expr (gfor_fndecl_os_error, 1, msg);\n+\n+  if (status != NULL_TREE && !integer_zerop (status))\n+    {\n+      /* Set the status variable if it's present.  */\n+      tree tmp2;\n+\n+      cond = fold_build2 (EQ_EXPR, boolean_type_node, status,\n+\t\t\t  build_int_cst (status_type, 0));\n+      tmp2 = fold_build2 (MODIFY_EXPR, status_type,\n+\t\t\t  build1 (INDIRECT_REF, status_type, status),\n+\t\t\t  build_int_cst (status_type, ERROR_ALLOCATION));\n+      tmp = fold_build3 (COND_EXPR, void_type_node, cond, tmp,\n+\t\t\t tmp2);\n+    }\n+\n+  tmp = fold_build3 (COND_EXPR, void_type_node,\n+\t\t     fold_build2 (EQ_EXPR, boolean_type_node, res,\n+\t\t\t\t  build_int_cst (pvoid_type_node, 0)),\n+\t\t     tmp, build_empty_stmt ());\n+  gfc_add_expr_to_block (&alloc_block, tmp);\n+\n+  cond = fold_build2 (LT_EXPR, boolean_type_node, size,\n+\t\t      build_int_cst (TREE_TYPE (size), 0));\n+  tmp = fold_build3 (COND_EXPR, void_type_node, cond, error,\n+\t\t     gfc_finish_block (&alloc_block));\n+  gfc_add_expr_to_block (block, tmp);\n+\n+  return res;\n+}\n+\n+\n+/* Generate code for an ALLOCATE statement when the argument is an\n+   allocatable array.  If the array is currently allocated, it is an\n+   error to allocate it again.\n+ \n+   This function follows the following pseudo-code:\n+  \n+    void *\n+    allocate_array (void *mem, size_t size, integer_type *stat)\n+    {\n+      if (mem == NULL)\n+\treturn allocate (size, stat);\n+      else\n+      {\n+\tif (stat)\n+\t{\n+\t  free (mem);\n+\t  mem = allocate (size, stat);\n+\t  *stat = ERROR_ALLOCATION;\n+\t  return mem;\n+\t}\n+\telse\n+\t  runtime_error (\"Attempting to allocate already allocated array\");\n+    }  */\n+tree\n+gfc_allocate_array_with_status (stmtblock_t * block, tree mem, tree size,\n+\t\t\t\ttree status)\n+{\n+  stmtblock_t alloc_block;\n+  tree res, tmp, null_mem, alloc, error, msg;\n+  tree type = TREE_TYPE (mem);\n+\n+  if (TREE_TYPE (size) != TREE_TYPE (size_type_node))\n+    size = fold_convert (size_type_node, size);\n+\n+  /* Create a variable to hold the result.  */\n+  res = gfc_create_var (pvoid_type_node, NULL);\n+  null_mem = fold_build2 (EQ_EXPR, boolean_type_node, mem,\n+\t\t\t  build_int_cst (type, 0));\n+\n+  /* If mem is NULL, we call gfc_allocate_with_status.  */\n+  gfc_start_block (&alloc_block);\n+  tmp = gfc_allocate_with_status (&alloc_block, size, status);\n+  gfc_add_modify_expr (&alloc_block, res, fold_convert (type, tmp));\n+  alloc = gfc_finish_block (&alloc_block);\n+\n+  /* Otherwise, we issue a runtime error or set the status variable.  */\n+  msg = gfc_build_addr_expr (pchar_type_node, gfc_build_cstring_const\n+\t\t\t(\"Attempting to allocate already allocated array\"));\n+  error = build_call_expr (gfor_fndecl_runtime_error, 1, msg);\n+\n+  if (status != NULL_TREE && !integer_zerop (status))\n+    {\n+      tree status_type = TREE_TYPE (TREE_TYPE (status));\n+      stmtblock_t set_status_block;\n+\n+      gfc_start_block (&set_status_block);\n+      tmp = build_call_expr (built_in_decls[BUILT_IN_FREE], 1,\n+\t\t\t     fold_convert (pvoid_type_node, mem));\n+      gfc_add_expr_to_block (&set_status_block, tmp);\n+\n+      tmp = gfc_allocate_with_status (&set_status_block, size, status);\n+      gfc_add_modify_expr (&set_status_block, res, fold_convert (type, tmp));\n+\n+      gfc_add_modify_expr (&set_status_block,\n+\t\t\t   build1 (INDIRECT_REF, status_type, status),\n+\t\t\t   build_int_cst (status_type, ERROR_ALLOCATION));\n+\n+      tmp = fold_build2 (EQ_EXPR, boolean_type_node, status,\n+\t\t\t build_int_cst (status_type, 0));\n+      error = fold_build3 (COND_EXPR, void_type_node, tmp, error,\n+\t\t\t   gfc_finish_block (&set_status_block));\n+    }\n+\n+  tmp = fold_build3 (COND_EXPR, void_type_node, null_mem, alloc, error);\n+  gfc_add_expr_to_block (block, tmp);\n+\n+  return res;\n+}\n+\n \n /* Free a given variable, if it's not NULL.  */\n tree\n@@ -497,6 +713,163 @@ gfc_call_free (tree var)\n }\n \n \n+\n+/* User-deallocate; we emit the code directly from the front-end, and the\n+   logic is the same as the previous library function:\n+\n+    void\n+    deallocate (void *pointer, GFC_INTEGER_4 * stat)\n+    {\n+      if (!pointer)\n+\t{\n+\t  if (stat)\n+\t    *stat = 1;\n+\t  else\n+\t    runtime_error (\"Attempt to DEALLOCATE unallocated memory.\");\n+\t}\n+      else\n+\t{\n+\t  free (pointer);\n+\t  if (stat)\n+\t    *stat = 0;\n+\t}\n+    }\n+\n+   In this front-end version, status doesn't have to be GFC_INTEGER_4.\n+   Moreover, if CAN_FAIL is true, then we will not emit a runtime error,\n+   even when no status variable is passed to us (this is used for\n+   unconditional deallocation generated by the front-end at end of\n+   each procedure).  */\n+tree\n+gfc_deallocate_with_status (tree pointer, tree status, bool can_fail)\n+{\n+  stmtblock_t null, non_null;\n+  tree cond, tmp, error, msg;\n+\n+  cond = fold_build2 (EQ_EXPR, boolean_type_node, pointer,\n+\t\t      build_int_cst (TREE_TYPE (pointer), 0));\n+\n+  /* When POINTER is NULL, we set STATUS to 1 if it's present, otherwise\n+     we emit a runtime error.  */\n+  gfc_start_block (&null);\n+  if (!can_fail)\n+    {\n+      msg = gfc_build_addr_expr (pchar_type_node, gfc_build_cstring_const\n+\t\t\t(\"Attempt to DEALLOCATE unallocated memory.\"));\n+      error = build_call_expr (gfor_fndecl_runtime_error, 1, msg);\n+    }\n+  else\n+    error = build_empty_stmt ();\n+\n+  if (status != NULL_TREE && !integer_zerop (status))\n+    {\n+      tree status_type = TREE_TYPE (TREE_TYPE (status));\n+      tree cond2;\n+\n+      cond2 = fold_build2 (NE_EXPR, boolean_type_node, status,\n+\t\t\t   build_int_cst (TREE_TYPE (status), 0));\n+      tmp = fold_build2 (MODIFY_EXPR, status_type,\n+\t\t\t build1 (INDIRECT_REF, status_type, status),\n+\t\t\t build_int_cst (status_type, 1));\n+      error = fold_build3 (COND_EXPR, void_type_node, cond2, tmp, error);\n+    }\n+\n+  gfc_add_expr_to_block (&null, error);\n+\n+  /* When POINTER is not NULL, we free it.  */\n+  gfc_start_block (&non_null);\n+  tmp = build_call_expr (built_in_decls[BUILT_IN_FREE], 1,\n+\t\t\t fold_convert (pvoid_type_node, pointer));\n+  gfc_add_expr_to_block (&non_null, tmp);\n+\n+  if (status != NULL_TREE && !integer_zerop (status))\n+    {\n+      /* We set STATUS to zero if it is present.  */\n+      tree status_type = TREE_TYPE (TREE_TYPE (status));\n+      tree cond2;\n+\n+      cond2 = fold_build2 (NE_EXPR, boolean_type_node, status,\n+\t\t\t   build_int_cst (TREE_TYPE (status), 0));\n+      tmp = fold_build2 (MODIFY_EXPR, status_type,\n+\t\t\t build1 (INDIRECT_REF, status_type, status),\n+\t\t\t build_int_cst (status_type, 0));\n+      tmp = fold_build3 (COND_EXPR, void_type_node, cond2, tmp,\n+\t\t\t build_empty_stmt ());\n+      gfc_add_expr_to_block (&non_null, tmp);\n+    }\n+\n+  return fold_build3 (COND_EXPR, void_type_node, cond,\n+\t\t      gfc_finish_block (&null), gfc_finish_block (&non_null));\n+}\n+\n+\n+/* Reallocate MEM so it has SIZE bytes of data.  This behaves like the\n+   following pseudo-code:\n+\n+void *\n+internal_realloc (void *mem, size_t size)\n+{\n+  if (size < 0)\n+    runtime_error (\"Attempt to allocate a negative amount of memory.\");\n+  mem = realloc (mem, size);\n+  if (!mem && size != 0)\n+    _gfortran_os_error (\"Out of memory\");\n+\n+  if (size == 0)\n+    return NULL;\n+\n+  return mem;\n+}  */\n+tree\n+gfc_call_realloc (stmtblock_t * block, tree mem, tree size)\n+{\n+  tree msg, res, negative, zero, null_result, tmp;\n+  tree type = TREE_TYPE (mem);\n+\n+  size = gfc_evaluate_now (size, block);\n+\n+  if (TREE_TYPE (size) != TREE_TYPE (size_type_node))\n+    size = fold_convert (size_type_node, size);\n+\n+  /* Create a variable to hold the result.  */\n+  res = gfc_create_var (type, NULL);\n+\n+  /* size < 0 ?  */\n+  negative = fold_build2 (LT_EXPR, boolean_type_node, size,\n+\t\t\t  build_int_cst (size_type_node, 0));\n+  msg = gfc_build_addr_expr (pchar_type_node, gfc_build_cstring_const\n+      (\"Attempt to allocate a negative amount of memory.\"));\n+  tmp = fold_build3 (COND_EXPR, void_type_node, negative,\n+\t\t     build_call_expr (gfor_fndecl_runtime_error, 1, msg),\n+\t\t     build_empty_stmt ());\n+  gfc_add_expr_to_block (block, tmp);\n+\n+  /* Call realloc and check the result.  */\n+  tmp = build_call_expr (built_in_decls[BUILT_IN_REALLOC], 2,\n+\t\t\t fold_convert (pvoid_type_node, mem), size);\n+  gfc_add_modify_expr (block, res, fold_convert (type, tmp));\n+  null_result = fold_build2 (EQ_EXPR, boolean_type_node, res,\n+\t\t\t     build_int_cst (pvoid_type_node, 0));\n+  zero = fold_build2 (EQ_EXPR, boolean_type_node, size,\n+\t\t      build_int_cst (size_type_node, 0));\n+  null_result = fold_build2 (TRUTH_AND_EXPR, boolean_type_node, null_result,\n+\t\t\t     zero);\n+  msg = gfc_build_addr_expr (pchar_type_node,\n+\t\t\t     gfc_build_cstring_const (\"Out of memory\"));\n+  tmp = fold_build3 (COND_EXPR, void_type_node, null_result,\n+\t\t     build_call_expr (gfor_fndecl_os_error, 1, msg),\n+\t\t     build_empty_stmt ());\n+  gfc_add_expr_to_block (block, tmp);\n+\n+  /* if (size == 0) then the result is NULL.  */\n+  tmp = fold_build2 (MODIFY_EXPR, type, res, build_int_cst (type, 0));\n+  tmp = fold_build3 (COND_EXPR, void_type_node, zero, tmp,\n+\t\t     build_empty_stmt ());\n+  gfc_add_expr_to_block (block, tmp);\n+\n+  return res;\n+}\n+\n /* Add a statement to a block.  */\n \n void"}, {"sha": "1991748eccc53d7ce14a109b271bcf5b0701c8c7", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4376b7cf2b7d906c1952205ec3242e689f84f671/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4376b7cf2b7d906c1952205ec3242e689f84f671/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=4376b7cf2b7d906c1952205ec3242e689f84f671", "patch": "@@ -450,6 +450,18 @@ tree gfc_call_free (tree);\n /* Allocate memory after performing a few checks.  */\n tree gfc_call_malloc (stmtblock_t *, tree, tree);\n \n+/* Allocate memory for arrays, with optional status variable.  */\n+tree gfc_allocate_array_with_status (stmtblock_t *, tree, tree, tree);\n+\n+/* Allocate memory, with optional status variable.  */\n+tree gfc_allocate_with_status (stmtblock_t *, tree, tree);\n+\n+/* Generate code to deallocate an array.  */\n+tree gfc_deallocate_with_status (tree, tree, bool);\n+\n+/* Generate code to call realloc().  */\n+tree gfc_call_realloc (stmtblock_t *, tree, tree);\n+\n /* Generate code for an assignment, includes scalarization.  */\n tree gfc_trans_assignment (gfc_expr *, gfc_expr *, bool);\n \n@@ -483,10 +495,6 @@ struct gimplify_omp_ctx;\n void gfc_omp_firstprivatize_type_sizes (struct gimplify_omp_ctx *, tree);\n \n /* Runtime library function decls.  */\n-extern GTY(()) tree gfor_fndecl_internal_realloc;\n-extern GTY(()) tree gfor_fndecl_allocate;\n-extern GTY(()) tree gfor_fndecl_allocate_array;\n-extern GTY(()) tree gfor_fndecl_deallocate;\n extern GTY(()) tree gfor_fndecl_pause_numeric;\n extern GTY(()) tree gfor_fndecl_pause_string;\n extern GTY(()) tree gfor_fndecl_stop_numeric;"}, {"sha": "1878af1d1fb23e66e5141d5f2813d118627a319d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4376b7cf2b7d906c1952205ec3242e689f84f671/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4376b7cf2b7d906c1952205ec3242e689f84f671/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4376b7cf2b7d906c1952205ec3242e689f84f671", "patch": "@@ -1,3 +1,8 @@\n+2007-08-29  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\t* gfortran.dg/alloc_comp_basics_1.f90: Update check.\n+\t* gfortran.dg/alloc_comp_constructor_1.f90: Update check.\n+\n 2007-08-29  Douglas Gregor  <doug.gregor@gmail.com>\n \n \tPR c++/33194"}, {"sha": "fc58bf4483039a9b5a79e7f778bec6e4a5c4da0d", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_basics_1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4376b7cf2b7d906c1952205ec3242e689f84f671/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_basics_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4376b7cf2b7d906c1952205ec3242e689f84f671/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_basics_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_basics_1.f90?ref=4376b7cf2b7d906c1952205ec3242e689f84f671", "patch": "@@ -139,6 +139,6 @@ subroutine check_alloc2(b)\n     end subroutine check_alloc2\n \n end program alloc\n-! { dg-final { scan-tree-dump-times \"deallocate\" 24 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"builtin_free\" 24 \"original\" } }\n ! { dg-final { cleanup-tree-dump \"original\" } }\n ! { dg-final { cleanup-modules \"alloc_m\" } }"}, {"sha": "969e703094c63681f8f1dca8e0840fff08c4aba3", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_constructor_1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4376b7cf2b7d906c1952205ec3242e689f84f671/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_constructor_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4376b7cf2b7d906c1952205ec3242e689f84f671/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_constructor_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_constructor_1.f90?ref=4376b7cf2b7d906c1952205ec3242e689f84f671", "patch": "@@ -104,5 +104,5 @@ function blaha()\n     end function blaha\r\n \r\n end program test_constructor\r\n-! { dg-final { scan-tree-dump-times \"deallocate\" 18 \"original\" } }\r\n+! { dg-final { scan-tree-dump-times \"builtin_free\" 19 \"original\" } }\r\n ! { dg-final { cleanup-tree-dump \"original\" } }\r"}, {"sha": "aa1df6aa7a6ecdfb4f76b68fa2b96dc738492ba3", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4376b7cf2b7d906c1952205ec3242e689f84f671/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4376b7cf2b7d906c1952205ec3242e689f84f671/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=4376b7cf2b7d906c1952205ec3242e689f84f671", "patch": "@@ -1,3 +1,11 @@\n+2007-08-29  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\t* runtime/memory.c (internal_realloc, allocate, allocate_array,\n+\tdeallocate): Remove functions.\n+\t* gfortran.map (_gfortran_allocate, _gfortran_allocate_array,\n+\t_gfortran_deallocate, _gfortran_internal_realloc): Remove symbols.\n+\t* libgfortran.h (error_codes): Add comment.\n+\n 2007-08-28  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libfortran/33055"}, {"sha": "429c84c8c4a504efe4f50ecd997a4807867fb6e8", "filename": "libgfortran/gfortran.map", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4376b7cf2b7d906c1952205ec3242e689f84f671/libgfortran%2Fgfortran.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4376b7cf2b7d906c1952205ec3242e689f84f671/libgfortran%2Fgfortran.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgfortran.map?ref=4376b7cf2b7d906c1952205ec3242e689f84f671", "patch": "@@ -11,8 +11,6 @@ GFORTRAN_1.0 {\n     _gfortran_all_l16;\n     _gfortran_all_l4;\n     _gfortran_all_l8;\n-    _gfortran_allocate;\n-    _gfortran_allocate_array;\n     _gfortran_any_l16;\n     _gfortran_any_l4;\n     _gfortran_any_l8;\n@@ -60,7 +58,6 @@ GFORTRAN_1.0 {\n     _gfortran_ctime;\n     _gfortran_ctime_sub;\n     _gfortran_date_and_time;\n-    _gfortran_deallocate;\n     _gfortran_eoshift0_1;\n     _gfortran_eoshift0_1_char;\n     _gfortran_eoshift0_2;\n@@ -167,7 +164,6 @@ GFORTRAN_1.0 {\n     _gfortran_ierrno_i4;\n     _gfortran_ierrno_i8;\n     _gfortran_internal_pack;\n-    _gfortran_internal_realloc;\n     _gfortran_internal_unpack;\n     _gfortran_irand;\n     _gfortran_isatty_l4;"}, {"sha": "d068a753fa43a8c6fa34740cdc6dc64fd2861e5f", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4376b7cf2b7d906c1952205ec3242e689f84f671/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4376b7cf2b7d906c1952205ec3242e689f84f671/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=4376b7cf2b7d906c1952205ec3242e689f84f671", "patch": "@@ -447,7 +447,9 @@ typedef enum\n   ERROR_READ_OVERFLOW,\n   ERROR_INTERNAL,\n   ERROR_INTERNAL_UNIT,\n-  ERROR_ALLOCATION,\n+  ERROR_ALLOCATION,\t\t/* Keep in sync with value used in\n+\t\t\t\t   gcc/fortran/trans.c\n+\t\t\t\t   (gfc_allocate_array_with_status).  */\n   ERROR_DIRECT_EOR,\n   ERROR_SHORT_RECORD,\n   ERROR_CORRUPT_FILE,"}, {"sha": "7407486b6961f4c38df6f529bba8d5b8c03f5c36", "filename": "libgfortran/runtime/memory.c", "status": "modified", "additions": 0, "deletions": 124, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4376b7cf2b7d906c1952205ec3242e689f84f671/libgfortran%2Fruntime%2Fmemory.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4376b7cf2b7d906c1952205ec3242e689f84f671/libgfortran%2Fruntime%2Fmemory.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Fmemory.c?ref=4376b7cf2b7d906c1952205ec3242e689f84f671", "patch": "@@ -38,10 +38,6 @@ Boston, MA 02110-1301, USA.  */\n    performance is desired, but it can help when you're debugging code.  */\n /* #define GFC_CLEAR_MEMORY */\n \n-/* If GFC_CHECK_MEMORY is defined, we do some sanity checks at runtime.\n-   This causes small overhead, but again, it also helps debugging.  */\n-#define GFC_CHECK_MEMORY\n-\n void *\n get_mem (size_t n)\n {\n@@ -76,123 +72,3 @@ internal_malloc_size (size_t size)\n \n   return get_mem (size);\n }\n-\n-\n-/* Reallocate internal memory MEM so it has SIZE bytes of data.\n-   Allocate a new block if MEM is zero, and free the block if\n-   SIZE is 0.  */\n-\n-extern void *internal_realloc (void *, index_type);\n-export_proto(internal_realloc);\n-\n-void *\n-internal_realloc (void *mem, index_type size)\n-{\n-#ifdef GFC_CHECK_MEMORY\n-  /* Under normal circumstances, this is _never_ going to happen!  */\n-  if (size < 0)\n-    runtime_error (\"Attempt to allocate a negative amount of memory.\");\n-#endif\n-  mem = realloc (mem, size);\n-  if (!mem && size != 0)\n-    os_error (\"Out of memory.\");\n-  \n-  if (size == 0)\n-      return NULL;\n-\n-  return mem;\n-}\n-\n-\n-/* User-allocate, one call for each member of the alloc-list of an\n-   ALLOCATE statement. */\n-\n-extern void *allocate (index_type, GFC_INTEGER_4 *) __attribute__ ((malloc));\n-export_proto(allocate);\n-\n-void *\n-allocate (index_type size, GFC_INTEGER_4 * stat)\n-{\n-  void *newmem;\n-\n-#ifdef GFC_CHECK_MEMORY\n-  /* The only time this can happen is the size computed by the\n-     frontend wraps around.  */\n-  if (size < 0)\n-    {\n-      if (stat)\n-\t{\n-\t  *stat = ERROR_ALLOCATION;\n-\t  return NULL;\n-\t}\n-      else\n-\truntime_error (\"Attempt to allocate negative amount of memory. \"\n-\t\t       \"Possible integer overflow\");\n-    }\n-#endif\n-  newmem = malloc (size ? size : 1);\n-  if (!newmem)\n-    {\n-      if (stat)\n-\t{\n-\t  *stat = ERROR_ALLOCATION;\n-\t  return newmem;\n-\t}\n-      else\n-\truntime_error (\"ALLOCATE: Out of memory.\");\n-    }\n-\n-  if (stat)\n-    *stat = 0;\n-\n-  return newmem;\n-}\n-\n-/* Function to call in an ALLOCATE statement when the argument is an\n-   allocatable array.  If the array is currently allocated, it is\n-   an error to allocate it again.  */\n-\n-extern void *allocate_array (void *, index_type, GFC_INTEGER_4 *);\n-export_proto(allocate_array);\n-\n-void *\n-allocate_array (void *mem, index_type size, GFC_INTEGER_4 * stat)\n-{\n-  if (mem == NULL)\n-    return allocate (size, stat);\n-  if (stat)\n-    {\n-      free (mem);\n-      mem = allocate (size, stat);\n-      *stat = ERROR_ALLOCATION;\n-      return mem;\n-    }\n-\n-  runtime_error (\"Attempting to allocate already allocated array.\");\n-}\n-\n-\n-/* User-deallocate; pointer is then NULLified by the front-end. */\n-\n-extern void deallocate (void *, GFC_INTEGER_4 *);\n-export_proto(deallocate);\n-\n-void\n-deallocate (void *mem, GFC_INTEGER_4 * stat)\n-{\n-  if (!mem)\n-    {\n-      if (stat)\n-\t{\n-\t  *stat = 1;\n-\t  return;\n-\t}\n-      else\n-\truntime_error (\"Internal: Attempt to DEALLOCATE unallocated memory.\");\n-    }\n-\n-  free (mem);\n-\n-  if (stat)\n-    *stat = 0;\n-}"}]}