{"sha": "fdc43210e38125c34a8578e1fb8f7b09c396c14c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmRjNDMyMTBlMzgxMjVjMzRhODU3OGUxZmI4ZjdiMDljMzk2YzE0Yw==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2012-07-31T21:08:41Z"}, "committer": {"name": "William Schmidt", "email": "wschmidt@gcc.gnu.org", "date": "2012-07-31T21:08:41Z"}, "message": "rs6000.c (rs6000_builtin_vectorization_cost): Revise costs for vec_perm and vec_promote_demote down to more natural values.\n\n2012-07-31  Bill Schmidt  <wschmidt@linux.ibm.com>\n\n\t* config/rs6000/rs6000.c (rs6000_builtin_vectorization_cost): Revise\n\tcosts for vec_perm and vec_promote_demote down to more natural values.\n\t(struct _rs6000_cost_data): New data structure.\n\t(rs6000_density_test): New function.\n\t(rs6000_init_cost): Change to use rs6000_cost_data.\n\t(rs6000_add_stmt_cost): Likewise.\n\t(rs6000_finish_cost): Perform density test when vectorizing a loop.\n\nFrom-SVN: r190019", "tree": {"sha": "5b69c789cf7c36dd0a03427bb3953c269241cd2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b69c789cf7c36dd0a03427bb3953c269241cd2b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fdc43210e38125c34a8578e1fb8f7b09c396c14c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdc43210e38125c34a8578e1fb8f7b09c396c14c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fdc43210e38125c34a8578e1fb8f7b09c396c14c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdc43210e38125c34a8578e1fb8f7b09c396c14c/comments", "author": null, "committer": null, "parents": [{"sha": "0e8d854eb8bbfc44c1fd9d2fa6e07514d2932e0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e8d854eb8bbfc44c1fd9d2fa6e07514d2932e0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e8d854eb8bbfc44c1fd9d2fa6e07514d2932e0e"}], "stats": {"total": 96, "additions": 84, "deletions": 12}, "files": [{"sha": "a137c7fa2621d09af1075b410a3c341623938ce4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdc43210e38125c34a8578e1fb8f7b09c396c14c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdc43210e38125c34a8578e1fb8f7b09c396c14c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fdc43210e38125c34a8578e1fb8f7b09c396c14c", "patch": "@@ -1,3 +1,13 @@\n+2012-07-31  Bill Schmidt  <wschmidt@linux.ibm.com>\n+\n+\t* config/rs6000/rs6000.c (rs6000_builtin_vectorization_cost): Revise\n+\tcosts for vec_perm and vec_promote_demote down to more natural values.\n+\t(struct _rs6000_cost_data): New data structure.\n+\t(rs6000_density_test): New function.\n+\t(rs6000_init_cost): Change to use rs6000_cost_data.\n+\t(rs6000_add_stmt_cost): Likewise.\n+\t(rs6000_finish_cost): Perform density test when vectorizing a loop.\n+\n 2012-07-31  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* sched-vis.c (print_exp): Handle FMA explicitly.  Simplify handling"}, {"sha": "b68082c143fd7cfd6cfbdc47c2315bda6937ecf2", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 74, "deletions": 12, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdc43210e38125c34a8578e1fb8f7b09c396c14c/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdc43210e38125c34a8578e1fb8f7b09c396c14c/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=fdc43210e38125c34a8578e1fb8f7b09c396c14c", "patch": "@@ -57,6 +57,7 @@\n #include \"params.h\"\n #include \"tm-constrs.h\"\n #include \"opts.h\"\n+#include \"tree-vectorizer.h\"\n #if TARGET_XCOFF\n #include \"xcoffout.h\"  /* get declarations of xcoff_*_section_name */\n #endif\n@@ -3326,13 +3327,13 @@ rs6000_builtin_vectorization_cost (enum vect_cost_for_stmt type_of_cost,\n \n       case vec_perm:\n \tif (TARGET_VSX)\n-\t  return 4;\n+\t  return 3;\n \telse\n \t  return 1;\n \n       case vec_promote_demote:\n         if (TARGET_VSX)\n-          return 5;\n+          return 4;\n         else\n           return 1;\n \n@@ -3468,14 +3469,71 @@ rs6000_preferred_simd_mode (enum machine_mode mode)\n   return word_mode;\n }\n \n+typedef struct _rs6000_cost_data\n+{\n+  struct loop *loop_info;\n+  unsigned cost[3];\n+} rs6000_cost_data;\n+\n+/* Test for likely overcommitment of vector hardware resources.  If a\n+   loop iteration is relatively large, and too large a percentage of\n+   instructions in the loop are vectorized, the cost model may not\n+   adequately reflect delays from unavailable vector resources.\n+   Penalize the loop body cost for this case.  */\n+\n+static void\n+rs6000_density_test (rs6000_cost_data *data)\n+{\n+  const int DENSITY_PCT_THRESHOLD = 85;\n+  const int DENSITY_SIZE_THRESHOLD = 70;\n+  const int DENSITY_PENALTY = 10;\n+  struct loop *loop = data->loop_info;\n+  basic_block *bbs = get_loop_body (loop);\n+  int nbbs = loop->num_nodes;\n+  int vec_cost = data->cost[vect_body], not_vec_cost = 0;\n+  int i, density_pct;\n+\n+  for (i = 0; i < nbbs; i++)\n+    {\n+      basic_block bb = bbs[i];\n+      gimple_stmt_iterator gsi;\n+\n+      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t{\n+\t  gimple stmt = gsi_stmt (gsi);\n+\t  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+\n+\t  if (!STMT_VINFO_RELEVANT_P (stmt_info)\n+\t      && !STMT_VINFO_IN_PATTERN_P (stmt_info))\n+\t    not_vec_cost++;\n+\t}\n+    }\n+\n+  density_pct = (vec_cost * 100) / (vec_cost + not_vec_cost);\n+\n+  if (density_pct > DENSITY_PCT_THRESHOLD\n+      && vec_cost + not_vec_cost > DENSITY_SIZE_THRESHOLD)\n+    {\n+      data->cost[vect_body] = vec_cost * (100 + DENSITY_PENALTY) / 100;\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+\tfprintf (vect_dump,\n+\t\t \"density %d%%, cost %d exceeds threshold, penalizing \"\n+\t\t \"loop body cost by %d%%\", density_pct, \n+\t\t vec_cost + not_vec_cost, DENSITY_PENALTY);\n+    }\n+}\n+\n /* Implement targetm.vectorize.init_cost.  */\n \n static void *\n-rs6000_init_cost (struct loop *loop_info ATTRIBUTE_UNUSED)\n+rs6000_init_cost (struct loop *loop_info)\n {\n-  unsigned *cost = XNEWVEC (unsigned, 3);\n-  cost[vect_prologue] = cost[vect_body] = cost[vect_epilogue] = 0;\n-  return cost;\n+  rs6000_cost_data *data = XNEW (struct _rs6000_cost_data);\n+  data->loop_info = loop_info;\n+  data->cost[vect_prologue] = 0;\n+  data->cost[vect_body]     = 0;\n+  data->cost[vect_epilogue] = 0;\n+  return data;\n }\n \n /* Implement targetm.vectorize.add_stmt_cost.  */\n@@ -3485,7 +3543,7 @@ rs6000_add_stmt_cost (void *data, int count, enum vect_cost_for_stmt kind,\n \t\t      struct _stmt_vec_info *stmt_info, int misalign,\n \t\t      enum vect_cost_model_location where)\n {\n-  unsigned *cost = (unsigned *) data;\n+  rs6000_cost_data *cost_data = (rs6000_cost_data*) data;\n   unsigned retval = 0;\n \n   if (flag_vect_cost_model)\n@@ -3500,7 +3558,7 @@ rs6000_add_stmt_cost (void *data, int count, enum vect_cost_for_stmt kind,\n \tcount *= 50;  /* FIXME.  */\n \n       retval = (unsigned) (count * stmt_cost);\n-      cost[where] += retval;\n+      cost_data->cost[where] += retval;\n     }\n \n   return retval;\n@@ -3512,10 +3570,14 @@ static void\n rs6000_finish_cost (void *data, unsigned *prologue_cost,\n \t\t    unsigned *body_cost, unsigned *epilogue_cost)\n {\n-  unsigned *cost = (unsigned *) data;\n-  *prologue_cost = cost[vect_prologue];\n-  *body_cost     = cost[vect_body];\n-  *epilogue_cost = cost[vect_epilogue];\n+  rs6000_cost_data *cost_data = (rs6000_cost_data*) data;\n+\n+  if (cost_data->loop_info)\n+    rs6000_density_test (cost_data);\n+\n+  *prologue_cost = cost_data->cost[vect_prologue];\n+  *body_cost     = cost_data->cost[vect_body];\n+  *epilogue_cost = cost_data->cost[vect_epilogue];\n }\n \n /* Implement targetm.vectorize.destroy_cost_data.  */"}]}