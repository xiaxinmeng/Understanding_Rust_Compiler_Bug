{"sha": "954d8e993c55366884fa11473e0da7b9b3457184", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTU0ZDhlOTkzYzU1MzY2ODg0ZmExMTQ3M2UwZGE3YjliMzQ1NzE4NA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@freesoft.cz", "date": "1999-12-16T10:35:14Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "1999-12-16T10:35:14Z"}, "message": "regclass.c (loop_depth): Remove\n\n\t* regclass.c (loop_depth): Remove\n\t(scan_one_insn): Do not handle LOOP_NOTE insns.\n\t(regclass): Go through basic blocks and set loop_cost\n\nFrom-SVN: r30976", "tree": {"sha": "86636ce3b4bf44a7d8367b093dcab0e21f08c8a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/86636ce3b4bf44a7d8367b093dcab0e21f08c8a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/954d8e993c55366884fa11473e0da7b9b3457184", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/954d8e993c55366884fa11473e0da7b9b3457184", "html_url": "https://github.com/Rust-GCC/gccrs/commit/954d8e993c55366884fa11473e0da7b9b3457184", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/954d8e993c55366884fa11473e0da7b9b3457184/comments", "author": null, "committer": null, "parents": [{"sha": "5ba280dae8c8d278b77979ff64dacd29d497ebe0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ba280dae8c8d278b77979ff64dacd29d497ebe0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ba280dae8c8d278b77979ff64dacd29d497ebe0"}], "stats": {"total": 52, "additions": 25, "deletions": 27}, "files": [{"sha": "570e307e4f2fd77f108be640b6b08fc6fd2b6935", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/954d8e993c55366884fa11473e0da7b9b3457184/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/954d8e993c55366884fa11473e0da7b9b3457184/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=954d8e993c55366884fa11473e0da7b9b3457184", "patch": "@@ -1,3 +1,9 @@\n+Thu Dec 16 11:33:57 MET 1999  Jan Hubicka  <hubicka@freesoft.cz>\n+\n+\t* regclass.c (loop_depth): Remove\n+\t(scan_one_insn): Do not handle LOOP_NOTE insns.\n+\t(regclass): Go through basic blocks and set loop_cost\n+\n Thu Dec 16 02:56:25 1999  Zack Weinberg  <zack@bitmover.com>\n \n \t* tree.h (DECL_FROM_INLINE): Check DECL_ABSTRACT_ORIGIN too."}, {"sha": "3c28580496c8c67fd5d1fbd67ad8c54143fa329f", "filename": "gcc/regclass.c", "status": "modified", "additions": 19, "deletions": 27, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/954d8e993c55366884fa11473e0da7b9b3457184/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/954d8e993c55366884fa11473e0da7b9b3457184/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=954d8e993c55366884fa11473e0da7b9b3457184", "patch": "@@ -716,10 +716,6 @@ static struct reg_pref *reg_pref;\n \n static struct reg_pref *reg_pref_buffer;\n \n-/* Record the depth of loops that we are in.  */\n-\n-static int loop_depth;\n-\n /* Account for the fact that insns within a loop are executed very commonly,\n    but don't keep doing this as loops go too deep.  */\n \n@@ -821,26 +817,6 @@ scan_one_insn (insn, pass)\n   rtx set, note;\n   int i, j;\n \n-  /* Show that an insn inside a loop is likely to be executed three\n-     times more than insns outside a loop.  This is much more aggressive\n-     than the assumptions made elsewhere and is being tried as an\n-     experiment.  */\n-\n-  if (code == NOTE)\n-    {\n-      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n-\tloop_depth++;\n-      else if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END)\n-\tloop_depth--;\n-\n-      if (optimize_size)\n-\tloop_cost = 1;\n-      else\n-\tloop_cost = 1 << (2 * MIN (loop_depth, 5));\n-\n-      return insn;\n-    }\n-\n   if (GET_RTX_CLASS (code) != 'i')\n     return insn;\n \n@@ -1085,6 +1061,7 @@ regclass (f, nregs, dump)\n \n   for (pass = 0; pass <= flag_expensive_optimizations; pass++)\n     {\n+      int index;\n       /* Zero out our accumulation of the cost of each class for each reg.  */\n \n       bzero ((char *) costs, nregs * sizeof (struct costs));\n@@ -1093,14 +1070,29 @@ regclass (f, nregs, dump)\n       bzero (in_inc_dec, nregs);\n #endif\n \n-      loop_depth = 0, loop_cost = 1;\n+      loop_cost = 1;\n \n       /* Scan the instructions and record each time it would\n \t save code to put a certain register in a certain class.  */\n \n-      for (insn = f; insn; insn = NEXT_INSN (insn))\n+      for (index = 0; index < n_basic_blocks; index++)\n \t{\n-\t  insn = scan_one_insn (insn, pass);\n+\t  basic_block bb = BASIC_BLOCK (index);\n+\n+\t  /* Show that an insn inside a loop is likely to be executed three\n+\t     times more than insns outside a loop.  This is much more aggressive\n+\t     than the assumptions made elsewhere and is being tried as an\n+\t     experiment.  */\n+\t  if (optimize_size)\n+\t    loop_cost = 1;\n+\t  else\n+\t    loop_cost = 1 << (2 * MIN (bb->loop_depth - 1, 5));\n+\t  for (insn = bb->head; ; insn = NEXT_INSN (insn))\n+\t    {\n+\t      insn = scan_one_insn (insn, pass);\n+\t      if (insn == bb->end)\n+\t\tbreak;\n+\t    }\n \t}\n       \n       /* Now for each register look at how desirable each class is"}]}