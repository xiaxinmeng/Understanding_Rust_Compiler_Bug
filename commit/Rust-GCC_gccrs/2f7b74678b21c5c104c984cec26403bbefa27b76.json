{"sha": "2f7b74678b21c5c104c984cec26403bbefa27b76", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmY3Yjc0Njc4YjIxYzVjMTA0Yzk4NGNlYzI2NDAzYmJlZmEyN2I3Ng==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-12-20T14:00:46Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-12-20T14:00:46Z"}, "message": "[multiple changes]\n\n2011-12-20  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch11.adb (Find_Local_Handler): Guard the\n\tsearch over individual exception choices in case the list of\n\thandlers contains other (possibly illegal) constructs.\n\n2011-12-20  Gary Dismukes  <dismukes@adacore.com>\n\n\t* sem_ch8.adb (Find_Type): Test taggedness\n\tof the Available_Type when checking for an illegal use of an\n\tincomplete type, when the incomplete view is a limited view of\n\ta type. Remove redundant Is_Tagged test.\n\n2011-12-20  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_util.adb: Add with and use clause for Aspects.\n\t(Is_Finalizable_Transient): Objects which denote Ada containers\n\tin the context of iterators are not considered transients. Such\n\tobject must live for as long as the loop is around.\n\t(Is_Iterated_Container): New routine.\n\n2011-12-20  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_imgv.adb (Expand_Width_Attribute): Add a\n\ttype conversion from the enumeration subtype to its base subtype.\n\nFrom-SVN: r182539", "tree": {"sha": "fe6c67803b376fd6b34bafbde01819f5aa89d330", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fe6c67803b376fd6b34bafbde01819f5aa89d330"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f7b74678b21c5c104c984cec26403bbefa27b76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f7b74678b21c5c104c984cec26403bbefa27b76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f7b74678b21c5c104c984cec26403bbefa27b76", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f7b74678b21c5c104c984cec26403bbefa27b76/comments", "author": null, "committer": null, "parents": [{"sha": "b26f70a095903c480d39d986a3e729f97f1fa88d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b26f70a095903c480d39d986a3e729f97f1fa88d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b26f70a095903c480d39d986a3e729f97f1fa88d"}], "stats": {"total": 221, "additions": 180, "deletions": 41}, "files": [{"sha": "697ea3dbba2e367bdf60b2dc4739caa5a3f79421", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f7b74678b21c5c104c984cec26403bbefa27b76/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f7b74678b21c5c104c984cec26403bbefa27b76/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=2f7b74678b21c5c104c984cec26403bbefa27b76", "patch": "@@ -1,3 +1,29 @@\n+2011-12-20  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch11.adb (Find_Local_Handler): Guard the\n+\tsearch over individual exception choices in case the list of\n+\thandlers contains other (possibly illegal) constructs.\n+\n+2011-12-20  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* sem_ch8.adb (Find_Type): Test taggedness\n+\tof the Available_Type when checking for an illegal use of an\n+\tincomplete type, when the incomplete view is a limited view of\n+\ta type. Remove redundant Is_Tagged test.\n+\n+2011-12-20  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_util.adb: Add with and use clause for Aspects.\n+\t(Is_Finalizable_Transient): Objects which denote Ada containers\n+\tin the context of iterators are not considered transients. Such\n+\tobject must live for as long as the loop is around.\n+\t(Is_Iterated_Container): New routine.\n+\n+2011-12-20  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_imgv.adb (Expand_Width_Attribute): Add a\n+\ttype conversion from the enumeration subtype to its base subtype.\n+\n 2011-12-20  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* sem_ch4.adb (Operator_Check): Update the call to"}, {"sha": "f38ff854640a4ff8f492ce407d865296b01d6551", "filename": "gcc/ada/exp_ch11.adb", "status": "modified", "additions": 37, "deletions": 29, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f7b74678b21c5c104c984cec26403bbefa27b76/gcc%2Fada%2Fexp_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f7b74678b21c5c104c984cec26403bbefa27b76/gcc%2Fada%2Fexp_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch11.adb?ref=2f7b74678b21c5c104c984cec26403bbefa27b76", "patch": "@@ -1913,49 +1913,57 @@ package body Exp_Ch11 is\n                H := First (Exception_Handlers (P));\n                while Present (H) loop\n \n-                  --  Loop through choices in one handler\n+                  --  Guard against other constructs appearing in the list of\n+                  --  exception handlers.\n \n-                  C := First (Exception_Choices (H));\n-                  while Present (C) loop\n+                  if Nkind (H) = N_Exception_Handler then\n \n-                     --  Deal with others case\n+                     --  Loop through choices in one handler\n \n-                     if Nkind (C) = N_Others_Choice then\n+                     C := First (Exception_Choices (H));\n+                     while Present (C) loop\n \n-                        --  Matching others handler, but we need to ensure\n-                        --  there is no choice parameter. If there is, then we\n-                        --  don't have a local handler after all (since we do\n-                        --  not allow choice parameters for local handlers).\n+                        --  Deal with others case\n \n-                        if No (Choice_Parameter (H)) then\n-                           return H;\n-                        else\n-                           return Empty;\n-                        end if;\n-\n-                     --  If not others must be entity name\n-\n-                     elsif Nkind (C) /= N_Others_Choice then\n-                        pragma Assert (Is_Entity_Name (C));\n-                        pragma Assert (Present (Entity (C)));\n-\n-                        --  Get exception being handled, dealing with renaming\n+                        if Nkind (C) = N_Others_Choice then\n \n-                        EHandle := Get_Renamed_Entity (Entity (C));\n+                           --  Matching others handler, but we need to ensure\n+                           --  there is no choice parameter. If there is, then\n+                           --  we don't have a local handler after all (since\n+                           --  we do not allow choice parameters for local\n+                           --  handlers).\n \n-                        --  If match, then check choice parameter\n-\n-                        if ERaise = EHandle then\n                            if No (Choice_Parameter (H)) then\n                               return H;\n                            else\n                               return Empty;\n                            end if;\n+\n+                        --  If not others must be entity name\n+\n+                        elsif Nkind (C) /= N_Others_Choice then\n+                           pragma Assert (Is_Entity_Name (C));\n+                           pragma Assert (Present (Entity (C)));\n+\n+                           --  Get exception being handled, dealing with\n+                           --  renaming.\n+\n+                           EHandle := Get_Renamed_Entity (Entity (C));\n+\n+                           --  If match, then check choice parameter\n+\n+                           if ERaise = EHandle then\n+                              if No (Choice_Parameter (H)) then\n+                                 return H;\n+                              else\n+                                 return Empty;\n+                              end if;\n+                           end if;\n                         end if;\n-                     end if;\n \n-                     Next (C);\n-                  end loop;\n+                        Next (C);\n+                     end loop;\n+                  end if;\n \n                   Next (H);\n                end loop;"}, {"sha": "f2e22f768b7616d73f5054e829a7331cf434ea7a", "filename": "gcc/ada/exp_imgv.adb", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f7b74678b21c5c104c984cec26403bbefa27b76/gcc%2Fada%2Fexp_imgv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f7b74678b21c5c104c984cec26403bbefa27b76/gcc%2Fada%2Fexp_imgv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_imgv.adb?ref=2f7b74678b21c5c104c984cec26403bbefa27b76", "patch": "@@ -1177,7 +1177,7 @@ package body Exp_Imgv is\n          --                  ...\n          --                      else n)))...\n \n-         --  where n is equal to Rtyp'Pos (Rtyp'Last) + 1\n+         --  where n is equal to Rtyp'Pos (Ptyp'Last) + 1\n \n          --  Note: The above processing is in accordance with the intent of\n          --  the RM, which is that Width should be related to the impl-defined\n@@ -1206,12 +1206,13 @@ package body Exp_Imgv is\n                      New_Occurrence_Of (Standard_Integer, Loc),\n                    Expression =>\n                      Make_Attribute_Reference (Loc,\n-                       Prefix            => New_Occurrence_Of (Rtyp, Loc),\n-                       Attribute_Name    => Name_Pos,\n-                       Expressions       => New_List (\n-                         Make_Attribute_Reference (Loc,\n-                           Prefix            => New_Occurrence_Of (Ptyp, Loc),\n-                           Attribute_Name    => Name_Last)))));\n+                       Prefix         => New_Occurrence_Of (Rtyp, Loc),\n+                       Attribute_Name => Name_Pos,\n+                       Expressions    => New_List (\n+                         Convert_To (Rtyp,\n+                           Make_Attribute_Reference (Loc,\n+                             Prefix         => New_Occurrence_Of (Ptyp, Loc),\n+                             Attribute_Name => Name_Last))))));\n \n                --  OK, now we need to build the conditional expression. First\n                --  get the value of M, the largest possible value needed."}, {"sha": "dd5fc9891f94ba4d96b579f8d73500bc66ec1b28", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 99, "deletions": 1, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f7b74678b21c5c104c984cec26403bbefa27b76/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f7b74678b21c5c104c984cec26403bbefa27b76/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=2f7b74678b21c5c104c984cec26403bbefa27b76", "patch": "@@ -23,6 +23,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Aspects;  use Aspects;\n with Atree;    use Atree;\n with Casing;   use Casing;\n with Checks;   use Checks;\n@@ -3966,6 +3967,13 @@ package body Exp_Util is\n       function Is_Allocated (Trans_Id : Entity_Id) return Boolean;\n       --  Determine whether transient object Trans_Id is allocated on the heap\n \n+      function Is_Iterated_Container\n+        (Trans_Id   : Entity_Id;\n+         First_Stmt : Node_Id) return Boolean;\n+      --  Determine whether transient object Trans_Id denotes a container which\n+      --  is in the process of being iterated in the statement list starting\n+      --  from First_Stmt.\n+\n       ---------------------------\n       -- Initialized_By_Access --\n       ---------------------------\n@@ -4180,6 +4188,90 @@ package body Exp_Util is\n              and then Nkind (Expr) = N_Allocator;\n       end Is_Allocated;\n \n+      ---------------------------\n+      -- Is_Iterated_Container --\n+      ---------------------------\n+\n+      function Is_Iterated_Container\n+        (Trans_Id   : Entity_Id;\n+         First_Stmt : Node_Id) return Boolean\n+      is\n+         Aspect : Node_Id;\n+         Call   : Node_Id;\n+         Iter   : Entity_Id;\n+         Param  : Node_Id;\n+         Stmt   : Node_Id;\n+         Typ    : Entity_Id;\n+\n+      begin\n+         --  It is not possible to iterate over containers in non-Ada 2012 code\n+\n+         if Ada_Version < Ada_2012 then\n+            return False;\n+         end if;\n+\n+         Typ := Etype (Trans_Id);\n+\n+         --  Handle access type created for secondary stack use\n+\n+         if Is_Access_Type (Typ) then\n+            Typ := Designated_Type (Typ);\n+         end if;\n+\n+         --  Look for aspect Default_Iterator\n+\n+         if Has_Aspects (Parent (Typ)) then\n+            Aspect := Find_Aspect (Typ, Aspect_Default_Iterator);\n+\n+            if Present (Aspect) then\n+               Iter := Entity (Aspect);\n+\n+               --  Examine the statements following the container object and\n+               --  look for a call to the default iterate routine where the\n+               --  first parameter is the transient. Such a call appears as:\n+\n+               --     It : Access_To_CW_Iterator :=\n+               --            Iterate (Tran_Id.all, ...)'reference;\n+\n+               Stmt := First_Stmt;\n+               while Present (Stmt) loop\n+\n+                  --  Detect an object declaration which is initialized by a\n+                  --  secondary stack function call.\n+\n+                  if Nkind (Stmt) = N_Object_Declaration\n+                    and then Present (Expression (Stmt))\n+                    and then Nkind (Expression (Stmt)) = N_Reference\n+                    and then Nkind (Prefix (Expression (Stmt))) =\n+                               N_Function_Call\n+                  then\n+                     Call := Prefix (Expression (Stmt));\n+\n+                     --  The call must invoke the default iterate routine of\n+                     --  the container and the transient object must appear as\n+                     --  the first actual parameter.\n+\n+                     if Entity (Name (Call)) = Iter\n+                       and then Present (Parameter_Associations (Call))\n+                     then\n+                        Param := First (Parameter_Associations (Call));\n+\n+                        if Nkind (Param) = N_Explicit_Dereference\n+                          and then Entity (Prefix (Param)) = Trans_Id\n+                        then\n+                           return True;\n+                        end if;\n+                     end if;\n+                  end if;\n+\n+                  Next (Stmt);\n+               end loop;\n+            end if;\n+         end if;\n+\n+         return False;\n+      end Is_Iterated_Container;\n+\n    --  Start of processing for Is_Finalizable_Transient\n \n    begin\n@@ -4220,7 +4312,13 @@ package body Exp_Util is\n \n           --  Do not consider conversions of tags to class-wide types\n \n-          and then not Is_Tag_To_CW_Conversion (Obj_Id);\n+          and then not Is_Tag_To_CW_Conversion (Obj_Id)\n+\n+          --  Do not consider containers in the context of iterator loops. Such\n+          --  transient objects must exist for as long as the loop is around,\n+          --  otherwise any operation carried out by the iterator will fail.\n+\n+          and then not Is_Iterated_Container (Obj_Id, Decl);\n    end Is_Finalizable_Transient;\n \n    ---------------------------------"}, {"sha": "8134973d8009a5a917cc6c06e82a8cf889007520", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f7b74678b21c5c104c984cec26403bbefa27b76/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f7b74678b21c5c104c984cec26403bbefa27b76/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=2f7b74678b21c5c104c984cec26403bbefa27b76", "patch": "@@ -6119,10 +6119,16 @@ package body Sem_Ch8 is\n                   --  is completed in the current scope, and not for a limited\n                   --  view of a type.\n \n-                  if not Is_Tagged_Type (T)\n-                    and then Ada_Version >= Ada_2005\n-                  then\n-                     if From_With_Type (T) then\n+                  if Ada_Version >= Ada_2005 then\n+\n+                     --  Test whether the Available_View of a limited type view\n+                     --  is tagged, since the limited view may not be marked as\n+                     --  tagged if the type itself has an untagged incomplete\n+                     --  type view in its package.\n+\n+                     if From_With_Type (T)\n+                       and then not Is_Tagged_Type (Available_View (T))\n+                     then\n                         Error_Msg_N\n                           (\"prefix of Class attribute must be tagged\", N);\n                         Set_Etype (N, Any_Type);"}]}