{"sha": "ec10f7c7036edcb58649048bef39ade57fc12594", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWMxMGY3YzcwMzZlZGNiNTg2NDkwNDhiZWYzOWFkZTU3ZmMxMjU5NA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-12-10T01:09:42Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2001-12-10T01:09:42Z"}, "message": "cfgcleanup.c (label_is_jump_target_p): New function.\n\n\t* cfgcleanup.c (label_is_jump_target_p): New function.\n\t(try_optimize_cfg): Use label_is_jump_target_p to check if label is\n\ttarget of a JUMP_INSN from the preceding block.\n\nFrom-SVN: r47825", "tree": {"sha": "7bea52dbe36fa4767e6c3e4e27b986e33e8527df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7bea52dbe36fa4767e6c3e4e27b986e33e8527df"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec10f7c7036edcb58649048bef39ade57fc12594", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec10f7c7036edcb58649048bef39ade57fc12594", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec10f7c7036edcb58649048bef39ade57fc12594", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec10f7c7036edcb58649048bef39ade57fc12594/comments", "author": null, "committer": null, "parents": [{"sha": "cca9fe755eae01916e8e399de9ce76871257a0bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cca9fe755eae01916e8e399de9ce76871257a0bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cca9fe755eae01916e8e399de9ce76871257a0bb"}], "stats": {"total": 49, "additions": 46, "deletions": 3}, "files": [{"sha": "9c3dcdab4c0349c705397ed4a0778b81e8dddbf7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec10f7c7036edcb58649048bef39ade57fc12594/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec10f7c7036edcb58649048bef39ade57fc12594/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ec10f7c7036edcb58649048bef39ade57fc12594", "patch": "@@ -1,3 +1,9 @@\n+2001-12-09  Richard Henderson  <rth@redhat.com>\n+\n+\t* cfgcleanup.c (label_is_jump_target_p): New function.\n+\t(try_optimize_cfg): Use label_is_jump_target_p to check if label is\n+\ttarget of a JUMP_INSN from the preceding block.\n+\n Sun Dec  9 18:40:07 2001  Douglas B. Rupp  <rupp@gnat.com>\n \n \t* vmsdbgout.c (lookup_filename): Assign null string instead"}, {"sha": "526202a3f32d9ad29fb07e32fdc32ea61f384fd7", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 40, "deletions": 3, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec10f7c7036edcb58649048bef39ade57fc12594/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec10f7c7036edcb58649048bef39ade57fc12594/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=ec10f7c7036edcb58649048bef39ade57fc12594", "patch": "@@ -69,6 +69,7 @@ static int flow_find_cross_jump\t\tPARAMS ((int, basic_block, basic_block,\n \t\t\t\t\t\t rtx *, rtx *));\n \n static bool delete_unreachable_blocks\tPARAMS ((void));\n+static bool label_is_jump_target_p\tPARAMS ((rtx, rtx));\n static bool tail_recursion_label_p\tPARAMS ((rtx));\n static void merge_blocks_move_predecessor_nojumps PARAMS ((basic_block,\n \t\t\t\t\t\t\t  basic_block));\n@@ -291,6 +292,38 @@ try_forward_edges (mode, b)\n   return changed;\n }\n \f\n+/* Return true if LABEL is a target of JUMP_INSN.  This applies only\n+   to non-complex jumps.  That is, direct unconditional, conditional,\n+   and tablejumps, but not computed jumps or returns.  It also does\n+   not apply to the fallthru case of a conditional jump.  */\n+\n+static bool\n+label_is_jump_target_p (label, jump_insn)\n+     rtx label, jump_insn;\n+{\n+  rtx tmp = JUMP_LABEL (jump_insn);\n+\n+  if (label == tmp)\n+    return true;\n+\n+  if (tmp != NULL_RTX\n+      && (tmp = NEXT_INSN (tmp)) != NULL_RTX\n+      && GET_CODE (tmp) == JUMP_INSN\n+      && (tmp = PATTERN (tmp),\n+\t  GET_CODE (tmp) == ADDR_VEC\n+\t  || GET_CODE (tmp) == ADDR_DIFF_VEC))\n+    {\n+      rtvec vec = XVEC (tmp, GET_CODE (tmp) == ADDR_DIFF_VEC);\n+      int i, veclen = GET_NUM_ELEM (vec);\n+\n+      for (i = 0; i < veclen; ++i)\n+\tif (XEXP (RTVEC_ELT (vec, i), 0) == label)\n+\t  return true;\n+    }\n+\n+  return false;\n+}\n+\n /* Return true if LABEL is used for tail recursion.  */\n \n static bool\n@@ -1162,10 +1195,14 @@ try_optimize_cfg (mode)\n \t      && GET_CODE (b->head) == CODE_LABEL\n \t      && (!(mode & CLEANUP_PRE_SIBCALL)\n \t\t  || !tail_recursion_label_p (b->head))\n-\t      /* If previous block ends with condjump jumping to next BB,\n-\t         we can't delete the label.  */\n+\t      /* If the previous block ends with a branch to this block,\n+\t\t we can't delete the label.  Normally this is a condjump\n+\t\t that is yet to be simplified, but if CASE_DROPS_THRU,\n+\t\t this can be a tablejump with some element going to the\n+\t\t same place as the default (fallthru).  */\n \t      && (b->pred->src == ENTRY_BLOCK_PTR\n-\t\t  || !reg_mentioned_p (b->head, b->pred->src->end)))\n+\t\t  || GET_CODE (b->pred->src->end) != JUMP_INSN\n+\t\t  || ! label_is_jump_target_p (b->head, b->pred->src->end)))\n \t    {\n \t      rtx label = b->head;\n \t      b->head = NEXT_INSN (b->head);"}]}