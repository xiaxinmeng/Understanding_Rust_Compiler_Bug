{"sha": "834e660ea8e0fbf26d937aa641aacaeeff7c5d60", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODM0ZTY2MGVhOGUwZmJmMjZkOTM3YWE2NDFhYWNhZWVmZjdjNWQ2MA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2020-05-05T10:35:00Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2020-05-07T08:54:09Z"}, "message": "Fix a few DWARF bugs with -fgnat-encodings=minimal\n\nThe -fgnat-encodings=minimal switch tells the compiler to generate mostly\npure DWARF for the GNAT compiler and it contains some bugs related to\ndiscriminated record types with variant part.\n\n\t* dwarf2out.c (add_data_member_location_attribute): Account for\n\tthe variant part offset in the computation of the data bit offset.\n\t(add_bit_offset_attribute): Remove CTX parameter.  Pass a new\n\tcontext in the call to field_byte_offset.\n\t(gen_field_die): Adjust call to add_bit_offset_attribute and\n\tremove confusing assertion.\n\t(analyze_variant_discr): Deal with boolean subtypes.", "tree": {"sha": "a96ba1c5e5be9ae1a75c714ed4d5aee876af2603", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a96ba1c5e5be9ae1a75c714ed4d5aee876af2603"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/834e660ea8e0fbf26d937aa641aacaeeff7c5d60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/834e660ea8e0fbf26d937aa641aacaeeff7c5d60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/834e660ea8e0fbf26d937aa641aacaeeff7c5d60", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/834e660ea8e0fbf26d937aa641aacaeeff7c5d60/comments", "author": null, "committer": null, "parents": [{"sha": "b24fc8a692e3f2a8bd89d7ccb230ad3c72323e73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b24fc8a692e3f2a8bd89d7ccb230ad3c72323e73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b24fc8a692e3f2a8bd89d7ccb230ad3c72323e73"}], "stats": {"total": 72, "additions": 58, "deletions": 14}, "files": [{"sha": "19d5167aa6b4780800309168581262ae5cdcb3dc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/834e660ea8e0fbf26d937aa641aacaeeff7c5d60/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/834e660ea8e0fbf26d937aa641aacaeeff7c5d60/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=834e660ea8e0fbf26d937aa641aacaeeff7c5d60", "patch": "@@ -1,3 +1,14 @@\n+2020-05-07  Eric Botcazou  <ebotcazou@adacore.com>\n+            Pierre-Marie de Rodat  <derodat@adacore.com>\n+\n+\t* dwarf2out.c (add_data_member_location_attribute): Take into account\n+\tthe variant part offset in the computation of the data bit offset.\n+\t(add_bit_offset_attribute): Remove CTX parameter.  Pass a new context\n+\tin the call to field_byte_offset.\n+\t(gen_field_die): Adjust call to add_bit_offset_attribute and remove\n+\tconfusing assertion.\n+\t(analyze_variant_discr): Deal with boolean subtypes.\n+\n 2020-05-07  Martin Liska  <mliska@suse.cz>\n \n \t* lto-wrapper.c: Split arguments of MAKE environment"}, {"sha": "396446f7670ad8274355cebfc2b2643115d84944", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/834e660ea8e0fbf26d937aa641aacaeeff7c5d60/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/834e660ea8e0fbf26d937aa641aacaeeff7c5d60/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=834e660ea8e0fbf26d937aa641aacaeeff7c5d60", "patch": "@@ -3828,8 +3828,7 @@ static void add_bound_info (dw_die_ref, enum dwarf_attribute, tree,\n static void add_subscript_info (dw_die_ref, tree, bool);\n static void add_byte_size_attribute (dw_die_ref, tree);\n static void add_alignment_attribute (dw_die_ref, tree);\n-static inline void add_bit_offset_attribute (dw_die_ref, tree,\n-\t\t\t\t\t     struct vlr_context *);\n+static void add_bit_offset_attribute (dw_die_ref, tree);\n static void add_bit_size_attribute (dw_die_ref, tree);\n static void add_prototyped_attribute (dw_die_ref, tree);\n static void add_abstract_origin_attribute (dw_die_ref, tree);\n@@ -19118,6 +19117,7 @@ struct vlr_context\n      QUAL_UNION_TYPE nodes.  Each time such a structure is passed to a\n      function processing a FIELD_DECL, it is required to be non null.  */\n   tree struct_type;\n+\n   /* When generating a variant part in a RECORD_TYPE (i.e. a nested\n      QUAL_UNION_TYPE), this holds an expression that computes the offset for\n      this variant part as part of the root record (in storage units).  For\n@@ -19456,9 +19456,13 @@ add_data_member_location_attribute (dw_die_ref die,\n \t to dwarf_version >= 4 once most consumers catched up.  */\n       if (dwarf_version >= 5\n \t  && TREE_CODE (decl) == FIELD_DECL\n-\t  && DECL_BIT_FIELD_TYPE (decl))\n+\t  && DECL_BIT_FIELD_TYPE (decl)\n+\t  && (ctx->variant_part_offset == NULL_TREE\n+\t      || TREE_CODE (ctx->variant_part_offset) == INTEGER_CST))\n \t{\n \t  tree off = bit_position (decl);\n+\t  if (ctx->variant_part_offset)\n+\t    off = bit_from_pos (ctx->variant_part_offset, off);\n \t  if (tree_fits_uhwi_p (off) && get_AT (die, DW_AT_bit_size))\n \t    {\n \t      remove_AT (die, DW_AT_byte_size);\n@@ -21095,14 +21099,12 @@ add_alignment_attribute (dw_die_ref die, tree tree_node)\n    exact location of the \"containing object\" for a bit-field is rather\n    complicated.  It's handled by the `field_byte_offset' function (above).\n \n-   CTX is required: see the comment for VLR_CONTEXT.\n-\n    Note that it is the size (in bytes) of the hypothetical \"containing object\"\n    which will be given in the DW_AT_byte_size attribute for this bit-field.\n    (See `byte_size_attribute' above).  */\n \n static inline void\n-add_bit_offset_attribute (dw_die_ref die, tree decl, struct vlr_context *ctx)\n+add_bit_offset_attribute (dw_die_ref die, tree decl)\n {\n   HOST_WIDE_INT object_offset_in_bytes;\n   tree original_type = DECL_BIT_FIELD_TYPE (decl);\n@@ -21111,7 +21113,10 @@ add_bit_offset_attribute (dw_die_ref die, tree decl, struct vlr_context *ctx)\n   HOST_WIDE_INT highest_order_field_bit_offset;\n   HOST_WIDE_INT bit_offset;\n \n-  field_byte_offset (decl, ctx, &object_offset_in_bytes);\n+  /* The containing object is within the DECL_CONTEXT.  */\n+  struct vlr_context ctx = { DECL_CONTEXT (decl), NULL_TREE };\n+\n+  field_byte_offset (decl, &ctx, &object_offset_in_bytes);\n \n   /* Must be a field and a bit field.  */\n   gcc_assert (original_type && TREE_CODE (decl) == FIELD_DECL);\n@@ -24279,16 +24284,11 @@ gen_field_die (tree decl, struct vlr_context *ctx, dw_die_ref context_die)\n     {\n       add_byte_size_attribute (decl_die, decl);\n       add_bit_size_attribute (decl_die, decl);\n-      add_bit_offset_attribute (decl_die, decl, ctx);\n+      add_bit_offset_attribute (decl_die, decl);\n     }\n \n   add_alignment_attribute (decl_die, decl);\n \n-  /* If we have a variant part offset, then we are supposed to process a member\n-     of a QUAL_UNION_TYPE, which is how we represent variant parts in\n-     trees.  */\n-  gcc_assert (ctx->variant_part_offset == NULL_TREE\n-\t      || TREE_CODE (DECL_FIELD_CONTEXT (decl)) != QUAL_UNION_TYPE);\n   if (TREE_CODE (DECL_FIELD_CONTEXT (decl)) != UNION_TYPE)\n     add_data_member_location_attribute (decl_die, decl, ctx);\n \n@@ -24883,7 +24883,9 @@ analyze_variants_discr (tree variant_part_decl,\n \n \t  else if ((candidate_discr\n \t\t      = analyze_discr_in_predicate (match_expr, struct_type))\n-\t\t   && TREE_TYPE (candidate_discr) == boolean_type_node)\n+\t\t   && (TREE_TYPE (candidate_discr) == boolean_type_node\n+\t\t       || TREE_TYPE (TREE_TYPE (candidate_discr))\n+\t\t\t  == boolean_type_node))\n \t    {\n \t      /* We are matching:  <discr_field> for a boolean discriminant.\n \t\t This sub-expression matches boolean_true_node.  */"}, {"sha": "22ad03d914e5590d3f03164ae04b4023ac9e7006", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/834e660ea8e0fbf26d937aa641aacaeeff7c5d60/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/834e660ea8e0fbf26d937aa641aacaeeff7c5d60/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=834e660ea8e0fbf26d937aa641aacaeeff7c5d60", "patch": "@@ -1,3 +1,7 @@\n+2020-05-07  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/debug16.adb: New test.\n+\n 2020-05-06  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/94938"}, {"sha": "8752002ec9b82df7c832173265ed7be11e4dd2ab", "filename": "gcc/testsuite/gnat.dg/debug16.adb", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/834e660ea8e0fbf26d937aa641aacaeeff7c5d60/gcc%2Ftestsuite%2Fgnat.dg%2Fdebug16.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/834e660ea8e0fbf26d937aa641aacaeeff7c5d60/gcc%2Ftestsuite%2Fgnat.dg%2Fdebug16.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fdebug16.adb?ref=834e660ea8e0fbf26d937aa641aacaeeff7c5d60", "patch": "@@ -0,0 +1,27 @@\n+--  { dg-do compile }\n+--  { dg-skip-if \"No Dwarf\" { { hppa*-*-hpux* } && { ! lp64 } } }\n+--  { dg-options \"-cargs -O0 -g -dA -fgnat-encodings=minimal -margs\" }\n+\n+procedure Debug16 is\n+\n+   type Number_T (Exists : Boolean := False) is\n+      record\n+         case Exists is\n+            when True =>\n+               Value : Natural range 0 .. 255;\n+            when False =>\n+               null;\n+         end case;\n+      end record;\n+   pragma Pack (Number_T);\n+\n+   X : Number_T;\n+\n+begin\n+   X := (Exists => True, Value => 10);\n+   if X.Exists then -- STOP\n+      X.Value := X.Value + 1;\n+   end if;\n+end;\n+\n+--  { dg-final { scan-assembler-times \"DW_AT_discr\" 4 } }"}]}