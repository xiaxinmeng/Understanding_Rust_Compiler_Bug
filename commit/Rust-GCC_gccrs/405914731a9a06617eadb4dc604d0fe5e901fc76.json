{"sha": "405914731a9a06617eadb4dc604d0fe5e901fc76", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDA1OTE0NzMxYTlhMDY2MTdlYWRiNGRjNjA0ZDBmZTVlOTAxZmM3Ng==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2011-04-19T16:15:08Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2011-04-19T16:15:08Z"}, "message": "ipa-cp.c (ipcp_process_devirtualization_opportunities): Take into account anc_offset and otr_type from the indirect edge info.\n\n2011-04-19  Martin Jambor  <mjambor@suse.cz>\n\n\t* ipa-cp.c (ipcp_process_devirtualization_opportunities): Take into\n\taccount anc_offset and otr_type from the indirect edge info.\n\t* ipa-prop.c (get_ancestor_addr_info): New function.\n\t(compute_complex_ancestor_jump_func): Assignment analysis moved to\n\tget_ancestor_addr_info, call it.\n\t(ipa_note_param_call): Do not initialize information about polymorphic\n\tcalls, return the indirect call graph edge.  Remove the last\n\tparameter, adjust all callers.\n\t(ipa_analyze_virtual_call_uses): Process also calls to ancestors of\n\tparameters.  Initialize polymorphic information in the indirect edge.\n\n\t* testsuite/g++.dg/ipa/devirt-7.C: New test.\n\nFrom-SVN: r172716", "tree": {"sha": "b1d1a05c105bd85d01b847d720bd2f7aed85afcc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b1d1a05c105bd85d01b847d720bd2f7aed85afcc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/405914731a9a06617eadb4dc604d0fe5e901fc76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/405914731a9a06617eadb4dc604d0fe5e901fc76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/405914731a9a06617eadb4dc604d0fe5e901fc76", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/405914731a9a06617eadb4dc604d0fe5e901fc76/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7c589800e2ecee0587396ef30140e1b541f229a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c589800e2ecee0587396ef30140e1b541f229a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c589800e2ecee0587396ef30140e1b541f229a2"}], "stats": {"total": 265, "additions": 211, "deletions": 54}, "files": [{"sha": "7ada452d6ef24f0ac7869519acd4b25a7ee706c1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405914731a9a06617eadb4dc604d0fe5e901fc76/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405914731a9a06617eadb4dc604d0fe5e901fc76/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=405914731a9a06617eadb4dc604d0fe5e901fc76", "patch": "@@ -1,3 +1,16 @@\n+2011-04-19  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* ipa-cp.c (ipcp_process_devirtualization_opportunities): Take into\n+\taccount anc_offset and otr_type from the indirect edge info.\n+\t* ipa-prop.c (get_ancestor_addr_info): New function.\n+\t(compute_complex_ancestor_jump_func): Assignment analysis moved to\n+\tget_ancestor_addr_info, call it.\n+\t(ipa_note_param_call): Do not initialize information about polymorphic\n+\tcalls, return the indirect call graph edge.  Remove the last\n+\tparameter, adjust all callers.\n+\t(ipa_analyze_virtual_call_uses): Process also calls to ancestors of\n+\tparameters.  Initialize polymorphic information in the indirect edge.\n+\n 2011-04-19  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR lto/48148"}, {"sha": "f7413f22a51ec6214c59877283a17cfbe431c127", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405914731a9a06617eadb4dc604d0fe5e901fc76/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405914731a9a06617eadb4dc604d0fe5e901fc76/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=405914731a9a06617eadb4dc604d0fe5e901fc76", "patch": "@@ -1247,8 +1247,8 @@ ipcp_process_devirtualization_opportunities (struct cgraph_node *node)\n   for (ie = node->indirect_calls; ie; ie = next_ie)\n     {\n       int param_index, types_count, j;\n-      HOST_WIDE_INT token;\n-      tree target, delta;\n+      HOST_WIDE_INT token, anc_offset;\n+      tree target, delta, otr_type;\n \n       next_ie = ie->next_callee;\n       if (!ie->indirect_info->polymorphic)\n@@ -1260,14 +1260,23 @@ ipcp_process_devirtualization_opportunities (struct cgraph_node *node)\n \tcontinue;\n \n       token = ie->indirect_info->otr_token;\n+      anc_offset = ie->indirect_info->anc_offset;\n+      otr_type = ie->indirect_info->otr_type;\n       target = NULL_TREE;\n       types_count = VEC_length (tree, info->params[param_index].types);\n       for (j = 0; j < types_count; j++)\n \t{\n \t  tree binfo = VEC_index (tree, info->params[param_index].types, j);\n-\t  tree d;\n-\t  tree t = gimple_get_virt_method_for_binfo (token, binfo, &d, true);\n+\t  tree d, t;\n \n+\t  binfo = get_binfo_at_offset (binfo, anc_offset, otr_type);\n+\t  if (!binfo)\n+\t    {\n+\t      target = NULL_TREE;\n+\t      break;\n+\t    }\n+\n+\t  t = gimple_get_virt_method_for_binfo (token, binfo, &d, true);\n \t  if (!t)\n \t    {\n \t      target = NULL_TREE;"}, {"sha": "c482165a6f38f38cc23103358c67bef6f5ff524a", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 94, "deletions": 50, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405914731a9a06617eadb4dc604d0fe5e901fc76/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405914731a9a06617eadb4dc604d0fe5e901fc76/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=405914731a9a06617eadb4dc604d0fe5e901fc76", "patch": "@@ -576,6 +576,50 @@ compute_complex_assign_jump_func (struct ipa_node_params *info,\n     }\n }\n \n+/* Extract the base, offset and MEM_REF expression from a statement ASSIGN if\n+   it looks like:\n+\n+   iftmp.1_3 = &obj_2(D)->D.1762;\n+\n+   The base of the MEM_REF must be a default definition SSA NAME of a\n+   parameter.  Return NULL_TREE if it looks otherwise.  If case of success, the\n+   whole MEM_REF expression is returned and the offset calculated from any\n+   handled components and the MEM_REF itself is stored into *OFFSET.  The whole\n+   RHS stripped off the ADDR_EXPR is stored into *OBJ_P.  */\n+\n+static tree\n+get_ancestor_addr_info (gimple assign, tree *obj_p, HOST_WIDE_INT *offset)\n+{\n+  HOST_WIDE_INT size, max_size;\n+  tree expr, parm, obj;\n+\n+  if (!gimple_assign_single_p (assign))\n+    return NULL_TREE;\n+  expr = gimple_assign_rhs1 (assign);\n+\n+  if (TREE_CODE (expr) != ADDR_EXPR)\n+    return NULL_TREE;\n+  expr = TREE_OPERAND (expr, 0);\n+  obj = expr;\n+  expr = get_ref_base_and_extent (expr, offset, &size, &max_size);\n+\n+  if (TREE_CODE (expr) != MEM_REF\n+      /* If this is a varying address, punt.  */\n+      || max_size == -1\n+      || max_size != size\n+      || *offset < 0)\n+    return NULL_TREE;\n+  parm = TREE_OPERAND (expr, 0);\n+  if (TREE_CODE (parm) != SSA_NAME\n+      || !SSA_NAME_IS_DEFAULT_DEF (parm)\n+      || TREE_CODE (SSA_NAME_VAR (parm)) != PARM_DECL)\n+    return NULL_TREE;\n+\n+  *offset += mem_ref_offset (expr).low * BITS_PER_UNIT;\n+  *obj_p = obj;\n+  return expr;\n+}\n+\n \n /* Given that an actual argument is an SSA_NAME that is a result of a phi\n    statement PHI, try to find out whether NAME is in fact a\n@@ -603,7 +647,7 @@ compute_complex_ancestor_jump_func (struct ipa_node_params *info,\n \t\t\t\t    struct ipa_jump_func *jfunc,\n \t\t\t\t    gimple call, gimple phi)\n {\n-  HOST_WIDE_INT offset, size, max_size;\n+  HOST_WIDE_INT offset;\n   gimple assign, cond;\n   basic_block phi_bb, assign_bb, cond_bb;\n   tree tmp, parm, expr, obj;\n@@ -626,32 +670,14 @@ compute_complex_ancestor_jump_func (struct ipa_node_params *info,\n \n   assign = SSA_NAME_DEF_STMT (tmp);\n   assign_bb = gimple_bb (assign);\n-  if (!single_pred_p (assign_bb)\n-      || !gimple_assign_single_p (assign))\n+  if (!single_pred_p (assign_bb))\n     return;\n-  expr = gimple_assign_rhs1 (assign);\n-\n-  if (TREE_CODE (expr) != ADDR_EXPR)\n+  expr = get_ancestor_addr_info (assign, &obj, &offset);\n+  if (!expr)\n     return;\n-  expr = TREE_OPERAND (expr, 0);\n-  obj = expr;\n-  expr = get_ref_base_and_extent (expr, &offset, &size, &max_size);\n-\n-  if (TREE_CODE (expr) != MEM_REF\n-      /* If this is a varying address, punt.  */\n-      || max_size == -1\n-      || max_size != size)\n-    return;\n-  offset += mem_ref_offset (expr).low * BITS_PER_UNIT;\n   parm = TREE_OPERAND (expr, 0);\n-  if (TREE_CODE (parm) != SSA_NAME\n-      || !SSA_NAME_IS_DEFAULT_DEF (parm)\n-      || offset < 0)\n-    return;\n-\n   index = ipa_get_param_decl_index (info, SSA_NAME_VAR (parm));\n-  if (index < 0)\n-    return;\n+  gcc_assert (index >= 0);\n \n   cond_bb = single_pred (assign_bb);\n   cond = last_stmt (cond_bb);\n@@ -675,7 +701,7 @@ compute_complex_ancestor_jump_func (struct ipa_node_params *info,\n       jfunc->type = IPA_JF_ANCESTOR;\n       jfunc->value.ancestor.formal_id = index;\n       jfunc->value.ancestor.offset = offset;\n-      jfunc->value.ancestor.type = TREE_TYPE (obj);;\n+      jfunc->value.ancestor.type = TREE_TYPE (obj);\n     }\n }\n \n@@ -1162,29 +1188,20 @@ ipa_is_ssa_with_stmt_def (tree t)\n     return false;\n }\n \n-/* Find the indirect call graph edge corresponding to STMT and add to it all\n-   information necessary to describe a call to a parameter number PARAM_INDEX.\n-   NODE is the caller.  POLYMORPHIC should be set to true iff the call is a\n-   virtual one.  */\n+/* Find the indirect call graph edge corresponding to STMT and mark it as a\n+   call to a parameter number PARAM_INDEX.  NODE is the caller.  Return the\n+   indirect call graph edge.  */\n \n-static void\n-ipa_note_param_call (struct cgraph_node *node, int param_index, gimple stmt,\n-\t\t     bool polymorphic)\n+static struct cgraph_edge *\n+ipa_note_param_call (struct cgraph_node *node, int param_index, gimple stmt)\n {\n   struct cgraph_edge *cs;\n \n   cs = cgraph_edge (node, stmt);\n   cs->indirect_info->param_index = param_index;\n   cs->indirect_info->anc_offset = 0;\n-  cs->indirect_info->polymorphic = polymorphic;\n-  if (polymorphic)\n-    {\n-      tree otr = gimple_call_fn (stmt);\n-      tree type, token = OBJ_TYPE_REF_TOKEN (otr);\n-      cs->indirect_info->otr_token = tree_low_cst (token, 1);\n-      type = TREE_TYPE (TREE_TYPE (OBJ_TYPE_REF_OBJECT (otr)));\n-      cs->indirect_info->otr_type = type;\n-    }\n+  cs->indirect_info->polymorphic = 0;\n+  return cs;\n }\n \n /* Analyze the CALL and examine uses of formal parameters of the caller NODE\n@@ -1263,7 +1280,7 @@ ipa_analyze_indirect_call_uses (struct cgraph_node *node,\n       tree var = SSA_NAME_VAR (target);\n       index = ipa_get_param_decl_index (info, var);\n       if (index >= 0)\n-\tipa_note_param_call (node, index, call, false);\n+\tipa_note_param_call (node, index, call);\n       return;\n     }\n \n@@ -1361,7 +1378,7 @@ ipa_analyze_indirect_call_uses (struct cgraph_node *node,\n   index = ipa_get_param_decl_index (info, rec);\n   if (index >= 0 && !is_parm_modified_before_call (&parms_info[index],\n \t\t\t\t\t\t   call, rec))\n-    ipa_note_param_call (node, index, call, false);\n+    ipa_note_param_call (node, index, call);\n \n   return;\n }\n@@ -1375,24 +1392,51 @@ ipa_analyze_virtual_call_uses (struct cgraph_node *node,\n \t\t\t       struct ipa_node_params *info, gimple call,\n \t\t\t       tree target)\n {\n+  struct cgraph_edge *cs;\n+  struct cgraph_indirect_call_info *ii;\n   struct ipa_jump_func jfunc;\n   tree obj = OBJ_TYPE_REF_OBJECT (target);\n-  tree var;\n   int index;\n+  HOST_WIDE_INT anc_offset;\n \n   if (!flag_devirtualize)\n     return;\n \n-  if (TREE_CODE (obj) != SSA_NAME\n-      || !SSA_NAME_IS_DEFAULT_DEF (obj))\n+  if (TREE_CODE (obj) != SSA_NAME)\n     return;\n \n-  var = SSA_NAME_VAR (obj);\n-  index = ipa_get_param_decl_index (info, var);\n+  if (SSA_NAME_IS_DEFAULT_DEF (obj))\n+    {\n+      if (TREE_CODE (SSA_NAME_VAR (obj)) != PARM_DECL)\n+\treturn;\n \n-  if (index >= 0\n-      && !detect_type_change_ssa (obj, call, &jfunc))\n-    ipa_note_param_call (node, index, call, true);\n+      anc_offset = 0;\n+      index = ipa_get_param_decl_index (info, SSA_NAME_VAR (obj));\n+      gcc_assert (index >= 0);\n+      if (detect_type_change_ssa (obj, call, &jfunc))\n+\treturn;\n+    }\n+  else\n+    {\n+      gimple stmt = SSA_NAME_DEF_STMT (obj);\n+      tree expr;\n+\n+      expr = get_ancestor_addr_info (stmt, &obj, &anc_offset);\n+      if (!expr)\n+\treturn;\n+      index = ipa_get_param_decl_index (info,\n+\t\t\t\t\tSSA_NAME_VAR (TREE_OPERAND (expr, 0)));\n+      gcc_assert (index >= 0);\n+      if (detect_type_change (obj, expr, call, &jfunc, anc_offset))\n+\treturn;\n+    }\n+\n+  cs = ipa_note_param_call (node, index, call);\n+  ii = cs->indirect_info;\n+  ii->anc_offset = anc_offset;\n+  ii->otr_token = tree_low_cst (OBJ_TYPE_REF_TOKEN (target), 1);\n+  ii->otr_type = TREE_TYPE (TREE_TYPE (OBJ_TYPE_REF_OBJECT (target)));\n+  ii->polymorphic = 1;\n }\n \n /* Analyze a call statement CALL whether and how it utilizes formal parameters"}, {"sha": "49bd36795ccaa501a6bf763cbf88734ce5c2e0a4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405914731a9a06617eadb4dc604d0fe5e901fc76/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405914731a9a06617eadb4dc604d0fe5e901fc76/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=405914731a9a06617eadb4dc604d0fe5e901fc76", "patch": "@@ -1,3 +1,7 @@\n+2011-04-19  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* g++.dg/ipa/devirt-7.C: New test.\n+\n 2011-04-19  Richard Guenther  <rguenther@suse.de>\n \n \tPR lto/48207"}, {"sha": "ac147b57599fb1adaa297de14c60ac97a7ee9586", "filename": "gcc/testsuite/g++.dg/ipa/devirt-7.C", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405914731a9a06617eadb4dc604d0fe5e901fc76/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405914731a9a06617eadb4dc604d0fe5e901fc76/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-7.C?ref=405914731a9a06617eadb4dc604d0fe5e901fc76", "patch": "@@ -0,0 +1,87 @@\n+/* Verify that IPA-CP can do devirtualization even if the virtual call\n+   comes from a method that has been early-inlined into a descendant.  */\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -fdump-ipa-cp\"  } */\n+\n+extern \"C\" void abort (void);\n+\n+class Distraction\n+{\n+public:\n+  float f;\n+  double d;\n+  Distraction ()\n+  {\n+    f = 8.3;\n+    d = 10.2;\n+  }\n+  virtual float bar (float z);\n+};\n+\n+class A\n+{\n+public:\n+  int data;\n+  virtual int foo (int i);\n+  int middleman_1 (int i);\n+};\n+\n+\n+class B : public Distraction, public A\n+{\n+public:\n+  virtual int foo (int i);\n+  int middleman_2 (int i);\n+  __attribute__ ((noinline)) B();\n+};\n+\n+float Distraction::bar (float z)\n+{\n+  f += z;\n+  return f/2;\n+}\n+\n+int A::foo (int i)\n+{\n+  return i + 1;\n+}\n+\n+int B::foo (int i)\n+{\n+  return i + 2;\n+}\n+\n+int __attribute__ ((noinline,noclone)) get_input(void)\n+{\n+  return 1;\n+}\n+\n+int __attribute__ ((always_inline))\n+A::middleman_1 (int i)\n+{\n+  return this->foo (i);\n+}\n+\n+int __attribute__ ((noinline))\n+B::middleman_2 (int i)\n+{\n+  return this->middleman_1 (i);\n+}\n+\n+B::B ()\n+{\n+}\n+\n+int main (int argc, char *argv[])\n+{\n+  class B b;\n+  int i;\n+\n+  for (i = 0; i < get_input(); i++)\n+    if (b.middleman_2 (get_input ()) != 3)\n+      abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-ipa-dump \"Discovered a virtual call to a known target.*B::foo\"  \"cp\"  } } */\n+/* { dg-final { cleanup-ipa-dump \"cp\" } } */"}]}