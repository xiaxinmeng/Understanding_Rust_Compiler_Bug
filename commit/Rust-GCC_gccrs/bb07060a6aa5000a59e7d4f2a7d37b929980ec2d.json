{"sha": "bb07060a6aa5000a59e7d4f2a7d37b929980ec2d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmIwNzA2MGE2YWE1MDAwYTU5ZTdkNGYyYTdkMzdiOTI5OTgwZWMyZA==", "commit": {"author": {"name": "John Wehle", "email": "john@feith.com", "date": "2000-09-13T06:27:16Z"}, "committer": {"name": "John Wehle", "email": "wehle@gcc.gnu.org", "date": "2000-09-13T06:27:16Z"}, "message": "alias.c (find_base_term): Use frame_pointer_rtx when handling an ADDRESSOF.\n\n\t* alias.c (find_base_term): Use frame_pointer_rtx\n\twhen handling an ADDRESSOF.\n\n\t* cse.c (canon_hash): Handle USE of BLKmode memory.\n\t(cse_insn): Outgoing arguments for a libcall don't\n\taffect any recorded expressions.\n\nFrom-SVN: r36384", "tree": {"sha": "6d053274503c8c34e42c3c2a121565419548e2ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d053274503c8c34e42c3c2a121565419548e2ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bb07060a6aa5000a59e7d4f2a7d37b929980ec2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb07060a6aa5000a59e7d4f2a7d37b929980ec2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb07060a6aa5000a59e7d4f2a7d37b929980ec2d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb07060a6aa5000a59e7d4f2a7d37b929980ec2d/comments", "author": {"login": "jlwehle", "id": 46985578, "node_id": "MDQ6VXNlcjQ2OTg1NTc4", "avatar_url": "https://avatars.githubusercontent.com/u/46985578?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jlwehle", "html_url": "https://github.com/jlwehle", "followers_url": "https://api.github.com/users/jlwehle/followers", "following_url": "https://api.github.com/users/jlwehle/following{/other_user}", "gists_url": "https://api.github.com/users/jlwehle/gists{/gist_id}", "starred_url": "https://api.github.com/users/jlwehle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jlwehle/subscriptions", "organizations_url": "https://api.github.com/users/jlwehle/orgs", "repos_url": "https://api.github.com/users/jlwehle/repos", "events_url": "https://api.github.com/users/jlwehle/events{/privacy}", "received_events_url": "https://api.github.com/users/jlwehle/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d21445e714fbef35a64b1ae05f8625c395e73890", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d21445e714fbef35a64b1ae05f8625c395e73890", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d21445e714fbef35a64b1ae05f8625c395e73890"}], "stats": {"total": 53, "additions": 48, "deletions": 5}, "files": [{"sha": "15f235d404aa41a976e75d5d3767671cd7988405", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb07060a6aa5000a59e7d4f2a7d37b929980ec2d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb07060a6aa5000a59e7d4f2a7d37b929980ec2d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bb07060a6aa5000a59e7d4f2a7d37b929980ec2d", "patch": "@@ -1,3 +1,12 @@\n+Wed Sep 13 02:31:23 EDT 2000  John Wehle  (john@feith.com)\n+\n+\t* alias.c (find_base_term): Use frame_pointer_rtx\n+\twhen handling an ADDRESSOF.\n+\n+\t* cse.c (canon_hash): Handle USE of BLKmode memory.\n+\t(cse_insn): Outgoing arguments for a libcall don't\n+\taffect any recorded expressions.\n+\n 2000-09-12  Tom Tromey  <tromey@cygnus.com>\n \n \t* configure, config.in: Rebuilt."}, {"sha": "32d63b269c51a03d2e04d698426470f7a93f57a7", "filename": "gcc/alias.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb07060a6aa5000a59e7d4f2a7d37b929980ec2d/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb07060a6aa5000a59e7d4f2a7d37b929980ec2d/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=bb07060a6aa5000a59e7d4f2a7d37b929980ec2d", "patch": "@@ -1132,7 +1132,7 @@ find_base_term (x)\n       return x;\n \n     case ADDRESSOF:\n-      return REG_BASE_VALUE (stack_pointer_rtx);\n+      return REG_BASE_VALUE (frame_pointer_rtx);\n \n     default:\n       return 0;"}, {"sha": "2396889c7d0f5241e47884be317121c9f305060d", "filename": "gcc/cse.c", "status": "modified", "additions": 38, "deletions": 4, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb07060a6aa5000a59e7d4f2a7d37b929980ec2d/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb07060a6aa5000a59e7d4f2a7d37b929980ec2d/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=bb07060a6aa5000a59e7d4f2a7d37b929980ec2d", "patch": "@@ -2352,6 +2352,28 @@ canon_hash (x, mode)\n       x = XEXP (x, 0);\n       goto repeat;\n \n+    case USE:\n+      /* A USE that mentions non-volatile memory needs special\n+\t handling since the MEM may be BLKmode which normally\n+\t prevents an entry from being made.  Pure calls are\n+\t marked by a USE which mentions BLKmode memory.  */\n+      if (GET_CODE (XEXP (x, 0)) == MEM\n+\t  && ! MEM_VOLATILE_P (XEXP (x, 0)))\n+\t{\n+\t  hash += (unsigned)USE;\n+\t  x = XEXP (x, 0);\n+\n+\t  if (! RTX_UNCHANGING_P (x) || FIXED_BASE_PLUS_P (XEXP (x, 0)))\n+\t    hash_arg_in_memory = 1;\n+\n+\t  /* Now that we have already found this special case,\n+\t     might as well speed it up as much as possible.  */\n+\t  hash += (unsigned) MEM;\n+\t  x = XEXP (x, 0);\n+\t  goto repeat;\n+\t}\n+      break;\n+\n     case PRE_DEC:\n     case PRE_INC:\n     case POST_DEC:\n@@ -5760,9 +5782,15 @@ cse_insn (insn, libcall_insn)\n \n       else if (do_not_record)\n \t{\n-\t  if (GET_CODE (dest) == REG || GET_CODE (dest) == SUBREG\n-\t      || GET_CODE (dest) == MEM)\n+\t  if (GET_CODE (dest) == REG || GET_CODE (dest) == SUBREG)\n \t    invalidate (dest, VOIDmode);\n+\t  else if (GET_CODE (dest) == MEM)\n+\t    {\n+\t      /* Outgoing arguments for a libcall don't\n+\t\t affect any recorded expressions.  */\n+\t      if (! libcall_insn || insn == libcall_insn)\n+\t\tinvalidate (dest, VOIDmode);\n+\t    }\n \t  else if (GET_CODE (dest) == STRICT_LOW_PART\n \t\t   || GET_CODE (dest) == ZERO_EXTRACT)\n \t    invalidate (XEXP (dest, 0), GET_MODE (dest));\n@@ -5919,9 +5947,15 @@ cse_insn (insn, libcall_insn)\n \t   previous quantity's chain.\n \t   Needed for memory if this is a nonvarying address, unless\n \t   we have just done an invalidate_memory that covers even those.  */\n-\tif (GET_CODE (dest) == REG || GET_CODE (dest) == SUBREG\n-\t    || GET_CODE (dest) == MEM)\n+\tif (GET_CODE (dest) == REG || GET_CODE (dest) == SUBREG)\n \t  invalidate (dest, VOIDmode);\n+\telse if (GET_CODE (dest) == MEM)\n+\t  {\n+\t    /* Outgoing arguments for a libcall don't\n+\t       affect any recorded expressions.  */\n+\t    if (! libcall_insn || insn == libcall_insn)\n+\t      invalidate (dest, VOIDmode);\n+\t  }\n \telse if (GET_CODE (dest) == STRICT_LOW_PART\n \t\t || GET_CODE (dest) == ZERO_EXTRACT)\n \t  invalidate (XEXP (dest, 0), GET_MODE (dest));"}]}