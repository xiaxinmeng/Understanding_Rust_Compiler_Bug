{"sha": "e48addeebcc08efa9cd2a13fd2e70e2c92db26d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTQ4YWRkZWViY2MwOGVmYTljZDJhMTNmZDJlNzBlMmM5MmRiMjZkOA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "1999-11-30T22:18:21Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-11-30T22:18:21Z"}, "message": "Jakub Jelinek  <jakub@redhat.com>\n\n        * config/sparc/sparc.h (FIXED_REGISTERS, CONDITIONAL_REGISTER_USAGE):\n        Allow the user to override call-used/fixed state of %g2-5\n        registers from the command line (with the exception of %g4 for\n        embedded model).\n        (REG_LEAF_ALLOC_ORDER): Move %g1 and %g4-7 registers to front, so that\n        there is a higher chance of having a leaf function.\n        (MACHINE_STATE_SAVE, MACHINE_STATE_RESTORE): Provide separate macros\n        for ARCH64 which has %ccr register.\n        * config/sparc/sparc.md (return_losum_si, return_losum_di): New\n        patterns.\n        * config/sparc/sparc.c (eligible_for_epilogue_delay): For the return\n        insn accept into delay slot any insn which does not use %[ol]\n        registers.  Accept some LO_SUM and shift left by 1 for the normal\n        restore case.\n        (output_function_epilogue): Likewise.\n        (epilogue_renumber): Added argument which inhibits any renumbering\n        and just tests if the rtx does not use any %[ol] registers.\n        (output_return): Reflect above change.\n\nFrom-SVN: r30727", "tree": {"sha": "a0aa3f53fbb63793261d833b1f8613a481049e03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a0aa3f53fbb63793261d833b1f8613a481049e03"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e48addeebcc08efa9cd2a13fd2e70e2c92db26d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e48addeebcc08efa9cd2a13fd2e70e2c92db26d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e48addeebcc08efa9cd2a13fd2e70e2c92db26d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e48addeebcc08efa9cd2a13fd2e70e2c92db26d8/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f34e52f774c16f4042cc44ddb471dd141a5dc583", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f34e52f774c16f4042cc44ddb471dd141a5dc583", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f34e52f774c16f4042cc44ddb471dd141a5dc583"}], "stats": {"total": 295, "additions": 220, "deletions": 75}, "files": [{"sha": "6210e8ae6087f36d51ac3f0310df64b511192d74", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e48addeebcc08efa9cd2a13fd2e70e2c92db26d8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e48addeebcc08efa9cd2a13fd2e70e2c92db26d8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e48addeebcc08efa9cd2a13fd2e70e2c92db26d8", "patch": "@@ -1,3 +1,24 @@\n+1999-11-30  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* config/sparc/sparc.h (FIXED_REGISTERS, CONDITIONAL_REGISTER_USAGE):\n+\tAllow the user to override call-used/fixed state of %g2-5\n+\tregisters from the command line (with the exception of %g4 for\n+\tembedded model).\n+\t(REG_LEAF_ALLOC_ORDER): Move %g1 and %g4-7 registers to front, so that\n+\tthere is a higher chance of having a leaf function.\n+\t(MACHINE_STATE_SAVE, MACHINE_STATE_RESTORE): Provide separate macros\n+\tfor ARCH64 which has %ccr register.\n+\t* config/sparc/sparc.md (return_losum_si, return_losum_di): New\n+\tpatterns.\n+\t* config/sparc/sparc.c (eligible_for_epilogue_delay): For the return\n+\tinsn accept into delay slot any insn which does not use %[ol]\n+\tregisters.  Accept some LO_SUM and shift left by 1 for the normal\n+\trestore case.\n+\t(output_function_epilogue): Likewise.\n+\t(epilogue_renumber): Added argument which inhibits any renumbering\n+\tand just tests if the rtx does not use any %[ol] registers.\n+\t(output_return): Reflect above change.\n+\n 1999-11-30  Jakub Jelinek  <jakub@redhat.com>\n \n \t* config/sparc/sparc.c (sparc_va_arg): Fix sparc64 va_arg"}, {"sha": "22c0fbffbc9e232d83282c78d07d509698b42318", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 111, "deletions": 58, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e48addeebcc08efa9cd2a13fd2e70e2c92db26d8/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e48addeebcc08efa9cd2a13fd2e70e2c92db26d8/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=e48addeebcc08efa9cd2a13fd2e70e2c92db26d8", "patch": "@@ -63,6 +63,10 @@ Boston, MA 02111-1307, USA.  */\n static int apparent_fsize;\n static int actual_fsize;\n \n+/* Number of live general or floating point registers needed to be saved\n+   (as 4-byte quantities).  This is only done if TARGET_EPILOGUE.  */\n+static int num_gfregs;\n+\n /* Save the operands last given to a compare for use when we\n    generate a scc or bcc insn.  */\n \n@@ -124,7 +128,7 @@ static void sparc_output_deferred_case_vectors PROTO((void));\n static void sparc_add_gc_roots    PROTO ((void));\n static void mark_ultrasparc_pipeline_state PROTO ((void *));\n static int check_return_regs PROTO ((rtx));\n-static void epilogue_renumber PROTO ((rtx *));\n+static int epilogue_renumber PROTO ((rtx *, int));\n static int ultra_cmove_results_ready_p PROTO ((rtx));\n static int ultra_fpmode_conflict_exists PROTO ((enum machine_mode));\n static rtx *ultra_find_type PROTO ((int, rtx *, int));\n@@ -2208,6 +2212,11 @@ eligible_for_epilogue_delay (trial, slot)\n      optimize things as necessary.  */\n   if (TARGET_LIVE_G0)\n     return 0;\n+    \n+  /* If there are any call-saved registers, we should scan TRIAL if it\n+     does not reference them.  For now just make it easy.  */\n+  if (num_gfregs)\n+    return 0;\n \n   /* In the case of a true leaf function, anything can go into the delay slot.\n      A delay slot only exists however if the frame size is zero, otherwise\n@@ -2228,7 +2237,7 @@ eligible_for_epilogue_delay (trial, slot)\n   pat = PATTERN (trial);\n \n   /* Otherwise, only operations which can be done in tandem with\n-     a `restore' insn can go into the delay slot.  */\n+     a `restore' or `return' insn can go into the delay slot.  */\n   if (GET_CODE (SET_DEST (pat)) != REG\n       || REGNO (SET_DEST (pat)) >= 32\n       || REGNO (SET_DEST (pat)) < 24)\n@@ -2247,7 +2256,7 @@ eligible_for_epilogue_delay (trial, slot)\n       else\n         return GET_MODE_SIZE (GET_MODE (src)) <= GET_MODE_SIZE (SImode);\n     }\n-    \n+\n   /* This matches \"*return_di\".  */\n   else if (arith_double_operand (src, GET_MODE (src)))\n     return GET_MODE_SIZE (GET_MODE (src)) <= GET_MODE_SIZE (DImode);\n@@ -2257,6 +2266,12 @@ eligible_for_epilogue_delay (trial, slot)\n \t   && register_operand (src, SFmode))\n     return 1;\n \n+  /* If we have return instruction, anything that does not use\n+     local or output registers and can go into a delay slot wins.  */\n+  else if (TARGET_V9 && ! epilogue_renumber (&pat, 1)\n+\t   && (get_attr_in_uncond_branch_delay (trial) == IN_BRANCH_DELAY_TRUE))\n+    return 1;\n+\n   /* This matches \"*return_addsi\".  */\n   else if (GET_CODE (src) == PLUS\n \t   && arith_operand (XEXP (src, 0), SImode)\n@@ -2273,6 +2288,25 @@ eligible_for_epilogue_delay (trial, slot)\n \t       || register_operand (XEXP (src, 1), DImode)))\n     return 1;\n \n+  /* This can match \"*return_losum_[sd]i\".\n+     Catch only some cases, so that return_losum* don't have\n+     to be too big.  */\n+  else if (GET_CODE (src) == LO_SUM\n+\t   && ! TARGET_CM_MEDMID\n+\t   && ((register_operand (XEXP (src, 0), SImode)\n+\t        && immediate_operand (XEXP (src, 1), SImode))\n+\t       || (TARGET_ARCH64\n+\t\t   && register_operand (XEXP (src, 0), DImode)\n+\t\t   && immediate_operand (XEXP (src, 1), DImode))))\n+    return 1;\n+\n+  /* sll{,x} reg,1,reg2 is add reg,reg,reg2 as well.  */\n+  else if (GET_CODE (src) == ASHIFT\n+\t   && (register_operand (XEXP (src, 0), SImode)\n+\t       || register_operand (XEXP (src, 0), DImode))\n+\t   && XEXP (src, 1) == const1_rtx)\n+    return 1;\n+\n   return 0;\n }\n \n@@ -2979,12 +3013,6 @@ restore_regs (file, low, high, base, offset, n_regs)\n   return n_regs;\n }\n \n-/* Static variables we want to share between prologue and epilogue.  */\n-\n-/* Number of live general or floating point registers needed to be saved\n-   (as 4-byte quantities).  This is only done if TARGET_EPILOGUE.  */\n-static int num_gfregs;\n-\n /* Compute the frame size required by the function.  This function is called\n    during the reload pass and also by output_function_prologue().  */\n \n@@ -3283,7 +3311,7 @@ output_function_epilogue (file, size, leaf_function)\n #endif\n \n   else if (current_function_epilogue_delay_list == 0)\n-    {                                                \n+    {\n       /* If code does not drop into the epilogue, we need\n \t do nothing except output pending case vectors.  */\n       rtx insn = get_last_insn ();                               \n@@ -3339,13 +3367,38 @@ output_function_epilogue (file, size, leaf_function)\n \t  /* If we wound up with things in our delay slot, flush them here.  */\n \t  if (current_function_epilogue_delay_list)\n \t    {\n-\t      rtx insn = emit_jump_insn_after (gen_rtx_RETURN (VOIDmode),\n-\t\t\t\t\t       get_last_insn ());\n-\t      PATTERN (insn) = gen_rtx_PARALLEL (VOIDmode,\n-\t\t\t\t\tgen_rtvec (2,\n-\t\t\t\t\t\t   PATTERN (XEXP (current_function_epilogue_delay_list, 0)),\n-\t\t\t\t\t\t   PATTERN (insn)));\n-\t      final_scan_insn (insn, file, 1, 0, 1);\n+\t      rtx delay = PATTERN (XEXP (current_function_epilogue_delay_list, 0));\n+\n+\t      if (TARGET_V9 && ! epilogue_renumber (&delay, 1))\n+\t\t{\n+\t\t  epilogue_renumber (&delay, 0);\n+\t\t  fputs (SKIP_CALLERS_UNIMP_P\n+\t\t\t ? \"\\treturn\\t%i7+12\\n\"\n+\t\t\t : \"\\treturn\\t%i7+8\\n\", file);\n+\t\t  final_scan_insn (XEXP (current_function_epilogue_delay_list, 0), file, 1, 0, 0);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  rtx insn = emit_jump_insn_after (gen_rtx_RETURN (VOIDmode),\n+\t\t\t\t\t\t   get_last_insn ());\n+\t\t  rtx src;\n+\n+\t\t  if (GET_CODE (delay) != SET)\n+\t\t    abort();\n+\n+\t\t  src = SET_SRC (delay);\n+\t\t  if (GET_CODE (src) == ASHIFT)\n+\t\t    {\n+\t\t      if (XEXP (src, 1) != const1_rtx)\n+\t\t\tabort();\n+\t\t      SET_SRC (delay) = gen_rtx_PLUS (GET_MODE (src), XEXP (src, 0),\n+\t\t\t\t\t\t      XEXP (src, 0));\n+\t\t    }\n+\n+\t\t  PATTERN (insn) = gen_rtx_PARALLEL (VOIDmode,\n+\t\t\t\t\tgen_rtvec (2, delay, PATTERN (insn)));\n+\t\t  final_scan_insn (insn, file, 1, 0, 1);\n+\t\t}\n \t    }\n \t  else if (TARGET_V9 && ! SKIP_CALLERS_UNIMP_P)\n \t    fputs (\"\\treturn\\t%i7+8\\n\\tnop\\n\", file);\n@@ -4726,56 +4779,56 @@ output_v9branch (op, reg, label, reversed, annul, noop, insn)\n   return string;\n }\n \n-/* Renumber registers in delay slot.  Replace registers instead of\n-   renumbering because they may be shared.\n-\n-   This does not handle instructions other than move.  */\n+/* Return 1, if any of the registers of the instruction are %l[0-7] or %o[0-7].\n+   Such instructions cannot be used in the delay slot of return insn on v9.\n+   If TEST is 0, also rename all %i[0-7] registers to their %o[0-7] counterparts.\n+ */\n \n-static void\n-epilogue_renumber (where)\n-     rtx *where;\n+static int\n+epilogue_renumber (where, test)\n+     register rtx *where;\n+     int test;\n {\n-  rtx x = *where;\n-  enum rtx_code code = GET_CODE (x);\n+  register const char *fmt;\n+  register int i;\n+  register enum rtx_code code;\n+\n+  if (*where == 0)\n+    return 0;\n+\n+  code = GET_CODE (*where);\n \n   switch (code)\n     {\n-    case MEM:\n-      *where = x = copy_rtx (x);\n-      epilogue_renumber (&XEXP (x, 0));\n-      return;\n-\n     case REG:\n-      {\n-\tint regno = REGNO (x);\n-\tif (regno > 8 && regno < 24)\n-\t  abort ();\n-\tif (regno >= 24 && regno < 32)\n-\t  *where = gen_rtx_REG (GET_MODE (x), regno - 16);\n-\treturn;\n-      }\n+      if (REGNO (*where) >= 8 && REGNO (*where) < 24)      /* oX or lX */\n+\treturn 1;\n+      if (! test && REGNO (*where) >= 24 && REGNO (*where) < 32)\n+\t*where = gen_rtx (REG, GET_MODE (*where), OUTGOING_REGNO (REGNO(*where)));\n+    case SCRATCH:\n+    case CC0:\n+    case PC:\n     case CONST_INT:\n     case CONST_DOUBLE:\n-    case CONST:\n-    case SYMBOL_REF:\n-    case LABEL_REF:\n-      return;\n+      return 0;\n+    }\n \n-    case IOR:\n-    case AND:\n-    case XOR:\n-    case PLUS:\n-    case MINUS:\n-      epilogue_renumber (&XEXP (x, 1));\n-    case NEG:\n-    case NOT:\n-      epilogue_renumber (&XEXP (x, 0));\n-      return;\n+  fmt = GET_RTX_FORMAT (code);\n \n-    default:\n-      debug_rtx (*where);\n-      abort ();\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'E')\n+\t{\n+\t  register int j;\n+\t  for (j = XVECLEN (*where, i) - 1; j >= 0; j--)\n+\t    if (epilogue_renumber (&(XVECEXP (*where, i, j)), test))\n+\t      return 1;\n+\t}\n+      else if (fmt[i] == 'e'\n+\t       && epilogue_renumber (&(XEXP (*where, i)), test))\n+\treturn 1;\n     }\n+  return 0;\n }\n \n /* Output assembler code to return from a function.  */\n@@ -4840,8 +4893,8 @@ output_return (operands)\n     {\n       if (delay)\n \t{\n-\t  epilogue_renumber (&SET_DEST (PATTERN (delay)));\n-\t  epilogue_renumber (&SET_SRC (PATTERN (delay)));\n+\t  epilogue_renumber (&SET_DEST (PATTERN (delay)), 0);\n+\t  epilogue_renumber (&SET_SRC (PATTERN (delay)), 0);\n \t}\n       if (SKIP_CALLERS_UNIMP_P)\n \treturn \"return\\t%%i7+12%#\";"}, {"sha": "f402b837245c27d228820ce9a87a14412cd6ad50", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 61, "deletions": 17, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e48addeebcc08efa9cd2a13fd2e70e2c92db26d8/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e48addeebcc08efa9cd2a13fd2e70e2c92db26d8/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=e48addeebcc08efa9cd2a13fd2e70e2c92db26d8", "patch": "@@ -962,7 +962,7 @@ if (TARGET_ARCH64\t\t\t\t\\\n */\n \n #define FIXED_REGISTERS  \\\n- {1, 0, 0, 0, 0, 0, 1, 1,\t\\\n+ {1, 0, 2, 2, 2, 2, 1, 1,\t\\\n   0, 0, 0, 0, 0, 0, 1, 0,\t\\\n   0, 0, 0, 0, 0, 0, 0, 0,\t\\\n   0, 0, 0, 0, 0, 0, 1, 1,\t\\\n@@ -1015,10 +1015,12 @@ do\t\t\t\t\t\t\t\t\\\n \tfixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\t\\\n \tcall_used_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\t\\\n       }\t\t\t\t\t\t\t\t\\\n-    if (TARGET_ARCH32)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-\tfixed_regs[5] = 1;\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n+    /* If the user has passed -f{fixed,call-{used,saved}}-g5 */\t\\\n+    /* then honour it.  */\t\t\t\t\t\\\n+    if (TARGET_ARCH32 && fixed_regs[5])\t\t\t\t\\\n+      fixed_regs[5] = 1;\t\t\t\t\t\\\n+    else if (TARGET_ARCH64 && fixed_regs[5] == 2)\t\t\\\n+      fixed_regs[5] = 0;\t\t\t\t\t\\\n     if (TARGET_LIVE_G0)\t\t\t\t\t\t\\\n       fixed_regs[0] = 0;\t\t\t\t\t\\\n     if (! TARGET_V9)\t\t\t\t\t\t\\\n@@ -1040,10 +1042,18 @@ do\t\t\t\t\t\t\t\t\\\n \tfor (regno = 32; regno < SPARC_LAST_V9_FCC_REG; regno++) \\\n \t  fixed_regs[regno] = 1;\t\t\t\t\\\n       }\t\t\t\t\t\t\t\t\\\n-    /* Don't unfix g2-g4 if they were fixed with -ffixed-.  */\t\\\n-    fixed_regs[2] |= ! TARGET_APP_REGS;\t\t\t\t\\\n-    fixed_regs[3] |= ! TARGET_APP_REGS;\t\t\t\t\\\n-    fixed_regs[4] |= ! TARGET_APP_REGS || TARGET_CM_EMBMEDANY;\t\\\n+    /* If the user has passed -f{fixed,call-{used,saved}}-g2 */\t\\\n+    /* then honour it.  Likewise with g3 and g4.  */\t\t\\\n+    if (fixed_regs[2] == 2)\t\t\t\t\t\\\n+      fixed_regs[2] = ! TARGET_APP_REGS;\t\t\t\\\n+    if (fixed_regs[3] == 2)\t\t\t\t\t\\\n+      fixed_regs[3] = ! TARGET_APP_REGS;\t\t\t\\\n+    if (TARGET_ARCH32 && fixed_regs[4] == 2)\t\t\t\\\n+      fixed_regs[4] = ! TARGET_APP_REGS;\t\t\t\\\n+    else if (TARGET_CM_EMBMEDANY)\t\t\t\t\\\n+      fixed_regs[4] = 1;\t\t\t\t\t\\\n+    else if (fixed_regs[4] == 2)\t\t\t\t\\\n+      fixed_regs[4] = 0;\t\t\t\t\t\\\n     if (TARGET_FLAT)\t\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\\\n \t/* Let the compiler believe the frame pointer is still\t\\\n@@ -1335,11 +1345,12 @@ extern enum reg_class sparc_regno_reg_class[];\n   1, 4, 5, 6, 7, 0, 14, 30}\n \n /* This is the order in which to allocate registers for\n-   leaf functions.  If all registers can fit in the \"i\" registers,\n+   leaf functions.  If all registers can fit in the \"gi\" registers,\n    then we have the possibility of having a leaf function.  */\n \n #define REG_LEAF_ALLOC_ORDER \\\n { 2, 3, 24, 25, 26, 27, 28, 29,\t\t\\\n+  4, 5, 6, 7, 1,\t\t\t\\\n   15, 8, 9, 10, 11, 12, 13,\t\t\\\n   16, 17, 18, 19, 20, 21, 22, 23,\t\\\n   34, 35, 36, 37, 38, 39,\t\t\\\n@@ -1352,8 +1363,8 @@ extern enum reg_class sparc_regno_reg_class[];\n   88, 89, 90, 91, 92, 93, 94, 95,\t\\\n   32, 33,\t\t\t\t\\\n   96, 97, 98, 99, 100,\t\t\t\\\n-  1, 4, 5, 6, 7, 0, 14, 30, 31}\n-\n+  0, 14, 30, 31}\n+  \n #define ORDER_REGS_FOR_LOCAL_ALLOC order_regs_for_local_alloc ()\n \n /* ??? %g7 is not a leaf register to effectively #undef LEAF_REGISTERS when\n@@ -1889,6 +1900,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define FUNCTION_BLOCK_PROFILER_EXIT(FILE) \\\n   sparc_function_block_profiler_exit(FILE)\n \n+#ifdef IN_LIBGCC2\n+\n /* The function `__bb_trace_func' is called in every basic block\n    and is not allowed to change the machine state. Saving (restoring)\n    the state can either be done in the BLOCK_PROFILER macro,\n@@ -1908,12 +1921,18 @@ do {\t\t\t\t\t\t\t\t\t\\\n    On sparc it is sufficient to save the psw register to memory.\n    Unfortunately the psw register can be read in supervisor mode only,\n    so we read only the condition codes by using branch instructions\n-   and hope that this is enough. */\n+   and hope that this is enough.\n+   \n+   On V9, life is much sweater:  there is a user accessible %ccr\n+   register, but we use it for 64bit libraries only.  */\n+\n+#if TARGET_ARCH32\n \n #define MACHINE_STATE_SAVE(ID)\t\t\t\\\n   int ms_flags, ms_saveret;\t\t\t\\\n   asm volatile(\t\t\t\t\t\\\n-\t\"mov %%g0,%0\\n\\\n+\t\"mov %%g2,%1\\n\\\n+\tmov %%g0,%0\\n\\\n \tbe,a LFLGNZ\"ID\"\\n\\\n \tor %0,4,%0\\n\\\n LFLGNZ\"ID\":\\n\\\n@@ -1925,10 +1944,20 @@ LFLGNC\"ID\":\\n\\\n LFLGNV\"ID\":\\n\\\n \tbneg,a LFLGNN\"ID\"\\n\\\n \tor %0,8,%0\\n\\\n-LFLGNN\"ID\":\\n\\\n-\tmov %%g2,%1\"\t\t\t\t\\\n+LFLGNN\"ID\":\"\t\t\t\t\t\\\n+\t: \"=r\"(ms_flags), \"=r\"(ms_saveret));\n+\n+#else\n+\n+#define MACHINE_STATE_SAVE(ID)\t\t\t\\\n+  unsigned long ms_flags, ms_saveret;\t\t\\\n+  asm volatile(\t\t\t\t\t\\\n+\t\"mov %%g2,%1\\n\\\t\t\t\t\\\n+\trd %%ccr,%0\"\t\t\t\t\\\n \t: \"=r\"(ms_flags), \"=r\"(ms_saveret));\n \n+#endif\n+\n /* On sparc MACHINE_STATE_RESTORE restores the psw register from memory.\n    The psw register can be written in supervisor mode only,\n    which is true even for simple condition codes.\n@@ -1937,6 +1966,8 @@ LFLGNN\"ID\":\\n\\\n    be generated in this way. If this happens an unimplemented\n    instruction will be executed to abort the program. */\n \n+#if TARGET_ARCH32\n+\n #define MACHINE_STATE_RESTORE(ID)\t\t\t\t\\\n { extern char flgtab[] __asm__(\"LFLGTAB\"ID);\t\t\t\\\n   int scratch;\t\t\t\t\t\t\t\\\n@@ -1995,7 +2026,20 @@ LFLGRET\"ID\":\\n\\\n \t: \"=r\"(scratch)\t\t\t\t\t\t\\\n \t: \"r\"(ms_flags*8), \"r\"(flgtab), \"r\"(-1),\t\t\\\n \t  \"r\"(0x80000000), \"r\"(ms_saveret)\t\t\t\\\n-\t: \"cc\", \"%g2\"); }\n+\t: \"cc\", \"g2\"); }\n+\n+#else\n+\n+#define MACHINE_STATE_RESTORE(ID)\t\t\t\t\\\n+  asm volatile (\t\t\t\t\t\t\\\n+\t\"wr %0,0,%%ccr\\n\\\n+\tmov %1,%%g2\"\t\t\t\t\t\t\\\n+\t: : \"r\"(ms_flags), \"r\"(ms_saveret)\t\t\t\\\n+\t: \"cc\", \"g2\");\n+\n+#endif\n+\n+#endif /* IN_LIBGCC2 */\n \f\n /* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n    the stack pointer does not matter.  The value is tested only in"}, {"sha": "95c686852273a623eabd1282c6f498463a5a1778", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e48addeebcc08efa9cd2a13fd2e70e2c92db26d8/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e48addeebcc08efa9cd2a13fd2e70e2c92db26d8/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=e48addeebcc08efa9cd2a13fd2e70e2c92db26d8", "patch": "@@ -8191,6 +8191,24 @@\n }\"\n   [(set_attr \"type\" \"multi\")])\n \n+(define_insn \"*return_losum_si\"\n+  [(set (match_operand:SI 0 \"restore_operand\" \"\")\n+\t(lo_sum:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t   (match_operand:SI 2 \"immediate_operand\" \"in\")))\n+   (return)]\n+  \"! TARGET_EPILOGUE && ! TARGET_LIVE_G0 && ! TARGET_CM_MEDMID\"\n+  \"*\n+{\n+  if (! TARGET_ARCH64 && current_function_returns_struct)\n+    return \\\"jmp\\\\t%%i7+12\\\\n\\\\trestore %r1, %%lo(%a2), %Y0\\\";\n+  /* If operands are global or in registers, can use return */\n+  else if (TARGET_V9 && IN_OR_GLOBAL_P (operands[1]))\n+    return \\\"return\\\\t%%i7+8\\\\n\\\\tor\\\\t%Y1, %%lo(%a2), %Y0\\\";\n+  else\n+    return \\\"ret\\;restore %r1, %%lo(%a2), %Y0\\\";\n+}\"\n+  [(set_attr \"type\" \"multi\")])\n+\n (define_insn \"*return_di\"\n   [(set (match_operand:DI 0 \"restore_operand\" \"\")\n \t(match_operand:DI 1 \"arith_double_operand\" \"rHI\"))\n@@ -8208,6 +8226,15 @@\n   \"ret\\;restore %r1, %2, %Y0\"\n   [(set_attr \"type\" \"multi\")])\n \n+(define_insn \"*return_losum_di\"\n+  [(set (match_operand:DI 0 \"restore_operand\" \"\")\n+\t(lo_sum:DI (match_operand:DI 1 \"arith_operand\" \"%r\")\n+\t\t   (match_operand:DI 2 \"immediate_operand\" \"in\")))\n+   (return)]\n+  \"TARGET_ARCH64 && ! TARGET_EPILOGUE && ! TARGET_CM_MEDMID\"\n+  \"ret\\;restore %r1, %%lo(a2), %Y0\"\n+  [(set_attr \"type\" \"multi\")])\n+\n ;; The following pattern is only generated by delayed-branch scheduling,\n ;; when the insn winds up in the epilogue.\n (define_insn \"*return_sf\""}]}