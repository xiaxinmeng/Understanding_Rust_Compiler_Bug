{"sha": "009890be6c6e3f34630be0f086303d42c6aa867b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDA5ODkwYmU2YzZlM2YzNDYzMGJlMGYwODYzMDNkNDJjNmFhODY3Yg==", "commit": {"author": {"name": "Olivier Hainque", "email": "hainque@adacore.com", "date": "2008-04-21T09:20:29Z"}, "committer": {"name": "Olivier Hainque", "email": "hainque@gcc.gnu.org", "date": "2008-04-21T09:20:29Z"}, "message": "Access to most C builtins from Ada\n\n2008-04-21  Olivier Hainque  <hainque@adacore.com>\n\nada/\n        Access to most C builtins from Ada\n        * utils.c: #include \"langhooks.h\" and define GCC_DIAG_STYLE.\n        (handle_pure_attribute, handle_novops_attribute,\n        handle_nonnull_attribute, handle_sentinel_attribute,\n        handle_noreturn_attribute, handle_malloc_attribute,\n        handle_type_generic_attribute): New attribute handlers, from C fe.\n        (gnat_internal_attribute_table): Map the new handlers.\n        (gnat_init_decl_processing): Move call to gnat_install_builtins to ...\n        (init_gigi_decls): ... here.\n        (handle_const_attribute, handle_nothrow_attribute, builtin_decl_for):\n        Move to a section dedicated to builtins processing.\n        (build_void_list_node, builtin_type_for_size): New functions.\n        (def_fn_type, get_nonnull_operand): Likewise.\n        (install_builtin_elementary_type, install_builtin_function_types,\n        install_builtin_attributes): Likewise.\n        (fake_attribute_handler): Fake handler for attributes we don't\n        support in Ada.\n        (def_builtin_1): New function, worker for DEF_BUILTIN.\n        (install_builtin_functions): New function.\n        (gnat_install_builtins): Move to the builtins processing section.\n        Now calling the newly introduced installers.\n\ntestsuite/\n        * gnat.dg/bltins.adb: New testcase.\n\nFrom-SVN: r134504", "tree": {"sha": "2b1bea3b93d788f69fb0e45c9825d752b2cd7d59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b1bea3b93d788f69fb0e45c9825d752b2cd7d59"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/009890be6c6e3f34630be0f086303d42c6aa867b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/009890be6c6e3f34630be0f086303d42c6aa867b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/009890be6c6e3f34630be0f086303d42c6aa867b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/009890be6c6e3f34630be0f086303d42c6aa867b/comments", "author": {"login": "hainque", "id": 18735142, "node_id": "MDQ6VXNlcjE4NzM1MTQy", "avatar_url": "https://avatars.githubusercontent.com/u/18735142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hainque", "html_url": "https://github.com/hainque", "followers_url": "https://api.github.com/users/hainque/followers", "following_url": "https://api.github.com/users/hainque/following{/other_user}", "gists_url": "https://api.github.com/users/hainque/gists{/gist_id}", "starred_url": "https://api.github.com/users/hainque/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hainque/subscriptions", "organizations_url": "https://api.github.com/users/hainque/orgs", "repos_url": "https://api.github.com/users/hainque/repos", "events_url": "https://api.github.com/users/hainque/events{/privacy}", "received_events_url": "https://api.github.com/users/hainque/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d82b799ce5aeb104f1cf6962be547149ab405530", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d82b799ce5aeb104f1cf6962be547149ab405530", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d82b799ce5aeb104f1cf6962be547149ab405530"}], "stats": {"total": 825, "additions": 753, "deletions": 72}, "files": [{"sha": "79f8440982cdb280bbc02d08038eaf42fc4ddb12", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/009890be6c6e3f34630be0f086303d42c6aa867b/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/009890be6c6e3f34630be0f086303d42c6aa867b/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=009890be6c6e3f34630be0f086303d42c6aa867b", "patch": "@@ -1,3 +1,27 @@\n+2008-04-21  Olivier Hainque  <hainque@adacore.com>\n+\n+\tAccess to most C builtins from Ada\n+\t* utils.c: #include \"langhooks.h\" and define GCC_DIAG_STYLE.\n+\t(handle_pure_attribute, handle_novops_attribute,\n+\thandle_nonnull_attribute, handle_sentinel_attribute,\n+\thandle_noreturn_attribute, handle_malloc_attribute,\n+\thandle_type_generic_attribute): New attribute handlers, from C fe.\n+\t(gnat_internal_attribute_table): Map the new handlers.\n+\t(gnat_init_decl_processing): Move call to gnat_install_builtins to ...\n+\t(init_gigi_decls): ... here.\n+\t(handle_const_attribute, handle_nothrow_attribute, builtin_decl_for):\n+\tMove to a section dedicated to builtins processing.\n+\t(build_void_list_node, builtin_type_for_size): New functions.\n+\t(def_fn_type, get_nonnull_operand): Likewise.\n+\t(install_builtin_elementary_type, install_builtin_function_types,\n+\tinstall_builtin_attributes): Likewise.\n+\t(fake_attribute_handler): Fake handler for attributes we don't\n+\tsupport in Ada.\n+\t(def_builtin_1): New function, worker for DEF_BUILTIN.\n+\t(install_builtin_functions): New function.\n+\t(gnat_install_builtins): Move to the builtins processing section.\n+\tNow calling the newly introduced installers.\n+\n 2008-04-20  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* decl.c (gnat_to_gnu_entity) <object>: Also promote the alignment of"}, {"sha": "498904136cc677df00bb1a03f0d982752e78ab96", "filename": "gcc/ada/Make-lang.in", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/009890be6c6e3f34630be0f086303d42c6aa867b/gcc%2Fada%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/009890be6c6e3f34630be0f086303d42c6aa867b/gcc%2Fada%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMake-lang.in?ref=009890be6c6e3f34630be0f086303d42c6aa867b", "patch": "@@ -1125,10 +1125,10 @@ ada/trans.o : ada/trans.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(ADA_TREE_H) ada/gigi.h gt-ada-trans.h\n \n ada/utils.o : ada/utils.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n-   $(TREE_H) $(FLAGS_H) $(EXPR_H) convert.h defaults.h ada/ada.h ada/types.h \\\n-   ada/atree.h ada/nlists.h ada/elists.h ada/sinfo.h ada/einfo.h ada/namet.h \\\n-   ada/stringt.h ada/uintp.h ada/fe.h $(ADA_TREE_H) ada/gigi.h gt-ada-utils.h \\\n-   gtype-ada.h $(TARGET_H)\n+   $(TREE_H) $(FLAGS_H) $(EXPR_H) convert.h defaults.h langhooks.h \\\n+   ada/ada.h ada/types.h ada/atree.h ada/nlists.h ada/elists.h ada/sinfo.h \\\n+   ada/einfo.h ada/namet.h ada/stringt.h ada/uintp.h ada/fe.h $(ADA_TREE_H) \\\n+   ada/gigi.h gt-ada-utils.h gtype-ada.h $(TARGET_H)\n \n ada/utils2.o : ada/utils2.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) $(FLAGS_H) ada/ada.h ada/types.h ada/atree.h ada/nlists.h \\"}, {"sha": "d6a2234e747b1ad725ce96679cca3c623a96620c", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 709, "deletions": 68, "changes": 777, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/009890be6c6e3f34630be0f086303d42c6aa867b/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/009890be6c6e3f34630be0f086303d42c6aa867b/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=009890be6c6e3f34630be0f086303d42c6aa867b", "patch": "@@ -23,6 +23,10 @@\n  *                                                                          *\n  ****************************************************************************/\n \n+/* We have attribute handlers using C specific format specifiers in warning\n+   messages.  Make sure they are properly recognized.  */\n+#define GCC_DIAG_STYLE __gcc_cdiag__\n+\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n@@ -42,6 +46,7 @@\n #include \"tree-gimple.h\"\n #include \"tree-dump.h\"\n #include \"pointer-set.h\"\n+#include \"langhooks.h\"\n \n #include \"ada.h\"\n #include \"types.h\"\n@@ -77,16 +82,40 @@ tree gnat_raise_decls[(int) LAST_REASON_CODE + 1];\n /* Forward declarations for handlers of attributes.  */\n static tree handle_const_attribute (tree *, tree, tree, int, bool *);\n static tree handle_nothrow_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_pure_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_novops_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_nonnull_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_sentinel_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_noreturn_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_malloc_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_type_generic_attribute (tree *, tree, tree, int, bool *);\n+\n+/* Fake handler for attributes we don't properly support, typically because\n+   they'd require dragging a lot of the common-c front-end circuitry.  */\n+static tree fake_attribute_handler      (tree *, tree, tree, int, bool *);\n \n /* Table of machine-independent internal attributes for Ada.  We support\n-   this minimal set of attributes to accommodate the Alpha back-end which\n-   unconditionally puts them on its builtins.  */\n+   this minimal set ot attributes to accomodate the needs of builtins.  */\n const struct attribute_spec gnat_internal_attribute_table[] =\n {\n   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n-  { \"const\",   0, 0, true,  false, false, handle_const_attribute   },\n-  { \"nothrow\", 0, 0, true,  false, false, handle_nothrow_attribute },\n-  { NULL,      0, 0, false, false, false, NULL }\n+  { \"const\",        0, 0,  true,  false, false, handle_const_attribute   },\n+  { \"nothrow\",      0, 0,  true,  false, false, handle_nothrow_attribute },\n+  { \"pure\",         0, 0,  true,  false, false, handle_pure_attribute },\n+  { \"no vops\",      0, 0,  true,  false, false, handle_novops_attribute },\n+  { \"nonnull\",      0, -1, false, true,  true,  handle_nonnull_attribute },\n+  { \"sentinel\",     0, 1,  false, true,  true,  handle_sentinel_attribute },\n+  { \"noreturn\",     0, 0,  true,  false, false, handle_noreturn_attribute },\n+  { \"malloc\",       0, 0,  true,  false, false, handle_malloc_attribute },\n+  { \"type generic\", 0, 0, false, true, true, handle_type_generic_attribute },\n+\n+  /* ??? format and format_arg are heavy and not supported, which actually\n+     prevents support for stdio builtins, which we however declare as part\n+     of the common builtins.def contents.  */\n+  { \"format\",     3, 3,  false, true,  true,  fake_attribute_handler },\n+  { \"format_arg\", 1, 1,  false, true,  true,  fake_attribute_handler },\n+\n+  { NULL,         0, 0, false, false, false, NULL }\n };\n \n /* Associates a GNAT tree node to a GCC tree node. It is used in\n@@ -149,7 +178,7 @@ static GTY((deletable)) struct gnat_binding_level *free_binding_level;\n /* An array of global declarations.  */\n static GTY(()) VEC(tree,gc) *global_decls;\n \n-/* An array of builtin declarations.  */\n+/* An array of builtin function declarations.  */\n static GTY(()) VEC(tree,gc) *builtin_decls;\n \n /* An array of global renaming pointers.  */\n@@ -494,20 +523,6 @@ gnat_init_decl_processing (void)\n   build_common_tree_nodes_2 (0);\n \n   ptr_void_type_node = build_pointer_type (void_type_node);\n-\n-  gnat_install_builtins ();\n-}\n-\n-/* Install the builtin functions we might need.  */\n-\n-static void\n-gnat_install_builtins ()\n-{\n-  /* Builtins used by generic middle-end optimizers.  */\n-  build_common_builtin_nodes ();\n-\n-  /* Target specific builtins, such as the AltiVec family on ppc.  */\n-  targetm.init_builtins ();\n }\n \n /* Create the predefined scalar types such as `integer_type_node' needed\n@@ -761,6 +776,10 @@ init_gigi_decls (tree long_long_float_type, tree exception_type)\n   DECL_FUNCTION_CODE (update_setjmp_buf_decl) = BUILT_IN_UPDATE_SETJMP_BUF;\n \n   main_identifier_node = get_identifier (\"main\");\n+\n+  /* Install the builtins we might need, either internally or as\n+     user available facilities for Intrinsic imports.  */\n+  gnat_install_builtins ();\n }\n \f\n /* Given a record type RECORD_TYPE and a chain of FIELD_DECL nodes FIELDLIST,\n@@ -2225,38 +2244,6 @@ gnat_builtin_function (tree decl)\n   return decl;\n }\n \n-/* Handle a \"const\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n-static tree\n-handle_const_attribute (tree *node, tree ARG_UNUSED (name),\n-\t\t\ttree ARG_UNUSED (args), int ARG_UNUSED (flags),\n-\t\t\tbool *no_add_attrs)\n-{\n-  if (TREE_CODE (*node) == FUNCTION_DECL)\n-    TREE_READONLY (*node) = 1;\n-  else\n-    *no_add_attrs = true;\n-\n-  return NULL_TREE;\n-}\n-\n-/* Handle a \"nothrow\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n-static tree\n-handle_nothrow_attribute (tree *node, tree ARG_UNUSED (name),\n-\t\t\t  tree ARG_UNUSED (args), int ARG_UNUSED (flags),\n-\t\t\t  bool *no_add_attrs)\n-{\n-  if (TREE_CODE (*node) == FUNCTION_DECL)\n-    TREE_NOTHROW (*node) = 1;\n-  else\n-    *no_add_attrs = true;\n-\n-  return NULL_TREE;\n-}\n-\n /* Return an integer type with the number of bits of precision given by\n    PRECISION.  UNSIGNEDP is nonzero if the type is unsigned; otherwise\n    it is a signed type.  */\n@@ -4039,22 +4026,6 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n   return expr;\n }\n \f\n-/* Search the chain of currently available builtin declarations for a node\n-   corresponding to function NAME (an IDENTIFIER_NODE).  Return the first node\n-   found, if any, or NULL_TREE otherwise.  */\n-tree\n-builtin_decl_for (tree name)\n-{\n-  unsigned i;\n-  tree decl;\n-\n-  for (i = 0; VEC_iterate(tree, builtin_decls, i, decl); i++)\n-    if (DECL_NAME (decl) == name)\n-      return decl;\n-\n-  return NULL_TREE;\n-}\n-\n /* Return the appropriate GCC tree code for the specified GNAT type,\n    the latter being a record type as predicated by Is_Record_Type.  */\n \n@@ -4129,5 +4100,675 @@ gnat_write_global_declarations (void)\n \t\t\t\t  VEC_length (tree, global_decls));\n }\n \n+/* ************************************************************************\n+ * *                           GCC builtins support                       *\n+ * ************************************************************************ */\n+\n+/* The general scheme is fairly simple:\n+   \n+   For each builtin function/type to be declared, gnat_install_builtins calls\n+   internal facilities which eventually get to gnat_push_decl, which in turn\n+   tracks the so declared builtin function decls in the 'builtin_decls' global\n+   datastructure. When an Intrinsic subprogram declaration is processed, we\n+   search this global datastructure to retrieve the associated BUILT_IN DECL\n+   node.  */\n+\n+/* Search the chain of currently available builtin declarations for a node\n+   corresponding to function NAME (an IDENTIFIER_NODE).  Return the first node\n+   found, if any, or NULL_TREE otherwise.  */\n+tree\n+builtin_decl_for (tree name)\n+{\n+  unsigned i;\n+  tree decl;\n+\n+  for (i = 0; VEC_iterate(tree, builtin_decls, i, decl); i++)\n+    if (DECL_NAME (decl) == name)\n+      return decl;\n+\n+  return NULL_TREE;\n+}\n+\n+/* The code below eventually exposes gnat_install_builtins, which declares\n+   the builtin types and functions we might need, either internally or as\n+   user accessible facilities.\n+\n+   ??? This is a first implementation shot, still in rough shape.  It is\n+   heavily inspired from the \"C\" family implementation, with chunks copied\n+   verbatim from there.\n+   \n+   Two obvious TODO candidates are\n+   o Use a more efficient name/decl mapping scheme\n+   o Devise a middle-end infrastructure to avoid having to copy\n+     pieces between front-ends.  */\n+\n+/* ----------------------------------------------------------------------- *\n+ *                         BUILTIN ELEMENTARY TYPES                        *\n+ * ----------------------------------------------------------------------- */\n+\n+/* Standard data types to be used in builtin argument declarations.  */\n+\n+enum c_tree_index\n+{\n+    CTI_SIGNED_SIZE_TYPE, /* For format checking only.  */\n+    CTI_STRING_TYPE,\n+    CTI_CONST_STRING_TYPE,\n+\n+    CTI_MAX\n+};\n+\n+static tree c_global_trees[CTI_MAX];\n+\n+#define signed_size_type_node\tc_global_trees[CTI_SIGNED_SIZE_TYPE]\n+#define string_type_node\tc_global_trees[CTI_STRING_TYPE]\n+#define const_string_type_node\tc_global_trees[CTI_CONST_STRING_TYPE]\n+\n+/* ??? In addition some attribute handlers, we currently don't support a\n+   (small) number of builtin-types, which in turns inhibits support for a\n+   number of builtin functions.  */\n+#define wint_type_node    void_type_node\n+#define intmax_type_node  void_type_node\n+#define uintmax_type_node void_type_node\n+\n+/* Build the void_list_node (void_type_node having been created).  */\n+\n+static tree\n+build_void_list_node (void)\n+{\n+  tree t = build_tree_list (NULL_TREE, void_type_node);\n+  return t;\n+}\n+\n+/* Used to help initialize the builtin-types.def table.  When a type of\n+   the correct size doesn't exist, use error_mark_node instead of NULL.\n+   The later results in segfaults even when a decl using the type doesn't\n+   get invoked.  */\n+\n+static tree\n+builtin_type_for_size (int size, bool unsignedp)\n+{\n+  tree type = lang_hooks.types.type_for_size (size, unsignedp);\n+  return type ? type : error_mark_node;\n+}\n+\n+/* Build/push the elementary type decls that builtin functions/types\n+   will need.  */\n+\n+static void\n+install_builtin_elementary_types (void)\n+{\n+  signed_size_type_node = size_type_node;\n+  pid_type_node = integer_type_node;\n+  void_list_node = build_void_list_node ();\n+\n+  string_type_node = build_pointer_type (char_type_node);\n+  const_string_type_node\n+    = build_pointer_type (build_qualified_type\n+\t\t\t  (char_type_node, TYPE_QUAL_CONST));\n+}\n+\n+/* ----------------------------------------------------------------------- *\n+ *                          BUILTIN FUNCTION TYPES                         *\n+ * ----------------------------------------------------------------------- */\n+\n+/* Now, builtin function types per se.  */\n+\n+enum c_builtin_type\n+{\n+#define DEF_PRIMITIVE_TYPE(NAME, VALUE) NAME,\n+#define DEF_FUNCTION_TYPE_0(NAME, RETURN) NAME,\n+#define DEF_FUNCTION_TYPE_1(NAME, RETURN, ARG1) NAME,\n+#define DEF_FUNCTION_TYPE_2(NAME, RETURN, ARG1, ARG2) NAME,\n+#define DEF_FUNCTION_TYPE_3(NAME, RETURN, ARG1, ARG2, ARG3) NAME,\n+#define DEF_FUNCTION_TYPE_4(NAME, RETURN, ARG1, ARG2, ARG3, ARG4) NAME,\n+#define DEF_FUNCTION_TYPE_5(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5) NAME,\n+#define DEF_FUNCTION_TYPE_6(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) NAME,\n+#define DEF_FUNCTION_TYPE_7(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) NAME,\n+#define DEF_FUNCTION_TYPE_VAR_0(NAME, RETURN) NAME,\n+#define DEF_FUNCTION_TYPE_VAR_1(NAME, RETURN, ARG1) NAME,\n+#define DEF_FUNCTION_TYPE_VAR_2(NAME, RETURN, ARG1, ARG2) NAME,\n+#define DEF_FUNCTION_TYPE_VAR_3(NAME, RETURN, ARG1, ARG2, ARG3) NAME,\n+#define DEF_FUNCTION_TYPE_VAR_4(NAME, RETURN, ARG1, ARG2, ARG3, ARG4) NAME,\n+#define DEF_FUNCTION_TYPE_VAR_5(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG6) \\\n+  NAME,\n+#define DEF_POINTER_TYPE(NAME, TYPE) NAME,\n+#include \"builtin-types.def\"\n+#undef DEF_PRIMITIVE_TYPE\n+#undef DEF_FUNCTION_TYPE_0\n+#undef DEF_FUNCTION_TYPE_1\n+#undef DEF_FUNCTION_TYPE_2\n+#undef DEF_FUNCTION_TYPE_3\n+#undef DEF_FUNCTION_TYPE_4\n+#undef DEF_FUNCTION_TYPE_5\n+#undef DEF_FUNCTION_TYPE_6\n+#undef DEF_FUNCTION_TYPE_7\n+#undef DEF_FUNCTION_TYPE_VAR_0\n+#undef DEF_FUNCTION_TYPE_VAR_1\n+#undef DEF_FUNCTION_TYPE_VAR_2\n+#undef DEF_FUNCTION_TYPE_VAR_3\n+#undef DEF_FUNCTION_TYPE_VAR_4\n+#undef DEF_FUNCTION_TYPE_VAR_5\n+#undef DEF_POINTER_TYPE\n+  BT_LAST\n+};\n+\n+typedef enum c_builtin_type builtin_type;\n+\n+/* A temporary array used in communication with def_fn_type.  */\n+static GTY(()) tree builtin_types[(int) BT_LAST + 1];\n+\n+/* A helper function for install_builtin_types.  Build function type\n+   for DEF with return type RET and N arguments.  If VAR is true, then the\n+   function should be variadic after those N arguments.\n+\n+   Takes special care not to ICE if any of the types involved are\n+   error_mark_node, which indicates that said type is not in fact available\n+   (see builtin_type_for_size).  In which case the function type as a whole\n+   should be error_mark_node.  */\n+\n+static void\n+def_fn_type (builtin_type def, builtin_type ret, bool var, int n, ...)\n+{\n+  tree args = NULL, t;\n+  va_list list;\n+  int i;\n+\n+  va_start (list, n);\n+  for (i = 0; i < n; ++i)\n+    {\n+      builtin_type a = va_arg (list, builtin_type);\n+      t = builtin_types[a];\n+      if (t == error_mark_node)\n+\tgoto egress;\n+      args = tree_cons (NULL_TREE, t, args);\n+    }\n+  va_end (list);\n+\n+  args = nreverse (args);\n+  if (!var)\n+    args = chainon (args, void_list_node);\n+\n+  t = builtin_types[ret];\n+  if (t == error_mark_node)\n+    goto egress;\n+  t = build_function_type (t, args);\n+\n+ egress:\n+  builtin_types[def] = t;\n+}\n+\n+/* Build the builtin function types and install them in the builtin_types\n+   array for later use in builtin function decls.  */\n+\n+static void\n+install_builtin_function_types (void)\n+{\n+  tree va_list_ref_type_node;\n+  tree va_list_arg_type_node;\n+\n+  if (TREE_CODE (va_list_type_node) == ARRAY_TYPE)\n+    {\n+      va_list_arg_type_node = va_list_ref_type_node =\n+\tbuild_pointer_type (TREE_TYPE (va_list_type_node));\n+    }\n+  else\n+    {\n+      va_list_arg_type_node = va_list_type_node;\n+      va_list_ref_type_node = build_reference_type (va_list_type_node);\n+    }\n+\n+#define DEF_PRIMITIVE_TYPE(ENUM, VALUE) \\\n+  builtin_types[ENUM] = VALUE;\n+#define DEF_FUNCTION_TYPE_0(ENUM, RETURN) \\\n+  def_fn_type (ENUM, RETURN, 0, 0);\n+#define DEF_FUNCTION_TYPE_1(ENUM, RETURN, ARG1) \\\n+  def_fn_type (ENUM, RETURN, 0, 1, ARG1);\n+#define DEF_FUNCTION_TYPE_2(ENUM, RETURN, ARG1, ARG2) \\\n+  def_fn_type (ENUM, RETURN, 0, 2, ARG1, ARG2);\n+#define DEF_FUNCTION_TYPE_3(ENUM, RETURN, ARG1, ARG2, ARG3) \\\n+  def_fn_type (ENUM, RETURN, 0, 3, ARG1, ARG2, ARG3);\n+#define DEF_FUNCTION_TYPE_4(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4) \\\n+  def_fn_type (ENUM, RETURN, 0, 4, ARG1, ARG2, ARG3, ARG4);\n+#define DEF_FUNCTION_TYPE_5(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5)\t\\\n+  def_fn_type (ENUM, RETURN, 0, 5, ARG1, ARG2, ARG3, ARG4, ARG5);\n+#define DEF_FUNCTION_TYPE_6(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t    ARG6)\t\t\t\t\t\\\n+  def_fn_type (ENUM, RETURN, 0, 6, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6);\n+#define DEF_FUNCTION_TYPE_7(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t    ARG6, ARG7)\t\t\t\t\t\\\n+  def_fn_type (ENUM, RETURN, 0, 7, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7);\n+#define DEF_FUNCTION_TYPE_VAR_0(ENUM, RETURN) \\\n+  def_fn_type (ENUM, RETURN, 1, 0);\n+#define DEF_FUNCTION_TYPE_VAR_1(ENUM, RETURN, ARG1) \\\n+  def_fn_type (ENUM, RETURN, 1, 1, ARG1);\n+#define DEF_FUNCTION_TYPE_VAR_2(ENUM, RETURN, ARG1, ARG2) \\\n+  def_fn_type (ENUM, RETURN, 1, 2, ARG1, ARG2);\n+#define DEF_FUNCTION_TYPE_VAR_3(ENUM, RETURN, ARG1, ARG2, ARG3) \\\n+  def_fn_type (ENUM, RETURN, 1, 3, ARG1, ARG2, ARG3);\n+#define DEF_FUNCTION_TYPE_VAR_4(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4) \\\n+  def_fn_type (ENUM, RETURN, 1, 4, ARG1, ARG2, ARG3, ARG4);\n+#define DEF_FUNCTION_TYPE_VAR_5(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5) \\\n+  def_fn_type (ENUM, RETURN, 1, 5, ARG1, ARG2, ARG3, ARG4, ARG5);\n+#define DEF_POINTER_TYPE(ENUM, TYPE) \\\n+  builtin_types[(int) ENUM] = build_pointer_type (builtin_types[(int) TYPE]);\n+\n+#include \"builtin-types.def\"\n+\n+#undef DEF_PRIMITIVE_TYPE\n+#undef DEF_FUNCTION_TYPE_1\n+#undef DEF_FUNCTION_TYPE_2\n+#undef DEF_FUNCTION_TYPE_3\n+#undef DEF_FUNCTION_TYPE_4\n+#undef DEF_FUNCTION_TYPE_5\n+#undef DEF_FUNCTION_TYPE_6\n+#undef DEF_FUNCTION_TYPE_VAR_0\n+#undef DEF_FUNCTION_TYPE_VAR_1\n+#undef DEF_FUNCTION_TYPE_VAR_2\n+#undef DEF_FUNCTION_TYPE_VAR_3\n+#undef DEF_FUNCTION_TYPE_VAR_4\n+#undef DEF_FUNCTION_TYPE_VAR_5\n+#undef DEF_POINTER_TYPE\n+  builtin_types[(int) BT_LAST] = NULL_TREE;\n+}\n+\n+/* ----------------------------------------------------------------------- *\n+ *                            BUILTIN ATTRIBUTES                           *\n+ * ----------------------------------------------------------------------- */\n+\n+enum built_in_attribute\n+{\n+#define DEF_ATTR_NULL_TREE(ENUM) ENUM,\n+#define DEF_ATTR_INT(ENUM, VALUE) ENUM,\n+#define DEF_ATTR_IDENT(ENUM, STRING) ENUM,\n+#define DEF_ATTR_TREE_LIST(ENUM, PURPOSE, VALUE, CHAIN) ENUM,\n+#include \"builtin-attrs.def\"\n+#undef DEF_ATTR_NULL_TREE\n+#undef DEF_ATTR_INT\n+#undef DEF_ATTR_IDENT\n+#undef DEF_ATTR_TREE_LIST\n+  ATTR_LAST\n+};\n+\n+static GTY(()) tree built_in_attributes[(int) ATTR_LAST];\n+\n+static void\n+install_builtin_attributes (void)\n+{\n+  /* Fill in the built_in_attributes array.  */\n+#define DEF_ATTR_NULL_TREE(ENUM)\t\t\t\t\\\n+  built_in_attributes[(int) ENUM] = NULL_TREE;\n+#define DEF_ATTR_INT(ENUM, VALUE)\t\t\t\t\\\n+  built_in_attributes[(int) ENUM] = build_int_cst (NULL_TREE, VALUE);\n+#define DEF_ATTR_IDENT(ENUM, STRING)\t\t\t\t\\\n+  built_in_attributes[(int) ENUM] = get_identifier (STRING);\n+#define DEF_ATTR_TREE_LIST(ENUM, PURPOSE, VALUE, CHAIN)\t\\\n+  built_in_attributes[(int) ENUM]\t\t\t\\\n+    = tree_cons (built_in_attributes[(int) PURPOSE],\t\\\n+\t\t built_in_attributes[(int) VALUE],\t\\\n+\t\t built_in_attributes[(int) CHAIN]);\n+#include \"builtin-attrs.def\"\n+#undef DEF_ATTR_NULL_TREE\n+#undef DEF_ATTR_INT\n+#undef DEF_ATTR_IDENT\n+#undef DEF_ATTR_TREE_LIST\n+}\n+\n+/* Handle a \"const\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_const_attribute (tree *node, tree ARG_UNUSED (name),\n+\t\t\ttree ARG_UNUSED (args), int ARG_UNUSED (flags),\n+\t\t\tbool *no_add_attrs)\n+{\n+  if (TREE_CODE (*node) == FUNCTION_DECL)\n+    TREE_READONLY (*node) = 1;\n+  else\n+    *no_add_attrs = true;\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"nothrow\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_nothrow_attribute (tree *node, tree ARG_UNUSED (name),\n+\t\t\t  tree ARG_UNUSED (args), int ARG_UNUSED (flags),\n+\t\t\t  bool *no_add_attrs)\n+{\n+  if (TREE_CODE (*node) == FUNCTION_DECL)\n+    TREE_NOTHROW (*node) = 1;\n+  else\n+    *no_add_attrs = true;\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"pure\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_pure_attribute (tree *node, tree name, tree ARG_UNUSED (args),\n+\t\t       int ARG_UNUSED (flags), bool *no_add_attrs)\n+{\n+  if (TREE_CODE (*node) == FUNCTION_DECL)\n+    DECL_IS_PURE (*node) = 1;\n+  /* ??? TODO: Support types.  */\n+  else\n+    {\n+      warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"no vops\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_novops_attribute (tree *node, tree ARG_UNUSED (name),\n+\t\t\t tree ARG_UNUSED (args), int ARG_UNUSED (flags),\n+\t\t\t bool *ARG_UNUSED (no_add_attrs))\n+{\n+  gcc_assert (TREE_CODE (*node) == FUNCTION_DECL);\n+  DECL_IS_NOVOPS (*node) = 1;\n+  return NULL_TREE;\n+}\n+\n+/* Helper for nonnull attribute handling; fetch the operand number\n+   from the attribute argument list.  */\n+\n+static bool\n+get_nonnull_operand (tree arg_num_expr, unsigned HOST_WIDE_INT *valp)\n+{\n+  /* Verify the arg number is a constant.  */\n+  if (TREE_CODE (arg_num_expr) != INTEGER_CST\n+      || TREE_INT_CST_HIGH (arg_num_expr) != 0)\n+    return false;\n+\n+  *valp = TREE_INT_CST_LOW (arg_num_expr);\n+  return true;\n+}\n+\n+/* Handle the \"nonnull\" attribute.  */\n+static tree\n+handle_nonnull_attribute (tree *node, tree ARG_UNUSED (name),\n+\t\t\t  tree args, int ARG_UNUSED (flags),\n+\t\t\t  bool *no_add_attrs)\n+{\n+  tree type = *node;\n+  unsigned HOST_WIDE_INT attr_arg_num;\n+\n+  /* If no arguments are specified, all pointer arguments should be\n+     non-null.  Verify a full prototype is given so that the arguments\n+     will have the correct types when we actually check them later.  */\n+  if (!args)\n+    {\n+      if (!TYPE_ARG_TYPES (type))\n+\t{\n+\t  error (\"nonnull attribute without arguments on a non-prototype\");\n+\t  *no_add_attrs = true;\n+\t}\n+      return NULL_TREE;\n+    }\n+\n+  /* Argument list specified.  Verify that each argument number references\n+     a pointer argument.  */\n+  for (attr_arg_num = 1; args; args = TREE_CHAIN (args))\n+    {\n+      tree argument;\n+      unsigned HOST_WIDE_INT arg_num = 0, ck_num;\n+\n+      if (!get_nonnull_operand (TREE_VALUE (args), &arg_num))\n+\t{\n+\t  error (\"nonnull argument has invalid operand number (argument %lu)\",\n+\t\t (unsigned long) attr_arg_num);\n+\t  *no_add_attrs = true;\n+\t  return NULL_TREE;\n+\t}\n+\n+      argument = TYPE_ARG_TYPES (type);\n+      if (argument)\n+\t{\n+\t  for (ck_num = 1; ; ck_num++)\n+\t    {\n+\t      if (!argument || ck_num == arg_num)\n+\t\tbreak;\n+\t      argument = TREE_CHAIN (argument);\n+\t    }\n+\n+\t  if (!argument\n+\t      || TREE_CODE (TREE_VALUE (argument)) == VOID_TYPE)\n+\t    {\n+\t      error (\"nonnull argument with out-of-range operand number (argument %lu, operand %lu)\",\n+\t\t     (unsigned long) attr_arg_num, (unsigned long) arg_num);\n+\t      *no_add_attrs = true;\n+\t      return NULL_TREE;\n+\t    }\n+\n+\t  if (TREE_CODE (TREE_VALUE (argument)) != POINTER_TYPE)\n+\t    {\n+\t      error (\"nonnull argument references non-pointer operand (argument %lu, operand %lu)\",\n+\t\t   (unsigned long) attr_arg_num, (unsigned long) arg_num);\n+\t      *no_add_attrs = true;\n+\t      return NULL_TREE;\n+\t    }\n+\t}\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"sentinel\" attribute.  */\n+\n+static tree\n+handle_sentinel_attribute (tree *node, tree name, tree args,\n+\t\t\t   int ARG_UNUSED (flags), bool *no_add_attrs)\n+{\n+  tree params = TYPE_ARG_TYPES (*node);\n+\n+  if (!params)\n+    {\n+      warning (OPT_Wattributes,\n+\t       \"%qE attribute requires prototypes with named arguments\", name);\n+      *no_add_attrs = true;\n+    }\n+  else\n+    {\n+      while (TREE_CHAIN (params))\n+\tparams = TREE_CHAIN (params);\n+\n+      if (VOID_TYPE_P (TREE_VALUE (params)))\n+        {\n+\t  warning (OPT_Wattributes,\n+\t\t   \"%qE attribute only applies to variadic functions\", name);\n+\t  *no_add_attrs = true;\n+\t}\n+    }\n+  \n+  if (args)\n+    {\n+      tree position = TREE_VALUE (args);\n+\n+      if (TREE_CODE (position) != INTEGER_CST)\n+        {\n+\t  warning (0, \"requested position is not an integer constant\");\n+\t  *no_add_attrs = true;\n+\t}\n+      else\n+        {\n+\t  if (tree_int_cst_lt (position, integer_zero_node))\n+\t    {\n+\t      warning (0, \"requested position is less than zero\");\n+\t      *no_add_attrs = true;\n+\t    }\n+\t}\n+    }\n+  \n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"noreturn\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_noreturn_attribute (tree *node, tree name, tree ARG_UNUSED (args),\n+\t\t\t   int ARG_UNUSED (flags), bool *no_add_attrs)\n+{\n+  tree type = TREE_TYPE (*node);\n+\n+  /* See FIXME comment in c_common_attribute_table.  */\n+  if (TREE_CODE (*node) == FUNCTION_DECL)\n+    TREE_THIS_VOLATILE (*node) = 1;\n+  else if (TREE_CODE (type) == POINTER_TYPE\n+\t   && TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE)\n+    TREE_TYPE (*node)\n+      = build_pointer_type\n+\t(build_type_variant (TREE_TYPE (type),\n+\t\t\t     TYPE_READONLY (TREE_TYPE (type)), 1));\n+  else\n+    {\n+      warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"malloc\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_malloc_attribute (tree *node, tree name, tree ARG_UNUSED (args),\n+\t\t\t int ARG_UNUSED (flags), bool *no_add_attrs)\n+{\n+  if (TREE_CODE (*node) == FUNCTION_DECL\n+      && POINTER_TYPE_P (TREE_TYPE (TREE_TYPE (*node))))\n+    DECL_IS_MALLOC (*node) = 1;\n+  else\n+    {\n+      warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Fake handler for attributes we don't properly support.  */\n+   \n+tree\n+fake_attribute_handler (tree * ARG_UNUSED (node),\n+\t\t\ttree ARG_UNUSED (name),\n+\t\t\ttree ARG_UNUSED (args),\n+\t\t\tint  ARG_UNUSED (flags),\n+\t\t\tbool * ARG_UNUSED (no_add_attrs))\n+{\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"type_generic\" attribute.  */\n+\n+static tree\n+handle_type_generic_attribute (tree *node, tree ARG_UNUSED (name),\n+\t\t\t       tree ARG_UNUSED (args), int ARG_UNUSED (flags),\n+\t\t\t       bool * ARG_UNUSED (no_add_attrs))\n+{\n+  /* Ensure we have a function type, with no arguments.  */\n+  gcc_assert (TREE_CODE (*node) == FUNCTION_TYPE && ! TYPE_ARG_TYPES (*node));\n+\n+  return NULL_TREE;\n+}\n+\n+/* ----------------------------------------------------------------------- *\n+ *                              BUILTIN FUNCTIONS                          *\n+ * ----------------------------------------------------------------------- */\n+\n+/* Worker for DEF_BUILTIN.  Possibly define a builtin function with one or two\n+   names.  Does not declare a non-__builtin_ function if flag_no_builtin, or\n+   if nonansi_p and flag_no_nonansi_builtin.  */\n+\n+static void\n+def_builtin_1 (enum built_in_function fncode,\n+\t       const char *name,\n+\t       enum built_in_class fnclass,\n+\t       tree fntype, tree libtype,\n+\t       bool both_p, bool fallback_p,\n+\t       bool nonansi_p ATTRIBUTE_UNUSED,\n+\t       tree fnattrs, bool implicit_p)\n+{\n+  tree decl;\n+  const char *libname;\n+\n+  /* Preserve an already installed decl.  It most likely was setup in advance\n+     (e.g. as part of the internal builtins) for specific reasons.  */ \n+  if (built_in_decls[(int) fncode] != NULL_TREE)\n+    return;\n+  \n+  gcc_assert ((!both_p && !fallback_p)\n+\t      || !strncmp (name, \"__builtin_\",\n+\t\t\t   strlen (\"__builtin_\")));\n+\n+  libname = name + strlen (\"__builtin_\");\n+  decl = add_builtin_function (name, fntype, fncode, fnclass,\n+\t\t\t       (fallback_p ? libname : NULL),\n+\t\t\t       fnattrs);\n+  if (both_p)\n+    /* ??? This is normally further controlled by command-line options\n+       like -fno-builtin, but we don't have them for Ada.  */\n+      add_builtin_function (libname, libtype, fncode, fnclass,\n+\t\t\t    NULL, fnattrs);\n+\n+  built_in_decls[(int) fncode] = decl;\n+  if (implicit_p)\n+    implicit_built_in_decls[(int) fncode] = decl;\n+}\n+\n+static int flag_isoc94 = 0;\n+static int flag_isoc99 = 0;\n+\n+/* Install what the common builtins.def offers.  */\n+\n+static void\n+install_builtin_functions (void)\n+{\n+#define DEF_BUILTIN(ENUM, NAME, CLASS, TYPE, LIBTYPE, BOTH_P, FALLBACK_P, \\\n+\t\t    NONANSI_P, ATTRS, IMPLICIT, COND)\t\t\t\\\n+  if (NAME && COND)\t\t\t\t\t\t\t\\\n+    def_builtin_1 (ENUM, NAME, CLASS,                                   \\\n+                   builtin_types[(int) TYPE],                           \\\n+                   builtin_types[(int) LIBTYPE],                        \\\n+                   BOTH_P, FALLBACK_P, NONANSI_P,                       \\\n+                   built_in_attributes[(int) ATTRS], IMPLICIT);\n+#include \"builtins.def\"\n+#undef DEF_BUILTIN\n+}\n+\n+/* ----------------------------------------------------------------------- *\n+ *                              BUILTIN FUNCTIONS                          *\n+ * ----------------------------------------------------------------------- */\n+\n+/* Install the builtin functions we might need.  */\n+\n+void\n+gnat_install_builtins (void)\n+{\n+  install_builtin_elementary_types ();\n+  install_builtin_function_types ();\n+  install_builtin_attributes ();\n+\n+  /* Install builtins used by generic middle-end pieces first.  Some of these\n+     know about internal specificities and control attributes accordingly, for\n+     instance __builtin_alloca vs no-throw and -fstack-check.  We will ignore\n+     the generic definition from builtins.def.  */\n+  build_common_builtin_nodes ();\n+\n+  /* Now, install the target specific builtins, such as the AltiVec family on\n+     ppc, and the common set as exposed by builtins.def.  */\n+  targetm.init_builtins ();\n+  install_builtin_functions ();\n+}\n+\n #include \"gt-ada-utils.h\"\n #include \"gtype-ada.h\""}, {"sha": "23c6f7e99e30d6c9b13267c720446fff7fe50791", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/009890be6c6e3f34630be0f086303d42c6aa867b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/009890be6c6e3f34630be0f086303d42c6aa867b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=009890be6c6e3f34630be0f086303d42c6aa867b", "patch": "@@ -1,3 +1,7 @@\n+2008-04-21  Olivier Hainque  <hainque@adacore.com>\n+\n+\t* gnat.dg/bltins.adb: New testcase.\n+\n 2008-04-20  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR fortran/35991"}, {"sha": "0ceb0b95ba3bcb424f3b89f8dfd7f64bcf5a98fe", "filename": "gcc/testsuite/gnat.dg/bltins.adb", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/009890be6c6e3f34630be0f086303d42c6aa867b/gcc%2Ftestsuite%2Fgnat.dg%2Fbltins.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/009890be6c6e3f34630be0f086303d42c6aa867b/gcc%2Ftestsuite%2Fgnat.dg%2Fbltins.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fbltins.adb?ref=009890be6c6e3f34630be0f086303d42c6aa867b", "patch": "@@ -0,0 +1,12 @@\n+-- { dg-do run }\n+\n+procedure Bltins is\n+\n+   function Sqrt (F : Float) return Float;\n+   pragma Import (Intrinsic, Sqrt, \"__builtin_sqrtf\");\n+\n+   F : Float := 4.0;\n+   R : Float;\n+begin\n+   R := Sqrt (F);\n+end;"}]}