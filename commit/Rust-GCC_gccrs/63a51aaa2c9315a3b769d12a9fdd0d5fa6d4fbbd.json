{"sha": "63a51aaa2c9315a3b769d12a9fdd0d5fa6d4fbbd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjNhNTFhYWEyYzkzMTVhM2I3NjlkMTJhOWZkZDBkNWZhNmQ0ZmJiZA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-08-13T08:17:14Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-08-13T08:17:14Z"}, "message": "pt.c (tsubst): Back out 1999-08-06 patch.\n\n\t* pt.c (tsubst): Back out 1999-08-06 patch.  Use fold and\n\tdecl_constant_value to simplify array bounds.\n\nFrom-SVN: r28702", "tree": {"sha": "9bf7a82a4038d8a5eb8778809dd084ffb64b676f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9bf7a82a4038d8a5eb8778809dd084ffb64b676f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/63a51aaa2c9315a3b769d12a9fdd0d5fa6d4fbbd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63a51aaa2c9315a3b769d12a9fdd0d5fa6d4fbbd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63a51aaa2c9315a3b769d12a9fdd0d5fa6d4fbbd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63a51aaa2c9315a3b769d12a9fdd0d5fa6d4fbbd/comments", "author": null, "committer": null, "parents": [{"sha": "80dabe332af45fd572921d401c07e3879bd0d90e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80dabe332af45fd572921d401c07e3879bd0d90e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80dabe332af45fd572921d401c07e3879bd0d90e"}], "stats": {"total": 90, "additions": 59, "deletions": 31}, "files": [{"sha": "37a7b689c0e2cd9f4266478c98f9ecda4c923157", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 59, "deletions": 31, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63a51aaa2c9315a3b769d12a9fdd0d5fa6d4fbbd/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63a51aaa2c9315a3b769d12a9fdd0d5fa6d4fbbd/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=63a51aaa2c9315a3b769d12a9fdd0d5fa6d4fbbd", "patch": "@@ -2216,6 +2216,12 @@ check_default_tmpl_args (decl, parms, is_primary, is_partial)\n      in the template-parameter-list of the definition of a member of a\n      class template.  */\n \n+  if (TREE_CODE (DECL_REAL_CONTEXT (decl)) == FUNCTION_DECL)\n+    /* You can't have a function template declaration in a local\n+       scope, nor you can you define a member of a class template in a\n+       local scope.  */\n+    return;\n+\n   if (current_class_type\n       && !TYPE_BEING_DEFINED (current_class_type)\n       && DECL_LANG_SPECIFIC (decl)\n@@ -5057,9 +5063,22 @@ instantiate_class_template (type)\n \t}\n     }\n \n+  /* Create the typedef that indicates provides a way of referencing a\n+     class name within the scope of that class.  */\n+  build_self_reference ();\n+\n   /* Don't replace enum constants here.  */\n   for (t = TYPE_FIELDS (pattern); t; t = TREE_CHAIN (t))\n-    if (TREE_CODE (t) != CONST_DECL)\n+    /* If this is the implicit self-reference typedef, skip it, as we\n+       have handled it above.  Note that the usual tsubst machinery\n+       doesn't work here, since the resulting declaration must have a\n+       different name than the one it was given originally.  */\n+    if (TREE_CODE (t) == TYPE_DECL \n+\t&& TREE_TYPE (t) == pattern\n+\t&& DECL_NAME (t) == constructor_name (t)\n+\t&& DECL_ARTIFICIAL (t))\n+      continue;\n+    else if (TREE_CODE (t) != CONST_DECL)\n       {\n \ttree r;\n \n@@ -5878,18 +5897,24 @@ tsubst_decl (t, args, type, in_decl)\n       break;\n \n     case VAR_DECL:\n+    case TYPE_DECL:\n       {\n \ttree argvec;\n \ttree gen_tmpl;\n \ttree spec;\n \ttree tmpl;\n-\ttree ctx = tsubst_aggr_type (DECL_CONTEXT (t), args, \n-\t\t\t\t     /*complain=*/1,\n-\t\t\t\t     in_decl, /*entering_scope=*/1);\n-\t\n-\t/* Nobody should be tsubst'ing into non-template variables.  */\n-\tmy_friendly_assert (DECL_LANG_SPECIFIC (t) \n-\t\t\t    && DECL_TEMPLATE_INFO (t) != NULL_TREE, 0);\n+\ttree ctx;\n+\n+\tif (!DECL_LANG_SPECIFIC (t) || !DECL_TEMPLATE_INFO (t))\n+\t  return t;\n+\n+\tif (TYPE_P (DECL_CONTEXT (t)))\n+\t  ctx = tsubst_aggr_type (DECL_CONTEXT (t), args, \n+\t\t\t\t  /*complain=*/1,\n+\t\t\t\t  in_decl, /*entering_scope=*/1);\n+\telse\n+\t  /* Subsequent calls to pushdecl will fill this in.  */\n+\t  ctx = NULL_TREE;\n \n \t/* Check to see if we already have this specialization.  */\n \ttmpl = DECL_TI_TEMPLATE (t);\n@@ -5903,7 +5928,13 @@ tsubst_decl (t, args, type, in_decl)\n \t    break;\n \t  }\n \n+\t/* This declaration is going to have to be around for a while,\n+\t   so me make sure it is on a saveable obstack.  */\n+\tpush_obstacks_nochange ();\n+\tsaveable_allocation ();\n \tr = copy_node (t);\n+\tpop_obstacks ();\n+\n \tTREE_TYPE (r) = type;\n \tc_apply_type_quals_to_decl (CP_TYPE_QUALS (type), r);\n \tDECL_CONTEXT (r) = ctx;\n@@ -5916,10 +5947,16 @@ tsubst_decl (t, args, type, in_decl)\n \tcopy_lang_decl (r);\n \tDECL_CLASS_CONTEXT (r) = DECL_CONTEXT (r);\n \n+\t/* Even if the original location is out of scope, the newly\n+\t   substituted one is not.  */\n+\tif (TREE_CODE (r) == VAR_DECL)\n+\t  DECL_DEAD_FOR_LOCAL (r) = 0;\n+\n \t/* A static data member declaration is always marked external\n \t   when it is declared in-class, even if an initializer is\n \t   present.  We mimic the non-template processing here.  */\n-\tDECL_EXTERNAL (r) = 1;\n+\tif (ctx)\n+\t  DECL_EXTERNAL (r) = 1;\n \n \tDECL_TEMPLATE_INFO (r) = perm_tree_cons (tmpl, argvec, NULL_TREE);\n \tSET_DECL_IMPLICIT_INSTANTIATION (r);\n@@ -5931,18 +5968,6 @@ tsubst_decl (t, args, type, in_decl)\n       }\n       break;\n \n-    case TYPE_DECL:\n-      if (t == TYPE_NAME (TREE_TYPE (t)))\n-\tr = TYPE_NAME (type);\n-      else\n-\t{\n-\t  r = copy_node (t);\n-\t  TREE_TYPE (r) = type;\n-\t  DECL_CONTEXT (r) = current_class_type;\n-\t  TREE_CHAIN (r) = NULL_TREE;\n-\t}\n-      break;\n-\n     default:\n       my_friendly_abort (0);\n     } \n@@ -6018,7 +6043,7 @@ tsubst_function_type (t, args, complain, in_decl)\n   tree arg_types;\n   tree fntype;\n \n-  /* The TYPE_CONTEXT is not used for function/method types.  */\n+  /* The TYPE_CONEXT is not used for function/method types.  */\n   my_friendly_assert (TYPE_CONTEXT (t) == NULL_TREE, 0);\n \n   /* Substitue the return type.  */\n@@ -7099,19 +7124,22 @@ tsubst_expr (t, args, complain, in_decl)\n     case DECL_STMT:\n       {\n \tint i = suspend_momentary ();\n-\ttree dcl, init;\n+\ttree decl, init;\n \n \tlineno = STMT_LINENO (t);\n \temit_line_note (input_filename, lineno);\n-\tdcl = start_decl\n-\t  (tsubst (TREE_OPERAND (t, 0), args, complain, in_decl),\n-\t   tsubst (TREE_OPERAND (t, 1), args, complain, in_decl),\n-\t   TREE_OPERAND (t, 2) != 0, NULL_TREE, NULL_TREE);\n-\tinit = tsubst_expr (TREE_OPERAND (t, 2), args, complain, in_decl);\n-\tcp_finish_decl\n-\t  (dcl, init, NULL_TREE, 1, /*init ? LOOKUP_ONLYCONVERTING :*/ 0);\n+\tdecl = DECL_STMT_DECL (t);\n+\tinit = DECL_INITIAL (decl);\n+\tdecl = tsubst (decl, args, complain, in_decl);\n+\tinit = tsubst_expr (init, args, complain, in_decl);\n+\tDECL_INITIAL (decl) = init;\n+\tmaybe_push_decl (decl);\n+\tif (TREE_CODE (decl) == VAR_DECL)\n+\t  DECL_TEMPLATE_INSTANTIATED (decl) = 1;\n+\tstart_decl_1 (decl);\n+\tcp_finish_decl (decl, init, NULL_TREE, 0, 0);\n \tresume_momentary (i);\n-\treturn dcl;\n+\treturn decl;\n       }\n \n     case FOR_STMT:"}]}