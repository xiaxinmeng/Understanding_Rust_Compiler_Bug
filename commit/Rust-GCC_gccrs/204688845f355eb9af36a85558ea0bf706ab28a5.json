{"sha": "204688845f355eb9af36a85558ea0bf706ab28a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjA0Njg4ODQ1ZjM1NWViOWFmMzZhODU1NThlYTBiZjcwNmFiMjhhNQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2014-08-22T14:05:24Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2014-08-22T14:05:24Z"}, "message": "cse.c: Use rtx_insn\n\ngcc/\n\t* cse.c (struct qty_table_elem): Strengthen field \"const_insn\"\n\tfrom rtx to rtx_insn *.\n\t(struct change_cc_mode_args): Likewise for field \"insn\".\n\t(this_insn): Strengthen from rtx to rtx_insn *.\n\t(make_new_qty): Replace use of NULL_RTX with NULL when dealing\n\twith insn.\n\t(validate_canon_reg): Strengthen param \"insn\" from rtx to\n\trtx_insn *.\n\t(canon_reg): Likewise.\n\t(fold_rtx): Likewise.  Replace use of NULL_RTX with NULL when\n\tdealing with insn.\n\t(record_jump_equiv): Strengthen param \"insn\" from rtx to\n\trtx_insn *.\n\t(try_back_substitute_reg): Likewise, also for locals \"prev\",\n\t\"bb_head\".\n\t(find_sets_in_insn): Likewise for param \"insn\".\n\t(canonicalize_insn): Likewise.\n\t(cse_insn): Likewise.  Add a checked cast.\n\t(invalidate_from_clobbers): Likewise for param \"insn\".\n\t(invalidate_from_sets_and_clobbers): Likewise.\n\t(cse_process_notes_1): Replace use of NULL_RTX with NULL when\n\tdealing with insn.\n\t(cse_prescan_path): Strengthen local \"insn\" from rtx to\n\trtx_insn *.\n\t(cse_extended_basic_block): Likewise for locals \"insn\" and\n\t\"prev_insn\".\n\t(cse_main): Likewise for param \"f\".\n\t(check_for_label_ref): Likewise for local \"insn\".\n\t(set_live_p): Likewise for second param (\"insn\").\n\t(insn_live_p): Likewise for first param (\"insn\") and for local\n\t\"next\".\n\t(cse_change_cc_mode_insn): Likewise for first param \"insn\".\n\t(cse_change_cc_mode_insns): Likewise for first and second params\n\t\"start\" and \"end\".\n\t(cse_cc_succs): Likewise for locals \"insns\", \"last_insns\", \"insn\"\n\tand \"end\".\n\t(cse_condition_code_reg): Likewise for locals \"last_insn\", \"insn\",\n\t\"cc_src_insn\".\n\nFrom-SVN: r214315", "tree": {"sha": "a8c6cb605a4a11c7032fc329b855bc28d6ffecae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a8c6cb605a4a11c7032fc329b855bc28d6ffecae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/204688845f355eb9af36a85558ea0bf706ab28a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/204688845f355eb9af36a85558ea0bf706ab28a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/204688845f355eb9af36a85558ea0bf706ab28a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/204688845f355eb9af36a85558ea0bf706ab28a5/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7e114fadf1ac83f36b1b84c60045ba016c4f37fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e114fadf1ac83f36b1b84c60045ba016c4f37fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e114fadf1ac83f36b1b84c60045ba016c4f37fa"}], "stats": {"total": 140, "additions": 91, "deletions": 49}, "files": [{"sha": "da1003aaeb178d60e7f79f4f593fe2f5b3f2b5af", "filename": "gcc/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/204688845f355eb9af36a85558ea0bf706ab28a5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/204688845f355eb9af36a85558ea0bf706ab28a5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=204688845f355eb9af36a85558ea0bf706ab28a5", "patch": "@@ -1,3 +1,44 @@\n+2014-08-22  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* cse.c (struct qty_table_elem): Strengthen field \"const_insn\"\n+\tfrom rtx to rtx_insn *.\n+\t(struct change_cc_mode_args): Likewise for field \"insn\".\n+\t(this_insn): Strengthen from rtx to rtx_insn *.\n+\t(make_new_qty): Replace use of NULL_RTX with NULL when dealing\n+\twith insn.\n+\t(validate_canon_reg): Strengthen param \"insn\" from rtx to\n+\trtx_insn *.\n+\t(canon_reg): Likewise.\n+\t(fold_rtx): Likewise.  Replace use of NULL_RTX with NULL when\n+\tdealing with insn.\n+\t(record_jump_equiv): Strengthen param \"insn\" from rtx to\n+\trtx_insn *.\n+\t(try_back_substitute_reg): Likewise, also for locals \"prev\",\n+\t\"bb_head\".\n+\t(find_sets_in_insn): Likewise for param \"insn\".\n+\t(canonicalize_insn): Likewise.\n+\t(cse_insn): Likewise.  Add a checked cast.\n+\t(invalidate_from_clobbers): Likewise for param \"insn\".\n+\t(invalidate_from_sets_and_clobbers): Likewise.\n+\t(cse_process_notes_1): Replace use of NULL_RTX with NULL when\n+\tdealing with insn.\n+\t(cse_prescan_path): Strengthen local \"insn\" from rtx to\n+\trtx_insn *.\n+\t(cse_extended_basic_block): Likewise for locals \"insn\" and\n+\t\"prev_insn\".\n+\t(cse_main): Likewise for param \"f\".\n+\t(check_for_label_ref): Likewise for local \"insn\".\n+\t(set_live_p): Likewise for second param (\"insn\").\n+\t(insn_live_p): Likewise for first param (\"insn\") and for local\n+\t\"next\".\n+\t(cse_change_cc_mode_insn): Likewise for first param \"insn\".\n+\t(cse_change_cc_mode_insns): Likewise for first and second params\n+\t\"start\" and \"end\".\n+\t(cse_cc_succs): Likewise for locals \"insns\", \"last_insns\", \"insn\"\n+\tand \"end\".\n+\t(cse_condition_code_reg): Likewise for locals \"last_insn\", \"insn\",\n+\t\"cc_src_insn\".\n+\n 2014-08-22  Alexander Ivchenko  <alexander.ivchenko@intel.com>\n \t    Maxim Kuznetsov  <maxim.kuznetsov@intel.com>\n \t    Anna Tikhonova  <anna.tikhonova@intel.com>"}, {"sha": "5d9abf5890734da975778ffe98a2a85b6d12edeb", "filename": "gcc/cse.c", "status": "modified", "additions": 50, "deletions": 49, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/204688845f355eb9af36a85558ea0bf706ab28a5/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/204688845f355eb9af36a85558ea0bf706ab28a5/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=204688845f355eb9af36a85558ea0bf706ab28a5", "patch": "@@ -241,7 +241,7 @@ static int next_qty;\n struct qty_table_elem\n {\n   rtx const_rtx;\n-  rtx const_insn;\n+  rtx_insn *const_insn;\n   rtx comparison_const;\n   int comparison_qty;\n   unsigned int first_reg, last_reg;\n@@ -258,7 +258,7 @@ static struct qty_table_elem *qty_table;\n    cse_change_cc_mode.  */\n struct change_cc_mode_args\n {\n-  rtx insn;\n+  rtx_insn *insn;\n   rtx newreg;\n };\n \n@@ -278,7 +278,7 @@ static enum machine_mode this_insn_cc0_mode, prev_insn_cc0_mode;\n \n /* Insn being scanned.  */\n \n-static rtx this_insn;\n+static rtx_insn *this_insn;\n static bool optimize_this_for_speed_p;\n \n /* Index by register number, gives the number of the next (or\n@@ -582,19 +582,19 @@ static inline unsigned canon_hash (rtx, enum machine_mode);\n static inline unsigned safe_hash (rtx, enum machine_mode);\n static inline unsigned hash_rtx_string (const char *);\n \n-static rtx canon_reg (rtx, rtx);\n+static rtx canon_reg (rtx, rtx_insn *);\n static enum rtx_code find_comparison_args (enum rtx_code, rtx *, rtx *,\n \t\t\t\t\t   enum machine_mode *,\n \t\t\t\t\t   enum machine_mode *);\n-static rtx fold_rtx (rtx, rtx);\n+static rtx fold_rtx (rtx, rtx_insn *);\n static rtx equiv_constant (rtx);\n-static void record_jump_equiv (rtx, bool);\n+static void record_jump_equiv (rtx_insn *, bool);\n static void record_jump_cond (enum rtx_code, enum machine_mode, rtx, rtx,\n \t\t\t      int);\n-static void cse_insn (rtx);\n+static void cse_insn (rtx_insn *);\n static void cse_prescan_path (struct cse_basic_block_data *);\n-static void invalidate_from_clobbers (rtx);\n-static void invalidate_from_sets_and_clobbers (rtx);\n+static void invalidate_from_clobbers (rtx_insn *);\n+static void invalidate_from_sets_and_clobbers (rtx_insn *);\n static rtx cse_process_notes (rtx, rtx, bool *);\n static void cse_extended_basic_block (struct cse_basic_block_data *);\n static int check_for_label_ref (rtx *, void *);\n@@ -604,11 +604,11 @@ static struct cse_reg_info * get_cse_reg_info (unsigned int regno);\n static int check_dependence (rtx *, void *);\n \n static void flush_hash_table (void);\n-static bool insn_live_p (rtx, int *);\n-static bool set_live_p (rtx, rtx, int *);\n+static bool insn_live_p (rtx_insn *, int *);\n+static bool set_live_p (rtx, rtx_insn *, int *);\n static int cse_change_cc_mode (rtx *, void *);\n-static void cse_change_cc_mode_insn (rtx, rtx);\n-static void cse_change_cc_mode_insns (rtx, rtx, rtx);\n+static void cse_change_cc_mode_insn (rtx_insn *, rtx);\n+static void cse_change_cc_mode_insns (rtx_insn *, rtx_insn *, rtx);\n static enum machine_mode cse_cc_succs (basic_block, basic_block, rtx, rtx,\n \t\t\t\t       bool);\n \f\n@@ -904,7 +904,7 @@ make_new_qty (unsigned int reg, enum machine_mode mode)\n   ent->first_reg = reg;\n   ent->last_reg = reg;\n   ent->mode = mode;\n-  ent->const_rtx = ent->const_insn = NULL_RTX;\n+  ent->const_rtx = ent->const_insn = NULL;\n   ent->comparison_code = UNKNOWN;\n \n   eqv = &reg_eqv_table[reg];\n@@ -2801,7 +2801,7 @@ exp_equiv_p (const_rtx x, const_rtx y, int validate, bool for_gcse)\n    the result if necessary.  INSN is as for canon_reg.  */\n \n static void\n-validate_canon_reg (rtx *xloc, rtx insn)\n+validate_canon_reg (rtx *xloc, rtx_insn *insn)\n {\n   if (*xloc)\n     {\n@@ -2825,7 +2825,7 @@ validate_canon_reg (rtx *xloc, rtx insn)\n    generally be discarded since the changes we are making are optional.  */\n \n static rtx\n-canon_reg (rtx x, rtx insn)\n+canon_reg (rtx x, rtx_insn *insn)\n {\n   int i;\n   enum rtx_code code;\n@@ -3104,7 +3104,7 @@ find_comparison_args (enum rtx_code code, rtx *parg1, rtx *parg2,\n    of X before modifying it.  */\n \n static rtx\n-fold_rtx (rtx x, rtx insn)\n+fold_rtx (rtx x, rtx_insn *insn)\n {\n   enum rtx_code code;\n   enum machine_mode mode;\n@@ -3580,7 +3580,7 @@ fold_rtx (rtx x, rtx insn)\n \t\tfor (p = p->first_same_value; p; p = p->next_same_value)\n \t\t  if (REG_P (p->exp))\n \t\t    return simplify_gen_binary (MINUS, mode, folded_arg0,\n-\t\t\t\t\t\tcanon_reg (p->exp, NULL_RTX));\n+\t\t\t\t\t\tcanon_reg (p->exp, NULL));\n \t    }\n \t  goto from_plus;\n \n@@ -3593,7 +3593,7 @@ fold_rtx (rtx x, rtx insn)\n \t      if (y && CONST_INT_P (XEXP (y, 1)))\n \t\treturn fold_rtx (plus_constant (mode, copy_rtx (y),\n \t\t\t\t\t\t-INTVAL (const_arg1)),\n-\t\t\t\t NULL_RTX);\n+\t\t\t\t NULL);\n \t    }\n \n \t  /* Fall through.  */\n@@ -3858,7 +3858,7 @@ equiv_constant (rtx x)\n    comparison is seen later, we will know its value.  */\n \n static void\n-record_jump_equiv (rtx insn, bool taken)\n+record_jump_equiv (rtx_insn *insn, bool taken)\n {\n   int cond_known_true;\n   rtx op0, op1;\n@@ -4185,7 +4185,7 @@ struct set\n    This is the last transformation that cse_insn will try to do.  */\n \n static void\n-try_back_substitute_reg (rtx set, rtx insn)\n+try_back_substitute_reg (rtx set, rtx_insn *insn)\n {\n   rtx dest = SET_DEST (set);\n   rtx src = SET_SRC (set);\n@@ -4201,8 +4201,8 @@ try_back_substitute_reg (rtx set, rtx insn)\n \t{\n \t  /* Scan for the previous nonnote insn, but stop at a basic\n \t     block boundary.  */\n-\t  rtx prev = insn;\n-\t  rtx bb_head = BB_HEAD (BLOCK_FOR_INSN (insn));\n+\t  rtx_insn *prev = insn;\n+\t  rtx_insn *bb_head = BB_HEAD (BLOCK_FOR_INSN (insn));\n \t  do\n \t    {\n \t      prev = PREV_INSN (prev);\n@@ -4249,7 +4249,7 @@ try_back_substitute_reg (rtx set, rtx insn)\n /* Record all the SETs in this instruction into SETS_PTR,\n    and return the number of recorded sets.  */\n static int\n-find_sets_in_insn (rtx insn, struct set **psets)\n+find_sets_in_insn (rtx_insn *insn, struct set **psets)\n {\n   struct set *sets = *psets;\n   int n_sets = 0;\n@@ -4331,7 +4331,7 @@ find_sets_in_insn (rtx insn, struct set **psets)\n    see canon_reg.  */\n \n static void\n-canonicalize_insn (rtx insn, struct set **psets, int n_sets)\n+canonicalize_insn (rtx_insn *insn, struct set **psets, int n_sets)\n {\n   struct set *sets = *psets;\n   rtx tem;\n@@ -4487,7 +4487,7 @@ canonicalize_insn (rtx insn, struct set **psets, int n_sets)\n    of available values.  */\n \n static void\n-cse_insn (rtx insn)\n+cse_insn (rtx_insn *insn)\n {\n   rtx x = PATTERN (insn);\n   int i;\n@@ -5481,7 +5481,7 @@ cse_insn (rtx insn)\n \t\t}\n \n \t      delete_insn_and_edges (insn);\n-\t      insn = new_rtx;\n+\t      insn = as_a <rtx_insn *> (new_rtx);\n \t    }\n \t  else\n \t    INSN_CODE (insn) = -1;\n@@ -5984,7 +5984,7 @@ invalidate_memory (void)\n    alias with something that is SET or CLOBBERed.  */\n \n static void\n-invalidate_from_clobbers (rtx insn)\n+invalidate_from_clobbers (rtx_insn *insn)\n {\n   rtx x = PATTERN (insn);\n \n@@ -6026,7 +6026,7 @@ invalidate_from_clobbers (rtx insn)\n    alias with something that is SET or CLOBBERed.  */\n \n static void\n-invalidate_from_sets_and_clobbers (rtx insn)\n+invalidate_from_sets_and_clobbers (rtx_insn *insn)\n {\n   rtx tem;\n   rtx x = PATTERN (insn);\n@@ -6154,7 +6154,7 @@ cse_process_notes_1 (rtx x, rtx object, bool *changed)\n \t}\n \n       /* Otherwise, canonicalize this register.  */\n-      return canon_reg (x, NULL_RTX);\n+      return canon_reg (x, NULL);\n \n     default:\n       break;\n@@ -6366,7 +6366,7 @@ cse_prescan_path (struct cse_basic_block_data *data)\n   for (path_entry = 0; path_entry < path_size; path_entry++)\n     {\n       basic_block bb;\n-      rtx insn;\n+      rtx_insn *insn;\n \n       bb = data->path[path_entry].bb;\n \n@@ -6405,7 +6405,7 @@ cse_extended_basic_block (struct cse_basic_block_data *ebb_data)\n   for (path_entry = 0; path_entry < path_size; path_entry++)\n     {\n       basic_block bb;\n-      rtx insn;\n+      rtx_insn *insn;\n \n       bb = ebb_data->path[path_entry].bb;\n \n@@ -6469,7 +6469,8 @@ cse_extended_basic_block (struct cse_basic_block_data *ebb_data)\n \t\t     Here we use fact that nothing expects CC0 to be\n \t\t     valid over an insn, which is true until the final\n \t\t     pass.  */\n-\t\t  rtx prev_insn, tem;\n+\t\t  rtx_insn *prev_insn;\n+\t\t  rtx tem;\n \n \t\t  prev_insn = prev_nonnote_nondebug_insn (insn);\n \t\t  if (prev_insn && NONJUMP_INSN_P (prev_insn)\n@@ -6560,7 +6561,7 @@ cse_extended_basic_block (struct cse_basic_block_data *ebb_data)\n    Return 0 otherwise.  */\n \n static int\n-cse_main (rtx f ATTRIBUTE_UNUSED, int nregs)\n+cse_main (rtx_insn *f ATTRIBUTE_UNUSED, int nregs)\n {\n   struct cse_basic_block_data ebb_data;\n   basic_block bb;\n@@ -6657,7 +6658,7 @@ cse_main (rtx f ATTRIBUTE_UNUSED, int nregs)\n static int\n check_for_label_ref (rtx *rtl, void *data)\n {\n-  rtx insn = (rtx) data;\n+  rtx_insn *insn = (rtx_insn *) data;\n \n   /* If this insn uses a LABEL_REF and there isn't a REG_LABEL_OPERAND\n      note for it, we must rerun jump since it needs to place the note.  If\n@@ -6811,7 +6812,7 @@ is_dead_reg (rtx x, int *counts)\n \n /* Return true if set is live.  */\n static bool\n-set_live_p (rtx set, rtx insn ATTRIBUTE_UNUSED, /* Only used with HAVE_cc0.  */\n+set_live_p (rtx set, rtx_insn *insn ATTRIBUTE_UNUSED, /* Only used with HAVE_cc0.  */\n \t    int *counts)\n {\n #ifdef HAVE_cc0\n@@ -6838,7 +6839,7 @@ set_live_p (rtx set, rtx insn ATTRIBUTE_UNUSED, /* Only used with HAVE_cc0.  */\n /* Return true if insn is live.  */\n \n static bool\n-insn_live_p (rtx insn, int *counts)\n+insn_live_p (rtx_insn *insn, int *counts)\n {\n   int i;\n   if (!cfun->can_delete_dead_exceptions && !insn_nothrow_p (insn))\n@@ -6863,7 +6864,7 @@ insn_live_p (rtx insn, int *counts)\n     }\n   else if (DEBUG_INSN_P (insn))\n     {\n-      rtx next;\n+      rtx_insn *next;\n \n       for (next = NEXT_INSN (insn); next; next = NEXT_INSN (next))\n \tif (NOTE_P (next))\n@@ -7116,7 +7117,7 @@ cse_change_cc_mode (rtx *loc, void *data)\n    GET_MODE (NEWREG) in INSN.  */\n \n static void\n-cse_change_cc_mode_insn (rtx insn, rtx newreg)\n+cse_change_cc_mode_insn (rtx_insn *insn, rtx newreg)\n {\n   struct change_cc_mode_args args;\n   int success;\n@@ -7143,9 +7144,9 @@ cse_change_cc_mode_insn (rtx insn, rtx newreg)\n    any instruction which modifies NEWREG.  */\n \n static void\n-cse_change_cc_mode_insns (rtx start, rtx end, rtx newreg)\n+cse_change_cc_mode_insns (rtx_insn *start, rtx_insn *end, rtx newreg)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n \n   for (insn = start; insn != end; insn = NEXT_INSN (insn))\n     {\n@@ -7183,9 +7184,9 @@ cse_cc_succs (basic_block bb, basic_block orig_bb, rtx cc_reg, rtx cc_src,\n   enum machine_mode mode;\n   unsigned int insn_count;\n   edge e;\n-  rtx insns[2];\n+  rtx_insn *insns[2];\n   enum machine_mode modes[2];\n-  rtx last_insns[2];\n+  rtx_insn *last_insns[2];\n   unsigned int i;\n   rtx newreg;\n   edge_iterator ei;\n@@ -7201,8 +7202,8 @@ cse_cc_succs (basic_block bb, basic_block orig_bb, rtx cc_reg, rtx cc_src,\n   insn_count = 0;\n   FOR_EACH_EDGE (e, ei, bb->succs)\n     {\n-      rtx insn;\n-      rtx end;\n+      rtx_insn *insn;\n+      rtx_insn *end;\n \n       if (e->flags & EDGE_COMPLEX)\n \tcontinue;\n@@ -7379,10 +7380,10 @@ cse_condition_code_reg (void)\n \n   FOR_EACH_BB_FN (bb, cfun)\n     {\n-      rtx last_insn;\n+      rtx_insn *last_insn;\n       rtx cc_reg;\n-      rtx insn;\n-      rtx cc_src_insn;\n+      rtx_insn *insn;\n+      rtx_insn *cc_src_insn;\n       rtx cc_src;\n       enum machine_mode mode;\n       enum machine_mode orig_mode;\n@@ -7407,7 +7408,7 @@ cse_condition_code_reg (void)\n       else\n \tcontinue;\n \n-      cc_src_insn = NULL_RTX;\n+      cc_src_insn = NULL;\n       cc_src = NULL_RTX;\n       for (insn = PREV_INSN (last_insn);\n \t   insn && insn != PREV_INSN (BB_HEAD (bb));"}]}