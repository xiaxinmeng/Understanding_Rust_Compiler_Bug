{"sha": "8d0741923dc99b7876f8faafdc238b59a32d0ffc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQwNzQxOTIzZGM5OWI3ODc2ZjhmYWFmZGMyMzhiNTlhMzJkMGZmYw==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2010-07-29T12:39:57Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2010-07-29T12:39:57Z"}, "message": "re PR rtl-optimization/42575 (arm-eabi-gcc 64-bit multiply weirdness)\n\n\tPR rtl-optimization/42575\n\t* dce.c (word_dce_process_block): Renamed from byte_dce_process_block.\n\tArgument AU removed.  All callers changed.  Ignore artificial refs.\n\tUse return value of df_word_lr_simulate_defs to decide whether an insn\n\tis necessary.\n\t(fast_dce): Rename arg to WORD_LEVEL.\n\t(run_word_dce): Renamed from rest_of_handle_fast_byte_dce.  No longer\n\tstatic.\n\t(pass_fast_rtl_byte_dce): Delete.\n\t* dce.h (run_word_dce): Declare.\n\t* df-core.c (df_print_word_regset): Renamed from df_print_byteregset.\n\tAll callers changed.  Simplify code to only deal with two-word regs.\n\t* df.h (DF_WORD_LR): Renamed from DF_BYTE_LR.\n\t(DF_WORD_LR_BB_INFO): Renamed from DF_BYTE_LR_BB_INFO.\n\t(DF_WORD_LR_IN): Renamed from DF_BYTE_LR_IN.\n\t(DF_WORD_LR_OUT): Renamed from DF_BYTE_LR_OUT.\n\t(struct df_word_lr_bb_info): Renamed from df_byte_lr_bb_info.\n\t(df_word_lr_mark_ref): Declare.\n\t(df_word_lr_add_problem, df_word_lr_mark_ref, df_word_lr_simulate_defs,\n\tdf_word_lr_simulate_uses): Declare or rename from byte variants.\n\t(df_byte_lr_simulate_artificial_refs_at_top,\n\tdf_byte_lr_simulate_artificial_refs_at_end, df_byte_lr_get_regno_start,\n\tdf_byte_lr_get_regno_len, df_compute_accessed_bytes): Delete\n\tdeclarations.\n\t(df_word_lr_get_bb_info): Rename from df_byte_lr_get_bb_info.\n\t(enum df_mm): Delete.\n\t* df-byte-scan.c: Delete file.\n\t* df-problems.c (df_word_lr_problem_data): Renamed from\n\tdf_byte_lr_problem_data, all members deleted except for\n\tWORD_LR_BITMAPS, which is renamed from BYTE_LR_BITMAPS.  Uses changed.\n\t(df_word_lr_expand_bitmap, df_byte_lr_simulate_artificial_refs_at_top,\n\tdf_byte_lr_simulate_artificial_refs_at_end, df_byte_lr_get_regno_start,\n\tdf_byte_lr_get_regno_len, df_byte_lr_check_regs,\n\tdf_byte_lr_confluence_0): Delete functions.\n\t(df_word_lr_free_bb_info): Renamed from df_byte_lr_free_bb_info; all\n\tcallers changed.\n\t(df_word_lr_alloc): Renamed from df_byte_lr_alloc; all callers changed.\n\tDon't initialize members that were deleted, don't try to discover data\n\tabout registers.  Ignore hard regs.\n\t(df_word_lr_reset): Renamed from df_byte_lr_reset; all callers changed.\n\t(df_word_lr_mark_ref): New function.\n\t(df_word_lr_bb_local_compute): Renamed from\n\tdf_byte_bb_lr_local_compute; all callers changed.  Use\n\tdf_word_lr_mark_ref.  Assert that artificial refs don't include\n\tpseudos.  Ignore hard registers.\n\t(df_word_lr_local_compute): Renamed from df_byte_lr_local_compute.\n\tAssert that exit block uses don't contain pseudos.\n\t(df_word_lr_init): Renamed from df_byte_lr_init; all callers changed.\n\t(df_word_lr_confluence_n): Renamed from df_byte_lr_confluence_n; all\n\tcallers changed.  Ignore hard regs.\n\t(df_word_lr_transfer_function): Renamed from\n\tdf_byte_lr_transfer_function; all callers changed.\n\t(df_word_lr_free): Renamed from df_byte_lr_free; all callers changed.\n\t(df_word_lr_top_dump): Renamed from df_byte_lr_top_dump; all callers\n\tchanged.\n\t(df_word_lr_bottom_dump): Renamed from df_byte_lr_bottom_dump; all\n\tcallers changed.\n\t(problem_WORD_LR): Renamed from problem_BYTE_LR; uses changed;\n\tconfluence operator 0 set to NULL.\n\t(df_word_lr_add_problem): Renamed from df_byte_lr_add_problem; all\n\tcallers changed.\n\t(df_word_lr_simulate_defs): Renamed from df_byte_lr_simulate_defs.\n\tReturn bool, true if bitmap changed or insn otherwise necessary.\n\tAll callers changed.  Simplify using df_word_lr_mark_ref.\n\t(df_word_lr_simulate_uses): Renamed from df_byte_lr_simulate_uses;\n\tall callers changed.  Simplify using df_word_lr_mark_ref.\n\t* lower-subreg.c: Include \"dce.h\"\n\t(decompose_multiword_subregs): Call run_word_dce if df available.\n\t* Makefile.in (lower-subreg.o): Adjust dependencies.\n\t(df-byte-scan.o): Delete.\n\t* timevar.def (TV_DF_WORD_LR): Renamed from TV_DF_BYTE_LR.\n\nFrom-SVN: r162678", "tree": {"sha": "54d2debed0ddf53a7d5d7ad6d3497aad94a384e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/54d2debed0ddf53a7d5d7ad6d3497aad94a384e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d0741923dc99b7876f8faafdc238b59a32d0ffc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d0741923dc99b7876f8faafdc238b59a32d0ffc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d0741923dc99b7876f8faafdc238b59a32d0ffc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d0741923dc99b7876f8faafdc238b59a32d0ffc/comments", "author": null, "committer": null, "parents": [{"sha": "9b638c031a7ec32d422e150f613f1ce718305a2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b638c031a7ec32d422e150f613f1ce718305a2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b638c031a7ec32d422e150f613f1ce718305a2a"}], "stats": {"total": 1263, "additions": 299, "deletions": 964}, "files": [{"sha": "e081dc26e684359bfa8d54f1fd7a0ce7dc9f7085", "filename": "gcc/ChangeLog", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d0741923dc99b7876f8faafdc238b59a32d0ffc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d0741923dc99b7876f8faafdc238b59a32d0ffc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8d0741923dc99b7876f8faafdc238b59a32d0ffc", "patch": "@@ -1,3 +1,77 @@\n+2010-07-29  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\tPR rtl-optimization/42575\n+\t* dce.c (word_dce_process_block): Renamed from byte_dce_process_block.\n+\tArgument AU removed.  All callers changed.  Ignore artificial refs.\n+\tUse return value of df_word_lr_simulate_defs to decide whether an insn\n+\tis necessary.\n+\t(fast_dce): Rename arg to WORD_LEVEL.\n+\t(run_word_dce): Renamed from rest_of_handle_fast_byte_dce.  No longer\n+\tstatic.\n+\t(pass_fast_rtl_byte_dce): Delete.\n+\t* dce.h (run_word_dce): Declare.\n+\t* df-core.c (df_print_word_regset): Renamed from df_print_byteregset.\n+\tAll callers changed.  Simplify code to only deal with two-word regs.\n+\t* df.h (DF_WORD_LR): Renamed from DF_BYTE_LR.\n+\t(DF_WORD_LR_BB_INFO): Renamed from DF_BYTE_LR_BB_INFO.\n+\t(DF_WORD_LR_IN): Renamed from DF_BYTE_LR_IN.\n+\t(DF_WORD_LR_OUT): Renamed from DF_BYTE_LR_OUT.\n+\t(struct df_word_lr_bb_info): Renamed from df_byte_lr_bb_info.\n+\t(df_word_lr_mark_ref): Declare.\n+\t(df_word_lr_add_problem, df_word_lr_mark_ref, df_word_lr_simulate_defs,\n+\tdf_word_lr_simulate_uses): Declare or rename from byte variants.\n+\t(df_byte_lr_simulate_artificial_refs_at_top,\n+\tdf_byte_lr_simulate_artificial_refs_at_end, df_byte_lr_get_regno_start,\n+\tdf_byte_lr_get_regno_len, df_compute_accessed_bytes): Delete\n+\tdeclarations.\n+\t(df_word_lr_get_bb_info): Rename from df_byte_lr_get_bb_info.\n+\t(enum df_mm): Delete.\n+\t* df-byte-scan.c: Delete file.\n+\t* df-problems.c (df_word_lr_problem_data): Renamed from\n+\tdf_byte_lr_problem_data, all members deleted except for\n+\tWORD_LR_BITMAPS, which is renamed from BYTE_LR_BITMAPS.  Uses changed.\n+\t(df_word_lr_expand_bitmap, df_byte_lr_simulate_artificial_refs_at_top,\n+\tdf_byte_lr_simulate_artificial_refs_at_end, df_byte_lr_get_regno_start,\n+\tdf_byte_lr_get_regno_len, df_byte_lr_check_regs,\n+\tdf_byte_lr_confluence_0): Delete functions.\n+\t(df_word_lr_free_bb_info): Renamed from df_byte_lr_free_bb_info; all\n+\tcallers changed.\n+\t(df_word_lr_alloc): Renamed from df_byte_lr_alloc; all callers changed.\n+\tDon't initialize members that were deleted, don't try to discover data\n+\tabout registers.  Ignore hard regs.\n+\t(df_word_lr_reset): Renamed from df_byte_lr_reset; all callers changed.\n+\t(df_word_lr_mark_ref): New function.\n+\t(df_word_lr_bb_local_compute): Renamed from\n+\tdf_byte_bb_lr_local_compute; all callers changed.  Use\n+\tdf_word_lr_mark_ref.  Assert that artificial refs don't include\n+\tpseudos.  Ignore hard registers.\n+\t(df_word_lr_local_compute): Renamed from df_byte_lr_local_compute.\n+\tAssert that exit block uses don't contain pseudos.\n+\t(df_word_lr_init): Renamed from df_byte_lr_init; all callers changed.\n+\t(df_word_lr_confluence_n): Renamed from df_byte_lr_confluence_n; all\n+\tcallers changed.  Ignore hard regs.\n+\t(df_word_lr_transfer_function): Renamed from\n+\tdf_byte_lr_transfer_function; all callers changed.\n+\t(df_word_lr_free): Renamed from df_byte_lr_free; all callers changed.\n+\t(df_word_lr_top_dump): Renamed from df_byte_lr_top_dump; all callers\n+\tchanged.\n+\t(df_word_lr_bottom_dump): Renamed from df_byte_lr_bottom_dump; all\n+\tcallers changed.\n+\t(problem_WORD_LR): Renamed from problem_BYTE_LR; uses changed;\n+\tconfluence operator 0 set to NULL.\n+\t(df_word_lr_add_problem): Renamed from df_byte_lr_add_problem; all\n+\tcallers changed.\n+\t(df_word_lr_simulate_defs): Renamed from df_byte_lr_simulate_defs.\n+\tReturn bool, true if bitmap changed or insn otherwise necessary.\n+\tAll callers changed.  Simplify using df_word_lr_mark_ref.\n+\t(df_word_lr_simulate_uses): Renamed from df_byte_lr_simulate_uses;\n+\tall callers changed.  Simplify using df_word_lr_mark_ref.\n+\t* lower-subreg.c: Include \"dce.h\"\n+\t(decompose_multiword_subregs): Call run_word_dce if df available.\n+\t* Makefile.in (lower-subreg.o): Adjust dependencies.\n+\t(df-byte-scan.o): Delete.\n+\t* timevar.def (TV_DF_WORD_LR): Renamed from TV_DF_BYTE_LR.\n+\n 2010-07-29  Richard Guenther  <rguenther@suse.de>\n \n \t* tree.c (build_vector): Assert that the vector constant"}, {"sha": "a6b3460e9489c53d7f3fd2ee06ab36bbffd2e440", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d0741923dc99b7876f8faafdc238b59a32d0ffc/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d0741923dc99b7876f8faafdc238b59a32d0ffc/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=8d0741923dc99b7876f8faafdc238b59a32d0ffc", "patch": "@@ -1202,7 +1202,6 @@ OBJS-common = \\\n \tdce.o \\\n \tddg.o \\\n \tdebug.o \\\n-\tdf-byte-scan.o \\\n \tdf-core.o \\\n \tdf-problems.o \\\n \tdf-scan.o \\\n@@ -3167,8 +3166,6 @@ df-scan.o : df-scan.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    hard-reg-set.h $(BASIC_BLOCK_H) $(DF_H) $(BITMAP_H) sbitmap.h $(TIMEVAR_H) \\\n    $(TM_P_H) $(FLAGS_H) $(TARGET_H) $(TARGET_DEF_H) $(TREE_H) output.h \\\n    $(TREE_PASS_H) $(EMIT_RTL_H)\n-df-byte-scan.o : df-byte-scan.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n-   $(TM_P_H) $(DF_H) output.h $(DBGCNT_H)\n regstat.o : regstat.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TM_P_H) $(FLAGS_H) $(REGS_H) output.h $(EXCEPT_H) hard-reg-set.h \\\n    $(BASIC_BLOCK_H) $(TIMEVAR_H) $(DF_H)\n@@ -3487,7 +3484,7 @@ dbgcnt.o: dbgcnt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TOPLEV_H) $(DIAGNOSTIC_\n lower-subreg.o : lower-subreg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(MACHMODE_H) $(TM_H) $(RTL_H) $(TM_P_H) $(TIMEVAR_H) $(FLAGS_H) \\\n    insn-config.h $(BASIC_BLOCK_H) $(RECOG_H) $(OBSTACK_H) $(BITMAP_H) \\\n-   $(EXPR_H) $(EXCEPT_H) $(REGS_H) $(TREE_PASS_H) $(DF_H)\n+   $(EXPR_H) $(EXCEPT_H) $(REGS_H) $(TREE_PASS_H) $(DF_H) dce.h\n target-globals.o : target-globals.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) insn-config.h $(MACHMODE_H) $(GGC_H) $(TOPLEV_H) target-globals.h \\\n    $(FLAGS_H) $(REGS_H) $(RTL_H) reload.h expmed.h $(EXPR_H) $(OPTABS_H) \\"}, {"sha": "19f8e42030d3ba28f43449e6a84c332b763407a3", "filename": "gcc/dce.c", "status": "modified", "additions": 26, "deletions": 86, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d0741923dc99b7876f8faafdc238b59a32d0ffc/gcc%2Fdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d0741923dc99b7876f8faafdc238b59a32d0ffc/gcc%2Fdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdce.c?ref=8d0741923dc99b7876f8faafdc238b59a32d0ffc", "patch": "@@ -767,12 +767,11 @@ struct rtl_opt_pass pass_ud_rtl_dce =\n    artificial uses. */\n \n static bool\n-byte_dce_process_block (basic_block bb, bool redo_out, bitmap au)\n+word_dce_process_block (basic_block bb, bool redo_out)\n {\n   bitmap local_live = BITMAP_ALLOC (&dce_tmp_bitmap_obstack);\n   rtx insn;\n   bool block_changed;\n-  df_ref *def_rec;\n \n   if (redo_out)\n     {\n@@ -781,85 +780,47 @@ byte_dce_process_block (basic_block bb, bool redo_out, bitmap au)\n \t set.  */\n       edge e;\n       edge_iterator ei;\n-      df_confluence_function_n con_fun_n = df_byte_lr->problem->con_fun_n;\n-      bitmap_clear (DF_BYTE_LR_OUT (bb));\n+      df_confluence_function_n con_fun_n = df_word_lr->problem->con_fun_n;\n+      bitmap_clear (DF_WORD_LR_OUT (bb));\n       FOR_EACH_EDGE (e, ei, bb->succs)\n \t(*con_fun_n) (e);\n     }\n \n   if (dump_file)\n     {\n       fprintf (dump_file, \"processing block %d live out = \", bb->index);\n-      df_print_byte_regset (dump_file, DF_BYTE_LR_OUT (bb));\n+      df_print_word_regset (dump_file, DF_WORD_LR_OUT (bb));\n     }\n \n-  bitmap_copy (local_live, DF_BYTE_LR_OUT (bb));\n-\n-  df_byte_lr_simulate_artificial_refs_at_end (bb, local_live);\n+  bitmap_copy (local_live, DF_WORD_LR_OUT (bb));\n \n   FOR_BB_INSNS_REVERSE (bb, insn)\n     if (INSN_P (insn))\n       {\n-\t/* The insn is needed if there is someone who uses the output.  */\n-\tfor (def_rec = DF_INSN_DEFS (insn); *def_rec; def_rec++)\n-\t  {\n-\t    df_ref def = *def_rec;\n-\t    unsigned int last;\n-\t    unsigned int dregno = DF_REF_REGNO (def);\n-\t    unsigned int start = df_byte_lr_get_regno_start (dregno);\n-\t    unsigned int len = df_byte_lr_get_regno_len (dregno);\n-\n-\t    unsigned int sb;\n-\t    unsigned int lb;\n-\t    /* This is one of the only places where DF_MM_MAY should\n-\t       be used for defs.  Need to make sure that we are\n-\t       checking for all of the bits that may be used.  */\n-\n-\t    if (!df_compute_accessed_bytes (def, DF_MM_MAY, &sb, &lb))\n-\t      {\n-\t\tstart += sb;\n-\t\tlen = lb - sb;\n-\t      }\n-\n-\t    if (bitmap_bit_p (au, dregno))\n-\t      {\n-\t\tmark_insn (insn, true);\n-\t\tgoto quickexit;\n-\t      }\n-\n-\t    last = start + len;\n-\t    while (start < last)\n-\t      if (bitmap_bit_p (local_live, start++))\n-\t\t{\n-\t\t  mark_insn (insn, true);\n-\t\t  goto quickexit;\n-\t\t}\n-\t  }\n-\n-      quickexit:\n-\n+\tbool any_changed;\n \t/* No matter if the instruction is needed or not, we remove\n \t   any regno in the defs from the live set.  */\n-\tdf_byte_lr_simulate_defs (insn, local_live);\n+\tany_changed = df_word_lr_simulate_defs (insn, local_live);\n+\tif (any_changed)\n+\t  mark_insn (insn, true);\n \n \t/* On the other hand, we do not allow the dead uses to set\n \t   anything in local_live.  */\n \tif (marked_insn_p (insn))\n-\t  df_byte_lr_simulate_uses (insn, local_live);\n+\t  df_word_lr_simulate_uses (insn, local_live);\n \n \tif (dump_file)\n \t  {\n \t    fprintf (dump_file, \"finished processing insn %d live out = \",\n \t\t     INSN_UID (insn));\n-\t    df_print_byte_regset (dump_file, local_live);\n+\t    df_print_word_regset (dump_file, local_live);\n \t  }\n       }\n \n-  df_byte_lr_simulate_artificial_refs_at_top (bb, local_live);\n-\n-  block_changed = !bitmap_equal_p (local_live, DF_BYTE_LR_IN (bb));\n+  block_changed = !bitmap_equal_p (local_live, DF_WORD_LR_IN (bb));\n   if (block_changed)\n-    bitmap_copy (DF_BYTE_LR_IN (bb), local_live);\n+    bitmap_copy (DF_WORD_LR_IN (bb), local_live);\n+\n   BITMAP_FREE (local_live);\n   return block_changed;\n }\n@@ -938,12 +899,12 @@ dce_process_block (basic_block bb, bool redo_out, bitmap au)\n }\n \n \n-/* Perform fast DCE once initialization is done.  If BYTE_LEVEL is\n-   true, use the byte level dce, otherwise do it at the pseudo\n+/* Perform fast DCE once initialization is done.  If WORD_LEVEL is\n+   true, use the word level dce, otherwise do it at the pseudo\n    level.  */\n \n static void\n-fast_dce (bool byte_level)\n+fast_dce (bool word_level)\n {\n   int *postorder = df_get_postorder (DF_BACKWARD);\n   int n_blocks = df_get_n_blocks (DF_BACKWARD);\n@@ -985,10 +946,9 @@ fast_dce (bool byte_level)\n \t      continue;\n \t    }\n \n-\t  if (byte_level)\n+\t  if (word_level)\n \t    local_changed\n-\t      = byte_dce_process_block (bb, bitmap_bit_p (redo_out, index),\n-\t\t\t\t\t  bb_has_eh_pred (bb) ? au_eh : au);\n+\t      = word_dce_process_block (bb, bitmap_bit_p (redo_out, index));\n \t  else\n \t    local_changed\n \t      = dce_process_block (bb, bitmap_bit_p (redo_out, index),\n@@ -1028,8 +988,8 @@ fast_dce (bool byte_level)\n \t     to redo the dataflow equations for the blocks that had a\n \t     change at the top of the block.  Then we need to redo the\n \t     iteration.  */\n-\t  if (byte_level)\n-\t    df_analyze_problem (df_byte_lr, all_blocks, postorder, n_blocks);\n+\t  if (word_level)\n+\t    df_analyze_problem (df_word_lr, all_blocks, postorder, n_blocks);\n \t  else\n \t    df_analyze_problem (df_lr, all_blocks, postorder, n_blocks);\n \n@@ -1062,14 +1022,15 @@ rest_of_handle_fast_dce (void)\n \n /* Fast byte level DCE.  */\n \n-static unsigned int\n-rest_of_handle_fast_byte_dce (void)\n+void\n+run_word_dce (void)\n {\n-  df_byte_lr_add_problem ();\n+  timevar_push (TV_DCE);\n+  df_word_lr_add_problem ();\n   init_dce (true);\n   fast_dce (true);\n   fini_dce (true);\n-  return 0;\n+  timevar_pop (TV_DCE);\n }\n \n \n@@ -1139,24 +1100,3 @@ struct rtl_opt_pass pass_fast_rtl_dce =\n   TODO_ggc_collect                      /* todo_flags_finish */\n  }\n };\n-\n-struct rtl_opt_pass pass_fast_rtl_byte_dce =\n-{\n- {\n-  RTL_PASS,\n-  \"byte-dce\",                           /* name */\n-  gate_fast_dce,                        /* gate */\n-  rest_of_handle_fast_byte_dce,         /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_DCE,                               /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_dump_func |\n-  TODO_df_finish | TODO_verify_rtl_sharing |\n-  TODO_ggc_collect                      /* todo_flags_finish */\n- }\n-};"}, {"sha": "341588c7eb5169eaffc1da969affbfacb7fe422a", "filename": "gcc/dce.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d0741923dc99b7876f8faafdc238b59a32d0ffc/gcc%2Fdce.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d0741923dc99b7876f8faafdc238b59a32d0ffc/gcc%2Fdce.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdce.h?ref=8d0741923dc99b7876f8faafdc238b59a32d0ffc", "patch": "@@ -20,6 +20,7 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_DCE_H\n #define GCC_DCE_H\n \n+extern void run_word_dce (void);\n extern void run_fast_dce (void);\n extern void run_fast_df_dce (void);\n "}, {"sha": "8271465041e01a3ca7d7071a8586c23cd22f9ef7", "filename": "gcc/df-byte-scan.c", "status": "removed", "additions": 0, "deletions": 340, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b638c031a7ec32d422e150f613f1ce718305a2a/gcc%2Fdf-byte-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b638c031a7ec32d422e150f613f1ce718305a2a/gcc%2Fdf-byte-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-byte-scan.c?ref=9b638c031a7ec32d422e150f613f1ce718305a2a", "patch": "@@ -1,340 +0,0 @@\n-/* Scanning of rtl byte level scanning for dataflow analysis.\n-   Copyright (C) 2008  Free Software Foundation, Inc.\n-   Contributed by Kenneth Zadeck (zadeck@naturalbridge.com).\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"rtl.h\"\n-#include \"tm_p.h\"\n-#include \"df.h\"\n-#include \"output.h\"\n-#include \"dbgcnt.h\"\n-\n-/* The following suite of functions provides bytewise modeling of REFs\n-   which are struct df_ref.  START_BYTE and LAST_BYTE are returned.\n-   These can be used as indexes into bitmaps.  The indexes are\n-   normalized so that 0 is the lowest numbered byte, of the inner\n-   register according to the natural ordering of the machine.\n-\n-   This code is designed to be used in backwards scans (which is, of\n-   course, the way all dataflow scanning should really be done).  It\n-   would require a lot of reworking of the api to make it work in a\n-   forwards scanning world.  */\n-\n-\n-/* Helper for df_compute_accessed_bytes.  Ref is some sort of extract.\n-   Return true if this effects the entire reg in REF.  Return false if\n-   otherwise and set START_BYTE and LAST_BYTE.  See the description of\n-   df_compute_accessed_bytes for a description of MM.  */\n-\n-static bool\n-df_compute_accessed_bytes_extract (df_ref ref,\n-\t\t\t\t   enum df_mm mm ,\n-\t\t\t\t   unsigned int *start_byte,\n-\t\t\t\t   unsigned int *last_byte)\n-{\n-  int start;\n-  int last;\n-  rtx reg = DF_REF_REG (ref);\n-  enum machine_mode m1;\n-  int m1_size;\n-  enum machine_mode m2;\n-  int m2_size;\n-\n-  /* (*_extract:M1 (reg:M2 X) WIDTH POS)\n-     (*_extract:M1 (subreg:M1 (reg:M2 X N) WIDTH POS)\n-\n-     This is a bitfield extraction.  The assignment clobbers/extracts\n-     exactly the bits named by WIDTH and POS and does not affect the\n-     other bits in register X.  It is also technically possible that\n-     the bits asked for are longer than units per word.  */\n-\n-  int offset = DF_REF_EXTRACT_OFFSET (ref);\n-  int width = DF_REF_EXTRACT_WIDTH (ref);\n-\n-  if (width == -1 || offset == -1)\n-    return true;\n-\n-  m1 = DF_REF_EXTRACT_MODE (ref);\n-  m1_size = GET_MODE_SIZE (m1);\n-\n-  gcc_assert (m1_size <= UNITS_PER_WORD);\n-\n-  /* There is nothing to do if this is a pure big or small endian\n-     machine, but if the machine is a pastiche, we have to convert the\n-     bit offsets into byte offsets.  This is only possible because we\n-     do not care about individual bits because this conversion may\n-     make the bits non-contiguous.  */\n-  if (BYTES_BIG_ENDIAN != BITS_BIG_ENDIAN)\n-    offset = GET_MODE_BITSIZE (m1_size) - (offset + width);\n-\n-  /* The offset is now in the same order as the subreg_byte.  */\n-  if (GET_CODE (reg) == SUBREG)\n-    {\n-      m2 = GET_MODE (SUBREG_REG (reg));\n-      m2_size = GET_MODE_SIZE (m2);\n-      if (m1_size > m2_size)\n-\t/* If it is paradoxical, subreg_byte will be zero.  */\n-\toffset -= subreg_lowpart_offset (m2, m1) * BITS_PER_UNIT;\n-      else\n-\toffset += SUBREG_BYTE (reg) * BITS_PER_UNIT;\n-    }\n-  else\n-    {\n-      m2 = GET_MODE (reg);\n-      m2_size = GET_MODE_SIZE (m2);\n-    }\n-\n-  if (mm == DF_MM_MUST)\n-    {\n-      /* For defs (generally), count the byte only if the whole byte\n-\t is touched.  */\n-      start = (offset + BITS_PER_UNIT - 1) / BITS_PER_UNIT;\n-      last = (width + offset) / BITS_PER_UNIT;\n-\n-      /* In the case where there is nothing, start may be one larger\n-\t than last, we canonize this to return zeros.  This keeps\n-\t computations of length from being negative.  */\n-      if (start >= last)\n-\t{\n-\t  start = 0;\n-\t  last = 0;\n-\t}\n-    }\n-  else\n-    {\n-      /* For uses (generally), count the byte if any part of the byte\n-\t is touched.  */\n-      start = offset / BITS_PER_UNIT;\n-      last = (width + offset + BITS_PER_UNIT - 1) / BITS_PER_UNIT;\n-    }\n-\n-  /* Paradoxical truncation.  */\n-  if (start < 0)\n-    start = 0;\n-  if (last > m2_size)\n-    last = m2_size;\n-\n-  if (dump_file)\n-    fprintf (dump_file, \"    cpb extract regno=%d start=%d last=%d\\n\",\n-\t     DF_REF_REGNO (ref), start, last);\n-\n-  *start_byte = start;\n-  *last_byte = last;\n-  return false;\n-}\n-\n-\n-/* Helper for df_compute_accessed_bytes.  Ref is a strict_low_part.\n-   Return true if this effects the entire reg in REF. Return false if\n-   otherwise and set START_BYTE and LAST_BYTE.  */\n-\n-static bool\n-df_compute_accessed_bytes_strict_low_part (df_ref ref,\n-\t\t\t\t\t   unsigned int *start_byte,\n-\t\t\t\t\t   unsigned int *last_byte)\n-{\n-  int start;\n-  int last;\n-  rtx reg = DF_REF_REG (ref);\n-  enum machine_mode m1;\n-  int m1_size;\n-  enum machine_mode m2;\n-  int m2_size;\n-  int offset;\n-\n-  /* In order to accommodate multiword subregs of a hardreg, df_scan\n-     eats the subreg and it can only be found from the loc.  */\n-  if (REG_P (reg))\n-    reg = *(DF_REF_LOC (ref));\n-\n-  m1 = GET_MODE (reg);\n-  m1_size = GET_MODE_SIZE (m1);\n-  m2 = GET_MODE (SUBREG_REG (reg));\n-  m2_size = GET_MODE_SIZE (m2);\n-  offset = SUBREG_BYTE (reg);\n-\n-  /* It does not seem to be meaningful to apply a strict_low_part of a\n-     paradoxical register.  */\n-  gcc_assert (m1_size <= m2_size);\n-\n-  /* (set (strict_low_part (subreg:M1 (reg:M2 X) N)) ...)\n-\n-  This is a bitfield insertion.  The assignment clobbers exactly the\n-  bits named by the subreg--the M1 bits at position N.  It is also\n-  technically possible that the bits asked for are longer than units\n-  per word.  */\n-\n-  start = offset;\n-  last = offset + m1_size;\n-\n-  if (dump_file)\n-    fprintf (dump_file, \"    cpb strict low part regno=%d start=%d last=%d\\n\",\n-\t     DF_REF_REGNO (ref), start, last);\n-\n-  *start_byte = start;\n-  *last_byte = last;\n-  return false;\n-}\n-\n-/* Helper for df_compute_accessed_bytes.  Ref is a naked subreg.\n-   Return true if this effects the entire reg in REF. Return false if\n-   otherwise and set START_BYTE and LAST_BYTE.  */\n-\n-static bool\n-df_compute_accessed_bytes_subreg (df_ref ref, unsigned int *start_byte,\n-\t\t\t\t  unsigned int *last_byte)\n-\n-{\n-  /* (subreg:M1 (reg:M2 X) N) */\n-  int start;\n-  int last;\n-  rtx reg = DF_REF_REG (ref);\n-\n-  enum machine_mode m1;\n-  int m1_size;\n-  enum machine_mode m2;\n-  int m2_size;\n-\n-  /* In order to accommodate multiword subregs of a hardreg, df_scan\n-     eats the subreg and it can only be found from the loc.  */\n-  if (REG_P (reg))\n-    reg = *(DF_REF_LOC (ref));\n-\n-  m1 = GET_MODE (reg);\n-  m1_size = GET_MODE_SIZE (m1);\n-  m2 = GET_MODE (SUBREG_REG (reg));\n-  m2_size = GET_MODE_SIZE (m2);\n-\n-  /* A simple paradoxical subreg just accesses the entire inner reg.  */\n-  if (m1_size >= m2_size)\n-    return true;\n-\n-  /* Defs and uses are different in the amount of the reg that touch.  */\n-  if (DF_REF_REG_DEF_P (ref))\n-    {\n-      /* This is an lvalue.  */\n-\n-      if (m2_size > UNITS_PER_WORD)\n-\t{\n-\t  /* The assignment clobbers UNITS_PER_WORD segments of X.\n-\t     Look at the bytes named by the subreg, and expand it to\n-\t     cover a UNITS_PER_WORD part of register X.  That part of\n-\t     register X is clobbered, the rest is not.\n-\n-\t     E.g., (subreg:SI (reg:DI X) 0), where UNITS_PER_WORD is the\n-\t     size of SImode, clobbers the first SImode part of X, and does\n-\t     not affect the second SImode part.\n-\n-\t     E.g., (subreg:QI (reg:DI X) 0), where UNITS_PER_WORD is the\n-\t     size of SImode, clobbers the first SImode part of X, and does\n-\t     not affect the second SImode part.  Here the QImode byte is\n-\t     expanded to a UNITS_PER_WORD portion of the register for\n-\t     purposes of determining what is clobbered.\n-\n-\t     If this is an rvalue, then it touches just the bytes that it\n-\t     talks about.  */\n-\t  int offset = SUBREG_BYTE (reg);\n-\n-\t  start = offset & ~(UNITS_PER_WORD - 1);\n-\t  last = (offset + m1_size + UNITS_PER_WORD - 1)\n-\t    & ~(UNITS_PER_WORD - 1);\n-\t}\n-      else\n-\t/* Whole register size M2 equal to or smaller than\n-\t   UNITS_PER_WORD The assignment clobbers the entire register\n-\t   X.  */\n-\treturn true;\n-    }\n-  else\n-    {\n-      /* This is an rvalue. It touches just the bytes they explicitly\n-\t mentioned.  */\n-      int offset = SUBREG_BYTE (reg);\n-      start = offset;\n-      last = start + m1_size;\n-    }\n-\n-  if (dump_file)\n-    fprintf (dump_file, \"    cpb subreg regno=%d start=%d last=%d\\n\",\n-\t     DF_REF_REGNO (ref), start, last);\n-\n-  *start_byte = start;\n-  *last_byte = last;\n-  return false;\n-}\n-\n-\n-/* Compute the set of affected bytes by a store to a pseudo to REF.\n-   MM is either DF_MM_MAY or DF_MM_MUST.  This is only relevant for\n-   the extracts which are not aligned to byte boundaries.  The\n-   DF_MM_MAY returns all of the bytes that any bit is set in and the\n-   DF_MM_MUST returns only the bytes that are completely covered.  In\n-   general DF_MM_MAY is used for uses and DF_MM_MUST is used for defs,\n-   but there are exceptions such as the inner loop of the byte level\n-   dead code eliminator which needs DF_MM_MAY for the defs to see if\n-   it any possible bit could be used.\n-\n-   If the store is to the whole register, just return TRUE, if it is\n-   to part of the register, return FALSE and set START_BYTE and\n-   LAST_BYTE properly.  In the case where fabricated uses are passed\n-   in, START_BYTE and LAST_BYTE are set to 0 and false is returned.\n-   This means that this use can be ignored.  */\n-\n-bool\n-df_compute_accessed_bytes (df_ref ref, enum df_mm mm,\n-\t\t\t   unsigned int *start_byte,\n-\t\t\t   unsigned int *last_byte)\n-{\n-  if (!dbg_cnt (df_byte_scan))\n-    return true;\n-\n-  if (!DF_REF_REG_DEF_P (ref)\n-      && DF_REF_FLAGS_IS_SET (ref, DF_REF_READ_WRITE))\n-    {\n-      if (DF_REF_FLAGS_IS_SET (ref, DF_REF_PRE_POST_MODIFY))\n-\t/* Pre/post modify/inc/dec always read and write the entire\n-\t   reg.  */\n-\treturn true;\n-      else\n-\t{\n-\t  /* DF_REF_READ_WRITE on a use (except for the\n-\t     DF_REF_PRE_POST_MODIFY) means that this use is fabricated\n-\t     from a def that is a partial set to a multiword reg.\n-\t     Here, we only model those cases precisely so the only one\n-\t     to consider is the use put on a auto inc and dec\n-\t     insns.  */\n-\t  *start_byte = 0;\n-\t  *last_byte = 0;\n-\t  return false;\n-\t}\n-    }\n-\n-  if (DF_REF_FLAGS_IS_SET (ref, DF_REF_SIGN_EXTRACT | DF_REF_ZERO_EXTRACT))\n-    return df_compute_accessed_bytes_extract (ref, mm, start_byte, last_byte);\n-  else if (DF_REF_FLAGS_IS_SET (ref, DF_REF_STRICT_LOW_PART))\n-    return df_compute_accessed_bytes_strict_low_part (ref,\n-\t\t\t\t\t\t      start_byte, last_byte);\n-  else if (GET_CODE (DF_REF_REG (ref)) == SUBREG)\n-    return df_compute_accessed_bytes_subreg (ref, start_byte, last_byte);\n-  return true;\n-}\n-"}, {"sha": "181c1e7ce22dfbda4a4a040670c7e56bfbedf6e8", "filename": "gcc/df-core.c", "status": "modified", "additions": 16, "deletions": 41, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d0741923dc99b7876f8faafdc238b59a32d0ffc/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d0741923dc99b7876f8faafdc238b59a32d0ffc/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=8d0741923dc99b7876f8faafdc238b59a32d0ffc", "patch": "@@ -1919,58 +1919,33 @@ df_print_regset (FILE *file, bitmap r)\n    debugging dump.  */\n \n void\n-df_print_byte_regset (FILE *file, bitmap r)\n+df_print_word_regset (FILE *file, bitmap r)\n {\n   unsigned int max_reg = max_reg_num ();\n-  bitmap_iterator bi;\n \n   if (r == NULL)\n     fputs (\" (nil)\", file);\n   else\n     {\n       unsigned int i;\n-      for (i = 0; i < max_reg; i++)\n+      for (i = FIRST_PSEUDO_REGISTER; i < max_reg; i++)\n \t{\n-\t  unsigned int first = df_byte_lr_get_regno_start (i);\n-\t  unsigned int len = df_byte_lr_get_regno_len (i);\n-\n-\t  if (len > 1)\n+\t  bool found = (bitmap_bit_p (r, 2 * i)\n+\t\t\t|| bitmap_bit_p (r, 2 * i + 1));\n+\t  if (found)\n \t    {\n-\t      bool found = false;\n-\t      unsigned int j;\n-\n-\t      EXECUTE_IF_SET_IN_BITMAP (r, first, j, bi)\n-\t\t{\n-\t\t  found = j < first + len;\n-\t\t  break;\n-\t\t}\n-\t      if (found)\n-\t\t{\n-\t\t  const char * sep = \"\";\n-\t\t  fprintf (file, \" %d\", i);\n-\t\t  if (i < FIRST_PSEUDO_REGISTER)\n-\t\t    fprintf (file, \" [%s]\", reg_names[i]);\n-\t\t  fprintf (file, \"(\");\n-\t\t  EXECUTE_IF_SET_IN_BITMAP (r, first, j, bi)\n-\t\t    {\n-\t\t      if (j > first + len - 1)\n-\t\t\tbreak;\n-\t\t      fprintf (file, \"%s%d\", sep, j-first);\n-\t\t      sep = \", \";\n-\t\t    }\n-\t\t  fprintf (file, \")\");\n-\t\t}\n+\t      int word;\n+\t      const char * sep = \"\";\n+\t      fprintf (file, \" %d\", i);\n+\t      fprintf (file, \"(\");\n+\t      for (word = 0; word < 2; word++)\n+\t\tif (bitmap_bit_p (r, 2 * i + word))\n+\t\t  {\n+\t\t    fprintf (file, \"%s%d\", sep, word);\n+\t\t    sep = \", \";\n+\t\t  }\n+\t      fprintf (file, \")\");\n \t    }\n-\t  else\n-\t    {\n-\t      if (bitmap_bit_p (r, first))\n-\t\t{\n-\t\t  fprintf (file, \" %d\", i);\n-\t\t  if (i < FIRST_PSEUDO_REGISTER)\n-\t\t    fprintf (file, \" [%s]\", reg_names[i]);\n-\t\t}\n-\t    }\n-\n \t}\n     }\n   fprintf (file, \"\\n\");"}, {"sha": "d0d0ea7160869f5e7f14deffe28c32b308c87ecc", "filename": "gcc/df-problems.c", "status": "modified", "additions": 156, "deletions": 460, "changes": 616, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d0741923dc99b7876f8faafdc238b59a32d0ffc/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d0741923dc99b7876f8faafdc238b59a32d0ffc/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=8d0741923dc99b7876f8faafdc238b59a32d0ffc", "patch": "@@ -2286,84 +2286,31 @@ df_chain_add_problem (unsigned int chain_flags)\n \n \f\n /*----------------------------------------------------------------------------\n-   BYTE LEVEL LIVE REGISTERS\n+   WORD LEVEL LIVE REGISTERS\n \n    Find the locations in the function where any use of a pseudo can\n    reach in the backwards direction.  In and out bitvectors are built\n-   for each basic block.  There are two mapping functions,\n-   df_byte_lr_get_regno_start and df_byte_lr_get_regno_len that are\n-   used to map regnos into bit vector positions.\n-\n-   This problem differs from the regular df_lr function in the way\n-   that subregs, *_extracts and strict_low_parts are handled. In lr\n-   these are consider partial kills, here, the exact set of bytes is\n-   modeled.  Note that any reg that has none of these operations is\n-   only modeled with a single bit since all operations access the\n-   entire register.\n-\n-   This problem is more brittle that the regular lr.  It currently can\n-   be used in dce incrementally, but cannot be used in an environment\n-   where insns are created or modified.  The problem is that the\n-   mapping of regnos to bitmap positions is relatively compact, in\n-   that if a pseudo does not do any of the byte wise operations, only\n-   one slot is allocated, rather than a slot for each byte.  If insn\n-   are created, where a subreg is used for a reg that had no subregs,\n-   the mapping would be wrong.  Likewise, there are no checks to see\n-   that new pseudos have been added.  These issues could be addressed\n-   by adding a problem specific flag to not use the compact mapping,\n-   if there was a need to do so.\n+   for each basic block.  We only track pseudo registers that have a\n+   size of 2 * UNITS_PER_WORD; bitmaps are indexed by 2 * regno and\n+   contain two bits corresponding to each of the subwords.\n \n    ----------------------------------------------------------------------------*/\n \n /* Private data used to verify the solution for this problem.  */\n-struct df_byte_lr_problem_data\n+struct df_word_lr_problem_data\n {\n-  /* Expanded versions of bitvectors used in lr.  */\n-  bitmap_head invalidated_by_call;\n-  bitmap_head hardware_regs_used;\n-\n-  /* Indexed by regno, this is true if there are subregs, extracts or\n-     strict_low_parts for this regno.  */\n-  bitmap_head needs_expansion;\n-\n-  /* The start position and len for each regno in the various bit\n-     vectors.  */\n-  unsigned int* regno_start;\n-  unsigned int* regno_len;\n   /* An obstack for the bitmaps we need for this problem.  */\n-  bitmap_obstack byte_lr_bitmaps;\n+  bitmap_obstack word_lr_bitmaps;\n };\n \n \n-/* Get the starting location for REGNO in the df_byte_lr bitmaps.  */\n-\n-int\n-df_byte_lr_get_regno_start (unsigned int regno)\n-{\n-  struct df_byte_lr_problem_data *problem_data\n-    = (struct df_byte_lr_problem_data *)df_byte_lr->problem_data;;\n-  return problem_data->regno_start[regno];\n-}\n-\n-\n-/* Get the len for REGNO in the df_byte_lr bitmaps.  */\n-\n-int\n-df_byte_lr_get_regno_len (unsigned int regno)\n-{\n-  struct df_byte_lr_problem_data *problem_data\n-    = (struct df_byte_lr_problem_data *)df_byte_lr->problem_data;;\n-  return problem_data->regno_len[regno];\n-}\n-\n-\n /* Free basic block info.  */\n \n static void\n-df_byte_lr_free_bb_info (basic_block bb ATTRIBUTE_UNUSED,\n+df_word_lr_free_bb_info (basic_block bb ATTRIBUTE_UNUSED,\n \t\t\t void *vbb_info)\n {\n-  struct df_byte_lr_bb_info *bb_info = (struct df_byte_lr_bb_info *) vbb_info;\n+  struct df_word_lr_bb_info *bb_info = (struct df_word_lr_bb_info *) vbb_info;\n   if (bb_info)\n     {\n       bitmap_clear (&bb_info->use);\n@@ -2374,124 +2321,39 @@ df_byte_lr_free_bb_info (basic_block bb ATTRIBUTE_UNUSED,\n }\n \n \n-/* Check all of the refs in REF_REC to see if any of them are\n-   extracts, subregs or strict_low_parts.  */\n-\n-static void\n-df_byte_lr_check_regs (df_ref *ref_rec)\n-{\n-  struct df_byte_lr_problem_data *problem_data\n-    = (struct df_byte_lr_problem_data *)df_byte_lr->problem_data;\n-\n-  for (; *ref_rec; ref_rec++)\n-    {\n-      df_ref ref = *ref_rec;\n-      if (DF_REF_FLAGS_IS_SET (ref, DF_REF_SIGN_EXTRACT\n-\t\t\t       | DF_REF_ZERO_EXTRACT\n-\t\t\t       | DF_REF_STRICT_LOW_PART)\n-\t  || GET_CODE (DF_REF_REG (ref)) == SUBREG)\n-\tbitmap_set_bit (&problem_data->needs_expansion, DF_REF_REGNO (ref));\n-    }\n-}\n-\n-\n-/* Expand bitmap SRC which is indexed by regno to DEST which is indexed by\n-   regno_start and regno_len.  */\n-\n-static void\n-df_byte_lr_expand_bitmap (bitmap dest, bitmap src)\n-{\n-  struct df_byte_lr_problem_data *problem_data\n-    = (struct df_byte_lr_problem_data *)df_byte_lr->problem_data;\n-  bitmap_iterator bi;\n-  unsigned int i;\n-\n-  bitmap_clear (dest);\n-  EXECUTE_IF_SET_IN_BITMAP (src, 0, i, bi)\n-    {\n-      bitmap_set_range (dest, problem_data->regno_start[i],\n-\t\t\tproblem_data->regno_len[i]);\n-    }\n-}\n-\n-\n-/* Allocate or reset bitmaps for DF_BYTE_LR blocks. The solution bits are\n+/* Allocate or reset bitmaps for DF_WORD_LR blocks. The solution bits are\n    not touched unless the block is new.  */\n \n static void\n-df_byte_lr_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n+df_word_lr_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n {\n   unsigned int bb_index;\n   bitmap_iterator bi;\n   basic_block bb;\n-  unsigned int regno;\n-  unsigned int index = 0;\n-  unsigned int max_reg = max_reg_num();\n-  struct df_byte_lr_problem_data *problem_data\n-    = XNEW (struct df_byte_lr_problem_data);\n+  struct df_word_lr_problem_data *problem_data\n+    = XNEW (struct df_word_lr_problem_data);\n \n-  df_byte_lr->problem_data = problem_data;\n+  df_word_lr->problem_data = problem_data;\n \n-  df_grow_bb_info (df_byte_lr);\n+  df_grow_bb_info (df_word_lr);\n \n   /* Create the mapping from regnos to slots. This does not change\n      unless the problem is destroyed and recreated.  In particular, if\n      we end up deleting the only insn that used a subreg, we do not\n      want to redo the mapping because this would invalidate everything\n      else.  */\n \n-  bitmap_obstack_initialize (&problem_data->byte_lr_bitmaps);\n-  problem_data->regno_start = XNEWVEC (unsigned int, max_reg);\n-  problem_data->regno_len = XNEWVEC (unsigned int, max_reg);\n-  bitmap_initialize (&problem_data->hardware_regs_used,\n-\t\t     &problem_data->byte_lr_bitmaps);\n-  bitmap_initialize (&problem_data->invalidated_by_call,\n-\t\t     &problem_data->byte_lr_bitmaps);\n-  bitmap_initialize (&problem_data->needs_expansion,\n-\t\t     &problem_data->byte_lr_bitmaps);\n-\n-  /* Discover which regno's use subregs, extracts or\n-     strict_low_parts.  */\n-  FOR_EACH_BB (bb)\n-    {\n-      rtx insn;\n-      FOR_BB_INSNS (bb, insn)\n-\t{\n-\t  if (INSN_P (insn))\n-\t    {\n-\t      struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n-\t      df_byte_lr_check_regs (DF_INSN_INFO_DEFS (insn_info));\n-\t      df_byte_lr_check_regs (DF_INSN_INFO_USES (insn_info));\n-\t    }\n-\t}\n-      bitmap_set_bit (df_byte_lr->out_of_date_transfer_functions, bb->index);\n-    }\n-\n-  bitmap_set_bit (df_byte_lr->out_of_date_transfer_functions, ENTRY_BLOCK);\n-  bitmap_set_bit (df_byte_lr->out_of_date_transfer_functions, EXIT_BLOCK);\n+  bitmap_obstack_initialize (&problem_data->word_lr_bitmaps);\n \n-  /* Allocate the slots for each regno.  */\n-  for (regno = 0; regno < max_reg; regno++)\n-    {\n-      int len;\n-      problem_data->regno_start[regno] = index;\n-      if (bitmap_bit_p (&problem_data->needs_expansion, regno))\n-\tlen = GET_MODE_SIZE (GET_MODE (regno_reg_rtx[regno]));\n-      else\n-\tlen = 1;\n-\n-      problem_data->regno_len[regno] = len;\n-      index += len;\n-    }\n+  FOR_EACH_BB (bb)\n+    bitmap_set_bit (df_word_lr->out_of_date_transfer_functions, bb->index);\n \n-  df_byte_lr_expand_bitmap (&problem_data->hardware_regs_used,\n-\t\t\t    &df->hardware_regs_used);\n-  df_byte_lr_expand_bitmap (&problem_data->invalidated_by_call,\n-\t\t\t    regs_invalidated_by_call_regset);\n+  bitmap_set_bit (df_word_lr->out_of_date_transfer_functions, ENTRY_BLOCK);\n+  bitmap_set_bit (df_word_lr->out_of_date_transfer_functions, EXIT_BLOCK);\n \n-  EXECUTE_IF_SET_IN_BITMAP (df_byte_lr->out_of_date_transfer_functions, 0, bb_index, bi)\n+  EXECUTE_IF_SET_IN_BITMAP (df_word_lr->out_of_date_transfer_functions, 0, bb_index, bi)\n     {\n-      struct df_byte_lr_bb_info *bb_info = df_byte_lr_get_bb_info (bb_index);\n+      struct df_word_lr_bb_info *bb_info = df_word_lr_get_bb_info (bb_index);\n       \n       /* When bitmaps are already initialized, just clear them.  */\n       if (bb_info->use.obstack)\n@@ -2501,74 +2363,109 @@ df_byte_lr_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n \t}\n       else\n \t{\n-\t  bitmap_initialize (&bb_info->use, &problem_data->byte_lr_bitmaps);\n-\t  bitmap_initialize (&bb_info->def, &problem_data->byte_lr_bitmaps);\n-\t  bitmap_initialize (&bb_info->in, &problem_data->byte_lr_bitmaps);\n-\t  bitmap_initialize (&bb_info->out, &problem_data->byte_lr_bitmaps);\n+\t  bitmap_initialize (&bb_info->use, &problem_data->word_lr_bitmaps);\n+\t  bitmap_initialize (&bb_info->def, &problem_data->word_lr_bitmaps);\n+\t  bitmap_initialize (&bb_info->in, &problem_data->word_lr_bitmaps);\n+\t  bitmap_initialize (&bb_info->out, &problem_data->word_lr_bitmaps);\n \t}\n     }\n \n-  df_byte_lr->optional_p = true;\n+  df_word_lr->optional_p = true;\n }\n \n \n /* Reset the global solution for recalculation.  */\n \n static void\n-df_byte_lr_reset (bitmap all_blocks)\n+df_word_lr_reset (bitmap all_blocks)\n {\n   unsigned int bb_index;\n   bitmap_iterator bi;\n \n   EXECUTE_IF_SET_IN_BITMAP (all_blocks, 0, bb_index, bi)\n     {\n-      struct df_byte_lr_bb_info *bb_info = df_byte_lr_get_bb_info (bb_index);\n+      struct df_word_lr_bb_info *bb_info = df_word_lr_get_bb_info (bb_index);\n       gcc_assert (bb_info);\n       bitmap_clear (&bb_info->in);\n       bitmap_clear (&bb_info->out);\n     }\n }\n \n+/* Examine REF, and if it is for a reg we're interested in, set or\n+   clear the bits corresponding to its subwords from the bitmap\n+   according to IS_SET.  LIVE is the bitmap we should update.  We do\n+   not track hard regs or pseudos of any size other than 2 *\n+   UNITS_PER_WORD.\n+   We return true if we changed the bitmap, or if we encountered a register\n+   we're not tracking.  */\n+\n+bool\n+df_word_lr_mark_ref (df_ref ref, bool is_set, regset live)\n+{\n+  rtx orig_reg = DF_REF_REG (ref);\n+  rtx reg = orig_reg;\n+  enum machine_mode reg_mode;\n+  unsigned regno;\n+  /* Left at -1 for whole accesses.  */\n+  int which_subword = -1;\n+  bool changed = false;\n+\n+  if (GET_CODE (reg) == SUBREG)\n+    reg = SUBREG_REG (orig_reg);\n+  regno = REGNO (reg);\n+  reg_mode = GET_MODE (reg);\n+  if (regno < FIRST_PSEUDO_REGISTER\n+      || GET_MODE_SIZE (reg_mode) != 2 * UNITS_PER_WORD)\n+    return true;\n+\n+  if (GET_CODE (orig_reg) == SUBREG\n+      && df_read_modify_subreg_p (orig_reg))\n+    {\n+      gcc_assert (DF_REF_FLAGS_IS_SET (ref, DF_REF_PARTIAL));\n+      if (subreg_lowpart_p (orig_reg))\n+\twhich_subword = 0;\n+      else\n+\twhich_subword = 1;\n+    }\n+  if (is_set)\n+    {\n+      if (which_subword != 1)\n+\tchanged |= bitmap_set_bit (live, regno * 2);\n+      if (which_subword != 0)\n+\tchanged |= bitmap_set_bit (live, regno * 2 + 1);\n+    }\n+  else\n+    {\n+      if (which_subword != 1)\n+\tchanged |= bitmap_clear_bit (live, regno * 2);\n+      if (which_subword != 0)\n+\tchanged |= bitmap_clear_bit (live, regno * 2 + 1);\n+    }\n+  return changed;\n+}\n \n /* Compute local live register info for basic block BB.  */\n \n static void\n-df_byte_lr_bb_local_compute (unsigned int bb_index)\n+df_word_lr_bb_local_compute (unsigned int bb_index)\n {\n-  struct df_byte_lr_problem_data *problem_data\n-    = (struct df_byte_lr_problem_data *)df_byte_lr->problem_data;\n   basic_block bb = BASIC_BLOCK (bb_index);\n-  struct df_byte_lr_bb_info *bb_info = df_byte_lr_get_bb_info (bb_index);\n+  struct df_word_lr_bb_info *bb_info = df_word_lr_get_bb_info (bb_index);\n   rtx insn;\n   df_ref *def_rec;\n   df_ref *use_rec;\n \n-  /* Process the registers set in an exception handler.  */\n+  /* Ensure that artificial refs don't contain references to pseudos.  */\n   for (def_rec = df_get_artificial_defs (bb_index); *def_rec; def_rec++)\n     {\n       df_ref def = *def_rec;\n-      if ((DF_REF_FLAGS (def) & DF_REF_AT_TOP) == 0)\n-\t{\n-\t  unsigned int dregno = DF_REF_REGNO (def);\n-\t  unsigned int start = problem_data->regno_start[dregno];\n-\t  unsigned int len = problem_data->regno_len[dregno];\n-\t  bitmap_set_range (&bb_info->def, start, len);\n-\t  bitmap_clear_range (&bb_info->use, start, len);\n-\t}\n+      gcc_assert (DF_REF_REGNO (def) < FIRST_PSEUDO_REGISTER);\n     }\n \n-  /* Process the hardware registers that are always live.  */\n   for (use_rec = df_get_artificial_uses (bb_index); *use_rec; use_rec++)\n     {\n       df_ref use = *use_rec;\n-      /* Add use to set of uses in this BB.  */\n-      if ((DF_REF_FLAGS (use) & DF_REF_AT_TOP) == 0)\n-\t{\n-\t  unsigned int uregno = DF_REF_REGNO (use);\n-\t  unsigned int start = problem_data->regno_start[uregno];\n-\t  unsigned int len = problem_data->regno_len[uregno];\n-\t  bitmap_set_range (&bb_info->use, start, len);\n-\t}\n+      gcc_assert (DF_REF_REGNO (use) < FIRST_PSEUDO_REGISTER);\n     }\n \n   FOR_BB_INSNS_REVERSE (bb, insn)\n@@ -2577,172 +2474,87 @@ df_byte_lr_bb_local_compute (unsigned int bb_index)\n \n       if (!INSN_P (insn))\n \tcontinue;\n-\n       for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n \t{\n \t  df_ref def = *def_rec;\n \t  /* If the def is to only part of the reg, it does\n \t     not kill the other defs that reach here.  */\n \t  if (!(DF_REF_FLAGS (def) & (DF_REF_CONDITIONAL)))\n \t    {\n-\t      unsigned int dregno = DF_REF_REGNO (def);\n-\t      unsigned int start = problem_data->regno_start[dregno];\n-\t      unsigned int len = problem_data->regno_len[dregno];\n-\t      unsigned int sb;\n-\t      unsigned int lb;\n-\t      if (!df_compute_accessed_bytes (def, DF_MM_MUST, &sb, &lb))\n-\t\t{\n-\t\t  start += sb;\n-\t\t  len = lb - sb;\n-\t\t}\n-\t      if (len)\n-\t\t{\n-\t\t  bitmap_set_range (&bb_info->def, start, len);\n-\t\t  bitmap_clear_range (&bb_info->use, start, len);\n-\t\t}\n+\t      df_word_lr_mark_ref (def, true, &bb_info->def);\n+\t      df_word_lr_mark_ref (def, false, &bb_info->use);\n \t    }\n \t}\n-\n       for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)\n \t{\n \t  df_ref use = *use_rec;\n-\t  unsigned int uregno = DF_REF_REGNO (use);\n-\t  unsigned int start = problem_data->regno_start[uregno];\n-\t  unsigned int len = problem_data->regno_len[uregno];\n-\t  unsigned int sb;\n-\t  unsigned int lb;\n-\t  if (!df_compute_accessed_bytes (use, DF_MM_MAY, &sb, &lb))\n-\t    {\n-\t      start += sb;\n-\t      len = lb - sb;\n-\t    }\n-\t  /* Add use to set of uses in this BB.  */\n-\t  if (len)\n-\t    bitmap_set_range (&bb_info->use, start, len);\n-\t}\n-    }\n-\n-  /* Process the registers set in an exception handler or the hard\n-     frame pointer if this block is the target of a non local\n-     goto.  */\n-  for (def_rec = df_get_artificial_defs (bb_index); *def_rec; def_rec++)\n-    {\n-      df_ref def = *def_rec;\n-      if (DF_REF_FLAGS (def) & DF_REF_AT_TOP)\n-\t{\n-\t  unsigned int dregno = DF_REF_REGNO (def);\n-\t  unsigned int start = problem_data->regno_start[dregno];\n-\t  unsigned int len = problem_data->regno_len[dregno];\n-\t  bitmap_set_range (&bb_info->def, start, len);\n-\t  bitmap_clear_range (&bb_info->use, start, len);\n-\t}\n-    }\n-\n-#ifdef EH_USES\n-  /* Process the uses that are live into an exception handler.  */\n-  for (use_rec = df_get_artificial_uses (bb_index); *use_rec; use_rec++)\n-    {\n-      df_ref use = *use_rec;\n-      /* Add use to set of uses in this BB.  */\n-      if (DF_REF_FLAGS (use) & DF_REF_AT_TOP)\n-\t{\n-\t  unsigned int uregno = DF_REF_REGNO (use);\n-\t  unsigned int start = problem_data->regno_start[uregno];\n-\t  unsigned int len = problem_data->regno_len[uregno];\n-\t  bitmap_set_range (&bb_info->use, start, len);\n+\t  df_word_lr_mark_ref (use, true, &bb_info->use);\n \t}\n     }\n-#endif\n }\n \n \n /* Compute local live register info for each basic block within BLOCKS.  */\n \n static void\n-df_byte_lr_local_compute (bitmap all_blocks ATTRIBUTE_UNUSED)\n+df_word_lr_local_compute (bitmap all_blocks ATTRIBUTE_UNUSED)\n {\n   unsigned int bb_index;\n   bitmap_iterator bi;\n \n-  EXECUTE_IF_SET_IN_BITMAP (df_byte_lr->out_of_date_transfer_functions, 0, bb_index, bi)\n+  EXECUTE_IF_SET_IN_BITMAP (df_word_lr->out_of_date_transfer_functions, 0, bb_index, bi)\n     {\n       if (bb_index == EXIT_BLOCK)\n \t{\n-\t  /* The exit block is special for this problem and its bits are\n-\t     computed from thin air.  */\n-\t  struct df_byte_lr_bb_info *bb_info = df_byte_lr_get_bb_info (EXIT_BLOCK);\n-\t  df_byte_lr_expand_bitmap (&bb_info->use, df->exit_block_uses);\n+\t  unsigned regno;\n+\t  bitmap_iterator bi;\n+\t  EXECUTE_IF_SET_IN_BITMAP (df->exit_block_uses, FIRST_PSEUDO_REGISTER,\n+\t\t\t\t    regno, bi)\n+\t    gcc_unreachable ();\n \t}\n       else\n-\tdf_byte_lr_bb_local_compute (bb_index);\n+\tdf_word_lr_bb_local_compute (bb_index);\n     }\n \n-  bitmap_clear (df_byte_lr->out_of_date_transfer_functions);\n+  bitmap_clear (df_word_lr->out_of_date_transfer_functions);\n }\n \n \n /* Initialize the solution vectors.  */\n \n static void\n-df_byte_lr_init (bitmap all_blocks)\n+df_word_lr_init (bitmap all_blocks)\n {\n   unsigned int bb_index;\n   bitmap_iterator bi;\n \n   EXECUTE_IF_SET_IN_BITMAP (all_blocks, 0, bb_index, bi)\n     {\n-      struct df_byte_lr_bb_info *bb_info = df_byte_lr_get_bb_info (bb_index);\n+      struct df_word_lr_bb_info *bb_info = df_word_lr_get_bb_info (bb_index);\n       bitmap_copy (&bb_info->in, &bb_info->use);\n       bitmap_clear (&bb_info->out);\n     }\n }\n \n \n-/* Confluence function that processes infinite loops.  This might be a\n-   noreturn function that throws.  And even if it isn't, getting the\n-   unwind info right helps debugging.  */\n-static void\n-df_byte_lr_confluence_0 (basic_block bb)\n-{\n-  struct df_byte_lr_problem_data *problem_data\n-    = (struct df_byte_lr_problem_data *)df_byte_lr->problem_data;\n-  bitmap op1 = &df_byte_lr_get_bb_info (bb->index)->out;\n-  if (bb != EXIT_BLOCK_PTR)\n-    bitmap_copy (op1, &problem_data->hardware_regs_used);\n-}\n-\n-\n /* Confluence function that ignores fake edges.  */\n \n static bool\n-df_byte_lr_confluence_n (edge e)\n+df_word_lr_confluence_n (edge e)\n {\n-  struct df_byte_lr_problem_data *problem_data\n-    = (struct df_byte_lr_problem_data *)df_byte_lr->problem_data;\n-  bitmap op1 = &df_byte_lr_get_bb_info (e->src->index)->out;\n-  bitmap op2 = &df_byte_lr_get_bb_info (e->dest->index)->in;\n-  bool changed = false;\n+  bitmap op1 = &df_word_lr_get_bb_info (e->src->index)->out;\n+  bitmap op2 = &df_word_lr_get_bb_info (e->dest->index)->in;\n \n-  /* Call-clobbered registers die across exception and call edges.  */\n-  /* ??? Abnormal call edges ignored for the moment, as this gets\n-     confused by sibling call edges, which crashes reg-stack.  */\n-  if (e->flags & EDGE_EH)\n-    changed = bitmap_ior_and_compl_into (op1, op2,\n-\t\t\t\t\t &problem_data->invalidated_by_call);\n-  else\n-    changed = bitmap_ior_into (op1, op2);\n-\n-  changed |= bitmap_ior_into (op1, &problem_data->hardware_regs_used);\n-  return changed;\n+  return bitmap_ior_into (op1, op2);\n }\n \n \n /* Transfer function.  */\n \n static bool\n-df_byte_lr_transfer_function (int bb_index)\n+df_word_lr_transfer_function (int bb_index)\n {\n-  struct df_byte_lr_bb_info *bb_info = df_byte_lr_get_bb_info (bb_index);\n+  struct df_word_lr_bb_info *bb_info = df_word_lr_get_bb_info (bb_index);\n   bitmap in = &bb_info->in;\n   bitmap out = &bb_info->out;\n   bitmap use = &bb_info->use;\n@@ -2755,86 +2567,83 @@ df_byte_lr_transfer_function (int bb_index)\n /* Free all storage associated with the problem.  */\n \n static void\n-df_byte_lr_free (void)\n+df_word_lr_free (void)\n {\n-  struct df_byte_lr_problem_data *problem_data\n-    = (struct df_byte_lr_problem_data *)df_byte_lr->problem_data;\n+  struct df_word_lr_problem_data *problem_data\n+    = (struct df_word_lr_problem_data *)df_word_lr->problem_data;\n \n-\n-  if (df_byte_lr->block_info)\n+  if (df_word_lr->block_info)\n     {\n-      df_byte_lr->block_info_size = 0;\n-      free (df_byte_lr->block_info);\n-      df_byte_lr->block_info = NULL;\n+      df_word_lr->block_info_size = 0;\n+      free (df_word_lr->block_info);\n+      df_word_lr->block_info = NULL;\n     }\n \n-  BITMAP_FREE (df_byte_lr->out_of_date_transfer_functions);\n-  bitmap_obstack_release (&problem_data->byte_lr_bitmaps);\n-  free (problem_data->regno_start);\n-  free (problem_data->regno_len);\n+  BITMAP_FREE (df_word_lr->out_of_date_transfer_functions);\n+  bitmap_obstack_release (&problem_data->word_lr_bitmaps);\n   free (problem_data);\n-  free (df_byte_lr);\n+  free (df_word_lr);\n }\n \n \n /* Debugging info at top of bb.  */\n \n static void\n-df_byte_lr_top_dump (basic_block bb, FILE *file)\n+df_word_lr_top_dump (basic_block bb, FILE *file)\n {\n-  struct df_byte_lr_bb_info *bb_info = df_byte_lr_get_bb_info (bb->index);\n+  struct df_word_lr_bb_info *bb_info = df_word_lr_get_bb_info (bb->index);\n   if (!bb_info)\n     return;\n \n   fprintf (file, \";; blr  in  \\t\");\n-  df_print_byte_regset (file, &bb_info->in);\n+  df_print_word_regset (file, &bb_info->in);\n   fprintf (file, \";; blr  use \\t\");\n-  df_print_byte_regset (file, &bb_info->use);\n+  df_print_word_regset (file, &bb_info->use);\n   fprintf (file, \";; blr  def \\t\");\n-  df_print_byte_regset (file, &bb_info->def);\n+  df_print_word_regset (file, &bb_info->def);\n }\n \n \n /* Debugging info at bottom of bb.  */\n \n static void\n-df_byte_lr_bottom_dump (basic_block bb, FILE *file)\n+df_word_lr_bottom_dump (basic_block bb, FILE *file)\n {\n-  struct df_byte_lr_bb_info *bb_info = df_byte_lr_get_bb_info (bb->index);\n+  struct df_word_lr_bb_info *bb_info = df_word_lr_get_bb_info (bb->index);\n   if (!bb_info)\n     return;\n \n   fprintf (file, \";; blr  out \\t\");\n-  df_print_byte_regset (file, &bb_info->out);\n+  df_print_word_regset (file, &bb_info->out);\n }\n \n \n /* All of the information associated with every instance of the problem.  */\n \n-static struct df_problem problem_BYTE_LR =\n+static struct df_problem problem_WORD_LR =\n {\n-  DF_BYTE_LR,                      /* Problem id.  */\n+  DF_WORD_LR,                      /* Problem id.  */\n   DF_BACKWARD,                     /* Direction.  */\n-  df_byte_lr_alloc,                /* Allocate the problem specific data.  */\n-  df_byte_lr_reset,                /* Reset global information.  */\n-  df_byte_lr_free_bb_info,         /* Free basic block info.  */\n-  df_byte_lr_local_compute,        /* Local compute function.  */\n-  df_byte_lr_init,                 /* Init the solution specific data.  */\n+  df_word_lr_alloc,                /* Allocate the problem specific data.  */\n+  df_word_lr_reset,                /* Reset global information.  */\n+  df_word_lr_free_bb_info,         /* Free basic block info.  */\n+  df_word_lr_local_compute,        /* Local compute function.  */\n+  df_word_lr_init,                 /* Init the solution specific data.  */\n   df_worklist_dataflow,            /* Worklist solver.  */\n-  df_byte_lr_confluence_0,         /* Confluence operator 0.  */\n-  df_byte_lr_confluence_n,         /* Confluence operator n.  */\n-  df_byte_lr_transfer_function,    /* Transfer function.  */\n+  NULL,                            /* Confluence operator 0.  */\n+  df_word_lr_confluence_n,         /* Confluence operator n.  */\n+  df_word_lr_transfer_function,    /* Transfer function.  */\n   NULL,                            /* Finalize function.  */\n-  df_byte_lr_free,                 /* Free all of the problem information.  */\n-  df_byte_lr_free,                 /* Remove this problem from the stack of dataflow problems.  */\n+  df_word_lr_free,                 /* Free all of the problem information.  */\n+  df_word_lr_free,                 /* Remove this problem from the stack of dataflow problems.  */\n   NULL,                            /* Debugging.  */\n-  df_byte_lr_top_dump,             /* Debugging start block.  */\n-  df_byte_lr_bottom_dump,          /* Debugging end block.  */\n+  df_word_lr_top_dump,             /* Debugging start block.  */\n+  df_word_lr_bottom_dump,          /* Debugging end block.  */\n   NULL,                            /* Incremental solution verify start.  */\n   NULL,                            /* Incremental solution verify end.  */\n   NULL,                       /* Dependent problem.  */\n-  sizeof (struct df_byte_lr_bb_info),/* Size of entry of block_info array.  */\n-  TV_DF_BYTE_LR,                   /* Timing variable.  */\n+  sizeof (struct df_word_lr_bb_info),/* Size of entry of block_info array.  */\n+  TV_DF_WORD_LR,                   /* Timing variable.  */\n   false                            /* Reset blocks on dropping out of blocks_to_analyze.  */\n };\n \n@@ -2844,163 +2653,50 @@ static struct df_problem problem_BYTE_LR =\n    solution.  */\n \n void\n-df_byte_lr_add_problem (void)\n+df_word_lr_add_problem (void)\n {\n-  df_add_problem (&problem_BYTE_LR);\n+  df_add_problem (&problem_WORD_LR);\n   /* These will be initialized when df_scan_blocks processes each\n      block.  */\n-  df_byte_lr->out_of_date_transfer_functions = BITMAP_ALLOC (NULL);\n+  df_word_lr->out_of_date_transfer_functions = BITMAP_ALLOC (NULL);\n }\n \n \n-/* Simulate the effects of the defs of INSN on LIVE.  */\n+/* Simulate the effects of the defs of INSN on LIVE.  Return true if we changed\n+   any bits, which is used by the caller to determine whether a set is\n+   necessary.  We also return true if there are other reasons not to delete\n+   an insn.  */\n \n-void\n-df_byte_lr_simulate_defs (rtx insn, bitmap live)\n+bool\n+df_word_lr_simulate_defs (rtx insn, bitmap live)\n {\n-  struct df_byte_lr_problem_data *problem_data\n-    = (struct df_byte_lr_problem_data *)df_byte_lr->problem_data;\n+  bool changed = false;\n   df_ref *def_rec;\n   unsigned int uid = INSN_UID (insn);\n \n   for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n     {\n       df_ref def = *def_rec;\n-\n-      /* If the def is to only part of the reg, it does\n-\t not kill the other defs that reach here.  */\n-      if (!(DF_REF_FLAGS (def) & DF_REF_CONDITIONAL))\n-\t{\n-\t  unsigned int dregno = DF_REF_REGNO (def);\n-\t  unsigned int start = problem_data->regno_start[dregno];\n-\t  unsigned int len = problem_data->regno_len[dregno];\n-\t  unsigned int sb;\n-\t  unsigned int lb;\n-\t  if (!df_compute_accessed_bytes (def, DF_MM_MUST, &sb, &lb))\n-\t    {\n-\t      start += sb;\n-\t      len = lb - sb;\n-\t    }\n-\n-\t  if (len)\n-\t    bitmap_clear_range (live, start, len);\n-\t}\n+      if (DF_REF_FLAGS (def) & DF_REF_CONDITIONAL)\n+\tchanged = true;\n+      else\n+\tchanged |= df_word_lr_mark_ref (*def_rec, false, live);\n     }\n+  return changed;\n }\n \n \n /* Simulate the effects of the uses of INSN on LIVE.  */\n \n void\n-df_byte_lr_simulate_uses (rtx insn, bitmap live)\n+df_word_lr_simulate_uses (rtx insn, bitmap live)\n {\n-  struct df_byte_lr_problem_data *problem_data\n-    = (struct df_byte_lr_problem_data *)df_byte_lr->problem_data;\n   df_ref *use_rec;\n   unsigned int uid = INSN_UID (insn);\n \n   for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)\n-    {\n-      df_ref use = *use_rec;\n-      unsigned int uregno = DF_REF_REGNO (use);\n-      unsigned int start = problem_data->regno_start[uregno];\n-      unsigned int len = problem_data->regno_len[uregno];\n-      unsigned int sb;\n-      unsigned int lb;\n-\n-      if (!df_compute_accessed_bytes (use, DF_MM_MAY, &sb, &lb))\n-\t{\n-\t  start += sb;\n-\t  len = lb - sb;\n-\t}\n-\n-      /* Add use to set of uses in this BB.  */\n-      if (len)\n-\tbitmap_set_range (live, start, len);\n-    }\n-}\n-\n-\n-/* Apply the artificial uses and defs at the top of BB in a forwards\n-   direction.  */\n-\n-void\n-df_byte_lr_simulate_artificial_refs_at_top (basic_block bb, bitmap live)\n-{\n-  struct df_byte_lr_problem_data *problem_data\n-    = (struct df_byte_lr_problem_data *)df_byte_lr->problem_data;\n-  df_ref *def_rec;\n-#ifdef EH_USES\n-  df_ref *use_rec;\n-#endif\n-  int bb_index = bb->index;\n-\n-#ifdef EH_USES\n-  for (use_rec = df_get_artificial_uses (bb_index); *use_rec; use_rec++)\n-    {\n-      df_ref use = *use_rec;\n-      if (DF_REF_FLAGS (use) & DF_REF_AT_TOP)\n-\t{\n-\t  unsigned int uregno = DF_REF_REGNO (use);\n-\t  unsigned int start = problem_data->regno_start[uregno];\n-\t  unsigned int len = problem_data->regno_len[uregno];\n-\t  bitmap_set_range (live, start, len);\n-\t}\n-    }\n-#endif\n-\n-  for (def_rec = df_get_artificial_defs (bb_index); *def_rec; def_rec++)\n-    {\n-      df_ref def = *def_rec;\n-      if (DF_REF_FLAGS (def) & DF_REF_AT_TOP)\n-\t{\n-\t  unsigned int dregno = DF_REF_REGNO (def);\n-\t  unsigned int start = problem_data->regno_start[dregno];\n-\t  unsigned int len = problem_data->regno_len[dregno];\n-\t  bitmap_clear_range (live, start, len);\n-\t}\n-    }\n+    df_word_lr_mark_ref (*use_rec, true, live);\n }\n-\n-\n-/* Apply the artificial uses and defs at the end of BB in a backwards\n-   direction.  */\n-\n-void\n-df_byte_lr_simulate_artificial_refs_at_end (basic_block bb, bitmap live)\n-{\n-  struct df_byte_lr_problem_data *problem_data\n-    = (struct df_byte_lr_problem_data *)df_byte_lr->problem_data;\n-  df_ref *def_rec;\n-  df_ref *use_rec;\n-  int bb_index = bb->index;\n-\n-  for (def_rec = df_get_artificial_defs (bb_index); *def_rec; def_rec++)\n-    {\n-      df_ref def = *def_rec;\n-      if ((DF_REF_FLAGS (def) & DF_REF_AT_TOP) == 0)\n-\t{\n-\t  unsigned int dregno = DF_REF_REGNO (def);\n-\t  unsigned int start = problem_data->regno_start[dregno];\n-\t  unsigned int len = problem_data->regno_len[dregno];\n-\t  bitmap_clear_range (live, start, len);\n-\t}\n-    }\n-\n-  for (use_rec = df_get_artificial_uses (bb_index); *use_rec; use_rec++)\n-    {\n-      df_ref use = *use_rec;\n-      if ((DF_REF_FLAGS (use) & DF_REF_AT_TOP) == 0)\n-\t{\n-\t  unsigned int uregno = DF_REF_REGNO (use);\n-\t  unsigned int start = problem_data->regno_start[uregno];\n-\t  unsigned int len = problem_data->regno_len[uregno];\n-\t  bitmap_set_range (live, start, len);\n-\t}\n-    }\n-}\n-\n-\n \f\n /*----------------------------------------------------------------------------\n    This problem computes REG_DEAD and REG_UNUSED notes."}, {"sha": "a585b3bf744fefac27ab6eb1186d2998765c7fc3", "filename": "gcc/df.h", "status": "modified", "additions": 20, "deletions": 32, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d0741923dc99b7876f8faafdc238b59a32d0ffc/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d0741923dc99b7876f8faafdc238b59a32d0ffc/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=8d0741923dc99b7876f8faafdc238b59a32d0ffc", "patch": "@@ -52,7 +52,7 @@ union df_ref_d;\n #define DF_LIVE    2      /* Live Registers & Uninitialized Registers */\n #define DF_RD      3      /* Reaching Defs. */\n #define DF_CHAIN   4      /* Def-Use and/or Use-Def Chains. */\n-#define DF_BYTE_LR 5      /* Subreg tracking lr.  */\n+#define DF_WORD_LR 5      /* Subreg tracking lr.  */\n #define DF_NOTE    6      /* REG_DEF and REG_UNUSED notes. */\n #define DF_MD      7      /* Multiple Definitions. */\n \n@@ -66,14 +66,6 @@ enum df_flow_dir\n     DF_BACKWARD\n   };\n \n-/* Used in the byte scanning to determine if may or must info is to be\n-   returned.  */\n-enum df_mm\n-  {\n-    DF_MM_MAY,\n-    DF_MM_MUST\n-  };\n-\n /* Descriminator for the various df_ref types.  */\n enum df_ref_class {DF_REF_BASE, DF_REF_ARTIFICIAL, DF_REF_REGULAR, DF_REF_EXTRACT};\n \n@@ -624,7 +616,7 @@ struct df_d\n #define DF_RD_BB_INFO(BB) (df_rd_get_bb_info((BB)->index))\n #define DF_LR_BB_INFO(BB) (df_lr_get_bb_info((BB)->index))\n #define DF_LIVE_BB_INFO(BB) (df_live_get_bb_info((BB)->index))\n-#define DF_BYTE_LR_BB_INFO(BB) (df_byte_lr_get_bb_info((BB)->index))\n+#define DF_WORD_LR_BB_INFO(BB) (df_word_lr_get_bb_info((BB)->index))\n #define DF_MD_BB_INFO(BB) (df_md_get_bb_info((BB)->index))\n \n /* Most transformations that wish to use live register analysis will\n@@ -641,8 +633,8 @@ struct df_d\n /* These macros are used by passes that are not tolerant of\n    uninitialized variables.  This intolerance should eventually\n    be fixed.  */\n-#define DF_BYTE_LR_IN(BB) (&DF_BYTE_LR_BB_INFO(BB)->in)\n-#define DF_BYTE_LR_OUT(BB) (&DF_BYTE_LR_BB_INFO(BB)->out)\n+#define DF_WORD_LR_IN(BB) (&DF_WORD_LR_BB_INFO(BB)->in)\n+#define DF_WORD_LR_OUT(BB) (&DF_WORD_LR_BB_INFO(BB)->out)\n \n /* Macros to access the elements within the ref structure.  */\n \n@@ -859,9 +851,11 @@ struct df_live_bb_info\n \n \n /* Live registers, a backwards dataflow problem.  These bitmaps are\n-indexed by the df_byte_lr_offset array which is indexed by pseudo.  */\n+   indexed by 2 * regno for each pseudo and have two entries for each\n+   pseudo.  Only pseudos that have a size of 2 * UNITS_PER_WORD are\n+   meaningfully tracked.  */\n \n-struct df_byte_lr_bb_info\n+struct df_word_lr_bb_info\n {\n   /* Local sets to describe the basic blocks.  */\n   bitmap_head def;   /* The set of registers set in this block\n@@ -883,7 +877,7 @@ extern struct df_d *df;\n #define df_lr      (df->problems_by_index[DF_LR])\n #define df_live    (df->problems_by_index[DF_LIVE])\n #define df_chain   (df->problems_by_index[DF_CHAIN])\n-#define df_byte_lr (df->problems_by_index[DF_BYTE_LR])\n+#define df_word_lr (df->problems_by_index[DF_WORD_LR])\n #define df_note    (df->problems_by_index[DF_NOTE])\n #define df_md      (df->problems_by_index[DF_MD])\n \n@@ -933,7 +927,7 @@ extern df_ref df_find_use (rtx, rtx);\n extern bool df_reg_used (rtx, rtx);\n extern void df_worklist_dataflow (struct dataflow *,bitmap, int *, int);\n extern void df_print_regset (FILE *file, bitmap r);\n-extern void df_print_byte_regset (FILE *file, bitmap r);\n+extern void df_print_word_regset (FILE *file, bitmap r);\n extern void df_dump (FILE *);\n extern void df_dump_region (FILE *);\n extern void df_dump_start (FILE *);\n@@ -972,13 +966,12 @@ extern void df_live_verify_transfer_functions (void);\n extern void df_live_add_problem (void);\n extern void df_live_set_all_dirty (void);\n extern void df_chain_add_problem (unsigned int);\n-extern void df_byte_lr_add_problem (void);\n-extern int df_byte_lr_get_regno_start (unsigned int);\n-extern int df_byte_lr_get_regno_len (unsigned int);\n-extern void df_byte_lr_simulate_defs (rtx, bitmap);\n-extern void df_byte_lr_simulate_uses (rtx, bitmap);\n-extern void df_byte_lr_simulate_artificial_refs_at_top (basic_block, bitmap);\n-extern void df_byte_lr_simulate_artificial_refs_at_end (basic_block, bitmap);\n+extern void df_word_lr_add_problem (void);\n+extern bool df_word_lr_mark_ref (df_ref, bool, bitmap);\n+extern bool df_word_lr_simulate_defs (rtx, bitmap);\n+extern void df_word_lr_simulate_uses (rtx, bitmap);\n+extern void df_word_lr_simulate_artificial_refs_at_top (basic_block, bitmap);\n+extern void df_word_lr_simulate_artificial_refs_at_end (basic_block, bitmap);\n extern void df_note_add_problem (void);\n extern void df_md_add_problem (void);\n extern void df_md_simulate_artificial_defs_at_top (basic_block, bitmap);\n@@ -1029,11 +1022,6 @@ extern void df_compute_regs_ever_live (bool);\n extern bool df_read_modify_subreg_p (rtx);\n extern void df_scan_verify (void);\n \n-/* Functions defined in df-byte-scan.c.  */\n-extern bool df_compute_accessed_bytes (df_ref, enum df_mm,\n-\t\t\t\t       unsigned int *, unsigned int *);\n-\n-\n /* Get basic block info.  */\n \n static inline struct df_scan_bb_info *\n@@ -1081,11 +1069,11 @@ df_live_get_bb_info (unsigned int index)\n     return NULL;\n }\n \n-static inline struct df_byte_lr_bb_info *\n-df_byte_lr_get_bb_info (unsigned int index)\n+static inline struct df_word_lr_bb_info *\n+df_word_lr_get_bb_info (unsigned int index)\n {\n-  if (index < df_byte_lr->block_info_size)\n-    return &((struct df_byte_lr_bb_info *) df_byte_lr->block_info)[index];\n+  if (index < df_word_lr->block_info_size)\n+    return &((struct df_word_lr_bb_info *) df_word_lr->block_info)[index];\n   else\n     return NULL;\n }"}, {"sha": "6876f0991ee316cf27cb5f7733a74363d18b5899", "filename": "gcc/lower-subreg.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d0741923dc99b7876f8faafdc238b59a32d0ffc/gcc%2Flower-subreg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d0741923dc99b7876f8faafdc238b59a32d0ffc/gcc%2Flower-subreg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flower-subreg.c?ref=8d0741923dc99b7876f8faafdc238b59a32d0ffc", "patch": "@@ -33,6 +33,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"basic-block.h\"\n #include \"recog.h\"\n #include \"bitmap.h\"\n+#include \"dce.h\"\n #include \"expr.h\"\n #include \"except.h\"\n #include \"regs.h\"\n@@ -1091,6 +1092,9 @@ decompose_multiword_subregs (void)\n       return;\n   }\n \n+  if (df)\n+    run_word_dce ();\n+\n   /* FIXME: When the dataflow branch is merged, we can change this\n      code to look for each multi-word pseudo-register and to find each\n      insn which sets or uses that register.  That should be faster"}, {"sha": "b5e1d2372d16327f72c951d38193dd862a5c69f9", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d0741923dc99b7876f8faafdc238b59a32d0ffc/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d0741923dc99b7876f8faafdc238b59a32d0ffc/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=8d0741923dc99b7876f8faafdc238b59a32d0ffc", "patch": "@@ -91,7 +91,7 @@ DEFTIMEVAR (TV_DF_LR\t\t     , \"df live regs\")\n DEFTIMEVAR (TV_DF_LIVE\t\t     , \"df live&initialized regs\")\n DEFTIMEVAR (TV_DF_UREC\t\t     , \"df uninitialized regs 2\")\n DEFTIMEVAR (TV_DF_CHAIN\t\t     , \"df use-def / def-use chains\")\n-DEFTIMEVAR (TV_DF_BYTE_LR\t     , \"df live byte regs\")\n+DEFTIMEVAR (TV_DF_WORD_LR\t     , \"df live reg subwords\")\n DEFTIMEVAR (TV_DF_NOTE\t\t     , \"df reg dead/unused notes\")\n DEFTIMEVAR (TV_REG_STATS\t     , \"register information\")\n "}]}