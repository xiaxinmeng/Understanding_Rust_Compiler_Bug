{"sha": "544055ae6558c7f9d4c80cf31d0dfa8abd240809", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQ0MDU1YWU2NTU4YzdmOWQ0YzgwY2YzMWQwZGZhOGFiZDI0MDgwOQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2012-04-25T02:15:48Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2012-04-25T02:15:48Z"}, "message": "rs6000.c (rs6000_emit_stack_reset): Delete forward decl.\n\n\t* config/rs6000/rs6000.c (rs6000_emit_stack_reset): Delete forward\n\tdecl.  Move logic selecting update reg to callers.  Update all callers.\n\t(rs6000_emit_allocate_stack): Add copy_off param.\n\t(emit_frame_save): Don't handle reg+reg addressing.\n\t(ptr_regno_for_savres): New function, extracted from..\n\t(rs6000_emit_savres_rtx): ..here.  Add lr_offset param.\n\t(rs6000_emit_prologue): Generate frame_ptr_rtx as we need it.\n\tSet frame_reg_rtx to r11 whenever r11 is needed, and merge\n\tframe offset adjustment for out-of-line save with copy from sp.\n\tSimplify condition controlling whether cr is saved early or\n\tlate.  Use ptr_regno_for_savres to verify correct reg is set\n\tup for out-of-line saves.  Pass the actual pointer reg used to\n\trs6000_emit_savres_rtx so rtl matches insns in out-of-line\n\tfunction.  Rearrange spe vars so code is similar to that\n\telsewhere in this function.  Don't update frame_off when spe\n\tsave code will restore r11.  Use emit_frame_save for spe and\n\tgpr saves.  Consolidate darwin out-of-line gpr setup with that\n\tfor other abis.  Don't assume frame_offset is zero and frame\n\treg is sp when setting up altivec reg saves, and calculate\n\texact offset requirement.\n\t(rs6000_emit_epilogue): Use HOST_WIDE_INT for frame_off.  Tidy\n\tspe restore code.  Consolidate darwin out-of-line gpr setup\n\twith that for other abis.\n\nFrom-SVN: r186797", "tree": {"sha": "e90d8bb12030ae8200260fd17ff26ea099f7e910", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e90d8bb12030ae8200260fd17ff26ea099f7e910"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/544055ae6558c7f9d4c80cf31d0dfa8abd240809", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/544055ae6558c7f9d4c80cf31d0dfa8abd240809", "html_url": "https://github.com/Rust-GCC/gccrs/commit/544055ae6558c7f9d4c80cf31d0dfa8abd240809", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/544055ae6558c7f9d4c80cf31d0dfa8abd240809/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "471df90fad59eff2cc97755e0248e5eb6c851a8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/471df90fad59eff2cc97755e0248e5eb6c851a8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/471df90fad59eff2cc97755e0248e5eb6c851a8d"}], "stats": {"total": 428, "additions": 212, "deletions": 216}, "files": [{"sha": "12f0ac93cff3fcdb88e23d5edc1aabf1e1ab87f2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/544055ae6558c7f9d4c80cf31d0dfa8abd240809/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/544055ae6558c7f9d4c80cf31d0dfa8abd240809/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=544055ae6558c7f9d4c80cf31d0dfa8abd240809", "patch": "@@ -1,3 +1,29 @@\n+2012-04-25  Alan Modra  <amodra@gmail.com>\n+\n+\t* config/rs6000/rs6000.c (rs6000_emit_stack_reset): Delete forward\n+\tdecl.  Move logic selecting update reg to callers.  Update all callers.\n+\t(rs6000_emit_allocate_stack): Add copy_off param.\n+\t(emit_frame_save): Don't handle reg+reg addressing.\n+\t(ptr_regno_for_savres): New function, extracted from..\n+\t(rs6000_emit_savres_rtx): ..here.  Add lr_offset param.\n+\t(rs6000_emit_prologue): Generate frame_ptr_rtx as we need it.\n+\tSet frame_reg_rtx to r11 whenever r11 is needed, and merge\n+\tframe offset adjustment for out-of-line save with copy from sp.\n+\tSimplify condition controlling whether cr is saved early or\n+\tlate.  Use ptr_regno_for_savres to verify correct reg is set\n+\tup for out-of-line saves.  Pass the actual pointer reg used to\n+\trs6000_emit_savres_rtx so rtl matches insns in out-of-line\n+\tfunction.  Rearrange spe vars so code is similar to that\n+\telsewhere in this function.  Don't update frame_off when spe\n+\tsave code will restore r11.  Use emit_frame_save for spe and\n+\tgpr saves.  Consolidate darwin out-of-line gpr setup with that\n+\tfor other abis.  Don't assume frame_offset is zero and frame\n+\treg is sp when setting up altivec reg saves, and calculate\n+\texact offset requirement.\n+\t(rs6000_emit_epilogue): Use HOST_WIDE_INT for frame_off.  Tidy\n+\tspe restore code.  Consolidate darwin out-of-line gpr setup\n+\twith that for other abis.\n+\n 2012-04-25  Alan Modra  <amodra@gmail.com>\n \n \t* config/rs6000/rs6000.c (rs6000_frame_related): Don't emit a"}, {"sha": "6718149bd05f75f208e461723a119f184d3dbfda", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 186, "deletions": 216, "changes": 402, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/544055ae6558c7f9d4c80cf31d0dfa8abd240809/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/544055ae6558c7f9d4c80cf31d0dfa8abd240809/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=544055ae6558c7f9d4c80cf31d0dfa8abd240809", "patch": "@@ -951,7 +951,6 @@ static void rs6000_eliminate_indexed_memrefs (rtx operands[2]);\n static const char *rs6000_mangle_type (const_tree);\n static void rs6000_set_default_type_attributes (tree);\n static rtx rs6000_savres_routine_sym (rs6000_stack_t *, bool, bool, bool);\n-static rtx rs6000_emit_stack_reset (rs6000_stack_t *, rtx, rtx, int, bool);\n static bool rs6000_reg_live_or_pic_offset_p (int);\n static tree rs6000_builtin_vectorized_libmass (tree, tree, tree);\n static tree rs6000_builtin_vectorized_function (tree, tree, tree);\n@@ -18535,7 +18534,7 @@ rs6000_emit_stack_tie (rtx fp, bool hard_frame_needed)\n    The generated code may use hard register 0 as a temporary.  */\n \n static void\n-rs6000_emit_allocate_stack (HOST_WIDE_INT size, rtx copy_reg)\n+rs6000_emit_allocate_stack (HOST_WIDE_INT size, rtx copy_reg, int copy_off)\n {\n   rtx insn;\n   rtx stack_reg = gen_rtx_REG (Pmode, STACK_POINTER_REGNUM);\n@@ -18579,7 +18578,12 @@ rs6000_emit_allocate_stack (HOST_WIDE_INT size, rtx copy_reg)\n     }\n \n   if (copy_reg)\n-    emit_move_insn (copy_reg, stack_reg);\n+    {\n+      if (copy_off != 0)\n+\temit_insn (gen_add3_insn (copy_reg, stack_reg, GEN_INT (copy_off)));\n+      else\n+\temit_move_insn (copy_reg, stack_reg);\n+    }\n \n   if (size > 32767)\n     {\n@@ -18922,42 +18926,22 @@ static rtx\n emit_frame_save (rtx frame_reg, enum machine_mode mode,\n \t\t unsigned int regno, int offset, HOST_WIDE_INT frame_reg_to_sp)\n {\n-  rtx reg, offset_rtx, insn, mem, addr, int_rtx;\n-  rtx replacea, replaceb;\n-\n-  int_rtx = GEN_INT (offset);\n+  rtx reg, insn, mem, addr;\n \n   /* Some cases that need register indexed addressing.  */\n-  if ((TARGET_ALTIVEC_ABI && ALTIVEC_VECTOR_MODE (mode))\n-      || (TARGET_VSX && ALTIVEC_OR_VSX_VECTOR_MODE (mode))\n-      || (TARGET_E500_DOUBLE && mode == DFmode)\n-      || (TARGET_SPE_ABI\n-\t  && SPE_VECTOR_MODE (mode)\n-\t  && !SPE_CONST_OFFSET_OK (offset)))\n-    {\n-      /* Whomever calls us must make sure r11 is available in the\n-\t flow path of instructions in the prologue.  */\n-      offset_rtx = gen_rtx_REG (Pmode, 11);\n-      emit_move_insn (offset_rtx, int_rtx);\n-\n-      replacea = offset_rtx;\n-      replaceb = int_rtx;\n-    }\n-  else\n-    {\n-      offset_rtx = int_rtx;\n-      replacea = NULL_RTX;\n-      replaceb = NULL_RTX;\n-    }\n+  gcc_checking_assert (!((TARGET_ALTIVEC_ABI && ALTIVEC_VECTOR_MODE (mode))\n+\t\t\t || (TARGET_VSX && ALTIVEC_OR_VSX_VECTOR_MODE (mode))\n+\t\t\t || (TARGET_E500_DOUBLE && mode == DFmode)\n+\t\t\t || (TARGET_SPE_ABI\n+\t\t\t     && SPE_VECTOR_MODE (mode)\n+\t\t\t     && !SPE_CONST_OFFSET_OK (offset))));\n \n   reg = gen_rtx_REG (mode, regno);\n-  addr = gen_rtx_PLUS (Pmode, frame_reg, offset_rtx);\n+  addr = gen_rtx_PLUS (Pmode, frame_reg, GEN_INT (offset));\n   mem = gen_frame_mem (mode, addr);\n-\n   insn = emit_move_insn (mem, reg);\n-\n   return rs6000_frame_related (insn, frame_reg, frame_reg_to_sp,\n-\t\t\t       replacea, replaceb);\n+\t\t\t       NULL_RTX, NULL_RTX);\n }\n \n /* Emit an offset memory reference suitable for a frame store, while\n@@ -19158,61 +19142,55 @@ rs6000_savres_routine_sym (rs6000_stack_t *info, bool savep,\n }\n \n /* Emit a sequence of insns, including a stack tie if needed, for\n-   resetting the stack pointer.  If SAVRES is true, then don't reset the\n-   stack pointer, but move the base of the frame into r11 for use by\n-   out-of-line register restore routines.  */\n+   resetting the stack pointer.  If UPDT_REGNO is not 1, then don't\n+   reset the stack pointer, but move the base of the frame into\n+   reg UPDT_REGNO for use by out-of-line register restore routines.  */\n \n static rtx\n rs6000_emit_stack_reset (rs6000_stack_t *info,\n-\t\t\t rtx sp_reg_rtx, rtx frame_reg_rtx,\n-\t\t\t int sp_offset, bool savres)\n+\t\t\t rtx frame_reg_rtx, HOST_WIDE_INT frame_off,\n+\t\t\t unsigned updt_regno)\n {\n+  rtx updt_reg_rtx;\n+\n   /* This blockage is needed so that sched doesn't decide to move\n      the sp change before the register restores.  */\n   if (DEFAULT_ABI == ABI_V4\n       || (TARGET_SPE_ABI\n \t  && info->spe_64bit_regs_used != 0\n \t  && info->first_gp_reg_save != 32))\n     rs6000_emit_stack_tie (frame_reg_rtx, frame_pointer_needed);\n-  \n-  if (frame_reg_rtx != sp_reg_rtx)\n-    {\n-      if (sp_offset != 0)\n-\t{\n-\t  rtx dest_reg = savres ? gen_rtx_REG (Pmode, 11) : sp_reg_rtx;\n-\t  rtx insn = emit_insn (gen_add3_insn (dest_reg, frame_reg_rtx,\n-\t\t\t\t\t       GEN_INT (sp_offset)));\n-\t  if (!savres)\n-\t    return insn;\n-\t}\n-      else if (!savres)\n-\treturn emit_move_insn (sp_reg_rtx, frame_reg_rtx);\n-    }\n-  else if (sp_offset != 0)\n-    {\n-      /* If we are restoring registers out-of-line, we will be using the\n-\t \"exit\" variants of the restore routines, which will reset the\n-\t stack for us.\tBut we do need to point r11 into the right place\n-\t for those routines.  */\n-      rtx dest_reg = (savres\n-\t\t      ? gen_rtx_REG (Pmode, 11)\n-\t\t      : sp_reg_rtx);\n \n-      rtx insn = emit_insn (gen_add3_insn (dest_reg, sp_reg_rtx,\n-\t\t\t\t\t   GEN_INT (sp_offset)));\n-      if (!savres)\n-\treturn insn;\n-    }\n+  /* If we are restoring registers out-of-line, we will be using the\n+     \"exit\" variants of the restore routines, which will reset the\n+     stack for us.  But we do need to point updt_reg into the\n+     right place for those routines.  */\n+  updt_reg_rtx = gen_rtx_REG (Pmode, updt_regno);\n+\n+  if (frame_off != 0)\n+    return emit_insn (gen_add3_insn (updt_reg_rtx,\n+\t\t\t\t     frame_reg_rtx, GEN_INT (frame_off)));\n+  else if (REGNO (frame_reg_rtx) != updt_regno)\n+    return emit_move_insn (updt_reg_rtx, frame_reg_rtx);\n+\n   return NULL_RTX;\n }\n \n+static inline unsigned\n+ptr_regno_for_savres (bool gpr, bool lr)\n+{\n+  if (DEFAULT_ABI == ABI_AIX)\n+    return !gpr || lr ? 1 : 12;\n+  return DEFAULT_ABI == ABI_DARWIN && !gpr ? 1 : 11;\n+}\n+\n /* Construct a parallel rtx describing the effect of a call to an\n    out-of-line register save/restore routine, and emit the insn\n    or jump_insn as appropriate.  */\n \n static rtx\n rs6000_emit_savres_rtx (rs6000_stack_t *info,\n-\t\t\trtx frame_reg_rtx, int save_area_offset,\n+\t\t\trtx frame_reg_rtx, int save_area_offset, int lr_offset,\n \t\t\tenum machine_mode reg_mode,\n \t\t\tbool savep, bool gpr, bool lr)\n {\n@@ -19239,9 +19217,7 @@ rs6000_emit_savres_rtx (rs6000_stack_t *info,\n \n   sym = rs6000_savres_routine_sym (info, savep, gpr, lr);\n   RTVEC_ELT (p, offset++) = gen_rtx_USE (VOIDmode, sym);\n-  use_reg = (DEFAULT_ABI == ABI_AIX ? (gpr && !lr ? 12 : 1)\n-\t     : DEFAULT_ABI == ABI_DARWIN && !gpr ? 1\n-\t     : 11);\n+  use_reg = ptr_regno_for_savres (gpr, lr);\n   RTVEC_ELT (p, offset++)\n     = gen_rtx_USE (VOIDmode,\n \t\t   gen_rtx_REG (Pmode, use_reg));\n@@ -19264,7 +19240,7 @@ rs6000_emit_savres_rtx (rs6000_stack_t *info,\n       rtx addr, reg, mem;\n       reg = gen_rtx_REG (Pmode, 0);\n       addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n-\t\t\t   GEN_INT (info->lr_save_offset));\n+\t\t\t   GEN_INT (lr_offset));\n       mem = gen_frame_mem (Pmode, addr);\n       RTVEC_ELT (p, i + offset) = gen_rtx_SET (VOIDmode, mem, reg);\n     }\n@@ -19311,8 +19287,8 @@ rs6000_emit_prologue (void)\n   enum machine_mode reg_mode = Pmode;\n   int reg_size = TARGET_32BIT ? 4 : 8;\n   rtx sp_reg_rtx = gen_rtx_REG (Pmode, STACK_POINTER_REGNUM);\n-  rtx frame_ptr_rtx = gen_rtx_REG (Pmode, 12);\n   rtx frame_reg_rtx = sp_reg_rtx;\n+  unsigned int cr_save_regno;\n   rtx cr_save_rtx = NULL_RTX;\n   rtx insn;\n   int strategy;\n@@ -19485,12 +19461,14 @@ rs6000_emit_prologue (void)\n \t\t       ? (!saving_GPRs_inline\n \t\t\t  && info->spe_64bit_regs_used == 0)\n \t\t       : (!saving_FPRs_inline || !saving_GPRs_inline));\n-      rtx copy_reg = need_r11 ? gen_rtx_REG (Pmode, 11) : NULL;\n+      rtx ptr_reg = NULL_RTX;\n \n-      if (info->total_size < 32767)\n+      if (need_r11)\n+\t{\n+\t  ptr_reg = gen_rtx_REG (Pmode, 11);\n+\t}\n+      else if (info->total_size < 32767)\n \tframe_off = info->total_size;\n-      else if (need_r11)\n-\tframe_reg_rtx = copy_reg;\n       else if (info->cr_save_p\n \t       || info->lr_save_p\n \t       || info->first_fp_reg_save < 64\n@@ -19499,8 +19477,7 @@ rs6000_emit_prologue (void)\n \t       || info->vrsave_mask != 0\n \t       || crtl->calls_eh_return)\n \t{\n-\t  copy_reg = frame_ptr_rtx;\n-\t  frame_reg_rtx = copy_reg;\n+\t  ptr_reg = gen_rtx_REG (Pmode, 12);\n \t}\n       else\n \t{\n@@ -19511,7 +19488,18 @@ rs6000_emit_prologue (void)\n \t     changes to this function.  */\n \t  frame_off = info->total_size;\n \t}\n-      rs6000_emit_allocate_stack (info->total_size, copy_reg);\n+      if (ptr_reg != NULL_RTX)\n+\t{\n+\t  /* Set up the frame offset to that needed by the first\n+\t     out-of-line save function.  */\n+\t  frame_reg_rtx = ptr_reg;\n+\t  if (!saving_FPRs_inline && info->first_fp_reg_save < 64)\n+\t    gcc_checking_assert (info->fp_save_offset + info->fp_size == 0);\n+\t  else if (!saving_GPRs_inline && info->first_gp_reg_save < 32)\n+\t    frame_off = -(info->gp_save_offset + info->gp_size);\n+\t}\n+      rs6000_emit_allocate_stack (info->total_size, ptr_reg, -frame_off);\n+      sp_off = info->total_size;\n       sp_off = info->total_size;\n       if (frame_reg_rtx != sp_reg_rtx)\n \trs6000_emit_stack_tie (frame_reg_rtx, false);\n@@ -19522,16 +19510,15 @@ rs6000_emit_prologue (void)\n     {\n       rtx addr, reg, mem;\n \n-      insn = emit_move_insn (gen_rtx_REG (Pmode, 0),\n-\t\t\t     gen_rtx_REG (Pmode, LR_REGNO));\n+      reg = gen_rtx_REG (Pmode, 0);\n+      insn = emit_move_insn (reg, gen_rtx_REG (Pmode, LR_REGNO));\n       RTX_FRAME_RELATED_P (insn) = 1;\n \n       if (!(strategy & (SAVE_NOINLINE_GPRS_SAVES_LR\n \t\t\t| SAVE_NOINLINE_FPRS_SAVES_LR)))\n \t{\n \t  addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n \t\t\t       GEN_INT (info->lr_save_offset + frame_off));\n-\t  reg = gen_rtx_REG (Pmode, 0);\n \t  mem = gen_rtx_MEM (Pmode, addr);\n \t  /* This should not be of rs6000_sr_alias_set, because of\n \t     __builtin_return_address.  */\n@@ -19543,15 +19530,14 @@ rs6000_emit_prologue (void)\n     }\n \n   /* If we need to save CR, put it into r12 or r11.  */\n+  cr_save_regno = DEFAULT_ABI == ABI_AIX && !saving_GPRs_inline ? 11 : 12;\n   if (!WORLD_SAVE_P (info)\n       && info->cr_save_p\n-      && frame_reg_rtx != frame_ptr_rtx)\n+      && REGNO (frame_reg_rtx) != cr_save_regno)\n     {\n       rtx set;\n \n-      cr_save_rtx\n-\t= gen_rtx_REG (SImode, DEFAULT_ABI == ABI_AIX && !saving_GPRs_inline\n-\t\t       ? 11 : 12);\n+      cr_save_rtx = gen_rtx_REG (SImode, cr_save_regno);\n       insn = emit_insn (gen_movesi_from_cr (cr_save_rtx));\n       RTX_FRAME_RELATED_P (insn) = 1;\n       /* Now, there's no way that dwarf2out_frame_debug_expr is going\n@@ -19582,14 +19568,18 @@ rs6000_emit_prologue (void)\n     }\n   else if (!WORLD_SAVE_P (info) && info->first_fp_reg_save != 64)\n     {\n+      bool lr = (strategy & SAVE_NOINLINE_FPRS_SAVES_LR) != 0;\n+      unsigned ptr_regno = ptr_regno_for_savres (/*gpr=*/false, lr);\n+\n+      gcc_checking_assert (ptr_regno == REGNO (frame_reg_rtx)\n+\t\t\t   && info->fp_save_offset + info->fp_size == 0\n+\t\t\t   && frame_off == 0);\n       insn = rs6000_emit_savres_rtx (info, frame_reg_rtx,\n-\t\t\t\t     info->fp_save_offset + frame_off,\n+\t\t\t\t     info->fp_save_offset,\n+\t\t\t\t     info->lr_save_offset,\n \t\t\t\t     DFmode,\n-\t\t\t\t     /*savep=*/true, /*gpr=*/false,\n-\t\t\t\t     /*lr=*/((strategy\n-\t\t\t\t\t      & SAVE_NOINLINE_FPRS_SAVES_LR)\n-\t\t\t\t\t     != 0));\n-      rs6000_frame_related (insn, frame_reg_rtx, sp_off - frame_off,\n+\t\t\t\t     /*savep=*/true, /*gpr=*/false, lr);\n+      rs6000_frame_related (insn, frame_reg_rtx, sp_off,\n \t\t\t    NULL_RTX, NULL_RTX);\n     }\n \n@@ -19602,7 +19592,7 @@ rs6000_emit_prologue (void)\n     {\n       int i;\n       rtx spe_save_area_ptr;\n-      int save_ptr_to_sp;\n+      HOST_WIDE_INT save_off;\n       int ool_adjust = 0;\n \n       /* Determine whether we can address all of the registers that need\n@@ -19612,28 +19602,25 @@ rs6000_emit_prologue (void)\n \t= (SPE_CONST_OFFSET_OK (info->spe_gp_save_offset + frame_off\n \t\t\t\t+ reg_size * (32 - info->first_gp_reg_save - 1))\n \t   && saving_GPRs_inline);\n-      int spe_offset;\n \n       if (spe_regs_addressable)\n \t{\n \t  spe_save_area_ptr = frame_reg_rtx;\n-\t  save_ptr_to_sp = sp_off - frame_off;\n-\t  spe_offset = info->spe_gp_save_offset + frame_off;\n+\t  save_off = frame_off;\n \t}\n       else\n \t{\n \t  /* Make r11 point to the start of the SPE save area.  We need\n \t     to be careful here if r11 is holding the static chain.  If\n \t     it is, then temporarily save it in r0.  */\n-\t  int offset;\n+\t  HOST_WIDE_INT offset;\n \n \t  if (!saving_GPRs_inline)\n \t    ool_adjust = 8 * (info->first_gp_reg_save\n \t\t\t      - (FIRST_SAVRES_REGISTER + 1));\n \t  offset = info->spe_gp_save_offset + frame_off - ool_adjust;\n \t  spe_save_area_ptr = gen_rtx_REG (Pmode, 11);\n-\t  save_ptr_to_sp = sp_off - frame_off + offset;\n-\t  spe_offset = 0;\n+\t  save_off = frame_off - offset;\n \n \t  if (using_static_chain_p)\n \t    {\n@@ -19644,40 +19631,30 @@ rs6000_emit_prologue (void)\n \t    }\n \t  emit_insn (gen_addsi3 (spe_save_area_ptr,\n \t\t\t\t frame_reg_rtx, GEN_INT (offset)));\n-\t  if (REGNO (frame_reg_rtx) == 11)\n+\t  if (!using_static_chain_p && REGNO (frame_reg_rtx) == 11)\n \t    frame_off = -info->spe_gp_save_offset + ool_adjust;\n \t}\n \n       if (saving_GPRs_inline)\n \t{\n \t  for (i = 0; i < 32 - info->first_gp_reg_save; i++)\n \t    if (rs6000_reg_live_or_pic_offset_p (info->first_gp_reg_save + i))\n-\t      {\n-\t\trtx reg = gen_rtx_REG (reg_mode, info->first_gp_reg_save + i);\n-\t\trtx offset, addr, mem;\n-\n-\t\t/* We're doing all this to ensure that the offset fits into\n-\t\t   the immediate offset of 'evstdd'.  */\n-\t\tgcc_assert (SPE_CONST_OFFSET_OK (reg_size * i + spe_offset));\n-\n-\t\toffset = GEN_INT (reg_size * i + spe_offset);\n-\t\taddr = gen_rtx_PLUS (Pmode, spe_save_area_ptr, offset);\n-\t\tmem = gen_rtx_MEM (V2SImode, addr);\n-\n-\t\tinsn = emit_move_insn (mem, reg);\n-\n-\t\trs6000_frame_related (insn, spe_save_area_ptr, save_ptr_to_sp,\n-\t\t\t\t      NULL_RTX, NULL_RTX);\n-\t      }\n+\t      emit_frame_save (spe_save_area_ptr, reg_mode,\n+\t\t\t       info->first_gp_reg_save + i,\n+\t\t\t       (info->spe_gp_save_offset + save_off\n+\t\t\t\t+ reg_size * i),\n+\t\t\t       sp_off - save_off);\n \t}\n       else\n \t{\n \t  insn = rs6000_emit_savres_rtx (info, spe_save_area_ptr,\n-\t\t\t\t\t ool_adjust, reg_mode,\n+\t\t\t\t\t info->spe_gp_save_offset + save_off,\n+\t\t\t\t\t info->lr_save_offset + save_off,\n+\t\t\t\t\t reg_mode,\n \t\t\t\t\t /*savep=*/true, /*gpr=*/true,\n \t\t\t\t\t /*lr=*/false);\n \n-\t  rs6000_frame_related (insn, spe_save_area_ptr, save_ptr_to_sp,\n+\t  rs6000_frame_related (insn, spe_save_area_ptr, sp_off - save_off,\n \t\t\t\tNULL_RTX, NULL_RTX);\n \t}\n \n@@ -19687,45 +19664,36 @@ rs6000_emit_prologue (void)\n     }\n   else if (!WORLD_SAVE_P (info) && !saving_GPRs_inline)\n     {\n-      if (DEFAULT_ABI == ABI_DARWIN)\n-\t{\n-\t  rtx dest_reg = gen_rtx_REG (Pmode, 11);\n-\t  if (info->first_fp_reg_save == 64)\n-\t    {\n-\t      /* we only need a copy, no fprs were saved.  */\n-\t      if (dest_reg != frame_reg_rtx)\n-\t\temit_move_insn (dest_reg, frame_reg_rtx);\n-\t    }\n-\t  else\n-\t    {\n-\t      int save_off = 8 * (64 - info->first_fp_reg_save);\n-\t      rtx offset = GEN_INT (frame_off - save_off);\n+      bool lr = (strategy & SAVE_NOINLINE_GPRS_SAVES_LR) != 0;\n+      unsigned ptr_regno = ptr_regno_for_savres (/*gpr=*/true, lr);\n+      rtx ptr_reg = frame_reg_rtx;\n+      bool ptr_set_up = REGNO (ptr_reg) == ptr_regno;\n+      int end_save = info->gp_save_offset + info->gp_size;\n+      int ptr_off;\n+\n+      if (!ptr_set_up)\n+\tptr_reg = gen_rtx_REG (Pmode, ptr_regno);\n \n-\t      if (REGNO (dest_reg) == REGNO (frame_reg_rtx))\n-\t\tframe_off = save_off;\n-\t      emit_insn (gen_add3_insn (dest_reg, frame_reg_rtx, offset));\n-\t    }\n-\t}\n       /* Need to adjust r11 (r12) if we saved any FPRs.  */\n-      else if (info->first_fp_reg_save != 64)\n+      if (end_save + frame_off != 0)\n \t{\n-\t  rtx dest_reg = gen_rtx_REG (Pmode, DEFAULT_ABI == ABI_AIX ? 12 : 11);\n-\t  int save_off = 8 * (64 - info->first_fp_reg_save);\n-\t  rtx offset = GEN_INT (frame_off - save_off);\n+\t  rtx offset = GEN_INT (end_save + frame_off);\n \n-\t  if (REGNO (dest_reg) == REGNO (frame_reg_rtx))\n-\t    frame_off = save_off;\n-\t  emit_insn (gen_add3_insn (dest_reg, frame_reg_rtx, offset));\n+\t  if (ptr_set_up)\n+\t    frame_off = -end_save;\n+\t  emit_insn (gen_add3_insn (ptr_reg, frame_reg_rtx, offset));\n \t}\n-\n-      insn = rs6000_emit_savres_rtx (info, frame_reg_rtx,\n-\t\t\t\t     info->gp_save_offset + frame_off,\n+      else if (!ptr_set_up)\n+\t{\n+\t  emit_move_insn (ptr_reg, frame_reg_rtx);\n+\t}\n+      ptr_off = -end_save;\n+      insn = rs6000_emit_savres_rtx (info, ptr_reg,\n+\t\t\t\t     info->gp_save_offset + ptr_off,\n+\t\t\t\t     info->lr_save_offset + ptr_off,\n \t\t\t\t     reg_mode,\n-\t\t\t\t     /*savep=*/true, /*gpr=*/true,\n-\t\t\t\t     /*lr=*/((strategy\n-\t\t\t\t\t      & SAVE_NOINLINE_GPRS_SAVES_LR)\n-\t\t\t\t\t     != 0));\n-      rs6000_frame_related (insn, frame_reg_rtx, sp_off - frame_off,\n+\t\t\t\t     /*savep=*/true, /*gpr=*/true, lr);\n+      rs6000_frame_related (insn, ptr_reg, sp_off - ptr_off,\n \t\t\t    NULL_RTX, NULL_RTX);\n     }\n   else if (!WORLD_SAVE_P (info) && using_store_multiple)\n@@ -19754,20 +19722,10 @@ rs6000_emit_prologue (void)\n       int i;\n       for (i = 0; i < 32 - info->first_gp_reg_save; i++)\n \tif (rs6000_reg_live_or_pic_offset_p (info->first_gp_reg_save + i))\n-\t  {\n-\t    rtx addr, reg, mem;\n-\t    reg = gen_rtx_REG (reg_mode, info->first_gp_reg_save + i);\n-\n-\t    addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n-\t\t\t\t GEN_INT (info->gp_save_offset\n-\t\t\t\t\t  + frame_off\n-\t\t\t\t\t  + reg_size * i));\n-\t    mem = gen_frame_mem (reg_mode, addr);\n-\n-\t    insn = emit_move_insn (mem, reg);\n-\t    rs6000_frame_related (insn, frame_reg_rtx, sp_off - frame_off,\n-\t\t\t\t  NULL_RTX, NULL_RTX);\n-\t  }\n+\t  emit_frame_save (frame_reg_rtx, reg_mode,\n+\t\t\t   info->first_gp_reg_save + i,\n+\t\t\t   info->gp_save_offset + frame_off + reg_size * i,\n+\t\t\t   sp_off - frame_off);\n     }\n \n   /* ??? There's no need to emit actual instructions here, but it's the\n@@ -19795,8 +19753,7 @@ rs6000_emit_prologue (void)\n       rtx save_insn, join_insn, note;\n       long toc_restore_insn;\n \n-      gcc_assert (frame_reg_rtx == frame_ptr_rtx\n-\t\t  || frame_reg_rtx == sp_reg_rtx);\n+      gcc_assert (REGNO (frame_reg_rtx) != 11);\n       tmp_reg = gen_rtx_REG (Pmode, 11);\n       tmp_reg_si = gen_rtx_REG (SImode, 11);\n       if (using_static_chain_p)\n@@ -19866,9 +19823,8 @@ rs6000_emit_prologue (void)\n       /* See the large comment above about why CR2_REGNO is used.  */\n       rtx magic_eh_cr_reg = gen_rtx_REG (SImode, CR2_REGNO);\n \n-      /* If r12 was used to hold the original sp, copy cr into r0 now\n-\t that it's free.  */\n-      if (REGNO (frame_reg_rtx) == 12)\n+      /* If we didn't copy cr before, do so now using r0.  */\n+      if (cr_save_rtx == NULL_RTX)\n \t{\n \t  rtx set;\n \n@@ -19889,19 +19845,25 @@ rs6000_emit_prologue (void)\n   if (!WORLD_SAVE_P (info) && info->push_p\n       && !(DEFAULT_ABI == ABI_V4 || crtl->calls_eh_return))\n     {\n-      rtx copy_reg = NULL;\n+      rtx ptr_reg = NULL;\n \n-      if (info->total_size < 32767)\n-\tframe_off = info->total_size;\n-      else if (info->altivec_size != 0\n-\t       || info->vrsave_mask != 0)\n+      /* If saving altivec regs we need to be able to address all save\n+\t locations using a 16-bit offset.  */\n+      if ((info->altivec_size != 0\n+\t   && (info->altivec_save_offset + info->altivec_size - 16\n+\t       + info->total_size - frame_off) > 32767)\n+\t  || (info->vrsave_mask != 0\n+\t      && (info->vrsave_save_offset\n+\t\t  + info->total_size - frame_off) > 32767))\n \t{\n-\t  copy_reg = frame_ptr_rtx;\n-\t  frame_reg_rtx = copy_reg;\n+\t  ptr_reg = gen_rtx_REG (Pmode, 12);\n+\t  frame_reg_rtx = ptr_reg;\n+\t  frame_off = -(info->altivec_save_offset + info->altivec_size);\n \t}\n-      else\n+      else if (REGNO (frame_reg_rtx) == 1)\n \tframe_off = info->total_size;\n-      rs6000_emit_allocate_stack (info->total_size, copy_reg);\n+      rs6000_emit_allocate_stack (info->total_size, ptr_reg, -frame_off);\n+      sp_off = info->total_size;\n       sp_off = info->total_size;\n       if (frame_reg_rtx != sp_reg_rtx)\n \trs6000_emit_stack_tie (frame_reg_rtx, false);\n@@ -20005,13 +19967,14 @@ rs6000_emit_prologue (void)\n       if (save_LR_around_toc_setup)\n \t{\n \t  rtx lr = gen_rtx_REG (Pmode, LR_REGNO);\n+\t  rtx tmp = gen_rtx_REG (Pmode, 12);\n \n-\t  insn = emit_move_insn (frame_ptr_rtx, lr);\n+\t  insn = emit_move_insn (tmp, lr);\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n \n \t  rs6000_emit_load_toc_table (TRUE);\n \n-\t  insn = emit_move_insn (lr, frame_ptr_rtx);\n+\t  insn = emit_move_insn (lr, tmp);\n \t  add_reg_note (insn, REG_CFA_RESTORE, lr);\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n \t}\n@@ -20203,7 +20166,7 @@ rs6000_emit_epilogue (int sibcall)\n   int use_backchain_to_restore_sp;\n   int restore_lr;\n   int strategy;\n-  int frame_off = 0;\n+  HOST_WIDE_INT frame_off = 0;\n   rtx sp_reg_rtx = gen_rtx_REG (Pmode, 1);\n   rtx frame_reg_rtx = sp_reg_rtx;\n   rtx cfa_restores = NULL_RTX;\n@@ -20212,6 +20175,7 @@ rs6000_emit_epilogue (int sibcall)\n   enum machine_mode reg_mode = Pmode;\n   int reg_size = TARGET_32BIT ? 4 : 8;\n   int i;\n+  unsigned ptr_regno;\n \n   info = rs6000_stack_info ();\n \n@@ -20628,13 +20592,10 @@ rs6000_emit_epilogue (int sibcall)\n \t= (SPE_CONST_OFFSET_OK (info->spe_gp_save_offset + frame_off\n \t\t\t\t+ reg_size * (32 - info->first_gp_reg_save - 1))\n \t   && restoring_GPRs_inline);\n-      int spe_offset;\n-      int ool_adjust = 0;\n \n-      if (spe_regs_addressable)\n-\tspe_offset = info->spe_gp_save_offset + frame_off;\n-      else\n+      if (!spe_regs_addressable)\n \t{\n+\t  int ool_adjust = 0;\n \t  rtx old_frame_reg_rtx = frame_reg_rtx;\n \t  /* Make r11 point to the start of the SPE save area.  We worried about\n \t     not clobbering it when we were saving registers in the prologue.\n@@ -20652,12 +20613,12 @@ rs6000_emit_epilogue (int sibcall)\n \t  /* Keep the invariant that frame_reg_rtx + frame_off points\n \t     at the top of the stack frame.  */\n \t  frame_off = -info->spe_gp_save_offset + ool_adjust;\n-\n-\t  spe_offset = 0;\n \t}\n \n       if (restoring_GPRs_inline)\n \t{\n+\t  HOST_WIDE_INT spe_offset = info->spe_gp_save_offset + frame_off;\n+\n \t  for (i = 0; i < 32 - info->first_gp_reg_save; i++)\n \t    if (rs6000_reg_live_or_pic_offset_p (info->first_gp_reg_save + i))\n \t      {\n@@ -20677,39 +20638,39 @@ rs6000_emit_epilogue (int sibcall)\n \t}\n       else\n \trs6000_emit_savres_rtx (info, frame_reg_rtx,\n-\t\t\t\tool_adjust, reg_mode,\n+\t\t\t\tinfo->spe_gp_save_offset + frame_off,\n+\t\t\t\tinfo->lr_save_offset + frame_off,\n+\t\t\t\treg_mode,\n \t\t\t\t/*savep=*/false, /*gpr=*/true,\n \t\t\t\t/*lr=*/true);\n     }\n   else if (!restoring_GPRs_inline)\n     {\n       /* We are jumping to an out-of-line function.  */\n-      bool can_use_exit = info->first_fp_reg_save == 64;\n+      rtx ptr_reg;\n+      int end_save = info->gp_save_offset + info->gp_size;\n+      bool can_use_exit = end_save == 0;\n+      int ptr_off;\n \n       /* Emit stack reset code if we need it.  */\n+      ptr_regno = ptr_regno_for_savres (/*gpr=*/true, can_use_exit);\n+      ptr_reg = gen_rtx_REG (Pmode, ptr_regno);\n       if (can_use_exit)\n-\t{\n-\t  rs6000_emit_stack_reset (info, sp_reg_rtx, frame_reg_rtx,\n-\t\t\t\t   frame_off, can_use_exit);\n-\t  if (DEFAULT_ABI == ABI_DARWIN)\n-\t    /* we only need a copy, no fprs were saved.  */\n-\t    emit_move_insn (gen_rtx_REG (Pmode, 11), frame_reg_rtx);\n-\n-\t  if (info->cr_save_p)\n-\t    rs6000_restore_saved_cr (cr_save_reg, using_mtcr_multiple);\n-\t}\n+\trs6000_emit_stack_reset (info, frame_reg_rtx, frame_off, ptr_regno);\n       else\n-\t{\n-\t  rtx src_reg = gen_rtx_REG (Pmode, DEFAULT_ABI == ABI_AIX ? 12 : 11);\n-\n-\t  emit_insn (gen_add3_insn (src_reg, frame_reg_rtx,\n-\t\t\t\t    GEN_INT (frame_off - info->fp_size)));\n-\t  if (REGNO (frame_reg_rtx) == REGNO (src_reg))\n-\t    frame_off = info->fp_size;\n-\t}\n-\n-      rs6000_emit_savres_rtx (info, frame_reg_rtx,\n-\t\t\t      info->gp_save_offset, reg_mode,\n+\temit_insn (gen_add3_insn (ptr_reg, frame_reg_rtx,\n+\t\t\t\t  GEN_INT (end_save + frame_off)));\n+      if (REGNO (frame_reg_rtx) == ptr_regno)\n+\tframe_off = -end_save;\n+\n+      if (can_use_exit && info->cr_save_p)\n+\trs6000_restore_saved_cr (cr_save_reg, using_mtcr_multiple);\n+\n+      ptr_off = -end_save;\n+      rs6000_emit_savres_rtx (info, ptr_reg,\n+\t\t\t      info->gp_save_offset + ptr_off,\n+\t\t\t      info->lr_save_offset + ptr_off,\n+\t\t\t      reg_mode,\n \t\t\t      /*savep=*/false, /*gpr=*/true,\n \t\t\t      /*lr=*/can_use_exit);\n     }\n@@ -20843,10 +20804,19 @@ rs6000_emit_epilogue (int sibcall)\n     rs6000_restore_saved_cr (cr_save_reg, using_mtcr_multiple);\n \n   /* If this is V.4, unwind the stack pointer after all of the loads\n-     have been done.  */\n-  insn = rs6000_emit_stack_reset (info, sp_reg_rtx, frame_reg_rtx,\n-\t\t\t\t  frame_off, !restoring_FPRs_inline);\n-  if (insn)\n+     have been done, or set up r11 if we are restoring fp out of line.  */\n+  ptr_regno = 1;\n+  if (!restoring_FPRs_inline)\n+    {\n+      bool lr = (strategy & REST_NOINLINE_FPRS_DOESNT_RESTORE_LR) == 0;\n+      ptr_regno = ptr_regno_for_savres (/*gpr=*/false, lr);\n+    }\n+\n+  insn = rs6000_emit_stack_reset (info, frame_reg_rtx, frame_off, ptr_regno);\n+  if (REGNO (frame_reg_rtx) == ptr_regno)\n+    frame_off = 0;\n+\n+  if (insn && restoring_FPRs_inline)\n     {\n       if (cfa_restores)\n \t{"}]}