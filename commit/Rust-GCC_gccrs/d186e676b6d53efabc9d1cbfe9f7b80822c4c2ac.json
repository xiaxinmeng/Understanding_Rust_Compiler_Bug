{"sha": "d186e676b6d53efabc9d1cbfe9f7b80822c4c2ac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDE4NmU2NzZiNmQ1M2VmYWJjOWQxY2JmZTlmN2I4MDgyMmM0YzJhYw==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2003-09-30T18:24:33Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-09-30T18:24:33Z"}, "message": "jcf-write.c (generate_bytecode_insns): Implement evaluate-once semantics for SAVE_EXPR...\n\n\n\t* jcf-write.c (generate_bytecode_insns): Implement evaluate-once\n\tsemantics for SAVE_EXPR, by caching the result in a temporary.\n\nFrom-SVN: r71949", "tree": {"sha": "356336d35072d68cb7699897c268ca1398c12168", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/356336d35072d68cb7699897c268ca1398c12168"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d186e676b6d53efabc9d1cbfe9f7b80822c4c2ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d186e676b6d53efabc9d1cbfe9f7b80822c4c2ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d186e676b6d53efabc9d1cbfe9f7b80822c4c2ac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d186e676b6d53efabc9d1cbfe9f7b80822c4c2ac/comments", "author": null, "committer": null, "parents": [{"sha": "8cefb55d775aed11b49b3148ed947e853cd66205", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cefb55d775aed11b49b3148ed947e853cd66205", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8cefb55d775aed11b49b3148ed947e853cd66205"}], "stats": {"total": 37, "additions": 36, "deletions": 1}, "files": [{"sha": "bf5da8c9ec9767dcb8defc44e1da1c55b225cc5e", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d186e676b6d53efabc9d1cbfe9f7b80822c4c2ac/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d186e676b6d53efabc9d1cbfe9f7b80822c4c2ac/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=d186e676b6d53efabc9d1cbfe9f7b80822c4c2ac", "patch": "@@ -1,3 +1,8 @@\n+2003-09-30  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* jcf-write.c (generate_bytecode_insns): Implement evaluate-once\n+\tsemantics for SAVE_EXPR, by caching the result in a temporary.\n+\n 2003-09-28  Richard Henderson  <rth@redhat.com>\n \n \t* check-init.c (check_init): Save and restore input_location"}, {"sha": "097177e48b966f1f80f551c43175d60d70f8a381", "filename": "gcc/java/jcf-write.c", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d186e676b6d53efabc9d1cbfe9f7b80822c4c2ac/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d186e676b6d53efabc9d1cbfe9f7b80822c4c2ac/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=d186e676b6d53efabc9d1cbfe9f7b80822c4c2ac", "patch": "@@ -2149,7 +2149,37 @@ generate_bytecode_insns (tree exp, int target, struct jcf_partial *state)\n       }\n       break;\n     case SAVE_EXPR:\n-      generate_bytecode_insns (TREE_OPERAND (exp, 0), STACK_TARGET, state);\n+      /* Because the state associated with a SAVE_EXPR tree node must\n+\t be a RTL expression, we use it to store the DECL_LOCAL_INDEX\n+\t of a temporary variable in a CONST_INT.  */\n+      if (! SAVE_EXPR_RTL (exp))\n+\t{\n+\t  tree type = TREE_TYPE (exp);\n+\t  tree decl = build_decl (VAR_DECL, NULL_TREE, type);\n+\t  generate_bytecode_insns (TREE_OPERAND (exp, 0),\n+\t\t\t\t   STACK_TARGET, state);\n+\t  localvar_alloc (decl, state);\n+\t  SAVE_EXPR_RTL (exp) = GEN_INT (DECL_LOCAL_INDEX (decl));\n+\t  emit_dup (TYPE_IS_WIDE (type) ? 2 : 1, 0, state);\n+\t  emit_store (decl, state);\n+\t}\n+      else\n+\t{\n+\t  /* The following code avoids creating a temporary DECL just\n+\t     to pass to emit_load.  This code could be factored with\n+\t     the similar implementation in emit_load_or_store.  */\n+\t  tree type = TREE_TYPE (exp);\n+\t  int kind = adjust_typed_op (type, 4);\n+\t  int index = (int) INTVAL (SAVE_EXPR_RTL (exp));\n+\t  if (index <= 3)\n+\t    {\n+\t      RESERVE (1);  /* [ilfda]load_[0123]  */\n+\t      OP1 (OPCODE_iload + 5 + 4*kind + index);\n+\t    }\n+\t  else  /* [ilfda]load  */\n+\t    maybe_wide (OPCODE_iload + kind, index, state);\n+\t  NOTE_PUSH (TYPE_IS_WIDE (type) ? 2 : 1);\n+\t}\n       break;\n     case CONVERT_EXPR:\n     case NOP_EXPR:"}]}