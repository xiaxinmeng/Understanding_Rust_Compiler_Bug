{"sha": "b99ce2a8b92662555be709c4944c365f28bdc2ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjk5Y2UyYThiOTI2NjI1NTViZTcwOWM0OTQ0YzM2NWYyOGJkYzJlZQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2011-03-27T09:11:15Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2011-03-27T09:11:15Z"}, "message": "mips.c (mips_prepare_builtin_arg): Replace icode and opno arguments with an expand_operand.\n\ngcc/\n\t* config/mips/mips.c (mips_prepare_builtin_arg): Replace icode and\n\topno arguments with an expand_operand.  Use create_input_operand.\n\t(mips_prepare_builtin_target): Delete.\n\t(mips_expand_builtin_insn, mips_expand_builtin_compare_1): New\n\tfunctions.\n\t(mips_expand_builtin_direct): Use create_output_operand and\n\tmips_expand_builtin_insn.  Update call to mips_prepare_builtin_arg.\n\t(mips_expand_builtin_movtf): Likewise.  Use mips_expand_fp_comparison.\n\t(mips_expand_builtin_compare): Use mips_expand_fp_comparison.\n\nFrom-SVN: r171571", "tree": {"sha": "fbb8821893ea3ddd8c5ac693a1b261db020ef5a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fbb8821893ea3ddd8c5ac693a1b261db020ef5a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b99ce2a8b92662555be709c4944c365f28bdc2ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b99ce2a8b92662555be709c4944c365f28bdc2ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b99ce2a8b92662555be709c4944c365f28bdc2ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b99ce2a8b92662555be709c4944c365f28bdc2ee/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5092eb960c2df8071aa8d61114788265579ebeaa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5092eb960c2df8071aa8d61114788265579ebeaa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5092eb960c2df8071aa8d61114788265579ebeaa"}], "stats": {"total": 170, "additions": 71, "deletions": 99}, "files": [{"sha": "c80e4ee2c5707bdf9d4864d5ae3e145c9be24c64", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b99ce2a8b92662555be709c4944c365f28bdc2ee/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b99ce2a8b92662555be709c4944c365f28bdc2ee/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b99ce2a8b92662555be709c4944c365f28bdc2ee", "patch": "@@ -1,3 +1,15 @@\n+2011-03-27  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* config/mips/mips.c (mips_prepare_builtin_arg): Replace icode and\n+\topno arguments with an expand_operand.  Use create_input_operand.\n+\t(mips_prepare_builtin_target): Delete.\n+\t(mips_expand_builtin_insn, mips_expand_builtin_compare_1): New\n+\tfunctions.\n+\t(mips_expand_builtin_direct): Use create_output_operand and\n+\tmips_expand_builtin_insn.  Update call to mips_prepare_builtin_arg.\n+\t(mips_expand_builtin_movtf): Likewise.  Use mips_expand_fp_comparison.\n+\t(mips_expand_builtin_compare): Use mips_expand_fp_comparison.\n+\n 2011-03-27  Ira Rosen  <ira.rosen@linaro.org>\n \n \t* config/arm/arm.c (arm_autovectorize_vector_sizes): New"}, {"sha": "d1f6ad57fe07d92557d22948a19509be6c619b78", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 59, "deletions": 99, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b99ce2a8b92662555be709c4944c365f28bdc2ee/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b99ce2a8b92662555be709c4944c365f28bdc2ee/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=b99ce2a8b92662555be709c4944c365f28bdc2ee", "patch": "@@ -13184,56 +13184,64 @@ mips_builtin_decl (unsigned int code, bool initialize_p ATTRIBUTE_UNUSED)\n   return mips_builtin_decls[code];\n }\n \n-/* Take argument ARGNO from EXP's argument list and convert it into a\n-   form suitable for input operand OPNO of instruction ICODE.  Return the\n-   value.  */\n+/* Take argument ARGNO from EXP's argument list and convert it into\n+   an expand operand.  Store the operand in *OP.  */\n \n-static rtx\n-mips_prepare_builtin_arg (enum insn_code icode,\n-\t\t\t  unsigned int opno, tree exp, unsigned int argno)\n+static void\n+mips_prepare_builtin_arg (struct expand_operand *op, tree exp,\n+\t\t\t  unsigned int argno)\n {\n   tree arg;\n   rtx value;\n-  enum machine_mode mode;\n \n   arg = CALL_EXPR_ARG (exp, argno);\n   value = expand_normal (arg);\n-  mode = insn_data[icode].operand[opno].mode;\n-  if (!insn_data[icode].operand[opno].predicate (value, mode))\n-    {\n-      /* We need to get the mode from ARG for two reasons:\n+  create_input_operand (op, value, TYPE_MODE (TREE_TYPE (arg)));\n+}\n \n-\t   - to cope with address operands, where MODE is the mode of the\n-\t     memory, rather than of VALUE itself.\n+/* Expand instruction ICODE as part of a built-in function sequence.\n+   Use the first NOPS elements of OPS as the instruction's operands.\n+   HAS_TARGET_P is true if operand 0 is a target; it is false if the\n+   instruction has no target.\n \n-\t   - to cope with special predicates like pmode_register_operand,\n-\t     where MODE is VOIDmode.  */\n-      value = copy_to_mode_reg (TYPE_MODE (TREE_TYPE (arg)), value);\n+   Return the target rtx if HAS_TARGET_P, otherwise return const0_rtx.  */\n \n-      /* Check the predicate again.  */\n-      if (!insn_data[icode].operand[opno].predicate (value, mode))\n-\t{\n-\t  error (\"invalid argument to built-in function\");\n-\t  return const0_rtx;\n-\t}\n+static rtx\n+mips_expand_builtin_insn (enum insn_code icode, unsigned int nops,\n+\t\t\t  struct expand_operand *ops, bool has_target_p)\n+{\n+  if (!maybe_expand_insn (icode, nops, ops))\n+    {\n+      error (\"invalid argument to built-in function\");\n+      return has_target_p ? gen_reg_rtx (ops[0].mode) : const0_rtx;\n     }\n-\n-  return value;\n+  return has_target_p ? ops[0].value : const0_rtx;\n }\n \n-/* Return an rtx suitable for output operand OP of instruction ICODE.\n-   If TARGET is non-null, try to use it where possible.  */\n+/* Expand a floating-point comparison for built-in function call EXP.\n+   The first NARGS arguments are the values to be compared.  ICODE is\n+   the .md pattern that does the comparison and COND is the condition\n+   that is being tested.  Return an rtx for the result.  */\n \n static rtx\n-mips_prepare_builtin_target (enum insn_code icode, unsigned int op, rtx target)\n+mips_expand_builtin_compare_1 (enum insn_code icode,\n+\t\t\t       enum mips_fp_condition cond,\n+\t\t\t       tree exp, int nargs)\n {\n-  enum machine_mode mode;\n+  struct expand_operand ops[MAX_RECOG_OPERANDS];\n+  int opno, argno;\n \n-  mode = insn_data[icode].operand[op].mode;\n-  if (target == 0 || !insn_data[icode].operand[op].predicate (target, mode))\n-    target = gen_reg_rtx (mode);\n+  /* The instruction should have a target operand, an operand for each\n+     argument, and an operand for COND.  */\n+  gcc_assert (nargs + 2 == insn_data[(int) icode].n_operands);\n \n-  return target;\n+  opno = 0;\n+  create_output_operand (&ops[opno++], NULL_RTX,\n+\t\t\t insn_data[(int) icode].operand[0].mode);\n+  for (argno = 0; argno < nargs; argno++)\n+    mips_prepare_builtin_arg (&ops[opno++], exp, argno);\n+  create_integer_operand (&ops[opno++], (int) cond);\n+  return mips_expand_builtin_insn (icode, opno, ops, true);\n }\n \n /* Expand a MIPS_BUILTIN_DIRECT or MIPS_BUILTIN_DIRECT_NO_TARGET function;\n@@ -13245,44 +13253,23 @@ static rtx\n mips_expand_builtin_direct (enum insn_code icode, rtx target, tree exp,\n \t\t\t    bool has_target_p)\n {\n-  rtx ops[MAX_RECOG_OPERANDS];\n+  struct expand_operand ops[MAX_RECOG_OPERANDS];\n   int opno, argno;\n \n   /* Map any target to operand 0.  */\n   opno = 0;\n   if (has_target_p)\n-    {\n-      target = mips_prepare_builtin_target (icode, opno, target);\n-      ops[opno] = target;\n-      opno++;\n-    }\n+    create_output_operand (&ops[opno++], target, TYPE_MODE (TREE_TYPE (exp)));\n \n   /* Map the arguments to the other operands.  The n_operands value\n      for an expander includes match_dups and match_scratches as well as\n      match_operands, so n_operands is only an upper bound on the number\n      of arguments to the expander function.  */\n   gcc_assert (opno + call_expr_nargs (exp) <= insn_data[icode].n_operands);\n-  for (argno = 0; argno < call_expr_nargs (exp); argno++, opno++)\n-    ops[opno] = mips_prepare_builtin_arg (icode, opno, exp, argno);\n-\n-  switch (opno)\n-    {\n-    case 2:\n-      emit_insn (GEN_FCN (icode) (ops[0], ops[1]));\n-      break;\n-\n-    case 3:\n-      emit_insn (GEN_FCN (icode) (ops[0], ops[1], ops[2]));\n-      break;\n-\n-    case 4:\n-      emit_insn (GEN_FCN (icode) (ops[0], ops[1], ops[2], ops[3]));\n-      break;\n+  for (argno = 0; argno < call_expr_nargs (exp); argno++)\n+    mips_prepare_builtin_arg (&ops[opno++], exp, argno);\n \n-    default:\n-      gcc_unreachable ();\n-    }\n-  return target;\n+  return mips_expand_builtin_insn (icode, opno, ops, has_target_p);\n }\n \n /* Expand a __builtin_mips_movt_*_ps or __builtin_mips_movf_*_ps\n@@ -13296,27 +13283,24 @@ mips_expand_builtin_movtf (enum mips_builtin_type type,\n \t\t\t   enum insn_code icode, enum mips_fp_condition cond,\n \t\t\t   rtx target, tree exp)\n {\n-  rtx cmp_result, op0, op1;\n-\n-  cmp_result = mips_prepare_builtin_target (icode, 0, 0);\n-  op0 = mips_prepare_builtin_arg (icode, 1, exp, 0);\n-  op1 = mips_prepare_builtin_arg (icode, 2, exp, 1);\n-  emit_insn (GEN_FCN (icode) (cmp_result, op0, op1, GEN_INT (cond)));\n+  struct expand_operand ops[4];\n+  rtx cmp_result;\n \n-  icode = CODE_FOR_mips_cond_move_tf_ps;\n-  target = mips_prepare_builtin_target (icode, 0, target);\n+  cmp_result = mips_expand_builtin_compare_1 (icode, cond, exp, 2);\n+  create_output_operand (&ops[0], target, TYPE_MODE (TREE_TYPE (exp)));\n   if (type == MIPS_BUILTIN_MOVT)\n     {\n-      op1 = mips_prepare_builtin_arg (icode, 2, exp, 2);\n-      op0 = mips_prepare_builtin_arg (icode, 1, exp, 3);\n+      mips_prepare_builtin_arg (&ops[2], exp, 2);\n+      mips_prepare_builtin_arg (&ops[1], exp, 3);\n     }\n   else\n     {\n-      op0 = mips_prepare_builtin_arg (icode, 1, exp, 2);\n-      op1 = mips_prepare_builtin_arg (icode, 2, exp, 3);\n+      mips_prepare_builtin_arg (&ops[1], exp, 2);\n+      mips_prepare_builtin_arg (&ops[2], exp, 3);\n     }\n-  emit_insn (gen_mips_cond_move_tf_ps (target, op0, op1, cmp_result));\n-  return target;\n+  create_fixed_operand (&ops[3], cmp_result);\n+  return mips_expand_builtin_insn (CODE_FOR_mips_cond_move_tf_ps,\n+\t\t\t\t   4, ops, true);\n }\n \n /* Move VALUE_IF_TRUE into TARGET if CONDITION is true; move VALUE_IF_FALSE\n@@ -13357,36 +13341,12 @@ mips_expand_builtin_compare (enum mips_builtin_type builtin_type,\n \t\t\t     enum insn_code icode, enum mips_fp_condition cond,\n \t\t\t     rtx target, tree exp)\n {\n-  rtx offset, condition, cmp_result, args[MAX_RECOG_OPERANDS];\n-  int argno;\n+  rtx offset, condition, cmp_result;\n \n   if (target == 0 || GET_MODE (target) != SImode)\n     target = gen_reg_rtx (SImode);\n-\n-  /* The instruction should have a target operand, an operand for each\n-     argument, and an operand for COND.  */\n-  gcc_assert (call_expr_nargs (exp) + 2 == insn_data[icode].n_operands);\n-\n-  /* Prepare the operands to the comparison.  */\n-  cmp_result = mips_prepare_builtin_target (icode, 0, 0);\n-  for (argno = 0; argno < call_expr_nargs (exp); argno++)\n-    args[argno] = mips_prepare_builtin_arg (icode, argno + 1, exp, argno);\n-\n-  switch (insn_data[icode].n_operands)\n-    {\n-    case 4:\n-      emit_insn (GEN_FCN (icode) (cmp_result, args[0], args[1],\n-\t\t\t\t  GEN_INT (cond)));\n-      break;\n-\n-    case 6:\n-      emit_insn (GEN_FCN (icode) (cmp_result, args[0], args[1],\n-\t\t\t\t  args[2], args[3], GEN_INT (cond)));\n-      break;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n+  cmp_result = mips_expand_builtin_compare_1 (icode, cond, exp,\n+\t\t\t\t\t      call_expr_nargs (exp));\n \n   /* If the comparison sets more than one register, we define the result\n      to be 0 if all registers are false and -1 if all registers are true."}]}