{"sha": "7dc56b36b8c9b8fde03ac0f1d8279105ebb58cfb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2RjNTZiMzZiOGM5YjhmZGUwM2FjMGYxZDgyNzkxMDVlYmI1OGNmYg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2006-02-15T09:47:09Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-02-15T09:47:09Z"}, "message": "tracebak.c (PPC AIX/Darwin): Define FORCE_CALL to 1.\n\n2006-02-13  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* tracebak.c (PPC AIX/Darwin): Define FORCE_CALL to 1.\n\t(PPC VxWorks): Likewise.\n\t(Generic unwinder): Define FORCE_CALL to 0 if not already defined.\n\t(forced_callee): Make non-inlinable and non-pure.\n\t(__gnat_backtrace): Call forced_callee if FORCE_CALL is set to 1.\n\nFrom-SVN: r111103", "tree": {"sha": "cf23c9d5805ebfe482f50161f153e2125e246ffb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf23c9d5805ebfe482f50161f153e2125e246ffb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7dc56b36b8c9b8fde03ac0f1d8279105ebb58cfb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7dc56b36b8c9b8fde03ac0f1d8279105ebb58cfb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7dc56b36b8c9b8fde03ac0f1d8279105ebb58cfb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7dc56b36b8c9b8fde03ac0f1d8279105ebb58cfb/comments", "author": null, "committer": null, "parents": [{"sha": "405b3ed444dd41d7818ab4da3da2f1ceb26ea4d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/405b3ed444dd41d7818ab4da3da2f1ceb26ea4d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/405b3ed444dd41d7818ab4da3da2f1ceb26ea4d4"}], "stats": {"total": 31, "additions": 18, "deletions": 13}, "files": [{"sha": "55fa44a3dd687b79d7ccf9689113cea4b876827a", "filename": "gcc/ada/tracebak.c", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dc56b36b8c9b8fde03ac0f1d8279105ebb58cfb/gcc%2Fada%2Ftracebak.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dc56b36b8c9b8fde03ac0f1d8279105ebb58cfb/gcc%2Fada%2Ftracebak.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftracebak.c?ref=7dc56b36b8c9b8fde03ac0f1d8279105ebb58cfb", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *                     Copyright (C) 2000-2005, AdaCore                     *\n+ *                     Copyright (C) 2000-2006, AdaCore                     *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -193,7 +193,8 @@ extern void (*Unlock_Task) (void);\n \n /*--------------------------- PPC AIX/Darwin ----------------------------*/\n \n-#if (defined (__ppc__) && ((defined (_AIX) || defined (__APPLE__))))\n+#if ((defined (_POWER) && defined (_AIX)) || \\\n+(defined (__ppc__) && defined (__APPLE__)))\n \n #define USE_GENERIC_UNWINDER\n \n@@ -215,7 +216,7 @@ struct layout\n    To have __gnat_backtrace retrieve its own return address, we then\n    define ... */\n \n-#define FORCE_CALL\n+#define FORCE_CALL 1\n #define FRAME_LEVEL 1\n \n #define BASE_SKIP 1\n@@ -232,7 +233,7 @@ struct layout\n   void *return_address;\n };\n \n-#define FORCE_CALL\n+#define FORCE_CALL 1\n #define FRAME_LEVEL 1\n /* See the PPC AIX case for an explanation of these values.  */\n \n@@ -404,13 +405,19 @@ struct layout\n #define MAX(x,y) ((x) > (y) ? (x) : (y))\n #endif\n \n-/* Define a dummy function to call if FORCE_CALL is defined.  Don't\n-   define it otherwise, as this could lead to \"defined but not used\"\n-   warnings.  */\n-#if defined (FORCE_CALL)\n-static void forced_callee () {}\n+#ifndef FORCE_CALL\n+#define FORCE_CALL 0\n #endif\n \n+/* Make sure the function is not inlined.  */\n+static void forced_callee (void) __attribute__ ((noinline));\n+\n+static void forced_callee (void)\n+{\n+  /* Make sure the function is not pure.  */\n+  volatile int i __attribute__ ((unused)) = 0;\n+}\n+\n int\n __gnat_backtrace (void **array,\n                   int size,\n@@ -423,10 +430,8 @@ __gnat_backtrace (void **array,\n   void *top_stack;\n   int cnt = 0;\n \n-  /* Honor FORCE_CALL when defined.  */\n-#if defined (FORCE_CALL)\n-  forced_callee ();\n-#endif\n+  if (FORCE_CALL)\n+    forced_callee ();\n \n   /* Force a call to builtin_frame_address with a positive argument\n      if required. This is necessary e.g. on sparc to have the register"}]}