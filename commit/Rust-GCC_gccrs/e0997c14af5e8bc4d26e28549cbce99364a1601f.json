{"sha": "e0997c14af5e8bc4d26e28549cbce99364a1601f", "node_id": "C_kwDOANBUbNoAKGUwOTk3YzE0YWY1ZThiYzRkMjZlMjg1NDljYmNlOTkzNjRhMTYwMWY", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2022-10-28T00:37:28Z"}, "committer": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2022-10-28T00:37:28Z"}, "message": "c: C2x enums with fixed underlying type [PR61469]\n\nC2x adds support for enums with a fixed underlying type specified\n(\"enum e : long long;\" and similar).  Implement this in the C front\nend.  The same representation is used for these types as in C++, with\ntwo macros moved from cp-tree.h to c-common.h.\n\nSuch enums can have bool as the underlying type, and various C\nfront-end code checking for boolean types is adjusted to use a new\nC_BOOLEAN_TYPE_P to handle such enums the same way as bool.  (Note\nthat for C++ we have bug 96496 that enums with underlying type bool\ndon't work correctly there.)\n\nThere are various issues with the wording for such enums in the\ncurrent C2x working draft (including but not limited to wording in the\naccepted paper that failed to make it into the working draft), which I\nintend to raise in NB comments.  I think what I've implemented and\nadded tests for matches the intent.\n\nBootstrapped with no regressions for x86_64-pc-linux-gnu.\n\n\tPR c/61469\n\ngcc/c-family/\n\t* c-common.h (ENUM_UNDERLYING_TYPE, ENUM_FIXED_UNDERLYING_TYPE_P):\n\tNew.  Moved from cp/cp-tree.h.\n\t* c-warn.cc (warnings_for_convert_and_check): Do not consider\n\tconversions to enum with underlying type bool to overflow.\n\ngcc/c/\n\t* c-convert.cc (c_convert): Handle enums with underlying boolean\n\ttype like bool.\n\t* c-decl.cc (shadow_tag_warned): Allow shadowing declarations for\n\tenums with enum type specifier, but give errors for storage class\n\tspecifiers, qualifiers or alignment specifiers in non-definition\n\tdeclarations of such enums.\n\t(grokdeclarator): Give error for non-definition use of type\n\tspecifier with an enum type specifier.\n\t(parser_xref_tag): Add argument has_enum_type_specifier.  Pass it\n\tto lookup_tag and use it to set ENUM_FIXED_UNDERLYING_TYPE_P.\n\t(xref_tag): Update call to parser_xref_tag.\n\t(start_enum): Add argument fixed_underlying_type.  Complete enum\n\ttype with a fixed underlying type given in the definition.  Give\n\terror for defining without a fixed underlying type in the\n\tdefinition if one was given in a prior declaration.  Do not mark\n\tenums with fixed underlying type as packed for -fshort-enums.\n\tStore the enum type in the_enum.\n\t(finish_enum): Do not adjust types of values or check their range\n\tfor an enum with a fixed underlying type.  Set underlying type of\n\tenum and variants.\n\t(build_enumerator): Check enumeration constants for enum with\n\tfixed underlying type against that type and convert to that type.\n\tIncrement in the underlying integer type, with handling for bool.\n\t(c_simulate_enum_decl): Update call to start_enum.\n\t(declspecs_add_type): Set specs->enum_type_specifier_ref_p.\n\t* c-objc-common.cc (c_get_alias_set): Use ENUM_UNDERLYING_TYPE\n\trather than recomputing an underlying type based on size.\n\t* c-parser.cc (c_parser_declspecs)\n\t(c_parser_struct_or_union_specifier, c_parser_typeof_specifier):\n\tSet has_enum_type_specifier for type specifiers.\n\t(c_parser_enum_specifier): Handle enum type specifiers.\n\t(c_parser_struct_or_union_specifier): Update call to\n\tparser_xref_tag.\n\t(c_parser_omp_atomic): Check for boolean increment or decrement\n\tusing C_BOOLEAN_TYPE_P.\n\t* c-tree.h (C_BOOLEAN_TYPE_P): New.\n\t(struct c_typespec): Add has_enum_type_specifier.\n\t(struct c_declspecs): Add enum_type_specifier_ref_p.\n\t(struct c_enum_contents): Add enum_type.\n\t(start_enum, parser_xref_tag): Update prototypes.\n\t* c-typeck.cc (composite_type): Allow for enumerated types\n\tcompatible with bool.\n\t(common_type, comptypes_internal, perform_integral_promotions):\n\tUse ENUM_UNDERLYING_TYPE.\n\t(parser_build_binary_op, build_unary_op, convert_for_assignment)\n\t(c_finish_return, c_start_switch, build_binary_op): Check for\n\tboolean types using C_BOOLEAN_TYPE_P.\n\ngcc/cp/\n\t* cp-tree.h (ENUM_FIXED_UNDERLYING_TYPE_P, ENUM_UNDERLYING_TYPE):\n\tRemove.  Moved to c-common.h.\n\ngcc/testsuite/\n\t* gcc.dg/c11-enum-4.c, gcc.dg/c11-enum-5.c, gcc.dg/c11-enum-6.c,\n\tgcc.dg/c2x-enum-6.c, gcc.dg/c2x-enum-7.c, gcc.dg/c2x-enum-8.c,\n\tgcc.dg/gnu2x-enum-1.c: New tests.", "tree": {"sha": "84fb0f36a0673df481028555dc3da83a12cf9e63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/84fb0f36a0673df481028555dc3da83a12cf9e63"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e0997c14af5e8bc4d26e28549cbce99364a1601f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0997c14af5e8bc4d26e28549cbce99364a1601f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0997c14af5e8bc4d26e28549cbce99364a1601f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0997c14af5e8bc4d26e28549cbce99364a1601f/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "96069d8433775769804b5fa5576d6f59a723a6b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96069d8433775769804b5fa5576d6f59a723a6b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96069d8433775769804b5fa5576d6f59a723a6b6"}], "stats": {"total": 916, "additions": 732, "deletions": 184}, "files": [{"sha": "f9d0d2945a56fa74f1a81a1c6e84b48de869f583", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0997c14af5e8bc4d26e28549cbce99364a1601f/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0997c14af5e8bc4d26e28549cbce99364a1601f/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=e0997c14af5e8bc4d26e28549cbce99364a1601f", "patch": "@@ -1004,6 +1004,30 @@ extern void c_parse_final_cleanups (void);\n /* True iff TYPE is cv decltype(nullptr).  */\n #define NULLPTR_TYPE_P(TYPE) (TREE_CODE (TYPE) == NULLPTR_TYPE)\n \n+/* Returns the underlying type of the given enumeration type. The\n+   underlying type is determined in different ways, depending on the\n+   properties of the enum:\n+\n+     - In C++0x or C2x, the underlying type can be explicitly specified, e.g.,\n+\n+         enum E1 : char { ... } // underlying type is char\n+\n+     - In a C++0x scoped enumeration, the underlying type is int\n+       unless otherwises specified:\n+\n+         enum class E2 { ... } // underlying type is int\n+\n+     - Otherwise, the underlying type is determined based on the\n+       values of the enumerators. In this case, the\n+       ENUM_UNDERLYING_TYPE will not be set until after the definition\n+       of the enumeration is completed by finish_enum.  */\n+#define ENUM_UNDERLYING_TYPE(TYPE) \\\n+  TREE_TYPE (ENUMERAL_TYPE_CHECK (TYPE))\n+\n+/* Determines whether an ENUMERAL_TYPE has an explicit\n+   underlying type.  */\n+#define ENUM_FIXED_UNDERLYING_TYPE_P(NODE) (TYPE_LANG_FLAG_5 (NODE))\n+\n extern tree do_case (location_t, tree, tree, tree);\n extern tree build_stmt (location_t, enum tree_code, ...);\n extern tree build_real_imag_expr (location_t, enum tree_code, tree);"}, {"sha": "cd59c3cafa918c116be948397994bb21407d9f9e", "filename": "gcc/c-family/c-warn.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0997c14af5e8bc4d26e28549cbce99364a1601f/gcc%2Fc-family%2Fc-warn.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0997c14af5e8bc4d26e28549cbce99364a1601f/gcc%2Fc-family%2Fc-warn.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-warn.cc?ref=e0997c14af5e8bc4d26e28549cbce99364a1601f", "patch": "@@ -1415,7 +1415,8 @@ warnings_for_convert_and_check (location_t loc, tree type, tree expr,\n \n   if (TREE_CODE (expr) == INTEGER_CST\n       && (TREE_CODE (type) == INTEGER_TYPE\n-\t  || TREE_CODE (type) == ENUMERAL_TYPE)\n+\t  || (TREE_CODE (type) == ENUMERAL_TYPE\n+\t      && TREE_CODE (ENUM_UNDERLYING_TYPE (type)) != BOOLEAN_TYPE))\n       && !int_fits_type_p (expr, type))\n     {\n       /* Do not diagnose overflow in a constant expression merely"}, {"sha": "8a43e5f6f33c44e9a17c7af4015db62dd0b40434", "filename": "gcc/c/c-convert.cc", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0997c14af5e8bc4d26e28549cbce99364a1601f/gcc%2Fc%2Fc-convert.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0997c14af5e8bc4d26e28549cbce99364a1601f/gcc%2Fc%2Fc-convert.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-convert.cc?ref=e0997c14af5e8bc4d26e28549cbce99364a1601f", "patch": "@@ -110,8 +110,13 @@ c_convert (tree type, tree expr, bool init_const)\n     case VOID_TYPE:\n       return fold_convert_loc (loc, type, e);\n \n-    case INTEGER_TYPE:\n     case ENUMERAL_TYPE:\n+      if (ENUM_UNDERLYING_TYPE (type) != NULL_TREE\n+\t  && TREE_CODE (ENUM_UNDERLYING_TYPE (type)) == BOOLEAN_TYPE)\n+\tgoto convert_to_boolean;\n+      gcc_fallthrough ();\n+\n+    case INTEGER_TYPE:\n       if (sanitize_flags_p (SANITIZE_FLOAT_CAST)\n \t  && current_function_decl != NULL_TREE\n \t  && TREE_CODE (TREE_TYPE (expr)) == REAL_TYPE\n@@ -129,6 +134,7 @@ c_convert (tree type, tree expr, bool init_const)\n       goto maybe_fold;\n \n     case BOOLEAN_TYPE:\n+    convert_to_boolean:\n       return fold_convert_loc\n \t(loc, type, c_objc_common_truthvalue_conversion (input_location, expr));\n "}, {"sha": "2b83900e3f0a1588c022ff92952747459e541898", "filename": "gcc/c/c-decl.cc", "status": "modified", "additions": 224, "deletions": 101, "changes": 325, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0997c14af5e8bc4d26e28549cbce99364a1601f/gcc%2Fc%2Fc-decl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0997c14af5e8bc4d26e28549cbce99364a1601f/gcc%2Fc%2Fc-decl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.cc?ref=e0997c14af5e8bc4d26e28549cbce99364a1601f", "patch": "@@ -4817,7 +4817,8 @@ shadow_tag_warned (const struct c_declspecs *declspecs, int warned)\n \t  else if (declspecs->typespec_kind != ctsk_tagdef\n \t\t   && declspecs->typespec_kind != ctsk_tagfirstref\n \t\t   && declspecs->typespec_kind != ctsk_tagfirstref_attrs\n-\t\t   && code == ENUMERAL_TYPE)\n+\t\t   && code == ENUMERAL_TYPE\n+\t\t   && !declspecs->enum_type_specifier_ref_p)\n \t    {\n \t      bool warned_enum = false;\n \t      if (warned != 1)\n@@ -4883,6 +4884,38 @@ shadow_tag_warned (const struct c_declspecs *declspecs, int warned)\n       warned = 1;\n     }\n \n+  if (declspecs->enum_type_specifier_ref_p && !warned)\n+    {\n+      if (declspecs->storage_class != csc_none)\n+\t{\n+\t  error (\"storage class specifier in empty declaration with %<enum%> \"\n+\t\t \"underlying type\");\n+\t  warned = 1;\n+\t}\n+      else if (declspecs->thread_p)\n+\t{\n+\t  error (\"%qs in empty declaration with %<enum%> underlying type\",\n+\t\t declspecs->thread_gnu_p ? \"__thread\" : \"_Thread_local\");\n+\t  warned = 1;\n+\t}\n+      else if (declspecs->const_p\n+\t       || declspecs->volatile_p\n+\t       || declspecs->atomic_p\n+\t       || declspecs->restrict_p\n+\t       || declspecs->address_space)\n+\t{\n+\t  error (\"type qualifier in empty declaration with %<enum%> \"\n+\t\t \"underlying type\");\n+\t  warned = 1;\n+\t}\n+      else if (declspecs->alignas_p)\n+\t{\n+\t  error (\"%<alignas%> in empty declaration with %<enum%> \"\n+\t\t \"underlying type\");\n+\t  warned = 1;\n+\t}\n+    }\n+\n   if (!warned && !in_system_header_at (input_location)\n       && declspecs->storage_class != csc_none)\n     {\n@@ -6496,6 +6529,16 @@ grokdeclarator (const struct c_declarator *declarator,\n       }\n   }\n \n+  /* An enum type specifier (\": specifier-qualifier-list\") may only be\n+     specified when the enum is being defined or in an empty\n+     declaration of the form \"enum identifier enum-type-specifier;\".\n+     Except for the case of an empty declaration that has additional\n+     declaration specifiers, all invalid contexts (declarations that\n+     aren't empty, type names, parameter declarations, member\n+     declarations) pass through grokdeclarator.  */\n+  if (declspecs->enum_type_specifier_ref_p)\n+    error_at (loc, \"%<enum%> underlying type may not be specified here\");\n+\n   /* A function definition's declarator must have the form of\n      a function declarator.  */\n \n@@ -8285,24 +8328,29 @@ get_parm_info (bool ellipsis, tree expr)\n    Define the tag as a forward-reference with location LOC if it is\n    not defined.  HAVE_STD_ATTRS says whether any standard attributes\n    were present after the struct, union or enum keyword; ATTRS are the\n-   standard attributes present there.  Return a c_typespec structure\n-   for the type specifier.  */\n+   standard attributes present there.  HAS_ENUM_TYPE_SPECIFIER says\n+   whether an enum type specifier (\": specifier-qualifier-list\") is\n+   present; if so, this is called before that specifier is parsed, so\n+   that the tag is in scope for that specifier.  Return a c_typespec\n+   structure for the type specifier.  */\n \n struct c_typespec\n parser_xref_tag (location_t loc, enum tree_code code, tree name,\n-\t\t bool have_std_attrs, tree attrs)\n+\t\t bool have_std_attrs, tree attrs, bool has_enum_type_specifier)\n {\n   struct c_typespec ret;\n   tree ref;\n   location_t refloc;\n \n   ret.expr = NULL_TREE;\n   ret.expr_const_operands = true;\n+  ret.has_enum_type_specifier = has_enum_type_specifier;\n \n-  /* If a cross reference is requested, look up the type\n-     already defined for this tag and return it.  */\n+  /* If a cross reference is requested, look up the type already\n+     defined for this tag and return it.  If an enum type specifier is\n+     present, only a definition in the current scope is relevant.  */\n \n-  ref = lookup_tag (code, name, false, &refloc);\n+  ref = lookup_tag (code, name, has_enum_type_specifier, &refloc);\n   /* If this is the right type of tag, return what we found.\n      (This reference will be shadowed by shadow_tag later if appropriate.)\n      If this is the wrong type of tag, do not return it.  If it was the\n@@ -8371,6 +8419,7 @@ parser_xref_tag (location_t loc, enum tree_code code, tree name,\n       TYPE_PRECISION (ref) = TYPE_PRECISION (unsigned_type_node);\n       TYPE_MIN_VALUE (ref) = TYPE_MIN_VALUE (unsigned_type_node);\n       TYPE_MAX_VALUE (ref) = TYPE_MAX_VALUE (unsigned_type_node);\n+      ENUM_FIXED_UNDERLYING_TYPE_P (ref) = has_enum_type_specifier;\n     }\n \n   pushtag (loc, name, ref);\n@@ -8387,7 +8436,8 @@ parser_xref_tag (location_t loc, enum tree_code code, tree name,\n tree\n xref_tag (enum tree_code code, tree name)\n {\n-  return parser_xref_tag (input_location, code, name, false, NULL_TREE).spec;\n+  return parser_xref_tag (input_location, code, name, false, NULL_TREE,\n+\t\t\t  false).spec;\n }\n \f\n /* Make sure that the tag NAME is defined *in the current scope*\n@@ -9288,12 +9338,15 @@ layout_array_type (tree t)\n /* Begin compiling the definition of an enumeration type.\n    NAME is its name (or null if anonymous).\n    LOC is the enum's location.\n+   FIXED_UNDERLYING_TYPE is the (C2x) underlying type specified in the\n+   definition.\n    Returns the type object, as yet incomplete.\n    Also records info about it so that build_enumerator\n    may be used to declare the individual values as they are read.  */\n \n tree\n-start_enum (location_t loc, struct c_enum_contents *the_enum, tree name)\n+start_enum (location_t loc, struct c_enum_contents *the_enum, tree name,\n+\t    tree fixed_underlying_type)\n {\n   tree enumtype = NULL_TREE;\n   location_t enumloc = UNKNOWN_LOCATION;\n@@ -9309,6 +9362,23 @@ start_enum (location_t loc, struct c_enum_contents *the_enum, tree name)\n     {\n       enumtype = make_node (ENUMERAL_TYPE);\n       pushtag (loc, name, enumtype);\n+      if (fixed_underlying_type != NULL_TREE)\n+\t{\n+\t  /* For an enum definition with a fixed underlying type, the\n+\t     type is complete during the definition and the\n+\t     enumeration constants have that type.  If there was a\n+\t     tag, the type was completed in c_parser_enum_specifier.\n+\t     If not, it must be completed here.  */\n+\t  ENUM_FIXED_UNDERLYING_TYPE_P (enumtype) = true;\n+\t  TYPE_MIN_VALUE (enumtype) = TYPE_MIN_VALUE (fixed_underlying_type);\n+\t  TYPE_MAX_VALUE (enumtype) = TYPE_MAX_VALUE (fixed_underlying_type);\n+\t  TYPE_UNSIGNED (enumtype) = TYPE_UNSIGNED (fixed_underlying_type);\n+\t  SET_TYPE_ALIGN (enumtype, TYPE_ALIGN (fixed_underlying_type));\n+\t  TYPE_SIZE (enumtype) = NULL_TREE;\n+\t  TYPE_PRECISION (enumtype) = TYPE_PRECISION (fixed_underlying_type);\n+\t  ENUM_UNDERLYING_TYPE (enumtype) = fixed_underlying_type;\n+\t  layout_type (enumtype);\n+\t}\n     }\n   /* Update type location to the one of the definition, instead of e.g.\n      a forward declaration.  */\n@@ -9336,10 +9406,16 @@ start_enum (location_t loc, struct c_enum_contents *the_enum, tree name)\n       TYPE_VALUES (enumtype) = NULL_TREE;\n     }\n \n+  if (ENUM_FIXED_UNDERLYING_TYPE_P (enumtype)\n+      && fixed_underlying_type == NULL_TREE)\n+    error_at (loc, \"%<enum%> declared with but defined without \"\n+\t      \"fixed underlying type\");\n+\n   the_enum->enum_next_value = integer_zero_node;\n+  the_enum->enum_type = enumtype;\n   the_enum->enum_overflow = 0;\n \n-  if (flag_short_enums)\n+  if (flag_short_enums && !ENUM_FIXED_UNDERLYING_TYPE_P (enumtype))\n     for (tree v = TYPE_MAIN_VARIANT (enumtype); v; v = TYPE_NEXT_VARIANT (v))\n       TYPE_PACKED (v) = 1;\n \n@@ -9403,54 +9479,61 @@ finish_enum (tree enumtype, tree values, tree attributes)\n     (tree_int_cst_lt (minnode, TYPE_MIN_VALUE (integer_type_node))\n      || tree_int_cst_lt (TYPE_MAX_VALUE (integer_type_node), maxnode));\n \n-  /* If the precision of the type was specified with an attribute and it\n-     was too small, give an error.  Otherwise, use it.  */\n-  if (TYPE_PRECISION (enumtype) && lookup_attribute (\"mode\", attributes))\n+\n+  if (!ENUM_FIXED_UNDERLYING_TYPE_P (enumtype))\n     {\n-      if (precision > TYPE_PRECISION (enumtype))\n+      /* If the precision of the type was specified with an attribute and it\n+\t was too small, give an error.  Otherwise, use it.  */\n+      if (TYPE_PRECISION (enumtype) && lookup_attribute (\"mode\", attributes))\n \t{\n-\t  TYPE_PRECISION (enumtype) = 0;\n-\t  error (\"specified mode too small for enumerated values\");\n+\t  if (precision > TYPE_PRECISION (enumtype))\n+\t    {\n+\t      TYPE_PRECISION (enumtype) = 0;\n+\t      error (\"specified mode too small for enumerated values\");\n+\t    }\n+\t  else\n+\t    precision = TYPE_PRECISION (enumtype);\n \t}\n       else\n-\tprecision = TYPE_PRECISION (enumtype);\n-    }\n-  else\n-    TYPE_PRECISION (enumtype) = 0;\n-\n-  if (TYPE_PACKED (enumtype)\n-      || precision > TYPE_PRECISION (integer_type_node)\n-      || TYPE_PRECISION (enumtype))\n-    {\n-      tem = c_common_type_for_size (precision, sign == UNSIGNED ? 1 : 0);\n-      if (tem == NULL)\n-\t{\n-\t  /* This should only occur when both signed and unsigned\n-\t     values of maximum precision occur among the\n-\t     enumerators.  */\n-\t  pedwarn (input_location, 0,\n-\t\t   \"enumeration values exceed range of largest integer\");\n-\t  tem = widest_integer_literal_type_node;\n-\t}\n-      else if (precision > TYPE_PRECISION (intmax_type_node)\n-\t       && !tree_int_cst_lt (minnode, TYPE_MIN_VALUE (intmax_type_node))\n-\t       && !tree_int_cst_lt (TYPE_MAX_VALUE (uintmax_type_node),\n-\t\t\t\t    maxnode))\n-\tpedwarn (input_location, OPT_Wpedantic,\n-\t\t \"enumeration values exceed range of %qs\",\n-\t\t sign == UNSIGNED ? \"uintmax_t\" : \"intmax_t\");\n-    }\n-  else\n-    tem = sign == UNSIGNED ? unsigned_type_node : integer_type_node;\n+\tTYPE_PRECISION (enumtype) = 0;\n+\n+      if (TYPE_PACKED (enumtype)\n+\t  || precision > TYPE_PRECISION (integer_type_node)\n+\t  || TYPE_PRECISION (enumtype))\n+\t{\n+\t  tem = c_common_type_for_size (precision, sign == UNSIGNED ? 1 : 0);\n+\t  if (tem == NULL)\n+\t    {\n+\t      /* This should only occur when both signed and unsigned\n+\t\t values of maximum precision occur among the\n+\t\t enumerators.  */\n+\t      pedwarn (input_location, 0,\n+\t\t       \"enumeration values exceed range of largest integer\");\n+\t      tem = widest_integer_literal_type_node;\n+\t    }\n+\t  else if (precision > TYPE_PRECISION (intmax_type_node)\n+\t\t   && !tree_int_cst_lt (minnode,\n+\t\t\t\t\tTYPE_MIN_VALUE (intmax_type_node))\n+\t\t   && !tree_int_cst_lt (TYPE_MAX_VALUE (uintmax_type_node),\n+\t\t\t\t\tmaxnode))\n+\t    pedwarn (input_location, OPT_Wpedantic,\n+\t\t     \"enumeration values exceed range of %qs\",\n+\t\t     sign == UNSIGNED ? \"uintmax_t\" : \"intmax_t\");\n+\t}\n+      else\n+\ttem = sign == UNSIGNED ? unsigned_type_node : integer_type_node;\n \n-  TYPE_MIN_VALUE (enumtype) = TYPE_MIN_VALUE (tem);\n-  TYPE_MAX_VALUE (enumtype) = TYPE_MAX_VALUE (tem);\n-  TYPE_UNSIGNED (enumtype) = TYPE_UNSIGNED (tem);\n-  SET_TYPE_ALIGN (enumtype, TYPE_ALIGN (tem));\n-  TYPE_SIZE (enumtype) = NULL_TREE;\n-  TYPE_PRECISION (enumtype) = TYPE_PRECISION (tem);\n+      TYPE_MIN_VALUE (enumtype) = TYPE_MIN_VALUE (tem);\n+      TYPE_MAX_VALUE (enumtype) = TYPE_MAX_VALUE (tem);\n+      TYPE_UNSIGNED (enumtype) = TYPE_UNSIGNED (tem);\n+      SET_TYPE_ALIGN (enumtype, TYPE_ALIGN (tem));\n+      TYPE_SIZE (enumtype) = NULL_TREE;\n+      TYPE_PRECISION (enumtype) = TYPE_PRECISION (tem);\n+      ENUM_UNDERLYING_TYPE (enumtype) =\n+\tc_common_type_for_size (TYPE_PRECISION (tem), TYPE_UNSIGNED (tem));\n \n-  layout_type (enumtype);\n+      layout_type (enumtype);\n+    }\n \n   if (values != error_mark_node)\n     {\n@@ -9477,8 +9560,10 @@ finish_enum (tree enumtype, tree values, tree attributes)\n \t     fit in int are given type int in build_enumerator (which\n \t     is the correct type while the enumeration is being\n \t     parsed), so no conversions are needed here if all\n-\t     enumerators fit in int.  */\n-\t  if (wider_than_int)\n+\t     enumerators fit in int.  If the enum has a fixed\n+\t     underlying type, the correct type was also given in\n+\t     build_enumerator.  */\n+\t  if (!ENUM_FIXED_UNDERLYING_TYPE_P (enumtype) && wider_than_int)\n \t    ini = convert (enumtype, ini);\n \n \t  DECL_INITIAL (enu) = ini;\n@@ -9516,6 +9601,7 @@ finish_enum (tree enumtype, tree values, tree attributes)\n       TYPE_USER_ALIGN (tem) = TYPE_USER_ALIGN (enumtype);\n       TYPE_UNSIGNED (tem) = TYPE_UNSIGNED (enumtype);\n       TYPE_LANG_SPECIFIC (tem) = TYPE_LANG_SPECIFIC (enumtype);\n+      ENUM_UNDERLYING_TYPE (tem) = ENUM_UNDERLYING_TYPE (enumtype);\n     }\n \n   /* Finish debugging output for this type.  */\n@@ -9595,56 +9681,89 @@ build_enumerator (location_t decl_loc, location_t loc,\n       if (the_enum->enum_overflow)\n \terror_at (loc, \"overflow in enumeration values\");\n     }\n-  /* Even though the underlying type of an enum is unspecified, the\n-     type of enumeration constants is explicitly defined as int\n-     (6.4.4.3/2 in the C99 Standard).  C2X allows any integer type, and\n-     GCC allows such types for older standards as an extension.  */\n-  bool warned_range = false;\n-  if (!int_fits_type_p (value,\n-\t\t\t(TYPE_UNSIGNED (TREE_TYPE (value))\n-\t\t\t ? uintmax_type_node\n-\t\t\t : intmax_type_node)))\n-    /* GCC does not consider its types larger than intmax_t to be\n-       extended integer types (although C2X would permit such types to\n-       be considered extended integer types if all the features\n-       required by <stdint.h> and <inttypes.h> macros, such as support\n-       for integer constants and I/O, were present), so diagnose if\n-       such a wider type is used.  (If the wider type arose from a\n-       constant of such a type, that will also have been diagnosed,\n-       but this is the only diagnostic in the case where it arises\n-       from choosing a wider type automatically when adding 1\n-       overflows.)  */\n-    warned_range = pedwarn (loc, OPT_Wpedantic,\n-\t\t\t    \"enumerator value outside the range of %qs\",\n+  if (ENUM_FIXED_UNDERLYING_TYPE_P (the_enum->enum_type))\n+    {\n+      /* Enumeration constants must fit in the fixed underlying type.  */\n+      if (!int_fits_type_p (value, ENUM_UNDERLYING_TYPE (the_enum->enum_type)))\n+\terror_at (loc,\n+\t\t  \"enumerator value outside the range of underlying type\");\n+      /* Enumeration constants for an enum with fixed underlying type\n+\t have the enum type, both inside and outside the\n+\t definition.  */\n+      value = convert (the_enum->enum_type, value);\n+    }\n+  else\n+    {\n+      /* Even though the underlying type of an enum is unspecified, the\n+\t type of enumeration constants is explicitly defined as int\n+\t (6.4.4.3/2 in the C99 Standard).  C2X allows any integer type, and\n+\t GCC allows such types for older standards as an extension.  */\n+      bool warned_range = false;\n+      if (!int_fits_type_p (value,\n \t\t\t    (TYPE_UNSIGNED (TREE_TYPE (value))\n-\t\t\t     ? \"uintmax_t\"\n-\t\t\t     : \"intmax_t\"));\n-  if (!warned_range && !int_fits_type_p (value, integer_type_node))\n-    pedwarn_c11 (loc, OPT_Wpedantic,\n-\t\t \"ISO C restricts enumerator values to range of %<int%> \"\n-\t\t \"before C2X\");\n-\n-  /* The ISO C Standard mandates enumerators to have type int before\n-     C2X, even though the underlying type of an enum type is\n-     unspecified.  C2X allows enumerators of any integer type.  During\n-     the parsing of the enumeration, C2X specifies that constants\n-     representable in int have type int, constants not representable\n-     in int have the type of the given expression if any, and\n-     constants not representable in int and derived by adding 1 to the\n-     previous constant have the type of that constant unless the\n-     addition would overflow or wraparound, in which case a wider type\n-     of the same signedness is chosen automatically; after the\n-     enumeration is parsed, all the constants have the type of the\n-     enumeration if any do not fit in int.  */\n-  if (int_fits_type_p (value, integer_type_node))\n-    value = convert (integer_type_node, value);\n+\t\t\t     ? uintmax_type_node\n+\t\t\t     : intmax_type_node)))\n+\t/* GCC does not consider its types larger than intmax_t to be\n+\t   extended integer types (although C2X would permit such types to\n+\t   be considered extended integer types if all the features\n+\t   required by <stdint.h> and <inttypes.h> macros, such as support\n+\t   for integer constants and I/O, were present), so diagnose if\n+\t   such a wider type is used.  (If the wider type arose from a\n+\t   constant of such a type, that will also have been diagnosed,\n+\t   but this is the only diagnostic in the case where it arises\n+\t   from choosing a wider type automatically when adding 1\n+\t   overflows.)  */\n+\twarned_range = pedwarn (loc, OPT_Wpedantic,\n+\t\t\t\t\"enumerator value outside the range of %qs\",\n+\t\t\t\t(TYPE_UNSIGNED (TREE_TYPE (value))\n+\t\t\t\t ? \"uintmax_t\"\n+\t\t\t\t : \"intmax_t\"));\n+      if (!warned_range && !int_fits_type_p (value, integer_type_node))\n+\tpedwarn_c11 (loc, OPT_Wpedantic,\n+\t\t     \"ISO C restricts enumerator values to range of %<int%> \"\n+\t\t     \"before C2X\");\n+\n+      /* The ISO C Standard mandates enumerators to have type int before\n+\t C2X, even though the underlying type of an enum type is\n+\t unspecified.  C2X allows enumerators of any integer type.  During\n+\t the parsing of the enumeration, C2X specifies that constants\n+\t representable in int have type int, constants not representable\n+\t in int have the type of the given expression if any, and\n+\t constants not representable in int and derived by adding 1 to the\n+\t previous constant have the type of that constant unless the\n+\t addition would overflow or wraparound, in which case a wider type\n+\t of the same signedness is chosen automatically; after the\n+\t enumeration is parsed, all the constants have the type of the\n+\t enumeration if any do not fit in int.  */\n+      if (int_fits_type_p (value, integer_type_node))\n+\tvalue = convert (integer_type_node, value);\n+    }\n \n   /* Set basis for default for next value.  */\n-  the_enum->enum_next_value\n-    = build_binary_op (EXPR_LOC_OR_LOC (value, input_location),\n-\t\t       PLUS_EXPR, value, integer_one_node, false);\n+  if (ENUM_FIXED_UNDERLYING_TYPE_P (the_enum->enum_type))\n+    {\n+      tree underlying_type = ENUM_UNDERLYING_TYPE (the_enum->enum_type);\n+      if (TREE_CODE (underlying_type) == BOOLEAN_TYPE)\n+\t/* A value of 2 following a value of 1 overflows bool, but we\n+\t   cannot carry out addition directly on bool without\n+\t   promotion, and converting the result of arithmetic in a\n+\t   wider type back to bool would not produce the right result\n+\t   for this overflow check.  */\n+\tthe_enum->enum_next_value = invert_truthvalue_loc (loc, value);\n+      else\n+\tthe_enum->enum_next_value\n+\t  = build_binary_op (EXPR_LOC_OR_LOC (value, input_location),\n+\t\t\t     PLUS_EXPR, convert (underlying_type, value),\n+\t\t\t     convert (underlying_type, integer_one_node),\n+\t\t\t     false);\n+    }\n+  else\n+    the_enum->enum_next_value\n+      = build_binary_op (EXPR_LOC_OR_LOC (value, input_location),\n+\t\t\t PLUS_EXPR, value, integer_one_node, false);\n   the_enum->enum_overflow = tree_int_cst_lt (the_enum->enum_next_value, value);\n-  if (the_enum->enum_overflow)\n+  if (the_enum->enum_overflow\n+      && !ENUM_FIXED_UNDERLYING_TYPE_P (the_enum->enum_type))\n     {\n       /* Choose a wider type with the same signedness if\n \t available.  */\n@@ -9691,7 +9810,8 @@ c_simulate_enum_decl (location_t loc, const char *name,\n   input_location = loc;\n \n   struct c_enum_contents the_enum;\n-  tree enumtype = start_enum (loc, &the_enum, get_identifier (name));\n+  tree enumtype = start_enum (loc, &the_enum, get_identifier (name),\n+\t\t\t      NULL_TREE);\n \n   tree value_chain = NULL_TREE;\n   string_int_pair *value;\n@@ -11980,6 +12100,9 @@ declspecs_add_type (location_t loc, struct c_declspecs *specs,\n \t    }\n \t}\n       specs->type = type;\n+      if (spec.has_enum_type_specifier\n+\t  && spec.kind != ctsk_tagdef)\n+\tspecs->enum_type_specifier_ref_p = true;\n     }\n \n   return specs;"}, {"sha": "1a8b162821885f32ec7d6960e677311219447fa5", "filename": "gcc/c/c-objc-common.cc", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0997c14af5e8bc4d26e28549cbce99364a1601f/gcc%2Fc%2Fc-objc-common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0997c14af5e8bc4d26e28549cbce99364a1601f/gcc%2Fc%2Fc-objc-common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-objc-common.cc?ref=e0997c14af5e8bc4d26e28549cbce99364a1601f", "patch": "@@ -387,13 +387,7 @@ c_get_alias_set (tree t)\n   /* Allow aliasing between enumeral types and the underlying\n      integer type.  This is required since those are compatible types.  */\n   if (TREE_CODE (t) == ENUMERAL_TYPE)\n-    {\n-      tree t1 = c_common_type_for_size (tree_to_uhwi (TYPE_SIZE (t)),\n-\t\t\t\t\t/* short-cut commoning to signed\n-\t\t\t\t\t   type.  */\n-\t\t\t\t\tfalse);\n-      return get_alias_set (t1);\n-    }\n+    return get_alias_set (ENUM_UNDERLYING_TYPE (t));\n \n   return c_common_get_alias_set (t);\n }"}, {"sha": "5bdcd93b5c7e3e30fb91f00fd7a5035883e615bc", "filename": "gcc/c/c-parser.cc", "status": "modified", "additions": 116, "deletions": 23, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0997c14af5e8bc4d26e28549cbce99364a1601f/gcc%2Fc%2Fc-parser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0997c14af5e8bc4d26e28549cbce99364a1601f/gcc%2Fc%2Fc-parser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.cc?ref=e0997c14af5e8bc4d26e28549cbce99364a1601f", "patch": "@@ -3011,6 +3011,7 @@ c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,\n \t    }\n \t  t.expr = NULL_TREE;\n \t  t.expr_const_operands = true;\n+\t  t.has_enum_type_specifier = false;\n \t  declspecs_add_type (name_token->location, specs, t);\n \t  continue;\n \t}\n@@ -3027,6 +3028,7 @@ c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,\n \t  t.spec = objc_get_protocol_qualified_type (NULL_TREE, proto);\n \t  t.expr = NULL_TREE;\n \t  t.expr_const_operands = true;\n+\t  t.has_enum_type_specifier = false;\n \t  declspecs_add_type (loc, specs, t);\n \t  continue;\n \t}\n@@ -3087,6 +3089,7 @@ c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,\n \t  t.spec = c_parser_peek_token (parser)->value;\n \t  t.expr = NULL_TREE;\n \t  t.expr_const_operands = true;\n+\t  t.has_enum_type_specifier = false;\n \t  declspecs_add_type (loc, specs, t);\n \t  c_parser_consume_token (parser);\n \t  break;\n@@ -3151,6 +3154,7 @@ c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,\n \t      t.spec = error_mark_node;\n \t      t.expr = NULL_TREE;\n \t      t.expr_const_operands = true;\n+\t      t.has_enum_type_specifier = false;\n \t      if (type != NULL)\n \t\tt.spec = groktypename (type, &t.expr,\n \t\t\t\t       &t.expr_const_operands);\n@@ -3218,17 +3222,20 @@ c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,\n /* Parse an enum specifier (C90 6.5.2.2, C99 6.7.2.2, C11 6.7.2.2).\n \n    enum-specifier:\n-     enum gnu-attributes[opt] identifier[opt] { enumerator-list }\n-       gnu-attributes[opt]\n-     enum gnu-attributes[opt] identifier[opt] { enumerator-list , }\n-       gnu-attributes[opt]\n+     enum gnu-attributes[opt] identifier[opt] enum-type-specifier[opt]\n+       { enumerator-list } gnu-attributes[opt]\n+     enum gnu-attributes[opt] identifier[opt] enum-type-specifier[opt]\n+       { enumerator-list , } gnu-attributes[opt] enum-type-specifier[opt]\n      enum gnu-attributes[opt] identifier\n \n-   The form with trailing comma is new in C99.  The forms with\n-   gnu-attributes are GNU extensions.  In GNU C, we accept any expression\n-   without commas in the syntax (assignment expressions, not just\n-   conditional expressions); assignment expressions will be diagnosed\n-   as non-constant.\n+   The form with trailing comma is new in C99; enum-type-specifiers\n+   are new in C2x.  The forms with gnu-attributes are GNU extensions.\n+   In GNU C, we accept any expression without commas in the syntax\n+   (assignment expressions, not just conditional expressions);\n+   assignment expressions will be diagnosed as non-constant.\n+\n+   enum-type-specifier:\n+     : specifier-qualifier-list\n \n    enumerator-list:\n      enumerator\n@@ -3256,6 +3263,7 @@ c_parser_enum_specifier (c_parser *parser)\n   tree std_attrs = NULL_TREE;\n   tree attrs;\n   tree ident = NULL_TREE;\n+  tree fixed_underlying_type = NULL_TREE;\n   location_t enum_loc;\n   location_t ident_loc = UNKNOWN_LOCATION;  /* Quiet warning.  */\n   gcc_assert (c_parser_next_token_is_keyword (parser, RID_ENUM));\n@@ -3274,6 +3282,83 @@ c_parser_enum_specifier (c_parser *parser)\n       enum_loc = ident_loc;\n       c_parser_consume_token (parser);\n     }\n+  if (c_parser_next_token_is (parser, CPP_COLON)\n+      /* Distinguish an enum-type-specifier from a bit-field\n+\t declaration of the form \"enum e : constant-expression;\".  */\n+      && c_token_starts_typename (c_parser_peek_2nd_token (parser)))\n+    {\n+      pedwarn_c11 (enum_loc, OPT_Wpedantic,\n+\t\t   \"ISO C does not support specifying %<enum%> underlying \"\n+\t\t   \"types before C2X\");\n+      if (ident)\n+\t{\n+\t  /* The tag is in scope during the enum-type-specifier (which\n+\t     may refer to the tag inside typeof).  */\n+\t  ret = parser_xref_tag (ident_loc, ENUMERAL_TYPE, ident,\n+\t\t\t\t have_std_attrs, std_attrs, true);\n+\t  if (!ENUM_FIXED_UNDERLYING_TYPE_P (ret.spec))\n+\t    error_at (enum_loc, \"%<enum%> declared both with and without \"\n+\t\t      \"fixed underlying type\");\n+\t}\n+      else\n+\t{\n+\t  /* There must be an enum definition, so this initialization\n+\t     (to avoid possible warnings about uninitialized data)\n+\t     will be replaced later (either with the results of that\n+\t     definition, or with the results of error handling for the\n+\t     case of no tag and no definition).  */\n+\t  ret.spec = NULL_TREE;\n+\t  ret.kind = ctsk_tagdef;\n+\t  ret.expr = NULL_TREE;\n+\t  ret.expr_const_operands = true;\n+\t  ret.has_enum_type_specifier = true;\n+\t}\n+      c_parser_consume_token (parser);\n+      struct c_declspecs *specs = build_null_declspecs ();\n+      c_parser_declspecs (parser, specs, false, true, false, false, false,\n+\t\t\t  false, true, cla_prefer_id);\n+      finish_declspecs (specs);\n+      if (specs->default_int_p)\n+\terror_at (enum_loc, \"no %<enum%> underlying type specified\");\n+      else if (TREE_CODE (specs->type) != INTEGER_TYPE\n+\t       && TREE_CODE (specs->type) != BOOLEAN_TYPE)\n+\t{\n+\t  error_at (enum_loc, \"invalid %<enum%> underlying type\");\n+\t  specs->type = integer_type_node;\n+\t}\n+      else if (specs->restrict_p)\n+\terror_at (enum_loc, \"invalid use of %<restrict%>\");\n+      fixed_underlying_type = TYPE_MAIN_VARIANT (specs->type);\n+      if (ident)\n+\t{\n+\t  /* The type specified must be consistent with any previously\n+\t     specified underlying type.  If this is a newly declared\n+\t     type, it is now a complete type.  */\n+\t  if (ENUM_FIXED_UNDERLYING_TYPE_P (ret.spec)\n+\t      && ENUM_UNDERLYING_TYPE (ret.spec) == NULL_TREE)\n+\t    {\n+\t      TYPE_MIN_VALUE (ret.spec) =\n+\t\tTYPE_MIN_VALUE (fixed_underlying_type);\n+\t      TYPE_MAX_VALUE (ret.spec) =\n+\t\tTYPE_MAX_VALUE (fixed_underlying_type);\n+\t      TYPE_UNSIGNED (ret.spec) = TYPE_UNSIGNED (fixed_underlying_type);\n+\t      SET_TYPE_ALIGN (ret.spec, TYPE_ALIGN (fixed_underlying_type));\n+\t      TYPE_SIZE (ret.spec) = NULL_TREE;\n+\t      TYPE_PRECISION (ret.spec) =\n+\t\tTYPE_PRECISION (fixed_underlying_type);\n+\t      ENUM_UNDERLYING_TYPE (ret.spec) = fixed_underlying_type;\n+\t      layout_type (ret.spec);\n+\t    }\n+\t  else if (ENUM_FIXED_UNDERLYING_TYPE_P (ret.spec)\n+\t\t   && !comptypes (fixed_underlying_type,\n+\t\t\t\t  ENUM_UNDERLYING_TYPE (ret.spec)))\n+\t    {\n+\t      error_at (enum_loc, \"%<enum%> underlying type incompatible with \"\n+\t\t\t\"previous declaration\");\n+\t      fixed_underlying_type = ENUM_UNDERLYING_TYPE (ret.spec);\n+\t    }\n+\t}\n+    }\n   if (c_parser_next_token_is (parser, CPP_OPEN_BRACE))\n     {\n       /* Parse an enum definition.  */\n@@ -3284,7 +3369,7 @@ c_parser_enum_specifier (c_parser *parser)\n \t forward order at the end.  */\n       tree values;\n       timevar_push (TV_PARSE_ENUM);\n-      type = start_enum (enum_loc, &the_enum, ident);\n+      type = start_enum (enum_loc, &the_enum, ident, fixed_underlying_type);\n       values = NULL_TREE;\n       c_parser_consume_token (parser);\n       while (true)\n@@ -3368,6 +3453,7 @@ c_parser_enum_specifier (c_parser *parser)\n       ret.kind = ctsk_tagdef;\n       ret.expr = NULL_TREE;\n       ret.expr_const_operands = true;\n+      ret.has_enum_type_specifier = fixed_underlying_type != NULL_TREE;\n       timevar_pop (TV_PARSE_ENUM);\n       return ret;\n     }\n@@ -3378,6 +3464,7 @@ c_parser_enum_specifier (c_parser *parser)\n       ret.kind = ctsk_tagref;\n       ret.expr = NULL_TREE;\n       ret.expr_const_operands = true;\n+      ret.has_enum_type_specifier = false;\n       return ret;\n     }\n   /* Attributes may only appear when the members are defined or in\n@@ -3386,15 +3473,18 @@ c_parser_enum_specifier (c_parser *parser)\n      standard C).  */\n   if (have_std_attrs && c_parser_next_token_is_not (parser, CPP_SEMICOLON))\n     c_parser_error (parser, \"expected %<;%>\");\n-  ret = parser_xref_tag (ident_loc, ENUMERAL_TYPE, ident, have_std_attrs,\n-\t\t\t std_attrs);\n-  /* In ISO C, enumerated types can be referred to only if already\n-     defined.  */\n-  if (pedantic && !COMPLETE_TYPE_P (ret.spec))\n+  if (fixed_underlying_type == NULL_TREE)\n     {\n-      gcc_assert (ident);\n-      pedwarn (enum_loc, OPT_Wpedantic,\n-\t       \"ISO C forbids forward references to %<enum%> types\");\n+      ret = parser_xref_tag (ident_loc, ENUMERAL_TYPE, ident, have_std_attrs,\n+\t\t\t     std_attrs, false);\n+      /* In ISO C, enumerated types without a fixed underlying type\n+\t can be referred to only if already defined.  */\n+      if (pedantic && !COMPLETE_TYPE_P (ret.spec))\n+\t{\n+\t  gcc_assert (ident);\n+\t  pedwarn (enum_loc, OPT_Wpedantic,\n+\t\t   \"ISO C forbids forward references to %<enum%> types\");\n+\t}\n     }\n   return ret;\n }\n@@ -3590,6 +3680,7 @@ c_parser_struct_or_union_specifier (c_parser *parser)\n       ret.kind = ctsk_tagdef;\n       ret.expr = NULL_TREE;\n       ret.expr_const_operands = true;\n+      ret.has_enum_type_specifier = false;\n       timevar_pop (TV_PARSE_STRUCT);\n       return ret;\n     }\n@@ -3600,6 +3691,7 @@ c_parser_struct_or_union_specifier (c_parser *parser)\n       ret.kind = ctsk_tagref;\n       ret.expr = NULL_TREE;\n       ret.expr_const_operands = true;\n+      ret.has_enum_type_specifier = false;\n       return ret;\n     }\n   /* Attributes may only appear when the members are defined or in\n@@ -3608,7 +3700,8 @@ c_parser_struct_or_union_specifier (c_parser *parser)\n     c_parser_error (parser, \"expected %<;%>\");\n   /* ??? Existing practice is that GNU attributes are ignored after\n      the struct or union keyword when not defining the members.  */\n-  ret = parser_xref_tag (ident_loc, code, ident, have_std_attrs, std_attrs);\n+  ret = parser_xref_tag (ident_loc, code, ident, have_std_attrs, std_attrs,\n+\t\t\t false);\n   return ret;\n }\n \n@@ -3817,6 +3910,7 @@ c_parser_typeof_specifier (c_parser *parser)\n   ret.spec = error_mark_node;\n   ret.expr = NULL_TREE;\n   ret.expr_const_operands = true;\n+  ret.has_enum_type_specifier = false;\n   if (c_parser_next_token_is_keyword (parser, RID_TYPEOF))\n     {\n       is_unqual = false;\n@@ -19153,15 +19247,14 @@ c_parser_omp_atomic (location_t loc, c_parser *parser, bool openacc)\n \t  && TREE_CODE (TREE_OPERAND (lhs, 1)) == COMPOUND_EXPR\n \t  && TREE_CODE (TREE_OPERAND (TREE_OPERAND (lhs, 1), 0)) == MODIFY_EXPR\n \t  && TREE_OPERAND (TREE_OPERAND (lhs, 1), 1) == TREE_OPERAND (lhs, 0)\n-\t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (TREE_OPERAND\n-\t\t\t\t\t      (TREE_OPERAND (lhs, 1), 0), 0)))\n-\t     == BOOLEAN_TYPE)\n+\t  && C_BOOLEAN_TYPE_P (TREE_TYPE (TREE_OPERAND (TREE_OPERAND\n+\t\t\t\t\t      (TREE_OPERAND (lhs, 1), 0), 0))))\n \t/* Undo effects of boolean_increment for post {in,de}crement.  */\n \tlhs = TREE_OPERAND (TREE_OPERAND (lhs, 1), 0);\n       /* FALLTHRU */\n     case MODIFY_EXPR:\n       if (TREE_CODE (lhs) == MODIFY_EXPR\n-\t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (lhs, 0))) == BOOLEAN_TYPE)\n+\t  && C_BOOLEAN_TYPE_P (TREE_TYPE (TREE_OPERAND (lhs, 0))))\n \t{\n \t  /* Undo effects of boolean_increment.  */\n \t  if (integer_onep (TREE_OPERAND (lhs, 1)))"}, {"sha": "d787dd4267b1a53bdc74502b1b83c8560f0949be", "filename": "gcc/c/c-tree.h", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0997c14af5e8bc4d26e28549cbce99364a1601f/gcc%2Fc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0997c14af5e8bc4d26e28549cbce99364a1601f/gcc%2Fc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-tree.h?ref=e0997c14af5e8bc4d26e28549cbce99364a1601f", "patch": "@@ -122,6 +122,14 @@ along with GCC; see the file COPYING3.  If not see\n    been folded.  */\n #define SAVE_EXPR_FOLDED_P(EXP)\tTREE_LANG_FLAG_1 (SAVE_EXPR_CHECK (EXP))\n \n+/* Whether a type has boolean semantics: either a boolean type or an\n+   enumeration type with a boolean type as its underlying type.  */\n+#define C_BOOLEAN_TYPE_P(TYPE)\t\t\t\t\t\t\\\n+  (TREE_CODE (TYPE) == BOOLEAN_TYPE\t\t\t\t\t\\\n+   || (TREE_CODE (TYPE) == ENUMERAL_TYPE\t\t\t\t\\\n+       && ENUM_UNDERLYING_TYPE (TYPE) != NULL_TREE\t\t\t\\\n+       && TREE_CODE (ENUM_UNDERLYING_TYPE (TYPE)) == BOOLEAN_TYPE))\n+\n /* Record parser information about an expression that is irrelevant\n    for code generation alongside a tree representing its value.  */\n struct c_expr\n@@ -216,6 +224,10 @@ struct c_typespec {\n   /* Whether the expression has operands suitable for use in constant\n      expressions.  */\n   bool expr_const_operands;\n+  /* Whether the type specifier includes an enum type specifier (that\n+     is, \": specifier-qualifier-list\" in a declaration using\n+     \"enum\").  */\n+  bool has_enum_type_specifier;\n   /* The specifier itself.  */\n   tree spec;\n   /* An expression to be evaluated before the type specifier, in the\n@@ -412,6 +424,12 @@ struct c_declspecs {\n   /* Whether any alignment specifier (even with zero alignment) was\n      specified.  */\n   BOOL_BITFIELD alignas_p : 1;\n+  /* Whether an enum type specifier (\": specifier-qualifier-list\") was\n+     specified other than in a definition of that enum (if so, this is\n+     invalid unless it is an empty declaration \"enum identifier\n+     enum-type-specifier;\", but such an empty declaration is valid in\n+     C2x when \"enum identifier;\" would not be).  */\n+  BOOL_BITFIELD enum_type_specifier_ref_p : 1;\n   /* The address space that the declaration belongs to.  */\n   addr_space_t address_space;\n };\n@@ -525,6 +543,9 @@ struct c_enum_contents\n      constant value.  */\n   tree enum_next_value;\n \n+  /* The enumeration type itself.  */\n+  tree enum_type;\n+\n   /* Nonzero means that there was overflow computing enum_next_value.  */\n   int enum_overflow;\n };\n@@ -625,7 +646,7 @@ extern void c_warn_unused_attributes (tree);\n extern tree c_warn_type_attributes (tree);\n extern void shadow_tag (const struct c_declspecs *);\n extern void shadow_tag_warned (const struct c_declspecs *, int);\n-extern tree start_enum (location_t, struct c_enum_contents *, tree);\n+extern tree start_enum (location_t, struct c_enum_contents *, tree, tree);\n extern bool start_function (struct c_declspecs *, struct c_declarator *, tree);\n extern tree start_decl (struct c_declarator *, struct c_declspecs *, bool,\n \t\t\ttree, location_t * = NULL);\n@@ -637,7 +658,7 @@ extern void temp_store_parm_decls (tree, tree);\n extern void temp_pop_parm_decls (void);\n extern tree xref_tag (enum tree_code, tree);\n extern struct c_typespec parser_xref_tag (location_t, enum tree_code, tree,\n-\t\t\t\t\t  bool, tree);\n+\t\t\t\t\t  bool, tree, bool);\n extern struct c_parm *build_c_parm (struct c_declspecs *, tree,\n \t\t\t\t    struct c_declarator *, location_t);\n extern struct c_declarator *build_attrs_declarator (tree,"}, {"sha": "6c16647cbe312a7ff304c0361d3efb68d6d559ac", "filename": "gcc/c/c-typeck.cc", "status": "modified", "additions": 31, "deletions": 25, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0997c14af5e8bc4d26e28549cbce99364a1601f/gcc%2Fc%2Fc-typeck.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0997c14af5e8bc4d26e28549cbce99364a1601f/gcc%2Fc%2Fc-typeck.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.cc?ref=e0997c14af5e8bc4d26e28549cbce99364a1601f", "patch": "@@ -420,9 +420,11 @@ composite_type (tree t1, tree t2)\n      (DR#013 question 3).  For consistency, use the enumerated type as\n      the composite type.  */\n \n-  if (code1 == ENUMERAL_TYPE && code2 == INTEGER_TYPE)\n+  if (code1 == ENUMERAL_TYPE\n+      && (code2 == INTEGER_TYPE || code2 == BOOLEAN_TYPE))\n     return t1;\n-  if (code2 == ENUMERAL_TYPE && code1 == INTEGER_TYPE)\n+  if (code2 == ENUMERAL_TYPE\n+      && (code1 == INTEGER_TYPE || code1 == BOOLEAN_TYPE))\n     return t2;\n \n   gcc_assert (code1 == code2);\n@@ -1025,9 +1027,9 @@ tree\n common_type (tree t1, tree t2)\n {\n   if (TREE_CODE (t1) == ENUMERAL_TYPE)\n-    t1 = c_common_type_for_size (TYPE_PRECISION (t1), 1);\n+    t1 = ENUM_UNDERLYING_TYPE (t1);\n   if (TREE_CODE (t2) == ENUMERAL_TYPE)\n-    t2 = c_common_type_for_size (TYPE_PRECISION (t2), 1);\n+    t2 = ENUM_UNDERLYING_TYPE (t2);\n \n   /* If both types are BOOLEAN_TYPE, then return boolean_type_node.  */\n   if (TREE_CODE (t1) == BOOLEAN_TYPE\n@@ -1125,7 +1127,7 @@ comptypes_internal (const_tree type1, const_tree type2, bool *enum_and_int_p,\n       && COMPLETE_TYPE_P (t1)\n       && TREE_CODE (t2) != ENUMERAL_TYPE)\n     {\n-      t1 = c_common_type_for_size (TYPE_PRECISION (t1), TYPE_UNSIGNED (t1));\n+      t1 = ENUM_UNDERLYING_TYPE (t1);\n       if (TREE_CODE (t2) != VOID_TYPE)\n \t{\n \t  if (enum_and_int_p != NULL)\n@@ -1138,7 +1140,7 @@ comptypes_internal (const_tree type1, const_tree type2, bool *enum_and_int_p,\n \t   && COMPLETE_TYPE_P (t2)\n \t   && TREE_CODE (t1) != ENUMERAL_TYPE)\n     {\n-      t2 = c_common_type_for_size (TYPE_PRECISION (t2), TYPE_UNSIGNED (t2));\n+      t2 = ENUM_UNDERLYING_TYPE (t2);\n       if (TREE_CODE (t1) != VOID_TYPE)\n \t{\n \t  if (enum_and_int_p != NULL)\n@@ -2193,15 +2195,19 @@ perform_integral_promotions (tree exp)\n \n   gcc_assert (INTEGRAL_TYPE_P (type));\n \n-  /* Normally convert enums to int,\n-     but convert wide enums to something wider.  */\n+  /* Convert enums to the result of applying the integer promotions to\n+     their underlying type.  */\n   if (code == ENUMERAL_TYPE)\n     {\n-      type = c_common_type_for_size (MAX (TYPE_PRECISION (type),\n-\t\t\t\t\t  TYPE_PRECISION (integer_type_node)),\n-\t\t\t\t     ((TYPE_PRECISION (type)\n-\t\t\t\t       >= TYPE_PRECISION (integer_type_node))\n-\t\t\t\t      && TYPE_UNSIGNED (type)));\n+      type = ENUM_UNDERLYING_TYPE (type);\n+      if (c_promoting_integer_type_p (type))\n+\t{\n+\t  if (TYPE_UNSIGNED (type)\n+\t      && TYPE_PRECISION (type) == TYPE_PRECISION (integer_type_node))\n+\t    type = unsigned_type_node;\n+\t  else\n+\t    type = integer_type_node;\n+\t}\n \n       return convert (type, exp);\n     }\n@@ -3932,7 +3938,7 @@ parser_build_binary_op (location_t location, enum tree_code code,\n \t    }\n \t  while (1);\n \t}\n-      if (TREE_CODE (TREE_TYPE (t)) != BOOLEAN_TYPE)\n+      if (!C_BOOLEAN_TYPE_P (TREE_TYPE (t)))\n \twarn_logical_not_parentheses (location, code, arg1.value, arg2.value);\n     }\n \n@@ -4537,7 +4543,7 @@ build_unary_op (location_t location, enum tree_code code, tree xarg,\n \t  while (TREE_CODE (e) == COMPOUND_EXPR)\n \t    e = TREE_OPERAND (e, 1);\n \n-\t  if ((TREE_CODE (TREE_TYPE (arg)) == BOOLEAN_TYPE\n+\t  if ((C_BOOLEAN_TYPE_P (TREE_TYPE (arg))\n \t       || truth_value_p (TREE_CODE (e))))\n \t    {\n \t      auto_diagnostic_group d;\n@@ -4669,7 +4675,7 @@ build_unary_op (location_t location, enum tree_code code, tree xarg,\n \t\t\t\"decrement of enumeration value is invalid in C++\");\n \t}\n \n-      if (TREE_CODE (TREE_TYPE (arg)) == BOOLEAN_TYPE)\n+      if (C_BOOLEAN_TYPE_P (TREE_TYPE (arg)))\n \t{\n \t  if (code == PREINCREMENT_EXPR || code == POSTINCREMENT_EXPR)\n \t    warning_at (location, OPT_Wbool_operation,\n@@ -4831,7 +4837,7 @@ build_unary_op (location_t location, enum tree_code code, tree xarg,\n \t    goto return_build_unary_op;\n \t  }\n \n-\tif (TREE_CODE (TREE_TYPE (arg)) == BOOLEAN_TYPE)\n+\tif (C_BOOLEAN_TYPE_P (TREE_TYPE (arg)))\n \t  val = boolean_increment (code, arg);\n \telse\n \t  val = build2 (code, TREE_TYPE (arg), arg, inc);\n@@ -7087,7 +7093,7 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n \t\t\t\t\t rhstype);\n \n       bool save = in_late_binary_op;\n-      if (codel == BOOLEAN_TYPE || codel == COMPLEX_TYPE\n+      if (C_BOOLEAN_TYPE_P (type) || codel == COMPLEX_TYPE\n \t  || (coder == REAL_TYPE\n \t      && (codel == INTEGER_TYPE || codel == ENUMERAL_TYPE)\n \t      && sanitize_flags_p (SANITIZE_FLOAT_CAST)))\n@@ -7734,7 +7740,7 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n \n       return convert (type, rhs);\n     }\n-  else if (codel == BOOLEAN_TYPE\n+  else if (C_BOOLEAN_TYPE_P (type)\n \t   /* The type nullptr_t may be converted to bool.  The\n \t      result is false.  */\n \t   && (coder == POINTER_TYPE || coder == NULLPTR_TYPE))\n@@ -11002,7 +11008,7 @@ c_finish_return (location_t loc, tree retval, tree origtype)\n \treturn NULL_TREE;\n \n       save = in_late_binary_op;\n-      if (TREE_CODE (TREE_TYPE (res)) == BOOLEAN_TYPE\n+      if (C_BOOLEAN_TYPE_P (TREE_TYPE (res))\n \t  || TREE_CODE (TREE_TYPE (res)) == COMPLEX_TYPE\n \t  || (TREE_CODE (TREE_TYPE (t)) == REAL_TYPE\n \t      && (TREE_CODE (TREE_TYPE (res)) == INTEGER_TYPE\n@@ -11164,7 +11170,7 @@ c_start_switch (location_t switch_loc,\n \t  while (TREE_CODE (e) == COMPOUND_EXPR)\n \t    e = TREE_OPERAND (e, 1);\n \n-\t  if ((TREE_CODE (type) == BOOLEAN_TYPE\n+\t  if ((C_BOOLEAN_TYPE_P (type)\n \t       || truth_value_p (TREE_CODE (e)))\n \t      /* Explicit cast to int suppresses this warning.  */\n \t      && !(TREE_CODE (type) == INTEGER_TYPE\n@@ -12493,9 +12499,9 @@ build_binary_op (location_t location, enum tree_code code,\n       else if (code1 == NULLPTR_TYPE && null_pointer_constant_p (orig_op0))\n \tresult_type = (INTEGRAL_TYPE_P (type0)\n \t\t       ? build_pointer_type (type0) : type0);\n-      if ((TREE_CODE (TREE_TYPE (orig_op0)) == BOOLEAN_TYPE\n+      if ((C_BOOLEAN_TYPE_P (TREE_TYPE (orig_op0))\n \t   || truth_value_p (TREE_CODE (orig_op0)))\n-\t  ^ (TREE_CODE (TREE_TYPE (orig_op1)) == BOOLEAN_TYPE\n+\t  ^ (C_BOOLEAN_TYPE_P (TREE_TYPE (orig_op1))\n \t     || truth_value_p (TREE_CODE (orig_op1))))\n \tmaybe_warn_bool_compare (location, code, orig_op0, orig_op1);\n       break;\n@@ -12638,9 +12644,9 @@ build_binary_op (location_t location, enum tree_code code,\n \t  instrument_expr = build_call_expr_loc (location, tt, 2, op0, op1);\n \t}\n \n-      if ((TREE_CODE (TREE_TYPE (orig_op0)) == BOOLEAN_TYPE\n+      if ((C_BOOLEAN_TYPE_P (TREE_TYPE (orig_op0))\n \t   || truth_value_p (TREE_CODE (orig_op0)))\n-\t  ^ (TREE_CODE (TREE_TYPE (orig_op1)) == BOOLEAN_TYPE\n+\t  ^ (C_BOOLEAN_TYPE_P (TREE_TYPE (orig_op1))\n \t     || truth_value_p (TREE_CODE (orig_op1))))\n \tmaybe_warn_bool_compare (location, code, orig_op0, orig_op1);\n       break;"}, {"sha": "6d84514e4c0f30dd6859d9e1ec75e275e955eb16", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0997c14af5e8bc4d26e28549cbce99364a1601f/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0997c14af5e8bc4d26e28549cbce99364a1601f/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=e0997c14af5e8bc4d26e28549cbce99364a1601f", "patch": "@@ -4507,30 +4507,6 @@ get_vec_init_expr (tree t)\n #define OPAQUE_ENUM_P(TYPE)\t\t\t\t\\\n   (TREE_CODE (TYPE) == ENUMERAL_TYPE && ENUM_IS_OPAQUE (TYPE))\n \n-/* Determines whether an ENUMERAL_TYPE has an explicit\n-   underlying type.  */\n-#define ENUM_FIXED_UNDERLYING_TYPE_P(NODE) (TYPE_LANG_FLAG_5 (NODE))\n-\n-/* Returns the underlying type of the given enumeration type. The\n-   underlying type is determined in different ways, depending on the\n-   properties of the enum:\n-\n-     - In C++0x, the underlying type can be explicitly specified, e.g.,\n-\n-         enum E1 : char { ... } // underlying type is char\n-\n-     - In a C++0x scoped enumeration, the underlying type is int\n-       unless otherwises specified:\n-\n-         enum class E2 { ... } // underlying type is int\n-\n-     - Otherwise, the underlying type is determined based on the\n-       values of the enumerators. In this case, the\n-       ENUM_UNDERLYING_TYPE will not be set until after the definition\n-       of the enumeration is completed by finish_enum.  */\n-#define ENUM_UNDERLYING_TYPE(TYPE) \\\n-  TREE_TYPE (ENUMERAL_TYPE_CHECK (TYPE))\n-\n /* [dcl.init.aggr]\n \n    An aggregate is an array or a class with no user-provided"}, {"sha": "57dd92a687abbcb824107dafbc5ab0261e80a6e9", "filename": "gcc/testsuite/gcc.dg/c11-enum-4.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0997c14af5e8bc4d26e28549cbce99364a1601f/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-enum-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0997c14af5e8bc4d26e28549cbce99364a1601f/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-enum-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-enum-4.c?ref=e0997c14af5e8bc4d26e28549cbce99364a1601f", "patch": "@@ -0,0 +1,7 @@\n+/* Test C2x enumerations with fixed underlying type are diagnosed for C11.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c11 -pedantic-errors\" } */\n+\n+enum e1 : int; /* { dg-error \"ISO C does not support specifying 'enum' underlying types\" } */\n+enum e2 : short { A }; /* { dg-error \"ISO C does not support specifying 'enum' underlying types\" } */\n+enum : short { B }; /* { dg-error \"ISO C does not support specifying 'enum' underlying types\" } */"}, {"sha": "91d681f21fefdb3a4693897c4d3f10d61e69ea2b", "filename": "gcc/testsuite/gcc.dg/c11-enum-5.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0997c14af5e8bc4d26e28549cbce99364a1601f/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-enum-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0997c14af5e8bc4d26e28549cbce99364a1601f/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-enum-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-enum-5.c?ref=e0997c14af5e8bc4d26e28549cbce99364a1601f", "patch": "@@ -0,0 +1,7 @@\n+/* Test C2x enumerations with fixed underlying type are diagnosed for C11.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c11 -pedantic\" } */\n+\n+enum e1 : int; /* { dg-warning \"ISO C does not support specifying 'enum' underlying types\" } */\n+enum e2 : short { A }; /* { dg-warning \"ISO C does not support specifying 'enum' underlying types\" } */\n+enum : short { B }; /* { dg-warning \"ISO C does not support specifying 'enum' underlying types\" } */"}, {"sha": "cd708bd7c5847767525a4c91ce7ef8fc881805f0", "filename": "gcc/testsuite/gcc.dg/c11-enum-6.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0997c14af5e8bc4d26e28549cbce99364a1601f/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-enum-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0997c14af5e8bc4d26e28549cbce99364a1601f/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-enum-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-enum-6.c?ref=e0997c14af5e8bc4d26e28549cbce99364a1601f", "patch": "@@ -0,0 +1,8 @@\n+/* Test C2x enumerations with fixed underlying type are not diagnosed for C11\n+   with -pedantic-errors -Wno-c11-c2x-compat.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c11 -pedantic-errors -Wno-c11-c2x-compat\" } */\n+\n+enum e1 : int;\n+enum e2 : short { A };\n+enum : short { B };"}, {"sha": "5ab9694302fa03a01edd81c80a828352a5002df3", "filename": "gcc/testsuite/gcc.dg/c2x-enum-6.c", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0997c14af5e8bc4d26e28549cbce99364a1601f/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-enum-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0997c14af5e8bc4d26e28549cbce99364a1601f/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-enum-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-enum-6.c?ref=e0997c14af5e8bc4d26e28549cbce99364a1601f", "patch": "@@ -0,0 +1,167 @@\n+/* Test C2x enumerations with fixed underlying type.  Valid code.  */\n+/* { dg-do run } */\n+/* { dg-options \"-std=c2x -pedantic-errors\" } */\n+\n+/* Check a type while defining an enum (via a diagnostic for incompatible\n+   pointer types if the wrong type was chosen).  */\n+#define TYPE_CHECK(cst, type)\t\t\t\t\t\t\\\n+  cst ## _type_check = sizeof (1 ? (type *) 0 : (typeof (cst) *) 0)\n+\n+extern int i;\n+\n+enum e1 : short { e1a = __SHRT_MAX__,\n+    TYPE_CHECK (e1a, short),\n+    e1z = (long long) 0,\n+    TYPE_CHECK (e1z, enum e1),\n+    e1b = -__SHRT_MAX__ - 1,\n+    e1c,\n+    TYPE_CHECK (e1c, enum e1) };\n+extern enum e1 e1v;\n+extern typeof (e1a) e1v;\n+extern typeof (e1b) e1v;\n+extern typeof (e1c) e1v;\n+extern typeof (e1z) e1v;\n+extern short e1v;\n+static_assert (e1a == __SHRT_MAX__);\n+static_assert (e1b == -__SHRT_MAX__ - 1);\n+static_assert (e1c == -__SHRT_MAX__);\n+static_assert (e1a > 0);\n+static_assert (e1b < 0);\n+static_assert (e1c < 0);\n+static_assert (e1z == 0);\n+extern typeof (+e1v) i;\n+extern typeof (+e1a) i;\n+extern typeof (e1a + e1b) i;\n+enum e1 : short;\n+enum e1 : volatile short;\n+enum e1 : _Atomic short;\n+enum e1 : typeof (short);\n+\n+enum e2 : bool { b0, b1, b0a = 0, b1a = 1 };\n+extern enum e2 e2v;\n+extern typeof (b0) e2v;\n+extern typeof (b0a) e2v;\n+extern typeof (b1) e2v;\n+extern typeof (b1a) e2v;\n+extern bool e2v;\n+extern typeof (+e2v) i;\n+extern typeof (+b0) i;\n+static_assert (b0 == 0);\n+static_assert (b1 == 1);\n+static_assert (b0a == 0);\n+static_assert (b1a == 1);\n+\n+enum e3 : volatile const _Atomic unsigned short;\n+enum e3 : unsigned short { e3a, e3b };\n+extern enum e3 e3v;\n+extern typeof (e3a) e3v;\n+extern typeof (e3b) e3v;\n+extern unsigned short e3v;\n+\n+/* The enum type is complete from the end of the first enum type specifier\n+   (which is nested inside another enum type specifier in this example).  */\n+enum e4 : typeof ((enum e4 : long { e4a = sizeof (enum e4) })0, 0L);\n+extern enum e4 e4v;\n+extern typeof (e4a) e4v;\n+extern long e4v;\n+\n+enum e5 : unsigned int;\n+extern enum e5 e5v;\n+extern typeof (e5v + e5v) e5v;\n+extern unsigned int e5v;\n+\n+enum : unsigned short { e6a, e6b, TYPE_CHECK (e6a, unsigned short) } e6v;\n+extern typeof (e6a) e6v;\n+extern typeof (e6b) e6v;\n+extern unsigned short e6v;\n+\n+struct s1;\n+struct s2 { int a; };\n+union u1;\n+union u2 { int a; };\n+enum xe1 { XE1 };\n+enum xe2 : long long { XE2 };\n+enum xe3 : unsigned long;\n+\n+void\n+f ()\n+{\n+  /* Tags can be redeclared in an inner scope.  */\n+  enum s1 : char;\n+  enum s2 : int { S2 };\n+  enum u1 : long { U1 };\n+  enum u2 : unsigned char;\n+  enum xe1 : long long;\n+  enum xe2 : short;\n+  enum xe3 : char { XE3 };\n+  static_assert (sizeof (enum xe3) == 1);\n+  static_assert (sizeof (enum xe2) == sizeof (short));\n+  static_assert (sizeof (enum xe1) == sizeof (long long));\n+}\n+\n+void *p;\n+typeof (nullptr) np;\n+\n+extern void abort (void);\n+extern void exit (int);\n+\n+int\n+main ()\n+{\n+  /* Conversions to enums with fixed underlying type have the same semantics as\n+     converting to the underlying type.  */\n+  volatile enum e1 e1vm;\n+  volatile enum e2 e2vm;\n+  e1vm = __LONG_LONG_MAX__; /* { dg-warning \"overflow\" } */\n+  if (e1vm != (short) __LONG_LONG_MAX__)\n+    abort ();\n+  e2vm = 10;\n+  if (e2vm != 1)\n+    abort ();\n+  e2vm = 0;\n+  if (e2vm != 0)\n+    abort ();\n+  /* Arithmetic on enums with fixed underlying type has the same semantics as\n+     arithmetic on the underlying type; in particular, the special semantics\n+     for bool apply to enums with bool as fixed underlying type.  */\n+  if (e2vm++ != 0)\n+    abort ();\n+  if (e2vm != 1)\n+    abort ();\n+  if (e2vm++ != 1)\n+    abort ();\n+  if (e2vm != 1)\n+    abort ();\n+  if (e2vm-- != 1)\n+    abort ();\n+  if (e2vm != 0)\n+    abort ();\n+  if (e2vm-- != 0)\n+    abort ();\n+  if (e2vm != 1)\n+    abort ();\n+  if (++e2vm != 1)\n+    abort ();\n+  if (e2vm != 1)\n+    abort ();\n+  e2vm = 0;\n+  if (++e2vm != 1)\n+    abort ();\n+  if (e2vm != 1)\n+    abort ();\n+  if (--e2vm != 0)\n+    abort ();\n+  if (e2vm != 0)\n+    abort ();\n+  if (--e2vm != 1)\n+    abort ();\n+  if (e2vm != 1)\n+    abort ();\n+  e2vm = p;\n+  e2vm = np;\n+  e2vm = (bool) p;\n+  e2vm = (bool) np;\n+  if (e2vm != 0)\n+    abort ();\n+  exit (0);\n+}"}, {"sha": "08bae31d82ca6d027c27bf6245e7b897b9459403", "filename": "gcc/testsuite/gcc.dg/c2x-enum-7.c", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0997c14af5e8bc4d26e28549cbce99364a1601f/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-enum-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0997c14af5e8bc4d26e28549cbce99364a1601f/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-enum-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-enum-7.c?ref=e0997c14af5e8bc4d26e28549cbce99364a1601f", "patch": "@@ -0,0 +1,97 @@\n+/* Test C2x enumerations with fixed underlying type.  Invalid code.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c2x -pedantic-errors\" } */\n+\n+/* An enum type specifier may only be used when the enum is defined, or in a\n+   declaration of the form \"enum name enum-type-specifier;\".  */\n+extern enum e1 : int; /* { dg-error \"storage class specifier in empty declaration with 'enum' underlying type\" } */\n+_Thread_local enum e2 : short; /* { dg-error \"'_Thread_local' in empty declaration with 'enum' underlying type\" } */\n+const enum e3 : long; /* { dg-error \"type qualifier in empty declaration with 'enum' underlying type\" } */\n+alignas (8) enum e4 : long; /* { dg-error \"'alignas' in empty declaration with 'enum' underlying type\" } */\n+inline enum e5 : unsigned; /* { dg-error \"'inline' in empty declaration\" } */\n+_Noreturn enum e6 : unsigned; /* { dg-error \"'_Noreturn' in empty declaration\" } */\n+auto enum e7 : unsigned; /* { dg-error \"'auto' in file-scope empty declaration\" } */\n+register enum e8 : unsigned; /* { dg-error \"'register' in file-scope empty declaration\" } */\n+\n+/* When the enum is defined, some extra declaration specifiers are permitted,\n+   but diagnosed as useless.  */\n+extern enum e9 : int { E9 }; /* { dg-warning \"useless storage class specifier in empty declaration\" } */\n+_Thread_local enum e10 : short { E10 }; /* { dg-warning \"useless '_Thread_local' in empty declaration\" } */\n+const enum e11 : long { E11 }; /* { dg-warning \"useless type qualifier in empty declaration\" } */\n+alignas (8) enum e12 : long { E12 }; /* { dg-warning \"useless '_Alignas' in empty declaration\" } */\n+\n+/* Nothing else may be declared with an enum type specifier for an enum not\n+   being defined in that declaration.  */\n+enum e13 : short x13; /* { dg-error \"'enum' underlying type may not be specified here\" } */\n+enum e14 : short f14 (); /* { dg-error \"'enum' underlying type may not be specified here\" } */\n+typeof (enum e15 : long) x15; /* { dg-error \"'enum' underlying type may not be specified here\" } */\n+int f16 (enum e16 : char p); /* { dg-error \"'enum' underlying type may not be specified here\" } */\n+/* { dg-warning \"will not be visible outside of this definition or declaration\" \"warning\" { target *-*-* } .-1 } */\n+int f17 (enum e17 : char); /* { dg-error \"'enum' underlying type may not be specified here\" } */\n+/* { dg-warning \"will not be visible outside of this definition or declaration\" \"warning\" { target *-*-* } .-1 } */\n+struct s18 { enum e18 : int x; }; /* { dg-error \"'enum' underlying type may not be specified here\" } */\n+\n+/* But those are OK if the enum content is defined.  */\n+enum e19 : short { E19 } x19;\n+enum e20 : long { E20 } f20 ();\n+typeof (enum e21 : long { E21 }) x21;\n+int f22 (enum e22 : long long { E22 } p); /* { dg-warning \"will not be visible outside of this definition or declaration\" } */\n+int f23 (enum e23 : long long { E23 } p); /* { dg-warning \"will not be visible outside of this definition or declaration\" } */\n+struct s24 { enum e24 : int { E24 } x; };\n+\n+/* Incompatible kinds of tags in the same scope are errors.  */\n+struct s25;\n+enum s25 : int; /* { dg-error \"wrong kind of tag\" } */\n+struct s26;\n+enum s26 : int { E26 }; /* { dg-error \"wrong kind of tag\" } */\n+struct s27 { int x; };\n+enum s27 : int; /* { dg-error \"wrong kind of tag\" } */\n+struct s28 { int x; };\n+enum s28 : int { E28 }; /* { dg-error \"wrong kind of tag\" } */\n+union u29;\n+enum u29 : int; /* { dg-error \"wrong kind of tag\" } */\n+union u30;\n+enum u30 : int { E30 }; /* { dg-error \"wrong kind of tag\" } */\n+union u31 { int x; };\n+enum u31 : int; /* { dg-error \"wrong kind of tag\" } */\n+union u32 { int x; };\n+enum u32 : int { E32 }; /* { dg-error \"wrong kind of tag\" } */\n+\n+/* If an enum has a fixed underlying type, that must be given when defining the\n+   enum.  */\n+enum e33 : short;\n+enum e33 { E33 }; /* { dg-error \"'enum' declared with but defined without fixed underlying type\" } */\n+\n+/* An enum defined without a fixed underlying type cannot then be declared with\n+   one.  */\n+enum e34 { E34A = -__INT_MAX__, E34B = __INT_MAX__ };\n+enum e34 : int; /* { dg-error \"'enum' declared both with and without fixed underlying type\" } */\n+\n+/* An enum with a fixed underlying type cannot be declared with an incompatible\n+   fixed underlying type.  */\n+enum e35 : int;\n+enum e35 : unsigned int; /* { dg-error \"'enum' underlying type incompatible with previous declaration\" } */\n+enum e36 : int;\n+enum e36 : unsigned int { E36 }; /* { dg-error \"'enum' underlying type incompatible with previous declaration\" } */\n+enum e37 : unsigned int { E37 };\n+enum e37 : int; /* { dg-error \"'enum' underlying type incompatible with previous declaration\" } */\n+\n+/* Enumeration constants must fit in the fixed underlying type.  */\n+enum e38 : unsigned char { E38 = (unsigned long long)((unsigned char) -1) + 1 }; /* { dg-error \"enumerator value outside the range of underlying type\" } */\n+enum e39 : unsigned int { E39 = -1 }; /* { dg-error \"enumerator value outside the range of underlying type\" } */\n+enum e40 : int { E40 = __INT_MAX__, E40A }; /* { dg-error \"overflow in enumeration values\" } */\n+enum e41 : unsigned int { E41 = (unsigned int) -1, E41A }; /* { dg-error \"overflow in enumeration values\" } */\n+enum e42 : bool { E42 = 2 }; /* { dg-error \"enumerator value outside the range of underlying type\" } */\n+enum e43 : bool { E43 = 1, E43A }; /* { dg-error \"overflow in enumeration values\" } */\n+\n+/* The underlying type must be an integer type, not itself an enum (or\n+   bit-precise) type.  */\n+enum e44 : double; /* { dg-error \"invalid 'enum' underlying type\" } */\n+typedef int T;\n+enum e45 : T;\n+typedef int *TP;\n+enum e46 : TP; /* { dg-error \"invalid 'enum' underlying type\" } */\n+enum e47 : enum e45; /* { dg-error \"invalid 'enum' underlying type\" } */\n+enum e48 : const; /* { dg-error \"no 'enum' underlying type specified\" } */\n+/* 'restrict' is not valid on integer types.  */\n+enum e49 : int restrict; /* { dg-error \"invalid use of 'restrict'\" } */"}, {"sha": "f7757fc3326689d38de0fbc64df33d8bc24024b4", "filename": "gcc/testsuite/gcc.dg/c2x-enum-8.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0997c14af5e8bc4d26e28549cbce99364a1601f/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-enum-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0997c14af5e8bc4d26e28549cbce99364a1601f/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-enum-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-enum-8.c?ref=e0997c14af5e8bc4d26e28549cbce99364a1601f", "patch": "@@ -0,0 +1,7 @@\n+/* Test C2x enumerations with fixed underlying type.  Test -Wc11-c2x-compat\n+   warnings.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c2x -pedantic-errors -Wc11-c2x-compat\" } */\n+\n+enum e1 : int; /* { dg-warning \"ISO C does not support specifying 'enum' underlying types before\" } */\n+enum e2 : short { E2 }; /* { dg-warning \"ISO C does not support specifying 'enum' underlying types before\" } */"}, {"sha": "b72ed7380e99ddde1014ae9daa9f58ba93855028", "filename": "gcc/testsuite/gcc.dg/gnu2x-enum-1.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0997c14af5e8bc4d26e28549cbce99364a1601f/gcc%2Ftestsuite%2Fgcc.dg%2Fgnu2x-enum-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0997c14af5e8bc4d26e28549cbce99364a1601f/gcc%2Ftestsuite%2Fgcc.dg%2Fgnu2x-enum-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgnu2x-enum-1.c?ref=e0997c14af5e8bc4d26e28549cbce99364a1601f", "patch": "@@ -0,0 +1,11 @@\n+/* Test C2x enumerations with fixed underlying type together with GNU\n+   extensions: an enum cannot be forward declared without a fixed underlying\n+   type and then declared or defined with one.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=gnu2x\" } */\n+\n+enum e1;\n+enum e1 : int; /* { dg-error \"'enum' declared both with and without fixed underlying type\" } */\n+\n+enum e2;\n+enum e2 : long { A }; /* { dg-error \"'enum' declared both with and without fixed underlying type\" } */"}]}