{"sha": "8180951683d7cb893419b5a8e720cbbf36366606", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODE4MDk1MTY4M2Q3Y2I4OTM0MTliNWE4ZTcyMGNiYmYzNjM2NjYwNg==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2005-11-09T11:47:30Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2005-11-09T11:47:30Z"}, "message": "boost_shared_ptr.h: Trivial formatting fixes.\n\n2005-11-09  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/tr1/boost_shared_ptr.h: Trivial formatting fixes.\n\nFrom-SVN: r106689", "tree": {"sha": "fbe60f4451144a0cf2482577f02e58cef1181509", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fbe60f4451144a0cf2482577f02e58cef1181509"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8180951683d7cb893419b5a8e720cbbf36366606", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8180951683d7cb893419b5a8e720cbbf36366606", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8180951683d7cb893419b5a8e720cbbf36366606", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8180951683d7cb893419b5a8e720cbbf36366606/comments", "author": null, "committer": null, "parents": [{"sha": "fb3712f61f4ecb0fca8738013f68f75b901a33b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb3712f61f4ecb0fca8738013f68f75b901a33b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb3712f61f4ecb0fca8738013f68f75b901a33b4"}], "stats": {"total": 376, "additions": 187, "deletions": 189}, "files": [{"sha": "60bcb2000ba08e07887d6111a963a3652cf20935", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8180951683d7cb893419b5a8e720cbbf36366606/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8180951683d7cb893419b5a8e720cbbf36366606/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=8180951683d7cb893419b5a8e720cbbf36366606", "patch": "@@ -1,3 +1,7 @@\n+2005-11-09  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/tr1/boost_shared_ptr.h: Trivial formatting fixes.\n+\n 2005-11-08  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* testsuite/lib/libstdc++.exp (check_v3_target_debug_mode): Use"}, {"sha": "345e17f8785f9075b4fe7dd85ff7a88afaf1398d", "filename": "libstdc++-v3/include/tr1/boost_shared_ptr.h", "status": "modified", "additions": 183, "deletions": 189, "changes": 372, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8180951683d7cb893419b5a8e720cbbf36366606/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fboost_shared_ptr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8180951683d7cb893419b5a8e720cbbf36366606/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fboost_shared_ptr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fboost_shared_ptr.h?ref=8180951683d7cb893419b5a8e720cbbf36366606", "patch": "@@ -64,10 +64,9 @@ class bad_weak_ptr : public std::exception\n {\n public:\n \n-  virtual char const* what() const throw()\n-  {\n-    return \"tr1::bad_weak_ptr\";\n-  }\n+  virtual char const*\n+  what() const throw()\n+  { return \"tr1::bad_weak_ptr\"; }\n };\n \n // Helper for exception objects in <tr1/memory>\n@@ -83,7 +82,7 @@ __throw_bad_weak_ptr()\n }\n \n \n-template <typename _Tp>\n+template<typename _Tp>\n   struct _Sp_deleter\n   {\n     typedef void result_type;\n@@ -140,22 +139,22 @@ class _Sp_counted_base\n   {\n     __gnu_cxx::lock lock(_M_mutex);\n     if (__gnu_cxx::__exchange_and_add(&_M_use_count, 1) == 0)\n-    {\n-      _M_use_count = 0;\n-      __throw_bad_weak_ptr();\n-    }\n+      {\n+\t_M_use_count = 0;\n+\t__throw_bad_weak_ptr();\n+      }\n   }\n \n   void\n   release() // nothrow\n   {\n     if (__gnu_cxx::__exchange_and_add(&_M_use_count, -1) == 1)\n-    {\n-      dispose();\n-      __glibcxx_mutex_lock(_M_mutex);\n-      __glibcxx_mutex_unlock(_M_mutex);\n-      weak_release();\n-    }\n+      {\n+\tdispose();\n+\t__glibcxx_mutex_lock(_M_mutex);\n+\t__glibcxx_mutex_unlock(_M_mutex);\n+\tweak_release();\n+      }\n   }\n \n   void\n@@ -168,11 +167,11 @@ class _Sp_counted_base\n   weak_release() // nothrow\n   {\n     if (__gnu_cxx::__exchange_and_add(&_M_weak_count, -1) == 1)\n-    {\n-      __glibcxx_mutex_lock(_M_mutex);\n-      __glibcxx_mutex_unlock(_M_mutex);\n-      destroy();\n-    }\n+      {\n+\t__glibcxx_mutex_lock(_M_mutex);\n+\t__glibcxx_mutex_unlock(_M_mutex);\n+\tdestroy();\n+      }\n   }\n \n   long\n@@ -184,45 +183,46 @@ class _Sp_counted_base\n private:\n \n   _Sp_counted_base(_Sp_counted_base const&);\n-  _Sp_counted_base& operator= (_Sp_counted_base const&);\n+  _Sp_counted_base& operator=(_Sp_counted_base const&);\n \n   _Atomic_word _M_use_count;        // #shared\n   _Atomic_word _M_weak_count;       // #weak + (#shared != 0)\n   __gnu_cxx::mutex_type _M_mutex;\n };\n \n-template <typename _Ptr, typename _Deleter>\n-class _Sp_counted_base_impl : public _Sp_counted_base\n-{\n-public:\n-\n-  /**\n-   *  @brief   \n-   *  @pre     d(p) must not throw.\n-   */\n-  _Sp_counted_base_impl(_Ptr __p, _Deleter __d)\n-  : _M_ptr(__p), _M_del(__d)\n-  { }\n-\n-  virtual void\n-  dispose() // nothrow\n-  {\n-    _M_del(_M_ptr);\n-  }\n-\n-  virtual void*\n-  get_deleter(const std::type_info& __ti)\n+template<typename _Ptr, typename _Deleter>\n+  class _Sp_counted_base_impl\n+  : public _Sp_counted_base\n   {\n-    return __ti == typeid(_Deleter) ? &_M_del : 0;\n-  }\n-\n-private:\n-  _Sp_counted_base_impl(const _Sp_counted_base_impl&);\n-  _Sp_counted_base_impl& operator=(const _Sp_counted_base_impl&);\n+  public:\n \n-  _Ptr     _M_ptr; // copy constructor must not throw\n-  _Deleter _M_del; // copy constructor must not throw\n-};\n+    /**\n+     *  @brief   \n+     *  @pre     d(p) must not throw.\n+     */\n+    _Sp_counted_base_impl(_Ptr __p, _Deleter __d)\n+    : _M_ptr(__p), _M_del(__d)\n+    { }\n+    \n+    virtual void\n+    dispose() // nothrow\n+    {\n+      _M_del(_M_ptr);\n+    }\n+    \n+    virtual void*\n+    get_deleter(const std::type_info& __ti)\n+    {\n+      return __ti == typeid(_Deleter) ? &_M_del : 0;\n+    }\n+    \n+  private:\n+    _Sp_counted_base_impl(const _Sp_counted_base_impl&);\n+    _Sp_counted_base_impl& operator=(const _Sp_counted_base_impl&);\n+    \n+    _Ptr     _M_ptr; // copy constructor must not throw\n+    _Deleter _M_del; // copy constructor must not throw\n+  };\n \n class weak_count;\n \n@@ -240,28 +240,27 @@ class shared_count\n   : _M_pi(0) // nothrow\n   { }\n \n-  template <typename _Ptr, typename _Deleter>\n+  template<typename _Ptr, typename _Deleter>\n     shared_count(_Ptr __p, _Deleter __d)\n     : _M_pi(0)\n     {\n       try\n-      {\n-        _M_pi = new _Sp_counted_base_impl<_Ptr, _Deleter>(__p, __d);\n-      }\n+\t{\n+\t  _M_pi = new _Sp_counted_base_impl<_Ptr, _Deleter>(__p, __d);\n+\t}\n       catch(...)\n-      {\n-        __d(__p); // delete __p\n-        __throw_exception_again;\n-      }\n+\t{\n+\t  __d(__p); // delete __p\n+\t  __throw_exception_again;\n+\t}\n     }\n \n   // auto_ptr<_Tp> is special cased to provide the strong guarantee\n \n-  template <typename _Tp>\n+  template<typename _Tp>\n     explicit shared_count(std::auto_ptr<_Tp>& __r)\n-    : _M_pi(new _Sp_counted_base_impl<_Tp*,_Sp_deleter<_Tp> >(\n-            __r.get(), _Sp_deleter<_Tp>()\n-            ))\n+    : _M_pi(new _Sp_counted_base_impl<_Tp*,\n+\t    _Sp_deleter<_Tp> >(__r.get(), _Sp_deleter<_Tp>()))\n     { __r.release(); }\n \n   // throws bad_weak_ptr when __r.use_count() == 0\n@@ -286,13 +285,13 @@ class shared_count\n     _Sp_counted_base* __tmp = __r._M_pi;\n \n     if(__tmp != _M_pi)\n-    {\n-      if(__tmp != 0)\n-        __tmp->add_ref_copy();\n-      if(_M_pi != 0)\n-        _M_pi->release();\n-      _M_pi = __tmp;\n-    }\n+      {\n+\tif(__tmp != 0)\n+\t  __tmp->add_ref_copy();\n+\tif(_M_pi != 0)\n+\t  _M_pi->release();\n+\t_M_pi = __tmp;\n+      }\n     return *this;\n   }\n \n@@ -411,58 +410,52 @@ shared_count::shared_count(const weak_count& __r)\n : _M_pi(__r._M_pi)\n {\n   if (_M_pi != 0)\n-  {\n     _M_pi->add_ref_lock();\n-  }\n   else\n-  {\n     __throw_bad_weak_ptr();\n-  }\n }\n \n // fwd decls\n-template <typename _Tp> class weak_ptr;\n-template <typename _Tp> class enable_shared_from_this;\n+template<typename _Tp>\n+  class weak_ptr;\n+\n+template<typename _Tp>\n+  class enable_shared_from_this;\n \n struct __static_cast_tag {};\n struct __const_cast_tag {};\n struct __dynamic_cast_tag {};\n struct __polymorphic_cast_tag {};\n \n-template<class _Tp> struct shared_ptr_traits\n-{\n-    typedef _Tp & reference;\n-};\n+template<class _Tp>\n+  struct shared_ptr_traits\n+  { typedef _Tp& reference; };\n \n-template<> struct shared_ptr_traits<void>\n-{\n-    typedef void reference;\n-};\n+template<>\n+  struct shared_ptr_traits<void>\n+  { typedef void reference; };\n \n-template<> struct shared_ptr_traits<void const>\n-{\n-    typedef void reference;\n-};\n+template<>\n+  struct shared_ptr_traits<void const>\n+  { typedef void reference; };\n \n-template<> struct shared_ptr_traits<void volatile>\n-{\n-    typedef void reference;\n-};\n+template<>\n+  struct shared_ptr_traits<void volatile>\n+  { typedef void reference; };\n \n-template<> struct shared_ptr_traits<void const volatile>\n-{\n-    typedef void reference;\n-};\n+template<>\n+  struct shared_ptr_traits<void const volatile>\n+  { typedef void reference; };\n \n \n // enable_shared_from_this support\n \n // friend of enable_shared_from_this\n-template <typename _Tp1, typename _Tp2>\n+template<typename _Tp1, typename _Tp2>\n   void\n-  __enable_shared_from_this( const shared_count& __pn,\n-                             const enable_shared_from_this<_Tp1>* __pe,\n-                             const _Tp2* __px );\n+  __enable_shared_from_this(const shared_count& __pn,\n+                            const enable_shared_from_this<_Tp1>* __pe,\n+                            const _Tp2* __px );\n \n inline void\n __enable_shared_from_this(const shared_count&, ...)\n@@ -476,7 +469,7 @@ __enable_shared_from_this(const shared_count&, ...)\n  *  is destroyed or reset.\n  */\n \n-template <typename _Tp>\n+template<typename _Tp>\n   class shared_ptr\n   {\n     typedef typename shared_ptr_traits<_Tp>::reference _Reference;\n@@ -488,15 +481,16 @@ template <typename _Tp>\n     /** @brief  Construct an empty %shared_ptr.\n      *  @post   use_count()==0 && get()==0\n      */\n-    shared_ptr() : _M_ptr(0), _M_refcount() // never throws\n+    shared_ptr()\n+    : _M_ptr(0), _M_refcount() // never throws\n     { }\n \n     /** @brief  Construct a %shared_ptr that owns the pointer @a p.\n      *  @param  p  A pointer that is convertible to element_type*.\n-     *  @post   use_count()==1 && get()==p\n+     *  @post   use_count() == 1 && get() == p\n      *  @throw  std::bad_alloc, in which case @c delete @a p is called.\n      */\n-    template <typename _Tp1>\n+    template<typename _Tp1>\n       explicit shared_ptr(_Tp1* __p)\n       : _M_ptr(__p), _M_refcount(__p, _Sp_deleter<_Tp1>())\n       {\n@@ -515,10 +509,10 @@ template <typename _Tp>\n      *          and the deleter @a d.\n      *  @param  p  A pointer.\n      *  @param  d  A deleter.\n-     *  @post   use_count()==1 && get()==p\n+     *  @post   use_count() == 1 && get() == p\n      *  @throw  std::bad_alloc, in which case @a d(p) is called.\n      */\n-    template <typename _Tp1, typename _Deleter>\n+    template<typename _Tp1, typename _Deleter>\n       shared_ptr(_Tp1* __p, _Deleter __d)\n       : _M_ptr(__p), _M_refcount(__p, __d)\n       {\n@@ -533,10 +527,10 @@ template <typename _Tp>\n     /** @brief  If @a r is empty, constructs an empty %shared_ptr; otherwise\n      *          construct a %shared_ptr that shares ownership with @a r.\n      *  @param  r  A %shared_ptr.\n-     *  @post   get()==r.get() && use_count()==r.use_count()\n+     *  @post   get() == r.get() && use_count() == r.use_count()\n      *  @throw  std::bad_alloc, in which case \n      */\n-    template <typename _Tp1>\n+    template<typename _Tp1>\n       shared_ptr(const shared_ptr<_Tp1>& __r)\n       : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount) // never throws\n       {\n@@ -546,11 +540,11 @@ template <typename _Tp>\n     /** @brief  Constructs a %shared_ptr that shares ownership with @a r\n      *          and stores a copy of the pointer stored in @a r.\n      *  @param  r  A weak_ptr.\n-     *  @post   use_count()==r.use_count()\n+     *  @post   use_count() == r.use_count()\n      *  @throw  bad_weak_ptr when r.expired(),\n      *          in which case the constructor has no effect.\n      */\n-    template <typename _Tp1>\n+    template<typename _Tp1>\n       explicit shared_ptr(const weak_ptr<_Tp1>& __r)\n       : _M_refcount(__r._M_refcount) // may throw\n       {\n@@ -561,9 +555,9 @@ template <typename _Tp>\n       }\n \n     /**\n-     * @post use_count()==1 and r.get()==0\n+     * @post use_count() == 1 and r.get() == 0\n      */\n-    template <typename _Tp1>\n+    template<typename _Tp1>\n       explicit shared_ptr(std::auto_ptr<_Tp1>& __r)\n       : _M_ptr(__r.get()), _M_refcount()\n       {\n@@ -575,30 +569,28 @@ template <typename _Tp>\n         __enable_shared_from_this( _M_refcount, __tmp, __tmp );\n       }\n \n-    template <typename _Tp1>\n+    template<typename _Tp1>\n       shared_ptr(const shared_ptr<_Tp1>& __r, __static_cast_tag)\n-      : _M_ptr(static_cast<element_type*>(__r._M_ptr))\n-      , _M_refcount(__r._M_refcount)\n+      : _M_ptr(static_cast<element_type*>(__r._M_ptr)),\n+\t_M_refcount(__r._M_refcount)\n       { }\n \n-    template <typename _Tp1>\n+    template<typename _Tp1>\n       shared_ptr(const shared_ptr<_Tp1>& __r, __const_cast_tag)\n-      : _M_ptr(const_cast<element_type*>(__r._M_ptr))\n-      , _M_refcount(__r._M_refcount)\n+      : _M_ptr(const_cast<element_type*>(__r._M_ptr)),\n+\t_M_refcount(__r._M_refcount)\n       { }\n \n-    template <typename _Tp1>\n+    template<typename _Tp1>\n       shared_ptr(const shared_ptr<_Tp1>& __r, __dynamic_cast_tag)\n-      : _M_ptr(dynamic_cast<element_type*>(__r._M_ptr))\n-      , _M_refcount(__r._M_refcount)\n+      : _M_ptr(dynamic_cast<element_type*>(__r._M_ptr)),\n+\t_M_refcount(__r._M_refcount)\n       {\n         if (_M_ptr == 0) // need to allocate new counter -- the cast failed\n-        {\n           _M_refcount = shared_count();\n-        }\n       }\n \n-    template <typename _Tp1>\n+    template<typename _Tp1>\n       shared_ptr&\n       operator=(const shared_ptr<_Tp1>& __r) // never throws\n       {\n@@ -607,7 +599,7 @@ template <typename _Tp>\n         return *this;\n       }\n \n-    template <typename _Tp1>\n+    template<typename _Tp1>\n       shared_ptr&\n       operator=(std::auto_ptr<_Tp1>& __r)\n       {\n@@ -619,15 +611,16 @@ template <typename _Tp>\n     reset() // never throws\n     { shared_ptr().swap(*this); }\n \n-    template <typename _Tp1>\n+    template<typename _Tp1>\n       void\n       reset(_Tp1* __p) // _Tp1 must be complete\n       {\n-        _GLIBCXX_DEBUG_ASSERT(__p == 0 || __p != _M_ptr); // catch self-reset errors\n+        _GLIBCXX_DEBUG_ASSERT(__p == 0 || __p != _M_ptr); // catch self-reset\n+\t                                                  // errors\n         shared_ptr(__p).swap(*this);\n       }\n \n-    template <typename _Tp1, typename _Deleter>\n+    template<typename _Tp1, typename _Deleter>\n       void\n       reset(_Tp1 * __p, _Deleter __d)\n       { shared_ptr(__p, __d).swap(*this); }\n@@ -679,7 +672,7 @@ template <typename _Tp>\n     { return _M_refcount.get_deleter(__ti); }\n \n   private:\n-    template <typename _Tp1>\n+    template<typename _Tp1>\n       bool\n       _M_less(const shared_ptr<_Tp1>& __rhs) const\n       { return _M_refcount < __rhs._M_refcount; }\n@@ -688,17 +681,17 @@ template <typename _Tp>\n     template <typename _Tp1> friend class weak_ptr;\n \n     // friends injected into enclosing namespace and found by ADL:\n-    template <typename _Tp1>\n+    template<typename _Tp1>\n       friend inline bool\n       operator==(const shared_ptr& __a, const shared_ptr<_Tp1>& __b)\n       { return __a.get() == __b.get(); }\n \n-    template <typename _Tp1>\n+    template<typename _Tp1>\n       friend inline bool\n       operator!=(const shared_ptr& __a, const shared_ptr<_Tp1>& __b)\n       { return __a.get() != __b.get(); }\n \n-    template <typename _Tp1>\n+    template<typename _Tp1>\n       friend inline bool\n       operator<(const shared_ptr& __a, const shared_ptr<_Tp1>& __b)\n       { return __a._M_less(__b); }\n@@ -714,7 +707,7 @@ template <typename _Tp>\n  *           will eventually result in undefined behaviour,\n  *           attempting to delete the same object twice.\n  */\n-template <typename _Tp, typename _Tp1>\n+template<typename _Tp, typename _Tp1>\n   shared_ptr<_Tp>\n   static_pointer_cast(const shared_ptr<_Tp1>& __r)\n   {\n@@ -726,7 +719,7 @@ template <typename _Tp, typename _Tp1>\n  *           will eventually result in undefined behaviour,\n  *           attempting to delete the same object twice.\n  */\n-template <typename _Tp, typename _Tp1>\n+template<typename _Tp, typename _Tp1>\n   shared_ptr<_Tp>\n   const_pointer_cast(const shared_ptr<_Tp1>& __r)\n   {\n@@ -738,15 +731,15 @@ template <typename _Tp, typename _Tp1>\n  *           will eventually result in undefined behaviour,\n  *           attempting to delete the same object twice.\n  */\n-template <typename _Tp, typename _Tp1>\n+template<typename _Tp, typename _Tp1>\n   shared_ptr<_Tp>\n   dynamic_pointer_cast(const shared_ptr<_Tp1>& __r)\n   {\n     return shared_ptr<_Tp>(__r, __dynamic_cast_tag());\n   }\n \n // 2.2.3.7 shared_ptr I/O\n-template <typename _Ch, typename _Tr, typename _Tp>\n+template<typename _Ch, typename _Tr, typename _Tp>\n   std::basic_ostream<_Ch, _Tr>&\n   operator<<(std::basic_ostream<_Ch, _Tr>& __os, const shared_ptr<_Tp>& __p)\n   {\n@@ -755,13 +748,13 @@ template <typename _Ch, typename _Tr, typename _Tp>\n   }\n \n // 2.2.3.10 shared_ptr get_deleter (experimental)\n-template <typename _Del, typename _Tp>\n+template<typename _Del, typename _Tp>\n   inline _Del*\n   get_deleter(const shared_ptr<_Tp>& __p)\n   { return static_cast<_Del*>(__p._M_get_deleter(typeid(_Del))); }\n \n \n-template <typename _Tp>\n+template<typename _Tp>\n   class weak_ptr\n   {\n   public:\n@@ -772,41 +765,41 @@ template <typename _Tp>\n     : _M_ptr(0), _M_refcount() // never throws\n     { }\n \n-  //  generated copy constructor, assignment, destructor are fine\n-\n-  //\n-  //  The \"obvious\" converting constructor implementation:\n-  //\n-  //  template<class Y>\n-  //  weak_ptr(weak_ptr<Y> const & r): _M_ptr(r._M_ptr), _M_refcount(r._M_refcount) // never throws\n-  //  {\n-  //  }\n-  //\n-  //  has a serious problem.\n-  //\n-  //  r._M_ptr may already have been invalidated. The _M_ptr(r._M_ptr)\n-  //  conversion may require access to *r._M_ptr (virtual inheritance).\n-  //\n-  //  It is not possible to avoid spurious access violations since\n-  //  in multithreaded programs r._M_ptr may be invalidated at any point.\n-  //\n-\n-    template <typename _Tp1>\n+    //  generated copy constructor, assignment, destructor are fine\n+\n+    //\n+    //  The \"obvious\" converting constructor implementation:\n+    //\n+    //  template<class Y>\n+    //    weak_ptr(weak_ptr<Y> const & r)\n+    //    : _M_ptr(r._M_ptr), _M_refcount(r._M_refcount) // never throws\n+    //    { }\n+    //\n+    //  has a serious problem.\n+    //\n+    //  r._M_ptr may already have been invalidated. The _M_ptr(r._M_ptr)\n+    //  conversion may require access to *r._M_ptr (virtual inheritance).\n+    //\n+    //  It is not possible to avoid spurious access violations since\n+    //  in multithreaded programs r._M_ptr may be invalidated at any point.\n+    //\n+\n+    template<typename _Tp1>\n       weak_ptr(const weak_ptr<_Tp1>& r)\n       : _M_refcount(r._M_refcount) // never throws\n       {\n         __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n         _M_ptr = r.lock().get();\n       }\n \n-    template <typename _Tp1>\n+    template<typename _Tp1>\n       weak_ptr(const shared_ptr<_Tp1>& r)\n       : _M_ptr(r._M_ptr), _M_refcount(r._M_refcount) // never throws\n       {\n         __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n       }\n \n-    template <typename _Tp1>\n+    template<typename _Tp1>\n       weak_ptr&\n       operator=(const weak_ptr<_Tp1>& r) // never throws\n       {\n@@ -815,7 +808,7 @@ template <typename _Tp>\n         return *this;\n       }\n \n-    template <typename _Tp1>\n+    template<typename _Tp1>\n       weak_ptr&\n       operator=(const shared_ptr<_Tp1>& r) // never throws\n       {\n@@ -831,25 +824,25 @@ template <typename _Tp>\n \n       // optimization: avoid throw overhead\n       if (expired())\n-      {\n-        return shared_ptr<element_type>();\n-      }\n-\n+\treturn shared_ptr<element_type>();\n+      \n       try\n-      {\n-        return shared_ptr<element_type>(*this);\n-      }\n+\t{\n+\t  return shared_ptr<element_type>(*this);\n+\t}\n       catch (const bad_weak_ptr&)\n-      {\n-        // Q: how can we get here?\n-        // A: another thread may have invalidated r after the use_count test above.\n-        return shared_ptr<element_type>();\n-      }\n+\t{\n+\t  // Q: how can we get here?\n+\t  // A: another thread may have invalidated r after the\n+\t  //    use_count test above.\n+\t  return shared_ptr<element_type>();\n+\t}\n \n #else\n \n       // optimization: avoid try/catch overhead when single threaded\n-      return expired() ? shared_ptr<element_type>() : shared_ptr<element_type>(*this);\n+      return expired() ? shared_ptr<element_type>()\n+\t               : shared_ptr<element_type>(*this);\n \n #endif\n     } // XXX MT\n@@ -876,7 +869,7 @@ template <typename _Tp>\n \n   private:\n \n-    template <typename _Tp1>\n+    template<typename _Tp1>\n       bool\n       _M_less(const weak_ptr<_Tp1>& __rhs) const\n       { return _M_refcount < __rhs._M_refcount; }\n@@ -891,13 +884,13 @@ template <typename _Tp>\n \n     // friend injected into namespace and found by ADL\n \n-    template <typename _Tp1>\n+    template<typename _Tp1>\n       friend inline bool\n       operator<(const weak_ptr& __lhs, const weak_ptr<_Tp1>& __rhs)\n       { return __lhs._M_less(__rhs); }\n \n-    template <typename _Tp1> friend class weak_ptr;\n-    template <typename _Tp1> friend class shared_ptr;\n+    template<typename _Tp1> friend class weak_ptr;\n+    template<typename _Tp1> friend class shared_ptr;\n     friend class enable_shared_from_this<_Tp>;\n \n     _Tp*       _M_ptr;           // contained pointer\n@@ -906,8 +899,7 @@ template <typename _Tp>\n   };  // weak_ptr\n \n \n-\n-template <typename _Tp>\n+template<typename _Tp>\n   class enable_shared_from_this\n   {\n   protected:\n@@ -930,26 +922,28 @@ template <typename _Tp>\n     shared_ptr<_Tp>\n     shared_from_this()\n     {\n-      shared_ptr<_Tp> p(this->_M_weak_this);\n-      return p;\n+      shared_ptr<_Tp> __p(this->_M_weak_this);\n+      return __p;\n     }\n \n     shared_ptr<const _Tp>\n     shared_from_this() const\n     {\n-      shared_ptr<const _Tp> p(this->_M_weak_this);\n-      return p;\n+      shared_ptr<const _Tp> __p(this->_M_weak_this);\n+      return __p;\n     }\n \n   private:\n-    template <typename _Tp1>\n+    template<typename _Tp1>\n       void\n       _M_weak_assign(_Tp1* __p, const shared_count& __n) const\n       { _M_weak_this._M_assign(__p, __n); }\n \n-    template <typename _Tp1>\n+    template<typename _Tp1>\n       friend void\n-      __enable_shared_from_this( const shared_count& __pn, const enable_shared_from_this* __pe, const _Tp1* __px)\n+      __enable_shared_from_this(const shared_count& __pn,\n+\t\t\t\tconst enable_shared_from_this* __pe,\n+\t\t\t\tconst _Tp1* __px)\n       {\n         if(__pe != 0)\n           __pe->_M_weak_assign(const_cast<_Tp1*>(__px), __pn);\n@@ -964,7 +958,7 @@ template <typename _Tp>\n  *  @brief   std::swap() specialisation for shared_ptr.\n  *  @relates shared_ptr.\n  */\n-template <typename _Tp>\n+template<typename _Tp>\n   inline void\n   swap(tr1::shared_ptr<_Tp>& __a, tr1::shared_ptr<_Tp>& __b)\n   {\n@@ -975,7 +969,7 @@ template <typename _Tp>\n  *  @brief   std::swap() specialisation for weak_ptr.\n  *  @relates weak_ptr.\n  */\n-template <typename _Tp>\n+template<typename _Tp>\n   void\n   swap(tr1::weak_ptr<_Tp>& __a, tr1::weak_ptr<_Tp>& __b)\n   {"}]}