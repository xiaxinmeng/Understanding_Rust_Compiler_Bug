{"sha": "9c4dcbc7d34f79065433f49e4dc0649dab00d676", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWM0ZGNiYzdkMzRmNzkwNjU0MzNmNDllNGRjMDY0OWRhYjAwZDY3Ng==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-05-16T19:48:07Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-05-16T19:48:07Z"}, "message": "(initializer_constant_valid_p): Rework to use precision, not size.\n\nAllow conversions from integer to pointer if int is wide enough.\n\nFrom-SVN: r7305", "tree": {"sha": "17aef83a56df47f601cd558febaeeaeb50e69f89", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/17aef83a56df47f601cd558febaeeaeb50e69f89"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9c4dcbc7d34f79065433f49e4dc0649dab00d676", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c4dcbc7d34f79065433f49e4dc0649dab00d676", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c4dcbc7d34f79065433f49e4dc0649dab00d676", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c4dcbc7d34f79065433f49e4dc0649dab00d676/comments", "author": null, "committer": null, "parents": [{"sha": "c96ea4a5f47df4fe14754209ddbdde06e9d5fd5e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c96ea4a5f47df4fe14754209ddbdde06e9d5fd5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c96ea4a5f47df4fe14754209ddbdde06e9d5fd5e"}], "stats": {"total": 24, "additions": 19, "deletions": 5}, "files": [{"sha": "7742e35a4977c12564a1faee3664bdf1f0e21a2a", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c4dcbc7d34f79065433f49e4dc0649dab00d676/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c4dcbc7d34f79065433f49e4dc0649dab00d676/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=9c4dcbc7d34f79065433f49e4dc0649dab00d676", "patch": "@@ -4131,17 +4131,21 @@ initializer_constant_valid_p (value, endtype)\n       if (TREE_CODE (TREE_TYPE (value)) == POINTER_TYPE\n \t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (value, 0))) == POINTER_TYPE)\n \treturn initializer_constant_valid_p (TREE_OPERAND (value, 0), endtype);\n+\n       /* Allow conversions between real types.  */\n       if (TREE_CODE (TREE_TYPE (value)) == REAL_TYPE\n \t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (value, 0))) == REAL_TYPE)\n \treturn initializer_constant_valid_p (TREE_OPERAND (value, 0), endtype);\n+\n       /* Allow length-preserving conversions between integer types.  */\n       if (TREE_CODE (TREE_TYPE (value)) == INTEGER_TYPE\n \t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (value, 0))) == INTEGER_TYPE\n-\t  && tree_int_cst_equal (TYPE_SIZE (TREE_TYPE (value)),\n-\t\t\t\t TYPE_SIZE (TREE_TYPE (TREE_OPERAND (value, 0)))))\n+\t  && (TYPE_PRECISION (TREE_TYPE (value))\n+\t      == TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (value, 0)))))\n \treturn initializer_constant_valid_p (TREE_OPERAND (value, 0), endtype);\n-      /* Allow conversions between integer types only if explicit value.  */\n+\n+      /* Allow conversions between other integer types only if\n+\t explicit value.  */\n       if (TREE_CODE (TREE_TYPE (value)) == INTEGER_TYPE\n \t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (value, 0))) == INTEGER_TYPE)\n \t{\n@@ -4151,13 +4155,23 @@ initializer_constant_valid_p (value, endtype)\n \t    return null_pointer_node;\n \t  return 0;\n \t}\n+\n       /* Allow (int) &foo provided int is as wide as a pointer.  */\n       if (TREE_CODE (TREE_TYPE (value)) == INTEGER_TYPE\n \t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (value, 0))) == POINTER_TYPE\n-\t  && ! tree_int_cst_lt (TYPE_SIZE (TREE_TYPE (value)),\n-\t\t\t\tTYPE_SIZE (TREE_TYPE (TREE_OPERAND (value, 0)))))\n+\t  && (TYPE_PRECISION (TREE_TYPE (value))\n+\t      >= TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (value, 0)))))\n+\treturn initializer_constant_valid_p (TREE_OPERAND (value, 0),\n+\t\t\t\t\t     endtype);\n+\n+      /* Likewise conversions from int to pointers.  */\n+      if (TREE_CODE (TREE_TYPE (value)) == POINTER_TYPE\n+\t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (value, 0))) == INTEGER_TYPE\n+\t  && (TYPE_PRECISION (TREE_TYPE (value))\n+\t      <= TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (value, 0)))))\n \treturn initializer_constant_valid_p (TREE_OPERAND (value, 0),\n \t\t\t\t\t     endtype);\n+\n       /* Allow conversions to union types if the value inside is okay.  */\n       if (TREE_CODE (TREE_TYPE (value)) == UNION_TYPE)\n \treturn initializer_constant_valid_p (TREE_OPERAND (value, 0),"}]}