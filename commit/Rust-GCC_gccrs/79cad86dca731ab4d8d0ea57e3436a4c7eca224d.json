{"sha": "79cad86dca731ab4d8d0ea57e3436a4c7eca224d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzljYWQ4NmRjYTczMWFiNGQ4ZDBlYTU3ZTM0MzZhNGM3ZWNhMjI0ZA==", "commit": {"author": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "2011-11-06T02:39:03Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "2011-11-06T02:39:03Z"}, "message": "More improvements to sparc VIS vec_init code generation.\n\ngcc/\n\n\t* config/sparc/sparc.md (UNSPEC_SHORT_LOAD): New unspec.\n\t(zero-extend_v8qi_vis, zero_extend_v4hi_vis): New expanders.\n\t(*zero_extend_v8qi_<P:mode>_insn,\n\t*zero_extend_v4hi_<P:mode>_insn): New insns.\n\t* config/sparc/sparc.c (vector_init_move_words,\n\tvector_init_prepare_elts, sparc_expand_vector_init_vis2,\n\tsparc_expand_vector_init_vis1): New functions.\n\t(vector_init_bshuffle): Rewrite to handle more cases and make use\n\tof locs[] array prepared by vector_init_prepare_elts.\n\t(vector_init_fpmerge, vector_init_faligndata): Delete.\n\t(sparc_expand_vector_init): Rewrite using new infrastructure.\n\ngcc/testsuite/\n\n\t* lib/test-supports.exp\n\t(check_effective_target_ultrasparc_vis2_hw): New proc.\n\t(check_effective_target_ultrasparc_vis3_hw): New proc.\n\t* gcc.target/sparc/vec-init-1.inc: New vector init common code.\n\t* gcc.target/sparc/vec-init-2.inc: Likewise.\n\t* gcc.target/sparc/vec-init-3.inc: Likewise.\n\t* gcc.target/sparc/vec-init-1-vis1.c: New test.\n\t* gcc.target/sparc/vec-init-1-vis2.c: New test.\n\t* gcc.target/sparc/vec-init-1-vis3.c: New test.\n\t* gcc.target/sparc/vec-init-2-vis1.c: New test.\n\t* gcc.target/sparc/vec-init-2-vis2.c: New test.\n\t* gcc.target/sparc/vec-init-2-vis3.c: New test.\n\t* gcc.target/sparc/vec-init-3-vis1.c: New test.\n\t* gcc.target/sparc/vec-init-3-vis2.c: New test.\n\t* gcc.target/sparc/vec-init-3-vis3.c: New test.\n\nFrom-SVN: r181024", "tree": {"sha": "2b91ab090e2bb20b0d2031ff23deb37131824d0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b91ab090e2bb20b0d2031ff23deb37131824d0d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79cad86dca731ab4d8d0ea57e3436a4c7eca224d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79cad86dca731ab4d8d0ea57e3436a4c7eca224d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79cad86dca731ab4d8d0ea57e3436a4c7eca224d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79cad86dca731ab4d8d0ea57e3436a4c7eca224d/comments", "author": null, "committer": null, "parents": [{"sha": "e940f96ffcfe6a80e5c25e49926f1fdf195293a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e940f96ffcfe6a80e5c25e49926f1fdf195293a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e940f96ffcfe6a80e5c25e49926f1fdf195293a8"}], "stats": {"total": 843, "additions": 743, "deletions": 100}, "files": [{"sha": "328efb3330743f063ffd72122afbdfe8f2425a3c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79cad86dca731ab4d8d0ea57e3436a4c7eca224d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79cad86dca731ab4d8d0ea57e3436a4c7eca224d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=79cad86dca731ab4d8d0ea57e3436a4c7eca224d", "patch": "@@ -1,3 +1,17 @@\n+2011-11-05  David S. Miller  <davem@davemloft.net>\n+\n+\t* config/sparc/sparc.md (UNSPEC_SHORT_LOAD): New unspec.\n+\t(zero-extend_v8qi_vis, zero_extend_v4hi_vis): New expanders.\n+\t(*zero_extend_v8qi_<P:mode>_insn,\n+\t*zero_extend_v4hi_<P:mode>_insn): New insns.\n+\t* config/sparc/sparc.c (vector_init_move_words,\n+\tvector_init_prepare_elts, sparc_expand_vector_init_vis2,\n+\tsparc_expand_vector_init_vis1): New functions.\n+\t(vector_init_bshuffle): Rewrite to handle more cases and make use\n+\tof locs[] array prepared by vector_init_prepare_elts.\n+\t(vector_init_fpmerge, vector_init_faligndata): Delete.\n+\t(sparc_expand_vector_init): Rewrite using new infrastructure.\n+\n 2011-11-05  Joern Rennecke  <joern.rennecke@embecosm.com>\n \n \t* config.gcc (epiphany-*-*): New architecture.\n@@ -56,7 +70,7 @@\n \tRemove -mcpu=601 multilib.\n \tRemove -Dmpc8260 multilib.\n \t* config/rs6000/rtems.h: Allow --float-gprs=... to override grps\n-\ton E500 targets.\t\n+\ton E500 targets.\n \n 2011-11-05  Quentin Neill  <quentin.neill@amd.com>\n "}, {"sha": "5d22fc0313e0bf02de64a99fe1ca9313b33de68b", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 320, "deletions": 99, "changes": 419, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79cad86dca731ab4d8d0ea57e3436a4c7eca224d/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79cad86dca731ab4d8d0ea57e3436a4c7eca224d/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=79cad86dca731ab4d8d0ea57e3436a4c7eca224d", "patch": "@@ -11280,83 +11280,333 @@ output_v8plus_mult (rtx insn, rtx *operands, const char *name)\n }\n \n static void\n-vector_init_bshuffle (rtx target, rtx elt, enum machine_mode mode,\n+vector_init_bshuffle (rtx target, rtx *locs, int n_elts, enum machine_mode mode,\n \t\t      enum machine_mode inner_mode)\n {\n-      rtx t1, final_insn;\n-      int bmask;\n+  rtx mid_target, r0_high, r0_low, r1_high, r1_low;\n+  enum machine_mode partial_mode;\n+  int bmask, i, idxs[8];\n \n-      t1 = gen_reg_rtx (mode);\n+  partial_mode = (mode == V4HImode\n+\t\t  ? V2HImode\n+\t\t  : (mode == V8QImode\n+\t\t     ? V4QImode : mode));\n \n-      elt = convert_modes (SImode, inner_mode, elt, true);\n-      emit_move_insn (gen_lowpart(SImode, t1), elt);\n+  r0_high = r0_low = NULL_RTX;\n+  r1_high = r1_low = NULL_RTX;\n \n-      switch (mode)\n+  /* Move the pieces into place, as needed, and calculate the nibble\n+     indexes for the bmask calculation.  After we execute this loop the\n+     locs[] array is no longer needed.  Therefore, to simplify things,\n+     we set entries that have been processed already to NULL_RTX.  */\n+\n+  for (i = 0; i < n_elts; i++)\n+    {\n+      int j;\n+\n+      if (locs[i] == NULL_RTX)\n+\tcontinue;\n+\n+      if (!r0_low)\n \t{\n-\tcase V2SImode:\n-\t  final_insn = gen_bshufflev2si_vis (target, t1, t1);\n-\t  bmask = 0x45674567;\n-\t  break;\n-\tcase V4HImode:\n-\t  final_insn = gen_bshufflev4hi_vis (target, t1, t1);\n-\t  bmask = 0x67676767;\n+\t  r0_low = locs[i];\n+\t  idxs[i] = 0x7;\n+\t}\n+      else if (!r1_low)\n+\t{\n+\t  r1_low = locs[i];\n+\t  idxs[i] = 0xf;\n+\t}\n+      else if (!r0_high)\n+\t{\n+\t  r0_high = gen_highpart (partial_mode, r0_low);\n+\t  emit_move_insn (r0_high, gen_lowpart (partial_mode, locs[i]));\n+\t  idxs[i] = 0x3;\n+\t}\n+      else if (!r1_high)\n+\t{\n+\t  r1_high = gen_highpart (partial_mode, r1_low);\n+\t  emit_move_insn (r1_high, gen_lowpart (partial_mode, locs[i]));\n+\t  idxs[i] = 0xb;\n+\t}\n+      else\n+\tgcc_unreachable ();\n+\n+      for (j = i + 1; j < n_elts; j++)\n+\t{\n+\t  if (locs[j] == locs[i])\n+\t    {\n+\t      locs[j] = NULL_RTX;\n+\t      idxs[j] = idxs[i];\n+\t    }\n+\t}\n+      locs[i] = NULL_RTX;\n+    }\n+\n+  bmask = 0;\n+  for (i = 0; i < n_elts; i++)\n+    {\n+      int v = idxs[i];\n+\n+      switch (GET_MODE_SIZE (inner_mode))\n+\t{\n+\tcase 2:\n+\t  bmask <<= 8;\n+\t  bmask |= (((v - 1) << 4) | v);\n \t  break;\n-\tcase V8QImode:\n-\t  final_insn = gen_bshufflev8qi_vis (target, t1, t1);\n-\t  bmask = 0x77777777;\n+\n+\tcase 1:\n+\t  bmask <<= 4;\n+\t  bmask |= v;\n \t  break;\n+\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n+    }\n+\n+  emit_insn (gen_bmasksi_vis (gen_reg_rtx (SImode), CONST0_RTX (SImode),\n+\t\t\t      force_reg (SImode, GEN_INT (bmask))));\n+\n+  mid_target = target;\n+  if (GET_MODE_SIZE (mode) == 4)\n+    {\n+      mid_target = gen_reg_rtx (mode == V2HImode\n+\t\t\t\t? V4HImode : V8QImode);\n+    }\n+\n+  if (!r1_low)\n+    r1_low = r0_low;\n+\n+  switch (GET_MODE (mid_target))\n+    {\n+    case V4HImode:\n+      emit_insn (gen_bshufflev4hi_vis (mid_target, r0_low, r1_low));\n+      break;\n+    case V8QImode:\n+      emit_insn (gen_bshufflev8qi_vis (mid_target, r0_low, r1_low));\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n \n-      emit_insn (gen_bmasksi_vis (gen_reg_rtx (SImode), CONST0_RTX (SImode),\n-\t\t\t\t  force_reg (SImode, GEN_INT (bmask))));\n-      emit_insn (final_insn);\n+  if (mid_target != target)\n+    emit_move_insn (target, gen_lowpart (partial_mode, mid_target));\n }\n \n+static bool\n+vector_init_move_words (rtx target, rtx vals, enum machine_mode mode,\n+\t\t\tenum machine_mode inner_mode)\n+{\n+  switch (mode)\n+    {\n+    case V1SImode:\n+    case V1DImode:\n+      emit_move_insn (gen_lowpart (inner_mode, target),\n+\t\t      gen_lowpart (inner_mode, XVECEXP (vals, 0, 0)));\n+      return true;\n+\n+    case V2SImode:\n+      emit_move_insn (gen_highpart (SImode, target), XVECEXP (vals, 0, 0));\n+      emit_move_insn (gen_lowpart (SImode, target), XVECEXP (vals, 0, 1));\n+      return true;\n+\n+    default:\n+      break;\n+    }\n+  return false;\n+}\n+\n+/* Move the elements in rtvec VALS into registers compatible with MODE.\n+   Store the rtx for these regs into the corresponding array entry of\n+   LOCS.  */\n static void\n-vector_init_fpmerge (rtx target, rtx elt, enum machine_mode inner_mode)\n+vector_init_prepare_elts (rtx vals, int n_elts, rtx *locs, enum machine_mode mode,\n+\t\t\t  enum machine_mode inner_mode)\n {\n-  rtx t1, t2, t3, t3_low;\n+  enum machine_mode loc_mode;\n+  int i;\n \n-  t1 = gen_reg_rtx (V4QImode);\n-  elt = convert_modes (SImode, inner_mode, elt, true);\n-  emit_move_insn (gen_lowpart (SImode, t1), elt);\n+  switch (mode)\n+    {\n+    case V2HImode:\n+      loc_mode = V4HImode;\n+      break;\n \n-  t2 = gen_reg_rtx (V4QImode);\n-  emit_move_insn (t2, t1);\n+    case V4QImode:\n+      loc_mode = V8QImode;\n+      break;\n+\n+    case V4HImode:\n+    case V8QImode:\n+      loc_mode = mode;\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  gcc_assert (GET_MODE_SIZE (inner_mode) <= 4);\n+  for (i = 0; i < n_elts; i++)\n+    {\n+      rtx dst, elt = XVECEXP (vals, 0, i);\n+      int j;\n+\n+      /* Did we see this already?  If so just record it's location.  */\n+      dst = NULL_RTX;\n+      for (j = 0; j < i; j++)\n+\t{\n+\t  if (XVECEXP (vals, 0, j) == elt)\n+\t    {\n+\t      dst = locs[j];\n+\t      break;\n+\t    }\n+\t}\n \n-  t3 = gen_reg_rtx (V8QImode);\n-  t3_low = gen_lowpart (V4QImode, t3);\n+      if (! dst)\n+\t{\n+\t  enum rtx_code code = GET_CODE (elt);\n \n-  emit_insn (gen_fpmerge_vis (t3, t1, t2));\n-  emit_move_insn (t1, t3_low);\n-  emit_move_insn (t2, t3_low);\n+\t  dst = gen_reg_rtx (loc_mode);\n \n-  emit_insn (gen_fpmerge_vis (t3, t1, t2));\n-  emit_move_insn (t1, t3_low);\n-  emit_move_insn (t2, t3_low);\n+\t  /* We use different strategies based upon whether the element\n+\t     is in memory or in a register.  When we start in a register\n+\t     and we're VIS3 capable, it's always cheaper to use the VIS3\n+\t     int-->fp register moves since we avoid having to use stack\n+\t     memory.  */\n+\t  if ((TARGET_VIS3 && (code == REG || code == SUBREG))\n+\t      || (CONSTANT_P (elt)\n+\t\t  && (const_zero_operand (elt, inner_mode)\n+\t\t      || const_all_ones_operand (elt, inner_mode))))\n+\t    {\n+\t      elt = convert_modes (SImode, inner_mode, elt, true);\n \n-  emit_insn (gen_fpmerge_vis (gen_lowpart (V8QImode, target), t1, t2));\n+\t      emit_clobber (dst);\n+\t      emit_move_insn (gen_lowpart (SImode, dst), elt);\n+\t    }\n+\t  else\n+\t    {\n+\t      rtx m = elt;\n+\n+\t      if (CONSTANT_P (elt))\n+\t\t{\n+\t\t  m = force_const_mem (inner_mode, elt);\n+\t\t}\n+\t      else if (code != MEM)\n+\t\t{\n+\t\t  rtx stk = assign_stack_temp (inner_mode, GET_MODE_SIZE(inner_mode), 0);\n+\t\t  emit_move_insn (stk, elt);\n+\t\t  m = stk;\n+\t\t}\n+\n+\t      switch (loc_mode)\n+\t\t{\n+\t\tcase V4HImode:\n+\t\t  emit_insn (gen_zero_extend_v4hi_vis (dst, m));\n+\t\t  break;\n+\t\tcase V8QImode:\n+\t\t  emit_insn (gen_zero_extend_v8qi_vis (dst, m));\n+\t\t  break;\n+\t\tdefault:\n+\t\t  gcc_unreachable ();\n+\t\t}\n+\t    }\n+\t}\n+      locs[i] = dst;\n+    }\n }\n \n static void\n-vector_init_faligndata (rtx target, rtx elt, enum machine_mode inner_mode)\n+sparc_expand_vector_init_vis2 (rtx target, rtx *locs, int n_elts, int n_unique,\n+\t\t\t       enum machine_mode mode,\n+\t\t\t       enum machine_mode inner_mode)\n {\n-  rtx t1 = gen_reg_rtx (V4HImode);\n+  if (n_unique <= 4)\n+    {\n+      vector_init_bshuffle (target, locs, n_elts, mode, inner_mode);\n+    }\n+  else\n+    {\n+      int i;\n \n-  elt = convert_modes (SImode, inner_mode, elt, true);\n+      gcc_assert (mode == V8QImode);\n \n-  emit_move_insn (gen_lowpart (SImode, t1), elt);\n+      emit_insn (gen_alignaddrsi_vis (gen_reg_rtx (SImode),\n+\t\t\t\t      force_reg (SImode, GEN_INT (7)),\n+\t\t\t\t      CONST0_RTX (SImode)));\n+      i = n_elts - 1;\n+      emit_insn (gen_faligndatav8qi_vis (target, locs[i], locs[i]));\n+      while (--i >= 0)\n+\temit_insn (gen_faligndatav8qi_vis (target, locs[i], target));\n+    }\n+}\n+\n+static void\n+sparc_expand_vector_init_vis1 (rtx target, rtx *locs, int n_elts, int n_unique,\n+\t\t\t       enum machine_mode mode)\n+{\n+  enum machine_mode full_mode = mode;\n+  rtx (*emitter)(rtx, rtx, rtx);\n+  int alignaddr_val, i;\n+  rtx tmp = target;\n+\n+  if (n_unique == 1 && mode == V8QImode)\n+    {\n+      rtx t2, t2_low, t1;\n+\n+      t1 = gen_reg_rtx (V4QImode);\n+      emit_move_insn (t1, gen_lowpart (V4QImode, locs[0]));\n+\n+      t2 = gen_reg_rtx (V8QImode);\n+      t2_low = gen_lowpart (V4QImode, t2);\n+\n+      /* xxxxxxAA --> xxxxxxxxxxxxAAAA\n+         xxxxAAAA --> xxxxxxxxAAAAAAAA\n+         AAAAAAAA --> AAAAAAAAAAAAAAAA */\n+      emit_insn (gen_fpmerge_vis (t2, t1, t1));\n+      emit_move_insn (t1, t2_low);\n+      emit_insn (gen_fpmerge_vis (t2, t1, t1));\n+      emit_move_insn (t1, t2_low);\n+      emit_insn (gen_fpmerge_vis (target, t1, t1));\n+      return;\n+    }\n+\n+  switch (mode)\n+    {\n+    case V2HImode:\n+      full_mode = V4HImode;\n+      /* FALLTHRU */\n+    case V4HImode:\n+      emitter = gen_faligndatav4hi_vis;\n+      alignaddr_val = 6;\n+      break;\n+\n+    case V4QImode:\n+      full_mode = V8QImode;\n+      /* FALLTHRU */\n+    case V8QImode:\n+      emitter = gen_faligndatav8qi_vis;\n+      alignaddr_val = 7;\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  if (full_mode != mode)\n+    tmp = gen_reg_rtx (full_mode);\n \n   emit_insn (gen_alignaddrsi_vis (gen_reg_rtx (SImode),\n-\t\t\t\t  force_reg (SImode, GEN_INT (6)),\n+\t\t\t\t  force_reg (SImode, GEN_INT (alignaddr_val)),\n \t\t\t\t  CONST0_RTX (SImode)));\n \n-  emit_insn (gen_faligndatav4hi_vis (target, t1, target));\n-  emit_insn (gen_faligndatav4hi_vis (target, t1, target));\n-  emit_insn (gen_faligndatav4hi_vis (target, t1, target));\n-  emit_insn (gen_faligndatav4hi_vis (target, t1, target));\n+  i = n_elts - 1;\n+  emit_insn (emitter (tmp, locs[i], locs[i]));\n+  while (--i >= 0)\n+    emit_insn (emitter (tmp, locs[i], tmp));\n+\n+  if (tmp != target)\n+    emit_move_insn (target, gen_highpart (mode, tmp));\n }\n \n void\n@@ -11365,19 +11615,30 @@ sparc_expand_vector_init (rtx target, rtx vals)\n   enum machine_mode mode = GET_MODE (target);\n   enum machine_mode inner_mode = GET_MODE_INNER (mode);\n   int n_elts = GET_MODE_NUNITS (mode);\n-  int i, n_var = 0;\n-  bool all_same;\n-  rtx mem;\n+  int i, n_var = 0, n_unique = 0;\n+  rtx locs[8];\n+\n+  gcc_assert (n_elts <= 8);\n \n-  all_same = true;\n   for (i = 0; i < n_elts; i++)\n     {\n       rtx x = XVECEXP (vals, 0, i);\n+      bool found = false;\n+      int j;\n+\n       if (!CONSTANT_P (x))\n \tn_var++;\n \n-      if (i > 0 && !rtx_equal_p (x, XVECEXP (vals, 0, 0)))\n-\tall_same = false;\n+      for (j = 0; j < i; j++)\n+\t{\n+\t  if (rtx_equal_p (x, XVECEXP (vals, 0, j)))\n+\t    {\n+\t      found = true;\n+\t      break;\n+\t    }\n+\t}\n+      if (!found)\n+\tn_unique++;\n     }\n \n   if (n_var == 0)\n@@ -11386,56 +11647,16 @@ sparc_expand_vector_init (rtx target, rtx vals)\n       return;\n     }\n \n-  if (GET_MODE_SIZE (inner_mode) == GET_MODE_SIZE (mode))\n-    {\n-      if (GET_MODE_SIZE (inner_mode) == 4)\n-\t{\n-\t  emit_move_insn (gen_lowpart (SImode, target),\n-\t\t\t  gen_lowpart (SImode, XVECEXP (vals, 0, 0)));\n-\t  return;\n-\t}\n-      else if (GET_MODE_SIZE (inner_mode) == 8)\n-\t{\n-\t  emit_move_insn (gen_lowpart (DImode, target),\n-\t\t\t  gen_lowpart (DImode, XVECEXP (vals, 0, 0)));\n-\t  return;\n-\t}\n-    }\n-  else if (GET_MODE_SIZE (inner_mode) == GET_MODE_SIZE (word_mode)\n-\t   && GET_MODE_SIZE (mode) == 2 * GET_MODE_SIZE (word_mode))\n-    {\n-      emit_move_insn (gen_highpart (word_mode, target),\n-\t\t      gen_lowpart (word_mode, XVECEXP (vals, 0, 0)));\n-      emit_move_insn (gen_lowpart (word_mode, target),\n-\t\t      gen_lowpart (word_mode, XVECEXP (vals, 0, 1)));\n-      return;\n-    }\n+  if (vector_init_move_words (target, vals, mode, inner_mode))\n+    return;\n \n-  if (all_same && GET_MODE_SIZE (mode) == 8)\n-    {\n-      if (TARGET_VIS2)\n-\t{\n-\t  vector_init_bshuffle (target, XVECEXP (vals, 0, 0), mode, inner_mode);\n-\t  return;\n-\t}\n-      if (mode == V8QImode)\n-\t{\n-\t  vector_init_fpmerge (target, XVECEXP (vals, 0, 0), inner_mode);\n-\t  return;\n-\t}\n-      if (mode == V4HImode)\n-\t{\n-\t  vector_init_faligndata (target, XVECEXP (vals, 0, 0), inner_mode);\n-\t  return;\n-\t}\n-    }\n+  vector_init_prepare_elts (vals, n_elts, locs, mode, inner_mode);\n \n-  mem = assign_stack_temp (mode, GET_MODE_SIZE (mode), 0);\n-  for (i = 0; i < n_elts; i++)\n-    emit_move_insn (adjust_address_nv (mem, inner_mode,\n-\t\t\t\t    i * GET_MODE_SIZE (inner_mode)),\n-\t\t    XVECEXP (vals, 0, i));\n-  emit_move_insn (target, mem);\n+  if (TARGET_VIS2)\n+    sparc_expand_vector_init_vis2 (target, locs, n_elts, n_unique,\n+\t\t\t\t   mode, inner_mode);\n+  else\n+    sparc_expand_vector_init_vis1 (target, locs, n_elts, n_unique, mode);\n }\n \n static reg_class_t"}, {"sha": "7452f96c9d34e1ab8460406c967aa7ab91a3b430", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79cad86dca731ab4d8d0ea57e3436a4c7eca224d/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79cad86dca731ab4d8d0ea57e3436a4c7eca224d/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=79cad86dca731ab4d8d0ea57e3436a4c7eca224d", "patch": "@@ -92,6 +92,7 @@\n    (UNSPEC_MUL8\t\t\t86)\n    (UNSPEC_MUL8SU\t\t87)\n    (UNSPEC_MULDSU\t\t88)\n+   (UNSPEC_SHORT_LOAD\t\t89)\n   ])\n \n (define_constants\n@@ -7830,6 +7831,48 @@\n   DONE;\n })\n \n+(define_expand \"zero_extend_v8qi_vis\"\n+  [(set (match_operand:V8QI 0 \"register_operand\" \"\")\n+        (unspec:V8QI [(match_operand:QI 1 \"memory_operand\" \"\")]\n+                     UNSPEC_SHORT_LOAD))]\n+  \"TARGET_VIS\"\n+{\n+  if (! REG_P (XEXP (operands[1], 0)))\n+    {\n+      rtx addr = force_reg (Pmode, XEXP (operands[1], 0));\n+      operands[1] = replace_equiv_address (operands[1], addr);\n+    }\n+})\n+\n+(define_expand \"zero_extend_v4hi_vis\"\n+  [(set (match_operand:V4HI 0 \"register_operand\" \"\")\n+        (unspec:V4HI [(match_operand:HI 1 \"memory_operand\" \"\")]\n+                     UNSPEC_SHORT_LOAD))]\n+  \"TARGET_VIS\"\n+{\n+  if (! REG_P (XEXP (operands[1], 0)))\n+    {\n+      rtx addr = force_reg (Pmode, XEXP (operands[1], 0));\n+      operands[1] = replace_equiv_address (operands[1], addr);\n+    }\n+})\n+\n+(define_insn \"*zero_extend_v8qi_<P:mode>_insn\"\n+  [(set (match_operand:V8QI 0 \"register_operand\" \"=e\")\n+        (unspec:V8QI [(mem:QI\n+                       (match_operand:P 1 \"register_operand\" \"r\"))]\n+                     UNSPEC_SHORT_LOAD))]\n+  \"TARGET_VIS\"\n+  \"ldda\\t[%1] 0xd0, %0\")\n+\n+(define_insn \"*zero_extend_v4hi_<P:mode>_insn\"\n+  [(set (match_operand:V4HI 0 \"register_operand\" \"=e\")\n+        (unspec:V4HI [(mem:HI\n+                       (match_operand:P 1 \"register_operand\" \"r\"))]\n+                     UNSPEC_SHORT_LOAD))]\n+  \"TARGET_VIS\"\n+  \"ldda\\t[%1] 0xd2, %0\")\n+\n (define_expand \"vec_init<mode>\"\n   [(match_operand:VMALL 0 \"register_operand\" \"\")\n    (match_operand:VMALL 1 \"\" \"\")]"}, {"sha": "b84dcf01758834b7db3449a7b70bc44aafa18a05", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79cad86dca731ab4d8d0ea57e3436a4c7eca224d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79cad86dca731ab4d8d0ea57e3436a4c7eca224d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=79cad86dca731ab4d8d0ea57e3436a4c7eca224d", "patch": "@@ -1,3 +1,21 @@\n+2011-11-05  David S. Miller  <davem@davemloft.net>\n+\n+\t* lib/test-supports.exp\n+\t(check_effective_target_ultrasparc_vis2_hw): New proc.\n+\t(check_effective_target_ultrasparc_vis3_hw): New proc.\n+\t* gcc.target/sparc/vec-init-1.inc: New vector init common code.\n+\t* gcc.target/sparc/vec-init-2.inc: Likewise.\n+\t* gcc.target/sparc/vec-init-3.inc: Likewise.\n+\t* gcc.target/sparc/vec-init-1-vis1.c: New test.\n+\t* gcc.target/sparc/vec-init-1-vis2.c: New test.\n+\t* gcc.target/sparc/vec-init-1-vis3.c: New test.\n+\t* gcc.target/sparc/vec-init-2-vis1.c: New test.\n+\t* gcc.target/sparc/vec-init-2-vis2.c: New test.\n+\t* gcc.target/sparc/vec-init-2-vis3.c: New test.\n+\t* gcc.target/sparc/vec-init-3-vis1.c: New test.\n+\t* gcc.target/sparc/vec-init-3-vis2.c: New test.\n+\t* gcc.target/sparc/vec-init-3-vis3.c: New test.\n+\n 2011-11-05  Joern Rennecke  <joern.rennecke@embecosm.com>\n \n \t* gcc.c-torture/execute/ieee/mul-subnormal-single-1.x:"}, {"sha": "4202bfa6e72a75f533511c4c6f46bc76b3fa9b14", "filename": "gcc/testsuite/gcc.target/sparc/vec-init-1-vis1.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79cad86dca731ab4d8d0ea57e3436a4c7eca224d/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fvec-init-1-vis1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79cad86dca731ab4d8d0ea57e3436a4c7eca224d/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fvec-init-1-vis1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fvec-init-1-vis1.c?ref=79cad86dca731ab4d8d0ea57e3436a4c7eca224d", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target ultrasparc_hw } */\n+/* { dg-options \"-mcpu=ultrasparc -mvis -O2\" } */\n+\n+#include \"vec-init-1.inc\""}, {"sha": "a5c213239364d5f7648ca6da5168ccd6e0f3c94f", "filename": "gcc/testsuite/gcc.target/sparc/vec-init-1-vis2.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79cad86dca731ab4d8d0ea57e3436a4c7eca224d/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fvec-init-1-vis2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79cad86dca731ab4d8d0ea57e3436a4c7eca224d/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fvec-init-1-vis2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fvec-init-1-vis2.c?ref=79cad86dca731ab4d8d0ea57e3436a4c7eca224d", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target ultrasparc_vis2_hw } */\n+/* { dg-options \"-mcpu=ultrasparc3 -O2\" } */\n+\n+#include \"vec-init-1.inc\""}, {"sha": "ab916e052ccd25f5b746a65f7cd7e0e56f92fadc", "filename": "gcc/testsuite/gcc.target/sparc/vec-init-1-vis3.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79cad86dca731ab4d8d0ea57e3436a4c7eca224d/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fvec-init-1-vis3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79cad86dca731ab4d8d0ea57e3436a4c7eca224d/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fvec-init-1-vis3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fvec-init-1-vis3.c?ref=79cad86dca731ab4d8d0ea57e3436a4c7eca224d", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target ultrasparc_vis3_hw } */\n+/* { dg-options \"-mcpu=niagara3 -O2\" } */\n+\n+#include \"vec-init-1.inc\""}, {"sha": "e27bb6e293bdc644373ab1ce5461464d2984af20", "filename": "gcc/testsuite/gcc.target/sparc/vec-init-1.inc", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79cad86dca731ab4d8d0ea57e3436a4c7eca224d/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fvec-init-1.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79cad86dca731ab4d8d0ea57e3436a4c7eca224d/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fvec-init-1.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fvec-init-1.inc?ref=79cad86dca731ab4d8d0ea57e3436a4c7eca224d", "patch": "@@ -0,0 +1,85 @@\n+typedef int __v1si __attribute__ ((__vector_size__ (4)));\n+typedef int __v2si __attribute__ ((__vector_size__ (8)));\n+typedef short __v2hi __attribute__ ((__vector_size__ (4)));\n+typedef short __v4hi __attribute__ ((__vector_size__ (8)));\n+typedef unsigned char __v4qi __attribute__ ((__vector_size__ (4)));\n+typedef unsigned char __v8qi __attribute__ ((__vector_size__ (8)));\n+\n+extern void abort (void);\n+\n+static void\n+compare64 (void *p, unsigned long long val)\n+{\n+  if (*(unsigned long long *)p != val)\n+    abort();\n+}\n+\n+static void\n+compare32 (void *p, unsigned int val)\n+{\n+  if (*(unsigned int *)p != val)\n+    abort();\n+}\n+\n+static void\n+test_v8qi (unsigned char x)\n+{\n+  __v8qi v = { x, x, x, x, x, x, x, x };\n+\n+  compare64(&v, 0x4444444444444444ULL);\n+}\n+\n+static void\n+test_v4qi (unsigned char x)\n+{\n+  __v4qi v = { x, x, x, x };\n+\n+  compare32(&v, 0x44444444);\n+}\n+\n+static void\n+test_v4hi (unsigned short x)\n+{\n+  __v4hi v = { x, x, x, x, };\n+\n+  compare64(&v, 0x3344334433443344ULL);\n+}\n+\n+static void\n+test_v2hi (unsigned short x)\n+{\n+  __v2hi v = { x, x, };\n+\n+  compare32(&v, 0x33443344);\n+}\n+\n+static void\n+test_v2si (unsigned int x)\n+{\n+  __v2si v = { x, x, };\n+\n+  compare64(&v, 0x1122334411223344ULL);\n+}\n+\n+static void\n+test_v1si (unsigned int x)\n+{\n+  __v1si v = { x };\n+\n+  compare32(&v, 0x11223344);\n+}\n+\n+unsigned char x8 = 0x44;\n+unsigned short x16 = 0x3344;\n+unsigned int x32 = 0x11223344;\n+\n+int main(void)\n+{\n+  test_v8qi (x8);\n+  test_v4qi (x8);\n+  test_v4hi (x16);\n+  test_v2hi (x16);\n+  test_v2si (x32);\n+  test_v1si (x32);\n+  return 0;\n+}"}, {"sha": "efa08fa248c2feef5fe47384272d1343b85eb897", "filename": "gcc/testsuite/gcc.target/sparc/vec-init-2-vis1.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79cad86dca731ab4d8d0ea57e3436a4c7eca224d/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fvec-init-2-vis1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79cad86dca731ab4d8d0ea57e3436a4c7eca224d/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fvec-init-2-vis1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fvec-init-2-vis1.c?ref=79cad86dca731ab4d8d0ea57e3436a4c7eca224d", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target ultrasparc_hw } */\n+/* { dg-options \"-mcpu=ultrasparc -mvis -O2\" } */\n+\n+#include \"vec-init-2.inc\""}, {"sha": "3aa0f51595fcbb2c06bab667a4e0f0ff7a1b35ee", "filename": "gcc/testsuite/gcc.target/sparc/vec-init-2-vis2.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79cad86dca731ab4d8d0ea57e3436a4c7eca224d/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fvec-init-2-vis2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79cad86dca731ab4d8d0ea57e3436a4c7eca224d/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fvec-init-2-vis2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fvec-init-2-vis2.c?ref=79cad86dca731ab4d8d0ea57e3436a4c7eca224d", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target ultrasparc_vis2_hw } */\n+/* { dg-options \"-mcpu=ultrasparc3 -O2\" } */\n+\n+#include \"vec-init-2.inc\""}, {"sha": "5f0c65860bc95d5cccab76ba4fefad9f0d1524c4", "filename": "gcc/testsuite/gcc.target/sparc/vec-init-2-vis3.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79cad86dca731ab4d8d0ea57e3436a4c7eca224d/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fvec-init-2-vis3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79cad86dca731ab4d8d0ea57e3436a4c7eca224d/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fvec-init-2-vis3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fvec-init-2-vis3.c?ref=79cad86dca731ab4d8d0ea57e3436a4c7eca224d", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target ultrasparc_vis3_hw } */\n+/* { dg-options \"-mcpu=niagara3 -O2\" } */\n+\n+#include \"vec-init-2.inc\""}, {"sha": "13685a1006e06586b585dcc31cb15acfcc5a205f", "filename": "gcc/testsuite/gcc.target/sparc/vec-init-2.inc", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79cad86dca731ab4d8d0ea57e3436a4c7eca224d/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fvec-init-2.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79cad86dca731ab4d8d0ea57e3436a4c7eca224d/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fvec-init-2.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fvec-init-2.inc?ref=79cad86dca731ab4d8d0ea57e3436a4c7eca224d", "patch": "@@ -0,0 +1,94 @@\n+typedef short __v2hi __attribute__ ((__vector_size__ (4)));\n+typedef short __v4hi __attribute__ ((__vector_size__ (8)));\n+\n+extern void abort (void);\n+\n+static void\n+compare64 (int n, void *p, unsigned long long val)\n+{\n+  unsigned long long *x = (unsigned long long *) p;\n+\n+  if (*x != val)\n+    abort();\n+}\n+\n+static void\n+compare32 (int n, void *p, unsigned int val)\n+{\n+  unsigned int *x = (unsigned int *) p;\n+  if (*x != val)\n+    abort();\n+}\n+\n+#define V2HI_TEST(N, elt0, elt1) \\\n+static void \\\n+test_v2hi_##N (unsigned short x, unsigned short y) \\\n+{ \\\n+  __v2hi v = { (elt0), (elt1) }; \\\n+  compare32(N, &v, ((int)(elt0) << 16) | (elt1)); \\\n+}\n+\n+V2HI_TEST(1, x, y)\n+V2HI_TEST(2, y, x)\n+V2HI_TEST(3, x, x)\n+V2HI_TEST(4, x, 0)\n+V2HI_TEST(5, 0, x)\n+V2HI_TEST(6, y, 1)\n+V2HI_TEST(7, 1, y)\n+V2HI_TEST(8, 2, 3)\n+V2HI_TEST(9, 0x400, x)\n+V2HI_TEST(10, y, 0x8000)\n+\n+#define V4HI_TEST(N, elt0, elt1, elt2, elt3)\t\\\n+static void \\\n+test_v4hi_##N (unsigned short a, unsigned short b, unsigned short c, unsigned short d) \\\n+{ \\\n+  __v4hi v = { (elt0), (elt1), (elt2), (elt3) }; \\\n+  compare64(N, &v, \\\n+            ((long long)(elt0) << 48) | \\\n+\t    ((long long)(elt1) << 32) | \\\n+            ((long long)(elt2) << 16) | \\\n+            ((long long)(elt3))); \\\n+}\n+\n+V4HI_TEST(1, a, a, a, a)\n+V4HI_TEST(2, a, b, c, d)\n+V4HI_TEST(3, a, a, b, b)\n+V4HI_TEST(4, d, c, b, a)\n+V4HI_TEST(5, a, 0, 0, 0)\n+V4HI_TEST(6, a, 0, b, 0)\n+V4HI_TEST(7, c, 5, 5, 5)\n+V4HI_TEST(8, d, 6, a, 6)\n+V4HI_TEST(9, 0x200, 0x300, 0x500, 0x8800)\n+V4HI_TEST(10, 0x600, a, a, a)\n+\n+unsigned short a16 = 0x3344;\n+unsigned short b16 = 0x5566;\n+unsigned short c16 = 0x7788;\n+unsigned short d16 = 0x9911;\n+\n+int main(void)\n+{\n+  test_v2hi_1 (a16, b16);\n+  test_v2hi_2 (a16, b16);\n+  test_v2hi_3 (a16, b16);\n+  test_v2hi_4 (a16, b16);\n+  test_v2hi_5 (a16, b16);\n+  test_v2hi_6 (a16, b16);\n+  test_v2hi_7 (a16, b16);\n+  test_v2hi_8 (a16, b16);\n+  test_v2hi_9 (a16, b16);\n+  test_v2hi_10 (a16, b16);\n+\n+  test_v4hi_1 (a16, b16, c16, d16);\n+  test_v4hi_2 (a16, b16, c16, d16);\n+  test_v4hi_3 (a16, b16, c16, d16);\n+  test_v4hi_4 (a16, b16, c16, d16);\n+  test_v4hi_5 (a16, b16, c16, d16);\n+  test_v4hi_6 (a16, b16, c16, d16);\n+  test_v4hi_7 (a16, b16, c16, d16);\n+  test_v4hi_8 (a16, b16, c16, d16);\n+  test_v4hi_9 (a16, b16, c16, d16);\n+  test_v4hi_10 (a16, b16, c16, d16);\n+  return 0;\n+}"}, {"sha": "6c826108c2954e9a50acac23d8479cd1ed893776", "filename": "gcc/testsuite/gcc.target/sparc/vec-init-3-vis1.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79cad86dca731ab4d8d0ea57e3436a4c7eca224d/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fvec-init-3-vis1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79cad86dca731ab4d8d0ea57e3436a4c7eca224d/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fvec-init-3-vis1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fvec-init-3-vis1.c?ref=79cad86dca731ab4d8d0ea57e3436a4c7eca224d", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target ultrasparc_hw } */\n+/* { dg-options \"-mcpu=ultrasparc -mvis -O2\" } */\n+\n+#include \"vec-init-3.inc\""}, {"sha": "6424e2f159285d1e5cf7bafc8b0d00b9ac236c6d", "filename": "gcc/testsuite/gcc.target/sparc/vec-init-3-vis2.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79cad86dca731ab4d8d0ea57e3436a4c7eca224d/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fvec-init-3-vis2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79cad86dca731ab4d8d0ea57e3436a4c7eca224d/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fvec-init-3-vis2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fvec-init-3-vis2.c?ref=79cad86dca731ab4d8d0ea57e3436a4c7eca224d", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target ultrasparc_vis2_hw } */\n+/* { dg-options \"-mcpu=ultrasparc3 -O2\" } */\n+\n+#include \"vec-init-3.inc\""}, {"sha": "226c108c5e5b9e2810f1c1d0be7cbcef5a7ab41b", "filename": "gcc/testsuite/gcc.target/sparc/vec-init-3-vis3.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79cad86dca731ab4d8d0ea57e3436a4c7eca224d/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fvec-init-3-vis3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79cad86dca731ab4d8d0ea57e3436a4c7eca224d/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fvec-init-3-vis3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fvec-init-3-vis3.c?ref=79cad86dca731ab4d8d0ea57e3436a4c7eca224d", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target ultrasparc_vis3_hw } */\n+/* { dg-options \"-mcpu=niagara3 -O2\" } */\n+\n+#include \"vec-init-3.inc\""}, {"sha": "8a3db2600a606db828f0200f654d6133490ccbe2", "filename": "gcc/testsuite/gcc.target/sparc/vec-init-3.inc", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79cad86dca731ab4d8d0ea57e3436a4c7eca224d/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fvec-init-3.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79cad86dca731ab4d8d0ea57e3436a4c7eca224d/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fvec-init-3.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fvec-init-3.inc?ref=79cad86dca731ab4d8d0ea57e3436a4c7eca224d", "patch": "@@ -0,0 +1,105 @@\n+typedef unsigned char __v4qi __attribute__ ((__vector_size__ (4)));\n+typedef unsigned char __v8qi __attribute__ ((__vector_size__ (8)));\n+\n+extern void abort (void);\n+\n+static void\n+compare64 (int n, void *p, unsigned long long val)\n+{\n+  unsigned long long *x = (unsigned long long *) p;\n+\n+  if (*x != val)\n+    abort();\n+}\n+\n+static void\n+compare32 (int n, void *p, unsigned int val)\n+{\n+  unsigned int *x = (unsigned int *) p;\n+  if (*x != val)\n+    abort();\n+}\n+\n+#define V4QI_TEST(N, elt0, elt1, elt2, elt3)\t\\\n+static void \\\n+test_v4qi_##N (unsigned char a, unsigned char b, unsigned char c, unsigned char d) \\\n+{ \\\n+  __v4qi v = { (elt0), (elt1), (elt2), (elt3) };\t\\\n+  compare32(N, &v, ((int)(elt0) << 24) | \\\n+\t           ((int)(elt1) << 16) | \\\n+\t           ((int)(elt2) << 8) | ((int)(elt3)));\t\\\n+}\n+\n+V4QI_TEST(1, a, a, a, a)\n+V4QI_TEST(2, b, b, b, b)\n+V4QI_TEST(3, a, b, c, d)\n+V4QI_TEST(4, d, c, b, a)\n+V4QI_TEST(5, a, 0, 0, 0)\n+V4QI_TEST(6, b, 1, 1, b)\n+V4QI_TEST(7, c, 5, d, 5)\n+V4QI_TEST(8, 0x20, 0x30, b, a)\n+V4QI_TEST(9, 0x40, 0x50, 0x60, 0x70)\n+V4QI_TEST(10, 0x40, 0x50, 0x60, c)\n+\n+#define V8QI_TEST(N, elt0, elt1, elt2, elt3, elt4, elt5, elt6, elt7) \\\n+static void \\\n+test_v8qi_##N (unsigned char a, unsigned char b, unsigned char c, unsigned char d, \\\n+               unsigned char e, unsigned char f, unsigned char g, unsigned char h) \\\n+{ \\\n+  __v8qi v = { (elt0), (elt1), (elt2), (elt3), \\\n+\t       (elt4), (elt5), (elt6), (elt7) }; \\\n+  compare64(N, &v, ((long long)(elt0) << 56) | \\\n+\t           ((long long)(elt1) << 48) | \\\n+\t           ((long long)(elt2) << 40) | \\\n+\t           ((long long)(elt3) << 32) | \\\n+\t           ((long long)(elt4) << 24) | \\\n+\t           ((long long)(elt5) << 16) | \\\n+\t           ((long long)(elt6) << 8) | \\\n+\t           ((long long)(elt7) << 0)); \\\n+}\n+\n+V8QI_TEST(1, a, a, a, a, a, a, a, a)\n+V8QI_TEST(2, a, b, c, d, e, f, g, h)\n+V8QI_TEST(3, h, g, f, e, d, c, b, a)\n+V8QI_TEST(4, a, b, a, b, a, b, a, b)\n+V8QI_TEST(5, c, b, c, b, c, b, c, a)\n+V8QI_TEST(6, a, 0, 0, 0, 0, 0, 0, 0)\n+V8QI_TEST(7, b, 1, b, 1, b, 1, b, 1)\n+V8QI_TEST(8, c, d, 0x20, a, 0x21, b, 0x23, c)\n+V8QI_TEST(9, 1, 2, 3, 4, 5, 6, 7, 8)\n+V8QI_TEST(10, a, a, b, b, c, c, d, d)\n+\n+unsigned char a8 = 0x33;\n+unsigned char b8 = 0x55;\n+unsigned char c8 = 0x77;\n+unsigned char d8 = 0x99;\n+unsigned char e8 = 0x11;\n+unsigned char f8 = 0x22;\n+unsigned char g8 = 0x44;\n+unsigned char h8 = 0x66;\n+\n+int main(void)\n+{\n+  test_v4qi_1 (a8, b8, c8, d8);\n+  test_v4qi_2 (a8, b8, c8, d8);\n+  test_v4qi_3 (a8, b8, c8, d8);\n+  test_v4qi_4 (a8, b8, c8, d8);\n+  test_v4qi_5 (a8, b8, c8, d8);\n+  test_v4qi_6 (a8, b8, c8, d8);\n+  test_v4qi_7 (a8, b8, c8, d8);\n+  test_v4qi_8 (a8, b8, c8, d8);\n+  test_v4qi_9 (a8, b8, c8, d8);\n+  test_v4qi_10 (a8, b8, c8, d8);\n+\n+  test_v8qi_1 (a8, b8, c8, d8, e8, f8, g8, h8);\n+  test_v8qi_2 (a8, b8, c8, d8, e8, f8, g8, h8);\n+  test_v8qi_3 (a8, b8, c8, d8, e8, f8, g8, h8);\n+  test_v8qi_4 (a8, b8, c8, d8, e8, f8, g8, h8);\n+  test_v8qi_5 (a8, b8, c8, d8, e8, f8, g8, h8);\n+  test_v8qi_6 (a8, b8, c8, d8, e8, f8, g8, h8);\n+  test_v8qi_7 (a8, b8, c8, d8, e8, f8, g8, h8);\n+  test_v8qi_8 (a8, b8, c8, d8, e8, f8, g8, h8);\n+  test_v8qi_9 (a8, b8, c8, d8, e8, f8, g8, h8);\n+  test_v8qi_10 (a8, b8, c8, d8, e8, f8, g8, h8);\n+  return 0;\n+}"}, {"sha": "1ba71f0c54123a1ea9fcfbf8da6eb3f4055214bc", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79cad86dca731ab4d8d0ea57e3436a4c7eca224d/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79cad86dca731ab4d8d0ea57e3436a4c7eca224d/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=79cad86dca731ab4d8d0ea57e3436a4c7eca224d", "patch": "@@ -2449,6 +2449,24 @@ proc check_effective_target_ultrasparc_hw { } {\n     } \"-mcpu=ultrasparc\"]\n }\n \n+# Return 1 if the test environment supports executing UltraSPARC VIS2\n+# instructions.  We check this by attempting: \"bmask %g0, %g0, %g0\"\n+\n+proc check_effective_target_ultrasparc_vis2_hw { } {\n+    return [check_runtime ultrasparc_hw {\n+\tint main() { __asm__(\".word 0x81b00320\"); return 0; }\n+    } \"-mcpu=ultrasparc3\"]\n+}\n+\n+# Return 1 if the test environment supports executing UltraSPARC VIS3\n+# instructions.  We check this by attempting: \"addxc %g0, %g0, %g0\"\n+\n+proc check_effective_target_ultrasparc_vis3_hw { } {\n+    return [check_runtime ultrasparc_hw {\n+\tint main() { __asm__(\".word 0x81b00220\"); return 0; }\n+    } \"-mcpu=niagara3\"]\n+}\n+\n # Return 1 if the target supports hardware vector shift operation.\n \n proc check_effective_target_vect_shift { } {"}]}