{"sha": "0284b52ec9c54f2071f3f71cd994c2bf49b38639", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDI4NGI1MmVjOWM1NGYyMDcxZjNmNzFjZDk5NGMyYmY0OWIzODYzOQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2013-12-06T14:48:17Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2013-12-06T14:48:17Z"}, "message": "elf.c (ET_DYN): Undefine and define again.\n\n\t* elf.c (ET_DYN): Undefine and define again.\n\t(elf_add): Add exe argument, if true and ehdr.e_type is ET_DYN,\n\treturn early -1 without closing the descriptor.\n\t(struct phdr_data): Add exe_descriptor.\n\t(phdr_callback): If pd->exe_descriptor is not -1, for very first\n\tcall if dlpi_name is NULL just call elf_add with the exe_descriptor,\n\totherwise backtrace_close the exe_descriptor if not -1.  Adjust\n\tcall to elf_add.\n\t(backtrace_initialize): Adjust call to elf_add.  If it returns\n\t-1, set pd.exe_descriptor to descriptor, otherwise set it to -1.\n\nFrom-SVN: r205748", "tree": {"sha": "62e73fccfcd14dbc8f71e874338ac6901fd4adb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62e73fccfcd14dbc8f71e874338ac6901fd4adb0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0284b52ec9c54f2071f3f71cd994c2bf49b38639", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0284b52ec9c54f2071f3f71cd994c2bf49b38639", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0284b52ec9c54f2071f3f71cd994c2bf49b38639", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0284b52ec9c54f2071f3f71cd994c2bf49b38639/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "26c096c3a397a9b7ae7d5a0efea8ed115c3a8ee9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26c096c3a397a9b7ae7d5a0efea8ed115c3a8ee9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26c096c3a397a9b7ae7d5a0efea8ed115c3a8ee9"}], "stats": {"total": 67, "additions": 56, "deletions": 11}, "files": [{"sha": "0c41f0135c41395e817554381b3df879d2070b24", "filename": "libbacktrace/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0284b52ec9c54f2071f3f71cd994c2bf49b38639/libbacktrace%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0284b52ec9c54f2071f3f71cd994c2bf49b38639/libbacktrace%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2FChangeLog?ref=0284b52ec9c54f2071f3f71cd994c2bf49b38639", "patch": "@@ -1,3 +1,16 @@\n+2013-12-06  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* elf.c (ET_DYN): Undefine and define again.\n+\t(elf_add): Add exe argument, if true and ehdr.e_type is ET_DYN,\n+\treturn early -1 without closing the descriptor.\n+\t(struct phdr_data): Add exe_descriptor.\n+\t(phdr_callback): If pd->exe_descriptor is not -1, for very first\n+\tcall if dlpi_name is NULL just call elf_add with the exe_descriptor,\n+\totherwise backtrace_close the exe_descriptor if not -1.  Adjust\n+\tcall to elf_add.\n+\t(backtrace_initialize): Adjust call to elf_add.  If it returns\n+\t-1, set pd.exe_descriptor to descriptor, otherwise set it to -1.\n+\n 2013-12-05  Ian Lance Taylor  <iant@google.com>\n \n \t* alloc.c (backtrace_vector_finish): Add error_callback and data"}, {"sha": "c7e646744dd7554b46b5c94f8b7b002ea1bb5adc", "filename": "libbacktrace/elf.c", "status": "modified", "additions": 43, "deletions": 11, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0284b52ec9c54f2071f3f71cd994c2bf49b38639/libbacktrace%2Felf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0284b52ec9c54f2071f3f71cd994c2bf49b38639/libbacktrace%2Felf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Felf.c?ref=0284b52ec9c54f2071f3f71cd994c2bf49b38639", "patch": "@@ -96,6 +96,7 @@ dl_iterate_phdr (int (*callback) (struct dl_phdr_info *,\n #undef ELFDATA2LSB\n #undef ELFDATA2MSB\n #undef EV_CURRENT\n+#undef ET_DYN\n #undef SHN_LORESERVE\n #undef SHN_XINDEX\n #undef SHN_UNDEF\n@@ -171,6 +172,8 @@ typedef struct {\n \n #define EV_CURRENT 1\n \n+#define ET_DYN 3\n+\n typedef struct {\n   b_elf_word\tsh_name;\t\t/* Section name, index in string tbl */\n   b_elf_word\tsh_type;\t\t/* Type of section */\n@@ -507,12 +510,16 @@ elf_syminfo (struct backtrace_state *state, uintptr_t addr,\n     callback (data, addr, sym->name, sym->address, sym->size);\n }\n \n-/* Add the backtrace data for one ELF file.  */\n+/* Add the backtrace data for one ELF file.  Returns 1 on success,\n+   0 on failure (in both cases descriptor is closed) or -1 if exe\n+   is non-zero and the ELF file is ET_DYN, which tells the caller that\n+   elf_add will need to be called on the descriptor again after\n+   base_address is determined.  */\n \n static int\n elf_add (struct backtrace_state *state, int descriptor, uintptr_t base_address,\n \t backtrace_error_callback error_callback, void *data,\n-\t fileline *fileline_fn, int *found_sym, int *found_dwarf)\n+\t fileline *fileline_fn, int *found_sym, int *found_dwarf, int exe)\n {\n   struct backtrace_view ehdr_view;\n   b_elf_ehdr ehdr;\n@@ -591,6 +598,12 @@ elf_add (struct backtrace_state *state, int descriptor, uintptr_t base_address,\n       goto fail;\n     }\n \n+  /* If the executable is ET_DYN, it is either a PIE, or we are running\n+     directly a shared library with .interp.  We need to wait for\n+     dl_iterate_phdr in that case to determine the actual base_address.  */\n+  if (exe && ehdr.e_type == ET_DYN)\n+    return -1;\n+\n   shoff = ehdr.e_shoff;\n   shnum = ehdr.e_shnum;\n   shstrndx = ehdr.e_shstrndx;\n@@ -847,6 +860,7 @@ struct phdr_data\n   fileline *fileline_fn;\n   int *found_sym;\n   int *found_dwarf;\n+  int exe_descriptor;\n };\n \n /* Callback passed to dl_iterate_phdr.  Load debug info from shared\n@@ -862,17 +876,32 @@ phdr_callback (struct dl_phdr_info *info, size_t size ATTRIBUTE_UNUSED,\n   fileline elf_fileline_fn;\n   int found_dwarf;\n \n-  /* There is not much we can do if we don't have the module name.  */\n+  /* There is not much we can do if we don't have the module name,\n+     unless executable is ET_DYN, where we expect the very first\n+     phdr_callback to be for the PIE.  */\n   if (info->dlpi_name == NULL || info->dlpi_name[0] == '\\0')\n-    return 0;\n+    {\n+      if (pd->exe_descriptor == -1)\n+\treturn 0;\n+      descriptor = pd->exe_descriptor;\n+      pd->exe_descriptor = -1;\n+    }\n+  else\n+    {\n+      if (pd->exe_descriptor != -1)\n+\t{\n+\t  backtrace_close (pd->exe_descriptor, pd->error_callback, pd->data);\n+\t  pd->exe_descriptor = -1;\n+\t}\n \n-  descriptor = backtrace_open (info->dlpi_name, pd->error_callback, pd->data,\n-\t\t\t       &does_not_exist);\n-  if (descriptor < 0)\n-    return 0;\n+      descriptor = backtrace_open (info->dlpi_name, pd->error_callback,\n+\t\t\t\t   pd->data, &does_not_exist);\n+      if (descriptor < 0)\n+\treturn 0;\n+    }\n \n   if (elf_add (pd->state, descriptor, info->dlpi_addr, pd->error_callback,\n-\t       pd->data, &elf_fileline_fn, pd->found_sym, &found_dwarf))\n+\t       pd->data, &elf_fileline_fn, pd->found_sym, &found_dwarf, 0))\n     {\n       if (found_dwarf)\n \t{\n@@ -893,13 +922,15 @@ backtrace_initialize (struct backtrace_state *state, int descriptor,\n \t\t      backtrace_error_callback error_callback,\n \t\t      void *data, fileline *fileline_fn)\n {\n+  int ret;\n   int found_sym;\n   int found_dwarf;\n   fileline elf_fileline_fn;\n   struct phdr_data pd;\n \n-  if (!elf_add (state, descriptor, 0, error_callback, data, &elf_fileline_fn,\n-\t\t&found_sym, &found_dwarf))\n+  ret = elf_add (state, descriptor, 0, error_callback, data, &elf_fileline_fn,\n+\t\t &found_sym, &found_dwarf, 1);\n+  if (!ret)\n     return 0;\n \n   pd.state = state;\n@@ -908,6 +939,7 @@ backtrace_initialize (struct backtrace_state *state, int descriptor,\n   pd.fileline_fn = &elf_fileline_fn;\n   pd.found_sym = &found_sym;\n   pd.found_dwarf = &found_dwarf;\n+  pd.exe_descriptor = ret < 0 ? descriptor : -1;\n \n   dl_iterate_phdr (phdr_callback, (void *) &pd);\n "}]}