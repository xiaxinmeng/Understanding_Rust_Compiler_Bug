{"sha": "210ac0b75b991788e1de7989fe7ea6d86bf41ab3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjEwYWMwYjc1Yjk5MTc4OGUxZGU3OTg5ZmU3ZWE2ZDg2YmY0MWFiMw==", "commit": {"author": {"name": "Andrew Pinski", "email": "apinski@cavium.com", "date": "2012-03-09T09:27:29Z"}, "committer": {"name": "Andrew Pinski", "email": "pinskia@gcc.gnu.org", "date": "2012-03-09T09:27:29Z"}, "message": "re PR tree-optimization/51988 (value_replacement in PHIOPT should handle even the cases where there are other PHIs even with non equal value)\n\n2012-03-09  Andrew Pinski  <apinski@cavium.com>\n\n\tPR middle-end/51988\n\t* tree-ssa-phiopt.c: Include tree-pretty-print.h for\n\tprint_generic_expr.\n\t(tree_ssa_phiopt_worker): Go through all the PHIs for\n\tvalue_replacement instead of just the singleton one.\n\t(value_replacement): Change return type to int.  Return 0 instead of\n\tfalse.\n\tAllow the middle basic block to contain more than just the definings\n\ttatement. \n\tHandle non empty middle basic blocks.\n\t* Makefile.in (tree-ssa-phiopt.o): Add tree-pretty-print.h.\n\n2012-03-09  Andrew Pinski  <apinski@cavium.com>\n\n\tPR middle-end/51988\n\t* gcc.dg/tree-ssa/phi-opt-8.c: New testcase.\n\t* gcc.dg/tree-ssa/phi-opt-9.c: New testcase.\n\nFrom-SVN: r185131", "tree": {"sha": "8ce1b024cb971a3bad7d160a1f7a85d3d1302029", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8ce1b024cb971a3bad7d160a1f7a85d3d1302029"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/210ac0b75b991788e1de7989fe7ea6d86bf41ab3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/210ac0b75b991788e1de7989fe7ea6d86bf41ab3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/210ac0b75b991788e1de7989fe7ea6d86bf41ab3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/210ac0b75b991788e1de7989fe7ea6d86bf41ab3/comments", "author": {"login": "apinski-cavium", "id": 6335315, "node_id": "MDQ6VXNlcjYzMzUzMTU=", "avatar_url": "https://avatars.githubusercontent.com/u/6335315?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apinski-cavium", "html_url": "https://github.com/apinski-cavium", "followers_url": "https://api.github.com/users/apinski-cavium/followers", "following_url": "https://api.github.com/users/apinski-cavium/following{/other_user}", "gists_url": "https://api.github.com/users/apinski-cavium/gists{/gist_id}", "starred_url": "https://api.github.com/users/apinski-cavium/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apinski-cavium/subscriptions", "organizations_url": "https://api.github.com/users/apinski-cavium/orgs", "repos_url": "https://api.github.com/users/apinski-cavium/repos", "events_url": "https://api.github.com/users/apinski-cavium/events{/privacy}", "received_events_url": "https://api.github.com/users/apinski-cavium/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bef28cedad5f74cca2b71b7c25ed98fc5c99021d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bef28cedad5f74cca2b71b7c25ed98fc5c99021d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bef28cedad5f74cca2b71b7c25ed98fc5c99021d"}], "stats": {"total": 174, "additions": 139, "deletions": 35}, "files": [{"sha": "1bce1c7a68551b1443577ca9f9f24efc156e8ce9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/210ac0b75b991788e1de7989fe7ea6d86bf41ab3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/210ac0b75b991788e1de7989fe7ea6d86bf41ab3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=210ac0b75b991788e1de7989fe7ea6d86bf41ab3", "patch": "@@ -1,3 +1,17 @@\n+2012-03-09  Andrew Pinski  <apinski@cavium.com>\n+\n+\tPR middle-end/51988\n+\t* tree-ssa-phiopt.c: Include tree-pretty-print.h for\n+\tprint_generic_expr.\n+\t(tree_ssa_phiopt_worker): Go through all the PHIs for\n+\tvalue_replacement instead of just the singleton one.\n+\t(value_replacement): Change return type to int.  Return 0 instead of\n+\tfalse.\n+\tAllow the middle basic block to contain more than just the definings\n+\ttatement. \n+\tHandle non empty middle basic blocks.\n+\t* Makefile.in (tree-ssa-phiopt.o): Add tree-pretty-print.h.\n+\n 2012-03-09  Jiangning Liu  <jiangning.liu@arm.com>\n \n \t* tree-scalar-evolution (interpret_rhs_expr): generate chrec for"}, {"sha": "b5190991180c660831569bd910918d9435b72b11", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/210ac0b75b991788e1de7989fe7ea6d86bf41ab3/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/210ac0b75b991788e1de7989fe7ea6d86bf41ab3/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=210ac0b75b991788e1de7989fe7ea6d86bf41ab3", "patch": "@@ -2355,7 +2355,7 @@ tree-ssa-phiopt.o : tree-ssa-phiopt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(GGC_H) $(TREE_H) $(TM_P_H) $(BASIC_BLOCK_H) \\\n    $(TREE_FLOW_H) $(TREE_PASS_H) $(TREE_DUMP_H) langhooks.h $(FLAGS_H) \\\n    $(DIAGNOSTIC_H) $(TIMEVAR_H) pointer-set.h domwalk.h $(CFGLOOP_H) \\\n-   $(TREE_DATA_REF_H)\n+   $(TREE_DATA_REF_H) tree-pretty-print.h\n tree-nrv.o : tree-nrv.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(TREE_H) $(FUNCTION_H) $(BASIC_BLOCK_H) $(FLAGS_H) \\\n    $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TIMEVAR_H) $(TREE_DUMP_H) $(TREE_PASS_H) \\"}, {"sha": "f1c9845d942e1f7a06a4874e0260c6e0b496972e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/210ac0b75b991788e1de7989fe7ea6d86bf41ab3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/210ac0b75b991788e1de7989fe7ea6d86bf41ab3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=210ac0b75b991788e1de7989fe7ea6d86bf41ab3", "patch": "@@ -1,3 +1,9 @@\n+2012-03-09  Andrew Pinski  <apinski@cavium.com>\n+\n+\tPR middle-end/51988\n+\t* gcc.dg/tree-ssa/phi-opt-8.c: New testcase.\n+\t* gcc.dg/tree-ssa/phi-opt-9.c: New testcase.\n+\n 2012-03-09  Jiangning Liu  <jiangning.liu@arm.com>\n \n \t* gcc.dg/tree-ssa/scev-3.c: New."}, {"sha": "31dab46a79595d05674f410aa1b358f57bab905c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/phi-opt-8.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/210ac0b75b991788e1de7989fe7ea6d86bf41ab3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fphi-opt-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/210ac0b75b991788e1de7989fe7ea6d86bf41ab3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fphi-opt-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fphi-opt-8.c?ref=210ac0b75b991788e1de7989fe7ea6d86bf41ab3", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-optimized -fdump-tree-phiopt1\" } */\n+\n+int g(int,int);\n+int f(int t, int c)\n+{\n+  int d = 0;\n+  int e = 0;\n+  if (t)\n+    {\n+      d = 1;\n+      e = t;\n+    }\n+  else d = 0, e = 0;\n+  return g(e,d);\n+}\n+\n+/* This testcase should be reduced to e = t; d = t != 0; in phiopt1\n+   but currently is not as PHI-OPT does not reduce the t PHI as we have\n+   two phis.  Note this is fixed with\n+   http://gcc.gnu.org/ml/gcc-patches/2012-01/msg01195.html .  */\n+/* { dg-final { scan-tree-dump-not \"if\" \"phiopt1\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump \"g .t_\\[0-9\\]*.D.,\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-not \"PHI\" \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"phiopt1\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "dccea7b050647f002b500a2c7a1b942938b41663", "filename": "gcc/testsuite/gcc.dg/tree-ssa/phi-opt-9.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/210ac0b75b991788e1de7989fe7ea6d86bf41ab3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fphi-opt-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/210ac0b75b991788e1de7989fe7ea6d86bf41ab3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fphi-opt-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fphi-opt-9.c?ref=210ac0b75b991788e1de7989fe7ea6d86bf41ab3", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-optimized\" } */\n+\n+int g(int,int);\n+int f(int t, int c)\n+{\n+  int d = 0;\n+  int e = 0;\n+  if (t)\n+    {\n+      d = c+1;\n+      e = t;\n+    }\n+  else d = 0, e = 0;\n+  return g(e,d);\n+}\n+\n+/* The value e should have been replaced with t and there should be only one PHI. */\n+/* { dg-final { scan-tree-dump \"g .t_\\[0-9\\]*.D.,\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"PHI\" 1 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "c195e3bcc4d7ae58dce2ac98c5306dd99e9759f5", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 71, "deletions": 34, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/210ac0b75b991788e1de7989fe7ea6d86bf41ab3/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/210ac0b75b991788e1de7989fe7ea6d86bf41ab3/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=210ac0b75b991788e1de7989fe7ea6d86bf41ab3", "patch": "@@ -36,13 +36,14 @@ along with GCC; see the file COPYING3.  If not see\n #include \"domwalk.h\"\n #include \"cfgloop.h\"\n #include \"tree-data-ref.h\"\n+#include \"tree-pretty-print.h\"\n \n static unsigned int tree_ssa_phiopt (void);\n static unsigned int tree_ssa_phiopt_worker (bool);\n static bool conditional_replacement (basic_block, basic_block,\n \t\t\t\t     edge, edge, gimple, tree, tree);\n-static bool value_replacement (basic_block, basic_block,\n-\t\t\t       edge, edge, gimple, tree, tree);\n+static int value_replacement (basic_block, basic_block,\n+\t\t\t      edge, edge, gimple, tree, tree);\n static bool minmax_replacement (basic_block, basic_block,\n \t\t\t\tedge, edge, gimple, tree, tree);\n static bool abs_replacement (basic_block, basic_block,\n@@ -314,7 +315,24 @@ tree_ssa_phiopt_worker (bool do_store_elim)\n \t{\n \t  gimple_seq phis = phi_nodes (bb2);\n \t  gimple_stmt_iterator gsi;\n+\t  bool candorest = true;\n+\t  /* Value replacement can work with more than one PHI\n+\t     so try that first. */\n+\t  for (gsi = gsi_start (phis); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t    {\n+\t      phi = gsi_stmt (gsi);\n+\t      arg0 = gimple_phi_arg_def (phi, e1->dest_idx);\n+\t      arg1 = gimple_phi_arg_def (phi, e2->dest_idx);\n+\t      if (value_replacement (bb, bb1, e1, e2, phi, arg0, arg1) == 2)\n+\t\t{\n+\t\t  candorest = false;\n+\t          cfgchanged = true;\n+\t\t  break;\n+\t\t}\n+\t    }\n \n+\t  if (!candorest)\n+\t    continue;\n \t  /* Check to make sure that there is only one non-virtual PHI node.\n \t     TODO: we could do it with more than one iff the other PHI nodes\n \t     have the same elements for these two edges.  */\n@@ -343,8 +361,6 @@ tree_ssa_phiopt_worker (bool do_store_elim)\n \t  /* Do the replacement of conditional if it can be done.  */\n \t  if (conditional_replacement (bb, bb1, e1, e2, phi, arg0, arg1))\n \t    cfgchanged = true;\n-\t  else if (value_replacement (bb, bb1, e1, e2, phi, arg0, arg1))\n-\t    cfgchanged = true;\n \t  else if (abs_replacement (bb, bb1, e1, e2, phi, arg0, arg1))\n \t    cfgchanged = true;\n \t  else if (minmax_replacement (bb, bb1, e1, e2, phi, arg0, arg1))\n@@ -624,12 +640,12 @@ jump_function_from_stmt (tree *arg, gimple stmt)\n }\n \n /*  The function value_replacement does the main work of doing the value\n-    replacement.  Return true if the replacement is done.  Otherwise return\n-    false.\n+    replacement.  Return non-zero if the replacement is done.  Otherwise return\n+    0.  If we remove the middle basic block, return 2.\n     BB is the basic block where the replacement is going to be done on.  ARG0\n     is argument 0 from the PHI.  Likewise for ARG1.  */\n \n-static bool\n+static int\n value_replacement (basic_block cond_bb, basic_block middle_bb,\n \t\t   edge e0, edge e1, gimple phi,\n \t\t   tree arg0, tree arg1)\n@@ -638,45 +654,44 @@ value_replacement (basic_block cond_bb, basic_block middle_bb,\n   gimple cond;\n   edge true_edge, false_edge;\n   enum tree_code code;\n+  bool emtpy_or_with_defined_p = true;\n \n   /* If the type says honor signed zeros we cannot do this\n      optimization.  */\n   if (HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (arg1))))\n-    return false;\n+    return 0;\n \n-  /* Allow a single statement in MIDDLE_BB that defines one of the PHI\n-     arguments.  */\n+  /* If there is a statement in MIDDLE_BB that defines one of the PHI\n+     arguments, then adjust arg0 or arg1.  */\n   gsi = gsi_after_labels (middle_bb);\n-  if (!gsi_end_p (gsi))\n+  if (!gsi_end_p (gsi) && is_gimple_debug (gsi_stmt (gsi)))\n+    gsi_next_nondebug (&gsi);\n+  while (!gsi_end_p (gsi))\n     {\n-      if (is_gimple_debug (gsi_stmt (gsi)))\n-\tgsi_next_nondebug (&gsi);\n-      if (!gsi_end_p (gsi))\n+      gimple stmt = gsi_stmt (gsi);\n+      tree lhs;\n+      gsi_next_nondebug (&gsi);\n+      if (!is_gimple_assign (stmt))\n \t{\n-\t  gimple stmt = gsi_stmt (gsi);\n-\t  tree lhs;\n-\t  gsi_next_nondebug (&gsi);\n-\t  if (!gsi_end_p (gsi))\n-\t    return false;\n-\t  if (!is_gimple_assign (stmt))\n-\t    return false;\n-\t  /* Now try to adjust arg0 or arg1 according to the computation\n-\t     in the single statement.  */\n-\t  lhs = gimple_assign_lhs (stmt);\n-\t  if (!((lhs == arg0\n-\t\t && jump_function_from_stmt (&arg0, stmt))\n-\t\t|| (lhs == arg1\n-\t\t    && jump_function_from_stmt (&arg1, stmt))))\n-\t    return false;\n+\t  emtpy_or_with_defined_p = false;\n+\t  continue;\n \t}\n+      /* Now try to adjust arg0 or arg1 according to the computation\n+\t in the statement.  */\n+      lhs = gimple_assign_lhs (stmt);\n+      if (!(lhs == arg0\n+\t     && jump_function_from_stmt (&arg0, stmt))\n+\t    || (lhs == arg1\n+\t\t&& jump_function_from_stmt (&arg1, stmt)))\n+\temtpy_or_with_defined_p = false;\n     }\n \n   cond = last_stmt (cond_bb);\n   code = gimple_cond_code (cond);\n \n   /* This transformation is only valid for equality comparisons.  */\n   if (code != NE_EXPR && code != EQ_EXPR)\n-    return false;\n+    return 0;\n \n   /* We need to know which is the true edge and which is the false\n       edge so that we know if have abs or negative abs.  */\n@@ -720,12 +735,34 @@ value_replacement (basic_block cond_bb, basic_block middle_bb,\n       else\n \targ = arg1;\n \n-      replace_phi_edge_with_variable (cond_bb, e1, phi, arg);\n+      /* If the middle basic block was empty or is defining the\n+\t PHI arguments and this is a singleton phi then we can remove\n+         the middle basic block. */\n+      if (emtpy_or_with_defined_p\n+\t  && gimple_seq_singleton_p (phi_nodes (gimple_bb (phi))))\n+\t{\n+          replace_phi_edge_with_variable (cond_bb, e1, phi, arg);\n+\t  /* Note that we optimized this PHI.  */\n+\t  return 2;\n+\t}\n+      else\n+\t{\n+\t  /* Replace the PHI arguments with arg. */\n+\t  SET_PHI_ARG_DEF (phi, e0->dest_idx, arg);\n+\t  SET_PHI_ARG_DEF (phi, e1->dest_idx, arg);\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"PHI \");\n+\t      print_generic_expr (dump_file, gimple_phi_result (phi), 0);\n+\t      fprintf (dump_file, \" reduced for COND_EXPR in block %d to \", cond_bb->index);\n+\t      print_generic_expr (dump_file, arg, 0);\n+\t      fprintf (dump_file, \".\\n\");\n+            }\n+          return 1;\n+\t}\n \n-      /* Note that we optimized this PHI.  */\n-      return true;\n     }\n-  return false;\n+  return 0;\n }\n \n /*  The function minmax_replacement does the main work of doing the minmax"}]}