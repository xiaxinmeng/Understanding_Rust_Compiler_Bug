{"sha": "2052721560b2329471c637b4d20f8fef44363004", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjA1MjcyMTU2MGIyMzI5NDcxYzYzN2I0ZDIwZjhmZWY0NDM2MzAwNA==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2006-08-17T08:22:05Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2006-08-17T08:22:05Z"}, "message": "re PR tree-optimization/27865 (tree check failure building FreePOOMA)\n\n\tPR tree-optimization/27865\n\t* tree-vrp.c (adjust_range_with_scev): Do not use TYPE_{MIN,MAX}_VALUE\n\tfor pointer types.\n\t* tree-scalar-evolution.c (fold_used_pointer_cast, pointer_offset_p,\n\tfold_used_pointer, pointer_used_p): New functions.\n\t(analyze_scalar_evolution_1): Use fold_used_pointer.\n\t* tree-chrec.c (convert_affine_scev): Convert no-op casts correctly.\n\t* tree-ssa-loop-ivopts.c (generic_type_for): Return integral type\n\tfor pointers.\n\nFrom-SVN: r116213", "tree": {"sha": "c20e13777a5de4b4baf2a2a1fb88f0351d8a1b0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c20e13777a5de4b4baf2a2a1fb88f0351d8a1b0e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2052721560b2329471c637b4d20f8fef44363004", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2052721560b2329471c637b4d20f8fef44363004", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2052721560b2329471c637b4d20f8fef44363004", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2052721560b2329471c637b4d20f8fef44363004/comments", "author": null, "committer": null, "parents": [{"sha": "b646edb85c5be9813851a21cddf0e9472d4023c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b646edb85c5be9813851a21cddf0e9472d4023c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b646edb85c5be9813851a21cddf0e9472d4023c2"}], "stats": {"total": 251, "additions": 231, "deletions": 20}, "files": [{"sha": "e8c816ad80451718e5427aabe2ef4fffdb508a28", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2052721560b2329471c637b4d20f8fef44363004/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2052721560b2329471c637b4d20f8fef44363004/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2052721560b2329471c637b4d20f8fef44363004", "patch": "@@ -1,3 +1,15 @@\n+2006-08-16  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\tPR tree-optimization/27865\n+\t* tree-vrp.c (adjust_range_with_scev): Do not use TYPE_{MIN,MAX}_VALUE\n+\tfor pointer types.\n+\t* tree-scalar-evolution.c (fold_used_pointer_cast, pointer_offset_p,\n+\tfold_used_pointer, pointer_used_p): New functions.\n+\t(analyze_scalar_evolution_1): Use fold_used_pointer.\n+\t* tree-chrec.c (convert_affine_scev): Convert no-op casts correctly.\n+\t* tree-ssa-loop-ivopts.c (generic_type_for): Return integral type\n+\tfor pointers.\n+\n 2006-08-17  Paolo Bonzini <bonzini@gnu.org>\n \n \tPR c++/28573"}, {"sha": "a74a49c3972af58b56aaaeeae3f7c66c6078810a", "filename": "gcc/tree-chrec.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2052721560b2329471c637b4d20f8fef44363004/gcc%2Ftree-chrec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2052721560b2329471c637b4d20f8fef44363004/gcc%2Ftree-chrec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.c?ref=2052721560b2329471c637b4d20f8fef44363004", "patch": "@@ -1162,7 +1162,10 @@ convert_affine_scev (struct loop *loop, tree type,\n \t -- must_check_src_overflow is true, and the range of TYPE is superset\n \t    of the range of CT -- i.e., in all cases except if CT signed and\n \t    TYPE unsigned.\n-         -- both CT and TYPE have the same precision and signedness.  */\n+         -- both CT and TYPE have the same precision and signedness, and we\n+\t    verify instead that the source does not overflow (this may be\n+\t    easier than verifying it for the result, as we may use the\n+\t    information about the semantics of overflow in CT).  */\n       if (must_check_src_overflow)\n \t{\n \t  if (TYPE_UNSIGNED (type) && !TYPE_UNSIGNED (ct))\n@@ -1172,7 +1175,10 @@ convert_affine_scev (struct loop *loop, tree type,\n \t}\n       else if (TYPE_UNSIGNED (ct) == TYPE_UNSIGNED (type)\n \t       && TYPE_PRECISION (ct) == TYPE_PRECISION (type))\n-\tmust_check_rslt_overflow = false;\n+\t{\n+\t  must_check_rslt_overflow = false;\n+\t  must_check_src_overflow = true;\n+\t}\n       else\n \tmust_check_rslt_overflow = true;\n     }"}, {"sha": "13cbe42b55fdbf405d0be3c8ab8c66ee1d118489", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2052721560b2329471c637b4d20f8fef44363004/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2052721560b2329471c637b4d20f8fef44363004/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=2052721560b2329471c637b4d20f8fef44363004", "patch": "@@ -1718,6 +1718,184 @@ compute_scalar_evolution_in_loop (struct loop *wrto_loop,\n   return analyze_scalar_evolution_1 (wrto_loop, res, chrec_not_analyzed_yet);\n }\n \n+/* Folds EXPR, if it is a cast to pointer, assuming that the created\n+   polynomial_chrec does not wrap.  */\n+\n+static tree\n+fold_used_pointer_cast (tree expr)\n+{\n+  tree op;\n+  tree type, inner_type;\n+\n+  if (TREE_CODE (expr) != NOP_EXPR && TREE_CODE (expr) != CONVERT_EXPR)\n+    return expr;\n+\n+  op = TREE_OPERAND (expr, 0);\n+  if (TREE_CODE (op) != POLYNOMIAL_CHREC)\n+    return expr;\n+\n+  type = TREE_TYPE (expr);\n+  inner_type = TREE_TYPE (op);\n+\n+  if (!INTEGRAL_TYPE_P (inner_type)\n+      || TYPE_PRECISION (inner_type) != TYPE_PRECISION (type))\n+    return expr;\n+\n+  return build_polynomial_chrec (CHREC_VARIABLE (op),\n+\t\tchrec_convert (type, CHREC_LEFT (op), NULL_TREE),\n+\t\tchrec_convert (type, CHREC_RIGHT (op), NULL_TREE));\n+}\n+\n+/* Returns true if EXPR is an expression corresponding to offset of pointer\n+   in p + offset.  */\n+\n+static bool\n+pointer_offset_p (tree expr)\n+{\n+  if (TREE_CODE (expr) == INTEGER_CST)\n+    return true;\n+\n+  if ((TREE_CODE (expr) == NOP_EXPR || TREE_CODE (expr) == CONVERT_EXPR)\n+      && INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (expr, 0))))\n+    return true;\n+\n+  return false;\n+}\n+\n+/* EXPR is a scalar evolution of a pointer that is dereferenced or used in\n+   comparison.  This means that it must point to a part of some object in\n+   memory, which enables us to argue about overflows and possibly simplify\n+   the EXPR.  Returns the simplified value.\n+\n+   Currently, for\n+\n+   int i, n;\n+   int *p;\n+\n+   for (i = -n; i < n; i++)\n+     *(p + i) = ...;\n+\n+   We generate the following code (assuming that size of int and size_t is\n+   4 bytes):\n+\n+   for (i = -n; i < n; i++)\n+     {\n+       size_t tmp1, tmp2;\n+       int *tmp3, *tmp4;\n+\n+       tmp1 = (size_t) i;\t(1)\n+       tmp2 = 4 * tmp1;\t\t(2)\n+       tmp3 = (int *) tmp2;\t(3)\n+       tmp4 = p + tmp3;\t\t(4)\n+\n+       *tmp4 = ...;\n+     }\n+\n+   We in general assume that pointer arithmetics does not overflow (since its\n+   behavior is undefined in that case).  One of the problems is that our\n+   translation does not capture this property very well -- (int *) is\n+   considered unsigned, hence the computation in (4) does overflow if i is\n+   negative.\n+\n+   This impreciseness creates complications in scev analysis.  The scalar\n+   evolution of i is [-n, +, 1].  Since int and size_t have the same precision\n+   (in this example), and size_t is unsigned (so we do not care about\n+   overflows), we succeed to derive that scev of tmp1 is [(size_t) -n, +, 1]\n+   and scev of tmp2 is [4 * (size_t) -n, +, 4].  With tmp3, we run into\n+   problem -- [(int *) (4 * (size_t) -n), +, 4] wraps, and since we on several\n+   places assume that this is not the case for scevs with pointer type, we\n+   cannot use this scev for tmp3; hence, its scev is\n+   (int *) [(4 * (size_t) -n), +, 4], and scev of tmp4 is\n+   p + (int *) [(4 * (size_t) -n), +, 4].  Most of the optimizers are unable to\n+   work with scevs of this shape.\n+\n+   However, since tmp4 is dereferenced, all its values must belong to a single\n+   object, and taking into account that the precision of int * and size_t is\n+   the same, it is impossible for its scev to wrap.  Hence, we can derive that\n+   its evolution is [p + (int *) (4 * (size_t) -n), +, 4], which the optimizers\n+   can work with.\n+\n+   ??? Maybe we should use different representation for pointer arithmetics,\n+   however that is a long-term project with a lot of potential for creating\n+   bugs.  */\n+\n+static tree\n+fold_used_pointer (tree expr)\n+{\n+  tree op0, op1, new0, new1;\n+  enum tree_code code = TREE_CODE (expr);\n+\n+  if (code == PLUS_EXPR\n+      || code == MINUS_EXPR)\n+    {\n+      op0 = TREE_OPERAND (expr, 0);\n+      op1 = TREE_OPERAND (expr, 1);\n+\n+      if (pointer_offset_p (op1))\n+\t{\n+\t  new0 = fold_used_pointer (op0);\n+\t  new1 = fold_used_pointer_cast (op1);\n+\t}\n+      else if (code == PLUS_EXPR && pointer_offset_p (op0))\n+\t{\n+\t  new0 = fold_used_pointer_cast (op0);\n+\t  new1 = fold_used_pointer (op1);\n+\t}\n+      else\n+\treturn expr;\n+\n+      if (new0 == op0 && new1 == op1)\n+\treturn expr;\n+\n+      if (code == PLUS_EXPR)\n+\texpr = chrec_fold_plus (TREE_TYPE (expr), new0, new1);\n+      else\n+\texpr = chrec_fold_minus (TREE_TYPE (expr), new0, new1);\n+\n+      return expr;\n+    }\n+  else\n+    return fold_used_pointer_cast (expr);\n+}\n+\n+/* Returns true if PTR is dereferenced, or used in comparison.  */\n+\n+static bool\n+pointer_used_p (tree ptr)\n+{\n+  use_operand_p use_p;\n+  imm_use_iterator imm_iter;\n+  tree stmt, rhs;\n+  struct ptr_info_def *pi = get_ptr_info (ptr);\n+  var_ann_t v_ann = var_ann (SSA_NAME_VAR (ptr));\n+\n+  /* Check whether the pointer has a memory tag; if it does, it is\n+     (or at least used to be) dereferenced.  */\n+  if ((pi != NULL && pi->name_mem_tag != NULL)\n+      || v_ann->symbol_mem_tag)\n+    return true;\n+\n+  FOR_EACH_IMM_USE_FAST (use_p, imm_iter, ptr)\n+    {\n+      stmt = USE_STMT (use_p);\n+      if (TREE_CODE (stmt) == COND_EXPR)\n+\treturn true;\n+\n+      if (TREE_CODE (stmt) != MODIFY_EXPR)\n+\tcontinue;\n+\n+      rhs = TREE_OPERAND (stmt, 1);\n+      if (!COMPARISON_CLASS_P (rhs))\n+\tcontinue;\n+\n+      if (TREE_OPERAND (stmt, 0) == ptr\n+\t  || TREE_OPERAND (stmt, 1) == ptr)\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n /* Helper recursive function.  */\n \n static tree\n@@ -1766,6 +1944,11 @@ analyze_scalar_evolution_1 (struct loop *loop, tree var, tree res)\n     {\n     case MODIFY_EXPR:\n       res = interpret_rhs_modify_expr (loop, def, TREE_OPERAND (def, 1), type);\n+\n+      if (POINTER_TYPE_P (type)\n+\t  && !automatically_generated_chrec_p (res)\n+\t  && pointer_used_p (var))\n+\tres = fold_used_pointer (res);\n       break;\n \n     case PHI_NODE:"}, {"sha": "2ead5495b7e5ad3f4d49cdc21d104088d7ddaebf", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2052721560b2329471c637b4d20f8fef44363004/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2052721560b2329471c637b4d20f8fef44363004/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=2052721560b2329471c637b4d20f8fef44363004", "patch": "@@ -1925,14 +1925,14 @@ strip_offset (tree expr, unsigned HOST_WIDE_INT *offset)\n }\n \n /* Returns variant of TYPE that can be used as base for different uses.\n-   For integer types, we return unsigned variant of the type, which\n-   avoids problems with overflows.  For pointer types, we return void *.  */\n+   We return unsigned type with the same precision, which avoids problems\n+   with overflows.  */\n \n static tree\n generic_type_for (tree type)\n {\n   if (POINTER_TYPE_P (type))\n-    return ptr_type_node;\n+    return unsigned_type_for (type);\n \n   if (TYPE_UNSIGNED (type))\n     return type;"}, {"sha": "5f53211475796bf0446e6f4c6810dbf68abfce93", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 25, "deletions": 15, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2052721560b2329471c637b4d20f8fef44363004/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2052721560b2329471c637b4d20f8fef44363004/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=2052721560b2329471c637b4d20f8fef44363004", "patch": "@@ -2015,7 +2015,7 @@ static void\n adjust_range_with_scev (value_range_t *vr, struct loop *loop, tree stmt,\n \t\t\ttree var)\n {\n-  tree init, step, chrec;\n+  tree init, step, chrec, tmin, tmax, min, max, type;\n   enum ev_direction dir;\n \n   /* TODO.  Don't adjust anti-ranges.  An anti-range may provide\n@@ -2049,13 +2049,23 @@ adjust_range_with_scev (value_range_t *vr, struct loop *loop, tree stmt,\n \t\t\t\ttrue))\n     return;\n \n-  if (!POINTER_TYPE_P (TREE_TYPE (init))\n-      && (vr->type == VR_VARYING || vr->type == VR_UNDEFINED))\n+  type = TREE_TYPE (var);\n+  if (POINTER_TYPE_P (type) || !TYPE_MIN_VALUE (type))\n+    tmin = lower_bound_in_type (type, type);\n+  else\n+    tmin = TYPE_MIN_VALUE (type);\n+  if (POINTER_TYPE_P (type) || !TYPE_MAX_VALUE (type))\n+    tmax = upper_bound_in_type (type, type);\n+  else\n+    tmax = TYPE_MAX_VALUE (type);\n+\n+  if (vr->type == VR_VARYING || vr->type == VR_UNDEFINED)\n     {\n+      min = tmin;\n+      max = tmax;\n+\n       /* For VARYING or UNDEFINED ranges, just about anything we get\n \t from scalar evolutions should be better.  */\n-      tree min = TYPE_MIN_VALUE (TREE_TYPE (init));\n-      tree max = TYPE_MAX_VALUE (TREE_TYPE (init));\n \n       if (dir == EV_DIR_DECREASES)\n \tmax = init;\n@@ -2064,16 +2074,17 @@ adjust_range_with_scev (value_range_t *vr, struct loop *loop, tree stmt,\n \n       /* If we would create an invalid range, then just assume we\n \t know absolutely nothing.  This may be over-conservative,\n-\t but it's clearly safe.  */\n+\t but it's clearly safe, and should happen only in unreachable\n+         parts of code, or for invalid programs.  */\n       if (compare_values (min, max) == 1)\n \treturn;\n \n       set_value_range (vr, VR_RANGE, min, max, vr->equiv);\n     }\n   else if (vr->type == VR_RANGE)\n     {\n-      tree min = vr->min;\n-      tree max = vr->max;\n+      min = vr->min;\n+      max = vr->max;\n \n       if (dir == EV_DIR_DECREASES)\n \t{\n@@ -2084,10 +2095,11 @@ adjust_range_with_scev (value_range_t *vr, struct loop *loop, tree stmt,\n \t      max = init;\n \n \t      /* If we just created an invalid range with the minimum\n-\t\t greater than the maximum, take the minimum all the\n-\t\t way to -INF.  */\n+\t\t greater than the maximum, we fail conservatively.\n+\t\t This should happen only in unreachable\n+\t\t parts of code, or for invalid programs.  */\n \t      if (compare_values (min, max) == 1)\n-\t\tmin = TYPE_MIN_VALUE (TREE_TYPE (min));\n+\t\treturn;\n \t    }\n \t}\n       else\n@@ -2097,11 +2109,9 @@ adjust_range_with_scev (value_range_t *vr, struct loop *loop, tree stmt,\n \t    {\n \t      min = init;\n \n-\t      /* If we just created an invalid range with the minimum\n-\t\t greater than the maximum, take the maximum all the\n-\t\t way to +INF.  */\n+\t      /* Again, avoid creating invalid range by failing.  */\n \t      if (compare_values (min, max) == 1)\n-\t\tmax = TYPE_MAX_VALUE (TREE_TYPE (max));\n+\t\treturn;\n \t    }\n \t}\n "}]}