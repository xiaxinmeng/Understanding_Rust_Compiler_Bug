{"sha": "e2e8d27426e0702c5ccaf77426de7430fcddb62c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTJlOGQyNzQyNmUwNzAyYzVjY2FmNzc0MjZkZTc0MzBmY2RkYjYyYw==", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2019-06-26T12:14:37Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@gcc.gnu.org", "date": "2019-06-26T12:14:37Z"}, "message": "rs6000: Remove duplicated code\n\nA large portion of the code moved from rs6000.c (to rs6000-logue.c)\nwas accidentally retained.  This fixes it.\n\n\n\t* rs6000.c: Fix previous commit, it missed some changes.\n\nFrom-SVN: r272690", "tree": {"sha": "0bb717c4a6d6a94c3b39d53f18804c240820999a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0bb717c4a6d6a94c3b39d53f18804c240820999a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e2e8d27426e0702c5ccaf77426de7430fcddb62c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2e8d27426e0702c5ccaf77426de7430fcddb62c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2e8d27426e0702c5ccaf77426de7430fcddb62c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2e8d27426e0702c5ccaf77426de7430fcddb62c/comments", "author": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "baf8d2ecd702d4b2cd18e9549771db994c22ae15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/baf8d2ecd702d4b2cd18e9549771db994c22ae15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/baf8d2ecd702d4b2cd18e9549771db994c22ae15"}], "stats": {"total": 1283, "additions": 4, "deletions": 1279}, "files": [{"sha": "2c455011e1a562a7c9e2a5914039c0f590194112", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2e8d27426e0702c5ccaf77426de7430fcddb62c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2e8d27426e0702c5ccaf77426de7430fcddb62c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e2e8d27426e0702c5ccaf77426de7430fcddb62c", "patch": "@@ -1,3 +1,7 @@\n+2019-06-26  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\t* rs6000.c: Fix previous commit, it missed some changes.\n+\n 2019-06-26  Richard Biener  <rguenther@suse.de>\n \n \tPR ipa/90982"}, {"sha": "3fc4029205a72bb51c162afb855dd73fd1a5c879", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 0, "deletions": 1279, "changes": 1279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2e8d27426e0702c5ccaf77426de7430fcddb62c/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2e8d27426e0702c5ccaf77426de7430fcddb62c/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=e2e8d27426e0702c5ccaf77426de7430fcddb62c", "patch": "@@ -23691,1285 +23691,6 @@ get_TOC_alias_set (void)\n   return set;\n }\n \n-/* This ties together stack memory (MEM with an alias set of frame_alias_set)\n-   and the change to the stack pointer.  */\n-\n-static void\n-rs6000_emit_stack_tie (rtx fp, bool hard_frame_needed)\n-{\n-  rtvec p;\n-  int i;\n-  rtx regs[3];\n-\n-  i = 0;\n-  regs[i++] = gen_rtx_REG (Pmode, STACK_POINTER_REGNUM);\n-  if (hard_frame_needed)\n-    regs[i++] = gen_rtx_REG (Pmode, HARD_FRAME_POINTER_REGNUM);\n-  if (!(REGNO (fp) == STACK_POINTER_REGNUM\n-\t|| (hard_frame_needed\n-\t    && REGNO (fp) == HARD_FRAME_POINTER_REGNUM)))\n-    regs[i++] = fp;\n-\n-  p = rtvec_alloc (i);\n-  while (--i >= 0)\n-    {\n-      rtx mem = gen_frame_mem (BLKmode, regs[i]);\n-      RTVEC_ELT (p, i) = gen_rtx_SET (mem, const0_rtx);\n-    }\n-\n-  emit_insn (gen_stack_tie (gen_rtx_PARALLEL (VOIDmode, p)));\n-}\n-\n-/* Allocate SIZE_INT bytes on the stack using a store with update style insn\n-   and set the appropriate attributes for the generated insn.  Return the\n-   first insn which adjusts the stack pointer or the last insn before\n-   the stack adjustment loop. \n-\n-   SIZE_INT is used to create the CFI note for the allocation.\n-\n-   SIZE_RTX is an rtx containing the size of the adjustment.  Note that\n-   since stacks grow to lower addresses its runtime value is -SIZE_INT.\n-\n-   ORIG_SP contains the backchain value that must be stored at *sp.  */\n-\n-static rtx_insn *\n-rs6000_emit_allocate_stack_1 (HOST_WIDE_INT size_int, rtx orig_sp)\n-{\n-  rtx_insn *insn;\n-\n-  rtx size_rtx = GEN_INT (-size_int);\n-  if (size_int > 32767)\n-    {\n-      rtx tmp_reg = gen_rtx_REG (Pmode, 0);\n-      /* Need a note here so that try_split doesn't get confused.  */\n-      if (get_last_insn () == NULL_RTX)\n-\temit_note (NOTE_INSN_DELETED);\n-      insn = emit_move_insn (tmp_reg, size_rtx);\n-      try_split (PATTERN (insn), insn, 0);\n-      size_rtx = tmp_reg;\n-    }\n-  \n-  if (TARGET_32BIT)\n-    insn = emit_insn (gen_movsi_update_stack (stack_pointer_rtx,\n-\t\t\t\t\t      stack_pointer_rtx,\n-\t\t\t\t\t      size_rtx,\n-\t\t\t\t\t      orig_sp));\n-  else\n-    insn = emit_insn (gen_movdi_update_stack (stack_pointer_rtx,\n-\t\t\t\t\t      stack_pointer_rtx,\n-\t\t\t\t\t      size_rtx,\n-\t\t\t\t\t      orig_sp));\n-  rtx par = PATTERN (insn);\n-  gcc_assert (GET_CODE (par) == PARALLEL);\n-  rtx set = XVECEXP (par, 0, 0);\n-  gcc_assert (GET_CODE (set) == SET);\n-  rtx mem = SET_DEST (set);\n-  gcc_assert (MEM_P (mem));\n-  MEM_NOTRAP_P (mem) = 1;\n-  set_mem_alias_set (mem, get_frame_alias_set ());\n-\n-  RTX_FRAME_RELATED_P (insn) = 1;\n-  add_reg_note (insn, REG_FRAME_RELATED_EXPR,\n-\t\tgen_rtx_SET (stack_pointer_rtx,\n-\t\t\t     gen_rtx_PLUS (Pmode,\n-\t\t\t\t\t   stack_pointer_rtx,\n-\t\t\t\t\t   GEN_INT (-size_int))));\n-\n-  /* Emit a blockage to ensure the allocation/probing insns are\n-     not optimized, combined, removed, etc.  Add REG_STACK_CHECK\n-     note for similar reasons.  */\n-  if (flag_stack_clash_protection)\n-    {\n-      add_reg_note (insn, REG_STACK_CHECK, const0_rtx);\n-      emit_insn (gen_blockage ());\n-    }\n-\n-  return insn;\n-}\n-\n-static HOST_WIDE_INT\n-get_stack_clash_protection_probe_interval (void)\n-{\n-  return (HOST_WIDE_INT_1U\n-\t  << PARAM_VALUE (PARAM_STACK_CLASH_PROTECTION_PROBE_INTERVAL));\n-}\n-\n-static HOST_WIDE_INT\n-get_stack_clash_protection_guard_size (void)\n-{\n-  return (HOST_WIDE_INT_1U\n-\t  << PARAM_VALUE (PARAM_STACK_CLASH_PROTECTION_GUARD_SIZE));\n-}\n-\n-/* Allocate ORIG_SIZE bytes on the stack and probe the newly\n-   allocated space every STACK_CLASH_PROTECTION_PROBE_INTERVAL bytes.\n-\n-   COPY_REG, if non-null, should contain a copy of the original\n-   stack pointer at exit from this function.\n-\n-   This is subtly different than the Ada probing in that it tries hard to\n-   prevent attacks that jump the stack guard.  Thus it is never allowed to\n-   allocate more than STACK_CLASH_PROTECTION_PROBE_INTERVAL bytes of stack\n-   space without a suitable probe.  */\n-static rtx_insn *\n-rs6000_emit_probe_stack_range_stack_clash (HOST_WIDE_INT orig_size,\n-\t\t\t\t\t   rtx copy_reg)\n-{\n-  rtx orig_sp = copy_reg;\n-\n-  HOST_WIDE_INT probe_interval = get_stack_clash_protection_probe_interval ();\n-\n-  /* Round the size down to a multiple of PROBE_INTERVAL.  */\n-  HOST_WIDE_INT rounded_size = ROUND_DOWN (orig_size, probe_interval);\n-\n-  /* If explicitly requested,\n-       or the rounded size is not the same as the original size\n-       or the the rounded size is greater than a page,\n-     then we will need a copy of the original stack pointer.  */\n-  if (rounded_size != orig_size\n-      || rounded_size > probe_interval\n-      || copy_reg)\n-    {\n-      /* If the caller did not request a copy of the incoming stack\n-\t pointer, then we use r0 to hold the copy.  */\n-      if (!copy_reg)\n-\torig_sp = gen_rtx_REG (Pmode, 0);\n-      emit_move_insn (orig_sp, stack_pointer_rtx);\n-    }\n-\n-  /* There's three cases here.\n-\n-     One is a single probe which is the most common and most efficiently\n-     implemented as it does not have to have a copy of the original\n-     stack pointer if there are no residuals.\n-\n-     Second is unrolled allocation/probes which we use if there's just\n-     a few of them.  It needs to save the original stack pointer into a\n-     temporary for use as a source register in the allocation/probe.\n-\n-     Last is a loop.  This is the most uncommon case and least efficient.  */\n-  rtx_insn *retval = NULL;\n-  if (rounded_size == probe_interval)\n-    {\n-      retval = rs6000_emit_allocate_stack_1 (probe_interval, stack_pointer_rtx);\n-\n-      dump_stack_clash_frame_info (PROBE_INLINE, rounded_size != orig_size);\n-    }\n-  else if (rounded_size <= 8 * probe_interval)\n-    {\n-      /* The ABI requires using the store with update insns to allocate\n-\t space and store the backchain into the stack\n-\n-\t So we save the current stack pointer into a temporary, then\n-\t emit the store-with-update insns to store the saved stack pointer\n-\t into the right location in each new page.  */\n-      for (int i = 0; i < rounded_size; i += probe_interval)\n-\t{\n-\t  rtx_insn *insn\n-\t    = rs6000_emit_allocate_stack_1 (probe_interval, orig_sp);\n-\n-\t  /* Save the first stack adjustment in RETVAL.  */\n-\t  if (i == 0)\n-\t    retval = insn;\n-\t}\n-\n-      dump_stack_clash_frame_info (PROBE_INLINE, rounded_size != orig_size);\n-    }\n-  else\n-    {\n-      /* Compute the ending address.  */\n-      rtx end_addr\n-\t= copy_reg ? gen_rtx_REG (Pmode, 0) : gen_rtx_REG (Pmode, 12);\n-      rtx rs = GEN_INT (-rounded_size);\n-      rtx_insn *insn;\n-      if (add_operand (rs, Pmode))\n-\tinsn = emit_insn (gen_add3_insn (end_addr, stack_pointer_rtx, rs));\n-      else\n-\t{\n-\t  emit_move_insn (end_addr, GEN_INT (-rounded_size));\n-\t  insn = emit_insn (gen_add3_insn (end_addr, end_addr,\n-\t\t\t\t\t   stack_pointer_rtx));\n-\t  /* Describe the effect of INSN to the CFI engine.  */\n-\t  add_reg_note (insn, REG_FRAME_RELATED_EXPR,\n-\t\t\tgen_rtx_SET (end_addr,\n-\t\t\t\t     gen_rtx_PLUS (Pmode, stack_pointer_rtx,\n-\t\t\t\t\t\t   rs)));\n-\t}\n-      RTX_FRAME_RELATED_P (insn) = 1;\n-\n-      /* Emit the loop.  */\n-      if (TARGET_64BIT)\n-\tretval = emit_insn (gen_probe_stack_rangedi (stack_pointer_rtx,\n-\t\t\t\t\t\t     stack_pointer_rtx, orig_sp,\n-\t\t\t\t\t\t     end_addr));\n-      else\n-\tretval = emit_insn (gen_probe_stack_rangesi (stack_pointer_rtx,\n-\t\t\t\t\t\t     stack_pointer_rtx, orig_sp,\n-\t\t\t\t\t\t     end_addr));\n-      RTX_FRAME_RELATED_P (retval) = 1;\n-      /* Describe the effect of INSN to the CFI engine.  */\n-      add_reg_note (retval, REG_FRAME_RELATED_EXPR,\n-\t\t    gen_rtx_SET (stack_pointer_rtx, end_addr));\n-\n-      /* Emit a blockage to ensure the allocation/probing insns are\n-\t not optimized, combined, removed, etc.  Other cases handle this\n-\t within their call to rs6000_emit_allocate_stack_1.  */\n-      emit_insn (gen_blockage ());\n-\n-      dump_stack_clash_frame_info (PROBE_LOOP, rounded_size != orig_size);\n-    }\n-\n-  if (orig_size != rounded_size)\n-    {\n-      /* Allocate (and implicitly probe) any residual space.   */\n-      HOST_WIDE_INT residual = orig_size - rounded_size;\n-\n-      rtx_insn *insn = rs6000_emit_allocate_stack_1 (residual, orig_sp);\n-\n-      /* If the residual was the only allocation, then we can return the\n-\t allocating insn.  */\n-      if (!retval)\n-\tretval = insn;\n-    }\n-\n-  return retval;\n-}\n-\n-/* Emit the correct code for allocating stack space, as insns.\n-   If COPY_REG, make sure a copy of the old frame is left there.\n-   The generated code may use hard register 0 as a temporary.  */\n-\n-static rtx_insn *\n-rs6000_emit_allocate_stack (HOST_WIDE_INT size, rtx copy_reg, int copy_off)\n-{\n-  rtx_insn *insn;\n-  rtx stack_reg = gen_rtx_REG (Pmode, STACK_POINTER_REGNUM);\n-  rtx tmp_reg = gen_rtx_REG (Pmode, 0);\n-  rtx todec = gen_int_mode (-size, Pmode);\n-\n-  if (INTVAL (todec) != -size)\n-    {\n-      warning (0, \"stack frame too large\");\n-      emit_insn (gen_trap ());\n-      return 0;\n-    }\n-\n-  if (crtl->limit_stack)\n-    {\n-      if (REG_P (stack_limit_rtx)\n-\t  && REGNO (stack_limit_rtx) > 1\n-\t  && REGNO (stack_limit_rtx) <= 31)\n-\t{\n-\t  rtx_insn *insn\n-\t    = gen_add3_insn (tmp_reg, stack_limit_rtx, GEN_INT (size));\n-\t  gcc_assert (insn);\n-\t  emit_insn (insn);\n-\t  emit_insn (gen_cond_trap (LTU, stack_reg, tmp_reg, const0_rtx));\n-\t}\n-      else if (SYMBOL_REF_P (stack_limit_rtx)\n-\t       && TARGET_32BIT\n-\t       && DEFAULT_ABI == ABI_V4\n-\t       && !flag_pic)\n-\t{\n-\t  rtx toload = gen_rtx_CONST (VOIDmode,\n-\t\t\t\t      gen_rtx_PLUS (Pmode,\n-\t\t\t\t\t\t    stack_limit_rtx,\n-\t\t\t\t\t\t    GEN_INT (size)));\n-\n-\t  emit_insn (gen_elf_high (tmp_reg, toload));\n-\t  emit_insn (gen_elf_low (tmp_reg, tmp_reg, toload));\n-\t  emit_insn (gen_cond_trap (LTU, stack_reg, tmp_reg,\n-\t\t\t\t    const0_rtx));\n-\t}\n-      else\n-\twarning (0, \"stack limit expression is not supported\");\n-    }\n-\n-  if (flag_stack_clash_protection)\n-    {\n-      if (size < get_stack_clash_protection_guard_size ())\n-\tdump_stack_clash_frame_info (NO_PROBE_SMALL_FRAME, true);\n-      else\n-\t{\n-\t  rtx_insn *insn = rs6000_emit_probe_stack_range_stack_clash (size,\n-\t\t\t\t\t\t\t\t      copy_reg);\n-\n-\t  /* If we asked for a copy with an offset, then we still need add in\n-\t     the offset.  */\n-\t  if (copy_reg && copy_off)\n-\t    emit_insn (gen_add3_insn (copy_reg, copy_reg, GEN_INT (copy_off)));\n-\t  return insn;\n-\t}\n-    }\n-\n-  if (copy_reg)\n-    {\n-      if (copy_off != 0)\n-\temit_insn (gen_add3_insn (copy_reg, stack_reg, GEN_INT (copy_off)));\n-      else\n-\temit_move_insn (copy_reg, stack_reg);\n-    }\n-\n-  /* Since we didn't use gen_frame_mem to generate the MEM, grab\n-     it now and set the alias set/attributes. The above gen_*_update\n-     calls will generate a PARALLEL with the MEM set being the first\n-     operation. */\n-  insn = rs6000_emit_allocate_stack_1 (size, stack_reg);\n-  return insn;\n-}\n-\n-#define PROBE_INTERVAL (1 << STACK_CHECK_PROBE_INTERVAL_EXP)\n-\n-#if PROBE_INTERVAL > 32768\n-#error Cannot use indexed addressing mode for stack probing\n-#endif\n-\n-/* Emit code to probe a range of stack addresses from FIRST to FIRST+SIZE,\n-   inclusive.  These are offsets from the current stack pointer.  */\n-\n-static void\n-rs6000_emit_probe_stack_range (HOST_WIDE_INT first, HOST_WIDE_INT size)\n-{\n-  /* See if we have a constant small number of probes to generate.  If so,\n-     that's the easy case.  */\n-  if (first + size <= 32768)\n-    {\n-      HOST_WIDE_INT i;\n-\n-      /* Probe at FIRST + N * PROBE_INTERVAL for values of N from 1 until\n-\t it exceeds SIZE.  If only one probe is needed, this will not\n-\t generate any code.  Then probe at FIRST + SIZE.  */\n-      for (i = PROBE_INTERVAL; i < size; i += PROBE_INTERVAL)\n-\temit_stack_probe (plus_constant (Pmode, stack_pointer_rtx,\n-\t\t\t\t\t -(first + i)));\n-\n-      emit_stack_probe (plus_constant (Pmode, stack_pointer_rtx,\n-\t\t\t\t       -(first + size)));\n-    }\n-\n-  /* Otherwise, do the same as above, but in a loop.  Note that we must be\n-     extra careful with variables wrapping around because we might be at\n-     the very top (or the very bottom) of the address space and we have\n-     to be able to handle this case properly; in particular, we use an\n-     equality test for the loop condition.  */\n-  else\n-    {\n-      HOST_WIDE_INT rounded_size;\n-      rtx r12 = gen_rtx_REG (Pmode, 12);\n-      rtx r0 = gen_rtx_REG (Pmode, 0);\n-\n-      /* Sanity check for the addressing mode we're going to use.  */\n-      gcc_assert (first <= 32768);\n-\n-      /* Step 1: round SIZE to the previous multiple of the interval.  */\n-\n-      rounded_size = ROUND_DOWN (size, PROBE_INTERVAL);\n-\n-\n-      /* Step 2: compute initial and final value of the loop counter.  */\n-\n-      /* TEST_ADDR = SP + FIRST.  */\n-      emit_insn (gen_rtx_SET (r12, plus_constant (Pmode, stack_pointer_rtx,\n-\t\t\t\t\t\t  -first)));\n-\n-      /* LAST_ADDR = SP + FIRST + ROUNDED_SIZE.  */\n-      if (rounded_size > 32768)\n-\t{\n-\t  emit_move_insn (r0, GEN_INT (-rounded_size));\n-\t  emit_insn (gen_rtx_SET (r0, gen_rtx_PLUS (Pmode, r12, r0)));\n-\t}\n-      else\n-\temit_insn (gen_rtx_SET (r0, plus_constant (Pmode, r12,\n-\t\t\t\t\t\t   -rounded_size)));\n-\n-\n-      /* Step 3: the loop\n-\n-\t do\n-\t   {\n-\t     TEST_ADDR = TEST_ADDR + PROBE_INTERVAL\n-\t     probe at TEST_ADDR\n-\t   }\n-\t while (TEST_ADDR != LAST_ADDR)\n-\n-\t probes at FIRST + N * PROBE_INTERVAL for values of N from 1\n-\t until it is equal to ROUNDED_SIZE.  */\n-\n-      if (TARGET_64BIT)\n-\temit_insn (gen_probe_stack_rangedi (r12, r12, stack_pointer_rtx, r0));\n-      else\n-\temit_insn (gen_probe_stack_rangesi (r12, r12, stack_pointer_rtx, r0));\n-\n-\n-      /* Step 4: probe at FIRST + SIZE if we cannot assert at compile-time\n-\t that SIZE is equal to ROUNDED_SIZE.  */\n-\n-      if (size != rounded_size)\n-\temit_stack_probe (plus_constant (Pmode, r12, rounded_size - size));\n-    }\n-}\n-\n-/* This function is called when rs6000_frame_related is processing\n-   SETs within a PARALLEL, and returns whether the REGNO save ought to\n-   be marked RTX_FRAME_RELATED_P.  The PARALLELs involved are those\n-   for out-of-line register save functions, store multiple, and the\n-   Darwin world_save.  They may contain registers that don't really\n-   need saving.  */\n-\n-static bool\n-interesting_frame_related_regno (unsigned int regno)\n-{\n-  /* Saves apparently of r0 are actually saving LR.  It doesn't make\n-     sense to substitute the regno here to test save_reg_p (LR_REGNO).\n-     We *know* LR needs saving, and dwarf2cfi.c is able to deduce that\n-     (set (mem) (r0)) is saving LR from a prior (set (r0) (lr)) marked\n-     as frame related.  */\n-  if (regno == 0)\n-    return true;\n-  /* If we see CR2 then we are here on a Darwin world save.  Saves of\n-     CR2 signify the whole CR is being saved.  This is a long-standing\n-     ABI wart fixed by ELFv2.  As for r0/lr there is no need to check\n-     that CR needs to be saved.  */\n-  if (regno == CR2_REGNO)\n-    return true;\n-  /* Omit frame info for any user-defined global regs.  If frame info\n-     is supplied for them, frame unwinding will restore a user reg.\n-     Also omit frame info for any reg we don't need to save, as that\n-     bloats frame info and can cause problems with shrink wrapping.\n-     Since global regs won't be seen as needing to be saved, both of\n-     these conditions are covered by save_reg_p.  */\n-  return save_reg_p (regno);\n-}\n-\n-/* Probe a range of stack addresses from REG1 to REG3 inclusive.  These are\n-   addresses, not offsets.\n-\n-   REG2 contains the backchain that must be stored into *sp at each allocation.\n-\n-   This is subtly different than the Ada probing above in that it tries hard\n-   to prevent attacks that jump the stack guard.  Thus, it is never allowed\n-   to allocate more than PROBE_INTERVAL bytes of stack space without a\n-   suitable probe.  */\n-\n-static const char *\n-output_probe_stack_range_stack_clash (rtx reg1, rtx reg2, rtx reg3)\n-{\n-  static int labelno = 0;\n-  char loop_lab[32];\n-  rtx xops[3];\n-\n-  HOST_WIDE_INT probe_interval = get_stack_clash_protection_probe_interval ();\n-\n-  ASM_GENERATE_INTERNAL_LABEL (loop_lab, \"LPSRL\", labelno++);\n-\n-  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, loop_lab);\n-\n-  /* This allocates and probes.  */\n-  xops[0] = reg1;\n-  xops[1] = reg2;\n-  xops[2] = GEN_INT (-probe_interval);\n-  if (TARGET_64BIT)\n-    output_asm_insn (\"stdu %1,%2(%0)\", xops);\n-  else\n-    output_asm_insn (\"stwu %1,%2(%0)\", xops);\n-\n-  /* Jump to LOOP_LAB if TEST_ADDR != LAST_ADDR.  */\n-  xops[0] = reg1;\n-  xops[1] = reg3;\n-  if (TARGET_64BIT)\n-    output_asm_insn (\"cmpd 0,%0,%1\", xops);\n-  else\n-    output_asm_insn (\"cmpw 0,%0,%1\", xops);\n-\n-  fputs (\"\\tbne 0,\", asm_out_file);\n-  assemble_name_raw (asm_out_file, loop_lab);\n-  fputc ('\\n', asm_out_file);\n-\n-  return \"\";\n-}\n-\n-/* Add to 'insn' a note which is PATTERN (INSN) but with REG replaced\n-   with (plus:P (reg 1) VAL), and with REG2 replaced with REPL2 if REG2\n-   is not NULL.  It would be nice if dwarf2out_frame_debug_expr could\n-   deduce these equivalences by itself so it wasn't necessary to hold\n-   its hand so much.  Don't be tempted to always supply d2_f_d_e with\n-   the actual cfa register, ie. r31 when we are using a hard frame\n-   pointer.  That fails when saving regs off r1, and sched moves the\n-   r31 setup past the reg saves.  */\n-\n-static rtx_insn *\n-rs6000_frame_related (rtx_insn *insn, rtx reg, HOST_WIDE_INT val,\n-\t\t      rtx reg2, rtx repl2)\n-{\n-  rtx repl;\n-\n-  if (REGNO (reg) == STACK_POINTER_REGNUM)\n-    {\n-      gcc_checking_assert (val == 0);\n-      repl = NULL_RTX;\n-    }\n-  else\n-    repl = gen_rtx_PLUS (Pmode, gen_rtx_REG (Pmode, STACK_POINTER_REGNUM),\n-\t\t\t GEN_INT (val));\n-\n-  rtx pat = PATTERN (insn);\n-  if (!repl && !reg2)\n-    {\n-      /* No need for any replacement.  Just set RTX_FRAME_RELATED_P.  */\n-      if (GET_CODE (pat) == PARALLEL)\n-\tfor (int i = 0; i < XVECLEN (pat, 0); i++)\n-\t  if (GET_CODE (XVECEXP (pat, 0, i)) == SET)\n-\t    {\n-\t      rtx set = XVECEXP (pat, 0, i);\n-\n-\t      if (!REG_P (SET_SRC (set))\n-\t\t  || interesting_frame_related_regno (REGNO (SET_SRC (set))))\n-\t\tRTX_FRAME_RELATED_P (set) = 1;\n-\t    }\n-      RTX_FRAME_RELATED_P (insn) = 1;\n-      return insn;\n-    }\n-\n-  /* We expect that 'pat' is either a SET or a PARALLEL containing\n-     SETs (and possibly other stuff).  In a PARALLEL, all the SETs\n-     are important so they all have to be marked RTX_FRAME_RELATED_P.\n-     Call simplify_replace_rtx on the SETs rather than the whole insn\n-     so as to leave the other stuff alone (for example USE of r12).  */\n-\n-  set_used_flags (pat);\n-  if (GET_CODE (pat) == SET)\n-    {\n-      if (repl)\n-\tpat = simplify_replace_rtx (pat, reg, repl);\n-      if (reg2)\n-\tpat = simplify_replace_rtx (pat, reg2, repl2);\n-    }\n-  else if (GET_CODE (pat) == PARALLEL)\n-    {\n-      pat = shallow_copy_rtx (pat);\n-      XVEC (pat, 0) = shallow_copy_rtvec (XVEC (pat, 0));\n-\n-      for (int i = 0; i < XVECLEN (pat, 0); i++)\n-\tif (GET_CODE (XVECEXP (pat, 0, i)) == SET)\n-\t  {\n-\t    rtx set = XVECEXP (pat, 0, i);\n-\n-\t    if (repl)\n-\t      set = simplify_replace_rtx (set, reg, repl);\n-\t    if (reg2)\n-\t      set = simplify_replace_rtx (set, reg2, repl2);\n-\t    XVECEXP (pat, 0, i) = set;\n-\n-\t    if (!REG_P (SET_SRC (set))\n-\t\t|| interesting_frame_related_regno (REGNO (SET_SRC (set))))\n-\t      RTX_FRAME_RELATED_P (set) = 1;\n-\t  }\n-    }\n-  else\n-    gcc_unreachable ();\n-\n-  RTX_FRAME_RELATED_P (insn) = 1;\n-  add_reg_note (insn, REG_FRAME_RELATED_EXPR, copy_rtx_if_shared (pat));\n-\n-  return insn;\n-}\n-\n-/* Returns an insn that has a vrsave set operation with the\n-   appropriate CLOBBERs.  */\n-\n-static rtx\n-generate_set_vrsave (rtx reg, rs6000_stack_t *info, int epiloguep)\n-{\n-  int nclobs, i;\n-  rtx insn, clobs[TOTAL_ALTIVEC_REGS + 1];\n-  rtx vrsave = gen_rtx_REG (SImode, VRSAVE_REGNO);\n-\n-  clobs[0]\n-    = gen_rtx_SET (vrsave,\n-\t\t   gen_rtx_UNSPEC_VOLATILE (SImode,\n-\t\t\t\t\t    gen_rtvec (2, reg, vrsave),\n-\t\t\t\t\t    UNSPECV_SET_VRSAVE));\n-\n-  nclobs = 1;\n-\n-  /* We need to clobber the registers in the mask so the scheduler\n-     does not move sets to VRSAVE before sets of AltiVec registers.\n-\n-     However, if the function receives nonlocal gotos, reload will set\n-     all call saved registers live.  We will end up with:\n-\n-     \t(set (reg 999) (mem))\n-\t(parallel [ (set (reg vrsave) (unspec blah))\n-\t\t    (clobber (reg 999))])\n-\n-     The clobber will cause the store into reg 999 to be dead, and\n-     flow will attempt to delete an epilogue insn.  In this case, we\n-     need an unspec use/set of the register.  */\n-\n-  for (i = FIRST_ALTIVEC_REGNO; i <= LAST_ALTIVEC_REGNO; ++i)\n-    if (info->vrsave_mask & ALTIVEC_REG_BIT (i))\n-      {\n-\tif (!epiloguep || call_used_regs [i])\n-\t  clobs[nclobs++] = gen_hard_reg_clobber (V4SImode, i);\n-\telse\n-\t  {\n-\t    rtx reg = gen_rtx_REG (V4SImode, i);\n-\n-\t    clobs[nclobs++]\n-\t      = gen_rtx_SET (reg,\n-\t\t\t     gen_rtx_UNSPEC (V4SImode,\n-\t\t\t\t\t     gen_rtvec (1, reg), 27));\n-\t  }\n-      }\n-\n-  insn = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (nclobs));\n-\n-  for (i = 0; i < nclobs; ++i)\n-    XVECEXP (insn, 0, i) = clobs[i];\n-\n-  return insn;\n-}\n-\n-static rtx\n-gen_frame_set (rtx reg, rtx frame_reg, int offset, bool store)\n-{\n-  rtx addr, mem;\n-\n-  addr = gen_rtx_PLUS (Pmode, frame_reg, GEN_INT (offset));\n-  mem = gen_frame_mem (GET_MODE (reg), addr);\n-  return gen_rtx_SET (store ? mem : reg, store ? reg : mem);\n-}\n-\n-static rtx\n-gen_frame_load (rtx reg, rtx frame_reg, int offset)\n-{\n-  return gen_frame_set (reg, frame_reg, offset, false);\n-}\n-\n-static rtx\n-gen_frame_store (rtx reg, rtx frame_reg, int offset)\n-{\n-  return gen_frame_set (reg, frame_reg, offset, true);\n-}\n-\n-/* Save a register into the frame, and emit RTX_FRAME_RELATED_P notes.\n-   Save REGNO into [FRAME_REG + OFFSET] in mode MODE.  */\n-\n-static rtx_insn *\n-emit_frame_save (rtx frame_reg, machine_mode mode,\n-\t\t unsigned int regno, int offset, HOST_WIDE_INT frame_reg_to_sp)\n-{\n-  rtx reg;\n-\n-  /* Some cases that need register indexed addressing.  */\n-  gcc_checking_assert (!(TARGET_ALTIVEC_ABI && ALTIVEC_VECTOR_MODE (mode))\n-\t\t\t || (TARGET_VSX && ALTIVEC_OR_VSX_VECTOR_MODE (mode)));\n-\n-  reg = gen_rtx_REG (mode, regno);\n-  rtx_insn *insn = emit_insn (gen_frame_store (reg, frame_reg, offset));\n-  return rs6000_frame_related (insn, frame_reg, frame_reg_to_sp,\n-\t\t\t       NULL_RTX, NULL_RTX);\n-}\n-\n-/* Emit an offset memory reference suitable for a frame store, while\n-   converting to a valid addressing mode.  */\n-\n-static rtx\n-gen_frame_mem_offset (machine_mode mode, rtx reg, int offset)\n-{\n-  return gen_frame_mem (mode, gen_rtx_PLUS (Pmode, reg, GEN_INT (offset)));\n-}\n-\n-#ifndef TARGET_FIX_AND_CONTINUE\n-#define TARGET_FIX_AND_CONTINUE 0\n-#endif\n-\n-/* It's really GPR 13 or 14, FPR 14 and VR 20.  We need the smallest.  */\n-#define FIRST_SAVRES_REGISTER FIRST_SAVED_GP_REGNO\n-#define LAST_SAVRES_REGISTER 31\n-#define N_SAVRES_REGISTERS (LAST_SAVRES_REGISTER - FIRST_SAVRES_REGISTER + 1)\n-\n-enum {\n-  SAVRES_LR = 0x1,\n-  SAVRES_SAVE = 0x2,\n-  SAVRES_REG = 0x0c,\n-  SAVRES_GPR = 0,\n-  SAVRES_FPR = 4,\n-  SAVRES_VR  = 8\n-};\n-\n-static GTY(()) rtx savres_routine_syms[N_SAVRES_REGISTERS][12];\n-\n-/* Temporary holding space for an out-of-line register save/restore\n-   routine name.  */\n-static char savres_routine_name[30];\n-\n-/* Return the name for an out-of-line register save/restore routine.\n-   We are saving/restoring GPRs if GPR is true.  */\n-\n-static char *\n-rs6000_savres_routine_name (int regno, int sel)\n-{\n-  const char *prefix = \"\";\n-  const char *suffix = \"\";\n-\n-  /* Different targets are supposed to define\n-     {SAVE,RESTORE}_FP_{PREFIX,SUFFIX} with the idea that the needed\n-     routine name could be defined with:\n-\n-     sprintf (name, \"%s%d%s\", SAVE_FP_PREFIX, regno, SAVE_FP_SUFFIX)\n-\n-     This is a nice idea in practice, but in reality, things are\n-     complicated in several ways:\n-\n-     - ELF targets have save/restore routines for GPRs.\n-\n-     - PPC64 ELF targets have routines for save/restore of GPRs that\n-       differ in what they do with the link register, so having a set\n-       prefix doesn't work.  (We only use one of the save routines at\n-       the moment, though.)\n-\n-     - PPC32 elf targets have \"exit\" versions of the restore routines\n-       that restore the link register and can save some extra space.\n-       These require an extra suffix.  (There are also \"tail\" versions\n-       of the restore routines and \"GOT\" versions of the save routines,\n-       but we don't generate those at present.  Same problems apply,\n-       though.)\n-\n-     We deal with all this by synthesizing our own prefix/suffix and\n-     using that for the simple sprintf call shown above.  */\n-  if (DEFAULT_ABI == ABI_V4)\n-    {\n-      if (TARGET_64BIT)\n-\tgoto aix_names;\n-\n-      if ((sel & SAVRES_REG) == SAVRES_GPR)\n-\tprefix = (sel & SAVRES_SAVE) ? \"_savegpr_\" : \"_restgpr_\";\n-      else if ((sel & SAVRES_REG) == SAVRES_FPR)\n-\tprefix = (sel & SAVRES_SAVE) ? \"_savefpr_\" : \"_restfpr_\";\n-      else if ((sel & SAVRES_REG) == SAVRES_VR)\n-\tprefix = (sel & SAVRES_SAVE) ? \"_savevr_\" : \"_restvr_\";\n-      else\n-\tabort ();\n-\n-      if ((sel & SAVRES_LR))\n-\tsuffix = \"_x\";\n-    }\n-  else if (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)\n-    {\n-#if !defined (POWERPC_LINUX) && !defined (POWERPC_FREEBSD)\n-      /* No out-of-line save/restore routines for GPRs on AIX.  */\n-      gcc_assert (!TARGET_AIX || (sel & SAVRES_REG) != SAVRES_GPR);\n-#endif\n-\n-    aix_names:\n-      if ((sel & SAVRES_REG) == SAVRES_GPR)\n-\tprefix = ((sel & SAVRES_SAVE)\n-\t\t  ? ((sel & SAVRES_LR) ? \"_savegpr0_\" : \"_savegpr1_\")\n-\t\t  : ((sel & SAVRES_LR) ? \"_restgpr0_\" : \"_restgpr1_\"));\n-      else if ((sel & SAVRES_REG) == SAVRES_FPR)\n-\t{\n-#if defined (POWERPC_LINUX) || defined (POWERPC_FREEBSD)\n-\t  if ((sel & SAVRES_LR))\n-\t    prefix = ((sel & SAVRES_SAVE) ? \"_savefpr_\" : \"_restfpr_\");\n-\t  else\n-#endif\n-\t    {\n-\t      prefix = (sel & SAVRES_SAVE) ? SAVE_FP_PREFIX : RESTORE_FP_PREFIX;\n-\t      suffix = (sel & SAVRES_SAVE) ? SAVE_FP_SUFFIX : RESTORE_FP_SUFFIX;\n-\t    }\n-\t}\n-      else if ((sel & SAVRES_REG) == SAVRES_VR)\n-\tprefix = (sel & SAVRES_SAVE) ? \"_savevr_\" : \"_restvr_\";\n-      else\n-\tabort ();\n-    }\n-\n-   if (DEFAULT_ABI == ABI_DARWIN)\n-    {\n-      /* The Darwin approach is (slightly) different, in order to be\n-\t compatible with code generated by the system toolchain.  There is a\n-\t single symbol for the start of save sequence, and the code here\n-\t embeds an offset into that code on the basis of the first register\n-\t to be saved.  */\n-      prefix = (sel & SAVRES_SAVE) ? \"save\" : \"rest\" ;\n-      if ((sel & SAVRES_REG) == SAVRES_GPR)\n-\tsprintf (savres_routine_name, \"*%sGPR%s%s%.0d ; %s r%d-r31\", prefix,\n-\t\t ((sel & SAVRES_LR) ? \"x\" : \"\"), (regno == 13 ? \"\" : \"+\"),\n-\t\t (regno - 13) * 4, prefix, regno);\n-      else if ((sel & SAVRES_REG) == SAVRES_FPR)\n-\tsprintf (savres_routine_name, \"*%sFP%s%.0d ; %s f%d-f31\", prefix,\n-\t\t (regno == 14 ? \"\" : \"+\"), (regno - 14) * 4, prefix, regno);\n-      else if ((sel & SAVRES_REG) == SAVRES_VR)\n-\tsprintf (savres_routine_name, \"*%sVEC%s%.0d ; %s v%d-v31\", prefix,\n-\t\t (regno == 20 ? \"\" : \"+\"), (regno - 20) * 8, prefix, regno);\n-      else\n-\tabort ();\n-    }\n-  else\n-    sprintf (savres_routine_name, \"%s%d%s\", prefix, regno, suffix);\n-\n-  return savres_routine_name;\n-}\n-\n-/* Return an RTL SYMBOL_REF for an out-of-line register save/restore routine.\n-   We are saving/restoring GPRs if GPR is true.  */\n-\n-static rtx\n-rs6000_savres_routine_sym (rs6000_stack_t *info, int sel)\n-{\n-  int regno = ((sel & SAVRES_REG) == SAVRES_GPR\n-\t       ? info->first_gp_reg_save\n-\t       : (sel & SAVRES_REG) == SAVRES_FPR\n-\t       ? info->first_fp_reg_save - 32\n-\t       : (sel & SAVRES_REG) == SAVRES_VR\n-\t       ? info->first_altivec_reg_save - FIRST_ALTIVEC_REGNO\n-\t       : -1);\n-  rtx sym;\n-  int select = sel;\n-\n-  /* Don't generate bogus routine names.  */\n-  gcc_assert (FIRST_SAVRES_REGISTER <= regno\n-\t      && regno <= LAST_SAVRES_REGISTER\n-\t      && select >= 0 && select <= 12);\n-\n-  sym = savres_routine_syms[regno-FIRST_SAVRES_REGISTER][select];\n-\n-  if (sym == NULL)\n-    {\n-      char *name;\n-\n-      name = rs6000_savres_routine_name (regno, sel);\n-\n-      sym = savres_routine_syms[regno-FIRST_SAVRES_REGISTER][select]\n-\t= gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (name));\n-      SYMBOL_REF_FLAGS (sym) |= SYMBOL_FLAG_FUNCTION;\n-    }\n-\n-  return sym;\n-}\n-\n-/* Emit a sequence of insns, including a stack tie if needed, for\n-   resetting the stack pointer.  If UPDT_REGNO is not 1, then don't\n-   reset the stack pointer, but move the base of the frame into\n-   reg UPDT_REGNO for use by out-of-line register restore routines.  */\n-\n-static rtx\n-rs6000_emit_stack_reset (rtx frame_reg_rtx, HOST_WIDE_INT frame_off,\n-\t\t\t unsigned updt_regno)\n-{\n-  /* If there is nothing to do, don't do anything.  */\n-  if (frame_off == 0 && REGNO (frame_reg_rtx) == updt_regno)\n-    return NULL_RTX;\n-\n-  rtx updt_reg_rtx = gen_rtx_REG (Pmode, updt_regno);\n-\n-  /* This blockage is needed so that sched doesn't decide to move\n-     the sp change before the register restores.  */\n-  if (DEFAULT_ABI == ABI_V4)\n-    return emit_insn (gen_stack_restore_tie (updt_reg_rtx, frame_reg_rtx,\n-\t\t\t\t\t     GEN_INT (frame_off)));\n-\n-  /* If we are restoring registers out-of-line, we will be using the\n-     \"exit\" variants of the restore routines, which will reset the\n-     stack for us.  But we do need to point updt_reg into the\n-     right place for those routines.  */\n-  if (frame_off != 0)\n-    return emit_insn (gen_add3_insn (updt_reg_rtx,\n-\t\t\t\t     frame_reg_rtx, GEN_INT (frame_off)));\n-  else\n-    return emit_move_insn (updt_reg_rtx, frame_reg_rtx);\n-\n-  return NULL_RTX;\n-}\n-\n-/* Return the register number used as a pointer by out-of-line\n-   save/restore functions.  */\n-\n-static inline unsigned\n-ptr_regno_for_savres (int sel)\n-{\n-  if (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)\n-    return (sel & SAVRES_REG) == SAVRES_FPR || (sel & SAVRES_LR) ? 1 : 12;\n-  return DEFAULT_ABI == ABI_DARWIN && (sel & SAVRES_REG) == SAVRES_FPR ? 1 : 11;\n-}\n-\n-/* Construct a parallel rtx describing the effect of a call to an\n-   out-of-line register save/restore routine, and emit the insn\n-   or jump_insn as appropriate.  */\n-\n-static rtx_insn *\n-rs6000_emit_savres_rtx (rs6000_stack_t *info,\n-\t\t\trtx frame_reg_rtx, int save_area_offset, int lr_offset,\n-\t\t\tmachine_mode reg_mode, int sel)\n-{\n-  int i;\n-  int offset, start_reg, end_reg, n_regs, use_reg;\n-  int reg_size = GET_MODE_SIZE (reg_mode);\n-  rtx sym;\n-  rtvec p;\n-  rtx par;\n-  rtx_insn *insn;\n-\n-  offset = 0;\n-  start_reg = ((sel & SAVRES_REG) == SAVRES_GPR\n-\t       ? info->first_gp_reg_save\n-\t       : (sel & SAVRES_REG) == SAVRES_FPR\n-\t       ? info->first_fp_reg_save\n-\t       : (sel & SAVRES_REG) == SAVRES_VR\n-\t       ? info->first_altivec_reg_save\n-\t       : -1);\n-  end_reg = ((sel & SAVRES_REG) == SAVRES_GPR\n-\t     ? 32\n-\t     : (sel & SAVRES_REG) == SAVRES_FPR\n-\t     ? 64\n-\t     : (sel & SAVRES_REG) == SAVRES_VR\n-\t     ? LAST_ALTIVEC_REGNO + 1\n-\t     : -1);\n-  n_regs = end_reg - start_reg;\n-  p = rtvec_alloc (3 + ((sel & SAVRES_LR) ? 1 : 0)\n-\t\t   + ((sel & SAVRES_REG) == SAVRES_VR ? 1 : 0)\n-\t\t   + n_regs);\n-\n-  if (!(sel & SAVRES_SAVE) && (sel & SAVRES_LR))\n-    RTVEC_ELT (p, offset++) = ret_rtx;\n-\n-  RTVEC_ELT (p, offset++) = gen_hard_reg_clobber (Pmode, LR_REGNO);\n-\n-  sym = rs6000_savres_routine_sym (info, sel);\n-  RTVEC_ELT (p, offset++) = gen_rtx_USE (VOIDmode, sym);\n-\n-  use_reg = ptr_regno_for_savres (sel);\n-  if ((sel & SAVRES_REG) == SAVRES_VR)\n-    {\n-      /* Vector regs are saved/restored using [reg+reg] addressing.  */\n-      RTVEC_ELT (p, offset++) = gen_hard_reg_clobber (Pmode, use_reg);\n-      RTVEC_ELT (p, offset++)\n-\t= gen_rtx_USE (VOIDmode, gen_rtx_REG (Pmode, 0));\n-    }\n-  else\n-    RTVEC_ELT (p, offset++)\n-      = gen_rtx_USE (VOIDmode, gen_rtx_REG (Pmode, use_reg));\n-\n-  for (i = 0; i < end_reg - start_reg; i++)\n-    RTVEC_ELT (p, i + offset)\n-      = gen_frame_set (gen_rtx_REG (reg_mode, start_reg + i),\n-\t\t       frame_reg_rtx, save_area_offset + reg_size * i,\n-\t\t       (sel & SAVRES_SAVE) != 0);\n-\n-  if ((sel & SAVRES_SAVE) && (sel & SAVRES_LR))\n-    RTVEC_ELT (p, i + offset)\n-      = gen_frame_store (gen_rtx_REG (Pmode, 0), frame_reg_rtx, lr_offset);\n-\n-  par = gen_rtx_PARALLEL (VOIDmode, p);\n-\n-  if (!(sel & SAVRES_SAVE) && (sel & SAVRES_LR))\n-    {\n-      insn = emit_jump_insn (par);\n-      JUMP_LABEL (insn) = ret_rtx;\n-    }\n-  else\n-    insn = emit_insn (par);\n-  return insn;\n-}\n-\n-/* Emit prologue code to store CR fields that need to be saved into REG.  This\n-   function should only be called when moving the non-volatile CRs to REG, it\n-   is not a general purpose routine to move the entire set of CRs to REG.\n-   Specifically, gen_prologue_movesi_from_cr() does not contain uses of the\n-   volatile CRs.  */\n-\n-static void\n-rs6000_emit_prologue_move_from_cr (rtx reg)\n-{\n-  /* Only the ELFv2 ABI allows storing only selected fields.  */\n-  if (DEFAULT_ABI == ABI_ELFv2 && TARGET_MFCRF)\n-    {\n-      int i, cr_reg[8], count = 0;\n-\n-      /* Collect CR fields that must be saved.  */\n-      for (i = 0; i < 8; i++)\n-\tif (save_reg_p (CR0_REGNO + i))\n-\t  cr_reg[count++] = i;\n-\n-      /* If it's just a single one, use mfcrf.  */\n-      if (count == 1)\n-\t{\n-\t  rtvec p = rtvec_alloc (1);\n-\t  rtvec r = rtvec_alloc (2);\n-\t  RTVEC_ELT (r, 0) = gen_rtx_REG (CCmode, CR0_REGNO + cr_reg[0]);\n-\t  RTVEC_ELT (r, 1) = GEN_INT (1 << (7 - cr_reg[0]));\n-\t  RTVEC_ELT (p, 0)\n-\t    = gen_rtx_SET (reg,\n-\t\t\t   gen_rtx_UNSPEC (SImode, r, UNSPEC_MOVESI_FROM_CR));\n-\n-\t  emit_insn (gen_rtx_PARALLEL (VOIDmode, p));\n-\t  return;\n-\t}\n-\n-      /* ??? It might be better to handle count == 2 / 3 cases here\n-\t as well, using logical operations to combine the values.  */\n-    }\n-\n-  emit_insn (gen_prologue_movesi_from_cr (reg));\n-}\n-\n-/* Return whether the split-stack arg pointer (r12) is used.  */\n-\n-static bool\n-split_stack_arg_pointer_used_p (void)\n-{\n-  /* If the pseudo holding the arg pointer is no longer a pseudo,\n-     then the arg pointer is used.  */\n-  if (cfun->machine->split_stack_arg_pointer != NULL_RTX\n-      && (!REG_P (cfun->machine->split_stack_arg_pointer)\n-\t  || HARD_REGISTER_P (cfun->machine->split_stack_arg_pointer)))\n-    return true;\n-\n-  /* Unfortunately we also need to do some code scanning, since\n-     r12 may have been substituted for the pseudo.  */\n-  rtx_insn *insn;\n-  basic_block bb = ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb;\n-  FOR_BB_INSNS (bb, insn)\n-    if (NONDEBUG_INSN_P (insn))\n-      {\n-\t/* A call destroys r12.  */\n-\tif (CALL_P (insn))\n-\t  return false;\n-\n-\tdf_ref use;\n-\tFOR_EACH_INSN_USE (use, insn)\n-\t  {\n-\t    rtx x = DF_REF_REG (use);\n-\t    if (REG_P (x) && REGNO (x) == 12)\n-\t      return true;\n-\t  }\n-\tdf_ref def;\n-\tFOR_EACH_INSN_DEF (def, insn)\n-\t  {\n-\t    rtx x = DF_REF_REG (def);\n-\t    if (REG_P (x) && REGNO (x) == 12)\n-\t      return false;\n-\t  }\n-      }\n-  return bitmap_bit_p (DF_LR_OUT (bb), 12);\n-}\n-\n-/* -mprofile-kernel code calls mcount before the function prolog,\n-   so a profiled leaf function should stay a leaf function.  */\n-static bool\n-rs6000_keep_leaf_when_profiled ()\n-{\n-  return TARGET_PROFILE_KERNEL;\n-}\n-\n-/* Non-zero if vmx regs are restored before the frame pop, zero if\n-   we restore after the pop when possible.  */\n-#define ALWAYS_RESTORE_ALTIVEC_BEFORE_POP 0\n-\n-/* Restoring cr is a two step process: loading a reg from the frame\n-   save, then moving the reg to cr.  For ABI_V4 we must let the\n-   unwinder know that the stack location is no longer valid at or\n-   before the stack deallocation, but we can't emit a cfa_restore for\n-   cr at the stack deallocation like we do for other registers.\n-   The trouble is that it is possible for the move to cr to be\n-   scheduled after the stack deallocation.  So say exactly where cr\n-   is located on each of the two insns.  */\n-\n-static rtx\n-load_cr_save (int regno, rtx frame_reg_rtx, int offset, bool exit_func)\n-{\n-  rtx mem = gen_frame_mem_offset (SImode, frame_reg_rtx, offset);\n-  rtx reg = gen_rtx_REG (SImode, regno);\n-  rtx_insn *insn = emit_move_insn (reg, mem);\n-\n-  if (!exit_func && DEFAULT_ABI == ABI_V4)\n-    {\n-      rtx cr = gen_rtx_REG (SImode, CR2_REGNO);\n-      rtx set = gen_rtx_SET (reg, cr);\n-\n-      add_reg_note (insn, REG_CFA_REGISTER, set);\n-      RTX_FRAME_RELATED_P (insn) = 1;\n-    }\n-  return reg;\n-}\n-\n-/* Reload CR from REG.  */\n-\n-static void\n-restore_saved_cr (rtx reg, bool using_mfcr_multiple, bool exit_func)\n-{\n-  int count = 0;\n-  int i;\n-\n-  if (using_mfcr_multiple)\n-    {\n-      for (i = 0; i < 8; i++)\n-\tif (save_reg_p (CR0_REGNO + i))\n-\t  count++;\n-      gcc_assert (count);\n-    }\n-\n-  if (using_mfcr_multiple && count > 1)\n-    {\n-      rtx_insn *insn;\n-      rtvec p;\n-      int ndx;\n-\n-      p = rtvec_alloc (count);\n-\n-      ndx = 0;\n-      for (i = 0; i < 8; i++)\n-\tif (save_reg_p (CR0_REGNO + i))\n-\t  {\n-\t    rtvec r = rtvec_alloc (2);\n-\t    RTVEC_ELT (r, 0) = reg;\n-\t    RTVEC_ELT (r, 1) = GEN_INT (1 << (7-i));\n-\t    RTVEC_ELT (p, ndx) =\n-\t      gen_rtx_SET (gen_rtx_REG (CCmode, CR0_REGNO + i),\n-\t\t\t   gen_rtx_UNSPEC (CCmode, r, UNSPEC_MOVESI_TO_CR));\n-\t    ndx++;\n-\t  }\n-      insn = emit_insn (gen_rtx_PARALLEL (VOIDmode, p));\n-      gcc_assert (ndx == count);\n-\n-      /* For the ELFv2 ABI we generate a CFA_RESTORE for each\n-\t CR field separately.  */\n-      if (!exit_func && DEFAULT_ABI == ABI_ELFv2 && flag_shrink_wrap)\n-\t{\n-\t  for (i = 0; i < 8; i++)\n-\t    if (save_reg_p (CR0_REGNO + i))\n-\t      add_reg_note (insn, REG_CFA_RESTORE,\n-\t\t\t    gen_rtx_REG (SImode, CR0_REGNO + i));\n-\n-\t  RTX_FRAME_RELATED_P (insn) = 1;\n-\t}\n-    }\n-  else\n-    for (i = 0; i < 8; i++)\n-      if (save_reg_p (CR0_REGNO + i))\n-\t{\n-\t  rtx insn = emit_insn (gen_movsi_to_cr_one\n-\t\t\t\t (gen_rtx_REG (CCmode, CR0_REGNO + i), reg));\n-\n-\t  /* For the ELFv2 ABI we generate a CFA_RESTORE for each\n-\t     CR field separately, attached to the insn that in fact\n-\t     restores this particular CR field.  */\n-\t  if (!exit_func && DEFAULT_ABI == ABI_ELFv2 && flag_shrink_wrap)\n-\t    {\n-\t      add_reg_note (insn, REG_CFA_RESTORE,\n-\t\t\t    gen_rtx_REG (SImode, CR0_REGNO + i));\n-\n-\t      RTX_FRAME_RELATED_P (insn) = 1;\n-\t    }\n-\t}\n-\n-  /* For other ABIs, we just generate a single CFA_RESTORE for CR2.  */\n-  if (!exit_func && DEFAULT_ABI != ABI_ELFv2\n-      && (DEFAULT_ABI == ABI_V4 || flag_shrink_wrap))\n-    {\n-      rtx_insn *insn = get_last_insn ();\n-      rtx cr = gen_rtx_REG (SImode, CR2_REGNO);\n-\n-      add_reg_note (insn, REG_CFA_RESTORE, cr);\n-      RTX_FRAME_RELATED_P (insn) = 1;\n-    }\n-}\n-\n-/* Like cr, the move to lr instruction can be scheduled after the\n-   stack deallocation, but unlike cr, its stack frame save is still\n-   valid.  So we only need to emit the cfa_restore on the correct\n-   instruction.  */\n-\n-static void\n-load_lr_save (int regno, rtx frame_reg_rtx, int offset)\n-{\n-  rtx mem = gen_frame_mem_offset (Pmode, frame_reg_rtx, offset);\n-  rtx reg = gen_rtx_REG (Pmode, regno);\n-\n-  emit_move_insn (reg, mem);\n-}\n-\n-static void\n-restore_saved_lr (int regno, bool exit_func)\n-{\n-  rtx reg = gen_rtx_REG (Pmode, regno);\n-  rtx lr = gen_rtx_REG (Pmode, LR_REGNO);\n-  rtx_insn *insn = emit_move_insn (lr, reg);\n-\n-  if (!exit_func && flag_shrink_wrap)\n-    {\n-      add_reg_note (insn, REG_CFA_RESTORE, lr);\n-      RTX_FRAME_RELATED_P (insn) = 1;\n-    }\n-}\n-\n-static rtx\n-add_crlr_cfa_restore (const rs6000_stack_t *info, rtx cfa_restores)\n-{\n-  if (DEFAULT_ABI == ABI_ELFv2)\n-    {\n-      int i;\n-      for (i = 0; i < 8; i++)\n-\tif (save_reg_p (CR0_REGNO + i))\n-\t  {\n-\t    rtx cr = gen_rtx_REG (SImode, CR0_REGNO + i);\n-\t    cfa_restores = alloc_reg_note (REG_CFA_RESTORE, cr,\n-\t\t\t\t\t   cfa_restores);\n-\t  }\n-    }\n-  else if (info->cr_save_p)\n-    cfa_restores = alloc_reg_note (REG_CFA_RESTORE,\n-\t\t\t\t   gen_rtx_REG (SImode, CR2_REGNO),\n-\t\t\t\t   cfa_restores);\n-\n-  if (info->lr_save_p)\n-    cfa_restores = alloc_reg_note (REG_CFA_RESTORE,\n-\t\t\t\t   gen_rtx_REG (Pmode, LR_REGNO),\n-\t\t\t\t   cfa_restores);\n-  return cfa_restores;\n-}\n-\n-/* Return true if OFFSET from stack pointer can be clobbered by signals.\n-   V.4 doesn't have any stack cushion, AIX ABIs have 220 or 288 bytes\n-   below stack pointer not cloberred by signals.  */\n-\n-static inline bool\n-offset_below_red_zone_p (HOST_WIDE_INT offset)\n-{\n-  return offset < (DEFAULT_ABI == ABI_V4\n-\t\t   ? 0\n-\t\t   : TARGET_32BIT ? -220 : -288);\n-}\n-\n-/* Append CFA_RESTORES to any existing REG_NOTES on the last insn.  */\n-\n-static void\n-emit_cfa_restores (rtx cfa_restores)\n-{\n-  rtx_insn *insn = get_last_insn ();\n-  rtx *loc = &REG_NOTES (insn);\n-\n-  while (*loc)\n-    loc = &XEXP (*loc, 1);\n-  *loc = cfa_restores;\n-  RTX_FRAME_RELATED_P (insn) = 1;\n-}\n-\n-/* -fsplit-stack support.  */\n-\n-/* A SYMBOL_REF for __morestack.  */\n-static GTY(()) rtx morestack_ref;\n-\n-static rtx\n-gen_add3_const (rtx rt, rtx ra, long c)\n-{\n-  if (TARGET_64BIT)\n-    return gen_adddi3 (rt, ra, GEN_INT (c));\n- else\n-    return gen_addsi3 (rt, ra, GEN_INT (c));\n-}\n-\n /* Return the internal arg pointer used for function incoming\n    arguments.  When -fsplit-stack, the arg pointer is r12 so we need\n    to copy it to a pseudo in order for it to be preserved over calls"}]}