{"sha": "362cc3d434b402148d579551c6f3ff4d4798a296", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzYyY2MzZDQzNGI0MDIxNDhkNTc5NTUxYzZmM2ZmNGQ0Nzk4YTI5Ng==", "commit": {"author": {"name": "Michael Hayes", "email": "m.hayes@elec.canterbury.ac.nz", "date": "1999-01-03T20:43:14Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-01-03T20:43:14Z"}, "message": "optabs.c (emit_cmp_insn): Abort if asked to emit non-canonical RTL for a target with HAVE_cc0 defined.\n\n        * optabs.c (emit_cmp_insn): Abort if asked to emit non-canonical RTL\n        for a target with HAVE_cc0 defined.\n        (emit_cmp_and_jump_insns): New function.\n        * expr.h (emit_cmp_and_jump_insns): Prototype it.\n        * loop.c (check_dbra_loop): Use it to replace calls\n        to emit_cmp_insn and emit_jump_insn and to canonicalise\n        the comparison if necessary.\n        * unroll.c (unroll_loop): Likewise.\n\nFrom-SVN: r24471", "tree": {"sha": "f3bee78195ed2ea424f2fed1ca5659020bca3406", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3bee78195ed2ea424f2fed1ca5659020bca3406"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/362cc3d434b402148d579551c6f3ff4d4798a296", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/362cc3d434b402148d579551c6f3ff4d4798a296", "html_url": "https://github.com/Rust-GCC/gccrs/commit/362cc3d434b402148d579551c6f3ff4d4798a296", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/362cc3d434b402148d579551c6f3ff4d4798a296/comments", "author": null, "committer": null, "parents": [{"sha": "1cd0a8edcaa31b8e1b76fc17ae41f3aa268fd5af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cd0a8edcaa31b8e1b76fc17ae41f3aa268fd5af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1cd0a8edcaa31b8e1b76fc17ae41f3aa268fd5af"}], "stats": {"total": 107, "additions": 81, "deletions": 26}, "files": [{"sha": "1e222523dc5227c53cb5e01b8b6ecba79566f4db", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/362cc3d434b402148d579551c6f3ff4d4798a296/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/362cc3d434b402148d579551c6f3ff4d4798a296/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=362cc3d434b402148d579551c6f3ff4d4798a296", "patch": "@@ -1,3 +1,14 @@\n+Sun Jan  3 22:58:15 1999  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n+\n+\t* optabs.c (emit_cmp_insn): Abort if asked to emit non-canonical RTL\n+\tfor a target with HAVE_cc0 defined.\n+\t(emit_cmp_and_jump_insns): New function.\n+\t* expr.h (emit_cmp_and_jump_insns): Prototype it.\n+\t* loop.c (check_dbra_loop): Use it to replace calls\n+\tto emit_cmp_insn and emit_jump_insn and to canonicalise\n+\tthe comparison if necessary.\n+\t* unroll.c (unroll_loop): Likewise.\n+\n Sun Jan  3 21:01:04 1999  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>\n \n \t* fixincludes (sys/utsname.h): Provide forward declaration of"}, {"sha": "c6740c296aa63aa4829aca14f57f1691e5414cbc", "filename": "gcc/expr.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/362cc3d434b402148d579551c6f3ff4d4798a296/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/362cc3d434b402148d579551c6f3ff4d4798a296/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=362cc3d434b402148d579551c6f3ff4d4798a296", "patch": "@@ -614,6 +614,11 @@ extern void emit_0_to_1_insn PROTO((rtx));\n extern void emit_cmp_insn PROTO((rtx, rtx, enum rtx_code, rtx,\n \t\t\t\t enum machine_mode, int, int));\n \n+/* Emit a pair of rtl insns to compare two rtx's and to jump \n+   to a label if the comparison is true.  */\n+extern void emit_cmp_and_jump_insns PROTO((rtx, rtx, enum rtx_code, rtx,\n+\t\t\t\t\t   enum machine_mode, int, int, rtx));\n+\n /* Nonzero if a compare of mode MODE can be done straightforwardly\n    (without splitting it into pieces).  */\n extern int can_compare_p PROTO((enum machine_mode));"}, {"sha": "fea8287b7e2cc23c51773f8f7fa5e1aa9034792f", "filename": "gcc/loop.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/362cc3d434b402148d579551c6f3ff4d4798a296/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/362cc3d434b402148d579551c6f3ff4d4798a296/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=362cc3d434b402148d579551c6f3ff4d4798a296", "patch": "@@ -7072,10 +7072,9 @@ check_dbra_loop (loop_end, insn_count, loop_start, loop_info)\n \n \t      /* Add new compare/branch insn at end of loop.  */\n \t      start_sequence ();\n-\t      emit_cmp_insn (reg, const0_rtx, cmp_code, NULL_RTX,\n-\t\t\t     GET_MODE (reg), 0, 0);\n-\t      emit_jump_insn ((*bcc_gen_fctn[(int) cmp_code])\n-\t\t\t      (XEXP (jump_label, 0)));\n+\t      emit_cmp_and_jump_insns (reg, const0_rtx, cmp_code, NULL_RTX,\n+\t\t\t\t       GET_MODE (reg), 0, 0, \n+\t\t\t\t       XEXP (jump_label, 0));\n \t      tem = gen_sequence ();\n \t      end_sequence ();\n \t      emit_jump_insn_before (tem, loop_end);"}, {"sha": "e57a8fc36793131c58c649e8ed98fcae3817fa22", "filename": "gcc/optabs.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/362cc3d434b402148d579551c6f3ff4d4798a296/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/362cc3d434b402148d579551c6f3ff4d4798a296/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=362cc3d434b402148d579551c6f3ff4d4798a296", "patch": "@@ -2722,6 +2722,14 @@ emit_cmp_insn (x, y, comparison, size, mode, unsignedp, align)\n   if (CONSTANT_P (y) && preserve_subexpressions_p () && rtx_cost (y, COMPARE) > 2)\n     y = force_reg (mode, y);\n \n+#ifdef HAVE_cc0\n+  /* Abort if we have a non-canonical comparison.  The RTL documentation\n+     states that canonical comparisons are required only for targets which\n+     have cc0.  */\n+  if (CONSTANT_P (x) && ! CONSTANT_P (y))\n+    abort();\n+#endif\n+\n   /* Don't let both operands fail to indicate the mode.  */\n   if (GET_MODE (x) == VOIDmode && GET_MODE (y) == VOIDmode)\n     x = force_reg (mode, x);\n@@ -2913,6 +2921,52 @@ emit_cmp_insn (x, y, comparison, size, mode, unsignedp, align)\n     abort ();\n }\n \n+/* Generate code to compare X with Y so that the condition codes are\n+   set and to jump to LABEL if the condition is true.  If X is a\n+   constant and Y is not a constant, then the comparison is swapped to\n+   ensure that the comparison RTL has the canonical form.\n+\n+   MODE is the mode of the inputs (in case they are const_int).\n+   UNSIGNEDP nonzero says that X and Y are unsigned;\n+   this matters if they need to be widened.\n+\n+   If they have mode BLKmode, then SIZE specifies the size of both X and Y,\n+   and ALIGN specifies the known shared alignment of X and Y.\n+\n+   COMPARISON is the rtl operator to compare with (EQ, NE, GT, etc.).\n+   It is ignored for fixed-point and block comparisons;\n+   it is used only for floating-point comparisons.  */\n+\n+void\n+emit_cmp_and_jump_insns (x, y, comparison, size, mode, unsignedp, align, label)\n+     rtx x, y;\n+     enum rtx_code comparison;\n+     rtx size;\n+     enum machine_mode mode;\n+     int unsignedp;\n+     int align;\n+     rtx label;\n+{\n+  rtx op0;\n+  rtx op1;\n+\t  \n+  if (GET_CODE (x) == CONST_INT)\n+    {\n+      /* Swap operands and condition to ensure canonical RTL.  */\n+      op0 = y;\n+      op1 = x;\n+      comparison = swap_condition (comparison);\n+    }\n+  else\n+    {\n+      op0 = x;\n+      op1 = y;\n+    }\n+  emit_cmp_insn (op0, op1, comparison, size, mode, unsignedp, align);\n+  emit_jump_insn ((*bcc_gen_fctn[(int) comparison]) (label));\n+}\n+\n+\n /* Nonzero if a compare of mode MODE can be done straightforwardly\n    (without splitting it into pieces).  */\n "}, {"sha": "8586e1deb39ef8685367d3214ece701ed56ec295", "filename": "gcc/unroll.c", "status": "modified", "additions": 8, "deletions": 22, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/362cc3d434b402148d579551c6f3ff4d4798a296/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/362cc3d434b402148d579551c6f3ff4d4798a296/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=362cc3d434b402148d579551c6f3ff4d4798a296", "patch": "@@ -919,12 +919,9 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \n \t  if (loop_info->comparison_code != NE)\n \t    {\n-\t      emit_cmp_insn (initial_value, final_value, neg_inc ? LE : GE,\n-\t\t\t     NULL_RTX, mode, 0, 0);\n-\t      if (neg_inc)\n-\t\temit_jump_insn (gen_ble (labels[1]));\n-\t      else\n-\t\temit_jump_insn (gen_bge (labels[1]));\n+\t      emit_cmp_and_jump_insns (initial_value, final_value, \n+\t\t\t\t       neg_inc ? LE : GE,\n+\t\t\t\t       NULL_RTX, mode, 0, 0, labels[1]);\n \t      JUMP_LABEL (get_last_insn ()) = labels[1];\n \t      LABEL_NUSES (labels[1])++;\n \t    }\n@@ -965,15 +962,9 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \t\t  cmp_code = LE;\n \t\t}\n \n-\t      emit_cmp_insn (diff, GEN_INT (abs_inc * cmp_const),\n-\t\t\t     cmp_code, NULL_RTX, mode, 0, 0);\n-\n-\t      if (i == 0)\n-\t\temit_jump_insn (gen_beq (labels[i]));\n-\t      else if (neg_inc)\n-\t\temit_jump_insn (gen_bge (labels[i]));\n-\t      else\n-\t\temit_jump_insn (gen_ble (labels[i]));\n+\t      emit_cmp_and_jump_insns (diff, GEN_INT (abs_inc * cmp_const),\n+\t\t\t\t       cmp_code, NULL_RTX, mode, 0, 0,\n+\t\t\t\t       labels[i]);\n \t      JUMP_LABEL (get_last_insn ()) = labels[i];\n \t      LABEL_NUSES (labels[i])++;\n \t    }\n@@ -1003,13 +994,8 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \t\t  cmp_code = GE;\n \t\t}\n \n-\t      emit_cmp_insn (diff, GEN_INT (cmp_const), cmp_code, NULL_RTX,\n-\t\t\t     mode, 0, 0);\n-\n-\t      if (neg_inc)\n-\t\temit_jump_insn (gen_ble (labels[0]));\n-\t      else\n-\t\temit_jump_insn (gen_bge (labels[0]));\n+\t      emit_cmp_and_jump_insns (diff, GEN_INT (cmp_const), cmp_code,\n+\t\t\t\t       NULL_RTX, mode, 0, 0, labels[0]);\n \t      JUMP_LABEL (get_last_insn ()) = labels[0];\n \t      LABEL_NUSES (labels[0])++;\n \t    }"}]}