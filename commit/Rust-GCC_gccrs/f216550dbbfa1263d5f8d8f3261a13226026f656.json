{"sha": "f216550dbbfa1263d5f8d8f3261a13226026f656", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjIxNjU1MGRiYmZhMTI2M2Q1ZjhkOGYzMjYxYTEzMjI2MDI2ZjY1Ng==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-09-13T12:41:21Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-09-13T12:41:21Z"}, "message": "Conv-op identifers not in identifier hash table\n\n\tConv-op identifers not in identifier hash table\n\t* lex.c (conv_type_hasher): Make member fns inline.\n\t(make_conv_op_name): Directly clone conv_op_identifier.\n\nFrom-SVN: r252081", "tree": {"sha": "0f8d0167de041b80bcdfab217ee0a4517e88efa8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f8d0167de041b80bcdfab217ee0a4517e88efa8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f216550dbbfa1263d5f8d8f3261a13226026f656", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f216550dbbfa1263d5f8d8f3261a13226026f656", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f216550dbbfa1263d5f8d8f3261a13226026f656", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f216550dbbfa1263d5f8d8f3261a13226026f656/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e5b87132fe80abec4bb94179b26c6655b1ad7023", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5b87132fe80abec4bb94179b26c6655b1ad7023", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5b87132fe80abec4bb94179b26c6655b1ad7023"}], "stats": {"total": 72, "additions": 37, "deletions": 35}, "files": [{"sha": "c0b7ba2ff69a0ffc25ca34ced3452386dcf2e143", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f216550dbbfa1263d5f8d8f3261a13226026f656/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f216550dbbfa1263d5f8d8f3261a13226026f656/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f216550dbbfa1263d5f8d8f3261a13226026f656", "patch": "@@ -1,5 +1,9 @@\n 2017-09-13  Nathan Sidwell  <nathan@acm.org>\n \n+\tConv-op identifers not in identifier hash table\n+\t* lex.c (conv_type_hasher): Make member fns inline.\n+\t(make_conv_op_name): Directly clone conv_op_identifier.\n+\n \tRename CLASSTYPE_METHOD_VEC to CLASSTYPE_MEMBER_VEC.\n \t* cp-tree.h (struct lang_type): Rename methods to members.\n \t(CLASSTYPE_METHOD_VEC): Rename to ..."}, {"sha": "5bdea7bf57d0c3a9478a926dba5a37973be4c3ac", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 33, "deletions": 35, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f216550dbbfa1263d5f8d8f3261a13226026f656/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f216550dbbfa1263d5f8d8f3261a13226026f656/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=f216550dbbfa1263d5f8d8f3261a13226026f656", "patch": "@@ -531,10 +531,24 @@ unqualified_fn_lookup_error (cp_expr name_expr)\n   return unqualified_name_lookup_error (name, loc);\n }\n \n+\n+/* Hasher for the conversion operator name hash table.  */\n struct conv_type_hasher : ggc_ptr_hash<tree_node>\n {\n-  static hashval_t hash (tree);\n-  static bool equal (tree, tree);\n+  /* Hash NODE, an identifier node in the table.  TYPE_UID is\n+     suitable, as we're not concerned about matching canonicalness\n+     here.  */\n+  static hashval_t hash (tree node)\n+  {\n+    return (hashval_t) TYPE_UID (TREE_TYPE (node));\n+  }\n+\n+  /* Compare NODE, an identifier node in the table, against TYPE, an\n+     incoming TYPE being looked up.  */\n+  static bool equal (tree node, tree type)\n+  {\n+    return TREE_TYPE (node) == type;\n+  }\n };\n \n /* This hash table maps TYPEs to the IDENTIFIER for a conversion\n@@ -543,57 +557,41 @@ struct conv_type_hasher : ggc_ptr_hash<tree_node>\n \n static GTY (()) hash_table<conv_type_hasher> *conv_type_names;\n \n-/* Hash a node (VAL1) in the table.  */\n-\n-hashval_t\n-conv_type_hasher::hash (tree val)\n-{\n-  return (hashval_t) TYPE_UID (TREE_TYPE (val));\n-}\n-\n-/* Compare VAL1 (a node in the table) with VAL2 (a TYPE).  */\n-\n-bool\n-conv_type_hasher::equal (tree val1, tree val2)\n-{\n-  return TREE_TYPE (val1) == val2;\n-}\n-\n-/* Return an identifier for a conversion operator to TYPE.  We can\n-   get from the returned identifier to the type.  */\n+/* Return an identifier for a conversion operator to TYPE.  We can get\n+   from the returned identifier to the type.  We store TYPE, which is\n+   not necessarily the canonical type,  which allows us to report the\n+   form the user used in error messages.  All these identifiers are\n+   not in the identifier hash table, and have the same string name.\n+   These IDENTIFIERS are not in the identifier hash table, and all\n+   have the same IDENTIFIER_STRING.  */\n \n tree\n make_conv_op_name (tree type)\n {\n-  tree *slot;\n-  tree identifier;\n-\n   if (type == error_mark_node)\n     return error_mark_node;\n \n   if (conv_type_names == NULL)\n     conv_type_names = hash_table<conv_type_hasher>::create_ggc (31);\n \n-  slot = conv_type_names->find_slot_with_hash (type,\n-\t\t\t\t\t       (hashval_t) TYPE_UID (type),\n-\t\t\t\t\t       INSERT);\n-  identifier = *slot;\n+  tree *slot = conv_type_names->find_slot_with_hash\n+    (type, (hashval_t) TYPE_UID (type), INSERT);\n+  tree identifier = *slot;\n   if (!identifier)\n     {\n-      char buffer[64];\n+      /* Create a raw IDENTIFIER outside of the identifier hash\n+\t table.  */\n+      identifier = copy_node (conv_op_identifier);\n \n-       /* Create a unique name corresponding to TYPE.  */\n-      sprintf (buffer, \"operator %lu\",\n-\t       (unsigned long) conv_type_names->elements ());\n-      identifier = get_identifier (buffer);\n-      *slot = identifier;\n+      /* Just in case something managed to bind.  */\n+      IDENTIFIER_BINDING (identifier) = NULL;\n+      IDENTIFIER_LABEL_VALUE (identifier) = NULL_TREE;\n \n       /* Hang TYPE off the identifier so it can be found easily later\n \t when performing conversions.  */\n       TREE_TYPE (identifier) = type;\n \n-      /* Set the identifier kind so we know later it's a conversion.  */\n-      set_identifier_kind (identifier, cik_conv_op);\n+      *slot = identifier;\n     }\n \n   return identifier;"}]}