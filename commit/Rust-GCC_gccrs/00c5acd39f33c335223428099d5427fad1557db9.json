{"sha": "00c5acd39f33c335223428099d5427fad1557db9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDBjNWFjZDM5ZjMzYzMzNTIyMzQyODA5OWQ1NDI3ZmFkMTU1N2RiOQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2014-03-13T15:42:21Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2014-03-13T15:42:21Z"}, "message": "re PR ada/51483 (cstand.adb:Register_Float_Type makes invalid assumption about FP modes)\n\n\tPR ada/51483\n\t* cstand.adb (Register_Float_Type): Add 'precision' parameter and use\n\tit to set the RM size.  Use directly 'size' for the Esize.\n\t(Create_Back_End_Float_Types): Adjust call to above.\n\t* get_targ.ads (Register_Type_Proc): Add 'precision' parameter.\n\t* set_targ.ads (FPT_Mode_Entry): Add 'precision' component.\n\t(Write_Target_Dependent_Values): Adjust comment.\n\t* set_targ.adb (Register_Float_Type): Add 'precision' parameter and\n\tdeal with it.\n\t(Write_Target_Dependent_Values): Write the precision in lieu of size.\n\t(Initialization): Read the precision in lieu of size and compute the\n\tsize from the precision and the alignment.\n\t* gcc-interface/gigi.h (enumerate_modes): Add integer parameter.\n\t* gcc-interface/misc.c (enumerate_modes): Likewise.  Do not register\n\ttypes for vector modes, pass the size in addition to the precision.\n\nFrom-SVN: r208546", "tree": {"sha": "1e9b0042edfbf26cf75b893c217e55b1cfd8d541", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e9b0042edfbf26cf75b893c217e55b1cfd8d541"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/00c5acd39f33c335223428099d5427fad1557db9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00c5acd39f33c335223428099d5427fad1557db9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00c5acd39f33c335223428099d5427fad1557db9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00c5acd39f33c335223428099d5427fad1557db9/comments", "author": null, "committer": null, "parents": [{"sha": "9299bde01aed78cfea5a779eae1f79bac9c3ac00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9299bde01aed78cfea5a779eae1f79bac9c3ac00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9299bde01aed78cfea5a779eae1f79bac9c3ac00"}], "stats": {"total": 122, "additions": 85, "deletions": 37}, "files": [{"sha": "cfb2c59156d6051558ddab0449b302f1280126b0", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00c5acd39f33c335223428099d5427fad1557db9/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00c5acd39f33c335223428099d5427fad1557db9/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=00c5acd39f33c335223428099d5427fad1557db9", "patch": "@@ -1,3 +1,21 @@\n+2014-03-13  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR ada/51483\n+\t* cstand.adb (Register_Float_Type): Add 'precision' parameter and use\n+\tit to set the RM size.  Use directly 'size' for the Esize.\n+\t(Create_Back_End_Float_Types): Adjust call to above.\n+\t* get_targ.ads (Register_Type_Proc): Add 'precision' parameter.\n+\t* set_targ.ads (FPT_Mode_Entry): Add 'precision' component.\n+\t(Write_Target_Dependent_Values): Adjust comment.\n+\t* set_targ.adb (Register_Float_Type): Add 'precision' parameter and\n+\tdeal with it.\n+\t(Write_Target_Dependent_Values): Write the precision in lieu of size.\n+\t(Initialization): Read the precision in lieu of size and compute the\n+\tsize from the precision and the alignment.\n+\t* gcc-interface/gigi.h (enumerate_modes): Add integer parameter.\n+\t* gcc-interface/misc.c (enumerate_modes): Likewise.  Do not register\n+\ttypes for vector modes, pass the size in addition to the precision.\n+\n 2014-03-10  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/Make-lang.in (ADA_DEPFILES): Fix typo."}, {"sha": "4099a7d04579619e0a30dd1b5108ab742d6e65a8", "filename": "gcc/ada/cstand.adb", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00c5acd39f33c335223428099d5427fad1557db9/gcc%2Fada%2Fcstand.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00c5acd39f33c335223428099d5427fad1557db9/gcc%2Fada%2Fcstand.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcstand.adb?ref=00c5acd39f33c335223428099d5427fad1557db9", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -158,6 +158,7 @@ package body CStand is\n      (Name      : String;\n       Digs      : Positive;\n       Float_Rep : Float_Rep_Kind;\n+      Precision : Positive;\n       Size      : Positive;\n       Alignment : Natural);\n    --  Registers a single back end floating-point type (from FPT_Mode_Table in\n@@ -167,7 +168,8 @@ package body CStand is\n    --  as a normal format (non-null-terminated) string. Digs is the number of\n    --  digits, which is always non-zero, since non-floating-point types were\n    --  filtered out earlier. Float_Rep indicates the kind of floating-point\n-   --  type, and Size and Alignment are the size and alignment in bits.\n+   --  type, and Precision, Size and Alignment are the precision, size and\n+   --  alignment in bits.\n \n    procedure Set_Integer_Bounds\n      (Id  : Entity_Id;\n@@ -480,7 +482,8 @@ package body CStand is\n                E : FPT_Mode_Entry renames FPT_Mode_Table (J);\n             begin\n                Register_Float_Type\n-                 (E.NAME.all, E.DIGS, E.FLOAT_REP, E.SIZE, E.ALIGNMENT);\n+                 (E.NAME.all, E.DIGS, E.FLOAT_REP, E.PRECISION, E.SIZE,\n+                  E.ALIGNMENT);\n             end;\n          end loop;\n       end Create_Back_End_Float_Types;\n@@ -2083,19 +2086,18 @@ package body CStand is\n      (Name      : String;\n       Digs      : Positive;\n       Float_Rep : Float_Rep_Kind;\n+      Precision : Positive;\n       Size      : Positive;\n       Alignment : Natural)\n    is\n-      Ent   : constant Entity_Id := New_Standard_Entity;\n-      Esize : constant Pos :=\n-                Pos ((Size + Alignment - 1) / Alignment * Alignment);\n+      Ent : constant Entity_Id := New_Standard_Entity;\n \n    begin\n       Set_Defining_Identifier (New_Node (N_Full_Type_Declaration, Stloc), Ent);\n       Make_Name (Ent, Name);\n       Set_Scope (Ent, Standard_Standard);\n-      Build_Float_Type (Ent, Esize, Float_Rep, Pos (Digs));\n-      Set_RM_Size (Ent, UI_From_Int (Int (Size)));\n+      Build_Float_Type (Ent, Int (Size), Float_Rep, Pos (Digs));\n+      Set_RM_Size (Ent, UI_From_Int (Int (Precision)));\n       Set_Alignment (Ent, UI_From_Int (Int (Alignment / 8)));\n \n       if No (Back_End_Float_Types) then"}, {"sha": "b7092735c898e9a12d313fc2d87dd23c11545c62", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00c5acd39f33c335223428099d5427fad1557db9/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00c5acd39f33c335223428099d5427fad1557db9/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=00c5acd39f33c335223428099d5427fad1557db9", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *          Copyright (C) 1992-2013, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2014, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -1044,7 +1044,7 @@ extern Nat get_target_double_scalar_alignment (void);\n /* This function is called by the front-end to enumerate all the supported\n    modes for the machine, as well as some predefined C types.  */\n extern void enumerate_modes (void (*f) (const char *, int, int, int, int, int,\n-\t\t\t\t\tint));\n+\t\t\t\t\tint, int));\n \n #ifdef __cplusplus\n }"}, {"sha": "a5f2881d697bbc7fcb206f8e38a408347dc52009", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00c5acd39f33c335223428099d5427fad1557db9/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00c5acd39f33c335223428099d5427fad1557db9/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=00c5acd39f33c335223428099d5427fad1557db9", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                           C Implementation File                          *\n  *                                                                          *\n- *          Copyright (C) 1992-2013, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2014, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -683,7 +683,7 @@ must_pass_by_ref (tree gnu_type)\n /* This function is called by the front-end to enumerate all the supported\n    modes for the machine, as well as some predefined C types.  F is a function\n    which is called back with the parameters as listed below, first a string,\n-   then six ints.  The name is any arbitrary null-terminated string and has\n+   then seven ints.  The name is any arbitrary null-terminated string and has\n    no particular significance, except for the case of predefined C types, where\n    it should be the name of the C type.  For integer types, only signed types\n    should be listed, unsigned versions are assumed.  The order of types should\n@@ -699,11 +699,12 @@ must_pass_by_ref (tree gnu_type)\n    COMPLEX_P\tnonzero is this represents a complex mode\n    COUNT\tcount of number of items, nonzero for vector mode\n    FLOAT_REP\tFloat_Rep_Kind for FP, otherwise undefined\n-   SIZE\t\tnumber of bits used to store data\n+   PRECISION\tnumber of bits used to store data\n+   SIZE\t\tnumber of bits occupied by the mode\n    ALIGN\tnumber of bits to which mode is aligned.  */\n \n void\n-enumerate_modes (void (*f) (const char *, int, int, int, int, int, int))\n+enumerate_modes (void (*f) (const char *, int, int, int, int, int, int, int))\n {\n   const tree c_types[]\n     = { float_type_node, double_type_node, long_double_type_node };\n@@ -777,28 +778,26 @@ enumerate_modes (void (*f) (const char *, int, int, int, int, int, int))\n \n       /* First register any C types for this mode that the front end\n \t may need to know about, unless the mode should be skipped.  */\n-\n-      if (!skip_p)\n+      if (!skip_p && !vector_p)\n \tfor (nameloop = 0; nameloop < ARRAY_SIZE (c_types); nameloop++)\n \t  {\n-\t    tree typ = c_types[nameloop];\n-\t    const char *nam = c_names[nameloop];\n+\t    tree type = c_types[nameloop];\n+\t    const char *name = c_names[nameloop];\n \n-\t    if (TYPE_MODE (typ) == i)\n+\t    if (TYPE_MODE (type) == i)\n \t      {\n-\t\tf (nam, digs, complex_p,\n-\t\t   vector_p ? GET_MODE_NUNITS (i) : 0, float_rep,\n-\t\t   TYPE_PRECISION (typ), TYPE_ALIGN (typ));\n+\t\tf (name, digs, complex_p, 0, float_rep, TYPE_PRECISION (type),\n+\t\t   TREE_INT_CST_LOW (TYPE_SIZE (type)), TYPE_ALIGN (type));\n \t\tskip_p = true;\n \t      }\n \t  }\n \n       /* If no predefined C types were found, register the mode itself.  */\n-\n       if (!skip_p)\n \tf (GET_MODE_NAME (i), digs, complex_p,\n \t   vector_p ? GET_MODE_NUNITS (i) : 0, float_rep,\n-\t   GET_MODE_PRECISION (i), GET_MODE_ALIGNMENT (i));\n+\t   GET_MODE_PRECISION (i), GET_MODE_BITSIZE (i),\n+\t   GET_MODE_ALIGNMENT (i));\n     }\n }\n "}, {"sha": "98be7c9a771ad90df26082f39957603b7951a688", "filename": "gcc/ada/get_targ.ads", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00c5acd39f33c335223428099d5427fad1557db9/gcc%2Fada%2Fget_targ.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00c5acd39f33c335223428099d5427fad1557db9/gcc%2Fada%2Fget_targ.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fget_targ.ads?ref=00c5acd39f33c335223428099d5427fad1557db9", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -28,8 +28,8 @@\n --  exp_dbug and the elaboration of ttypes, via the Set_Targs package.\n --  It also contains the routine for registering floating-point types.\n \n---  NOTE:  Any changes in this package must be reflected in jgettarg.ads\n---  and aa_getta.ads and any other versions of this package.\n+--  NOTE: Any changes in this package must be reflected in aa_getta.adb\n+--  and any other version in the various back ends.\n \n --  Note that all these values return sizes of C types with corresponding\n --  names. This allows GNAT to define the corresponding Ada types to have\n@@ -134,6 +134,7 @@ package Get_Targ is\n       Complex   : Boolean;        -- True iff type has real and imaginary parts\n       Count     : Natural;        -- Number of elements in vector, 0 otherwise\n       Float_Rep : Float_Rep_Kind; -- Representation used for fpt type\n+      Precision : Positive;       -- Precision of representation in bits\n       Size      : Positive;       -- Size of representation in bits\n       Alignment : Natural);       -- Required alignment in bits\n    pragma Convention (C, Register_Type_Proc);"}, {"sha": "d6268c82333212c21f0648fc5ee3be7f6c7f11d1", "filename": "gcc/ada/set_targ.adb", "status": "modified", "additions": 28, "deletions": 8, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00c5acd39f33c335223428099d5427fad1557db9/gcc%2Fada%2Fset_targ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00c5acd39f33c335223428099d5427fad1557db9/gcc%2Fada%2Fset_targ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fset_targ.adb?ref=00c5acd39f33c335223428099d5427fad1557db9", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---            Copyright (C) 2013, Free Software Foundation, Inc.            --\n+--          Copyright (C) 2013-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -140,6 +140,7 @@ package body Set_Targ is\n       Complex   : Boolean;\n       Count     : Natural;\n       Float_Rep : Float_Rep_Kind;\n+      Precision : Positive;\n       Size      : Positive;\n       Alignment : Natural);\n    pragma Convention (C, Register_Float_Type);\n@@ -151,7 +152,8 @@ package body Set_Targ is\n    --  non-zero if the type has real and imaginary parts (also ignored during\n    --  registration). Count is the number of elements in a vector type (zero =\n    --  not a vector, registration ignores vectors). Float_Rep shows the kind of\n-   --  floating-point type, and Size/Alignment are the size/alignment in bits.\n+   --  floating-point type, and Precision, Size and Alignment are the precision\n+   --  size and alignment in bits.\n    --\n    --  So to summarize, the only types that are actually registered have Digs\n    --  non-zero, Complex zero (false), and Count zero (not a vector).\n@@ -179,6 +181,7 @@ package body Set_Targ is\n       Complex   : Boolean;\n       Count     : Natural;\n       Float_Rep : Float_Rep_Kind;\n+      Precision : Positive;\n       Size      : Positive;\n       Alignment : Natural)\n    is\n@@ -244,13 +247,24 @@ package body Set_Targ is\n \n          else\n             Write_Str (\"mod 2**\");\n-            Write_Int (Int (Size / Positive'Max (1, Count)));\n+            Write_Int (Int (Precision / Positive'Max (1, Count)));\n             Write_Line (\";\");\n          end if;\n \n-         Write_Str (\"for \" & T (1 .. Last) & \"'Size use \");\n-         Write_Int (Int (Size));\n-         Write_Line (\";\");\n+         if Precision = Size then\n+            Write_Str (\"for \" & T (1 .. Last) & \"'Size use \");\n+            Write_Int (Int (Size));\n+            Write_Line (\";\");\n+\n+         else\n+            Write_Str (\"for \" & T (1 .. Last) & \"'Value_Size use \");\n+            Write_Int (Int (Precision));\n+            Write_Line (\";\");\n+\n+            Write_Str (\"for \" & T (1 .. Last) & \"'Object_Size use \");\n+            Write_Int (Int (Size));\n+            Write_Line (\";\");\n+         end if;\n \n          Write_Str (\"for \" & T (1 .. Last) & \"'Alignment use \");\n          Write_Int (Int (Alignment / 8));\n@@ -286,6 +300,7 @@ package body Set_Targ is\n            (NAME      => new String'(T (1 .. Last)),\n             DIGS      => Digs,\n             FLOAT_REP => Float_Rep,\n+            PRECISION => Precision,\n             SIZE      => Size,\n             ALIGNMENT => Alignment);\n       end if;\n@@ -448,7 +463,7 @@ package body Set_Targ is\n \n             AddC (' ');\n \n-            AddN (E.SIZE);\n+            AddN (E.PRECISION);\n             AddC (' ');\n \n             AddN (E.ALIGNMENT);\n@@ -826,7 +841,7 @@ begin\n                N := N + 1;\n                Check_Spaces;\n \n-               E.SIZE := Get_Nat;\n+               E.PRECISION := Get_Nat;\n                Check_Spaces;\n \n                E.ALIGNMENT := Get_Nat;\n@@ -835,6 +850,11 @@ begin\n                   FailN (\"junk at end of line for\");\n                end if;\n \n+               --  ??? We do not read E.SIZE, see Write_Target_Dependent_Values\n+\n+               E.SIZE :=\n+                 (E.PRECISION + E.ALIGNMENT - 1) / E.ALIGNMENT * E.ALIGNMENT;\n+\n                N := N + 1;\n             end;\n          end loop;"}, {"sha": "d3ae3d838ffc6b1f4223ad216fb9144b5869bcdb", "filename": "gcc/ada/set_targ.ads", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00c5acd39f33c335223428099d5427fad1557db9/gcc%2Fada%2Fset_targ.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00c5acd39f33c335223428099d5427fad1557db9/gcc%2Fada%2Fset_targ.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fset_targ.ads?ref=00c5acd39f33c335223428099d5427fad1557db9", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---            Copyright (C) 2013, Free Software Foundation, Inc.            --\n+--          Copyright (C) 2013-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -94,6 +94,7 @@ package Set_Targ is\n       NAME      : String_Ptr;     -- Name of mode (no null character at end)\n       DIGS      : Natural;        -- Digits for floating-point type\n       FLOAT_REP : Float_Rep_Kind; -- Float representation\n+      PRECISION : Natural;        -- Precision in bits\n       SIZE      : Natural;        -- Size in bits\n       ALIGNMENT : Natural;        -- Alignment in bits\n    end record;\n@@ -130,13 +131,20 @@ package Set_Targ is\n    --\n    --     One line per registered mode\n    --\n-   --       name  digs float_rep size alignment\n+   --       name  digs float_rep precision alignment\n    --\n    --     where name is the string name of the type (which can have single\n    --     spaces embedded in the name (e.g. long double). The name is followed\n    --     by at least two blanks. The following fields are as described above\n    --     for a Mode_Entry (where float_rep is I/V/A for IEEE-754-Binary,\n    --     Vax_Native, AAMP), fields are separated by at least one blank, and\n    --     a LF character immediately follows the alignment field.\n+   --\n+   --     ??? We do not write the size for backward compatibility reasons,\n+   --     which means that target.atp will not be a complete description for\n+   --     the very peculiar cases where the size cannot be computed from the\n+   --     precision and the alignment by the formula:\n+   --\n+   --       size := (precision + alignment - 1) / alignment * alignment\n \n end Set_Targ;"}]}