{"sha": "dc91c65378cd0e6c07dde9ca119ec0cc7304b039", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGM5MWM2NTM3OGNkMGU2YzA3ZGRlOWNhMTE5ZWMwY2M3MzA0YjAzOQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-09-04T07:27:42Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-09-04T07:27:42Z"}, "message": "re PR middle-end/36262 (Extreme memory usage of VRP compared to older versions)\n\n2019-09-04  Richard Biener  <rguenther@suse.de>\n\n\tPR rtl-optimization/36262\n\t* postreload-gcse.c: Include intl.h and gcse.h.\n\t(insert_expr_in_table): Insert at the head of cur_expr->avail_occr\n\tto avoid linear list walk.\n\t(record_last_mem_set_info): Gate off if not computing transparentness.\n\t(get_bb_avail_insn): If transparentness isn't computed give up\n\tearly.\n\t(gcse_after_reload_main): Skip compute_transp and extended PRE\n\tif gcse_or_cprop_is_too_expensive says so.\n\nFrom-SVN: r275365", "tree": {"sha": "70c895f15d4a9ae8667a6788b09613b0229f0ecc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/70c895f15d4a9ae8667a6788b09613b0229f0ecc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc91c65378cd0e6c07dde9ca119ec0cc7304b039", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc91c65378cd0e6c07dde9ca119ec0cc7304b039", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc91c65378cd0e6c07dde9ca119ec0cc7304b039", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc91c65378cd0e6c07dde9ca119ec0cc7304b039/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f8e36f0aef5f867fdde0a1abff5bbc66c17a6429", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8e36f0aef5f867fdde0a1abff5bbc66c17a6429", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8e36f0aef5f867fdde0a1abff5bbc66c17a6429"}], "stats": {"total": 76, "additions": 44, "deletions": 32}, "files": [{"sha": "fa47927e47f4d2fec83d3d7d7f0c335999b24735", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc91c65378cd0e6c07dde9ca119ec0cc7304b039/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc91c65378cd0e6c07dde9ca119ec0cc7304b039/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dc91c65378cd0e6c07dde9ca119ec0cc7304b039", "patch": "@@ -1,3 +1,15 @@\n+2019-09-04  Richard Biener  <rguenther@suse.de>\n+\n+\tPR rtl-optimization/36262\n+\t* postreload-gcse.c: Include intl.h and gcse.h.\n+\t(insert_expr_in_table): Insert at the head of cur_expr->avail_occr\n+\tto avoid linear list walk.\n+\t(record_last_mem_set_info): Gate off if not computing transparentness.\n+\t(get_bb_avail_insn): If transparentness isn't computed give up\n+\tearly.\n+\t(gcse_after_reload_main): Skip compute_transp and extended PRE\n+\tif gcse_or_cprop_is_too_expensive says so.\n+\n 2019-09-03  Jozef Lawrynowicz  <jozef.l@mittosystems.com>\n \n \t* config/msp430/msp430.c (msp430_init_sections): Remove handling of the"}, {"sha": "786678c66c8949cbe17c1f53af3a4e8403698106", "filename": "gcc/postreload-gcse.c", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc91c65378cd0e6c07dde9ca119ec0cc7304b039/gcc%2Fpostreload-gcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc91c65378cd0e6c07dde9ca119ec0cc7304b039/gcc%2Fpostreload-gcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload-gcse.c?ref=dc91c65378cd0e6c07dde9ca119ec0cc7304b039", "patch": "@@ -38,7 +38,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"params.h\"\n #include \"tree-pass.h\"\n #include \"dbgcnt.h\"\n+#include \"intl.h\"\n #include \"gcse-common.h\"\n+#include \"gcse.h\"\n \n /* The following code implements gcse after reload, the purpose of this\n    pass is to cleanup redundant loads generated by reload and other\n@@ -364,7 +366,7 @@ insert_expr_in_table (rtx x, rtx_insn *insn)\n   int do_not_record_p;\n   hashval_t hash;\n   struct expr *cur_expr, **slot;\n-  struct occr *avail_occr, *last_occr = NULL;\n+  struct occr *avail_occr;\n \n   hash = hash_expr (x, &do_not_record_p);\n \n@@ -405,38 +407,22 @@ insert_expr_in_table (rtx x, rtx_insn *insn)\n       cur_expr = *slot;\n     }\n \n-  /* Search for another occurrence in the same basic block.  */\n+  /* Search for another occurrence in the same basic block.  We insert\n+     insns blockwise from start to end, so keep appending to the\n+     start of the list so we have to check only a single element.  */\n   avail_occr = cur_expr->avail_occr;\n-  while (avail_occr\n-\t && BLOCK_FOR_INSN (avail_occr->insn) != BLOCK_FOR_INSN (insn))\n-    {\n-      /* If an occurrence isn't found, save a pointer to the end of\n-\t the list.  */\n-      last_occr = avail_occr;\n-      avail_occr = avail_occr->next;\n-    }\n-\n-  if (avail_occr)\n-    /* Found another instance of the expression in the same basic block.\n-       Prefer this occurrence to the currently recorded one.  We want\n-       the last one in the block and the block is scanned from start\n-       to end.  */\n+  if (avail_occr\n+      && BLOCK_FOR_INSN (avail_occr->insn) == BLOCK_FOR_INSN (insn))\n     avail_occr->insn = insn;\n   else\n     {\n       /* First occurrence of this expression in this basic block.  */\n       avail_occr = (struct occr *) obstack_alloc (&occr_obstack,\n \t\t\t\t\t\t  sizeof (struct occr));\n-\n-      /* First occurrence of this expression in any block?  */\n-      if (cur_expr->avail_occr == NULL)\n-        cur_expr->avail_occr = avail_occr;\n-      else\n-        last_occr->next = avail_occr;\n-\n       avail_occr->insn = insn;\n-      avail_occr->next = NULL;\n+      avail_occr->next = cur_expr->avail_occr;\n       avail_occr->deleted_p = 0;\n+      cur_expr->avail_occr = avail_occr;\n     }\n }\n \f\n@@ -710,6 +696,9 @@ record_last_reg_set_info_regno (rtx_insn *insn, int regno)\n static void\n record_last_mem_set_info (rtx_insn *insn)\n {\n+  if (!transp)\n+    return;\n+\n   struct modifies_mem *list_entry;\n \n   list_entry = (struct modifies_mem *) obstack_alloc (&modifies_mem_obstack,\n@@ -995,7 +984,8 @@ get_bb_avail_insn (basic_block bb, struct occr *orig_occr, int bitmap_index)\n   /* If we could not find an occurrence in BB, see if BB\n      has a single predecessor with an occurrence that is\n      transparent through BB.  */\n-  if (single_pred_p (bb)\n+  if (transp\n+      && single_pred_p (bb)\n       && bitmap_bit_p (transp[bb->index], bitmap_index)\n       && (occr = get_bb_avail_insn (single_pred (bb), orig_occr, bitmap_index)))\n     {\n@@ -1371,6 +1361,10 @@ delete_redundant_insns (void)\n static void\n gcse_after_reload_main (rtx f ATTRIBUTE_UNUSED)\n {\n+  /* Disable computing transparentness if it is too expensive.  */\n+  bool do_transp\n+    = !gcse_or_cprop_is_too_expensive (_(\"using simple load CSE after register \"\n+\t\t\t\t\t \"allocation\"));\n \n   memset (&stats, 0, sizeof (stats));\n \n@@ -1392,15 +1386,21 @@ gcse_after_reload_main (rtx f ATTRIBUTE_UNUSED)\n \t increase the number of redundant loads found.  So compute transparency\n \t information for each memory expression in the hash table.  */\n       df_analyze ();\n-      /* This cannot be part of the normal allocation routine because\n-\t we have to know the number of elements in the hash table.  */\n-      transp = sbitmap_vector_alloc (last_basic_block_for_fn (cfun),\n-\t\t\t\t     expr_table->elements ());\n-      bitmap_vector_ones (transp, last_basic_block_for_fn (cfun));\n-      expr_table->traverse <FILE *, compute_expr_transp> (dump_file);\n+      if (do_transp)\n+\t{\n+\t  /* This cannot be part of the normal allocation routine because\n+\t     we have to know the number of elements in the hash table.  */\n+\t  transp = sbitmap_vector_alloc (last_basic_block_for_fn (cfun),\n+\t\t\t\t\t expr_table->elements ());\n+\t  bitmap_vector_ones (transp, last_basic_block_for_fn (cfun));\n+\t  expr_table->traverse <FILE *, compute_expr_transp> (dump_file);\n+\t}\n+      else\n+\ttransp = NULL;\n       eliminate_partially_redundant_loads ();\n       delete_redundant_insns ();\n-      sbitmap_vector_free (transp);\n+      if (do_transp)\n+\tsbitmap_vector_free (transp);\n \n       if (dump_file)\n \t{"}]}