{"sha": "d6672e91f14a7a570de58160bf251ac82e4557a3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDY2NzJlOTFmMTRhN2E1NzBkZTU4MTYwYmYyNTFhYzgyZTQ1NTdhMw==", "commit": {"author": {"name": "Joel Brobecker", "email": "brobecker@gnat.com", "date": "2004-03-22T20:57:00Z"}, "committer": {"name": "Joel Brobecker", "email": "brobecke@gcc.gnu.org", "date": "2004-03-22T20:57:00Z"}, "message": "dwarf2out.c (is_subrange_type): Do not emit a subrange_type DIE for base types.\n\n        * dwarf2out.c (is_subrange_type): Do not emit a subrange_type DIE\n        for base types.\n\nFrom-SVN: r79838", "tree": {"sha": "b6dbfe7753c9070f124746670e69a9e749c1d142", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b6dbfe7753c9070f124746670e69a9e749c1d142"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d6672e91f14a7a570de58160bf251ac82e4557a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6672e91f14a7a570de58160bf251ac82e4557a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6672e91f14a7a570de58160bf251ac82e4557a3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6672e91f14a7a570de58160bf251ac82e4557a3/comments", "author": null, "committer": null, "parents": [{"sha": "886de2d4dcf3ade25fb76c32522fd4aa2f9510b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/886de2d4dcf3ade25fb76c32522fd4aa2f9510b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/886de2d4dcf3ade25fb76c32522fd4aa2f9510b8"}], "stats": {"total": 37, "additions": 37, "deletions": 0}, "files": [{"sha": "daebc141599787bfff320cb4629b28aca628847f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6672e91f14a7a570de58160bf251ac82e4557a3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6672e91f14a7a570de58160bf251ac82e4557a3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d6672e91f14a7a570de58160bf251ac82e4557a3", "patch": "@@ -1,3 +1,8 @@\n+2004-03-22  Joel Brobecker  <brobecker@gnat.com>\n+\n+\t* dwarf2out.c (is_subrange_type): Do not emit a subrange_type DIE\n+\tfor base types.\n+\n 2004-03-22  Joel Brobecker  <brobecker@gnat.com>\n \n \t* dwarf2out.c (is_subrange_type): Minor code rework. No behavior"}, {"sha": "4a1745353c4b50b00c2726f56ed52feadf82c7cc", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6672e91f14a7a570de58160bf251ac82e4557a3/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6672e91f14a7a570de58160bf251ac82e4557a3/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=d6672e91f14a7a570de58160bf251ac82e4557a3", "patch": "@@ -8012,6 +8012,38 @@ is_subrange_type (tree type)\n       && TREE_CODE (subtype) != ENUMERAL_TYPE)\n     return false;\n \n+  if (TREE_CODE (type) == TREE_CODE (subtype)\n+      && int_size_in_bytes (type) == int_size_in_bytes (subtype)\n+      && TYPE_MIN_VALUE (type) != NULL\n+      && TYPE_MIN_VALUE (subtype) != NULL\n+      && tree_int_cst_equal (TYPE_MIN_VALUE (type), TYPE_MIN_VALUE (subtype))\n+      && TYPE_MAX_VALUE (type) != NULL\n+      && TYPE_MAX_VALUE (subtype) != NULL\n+      && tree_int_cst_equal (TYPE_MAX_VALUE (type), TYPE_MAX_VALUE (subtype)))\n+    {\n+      /* The type and its subtype have the same representation.  If in\n+         addition the two types also have the same name, then the given\n+         type is not a subrange type, but rather a plain base type.  */\n+      /* FIXME: brobecker/2004-03-22:\n+         Sizetype INTEGER_CSTs nodes are canonicalized.  It should\n+         therefore be sufficient to check the TYPE_SIZE node pointers\n+         rather than checking the actual size.  Unfortunately, we have\n+         found some cases, such as in the Ada \"integer\" type, where\n+         this is not the case.  Until this problem is solved, we need to\n+         keep checking the actual size.  */\n+      tree type_name = TYPE_NAME (type);\n+      tree subtype_name = TYPE_NAME (subtype);\n+\n+      if (type_name != NULL && TREE_CODE (type_name) == TYPE_DECL)\n+        type_name = DECL_NAME (type_name);\n+\n+      if (subtype_name != NULL && TREE_CODE (subtype_name) == TYPE_DECL)\n+        subtype_name = DECL_NAME (subtype_name);\n+\n+      if (type_name == subtype_name)\n+        return false;\n+    }\n+\n   return true;\n }\n "}]}