{"sha": "9c3ff9fc828113aaeb1efb2d69217c64eca6cdd2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWMzZmY5ZmM4MjgxMTNhYWViMWVmYjJkNjkyMTdjNjRlY2E2Y2RkMg==", "commit": {"author": {"name": "Roman Kennke", "email": "roman@kennke.org", "date": "2005-04-19T05:13:47Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2005-04-19T05:13:47Z"}, "message": "MediaTracker.java: Reindented tabs to spaces.\n\n2005-04-19  Roman Kennke  <roman@kennke.org>\n\n\t* java/awt/MediaTracker.java:\n\tReindented tabs to spaces.\n\n2005-04-19  Roman Kennke  <roman@kennke.org>\n\n\t* java/awt/MediaTracker.java\n\t(MediaEntry.imageUpdate): Removed check for SOMEBITS, this\n\tconfused the media tracker and lead to lockups. The LOADING\n\tbit is handled on other places.\n\t(addImage): Removed the 'start image tracking' stuff. This\n\tis not necessary and could confuse the media tracker.\n\t(checkAll): Improved the check for image status so that\n\timages that already complete images are detected. Also now\n\tare really all images checked and if necessary loaded. Before\n\tthe method bailed out after the first incomplete image.\n\t(statusAll): Detect images that are complete after the\n\tcall to Component.prepareImage(..).\n\t(checkID): The same as in checkAll.\n\t(statusID): The same as in statusAll.\n\n2005-04-19  Roman Kennke  <roman@kennke.org>\n\n\t* java/awt/MediaTracker.java\n\t(addImage): Synchronized list access.\n\t(waitForAll): Fixed comparison of time (changed < to >).\n\t(waitForID): Fixed comparison of time (changed < to >).\n\t(removeImage): Synchronized list access.\n\n2005-04-19  Roman Kennke  <roman@kennke.org>\n\n\t* java/awt/MediaTracker.java\n\tAdded API documentation.\n\n2005-04-19  Roman Kennke  <roman@kennke.org>\n\n\t* java/awt/MediaTracker.java\n\t(MediaEntry.imageUpdate): Fixed flags. The different flags\n\tmust not be ORed together.\n\t(checkAll): Modified to handle different meaning of the flags.\n\t(waitForAll): Fixed so that it waits maximum the\n\tspecified amount of milliseconds.\n\t(statusAll): Modified to handle different meaning of the flags.\n\t(waitForID): Fixed so that it waits maximum the\n\tspecified amount of milliseconds.\n\nFrom-SVN: r98374", "tree": {"sha": "84f14164ad5d8d059d63083918e815d6d40cc433", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/84f14164ad5d8d059d63083918e815d6d40cc433"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9c3ff9fc828113aaeb1efb2d69217c64eca6cdd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c3ff9fc828113aaeb1efb2d69217c64eca6cdd2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c3ff9fc828113aaeb1efb2d69217c64eca6cdd2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c3ff9fc828113aaeb1efb2d69217c64eca6cdd2/comments", "author": null, "committer": null, "parents": [{"sha": "d6e4d86e1ddbfb19e90416b756366bde4753a9fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6e4d86e1ddbfb19e90416b756366bde4753a9fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6e4d86e1ddbfb19e90416b756366bde4753a9fa"}], "stats": {"total": 567, "additions": 439, "deletions": 128}, "files": [{"sha": "6360762deb365e90214d7a1cd369b8bfffdbec27", "filename": "libjava/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c3ff9fc828113aaeb1efb2d69217c64eca6cdd2/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c3ff9fc828113aaeb1efb2d69217c64eca6cdd2/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=9c3ff9fc828113aaeb1efb2d69217c64eca6cdd2", "patch": "@@ -1,3 +1,50 @@\n+2005-04-19  Roman Kennke  <roman@kennke.org>\n+\n+\t* java/awt/MediaTracker.java:\n+\tReindented tabs to spaces.\n+\n+2005-04-19  Roman Kennke  <roman@kennke.org>\n+\n+\t* java/awt/MediaTracker.java\n+\t(MediaEntry.imageUpdate): Removed check for SOMEBITS, this\n+\tconfused the media tracker and lead to lockups. The LOADING\n+\tbit is handled on other places.\n+\t(addImage): Removed the 'start image tracking' stuff. This\n+\tis not necessary and could confuse the media tracker.\n+\t(checkAll): Improved the check for image status so that\n+\timages that already complete images are detected. Also now\n+\tare really all images checked and if necessary loaded. Before\n+\tthe method bailed out after the first incomplete image.\n+\t(statusAll): Detect images that are complete after the\n+\tcall to Component.prepareImage(..).\n+\t(checkID): The same as in checkAll.\n+\t(statusID): The same as in statusAll.\n+\n+2005-04-19  Roman Kennke  <roman@kennke.org>\n+\n+\t* java/awt/MediaTracker.java\n+\t(addImage): Synchronized list access.\n+\t(waitForAll): Fixed comparison of time (changed < to >).\n+\t(waitForID): Fixed comparison of time (changed < to >).\n+\t(removeImage): Synchronized list access.\n+\n+2005-04-19  Roman Kennke  <roman@kennke.org>\n+\n+\t* java/awt/MediaTracker.java\n+\tAdded API documentation.\n+\n+2005-04-19  Roman Kennke  <roman@kennke.org>\n+\n+\t* java/awt/MediaTracker.java\n+\t(MediaEntry.imageUpdate): Fixed flags. The different flags\n+\tmust not be ORed together.\n+\t(checkAll): Modified to handle different meaning of the flags.\n+\t(waitForAll): Fixed so that it waits maximum the\n+\tspecified amount of milliseconds.\n+\t(statusAll): Modified to handle different meaning of the flags.\n+\t(waitForID): Fixed so that it waits maximum the\n+\tspecified amount of milliseconds.\n+\n 2005-04-19  vid Gilbert <david.gilbert@object-refinery.com>\n \n \t* java/awt/Font.java (decode): Handle null argument and allow"}, {"sha": "2c51fbd19a14d5c738f3d5fe4dfa2f4e53ebc5a8", "filename": "libjava/java/awt/MediaTracker.java", "status": "modified", "additions": 392, "deletions": 128, "changes": 520, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c3ff9fc828113aaeb1efb2d69217c64eca6cdd2/libjava%2Fjava%2Fawt%2FMediaTracker.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c3ff9fc828113aaeb1efb2d69217c64eca6cdd2/libjava%2Fjava%2Fawt%2FMediaTracker.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FMediaTracker.java?ref=9c3ff9fc828113aaeb1efb2d69217c64eca6cdd2", "patch": "@@ -45,145 +45,257 @@\n   * This class is used for keeping track of the status of various media\n   * objects.\n   *\n+  * Media objects are tracked by assigning them an ID. It is possible\n+  * to assign the same ID to mutliple objects, effectivly grouping them\n+  * together. In this case the status flags ({@link #statusID}) and error flag\n+  * (@link #isErrorID} and {@link #getErrorId}) are ORed together. This\n+  * means that you cannot say exactly which media object has which status,\n+  * at most you can say that there <em>are</em> certain media objects with\n+  * some certain status.\n+  * \n+  * At the moment only images are supported by this class.\n+  *\n   * @author Aaron M. Renn (arenn@urbanophile.com)\n   * @author Bryce McKinlay\n   */\n public class MediaTracker implements java.io.Serializable\n {\n+  /** Indicates that the media is still loading. */\n   public static final int LOADING = 1 << 0;\n+\n+  /** Indicates that the loading operation has been aborted. */\n   public static final int ABORTED = 1 << 1;\n+\n+  /** Indicates that an error has occured during loading of the media. */\n   public static final int ERRORED = 1 << 2;\n+\n+  /** Indicates that the media has been successfully and completely loaded. */\n   public static final int COMPLETE = 1 << 3;\n-  \n+\n+  /** The component on which the media is eventually been drawn. */\n   Component target;\n+\n+  /** The head of the linked list of tracked media objects. */\n   MediaEntry head;\n \n+  /** Our serialVersionUID for serialization. */\n   static final long serialVersionUID = -483174189758638095L;\n \n+  /**\n+   * This represents a media object that is tracked by a MediaTracker.\n+   * It also implements a simple linked list.\n+   */\n   // FIXME: The serialized form documentation says MediaEntry is a \n   // serializable field, but the serialized form of MediaEntry itself\n   // doesn't appear to be documented.\n   class MediaEntry implements ImageObserver\n   {\n+    /** The ID of the media object. */\n     int id;\n+\n+    /** The media object. (only images are supported ATM). */\n     Image image;\n+\n+    /** The link to the next entry in the list. */\n     MediaEntry next;\n+\n+    /** The tracking status. */\n     int status;\n+\n+    /** The width of the image. */\n     int width;\n+\n+    /** The height of the image. */\n     int height;\n     \n+    /**\n+     * Receives notification from an {@link java.awt.image.ImageProducer}\n+     * that more data of the image is available.\n+     *\n+     * @param img the image that is updated\n+     * @param flags flags from the ImageProducer that indicate the status\n+     *        of the loading process\n+     * @param x the X coordinate of the upper left corner of the image\n+     * @param y the Y coordinate of the upper left corner of the image\n+     * @param width the width of the image\n+     * @param height the height of the image\n+     *\n+     * @return <code>true</code> if more data is needed, <code>false</code>\n+     *         otherwise\n+     *\n+     * @see {@link java.awt.image.ImageObserver}\n+     */\n     public boolean imageUpdate(Image img, int flags, int x, int y, \n-\t\t\t       int width, int height)\n+                               int width, int height)\n     {\n       if ((flags & ABORT) != 0)\n-        status = ABORTED | COMPLETE;\n+        status = ABORTED;\n       else if ((flags & ERROR) != 0)\n-        status = ERRORED | COMPLETE;\n+        status = ERRORED;\n       else if ((flags & ALLBITS) != 0)\n         status = COMPLETE;\n-      else if ((flags & SOMEBITS) != 0)\n-        status = LOADING;\n       else\n         status = 0;\n \n-      if ((status & COMPLETE) == COMPLETE)\n-      {\n-        synchronized (MediaTracker.this)\n+      synchronized (MediaTracker.this)\n         {\n           MediaTracker.this.notifyAll();\n         }\n-      }\n+\n       // If status is not COMPLETE then we need more updates.\n-      return (status & COMPLETE) == 0;\n+      return ((status & (COMPLETE | ERRORED | ABORTED)) == 0);\n     }\n   }\n \n+  /**\n+   * Constructs a new MediaTracker for the component <code>c</code>. The\n+   * component should be the component that uses the media (i.e. draws it).\n+   *\n+   * @param c the Component that wants to use the media\n+   */\n   public MediaTracker(Component c)\n   {\n     target = c;\n   }\n \n+  /**\n+   * Adds an image to the tracker with the specified <code>ID</code>.\n+   *\n+   * @param image the image to be added\n+   * @param id the ID of the tracker list to which the image is added\n+   */\n   public void addImage(Image image, int id)\n   {\n     MediaEntry e = new MediaEntry();\n     e.id = id;\n     e.image = image;\n-    e.next = head;\n-    head = e;\n-    // Start tracking image status.\n-    int flags = target.checkImage(image, e);\n-    e.imageUpdate(image, flags, -1, -1, -1, -1);\n+    synchronized(this)\n+      {\n+        e.next = head;\n+        head = e;\n+      }\n   }\n \n+  /**\n+   * Adds an image to the tracker with the specified <code>ID</code>.\n+   * The image is expected to be rendered with the specified width and\n+   * height.\n+   *\n+   * @param image the image to be added\n+   * @param id the ID of the tracker list to which the image is added\n+   * @param width the width of the image\n+   * @param height the height of the image\n+   */\n   public void addImage(Image image, int id, int width, int height)\n   {\n     MediaEntry e = new MediaEntry();\n     e.id = id;\n     e.image = image;\n-    e.next = head;\n     e.width = width;\n     e.height = height;\n-    head = e;\n-    // Start tracking image status.\n-    int flags = target.checkImage(image, width, height, e);\n-    e.imageUpdate(image, flags, -1, -1, width, height);\n+    synchronized(this)\n+      {\n+        e.next = head;\n+        head = e;\n+      }\n   }\n \n+  /**\n+   * Checks if all media objects have finished loading, i.e. are\n+   * {@link #COMPLETE}, {@link #ABORTED} or {@link #ERRORED}.\n+   *\n+   * If the media objects are not already loading, a call to this\n+   * method does <em>not</em> start loading. This is equivalent to\n+   * a call to <code>checkAll(false)</code>.\n+   *\n+   * @return if all media objects have finished loading either by beeing\n+   *         complete, have been aborted or errored.\n+   */\n   public boolean checkAll()\n   {\n     return checkAll(false);\n   }\n \n+  /**\n+   * Checks if all media objects have finished loading, i.e. are\n+   * {@link #COMPLETE}, {@link #ABORTED} or {@link #ERRORED}.\n+   *\n+   * If the media objects are not already loading, and <code>load</code>\n+   * is <code>true</code> then a call to this\n+   * method starts loading the media objects.\n+   *\n+   * @param load if <code>true</code> this method starts loading objects\n+   *        that are not already loading\n+   *\n+   * @return if all media objects have finished loading either by beeing\n+   *         complete, have been aborted or errored.\n+   */\n   public boolean checkAll(boolean load)\n   {\n     MediaEntry e = head;\n     boolean result = true;\n     \n     while (e != null)\n       {\n-\tif ((e.status & COMPLETE) == 0)\n-\t  {\n-\t    if (load)\n-\t      {\n-\t\tresult = false;\n-\t        if (e.status == 0)\n-\t\t  {\n-\t\t    target.prepareImage(e.image, e);\n-\t\t    e.status = LOADING;\n-\t\t  }\n-\t      }\n-\t    else\n-\t      return false;\n-\t  }\n-\te = e.next;\n+        if ((e.status & (COMPLETE | ERRORED | ABORTED)) == 0)\n+          {\n+            if (load && ((e.status & LOADING) == 0))\n+              {\n+                e.status = LOADING;\n+                result = false;\n+                boolean complete = target.prepareImage(e.image, e);\n+                if (complete)\n+                  {\n+                    e.status = COMPLETE;\n+                    result = true;\n+                  }\n+              }\n+            else\n+              result = false;\n+          }\n+        e = e.next;\n       }\n     return result;\n   }\n \n+  /**\n+   * Checks if any of the registered media objects has encountered an error\n+   * during loading.\n+   *\n+   * @return <code>true</code> if at least one media object has encountered\n+   *         an error during loading, <code>false</code> otherwise\n+   *\n+   */\n   public boolean isErrorAny()\n   {\n     MediaEntry e = head;    \n     while (e != null)\n       {\n         if ((e.status & ERRORED) != 0)\n-\t  return true;\n+          return true;\n         e = e.next;\n       }\n     return false;\n   }\n \n+  /**\n+   * Returns all media objects that have encountered errors during loading.\n+   *\n+   * @return an array of all media objects that have encountered errors\n+   *         or <code>null</code> if there were no errors at all\n+   */\n   public Object[] getErrorsAny()\n   {\n     MediaEntry e = head;\n     ArrayList result = null;\n     while (e != null)\n       {\n         if ((e.status & ERRORED) != 0)\n-\t  {\n-\t    if (result == null)\n-\t      result = new ArrayList();\n-\t    result.add(e.image);\n-\t  }\n+          {\n+            if (result == null)\n+              result = new ArrayList();\n+            result.add(e.image);\n+          }\n         e = e.next;\n       }\n     if (result == null)\n@@ -192,6 +304,13 @@ public Object[] getErrorsAny()\n       return result.toArray();\n   }\n \n+  /**\n+   * Waits for all media objects to finish loading, either by completing\n+   * successfully or by aborting or encountering an error.\n+   *\n+   * @throws InterruptedException if another thread interrupted the\n+   *         current thread while waiting\n+   */\n   public void waitForAll() throws InterruptedException\n   {\n     synchronized (this)\n@@ -201,92 +320,166 @@ public void waitForAll() throws InterruptedException\n     }\n   }\n \n+  /**\n+   * Waits for all media objects to finish loading, either by completing\n+   * successfully or by aborting or encountering an error.\n+   *\n+   * This method waits at most <code>ms</code> milliseconds. If the\n+   * media objects have not completed loading within this timeframe, this\n+   * method returns <code>false</code>, otherwise <code>true</code>.\n+   *\n+   * @param ms timeframe in milliseconds to wait for the media objects to\n+   *        finish\n+   *\n+   * @return <code>true</code> if all media objects have successfully loaded\n+   *         within the timeframe, <code>false</code> otherwise\n+   *\n+   * @throws InterruptedException if another thread interrupted the\n+   *         current thread while waiting\n+   */\n   public boolean waitForAll(long ms) throws InterruptedException\n   {\n     long start = System.currentTimeMillis();\n+    boolean result = checkAll(true);\n     synchronized (this)\n     {\n-      while (!checkAll(true))\n-        wait(ms);\n+      while (result == false)\n+        {\n+          wait(ms);\n+          result = checkAll(true);\n+          if ((System.currentTimeMillis() - start) > ms)\n+            break;\n+        }\n     }\n-    if ((System.currentTimeMillis() - start) < ms)\n-      return true;\n-    else\n-      return false;\n+\n+    return result;\n   }\n \n+  /**\n+   * Returns the status flags of all registered media objects ORed together.\n+   * If <code>load</code> is <code>true</code> then media objects that\n+   * are not already loading will be started to load.\n+   *\n+   * @param load if set to <code>true</code> then media objects that are\n+   *        not already loading are started\n+   *\n+   * @return the status flags of all tracked media objects ORed together\n+   */\n   public int statusAll(boolean load)\n   {\n     int result = 0;\n     MediaEntry e = head;\n     while (e != null)\n       {\n         if (load && e.status == 0)\n-\t  {\n-\t    target.prepareImage(e.image, e);\n-\t    e.status = LOADING;\n-\t  }\n+          {\n+            boolean complete = target.prepareImage(e.image, e);\n+            if (complete)\n+              e.status = COMPLETE;\n+            else\n+              e.status = LOADING;\n+          }\n         result |= e.status;\n-\te = e.next;\n+        e = e.next;\n       }\n     return result;\n   }\n \n+  /**\n+   * Checks if the media objects with <code>ID</code> have completed loading.\n+   *\n+   * @param id the ID of the media objects to check\n+   *\n+   * @return <code>true</code> if all media objects with <code>ID</code>\n+   *         have successfully finished\n+   */\n   public boolean checkID(int id)\n   {\n     return checkID(id, false);\n   }\n \n+  /**\n+   * Checks if the media objects with <code>ID</code> have completed loading.\n+   * If <code>load</code> is <code>true</code> then media objects that\n+   * are not already loading will be started to load.\n+   *\n+   * @param id the ID of the media objects to check\n+   * @param load if set to <code>true</code> then media objects that are\n+   *        not already loading are started\n+   *\n+   * @return <code>true</code> if all media objects with <code>ID</code>\n+   *         have successfully finished\n+   */\n   public boolean checkID(int id, boolean load)\n   {\n     MediaEntry e = head;\n     boolean result = true;\n     \n     while (e != null)\n       {\n-\tif (e.id == id && ((e.status & COMPLETE) == 0))\n-\t  {\n-\t    if (load)\n-\t      {\n-\t\tresult = false;\n-\t        if (e.status == 0)\n-\t\t  {\n-\t\t    target.prepareImage(e.image, e);\n-\t\t    e.status = LOADING;\n-\t\t  }\n-\t      }\n-\t    else\n-\t      return false;\n-\t  }\n-\te = e.next;\n+        if (e.id == id && ((e.status & (COMPLETE | ABORTED | ERRORED)) == 0))\n+          {\n+            if (load && ((e.status & LOADING) == 0))\n+              {\n+                e.status = LOADING;\n+                result = false;\n+                boolean complete = target.prepareImage(e.image, e);\n+                if (complete)\n+                  {\n+                    e.status = COMPLETE;\n+                    result = true;\n+                  }\n+              }\n+            else\n+              result = false;\n+          }\n+        e = e.next;\n       }\n     return result;\n   }\n \n+  /**\n+   * Returns <code>true</code> if any of the media objects with <code>ID</code>\n+   * have encountered errors during loading, false otherwise.\n+   *\n+   * @param id the ID of the media objects to check\n+   *\n+   * @return <code>true</code> if any of the media objects with <code>ID</code>\n+   *         have encountered errors during loading, false otherwise\n+   */\n   public boolean isErrorID(int id)\n   {\n     MediaEntry e = head;    \n     while (e != null)\n       {\n         if (e.id == id && ((e.status & ERRORED) != 0))\n-\t  return true;\n+          return true;\n         e = e.next;\n       }\n     return false;\n   }\n \n+  /**\n+   * Returns all media objects with the specified ID that have encountered\n+   * an error.\n+   *\n+   * @param id the ID of the media objects to check\n+   *\n+   * @return an array of all media objects  with the specified ID that\n+   *         have encountered an error\n+   */\n   public Object[] getErrorsID(int id)\n   {\n     MediaEntry e = head;\n     ArrayList result = null;\n     while (e != null)\n       {\n         if (e.id == id && ((e.status & ERRORED) != 0))\n-\t  {\n-\t    if (result == null)\n-\t      result = new ArrayList();\n-\t    result.add(e.image);\n-\t  }\n+          {\n+            if (result == null)\n+              result = new ArrayList();\n+            result.add(e.image);\n+          }\n         e = e.next;\n       }\n     if (result == null)\n@@ -295,6 +488,15 @@ public Object[] getErrorsID(int id)\n       return result.toArray();\n   }\n \n+  /**\n+   * Waits for all media objects with the specified ID to finish loading,\n+   * either by completing successfully or by aborting or encountering an error.\n+   *\n+   * @param id the ID of the media objects to wait for\n+   *\n+   * @throws InterruptedException if another thread interrupted the\n+   *         current thread while waiting\n+   */\n   public void waitForID(int id) throws InterruptedException\n   {\n     MediaEntry e = head;\n@@ -305,95 +507,157 @@ public void waitForID(int id) throws InterruptedException\n     }\n   }\n \n+  /**\n+   * Waits for all media objects with the specified ID to finish loading,\n+   * either by completing successfully or by aborting or encountering an error.\n+   *\n+   * This method waits at most <code>ms</code> milliseconds. If the\n+   * media objects have not completed loading within this timeframe, this\n+   * method returns <code>false</code>, otherwise <code>true</code>.\n+   *\n+   * @param id the ID of the media objects to wait for\n+   * @param ms timeframe in milliseconds to wait for the media objects to\n+   *        finish\n+   *\n+   * @return <code>true</code> if all media objects have successfully loaded\n+   *         within the timeframe, <code>false</code> otherwise\n+   *\n+   * @throws InterruptedException if another thread interrupted the\n+   *         current thread while waiting\n+   */\n   public boolean waitForID(int id, long ms) throws InterruptedException\n   {\n     MediaEntry e = head;\n     long start = System.currentTimeMillis();\n+    boolean result = checkID(id, true);\n+\n     synchronized (this)\n     {\n-      while (checkID (id, true) == false)\n-        wait(ms);\n-    }  \n-    if ((System.currentTimeMillis() - start) < ms)\n-      return true;\n-    else\n-      return false;\n+      while (result == false)\n+        {\n+          wait(ms);\n+          result = checkID(id, true);\n+          if ((System.currentTimeMillis() - start) > ms)\n+            break;\n+        }\n+    }\n+\n+    return result;\n   }\n \n+  /**\n+   * Returns the status flags of the media objects with the specified ID\n+   * ORed together.\n+   *\n+   * If <code>load</code> is <code>true</code> then media objects that\n+   * are not already loading will be started to load.\n+   *\n+   * @param load if set to <code>true</code> then media objects that are\n+   *        not already loading are started\n+   *\n+   * @return the status flags of all tracked media objects ORed together\n+   */\n   public int statusID(int id, boolean load)\n   {\n     int result = 0;\n     MediaEntry e = head;\n     while (e != null)\n       {\n         if (e.id == id)\n-\t  {\n+          {\n             if (load && e.status == 0)\n-\t      {\n-\t\ttarget.prepareImage(e.image, e);\n-\t\te.status = LOADING;\n-\t      }\n+              {\n+                boolean complete = target.prepareImage(e.image, e);\n+                if (complete)\n+                  e.status = COMPLETE;\n+                else\n+                  e.status = LOADING;\n+              }\n             result |= e.status;\n-\t  }\n-\te = e.next;\n+          }\n+        e = e.next;\n       }\n     return result;\n   }\n \n+  /**\n+   * Removes an image from this MediaTracker.\n+   *\n+   * @param image the image to be removed\n+   */\n   public void removeImage(Image image)\n   {\n-    MediaEntry e = head;\n-    MediaEntry prev = null;\n-    while (e != null)\n+    synchronized (this)\n       {\n-        if (e.image == image)\n-\t  {\n-\t    if (prev == null)\n-\t      head = e.next;\n-\t    else\n-\t      prev.next = e.next;\n-\t  }\n-\tprev = e;\n-\te = e.next;\n+        MediaEntry e = head;\n+        MediaEntry prev = null;\n+        while (e != null)\n+          {\n+            if (e.image == image)\n+              {\n+                if (prev == null)\n+                  head = e.next;\n+                else\n+                  prev.next = e.next;\n+              }\n+            prev = e;\n+            e = e.next;\n+          }\n       }\n   }\n \n+  /**\n+   * Removes an image with the specified ID from this MediaTracker.\n+   *\n+   * @param image the image to be removed\n+   */\n   public void removeImage(Image image, int id)\n   {\n-    MediaEntry e = head;\n-    MediaEntry prev = null;\n-    while (e != null)\n+    synchronized (this)\n       {\n-        if (e.id == id && e.image == image)\n-\t  {\n-\t    if (prev == null)\n-\t      head = e.next;\n-\t    else\n-\t      prev.next = e.next;\n-\t  }\n-\telse\n-\t  prev = e;\n-\te = e.next;\n-      }  \n+        MediaEntry e = head;\n+        MediaEntry prev = null;\n+        while (e != null)\n+          {\n+            if (e.id == id && e.image == image)\n+              {\n+                if (prev == null)\n+                  head = e.next;\n+                else\n+                  prev.next = e.next;\n+              }\n+            else\n+              prev = e;\n+            e = e.next;\n+          }\n+      }\n   }\n \n+  /**\n+   * Removes an image with the specified ID and scale from this MediaTracker.\n+   *\n+   * @param image the image to be removed\n+   */\n   public void removeImage(Image image, int id, int width, int height)\n   {\n-    MediaEntry e = head;\n-    MediaEntry prev = null;\n-    while (e != null)\n+    synchronized (this)\n       {\n-        if (e.id == id && e.image == image\n-\t    && e.width == width && e.height == height)\n-\t  {\n-\t    if (prev == null)\n-\t      head = e.next;\n-\t    else\n-\t      prev.next = e.next;\n-\t  }\n-\telse\n-\t  prev = e;\n-\te = e.next;\n+        MediaEntry e = head;\n+        MediaEntry prev = null;\n+        while (e != null)\n+          {\n+            if (e.id == id && e.image == image\n+                && e.width == width && e.height == height)\n+              {\n+                if (prev == null)\n+                  head = e.next;\n+                else\n+                  prev.next = e.next;\n+              }\n+            else\n+              prev = e;\n+            e = e.next;\n+          }\n       }\n   }\n }"}]}