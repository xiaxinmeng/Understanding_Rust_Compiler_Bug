{"sha": "acb51b5c801540c7c15236f9f5a6be893216584f", "node_id": "C_kwDOANBUbNoAKGFjYjUxYjVjODAxNTQwYzdjMTUyMzZmOWY1YTZiZTg5MzIxNjU4NGY", "commit": {"author": {"name": "Ju-Zhe Zhong", "email": "juzhe.zhong@rivai.ai", "date": "2023-02-13T07:41:13Z"}, "committer": {"name": "Kito Cheng", "email": "kito.cheng@sifive.com", "date": "2023-02-15T13:17:21Z"}, "message": "RISC-V: Add integer compare C/C++ intrinsic support\n\ngcc/ChangeLog:\n\n\t* config/riscv/predicates.md (vector_mask_operand): Refine the codes.\n\t(vector_all_trues_mask_operand): New predicate.\n\t(vector_undef_operand): New predicate.\n\t(ltge_operator): New predicate.\n\t(comparison_except_ltge_operator): New predicate.\n\t(comparison_except_eqge_operator): New predicate.\n\t(ge_operator): New predicate.\n\t* config/riscv/riscv-v.cc (has_vi_variant_p): Add compare support.\n\t* config/riscv/riscv-vector-builtins-bases.cc (class icmp): New class.\n\t(BASE): Ditto.\n\t* config/riscv/riscv-vector-builtins-bases.h: Ditto.\n\t* config/riscv/riscv-vector-builtins-functions.def (vmseq): Ditto.\n\t(vmsne): Ditto.\n\t(vmslt): Ditto.\n\t(vmsgt): Ditto.\n\t(vmsle): Ditto.\n\t(vmsge): Ditto.\n\t(vmsltu): Ditto.\n\t(vmsgtu): Ditto.\n\t(vmsleu): Ditto.\n\t(vmsgeu): Ditto.\n\t* config/riscv/riscv-vector-builtins-shapes.cc\n\t(struct return_mask_def): Adjust for compare support.\n\t* config/riscv/riscv-vector-builtins.cc\n\t(function_expander::use_compare_insn): New function.\n\t* config/riscv/riscv-vector-builtins.h\n\t(function_expander::add_integer_operand): Ditto.\n\t* config/riscv/riscv.cc (riscv_print_operand): Add compare support.\n\t* config/riscv/riscv.md: Add vector min/max attributes.\n\t* config/riscv/vector-iterators.md (xnor): New iterator.\n\t* config/riscv/vector.md (@pred_cmp<mode>): New pattern.\n\t(*pred_cmp<mode>): Ditto.\n\t(*pred_cmp<mode>_narrow): Ditto.\n\t(@pred_ltge<mode>): Ditto.\n\t(*pred_ltge<mode>): Ditto.\n\t(*pred_ltge<mode>_narrow): Ditto.\n\t(@pred_cmp<mode>_scalar): Ditto.\n\t(*pred_cmp<mode>_scalar): Ditto.\n\t(*pred_cmp<mode>_scalar_narrow): Ditto.\n\t(@pred_eqne<mode>_scalar): Ditto.\n\t(*pred_eqne<mode>_scalar): Ditto.\n\t(*pred_eqne<mode>_scalar_narrow): Ditto.\n\t(*pred_cmp<mode>_extended_scalar): Ditto.\n\t(*pred_cmp<mode>_extended_scalar_narrow): Ditto.\n\t(*pred_eqne<mode>_extended_scalar): Ditto.\n\t(*pred_eqne<mode>_extended_scalar_narrow): Ditto.\n\t(@pred_ge<mode>_scalar): Ditto.\n\t(@pred_<optab><mode>): Ditto.\n\t(@pred_n<optab><mode>): Ditto.\n\t(@pred_<optab>n<mode>): Ditto.\n\t(@pred_not<mode>): Ditto.", "tree": {"sha": "f88589fe6e1d04a95f423b0fce8a38d43c126b80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f88589fe6e1d04a95f423b0fce8a38d43c126b80"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/acb51b5c801540c7c15236f9f5a6be893216584f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acb51b5c801540c7c15236f9f5a6be893216584f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/acb51b5c801540c7c15236f9f5a6be893216584f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acb51b5c801540c7c15236f9f5a6be893216584f/comments", "author": {"login": "zhongjuzhe", "id": 66454988, "node_id": "MDQ6VXNlcjY2NDU0OTg4", "avatar_url": "https://avatars.githubusercontent.com/u/66454988?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zhongjuzhe", "html_url": "https://github.com/zhongjuzhe", "followers_url": "https://api.github.com/users/zhongjuzhe/followers", "following_url": "https://api.github.com/users/zhongjuzhe/following{/other_user}", "gists_url": "https://api.github.com/users/zhongjuzhe/gists{/gist_id}", "starred_url": "https://api.github.com/users/zhongjuzhe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zhongjuzhe/subscriptions", "organizations_url": "https://api.github.com/users/zhongjuzhe/orgs", "repos_url": "https://api.github.com/users/zhongjuzhe/repos", "events_url": "https://api.github.com/users/zhongjuzhe/events{/privacy}", "received_events_url": "https://api.github.com/users/zhongjuzhe/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kito-cheng", "id": 2723185, "node_id": "MDQ6VXNlcjI3MjMxODU=", "avatar_url": "https://avatars.githubusercontent.com/u/2723185?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kito-cheng", "html_url": "https://github.com/kito-cheng", "followers_url": "https://api.github.com/users/kito-cheng/followers", "following_url": "https://api.github.com/users/kito-cheng/following{/other_user}", "gists_url": "https://api.github.com/users/kito-cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/kito-cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kito-cheng/subscriptions", "organizations_url": "https://api.github.com/users/kito-cheng/orgs", "repos_url": "https://api.github.com/users/kito-cheng/repos", "events_url": "https://api.github.com/users/kito-cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/kito-cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "142bd88c5f609546a466743ab1066d5620a830bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/142bd88c5f609546a466743ab1066d5620a830bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/142bd88c5f609546a466743ab1066d5620a830bc"}], "stats": {"total": 1040, "additions": 999, "deletions": 41}, "files": [{"sha": "bbbf523d5888b25060ebf7d7b34df8a82e1c00ea", "filename": "gcc/config/riscv/predicates.md", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acb51b5c801540c7c15236f9f5a6be893216584f/gcc%2Fconfig%2Friscv%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acb51b5c801540c7c15236f9f5a6be893216584f/gcc%2Fconfig%2Friscv%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fpredicates.md?ref=acb51b5c801540c7c15236f9f5a6be893216584f", "patch": "@@ -283,14 +283,21 @@\n \t\t|| satisfies_constraint_vi (op)\n \t\t|| satisfies_constraint_Wc0 (op)\"))))\n \n-(define_predicate \"vector_mask_operand\"\n+(define_predicate \"vector_all_trues_mask_operand\"\n   (ior (match_operand 0 \"register_operand\")\n        (match_test \"op == CONSTM1_RTX (GET_MODE (op))\")))\n \n+(define_predicate \"vector_mask_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_operand 0 \"vector_all_trues_mask_operand\")))\n+\n+(define_predicate \"vector_undef_operand\"\n+  (match_test \"GET_CODE (op) == UNSPEC\n+\t\t    && (XINT (op, 1) == UNSPEC_VUNDEF)\"))\n+\n (define_predicate \"vector_merge_operand\"\n   (ior (match_operand 0 \"register_operand\")\n-       (match_test \"GET_CODE (op) == UNSPEC\n-\t\t    && (XINT (op, 1) == UNSPEC_VUNDEF)\")))\n+       (match_operand 0 \"vector_undef_operand\")))\n \n (define_predicate \"vector_arith_operand\"\n   (ior (match_operand 0 \"register_operand\")\n@@ -307,6 +314,18 @@\n        (and (match_code \"const_vector\")\n             (match_test \"riscv_vector::const_vec_all_same_in_range_p (op, 0, 31)\"))))\n \n+(define_predicate \"ltge_operator\"\n+  (match_code \"lt,ltu,ge,geu\"))\n+\n+(define_predicate \"comparison_except_ltge_operator\"\n+  (match_code \"eq,ne,le,leu,gt,gtu\"))\n+\n+(define_predicate \"comparison_except_eqge_operator\"\n+  (match_code \"le,leu,gt,gtu,lt,ltu\"))\n+\n+(define_predicate \"ge_operator\"\n+  (match_code \"ge,geu\"))\n+\n ;; pmode_reg_or_uimm5_operand can be used by vsll.vx/vsrl.vx/vsra.vx instructions.\n ;; Since it has the same predicate with vector_length_operand which allows register\n ;; or immediate (0 ~ 31), we define this predicate same as vector_length_operand here."}, {"sha": "cc26888d58b952ad3899354c31ef73c585002261", "filename": "gcc/config/riscv/riscv-v.cc", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acb51b5c801540c7c15236f9f5a6be893216584f/gcc%2Fconfig%2Friscv%2Friscv-v.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acb51b5c801540c7c15236f9f5a6be893216584f/gcc%2Fconfig%2Friscv%2Friscv-v.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-v.cc?ref=acb51b5c801540c7c15236f9f5a6be893216584f", "patch": "@@ -427,11 +427,33 @@ neg_simm5_p (rtx x)\n bool\n has_vi_variant_p (rtx_code code, rtx x)\n {\n-  if (code != PLUS && code != MINUS && code != AND && code != IOR && code != XOR\n-      && code != SS_PLUS && code != SS_MINUS && code != US_PLUS\n-      && code != US_MINUS)\n-    return false;\n-  return simm5_p (x);\n+  switch (code)\n+    {\n+    case PLUS:\n+    case MINUS:\n+    case AND:\n+    case IOR:\n+    case XOR:\n+    case SS_PLUS:\n+    case SS_MINUS:\n+    case US_PLUS:\n+    case US_MINUS:\n+    case EQ:\n+    case NE:\n+    case LE:\n+    case LEU:\n+    case GT:\n+    case GTU:\n+      return simm5_p (x);\n+\n+    case LT:\n+    case LTU:\n+    case GE:\n+    case GEU:\n+      return neg_simm5_p (x);\n+    default:\n+      return false;\n+    }\n }\n \n } // namespace riscv_vector"}, {"sha": "4f3531d4486d53ca29b0ca7116d7cf6f40fe3ea9", "filename": "gcc/config/riscv/riscv-vector-builtins-bases.cc", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acb51b5c801540c7c15236f9f5a6be893216584f/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acb51b5c801540c7c15236f9f5a6be893216584f/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.cc?ref=acb51b5c801540c7c15236f9f5a6be893216584f", "patch": "@@ -505,6 +505,40 @@ class vnclip : public function_base\n   }\n };\n \n+/* Implements vmseq/vmsne/vmslt/vmsgt/vmsle/vmsge.  */\n+template<rtx_code CODE>\n+class icmp : public function_base\n+{\n+public:\n+  rtx expand (function_expander &e) const override\n+  {\n+    switch (e.op_info->op)\n+      {\n+\tcase OP_TYPE_vx: {\n+\t  if (CODE == GE || CODE == GEU)\n+\t    return e.use_compare_insn (CODE, code_for_pred_ge_scalar (\n+\t\t\t\t\t       e.vector_mode ()));\n+\t  else if (CODE == EQ || CODE == NE)\n+\t    return e.use_compare_insn (CODE, code_for_pred_eqne_scalar (\n+\t\t\t\t\t       e.vector_mode ()));\n+\t  else\n+\t    return e.use_compare_insn (CODE, code_for_pred_cmp_scalar (\n+\t\t\t\t\t       e.vector_mode ()));\n+\t}\n+\tcase OP_TYPE_vv: {\n+\t  if (CODE == LT || CODE == LTU || CODE == GE || CODE == GEU)\n+\t    return e.use_compare_insn (CODE,\n+\t\t\t\t       code_for_pred_ltge (e.vector_mode ()));\n+\t  else\n+\t    return e.use_compare_insn (CODE,\n+\t\t\t\t       code_for_pred_cmp (e.vector_mode ()));\n+\t}\n+      default:\n+\tgcc_unreachable ();\n+      }\n+  }\n+};\n+\n static CONSTEXPR const vsetvl<false> vsetvl_obj;\n static CONSTEXPR const vsetvl<true> vsetvlmax_obj;\n static CONSTEXPR const loadstore<false, LST_UNIT_STRIDE, false> vle_obj;\n@@ -572,6 +606,16 @@ static CONSTEXPR const vnshift<ASHIFTRT> vnsra_obj;\n static CONSTEXPR const vncvt_x vncvt_x_obj;\n static CONSTEXPR const vmerge vmerge_obj;\n static CONSTEXPR const vmv_v vmv_v_obj;\n+static CONSTEXPR const icmp<EQ> vmseq_obj;\n+static CONSTEXPR const icmp<NE> vmsne_obj;\n+static CONSTEXPR const icmp<LT> vmslt_obj;\n+static CONSTEXPR const icmp<GT> vmsgt_obj;\n+static CONSTEXPR const icmp<LE> vmsle_obj;\n+static CONSTEXPR const icmp<GE> vmsge_obj;\n+static CONSTEXPR const icmp<LTU> vmsltu_obj;\n+static CONSTEXPR const icmp<GTU> vmsgtu_obj;\n+static CONSTEXPR const icmp<LEU> vmsleu_obj;\n+static CONSTEXPR const icmp<GEU> vmsgeu_obj;\n static CONSTEXPR const binop<SS_PLUS> vsadd_obj;\n static CONSTEXPR const binop<SS_MINUS> vssub_obj;\n static CONSTEXPR const binop<US_PLUS> vsaddu_obj;\n@@ -658,6 +702,16 @@ BASE (vnsra)\n BASE (vncvt_x)\n BASE (vmerge)\n BASE (vmv_v)\n+BASE (vmseq)\n+BASE (vmsne)\n+BASE (vmslt)\n+BASE (vmsgt)\n+BASE (vmsle)\n+BASE (vmsge)\n+BASE (vmsltu)\n+BASE (vmsgtu)\n+BASE (vmsleu)\n+BASE (vmsgeu)\n BASE (vsadd)\n BASE (vssub)\n BASE (vsaddu)"}, {"sha": "6233b4122f8ec422de1164aa50b8c318323fbad1", "filename": "gcc/config/riscv/riscv-vector-builtins-bases.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acb51b5c801540c7c15236f9f5a6be893216584f/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acb51b5c801540c7c15236f9f5a6be893216584f/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.h?ref=acb51b5c801540c7c15236f9f5a6be893216584f", "patch": "@@ -91,6 +91,16 @@ extern const function_base *const vnsra;\n extern const function_base *const vncvt_x;\n extern const function_base *const vmerge;\n extern const function_base *const vmv_v;\n+extern const function_base *const vmseq;\n+extern const function_base *const vmsne;\n+extern const function_base *const vmslt;\n+extern const function_base *const vmsgt;\n+extern const function_base *const vmsle;\n+extern const function_base *const vmsge;\n+extern const function_base *const vmsltu;\n+extern const function_base *const vmsgtu;\n+extern const function_base *const vmsleu;\n+extern const function_base *const vmsgeu;\n extern const function_base *const vsadd;\n extern const function_base *const vssub;\n extern const function_base *const vsaddu;"}, {"sha": "f61f48d36a0895b8ca88ea65b8ad5cc00e691ce3", "filename": "gcc/config/riscv/riscv-vector-builtins-functions.def", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acb51b5c801540c7c15236f9f5a6be893216584f/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-functions.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acb51b5c801540c7c15236f9f5a6be893216584f/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-functions.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-functions.def?ref=acb51b5c801540c7c15236f9f5a6be893216584f", "patch": "@@ -157,6 +157,26 @@ DEF_RVV_FUNCTION (vmerge, no_mask_policy, tu_preds, all_vvvm_ops)\n DEF_RVV_FUNCTION (vmerge, no_mask_policy, tu_preds, iu_vvxm_ops)\n DEF_RVV_FUNCTION (vmv_v, move, tu_preds, all_v_ops)\n DEF_RVV_FUNCTION (vmv_v, move, tu_preds, iu_x_ops)\n+DEF_RVV_FUNCTION (vmseq, return_mask, none_m_mu_preds, iu_mvv_ops)\n+DEF_RVV_FUNCTION (vmsne, return_mask, none_m_mu_preds, iu_mvv_ops)\n+DEF_RVV_FUNCTION (vmslt, return_mask, none_m_mu_preds, i_mvv_ops)\n+DEF_RVV_FUNCTION (vmsgt, return_mask, none_m_mu_preds, i_mvv_ops)\n+DEF_RVV_FUNCTION (vmsle, return_mask, none_m_mu_preds, i_mvv_ops)\n+DEF_RVV_FUNCTION (vmsge, return_mask, none_m_mu_preds, i_mvv_ops)\n+DEF_RVV_FUNCTION (vmsltu, return_mask, none_m_mu_preds, u_mvv_ops)\n+DEF_RVV_FUNCTION (vmsgtu, return_mask, none_m_mu_preds, u_mvv_ops)\n+DEF_RVV_FUNCTION (vmsleu, return_mask, none_m_mu_preds, u_mvv_ops)\n+DEF_RVV_FUNCTION (vmsgeu, return_mask, none_m_mu_preds, u_mvv_ops)\n+DEF_RVV_FUNCTION (vmseq, return_mask, none_m_mu_preds, iu_mvx_ops)\n+DEF_RVV_FUNCTION (vmsne, return_mask, none_m_mu_preds, iu_mvx_ops)\n+DEF_RVV_FUNCTION (vmslt, return_mask, none_m_mu_preds, i_mvx_ops)\n+DEF_RVV_FUNCTION (vmsgt, return_mask, none_m_mu_preds, i_mvx_ops)\n+DEF_RVV_FUNCTION (vmsle, return_mask, none_m_mu_preds, i_mvx_ops)\n+DEF_RVV_FUNCTION (vmsge, return_mask, none_m_mu_preds, i_mvx_ops)\n+DEF_RVV_FUNCTION (vmsltu, return_mask, none_m_mu_preds, u_mvx_ops)\n+DEF_RVV_FUNCTION (vmsgtu, return_mask, none_m_mu_preds, u_mvx_ops)\n+DEF_RVV_FUNCTION (vmsleu, return_mask, none_m_mu_preds, u_mvx_ops)\n+DEF_RVV_FUNCTION (vmsgeu, return_mask, none_m_mu_preds, u_mvx_ops)\n /* 12. Vector Fixed-Point Arithmetic Instructions. */\n DEF_RVV_FUNCTION (vsadd, alu, full_preds, i_vvv_ops)\n DEF_RVV_FUNCTION (vssub, alu, full_preds, i_vvv_ops)"}, {"sha": "2836170323aaa1ee73c625dc9572b2c2e2398eda", "filename": "gcc/config/riscv/riscv-vector-builtins-shapes.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acb51b5c801540c7c15236f9f5a6be893216584f/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-shapes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acb51b5c801540c7c15236f9f5a6be893216584f/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-shapes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-shapes.cc?ref=acb51b5c801540c7c15236f9f5a6be893216584f", "patch": "@@ -288,6 +288,8 @@ struct return_mask_def : public build_base\n \tb.append_name (type_suffixes[ret_type_idx].vector);\n       }\n \n+    if (overloaded_p && instance.pred == PRED_TYPE_m)\n+      return b.finish_name ();\n     b.append_name (predication_suffixes[instance.pred]);\n     return b.finish_name ();\n   }"}, {"sha": "c1f595cdff119d06dea81919465a05dffc096866", "filename": "gcc/config/riscv/riscv-vector-builtins.cc", "status": "modified", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acb51b5c801540c7c15236f9f5a6be893216584f/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acb51b5c801540c7c15236f9f5a6be893216584f/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.cc?ref=acb51b5c801540c7c15236f9f5a6be893216584f", "patch": "@@ -438,6 +438,10 @@ static CONSTEXPR const predication_type_index tu_preds[]\n static CONSTEXPR const predication_type_index none_m_preds[]\n   = {PRED_TYPE_none, PRED_TYPE_m, NUM_PRED_TYPES};\n \n+/* vop/vop_m/vop_mu will be registered.  */\n+static CONSTEXPR const predication_type_index none_m_mu_preds[]\n+  = {PRED_TYPE_none, PRED_TYPE_m, PRED_TYPE_mu, NUM_PRED_TYPES};\n+\n /* A static operand information for size_t func (void) function registration. */\n static CONSTEXPR const rvv_op_info i_none_size_void_ops\n   = {i_ops,\t\t\t\t/* Types */\n@@ -621,6 +625,22 @@ static CONSTEXPR const rvv_op_info iu_mvv_ops\n      rvv_arg_type_info (RVV_BASE_mask), /* Return type */\n      vv_args /* Args */};\n \n+/* A static operand information for mask_type func (vector_type, vector_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info i_mvv_ops\n+  = {i_ops,\t\t\t\t/* Types */\n+     OP_TYPE_vv,\t\t\t/* Suffix */\n+     rvv_arg_type_info (RVV_BASE_mask), /* Return type */\n+     vv_args /* Args */};\n+\n+/* A static operand information for mask_type func (vector_type, vector_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info u_mvv_ops\n+  = {u_ops,\t\t\t\t/* Types */\n+     OP_TYPE_vv,\t\t\t/* Suffix */\n+     rvv_arg_type_info (RVV_BASE_mask), /* Return type */\n+     vv_args /* Args */};\n+\n /* A static operand information for mask_type func (vector_type, scalar_type)\n  * function registration. */\n static CONSTEXPR const rvv_op_info iu_mvx_ops\n@@ -629,6 +649,22 @@ static CONSTEXPR const rvv_op_info iu_mvx_ops\n      rvv_arg_type_info (RVV_BASE_mask), /* Return type */\n      vx_args /* Args */};\n \n+/* A static operand information for mask_type func (vector_type, scalar_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info i_mvx_ops\n+  = {i_ops,\t\t\t\t/* Types */\n+     OP_TYPE_vx,\t\t\t/* Suffix */\n+     rvv_arg_type_info (RVV_BASE_mask), /* Return type */\n+     vx_args /* Args */};\n+\n+/* A static operand information for mask_type func (vector_type, scalar_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info u_mvx_ops\n+  = {u_ops,\t\t\t\t/* Types */\n+     OP_TYPE_vx,\t\t\t/* Suffix */\n+     rvv_arg_type_info (RVV_BASE_mask), /* Return type */\n+     vx_args /* Args */};\n+\n /* A static operand information for vector_type func (vector_type, vector_type)\n  * function registration. */\n static CONSTEXPR const rvv_op_info i_vvv_ops\n@@ -1902,6 +1938,47 @@ function_expander::use_contiguous_store_insn (insn_code icode)\n   return generate_insn (icode);\n }\n \n+/* Implement the call using instruction ICODE, with a 1:1 mapping between\n+   arguments and input operands.  */\n+rtx\n+function_expander::use_compare_insn (rtx_code rcode, insn_code icode)\n+{\n+  machine_mode mode = TYPE_MODE (builtin_types[type.index].vector);\n+  machine_mode mask_mode = TYPE_MODE (TREE_TYPE (exp));\n+\n+  /* Record the offset to get the argument.  */\n+  int arg_offset = 0;\n+\n+  if (use_real_mask_p (pred))\n+    add_input_operand (arg_offset++);\n+  else\n+    add_all_one_mask_operand (mask_mode);\n+\n+  if (use_real_merge_p (pred))\n+    add_input_operand (arg_offset++);\n+  else\n+    add_vundef_operand (mask_mode);\n+\n+  rtx op1 = expand_normal (CALL_EXPR_ARG (exp, arg_offset++));\n+  rtx op2 = expand_normal (CALL_EXPR_ARG (exp, arg_offset++));\n+  rtx comparison = gen_rtx_fmt_ee (rcode, mask_mode, op1, op2);\n+  if (!VECTOR_MODE_P (GET_MODE (op2)))\n+    comparison = gen_rtx_fmt_ee (rcode, mask_mode, op1,\n+\t\t\t\t gen_rtx_VEC_DUPLICATE (mode, op2));\n+  add_fixed_operand (comparison);\n+  add_fixed_operand (op1);\n+  if (CONST_INT_P (op2))\n+    add_integer_operand (op2);\n+  else\n+    add_fixed_operand (op2);\n+  for (int argno = arg_offset; argno < call_expr_nargs (exp); argno++)\n+    add_input_operand (argno);\n+\n+  add_input_operand (Pmode, get_mask_policy_for_pred (pred));\n+  add_input_operand (Pmode, get_avl_type_rtx (avl_type::NONVLMAX));\n+  return generate_insn (icode);\n+}\n+\n /* Generate instruction ICODE, given that its operands have already\n    been added to M_OPS.  Return the value of the first operand.  */\n rtx"}, {"sha": "9807fdf293810e1e201416e1ed2daa002eed5072", "filename": "gcc/config/riscv/riscv-vector-builtins.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acb51b5c801540c7c15236f9f5a6be893216584f/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acb51b5c801540c7c15236f9f5a6be893216584f/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.h?ref=acb51b5c801540c7c15236f9f5a6be893216584f", "patch": "@@ -338,6 +338,7 @@ class function_expander : public function_call_info\n   void add_all_one_mask_operand (machine_mode);\n   void add_vundef_operand (machine_mode);\n   void add_fixed_operand (rtx);\n+  void add_integer_operand (rtx);\n   void add_mem_operand (machine_mode, unsigned);\n \n   machine_mode vector_mode (void) const;\n@@ -346,6 +347,7 @@ class function_expander : public function_call_info\n   rtx use_exact_insn (insn_code);\n   rtx use_contiguous_load_insn (insn_code);\n   rtx use_contiguous_store_insn (insn_code);\n+  rtx use_compare_insn (rtx_code, insn_code);\n   rtx generate_insn (insn_code);\n \n   /* The function call expression.  */\n@@ -467,6 +469,13 @@ function_expander::add_fixed_operand (rtx x)\n   create_fixed_operand (&m_ops[opno++], x);\n }\n \n+/* Add an integer operand X.  */\n+inline void\n+function_expander::add_integer_operand (rtx x)\n+{\n+  create_integer_operand (&m_ops[opno++], INTVAL (x));\n+}\n+\n /* Return the machine_mode of the corresponding vector type.  */\n inline machine_mode\n function_expander::vector_mode (void) const"}, {"sha": "f11b7949a49ea3472d357f2ac86eb55eb60fe307", "filename": "gcc/config/riscv/riscv.cc", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acb51b5c801540c7c15236f9f5a6be893216584f/gcc%2Fconfig%2Friscv%2Friscv.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acb51b5c801540c7c15236f9f5a6be893216584f/gcc%2Fconfig%2Friscv%2Friscv.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.cc?ref=acb51b5c801540c7c15236f9f5a6be893216584f", "patch": "@@ -4263,7 +4263,8 @@ riscv_print_operand (FILE *file, rtx op, int letter)\n \t      output_operand_lossage (\"invalid vector constant\");\n \t    else if (satisfies_constraint_Wc0 (op))\n \t      asm_fprintf (file, \"0\");\n-\t    else if (satisfies_constraint_vi (op))\n+\t    else if (satisfies_constraint_vi (op)\n+\t\t     || satisfies_constraint_vj (op))\n \t      asm_fprintf (file, \"%wd\", INTVAL (elt));\n \t    else\n \t      output_operand_lossage (\"invalid vector constant\");\n@@ -4376,6 +4377,10 @@ riscv_print_operand (FILE *file, rtx op, int letter)\n         fputs (\"i\", file);\n       break;\n \n+    case 'B':\n+      fputs (GET_RTX_NAME (code), file);\n+      break;\n+\n     case 'S':\n       {\n \trtx newop = GEN_INT (ctz_hwi (INTVAL (op)));"}, {"sha": "487059ebe973f129e0f06125ec6c03d1b73c1627", "filename": "gcc/config/riscv/riscv.md", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acb51b5c801540c7c15236f9f5a6be893216584f/gcc%2Fconfig%2Friscv%2Friscv.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acb51b5c801540c7c15236f9f5a6be893216584f/gcc%2Fconfig%2Friscv%2Friscv.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.md?ref=acb51b5c801540c7c15236f9f5a6be893216584f", "patch": "@@ -267,7 +267,8 @@\n ;; vicalu      vector arithmetic with carry or borrow instructions\n ;; vshift      vector single-width bit shift instructions\n ;; vnshift     vector narrowing integer shift instructions\n-;; vicmp       vector integer comparison/min/max instructions\n+;; viminmax    vector integer min/max instructions\n+;; vicmp       vector integer comparison instructions\n ;; vimul       vector single-width integer multiply instructions\n ;; vidiv       vector single-width integer divide instructions\n ;; viwmul      vector widening integer multiply instructions\n@@ -291,7 +292,8 @@\n ;; vfwmuladd   vector widening floating-point multiply-add instructions\n ;; vfsqrt      vector floating-point square-root instructions\n ;; vfrecp      vector floating-point reciprocal square-root instructions\n-;; vfcmp       vector floating-point comparison/min/max instructions\n+;; vfminmax    vector floating-point min/max instructions\n+;; vfcmp       vector floating-point comparison instructions\n ;; vfsgnj      vector floating-point sign-injection instructions\n ;; vfclass     vector floating-point classify instruction\n ;; vfmerge     vector floating-point merge instruction\n@@ -335,11 +337,11 @@\n    fmadd,fdiv,fcmp,fcvt,fsqrt,multi,auipc,sfb_alu,nop,ghost,bitmanip,rotate,\n    atomic,rdvlenb,rdvl,vsetvl,vlde,vste,vldm,vstm,vlds,vsts,\n    vldux,vldox,vstux,vstox,vldff,vldr,vstr,\n-   vialu,viwalu,vext,vicalu,vshift,vnshift,vicmp,\n+   vialu,viwalu,vext,vicalu,vshift,vnshift,vicmp,viminmax,\n    vimul,vidiv,viwmul,vimuladd,viwmuladd,vimerge,vimov,\n    vsalu,vaalu,vsmul,vsshift,vnclip,\n    vfalu,vfwalu,vfmul,vfdiv,vfwmul,vfmuladd,vfwmuladd,vfsqrt,vfrecp,\n-   vfcmp,vfsgnj,vfclass,vfmerge,vfmov,\n+   vfcmp,vfminmax,vfsgnj,vfclass,vfmerge,vfmov,\n    vfcvtitof,vfcvtftoi,vfwcvtitof,vfwcvtftoi,\n    vfwcvtftof,vfncvtitof,vfncvtftoi,vfncvtftof,\n    vired,viwred,vfred,vfredo,vfwred,vfwredo,"}, {"sha": "c8b24150f4e525ebe270f6351d0ed87d6269154a", "filename": "gcc/config/riscv/vector-iterators.md", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acb51b5c801540c7c15236f9f5a6be893216584f/gcc%2Fconfig%2Friscv%2Fvector-iterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acb51b5c801540c7c15236f9f5a6be893216584f/gcc%2Fconfig%2Friscv%2Fvector-iterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fvector-iterators.md?ref=acb51b5c801540c7c15236f9f5a6be893216584f", "patch": "@@ -225,6 +225,15 @@\n   (VNx1DF \"VNx1BI\") (VNx2DF \"VNx2BI\") (VNx4DF \"VNx4BI\") (VNx8DF \"VNx8BI\")\n ])\n \n+(define_mode_attr vm [\n+  (VNx1QI \"vnx1bi\") (VNx2QI \"vnx2bi\") (VNx4QI \"vnx4bi\") (VNx8QI \"vnx8bi\") (VNx16QI \"vnx16bi\") (VNx32QI \"vnx32bi\") (VNx64QI \"vnx64bi\")\n+  (VNx1HI \"vnx1bi\") (VNx2HI \"vnx2bi\") (VNx4HI \"vnx4bi\") (VNx8HI \"vnx8bi\") (VNx16HI \"vnx16bi\") (VNx32HI \"vnx32bi\")\n+  (VNx1SI \"vnx1bi\") (VNx2SI \"vnx2bi\") (VNx4SI \"vnx4bi\") (VNx8SI \"vnx8bi\") (VNx16SI \"vnx16bi\")\n+  (VNx1DI \"vnx1bi\") (VNx2DI \"vnx2bi\") (VNx4DI \"vnx4bi\") (VNx8DI \"vnx8bi\")\n+  (VNx1SF \"vnx1bi\") (VNx2SF \"vnx2bi\") (VNx4SF \"vnx4bi\") (VNx8SF \"vnx8bi\") (VNx16SF \"vnx16bi\")\n+  (VNx1DF \"vnx1bi\") (VNx2DF \"vnx2bi\") (VNx4DF \"vnx4bi\") (VNx8DF \"vnx8bi\")\n+])\n+\n (define_mode_attr VEL [\n   (VNx1QI \"QI\") (VNx2QI \"QI\") (VNx4QI \"QI\") (VNx8QI \"QI\") (VNx16QI \"QI\") (VNx32QI \"QI\") (VNx64QI \"QI\")\n   (VNx1HI \"HI\") (VNx2HI \"HI\") (VNx4HI \"HI\") (VNx8HI \"HI\") (VNx16HI \"HI\") (VNx32HI \"HI\")\n@@ -322,6 +331,9 @@\n (define_code_attr macc_nmsac [(plus \"macc\") (minus \"nmsac\")])\n (define_code_attr madd_nmsub [(plus \"madd\") (minus \"nmsub\")])\n \n+(define_code_iterator and_ior [and ior])\n+(define_code_attr ninsn [(and \"nand\") (ior \"nor\") (xor \"xnor\")])\n+\n (define_code_attr binop_rhs1_predicate [\n \t\t\t(plus \"register_operand\")\n \t\t\t(minus \"vector_arith_operand\")\n@@ -419,10 +431,10 @@\n \t\t\t(ashift \"vshift\")\n \t\t\t(ashiftrt \"vshift\")\n \t\t\t(lshiftrt \"vshift\")\n-\t\t\t(smin \"vicmp\")\n-\t\t\t(smax \"vicmp\")\n-\t\t\t(umin \"vicmp\")\n-\t\t\t(umax \"vicmp\")\n+\t\t\t(smin \"viminmax\")\n+\t\t\t(smax \"viminmax\")\n+\t\t\t(umin \"viminmax\")\n+\t\t\t(umax \"viminmax\")\n \t\t\t(mult \"vimul\")\n \t\t\t(div \"vidiv\")\n \t\t\t(mod \"vidiv\")"}, {"sha": "34436573b4cc8e79bda88978730ce7aa24697335", "filename": "gcc/config/riscv/vector.md", "status": "modified", "additions": 750, "deletions": 24, "changes": 774, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acb51b5c801540c7c15236f9f5a6be893216584f/gcc%2Fconfig%2Friscv%2Fvector.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acb51b5c801540c7c15236f9f5a6be893216584f/gcc%2Fconfig%2Friscv%2Fvector.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fvector.md?ref=acb51b5c801540c7c15236f9f5a6be893216584f", "patch": "@@ -41,11 +41,11 @@\n (define_attr \"has_vtype_op\" \"false,true\"\n   (cond [(eq_attr \"type\" \"vlde,vste,vldm,vstm,vlds,vsts,\\\n \t\t\t  vldux,vldox,vstux,vstox,vldff,\\\n-\t\t\t  vialu,viwalu,vext,vicalu,vshift,vnshift,vicmp,\\\n+\t\t\t  vialu,viwalu,vext,vicalu,vshift,vnshift,vicmp,viminmax,\\\n \t\t\t  vimul,vidiv,viwmul,vimuladd,viwmuladd,vimerge,vimov,\\\n \t\t\t  vsalu,vaalu,vsmul,vsshift,vnclip,\\\n \t\t\t  vfalu,vfwalu,vfmul,vfdiv,vfwmul,vfmuladd,vfwmuladd,vfsqrt,vfrecp,\\\n-\t\t\t  vfcmp,vfsgnj,vfclass,vfmerge,vfmov,\\\n+\t\t\t  vfcmp,vfminmax,vfsgnj,vfclass,vfmerge,vfmov,\\\n \t\t\t  vfcvtitof,vfcvtftoi,vfwcvtitof,vfwcvtftoi,\\\n \t\t\t  vfwcvtftof,vfncvtitof,vfncvtftoi,vfncvtftof,\\\n \t\t\t  vired,viwred,vfred,vfredo,vfwred,vfwredo,\\\n@@ -61,11 +61,11 @@\n (define_attr \"has_vl_op\" \"false,true\"\n   (cond [(eq_attr \"type\" \"vlde,vste,vldm,vstm,vlds,vsts,\\\n \t\t\t  vldux,vldox,vstux,vstox,vldff,\\\n-\t\t\t  vialu,viwalu,vext,vicalu,vshift,vnshift,vicmp,\\\n+\t\t\t  vialu,viwalu,vext,vicalu,vshift,vnshift,vicmp,viminmax,\\\n \t\t\t  vimul,vidiv,viwmul,vimuladd,viwmuladd,vimerge,vimov,\\\n \t\t\t  vsalu,vaalu,vsmul,vsshift,vnclip,\\\n \t\t\t  vfalu,vfwalu,vfmul,vfdiv,vfwmul,vfmuladd,vfwmuladd,vfsqrt,vfrecp,\\\n-\t\t\t  vfcmp,vfsgnj,vfclass,vfmerge,vfmov,\\\n+\t\t\t  vfcmp,vfminmax,vfsgnj,vfclass,vfmerge,vfmov,\\\n \t\t\t  vfcvtitof,vfcvtftoi,vfwcvtitof,vfwcvtftoi,\\\n \t\t\t  vfwcvtftof,vfncvtitof,vfncvtftoi,vfncvtftof,\\\n \t\t\t  vired,viwred,vfred,vfredo,vfwred,vfwredo,\\\n@@ -146,7 +146,7 @@\n \t\t\t  vialu,vshift,vicmp,vimul,vidiv,vsalu,\\\n \t\t\t  vext,viwalu,viwmul,vicalu,vnshift,\\\n \t\t\t  vimuladd,vimerge,vaalu,vsmul,vsshift,\\\n-\t\t\t  vnclip\")\n+\t\t\t  vnclip,viminmax\")\n \t   (const_int INVALID_ATTRIBUTE)\n \t (eq_attr \"mode\" \"VNx1QI,VNx1BI\")\n \t   (symbol_ref \"riscv_vector::get_ratio(E_VNx1QImode)\")\n@@ -196,8 +196,8 @@\n \n ;; The index of operand[] to get the merge op.\n (define_attr \"merge_op_idx\" \"\"\n-\t(cond [(eq_attr \"type\" \"vlde,vimov,vfmov,vldm,vlds,vmalu,vldux,vldox,\\\n-\t\t\t\tvialu,vshift,vicmp,vimul,vidiv,vsalu,vext,viwalu,\\\n+\t(cond [(eq_attr \"type\" \"vlde,vimov,vfmov,vldm,vlds,vmalu,vldux,vldox,vicmp,\\\n+\t\t\t\tvialu,vshift,viminmax,vimul,vidiv,vsalu,vext,viwalu,\\\n \t\t\t\tviwmul,vnshift,vimuladd,vaalu,vsmul,vsshift,vnclip\")\n \t       (const_int 2)\n \n@@ -218,10 +218,13 @@\n              (const_int 5)\n              (const_int 4))\n \n-\t (eq_attr \"type\" \"vldux,vldox,vialu,vshift,vicmp,vimul,vidiv,vsalu,\\\n+\t (eq_attr \"type\" \"vldux,vldox,vialu,vshift,viminmax,vimul,vidiv,vsalu,\\\n \t\t\t  viwalu,viwmul,vnshift,vimuladd,vimerge,vaalu,vsmul,\\\n \t\t\t  vsshift,vnclip\")\n-\t   (const_int 5)]\n+\t   (const_int 5)\n+\n+\t (eq_attr \"type\" \"vicmp\")\n+\t   (const_int 6)]\n   (const_int INVALID_ATTRIBUTE)))\n \n ;; The tail policy op value.\n@@ -236,7 +239,7 @@\n \t     (symbol_ref \"riscv_vector::get_ta(operands[6])\")\n \t     (symbol_ref \"riscv_vector::get_ta(operands[5])\"))\n \n-\t (eq_attr \"type\" \"vldux,vldox,vialu,vshift,vicmp,vimul,vidiv,vsalu,\\\n+\t (eq_attr \"type\" \"vldux,vldox,vialu,vshift,viminmax,vimul,vidiv,vsalu,\\\n \t\t\t  viwalu,viwmul,vnshift,vimuladd,vimerge,vaalu,vsmul,\\\n \t\t\t  vsshift,vnclip\")\n \t   (symbol_ref \"riscv_vector::get_ta(operands[6])\")]\n@@ -254,9 +257,9 @@\n \t     (symbol_ref \"riscv_vector::get_ma(operands[7])\")\n \t     (symbol_ref \"riscv_vector::get_ma(operands[6])\"))\n \n-\t (eq_attr \"type\" \"vldux,vldox,vialu,vshift,vicmp,vimul,vidiv,vsalu,\\\n+\t (eq_attr \"type\" \"vldux,vldox,vialu,vshift,viminmax,vimul,vidiv,vsalu,\\\n \t\t\t  viwalu,viwmul,vnshift,vimuladd,vaalu,vsmul,vsshift,\\\n-\t\t\t  vnclip\")\n+\t\t\t  vnclip,vicmp\")\n \t   (symbol_ref \"riscv_vector::get_ma(operands[7])\")]\n \t(const_int INVALID_ATTRIBUTE)))\n \n@@ -274,9 +277,9 @@\n \t     (const_int INVALID_ATTRIBUTE)\n \t     (symbol_ref \"INTVAL (operands[7])\"))\n \n-\t (eq_attr \"type\" \"vldux,vldox,vialu,vshift,vicmp,vimul,vidiv,vsalu,\\\n+\t (eq_attr \"type\" \"vldux,vldox,vialu,vshift,viminmax,vimul,vidiv,vsalu,\\\n \t\t\t  viwalu,viwmul,vnshift,vimuladd,vaalu,vsmul,vsshift,\\\n-\t\t\t  vnclip\")\n+\t\t\t  vnclip,vicmp\")\n \t   (symbol_ref \"INTVAL (operands[8])\")\n \t (eq_attr \"type\" \"vstux,vstox\")\n \t   (symbol_ref \"INTVAL (operands[5])\")]\n@@ -763,16 +766,16 @@\n ;; constraint alternative 3 match vmclr.m.\n ;; constraint alternative 4 match vmset.m.\n (define_insn_and_split \"@pred_mov<mode>\"\n-  [(set (match_operand:VB 0 \"nonimmediate_operand\"       \"=vr,   m,  vr,  vr,  vr\")\n+  [(set (match_operand:VB 0 \"nonimmediate_operand\"               \"=vr,   m,  vr,  vr,  vr\")\n \t(if_then_else:VB\n \t  (unspec:VB\n-\t    [(match_operand:VB 1 \"vector_mask_operand\"   \"Wc1, Wc1, Wc1, Wc1, Wc1\")\n-\t     (match_operand 4 \"vector_length_operand\"    \" rK,  rK,  rK,  rK,  rK\")\n-\t     (match_operand 5 \"const_int_operand\"        \"  i,   i,   i,   i,   i\")\n+\t    [(match_operand:VB 1 \"vector_all_trues_mask_operand\" \"Wc1, Wc1, Wc1, Wc1, Wc1\")\n+\t     (match_operand 4 \"vector_length_operand\"            \" rK,  rK,  rK,  rK,  rK\")\n+\t     (match_operand 5 \"const_int_operand\"                \"  i,   i,   i,   i,   i\")\n \t     (reg:SI VL_REGNUM)\n \t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n-\t  (match_operand:VB 3 \"vector_move_operand\"      \"  m,  vr,  vr, Wc0, Wc1\")\n-\t  (match_operand:VB 2 \"vector_merge_operand\"     \" vu,  vu,  vu,  vu,  vu\")))]\n+\t  (match_operand:VB 3 \"vector_move_operand\"              \"  m,  vr,  vr, Wc0, Wc1\")\n+\t  (match_operand:VB 2 \"vector_undef_operand\"             \" vu,  vu,  vu,  vu,  vu\")))]\n   \"TARGET_VECTOR\"\n   \"@\n    vlm.v\\t%0,%3\n@@ -790,14 +793,14 @@\n ;; Dedicated pattern for vsm.v instruction since we can't reuse pred_mov pattern to include\n ;; memory operand as input which will produce inferior codegen.\n (define_insn \"@pred_store<mode>\"\n-  [(set (match_operand:VB 0 \"memory_operand\"            \"+m\")\n+  [(set (match_operand:VB 0 \"memory_operand\"                      \"+m\")\n \t(if_then_else:VB\n \t  (unspec:VB\n-\t    [(match_operand:VB 1 \"vector_mask_operand\" \"Wc1\")\n-\t     (match_operand 3 \"vector_length_operand\"  \" rK\")\n+\t    [(match_operand:VB 1 \"vector_all_trues_mask_operand\" \"Wc1\")\n+\t     (match_operand 3 \"vector_length_operand\"            \" rK\")\n \t     (reg:SI VL_REGNUM)\n \t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n-\t  (match_operand:VB 2 \"register_operand\"       \" vr\")\n+\t  (match_operand:VB 2 \"register_operand\"                 \" vr\")\n \t  (match_dup 0)))]\n   \"TARGET_VECTOR\"\n   \"vsm.v\\t%2,%0\"\n@@ -3399,3 +3402,726 @@\n   \"vnclip<v_su>.w%o4\\t%0,%3,%4%p1\"\n   [(set_attr \"type\" \"vnclip\")\n    (set_attr \"mode\" \"<V_DOUBLE_TRUNC>\")])\n+\n+;; -------------------------------------------------------------------------------\n+;; ---- Predicated comparison operations\n+;; -------------------------------------------------------------------------------\n+;; Includes:\n+;; - 11.8 Vector Integer Comparision Instructions\n+;; -------------------------------------------------------------------------------\n+\n+(define_expand \"@pred_cmp<mode>\"\n+  [(set (match_operand:<VM> 0 \"register_operand\")\n+\t(if_then_else:<VM>\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\")\n+\t     (match_operand 6 \"vector_length_operand\")\n+\t     (match_operand 7 \"const_int_operand\")\n+\t     (match_operand 8 \"const_int_operand\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (match_operator:<VM> 3 \"comparison_except_ltge_operator\"\n+\t     [(match_operand:VI 4 \"register_operand\")\n+\t      (match_operand:VI 5 \"vector_arith_operand\")])\n+\t  (match_operand:<VM> 2 \"vector_merge_operand\")))]\n+  \"TARGET_VECTOR\"\n+  {})\n+\n+;; We don't use early-clobber for LMUL <= 1 to get better codegen.\n+(define_insn \"*pred_cmp<mode>\"\n+  [(set (match_operand:<VM> 0 \"register_operand\"                \"=vr,   vr\")\n+\t(if_then_else:<VM>\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"      \"vmWc1,vmWc1\")\n+\t     (match_operand 6 \"vector_length_operand\"         \"   rK,   rK\")\n+\t     (match_operand 7 \"const_int_operand\"             \"    i,    i\")\n+\t     (match_operand 8 \"const_int_operand\"             \"    i,    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (match_operator:<VM> 3 \"comparison_except_ltge_operator\"\n+\t     [(match_operand:VI 4 \"register_operand\"          \"   vr,   vr\")\n+\t      (match_operand:VI 5 \"vector_arith_operand\"      \"   vr,   vi\")])\n+\t  (match_operand:<VM> 2 \"vector_merge_operand\"        \"  0vu,  0vu\")))]\n+  \"TARGET_VECTOR && known_le (GET_MODE_SIZE (<MODE>mode), BYTES_PER_RISCV_VECTOR)\"\n+  \"vms%B3.v%o5\\t%0,%4,%v5%p1\"\n+  [(set_attr \"type\" \"vicmp\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+;; We use early-clobber for source LMUL > dest LMUL.\n+(define_insn \"*pred_cmp<mode>_narrow\"\n+  [(set (match_operand:<VM> 0 \"register_operand\"              \"=&vr,   &vr\")\n+\t(if_then_else:<VM>\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"      \"vmWc1,vmWc1\")\n+\t     (match_operand 6 \"vector_length_operand\"         \"   rK,   rK\")\n+\t     (match_operand 7 \"const_int_operand\"             \"    i,    i\")\n+\t     (match_operand 8 \"const_int_operand\"             \"    i,    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (match_operator:<VM> 3 \"comparison_except_ltge_operator\"\n+\t     [(match_operand:VI 4 \"register_operand\"          \"   vr,   vr\")\n+\t      (match_operand:VI 5 \"vector_arith_operand\"      \"   vr,   vi\")])\n+\t  (match_operand:<VM> 2 \"vector_merge_operand\"        \"  0vu,  0vu\")))]\n+  \"TARGET_VECTOR && known_gt (GET_MODE_SIZE (<MODE>mode), BYTES_PER_RISCV_VECTOR)\"\n+  \"vms%B3.v%o5\\t%0,%4,%v5%p1\"\n+  [(set_attr \"type\" \"vicmp\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_expand \"@pred_ltge<mode>\"\n+  [(set (match_operand:<VM> 0 \"register_operand\")\n+\t(if_then_else:<VM>\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\")\n+\t     (match_operand 6 \"vector_length_operand\")\n+\t     (match_operand 7 \"const_int_operand\")\n+\t     (match_operand 8 \"const_int_operand\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (match_operator:<VM> 3 \"ltge_operator\"\n+\t     [(match_operand:VI 4 \"register_operand\")\n+\t      (match_operand:VI 5 \"vector_neg_arith_operand\")])\n+\t  (match_operand:<VM> 2 \"vector_merge_operand\")))]\n+  \"TARGET_VECTOR\"\n+  {})\n+\n+;; We don't use early-clobber for LMUL <= 1 to get better codegen.\n+(define_insn \"*pred_ltge<mode>\"\n+  [(set (match_operand:<VM> 0 \"register_operand\"                \"=vr,   vr\")\n+\t(if_then_else:<VM>\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"      \"vmWc1,vmWc1\")\n+\t     (match_operand 6 \"vector_length_operand\"         \"   rK,   rK\")\n+\t     (match_operand 7 \"const_int_operand\"             \"    i,    i\")\n+\t     (match_operand 8 \"const_int_operand\"             \"    i,    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (match_operator:<VM> 3 \"ltge_operator\"\n+\t     [(match_operand:VI 4 \"register_operand\"          \"   vr,   vr\")\n+\t      (match_operand:VI 5 \"vector_neg_arith_operand\"  \"   vr,   vj\")])\n+\t  (match_operand:<VM> 2 \"vector_merge_operand\"        \"  0vu,  0vu\")))]\n+  \"TARGET_VECTOR && known_le (GET_MODE_SIZE (<MODE>mode), BYTES_PER_RISCV_VECTOR)\"\n+  \"vms%B3.v%o5\\t%0,%4,%v5%p1\"\n+  [(set_attr \"type\" \"vicmp\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+;; We use early-clobber for source LMUL > dest LMUL.\n+(define_insn \"*pred_ltge<mode>_narrow\"\n+  [(set (match_operand:<VM> 0 \"register_operand\"              \"=&vr,   &vr\")\n+\t(if_then_else:<VM>\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"      \"vmWc1,vmWc1\")\n+\t     (match_operand 6 \"vector_length_operand\"         \"   rK,   rK\")\n+\t     (match_operand 7 \"const_int_operand\"             \"    i,    i\")\n+\t     (match_operand 8 \"const_int_operand\"             \"    i,    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (match_operator:<VM> 3 \"ltge_operator\"\n+\t     [(match_operand:VI 4 \"register_operand\"          \"   vr,   vr\")\n+\t      (match_operand:VI 5 \"vector_neg_arith_operand\"  \"   vr,   vj\")])\n+\t  (match_operand:<VM> 2 \"vector_merge_operand\"        \"  0vu,  0vu\")))]\n+  \"TARGET_VECTOR && known_gt (GET_MODE_SIZE (<MODE>mode), BYTES_PER_RISCV_VECTOR)\"\n+  \"vms%B3.v%o5\\t%0,%4,%v5%p1\"\n+  [(set_attr \"type\" \"vicmp\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_expand \"@pred_cmp<mode>_scalar\"\n+  [(set (match_operand:<VM> 0 \"register_operand\")\n+\t(if_then_else:<VM>\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\")\n+\t     (match_operand 6 \"vector_length_operand\")\n+\t     (match_operand 7 \"const_int_operand\")\n+\t     (match_operand 8 \"const_int_operand\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (match_operator:<VM> 3 \"comparison_except_eqge_operator\"\n+\t     [(match_operand:VI_QHS 4 \"register_operand\")\n+\t      (vec_duplicate:VI_QHS\n+\t        (match_operand:<VEL> 5 \"register_operand\"))])\n+\t  (match_operand:<VM> 2 \"vector_merge_operand\")))]\n+  \"TARGET_VECTOR\"\n+  {})\n+\n+;; We don't use early-clobber for LMUL <= 1 to get better codegen.\n+(define_insn \"*pred_cmp<mode>_scalar\"\n+  [(set (match_operand:<VM> 0 \"register_operand\"                \"=vr\")\n+\t(if_then_else:<VM>\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"      \"vmWc1\")\n+\t     (match_operand 6 \"vector_length_operand\"         \"   rK\")\n+\t     (match_operand 7 \"const_int_operand\"             \"    i\")\n+\t     (match_operand 8 \"const_int_operand\"             \"    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (match_operator:<VM> 3 \"comparison_except_eqge_operator\"\n+\t     [(match_operand:VI_QHS 4 \"register_operand\"      \"   vr\")\n+\t      (vec_duplicate:VI_QHS\n+\t        (match_operand:<VEL> 5 \"register_operand\"     \"    r\"))])\n+\t  (match_operand:<VM> 2 \"vector_merge_operand\"        \"  0vu\")))]\n+  \"TARGET_VECTOR && known_le (GET_MODE_SIZE (<MODE>mode), BYTES_PER_RISCV_VECTOR)\"\n+  \"vms%B3.vx\\t%0,%4,%5%p1\"\n+  [(set_attr \"type\" \"vicmp\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+;; We use early-clobber for source LMUL > dest LMUL.\n+(define_insn \"*pred_cmp<mode>_scalar_narrow\"\n+  [(set (match_operand:<VM> 0 \"register_operand\"               \"=&vr\")\n+\t(if_then_else:<VM>\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"      \"vmWc1\")\n+\t     (match_operand 6 \"vector_length_operand\"         \"   rK\")\n+\t     (match_operand 7 \"const_int_operand\"             \"    i\")\n+\t     (match_operand 8 \"const_int_operand\"             \"    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (match_operator:<VM> 3 \"comparison_except_eqge_operator\"\n+\t     [(match_operand:VI_QHS 4 \"register_operand\"      \"   vr\")\n+\t      (vec_duplicate:VI_QHS\n+\t        (match_operand:<VEL> 5 \"register_operand\"     \"    r\"))])\n+\t  (match_operand:<VM> 2 \"vector_merge_operand\"        \"  0vu\")))]\n+  \"TARGET_VECTOR && known_gt (GET_MODE_SIZE (<MODE>mode), BYTES_PER_RISCV_VECTOR)\"\n+  \"vms%B3.vx\\t%0,%4,%5%p1\"\n+  [(set_attr \"type\" \"vicmp\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_expand \"@pred_eqne<mode>_scalar\"\n+  [(set (match_operand:<VM> 0 \"register_operand\")\n+\t(if_then_else:<VM>\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\")\n+\t     (match_operand 6 \"vector_length_operand\")\n+\t     (match_operand 7 \"const_int_operand\")\n+\t     (match_operand 8 \"const_int_operand\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (match_operator:<VM> 3 \"equality_operator\"\n+\t     [(vec_duplicate:VI_QHS\n+\t        (match_operand:<VEL> 5 \"register_operand\"))\n+\t      (match_operand:VI_QHS 4 \"register_operand\")])\n+\t  (match_operand:<VM> 2 \"vector_merge_operand\")))]\n+  \"TARGET_VECTOR\"\n+  {})\n+\n+;; We don't use early-clobber for LMUL <= 1 to get better codegen.\n+(define_insn \"*pred_eqne<mode>_scalar\"\n+  [(set (match_operand:<VM> 0 \"register_operand\"                \"=vr\")\n+\t(if_then_else:<VM>\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"      \"vmWc1\")\n+\t     (match_operand 6 \"vector_length_operand\"         \"   rK\")\n+\t     (match_operand 7 \"const_int_operand\"             \"    i\")\n+\t     (match_operand 8 \"const_int_operand\"             \"    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (match_operator:<VM> 3 \"equality_operator\"\n+\t     [(vec_duplicate:VI_QHS\n+\t        (match_operand:<VEL> 5 \"register_operand\"     \"    r\"))\n+\t      (match_operand:VI_QHS 4 \"register_operand\"      \"   vr\")])\n+\t  (match_operand:<VM> 2 \"vector_merge_operand\"        \"  0vu\")))]\n+  \"TARGET_VECTOR && known_le (GET_MODE_SIZE (<MODE>mode), BYTES_PER_RISCV_VECTOR)\"\n+  \"vms%B3.vx\\t%0,%4,%5%p1\"\n+  [(set_attr \"type\" \"vicmp\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+;; We use early-clobber for source LMUL > dest LMUL.\n+(define_insn \"*pred_eqne<mode>_scalar_narrow\"\n+  [(set (match_operand:<VM> 0 \"register_operand\"               \"=&vr\")\n+\t(if_then_else:<VM>\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"      \"vmWc1\")\n+\t     (match_operand 6 \"vector_length_operand\"         \"   rK\")\n+\t     (match_operand 7 \"const_int_operand\"             \"    i\")\n+\t     (match_operand 8 \"const_int_operand\"             \"    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (match_operator:<VM> 3 \"equality_operator\"\n+\t     [(vec_duplicate:VI_QHS\n+\t        (match_operand:<VEL> 5 \"register_operand\"     \"    r\"))\n+\t      (match_operand:VI_QHS 4 \"register_operand\"      \"   vr\")])\n+\t  (match_operand:<VM> 2 \"vector_merge_operand\"        \"  0vu\")))]\n+  \"TARGET_VECTOR && known_gt (GET_MODE_SIZE (<MODE>mode), BYTES_PER_RISCV_VECTOR)\"\n+  \"vms%B3.vx\\t%0,%4,%5%p1\"\n+  [(set_attr \"type\" \"vicmp\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+;; Handle GET_MODE_INNER (mode) = DImode. We need to split them since\n+;; we need to deal with SEW = 64 in RV32 system.\n+(define_expand \"@pred_cmp<mode>_scalar\"\n+  [(set (match_operand:<VM> 0 \"register_operand\")\n+\t(if_then_else:<VM>\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\")\n+\t     (match_operand 6 \"vector_length_operand\")\n+\t     (match_operand 7 \"const_int_operand\")\n+\t     (match_operand 8 \"const_int_operand\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (match_operator:<VM> 3 \"comparison_except_eqge_operator\"\n+\t     [(match_operand:VI_D 4 \"register_operand\")\n+\t      (vec_duplicate:VI_D\n+\t        (match_operand:<VEL> 5 \"reg_or_int_operand\"))])\n+\t  (match_operand:<VM> 2 \"vector_merge_operand\")))]\n+  \"TARGET_VECTOR\"\n+  {\n+    enum rtx_code code = GET_CODE (operands[3]);\n+\n+    if (riscv_vector::has_vi_variant_p (code, operands[5]))\n+      operands[5] = force_reg (<VEL>mode, operands[5]);\n+    else if (!TARGET_64BIT)\n+      {\n+\trtx v = gen_reg_rtx (<MODE>mode);\n+\n+\tif (riscv_vector::simm32_p (operands[5]))\n+\t  {\n+\t    if (!rtx_equal_p (operands[5], const0_rtx))\n+\t      operands[5] = force_reg (Pmode, operands[5]);\n+\t    operands[5] = gen_rtx_SIGN_EXTEND (<VEL>mode, operands[5]);\n+\t  }\n+\telse\n+\t  {\n+\t    if (CONST_INT_P (operands[5]))\n+\t      operands[5] = force_reg (<VEL>mode, operands[5]);\n+\n+\t    riscv_vector::emit_nonvlmax_op (code_for_pred_broadcast (<MODE>mode),\n+\t\t\tv, operands[5], operands[6], <VM>mode);\n+\t    if (code == LT || code == LTU)\n+\t\temit_insn (gen_pred_ltge<mode> (operands[0], operands[1],\n+\t\t\t   operands[2], operands[3], operands[4], v,\n+\t\t\t   operands[6], operands[7], operands[8]));\n+\t    else\n+\t\temit_insn (gen_pred_cmp<mode> (operands[0], operands[1],\n+\t\t\t   operands[2], operands[3], operands[4], v,\n+\t\t\t   operands[6], operands[7], operands[8]));\n+\t    DONE;\n+\t  }\n+      }\n+    else\n+      operands[5] = force_reg (<VEL>mode, operands[5]);\n+  })\n+\n+(define_expand \"@pred_eqne<mode>_scalar\"\n+  [(set (match_operand:<VM> 0 \"register_operand\")\n+\t(if_then_else:<VM>\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\")\n+\t     (match_operand 6 \"vector_length_operand\")\n+\t     (match_operand 7 \"const_int_operand\")\n+\t     (match_operand 8 \"const_int_operand\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (match_operator:<VM> 3 \"equality_operator\"\n+\t     [(vec_duplicate:VI_D\n+\t        (match_operand:<VEL> 5 \"reg_or_int_operand\"))\n+\t      (match_operand:VI_D 4 \"register_operand\")])\n+\t  (match_operand:<VM> 2 \"vector_merge_operand\")))]\n+  \"TARGET_VECTOR\"\n+  {\n+    enum rtx_code code = GET_CODE (operands[3]);\n+\n+    if (riscv_vector::has_vi_variant_p (code, operands[5]))\n+      operands[5] = force_reg (<VEL>mode, operands[5]);\n+    else if (!TARGET_64BIT)\n+      {\n+\trtx v = gen_reg_rtx (<MODE>mode);\n+\n+\tif (riscv_vector::simm32_p (operands[5]))\n+\t  {\n+\t    if (!rtx_equal_p (operands[5], const0_rtx))\n+\t      operands[5] = force_reg (Pmode, operands[5]);\n+\t    operands[5] = gen_rtx_SIGN_EXTEND (<VEL>mode, operands[5]);\n+\t  }\n+\telse\n+\t  {\n+\t    if (CONST_INT_P (operands[5]))\n+\t      operands[5] = force_reg (<VEL>mode, operands[5]);\n+\n+\t    riscv_vector::emit_nonvlmax_op (code_for_pred_broadcast (<MODE>mode),\n+\t\t\tv, operands[5], operands[6], <VM>mode);\n+\t    emit_insn (gen_pred_cmp<mode> (operands[0], operands[1],\n+\t\t       operands[2], operands[3], operands[4], v,\n+\t\t       operands[6], operands[7], operands[8]));\n+\t    DONE;\n+\t  }\n+      }\n+    else\n+      operands[5] = force_reg (<VEL>mode, operands[5]);\n+  })\n+\n+;; We don't use early-clobber for LMUL <= 1 to get better codegen.\n+(define_insn \"*pred_cmp<mode>_scalar\"\n+  [(set (match_operand:<VM> 0 \"register_operand\"                \"=vr\")\n+\t(if_then_else:<VM>\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"      \"vmWc1\")\n+\t     (match_operand 6 \"vector_length_operand\"         \"   rK\")\n+\t     (match_operand 7 \"const_int_operand\"             \"    i\")\n+\t     (match_operand 8 \"const_int_operand\"             \"    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (match_operator:<VM> 3 \"comparison_except_eqge_operator\"\n+\t     [(match_operand:VI_D 4 \"register_operand\"        \"    vr\")\n+\t      (vec_duplicate:VI_D\n+\t        (match_operand:<VEL> 5 \"register_operand\"     \"    r\"))])\n+\t  (match_operand:<VM> 2 \"vector_merge_operand\"        \"  0vu\")))]\n+  \"TARGET_VECTOR && known_le (GET_MODE_SIZE (<MODE>mode), BYTES_PER_RISCV_VECTOR)\"\n+  \"vms%B3.vx\\t%0,%4,%5%p1\"\n+  [(set_attr \"type\" \"vicmp\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+;; We use early-clobber for source LMUL > dest LMUL.\n+(define_insn \"*pred_cmp<mode>_scalar_narrow\"\n+  [(set (match_operand:<VM> 0 \"register_operand\"               \"=&vr\")\n+\t(if_then_else:<VM>\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"      \"vmWc1\")\n+\t     (match_operand 6 \"vector_length_operand\"         \"   rK\")\n+\t     (match_operand 7 \"const_int_operand\"             \"    i\")\n+\t     (match_operand 8 \"const_int_operand\"             \"    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (match_operator:<VM> 3 \"comparison_except_eqge_operator\"\n+\t     [(match_operand:VI_D 4 \"register_operand\"        \"   vr\")\n+\t      (vec_duplicate:VI_D\n+\t        (match_operand:<VEL> 5 \"register_operand\"     \"    r\"))])\n+\t  (match_operand:<VM> 2 \"vector_merge_operand\"        \"  0vu\")))]\n+  \"TARGET_VECTOR && known_gt (GET_MODE_SIZE (<MODE>mode), BYTES_PER_RISCV_VECTOR)\"\n+  \"vms%B3.vx\\t%0,%4,%5%p1\"\n+  [(set_attr \"type\" \"vicmp\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+;; We don't use early-clobber for LMUL <= 1 to get better codegen.\n+(define_insn \"*pred_eqne<mode>_scalar\"\n+  [(set (match_operand:<VM> 0 \"register_operand\"                \"=vr\")\n+\t(if_then_else:<VM>\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"      \"vmWc1\")\n+\t     (match_operand 6 \"vector_length_operand\"         \"   rK\")\n+\t     (match_operand 7 \"const_int_operand\"             \"    i\")\n+\t     (match_operand 8 \"const_int_operand\"             \"    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (match_operator:<VM> 3 \"equality_operator\"\n+\t     [(vec_duplicate:VI_D\n+\t        (match_operand:<VEL> 5 \"register_operand\"     \"    r\"))\n+\t      (match_operand:VI_D 4 \"register_operand\"        \"   vr\")])\n+\t  (match_operand:<VM> 2 \"vector_merge_operand\"        \"  0vu\")))]\n+  \"TARGET_VECTOR && known_le (GET_MODE_SIZE (<MODE>mode), BYTES_PER_RISCV_VECTOR)\"\n+  \"vms%B3.vx\\t%0,%4,%5%p1\"\n+  [(set_attr \"type\" \"vicmp\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+;; We use early-clobber for source LMUL > dest LMUL.\n+(define_insn \"*pred_eqne<mode>_scalar_narrow\"\n+  [(set (match_operand:<VM> 0 \"register_operand\"               \"=&vr\")\n+\t(if_then_else:<VM>\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"      \"vmWc1\")\n+\t     (match_operand 6 \"vector_length_operand\"         \"   rK\")\n+\t     (match_operand 7 \"const_int_operand\"             \"    i\")\n+\t     (match_operand 8 \"const_int_operand\"             \"    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (match_operator:<VM> 3 \"equality_operator\"\n+\t     [(vec_duplicate:VI_D\n+\t        (match_operand:<VEL> 5 \"register_operand\"     \"    r\"))\n+\t      (match_operand:VI_D 4 \"register_operand\"        \"   vr\")])\n+\t  (match_operand:<VM> 2 \"vector_merge_operand\"        \"  0vu\")))]\n+  \"TARGET_VECTOR && known_gt (GET_MODE_SIZE (<MODE>mode), BYTES_PER_RISCV_VECTOR)\"\n+  \"vms%B3.vx\\t%0,%4,%5%p1\"\n+  [(set_attr \"type\" \"vicmp\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+;; We don't use early-clobber for LMUL <= 1 to get better codegen.\n+(define_insn \"*pred_cmp<mode>_extended_scalar\"\n+  [(set (match_operand:<VM> 0 \"register_operand\"                 \"=vr\")\n+\t(if_then_else:<VM>\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"       \"vmWc1\")\n+\t     (match_operand 6 \"vector_length_operand\"          \"   rK\")\n+\t     (match_operand 7 \"const_int_operand\"              \"    i\")\n+\t     (match_operand 8 \"const_int_operand\"              \"    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (match_operator:<VM> 3 \"comparison_except_eqge_operator\"\n+\t     [(match_operand:VI_D 4 \"register_operand\"         \"   vr\")\n+\t      (vec_duplicate:VI_D\n+\t        (sign_extend:<VEL>\n+\t          (match_operand:<VSUBEL> 5 \"register_operand\" \"    r\")))])\n+\t  (match_operand:<VM> 2 \"vector_merge_operand\"         \"  0vu\")))]\n+  \"TARGET_VECTOR && known_le (GET_MODE_SIZE (<MODE>mode), BYTES_PER_RISCV_VECTOR)\"\n+  \"vms%B3.vx\\t%0,%4,%5%p1\"\n+  [(set_attr \"type\" \"vicmp\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"*pred_cmp<mode>_extended_scalar_narrow\"\n+  [(set (match_operand:<VM> 0 \"register_operand\"                \"=&vr\")\n+\t(if_then_else:<VM>\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"       \"vmWc1\")\n+\t     (match_operand 6 \"vector_length_operand\"          \"   rK\")\n+\t     (match_operand 7 \"const_int_operand\"              \"    i\")\n+\t     (match_operand 8 \"const_int_operand\"              \"    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (match_operator:<VM> 3 \"comparison_except_eqge_operator\"\n+\t     [(match_operand:VI_D 4 \"register_operand\"         \"   vr\")\n+\t      (vec_duplicate:VI_D\n+\t        (sign_extend:<VEL>\n+\t          (match_operand:<VSUBEL> 5 \"register_operand\" \"    r\")))])\n+\t  (match_operand:<VM> 2 \"vector_merge_operand\"         \"  0vu\")))]\n+  \"TARGET_VECTOR && known_gt (GET_MODE_SIZE (<MODE>mode), BYTES_PER_RISCV_VECTOR)\"\n+  \"vms%B3.vx\\t%0,%4,%5%p1\"\n+  [(set_attr \"type\" \"vicmp\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+;; We don't use early-clobber for LMUL <= 1 to get better codegen.\n+(define_insn \"*pred_eqne<mode>_extended_scalar\"\n+  [(set (match_operand:<VM> 0 \"register_operand\"                 \"=vr\")\n+\t(if_then_else:<VM>\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"       \"vmWc1\")\n+\t     (match_operand 6 \"vector_length_operand\"          \"   rK\")\n+\t     (match_operand 7 \"const_int_operand\"              \"    i\")\n+\t     (match_operand 8 \"const_int_operand\"              \"    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (match_operator:<VM> 3 \"equality_operator\"\n+\t     [(vec_duplicate:VI_D\n+\t        (sign_extend:<VEL>\n+\t          (match_operand:<VSUBEL> 5 \"register_operand\" \"    r\")))\n+\t      (match_operand:VI_D 4 \"register_operand\"         \"   vr\")])\n+\t  (match_operand:<VM> 2 \"vector_merge_operand\"         \"  0vu\")))]\n+  \"TARGET_VECTOR && known_le (GET_MODE_SIZE (<MODE>mode), BYTES_PER_RISCV_VECTOR)\"\n+  \"vms%B3.vx\\t%0,%4,%5%p1\"\n+  [(set_attr \"type\" \"vicmp\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"*pred_eqne<mode>_extended_scalar_narrow\"\n+  [(set (match_operand:<VM> 0 \"register_operand\"                \"=&vr\")\n+\t(if_then_else:<VM>\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"       \"vmWc1\")\n+\t     (match_operand 6 \"vector_length_operand\"          \"   rK\")\n+\t     (match_operand 7 \"const_int_operand\"              \"    i\")\n+\t     (match_operand 8 \"const_int_operand\"              \"    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (match_operator:<VM> 3 \"equality_operator\"\n+\t     [(vec_duplicate:VI_D\n+\t        (sign_extend:<VEL>\n+\t          (match_operand:<VSUBEL> 5 \"register_operand\" \"    r\")))\n+\t      (match_operand:VI_D 4 \"register_operand\"         \"   vr\")])\n+\t  (match_operand:<VM> 2 \"vector_merge_operand\"         \"  0vu\")))]\n+  \"TARGET_VECTOR && known_gt (GET_MODE_SIZE (<MODE>mode), BYTES_PER_RISCV_VECTOR)\"\n+  \"vms%B3.vx\\t%0,%4,%5%p1\"\n+  [(set_attr \"type\" \"vicmp\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+;; GE, vmsge.vx/vmsgeu.vx\n+;;\n+;; unmasked va >= x\n+;;  - pseudoinstruction: vmsge{u}.vx vd, va, x\n+;;  - expansion: vmslt{u}.vx vd, va, x; vmnand.mm vd, vd, vd\n+;;\n+;; masked va >= x, vd != v0\n+;;  - pseudoinstruction: vmsge{u}.vx vd, va, x, v0.t\n+;;  - expansion: vmslt{u}.vx vd, va, x, v0.t; vmxor.mm vd, vd, v0\n+;;\n+;; masked va >= x, vd == v0\n+;;  - pseudoinstruction: vmsge{u}.vx vd, va, x, v0.t, vt\n+;;  - expansion: vmslt{u}.vx vt, va, x;  vmandn.mm vd, vd, vt\n+(define_expand \"@pred_ge<mode>_scalar\"\n+  [(set (match_operand:<VM> 0 \"register_operand\")\n+\t(if_then_else:<VM>\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\")\n+\t     (match_operand 6 \"vector_length_operand\")\n+\t     (match_operand 7 \"const_int_operand\")\n+\t     (match_operand 8 \"const_int_operand\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (match_operator:<VM> 3 \"ge_operator\"\n+\t     [(match_operand:VI 4 \"register_operand\")\n+\t      (vec_duplicate:VI\n+\t        (match_operand:<VEL> 5 \"reg_or_int_operand\"))])\n+\t  (match_operand:<VM> 2 \"vector_merge_operand\")))]\n+  \"TARGET_VECTOR\"\n+{\n+  enum rtx_code code = GET_CODE (operands[3]);\n+  rtx undef = gen_rtx_UNSPEC (<VM>mode, gen_rtvec (1, const0_rtx), UNSPEC_VUNDEF);\n+  if (code == GEU && rtx_equal_p (operands[5], const0_rtx))\n+    {\n+      /* If vmsgeu with 0 immediate, expand it to vmset.  */\n+      if (satisfies_constraint_Wc1 (operands[1]))\n+\temit_insn (\n+\t  gen_pred_mov (<VM>mode, operands[0], CONSTM1_RTX (<VM>mode), undef,\n+\t\t\tCONSTM1_RTX (<VM>mode), operands[6], operands[8]));\n+      else\n+\t{\n+\t  /* If vmsgeu_mask with 0 immediate, expand it to vmor mask, maskedoff.\n+\t   */\n+\t  if (rtx_equal_p (operands[1], operands[2]))\n+\t    emit_move_insn (operands[0], operands[1]);\n+\t  else if (register_operand (operands[2], <VM>mode))\n+\t    emit_insn (gen_pred (IOR, <VM>mode, operands[0],\n+\t\t\t\t CONSTM1_RTX (<VM>mode), undef, operands[1],\n+\t\t\t\t operands[2], operands[6], operands[8]));\n+\t  else\n+\t    emit_insn (gen_pred (IOR, <VM>mode, operands[0],\n+\t\t\t\t CONSTM1_RTX (<VM>mode), undef, operands[1],\n+\t\t\t\t operands[1], operands[6], operands[8]));\n+\t}\n+    }\n+  else if (riscv_vector::neg_simm5_p (operands[5]))\n+    emit_insn (\n+      gen_pred_ltge<mode> (operands[0], operands[1], operands[2], operands[3],\n+\t\t\t   operands[4],\n+\t\t\t   gen_const_vec_duplicate (<MODE>mode, operands[5]),\n+\t\t\t   operands[6], operands[7], operands[8]));\n+  else\n+    {\n+      if (code == GE)\n+\toperands[3] = gen_rtx_fmt_ee (LT, <VM>mode, XEXP (operands[3], 0),\n+\t\t\t\t      XEXP (operands[3], 1));\n+      else\n+\toperands[3] = gen_rtx_fmt_ee (LTU, <VM>mode, XEXP (operands[3], 0),\n+\t\t\t\t      XEXP (operands[3], 1));\n+      if (GET_MODE_BITSIZE (<VEL>mode) <= GET_MODE_BITSIZE (Pmode))\n+\toperands[5] = force_reg (<VEL>mode, operands[5]);\n+\n+      if (satisfies_constraint_Wc1 (operands[1]))\n+\t{\n+\t  /* unmasked va >= x\n+\t    - pseudoinstruction: vmsge{u}.vx vd, va, x\n+\t    - expansion: vmslt{u}.vx vd, va, x; vmnand.mm vd, vd, vd.  */\n+\t  emit_insn (\n+\t    gen_pred_cmp<mode>_scalar (operands[0], operands[1], operands[2],\n+\t\t\t\t\toperands[3], operands[4], operands[5],\n+\t\t\t\t\toperands[6], operands[7], operands[8]));\n+\t  emit_insn (gen_pred_nand<vm> (operands[0], CONSTM1_RTX (<VM>mode),\n+\t\t\t\t\tundef, operands[0], operands[0],\n+\t\t\t\t\toperands[6], operands[8]));\n+\t}\n+      else\n+\t{\n+\t  if (rtx_equal_p (operands[1], operands[2]))\n+\t    {\n+\t      /* masked va >= x, vd == v0\n+\t\t- pseudoinstruction: vmsge{u}.vx vd, va, x, v0.t, vt\n+\t\t- expansion: vmslt{u}.vx vt, va, x;  vmandn.mm vd, vd, vt.  */\n+\t      rtx reg = gen_reg_rtx (<VM>mode);\n+\t      emit_insn (gen_pred_cmp<mode>_scalar (\n+\t\treg, CONSTM1_RTX (<VM>mode), undef, operands[3], operands[4],\n+\t\toperands[5], operands[6], operands[7], operands[8]));\n+\t      emit_insn (\n+\t\tgen_pred_andn<vm> (operands[0], CONSTM1_RTX (<VM>mode), undef,\n+\t\t\t\t   operands[1], reg, operands[6], operands[8]));\n+\t    }\n+\t  else\n+\t    {\n+\t      /* masked va >= x, vd != v0\n+\t\t- pseudoinstruction: vmsge{u}.vx vd, va, x, v0.t\n+\t\t- expansion: vmslt{u}.vx vd, va, x, v0.t; vmxor.mm vd, vd, v0.\n+\t      */\n+\t      emit_insn (gen_pred_cmp<mode>_scalar (\n+\t\toperands[0], operands[1], operands[2], operands[3], operands[4],\n+\t\toperands[5], operands[6], operands[7], operands[8]));\n+\t      emit_insn (gen_pred (XOR, <VM>mode, operands[0],\n+\t\t\t\t   CONSTM1_RTX (<VM>mode), undef, operands[0],\n+\t\t\t\t   operands[1], operands[6], operands[8]));\n+\t    }\n+\t}\n+    }\n+  DONE;\n+})\n+\n+;; -------------------------------------------------------------------------------\n+;; ---- Predicated BOOL mask operations\n+;; -------------------------------------------------------------------------------\n+;; Includes:\n+;; - 15.1 Vector Mask-Register Logical Instructions\n+;; -------------------------------------------------------------------------------\n+\n+;; We keep this pattern same as pred_mov so that we can gain more optimizations.\n+;; For example, if we have vmxor.mm v1,v1,v1. It will be optmized as vmclr.m which\n+;; is generated by pred_mov.\n+(define_insn \"@pred_<optab><mode>\"\n+  [(set (match_operand:VB 0 \"register_operand\"                   \"=vr\")\n+\t(if_then_else:VB\n+\t  (unspec:VB\n+\t    [(match_operand:VB 1 \"vector_all_trues_mask_operand\" \"Wc1\")\n+\t     (match_operand 5 \"vector_length_operand\"            \" rK\")\n+\t     (match_operand 6 \"const_int_operand\"                \"  i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (any_bitwise:VB\n+\t    (match_operand:VB 3 \"register_operand\"               \" vr\")\n+\t    (match_operand:VB 4 \"register_operand\"               \" vr\"))\n+\t  (match_operand:VB 2 \"vector_undef_operand\"             \" vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"vm<insn>.mm\\t%0,%3,%4\"\n+  [(set_attr \"type\" \"vmalu\")\n+   (set_attr \"mode\" \"<MODE>\")\n+   (set_attr \"vl_op_idx\" \"5\")\n+   (set (attr \"avl_type\") (symbol_ref \"INTVAL (operands[6])\"))])\n+\n+(define_insn \"@pred_n<optab><mode>\"\n+  [(set (match_operand:VB 0 \"register_operand\"                   \"=vr\")\n+\t(if_then_else:VB\n+\t  (unspec:VB\n+\t    [(match_operand:VB 1 \"vector_all_trues_mask_operand\" \"Wc1\")\n+\t     (match_operand 5 \"vector_length_operand\"            \" rK\")\n+\t     (match_operand 6 \"const_int_operand\"                \"  i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (not:VB\n+\t    (any_bitwise:VB\n+\t      (match_operand:VB 3 \"register_operand\"             \" vr\")\n+\t      (match_operand:VB 4 \"register_operand\"             \" vr\")))\n+\t  (match_operand:VB 2 \"vector_undef_operand\"             \" vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"vm<ninsn>.mm\\t%0,%3,%4\"\n+  [(set_attr \"type\" \"vmalu\")\n+   (set_attr \"mode\" \"<MODE>\")\n+   (set_attr \"vl_op_idx\" \"5\")\n+   (set (attr \"avl_type\") (symbol_ref \"INTVAL (operands[6])\"))])\n+\n+(define_insn \"@pred_<optab>n<mode>\"\n+  [(set (match_operand:VB 0 \"register_operand\"                   \"=vr\")\n+\t(if_then_else:VB\n+\t  (unspec:VB\n+\t    [(match_operand:VB 1 \"vector_all_trues_mask_operand\" \"Wc1\")\n+\t     (match_operand 5 \"vector_length_operand\"            \" rK\")\n+\t     (match_operand 6 \"const_int_operand\"                \"  i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (and_ior:VB\n+\t    (match_operand:VB 3 \"register_operand\"               \" vr\")\n+\t    (not:VB\n+\t      (match_operand:VB 4 \"register_operand\"             \" vr\")))\n+\t  (match_operand:VB 2 \"vector_undef_operand\"             \" vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"vm<insn>n.mm\\t%0,%3,%4\"\n+  [(set_attr \"type\" \"vmalu\")\n+   (set_attr \"mode\" \"<MODE>\")\n+   (set_attr \"vl_op_idx\" \"5\")\n+   (set (attr \"avl_type\") (symbol_ref \"INTVAL (operands[6])\"))])\n+\n+(define_insn \"@pred_not<mode>\"\n+  [(set (match_operand:VB 0 \"register_operand\"                   \"=vr\")\n+\t(if_then_else:VB\n+\t  (unspec:VB\n+\t    [(match_operand:VB 1 \"vector_all_trues_mask_operand\" \"Wc1\")\n+\t     (match_operand 4 \"vector_length_operand\"            \" rK\")\n+\t     (match_operand 5 \"const_int_operand\"                \"  i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (not:VB\n+\t    (match_operand:VB 3 \"register_operand\"               \" vr\"))\n+\t  (match_operand:VB 2 \"vector_undef_operand\"             \" vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"vmnot.mm\\t%0,%3\"\n+  [(set_attr \"type\" \"vmalu\")\n+   (set_attr \"mode\" \"<MODE>\")\n+   (set_attr \"vl_op_idx\" \"4\")\n+   (set (attr \"avl_type\") (symbol_ref \"INTVAL (operands[5])\"))])"}]}