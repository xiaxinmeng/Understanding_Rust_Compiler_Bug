{"sha": "9a1b6b7a98ebcbdfd4210edde604293e03ed6eba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWExYjZiN2E5OGViY2JkZmQ0MjEwZWRkZTYwNDI5M2UwM2VkNmViYQ==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-09-11T22:39:34Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-09-11T22:39:34Z"}, "message": "tree.h (expand_case): Move prototype ...\n\n\t* tree.h (expand_case): Move prototype ...\n\t* expr.h (expand_case): ...here.\n\t(expand_sjlj_dispatch_table): New prototype.\n\t* stmt.c: Include pointer-set.h instead of bitmap.h.\n\t(expand_case): Use a pointer set instead of a bitmap for\n\talready-seen labels.  Fold label values here.\n\t(add_case_node): Don't fold label values here.\n\t(expand_sjlj_dispatch_table): New function.\n\t* except.c (sjlj_emit_dispatch_table): Use it.\n\nFrom-SVN: r191203", "tree": {"sha": "b469cd6db72a4e79549037180afa5a93d3451b03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b469cd6db72a4e79549037180afa5a93d3451b03"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a1b6b7a98ebcbdfd4210edde604293e03ed6eba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a1b6b7a98ebcbdfd4210edde604293e03ed6eba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a1b6b7a98ebcbdfd4210edde604293e03ed6eba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a1b6b7a98ebcbdfd4210edde604293e03ed6eba/comments", "author": null, "committer": null, "parents": [{"sha": "73072611358be40e7201e5dc8c5d26e22e22febb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73072611358be40e7201e5dc8c5d26e22e22febb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73072611358be40e7201e5dc8c5d26e22e22febb"}], "stats": {"total": 213, "additions": 158, "deletions": 55}, "files": [{"sha": "347bfee5e015939e8b33e67d326bed14947dd5bf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a1b6b7a98ebcbdfd4210edde604293e03ed6eba/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a1b6b7a98ebcbdfd4210edde604293e03ed6eba/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9a1b6b7a98ebcbdfd4210edde604293e03ed6eba", "patch": "@@ -1,3 +1,15 @@\n+2012-09-11  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* tree.h (expand_case): Move prototype ...\n+\t* expr.h (expand_case): ...here.\n+\t(expand_sjlj_dispatch_table): New prototype.\n+\t* stmt.c: Include pointer-set.h instead of bitmap.h.\n+\t(expand_case): Use a pointer set instead of a bitmap for\n+\talready-seen labels.  Fold label values here.\n+\t(add_case_node): Don't fold label values here.\n+\t(expand_sjlj_dispatch_table): New function.\n+\t* except.c (sjlj_emit_dispatch_table): Use it.\n+\n 2012-09-11  Marc Glisse  <marc.glisse@inria.fr>\n \n         * tree-ssa-forwprop.c (simplify_vector_constructor): New function."}, {"sha": "801718de1954629ac91ea38e179b3c4be75ed3a9", "filename": "gcc/except.c", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a1b6b7a98ebcbdfd4210edde604293e03ed6eba/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a1b6b7a98ebcbdfd4210edde604293e03ed6eba/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=9a1b6b7a98ebcbdfd4210edde604293e03ed6eba", "patch": "@@ -1361,17 +1361,9 @@ sjlj_emit_dispatch_table (rtx dispatch_label, int num_dispatch)\n \n   if (num_dispatch > 1)\n     {\n-      gimple switch_stmt;\n-      tree default_label = create_artificial_label (UNKNOWN_LOCATION);\n       rtx disp = adjust_address (fc, TYPE_MODE (integer_type_node),\n \t\t\t\t sjlj_fc_call_site_ofs);\n-      switch_stmt = gimple_build_switch (make_tree (integer_type_node, disp),\n-\t\t\t\t\t build_case_label (NULL, NULL,\n-\t\t\t\t\t\t\t   default_label),\n-\t\t\t\t\t dispatch_labels);\n-      expand_case (switch_stmt);\n-      emit_label (label_rtx (default_label));\n-      expand_builtin_trap ();\n+      expand_sjlj_dispatch_table (disp, dispatch_labels);\n     }\n \n   seq = get_insns ();"}, {"sha": "f63b8f3052d2f8f347d0cd8736e52a8cfb80b3bb", "filename": "gcc/expr.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a1b6b7a98ebcbdfd4210edde604293e03ed6eba/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a1b6b7a98ebcbdfd4210edde604293e03ed6eba/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=9a1b6b7a98ebcbdfd4210edde604293e03ed6eba", "patch": "@@ -721,4 +721,13 @@ extern tree build_libfunc_function (const char *);\n /* Get the personality libfunc for a function decl.  */\n rtx get_personality_function (tree);\n \n+\n+/* In stmt.c */\n+\n+/* Expand a GIMPLE_SWITCH statement.  */\n+extern void expand_case (gimple);\n+\n+/* Like expand_case but special-case for SJLJ exception dispatching.  */\n+extern void expand_sjlj_dispatch_table (rtx, VEC(tree,heap) *);\n+\n #endif /* GCC_EXPR_H */"}, {"sha": "b64b0807433168912623876ef7092b620505011c", "filename": "gcc/stmt.c", "status": "modified", "additions": 136, "deletions": 45, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a1b6b7a98ebcbdfd4210edde604293e03ed6eba/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a1b6b7a98ebcbdfd4210edde604293e03ed6eba/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=9a1b6b7a98ebcbdfd4210edde604293e03ed6eba", "patch": "@@ -52,7 +52,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"regs.h\"\n #include \"alloc-pool.h\"\n #include \"pretty-print.h\"\n-#include \"bitmap.h\"\n+#include \"pointer-set.h\"\n #include \"params.h\"\n #include \"dumpfile.h\"\n \n@@ -113,9 +113,6 @@ static int node_has_low_bound (case_node_ptr, tree);\n static int node_has_high_bound (case_node_ptr, tree);\n static int node_is_bounded (case_node_ptr, tree);\n static void emit_case_nodes (rtx, case_node_ptr, rtx, tree);\n-static struct case_node *add_case_node (struct case_node *, tree,\n-                                        tree, tree, tree, alloc_pool);\n-\n \f\n /* Return the rtx-label that corresponds to a LABEL_DECL,\n    creating it if necessary.  */\n@@ -1650,31 +1647,34 @@ expand_stack_restore (tree var)\n   emit_stack_restore (SAVE_BLOCK, sa);\n   fixup_args_size_notes (prev, get_last_insn (), 0);\n }\n+\n+/* Generate code to jump to LABEL if OP0 and OP1 are equal in mode MODE.  */\n+static void\n+do_jump_if_equal (enum machine_mode mode, rtx op0, rtx op1, rtx label,\n+\t\t  int unsignedp)\n+{\n+  do_compare_rtx_and_jump (op0, op1, EQ, unsignedp, mode,\n+\t\t\t   NULL_RTX, NULL_RTX, label, -1);\n+}\n \f\n /* Do the insertion of a case label into case_list.  The labels are\n    fed to us in descending order from the sorted vector of case labels used\n    in the tree part of the middle end.  So the list we construct is\n-   sorted in ascending order.  The bounds on the case range, LOW and HIGH,\n-   are converted to case's index type TYPE.  Note that the original type\n-   of the case index in the source code is usually \"lost\" during\n-   gimplification due to type promotion, but the case labels retain the\n-   original type.  */\n+   sorted in ascending order.  */\n \n static struct case_node *\n-add_case_node (struct case_node *head, tree type, tree low, tree high,\n+add_case_node (struct case_node *head, tree low, tree high,\n                tree label, alloc_pool case_node_pool)\n {\n   struct case_node *r;\n \n   gcc_checking_assert (low);\n-  gcc_checking_assert (! high || (TREE_TYPE (low) == TREE_TYPE (high)));\n+  gcc_checking_assert (high && (TREE_TYPE (low) == TREE_TYPE (high)));\n \n-  /* Add this label to the chain.  Make sure to drop overflow flags.  */\n+  /* Add this label to the chain.  */\n   r = (struct case_node *) pool_alloc (case_node_pool);\n-  r->low = build_int_cst_wide (type, TREE_INT_CST_LOW (low),\n-\t\t\t       TREE_INT_CST_HIGH (low));\n-  r->high = build_int_cst_wide (type, TREE_INT_CST_LOW (high),\n-\t\t\t\tTREE_INT_CST_HIGH (high));\n+  r->low = low;\n+  r->high = high;\n   r->code_label = label;\n   r->parent = r->left = NULL;\n   r->right = head;\n@@ -1952,17 +1952,10 @@ expand_case (gimple stmt)\n   rtx default_label = NULL_RTX;\n   unsigned int count, uniq;\n   int i;\n-  rtx before_case, end;\n   int ncases = gimple_switch_num_labels (stmt);\n   tree index_expr = gimple_switch_index (stmt);\n   tree index_type = TREE_TYPE (index_expr);\n-\n   tree elt;\n-  bitmap label_bitmap;\n-\n-  /* The insn after which the case dispatch should finally\n-     be emitted.  Zero for a dummy.  */\n-  rtx start;\n \n   /* A list of case labels; it is first built as a list and it may then\n      be rearranged into a nearly balanced binary tree.  */\n@@ -2005,17 +1998,15 @@ expand_case (gimple stmt)\n      how to expand this switch().  */\n   uniq = 0;\n   count = 0;\n-  label_bitmap = BITMAP_ALLOC (NULL);\n+  struct pointer_set_t *seen_labels = pointer_set_create ();\n   for (i = gimple_switch_num_labels (stmt) - 1; i >= 1; --i)\n     {\n-      tree low, high;\n-      rtx lab;\n-\n       elt = gimple_switch_label (stmt, i);\n-      low = CASE_LOW (elt);\n+      tree low = CASE_LOW (elt);\n       gcc_assert (low);\n-      high = CASE_HIGH (elt);\n+      tree high = CASE_HIGH (elt);\n       gcc_assert (! high || tree_int_cst_lt (low, high));\n+      tree lab = CASE_LABEL (elt);\n \n       /* Count the elements.\n \t A range counts double, since it requires two compares.  */\n@@ -2025,28 +2016,43 @@ expand_case (gimple stmt)\n \n       /* If we have not seen this label yet, then increase the\n \t number of unique case node targets seen.  */\n-      lab = label_rtx (CASE_LABEL (elt));\n-      if (bitmap_set_bit (label_bitmap, CODE_LABEL_NUMBER (lab)))\n+      if (!pointer_set_insert (seen_labels, lab))\n \tuniq++;\n \n+      /* The bounds on the case range, LOW and HIGH, have to be converted\n+\t to case's index type TYPE.  Note that the original type of the\n+\t case index in the source code is usually \"lost\" during\n+\t gimplification due to type promotion, but the case labels retain the\n+\t original type.  Make sure to drop overflow flags.  */\n+      low = fold_convert (index_type, low);\n+      if (TREE_OVERFLOW (low))\n+\tlow = build_int_cst_wide (index_type,\n+\t\t\t\t  TREE_INT_CST_LOW (low),\n+\t\t\t\t  TREE_INT_CST_HIGH (low));\n+\n       /* The canonical from of a case label in GIMPLE is that a simple case\n \t has an empty CASE_HIGH.  For the casesi and tablejump expanders,\n \t the back ends want simple cases to have high == low.  */\n       if (! high)\n \thigh = low;\n-\n-      case_list = add_case_node (case_list, index_type, low, high,\n-\t\t\t\t CASE_LABEL (elt), case_node_pool);\n+      high = fold_convert (index_type, high);\n+      if (TREE_OVERFLOW (high))\n+\thigh = build_int_cst_wide (index_type,\n+\t\t\t\t   TREE_INT_CST_LOW (high),\n+\t\t\t\t   TREE_INT_CST_HIGH (high));\n+\n+      case_list = add_case_node (case_list, low, high, lab,\n+\t\t\t\t case_node_pool);\n     }\n-  BITMAP_FREE (label_bitmap);\n+  pointer_set_destroy (seen_labels);\n \n   /* cleanup_tree_cfg removes all SWITCH_EXPR with a single\n      destination, such as one with a default case only.\n      It also removes cases that are out of range for the switch\n      type, so we should never get a zero here.  */\n   gcc_assert (count > 0);\n \n-  before_case = start = get_last_insn ();\n+  rtx before_case = get_last_insn ();\n \n   /* Decide how to expand this switch.\n      The two options at this point are a dispatch table (casesi or\n@@ -2060,23 +2066,108 @@ expand_case (gimple stmt)\n \t\t\t      case_list, default_label,\n \t\t\t      minval, maxval, range);\n \n-  before_case = NEXT_INSN (before_case);\n-  end = get_last_insn ();\n-  reorder_insns (before_case, end, start);\n+  reorder_insns (NEXT_INSN (before_case), get_last_insn (), before_case);\n \n   free_temp_slots ();\n   free_alloc_pool (case_node_pool);\n }\n \n-/* Generate code to jump to LABEL if OP0 and OP1 are equal in mode MODE.  */\n+/* Expand the dispatch to a short decrement chain if there are few cases\n+   to dispatch to.  Likewise if neither casesi nor tablejump is available,\n+   or if flag_jump_tables is set.  Otherwise, expand as a casesi or a\n+   tablejump.  The index mode is always the mode of integer_type_node.\n+   Trap if no case matches the index.\n \n-static void\n-do_jump_if_equal (enum machine_mode mode, rtx op0, rtx op1, rtx label,\n-\t\t  int unsignedp)\n+   DISPATCH_INDEX is the index expression to switch on.  It should be a\n+   memory or register operand.\n+   \n+   DISPATCH_TABLE is a set of case labels.  The set should be sorted in\n+   ascending order, be contiguous, starting with value 0, and contain only\n+   single-valued case labels.  */\n+\n+void\n+expand_sjlj_dispatch_table (rtx dispatch_index,\n+\t\t\t    VEC(tree,heap) *dispatch_table)\n {\n-  do_compare_rtx_and_jump (op0, op1, EQ, unsignedp, mode,\n-\t\t\t   NULL_RTX, NULL_RTX, label, -1);\n+  tree index_type = integer_type_node;\n+  enum machine_mode index_mode = TYPE_MODE (index_type);\n+\n+  int ncases = VEC_length (tree, dispatch_table);\n+\n+  do_pending_stack_adjust ();\n+  rtx before_case = get_last_insn ();\n+\n+  /* Expand as a decrement-chain if there are 5 or fewer dispatch\n+     labels.  This covers more than 98% of the cases in libjava,\n+     and seems to be a reasonable compromise between the \"old way\"\n+     of expanding as a decision tree or dispatch table vs. the \"new\n+     way\" with decrement chain or dispatch table.  */\n+  if (VEC_length (tree, dispatch_table) <= 5\n+      || (!HAVE_casesi && !HAVE_tablejump)\n+      || !flag_jump_tables)\n+    {\n+      /* Expand the dispatch as a decrement chain:\n+\n+\t \"switch(index) {case 0: do_0; case 1: do_1; ...; case N: do_N;}\"\n+\n+\t ==>\n+\n+\t if (index == 0) do_0; else index--;\n+\t if (index == 0) do_1; else index--;\n+\t ...\n+\t if (index == 0) do_N; else index--;\n+\n+\t This is more efficient than a dispatch table on most machines.\n+\t The last \"index--\" is redundant but the code is trivially dead\n+\t and will be cleaned up by later passes.  */\n+      rtx index = copy_to_mode_reg (index_mode, dispatch_index);\n+      rtx zero = CONST0_RTX (index_mode);\n+      for (int i = 0; i < ncases; i++)\n+        {\n+\t  tree elt = VEC_index (tree, dispatch_table, i);\n+\t  rtx lab = label_rtx (CASE_LABEL (elt));\n+\t  do_jump_if_equal (index_mode, index, zero, lab, 0);\n+\t  force_expand_binop (index_mode, sub_optab,\n+\t\t\t      index, CONST1_RTX (index_mode),\n+\t\t\t      index, 0, OPTAB_DIRECT);\n+\t}\n+    }\n+  else\n+    {\n+      /* Similar to expand_case, but much simpler.  */\n+      struct case_node *case_list = 0;\n+      alloc_pool case_node_pool = create_alloc_pool (\"struct sjlj_case pool\",\n+\t\t\t\t\t\t     sizeof (struct case_node),\n+\t\t\t\t\t\t     ncases);\n+      tree index_expr = make_tree (index_type, dispatch_index);\n+      tree minval = build_int_cst (index_type, 0);\n+      tree maxval = CASE_LOW (VEC_last (tree, dispatch_table));\n+      tree range = maxval;\n+      rtx default_label = gen_label_rtx ();\n+\n+      for (int i = ncases - 1; i > 0; --i)\n+\t{\n+\t  tree elt = VEC_index (tree, dispatch_table, i);\n+\t  tree low = CASE_LOW (elt);\n+\t  tree lab = CASE_LABEL (elt);\n+\t  case_list = add_case_node (case_list, low, low, lab, case_node_pool);\n+\t}\n+\n+      emit_case_dispatch_table (index_expr, index_type,\n+\t\t\t\tcase_list, default_label,\n+\t\t\t\tminval, maxval, range);\n+      emit_label (default_label);\n+      free_alloc_pool (case_node_pool);\n+    }\n+\n+  /* Dispatching something not handled?  Trap!  */\n+  expand_builtin_trap ();\n+\n+  reorder_insns (NEXT_INSN (before_case), get_last_insn (), before_case);\n+\n+  free_temp_slots ();\n }\n+\n \f\n /* Take an ordered list of case nodes\n    and transform them into a near optimal binary tree,"}, {"sha": "f9c9a7f884e58a05491be76cfe16551d6bad0cce", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a1b6b7a98ebcbdfd4210edde604293e03ed6eba/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a1b6b7a98ebcbdfd4210edde604293e03ed6eba/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=9a1b6b7a98ebcbdfd4210edde604293e03ed6eba", "patch": "@@ -6117,7 +6117,6 @@ extern bool parse_input_constraint (const char **, int, int, int, int,\n \t\t\t\t    const char * const *, bool *, bool *);\n extern void expand_asm_stmt (gimple);\n extern tree resolve_asm_operand_names (tree, tree, tree, tree);\n-extern void expand_case (gimple);\n #ifdef HARD_CONST\n /* Silly ifdef to avoid having all includers depend on hard-reg-set.h.  */\n extern tree tree_overlaps_hard_reg_set (tree, HARD_REG_SET *);"}]}