{"sha": "c29f60c03cc219571c8c45ff8bb1b9b04efec478", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzI5ZjYwYzAzY2MyMTk1NzFjOGM0NWZmOGJiMWI5YjA0ZWZlYzQ3OA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@cygnus.co.uk", "date": "1999-11-23T12:10:36Z"}, "committer": {"name": "Bernd Schmidt", "email": "crux@gcc.gnu.org", "date": "1999-11-23T12:10:36Z"}, "message": "Copy propagation for hoisted mems in loop.c.\n\nFrom-SVN: r30638", "tree": {"sha": "75db5dcb11714d1d5aa0e60c25cd0a38b56c11d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/75db5dcb11714d1d5aa0e60c25cd0a38b56c11d8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c29f60c03cc219571c8c45ff8bb1b9b04efec478", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c29f60c03cc219571c8c45ff8bb1b9b04efec478", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c29f60c03cc219571c8c45ff8bb1b9b04efec478", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c29f60c03cc219571c8c45ff8bb1b9b04efec478/comments", "author": null, "committer": null, "parents": [{"sha": "429d7c746fa51cbe5c4c5a096aa8952d59b63cd8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/429d7c746fa51cbe5c4c5a096aa8952d59b63cd8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/429d7c746fa51cbe5c4c5a096aa8952d59b63cd8"}], "stats": {"total": 124, "additions": 120, "deletions": 4}, "files": [{"sha": "237bf77d42268a92896f3161b15590e301cd4ae0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c29f60c03cc219571c8c45ff8bb1b9b04efec478/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c29f60c03cc219571c8c45ff8bb1b9b04efec478/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c29f60c03cc219571c8c45ff8bb1b9b04efec478", "patch": "@@ -1,3 +1,11 @@\n+1999-11-23  Bernd Schmidt  <bernds@cygnus.co.uk>\n+\n+\t* loop.c: Include \"basic-block.h\".\n+\t(try_copy_prop, replace_loop_reg): New functions.\n+\t(load_mems): Detect registers that just hold copies of the hoisted\n+\tmem, and call try_copy_prop to eliminate them.\n+\t* Makefile.in (loop.o): Update dependencies.\n+\n Tue Nov 23 01:03:29 1999  Hans-Peter Nilsson  <hp@axis.com>\n \n \t* Makefile.in (gencheck.o): Depend on gencheck.h."}, {"sha": "771c22c174b504d6c3f00701604a2e1edef8eb88", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c29f60c03cc219571c8c45ff8bb1b9b04efec478/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c29f60c03cc219571c8c45ff8bb1b9b04efec478/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=c29f60c03cc219571c8c45ff8bb1b9b04efec478", "patch": "@@ -1551,7 +1551,7 @@ profile.o : profile.c $(CONFIG_H) system.h $(RTL_H) flags.h insn-flags.h \\\n    ggc.h\n loop.o : loop.c $(CONFIG_H) system.h $(RTL_H) flags.h loop.h insn-config.h \\\n    insn-flags.h $(REGS_H) hard-reg-set.h $(RECOG_H) $(EXPR_H) real.h \\\n-   function.h toplev.h varray.h except.h\n+   $(BASIC_BLOCK_H) function.h toplev.h varray.h except.h\n unroll.o : unroll.c $(CONFIG_H) system.h $(RTL_H) insn-config.h function.h \\\n    integrate.h $(REGS_H) $(RECOG_H) flags.h $(EXPR_H) loop.h toplev.h varray.h\n flow.o : flow.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h insn-config.h \\"}, {"sha": "8aeda6e98e58665eae17fb93564e0ebbdecdd519", "filename": "gcc/loop.c", "status": "modified", "additions": 111, "deletions": 3, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c29f60c03cc219571c8c45ff8bb1b9b04efec478/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c29f60c03cc219571c8c45ff8bb1b9b04efec478/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=c29f60c03cc219571c8c45ff8bb1b9b04efec478", "patch": "@@ -41,6 +41,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"obstack.h\"\n #include \"function.h\"\n #include \"expr.h\"\n+#include \"basic-block.h\"\n #include \"insn-config.h\"\n #include \"insn-flags.h\"\n #include \"regs.h\"\n@@ -337,6 +338,8 @@ static void load_mems_and_recount_loop_regs_set PROTO((rtx, rtx, rtx,\n static void load_mems PROTO((rtx, rtx, rtx, rtx));\n static int insert_loop_mem PROTO((rtx *, void *));\n static int replace_loop_mem PROTO((rtx *, void *));\n+static int replace_loop_reg PROTO((rtx *, void *));\n+static void try_copy_prop PROTO((rtx, rtx, rtx, rtx, int));\n static int replace_label PROTO((rtx *, void *));\n \n typedef struct rtx_and_int {\n@@ -9717,6 +9720,7 @@ load_mems (scan_start, end, loop_top, start)\n   rtx end_label = NULL_RTX;\n   /* Nonzero if the next instruction may never be executed.  */\n   int next_maybe_never = 0;\n+  int last_max_reg = max_reg_num ();\n \n   if (loop_mems_idx == 0)\n     return;\n@@ -9756,6 +9760,7 @@ load_mems (scan_start, end, loop_top, start)\n   /* Actually move the MEMs.  */\n   for (i = 0; i < loop_mems_idx; ++i) \n     {\n+      regset_head copies;\n       int written = 0;\n       rtx reg;\n       rtx mem = loop_mems[i].mem;\n@@ -9817,6 +9822,8 @@ load_mems (scan_start, end, loop_top, start)\n \t   loop, but later discovered that we could not.  */\n \tcontinue;\n \n+      INIT_REG_SET (&copies);\n+\n       /* Allocate a pseudo for this MEM.  We set REG_USERVAR_P in\n \t order to keep scan_loop from moving stores to this MEM\n \t out of the loop just because this REG is neither a\n@@ -9827,21 +9834,45 @@ load_mems (scan_start, end, loop_top, start)\n \n       /* Now, replace all references to the MEM with the\n \t corresponding pesudos.  */\n+      maybe_never = 0;\n       for (p = next_insn_in_loop (scan_start, scan_start, end, loop_top);\n \t   p != NULL_RTX;\n \t   p = next_insn_in_loop (p, scan_start, end, loop_top))\n \t{\n \t  rtx_and_int ri;\n-\t  ri.r = p;\n-\t  ri.i = i;\n-\t  for_each_rtx (&p, replace_loop_mem, &ri);\n+\t  rtx set;\n+\n+\t  if (GET_RTX_CLASS (GET_CODE (p)) == 'i')\n+\t    {\n+\t      /* See if this copies the mem into a register that isn't\n+\t\t modified afterwards.  We'll try to do copy propagation\n+\t\t a little further on.  */\n+\t      set = single_set (p);\n+\t      if (set\n+\t\t  /* @@@ This test is _way_ too conservative.  */\n+\t\t  && ! maybe_never\n+\t\t  && GET_CODE (SET_DEST (set)) == REG\n+\t\t  && REGNO (SET_DEST (set)) >= FIRST_PSEUDO_REGISTER\n+\t\t  && REGNO (SET_DEST (set)) < last_max_reg\n+\t\t  && VARRAY_INT (n_times_set, REGNO (SET_DEST (set))) == 1\n+\t\t  && rtx_equal_p (SET_SRC (set), loop_mems[i].mem))\n+\t\tSET_REGNO_REG_SET (&copies, REGNO (SET_DEST (set)));\n+\t      ri.r = p;\n+\t      ri.i = i;\n+\t      for_each_rtx (&p, replace_loop_mem, &ri);\n+\t    }\n+\n+\t  if (GET_CODE (p) == CODE_LABEL\n+\t      || GET_CODE (p) == JUMP_INSN)\n+\t    maybe_never = 1;\n \t}\n \n       if (! apply_change_group ())\n \t/* We couldn't replace all occurrences of the MEM.  */\n \tloop_mems[i].optimize = 0;\n       else\n \t{\n+\t  int j;\n \t  rtx set;\n \n \t  /* Load the memory immediately before START, which is\n@@ -9874,6 +9905,16 @@ load_mems (scan_start, end, loop_top, start)\n \t      print_rtl (loop_dump_stream, mem);\n \t      fputc ('\\n', loop_dump_stream);\n \t    }\n+\n+\t  /* Attempt a bit of copy propagation.  This helps untangle the\n+\t     data flow, and enables {basic,general}_induction_var to find\n+\t     more bivs/givs.  */\n+\t  EXECUTE_IF_SET_IN_REG_SET\n+\t    (&copies, FIRST_PSEUDO_REGISTER, j,\n+\t     {\n+\t       try_copy_prop (scan_start, loop_top, end, loop_mems[i].reg, j);\n+\t     });\n+\t  CLEAR_REG_SET (&copies);\n \t}\n     }\n \n@@ -9901,6 +9942,51 @@ load_mems (scan_start, end, loop_top, start)\n     }\n }\n \n+/* Try to replace every occurrence of pseudo REGNO with REPLACEMENT.\n+   There must be exactly one insn that sets this pseudo; it will be\n+   deleted if all replacements succeed and we can prove that the register\n+   is not used after the loop.\n+   The arguments SCAN_START, LOOP_TOP and END are as in load_mems.  */\n+static void\n+try_copy_prop (scan_start, loop_top, end, replacement, regno)\n+     rtx scan_start, loop_top, end, replacement;\n+     int regno;\n+{\n+  rtx init_insn = 0;\n+  rtx insn;\n+  for (insn = next_insn_in_loop (scan_start, scan_start, end, loop_top);\n+       insn != NULL_RTX;\n+       insn = next_insn_in_loop (insn, scan_start, end, loop_top))\n+    {\n+      rtx set;\n+      rtx array[3] = { regno_reg_rtx[regno], replacement, insn };\n+      if (GET_RTX_CLASS (GET_CODE (insn)) != 'i')\n+\tcontinue;\n+      set = single_set (insn);\n+      if (set\n+\t  && GET_CODE (SET_DEST (set)) == REG\n+\t  && REGNO (SET_DEST (set)) == regno)\n+\t{\n+\t  if (init_insn)\n+\t    abort ();\n+\t  init_insn = insn;\n+\t}\n+      for_each_rtx (&insn, replace_loop_reg, array);\n+    }\n+  if (! init_insn)\n+    abort ();\n+  if (apply_change_group ())\n+    {\n+      if (uid_luid[REGNO_LAST_UID (regno)] < INSN_LUID (end))\n+\t{\n+\t  PUT_CODE (init_insn, NOTE);\n+\t  NOTE_LINE_NUMBER (init_insn) = NOTE_INSN_DELETED;\n+\t}\n+      if (loop_dump_stream)\n+\tfprintf (loop_dump_stream, \"  Replaced reg %d.\\n\", regno);\n+    }\n+}\n+\n /* Replace MEM with its associated pseudo register.  This function is\n    called from load_mems via for_each_rtx.  DATA is actually an\n    rtx_and_int * describing the instruction currently being scanned\n@@ -9949,6 +10035,28 @@ replace_loop_mem (mem, data)\n   return 0;\n }\n \n+/* Replace one register with another.  Called through for_each_rtx; PX points\n+   to the rtx being scanned.  DATA is actually an array of three rtx's; the\n+   first one is the one to be replaced, and the second one the replacement.\n+   The third one is the current insn.  */\n+\n+static int\n+replace_loop_reg (px, data)\n+     rtx *px;\n+     void *data;\n+{\n+  rtx x = *px;\n+  rtx *array = (rtx *)data;\n+\n+  if (x == NULL_RTX)\n+    return 0;\n+\n+  if (x == array[0])\n+    validate_change (array[2], px, array[1], 1);\n+\n+  return 0;\n+}\n+\n /* Replace occurrences of the old exit label for the loop with the new\n    one.  DATA is an rtx_pair containing the old and new labels,\n    respectively.  */"}]}