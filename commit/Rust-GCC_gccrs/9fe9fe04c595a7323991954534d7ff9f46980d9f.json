{"sha": "9fe9fe04c595a7323991954534d7ff9f46980d9f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWZlOWZlMDRjNTk1YTczMjM5OTE5NTQ1MzRkN2ZmOWY0Njk4MGQ5Zg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2009-04-17T14:25:57Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2009-04-17T14:25:57Z"}, "message": "tree-ssa-ccp.c (struct fold_stmt_r_data): Remove.\n\n2009-04-17  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-ssa-ccp.c (struct fold_stmt_r_data): Remove.\n\t(fold_stmt_r): Likewise.\n\t(maybe_fold_reference): New function.\n\t(fold_gimple_assign): Handle cases fold_stmt_r did.\n\t(fold_stmt): Do not use fold_stmt_r.\n\t(fold_stmt_inplace): Likewise.\n\nFrom-SVN: r146271", "tree": {"sha": "22cb5299cdd32bafb99cedcb1fe6228262b81635", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/22cb5299cdd32bafb99cedcb1fe6228262b81635"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9fe9fe04c595a7323991954534d7ff9f46980d9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fe9fe04c595a7323991954534d7ff9f46980d9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fe9fe04c595a7323991954534d7ff9f46980d9f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fe9fe04c595a7323991954534d7ff9f46980d9f/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "03b6478770fdc7a2db42653bd8532786fdc642bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03b6478770fdc7a2db42653bd8532786fdc642bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03b6478770fdc7a2db42653bd8532786fdc642bf"}], "stats": {"total": 354, "additions": 139, "deletions": 215}, "files": [{"sha": "0908a3f92fc9b39eae0c3d8fabc941fcc2192ff3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fe9fe04c595a7323991954534d7ff9f46980d9f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fe9fe04c595a7323991954534d7ff9f46980d9f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9fe9fe04c595a7323991954534d7ff9f46980d9f", "patch": "@@ -1,3 +1,12 @@\n+2009-04-17  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-ssa-ccp.c (struct fold_stmt_r_data): Remove.\n+\t(fold_stmt_r): Likewise.\n+\t(maybe_fold_reference): New function.\n+\t(fold_gimple_assign): Handle cases fold_stmt_r did.\n+\t(fold_stmt): Do not use fold_stmt_r.\n+\t(fold_stmt_inplace): Likewise.\n+\n 2009-04-17  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-ssa-dom.c (gimple_assign_unary_useless_conversion_p): Remove."}, {"sha": "0bbc0f04325f9dd500feadaa7349cb74b244173a", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 130, "deletions": 215, "changes": 345, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fe9fe04c595a7323991954534d7ff9f46980d9f/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fe9fe04c595a7323991954534d7ff9f46980d9f/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=9fe9fe04c595a7323991954534d7ff9f46980d9f", "patch": "@@ -1616,7 +1616,7 @@ struct gimple_opt_pass pass_ccp =\n };\n \n \n-/* A subroutine of fold_stmt_r.  Attempts to fold *(A+O) to A[X].\n+/* A subroutine of fold_stmt.  Attempts to fold *(A+O) to A[X].\n    BASE is an array type.  OFFSET is a byte displacement.  ORIG_TYPE\n    is the desired result type.  */\n \n@@ -2001,7 +2001,7 @@ maybe_fold_offset_to_address (tree addr, tree offset, tree orig_type)\n   return NULL_TREE;\n }\n \n-/* A subroutine of fold_stmt_r.  Attempt to simplify *(BASE+OFFSET).\n+/* A subroutine of fold_stmt.  Attempt to simplify *(BASE+OFFSET).\n    Return the simplified expression, or NULL if nothing could be done.  */\n \n static tree\n@@ -2220,180 +2220,64 @@ maybe_fold_stmt_addition (tree res_type, tree op0, tree op1)\n   return t;\n }\n \n-/* For passing state through walk_tree into fold_stmt_r and its\n-   children.  */\n-\n-struct fold_stmt_r_data\n-{\n-  gimple stmt;\n-  bool *changed_p;\n-  bool *inside_addr_expr_p;\n-};\n-\n-/* Subroutine of fold_stmt called via walk_tree.  We perform several\n-   simplifications of EXPR_P, mostly having to do with pointer arithmetic.  */\n+/* Subroutine of fold_stmt.  We perform several simplifications of the\n+   memory reference tree EXPR and make sure to re-gimplify them properly\n+   after propagation of constant addresses.  IS_LHS is true if the\n+   reference is supposed to be an lvalue.  */\n \n static tree\n-fold_stmt_r (tree *expr_p, int *walk_subtrees, void *data)\n+maybe_fold_reference (tree expr, bool is_lhs)\n {\n-  struct walk_stmt_info *wi = (struct walk_stmt_info *) data;\n-  struct fold_stmt_r_data *fold_stmt_r_data;\n-  bool *inside_addr_expr_p;\n-  bool *changed_p;\n-  tree expr = *expr_p, t;\n-  bool volatile_p = TREE_THIS_VOLATILE (expr);\n+  tree *t = &expr;\n \n-  fold_stmt_r_data = (struct fold_stmt_r_data *) wi->info;\n-  inside_addr_expr_p = fold_stmt_r_data->inside_addr_expr_p;\n-  changed_p = fold_stmt_r_data->changed_p;\n+  if (TREE_CODE (expr) == ARRAY_REF\n+      && !is_lhs)\n+    {\n+      tree tem = fold_read_from_constant_string (expr);\n+      if (tem)\n+\treturn tem;\n+    }\n \n-  /* ??? It'd be nice if walk_tree had a pre-order option.  */\n-  switch (TREE_CODE (expr))\n+  /* ???  We might want to open-code the relevant remaining cases\n+     to avoid using the generic fold.  */\n+  if (handled_component_p (*t)\n+      && CONSTANT_CLASS_P (TREE_OPERAND (*t, 0)))\n     {\n-    case INDIRECT_REF:\n-      t = walk_tree (&TREE_OPERAND (expr, 0), fold_stmt_r, data, NULL);\n-      if (t)\n-\treturn t;\n-      *walk_subtrees = 0;\n+      tree tem = fold (*t);\n+      if (tem != *t)\n+\treturn tem;\n+    }\n+\n+  while (handled_component_p (*t))\n+    t = &TREE_OPERAND (*t, 0);\n \n-      t = maybe_fold_stmt_indirect (expr, TREE_OPERAND (expr, 0),\n-\t\t\t\t    integer_zero_node);\n+  if (TREE_CODE (*t) == INDIRECT_REF)\n+    {\n+      tree tem = maybe_fold_stmt_indirect (*t, TREE_OPERAND (*t, 0),\n+\t\t\t\t\t   integer_zero_node);\n       /* Avoid folding *\"abc\" = 5 into 'a' = 5.  */\n-      if (wi->is_lhs && t && TREE_CODE (t) == INTEGER_CST)\n-\tt = NULL_TREE;\n-      if (!t\n-\t  && TREE_CODE (TREE_OPERAND (expr, 0)) == ADDR_EXPR)\n+      if (is_lhs && tem && CONSTANT_CLASS_P (tem))\n+\ttem = NULL_TREE;\n+      if (!tem\n+\t  && TREE_CODE (TREE_OPERAND (*t, 0)) == ADDR_EXPR)\n \t/* If we had a good reason for propagating the address here,\n \t   make sure we end up with valid gimple.  See PR34989.  */\n-\tt = TREE_OPERAND (TREE_OPERAND (expr, 0), 0);\n-      break;\n-\n-    case NOP_EXPR:\n-      t = walk_tree (&TREE_OPERAND (expr, 0), fold_stmt_r, data, NULL);\n-      if (t)\n-\treturn t;\n-      *walk_subtrees = 0;\n-\n-      if (POINTER_TYPE_P (TREE_TYPE (expr))\n-          && POINTER_TYPE_P (TREE_TYPE (TREE_TYPE (expr)))\n-\t  && POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (expr, 0)))\n-\t  && (t = maybe_fold_offset_to_address (TREE_OPERAND (expr, 0),\n-\t\t\t\t\t\tinteger_zero_node,\n-\t\t\t\t\t\tTREE_TYPE (TREE_TYPE (expr)))))\n-\treturn t;\n-      break;\n-\n-      /* ??? Could handle more ARRAY_REFs here, as a variant of INDIRECT_REF.\n-\t We'd only want to bother decomposing an existing ARRAY_REF if\n-\t the base array is found to have another offset contained within.\n-\t Otherwise we'd be wasting time.  */\n-    case ARRAY_REF:\n-      /* If we are not processing expressions found within an\n-\t ADDR_EXPR, then we can fold constant array references.\n-\t Don't fold on LHS either, to avoid folding \"abc\"[0] = 5\n-\t into 'a' = 5.  */\n-      if (!*inside_addr_expr_p && !wi->is_lhs)\n-\tt = fold_read_from_constant_string (expr);\n-      else\n-\tt = NULL;\n-      break;\n-\n-    case ADDR_EXPR:\n-      *inside_addr_expr_p = true;\n-      t = walk_tree (&TREE_OPERAND (expr, 0), fold_stmt_r, data, NULL);\n-      *inside_addr_expr_p = false;\n-      if (t)\n-\treturn t;\n-      *walk_subtrees = 0;\n-\n-      /* Make sure the value is properly considered constant, and so gets\n-\t propagated as expected.  */\n-      if (*changed_p)\n-        recompute_tree_invariant_for_addr_expr (expr);\n-      return NULL_TREE;\n-\n-    case COMPONENT_REF:\n-      t = walk_tree (&TREE_OPERAND (expr, 0), fold_stmt_r, data, NULL);\n-      if (t)\n-        return t;\n-      *walk_subtrees = 0;\n-\n-      /* Make sure the FIELD_DECL is actually a field in the type on the lhs.\n-\t We've already checked that the records are compatible, so we should\n-\t come up with a set of compatible fields.  */\n-      {\n-\ttree expr_record = TREE_TYPE (TREE_OPERAND (expr, 0));\n-\ttree expr_field = TREE_OPERAND (expr, 1);\n-\n-        if (DECL_FIELD_CONTEXT (expr_field) != TYPE_MAIN_VARIANT (expr_record))\n-\t  {\n-\t    expr_field = find_compatible_field (expr_record, expr_field);\n-\t    TREE_OPERAND (expr, 1) = expr_field;\n-\t  }\n-      }\n-      break;\n-\n-    case TARGET_MEM_REF:\n-      t = maybe_fold_tmr (expr);\n-      break;\n-\n-    case POINTER_PLUS_EXPR:\n-      t = walk_tree (&TREE_OPERAND (expr, 0), fold_stmt_r, data, NULL);\n-      if (t)\n-        return t;\n-      t = walk_tree (&TREE_OPERAND (expr, 1), fold_stmt_r, data, NULL);\n-      if (t)\n-        return t;\n-      *walk_subtrees = 0;\n-\n-      t = maybe_fold_stmt_addition (TREE_TYPE (expr),\n-                                    TREE_OPERAND (expr, 0),\n-                                    TREE_OPERAND (expr, 1));\n-      break;\n-\n-    case COND_EXPR:\n-      if (COMPARISON_CLASS_P (TREE_OPERAND (expr, 0)))\n-        {\n-\t  tree op0 = TREE_OPERAND (expr, 0);\n-          tree tem;\n-\t  bool set;\n-\n-\t  fold_defer_overflow_warnings ();\n-\t  tem = fold_binary (TREE_CODE (op0), TREE_TYPE (op0),\n-\t\t\t     TREE_OPERAND (op0, 0),\n-\t\t\t     TREE_OPERAND (op0, 1));\n-          /* This is actually a conditional expression, not a GIMPLE\n-             conditional statement, however, the valid_gimple_rhs_p\n-             test still applies.  */\n-\t  set = tem && is_gimple_condexpr (tem) && valid_gimple_rhs_p (tem);\n-\t  fold_undefer_overflow_warnings (set, fold_stmt_r_data->stmt, 0);\n-\t  if (set)\n-\t    {\n-              COND_EXPR_COND (expr) = tem;\n-\t      t = expr;\n-\t      break;\n-\t    }\n-        }\n-      return NULL_TREE;\n-\n-    default:\n-      return NULL_TREE;\n-    }\n+\ttem = TREE_OPERAND (TREE_OPERAND (*t, 0), 0);\n \n-  if (t)\n-    {\n-      /* Preserve volatileness of the original expression.\n-\t We can end up with a plain decl here which is shared\n-\t and we shouldn't mess with its flags.  */\n-      if (!SSA_VAR_P (t))\n-\tTREE_THIS_VOLATILE (t) = volatile_p;\n-      *expr_p = t;\n-      *changed_p = true;\n+      if (tem)\n+\t{\n+\t  *t = tem;\n+\t  tem = maybe_fold_reference (expr, is_lhs);\n+\t  if (tem)\n+\t    return tem;\n+\t  return expr;\n+\t}\n     }\n \n   return NULL_TREE;\n }\n \n+\n /* Return the string length, maximum string length or maximum value of\n    ARG in LENGTH.\n    If ARG is an SSA name variable, follow its use-def chains.  If LENGTH\n@@ -2713,23 +2597,61 @@ fold_gimple_assign (gimple_stmt_iterator *si)\n   gimple stmt = gsi_stmt (*si);\n   enum tree_code subcode = gimple_assign_rhs_code (stmt);\n \n-  tree result = NULL;\n+  tree result = NULL_TREE;\n \n   switch (get_gimple_rhs_class (subcode))\n     {\n     case GIMPLE_SINGLE_RHS:\n       {\n         tree rhs = gimple_assign_rhs1 (stmt);\n-        \n+\n         /* Try to fold a conditional expression.  */\n         if (TREE_CODE (rhs) == COND_EXPR)\n           {\n-            tree temp = fold (COND_EXPR_COND (rhs));\n-            if (temp != COND_EXPR_COND (rhs))\n-              result = fold_build3 (COND_EXPR, TREE_TYPE (rhs), temp,\n-                                    COND_EXPR_THEN (rhs), COND_EXPR_ELSE (rhs));\n+\t    tree op0 = COND_EXPR_COND (rhs);\n+\t    tree tem;\n+\t    bool set = false;\n+\n+\t    if (COMPARISON_CLASS_P (op0))\n+\t      {\n+\t\tfold_defer_overflow_warnings ();\n+\t\ttem = fold_binary (TREE_CODE (op0), TREE_TYPE (op0),\n+\t\t\t\t   TREE_OPERAND (op0, 0),\n+\t\t\t\t   TREE_OPERAND (op0, 1));\n+\t\t/* This is actually a conditional expression, not a GIMPLE\n+\t\t   conditional statement, however, the valid_gimple_rhs_p\n+\t\t   test still applies.  */\n+\t\tset = (tem && is_gimple_condexpr (tem)\n+\t\t       && valid_gimple_rhs_p (tem));\n+\t\tfold_undefer_overflow_warnings (set, stmt, 0);\n+\t      }\n+\t    else if (is_gimple_min_invariant (op0))\n+\t      {\n+\t\ttem = op0;\n+\t\tset = true;\n+\t      }\n+\t    else\n+\t      return NULL_TREE;\n+\n+\t    if (set)\n+\t      result = fold_build3 (COND_EXPR, TREE_TYPE (rhs), tem,\n+\t\t\t\t    COND_EXPR_THEN (rhs), COND_EXPR_ELSE (rhs));\n           }\n \n+\telse if (TREE_CODE (rhs) == TARGET_MEM_REF)\n+\t  return maybe_fold_tmr (rhs);\n+\n+\telse if (REFERENCE_CLASS_P (rhs))\n+\t  return maybe_fold_reference (rhs, false);\n+\n+\telse if (TREE_CODE (rhs) == ADDR_EXPR)\n+\t  {\n+\t    tree tem = maybe_fold_reference (TREE_OPERAND (rhs, 0), true);\n+\t    if (tem)\n+\t      result = fold_convert (TREE_TYPE (rhs),\n+\t\t\t\t     build_fold_addr_expr (tem));\n+\t  }\n+\n         /* If we couldn't fold the RHS, hand over to the generic\n            fold routines.  */\n         if (result == NULL_TREE)\n@@ -2742,11 +2664,8 @@ fold_gimple_assign (gimple_stmt_iterator *si)\n \n         if (result != rhs && valid_gimple_rhs_p (result))\n \t  return result;\n-        else\n-          /* It is possible that fold_stmt_r simplified the RHS.\n-             Make sure that the subcode of this statement still\n-             reflects the principal operator of the rhs operand. */\n-          return rhs;\n+\n+\treturn NULL_TREE;\n       }\n       break;\n \n@@ -2919,32 +2838,17 @@ fold_gimple_call (gimple_stmt_iterator *gsi)\n \n /* Fold the statement pointed to by GSI.  In some cases, this function may\n    replace the whole statement with a new one.  Returns true iff folding\n-   makes any changes.  */\n+   makes any changes.\n+   The statement pointed to by GSI should be in valid gimple form but may\n+   be in unfolded state as resulting from for example constant propagation\n+   which can produce *&x = 0.  */\n \n bool\n fold_stmt (gimple_stmt_iterator *gsi)\n {\n-  tree res;\n-  struct fold_stmt_r_data fold_stmt_r_data;\n-  struct walk_stmt_info wi;\n-\n   bool changed = false;\n-  bool inside_addr_expr = false;\n-\n   gimple stmt = gsi_stmt (*gsi);\n \n-  fold_stmt_r_data.stmt = stmt;\n-  fold_stmt_r_data.changed_p = &changed;\n-  fold_stmt_r_data.inside_addr_expr_p = &inside_addr_expr;\n-\n-  memset (&wi, 0, sizeof (wi));\n-  wi.info = &fold_stmt_r_data;\n-\n-  /* Fold the individual operands.\n-     For example, fold instances of *&VAR into VAR, etc.  */\n-  res = walk_gimple_op (stmt, fold_stmt_r, &wi);\n-  gcc_assert (!res);\n-\n   /* Fold the main computation performed by the statement.  */\n   switch (gimple_code (stmt))\n     {\n@@ -2956,7 +2860,6 @@ fold_stmt (gimple_stmt_iterator *gsi)\n \t    gimple_assign_set_rhs_from_tree (gsi, new_rhs);\n \t    changed = true;\n \t  }\n-\tstmt = gsi_stmt (*gsi);\n \tbreak;\n       }\n     case GIMPLE_COND:\n@@ -2972,42 +2875,39 @@ fold_stmt (gimple_stmt_iterator *gsi)\n       break;\n     }\n \n+  stmt = gsi_stmt (*gsi);\n+\n+  /* Fold *& on the lhs.  */\n+  if (gimple_has_lhs (stmt))\n+    {\n+      tree lhs = gimple_get_lhs (stmt);\n+      if (lhs && REFERENCE_CLASS_P (lhs))\n+\t{\n+\t  tree new_lhs = maybe_fold_reference (lhs, true);\n+\t  if (new_lhs)\n+\t    {\n+\t      gimple_set_lhs (stmt, new_lhs);\n+\t      changed = true;\n+\t    }\n+\t}\n+    }\n+\n   return changed;\n }\n \n /* Perform the minimal folding on statement STMT.  Only operations like\n    *&x created by constant propagation are handled.  The statement cannot\n    be replaced with a new one.  Return true if the statement was\n-   changed, false otherwise.  */\n+   changed, false otherwise.\n+   The statement STMT should be in valid gimple form but may\n+   be in unfolded state as resulting from for example constant propagation\n+   which can produce *&x = 0.  */\n \n bool\n fold_stmt_inplace (gimple stmt)\n {\n-  tree res;\n-  struct fold_stmt_r_data fold_stmt_r_data;\n-  struct walk_stmt_info wi;\n   gimple_stmt_iterator si;\n-\n   bool changed = false;\n-  bool inside_addr_expr = false;\n-\n-  fold_stmt_r_data.stmt = stmt;\n-  fold_stmt_r_data.changed_p = &changed;\n-  fold_stmt_r_data.inside_addr_expr_p = &inside_addr_expr;\n-\n-  memset (&wi, 0, sizeof (wi));\n-  wi.info = &fold_stmt_r_data;\n-\n-  /* Fold the individual operands.\n-     For example, fold instances of *&VAR into VAR, etc.\n-\n-     It appears that, at one time, maybe_fold_stmt_indirect\n-     would cause the walk to return non-null in order to\n-     signal that the entire statement should be replaced with\n-     a call to _builtin_trap.  This functionality is currently\n-     disabled, as noted in a FIXME, and cannot be supported here.  */\n-  res = walk_gimple_op (stmt, fold_stmt_r, &wi);\n-  gcc_assert (!res);\n \n   /* Fold the main computation performed by the statement.  */\n   switch (gimple_code (stmt))\n@@ -3036,6 +2936,21 @@ fold_stmt_inplace (gimple stmt)\n       break;\n     }\n \n+  /* Fold *& on the lhs.  */\n+  if (gimple_has_lhs (stmt))\n+    {\n+      tree lhs = gimple_get_lhs (stmt);\n+      if (lhs && REFERENCE_CLASS_P (lhs))\n+\t{\n+\t  tree new_lhs = maybe_fold_reference (lhs, true);\n+\t  if (new_lhs)\n+\t    {\n+\t      gimple_set_lhs (stmt, new_lhs);\n+\t      changed = true;\n+\t    }\n+\t}\n+    }\n+\n   return changed;\n }\n "}]}