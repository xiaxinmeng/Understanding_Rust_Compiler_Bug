{"sha": "964512791e121b627ced9b14021856ca34121bc0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTY0NTEyNzkxZTEyMWI2MjdjZWQ5YjE0MDIxODU2Y2EzNDEyMWJjMA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-02-07T02:27:05Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-02-07T02:27:05Z"}, "message": "re PR ipa/59469 (LLVM build failure with gcc LTO)\n\n\n\tPR ipa/59469\n\t* lto-cgraph.c (lto_output_node): Use\n\tsymtab_get_symbol_partitioning_class.\n\t(lto_output_varpool_node): likewise.\n\t(symtab_get_symbol_partitioning_class): Move here from\n\tlto/lto-partition.c\n\t* cgraph.h (symbol_partitioning_class): Likewise.\n\t(symtab_get_symbol_partitioning_class): Declare.\n\n\t* lto-partition.c (symbol_class): Move to cgraph.h\n\t(get_symbol_class): Move to symtab.c\n\t(add_references_to_partition, add_symbol_to_partition_1,\n\tlto_max_map, lto_1_to_1_map, lto_balanced_map,\n\tlto_promote_cross_file_statics): Update.\n\nFrom-SVN: r207589", "tree": {"sha": "63a0d48e093baf01eaef591a754404df1020cbe3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/63a0d48e093baf01eaef591a754404df1020cbe3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/964512791e121b627ced9b14021856ca34121bc0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/964512791e121b627ced9b14021856ca34121bc0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/964512791e121b627ced9b14021856ca34121bc0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/964512791e121b627ced9b14021856ca34121bc0/comments", "author": null, "committer": null, "parents": [{"sha": "b3bb0eb9c0a89c9ec197f2f0a7c2e6a8d3f004af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3bb0eb9c0a89c9ec197f2f0a7c2e6a8d3f004af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3bb0eb9c0a89c9ec197f2f0a7c2e6a8d3f004af"}], "stats": {"total": 134, "additions": 47, "deletions": 87}, "files": [{"sha": "32b1ee17fa3e042fb68787205ae363b84f4a78d9", "filename": "gcc/cgraph.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/964512791e121b627ced9b14021856ca34121bc0/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/964512791e121b627ced9b14021856ca34121bc0/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=964512791e121b627ced9b14021856ca34121bc0", "patch": "@@ -704,6 +704,20 @@ extern GTY(()) struct asm_node *asm_nodes;\n extern GTY(()) int symtab_order;\n extern bool cpp_implicit_aliases_done;\n \n+/* Classifcation of symbols WRT partitioning.  */\n+enum symbol_partitioning_class\n+{\n+   /* External declarations are ignored by partitioning algorithms and they are\n+      added into the boundary later via compute_ltrans_boundary.  */\n+   SYMBOL_EXTERNAL,\n+   /* Partitioned symbols are pur into one of partitions.  */\n+   SYMBOL_PARTITION,\n+   /* Duplicated symbols (such as comdat or constant pool references) are\n+      copied into every node needing them via add_symbol_to_partition.  */\n+   SYMBOL_DUPLICATE\n+};\n+\n+\n /* In symtab.c  */\n void symtab_register_node (symtab_node *);\n void symtab_unregister_node (symtab_node *);\n@@ -734,6 +748,7 @@ bool symtab_for_node_and_aliases (symtab_node *,\n symtab_node *symtab_nonoverwritable_alias (symtab_node *);\n enum availability symtab_node_availability (symtab_node *);\n bool symtab_semantically_equivalent_p (symtab_node *, symtab_node *);\n+enum symbol_partitioning_class symtab_get_symbol_partitioning_class (symtab_node *);\n \n /* In cgraph.c  */\n void dump_cgraph (FILE *);"}, {"sha": "ef3890db981f1dc61c2a2f24549e464bbe8339e7", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/964512791e121b627ced9b14021856ca34121bc0/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/964512791e121b627ced9b14021856ca34121bc0/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=964512791e121b627ced9b14021856ca34121bc0", "patch": "@@ -417,7 +417,8 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n      Cherry-picked nodes:  These are nodes we pulled from other\n      translation units into SET during IPA-inlining.  We make them as\n      local static nodes to prevent clashes with other local statics.  */\n-  if (boundary_p && node->analyzed && !DECL_EXTERNAL (node->decl))\n+  if (boundary_p && node->analyzed\n+      && symtab_get_symbol_partitioning_class (node) == SYMBOL_PARTITION)\n     {\n       /* Inline clones can not be part of boundary.  \n          gcc_assert (!node->global.inlined_to);  \n@@ -501,8 +502,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   bp_pack_value (&bp, node->unique_name, 1);\n   bp_pack_value (&bp, node->address_taken, 1);\n   bp_pack_value (&bp, tag == LTO_symtab_analyzed_node\n-\t\t && !DECL_EXTERNAL (node->decl)\n-\t\t && !DECL_COMDAT (node->decl)\n+\t\t && symtab_get_symbol_partitioning_class (node) == SYMBOL_PARTITION\n \t\t && (reachable_from_other_partition_p (node, encoder)\n \t\t     || referenced_from_other_partition_p (&node->ref_list,\n \t\t\t\t\t\t\t   encoder)), 1);\n@@ -569,9 +569,7 @@ lto_output_varpool_node (struct lto_simple_output_block *ob, varpool_node *node,\n   /* Constant pool initializers can be de-unified into individual ltrans units.\n      FIXME: Alternatively at -Os we may want to avoid generating for them the local\n      labels and share them across LTRANS partitions.  */\n-  if (DECL_IN_CONSTANT_POOL (node->decl)\n-      && !DECL_EXTERNAL (node->decl)\n-      && !DECL_COMDAT (node->decl))\n+  if (symtab_get_symbol_partitioning_class (node) != SYMBOL_PARTITION)\n     {\n       bp_pack_value (&bp, 0, 1);  /* used_from_other_parition.  */\n       bp_pack_value (&bp, 0, 1);  /* in_other_partition.  */"}, {"sha": "db7b030e5ab54a120b89bdc886fb5af21224ca2c", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/964512791e121b627ced9b14021856ca34121bc0/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/964512791e121b627ced9b14021856ca34121bc0/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=964512791e121b627ced9b14021856ca34121bc0", "patch": "@@ -1,3 +1,12 @@\n+2014-02-06  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR ipa/59469\n+\t* lto-partition.c (symbol_class): Move to cgraph.h\n+\t(get_symbol_class): Move to symtab.c\n+\t(add_references_to_partition, add_symbol_to_partition_1,\n+\tlto_max_map, lto_1_to_1_map, lto_balanced_map,\n+\tlto_promote_cross_file_statics): Update.\n+\n 2014-02-05  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* lto.c (lto_parallelism): New static var."}, {"sha": "c638cec1795ab428ae9e616b1a9aa82956a8b014", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 19, "deletions": 81, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/964512791e121b627ced9b14021856ca34121bc0/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/964512791e121b627ced9b14021856ca34121bc0/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=964512791e121b627ced9b14021856ca34121bc0", "patch": "@@ -38,73 +38,10 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ipa-utils.h\"\n #include \"lto-partition.h\"\n \n-/* Classifcation of symbols into classes WRT partitioning.  */\n-enum symbol_class\n-{\n-   /* External declarations are ignored by partitioning algorithms and they are\n-      added into the boundary later via compute_ltrans_boundary.  */\n-   SYMBOL_EXTERNAL,\n-   /* Partitioned symbols are pur into one of partitions.  */\n-   SYMBOL_PARTITION,\n-   /* Duplicated symbols (such as comdat or constant pool references) are\n-      copied into every node needing them via add_symbol_to_partition.  */\n-   SYMBOL_DUPLICATE\n-};\n-\n vec<ltrans_partition> ltrans_partitions;\n \n static void add_symbol_to_partition (ltrans_partition part, symtab_node *node);\n \n-/* Classify symbol NODE.  */\n-\n-enum symbol_class\n-get_symbol_class (symtab_node *node)\n-{\n-  /* Inline clones are always duplicated.\n-     This include external delcarations.   */\n-  cgraph_node *cnode = dyn_cast <cgraph_node> (node);\n-\n-  if (DECL_ABSTRACT (node->decl))\n-    return SYMBOL_EXTERNAL;\n-\n-  if (cnode && cnode->global.inlined_to)\n-    return SYMBOL_DUPLICATE;\n-\n-  /* Weakref aliases are always duplicated.  */\n-  if (node->weakref)\n-    return SYMBOL_DUPLICATE;\n-\n-  /* External declarations are external.  */\n-  if (DECL_EXTERNAL (node->decl))\n-    return SYMBOL_EXTERNAL;\n-\n-  if (varpool_node *vnode = dyn_cast <varpool_node> (node))\n-    {\n-      /* Constant pool references use local symbol names that can not\n-         be promoted global.  We should never put into a constant pool\n-         objects that can not be duplicated across partitions.  */\n-      if (DECL_IN_CONSTANT_POOL (node->decl))\n-\treturn SYMBOL_DUPLICATE;\n-      gcc_checking_assert (vnode->definition);\n-    }\n-  /* Functions that are cloned may stay in callgraph even if they are unused.\n-     Handle them as external; compute_ltrans_boundary take care to make\n-     proper things to happen (i.e. to make them appear in the boundary but\n-     with body streamed, so clone can me materialized).  */\n-  else if (!cgraph (node)->definition)\n-    return SYMBOL_EXTERNAL;\n-\n-  /* Linker discardable symbols are duplicated to every use unless they are\n-     keyed.\n-     Keyed symbols or those.  */\n-  if (DECL_ONE_ONLY (node->decl)\n-      && !node->force_output\n-      && !node->forced_by_abi\n-      && !symtab_used_from_object_file_p (node))\n-    return SYMBOL_DUPLICATE;\n-\n-  return SYMBOL_PARTITION;\n-}\n \n /* Create new partition with name NAME.  */\n \n@@ -153,7 +90,7 @@ add_references_to_partition (ltrans_partition part, symtab_node *node)\n \n   /* Add all duplicated references to the partition.  */\n   for (i = 0; ipa_ref_list_reference_iterate (&node->ref_list, i, ref); i++)\n-    if (get_symbol_class (ref->referred) == SYMBOL_DUPLICATE)\n+    if (symtab_get_symbol_partitioning_class (ref->referred) == SYMBOL_DUPLICATE)\n       add_symbol_to_partition (part, ref->referred);\n     /* References to a readonly variable may be constant foled into its value.\n        Recursively look into the initializers of the constant variable and add\n@@ -175,7 +112,7 @@ add_references_to_partition (ltrans_partition part, symtab_node *node)\n static bool\n add_symbol_to_partition_1 (ltrans_partition part, symtab_node *node)\n {\n-  enum symbol_class c = get_symbol_class (node);\n+  enum symbol_partitioning_class c = symtab_get_symbol_partitioning_class (node);\n   int i;\n   struct ipa_ref *ref;\n   symtab_node *node1;\n@@ -218,7 +155,7 @@ add_symbol_to_partition_1 (ltrans_partition part, symtab_node *node)\n       for (e = cnode->callees; e; e = e->next_callee)\n \tif (!e->inline_failed)\n \t  add_symbol_to_partition_1 (part, e->callee);\n-\telse if (get_symbol_class (e->callee) == SYMBOL_DUPLICATE)\n+\telse if (symtab_get_symbol_partitioning_class (e->callee) == SYMBOL_DUPLICATE)\n \t  add_symbol_to_partition (part, e->callee);\n \n       /* Add all thunks associated with the function.  */\n@@ -238,10 +175,11 @@ add_symbol_to_partition_1 (ltrans_partition part, symtab_node *node)\n   if (node->same_comdat_group)\n     for (node1 = node->same_comdat_group;\n \t node1 != node; node1 = node1->same_comdat_group)\n-      {\n-\tbool added = add_symbol_to_partition_1 (part, node1);\n-\tgcc_assert (added);\n-      }\n+      if (!node->alias)\n+\t{\n+\t  bool added = add_symbol_to_partition_1 (part, node1);\n+\t  gcc_assert (added);\n+\t}\n   return true;\n }\n \n@@ -276,7 +214,7 @@ add_symbol_to_partition (ltrans_partition part, symtab_node *node)\n   symtab_node *node1;\n \n   /* Verify that we do not try to duplicate something that can not be.  */\n-  gcc_checking_assert (get_symbol_class (node) == SYMBOL_DUPLICATE\n+  gcc_checking_assert (symtab_get_symbol_partitioning_class (node) == SYMBOL_DUPLICATE\n \t\t       || !symbol_partitioned_p (node));\n \n   while ((node1 = contained_in_symbol (node)) != node)\n@@ -289,7 +227,7 @@ add_symbol_to_partition (ltrans_partition part, symtab_node *node)\n      Be lax about comdats; they may or may not be duplicated and we may\n      end up in need to duplicate keyed comdat because it has unkeyed alias.  */\n \n-  gcc_assert (get_symbol_class (node) == SYMBOL_DUPLICATE\n+  gcc_assert (symtab_get_symbol_partitioning_class (node) == SYMBOL_DUPLICATE\n \t      || DECL_COMDAT (node->decl)\n \t      || !symbol_partitioned_p (node));\n \n@@ -336,7 +274,7 @@ lto_1_to_1_map (void)\n \n   FOR_EACH_SYMBOL (node)\n     {\n-      if (get_symbol_class (node) != SYMBOL_PARTITION\n+      if (symtab_get_symbol_partitioning_class (node) != SYMBOL_PARTITION\n \t  || symbol_partitioned_p (node))\n \tcontinue;\n \n@@ -388,7 +326,7 @@ lto_max_map (void)\n \n   FOR_EACH_SYMBOL (node)\n     {\n-      if (get_symbol_class (node) != SYMBOL_PARTITION\n+      if (symtab_get_symbol_partitioning_class (node) != SYMBOL_PARTITION\n \t  || symbol_partitioned_p (node))\n \tcontinue;\n       partition = new_partition (node->asm_name ());\n@@ -498,7 +436,7 @@ lto_balanced_map (void)\n     gcc_assert (!vnode->aux);\n     \n   FOR_EACH_DEFINED_FUNCTION (node)\n-    if (get_symbol_class (node) == SYMBOL_PARTITION)\n+    if (symtab_get_symbol_partitioning_class (node) == SYMBOL_PARTITION)\n       {\n \torder[n_nodes++] = node;\n \ttotal_size += inline_summary (node)->size;\n@@ -518,13 +456,13 @@ lto_balanced_map (void)\n   if (!flag_toplevel_reorder)\n     {\n       FOR_EACH_VARIABLE (vnode)\n-\tif (get_symbol_class (vnode) == SYMBOL_PARTITION)\n+\tif (symtab_get_symbol_partitioning_class (vnode) == SYMBOL_PARTITION)\n \t  n_varpool_nodes++;\n       varpool_order = XNEWVEC (varpool_node *, n_varpool_nodes);\n \n       n_varpool_nodes = 0;\n       FOR_EACH_VARIABLE (vnode)\n-\tif (get_symbol_class (vnode) == SYMBOL_PARTITION)\n+\tif (symtab_get_symbol_partitioning_class (vnode) == SYMBOL_PARTITION)\n \t  varpool_order[n_varpool_nodes++] = vnode;\n       qsort (varpool_order, n_varpool_nodes, sizeof (varpool_node *),\n \t     varpool_node_cmp);\n@@ -643,7 +581,7 @@ lto_balanced_map (void)\n \t\tif (!vnode->definition)\n \t\t  continue;\n \t\tif (!symbol_partitioned_p (vnode) && flag_toplevel_reorder\n-\t\t    && get_symbol_class (vnode) == SYMBOL_PARTITION)\n+\t\t    && symtab_get_symbol_partitioning_class (vnode) == SYMBOL_PARTITION)\n \t\t  add_symbol_to_partition (partition, vnode);\n \t\tindex = lto_symtab_encoder_lookup (partition->encoder,\n \t\t\t\t\t\t   vnode);\n@@ -676,7 +614,7 @@ lto_balanced_map (void)\n \t\tvnode = ipa_ref_referring_varpool_node (ref);\n \t\tgcc_assert (vnode->definition);\n \t\tif (!symbol_partitioned_p (vnode) && flag_toplevel_reorder\n-\t\t    && get_symbol_class (vnode) == SYMBOL_PARTITION)\n+\t\t    && symtab_get_symbol_partitioning_class (vnode) == SYMBOL_PARTITION)\n \t\t  add_symbol_to_partition (partition, vnode);\n \t\tindex = lto_symtab_encoder_lookup (partition->encoder,\n \t\t\t\t\t\t   vnode);\n@@ -769,7 +707,7 @@ lto_balanced_map (void)\n   if (flag_toplevel_reorder)\n     {\n       FOR_EACH_VARIABLE (vnode)\n-        if (get_symbol_class (vnode) == SYMBOL_PARTITION\n+        if (symtab_get_symbol_partitioning_class (vnode) == SYMBOL_PARTITION\n \t    && !symbol_partitioned_p (vnode))\n \t  add_symbol_to_partition (partition, vnode);\n     }\n@@ -979,7 +917,7 @@ lto_promote_cross_file_statics (void)\n \t      || lto_symtab_encoder_in_partition_p (encoder, node)\n \t      /* ... or if we do not partition it. This mean that it will\n \t\t appear in every partition refernecing it.  */\n-\t      || get_symbol_class (node) != SYMBOL_PARTITION)\n+\t      || symtab_get_symbol_partitioning_class (node) != SYMBOL_PARTITION)\n \t    continue;\n \n           promote_symbol (node);"}]}