{"sha": "215770ada8310953eb90e2369b796263dcf5f770", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjE1NzcwYWRhODMxMDk1M2ViOTBlMjM2OWI3OTYyNjNkY2Y1Zjc3MA==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2012-08-08T18:03:37Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2012-08-08T18:03:37Z"}, "message": "builtins.c (expand_builtin_atomic_compare_exchange): Pass old value operand as MEM to expand_atomic_compare_and_swap.\n\n\t* builtins.c (expand_builtin_atomic_compare_exchange): Pass old\n\tvalue operand as MEM to expand_atomic_compare_and_swap.\n\n\t* config/s390/s390.md (\"atomic_compare_and_swap<mode>\"): Accept\n\tnonimmediate_operand for old value; generate load and store if\n\tneeded.\n\t* config/s390/s390.c (s390_expand_cs_hqi): Accept any operand\n\tas vtarget.\n\nFrom-SVN: r190236", "tree": {"sha": "45326924f3c22152fe766736893f863430b07a20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/45326924f3c22152fe766736893f863430b07a20"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/215770ada8310953eb90e2369b796263dcf5f770", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/215770ada8310953eb90e2369b796263dcf5f770", "html_url": "https://github.com/Rust-GCC/gccrs/commit/215770ada8310953eb90e2369b796263dcf5f770", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/215770ada8310953eb90e2369b796263dcf5f770/comments", "author": null, "committer": null, "parents": [{"sha": "07c5a154bb3d23948235bd9481fecca779b1f62d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07c5a154bb3d23948235bd9481fecca779b1f62d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07c5a154bb3d23948235bd9481fecca779b1f62d"}], "stats": {"total": 41, "additions": 33, "deletions": 8}, "files": [{"sha": "b8eb055a2029e8134b832579fe9a9223bc793008", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/215770ada8310953eb90e2369b796263dcf5f770/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/215770ada8310953eb90e2369b796263dcf5f770/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=215770ada8310953eb90e2369b796263dcf5f770", "patch": "@@ -1,3 +1,14 @@\n+2012-08-08  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n+\n+\t* builtins.c (expand_builtin_atomic_compare_exchange): Pass old\n+\tvalue operand as MEM to expand_atomic_compare_and_swap.\n+\n+\t* config/s390/s390.md (\"atomic_compare_and_swap<mode>\"): Accept\n+\tnonimmediate_operand for old value; generate load and store if\n+\tneeded.\n+\t* config/s390/s390.c (s390_expand_cs_hqi): Accept any operand\n+\tas vtarget.\n+\n 2012-08-08  Steven Bosscher  <steven@gcc.gnu.org>\n \n \tPR middle-end/54146"}, {"sha": "4b177c48e65e9c09261ce152a8ed7e02294e4d37", "filename": "gcc/builtins.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/215770ada8310953eb90e2369b796263dcf5f770/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/215770ada8310953eb90e2369b796263dcf5f770/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=215770ada8310953eb90e2369b796263dcf5f770", "patch": "@@ -5376,21 +5376,23 @@ expand_builtin_atomic_compare_exchange (enum machine_mode mode, tree exp,\n \n   expect = expand_normal (CALL_EXPR_ARG (exp, 1));\n   expect = convert_memory_address (Pmode, expect);\n+  expect = gen_rtx_MEM (mode, expect);\n   desired = expand_expr_force_mode (CALL_EXPR_ARG (exp, 2), mode);\n \n   weak = CALL_EXPR_ARG (exp, 3);\n   is_weak = false;\n   if (host_integerp (weak, 0) && tree_low_cst (weak, 0) != 0)\n     is_weak = true;\n \n-  oldval = copy_to_reg (gen_rtx_MEM (mode, expect));\n-\n+  oldval = expect;\n   if (!expand_atomic_compare_and_swap ((target == const0_rtx ? NULL : &target),\n \t\t\t\t       &oldval, mem, oldval, desired,\n \t\t\t\t       is_weak, success, failure))\n     return NULL_RTX;\n \n-  emit_move_insn (gen_rtx_MEM (mode, expect), oldval);\n+  if (oldval != expect)\n+    emit_move_insn (expect, oldval);\n+\n   return target;\n }\n "}, {"sha": "5297ff3ff8dfe9a8f46a2d5427c1ecee031ae50b", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/215770ada8310953eb90e2369b796263dcf5f770/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/215770ada8310953eb90e2369b796263dcf5f770/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=215770ada8310953eb90e2369b796263dcf5f770", "patch": "@@ -4825,7 +4825,6 @@ s390_expand_cs_hqi (enum machine_mode mode, rtx btarget, rtx vtarget, rtx mem,\n   rtx res = gen_reg_rtx (SImode);\n   rtx csloop = NULL, csend = NULL;\n \n-  gcc_assert (register_operand (vtarget, VOIDmode));\n   gcc_assert (MEM_P (mem));\n \n   init_alignment_context (&ac, mem, mode);"}, {"sha": "b3d096c9ef7c6f4a61b29f211b276cec1beb6633", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/215770ada8310953eb90e2369b796263dcf5f770/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/215770ada8310953eb90e2369b796263dcf5f770/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=215770ada8310953eb90e2369b796263dcf5f770", "patch": "@@ -8870,7 +8870,7 @@\n \n (define_expand \"atomic_compare_and_swap<mode>\"\n   [(match_operand:SI 0 \"register_operand\")\t;; bool success output\n-   (match_operand:DGPR 1 \"register_operand\")\t;; oldval output\n+   (match_operand:DGPR 1 \"nonimmediate_operand\");; oldval output\n    (match_operand:DGPR 2 \"memory_operand\")\t;; memory\n    (match_operand:DGPR 3 \"register_operand\")\t;; expected intput\n    (match_operand:DGPR 4 \"register_operand\")\t;; newval intput\n@@ -8879,9 +8879,22 @@\n    (match_operand:SI 7 \"const_int_operand\")]\t;; failure model\n   \"\"\n {\n-  rtx cc, cmp;\n+  rtx cc, cmp, output = operands[1];\n+\n+  if (!register_operand (output, <MODE>mode))\n+    output = gen_reg_rtx (<MODE>mode);\n+\n   emit_insn (gen_atomic_compare_and_swap<mode>_internal\n-\t     (operands[1], operands[2], operands[3], operands[4]));\n+\t     (output, operands[2], operands[3], operands[4]));\n+\n+  /* We deliberately accept non-register operands in the predicate\n+     to ensure the write back to the output operand happens *before*\n+     the store-flags code below.  This makes it easier for combine\n+     to merge the store-flags code with a potential test-and-branch\n+     pattern following (immediately!) afterwards.  */\n+  if (output != operands[1])\n+    emit_move_insn (operands[1], output);\n+\n   cc = gen_rtx_REG (CCZ1mode, CC_REGNUM);\n   cmp = gen_rtx_EQ (SImode, cc, const0_rtx);\n   emit_insn (gen_cstorecc4 (operands[0], cmp, cc, const0_rtx));\n@@ -8890,7 +8903,7 @@\n \n (define_expand \"atomic_compare_and_swap<mode>\"\n   [(match_operand:SI 0 \"register_operand\")\t;; bool success output\n-   (match_operand:HQI 1 \"register_operand\")\t;; oldval output\n+   (match_operand:HQI 1 \"nonimmediate_operand\")\t;; oldval output\n    (match_operand:HQI 2 \"memory_operand\")\t;; memory\n    (match_operand:HQI 3 \"general_operand\")\t;; expected intput\n    (match_operand:HQI 4 \"general_operand\")\t;; newval intput"}]}