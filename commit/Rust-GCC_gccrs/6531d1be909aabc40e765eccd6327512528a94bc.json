{"sha": "6531d1be909aabc40e765eccd6327512528a94bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjUzMWQxYmU5MDlhYWJjNDBlNzY1ZWNjZDYzMjc1MTI1MjhhOTRiYw==", "commit": {"author": {"name": "Bernhard Fischer", "email": "aldot@gcc.gnu.org", "date": "2006-05-21T15:11:54Z"}, "committer": {"name": "Bernhard Reutner-Fischer", "email": "aldot@gcc.gnu.org", "date": "2006-05-21T15:11:54Z"}, "message": "tree-cfg.c: Prune whitespace.\n\n\t* tree-cfg.c: Prune whitespace.\n\t(debug_tree_cfg): Point to correct header containing the\n\tTDF_* defines.\n\nFrom-SVN: r113954", "tree": {"sha": "b7931cf534a58a90c9069a20850e997a3dc971f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b7931cf534a58a90c9069a20850e997a3dc971f6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6531d1be909aabc40e765eccd6327512528a94bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6531d1be909aabc40e765eccd6327512528a94bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6531d1be909aabc40e765eccd6327512528a94bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6531d1be909aabc40e765eccd6327512528a94bc/comments", "author": null, "committer": null, "parents": [{"sha": "95a52ebb0b0c0bff5c76795be09b5a856446c21f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95a52ebb0b0c0bff5c76795be09b5a856446c21f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95a52ebb0b0c0bff5c76795be09b5a856446c21f"}], "stats": {"total": 124, "additions": 64, "deletions": 60}, "files": [{"sha": "7bd222e353e53f2ae5655aa813c00a80b065ea37", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6531d1be909aabc40e765eccd6327512528a94bc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6531d1be909aabc40e765eccd6327512528a94bc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6531d1be909aabc40e765eccd6327512528a94bc", "patch": "@@ -1,3 +1,9 @@\n+2006-05-21  Bernhard Fischer  <aldot@gcc.gnu.org>\n+\n+\t* tree-cfg.c: Prune whitespace.\n+\t(debug_tree_cfg): Point to correct header containing the\n+\tTDF_* defines.\n+\n 2006-05-21  Bernhard Fischer  <aldot@gcc.gnu.org>\n \n \tPR middle-end/25776"}, {"sha": "a3fed03956fb1ea723e99f31339592576ffbf2f8", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 58, "deletions": 60, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6531d1be909aabc40e765eccd6327512528a94bc/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6531d1be909aabc40e765eccd6327512528a94bc/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=6531d1be909aabc40e765eccd6327512528a94bc", "patch": "@@ -247,9 +247,9 @@ struct tree_opt_pass pass_build_cfg =\n   0\t\t\t\t\t/* letter */\n };\n \n-/* Search the CFG for any computed gotos.  If found, factor them to a \n+/* Search the CFG for any computed gotos.  If found, factor them to a\n    common computed goto site.  Also record the location of that site so\n-   that we can un-factor the gotos after we have converted back to \n+   that we can un-factor the gotos after we have converted back to\n    normal form.  */\n \n static void\n@@ -264,7 +264,7 @@ factor_computed_gotos (void)\n   /* We know there are one or more computed gotos in this function.\n      Examine the last statement in each basic block to see if the block\n      ends with a computed goto.  */\n-\t\n+\n   FOR_EACH_BB (bb)\n     {\n       block_stmt_iterator bsi = bsi_last (bb);\n@@ -565,7 +565,7 @@ make_edges (void)\n \t\t      }\n \t\t  }\n \t\t  break;\n-\t\t     \n+\n \t\tdefault:\n \t\t  gcc_unreachable ();\n \t\t}\n@@ -658,7 +658,7 @@ edge_to_cases_eq (const void *p1, const void *p2)\n /* Called for each element in the hash table (P) as we delete the\n    edge to cases hash table.\n \n-   Clear all the TREE_CHAINs to prevent problems with copying of \n+   Clear all the TREE_CHAINs to prevent problems with copying of\n    SWITCH_EXPRs and structure sharing rules, then free the hash table\n    element.  */\n \n@@ -759,7 +759,7 @@ get_cases_for_edge (edge e, tree t)\n      chains available.  Return NULL so the caller can detect this case.  */\n   if (!recording_case_labels_p ())\n     return NULL;\n-  \n+\n restart:\n   elt.e = e;\n   elt.case_labels = NULL;\n@@ -821,7 +821,7 @@ label_to_block_fn (struct function *ifun, tree dest)\n      and undefined variable warnings quite right.  */\n   if ((errorcount || sorrycount) && uid < 0)\n     {\n-      block_stmt_iterator bsi = \n+      block_stmt_iterator bsi =\n \tbsi_start (BASIC_BLOCK (NUM_FIXED_BLOCKS));\n       tree stmt;\n \n@@ -1025,13 +1025,13 @@ cleanup_dead_labels (void)\n \n \t    break;\n \t  }\n-  \n+\n \tcase SWITCH_EXPR:\n \t  {\n \t    size_t i;\n \t    tree vec = SWITCH_LABELS (stmt);\n \t    size_t n = TREE_VEC_LENGTH (vec);\n-  \n+\n \t    /* Replace all destination labels.  */\n \t    for (i = 0; i < n; ++i)\n \t      {\n@@ -1111,7 +1111,7 @@ group_case_labels (void)\n \t  int old_size = TREE_VEC_LENGTH (labels);\n \t  int i, j, new_size = old_size;\n \t  tree default_case = TREE_VEC_ELT (labels, old_size - 1);\n- \t  tree default_label;\n+\t  tree default_label;\n \n \t  /* The default label is always the last case in a switch\n \t     statement after gimplification.  */\n@@ -1205,7 +1205,7 @@ tree_can_merge_blocks_p (basic_block a, basic_block b)\n \n   if (b == EXIT_BLOCK_PTR)\n     return false;\n-  \n+\n   /* If A ends by a statement causing exceptions or something similar, we\n      cannot merge the blocks.  */\n   stmt = last_stmt (a);\n@@ -1293,7 +1293,7 @@ replace_uses_by (tree name, tree val)\n \t  mark_new_vars_to_rename (stmt);\n \t}\n     }\n- \n+\n   gcc_assert (num_imm_uses (name) == 0);\n \n   /* Also update the trees stored in loop structures.  */\n@@ -1402,24 +1402,23 @@ tree_merge_blocks (basic_block a, basic_block b)\n    reached by a complex edge, if there is one.  Else, return BB.  We use\n    this in optimizations that use post-dominators for their heuristics,\n    to catch the cases in C++ where function calls are involved.  */\n-    \n+\n basic_block\n-single_noncomplex_succ (basic_block bb)  \n+single_noncomplex_succ (basic_block bb)\n {\n   edge e0, e1;\n   if (EDGE_COUNT (bb->succs) != 2)\n     return bb;\n-   \n+\n   e0 = EDGE_SUCC (bb, 0);\n   e1 = EDGE_SUCC (bb, 1);\n   if (e0->flags & EDGE_COMPLEX)\n     return e1->dest;\n   if (e1->flags & EDGE_COMPLEX)\n     return e0->dest;\n-   \n+\n   return bb;\n-}       \n-        \n+}\n \n \n /* Walk the function tree removing unnecessary statements.\n@@ -1798,7 +1797,7 @@ remove_useless_stmts_label (tree *stmt_p, struct rus_data *data)\n \n /* If the function is \"const\" or \"pure\", then clear TREE_SIDE_EFFECTS on its\n    decl.  This allows us to eliminate redundant or useless\n-   calls to \"const\" functions. \n+   calls to \"const\" functions.\n \n    Gimplifier already does the same operation, but we may notice functions\n    being const and pure once their calls has been gimplified, so we need\n@@ -1912,7 +1911,7 @@ remove_useless_stmts_1 (tree *tp, struct rus_data *data)\n \t\ttsi_delink (&i);\n \t\tcontinue;\n \t      }\n-\t    \n+\n \t    remove_useless_stmts_1 (tsi_stmt_ptr (i), data);\n \n \t    t = tsi_stmt (i);\n@@ -1954,7 +1953,7 @@ remove_useless_stmts (void)\n }\n \n \n-struct tree_opt_pass pass_remove_useless_stmts = \n+struct tree_opt_pass pass_remove_useless_stmts =\n {\n   \"useless\",\t\t\t\t/* name */\n   NULL,\t\t\t\t\t/* gate */\n@@ -2055,7 +2054,7 @@ remove_bb (basic_block bb)\n \t      DECL_NONLOCAL (LABEL_EXPR_LABEL (stmt)) = 0;\n \t      FORCED_LABEL (LABEL_EXPR_LABEL (stmt)) = 1;\n \t    }\n-\t  \t  \n+\n \t  new_bb = bb->prev_bb;\n \t  new_bsi = bsi_start (new_bb);\n \t  bsi_remove (&i, false);\n@@ -2167,7 +2166,7 @@ find_taken_edge_cond_expr (basic_block bb, tree val)\n   edge true_edge, false_edge;\n \n   extract_true_false_edges_from_block (bb, &true_edge, &false_edge);\n-  \n+\n   gcc_assert (TREE_CODE (val) == INTEGER_CST);\n   return (zero_p (val) ? false_edge : true_edge);\n }\n@@ -2267,13 +2266,13 @@ debug_tree_bb_n (int n)\n {\n   debug_tree_bb (BASIC_BLOCK (n));\n   return BASIC_BLOCK (n);\n-}\t \n+}\n \n \n /* Dump the CFG on stderr.\n \n    FLAGS are the same used by the tree dumping functions\n-   (see TDF_* in tree.h).  */\n+   (see TDF_* in tree-pass.h).  */\n \n void\n debug_tree_cfg (int flags)\n@@ -2838,7 +2837,7 @@ bsi_insert_after (block_stmt_iterator *i, tree t, enum bsi_iterator_update m)\n \n \n /* Remove the statement pointed to by iterator I.  The iterator is updated\n-   to the next statement. \n+   to the next statement.\n \n    When REMOVE_EH_INFO is true we remove the statement pointed to by\n    iterator I from the EH tables.  Otherwise we do not modify the EH\n@@ -2862,18 +2861,18 @@ bsi_remove (block_stmt_iterator *i, bool remove_eh_info)\n \n /* Move the statement at FROM so it comes right after the statement at TO.  */\n \n-void \n+void\n bsi_move_after (block_stmt_iterator *from, block_stmt_iterator *to)\n {\n   tree stmt = bsi_stmt (*from);\n   bsi_remove (from, false);\n   bsi_insert_after (to, stmt, BSI_SAME_STMT);\n-} \n+}\n \n \n /* Move the statement at FROM so it comes right before the statement at TO.  */\n \n-void \n+void\n bsi_move_before (block_stmt_iterator *from, block_stmt_iterator *to)\n {\n   tree stmt = bsi_stmt (*from);\n@@ -2888,7 +2887,7 @@ void\n bsi_move_to_bb_end (block_stmt_iterator *from, basic_block bb)\n {\n   block_stmt_iterator last = bsi_last (bb);\n-  \n+\n   /* Have to check bsi_end_p because it could be an empty block.  */\n   if (!bsi_end_p (last) && is_ctrl_stmt (bsi_stmt (last)))\n     bsi_move_before (from, &last);\n@@ -2900,7 +2899,6 @@ bsi_move_to_bb_end (block_stmt_iterator *from, basic_block bb)\n /* Replace the contents of the statement pointed to by iterator BSI\n    with STMT.  If UPDATE_EH_INFO is true, the exception handling\n    information of the original statement is moved to the new statement.  */\n-  \n \n void\n bsi_replace (const block_stmt_iterator *bsi, tree stmt, bool update_eh_info)\n@@ -2951,7 +2949,7 @@ tree_find_edge_insert_loc (edge e, block_stmt_iterator *bsi,\n  restart:\n \n   /* If the destination has one predecessor which has no PHI nodes,\n-     insert there.  Except for the exit block. \n+     insert there.  Except for the exit block.\n \n      The requirement for no PHI nodes could be relaxed.  Basically we\n      would have to examine the PHIs to prove that none of them used\n@@ -3107,7 +3105,7 @@ reinstall_phi_args (edge new_edge, edge old_edge)\n \n   if (!PENDING_STMT (old_edge))\n     return;\n-  \n+\n   for (var = PENDING_STMT (old_edge), phi = phi_nodes (new_edge->dest);\n        var && phi;\n        var = TREE_CHAIN (var), phi = PHI_CHAIN (phi))\n@@ -3202,7 +3200,7 @@ verify_expr (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n \n   if (TYPE_P (t))\n     *walk_subtrees = 0;\n-  \n+\n   /* Check operand N for being valid GIMPLE and give error MSG if not.  */\n #define CHECK_OP(N, MSG) \\\n   do { if (!is_gimple_val (TREE_OPERAND (t, N)))\t\t\\\n@@ -3793,11 +3791,11 @@ tree_verify_flow_info (void)\n \t  if (simple_goto_p (stmt))\n \t    {\n \t      error (\"explicit goto at end of bb %d\", bb->index);\n-    \t      err = 1;\n+\t      err = 1;\n \t    }\n \t  else\n \t    {\n-\t      /* FIXME.  We should double check that the labels in the \n+\t      /* FIXME.  We should double check that the labels in the\n \t\t destination blocks have their address taken.  */\n \t      FOR_EACH_EDGE (e, ei, bb->succs)\n \t\tif ((e->flags & (EDGE_FALLTHRU | EDGE_TRUE_VALUE\n@@ -4049,7 +4047,7 @@ tree_redirect_edge_and_branch (edge e, basic_block dest)\n   if (e->flags & (EDGE_ABNORMAL_CALL | EDGE_EH))\n     return NULL;\n \n-  if (e->src != ENTRY_BLOCK_PTR \n+  if (e->src != ENTRY_BLOCK_PTR\n       && (ret = tree_try_redirect_by_replacing_jump (e, dest)))\n     return ret;\n \n@@ -4296,7 +4294,7 @@ add_phi_args_after_copy_bb (basic_block bb_copy)\n   edge e, e_copy;\n   edge_iterator ei;\n   tree phi, phi_copy, phi_next, def;\n-      \n+\n   bb = get_bb_original (bb_copy);\n \n   FOR_EACH_EDGE (e_copy, ei, bb_copy->succs)\n@@ -4458,7 +4456,7 @@ tree_duplicate_sese_region (edge entry, edge exit,\n \t\t\t\t       total_count - entry_count,\n \t\t\t\t       total_count);\n       scale_bbs_frequencies_gcov_type (region_copy, n_region, entry_count,\n-\t  \t\t\t       total_count);\n+\t\t\t\t       total_count);\n     }\n   else\n     {\n@@ -4610,7 +4608,7 @@ move_stmt_r (tree *tp, int *walk_subtrees, void *data)\n    original array of blocks and placed in DEST_FN's array of blocks.\n    If UPDATE_EDGE_COUNT_P is true, the edge counts on both CFGs is\n    updated to reflect the moved edges.\n-   \n+\n    On exit, local variables that need to be removed from\n    CFUN->UNEXPANDED_VAR_LIST will have been added to VARS_TO_REMOVE.  */\n \n@@ -4728,7 +4726,7 @@ find_outermost_region_in_block (struct function *src_cfun,\n \t\t\t\tbasic_block bb, int region)\n {\n   block_stmt_iterator si;\n-  \n+\n   for (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n     {\n       tree stmt = bsi_stmt (si);\n@@ -4971,7 +4969,7 @@ dump_function_to_file (tree fn, FILE *file, int flags)\n   basic_block bb;\n   tree chain;\n   struct function *saved_cfun;\n-  \n+\n   fprintf (file, \"%s (\", lang_hooks.decl_printable_name (fn, 2));\n \n   arg = DECL_ARGUMENTS (fn);\n@@ -5026,7 +5024,7 @@ dump_function_to_file (tree fn, FILE *file, int flags)\n \n       FOR_EACH_BB (bb)\n \tdump_generic_bb (file, bb, 2, flags);\n-\t\n+\n       fprintf (file, \"}\\n\");\n       check_bb_profile (EXIT_BLOCK_PTR, file);\n     }\n@@ -5117,7 +5115,7 @@ print_loop (FILE *file, struct loop *loop, int indent)\n {\n   char *s_indent;\n   basic_block bb;\n-  \n+\n   if (loop == NULL)\n     return;\n \n@@ -5127,7 +5125,7 @@ print_loop (FILE *file, struct loop *loop, int indent)\n \n   /* Print the loop's header.  */\n   fprintf (file, \"%sloop_%d\\n\", s_indent, loop->num);\n-  \n+\n   /* Print the loop's body.  */\n   fprintf (file, \"%s{\\n\", s_indent);\n   FOR_EACH_BB (bb)\n@@ -5139,13 +5137,13 @@ print_loop (FILE *file, struct loop *loop, int indent)\n \tfprintf (file, \"}, succs = {\");\n \tprint_succ_bbs (file, bb);\n \tfprintf (file, \"})\\n\");\n-\t\n+\n \t/* Print the basic_block's body.  */\n \tfprintf (file, \"%s  {\\n\", s_indent);\n \ttree_dump_bb (bb, file, indent + 4);\n \tfprintf (file, \"%s  }\\n\", s_indent);\n       }\n-  \n+\n   print_loop (file, loop->inner, indent + 2);\n   fprintf (file, \"%s}\\n\", s_indent);\n   print_loop (file, loop->next, indent);\n@@ -5155,11 +5153,11 @@ print_loop (FILE *file, struct loop *loop, int indent)\n /* Follow a CFG edge from the entry point of the program, and on entry\n    of a loop, pretty print the loop structure on FILE.  */\n \n-void \n+void\n print_loop_ir (FILE *file)\n {\n   basic_block bb;\n-  \n+\n   bb = BASIC_BLOCK (NUM_FIXED_BLOCKS);\n   if (bb && bb->loop_father)\n     print_loop (file, bb->loop_father, 0);\n@@ -5168,7 +5166,7 @@ print_loop_ir (FILE *file)\n \n /* Debugging loops structure at tree level.  */\n \n-void \n+void\n debug_loop_ir (void)\n {\n   print_loop_ir (stderr);\n@@ -5433,8 +5431,8 @@ tree_execute_on_shrinking_pred (edge e)\n    of 'first'. Both of them are dominated by 'new_head' basic block. When\n    'new_head' was created by 'second's incoming edge it received phi arguments\n    on the edge by split_edge(). Later, additional edge 'e' was created to\n-   connect 'new_head' and 'first'. Now this routine adds phi args on this \n-   additional edge 'e' that new_head to second edge received as part of edge \n+   connect 'new_head' and 'first'. Now this routine adds phi args on this\n+   additional edge 'e' that new_head to second edge received as part of edge\n    splitting.\n */\n \n@@ -5452,17 +5450,17 @@ tree_lv_adjust_loop_header_phi (basic_block first, basic_block second,\n   /* Browse all 'second' basic block phi nodes and add phi args to\n      edge 'e' for 'first' head. PHI args are always in correct order.  */\n \n-  for (phi2 = phi_nodes (second), phi1 = phi_nodes (first); \n-       phi2 && phi1; \n+  for (phi2 = phi_nodes (second), phi1 = phi_nodes (first);\n+       phi2 && phi1;\n        phi2 = PHI_CHAIN (phi2),  phi1 = PHI_CHAIN (phi1))\n     {\n       tree def = PHI_ARG_DEF (phi2, e2->dest_idx);\n       add_phi_arg (phi1, def, e);\n     }\n }\n \n-/* Adds a if else statement to COND_BB with condition COND_EXPR.  \n-   SECOND_HEAD is the destination of the THEN and FIRST_HEAD is \n+/* Adds a if else statement to COND_BB with condition COND_EXPR.\n+   SECOND_HEAD is the destination of the THEN and FIRST_HEAD is\n    the destination of the ELSE part.  */\n static void\n tree_lv_add_condition_to_bb (basic_block first_head, basic_block second_head,\n@@ -5480,8 +5478,8 @@ tree_lv_add_condition_to_bb (basic_block first_head, basic_block second_head,\n   goto2 = build1 (GOTO_EXPR, void_type_node, tree_block_label (second_head));\n   new_cond_expr = build3 (COND_EXPR, void_type_node, cond_expr, goto1, goto2);\n \n-  /* Add new cond in cond_bb.  */ \n-  bsi = bsi_start (cond_bb); \n+  /* Add new cond in cond_bb.  */\n+  bsi = bsi_start (cond_bb);\n   bsi_insert_after (&bsi, new_cond_expr, BSI_NEW_STMT);\n   /* Adjust edges appropriately to connect new head with first head\n      as well as second head.  */\n@@ -5518,7 +5516,7 @@ struct cfg_hooks tree_cfg_hooks = {\n   tree_lv_add_condition_to_bb, /* lv_add_condition_to_bb */\n   tree_lv_adjust_loop_header_phi, /* lv_adjust_loop_header_phi*/\n   extract_true_false_edges_from_block, /* extract_cond_bb_edges */\n-  flush_pending_stmts \t\t/* flush_pending_stmts */  \n+  flush_pending_stmts\t\t/* flush_pending_stmts */\n };\n \n \n@@ -5547,7 +5545,7 @@ split_critical_edges (void)\n   return 0;\n }\n \n-struct tree_opt_pass pass_split_crit_edges = \n+struct tree_opt_pass pass_split_crit_edges =\n {\n   \"crited\",                          /* name */\n   NULL,                          /* gate */"}]}