{"sha": "d39f6b24d401c8a945fae1488de0dea2252ec7ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDM5ZjZiMjRkNDAxYzhhOTQ1ZmFlMTQ4OGRlMGRlYTIyNTJlYzdhZQ==", "commit": {"author": {"name": "Yannick Moy", "email": "moy@adacore.com", "date": "2019-08-12T08:59:42Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-08-12T08:59:42Z"}, "message": "[Ada] More precise handling of Size/Object_Size in GNATprove\n\nGNATprove does a partial expansion which did not allow getting the\nmost precise value for attributes Size/Object_Size. Now fixed.\n\nThere is no impact on compilation.\n\n2019-08-12  Yannick Moy  <moy@adacore.com>\n\ngcc/ada/\n\n\t* exp_attr.adb, exp_attr.ads (Expand_Size_Attribute): New\n\tprocedure to share part of the attribute expansion with\n\tGNATprove mode.\n\t(Expand_N_Attribute_Reference): Extract part of the\n\tSize/Object_Size expansion in the new procedure\n\tExpand_Size_Attribute.\n\t* exp_spark.adb (Expand_SPARK_N_Attribute_Reference): Expand\n\tSize/Object_Size attributes using the new procedure\n\tExpand_Size_Attribute.\n\nFrom-SVN: r274290", "tree": {"sha": "47025463fc6ac7c0e821c0258bc24adbab991749", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/47025463fc6ac7c0e821c0258bc24adbab991749"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d39f6b24d401c8a945fae1488de0dea2252ec7ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d39f6b24d401c8a945fae1488de0dea2252ec7ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d39f6b24d401c8a945fae1488de0dea2252ec7ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d39f6b24d401c8a945fae1488de0dea2252ec7ae/comments", "author": {"login": "yannickmoy", "id": 859440, "node_id": "MDQ6VXNlcjg1OTQ0MA==", "avatar_url": "https://avatars.githubusercontent.com/u/859440?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yannickmoy", "html_url": "https://github.com/yannickmoy", "followers_url": "https://api.github.com/users/yannickmoy/followers", "following_url": "https://api.github.com/users/yannickmoy/following{/other_user}", "gists_url": "https://api.github.com/users/yannickmoy/gists{/gist_id}", "starred_url": "https://api.github.com/users/yannickmoy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yannickmoy/subscriptions", "organizations_url": "https://api.github.com/users/yannickmoy/orgs", "repos_url": "https://api.github.com/users/yannickmoy/repos", "events_url": "https://api.github.com/users/yannickmoy/events{/privacy}", "received_events_url": "https://api.github.com/users/yannickmoy/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "08c8696d4884425839fc5cd14a8788fe53f031e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08c8696d4884425839fc5cd14a8788fe53f031e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08c8696d4884425839fc5cd14a8788fe53f031e4"}], "stats": {"total": 289, "additions": 163, "deletions": 126}, "files": [{"sha": "ca2030d95fcd935193c73c4d3f775ef1227b0beb", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d39f6b24d401c8a945fae1488de0dea2252ec7ae/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d39f6b24d401c8a945fae1488de0dea2252ec7ae/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d39f6b24d401c8a945fae1488de0dea2252ec7ae", "patch": "@@ -1,3 +1,15 @@\n+2019-08-12  Yannick Moy  <moy@adacore.com>\n+\n+\t* exp_attr.adb, exp_attr.ads (Expand_Size_Attribute): New\n+\tprocedure to share part of the attribute expansion with\n+\tGNATprove mode.\n+\t(Expand_N_Attribute_Reference): Extract part of the\n+\tSize/Object_Size expansion in the new procedure\n+\tExpand_Size_Attribute.\n+\t* exp_spark.adb (Expand_SPARK_N_Attribute_Reference): Expand\n+\tSize/Object_Size attributes using the new procedure\n+\tExpand_Size_Attribute.\n+\n 2019-08-12  Yannick Moy  <moy@adacore.com>\n \n \t* exp_spark.adb (Expand_SPARK_N_Attribute_Reference): Only"}, {"sha": "d90dc29171fbdecc73b54c738be1a6229acfd6f4", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 139, "deletions": 122, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d39f6b24d401c8a945fae1488de0dea2252ec7ae/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d39f6b24d401c8a945fae1488de0dea2252ec7ae/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=d39f6b24d401c8a945fae1488de0dea2252ec7ae", "patch": "@@ -3598,8 +3598,8 @@ package body Exp_Attr is\n       --    Result_Type (System.Fore (Universal_Real (Type'First)),\n       --                              Universal_Real (Type'Last))\n \n-      --  Note that we know that the type is a non-static subtype, or Fore\n-      --  would have itself been computed dynamically in Eval_Attribute.\n+      --  Note that we know that the type is a nonstatic subtype, or Fore would\n+      --  have itself been computed dynamically in Eval_Attribute.\n \n       when Attribute_Fore =>\n          Rewrite (N,\n@@ -5849,7 +5849,6 @@ package body Exp_Attr is\n          | Attribute_VADS_Size\n       =>\n          Size : declare\n-            Siz      : Uint;\n             New_Node : Node_Id;\n \n          begin\n@@ -5961,128 +5960,12 @@ package body Exp_Attr is\n                Rewrite (N, New_Node);\n                Analyze_And_Resolve (N, Typ);\n                return;\n-\n-            --  Case of known RM_Size of a type\n-\n-            elsif (Id = Attribute_Size or else Id = Attribute_Value_Size)\n-              and then Is_Entity_Name (Pref)\n-              and then Is_Type (Entity (Pref))\n-              and then Known_Static_RM_Size (Entity (Pref))\n-            then\n-               Siz := RM_Size (Entity (Pref));\n-\n-            --  Case of known Esize of a type\n-\n-            elsif Id = Attribute_Object_Size\n-              and then Is_Entity_Name (Pref)\n-              and then Is_Type (Entity (Pref))\n-              and then Known_Static_Esize (Entity (Pref))\n-            then\n-               Siz := Esize (Entity (Pref));\n-\n-            --  Case of known size of object\n-\n-            elsif Id = Attribute_Size\n-              and then Is_Entity_Name (Pref)\n-              and then Is_Object (Entity (Pref))\n-              and then Known_Esize (Entity (Pref))\n-              and then Known_Static_Esize (Entity (Pref))\n-            then\n-               Siz := Esize (Entity (Pref));\n-\n-            --  For an array component, we can do Size in the front end if the\n-            --  component_size of the array is set.\n-\n-            elsif Nkind (Pref) = N_Indexed_Component then\n-               Siz := Component_Size (Etype (Prefix (Pref)));\n-\n-            --  For a record component, we can do Size in the front end if\n-            --  there is a component clause, or if the record is packed and the\n-            --  component's size is known at compile time.\n-\n-            elsif Nkind (Pref) = N_Selected_Component then\n-               declare\n-                  Rec  : constant Entity_Id := Etype (Prefix (Pref));\n-                  Comp : constant Entity_Id := Entity (Selector_Name (Pref));\n-\n-               begin\n-                  if Present (Component_Clause (Comp)) then\n-                     Siz := Esize (Comp);\n-\n-                  elsif Is_Packed (Rec) then\n-                     Siz := RM_Size (Ptyp);\n-\n-                  else\n-                     Apply_Universal_Integer_Attribute_Checks (N);\n-                     return;\n-                  end if;\n-               end;\n-\n-            --  All other cases are handled by the back end\n-\n-            else\n-               Apply_Universal_Integer_Attribute_Checks (N);\n-\n-               --  If Size is applied to a formal parameter that is of a packed\n-               --  array subtype, then apply Size to the actual subtype.\n-\n-               if Is_Entity_Name (Pref)\n-                 and then Is_Formal (Entity (Pref))\n-                 and then Is_Array_Type (Ptyp)\n-                 and then Is_Packed (Ptyp)\n-               then\n-                  Rewrite (N,\n-                    Make_Attribute_Reference (Loc,\n-                      Prefix         =>\n-                        New_Occurrence_Of (Get_Actual_Subtype (Pref), Loc),\n-                      Attribute_Name => Name_Size));\n-                  Analyze_And_Resolve (N, Typ);\n-               end if;\n-\n-               --  If Size applies to a dereference of an access to\n-               --  unconstrained packed array, the back end needs to see its\n-               --  unconstrained nominal type, but also a hint to the actual\n-               --  constrained type.\n-\n-               if Nkind (Pref) = N_Explicit_Dereference\n-                 and then Is_Array_Type (Ptyp)\n-                 and then not Is_Constrained (Ptyp)\n-                 and then Is_Packed (Ptyp)\n-               then\n-                  Set_Actual_Designated_Subtype (Pref,\n-                    Get_Actual_Subtype (Pref));\n-               end if;\n-\n-               return;\n             end if;\n \n-            --  Common processing for record and array component case\n+            --  Call Expand_Size_Attribute to do the final part of the\n+            --  expansion which is shared with GNATprove expansion.\n \n-            if Siz /= No_Uint and then Siz /= 0 then\n-               declare\n-                  CS : constant Boolean := Comes_From_Source (N);\n-\n-               begin\n-                  Rewrite (N, Make_Integer_Literal (Loc, Siz));\n-\n-                  --  This integer literal is not a static expression. We do\n-                  --  not call Analyze_And_Resolve here, because this would\n-                  --  activate the circuit for deciding that a static value\n-                  --  was out of range, and we don't want that.\n-\n-                  --  So just manually set the type, mark the expression as\n-                  --  non-static, and then ensure that the result is checked\n-                  --  properly if the attribute comes from source (if it was\n-                  --  internally generated, we never need a constraint check).\n-\n-                  Set_Etype (N, Typ);\n-                  Set_Is_Static_Expression (N, False);\n-\n-                  if CS then\n-                     Apply_Constraint_Check (N, Typ);\n-                  end if;\n-               end;\n-            end if;\n+            Expand_Size_Attribute (N);\n          end Size;\n \n       ------------------\n@@ -7608,6 +7491,140 @@ package body Exp_Attr is\n       end if;\n    end Expand_Pred_Succ_Attribute;\n \n+   ---------------------------\n+   -- Expand_Size_Attribute --\n+   ---------------------------\n+\n+   procedure Expand_Size_Attribute (N : Node_Id) is\n+      Loc   : constant Source_Ptr   := Sloc (N);\n+      Typ   : constant Entity_Id    := Etype (N);\n+      Pref  : constant Node_Id      := Prefix (N);\n+      Ptyp  : constant Entity_Id    := Etype (Pref);\n+      Id    : constant Attribute_Id := Get_Attribute_Id (Attribute_Name (N));\n+      Siz   : Uint;\n+\n+   begin\n+      --  Case of known RM_Size of a type\n+\n+      if (Id = Attribute_Size or else Id = Attribute_Value_Size)\n+        and then Is_Entity_Name (Pref)\n+        and then Is_Type (Entity (Pref))\n+        and then Known_Static_RM_Size (Entity (Pref))\n+      then\n+         Siz := RM_Size (Entity (Pref));\n+\n+      --  Case of known Esize of a type\n+\n+      elsif Id = Attribute_Object_Size\n+        and then Is_Entity_Name (Pref)\n+        and then Is_Type (Entity (Pref))\n+        and then Known_Static_Esize (Entity (Pref))\n+      then\n+         Siz := Esize (Entity (Pref));\n+\n+      --  Case of known size of object\n+\n+      elsif Id = Attribute_Size\n+        and then Is_Entity_Name (Pref)\n+        and then Is_Object (Entity (Pref))\n+        and then Known_Esize (Entity (Pref))\n+        and then Known_Static_Esize (Entity (Pref))\n+      then\n+         Siz := Esize (Entity (Pref));\n+\n+      --  For an array component, we can do Size in the front end if the\n+      --  component_size of the array is set.\n+\n+      elsif Nkind (Pref) = N_Indexed_Component then\n+         Siz := Component_Size (Etype (Prefix (Pref)));\n+\n+      --  For a record component, we can do Size in the front end if there is a\n+      --  component clause, or if the record is packed and the component's size\n+      --  is known at compile time.\n+\n+      elsif Nkind (Pref) = N_Selected_Component then\n+         declare\n+            Rec  : constant Entity_Id := Etype (Prefix (Pref));\n+            Comp : constant Entity_Id := Entity (Selector_Name (Pref));\n+\n+         begin\n+            if Present (Component_Clause (Comp)) then\n+               Siz := Esize (Comp);\n+\n+            elsif Is_Packed (Rec) then\n+               Siz := RM_Size (Ptyp);\n+\n+            else\n+               Apply_Universal_Integer_Attribute_Checks (N);\n+               return;\n+            end if;\n+         end;\n+\n+      --  All other cases are handled by the back end\n+\n+      else\n+         Apply_Universal_Integer_Attribute_Checks (N);\n+\n+         --  If Size is applied to a formal parameter that is of a packed\n+         --  array subtype, then apply Size to the actual subtype.\n+\n+         if Is_Entity_Name (Pref)\n+           and then Is_Formal (Entity (Pref))\n+           and then Is_Array_Type (Ptyp)\n+           and then Is_Packed (Ptyp)\n+         then\n+            Rewrite (N,\n+              Make_Attribute_Reference (Loc,\n+                Prefix         =>\n+                  New_Occurrence_Of (Get_Actual_Subtype (Pref), Loc),\n+                Attribute_Name => Name_Size));\n+            Analyze_And_Resolve (N, Typ);\n+         end if;\n+\n+         --  If Size applies to a dereference of an access to unconstrained\n+         --  packed array, the back end needs to see its unconstrained nominal\n+         --  type, but also a hint to the actual constrained type.\n+\n+         if Nkind (Pref) = N_Explicit_Dereference\n+           and then Is_Array_Type (Ptyp)\n+           and then not Is_Constrained (Ptyp)\n+           and then Is_Packed (Ptyp)\n+         then\n+            Set_Actual_Designated_Subtype (Pref, Get_Actual_Subtype (Pref));\n+         end if;\n+\n+         return;\n+      end if;\n+\n+      --  Common processing for record and array component case\n+\n+      if Siz /= No_Uint and then Siz /= 0 then\n+         declare\n+            CS : constant Boolean := Comes_From_Source (N);\n+\n+         begin\n+            Rewrite (N, Make_Integer_Literal (Loc, Siz));\n+\n+            --  This integer literal is not a static expression. We do not\n+            --  call Analyze_And_Resolve here, because this would activate\n+            --  the circuit for deciding that a static value was out of range,\n+            --  and we don't want that.\n+\n+            --  So just manually set the type, mark the expression as\n+            --  nonstatic, and then ensure that the result is checked\n+            --  properly if the attribute comes from source (if it was\n+            --  internally generated, we never need a constraint check).\n+\n+            Set_Etype (N, Typ);\n+            Set_Is_Static_Expression (N, False);\n+\n+            if CS then\n+               Apply_Constraint_Check (N, Typ);\n+            end if;\n+         end;\n+      end if;\n+   end Expand_Size_Attribute;\n+\n    -----------------------------\n    -- Expand_Update_Attribute --\n    -----------------------------"}, {"sha": "8ca9b10c127aa80b3855efa96eae9cd8b3cd516b", "filename": "gcc/ada/exp_attr.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d39f6b24d401c8a945fae1488de0dea2252ec7ae/gcc%2Fada%2Fexp_attr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d39f6b24d401c8a945fae1488de0dea2252ec7ae/gcc%2Fada%2Fexp_attr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.ads?ref=d39f6b24d401c8a945fae1488de0dea2252ec7ae", "patch": "@@ -31,4 +31,9 @@ package Exp_Attr is\n \n    procedure Expand_N_Attribute_Reference (N : Node_Id);\n \n+   procedure Expand_Size_Attribute (N : Node_Id);\n+   --  Handles part of the expansion of attributes 'Object_Size, 'Size,\n+   --  'Value_Size, and 'VADS_Size, so that it can also be used in the special\n+   --  expansion in GNATprove mode.\n+\n end Exp_Attr;"}, {"sha": "ea1381c97cf3d1a730078c9229b47dd1b782887e", "filename": "gcc/ada/exp_spark.adb", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d39f6b24d401c8a945fae1488de0dea2252ec7ae/gcc%2Fada%2Fexp_spark.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d39f6b24d401c8a945fae1488de0dea2252ec7ae/gcc%2Fada%2Fexp_spark.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_spark.adb?ref=d39f6b24d401c8a945fae1488de0dea2252ec7ae", "patch": "@@ -227,6 +227,13 @@ package body Exp_SPARK is\n             end if;\n          end;\n \n+      elsif Attr_Id = Attribute_Object_Size\n+        or else Attr_Id = Attribute_Size\n+        or else Attr_Id = Attribute_Value_Size\n+        or else Attr_Id = Attribute_VADS_Size\n+      then\n+         Exp_Attr.Expand_Size_Attribute (N);\n+\n       --  For attributes which return Universal_Integer, introduce a conversion\n       --  to the expected type with the appropriate check flags set.\n \n@@ -241,10 +248,6 @@ package body Exp_SPARK is\n         or else Attr_Id = Attribute_Pos\n         or else Attr_Id = Attribute_Position\n         or else Attr_Id = Attribute_Range_Length\n-        or else Attr_Id = Attribute_Object_Size\n-        or else Attr_Id = Attribute_Size\n-        or else Attr_Id = Attribute_Value_Size\n-        or else Attr_Id = Attribute_VADS_Size\n         or else Attr_Id = Attribute_Aft\n         or else Attr_Id = Attribute_Max_Alignment_For_Allocation\n       then"}]}