{"sha": "354d4c68c6e258ffa3341febb7e54ca51685a0e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzU0ZDRjNjhjNmUyNThmZmEzMzQxZmViYjdlNTRjYTUxNjg1YTBlNQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2004-04-01T21:47:59Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2004-04-01T21:47:59Z"}, "message": "mt_allocator.h (__mt_alloc<>::_S_initialize): Streamline the second half...\n\n2004-04-01  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/ext/mt_allocator.h (__mt_alloc<>::_S_initialize):\n\tStreamline the second half, wrapping it in a single\n\t'#ifdef __GTHREADS if (__gthread_active_p())' and avoiding\n\tconditionals inside loops.\n\nFrom-SVN: r80323", "tree": {"sha": "46f7e93041285ece3dffa3552c6de6b96190c5ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/46f7e93041285ece3dffa3552c6de6b96190c5ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/354d4c68c6e258ffa3341febb7e54ca51685a0e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/354d4c68c6e258ffa3341febb7e54ca51685a0e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/354d4c68c6e258ffa3341febb7e54ca51685a0e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/354d4c68c6e258ffa3341febb7e54ca51685a0e5/comments", "author": null, "committer": null, "parents": [{"sha": "6407bc6703d1a33e231e73faabffb6ba2e15ce8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6407bc6703d1a33e231e73faabffb6ba2e15ce8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6407bc6703d1a33e231e73faabffb6ba2e15ce8d"}], "stats": {"total": 81, "additions": 38, "deletions": 43}, "files": [{"sha": "b47d26e0a3dee4c0084f2766aaee489830ea9040", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/354d4c68c6e258ffa3341febb7e54ca51685a0e5/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/354d4c68c6e258ffa3341febb7e54ca51685a0e5/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=354d4c68c6e258ffa3341febb7e54ca51685a0e5", "patch": "@@ -1,3 +1,10 @@\n+2004-04-01  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/ext/mt_allocator.h (__mt_alloc<>::_S_initialize):\n+\tStreamline the second half, wrapping it in a single\n+\t'#ifdef __GTHREADS if (__gthread_active_p())' and avoiding\n+\tconditionals inside loops.\n+\n 2004-04-01  Paolo Carlini  <pcarlini@suse.de>\n \n \tPR libstdc++/14775"}, {"sha": "8edbaaaf50fb7fddfff82ba4da31bac79c046f1f", "filename": "libstdc++-v3/include/ext/mt_allocator.h", "status": "modified", "additions": 31, "deletions": 43, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/354d4c68c6e258ffa3341febb7e54ca51685a0e5/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/354d4c68c6e258ffa3341febb7e54ca51685a0e5/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h?ref=354d4c68c6e258ffa3341febb7e54ca51685a0e5", "patch": "@@ -151,12 +151,7 @@ namespace __gnu_cxx\n \texplicit _Tune()\n \t: _M_max_bytes(128), _M_min_bin(8),\n \t  _M_chunk_size(4096 - 4 * sizeof(void*)), \n-#ifdef __GTHREADS\n-\t  _M_max_threads(4096), \n-#else\n-\t  _M_max_threads(0), \n-#endif\n-\t  _M_freelist_headroom(10), \n+\t  _M_max_threads(4096), _M_freelist_headroom(10), \n \t  _M_force_new(getenv(\"GLIBCXX_FORCE_NEW\") ? true : false) \n \t{ }      \n \n@@ -230,7 +225,7 @@ namespace __gnu_cxx\n \n       union _Block_record\n       {\n-\t// Points to the next block_record for its thread_id.\n+\t// Points to the block_record of the next free block.\n         _Block_record* volatile         _M_next;\n \n \t// The thread id of the thread which has requested this block.\n@@ -522,10 +517,13 @@ namespace __gnu_cxx\n           *__bp++ = __bint;\n         }\n \n+      // Initialize _S_bin and its members.\n+      void* __v = ::operator new(sizeof(_Bin_record) * _S_bin_size);\n+      _S_bin = static_cast<_Bin_record*>(__v);\n+\n       // If __gthread_active_p() create and initialize the list of\n       // free thread ids. Single threaded applications use thread id 0\n       // directly and have no need for this.\n-      void* __v;\n #ifdef __GTHREADS\n       if (__gthread_active_p())\n         {\n@@ -554,29 +552,14 @@ namespace __gnu_cxx\n           // Initialize per thread key to hold pointer to\n           // _S_thread_freelist.\n           __gthread_key_create(&_S_thread_key, _S_destroy_thread_key);\n-        }\n-#endif\n \n-      // Initialize _S_bin and its members.\n-      __v = ::operator new(sizeof(_Bin_record) * _S_bin_size);\n-      _S_bin = static_cast<_Bin_record*>(__v);\n-\t\n-      // Maximum number of threads. \n-      size_t __max_threads = 1;\n-#ifdef __GTHREADS\n-      if (__gthread_active_p())\n-        __max_threads = _S_options._M_max_threads + 1;\n-#endif\n-\n-      for (size_t __n = 0; __n < _S_bin_size; ++__n)\n-        {\n-\t  _Bin_record& __bin = _S_bin[__n];\n-\t  __v = ::operator new(sizeof(_Block_record*) * __max_threads);\n-          __bin._M_first = static_cast<_Block_record**>(__v);\n+\t  const size_t __max_threads = _S_options._M_max_threads + 1;\n+\t  for (size_t __n = 0; __n < _S_bin_size; ++__n)\n+\t    {\n+\t      _Bin_record& __bin = _S_bin[__n];\n+\t      __v = ::operator new(sizeof(_Block_record*) * __max_threads);\n+\t      __bin._M_first = static_cast<_Block_record**>(__v);\n \n-#ifdef __GTHREADS\n-          if (__gthread_active_p())\n-            {\n \t      __v = ::operator new(sizeof(size_t) * __max_threads);\n               __bin._M_free = static_cast<size_t*>(__v);\n \n@@ -595,21 +578,26 @@ namespace __gnu_cxx\n #else\n               { __GTHREAD_MUTEX_INIT_FUNCTION(__bin._M_mutex); }\n #endif\n-            }\n-#endif\n \n-          for (size_t __threadn = 0; __threadn < __max_threads; ++__threadn)\n-            {\n-              __bin._M_first[__threadn] = NULL;\n-#ifdef __GTHREADS\n-              if (__gthread_active_p())\n-                {\n-                  __bin._M_free[__threadn] = 0;\n-                  __bin._M_used[__threadn] = 0;\n-                }\n-#endif\n-            }\n-        }\n+\t      for (size_t __threadn = 0; __threadn < __max_threads;\n+\t\t   ++__threadn)\n+\t\t{\n+\t\t  __bin._M_first[__threadn] = NULL;\n+\t\t  __bin._M_free[__threadn] = 0;\n+\t\t  __bin._M_used[__threadn] = 0;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+#endif\t\n+\tfor (size_t __n = 0; __n < _S_bin_size; ++__n)\n+\t  {\n+\t    _Bin_record& __bin = _S_bin[__n];\n+\t    __v = ::operator new(sizeof(_Block_record*));\n+\t    __bin._M_first = static_cast<_Block_record**>(__v);\n+\t    __bin._M_first[0] = NULL;\n+\t  }\n+\n       _S_init = true;\n     }\n "}]}