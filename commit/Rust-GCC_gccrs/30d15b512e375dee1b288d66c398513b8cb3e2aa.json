{"sha": "30d15b512e375dee1b288d66c398513b8cb3e2aa", "node_id": "C_kwDOANBUbNoAKDMwZDE1YjUxMmUzNzVkZWUxYjI4OGQ2NmMzOTg1MTNiOGNiM2UyYWE", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2022-02-03T20:59:39Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2022-02-03T20:59:39Z"}, "message": "Enable pointer_query caching in -Wrestrict.\n\ngcc/ChangeLog:\n\n\t* gimple-ssa-warn-restrict.cc (class pass_wrestrict): Outline ctor.\n\t(pass_wrestrict::m_ptr_qry): New member.\n\t(wrestrict_walk): Rename...\n\t(pass_wrestrict::check_block): ...to this.\n\t(pass_wrestrict::execute): Set up and tear down pointer_query and\n\tranger.\n\t(builtin_memref::builtin_memref): Change ctor argument.  Simplify.\n\t(builtin_access::builtin_access): Same.\n\t(builtin_access::m_ptr_qry): New member.\n\t(check_call): Rename...\n\t(pass_wrestrict::check_call): ...to this.\n\t(check_bounds_or_overlap): Change argument.\n\t* gimple-ssa-warn-restrict.h (check_bounds_or_overlap): Same.", "tree": {"sha": "c7b61bd35b5323b8b7000761cee3270d32f82dda", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c7b61bd35b5323b8b7000761cee3270d32f82dda"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/30d15b512e375dee1b288d66c398513b8cb3e2aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30d15b512e375dee1b288d66c398513b8cb3e2aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30d15b512e375dee1b288d66c398513b8cb3e2aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30d15b512e375dee1b288d66c398513b8cb3e2aa/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a62b740d7b8bff2d8b5578d01d00e5fe464e5325", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a62b740d7b8bff2d8b5578d01d00e5fe464e5325", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a62b740d7b8bff2d8b5578d01d00e5fe464e5325"}], "stats": {"total": 128, "additions": 61, "deletions": 67}, "files": [{"sha": "b678e806da373a109d1e24765970bb4112c5feef", "filename": "gcc/gimple-ssa-warn-restrict.cc", "status": "modified", "additions": 60, "deletions": 66, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30d15b512e375dee1b288d66c398513b8cb3e2aa/gcc%2Fgimple-ssa-warn-restrict.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30d15b512e375dee1b288d66c398513b8cb3e2aa/gcc%2Fgimple-ssa-warn-restrict.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-restrict.cc?ref=30d15b512e375dee1b288d66c398513b8cb3e2aa", "patch": "@@ -62,46 +62,61 @@ const pass_data pass_data_wrestrict = {\n class pass_wrestrict : public gimple_opt_pass\n {\n  public:\n-  pass_wrestrict (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_wrestrict, ctxt)\n-    { }\n-\n-  opt_pass *clone () { return new pass_wrestrict (m_ctxt); }\n+  pass_wrestrict (gcc::context *);\n \n   virtual bool gate (function *);\n   virtual unsigned int execute (function *);\n+\n+  void check_call (gimple *);\n+\n+  void check_block (basic_block);\n+\n+  /* A pointer_query object to store information about pointers and\n+     their targets in.  */\n+  pointer_query m_ptr_qry;\n };\n \n+pass_wrestrict::pass_wrestrict (gcc::context *ctxt)\n+  : gimple_opt_pass (pass_data_wrestrict, ctxt),\n+    m_ptr_qry ()\n+{ }\n+\n bool\n pass_wrestrict::gate (function *fun ATTRIBUTE_UNUSED)\n {\n   return warn_array_bounds || warn_restrict || warn_stringop_overflow;\n }\n \n-static void check_call (range_query *, gimple *);\n-\n-static void\n-wrestrict_walk (range_query *query, basic_block bb)\n+void\n+pass_wrestrict::check_block (basic_block bb)\n {\n   /* Iterate over statements, looking for function calls.  */\n-  for (gimple_stmt_iterator si = gsi_start_bb (bb); !gsi_end_p (si);\n-       gsi_next (&si))\n+  for (auto si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n     {\n       gimple *stmt = gsi_stmt (si);\n       if (!is_gimple_call (stmt))\n \tcontinue;\n \n-      check_call (query, stmt);\n+      check_call (stmt);\n     }\n }\n \n unsigned\n pass_wrestrict::execute (function *fun)\n {\n-  gimple_ranger ranger;\n+  /* Create a new ranger instance and associate it with FUN.  */\n+  m_ptr_qry.rvals = enable_ranger (fun);\n+\n   basic_block bb;\n   FOR_EACH_BB_FN (bb, fun)\n-    wrestrict_walk (&ranger, bb);\n+    check_block (bb);\n+\n+  m_ptr_qry.flush_cache ();\n+\n+  /* Release the ranger instance and replace it with a global ranger.\n+     Also reset the pointer since calling disable_ranger() deletes it.  */\n+  disable_ranger (fun);\n+  m_ptr_qry.rvals = NULL;\n \n   return 0;\n }\n@@ -145,15 +160,15 @@ class builtin_memref\n      only the destination reference is.  */\n   bool strbounded_p;\n \n-  builtin_memref (range_query *, gimple *, tree, tree);\n+  builtin_memref (pointer_query &, gimple *, tree, tree);\n \n   tree offset_out_of_bounds (int, offset_int[3]) const;\n \n private:\n   /* Call statement to the built-in.  */\n   gimple *stmt;\n \n-  range_query *query;\n+  pointer_query &m_ptr_qry;\n \n   /* Ctor helper to set or extend OFFRANGE based on argument.  */\n   void extend_offset_range (tree);\n@@ -187,7 +202,8 @@ class builtin_access\n \t    && detect_overlap != &builtin_access::no_overlap);\n   }\n \n-  builtin_access (range_query *, gimple *, builtin_memref &, builtin_memref &);\n+  builtin_access (pointer_query &, gimple *,\n+\t\t  builtin_memref &, builtin_memref &);\n \n   /* Entry point to determine overlap.  */\n   bool overlap ();\n@@ -225,7 +241,7 @@ class builtin_access\n    a size SIZE in bytes.  If SIZE is NULL_TREE then the size is assumed\n    to be unknown.  STMT is the statement in which expr appears in.  */\n \n-builtin_memref::builtin_memref (range_query *query, gimple *stmt, tree expr,\n+builtin_memref::builtin_memref (pointer_query &ptrqry, gimple *stmt, tree expr,\n \t\t\t\ttree size)\n : ptr (expr),\n   ref (),\n@@ -238,7 +254,7 @@ builtin_memref::builtin_memref (range_query *query, gimple *stmt, tree expr,\n   maxobjsize (tree_to_shwi (max_object_size ())),\n   strbounded_p (),\n   stmt (stmt),\n-  query (query)\n+  m_ptr_qry (ptrqry)\n {\n   /* Unfortunately, wide_int default ctor is a no-op so array members\n      of the type must be set individually.  */\n@@ -257,7 +273,7 @@ builtin_memref::builtin_memref (range_query *query, gimple *stmt, tree expr,\n       tree range[2];\n       /* Determine the size range, allowing for the result to be [0, 0]\n \t for SIZE in the anti-range ~[0, N] where N >= PTRDIFF_MAX.  */\n-      get_size_range (query, size, stmt, range, SR_ALLOW_ZERO);\n+      get_size_range (m_ptr_qry.rvals, size, stmt, range, SR_ALLOW_ZERO);\n       sizrange[0] = wi::to_offset (range[0]);\n       sizrange[1] = wi::to_offset (range[1]);\n       /* get_size_range returns SIZE_MAX for the maximum size.\n@@ -334,9 +350,9 @@ builtin_memref::extend_offset_range (tree offset)\n       /* A pointer offset is represented as sizetype but treated\n \t as signed.  */\n       wide_int min, max;\n-      value_range_kind rng;\n+      value_range_kind rng = VR_VARYING;\n       value_range vr;\n-      if (query && query->range_of_expr (vr, offset, stmt))\n+      if (m_ptr_qry.rvals->range_of_expr (vr, offset, stmt))\n \t{\n \t  rng = vr.kind ();\n \t  if (!vr.undefined_p ())\n@@ -345,19 +361,7 @@ builtin_memref::extend_offset_range (tree offset)\n \t      max = wi::to_wide (vr.max ());\n \t    }\n \t}\n-      else\n-\t{\n-\t  /* There is a global version here because\n-\t     check_bounds_or_overlap may be called from gimple\n-\t     fold during gimple lowering.  */\n-\t  get_range_query (cfun)->range_of_expr (vr, offset, stmt);\n-\t  rng = vr.kind ();\n-\t  if (!vr.undefined_p ())\n-\t    {\n-\t      min = wi::to_wide (vr.min ());\n-\t      max = wi::to_wide (vr.max ());\n-\t    }\n-\t}\n+\n       if (rng == VR_ANTI_RANGE && wi::lts_p (max, min))\n \t{\n \t  /* Convert an anti-range whose upper bound is less than\n@@ -674,7 +678,7 @@ builtin_memref::offset_out_of_bounds (int strict, offset_int ooboff[3]) const\n /* Create an association between the memory references DST and SRC\n    for access by a call EXPR to a memory or string built-in funtion.  */\n \n-builtin_access::builtin_access (range_query *query, gimple *call,\n+builtin_access::builtin_access (pointer_query &ptrqry, gimple *call,\n \t\t\t\tbuiltin_memref &dst,\n \t\t\t\tbuiltin_memref &src)\n : dstref (&dst), srcref (&src), sizrange (), ovloff (), ovlsiz (),\n@@ -766,39 +770,28 @@ builtin_access::builtin_access (range_query *query, gimple *call,\n       return;\n     }\n \n-  const offset_int maxobjsize = dst.maxobjsize;\n-\n   /* Try to determine the size of the base object.  compute_objsize\n      expects a pointer so create one if BASE is a non-pointer object.  */\n-  tree addr;\n   if (dst.basesize < 0)\n     {\n-      addr = dst.base;\n-      if (!POINTER_TYPE_P (TREE_TYPE (addr)))\n-\taddr = build1 (ADDR_EXPR, (TREE_TYPE (addr)), addr);\n-\n-      if (tree dstsize = compute_objsize (addr, call, ostype))\n-\tdst.basesize = wi::to_offset (dstsize);\n-      else if (POINTER_TYPE_P (TREE_TYPE (addr)))\n-\tdst.basesize = HOST_WIDE_INT_MIN;\n+      access_ref aref;\n+      if (ptrqry.get_ref (dst.base, call, &aref, ostype) && aref.base0)\n+\tdst.basesize = aref.sizrng[1];\n       else\n-\tdst.basesize = maxobjsize;\n+\tdst.basesize = HOST_WIDE_INT_MIN;\n     }\n \n   if (src.base && src.basesize < 0)\n     {\n-      addr = src.base;\n-      if (!POINTER_TYPE_P (TREE_TYPE (addr)))\n-\taddr = build1 (ADDR_EXPR, (TREE_TYPE (addr)), addr);\n-\n-      if (tree srcsize = compute_objsize (addr, call, ostype))\n-\tsrc.basesize = wi::to_offset (srcsize);\n-      else if (POINTER_TYPE_P (TREE_TYPE (addr)))\n-\tsrc.basesize = HOST_WIDE_INT_MIN;\n+      access_ref aref;\n+      if (ptrqry.get_ref (src.base, call, &aref, ostype) && aref.base0)\n+\tsrc.basesize = aref.sizrng[1];\n       else\n-\tsrc.basesize = maxobjsize;\n+\tsrc.basesize = HOST_WIDE_INT_MIN;\n     }\n \n+  const offset_int maxobjsize = dst.maxobjsize;\n+\n   /* Make adjustments for references to the same object by string\n      built-in functions to reflect the constraints imposed by\n      the function.  */\n@@ -814,7 +807,7 @@ builtin_access::builtin_access (range_query *query, gimple *call,\n \n       tree size = gimple_call_arg (call, sizeargno);\n       tree range[2];\n-      if (get_size_range (query, size, call, range, true))\n+      if (get_size_range (ptrqry.rvals, size, call, range, true))\n \t{\n \t  bounds[0] = wi::to_offset (range[0]);\n \t  bounds[1] = wi::to_offset (range[1]);\n@@ -1895,8 +1888,8 @@ maybe_diag_access_bounds (gimple *call, tree func, int strict,\n /* Check a CALL statement for restrict-violations and issue warnings\n    if/when appropriate.  */\n \n-static void\n-check_call (range_query *query, gimple *call)\n+void\n+pass_wrestrict::check_call (gimple *call)\n {\n   /* Avoid checking the call if it has already been diagnosed for\n      some reason.  */\n@@ -1986,7 +1979,7 @@ check_call (range_query *query, gimple *call)\n       || (dstwr && !INTEGRAL_TYPE_P (TREE_TYPE (dstwr))))\n     return;\n \n-  opt_code opt = check_bounds_or_overlap (query, call, dst, src, dstwr,\n+  opt_code opt = check_bounds_or_overlap (m_ptr_qry, call, dst, src, dstwr,\n \t\t\t\t\t  NULL_TREE);\n   /* Avoid diagnosing the call again.  */\n   suppress_warning (call, opt);\n@@ -2006,25 +1999,26 @@ check_bounds_or_overlap (gimple *call, tree dst, tree src, tree dstsize,\n \t\t\t tree srcsize, bool bounds_only /* = false */,\n \t\t\t bool do_warn /* = true */)\n {\n-  return check_bounds_or_overlap (/*range_query=*/NULL,\n+  pointer_query ptrqry (get_range_query (cfun));\n+  return check_bounds_or_overlap (ptrqry,\n \t\t\t\t  call, dst, src, dstsize, srcsize,\n \t\t\t\t  bounds_only, do_warn);\n }\n \n opt_code\n-check_bounds_or_overlap (range_query *query,\n+check_bounds_or_overlap (pointer_query &ptrqry,\n \t\t\t gimple *call, tree dst, tree src, tree dstsize,\n \t\t\t tree srcsize, bool bounds_only /* = false */,\n \t\t\t bool do_warn /* = true */)\n {\n   tree func = gimple_call_fndecl (call);\n \n-  builtin_memref dstref (query, call, dst, dstsize);\n-  builtin_memref srcref (query, call, src, srcsize);\n+  builtin_memref dstref (ptrqry, call, dst, dstsize);\n+  builtin_memref srcref (ptrqry, call, src, srcsize);\n \n   /* Create a descriptor of the access.  This may adjust both DSTREF\n      and SRCREF based on one another and the kind of the access.  */\n-  builtin_access acs (query, call, dstref, srcref);\n+  builtin_access acs (ptrqry, call, dstref, srcref);\n \n   /* Set STRICT to the value of the -Warray-bounds=N argument for\n      string functions or when N > 1.  */"}, {"sha": "2bdde030023859e14b2046a1b10a8b327d54d8b3", "filename": "gcc/gimple-ssa-warn-restrict.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30d15b512e375dee1b288d66c398513b8cb3e2aa/gcc%2Fgimple-ssa-warn-restrict.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30d15b512e375dee1b288d66c398513b8cb3e2aa/gcc%2Fgimple-ssa-warn-restrict.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-restrict.h?ref=30d15b512e375dee1b288d66c398513b8cb3e2aa", "patch": "@@ -22,7 +22,7 @@\n \n extern opt_code check_bounds_or_overlap (gimple *, tree, tree, tree, tree,\n \t\t\t\t\t bool = false, bool = true);\n-extern opt_code check_bounds_or_overlap (class range_query *, gimple *,\n+extern opt_code check_bounds_or_overlap (class pointer_query &, gimple *,\n \t\t\t\t\t tree, tree, tree, tree,\n \t\t\t\t\t bool = false, bool = true);\n "}]}