{"sha": "43962ff925c94f949faff364c7d4ac9c223012db", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDM5NjJmZjkyNWM5NGY5NDlmYWZmMzY0YzdkNGFjOWMyMjMwMTJkYg==", "commit": {"author": {"name": "Andrew John Hughes", "email": "gnu_andrew@member.fsf.org", "date": "2004-11-07T11:55:09Z"}, "committer": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2004-11-07T11:55:09Z"}, "message": "2004-11-07  Andrew John Hughes <gnu_andrew@member.fsf.org>\n\n       * java/util/GregorianCalendar.java\n       Added/amended documentation.\n\nFrom-SVN: r90228", "tree": {"sha": "c5094227f3f08a858dea19b1186955b7d6253b56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c5094227f3f08a858dea19b1186955b7d6253b56"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/43962ff925c94f949faff364c7d4ac9c223012db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43962ff925c94f949faff364c7d4ac9c223012db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43962ff925c94f949faff364c7d4ac9c223012db", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43962ff925c94f949faff364c7d4ac9c223012db/comments", "author": {"login": "gnu-andrew", "id": 962817, "node_id": "MDQ6VXNlcjk2MjgxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/962817?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gnu-andrew", "html_url": "https://github.com/gnu-andrew", "followers_url": "https://api.github.com/users/gnu-andrew/followers", "following_url": "https://api.github.com/users/gnu-andrew/following{/other_user}", "gists_url": "https://api.github.com/users/gnu-andrew/gists{/gist_id}", "starred_url": "https://api.github.com/users/gnu-andrew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gnu-andrew/subscriptions", "organizations_url": "https://api.github.com/users/gnu-andrew/orgs", "repos_url": "https://api.github.com/users/gnu-andrew/repos", "events_url": "https://api.github.com/users/gnu-andrew/events{/privacy}", "received_events_url": "https://api.github.com/users/gnu-andrew/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "70c67ff596d487c37654ae39e57517da1994723b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70c67ff596d487c37654ae39e57517da1994723b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70c67ff596d487c37654ae39e57517da1994723b"}], "stats": {"total": 298, "additions": 240, "deletions": 58}, "files": [{"sha": "2c977f3f2667ba6a559b9b16cc14912fc192c94a", "filename": "libjava/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43962ff925c94f949faff364c7d4ac9c223012db/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43962ff925c94f949faff364c7d4ac9c223012db/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=43962ff925c94f949faff364c7d4ac9c223012db", "patch": "@@ -1,3 +1,8 @@\n+2004-11-07  Andrew John Hughes <gnu_andrew@member.fsf.org>\n+\n+\t* java/util/GregorianCalendar.java\n+\tAdded/amended documentation.\n+\n 2004-11-07  Andrew John Hughes <gnu_andrew@member.fsf.org>\n \n \t* java/util/Collections.java"}, {"sha": "c54691c36a67bd28711bc7dbb69620374abbc7ac", "filename": "libjava/java/util/GregorianCalendar.java", "status": "modified", "additions": 235, "deletions": 58, "changes": 293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43962ff925c94f949faff364c7d4ac9c223012db/libjava%2Fjava%2Futil%2FGregorianCalendar.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43962ff925c94f949faff364c7d4ac9c223012db/libjava%2Fjava%2Futil%2FGregorianCalendar.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FGregorianCalendar.java?ref=43962ff925c94f949faff364c7d4ac9c223012db", "patch": "@@ -39,27 +39,104 @@\n \n package java.util;\n \n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+\n /**\n+ * <p>\n  * This class represents the Gregorian calendar, that is used in most\n  * countries all over the world.  It does also handle the Julian calendar\n  * for dates smaller than the date of the change to the Gregorian calendar.\n- * This change date is different from country to country, you can set it with\n- * <code>setGregorianChange</code>\n- *\n  * The Gregorian calendar differs from the Julian calendar by a different\n  * leap year rule (no leap year every 100 years, except if year is divisible\n- * by 400).  The non existing days that were omited when the change took\n- * place are interpreted as gregorian date\n- *\n- * There are to eras available for the Gregorian calendar, namely BC and AD.\n+ * by 400).  \n+ * </p>\n+ * <p>\n+ * This change date is different from country to country, and can be changed with\n+ * <code>setGregorianChange</code>.  The first countries to adopt the Gregorian\n+ * calendar did so on the 15th of October, 1582.  This date followed October\n+ * the 4th, 1582 in the Julian calendar system.  The non-existant days that were\n+ * omitted when the change took place are interpreted as Gregorian dates.\n+ * </p>\n+ * <p>\n+ * Prior to the changeover date, New Year's Day occurred on the 25th of March.\n+ * However, this class always takes New Year's Day as being the 1st of January.\n+ * Client code should manually adapt the year value, if required, for dates\n+ * between January the 1st and March the 24th in years prior to the changeover.\n+ * </p>\n+ * <p>\n+ * Any date infinitely forwards or backwards in time can be represented by\n+ * this class.  A <em>proleptic</em> calendar system is used, which allows\n+ * future dates to be created via the existing rules.  This allows meaningful\n+ * and consistent dates to be produced for all years.  However, dates are only\n+ * historically accurate following March the 1st, 4AD when the Julian calendar\n+ * system was adopted.  Prior to this, leap year rules were applied erraticly.\n+ * </p>\n+ * <p>\n+ * There are two eras available for the Gregorian calendar, namely BC and AD.\n+ * </p>\n+ * <p>\n+ * Weeks are defined as a period of seven days, beginning on the first day\n+ * of the week, as returned by <code>getFirstDayOfWeek()</code>, and ending\n+ * on the day prior to this.\n+ * </p>\n+ * <p>\n+ * The weeks of the year are numbered from 1 to a possible 53.  The first week\n+ * of the year is defined as the first week that contains at least the minimum\n+ * number of days of the first week in the new year (retrieved via\n+ * <code>getMinimalDaysInFirstWeek()</code>).  All weeks after this are numbered\n+ * from 2 onwards.\n+ * </p>\n+ * <p>\n+ * For example, take the year 2004.  It began on a Thursday.  The first week\n+ * of 2004 depends both on where a week begins and how long it must minimally\n+ * last.  Let's say that the week begins on a Monday and must have a minimum\n+ * of 5 days.  In this case, the first week begins on Monday, the 5th of January.\n+ * The first 4 days (Thursday to Sunday) are not eligible, as they are too few\n+ * to make up the minimum number of days of the first week which must be in\n+ * the new year.  If the minimum was lowered to 4 days, then the first week\n+ * would instead begin on Monday, the 29th of December, 2003.  This first week\n+ * has 4 of its days in the new year, and is now eligible.\n+ * </p>\n+ * <p>\n+ * The weeks of the month are numbered from 0 to a possible 6.  The first week\n+ * of the month (numbered 1) is a set of days, prior to the first day of the week,\n+ * which number at least the minimum number of days in a week.  Unlike the first\n+ * week of the year, the first week of the month only uses days from that particular\n+ * month.  As a consequence, it may have a variable number of days (from the minimum\n+ * number required up to a full week of 7) and it need not start on the first day of\n+ * the week.  It must, however, be following by the first day of the week, as this\n+ * marks the beginning of week 2.  Any days of the month which occur prior to the\n+ * first week (because the first day of the week occurs before the minimum number\n+ * of days is met) are seen as week 0.\n+ * </p>\n+ * <p>\n+ * Again, we will take the example of the year 2004 to demonstrate this.  September\n+ * 2004 begins on a Wednesday.  Taking our first day of the week as Monday, and the\n+ * minimum length of the first week as 6, we find that week 1 runs from Monday,\n+ * the 6th of September to Sunday the 12th.  Prior to the 6th, there are only\n+ * 5 days (Wednesday through to Sunday).  This is too small a number to meet the\n+ * minimum, so these are classed as being days in week 0.  Week 2 begins on the\n+ * 13th, and so on.  This changes if we reduce the minimum to 5.  In this case,\n+ * week 1 is a truncated week from Wednesday the 1st to Sunday the 5th, and week\n+ * 0 doesn't exist.  The first seven day week is week 2, starting on the 6th.\n+ * </p>\n+ * <p>\n+ * On using the <code>clear()</code> method, the Gregorian calendar returns\n+ * to its default value of the 1st of January, 1970 AD 00:00:00 (the epoch).\n+ * The day of the week is set to the correct day for that particular time.\n+ * The day is also the first of the month, and the date is in week 0.\n+ * </p>\n  *\n  * @see Calendar\n  * @see TimeZone\n+ * @see Calendar#getFirstDayOfWeek()\n+ * @see Calendar#getMinimalDaysInFirstWeek()\n  */\n public class GregorianCalendar extends Calendar\n {\n   /**\n-   * Constant representing the era BC (before Christ).\n+   * Constant representing the era BC (Before Christ).\n    */\n   public static final int BC = 0;\n   \n@@ -73,9 +150,15 @@ public class GregorianCalendar extends Calendar\n    * This is locale dependent; the default for most catholic\n    * countries is midnight (UTC) on October 5, 1582 (Julian),\n    * or October 15, 1582 (Gregorian).\n+   *\n+   * @serial the changeover point from the Julian calendar\n+   *         system to the Gregorian.\n    */\n   private long gregorianCutover;\n \n+  /**\n+   * For compatability with Sun's JDK.\n+   */\n   static final long serialVersionUID = -8125100834729963327L;\n \n   /**\n@@ -84,9 +167,12 @@ public class GregorianCalendar extends Calendar\n   private static final String bundleName = \"gnu.java.locale.Calendar\";\n \n   /**\n-   * get resource bundle:\n-   * The resources should be loaded via this method only. Iff an application\n-   * uses this method, the resourcebundle is required. --Fridi. \n+   * Retrieves the resource bundle.  The resources should be loaded\n+   * via this method only. Iff an application uses this method, the\n+   * resourcebundle is required.\n+   *\n+   * @param locale the locale in use for this calendar.\n+   * @return A resource bundle for the calendar for the specified locale.\n    */\n   private static ResourceBundle getBundle(Locale locale) \n   {\n@@ -105,7 +191,8 @@ public GregorianCalendar()\n   \n   /**\n    * Constructs a new GregorianCalender representing the current\n-   * time, using the specified time zone and the default locale.  \n+   * time, using the specified time zone and the default locale. \n+   * \n    * @param zone a time zone.\n    */\n   public GregorianCalendar(TimeZone zone)\n@@ -115,7 +202,8 @@ public GregorianCalendar(TimeZone zone)\n   \n   /**\n    * Constructs a new GregorianCalender representing the current\n-   * time, using the default time zone and the specified locale.  \n+   * time, using the default time zone and the specified locale.\n+   *  \n    * @param locale a locale.\n    */\n   public GregorianCalendar(Locale locale)\n@@ -126,6 +214,7 @@ public GregorianCalendar(Locale locale)\n   /**\n    * Constructs a new GregorianCalender representing the current\n    * time with the given time zone and the given locale.\n+   *\n    * @param zone a time zone.  \n    * @param locale a locale.  \n    */\n@@ -153,6 +242,7 @@ public GregorianCalendar(int year, int month, int day)\n   /**\n    * Constructs a new GregorianCalendar representing midnight on the\n    * given date with the default time zone and locale.\n+   *\n    * @param year corresponds to the YEAR time field.\n    * @param month corresponds to the MONTH time field.\n    * @param day corresponds to the DAY time field.\n@@ -168,6 +258,8 @@ public GregorianCalendar(int year, int month, int day, int hour, int minute)\n   /**\n    * Constructs a new GregorianCalendar representing midnight on the\n    * given date with the default time zone and locale.\n+   *\n+   *\n    * @param year corresponds to the YEAR time field.\n    * @param month corresponds to the MONTH time field.\n    * @param day corresponds to the DAY time field.\n@@ -187,6 +279,7 @@ public GregorianCalendar(int year, int month, int day,\n    * You can use <code>new Date(Long.MAX_VALUE)</code> to use a pure\n    * Julian calendar, or <code>Long.MIN_VALUE</code> for a pure Gregorian\n    * calendar.\n+   *\n    * @param date the date of the change.\n    */\n   public void setGregorianChange(Date date)\n@@ -196,6 +289,7 @@ public void setGregorianChange(Date date)\n \n   /**\n    * Gets the date of the switch from Julian dates to Gregorian dates.\n+   *\n    * @return the date of the change.\n    */\n   public final Date getGregorianChange()\n@@ -204,17 +298,21 @@ public final Date getGregorianChange()\n   }\n \n   /**\n+   * <p>\n    * Determines if the given year is a leap year.  The result is\n-   * undefined if the gregorian change took place in 1800, so that\n-   * the end of february is skiped and you give that year\n-   * (well...).<br>\n-   *\n-   * The year should be positive and you can't give an ERA.  But\n-   * remember that before 4 BC there wasn't a consistent leap year\n-   * rule, so who cares.\n+   * undefined if the Gregorian change took place in 1800, so that\n+   * the end of February is skipped, and that year is specified.\n+   * (well...).\n+   * </p>\n+   * <p>\n+   * To specify a year in the BC era, use a negative value calculated\n+   * as 1 - y, where y is the required year in BC.  So, 1 BC is 0,\n+   * 2 BC is -1, 3 BC is -2, etc.\n+   * </p>\n    *\n-   * @param year a year use nonnegative value for BC.\n-   * @return true, if the given year is a leap year, false otherwise.  */\n+   * @param year a year (use a negative value for BC).\n+   * @return true, if the given year is a leap year, false otherwise.  \n+   */\n   public boolean isLeapYear(int year)\n   {\n     if ((year & 3) != 0)\n@@ -244,11 +342,12 @@ public boolean isLeapYear(int year)\n    * @param year the year of the date.\n    * @param dayOfYear the day of year of the date; 1 based.\n    * @param millis the millisecond in that day.\n-   * @return the days since the epoch, may be negative.  */\n+   * @return the days since the epoch, may be negative.  \n+   */\n   private long getLinearTime(int year, int dayOfYear, int millis)\n   {\n     // The 13 is the number of days, that were omitted in the Gregorian\n-    // Calender until the epoch.\n+    // Calendar until the epoch.\n     // We shift right by 2 instead of dividing by 4, to get correct\n     // results for negative years (and this is even more efficient).\n     int julianDay = ((year * (365 * 4 + 1)) >> 2) + dayOfYear -\n@@ -276,6 +375,14 @@ private long getLinearTime(int year, int dayOfYear, int millis)\n     return time;\n   }\n \n+  /**\n+   * Retrieves the day of the week corresponding to the specified\n+   * day of the specified year.\n+   *\n+   * @param year the year in which the dayOfYear occurs.\n+   * @param dayOfYear the day of the year (an integer between 0 and\n+   *        and 366)\n+   */\n   private int getWeekDay(int year, int dayOfYear)\n   {\n     int day =\n@@ -289,20 +396,24 @@ private int getWeekDay(int year, int dayOfYear)\n   }\n \n   /**\n+   * <p>\n    * Calculate the dayOfYear from the fields array.  \n    * The relativeDays is used, to account for weeks that begin before\n-   * the gregorian change and end after it.<br>\n-   *\n-   * We return two values, the first is used to determine, if we\n-   * should use Gregorian calendar or Julian calendar, in case of\n-   * the change year, the second is a relative day after the given\n+   * the Gregorian change and end after it.\n+   * </p>\n+   * <p>\n+   * We return two values.  The first is used to determine, if we\n+   * should use the Gregorian calendar or the Julian calendar, in order\n+   * to handle the change year. The second is a relative day after the given\n    * day.  This is necessary for week calculation in the year in\n-   * which gregorian change occurs. <br>\n-   *\n+   * which the Gregorian change occurs. \n+   * </p>\n+   * \n    * @param year the year, negative for BC.\n-   * @return an array of two int values, the first containing a reference\n-   * day of current year, the second a relative count since this reference\n-   * day.  */\n+   * @return an array of two integer values, the first containing a reference\n+   * day in the current year, the second a relative count since this reference\n+   * day.  \n+   */\n   private int[] getDayOfYear(int year)\n   {\n     if (isSet[MONTH])\n@@ -387,6 +498,9 @@ private int[] getDayOfYear(int year)\n   /**\n    * Converts the time field values (<code>fields</code>) to\n    * milliseconds since the epoch UTC (<code>time</code>). \n+   *\n+   * @throws IllegalArgumentException if any calendar fields\n+   *         are invalid.\n    */\n   protected synchronized void computeTime()\n   {\n@@ -465,15 +579,19 @@ else if (isSet[HOUR])\n   }\n \n   /**\n+   * <p>\n    * Determines if the given year is a leap year.  \n+   * </p>\n+   * <p>\n+   * To specify a year in the BC era, use a negative value calculated\n+   * as 1 - y, where y is the required year in BC.  So, 1 BC is 0,\n+   * 2 BC is -1, 3 BC is -2, etc.\n+   * </p>\n    *\n-   * The year should be positive and you can't give an ERA.  But\n-   * remember that before 4 BC there wasn't a consistent leap year\n-   * rule, so who cares.\n-   *\n-   * @param year a year use nonnegative value for BC.\n-   * @param gregorian if true, use gregorian leap year rule.\n-   * @return true, if the given year is a leap year, false otherwise.  */\n+   * @param year a year (use a negative value for BC).\n+   * @param gregorian if true, use the gregorian leap year rule.\n+   * @return true, if the given year is a leap year, false otherwise.  \n+   */\n   private boolean isLeapYear(int year, boolean gregorian)\n   {\n     if ((year & 3) != 0)\n@@ -495,8 +613,9 @@ private boolean isLeapYear(int year, boolean gregorian)\n    *\n    * @param year the year of the date.\n    * @param dayOfYear the day of year of the date; 1 based.\n-   * @param gregorian True, if we should use Gregorian rules.\n-   * @return the days since the epoch, may be negative.  */\n+   * @param gregorian <code>true</code>, if we should use the Gregorian rules.\n+   * @return the days since the epoch, may be negative.\n+   */\n   private int getLinearDay(int year, int dayOfYear, boolean gregorian)\n   {\n     // The 13 is the number of days, that were omitted in the Gregorian\n@@ -529,7 +648,9 @@ private int getLinearDay(int year, int dayOfYear, boolean gregorian)\n    * Converts the given linear day into era, year, month,\n    * day_of_year, day_of_month, day_of_week, and writes the result\n    * into the fields array.\n+   *\n    * @param day the linear day.  \n+   * @param gregorian true, if we should use Gregorian rules.\n    */\n   private void calculateDay(int day, boolean gregorian)\n   {\n@@ -588,7 +709,7 @@ private void calculateDay(int day, boolean gregorian)\n   /**\n    * Converts the milliseconds since the epoch UTC\n    * (<code>time</code>) to time fields\n-   * (<code>fields</code>). \n+   * (<code>fields</code>).\n    */\n   protected synchronized void computeFields()\n   {\n@@ -660,11 +781,19 @@ protected synchronized void computeFields()\n   }\n \n   /**\n-   * Compares the given calender with this.  \n+   * Compares the given calendar with this.  An object, o, is\n+   * equivalent to this if it is also a <code>GregorianCalendar</code>\n+   * with the same time since the epoch under the same conditions\n+   * (same change date and same time zone).\n+   *  \n    * @param o the object to that we should compare.\n    * @return true, if the given object is a calendar, that represents\n-   * the same time (but doesn't necessary have the same fields).\n-   * @XXX Should we check if time zones, locale, cutover etc. are equal?\n+   * the same time (but doesn't necessarily have the same fields).\n+   * @throws IllegalArgumentException if one of the fields\n+   *         <code>ZONE_OFFSET</code> or <code>DST_OFFSET</code> is\n+   *         specified, if an unknown field is specified or if one\n+   *         of the calendar fields receives an illegal value when\n+   *         leniancy is not enabled.\n    */\n   public boolean equals(Object o)\n   {\n@@ -707,8 +836,8 @@ public boolean equals(Object o)\n    * Adds the specified amount of time to the given time field.  The\n    * amount may be negative to subtract the time.  If the field overflows\n    * it does what you expect: Jan, 25 + 10 Days is Feb, 4.\n-   * @param field the time field. One of the time field constants.\n-   * @param amount the amount of time.\n+   * @param field one of the time field constants.\n+   * @param amount the amount of time to add.\n    * @exception IllegalArgumentException if <code>field</code> is \n    *   <code>ZONE_OFFSET</code>, <code>DST_OFFSET</code>, or invalid; or\n    *   if <code>amount</code> contains an out-of-range value and the calendar\n@@ -809,12 +938,26 @@ public void add(int field, int amount)\n    *\n    * @param field the time field. One of the time field constants.\n    * @param up the direction, true for up, false for down.\n+   * @throws IllegalArgumentException if one of the fields\n+   *         <code>ZONE_OFFSET</code> or <code>DST_OFFSET</code> is\n+   *         specified, if an unknown field is specified or if one\n+   *         of the calendar fields receives an illegal value when\n+   *         leniancy is not enabled.\n    */\n   public void roll(int field, boolean up)\n   {\n     roll(field, up ? 1 : -1);\n   }\n \n+  /**\n+   * Checks that the fields are still within their legal bounds,\n+   * following use of the <code>roll()</code> method.\n+   *\n+   * @param field the field to check.\n+   * @param delta multipler for alterations to the <code>time</code>.\n+   * @see #roll(int, boolean)\n+   * @see #roll(int, int)\n+   */\n   private void cleanUpAfterRoll(int field, int delta)\n   {\n     switch (field)\n@@ -912,6 +1055,11 @@ private void cleanUpAfterRoll(int field, int delta)\n    *\n    * @param field the time field. One of the time field constants.\n    * @param amount the amount by which we should roll.\n+   * @throws IllegalArgumentException if one of the fields\n+   *         <code>ZONE_OFFSET</code> or <code>DST_OFFSET</code> is\n+   *         specified, if an unknown field is specified or if one\n+   *         of the calendar fields receives an illegal value when\n+   *         leniancy is not enabled.\n    */\n   public void roll(int field, int amount)\n   {\n@@ -936,18 +1084,25 @@ public void roll(int field, int amount)\n     cleanUpAfterRoll(field, newval - oldval);\n   }\n \n+  /**\n+   * The minimum values for the calendar fields.\n+   */\n   private static final int[] minimums =\n       { BC,       1,  0,  0, 1,  1,   1,   SUNDAY, 1, \n         AM,  1,  0,  1,  1,   1, -(12*60*60*1000),               0 };\n \n+  /**\n+   * The maximum values for the calendar fields.\n+   */\n   private static final int[] maximums =\n       { AD, 5000000, 11, 53, 5, 31, 366, SATURDAY, 5, \n         PM, 12, 23, 59, 59, 999, +(12*60*60*1000), (12*60*60*1000) };\n \n   /**\n    * Gets the smallest value that is allowed for the specified field.\n-   * @param field the time field. One of the time field constants.\n-   * @return the smallest value.\n+   *\n+   * @param field one of the time field constants.\n+   * @return the smallest value for the specified field.\n    */\n   public int getMinimum(int field)\n   {\n@@ -956,7 +1111,8 @@ public int getMinimum(int field)\n \n   /**\n    * Gets the biggest value that is allowed for the specified field.\n-   * @param field the time field. One of the time field constants.\n+   *\n+   * @param field one of the time field constants.\n    * @return the biggest value.\n    */\n   public int getMaximum(int field)\n@@ -967,8 +1123,12 @@ public int getMaximum(int field)\n \n   /**\n    * Gets the greatest minimum value that is allowed for the specified field.\n+   * This is the largest value returned by the <code>getActualMinimum(int)</code>\n+   * method.\n+   *\n    * @param field the time field. One of the time field constants.\n    * @return the greatest minimum value.\n+   * @see #getActualMinimum(int)\n    */\n   public int getGreatestMinimum(int field)\n   {\n@@ -979,10 +1139,15 @@ public int getGreatestMinimum(int field)\n \n   /**\n    * Gets the smallest maximum value that is allowed for the\n-   * specified field.  For example this is 28 for DAY_OF_MONTH.\n+   * specified field.  This is the smallest value returned\n+   * by the <code>getActualMaximum(int)</code>.  For example,\n+   * this is 28 for DAY_OF_MONTH (as all months have at least\n+   * 28 days).\n+   *\n    * @param field the time field. One of the time field constants.\n    * @return the least maximum value.  \n-   * @since jdk1.2\n+   * @see #getActualMaximum(int)\n+   * @since 1.2\n    */\n   public int getLeastMaximum(int field)\n   {\n@@ -1006,10 +1171,12 @@ public int getLeastMaximum(int field)\n    * Gets the actual minimum value that is allowed for the specified field.\n    * This value is dependent on the values of the other fields.  Note that\n    * this calls <code>complete()</code> if not enough fields are set.  This\n-   * can have ugly side effects.\n+   * can have ugly side effects.  The value given depends on the current\n+   * time used by this instance.\n+   *\n    * @param field the time field. One of the time field constants.\n    * @return the actual minimum value.\n-   * @since jdk1.2\n+   * @since 1.2\n    */\n   public int getActualMinimum(int field)\n   {\n@@ -1034,7 +1201,10 @@ public int getActualMinimum(int field)\n    * Gets the actual maximum value that is allowed for the specified field.\n    * This value is dependent on the values of the other fields.  Note that\n    * this calls <code>complete()</code> if not enough fields are set.  This\n-   * can have ugly side effects.\n+   * can have ugly side effects.  The value given depends on the current time\n+   * used by this instance; thus, leap years have a maximum day of month value of\n+   * 29, rather than 28.\n+   *\n    * @param field the time field. One of the time field constants.\n    * @return the actual maximum value.  \n    */\n@@ -1057,8 +1227,13 @@ public int getActualMaximum(int field)\n \n \t  int minimalDays = getMinimalDaysInFirstWeek();\n \t  int firstWeekday = getWeekDay(year, minimalDays);\n+\t  /* \n+\t   * Is there a set of days at the beginning of the year, before the\n+\t   * first day of the week, equal to or greater than the minimum number\n+\t   * of days required in the first week?\n+\t   */\n \t  if (minimalDays - (7 + firstWeekday - getFirstDayOfWeek()) % 7 < 1)\n-\t    return week + 1;\n+\t    return week + 1; /* Add week 1: firstWeekday through to firstDayOfWeek */\n \t}\n \tcase DAY_OF_MONTH:\n \t{\n@@ -1105,4 +1280,6 @@ else if (month < AUGUST)\n \treturn maximums[field];\n       }\n   }\n+\n+\n }"}]}