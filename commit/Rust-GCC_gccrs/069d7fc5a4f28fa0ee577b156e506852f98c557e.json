{"sha": "069d7fc5a4f28fa0ee577b156e506852f98c557e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDY5ZDdmYzVhNGYyOGZhMGVlNTc3YjE1NmU1MDY4NTJmOThjNTU3ZQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2014-10-10T15:56:07Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2014-10-10T15:56:07Z"}, "message": "re PR target/63404 (gcc 5 miscompiles linux block layer)\n\nPR target/63404\n\n  * shrink-wrap.c (move_insn_for_shrink_wrap): Don't use single_set.\n  Restrict the set of expressions we're willing to move.\n\nFrom-SVN: r216096", "tree": {"sha": "98910f50ad06223df3a830870ec1d14aac86e59f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/98910f50ad06223df3a830870ec1d14aac86e59f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/069d7fc5a4f28fa0ee577b156e506852f98c557e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/069d7fc5a4f28fa0ee577b156e506852f98c557e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/069d7fc5a4f28fa0ee577b156e506852f98c557e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/069d7fc5a4f28fa0ee577b156e506852f98c557e/comments", "author": null, "committer": null, "parents": [{"sha": "fb0ab69706097f5e9c6e772e82d4f8e39c7e5955", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb0ab69706097f5e9c6e772e82d4f8e39c7e5955", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb0ab69706097f5e9c6e772e82d4f8e39c7e5955"}], "stats": {"total": 95, "additions": 72, "deletions": 23}, "files": [{"sha": "d1086cfb1824e7cdc6700d62cb0ab8de5907ea20", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/069d7fc5a4f28fa0ee577b156e506852f98c557e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/069d7fc5a4f28fa0ee577b156e506852f98c557e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=069d7fc5a4f28fa0ee577b156e506852f98c557e", "patch": "@@ -1,3 +1,9 @@\n+2014-10-10  Richard Henderson  <rth@redhat.com>\n+\n+\tPR target/63404\n+\t* shrink-wrap.c (move_insn_for_shrink_wrap): Don't use single_set.\n+\tRestrict the set of expressions we're willing to move.\n+\n 2014-10-10  Jeff Law  <law@redhat.com>\n \n \t* ira.c (struct equivalence): Promote INIT_INSNs field to"}, {"sha": "257812c02fbb66e623e41b0a6ad9ba3bc651d1a4", "filename": "gcc/shrink-wrap.c", "status": "modified", "additions": 66, "deletions": 23, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/069d7fc5a4f28fa0ee577b156e506852f98c557e/gcc%2Fshrink-wrap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/069d7fc5a4f28fa0ee577b156e506852f98c557e/gcc%2Fshrink-wrap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fshrink-wrap.c?ref=069d7fc5a4f28fa0ee577b156e506852f98c557e", "patch": "@@ -176,17 +176,40 @@ move_insn_for_shrink_wrap (basic_block bb, rtx_insn *insn,\n   basic_block next_block;\n   edge live_edge;\n \n-  /* Look for a simple register copy.  */\n-  set = single_set (insn);\n-  if (!set)\n+  /* Look for a simple register assignment.  We don't use single_set here\n+     because we can't deal with any CLOBBERs, USEs, or REG_UNUSED secondary\n+     destinations.  */\n+  if (!INSN_P (insn))\n+    return false;\n+  set = PATTERN (insn);\n+  if (GET_CODE (set) != SET)\n     return false;\n   src = SET_SRC (set);\n   dest = SET_DEST (set);\n \n-  if (!REG_P (src))\n+  /* For the destination, we want only a register.  Also disallow STACK\n+     or FRAME related adjustments.  They are likely part of the prologue,\n+     so keep them in the entry block.  */\n+  if (!REG_P (dest)\n+      || dest == stack_pointer_rtx\n+      || dest == frame_pointer_rtx\n+      || dest == hard_frame_pointer_rtx)\n+    return false;\n+\n+  /* For the source, we want one of:\n+      (1) A (non-overlapping) register\n+      (2) A constant,\n+      (3) An expression involving no more than one register.\n+\n+     That last point comes from the code following, which was originally\n+     written to handle only register move operations, and still only handles\n+     a single source register when checking for overlaps.  Happily, the\n+     same checks can be applied to expressions like (plus reg const).  */\n+\n+  if (CONSTANT_P (src))\n+    ;\n+  else if (!REG_P (src))\n     {\n-      unsigned int reg_num = 0;\n-      unsigned int nonconstobj_num = 0;\n       rtx src_inner = NULL_RTX;\n \n       if (can_throw_internal (insn))\n@@ -196,30 +219,50 @@ move_insn_for_shrink_wrap (basic_block bb, rtx_insn *insn,\n       FOR_EACH_SUBRTX_VAR (iter, array, src, ALL)\n \t{\n \t  rtx x = *iter;\n-\t  if (REG_P (x))\n+\t  switch (GET_RTX_CLASS (GET_CODE (x)))\n \t    {\n-\t      reg_num++;\n-\t      src_inner = x;\n+\t    case RTX_CONST_OBJ:\n+\t    case RTX_COMPARE:\n+\t    case RTX_COMM_COMPARE:\n+\t    case RTX_BIN_ARITH:\n+\t    case RTX_COMM_ARITH:\n+\t    case RTX_UNARY:\n+\t    case RTX_TERNARY:\n+\t      /* Constant or expression.  Continue.  */\n+\t      break;\n+\n+\t    case RTX_OBJ:\n+\t    case RTX_EXTRA:\n+\t      switch (GET_CODE (x))\n+\t\t{\n+\t\tcase UNSPEC:\n+\t\tcase SUBREG:\n+\t\tcase STRICT_LOW_PART:\n+\t\tcase PC:\n+\t\t  /* Ok.  Continue.  */\n+\t\t  break;\n+\n+\t\tcase REG:\n+\t\t  /* Fail if we see a second inner register.  */\n+\t\t  if (src_inner != NULL)\n+\t\t    return false;\n+\t\t  src_inner = x;\n+\t\t  break;\n+\n+\t\tdefault:\n+\t\t  return false;\n+\t\t}\n+\t      break;\n+\n+\t    default:\n+\t      return false;\n \t    }\n-\t  else if (!CONSTANT_P (x) && OBJECT_P (x))\n-\t    nonconstobj_num++;\n \t}\n \n-      if (nonconstobj_num > 0\n-\t  || reg_num > 1)\n-\tsrc = NULL_RTX;\n-      else if (reg_num == 1)\n+      if (src_inner != NULL)\n \tsrc = src_inner;\n     }\n \n-  if (!REG_P (dest) || src == NULL_RTX\n-      /* STACK or FRAME related adjustment might be part of prologue.\n-\t So keep them in the entry block.  */\n-      || dest == stack_pointer_rtx\n-      || dest == frame_pointer_rtx\n-      || dest == hard_frame_pointer_rtx)\n-    return false;\n-\n   /* Make sure that the source register isn't defined later in BB.  */\n   if (REG_P (src))\n     {"}]}