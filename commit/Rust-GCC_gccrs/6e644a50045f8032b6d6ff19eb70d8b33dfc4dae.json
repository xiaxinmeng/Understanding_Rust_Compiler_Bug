{"sha": "6e644a50045f8032b6d6ff19eb70d8b33dfc4dae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmU2NDRhNTAwNDVmODAzMmI2ZDZmZjE5ZWI3MGQ4YjMzZGZjNGRhZQ==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2018-11-30T14:25:15Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2018-11-30T14:25:15Z"}, "message": "Make red zone size more flexible for stack variables (PR sanitizer/81715).\n\n2018-11-30  Martin Liska  <mliska@suse.cz>\n\n\tPR sanitizer/81715\n\t* asan.c (asan_shadow_cst): Remove, partially transform\n\tinto flush_redzone_payload.\n\t(RZ_BUFFER_SIZE): New.\n\t(struct asan_redzone_buffer): New.\n\t(asan_redzone_buffer::emit_redzone_byte): Likewise.\n\t(asan_redzone_buffer::flush_redzone_payload): Likewise.\n\t(asan_redzone_buffer::flush_if_full): Likewise.\n\t(asan_emit_stack_protection): Use asan_redzone_buffer class\n\tthat is responsible for proper aligned stores and flushing\n\tof shadow memory payload.\n\t* asan.h (ASAN_MIN_RED_ZONE_SIZE): New.\n\t(asan_var_and_redzone_size): Likewise.\n\t* cfgexpand.c (expand_stack_vars): Use smaller alignment\n\t(ASAN_MIN_RED_ZONE_SIZE) in order to make shadow memory\n\tfor automatic variables more compact.\n2018-11-30  Martin Liska  <mliska@suse.cz>\n\n\tPR sanitizer/81715\n\t* c-c++-common/asan/asan-stack-small.c: New test.\n\nFrom-SVN: r266664", "tree": {"sha": "b6ab18da4eaeb67ce5e78a93ed2b4b84bfa0b637", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b6ab18da4eaeb67ce5e78a93ed2b4b84bfa0b637"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e644a50045f8032b6d6ff19eb70d8b33dfc4dae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e644a50045f8032b6d6ff19eb70d8b33dfc4dae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e644a50045f8032b6d6ff19eb70d8b33dfc4dae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e644a50045f8032b6d6ff19eb70d8b33dfc4dae/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b49f1a7e7c85add83637cf7df46b8fc9b5b299e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b49f1a7e7c85add83637cf7df46b8fc9b5b299e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b49f1a7e7c85add83637cf7df46b8fc9b5b299e9"}], "stats": {"total": 293, "additions": 243, "deletions": 50}, "files": [{"sha": "c10bfc3e4d732c0762fcf302c0986e0226ac27cf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e644a50045f8032b6d6ff19eb70d8b33dfc4dae/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e644a50045f8032b6d6ff19eb70d8b33dfc4dae/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6e644a50045f8032b6d6ff19eb70d8b33dfc4dae", "patch": "@@ -1,3 +1,22 @@\n+2018-11-30  Martin Liska  <mliska@suse.cz>\n+\n+\tPR sanitizer/81715\n+\t* asan.c (asan_shadow_cst): Remove, partially transform\n+\tinto flush_redzone_payload.\n+\t(RZ_BUFFER_SIZE): New.\n+\t(struct asan_redzone_buffer): New.\n+\t(asan_redzone_buffer::emit_redzone_byte): Likewise.\n+\t(asan_redzone_buffer::flush_redzone_payload): Likewise.\n+\t(asan_redzone_buffer::flush_if_full): Likewise.\n+\t(asan_emit_stack_protection): Use asan_redzone_buffer class\n+\tthat is responsible for proper aligned stores and flushing\n+\tof shadow memory payload.\n+\t* asan.h (ASAN_MIN_RED_ZONE_SIZE): New.\n+\t(asan_var_and_redzone_size): Likewise.\n+\t* cfgexpand.c (expand_stack_vars): Use smaller alignment\n+\t(ASAN_MIN_RED_ZONE_SIZE) in order to make shadow memory\n+\tfor automatic variables more compact.\n+\n 2018-11-30  Alan Modra  <amodra@gmail.com>\n \n \t* config/rs6000/predicates.md (easy_fp_constant): Avoid long"}, {"sha": "5d1d1dec064d5261e9dc96c3e8a62c4732a67dd4", "filename": "gcc/asan.c", "status": "modified", "additions": 157, "deletions": 45, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e644a50045f8032b6d6ff19eb70d8b33dfc4dae/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e644a50045f8032b6d6ff19eb70d8b33dfc4dae/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=6e644a50045f8032b6d6ff19eb70d8b33dfc4dae", "patch": "@@ -1155,20 +1155,6 @@ asan_pp_string (pretty_printer *pp)\n   return build1 (ADDR_EXPR, shadow_ptr_types[0], ret);\n }\n \n-/* Return a CONST_INT representing 4 subsequent shadow memory bytes.  */\n-\n-static rtx\n-asan_shadow_cst (unsigned char shadow_bytes[4])\n-{\n-  int i;\n-  unsigned HOST_WIDE_INT val = 0;\n-  gcc_assert (WORDS_BIG_ENDIAN == BYTES_BIG_ENDIAN);\n-  for (i = 0; i < 4; i++)\n-    val |= (unsigned HOST_WIDE_INT) shadow_bytes[BYTES_BIG_ENDIAN ? 3 - i : i]\n-\t   << (BITS_PER_UNIT * i);\n-  return gen_int_mode (val, SImode);\n-}\n-\n /* Clear shadow memory at SHADOW_MEM, LEN bytes.  Can't call a library call here\n    though.  */\n \n@@ -1235,6 +1221,136 @@ shadow_mem_size (unsigned HOST_WIDE_INT size)\n   return ROUND_UP (size, ASAN_SHADOW_GRANULARITY) / ASAN_SHADOW_GRANULARITY;\n }\n \n+/* Always emit 4 bytes at a time.  */\n+#define RZ_BUFFER_SIZE 4\n+\n+/* ASAN redzone buffer container that handles emission of shadow bytes.  */\n+struct asan_redzone_buffer\n+{\n+  /* Constructor.  */\n+  asan_redzone_buffer (rtx shadow_mem, HOST_WIDE_INT prev_offset):\n+    m_shadow_mem (shadow_mem), m_prev_offset (prev_offset),\n+    m_original_offset (prev_offset), m_shadow_bytes (RZ_BUFFER_SIZE)\n+  {}\n+\n+  /* Emit VALUE shadow byte at a given OFFSET.  */\n+  void emit_redzone_byte (HOST_WIDE_INT offset, unsigned char value);\n+\n+  /* Emit RTX emission of the content of the buffer.  */\n+  void flush_redzone_payload (void);\n+\n+private:\n+  /* Flush if the content of the buffer is full\n+     (equal to RZ_BUFFER_SIZE).  */\n+  void flush_if_full (void);\n+\n+  /* Memory where we last emitted a redzone payload.  */\n+  rtx m_shadow_mem;\n+\n+  /* Relative offset where we last emitted a redzone payload.  */\n+  HOST_WIDE_INT m_prev_offset;\n+\n+  /* Relative original offset.  Used for checking only.  */\n+  HOST_WIDE_INT m_original_offset;\n+\n+public:\n+  /* Buffer with redzone payload.  */\n+  auto_vec<unsigned char> m_shadow_bytes;\n+};\n+\n+/* Emit VALUE shadow byte at a given OFFSET.  */\n+\n+void\n+asan_redzone_buffer::emit_redzone_byte (HOST_WIDE_INT offset,\n+\t\t\t\t\tunsigned char value)\n+{\n+  gcc_assert ((offset & (ASAN_SHADOW_GRANULARITY - 1)) == 0);\n+  gcc_assert (offset >= m_prev_offset);\n+\n+  HOST_WIDE_INT off\n+    = m_prev_offset + ASAN_SHADOW_GRANULARITY * m_shadow_bytes.length ();\n+  if (off == offset)\n+    {\n+      /* Consecutive shadow memory byte.  */\n+      m_shadow_bytes.safe_push (value);\n+      flush_if_full ();\n+    }\n+  else\n+    {\n+      if (!m_shadow_bytes.is_empty ())\n+\tflush_redzone_payload ();\n+\n+      /* Maybe start earlier in order to use aligned store.  */\n+      HOST_WIDE_INT align = (offset - m_prev_offset) % ASAN_RED_ZONE_SIZE;\n+      if (align)\n+\t{\n+\t  offset -= align;\n+\t  for (unsigned i = 0; i < align / BITS_PER_UNIT; i++)\n+\t    m_shadow_bytes.safe_push (0);\n+\t}\n+\n+      /* Adjust m_prev_offset and m_shadow_mem.  */\n+      HOST_WIDE_INT diff = offset - m_prev_offset;\n+      m_shadow_mem = adjust_address (m_shadow_mem, VOIDmode,\n+\t\t\t\t     diff >> ASAN_SHADOW_SHIFT);\n+      m_prev_offset = offset;\n+      m_shadow_bytes.safe_push (value);\n+      flush_if_full ();\n+    }\n+}\n+\n+/* Emit RTX emission of the content of the buffer.  */\n+\n+void\n+asan_redzone_buffer::flush_redzone_payload (void)\n+{\n+  gcc_assert (WORDS_BIG_ENDIAN == BYTES_BIG_ENDIAN);\n+\n+  if (m_shadow_bytes.is_empty ())\n+    return;\n+\n+  /* Be sure we always emit to an aligned address.  */\n+  gcc_assert (((m_prev_offset - m_original_offset)\n+\t      & (ASAN_RED_ZONE_SIZE - 1)) == 0);\n+\n+  /* Fill it to RZ_BUFFER_SIZE bytes with zeros if needed.  */\n+  unsigned l = m_shadow_bytes.length ();\n+  for (unsigned i = 0; i <= RZ_BUFFER_SIZE - l; i++)\n+    m_shadow_bytes.safe_push (0);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file,\n+\t     \"Flushing rzbuffer at offset %\" PRId64 \" with: \", m_prev_offset);\n+\n+  unsigned HOST_WIDE_INT val = 0;\n+  for (unsigned i = 0; i < RZ_BUFFER_SIZE; i++)\n+    {\n+      unsigned char v\n+\t= m_shadow_bytes[BYTES_BIG_ENDIAN ? RZ_BUFFER_SIZE - i : i];\n+      val |= (unsigned HOST_WIDE_INT)v << (BITS_PER_UNIT * i);\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"%02x \", v);\n+    }\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"\\n\");\n+\n+  rtx c = gen_int_mode (val, SImode);\n+  m_shadow_mem = adjust_address (m_shadow_mem, SImode, 0);\n+  emit_move_insn (m_shadow_mem, c);\n+  m_shadow_bytes.truncate (0);\n+}\n+\n+/* Flush if the content of the buffer is full\n+   (equal to RZ_BUFFER_SIZE).  */\n+\n+void\n+asan_redzone_buffer::flush_if_full (void)\n+{\n+  if (m_shadow_bytes.length () == RZ_BUFFER_SIZE)\n+    flush_redzone_payload ();\n+}\n+\n /* Insert code to protect stack vars.  The prologue sequence should be emitted\n    directly, epilogue sequence returned.  BASE is the register holding the\n    stack base, against which OFFSETS array offsets are relative to, OFFSETS\n@@ -1256,7 +1372,6 @@ asan_emit_stack_protection (rtx base, rtx pbase, unsigned int alignb,\n   rtx_code_label *lab;\n   rtx_insn *insns;\n   char buf[32];\n-  unsigned char shadow_bytes[4];\n   HOST_WIDE_INT base_offset = offsets[length - 1];\n   HOST_WIDE_INT base_align_bias = 0, offset, prev_offset;\n   HOST_WIDE_INT asan_frame_size = offsets[0] - base_offset;\n@@ -1421,46 +1536,43 @@ asan_emit_stack_protection (rtx base, rtx pbase, unsigned int alignb,\n   if (STRICT_ALIGNMENT)\n     set_mem_align (shadow_mem, (GET_MODE_ALIGNMENT (SImode)));\n   prev_offset = base_offset;\n+\n+  asan_redzone_buffer rz_buffer (shadow_mem, prev_offset);\n   for (l = length; l; l -= 2)\n     {\n       if (l == 2)\n \tcur_shadow_byte = ASAN_STACK_MAGIC_RIGHT;\n       offset = offsets[l - 1];\n-      if ((offset - base_offset) & (ASAN_RED_ZONE_SIZE - 1))\n+\n+      bool extra_byte = (offset - base_offset) & (ASAN_SHADOW_GRANULARITY - 1);\n+      /* If a red-zone is not aligned to ASAN_SHADOW_GRANULARITY then\n+\t the previous stack variable has size % ASAN_SHADOW_GRANULARITY != 0.\n+\t In that case we have to emit one extra byte that will describe\n+\t how many bytes (our of ASAN_SHADOW_GRANULARITY) can be accessed.  */\n+      if (extra_byte)\n \t{\n-\t  int i;\n \t  HOST_WIDE_INT aoff\n \t    = base_offset + ((offset - base_offset)\n-\t\t\t     & ~(ASAN_RED_ZONE_SIZE - HOST_WIDE_INT_1));\n-\t  shadow_mem = adjust_address (shadow_mem, VOIDmode,\n-\t\t\t\t       (aoff - prev_offset)\n-\t\t\t\t       >> ASAN_SHADOW_SHIFT);\n-\t  prev_offset = aoff;\n-\t  for (i = 0; i < 4; i++, aoff += ASAN_SHADOW_GRANULARITY)\n-\t    if (aoff < offset)\n-\t      {\n-\t\tif (aoff < offset - (HOST_WIDE_INT)ASAN_SHADOW_GRANULARITY + 1)\n-\t\t  shadow_bytes[i] = 0;\n-\t\telse\n-\t\t  shadow_bytes[i] = offset - aoff;\n-\t      }\n-\t    else\n-\t      shadow_bytes[i] = ASAN_STACK_MAGIC_MIDDLE;\n-\t  emit_move_insn (shadow_mem, asan_shadow_cst (shadow_bytes));\n-\t  offset = aoff;\n+\t\t\t     & ~(ASAN_SHADOW_GRANULARITY - HOST_WIDE_INT_1));\n+\t  rz_buffer.emit_redzone_byte (aoff, offset - aoff);\n+\t  offset = aoff + ASAN_SHADOW_GRANULARITY;\n \t}\n-      while (offset <= offsets[l - 2] - ASAN_RED_ZONE_SIZE)\n+\n+      /* Calculate size of red zone payload.  */\n+      while (offset < offsets[l - 2])\n \t{\n-\t  shadow_mem = adjust_address (shadow_mem, VOIDmode,\n-\t\t\t\t       (offset - prev_offset)\n-\t\t\t\t       >> ASAN_SHADOW_SHIFT);\n-\t  prev_offset = offset;\n-\t  memset (shadow_bytes, cur_shadow_byte, 4);\n-\t  emit_move_insn (shadow_mem, asan_shadow_cst (shadow_bytes));\n-\t  offset += ASAN_RED_ZONE_SIZE;\n+\t  rz_buffer.emit_redzone_byte (offset, cur_shadow_byte);\n+\t  offset += ASAN_SHADOW_GRANULARITY;\n \t}\n+\n       cur_shadow_byte = ASAN_STACK_MAGIC_MIDDLE;\n     }\n+\n+  /* As the automatic variables are aligned to\n+     ASAN_RED_ZONE_SIZE / ASAN_SHADOW_GRANULARITY, the buffer should be\n+     flushed here.  */\n+  gcc_assert (rz_buffer.m_shadow_bytes.is_empty ());\n+\n   do_pending_stack_adjust ();\n \n   /* Construct epilogue sequence.  */\n@@ -1519,7 +1631,7 @@ asan_emit_stack_protection (rtx base, rtx pbase, unsigned int alignb,\n   for (l = length; l; l -= 2)\n     {\n       offset = base_offset + ((offsets[l - 1] - base_offset)\n-\t\t\t     & ~(ASAN_RED_ZONE_SIZE - HOST_WIDE_INT_1));\n+\t\t\t     & ~(ASAN_MIN_RED_ZONE_SIZE - HOST_WIDE_INT_1));\n       if (last_offset + last_size != offset)\n \t{\n \t  shadow_mem = adjust_address (shadow_mem, VOIDmode,\n@@ -1531,7 +1643,7 @@ asan_emit_stack_protection (rtx base, rtx pbase, unsigned int alignb,\n \t  last_size = 0;\n \t}\n       last_size += base_offset + ((offsets[l - 2] - base_offset)\n-\t\t\t\t  & ~(ASAN_RED_ZONE_SIZE - HOST_WIDE_INT_1))\n+\t\t\t\t  & ~(ASAN_MIN_RED_ZONE_SIZE - HOST_WIDE_INT_1))\n \t\t   - offset;\n \n       /* Unpoison shadow memory that corresponds to a variable that is \n@@ -1552,7 +1664,7 @@ asan_emit_stack_protection (rtx base, rtx pbase, unsigned int alignb,\n \t\t\t   \"%s (%\" PRId64 \" B)\\n\", n, size);\n \t\t}\n \n-\t\tlast_size += size & ~(ASAN_RED_ZONE_SIZE - HOST_WIDE_INT_1);\n+\t\tlast_size += size & ~(ASAN_MIN_RED_ZONE_SIZE - HOST_WIDE_INT_1);\n \t    }\n \t}\n     }"}, {"sha": "e1b9b491e674ed6e8eaf72eb072fab1baef19cd6", "filename": "gcc/asan.h", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e644a50045f8032b6d6ff19eb70d8b33dfc4dae/gcc%2Fasan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e644a50045f8032b6d6ff19eb70d8b33dfc4dae/gcc%2Fasan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.h?ref=6e644a50045f8032b6d6ff19eb70d8b33dfc4dae", "patch": "@@ -53,6 +53,11 @@ extern hash_set <tree> *asan_used_labels;\n    up to 2 * ASAN_RED_ZONE_SIZE - 1 bytes.  */\n #define ASAN_RED_ZONE_SIZE\t32\n \n+/* Stack variable use more compact red zones.  The size includes also\n+   size of variable itself.  */\n+\n+#define ASAN_MIN_RED_ZONE_SIZE\t16\n+\n /* Shadow memory values for stack protection.  Left is below protected vars,\n    the first pointer in stack corresponding to that offset contains\n    ASAN_STACK_FRAME_MAGIC word, the second pointer to a string describing\n@@ -102,6 +107,26 @@ asan_red_zone_size (unsigned int size)\n   return c ? 2 * ASAN_RED_ZONE_SIZE - c : ASAN_RED_ZONE_SIZE;\n }\n \n+/* Return how much a stack variable occupis on a stack\n+   including a space for red zone.  */\n+\n+static inline unsigned HOST_WIDE_INT\n+asan_var_and_redzone_size (unsigned HOST_WIDE_INT size)\n+{\n+  if (size <= 4)\n+    return 16;\n+  else if (size <= 16)\n+    return 32;\n+  else if (size <= 128)\n+    return size + 32;\n+  else if (size <= 512)\n+    return size + 64;\n+  else if (size <= 4096)\n+    return size + 128;\n+  else\n+    return size + 256;\n+}\n+\n extern bool set_asan_shadow_offset (const char *);\n \n extern void set_sanitized_sections (const char *);"}, {"sha": "5e23bc242b98ee281d2284b9c8af68507596975b", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e644a50045f8032b6d6ff19eb70d8b33dfc4dae/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e644a50045f8032b6d6ff19eb70d8b33dfc4dae/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=6e644a50045f8032b6d6ff19eb70d8b33dfc4dae", "patch": "@@ -1125,13 +1125,17 @@ expand_stack_vars (bool (*pred) (size_t), struct stack_vars_data *data)\n \t      && stack_vars[i].size.is_constant ())\n \t    {\n \t      prev_offset = align_base (prev_offset,\n-\t\t\t\t\tMAX (alignb, ASAN_RED_ZONE_SIZE),\n+\t\t\t\t\tMAX (alignb, ASAN_MIN_RED_ZONE_SIZE),\n \t\t\t\t\t!FRAME_GROWS_DOWNWARD);\n \t      tree repr_decl = NULL_TREE;\n-\t      offset\n-\t\t= alloc_stack_frame_space (stack_vars[i].size\n-\t\t\t\t\t   + ASAN_RED_ZONE_SIZE,\n-\t\t\t\t\t   MAX (alignb, ASAN_RED_ZONE_SIZE));\n+\t      unsigned HOST_WIDE_INT size\n+\t\t= asan_var_and_redzone_size (stack_vars[i].size.to_constant ());\n+\t      if (data->asan_vec.is_empty ())\n+\t\tsize = MAX (size, ASAN_RED_ZONE_SIZE);\n+\n+\t      unsigned HOST_WIDE_INT alignment = MAX (alignb,\n+\t\t\t\t\t\t      ASAN_MIN_RED_ZONE_SIZE);\n+\t      offset = alloc_stack_frame_space (size, alignment);\n \n \t      data->asan_vec.safe_push (prev_offset);\n \t      /* Allocating a constant amount of space from a constant"}, {"sha": "33b42aa2e863caf77b343faaf406ff2c3a0adb5e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e644a50045f8032b6d6ff19eb70d8b33dfc4dae/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e644a50045f8032b6d6ff19eb70d8b33dfc4dae/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6e644a50045f8032b6d6ff19eb70d8b33dfc4dae", "patch": "@@ -1,3 +1,8 @@\n+2018-11-30  Martin Liska  <mliska@suse.cz>\n+\n+\tPR sanitizer/81715\n+\t* c-c++-common/asan/asan-stack-small.c: New test.\n+\n 2018-11-30  Richard Biener  <rguenther@suse.de>\n \n \t* gcc.dg/gimplefe-34.c: New testcase."}, {"sha": "11a56b8db4cbd94cfc7bdf1fb24f2c4600caff40", "filename": "gcc/testsuite/c-c++-common/asan/asan-stack-small.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e644a50045f8032b6d6ff19eb70d8b33dfc4dae/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fasan-stack-small.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e644a50045f8032b6d6ff19eb70d8b33dfc4dae/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fasan-stack-small.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fasan-stack-small.c?ref=6e644a50045f8032b6d6ff19eb70d8b33dfc4dae", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do run } */\n+\n+char *pa;\n+char *pb;\n+char *pc;\n+\n+void access (volatile char *ptr)\n+{\n+  *ptr = 'x';\n+}\n+\n+int main (int argc, char **argv)\n+{\n+  char a;\n+  char b;\n+  char c;\n+\n+  pa = &a;\n+  pb = &b;\n+  pc = &c;\n+\n+  access (pb);\n+  access (pc);\n+  // access 'b' here\n+  access (pa + 32);\n+\n+  return 0;\n+}"}]}