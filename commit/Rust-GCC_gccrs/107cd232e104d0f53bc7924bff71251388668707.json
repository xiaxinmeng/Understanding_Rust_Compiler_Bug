{"sha": "107cd232e104d0f53bc7924bff71251388668707", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTA3Y2QyMzJlMTA0ZDBmNTNiYzc5MjRiZmY3MTI1MTM4ODY2ODcwNw==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2007-06-06T10:18:16Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-06-06T10:18:16Z"}, "message": "comperr.adb (Compiler_Abort): New Finalize/Output_Messages interface for Errout\n\n2007-04-20  Robert Dewar  <dewar@adacore.com>\n\n\t* comperr.adb (Compiler_Abort): New Finalize/Output_Messages interface\n\tfor Errout\n\n\t* errout.adb: New Finalize/Compilation_Errors/Output_Messages\n\timplementation\n\n\t* errout.ads (Finalize): Changed interface\n\t(Output_Messages): New procedure\n\t(Compilation_Errors): New Interface\n\n\t* prepcomp.ads, prepcomp.adb (Parse_Preprocessing_Data_File): New\n\tFinalize/Output_Messages interface for Errout\n\t(Prepare_To_Preprocess): New Finalize/Output_Messages interface for\n\tErrout.\n\nFrom-SVN: r125374", "tree": {"sha": "82394de02a1975c2f12ee1d2d138d5da654b88ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/82394de02a1975c2f12ee1d2d138d5da654b88ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/107cd232e104d0f53bc7924bff71251388668707", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/107cd232e104d0f53bc7924bff71251388668707", "html_url": "https://github.com/Rust-GCC/gccrs/commit/107cd232e104d0f53bc7924bff71251388668707", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/107cd232e104d0f53bc7924bff71251388668707/comments", "author": null, "committer": null, "parents": [{"sha": "4378d23433bf8b13db7f67d2a8667b03d583698e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4378d23433bf8b13db7f67d2a8667b03d583698e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4378d23433bf8b13db7f67d2a8667b03d583698e"}], "stats": {"total": 643, "additions": 364, "deletions": 279}, "files": [{"sha": "9b89852c4b6c67f629cb89644caa347aaa2d2f95", "filename": "gcc/ada/comperr.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/107cd232e104d0f53bc7924bff71251388668707/gcc%2Fada%2Fcomperr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/107cd232e104d0f53bc7924bff71251388668707/gcc%2Fada%2Fcomperr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcomperr.adb?ref=107cd232e104d0f53bc7924bff71251388668707", "patch": "@@ -121,6 +121,7 @@ package body Comperr is\n \n       if Serious_Errors_Detected /= 0 and then not Debug_Flag_K then\n          Errout.Finalize;\n+         Errout.Output_Messages;\n \n          Set_Standard_Error;\n          Write_Str (\"compilation abandoned due to previous error\");"}, {"sha": "cfadbd8a32160d01e065b03a01948a5d7fb4bbb3", "filename": "gcc/ada/errout.adb", "status": "modified", "additions": 296, "deletions": 244, "changes": 540, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/107cd232e104d0f53bc7924bff71251388668707/gcc%2Fada%2Ferrout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/107cd232e104d0f53bc7924bff71251388668707/gcc%2Fada%2Ferrout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.adb?ref=107cd232e104d0f53bc7924bff71251388668707", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -40,7 +40,6 @@ with Fname;    use Fname;\n with Gnatvsn;  use Gnatvsn;\n with Hostparm; use Hostparm;\n with Lib;      use Lib;\n-with Namet;    use Namet;\n with Opt;      use Opt;\n with Nlists;   use Nlists;\n with Output;   use Output;\n@@ -61,6 +60,9 @@ package body Errout is\n    --  error message procedures should be ignored (when parsing irrelevant\n    --  text in sources being preprocessed).\n \n+   Finalize_Called : Boolean := False;\n+   --  Set True if the Finalize routine has been called\n+\n    Warn_On_Instance : Boolean;\n    --  Flag set true for warning message to be posted on instance\n \n@@ -138,8 +140,9 @@ package body Errout is\n    --  location of the flag, which is provided for the internal call to\n    --  Set_Msg_Insertion_Line_Number,\n \n-   procedure Set_Msg_Insertion_Unit_Name;\n-   --  Handle unit name insertion ($ insertion character)\n+   procedure Set_Msg_Insertion_Unit_Name (Suffix : Boolean := True);\n+   --  Handle unit name insertion ($ insertion character). Depending on Boolean\n+   --  parameter Suffix, (spec) or (body) is appended after the unit name.\n \n    procedure Set_Msg_Node (Node : Node_Id);\n    --  Add the sequence of characters for the name associated with the\n@@ -224,6 +227,19 @@ package body Errout is\n       end if;\n    end Change_Error_Text;\n \n+   ------------------------\n+   -- Compilation_Errors --\n+   ------------------------\n+\n+   function Compilation_Errors return Boolean is\n+   begin\n+      if not Finalize_Called then\n+         raise Program_Error;\n+      else\n+         return Erroutc.Compilation_Errors;\n+      end if;\n+   end Compilation_Errors;\n+\n    ---------------\n    -- Error_Msg --\n    ---------------\n@@ -1163,9 +1179,252 @@ package body Errout is\n    --------------\n \n    procedure Finalize is\n-      Cur      : Error_Msg_Id;\n-      Nxt      : Error_Msg_Id;\n-      E, F     : Error_Msg_Id;\n+      Cur : Error_Msg_Id;\n+      Nxt : Error_Msg_Id;\n+      F   : Error_Msg_Id;\n+\n+   begin\n+      --  Eliminate any duplicated error messages from the list. This is\n+      --  done after the fact to avoid problems with Change_Error_Text.\n+\n+      Cur := First_Error_Msg;\n+      while Cur /= No_Error_Msg loop\n+         Nxt := Errors.Table (Cur).Next;\n+\n+         F := Nxt;\n+         while F /= No_Error_Msg\n+           and then Errors.Table (F).Sptr = Errors.Table (Cur).Sptr\n+         loop\n+            Check_Duplicate_Message (Cur, F);\n+            F := Errors.Table (F).Next;\n+         end loop;\n+\n+         Cur := Nxt;\n+      end loop;\n+\n+      --  Mark any messages suppressed by specific warnings as Deleted\n+\n+      Cur := First_Error_Msg;\n+      while Cur /= No_Error_Msg loop\n+         if not Errors.Table (Cur).Deleted\n+           and then Warning_Specifically_Suppressed\n+                     (Errors.Table (Cur).Sptr,\n+                      Errors.Table (Cur).Text)\n+         then\n+            Errors.Table (Cur).Deleted := True;\n+            Warnings_Detected := Warnings_Detected - 1;\n+         end if;\n+\n+         Cur := Errors.Table (Cur).Next;\n+      end loop;\n+\n+      --  Remaining processing should only be done once in the case where\n+      --  Finalize has been called more than once.\n+\n+      if Finalize_Called then\n+         return;\n+      else\n+         Finalize_Called := True;\n+      end if;\n+\n+      --  Check consistency of specific warnings (may add warnings)\n+\n+      Validate_Specific_Warnings (Error_Msg'Access);\n+   end Finalize;\n+\n+   ----------------\n+   -- First_Node --\n+   ----------------\n+\n+   function First_Node (C : Node_Id) return Node_Id is\n+      L        : constant Source_Ptr        := Sloc (Original_Node (C));\n+      Sfile    : constant Source_File_Index := Get_Source_File_Index (L);\n+      Earliest : Node_Id;\n+      Eloc     : Source_Ptr;\n+      Discard  : Traverse_Result;\n+\n+      pragma Warnings (Off, Discard);\n+\n+      function Test_Earlier (N : Node_Id) return Traverse_Result;\n+      --  Function applied to every node in the construct\n+\n+      function Search_Tree_First is new Traverse_Func (Test_Earlier);\n+      --  Create traversal function\n+\n+      ------------------\n+      -- Test_Earlier --\n+      ------------------\n+\n+      function Test_Earlier (N : Node_Id) return Traverse_Result is\n+         Loc : constant Source_Ptr := Sloc (Original_Node (N));\n+\n+      begin\n+         --  Check for earlier. The tests for being in the same file ensures\n+         --  against strange cases of foreign code somehow being present. We\n+         --  don't want wild placement of messages if that happens, so it is\n+         --  best to just ignore this situation.\n+\n+         if Loc < Eloc\n+           and then Get_Source_File_Index (Loc) = Sfile\n+         then\n+            Earliest := Original_Node (N);\n+            Eloc     := Loc;\n+         end if;\n+\n+         return OK_Orig;\n+      end Test_Earlier;\n+\n+   --  Start of processing for First_Node\n+\n+   begin\n+      Earliest := Original_Node (C);\n+      Eloc := Sloc (Earliest);\n+      Discard := Search_Tree_First (Original_Node (C));\n+      return Earliest;\n+   end First_Node;\n+\n+   ----------------\n+   -- First_Sloc --\n+   ----------------\n+\n+   function First_Sloc (N : Node_Id) return Source_Ptr is\n+      SI : constant Source_File_Index := Source_Index (Get_Source_Unit (N));\n+      SF : constant Source_Ptr        := Source_First (SI);\n+      F  : Node_Id;\n+      S  : Source_Ptr;\n+\n+   begin\n+      F := First_Node (N);\n+      S := Sloc (F);\n+\n+      --  The following circuit is a bit subtle. When we have parenthesized\n+      --  expressions, then the Sloc will not record the location of the\n+      --  paren, but we would like to post the flag on the paren. So what\n+      --  we do is to crawl up the tree from the First_Node, adjusting the\n+      --  Sloc value for any parentheses we know are present. Yes, we know\n+      --  this circuit is not 100% reliable (e.g. because we don't record\n+      --  all possible paren level values), but this is only for an error\n+      --  message so it is good enough.\n+\n+      Node_Loop : loop\n+         Paren_Loop : for J in 1 .. Paren_Count (F) loop\n+\n+            --  We don't look more than 12 characters behind the current\n+            --  location, and in any case not past the front of the source.\n+\n+            Search_Loop : for K in 1 .. 12 loop\n+               exit Search_Loop when S = SF;\n+\n+               if Source_Text (SI) (S - 1) = '(' then\n+                  S := S - 1;\n+                  exit Search_Loop;\n+\n+               elsif Source_Text (SI) (S - 1) <= ' ' then\n+                  S := S - 1;\n+\n+               else\n+                  exit Search_Loop;\n+               end if;\n+            end loop Search_Loop;\n+         end loop Paren_Loop;\n+\n+         exit Node_Loop when F = N;\n+         F := Parent (F);\n+         exit Node_Loop when Nkind (F) not in N_Subexpr;\n+      end loop Node_Loop;\n+\n+      return S;\n+   end First_Sloc;\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize is\n+   begin\n+      Errors.Init;\n+      First_Error_Msg := No_Error_Msg;\n+      Last_Error_Msg := No_Error_Msg;\n+      Serious_Errors_Detected := 0;\n+      Total_Errors_Detected := 0;\n+      Warnings_Detected := 0;\n+      Cur_Msg := No_Error_Msg;\n+      List_Pragmas.Init;\n+\n+      --  Initialize warnings table, if all warnings are suppressed, supply\n+      --  an initial dummy entry covering all possible source locations.\n+\n+      Warnings.Init;\n+      Specific_Warnings.Init;\n+\n+      if Warning_Mode = Suppress then\n+         Warnings.Increment_Last;\n+         Warnings.Table (Warnings.Last).Start := Source_Ptr'First;\n+         Warnings.Table (Warnings.Last).Stop  := Source_Ptr'Last;\n+      end if;\n+   end Initialize;\n+\n+   -----------------\n+   -- No_Warnings --\n+   -----------------\n+\n+   function No_Warnings (N : Node_Or_Entity_Id) return Boolean is\n+   begin\n+      if Error_Posted (N) then\n+         return True;\n+\n+      elsif Nkind (N) in N_Entity and then Warnings_Off (N) then\n+         return True;\n+\n+      elsif Is_Entity_Name (N)\n+        and then Present (Entity (N))\n+        and then Warnings_Off (Entity (N))\n+      then\n+         return True;\n+\n+      else\n+         return False;\n+      end if;\n+   end No_Warnings;\n+\n+   -------------\n+   -- OK_Node --\n+   -------------\n+\n+   function OK_Node (N : Node_Id) return Boolean is\n+      K : constant Node_Kind := Nkind (N);\n+\n+   begin\n+      if Error_Posted (N) then\n+         return False;\n+\n+      elsif K in N_Has_Etype\n+        and then Present (Etype (N))\n+        and then Error_Posted (Etype (N))\n+      then\n+         return False;\n+\n+      elsif (K in N_Op\n+              or else K = N_Attribute_Reference\n+              or else K = N_Character_Literal\n+              or else K = N_Expanded_Name\n+              or else K = N_Identifier\n+              or else K = N_Operator_Symbol)\n+        and then Present (Entity (N))\n+        and then Error_Posted (Entity (N))\n+      then\n+         return False;\n+      else\n+         return True;\n+      end if;\n+   end OK_Node;\n+\n+   ---------------------\n+   -- Output_Messages --\n+   ---------------------\n+\n+   procedure Output_Messages is\n+      E        : Error_Msg_Id;\n       Err_Flag : Boolean;\n \n       procedure Write_Error_Summary;\n@@ -1297,56 +1556,25 @@ package body Errout is\n          end if;\n       end Write_Max_Errors;\n \n-   --  Start of processing for Finalize\n+   --  Start of processing for Output_Messages\n \n    begin\n+      --  Error if Finalize has not been called\n+\n+      if not Finalize_Called then\n+         raise Program_Error;\n+      end if;\n+\n       --  Reset current error source file if the main unit has a pragma\n       --  Source_Reference. This ensures outputting the proper name of\n       --  the source file in this situation.\n \n-      if Main_Source_File = No_Source_File or else\n-        Num_SRef_Pragmas (Main_Source_File) /= 0\n+      if Main_Source_File = No_Source_File\n+        or else Num_SRef_Pragmas (Main_Source_File) /= 0\n       then\n          Current_Error_Source_File := No_Source_File;\n       end if;\n \n-      --  Eliminate any duplicated error messages from the list. This is\n-      --  done after the fact to avoid problems with Change_Error_Text.\n-\n-      Cur := First_Error_Msg;\n-      while Cur /= No_Error_Msg loop\n-         Nxt := Errors.Table (Cur).Next;\n-\n-         F := Nxt;\n-         while F /= No_Error_Msg\n-           and then Errors.Table (F).Sptr = Errors.Table (Cur).Sptr\n-         loop\n-            Check_Duplicate_Message (Cur, F);\n-            F := Errors.Table (F).Next;\n-         end loop;\n-\n-         Cur := Nxt;\n-      end loop;\n-\n-      --  Mark any messages suppressed by specific warnings as Deleted\n-\n-      Cur := First_Error_Msg;\n-      while Cur /= No_Error_Msg loop\n-         if Warning_Specifically_Suppressed\n-             (Errors.Table (Cur).Sptr,\n-              Errors.Table (Cur).Text)\n-         then\n-            Errors.Table (Cur).Deleted := True;\n-            Warnings_Detected := Warnings_Detected - 1;\n-         end if;\n-\n-         Cur := Errors.Table (Cur).Next;\n-      end loop;\n-\n-      --  Check consistency of specific warnings (may add warnings)\n-\n-      Validate_Specific_Warnings (Error_Msg'Access);\n-\n       --  Brief Error mode\n \n       if Brief_Output or (not Full_List and not Verbose_Mode) then\n@@ -1544,194 +1772,7 @@ package body Errout is\n          Total_Errors_Detected := Total_Errors_Detected + Warnings_Detected;\n          Warnings_Detected := 0;\n       end if;\n-   end Finalize;\n-\n-   ----------------\n-   -- First_Node --\n-   ----------------\n-\n-   function First_Node (C : Node_Id) return Node_Id is\n-      L        : constant Source_Ptr        := Sloc (Original_Node (C));\n-      Sfile    : constant Source_File_Index := Get_Source_File_Index (L);\n-      Earliest : Node_Id;\n-      Eloc     : Source_Ptr;\n-      Discard  : Traverse_Result;\n-\n-      pragma Warnings (Off, Discard);\n-\n-      function Test_Earlier (N : Node_Id) return Traverse_Result;\n-      --  Function applied to every node in the construct\n-\n-      function Search_Tree_First is new Traverse_Func (Test_Earlier);\n-      --  Create traversal function\n-\n-      ------------------\n-      -- Test_Earlier --\n-      ------------------\n-\n-      function Test_Earlier (N : Node_Id) return Traverse_Result is\n-         Loc : constant Source_Ptr := Sloc (Original_Node (N));\n-\n-      begin\n-         --  Check for earlier. The tests for being in the same file ensures\n-         --  against strange cases of foreign code somehow being present. We\n-         --  don't want wild placement of messages if that happens, so it is\n-         --  best to just ignore this situation.\n-\n-         if Loc < Eloc\n-           and then Get_Source_File_Index (Loc) = Sfile\n-         then\n-            Earliest := Original_Node (N);\n-            Eloc     := Loc;\n-         end if;\n-\n-         return OK_Orig;\n-      end Test_Earlier;\n-\n-   --  Start of processing for First_Node\n-\n-   begin\n-      Earliest := Original_Node (C);\n-      Eloc := Sloc (Earliest);\n-      Discard := Search_Tree_First (Original_Node (C));\n-      return Earliest;\n-   end First_Node;\n-\n-   ----------------\n-   -- First_Sloc --\n-   ----------------\n-\n-   function First_Sloc (N : Node_Id) return Source_Ptr is\n-      SI : constant Source_File_Index := Source_Index (Get_Source_Unit (N));\n-      SF : constant Source_Ptr        := Source_First (SI);\n-      F  : Node_Id;\n-      S  : Source_Ptr;\n-\n-   begin\n-      F := First_Node (N);\n-      S := Sloc (F);\n-\n-      --  The following circuit is a bit subtle. When we have parenthesized\n-      --  expressions, then the Sloc will not record the location of the\n-      --  paren, but we would like to post the flag on the paren. So what\n-      --  we do is to crawl up the tree from the First_Node, adjusting the\n-      --  Sloc value for any parentheses we know are present. Yes, we know\n-      --  this circuit is not 100% reliable (e.g. because we don't record\n-      --  all possible paren level valoues), but this is only for an error\n-      --  message so it is good enough.\n-\n-      Node_Loop : loop\n-         Paren_Loop : for J in 1 .. Paren_Count (F) loop\n-\n-            --  We don't look more than 12 characters behind the current\n-            --  location, and in any case not past the front of the source.\n-\n-            Search_Loop : for K in 1 .. 12 loop\n-               exit Search_Loop when S = SF;\n-\n-               if Source_Text (SI) (S - 1) = '(' then\n-                  S := S - 1;\n-                  exit Search_Loop;\n-\n-               elsif Source_Text (SI) (S - 1) <= ' ' then\n-                  S := S - 1;\n-\n-               else\n-                  exit Search_Loop;\n-               end if;\n-            end loop Search_Loop;\n-         end loop Paren_Loop;\n-\n-         exit Node_Loop when F = N;\n-         F := Parent (F);\n-         exit Node_Loop when Nkind (F) not in N_Subexpr;\n-      end loop Node_Loop;\n-\n-      return S;\n-   end First_Sloc;\n-\n-   ----------------\n-   -- Initialize --\n-   ----------------\n-\n-   procedure Initialize is\n-   begin\n-      Errors.Init;\n-      First_Error_Msg := No_Error_Msg;\n-      Last_Error_Msg := No_Error_Msg;\n-      Serious_Errors_Detected := 0;\n-      Total_Errors_Detected := 0;\n-      Warnings_Detected := 0;\n-      Cur_Msg := No_Error_Msg;\n-      List_Pragmas.Init;\n-\n-      --  Initialize warnings table, if all warnings are suppressed, supply\n-      --  an initial dummy entry covering all possible source locations.\n-\n-      Warnings.Init;\n-      Specific_Warnings.Init;\n-\n-      if Warning_Mode = Suppress then\n-         Warnings.Increment_Last;\n-         Warnings.Table (Warnings.Last).Start := Source_Ptr'First;\n-         Warnings.Table (Warnings.Last).Stop  := Source_Ptr'Last;\n-      end if;\n-   end Initialize;\n-\n-   -----------------\n-   -- No_Warnings --\n-   -----------------\n-\n-   function No_Warnings (N : Node_Or_Entity_Id) return Boolean is\n-   begin\n-      if Error_Posted (N) then\n-         return True;\n-\n-      elsif Nkind (N) in N_Entity and then Warnings_Off (N) then\n-         return True;\n-\n-      elsif Is_Entity_Name (N)\n-        and then Present (Entity (N))\n-        and then Warnings_Off (Entity (N))\n-      then\n-         return True;\n-\n-      else\n-         return False;\n-      end if;\n-   end No_Warnings;\n-\n-   -------------\n-   -- OK_Node --\n-   -------------\n-\n-   function OK_Node (N : Node_Id) return Boolean is\n-      K : constant Node_Kind := Nkind (N);\n-\n-   begin\n-      if Error_Posted (N) then\n-         return False;\n-\n-      elsif K in N_Has_Etype\n-        and then Present (Etype (N))\n-        and then Error_Posted (Etype (N))\n-      then\n-         return False;\n-\n-      elsif (K in N_Op\n-              or else K = N_Attribute_Reference\n-              or else K = N_Character_Literal\n-              or else K = N_Expanded_Name\n-              or else K = N_Identifier\n-              or else K = N_Operator_Symbol)\n-        and then Present (Entity (N))\n-        and then Error_Posted (Entity (N))\n-      then\n-         return False;\n-      else\n-         return True;\n-      end if;\n-   end OK_Node;\n+   end Output_Messages;\n \n    ------------------------\n    -- Output_Source_Line --\n@@ -2277,17 +2318,17 @@ package body Errout is\n    -- Set_Msg_Insertion_Unit_Name --\n    ---------------------------------\n \n-   procedure Set_Msg_Insertion_Unit_Name is\n+   procedure Set_Msg_Insertion_Unit_Name (Suffix : Boolean := True) is\n    begin\n-      if Error_Msg_Unit_1 = No_Name then\n+      if Error_Msg_Unit_1 = No_Unit_Name then\n          null;\n \n-      elsif Error_Msg_Unit_1 = Error_Name then\n+      elsif Error_Msg_Unit_1 = Error_Unit_Name then\n          Set_Msg_Blank;\n          Set_Msg_Str (\"<error>\");\n \n       else\n-         Get_Unit_Name_String (Error_Msg_Unit_1);\n+         Get_Unit_Name_String (Error_Msg_Unit_1, Suffix);\n          Set_Msg_Blank;\n          Set_Msg_Quote;\n          Set_Msg_Name_Buffer;\n@@ -2457,8 +2498,8 @@ package body Errout is\n    ------------------\n \n    procedure Set_Msg_Text (Text : String; Flag : Source_Ptr) is\n-      C : Character;         -- Current character\n-      P : Natural;           -- Current index;\n+      C : Character;   -- Current character\n+      P : Natural;     -- Current index;\n \n    begin\n       Manual_Quote_Mode := False;\n@@ -2471,14 +2512,25 @@ package body Errout is\n          C := Text (P);\n          P := P + 1;\n \n-         --  Check for insertion character\n+         --  Check for insertion character or sequence\n \n          case C is\n             when '%' =>\n-               Set_Msg_Insertion_Name;\n+               if P <= Text'Last and then Text (P) = '%' then\n+                  P := P + 1;\n+                  Set_Msg_Insertion_Name_Literal;\n+               else\n+                  Set_Msg_Insertion_Name;\n+               end if;\n \n             when '$' =>\n-               Set_Msg_Insertion_Unit_Name;\n+               if P <= Text'Last and then Text (P) = '$' then\n+                  P := P + 1;\n+                  Set_Msg_Insertion_Unit_Name (Suffix => False);\n+\n+               else\n+                  Set_Msg_Insertion_Unit_Name;\n+               end if;\n \n             when '{' =>\n                Set_Msg_Insertion_File_Name;"}, {"sha": "9992cb4f5b24c7f5353d556194b831f83c13937c", "filename": "gcc/ada/errout.ads", "status": "modified", "additions": 46, "deletions": 17, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/107cd232e104d0f53bc7924bff71251388668707/gcc%2Fada%2Ferrout.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/107cd232e104d0f53bc7924bff71251388668707/gcc%2Fada%2Ferrout.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.ads?ref=107cd232e104d0f53bc7924bff71251388668707", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,9 +31,10 @@\n \n with Err_Vars;\n with Erroutc;\n+with Namet;    use Namet;\n with Table;\n-with Types; use Types;\n-with Uintp; use Uintp;\n+with Types;    use Types;\n+with Uintp;    use Uintp;\n \n with System;\n \n@@ -147,7 +148,15 @@ package Errout is\n    --      message, similarly replaced by the names which are specified by the\n    --      Name_Id values stored in Error_Msg_Name_2 and Error_Msg_Name_3. The\n    --      names are decoded and cased according to the current identifier\n-   --      casing mode.\n+   --      casing mode. Note: if a unit name ending with %b or %s is passed\n+   --      for this kind of insertion, this suffix is simply stripped. Use a\n+   --      unit name insertion ($) to process the suffix.\n+\n+   --    Insertion character %% (Double percent: insert literal name)\n+   --      The character sequence %% acts as described above for %, except\n+   --      that the name is simply obtained with Get_Name_String and is not\n+   --      decoded or cased, it is inserted literally from the names table.\n+   --      A trailing %b or %s is not treated specially.\n \n    --    Insertion character $ (Dollar: insert unit name from Names table)\n    --      The character $ is treated similarly to %, except that the name is\n@@ -157,11 +166,13 @@ package Errout is\n    --      strings. If this postfix is not required, use the normal %\n    --      insertion for the unit name.\n \n-   --    Insertion character { (Left brace: insert literally from names table)\n-   --      The character { is treated similarly to %, except that the name is\n-   --      output literally as stored in the names table without adjusting the\n-   --      casing. This can be used for file names and in other situations\n-   --      where the name string is to be output unchanged.\n+   --    Insertion character { (Left brace: insert file name from names table)\n+   --      The character { is treated similarly to %, except that the input\n+   --      value is a File_Name_Type value stored in Error_Msg_File_1 or\n+   --      Error_Msg_File_2 or Error_Msg_File_3. The value is output literally,\n+   --      enclosed in quotes as for %, but the case is not modified, the\n+   --      insertion is the exact string stored in the names table without\n+   --      adjusting the casing.\n \n    --    Insertion character * (Asterisk, insert reserved word name)\n    --      The insertion character * is treated exactly like % except that the\n@@ -384,9 +395,14 @@ package Errout is\n    Error_Msg_Name_3 : Name_Id renames Err_Vars.Error_Msg_Name_3;\n    --  Name_Id values for % insertion characters in message\n \n-   Error_Msg_Unit_1 : Name_Id renames Err_Vars.Error_Msg_Unit_1;\n-   Error_Msg_Unit_2 : Name_Id renames Err_Vars.Error_Msg_Unit_2;\n-   --  Name_Id values for $ insertion characters in message\n+   Error_Msg_File_1 : File_Name_Type renames Err_Vars.Error_Msg_File_1;\n+   Error_Msg_File_2 : File_Name_Type renames Err_Vars.Error_Msg_File_2;\n+   Error_Msg_File_3 : File_Name_Type renames Err_Vars.Error_Msg_File_3;\n+   --  File_Name_Type values for { insertion characters in message\n+\n+   Error_Msg_Unit_1 : Unit_Name_Type renames Err_Vars.Error_Msg_Unit_1;\n+   Error_Msg_Unit_2 : Unit_Name_Type renames Err_Vars.Error_Msg_Unit_2;\n+   --  Unit_Name_Type values for $ insertion characters in message\n \n    Error_Msg_Node_1 : Node_Id renames Err_Vars.Error_Msg_Node_1;\n    Error_Msg_Node_2 : Node_Id renames Err_Vars.Error_Msg_Node_2;\n@@ -545,8 +561,21 @@ package Errout is\n    --  source file before using any of the other routines in the package.\n \n    procedure Finalize;\n-   --  Finalize processing of error messages for one file and output message\n-   --  indicating the number of detected errors.\n+   --  Finalize processing of error message list. Includes processing for\n+   --  duplicated error messages, and other similar final adjustment of the\n+   --  list of error messages. Note that this procedure must be called before\n+   --  calling Compilation_Errors to determine if there were any errors. It\n+   --  is perfectly fine to call Finalize more than once. Indeed this can\n+   --  make good sense. For example, do some processing that may generate\n+   --  messages. Call Finalize to eliminate duplicates and remove deleted\n+   --  warnings. Test for compilation errors using Compilation_Errors, then\n+   --  generate some more errors/warnings, call Finalize again to make sure\n+   --  that all duplicates in these new messages are dealt with, then finally\n+   --  call Output_Messages to output the final list of messages.\n+\n+   procedure Output_Messages;\n+   --  Output list of messages, including messages giving number of detected\n+   --  errors and warnings.\n \n    procedure Error_Msg (Msg : String; Flag_Location : Source_Ptr);\n    --  Output a message at specified location. Can be called from the parser\n@@ -687,10 +716,10 @@ package Errout is\n    --  the pragma. Err is set to True on return to report the error of no\n    --  matching Warnings Off pragma preceding this one.\n \n-   function Compilation_Errors return Boolean\n-     renames Erroutc.Compilation_Errors;\n+   function Compilation_Errors return Boolean;\n    --  Returns true if errors have been detected, or warnings in -gnatwe\n-   --  (treat warnings as errors) mode.\n+   --  (treat warnings as errors) mode. Note that it is mandatory to call\n+   --  Finalize before calling this routine.\n \n    procedure Error_Msg_CRT (Feature : String; N : Node_Id);\n    --  Posts a non-fatal message on node N saying that the feature identified"}, {"sha": "4a590e437013e08cc29e6a2c5370e6ee1660114d", "filename": "gcc/ada/prepcomp.adb", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/107cd232e104d0f53bc7924bff71251388668707/gcc%2Fada%2Fprepcomp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/107cd232e104d0f53bc7924bff71251388668707/gcc%2Fada%2Fprepcomp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprepcomp.adb?ref=107cd232e104d0f53bc7924bff71251388668707", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2003-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2003-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -27,7 +27,6 @@\n with Ada.Unchecked_Deallocation;\n \n with Errout;   use Errout;\n-with Namet;    use Namet;\n with Lib.Writ; use Lib.Writ;\n with Opt;      use Opt;\n with Osint;    use Osint;\n@@ -37,6 +36,7 @@ with Scn;      use Scn;\n with Sinput.L; use Sinput.L;\n with Stringt;  use Stringt;\n with Table;\n+with Types;    use Types;\n \n package body Prepcomp is\n \n@@ -69,20 +69,20 @@ package body Prepcomp is\n \n    type Preproc_Data is record\n       Mapping      : Symbol_Table.Instance;\n-      File_Name    : Name_Id   := No_Name;\n-      Deffile      : String_Id := No_String;\n-      Undef_False  : Boolean   := False;\n-      Always_Blank : Boolean   := False;\n-      Comments     : Boolean   := False;\n-      List_Symbols : Boolean   := False;\n-      Processed    : Boolean   := False;\n+      File_Name    : File_Name_Type := No_File;\n+      Deffile      : String_Id      := No_String;\n+      Undef_False  : Boolean        := False;\n+      Always_Blank : Boolean        := False;\n+      Comments     : Boolean        := False;\n+      List_Symbols : Boolean        := False;\n+      Processed    : Boolean        := False;\n    end record;\n    --  Structure to keep the preprocessing data for a file name or for the\n    --  default (when Name_Id = No_Name).\n \n    No_Preproc_Data : constant Preproc_Data :=\n      (Mapping      => No_Mapping,\n-      File_Name    => No_Name,\n+      File_Name    => No_File,\n       Deffile      => No_String,\n       Undef_False  => False,\n       Always_Blank => False,\n@@ -295,7 +295,7 @@ package body Prepcomp is\n                   if Current_Data.File_Name =\n                        Preproc_Data_Table.Table (Index).File_Name\n                   then\n-                     Error_Msg_Name_1 := Current_Data.File_Name;\n+                     Error_Msg_File_1 := Current_Data.File_Name;\n                      Error_Msg\n                        (\"multiple preprocessing data for{\", Token_Ptr);\n                      OK := False;\n@@ -544,7 +544,7 @@ package body Prepcomp is\n \n          --  Record Current_Data\n \n-         if Current_Data.File_Name = No_Name then\n+         if Current_Data.File_Name = No_File then\n             Default_Data := Current_Data;\n \n          else\n@@ -561,6 +561,7 @@ package body Prepcomp is\n \n       if Total_Errors_Detected > T then\n          Errout.Finalize;\n+         Errout.Output_Messages;\n          Fail (\"errors found in preprocessing data file \"\"\",\n                Get_Name_String (N),\n                \"\"\"\");\n@@ -648,10 +649,11 @@ package body Prepcomp is\n          String_To_Name_Buffer (Current_Data.Deffile);\n \n          declare\n-            N : constant Name_Id := Name_Find;\n-            Deffile : constant Source_File_Index :=  Load_Definition_File (N);\n-            Add_Deffile : Boolean := True;\n-            T : constant Nat := Total_Errors_Detected;\n+            N           : constant File_Name_Type    := Name_Find;\n+            Deffile     : constant Source_File_Index :=\n+                            Load_Definition_File (N);\n+            Add_Deffile : Boolean                    := True;\n+            T           : constant Nat               := Total_Errors_Detected;\n \n          begin\n             if Deffile = No_Source_File then\n@@ -686,6 +688,7 @@ package body Prepcomp is\n \n             if T /= Total_Errors_Detected then\n                Errout.Finalize;\n+               Errout.Output_Messages;\n                Fail (\"errors found in definition file \"\"\",\n                      Get_Name_String (N),\n                      \"\"\"\");"}, {"sha": "c9b6b3837e91f094437035f1a5e601cd6e2e1ffb", "filename": "gcc/ada/prepcomp.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/107cd232e104d0f53bc7924bff71251388668707/gcc%2Fada%2Fprepcomp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/107cd232e104d0f53bc7924bff71251388668707/gcc%2Fada%2Fprepcomp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprepcomp.ads?ref=107cd232e104d0f53bc7924bff71251388668707", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2002-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2002-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -26,7 +26,7 @@\n \n --  This package stores all preprocessing data for the compiler\n \n-with Types; use Types;\n+with Namet; use Namet;\n \n package Prepcomp is\n "}]}