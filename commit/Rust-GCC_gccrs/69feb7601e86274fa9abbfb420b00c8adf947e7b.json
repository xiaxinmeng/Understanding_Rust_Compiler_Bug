{"sha": "69feb7601e86274fa9abbfb420b00c8adf947e7b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjlmZWI3NjAxZTg2Mjc0ZmE5YWJiZmI0MjBiMDBjOGFkZjk0N2U3Yg==", "commit": {"author": {"name": "Peter Bergner", "email": "bergner@linux.ibm.com", "date": "2021-07-14T23:27:02Z"}, "committer": {"name": "Peter Bergner", "email": "bergner@linux.ibm.com", "date": "2021-07-14T23:27:02Z"}, "message": "rs6000: Generate an lxvp instead of two adjacent lxv instructions\n\nThe MMA build built-ins currently use individual lxv instructions to\nload up the registers of a __vector_pair or __vector_quad.  If the\nmemory addresses of the built-in operands are to adjacent locations,\nthen we can use an lxvp in some cases to load up two registers at once.\nThe patch below adds support for checking whether memory addresses are\nadjacent and emitting an lxvp instead of two lxv instructions.\n\n2021-07-14  Peter Bergner  <bergner@linux.ibm.com>\n\ngcc/\n\t* config/rs6000/rs6000.c (adjacent_mem_locations): Return the lower\n\taddressed memory rtx, if any.\n\t(rs6000_split_multireg_move): Fix code formatting.\n\tHandle MMA build built-ins with operands in adjacent memory locations.\n\ngcc/testsuite/\n\t* gcc.target/powerpc/mma-builtin-9.c: New test.", "tree": {"sha": "401e1f3e61d0a8869d2658674cc3681aa8e292df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/401e1f3e61d0a8869d2658674cc3681aa8e292df"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/69feb7601e86274fa9abbfb420b00c8adf947e7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69feb7601e86274fa9abbfb420b00c8adf947e7b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69feb7601e86274fa9abbfb420b00c8adf947e7b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69feb7601e86274fa9abbfb420b00c8adf947e7b/comments", "author": {"login": "peter-bergner", "id": 17504345, "node_id": "MDQ6VXNlcjE3NTA0MzQ1", "avatar_url": "https://avatars.githubusercontent.com/u/17504345?v=4", "gravatar_id": "", "url": "https://api.github.com/users/peter-bergner", "html_url": "https://github.com/peter-bergner", "followers_url": "https://api.github.com/users/peter-bergner/followers", "following_url": "https://api.github.com/users/peter-bergner/following{/other_user}", "gists_url": "https://api.github.com/users/peter-bergner/gists{/gist_id}", "starred_url": "https://api.github.com/users/peter-bergner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/peter-bergner/subscriptions", "organizations_url": "https://api.github.com/users/peter-bergner/orgs", "repos_url": "https://api.github.com/users/peter-bergner/repos", "events_url": "https://api.github.com/users/peter-bergner/events{/privacy}", "received_events_url": "https://api.github.com/users/peter-bergner/received_events", "type": "User", "site_admin": false}, "committer": {"login": "peter-bergner", "id": 17504345, "node_id": "MDQ6VXNlcjE3NTA0MzQ1", "avatar_url": "https://avatars.githubusercontent.com/u/17504345?v=4", "gravatar_id": "", "url": "https://api.github.com/users/peter-bergner", "html_url": "https://github.com/peter-bergner", "followers_url": "https://api.github.com/users/peter-bergner/followers", "following_url": "https://api.github.com/users/peter-bergner/following{/other_user}", "gists_url": "https://api.github.com/users/peter-bergner/gists{/gist_id}", "starred_url": "https://api.github.com/users/peter-bergner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/peter-bergner/subscriptions", "organizations_url": "https://api.github.com/users/peter-bergner/orgs", "repos_url": "https://api.github.com/users/peter-bergner/repos", "events_url": "https://api.github.com/users/peter-bergner/events{/privacy}", "received_events_url": "https://api.github.com/users/peter-bergner/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d914777fc6c6151f430d798fc97bae927a430f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d914777fc6c6151f430d798fc97bae927a430f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d914777fc6c6151f430d798fc97bae927a430f7"}], "stats": {"total": 110, "additions": 92, "deletions": 18}, "files": [{"sha": "ce29b372bd0272c1a44572f115ef9b3e932bdca4", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 64, "deletions": 18, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69feb7601e86274fa9abbfb420b00c8adf947e7b/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69feb7601e86274fa9abbfb420b00c8adf947e7b/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=69feb7601e86274fa9abbfb420b00c8adf947e7b", "patch": "@@ -18051,23 +18051,29 @@ get_memref_parts (rtx mem, rtx *base, HOST_WIDE_INT *offset,\n   return true;\n }\n \n-/* The function returns true if the target storage location of\n-   mem1 is adjacent to the target storage location of mem2 */\n-/* Return 1 if memory locations are adjacent.  */\n+/* If the target storage locations of arguments MEM1 and MEM2 are\n+   adjacent, then return the argument that has the lower address.\n+   Otherwise, return NULL_RTX.  */\n \n-static bool\n+static rtx\n adjacent_mem_locations (rtx mem1, rtx mem2)\n {\n   rtx reg1, reg2;\n   HOST_WIDE_INT off1, size1, off2, size2;\n \n-  if (get_memref_parts (mem1, &reg1, &off1, &size1)\n-      && get_memref_parts (mem2, &reg2, &off2, &size2))\n-    return ((REGNO (reg1) == REGNO (reg2))\n-\t    && ((off1 + size1 == off2)\n-\t\t|| (off2 + size2 == off1)));\n+  if (MEM_P (mem1)\n+      && MEM_P (mem2)\n+      && get_memref_parts (mem1, &reg1, &off1, &size1)\n+      && get_memref_parts (mem2, &reg2, &off2, &size2)\n+      && REGNO (reg1) == REGNO (reg2))\n+    {\n+      if (off1 + size1 == off2)\n+\treturn mem1;\n+      else if (off2 + size2 == off1)\n+\treturn mem2;\n+    }\n \n-  return false;\n+  return NULL_RTX;\n }\n \n /* This function returns true if it can be determined that the two MEM\n@@ -26708,8 +26714,8 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n \n \t  for (int i = 0; i < nregs; i += reg_mode_nregs)\n \t    {\n-\t      unsigned subreg =\n-\t\t(WORDS_BIG_ENDIAN) ? i : (nregs - reg_mode_nregs - i);\n+\t      unsigned subreg\n+\t\t= WORDS_BIG_ENDIAN ? i : (nregs - reg_mode_nregs - i);\n \t      rtx dst2 = adjust_address (dst, reg_mode, offset);\n \t      rtx src2 = gen_rtx_REG (reg_mode, reg + subreg);\n \t      offset += size;\n@@ -26726,8 +26732,8 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n \n \t  for (int i = 0; i < nregs; i += reg_mode_nregs)\n \t    {\n-\t      unsigned subreg =\n-\t\t(WORDS_BIG_ENDIAN) ? i : (nregs - reg_mode_nregs - i);\n+\t      unsigned subreg\n+\t\t= WORDS_BIG_ENDIAN ? i : (nregs - reg_mode_nregs - i);\n \t      rtx dst2 = gen_rtx_REG (reg_mode, reg + subreg);\n \t      rtx src2 = adjust_address (src, reg_mode, offset);\n \t      offset += size;\n@@ -26752,13 +26758,53 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n \t  if (GET_MODE (src) == OOmode)\n \t    gcc_assert (VSX_REGNO_P (REGNO (dst)));\n \n-\t  reg_mode = GET_MODE (XVECEXP (src, 0, 0));\n \t  int nvecs = XVECLEN (src, 0);\n \t  for (int i = 0; i < nvecs; i++)\n \t    {\n-\t      int index = WORDS_BIG_ENDIAN ? i : nvecs - 1 - i;\n-\t      rtx dst_i = gen_rtx_REG (reg_mode, reg + index);\n-\t      emit_insn (gen_rtx_SET (dst_i, XVECEXP (src, 0, i)));\n+\t      rtx op;\n+\t      int regno = reg + i;\n+\n+\t      if (WORDS_BIG_ENDIAN)\n+\t\t{\n+\t\t  op = XVECEXP (src, 0, i);\n+\n+\t\t  /* If we are loading an even VSX register and the memory location\n+\t\t     is adjacent to the next register's memory location (if any),\n+\t\t     then we can load them both with one LXVP instruction.  */\n+\t\t  if ((regno & 1) == 0)\n+\t\t    {\n+\t\t      rtx op2 = XVECEXP (src, 0, i + 1);\n+\t\t      if (adjacent_mem_locations (op, op2) == op)\n+\t\t\t{\n+\t\t\t  op = adjust_address (op, OOmode, 0);\n+\t\t\t  /* Skip the next register, since we're going to\n+\t\t\t     load it together with this register.  */\n+\t\t\t  i++;\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  op = XVECEXP (src, 0, nvecs - i - 1);\n+\n+\t\t  /* If we are loading an even VSX register and the memory location\n+\t\t     is adjacent to the next register's memory location (if any),\n+\t\t     then we can load them both with one LXVP instruction.  */\n+\t\t  if ((regno & 1) == 0)\n+\t\t    {\n+\t\t\t  rtx op2 = XVECEXP (src, 0, nvecs - i - 2);\n+\t\t\t  if (adjacent_mem_locations (op2, op) == op2)\n+\t\t\t    {\n+\t\t\t      op = adjust_address (op2, OOmode, 0);\n+\t\t\t      /* Skip the next register, since we're going to\n+\t\t\t\t load it together with this register.  */\n+\t\t\t      i++;\n+\t\t\t    }\n+\t\t    }\n+\t\t}\n+\n+\t      rtx dst_i = gen_rtx_REG (GET_MODE (op), regno);\n+\t      emit_insn (gen_rtx_SET (dst_i, op));\n \t    }\n \n \t  /* We are writing an accumulator register, so we have to"}, {"sha": "397d0f1db359668ceb103c99ef4b1d6f19bc80a5", "filename": "gcc/testsuite/gcc.target/powerpc/mma-builtin-9.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69feb7601e86274fa9abbfb420b00c8adf947e7b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmma-builtin-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69feb7601e86274fa9abbfb420b00c8adf947e7b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmma-builtin-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmma-builtin-9.c?ref=69feb7601e86274fa9abbfb420b00c8adf947e7b", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target power10_ok } */\n+/* { dg-options \"-mdejagnu-cpu=power10 -O2\" } */\n+\n+typedef unsigned char  vec_t __attribute__((vector_size(16)));\n+\n+void\n+foo (__vector_pair *dst, vec_t *src)\n+{\n+  __vector_pair pair;\n+  /* Adjacent loads should be combined into one lxvp instruction.  */\n+  __builtin_vsx_build_pair (&pair, src[0], src[1]);\n+  *dst = pair;\n+}\n+\n+void\n+bar (__vector_quad *dst, vec_t *src)\n+{\n+  __vector_quad quad;\n+  /* Adjacent loads should be combined into two lxvp instructions.  */\n+  __builtin_mma_build_acc (&quad, src[0], src[1], src[2], src[3]);\n+  *dst = quad;\n+}\n+\n+/* { dg-final { scan-assembler-not {\\mlxv\\M} } } */\n+/* { dg-final { scan-assembler-not {\\mstxv\\M} } } */\n+/* { dg-final { scan-assembler-times {\\mlxvp\\M} 3 } } */\n+/* { dg-final { scan-assembler-times {\\mstxvp\\M} 3 } } */"}]}