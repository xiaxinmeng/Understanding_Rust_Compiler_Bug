{"sha": "1d6e90ac10263b976699d6c039dc9a49c0598aaa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWQ2ZTkwYWMxMDI2M2I5NzY2OTlkNmMwMzlkYzlhNDljMDU5OGFhYQ==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2002-01-16T12:25:53Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2002-01-16T12:25:53Z"}, "message": "General formatting tidy up.\n\nFrom-SVN: r48907", "tree": {"sha": "ee5d3aa23fdbedd7ef98416bcd5cda165f704aed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ee5d3aa23fdbedd7ef98416bcd5cda165f704aed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1d6e90ac10263b976699d6c039dc9a49c0598aaa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d6e90ac10263b976699d6c039dc9a49c0598aaa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d6e90ac10263b976699d6c039dc9a49c0598aaa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d6e90ac10263b976699d6c039dc9a49c0598aaa/comments", "author": null, "committer": null, "parents": [{"sha": "60e8b9f0d18271ca2cb46f1b732ba4328eacf6b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60e8b9f0d18271ca2cb46f1b732ba4328eacf6b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60e8b9f0d18271ca2cb46f1b732ba4328eacf6b4"}], "stats": {"total": 394, "additions": 233, "deletions": 161}, "files": [{"sha": "03e675b482d8910a3f007bd3a4ab866da91cdf88", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d6e90ac10263b976699d6c039dc9a49c0598aaa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d6e90ac10263b976699d6c039dc9a49c0598aaa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1d6e90ac10263b976699d6c039dc9a49c0598aaa", "patch": "@@ -1,4 +1,8 @@\n-2002-01-26  Graham Stott  <grahams@redhat.com>\n+2002-01-16  Nick Clifton  <nickc@cambridge.redhat.com>\n+\n+\t* config/arm/arm.c: General formatting tidy up.\n+\n+2002-01-16  Graham Stott  <grahams@redhat.com>\n \n \t* calls.c (try_to_integrate): Use \"(size_t)\" intermediate\n \tcast and when casting an integer literal to \"rtx\" pointer.\n@@ -8,7 +12,7 @@\n \t* integrate.c (expand_iline_function): Likewise.\n \t* regmove.c (try_auto_increment): Likewise.\n \n-2002-01-26  Graham Stott  <grahams@redhat.com>\n+2002-01-16  Graham Stott  <grahams@redhat.com>\n \n \t* sched-rgn.c (passed): Use sbitmap_free.\n \t(header): Likewise."}, {"sha": "00b1b1958fb7cd455cb053da14327972de7e45ec", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 227, "deletions": 159, "changes": 386, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d6e90ac10263b976699d6c039dc9a49c0598aaa/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d6e90ac10263b976699d6c039dc9a49c0598aaa/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=1d6e90ac10263b976699d6c039dc9a49c0598aaa", "patch": "@@ -1,5 +1,5 @@\n /* Output routines for GCC for ARM.\n-   Copyright (C) 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001\n+   Copyright (C) 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002\n    Free Software Foundation, Inc.\n    Contributed by Pieter `Tiggr' Schoenmakers (rcpieter@win.tue.nl)\n    and Martin Simmons (@harleqn.co.uk).\n@@ -60,6 +60,8 @@ typedef struct minipool_fixup   Mfix;\n #define Ulong    unsigned long\n #define Ccstar   const char *\n \n+const struct attribute_spec arm_attribute_table[];\n+\n /* Forward function declarations.  */\n static void      arm_add_gc_roots \t\tPARAMS ((void));\n static int       arm_gen_constant\t\tPARAMS ((enum rtx_code, Mmode, Hint, rtx, rtx, int, int));\n@@ -69,8 +71,7 @@ static int       eliminate_lr2ip\t\tPARAMS ((rtx *));\n static rtx\t emit_multi_reg_push\t\tPARAMS ((int));\n static rtx\t emit_sfm\t\t\tPARAMS ((int, int));\n #ifndef AOF_ASSEMBLER\n-static bool\t arm_assemble_integer\t\tPARAMS ((rtx, unsigned int,\n-\t\t\t\t\t\t\t int));\n+static bool\t arm_assemble_integer\t\tPARAMS ((rtx, unsigned int, int));\n #endif\n static Ccstar    fp_const_from_val\t\tPARAMS ((REAL_VALUE_TYPE *));\n static arm_cc    get_arm_condition_code\t\tPARAMS ((rtx));\n@@ -104,26 +105,21 @@ static void\t push_minipool_barrier\t        PARAMS ((rtx, Hint));\n static void\t push_minipool_fix\t\tPARAMS ((rtx, Hint, rtx *, Mmode, rtx));\n static void\t note_invalid_constants\t        PARAMS ((rtx, Hint));\n static int       current_file_function_operand\tPARAMS ((rtx));\n-static Ulong arm_compute_save_reg0_reg12_mask   PARAMS ((void));\n+static Ulong\t arm_compute_save_reg0_reg12_mask  PARAMS ((void));\n static Ulong     arm_compute_save_reg_mask\tPARAMS ((void));\n static Ulong     arm_isr_value \t\t\tPARAMS ((tree));\n static Ulong     arm_compute_func_type\t\tPARAMS ((void));\n-static tree      arm_handle_fndecl_attribute PARAMS ((tree *, tree, tree, int, bool *));\n-static tree      arm_handle_isr_attribute PARAMS ((tree *, tree, tree, int, bool *));\n-const struct attribute_spec arm_attribute_table[];\n-static void\t arm_output_function_epilogue\tPARAMS ((FILE *,\n-\t\t\t\t\t\t\t HOST_WIDE_INT));\n-static void\t arm_output_function_prologue\tPARAMS ((FILE *,\n-\t\t\t\t\t\t\t HOST_WIDE_INT));\n-static void\t thumb_output_function_prologue PARAMS ((FILE *,\n-\t\t\t\t\t\t\t HOST_WIDE_INT));\n+static tree      arm_handle_fndecl_attribute    PARAMS ((tree *, tree, tree, int, bool *));\n+static tree      arm_handle_isr_attribute       PARAMS ((tree *, tree, tree, int, bool *));\n+static void\t arm_output_function_epilogue\tPARAMS ((FILE *, Hint));\n+static void\t arm_output_function_prologue\tPARAMS ((FILE *, Hint));\n+static void\t thumb_output_function_prologue PARAMS ((FILE *, Hint));\n static int\t arm_comp_type_attributes\tPARAMS ((tree, tree));\n-static void\t arm_set_default_type_attributes\tPARAMS ((tree));\n+static void\t arm_set_default_type_attributes  PARAMS ((tree));\n+static int\t arm_adjust_cost\t\tPARAMS ((rtx, rtx, rtx, int));\n #ifdef OBJECT_FORMAT_ELF\n-static void\t arm_elf_asm_named_section\tPARAMS ((const char *,\n-\t\t\t\t\t\t\t unsigned int));\n+static void\t arm_elf_asm_named_section\tPARAMS ((const char *, unsigned int));\n #endif\n-static int\t arm_adjust_cost\t\tPARAMS ((rtx, rtx, rtx, int));\n \n #undef Hint\n #undef Mmode\n@@ -132,59 +128,59 @@ static int\t arm_adjust_cost\t\tPARAMS ((rtx, rtx, rtx, int));\n \f\n /* Initialize the GCC target structure.  */\n #ifdef TARGET_DLLIMPORT_DECL_ATTRIBUTES\n-#undef TARGET_MERGE_DECL_ATTRIBUTES\n+#undef  TARGET_MERGE_DECL_ATTRIBUTES\n #define TARGET_MERGE_DECL_ATTRIBUTES merge_dllimport_decl_attributes\n #endif\n \n-#undef TARGET_ATTRIBUTE_TABLE\n+#undef  TARGET_ATTRIBUTE_TABLE\n #define TARGET_ATTRIBUTE_TABLE arm_attribute_table\n \n #ifdef AOF_ASSEMBLER\n-#undef TARGET_ASM_BYTE_OP\n+#undef  TARGET_ASM_BYTE_OP\n #define TARGET_ASM_BYTE_OP \"\\tDCB\\t\"\n-#undef TARGET_ASM_ALIGNED_HI_OP\n+#undef  TARGET_ASM_ALIGNED_HI_OP\n #define TARGET_ASM_ALIGNED_HI_OP \"\\tDCW\\t\"\n-#undef TARGET_ASM_ALIGNED_SI_OP\n+#undef  TARGET_ASM_ALIGNED_SI_OP\n #define TARGET_ASM_ALIGNED_SI_OP \"\\tDCD\\t\"\n #else\n-#undef TARGET_ASM_ALIGNED_SI_OP\n+#undef  TARGET_ASM_ALIGNED_SI_OP\n #define TARGET_ASM_ALIGNED_SI_OP NULL\n-#undef TARGET_ASM_INTEGER\n+#undef  TARGET_ASM_INTEGER\n #define TARGET_ASM_INTEGER arm_assemble_integer\n #endif\n \n-#undef TARGET_ASM_FUNCTION_PROLOGUE\n+#undef  TARGET_ASM_FUNCTION_PROLOGUE\n #define TARGET_ASM_FUNCTION_PROLOGUE arm_output_function_prologue\n \n-#undef TARGET_ASM_FUNCTION_EPILOGUE\n+#undef  TARGET_ASM_FUNCTION_EPILOGUE\n #define TARGET_ASM_FUNCTION_EPILOGUE arm_output_function_epilogue\n \n-#undef TARGET_COMP_TYPE_ATTRIBUTES\n+#undef  TARGET_COMP_TYPE_ATTRIBUTES\n #define TARGET_COMP_TYPE_ATTRIBUTES arm_comp_type_attributes\n \n-#undef TARGET_SET_DEFAULT_TYPE_ATTRIBUTES\n+#undef  TARGET_SET_DEFAULT_TYPE_ATTRIBUTES\n #define TARGET_SET_DEFAULT_TYPE_ATTRIBUTES arm_set_default_type_attributes\n \n-#undef TARGET_INIT_BUILTINS\n+#undef  TARGET_INIT_BUILTINS\n #define TARGET_INIT_BUILTINS arm_init_builtins\n \n-#undef TARGET_EXPAND_BUILTIN\n+#undef  TARGET_EXPAND_BUILTIN\n #define TARGET_EXPAND_BUILTIN arm_expand_builtin\n \n-#undef TARGET_SCHED_ADJUST_COST\n+#undef  TARGET_SCHED_ADJUST_COST\n #define TARGET_SCHED_ADJUST_COST arm_adjust_cost\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Obstack for minipool constant handling.  */\n static struct obstack minipool_obstack;\n-static char *minipool_startobj;\n+static char *         minipool_startobj;\n \n-#define obstack_chunk_alloc xmalloc\n-#define obstack_chunk_free free\n+#define obstack_chunk_alloc   xmalloc\n+#define obstack_chunk_free    free\n \n-/* The maximum number of insns skipped which will be conditionalised if\n-   possible.  */\n+/* The maximum number of insns skipped which\n+   will be conditionalised if possible.  */\n static int max_insns_skipped = 5;\n \n extern FILE * asm_out_file;\n@@ -225,8 +221,8 @@ int    arm_structure_size_boundary = DEFAULT_STRUCTURE_SIZE_BOUNDARY;\n #define FL_ARCH5E     (1 << 9)        /* DSP extenstions to v5 */\n #define FL_XSCALE     (1 << 10)\t      /* XScale */\n \n-/* The bits in this mask specify which instructions we are\n-   allowed to generate.  */\n+/* The bits in this mask specify which\n+   instructions we are allowed to generate.  */\n static int insn_flags = 0;\n \n /* The bits in this mask specify which instruction scheduling options should\n@@ -295,7 +291,7 @@ rtx arm_target_insn;\n int arm_target_label;\n \n /* The condition codes of the ARM, and the inverse function.  */\n-static const char *const arm_condition_codes[] =\n+static const char * const arm_condition_codes[] =\n {\n   \"eq\", \"ne\", \"cs\", \"cc\", \"mi\", \"pl\", \"vs\", \"vc\",\n   \"hi\", \"ls\", \"ge\", \"lt\", \"gt\", \"le\", \"al\", \"nv\"\n@@ -811,7 +807,7 @@ arm_isr_value (argument)\n      tree argument;\n {\n   const isr_attribute_arg * ptr;\n-  const char *        arg;\n+  const char *              arg;\n \n   /* No argument - default to IRQ.  */\n   if (argument == NULL_TREE)\n@@ -826,8 +822,8 @@ arm_isr_value (argument)\n \n   /* Check it against the list of known arguments.  */\n   for (ptr = isr_attribute_args; ptr->arg != NULL; ptr ++)\n-    if (strcmp (arg, ptr->arg) == 0)\n-\treturn ptr->return_value;\n+    if (streq (arg, ptr->arg))\n+      return ptr->return_value;\n \n   /* An unrecognised interrupt type.  */\n   return ARM_FT_UNKNOWN;\n@@ -1101,6 +1097,7 @@ count_insns_for_constant (HOST_WIDE_INT remainder, int i)\n \n /* As above, but extra parameter GENERATE which, if clear, suppresses\n    RTL generation.  */\n+\n static int\n arm_gen_constant (code, mode, val, target, source, subtargets, generate)\n      enum rtx_code code;\n@@ -1672,14 +1669,17 @@ arm_gen_constant (code, mode, val, target, source, subtargets, generate)\n \t    i -= 6;\n \t  }\n \ti -= 2;\n-      } while (remainder);\n+      }\n+    while (remainder);\n   }\n+\n   return insns;\n }\n \n /* Canonicalize a comparison so that we are more likely to recognize it.\n    This can be done for a few constant compares, where we can make the\n    immediate value easier to load.  */\n+\n enum rtx_code\n arm_canonicalize_comparison (code, op1)\n      enum rtx_code code;\n@@ -1743,6 +1743,7 @@ arm_canonicalize_comparison (code, op1)\n /* Decide whether a type should be returned in memory (true)\n    or in a register (false).  This is called by the macro\n    RETURN_IN_MEMORY.  */\n+\n int\n arm_return_in_memory (type)\n      tree type;\n@@ -1877,6 +1878,7 @@ arm_init_cumulative_args (pcum, fntype, libname, indirect)\n     the preceding args and about the function being called.\n    NAMED is nonzero if this argument is a named parameter\n     (otherwise it is an extra parameter matching an ellipsis).  */\n+\n rtx\n arm_function_arg (pcum, mode, type, named)\n      CUMULATIVE_ARGS * pcum;\n@@ -1906,25 +1908,24 @@ static arm_pragma_enum arm_pragma_long_calls = OFF;\n \n void\n arm_pr_long_calls (pfile)\n-     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+     cpp_reader * pfile ATTRIBUTE_UNUSED;\n {\n   arm_pragma_long_calls = LONG;\n }\n \n void\n arm_pr_no_long_calls (pfile)\n-     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+     cpp_reader * pfile ATTRIBUTE_UNUSED;\n {\n   arm_pragma_long_calls = SHORT;\n }\n \n void\n arm_pr_long_calls_off (pfile)\n-     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+     cpp_reader * pfile ATTRIBUTE_UNUSED;\n {\n   arm_pragma_long_calls = OFF;\n }\n-\n \f\n /* Table of machine attributes.  */\n const struct attribute_spec arm_attribute_table[] =\n@@ -1960,13 +1961,14 @@ const struct attribute_spec arm_attribute_table[] =\n \n /* Handle an attribute requiring a FUNCTION_DECL;\n    arguments as in struct attribute_spec.handler.  */\n+\n static tree\n arm_handle_fndecl_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n+     tree * node;\n+     tree   name;\n+     tree   args ATTRIBUTE_UNUSED;\n+     int    flags ATTRIBUTE_UNUSED;\n+     bool * no_add_attrs;\n {\n   if (TREE_CODE (*node) != FUNCTION_DECL)\n     {\n@@ -1980,13 +1982,14 @@ arm_handle_fndecl_attribute (node, name, args, flags, no_add_attrs)\n \n /* Handle an \"interrupt\" or \"isr\" attribute;\n    arguments as in struct attribute_spec.handler.  */\n+\n static tree\n arm_handle_isr_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args;\n-     int flags;\n-     bool *no_add_attrs;\n+     tree * node;\n+     tree   name;\n+     tree   args;\n+     int    flags;\n+     bool * no_add_attrs;\n {\n   if (DECL_P (*node))\n     {\n@@ -2016,10 +2019,9 @@ arm_handle_isr_attribute (node, name, args, flags, no_add_attrs)\n \t       && arm_isr_value (args) != ARM_FT_UNKNOWN)\n \t{\n \t  *node = build_type_copy (*node);\n-\t  TREE_TYPE (*node) = build_type_attribute_variant (TREE_TYPE (*node),\n-\t\t\t\t\t\t\t    tree_cons (name,\n-\t\t\t\t\t\t\t\t       args,\n-\t\t\t\t\t\t\t\t       TYPE_ATTRIBUTES (TREE_TYPE (*node))));\n+\t  TREE_TYPE (*node) = build_type_attribute_variant\n+\t    (TREE_TYPE (*node),\n+\t     tree_cons (name, args, TYPE_ATTRIBUTES (TREE_TYPE (*node))));\n \t  *no_add_attrs = true;\n \t}\n       else\n@@ -2045,6 +2047,7 @@ arm_handle_isr_attribute (node, name, args, flags, no_add_attrs)\n /* Return 0 if the attributes for two types are incompatible, 1 if they\n    are compatible, and 2 if they are nearly compatible (which causes a\n    warning to be generated).  */\n+\n static int\n arm_comp_type_attributes (type1, type2)\n      tree type1;\n@@ -2089,6 +2092,7 @@ arm_comp_type_attributes (type1, type2)\n \n /*  Encode long_call or short_call attribute by prefixing\n     symbol name in DECL with a special character FLAG.  */\n+\n void\n arm_encode_call_attribute (decl, flag)\n   tree decl;\n@@ -2116,6 +2120,7 @@ arm_encode_call_attribute (decl, flag)\n /*  Assigns default attributes to newly defined type.  This is used to\n     set short_call/long_call attributes for function types of\n     functions defined inside corresponding #pragma scopes.  */\n+\n static void\n arm_set_default_type_attributes (type)\n   tree type;\n@@ -2143,6 +2148,7 @@ arm_set_default_type_attributes (type)\n /* Return 1 if the operand is a SYMBOL_REF for a function known to be\n    defined within the current compilation unit.  If this caanot be\n    determined, then 0 is returned.  */\n+\n static int\n current_file_function_operand (sym_ref)\n   rtx sym_ref;\n@@ -2185,6 +2191,7 @@ current_file_function_operand (sym_ref)\n    \"call_symbol\" and \"call_symbol_value\" patterns and to 0 in the \"call\"\n    and \"call_value\" patterns.  This is because of the difference in the\n    SYM_REFs passed by these patterns.  */\n+\n int\n arm_is_longcall_p (sym_ref, call_cookie, call_symbol)\n   rtx sym_ref;\n@@ -2217,6 +2224,7 @@ arm_is_longcall_p (sym_ref, call_cookie, call_symbol)\n }\n \n /* Return non-zero if it is ok to make a tail-call to DECL.  */\n+\n int\n arm_function_ok_for_sibcall (decl)\n      tree decl;\n@@ -2922,7 +2930,7 @@ arm_adjust_cost (insn, link, dep, cost)\n \n static int fpa_consts_inited = 0;\n \n-static const char *const strings_fpa[8] =\n+static const char * const strings_fpa[8] =\n {\n   \"0\",   \"1\",   \"2\",   \"3\",\n   \"4\",   \"5\",   \"0.5\", \"10\"\n@@ -3004,7 +3012,7 @@ neg_const_double_rtx_ok_for_fpu (x)\n \n int\n s_register_operand (op, mode)\n-     register rtx op;\n+     rtx op;\n      enum machine_mode mode;\n {\n   if (GET_MODE (op) != mode && mode != VOIDmode)\n@@ -3022,9 +3030,10 @@ s_register_operand (op, mode)\n }\n \n /* A hard register operand (even before reload.  */\n+\n int\n arm_hard_register_operand (op, mode)\n-     register rtx op;\n+     rtx op;\n      enum machine_mode mode;\n {\n   if (GET_MODE (op) != mode && mode != VOIDmode)\n@@ -3038,7 +3047,7 @@ arm_hard_register_operand (op, mode)\n \n int\n reg_or_int_operand (op, mode)\n-     register rtx op;\n+     rtx op;\n      enum machine_mode mode;\n {\n   if (GET_CODE (op) == CONST_INT)\n@@ -3078,6 +3087,7 @@ arm_reload_memory_operand (op, mode)\n    emitting patterns.  In this latter case we cannot use memory_operand()\n    because it will fail on badly formed MEMs, which is precisly what we are\n    trying to catch.  */\n+\n int\n bad_signed_byte_operand (op, mode)\n      rtx op;\n@@ -3120,8 +3130,8 @@ arm_rhs_operand (op, mode)\n \t  || (GET_CODE (op) == CONST_INT && const_ok_for_arm (INTVAL (op))));\n }\n \n-/* Return TRUE for valid operands for the rhs of an ARM instruction, or a load.\n- */\n+/* Return TRUE for valid operands for the\n+   rhs of an ARM instruction, or a load.  */\n \n int\n arm_rhsm_operand (op, mode)\n@@ -3163,9 +3173,10 @@ arm_not_operand (op, mode)\n \n /* Return TRUE if the operand is a memory reference which contains an\n    offsettable address.  */\n+\n int\n offsettable_memory_operand (op, mode)\n-     register rtx op;\n+     rtx op;\n      enum machine_mode mode;\n {\n   if (mode == VOIDmode)\n@@ -3179,9 +3190,10 @@ offsettable_memory_operand (op, mode)\n \n /* Return TRUE if the operand is a memory reference which is, or can be\n    made word aligned by adjusting the offset.  */\n+\n int\n alignable_memory_operand (op, mode)\n-     register rtx op;\n+     rtx op;\n      enum machine_mode mode;\n {\n   rtx reg;\n@@ -3207,9 +3219,10 @@ alignable_memory_operand (op, mode)\n \n /* Similar to s_register_operand, but does not allow hard integer \n    registers.  */\n+\n int\n f_register_operand (op, mode)\n-     register rtx op;\n+     rtx op;\n      enum machine_mode mode;\n {\n   if (GET_MODE (op) != mode && mode != VOIDmode)\n@@ -3272,8 +3285,10 @@ power_of_two_operand (op, mode)\n   if (GET_CODE (op) == CONST_INT)\n     {\n       HOST_WIDE_INT value = INTVAL (op);\n+\n       return value != 0  &&  (value & (value - 1)) == 0;\n     }\n+\n   return FALSE;\n }\n \n@@ -3311,6 +3326,7 @@ di_operand (op, mode)\n }\n \n /* Like di_operand, but don't accept constants.  */\n+\n int\n nonimmediate_di_operand (op, mode)\n      rtx op;\n@@ -3342,7 +3358,14 @@ soft_df_operand (op, mode)\n      enum machine_mode mode;\n {\n   if (s_register_operand (op, mode))\n-    return TRUE;\n+    {\n+      if (GET_CODE (op) == SUBREG)\n+\top = SUBREG_REG (op);\n+\n+      if (REGNO (op) == IP_REGNUM)\n+\treturn FALSE;\n+      return TRUE;\n+    }\n \n   if (mode != VOIDmode && GET_MODE (op) != mode)\n     return FALSE;\n@@ -3367,13 +3390,21 @@ soft_df_operand (op, mode)\n }\n \n /* Like soft_df_operand, but don't accept constants.  */\n+\n int\n nonimmediate_soft_df_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n   if (s_register_operand (op, mode))\n-    return TRUE;\n+    {\n+      if (GET_CODE (op) == SUBREG)\n+\top = SUBREG_REG (op);\n+\n+      if (REGNO (op) == IP_REGNUM)\n+\treturn FALSE;\n+      return TRUE;\n+    }\n \n   if (mode != VOIDmode && GET_MODE (op) != mode)\n     return FALSE;\n@@ -3387,6 +3418,7 @@ nonimmediate_soft_df_operand (op, mode)\n }\n \n /* Return TRUE for valid index operands.  */\n+\n int\n index_operand (op, mode)\n      rtx op;\n@@ -3421,15 +3453,15 @@ shiftable_operator (x, mode)\n      rtx x;\n      enum machine_mode mode;\n {\n+  enum rtx_code code;\n+\n   if (GET_MODE (x) != mode)\n     return FALSE;\n-  else\n-    {\n-      enum rtx_code code = GET_CODE (x);\n \n-      return (code == PLUS || code == MINUS\n-\t      || code == IOR || code == XOR || code == AND);\n-    }\n+  code = GET_CODE (x);\n+\n+  return (code == PLUS || code == MINUS\n+\t  || code == IOR || code == XOR || code == AND);\n }\n \n /* Return TRUE for binary logical operators.  */\n@@ -3439,14 +3471,14 @@ logical_binary_operator (x, mode)\n      rtx x;\n      enum machine_mode mode;\n {\n+  enum rtx_code code;\n+\n   if (GET_MODE (x) != mode)\n     return FALSE;\n-  else\n-    {\n-      enum rtx_code code = GET_CODE (x);\n \n-      return (code == IOR || code == XOR || code == AND);\n-    }\n+  code = GET_CODE (x);\n+\n+  return (code == IOR || code == XOR || code == AND);\n }\n \n /* Return TRUE for shift operators.  */\n@@ -3456,21 +3488,22 @@ shift_operator (x, mode)\n      rtx x;\n      enum machine_mode mode;\n {\n+  enum rtx_code code;\n+\n   if (GET_MODE (x) != mode)\n     return FALSE;\n-  else\n-    {\n-      enum rtx_code code = GET_CODE (x);\n \n-      if (code == MULT)\n-\treturn power_of_two_operand (XEXP (x, 1), mode);\n+  code = GET_CODE (x);\n \n-      return (code == ASHIFT || code == ASHIFTRT || code == LSHIFTRT\n-\t      || code == ROTATERT);\n-    }\n+  if (code == MULT)\n+    return power_of_two_operand (XEXP (x, 1), mode);\n+\n+  return (code == ASHIFT || code == ASHIFTRT || code == LSHIFTRT\n+\t  || code == ROTATERT);\n }\n \n /* Return TRUE if x is EQ or NE.  */\n+\n int\n equality_operator (x, mode)\n      rtx x;\n@@ -3480,6 +3513,7 @@ equality_operator (x, mode)\n }\n \n /* Return TRUE if x is a comparison operator other than LTGT or UNEQ.  */\n+\n int\n arm_comparison_operator (x, mode)\n      rtx x;\n@@ -3491,6 +3525,7 @@ arm_comparison_operator (x, mode)\n }\n \n /* Return TRUE for SMIN SMAX UMIN UMAX operators.  */\n+\n int\n minmax_operator (x, mode)\n      rtx x;\n@@ -3506,6 +3541,7 @@ minmax_operator (x, mode)\n \n /* Return TRUE if this is the condition code register, if we aren't given\n    a mode, accept any class CCmode register.  */\n+\n int\n cc_register (x, mode)\n      rtx x;\n@@ -3530,6 +3566,7 @@ cc_register (x, mode)\n /* Return TRUE if this is the condition code register, if we aren't given\n    a mode, accept any class CCmode register which indicates a dominance\n    expression.  */\n+\n int\n dominant_cc_register (x, mode)\n      rtx x;\n@@ -3554,12 +3591,13 @@ dominant_cc_register (x, mode)\n }\n \n /* Return TRUE if X references a SYMBOL_REF.  */\n+\n int\n symbol_mentioned_p (x)\n      rtx x;\n {\n-  register const char * fmt;\n-  register int i;\n+  const char * fmt;\n+  int i;\n \n   if (GET_CODE (x) == SYMBOL_REF)\n     return 1;\n@@ -3570,7 +3608,7 @@ symbol_mentioned_p (x)\n     {\n       if (fmt[i] == 'E')\n \t{\n-\t  register int j;\n+\t  int j;\n \n \t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n \t    if (symbol_mentioned_p (XVECEXP (x, i, j)))\n@@ -3584,12 +3622,13 @@ symbol_mentioned_p (x)\n }\n \n /* Return TRUE if X references a LABEL_REF.  */\n+\n int\n label_mentioned_p (x)\n      rtx x;\n {\n-  register const char * fmt;\n-  register int i;\n+  const char * fmt;\n+  int i;\n \n   if (GET_CODE (x) == LABEL_REF)\n     return 1;\n@@ -3599,7 +3638,7 @@ label_mentioned_p (x)\n     {\n       if (fmt[i] == 'E')\n \t{\n-\t  register int j;\n+\t  int j;\n \n \t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n \t    if (label_mentioned_p (XVECEXP (x, i, j)))\n@@ -3631,41 +3670,45 @@ minmax_code (x)\n }\n \n /* Return 1 if memory locations are adjacent.  */\n+\n int\n adjacent_mem_locations (a, b)\n      rtx a, b;\n {\n-  int val0 = 0, val1 = 0;\n-  int reg0, reg1;\n-  \n   if ((GET_CODE (XEXP (a, 0)) == REG\n        || (GET_CODE (XEXP (a, 0)) == PLUS\n \t   && GET_CODE (XEXP (XEXP (a, 0), 1)) == CONST_INT))\n       && (GET_CODE (XEXP (b, 0)) == REG\n \t  || (GET_CODE (XEXP (b, 0)) == PLUS\n \t      && GET_CODE (XEXP (XEXP (b, 0), 1)) == CONST_INT)))\n     {\n+      int val0 = 0, val1 = 0;\n+      int reg0, reg1;\n+  \n       if (GET_CODE (XEXP (a, 0)) == PLUS)\n         {\n-\t  reg0 = REGNO (XEXP (XEXP (a, 0), 0));\n+\t  reg0 = REGNO  (XEXP (XEXP (a, 0), 0));\n \t  val0 = INTVAL (XEXP (XEXP (a, 0), 1));\n         }\n       else\n \treg0 = REGNO (XEXP (a, 0));\n+\n       if (GET_CODE (XEXP (b, 0)) == PLUS)\n         {\n-\t  reg1 = REGNO (XEXP (XEXP (b, 0), 0));\n+\t  reg1 = REGNO  (XEXP (XEXP (b, 0), 0));\n \t  val1 = INTVAL (XEXP (XEXP (b, 0), 1));\n         }\n       else\n \treg1 = REGNO (XEXP (b, 0));\n+\n       return (reg0 == reg1) && ((val1 - val0) == 4 || (val0 - val1) == 4);\n     }\n   return 0;\n }\n \n /* Return 1 if OP is a load multiple operation.  It is known to be\n    parallel and the first section will be tested.  */\n+\n int\n load_multiple_operation (op, mode)\n      rtx op;\n@@ -3728,6 +3771,7 @@ load_multiple_operation (op, mode)\n \n /* Return 1 if OP is a store multiple operation.  It is known to be\n    parallel and the first section will be tested.  */\n+\n int\n store_multiple_operation (op, mode)\n      rtx op;\n@@ -3802,8 +3846,8 @@ load_multiple_sequence (operands, nops, regs, base, load_offset)\n   int base_reg = -1;\n   int i;\n \n-  /* Can only handle 2, 3, or 4 insns at present, though could be easily\n-     extended if required.  */\n+  /* Can only handle 2, 3, or 4 insns at present,\n+     though could be easily extended if required.  */\n   if (nops < 2 || nops > 4)\n     abort ();\n \n@@ -4221,6 +4265,7 @@ multi_register_push (op, mode)\n }\n \f\n /* Routines for use in generating RTL.  */\n+\n rtx\n arm_gen_load_multiple (base_regno, count, from, up, write_back, unchanging_p,\n \t\t       in_struct_p, scalar_p)\n@@ -4565,6 +4610,7 @@ arm_gen_movstrqi (operands)\n /* Generate a memory reference for a half word, such that it will be loaded\n    into the top 16 bits of the word.  We can assume that the address is\n    known to be alignable and of the form reg, or plus (reg, const).  */\n+\n rtx\n arm_gen_rotated_half_load (memref)\n      rtx memref;\n@@ -4952,6 +4998,7 @@ arm_reload_in_hi (operands)\n    scratch in operands[2] overlaps either the input value or output address\n    in some way, then that value must die in this insn (we absolutely need\n    two scratch registers for some corner cases).  */\n+\n void\n arm_reload_out_hi (operands)\n      rtx * operands;\n@@ -4967,7 +5014,6 @@ arm_reload_out_hi (operands)\n       ref = SUBREG_REG (ref);\n     }\n \n-\n   if (GET_CODE (ref) == REG)\n     {\n       /* We have a pseudo which has been spilt onto the stack; there\n@@ -5113,6 +5159,7 @@ arm_reload_out_hi (operands)\n }\n \f\n /* Print a symbolic form of X to the debug file, F.  */\n+\n static void\n arm_print_value (f, x)\n      FILE * f;\n@@ -5281,6 +5328,7 @@ Mfix *\t\tminipool_barrier;\n \n /* Determines if INSN is the start of a jump table.  Returns the end\n    of the TABLE or NULL_RTX.  */\n+\n static rtx\n is_jump_table (insn)\n      rtx insn;\n@@ -5313,6 +5361,7 @@ get_jump_table_size (insn)\n /* Move a minipool fix MP from its current location to before MAX_MP.\n    If MAX_MP is NULL, then MP doesn't need moving, but the addressing\n    contrains may need updating.  */\n+\n static Mnode *\n move_minipool_fix_forward_ref (mp, max_mp, max_address)\n      Mnode *       mp;\n@@ -5372,6 +5421,7 @@ move_minipool_fix_forward_ref (mp, max_mp, max_address)\n \n /* Add a constant to the minipool for a forward reference.  Returns the\n    node added or NULL if the constant will not fit in this pool.  */\n+\n static Mnode *\n add_minipool_forward_ref (fix)\n      Mfix * fix;\n@@ -5540,6 +5590,7 @@ move_minipool_fix_backward_ref (mp, min_mp, min_address)\n    somewhat confusing because the calculated offsets for each fix do\n    not take into account the size of the pool (which is still under\n    construction.  */\n+\n static Mnode *\n add_minipool_backward_ref (fix)\n      Mfix * fix;\n@@ -5756,6 +5807,7 @@ dump_minipool (scan)\n }\n \n /* Return the cost of forcibly inserting a barrier after INSN.  */\n+\n static int\n arm_barrier_cost (insn)\n      rtx insn;\n@@ -5792,6 +5844,7 @@ arm_barrier_cost (insn)\n    (FIX->address,MAX_ADDRESS) to forcibly insert a minipool barrier.\n    Create the barrier by inserting a jump and add a new fix entry for\n    it.  */\n+\n static Mfix *\n create_fix_barrier (fix, max_address)\n      Mfix * fix;\n@@ -5957,6 +6010,7 @@ push_minipool_fix (insn, address, loc, mode, value)\n }\n \n /* Scan INSN and note any of its operands that need fixing.  */\n+\n static void\n note_invalid_constants (insn, address)\n      rtx insn;\n@@ -6170,6 +6224,7 @@ arm_reorg (first)\n /* If the rtx is the correct value then return the string of the number.\n    In this way we can ensure that valid double constants are generated even\n    when cross compiling.  */\n+\n const char *\n fp_immediate_constant (x)\n      rtx x;\n@@ -6189,6 +6244,7 @@ fp_immediate_constant (x)\n }\n \n /* As for fp_immediate_constant, but value is passed directly, not in rtx.  */\n+\n static const char *\n fp_const_from_val (r)\n      REAL_VALUE_TYPE * r;\n@@ -6268,8 +6324,8 @@ eliminate_lr2ip (x)\n   int something_changed = 0;\n   rtx x0 = * x;\n   int code = GET_CODE (x0);\n-  register int i, j;\n-  register const char * fmt;\n+  int i, j;\n+  const char * fmt;\n   \n   switch (code)\n     {\n@@ -6372,6 +6428,7 @@ output_mov_long_double_arm_from_fpu (operands)\n /* Output a move from arm registers to arm registers of a long double\n    OPERANDS[0] is the destination.\n    OPERANDS[1] is the source.  */\n+\n const char *\n output_mov_long_double_arm_from_arm (operands)\n      rtx * operands;\n@@ -6493,13 +6550,11 @@ output_move_double (operands)\n \t    abort ();\n \t  else if (WORDS_BIG_ENDIAN)\n \t    {\n-\t      \n \t      otherops[1] = GEN_INT (CONST_DOUBLE_LOW (operands[1]));\n \t      operands[1] = GEN_INT (CONST_DOUBLE_HIGH (operands[1]));\n \t    }\n \t  else\n \t    {\n-\t      \n \t      otherops[1] = GEN_INT (CONST_DOUBLE_HIGH (operands[1]));\n \t      operands[1] = GEN_INT (CONST_DOUBLE_LOW (operands[1]));\n \t    }\n@@ -6573,6 +6628,7 @@ output_move_double (operands)\n \t\t  otherops[0] = operands[0];\n \t\t  otherops[1] = XEXP (XEXP (operands[1], 0), 0);\n \t\t  otherops[2] = XEXP (XEXP (operands[1], 0), 1);\n+\n \t\t  if (GET_CODE (XEXP (operands[1], 0)) == PLUS)\n \t\t    {\n \t\t      if (GET_CODE (otherops[2]) == CONST_INT)\n@@ -6589,6 +6645,7 @@ output_move_double (operands)\n \t\t\t      output_asm_insn (\"ldm%?ib\\t%1, %M0\", otherops);\n \t\t\t      return \"\";\n \t\t\t    }\n+\n \t\t\t  if (!(const_ok_for_arm (INTVAL (otherops[2]))))\n \t\t\t    output_asm_insn (\"sub%?\\t%0, %1, #%n2\", otherops);\n \t\t\t  else\n@@ -6677,7 +6734,8 @@ output_move_double (operands)\n \t}\n     }\n   else\n-    abort ();  /* Constraints should prevent this */\n+    /* Constraints should prevent this.  */\n+    abort ();\n \n   return \"\";\n }\n@@ -6691,41 +6749,38 @@ output_mov_immediate (operands)\n      rtx * operands;\n {\n   HOST_WIDE_INT n = INTVAL (operands[1]);\n-  int n_ones = 0;\n-  int i;\n \n-  /* Try to use one MOV */\n+  /* Try to use one MOV.  */\n   if (const_ok_for_arm (n))\n-    {\n-      output_asm_insn (\"mov%?\\t%0, %1\", operands);\n-      return \"\";\n-    }\n+    output_asm_insn (\"mov%?\\t%0, %1\", operands);\n \n-  /* Try to use one MVN */\n-  if (const_ok_for_arm (~n))\n+  /* Try to use one MVN.  */\n+  else if (const_ok_for_arm (~n))\n     {\n       operands[1] = GEN_INT (~n);\n       output_asm_insn (\"mvn%?\\t%0, %1\", operands);\n-      return \"\";\n     }\n+  else\n+    {\n+      int n_ones = 0;\n+      int i;\n \n-  /* If all else fails, make it out of ORRs or BICs as appropriate.  */\n-\n-  for (i=0; i < 32; i++)\n-    if (n & 1 << i)\n-      n_ones++;\n+      /* If all else fails, make it out of ORRs or BICs as appropriate.  */\n+      for (i = 0; i < 32; i ++)\n+\tif (n & 1 << i)\n+\t  n_ones ++;\n \n-  if (n_ones > 16)  /* Shorter to use MVN with BIC in this case.  */\n-    output_multi_immediate (operands, \"mvn%?\\t%0, %1\", \"bic%?\\t%0, %0, %1\", 1, ~n);\n-  else\n-    output_multi_immediate (operands, \"mov%?\\t%0, %1\", \"orr%?\\t%0, %0, %1\", 1, n);\n+      if (n_ones > 16)  /* Shorter to use MVN with BIC in this case.  */\n+\toutput_multi_immediate (operands, \"mvn%?\\t%0, %1\", \"bic%?\\t%0, %0, %1\", 1, ~ n);\n+      else\n+\toutput_multi_immediate (operands, \"mov%?\\t%0, %1\", \"orr%?\\t%0, %0, %1\", 1, n);\n+    }\n \n   return \"\";\n }\n \n-\n-/* Output an ADD r, s, #n where n may be too big for one instruction.  If\n-   adding zero to one register, output nothing.  */\n+/* Output an ADD r, s, #n where n may be too big for one instruction.\n+   If adding zero to one register, output nothing.  */\n \n const char *\n output_add_immediate (operands)\n@@ -6769,8 +6824,9 @@ output_multi_immediate (operands, instr1, instr2, immed_op, n)\n \n   if (n == 0)\n     {\n+      /* Quick and easy output.  */\n       operands[immed_op] = const0_rtx;\n-      output_asm_insn (instr1, operands); /* Quick and easy output.  */\n+      output_asm_insn (instr1, operands);\n     }\n   else\n     {\n@@ -6793,7 +6849,6 @@ output_multi_immediate (operands, instr1, instr2, immed_op, n)\n   return \"\";\n }\n \n-\n /* Return the appropriate ARM instruction for the operation code.\n    The returned result should not be overwritten.  OP is the rtx of the\n    operation.  SHIFT_FIRST_ARG is TRUE if the first argument of the operator\n@@ -6826,7 +6881,6 @@ arithmetic_instr (op, shift_first_arg)\n     }\n }\n \n-\n /* Ensure valid constant shifts and return the appropriate shift mnemonic\n    for the operation code.  The returned result should not be overwritten.\n    OP is the rtx code of the shift.\n@@ -6889,7 +6943,8 @@ shift_op (op, amountp)\n \t is not set correctly if we set the flags; but we never use the \n \t carry bit from such an operation, so we can ignore that.  */\n       if (code == ROTATERT)\n-\t*amountp &= 31;\t\t/* Rotate is just modulo 32 */\n+\t/* Rotate is just modulo 32.  */\n+\t*amountp &= 31;\n       else if (*amountp != (*amountp & 31))\n \t{\n \t  if (code == ASHIFT)\n@@ -6905,8 +6960,8 @@ shift_op (op, amountp)\n   return mnem;\n }\n \n-\n /* Obtain the shift from the POWER of two.  */\n+\n static HOST_WIDE_INT\n int_log2 (power)\n      HOST_WIDE_INT power;\n@@ -6917,7 +6972,7 @@ int_log2 (power)\n     {\n       if (shift > 31)\n \tabort ();\n-      shift++;\n+      shift ++;\n     }\n \n   return shift;\n@@ -6940,7 +6995,7 @@ output_ascii_pseudo_op (stream, p, len)\n   \n   for (i = 0; i < len; i++)\n     {\n-      register int c = p[i];\n+      int c = p[i];\n \n       if (len_so_far >= MAX_ASCII_LEN)\n \t{\n@@ -7967,14 +8022,13 @@ arm_compute_initial_elimination_offset (from, to)\n       unsigned int reg_mask;\n       unsigned int reg;\n \n-      /* Makre sure that we compute which registers will be saved\n+      /* Make sure that we compute which registers will be saved\n \t on the stack using the same algorithm that is used by\n \t arm_compute_save_reg_mask().  */\n       reg_mask = arm_compute_save_reg0_reg12_mask ();\n \n       /* Now count the number of bits set in save_reg_mask.\n \t For each set bit we need 4 bytes of stack space.  */\n-\n       while (reg_mask)\n \t{\n \t  call_saved_registers += 4;\n@@ -8282,18 +8336,15 @@ arm_expand_prologue ()\n \t  /* Recover the static chain register.  */\n \t  if (regs_ever_live [3] == 0\n \t      || saved_pretend_args)\n-\t    {\n-\t      insn = gen_rtx_REG (SImode, 3);\n-\t      insn = gen_rtx_SET (SImode, ip_rtx, insn);\n-\t      (void) emit_insn (insn);\n-\t    }\n+\t    insn = gen_rtx_REG (SImode, 3);\n \t  else /* if (current_function_pretend_args_size == 0) */\n \t    {\n \t      insn = gen_rtx_PLUS (SImode, hard_frame_pointer_rtx, GEN_INT (4));\n \t      insn = gen_rtx_MEM (SImode, insn);\n-\t      insn = gen_rtx_SET (SImode, ip_rtx, insn);\n-\t      (void) emit_insn (insn);\n \t    }\n+\n+\t  insn = gen_rtx_SET (SImode, ip_rtx, insn);\n+\t  (void) emit_insn (insn);\n \t}\n     }\n \n@@ -8581,6 +8632,7 @@ arm_assemble_integer (x, size, aligned_p)\n       fputc ('\\n', asm_out_file);\n       return true;\n     }\n+\n   return default_assemble_integer (x, size, aligned_p);\n }\n #endif\n@@ -8625,8 +8677,8 @@ get_arm_condition_code (comparison)\n      rtx comparison;\n {\n   enum machine_mode mode = GET_MODE (XEXP (comparison, 0));\n-  register int code;\n-  register enum rtx_code comp_code = GET_CODE (comparison);\n+  int code;\n+  enum rtx_code comp_code = GET_CODE (comparison);\n \n   if (GET_MODE_CLASS (mode) != MODE_CC)\n     mode = SELECT_CC_MODE (comp_code, XEXP (comparison, 0),\n@@ -8748,7 +8800,7 @@ arm_final_prescan_insn (insn)\n      rtx insn;\n {\n   /* BODY will hold the body of INSN.  */\n-  register rtx body = PATTERN (insn);\n+  rtx body = PATTERN (insn);\n \n   /* This will be 1 if trying to repeat the trick, and things need to be\n      reversed if it appears to fail.  */\n@@ -9108,6 +9160,7 @@ arm_regno_class (regno)\n \n /* Handle a special case when computing the offset\n    of an argument from the frame pointer.  */\n+\n int\n arm_debugger_arg_offset (value, addr)\n      int value;\n@@ -9303,8 +9356,9 @@ replace_symbols_in_block (block, orig, new)\n     }\n }\n \n-/* Return the number (counting from 0) of the least significant set\n-   bit in MASK.  */\n+/* Return the number (counting from 0) of\n+   the least significant set bit in MASK.  */\n+\n #ifdef __GNUC__\n inline\n #endif\n@@ -9616,6 +9670,7 @@ thumb_exit (f, reg_containing_return_addr, eh_ofs)\n }\n \n /* Emit code to push or pop registers to or from the stack.  */\n+\n static void\n thumb_pushpop (f, mask, push)\n      FILE * f;\n@@ -9708,6 +9763,7 @@ thumb_shiftable_const (val)\n \n /* Returns non-zero if the current function contains,\n    or might contain a far jump.  */\n+\n int\n thumb_far_jump_used_p (int in_prologue)\n {\n@@ -9775,6 +9831,7 @@ thumb_far_jump_used_p (int in_prologue)\n }\n \n /* Return non-zero if FUNC must be entered in ARM mode.  */\n+\n int\n is_called_in_ARM_mode (func)\n      tree func;\n@@ -10005,6 +10062,7 @@ arm_free_machine_status (p)\n \n /* Return an RTX indicating where the return address to the\n    calling function can be found.  */\n+\n rtx\n arm_return_addr (count, frame)\n      int count;\n@@ -10024,6 +10082,7 @@ arm_return_addr (count, frame)\n }\n \n /* Do anything needed before RTL is emitted for each function.  */\n+\n void\n arm_init_expanders ()\n {\n@@ -10034,6 +10093,7 @@ arm_init_expanders ()\n }\n \n /* Generate the rest of a function's prologue.  */\n+\n void\n thumb_expand_prologue ()\n {\n@@ -10062,7 +10122,7 @@ thumb_expand_prologue ()\n       \n       if (amount < 512)\n \temit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t       GEN_INT (-amount)));\n+\t\t\t       GEN_INT (- amount)));\n       else\n \t{\n \t  int regno;\n@@ -10093,15 +10153,19 @@ thumb_expand_prologue ()\n \t  if (regno > LAST_LO_REGNUM) /* Very unlikely */\n \t    {\n \t      rtx spare = gen_rtx (REG, SImode, IP_REGNUM);\n+\t      rtx insn;\n \n \t      /* Choose an arbitary, non-argument low register.  */\n \t      reg = gen_rtx (REG, SImode, LAST_LO_REGNUM);\n \n \t      /* Save it by copying it into a high, scratch register.  */\n-\t      emit_insn (gen_movsi (spare, reg));\n+\t      insn = emit_insn (gen_movsi (spare, reg));\n+\t      /* Add a reg note to stop propogate_one_insn() from barfing.  */\n+\t      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, spare,\n+\t\t\t\t\t\t    REG_NOTES (insn));\n \n \t      /* Decrement the stack.  */\n-\t      emit_insn (gen_movsi (reg, GEN_INT (-amount)));\n+\t      emit_insn (gen_movsi (reg, GEN_INT (- amount)));\n \t      emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n \t\t\t\t     reg));\n \n@@ -10118,7 +10182,7 @@ thumb_expand_prologue ()\n \t    {\n \t      reg = gen_rtx (REG, SImode, regno);\n \n-\t      emit_insn (gen_movsi (reg, GEN_INT (-amount)));\n+\t      emit_insn (gen_movsi (reg, GEN_INT (- amount)));\n \t      emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n \t\t\t\t     reg));\n \t    }\n@@ -10586,7 +10650,7 @@ thumb_output_move_mem_multiple (n, operands)\n   return \"\";\n }\n \n-/* Routines for generating rtl */\n+/* Routines for generating rtl.  */\n \n void\n thumb_expand_movstrqi (operands)\n@@ -10654,7 +10718,7 @@ thumb_condition_code (x, invert)\n      rtx x;\n      int invert;\n {\n-  static const char *const conds[] =\n+  static const char * const conds[] =\n   {\n     \"eq\", \"ne\", \"cs\", \"cc\", \"mi\", \"pl\", \"vs\", \"vc\", \n     \"hi\", \"ls\", \"ge\", \"lt\", \"gt\", \"le\"\n@@ -10681,6 +10745,7 @@ thumb_condition_code (x, invert)\n }\n \n /* Handle storing a half-word to memory during reload.  */ \n+\n void\n thumb_reload_out_hi (operands)\n      rtx * operands;\n@@ -10689,6 +10754,7 @@ thumb_reload_out_hi (operands)\n }\n \n /* Handle storing a half-word to memory during reload.  */ \n+\n void\n thumb_reload_in_hi (operands)\n      rtx * operands ATTRIBUTE_UNUSED;\n@@ -10698,6 +10764,7 @@ thumb_reload_in_hi (operands)\n \n /* Return the length of a function name prefix\n     that starts with the character 'c'.  */\n+\n static int\n arm_get_strip_length (char c)\n {\n@@ -10710,6 +10777,7 @@ arm_get_strip_length (char c)\n \n /* Return a pointer to a function's name with any\n    and all prefix encodings stripped from it.  */\n+\n const char *\n arm_strip_name_encoding (const char * name)\n {"}]}