{"sha": "a29174904bb1b005e16bd9d498b2aa380b6999f8", "node_id": "C_kwDOANBUbNoAKGEyOTE3NDkwNGJiMWIwMDVlMTZiZDlkNDk4YjJhYTM4MGI2OTk5Zjg", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2021-11-14T11:01:41Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2021-11-14T11:01:41Z"}, "message": "Cleanup tree-ssa-alias and tree-ssa-dse use of modref summary\n\nMove code getting tree op from access_node and stmt to a common place.  I also\ncommonized logic to build ao_ref. While I was on it I also replaced FOR_EACH_*\nby range for since they reads better.\n\ngcc/ChangeLog:\n\n2021-11-14  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* ipa-modref-tree.c (modref_access_node::get_call_arg): New member\n\tfunction.\n\t(modref_access_node::get_ao_ref): Likewise.\n\t* ipa-modref-tree.h (modref_access_node::get_call_arg): Declare.\n\t(modref_access_node::get_ao_ref): Declare.\n\t* tree-ssa-alias.c (modref_may_conflict): Use new accessors.\n\t* tree-ssa-dse.c (dse_optimize_call): Use new accessors.\n\ngcc/testsuite/ChangeLog:\n\n2021-11-14  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* c-c++-common/asan/null-deref-1.c: Update template.\n\t* c-c++-common/tsan/free_race.c: Update template.\n\t* c-c++-common/tsan/free_race2.c: Update template.\n\t* gcc.dg/ipa/ipa-sra-4.c: Update template.", "tree": {"sha": "48361c572baa32880b4f5905f5da52495b53a90e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/48361c572baa32880b4f5905f5da52495b53a90e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a29174904bb1b005e16bd9d498b2aa380b6999f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a29174904bb1b005e16bd9d498b2aa380b6999f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a29174904bb1b005e16bd9d498b2aa380b6999f8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a29174904bb1b005e16bd9d498b2aa380b6999f8/comments", "author": null, "committer": null, "parents": [{"sha": "a8029add3065e4abb5dbaa92ce3f1b307f3e16ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8029add3065e4abb5dbaa92ce3f1b307f3e16ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8029add3065e4abb5dbaa92ce3f1b307f3e16ef"}], "stats": {"total": 150, "additions": 77, "deletions": 73}, "files": [{"sha": "6fc2b7298f473408931dd839edb10974cc49704a", "filename": "gcc/ipa-modref-tree.c", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a29174904bb1b005e16bd9d498b2aa380b6999f8/gcc%2Fipa-modref-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a29174904bb1b005e16bd9d498b2aa380b6999f8/gcc%2Fipa-modref-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref-tree.c?ref=a29174904bb1b005e16bd9d498b2aa380b6999f8", "patch": "@@ -25,6 +25,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree.h\"\n #include \"ipa-modref-tree.h\"\n #include \"selftest.h\"\n+#include \"tree-ssa-alias.h\"\n+#include \"gimple.h\"\n \n /* Return true if both accesses are the same.  */\n bool\n@@ -603,6 +605,39 @@ modref_access_node::dump (FILE *out)\n   fprintf (out, \"\\n\");\n }\n \n+/* Return tree corresponding to parameter of the range in STMT.  */\n+tree\n+modref_access_node::get_call_arg (const gcall *stmt) const\n+{\n+  if (parm_index == MODREF_UNKNOWN_PARM)\n+    return NULL;\n+  if (parm_index == MODREF_STATIC_CHAIN_PARM)\n+    return gimple_call_chain (stmt);\n+  /* MODREF_RETSLOT_PARM should not happen in access trees since the store\n+     is seen explicitly in the caller.  */\n+  gcc_checking_assert (parm_index >= 0);\n+  if (parm_index >= (int)gimple_call_num_args (stmt))\n+    return NULL;\n+  return gimple_call_arg (stmt, parm_index);\n+}\n+\n+/* Return tree corresponding to parameter of the range in STMT.  */\n+bool\n+modref_access_node::get_ao_ref (const gcall *stmt, ao_ref *ref) const\n+{\n+  tree arg;\n+\n+  if (!parm_offset_known || !(arg = get_call_arg (stmt)))\n+    return false;\n+  poly_offset_int off = (poly_offset_int)offset\n+\t+ ((poly_offset_int)parm_offset << LOG2_BITS_PER_UNIT);\n+  poly_int64 off2;\n+  if (!off.to_shwi (&off2))\n+    return false;\n+  ao_ref_init_from_ptr_and_range (ref, arg, true, off2, size, max_size);\n+  return true;\n+}\n+\n #if CHECKING_P\n \n namespace selftest {"}, {"sha": "2fcabe480bdbf15e0c9d349a65839c5b406a53cf", "filename": "gcc/ipa-modref-tree.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a29174904bb1b005e16bd9d498b2aa380b6999f8/gcc%2Fipa-modref-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a29174904bb1b005e16bd9d498b2aa380b6999f8/gcc%2Fipa-modref-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref-tree.h?ref=a29174904bb1b005e16bd9d498b2aa380b6999f8", "patch": "@@ -77,7 +77,7 @@ struct GTY(()) modref_access_node\n      This has to be limited in order to keep dataflow finite.  */\n   unsigned char adjustments;\n \n-  /* Return true if access node holds no useful info.  */\n+  /* Return true if access node holds some useful info.  */\n   bool useful_p () const\n     {\n       return parm_index != MODREF_UNKNOWN_PARM;\n@@ -88,10 +88,13 @@ struct GTY(()) modref_access_node\n   bool operator == (modref_access_node &a) const;\n   /* Return true if range info is useful.  */\n   bool range_info_useful_p () const;\n+  /* Return tree corresponding to parameter of the range in STMT.  */\n+  tree get_call_arg (const gcall *stmt) const;\n+  /* Build ao_ref corresponding to the access and return true if succesful.  */\n+  bool get_ao_ref (const gcall *stmt, class ao_ref *ref) const;\n   /* Insert A into vector ACCESSES.  Limit size of vector to MAX_ACCESSES and\n      if RECORD_ADJUSTMENT is true keep track of adjustment counts.\n-     Return 0 if nothing changed, 1 is insertion suceeded and -1 if\n-     failed.  */\n+     Return 0 if nothing changed, 1 is insertion suceeded and -1 if failed.  */\n   static int insert (vec <modref_access_node, va_gc> *&accesses,\n \t\t     modref_access_node a, size_t max_accesses,\n \t\t     bool record_adjustments);"}, {"sha": "c967b29b9e238fb3693b68a4e2ce96c092d3fd87", "filename": "gcc/testsuite/c-c++-common/asan/null-deref-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a29174904bb1b005e16bd9d498b2aa380b6999f8/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fnull-deref-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a29174904bb1b005e16bd9d498b2aa380b6999f8/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fnull-deref-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fnull-deref-1.c?ref=a29174904bb1b005e16bd9d498b2aa380b6999f8", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do run } */\n-/* { dg-options \"-fno-omit-frame-pointer -fno-shrink-wrap\" } */\n+/* { dg-options \"-fno-omit-frame-pointer -fno-shrink-wrap -fno-ipa-modref\" } */\n /* { dg-additional-options \"-mno-omit-leaf-frame-pointer\" { target { i?86-*-* x86_64-*-* } } } */\n /* { dg-shouldfail \"asan\" } */\n "}, {"sha": "831c23e885960d9bff81ed6b900740ebc713afc9", "filename": "gcc/testsuite/c-c++-common/tsan/free_race.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a29174904bb1b005e16bd9d498b2aa380b6999f8/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftsan%2Ffree_race.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a29174904bb1b005e16bd9d498b2aa380b6999f8/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftsan%2Ffree_race.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftsan%2Ffree_race.c?ref=a29174904bb1b005e16bd9d498b2aa380b6999f8", "patch": "@@ -1,4 +1,5 @@\n /* { dg-shouldfail \"tsan\" } */\n+/* { dg-additional-options \"-ldl -fno-ipa-modref\" } */\n \n #include <stdlib.h>\n "}, {"sha": "a74d9dc3940e49c317c661721ddaa85eb5a9ffd0", "filename": "gcc/testsuite/c-c++-common/tsan/free_race2.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a29174904bb1b005e16bd9d498b2aa380b6999f8/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftsan%2Ffree_race2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a29174904bb1b005e16bd9d498b2aa380b6999f8/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftsan%2Ffree_race2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftsan%2Ffree_race2.c?ref=a29174904bb1b005e16bd9d498b2aa380b6999f8", "patch": "@@ -1,4 +1,5 @@\n /* { dg-shouldfail \"tsan\" } */\n+/* { dg-additional-options \"-ldl -fno-ipa-modref\" } */\n \n #include <stdlib.h>\n "}, {"sha": "c86ae8320a78852330db95d55a241c7c4f56d9de", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-sra-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a29174904bb1b005e16bd9d498b2aa380b6999f8/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a29174904bb1b005e16bd9d498b2aa380b6999f8/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-4.c?ref=a29174904bb1b005e16bd9d498b2aa380b6999f8", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fipa-sra -fno-ipa-pure-const -fdump-ipa-sra\" } */\n+/* { dg-options \"-O2 -fipa-sra -fno-ipa-pure-const -fdump-ipa-sra -fno-ipa-modref\" } */\n \n static int\n __attribute__((noinline))"}, {"sha": "29be1f848b56d320838677db1aaa5409b6f46353", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 21, "deletions": 47, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a29174904bb1b005e16bd9d498b2aa380b6999f8/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a29174904bb1b005e16bd9d498b2aa380b6999f8/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=a29174904bb1b005e16bd9d498b2aa380b6999f8", "patch": "@@ -2535,13 +2535,10 @@ refs_output_dependent_p (tree store1, tree store2)\n    IF TBAA_P is true, use TBAA oracle.  */\n \n static bool\n-modref_may_conflict (const gimple *stmt,\n+modref_may_conflict (const gcall *stmt,\n \t\t     modref_tree <alias_set_type> *tt, ao_ref *ref, bool tbaa_p)\n {\n   alias_set_type base_set, ref_set;\n-  modref_base_node <alias_set_type> *base_node;\n-  modref_ref_node <alias_set_type> *ref_node;\n-  size_t i, j, k;\n \n   if (tt->every_base)\n     return true;\n@@ -2554,7 +2551,7 @@ modref_may_conflict (const gimple *stmt,\n   ref_set = ao_ref_alias_set (ref);\n \n   int num_tests = 0, max_tests = param_modref_max_tests;\n-  FOR_EACH_VEC_SAFE_ELT (tt->bases, i, base_node)\n+  for (auto base_node : tt->bases)\n     {\n       if (tbaa_p && flag_strict_aliasing)\n \t{\n@@ -2569,7 +2566,7 @@ modref_may_conflict (const gimple *stmt,\n       if (base_node->every_ref)\n \treturn true;\n \n-      FOR_EACH_VEC_SAFE_ELT (base_node->refs, j, ref_node)\n+      for (auto ref_node : base_node->refs)\n \t{\n \t  /* Do not repeat same test as before.  */\n \t  if ((ref_set != base_set || base_node->base != ref_node->ref)\n@@ -2583,66 +2580,43 @@ modref_may_conflict (const gimple *stmt,\n \t      num_tests++;\n \t    }\n \n-\t  /* TBAA checks did not disambiguate,  try to use base pointer, for\n-\t     that we however need to have ref->ref or ref->base.  */\n-\t  if (ref_node->every_access || (!ref->ref && !ref->base))\n+\t  if (ref_node->every_access)\n \t    return true;\n \n-\t  modref_access_node *access_node;\n-\t  FOR_EACH_VEC_SAFE_ELT (ref_node->accesses, k, access_node)\n+\t  /* TBAA checks did not disambiguate, try individual accesses.  */\n+\t  for (auto access_node : ref_node->accesses)\n \t    {\n \t      if (num_tests >= max_tests)\n \t\treturn true;\n \n-\t      if (access_node->parm_index == MODREF_UNKNOWN_PARM\n-\t\t  || access_node->parm_index\n-\t\t     >= (int)gimple_call_num_args (stmt))\n+\t      tree arg = access_node.get_call_arg (stmt);\n+\t      if (!arg)\n \t\treturn true;\n \n \t      alias_stats.modref_baseptr_tests++;\n-\t      tree arg;\n-\n-\t      if (access_node->parm_index == MODREF_STATIC_CHAIN_PARM)\n-\t\targ = gimple_call_chain (stmt);\n-\t      else\n-\t\targ = gimple_call_arg (stmt, access_node->parm_index);\n \n \t      if (integer_zerop (arg) && flag_delete_null_pointer_checks)\n \t\tcontinue;\n \n+\t      /* PTA oracle will be unhapy of arg is not an pointer.  */\n \t      if (!POINTER_TYPE_P (TREE_TYPE (arg)))\n \t\treturn true;\n \n-\t      /* ao_ref_init_from_ptr_and_range assumes that memory access\n-\t\t starts by the pointed to location.  If we did not track the\n-\t\t offset it is possible that it starts before the actual\n-\t\t pointer.  */\n-\t      if (!access_node->parm_offset_known)\n-\t\t{\n-\t\t  if (ptr_deref_may_alias_ref_p_1 (arg, ref))\n-\t\t    return true;\n-\t\t}\n-\t      else\n+\t      /* If we don't have base pointer, give up.  */\n+\t      if (!ref->ref && !ref->base)\n+\t\tcontinue;\n+\n+\t      ao_ref ref2;\n+\t      if (access_node.get_ao_ref (stmt, &ref2))\n \t\t{\n-\t\t  ao_ref ref2;\n-\t\t  poly_offset_int off = (poly_offset_int)access_node->offset\n-\t\t\t+ ((poly_offset_int)access_node->parm_offset\n-\t\t\t   << LOG2_BITS_PER_UNIT);\n-\t\t  poly_int64 off2;\n-\t\t  if (off.to_shwi (&off2))\n-\t\t    {\n-\t\t      ao_ref_init_from_ptr_and_range\n-\t\t\t     (&ref2, arg, true, off2,\n-\t\t\t      access_node->size,\n-\t\t\t      access_node->max_size);\n-\t\t      ref2.ref_alias_set = ref_set;\n-\t\t      ref2.base_alias_set = base_set;\n-\t\t      if (refs_may_alias_p_1 (&ref2, ref, tbaa_p))\n-\t\t\treturn true;\n-\t\t    }\n-\t\t  else if (ptr_deref_may_alias_ref_p_1 (arg, ref))\n+\t\t  ref2.ref_alias_set = ref_node->ref;\n+\t\t  ref2.base_alias_set = base_node->base;\n+\t\t  if (refs_may_alias_p_1 (&ref2, ref, tbaa_p))\n \t\t    return true;\n \t\t}\n+\t      else if (ptr_deref_may_alias_ref_p_1 (arg, ref))\n+\t\treturn true;\n+\n \t      num_tests++;\n \t    }\n \t}"}, {"sha": "ce0083a6dab8b765a60df17ff35b2a96998a2440", "filename": "gcc/tree-ssa-dse.c", "status": "modified", "additions": 11, "deletions": 21, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a29174904bb1b005e16bd9d498b2aa380b6999f8/gcc%2Ftree-ssa-dse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a29174904bb1b005e16bd9d498b2aa380b6999f8/gcc%2Ftree-ssa-dse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dse.c?ref=a29174904bb1b005e16bd9d498b2aa380b6999f8", "patch": "@@ -1079,35 +1079,25 @@ dse_optimize_call (gimple_stmt_iterator *gsi, sbitmap live_bytes)\n   if (!summary || !summary->try_dse)\n     return false;\n \n-  modref_base_node <alias_set_type> *base_node;\n-  modref_ref_node <alias_set_type> *ref_node;\n-  modref_access_node *access_node;\n-  size_t i, j, k;\n   bool by_clobber_p = false;\n \n   /* Walk all memory writes and verify that they are dead.  */\n-  FOR_EACH_VEC_SAFE_ELT (summary->stores->bases, i, base_node)\n-    FOR_EACH_VEC_SAFE_ELT (base_node->refs, j, ref_node)\n-      FOR_EACH_VEC_SAFE_ELT (ref_node->accesses, k, access_node)\n+  for (auto base_node : summary->stores->bases)\n+    for (auto ref_node : base_node->refs)\n+      for (auto access_node : ref_node->accesses)\n \t{\n-\t  gcc_checking_assert (access_node->parm_offset_known);\n+\t  tree arg = access_node.get_call_arg (stmt);\n \n-\t  tree arg;\n-\t  if (access_node->parm_index == MODREF_STATIC_CHAIN_PARM)\n-\t    arg = gimple_call_chain (stmt);\n-\t  else\n-\t    arg = gimple_call_arg (stmt, access_node->parm_index);\n+\t  if (!arg)\n+\t    return false;\n+\n+\t  if (integer_zerop (arg) && flag_delete_null_pointer_checks)\n+\t    continue;\n \n \t  ao_ref ref;\n-\t  poly_offset_int off = (poly_offset_int)access_node->offset\n-\t\t+ ((poly_offset_int)access_node->parm_offset\n-\t\t   << LOG2_BITS_PER_UNIT);\n-\t  poly_int64 off2;\n-\t  if (!off.to_shwi (&off2))\n+\n+\t  if (!access_node.get_ao_ref (stmt, &ref))\n \t    return false;\n-\t  ao_ref_init_from_ptr_and_range\n-\t\t (&ref, arg, true, off2, access_node->size,\n-\t\t  access_node->max_size);\n \t  ref.ref_alias_set = ref_node->ref;\n \t  ref.base_alias_set = base_node->base;\n "}]}