{"sha": "ebc2f4010dc789bf50fe46460594fd947df8084d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWJjMmY0MDEwZGM3ODliZjUwZmU0NjQ2MDU5NGZkOTQ3ZGY4MDg0ZA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2018-01-31T06:17:25Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-01-31T06:17:25Z"}, "message": "go-gcc.cc (Gcc_backend::convert_tree): New private method.\n\n\t* go-gcc.cc (Gcc_backend::convert_tree): New private method.\n\t(Gcc_backend::constructor_expression): Call it.\n\t(Gcc_backend::assignment_statement): Likewise.\n\t(Gcc_backend::temporary_variable): Likewise.\n\nFixes https://golang.org/issue/#23606\n\nFrom-SVN: r257218", "tree": {"sha": "7fc9b95e68b06c4ab1928cb2dfb46b6cce4b7803", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7fc9b95e68b06c4ab1928cb2dfb46b6cce4b7803"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ebc2f4010dc789bf50fe46460594fd947df8084d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebc2f4010dc789bf50fe46460594fd947df8084d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebc2f4010dc789bf50fe46460594fd947df8084d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebc2f4010dc789bf50fe46460594fd947df8084d/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5837571173e41e9c30eccb92f75b17e52bed2116", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5837571173e41e9c30eccb92f75b17e52bed2116", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5837571173e41e9c30eccb92f75b17e52bed2116"}], "stats": {"total": 77, "additions": 50, "deletions": 27}, "files": [{"sha": "b1876c57d5a2cd22ac5798791fd1782e0ab1ec04", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebc2f4010dc789bf50fe46460594fd947df8084d/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebc2f4010dc789bf50fe46460594fd947df8084d/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=ebc2f4010dc789bf50fe46460594fd947df8084d", "patch": "@@ -1,3 +1,10 @@\n+2018-01-30  Ian Lance Taylor  <iant@golang.org>\n+\n+\t* go-gcc.cc (Gcc_backend::convert_tree): New private method.\n+\t(Gcc_backend::constructor_expression): Call it.\n+\t(Gcc_backend::assignment_statement): Likewise.\n+\t(Gcc_backend::temporary_variable): Likewise.\n+\n 2018-01-09  Cherry Zhang  <cherryyz@google.com>\n \n \t* go-gcc.cc (local_variable): Add decl_var parameter."}, {"sha": "de1cadfda3184938107e9c618e84dc3be3562271", "filename": "gcc/go/go-gcc.cc", "status": "modified", "additions": 43, "deletions": 27, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebc2f4010dc789bf50fe46460594fd947df8084d/gcc%2Fgo%2Fgo-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebc2f4010dc789bf50fe46460594fd947df8084d/gcc%2Fgo%2Fgo-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc.cc?ref=ebc2f4010dc789bf50fe46460594fd947df8084d", "patch": "@@ -541,6 +541,9 @@ class Gcc_backend : public Backend\n   tree\n   non_zero_size_type(tree);\n \n+  tree\n+  convert_tree(tree, tree, Location);\n+\n private:\n   void\n   define_builtin(built_in_function bcode, const char* name, const char* libname,\n@@ -1785,8 +1788,7 @@ Gcc_backend::constructor_expression(Btype* btype,\n       constructor_elt empty = {NULL, NULL};\n       constructor_elt* elt = init->quick_push(empty);\n       elt->index = field;\n-      elt->value = fold_convert_loc(location.gcc_location(), TREE_TYPE(field),\n-                                    val);\n+      elt->value = this->convert_tree(TREE_TYPE(field), val, location);\n       if (!TREE_CONSTANT(elt->value))\n \tis_constant = false;\n     }\n@@ -2055,29 +2057,7 @@ Gcc_backend::assignment_statement(Bfunction* bfn, Bexpression* lhs,\n     return this->compound_statement(this->expression_statement(bfn, lhs),\n \t\t\t\t    this->expression_statement(bfn, rhs));\n \n-  // Sometimes the same unnamed Go type can be created multiple times\n-  // and thus have multiple tree representations.  Make sure this does\n-  // not confuse the middle-end.\n-  if (TREE_TYPE(lhs_tree) != TREE_TYPE(rhs_tree))\n-    {\n-      tree lhs_type_tree = TREE_TYPE(lhs_tree);\n-      gcc_assert(TREE_CODE(lhs_type_tree) == TREE_CODE(TREE_TYPE(rhs_tree)));\n-      if (POINTER_TYPE_P(lhs_type_tree)\n-\t  || INTEGRAL_TYPE_P(lhs_type_tree)\n-\t  || SCALAR_FLOAT_TYPE_P(lhs_type_tree)\n-\t  || COMPLEX_FLOAT_TYPE_P(lhs_type_tree))\n-\trhs_tree = fold_convert_loc(location.gcc_location(), lhs_type_tree,\n-\t\t\t\t    rhs_tree);\n-      else if (TREE_CODE(lhs_type_tree) == RECORD_TYPE\n-\t       || TREE_CODE(lhs_type_tree) == ARRAY_TYPE)\n-\t{\n-\t  gcc_assert(int_size_in_bytes(lhs_type_tree)\n-\t\t     == int_size_in_bytes(TREE_TYPE(rhs_tree)));\n-\t  rhs_tree = fold_build1_loc(location.gcc_location(),\n-\t\t\t\t     VIEW_CONVERT_EXPR,\n-\t\t\t\t     lhs_type_tree, rhs_tree);\n-\t}\n-    }\n+  rhs_tree = this->convert_tree(TREE_TYPE(lhs_tree), rhs_tree, location);\n \n   return this->make_statement(fold_build2_loc(location.gcc_location(),\n                                               MODIFY_EXPR,\n@@ -2507,6 +2487,43 @@ Gcc_backend::non_zero_size_type(tree type)\n   gcc_unreachable();\n }\n \n+// Convert EXPR_TREE to TYPE_TREE.  Sometimes the same unnamed Go type\n+// can be created multiple times and thus have multiple tree\n+// representations.  Make sure this does not confuse the middle-end.\n+\n+tree\n+Gcc_backend::convert_tree(tree type_tree, tree expr_tree, Location location)\n+{\n+  if (type_tree == TREE_TYPE(expr_tree))\n+    return expr_tree;\n+\n+  if (type_tree == error_mark_node\n+      || expr_tree == error_mark_node\n+      || TREE_TYPE(expr_tree) == error_mark_node)\n+    return error_mark_node;\n+\n+  gcc_assert(TREE_CODE(type_tree) == TREE_CODE(TREE_TYPE(expr_tree)));\n+  if (POINTER_TYPE_P(type_tree)\n+      || INTEGRAL_TYPE_P(type_tree)\n+      || SCALAR_FLOAT_TYPE_P(type_tree)\n+      || COMPLEX_FLOAT_TYPE_P(type_tree))\n+    return fold_convert_loc(location.gcc_location(), type_tree, expr_tree);\n+  else if (TREE_CODE(type_tree) == RECORD_TYPE\n+\t   || TREE_CODE(type_tree) == ARRAY_TYPE)\n+    {\n+      gcc_assert(int_size_in_bytes(type_tree)\n+\t\t == int_size_in_bytes(TREE_TYPE(expr_tree)));\n+      if (TYPE_MAIN_VARIANT(type_tree)\n+\t  == TYPE_MAIN_VARIANT(TREE_TYPE(expr_tree)))\n+\treturn fold_build1_loc(location.gcc_location(), NOP_EXPR,\n+\t\t\t       type_tree, expr_tree);\n+      return fold_build1_loc(location.gcc_location(), VIEW_CONVERT_EXPR,\n+\t\t\t     type_tree, expr_tree);\n+    }\n+\n+  gcc_unreachable();\n+}\n+\n // Make a global variable.\n \n Bvariable*\n@@ -2717,8 +2734,7 @@ Gcc_backend::temporary_variable(Bfunction* function, Bblock* bblock,\n     }\n \n   if (this->type_size(btype) != 0 && init_tree != NULL_TREE)\n-    DECL_INITIAL(var) = fold_convert_loc(location.gcc_location(), type_tree,\n-                                         init_tree);\n+    DECL_INITIAL(var) = this->convert_tree(type_tree, init_tree, location);\n \n   if (is_address_taken)\n     TREE_ADDRESSABLE(var) = 1;"}]}