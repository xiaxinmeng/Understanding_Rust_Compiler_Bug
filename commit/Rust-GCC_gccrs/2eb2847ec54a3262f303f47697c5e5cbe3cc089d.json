{"sha": "2eb2847ec54a3262f303f47697c5e5cbe3cc089d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmViMjg0N2VjNTRhMzI2MmYzMDNmNDc2OTdjNWU1Y2JlM2NjMDg5ZA==", "commit": {"author": {"name": "Wilco Dijkstra", "email": "wdijkstr@arm.com", "date": "2018-05-30T10:31:21Z"}, "committer": {"name": "Wilco Dijkstra", "email": "wilco@gcc.gnu.org", "date": "2018-05-30T10:31:21Z"}, "message": "[AArch64] Fix aarch64_ira_change_pseudo_allocno_class\n\nA recent commit removing '*' from the md files caused a large regression in\nh264ref.  It turns out aarch64_ira_change_pseudo_allocno_class is no longer\neffective after the SVE changes, and the combination results in the regression.\nThis patch fixes it by explicitly checking for a subset of GENERAL_REGS and\nFP_REGS.  Add a missing ? to aarch64_get_lane to fix a failure in the testsuite.\n\n    gcc/\n\t* config/aarch64/aarch64.c (aarch64_ira_change_pseudo_allocno_class):\n\tCheck for subset of GENERAL_REGS and FP_REGS.\n\t* config/aarch64/aarch64-simd.md (aarch64_get_lane): Increase cost of\n\tr=w alternative.\n\nFrom-SVN: r260951", "tree": {"sha": "c82f3633a43f74e9269c0bd423729416b7d5048e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c82f3633a43f74e9269c0bd423729416b7d5048e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2eb2847ec54a3262f303f47697c5e5cbe3cc089d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2eb2847ec54a3262f303f47697c5e5cbe3cc089d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2eb2847ec54a3262f303f47697c5e5cbe3cc089d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2eb2847ec54a3262f303f47697c5e5cbe3cc089d/comments", "author": null, "committer": null, "parents": [{"sha": "30522cdb1462ff8892d01429de3d73e1b5c7e919", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30522cdb1462ff8892d01429de3d73e1b5c7e919", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30522cdb1462ff8892d01429de3d73e1b5c7e919"}], "stats": {"total": 36, "additions": 23, "deletions": 13}, "files": [{"sha": "ef0a71e7145c56b641032558bb8e1f73f0027a6e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eb2847ec54a3262f303f47697c5e5cbe3cc089d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eb2847ec54a3262f303f47697c5e5cbe3cc089d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2eb2847ec54a3262f303f47697c5e5cbe3cc089d", "patch": "@@ -1,3 +1,10 @@\n+2018-05-30  Wilco Dijkstra  <wdijkstr@arm.com>\n+\n+\t* config/aarch64/aarch64.c (aarch64_ira_change_pseudo_allocno_class):\n+\tCheck for subset of GENERAL_REGS and FP_REGS.\n+\t* config/aarch64/aarch64-simd.md (aarch64_get_lane): Increase cost of\n+\tr=w alternative.\n+\n 2018-05-30  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* alias.c (adjust_offset_for_component_ref): Use poly_int_tree_p"}, {"sha": "962386981afb94ba4039fd19dc298e122101dbeb", "filename": "gcc/config/aarch64/aarch64-simd.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eb2847ec54a3262f303f47697c5e5cbe3cc089d/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eb2847ec54a3262f303f47697c5e5cbe3cc089d/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md?ref=2eb2847ec54a3262f303f47697c5e5cbe3cc089d", "patch": "@@ -3022,7 +3022,7 @@\n ;; is guaranteed so upper bits should be considered undefined.\n ;; RTL uses GCC vector extension indices throughout so flip only for assembly.\n (define_insn \"aarch64_get_lane<mode>\"\n-  [(set (match_operand:<VEL> 0 \"aarch64_simd_nonimmediate_operand\" \"=r, w, Utv\")\n+  [(set (match_operand:<VEL> 0 \"aarch64_simd_nonimmediate_operand\" \"=?r, w, Utv\")\n \t(vec_select:<VEL>\n \t  (match_operand:VALL_F16 1 \"register_operand\" \"w, w, w\")\n \t  (parallel [(match_operand:SI 2 \"immediate_operand\" \"i, i, i\")])))]"}, {"sha": "1fbde469ac173f67ac5adfc0d42d6694f2cb8a5c", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eb2847ec54a3262f303f47697c5e5cbe3cc089d/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eb2847ec54a3262f303f47697c5e5cbe3cc089d/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=2eb2847ec54a3262f303f47697c5e5cbe3cc089d", "patch": "@@ -1087,16 +1087,17 @@ aarch64_err_no_fpadvsimd (machine_mode mode, const char *msg)\n }\n \n /* Implement TARGET_IRA_CHANGE_PSEUDO_ALLOCNO_CLASS.\n-   The register allocator chooses ALL_REGS if FP_REGS and GENERAL_REGS have\n-   the same cost even if ALL_REGS has a much larger cost.  ALL_REGS is also\n-   used if the cost of both FP_REGS and GENERAL_REGS is lower than the memory\n-   cost (in this case the best class is the lowest cost one).  Using ALL_REGS\n-   irrespectively of its cost results in bad allocations with many redundant\n-   int<->FP moves which are expensive on various cores.\n-   To avoid this we don't allow ALL_REGS as the allocno class, but force a\n-   decision between FP_REGS and GENERAL_REGS.  We use the allocno class if it\n-   isn't ALL_REGS.  Similarly, use the best class if it isn't ALL_REGS.\n-   Otherwise set the allocno class depending on the mode.\n+   The register allocator chooses POINTER_AND_FP_REGS if FP_REGS and\n+   GENERAL_REGS have the same cost - even if POINTER_AND_FP_REGS has a much\n+   higher cost.  POINTER_AND_FP_REGS is also used if the cost of both FP_REGS\n+   and GENERAL_REGS is lower than the memory cost (in this case the best class\n+   is the lowest cost one).  Using POINTER_AND_FP_REGS irrespectively of its\n+   cost results in bad allocations with many redundant int<->FP moves which\n+   are expensive on various cores.\n+   To avoid this we don't allow POINTER_AND_FP_REGS as the allocno class, but\n+   force a decision between FP_REGS and GENERAL_REGS.  We use the allocno class\n+   if it isn't POINTER_AND_FP_REGS.  Similarly, use the best class if it isn't\n+   POINTER_AND_FP_REGS.  Otherwise set the allocno class depending on the mode.\n    The result of this is that it is no longer inefficient to have a higher\n    memory move cost than the register move cost.\n */\n@@ -1107,10 +1108,12 @@ aarch64_ira_change_pseudo_allocno_class (int regno, reg_class_t allocno_class,\n {\n   machine_mode mode;\n \n-  if (allocno_class != ALL_REGS)\n+  if (reg_class_subset_p (allocno_class, GENERAL_REGS)\n+      || reg_class_subset_p (allocno_class, FP_REGS))\n     return allocno_class;\n \n-  if (best_class != ALL_REGS)\n+  if (reg_class_subset_p (best_class, GENERAL_REGS)\n+      || reg_class_subset_p (best_class, FP_REGS))\n     return best_class;\n \n   mode = PSEUDO_REGNO_MODE (regno);"}]}