{"sha": "50dbf0b414c3a0afe3f1fbe2143511882d5277d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTBkYmYwYjQxNGMzYTBhZmUzZjFmYmUyMTQzNTExODgyZDUyNzdkOQ==", "commit": {"author": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2009-08-21T09:43:04Z"}, "committer": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2009-08-21T09:43:04Z"}, "message": "re PR fortran/41106 ([F03] Procedure Pointers with CHARACTER results)\n\n2009-08-21  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/41106\n\t* primary.c (gfc_variable_attr): Make it work also on EXPR_FUNCTION.\n\t(gfc_expr_attr): Use gfc_variable_attr for procedure pointer components.\n\t* resolve.c (resolve_fl_derived): Handle CHARACTER-valued procedure\n\tpointer components.\n\t* trans-expr.c (gfc_conv_component_ref): Ditto.\n\t(gfc_conv_variable): Ditto.\n\t(gfc_conv_procedure_call): Ditto.\n\t(gfc_trans_pointer_assignment): Ditto.\n\t* trans-types.c (gfc_get_derived_type): Ditto.\n\n\n2009-08-21  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/41106\n\t* gfortran.dg/proc_ptr_23.f90: New.\n\t* gfortran.dg/proc_ptr_comp_15.f90: New.\n\t* gfortran.dg/proc_ptr_comp_16.f90: New.\n\t* gfortran.dg/proc_ptr_comp_17.f90: New.\n\nFrom-SVN: r150987", "tree": {"sha": "a3b5977c83d08689c7361a13185588b3559d8618", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a3b5977c83d08689c7361a13185588b3559d8618"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/50dbf0b414c3a0afe3f1fbe2143511882d5277d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50dbf0b414c3a0afe3f1fbe2143511882d5277d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50dbf0b414c3a0afe3f1fbe2143511882d5277d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50dbf0b414c3a0afe3f1fbe2143511882d5277d9/comments", "author": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b8c1a924a55851b83b26391e1703bd15c1c4066", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b8c1a924a55851b83b26391e1703bd15c1c4066", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b8c1a924a55851b83b26391e1703bd15c1c4066"}], "stats": {"total": 210, "additions": 178, "deletions": 32}, "files": [{"sha": "53a9d6d99ec6996ea2cba42cc6df97c643852ddf", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dbf0b414c3a0afe3f1fbe2143511882d5277d9/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dbf0b414c3a0afe3f1fbe2143511882d5277d9/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=50dbf0b414c3a0afe3f1fbe2143511882d5277d9", "patch": "@@ -1,3 +1,16 @@\n+2009-08-21  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/41106\n+\t* primary.c (gfc_variable_attr): Make it work also on EXPR_FUNCTION.\n+\t(gfc_expr_attr): Use gfc_variable_attr for procedure pointer components.\n+\t* resolve.c (resolve_fl_derived): Handle CHARACTER-valued procedure\n+\tpointer components.\n+\t* trans-expr.c (gfc_conv_component_ref): Ditto.\n+\t(gfc_conv_variable): Ditto.\n+\t(gfc_conv_procedure_call): Ditto.\n+\t(gfc_trans_pointer_assignment): Ditto.\n+\t* trans-types.c (gfc_get_derived_type): Ditto.\n+\n 2009-08-20  Tobias Schl\ufffdter  <tobi@gcc.gnu.org>\n \n \t* trans-stmt.c (gfc_trans_do): Add a few missing folds."}, {"sha": "0a917f7f048b60ad07502e8546ab7c20898f6fe6", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dbf0b414c3a0afe3f1fbe2143511882d5277d9/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dbf0b414c3a0afe3f1fbe2143511882d5277d9/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=50dbf0b414c3a0afe3f1fbe2143511882d5277d9", "patch": "@@ -1938,7 +1938,7 @@ gfc_variable_attr (gfc_expr *expr, gfc_typespec *ts)\n   symbol_attribute attr;\n   gfc_ref *ref;\n \n-  if (expr->expr_type != EXPR_VARIABLE)\n+  if (expr->expr_type != EXPR_VARIABLE && expr->expr_type != EXPR_FUNCTION)\n     gfc_internal_error (\"gfc_variable_attr(): Expression isn't a variable\");\n \n   ref = expr->ref;\n@@ -2032,6 +2032,8 @@ gfc_expr_attr (gfc_expr *e)\n \n       if (e->value.function.esym != NULL)\n \tattr = e->value.function.esym->result->attr;\n+      else\n+\tattr = gfc_variable_attr (e, NULL);\n \n       /* TODO: NULL() returns pointers.  May have to take care of this\n \t here.  */"}, {"sha": "411e2c8d9dc492dd85867a8abb1246f19fb19d07", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dbf0b414c3a0afe3f1fbe2143511882d5277d9/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dbf0b414c3a0afe3f1fbe2143511882d5277d9/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=50dbf0b414c3a0afe3f1fbe2143511882d5277d9", "patch": "@@ -9476,7 +9476,7 @@ resolve_fl_derived (gfc_symbol *sym)\n \t      if (ifc->ts.type == BT_CHARACTER && ifc->ts.u.cl)\n \t\t{\n \t\t  c->ts.u.cl = gfc_new_charlen (sym->ns, ifc->ts.u.cl);\n-\t\t  /* TODO: gfc_expr_replace_symbols (c->ts.u.cl->length, c);*/\n+\t\t  gfc_expr_replace_comp (c->ts.u.cl->length, c);\n \t\t}\n \t    }\n \t  else if (c->ts.interface->name[0] != '\\0')\n@@ -9604,7 +9604,7 @@ resolve_fl_derived (gfc_symbol *sym)\n \t  return FAILURE;\n \t}\n \n-      if (c->ts.type == BT_CHARACTER)\n+      if (c->ts.type == BT_CHARACTER && !c->attr.proc_pointer)\n \t{\n \t if (c->ts.u.cl->length == NULL\n \t     || (resolve_charlen (c->ts.u.cl) == FAILURE)"}, {"sha": "3f5e76d137dbbb88dfb87ee0df8f96b104a0b878", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 41, "deletions": 26, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dbf0b414c3a0afe3f1fbe2143511882d5277d9/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dbf0b414c3a0afe3f1fbe2143511882d5277d9/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=50dbf0b414c3a0afe3f1fbe2143511882d5277d9", "patch": "@@ -474,7 +474,7 @@ gfc_conv_component_ref (gfc_se * se, gfc_ref * ref)\n \n   se->expr = tmp;\n \n-  if (c->ts.type == BT_CHARACTER)\n+  if (c->ts.type == BT_CHARACTER && !c->attr.proc_pointer)\n     {\n       tmp = c->ts.u.cl->backend_decl;\n       /* Components must always be constant length.  */\n@@ -714,7 +714,7 @@ gfc_conv_variable (gfc_se * se, gfc_expr * expr)\n      separately.  */\n   if (se->want_pointer)\n     {\n-      if (expr->ts.type == BT_CHARACTER)\n+      if (expr->ts.type == BT_CHARACTER && !gfc_is_proc_ptr_comp (expr, NULL))\n \tgfc_conv_string_parameter (se);\n       else \n \tse->expr = gfc_build_addr_expr (NULL_TREE, se->expr);\n@@ -2577,16 +2577,25 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \n   gfc_init_block (&post);\n   gfc_init_interface_mapping (&mapping);\n-  need_interface_mapping = ((sym->ts.type == BT_CHARACTER\n-\t\t\t\t  && sym->ts.u.cl->length\n-\t\t\t\t  && sym->ts.u.cl->length->expr_type\n-\t\t\t\t\t\t!= EXPR_CONSTANT)\n-\t\t\t      || (comp && comp->attr.dimension)\n-\t\t\t      || (!comp && sym->attr.dimension));\n-  if (comp)\n-    formal = comp->formal;\n+  if (!comp)\n+    {\n+      formal = sym->formal;\n+      need_interface_mapping = sym->attr.dimension ||\n+\t\t\t       (sym->ts.type == BT_CHARACTER\n+\t\t\t\t&& sym->ts.u.cl->length\n+\t\t\t\t&& sym->ts.u.cl->length->expr_type\n+\t\t\t\t   != EXPR_CONSTANT);\n+    }\n   else\n-    formal = sym->formal;\n+    {\n+      formal = comp->formal;\n+      need_interface_mapping = comp->attr.dimension ||\n+\t\t\t       (comp->ts.type == BT_CHARACTER\n+\t\t\t\t&& comp->ts.u.cl->length\n+\t\t\t\t&& comp->ts.u.cl->length->expr_type\n+\t\t\t\t   != EXPR_CONSTANT);\n+    }\n+\n   /* Evaluate the arguments.  */\n   for (; arg != NULL; arg = arg->next, formal = formal ? formal->next : NULL)\n     {\n@@ -2913,12 +2922,16 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n     }\n   gfc_finish_interface_mapping (&mapping, &se->pre, &se->post);\n \n-  ts = sym->ts;\n+  if (comp)\n+    ts = comp->ts;\n+  else\n+   ts = sym->ts;\n+\n   if (ts.type == BT_CHARACTER && sym->attr.is_bind_c)\n     se->string_length = build_int_cst (gfc_charlen_type_node, 1);\n   else if (ts.type == BT_CHARACTER)\n     {\n-      if (sym->ts.u.cl->length == NULL)\n+      if (ts.u.cl->length == NULL)\n \t{\n \t  /* Assumed character length results are not allowed by 5.1.1.5 of the\n \t     standard and are trapped in resolve.c; except in the case of SPREAD\n@@ -2943,9 +2956,9 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t  /* Calculate the length of the returned string.  */\n \t  gfc_init_se (&parmse, NULL);\n \t  if (need_interface_mapping)\n-\t    gfc_apply_interface_mapping (&mapping, &parmse, sym->ts.u.cl->length);\n+\t    gfc_apply_interface_mapping (&mapping, &parmse, ts.u.cl->length);\n \t  else\n-\t    gfc_conv_expr (&parmse, sym->ts.u.cl->length);\n+\t    gfc_conv_expr (&parmse, ts.u.cl->length);\n \t  gfc_add_block_to_block (&se->pre, &parmse.pre);\n \t  gfc_add_block_to_block (&se->post, &parmse.post);\n \t  \n@@ -2963,7 +2976,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n       len = cl.backend_decl;\n     }\n \n-  byref = (comp && comp->attr.dimension)\n+  byref = (comp && (comp->attr.dimension || comp->ts.type == BT_CHARACTER))\n \t  || (!comp && gfc_return_by_reference (sym));\n   if (byref)\n     {\n@@ -3004,7 +3017,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t  tmp = gfc_build_addr_expr (NULL_TREE, tmp);\n \t  retargs = gfc_chainon_list (retargs, tmp);\n \t}\n-      else if (sym->result->attr.dimension)\n+      else if (!comp && sym->result->attr.dimension)\n \t{\n \t  gcc_assert (se->loop && info);\n \n@@ -3036,7 +3049,8 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \n \t  /* Return an address to a char[0:len-1]* temporary for\n \t     character pointers.  */\n-\t  if (sym->attr.pointer || sym->attr.allocatable)\n+\t  if ((!comp && (sym->attr.pointer || sym->attr.allocatable))\n+\t       || (comp && (comp->attr.pointer || comp->attr.allocatable)))\n \t    {\n \t      var = gfc_create_var (type, \"pstr\");\n \n@@ -3148,22 +3162,21 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t      /* Bundle in the string length.  */\n \t      se->string_length = len;\n \t    }\n-\t  else if (sym->ts.type == BT_CHARACTER)\n+\t  else if (ts.type == BT_CHARACTER)\n \t    {\n \t      /* Dereference for character pointer results.  */\n-\t      if (sym->attr.pointer || sym->attr.allocatable)\n-\t\tse->expr = build_fold_indirect_ref_loc (input_location,\n-\t\t\t\t\t\t    var);\n+\t      if ((!comp && (sym->attr.pointer || sym->attr.allocatable))\n+\t\t  || (comp && (comp->attr.pointer || comp->attr.allocatable)))\n+\t\tse->expr = build_fold_indirect_ref_loc (input_location, var);\n \t      else\n \t        se->expr = var;\n \n \t      se->string_length = len;\n \t    }\n \t  else\n \t    {\n-\t      gcc_assert (sym->ts.type == BT_COMPLEX && gfc_option.flag_f2c);\n-\t      se->expr = build_fold_indirect_ref_loc (input_location,\n-\t\t\t\t\t\t  var);\n+\t      gcc_assert (ts.type == BT_COMPLEX && gfc_option.flag_f2c);\n+\t      se->expr = build_fold_indirect_ref_loc (input_location, var);\n \t    }\n \t}\n     }\n@@ -4237,7 +4250,9 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n \n       /* Check character lengths if character expression.  The test is only\n \t really added if -fbounds-check is enabled.  */\n-      if (expr1->ts.type == BT_CHARACTER && expr2->expr_type != EXPR_NULL)\n+      if (expr1->ts.type == BT_CHARACTER && expr2->expr_type != EXPR_NULL\n+\t  && !expr1->symtree->n.sym->attr.proc_pointer\n+\t  && !gfc_is_proc_ptr_comp (expr1, NULL))\n \t{\n \t  gcc_assert (expr2->ts.type == BT_CHARACTER);\n \t  gcc_assert (lse.string_length && rse.string_length);"}, {"sha": "454a155c1d370cbd5d7979f093141781b70ff8d6", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dbf0b414c3a0afe3f1fbe2143511882d5277d9/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dbf0b414c3a0afe3f1fbe2143511882d5277d9/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=50dbf0b414c3a0afe3f1fbe2143511882d5277d9", "patch": "@@ -2134,12 +2134,11 @@ gfc_get_derived_type (gfc_symbol * derived)\n \t\t\t\t\t\t    PACKED_STATIC,\n \t\t\t\t\t\t    !c->attr.target);\n \t}\n-      else if (c->attr.pointer)\n+      else if (c->attr.pointer && !c->attr.proc_pointer)\n \tfield_type = build_pointer_type (field_type);\n \n       field = gfc_add_field_to_struct (&fieldlist, typenode,\n-\t\t\t\t       get_identifier (c->name),\n-\t\t\t\t       field_type);\n+\t\t\t\t       get_identifier (c->name), field_type);\n       if (c->loc.lb)\n \tgfc_set_decl_location (field, &c->loc);\n       else if (derived->declared_at.lb)"}, {"sha": "0a3181446c4581ac6dcc9492340f33d1090ae078", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dbf0b414c3a0afe3f1fbe2143511882d5277d9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dbf0b414c3a0afe3f1fbe2143511882d5277d9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=50dbf0b414c3a0afe3f1fbe2143511882d5277d9", "patch": "@@ -1,3 +1,11 @@\n+2009-08-21  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/41106\n+\t* gfortran.dg/proc_ptr_23.f90: New.\n+\t* gfortran.dg/proc_ptr_comp_15.f90: New.\n+\t* gfortran.dg/proc_ptr_comp_16.f90: New.\n+\t* gfortran.dg/proc_ptr_comp_17.f90: New.\n+\n 2009-08-21  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/41131"}, {"sha": "ee947122f2b2fae241e31da71fdfefbb8c5f64ff", "filename": "gcc/testsuite/gfortran.dg/proc_ptr_23.f90", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dbf0b414c3a0afe3f1fbe2143511882d5277d9/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_23.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dbf0b414c3a0afe3f1fbe2143511882d5277d9/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_23.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_23.f90?ref=50dbf0b414c3a0afe3f1fbe2143511882d5277d9", "patch": "@@ -0,0 +1,19 @@\n+! { dg-do run }\n+!\n+! PR 41106: [F03] Procedure Pointers with CHARACTER results\n+!\n+! Contributed by Janus Weil <janus@gcc.gnu.org>\n+\n+character(len=5) :: str\n+procedure(character(len=5)), pointer :: pp\n+pp => abc\n+print *,pp()\n+str = pp()\n+if (str/='abcde') call abort()\n+contains\n+ function abc()\n+  character(len=5) :: abc\n+  abc = 'abcde'\n+ end function abc\n+end\n+"}, {"sha": "9f15d14dbe4ba00c2e1914f16da9462e2ab10854", "filename": "gcc/testsuite/gfortran.dg/proc_ptr_comp_15.f90", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dbf0b414c3a0afe3f1fbe2143511882d5277d9/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_15.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dbf0b414c3a0afe3f1fbe2143511882d5277d9/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_15.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_15.f90?ref=50dbf0b414c3a0afe3f1fbe2143511882d5277d9", "patch": "@@ -0,0 +1,28 @@\n+! { dg-do run }\n+!\n+! PR 41106: [F03] Procedure Pointers with CHARACTER results\n+!\n+! Contributed by Tobias Burnus <burnus@gcc.gnu.org>\n+\n+module m\n+ type :: t\n+ procedure(character(len=5)), pointer, nopass :: ptr\n+ end type\n+contains\n+ function abc()\n+  character(len=5) :: abc\n+  abc = 'abcde'\n+ end function abc\n+end module m\n+\n+use m\n+ type(t) :: x\n+ character(len=5) :: str\n+ x%ptr => abc\n+ print *,x%ptr()\n+ str = x%ptr()\n+ if (str/='abcde') call abort()\n+end\n+\n+! { dg-final { cleanup-modules \"m\" } }\n+"}, {"sha": "e6b77a22f02350c26b5572e7df8d30f821fc4c29", "filename": "gcc/testsuite/gfortran.dg/proc_ptr_comp_16.f90", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dbf0b414c3a0afe3f1fbe2143511882d5277d9/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_16.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dbf0b414c3a0afe3f1fbe2143511882d5277d9/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_16.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_16.f90?ref=50dbf0b414c3a0afe3f1fbe2143511882d5277d9", "patch": "@@ -0,0 +1,30 @@\n+! { dg-do run }\n+!\n+! PR 41106: [F03] Procedure Pointers with CHARACTER results\n+!\n+! Contributed by Janus Weil <janus@gcc.gnu.org>\n+\n+module m\n+ type :: t\n+  procedure(abc), pointer, nopass :: ptr\n+ end type\n+contains\n+ function abc(i)\n+  integer :: i\n+  character(len=i) :: abc\n+  abc = 'abcde'\n+ end function abc\n+end module m\n+\n+use m\n+ type(t) :: x\n+ character(len=4) :: str\n+ x%ptr => abc\n+ print *,x%ptr(4)\n+ if (x%ptr(4)/='abcd') call abort\n+ str = x%ptr(3)\n+ if (str/='abc') call abort()\n+end\n+\n+! { dg-final { cleanup-modules \"m\" } }\n+"}, {"sha": "cfe498b0ecab36f3daff37b3dd396968ad8d4a7e", "filename": "gcc/testsuite/gfortran.dg/proc_ptr_comp_17.f90", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dbf0b414c3a0afe3f1fbe2143511882d5277d9/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_17.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dbf0b414c3a0afe3f1fbe2143511882d5277d9/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_17.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_17.f90?ref=50dbf0b414c3a0afe3f1fbe2143511882d5277d9", "patch": "@@ -0,0 +1,32 @@\n+! { dg-do run }\n+!\n+! PR 41106: [F03] Procedure Pointers with CHARACTER results\n+!\n+! Contributed by Janus Weil <janus@gcc.gnu.org>\n+\n+module m\n+ type :: t\n+ procedure(abc), pointer, nopass :: ptr\n+ end type\n+contains\n+ function abc(arg)\n+  character(len=5),pointer :: abc\n+  character(len=5),target :: arg\n+  abc => arg\n+ end function abc\n+end module m\n+\n+use m\n+ type(t) :: x\n+ character(len=5) :: str = 'abcde'\n+ character(len=5), pointer :: strptr\n+ x%ptr => abc\n+ print *,x%ptr(str)\n+ strptr => x%ptr(str)\n+ if (strptr/='abcde') call abort()\n+ str = 'fghij'\n+ if (strptr/='fghij') call abort()\n+end\n+\n+! { dg-final { cleanup-modules \"m\" } }\n+"}]}