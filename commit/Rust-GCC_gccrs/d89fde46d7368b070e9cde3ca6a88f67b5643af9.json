{"sha": "d89fde46d7368b070e9cde3ca6a88f67b5643af9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDg5ZmRlNDZkNzM2OGIwNzBlOWNkZTNjYTZhODhmNjdiNTY0M2FmOQ==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2018-09-26T19:03:26Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2018-09-26T19:03:26Z"}, "message": "tree.c (zerop): Change return type to bool.\n\n\ngcc/ChangeLog:\n\n\t* tree.c (zerop): Change return type to bool.\n\t(integer_zerop, integer_onep, integer_each_onep): Same.\n\t(integer_all_onesp, integer_minus_onep, integer_pow2p): Same.\n\t(integer_nonzerop, integer_truep, tree_ctz, real_zerop): Same.\n\t(real_onep, real_minus_onep, chain_index): Same.\n\t(print_type_hash_statistics, type_list_equal): Same.\n\t* tree.h (zerop): Same.\n\t(zerop, integer_zerop, integer_onep, integer_each_onep): Same.\n\t(integer_all_onesp, integer_minus_onep, integer_pow2p): Same.\n\t(integer_nonzerop, integer_truep, tree_ctz, real_zerop): Same.\n\t(real_onep, real_minus_onep, chain_index): Same.\n\t(print_type_hash_statistics, type_list_equal): Same.\n\nFrom-SVN: r264653", "tree": {"sha": "5a5adfe6b0cb3424e7f060f853d7636a650c2703", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5a5adfe6b0cb3424e7f060f853d7636a650c2703"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d89fde46d7368b070e9cde3ca6a88f67b5643af9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d89fde46d7368b070e9cde3ca6a88f67b5643af9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d89fde46d7368b070e9cde3ca6a88f67b5643af9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d89fde46d7368b070e9cde3ca6a88f67b5643af9/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1fb157ccb58a56edae02542d2bb3f1f30e5f63d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fb157ccb58a56edae02542d2bb3f1f30e5f63d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1fb157ccb58a56edae02542d2bb3f1f30e5f63d1"}], "stats": {"total": 95, "additions": 55, "deletions": 40}, "files": [{"sha": "69c754d8f088d8943870d66a839a1365bbb87927", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d89fde46d7368b070e9cde3ca6a88f67b5643af9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d89fde46d7368b070e9cde3ca6a88f67b5643af9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d89fde46d7368b070e9cde3ca6a88f67b5643af9", "patch": "@@ -1,3 +1,18 @@\n+2018-09-26  Martin Sebor  <msebor@redhat.com>\n+\n+\t* tree.c (zerop): Change return type to bool.\n+\t(integer_zerop, integer_onep, integer_each_onep): Same.\n+\t(integer_all_onesp, integer_minus_onep, integer_pow2p): Same.\n+\t(integer_nonzerop, integer_truep, tree_ctz, real_zerop): Same.\n+\t(real_onep, real_minus_onep, chain_index): Same.\n+\t(print_type_hash_statistics, type_list_equal): Same.\n+\t* tree.h (zerop): Same.\n+\t(zerop, integer_zerop, integer_onep, integer_each_onep): Same.\n+\t(integer_all_onesp, integer_minus_onep, integer_pow2p): Same.\n+\t(integer_nonzerop, integer_truep, tree_ctz, real_zerop): Same.\n+\t(real_onep, real_minus_onep, chain_index): Same.\n+\t(print_type_hash_statistics, type_list_equal): Same.\n+\n 2018-09-26  Jim Wilson  <jimw@sifive.com>\n \n \t* config/riscv/riscv.h (FUNCTION_ARG_REGNO_P): Fix comment."}, {"sha": "64d9e0bfe818341e8c2c528044d0b82f52cfd889", "filename": "gcc/tree.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d89fde46d7368b070e9cde3ca6a88f67b5643af9/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d89fde46d7368b070e9cde3ca6a88f67b5643af9/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=d89fde46d7368b070e9cde3ca6a88f67b5643af9", "patch": "@@ -2475,7 +2475,7 @@ grow_tree_vec (tree v, int len MEM_STAT_DECL)\n /* Return 1 if EXPR is the constant zero, whether it is integral, float or\n    fixed, and scalar, complex or vector.  */\n \n-int\n+bool\n zerop (const_tree expr)\n {\n   return (integer_zerop (expr)\n@@ -2486,7 +2486,7 @@ zerop (const_tree expr)\n /* Return 1 if EXPR is the integer constant zero or a complex constant\n    of zero.  */\n \n-int\n+bool\n integer_zerop (const_tree expr)\n {\n   switch (TREE_CODE (expr))\n@@ -2508,7 +2508,7 @@ integer_zerop (const_tree expr)\n /* Return 1 if EXPR is the integer constant one or the corresponding\n    complex constant.  */\n \n-int\n+bool\n integer_onep (const_tree expr)\n {\n   switch (TREE_CODE (expr))\n@@ -2530,7 +2530,7 @@ integer_onep (const_tree expr)\n /* Return 1 if EXPR is the integer constant one.  For complex and vector,\n    return 1 if every piece is the integer constant one.  */\n \n-int\n+bool\n integer_each_onep (const_tree expr)\n {\n   if (TREE_CODE (expr) == COMPLEX_CST)\n@@ -2543,29 +2543,29 @@ integer_each_onep (const_tree expr)\n /* Return 1 if EXPR is an integer containing all 1's in as much precision as\n    it contains, or a complex or vector whose subparts are such integers.  */\n \n-int\n+bool\n integer_all_onesp (const_tree expr)\n {\n   if (TREE_CODE (expr) == COMPLEX_CST\n       && integer_all_onesp (TREE_REALPART (expr))\n       && integer_all_onesp (TREE_IMAGPART (expr)))\n-    return 1;\n+    return true;\n \n   else if (TREE_CODE (expr) == VECTOR_CST)\n     return (VECTOR_CST_NPATTERNS (expr) == 1\n \t    && VECTOR_CST_DUPLICATE_P (expr)\n \t    && integer_all_onesp (VECTOR_CST_ENCODED_ELT (expr, 0)));\n \n   else if (TREE_CODE (expr) != INTEGER_CST)\n-    return 0;\n+    return false;\n \n   return (wi::max_value (TYPE_PRECISION (TREE_TYPE (expr)), UNSIGNED)\n \t  == wi::to_wide (expr));\n }\n \n /* Return 1 if EXPR is the integer constant minus one.  */\n \n-int\n+bool\n integer_minus_onep (const_tree expr)\n {\n   if (TREE_CODE (expr) == COMPLEX_CST)\n@@ -2578,24 +2578,24 @@ integer_minus_onep (const_tree expr)\n /* Return 1 if EXPR is an integer constant that is a power of 2 (i.e., has only\n    one bit on).  */\n \n-int\n+bool\n integer_pow2p (const_tree expr)\n {\n   if (TREE_CODE (expr) == COMPLEX_CST\n       && integer_pow2p (TREE_REALPART (expr))\n       && integer_zerop (TREE_IMAGPART (expr)))\n-    return 1;\n+    return true;\n \n   if (TREE_CODE (expr) != INTEGER_CST)\n-    return 0;\n+    return false;\n \n   return wi::popcount (wi::to_wide (expr)) == 1;\n }\n \n /* Return 1 if EXPR is an integer constant other than zero or a\n    complex constant other than zero.  */\n \n-int\n+bool\n integer_nonzerop (const_tree expr)\n {\n   return ((TREE_CODE (expr) == INTEGER_CST\n@@ -2609,7 +2609,7 @@ integer_nonzerop (const_tree expr)\n    return 1 if every piece is the integer constant minus one\n    (representing the value TRUE).  */\n \n-int\n+bool\n integer_truep (const_tree expr)\n {\n   if (TREE_CODE (expr) == VECTOR_CST)\n@@ -2619,7 +2619,7 @@ integer_truep (const_tree expr)\n \n /* Return 1 if EXPR is the fixed-point constant zero.  */\n \n-int\n+bool\n fixed_zerop (const_tree expr)\n {\n   return (TREE_CODE (expr) == FIXED_CST\n@@ -2764,7 +2764,7 @@ tree_ctz (const_tree expr)\n /* Return 1 if EXPR is the real constant zero.  Trailing zeroes matter for\n    decimal float constants, so don't return 1 for them.  */\n \n-int\n+bool\n real_zerop (const_tree expr)\n {\n   switch (TREE_CODE (expr))\n@@ -2794,7 +2794,7 @@ real_zerop (const_tree expr)\n    Trailing zeroes matter for decimal float constants, so don't return\n    1 for them.  */\n \n-int\n+bool\n real_onep (const_tree expr)\n {\n   switch (TREE_CODE (expr))\n@@ -2817,7 +2817,7 @@ real_onep (const_tree expr)\n /* Return 1 if EXPR is the real constant minus one.  Trailing zeroes\n    matter for decimal float constants, so don't return 1 for them.  */\n \n-int\n+bool\n real_minus_onep (const_tree expr)\n {\n   switch (TREE_CODE (expr))\n@@ -2839,7 +2839,7 @@ real_minus_onep (const_tree expr)\n \n /* Nonzero if EXP is a constant or a cast of a constant.  */\n \n-int\n+bool\n really_constant_p (const_tree exp)\n {\n   /* This is not quite the same as STRIP_NOPS.  It does more.  */\n@@ -2954,17 +2954,17 @@ chain_index (int idx, tree chain)\n \n /* Return nonzero if ELEM is part of the chain CHAIN.  */\n \n-int\n+bool\n chain_member (const_tree elem, const_tree chain)\n {\n   while (chain)\n     {\n       if (elem == chain)\n-\treturn 1;\n+\treturn true;\n       chain = DECL_CHAIN (chain);\n     }\n \n-  return 0;\n+  return false;\n }\n \n /* Return the length of a chain of nodes chained through TREE_CHAIN.\n@@ -6712,7 +6712,7 @@ print_type_hash_statistics (void)\n    return 1 if the lists contain the same types in the same order.\n    Also, the TREE_PURPOSEs must match.  */\n \n-int\n+bool\n type_list_equal (const_tree l1, const_tree l2)\n {\n   const_tree t1, t2;\n@@ -6723,7 +6723,7 @@ type_list_equal (const_tree l1, const_tree l2)\n \t    && ! (1 == simple_cst_equal (TREE_PURPOSE (t1), TREE_PURPOSE (t2))\n \t\t  && (TREE_TYPE (TREE_PURPOSE (t1))\n \t\t      == TREE_TYPE (TREE_PURPOSE (t2))))))\n-      return 0;\n+      return false;\n \n   return t1 == t2;\n }"}, {"sha": "33fcbcd64963557ab2b632aff4c4f00ac5f4d414", "filename": "gcc/tree.h", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d89fde46d7368b070e9cde3ca6a88f67b5643af9/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d89fde46d7368b070e9cde3ca6a88f67b5643af9/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=d89fde46d7368b070e9cde3ca6a88f67b5643af9", "patch": "@@ -4450,53 +4450,53 @@ extern vec<tree, va_gc> *ctor_to_vec (tree);\n \n /* zerop (tree x) is nonzero if X is a constant of value 0.  */\n \n-extern int zerop (const_tree);\n+extern bool zerop (const_tree);\n \n /* integer_zerop (tree x) is nonzero if X is an integer constant of value 0.  */\n \n-extern int integer_zerop (const_tree);\n+extern bool integer_zerop (const_tree);\n \n /* integer_onep (tree x) is nonzero if X is an integer constant of value 1.  */\n \n-extern int integer_onep (const_tree);\n+extern bool integer_onep (const_tree);\n \n /* integer_onep (tree x) is nonzero if X is an integer constant of value 1, or\n    a vector or complex where each part is 1.  */\n \n-extern int integer_each_onep (const_tree);\n+extern bool integer_each_onep (const_tree);\n \n /* integer_all_onesp (tree x) is nonzero if X is an integer constant\n    all of whose significant bits are 1.  */\n \n-extern int integer_all_onesp (const_tree);\n+extern bool integer_all_onesp (const_tree);\n \n /* integer_minus_onep (tree x) is nonzero if X is an integer constant of\n    value -1.  */\n \n-extern int integer_minus_onep (const_tree);\n+extern bool integer_minus_onep (const_tree);\n \n /* integer_pow2p (tree x) is nonzero is X is an integer constant with\n    exactly one bit 1.  */\n \n-extern int integer_pow2p (const_tree);\n+extern bool integer_pow2p (const_tree);\n \n /* integer_nonzerop (tree x) is nonzero if X is an integer constant\n    with a nonzero value.  */\n \n-extern int integer_nonzerop (const_tree);\n+extern bool integer_nonzerop (const_tree);\n \n /* integer_truep (tree x) is nonzero if X is an integer constant of value 1 or\n    a vector where each element is an integer constant of value -1.  */\n \n-extern int integer_truep (const_tree);\n+extern bool integer_truep (const_tree);\n \n extern bool cst_and_fits_in_hwi (const_tree);\n extern tree num_ending_zeros (const_tree);\n \n /* fixed_zerop (tree x) is nonzero if X is a fixed-point constant of\n    value 0.  */\n \n-extern int fixed_zerop (const_tree);\n+extern bool fixed_zerop (const_tree);\n \n /* staticp (tree x) is nonzero if X is a reference to data allocated\n    at a fixed address in memory.  Returns the outermost data.  */\n@@ -4707,8 +4707,8 @@ extern tree decl_function_context (const_tree);\n    this _DECL with its context, or zero if none.  */\n extern tree decl_type_context (const_tree);\n \n-/* Return 1 if EXPR is the real constant zero.  */\n-extern int real_zerop (const_tree);\n+/* Return true if EXPR is the real constant zero.  */\n+extern bool real_zerop (const_tree);\n \n /* Initialize the iterator I with arguments from function FNDECL  */\n \n@@ -4889,7 +4889,7 @@ bit_field_offset (const_tree t)\n }\n \n extern tree strip_float_extensions (tree);\n-extern int really_constant_p (const_tree);\n+extern bool really_constant_p (const_tree);\n extern bool ptrdiff_tree_p (const_tree, poly_int64_pod *);\n extern bool decl_address_invariant_p (const_tree);\n extern bool decl_address_ip_invariant_p (const_tree);\n@@ -4920,14 +4920,14 @@ static inline hashval_t iterative_hash_expr(const_tree tree, hashval_t seed)\n }\n \n extern int compare_tree_int (const_tree, unsigned HOST_WIDE_INT);\n-extern int type_list_equal (const_tree, const_tree);\n-extern int chain_member (const_tree, const_tree);\n+extern bool type_list_equal (const_tree, const_tree);\n+extern bool chain_member (const_tree, const_tree);\n extern void dump_tree_statistics (void);\n extern void recompute_tree_invariant_for_addr_expr (tree);\n extern bool needs_to_live_in_memory (const_tree);\n extern tree reconstruct_complex_type (tree, tree);\n-extern int real_onep (const_tree);\n-extern int real_minus_onep (const_tree);\n+extern bool real_onep (const_tree);\n+extern bool real_minus_onep (const_tree);\n extern void init_ttree (void);\n extern void build_common_tree_nodes (bool);\n extern void build_common_builtin_nodes (void);"}]}