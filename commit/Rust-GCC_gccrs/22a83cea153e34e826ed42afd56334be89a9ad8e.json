{"sha": "22a83cea153e34e826ed42afd56334be89a9ad8e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjJhODNjZWExNTNlMzRlODI2ZWQ0MmFmZDU2MzM0YmU4OWE5YWQ4ZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-07-09T13:14:52Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-07-09T13:14:52Z"}, "message": "[multiple changes]\n\n2012-07-09  Thomas Quinot  <quinot@adacore.com>\n\n\t* einfo.adb (Set_Reverse_Storage_Order): Update assertion,\n\tflag is now valid for array types as well.\n\n2012-07-09  Tristan Gingold  <gingold@adacore.com>\n\n\t* tracebak.c: Implement __gnat_backtrace for Win64 SEH.\n\n2012-07-09  Robert Dewar  <dewar@adacore.com>\n\n\t* einfo.ads: Minor reformatting.\n\n2012-07-09  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_ch8.adb (Expand_N_Subprogram_Renaming_Declaration): Handle as\n\trenaming_as_body renamings of predefined dispatching equality\n\tand unequality operators.\n\n2012-07-09  Robert Dewar  <dewar@adacore.com>\n\n\t* rident.ads: Do not instantiate r-ident.ads, this is now an\n\tindependent unit.\n\n2012-07-09  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_disp.adb (Write_DT): Avoid runtime crash of this debugging\n\troutine.\n\t* sem_disp.adb (Find_Dispatching_Time): Protect this routine\n\tagainst partially decorated entities.\n\n2012-07-09  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch13.adb (Check_Size): Reject a size clause that specifies\n\ta value greater than Int'Last for a scalar type.\n\n2012-07-09  Vincent Pucci  <pucci@adacore.com>\n\n\t* sem_ch9.adb (Allows_Lock_Free_Implementation): type must support\n\tatomic operation moved to the protected body case. No non-elementary\n\tout parameter moved to the protected declaration case. Functions have\n\tonly one lock-free restriction.\n\t(Analyze_Protected_Type_Declaration): Issue a warning when\n\tPriority given with Lock_Free.\n\n2012-07-09  Vincent Pucci  <pucci@adacore.com>\n\n\t* sem_dim.adb: Grammar of aspect Dimension fixed.\n\n2012-07-09  Vincent Pucci  <pucci@adacore.com>\n\n\t* freeze.adb (Freeze_Record_Type): Code reorg in order to avoid\n\tpushing and popping the scope stack whenever a delayed aspect occurs.\n\n2012-07-09  Gary Dismukes  <dismukes@adacore.com>\n\n\t* s-os_lib.ads: Remove pragma Elaborate_Body, as\n\tthis is now unnecessary due to recently added pragma Preelaborate.\n\n2012-07-09  Jose Ruiz  <ruiz@adacore.com>\n\n\t* s-taprop-mingw.adb (Set_Priority): Remove the code that was\n\tpreviously in place to reorder the ready queue when a task drops\n\tits priority due to the loss of inherited priority.\n\nFrom-SVN: r189377", "tree": {"sha": "9fbb4905b777da0e0b7e9948da3632d61fee8a40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9fbb4905b777da0e0b7e9948da3632d61fee8a40"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/22a83cea153e34e826ed42afd56334be89a9ad8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22a83cea153e34e826ed42afd56334be89a9ad8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22a83cea153e34e826ed42afd56334be89a9ad8e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22a83cea153e34e826ed42afd56334be89a9ad8e/comments", "author": null, "committer": null, "parents": [{"sha": "a2c1791d894d8d421bda4344219bc971ec7faa30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2c1791d894d8d421bda4344219bc971ec7faa30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2c1791d894d8d421bda4344219bc971ec7faa30"}], "stats": {"total": 1234, "additions": 943, "deletions": 291}, "files": [{"sha": "627ccaf286d07ab44a733f0ba6a85c0a2f0fc726", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22a83cea153e34e826ed42afd56334be89a9ad8e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22a83cea153e34e826ed42afd56334be89a9ad8e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=22a83cea153e34e826ed42afd56334be89a9ad8e", "patch": "@@ -1,3 +1,68 @@\n+2012-07-09  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* einfo.adb (Set_Reverse_Storage_Order): Update assertion,\n+\tflag is now valid for array types as well.\n+\n+2012-07-09  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* tracebak.c: Implement __gnat_backtrace for Win64 SEH.\n+\n+2012-07-09  Robert Dewar  <dewar@adacore.com>\n+\n+\t* einfo.ads: Minor reformatting.\n+\n+2012-07-09  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_ch8.adb (Expand_N_Subprogram_Renaming_Declaration): Handle as\n+\trenaming_as_body renamings of predefined dispatching equality\n+\tand unequality operators.\n+\n+2012-07-09  Robert Dewar  <dewar@adacore.com>\n+\n+\t* rident.ads: Do not instantiate r-ident.ads, this is now an\n+\tindependent unit.\n+\n+2012-07-09  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_disp.adb (Write_DT): Avoid runtime crash of this debugging\n+\troutine.\n+\t* sem_disp.adb (Find_Dispatching_Time): Protect this routine\n+\tagainst partially decorated entities.\n+\n+2012-07-09  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch13.adb (Check_Size): Reject a size clause that specifies\n+\ta value greater than Int'Last for a scalar type.\n+\n+2012-07-09  Vincent Pucci  <pucci@adacore.com>\n+\n+\t* sem_ch9.adb (Allows_Lock_Free_Implementation): type must support\n+\tatomic operation moved to the protected body case. No non-elementary\n+\tout parameter moved to the protected declaration case. Functions have\n+\tonly one lock-free restriction.\n+\t(Analyze_Protected_Type_Declaration): Issue a warning when\n+\tPriority given with Lock_Free.\n+\n+2012-07-09  Vincent Pucci  <pucci@adacore.com>\n+\n+\t* sem_dim.adb: Grammar of aspect Dimension fixed.\n+\n+2012-07-09  Vincent Pucci  <pucci@adacore.com>\n+\n+\t* freeze.adb (Freeze_Record_Type): Code reorg in order to avoid\n+\tpushing and popping the scope stack whenever a delayed aspect occurs.\n+\n+2012-07-09  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* s-os_lib.ads: Remove pragma Elaborate_Body, as\n+\tthis is now unnecessary due to recently added pragma Preelaborate.\n+\n+2012-07-09  Jose Ruiz  <ruiz@adacore.com>\n+\n+\t* s-taprop-mingw.adb (Set_Priority): Remove the code that was\n+\tpreviously in place to reorder the ready queue when a task drops\n+\tits priority due to the loss of inherited priority.\n+\n 2012-07-09  Robert Dewar  <dewar@adacore.com>\n \n \t* layout.adb, i-cstrea.ads, a-ststio.ads, prj-util.ads, sem_cat.adb,"}, {"sha": "6ef644a94cff00a6ac058034d4cb21774a0eaa52", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22a83cea153e34e826ed42afd56334be89a9ad8e/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22a83cea153e34e826ed42afd56334be89a9ad8e/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=22a83cea153e34e826ed42afd56334be89a9ad8e", "patch": "@@ -5163,7 +5163,8 @@ package body Einfo is\n    procedure Set_Reverse_Storage_Order (Id : E; V : B := True) is\n    begin\n       pragma Assert\n-        (Is_Record_Type (Id) and then Is_Base_Type (Id));\n+        (Is_Base_Type (Id)\n+           and then (Is_Record_Type (Id) or else Is_Array_Type (Id)));\n       Set_Flag93 (Id, V);\n    end Set_Reverse_Storage_Order;\n "}, {"sha": "3da53018faea8f066aa7309d7fe7e1a2a2f6e90b", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22a83cea153e34e826ed42afd56334be89a9ad8e/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22a83cea153e34e826ed42afd56334be89a9ad8e/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=22a83cea153e34e826ed42afd56334be89a9ad8e", "patch": "@@ -5021,6 +5021,7 @@ package Einfo is\n    --    Has_Component_Size_Clause           (Flag68)   (base type only)\n    --    Has_Pragma_Pack                     (Flag121)  (impl base type only)\n    --    Is_Constrained                      (Flag12)\n+   --    Reverse_Storage_Order               (Flag93)   (base type only)\n    --    Next_Index                          (synth)\n    --    Number_Dimensions                   (synth)\n    --    (plus type attributes)"}, {"sha": "3647ceb5b62bc4948c14141df4d660f8ec47b674", "filename": "gcc/ada/exp_ch8.adb", "status": "modified", "additions": 110, "deletions": 31, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22a83cea153e34e826ed42afd56334be89a9ad8e/gcc%2Fada%2Fexp_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22a83cea153e34e826ed42afd56334be89a9ad8e/gcc%2Fada%2Fexp_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch8.adb?ref=22a83cea153e34e826ed42afd56334be89a9ad8e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -239,6 +239,44 @@ package body Exp_Ch8 is\n    ----------------------------------------------\n \n    procedure Expand_N_Subprogram_Renaming_Declaration (N : Node_Id) is\n+      Loc : constant Source_Ptr := Sloc (N);\n+      Id  : constant Entity_Id  := Defining_Entity (N);\n+\n+      function Build_Body_For_Renaming return Node_Id;\n+      --  Build and return the body for the renaming declaration of an\n+      --  equality or unequality operator.\n+\n+      function Build_Body_For_Renaming return Node_Id is\n+         Body_Id : Entity_Id;\n+         Decl    : Node_Id;\n+\n+      begin\n+         Set_Alias (Id, Empty);\n+         Set_Has_Completion (Id, False);\n+         Rewrite (N,\n+           Make_Subprogram_Declaration (Sloc (N),\n+             Specification => Specification (N)));\n+         Set_Has_Delayed_Freeze (Id);\n+\n+         Body_Id := Make_Defining_Identifier (Sloc (N), Chars (Id));\n+         Set_Debug_Info_Needed (Body_Id);\n+\n+         Decl :=\n+           Make_Subprogram_Body (Loc,\n+             Specification              =>\n+               Make_Function_Specification (Loc,\n+                 Defining_Unit_Name       => Body_Id,\n+                 Parameter_Specifications => Copy_Parameter_List (Id),\n+                 Result_Definition        =>\n+                   New_Occurrence_Of (Standard_Boolean, Loc)),\n+             Declarations               => Empty_List,\n+             Handled_Statement_Sequence => Empty);\n+\n+         return Decl;\n+      end Build_Body_For_Renaming;\n+\n+      --  Local variable\n+\n       Nam : constant Node_Id := Name (N);\n \n    begin\n@@ -259,25 +297,26 @@ package body Exp_Ch8 is\n          Force_Evaluation (Prefix (Nam));\n       end if;\n \n-      --  Check whether this is a renaming of a predefined equality on an\n-      --  untagged record type (AI05-0123).\n+      --  Handle cases where we build a body for a renamed equality\n \n       if Is_Entity_Name (Nam)\n-        and then Chars (Entity (Nam)) = Name_Op_Eq\n+        and then (Chars (Entity (Nam)) = Name_Op_Ne\n+                   or else Chars (Entity (Nam)) = Name_Op_Eq)\n         and then Scope (Entity (Nam)) = Standard_Standard\n-        and then Ada_Version >= Ada_2012\n       then\n          declare\n-            Loc : constant Source_Ptr := Sloc (N);\n-            Id  : constant Entity_Id  := Defining_Entity (N);\n-            Typ : constant Entity_Id  := Etype (First_Formal (Id));\n-\n-            Decl    : Node_Id;\n-            Body_Id : constant Entity_Id :=\n-                        Make_Defining_Identifier (Sloc (N), Chars (Id));\n+            Left  : constant Entity_Id := First_Formal (Id);\n+            Right : constant Entity_Id := Next_Formal (Left);\n+            Typ   : constant Entity_Id := Etype (Left);\n+            Decl  : Node_Id;\n \n          begin\n-            if Is_Record_Type (Typ)\n+            --  Check whether this is a renaming of a predefined equality on an\n+            --  untagged record type (AI05-0123).\n+\n+            if Ada_Version >= Ada_2012\n+              and then Chars (Entity (Nam)) = Name_Op_Eq\n+              and then Is_Record_Type (Typ)\n               and then not Is_Tagged_Type (Typ)\n               and then not Is_Frozen (Typ)\n             then\n@@ -288,23 +327,7 @@ package body Exp_Ch8 is\n                --  declaration, and the body is inserted at the end of the\n                --  current declaration list to prevent premature freezing.\n \n-               Set_Alias (Id, Empty);\n-               Set_Has_Completion (Id, False);\n-               Rewrite (N,\n-                 Make_Subprogram_Declaration (Sloc (N),\n-                   Specification => Specification (N)));\n-               Set_Has_Delayed_Freeze (Id);\n-\n-               Decl := Make_Subprogram_Body (Loc,\n-                         Specification              =>\n-                           Make_Function_Specification (Loc,\n-                             Defining_Unit_Name       => Body_Id,\n-                             Parameter_Specifications =>\n-                               Copy_Parameter_List (Id),\n-                             Result_Definition        =>\n-                               New_Occurrence_Of (Standard_Boolean, Loc)),\n-                         Declarations               => Empty_List,\n-                         Handled_Statement_Sequence => Empty);\n+               Decl := Build_Body_For_Renaming;\n \n                Set_Handled_Statement_Sequence (Decl,\n                  Make_Handled_Sequence_Of_Statements (Loc,\n@@ -322,7 +345,63 @@ package body Exp_Ch8 is\n                             Bodies => Declarations (Decl))))));\n \n                Append (Decl, List_Containing (N));\n-               Set_Debug_Info_Needed (Body_Id);\n+\n+            --  Handle renamings of predefined dispatching equality operators.\n+            --  When we analyze a renaming of the equality operator of a tagged\n+            --  type, the predefined dispatching primitives are not available\n+            --  (since they are added by the expander when the tagged type is\n+            --  frozen) and hence they are left decorated as renamings of the\n+            --  standard non-dispatching operators. Here we generate a body\n+            --  for such renamings which invokes the predefined dispatching\n+            --  equality operator.\n+\n+            --  Example:\n+\n+            --    type T is tagged null record;\n+            --    function  Eq (X, Y : T1) return Boolean renames \"=\";\n+            --    function Neq (X, Y : T1) return Boolean renames \"/=\";\n+\n+            elsif Is_Record_Type (Typ)\n+              and then Is_Tagged_Type (Typ)\n+              and then Is_Dispatching_Operation (Id)\n+              and then not Is_Dispatching_Operation (Entity (Nam))\n+            then\n+               pragma Assert (not Is_Frozen (Typ));\n+\n+               Decl := Build_Body_For_Renaming;\n+\n+               --  Clean decoration of intrinsic subprogram\n+\n+               Set_Is_Intrinsic_Subprogram (Id, False);\n+               Set_Convention (Id, Convention_Ada);\n+\n+               if Chars (Entity (Nam)) = Name_Op_Ne then\n+                  Set_Handled_Statement_Sequence (Decl,\n+                    Make_Handled_Sequence_Of_Statements (Loc,\n+                      Statements => New_List (\n+                        Make_Simple_Return_Statement (Loc,\n+                          Expression =>\n+                             Make_Op_Not (Loc,\n+                               Make_Op_Eq (Loc,\n+                                 Left_Opnd  =>\n+                                   New_Reference_To (Left, Loc),\n+                                 Right_Opnd =>\n+                                   New_Reference_To (Right, Loc)))))));\n+\n+               else pragma Assert (Chars (Entity (Nam)) = Name_Op_Eq);\n+                  Set_Handled_Statement_Sequence (Decl,\n+                    Make_Handled_Sequence_Of_Statements (Loc,\n+                      Statements => New_List (\n+                        Make_Simple_Return_Statement (Loc,\n+                          Expression =>\n+                            Make_Op_Eq (Loc,\n+                              Left_Opnd  =>\n+                                New_Reference_To (Left, Loc),\n+                              Right_Opnd =>\n+                                New_Reference_To (Right, Loc))))));\n+               end if;\n+\n+               Append (Decl, List_Containing (N));\n             end if;\n          end;\n       end if;"}, {"sha": "2dc1e485ea628284b0a91971e7f34d6b9e74c1d8", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22a83cea153e34e826ed42afd56334be89a9ad8e/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22a83cea153e34e826ed42afd56334be89a9ad8e/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=22a83cea153e34e826ed42afd56334be89a9ad8e", "patch": "@@ -5777,7 +5777,7 @@ package body Exp_Disp is\n              Prefix => New_Reference_To (TSD, Loc),\n              Attribute_Name => Name_Address));\n \n-         --  Stage 2: Initialize the table of primitive operations\n+         --  Stage 2: Initialize the table of user-defined primitive operations\n \n          Prim_Ops_Aggr_List := New_List;\n \n@@ -8857,7 +8857,8 @@ package body Exp_Disp is\n             --  If the DTC_Entity attribute is already set we can also output\n             --  the name of the interface covered by this primitive (if any).\n \n-            if Present (DTC_Entity (Alias (Prim)))\n+            if Ekind_In (Alias (Prim), E_Function, E_Procedure)\n+              and then Present (DTC_Entity (Alias (Prim)))\n               and then Is_Interface (Scope (DTC_Entity (Alias (Prim))))\n             then\n                Write_Str  (\" from interface \");"}, {"sha": "279e08abe4e3f581cdd6d167b7e0d8e0b0772a14", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 40, "deletions": 21, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22a83cea153e34e826ed42afd56334be89a9ad8e/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22a83cea153e34e826ed42afd56334be89a9ad8e/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=22a83cea153e34e826ed42afd56334be89a9ad8e", "patch": "@@ -1814,6 +1814,11 @@ package body Freeze is\n          Junk : Boolean;\n          pragma Warnings (Off, Junk);\n \n+         Rec_Pushed : Boolean := False;\n+         --  Set True if the record type scope Rec has been pushed on the scope\n+         --  stack. Needed for the analysis of delayed aspects specified to the\n+         --  components of Rec.\n+\n          Unplaced_Component : Boolean := False;\n          --  Set True if we find at least one component with no component\n          --  clause (used to warn about useless Pack pragmas).\n@@ -1901,39 +1906,53 @@ package body Freeze is\n       --  Start of processing for Freeze_Record_Type\n \n       begin\n-         --  Freeze components and embedded subtypes\n+         --  Deal with delayed aspect specifications for components. The\n+         --  analysis of the aspect is required to be delayed to the freeze\n+         --  point, thus we analyze the pragma or attribute definition clause\n+         --  in the tree at this point. We also analyze the aspect\n+         --  specification node at the freeze point when the aspect doesn't\n+         --  correspond to pragma/attribute definition clause.\n \n          Comp := First_Entity (Rec);\n-         Prev := Empty;\n          while Present (Comp) loop\n-\n-            --  Deal with delayed aspect specifications for components. The\n-            --  analysis of the aspect is required to be delayed to the freeze\n-            --  point, thus we analyze the pragma or attribute definition\n-            --  clause in the tree at this point. We also analyze the aspect\n-            --  specification node at the freeze point when the aspect doesn't\n-            --  correspond to pragma/attribute definition clause.\n-\n             if Ekind (Comp) = E_Component\n               and then Has_Delayed_Aspects (Comp)\n             then\n-               Push_Scope (Rec);\n-\n-               --  The visibility to the discriminants must be restored in\n-               --  order to properly analyze the aspects.\n+               if not Rec_Pushed then\n+                  Push_Scope (Rec);\n+                  Rec_Pushed := True;\n \n-               if Has_Discriminants (Rec) then\n-                  Install_Discriminants (Rec);\n-                  Analyze_Aspects_At_Freeze_Point (Comp);\n-                  Uninstall_Discriminants (Rec);\n+                  --  The visibility to the discriminants must be restored in\n+                  --  order to properly analyze the aspects.\n \n-               else\n-                  Analyze_Aspects_At_Freeze_Point (Comp);\n+                  if Has_Discriminants (Rec) then\n+                     Install_Discriminants (Rec);\n+                  end if;\n                end if;\n \n-               Pop_Scope;\n+               Analyze_Aspects_At_Freeze_Point (Comp);\n+            end if;\n+\n+            Next_Entity (Comp);\n+         end loop;\n+\n+         --  Pop the scope if Rec scope has been pushed on the scope stack\n+         --  during the delayed aspect analysis process.\n+\n+         if Rec_Pushed then\n+            if Has_Discriminants (Rec) then\n+               Uninstall_Discriminants (Rec);\n             end if;\n \n+            Pop_Scope;\n+         end if;\n+\n+         --  Freeze components and embedded subtypes\n+\n+         Comp := First_Entity (Rec);\n+         Prev := Empty;\n+         while Present (Comp) loop\n+\n             --  Handle the component and discriminant case\n \n             if Ekind (Comp) = E_Component"}, {"sha": "4e428c4962dac4ad2ef535c9a8f88f53dba702c0", "filename": "gcc/ada/restrict.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22a83cea153e34e826ed42afd56334be89a9ad8e/gcc%2Fada%2Frestrict.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22a83cea153e34e826ed42afd56334be89a9ad8e/gcc%2Fada%2Frestrict.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frestrict.adb?ref=22a83cea153e34e826ed42afd56334be89a9ad8e", "patch": "@@ -768,7 +768,7 @@ package body Restrict is\n    ----------------------------------\n \n    --  Note: body of this function must be coordinated with list of\n-   --  renaming declarations in System.Rident.\n+   --  renaming declarations in Rident.\n \n    function Process_Restriction_Synonyms (N : Node_Id) return Name_Id\n    is"}, {"sha": "d7b05d460cfff50fe5d15749c3f41622d3e166de", "filename": "gcc/ada/restrict.ads", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22a83cea153e34e826ed42afd56334be89a9ad8e/gcc%2Fada%2Frestrict.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22a83cea153e34e826ed42afd56334be89a9ad8e/gcc%2Fada%2Frestrict.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frestrict.ads?ref=22a83cea153e34e826ed42afd56334be89a9ad8e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -332,10 +332,10 @@ package Restrict is\n    --  exception propagation is activated.\n \n    function Process_Restriction_Synonyms (N : Node_Id) return Name_Id;\n-   --  Id is a node whose Chars field contains the name of a restriction.\n-   --  If it is one of synonyms that we allow for historical purposes (for\n-   --  list see System.Rident), then the proper official name is returned.\n-   --  Otherwise the Chars field of the argument is returned unchanged.\n+   --  Id is a node whose Chars field contains the name of a restriction. If it\n+   --  is one of synonyms that we allow for historical purposes (for list see\n+   --  Rident), then the proper official name is returned. Otherwise the Chars\n+   --  field of the argument is returned unchanged.\n \n    function Restriction_Active (R : All_Restrictions) return Boolean;\n    pragma Inline (Restriction_Active);"}, {"sha": "240871405bb5c1a6014dc589c684a2e3481181ae", "filename": "gcc/ada/rident.ads", "status": "modified", "additions": 411, "deletions": 11, "changes": 422, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22a83cea153e34e826ed42afd56334be89a9ad8e/gcc%2Fada%2Frident.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22a83cea153e34e826ed42afd56334be89a9ad8e/gcc%2Fada%2Frident.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frident.ads?ref=22a83cea153e34e826ed42afd56334be89a9ad8e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -34,16 +34,416 @@\n --  it can be used by the binder without dragging in unneeded compiler\n --  packages.\n \n---  Note: the actual definitions of the types are in package System.Rident,\n---  and this package is merely an instantiation of that package. The point\n---  of this level of generic indirection is to allow the compile time use\n---  to have the image tables available (this package is not compiled with\n---  Discard_Names), while at run-time we do not want those image tables.\n+package Rident is\n \n---  Rather than have clients instantiate System.Rident directly, we have the\n---  single instantiation here at the library level, which means that we only\n---  have one copy of the image tables\n+   --  The following enumeration type defines the set of restriction\n+   --  identifiers that are implemented in GNAT.\n \n-with System.Rident;\n+   --  To add a new restriction identifier, add an entry with the name to be\n+   --  used in the pragma, and add calls to the Restrict.Check_Restriction\n+   --  routine as appropriate.\n \n-package Rident is new System.Rident;\n+   type Restriction_Id is\n+\n+      --  The following cases are checked for consistency in the binder. The\n+      --  binder will check that every unit either has the restriction set, or\n+      --  does not violate the restriction.\n+\n+     (Simple_Barriers,                         -- GNAT (Ravenscar)\n+      No_Abort_Statements,                     -- (RM D.7(5), H.4(3))\n+      No_Access_Subprograms,                   -- (RM H.4(17))\n+      No_Allocators,                           -- (RM H.4(7))\n+      No_Allocators_After_Elaboration,         -- Ada 2012 (RM D.7(19.1/2))\n+      No_Anonymous_Allocators,                 -- Ada 2012 (RM H.4(8/1))\n+      No_Asynchronous_Control,                 -- (RM D.7(10))\n+      No_Calendar,                             -- GNAT\n+      No_Default_Stream_Attributes,            -- Ada 2012 (RM 13.12.1(4/2))\n+      No_Delay,                                -- (RM H.4(21))\n+      No_Direct_Boolean_Operators,             -- GNAT\n+      No_Dispatch,                             -- (RM H.4(19))\n+      No_Dispatching_Calls,                    -- GNAT\n+      No_Dynamic_Attachment,                   -- GNAT\n+      No_Dynamic_Priorities,                   -- (RM D.9(9))\n+      No_Enumeration_Maps,                     -- GNAT\n+      No_Entry_Calls_In_Elaboration_Code,      -- GNAT\n+      No_Entry_Queue,                          -- GNAT (Ravenscar)\n+      No_Exception_Handlers,                   -- GNAT\n+      No_Exception_Propagation,                -- GNAT\n+      No_Exception_Registration,               -- GNAT\n+      No_Exceptions,                           -- (RM H.4(12))\n+      No_Finalization,                         -- GNAT\n+      No_Fixed_Point,                          -- (RM H.4(15))\n+      No_Floating_Point,                       -- (RM H.4(14))\n+      No_IO,                                   -- (RM H.4(20))\n+      No_Implicit_Conditionals,                -- GNAT\n+      No_Implicit_Dynamic_Code,                -- GNAT\n+      No_Implicit_Heap_Allocations,            -- (RM D.8(8), H.4(3))\n+      No_Implicit_Loops,                       -- GNAT\n+      No_Initialize_Scalars,                   -- GNAT\n+      No_Local_Allocators,                     -- (RM H.4(8))\n+      No_Local_Timing_Events,                  -- (RM D.7(10.2/2))\n+      No_Local_Protected_Objects,              -- GNAT\n+      No_Nested_Finalization,                  -- (RM D.7(4))\n+      No_Protected_Type_Allocators,            -- GNAT\n+      No_Protected_Types,                      -- (RM H.4(5))\n+      No_Recursion,                            -- (RM H.4(22))\n+      No_Reentrancy,                           -- (RM H.4(23))\n+      No_Relative_Delay,                       -- GNAT (Ravenscar)\n+      No_Requeue_Statements,                   -- GNAT\n+      No_Secondary_Stack,                      -- GNAT\n+      No_Select_Statements,                    -- GNAT (Ravenscar)\n+      No_Specific_Termination_Handlers,        -- (RM D.7(10.7/2))\n+      No_Standard_Storage_Pools,               -- GNAT\n+      No_Stream_Optimizations,                 -- GNAT\n+      No_Streams,                              -- GNAT\n+      No_Task_Allocators,                      -- (RM D.7(7))\n+      No_Task_Attributes_Package,              -- GNAT\n+      No_Task_Hierarchy,                       -- (RM D.7(3), H.4(3))\n+      No_Task_Termination,                     -- GNAT (Ravenscar)\n+      No_Tasking,                              -- GNAT\n+      No_Terminate_Alternatives,               -- (RM D.7(6))\n+      No_Unchecked_Access,                     -- (RM H.4(18))\n+      No_Unchecked_Conversion,                 -- (RM H.4(16))\n+      No_Unchecked_Deallocation,               -- (RM H.4(9))\n+      Static_Priorities,                       -- GNAT\n+      Static_Storage_Size,                     -- GNAT\n+\n+      --  The following require consistency checking with special rules. See\n+      --  individual routines in unit Bcheck for details of what is required.\n+\n+      No_Default_Initialization,               -- GNAT\n+\n+      --  The following cases do not require consistency checking and if used\n+      --  as a configuration pragma within a specific unit, apply only to that\n+      --  unit (e.g. if used in the package spec, do not apply to the body)\n+\n+      --  Note: No_Elaboration_Code is handled specially. Like the other\n+      --  non-partition-wide restrictions, it can only be set in a unit that\n+      --  is part of the extended main source unit (body/spec/subunits). But\n+      --  it is sticky, in that if it is found anywhere within any of these\n+      --  units, it applies to all units in this extended main source.\n+\n+      Immediate_Reclamation,                   -- (RM H.4(10))\n+      No_Implementation_Aspect_Specifications, -- Ada 2012 AI-241\n+      No_Implementation_Attributes,            -- Ada 2005 AI-257\n+      No_Implementation_Identifiers,           -- Ada 2012 AI-246\n+      No_Implementation_Pragmas,               -- Ada 2005 AI-257\n+      No_Implementation_Restrictions,          -- GNAT\n+      No_Implementation_Units,                 -- Ada 2012 AI-242\n+      No_Implicit_Aliasing,                    -- GNAT\n+      No_Elaboration_Code,                     -- GNAT\n+      No_Obsolescent_Features,                 -- Ada 2005 AI-368\n+      No_Wide_Characters,                      -- GNAT\n+      SPARK,                                   -- GNAT\n+\n+      --  The following cases require a parameter value\n+\n+      --  The following entries are fully checked at compile/bind time, which\n+      --  means that the compiler can in general tell the minimum value which\n+      --  could be used with a restrictions pragma. The binder can deduce the\n+      --  appropriate minimum value for the partition by taking the maximum\n+      --  value required by any unit.\n+\n+      Max_Protected_Entries,                   -- (RM D.7(14))\n+      Max_Select_Alternatives,                 -- (RM D.7(12))\n+      Max_Task_Entries,                        -- (RM D.7(13), H.4(3))\n+\n+      --  The following entries are also fully checked at compile/bind time,\n+      --  and the compiler can also at least in some cases tell the minimum\n+      --  value which could be used with a restriction pragma. The difference\n+      --  is that the contributions are additive, so the binder deduces this\n+      --  value by adding the unit contributions.\n+\n+      Max_Tasks,                               -- (RM D.7(19), H.4(3))\n+\n+      --  The following entries are checked at compile time only for zero/\n+      --  nonzero entries. This means that the compiler can tell at compile\n+      --  time if a restriction value of zero is (would be) violated, but that\n+      --  the compiler cannot distinguish between different non-zero values.\n+\n+      Max_Asynchronous_Select_Nesting,         -- (RM D.7(18), H.4(3))\n+      Max_Entry_Queue_Length,                  -- GNAT\n+\n+      --  The remaining entries are not checked at compile/bind time\n+\n+      Max_Storage_At_Blocking,                 -- (RM D.7(17))\n+\n+      Not_A_Restriction_Id);\n+\n+   --  Synonyms permitted for historical purposes of compatibility.\n+   --  Must be coordinated with Restrict.Process_Restriction_Synonym.\n+\n+   Boolean_Entry_Barriers : Restriction_Id renames Simple_Barriers;\n+   Max_Entry_Queue_Depth  : Restriction_Id renames Max_Entry_Queue_Length;\n+   No_Dynamic_Interrupts  : Restriction_Id renames No_Dynamic_Attachment;\n+   No_Requeue             : Restriction_Id renames No_Requeue_Statements;\n+   No_Task_Attributes     : Restriction_Id renames No_Task_Attributes_Package;\n+\n+   subtype All_Restrictions is Restriction_Id range\n+     Simple_Barriers .. Max_Storage_At_Blocking;\n+   --  All restrictions (excluding only Not_A_Restriction_Id)\n+\n+   subtype All_Boolean_Restrictions is Restriction_Id range\n+     Simple_Barriers .. SPARK;\n+   --  All restrictions which do not take a parameter\n+\n+   subtype Partition_Boolean_Restrictions is All_Boolean_Restrictions range\n+     Simple_Barriers .. Static_Storage_Size;\n+   --  Boolean restrictions that are checked for partition consistency.\n+   --  Note that all parameter restrictions are checked for partition\n+   --  consistency by default, so this distinction is only needed in the\n+   --  case of Boolean restrictions.\n+\n+   subtype Cunit_Boolean_Restrictions is All_Boolean_Restrictions range\n+     Immediate_Reclamation .. SPARK;\n+   --  Boolean restrictions that are not checked for partition consistency\n+   --  and that thus apply only to the current unit. Note that for these\n+   --  restrictions, the compiler does not apply restrictions found in\n+   --  with'ed units, parent specs etc. to the main unit, and vice versa.\n+\n+   subtype All_Parameter_Restrictions is\n+     Restriction_Id range\n+       Max_Protected_Entries .. Max_Storage_At_Blocking;\n+   --  All restrictions that take a parameter\n+\n+   subtype Checked_Parameter_Restrictions is\n+     All_Parameter_Restrictions range\n+       Max_Protected_Entries .. Max_Entry_Queue_Length;\n+   --  These are the parameter restrictions that can be at least partially\n+   --  checked at compile/binder time. Minimally, the compiler can detect\n+   --  violations of a restriction pragma with a value of zero reliably.\n+\n+   subtype Checked_Max_Parameter_Restrictions is\n+     Checked_Parameter_Restrictions range\n+       Max_Protected_Entries .. Max_Task_Entries;\n+   --  Restrictions with parameters that can be checked in some cases by\n+   --  maximizing among statically detected instances where the compiler\n+   --  can determine the count.\n+\n+   subtype Checked_Add_Parameter_Restrictions is\n+     Checked_Parameter_Restrictions range\n+       Max_Tasks .. Max_Tasks;\n+   --  Restrictions with parameters that can be checked in some cases by\n+   --  summing the statically detected instances where the compiler can\n+   --  determine the count.\n+\n+   subtype Checked_Val_Parameter_Restrictions is\n+     Checked_Parameter_Restrictions range\n+       Max_Protected_Entries .. Max_Tasks;\n+   --  Restrictions with parameter where the count is known at least in some\n+   --  cases by the compiler/binder.\n+\n+   subtype Checked_Zero_Parameter_Restrictions is\n+     Checked_Parameter_Restrictions range\n+       Max_Asynchronous_Select_Nesting .. Max_Entry_Queue_Length;\n+   --  Restrictions with parameters where the compiler can detect the use of\n+   --  the feature, and hence violations of a restriction specifying a value\n+   --  of zero, but cannot detect specific values other than zero/nonzero.\n+\n+   subtype Unchecked_Parameter_Restrictions is\n+     All_Parameter_Restrictions range\n+       Max_Storage_At_Blocking .. Max_Storage_At_Blocking;\n+   --  Restrictions with parameters where the compiler cannot ever detect\n+   --  corresponding compile time usage, so the binder and compiler never\n+   --  detect violations of any restriction.\n+\n+   -------------------------------------\n+   -- Restriction Status Declarations --\n+   -------------------------------------\n+\n+   --  The following declarations are used to record the current status or\n+   --  restrictions (for the current unit, or related units, at compile time,\n+   --  and for all units in a partition at bind time or run time).\n+\n+   type Restriction_Flags  is array (All_Restrictions)           of Boolean;\n+   type Restriction_Values is array (All_Parameter_Restrictions) of Natural;\n+   type Parameter_Flags    is array (All_Parameter_Restrictions) of Boolean;\n+\n+   type Restrictions_Info is record\n+      Set : Restriction_Flags;\n+      --  An entry is True in the Set array if a restrictions pragma has been\n+      --  encountered for the given restriction. If the value is True for a\n+      --  parameter restriction, then the corresponding entry in the Value\n+      --  array gives the minimum value encountered for any such restriction.\n+\n+      Value : Restriction_Values;\n+      --  If the entry for a parameter restriction in Set is True (i.e. a\n+      --  restrictions pragma for the restriction has been encountered), then\n+      --  the corresponding entry in the Value array is the minimum value\n+      --  specified by any such restrictions pragma. Note that a restrictions\n+      --  pragma specifying a value greater than Int'Last is simply ignored.\n+\n+      Violated : Restriction_Flags;\n+      --  An entry is True in the violations array if the compiler has detected\n+      --  a violation of the restriction. For a parameter restriction, the\n+      --  Count and Unknown arrays have additional information.\n+\n+      Count : Restriction_Values;\n+      --  If an entry for a parameter restriction is True in Violated, the\n+      --  corresponding entry in the Count array may record additional\n+      --  information. If the actual minimum count is known (by taking\n+      --  maximums, or sums, depending on the restriction), it will be\n+      --  recorded in this array. If not, then the value will remain zero.\n+      --  The value is also zero for a non-violated restriction.\n+\n+      Unknown : Parameter_Flags;\n+      --  If an entry for a parameter restriction is True in Violated, the\n+      --  corresponding entry in the Unknown array may record additional\n+      --  information. If the actual count is not known by the compiler (but\n+      --  is known to be non-zero), then the entry in Unknown will be True.\n+      --  This indicates that the value in Count is not known to be exact,\n+      --  and the actual violation count may be higher.\n+\n+      --  Note: If Violated (K) is True, then either Count (K) > 0 or\n+      --  Unknown (K) = True. It is possible for both these to be set.\n+      --  For example, if Count (K) = 3 and Unknown (K) is True, it means\n+      --  that the actual violation count is at least 3 but might be higher.\n+   end record;\n+\n+   No_Restrictions : constant Restrictions_Info :=\n+     (Set      => (others => False),\n+      Value    => (others => 0),\n+      Violated => (others => False),\n+      Count    => (others => 0),\n+      Unknown  => (others => False));\n+   --  Used to initialize Restrictions_Info variables\n+\n+   ----------------------------------\n+   -- Profile Definitions and Data --\n+   ----------------------------------\n+\n+   --  Note: to add a profile, modify the following declarations appropriately,\n+   --  add Name_xxx to Snames, and add a branch to the conditions for pragmas\n+   --  Profile and Profile_Warnings in the body of Sem_Prag.\n+\n+   type Profile_Name is\n+     (No_Profile,\n+      No_Implementation_Extensions,\n+      Ravenscar,\n+      Restricted);\n+   --  Names of recognized profiles. No_Profile is used to indicate that a\n+   --  restriction came from pragma Restrictions[_Warning], as opposed to\n+   --  pragma Profile[_Warning].\n+\n+   subtype Profile_Name_Actual is Profile_Name\n+     range No_Implementation_Extensions .. Restricted;\n+   --  Actual used profile names\n+\n+   type Profile_Data is record\n+      Set : Restriction_Flags;\n+      --  Set to True if given restriction must be set for the profile, and\n+      --  False if it need not be set (False does not mean that it must not be\n+      --  set, just that it need not be set). If the flag is True for a\n+      --  parameter restriction, then the Value array gives the maximum value\n+      --  permitted by the profile.\n+\n+      Value : Restriction_Values;\n+      --  An entry in this array is meaningful only if the corresponding flag\n+      --  in Set is True. In that case, the value in this array is the maximum\n+      --  value of the parameter permitted by the profile.\n+   end record;\n+\n+   Profile_Info : constant array (Profile_Name_Actual) of Profile_Data :=\n+\n+                    (No_Implementation_Extensions =>\n+                        --  Restrictions for Restricted profile\n+\n+                       (Set   =>\n+                          (No_Implementation_Aspect_Specifications => True,\n+                           No_Implementation_Attributes            => True,\n+                           No_Implementation_Identifiers           => True,\n+                           No_Implementation_Pragmas               => True,\n+                           No_Implementation_Units                 => True,\n+                           others                                  => False),\n+\n+                        --  Value settings for Restricted profile (none\n+\n+                        Value =>\n+                          (others                          => 0)),\n+\n+                     --  Restricted Profile\n+\n+                     Restricted =>\n+\n+                        --  Restrictions for Restricted profile\n+\n+                       (Set   =>\n+                          (No_Abort_Statements             => True,\n+                           No_Asynchronous_Control         => True,\n+                           No_Dynamic_Attachment           => True,\n+                           No_Dynamic_Priorities           => True,\n+                           No_Entry_Queue                  => True,\n+                           No_Local_Protected_Objects      => True,\n+                           No_Protected_Type_Allocators    => True,\n+                           No_Requeue_Statements           => True,\n+                           No_Task_Allocators              => True,\n+                           No_Task_Attributes_Package      => True,\n+                           No_Task_Hierarchy               => True,\n+                           No_Terminate_Alternatives       => True,\n+                           Max_Asynchronous_Select_Nesting => True,\n+                           Max_Protected_Entries           => True,\n+                           Max_Select_Alternatives         => True,\n+                           Max_Task_Entries                => True,\n+                           others                          => False),\n+\n+                        --  Value settings for Restricted profile\n+\n+                        Value =>\n+                          (Max_Asynchronous_Select_Nesting => 0,\n+                           Max_Protected_Entries           => 1,\n+                           Max_Select_Alternatives         => 0,\n+                           Max_Task_Entries                => 0,\n+                           others                          => 0)),\n+\n+                     --  Ravenscar Profile\n+\n+                     --  Note: the table entries here only represent the\n+                     --  required restriction profile for Ravenscar. The\n+                     --  full Ravenscar profile also requires:\n+\n+                     --    pragma Dispatching_Policy (FIFO_Within_Priorities);\n+                     --    pragma Locking_Policy (Ceiling_Locking);\n+                     --    pragma Detect_Blocking\n+\n+                     Ravenscar  =>\n+\n+                     --  Restrictions for Ravenscar = Restricted profile ..\n+\n+                       (Set   =>\n+                          (No_Abort_Statements             => True,\n+                           No_Asynchronous_Control         => True,\n+                           No_Dynamic_Attachment           => True,\n+                           No_Dynamic_Priorities           => True,\n+                           No_Entry_Queue                  => True,\n+                           No_Local_Protected_Objects      => True,\n+                           No_Protected_Type_Allocators    => True,\n+                           No_Requeue_Statements           => True,\n+                           No_Task_Allocators              => True,\n+                           No_Task_Attributes_Package      => True,\n+                           No_Task_Hierarchy               => True,\n+                           No_Terminate_Alternatives       => True,\n+                           Max_Asynchronous_Select_Nesting => True,\n+                           Max_Protected_Entries           => True,\n+                           Max_Select_Alternatives         => True,\n+                           Max_Task_Entries                => True,\n+\n+                           --  plus these additional restrictions:\n+\n+                           No_Calendar                     => True,\n+                           No_Implicit_Heap_Allocations    => True,\n+                           No_Relative_Delay               => True,\n+                           No_Select_Statements            => True,\n+                           No_Task_Termination             => True,\n+                           Simple_Barriers                 => True,\n+                           others                          => False),\n+\n+                        --  Value settings for Ravenscar (same as Restricted)\n+\n+                        Value =>\n+                          (Max_Asynchronous_Select_Nesting => 0,\n+                           Max_Protected_Entries           => 1,\n+                           Max_Select_Alternatives         => 0,\n+                           Max_Task_Entries                => 0,\n+                           others                          => 0)));\n+\n+end Rident;"}, {"sha": "9848cb82c82c272336fe83446551da8bea69f9f4", "filename": "gcc/ada/s-os_lib.ads", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22a83cea153e34e826ed42afd56334be89a9ad8e/gcc%2Fada%2Fs-os_lib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22a83cea153e34e826ed42afd56334be89a9ad8e/gcc%2Fada%2Fs-os_lib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-os_lib.ads?ref=22a83cea153e34e826ed42afd56334be89a9ad8e", "patch": "@@ -54,7 +54,6 @@ with System;\n with System.Strings;\n \n package System.OS_Lib is\n-   pragma Elaborate_Body (OS_Lib);\n    pragma Preelaborate;\n \n    -----------------------"}, {"sha": "8b38ad8b635ec74176be43a1441199b45bf5b2ce", "filename": "gcc/ada/s-taprop-mingw.adb", "status": "modified", "additions": 10, "deletions": 39, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22a83cea153e34e826ed42afd56334be89a9ad8e/gcc%2Fada%2Fs-taprop-mingw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22a83cea153e34e826ed42afd56334be89a9ad8e/gcc%2Fada%2Fs-taprop-mingw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-mingw.adb?ref=22a83cea153e34e826ed42afd56334be89a9ad8e", "patch": "@@ -716,57 +716,28 @@ package body System.Task_Primitives.Operations is\n    -- Set_Priority --\n    ------------------\n \n-   type Prio_Array_Type is array (System.Any_Priority) of Integer;\n-   pragma Atomic_Components (Prio_Array_Type);\n-\n-   Prio_Array : Prio_Array_Type;\n-   --  Global array containing the id of the currently running task for\n-   --  each priority.\n-   --\n-   --  Note: we assume that we are on a single processor with run-til-blocked\n-   --  scheduling.\n-\n    procedure Set_Priority\n      (T                   : Task_Id;\n       Prio                : System.Any_Priority;\n       Loss_Of_Inheritance : Boolean := False)\n    is\n-      Res        : BOOL;\n-      Array_Item : Integer;\n+      Res : BOOL;\n+      pragma Unreferenced (Loss_Of_Inheritance);\n \n    begin\n       Res := SetThreadPriority\n         (T.Common.LL.Thread, Interfaces.C.int (Underlying_Priorities (Prio)));\n       pragma Assert (Res = Win32.TRUE);\n \n-      if Dispatching_Policy = 'F' or else Get_Policy (Prio) = 'F' then\n-\n-         --  Annex D requirement [RM D.2.2 par. 9]:\n-         --    If the task drops its priority due to the loss of inherited\n-         --    priority, it is added at the head of the ready queue for its\n-         --    new active priority.\n-\n-         if Loss_Of_Inheritance\n-           and then Prio < T.Common.Current_Priority\n-         then\n-            Array_Item := Prio_Array (T.Common.Base_Priority) + 1;\n-            Prio_Array (T.Common.Base_Priority) := Array_Item;\n-\n-            loop\n-               --  Let some processes a chance to arrive\n-\n-               Yield;\n+      --  Note: Annex D (RM D.2.3(5/2)) requires the task to be placed at the\n+      --  head of its priority queue when decreasing its priority as a result\n+      --  of a loss of inherited priority. This is not the case, but we\n+      --  consider it an acceptable variation (RM 1.1.3(6)), given this is the\n+      --  built-in behavior offered by the Windows operating system.\n \n-               --  Then wait for our turn to proceed\n-\n-               exit when Array_Item = Prio_Array (T.Common.Base_Priority)\n-                 or else Prio_Array (T.Common.Base_Priority) = 1;\n-            end loop;\n-\n-            Prio_Array (T.Common.Base_Priority) :=\n-              Prio_Array (T.Common.Base_Priority) - 1;\n-         end if;\n-      end if;\n+      --  In older versions we attempted to better approximate the Annex D\n+      --  required behavior, but this simulation was not entirely accurate,\n+      --  and it seems better to live with the standard Windows semantics.\n \n       T.Common.Current_Priority := Prio;\n    end Set_Priority;"}, {"sha": "e475000a758af109b31aa107e8e6335c6cc1d5b2", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22a83cea153e34e826ed42afd56334be89a9ad8e/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22a83cea153e34e826ed42afd56334be89a9ad8e/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=22a83cea153e34e826ed42afd56334be89a9ad8e", "patch": "@@ -7735,6 +7735,18 @@ package body Sem_Ch13 is\n    begin\n       Biased := False;\n \n+      --  Reject patently improper size values.\n+\n+      if Is_Scalar_Type (T)\n+        and then Siz > UI_From_Int (Int'Last)\n+      then\n+         Error_Msg_N (\"Size value too large for scalar type\", N);\n+         if Nkind (Original_Node (N)) = N_Op_Expon then\n+            Error_Msg_N\n+              (\"\\maybe '* was meant, rather than '*'*\", Original_Node (N));\n+         end if;\n+      end if;\n+\n       --  Dismiss cases for generic types or types with previous errors\n \n       if No (UT)"}, {"sha": "d85f2798c2f2f6eaa8349ab2fe309869b830cb82", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 206, "deletions": 174, "changes": 380, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22a83cea153e34e826ed42afd56334be89a9ad8e/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22a83cea153e34e826ed42afd56334be89a9ad8e/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=22a83cea153e34e826ed42afd56334be89a9ad8e", "patch": "@@ -139,87 +139,69 @@ package body Sem_Ch9 is\n             Priv_Decls : constant List_Id := Private_Declarations (Pdef);\n             Vis_Decls  : constant List_Id := Visible_Declarations (Pdef);\n \n-            Comp_Id    : Entity_Id;\n-            Comp_Size  : Int;\n-            Comp_Type  : Entity_Id;\n-            Decl       : Node_Id;\n+            Decl : Node_Id;\n \n          begin\n-            --  Examine the visible declarations. Entries and entry families\n-            --  are not allowed by the lock-free restrictions.\n+            --  Examine the visible and the private declarations\n \n             Decl := First (Vis_Decls);\n             while Present (Decl) loop\n+\n+               --  Entries and entry families are not allowed by the lock-free\n+               --  restrictions.\n+\n                if Nkind (Decl) = N_Entry_Declaration then\n                   if Complain then\n-                     Error_Msg_N (\"entry not allowed for lock-free \" &\n-                                  \"implementation\",\n+                     Error_Msg_N (\"entry not allowed when Lock_Free given\",\n                                   Decl);\n                   end if;\n \n                   return False;\n-               end if;\n-\n-               Next (Decl);\n-            end loop;\n-\n-            --  Examine the private declarations\n-\n-            Decl := First (Priv_Decls);\n-            while Present (Decl) loop\n-\n-               --  The protected type must define at least one scalar component\n-\n-               if Nkind (Decl) = N_Component_Declaration then\n-                  Comp_Id       := Defining_Identifier (Decl);\n-                  Comp_Type     := Etype (Comp_Id);\n \n-                  --  Make sure the protected component type has size and\n-                  --  alignment fields set at this point whenever this is\n-                  --  possible.\n+               --  Non-elementary out parameters in protected procedure are not\n+               --  allowed by the lock-free restrictions.\n \n-                  Layout_Type (Comp_Type);\n-\n-                  if Known_Esize (Comp_Type) then\n-                     Comp_Size := UI_To_Int (Esize (Comp_Type));\n-\n-                  --  If the Esize (Object_Size) is unknown at compile-time,\n-                  --  look at the RM_Size (Value_Size) since it may have been\n-                  --  set by an explicit representation clause.\n-\n-                  else\n-                     Comp_Size := UI_To_Int (RM_Size (Comp_Type));\n-                  end if;\n-\n-                  --  Check that the size of the component is 8, 16, 32 or 64\n-                  --  bits.\n+               elsif Nkind (Decl) = N_Subprogram_Declaration\n+                 and then Nkind (Specification (Decl)) =\n+                            N_Procedure_Specification\n+                 and then Present\n+                            (Parameter_Specifications (Specification (Decl)))\n+               then\n+                  declare\n+                     Par_Specs : constant List_Id   :=\n+                                   Parameter_Specifications\n+                                     (Specification (Decl));\n+                     Par       : constant Node_Id   := First (Par_Specs);\n+                     Par_Typ   : constant Entity_Id :=\n+                                   Etype (Parameter_Type (Par));\n \n-                  case Comp_Size is\n-                     when 8 | 16 | 32 | 64 =>\n-                        null;\n-                     when others           =>\n+                  begin\n+                     if Out_Present (Par)\n+                       and then not Is_Elementary_Type (Par_Typ)\n+                     then\n                         if Complain then\n-                           Error_Msg_N (\"must support atomic operations for \" &\n-                                        \"lock-free implementation\",\n-                                         Decl);\n+                           Error_Msg_NE\n+                             (\"non-elementary out parameter& not allowed \" &\n+                              \"when Lock_Free given\",\n+                              Par,\n+                              Defining_Identifier (Par));\n                         end if;\n \n                         return False;\n-                  end case;\n-\n-               --  Entries and entry families are not allowed\n+                     end if;\n+                  end;\n+               end if;\n \n-               elsif Nkind (Decl) = N_Entry_Declaration then\n-                  if Complain then\n-                     Error_Msg_N (\"entry not allowed for lock-free \" &\n-                                  \"implementation\",\n-                                  Decl);\n-                  end if;\n+               --  Examine the private declarations after the visible\n+               --  declarations.\n \n-                  return False;\n+               if No (Next (Decl))\n+                 and then List_Containing (Decl) = Vis_Decls\n+               then\n+                  Decl := First (Priv_Decls);\n+               else\n+                  Next (Decl);\n                end if;\n-\n-               Next (Decl);\n             end loop;\n          end;\n \n@@ -248,6 +230,11 @@ package body Sem_Ch9 is\n             function Satisfies_Lock_Free_Requirements\n               (Sub_Body : Node_Id) return Boolean\n             is\n+               Is_Procedure : constant Boolean    :=\n+                                Ekind (Corresponding_Spec (Sub_Body)) =\n+                                  E_Procedure;\n+               --  Indicates if Sub_Body is a procedure body\n+\n                Comp : Entity_Id := Empty;\n                --  Track the current component which the body references\n \n@@ -260,152 +247,160 @@ package body Sem_Ch9 is\n \n                function Check_Node (N : Node_Id) return Traverse_Result is\n                begin\n-                  --  Function calls and attribute references must be static\n+                  if Is_Procedure then\n+                     --  Function calls and attribute references must be static\n \n-                  if Nkind (N) = N_Attribute_Reference\n-                    and then not Is_Static_Expression (N)\n-                  then\n-                     if Complain then\n-                        Error_Msg_N\n-                          (\"non-static attribute reference not allowed\",\n-                           N);\n-                     end if;\n+                     if Nkind (N) = N_Attribute_Reference\n+                       and then not Is_Static_Expression (N)\n+                     then\n+                        if Complain then\n+                           Error_Msg_N\n+                             (\"non-static attribute reference not allowed\", N);\n+                        end if;\n \n-                     return Abandon;\n+                        return Abandon;\n \n-                  elsif Nkind (N) = N_Function_Call\n-                    and then not Is_Static_Expression (N)\n-                  then\n-                     if Complain then\n-                        Error_Msg_N (\"non-static function call not allowed\",\n-                                     N);\n-                     end if;\n+                     elsif Nkind (N) = N_Function_Call\n+                       and then not Is_Static_Expression (N)\n+                     then\n+                        if Complain then\n+                           Error_Msg_N (\"non-static function call not allowed\",\n+                                        N);\n+                        end if;\n \n-                     return Abandon;\n+                        return Abandon;\n \n-                  --  Loop statements and procedure calls are prohibited\n+                     --  Loop statements and procedure calls are prohibited\n \n-                  elsif Nkind (N) = N_Loop_Statement then\n-                     if Complain then\n-                        Error_Msg_N (\"loop not allowed\", N);\n-                     end if;\n+                     elsif Nkind (N) = N_Loop_Statement then\n+                        if Complain then\n+                           Error_Msg_N (\"loop not allowed\", N);\n+                        end if;\n \n-                     return Abandon;\n+                        return Abandon;\n \n-                  elsif Nkind (N) = N_Procedure_Call_Statement then\n-                     if Complain then\n-                        Error_Msg_N (\"procedure call not allowed\", N);\n-                     end if;\n+                     elsif Nkind (N) = N_Procedure_Call_Statement then\n+                        if Complain then\n+                           Error_Msg_N (\"procedure call not allowed\", N);\n+                        end if;\n+\n+                        return Abandon;\n+\n+                     --  References\n+\n+                     elsif Nkind (N) = N_Identifier\n+                       and then Present (Entity (N))\n+                     then\n+                        declare\n+                           Id     : constant Entity_Id := Entity (N);\n+                           Sub_Id : constant Entity_Id :=\n+                                      Corresponding_Spec (Sub_Body);\n+\n+                        begin\n+                           --  Prohibit references to non-constant entities\n+                           --  outside the protected subprogram scope.\n+\n+                           if Ekind (Id) in Assignable_Kind\n+                             and then not Scope_Within_Or_Same (Scope (Id),\n+                                            Sub_Id)\n+                             and then not Scope_Within_Or_Same (Scope (Id),\n+                                            Protected_Body_Subprogram (Sub_Id))\n+                           then\n+                              if Complain then\n+                                 Error_Msg_NE\n+                                   (\"reference to global variable& not \" &\n+                                    \"allowed\", N, Id);\n+                              end if;\n \n-                     return Abandon;\n+                              return Abandon;\n+                           end if;\n+                        end;\n+                     end if;\n+                  end if;\n \n-                  --  References\n+                  --  A protected subprogram (function or procedure) may\n+                  --  reference only one component of the protected type, plus\n+                  --  the type of the component must support atomic operation.\n \n-                  elsif Nkind (N) = N_Identifier\n+                  if Nkind (N) = N_Identifier\n                     and then Present (Entity (N))\n                   then\n                      declare\n-                        Id     : constant Entity_Id := Entity (N);\n-                        Sub_Id : constant Entity_Id :=\n-                                   Corresponding_Spec (Sub_Body);\n+                        Id        : constant Entity_Id := Entity (N);\n+                        Comp_Decl : Node_Id;\n+                        Comp_Id   : Entity_Id := Empty;\n+                        Comp_Size : Int;\n+                        Comp_Type : Entity_Id;\n \n                      begin\n-                        --  Prohibit references to non-constant entities\n-                        --  outside the protected subprogram scope.\n-\n-                        if Ekind (Id) in Assignable_Kind\n-                          and then not Scope_Within_Or_Same (Scope (Id),\n-                                         Sub_Id)\n-                          and then not Scope_Within_Or_Same (Scope (Id),\n-                                         Protected_Body_Subprogram (Sub_Id))\n+                        if Ekind (Id) = E_Component then\n+                           Comp_Id := Id;\n+\n+                        elsif Ekind_In (Id, E_Constant, E_Variable)\n+                          and then Present (Prival_Link (Id))\n                         then\n-                           if Complain then\n-                              Error_Msg_NE\n-                                (\"reference to global variable& not allowed\",\n-                                 N, Id);\n-                           end if;\n+                           Comp_Id := Prival_Link (Id);\n+                        end if;\n \n-                           return Abandon;\n+                        if Present (Comp_Id) then\n+                           Comp_Decl := Parent (Comp_Id);\n+                           Comp_Type := Etype (Comp_Id);\n \n-                        --  Prohibit non-scalar out parameters (scalar\n-                        --  parameters are passed by copy).\n+                           if Nkind (Comp_Decl) = N_Component_Declaration\n+                             and then Is_List_Member (Comp_Decl)\n+                             and then List_Containing (Comp_Decl) = Priv_Decls\n+                           then\n+                              --  Make sure the protected component type has\n+                              --  size and alignment fields set at this point\n+                              --  whenever this is possible.\n \n-                        elsif Ekind_In (Id, E_Out_Parameter,\n-                                            E_In_Out_Parameter)\n-                          and then not Is_Elementary_Type (Etype (Id))\n-                          and then Scope_Within_Or_Same (Scope (Id), Sub_Id)\n-                        then\n-                           if Complain then\n-                              Error_Msg_NE\n-                                (\"non-elementary out parameter& not allowed\",\n-                                 N, Id);\n-                           end if;\n+                              Layout_Type (Comp_Type);\n \n-                           return Abandon;\n+                              if Known_Esize (Comp_Type) then\n+                                 Comp_Size := UI_To_Int (Esize (Comp_Type));\n \n-                        --  A protected subprogram may reference only one\n-                        --  component of the protected type.\n+                              --  If the Esize (Object_Size) is unknown at\n+                              --  compile-time, look at the RM_Size\n+                              --  (Value_Size) since it may have been set by an\n+                              --  explicit representation clause.\n \n-                        elsif Ekind (Id) = E_Component then\n-                           declare\n-                              Comp_Decl : constant Node_Id := Parent (Id);\n-                           begin\n-                              if Nkind (Comp_Decl) = N_Component_Declaration\n-                                and then Is_List_Member (Comp_Decl)\n-                                and then List_Containing (Comp_Decl) =\n-                                           Priv_Decls\n-                              then\n-                                 if No (Comp) then\n-                                    Comp := Id;\n+                              else\n+                                 Comp_Size := UI_To_Int (RM_Size (Comp_Type));\n+                              end if;\n \n-                                 --  Check if another protected component has\n-                                 --  already been accessed by the subprogram\n-                                 --  body.\n+                              --  Check that the size of the component is 8,\n+                              --  16, 32 or 64 bits.\n \n-                                 elsif Comp /= Id then\n+                              case Comp_Size is\n+                                 when 8 | 16 | 32 | 64 =>\n+                                    null;\n+                                 when others           =>\n                                     if Complain then\n-                                       Error_Msg_N\n-                                         (\"only one protected component \" &\n-                                          \"allowed\",\n-                                          N);\n+                                       Error_Msg_NE\n+                                         (\"type of& must support atomic \" &\n+                                          \"operations\",\n+                                          N, Comp_Id);\n                                     end if;\n \n                                     return Abandon;\n-                                 end if;\n-                              end if;\n-                           end;\n+                              end case;\n \n-                        elsif Ekind_In (Id, E_Constant, E_Variable)\n-                          and then Present (Prival_Link (Id))\n-                        then\n-                           declare\n-                              Comp_Decl : constant Node_Id :=\n-                                            Parent (Prival_Link (Id));\n-                           begin\n-                              if Nkind (Comp_Decl) = N_Component_Declaration\n-                                and then Is_List_Member (Comp_Decl)\n-                                and then List_Containing (Comp_Decl) =\n-                                           Priv_Decls\n-                              then\n-                                 if No (Comp) then\n-                                    Comp := Prival_Link (Id);\n-\n-                                 --  Check if another protected component has\n-                                 --  already been accessed by the subprogram\n-                                 --  body.\n-\n-                                 elsif Comp /= Prival_Link (Id) then\n-                                    if Complain then\n-                                       Error_Msg_N\n-                                         (\"only one protected component \" &\n-                                          \"allowed\",\n-                                          N);\n-                                    end if;\n+                              --  Check if another protected component has\n+                              --  already been accessed by the subprogram body.\n \n-                                    return Abandon;\n+                              if No (Comp) then\n+                                 Comp := Id;\n+\n+                              elsif Comp /= Id then\n+                                 if Complain then\n+                                    Error_Msg_N\n+                                      (\"only one protected component allowed\",\n+                                       N);\n                                  end if;\n+\n+                                 return Abandon;\n                               end if;\n-                           end;\n+                           end if;\n                         end if;\n                      end;\n                   end if;\n@@ -444,7 +439,7 @@ package body Sem_Ch9 is\n                  and then not Satisfies_Lock_Free_Requirements (Decl)\n                then\n                   if Complain then\n-                     Error_Msg_N (\"body prevents lock-free implementation\",\n+                     Error_Msg_N (\"body not allowed when Lock_Free given\",\n                                   Decl);\n                   end if;\n \n@@ -1787,6 +1782,43 @@ package body Sem_Ch9 is\n       --  issued by Allows_Lock_Free_Implementation.\n \n       if Uses_Lock_Free (Defining_Identifier (N)) then\n+         --  Complain when there is an explicit aspect/pragma Priority (or\n+         --  Interrupt_Priority) while the lock-free implementation is forced\n+         --  by an aspect/pragma.\n+\n+         declare\n+            Id        : constant Entity_Id :=\n+                          Defining_Identifier (Original_Node (N));\n+            --  The warning must be issued on the original identifier in order\n+            --  to deal properly with the case of a single protected object.\n+\n+            Prio_Item : constant Node_Id :=\n+                          Get_Rep_Item\n+                            (Defining_Identifier (N),\n+                             Name_Priority,\n+                             Check_Parents => False);\n+\n+         begin\n+            if Present (Prio_Item) then\n+               --  Aspect case\n+\n+               if Nkind (Prio_Item) = N_Aspect_Specification\n+                 or else From_Aspect_Specification (Prio_Item)\n+               then\n+                  Error_Msg_Name_1 := Chars (Identifier (Prio_Item));\n+                  Error_Msg_NE (\"?aspect% for & has no effect when Lock_Free\" &\n+                                \" given\", Prio_Item, Id);\n+\n+               --  Pragma case\n+\n+               else\n+                  Error_Msg_Name_1 := Pragma_Name (Prio_Item);\n+                  Error_Msg_NE (\"?pragma% for & has no effect when Lock_Free\" &\n+                                \" given\", Prio_Item, Id);\n+               end if;\n+            end if;\n+         end;\n+\n          if not Allows_Lock_Free_Implementation (N, Complain => True) then\n             return;\n          end if;"}, {"sha": "917384ac38934180173dece5f70962b9ef94d846", "filename": "gcc/ada/sem_dim.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22a83cea153e34e826ed42afd56334be89a9ad8e/gcc%2Fada%2Fsem_dim.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22a83cea153e34e826ed42afd56334be89a9ad8e/gcc%2Fada%2Fsem_dim.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_dim.adb?ref=22a83cea153e34e826ed42afd56334be89a9ad8e", "patch": "@@ -432,7 +432,7 @@ package body Sem_Dim is\n    ------------------------------\n \n    --  with Dimension => (\n-   --       [Symbol =>] SYMBOL,\n+   --    [[Symbol =>]   SYMBOL,]\n    --                   DIMENSION_VALUE\n    --    [,             DIMENSION_VALUE]\n    --    [,             DIMENSION_VALUE]"}, {"sha": "486d5cab7162226f4d5aece47ec296ce2511c94a", "filename": "gcc/ada/sem_disp.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22a83cea153e34e826ed42afd56334be89a9ad8e/gcc%2Fada%2Fsem_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22a83cea153e34e826ed42afd56334be89a9ad8e/gcc%2Fada%2Fsem_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.adb?ref=22a83cea153e34e826ed42afd56334be89a9ad8e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1696,7 +1696,9 @@ package body Sem_Disp is\n       Ctrl_Type : Entity_Id;\n \n    begin\n-      if Present (DTC_Entity (Subp)) then\n+      if Ekind_In (Subp, E_Function, E_Procedure)\n+        and then Present (DTC_Entity (Subp))\n+      then\n          return Scope (DTC_Entity (Subp));\n \n       --  For subprograms internally generated by derivations of tagged types"}, {"sha": "e5ed8691126bd1fbd5e416fa72080b4f06fd4650", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22a83cea153e34e826ed42afd56334be89a9ad8e/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22a83cea153e34e826ed42afd56334be89a9ad8e/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=22a83cea153e34e826ed42afd56334be89a9ad8e", "patch": "@@ -6254,7 +6254,7 @@ package body Sem_Prag is\n \n       --    Set Detect_Blocking mode\n \n-      --    Set required restrictions (see System.Rident for detailed list)\n+      --    Set required restrictions (see Rident for detailed list)\n \n       --    Set the No_Dependence rules\n       --      No_Dependence => Ada.Asynchronous_Task_Control"}, {"sha": "b65dbc76d4e000687c897c25aa1460e663255e88", "filename": "gcc/ada/tracebak.c", "status": "modified", "additions": 71, "deletions": 1, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22a83cea153e34e826ed42afd56334be89a9ad8e/gcc%2Fada%2Ftracebak.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22a83cea153e34e826ed42afd56334be89a9ad8e/gcc%2Fada%2Ftracebak.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftracebak.c?ref=22a83cea153e34e826ed42afd56334be89a9ad8e", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *            Copyright (C) 2000-2011, Free Software Foundation, Inc.       *\n+ *            Copyright (C) 2000-2012, Free Software Foundation, Inc.       *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -106,6 +106,76 @@ extern void (*Unlock_Task) (void);\n \n #include \"tb-ivms.c\"\n \n+#elif defined (_WIN64) && defined (__SEH__)\n+\n+#include <windows.h>\n+\n+int\n+__gnat_backtrace (void **array,\n+                  int size,\n+                  void *exclude_min,\n+                  void *exclude_max,\n+                  int skip_frames)\n+{\n+  CONTEXT context;\n+  UNWIND_HISTORY_TABLE history;\n+  int i;\n+\n+  /* Get the context.  */\n+  RtlCaptureContext (&context);\n+\n+  /* Setup unwind history table (a cached to speed-up unwinding).  */\n+  memset (&history, 0, sizeof (history));\n+\n+  i = 0;\n+  while (1)\n+    {\n+      PRUNTIME_FUNCTION RuntimeFunction;\n+      KNONVOLATILE_CONTEXT_POINTERS NvContext;\n+      ULONG64 ImageBase;\n+      VOID *HandlerData;\n+      ULONG64 EstablisherFrame;\n+\n+      /* Get function metadata.  */\n+      RuntimeFunction = RtlLookupFunctionEntry\n+\t(context.Rip, &ImageBase, &history);\n+\n+      if (!RuntimeFunction)\n+\t{\n+\t  /* In case of failure, assume this is a leaf function.  */\n+\t  context.Rip = *(ULONG64 **) context.Rsp;\n+\t  context.Rsp += 8;\n+\t}\n+      else\n+\t{\n+\t  /* Unwind.  */\n+\t  memset (&NvContext, 0, sizeof (KNONVOLATILE_CONTEXT_POINTERS));\n+\t  RtlVirtualUnwind (0, ImageBase, context.Rip, RuntimeFunction,\n+\t\t\t    &context, &HandlerData, &EstablisherFrame,\n+\t\t\t    &NvContext);\n+\t}\n+\n+      /* 0 means bottom of the stack.  */\n+      if (context.Rip == 0)\n+\tbreak;\n+\n+      /* Skip frames.  */\n+      if (skip_frames)\n+\t{\n+\t  skip_frames--;\n+\t  continue;\n+\t}\n+      /* Excluded frames.  */\n+      if ((void *)context.Rip >= exclude_min\n+\t  && (void *)context.Rip <= exclude_max)\n+\tcontinue;\n+\n+      array[i++] = context.Rip - 2;\n+      if (i >= size)\n+\tbreak;\n+    }\n+  return i;\n+}\n #else\n \n /* No target specific implementation.  */"}]}