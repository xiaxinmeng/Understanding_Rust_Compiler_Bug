{"sha": "c344e2656abaa01b2afaebb6beef66b90433fbfa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzM0NGUyNjU2YWJhYTAxYjJhZmFlYmI2YmVlZjY2YjkwNDMzZmJmYQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2012-04-25T02:18:56Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2012-04-25T02:18:56Z"}, "message": "rs6000.c (START_USE, [...]): Define.\n\n\t* config/rs6000/rs6000.c (START_USE, END_USE, NOT_INUSE): Define.\n\t(rs6000_emit_prologue): Use the above to catch register overlap.\n\nFrom-SVN: r186798", "tree": {"sha": "6753bf434b23128855372851d3d46b8ac31b4f2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6753bf434b23128855372851d3d46b8ac31b4f2e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c344e2656abaa01b2afaebb6beef66b90433fbfa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c344e2656abaa01b2afaebb6beef66b90433fbfa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c344e2656abaa01b2afaebb6beef66b90433fbfa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c344e2656abaa01b2afaebb6beef66b90433fbfa/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "544055ae6558c7f9d4c80cf31d0dfa8abd240809", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/544055ae6558c7f9d4c80cf31d0dfa8abd240809", "html_url": "https://github.com/Rust-GCC/gccrs/commit/544055ae6558c7f9d4c80cf31d0dfa8abd240809"}], "stats": {"total": 80, "additions": 72, "deletions": 8}, "files": [{"sha": "8f738149efaae9033728fe2302960d45d8d15d9c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c344e2656abaa01b2afaebb6beef66b90433fbfa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c344e2656abaa01b2afaebb6beef66b90433fbfa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c344e2656abaa01b2afaebb6beef66b90433fbfa", "patch": "@@ -1,3 +1,8 @@\n+2012-04-25  Alan Modra  <amodra@gmail.com>\n+\n+\t* config/rs6000/rs6000.c (START_USE, END_USE, NOT_INUSE): Define.\n+\t(rs6000_emit_prologue): Use the above to catch register overlap.\n+\n 2012-04-25  Alan Modra  <amodra@gmail.com>\n \n \t* config/rs6000/rs6000.c (rs6000_emit_stack_reset): Delete forward"}, {"sha": "bb1a2b93d20f0d9742e8fcd2fd5b135bb7953aa0", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 67, "deletions": 8, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c344e2656abaa01b2afaebb6beef66b90433fbfa/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c344e2656abaa01b2afaebb6beef66b90433fbfa/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=c344e2656abaa01b2afaebb6beef66b90433fbfa", "patch": "@@ -19302,6 +19302,29 @@ rs6000_emit_prologue (void)\n   HOST_WIDE_INT frame_off = 0;\n   HOST_WIDE_INT sp_off = 0;\n \n+#ifdef ENABLE_CHECKING\n+  /* Track and check usage of r0, r11, r12.  */\n+  int reg_inuse = using_static_chain_p ? 1 << 11 : 0;\n+#define START_USE(R) do \\\n+  {\t\t\t\t\t\t\\\n+    gcc_assert ((reg_inuse & (1 << (R))) == 0);\t\\\n+    reg_inuse |= 1 << (R);\t\t\t\\\n+  } while (0)\n+#define END_USE(R) do \\\n+  {\t\t\t\t\t\t\\\n+    gcc_assert ((reg_inuse & (1 << (R))) != 0);\t\\\n+    reg_inuse &= ~(1 << (R));\t\t\t\\\n+  } while (0)\n+#define NOT_INUSE(R) do \\\n+  {\t\t\t\t\t\t\\\n+    gcc_assert ((reg_inuse & (1 << (R))) == 0);\t\\\n+  } while (0)\n+#else\n+#define START_USE(R) do {} while (0)\n+#define END_USE(R) do {} while (0)\n+#define NOT_INUSE(R) do {} while (0)\n+#endif\n+\n   if (flag_stack_usage_info)\n     current_function_static_stack_size = info->total_size;\n \n@@ -19466,6 +19489,7 @@ rs6000_emit_prologue (void)\n       if (need_r11)\n \t{\n \t  ptr_reg = gen_rtx_REG (Pmode, 11);\n+\t  START_USE (11);\n \t}\n       else if (info->total_size < 32767)\n \tframe_off = info->total_size;\n@@ -19478,6 +19502,7 @@ rs6000_emit_prologue (void)\n \t       || crtl->calls_eh_return)\n \t{\n \t  ptr_reg = gen_rtx_REG (Pmode, 12);\n+\t  START_USE (12);\n \t}\n       else\n \t{\n@@ -19500,7 +19525,6 @@ rs6000_emit_prologue (void)\n \t}\n       rs6000_emit_allocate_stack (info->total_size, ptr_reg, -frame_off);\n       sp_off = info->total_size;\n-      sp_off = info->total_size;\n       if (frame_reg_rtx != sp_reg_rtx)\n \trs6000_emit_stack_tie (frame_reg_rtx, false);\n     }\n@@ -19511,6 +19535,7 @@ rs6000_emit_prologue (void)\n       rtx addr, reg, mem;\n \n       reg = gen_rtx_REG (Pmode, 0);\n+      START_USE (0);\n       insn = emit_move_insn (reg, gen_rtx_REG (Pmode, LR_REGNO));\n       RTX_FRAME_RELATED_P (insn) = 1;\n \n@@ -19526,6 +19551,7 @@ rs6000_emit_prologue (void)\n \t  insn = emit_move_insn (mem, reg);\n \t  rs6000_frame_related (insn, frame_reg_rtx, sp_off - frame_off,\n \t\t\t\tNULL_RTX, NULL_RTX);\n+\t  END_USE (0);\n \t}\n     }\n \n@@ -19538,6 +19564,7 @@ rs6000_emit_prologue (void)\n       rtx set;\n \n       cr_save_rtx = gen_rtx_REG (SImode, cr_save_regno);\n+      START_USE (cr_save_regno);\n       insn = emit_insn (gen_movesi_from_cr (cr_save_rtx));\n       RTX_FRAME_RELATED_P (insn) = 1;\n       /* Now, there's no way that dwarf2out_frame_debug_expr is going\n@@ -19581,6 +19608,8 @@ rs6000_emit_prologue (void)\n \t\t\t\t     /*savep=*/true, /*gpr=*/false, lr);\n       rs6000_frame_related (insn, frame_reg_rtx, sp_off,\n \t\t\t    NULL_RTX, NULL_RTX);\n+      if (lr)\n+\tEND_USE (0);\n     }\n \n   /* Save GPRs.  This is done as a PARALLEL if we are using\n@@ -19625,10 +19654,15 @@ rs6000_emit_prologue (void)\n \t  if (using_static_chain_p)\n \t    {\n \t      rtx r0 = gen_rtx_REG (Pmode, 0);\n+\n+\t      START_USE (0);\n \t      gcc_assert (info->first_gp_reg_save > 11);\n \n \t      emit_move_insn (r0, spe_save_area_ptr);\n \t    }\n+\t  else if (REGNO (frame_reg_rtx) != 11)\n+\t    START_USE (11);\n+\n \t  emit_insn (gen_addsi3 (spe_save_area_ptr,\n \t\t\t\t frame_reg_rtx, GEN_INT (offset)));\n \t  if (!using_static_chain_p && REGNO (frame_reg_rtx) == 11)\n@@ -19659,8 +19693,16 @@ rs6000_emit_prologue (void)\n \t}\n \n       /* Move the static chain pointer back.  */\n-      if (using_static_chain_p && !spe_regs_addressable)\n-\temit_move_insn (spe_save_area_ptr, gen_rtx_REG (Pmode, 0));\n+      if (!spe_regs_addressable)\n+\t{\n+\t  if (using_static_chain_p)\n+\t    {\n+\t      emit_move_insn (spe_save_area_ptr, gen_rtx_REG (Pmode, 0));\n+\t      END_USE (0);\n+\t    }\n+\t  else if (REGNO (frame_reg_rtx) != 11)\n+\t    END_USE (11);\n+\t}\n     }\n   else if (!WORLD_SAVE_P (info) && !saving_GPRs_inline)\n     {\n@@ -19681,10 +19723,13 @@ rs6000_emit_prologue (void)\n \n \t  if (ptr_set_up)\n \t    frame_off = -end_save;\n+\t  else\n+\t    NOT_INUSE (ptr_regno);\n \t  emit_insn (gen_add3_insn (ptr_reg, frame_reg_rtx, offset));\n \t}\n       else if (!ptr_set_up)\n \t{\n+\t  NOT_INUSE (ptr_regno);\n \t  emit_move_insn (ptr_reg, frame_reg_rtx);\n \t}\n       ptr_off = -end_save;\n@@ -19695,6 +19740,8 @@ rs6000_emit_prologue (void)\n \t\t\t\t     /*savep=*/true, /*gpr=*/true, lr);\n       rs6000_frame_related (insn, ptr_reg, sp_off - ptr_off,\n \t\t\t    NULL_RTX, NULL_RTX);\n+      if (lr)\n+\tEND_USE (0);\n     }\n   else if (!WORLD_SAVE_P (info) && using_store_multiple)\n     {\n@@ -19753,12 +19800,15 @@ rs6000_emit_prologue (void)\n       rtx save_insn, join_insn, note;\n       long toc_restore_insn;\n \n-      gcc_assert (REGNO (frame_reg_rtx) != 11);\n       tmp_reg = gen_rtx_REG (Pmode, 11);\n       tmp_reg_si = gen_rtx_REG (SImode, 11);\n       if (using_static_chain_p)\n-\temit_move_insn (gen_rtx_REG (Pmode, 0), tmp_reg);\n-      gcc_assert (saving_GPRs_inline && saving_FPRs_inline);\n+\t{\n+\t  START_USE (0);\n+\t  emit_move_insn (gen_rtx_REG (Pmode, 0), tmp_reg);\n+\t}\n+      else\n+\tSTART_USE (11);\n       emit_move_insn (tmp_reg, gen_rtx_REG (Pmode, LR_REGNO));\n       /* Peek at instruction to which this function returns.  If it's\n \t restoring r2, then we know we've already saved r2.  We can't\n@@ -19811,7 +19861,12 @@ rs6000_emit_prologue (void)\n       RTX_FRAME_RELATED_P (join_insn) = 1;\n \n       if (using_static_chain_p)\n-\temit_move_insn (tmp_reg, gen_rtx_REG (Pmode, 0));\n+\t{\n+\t  emit_move_insn (tmp_reg, gen_rtx_REG (Pmode, 0));\n+\t  END_USE (0);\n+\t}\n+      else\n+\tEND_USE (11);\n     }\n \n   /* Save CR if we use any that must be preserved.  */\n@@ -19828,13 +19883,15 @@ rs6000_emit_prologue (void)\n \t{\n \t  rtx set;\n \n+\t  START_USE (0);\n \t  cr_save_rtx = gen_rtx_REG (SImode, 0);\n \t  insn = emit_insn (gen_movesi_from_cr (cr_save_rtx));\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n \t  set = gen_rtx_SET (VOIDmode, cr_save_rtx, magic_eh_cr_reg);\n \t  add_reg_note (insn, REG_FRAME_RELATED_EXPR, set);\n \t}\n       insn = emit_move_insn (mem, cr_save_rtx);\n+      END_USE (REGNO (cr_save_rtx));\n \n       rs6000_frame_related (insn, frame_reg_rtx, sp_off - frame_off,\n \t\t\t    NULL_RTX, NULL_RTX);\n@@ -19856,6 +19913,7 @@ rs6000_emit_prologue (void)\n \t      && (info->vrsave_save_offset\n \t\t  + info->total_size - frame_off) > 32767))\n \t{\n+\t  START_USE (12);\n \t  ptr_reg = gen_rtx_REG (Pmode, 12);\n \t  frame_reg_rtx = ptr_reg;\n \t  frame_off = -(info->altivec_save_offset + info->altivec_size);\n@@ -19864,7 +19922,6 @@ rs6000_emit_prologue (void)\n \tframe_off = info->total_size;\n       rs6000_emit_allocate_stack (info->total_size, ptr_reg, -frame_off);\n       sp_off = info->total_size;\n-      sp_off = info->total_size;\n       if (frame_reg_rtx != sp_reg_rtx)\n \trs6000_emit_stack_tie (frame_reg_rtx, false);\n     }\n@@ -19896,6 +19953,7 @@ rs6000_emit_prologue (void)\n \n \t    savereg = gen_rtx_REG (V4SImode, i);\n \n+\t    NOT_INUSE (0);\n \t    areg = gen_rtx_REG (Pmode, 0);\n \t    emit_move_insn (areg, GEN_INT (offset));\n \n@@ -19928,6 +19986,7 @@ rs6000_emit_prologue (void)\n       /* Get VRSAVE onto a GPR.  Note that ABI_V4 might be using r12\n \t as frame_reg_rtx and r11 as the static chain pointer for\n \t nested functions.  */\n+      NOT_INUSE (0);\n       reg = gen_rtx_REG (SImode, 0);\n       vrsave = gen_rtx_REG (SImode, VRSAVE_REGNO);\n       if (TARGET_MACHO)"}]}