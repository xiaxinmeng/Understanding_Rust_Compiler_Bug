{"sha": "852c8ba12e7824f881bd52a16af2a033a798cb23", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODUyYzhiYTEyZTc4MjRmODgxYmQ1MmExNmFmMmEwMzNhNzk4Y2IyMw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2003-02-09T22:55:35Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2003-02-09T22:55:35Z"}, "message": "simplify-rtx.c (simplify_unary_operation, [...]): Deal with vector modes\n\n\t* simplify-rtx.c (simplify_unary_operation,\n\tsimplify_binary_operation):  Deal with vector modes\n\t(simplify_ternary_operation):  Deal with no-op VEC_MERGE.\n\nFrom-SVN: r62610", "tree": {"sha": "64162b5387c0a25095855244c8e0a85d395c9bfa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/64162b5387c0a25095855244c8e0a85d395c9bfa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/852c8ba12e7824f881bd52a16af2a033a798cb23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/852c8ba12e7824f881bd52a16af2a033a798cb23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/852c8ba12e7824f881bd52a16af2a033a798cb23", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/852c8ba12e7824f881bd52a16af2a033a798cb23/comments", "author": null, "committer": null, "parents": [{"sha": "2382b79f354cae47084d9ea18afcdc58e924a4c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2382b79f354cae47084d9ea18afcdc58e924a4c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2382b79f354cae47084d9ea18afcdc58e924a4c9"}], "stats": {"total": 202, "additions": 190, "deletions": 12}, "files": [{"sha": "e7449de84be0f1d964492f9914f2aee1dac91983", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852c8ba12e7824f881bd52a16af2a033a798cb23/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852c8ba12e7824f881bd52a16af2a033a798cb23/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=852c8ba12e7824f881bd52a16af2a033a798cb23", "patch": "@@ -1,3 +1,9 @@\n+Sun Feb  9 23:54:59 CET 2003  Jan Hubicka  <jh@suse.cz>\n+\n+\t* simplify-rtx.c (simplify_unary_operation,\n+\tsimplify_binary_operation):  Deal with vector modes\n+\t(simplify_ternary_operation):  Deal with no-op VEC_MERGE.\n+\n 2002-02-09  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* toplev.c (rest_of_compilation): Recompute register usage after"}, {"sha": "e874c2a2883101d06593429685b131d8edfa645b", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 184, "deletions": 12, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852c8ba12e7824f881bd52a16af2a033a798cb23/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852c8ba12e7824f881bd52a16af2a033a798cb23/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=852c8ba12e7824f881bd52a16af2a033a798cb23", "patch": "@@ -410,6 +410,31 @@ simplify_unary_operation (code, mode, op, op_mode)\n \t}\n     }\n \n+  if (VECTOR_MODE_P (mode) && GET_CODE (trueop) == CONST_VECTOR)\n+    {\n+      int elt_size = GET_MODE_SIZE (GET_MODE_INNER (mode));\n+      unsigned n_elts = (GET_MODE_SIZE (mode) / elt_size);\n+      enum machine_mode opmode = GET_MODE (trueop);\n+      int op_elt_size = GET_MODE_SIZE (GET_MODE_INNER (opmode));\n+      unsigned op_n_elts = (GET_MODE_SIZE (opmode) / op_elt_size);\n+      rtvec v = rtvec_alloc (n_elts);\n+      unsigned int i;\n+\n+      if (op_n_elts != n_elts)\n+\tabort ();\n+\n+      for (i = 0; i < n_elts; i++)\n+\t{\n+\t  rtx x = simplify_unary_operation (code, GET_MODE_INNER (mode),\n+\t\t\t\t\t    CONST_VECTOR_ELT (trueop, i),\n+\t\t\t\t\t    GET_MODE_INNER (opmode));\n+\t  if (!x)\n+\t    return 0;\n+\t  RTVEC_ELT (v, i) = x;\n+\t}\n+      return gen_rtx_CONST_VECTOR (mode, v);\n+    }\n+\n   /* The order of these tests is critical so that, for example, we don't\n      check the wrong mode (input vs. output) for a conversion operation,\n      such as FIX.  At some point, this should be simplified.  */\n@@ -875,6 +900,37 @@ simplify_binary_operation (code, mode, op0, op1)\n       tem = trueop0, trueop0 = trueop1, trueop1 = tem;\n     }\n \n+  if (VECTOR_MODE_P (mode)\n+      && GET_CODE (trueop0) == CONST_VECTOR\n+      && GET_CODE (trueop1) == CONST_VECTOR)\n+    {\n+      int elt_size = GET_MODE_SIZE (GET_MODE_INNER (mode));\n+      unsigned n_elts = (GET_MODE_SIZE (mode) / elt_size);\n+      enum machine_mode op0mode = GET_MODE (trueop0);\n+      int op0_elt_size = GET_MODE_SIZE (GET_MODE_INNER (op0mode));\n+      unsigned op0_n_elts = (GET_MODE_SIZE (op0mode) / op0_elt_size);\n+      enum machine_mode op1mode = GET_MODE (trueop1);\n+      int op1_elt_size = GET_MODE_SIZE (GET_MODE_INNER (op1mode));\n+      unsigned op1_n_elts = (GET_MODE_SIZE (op1mode) / op1_elt_size);\n+      rtvec v = rtvec_alloc (n_elts);\n+      unsigned int i;\n+\n+      if (op0_n_elts != n_elts || op1_n_elts != n_elts)\n+\tabort ();\n+\n+      for (i = 0; i < n_elts; i++)\n+\t{\n+\t  rtx x = simplify_binary_operation (code, GET_MODE_INNER (mode),\n+\t\t\t\t\t     CONST_VECTOR_ELT (trueop0, i),\n+\t\t\t\t\t     CONST_VECTOR_ELT (trueop1, i));\n+\t  if (!x)\n+\t    return 0;\n+\t  RTVEC_ELT (v, i) = x;\n+\t}\n+\n+      return gen_rtx_CONST_VECTOR (mode, v);\n+    }\n+\n   if (GET_MODE_CLASS (mode) == MODE_FLOAT\n       && GET_CODE (trueop0) == CONST_DOUBLE\n       && GET_CODE (trueop1) == CONST_DOUBLE\n@@ -1515,7 +1571,114 @@ simplify_binary_operation (code, mode, op0, op1)\n \t  return 0;\n \n \tcase VEC_SELECT:\n+\t  if (!VECTOR_MODE_P (mode))\n+\t    {\n+\t      if (!VECTOR_MODE_P (GET_MODE (trueop0))\n+\t\t  || (mode\n+\t\t      != GET_MODE_INNER (GET_MODE (trueop0)))\n+\t\t  || GET_CODE (trueop1) != PARALLEL\n+\t\t  || XVECLEN (trueop1, 0) != 1\n+\t\t  || GET_CODE (XVECEXP (trueop1, 0, 0)) != CONST_INT)\n+\t\tabort ();\n+\n+\t      if (GET_CODE (trueop0) == CONST_VECTOR)\n+\t\treturn CONST_VECTOR_ELT (trueop0, INTVAL (XVECEXP (trueop1, 0, 0)));\n+\t    }\n+\t  else\n+\t    {\n+\t      if (!VECTOR_MODE_P (GET_MODE (trueop0))\n+\t\t  || (GET_MODE_INNER (mode)\n+\t\t      != GET_MODE_INNER (GET_MODE (trueop0)))\n+\t\t  || GET_CODE (trueop1) != PARALLEL)\n+\t\tabort ();\n+\n+\t      if (GET_CODE (trueop0) == CONST_VECTOR)\n+\t\t{\n+\t\t  int elt_size = GET_MODE_SIZE (GET_MODE_INNER (mode));\n+\t\t  unsigned n_elts = (GET_MODE_SIZE (mode) / elt_size);\n+\t\t  rtvec v = rtvec_alloc (n_elts);\n+\t\t  unsigned int i;\n+\n+\t\t  if (XVECLEN (trueop1, 0) != (int)n_elts)\n+\t\t    abort ();\n+\t\t  for (i = 0; i < n_elts; i++)\n+\t\t    {\n+\t\t       rtx x = XVECEXP (trueop1, 0, i);\n+\n+\t\t       if (GET_CODE (x) != CONST_INT)\n+\t\t\t abort ();\n+\t\t       RTVEC_ELT (v, i) = CONST_VECTOR_ELT (trueop0, INTVAL (x));\n+\t\t    }\n+\n+\t\t  return gen_rtx_CONST_VECTOR (mode, v);\n+\t\t}\n+\t    }\n+\t  return 0;\n \tcase VEC_CONCAT:\n+\t  {\n+\t    enum machine_mode op0_mode = (GET_MODE (trueop0) != VOIDmode\n+\t\t\t\t\t  ? GET_MODE (trueop0)\n+\t\t\t\t\t  : GET_MODE_INNER (mode));\n+\t    enum machine_mode op1_mode = (GET_MODE (trueop1) != VOIDmode\n+\t\t\t\t\t  ? GET_MODE (trueop1)\n+\t\t\t\t\t  : GET_MODE_INNER (mode));\n+\n+\t    if (!VECTOR_MODE_P (mode)\n+\t\t|| (GET_MODE_SIZE (op0_mode) + GET_MODE_SIZE (op1_mode)\n+\t\t    != GET_MODE_SIZE (mode)))\n+\t      abort ();\n+\n+\t    if ((VECTOR_MODE_P (op0_mode)\n+\t\t && (GET_MODE_INNER (mode)\n+\t\t     != GET_MODE_INNER (op0_mode)))\n+\t\t|| (!VECTOR_MODE_P (op0_mode)\n+\t\t    && GET_MODE_INNER (mode) != op0_mode))\n+\t      abort ();\n+\n+\t    if ((VECTOR_MODE_P (op1_mode)\n+\t\t && (GET_MODE_INNER (mode)\n+\t\t     != GET_MODE_INNER (op1_mode)))\n+\t\t|| (!VECTOR_MODE_P (op1_mode)\n+\t\t    && GET_MODE_INNER (mode) != op1_mode))\n+\t      abort ();\n+\n+\t    if ((GET_CODE (trueop0) == CONST_VECTOR\n+\t\t || GET_CODE (trueop0) == CONST_INT\n+\t\t || GET_CODE (trueop0) == CONST_DOUBLE)\n+\t\t&& (GET_CODE (trueop1) == CONST_VECTOR\n+\t\t    || GET_CODE (trueop1) == CONST_INT\n+\t\t    || GET_CODE (trueop1) == CONST_DOUBLE))\n+\t      {\n+\t\tint elt_size = GET_MODE_SIZE (GET_MODE_INNER (mode));\n+\t\tunsigned n_elts = (GET_MODE_SIZE (mode) / elt_size);\n+\t\trtvec v = rtvec_alloc (n_elts);\n+\t\tunsigned int i;\n+\t\tunsigned in_n_elts = 1;\n+\n+\t\tif (VECTOR_MODE_P (op0_mode))\n+\t\t  in_n_elts = (GET_MODE_SIZE (op0_mode) / elt_size);\n+\t\tfor (i = 0; i < n_elts; i++)\n+\t\t  {\n+\t\t    if (i < in_n_elts)\n+\t\t      {\n+\t\t\tif (!VECTOR_MODE_P (op0_mode))\n+\t\t\t  RTVEC_ELT (v, i) = trueop0;\n+\t\t\telse\n+\t\t\t  RTVEC_ELT (v, i) = CONST_VECTOR_ELT (trueop0, i);\n+\t\t      }\n+\t\t    else\n+\t\t      {\n+\t\t\tif (!VECTOR_MODE_P (op1_mode))\n+\t\t\t  RTVEC_ELT (v, i) = trueop1;\n+\t\t\telse\n+\t\t\t  RTVEC_ELT (v, i) = CONST_VECTOR_ELT (trueop1,\n+\t\t\t\t\t\t\t       i - in_n_elts);\n+\t\t      }\n+\t\t  }\n+\n+\t\treturn gen_rtx_CONST_VECTOR (mode, v);\n+\t      }\n+\t    }\n \t  return 0;\n \n \tdefault:\n@@ -2379,23 +2542,32 @@ simplify_ternary_operation (code, mode, op0_mode, op0, op1, op2)\n \t  || GET_MODE (op1) != mode\n \t  || !VECTOR_MODE_P (mode))\n \tabort ();\n-      op0 = avoid_constant_pool_reference (op0);\n-      op1 = avoid_constant_pool_reference (op1);\n       op2 = avoid_constant_pool_reference (op2);\n-      if (GET_CODE (op0) == CONST_VECTOR\n-\t  && GET_CODE (op1) == CONST_VECTOR\n-\t  && GET_CODE (op2) == CONST_INT)\n+      if (GET_CODE (op2) == CONST_INT)\n \t{\n           int elt_size = GET_MODE_SIZE (GET_MODE_INNER (mode));\n \t  unsigned n_elts = (GET_MODE_SIZE (mode) / elt_size);\n-\t  rtvec v = rtvec_alloc (n_elts);\n-\t  unsigned int i;\n+\t  int mask = (1<<n_elts) - 1;\n \n-\t  for (i = 0; i < n_elts; i++)\n-\t    RTVEC_ELT (v, i) = (INTVAL (op2) & (1 << i)\n-\t\t\t\t? CONST_VECTOR_ELT (op0, i)\n-\t\t\t\t: CONST_VECTOR_ELT (op1, i));\n-\t  return gen_rtx_CONST_VECTOR (mode, v);\n+\t  if (!(INTVAL (op2) & mask))\n+\t    return op1;\n+\t  if ((INTVAL (op2) & mask) == mask)\n+\t    return op0;\n+\n+\t  op0 = avoid_constant_pool_reference (op0);\n+\t  op1 = avoid_constant_pool_reference (op1);\n+\t  if (GET_CODE (op0) == CONST_VECTOR\n+\t      && GET_CODE (op1) == CONST_VECTOR)\n+\t    {\n+\t      rtvec v = rtvec_alloc (n_elts);\n+\t      unsigned int i;\n+\n+\t      for (i = 0; i < n_elts; i++)\n+\t\tRTVEC_ELT (v, i) = (INTVAL (op2) & (1 << i)\n+\t\t\t\t    ? CONST_VECTOR_ELT (op0, i)\n+\t\t\t\t    : CONST_VECTOR_ELT (op1, i));\n+\t      return gen_rtx_CONST_VECTOR (mode, v);\n+\t    }\n \t}\n       break;\n "}]}