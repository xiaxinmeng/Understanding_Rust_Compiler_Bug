{"sha": "4343f5e256791a5abaaef29fe1f831a03bab129e", "node_id": "C_kwDOANBUbNoAKDQzNDNmNWUyNTY3OTFhNWFiYWFlZjI5ZmUxZjgzMWEwM2JhYjEyOWU", "commit": {"author": {"name": "Raoni Fassina Firmino", "email": "raoni@linux.ibm.com", "date": "2022-01-13T17:08:53Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2022-01-24T17:00:11Z"}, "message": "rtl: builtins: (not just) rs6000: Add builtins for fegetround, feclearexcept and feraiseexcept [PR94193]\n\nThis optimizations were originally in glibc, but was removed\nand suggested that they were a good fit as gcc builtins[1].\n\nfeclearexcept and feraiseexcept were extended (in comparison to the\nglibc version) to accept any combination of the accepted flags, not\nlimited to just one flag bit at a time anymore.\n\nThe builtin expanders needs knowledge of the target libc's FE_*\nvalues, so they are limited to expand only to suitable libcs.\n\n[1] https://sourceware.org/legacy-ml/libc-alpha/2020-03/msg00047.html\n    https://sourceware.org/legacy-ml/libc-alpha/2020-03/msg00080.html\n\n2020-08-13  Raoni Fassina Firmino  <raoni@linux.ibm.com>\n\ngcc/\n\tPR target/94193\n\t* builtins.cc (expand_builtin_fegetround): New function.\n\t(expand_builtin_feclear_feraise_except): New function.\n\t(expand_builtin): Add cases for BUILT_IN_FEGETROUND,\n\tBUILT_IN_FECLEAREXCEPT and BUILT_IN_FERAISEEXCEPT.\n\t* config/rs6000/rs6000.md (fegetroundsi): New pattern.\n\t(feclearexceptsi): New Pattern.\n\t(feraiseexceptsi): New Pattern.\n\t* doc/extend.texi: Add a new introductory paragraph about the\n\tnew builtins.\n\t* doc/md.texi: (fegetround@var{m}): Document new optab.\n\t(feclearexcept@var{m}): Document new optab.\n\t(feraiseexcept@var{m}): Document new optab.\n\t* optabs.def (fegetround_optab): New optab.\n\t(feclearexcept_optab): New optab.\n\t(feraiseexcept_optab): New optab.\n\ngcc/testsuite/\n\tPR target/94193\n\t* gcc.target/powerpc/builtin-feclearexcept-feraiseexcept-1.c: New test.\n\t* gcc.target/powerpc/builtin-feclearexcept-feraiseexcept-2.c: New test.\n\t* gcc.target/powerpc/builtin-fegetround.c: New test.\n\nSigned-off-by: Raoni Fassina Firmino <raoni@linux.ibm.com>", "tree": {"sha": "5847305e8cfd8ad62d664399b54252788735ee65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5847305e8cfd8ad62d664399b54252788735ee65"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4343f5e256791a5abaaef29fe1f831a03bab129e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4343f5e256791a5abaaef29fe1f831a03bab129e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4343f5e256791a5abaaef29fe1f831a03bab129e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4343f5e256791a5abaaef29fe1f831a03bab129e/comments", "author": null, "committer": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1aa2a3cf1ba233ccd5a49fde85a2ca7e5f620e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1aa2a3cf1ba233ccd5a49fde85a2ca7e5f620e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1aa2a3cf1ba233ccd5a49fde85a2ca7e5f620e9"}], "stats": {"total": 419, "additions": 419, "deletions": 0}, "files": [{"sha": "e84208035dab08174338fceeb8604ad1af902f1e", "filename": "gcc/builtins.cc", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4343f5e256791a5abaaef29fe1f831a03bab129e/gcc%2Fbuiltins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4343f5e256791a5abaaef29fe1f831a03bab129e/gcc%2Fbuiltins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.cc?ref=4343f5e256791a5abaaef29fe1f831a03bab129e", "patch": "@@ -119,6 +119,9 @@ static rtx expand_builtin_mathfn_3 (tree, rtx, rtx);\n static rtx expand_builtin_mathfn_ternary (tree, rtx, rtx);\n static rtx expand_builtin_interclass_mathfn (tree, rtx);\n static rtx expand_builtin_sincos (tree);\n+static rtx expand_builtin_fegetround (tree, rtx, machine_mode);\n+static rtx expand_builtin_feclear_feraise_except (tree, rtx, machine_mode,\n+\t\t\t\t\t\t  optab);\n static rtx expand_builtin_cexpi (tree, rtx);\n static rtx expand_builtin_int_roundingfn (tree, rtx);\n static rtx expand_builtin_int_roundingfn_2 (tree, rtx);\n@@ -2555,6 +2558,59 @@ expand_builtin_sincos (tree exp)\n   return const0_rtx;\n }\n \n+/* Expand call EXP to the fegetround builtin (from C99 fenv.h), returning the\n+   result and setting it in TARGET.  Otherwise return NULL_RTX on failure.  */\n+static rtx\n+expand_builtin_fegetround (tree exp, rtx target, machine_mode target_mode)\n+{\n+  if (!validate_arglist (exp, VOID_TYPE))\n+    return NULL_RTX;\n+\n+  insn_code icode = direct_optab_handler (fegetround_optab, SImode);\n+  if (icode == CODE_FOR_nothing)\n+    return NULL_RTX;\n+\n+  if (target == 0\n+      || GET_MODE (target) != target_mode\n+      || !(*insn_data[icode].operand[0].predicate) (target, target_mode))\n+    target = gen_reg_rtx (target_mode);\n+\n+  rtx pat = GEN_FCN (icode) (target);\n+  if (!pat)\n+    return NULL_RTX;\n+  emit_insn (pat);\n+\n+  return target;\n+}\n+\n+/* Expand call EXP to either feclearexcept or feraiseexcept builtins (from C99\n+   fenv.h), returning the result and setting it in TARGET.  Otherwise return\n+   NULL_RTX on failure.  */\n+static rtx\n+expand_builtin_feclear_feraise_except (tree exp, rtx target,\n+\t\t\t\t       machine_mode target_mode, optab op_optab)\n+{\n+  if (!validate_arglist (exp, INTEGER_TYPE, VOID_TYPE))\n+    return NULL_RTX;\n+  rtx op0 = expand_normal (CALL_EXPR_ARG (exp, 0));\n+\n+  insn_code icode = direct_optab_handler (op_optab, SImode);\n+  if (icode == CODE_FOR_nothing)\n+    return NULL_RTX;\n+\n+  if (target == 0\n+      || GET_MODE (target) != target_mode\n+      || !(*insn_data[icode].operand[0].predicate) (target, target_mode))\n+    target = gen_reg_rtx (target_mode);\n+\n+  rtx pat = GEN_FCN (icode) (target, op0);\n+  if (!pat)\n+    return NULL_RTX;\n+  emit_insn (pat);\n+\n+  return target;\n+}\n+\n /* Expand a call to the internal cexpi builtin to the sincos math function.\n    EXP is the expression that is a call to the builtin function; if convenient,\n    the result should be placed in TARGET.  */\n@@ -7056,6 +7112,26 @@ expand_builtin (tree exp, rtx target, rtx subtarget, machine_mode mode,\n \treturn target;\n       break;\n \n+    case BUILT_IN_FEGETROUND:\n+      target = expand_builtin_fegetround (exp, target, target_mode);\n+      if (target)\n+\treturn target;\n+      break;\n+\n+    case BUILT_IN_FECLEAREXCEPT:\n+      target = expand_builtin_feclear_feraise_except (exp, target, target_mode,\n+\t\t\t\t\t\t      feclearexcept_optab);\n+      if (target)\n+\treturn target;\n+      break;\n+\n+    case BUILT_IN_FERAISEEXCEPT:\n+      target = expand_builtin_feclear_feraise_except (exp, target, target_mode,\n+\t\t\t\t\t\t      feraiseexcept_optab);\n+      if (target)\n+\treturn target;\n+      break;\n+\n     case BUILT_IN_APPLY_ARGS:\n       return expand_builtin_apply_args ();\n "}, {"sha": "fdfbc6566a5c93fe6fe36edd2acefe924db83ef5", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4343f5e256791a5abaaef29fe1f831a03bab129e/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4343f5e256791a5abaaef29fe1f831a03bab129e/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=4343f5e256791a5abaaef29fe1f831a03bab129e", "patch": "@@ -6912,6 +6912,117 @@\n   [(set_attr \"type\" \"fpload\")\n    (set_attr \"length\" \"8\")\n    (set_attr \"isa\" \"*,p8v,p8v\")])\n+\n+;; int fegetround(void)\n+;;\n+;; This expansion for the C99 function only expands for compatible\n+;; target libcs, because it needs to return one of FE_DOWNWARD,\n+;; FE_TONEAREST, FE_TOWARDZERO or FE_UPWARD with the values as defined\n+;; by the target libc, and since the libc is free to choose the values\n+;; (and they may differ from the hardware) and the expander needs to\n+;; know then beforehand, this expanded only expands for target libcs\n+;; that it can handle the values is knows.\n+;; Because of these restriction, this only expands on the desired\n+;; case and fallback to a call to libc otherwise.\n+(define_expand \"fegetroundsi\"\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\")\n+\t(unspec_volatile:SI [(const_int 0)] UNSPECV_MFFSL))]\n+  \"TARGET_HARD_FLOAT\"\n+{\n+  if (!OPTION_GLIBC)\n+    FAIL;\n+\n+  rtx tmp_df = gen_reg_rtx (DFmode);\n+  emit_insn (gen_rs6000_mffsl (tmp_df));\n+\n+  rtx tmp_di = simplify_gen_subreg (DImode, tmp_df, DFmode, 0);\n+  rtx tmp_di_2 = gen_reg_rtx (DImode);\n+  emit_insn (gen_anddi3 (tmp_di_2, tmp_di, GEN_INT (3)));\n+  rtx tmp_si = gen_reg_rtx (SImode);\n+  tmp_si = gen_lowpart (SImode, tmp_di_2);\n+  emit_move_insn (operands[0], tmp_si);\n+  DONE;\n+})\n+\n+;; int feclearexcept(int excepts)\n+;;\n+;; This expansion for the C99 function only works when EXCEPTS is a\n+;; constant known at compile time and specifies any one of\n+;; FE_INEXACT, FE_DIVBYZERO, FE_UNDERFLOW and FE_OVERFLOW flags.\n+;; It doesn't handle values out of range, and always returns 0.\n+;; Note that FE_INVALID is unsupported because it maps to more than\n+;; one bit of the FPSCR register.\n+;; The FE_* are defined in the target libc, and since they are free to\n+;; choose the values and the expand needs to know them beforehand,\n+;; this expander only expands for target libcs that it can handle the\n+;; values it knows.\n+;; Because of these restrictions, this only expands on the desired\n+;; cases and fallback to a call to libc on any other case.\n+(define_expand \"feclearexceptsi\"\n+  [(use (match_operand:SI 1 \"const_int_operand\" \"n\"))\n+   (set (match_operand:SI 0 \"gpc_reg_operand\")\n+\t(const_int 0))]\n+  \"TARGET_HARD_FLOAT\"\n+{\n+  if (!OPTION_GLIBC)\n+    FAIL;\n+\n+  unsigned int fe = INTVAL (operands[1]);\n+  if (fe != (fe & 0x1e000000))\n+    FAIL;\n+\n+  if (fe & 0x02000000)  /* FE_INEXACT */\n+    emit_insn (gen_rs6000_mtfsb0 (gen_rtx_CONST_INT (SImode, 6)));\n+  if (fe & 0x04000000)  /* FE_DIVBYZERO */\n+    emit_insn (gen_rs6000_mtfsb0 (gen_rtx_CONST_INT (SImode, 5)));\n+  if (fe & 0x08000000)  /* FE_UNDERFLOW */\n+    emit_insn (gen_rs6000_mtfsb0 (gen_rtx_CONST_INT (SImode, 4)));\n+  if (fe & 0x10000000)  /* FE_OVERFLOW */\n+    emit_insn (gen_rs6000_mtfsb0 (gen_rtx_CONST_INT (SImode, 3)));\n+\n+  emit_move_insn (operands[0], const0_rtx);\n+  DONE;\n+})\n+\n+;; int feraiseexcept(int excepts)\n+;;\n+;; This expansion for the C99 function only works when excepts is a\n+;; constant known at compile time and specifies any one of\n+;; FE_INEXACT, FE_DIVBYZERO, FE_UNDERFLOW and FE_OVERFLOW flags.\n+;; It doesn't handle values out of range, and always returns 0.\n+;; Note that FE_INVALID is unsupported because it maps to more than\n+;; one bit of the FPSCR register.\n+;; The FE_* are defined in the target libc, and since they are free to\n+;; choose the values and the expand needs to know them beforehand,\n+;; this expander only expands for target libcs that it can handle the\n+;; values it knows.\n+;; Because of these restrictions, this only expands on the desired\n+;; cases and fallback to a call to libc on any other case.\n+(define_expand \"feraiseexceptsi\"\n+  [(use (match_operand:SI 1 \"const_int_operand\" \"n\"))\n+   (set (match_operand:SI 0 \"gpc_reg_operand\")\n+\t(const_int 0))]\n+  \"TARGET_HARD_FLOAT\"\n+{\n+  if (!OPTION_GLIBC)\n+    FAIL;\n+\n+  unsigned int fe = INTVAL (operands[1]);\n+  if (fe != (fe & 0x1e000000))\n+    FAIL;\n+\n+  if (fe & 0x02000000)  /* FE_INEXACT */\n+    emit_insn (gen_rs6000_mtfsb1 (gen_rtx_CONST_INT (SImode, 6)));\n+  if (fe & 0x04000000)  /* FE_DIVBYZERO */\n+    emit_insn (gen_rs6000_mtfsb1 (gen_rtx_CONST_INT (SImode, 5)));\n+  if (fe & 0x08000000)  /* FE_UNDERFLOW */\n+    emit_insn (gen_rs6000_mtfsb1 (gen_rtx_CONST_INT (SImode, 4)));\n+  if (fe & 0x10000000)  /* FE_OVERFLOW */\n+    emit_insn (gen_rs6000_mtfsb1 (gen_rtx_CONST_INT (SImode, 3)));\n+\n+  emit_move_insn (operands[0], const0_rtx);\n+  DONE;\n+})\n \f\n ;; Define the TImode operations that can be done in a small number\n ;; of instructions.  The & constraints are to prevent the register"}, {"sha": "a961fc4e0a2fb6ba7e1ada823da4dbf1fdb92323", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4343f5e256791a5abaaef29fe1f831a03bab129e/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4343f5e256791a5abaaef29fe1f831a03bab129e/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=4343f5e256791a5abaaef29fe1f831a03bab129e", "patch": "@@ -13506,6 +13506,14 @@ In the same fashion, GCC provides @code{fpclassify}, @code{isfinite},\n @code{__builtin_} prefixed.  The @code{isinf} and @code{isnan}\n built-in functions appear both with and without the @code{__builtin_} prefix.\n \n+GCC provides built-in versions of the ISO C99 floating-point rounding and\n+exceptions handling functions @code{fegetround}, @code{feclearexcept} and\n+@code{feraiseexcept}.  They may not be available for all targets, and because\n+they need close interaction with libc internal values, they may not be available\n+for all target libcs, but in all cases they will gracefully fallback to libc\n+calls.  This built-in functions appear both with and without the\n+@code{__builtin_} prefix.\n+\n @deftypefn {Built-in Function} void *__builtin_alloca (size_t size)\n The @code{__builtin_alloca} function must be called at block scope.\n The function allocates an object @var{size} bytes large on the stack"}, {"sha": "feacb12e589968a6bfe8b30832163718c2a908aa", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4343f5e256791a5abaaef29fe1f831a03bab129e/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4343f5e256791a5abaaef29fe1f831a03bab129e/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=4343f5e256791a5abaaef29fe1f831a03bab129e", "patch": "@@ -6087,6 +6087,23 @@ mode @var{m}, which is a scalar or vector floating-point mode.\n \n This pattern is not allowed to @code{FAIL}.\n \n+@cindex @code{fegetround@var{m}} instruction pattern\n+@item @samp{fegetround@var{m}}\n+Store the current machine floating-point rounding mode into operand 0.\n+Operand 0 has mode @var{m}, which is scalar.  This pattern is used to\n+implement the @code{fegetround} function from the ISO C99 standard.\n+\n+@cindex @code{feclearexcept@var{m}} instruction pattern\n+@cindex @code{feraiseexcept@var{m}} instruction pattern\n+@item @samp{feclearexcept@var{m}}\n+@item @samp{feraiseexcept@var{m}}\n+Clears or raises the supported machine floating-point exceptions\n+represented by the bits in operand 1.  Error status is stored as\n+nonzero value in operand 0.  Both operands have mode @var{m}, which is\n+a scalar.  These patterns are used to implement the\n+@code{feclearexcept} and @code{feraiseexcept} functions from the ISO\n+C99 standard.\n+\n @cindex @code{exp@var{m}2} instruction pattern\n @item @samp{exp@var{m}2}\n Raise e (the base of natural logarithms) to the power of operand 1"}, {"sha": "801310ebaa7d469520809bb7efed6820f8eb866b", "filename": "gcc/optabs.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4343f5e256791a5abaaef29fe1f831a03bab129e/gcc%2Foptabs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4343f5e256791a5abaaef29fe1f831a03bab129e/gcc%2Foptabs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.def?ref=4343f5e256791a5abaaef29fe1f831a03bab129e", "patch": "@@ -331,6 +331,10 @@ OPTAB_D (sinh_optab, \"sinh$a2\")\n OPTAB_D (tan_optab, \"tan$a2\")\n OPTAB_D (tanh_optab, \"tanh$a2\")\n \n+OPTAB_D (fegetround_optab, \"fegetround$a\")\n+OPTAB_D (feclearexcept_optab, \"feclearexcept$a\")\n+OPTAB_D (feraiseexcept_optab, \"feraiseexcept$a\")\n+\n /* C99 implementations of fmax/fmin.  */\n OPTAB_D (fmax_optab, \"fmax$a3\")\n OPTAB_D (fmin_optab, \"fmin$a3\")"}, {"sha": "4482e89b0db9e8470e7d6e1fdca23486e661d68d", "filename": "gcc/testsuite/gcc.target/powerpc/builtin-feclearexcept-feraiseexcept-1.c", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4343f5e256791a5abaaef29fe1f831a03bab129e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbuiltin-feclearexcept-feraiseexcept-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4343f5e256791a5abaaef29fe1f831a03bab129e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbuiltin-feclearexcept-feraiseexcept-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbuiltin-feclearexcept-feraiseexcept-1.c?ref=4343f5e256791a5abaaef29fe1f831a03bab129e", "patch": "@@ -0,0 +1,76 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target fenv_exceptions } */\n+/* { dg-options \"-lm -fno-builtin\" } */\n+\n+/* This testcase ensures that the builtins expand with the matching arguments\n+   or otherwise fallback gracefully to a function call, and don't ICE during\n+   compilation.\n+   \"-fno-builtin\" option is used to enable calls to libc implementation of the\n+   gcc builtins tested when not using __builtin_ prefix. */\n+\n+#include <fenv.h>\n+\n+int\n+main ()\n+{\n+  int   rsi = 0;\n+  long  rsl = 0;\n+  short rss = 0;\n+  char  rsc = 0;\n+\n+  unsigned int   rui = 0;\n+  unsigned long  rul = 0;\n+  unsigned short rus = 0;\n+  unsigned char  ruc = 0;\n+\n+  int e = FE_DIVBYZERO;\n+\n+  __builtin_feclearexcept(e);                          // CALL\n+  __builtin_feclearexcept(FE_ALL_EXCEPT);              // CALL\n+  __builtin_feclearexcept(FE_INVALID);                 // CALL\n+  __builtin_feclearexcept(FE_INVALID | FE_INEXACT);    // CALL\n+\n+  __builtin_feclearexcept(FE_INEXACT | FE_DIVBYZERO |\n+                          FE_UNDERFLOW | FE_OVERFLOW);  // EXPAND\n+  __builtin_feclearexcept(FE_INEXACT | FE_OVERFLOW);    // EXPAND\n+  __builtin_feclearexcept(FE_INEXACT);                  // EXPAND\n+  __builtin_feclearexcept(FE_DIVBYZERO);                // EXPAND\n+  __builtin_feclearexcept(FE_UNDERFLOW);                // EXPAND\n+  __builtin_feclearexcept(FE_OVERFLOW);                 // EXPAND\n+  __builtin_feclearexcept(0);                           // EXPAND\n+\n+  rsi = __builtin_feclearexcept(FE_DIVBYZERO);  // EXPAND\n+  rsl = __builtin_feclearexcept(FE_DIVBYZERO);  // EXPAND\n+  rss = __builtin_feclearexcept(FE_DIVBYZERO);  // EXPAND\n+  rsc = __builtin_feclearexcept(FE_DIVBYZERO);  // EXPAND\n+  rui = __builtin_feclearexcept(FE_DIVBYZERO);  // EXPAND\n+  rul = __builtin_feclearexcept(FE_DIVBYZERO);  // EXPAND\n+  rus = __builtin_feclearexcept(FE_DIVBYZERO);  // EXPAND\n+  ruc = __builtin_feclearexcept(FE_DIVBYZERO);  // EXPAND\n+\n+\n+  __builtin_feraiseexcept(e);                          // CALL\n+  __builtin_feraiseexcept(FE_ALL_EXCEPT);              // CALL\n+  __builtin_feraiseexcept(FE_INVALID);                 // CALL\n+  __builtin_feraiseexcept(FE_INVALID | FE_INEXACT);    // CALL\n+\n+  __builtin_feraiseexcept(FE_INEXACT | FE_DIVBYZERO |\n+                          FE_UNDERFLOW | FE_OVERFLOW);  // EXPAND\n+  __builtin_feraiseexcept(FE_INEXACT | FE_OVERFLOW);    // EXPAND\n+  __builtin_feraiseexcept(FE_INEXACT);                  // EXPAND\n+  __builtin_feraiseexcept(FE_DIVBYZERO);                // EXPAND\n+  __builtin_feraiseexcept(FE_UNDERFLOW);                // EXPAND\n+  __builtin_feraiseexcept(FE_OVERFLOW);                 // EXPAND\n+  __builtin_feraiseexcept(0);                           // EXPAND\n+\n+  rsi = __builtin_feraiseexcept(FE_DIVBYZERO);  // EXPAND\n+  rsl = __builtin_feraiseexcept(FE_DIVBYZERO);  // EXPAND\n+  rss = __builtin_feraiseexcept(FE_DIVBYZERO);  // EXPAND\n+  rsc = __builtin_feraiseexcept(FE_DIVBYZERO);  // EXPAND\n+  rui = __builtin_feraiseexcept(FE_DIVBYZERO);  // EXPAND\n+  rul = __builtin_feraiseexcept(FE_DIVBYZERO);  // EXPAND\n+  rus = __builtin_feraiseexcept(FE_DIVBYZERO);  // EXPAND\n+  ruc = __builtin_feraiseexcept(FE_DIVBYZERO);  // EXPAND\n+\n+  return 0;\n+}"}, {"sha": "28c2a00ec520385c4731f05760204c5799558367", "filename": "gcc/testsuite/gcc.target/powerpc/builtin-feclearexcept-feraiseexcept-2.c", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4343f5e256791a5abaaef29fe1f831a03bab129e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbuiltin-feclearexcept-feraiseexcept-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4343f5e256791a5abaaef29fe1f831a03bab129e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbuiltin-feclearexcept-feraiseexcept-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbuiltin-feclearexcept-feraiseexcept-2.c?ref=4343f5e256791a5abaaef29fe1f831a03bab129e", "patch": "@@ -0,0 +1,91 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target fenv_exceptions } */\n+/* { dg-options \"-lm -fno-builtin\" } */\n+\n+/* This testcase ensures that the builtins are correctly expanded and match the\n+   expected result.\n+   \"-fno-builtin\" option is used to enable calls to libc implementation of the\n+   gcc builtins tested when not using __builtin_ prefix.\n+   The excepts parameter needs to be passed as constant to\n+   __builtin_feclearexcept and __builtin_feraiseexcept because some bultins only\n+   expand on constant input. */\n+\n+#include <fenv.h>\n+\n+#ifdef DEBUG\n+#include <stdio.h>\n+#define INFO(...) printf(__VA_ARGS__)\n+#define FAIL(ret, raised, expected, excepts, excepts_str, func) \\\n+        printf(\"ERROR [l %d] testing %s (%x): %s returned %d.\"  \\\n+\t       \" Raised except bits %x, expecected %x\\n\",       \\\n+\t       __LINE__, excepts_str, excepts, func, ret, raised, expected)\n+#else\n+void abort (void);\n+#define INFO(...)\n+#define FAIL(ret, raised, expected, excepts, excepts_str, func) abort()\n+#endif\n+\n+#define TEST(excepts)                                                          \\\n+    do {                                                                       \\\n+      int ret = 0;                                                             \\\n+      int raised = 0;                                                          \\\n+                                                                               \\\n+      INFO(\"test: %s (%x)\\n\", #excepts, excepts);                              \\\n+                                                                               \\\n+      feclearexcept(FE_ALL_EXCEPT);                                            \\\n+      ret = __builtin_feraiseexcept(excepts);                                  \\\n+      raised = fetestexcept(FE_ALL_EXCEPT);                                    \\\n+      if (ret != 0 || raised != (excepts))                                     \\\n+        FAIL(ret, raised, excepts, excepts, #excepts,                          \\\n+\t     \"__builtin_feraiseexcept\");                                       \\\n+                                                                               \\\n+      feraiseexcept(FE_ALL_EXCEPT);                                            \\\n+      ret = __builtin_feclearexcept(excepts);                                  \\\n+      raised = fetestexcept(FE_ALL_EXCEPT);                                    \\\n+      if (ret != 0 || raised != (FE_ALL_EXCEPT & ~(excepts)))                  \\\n+        FAIL(ret, raised, FE_ALL_EXCEPT & ~(excepts), excepts, #excepts,       \\\n+\t     \"__builtin_feclearexcept\");                                       \\\n+    } while (0)\n+\n+int\n+main ()\n+{\n+    TEST(0);\n+    TEST(FE_ALL_EXCEPT);\n+\n+    TEST(FE_INVALID);\n+    TEST(FE_DIVBYZERO);\n+    TEST(FE_INEXACT);\n+    TEST(FE_OVERFLOW);\n+    TEST(FE_UNDERFLOW);\n+\n+    TEST(FE_INVALID | FE_DIVBYZERO);\n+    TEST(FE_INVALID | FE_INEXACT);\n+    TEST(FE_INVALID | FE_OVERFLOW);\n+    TEST(FE_INVALID | FE_UNDERFLOW);\n+    TEST(FE_DIVBYZERO | FE_INEXACT);\n+    TEST(FE_DIVBYZERO | FE_OVERFLOW);\n+    TEST(FE_DIVBYZERO | FE_UNDERFLOW);\n+    TEST(FE_INEXACT | FE_OVERFLOW);\n+    TEST(FE_INEXACT | FE_UNDERFLOW);\n+    TEST(FE_OVERFLOW | FE_UNDERFLOW);\n+\n+    TEST(FE_INVALID | FE_DIVBYZERO | FE_INEXACT);\n+    TEST(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW);\n+    TEST(FE_INVALID | FE_DIVBYZERO | FE_UNDERFLOW);\n+    TEST(FE_INVALID | FE_INEXACT | FE_OVERFLOW);\n+    TEST(FE_INVALID | FE_INEXACT | FE_UNDERFLOW);\n+    TEST(FE_INVALID | FE_OVERFLOW | FE_UNDERFLOW);\n+    TEST(FE_DIVBYZERO | FE_INEXACT | FE_OVERFLOW);\n+    TEST(FE_DIVBYZERO | FE_INEXACT | FE_UNDERFLOW);\n+    TEST(FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW);\n+    TEST(FE_INEXACT | FE_OVERFLOW | FE_UNDERFLOW);\n+\n+    TEST(FE_INVALID | FE_DIVBYZERO | FE_INEXACT | FE_UNDERFLOW);\n+    TEST(FE_INVALID | FE_DIVBYZERO | FE_INEXACT | FE_OVERFLOW);\n+    TEST(FE_INVALID | FE_DIVBYZERO | FE_UNDERFLOW | FE_OVERFLOW);\n+    TEST(FE_INVALID | FE_INEXACT | FE_UNDERFLOW | FE_OVERFLOW);\n+    TEST(FE_DIVBYZERO | FE_INEXACT | FE_UNDERFLOW | FE_OVERFLOW);\n+\n+  return 0;\n+}"}, {"sha": "56ffc50e3ee3accf56b0a28e8d1bd02a555e4cbc", "filename": "gcc/testsuite/gcc.target/powerpc/builtin-fegetround.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4343f5e256791a5abaaef29fe1f831a03bab129e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbuiltin-fegetround.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4343f5e256791a5abaaef29fe1f831a03bab129e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbuiltin-fegetround.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbuiltin-fegetround.c?ref=4343f5e256791a5abaaef29fe1f831a03bab129e", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target fenv_exceptions } */\n+/* { dg-options \"-lm -fno-builtin\" } */\n+\n+/* This testcase ensures that the builtins is correctly expanded and match the\n+   expected result from the standard function.\n+   \"-fno-builtin\" option is used to enable calls to libc implementation of the\n+   gcc builtins tested when not using __builtin_ prefix. */\n+\n+#include <fenv.h>\n+\n+#ifdef DEBUG\n+#include <stdio.h>\n+#define FAIL(v, e) printf(\"ERROR, __builtin_fegetround() returned %d,\" \\\n+                          \" not the expecected value %d\\n\", v, e);\n+#else\n+void abort (void);\n+#define FAIL(v, e) abort()\n+#endif\n+\n+int\n+main ()\n+{\n+  int i, rounding, expected;\n+  const int rm[] = {FE_TONEAREST, FE_TOWARDZERO, FE_UPWARD, FE_DOWNWARD};\n+  for (i = 0; i < sizeof rm / sizeof rm[0]; i++)\n+    {\n+      fesetround(rm[i]);\n+      rounding = __builtin_fegetround();\n+      expected = fegetround();\n+      if (rounding != expected)\n+        FAIL(rounding, expected);\n+    }\n+\n+  return 0;\n+}"}]}