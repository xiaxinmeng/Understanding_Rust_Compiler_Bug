{"sha": "2505bc9700f24c9e1478c19822fd82c0f5c6f9e9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjUwNWJjOTcwMGYyNGM5ZTE0NzhjMTk4MjJmZDgyYzBmNWM2ZjllOQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-04-29T16:55:35Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-04-29T16:55:35Z"}, "message": "(output_move_double): Support XFmode moves.\n\nFrom-SVN: r4274", "tree": {"sha": "b7979570d503576e1b73f025935ecd040057a854", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b7979570d503576e1b73f025935ecd040057a854"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2505bc9700f24c9e1478c19822fd82c0f5c6f9e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2505bc9700f24c9e1478c19822fd82c0f5c6f9e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2505bc9700f24c9e1478c19822fd82c0f5c6f9e9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2505bc9700f24c9e1478c19822fd82c0f5c6f9e9/comments", "author": null, "committer": null, "parents": [{"sha": "32c454f6c71d154c5f51188ce44f82727db8d0a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32c454f6c71d154c5f51188ce44f82727db8d0a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32c454f6c71d154c5f51188ce44f82727db8d0a7"}], "stats": {"total": 176, "additions": 152, "deletions": 24}, "files": [{"sha": "f0ba65bac0b977f9f17ff5c810fe6b67a851c503", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 152, "deletions": 24, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2505bc9700f24c9e1478c19822fd82c0f5c6f9e9/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2505bc9700f24c9e1478c19822fd82c0f5c6f9e9/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=2505bc9700f24c9e1478c19822fd82c0f5c6f9e9", "patch": "@@ -870,16 +870,25 @@ singlemove_string (operands)\n   return \"sub%.l %0,%0\";\n }\n \n+\n /* Output assembler code to perform a doubleword move insn\n    with operands OPERANDS.  */\n \n char *\n output_move_double (operands)\n      rtx *operands;\n {\n-  enum { REGOP, OFFSOP, MEMOP, PUSHOP, POPOP, CNSTOP, RNDOP } optype0, optype1;\n+  enum\n+    {\n+      REGOP, OFFSOP, MEMOP, PUSHOP, POPOP, CNSTOP, RNDOP\n+    } optype0, optype1;\n   rtx latehalf[2];\n+  rtx middlehalf[2];\n   rtx addreg0 = 0, addreg1 = 0;\n+  int size = GET_MODE_SIZE (GET_MODE (operands[1]));\n+\n+  middlehalf[0] = 0;\n+  middlehalf[1] = 0;\n \n   /* First classify both operands.  */\n \n@@ -925,15 +934,31 @@ output_move_double (operands)\n   if (optype0 == PUSHOP && optype1 == POPOP)\n     {\n       operands[0] = XEXP (XEXP (operands[0], 0), 0);\n-      output_asm_insn (\"subq%.l %#8,%0\", operands);\n-      operands[0] = gen_rtx (MEM, DImode, operands[0]);\n+      if (size == 12)\n+        output_asm_insn (\"sub%.l %#12,%0\", operands);\n+      else\n+        output_asm_insn (\"subq%.l %#8,%0\", operands);\n+      if (GET_MODE (operands[1]) == XFmode)\n+\toperands[0] = gen_rtx (MEM, XFmode, operands[0]);\n+      else if (GET_MODE (operands[0]) == DFmode)\n+\toperands[0] = gen_rtx (MEM, DFmode, operands[0]);\n+      else\n+\toperands[0] = gen_rtx (MEM, DImode, operands[0]);\n       optype0 = OFFSOP;\n     }\n   if (optype0 == POPOP && optype1 == PUSHOP)\n     {\n       operands[1] = XEXP (XEXP (operands[1], 0), 0);\n-      output_asm_insn (\"subq%.l %#8,%1\", operands);\n-      operands[1] = gen_rtx (MEM, DImode, operands[1]);\n+      if (size == 12)\n+        output_asm_insn (\"sub%.l %#12,%1\", operands);\n+      else\n+        output_asm_insn (\"subq%.l %#8,%1\", operands);\n+      if (GET_MODE (operands[1]) == XFmode)\n+\toperands[1] = gen_rtx (MEM, XFmode, operands[1]);\n+      else if (GET_MODE (operands[1]) == DFmode)\n+\toperands[1] = gen_rtx (MEM, DFmode, operands[1]);\n+      else\n+\toperands[1] = gen_rtx (MEM, DImode, operands[1]);\n       optype1 = OFFSOP;\n     }\n \n@@ -955,21 +980,83 @@ output_move_double (operands)\n      for the high-numbered word and in some cases alter the\n      operands in OPERANDS to be suitable for the low-numbered word.  */\n \n-  if (optype0 == REGOP)\n-    latehalf[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n-  else if (optype0 == OFFSOP)\n-    latehalf[0] = adj_offsettable_operand (operands[0], 4);\n-  else\n-    latehalf[0] = operands[0];\n-\n-  if (optype1 == REGOP)\n-    latehalf[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n-  else if (optype1 == OFFSOP)\n-    latehalf[1] = adj_offsettable_operand (operands[1], 4);\n-  else if (optype1 == CNSTOP)\n-    split_double (operands[1], &operands[1], &latehalf[1]);\n+  if (size == 12)\n+    {\n+      if (optype0 == REGOP)\n+\t{\n+\t  latehalf[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 2);\n+\t  middlehalf[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+\t}\n+      else if (optype0 == OFFSOP)\n+\t{\n+\t  middlehalf[0] = adj_offsettable_operand (operands[0], 4);\n+\t  latehalf[0] = adj_offsettable_operand (operands[0], size - 4);\n+\t}\n+      else\n+\t{\n+\t  middlehalf[0] = operands[0];\n+\t  latehalf[0] = operands[0];\n+\t}\n+\n+      if (optype1 == REGOP)\n+\t{\n+\t  latehalf[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 2);\n+\t  middlehalf[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+\t}\n+      else if (optype1 == OFFSOP)\n+\t{\n+\t  middlehalf[1] = adj_offsettable_operand (operands[1], 4);\n+\t  latehalf[1] = adj_offsettable_operand (operands[1], size - 4);\n+\t}\n+      else if (optype1 == CNSTOP)\n+\t{\n+\t  if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+\t    {\n+\t      REAL_VALUE_TYPE r;\n+\t      long l[3];\n+\n+\t      REAL_VALUE_FROM_CONST_DOUBLE (r, operands[1]);\n+\t      REAL_VALUE_TO_TARGET_LONG_DOUBLE (r, l);\n+\t      operands[1] = GEN_INT (l[0]);\n+\t      middlehalf[1] = GEN_INT (l[1]);\n+\t      latehalf[1] = GEN_INT (l[2]);\n+\t    }\n+\t  else if (CONSTANT_P (operands[1]))\n+\t    {\n+\t      /* actually, no non-CONST_DOUBLE constant should ever\n+\t\t appear here.  */\n+\t      abort ();\n+\t      if (GET_CODE (operands[1]) == CONST_INT && INTVAL (operands[1]) < 0)\n+\t\tlatehalf[1] = constm1_rtx;\n+\t      else\n+\t\tlatehalf[1] = const0_rtx;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  middlehalf[1] = operands[1];\n+\t  latehalf[1] = operands[1];\n+\t}\n+    }\n   else\n-    latehalf[1] = operands[1];\n+    /* size is not 12: */\n+    {\n+      if (optype0 == REGOP)\n+\tlatehalf[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+      else if (optype0 == OFFSOP)\n+\tlatehalf[0] = adj_offsettable_operand (operands[0], size - 4);\n+      else\n+\tlatehalf[0] = operands[0];\n+\n+      if (optype1 == REGOP)\n+\tlatehalf[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+      else if (optype1 == OFFSOP)\n+\tlatehalf[1] = adj_offsettable_operand (operands[1], size - 4);\n+      else if (optype1 == CNSTOP)\n+\tsplit_double (operands[1], &operands[1], &latehalf[1]);\n+      else\n+\tlatehalf[1] = operands[1];\n+    }\n \n   /* If insn is effectively movd N(sp),-(sp) then we will do the\n      high word first.  We should use the adjusted operand 1 (which is N+4(sp))\n@@ -989,13 +1076,24 @@ output_move_double (operands)\n \n   if (optype0 == PUSHOP || optype1 == PUSHOP\n       || (optype0 == REGOP && optype1 == REGOP\n-\t  && REGNO (operands[0]) == REGNO (latehalf[1])))\n+\t  && ((middlehalf[1] && REGNO (operands[0]) == REGNO (middlehalf[1]))\n+\t      || REGNO (operands[0]) == REGNO (latehalf[1]))))\n     {\n       /* Make any unoffsettable addresses point at high-numbered word.  */\n       if (addreg0)\n-\toutput_asm_insn (\"addql %#4,%0\", &addreg0);\n+\t{\n+\t  if (size == 12)\n+\t    output_asm_insn (\"addql %#8,%0\", &addreg0);\n+\t  else\n+\t    output_asm_insn (\"addql %#4,%0\", &addreg0);\n+\t}\n       if (addreg1)\n-\toutput_asm_insn (\"addql %#4,%0\", &addreg1);\n+\t{\n+\t  if (size == 12)\n+\t    output_asm_insn (\"addql %#8,%0\", &addreg1);\n+\t  else\n+\t    output_asm_insn (\"addql %#4,%0\", &addreg1);\n+\t}\n \n       /* Do that word.  */\n       output_asm_insn (singlemove_string (latehalf), latehalf);\n@@ -1006,6 +1104,15 @@ output_move_double (operands)\n       if (addreg1)\n \toutput_asm_insn (\"subql %#4,%0\", &addreg1);\n \n+      if (size == 12)\n+\t{\n+\t  output_asm_insn (singlemove_string (middlehalf), middlehalf);\n+\t  if (addreg0)\n+\t    output_asm_insn (\"subql %#4,%0\", &addreg0);\n+\t  if (addreg1)\n+\t    output_asm_insn (\"subql %#4,%0\", &addreg1);\n+\t}\n+\n       /* Do low-numbered word.  */\n       return singlemove_string (operands);\n     }\n@@ -1014,6 +1121,17 @@ output_move_double (operands)\n \n   output_asm_insn (singlemove_string (operands), operands);\n \n+  /* Do the middle one of the three words for long double */\n+  if (size == 12)\n+    {\n+      if (addreg0)\n+\toutput_asm_insn (\"addql %#4,%0\", &addreg0);\n+      if (addreg1)\n+\toutput_asm_insn (\"addql %#4,%0\", &addreg1);\n+\n+      output_asm_insn (singlemove_string (middlehalf), middlehalf);\n+    }\n+\n   /* Make any unoffsettable addresses point at high-numbered word.  */\n   if (addreg0)\n     output_asm_insn (\"addql %#4,%0\", &addreg0);\n@@ -1025,9 +1143,19 @@ output_move_double (operands)\n \n   /* Undo the adds we just did.  */\n   if (addreg0)\n-    output_asm_insn (\"subql %#4,%0\", &addreg0);\n+    {\n+      if (size == 12)\n+        output_asm_insn (\"subql %#8,%0\", &addreg0);\n+      else\n+        output_asm_insn (\"subql %#4,%0\", &addreg0);\n+    }\n   if (addreg1)\n-    output_asm_insn (\"subql %#4,%0\", &addreg1);\n+    {\n+      if (size == 12)\n+        output_asm_insn (\"subql %#8,%0\", &addreg1);\n+      else\n+        output_asm_insn (\"subql %#4,%0\", &addreg1);\n+    }\n \n   return \"\";\n }"}]}