{"sha": "2e14a41b63bb3ac89e91b85e58ae3d0f3e3798c9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmUxNGE0MWI2M2JiM2FjODllOTFiODVlNThhZTNkMGYzZTM3OThjOQ==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@cygnus.com", "date": "1998-05-05T00:44:36Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-05-05T00:44:36Z"}, "message": "i386.c (output_fix_trunc): Add code to emulate non-popping DImode case.\n\n        * i386.c (output_fix_trunc): Add code to emulate non-popping DImode\n        case.\n\nFrom-SVN: r19538", "tree": {"sha": "5e64e512121f84b885b6d4e82b04b218c81115f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e64e512121f84b885b6d4e82b04b218c81115f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e14a41b63bb3ac89e91b85e58ae3d0f3e3798c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e14a41b63bb3ac89e91b85e58ae3d0f3e3798c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e14a41b63bb3ac89e91b85e58ae3d0f3e3798c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e14a41b63bb3ac89e91b85e58ae3d0f3e3798c9/comments", "author": null, "committer": null, "parents": [{"sha": "fd34c882b9d23ef58b1bdf6ebd66d0d796ffbf79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd34c882b9d23ef58b1bdf6ebd66d0d796ffbf79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd34c882b9d23ef58b1bdf6ebd66d0d796ffbf79"}], "stats": {"total": 19, "additions": 17, "deletions": 2}, "files": [{"sha": "cb23598d74c7dbdc2a3137e30bf2d8fed4c53b12", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e14a41b63bb3ac89e91b85e58ae3d0f3e3798c9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e14a41b63bb3ac89e91b85e58ae3d0f3e3798c9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2e14a41b63bb3ac89e91b85e58ae3d0f3e3798c9", "patch": "@@ -1,3 +1,8 @@\n+Tue May  5 01:43:16 1998  Jim Wilson  <wilson@cygnus.com>\n+\n+\t* i386.c (output_fix_trunc): Add code to emulate non-popping DImode\n+\tcase.\n+\n Tue May  5 01:15:06 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* reorg.c (fill_slots_from_thread): Update REG_DEAD/REG_UNUSED notes"}, {"sha": "73ca40cc50118058bfbcb27b84da5b05ce375a0d", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e14a41b63bb3ac89e91b85e58ae3d0f3e3798c9/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e14a41b63bb3ac89e91b85e58ae3d0f3e3798c9/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=2e14a41b63bb3ac89e91b85e58ae3d0f3e3798c9", "patch": "@@ -3943,8 +3943,7 @@ output_fix_trunc (insn, operands)\n   int stack_top_dies = find_regno_note (insn, REG_DEAD, FIRST_STACK_REG) != 0;\n   rtx xops[2];\n \n-  if (! STACK_TOP_P (operands[1])\n-      || (GET_MODE (operands[0]) == DImode && ! stack_top_dies))\n+  if (! STACK_TOP_P (operands[1]))\n     abort ();\n \n   xops[0] = GEN_INT (12);\n@@ -3963,6 +3962,17 @@ output_fix_trunc (insn, operands)\n     {\n       if (stack_top_dies)\n \toutput_asm_insn (AS1 (fistp%z0,%0), operands);\n+      else if (GET_MODE (operands[0]) == DImode && ! stack_top_dies)\n+\t{\n+\t  /* There is no DImode version of this without a stack pop, so\n+\t     we must emulate it.  It doesn't matter much what the second\n+\t     instruction is, because the value being pushed on the FP stack\n+\t     is not used except for the following stack popping store.\n+\t     This case can only happen without optimization, so it doesn't\n+\t     matter that it is inefficient.  */\n+\t  output_asm_insn (AS1 (fistp%z0,%0), operands);\n+\t  output_asm_insn (AS1 (fild%z0,%0), operands);\n+\t}\n       else\n \toutput_asm_insn (AS1 (fist%z0,%0), operands);\n     }"}]}