{"sha": "fa5322fa5824e95a7aa82413782b510c8d91e7d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmE1MzIyZmE1ODI0ZTk1YTdhYTgyNDEzNzgyYjUxMGM4ZDkxZTdkOA==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2002-02-09T03:08:08Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2002-02-09T03:08:08Z"}, "message": "Contribute sh64-elf.\n\n2002-02-09  Alexandre Oliva  <aoliva@redhat.com>\n* config/sh/sh.c (TARGET_CANNOT_MODIFY_JUMPS_P): Define to...\n(sh_cannot_modify_jumps_p): New function.\n2002-02-05  Alexandre Oliva  <aoliva@redhat.com>\n* config/sh/sh.c (TARGET_MS_BITFIELD_LAYOUT_P): Define to...\n(sh_ms_bitfield_layout_p): New function.\n2002-02-04  Alexandre Oliva  <aoliva@redhat.com>\n\t    Zack Weinberg  <zack@codesourcery.com>\n* config/sh/sh.h (TRAMPOLINE_ADJUST_ADDRESS): Use\nexpand_simple_binop instead of expand_binop.\n2002-02-03  Alexandre Oliva  <aoliva@redhat.com>\n* config/sh/sh.h (OVERRIDE_OPTIONS) [! TARGET_SH5]: Disable\nuse of .quad and .uaquad.\n* config/sh/sh.c (TARGET_ASM_UNALIGNED_DI_OP,\nTARGET_ASM_ALIGNED_DI_OP): Add comment pointing to the above.\n2002-01-24  Alexandre Oliva  <aoliva@redhat.com>\n* config/sh/sh.md (movdi_const, movdi_const_32bit,\nmovdi_const_16bit): Make sure all CONSTs have modes.\n(sym2PIC): Ditto, but by adjusting all callers.\n* config/sh/sh.c (calc_live_regs) [TARGET_SHCOMPACT]: Set pr_live\nif the prologue calls the SHmedia argument decoder or register\nsaver.\n2002-01-24  Alexandre Oliva  <aoliva@redhat.com>\n* config/sh/sh.c (TARGET_ASM_UNALIGNED_DI_OP): Define.\n(TARGET_ASM_ALIGNED_DI_OP): Likewise.\n(sh_expand_epilogue): Don't emit USE of return target register.\n(prepare_move_operands): Legitimize DImode PIC addresses.\n(sh_media_register_for_return): Skip tr0, used to initialize the\nPIC register.\n(sh_expand_prologue): Remove explicit USE of return register.\n(nonpic_symbol_mentioned_p): PC is non-PIC.  Don't recurse in\nCONST_DOUBLEs.  UNSPEC_GOTPLT is PIC.\n* config/sh/sh.h (ASM_OUTPUT_DOUBLE_INT): Removed, obsolete.\n(OVERRIDE_OPTIONS): Don't disable PIC on SH5.\n(EXTRA_CONSTRAINT_S): Use MOVI_SHORI_BASE_OPERAND_P instead of\nEXTRA_CONSTRAINT_T.\n(GOT_ENTRY_P, GOTPLT_ENTRY_P, GOTOFF_P, PIC_ADDR_P): New.\n(MOVI_SHORI_BASE_OPERAND_P): New.\n(NON_PIC_REFERENCE_P, PIC_REFERENCE_P): New.\n(EXTRA_CONSTRAINT_T): Define in terms of them.\n(OUTPUT_ADDR_CONST_EXTRA): Handle UNSPEC_GOTPLT.\n* config/sh/sh.md (movsi_media, movsi_media_nofpu,\nmovdi_media, movdi_media_nofpu): Add SIBCALL_REGS class to\nalternatives supporting TARGET_REGS.\n(UNSPEC_GOTPLT): New constant.\n(movdi split): Move incrementing of LABEL_NUSES...\n(movdi_const, movdi_const_32bit): Here.  Use\nMOVI_SHORI_BASE_OPERAND_P instead of EXTRA_CONSTRAINT_T.\n(movdi_const_16bit): New.\n(call, call_value) [flag_pic]: Use GOTPLT.\n(call_pop, call_value_pop): New expands.\n(call_pop_compact, call_pop_rettramp): New insns.\n(call_value_pop_compact, call_value_pop_rettramp): New insns.\n(sibcall) [flag_pic]: Use GOT.\n(builtint_setjmp_receiver): Remove bogus, unused expand.\n(GOTaddr2picreg): Implement for SHcompact and SHmedia.\n(*pt, *ptb, ptrel): New insns.\n(sym2GOT): Handle DImode GOT.\n(sym2GOTPLT, symGOTPLT2reg): New expands.\n(sym2PIC): New expand.\n(shcompact_return_tramp): Use GOTPLT to return trampoline.\n(shcompact_return_tramp_i): Use return register explicitly.\n* config/sh/sh.h (OVERRIDE_OPTIONS) [TARGET_SHMEDIA]: Don't\ndisable flag_reorder_blocks.\n2002-01-19  Alexandre Oliva  <aoliva@redhat.com>\n* config/sh/sh.md (sibcall_compact): Reorder return, uses and\nclobbers, for clarity.\n(sibcall_epilogue) [TARGET_SHCOMPACT]: Mark saving and\nrestoring of r0 in macl as MAYBE_DEAD.\n2002-01-18  Alexandre Oliva  <aoliva@redhat.com>\n* config/sh/sh.h (LONG_DOUBLE_TYPE_SIZE): Define.\n* config/sh/sh.md (movv4sf_i, movv16sf_i): Fix uses of\nalter_subreg all over.\n(jump) [TARGET_SHMEDIA]: FAIL to create new jumps after\nreload, instead of emitting instructions that would require\nreloading.\n(casesi_load_media): Add missing modes.\n2001-11-09  Alexandre Oliva  <aoliva@redhat.com>\n* config/sh/sh.c (sh_expand_prologue): Mark the PIC register\nas used if the argument decoder is called.\n2001-08-28  Alexandre Oliva  <aoliva@redhat.com>\n* config/sh/sh.md (udivsi3, divsi3): Load libcall symbol name in\nPmode, then extend it to DImode if necessary.\n2001-08-28  Stephen Clarke  <Stephen.Clarke@st.com>\n* config/sh/sh.h (LEGITIMATE_CONSTANT_P): Don't accept DFmode\nconstants in FPU-enabled SHmedia, let them be loaded from memory.\n2001-08-28  Alexandre Oliva  <aoliva@redhat.com>\n* config/sh/sh.md (cmpeqdi_media, cmpgtdi_media, cmpgtudi_media):\nAdjust whitespace in assembly output templates.\n2001-08-28  Stephen Clarke  <Stephen.Clarke@st.com>\n* config/sh/sh.md (movdicc_false, movdicc_true, movdicc): Adjust\nmode of if_then_else.\n2001-08-04  Alexandre Oliva  <aoliva@redhat.com>\n* config/sh/sh64.h (CPP_DEFAULT_CPU_SPEC): Override definition in\nsh.h.\n2001-07-26  Andrew Haley  <aph@cambridge.redhat.com>\n\t    Joern Rennecke <amylaar@redhat.com>\n* config/sh/sh64.h (CPP_DEFAULT_CPU_SPEC): New.\n(SUBTARGET_CPP_PTR_SPEC): New.\n(SUBTARGET_CPP_SPEC): Remove.\n2001-07-06  Chandrakala Chavva  <cchavva@redhat.com>\n* config/sh/sh.md (movsf_media_nofpu+1, movdf_media_nofpu+1):\nFix typo in previous checkin.\n2001-07-11  Chandrakala Chavva  <cchavva@redhat.com>\n* config/sh/sh.h (MODES_TIEABLE_P): Fix redact indentations.\n2001-07-10  Chandrakala Chavva  <cchavva@cygnus.com>\n\t    Alexandre Oliva  <aoliva@redhat.com>\n* config/sh/sh.h (MODES_TIEABLE_P): Don't tie modes wider than\nwhat single FP register can hold for SHmedia target.\n2001-07-06  Chandrakala Chavva  <cchavva@redhat.com>\n\t    Alexandre Oliva  <aoliva@redhat.com>\n* config/sh/sh.md (movsf_media_nofpu+1, movdf_media_nofpu+1):\nDo not split into SUBREG.\n2001-06-14  Alexandre Oliva  <aoliva@redhat.com>\n* config/sh/ushmedia.h, config/sh/sshmedia.h: Updated signatures\nand added new functions as specified in SH5 ABI r9.\n2001-06-04  Alexandre Oliva  <aoliva@redhat.com>\n* config/sh/lib1funcs.asm (GCC_nested_trampoline): Align to an\n8-byte boundary.\n2001-06-03  Alexandre Oliva  <aoliva@redhat.com>\n* config/sh/sh.c (dump_table): Add const0_rtx in calls of\ngen_consttable_4 and gen_consttable_8.  Emit multiple labels\nand consttable_window_ends.\n2001-06-03  Graham Stott  <grahams@redhat,com>\n* config/sh/sh.md (movdi split): Remove unused variable last_insn.\n2001-05-16  Alexandre Oliva  <aoliva@redhat.com>\n* config/sh/sh.c (print_operand): Handle floating-point pair,\nvector and matrix registers.\n* config/sh/sh.h (REGISTER_MOVE_COST): Take floating-pointer\nvector modes into account.\n* config/sh/sh.md (movv2sf): Split move between registers into\nmovdf.\n(movv4sf, movv16sf): Introduce insns that get split only after\nreload.\n* config/sh/shmedia.h: Fix Copyright dates.\n* config/sh/ushmedia.h: Likewise.  Move loop counter\ndeclarations into conditionals that uses them.\n(sh_media_FVADD_S, sh_media_FVSUB_S): Fix off-by-one error in\nloop boundary.\n* config/sh/sshmedia.h: Fix Copyright dates.\n(sh_media_PUTCFG): Fix constraints.\n2001-05-12  Alexandre Oliva  <aoliva@redhat.com>\n* config/sh/sh.h (TARGET_PTRMEMFUNC_VBIT_LOCATION): Define to\nptrmemfunc_vbit_in_delta for SH5.\n2001-05-08  Alexandre Oliva  <aoliva@redhat.com>\n* config/sh/sh.h (TARGET_SWITCHES): Document -m5-*.\n* invoke.texi: Likewise.\n2001-04-14  Alexandre Oliva  <aoliva@redhat.com>\n* config/sh/lib1funcs.asm (GCC_push_shmedia_regs,\nGCC_push_shmedia_regs_nofpu, GCC_pop_shmedia_regs,\nGCC_pop_shmedia_regs_nofpu): New global symbols.\n* config/sh/t-sh64 (LIB1ASMFUNCS): Add them.\n* config/sh/sh.h (SHMEDIA_REGS_STACK_ADJUST): New macro.\n* config/sh/sh.c (calc_live_regs): Account for PR's saving in\ncompact function with nonlocal labels.\n(sh_expand_prologue) [SHcompact]: Push SHmedia regs if needed.\n(sh_expand_epilogue) [SHcompact]: Pop them when appropriate.\n(initial_elimination_offset): Account for their stack space.\n* config/sh/sh.md (shmedia_save_restore_regs_compact): New insn.\n* config/sh/sh.md (movsi_media, movsi_media_nofpu, movqi_media,\nmovhi_media, movdi_media, movdi_media_nofpu, movdf_media,\nmovdf_media_nofpu, movsf_media, movsf_media_nofpu): Require at\nleast one of the operands to be a register.\n(movv2sf): Likewise.  Renamed to movv2sf_i.\n(movdi, movdf, movv2sf, movv4sf, movv16sf, movsf):\nprepare_move_operands() before emitting SHmedia insns.\n2001-04-03  Alexandre Oliva  <aoliva@redhat.com>\n* config/sh/crti.asm (init, fini) [__SH5__ && ! __SHMEDIA__]:\nDon't save nor initialize r12.  Don't mis-align the stack.\nPad the code with a nop.\n* config/sh/crti.asm: Don't restore r12.  Don't mis-align the\nstack.\n2001-03-13  Alexandre Oliva  <aoliva@redhat.com>\n* gcc/longlong.h (__umulsidi3, count_leading_zeros)\n[__SHMEDIA__]: Implement.\n2001-03-11  Alexandre Oliva  <aoliva@redhat.com>\n* config/sh/sh.md: Set latency of `pt' closer to reality.\n(movsi_media, movsi_media_nofpu, movdi_media, movdi_media_nofpu,\nmovdf_media, movdf_media_nofpu, movsf_media, movsf_media_nofpu):\nSet move, load and store type attributes.\n* config/sh/sh.c (sh_loop_align) [TARGET_SH5]: Set to 3.\n* config/sh/sh.h (OVERRIDE_OPTIONS) [TARGET_SH5]: Disable\nprofiling.\n* config/sh/sh.h (PROMOTE_MODE): Sign-extend SImode to DImode.\n* config/sh/sh-protos.h (sh_media_register_for_return): Declare.\n* config/sh/sh.c (sh_media_register_for_return): New function.\n(sh_expand_prologue) [TARGET_SHMEDIA]: Copy r18 to an available\nbranch-target register.\n(sh_expand_epilogue) [TARGET_SHMEDIA]: Explicitly USE it.\n* config/sh/sh.md (return_media_i): Use any call-clobbered\nbranch-target register.\n(return_media): If r18 wasn't copied in the prologue, copy it\nhere.\n* config/sh/sh.h (CONDITIONAL_REGISTER_USAGE) [TARGET_SHMEDIA]:\nClear class FP0_REGS.\n* config/sh/sh64.h (LINK_SPEC): Removed incorrect default copied\nfrom elf.h.\n2001-03-08  DJ Delorie  <dj@redhat.com>\n* config/sh/sh.h (OVERRIDE_OPTIONS): Disable relaxing for SHMEDIA.\n2001-02-09  Alexandre Oliva  <aoliva@redhat.com>\n* config/sh/sh.md (sibcall_compact): Set fp_mode to single.\n2001-02-07  Alexandre Oliva  <aoliva@redhat.com>\n* config/sh/sh.h (INT_ASM_OP) [SHMEDIA64]: Use `.quad'.\n2001-02-03  Alexandre Oliva  <aoliva@redhat.com>\n* config/sh/sh.h (INIT_CUMULATIVE_ARGS): Compute size of BLKmode\nreturn value correctly for call_cookie.\n2001-02-01  Alexandre Oliva  <aoliva@redhat.com>\n* config/sh/crt1.asm (start): Modified so as to call\n___setup_argv_and_call_main.\n2001-01-26  Alexandre Oliva  <aoliva@redhat.com>\n* config/sh/sh.h (FUNCTION_ARG_ADVANCE): Don't count stack_regs in\nSHmedia mode.\n2001-01-20  Alexandre Oliva  <aoliva@redhat.com>\n* config/sh/sh.h (STRIP_DATALABEL_ENCODING): New macro.\n(STRIP_NAME_ENCODING): Use it.\n(ASM_OUTPUT_LABELREF): Likewise.  Don't call assemble_name().\n2001-01-19  Alexandre Oliva  <aoliva@redhat.com>\n* config/sh/sh.md (sgeu) [! SHMEDIA]: Fix invocation of\nprepare_scc_operands().\n* config/sh/sh.h (SH_DATALABEL_ENCODING): Change to \"#\"...\n(DATALABEL_SYMNAME_P): ... so that we don't need memcmp here.\n2001-01-17  Alexandre Oliva  <aoliva@redhat.com>\n* config/sh/sh.h (STRIP_NAME_ENCODING): Strip leading `*'.\n2001-01-13  Alexandre Oliva  <aoliva@redhat.com>\n* config/sh/sh.md (shcompact_incoming_args): Use R0_REG.\n* config/sh/sh.md (R7_REG, R8_REG, R9_REG): Define as constants,\nused in shcompact_incoming_args.\n* config/sh/sh.c (sh_expand_epilogue): Fix thinko in previous\nchange.\n* config/sh/crt1.asm (start) [SH5]: Switch to single-precision\nmode.\n* config/sh/lib1funcs.asm (sdivsi3_i4, udivsi3_i4, set_fpscr):\nAdjust accordingly.\n* config/sh/sh.c (sh_expand_prologue, sh_expand_epilogue):\nSimplify.  Adjust.  Add sanity check.\n* config/sh/sh.h (TARGET_SWITCHES) [5-compact]: Set\nFPU_SINGLE_BIT.\n* config/sh/sh.md (udivsi3_i4_single, divsi3_i4_single): Match\nTARGET_SHCOMPACT.\n(udivsi3, divsi3): Use them.\n(force_mode_for_call): New insn.\n(call, call_value, sibcall_value): Emit it before SHcompact\ncalls.\n2001-01-11  Alexandre Oliva  <aoliva@redhat.com>\n* config/sh/sh.md (call, call_value, sibcall): Make sure the\ncall cookie is non-NULL before taking its value.\n2001-01-10  Alexandre Oliva  <aoliva@redhat.com>\n* config.gcc (sh64): Set target_requires_64bit_host_wide_int.\n2001-01-09  Alexandre Oliva  <aoliva@redhat.com>\n* config/sh/sh.md (shcompact_incoming_args): Set argument memory\nblock.\n* config/sh/sh.h (STATIC_CHAIN_REGNUM) [SH5]: Use r1.\n* config/sh/sh.c (sh_expand_prologue) [SH5]: Use r0 as\ntemporary for stack adjusts.  Use MACL and MACH to pass\narguments to shcompact_incoming_args.\n* config/sh/sh.md (shcompact_incoming_args): Adjust.  Don't\nclobber r1.\n* config/sh/lib1funcs.asm (shcompact_incoming_args): Likewise.\n(nested_trampoline): Load static chain address into r1.\n* config/sh/sh.md (movdi_media splits): Fix sign-extension.\n2001-01-07  Alexandre Oliva  <aoliva@redhat.com\n* config/sh/sh.c (fpul_operand) [SHMEDIA]: Just call\nfp_arith_reg_operand().\n2001-01-06  Alexandre Oliva  <aoliva@redhat.com>\n* config/sh/sh.md (casesi): Sign-extend the first two operands,\nand use signed compares for them.\n* config/sh/sh.c (dump_table): Don't emit 8-byte constants after\n4-byte ones.  Instead, inter-leave them, maintaining the 8-byte\nones properly aligned.\n(find_barrier): Account for extra alignment needed for 8-byte wide\nconstants.\n(machine_dependent_reorg): Require a label for the second 4-byte\nconstant after an 8-byte one.\n* config/sh/lib1funcs.asm (sdivsi3): Fix typo in yesterday's\nchange.\n2001-01-05  Alexandre Oliva  <aoliva@redhat.com>\n* config/sh/sh.c (machine_dependent_reorg) [SHCOMPACT]: Reset\nlast_float when switching float modes.\n* config/sh/sh.md (movdf) [SH5]: Don't use stack-pointer\nauto-increment for general-purpose registers.\n* config/sh/lib1funcs.asm (sdivsi3) [SHMEDIA]: Sign-extend the\nresult.\n* config/sh/sh.c (sh_expand_prologue) [SH5]: Use r1 as temporary\nfor stack adjust.\n* config/sh/sh.c (sh_builtin_saveregs): Support using all\nregisters for varargs.\n2001-01-01  Alexandre Oliva  <aoliva@redhat.com>\n* config/sh/sh.h (FUNCTION_ARG_ADVANCE): Simplify.\n* config/sh/sh.h (CALL_COOKIE_STACKSEQ,\nCALL_COOKIE_STACKSEQ_SHIFT, CALL_COOKIE_STACKSEQ_GET): New macros.\n(CALL_COOKIE_INT_REG_SHIFT): Adjust.\n(FUNCTION_ARG_ADVANCE): Use SHCOMPACT_FORCE_ON_STACK.  Adjust\ncall_cookie accordingly.\n(FUNCTION_ARG): Test SHCOMPACT_FORCE_ON_STACK.\n(SHCOMPACT_BYREF): Likewise.\n(SHCOMPACT_FORCE_ON_STACK): New macro.\n* config/sh/sh.c (sh_expand_prologue): Use new call_cookie format.\n(sh_builtin_saveregs): Likewise.\n* config/sh/lib1funcs.asm (shcompact_call_trampoline,\nshcompact_incoming_args): Use new shift values.  Support\nsequences of consecutive and non-consecutive pushes/pops.\n* config/sh/sh.md (return): Don't explicitly use PR_REG.\n2001-01-05  Hans-Peter Nilsson  <hpn@cygnus.com>\n* config/sh/sh.h (TEXT_SECTION): Define.\n* config/sh/elf.h (ASM_FILE_START): Output TEXT_SECTION_ASM_OP.\n2001-01-05  Alexandre Oliva  <aoliva@redhat.com>\n* config/sh/sh.h (INIT_CUMULATIVE_LIBCALL_ARGS): New macro.\n* config/sh/sh.h (BASE_RETURN_VALUE_REG): Use FP regs for\nreturn values on FPU-enabled SHmedia.\n(FUNCTION_VALUE_REGNO_P): Mark FIRST_FP_RET_REG as used on\nFPU-enabled SHmedia.\n(INIT_CUMULATIVE_ARGS): Set up return trampoline only if\nvalue is returned in a non-FP reg and is not returned by\nreference.\n* config/sh/sh.md (shcompact_return_tramp_i): Change type to\njump_ind.\n2000-01-04  Alexandre Oliva  <aoliva@redhat.com>\n* config/sh/sh.h (SH_MIN_ALIGN_FOR_CALLEE_COPY): New.\n(FUNCTION_ARG_CALLEE_COPIES): Require argument to be\nquad-aligned to be passed by callee-copy reference.\n2001-01-03  Alexandre Oliva  <aoliva@redhat.com>\n* config/sh/elf.h (MAX_WCHAR_TYPE_SIZE): Define.\n* config/sh/sh64.h (MAX_WCHAR_TYPE_SIZE): Undefine.\n2001-01-02  Alexandre Oliva  <aoliva@redhat.com>\n* config/sh/lib1funcs.asm (shcompact_call_trampoline): Fix error in\ncopying low-numbered FP regs to r7 and r8.\n* config/sh/sh.h (FUNCTION_ARG_ADVANCE): Don't request copying of\nFP regs to general-purpose regs only if the copy was passed on the\nstack.\n* config/sh/lib1funcs.asm (shcompact_call_trampoline): Fix typo in\ncopying FP reg to r9.\n* config/sh/sh.h (FUNCTION_ARG_ADVANCE): Use trampoline to\ncopy FP regs to general-purpose regs only in outgoing calls.\n* config/sh/sh.md (movdf_media, movsf_media): Revert incorrect\nchange from \t2000-10-30.  Adjust for 64-bit (or 32-bit)\nHOST_WIDE_INT.\n* config/sh/sh.h (struct sh_args): Document all fields.\n(FUNCTION_OK_FOR_SIBCALL): Functions that receive arguments\npassed partially on the stack should not consider making\nsibcalls.\n* config/sh/sh.h (FUNCTION_ARG_ADVANCE): Add byref regs to\nstack_regs only for incoming calls.  When passing FP args,\nmake sure there are FP regs available before modifying\ncall_cookie.\n(SHCOMPACT_BYREF): Pass double args in general-purpose\nregisters by reference.\n2000-12-30  Alexandre Oliva  <aoliva@redhat.com>\n* config/sh/sh.h (FUNCTION_OK_FOR_SIBCALL) [SHCOMPACT]: Don't\nattempt to generate sibcalls if the caller got any arguments\nby reference.\n* config/sh/lib1funcs.asm (set_fpscr) [SH5]: Default to double.\n* config/sh/sh.c (dump_table) [SHCOMPACT]: Align DImode and DFmode\nto 8-byte boundaries.\n* config/sh/sh.md (shcompact_preserve_incoming_args): New insn.\n* config/sh/sh.h (CALL_COOKIE_INT_REG_GET): New macro.\n* config/sh/sh.c (sh_expand_prologue): Preserve args that will be\nstored in the stack.\n* config/sh/lib1funcs.asm (ct_main_table, ia_main_table): Arrange\nfor the offsets to have the ISA bit set.\n(shcompact_call_trampoline): Document.  Swap r0 and r1, to match\ninvocation.  Use beq instead of bgt to mark end of sequence of\nloads.\n(shcompact_incoming_args): Fix store of r2.  Use beq instead of\nbgt to mark end of sequence of stores.\n* config/sh/sh.c (arith_operand): Don't check whether\nCONST_OK_FOR_J for now.\n* config/sh/sh.md (movdf_media, movsf_media): Use HOST_WIDE_INT\ninstead of long for conversion.\n2000-12-29  Alexandre Oliva  <aoliva@redhat.com>\n* config/sh/sh.c (print_operand_address): Convert INTVAL to int\nbefore passing it to fprintf.\n2000-12-28  Alexandre Oliva  <aoliva@redhat.com>\n* config/sh/crt1.asm (start): Reset SR.FD, to enable the FP unit.\nCall set_fpscr before reading/writing SR.\n* config/sh/crt1.asm (start): Set SR.SZ and SR.PR, but not SR.FR.\nCall set_fpscr.\n* config/sh/lib1funcs.asm: Add `.align 2' directives before\nSHmedia code.\n(FMOVD_WORKS): Define on SH5 with FPU.\n(set_fpscr): Define on SH5.  Remove separate _fpscr_values\nsetting.\n* config/sh/t-sh64 (LIB1ASMFUNCS): Add _set_fpscr instead of\n_fpscr_values.\n2000-12-28  Hans-Peter Nilsson  <hpn@cygnus.com>\n* config/sh/lib1funcs.asm (ct_main_table): Align contents to even\naddress.\n(ia_main_table): Ditto.\n2000-12-27  Alexandre Oliva  <aoliva@redhat.com>\n* config/sh/sh.h (MAX_WCHAR_TYPE_SIZE): Don't define.\n* config/sh/sh64.h (WCHAR_TYPE, WCHAR_TYPE_SIZE): Reinstate\nthe definitions from sh.h.\n* config/sh/sh.h (PTRDIFF_TYPE): Define as conditional on\nTARGET_SH5.\n(SUBTARGET_CPP_SPEC): Arrange for __PTRDIFF_TYPE__ to be defined.\n* config/sh/elf.h (PTRDIFF_TYPE): Likewise.\n* config/sh/sh64.h (SUBTARGET_CPP_SPEC): Likewise.\n2000-12-26  Alexandre Oliva  <aoliva@redhat.com>\n* config/sh/sh.md (movdi_media split): Don't add REG_LABEL notes.\nIncrement LABEL_NUSES.\n\nFrom-SVN: r49630", "tree": {"sha": "d0a27ffe9a822025fe0fa1929bfd170fabd4723e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d0a27ffe9a822025fe0fa1929bfd170fabd4723e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa5322fa5824e95a7aa82413782b510c8d91e7d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa5322fa5824e95a7aa82413782b510c8d91e7d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa5322fa5824e95a7aa82413782b510c8d91e7d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa5322fa5824e95a7aa82413782b510c8d91e7d8/comments", "author": null, "committer": null, "parents": [{"sha": "7aa00daf451b0cb94479991499fc74e33fd90582", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7aa00daf451b0cb94479991499fc74e33fd90582", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7aa00daf451b0cb94479991499fc74e33fd90582"}], "stats": {"total": 9987, "additions": 9313, "deletions": 674}, "files": [{"sha": "6d0d26798b3586cd86e357f66b7d9a1c26900c09", "filename": "gcc/ChangeLog", "status": "modified", "additions": 883, "deletions": 0, "changes": 883, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa5322fa5824e95a7aa82413782b510c8d91e7d8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa5322fa5824e95a7aa82413782b510c8d91e7d8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fa5322fa5824e95a7aa82413782b510c8d91e7d8", "patch": "@@ -1,5 +1,888 @@\n 2002-02-09  Alexandre Oliva  <aoliva@redhat.com>\n \n+\tContribute sh64-elf.\n+\t2002-02-09  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.c (TARGET_CANNOT_MODIFY_JUMPS_P): Define to...\n+\t(sh_cannot_modify_jumps_p): New function.\n+\t2002-02-05  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.c (TARGET_MS_BITFIELD_LAYOUT_P): Define to...\n+\t(sh_ms_bitfield_layout_p): New function.\n+\t2002-02-04  Alexandre Oliva  <aoliva@redhat.com>\n+\t\t    Zack Weinberg  <zack@codesourcery.com>\n+\t* config/sh/sh.h (TRAMPOLINE_ADJUST_ADDRESS): Use\n+\texpand_simple_binop instead of expand_binop.\n+\t2002-02-03  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.h (OVERRIDE_OPTIONS) [! TARGET_SH5]: Disable\n+\tuse of .quad and .uaquad.\n+\t* config/sh/sh.c (TARGET_ASM_UNALIGNED_DI_OP,\n+\tTARGET_ASM_ALIGNED_DI_OP): Add comment pointing to the above.\n+\t2002-01-24  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.md (movdi_const, movdi_const_32bit,\n+\tmovdi_const_16bit): Make sure all CONSTs have modes.\n+\t(sym2PIC): Ditto, but by adjusting all callers.\n+\t* config/sh/sh.c (calc_live_regs) [TARGET_SHCOMPACT]: Set pr_live\n+\tif the prologue calls the SHmedia argument decoder or register\n+\tsaver.\n+\t2002-01-24  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.c (TARGET_ASM_UNALIGNED_DI_OP): Define.\n+\t(TARGET_ASM_ALIGNED_DI_OP): Likewise.\n+\t(sh_expand_epilogue): Don't emit USE of return target register.\n+\t(prepare_move_operands): Legitimize DImode PIC addresses.\n+\t(sh_media_register_for_return): Skip tr0, used to initialize the\n+\tPIC register.\n+\t(sh_expand_prologue): Remove explicit USE of return register.\n+\t(nonpic_symbol_mentioned_p): PC is non-PIC.  Don't recurse in\n+\tCONST_DOUBLEs.  UNSPEC_GOTPLT is PIC.\n+\t* config/sh/sh.h (ASM_OUTPUT_DOUBLE_INT): Removed, obsolete.\n+\t(OVERRIDE_OPTIONS): Don't disable PIC on SH5.\n+\t(EXTRA_CONSTRAINT_S): Use MOVI_SHORI_BASE_OPERAND_P instead of\n+\tEXTRA_CONSTRAINT_T.\n+\t(GOT_ENTRY_P, GOTPLT_ENTRY_P, GOTOFF_P, PIC_ADDR_P): New.\n+\t(MOVI_SHORI_BASE_OPERAND_P): New.\n+\t(NON_PIC_REFERENCE_P, PIC_REFERENCE_P): New.\n+\t(EXTRA_CONSTRAINT_T): Define in terms of them.\n+\t(OUTPUT_ADDR_CONST_EXTRA): Handle UNSPEC_GOTPLT.\n+\t* config/sh/sh.md (movsi_media, movsi_media_nofpu,\n+\tmovdi_media, movdi_media_nofpu): Add SIBCALL_REGS class to\n+\talternatives supporting TARGET_REGS.\n+\t(UNSPEC_GOTPLT): New constant.\n+\t(movdi split): Move incrementing of LABEL_NUSES...\n+\t(movdi_const, movdi_const_32bit): Here.  Use\n+\tMOVI_SHORI_BASE_OPERAND_P instead of EXTRA_CONSTRAINT_T.\n+\t(movdi_const_16bit): New.\n+\t(call, call_value) [flag_pic]: Use GOTPLT.\n+\t(call_pop, call_value_pop): New expands.\n+\t(call_pop_compact, call_pop_rettramp): New insns.\n+\t(call_value_pop_compact, call_value_pop_rettramp): New insns.\n+\t(sibcall) [flag_pic]: Use GOT.\n+\t(builtint_setjmp_receiver): Remove bogus, unused expand.\n+\t(GOTaddr2picreg): Implement for SHcompact and SHmedia.\n+\t(*pt, *ptb, ptrel): New insns.\n+\t(sym2GOT): Handle DImode GOT.\n+\t(sym2GOTPLT, symGOTPLT2reg): New expands.\n+\t(sym2PIC): New expand.\n+\t(shcompact_return_tramp): Use GOTPLT to return trampoline.\n+\t(shcompact_return_tramp_i): Use return register explicitly.\n+\t* config/sh/sh.h (OVERRIDE_OPTIONS) [TARGET_SHMEDIA]: Don't\n+\tdisable flag_reorder_blocks.\n+\t2002-01-19  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.md (sibcall_compact): Reorder return, uses and\n+\tclobbers, for clarity.\n+\t(sibcall_epilogue) [TARGET_SHCOMPACT]: Mark saving and\n+\trestoring of r0 in macl as MAYBE_DEAD.\n+\t2002-01-18  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.h (LONG_DOUBLE_TYPE_SIZE): Define.\n+\t* config/sh/sh.md (movv4sf_i, movv16sf_i): Fix uses of\n+\talter_subreg all over.\n+\t(jump) [TARGET_SHMEDIA]: FAIL to create new jumps after\n+\treload, instead of emitting instructions that would require\n+\treloading.\n+\t(casesi_load_media): Add missing modes.\n+\t2001-11-09  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.c (sh_expand_prologue): Mark the PIC register\n+\tas used if the argument decoder is called.\n+\t2001-08-28  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.md (udivsi3, divsi3): Load libcall symbol name in\n+\tPmode, then extend it to DImode if necessary.\n+\t2001-08-28  Stephen Clarke  <Stephen.Clarke@st.com>\n+\t* config/sh/sh.h (LEGITIMATE_CONSTANT_P): Don't accept DFmode\n+\tconstants in FPU-enabled SHmedia, let them be loaded from memory.\n+\t2001-08-28  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.md (cmpeqdi_media, cmpgtdi_media, cmpgtudi_media):\n+\tAdjust whitespace in assembly output templates.\n+\t2001-08-28  Stephen Clarke  <Stephen.Clarke@st.com>\n+\t* config/sh/sh.md (movdicc_false, movdicc_true, movdicc): Adjust\n+\tmode of if_then_else.\n+\t2001-08-04  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh64.h (CPP_DEFAULT_CPU_SPEC): Override definition in\n+\tsh.h.\n+\t2001-07-26  Andrew Haley  <aph@cambridge.redhat.com>\n+\t\t    Joern Rennecke <amylaar@redhat.com>\n+\t* config/sh/sh64.h (CPP_DEFAULT_CPU_SPEC): New.\n+\t(SUBTARGET_CPP_PTR_SPEC): New.\n+\t(SUBTARGET_CPP_SPEC): Remove.\n+\t2001-07-06  Chandrakala Chavva  <cchavva@redhat.com>\n+\t* config/sh/sh.md (movsf_media_nofpu+1, movdf_media_nofpu+1):\n+\tFix typo in previous checkin.\n+\t2001-07-11  Chandrakala Chavva  <cchavva@redhat.com>\n+\t* config/sh/sh.h (MODES_TIEABLE_P): Fix redact indentations.\n+\t2001-07-10  Chandrakala Chavva  <cchavva@cygnus.com>\n+\t\t    Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.h (MODES_TIEABLE_P): Don't tie modes wider than\n+\twhat single FP register can hold for SHmedia target.\n+\t2001-07-06  Chandrakala Chavva  <cchavva@redhat.com>\n+\t\t    Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.md (movsf_media_nofpu+1, movdf_media_nofpu+1):\n+\tDo not split into SUBREG.\n+\t2001-06-14  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/ushmedia.h, config/sh/sshmedia.h: Updated signatures\n+\tand added new functions as specified in SH5 ABI r9.\n+\t2001-06-04  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/lib1funcs.asm (GCC_nested_trampoline): Align to an\n+\t8-byte boundary.\n+\t2001-06-03  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.c (dump_table): Add const0_rtx in calls of\n+\tgen_consttable_4 and gen_consttable_8.  Emit multiple labels\n+\tand consttable_window_ends.\n+\t2001-06-03  Graham Stott  <grahams@redhat,com>\n+\t* config/sh/sh.md (movdi split): Remove unused variable last_insn.\n+\t2001-05-16  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.c (print_operand): Handle floating-point pair,\n+\tvector and matrix registers.\n+\t* config/sh/sh.h (REGISTER_MOVE_COST): Take floating-pointer\n+\tvector modes into account.\n+\t* config/sh/sh.md (movv2sf): Split move between registers into\n+\tmovdf.\n+\t(movv4sf, movv16sf): Introduce insns that get split only after\n+\treload.\n+\t* config/sh/shmedia.h: Fix Copyright dates.\n+\t* config/sh/ushmedia.h: Likewise.  Move loop counter\n+\tdeclarations into conditionals that uses them.\n+\t(sh_media_FVADD_S, sh_media_FVSUB_S): Fix off-by-one error in\n+\tloop boundary.\n+\t* config/sh/sshmedia.h: Fix Copyright dates.\n+\t(sh_media_PUTCFG): Fix constraints.\n+\t2001-05-12  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.h (TARGET_PTRMEMFUNC_VBIT_LOCATION): Define to\n+\tptrmemfunc_vbit_in_delta for SH5.\n+\t2001-05-08  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.h (TARGET_SWITCHES): Document -m5-*.\n+\t* invoke.texi: Likewise.\n+\t2001-04-14  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/lib1funcs.asm (GCC_push_shmedia_regs,\n+\tGCC_push_shmedia_regs_nofpu, GCC_pop_shmedia_regs,\n+\tGCC_pop_shmedia_regs_nofpu): New global symbols.\n+\t* config/sh/t-sh64 (LIB1ASMFUNCS): Add them.\n+\t* config/sh/sh.h (SHMEDIA_REGS_STACK_ADJUST): New macro.\n+\t* config/sh/sh.c (calc_live_regs): Account for PR's saving in\n+\tcompact function with nonlocal labels.\n+\t(sh_expand_prologue) [SHcompact]: Push SHmedia regs if needed.\n+\t(sh_expand_epilogue) [SHcompact]: Pop them when appropriate.\n+\t(initial_elimination_offset): Account for their stack space.\n+\t* config/sh/sh.md (shmedia_save_restore_regs_compact): New insn.\n+\t* config/sh/sh.md (movsi_media, movsi_media_nofpu, movqi_media,\n+\tmovhi_media, movdi_media, movdi_media_nofpu, movdf_media,\n+\tmovdf_media_nofpu, movsf_media, movsf_media_nofpu): Require at\n+\tleast one of the operands to be a register.\n+\t(movv2sf): Likewise.  Renamed to movv2sf_i.\n+\t(movdi, movdf, movv2sf, movv4sf, movv16sf, movsf):\n+\tprepare_move_operands() before emitting SHmedia insns.\n+\t2001-04-03  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/crti.asm (init, fini) [__SH5__ && ! __SHMEDIA__]:\n+\tDon't save nor initialize r12.  Don't mis-align the stack.\n+\tPad the code with a nop.\n+\t* config/sh/crti.asm: Don't restore r12.  Don't mis-align the\n+\tstack.\n+\t2001-03-13  Alexandre Oliva  <aoliva@redhat.com>\n+\t* gcc/longlong.h (__umulsidi3, count_leading_zeros)\n+\t[__SHMEDIA__]: Implement.\n+\t2001-03-11  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.md: Set latency of `pt' closer to reality.\n+\t(movsi_media, movsi_media_nofpu, movdi_media, movdi_media_nofpu,\n+\tmovdf_media, movdf_media_nofpu, movsf_media, movsf_media_nofpu):\n+\tSet move, load and store type attributes.\n+\t* config/sh/sh.c (sh_loop_align) [TARGET_SH5]: Set to 3.\n+\t* config/sh/sh.h (OVERRIDE_OPTIONS) [TARGET_SH5]: Disable\n+\tprofiling.\n+\t* config/sh/sh.h (PROMOTE_MODE): Sign-extend SImode to DImode.\n+\t* config/sh/sh-protos.h (sh_media_register_for_return): Declare.\n+\t* config/sh/sh.c (sh_media_register_for_return): New function.\n+\t(sh_expand_prologue) [TARGET_SHMEDIA]: Copy r18 to an available\n+\tbranch-target register.\n+\t(sh_expand_epilogue) [TARGET_SHMEDIA]: Explicitly USE it.\n+\t* config/sh/sh.md (return_media_i): Use any call-clobbered\n+\tbranch-target register.\n+\t(return_media): If r18 wasn't copied in the prologue, copy it\n+\there.\n+\t* config/sh/sh.h (CONDITIONAL_REGISTER_USAGE) [TARGET_SHMEDIA]:\n+\tClear class FP0_REGS.\n+\t* config/sh/sh64.h (LINK_SPEC): Removed incorrect default copied\n+\tfrom elf.h.\n+\t2001-03-08  DJ Delorie  <dj@redhat.com>\n+\t* config/sh/sh.h (OVERRIDE_OPTIONS): Disable relaxing for SHMEDIA.\n+\t2001-02-09  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.md (sibcall_compact): Set fp_mode to single.\n+\t2001-02-07  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.h (INT_ASM_OP) [SHMEDIA64]: Use `.quad'.\n+\t2001-02-03  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.h (INIT_CUMULATIVE_ARGS): Compute size of BLKmode\n+\treturn value correctly for call_cookie.\n+\t2001-02-01  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/crt1.asm (start): Modified so as to call\n+\t___setup_argv_and_call_main.\n+\t2001-01-26  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.h (FUNCTION_ARG_ADVANCE): Don't count stack_regs in\n+\tSHmedia mode.\n+\t2001-01-20  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.h (STRIP_DATALABEL_ENCODING): New macro.\n+\t(STRIP_NAME_ENCODING): Use it.\n+\t(ASM_OUTPUT_LABELREF): Likewise.  Don't call assemble_name().\n+\t2001-01-19  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.md (sgeu) [! SHMEDIA]: Fix invocation of\n+\tprepare_scc_operands().\n+\t* config/sh/sh.h (SH_DATALABEL_ENCODING): Change to \"#\"...\n+\t(DATALABEL_SYMNAME_P): ... so that we don't need memcmp here.\n+\t2001-01-17  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.h (STRIP_NAME_ENCODING): Strip leading `*'.\n+\t2001-01-13  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.md (shcompact_incoming_args): Use R0_REG.\n+\t* config/sh/sh.md (R7_REG, R8_REG, R9_REG): Define as constants,\n+\tused in shcompact_incoming_args.\n+\t* config/sh/sh.c (sh_expand_epilogue): Fix thinko in previous\n+\tchange.\n+\t* config/sh/crt1.asm (start) [SH5]: Switch to single-precision\n+\tmode.\n+\t* config/sh/lib1funcs.asm (sdivsi3_i4, udivsi3_i4, set_fpscr):\n+\tAdjust accordingly.\n+\t* config/sh/sh.c (sh_expand_prologue, sh_expand_epilogue):\n+\tSimplify.  Adjust.  Add sanity check.\n+\t* config/sh/sh.h (TARGET_SWITCHES) [5-compact]: Set\n+\tFPU_SINGLE_BIT.\n+\t* config/sh/sh.md (udivsi3_i4_single, divsi3_i4_single): Match\n+\tTARGET_SHCOMPACT.\n+\t(udivsi3, divsi3): Use them.\n+\t(force_mode_for_call): New insn.\n+\t(call, call_value, sibcall_value): Emit it before SHcompact\n+\tcalls.\n+\t2001-01-11  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.md (call, call_value, sibcall): Make sure the\n+\tcall cookie is non-NULL before taking its value.\n+\t2001-01-10  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config.gcc (sh64): Set target_requires_64bit_host_wide_int.\n+\t2001-01-09  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.md (shcompact_incoming_args): Set argument memory\n+\tblock.\n+\t* config/sh/sh.h (STATIC_CHAIN_REGNUM) [SH5]: Use r1.\n+\t* config/sh/sh.c (sh_expand_prologue) [SH5]: Use r0 as\n+\ttemporary for stack adjusts.  Use MACL and MACH to pass\n+\targuments to shcompact_incoming_args.\n+\t* config/sh/sh.md (shcompact_incoming_args): Adjust.  Don't\n+\tclobber r1.\n+\t* config/sh/lib1funcs.asm (shcompact_incoming_args): Likewise.\n+\t(nested_trampoline): Load static chain address into r1.\n+\t* config/sh/sh.md (movdi_media splits): Fix sign-extension.\n+\t2001-01-07  Alexandre Oliva  <aoliva@redhat.com\n+\t* config/sh/sh.c (fpul_operand) [SHMEDIA]: Just call\n+\tfp_arith_reg_operand().\n+\t2001-01-06  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.md (casesi): Sign-extend the first two operands,\n+\tand use signed compares for them.\n+\t* config/sh/sh.c (dump_table): Don't emit 8-byte constants after\n+\t4-byte ones.  Instead, inter-leave them, maintaining the 8-byte\n+\tones properly aligned.\n+\t(find_barrier): Account for extra alignment needed for 8-byte wide\n+\tconstants.\n+\t(machine_dependent_reorg): Require a label for the second 4-byte\n+\tconstant after an 8-byte one.\n+\t* config/sh/lib1funcs.asm (sdivsi3): Fix typo in yesterday's\n+\tchange.\n+\t2001-01-05  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.c (machine_dependent_reorg) [SHCOMPACT]: Reset\n+\tlast_float when switching float modes.\n+\t* config/sh/sh.md (movdf) [SH5]: Don't use stack-pointer\n+\tauto-increment for general-purpose registers.\n+\t* config/sh/lib1funcs.asm (sdivsi3) [SHMEDIA]: Sign-extend the\n+\tresult.\n+\t* config/sh/sh.c (sh_expand_prologue) [SH5]: Use r1 as temporary\n+\tfor stack adjust.\n+\t* config/sh/sh.c (sh_builtin_saveregs): Support using all\n+\tregisters for varargs.\n+\t2001-01-01  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.h (FUNCTION_ARG_ADVANCE): Simplify.\n+\t* config/sh/sh.h (CALL_COOKIE_STACKSEQ,\n+\tCALL_COOKIE_STACKSEQ_SHIFT, CALL_COOKIE_STACKSEQ_GET): New macros.\n+\t(CALL_COOKIE_INT_REG_SHIFT): Adjust.\n+\t(FUNCTION_ARG_ADVANCE): Use SHCOMPACT_FORCE_ON_STACK.  Adjust\n+\tcall_cookie accordingly.\n+\t(FUNCTION_ARG): Test SHCOMPACT_FORCE_ON_STACK.\n+\t(SHCOMPACT_BYREF): Likewise.\n+\t(SHCOMPACT_FORCE_ON_STACK): New macro.\n+\t* config/sh/sh.c (sh_expand_prologue): Use new call_cookie format.\n+\t(sh_builtin_saveregs): Likewise.\n+\t* config/sh/lib1funcs.asm (shcompact_call_trampoline,\n+\tshcompact_incoming_args): Use new shift values.  Support\n+\tsequences of consecutive and non-consecutive pushes/pops.\n+\t* config/sh/sh.md (return): Don't explicitly use PR_REG.\n+\t2001-01-05  Hans-Peter Nilsson  <hpn@cygnus.com>\n+\t* config/sh/sh.h (TEXT_SECTION): Define.\n+\t* config/sh/elf.h (ASM_FILE_START): Output TEXT_SECTION_ASM_OP.\n+\t2001-01-05  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.h (INIT_CUMULATIVE_LIBCALL_ARGS): New macro.\n+\t* config/sh/sh.h (BASE_RETURN_VALUE_REG): Use FP regs for\n+\treturn values on FPU-enabled SHmedia.\n+\t(FUNCTION_VALUE_REGNO_P): Mark FIRST_FP_RET_REG as used on\n+\tFPU-enabled SHmedia.\n+\t(INIT_CUMULATIVE_ARGS): Set up return trampoline only if\n+\tvalue is returned in a non-FP reg and is not returned by\n+\treference.\n+\t* config/sh/sh.md (shcompact_return_tramp_i): Change type to\n+\tjump_ind.\n+\t2000-01-04  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.h (SH_MIN_ALIGN_FOR_CALLEE_COPY): New.\n+\t(FUNCTION_ARG_CALLEE_COPIES): Require argument to be\n+\tquad-aligned to be passed by callee-copy reference.\n+\t2001-01-03  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/elf.h (MAX_WCHAR_TYPE_SIZE): Define.\n+\t* config/sh/sh64.h (MAX_WCHAR_TYPE_SIZE): Undefine.\n+\t2001-01-02  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/lib1funcs.asm (shcompact_call_trampoline): Fix error in\n+\tcopying low-numbered FP regs to r7 and r8.\n+\t* config/sh/sh.h (FUNCTION_ARG_ADVANCE): Don't request copying of\n+\tFP regs to general-purpose regs only if the copy was passed on the\n+\tstack.\n+\t* config/sh/lib1funcs.asm (shcompact_call_trampoline): Fix typo in\n+\tcopying FP reg to r9.\n+\t* config/sh/sh.h (FUNCTION_ARG_ADVANCE): Use trampoline to\n+\tcopy FP regs to general-purpose regs only in outgoing calls.\n+\t* config/sh/sh.md (movdf_media, movsf_media): Revert incorrect\n+\tchange from \t2000-10-30.  Adjust for 64-bit (or 32-bit)\n+\tHOST_WIDE_INT.\n+\t* config/sh/sh.h (struct sh_args): Document all fields.\n+\t(FUNCTION_OK_FOR_SIBCALL): Functions that receive arguments\n+\tpassed partially on the stack should not consider making\n+\tsibcalls.\n+\t* config/sh/sh.h (FUNCTION_ARG_ADVANCE): Add byref regs to\n+\tstack_regs only for incoming calls.  When passing FP args,\n+\tmake sure there are FP regs available before modifying\n+\tcall_cookie.\n+\t(SHCOMPACT_BYREF): Pass double args in general-purpose\n+\tregisters by reference.\n+\t2000-12-30  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.h (FUNCTION_OK_FOR_SIBCALL) [SHCOMPACT]: Don't\n+\tattempt to generate sibcalls if the caller got any arguments\n+\tby reference.\n+\t* config/sh/lib1funcs.asm (set_fpscr) [SH5]: Default to double.\n+\t* config/sh/sh.c (dump_table) [SHCOMPACT]: Align DImode and DFmode\n+\tto 8-byte boundaries.\n+\t* config/sh/sh.md (shcompact_preserve_incoming_args): New insn.\n+\t* config/sh/sh.h (CALL_COOKIE_INT_REG_GET): New macro.\n+\t* config/sh/sh.c (sh_expand_prologue): Preserve args that will be\n+\tstored in the stack.\n+\t* config/sh/lib1funcs.asm (ct_main_table, ia_main_table): Arrange\n+\tfor the offsets to have the ISA bit set.\n+\t(shcompact_call_trampoline): Document.  Swap r0 and r1, to match\n+\tinvocation.  Use beq instead of bgt to mark end of sequence of\n+\tloads.\n+\t(shcompact_incoming_args): Fix store of r2.  Use beq instead of\n+\tbgt to mark end of sequence of stores.\n+\t* config/sh/sh.c (arith_operand): Don't check whether\n+\tCONST_OK_FOR_J for now.\n+\t* config/sh/sh.md (movdf_media, movsf_media): Use HOST_WIDE_INT\n+\tinstead of long for conversion.\n+\t2000-12-29  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.c (print_operand_address): Convert INTVAL to int\n+\tbefore passing it to fprintf.\n+\t2000-12-28  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/crt1.asm (start): Reset SR.FD, to enable the FP unit.\n+\tCall set_fpscr before reading/writing SR.\n+\t* config/sh/crt1.asm (start): Set SR.SZ and SR.PR, but not SR.FR.\n+\tCall set_fpscr.\n+\t* config/sh/lib1funcs.asm: Add `.align 2' directives before\n+\tSHmedia code.\n+\t(FMOVD_WORKS): Define on SH5 with FPU.\n+\t(set_fpscr): Define on SH5.  Remove separate _fpscr_values\n+\tsetting.\n+\t* config/sh/t-sh64 (LIB1ASMFUNCS): Add _set_fpscr instead of\n+\t_fpscr_values.\n+\t2000-12-28  Hans-Peter Nilsson  <hpn@cygnus.com>\n+\t* config/sh/lib1funcs.asm (ct_main_table): Align contents to even\n+\taddress.\n+\t(ia_main_table): Ditto.\n+\t2000-12-27  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.h (MAX_WCHAR_TYPE_SIZE): Don't define.\n+\t* config/sh/sh64.h (WCHAR_TYPE, WCHAR_TYPE_SIZE): Reinstate\n+\tthe definitions from sh.h.\n+\t* config/sh/sh.h (PTRDIFF_TYPE): Define as conditional on\n+\tTARGET_SH5.\n+\t(SUBTARGET_CPP_SPEC): Arrange for __PTRDIFF_TYPE__ to be defined.\n+\t* config/sh/elf.h (PTRDIFF_TYPE): Likewise.\n+\t* config/sh/sh64.h (SUBTARGET_CPP_SPEC): Likewise.\n+\t2000-12-26  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.md (movdi_media split): Don't add REG_LABEL notes.\n+\tIncrement LABEL_NUSES.\n+\t\n+\t* config/sh/sh.h (SIZE_TYPE): Define as conditional on\n+\tTARGET_SH5.\n+\t(SUBTARGET_CPP_SPEC): Arrange for __SIZE_TYPE__ to be always\n+\tdefined.\n+\t* config/sh/elf.h (SIZE_TYPE): Likewise.\n+\t* config/sh/sh64.h (SUBTARGET_CPP_SPEC): Likewise.\n+\t* config/sh/lib1funcs.asm (shcompact_call_trampoline,\n+\tshcompact_incoming_args): Load switch table addresses using\n+\tdatalabel.\n+\t* config/sh/sh.h (SUBTARGET_CPP_SPEC): Define __SIZE_TYPE__.\n+\t(NO_BUILTIN_SIZE_TYPE): Define.\n+\t(SIZE_TYPE): Don't define.\n+\t* config/sh/sh64.h (SUBTARGET_CPP_SPEC): Define __SIZE_TYPE__.\n+\t* config/sh/sh.h (CPP_SPEC): Fixed typo that prevented the\n+\tdefinition of __SH5__=32 for -m5-compact-nofpu.\n+\t* config/sh/sh.c (barrier_align): Ensure 32-bit alignment after\n+\tADDR_DIFF_VEC.\n+\t2000-12-24  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.h (FUNCTION_ARG_PADDING): Removed.\n+\t2000-12-23  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.h (TARGET_CACHE32): Enable on SH5.\n+\t(FUNCTION_BOUNDARY): Ensure 32-bit alignment for SHmedia.\n+\t(INSN_LENGTH_ALIGNMENT): Likewise.\n+\t2000-12-22  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.md (call, call_value, sibcall): Simplify\n+\tcopying of non-branch-target register.\n+\t2000-12-22  Alexandre Oliva  <aoliva@redhat.com>\n+\t* glimits.h (__LONG_MAX__): Revert \t2000-12-13's patch.\n+\t* config/sh/sh.h (CPP_SPEC): Define it here for 64-bit SHmedia.\n+\t2000-12-22  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.h (GET_SH_ARG_CLASS): Handle complex\n+\tfloating-point values as structs.\n+\t(FUNCTION_ARG): Use SH5_PROTOTYPED_FLOAT_ARG.\n+\t(SH5_PROTOTYPELESS_FLOAT_ARG): List FP registers before\n+\tgeneral-purpose register.\n+\t(SH5_PROTOTYPED_FLOAT_ARG): New macro.\n+\t2000-12-20  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.md (addsi3): Force operand1 to reg for SHmedia.\n+\t* config/sh/sh.md (movsi_media): Split CONST_DOUBLE loads too.\n+\t* config/sh/sh.h (DATALABEL_REF_P): Don't require the CONST.\n+\t(ENCODE_SECTION_INFO): Enclose variables and constants in\n+\tDATALABEL unspecs.\n+\t(SH_DATALABEL_ENCODING, DATALABEL_SYMNAME_P): Define.\n+\t(STRIP_NAME_ENCODING): Strip SH_DATALABEL_ENCODING off.\n+\t(ASM_OUTPUT_LABELREF, AMS_OUTPUT_SYMBOL_REF): Define.\n+\t* config/sh/sh.c (gen_datalabel_ref): Use UNSPEC_DATALABEL\n+\tonly for LABEL_REFs.  For SYMBOL_REFs, prepend\n+\tSH_DATALABEL_ENCODING to the symbol name.\n+\t* config/sh/sh.md (indirect_jump): Use SUBREG instead of\n+\tconvert_mode().\n+\t2000-12-20  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.md (casesi): Enclose ADDR_DIFF_VEC address in\n+\tUNSPEC_DATALABEL.\n+\t* config/sh/sh.c (gen_datalabel_ref): Accept LABEL_REFs.\n+\t* config/sh/sh.h (DATALABEL_REF_NO_CONST_P): Likewise.\n+\t(DATALABEL_REF_P): Don't require CONST.\n+\t(ASM_OUTPUT_ADDR_DIFF_ELT): On SH5, output datalabel before\n+\tREL label.\n+\t2000-12-19  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.md (extendhidi2, extendqidi2): Use arithmetic shift\n+\tright.\n+\t2000-12-18  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.md (movsi_media, call, call_value, sibcall):\n+\tUse shallow_copy_rtx and PUT_MODE to change the mode of\n+\tSYMBOL_REFs, LABEL_REFs, CONSTs, etc.\n+\t* config/sh/sh.h (PREFERRED_RELOAD_CLASS): Reload SYMBOL_REFs\n+\ton SHmedia using GENERAL_REGs.\n+\t* config/sh/sh.md (ble_media_i, blt_media_i, bleu_media_i,\n+\tbltu_media_i): Fix reversion of conditions.\n+\t2000-12-18  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.md (zero_extendhidi2): Use logical shift right.\n+\t* config/sh/sh.c (output_far_jump): Save r13 in macl.\n+\t2000-12-17  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.c (gen_datalabel_ref): Fix mode of the UNSPEC.\n+\t2000-12-16  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/lib1funcs.asm (ic_invalidate): Define for SH5.\n+\t(GCC_nested_trampoline): Likewise.\n+\t* config/sh/sh-protos.h (gen_datalabel_ref): Declare.\n+\t* config/sh/sh.c (gen_datalabel_ref): Define.\n+\t* config/sh/sh.h (TRAMPOLINE_SIZE): Adjust for SH5.\n+\t(INITIALIZE_TRAMPOLINE): Likewise.\n+\t(TRAMPOLINE_ADJUST_ADDRESS): Define.\n+\t(DATALABEL_REF_NO_CONST_P, DATALABEL_REF_P): Define.\n+\t(EXTRA_CONSTRAINT_T): Match DATALABEL unspecs.\n+\t(OUTPUT_ADDR_CONST_EXTRA): Handle DATALABEL unspecs.\n+\t* config/sh/sh.md (UNSPEC_DATALABEL): New constant.\n+\t(ic_invalidate): Adjust for SH5.\n+\t(ic_invalidate_line_media, ic_invalidate_line_compact): New insns.\n+\t* config/sh/t-sh64 (LIB1ASMFUNCS): Added _ic_invalidate and\n+\t_nested_trampoline.\n+\t2000-12-15  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.h (MOVE_MAX): Set to 8 for SHmedia, 4 elsewhere.\n+\t(MOVE_MAX_PIECES): Set to 8 on SHmedia too.\n+\t2000-12-14  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.h (DBX_REGISTER_NUMBER): Adjust for sh64-elf-gdb.\n+\t* config/sh/elf.h (DBX_REGISTER_NUMBER): Likewise.\n+\t2000-12-14  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.c (target_reg_operand): Match only target-branch\n+\tregisters and pseudos that aren't virtual registers.\n+\t* config/sh/sh.md (call, call_value, sibcall) [TARGET_SHMEDIA]:\n+\tCopy operands that don't match target_reg_operand to pseudos.\n+\t(call_media, call_value_media, sibcall_media): Use\n+\ttarget_reg_operand instead of target_operand.\n+\t2000-12-13  Alexandre Oliva  <aoliva@redhat.com>\n+\t* glimits.h (__LONG_MAX__) [SH5 == 64]: Adjust for 64 bits. \n+\t* config/sh/sh.c (target_reg_operand): Match hardware registers\n+\tother than branch-target registers.\n+\t* config/sh/sh.md (zero_extendqidi2): Input operand is %1.\n+\t* config/sh/lib1funcs.asm (sdivsi3) [SH5]: Make it global.\n+\t(fpscr_values) [SH5 == 32]: Define.\n+\t* config/sh/t-sh64 (LIB1ASMFUNCS): Add fpscr_values.\n+\t* config/sh/sh.md (call, call_value, sibcall) [TARGET_SHMEDIA]:\n+\tHandle function addresses coming in SUBREGs.\n+\t2000-12-12  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/lib1funcs.asm (shcompact_call_trampoline,\n+\tshcompact_return_trampoline): Use datalabel where appropriate.\n+\t2000-12-09  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.h (SECONDARY_OUTPUT_RELOAD_CLASS): Use a\n+\tgeneral-purpose register to copy one branch-target register to\n+\tanother.\n+\t2000-12-06  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.c (target_operand): Accept LABEL_REFs and\n+\tSYMBOL_REFs with VOIDmode.\n+\t* config/sh/sh.md (ble_media_i, blt_media_i, bleu_media_i,\n+\tbltu_media_i): New insns.\n+\t2000-12-06  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.h (RETURN_IN_MEMORY): Adjust for SH5 ABI.\n+\t(INIT_CUMULATIVE_ARGS): Likewise.\n+\t2000-12-01  Alexandre Oliva  <aoliva@redhat.com>\n+\t* machmode.def (V16SFmode): New mode.\n+\t* c-common.c (type_for_mode): Support V2SF and V16SF.\n+\t* tree.c (build_common_tree_nodes_2): Likewise.\n+\t* tree.h (tree_index): Likewise.\n+\t* calls.c (emit_call_1): Take args_so_far.  Adjust all\n+\tcallers.  Introduce CALL_POPS_ARGS.\n+\t* tm.texi (CALL_POPS_ARGS): Document.\n+\t* config/sh/crt1.asm: Implement in SHmedia mode.\n+\t* config/sh/crti.asm, config/sh/crtn.asm: Likewise\n+\t* config/sh/elf.h (ASM_SPEC, LINK_SPEC): Support SH5 flags.\n+\t(DBX_REGISTER_NUMBER): Renumber registers for SH5.\n+\t* config/sh/lib1funcs.asm: Disable functions unused in SH5.\n+\tImplement divsi and udivsi in SHmedia mode.  Introduce\n+\tSHcompact trampolines.\n+\t* config/sh/sh.c (GEN_MOV, GEN_ADD3, GEN_SUB3): Use DImode\n+\tonly in SHmedia64.\n+\t(regno_reg_class): Rewrite.\n+\t(fp_reg_names): Remove.\n+\t(sh_register_names, sh_additional_register_names): New.\n+\t(print_operand): Added `u'.  Support SUBREGs in addresses.\n+\tAdd parentheses around shifted CONSTs.\n+\t(output_file_start): Output .mode and .abi directives.\n+\t(shiftcosts, addsubcosts, multcosts): Adjust.\n+\t(output_stack_adjust): Compute alignment.  Sanity-check SIZE.\n+\t(push_regs): Take array of HOST_WIDE_INTs.  Adjust callers.\n+\t(calc_live_regs): Output to array of HOST_WIDE_INTs.  Count\n+\tbytes, not registers.  Take into account the need for the\n+\tSHcompact incoming args trampoline.  Adjust all callers.\n+\t(sh_expand_prologue): Take stack_regs into account.  Call\n+\tincoming args trampoline.  Keep stack aligned as per SH5 ABI.\n+\t(sh_expand_epilogue): Take stack_regs into accoutn.  Keep\n+\tstack aligned as per SH5 ABI.\n+\t(sh_builtin_saveregs): Support SH5 ABI.\n+\t(sh_build_va_list, sh_va_start): Likewise.\n+\t(initial_elimination_offset): Take alignment into account.\n+\tCompute location of PR according to the SH5 stack frame.\n+\t(arith_reg_operand): Reject branch-target registers.\n+\t(shmedia_6bit_operand): New.\n+\t(logical_operand): Use CONST_OK_FOR_P on SHmedia.\n+\t(target_reg_operand): Match DImode only.  Accept SUBREGs.\n+\t(target_operand): New.\n+\t* config/sh/sh.h (CPP_SPEC, SUBTARGET_CPP_SPEC): Support SH5 flags.\n+\t(CONDITIONAL_REGISTER_USAGE): Implement SH5 ABI.  Initialize\n+\tSIBCALL_REGS for SHmedia.\n+\t(TARGET_SH3E, TARGET_SH4): Only if SH1_BIT is set too.\n+\t(TARGET_FPU_DOUBLE, TARGET_FPU_ANY): New.\n+\t(TARGET_SHMEDIA32, TARGET_SHMEDIA64): New.\n+\t(TARGET_SWITCHES): New SH5 flags.\n+\t(OVERRIDE_OPTIONS): Set SH5-specific options.  Use\n+\tVALID_REGISTER_P to disable unsupported registers.\n+\t(LONG_TYPE_SIZE, LONG_LONG_TYPE_SIZE): Set.\n+\t(POINTER_SIZE, PARM_BOUNDARY): Adjust.\n+\t(FUNCTION_ARG_PADDING): Define.\n+\t(FASTEST_ALIGNMENT): Adjust.\n+\t(SH_REGISTER_NAMES_INITIALIZER): New.\n+\t(sh_register_names): Declare.\n+\t(DEBUG_REGISTER_NAMES): Define.\n+\t(REGISTER_NAMES): Define based on sh_register_names.\n+\t(SH_ADDITIONAL_REGISTER_NAMES_INITIALIZER): New.\n+\t(sh_additional_register_names): Declare.\n+\t(LAST_GENERAL_REG, LAST_FP_REG, LAST_XD_REG): Adjust for SHmedia.\n+\t(FIRST_TARGET_REG, LAST_TARGET_REG): Define.\n+\t(TARGET_REGISTER_P, SHMEDIA_REGISTER_P, VALID_REGISTER_P): Define.\n+\t(REGISTER_NATURAL_MODE): Define.\n+\t(FIRST_PSEUDO_REGISTER): Adjust.\n+\t(FIXED_REGISTERS, CALL_USED_REGISTERS): Adjust.\n+\t(HARD_REGNO_CALL_PART_CLOBBERED): Define.\n+\t(HARD_REGNO_NREGS, HARD_REGNO_MODE_OK): Adjust.\n+\t(VECTOR_MODE_SUPPORTED_P): Define.\n+\t(REG_CLASS_CONTENTS): Adjust.\n+\t(SMALL_REGISTER_CLASSES): Adjust.\n+\t(REG_ALLOC_ORDER): Adjust.\n+\t(INDEX_REG_CLASS): Adjust.\n+\t(CONST_OK_FOR_O, CONST_OK_FOR_P): New.\n+\t(CONST_OK_FOR_LETTER_P): Adjust.\n+\t(PREFERRED_RELOAD_CLASS): Adjust.\n+\t(SECONDARY_OUTPUT_RELOAD_CLASS): Adjust.\n+\t(SECONDARY_INPUT_RELOAD_CLASS): Adjust.\n+\t(NPARM_REGS, FIRST_PARM_REG, FIRST_RET_REG): Adjust.\n+\t(FIRST_FP_PARM_REG): Adjust.\n+\t(CALL_POPS_ARGS): Define.\n+\t(FUNCTION_ARG_REGNO_P): Adjust.\n+\t(struct sh_args): New fields.\n+\t(GET_SH_ARG_CLASS): Adjust.\n+\t(INIT_CUMULATIVE_ARGS): Adjust.\n+\t(INIT_CUMULATIVE_INCOMING_ARGS): Define.\n+\t(FUNCTION_ARG_ADVANCE): Adjust.\n+\t(FUNCTION_ARG): Adjust.\n+\t(FUNCTION_ARG_PASS_BY_REFERENCE, SHCOMPACT_BYREF): Define.\n+\t(FUNCTION_ARG_CALLEE_COPIES): Define.\n+\t(SH5_PROTOTYPELESS_FLOAT_ARG): Define.\n+\t(STRICT_ARGUMENT_NAMING): Define.\n+\t(PRETEND_OUTGOING_VARARGS_NAMED): Adjust.\n+\t(FUNCTION_ARG_PARTIAL_NREGS): Adjust.\n+\t(SH5_WOULD_BE_PARTIAL_NREGS): Define.\n+\t(SETUP_INCOMING_VARARGS): Adjust.\n+\t(HAVE_POST_INCREMENT, HAVE_PRE_DECREMENT): Adjust.\n+\t(USE_LOAD_POST_INCREMENT, USE_STORE_PRE_DECREMENT): Adjust.\n+\t(REGNO_OK_FOR_INDEX_P, REG_OK_FOR_INDEX_P): Adjust.\n+\t(SUBREG_OK_FOR_INDEX_P): Adjust.\n+\t(EXTRA_CONSTRAINT_S): Update.\n+\t(EXTRA_CONSTRAINT_T): New.\n+\t(EXTRA_CONSTRAINT): Adjust.\n+\t(GO_IF_LEGITIMATE_INDEX): Adjust.\n+\t(GO_IF_LEGITIMATE_ADDRESS): Adjust.\n+\t(LEGITIMIZE_ADDRESS, LEGITIMIZE_RELOAD_ADDRESS): Adjust.\n+\t(MOVE_MAX): Adjust.\n+\t(MAX_MOVE_MAX): Define.\n+\t(Pmode): Adjust.\n+\t(CONST_COSTS): Adjust.\n+\t(REGISTER_MOVE_COST): Adjust.\n+\t(BRANCH_COST): Adjust.\n+\t(TEXT_SECTION_ASM_OP): Adjust.\n+\t(DBX_REGISTER_NUMBER): Adjust.\n+\t(ASM_OUTPUT_DOUBLE_INT): New.\n+\t(UNALIGNED_DOUBLE_INT_ASM_OP): New.\n+\t(PREDICATE_CODES): Adjust.\n+\t(PROMOTE_MODE): Adjust.\n+\t(CRT_CALL_STATIC_FUNCTION): Do not define for SHmedia.\n+\t* config/sh/sh.md (AP_REG, PR_REG, T_REG, GBR_REG): Renumber.\n+\t(MACH_REG, MACL_REG, FPUL_REG, RAP_REG, FPSCR_REG): Renumber.\n+\t(PR_MEDIA_REG, T_MEDIA_REG, R10_REG): New.\n+\t(DR0_REG, DR2_REG, DR4_REG): Renumber.\n+\t(TR0_REG, TR1_REG, TR2_REG): New.\n+\t(XD0_REG): Renumber.\n+\t(UNSPEC_COMPACT_ARGS): New.\n+\t(type): Added pt and ptabs.\n+\t(length): Default to 4 on SHmedia.  Default pt length to 12\n+\tand \t20 on SHmedia32 and SHmedia64, respectively.\n+\t(pt): New function unit.\n+\t(movdi, movsi): Add types pt and ptabs.  Don't increment LABEL_NUSES.\n+\tAdd whitespace between operands of SHmedia instructions.\n+\t(movdicc): Fix.\n+\t(adddi3_media, addsi3_media): Adjust constraints.\n+\t(subsi3) [SHmedia]: Force operand 1 into a register.\n+\t(udivsi3_i1_media, udivsi3_i4_media): New.\n+\t(udivsi3): Support SHmedia.\n+\t(divsi3_i1_media, divsi3_i4_media): New.\n+\t(divsi3): Support SHmedia.\n+\t(anddi3, iordi3, xordi3): Adjust constraints.\n+\t(zero_extendhidi2, zero_extendqidi2): New.\n+\t(extendsidi2, extendhidi2, extendqidi2): New.\n+\t(push, pop, push_e, push_fpul, push_4): Disable on SH5.\n+\t(pop_e, pop_fpul, pop_4): Likewise.\n+\t(movsi_media): Support FP and BT registers.\n+\t(movsi_media_nofpu): New.  Adjust splits to DImode.\n+\t(lduw, ldub): Renamed to zero_extend* above.\n+\t(movqi_media): Fix typo.\n+\t(movdi_media): Support FP and BT registers.\n+\t(movdi_media_nofpu): New.  Adjust splits for SHmedia32.\n+\t(movdi_const_32bit): New.\n+\t(shori_media): Require immediate operand.  Use `u' for output.\n+\t(movdf_media, movsf_media): Simplified.\n+\t(movdf_media_nofpu, movsf_media_nofpu): New.\n+\t(movdf, movsf): Adjust\n+\t(movv2sf, movv2sf, movv16sf): New.\n+\t(beq_media, beq_media_i): Adjust constraints.  Don't use\n+\tscratch BT register.\n+\t(bne_media, bne_media_i): Likewise.\n+\t(bgt_media, bgt_media_i): Likewise.\n+\t(bge_media, bge_media_i): Likewise.\n+\t(bgtu_media, bgtu_media_i): Likewise.\n+\t(bgeu_media, bgeu_media_i): Likewise.\n+\t(beq, bne, bgt, blt, ble, bge, bgtu, bltu, bgeu, bleu,\n+\tbunordered): Emit jump insn.  Force operands to registers when\n+\tneeded.\n+\t(jump_media, jump): Simplify.\n+\t(call_compact, call_compact_rettramp): New.\n+\t(call_value_compact, call_value_compact_rettramp): New.\n+\t(call_media, call_value_media): Simplify.\n+\t(sibcall_compact, sibcall_media): New.\n+\t(call, call_value): Adjust for SHmedia and SHcompact.\n+\t(sibcall, sibcall_value, untyped_call): Likewise.\n+\t(sibcall_epilogue): Preserve r0 across epilogue for SHcompact.\n+\t(indirect_jump): Adjust for SHmedia.\n+\t(casesi_jump_media): New.\n+\t(nop): Re-enable for SHmedia.\n+\t(call_site): Restrict to SH1.\n+\t(casesi): Adjust for SHmedia.\n+\t(casesi_shift_media, casesi_load_media): New.\n+\t(return): Explicitly use PR register.  Call return trampoline\n+\ton SHcompact.\n+\t(return_i): Explicitly use PR register.\n+\t(shcompact_return_tramp, shcompact_return_tramp_i): New.\n+\t(return_media): Adjust.\n+\t(shcompact_incoming_args): New.\n+\t(epilogue): Adjust.\n+\t(seq, slt, sle, sgt, sge, sgtu, sltu, sleu, sgeu, sne): Adjust.\n+\t(movstrsi): Disable on SH5.\n+\t(fpu_switch0, fpu_switch1, movpsi): Enable on SH4.\n+\t(addsf3, addsf3_media): Test TARGET_SHMEDIA_FPU.\n+\t(subsf3, subsf3_media): Likewise.\n+\t(mulsf3, mulsf3_media, mac_media): Likewise.\n+\t(divsf3, divsf3_media): Likewise.\n+\t(floatdisf2, floatsisf2_media): Likewise.  Adjust constraints.\n+\t(floatsisf2, fux_truncsfsi2): Likewise.\n+\t(fix_truncsfdi2, fix_truncsfsi2_media): Likewise.  Adjust\n+\tconstraints.\n+\t(cmpeqsf_media, cmpgtsf_media, cmpgesf_media): Likewise.\n+\t(cmpunsf_media, cmpsf): Likewise.\n+\t(negsf2, negsf2_media, sqrtsf2, sqrtsf2_media): Likewise.\n+\t(abssf2, abssf2_media): Likewise.\n+\t(adddf3, adddf3_media, subdf3, subdf3_media): Likewise.\n+\t(muldf3, muldf3_media, divdf3, divdf3_media): Likewise.\n+\t(floatdidf2, floatsidf2_media): Likewise.  Adjust constraints.\n+\t(floatsidf2, fix_truncdfsi2): Likewise.\n+\t(fix_truncdfdi2, fix_truncdfsi2_media): Likewise.  Adjust\n+\tconstraints.\n+\t(cmpeqdf_media, cmpgtdf_media): Likewise.\n+\t(cmpgedf_media, cmpundf_media, cmpdf): Likewise.\n+\t(negdf2, negdf2_media, sqrtdf2, sqrtdf2_media): Likewise.\n+\t(absdf2, absdf2_media): Likewise.\n+\t(extendsfdf2, extendsfdf2_media): Likewise.\n+\t(truncsfdf2, truncsfdf2_media): Likewise.\n+\t* config/sh/sh64.h: New file.\n+\t* config/sh/t-sh64: New file.\n+\t* config/sh/shmedia.h: New file.\n+\t* config/sh/ushmedia.h: New file.\n+\t* config/sh/sshmedia.h: New file.\n+\t* configure.in: Added sh64-*-elf.\n+\t* configure: Rebuilt.\n+\t2000-10-10  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.c (GEN_MOV, GEN_ADD3, GEN_SUB3): New macros.\n+\t(reg_class_from_letter): Use `b' for TARGET_REGS.\n+\t(print_operand): Support `%M', `%m', `AND' and\n+\t`ASHIFTRT'.  Do not precede constants with `#' on SHmedia.\n+\t(andcosts): Adjust for SHmedia.\n+\t(output_stack_adjust, sh_expand_prologue, sh_expand_epilogue):\n+\tLikewise.\n+\t(target_reg_operand): New function.\n+\t* config/sh/sh-protos.h (target_reg_operand): Declare.\n+\t* config/sh/sh.h (CONDITIONAL_REGISTER_USAGE): Don't disable\n+\tFP registers on SH5.\n+\t(HARD_REGNO_MODE_OK): Accept them whenever they're acceptable\n+\ton SH4.\n+\t(TARGET_REGISTER_P): New macro.\n+\t(reg_class, REG_CLASS_NAMES, REG_CLASS_CONTENTS): Added TARGET_REGS.\n+\t(FUNCTION_VALUE): Use DImode for promoted types on SHmedia.\n+\t(EXTRA_CONSTRAINT_S): New macro.\n+\t(EXTRA_CONSTRAINT): Adjust.\n+\t(FLOAT_TYPE_SIZE): Define to 32.\n+\t(Pmode): DImode on SHmedia.\n+\t(CONST_COSTS): Adjust for SHmedia literals.\n+\t(PREDICATE_CODES): Added target_reg_operand.\n+\t(PROMOTE_MODE): Promote signed types to DImode on SHmedia.\n+\t* config/sh/sh.md: Remove all attrs from SHmedia insns.\n+\t(cmpeqdi_media, cmpgtdi_media, cmpgtudi_media): New insns.\n+\t(cmpdi): Accept SHmedia.\n+\t(movdicc_false, movdicc_true): New insns.\n+\t(movdicc): New expand.\n+\t(adddi3): Accept arith_operand for op2, but FAIL on SH1 if\n+\tno_new_pseudos.\n+\t(addsi3_media): Match `S' constraint.\n+\t(anddi3, andcdi3, iordi3, xordi3, negdi_media): New insns.\n+\t(negdi2): Expand for SHmedia.\n+\t(one_cmpldi2): New expand.\n+\t(zero_extendsidi2): Change from expand to insn.\n+\t(extendsidi2): Add constraints.\n+\t(movdi_media, movsi_media): Change `%x' to `%M'.  Use `%m' for\n+\tLD/ST address.  Fix SI immediate loading split.\n+\t(movhi_media, movqi_media, lduw, ldub): New insns.\n+\t(movhi, movqi): Accept SHmedia.\n+\t(shori_media, movdi_media): Relax input constraints.  Split\n+\tsymbolic constants.\n+\t(movdf_media, movsf_media): New insn.  New split to movdi.\n+\t(movdf, movsf): Match on SHmedia.\n+\t(beq_media, bne_media, bgt_media, bge_media, bgtu_media,\n+\tbgeu_media): New insns and splits.  New insns with `_i' suffix.\n+\t(beq, bne, bgt, blt, ble, bge, bgtu, bltu, bgeu, bleu): Adjust.\n+\t(bunordered): New expand.\n+\t(jump_compact): Renamed from `jump'.\n+\t(jump_media): New insn.\n+\t(jump): New expand.\n+\t(call_media, call_value_media): New insns.\n+\t(call, call_value): Adjust.\n+\t(indirect_jump_compact): Renamed from `indirect_jump'.\n+\t(indirect_jump_media): New insn.\n+\t(indirect_jump): New expand.\n+\t(untyped_call, return): Accept SHmedia.\n+\t(return_media): New insn.\n+\t(prologue, epilogue, blockage): Accept SHmedia.\n+\t(seq, slt, sle, sgt, sge, sgtu, sltu, sleu, sgeu, sne): Adjust.\n+\t(sunordered): New expand.\n+\t(addsf3, subsf3, mulsf3, divsf3, floatsisf2, fix_truncsfsi2,\n+\tcmpsf, negsf2, sqrtsf2, abssf2): Adjust for SHmedia.\n+\t(addsf3_media, subsf3_media, mulsf3_media, mac_media,\n+\tdivsf3_media, floatdisf2, floatsisf2_media, fix_truncsfdi2,\n+\tfix_truncsfsi2_media, cmpeqsf_media, cmpgtsf_media,\n+\tcmpgesf_media, cmpunsf_media, negsf2_media, sqrtsf2_media,\n+\tabssf2_media): New insns.\n+\t(adddf3, subdf3, muldf3, divdf3, floatsidf2, fix_truncdfsi2,\n+\tcmpdf, negdf2, sqrtdf2, absdf2): Adjust for SHmedia.\n+\t(adddf3_media, subdf3_media, muldf3_media, divdf3_media,\n+\tfloatdidf2, floatsidf2_media, fix_truncdfdi2,\n+\tfix_truncdfsi2_media, cmpeqdf_media, cmpgtdf_media,\n+\tcmpgedf_media, cmpundf_media, negdf2_media, sqrtdf2_media,\n+\tabsdf2_media): New insns.\n+\t(extendsfdf2, truncdfsf2): Adjust for SHmedia.\n+\t(extendsfdf2_media, truncdfsf2_media): New insns.\n+\t2000-09-14  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.c (machine_dependent_reorg): On shmedia, skip for now.\n+\t* config/sh/sh.h (CONST_OK_FOR_J): Document.\n+\t(LEGITIMATE_CONSTANT_P): Accept CONST_DOUBLEs on shmedia.\n+\t* config/sh/sh.md (adddi3): New expand.\n+\t(adddi3_media, adddi3z_media): New insns.\n+\t(adddi3_compact): Renamed from adddi3.\n+\t(addsi3_media): Use add.l r63 to add constant zero.\n+\t(subdi3): New expand.\n+\t(subdi3_media): New insn.\n+\t(subdi3_compact): Renamed from subdi3.\n+\t(mulsidi3): New expand.\n+\t(mulsidi3_media): New insn.\n+\t(mulsidi3_compact): Renamed from mulsidi3.\n+\t(umulsidi3): New expand.\n+\t(umulsidi3_media): New insn.\n+\t(umulsidi3_compact): Renamed from umulsidi3.\n+\t(ashlsi3_media, ashrsi3_media, lshrsi3_media): New insns.\n+\t(ashlsi3, ashrsi3, lshrsi3): Use them.\n+\t(ashldi3_media, ashrdi3_media, lshrdi3_media): New insns.\n+\t(ashldi3, ashrdi3, lshrdi3): Use them.\n+\t(zero_extendsidi2): New expand.\n+\t(extendsidi2): New insn.\n+\t(movsi_media): New insn.  Split to movdi to load constants.\n+\t(movsi): Enable for shmedia.\n+\t(movdi_media): New insn.  Use shori_media to load wide constants.\n+\t(short_media): New insn.\n+\t(movdi): Enable for shmedia.\n+\t2000-09-08  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.h (CPP_SPEC): Added `m5'.\n+\t(SUBTARGET_CPP_SPEC): Added `!m5'.\n+\t(SH5_BIT, TARGET_SH5, TARGET_SHMEDIA, TARGET_SHCOMPACT): New macros.\n+\t(TARGET_SWITCHES): Added `5' and `5-compact'.  Added SH1_BIT\n+\tto all other SH variants.\n+\t(TARGET_DEFAULT): Set to SH1_BIT.\n+\t(OVERRIDE_OPTIONS): Recognize sh5 CPU.\n+\t(BITS_PER_WORD): Raise to 64 on shmedia.\n+\t(MAX_BITS_PER_WORD): Change to 64.\n+\t(MAX_LONG_TYPE_SIZE, MAX_WCHAR_TYPE_SIZE): Set to MAX_BITS_PER_WORD.\n+\t(INT_TYPE_SIZE): Keep as 32.\n+\t(UNITS_PER_WORD): Raise to 8 on shmedia.\n+\t(MIN_UNITS_PER_WORD): Keep as 4.\n+\t(POINTER_SIZE): Raise to 64 on shmedia.\n+\t(CONST_OK_FOR_J): New macro.\n+\t(CONST_OK_FOR_LETTER_P): Use it.\n+\t(processor_type): Add PROCESSOR_SH5.\n+\t* config/sh/sh.md: Conditionalize all expands, insns and\n+\tsplits to TARGET_SH1.\n+\t(cpu): Added sh5.\n+\t(addsi3_compact): Renamed from...\n+\t(addsi3): Now an expand.\n+\t(addsi3_media, subsi3_media): New insns.\n+\t(subsi3): Don't negate constants with SHmedia.\n+\n \t* hooks.c: New file.\n \t* hooks.h: New file.\n \t* Makefile.in (HOOKS_H): New."}, {"sha": "3768db554ba13e287827dc35f3575a873396050d", "filename": "gcc/c-common.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa5322fa5824e95a7aa82413782b510c8d91e7d8/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa5322fa5824e95a7aa82413782b510c8d91e7d8/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=fa5322fa5824e95a7aa82413782b510c8d91e7d8", "patch": "@@ -1408,6 +1408,8 @@ type_for_mode (mode, unsignedp)\n \t  return unsignedp ? unsigned_V4HI_type_node : V4HI_type_node;\n \tcase V8QImode:\n \t  return unsignedp ? unsigned_V8QI_type_node : V8QI_type_node;\n+\tcase V16SFmode:\n+\t  return V16SF_type_node;\n \tcase V4SFmode:\n \t  return V4SF_type_node;\n \tcase V2SFmode:"}, {"sha": "9d014f925cd98673b9938f6817c67af4bf1345dd", "filename": "gcc/calls.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa5322fa5824e95a7aa82413782b510c8d91e7d8/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa5322fa5824e95a7aa82413782b510c8d91e7d8/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=fa5322fa5824e95a7aa82413782b510c8d91e7d8", "patch": "@@ -181,7 +181,8 @@ static int calls_function_1\tPARAMS ((tree, int));\n \n static void emit_call_1\t\tPARAMS ((rtx, tree, tree, HOST_WIDE_INT,\n \t\t\t\t\t HOST_WIDE_INT, HOST_WIDE_INT, rtx,\n-\t\t\t\t\t rtx, int, rtx, int));\n+\t\t\t\t\t rtx, int, rtx, int,\n+\t\t\t\t\t CUMULATIVE_ARGS *));\n static void precompute_register_parameters\tPARAMS ((int,\n \t\t\t\t\t\t\t struct arg_data *,\n \t\t\t\t\t\t\t int *));\n@@ -444,7 +445,7 @@ prepare_call_address (funexp, fndecl, call_fusage, reg_parm_seen, sibcallp)\n static void\n emit_call_1 (funexp, fndecl, funtype, stack_size, rounded_stack_size,\n \t     struct_value_size, next_arg_reg, valreg, old_inhibit_defer_pop,\n-\t     call_fusage, ecf_flags)\n+\t     call_fusage, ecf_flags, args_so_far)\n      rtx funexp;\n      tree fndecl ATTRIBUTE_UNUSED;\n      tree funtype ATTRIBUTE_UNUSED;\n@@ -456,6 +457,7 @@ emit_call_1 (funexp, fndecl, funtype, stack_size, rounded_stack_size,\n      int old_inhibit_defer_pop;\n      rtx call_fusage;\n      int ecf_flags;\n+     CUMULATIVE_ARGS *args_so_far ATTRIBUTE_UNUSED;\n {\n   rtx rounded_stack_size_rtx = GEN_INT (rounded_stack_size);\n   rtx call_insn;\n@@ -466,6 +468,10 @@ emit_call_1 (funexp, fndecl, funtype, stack_size, rounded_stack_size,\n   struct_value_size_rtx = GEN_INT (struct_value_size);\n #endif\n \n+#ifdef CALL_POPS_ARGS\n+  n_popped += CALL_POPS_ARGS (* args_so_far);\n+#endif\n+  \n   /* Ensure address is valid.  SYMBOL_REF is already valid, so no need,\n      and we don't want to load it into a register as an optimization,\n      because prepare_call_address already did it if it should be done.  */\n@@ -3055,7 +3061,7 @@ expand_call (exp, target, ignore)\n       emit_call_1 (funexp, fndecl, funtype, unadjusted_args_size,\n \t\t   adjusted_args_size.constant, struct_value_size,\n \t\t   next_arg_reg, valreg, old_inhibit_defer_pop, call_fusage,\n-\t\t   flags);\n+\t\t   flags, & args_so_far);\n \n       /* Verify that we've deallocated all the stack we used.  */\n       if (pass\n@@ -4053,7 +4059,7 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n \t       struct_value_size,\n \t       FUNCTION_ARG (args_so_far, VOIDmode, void_type_node, 1),\n \t       valreg,\n-\t       old_inhibit_defer_pop + 1, call_fusage, flags);\n+\t       old_inhibit_defer_pop + 1, call_fusage, flags, & args_so_far);\n \n   /* For calls to `setjmp', etc., inform flow.c it should complain\n      if nonvolatile values are live.  For functions that cannot return,"}, {"sha": "80fb31a7bbba56855c1d203716544c6a662a2ded", "filename": "gcc/config.gcc", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa5322fa5824e95a7aa82413782b510c8d91e7d8/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa5322fa5824e95a7aa82413782b510c8d91e7d8/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=fa5322fa5824e95a7aa82413782b510c8d91e7d8", "patch": "@@ -263,6 +263,9 @@ powerpc*-*-*)\n sparc*-*-*)\n \tcpu_type=sparc\n \t;;\n+sh64-*-*)\n+\tcpu_type=sh\n+\t;;\n esac\n \n tm_file=${cpu_type}/${cpu_type}.h\n@@ -2885,6 +2888,16 @@ sh-*-elf*)\n \ttm_file=\"${tm_file} sh/elf.h\"\n \tfloat_format=sh\n \t;;\n+sh64-*-elf*)\n+\ttmake_file=\"sh/t-sh sh/t-elf sh/t-sh64\"\n+\ttm_file=\"${tm_file} sh/sh.h sh/elf.h sh/sh64.h\"\n+\tfloat_format=sh\n+\textra_headers=\"../../config/sh/shmedia.h ../../config/sh/ushmedia.h ../../config/sh/sshmedia.h\"\n+\t# Not strictly necessary to check this, but a good idea anyway.\n+\tif test $machine = $target; then\n+\t\ttarget_requires_64bit_host_wide_int=yes\n+\tfi\n+\t;;\n sh-*-rtemself*)\n \ttmake_file=\"sh/t-sh sh/t-elf t-rtems\"\n \ttm_file=\"${tm_file} sh/elf.h sh/rtemself.h\""}, {"sha": "e46c5ae139e9cc5291fac87d8db8686c0e37807e", "filename": "gcc/config/sh/crt1.asm", "status": "modified", "additions": 76, "deletions": 1, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa5322fa5824e95a7aa82413782b510c8d91e7d8/gcc%2Fconfig%2Fsh%2Fcrt1.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa5322fa5824e95a7aa82413782b510c8d91e7d8/gcc%2Fconfig%2Fsh%2Fcrt1.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fcrt1.asm?ref=fa5322fa5824e95a7aa82413782b510c8d91e7d8", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2000 Free Software Foundation, Inc.\n+/* Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n    This file was pretty much copied from newlib.\n \n This file is part of GNU CC.\n@@ -27,6 +27,80 @@ along with this program; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n+\n+#ifdef __SH5__\n+\t.section .data,\"aw\"\n+\t.global ___data\n+___data:\n+\n+\t.section .rodata,\"a\"\n+\t.global ___rodata\n+___rodata:\n+\n+#if __SH5__ == 64\n+\t.section .text,\"ax\"\n+#define LOAD_ADDR(sym, reg) \\\n+\tmovi\t(sym >> 48) & 65535, reg; \\\n+\tshori\t(sym >> 32) & 65535, reg; \\\n+\tshori\t(sym >> 16) & 65535, reg; \\\n+\tshori\tsym & 65535, reg\n+#else\n+\t.mode\tSHmedia\n+\t.section .text..SHmedia32,\"ax\"\n+#define LOAD_ADDR(sym, reg) \\\n+\tmovi\t(sym >> 16) & 65535, reg; \\\n+\tshori\tsym & 65535, reg\n+#endif\n+\t.global start\n+start:\n+\tLOAD_ADDR (_stack, r15)\n+\n+\tpt/l\t.Lzero_bss_loop, tr0\n+\tpt/l\t_atexit, tr1\n+\tpt/l\t_init, tr5\n+\tpt/l\t___setup_argv_and_call_main, tr6\n+\tpt/l\t_exit, tr7\n+\n+\t! zero out bss\n+\tLOAD_ADDR (_edata, r0)\n+\tLOAD_ADDR (_end, r1)\n+.Lzero_bss_loop:\n+\tstx.q\tr0, r63, r63\n+\taddi\tr0, 8, r0\n+\tbgt/l\tr1, r0, tr0\n+\n+\tLOAD_ADDR (___data, r26)\n+\tLOAD_ADDR (___rodata, r27)\n+\n+#if ! __SH4_NOFPU__\n+#if __SH5__ == 32\n+\tpt/l ___set_fpscr, tr0\n+\tmovi\t0, r4\n+\tblink\ttr0, r18\n+#endif\n+\tgetcon\tsr, r0\n+\t! enable the FP unit, by resetting SR.FD\n+\t! also zero out SR.FR, SR.SZ and SR.PR, as mandated by the ABI\n+\tmovi\t0, r1\n+\tshori\t0xf000, r1\n+\tandc\tr0, r1, r0\n+\tputcon\tr0, sr\n+#endif\n+\n+\t! arrange for exit to call fini\n+\tLOAD_ADDR (_fini, r2)\n+\tblink\ttr1, r18\n+\n+\t! call init\n+\tblink\ttr5, r18\n+\n+\t! call the mainline\n+\tblink\ttr6, r18\n+\n+\t! call exit\n+\tblink\ttr7, r18\n+\t\n+#else\n \t.section .text\n \t.global\tstart\n start:\n@@ -99,6 +173,7 @@ fini_k:\n ___main:\n \trts\n \tnop\n+#endif\n \n #ifdef __ELF__\n \t.section .stack,\"aw\""}, {"sha": "41bc9101214aee745a2a326e4391692798d448a2", "filename": "gcc/config/sh/crti.asm", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa5322fa5824e95a7aa82413782b510c8d91e7d8/gcc%2Fconfig%2Fsh%2Fcrti.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa5322fa5824e95a7aa82413782b510c8d91e7d8/gcc%2Fconfig%2Fsh%2Fcrti.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fcrti.asm?ref=fa5322fa5824e95a7aa82413782b510c8d91e7d8", "patch": "@@ -50,6 +50,19 @@ Boston, MA 02111-1307, USA.  */\n #endif\n \t.global\t _init\n _init:\n+#if __SHMEDIA__\n+\taddi\tr15, -16, r15\n+\tst.q\tr15, 8, r14\n+\tst.q\tr15, 0, r18\n+\tadd\tr15, r63, r14\n+#elif __SH5__ && ! __SHMEDIA__\n+\tmov\tr15,r0\n+\tadd\t#-8,r15\n+\tmov.l\tr14,@-r0\n+\tsts.l\tpr,@-r0\n+\tmov\tr15,r14\n+\tnop\n+#else\n #ifdef __ELF__\n \tmov.l\tr12,@-r15\n \tmova\t0f,r0\n@@ -68,6 +81,7 @@ _init:\n 0:\t.long\t_GLOBAL_OFFSET_TABLE_\n 1:\n #endif\n+#endif /* __SHMEDIA__ */\n \n \t.section .fini\n /* The alignment below can't be smaller, otherwise the mova below\n@@ -81,6 +95,19 @@ _init:\n #endif\n \t.global  _fini\n _fini:\t\n+#if __SHMEDIA__\n+\taddi\tr15, -16, r15\n+\tst.q\tr15, 8, r14\n+\tst.q\tr15, 0, r18\n+\tadd\tr15, r63, r14\n+#elif __SH5__ && ! __SHMEDIA__\n+\tmov\tr15,r0\n+\tadd\t#-8,r15\n+\tmov.l\tr14,@-r0\n+\tsts.l\tpr,@-r0\n+\tmov\tr15,r14\n+\tnop\n+#else\n #ifdef __ELF__\n \tmov.l\tr12,@-r15\n \tmova\t0f,r0\n@@ -99,3 +126,4 @@ _fini:\n 0:\t.long\t_GLOBAL_OFFSET_TABLE_\n 1:\n #endif\n+#endif /* __SHMEDIA__ */"}, {"sha": "e064a7b2c42b5fc1582147caa5f8cb201e39b4f9", "filename": "gcc/config/sh/crtn.asm", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa5322fa5824e95a7aa82413782b510c8d91e7d8/gcc%2Fconfig%2Fsh%2Fcrtn.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa5322fa5824e95a7aa82413782b510c8d91e7d8/gcc%2Fconfig%2Fsh%2Fcrtn.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fcrtn.asm?ref=fa5322fa5824e95a7aa82413782b510c8d91e7d8", "patch": "@@ -30,6 +30,20 @@ Boston, MA 02111-1307, USA.  */\n /* See an explanation about .init and .fini in crti.asm.  */\n \n \t.section .init\n+#if __SHMEDIA__\n+\tadd\tr14, r63, r15\n+\tld.q\tr15, 0, r18\n+\tptabs\tr18, tr0\n+\tld.q\tr15, 8, r14\n+\taddi\tr15, 16, r15\n+\tblink\ttr0, r63\n+#elif __SH5__ && ! __SHMEDIA__\n+\tmov\tr14,r15\n+\tlds.l\t@r14+,pr\n+\tmov.l\t@r14,r14\n+\trts\n+\tadd\t#8,r15\n+#else\n \tmov\tr14,r15\n \tlds.l\t@r15+,pr\n \tmov.l\t@r15+,r14\n@@ -39,8 +53,23 @@ Boston, MA 02111-1307, USA.  */\n #else\n \tnop\n #endif\n+#endif /* __SHMEDIA__ */\n \n \t.section .fini\n+#if __SHMEDIA__\n+\tadd\tr14, r63, r15\n+\tld.q\tr15, 0, r18\n+\tptabs\tr18, tr0\n+\tld.q\tr15, 8, r14\n+\taddi\tr15, 16, r15\n+\tblink\ttr0, r63\n+#elif __SH5__ && ! __SHMEDIA__\n+\tmov\tr14,r15\n+\tlds.l\t@r14+,pr\n+\tmov.l\t@r14,r14\n+\trts\n+\tadd\t#8,r15\n+#else\n \tmov\tr14,r15\n \tlds.l\t@r15+,pr\n \tmov.l\t@r15+,r14\n@@ -50,3 +79,4 @@ Boston, MA 02111-1307, USA.  */\n #else\n \tnop\n #endif\n+#endif /* __SHMEDIA__ */"}, {"sha": "9bd5a3698aa2a7a5dba0449bf580a44396064134", "filename": "gcc/config/sh/elf.h", "status": "modified", "additions": 56, "deletions": 4, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa5322fa5824e95a7aa82413782b510c8d91e7d8/gcc%2Fconfig%2Fsh%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa5322fa5824e95a7aa82413782b510c8d91e7d8/gcc%2Fconfig%2Fsh%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Felf.h?ref=fa5322fa5824e95a7aa82413782b510c8d91e7d8", "patch": "@@ -27,6 +27,8 @@ Boston, MA 02111-1307, USA.  */\n #undef TARGET_ASM_NAMED_SECTION\n #undef ASM_DECLARE_FUNCTION_NAME\n #undef MAX_OFILE_ALIGNMENT\n+#undef SIZE_TYPE\n+#undef PTRDIFF_TYPE\n \n /* Be ELF-like.  */\n /* TODO: convert includes to ${tm_file} list in config.gcc.  */\n@@ -47,6 +49,11 @@ Boston, MA 02111-1307, USA.  */\n /* use a more compact format for line information */\n #define DWARF2_ASM_LINE_DEBUG_INFO 1\n \n+/* WCHAR_TYPE_SIZE is defined to BITS_PER_WORD in svr4.h, but\n+   BITS_PER_WORD isn't constant any more.  Fortunately, on no SH\n+   platform is it wider than 32-bits.  */\n+#define MAX_WCHAR_TYPE_SIZE 32\n+\n /* The prefix to add to user-visible assembler symbols.\n    Note that svr4.h redefined it from the original value (that we want)\n    in sh.h */\n@@ -60,6 +67,14 @@ Boston, MA 02111-1307, USA.  */\n #undef ASM_FILE_START\n #define ASM_FILE_START(FILE) do {\t\t\t\t\\\n   output_file_directive ((FILE), main_input_filename);\t\t\\\n+/* We also need to show the text section with the proper\t\\\n+   attributes as in TEXT_SECTION_ASM_OP, before dwarf2out\t\\\n+   emits it without attributes in TEXT_SECTION, else GAS\t\\\n+   will complain.  We can teach GAS specifically about the\t\\\n+   default attributes for our choice of text section, but\t\\\n+   then we would have to change GAS again if/when we change\t\\\n+   the text section name.  */\t\t\t\t\t\\\n+   fprintf ((FILE), \"%s\\n\", TEXT_SECTION_ASM_OP);\t\t\\\n   if (TARGET_LITTLE_ENDIAN)\t\t\t\t\t\\\n     fprintf ((FILE), \"\\t.little\\n\");\t\t\t\t\\\n } while (0)\n@@ -69,17 +84,54 @@ Boston, MA 02111-1307, USA.  */\n /* Let code know that this is ELF.  */\n #define CPP_PREDEFINES \"-D__sh__ -D__ELF__ -Acpu=sh -Amachine=sh\"\n \n+#undef SIZE_TYPE\n+#define SIZE_TYPE (TARGET_SH5 ? \"long unsigned int\" : \"unsigned int\")\n+\n+#undef PTRDIFF_TYPE\n+#define PTRDIFF_TYPE (TARGET_SH5 ? \"long int\" : \"int\")\n /* Pass -ml and -mrelax to the assembler and linker.  */\n #undef ASM_SPEC\n-#define ASM_SPEC  \"%{ml:-little} %{mrelax:-relax}\"\n+#define ASM_SPEC  \"%{ml:-little} %{mrelax:-relax} \\\n+%{m5-compact:--isa=SHcompact} %{m5-compact-nofpu:--isa=SHcompact} \\\n+%{m5-32media:--isa=SHmedia --abi=32} %{m5-32media-nofpu:--isa=SHmedia --abi=32} \\\n+%{m5-64media:--isa=SHmedia --abi=64} %{m5-64media-nofpu:--isa=SHmedia --abi=64}\"\n \n #undef LINK_SPEC\n-#define LINK_SPEC \"%{ml:-m shlelf} %{mrelax:-relax}\"\n+#define LINK_SPEC \" \\\n+%{m5-compact:%{!ml:-m shelf32} %{ml:-m shlelf32}} \\\n+%{m5-compact-nofpu:%{!ml:-m shelf32} %{ml:-m shlelf32}} \\\n+%{m5-32media:%{!ml:-m shelf32} %{ml:-m shlelf32}} \\\n+%{m5-32media-nofpu:%{!ml:-m shelf32} %{ml:-m shlelf32}} \\\n+%{m5-64media:%{!ml:-m shelf64} %{ml:-m shlelf64}} \\\n+%{m5-64media-nofpu:%{!ml:-m shelf64} %{ml:-m shlelf64}} \\\n+%{!m5-64media:%{!m5-64media-nofpu:%{!m5-32media:%{!m5-32media-nofpu:%{!m5-compact:%{!m5-compact-nofpu:%{ml:-m shlelf}}}}}}} \\\n+%{mrelax:-relax}\"\n \n /* svr4.h undefined DBX_REGISTER_NUMBER, so we need to define it\n    again.  */\n-#define DBX_REGISTER_NUMBER(REGNO)\t\\\n-  (((REGNO) >= 22 && (REGNO) <= 39) ? ((REGNO) + 1) : (REGNO))\n+#define DBX_REGISTER_NUMBER(REGNO)\t\t\t\t\t\\\n+  (GENERAL_REGISTER_P (REGNO)\t\t\t\t\t\t\\\n+   ? ((REGNO) - FIRST_GENERAL_REG)\t\t\t\t\t\\\n+   : FP_REGISTER_P (REGNO)\t\t\t\t\t\t\\\n+   ? ((REGNO) - FIRST_FP_REG + (TARGET_SH5 ? (TARGET_SHCOMPACT ? 245\t\\\n+\t\t\t\t\t      : 77) : 25))\t\t\\\n+   : XD_REGISTER_P (REGNO)\t\t\t\t\t\t\\\n+   ? ((REGNO) - FIRST_XD_REG + (TARGET_SH5 ? 289 : 87))\t\t\t\\\n+   : TARGET_REGISTER_P (REGNO)\t\t\t\t\t\t\\\n+   ? ((REGNO) - FIRST_TARGET_REG + 68)\t\t\t\t\t\\\n+   : (REGNO) == PR_REG\t\t\t\t\t\t\t\\\n+   ? (TARGET_SH5 ? 241 : 17)\t\t\t\t\t\t\\\n+   : (REGNO) == T_REG\t\t\t\t\t\t\t\\\n+   ? (TARGET_SH5 ? 242 : 18)\t\t\t\t\t\t\\\n+   : (REGNO) == GBR_REG\t\t\t\t\t\t\t\\\n+   ? (TARGET_SH5 ? 238 : 19)\t\t\t\t\t\t\\\n+   : (REGNO) == MACH_REG\t\t\t\t\t\t\\\n+   ? (TARGET_SH5 ? 239 : 20)\t\t\t\t\t\t\\\n+   : (REGNO) == MACL_REG\t\t\t\t\t\t\\\n+   ? (TARGET_SH5 ? 240 : 21)\t\t\t\t\t\t\\\n+   : (REGNO) == FPUL_REG\t\t\t\t\t\t\\\n+   ? (TARGET_SH5 ? 244 : 23)\t\t\t\t\t\t\\\n+   : (abort(), -1))\n \n #undef ASM_GENERATE_INTERNAL_LABEL\n #define ASM_GENERATE_INTERNAL_LABEL(STRING, PREFIX, NUM) \\"}, {"sha": "53ca874d4c17bf845c286812c929c7c53dea58fb", "filename": "gcc/config/sh/lib1funcs.asm", "status": "modified", "additions": 934, "deletions": 4, "changes": 938, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa5322fa5824e95a7aa82413782b510c8d91e7d8/gcc%2Fconfig%2Fsh%2Flib1funcs.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa5322fa5824e95a7aa82413782b510c8d91e7d8/gcc%2Fconfig%2Fsh%2Flib1funcs.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Flib1funcs.asm?ref=fa5322fa5824e95a7aa82413782b510c8d91e7d8", "patch": "@@ -51,6 +51,11 @@ Boston, MA 02111-1307, USA.  */\n #define GLOBAL(X) ___##X\n #endif\n \n+#if defined __SH5__ && ! defined __SH4_NOFPU__\n+#define FMOVD_WORKS\n+#endif\n+\n+#if ! __SH5__\n #ifdef L_ashiftrt\n \t.global\tGLOBAL(ashiftrt_r4_0)\n \t.global\tGLOBAL(ashiftrt_r4_1)\n@@ -866,6 +871,7 @@ hiset:\tsts\tmacl,r0\t\t! r0 = bb*dd\n \n \n #endif\n+#endif /* ! __SH5__ */\n #ifdef L_sdivsi3_i4\n \t.title \"SH DIVIDE\"\n !! 4 byte integer Divide code for the Hitachi SH\n@@ -882,9 +888,13 @@ GLOBAL(sdivsi3_i4):\n \trts\n \tftrc dr0,fpul\n \n-#elif defined(__SH4_SINGLE__) || defined(__SH4_SINGLE_ONLY__)\n+#elif defined(__SH4_SINGLE__) || defined(__SH4_SINGLE_ONLY__) || (defined (__SH5__) && ! defined __SH4_NOFPU__)\n !! args in r4 and r5, result in fpul, clobber r2, dr0, dr2\n \n+#if ! __SH5__ || __SH5__ == 32\n+#if __SH5__\n+\t.mode\tSHcompact\n+#endif\n \t.global\tGLOBAL(sdivsi3_i4)\n GLOBAL(sdivsi3_i4):\n \tsts.l fpscr,@-r15\n@@ -900,6 +910,7 @@ GLOBAL(sdivsi3_i4):\n \trts\n \tlds.l @r15+,fpscr\n \n+#endif /* ! __SH5__ || __SH5__ == 32 */\n #endif /* ! __SH4__ */\n #endif\n \n@@ -916,6 +927,71 @@ GLOBAL(sdivsi3_i4):\n !! args in r4 and r5, result in r0 clobber r1,r2,r3\n \n \t.global\tGLOBAL(sdivsi3)\n+#if __SHMEDIA__\n+#if __SH5__ == 32\n+\t.section\t.text..SHmedia32,\"ax\"\n+#else\n+\t.text\n+#endif\n+\t.align\t2\n+/* The assembly code that follows is a hand-optimized version of the C\n+   code that follows.  Note that the registers that are modified are\n+   exactly those listed as clobbered in the patterns divsi3_i1 and\n+   divsi3_i1_media.\n+\t\n+int __sdivsi3 (i, j)\n+     int i, j;\n+{\n+  register unsigned long long r18 asm (\"r18\");\n+  register unsigned long long r19 asm (\"r19\");\n+  register unsigned long long r0 asm (\"r0\") = 0;\n+  register unsigned long long r1 asm (\"r1\") = 1;\n+  register int r2 asm (\"r2\") = i >> 31;\n+  register int r3 asm (\"r3\") = j >> 31;\n+\n+  r2 = r2 ? r2 : r1;\n+  r3 = r3 ? r3 : r1;\n+  r18 = i * r2;\n+  r19 = j * r3;\n+  r2 *= r3;\n+  \n+  r19 <<= 31;\n+  r1 <<= 31;\n+  do\n+    if (r18 >= r19)\n+      r0 |= r1, r18 -= r19;\n+  while (r19 >>= 1, r1 >>= 1);\n+\n+  return r2 * (int)r0;\n+}\n+*/\n+GLOBAL(sdivsi3):\n+\tpt/l\tLOCAL(sdivsi3_dontadd), tr2\n+\tpt/l\tLOCAL(sdivsi3_loop), tr1\n+\tptabs/l\tr18, tr0\n+\tmovi\t0, r0\n+\tmovi\t1, r1\n+\tshari.l\tr4, 31, r2\n+\tshari.l\tr5, 31, r3\n+\tcmveq\tr2, r1, r2\n+\tcmveq\tr3, r1, r3\n+\tmuls.l\tr4, r2, r18\n+\tmuls.l\tr5, r3, r19\n+\tmuls.l\tr2, r3, r2\n+\tshlli\tr19, 31, r19\n+\tshlli\tr1, 31, r1\n+LOCAL(sdivsi3_loop):\n+\tbgtu\tr19, r18, tr2\n+\tor\tr0, r1, r0\n+\tsub\tr18, r19, r18\n+LOCAL(sdivsi3_dontadd):\n+\tshlri\tr1, 1, r1\n+\tshlri\tr19, 1, r19\n+\tbnei\tr1, 0, tr1\n+\tmuls.l\tr0, r2, r0\n+\tadd.l\tr0, r63, r0\n+\tblink\ttr0, r63\n+#else\n GLOBAL(sdivsi3):\n \tmov\tr4,r1\n \tmov\tr5,r0\n@@ -1000,6 +1076,7 @@ GLOBAL(sdivsi3):\n div0:\trts\n \tmov\t#0,r0\n \n+#endif /* ! __SHMEDIA__ */\n #endif /* ! __SH4__ */\n #endif\n #ifdef L_udivsi3_i4\n@@ -1050,9 +1127,13 @@ trivial:\n L1:\n \t.double 2147483648\n \n-#elif defined(__SH4_SINGLE__) || defined(__SH4_SINGLE_ONLY__)\n+#elif defined(__SH4_SINGLE__) || defined(__SH4_SINGLE_ONLY__) || (defined (__SH5__) && ! defined __SH4_NOFPU__)\n !! args in r4 and r5, result in fpul, clobber r0, r1, r4, r5, dr0, dr2, dr4\n \n+#if ! __SH5__ || __SH5__ == 32\n+#if __SH5__\n+\t.mode\tSHcompact\n+#endif\n \t.global\tGLOBAL(udivsi3_i4)\n GLOBAL(udivsi3_i4):\n \tmov #1,r1\n@@ -1102,6 +1183,7 @@ L1:\n #endif\n \t.double 2147483648\n \n+#endif /* ! __SH5__ || __SH5__ == 32 */\n #endif /* ! __SH4__ */\n #endif\n \n@@ -1118,6 +1200,57 @@ L1:\n !! args in r4 and r5, result in r0, clobbers r4, pr, and t bit\n \t.global\tGLOBAL(udivsi3)\n \n+#if __SHMEDIA__\n+#if __SH5__ == 32\n+\t.section\t.text..SHmedia32,\"ax\"\n+#else\n+\t.text\n+#endif\n+\t.align\t2\n+/* The assembly code that follows is a hand-optimized version of the C\n+   code that follows.  Note that the registers that are modified are\n+   exactly those listed as clobbered in the patterns udivsi3_i1 and\n+   udivsi3_i1_media.\n+\t\n+unsigned \n+__udivsi3 (i, j)\n+    unsigned i, j; \n+{\n+  register unsigned long long r0 asm (\"r0\") = 0;\n+  register unsigned long long r18 asm (\"r18\") = 1;\n+  register unsigned long long r4 asm (\"r4\") = i;\n+  register unsigned long long r19 asm (\"r19\") = j;\n+\n+  r19 <<= 31;\n+  r18 <<= 31;\n+  do\n+    if (r4 >= r19)\n+      r0 |= r18, r4 -= r19;\n+  while (r19 >>= 1, r18 >>= 1);\n+\n+  return r0;\n+}\n+*/\n+GLOBAL(udivsi3):\n+\tpt/l\tLOCAL(udivsi3_dontadd), tr2\n+\tpt/l\tLOCAL(udivsi3_loop), tr1\n+\tptabs/l\tr18, tr0\n+\tmovi\t0, r0\n+\tmovi\t1, r18\n+\taddz.l\tr5, r63, r19\n+\taddz.l\tr4, r63, r4\n+\tshlli\tr19, 31, r19\n+\tshlli\tr18, 31, r18\n+LOCAL(udivsi3_loop):\n+\tbgtu\tr19, r4, tr2\n+\tor\tr0, r18, r0\n+\tsub\tr4, r19, r4\n+LOCAL(udivsi3_dontadd):\n+\tshlri\tr18, 1, r18\n+\tshlri\tr19, 1, r19\n+\tbnei\tr18, 0, tr1\n+\tblink\ttr0, r63\n+#else\n GLOBAL(udivsi3):\n longway:\n \tmov\t#0,r0\n@@ -1166,10 +1299,14 @@ vshortway:\n ret:\trts\n \tmov\tr4,r0\n \n+#endif /* ! __SHMEDIA__ */\n #endif /* __SH4__ */\n #endif\n #ifdef L_set_fpscr\n-#if defined (__SH3E__) || defined(__SH4_SINGLE__) || defined(__SH4__) || defined(__SH4_SINGLE_ONLY__)\n+#if defined (__SH3E__) || defined(__SH4_SINGLE__) || defined(__SH4__) || defined(__SH4_SINGLE_ONLY__) || __SH5__ == 32\n+#ifdef __SH5__\n+\t.mode\tSHcompact\n+#endif\n \t.global GLOBAL(set_fpscr)\n GLOBAL(set_fpscr):\n \tlds r4,fpscr\n@@ -1211,7 +1348,17 @@ LOCAL(set_fpscr_L1):\n #endif /* SH3E / SH4 */\n #endif /* L_set_fpscr */\n #ifdef L_ic_invalidate\n-#if defined(__SH4_SINGLE__) || defined(__SH4__) || defined(__SH4_SINGLE_ONLY__)\n+#if __SH5__ == 32\n+\t.mode\tSHmedia\n+\t.section\t.text..SHmedia32,\"ax\"\n+\t.align\t2\n+\t.global\tGLOBAL(ic_invalidate)\n+GLOBAL(ic_invalidate):\n+\ticbi\tr0, 0\n+\tptabs\tr18, tr0\n+\tsynci\n+\tblink\ttr0, r63\n+#elif defined(__SH4_SINGLE__) || defined(__SH4__) || defined(__SH4_SINGLE_ONLY__)\n \t.global GLOBAL(ic_invalidate)\n GLOBAL(ic_invalidate):\n \tocbwb\t@r4\n@@ -1237,3 +1384,786 @@ GLOBAL(ic_invalidate):\n \t.endr\n #endif /* SH4 */\n #endif /* L_ic_invalidate */\n+\n+#if defined (__SH5__) && __SH5__ == 32\n+#ifdef L_shcompact_call_trampoline\n+\t.section\t.rodata\n+\t.align\t1\n+LOCAL(ct_main_table):\n+.word\tLOCAL(ct_r2_fp) - datalabel LOCAL(ct_main_label)\n+.word\tLOCAL(ct_r2_ld) - datalabel LOCAL(ct_main_label)\n+.word\tLOCAL(ct_r2_pop) - datalabel LOCAL(ct_main_label)\n+.word\tLOCAL(ct_r3_fp) - datalabel LOCAL(ct_main_label)\n+.word\tLOCAL(ct_r3_ld) - datalabel LOCAL(ct_main_label)\n+.word\tLOCAL(ct_r3_pop) - datalabel LOCAL(ct_main_label)\n+.word\tLOCAL(ct_r4_fp) - datalabel LOCAL(ct_main_label)\n+.word\tLOCAL(ct_r4_ld) - datalabel LOCAL(ct_main_label)\n+.word\tLOCAL(ct_r4_pop) - datalabel LOCAL(ct_main_label)\n+.word\tLOCAL(ct_r5_fp) - datalabel LOCAL(ct_main_label)\n+.word\tLOCAL(ct_r5_ld) - datalabel LOCAL(ct_main_label)\n+.word\tLOCAL(ct_r5_pop) - datalabel LOCAL(ct_main_label)\n+.word\tLOCAL(ct_r6_fph) - datalabel LOCAL(ct_main_label)\n+.word\tLOCAL(ct_r6_fpl) - datalabel LOCAL(ct_main_label)\n+.word\tLOCAL(ct_r6_ld) - datalabel LOCAL(ct_main_label)\n+.word\tLOCAL(ct_r6_pop) - datalabel LOCAL(ct_main_label)\n+.word\tLOCAL(ct_r7_fph) - datalabel LOCAL(ct_main_label)\n+.word\tLOCAL(ct_r7_fpl) - datalabel LOCAL(ct_main_label)\n+.word\tLOCAL(ct_r7_ld) - datalabel LOCAL(ct_main_label)\n+.word\tLOCAL(ct_r7_pop) - datalabel LOCAL(ct_main_label)\n+.word\tLOCAL(ct_r8_fph) - datalabel LOCAL(ct_main_label)\n+.word\tLOCAL(ct_r8_fpl) - datalabel LOCAL(ct_main_label)\n+.word\tLOCAL(ct_r8_ld) - datalabel LOCAL(ct_main_label)\n+.word\tLOCAL(ct_r8_pop) - datalabel LOCAL(ct_main_label)\n+.word\tLOCAL(ct_r9_fph) - datalabel LOCAL(ct_main_label)\n+.word\tLOCAL(ct_r9_fpl) - datalabel LOCAL(ct_main_label)\n+.word\tLOCAL(ct_r9_ld) - datalabel LOCAL(ct_main_label)\n+.word\tLOCAL(ct_r9_pop) - datalabel LOCAL(ct_main_label)\n+.word\tLOCAL(ct_pop_seq) - datalabel LOCAL(ct_main_label)\n+.word\tLOCAL(ct_pop_seq) - datalabel LOCAL(ct_main_label)\n+.word\tLOCAL(ct_r9_pop) - datalabel LOCAL(ct_main_label)\n+.word\tLOCAL(ct_ret_wide) - datalabel LOCAL(ct_main_label)\n+.word\tLOCAL(ct_call_func) - datalabel LOCAL(ct_main_label)\n+\t.mode\tSHmedia\n+\t.section\t.text..SHmedia32, \"ax\"\n+\t.align\t2\n+\t\n+     /* This function loads 64-bit general-purpose registers from the\n+\tstack, from a memory address contained in them or from an FP\n+\tregister, according to a cookie passed in r1.  Its execution\n+\ttime is linear on the number of registers that actually have\n+\tto be copied.  See sh.h for details on the actual bit pattern.\n+\n+\tThe function to be called is passed in r0.  If a 32-bit return\n+\tvalue is expected, the actual function will be tail-called,\n+\totherwise the return address will be stored in r10 (that the\n+\tcaller should expect to be clobbered) and the return value\n+\twill be expanded into r2/r3 upon return.  */\n+\t\n+\t.global\tGLOBAL(GCC_shcompact_call_trampoline)\n+GLOBAL(GCC_shcompact_call_trampoline):\n+\tptabs/l\tr0, tr0\t/* Prepare to call the actual function.  */\n+\tmovi\t((datalabel LOCAL(ct_main_table) - 31 * 2) >> 16) & 65535, r0\n+\tpt/l\tLOCAL(ct_loop), tr1\n+\taddz.l\tr1, r63, r1\n+\tshori\t((datalabel LOCAL(ct_main_table) - 31 * 2)) & 65535, r0\n+LOCAL(ct_loop):\n+\tnsb\tr1, r28\n+\tshlli\tr28, 1, r29\n+\tldx.w\tr0, r29, r30\n+LOCAL(ct_main_label):\n+\tptrel/l\tr30, tr2\n+\tblink\ttr2, r63\n+LOCAL(ct_r2_fp):\t/* Copy r2 from an FP register.  */\n+\t/* It must be dr0, so just do it.  */\n+\tfmov.dq\tdr0, r2\n+\tmovi\t7, r30\n+\tshlli\tr30, 29, r31\n+\tandc\tr1, r31, r1\n+\tblink\ttr1, r63\n+LOCAL(ct_r3_fp):\t/* Copy r3 from an FP register.  */\n+\t/* It is either dr0 or dr2.  */\n+\tmovi\t7, r30\n+\tshlri\tr1, 26, r32\n+\tshlli\tr30, 26, r31\n+\tandc\tr1, r31, r1\n+\tfmov.dq\tdr0, r3\n+\tbeqi/l\tr32, 4, tr1\n+\tfmov.dq\tdr2, r3\n+\tblink\ttr1, r63\n+LOCAL(ct_r4_fp):\t/* Copy r4 from an FP register.  */\n+\tshlri\tr1, 23 - 3, r34\n+\tandi\tr34, 3 << 3, r33\n+\taddi\tr33, LOCAL(ct_r4_fp_copy) - datalabel LOCAL(ct_r4_fp_base), r32\n+LOCAL(ct_r4_fp_base):\n+\tptrel/l\tr32, tr2\n+\tmovi\t7, r30\n+\tshlli\tr30, 23, r31\n+\tandc\tr1, r31, r1\n+\tblink\ttr2, r63\n+LOCAL(ct_r4_fp_copy):\n+\tfmov.dq\tdr0, r4\n+\tblink\ttr1, r63\n+\tfmov.dq\tdr2, r4\n+\tblink\ttr1, r63\n+\tfmov.dq\tdr4, r4\n+\tblink\ttr1, r63\n+LOCAL(ct_r5_fp):\t/* Copy r5 from an FP register.  */\n+\tshlri\tr1, 20 - 3, r34\n+\tandi\tr34, 3 << 3, r33\n+\taddi\tr33, LOCAL(ct_r5_fp_copy) - datalabel LOCAL(ct_r5_fp_base), r32\n+LOCAL(ct_r5_fp_base):\n+\tptrel/l\tr32, tr2\n+\tmovi\t7, r30\n+\tshlli\tr30, 20, r31\n+\tandc\tr1, r31, r1\n+\tblink\ttr2, r63\n+LOCAL(ct_r5_fp_copy):\n+\tfmov.dq\tdr0, r5\n+\tblink\ttr1, r63\n+\tfmov.dq\tdr2, r5\n+\tblink\ttr1, r63\n+\tfmov.dq\tdr4, r5\n+\tblink\ttr1, r63\n+\tfmov.dq\tdr6, r5\n+\tblink\ttr1, r63\n+LOCAL(ct_r6_fph):\t/* Copy r6 from a high FP register.  */\n+\t/* It must be dr8.  */\n+\tfmov.dq\tdr8, r6\n+\tmovi\t15, r30\n+\tshlli\tr30, 16, r31\n+\tandc\tr1, r31, r1\n+\tblink\ttr1, r63\n+LOCAL(ct_r6_fpl):\t/* Copy r6 from a low FP register.  */\n+\tshlri\tr1, 16 - 3, r34\n+\tandi\tr34, 3 << 3, r33\n+\taddi\tr33, LOCAL(ct_r6_fp_copy) - datalabel LOCAL(ct_r6_fp_base), r32\n+LOCAL(ct_r6_fp_base):\n+\tptrel/l\tr32, tr2\n+\tmovi\t7, r30\n+\tshlli\tr30, 16, r31\n+\tandc\tr1, r31, r1\n+\tblink\ttr2, r63\n+LOCAL(ct_r6_fp_copy):\n+\tfmov.dq\tdr0, r6\n+\tblink\ttr1, r63\n+\tfmov.dq\tdr2, r6\n+\tblink\ttr1, r63\n+\tfmov.dq\tdr4, r6\n+\tblink\ttr1, r63\n+\tfmov.dq\tdr6, r6\n+\tblink\ttr1, r63\n+LOCAL(ct_r7_fph):\t/* Copy r7 from a high FP register.  */\n+\t/* It is either dr8 or dr10.  */\n+\tmovi\t15 << 12, r31\n+\tshlri\tr1, 12, r32\n+\tandc\tr1, r31, r1\n+\tfmov.dq\tdr8, r7\n+\tbeqi/l\tr32, 8, tr1\n+\tfmov.dq\tdr10, r7\n+\tblink\ttr1, r63\n+LOCAL(ct_r7_fpl):\t/* Copy r7 from a low FP register.  */\n+\tshlri\tr1, 12 - 3, r34\n+\tandi\tr34, 3 << 3, r33\n+\taddi\tr33, LOCAL(ct_r7_fp_copy) - datalabel LOCAL(ct_r7_fp_base), r32\n+LOCAL(ct_r7_fp_base):\n+\tptrel/l\tr32, tr2\n+\tmovi\t7 << 12, r31\n+\tandc\tr1, r31, r1\n+\tblink\ttr2, r63\n+LOCAL(ct_r7_fp_copy):\n+\tfmov.dq\tdr0, r7\n+\tblink\ttr1, r63\n+\tfmov.dq\tdr2, r7\n+\tblink\ttr1, r63\n+\tfmov.dq\tdr4, r7\n+\tblink\ttr1, r63\n+\tfmov.dq\tdr6, r7\n+\tblink\ttr1, r63\n+LOCAL(ct_r8_fph):\t/* Copy r8 from a high FP register.  */\n+\t/* It is either dr8 or dr10.  */\n+\tmovi\t15 << 8, r31\n+\tandi\tr1, 1 << 8, r32\n+\tandc\tr1, r31, r1\n+\tfmov.dq\tdr8, r8\n+\tbeq/l\tr32, r63, tr1\n+\tfmov.dq\tdr10, r8\n+\tblink\ttr1, r63\n+LOCAL(ct_r8_fpl):\t/* Copy r8 from a low FP register.  */\n+\tshlri\tr1, 8 - 3, r34\n+\tandi\tr34, 3 << 3, r33\n+\taddi\tr33, LOCAL(ct_r8_fp_copy) - datalabel LOCAL(ct_r8_fp_base), r32\n+LOCAL(ct_r8_fp_base):\n+\tptrel/l\tr32, tr2\n+\tmovi\t7 << 8, r31\n+\tandc\tr1, r31, r1\n+\tblink\ttr2, r63\n+LOCAL(ct_r8_fp_copy):\n+\tfmov.dq\tdr0, r8\n+\tblink\ttr1, r63\n+\tfmov.dq\tdr2, r8\n+\tblink\ttr1, r63\n+\tfmov.dq\tdr4, r8\n+\tblink\ttr1, r63\n+\tfmov.dq\tdr6, r8\n+\tblink\ttr1, r63\n+LOCAL(ct_r9_fph):\t/* Copy r9 from a high FP register.  */\n+\t/* It is either dr8 or dr10.  */\n+\tmovi\t15 << 4, r31\n+\tandi\tr1, 1 << 4, r32\n+\tandc\tr1, r31, r1\n+\tfmov.dq\tdr8, r9\n+\tbeq/l\tr32, r63, tr1\n+\tfmov.dq\tdr10, r9\n+\tblink\ttr1, r63\n+LOCAL(ct_r9_fpl):\t/* Copy r9 from a low FP register.  */\n+\tshlri\tr1, 4 - 3, r34\n+\tandi\tr34, 3 << 3, r33\n+\taddi\tr33, LOCAL(ct_r9_fp_copy) - datalabel LOCAL(ct_r9_fp_base), r32\n+LOCAL(ct_r9_fp_base):\n+\tptrel/l\tr32, tr2\n+\tmovi\t7 << 4, r31\n+\tandc\tr1, r31, r1\n+\tblink\ttr2, r63\n+LOCAL(ct_r9_fp_copy):\n+\tfmov.dq\tdr0, r9\n+\tblink\ttr1, r63\n+\tfmov.dq\tdr2, r9\n+\tblink\ttr1, r63\n+\tfmov.dq\tdr4, r9\n+\tblink\ttr1, r63\n+\tfmov.dq\tdr6, r9\n+\tblink\ttr1, r63\n+LOCAL(ct_r2_ld):\t/* Copy r2 from a memory address.  */\n+\tpt/l\tLOCAL(ct_r2_load), tr2\n+\tmovi\t3, r30\n+\tshlli\tr30, 29, r31\n+\tand\tr1, r31, r32\n+\tandc\tr1, r31, r1\n+\tbeq/l\tr31, r32, tr2\n+\taddi.l\tr2, 8, r3\n+\tldx.q\tr2, r63, r2\n+\t/* Fall through.  */\n+LOCAL(ct_r3_ld):\t/* Copy r3 from a memory address.  */\n+\tpt/l\tLOCAL(ct_r3_load), tr2\n+\tmovi\t3, r30\n+\tshlli\tr30, 26, r31\n+\tand\tr1, r31, r32\n+\tandc\tr1, r31, r1\n+\tbeq/l\tr31, r32, tr2\n+\taddi.l\tr3, 8, r4\n+\tldx.q\tr3, r63, r3\n+LOCAL(ct_r4_ld):\t/* Copy r4 from a memory address.  */\n+\tpt/l\tLOCAL(ct_r4_load), tr2\n+\tmovi\t3, r30\n+\tshlli\tr30, 23, r31\n+\tand\tr1, r31, r32\n+\tandc\tr1, r31, r1\n+\tbeq/l\tr31, r32, tr2\n+\taddi.l\tr4, 8, r5\n+\tldx.q\tr4, r63, r4\n+LOCAL(ct_r5_ld):\t/* Copy r5 from a memory address.  */\n+\tpt/l\tLOCAL(ct_r5_load), tr2\n+\tmovi\t3, r30\n+\tshlli\tr30, 20, r31\n+\tand\tr1, r31, r32\n+\tandc\tr1, r31, r1\n+\tbeq/l\tr31, r32, tr2\n+\taddi.l\tr5, 8, r6\n+\tldx.q\tr5, r63, r5\n+LOCAL(ct_r6_ld):\t/* Copy r6 from a memory address.  */\n+\tpt/l\tLOCAL(ct_r6_load), tr2\n+\tmovi\t3 << 16, r31\n+\tand\tr1, r31, r32\n+\tandc\tr1, r31, r1\n+\tbeq/l\tr31, r32, tr2\n+\taddi.l\tr6, 8, r7\n+\tldx.q\tr6, r63, r6\n+LOCAL(ct_r7_ld):\t/* Copy r7 from a memory address.  */\n+\tpt/l\tLOCAL(ct_r7_load), tr2\n+\tmovi\t3 << 12, r31\n+\tand\tr1, r31, r32\n+\tandc\tr1, r31, r1\n+\tbeq/l\tr31, r32, tr2\n+\taddi.l\tr7, 8, r8\n+\tldx.q\tr7, r63, r7\n+LOCAL(ct_r8_ld):\t/* Copy r8 from a memory address.  */\n+\tpt/l\tLOCAL(ct_r8_load), tr2\n+\tmovi\t3 << 8, r31\n+\tand\tr1, r31, r32\n+\tandc\tr1, r31, r1\n+\tbeq/l\tr31, r32, tr2\n+\taddi.l\tr8, 8, r9\n+\tldx.q\tr8, r63, r8\n+LOCAL(ct_r9_ld):\t/* Copy r9 from a memory address.  */\n+\tpt/l\tLOCAL(ct_check_tramp), tr2\n+\tldx.q\tr9, r63, r9\n+\tblink\ttr2, r63\n+LOCAL(ct_r2_load):\n+\tldx.q\tr2, r63, r2\n+\tblink\ttr1, r63\n+LOCAL(ct_r3_load):\n+\tldx.q\tr3, r63, r3\n+\tblink\ttr1, r63\n+LOCAL(ct_r4_load):\n+\tldx.q\tr4, r63, r4\n+\tblink\ttr1, r63\n+LOCAL(ct_r5_load):\n+\tldx.q\tr5, r63, r5\n+\tblink\ttr1, r63\n+LOCAL(ct_r6_load):\n+\tldx.q\tr6, r63, r6\n+\tblink\ttr1, r63\n+LOCAL(ct_r7_load):\n+\tldx.q\tr7, r63, r7\n+\tblink\ttr1, r63\n+LOCAL(ct_r8_load):\n+\tldx.q\tr8, r63, r8\n+\tblink\ttr1, r63\n+LOCAL(ct_r2_pop):\t/* Pop r2 from the stack.  */\n+\tmovi\t1, r30\n+\tldx.q\tr15, r63, r2\n+\tshlli\tr30, 29, r31\n+\taddi.l\tr15, 8, r15\n+\tandc\tr1, r31, r1\n+\tblink\ttr1, r63\n+LOCAL(ct_r3_pop):\t/* Pop r3 from the stack.  */\n+\tmovi\t1, r30\n+\tldx.q\tr15, r63, r3\n+\tshlli\tr30, 26, r31\n+\taddi.l\tr15, 8, r15\n+\tandc\tr1, r31, r1\n+\tblink\ttr1, r63\n+LOCAL(ct_r4_pop):\t/* Pop r4 from the stack.  */\n+\tmovi\t1, r30\n+\tldx.q\tr15, r63, r4\n+\tshlli\tr30, 23, r31\n+\taddi.l\tr15, 8, r15\n+\tandc\tr1, r31, r1\n+\tblink\ttr1, r63\n+LOCAL(ct_r5_pop):\t/* Pop r5 from the stack.  */\n+\tmovi\t1, r30\n+\tldx.q\tr15, r63, r5\n+\tshlli\tr30, 20, r31\n+\taddi.l\tr15, 8, r15\n+\tandc\tr1, r31, r1\n+\tblink\ttr1, r63\n+LOCAL(ct_r6_pop):\t/* Pop r6 from the stack.  */\n+\tmovi\t1, r30\n+\tldx.q\tr15, r63, r6\n+\tshlli\tr30, 16, r31\n+\taddi.l\tr15, 8, r15\n+\tandc\tr1, r31, r1\n+\tblink\ttr1, r63\n+LOCAL(ct_r7_pop):\t/* Pop r7 from the stack.  */\n+\tldx.q\tr15, r63, r7\n+\tmovi\t1 << 12, r31\n+\taddi.l\tr15, 8, r15\n+\tandc\tr1, r31, r1\n+\tblink\ttr1, r63\n+LOCAL(ct_r8_pop):\t/* Pop r8 from the stack.  */\n+\tldx.q\tr15, r63, r8\n+\tmovi\t1 << 8, r31\n+\taddi.l\tr15, 8, r15\n+\tandc\tr1, r31, r1\n+\tblink\ttr1, r63\n+LOCAL(ct_pop_seq):\t/* Pop a sequence of registers off the stack.  */\n+\tandi\tr1, 7 << 1, r30\n+\tmovi\t(LOCAL(ct_end_of_pop_seq) >> 16) & 65535, r32\n+\tshlli\tr30, 2, r31\n+\tshori\tLOCAL(ct_end_of_pop_seq) & 65535, r32\n+\tsub.l\tr32, r31, r33\n+\tptabs/l\tr33, tr2\n+\tblink\ttr2, r63\n+LOCAL(ct_start_of_pop_seq):\t/* Beginning of pop sequence.  */\n+\tldx.q\tr15, r63, r3\n+\taddi.l\tr15, 8, r15\n+\tldx.q\tr15, r63, r4\n+\taddi.l\tr15, 8, r15\n+\tldx.q\tr15, r63, r5\n+\taddi.l\tr15, 8, r15\n+\tldx.q\tr15, r63, r6\n+\taddi.l\tr15, 8, r15\n+\tldx.q\tr15, r63, r7\n+\taddi.l\tr15, 8, r15\n+\tldx.q\tr15, r63, r8\n+\taddi.l\tr15, 8, r15\n+LOCAL(ct_r9_pop):\t/* Pop r9 from the stack.  */\n+\tldx.q\tr15, r63, r9\n+\taddi.l\tr15, 8, r15\n+LOCAL(ct_end_of_pop_seq): /* Label used to compute first pop instruction.  */\n+LOCAL(ct_check_tramp):\t/* Check whether we need a trampoline.  */\n+\tpt/u\tLOCAL(ct_ret_wide), tr2\n+\tandi\tr1, 1, r1\n+\tbne/u\tr1, r63, tr2\n+LOCAL(ct_call_func):\t/* Just branch to the function.  */\n+\tblink\ttr0, r63\n+LOCAL(ct_ret_wide):\t/* Call the function, so that we can unpack its \n+\t\t\t   64-bit return value.  */\n+\tadd.l\tr18, r63, r10\n+\tblink\ttr0, r18\n+\tptabs\tr10, tr0\n+#if __LITTLE_ENDIAN__\n+\tshari\tr2, 32, r3\n+\tadd.l\tr2, r63, r2\n+#else\n+\tadd.l\tr2, r63, r3\n+\tshari\tr2, 32, r2\n+#endif\n+\tblink\ttr0, r63\n+#endif /* L_shcompact_call_trampoline */\n+\n+#ifdef L_shcompact_return_trampoline\n+     /* This function does the converse of the code in `ret_wide'\n+\tabove.  It is tail-called by SHcompact functions returning\n+\t64-bit non-floating-point values, to pack the 32-bit values in\n+\tr2 and r3 into r2.  */\n+\n+\t.mode\tSHmedia\n+\t.section\t.text..SHmedia32, \"ax\"\n+\t.align\t2\n+\t.global\tGLOBAL(GCC_shcompact_return_trampoline)\n+GLOBAL(GCC_shcompact_return_trampoline):\n+\tptabs/l\tr18, tr0\n+#if __LITTLE_ENDIAN__\n+\taddz.l\tr2, r63, r2\n+\tshlli\tr3, 32, r3\n+#else\n+\taddz.l\tr3, r63, r3\n+\tshlli\tr2, 32, r2\n+#endif\n+\tor\tr3, r2, r2\n+\tblink\ttr0, r63\n+#endif /* L_shcompact_return_trampoline */\n+\n+#ifdef L_shcompact_incoming_args\n+\t.section\t.rodata\n+\t.align\t1\n+LOCAL(ia_main_table):\n+.word\t1 /* Invalid, just loop */\n+.word\tLOCAL(ia_r2_ld) - datalabel LOCAL(ia_main_label)\n+.word\tLOCAL(ia_r2_push) - datalabel LOCAL(ia_main_label)\n+.word\t1 /* Invalid, just loop */\n+.word\tLOCAL(ia_r3_ld) - datalabel LOCAL(ia_main_label)\n+.word\tLOCAL(ia_r3_push) - datalabel LOCAL(ia_main_label)\n+.word\t1 /* Invalid, just loop */\n+.word\tLOCAL(ia_r4_ld) - datalabel LOCAL(ia_main_label)\n+.word\tLOCAL(ia_r4_push) - datalabel LOCAL(ia_main_label)\n+.word\t1 /* Invalid, just loop */\n+.word\tLOCAL(ia_r5_ld) - datalabel LOCAL(ia_main_label)\n+.word\tLOCAL(ia_r5_push) - datalabel LOCAL(ia_main_label)\n+.word\t1 /* Invalid, just loop */\n+.word\t1 /* Invalid, just loop */\n+.word\tLOCAL(ia_r6_ld) - datalabel LOCAL(ia_main_label)\n+.word\tLOCAL(ia_r6_push) - datalabel LOCAL(ia_main_label)\n+.word\t1 /* Invalid, just loop */\n+.word\t1 /* Invalid, just loop */\n+.word\tLOCAL(ia_r7_ld) - datalabel LOCAL(ia_main_label)\n+.word\tLOCAL(ia_r7_push) - datalabel LOCAL(ia_main_label)\n+.word\t1 /* Invalid, just loop */\n+.word\t1 /* Invalid, just loop */\n+.word\tLOCAL(ia_r8_ld) - datalabel LOCAL(ia_main_label)\n+.word\tLOCAL(ia_r8_push) - datalabel LOCAL(ia_main_label)\n+.word\t1 /* Invalid, just loop */\n+.word\t1 /* Invalid, just loop */\n+.word\tLOCAL(ia_r9_ld) - datalabel LOCAL(ia_main_label)\n+.word\tLOCAL(ia_r9_push) - datalabel LOCAL(ia_main_label)\n+.word\tLOCAL(ia_push_seq) - datalabel LOCAL(ia_main_label)\n+.word\tLOCAL(ia_push_seq) - datalabel LOCAL(ia_main_label)\n+.word\tLOCAL(ia_r9_push) - datalabel LOCAL(ia_main_label)\n+.word\tLOCAL(ia_return) - datalabel LOCAL(ia_main_label)\n+.word\tLOCAL(ia_return) - datalabel LOCAL(ia_main_label)\n+\t.mode\tSHmedia\n+\t.section\t.text..SHmedia32, \"ax\"\n+\t.align\t2\n+\t\n+     /* This function stores 64-bit general-purpose registers back in\n+\tthe stack, starting at @(r1), where the cookie is supposed to\n+\thave been stored, and loads the address in which each register\n+\twas stored into itself.  Its execution time is linear on the\n+\tnumber of registers that actually have to be copied, and it is\n+\toptimized for structures larger than 64 bits, as opposed to\n+\tinvidivual `long long' arguments.  See sh.h for details on the\n+\tactual bit pattern.  */\n+\t\n+\t.global\tGLOBAL(GCC_shcompact_incoming_args)\n+GLOBAL(GCC_shcompact_incoming_args):\n+\tptabs/l\tr18, tr0\t/* Prepare to return.  */\n+\tshlri\tr17, 32, r0\t/* Load the cookie.  */\n+\tmovi\t((datalabel LOCAL(ia_main_table) - 31 * 2) >> 16) & 65535, r35\n+\tpt/l\tLOCAL(ia_loop), tr1\n+\tadd.l\tr17, r63, r17\n+\tshori\t((datalabel LOCAL(ia_main_table) - 31 * 2)) & 65535, r35\n+LOCAL(ia_loop):\n+\tnsb\tr0, r28\n+\tshlli\tr28, 1, r29\n+\tldx.w\tr35, r29, r30\n+LOCAL(ia_main_label):\n+\tptrel/l\tr30, tr2\n+\tblink\ttr2, r63\n+LOCAL(ia_r2_ld):\t/* Store r2 and load its address.  */\n+\tmovi\t3, r30\n+\tshlli\tr30, 29, r31\n+\tand\tr0, r31, r32\n+\tandc\tr0, r31, r0\n+\tstx.q\tr17, r63, r2\n+\tadd.l\tr17, r63, r2\n+\taddi.l\tr17, 8, r17\n+\tbeq/u\tr31, r32, tr1\n+LOCAL(ia_r3_ld):\t/* Store r3 and load its address.  */\n+\tmovi\t3, r30\n+\tshlli\tr30, 26, r31\n+\tand\tr0, r31, r32\n+\tandc\tr0, r31, r0\n+\tstx.q\tr17, r63, r3\n+\tadd.l\tr17, r63, r3\n+\taddi.l\tr17, 8, r17\n+\tbeq/u\tr31, r32, tr1\n+LOCAL(ia_r4_ld):\t/* Store r4 and load its address.  */\n+\tmovi\t3, r30\n+\tshlli\tr30, 23, r31\n+\tand\tr0, r31, r32\n+\tandc\tr0, r31, r0\n+\tstx.q\tr17, r63, r4\n+\tadd.l\tr17, r63, r4\n+\taddi.l\tr17, 8, r17\n+\tbeq/u\tr31, r32, tr1\n+LOCAL(ia_r5_ld):\t/* Store r5 and load its address.  */\n+\tmovi\t3, r30\n+\tshlli\tr30, 20, r31\n+\tand\tr0, r31, r32\n+\tandc\tr0, r31, r0\n+\tstx.q\tr17, r63, r5\n+\tadd.l\tr17, r63, r5\n+\taddi.l\tr17, 8, r17\n+\tbeq/u\tr31, r32, tr1\n+LOCAL(ia_r6_ld):\t/* Store r6 and load its address.  */\n+\tmovi\t3, r30\n+\tshlli\tr30, 16, r31\n+\tand\tr0, r31, r32\n+\tandc\tr0, r31, r0\n+\tstx.q\tr17, r63, r6\n+\tadd.l\tr17, r63, r6\n+\taddi.l\tr17, 8, r17\n+\tbeq/u\tr31, r32, tr1\n+LOCAL(ia_r7_ld):\t/* Store r7 and load its address.  */\n+\tmovi\t3 << 12, r31\n+\tand\tr0, r31, r32\n+\tandc\tr0, r31, r0\n+\tstx.q\tr17, r63, r7\n+\tadd.l\tr17, r63, r7\n+\taddi.l\tr17, 8, r17\n+\tbeq/u\tr31, r32, tr1\n+LOCAL(ia_r8_ld):\t/* Store r8 and load its address.  */\n+\tmovi\t3 << 8, r31\n+\tand\tr0, r31, r32\n+\tandc\tr0, r31, r0\n+\tstx.q\tr17, r63, r8\n+\tadd.l\tr17, r63, r8\n+\taddi.l\tr17, 8, r17\n+\tbeq/u\tr31, r32, tr1\n+LOCAL(ia_r9_ld):\t/* Store r9 and load its address.  */\n+\tstx.q\tr17, r63, r9\n+\tadd.l\tr17, r63, r9\n+\tblink\ttr0, r63\n+LOCAL(ia_r2_push):\t/* Push r2 onto the stack.  */\n+\tmovi\t1, r30\n+\tshlli\tr30, 29, r31\n+\tandc\tr0, r31, r0\n+\tstx.q\tr17, r63, r2\n+\taddi.l\tr17, 8, r17\n+\tblink\ttr1, r63\n+LOCAL(ia_r3_push):\t/* Push r3 onto the stack.  */\n+\tmovi\t1, r30\n+\tshlli\tr30, 26, r31\n+\tandc\tr0, r31, r0\n+\tstx.q\tr17, r63, r3\n+\taddi.l\tr17, 8, r17\n+\tblink\ttr1, r63\n+LOCAL(ia_r4_push):\t/* Push r4 onto the stack.  */\n+\tmovi\t1, r30\n+\tshlli\tr30, 23, r31\n+\tandc\tr0, r31, r0\n+\tstx.q\tr17, r63, r4\n+\taddi.l\tr17, 8, r17\n+\tblink\ttr1, r63\n+LOCAL(ia_r5_push):\t/* Push r5 onto the stack.  */\n+\tmovi\t1, r30\n+\tshlli\tr30, 20, r31\n+\tandc\tr0, r31, r0\n+\tstx.q\tr17, r63, r5\n+\taddi.l\tr17, 8, r17\n+\tblink\ttr1, r63\n+LOCAL(ia_r6_push):\t/* Push r6 onto the stack.  */\n+\tmovi\t1, r30\n+\tshlli\tr30, 16, r31\n+\tandc\tr0, r31, r0\n+\tstx.q\tr17, r63, r6\n+\taddi.l\tr17, 8, r17\n+\tblink\ttr1, r63\n+LOCAL(ia_r7_push):\t/* Push r7 onto the stack.  */\n+\tmovi\t1 << 12, r31\n+\tandc\tr0, r31, r0\n+\tstx.q\tr17, r63, r7\n+\taddi.l\tr17, 8, r17\n+\tblink\ttr1, r63\n+LOCAL(ia_r8_push):\t/* Push r8 onto the stack.  */\n+\tmovi\t1 << 8, r31\n+\tandc\tr0, r31, r0\n+\tstx.q\tr17, r63, r8\n+\taddi.l\tr17, 8, r17\n+\tblink\ttr1, r63\n+LOCAL(ia_push_seq):\t/* Push a sequence of registers onto the stack.  */\n+\tandi\tr0, 7 << 1, r30\n+\tmovi\t(LOCAL(ia_end_of_push_seq) >> 16) & 65535, r32\n+\tshlli\tr30, 2, r31\n+\tshori\tLOCAL(ia_end_of_push_seq) & 65535, r32\n+\tsub.l\tr32, r31, r33\n+\tptabs/l\tr33, tr2\n+\tblink\ttr2, r63\n+LOCAL(ia_stack_of_push_seq):\t /* Beginning of push sequence.  */\n+\tstx.q\tr17, r63, r3\n+\taddi.l\tr17, 8, r17\n+\tstx.q\tr17, r63, r4\n+\taddi.l\tr17, 8, r17\n+\tstx.q\tr17, r63, r5\n+\taddi.l\tr17, 8, r17\n+\tstx.q\tr17, r63, r6\n+\taddi.l\tr17, 8, r17\n+\tstx.q\tr17, r63, r7\n+\taddi.l\tr17, 8, r17\n+\tstx.q\tr17, r63, r8\n+\taddi.l\tr17, 8, r17\n+LOCAL(ia_r9_push):\t/* Push r9 onto the stack.  */\n+\tstx.q\tr17, r63, r9\n+LOCAL(ia_return):\t/* Return.  */\n+\tblink\ttr0, r63\n+LOCAL(ia_end_of_push_seq): /* Label used to compute the first push instruction.  */\n+#endif /* L_shcompact_incoming_args */\n+#endif\n+#if __SH5__\n+#ifdef L_nested_trampoline\n+#if __SH5__ == 32\n+\t.section\t.text..SHmedia32,\"ax\"\n+#else\n+\t.text\n+#endif\n+\t.align\t3 /* It is copied in units of 8 bytes in SHmedia mode.  */\n+\t.global\tGLOBAL(GCC_nested_trampoline)\n+GLOBAL(GCC_nested_trampoline):\n+\t.mode\tSHmedia\n+\tptrel/u\tr63, tr0\n+\tgettr\ttr0, r0\n+#if __SH5__ == 64\n+\tld.q\tr0, 24, r1\n+#else\n+\tld.l\tr0, 24, r1\n+#endif\n+\tptabs/l\tr1, tr1\n+#if __SH5__ == 64\n+\tld.q\tr0, 32, r1\n+#else\n+\tld.l\tr0, 28, r1\n+#endif\n+\tblink\ttr1, r63\n+#endif /* L_nested_trampoline */\n+#endif /* __SH5__ */\n+#if __SH5__ == 32\n+#ifdef L_push_pop_shmedia_regs\n+\t.section\t.text..SHmedia32,\"ax\"\n+\t.mode\tSHmedia\n+\t.align\t2\n+#ifndef __SH4_NOFPU__\t\n+\t.global\tGLOBAL(GCC_push_shmedia_regs)\n+GLOBAL(GCC_push_shmedia_regs):\n+\taddi.l\tr15, -14*8, r15\n+\tfst.d\tr15, 13*8, dr62\n+\tfst.d\tr15, 12*8, dr60\n+\tfst.d\tr15, 11*8, dr58\n+\tfst.d\tr15, 10*8, dr56\n+\tfst.d\tr15,  9*8, dr54\n+\tfst.d\tr15,  8*8, dr52\n+\tfst.d\tr15,  7*8, dr50\n+\tfst.d\tr15,  6*8, dr48\n+\tfst.d\tr15,  5*8, dr46\n+\tfst.d\tr15,  4*8, dr44\n+\tfst.d\tr15,  3*8, dr42\n+\tfst.d\tr15,  2*8, dr40\n+\tfst.d\tr15,  1*8, dr38\n+\tfst.d\tr15,  0*8, dr36\n+#endif\n+\t.global\tGLOBAL(GCC_push_shmedia_regs_nofpu)\n+GLOBAL(GCC_push_shmedia_regs_nofpu):\n+\tptabs/l\tr18, tr0\n+\taddi.l\tr15, -27*8, r15\n+\tgettr\ttr7, r62\n+\tgettr\ttr6, r61\n+\tgettr\ttr5, r60\n+\tst.q\tr15, 26*8, r62\n+\tst.q\tr15, 25*8, r61\n+\tst.q\tr15, 24*8, r60\n+\tst.q\tr15, 23*8, r59\n+\tst.q\tr15, 22*8, r58\n+\tst.q\tr15, 21*8, r57\n+\tst.q\tr15, 20*8, r56\n+\tst.q\tr15, 19*8, r55\n+\tst.q\tr15, 18*8, r54\n+\tst.q\tr15, 17*8, r53\n+\tst.q\tr15, 16*8, r52\n+\tst.q\tr15, 15*8, r51\n+\tst.q\tr15, 14*8, r50\n+\tst.q\tr15, 13*8, r49\n+\tst.q\tr15, 12*8, r48\n+\tst.q\tr15, 11*8, r47\n+\tst.q\tr15, 10*8, r46\n+\tst.q\tr15,  9*8, r45\n+\tst.q\tr15,  8*8, r44\n+\tst.q\tr15,  7*8, r35\n+\tst.q\tr15,  6*8, r34\n+\tst.q\tr15,  5*8, r33\n+\tst.q\tr15,  4*8, r32\n+\tst.q\tr15,  3*8, r31\n+\tst.q\tr15,  2*8, r30\n+\tst.q\tr15,  1*8, r29\n+\tst.q\tr15,  0*8, r28\n+\tblink\ttr0, r63\n+\n+#ifndef __SH4_NOFPU__\n+\t.global\tGLOBAL(GCC_pop_shmedia_regs)\n+GLOBAL(GCC_pop_shmedia_regs):\n+\tpt\t.L0, tr1\n+\tmovi\t41*8, r0\n+\tfld.d\tr15, 40*8, dr62\n+\tfld.d\tr15, 39*8, dr60\n+\tfld.d\tr15, 38*8, dr58\n+\tfld.d\tr15, 37*8, dr56\n+\tfld.d\tr15, 36*8, dr54\n+\tfld.d\tr15, 35*8, dr52\n+\tfld.d\tr15, 34*8, dr50\n+\tfld.d\tr15, 33*8, dr48\n+\tfld.d\tr15, 32*8, dr46\n+\tfld.d\tr15, 31*8, dr44\n+\tfld.d\tr15, 30*8, dr42\n+\tfld.d\tr15, 29*8, dr40\n+\tfld.d\tr15, 28*8, dr38\n+\tfld.d\tr15, 27*8, dr36\n+\tblink\ttr1, r63\n+#endif\n+\t.global\tGLOBAL(GCC_pop_shmedia_regs_nofpu)\n+GLOBAL(GCC_pop_shmedia_regs_nofpu):\n+\tmovi\t27*8, r0\n+.L0:\n+\tptabs\tr18, tr0\n+\tld.q\tr15, 26*8, r62\n+\tld.q\tr15, 25*8, r61\n+\tld.q\tr15, 24*8, r60\n+\tptabs\tr62, tr7\n+\tptabs\tr61, tr6\n+\tptabs\tr60, tr5\n+\tld.q\tr15, 23*8, r59\n+\tld.q\tr15, 22*8, r58\n+\tld.q\tr15, 21*8, r57\n+\tld.q\tr15, 20*8, r56\n+\tld.q\tr15, 19*8, r55\n+\tld.q\tr15, 18*8, r54\n+\tld.q\tr15, 17*8, r53\n+\tld.q\tr15, 16*8, r52\n+\tld.q\tr15, 15*8, r51\n+\tld.q\tr15, 14*8, r50\n+\tld.q\tr15, 13*8, r49\n+\tld.q\tr15, 12*8, r48\n+\tld.q\tr15, 11*8, r47\n+\tld.q\tr15, 10*8, r46\n+\tld.q\tr15,  9*8, r45\n+\tld.q\tr15,  8*8, r44\n+\tld.q\tr15,  7*8, r35\n+\tld.q\tr15,  6*8, r34\n+\tld.q\tr15,  5*8, r33\n+\tld.q\tr15,  4*8, r32\n+\tld.q\tr15,  3*8, r31\n+\tld.q\tr15,  2*8, r30\n+\tld.q\tr15,  1*8, r29\n+\tld.q\tr15,  0*8, r28\n+\tadd.l\tr15, r0, r15\n+\tblink\ttr0, r63\n+#endif /* __SH5__ == 32 */\n+#endif /* L_push_pop_shmedia_regs */"}, {"sha": "59ed9e70dbb7b85e335262fa5750bf7d5da8f712", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa5322fa5824e95a7aa82413782b510c8d91e7d8/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa5322fa5824e95a7aa82413782b510c8d91e7d8/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=fa5322fa5824e95a7aa82413782b510c8d91e7d8", "patch": "@@ -73,6 +73,7 @@ extern int gen_shl_and PARAMS ((rtx, rtx, rtx, rtx));\n extern int shl_sext_kind PARAMS ((rtx, rtx, int *));\n extern int shl_sext_length PARAMS ((rtx));\n extern int gen_shl_sext PARAMS ((rtx, rtx, rtx, rtx));\n+extern rtx gen_datalabel_ref PARAMS ((rtx));\n extern int regs_used PARAMS ((rtx, int));\n extern void fixup_addr_diff_vecs PARAMS ((rtx));\n extern int get_dest_uid PARAMS ((rtx, int));\n@@ -114,6 +115,7 @@ extern const char *output_jump_label_table PARAMS ((void));\n extern int sh_handle_pragma PARAMS ((int (*)(void), void (*)(int), const char *));\n extern struct rtx_def *get_fpscr_rtx PARAMS ((void));\n extern void output_file_start PARAMS ((FILE *));\n+extern int sh_media_register_for_return PARAMS ((void));\n extern void sh_expand_prologue PARAMS ((void));\n extern void sh_expand_epilogue PARAMS ((void));\n extern int sh_need_epilogue PARAMS ((void));"}, {"sha": "c408caaabe15a7f7a1480a5dc5b3cabec28825ba", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 1095, "deletions": 96, "changes": 1191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa5322fa5824e95a7aa82413782b510c8d91e7d8/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa5322fa5824e95a7aa82413782b510c8d91e7d8/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=fa5322fa5824e95a7aa82413782b510c8d91e7d8", "patch": "@@ -47,6 +47,13 @@ int code_for_indirect_jump_scratch = CODE_FOR_indirect_jump_scratch;\n #define MSW (TARGET_LITTLE_ENDIAN ? 1 : 0)\n #define LSW (TARGET_LITTLE_ENDIAN ? 0 : 1)\n \n+/* These are some macros to abstract register modes.  */\n+#define CONST_OK_FOR_ADD(size) \\\n+  (TARGET_SHMEDIA ? CONST_OK_FOR_P (size) : CONST_OK_FOR_I (size))\n+#define GEN_MOV (*(TARGET_SHMEDIA64 ? gen_movdi : gen_movsi))\n+#define GEN_ADD3 (*(TARGET_SHMEDIA64 ? gen_adddi3 : gen_addsi3))\n+#define GEN_SUB3 (*(TARGET_SHMEDIA64 ? gen_subdi3 : gen_subsi3))\n+\n /* Set to 1 by expand_prologue() when the function is an interrupt handler.  */\n int current_function_interrupt;\n \n@@ -100,31 +107,56 @@ int regno_reg_class[FIRST_PSEUDO_REGISTER] =\n   GENERAL_REGS, GENERAL_REGS, GENERAL_REGS, GENERAL_REGS,\n   GENERAL_REGS, GENERAL_REGS, GENERAL_REGS, GENERAL_REGS,\n   GENERAL_REGS, GENERAL_REGS, GENERAL_REGS, GENERAL_REGS,\n-  GENERAL_REGS, PR_REGS, T_REGS, NO_REGS,\n-  MAC_REGS, MAC_REGS, FPUL_REGS, GENERAL_REGS,\n+  GENERAL_REGS, GENERAL_REGS, GENERAL_REGS, GENERAL_REGS,\n+  GENERAL_REGS, GENERAL_REGS, GENERAL_REGS, GENERAL_REGS,\n+  GENERAL_REGS, GENERAL_REGS, GENERAL_REGS, GENERAL_REGS,\n+  GENERAL_REGS, GENERAL_REGS, GENERAL_REGS, GENERAL_REGS,\n+  GENERAL_REGS, GENERAL_REGS, GENERAL_REGS, GENERAL_REGS,\n+  GENERAL_REGS, GENERAL_REGS, GENERAL_REGS, GENERAL_REGS,\n+  GENERAL_REGS, GENERAL_REGS, GENERAL_REGS, GENERAL_REGS,\n+  GENERAL_REGS, GENERAL_REGS, GENERAL_REGS, GENERAL_REGS,\n+  GENERAL_REGS, GENERAL_REGS, GENERAL_REGS, GENERAL_REGS,\n+  GENERAL_REGS, GENERAL_REGS, GENERAL_REGS, GENERAL_REGS,\n+  GENERAL_REGS, GENERAL_REGS, GENERAL_REGS, GENERAL_REGS,\n+  GENERAL_REGS, GENERAL_REGS, GENERAL_REGS, GENERAL_REGS,\n   FP0_REGS,FP_REGS, FP_REGS, FP_REGS,\n   FP_REGS, FP_REGS, FP_REGS, FP_REGS,\n   FP_REGS, FP_REGS, FP_REGS, FP_REGS,\n   FP_REGS, FP_REGS, FP_REGS, FP_REGS,\n+  FP_REGS, FP_REGS, FP_REGS, FP_REGS,\n+  FP_REGS, FP_REGS, FP_REGS, FP_REGS,\n+  FP_REGS, FP_REGS, FP_REGS, FP_REGS,\n+  FP_REGS, FP_REGS, FP_REGS, FP_REGS,\n+  FP_REGS, FP_REGS, FP_REGS, FP_REGS,\n+  FP_REGS, FP_REGS, FP_REGS, FP_REGS,\n+  FP_REGS, FP_REGS, FP_REGS, FP_REGS,\n+  FP_REGS, FP_REGS, FP_REGS, FP_REGS,\n+  FP_REGS, FP_REGS, FP_REGS, FP_REGS,\n+  FP_REGS, FP_REGS, FP_REGS, FP_REGS,\n+  FP_REGS, FP_REGS, FP_REGS, FP_REGS,\n+  FP_REGS, FP_REGS, FP_REGS, FP_REGS,\n+  TARGET_REGS, TARGET_REGS, TARGET_REGS, TARGET_REGS,\n+  TARGET_REGS, TARGET_REGS, TARGET_REGS, TARGET_REGS,\n   DF_REGS, DF_REGS, DF_REGS, DF_REGS,\n   DF_REGS, DF_REGS, DF_REGS, DF_REGS,\n-  FPSCR_REGS,\n+  NO_REGS, GENERAL_REGS, PR_REGS, T_REGS,\n+  MAC_REGS, MAC_REGS, FPUL_REGS, FPSCR_REGS,\n+  GENERAL_REGS,\n };\n \n-char fp_reg_names[][5] =\n-{\n-  \"fr0\", \"fr1\", \"fr2\", \"fr3\", \"fr4\", \"fr5\", \"fr6\", \"fr7\",\n-  \"fr8\", \"fr9\", \"fr10\", \"fr11\", \"fr12\", \"fr13\", \"fr14\", \"fr15\",\n-  \"fpul\",\n-  \"xd0\",\"xd2\",\"xd4\", \"xd6\", \"xd8\", \"xd10\", \"xd12\", \"xd14\",\n-};\n+char sh_register_names[FIRST_PSEUDO_REGISTER] \\\n+  [MAX_REGISTER_NAME_LENGTH + 1] = SH_REGISTER_NAMES_INITIALIZER;\n+\n+char sh_additional_register_names[ADDREGNAMES_SIZE] \\\n+  [MAX_ADDITIONAL_REGISTER_NAME_LENGTH + 1]\n+  = SH_ADDITIONAL_REGISTER_NAMES_INITIALIZER;\n \n /* Provide reg_class from a letter such as appears in the machine\n    description.  */\n \n const enum reg_class reg_class_from_letter[] =\n {\n-  /* a */ ALL_REGS, /* b */ NO_REGS, /* c */ FPSCR_REGS, /* d */ DF_REGS,\n+  /* a */ ALL_REGS, /* b */ TARGET_REGS, /* c */ FPSCR_REGS, /* d */ DF_REGS,\n   /* e */ NO_REGS, /* f */ FP_REGS, /* g */ NO_REGS, /* h */ NO_REGS,\n   /* i */ NO_REGS, /* j */ NO_REGS, /* k */ SIBCALL_REGS, /* l */ PR_REGS,\n   /* m */ NO_REGS, /* n */ NO_REGS, /* o */ NO_REGS, /* p */ NO_REGS,\n@@ -150,8 +182,8 @@ static rtx gen_block_redirect PARAMS ((rtx, int, int));\n static void output_stack_adjust PARAMS ((int, rtx, int));\n static void push PARAMS ((int));\n static void pop PARAMS ((int));\n-static void push_regs PARAMS ((int, int));\n-static int calc_live_regs PARAMS ((int *, int *));\n+static void push_regs PARAMS ((HOST_WIDE_INT *));\n+static void calc_live_regs PARAMS ((int *, HOST_WIDE_INT *));\n static void mark_use PARAMS ((rtx, rtx *));\n static HOST_WIDE_INT rounded_frame_size PARAMS ((int));\n static rtx mark_constant_pool_use PARAMS ((rtx));\n@@ -165,6 +197,9 @@ static void sh_insert_attributes PARAMS ((tree, tree *));\n static void sh_asm_named_section PARAMS ((const char *, unsigned int));\n #endif\n static int sh_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n+static bool sh_cannot_modify_jumps_p PARAMS ((void));\n+\n+static bool sh_ms_bitfield_layout_p PARAMS ((tree));\n \f\n /* Initialize the GCC target structure.  */\n #undef TARGET_ATTRIBUTE_TABLE\n@@ -176,6 +211,12 @@ static int sh_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n #undef TARGET_ASM_UNALIGNED_SI_OP\n #define TARGET_ASM_UNALIGNED_SI_OP \"\\t.ualong\\t\"\n \n+/* These are NULLed out on non-SH5 in OVERRIDE_OPTIONS.  */\n+#undef TARGET_ASM_UNALIGNED_DI_OP\n+#define TARGET_ASM_UNALIGNED_DI_OP \"\\t.uaquad\\t\"\n+#undef TARGET_ASM_ALIGNED_DI_OP\n+#define TARGET_ASM_ALIGNED_DI_OP \"\\t.quad\\t\"\n+\n #undef TARGET_ASM_FUNCTION_EPILOGUE\n #define TARGET_ASM_FUNCTION_EPILOGUE sh_output_function_epilogue\n \n@@ -185,6 +226,12 @@ static int sh_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n #undef TARGET_SCHED_ADJUST_COST\n #define TARGET_SCHED_ADJUST_COST sh_adjust_cost\n \n+#undef TARGET_CANNOT_MODIFY_JUMPS_P\n+#define TARGET_CANNOT_MODIFY_JUMPS_P sh_cannot_modify_jumps_p\n+\n+#undef TARGET_MS_BITFIELD_LAYOUT_P\n+#define TARGET_MS_BITFIELD_LAYOUT_P sh_ms_bitfield_layout_p\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Print the operand address in x to the stream.  */\n@@ -257,6 +304,9 @@ print_operand_address (stream, x)\n    'R'  print the LSW of a dp value - changes if in little endian\n    'S'  print the MSW of a dp value - changes if in little endian\n    'T'  print the next word of a dp value - same as 'R' in big endian mode.\n+   'M'  print an `x' if `m' will print `base,index'.\n+   'm'  print a pair `base,offset' or `base,index', for LD and ST.\n+   'u'  prints the lowest 16 bits of CONST_INT, as an unsigned value.\n    'o'  output an operator.  */\n \n void\n@@ -338,21 +388,120 @@ print_operand (stream, x, code)\n \t  break;\n \t}\n       break;\n+    case 'M':\n+      if (GET_CODE (x) == MEM\n+\t  && GET_CODE (XEXP (x, 0)) == PLUS\n+\t  && (GET_CODE (XEXP (XEXP (x, 0), 1)) == REG\n+\t      || GET_CODE (XEXP (XEXP (x, 0), 1)) == SUBREG))\n+\tfputc ('x', stream);\n+      break;\n+\n+    case 'm':\n+      if (GET_CODE (x) != MEM)\n+\tabort ();\n+      x = XEXP (x, 0);\n+      switch (GET_CODE (x))\n+\t{\n+\tcase REG:\n+\tcase SUBREG:\n+\t  print_operand (stream, x, 0);\n+\t  fputs (\", 0\", stream);\n+\t  break;\n+\n+\tcase PLUS:\n+\t  print_operand (stream, XEXP (x, 0), 0);\n+\t  fputs (\", \", stream);\n+\t  print_operand (stream, XEXP (x, 1), 0);\n+\t  break;\n+\n+\tdefault:\n+\t  abort ();\n+\t}\n+      break;\n+\n+    case 'u':\n+      if (GET_CODE (x) == CONST_INT)\n+        {\n+\t  fprintf ((stream), \"%u\", (unsigned) INTVAL (x) & (0x10000 - 1));\n+\t  break;\n+\t}\n+      /* Fall through.  */\n+\n     default:\n       switch (GET_CODE (x))\n \t{\n+\t  /* FIXME: We need this on SHmedia32 because reload generates\n+\t     some sign-extended HI or QI loads into DImode registers\n+\t     but, because Pmode is SImode, the address ends up with a\n+\t     subreg:SI of the DImode register.  Maybe reload should be\n+\t     fixed so as to apply alter_subreg to such loads?  */\n+\tcase SUBREG:\n+\t  if (SUBREG_BYTE (x) != 0\n+\t      || GET_CODE (SUBREG_REG (x)) != REG)\n+\t    abort ();\n+\n+\t  x = SUBREG_REG (x);\n+\t  /* Fall through.  */\n+\n \tcase REG:\n \t  if (FP_REGISTER_P (REGNO (x))\n-\t      && GET_MODE_SIZE (GET_MODE (x)) > 4)\n-\t    fprintf ((stream), \"d%s\", reg_names[REGNO (x)]+1);\n+\t      && GET_MODE (x) == V16SFmode)\n+\t    fprintf ((stream), \"mtrx%s\", reg_names[REGNO (x)] + 2);\n+\t  else if (FP_REGISTER_P (REGNO (x))\n+\t\t   && GET_MODE (x) == V4SFmode)\n+\t    fprintf ((stream), \"fv%s\", reg_names[REGNO (x)] + 2);\n+\t  else if (GET_CODE (x) == REG\n+\t\t   && GET_MODE (x) == V2SFmode)\n+\t    fprintf ((stream), \"fp%s\", reg_names[REGNO (x)] + 2);\n+\t  else if (FP_REGISTER_P (REGNO (x))\n+\t\t   && GET_MODE_SIZE (GET_MODE (x)) > 4)\n+\t    fprintf ((stream), \"d%s\", reg_names[REGNO (x)] + 1);\n \t  else\n \t    fputs (reg_names[REGNO (x)], (stream));\n \t  break;\n+\n \tcase MEM:\n \t  output_address (XEXP (x, 0));\n \t  break;\n+\t  \n+\tcase CONST:\n+\t  if (TARGET_SHMEDIA\n+\t      && GET_CODE (XEXP (x, 0)) == SIGN_EXTEND\n+\t      && GET_MODE (XEXP (x, 0)) == DImode\n+\t      && GET_CODE (XEXP (XEXP (x, 0), 0)) == TRUNCATE\n+\t      && GET_MODE (XEXP (XEXP (x, 0), 0)) == HImode)\n+\t    {\n+\t      rtx val = XEXP (XEXP (XEXP (x, 0), 0), 0);\n+\n+\t      fputc ('(', stream);\n+\t      if (GET_CODE (val) == ASHIFTRT)\n+\t\t{\n+\t\t  fputc ('(', stream);\n+\t\t  if (GET_CODE (XEXP (val, 0)) == CONST)\n+\t\t    fputc ('(', stream);\n+\t\t  output_addr_const (stream, XEXP (val, 0));\n+\t\t  if (GET_CODE (XEXP (val, 0)) == CONST)\n+\t\t    fputc (')', stream);\n+\t\t  fputs (\" >> \", stream);\n+\t\t  output_addr_const (stream, XEXP (val, 1));\n+\t\t  fputc (')', stream);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (GET_CODE (val) == CONST)\n+\t\t    fputc ('(', stream);\n+\t\t  output_addr_const (stream, val);\n+\t\t  if (GET_CODE (val) == CONST)\n+\t\t    fputc (')', stream);\n+\t\t}\n+\t      fputs (\" & 65535)\", stream);\n+\t      break;\n+\t    }\n+\n+\t  /* Fall through.  */\n \tdefault:\n-\t  fputc ('#', stream);\n+\t  if (TARGET_SH1)\n+\t    fputc ('#', stream);\n \t  output_addr_const (stream, x);\n \t  break;\n \t}\n@@ -498,17 +647,20 @@ prepare_move_operands (operands, mode)\n      rtx operands[];\n      enum machine_mode mode;\n {\n-  if (mode == SImode && flag_pic)\n+  if ((mode == SImode || mode == DImode) && flag_pic)\n     {\n       rtx temp;\n       if (SYMBOLIC_CONST_P (operands[1]))\n \t{\n \t  if (GET_CODE (operands[0]) == MEM)\n \t    operands[1] = force_reg (Pmode, operands[1]);\n+\t  else if (GET_CODE (operands[1]) == LABEL_REF\n+\t\t   && target_reg_operand (operands[0], mode))\n+\t    /* It's ok.  */;\n \t  else\n \t    {\n \t      temp = no_new_pseudos ? operands[0] : gen_reg_rtx (Pmode);\n-\t      operands[1] = legitimize_pic_address (operands[1], SImode, temp);\n+\t      operands[1] = legitimize_pic_address (operands[1], mode, temp);\n \t    }\n \t}\n       else if (GET_CODE (operands[1]) == CONST\n@@ -517,8 +669,8 @@ prepare_move_operands (operands, mode)\n \t{\n \t  temp = no_new_pseudos ? operands[0] : gen_reg_rtx (Pmode);\n \t  temp = legitimize_pic_address (XEXP (XEXP (operands[1], 0), 0),\n-\t\t\t\t\t SImode, temp);\n-\t  operands[1] = expand_binop (SImode, add_optab, temp,\n+\t\t\t\t\t mode, temp);\n+\t  operands[1] = expand_binop (mode, add_optab, temp,\n \t\t\t\t      XEXP (XEXP (operands[1], 0), 1),\n \t\t\t\t      no_new_pseudos ? temp\n \t\t\t\t      : gen_reg_rtx (Pmode),\n@@ -802,9 +954,19 @@ output_far_jump (insn, op)\n \tprint_slot (final_sequence);\n \n       this.reg = gen_rtx_REG (SImode, 13);\n-      output_asm_insn (\"mov.l\tr13,@-r15\", 0);\n+      /* We must keep the stack aligned to 8-byte boundaries on SH5.\n+\t Fortunately, MACL is fixed and call-clobbered, and we never\n+\t need its value across jumps, so save r13 in it instead of in\n+\t the stack.  */\n+      if (TARGET_SH5)\n+\toutput_asm_insn (\"lds\tr13, macl\", 0);\n+      else\n+\toutput_asm_insn (\"mov.l\tr13,@-r15\", 0);\n       output_asm_insn (jump, &this.lab);\n-      output_asm_insn (\"mov.l\t@r15+,r13\", 0);\n+      if (TARGET_SH5)\n+\toutput_asm_insn (\"sts\tmacl, r13\", 0);\n+      else\n+\toutput_asm_insn (\"mov.l\t@r15+,r13\", 0);\n     }\n   if (far && flag_pic && TARGET_SH2)\n     {\n@@ -954,6 +1116,12 @@ output_file_start (file)\n \n   if (TARGET_LITTLE_ENDIAN)\n     fprintf (file, \"\\t.little\\n\");\n+\n+  if (TARGET_SHCOMPACT)\n+    fprintf (file, \"\\t.mode\\tSHcompact\\n\");\n+  else if (TARGET_SHMEDIA)\n+    fprintf (file, \"\\t.mode\\tSHmedia\\n\\t.abi\\t%i\\n\",\n+\t     TARGET_SHMEDIA64 ? 64 : 32);\n }\n \f\n /* Actual number of instructions used to make a shift by N.  */\n@@ -1031,6 +1199,9 @@ shiftcosts (x)\n {\n   int value;\n \n+  if (TARGET_SHMEDIA)\n+    return 1;\n+\n   if (GET_MODE_SIZE (GET_MODE (x)) > UNITS_PER_WORD)\n     {\n       if (GET_MODE (x) == DImode\n@@ -1073,6 +1244,17 @@ andcosts (x)\n     return 1;\n \n   i = INTVAL (XEXP (x, 1));\n+\n+  if (TARGET_SHMEDIA)\n+    {\n+      if ((GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t   && CONST_OK_FOR_J (INTVAL (XEXP (x, 1))))\n+\t  || EXTRA_CONSTRAINT_S (XEXP (x, 1)))\n+\treturn 1;\n+      else\n+\treturn 2;\n+    }\n+\n   /* These constants are single cycle extu.[bw] instructions.  */\n   if (i == 0xff || i == 0xffff)\n     return 1;\n@@ -1102,9 +1284,30 @@ addsubcosts (x)\n \n   /* Likewise for small constants.  */\n   if (GET_CODE (XEXP (x, 1)) == CONST_INT\n-      && CONST_OK_FOR_I (INTVAL (XEXP (x, 1))))\n+      && CONST_OK_FOR_ADD (INTVAL (XEXP (x, 1))))\n     return 1;\n \n+  if (TARGET_SHMEDIA)\n+    switch (GET_CODE (XEXP (x, 1)))\n+      {\n+      case CONST:\n+      case LABEL_REF:\n+      case SYMBOL_REF:\n+\treturn TARGET_SHMEDIA64 ? 5 : 3;\n+\n+      case CONST_INT:\n+\tif (CONST_OK_FOR_J (INTVAL (XEXP (x, 1))))\n+          return 2;\n+\telse if (CONST_OK_FOR_J (INTVAL (XEXP (x, 1)) >> 16))\n+\t  return 3;\n+\telse if (CONST_OK_FOR_J ((INTVAL (XEXP (x, 1)) >> 16) >> 16))\n+\t  return 4;\n+\n+\t/* Fall through.  */\n+      default:\n+\t  return 5;\n+      }\n+\n   /* Any other constant requires a 2 cycle pc-relative load plus an\n      addition.  */\n   return 3;\n@@ -1115,6 +1318,9 @@ int\n multcosts (x)\n      rtx x ATTRIBUTE_UNUSED;\n {\n+  if (TARGET_SHMEDIA)\n+    return 3;\n+\n   if (TARGET_SH2)\n     {\n       /* We have a mul insn, so we can never take more than the mul and the\n@@ -1916,6 +2122,27 @@ gen_shl_sext (dest, left_rtx, size_rtx, source)\n     }\n   return 0;\n }\n+\n+/* Prefix a symbol_ref name with \"datalabel\".  */\n+\n+rtx\n+gen_datalabel_ref (sym)\n+     rtx sym;\n+{\n+  if (GET_CODE (sym) == LABEL_REF)\n+    return gen_rtx_CONST (GET_MODE (sym),\n+\t\t\t  gen_rtx_UNSPEC (GET_MODE (sym),\n+\t\t\t\t\t  gen_rtvec (1, sym),\n+\t\t\t\t\t  UNSPEC_DATALABEL));\n+    \n+  if (GET_CODE (sym) != SYMBOL_REF)\n+    abort ();\n+\n+  XSTR (sym, 0) = concat (SH_DATALABEL_ENCODING, XSTR (sym, 0), NULL);\n+\n+  return sym;\n+}\n+\n \f\n /* The SH cannot load a large constant into a register, constants have to\n    come from a pc relative load.  The reference of a pc relative load\n@@ -2078,6 +2305,7 @@ dump_table (scan)\n   int i;\n   int need_align = 1;\n   rtx lab, ref;\n+  int have_di = 0;\n \n   /* Do two passes, first time dump out the HI sized constants.  */\n \n@@ -2102,10 +2330,87 @@ dump_table (scan)\n \t      scan = emit_insn_after (gen_consttable_window_end (lab), scan);\n \t    }\n \t}\n+      else if (p->mode == DImode || p->mode == DFmode)\n+\thave_di = 1;\n     }\n \n   need_align = 1;\n \n+  if (TARGET_SHCOMPACT && have_di)\n+    {\n+      rtx align_insn = NULL_RTX;\n+\n+      scan = emit_label_after (gen_label_rtx (), scan);\n+      scan = emit_insn_after (gen_align_log (GEN_INT (3)), scan);\n+      need_align = 0;\n+\n+      for (i = 0; i < pool_size; i++)\n+\t{\n+\t  pool_node *p = &pool_vector[i];\n+\n+\t  switch (p->mode)\n+\t    {\n+\t    case HImode:\n+\t      break;\n+\t    case SImode:\n+\t    case SFmode:\n+\t      if (align_insn)\n+\t\t{\n+\t\t  for (lab = p->label; lab; lab = LABEL_REFS (lab))\n+\t\t    emit_label_before (lab, align_insn);\n+\t\t  emit_insn_before (gen_consttable_4 (p->value, const0_rtx),\n+\t\t\t\t    align_insn);\n+\t\t  for (ref = p->wend; ref; ref = LABEL_NEXTREF (ref))\n+\t\t    {\n+\t\t      lab = XEXP (ref, 0);\n+\t\t      emit_insn_before (gen_consttable_window_end (lab),\n+\t\t\t\t       align_insn);\n+\t\t    }\n+\t\t  delete_insn (align_insn);\n+\t\t  align_insn = NULL_RTX;\n+\t\t  continue;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  for (lab = p->label; lab; lab = LABEL_REFS (lab))\n+\t\t    scan = emit_label_after (lab, scan);\n+\t\t  scan = emit_insn_after (gen_consttable_4 (p->value,\n+\t\t\t\t\t\t\t    const0_rtx), scan);\n+\t\t  need_align = ! need_align;\n+\t\t}\n+\t      break;\n+\t    case DFmode:\n+\t    case DImode:\n+\t      if (need_align)\n+\t\t{\n+\t\t  scan = emit_insn_after (gen_align_log (GEN_INT (3)), scan);\n+\t\t  align_insn = scan;\n+\t\t  need_align = 0;\n+\t\t}\n+\t      for (lab = p->label; lab; lab = LABEL_REFS (lab))\n+\t\tscan = emit_label_after (lab, scan);\n+\t      scan = emit_insn_after (gen_consttable_8 (p->value, const0_rtx),\n+\t\t\t\t      scan);\n+\t      break;\n+\t    default:\n+\t      abort ();\n+\t      break;\n+\t    }\n+\n+\t  if (p->mode != HImode)\n+\t    {\n+\t      for (ref = p->wend; ref; ref = LABEL_NEXTREF (ref))\n+\t\t{\n+\t\t  lab = XEXP (ref, 0);\n+\t\t  scan = emit_insn_after (gen_consttable_window_end (lab),\n+\t\t\t\t\t  scan);\n+\t\t}\n+\t    }\n+\t}\n+\n+      pool_size = 0;\n+    }\n+  \n   for (i = 0; i < pool_size; i++)\n     {\n       pool_node *p = &pool_vector[i];\n@@ -2240,6 +2545,7 @@ find_barrier (num_mova, mova, from)\n   int count_hi = 0;\n   int found_hi = 0;\n   int found_si = 0;\n+  int found_di = 0;\n   int hi_align = 2;\n   int si_align = 2;\n   int leading_mova = num_mova;\n@@ -2321,6 +2627,18 @@ find_barrier (num_mova, mova, from)\n \t    }\n \t  else\n \t    {\n+\t      /* We dump DF/DI constants before SF/SI ones, because\n+\t\t the limit is the same, but the alignment requirements\n+\t\t are higher.  We may waste up to 4 additional bytes\n+\t\t for alignment, and the DF/DI constant may have\n+\t\t another SF/SI constant placed before it. */\n+\t      if (TARGET_SHCOMPACT\n+\t\t  && ! found_di\n+\t\t  && (mode == DFmode || mode == DImode))\n+\t\t{\n+\t\t  found_di = 1;\n+\t\t  si_limit -= 8;\n+\t\t}\n \t      while (si_align > 2 && found_si + si_align - 2 > count_si)\n \t\tsi_align >>= 1;\n \t      if (found_si > count_si)\n@@ -2928,7 +3246,7 @@ barrier_align (barrier_or_label)\n       return ((TARGET_SMALLCODE\n \t       || (XVECLEN (pat, 1) * GET_MODE_SIZE (GET_MODE (pat))\n \t\t   <= (unsigned)1 << (CACHE_LOG - 2)))\n-\t      ? 1 : CACHE_LOG);\n+\t      ? 1 << TARGET_SHMEDIA : CACHE_LOG);\n     }\n \n   if (TARGET_SMALLCODE)\n@@ -3035,6 +3353,10 @@ sh_loop_align (label)\n       || GET_CODE (PATTERN (next)) == ADDR_DIFF_VEC\n       || recog_memoized (next) == CODE_FOR_consttable_2)\n     return 0;\n+\n+  if (TARGET_SH5)\n+    return 3;\n+\n   return 2;\n }\n \n@@ -3058,6 +3380,9 @@ machine_dependent_reorg (first)\n   if (! optimize)\n     split_all_insns_noflow ();\n \n+  if (TARGET_SHMEDIA)\n+    return;\n+\n   /* If relaxing, generate pseudo-ops to associate function calls with\n      the symbols they call.  It does no harm to not generate these\n      pseudo-ops.  However, when we can generate them, it enables to\n@@ -3340,6 +3665,7 @@ machine_dependent_reorg (first)\n \t     behind.  */\n \t  rtx barrier = find_barrier (num_mova, mova, insn);\n \t  rtx last_float_move, last_float = 0, *last_float_addr;\n+\t  int may_need_align = 1;\n \n \t  if (num_mova && ! mova_p (mova))\n \t    {\n@@ -3397,6 +3723,27 @@ machine_dependent_reorg (first)\n \t\t      if (last_float\n \t\t\t  && reg_set_between_p (r0_rtx, last_float_move, scan))\n \t\t\tlast_float = 0;\n+\t\t      if (TARGET_SHCOMPACT)\n+\t\t\t{\n+\t\t\t  /* The first SFmode constant after a DFmode\n+\t\t\t     constant may be pulled before a sequence\n+\t\t\t     of DFmode constants, so the second SFmode\n+\t\t\t     needs a label, just in case.  */\n+\t\t\t  if (GET_MODE_SIZE (mode) == 4)\n+\t\t\t    {\n+\t\t\t      if (last_float && may_need_align)\n+\t\t\t\tlast_float = 0;\n+\t\t\t      may_need_align = 0;\n+\t\t\t    }\n+\t\t\t  if (last_float\n+\t\t\t      && (GET_MODE_SIZE (GET_MODE (last_float))\n+\t\t\t\t  != GET_MODE_SIZE (mode)))\n+\t\t\t    {\n+\t\t\t      last_float = 0;\n+\t\t\t      if (GET_MODE_SIZE (mode) == 4)\n+\t\t\t\tmay_need_align = 1;\n+\t\t\t    }\n+\t\t\t}\n \t\t      lab = add_constant (src, mode, last_float);\n \t\t      if (lab)\n \t\t\temit_insn_before (gen_mova (lab), scan);\n@@ -3842,16 +4189,21 @@ output_stack_adjust (size, reg, temp)\n {\n   if (size)\n     {\n-      if (CONST_OK_FOR_I (size))\n-\temit_insn (gen_addsi3 (reg, reg, GEN_INT (size)));\n+      HOST_WIDE_INT align = STACK_BOUNDARY / BITS_PER_UNIT;\n+\n+      if (size % align)\n+\tabort ();\n+\n+      if (CONST_OK_FOR_ADD (size))\n+\temit_insn (GEN_ADD3 (reg, reg, GEN_INT (size)));\n       /* Try to do it with two partial adjustments; however, we must make\n \t sure that the stack is properly aligned at all times, in case\n \t an interrupt occurs between the two partial adjustments.  */\n-      else if (CONST_OK_FOR_I (size / 2 & -4)\n-\t       && CONST_OK_FOR_I (size - (size / 2 & -4)))\n+      else if (CONST_OK_FOR_ADD (size / 2 & -align)\n+\t       && CONST_OK_FOR_ADD (size - (size / 2 & -align)))\n \t{\n-\t  emit_insn (gen_addsi3 (reg, reg, GEN_INT (size / 2 & -4)));\n-\t  emit_insn (gen_addsi3 (reg, reg, GEN_INT (size - (size / 2 & -4))));\n+\t  emit_insn (GEN_ADD3 (reg, reg, GEN_INT (size / 2 & -align)));\n+\t  emit_insn (GEN_ADD3 (reg, reg, GEN_INT (size - (size / 2 & -align))));\n \t}\n       else\n \t{\n@@ -3862,20 +4214,20 @@ output_stack_adjust (size, reg, temp)\n \t     to handle this case, so just abort when we see it.  */\n \t  if (temp < 0)\n \t    abort ();\n-\t  const_reg = gen_rtx_REG (SImode, temp);\n+\t  const_reg = gen_rtx_REG (GET_MODE (reg), temp);\n \n \t  /* If SIZE is negative, subtract the positive value.\n \t     This sometimes allows a constant pool entry to be shared\n \t     between prologue and epilogue code.  */\n \t  if (size < 0)\n \t    {\n-\t      emit_insn (gen_movsi (const_reg, GEN_INT (-size)));\n-\t      emit_insn (gen_subsi3 (reg, reg, const_reg));\n+\t      emit_insn (GEN_MOV (const_reg, GEN_INT (-size)));\n+\t      emit_insn (GEN_SUB3 (reg, reg, const_reg));\n \t    }\n \t  else\n \t    {\n-\t      emit_insn (gen_movsi (const_reg, GEN_INT (size)));\n-\t      emit_insn (gen_addsi3 (reg, reg, const_reg));\n+\t      emit_insn (GEN_MOV (const_reg, GEN_INT (size)));\n+\t      emit_insn (GEN_ADD3 (reg, reg, const_reg));\n \t    }\n \t}\n     }\n@@ -3938,21 +4290,18 @@ pop (rn)\n /* Generate code to push the regs specified in the mask.  */\n \n static void\n-push_regs (mask, mask2)\n-     int mask, mask2;\n+push_regs (mask)\n+     HOST_WIDE_INT *mask;\n {\n   int i;\n \n   /* Push PR last; this gives better latencies after the prologue, and\n      candidates for the return delay slot when there are no general\n      registers pushed.  */\n-  for (i = 0; i < 32; i++)\n-    if (mask & (1 << i) && i != PR_REG)\n-      push (i);\n-  for (i = 32; i < FIRST_PSEUDO_REGISTER; i++)\n-    if (mask2 & (1 << (i - 32)))\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    if (i != PR_REG && mask[i / 32] & (1 << (i % 32)))\n       push (i);\n-  if (mask & (1 << PR_REG))\n+  if (mask[PR_REG / 32] & (1 << (PR_REG % 32)))\n     push (PR_REG);\n }\n \n@@ -3963,13 +4312,12 @@ push_regs (mask, mask2)\n    function, and if we call another function (we can tell by looking at PR),\n    make sure that all the regs it clobbers are safe too.  */\n \n-static int\n-calc_live_regs (count_ptr, live_regs_mask2)\n+static void\n+calc_live_regs (count_ptr, live_regs_mask)\n      int *count_ptr;\n-     int *live_regs_mask2;\n+     HOST_WIDE_INT *live_regs_mask;\n {\n   int reg;\n-  int live_regs_mask = 0;\n   int count;\n   int interrupt_handler;\n   rtx pr_initial;\n@@ -3983,7 +4331,8 @@ calc_live_regs (count_ptr, live_regs_mask2)\n   else\n     interrupt_handler = 0;\n \n-  *live_regs_mask2 = 0;\n+  for (count = 0; 32 * count < FIRST_PSEUDO_REGISTER; count++)\n+    live_regs_mask[count] = 0;\n   /* If we can save a lot of saves by switching to double mode, do that.  */\n   if (TARGET_SH4 && TARGET_FMOVD && TARGET_FPU_SINGLE)\n     for (count = 0, reg = FIRST_FP_REG; reg <= LAST_FP_REG; reg += 2)\n@@ -3998,6 +4347,13 @@ calc_live_regs (count_ptr, live_regs_mask2)\n   pr_live = (pr_initial\n \t     ? REGNO (pr_initial) != PR_REG\n \t     : regs_ever_live[PR_REG]);\n+  /* Force PR to be live if the prologue has to call the SHmedia\n+     argument decoder or register saver.  */\n+  if (TARGET_SHCOMPACT\n+      && ((current_function_args_info.call_cookie\n+\t   & ~ CALL_COOKIE_RET_TRAMP (1))\n+\t  || current_function_has_nonlocal_label))\n+    pr_live = 1;\n   for (count = 0, reg = FIRST_PSEUDO_REGISTER - 1; reg >= 0; reg--)\n     {\n       if (reg == PR_REG\n@@ -4014,36 +4370,30 @@ calc_live_regs (count_ptr, live_regs_mask2)\n \t  : (/* Only push those regs which are used and need to be saved.  */\n \t     regs_ever_live[reg] && ! call_used_regs[reg]))\n \t{\n-\t  if (reg >= 32)\n-\t    *live_regs_mask2 |= 1 << (reg - 32);\n-\t  else\n-\t    live_regs_mask |= 1 << reg;\n-\t  count++;\n-\t  if (TARGET_SH4 && TARGET_FMOVD && FP_OR_XD_REGISTER_P (reg))\n+\t  live_regs_mask[reg / 32] |= 1 << (reg % 32);\n+\t  count += GET_MODE_SIZE (REGISTER_NATURAL_MODE (reg));\n+\n+\t  if ((TARGET_SH4 || TARGET_SH5) && TARGET_FMOVD\n+\t      && GET_MODE_CLASS (REGISTER_NATURAL_MODE (reg)) == MODE_FLOAT)\n \t    {\n \t      if (FP_REGISTER_P (reg))\n \t\t{\n \t\t  if (! TARGET_FPU_SINGLE && ! regs_ever_live[reg ^ 1])\n \t\t    {\n-\t\t      if (reg >= 32)\n-\t\t\t*live_regs_mask2 |= 1 << ((reg ^ 1) - 32);\n-\t\t      else\n-\t\t\tlive_regs_mask |= 1 << (reg ^ 1);\n-\t\t      count++;\n+\t\t      live_regs_mask[(reg ^ 1) / 32] |= 1 << ((reg ^ 1) % 32);\n+\t\t      count += GET_MODE_SIZE (REGISTER_NATURAL_MODE (reg ^ 1));\n \t\t    }\n \t\t}\n-\t      else /* if (XD_REGISTER_P (reg)) */\n+\t      else if (XD_REGISTER_P (reg))\n \t\t{\n \t\t  /* Must switch to double mode to access these registers.  */\n \t\t  target_flags &= ~FPU_SINGLE_BIT;\n-\t\t  count++;\n \t\t}\n \t    }\n \t}\n     }\n \n-  *count_ptr = count * UNITS_PER_WORD;\n-  return live_regs_mask;\n+  *count_ptr = count;\n }\n \n /* Code to generate prologue and epilogue sequences */\n@@ -4061,12 +4411,33 @@ rounded_frame_size (pushed)\n   return ((size + pushed + align - 1) & -align) - pushed;\n }\n \n+/* Choose a call-clobbered target-branch register that remains\n+   unchanged along the whole function.  We set it up as the return\n+   value in the prologue.  */\n+int\n+sh_media_register_for_return ()\n+{\n+  int regno;\n+  int tr0_used;\n+\n+  if (! current_function_is_leaf)\n+    return -1;\n+\n+  tr0_used = flag_pic && regs_ever_live[PIC_OFFSET_TABLE_REGNUM];\n+\n+  for (regno = FIRST_TARGET_REG + tr0_used; regno <= LAST_TARGET_REG; regno++)\n+    if (call_used_regs[regno] && ! regs_ever_live[regno])\n+      return regno;\n+\n+  return -1;\n+}\n+\n void\n sh_expand_prologue ()\n {\n-  int live_regs_mask;\n+  HOST_WIDE_INT live_regs_mask[(FIRST_PSEUDO_REGISTER + 31) / 32];\n   int d, i;\n-  int live_regs_mask2;\n+  int d_rounding = 0;\n   int save_flags = target_flags;\n \n   current_function_interrupt\n@@ -4076,19 +4447,63 @@ sh_expand_prologue ()\n \n   /* We have pretend args if we had an object sent partially in registers\n      and partially on the stack, e.g. a large structure.  */\n-  output_stack_adjust (-current_function_pretend_args_size,\n-\t\t       stack_pointer_rtx, 1);\n+  output_stack_adjust (-current_function_pretend_args_size\n+\t\t       - current_function_args_info.stack_regs * 8,\n+\t\t       stack_pointer_rtx, TARGET_SH5 ? 0 : 1);\n \n   extra_push = 0;\n \n+  if (TARGET_SHCOMPACT\n+      && (current_function_args_info.call_cookie & ~ CALL_COOKIE_RET_TRAMP(1)))\n+    {\n+      int reg;\n+\n+      /* First, make all registers with incoming arguments that will\n+\t be pushed onto the stack live, so that register renaming\n+\t doesn't overwrite them.  */\n+      for (reg = 0; reg < NPARM_REGS (SImode); reg++)\n+\tif (CALL_COOKIE_STACKSEQ_GET (current_function_args_info.call_cookie)\n+\t    >= NPARM_REGS (SImode) - reg)\n+\t  for (; reg < NPARM_REGS (SImode); reg++)\n+\t    emit_insn (gen_shcompact_preserve_incoming_args\n+\t\t       (gen_rtx_REG (SImode, FIRST_PARM_REG + reg)));\n+\telse if (CALL_COOKIE_INT_REG_GET\n+\t\t (current_function_args_info.call_cookie, reg) == 1)\n+\t  emit_insn (gen_shcompact_preserve_incoming_args\n+\t\t     (gen_rtx_REG (SImode, FIRST_PARM_REG + reg)));\n+\n+      emit_move_insn (gen_rtx_REG (Pmode, MACL_REG),\n+\t\t      stack_pointer_rtx);\n+      emit_move_insn (gen_rtx_REG (SImode, R0_REG),\n+\t\t      GEN_INT (current_function_args_info.call_cookie));\n+      emit_move_insn (gen_rtx_REG (SImode, MACH_REG),\n+\t\t      gen_rtx_REG (SImode, R0_REG));\n+    }\n+  else if (TARGET_SHMEDIA)\n+    {\n+      int tr = sh_media_register_for_return ();\n+\n+      if (tr >= 0)\n+\t{\n+\t  rtx insn = emit_move_insn (gen_rtx_REG (DImode, tr),\n+\t\t\t\t     gen_rtx_REG (DImode, PR_MEDIA_REG));\n+\n+\t  /* If this function only exits with sibcalls, this copy\n+\t     will be flagged as dead.  */\n+\t  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD,\n+\t\t\t\t\t\tconst0_rtx,\n+\t\t\t\t\t\tREG_NOTES (insn));\n+\t}\n+    }\n+\n   /* This is set by SETUP_VARARGS to indicate that this is a varargs\n      routine.  Clear it here so that the next function isn't affected.  */\n   if (current_function_anonymous_args)\n     {\n       current_function_anonymous_args = 0;\n \n       /* This is not used by the SH3E calling convention  */\n-      if (! TARGET_SH3E && ! TARGET_HITACHI)\n+      if (TARGET_SH1 && ! TARGET_SH3E && ! TARGET_HITACHI)\n \t{\n \t  /* Push arg regs as if they'd been provided by caller in stack.  */\n \t  for (i = 0; i < NPARM_REGS(SImode); i++)\n@@ -4108,13 +4523,164 @@ sh_expand_prologue ()\n   if (sp_switch)\n     emit_insn (gen_sp_switch_1 ());\n \n-  live_regs_mask = calc_live_regs (&d, &live_regs_mask2);\n+  calc_live_regs (&d, live_regs_mask);\n   /* ??? Maybe we could save some switching if we can move a mode switch\n      that already happens to be at the function start into the prologue.  */\n   if (target_flags != save_flags)\n     emit_insn (gen_toggle_sz ());\n     \n-  push_regs (live_regs_mask, live_regs_mask2);\n+  if (TARGET_SH5)\n+    {\n+      int i;\n+      int offset;\n+      int align;\n+      rtx r0 = gen_rtx_REG (Pmode, R0_REG);\n+      int offset_in_r0 = -1;\n+      int sp_in_r0 = 0;\n+\n+      if (d % (STACK_BOUNDARY / BITS_PER_UNIT))\n+\td_rounding = ((STACK_BOUNDARY / BITS_PER_UNIT)\n+\t\t      - d % (STACK_BOUNDARY / BITS_PER_UNIT));\n+\n+      offset = d + d_rounding;\n+      output_stack_adjust (-offset, stack_pointer_rtx, 1);\n+\n+      /* We loop twice: first, we save 8-byte aligned registers in the\n+\t higher addresses, that are known to be aligned.  Then, we\n+\t proceed to saving 32-bit registers that don't need 8-byte\n+\t alignment.  */\n+      for (align = 1; align >= 0; align--)\n+\tfor (i = FIRST_PSEUDO_REGISTER - 1; i >= 0; i--)\n+\t  if (live_regs_mask[i/32] & (1 << (i % 32)))\n+\t    {\n+\t      enum machine_mode mode = REGISTER_NATURAL_MODE (i);\n+\t      int reg = i;\n+\t      rtx reg_rtx, mem_rtx, pre_dec = NULL_RTX;\n+\n+\t      if (mode == SFmode && (i % 2) == 1\n+\t\t  && ! TARGET_FPU_SINGLE && FP_REGISTER_P (i)\n+\t\t  && (live_regs_mask[(i ^ 1) / 32] & (1 << ((i ^ 1) % 32))))\n+\t\t{\n+\t\t  mode = DFmode;\n+\t\t  i--;\n+\t\t  reg--;\n+\t\t}\n+\t\t\n+\t      /* If we're doing the aligned pass and this is not aligned,\n+\t\t or we're doing the unaligned pass and this is aligned,\n+\t\t skip it.  */\n+\t      if ((GET_MODE_SIZE (mode) % (STACK_BOUNDARY / BITS_PER_UNIT)\n+\t\t   == 0) != align)\n+\t\tcontinue;\n+\n+\t      offset -= GET_MODE_SIZE (mode);\n+\n+\t      reg_rtx = gen_rtx_REG (mode, reg);\n+\n+\t      mem_rtx = gen_rtx_MEM (mode,\n+\t\t\t\t     gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t\t   stack_pointer_rtx,\n+\t\t\t\t\t\t   GEN_INT (offset)));\n+\n+\t      GO_IF_LEGITIMATE_ADDRESS (mode, XEXP (mem_rtx, 0), try_pre_dec);\n+\n+\t      mem_rtx = NULL_RTX;\n+\n+\t    try_pre_dec:\n+\t      do\n+\t\tif (HAVE_PRE_DECREMENT\n+\t\t    && (offset_in_r0 - offset == GET_MODE_SIZE (mode)\n+\t\t\t|| mem_rtx == NULL_RTX\n+\t\t\t|| i == PR_REG || SPECIAL_REGISTER_P (i)))\n+\t\t  {\n+\t\t    pre_dec = gen_rtx_MEM (mode,\n+\t\t\t\t\t   gen_rtx_PRE_DEC (Pmode, r0));\n+\n+\t\t    GO_IF_LEGITIMATE_ADDRESS (mode, XEXP (pre_dec, 0),\n+\t\t\t\t\t      pre_dec_ok);\n+\n+\t\t    pre_dec = NULL_RTX;\n+\n+\t\t    break;\n+\n+\t\t  pre_dec_ok:\n+\t\t    mem_rtx = NULL_RTX;\n+\t\t    offset += GET_MODE_SIZE (mode);\n+\t\t  }\n+\t      while (0);\n+\n+\t      if (mem_rtx != NULL_RTX)\n+\t\tgoto addr_ok;\n+\n+\t      if (offset_in_r0 == -1)\n+\t\t{\n+\t\t  emit_move_insn (r0, GEN_INT (offset));\n+\t\t  offset_in_r0 = offset;\n+\t\t}\n+\t      else if (offset != offset_in_r0)\n+\t\t{\n+\t\t  emit_move_insn (r0,\n+\t\t\t\t  gen_rtx_PLUS\n+\t\t\t\t  (Pmode, r0,\n+\t\t\t\t   GEN_INT (offset - offset_in_r0)));\n+\t\t  offset_in_r0 += offset - offset_in_r0;\n+\t\t}\n+\t\t\t\t\t\t  \n+\t      if (pre_dec != NULL_RTX)\n+\t\t{\n+\t\t  if (! sp_in_r0)\n+\t\t    {\n+\t\t      emit_move_insn (r0,\n+\t\t\t\t      gen_rtx_PLUS\n+\t\t\t\t      (Pmode, r0, stack_pointer_rtx));\n+\t\t      sp_in_r0 = 1;\n+\t\t    }\n+\n+\t\t  offset -= GET_MODE_SIZE (mode);\n+\t\t  offset_in_r0 -= GET_MODE_SIZE (mode);\n+\n+\t\t  mem_rtx = pre_dec;\n+\t\t}\n+\t      else if (sp_in_r0)\n+\t\tmem_rtx = gen_rtx_MEM (mode, r0);\n+\t      else\n+\t\tmem_rtx = gen_rtx_MEM (mode,\n+\t\t\t\t       gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t\t     stack_pointer_rtx,\n+\t\t\t\t\t\t     r0));\n+\n+\t      /* We must not use an r0-based address for target-branch\n+\t\t registers or for special registers without pre-dec\n+\t\t memory addresses, since we store their values in r0\n+\t\t first.  */\n+\t      if (TARGET_REGISTER_P (i)\n+\t\t  || ((i == PR_REG || SPECIAL_REGISTER_P (i))\n+\t\t      && mem_rtx != pre_dec))\n+\t\tabort ();\n+\n+\t    addr_ok:\n+\t      if (TARGET_REGISTER_P (i)\n+\t\t  || ((i == PR_REG || SPECIAL_REGISTER_P (i))\n+\t\t      && mem_rtx != pre_dec))\n+\t\t{\n+\t\t  rtx r0mode = gen_rtx_REG (GET_MODE (reg_rtx), R0_REG);\n+\n+\t\t  emit_move_insn (r0mode, reg_rtx);\n+\n+\t\t  offset_in_r0 = -1;\n+\t\t  sp_in_r0 = 0;\n+\n+\t\t  reg_rtx = r0mode;\n+\t\t}\n+\n+\t      emit_move_insn (mem_rtx, reg_rtx);\n+\t    }\n+\n+      if (offset != d_rounding)\n+\tabort ();\n+    }\n+  else\n+    push_regs (live_regs_mask);\n \n   if (flag_pic && regs_ever_live[PIC_OFFSET_TABLE_REGNUM])\n     {\n@@ -4135,6 +4701,19 @@ sh_expand_prologue ()\n       while (insn != last);\n     }\n \n+  if (SHMEDIA_REGS_STACK_ADJUST ())\n+    {\n+      emit_move_insn (gen_rtx_REG (Pmode, R0_REG),\n+\t\t      gen_rtx_SYMBOL_REF (Pmode,\n+\t\t\t\t\t  TARGET_FPU_ANY\n+\t\t\t\t\t  ? \"__GCC_push_shmedia_regs\"\n+\t\t\t\t\t  : \"__GCC_push_shmedia_regs_nofpu\"));\n+      /* This must NOT go through the PLT, otherwise mach and macl\n+\t may be clobbered.  */\n+      emit_insn (gen_shmedia_save_restore_regs_compact\n+\t\t (GEN_INT (-SHMEDIA_REGS_STACK_ADJUST ())));\n+    }\n+\n   if (target_flags != save_flags)\n     {\n       rtx insn = emit_insn (gen_toggle_sz ());\n@@ -4149,26 +4728,48 @@ sh_expand_prologue ()\n \n   target_flags = save_flags;\n \n-  output_stack_adjust (-rounded_frame_size (d),\n-\t\t       stack_pointer_rtx, 1);\n+  output_stack_adjust (-rounded_frame_size (d) + d_rounding,\n+\t\t       stack_pointer_rtx, TARGET_SH5 ? 0 : 1);\n \n   if (frame_pointer_needed)\n-    emit_insn (gen_movsi (frame_pointer_rtx, stack_pointer_rtx));\n+    emit_insn (GEN_MOV (frame_pointer_rtx, stack_pointer_rtx));\n+\n+  if (TARGET_SHCOMPACT && flag_pic && current_function_args_info.call_cookie)\n+    /* We're going to use the PIC register to load the address of the\n+       incoming-argument decoder and/or of the return trampoline from\n+       the GOT, so make sure the PIC register is preserved and\n+       initialized.  */\n+    regs_ever_live[PIC_OFFSET_TABLE_REGNUM] = 1;\n+\n+  if (TARGET_SHCOMPACT\n+      && (current_function_args_info.call_cookie & ~ CALL_COOKIE_RET_TRAMP(1)))\n+    {\n+      /* This must NOT go through the PLT, otherwise mach and macl\n+\t may be clobbered.  */\n+      emit_move_insn (gen_rtx_REG (Pmode, R0_REG),\n+\t\t      gen_rtx_SYMBOL_REF (Pmode,\n+\t\t\t\t\t  \"__GCC_shcompact_incoming_args\"));\n+      emit_insn (gen_shcompact_incoming_args ());\n+    }\n }\n \n void\n sh_expand_epilogue ()\n {\n-  int live_regs_mask;\n+  HOST_WIDE_INT live_regs_mask[(FIRST_PSEUDO_REGISTER + 31) / 32];\n   int d, i;\n+  int d_rounding = 0;\n \n-  int live_regs_mask2;\n   int save_flags = target_flags;\n   int frame_size;\n \n-  live_regs_mask = calc_live_regs (&d, &live_regs_mask2);\n+  calc_live_regs (&d, live_regs_mask);\n \n-  frame_size = rounded_frame_size (d);\n+  if (TARGET_SH5 && d % (STACK_BOUNDARY / BITS_PER_UNIT))\n+    d_rounding = ((STACK_BOUNDARY / BITS_PER_UNIT)\n+\t\t  - d % (STACK_BOUNDARY / BITS_PER_UNIT));\n+\n+  frame_size = rounded_frame_size (d) - d_rounding;\n \n   if (frame_pointer_needed)\n     {\n@@ -4179,7 +4780,7 @@ sh_expand_epilogue ()\n \t occur after the SP adjustment and clobber data in the local\n \t frame.  */\n       emit_insn (gen_blockage ());\n-      emit_insn (gen_movsi (stack_pointer_rtx, frame_pointer_rtx));\n+      emit_insn (GEN_MOV (stack_pointer_rtx, frame_pointer_rtx));\n     }\n   else if (frame_size)\n     {\n@@ -4191,33 +4792,190 @@ sh_expand_epilogue ()\n       output_stack_adjust (frame_size, stack_pointer_rtx, 7);\n     }\n \n+  if (SHMEDIA_REGS_STACK_ADJUST ())\n+    {\n+      emit_move_insn (gen_rtx_REG (Pmode, R0_REG),\n+\t\t      gen_rtx_SYMBOL_REF (Pmode,\n+\t\t\t\t\t  TARGET_FPU_ANY\n+\t\t\t\t\t  ? \"__GCC_pop_shmedia_regs\"\n+\t\t\t\t\t  : \"__GCC_pop_shmedia_regs_nofpu\"));\n+      /* This must NOT go through the PLT, otherwise mach and macl\n+\t may be clobbered.  */\n+      emit_insn (gen_shmedia_save_restore_regs_compact\n+\t\t (GEN_INT (SHMEDIA_REGS_STACK_ADJUST ())));\n+    }\n+\n   /* Pop all the registers.  */\n \n   if (target_flags != save_flags)\n     emit_insn (gen_toggle_sz ());\n-  if (live_regs_mask & (1 << PR_REG))\n+  if (TARGET_SH5)\n+    {\n+      int offset = d_rounding;\n+      int offset_in_r0 = -1;\n+      int sp_in_r0 = 0;\n+      int align;\n+      rtx r0 = gen_rtx_REG (Pmode, R0_REG);\n+      \n+      /* We loop twice: first, we save 8-byte aligned registers in the\n+\t higher addresses, that are known to be aligned.  Then, we\n+\t proceed to saving 32-bit registers that don't need 8-byte\n+\t alignment.  */\n+      for (align = 0; align <= 1; align++)\n+\tfor (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\t  if (live_regs_mask[i/32] & (1 << (i % 32)))\n+\t    {\n+\t      enum machine_mode mode = REGISTER_NATURAL_MODE (i);\n+\t      int reg = i;\n+\t      rtx reg_rtx, mem_rtx, post_inc = NULL_RTX, insn;\n+\n+\t      if (mode == SFmode && (i % 2) == 0\n+\t\t  && ! TARGET_FPU_SINGLE && FP_REGISTER_P (i)\n+\t\t  && (live_regs_mask[(i ^ 1) / 32] & (1 << ((i ^ 1) % 32))))\n+\t\t{\n+\t\t  mode = DFmode;\n+\t\t  i++;\n+\t\t}\n+\n+\t      /* If we're doing the aligned pass and this is not aligned,\n+\t\t or we're doing the unaligned pass and this is aligned,\n+\t\t skip it.  */\n+\t      if ((GET_MODE_SIZE (mode) % (STACK_BOUNDARY / BITS_PER_UNIT)\n+\t\t   == 0) != align)\n+\t\tcontinue;\n+\n+\t      reg_rtx = gen_rtx_REG (mode, reg);\n+\n+\t      mem_rtx = gen_rtx_MEM (mode,\n+\t\t\t\t     gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t\t   stack_pointer_rtx,\n+\t\t\t\t\t\t   GEN_INT (offset)));\n+\n+\t      GO_IF_LEGITIMATE_ADDRESS (mode, XEXP (mem_rtx, 0), try_post_inc);\n+\n+\t      mem_rtx = NULL_RTX;\n+\n+\t    try_post_inc:\n+\t      do\n+\t\tif (HAVE_POST_INCREMENT\n+\t\t    && (offset == offset_in_r0\n+\t\t\t|| (offset + GET_MODE_SIZE (mode) != d + d_rounding\n+\t\t\t    && mem_rtx == NULL_RTX)\n+\t\t\t|| i == PR_REG || SPECIAL_REGISTER_P (i)))\n+\t\t  {\n+\t\t    post_inc = gen_rtx_MEM (mode,\n+\t\t\t\t\t    gen_rtx_POST_INC (Pmode, r0));\n+\n+\t\t    GO_IF_LEGITIMATE_ADDRESS (mode, XEXP (post_inc, 0),\n+\t\t\t\t\t      post_inc_ok);\n+\n+\t\t    post_inc = NULL_RTX;\n+\n+\t\t    break;\n+\t\t    \n+\t\t  post_inc_ok:\n+\t\t    mem_rtx = NULL_RTX;\n+\t\t  }\n+\t      while (0);\n+\t      \n+\t      if (mem_rtx != NULL_RTX)\n+\t\tgoto addr_ok;\n+\n+\t      if (offset_in_r0 == -1)\n+\t\t{\n+\t\t  emit_move_insn (r0, GEN_INT (offset));\n+\t\t  offset_in_r0 = offset;\n+\t\t}\n+\t      else if (offset != offset_in_r0)\n+\t\t{\n+\t\t  emit_move_insn (r0,\n+\t\t\t\t  gen_rtx_PLUS\n+\t\t\t\t  (Pmode, r0,\n+\t\t\t\t   GEN_INT (offset - offset_in_r0)));\n+\t\t  offset_in_r0 += offset - offset_in_r0;\n+\t\t}\n+\t\t  \n+\t      if (post_inc != NULL_RTX)\n+\t\t{\n+\t\t  if (! sp_in_r0)\n+\t\t    {\n+\t\t      emit_move_insn (r0,\n+\t\t\t\t      gen_rtx_PLUS\n+\t\t\t\t      (Pmode, r0, stack_pointer_rtx));\n+\t\t      sp_in_r0 = 1;\n+\t\t    }\n+\t\t  \n+\t\t  mem_rtx = post_inc;\n+\n+\t\t  offset_in_r0 += GET_MODE_SIZE (mode);\n+\t\t}\n+\t      else if (sp_in_r0)\n+\t\tmem_rtx = gen_rtx_MEM (mode, r0);\n+\t      else\n+\t\tmem_rtx = gen_rtx_MEM (mode,\n+\t\t\t\t       gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t\t     stack_pointer_rtx,\n+\t\t\t\t\t\t     r0));\n+\n+\t      if ((i == PR_REG || SPECIAL_REGISTER_P (i))\n+\t\t  && mem_rtx != post_inc)\n+\t\tabort ();\n+\n+\t    addr_ok:\n+\t      if ((i == PR_REG || SPECIAL_REGISTER_P (i))\n+\t\t  && mem_rtx != post_inc)\n+\t\t{\n+\t\t  insn = emit_move_insn (r0, mem_rtx);\n+\t\t  mem_rtx = r0;\n+\t\t}\n+\t      else if (TARGET_REGISTER_P (i))\n+\t\t{\n+\t\t  rtx r1 = gen_rtx_REG (mode, R1_REG);\n+\n+\t\t  insn = emit_move_insn (r1, mem_rtx);\n+\t\t  mem_rtx = r1;\n+\t\t}\n+\n+\t      insn = emit_move_insn (reg_rtx, mem_rtx);\n+\n+\t      offset += GET_MODE_SIZE (mode);\n+\t    }\n+\n+      if (offset != d + d_rounding)\n+\tabort ();\n+\n+      goto finish;\n+    }\n+  else\n+    d = 0;\n+  if (live_regs_mask[PR_REG / 32] & (1 << (PR_REG % 32)))\n     pop (PR_REG);\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     {\n       int j = (FIRST_PSEUDO_REGISTER - 1) - i;\n-      if (j < 32 && (live_regs_mask & (1 << j)) && j != PR_REG)\n-\tpop (j);\n-      else if (j >= 32 && (live_regs_mask2 & (1 << (j - 32))))\n+\n+      if (j != PR_REG && live_regs_mask[j / 32] & (1 << (j % 32)))\n \tpop (j);\n     }\n+ finish:\n   if (target_flags != save_flags)\n     emit_insn (gen_toggle_sz ());\n   target_flags = save_flags;\n \n-  output_stack_adjust (extra_push + current_function_pretend_args_size,\n+  output_stack_adjust (extra_push + current_function_pretend_args_size\n+\t\t       + d + d_rounding\n+\t\t       + current_function_args_info.stack_regs * 8,\n \t\t       stack_pointer_rtx, 7);\n \n   /* Switch back to the normal stack if necessary.  */\n   if (sp_switch)\n     emit_insn (gen_sp_switch_2 ());\n \n   /* Tell flow the insn that pops PR isn't dead.  */\n-  if (live_regs_mask & (1 << PR_REG))\n+  /* PR_REG will never be live in SHmedia mode, and we don't need to\n+     USE PR_MEDIA_REG, since it will be explicitly copied to TR0_REG\n+     by the return pattern.  */\n+  if (live_regs_mask[PR_REG / 32] & (1 << (PR_REG % 32)))\n     emit_insn (gen_rtx_USE (VOIDmode, gen_rtx_REG (SImode, PR_REG)));\n }\n \n@@ -4268,12 +5026,57 @@ sh_builtin_saveregs ()\n   int bufsize, regno;\n   HOST_WIDE_INT alias_set;\n \n+  if (TARGET_SH5)\n+    {\n+      if (n_intregs)\n+\t{\n+\t  int pushregs = n_intregs;\n+\n+\t  while (pushregs < NPARM_REGS (SImode) - 1\n+\t\t && (CALL_COOKIE_INT_REG_GET\n+\t\t\t(current_function_args_info.call_cookie,\n+\t\t\t NPARM_REGS (SImode) - pushregs)\n+\t\t     == 1))\n+\t    {\n+\t      current_function_args_info.call_cookie\n+\t\t&= ~ CALL_COOKIE_INT_REG (NPARM_REGS (SImode)\n+\t\t\t\t\t  - pushregs, 1);\n+\t      pushregs++;\n+\t    }\n+\n+\t  if (pushregs == NPARM_REGS (SImode))\n+\t    current_function_args_info.call_cookie\n+\t      |= (CALL_COOKIE_INT_REG (0, 1)\n+\t\t  | CALL_COOKIE_STACKSEQ (pushregs - 1));\n+\t  else\n+\t    current_function_args_info.call_cookie\n+\t      |= CALL_COOKIE_STACKSEQ (pushregs);\n+\n+\t  current_function_pretend_args_size += 8 * n_intregs;\n+\t}\n+      if (TARGET_SHCOMPACT)\n+\treturn const0_rtx;\n+    }\n+  \n+  if (! TARGET_SH3E && ! TARGET_SH4 && ! TARGET_SH5)\n+    {\n+      error (\"__builtin_saveregs not supported by this subtarget\");\n+      return const0_rtx;\n+    }\n+\n+  if (TARGET_SHMEDIA)\n+    n_floatregs = 0;\n+\n   /* Allocate block of memory for the regs.  */\n   /* ??? If n_intregs + n_floatregs == 0, should we allocate at least 1 byte?\n      Or can assign_stack_local accept a 0 SIZE argument?  */\n   bufsize = (n_intregs * UNITS_PER_WORD) + (n_floatregs * UNITS_PER_WORD);\n \n-  regbuf = assign_stack_local (BLKmode, bufsize, 0);\n+  if (TARGET_SHMEDIA)\n+    regbuf = gen_rtx_MEM (BLKmode,\n+\t\t\t  gen_rtx_REG (Pmode, ARG_POINTER_REGNUM));\n+  else\n+    regbuf = assign_stack_local (BLKmode, bufsize, 0);\n   alias_set = get_varargs_alias_set ();\n   set_mem_alias_set (regbuf, alias_set);\n \n@@ -4286,6 +5089,10 @@ sh_builtin_saveregs ()\n \t\t\t\t\t n_floatregs * UNITS_PER_WORD),\n \t\t\t n_intregs, n_intregs * UNITS_PER_WORD);\n \n+  if (TARGET_SHMEDIA)\n+    /* Return the address of the regbuf.  */\n+    return XEXP (regbuf, 0);\n+\n   /* Save float args.\n      This is optimized to only save the regs that are necessary.  Explicitly\n      named args need not be saved.\n@@ -4345,7 +5152,7 @@ sh_build_va_list ()\n   tree f_next_o, f_next_o_limit, f_next_fp, f_next_fp_limit, f_next_stack;\n   tree record;\n \n-  if ((! TARGET_SH3E && ! TARGET_SH4) || TARGET_HITACHI)\n+  if (TARGET_SH5 || (! TARGET_SH3E && ! TARGET_SH4) || TARGET_HITACHI)\n     return ptr_type_node;\n \n   record = make_node (RECORD_TYPE);\n@@ -4393,6 +5200,20 @@ sh_va_start (stdarg_p, valist, nextarg)\n   tree t, u;\n   int nfp, nint;\n \n+  if (TARGET_SH5)\n+    {\n+      expand_builtin_saveregs ();\n+      /* When the varargs dummy argument is ``passed'' on a register,\n+\t we don't want std_expand_builtin_va_start() to apply any\n+\t correction for it, so set stdarg_p so as to pretend there's\n+\t no such dummy argument.  */\n+      if (current_function_args_info.arg_count[(int) SH_ARG_INT]\n+\t  < NPARM_REGS (SImode))\n+\tstdarg_p = 1;\n+      std_expand_builtin_va_start (stdarg_p, valist, nextarg);\n+      return;\n+    }\n+\n   if ((! TARGET_SH3E && ! TARGET_SH4) || TARGET_HITACHI)\n     {\n       std_expand_builtin_va_start (stdarg_p, valist, nextarg);\n@@ -4471,7 +5292,7 @@ sh_va_arg (valist, type)\n   rsize = (size + UNITS_PER_WORD - 1) & -UNITS_PER_WORD;\n   pptr_type_node = build_pointer_type (ptr_type_node);\n \n-  if ((TARGET_SH3E || TARGET_SH4) && ! TARGET_HITACHI)\n+  if (! TARGET_SH5 && (TARGET_SH3E || TARGET_SH4) && ! TARGET_HITACHI)\n     {\n       tree f_next_o, f_next_o_limit, f_next_fp, f_next_fp_limit, f_next_stack;\n       tree next_o, next_o_limit, next_fp, next_fp_limit, next_stack;\n@@ -4596,29 +5417,91 @@ initial_elimination_offset (from, to)\n      int to;\n {\n   int regs_saved;\n+  int regs_saved_rounding = 0;\n   int total_saved_regs_space;\n   int total_auto_space;\n   int save_flags = target_flags;\n+  int copy_flags;\n+\n+  HOST_WIDE_INT live_regs_mask[(FIRST_PSEUDO_REGISTER + 31) / 32];\n+  calc_live_regs (&regs_saved, live_regs_mask);\n+  regs_saved += SHMEDIA_REGS_STACK_ADJUST ();\n+  if (TARGET_SH5 && regs_saved % (STACK_BOUNDARY / BITS_PER_UNIT))\n+    regs_saved_rounding = ((STACK_BOUNDARY / BITS_PER_UNIT)\n+\t\t\t   - regs_saved % (STACK_BOUNDARY / BITS_PER_UNIT));\n \n-  int live_regs_mask, live_regs_mask2;\n-  live_regs_mask = calc_live_regs (&regs_saved, &live_regs_mask2);\n-  total_auto_space = rounded_frame_size (regs_saved);\n+  total_auto_space = rounded_frame_size (regs_saved) - regs_saved_rounding;\n+  copy_flags = target_flags;\n   target_flags = save_flags;\n \n-  total_saved_regs_space = regs_saved;\n+  total_saved_regs_space = regs_saved + regs_saved_rounding;\n \n   if (from == ARG_POINTER_REGNUM && to == FRAME_POINTER_REGNUM)\n-    return total_saved_regs_space + total_auto_space;\n+    return total_saved_regs_space + total_auto_space\n+      + current_function_args_info.byref_regs * 8;\n \n   if (from == ARG_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n-    return total_saved_regs_space + total_auto_space;\n+    return total_saved_regs_space + total_auto_space\n+      + current_function_args_info.byref_regs * 8;\n \n   /* Initial gap between fp and sp is 0.  */\n   if (from == FRAME_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n     return 0;\n \n   if (from == RETURN_ADDRESS_POINTER_REGNUM\n       && (to == FRAME_POINTER_REGNUM || to == STACK_POINTER_REGNUM))\n+      if (TARGET_SH5)\n+\t{\n+\t  int i, n = total_saved_regs_space;\n+\t  int align;\n+\t  int pr_reg = TARGET_SHMEDIA ? PR_MEDIA_REG : PR_REG;\n+\t  \n+\t  n += total_auto_space;\n+\n+\t  /* If it wasn't saved, there's not much we can do.  */\n+\t  if ((live_regs_mask[pr_reg / 32] & (1 << (pr_reg % 32))) == 0)\n+\t    return n;\n+\n+\t  target_flags = copy_flags;\n+\n+\t  /* We loop twice: first, check 8-byte aligned registers,\n+\t     that are stored in the higher addresses, that are known\n+\t     to be aligned.  Then, check 32-bit registers that don't\n+\t     need 8-byte alignment.  */\n+\t  for (align = 1; align >= 0; align--)\n+\t    for (i = FIRST_PSEUDO_REGISTER - 1; i >= 0; i--)\n+\t      if (live_regs_mask[i/32] & (1 << (i % 32)))\n+\t\t{\n+\t\t  enum machine_mode mode = REGISTER_NATURAL_MODE (i);\n+\n+\t\t  if (mode == SFmode && (i % 2) == 1\n+\t\t      && ! TARGET_FPU_SINGLE && FP_REGISTER_P (i)\n+\t\t      && (live_regs_mask[(i ^ 1) / 32]\n+\t\t\t  & (1 << ((i ^ 1) % 32))))\n+\t\t    {\n+\t\t      mode = DFmode;\n+\t\t      i--;\n+\t\t    }\n+\t\t\n+\t\t  /* If we're doing the aligned pass and this is not aligned,\n+\t\t     or we're doing the unaligned pass and this is aligned,\n+\t\t     skip it.  */\n+\t\t  if ((GET_MODE_SIZE (mode) % (STACK_BOUNDARY / BITS_PER_UNIT)\n+\t\t       == 0) != align)\n+\t\t    continue;\n+\n+\t\t  n -= GET_MODE_SIZE (mode);\n+\n+\t\t  if (i == pr_reg)\n+\t\t    {\n+\t\t      target_flags = save_flags;\n+\t\t      return n;\n+\t\t    }\n+\t\t}\n+\n+\t  abort ();\n+\t}\n+      else\n     return total_auto_space;\n \n   abort ();\n@@ -4858,6 +5741,20 @@ general_movdst_operand (op, mode)\n   return general_operand (op, mode);\n }\n \n+/* Accept a register, but not a subreg of any kind.  This allows us to\n+   avoid pathological cases in reload wrt data movement common in \n+   int->fp conversion.  */\n+\n+int\n+reg_no_subreg_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == SUBREG)\n+    return 0;\n+  return register_operand (op, mode);\n+}\n+\n /* Returns 1 if OP is a normal arithmetic register.  */\n \n int\n@@ -4877,6 +5774,7 @@ arith_reg_operand (op, mode)\n \treturn 1;\n \n       return (regno != T_REG && regno != PR_REG\n+\t      && ! TARGET_REGISTER_P (regno)\n \t      && (regno != FPUL_REG || TARGET_SH4)\n \t      && regno != MACH_REG && regno != MACL_REG);\n     }\n@@ -4915,7 +5813,20 @@ arith_operand (op, mode)\n   if (arith_reg_operand (op, mode))\n     return 1;\n \n-  if (GET_CODE (op) == CONST_INT && CONST_OK_FOR_I (INTVAL (op)))\n+  if (TARGET_SHMEDIA)\n+    {\n+      /* FIXME: We should be checking whether the CONST_INT fits in a\n+\t CONST_OK_FOR_J here, but this causes reload_cse to crash when\n+\t attempting to transform a sequence of two 64-bit sets of the\n+\t same register from literal constants into a set and an add,\n+\t when the difference is too wide for an add.  */\n+      if (GET_CODE (op) == CONST_INT\n+\t  || EXTRA_CONSTRAINT_S (op))\n+\treturn 1;\n+      else\n+\treturn 0;\n+    }\n+  else if (GET_CODE (op) == CONST_INT && CONST_OK_FOR_I (INTVAL (op)))\n     return 1;\n \n   return 0;\n@@ -4937,6 +5848,18 @@ arith_reg_or_0_operand (op, mode)\n   return 0;\n }\n \n+/* Return 1 if OP is a valid source operand for an SHmedia operation\n+   that takes either a register or a 6-bit immediate.  */\n+\n+int\n+shmedia_6bit_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (arith_reg_operand (op, mode)\n+\t  || (GET_CODE (op) == CONST_INT && CONST_OK_FOR_O (INTVAL (op))));\n+}\n+\n /* Returns 1 if OP is a valid source operand for a logical operation.  */\n \n int\n@@ -4947,7 +5870,14 @@ logical_operand (op, mode)\n   if (arith_reg_operand (op, mode))\n     return 1;\n \n-  if (GET_CODE (op) == CONST_INT && CONST_OK_FOR_L (INTVAL (op)))\n+  if (TARGET_SHMEDIA)\n+    {\n+      if (GET_CODE (op) == CONST_INT && CONST_OK_FOR_P (INTVAL (op)))\n+\treturn 1;\n+      else\n+\treturn 0;\n+    }\n+  else if (GET_CODE (op) == CONST_INT && CONST_OK_FOR_L (INTVAL (op)))\n     return 1;\n \n   return 0;\n@@ -5019,6 +5949,9 @@ fpul_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n+  if (TARGET_SHMEDIA)\n+    return fp_arith_reg_operand (op, mode);\n+\n   return (GET_CODE (op) == REG\n \t  && (REGNO (op) == FPUL_REG || REGNO (op) >= FIRST_PSEUDO_REGISTER)\n \t  && GET_MODE (op) == mode);\n@@ -5087,6 +6020,50 @@ binary_float_operator (op, mode)\n     }\n   return 0;\n }\n+\n+/* Accept pseudos and branch target registers.  */\n+int\n+target_reg_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (mode != DImode\n+      || GET_MODE (op) != DImode)\n+    return 0;\n+\n+  if (GET_CODE (op) == SUBREG)\n+    op = XEXP (op, 0);\n+\n+  if (GET_CODE (op) != REG)\n+    return 0;\n+\n+  /* We must protect ourselves from matching pseudos that are virtual\n+     register, because they will eventually be replaced with hardware\n+     registers that aren't branch-target registers.  */\n+  if (REGNO (op) > LAST_VIRTUAL_REGISTER\n+      || TARGET_REGISTER_P (REGNO (op)))\n+    return 1;\n+\n+  return 0;\n+}\n+\n+/* Same as target_reg_operand, except that label_refs and symbol_refs\n+   are accepted before reload.  */\n+int\n+target_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (mode != DImode)\n+    return 0;\n+\n+  if ((GET_MODE (op) == DImode || GET_MODE (op) == VOIDmode)\n+      && EXTRA_CONSTRAINT_T (op))\n+    return ! reload_completed;\n+\n+  return target_reg_operand (op, mode);\n+}\n+\n \f\n /* Return the destination address of a branch.  */\n    \n@@ -5480,13 +6457,20 @@ nonpic_symbol_mentioned_p (x)\n   register const char *fmt;\n   register int i;\n \n-  if (GET_CODE (x) == SYMBOL_REF || GET_CODE (x) == LABEL_REF)\n+  if (GET_CODE (x) == SYMBOL_REF || GET_CODE (x) == LABEL_REF\n+      || GET_CODE (x) == PC)\n     return 1;\n \n+  /* We don't want to look into the possible MEM location of a\n+     CONST_DOUBLE, since we're not going to use it, in general.  */\n+  if (GET_CODE (x) == CONST_DOUBLE)\n+    return 0;\n+\n   if (GET_CODE (x) == UNSPEC\n       && (XINT (x, 1) == UNSPEC_PIC\n \t  || XINT (x, 1) == UNSPEC_GOT\n \t  || XINT (x, 1) == UNSPEC_GOTOFF\n+\t  || XINT (x, 1) == UNSPEC_GOTPLT\n \t  || XINT (x, 1) == UNSPEC_PLT))\n       return 0;\n \n@@ -5718,3 +6702,18 @@ sh_pr_n_sets ()\n {\n   return REG_N_SETS (PR_REG);\n }\n+\n+/* SHmedia requires registers for branches, so we can't generate new\n+   branches past reload.  */\n+static bool\n+sh_cannot_modify_jumps_p ()\n+{\n+  return (TARGET_SHMEDIA && (reload_in_progress || reload_completed));\n+}\n+\n+static bool\n+sh_ms_bitfield_layout_p (record_type)\n+     tree record_type ATTRIBUTE_UNUSED;\n+{\n+  return TARGET_SH5;\n+}"}, {"sha": "c33f6c0b40aa6e2e9eb17690a07387477bccaccc", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 1172, "deletions": 182, "changes": 1354, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa5322fa5824e95a7aa82413782b510c8d91e7d8/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa5322fa5824e95a7aa82413782b510c8d91e7d8/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=fa5322fa5824e95a7aa82413782b510c8d91e7d8", "patch": "@@ -43,6 +43,11 @@ extern int code_for_indirect_jump_scratch;\n #define SDB_DELIM \";\"\n \n #define CPP_SPEC \" \\\n+%{m5-64media|m5-64media-nofpu|m5-32media|m5-32media-nofpu:-D__SHMEDIA__=1} \\\n+%{m5-compact|m5-compact-nofpu:-D__SHMEDIA__=0} \\\n+%{m5-64media|m5-64media-nofpu:-D__SH5__=64 -D__LONG_MAX__=9223372036854775807L} \\\n+%{m5-32media|m5-32media-nofpu|m5-compact|m5-compact-nofpu:-D__SH5__=32} \\\n+%{m5-64media-nofpu|m5-32media-nofpu|m5-compact-nofpu:-D__SH4_NOFPU__} \\\n %{m1:-D__sh1__} \\\n %{m2:-D__sh2__} \\\n %{m3:-D__sh3__} \\\n@@ -51,8 +56,7 @@ extern int code_for_indirect_jump_scratch;\n %{m4-single:-D__SH4_SINGLE__} \\\n %{m4-nofpu:-D__sh3__ -D__SH4_NOFPU__} \\\n %{m4:-D__SH4__} \\\n-%{!m1:%{!m2:%{!m3*:%{!m4*:%(cpp_default_cpu_spec)}}}} \\\n-%{mnomacsave:-D__NOMACSAVE__} \\\n+%{!m1:%{!m2:%{!m3*:%{!m4*:%{!m5*:%(cpp_default_cpu_spec)}}}}} \\\n %{mhitachi:-D__HITACHI__} \\\n %(subtarget_cpp_spec) \\\n %(subtarget_cpp_ptr_spec) \\\n@@ -71,7 +75,10 @@ extern int code_for_indirect_jump_scratch;\n #endif\n \n #ifndef SUBTARGET_CPP_PTR_SPEC\n-#define SUBTARGET_CPP_PTR_SPEC \"-D__SIZE_TYPE__=unsigned\\\\ int -D__PTRDIFF_TYPE__=int\"\n+#define SUBTARGET_CPP_PTR_SPEC \"\\\n+%{m5-64media|m5-64media-nofpu|m5-32media|m5-32media-nofpu|m5-compact|m5-compact-nofpu:-D__SIZE_TYPE__=long\\\\ unsigned\\\\ int -D__PTRDIFF_TYPE__=long\\\\ int} \\\n+%{!m5-64media:%{!m5-64media-nofpu:%{!m5-32media:%{!m5-32media-nofpu:%{!m5-compact:%{!m5-compact-nofpu:-D__SIZE_TYPE__=unsigned\\\\ int -D__PTRDIFF_TYPE__=int}}}}}} \\\n+\"\n #endif\n \n #define EXTRA_SPECS\t\t\t\t\t\t\\\n@@ -92,19 +99,18 @@ extern int code_for_indirect_jump_scratch;\n #define CONDITIONAL_REGISTER_USAGE do\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   int regno;\t\t\t\t\t\t\t\t\\\n-  if (! TARGET_SH4 || ! TARGET_FMOVD)\t\t\t\t\t\\\n+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno ++)\t\t\\\n+    if (! VALID_REGISTER_P (regno))\t\t\t\t\t\\\n+      fixed_regs[regno] = call_used_regs[regno] = 1;\t\t\t\\\n+  /* R8 and R9 are call-clobbered on SH5, but not on earlier SH ABIs.  */ \\\n+  if (TARGET_SH5)\t\t\t\t\t\t\t\\\n+    call_used_regs[FIRST_GENERAL_REG + 8]\t\t\t\t\\\n+      = call_used_regs[FIRST_GENERAL_REG + 9] = 1;\t\t\t\\\n+  if (TARGET_SHMEDIA)\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      for (regno = FIRST_XD_REG; regno <= LAST_XD_REG; regno++)\t\t\\\n-\tfixed_regs[regno] = call_used_regs[regno] = 1;\t\t\t\\\n-      if (! TARGET_SH4)\t\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  if (! TARGET_SH3E)\t\t\t\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t      for (regno = FIRST_FP_REG; regno <= LAST_FP_REG; regno++)\t\\\n-\t\tfixed_regs[regno] = call_used_regs[regno] = 1;\t\t\\\n-\t      fixed_regs[FPUL_REG] = call_used_regs[FPUL_REG] = 1;\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n+      regno_reg_class[FIRST_GENERAL_REG] = GENERAL_REGS;\t\t\\\n+      CLEAR_HARD_REG_SET (reg_class_contents[FP0_REGS]);\t\t\\\n+      regno_reg_class[FIRST_FP_REG] = FP_REGS;\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n   if (flag_pic)\t\t\t\t\t\t\t\t\\\n     fixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\t\t\t\\\n@@ -114,9 +120,16 @@ extern int code_for_indirect_jump_scratch;\n       call_used_regs[MACH_REG] = 0;\t\t\t\t\t\\\n       call_used_regs[MACL_REG] = 0;\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n-  for (regno = FIRST_GENERAL_REG; regno <= LAST_GENERAL_REG; regno++)\t\\\n-    if (! fixed_regs[regno] && call_used_regs[regno])\t\t\t\\\n-      SET_HARD_REG_BIT (reg_class_contents[SIBCALL_REGS], regno);\t\\\n+  if (TARGET_SHMEDIA)\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      for (regno = FIRST_TARGET_REG; regno <= LAST_TARGET_REG; regno ++)\\\n+\tif (! fixed_regs[regno] && call_used_regs[regno])\t\t\\\n+\t  SET_HARD_REG_BIT (reg_class_contents[SIBCALL_REGS], regno);\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    for (regno = FIRST_GENERAL_REG; regno <= LAST_GENERAL_REG; regno++)\t\\\n+      if (! fixed_regs[regno] && call_used_regs[regno])\t\t\t\\\n+\tSET_HARD_REG_BIT (reg_class_contents[SIBCALL_REGS], regno);\t\\\n } while (0)\n \f\n /* ??? Need to write documentation for all SH options and add it to the\n@@ -135,6 +148,7 @@ extern int target_flags;\n #define FPU_SINGLE_BIT\t(1<<7)\n #define SH4_BIT\t       \t(1<<12)\n #define FMOVD_BIT\t(1<<4)\n+#define SH5_BIT\t\t(1<<0)\n #define SPACE_BIT \t(1<<13)\n #define BIGTABLE_BIT  \t(1<<14)\n #define RELAX_BIT\t(1<<15)\n@@ -162,10 +176,10 @@ extern int target_flags;\n #define TARGET_SH3 (target_flags & SH3_BIT)\n \n /* Nonzero if we should generate code using type 3E insns.  */\n-#define TARGET_SH3E (target_flags & SH3E_BIT)\n+#define TARGET_SH3E ((target_flags & SH3E_BIT) && (target_flags & SH1_BIT))\n \n /* Nonzero if the cache line size is 32.  */\n-#define TARGET_CACHE32 (target_flags & HARD_SH4_BIT)\n+#define TARGET_CACHE32 (target_flags & HARD_SH4_BIT || TARGET_SH5)\n \n /* Nonzero if we schedule for a superscalar implementation.  */\n #define TARGET_SUPERSCALAR (target_flags & HARD_SH4_BIT)\n@@ -179,9 +193,38 @@ extern int target_flags;\n /* Nonzero if the default precision of th FPU is single */\n #define TARGET_FPU_SINGLE (target_flags & FPU_SINGLE_BIT)\n \n+/* Nonzero if a double-precision FPU is available.  */\n+#define TARGET_FPU_DOUBLE (target_flags & SH4_BIT)\n+\n+/* Nonzero if an FPU is available.  */\n+#define TARGET_FPU_ANY (TARGET_SH3E || TARGET_FPU_DOUBLE)\n+\n /* Nonzero if we should generate code using type 4 insns.  */\n-#define TARGET_SH4 (target_flags & SH4_BIT)\n+#define TARGET_SH4 ((target_flags & SH4_BIT) && (target_flags & SH1_BIT))\n+\n+/* Nonzero if we should generate code for a SH5 CPU (either ISA).  */\n+#define TARGET_SH5 (target_flags & SH5_BIT)\n+\n+/* Nonzero if we should generate code using the SHcompact instruction\n+   set and 32-bit ABI.  */\n+#define TARGET_SHCOMPACT (TARGET_SH5 && TARGET_SH1)\n+\n+/* Nonzero if we should generate code using the SHmedia instruction\n+   set and ABI.  */\n+#define TARGET_SHMEDIA (TARGET_SH5 && ! TARGET_SH1)\n \n+/* Nonzero if we should generate code using the SHmedia ISA and 32-bit\n+   ABI.  */\n+#define TARGET_SHMEDIA32 (TARGET_SH5 && ! TARGET_SH1 \\\n+\t\t\t  && (target_flags & SH3E_BIT))\n+\n+/* Nonzero if we should generate code using the SHmedia ISA and 64-bit\n+   ABI.  */\n+#define TARGET_SHMEDIA64 (TARGET_SH5 && ! TARGET_SH1 \\\n+ \t\t\t  && ! (target_flags & SH3E_BIT))\n+\n+/* Nonzero if we should generate code using SHmedia FPU instructions.  */\n+#define TARGET_SHMEDIA_FPU (TARGET_SHMEDIA && TARGET_FPU_DOUBLE)\n /* Nonzero if we should generate fmovd.  */\n #define TARGET_FMOVD (target_flags & FMOVD_BIT)\n \n@@ -222,7 +265,7 @@ extern int target_flags;\n \n /* Reset all target-selection flags.  */\n #define TARGET_NONE -(SH1_BIT | SH2_BIT | SH3_BIT | SH3E_BIT | SH4_BIT \\\n-\t\t      | HARD_SH4_BIT | FPU_SINGLE_BIT)\n+\t\t      | HARD_SH4_BIT | FPU_SINGLE_BIT | SH5_BIT)\n \n #define TARGET_SWITCHES  \t\t\t\\\n { {\"1\",\t        TARGET_NONE, \"\" },\t\t\\\n@@ -241,6 +284,18 @@ extern int target_flags;\n   {\"4-nofpu\",\tSH3_BIT|SH2_BIT|SH1_BIT|HARD_SH4_BIT, \"\" },\\\n   {\"4\",\t        TARGET_NONE, \"\" },\t\t\\\n   {\"4\",\t        SH4_BIT|SH3E_BIT|SH3_BIT|SH2_BIT|SH1_BIT|HARD_SH4_BIT, \"\" }, \\\n+  {\"5-64media\",\tTARGET_NONE, \"\" },\t\t\\\n+  {\"5-64media\", SH5_BIT|SH4_BIT, \"Generate 64-bit SHmedia code\" }, \\\n+  {\"5-64media-nofpu\", TARGET_NONE, \"\" },\t\\\n+  {\"5-64media-nofpu\", SH5_BIT, \"Generate 64-bit FPU-less SHmedia code\" }, \\\n+  {\"5-32media\",\tTARGET_NONE, \"\" },\t\t\\\n+  {\"5-32media\", SH5_BIT|SH4_BIT|SH3E_BIT, \"Generate 32-bit SHmedia code\" }, \\\n+  {\"5-32media-nofpu\", TARGET_NONE, \"\" },\t\\\n+  {\"5-32media-nofpu\", SH5_BIT|SH3E_BIT, \"Generate 32-bit FPU-less SHmedia code\" }, \\\n+  {\"5-compact\",\tTARGET_NONE, \"\" },\t\t\\\n+  {\"5-compact\",\tSH5_BIT|SH4_BIT|SH3E_BIT|SH3_BIT|SH2_BIT|SH1_BIT|FPU_SINGLE_BIT, \"Generate SHcompact code\" }, \\\n+  {\"5-compact-nofpu\", TARGET_NONE, \"\" },\t\\\n+  {\"5-compact-nofpu\", SH5_BIT|SH3_BIT|SH2_BIT|SH1_BIT, \"Generate FPU-less SHcompact code\" }, \\\n   {\"b\",\t\t-LITTLE_ENDIAN_BIT, \"\" },  \t\\\n   {\"bigtable\", \tBIGTABLE_BIT, \"\" },\t\t\\\n   {\"dalign\",  \tDALIGN_BIT, \"\" },\t\t\\\n@@ -279,6 +334,8 @@ extern int assembler_dialect;\n \n #define OVERRIDE_OPTIONS \t\t\t\t\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n+  int regno;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n   sh_cpu = CPU_SH1;\t\t\t\t\t\t\t\\\n   assembler_dialect = 0;\t\t\t\t\t\t\\\n   if (TARGET_SH2)\t\t\t\t\t\t\t\\\n@@ -292,16 +349,40 @@ do {\t\t\t\t\t\t\t\t\t\\\n       assembler_dialect = 1;\t\t\t\t\t\t\\\n       sh_cpu = CPU_SH4;\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n-  if (! TARGET_SH4 || ! TARGET_FMOVD)\t\t\t\t\t\\\n+  if (TARGET_SH5)\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      sh_cpu = CPU_SH5;\t\t\t\t\t\t\t\\\n+      target_flags |= DALIGN_BIT;\t\t\t\t\t\\\n+      if (TARGET_FPU_ANY)\t\t\t\t\t\t\\\n+\ttarget_flags |= FMOVD_BIT;\t\t\t\t\t\\\n+      if (TARGET_SHMEDIA)\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  /* There are no delay slots on SHmedia.  */\t\t\t\\\n+\t  flag_delayed_branch = 0;\t\t\t\t\t\\\n+\t  /* Relaxation isn't yet supported for SHmedia */\t\t\\\n+\t  target_flags &= ~RELAX_BIT;\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      if (profile_flag || profile_arc_flag)\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  warning (\"Profiling is not supported on this target.\");\t\\\n+\t  profile_flag = profile_arc_flag = 0;\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      /* Prevent usage of explicit register names for variables\t\t\\\n-\t for registers not present / not addressable in the\t\t\\\n-\t target architecture.  */\t\t\t\t\t\\\n-      int regno;\t\t\t\t\t\t\t\\\n-      for (regno = (TARGET_SH3E) ? 17 : 0; \t\t\t\t\\\n-\t   regno <= 24; regno++)\t\t\t\t\t\\\n-\tfp_reg_names[regno][0] = 0;\t\t\t\t\t\\\n+       /* Only the sh64-elf assembler fully supports .quad properly.  */\\\n+       targetm.asm_out.aligned_op.di = NULL;\t\t\t\t\\\n+       targetm.asm_out.unaligned_op.di = NULL;\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\t\t\\\n+    if (! VALID_REGISTER_P (regno))\t\t\t\t\t\\\n+      sh_register_names[regno][0] = '\\0';\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  for (regno = 0; regno < ADDREGNAMES_SIZE; regno++)\t\t\t\\\n+    if (! VALID_REGISTER_P (ADDREGNAMES_REGNO (regno)))\t\t\t\\\n+      sh_additional_register_names[regno][0] = '\\0';\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n   if (flag_omit_frame_pointer < 0)\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      /* The debugging information is sufficient,\t\t\t\\\n@@ -356,18 +437,34 @@ do {\t\t\t\t\t\t\t\t\t\\\n    Note that this is not necessarily the width of data type `int';\n    if using 16-bit ints on a 68000, this would still be 32.\n    But on a machine with 16-bit registers, this would be 16.  */\n-#define BITS_PER_WORD  32\n-#define MAX_BITS_PER_WORD 32\n+#define BITS_PER_WORD  (TARGET_SHMEDIA ? 64 : 32)\n+#define MAX_BITS_PER_WORD 64\n+\n+#define MAX_LONG_TYPE_SIZE MAX_BITS_PER_WORD\n+\n+/* Width in bits of an `int'.  We want just 32-bits, even if words are\n+   longer. */\n+#define INT_TYPE_SIZE 32\n+\n+/* Width in bits of a `long'.  */\n+#define LONG_TYPE_SIZE (TARGET_SHMEDIA64 ? 64 : 32)\n+\n+/* Width in bits of a `long long'.  */\n+#define LONG_LONG_TYPE_SIZE 64\n+\n+/* Width in bits of a `long double'.  */\n+#define LONG_DOUBLE_TYPE_SIZE 64\n \n /* Width of a word, in units (bytes).  */\n-#define UNITS_PER_WORD\t4\n+#define UNITS_PER_WORD\t(TARGET_SHMEDIA ? 8 : 4)\n+#define MIN_UNITS_PER_WORD 4\n \n /* Width in bits of a pointer.\n    See also the macro `Pmode' defined below.  */\n-#define POINTER_SIZE  32\n+#define POINTER_SIZE  (TARGET_SHMEDIA64 ? 64 : 32)\n \n /* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n-#define PARM_BOUNDARY  \t32\n+#define PARM_BOUNDARY  \t(TARGET_SH5 ? 64 : 32)\n \n /* Boundary (in *bits*) on which stack pointer should be aligned.  */\n #define STACK_BOUNDARY  BIGGEST_ALIGNMENT\n@@ -380,7 +477,14 @@ do {\t\t\t\t\t\t\t\t\t\\\n /* Allocation boundary (in *bits*) for the code of a function.\n    32 bit alignment is faster, because instructions are always fetched as a\n    pair from a longword boundary.  */\n-#define FUNCTION_BOUNDARY  (TARGET_SMALLCODE ? 16 : (1 << CACHE_LOG) * 8)\n+#define FUNCTION_BOUNDARY  \\\n+  (TARGET_SMALLCODE ? 16 << TARGET_SHMEDIA : (1 << CACHE_LOG) * 8)\n+\n+/* On SH5, the lowest bit is used to indicate SHmedia functions, so\n+   the vbit must go into the delta field of\n+   pointers-to-member-functions.  */\n+#define TARGET_PTRMEMFUNC_VBIT_LOCATION \\\n+  (TARGET_SH5 ? ptrmemfunc_vbit_in_delta : ptrmemfunc_vbit_in_pfn)\n \n /* Alignment of field after `int : 0' in a structure.  */\n #define EMPTY_FIELD_BOUNDARY  32\n@@ -389,7 +493,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define BIGGEST_ALIGNMENT  (TARGET_ALIGN_DOUBLE ? 64 : 32)\n \n /* The best alignment to use in cases where we have a choice.  */\n-#define FASTEST_ALIGNMENT 32\n+#define FASTEST_ALIGNMENT (TARGET_SH5 ? 64 : 32)\n \n /* Make strings word-aligned so strcpy from constants will be faster.  */\n #define CONSTANT_ALIGNMENT(EXP, ALIGN)\t\\\n@@ -440,9 +544,9 @@ do {\t\t\t\t\t\t\t\t\t\\\n /* The base two logarithm of the known minimum alignment of an insn length.  */\n #define INSN_LENGTH_ALIGNMENT(A_INSN)\t\t\t\t\t\\\n   (GET_CODE (A_INSN) == INSN\t\t\t\t\t\t\\\n-   ? 1\t\t\t\t\t\t\t\t\t\\\n+   ? 1 << TARGET_SHMEDIA\t\t\t\t\t\t\\\n    : GET_CODE (A_INSN) == JUMP_INSN || GET_CODE (A_INSN) == CALL_INSN\t\\\n-   ? 1\t\t\t\t\t\t\t\t\t\\\n+   ? 1 << TARGET_SHMEDIA\t\t\t\t\t\t\\\n    : CACHE_LOG)\n \f\n /* Standard register usage.  */\n@@ -467,6 +571,95 @@ do {\t\t\t\t\t\t\t\t\t\\\n \tfr4..fr11\tfp args in\n \tfr12..fr15\tcall saved floating point registers  */\n \n+#define MAX_REGISTER_NAME_LENGTH 5\n+extern char sh_register_names[][MAX_REGISTER_NAME_LENGTH + 1];\n+\n+#define SH_REGISTER_NAMES_INITIALIZER\t\t\t\t\t\\\n+{\t\t\t\t                   \t\t\t\\\n+  \"r0\",   \"r1\",   \"r2\",   \"r3\",   \"r4\",   \"r5\",   \"r6\",   \"r7\", \t\\\n+  \"r8\",   \"r9\",   \"r10\",  \"r11\",  \"r12\",  \"r13\",  \"r14\",  \"r15\",\t\\\n+  \"r16\",  \"r17\",  \"r18\",  \"r19\",  \"r20\",  \"r21\",  \"r22\",  \"r23\",\t\\\n+  \"r24\",  \"r25\",  \"r26\",  \"r27\",  \"r28\",  \"r29\",  \"r30\",  \"r31\",\t\\\n+  \"r32\",  \"r33\",  \"r34\",  \"r35\",  \"r36\",  \"r37\",  \"r38\",  \"r39\", \t\\\n+  \"r40\",  \"r41\",  \"r42\",  \"r43\",  \"r44\",  \"r45\",  \"r46\",  \"r47\",\t\\\n+  \"r48\",  \"r49\",  \"r50\",  \"r51\",  \"r52\",  \"r53\",  \"r54\",  \"r55\",\t\\\n+  \"r56\",  \"r57\",  \"r58\",  \"r59\",  \"r60\",  \"r61\",  \"r62\",  \"r63\",\t\\\n+  \"fr0\",  \"fr1\",  \"fr2\",  \"fr3\",  \"fr4\",  \"fr5\",  \"fr6\",  \"fr7\", \t\\\n+  \"fr8\",  \"fr9\",  \"fr10\", \"fr11\", \"fr12\", \"fr13\", \"fr14\", \"fr15\",\t\\\n+  \"fr16\", \"fr17\", \"fr18\", \"fr19\", \"fr20\", \"fr21\", \"fr22\", \"fr23\",\t\\\n+  \"fr24\", \"fr25\", \"fr26\", \"fr27\", \"fr28\", \"fr29\", \"fr30\", \"fr31\",\t\\\n+  \"fr32\", \"fr33\", \"fr34\", \"fr35\", \"fr36\", \"fr37\", \"fr38\", \"fr39\", \t\\\n+  \"fr40\", \"fr41\", \"fr42\", \"fr43\", \"fr44\", \"fr45\", \"fr46\", \"fr47\",\t\\\n+  \"fr48\", \"fr49\", \"fr50\", \"fr51\", \"fr52\", \"fr53\", \"fr54\", \"fr55\",\t\\\n+  \"fr56\", \"fr57\", \"fr58\", \"fr59\", \"fr60\", \"fr61\", \"fr62\", \"fr63\",\t\\\n+  \"tr0\",  \"tr1\",  \"tr2\",  \"tr3\",  \"tr4\",  \"tr5\",  \"tr6\",  \"tr7\", \t\\\n+  \"xd0\",  \"xd2\",  \"xd4\",  \"xd6\",  \"xd8\",  \"xd10\", \"xd12\", \"xd14\",\t\\\n+  \"gbr\",  \"ap\",\t  \"pr\",   \"t\",    \"mach\", \"macl\", \"fpul\", \"fpscr\",\t\\\n+  \"rap\"\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define DEBUG_REGISTER_NAMES SH_REGISTER_NAMES_INITIALIZER\n+\n+#define REGNAMES_ARR_INDEX_1(index) \\\n+  (sh_register_names[index])\n+#define REGNAMES_ARR_INDEX_2(index) \\\n+  REGNAMES_ARR_INDEX_1 ((index)), REGNAMES_ARR_INDEX_1 ((index)+1)\n+#define REGNAMES_ARR_INDEX_4(index) \\\n+  REGNAMES_ARR_INDEX_2 ((index)), REGNAMES_ARR_INDEX_2 ((index)+2)\n+#define REGNAMES_ARR_INDEX_8(index) \\\n+  REGNAMES_ARR_INDEX_4 ((index)), REGNAMES_ARR_INDEX_4 ((index)+4)\n+#define REGNAMES_ARR_INDEX_16(index) \\\n+  REGNAMES_ARR_INDEX_8 ((index)), REGNAMES_ARR_INDEX_8 ((index)+8)\n+#define REGNAMES_ARR_INDEX_32(index) \\\n+  REGNAMES_ARR_INDEX_16 ((index)), REGNAMES_ARR_INDEX_16 ((index)+16)\n+#define REGNAMES_ARR_INDEX_64(index) \\\n+  REGNAMES_ARR_INDEX_32 ((index)), REGNAMES_ARR_INDEX_32 ((index)+32)\n+\n+#define REGISTER_NAMES \\\n+{ \\\n+  REGNAMES_ARR_INDEX_64 (0), \\\n+  REGNAMES_ARR_INDEX_64 (64), \\\n+  REGNAMES_ARR_INDEX_8 (128), \\\n+  REGNAMES_ARR_INDEX_8 (136), \\\n+  REGNAMES_ARR_INDEX_8 (144), \\\n+  REGNAMES_ARR_INDEX_1 (152) \\\n+}\n+\n+#define ADDREGNAMES_SIZE 32\n+#define MAX_ADDITIONAL_REGISTER_NAME_LENGTH 4\n+extern char sh_additional_register_names[ADDREGNAMES_SIZE] \\\n+  [MAX_ADDITIONAL_REGISTER_NAME_LENGTH + 1];\n+\n+#define SH_ADDITIONAL_REGISTER_NAMES_INITIALIZER\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  \"dr0\",  \"dr2\",  \"dr4\",  \"dr6\",  \"dr8\",  \"dr10\", \"dr12\", \"dr14\",\t\\\n+  \"dr16\", \"dr18\", \"dr20\", \"dr22\", \"dr24\", \"dr26\", \"dr28\", \"dr30\",\t\\\n+  \"dr32\", \"dr34\", \"dr36\", \"dr38\", \"dr40\", \"dr42\", \"dr44\", \"dr46\",\t\\\n+  \"dr48\", \"dr50\", \"dr52\", \"dr54\", \"dr56\", \"dr58\", \"dr60\", \"dr62\"\t\\\n+}\n+\n+#define ADDREGNAMES_REGNO(index) \\\n+  ((index < 32) ? (FIRST_FP_REG + (index) * 2) \\\n+   : (-1))\n+\n+#define ADDREGNAMES_ARR_INDEX_1(index) \\\n+  { (sh_additional_register_names[index]), ADDREGNAMES_REGNO (index) }\n+#define ADDREGNAMES_ARR_INDEX_2(index) \\\n+  ADDREGNAMES_ARR_INDEX_1 ((index)), ADDREGNAMES_ARR_INDEX_1 ((index)+1)\n+#define ADDREGNAMES_ARR_INDEX_4(index) \\\n+  ADDREGNAMES_ARR_INDEX_2 ((index)), ADDREGNAMES_ARR_INDEX_2 ((index)+2)\n+#define ADDREGNAMES_ARR_INDEX_8(index) \\\n+  ADDREGNAMES_ARR_INDEX_4 ((index)), ADDREGNAMES_ARR_INDEX_4 ((index)+4)\n+#define ADDREGNAMES_ARR_INDEX_16(index) \\\n+  ADDREGNAMES_ARR_INDEX_8 ((index)), ADDREGNAMES_ARR_INDEX_8 ((index)+8)\n+#define ADDREGNAMES_ARR_INDEX_32(index) \\\n+  ADDREGNAMES_ARR_INDEX_16 ((index)), ADDREGNAMES_ARR_INDEX_16 ((index)+16)\n+\n+#define ADDITIONAL_REGISTER_NAMES \\\n+{\t\t\t\t\t\\\n+  ADDREGNAMES_ARR_INDEX_32 (0)\t\t\\\n+}\n+\n /* Number of actual hardware registers.\n    The hardware registers are assigned numbers for the compiler\n    from 0 to just below FIRST_PSEUDO_REGISTER.\n@@ -476,11 +669,14 @@ do {\t\t\t\t\t\t\t\t\t\\\n /* There are many other relevant definitions in sh.md's md_constants.  */\n \n #define FIRST_GENERAL_REG R0_REG\n-#define LAST_GENERAL_REG (FIRST_GENERAL_REG + 15)\n+#define LAST_GENERAL_REG (FIRST_GENERAL_REG + (TARGET_SHMEDIA ? 63 : 15))\n #define FIRST_FP_REG DR0_REG\n-#define LAST_FP_REG  (FIRST_FP_REG + 15)\n+#define LAST_FP_REG  (FIRST_FP_REG + \\\n+\t\t      (TARGET_SHMEDIA_FPU ? 63 : TARGET_SH3E ? 15 : -1))\n #define FIRST_XD_REG XD0_REG\n-#define LAST_XD_REG  (FIRST_XD_REG + 7)\n+#define LAST_XD_REG  (FIRST_XD_REG + ((TARGET_SH4 && TARGET_FMOVD) ? 7 : -1))\n+#define FIRST_TARGET_REG TR0_REG\n+#define LAST_TARGET_REG  (FIRST_TARGET_REG + (TARGET_SHMEDIA ? 7 : -1))\n \n #define GENERAL_REGISTER_P(REGNO) \\\n   IN_RANGE ((REGNO), FIRST_GENERAL_REG, LAST_GENERAL_REG)\n@@ -504,28 +700,67 @@ do {\t\t\t\t\t\t\t\t\t\\\n   ((REGNO) == GBR_REG || (REGNO) == T_REG \\\n    || (REGNO) == MACH_REG || (REGNO) == MACL_REG)\n \n-#define FIRST_PSEUDO_REGISTER 49\n+#define TARGET_REGISTER_P(REGNO) \\\n+  ((REGNO) >= FIRST_TARGET_REG && (REGNO) <= LAST_TARGET_REG)\n+\n+#define SHMEDIA_REGISTER_P(REGNO) \\\n+  (GENERAL_REGISTER_P (REGNO) || FP_REGISTER_P (REGNO) \\\n+   || TARGET_REGISTER_P (REGNO))\n+\n+/* This is to be used in CONDITIONAL_REGISTER_USAGE, to mark registers\n+   that should be fixed.  */\n+#define VALID_REGISTER_P(REGNO) \\\n+  (SHMEDIA_REGISTER_P (REGNO) || XD_REGISTER_P (REGNO) \\\n+   || (REGNO) == AP_REG || (REGNO) == RAP_REG \\\n+   || (TARGET_SH1 && (SPECIAL_REGISTER_P (REGNO) || (REGNO) == PR_REG)) \\\n+   || (TARGET_SH3E && (REGNO) == FPUL_REG))\n+\n+/* The mode that should be generally used to store a register by\n+   itself in the stack, or to load it back.  */\n+#define REGISTER_NATURAL_MODE(REGNO) \\\n+  (FP_REGISTER_P (REGNO) ? SFmode \\\n+   : XD_REGISTER_P (REGNO) ? DFmode \\\n+   : TARGET_SHMEDIA ? DImode : SImode)\n+\n+#define FIRST_PSEUDO_REGISTER 153\n \n /* 1 for registers that have pervasive standard uses\n    and are not available for the register allocator.\n \n    Mach register is fixed 'cause it's only 10 bits wide for SH1.\n    It is 32 bits wide for SH2.  */\n \n-#define FIXED_REGISTERS  \t\\\n-  { 0,  0,  0,  0, \t\t\\\n-    0,  0,  0,  0, \t\t\\\n-    0,  0,  0,  0, \t\t\\\n-    0,  0,  0,  1, \t\t\\\n-    1,  1,  1,  1, \t\t\\\n-    1,  1,  0,  1,\t\t\\\n-    0,  0,  0,  0,\t\t\\\n-    0,  0,  0,  0,\t\t\\\n-    0,  0,  0,  0,\t\t\\\n-    0,  0,  0,  0,\t\t\\\n-    0,  0,  0,  0,\t\t\\\n-    0,  0,  0,  0,\t\t\\\n-    1,\t\t\t\t\\\n+#define FIXED_REGISTERS  \t\t\t\t\t\t\\\n+{\t\t\t\t                   \t\t\t\\\n+/* Regular registers.  */\t\t\t\t\t\t\\\n+  0,      0,      0,      0,      0,      0,      0,      0,\t\t\\\n+  0,      0,      0,      0,      0,      0,      0,      1,\t\t\\\n+  /* r16 is reserved, r18 is the former pr.  */\t\t\t\t\\\n+  1,      0,      0,      0,      0,      0,      0,      0,\t\t\\\n+  /* r24 is reserved for the OS; r25, for the assembler or linker.  */\t\\\n+  /* r26 is a global variable data pointer; r27 is for constants.  */\t\\\n+  1,      1,      1,      1,      0,      0,      0,      0,\t\t\\\n+  0,      0,      0,      0,      0,      0,      0,      0,\t\t\\\n+  0,      0,      0,      0,      0,      0,      0,      0,\t\t\\\n+  0,      0,      0,      0,      0,      0,      0,      0,\t\t\\\n+  0,      0,      0,      0,      0,      0,      0,      1,\t\t\\\n+/* FP registers.  */\t\t\t\t\t\t\t\\\n+  0,      0,      0,      0,      0,      0,      0,      0,\t\t\\\n+  0,      0,      0,      0,      0,      0,      0,      0,\t\t\\\n+  0,      0,      0,      0,      0,      0,      0,      0,\t\t\\\n+  0,      0,      0,      0,      0,      0,      0,      0,\t\t\\\n+  0,      0,      0,      0,      0,      0,      0,      0,\t\t\\\n+  0,      0,      0,      0,      0,      0,      0,      0,\t\t\\\n+  0,      0,      0,      0,      0,      0,      0,      0,\t\t\\\n+  0,      0,      0,      0,      0,      0,      0,      0,\t\t\\\n+/* Branch target registers.  */\t\t\t\t\t\t\\\n+  0,      0,      0,      0,      0,      0,      0,      0,\t\t\\\n+/* XD registers.  */\t\t\t\t\t\t\t\\\n+  0,      0,      0,      0,      0,      0,      0,      0,\t\t\\\n+/*\"gbr\",  \"ap\",\t  \"pr\",   \"t\",    \"mach\", \"macl\", \"fpul\", \"fpscr\", */\t\\\n+  1,      1,      1,      1,      1,      1,      0,      1,\t\t\\\n+/*\"rap\" */\t\t\t\t\t\t\t\t\\\n+  1,\t\t\t\t\t\t\t\t\t\\\n }\n \n /* 1 for registers not available across function calls.\n@@ -535,22 +770,50 @@ do {\t\t\t\t\t\t\t\t\t\\\n    and the register where structure-value addresses are passed.\n    Aside from that, you can include as many other registers as you like.  */\n \n-#define CALL_USED_REGISTERS \t\\\n-  { 1,  1,  1,  1,\t\t\\\n-    1,  1,  1,  1, \t\t\\\n-    0,  0,  0,  0,\t\t\\\n-    0,  0,  0,  1,\t\t\\\n-    1,  0,  1,  1,\t\t\\\n-    1,  1,  1,  1,\t\t\\\n-    1,  1,  1,  1,\t\t\\\n-    1,  1,  1,  1,\t\t\\\n-    1,  1,  1,  1,\t\t\\\n-    0,  0,  0,  0,\t\t\\\n-    1,  1,  1,  1,\t\t\\\n-    1,  1,  0,  0,\t\t\\\n-    1,\t\t\t\t\\\n+#define CALL_USED_REGISTERS  \t\t\t\t\t\t\\\n+{\t\t\t\t                   \t\t\t\\\n+/* Regular registers.  */\t\t\t\t\t\t\\\n+  1,      1,      1,      1,      1,      1,      1,      1,\t\t\\\n+  /* R8 and R9 are call-clobbered on SH5, but not on earlier SH ABIs.\t\\\n+     Only the lower 32bits of R10-R14 are guaranteed to be preserved\t\\\n+     across SH5 function calls.  */\t\t\t\t\t\\\n+  0,      0,      0,      0,      0,      0,      0,      1,\t\t\\\n+  1,      1,      0,      1,      1,      1,      1,      1,\t\t\\\n+  1,      1,      1,      1,      0,      0,      0,      0,\t\t\\\n+  0,      0,      0,      0,      1,      1,      1,      1,\t\t\\\n+  1,      1,      1,      1,      0,      0,      0,      0,\t\t\\\n+  0,      0,      0,      0,      0,      0,      0,      0,\t\t\\\n+  0,      0,      0,      0,      1,      1,      1,      1,\t\t\\\n+/* FP registers.  */\t\t\t\t\t\t\t\\\n+  1,      1,      1,      1,      1,      1,      1,      1,\t\t\\\n+  1,      1,      1,      1,      0,      0,      0,      0,\t\t\\\n+  1,      1,      1,      1,      1,      1,      1,      1,\t\t\\\n+  1,      1,      1,      1,      1,      1,      1,      1,\t\t\\\n+  1,      1,      1,      1,      0,      0,      0,      0,\t\t\\\n+  0,      0,      0,      0,      0,      0,      0,      0,\t\t\\\n+  0,      0,      0,      0,      0,      0,      0,      0,\t\t\\\n+  0,      0,      0,      0,      0,      0,      0,      0,\t\t\\\n+/* Branch target registers.  */\t\t\t\t\t\t\\\n+  1,      1,      1,      1,      1,      0,      0,      0,\t\t\\\n+/* XD registers.  */\t\t\t\t\t\t\t\\\n+  1,      1,      1,      1,      1,      1,      0,      0,\t\t\\\n+/*\"gbr\",  \"ap\",\t  \"pr\",   \"t\",    \"mach\", \"macl\", \"fpul\", \"fpscr\", */\t\\\n+  1,      1,      0,      1,      1,      1,      1,      1,\t\t\\\n+/*\"rap\" */\t\t\t\t\t\t\t\t\\\n+  1,\t\t\t\t\t\t\t\t\t\\\n }\n \n+/* Only the lower 32-bits of R10-R14 are guaranteed to be preserved\n+   across SHcompact function calls.  We can't tell whether a called\n+   function is SHmedia or SHcompact, so we assume it may be when\n+   compiling SHmedia code with the 32-bit ABI, since that's the only\n+   ABI that can be linked with SHcompact code.  */\n+#define HARD_REGNO_CALL_PART_CLOBBERED(REGNO,MODE) \\\n+  (TARGET_SHMEDIA32 \\\n+   && GET_MODE_SIZE (MODE) > 4 \\\n+   && (REGNO) >= FIRST_GENERAL_REG + 10 \\\n+   && (REGNO) <= FIRST_GENERAL_REG + 14)\n+\n /* Return number of consecutive hard regs needed starting at reg REGNO\n    to hold something of mode MODE.\n    This is ordinarily the length in words of a value of mode MODE\n@@ -561,6 +824,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define HARD_REGNO_NREGS(REGNO, MODE) \\\n    (XD_REGISTER_P (REGNO) \\\n     ? (GET_MODE_SIZE (MODE) / (2 * UNITS_PER_WORD)) \\\n+    : (TARGET_SHMEDIA && FP_REGISTER_P (REGNO)) \\\n+    ? ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD/2 - 1) / (UNITS_PER_WORD/2)) \\\n     : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)) \\\n \n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n@@ -580,17 +845,35 @@ do {\t\t\t\t\t\t\t\t\t\\\n    : (REGNO) == FPUL_REG ? (MODE) == SImode || (MODE) == SFmode\t\\\n    : FP_REGISTER_P (REGNO) && (MODE) == SFmode \\\n    ? 1 \\\n+   : (MODE) == V2SFmode \\\n+   ? (FP_REGISTER_P (REGNO) && ((REGNO) - FIRST_FP_REG) % 2 == 0) \\\n+   : (MODE) == V4SFmode \\\n+   ? (FP_REGISTER_P (REGNO) && ((REGNO) - FIRST_FP_REG) % 4 == 0) \\\n+   : (MODE) == V16SFmode \\\n+   ? (TARGET_SHMEDIA \\\n+      ? (FP_REGISTER_P (REGNO) && ((REGNO) - FIRST_FP_REG) % 16 == 0) \\\n+      : (REGNO) == FIRST_XD_REG) \\\n    : FP_REGISTER_P (REGNO) \\\n    ? ((MODE) == SFmode \\\n-      || (TARGET_SH3E && (MODE) == SCmode) \\\n-      || (((TARGET_SH4 && (MODE) == DFmode) || (MODE) == DCmode) \\\n+      || (TARGET_SHMEDIA && (MODE) == SImode) \\\n+      || ((TARGET_SH3E || TARGET_SHMEDIA) && (MODE) == SCmode) \\\n+      || (((TARGET_SH4 && (MODE) == DFmode) || (MODE) == DCmode \\\n+\t   || (TARGET_SHMEDIA && ((MODE) == DFmode || (MODE) == DImode \\\n+\t\t\t\t  || (MODE) == V2SFmode))) \\\n \t  && (((REGNO) - FIRST_FP_REG) & 1) == 0)) \\\n    : XD_REGISTER_P (REGNO) \\\n    ? (MODE) == DFmode \\\n+   : TARGET_REGISTER_P (REGNO) \\\n+   ? ((MODE) == DImode || (MODE) == SImode) \\\n    : (REGNO) == PR_REG ? 0\t\t\t\\\n    : (REGNO) == FPSCR_REG ? (MODE) == PSImode \\\n    : 1)\n \n+/* Value is 1 if MODE is a supported vector mode.  */\n+#define VECTOR_MODE_SUPPORTED_P(MODE) \\\n+  (TARGET_FPU_ANY \\\n+   && ((MODE) == V2SFmode || (MODE) == V4SFmode || (MODE) == V16SFmode))\n+\n /* Value is 1 if it is a good idea to tie two pseudo registers\n    when one has mode MODE1 and one has mode MODE2.\n    If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n@@ -602,7 +885,9 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define MODES_TIEABLE_P(MODE1, MODE2) \\\n   ((MODE1) == (MODE2) \\\n    || (GET_MODE_CLASS (MODE1) == GET_MODE_CLASS (MODE2) \\\n-       && (MODE1) != SFmode && (MODE2) != SFmode))\n+       && (TARGET_SHMEDIA ? ((GET_MODE_SIZE (MODE1) <= 4) \\\n+\t\t\t      && (GET_MODE_SIZE (MODE2) <= 4)) \\\n+\t\t\t  : ((MODE1) != SFmode && (MODE2) != SFmode))))\n \n /* Specify the registers used for certain standard purposes.\n    The values of these macros are register numbers.  */\n@@ -677,7 +962,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define ARG_POINTER_REGNUM\tAP_REG\n \n /* Register in which the static-chain is passed to a function.  */\n-#define STATIC_CHAIN_REGNUM\t3\n+#define STATIC_CHAIN_REGNUM\t(TARGET_SH5 ? 1 : 3)\n \n /* The register in which a struct value address is passed.  */\n \n@@ -695,13 +980,24 @@ do {\t\t\t\t\t\t\t\t\t\\\n   (TARGET_HITACHI ? 0 : gen_rtx_REG (Pmode, STRUCT_VALUE_REGNUM))\n \n #define RETURN_IN_MEMORY(TYPE) \\\n-  (TYPE_MODE (TYPE) == BLKmode \\\n-   || TARGET_HITACHI && TREE_CODE (TYPE) == RECORD_TYPE)\n+  (TARGET_SH5 \\\n+   ? ((TYPE_MODE (TYPE) == BLKmode \\\n+       ? int_size_in_bytes (TYPE) \\\n+       : GET_MODE_SIZE (TYPE_MODE (TYPE))) > 8) \\\n+   : (TYPE_MODE (TYPE) == BLKmode \\\n+      || TARGET_HITACHI && TREE_CODE (TYPE) == RECORD_TYPE))\n \n /* Don't default to pcc-struct-return, because we have already specified\n    exactly how to return structures in the RETURN_IN_MEMORY macro.  */\n \n #define DEFAULT_PCC_STRUCT_RETURN 0\n+\n+#define SHMEDIA_REGS_STACK_ADJUST() \\\n+  (TARGET_SHCOMPACT && current_function_has_nonlocal_label \\\n+   ? (8 * (/* r28-r35 */ 8 + /* r44-r59 */ 16 + /* tr5-tr7 */ 3) \\\n+      + (TARGET_FPU_ANY ? 4 * (/* fr36 - fr63 */ 28) : 0)) \\\n+   : 0)\n+\n \f\n /* Define the classes of registers for register constraints in the\n    machine description.  Also define ranges of constants.\n@@ -751,6 +1047,7 @@ enum reg_class\n   DF_REGS,\n   FPSCR_REGS,\n   GENERAL_FP_REGS,\n+  TARGET_REGS,\n   ALL_REGS,\n   LIM_REG_CLASSES\n };\n@@ -773,31 +1070,47 @@ enum reg_class\n   \"DF_REGS\",\t\t\\\n   \"FPSCR_REGS\",\t\t\\\n   \"GENERAL_FP_REGS\",\t\\\n+  \"TARGET_REGS\",\t\\\n   \"ALL_REGS\",\t\t\\\n }\n \n /* Define which registers fit in which classes.\n    This is an initializer for a vector of HARD_REG_SET\n    of length N_REG_CLASSES.  */\n \n-#define REG_CLASS_CONTENTS\t\t\t\t\\\n-{\t\t\t\t\t\t\t\\\n-  { 0x00000000, 0x00000000 }, /* NO_REGS\t*/\t\\\n-  { 0x00000001, 0x00000000 }, /* R0_REGS\t*/\t\\\n-  { 0x00020000, 0x00000000 }, /* PR_REGS\t*/\t\\\n-  { 0x00040000, 0x00000000 }, /* T_REGS\t\t*/\t\\\n-  { 0x00300000, 0x00000000 }, /* MAC_REGS\t*/\t\\\n-  { 0x00400000, 0x00000000 }, /* FPUL_REGS\t*/\t\\\n-  /* SIBCALL_REGS is initialized in CONDITIONAL_REGISTER_USAGE.  */ \\\n-  { 0x00000000, 0x00000000 }, /* SIBCALL_REGS   */\t\\\n-  { 0x0081FFFF, 0x00000000 }, /* GENERAL_REGS\t*/\t\\\n-  { 0x01000000, 0x00000000 }, /* FP0_REGS\t*/\t\\\n-  { 0xFF000000, 0x000000FF }, /* FP_REGS\t*/\t\\\n-  { 0xFF000000, 0x0000FFFF }, /* DF_REGS\t*/\t\\\n-  { 0x00000000, 0x00010000 }, /* FPSCR_REGS\t*/\t\\\n-  { 0xFF81FFFF, 0x0000FFFF }, /* GENERAL_FP_REGS */\t\\\n-  { 0xFFFFFFFF, 0x0001FFFF }, /* ALL_REGS\t*/\t\\\n-}\n+#define REG_CLASS_CONTENTS\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+/* NO_REGS:  */\t\t\t\t\t\t\t\t\\\n+  { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t\\\n+/* R0_REGS:  */\t\t\t\t\t\t\t\t\\\n+  { 0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t\\\n+/* PR_REGS:  */\t\t\t\t\t\t\t\t\\\n+  { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00040000 },\t\\\n+/* T_REGS:  */\t\t\t\t\t\t\t\t\\\n+  { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00080000 },\t\\\n+/* MAC_REGS:  */\t\t\t\t\t\t\t\\\n+  { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00300000 },\t\\\n+/* FPUL_REGS:  */\t\t\t\t\t\t\t\\\n+  { 0x00000000, 0x00000000, 0x00000000, 0x00000001, 0x00400000 },\t\\\n+/* SIBCALL_REGS: Initialized in CONDITIONAL_REGISTER_USAGE.  */\t\\\n+  { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t\\\n+/* GENERAL_REGS:  */\t\t\t\t\t\t\t\\\n+  { 0xffffffff, 0xffffffff, 0x00000000, 0x00000000, 0x01020000 },\t\\\n+/* FP0_REGS:  */\t\t\t\t\t\t\t\\\n+  { 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000000 },\t\\\n+/* FP_REGS:  */\t\t\t\t\t\t\t\t\\\n+  { 0x00000000, 0x00000000, 0xffffffff, 0xffffffff, 0x00000000 },\t\\\n+/* DF_REGS:  */\t\t\t\t\t\t\t\t\\\n+  { 0x00000000, 0x00000000, 0xffffffff, 0xffffffff, 0x0000ff00 },\t\\\n+/* FPSCR_REGS:  */\t\t\t\t\t\t\t\\\n+  { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00800000 },\t\\\n+/* GENERAL_FP_REGS:  */\t\t\t\t\t\t\t\\\n+  { 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x0102ff00 },\t\\\n+/* TARGET_REGS:  */\t\t\t\t\t\t\t\\\n+  { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x000000ff },\t\\\n+/* ALL_REGS:  */\t\t\t\t\t\t\t\\\n+  { 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x01ffffff },\t\\\n+}\t\t\t\t\t\t\t\t\t \n \n /* The same information, inverted:\n    Return the class number of the smallest class containing\n@@ -811,20 +1124,36 @@ extern int regno_reg_class[FIRST_PSEUDO_REGISTER];\n    rtl to be used as spill registers but prevents the compiler from\n    extending the lifetime of these registers.  */\n \n-#define SMALL_REGISTER_CLASSES 1\n+#define SMALL_REGISTER_CLASSES (! TARGET_SHMEDIA)\n \n /* The order in which register should be allocated.  */\n /* Sometimes FP0_REGS becomes the preferred class of a floating point pseudo,\n    and GENERAL_FP_REGS the alternate class.  Since FP0 is likely to be\n    spilled or used otherwise, we better have the FP_REGS allocated first.  */\n #define REG_ALLOC_ORDER \\\n-  { 25,26,27,28,29,30,31,24,32,33,34,35,36,37,38,39,\t\\\n-    40,41,42,43,44,45,46,47,48,\t\t\t\t\\\n-    1,2,3,7,6,5,4,0,8,9,10,11,12,13,14,\t\t\t\\\n-    22,15,16,17,18,19,20,21,23 }\n+  { 65, 66, 67, 68, 69, 70, 71, 64, \\\n+    72, 73, 74, 75, 76, 77, 78, 79, \\\n+   136,137,138,139,140,141,142,143, \\\n+    80, 81, 82, 83, 84, 85, 86, 87, \\\n+    88, 89, 90, 91, 92, 93, 94, 95, \\\n+    96, 97, 98, 99,100,101,102,103, \\\n+   104,105,106,107,108,109,110,111, \\\n+   112,113,114,115,116,117,118,119, \\\n+   120,121,122,123,124,125,126,127, \\\n+   151,  1,  2,  3,  7,  6,  5,  4, \\\n+     0,  8,  9, 10, 11, 12, 13, 14, \\\n+    16, 17, 18, 19, 20, 21, 22, 23, \\\n+    24, 25, 26, 27, 28, 29, 30, 31, \\\n+    32, 33, 34, 35, 36, 37, 38, 39, \\\n+    40, 41, 42, 43, 44, 45, 46, 47, \\\n+    48, 49, 50, 51, 52, 53, 54, 55, \\\n+    56, 57, 58, 59, 60, 61, 62, 63, \\\n+   150, 15,145,146,147,144,148,149, \\\n+   128,129,130,131,132,133,134,135, \\\n+   152 }\n \n /* The class value for index registers, and the one for base regs.  */\n-#define INDEX_REG_CLASS  R0_REGS\n+#define INDEX_REG_CLASS  (TARGET_SHMEDIA ? GENERAL_REGS : R0_REGS)\n #define BASE_REG_CLASS\t GENERAL_REGS\n \n /* Get reg_class from a letter such as appears in the machine\n@@ -840,24 +1169,37 @@ extern const enum reg_class reg_class_from_letter[];\n    C is the letter, and VALUE is a constant value.\n    Return 1 if VALUE is in the range specified by C.\n \tI: arithmetic operand -127..128, as used in add, sub, etc\n+\tJ: arithmetic operand -32768..32767, as used in SHmedia movi and shori\n \tK: shift operand 1,2,8 or 16\n \tL: logical operand 0..255, as used in and, or, etc.\n \tM: constant 1\n-\tN: constant 0  */\n+\tN: constant 0\n+\tO: arithmetic operand -32..31, as used in SHmedia beqi, bnei and xori\n+\tP: arithmetic operand -512..511, as used in SHmedia andi, ori\n+*/\n \n #define CONST_OK_FOR_I(VALUE) (((HOST_WIDE_INT)(VALUE))>= -128 \\\n \t\t\t       && ((HOST_WIDE_INT)(VALUE)) <= 127)\n+#define CONST_OK_FOR_J(VALUE) (((HOST_WIDE_INT)(VALUE)) >= -32768 \\\n+\t\t\t       && ((HOST_WIDE_INT)(VALUE)) <= 32767)\n #define CONST_OK_FOR_K(VALUE) ((VALUE)==1||(VALUE)==2||(VALUE)==8||(VALUE)==16)\n #define CONST_OK_FOR_L(VALUE) (((HOST_WIDE_INT)(VALUE))>= 0 \\\n \t\t\t       && ((HOST_WIDE_INT)(VALUE)) <= 255)\n #define CONST_OK_FOR_M(VALUE) ((VALUE)==1)\n #define CONST_OK_FOR_N(VALUE) ((VALUE)==0)\n+#define CONST_OK_FOR_O(VALUE) (((HOST_WIDE_INT)(VALUE)) >= -32 \\\n+\t\t\t       && ((HOST_WIDE_INT)(VALUE)) <= 31)\n+#define CONST_OK_FOR_P(VALUE) (((HOST_WIDE_INT)(VALUE)) >= -512 \\\n+\t\t\t       && ((HOST_WIDE_INT)(VALUE)) <= 511)\n #define CONST_OK_FOR_LETTER_P(VALUE, C)\t\t\\\n      ((C) == 'I' ? CONST_OK_FOR_I (VALUE)\t\\\n+    : (C) == 'J' ? CONST_OK_FOR_J (VALUE)\t\\\n     : (C) == 'K' ? CONST_OK_FOR_K (VALUE)\t\\\n     : (C) == 'L' ? CONST_OK_FOR_L (VALUE)\t\\\n     : (C) == 'M' ? CONST_OK_FOR_M (VALUE)\t\\\n     : (C) == 'N' ? CONST_OK_FOR_N (VALUE)\t\\\n+    : (C) == 'O' ? CONST_OK_FOR_O (VALUE)\t\\\n+    : (C) == 'P' ? CONST_OK_FOR_P (VALUE)\t\\\n     : 0)\n \n /* Similar, but for floating constants, and defining letters G and H.\n@@ -873,7 +1215,12 @@ extern const enum reg_class reg_class_from_letter[];\n    In general this is just CLASS; but on some machines\n    in some cases it is preferable to use a more restrictive class.  */\n \n-#define PREFERRED_RELOAD_CLASS(X, CLASS) (CLASS)\n+#define PREFERRED_RELOAD_CLASS(X, CLASS) \\\n+  ((CLASS) == NO_REGS && TARGET_SHMEDIA \\\n+   && (GET_CODE (X) == CONST_DOUBLE \\\n+       || GET_CODE (X) == SYMBOL_REF) \\\n+   ? GENERAL_REGS \\\n+   : (CLASS)) \\\n \n #define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS,MODE,X) \\\n   ((((((CLASS) == FP_REGS || (CLASS) == FP0_REGS\t\t\t\\\n@@ -882,6 +1229,7 @@ extern const enum reg_class reg_class_from_letter[];\n      || (((CLASS) == GENERAL_REGS || (CLASS) == R0_REGS)\t\t\\\n \t && GET_CODE (X) == REG\t\t\t\t\t\t\\\n \t && FP_REGISTER_P (REGNO (X))))\t\t\t\t\t\\\n+    && ! TARGET_SHMEDIA\t\t\t\t\t\t\t\\\n     && MODE == SFmode)\t\t\t\t\t\t\t\\\n    ? FPUL_REGS\t\t\t\t\t\t\t\t\\\n    : ((CLASS) == FPUL_REGS\t\t\t\t\t\t\\\n@@ -891,13 +1239,22 @@ extern const enum reg_class reg_class_from_letter[];\n \t\t  || REGNO (X) == T_REG\t\t\t\t\t\\\n \t\t  || system_reg_operand (X, VOIDmode)))))\t\t\\\n    ? GENERAL_REGS\t\t\t\t\t\t\t\\\n+   : (((CLASS) == FP_REGS || (CLASS) == DF_REGS) && TARGET_SHMEDIA\t\\\n+      && immediate_operand ((X), (MODE)))\t\t\t\t\\\n+   ? GENERAL_REGS\t\t\t\t\t\t\t\\\n+   : ((CLASS) == TARGET_REGS\t\t\t\t\t\t\\\n+      || (TARGET_SHMEDIA && (CLASS) == SIBCALL_REGS))\t\t\t\\\n+   ? ((target_operand ((X), (MODE))\t\t\t\t\t\\\n+       && ! target_reg_operand ((X), (MODE)))\t\t\t\t\\\n+      ? NO_REGS : GENERAL_REGS)\t\t\t\t\t\t\\\n    : (((CLASS) == MAC_REGS || (CLASS) == PR_REGS)\t\t\t\\\n       && GET_CODE (X) == REG && ! GENERAL_REGISTER_P (REGNO (X))\t\\\n       && (CLASS) != REGNO_REG_CLASS (REGNO (X)))\t\t\t\\\n    ? GENERAL_REGS : NO_REGS)\n \n #define SECONDARY_INPUT_RELOAD_CLASS(CLASS,MODE,X)  \\\n   ((((CLASS) == FP_REGS || (CLASS) == FP0_REGS || (CLASS) == DF_REGS)\t\\\n+    && ! TARGET_SHMEDIA\t\t\t\t\t\t\t\\\n     && immediate_operand ((X), (MODE))\t\t\t\t\t\\\n     && ! ((fp_zero_operand (X) || fp_one_operand (X))\t\t\t\\\n \t  && (MODE) == SFmode && fldi_ok ()))\t\t\t\t\\\n@@ -940,17 +1297,17 @@ extern const enum reg_class reg_class_from_letter[];\n    These macros are used only in other macro definitions below.  */\n \n #define NPARM_REGS(MODE) \\\n-  (TARGET_SH3E && (MODE) == SFmode \\\n-   ? 8 \\\n+  (TARGET_FPU_ANY && (MODE) == SFmode \\\n+   ? (TARGET_SH5 ? 12 : 8) \\\n    : TARGET_SH4 && (GET_MODE_CLASS (MODE) == MODE_FLOAT \\\n \t\t    || GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT) \\\n-   ? 8 \\\n-   : 4)\n+   ? (TARGET_SH5 ? 12 : 8) \\\n+   : (TARGET_SH5 ? 8 : 4))\n \n-#define FIRST_PARM_REG (FIRST_GENERAL_REG + 4)\n-#define FIRST_RET_REG  FIRST_GENERAL_REG\n+#define FIRST_PARM_REG (FIRST_GENERAL_REG + (TARGET_SH5 ? 2 : 4))\n+#define FIRST_RET_REG  (FIRST_GENERAL_REG + (TARGET_SH5 ? 2 : 0))\n \n-#define FIRST_FP_PARM_REG (FIRST_FP_REG + 4)\n+#define FIRST_FP_PARM_REG (FIRST_FP_REG + (TARGET_SH5 ? 0 : 4))\n #define FIRST_FP_RET_REG FIRST_FP_REG\n \n /* Define this if pushing a word on the stack\n@@ -990,6 +1347,13 @@ extern const enum reg_class reg_class_from_letter[];\n    on the stack.  */\n #define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE)  0\n \n+/* Value is the number of bytes of arguments automatically popped when\n+   calling a subroutine.\n+   CUM is the accumulated argument list.\n+\n+   On SHcompact, the call trampoline pops arguments off the stack.  */\n+#define CALL_POPS_ARGS(CUM) (TARGET_SHCOMPACT ? (CUM).stack_regs * 8 : 0)\n+\n /* Nonzero if we do not know how to pass TYPE solely in registers.\n    Values that come in registers with inconvenient padding are stored\n    to memory at the function start.  */\n@@ -1001,11 +1365,11 @@ extern const enum reg_class reg_class_from_letter[];\n /* Some subroutine macros specific to this machine.  */\n \n #define BASE_RETURN_VALUE_REG(MODE) \\\n-  ((TARGET_SH3E && ((MODE) == SFmode))\t\t\t\\\n+  ((TARGET_FPU_ANY && ((MODE) == SFmode))\t\t\t\\\n    ? FIRST_FP_RET_REG\t\t\t\t\t\\\n-   : TARGET_SH3E && (MODE) == SCmode\t\t\\\n+   : TARGET_FPU_ANY && (MODE) == SCmode\t\t\\\n    ? FIRST_FP_RET_REG\t\t\t\t\t\\\n-   : (TARGET_SH4\t\t\t\t\t\\\n+   : (TARGET_FPU_DOUBLE\t\t\t\t\t\\\n       && ((MODE) == DFmode || (MODE) == SFmode\t\t\\\n \t  || (MODE) == DCmode || (MODE) == SCmode ))\t\\\n    ? FIRST_FP_RET_REG\t\t\t\t\t\\\n@@ -1038,7 +1402,7 @@ extern const enum reg_class reg_class_from_letter[];\n \t\t || TREE_CODE (VALTYPE) == CHAR_TYPE\t\t\t\\\n \t\t || TREE_CODE (VALTYPE) == REAL_TYPE\t\t\t\\\n \t\t || TREE_CODE (VALTYPE) == OFFSET_TYPE))\t\t\\\n-\t    ? SImode : TYPE_MODE (VALTYPE)),\t\t\t\t\\\n+\t    ? (TARGET_SHMEDIA ? DImode : SImode) : TYPE_MODE (VALTYPE)), \\\n \t   BASE_RETURN_VALUE_REG (TYPE_MODE (VALTYPE)))\n      \n /* Define how to find the value returned by a library function\n@@ -1048,13 +1412,16 @@ extern const enum reg_class reg_class_from_letter[];\n \n /* 1 if N is a possible register number for a function value.  */\n #define FUNCTION_VALUE_REGNO_P(REGNO) \\\n-  ((REGNO) == FIRST_RET_REG || (TARGET_SH3E && (REGNO) == FIRST_FP_RET_REG))\n+  ((REGNO) == FIRST_RET_REG || (TARGET_SH3E && (REGNO) == FIRST_FP_RET_REG) \\\n+   || (TARGET_SHMEDIA_FPU && (REGNO) == FIRST_FP_RET_REG))\n \n /* 1 if N is a possible register number for function argument passing.  */\n #define FUNCTION_ARG_REGNO_P(REGNO) \\\n-  (((REGNO) >= FIRST_PARM_REG && (REGNO) < (FIRST_PARM_REG + 4))        \\\n-   || (TARGET_SH3E                                                      \\\n-       && (REGNO) >= FIRST_FP_PARM_REG && (REGNO) < (FIRST_FP_PARM_REG + 8)))\n+  (((REGNO) >= FIRST_PARM_REG && (REGNO) < (FIRST_PARM_REG\t\t\\\n+\t\t\t\t\t    + NPARM_REGS (SImode))\t\\\n+   || (TARGET_FPU_ANY                                                   \\\n+       && (REGNO) >= FIRST_FP_PARM_REG && (REGNO) < (FIRST_FP_PARM_REG\t\\\n+\t\t\t\t\t\t     + NPARM_REGS (SFmode)))))\n \f\n /* Define a data type for recording info about an argument list\n    during the scan of that argument list.  This data type should\n@@ -1071,15 +1438,112 @@ enum sh_arg_class { SH_ARG_INT = 0, SH_ARG_FLOAT = 1 };\n struct sh_args {\n     int arg_count[2];\n     int force_mem;\n+  /* Non-zero if a prototype is available for the function.  */\n+    int prototype_p;\n+  /* The number of an odd floating-point register, that should be used\n+     for the next argument of type float.  */\n+    int free_single_fp_reg;\n+  /* Whether we're processing an outgoing function call.  */\n+    int outgoing;\n+  /* The number of general-purpose registers that should have been\n+     used to pass partial arguments, that are passed totally on the\n+     stack.  On SHcompact, a call trampoline will pop them off the\n+     stack before calling the actual function, and, if the called\n+     function is implemented in SHcompact mode, the incoming arguments\n+     decoder will push such arguments back onto the stack.  For\n+     incoming arguments, STACK_REGS also takes into account other\n+     arguments passed by reference, that the decoder will also push\n+     onto the stack.  */\n+    int stack_regs;\n+  /* The number of general-purpose registers that should have been\n+     used to pass arguments, if the arguments didn't have to be passed\n+     by reference.  */\n+    int byref_regs;\n+  /* Set by SHCOMPACT_BYREF if the current argument is to be passed by\n+     reference.  */\n+    int byref;\n+\n+  /* call_cookie is a bitmask used by call expanders, as well as\n+     function prologue and epilogues, to allow SHcompact to comply\n+     with the SH5 32-bit ABI, that requires 64-bit registers to be\n+     used even though only the lower 32-bit half is visible in\n+     SHcompact mode.  The strategy is to call SHmedia trampolines.\n+\n+     The alternatives for each of the argument-passing registers are\n+     (a) leave it unchanged; (b) pop it off the stack; (c) load its\n+     contents from the address in it; (d) add 8 to it, storing the\n+     result in the next register, then (c); (e) copy it from some\n+     floating-point register,\n+\n+     Regarding copies from floating-point registers, r2 may only be\n+     copied from dr0.  r3 may be copied from dr0 or dr2.  r4 maybe\n+     copied from dr0, dr2 or dr4.  r5 maybe copied from dr0, dr2,\n+     dr4 or dr6.  r6 may be copied from dr0, dr2, dr4, dr6 or dr8.\n+     r7 through to r9 may be copied from dr0, dr2, dr4, dr8, dr8 or\n+     dr10.\n+\n+     The bit mask is structured as follows:\n+\n+     - 1 bit to tell whether to set up a return trampoline.\n+\n+     - 3 bits to count the number consecutive registers to pop off the\n+       stack.\n+\n+     - 4 bits for each of r9, r8, r7 and r6.\n+\n+     - 3 bits for each of r5, r4, r3 and r2.\n+\n+     - 3 bits set to 0 (the most significant ones)\n+\n+        3           2            1           0\n+       1098 7654 3210 9876 5432 1098 7654 3210\n+       FLPF LPFL PFLP FFLP FFLP FFLP FFLP SSST\n+       2223 3344 4555 6666 7777 8888 9999 SSS-\n+\n+     - If F is set, the register must be copied from an FP register,\n+       whose number is encoded in the remaining bits.\n+\n+     - Else, if L is set, the register must be loaded from the address\n+       contained in it.  If the P bit is *not* set, the address of the\n+       following dword should be computed first, and stored in the\n+       following register.\n+\n+     - Else, if P is set, the register alone should be popped off the\n+       stack.\n+\n+     - After all this processing, the number of registers represented\n+       in SSS will be popped off the stack.  This is an optimization\n+       for pushing/popping consecutive registers, typically used for\n+       varargs and large arguments partially passed in registers.\n+\n+     - If T is set, a return trampoline will be set up for 64-bit\n+     return values to be split into 2 32-bit registers.  */\n+#define CALL_COOKIE_RET_TRAMP_SHIFT 0\n+#define CALL_COOKIE_RET_TRAMP(VAL) ((VAL) << CALL_COOKIE_RET_TRAMP_SHIFT)\n+#define CALL_COOKIE_STACKSEQ_SHIFT 1\n+#define CALL_COOKIE_STACKSEQ(VAL) ((VAL) << CALL_COOKIE_STACKSEQ_SHIFT)\n+#define CALL_COOKIE_STACKSEQ_GET(COOKIE) \\\n+  (((COOKIE) >> CALL_COOKIE_STACKSEQ_SHIFT) & 7)\n+#define CALL_COOKIE_INT_REG_SHIFT(REG) \\\n+  (4 * (7 - (REG)) + (((REG) <= 2) ? ((REG) - 2) : 1) + 3)\n+#define CALL_COOKIE_INT_REG(REG, VAL) \\\n+  ((VAL) << CALL_COOKIE_INT_REG_SHIFT (REG))\n+#define CALL_COOKIE_INT_REG_GET(COOKIE, REG) \\\n+  (((COOKIE) >> CALL_COOKIE_INT_REG_SHIFT (REG)) & ((REG) < 4 ? 7 : 15))\n+    long call_cookie;\n };\n \n #define CUMULATIVE_ARGS  struct sh_args\n \n #define GET_SH_ARG_CLASS(MODE) \\\n-  ((TARGET_SH3E && (MODE) == SFmode) \\\n+  ((TARGET_FPU_ANY && (MODE) == SFmode) \\\n    ? SH_ARG_FLOAT \\\n-   : TARGET_SH4 && (GET_MODE_CLASS (MODE) == MODE_FLOAT \\\n-\t\t    || GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT) \\\n+   /* There's no mention of complex float types in the SH5 ABI, so we\n+      should presumably handle them as aggregate types.  */ \\\n+   : TARGET_SH5 && GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT \\\n+   ? SH_ARG_INT \\\n+   : TARGET_FPU_DOUBLE && (GET_MODE_CLASS (MODE) == MODE_FLOAT \\\n+\t\t\t   || GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT) \\\n    ? SH_ARG_FLOAT : SH_ARG_INT)\n \n #define ROUND_ADVANCE(SIZE) \\\n@@ -1116,7 +1580,48 @@ struct sh_args {\n     (CUM).force_mem\t\t\t\t\t\t\\\n       = (TARGET_HITACHI && FNTYPE\t\t\t\t\\\n \t && aggregate_value_p (TREE_TYPE (FNTYPE)));\t\t\\\n+    (CUM).prototype_p = (FNTYPE) && TYPE_ARG_TYPES (FNTYPE);\t\\\n+    (CUM).arg_count[(int) SH_ARG_INT]\t\t\t\t\\\n+      = (TARGET_SH5 && (FNTYPE)\t\t\t\t\t\\\n+\t && aggregate_value_p (TREE_TYPE (FNTYPE)));\t\t\\\n+    (CUM).free_single_fp_reg = 0;\t\t\t\t\\\n+    (CUM).outgoing = 1;\t\t\t\t\t\t\\\n+    (CUM).stack_regs = 0;\t\t\t\t\t\\\n+    (CUM).byref_regs = 0;\t\t\t\t\t\\\n+    (CUM).byref = 0;\t\t\t\t\t\t\\\n+    (CUM).call_cookie\t\t\t\t\t\t\\\n+      = (CALL_COOKIE_RET_TRAMP\t\t\t\t\t\\\n+\t (TARGET_SHCOMPACT && (FNTYPE)\t\t\t\t\\\n+\t  && (CUM).arg_count[(int) SH_ARG_INT] == 0\t\t\\\n+\t  && (TYPE_MODE (TREE_TYPE (FNTYPE)) == BLKmode\t\t\\\n+\t      ? int_size_in_bytes (TREE_TYPE (FNTYPE))\t\t\\\n+\t      : GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (FNTYPE)))) > 4 \\\n+\t  && (BASE_RETURN_VALUE_REG (TYPE_MODE (TREE_TYPE\t\\\n+ \t\t\t\t\t\t(FNTYPE)))\t\\\n+\t      == FIRST_RET_REG)));\t\t\t\t\\\n+  } while (0)\n+\n+#define INIT_CUMULATIVE_LIBCALL_ARGS(CUM, MODE, LIBNAME) \\\n+  do {\t\t\t\t\t\t\t\t\\\n+    INIT_CUMULATIVE_ARGS ((CUM), NULL_TREE, (LIBNAME), 0);\t\\\n+    (CUM).call_cookie\t\t\t\t\t\t\\\n+      = (CALL_COOKIE_RET_TRAMP\t\t\t\t\t\\\n+\t (TARGET_SHCOMPACT && GET_MODE_SIZE (MODE) > 4\t\t\\\n+\t  && BASE_RETURN_VALUE_REG (MODE) == FIRST_RET_REG));\t\\\n+  } while (0)\n+\n+#define INIT_CUMULATIVE_INCOMING_ARGS(CUM, FNTYPE, LIBNAME) \\\n+  do {\t\t\t\t\t\t\t\t\\\n+    INIT_CUMULATIVE_ARGS ((CUM), (FNTYPE), (LIBNAME), 0);\t\\\n+    (CUM).outgoing = 0;\t\t\t\t\t\t\\\n   } while (0)\n+ \n+/* FIXME: This is overly conservative.  A SHcompact function that\n+   receives arguments ``by reference'' will have them stored in its\n+   own stack frame, so it must not pass pointers or references to\n+   these arguments to other functions by means of sibling calls.  */\n+#define FUNCTION_OK_FOR_SIBCALL(DECL) \\\n+  (! TARGET_SHCOMPACT || current_function_args_info.stack_regs == 0)\n \n /* Update the data in CUM to advance over an argument\n    of mode MODE and data type TYPE.\n@@ -1126,6 +1631,109 @@ struct sh_args {\n #define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n  if ((CUM).force_mem)\t\t\t\t\t\\\n    (CUM).force_mem = 0;\t\t\t\t\t\\\n+ else if (TARGET_SH5)\t\t\t\t\t\\\n+   {\t\t\t\t\t\t\t\\\n+     tree TYPE_ = ((CUM).byref && (TYPE)\t\t\\\n+\t\t   ? TREE_TYPE (TYPE)\t\t\t\\\n+ \t\t   : (TYPE));\t\t\t\t\\\n+     enum machine_mode MODE_ = ((CUM).byref && (TYPE)\t\\\n+\t\t\t\t? TYPE_MODE (TYPE_)\t\\\n+\t\t\t\t: (MODE));\t\t\\\n+     int dwords = (((CUM).byref\t\t\t\t\\\n+\t\t    ? (CUM).byref\t\t\t\\\n+\t\t    : (MODE_) == BLKmode\t\t\\\n+\t\t    ? int_size_in_bytes (TYPE_)\t\t\\\n+\t\t    : GET_MODE_SIZE (MODE_)) + 7) / 8;\t\\\n+     int numregs = MIN (dwords, NPARM_REGS (SImode)\t\\\n+\t\t\t- (CUM).arg_count[(int) SH_ARG_INT]); \\\n+\t\t\t\t\t\t\t\\\n+     if (numregs)\t\t\t\t\t\\\n+       {\t\t\t\t\t\t\\\n+\t (CUM).arg_count[(int) SH_ARG_INT] += numregs;\t\\\n+\t if (TARGET_SHCOMPACT\t\t\t\t\\\n+\t     && SHCOMPACT_FORCE_ON_STACK (MODE_, TYPE_)) \\\n+\t   (CUM).call_cookie \t\t\t\t\\\n+\t     |= CALL_COOKIE_INT_REG (((CUM).arg_count[(int) SH_ARG_INT] \\\n+\t\t\t\t      - numregs), 1);\t\\\n+\t else if ((CUM).byref)\t\t\t\t\\\n+\t   {\t\t\t\t\t\t\\\n+\t     if (! (CUM).outgoing)\t\t\t\\\n+\t       (CUM).stack_regs += numregs;\t\t\\\n+\t     (CUM).byref_regs += numregs;\t\t\\\n+\t     (CUM).byref = 0;\t\t\t\t\\\n+\t     do\t\t\t\t\t\t\\\n+\t       (CUM).call_cookie\t\t\t\\\n+\t\t |= CALL_COOKIE_INT_REG (((CUM).arg_count[(int) SH_ARG_INT] \\\n+\t\t\t\t\t  - numregs), 2); \\\n+\t     while (--numregs);\t\t\t\t\\\n+\t     (CUM).call_cookie\t\t\t\t\\\n+\t       |= CALL_COOKIE_INT_REG (((CUM).arg_count[(int) SH_ARG_INT] \\\n+\t\t\t\t        - 1), 1); \\\n+\t   }\t\t\t\t\t\t\\\n+\t else if (dwords > numregs)\t\t\t\\\n+\t   {\t\t\t\t\t\t\\\n+\t     int pushregs = numregs;\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+\t     if (TARGET_SHCOMPACT)\t\t\t\\\n+\t       (CUM).stack_regs += numregs;\t\t\\\n+\t     while (pushregs < NPARM_REGS (SImode) - 1\t\\\n+\t\t    && (CALL_COOKIE_INT_REG_GET\t\t\\\n+\t\t\t((CUM).call_cookie,\t\t\\\n+\t\t\tNPARM_REGS (SImode) - pushregs) \\\n+\t\t\t== 1))\t\t\t\t\\\n+\t       {\t\t\t\t\t\\\n+\t\t (CUM).call_cookie\t\t\t\\\n+\t\t   &= ~ CALL_COOKIE_INT_REG (NPARM_REGS (SImode) \\\n+\t\t\t\t\t     - pushregs, 1); \\\n+\t\t pushregs++;\t\t\t\t\\\n+\t       }\t\t\t\t\t\\\n+\t     if (numregs == NPARM_REGS (SImode))\t\\\n+\t       (CUM).call_cookie \t\t\t\\\n+\t\t |= CALL_COOKIE_INT_REG (0, 1)\t\t\\\n+\t\t    | CALL_COOKIE_STACKSEQ (numregs - 1); \\\n+\t     else\t\t\t\t\t\\\n+\t       (CUM).call_cookie\t\t\t\\\n+\t\t |= CALL_COOKIE_STACKSEQ (numregs);\t\\\n+\t   }\t\t\t\t\t\t\\\n+       }\t\t\t\t\t\t\\\n+     if (GET_SH_ARG_CLASS (MODE_) == SH_ARG_FLOAT\t\\\n+\t && ((NAMED) || ! (CUM).prototype_p))\t\t\\\n+       {\t\t\t\t\t\t\\\n+\t if ((MODE_) == SFmode && (CUM).free_single_fp_reg) \\\n+\t   (CUM).free_single_fp_reg = 0;\t\t\\\n+\t else if ((CUM).arg_count[(int) SH_ARG_FLOAT]\t\\\n+ \t\t  < NPARM_REGS (SFmode))\t\t\\\n+\t   {\t\t\t\t\t        \\\n+\t     int numfpregs\t\t \t\t\\\n+\t       = MIN ((GET_MODE_SIZE (MODE_) + 7) / 8 * 2, \\\n+\t\t      NPARM_REGS (SFmode)\t\t\\\n+\t\t      - (CUM).arg_count[(int) SH_ARG_FLOAT]); \\\n+\t\t \t\t\t\t\t\\\n+\t     (CUM).arg_count[(int) SH_ARG_FLOAT] += numfpregs; \\\n+\t\t\t\t\t\t\t\\\n+\t     if (TARGET_SHCOMPACT && ! (CUM).prototype_p) \\\n+\t       {\t\t\t\t\t\\\n+\t\t if ((CUM).outgoing && numregs > 0)\t\\\n+\t\t   do\t\t\t\t\t\\\n+\t\t     {\t\t\t\t\t\\\n+\t\t       (CUM).call_cookie\t\t\\\n+\t\t\t |= (CALL_COOKIE_INT_REG\t\\\n+\t\t\t     ((CUM).arg_count[(int) SH_ARG_INT] \\\n+\t\t\t      - numregs + ((numfpregs - 2) / 2), \\\n+\t\t\t      4 + ((CUM).arg_count[(int) SH_ARG_FLOAT] \\\n+\t\t\t\t   - numfpregs) / 2));\t\\\n+\t\t     }\t\t\t\t\t\\\n+\t\t   while (numfpregs -= 2);\t\t\\\n+\t       }\t\t\t\t\t\\\n+\t     else if ((MODE_) == SFmode && (NAMED)\t\\\n+\t\t      && ((CUM).arg_count[(int) SH_ARG_FLOAT] \\\n+\t\t\t  < NPARM_REGS (SFmode)))\t\\\n+\t       (CUM).free_single_fp_reg\t\t\t\\\n+\t\t = FIRST_FP_PARM_REG - numfpregs\t\\\n+\t\t + (CUM).arg_count[(int) SH_ARG_FLOAT] + 1; \\\n+\t   }\t\t\t\t\t\t\\\n+       }\t\t\t\t\t\t\\\n+   }\t\t\t\t\t\t\t\\\n  else if (! TARGET_SH4 || PASS_IN_REG_P ((CUM), (MODE), (TYPE))) \\\n    ((CUM).arg_count[(int) GET_SH_ARG_CLASS (MODE)]\t\\\n     = (ROUND_REG ((CUM), (MODE))\t\t\t\\\n@@ -1170,16 +1778,136 @@ struct sh_args {\n    its data type forbids.  */\n \n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n-  ((PASS_IN_REG_P ((CUM), (MODE), (TYPE))\t\t\t\t\\\n+  ((! TARGET_SH5 \\\n+    && PASS_IN_REG_P ((CUM), (MODE), (TYPE))\t\t\t\t\\\n     && ((NAMED)\t\t\t\t\t\t\t\t\\\n \t|| (! TARGET_HITACHI && (TARGET_SH3E || ! current_function_varargs)))) \\\n    ? gen_rtx_REG ((MODE),\t\t\t\t\t\t\\\n \t\t  ((BASE_ARG_REG (MODE) + ROUND_REG ((CUM), (MODE))) \t\\\n \t\t   ^ ((MODE) == SFmode && TARGET_SH4\t\t\t\\\n \t\t      && TARGET_LITTLE_ENDIAN != 0)))\t\t\t\\\n+   : TARGET_SH5\t\t\t\t\t\t\t\t\\\n+   ? ((MODE) == VOIDmode && TARGET_SHCOMPACT\t\t\t\t\\\n+      ? GEN_INT ((CUM).call_cookie)\t\t\t\t\t\\\n+      /* The following test assumes unnamed arguments are promoted to\t\\\n+\t DFmode.  */\t\t\t\t\t\t\t\\\n+      : (MODE) == SFmode && (CUM).free_single_fp_reg\t\t\t\\\n+      ? SH5_PROTOTYPED_FLOAT_ARG ((CUM), (MODE), (CUM).free_single_fp_reg) \\\n+      : (GET_SH_ARG_CLASS (MODE) == SH_ARG_FLOAT\t\t\t\\\n+         && ((NAMED) || ! (CUM).prototype_p)\t\t\t\t\\\n+         && (CUM).arg_count[(int) SH_ARG_FLOAT] < NPARM_REGS (SFmode))\t\\\n+      ? ((! (CUM).prototype_p && TARGET_SHMEDIA)\t\t\t\\\n+\t ? SH5_PROTOTYPELESS_FLOAT_ARG ((CUM), (MODE))\t\t\t\\\n+\t : SH5_PROTOTYPED_FLOAT_ARG ((CUM), (MODE),\t\t\t\\\n+\t\t\t\t     FIRST_FP_PARM_REG\t\t\t\\\n+\t\t\t\t     + (CUM).arg_count[(int) SH_ARG_FLOAT])) \\\n+      : ((CUM).arg_count[(int) SH_ARG_INT] < NPARM_REGS (SImode)\t\\\n+\t && (! TARGET_SHCOMPACT\t\t\t\t\t\t\\\n+\t     || (! SHCOMPACT_FORCE_ON_STACK ((MODE), (TYPE))\t\t\\\n+\t         && ! SH5_WOULD_BE_PARTIAL_NREGS ((CUM), (MODE),\t\\\n+\t\t\t\t\t\t  (TYPE), (NAMED)))))\t\\\n+      ? gen_rtx_REG ((MODE), (FIRST_PARM_REG\t\t\t\t\\\n+ \t\t\t      + (CUM).arg_count[(int) SH_ARG_INT]))\t\\\n+      : 0)\t\t\t\t\t\t\t\t\\\n    : 0)\n \n-#define PRETEND_OUTGOING_VARARGS_NAMED (! TARGET_HITACHI)\n+/* Whether an argument must be passed by reference.  On SHcompact, we\n+   pretend arguments wider than 32-bits that would have been passed in\n+   registers are passed by reference, so that an SHmedia trampoline\n+   loads them into the full 64-bits registers.  */\n+#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM,MODE,TYPE,NAMED) \\\n+  (MUST_PASS_IN_STACK ((MODE), (TYPE)) \\\n+   || SHCOMPACT_BYREF ((CUM), (MODE), (TYPE), (NAMED)))\n+\n+#define SHCOMPACT_BYREF(CUM, MODE, TYPE, NAMED) \\\n+  ((CUM).byref\t\t\t\t\t\t\t\t\\\n+   = (TARGET_SHCOMPACT\t\t\t\t\t\t\t\\\n+      && (CUM).arg_count[(int) SH_ARG_INT] < NPARM_REGS (SImode)\t\\\n+      && (! (NAMED) || GET_SH_ARG_CLASS (MODE) == SH_ARG_INT\t\t\\\n+\t  || (GET_SH_ARG_CLASS (MODE) == SH_ARG_FLOAT\t\t\t\\\n+\t      && ((CUM).arg_count[(int) SH_ARG_FLOAT]\t\t\t\\\n+ \t\t  >= NPARM_REGS (SFmode))))\t\t\t\t\\\n+      && ((MODE) == BLKmode ? int_size_in_bytes (TYPE)\t\t\t\\\n+\t  : GET_MODE_SIZE (MODE)) > 4\t\t\t\t       \t\\\n+      && ! SHCOMPACT_FORCE_ON_STACK ((MODE), (TYPE))\t\t\t\\\n+      && ! SH5_WOULD_BE_PARTIAL_NREGS ((CUM), (MODE),\t\t\t\\\n+\t\t\t\t       (TYPE), (NAMED)))\t\t\\\n+      ? ((MODE) == BLKmode ? int_size_in_bytes (TYPE)\t\t\t\\\n+\t : GET_MODE_SIZE (MODE))\t\t\t\t\t\\\n+      : 0)\n+\n+/* If an argument of size 5, 6 or 7 bytes is to be passed in a 64-bit\n+   register in SHcompact mode, it must be padded in the most\n+   significant end.  This means that passing it by reference wouldn't\n+   pad properly on a big-endian machine.  In this particular case, we\n+   pass this argument on the stack, in a way that the call trampoline\n+   will load its value into the appropriate register.  */\n+#define SHCOMPACT_FORCE_ON_STACK(MODE,TYPE) \\\n+  ((MODE) == BLKmode \\\n+   && TARGET_SHCOMPACT \\\n+   && ! TARGET_LITTLE_ENDIAN \\\n+   && int_size_in_bytes (TYPE) > 4 \\\n+   && int_size_in_bytes (TYPE) < 8)\n+\n+/* Minimum alignment for an argument to be passed by callee-copy\n+   reference.  We need such arguments to be aligned to 8 byte\n+   boundaries, because they'll be loaded using quad loads.  */\n+#define SH_MIN_ALIGN_FOR_CALLEE_COPY (8 * BITS_PER_UNIT)\n+\n+#define FUNCTION_ARG_CALLEE_COPIES(CUM,MODE,TYPE,NAMED) \\\n+  ((CUM).outgoing\t\t\t\t\t\t\t\\\n+   && (((MODE) == BLKmode ? TYPE_ALIGN (TYPE)\t\t\t\t\\\n+\t: GET_MODE_ALIGNMENT (MODE))\t\t\t\t\t\\\n+       % SH_MIN_ALIGN_FOR_CALLEE_COPY == 0))\n+\n+/* The SH5 ABI requires floating-point arguments to be passed to\n+   functions without a prototype in both an FP register and a regular\n+   register or the stack.  When passing the argument in both FP and\n+   general-purpose registers, list the FP register first.  */\n+#define SH5_PROTOTYPELESS_FLOAT_ARG(CUM,MODE) \\\n+  (gen_rtx_PARALLEL\t\t\t\t\t\t\t\\\n+   ((MODE),\t\t\t\t\t\t\t\t\\\n+    gen_rtvec (2,\t\t\t\t\t\t\t\\\n+\t       gen_rtx_EXPR_LIST\t\t\t\t\t\\\n+\t       (VOIDmode,\t\t\t\t\t\t\\\n+\t\t((CUM).arg_count[(int) SH_ARG_INT] < NPARM_REGS (SImode) \\\n+\t\t ? gen_rtx_REG ((MODE), FIRST_FP_PARM_REG\t\t\\\n+\t\t\t\t+ (CUM).arg_count[(int) SH_ARG_FLOAT])\t\\\n+\t\t : NULL_RTX),\t\t\t\t\t\t\\\n+\t\tconst0_rtx),\t\t\t\t\t\t\\\n+\t       gen_rtx_EXPR_LIST\t\t\t\t\t\\\n+\t       (VOIDmode,\t\t\t\t\t\t\\\n+\t\t((CUM).arg_count[(int) SH_ARG_INT] < NPARM_REGS (SImode) \\\n+\t\t ? gen_rtx_REG ((MODE), FIRST_PARM_REG\t\t\t\\\n+\t\t\t\t+ (CUM).arg_count[(int) SH_ARG_INT])\t\\\n+\t\t : gen_rtx_REG ((MODE), FIRST_FP_PARM_REG\t\t\\\n+\t\t\t\t+ (CUM).arg_count[(int) SH_ARG_FLOAT])), \\\n+\t\tconst0_rtx))))\n+\n+/* The SH5 ABI requires regular registers or stack slots to be\n+   reserved for floating-point arguments.  Registers are taken care of\n+   in FUNCTION_ARG_ADVANCE, but stack slots must be reserved here.\n+   Unfortunately, there's no way to just reserve a stack slot, so\n+   we'll end up needlessly storing a copy of the argument in the\n+   stack.  For incoming arguments, however, the PARALLEL will be\n+   optimized to the register-only form, and the value in the stack\n+   slot won't be used at all.  */\n+#define SH5_PROTOTYPED_FLOAT_ARG(CUM,MODE,REG) \\\n+  ((CUM).arg_count[(int) SH_ARG_INT] < NPARM_REGS (SImode)\t\t\\\n+   ? gen_rtx_REG ((MODE), (REG))\t\t\t\t\t\\\n+   : gen_rtx_PARALLEL ((MODE),\t\t\t\t\t\t\\\n+\t\t       gen_rtvec (2,\t\t\t\t\t\\\n+\t\t\t\t  gen_rtx_EXPR_LIST\t\t\t\\\n+\t\t\t\t  (VOIDmode, NULL_RTX,\t\t\t\\\n+\t\t\t\t   const0_rtx),\t\t\t\t\\\n+\t\t\t\t  gen_rtx_EXPR_LIST\t\t\t\\\n+\t\t\t\t  (VOIDmode, gen_rtx_REG ((MODE),\t\\\n+\t\t\t\t\t\t\t  (REG)),\t\\\n+\t\t\t\t   const0_rtx))))\n+\n+#define STRICT_ARGUMENT_NAMING TARGET_SH5\n+\n+#define PRETEND_OUTGOING_VARARGS_NAMED (! TARGET_HITACHI && ! TARGET_SH5)\n \n /* For an arg passed partly in registers and partly in memory,\n    this is the number of registers used.\n@@ -1188,23 +1916,32 @@ struct sh_args {\n    We sometimes split args.  */\n \n #define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \\\n-  ((PASS_IN_REG_P ((CUM), (MODE), (TYPE))\t\t\t\\\n+  ((! TARGET_SH5 \\\n+    && PASS_IN_REG_P ((CUM), (MODE), (TYPE))\t\t\t\\\n     && ! TARGET_SH4\t\t\t\t\t\t\\\n     && (ROUND_REG ((CUM), (MODE))\t\t\t\t\\\n \t+ ((MODE) != BLKmode\t\t\t\t\t\\\n \t   ? ROUND_ADVANCE (GET_MODE_SIZE (MODE))\t\t\\\n \t   : ROUND_ADVANCE (int_size_in_bytes (TYPE)))\t\t\\\n \t> NPARM_REGS (MODE)))\t\t\t\t\t\\\n    ? NPARM_REGS (MODE) - ROUND_REG ((CUM), (MODE))\t\t\\\n+   : (SH5_WOULD_BE_PARTIAL_NREGS ((CUM), (MODE), (TYPE), (NAMED)) \\\n+      && ! TARGET_SHCOMPACT)\t\t\t\t\t\\\n+   ? NPARM_REGS (SImode) - (CUM).arg_count[(int) SH_ARG_INT]\t\\\n    : 0)\n \n+#define SH5_WOULD_BE_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \\\n+  (TARGET_SH5 && (MODE) == BLKmode\t\t\t\t\\\n+   && ((CUM).arg_count[(int) SH_ARG_INT]\t\t\t\\\n+       + (int_size_in_bytes (TYPE) + 7) / 8) > NPARM_REGS (SImode))\n+\n extern int current_function_anonymous_args;\n \n /* Perform any needed actions needed for a function that is receiving a\n    variable number of arguments.  */\n \n #define SETUP_INCOMING_VARARGS(ASF, MODE, TYPE, PAS, ST) \\\n-  current_function_anonymous_args = 1;\n+  current_function_anonymous_args = ! TARGET_SH5\n \n /* Define the `__builtin_va_list' type for the ABI.  */\n #define BUILD_VA_LIST_TYPE(VALIST) \\\n@@ -1254,7 +1991,7 @@ extern int current_function_anonymous_args;\n    6 000c 00000000 \tl2:\t.long   function  */\n \n /* Length in units of the trampoline for entering a nested function.  */\n-#define TRAMPOLINE_SIZE  16\n+#define TRAMPOLINE_SIZE  (TARGET_SHMEDIA64 ? 40 : TARGET_SH5 ? 32 : 16)\n \n /* Alignment required for a trampoline in bits .  */\n #define TRAMPOLINE_ALIGNMENT \\\n@@ -1266,6 +2003,27 @@ extern int current_function_anonymous_args;\n \n #define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT) do\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n+  if (TARGET_SH5)\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      rtx tramp_templ = gen_rtx_SYMBOL_REF (Pmode,\t\t\t\\\n+\t\t\t\t\t    \"__GCC_nested_trampoline\");\t\\\n+      int fixed_len = TRAMPOLINE_SIZE - 2 * GET_MODE_SIZE (Pmode);\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      tramp_templ = gen_datalabel_ref (tramp_templ);\t\t\t\\\n+      emit_block_move (gen_rtx_MEM (BLKmode, (TRAMP)),\t\t\t\\\n+\t\t       gen_rtx_MEM (BLKmode, tramp_templ),\t\t\\\n+\t\t       GEN_INT (fixed_len));\t\t\t\t\\\n+      emit_move_insn (gen_rtx_MEM (Pmode, plus_constant ((TRAMP),\t\\\n+\t\t\t\t\t\t\t fixed_len)),\t\\\n+\t\t      (FNADDR));\t\t\t\t\t\\\n+      emit_move_insn (gen_rtx_MEM (Pmode,\t\t\t\t\\\n+\t\t\t\t   plus_constant ((TRAMP),\t\t\\\n+\t\t\t\t\t\t  fixed_len\t\t\\\n+\t\t\t\t\t\t  + GET_MODE_SIZE (Pmode))), \\\n+\t\t      (CXT));\t\t\t\t\t\t\\\n+      emit_insn (gen_ic_invalidate_line (TRAMP));\t\t\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n   emit_move_insn (gen_rtx_MEM (SImode, (TRAMP)),\t\t\t\\\n                   GEN_INT (trunc_int_for_mode                  \t\t\\\n                          (TARGET_LITTLE_ENDIAN ? 0xd301d202 : 0xd202d301,\\\n@@ -1286,6 +2044,16 @@ extern int current_function_anonymous_args;\n     }\t\t\t\t\t\t\t\t\t\\\n } while (0)\n \n+/* On SH5, trampolines are SHmedia code, so add 1 to the address.  */\n+\n+#define TRAMPOLINE_ADJUST_ADDRESS(TRAMP) do\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (TARGET_SH5)\t\t\t\t\t\t\t\\\n+    (TRAMP) = expand_simple_binop (Pmode, PLUS, (TRAMP), GEN_INT (1),\t\\\n+\t\t\t\t   gen_reg_rtx (Pmode), 0,\t\t\\\n+\t\t\t\t   OPTAB_LIB_WIDEN);\t\t\t\\\n+} while (0)\n+\n /* A C expression whose value is RTL representing the value of the return\n    address for the frame COUNT steps up from the current frame.\n    FRAMEADDR is already the frame pointer of the COUNT frame, so we\n@@ -1300,17 +2068,17 @@ extern int current_function_anonymous_args;\n #define EXPAND_BUILTIN_SAVEREGS() sh_builtin_saveregs ()\n \f\n /* Addressing modes, and classification of registers for them.  */\n-#define HAVE_POST_INCREMENT  1\n+#define HAVE_POST_INCREMENT  TARGET_SH1\n /*#define HAVE_PRE_INCREMENT   1*/\n /*#define HAVE_POST_DECREMENT  1*/\n-#define HAVE_PRE_DECREMENT   1\n+#define HAVE_PRE_DECREMENT   TARGET_SH1\n \n #define USE_LOAD_POST_INCREMENT(mode)    ((mode == SImode || mode == DImode) \\\n-                                           ? 0 : 1)\n+                                           ? 0 : TARGET_SH1)\n #define USE_LOAD_PRE_DECREMENT(mode)     0\n #define USE_STORE_POST_INCREMENT(mode)   0\n #define USE_STORE_PRE_DECREMENT(mode)    ((mode == SImode || mode == DImode) \\\n-                                           ? 0 : 1)\n+                                           ? 0 : TARGET_SH1)\n \n #define MOVE_BY_PIECES_P(SIZE, ALIGN)  (move_by_pieces_ninsns (SIZE, ALIGN) \\\n                                         < (TARGET_SMALLCODE ? 2 :           \\\n@@ -1328,7 +2096,10 @@ extern int current_function_anonymous_args;\n   (GENERAL_OR_AP_REGISTER_P (REGNO) \\\n    || GENERAL_OR_AP_REGISTER_P (reg_renumber[(REGNO)]))\n #define REGNO_OK_FOR_INDEX_P(REGNO) \\\n-  ((REGNO) == R0_REG || (unsigned) reg_renumber[(REGNO)] == R0_REG)\n+  (TARGET_SHMEDIA \\\n+   ? (GENERAL_REGISTER_P (REGNO) \\\n+      || GENERAL_REGISTER_P ((unsigned) reg_renumber[(REGNO)])) \\\n+   : (REGNO) == R0_REG || (unsigned) reg_renumber[(REGNO)] == R0_REG)\n \n /* Maximum number of registers that can appear in a valid memory\n    address.  */\n@@ -1342,9 +2113,14 @@ extern int current_function_anonymous_args;\n /* Nonzero if the constant value X is a legitimate general operand.  */\n \n #define LEGITIMATE_CONSTANT_P(X) \\\n-  (GET_CODE (X) != CONST_DOUBLE\t\t\t\t\t\t\\\n-   || GET_MODE (X) == DFmode || GET_MODE (X) == SFmode\t\t\t\\\n-   || (TARGET_SH3E && (fp_zero_operand (X) || fp_one_operand (X))))\n+  (TARGET_SHMEDIA\t\t\t\t\t\t\t\\\n+   ? (GET_MODE (X) != DFmode\t\t\t\t\t\t\\\n+      || (X) == CONST0_RTX (GET_MODE (X))\t\t\t\t\\\n+      || ! TARGET_SHMEDIA_FPU\t\t\t\t\t\t\\\n+      || TARGET_SHMEDIA64)\t\t\t\t\t\t\\\n+   : (GET_CODE (X) != CONST_DOUBLE\t\t\t\t\t\\\n+      || GET_MODE (X) == DFmode || GET_MODE (X) == SFmode\t\t\\\n+      || (TARGET_SH3E && (fp_zero_operand (X) || fp_one_operand (X)))))\n \n /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n    and check its validity for a certain class.\n@@ -1363,12 +2139,14 @@ extern int current_function_anonymous_args;\n /* Nonzero if X is a hard reg that can be used as an index\n    or if it is a pseudo reg.  */\n #define REG_OK_FOR_INDEX_P(X) \\\n-  (REGNO (X) == R0_REG || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n+  ((TARGET_SHMEDIA ? GENERAL_REGISTER_P (REGNO (X)) \\\n+    : REGNO (X) == R0_REG) || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n \n /* Nonzero if X/OFFSET is a hard reg that can be used as an index\n    or if X is a pseudo reg.  */\n #define SUBREG_OK_FOR_INDEX_P(X, OFFSET) \\\n-  ((REGNO (X) == R0_REG && OFFSET == 0) || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n+  ((TARGET_SHMEDIA ? GENERAL_REGISTER_P (REGNO (X)) \\\n+    : REGNO (X) == R0_REG && OFFSET == 0) || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n \n #else\n \n@@ -1395,8 +2173,73 @@ extern int current_function_anonymous_args;\n \t   && GET_CODE (XEXP (XEXP (XEXP ((OP), 0), 0), 0)) == LABEL_REF \\\n \t   && GET_CODE (XEXP (XEXP (XEXP ((OP), 0), 0), 1)) == CONST_INT)))\n \n+/* The `S' constraint is a 16-bit constant, literal or symbolic.  */\n+#define EXTRA_CONSTRAINT_S(OP) \\\n+  (GET_CODE (OP) == CONST \\\n+   && GET_CODE (XEXP ((OP), 0)) == SIGN_EXTEND \\\n+   && GET_MODE (XEXP ((OP), 0)) == DImode \\\n+   && GET_CODE (XEXP (XEXP ((OP), 0), 0)) == TRUNCATE \\\n+   && GET_MODE (XEXP (XEXP ((OP), 0), 0)) == HImode \\\n+   && (MOVI_SHORI_BASE_OPERAND_P (XEXP (XEXP (XEXP ((OP), 0), 0), 0)) \\\n+       || (GET_CODE (XEXP (XEXP (XEXP ((OP), 0), 0), 0)) == ASHIFTRT \\\n+\t   && (MOVI_SHORI_BASE_OPERAND_P \\\n+\t       (XEXP (XEXP (XEXP (XEXP ((OP), 0), 0), 0), 0))) \\\n+\t   && GET_CODE (XEXP (XEXP (XEXP (XEXP ((OP), 0), 0), 0), \\\n+\t\t\t      1)) == CONST_INT)))\n+\n+/* Check whether OP is a datalabel unspec.  */\n+#define DATALABEL_REF_NO_CONST_P(OP) \\\n+  (GET_CODE (OP) == UNSPEC \\\n+   && XINT ((OP), 1) == UNSPEC_DATALABEL \\\n+   && XVECLEN ((OP), 0) == 1 \\\n+   && (GET_CODE (XVECEXP ((OP), 0, 0)) == SYMBOL_REF \\\n+       || GET_CODE (XVECEXP ((OP), 0, 0)) == LABEL_REF))\n+\n+/* Check whether OP is a datalabel unspec, possibly enclosed within a\n+   CONST.  */\n+#define DATALABEL_REF_P(OP) \\\n+  ((GET_CODE (OP) == CONST && DATALABEL_REF_NO_CONST_P (XEXP ((OP), 0))) \\\n+   || DATALABEL_REF_NO_CONST_P (OP))\n+\n+#define GOT_ENTRY_P(OP) \\\n+  (GET_CODE (OP) == CONST && GET_CODE (XEXP ((OP), 0)) == UNSPEC \\\n+   && XINT (XEXP ((OP), 0), 1) == UNSPEC_GOT)\n+\n+#define GOTPLT_ENTRY_P(OP) \\\n+  (GET_CODE (OP) == CONST && GET_CODE (XEXP ((OP), 0)) == UNSPEC \\\n+   && XINT (XEXP ((OP), 0), 1) == UNSPEC_GOTPLT)\n+\n+#define GOTOFF_P(OP) \\\n+  (GET_CODE (OP) == CONST && GET_CODE (XEXP ((OP), 0)) == UNSPEC \\\n+   && XINT (XEXP ((OP), 0), 1) == UNSPEC_GOTOFF)\n+\n+#define PIC_ADDR_P(OP) \\\n+  (GET_CODE (OP) == CONST && GET_CODE (XEXP ((OP), 0)) == UNSPEC \\\n+   && XINT (XEXP ((OP), 0), 1) == UNSPEC_PIC)\n+\n+#define NON_PIC_REFERENCE_P(OP) \\\n+  (GET_CODE (OP) == LABEL_REF || GET_CODE (OP) == SYMBOL_REF \\\n+   || DATALABEL_REF_P (OP) \\\n+   || (GET_CODE (OP) == CONST && GET_CODE (XEXP ((OP), 0)) == PLUS \\\n+       && (GET_CODE (XEXP (XEXP ((OP), 0), 0)) == SYMBOL_REF \\\n+\t   || DATALABEL_REF_P (XEXP (XEXP ((OP), 0), 0))) \\\n+       && GET_CODE (XEXP (XEXP ((OP), 0), 1)) == CONST_INT))\n+\n+#define PIC_REFERENCE_P(OP) \\\n+  (GOT_ENTRY_P (OP) || GOTPLT_ENTRY_P (OP) \\\n+   || GOTOFF_P (OP) || PIC_ADDR_P (OP))\n+\n+#define MOVI_SHORI_BASE_OPERAND_P(OP) \\\n+  (flag_pic ? PIC_REFERENCE_P (OP) : NON_PIC_REFERENCE_P (OP))\n+\n+/* The `T' constraint is a label or a symbol.  */\n+#define EXTRA_CONSTRAINT_T(OP) \\\n+  (NON_PIC_REFERENCE_P (OP))\n+\n #define EXTRA_CONSTRAINT(OP, C)\t\t\\\n   ((C) == 'Q' ? EXTRA_CONSTRAINT_Q (OP)\t\\\n+   : (C) == 'S' ? EXTRA_CONSTRAINT_S (OP) \\\n+   : (C) == 'T' ? EXTRA_CONSTRAINT_T (OP) \\\n    : 0)\n \f\n /* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n@@ -1453,6 +2296,16 @@ extern int current_function_anonymous_args;\n   do {\t\t\t\t\t\t\t\t\t\\\n     if (GET_CODE (OP) == CONST_INT) \t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n+\tif (TARGET_SHMEDIA)\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    int MODE_SIZE = GET_MODE_SIZE (MODE);\t\t\t\\\n+\t    if (! (INTVAL (OP) & (MODE_SIZE - 1))\t\t\t\\\n+\t\t&& INTVAL (OP) >= -512 * MODE_SIZE\t\t\t\\\n+\t\t&& INTVAL (OP) < 512 * MODE_SIZE)\t\t\t\\\n+\t      goto LABEL;\t\t\t\t\t\t\\\n+\t    else\t\t\t\t\t\t\t\\\n+\t      break;\t\t\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n \tif (MODE_DISP_OK_4 ((OP), (MODE)))  goto LABEL;\t\t      \t\\\n \tif (MODE_DISP_OK_8 ((OP), (MODE)))  goto LABEL;\t\t      \t\\\n       }\t\t\t\t\t\t\t\t\t\\\n@@ -1463,6 +2316,7 @@ extern int current_function_anonymous_args;\n   if (BASE_REGISTER_RTX_P (X))\t\t\t\t\t\t\\\n     goto LABEL;\t\t\t\t\t\t\t\t\\\n   else if ((GET_CODE (X) == POST_INC || GET_CODE (X) == PRE_DEC)\t\\\n+\t   && ! TARGET_SHMEDIA\t\t\t\t\t\t\\\n \t   && BASE_REGISTER_RTX_P (XEXP ((X), 0)))\t\t\t\\\n     goto LABEL;\t\t\t\t\t\t\t\t\\\n   else if (GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n@@ -1473,6 +2327,7 @@ extern int current_function_anonymous_args;\n       if (GET_MODE_SIZE (MODE) <= 8 && BASE_REGISTER_RTX_P (xop0))\t\\\n \tGO_IF_LEGITIMATE_INDEX ((MODE), xop1, LABEL);\t\t\t\\\n       if (GET_MODE_SIZE (MODE) <= 4\t\t\t\t\t\\\n+\t  || (TARGET_SHMEDIA && GET_MODE_SIZE (MODE) <= 8)\t\t\\\n \t  || (TARGET_SH4 && TARGET_FMOVD && MODE == DFmode))\t\t\\\n \t{\t\t\t\t\t\t\t\t\\\n \t  if (BASE_REGISTER_RTX_P (xop1) && INDEX_REGISTER_RTX_P (xop0))\\\n@@ -1509,6 +2364,7 @@ extern int current_function_anonymous_args;\n \t  || GET_MODE_SIZE (MODE) == 8)\t\t\t\t\\\n       && GET_CODE (XEXP ((X), 1)) == CONST_INT\t\t\t\\\n       && BASE_REGISTER_RTX_P (XEXP ((X), 0))\t\t\t\\\n+      && ! TARGET_SHMEDIA\t\t\t\t\t\\\n       && ! (TARGET_SH4 && (MODE) == DFmode)\t\t\t\\\n       && ! (TARGET_SH3E && (MODE) == SFmode))\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n@@ -1557,6 +2413,7 @@ extern int current_function_anonymous_args;\n       && (GET_MODE_SIZE (MODE) == 4 || GET_MODE_SIZE (MODE) == 8)\t\\\n       && GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\t\\\n       && BASE_REGISTER_RTX_P (XEXP (X, 0))\t\t\t\t\\\n+      && ! TARGET_SHMEDIA\t\t\t\t\t\t\\\n       && ! (TARGET_SH4 && (MODE) == DFmode)\t\t\t\t\\\n       && ! ((MODE) == PSImode && (TYPE) == RELOAD_FOR_INPUT_ADDRESS))\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n@@ -1602,6 +2459,7 @@ extern int current_function_anonymous_args;\n \t   && GET_CODE (XEXP (XEXP (X, 0), 1)) == CONST_INT\t\t\\\n \t   && BASE_REGISTER_RTX_P (XEXP (XEXP (X, 0), 0))\t\t\\\n \t   && GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\\\n+\t   && ! TARGET_SHMEDIA\t\t\t\t\t\t\\\n \t   && ! (TARGET_SH3E && MODE == SFmode))\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       /* Because this address is so complex, we know it must have\t\\\n@@ -1645,15 +2503,26 @@ extern int current_function_anonymous_args;\n    Do not define this if the table should contain absolute addresses.  */\n #define CASE_VECTOR_PC_RELATIVE 1\n \n+/* Define it here, so that it doesn't get bumped to 64-bits on SHmedia.  */\n+#define FLOAT_TYPE_SIZE 32\n+\n /* Since the SH3e has only `float' support, it is desirable to make all\n    floating point types equivalent to `float'.  */\n #define DOUBLE_TYPE_SIZE ((TARGET_SH3E && ! TARGET_SH4) ? 32 : 64)\n \n /* 'char' is signed by default.  */\n #define DEFAULT_SIGNED_CHAR  1\n \n+/* We -Define SIZE_TYPE in CPP_SPEC.  */\n+#define NO_BUILTIN_SIZE_TYPE 1\n+\n /* The type of size_t unsigned int.  */\n-#define SIZE_TYPE \"unsigned int\"\n+#define SIZE_TYPE (TARGET_SH5 ? \"long unsigned int\" : \"unsigned int\")\n+\n+#define NO_BUILTIN_PTRDIFF_TYPE 1\n+\n+#undef  PTRDIFF_TYPE\n+#define PTRDIFF_TYPE (TARGET_SH5 ? \"long int\" : \"int\")\n \n #define WCHAR_TYPE \"short unsigned int\"\n #define WCHAR_TYPE_SIZE 16\n@@ -1663,11 +2532,15 @@ extern int current_function_anonymous_args;\n \n /* Max number of bytes we can move from memory to memory\n    in one reasonably fast instruction.  */\n-#define MOVE_MAX 4\n+#define MOVE_MAX (TARGET_SHMEDIA ? 8 : 4)\n+\n+/* Maximum value possibly taken by MOVE_MAX.  Must be defined whenever\n+   MOVE_MAX is not a compile-time constant.  */\n+#define MAX_MOVE_MAX 8\n \n /* Max number of bytes we want move_by_pieces to be able to copy\n    efficiently.  */\n-#define MOVE_MAX_PIECES (TARGET_SH4 ? 8 : 4)\n+#define MOVE_MAX_PIECES (TARGET_SH4 || TARGET_SHMEDIA ? 8 : 4)\n \n /* Define if operations between registers always perform the operation\n    on the full register even if a narrower mode is specified.  */\n@@ -1714,13 +2587,24 @@ extern int current_function_anonymous_args;\n #define PROMOTE_PROTOTYPES 1\n \n /* The machine modes of pointers and functions.  */\n-#define Pmode  SImode\n+#define Pmode  (TARGET_SHMEDIA64 ? DImode : SImode)\n #define FUNCTION_MODE  Pmode\n \n /* The relative costs of various types of constants.  */\n \n #define CONST_COSTS(RTX, CODE, OUTER_CODE)\t\\\n   case CONST_INT:\t\t\t\t\\\n+    if (TARGET_SHMEDIA)\t\t\t\t\\\n+      {\t\t\t\t\t\t\\\n+\tif (CONST_OK_FOR_J (INTVAL (RTX)))\t\\\n+          return COSTS_N_INSNS (1);\t\t\\\n+\telse if (CONST_OK_FOR_J (INTVAL (RTX) >> 16)) \\\n+\t  return COSTS_N_INSNS (2);\t\t\\\n+\telse if (CONST_OK_FOR_J ((INTVAL (RTX) >> 16) >> 16)) \\\n+\t  return COSTS_N_INSNS (3);\t\t\\\n+        else\t\t\t\t\t\\\n+\t  return COSTS_N_INSNS (4);\t\t\\\n+      }\t\t\t\t\t\t\\\n     if (CONST_OK_FOR_I (INTVAL (RTX)))\t\t\\\n       return 0;\t\t\t\t\t\\\n     else if (((OUTER_CODE) == AND || (OUTER_CODE) == IOR || (OUTER_CODE) == XOR) \\\n@@ -1731,8 +2615,15 @@ extern int current_function_anonymous_args;\n   case CONST: \t\t\t\t\t\\\n   case LABEL_REF:\t\t\t\t\\\n   case SYMBOL_REF:\t\t\t\t\\\n+    if (TARGET_SHMEDIA64)\t\t\t\\\n+      return COSTS_N_INSNS (4);\t\t\t\\\n+    if (TARGET_SHMEDIA32)\t\t\t\\\n+      return COSTS_N_INSNS (2);\t\t\t\\\n     return 5;\t\t\t\t\t\\\n   case CONST_DOUBLE:\t\t\t\t\\\n+    if (TARGET_SHMEDIA)\t\t\t\t\\\n+      return COSTS_N_INSNS (4);\t\t\t\\\n+    else\t\t\t\t\t\\\n       return 10;\n \n #define RTX_COSTS(X, CODE, OUTER_CODE)\t\t\t\\\n@@ -1804,9 +2695,39 @@ do\t\t\t\t\t\t\t\t\t\\\n \t  (TREE_CODE_CLASS (TREE_CODE (DECL)) != 'd'\t\t\t\\\n \t   || ! TREE_PUBLIC (DECL));\t\t\t\t\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n+    if (TARGET_SH5)\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\trtx rtl = (TREE_CODE_CLASS (TREE_CODE (DECL)) != 'd'\t\t\\\n+\t\t   ? TREE_CST_RTL (DECL)\t\t\t\t\\\n+\t\t   : TREE_CODE (DECL) != VAR_DECL\t\t\t\\\n+\t\t   ? NULL_RTX\t\t\t\t\t\t\\\n+ \t\t   : DECL_RTL (DECL));\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+        if (rtl && GET_CODE (rtl) == MEM\t\t\t\t\\\n+ \t    && GET_CODE (XEXP (rtl, 0)) == SYMBOL_REF)\t\t\t\\\n+\t  XEXP (rtl, 0) = gen_datalabel_ref (XEXP (rtl, 0));\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n   }\t\t\t\t\t\t\t\t\t\\\n while (0)\n \n+/* The prefix used to mark SYMBOL_REFs that refer to data symbols.  */\n+#define SH_DATALABEL_ENCODING \"#\"\n+\n+/* Return true if SYM_NAME starts with SH_DATALABEL_ENCODING.  */\n+#define DATALABEL_SYMNAME_P(SYM_NAME) \\\n+  (SH_DATALABEL_ENCODING[1] ? (abort (), 0) : \\\n+   (SYM_NAME)[0] == SH_DATALABEL_ENCODING[0])\n+\n+/* Skip an optional SH_DATALABEL_ENCODING in the beginning of\n+   SYM_NAME.  Then, remove a leading *, like the default definition in\n+   output.h.  */\n+#define STRIP_DATALABEL_ENCODING(VAR, SYM_NAME) \\\n+  (VAR) = (SYM_NAME) + (DATALABEL_SYMNAME_P (SYM_NAME) \\\n+\t\t\t? strlen (SH_DATALABEL_ENCODING) : 0)\n+#define STRIP_NAME_ENCODING(VAR, SYM_NAME) \\\n+  STRIP_DATALABEL_ENCODING((VAR), (SYM_NAME)), \\\n+  (VAR) += (*(VAR) == '*')\n+\n /* We can't directly access anything that contains a symbol,\n    nor can we indirect via the constant pool.  */\n #define LEGITIMATE_PIC_OPERAND_P(X)\t\t\t\t\\\n@@ -1823,6 +2744,7 @@ while (0)\n    since it increases pressure on r0.  */\n \n #define ADDRESS_COST(X) (GET_CODE (X) == PLUS && ! CONSTANT_P (XEXP (X, 1)) \\\n+\t\t\t && ! TARGET_SHMEDIA \\\n \t\t\t ? 1 : 0)\n \n /* Compute extra cost of moving data between one register class\n@@ -1833,13 +2755,14 @@ while (0)\n    it uses this information.  Hence, the general register <-> floating point\n    register information here is not used for SFmode.  */\n #define REGISTER_MOVE_COST(MODE, SRCCLASS, DSTCLASS) \\\n-  ((((DSTCLASS) == T_REGS) || ((DSTCLASS) == PR_REGS)) ? 10\t\t\\\n+ (((((DSTCLASS) == T_REGS) || ((DSTCLASS) == PR_REGS)) ? 10\t\t\\\n    : ((((DSTCLASS) == FP0_REGS || (DSTCLASS) == FP_REGS || (DSTCLASS) == DF_REGS) \\\n        && ((SRCCLASS) == GENERAL_REGS || (SRCCLASS) == R0_REGS))\t\\\n       || (((DSTCLASS) == GENERAL_REGS || (DSTCLASS) == R0_REGS)\t\t\\\n \t  && ((SRCCLASS) == FP0_REGS || (SRCCLASS) == FP_REGS\t\t\\\n \t      || (SRCCLASS) == DF_REGS)))\t\t\t\t\\\n-   ? TARGET_FMOVD ? 8 : 12\t\t\t\t\t\t\\\n+   ? (TARGET_SHMEDIA ? 2\t\t\t\t\t\t\\\n+      : TARGET_FMOVD ? 8 : 12)\t\t\t\t\t\t\\\n    : (((DSTCLASS) == FPUL_REGS\t\t\t\t\t\t\\\n        && ((SRCCLASS) == GENERAL_REGS || (SRCCLASS) == R0_REGS))\t\\\n       || (SRCCLASS == FPUL_REGS\t\t\t\t\t\t\\\n@@ -1851,7 +2774,13 @@ while (0)\n       || ((SRCCLASS) == FPUL_REGS\t\t\t\t\t\\\n \t  && ((DSTCLASS) == PR_REGS || (DSTCLASS) == MAC_REGS)))\t\\\n    ? 7\t\t\t\t\t\t\t\t\t\\\n-   : 2)\n+   : (((SRCCLASS) == TARGET_REGS && (DSTCLASS) != GENERAL_REGS)\t\t\\\n+      || ((DSTCLASS) == TARGET_REGS && (SRCCLASS) != GENERAL_REGS))\t\\\n+   ? 20\t\t\t\t\t\t\t\t\t\\\n+   : (((SRCCLASS) == FPSCR_REGS && (DSTCLASS) != GENERAL_REGS)\t\t\\\n+      || ((DSTCLASS) == FPSCR_REGS && (SRCCLASS) != GENERAL_REGS))\t\\\n+   ? 4\t\t\t\t\t\t\t\t\t\\\n+   : 2) * ((MODE) == V16SFmode ? 8 : (MODE) == V4SFmode ? 2 : 1))\n \n /* ??? Perhaps make MEMORY_MOVE_COST depend on compiler option?  This\n    would be so that people with slow memory systems could generate\n@@ -1862,7 +2791,7 @@ while (0)\n    The SH1 does not have delay slots, hence we get a pipeline stall\n    at every branch.  The SH4 is superscalar, so the single delay slot\n    is not sufficient to keep both pipelines filled.  */\n-#define BRANCH_COST (! TARGET_SH2 || TARGET_HARD_SH4 ? 2 : 1)\n+#define BRANCH_COST (TARGET_SH5 ? 1 : ! TARGET_SH2 || TARGET_HARD_SH4 ? 2 : 1)\n \f\n /* Assembler output control.  */\n \n@@ -1885,9 +2814,20 @@ while (0)\n \n /* How to change between sections.  */\n \n-#define TEXT_SECTION_ASM_OP  \t\t\"\\t.text\"\n+#define TEXT_SECTION_ASM_OP  \t\t(TARGET_SHMEDIA32 ? \"\\t.section\\t.text..SHmedia32,\\\"ax\\\"\" : \"\\t.text\")\n #define DATA_SECTION_ASM_OP  \t\t\"\\t.data\"\n \n+#if defined CRT_BEGIN || defined CRT_END\n+/* Arrange for TEXT_SECTION_ASM_OP to be a compile-time constant.  */\n+# undef TEXT_SECTION_ASM_OP\n+# if __SHMEDIA__ == 1 && __SH5__ == 32\n+#  define TEXT_SECTION_ASM_OP \"\\t.section\\t.text..SHmedia32,\\\"ax\\\"\"\n+# else\n+#  define TEXT_SECTION_ASM_OP \"\\t.text\"\n+# endif\n+#endif\n+\n+\n /* If defined, a C expression whose value is a string containing the\n    assembler operation to identify the following data as\n    uninitialized global data.  If not defined, and neither\n@@ -1951,43 +2891,60 @@ while (0)\n #define ASM_OUTPUT_REG_POP(file, v) \\\n   fprintf ((file), \"\\tmov.l\\t@r15+,r%d\\n\", (v));\n \n-/* The assembler's names for the registers.  RFP need not always be used as\n-   the Real framepointer; it can also be used as a normal general register.\n-   Note that the name `fp' is horribly misleading since `fp' is in fact only\n-   the argument-and-return-context pointer.  */\n-\n-extern char fp_reg_names[][5];\n-\n-#define REGISTER_NAMES  \t\t\t\t\\\n-{\t\t\t\t                   \t\\\n-  \"r0\", \"r1\", \"r2\",  \"r3\",  \"r4\",  \"r5\",  \"r6\",  \"r7\", \t\\\n-  \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\",\t\\\n-  \"ap\", \"pr\", \"t\",   \"gbr\", \"mach\",\"macl\", fp_reg_names[16], \"rap\", \\\n-  fp_reg_names[0],  fp_reg_names[1] , fp_reg_names[2],  fp_reg_names[3], \\\n-  fp_reg_names[4],  fp_reg_names[5],  fp_reg_names[6],  fp_reg_names[7], \\\n-  fp_reg_names[8],  fp_reg_names[9],  fp_reg_names[10], fp_reg_names[11], \\\n-  fp_reg_names[12], fp_reg_names[13], fp_reg_names[14], fp_reg_names[15], \\\n-  fp_reg_names[17], fp_reg_names[18], fp_reg_names[19], fp_reg_names[20], \\\n-  fp_reg_names[21], fp_reg_names[22], fp_reg_names[23], fp_reg_names[24], \\\n-  \"fpscr\", \\\n-}\n-\n-#define DEBUG_REGISTER_NAMES  \t\t\t\t\\\n-{\t\t\t\t                   \t\\\n-  \"r0\", \"r1\", \"r2\",  \"r3\",  \"r4\",  \"r5\",  \"r6\",  \"r7\", \t\\\n-  \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\",\t\\\n-  \"ap\", \"pr\", \"t\",  \"gbr\", \"mach\",\"macl\", \"fpul\",\"rap\", \\\n-  \"fr0\",\"fr1\",\"fr2\", \"fr3\", \"fr4\", \"fr5\", \"fr6\", \"fr7\", \\\n-  \"fr8\",\"fr9\",\"fr10\",\"fr11\",\"fr12\",\"fr13\",\"fr14\",\"fr15\",\\\n-  \"xd0\",\"xd2\",\"xd4\", \"xd6\", \"xd8\", \"xd10\",\"xd12\",\"xd14\", \\\n-  \"fpscr\", \\\n-}\n-\n /* DBX register number for a given compiler register number.  */\n /* GDB has FPUL at 23 and FP0 at 25, so we must add one to all FP registers\n    to match gdb.  */\n-#define DBX_REGISTER_NUMBER(REGNO)\t\\\n-  (((REGNO) >= 22 && (REGNO) <= 39) ? ((REGNO) + 1) : (REGNO))\n+/* If you change this macro, make sure you update it in elf.h too.  */\n+#define DBX_REGISTER_NUMBER(REGNO) \\\n+  (GENERAL_REGISTER_P (REGNO) \\\n+   ? ((REGNO) - FIRST_GENERAL_REG) \\\n+   : FP_REGISTER_P (REGNO) \\\n+   ? ((REGNO) - FIRST_FP_REG + (TARGET_SH5 ? (TARGET_SHCOMPACT ? 245 \\\n+\t\t\t\t\t      : 77) : 25)) \\\n+   : XD_REGISTER_P (REGNO) \\\n+   ? ((REGNO) - FIRST_XD_REG + (TARGET_SH5 ? 289 : 87)) \\\n+   : TARGET_REGISTER_P (REGNO) \\\n+   ? ((REGNO) - FIRST_TARGET_REG + 68) \\\n+   : (REGNO) == PR_REG \\\n+   ? (TARGET_SH5 ? 241 : 17) \\\n+   : (REGNO) == T_REG \\\n+   ? (TARGET_SH5 ? 242 : 18) \\\n+   : (REGNO) == GBR_REG \\\n+   ? (TARGET_SH5 ? 238 : 19) \\\n+   : (REGNO) == MACH_REG \\\n+   ? (TARGET_SH5 ? 239 : 20) \\\n+   : (REGNO) == MACL_REG \\\n+   ? (TARGET_SH5 ? 240 : 21) \\\n+   : (REGNO) == FPUL_REG \\\n+   ? (TARGET_SH5 ? 244 : 23) \\\n+   : (abort(), -1))\n+\n+/* This is how to output a reference to a user-level label named NAME.  */\n+#define ASM_OUTPUT_LABELREF(FILE, NAME)\t\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      char * lname;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+      STRIP_DATALABEL_ENCODING (lname, (NAME));\t\t\\\n+      if (lname[0] == '*')\t\t\t\t\\\n+\tfputs (lname + 1, (FILE));\t\t\t\\\n+      else\t\t\t\t\t\t\\\n+\tasm_fprintf ((FILE), \"%U%s\", lname);\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+/* This is how to output a reference to a symbol_ref.  On SH5,\n+   references to non-code symbols must be preceded by `datalabel'.  */\n+#define ASM_OUTPUT_SYMBOL_REF(FILE,SYM)\t\t\t\\\n+  do \t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      if (TARGET_SH5\t\t\t\t\t\\\n+\t  && (DATALABEL_SYMNAME_P (XSTR ((SYM), 0))\t\\\n+\t      || CONSTANT_POOL_ADDRESS_P (SYM)))\t\\\n+\tfputs (\"datalabel \", (FILE));\t\t\t\\\n+      assemble_name ((FILE), XSTR ((SYM), 0));\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n \n /* Output a label definition.  */\n #define ASM_OUTPUT_LABEL(FILE,NAME) \\\n@@ -2040,12 +2997,30 @@ extern char fp_reg_names[][5];\n   switch (GET_MODE (BODY))\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n     case SImode:\t\t\t\t\t\t\t\\\n+      if (TARGET_SH5)\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  asm_fprintf ((STREAM), \"\\t.long\\t%LL%d-datalabel %LL%d\\n\",\t\\\n+\t\t       (VALUE), (REL));\t\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n       asm_fprintf ((STREAM), \"\\t.long\\t%LL%d-%LL%d\\n\", (VALUE),(REL));\t\\\n       break;\t\t\t\t\t\t\t\t\\\n     case HImode:\t\t\t\t\t\t\t\\\n+      if (TARGET_SH5)\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  asm_fprintf ((STREAM), \"\\t.word\\t%LL%d-datalabel %LL%d\\n\",\t\\\n+\t\t       (VALUE), (REL));\t\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n       asm_fprintf ((STREAM), \"\\t.word\\t%LL%d-%LL%d\\n\", (VALUE),(REL));\t\\\n       break;\t\t\t\t\t\t\t\t\\\n     case QImode:\t\t\t\t\t\t\t\\\n+      if (TARGET_SH5)\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  asm_fprintf ((STREAM), \"\\t.byte\\t%LL%d-datalabel %LL%d\\n\",\t\\\n+\t\t       (VALUE), (REL));\t\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n       asm_fprintf ((STREAM), \"\\t.byte\\t%LL%d-%LL%d\\n\", (VALUE),(REL));\t\\\n       break;\t\t\t\t\t\t\t\t\\\n     default:\t\t\t\t\t\t\t\t\\\n@@ -2119,10 +3094,14 @@ extern char fp_reg_names[][5];\n    constants.  Used for PIC-specific UNSPECs.  */\n #define OUTPUT_ADDR_CONST_EXTRA(STREAM, X, FAIL) \\\n   do\t\t\t\t\t\t\t\t\t\\\n-    if (flag_pic && GET_CODE (X) == UNSPEC && XVECLEN ((X), 0) == 1)\t\\\n+    if (GET_CODE (X) == UNSPEC && XVECLEN ((X), 0) == 1)\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n \tswitch (XINT ((X), 1))\t\t\t\t\t\t\\\n \t  {\t\t\t\t\t\t\t\t\\\n+\t  case UNSPEC_DATALABEL:\t\t\t\t\t\\\n+\t    fputs (\"datalabel \", (STREAM));\t\t\t\t\\\n+\t    output_addr_const ((STREAM), XVECEXP ((X), 0, 0));\t\t\\\n+\t    break;\t\t\t\t\t\t\t\\\n \t  case UNSPEC_PIC:\t\t\t\t\t\t\\\n \t    /* GLOBAL_OFFSET_TABLE or local symbols, no suffix.  */\t\\\n \t    output_addr_const ((STREAM), XVECEXP ((X), 0, 0));\t\t\\\n@@ -2139,6 +3118,10 @@ extern char fp_reg_names[][5];\n \t    output_addr_const ((STREAM), XVECEXP ((X), 0, 0));\t\t\\\n \t    fputs (\"@PLT\", (STREAM));\t\t\t\t\t\\\n \t    break;\t\t\t\t\t\t\t\\\n+\t  case UNSPEC_GOTPLT:\t\t\t\t\t\t\\\n+\t    output_addr_const ((STREAM), XVECEXP ((X), 0, 0));\t\t\\\n+\t    fputs (\"@GOTPLT\", (STREAM));\t\t\t\t\\\n+\t    break;\t\t\t\t\t\t\t\\\n \t  case UNSPEC_CALLER:\t\t\t\t\t\t\\\n \t    {\t\t\t\t\t\t\t\t\\\n \t      char name[32];\t\t\t\t\t\t\\\n@@ -2169,7 +3152,8 @@ enum processor_type {\n   PROCESSOR_SH2,\n   PROCESSOR_SH3,\n   PROCESSOR_SH3E,\n-  PROCESSOR_SH4\n+  PROCESSOR_SH4,\n+  PROCESSOR_SH5\n };\n \n #define sh_cpu_attr ((enum attr_cpu)sh_cpu)\n@@ -2239,6 +3223,9 @@ extern struct rtx_def *fpscr_rtx;\n   {\"general_movdst_operand\", {SUBREG, REG, MEM}},\t\t\t\\\n   {\"logical_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n   {\"noncommutative_float_operator\", {MINUS, DIV}},\t\t\t\\\n+  {\"shmedia_6bit_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n+  {\"target_reg_operand\", {SUBREG, REG}},\t\t\t\t\\\n+  {\"target_operand\", {SUBREG, REG, LABEL_REF, SYMBOL_REF}},\t\t\\\n   {\"register_operand\", {SUBREG, REG}},\t\t\t\t\t\\\n   {\"symbol_ref_operand\", {SYMBOL_REF}},\n \n@@ -2254,7 +3241,8 @@ extern struct rtx_def *fpscr_rtx;\n #define PROMOTE_MODE(MODE, UNSIGNEDP, TYPE) \\\n   if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\t\\\n       && GET_MODE_SIZE (MODE) < UNITS_PER_WORD)\t\t\\\n-    (MODE) = SImode;\n+    (UNSIGNEDP) = ((MODE) == SImode ? 0 : (UNSIGNEDP)),\t\\\n+    (MODE) = (TARGET_SH1 ? SImode : DImode);\n \n /* Defining PROMOTE_FUNCTION_ARGS eliminates some unnecessary zero/sign\n    extensions applied to char/short functions arguments.  Defining\n@@ -2299,6 +3287,7 @@ extern struct rtx_def *fpscr_rtx;\n \n #define DWARF_LINE_MIN_INSTR_LENGTH 2\n \n+#if (defined CRT_BEGIN || defined CRT_END) && ! __SHMEDIA__\n /* SH constant pool breaks the devices in crtstuff.c to control section\n    in where code resides.  We have to write it as asm code.  */\n #define CRT_CALL_STATIC_FUNCTION(SECTION_OP, FUNC) \\\n@@ -2310,6 +3299,7 @@ extern struct rtx_def *fpscr_rtx;\n 0:\t.p2align 2\\n\\\n 1:\t.long\t\" USER_LABEL_PREFIX #FUNC \" - 0b\\n\\\n 2:\\n\" TEXT_SECTION_ASM_OP);\n+#endif /* (defined CRT_BEGIN || defined CRT_END) && ! __SHMEDIA__ */\n \n #define ALLOCATE_INITIAL_VALUE(hard_reg) \\\n   (REGNO (hard_reg) == PR_REG \\"}, {"sha": "01c7aba53280567914e478a45576f879b196087c", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 3648, "deletions": 383, "changes": 4031, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa5322fa5824e95a7aa82413782b510c8d91e7d8/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa5322fa5824e95a7aa82413782b510c8d91e7d8/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=fa5322fa5824e95a7aa82413782b510c8d91e7d8"}, {"sha": "ccf7f481bf00efe984b028da379e23a3e50fa157", "filename": "gcc/config/sh/sh64.h", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa5322fa5824e95a7aa82413782b510c8d91e7d8/gcc%2Fconfig%2Fsh%2Fsh64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa5322fa5824e95a7aa82413782b510c8d91e7d8/gcc%2Fconfig%2Fsh%2Fsh64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh64.h?ref=fa5322fa5824e95a7aa82413782b510c8d91e7d8", "patch": "@@ -0,0 +1,61 @@\n+/* Definitions of target machine for GNU compiler for Hitachi Super-H 5.\n+   Copyright 2000, 2001 Free Software Foundation, Inc.\n+   Contributed by Alexandre Oliva <aoliva@redhat.com>\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#undef CPP_DEFAULT_CPU_SPEC\n+#define CPP_DEFAULT_CPU_SPEC \"-D__SH5__=32 -D__SHMEDIA__\"\n+\n+#undef SUBTARGET_CPP_PTR_SPEC\n+#define SUBTARGET_CPP_PTR_SPEC \"\\\n+%{!m1:%{!m2:%{!m3:%{!m3e:%{!m4:%{!m4-single:%{!m4-single-only:%{!m4-nofpu:-D__SIZE_TYPE__=long\\\\ unsigned\\\\ int -D__PTRDIFF_TYPE__=long\\\\ int}}}}}}}} \\\n+%{m1|m2|m3|m3e|m4|m4-single|m4-single-only|m4-nofpu:-D__SIZE_TYPE__=unsigned\\\\ int -D__PTRDIFF_TYPE__=int} \\\n+\"\n+\n+#undef ASM_SPEC\n+#define ASM_SPEC  \"%{ml:-little} %{mrelax:-relax} \\\n+%{m5-compact:--isa=SHcompact} %{m5-compact-nofpu:--isa=shcompact} \\\n+%{m5-32media:--isa=SHmedia --abi=32} %{m5-32media-nofpu:--isa=SHmedia --abi=32} \\\n+%{m5-64media:--isa=SHmedia --abi=64} %{m5-64media-nofpu:--isa=SHmedia --abi=64} \\\n+%{!m1:%{!m2:%{!m3:%{!m3e:%{!m4:%{!m4-single:%{!m4-single-only:%{!m4-nofpu:%{!m5-64media:%{!m5-64media-nofpu:%{!m5-32media:%{!m5-32media-nofpu:%{!m5-compact:%{!m5-compact-nofpu:--isa=SHmedia --abi=32}}}}}}}}}}}}}} \\\n+\"\n+\n+#undef LINK_SPEC\n+#define LINK_SPEC \" \\\n+%{m5-compact:%{!ml:-m shelf32} %{ml:-m shlelf32}} \\\n+%{m5-compact-nofpu:%{!ml:-m shelf32} %{ml:-m shlelf32}} \\\n+%{m5-32media:%{!ml:-m shelf32} %{ml:-m shlelf32}} \\\n+%{m5-32media-nofpu:%{!ml:-m shelf32} %{ml:-m shlelf32}} \\\n+%{m5-64media:%{!ml:-m shelf64} %{ml:-m shlelf64}} \\\n+%{m5-64media-nofpu:%{!ml:-m shelf64} %{ml:-m shlelf64}} \\\n+%{!m1:%{!m2:%{!m3:%{!m3e:%{!m4:%{!m4-single:%{!m4-single-only:%{!m4-nofpu:%{!m5-64media:%{!m5-64media-nofpu:%{!m5-32media:%{!m5-32media-nofpu:%{!m5-compact:%{!m5-compact-nofpu:%{!ml:-m shelf32} %{ml:-m shlelf32}}}}}}}}}}}}}}} \\\n+%{mrelax:-relax}\"\n+\n+#undef TARGET_DEFAULT\n+#define TARGET_DEFAULT  (SH5_BIT|SH4_BIT|SH3E_BIT)\n+\n+/* These have been overridden in svr4.h, included in elf.h.  Restore\n+   them.  */\n+#undef WCHAR_TYPE\n+#define WCHAR_TYPE \"short unsigned int\"\n+\n+#undef WCHAR_TYPE_SIZE\n+#define WCHAR_TYPE_SIZE 16\n+\n+#undef MAX_WCHAR_TYPE_SIZE"}, {"sha": "0ce6624951f7798c99edbff4dbb77eb09280c6e5", "filename": "gcc/config/sh/shmedia.h", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa5322fa5824e95a7aa82413782b510c8d91e7d8/gcc%2Fconfig%2Fsh%2Fshmedia.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa5322fa5824e95a7aa82413782b510c8d91e7d8/gcc%2Fconfig%2Fsh%2Fshmedia.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fshmedia.h?ref=fa5322fa5824e95a7aa82413782b510c8d91e7d8", "patch": "@@ -0,0 +1,33 @@\n+/* Copyright (C) 2000 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you include this header file into source\n+   files compiled by GCC, this header file does not by itself cause\n+   the resulting executable to be covered by the GNU General Public\n+   License.  This exception does not however invalidate any other\n+   reasons why the executable file might be covered by the GNU General\n+   Public License.  */\n+\n+#ifndef _SHMEDIA_H\n+#define _SHMEDIA_H\n+\n+#include <ushmedia.h>\n+#include <sshmedia.h>\n+\n+#endif"}, {"sha": "d7ef4564e84d1394c92a07e000c56590a2d2c1c3", "filename": "gcc/config/sh/sshmedia.h", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa5322fa5824e95a7aa82413782b510c8d91e7d8/gcc%2Fconfig%2Fsh%2Fsshmedia.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa5322fa5824e95a7aa82413782b510c8d91e7d8/gcc%2Fconfig%2Fsh%2Fsshmedia.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsshmedia.h?ref=fa5322fa5824e95a7aa82413782b510c8d91e7d8", "patch": "@@ -0,0 +1,74 @@\n+/* Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you include this header file into source\n+   files compiled by GCC, this header file does not by itself cause\n+   the resulting executable to be covered by the GNU General Public\n+   License.  This exception does not however invalidate any other\n+   reasons why the executable file might be covered by the GNU General\n+   Public License.  */\n+\n+/* sshmedia.h: Intrinsics corresponding to SHmedia instructions that\n+   may only be executed in privileged mode.  */\n+\n+#ifndef _SSHMEDIA_H\n+#define _SSHMEDIA_H\n+\n+#if __SHMEDIA__\n+__inline__ static\n+unsigned long long\n+sh_media_GETCON (unsigned int k)\n+{\n+  unsigned long long res;\n+  __asm__ __volatile__ (\"getcon\tcr%1, %0\" : \"=r\" (res) : \"n\" (k));\n+  return res;\n+}\n+\n+__inline__ static\n+void\n+sh_media_PUTCON (unsigned long long mm, unsigned int k)\n+{\n+  __asm__ __volatile__ (\"putcon\t%0, cr%1\" : : \"r\" (mm), \"n\" (k));\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_GETCFG (unsigned long long mm, int s)\n+{\n+  unsigned long long res;\n+  __asm__ __volatile__ (\"getcfg\t%1, %2, %0\" : \"=r\" (res) : \"r\" (mm), \"n\" (s));\n+  return res;\n+}\n+\n+__inline__ static\n+void\n+sh_media_PUTCFG (unsigned long long mm, int s, unsigned long long mw)\n+{\n+  __asm__ __volatile__ (\"putcfg\t%0, %1, %2\" : : \"r\" (mm), \"n\" (s), \"r\" (mw));\n+}\n+\n+__inline__ static\n+void\n+sh_media_SLEEP (void)\n+{\n+  __asm__ __volatile__ (\"sleep\");\n+}\n+#endif\n+\n+#endif"}, {"sha": "c3329893019f097f215df26d965f765f594f2e1e", "filename": "gcc/config/sh/t-sh64", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa5322fa5824e95a7aa82413782b510c8d91e7d8/gcc%2Fconfig%2Fsh%2Ft-sh64", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa5322fa5824e95a7aa82413782b510c8d91e7d8/gcc%2Fconfig%2Fsh%2Ft-sh64", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Ft-sh64?ref=fa5322fa5824e95a7aa82413782b510c8d91e7d8", "patch": "@@ -0,0 +1,11 @@\n+EXTRA_MULTILIB_PARTS= crt1.o crti.o crtn.o crtbegin.o crtend.o\n+\n+LIB1ASMFUNCS = \\\n+  _sdivsi3 _sdivsi3_i4 _udivsi3 _udivsi3_i4 _set_fpscr \\\n+  _shcompact_call_trampoline _shcompact_return_trampoline \\\n+  _shcompact_incoming_args _ic_invalidate _nested_trampoline \\\n+  _push_pop_shmedia_regs\n+\n+MULTILIB_OPTIONS= ml m5-32media-nofpu/m5-compact/m5-compact-nofpu/m5-64media/m5-64media-nofpu\n+MULTILIB_DIRNAMES= ml nofpu compact nofpu/compact media64 nofpu/media64\n+MULTILIB_MATCHES="}, {"sha": "9a402e8a06ec6b4cf7e4698a00c52d850f553870", "filename": "gcc/config/sh/ushmedia.h", "status": "added", "additions": 1147, "deletions": 0, "changes": 1147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa5322fa5824e95a7aa82413782b510c8d91e7d8/gcc%2Fconfig%2Fsh%2Fushmedia.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa5322fa5824e95a7aa82413782b510c8d91e7d8/gcc%2Fconfig%2Fsh%2Fushmedia.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fushmedia.h?ref=fa5322fa5824e95a7aa82413782b510c8d91e7d8", "patch": "@@ -0,0 +1,1147 @@\n+/* Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you include this header file into source\n+   files compiled by GCC, this header file does not by itself cause\n+   the resulting executable to be covered by the GNU General Public\n+   License.  This exception does not however invalidate any other\n+   reasons why the executable file might be covered by the GNU General\n+   Public License.  */\n+\n+/* ushmedia.h: Intrinsics corresponding to SHmedia instructions that\n+   may be executed in both user and privileged mode.  */\n+\n+#ifndef _USHMEDIA_H\n+#define _USHMEDIA_H\n+\n+#if __SHMEDIA__\n+#if ! __SH4_NO_FPU\n+typedef float __GCC_FV __attribute__ ((mode (V4SF)));\n+typedef float __GCC_MTRX __attribute__ ((mode (V16SF)));\n+#endif\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MABS_L (unsigned long long mm)\n+{\n+  unsigned long long res;\n+  __asm__ (\"mabs.l\t%1, %0\" : \"=r\" (res) : \"r\" (mm));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MABS_W (unsigned long long mm)\n+{\n+  unsigned long long res;\n+  __asm__ (\"mabs.w\t%1, %0\" : \"=r\" (res) : \"r\" (mm));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MADD_L (unsigned long long mm, unsigned long long mn)\n+{\n+  unsigned long long res;\n+  __asm__ (\"madd.l\t%1, %2, %0\" : \"=r\" (res) : \"r\" (mm), \"r\" (mn));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MADD_W (unsigned long long mm, unsigned long long mn)\n+{\n+  unsigned long long res;\n+  __asm__ (\"madd.w\t%1, %2, %0\" : \"=r\" (res) : \"r\" (mm), \"r\" (mn));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MADDS_L (unsigned long long mm, unsigned long long mn)\n+{\n+  unsigned long long res;\n+  __asm__ (\"madds.l\t%1, %2, %0\" : \"=r\" (res) : \"r\" (mm), \"r\" (mn));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MADDS_UB (unsigned long long mm, unsigned long long mn)\n+{\n+  unsigned long long res;\n+  __asm__ (\"madds.ub\t%1, %2, %0\" : \"=r\" (res) : \"r\" (mm), \"r\" (mn));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MADDS_W (unsigned long long mm, unsigned long long mn)\n+{\n+  unsigned long long res;\n+  __asm__ (\"madds.w\t%1, %2, %0\" : \"=r\" (res) : \"r\" (mm), \"r\" (mn));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MCMPEQ_B (unsigned long long mm, unsigned long long mn)\n+{\n+  unsigned long long res;\n+  __asm__ (\"mcmpeq.b\t%1, %2, %0\" : \"=r\" (res) : \"r\" (mm), \"r\" (mn));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MCMPEQ_L (unsigned long long mm, unsigned long long mn)\n+{\n+  unsigned long long res;\n+  __asm__ (\"mcmpeq.l\t%1, %2, %0\" : \"=r\" (res) : \"r\" (mm), \"r\" (mn));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MCMPEQ_W (unsigned long long mm, unsigned long long mn)\n+{\n+  unsigned long long res;\n+  __asm__ (\"mcmpeq.w\t%1, %2, %0\" : \"=r\" (res) : \"r\" (mm), \"r\" (mn));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MCMPGT_L (unsigned long long mm, unsigned long long mn)\n+{\n+  unsigned long long res;\n+  __asm__ (\"mcmpgt.l\t%1, %2, %0\" : \"=r\" (res) : \"r\" (mm), \"r\" (mn));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MCMPGT_UB (unsigned long long mm, unsigned long long mn)\n+{\n+  unsigned long long res;\n+  __asm__ (\"mcmpgt.ub\t%1, %2, %0\" : \"=r\" (res) : \"r\" (mm), \"r\" (mn));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MCMPGT_W (unsigned long long mm, unsigned long long mn)\n+{\n+  unsigned long long res;\n+  __asm__ (\"mcmpgt.w\t%1, %2, %0\" : \"=r\" (res) : \"r\" (mm), \"r\" (mn));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MCMV (unsigned long long mm, unsigned long long mn, unsigned long long mw)\n+{\n+  unsigned long long res;\n+  __asm__ (\"mcmv\t%1, %2, %0\" : \"=r\" (res)\n+\t   : \"r\" (mm), \"r\" (mn), \"0\" (mw));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MCNVS_LW (unsigned long long mm, unsigned long long mn)\n+{\n+  unsigned long long res;\n+  __asm__ (\"mcnvs.lw\t%1, %2, %0\" : \"=r\" (res) : \"r\" (mm), \"r\" (mn));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MCNVS_WB (unsigned long long mm, unsigned long long mn)\n+{\n+  unsigned long long res;\n+  __asm__ (\"mcnvs.wb\t%1, %2, %0\" : \"=r\" (res) : \"r\" (mm), \"r\" (mn));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MCNVS_WUB (unsigned long long mm, unsigned long long mn)\n+{\n+  unsigned long long res;\n+  __asm__ (\"mcnvs.wub\t%1, %2, %0\" : \"=r\" (res) : \"r\" (mm), \"r\" (mn));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MEXTR1 (unsigned long long mm, unsigned long long mn)\n+{\n+  unsigned long long res;\n+  __asm__ (\"mextr1\t%1, %2, %0\" : \"=r\" (res) : \"r\" (mm), \"r\" (mn));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MEXTR2 (unsigned long long mm, unsigned long long mn)\n+{\n+  unsigned long long res;\n+  __asm__ (\"mextr2\t%1, %2, %0\" : \"=r\" (res) : \"r\" (mm), \"r\" (mn));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MEXTR3 (unsigned long long mm, unsigned long long mn)\n+{\n+  unsigned long long res;\n+  __asm__ (\"mextr3\t%1, %2, %0\" : \"=r\" (res) : \"r\" (mm), \"r\" (mn));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MEXTR4 (unsigned long long mm, unsigned long long mn)\n+{\n+  unsigned long long res;\n+  __asm__ (\"mextr4\t%1, %2, %0\" : \"=r\" (res) : \"r\" (mm), \"r\" (mn));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MEXTR5 (unsigned long long mm, unsigned long long mn)\n+{\n+  unsigned long long res;\n+  __asm__ (\"mextr5\t%1, %2, %0\" : \"=r\" (res) : \"r\" (mm), \"r\" (mn));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MEXTR6 (unsigned long long mm, unsigned long long mn)\n+{\n+  unsigned long long res;\n+  __asm__ (\"mextr6\t%1, %2, %0\" : \"=r\" (res) : \"r\" (mm), \"r\" (mn));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MEXTR7 (unsigned long long mm, unsigned long long mn)\n+{\n+  unsigned long long res;\n+  __asm__ (\"mextr7\t%1, %2, %0\" : \"=r\" (res) : \"r\" (mm), \"r\" (mn));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MMACFX_WL (unsigned long long mm, unsigned long long mn, unsigned long long mw)\n+{\n+  unsigned long long res;\n+  __asm__ (\"mmacfx.wl\t%1, %2, %0\" : \"=r\" (res)\n+\t   : \"r\" (mm), \"r\" (mn), \"0\" (mw));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MMACNFX_WL (unsigned long long mm, unsigned long long mn, unsigned long long mw)\n+{\n+  unsigned long long res;\n+  __asm__ (\"mmacnfx.wl\t%1, %2, %0\" : \"=r\" (res)\n+\t   : \"r\" (mm), \"r\" (mn), \"0\" (mw));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MMUL_L (unsigned long long mm, unsigned long long mn)\n+{\n+  unsigned long long res;\n+  __asm__ (\"mmul.l\t%1, %2, %0\" : \"=r\" (res) : \"r\" (mm), \"r\" (mn));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MMUL_W (unsigned long long mm, unsigned long long mn)\n+{\n+  unsigned long long res;\n+  __asm__ (\"mmul.w\t%1, %2, %0\" : \"=r\" (res) : \"r\" (mm), \"r\" (mn));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MMULFX_L (unsigned long long mm, unsigned long long mn)\n+{\n+  unsigned long long res;\n+  __asm__ (\"mmulfx.l\t%1, %2, %0\" : \"=r\" (res) : \"r\" (mm), \"r\" (mn));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MMULFX_W (unsigned long long mm, unsigned long long mn)\n+{\n+  unsigned long long res;\n+  __asm__ (\"mmulfx.w\t%1, %2, %0\" : \"=r\" (res) : \"r\" (mm), \"r\" (mn));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MMULFXRP_W (unsigned long long mm, unsigned long long mn)\n+{\n+  unsigned long long res;\n+  __asm__ (\"mmulfxrp.w\t%1, %2, %0\" : \"=r\" (res) : \"r\" (mm), \"r\" (mn));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MMULHI_WL (unsigned long long mm, unsigned long long mn)\n+{\n+  unsigned long long res;\n+  __asm__ (\"mmulhi.wl\t%1, %2, %0\" : \"=r\" (res) : \"r\" (mm), \"r\" (mn));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MMULLO_WL (unsigned long long mm, unsigned long long mn)\n+{\n+  unsigned long long res;\n+  __asm__ (\"mmullo.wl\t%1, %2, %0\" : \"=r\" (res) : \"r\" (mm), \"r\" (mn));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MMULSUM_WQ (unsigned long long mm, unsigned long long mn, unsigned long long mw)\n+{\n+  unsigned long long res;\n+  __asm__ (\"mmulsum.wq\t%1, %2, %0\" : \"=r\" (res)\n+\t   : \"r\" (mm), \"r\" (mn), \"0\" (mw));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MPERM_W (unsigned long long mm, unsigned int mn)\n+{\n+  unsigned long long res;\n+  __asm__ (\"mperm.w\t%1, %2, %0\" : \"=r\" (res) : \"r\" (mm), \"r\" (mn));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MSAD_UBQ (unsigned long long mm, unsigned long long mn, unsigned long long mw)\n+{\n+  unsigned long long res;\n+  __asm__ (\"msad.ubq\t%1, %2, %0\" : \"=r\" (res)\n+\t   : \"r\" (mm), \"r\" (mn), \"0\" (mw));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MSHALDS_L (unsigned long long mm, unsigned int mn)\n+{\n+  unsigned long long res;\n+  __asm__ (\"mshalds.l\t%1, %2, %0\" : \"=r\" (res) : \"r\" (mm), \"r\" (mn));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MSHALDS_W (unsigned long long mm, unsigned int mn)\n+{\n+  unsigned long long res;\n+  __asm__ (\"mshalds.w\t%1, %2, %0\" : \"=r\" (res) : \"r\" (mm), \"r\" (mn));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MSHARD_L (unsigned long long mm, unsigned int mn)\n+{\n+  unsigned long long res;\n+  __asm__ (\"mshard.l\t%1, %2, %0\" : \"=r\" (res) : \"r\" (mm), \"r\" (mn));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MSHARD_W (unsigned long long mm, unsigned int mn)\n+{\n+  unsigned long long res;\n+  __asm__ (\"mshard.w\t%1, %2, %0\" : \"=r\" (res) : \"r\" (mm), \"r\" (mn));\n+  return res;\n+}\n+\n+__inline__ static\n+short\n+sh_media_MSHARDS_Q (long long mm, unsigned int mn)\n+{\n+  short res;\n+  __asm__ (\"mshards.q\t%1, %2, %0\" : \"=r\" (res) : \"r\" (mm), \"r\" (mn));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MSHFHI_B (unsigned long long mm, unsigned long long mn)\n+{\n+  unsigned long long res;\n+  __asm__ (\"mshfhi.b\t%1, %2, %0\" : \"=r\" (res) : \"r\" (mm), \"r\" (mn));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MSHFHI_L (unsigned long long mm, unsigned long long mn)\n+{\n+  unsigned long long res;\n+  __asm__ (\"mshfhi.l\t%1, %2, %0\" : \"=r\" (res) : \"r\" (mm), \"r\" (mn));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MSHFHI_W (unsigned long long mm, unsigned long long mn)\n+{\n+  unsigned long long res;\n+  __asm__ (\"mshfhi.w\t%1, %2, %0\" : \"=r\" (res) : \"r\" (mm), \"r\" (mn));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MSHFLO_B (unsigned long long mm, unsigned long long mn)\n+{\n+  unsigned long long res;\n+  __asm__ (\"mshflo.b\t%1, %2, %0\" : \"=r\" (res) : \"r\" (mm), \"r\" (mn));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MSHFLO_L (unsigned long long mm, unsigned long long mn)\n+{\n+  unsigned long long res;\n+  __asm__ (\"mshflo.l\t%1, %2, %0\" : \"=r\" (res) : \"r\" (mm), \"r\" (mn));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MSHFLO_W (unsigned long long mm, unsigned long long mn)\n+{\n+  unsigned long long res;\n+  __asm__ (\"mshflo.w\t%1, %2, %0\" : \"=r\" (res) : \"r\" (mm), \"r\" (mn));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MSHLLD_L (unsigned long long mm, unsigned int mn)\n+{\n+  unsigned long long res;\n+  __asm__ (\"mshlld.l\t%1, %2, %0\" : \"=r\" (res) : \"r\" (mm), \"r\" (mn));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MSHLLD_W (unsigned long long mm, unsigned int mn)\n+{\n+  unsigned long long res;\n+  __asm__ (\"mshlld.w\t%1, %2, %0\" : \"=r\" (res) : \"r\" (mm), \"r\" (mn));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MSHLRD_L (unsigned long long mm, unsigned int mn)\n+{\n+  unsigned long long res;\n+  __asm__ (\"mshlrd.l\t%1, %2, %0\" : \"=r\" (res) : \"r\" (mm), \"r\" (mn));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MSHLRD_W (unsigned long long mm, unsigned int mn)\n+{\n+  unsigned long long res;\n+  __asm__ (\"mshlrd.w\t%1, %2, %0\" : \"=r\" (res) : \"r\" (mm), \"r\" (mn));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MSUB_L (unsigned long long mm, unsigned long long mn)\n+{\n+  unsigned long long res;\n+  __asm__ (\"msub.l\t%1, %2, %0\" : \"=r\" (res) : \"r\" (mm), \"r\" (mn));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MSUB_W (unsigned long long mm, unsigned long long mn)\n+{\n+  unsigned long long res;\n+  __asm__ (\"msub.w\t%1, %2, %0\" : \"=r\" (res) : \"r\" (mm), \"r\" (mn));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MSUBS_L (unsigned long long mm, unsigned long long mn)\n+{\n+  unsigned long long res;\n+  __asm__ (\"msubs.l\t%1, %2, %0\" : \"=r\" (res) : \"r\" (mm), \"r\" (mn));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MSUBS_UB (unsigned long long mm, unsigned long long mn)\n+{\n+  unsigned long long res;\n+  __asm__ (\"msubs.ub\t%1, %2, %0\" : \"=r\" (res) : \"r\" (mm), \"r\" (mn));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_MSUBS_W (unsigned long long mm, unsigned long long mn)\n+{\n+  unsigned long long res;\n+  __asm__ (\"msubs.w\t%1, %2, %0\" : \"=r\" (res) : \"r\" (mm), \"r\" (mn));\n+  return res;\n+}\n+\n+#if ! __SH4_NOFPU__\n+__inline__ static\n+double\n+sh_media_FABS_D (double dg)\n+{\n+  double res;\n+  __asm__ (\"fabs.d\t%1, %0\" : \"=f\" (res) : \"f\" (dg));\n+  return res;\n+}\n+\n+__inline__ static\n+float \n+sh_media_FABS_S (float fg)\n+{\n+  float res;\n+  __asm__ (\"fabs.s\t%1, %0\" : \"=f\" (res) : \"f\" (fg));\n+  return res;\n+}\n+\n+__inline__ static\n+int   \n+sh_media_FCMPUN_D (double dg, double dh)\n+{\n+  int res;\n+  __asm__ (\"fcmpun.d\t%1, %2, %0\" : \"=f\" (res) : \"f\" (dg), \"f\" (dh));\n+  return res;\n+}\n+\n+__inline__ static\n+int   \n+sh_media_FCMPUN_S (float fg, float fh)\n+{\n+  int res;\n+  __asm__ (\"fcmpun.s\t%1, %2, %0\" : \"=f\" (res) : \"f\" (fg), \"f\" (fh));\n+  return res;\n+}\n+\n+__inline__ static\n+float \n+sh_media_FGETSCR (void)\n+{\n+  float res;\n+  __asm__ (\"fgetscr\t%0\" : \"=f\" (res));\n+  return res;\n+}\n+\n+__inline__ static\n+float \n+sh_media_FIPR_S (const void *fvg, const void *fvh)\n+{\n+  float res;\n+  __asm__ (\"fipr.s\t%1, %2, %0\" : \"=f\" (res)\n+\t   : \"f\" (*(const __GCC_FV *)fvg), \"f\" (*(const __GCC_FV *)fvh));\n+  return res;\n+}\n+\n+__inline__ static\n+float \n+sh_media_FMAC_S (float fg, float fh, float fq)\n+{\n+  float res;\n+  __asm__ (\"fmac.s\t%1, %2, %0\" : \"=f\" (res)\n+\t   : \"f\" (fg), \"f\" (fh), \"0\" (fq));\n+  return res;\n+}\n+\n+__inline__ static\n+long long\n+sh_media_FMOV_DQ (double dg)\n+{\n+  long long res;\n+  __asm__ (\"fmov.dq\t%1, %0\" : \"=r\" (res) : \"f\" (dg));\n+  return res;\n+}\n+\n+__inline__ static\n+float\n+sh_media_FMOV_LS (int mm)\n+{\n+  float res;\n+  __asm__ (\"fmov.ls\t%1, %0\" : \"=f\" (res) : \"r\" (mm));\n+  return res;\n+}\n+\n+__inline__ static\n+double\n+sh_media_FMOV_QD (long long mm)\n+{\n+  double res;\n+  __asm__ (\"fmov.qd\t%1, %0\" : \"=f\" (res) : \"r\" (mm));\n+  return res;\n+}\n+\n+__inline__ static\n+int\n+sh_media_FMOV_SL (float fg)\n+{\n+  int res;\n+  __asm__ (\"fmov.sl\t%1, %0\" : \"=r\" (res) : \"f\" (fg));\n+  return res;\n+}\n+\n+__inline__ static\n+void  \n+sh_media_FPUTSCR (float fg)\n+{\n+  __asm__ (\"fputscr\t%0\" : : \"f\" (fg));\n+}\n+\n+__inline__ static\n+double\n+sh_media_FSQRT_D (double dg)\n+{\n+  double res;\n+  __asm__ (\"fsqrt.d\t%1, %0\" : \"=f\" (res) : \"f\" (dg));\n+  return res;\n+}\n+\n+__inline__ static\n+float \n+sh_media_FSQRT_S (float fg)\n+{\n+  float res;\n+  __asm__ (\"fsqrt.s\t%1, %0\" : \"=f\" (res) : \"f\" (fg));\n+  return res;\n+}\n+\n+__inline__ static\n+void  \n+sh_media_FTRV_S (const void *mtrxg, const void *fvh, void *fvf)\n+{\n+  __asm__ (\"ftrv.s\t%2, %1, %0\" : \"=f\" (*(__GCC_FV *)fvf)\n+\t   : \"f\" (*(const __GCC_FV *)fvh), \"f\" (*(const __GCC_MTRX *)mtrxg));\n+}\n+#endif /* ! __SH4_NOFPU__ */\n+\n+__inline__ static\n+unsigned long long\n+sh_media_LDHI_L (void *p, int s)\n+{\n+  unsigned long long res;\n+  __asm__ (\"ldhi.l\t%m1, %0\" : \"=r\" (res) : \"o\" (((char*)p)[s]));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_LDHI_Q (void *p, int s)\n+{\n+  unsigned long long res;\n+  __asm__ (\"ldhi.q\t%m1, %0\" : \"=r\" (res) : \"o\" (((char*)p)[s]));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_LDLO_L (void *p, int s)\n+{\n+  unsigned long long res;\n+  __asm__ (\"ldlo.l\t%m1, %0\" : \"=r\" (res) : \"o\" (((char*)p)[s]));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_LDLO_Q (void *p, int s)\n+{\n+  unsigned long long res;\n+  __asm__ (\"ldlo.q\t%m1, %0\" : \"=r\" (res) : \"o\" (((char*)p)[s]));\n+  return res;\n+}\n+\n+__inline__ static\n+void     \n+sh_media_STHI_L (void *p, int s, unsigned int mw)\n+{\n+  __asm__ (\"sthi.l %m0, %1\" : \"+o\" (((char*)p)[s]) : \"r\" (mw));\n+}\n+\n+__inline__ static\n+void     \n+sh_media_STHI_Q (void *p, int s, unsigned long long mw)\n+{\n+  __asm__ (\"sthi.q %m0, %1\" : \"+o\" (((char*)p)[s]) : \"r\" (mw));\n+}\n+\n+__inline__ static\n+void     \n+sh_media_STLO_L (void *p, int s, unsigned int mw)\n+{\n+  __asm__ (\"stlo.l %m0, %1\" : \"+o\" (((char*)p)[s]) : \"r\" (mw));\n+}\n+\n+__inline__ static\n+void     \n+sh_media_STLO_Q (void *p, int s, unsigned long long mw)\n+{\n+  __asm__ (\"stlo.q %m0, %1\" : \"+o\" (((char*)p)[s]) : \"r\" (mw));\n+}\n+\n+__inline__ static\n+unsigned char\n+sh_media_NSB (long long mm)\n+{\n+  unsigned char res;\n+  __asm__ (\"nsb\t%1, %0\" : \"=r\" (res) : \"r\" (mm));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_BYTEREV (unsigned long long mm)\n+{\n+  unsigned long long res;\n+  __asm__ (\"byterev\t%1, %0\" : \"=r\" (res) : \"r\" (mm));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_CMVEQ (unsigned long long mm, unsigned long long mn, unsigned long long mw)\n+{\n+  unsigned long long res;\n+  __asm__ (\"cmveq\t%1, %2, %0\" : \"=r\" (res)\n+\t   : \"r\" (mm), \"r\" (mn), \"0\" (mw));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_CMVNE (unsigned long long mm, unsigned long long mn, unsigned long long mw)\n+{\n+  unsigned long long res;\n+  __asm__ (\"cmveq\t%1, %2, %0\" : \"=r\" (res)\n+\t   : \"r\" (mm), \"r\" (mn), \"0\" (mw));\n+  return res;\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_ADDZ_L (unsigned int mm, unsigned int mn)\n+{\n+  unsigned long long res;\n+  __asm__ (\"addz.l\t%1, %2, %0\" : \"=r\" (res) : \"r\" (mm), \"r\" (mn));\n+  return res;\n+}\n+\n+__inline__ static\n+void\n+sh_media_NOP (void)\n+{\n+  __asm__ __volatile__ (\"nop\" : :);\n+}\n+\n+__inline__ static\n+unsigned long long\n+sh_media_SWAP_Q (void *mm, long long mn, unsigned long long mw)\n+{\n+  unsigned long long res;\n+  unsigned long long *addr = (unsigned long long *)((char *)mm + mn);\n+  __asm__ (\"swap.q\t%m1, %0\" : \"=r\" (res), \"+o\" (*addr) : \"0\" (mw));\n+  return res;\n+}\n+\n+__inline__ static\n+void     \n+sh_media_SYNCI (void)\n+{\n+  __asm__ __volatile__ (\"synci\");\n+}\n+\n+__inline__ static\n+void     \n+sh_media_SYNCO (void)\n+{\n+  __asm__ __volatile__ (\"synco\");\n+}\n+\n+__inline__ static\n+void\n+sh_media_ALLOCO (void *mm, int s)\n+{\n+  __asm__ __volatile__ (\"alloco\t%m0\" : : \"o\" (((char*)mm)[s]));\n+}\n+\n+__inline__ static\n+void\n+sh_media_ICBI (void *mm, int s)\n+{\n+  __asm__ __volatile__ (\"icbi\t%m0\" : : \"o\" (((char*)mm)[s]));\n+}\n+\n+__inline__ static\n+void\n+sh_media_OCBI (void *mm, int s)\n+{\n+  __asm__ __volatile__ (\"ocbi\t%m0\" : : \"o\" (((char*)mm)[s]));\n+}\n+\n+__inline__ static\n+void\n+sh_media_OCBP (void *mm, int s)\n+{\n+  __asm__ __volatile__ (\"ocbp\t%m0\" : : \"o\" (((char*)mm)[s]));\n+}\n+\n+__inline__ static\n+void\n+sh_media_OCBWB (void *mm, int s)\n+{\n+  __asm__ __volatile__ (\"ocbwb\t%m0\" : : \"o\" (((char*)mm)[s]));\n+}\n+\n+__inline__ static\n+void\n+sh_media_PREFI (void *mm, int s)\n+{\n+  __asm__ __volatile__ (\"prefi\t%m0\" : : \"o\" (((char*)mm)[s]));\n+}\n+\n+__inline__ static\n+void\n+sh_media_PREFO (void *mm, int s)\n+{\n+  __asm__ __volatile__ (\"ld.b\t%m0, r63\" : : \"o\" (((char*)mm)[s]));\n+}\n+\n+__inline__ static\n+void\n+sh_media_BRK (void)\n+{\n+  __asm__ __volatile__ (\"brk\");\n+}\n+\n+__inline__ static\n+void\n+sh_media_TRAPA (unsigned long long mm)\n+{\n+  __asm__ __volatile__ (\"trapa\t%%0\" : : \"r\" (mm));\n+}\n+\n+__inline__ static\n+short         \n+sh_media_unaligned_LD_W (void *p)\n+{\n+#if __LITTLE_ENDIAN__\n+  return (((unsigned char *)p)[0]\n+\t  | (((short)((__signed__ char *)p)[1]) << 8));\n+#else\n+  return ((((short)((__signed__ char *)p)[0]) << 8)\n+\t  | ((unsigned char *)p)[1]);\n+#endif\n+}\n+\n+__inline__ static\n+unsigned short\n+sh_media_unaligned_LD_UW (void *p)\n+{\n+  unsigned char *addr = p;\n+#if __LITTLE_ENDIAN__\n+  return sh_media_MSHFLO_B (addr[0], addr[1]);\n+#else\n+  return sh_media_MSHFLO_B (addr[1], addr[0]);\n+#endif\n+}\n+\n+__inline__ static\n+int           \n+sh_media_unaligned_LD_L (void *p)\n+{\n+#if __LITTLE_ENDIAN__\n+  return sh_media_LDHI_L (p, 3) | sh_media_LDLO_L (p, 0);\n+#else\n+  return sh_media_LDLO_L (p, 3) | sh_media_LDHI_L (p, 0);\n+#endif\n+}\n+\n+__inline__ static\n+long long     \n+sh_media_unaligned_LD_Q (void *p)\n+{\n+#if __LITTLE_ENDIAN__\n+  return sh_media_LDHI_Q (p, 7) | sh_media_LDLO_Q (p, 0);\n+#else\n+  return sh_media_LDLO_Q (p, 7) | sh_media_LDHI_Q (p, 0);\n+#endif\n+}\n+\n+__inline__ static\n+void\n+sh_media_unaligned_ST_W (void *p, unsigned int k)\n+{\n+  char *addr = p;\n+#if __LITTLE_ENDIAN__\n+  addr[0] = k;\n+  addr[1] = k >> 8;\n+#else\n+  addr[1] = k;\n+  addr[0] = k >> 8;\n+#endif\n+}\n+\n+__inline__ static\n+void\n+sh_media_unaligned_ST_L (void *p, unsigned int k)\n+{\n+#if __LITTLE_ENDIAN__\n+  sh_media_STHI_L (p, 3, k);\n+  sh_media_STLO_L (p, 0, k);\n+#else\n+  sh_media_STLO_L (p, 3, k);\n+  sh_media_STHI_L (p, 0, k);\n+#endif\n+}\n+\n+__inline__ static\n+void\n+sh_media_unaligned_ST_Q (void *p, unsigned long long k)\n+{\n+#if __LITTLE_ENDIAN__\n+  sh_media_STHI_Q (p, 7, k);\n+  sh_media_STLO_Q (p, 0, k);\n+#else\n+  sh_media_STLO_Q (p, 7, k);\n+  sh_media_STHI_Q (p, 0, k);\n+#endif\n+}\n+\n+#if ! __SH4_NOFPU__\n+__inline__ static\n+void\n+sh_media_FVCOPY_S (const void *fvg, void *fvf)\n+{\n+  const __GCC_FV *g = fvg;\n+  __GCC_FV *f = fvf;\n+  *f = *g;\n+}\n+\n+__inline__ static\n+void\n+sh_media_FVADD_S (const void *fvg, const void *fvh, void *fvf)\n+{\n+  const float *g = fvg, *h = fvh;\n+  float *f = fvf;\n+#if 1\n+  int i;\n+\n+  for (i = 0; i < 4; i++)\n+    f[i] = g[i] + h[i];\n+#else\n+  f[0] = g[0] + h[0];\n+  f[1] = g[1] + h[1];\n+  f[2] = g[2] + h[2];\n+  f[3] = g[3] + h[3];\n+#endif\n+}\n+\n+__inline__ static\n+void\n+sh_media_FVSUB_S (const void *fvg, const void *fvh, void *fvf)\n+{\n+  const float *g = fvg, *h = fvh;\n+  float *f = fvf;\n+#if 1\n+  int i;\n+\n+  for (i = 0; i < 4; i++)\n+    f[i] = g[i] - h[i];\n+#else\n+  f[0] = g[0] - h[0];\n+  f[1] = g[1] - h[1];\n+  f[2] = g[2] - h[2];\n+  f[3] = g[3] - h[3];\n+#endif\n+}\n+\n+__inline__ static\n+void\n+sh_media_FMTRXCOPY_S (const void *mtrxg, void *mtrxf)\n+{\n+  const __GCC_MTRX *g = mtrxg;\n+  __GCC_MTRX *f = mtrxf;\n+  *f = *g;\n+}\n+\n+__inline__ static\n+void\n+sh_media_FMTRXADD_S (const void *mtrxg, const void *mtrxh, void *mtrxf)\n+{\n+  const __GCC_FV *g = mtrxg, *h = mtrxh;\n+  __GCC_FV *f = mtrxf;\n+#if 1\n+  int i;\n+\n+  for (i = 0; i < 4; i++)\n+    sh_media_FVADD_S (&g[i], &h[i], &f[i]);\n+#else\n+  sh_media_FVADD_S (&g[0], &h[0], &f[0]);\n+  sh_media_FVADD_S (&g[1], &h[1], &f[1]);\n+  sh_media_FVADD_S (&g[2], &h[2], &f[2]);\n+  sh_media_FVADD_S (&g[3], &h[3], &f[3]);\n+#endif\n+}\n+\n+__inline__ static\n+void\n+sh_media_FMTRXSUB_S (const void *mtrxg, const void *mtrxh, void *mtrxf)\n+{\n+  const __GCC_FV *g = mtrxg, *h = mtrxh;\n+  __GCC_FV *f = mtrxf;\n+#if 1\n+  int i;\n+\n+  for (i = 0; i < 4; i++)\n+    sh_media_FVSUB_S (&g[i], &h[i], &f[i]);\n+#else\n+  sh_media_FVSUB_S (&g[0], &h[0], &f[0]);\n+  sh_media_FVSUB_S (&g[1], &h[1], &f[1]);\n+  sh_media_FVSUB_S (&g[2], &h[2], &f[2]);\n+  sh_media_FVSUB_S (&g[3], &h[3], &f[3]);\n+#endif\n+}\n+\n+__inline__ static\n+void\n+sh_media_FTRVADD_S (const void *mtrxg, const void *fvh, const void *fvi, void *fvf)\n+{\n+  sh_media_FTRV_S (mtrxg, fvh, fvf);\n+  sh_media_FVADD_S (fvf, fvi, fvf);\n+}\n+\n+__inline__ static\n+void\n+sh_media_FTRVSUB_S (const void *mtrxg, const void *fvh, const void *fvi, void *fvf)\n+{\n+  sh_media_FTRV_S (mtrxg, fvh, fvf);\n+  sh_media_FVSUB_S (fvf, fvi, fvf);\n+}\n+\n+__inline__ static\n+void\n+sh_media_FMTRXMUL_S (const void *mtrxg, const void *mtrxh, void *mtrxf)\n+{\n+  const __GCC_FV *g = mtrxg;\n+  __GCC_FV *f = mtrxf;\n+#if 1\n+  int j;\n+\n+  for (j = 0; j < 4; j++)\n+    sh_media_FTRV_S (mtrxh, &g[j], &f[j]);\n+#else\n+  sh_media_FTRV_S (mtrxh, &g[0], &f[0]);\n+  sh_media_FTRV_S (mtrxh, &g[1], &f[1]);\n+  sh_media_FTRV_S (mtrxh, &g[2], &f[2]);\n+  sh_media_FTRV_S (mtrxh, &g[3], &f[3]);\n+#endif\n+}\n+\n+__inline__ static\n+void\n+sh_media_FMTRXMULADD_S (const void *mtrxg, const void *mtrxh, const void *mtrxi, void *mtrxf)\n+{\n+  const __GCC_FV *g = mtrxg, *i = mtrxi;\n+  __GCC_FV *f = mtrxf;\n+#if 1\n+  int j;\n+\n+  for (j = 0; j < 4; j++)\n+    sh_media_FTRVADD_S (mtrxh, &g[j], &i[j], &f[j]);\n+#else\n+  sh_media_FTRVADD_S (mtrxh, &g[0], &i[0], &f[0]);\n+  sh_media_FTRVADD_S (mtrxh, &g[1], &i[1], &f[1]);\n+  sh_media_FTRVADD_S (mtrxh, &g[2], &i[2], &f[2]);\n+  sh_media_FTRVADD_S (mtrxh, &g[3], &i[3], &f[3]);\n+#endif\n+}\n+\n+__inline__ static\n+void\n+sh_media_FMTRXMULSUB_S (const void *mtrxg, const void *mtrxh, const void *mtrxi, void *mtrxf)\n+{\n+  const __GCC_FV *g = mtrxg, *i = mtrxi;\n+  __GCC_FV *f = mtrxf;\n+#if 1\n+  int j;\n+\n+  for (j = 0; j < 4; j++)\n+    sh_media_FTRVSUB_S (mtrxh, &g[j], &i[j], &f[j]);\n+#else\n+  sh_media_FTRVSUB_S (mtrxh, &g[0], &i[0], &f[0]);\n+  sh_media_FTRVSUB_S (mtrxh, &g[1], &i[1], &f[1]);\n+  sh_media_FTRVSUB_S (mtrxh, &g[2], &i[2], &f[2]);\n+  sh_media_FTRVSUB_S (mtrxh, &g[3], &i[3], &f[3]);\n+#endif\n+}\n+#endif /* ! __SH4_NOFPU__ */\n+\n+#endif /* __SHMEDIA__ */\n+\n+#endif /* _USHMEDIA_H */"}, {"sha": "620edb735c976c19f5d9724ae84b5aa59e2c7685", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa5322fa5824e95a7aa82413782b510c8d91e7d8/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa5322fa5824e95a7aa82413782b510c8d91e7d8/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=fa5322fa5824e95a7aa82413782b510c8d91e7d8", "patch": "@@ -540,6 +540,9 @@ in the following sections.\n @gccoptlist{\n -m1  -m2  -m3  -m3e @gol\n -m4-nofpu  -m4-single-only  -m4-single  -m4 @gol\n+-m5-64media -m5-64media-nofpu @gol\n+-m5-32media -m5-32media-nofpu @gol\n+-m5-compact -m5-compact-nofpu @gol\n -mb  -ml  -mdalign  -mrelax @gol\n -mbigtable  -mfmovd  -mhitachi  -mnomacsave @gol\n -mieee  -misize  -mpadstruct  -mspace @gol"}, {"sha": "663393e74592d6977ccb2bdb479928e4bef400a1", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa5322fa5824e95a7aa82413782b510c8d91e7d8/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa5322fa5824e95a7aa82413782b510c8d91e7d8/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=fa5322fa5824e95a7aa82413782b510c8d91e7d8", "patch": "@@ -3266,6 +3266,22 @@ arguments pop them but other functions (such as @code{printf}) pop\n nothing (the caller pops all).  When this convention is in use,\n @var{funtype} is examined to determine whether a function takes a fixed\n number of arguments.\n+\n+@findex CALL_POPS_ARGS\n+@item   CALL_POPS_ARGS (@var{cum})\n+A C expression that should indicate the number of bytes a call sequence\n+pops off the stack.  It is added to the value of @code{RETURN_POPS_ARGS}\n+when compiling a function call.\n+\n+@var{cum} is the variable in which all arguments to the called function\n+have been accumulated.\n+\n+On certain architectures, such as the SH5, a call trampoline is used\n+that pops certain registers off the stack, depending on the arguments\n+that have been passed to the function.  Since this is a property of the\n+call site, not of the called function, @code{RETURN_POPS_ARGS} is not\n+appropriate.\n+\n @end table\n \n @node Register Arguments"}, {"sha": "c8b9aee1337cf8bc2f332072c9db290726cb34de", "filename": "gcc/longlong.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa5322fa5824e95a7aa82413782b510c8d91e7d8/gcc%2Flonglong.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa5322fa5824e95a7aa82413782b510c8d91e7d8/gcc%2Flonglong.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flonglong.h?ref=fa5322fa5824e95a7aa82413782b510c8d91e7d8", "patch": "@@ -1002,6 +1002,21 @@ UDItype __umulsidi3 (USItype, USItype);\n #define UMUL_TIME 5\n #endif\n \n+#if defined (__SH5__) && __SHMEDIA__ && W_TYPE_SIZE == 32\n+#define __umulsidi3(u,v) ((UDItype)(USItype)u*(USItype)v)\n+#define count_leading_zeros(count, x) \\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      UDItype x_ = (USItype)(x);\t\t\t\t\t\\\n+      SItype c_;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      __asm__ (\"nsb %1, %0\" : \"=r\" (c_) : \"r\" (x_));\t\t\t\\\n+      (count) = c_ - 31;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+#define COUNT_LEADING_ZEROS_0 32\n+#endif\n+\n #if defined (__sparc__) && !defined (__arch64__) && !defined (__sparcv9) \\\n     && W_TYPE_SIZE == 32\n #define add_ssaaaa(sh, sl, ah, al, bh, bl) \\"}, {"sha": "5ec6a1ea1825ad03665e333518fdf938ae5f9218", "filename": "gcc/machmode.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa5322fa5824e95a7aa82413782b510c8d91e7d8/gcc%2Fmachmode.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa5322fa5824e95a7aa82413782b510c8d91e7d8/gcc%2Fmachmode.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.def?ref=fa5322fa5824e95a7aa82413782b510c8d91e7d8", "patch": "@@ -139,6 +139,7 @@ DEF_MACHMODE (V4DFmode, \"V4DF\", MODE_VECTOR_FLOAT, BITS_PER_UNIT*32, 32, 8, V8DF\n \n DEF_MACHMODE (V8SFmode, \"V8SF\", MODE_VECTOR_FLOAT, BITS_PER_UNIT*32, 32, 4,V4DFmode)\n DEF_MACHMODE (V8DFmode, \"V8DF\", MODE_VECTOR_FLOAT, BITS_PER_UNIT*64, 64, 8, VOIDmode)\n+DEF_MACHMODE (V16SFmode, \"V16SF\", MODE_VECTOR_FLOAT, 512, 64, 4, VOIDmode)\n \n /* BLKmode is used for structures, arrays, etc.\n    that fit no more specific mode.  */"}, {"sha": "d664866301d9f69243957b20d51698c9105ea76d", "filename": "gcc/tree.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa5322fa5824e95a7aa82413782b510c8d91e7d8/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa5322fa5824e95a7aa82413782b510c8d91e7d8/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=fa5322fa5824e95a7aa82413782b510c8d91e7d8", "patch": "@@ -4907,6 +4907,7 @@ build_common_tree_nodes_2 (short_double)\n   unsigned_V16QI_type_node\n     = make_vector (V16QImode, unsigned_intQI_type_node, 1);\n \n+  V16SF_type_node = make_vector (V16SFmode, float_type_node, 0);\n   V4SF_type_node = make_vector (V4SFmode, float_type_node, 0);\n   V4SI_type_node = make_vector (V4SImode, intSI_type_node, 0);\n   V2SI_type_node = make_vector (V2SImode, intSI_type_node, 0);"}, {"sha": "fe4e0335012596751ed0ea97b9d43bc84337d0f3", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa5322fa5824e95a7aa82413782b510c8d91e7d8/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa5322fa5824e95a7aa82413782b510c8d91e7d8/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=fa5322fa5824e95a7aa82413782b510c8d91e7d8", "patch": "@@ -1910,6 +1910,7 @@ enum tree_index\n   TI_UV16QI_TYPE,\n \n   TI_V4SF_TYPE,\n+  TI_V16SF_TYPE,\n   TI_V4SI_TYPE,\n   TI_V8HI_TYPE,\n   TI_V8QI_TYPE,\n@@ -1992,6 +1993,7 @@ extern tree global_trees[TI_MAX];\n #define V4HI_type_node\t\t\tglobal_trees[TI_V4HI_TYPE]\n #define V2SI_type_node\t\t\tglobal_trees[TI_V2SI_TYPE]\n #define V2SF_type_node\t\t\tglobal_trees[TI_V2SF_TYPE]\n+#define V16SF_type_node\t\t\tglobal_trees[TI_V16SF_TYPE]\n \n /* An enumeration of the standard C integer types.  These must be\n    ordered so that shorter types appear before longer ones.  */"}]}