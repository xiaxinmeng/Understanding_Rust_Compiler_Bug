{"sha": "c788734738f1afd93b5b78c0e22e013e9c9720eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzc4ODczNDczOGYxYWZkOTNiNWI3OGMwZTIyZTAxM2U5Yzk3MjBlYg==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2018-10-31T14:46:17Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2018-10-31T14:46:17Z"}, "message": "Provide extension hint for aarch64 target (PR driver/83193).\n\n2018-10-31  Martin Liska  <mliska@suse.cz>\n\n\tPR driver/83193\n\t* common/config/aarch64/aarch64-common.c (aarch64_parse_extension):\n\tAdd new argument invalid_extension.\n\t(aarch64_get_all_extension_candidates): New function.\n\t(aarch64_rewrite_selected_cpu): Add NULL to function call.\n\t* config/aarch64/aarch64-protos.h (aarch64_parse_extension): Add\n\tnew argument.\n\t(aarch64_get_all_extension_candidates): New function.\n\t* config/aarch64/aarch64.c (aarch64_parse_arch): Add new\n\targument invalid_extension.\n\t(aarch64_parse_cpu): Likewise.\n\t(aarch64_print_hint_for_extensions): New function.\n\t(aarch64_validate_mcpu): Provide hint about invalid extension.\n\t(aarch64_validate_march): Likewise.\n\t(aarch64_handle_attr_arch): Pass new argument.\n\t(aarch64_handle_attr_cpu): Provide hint about invalid extension.\n\t(aarch64_handle_attr_isa_flags): Likewise.\n2018-10-31  Martin Liska  <mliska@suse.cz>\n\n\tPR driver/83193\n\t* gcc.target/aarch64/spellcheck_7.c: New test.\n\t* gcc.target/aarch64/spellcheck_8.c: New test.\n\t* gcc.target/aarch64/spellcheck_9.c: New test.\n\nFrom-SVN: r265686", "tree": {"sha": "f8dde731c2ee6e256337d534c545f2fa7823bb00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f8dde731c2ee6e256337d534c545f2fa7823bb00"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c788734738f1afd93b5b78c0e22e013e9c9720eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c788734738f1afd93b5b78c0e22e013e9c9720eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c788734738f1afd93b5b78c0e22e013e9c9720eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c788734738f1afd93b5b78c0e22e013e9c9720eb/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ff65e98035f39bbd577fd50ccafa7743d4ac42a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff65e98035f39bbd577fd50ccafa7743d4ac42a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff65e98035f39bbd577fd50ccafa7743d4ac42a5"}], "stats": {"total": 160, "additions": 140, "deletions": 20}, "files": [{"sha": "26cfa87d6b825edd6add7bdbf713548fc8d4259d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c788734738f1afd93b5b78c0e22e013e9c9720eb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c788734738f1afd93b5b78c0e22e013e9c9720eb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c788734738f1afd93b5b78c0e22e013e9c9720eb", "patch": "@@ -1,3 +1,23 @@\n+2018-10-31  Martin Liska  <mliska@suse.cz>\n+\n+\tPR driver/83193\n+\t* common/config/aarch64/aarch64-common.c (aarch64_parse_extension):\n+\tAdd new argument invalid_extension.\n+\t(aarch64_get_all_extension_candidates): New function.\n+\t(aarch64_rewrite_selected_cpu): Add NULL to function call.\n+\t* config/aarch64/aarch64-protos.h (aarch64_parse_extension): Add\n+\tnew argument.\n+\t(aarch64_get_all_extension_candidates): New function.\n+\t* config/aarch64/aarch64.c (aarch64_parse_arch): Add new\n+\targument invalid_extension.\n+\t(aarch64_parse_cpu): Likewise.\n+\t(aarch64_print_hint_for_extensions): New function.\n+\t(aarch64_validate_mcpu): Provide hint about invalid extension.\n+\t(aarch64_validate_march): Likewise.\n+\t(aarch64_handle_attr_arch): Pass new argument.\n+\t(aarch64_handle_attr_cpu): Provide hint about invalid extension.\n+\t(aarch64_handle_attr_isa_flags): Likewise.\n+\n 2018-10-31  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/70359"}, {"sha": "dd7d42673402c3cf16ebce009d263d62d574690a", "filename": "gcc/common/config/aarch64/aarch64-common.c", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c788734738f1afd93b5b78c0e22e013e9c9720eb/gcc%2Fcommon%2Fconfig%2Faarch64%2Faarch64-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c788734738f1afd93b5b78c0e22e013e9c9720eb/gcc%2Fcommon%2Fconfig%2Faarch64%2Faarch64-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Faarch64%2Faarch64-common.c?ref=c788734738f1afd93b5b78c0e22e013e9c9720eb", "patch": "@@ -220,10 +220,13 @@ static const struct arch_to_arch_name all_architectures[] =\n \n /* Parse the architecture extension string STR and update ISA_FLAGS\n    with the architecture features turned on or off.  Return a\n-   aarch64_parse_opt_result describing the result.  */\n+   aarch64_parse_opt_result describing the result.\n+   When the STR string contains an invalid extension,\n+   a copy of the string is created and stored to INVALID_EXTENSION.  */\n \n enum aarch64_parse_opt_result\n-aarch64_parse_extension (const char *str, unsigned long *isa_flags)\n+aarch64_parse_extension (const char *str, unsigned long *isa_flags,\n+\t\t\t std::string *invalid_extension)\n {\n   /* The extension string is parsed left to right.  */\n   const struct aarch64_option_extension *opt = NULL;\n@@ -274,6 +277,8 @@ aarch64_parse_extension (const char *str, unsigned long *isa_flags)\n       if (opt->name == NULL)\n \t{\n \t  /* Extension not found in list.  */\n+\t  if (invalid_extension)\n+\t    *invalid_extension = std::string (str, len);\n \t  return AARCH64_PARSE_INVALID_FEATURE;\n \t}\n \n@@ -283,6 +288,16 @@ aarch64_parse_extension (const char *str, unsigned long *isa_flags)\n   return AARCH64_PARSE_OK;\n }\n \n+/* Append all architecture extension candidates to the CANDIDATES vector.  */\n+\n+void\n+aarch64_get_all_extension_candidates (auto_vec<const char *> *candidates)\n+{\n+  const struct aarch64_option_extension *opt;\n+  for (opt = all_extensions; opt->name != NULL; opt++)\n+    candidates->safe_push (opt->name);\n+}\n+\n /* Return a string representation of ISA_FLAGS.  DEFAULT_ARCH_FLAGS\n    gives the default set of flags which are implied by whatever -march\n    we'd put out.  Our job is to figure out the minimal set of \"+\" and\n@@ -370,7 +385,7 @@ aarch64_rewrite_selected_cpu (const char *name)\n     fatal_error (input_location, \"unknown value %qs for -mcpu\", name);\n \n   unsigned long extensions = p_to_a->flags;\n-  aarch64_parse_extension (extension_str.c_str (), &extensions);\n+  aarch64_parse_extension (extension_str.c_str (), &extensions, NULL);\n \n   std::string outstr = a_to_an->arch_name\n \t+ aarch64_get_extension_string_for_isa_flags (extensions,"}, {"sha": "1fe1a50d52aeb3719cf30c4a2af41abb8dd7233d", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c788734738f1afd93b5b78c0e22e013e9c9720eb/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c788734738f1afd93b5b78c0e22e013e9c9720eb/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=c788734738f1afd93b5b78c0e22e013e9c9720eb", "patch": "@@ -613,7 +613,9 @@ bool aarch64_handle_option (struct gcc_options *, struct gcc_options *,\n \t\t\t     const struct cl_decoded_option *, location_t);\n const char *aarch64_rewrite_selected_cpu (const char *name);\n enum aarch64_parse_opt_result aarch64_parse_extension (const char *,\n-\t\t\t\t\t\t       unsigned long *);\n+\t\t\t\t\t\t       unsigned long *,\n+\t\t\t\t\t\t       std::string *);\n+void aarch64_get_all_extension_candidates (auto_vec<const char *> *candidates);\n std::string aarch64_get_extension_string_for_isa_flags (unsigned long,\n \t\t\t\t\t\t\tunsigned long);\n "}, {"sha": "b44ee40115dce526c7cc302b2a47c28ab8b41508", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 54, "deletions": 16, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c788734738f1afd93b5b78c0e22e013e9c9720eb/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c788734738f1afd93b5b78c0e22e013e9c9720eb/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=c788734738f1afd93b5b78c0e22e013e9c9720eb", "patch": "@@ -10545,11 +10545,13 @@ static void initialize_aarch64_code_model (struct gcc_options *);\n /* Parse the TO_PARSE string and put the architecture struct that it\n    selects into RES and the architectural features into ISA_FLAGS.\n    Return an aarch64_parse_opt_result describing the parse result.\n-   If there is an error parsing, RES and ISA_FLAGS are left unchanged.  */\n+   If there is an error parsing, RES and ISA_FLAGS are left unchanged.\n+   When the TO_PARSE string contains an invalid extension,\n+   a copy of the string is created and stored to INVALID_EXTENSION.  */\n \n static enum aarch64_parse_opt_result\n aarch64_parse_arch (const char *to_parse, const struct processor **res,\n-\t\t    unsigned long *isa_flags)\n+\t\t    unsigned long *isa_flags, std::string *invalid_extension)\n {\n   char *ext;\n   const struct processor *arch;\n@@ -10580,7 +10582,7 @@ aarch64_parse_arch (const char *to_parse, const struct processor **res,\n \t    {\n \t      /* TO_PARSE string contains at least one extension.  */\n \t      enum aarch64_parse_opt_result ext_res\n-\t\t= aarch64_parse_extension (ext, &isa_temp);\n+\t\t= aarch64_parse_extension (ext, &isa_temp, invalid_extension);\n \n \t      if (ext_res != AARCH64_PARSE_OK)\n \t\treturn ext_res;\n@@ -10600,11 +10602,13 @@ aarch64_parse_arch (const char *to_parse, const struct processor **res,\n /* Parse the TO_PARSE string and put the result tuning in RES and the\n    architecture flags in ISA_FLAGS.  Return an aarch64_parse_opt_result\n    describing the parse result.  If there is an error parsing, RES and\n-   ISA_FLAGS are left unchanged.  */\n+   ISA_FLAGS are left unchanged.\n+   When the TO_PARSE string contains an invalid extension,\n+   a copy of the string is created and stored to INVALID_EXTENSION.  */\n \n static enum aarch64_parse_opt_result\n aarch64_parse_cpu (const char *to_parse, const struct processor **res,\n-\t\t   unsigned long *isa_flags)\n+\t\t   unsigned long *isa_flags, std::string *invalid_extension)\n {\n   char *ext;\n   const struct processor *cpu;\n@@ -10636,7 +10640,7 @@ aarch64_parse_cpu (const char *to_parse, const struct processor **res,\n \t    {\n \t      /* TO_PARSE string contains at least one extension.  */\n \t      enum aarch64_parse_opt_result ext_res\n-\t\t= aarch64_parse_extension (ext, &isa_temp);\n+\t\t= aarch64_parse_extension (ext, &isa_temp, invalid_extension);\n \n \t      if (ext_res != AARCH64_PARSE_OK)\n \t\treturn ext_res;\n@@ -11118,6 +11122,26 @@ aarch64_print_hint_for_arch (const char *str)\n   aarch64_print_hint_for_core_or_arch (str, true);\n }\n \n+\n+/* Print a hint with a suggestion for an extension name\n+   that most closely resembles what the user passed in STR.  */\n+\n+void\n+aarch64_print_hint_for_extensions (const std::string &str)\n+{\n+  auto_vec<const char *> candidates;\n+  aarch64_get_all_extension_candidates (&candidates);\n+  char *s;\n+  const char *hint = candidates_list_and_hint (str.c_str (), s, candidates);\n+  if (hint)\n+    inform (input_location, \"valid arguments are: %s;\"\n+\t\t\t     \" did you mean %qs?\", s, hint);\n+  else\n+    inform (input_location, \"valid arguments are: %s;\", s);\n+\n+  XDELETEVEC (s);\n+}\n+\n /* Validate a command-line -mcpu option.  Parse the cpu and extensions (if any)\n    specified in STR and throw errors if appropriate.  Put the results if\n    they are valid in RES and ISA_FLAGS.  Return whether the option is\n@@ -11127,8 +11151,9 @@ static bool\n aarch64_validate_mcpu (const char *str, const struct processor **res,\n \t\t       unsigned long *isa_flags)\n {\n+  std::string invalid_extension;\n   enum aarch64_parse_opt_result parse_res\n-    = aarch64_parse_cpu (str, res, isa_flags);\n+    = aarch64_parse_cpu (str, res, isa_flags, &invalid_extension);\n \n   if (parse_res == AARCH64_PARSE_OK)\n     return true;\n@@ -11143,7 +11168,9 @@ aarch64_validate_mcpu (const char *str, const struct processor **res,\n \taarch64_print_hint_for_core (str);\n \tbreak;\n       case AARCH64_PARSE_INVALID_FEATURE:\n-\terror (\"invalid feature modifier in %<-mcpu=%s%>\", str);\n+\terror (\"invalid feature modifier %qs in %<-mcpu=%s%>\",\n+\t       invalid_extension.c_str (), str);\n+\taarch64_print_hint_for_extensions (invalid_extension);\n \tbreak;\n       default:\n \tgcc_unreachable ();\n@@ -11161,8 +11188,9 @@ static bool\n aarch64_validate_march (const char *str, const struct processor **res,\n \t\t\t unsigned long *isa_flags)\n {\n+  std::string invalid_extension;\n   enum aarch64_parse_opt_result parse_res\n-    = aarch64_parse_arch (str, res, isa_flags);\n+    = aarch64_parse_arch (str, res, isa_flags, &invalid_extension);\n \n   if (parse_res == AARCH64_PARSE_OK)\n     return true;\n@@ -11177,7 +11205,9 @@ aarch64_validate_march (const char *str, const struct processor **res,\n \taarch64_print_hint_for_arch (str);\n \tbreak;\n       case AARCH64_PARSE_INVALID_FEATURE:\n-\terror (\"invalid feature modifier in %<-march=%s%>\", str);\n+\terror (\"invalid feature modifier %qs in %<-march=%s%>\",\n+\t       invalid_extension.c_str (), str);\n+\taarch64_print_hint_for_extensions (invalid_extension);\n \tbreak;\n       default:\n \tgcc_unreachable ();\n@@ -11577,8 +11607,9 @@ static bool\n aarch64_handle_attr_arch (const char *str)\n {\n   const struct processor *tmp_arch = NULL;\n+  std::string invalid_extension;\n   enum aarch64_parse_opt_result parse_res\n-    = aarch64_parse_arch (str, &tmp_arch, &aarch64_isa_flags);\n+    = aarch64_parse_arch (str, &tmp_arch, &aarch64_isa_flags, &invalid_extension);\n \n   if (parse_res == AARCH64_PARSE_OK)\n     {\n@@ -11598,7 +11629,9 @@ aarch64_handle_attr_arch (const char *str)\n \taarch64_print_hint_for_arch (str);\n \tbreak;\n       case AARCH64_PARSE_INVALID_FEATURE:\n-\terror (\"invalid value (\\\"%s\\\") in %<target()%> pragma or attribute\", str);\n+\terror (\"invalid feature modifier %s of value (\\\"%s\\\") in \"\n+\t       \"%<target()%> pragma or attribute\", invalid_extension.c_str (), str);\n+\taarch64_print_hint_for_extensions (invalid_extension);\n \tbreak;\n       default:\n \tgcc_unreachable ();\n@@ -11613,8 +11646,9 @@ static bool\n aarch64_handle_attr_cpu (const char *str)\n {\n   const struct processor *tmp_cpu = NULL;\n+  std::string invalid_extension;\n   enum aarch64_parse_opt_result parse_res\n-    = aarch64_parse_cpu (str, &tmp_cpu, &aarch64_isa_flags);\n+    = aarch64_parse_cpu (str, &tmp_cpu, &aarch64_isa_flags, &invalid_extension);\n \n   if (parse_res == AARCH64_PARSE_OK)\n     {\n@@ -11637,7 +11671,9 @@ aarch64_handle_attr_cpu (const char *str)\n \taarch64_print_hint_for_core (str);\n \tbreak;\n       case AARCH64_PARSE_INVALID_FEATURE:\n-\terror (\"invalid value (\\\"%s\\\") in %<target()%> pragma or attribute\", str);\n+\terror (\"invalid feature modifier %s of value (\\\"%s\\\") in \"\n+\t       \"%<target()%> pragma or attribute\", invalid_extension.c_str (), str);\n+\taarch64_print_hint_for_extensions (invalid_extension);\n \tbreak;\n       default:\n \tgcc_unreachable ();\n@@ -11695,7 +11731,8 @@ aarch64_handle_attr_isa_flags (char *str)\n       str += 8;\n     }\n \n-  parse_res = aarch64_parse_extension (str, &isa_flags);\n+  std::string invalid_extension;\n+  parse_res = aarch64_parse_extension (str, &isa_flags, &invalid_extension);\n \n   if (parse_res == AARCH64_PARSE_OK)\n     {\n@@ -11710,7 +11747,8 @@ aarch64_handle_attr_isa_flags (char *str)\n \tbreak;\n \n       case AARCH64_PARSE_INVALID_FEATURE:\n-\terror (\"invalid value (\\\"%s\\\") in %<target()%> pragma or attribute\", str);\n+\terror (\"invalid feature modifier %s of value (\\\"%s\\\") in \"\n+\t       \"%<target()%> pragma or attribute\", invalid_extension.c_str (), str);\n \tbreak;\n \n       default:"}, {"sha": "d6b6780be13a707faf99042a7f5f47a73fba9fc1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c788734738f1afd93b5b78c0e22e013e9c9720eb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c788734738f1afd93b5b78c0e22e013e9c9720eb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c788734738f1afd93b5b78c0e22e013e9c9720eb", "patch": "@@ -1,3 +1,10 @@\n+2018-10-31  Martin Liska  <mliska@suse.cz>\n+\n+\tPR driver/83193\n+\t* gcc.target/aarch64/spellcheck_7.c: New test.\n+\t* gcc.target/aarch64/spellcheck_8.c: New test.\n+\t* gcc.target/aarch64/spellcheck_9.c: New test.\n+\n 2018-10-31  Nathan Sidwell  <nathan@acm.org>\n \n \t* g++.dg/lookup/using60.C: New."}, {"sha": "1d31950cb610e255d3b5d59d1ac60fe5caf24e84", "filename": "gcc/testsuite/gcc.target/aarch64/spellcheck_7.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c788734738f1afd93b5b78c0e22e013e9c9720eb/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fspellcheck_7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c788734738f1afd93b5b78c0e22e013e9c9720eb/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fspellcheck_7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fspellcheck_7.c?ref=c788734738f1afd93b5b78c0e22e013e9c9720eb", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-march=*\" } { \"\" } } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-mcpu=*\" } { \"\" } } */\n+/* { dg-options \"-march=armv8-a+typo\" } */\n+\n+void\n+foo ()\n+{\n+}\n+\n+/* { dg-error \"invalid feature modifier .typo. in .-march=armv8-a\\\\+typo.\"  \"\" { target *-*-* } 0 } */\n+/* { dg-message \"valid arguments are: \\[^\\n\\r]*;'?\"  \"\" { target *-*-* } 0 } */"}, {"sha": "1b8c5ebfeb1cb42aeb03b78aff3a056e48d733b0", "filename": "gcc/testsuite/gcc.target/aarch64/spellcheck_8.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c788734738f1afd93b5b78c0e22e013e9c9720eb/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fspellcheck_8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c788734738f1afd93b5b78c0e22e013e9c9720eb/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fspellcheck_8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fspellcheck_8.c?ref=c788734738f1afd93b5b78c0e22e013e9c9720eb", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-march=*\" } { \"\" } } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-mcpu=*\" } { \"\" } } */\n+/* { dg-options \"-march=armv8-a+cripto\" } */\n+\n+void\n+foo ()\n+{\n+}\n+\n+/* { dg-error \"invalid feature modifier .cripto. in .-march=armv8-a\\\\+cripto.\"  \"\" { target *-*-* } 0 } */\n+/* { dg-message \"valid arguments are: \\[^\\n\\r]*; did you mean .crypto.?\"  \"\" { target *-*-* } 0 } */\n+"}, {"sha": "ad5b82589c11c22f641f02c19e40eea055ceac29", "filename": "gcc/testsuite/gcc.target/aarch64/spellcheck_9.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c788734738f1afd93b5b78c0e22e013e9c9720eb/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fspellcheck_9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c788734738f1afd93b5b78c0e22e013e9c9720eb/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fspellcheck_9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fspellcheck_9.c?ref=c788734738f1afd93b5b78c0e22e013e9c9720eb", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-march=*\" } { \"\" } } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-mcpu=*\" } { \"\" } } */\n+/* { dg-options \"-mcpu=thunderx+cripto\" } */\n+\n+void\n+foo ()\n+{\n+}\n+\n+/* { dg-error \"invalid feature modifier .cripto. in .-mcpu=thunderx\\\\+cripto.\"  \"\" { target *-*-* } 0 } */\n+/* { dg-message \"valid arguments are: \\[^\\n\\r]*; did you mean .crypto.?\"  \"\" { target *-*-* } 0 } */\n+"}]}