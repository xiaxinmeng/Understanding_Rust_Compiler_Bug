{"sha": "20dc266e5a178fd87bb8ae6ebbf63e391f74e9b0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjBkYzI2NmU1YTE3OGZkODdiYjhhZTZlYmJmNjNlMzkxZjc0ZTliMA==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2019-12-13T09:04:18Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-12-13T09:04:18Z"}, "message": "[Ada] Deallocation of controlled type implementing interface types\n\n2019-12-13  Javier Miranda  <miranda@adacore.com>\n\ngcc/ada/\n\n\t* exp_disp.ads (Expand_Interface_Thunk): Adding one formal (the\n\tinterface type).\n\t* exp_disp.adb (Expand_Interface_Thunk): Using the added formal\n\tto ensure the correct profile of the thunk generated for\n\tpredefined primitives; in addition, the added formal is also\n\tused to perform a check that ensures that the controlling type\n\tof the thunk is the one expected by the GCC backend.\n\t(Make_Secondary_DT, Register_Primitive): Adding the new formal\n\tto the calls to Expand_Interface_Thunk.\n\t* exp_ch6.adb (Register_Predefined_DT_Entry): Adding the new\n\tformal to the call to Expand_Interface_Thunk.\n\t* exp_intr.adb (Expand_Unc_Deallocation): When deallocating a\n\tcontrolled type and the call to unchecked deallocation is\n\tperformed with a pointer to one of the convered interface types,\n\tdisplace the pointer to the object to reference the base of the\n\tobject to deallocate its memory.\n\t* gcc-interface/trans.c (maybe_make_gnu_thunk): Assert that the\n\tcontrolling type of the thunk is an interface type.\n\nFrom-SVN: r279351", "tree": {"sha": "76f6ee6f563585d48c5854f40e3ced0a9640bc7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/76f6ee6f563585d48c5854f40e3ced0a9640bc7e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/20dc266e5a178fd87bb8ae6ebbf63e391f74e9b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20dc266e5a178fd87bb8ae6ebbf63e391f74e9b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20dc266e5a178fd87bb8ae6ebbf63e391f74e9b0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20dc266e5a178fd87bb8ae6ebbf63e391f74e9b0/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6c9e4a1d65bc7ff2747f714ebb48a41827f4f74b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c9e4a1d65bc7ff2747f714ebb48a41827f4f74b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c9e4a1d65bc7ff2747f714ebb48a41827f4f74b"}], "stats": {"total": 101, "additions": 88, "deletions": 13}, "files": [{"sha": "b4ed0d5705666c31ebeadc86278ce660d3269a0b", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20dc266e5a178fd87bb8ae6ebbf63e391f74e9b0/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20dc266e5a178fd87bb8ae6ebbf63e391f74e9b0/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=20dc266e5a178fd87bb8ae6ebbf63e391f74e9b0", "patch": "@@ -1,3 +1,24 @@\n+2019-12-13  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_disp.ads (Expand_Interface_Thunk): Adding one formal (the\n+\tinterface type).\n+\t* exp_disp.adb (Expand_Interface_Thunk): Using the added formal\n+\tto ensure the correct profile of the thunk generated for\n+\tpredefined primitives; in addition, the added formal is also\n+\tused to perform a check that ensures that the controlling type\n+\tof the thunk is the one expected by the GCC backend.\n+\t(Make_Secondary_DT, Register_Primitive): Adding the new formal\n+\tto the calls to Expand_Interface_Thunk.\n+\t* exp_ch6.adb (Register_Predefined_DT_Entry): Adding the new\n+\tformal to the call to Expand_Interface_Thunk.\n+\t* exp_intr.adb (Expand_Unc_Deallocation): When deallocating a\n+\tcontrolled type and the call to unchecked deallocation is\n+\tperformed with a pointer to one of the convered interface types,\n+\tdisplace the pointer to the object to reference the base of the\n+\tobject to deallocate its memory.\n+\t* gcc-interface/trans.c (maybe_make_gnu_thunk): Assert that the\n+\tcontrolling type of the thunk is an interface type.\n+\n 2019-12-13  Bob Duff  <duff@adacore.com>\n \n \t* exp_attr.adb (Is_Available): Remove this function, and replace"}, {"sha": "c03cd7c535286b67f9fd7c8dbe1c02eb2b532c6a", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20dc266e5a178fd87bb8ae6ebbf63e391f74e9b0/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20dc266e5a178fd87bb8ae6ebbf63e391f74e9b0/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=20dc266e5a178fd87bb8ae6ebbf63e391f74e9b0", "patch": "@@ -7607,7 +7607,8 @@ package body Exp_Ch6 is\n            and then Ekind (Node (Iface_DT_Ptr)) = E_Constant\n          loop\n             pragma Assert (Has_Thunks (Node (Iface_DT_Ptr)));\n-            Expand_Interface_Thunk (Prim, Thunk_Id, Thunk_Code);\n+            Expand_Interface_Thunk (Prim, Thunk_Id, Thunk_Code,\n+              Iface => Related_Type (Node (Iface_DT_Ptr)));\n \n             if Present (Thunk_Code) then\n                Insert_Actions_After (N, New_List ("}, {"sha": "4663a086d546b09e720a2d34997d8237c349133d", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 34, "deletions": 5, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20dc266e5a178fd87bb8ae6ebbf63e391f74e9b0/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20dc266e5a178fd87bb8ae6ebbf63e391f74e9b0/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=20dc266e5a178fd87bb8ae6ebbf63e391f74e9b0", "patch": "@@ -1850,7 +1850,8 @@ package body Exp_Disp is\n    procedure Expand_Interface_Thunk\n      (Prim       : Node_Id;\n       Thunk_Id   : out Entity_Id;\n-      Thunk_Code : out Node_Id)\n+      Thunk_Code : out Node_Id;\n+      Iface      : Entity_Id)\n    is\n       Loc     : constant Source_Ptr := Sloc (Prim);\n       Actuals : constant List_Id    := New_List;\n@@ -1912,12 +1913,38 @@ package body Exp_Disp is\n          --  Use the interface type as the type of the controlling formal (see\n          --  comment above).\n \n-         if not Is_Controlling_Formal (Formal) or else Is_Predef_Op then\n+         if not Is_Controlling_Formal (Formal) then\n             Ftyp := Etype (Formal);\n             Expr := New_Copy_Tree (Expression (Parent (Formal)));\n+\n+         --  For predefined primitives the controlling type of the thunk is\n+         --  the interface type passed by the caller (since they don't have\n+         --  available the Interface_Alias attribute; see comment above).\n+\n+         elsif Is_Predef_Op then\n+            Ftyp := Iface;\n+            Expr := Empty;\n+\n          else\n             Ftyp := Etype (Iface_Formal);\n             Expr := Empty;\n+\n+            --  Sanity check performed to ensure the proper controlling type\n+            --  when the thunk has exactly one controlling parameter and it\n+            --  comes first. In such case the GCC backend reuses the C++\n+            --  thunks machinery which perform a computation equivalent to\n+            --  the code generated by the expander; for other cases the GCC\n+            --  backend translates the expanded code unmodified. However, as\n+            --  a generalization, the check is performed for all controlling\n+            --  types.\n+\n+            if Is_Access_Type (Ftyp) then\n+               pragma Assert (Base_Type (Designated_Type (Ftyp)) = Iface);\n+               null;\n+            else\n+               Ftyp := Base_Type (Ftyp);\n+               pragma Assert (Ftyp = Iface);\n+            end if;\n          end if;\n \n          Append_To (Formals,\n@@ -4073,7 +4100,8 @@ package body Exp_Disp is\n                           Alias (Prim);\n \n                      else\n-                        Expand_Interface_Thunk (Prim, Thunk_Id, Thunk_Code);\n+                        Expand_Interface_Thunk\n+                          (Prim, Thunk_Id, Thunk_Code, Iface);\n \n                         if Present (Thunk_Id) then\n                            Append_To (Result, Thunk_Code);\n@@ -4379,7 +4407,8 @@ package body Exp_Disp is\n                         Prim_Table (Prim_Pos) := Alias (Prim);\n \n                      else\n-                        Expand_Interface_Thunk (Prim, Thunk_Id, Thunk_Code);\n+                        Expand_Interface_Thunk\n+                          (Prim, Thunk_Id, Thunk_Code, Iface);\n \n                         if Present (Thunk_Id) then\n                            Prim_Pos :=\n@@ -7507,7 +7536,7 @@ package body Exp_Disp is\n             return L;\n          end if;\n \n-         Expand_Interface_Thunk (Prim, Thunk_Id, Thunk_Code);\n+         Expand_Interface_Thunk (Prim, Thunk_Id, Thunk_Code, Iface_Typ);\n \n          if not Is_Ancestor (Iface_Typ, Tag_Typ, Use_Full_View => True)\n            and then Present (Thunk_Code)"}, {"sha": "5c490dfb9af7de2ad49aea333a778503b205ae43", "filename": "gcc/ada/exp_disp.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20dc266e5a178fd87bb8ae6ebbf63e391f74e9b0/gcc%2Fada%2Fexp_disp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20dc266e5a178fd87bb8ae6ebbf63e391f74e9b0/gcc%2Fada%2Fexp_disp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.ads?ref=20dc266e5a178fd87bb8ae6ebbf63e391f74e9b0", "patch": "@@ -242,7 +242,8 @@ package Exp_Disp is\n    procedure Expand_Interface_Thunk\n      (Prim       : Node_Id;\n       Thunk_Id   : out Entity_Id;\n-      Thunk_Code : out Node_Id);\n+      Thunk_Code : out Node_Id;\n+      Iface      : Entity_Id);\n    --  Ada 2005 (AI-251): When a tagged type implements abstract interfaces we\n    --  generate additional subprograms (thunks) associated with each primitive\n    --  Prim to have a layout compatible with the C++ ABI. The thunk displaces"}, {"sha": "78555bf41065c4aa5899cbeaf2725a4bbc40dfac", "filename": "gcc/ada/exp_intr.adb", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20dc266e5a178fd87bb8ae6ebbf63e391f74e9b0/gcc%2Fada%2Fexp_intr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20dc266e5a178fd87bb8ae6ebbf63e391f74e9b0/gcc%2Fada%2Fexp_intr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_intr.adb?ref=20dc266e5a178fd87bb8ae6ebbf63e391f74e9b0", "patch": "@@ -988,9 +988,31 @@ package body Exp_Intr is\n       --  are allowed, the generated code may lack block statements.\n \n       if Needs_Fin then\n-         Obj_Ref :=\n-           Make_Explicit_Dereference (Loc,\n-             Prefix => Duplicate_Subexpr_No_Checks (Arg));\n+\n+         --  Ada 2005 (AI-251): In case of abstract interface type we displace\n+         --  the pointer to reference the base of the object to deallocate its\n+         --  memory, unless we're targetting a VM, in which case no special\n+         --  processing is required.\n+\n+         if Is_Interface (Directly_Designated_Type (Typ))\n+           and then Tagged_Type_Expansion\n+         then\n+            Obj_Ref :=\n+              Make_Explicit_Dereference (Loc,\n+                Prefix =>\n+                  Unchecked_Convert_To (Typ,\n+                    Make_Function_Call (Loc,\n+                      Name                   =>\n+                        New_Occurrence_Of (RTE (RE_Base_Address), Loc),\n+                      Parameter_Associations => New_List (\n+                        Unchecked_Convert_To (RTE (RE_Address),\n+                          Duplicate_Subexpr_No_Checks (Arg))))));\n+\n+         else\n+            Obj_Ref :=\n+              Make_Explicit_Dereference (Loc,\n+                Prefix => Duplicate_Subexpr_No_Checks (Arg));\n+         end if;\n \n          --  If the designated type is tagged, the finalization call must\n          --  dispatch because the designated type may not be the actual type"}, {"sha": "ef16a08498bd67362500755e3088dbe5a497daf1", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20dc266e5a178fd87bb8ae6ebbf63e391f74e9b0/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20dc266e5a178fd87bb8ae6ebbf63e391f74e9b0/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=20dc266e5a178fd87bb8ae6ebbf63e391f74e9b0", "patch": "@@ -11287,11 +11287,12 @@ maybe_make_gnu_thunk (Entity_Id gnat_thunk, tree gnu_thunk)\n   const Entity_Id gnat_controlling_type = get_controlling_type (gnat_target);\n   const Entity_Id gnat_interface_type = get_controlling_type (gnat_thunk);\n \n+  /* We must have an interface type at this point.  */\n+  gcc_assert (Is_Interface (gnat_interface_type));\n+\n   /* Now compute whether the former covers the latter.  */\n   const Entity_Id gnat_interface_tag\n-    = Is_Interface (gnat_interface_type)\n-      ? Find_Interface_Tag (gnat_controlling_type, gnat_interface_type)\n-      : Empty;\n+    = Find_Interface_Tag (gnat_controlling_type, gnat_interface_type);\n   tree gnu_interface_tag\n     = Present (gnat_interface_tag)\n       ? gnat_to_gnu_field_decl (gnat_interface_tag)"}]}