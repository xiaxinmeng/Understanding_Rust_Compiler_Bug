{"sha": "f1016df4031ad7fbbe23bc5b4d91c87d609d2bf7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjEwMTZkZjQwMzFhZDdmYmJlMjNiYzViNGQ5MWM4N2Q2MDlkMmJmNw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2012-05-10T21:50:22Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-05-10T21:50:22Z"}, "message": "ipa-inline.c (update_all_callee_keys): Remove.\n\n\n\t* ipa-inline.c (update_all_callee_keys): Remove.\n\t(inline_small_functions): Simplify priority updating.\n\nFrom-SVN: r187382", "tree": {"sha": "9d0df18d768a5c86cedd319356d9f1c290c37596", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9d0df18d768a5c86cedd319356d9f1c290c37596"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f1016df4031ad7fbbe23bc5b4d91c87d609d2bf7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1016df4031ad7fbbe23bc5b4d91c87d609d2bf7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1016df4031ad7fbbe23bc5b4d91c87d609d2bf7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1016df4031ad7fbbe23bc5b4d91c87d609d2bf7/comments", "author": null, "committer": null, "parents": [{"sha": "57228a699857bbc47b6df2042f3fe77dc280876d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57228a699857bbc47b6df2042f3fe77dc280876d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57228a699857bbc47b6df2042f3fe77dc280876d"}], "stats": {"total": 64, "additions": 7, "deletions": 57}, "files": [{"sha": "8df98d7ea2f07e71670657c8fe90e566cf00f1f3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1016df4031ad7fbbe23bc5b4d91c87d609d2bf7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1016df4031ad7fbbe23bc5b4d91c87d609d2bf7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f1016df4031ad7fbbe23bc5b4d91c87d609d2bf7", "patch": "@@ -1,3 +1,8 @@\n+2012-05-10  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-inline.c (update_all_callee_keys): Remove.\n+\t(inline_small_functions): Simplify priority updating.\n+\n 2012-05-10  Jan Hubicka  <jh@suse.cz>\n \n \t* ipa.c (symtab_remove_unreachable_nodes): Fix marking of clones."}, {"sha": "c3482edf087c3841a39bf6050396963dc437e382", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 2, "deletions": 57, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1016df4031ad7fbbe23bc5b4d91c87d609d2bf7/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1016df4031ad7fbbe23bc5b4d91c87d609d2bf7/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=f1016df4031ad7fbbe23bc5b4d91c87d609d2bf7", "patch": "@@ -1097,45 +1097,6 @@ update_callee_keys (fibheap_t heap, struct cgraph_node *node,\n       }\n }\n \n-/* Recompute heap nodes for each of caller edges of each of callees.\n-   Walk recursively into all inline clones.  */\n-\n-static void\n-update_all_callee_keys (fibheap_t heap, struct cgraph_node *node,\n-\t\t\tbitmap updated_nodes)\n-{\n-  struct cgraph_edge *e = node->callees;\n-  if (!e)\n-    return;\n-  while (true)\n-    if (!e->inline_failed && e->callee->callees)\n-      e = e->callee->callees;\n-    else\n-      {\n-\tstruct cgraph_node *callee = cgraph_function_or_thunk_node (e->callee,\n-\t\t\t\t\t\t\t\t    NULL);\n-\n-\t/* We inlined and thus callees might have different number of calls.\n-\t   Reset their caches  */\n-        reset_node_growth_cache (callee);\n-\tif (e->inline_failed)\n-\t  update_caller_keys (heap, callee, updated_nodes, e);\n-\tif (e->next_callee)\n-\t  e = e->next_callee;\n-\telse\n-\t  {\n-\t    do\n-\t      {\n-\t\tif (e->caller == node)\n-\t\t  return;\n-\t\te = e->caller->callers;\n-\t      }\n-\t    while (!e->next_callee);\n-\t    e = e->next_callee;\n-\t  }\n-      }\n-}\n-\n /* Enqueue all recursive calls from NODE into priority queue depending on\n    how likely we want to recursively inline the call.  */\n \n@@ -1488,7 +1449,7 @@ inline_small_functions (void)\n \t     at once. Consequently we need to update all callee keys.  */\n \t  if (flag_indirect_inlining)\n \t    add_new_edges_to_heap (heap, new_indirect_edges);\n-          update_all_callee_keys (heap, where, updated_nodes);\n+          update_callee_keys (heap, where, updated_nodes);\n \t}\n       else\n \t{\n@@ -1527,18 +1488,7 @@ inline_small_functions (void)\n \t  reset_edge_caches (edge->callee);\n           reset_node_growth_cache (callee);\n \n-\t  /* We inlined last offline copy to the body.  This might lead\n-\t     to callees of function having fewer call sites and thus they\n-\t     may need updating. \n-\n-\t     FIXME: the callee size could also shrink because more information\n-\t     is propagated from caller.  We don't track when this happen and\n-\t     thus we need to recompute everything all the time.  Once this is\n-\t     solved, \"|| 1\" should go away.  */\n-\t  if (callee->global.inlined_to || 1)\n-\t    update_all_callee_keys (heap, callee, updated_nodes);\n-\t  else\n-\t    update_callee_keys (heap, edge->callee, updated_nodes);\n+\t  update_callee_keys (heap, edge->callee, updated_nodes);\n \t}\n       where = edge->caller;\n       if (where->global.inlined_to)\n@@ -1551,11 +1501,6 @@ inline_small_functions (void)\n \t called by function we inlined (since number of it inlinable callers\n \t might change).  */\n       update_caller_keys (heap, where, updated_nodes, NULL);\n-\n-      /* We removed one call of the function we just inlined.  If offline\n-\t copy is still needed, be sure to update the keys.  */\n-      if (callee != where && !callee->global.inlined_to)\n-        update_caller_keys (heap, callee, updated_nodes, NULL);\n       bitmap_clear (updated_nodes);\n \n       if (dump_file)"}]}