{"sha": "86fa5de4fc7a62813adacf107775d3ebc9bb65c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODZmYTVkZTRmYzdhNjI4MTNhZGFjZjEwNzc3NWQzZWJjOWJiNjVjMg==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2011-05-21T11:34:29Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2011-05-21T11:34:29Z"}, "message": "opt-read.awk: New.\n\n\t* opt-read.awk: New.  Split out of optc-gen.awk and opth-gen.awk.\n\t* optc-gen.awk: Move common code to opt-read.awk.\n\t* opth-gen.awk: Likewise.\n\t* Makefile.in (options.c, s-options-h): Update to use\n\topt-read.awk.\n\nFrom-SVN: r173995", "tree": {"sha": "ae156dc216d9a4a2a65ebcd0ee31c34599b4e278", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae156dc216d9a4a2a65ebcd0ee31c34599b4e278"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86fa5de4fc7a62813adacf107775d3ebc9bb65c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86fa5de4fc7a62813adacf107775d3ebc9bb65c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86fa5de4fc7a62813adacf107775d3ebc9bb65c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86fa5de4fc7a62813adacf107775d3ebc9bb65c2/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c54a6b835913f97446cb0dfeb3c257009b61230e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c54a6b835913f97446cb0dfeb3c257009b61230e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c54a6b835913f97446cb0dfeb3c257009b61230e"}], "stats": {"total": 336, "additions": 143, "deletions": 193}, "files": [{"sha": "fcb71b7854f3641532dea09056ba5d59fcc385ba", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86fa5de4fc7a62813adacf107775d3ebc9bb65c2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86fa5de4fc7a62813adacf107775d3ebc9bb65c2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=86fa5de4fc7a62813adacf107775d3ebc9bb65c2", "patch": "@@ -1,3 +1,11 @@\n+2011-05-21  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* opt-read.awk: New.  Split out of optc-gen.awk and opth-gen.awk.\n+\t* optc-gen.awk: Move common code to opt-read.awk.\n+\t* opth-gen.awk: Likewise.\n+\t* Makefile.in (options.c, s-options-h): Update to use\n+\topt-read.awk.\n+\n 2011-05-20  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* godump.c (go_format_type): Don't use TYPE_ARG_TYPES."}, {"sha": "a9d20c5a21a5d9352218f673be098cd59c3810f7", "filename": "gcc/Makefile.in", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86fa5de4fc7a62813adacf107775d3ebc9bb65c2/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86fa5de4fc7a62813adacf107775d3ebc9bb65c2/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=86fa5de4fc7a62813adacf107775d3ebc9bb65c2", "patch": "@@ -2263,13 +2263,17 @@ s-options: $(ALL_OPT_FILES) Makefile $(srcdir)/opt-gather.awk\n \t$(SHELL) $(srcdir)/../move-if-change tmp-optionlist optionlist\n \t$(STAMP) s-options\n \n-options.c: optionlist $(srcdir)/opt-functions.awk $(srcdir)/optc-gen.awk\n-\t$(AWK) -f $(srcdir)/opt-functions.awk -f $(srcdir)/optc-gen.awk \\\n+options.c: optionlist $(srcdir)/opt-functions.awk $(srcdir)/opt-read.awk \\\n+    $(srcdir)/optc-gen.awk\n+\t$(AWK) -f $(srcdir)/opt-functions.awk -f $(srcdir)/opt-read.awk \\\n+\t       -f $(srcdir)/optc-gen.awk \\\n \t       -v header_name=\"config.h system.h coretypes.h tm.h\" < $< > $@\n \n options.h: s-options-h ; @true\n-s-options-h: optionlist $(srcdir)/opt-functions.awk $(srcdir)/opth-gen.awk\n-\t$(AWK) -f $(srcdir)/opt-functions.awk -f $(srcdir)/opth-gen.awk \\\n+s-options-h: optionlist $(srcdir)/opt-functions.awk $(srcdir)/opt-read.awk \\\n+    $(srcdir)/opth-gen.awk\n+\t$(AWK) -f $(srcdir)/opt-functions.awk -f $(srcdir)/opt-read.awk \\\n+\t       -f $(srcdir)/opth-gen.awk \\\n \t       < $< > tmp-options.h\n \t$(SHELL) $(srcdir)/../move-if-change tmp-options.h options.h\n \t$(STAMP) $@"}, {"sha": "c488ed5cde53f65785ac68631bb391916351071f", "filename": "gcc/opt-read.awk", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86fa5de4fc7a62813adacf107775d3ebc9bb65c2/gcc%2Fopt-read.awk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86fa5de4fc7a62813adacf107775d3ebc9bb65c2/gcc%2Fopt-read.awk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopt-read.awk?ref=86fa5de4fc7a62813adacf107775d3ebc9bb65c2", "patch": "@@ -0,0 +1,119 @@\n+#  Copyright (C) 2003,2004,2005,2006,2007,2008, 2010, 2011\n+#  Free Software Foundation, Inc.\n+#  Contributed by Kelley Cook, June 2004.\n+#  Original code from Neil Booth, May 2003.\n+#\n+# This program is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published by the\n+# Free Software Foundation; either version 3, or (at your option) any\n+# later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with this program; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# Read in the option records generated from opt-gather.awk.\n+\n+BEGIN {\n+\tn_opts = 0\n+\tn_langs = 0\n+\tn_target_save = 0\n+\tn_extra_vars = 0\n+\tn_extra_target_vars = 0\n+\tn_extra_masks = 0\n+\tn_extra_c_includes = 0\n+\tn_extra_h_includes = 0\n+\tn_enums = 0\n+\thave_save = 0;\n+\tquote = \"\\042\"\n+\tcomma = \",\"\n+\tFS=SUBSEP\n+\t# Default the name of header created from opth-gen.awk to options.h\n+\tif (header_name == \"\") header_name=\"options.h\"\n+}\n+\n+# Collect the text and flags of each option into an array\n+\t{\n+\t\tif ($1 == \"Language\") {\n+\t\t\tlangs[n_langs] = $2\n+\t\t\tn_langs++;\n+\t\t}\n+\t\telse if ($1 == \"TargetSave\") {\n+\t\t\t# Make sure the declarations are put in source order\n+\t\t\ttarget_save_decl[n_target_save] = $2\n+\t\t\tn_target_save++\n+\t\t}\n+\t\telse if ($1 == \"Variable\") {\n+\t\t\textra_vars[n_extra_vars] = $2\n+\t\t\tn_extra_vars++\n+\t\t}\n+\t\telse if ($1 == \"TargetVariable\") {\n+\t\t\t# Combination of TargetSave and Variable\n+\t\t\textra_vars[n_extra_vars] = $2\n+\t\t\tn_extra_vars++\n+\n+\t\t\tvar = $2\n+\t\t\tsub(\" *=.*\", \"\", var)\n+\t\t\torig_var = var\n+\t\t\tname = var\n+\t\t\ttype = var\n+\t\t\tsub(\"^.*[ *]\", \"\", name)\n+\t\t\tsub(\" *\" name \"$\", \"\", type)\n+\t\t\ttarget_save_decl[n_target_save] = type \" x_\" name\n+\t\t\tn_target_save++\n+\n+\t\t\textra_target_vars[n_extra_target_vars] = name\n+\t\t\tn_extra_target_vars++\n+\t\t}\n+\t\telse if ($1 == \"HeaderInclude\") {\n+\t\t\textra_h_includes[n_extra_h_includes++] = $2;\n+\t\t}\n+\t\telse if ($1 == \"SourceInclude\")  {\n+\t\t\textra_c_includes[n_extra_c_includes++] = $2;\n+\t\t}\n+\t\telse if ($1 == \"Enum\") {\n+\t\t\tprops = $2\n+\t\t\tname = opt_args(\"Name\", props)\n+\t\t\ttype = opt_args(\"Type\", props)\n+\t\t\tunknown_error = opt_args(\"UnknownError\", props)\n+\t\t\tenum_names[n_enums] = name\n+\t\t\tenum_type[name] = type\n+\t\t\tenum_index[name] = n_enums\n+\t\t\tenum_unknown_error[name] = unknown_error\n+\t\t\tenum_help[name] = $3\n+\t\t\tn_enums++\n+\t\t}\n+\t\telse if ($1 == \"EnumValue\")  {\n+\t\t\tprops = $2\n+\t\t\tenum_name = opt_args(\"Enum\", props)\n+\t\t\tstring = opt_args(\"String\", props)\n+\t\t\tvalue = opt_args(\"Value\", props)\n+\t\t\tval_flags = \"0\"\n+\t\t\tval_flags = val_flags \\\n+\t\t\t  test_flag(\"Canonical\", props, \"| CL_ENUM_CANONICAL\") \\\n+\t\t\t  test_flag(\"DriverOnly\", props, \"| CL_ENUM_DRIVER_ONLY\")\n+\t\t\tenum_data[enum_name] = enum_data[enum_name] \\\n+\t\t\t  \"  { \" quote string quote \", \" value \", \" val_flags \\\n+\t\t\t  \" },\\n\"\n+\t\t}\n+\t\telse {\n+\t\t\tname = opt_args(\"Mask\", $1)\n+\t\t\tif (name == \"\") {\n+\t\t\t\topts[n_opts]  = $1\n+\t\t\t\tflags[n_opts] = $2\n+\t\t\t\thelp[n_opts]  = $3\n+\t\t\t\tfor (i = 4; i <= NF; i++)\n+\t\t\t\t\thelp[n_opts] = help[n_opts] \" \" $i\n+\t\t\t\tn_opts++;\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\textra_masks[n_extra_masks++] = name\n+\t\t\t}\n+\t\t}\n+\t}\n+"}, {"sha": "2c4df708801e09de498b8d9efba09f2bebbcd079", "filename": "gcc/optc-gen.awk", "status": "modified", "additions": 4, "deletions": 95, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86fa5de4fc7a62813adacf107775d3ebc9bb65c2/gcc%2Foptc-gen.awk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86fa5de4fc7a62813adacf107775d3ebc9bb65c2/gcc%2Foptc-gen.awk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptc-gen.awk?ref=86fa5de4fc7a62813adacf107775d3ebc9bb65c2", "patch": "@@ -21,104 +21,13 @@\n # opt-gather.awk, combines the flags of duplicate options and generates a\n # C file.\n #\n-# This program uses functions from opt-functions.awk\n+\n+# This program uses functions from opt-functions.awk and code from\n+# opt-read.awk.\n #\n-# Usage: awk -f opt-functions.awk -f optc-gen.awk \\\n+# Usage: awk -f opt-functions.awk -f opt-read.awk -f optc-gen.awk \\\n #            [-v header_name=header.h] < inputfile > options.c\n \n-BEGIN {\n-\tn_opts = 0\n-\tn_langs = 0\n-\tn_target_save = 0\n-\tn_extra_vars = 0\n-\tn_extra_target_vars = 0\n-\tn_extra_c_includes = 0\n-\tn_extra_h_includes = 0\n-\tn_enums = 0\n-\tquote = \"\\042\"\n-\tcomma = \",\"\n-\tFS=SUBSEP\n-\t# Default the name of header created from opth-gen.awk to options.h\n-\tif (header_name == \"\") header_name=\"options.h\"\n-}\n-\n-# Collect the text and flags of each option into an array\n-\t{\n-\t\tif ($1 == \"Language\") {\n-\t\t\tlangs[n_langs] = $2\n-\t\t\tn_langs++;\n-\t\t}\n-\t\telse if ($1 == \"TargetSave\") {\n-\t\t\t# Make sure the declarations are put in source order\n-\t\t\ttarget_save_decl[n_target_save] = $2\n-\t\t\tn_target_save++\n-\t\t}\n-\t\telse if ($1 == \"Variable\") {\n-\t\t\textra_vars[n_extra_vars] = $2\n-\t\t\tn_extra_vars++\n-\t\t}\n-\t\telse if ($1 == \"TargetVariable\") {\n-\t\t\t# Combination of TargetSave and Variable\n-\t\t\textra_vars[n_extra_vars] = $2\n-\t\t\tn_extra_vars++\n-\n-\t\t\tvar = $2\n-\t\t\tsub(\" *=.*\", \"\", var)\n-\t\t\torig_var = var\n-\t\t\tname = var\n-\t\t\ttype = var\n-\t\t\tsub(\"^.*[ *]\", \"\", name)\n-\t\t\tsub(\" *\" name \"$\", \"\", type)\n-\t\t\ttarget_save_decl[n_target_save] = type \" x_\" name\n-\t\t\tn_target_save++\n-\n-\t\t\textra_target_vars[n_extra_target_vars] = name\n-\t\t\tn_extra_target_vars++;\n-\t\t}\n-\t\telse if ($1 == \"HeaderInclude\") {\n-\t\t\textra_h_includes[n_extra_h_includes++] = $2;\n-\t\t}\n-\t\telse if ($1 == \"SourceInclude\")  {\n-\t\t\textra_c_includes[n_extra_c_includes++] = $2;\n-\t\t}\n-\t\telse if ($1 == \"Enum\") {\n-\t\t\tprops = $2\n-\t\t\tname = opt_args(\"Name\", props)\n-\t\t\ttype = opt_args(\"Type\", props)\n-\t\t\tunknown_error = opt_args(\"UnknownError\", props)\n-\t\t\tenum_names[n_enums] = name\n-\t\t\tenum_type[name] = type\n-\t\t\tenum_index[name] = n_enums\n-\t\t\tenum_unknown_error[name] = unknown_error\n-\t\t\tenum_help[name] = $3\n-\t\t\tn_enums++\n-\t\t}\n-\t\telse if ($1 == \"EnumValue\")  {\n-\t\t\tprops = $2\n-\t\t\tenum_name = opt_args(\"Enum\", props)\n-\t\t\tstring = opt_args(\"String\", props)\n-\t\t\tvalue = opt_args(\"Value\", props)\n-\t\t\tval_flags = \"0\"\n-\t\t\tval_flags = val_flags \\\n-\t\t\t  test_flag(\"Canonical\", props, \"| CL_ENUM_CANONICAL\") \\\n-\t\t\t  test_flag(\"DriverOnly\", props, \"| CL_ENUM_DRIVER_ONLY\")\n-\t\t\tenum_data[enum_name] = enum_data[enum_name] \\\n-\t\t\t  \"  { \" quote string quote \", \" value \", \" val_flags \\\n-\t\t\t  \" },\\n\"\n-\t\t}\n-\t\telse {\n-\t\t\tname = opt_args(\"Mask\", $1)\n-\t\t\tif (name == \"\") {\n-\t\t\t\topts[n_opts]  = $1\n-\t\t\t\tflags[n_opts] = $2\n-\t\t\t\thelp[n_opts]  = $3\n-\t\t\t\tfor (i = 4; i <= NF; i++)\n-\t\t\t\t\thelp[n_opts] = help[n_opts] \" \" $i\n-\t\t\t\tn_opts++;\n-\t\t\t}\n-\t\t}\n-\t}\n-\n # Dump that array of options into a C file.\n END {\n print \"/* This file is auto-generated by optc-gen.awk.  */\""}, {"sha": "7877d033b69c52d30329170c61b0bde839b4a871", "filename": "gcc/opth-gen.awk", "status": "modified", "additions": 4, "deletions": 94, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86fa5de4fc7a62813adacf107775d3ebc9bb65c2/gcc%2Fopth-gen.awk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86fa5de4fc7a62813adacf107775d3ebc9bb65c2/gcc%2Fopth-gen.awk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopth-gen.awk?ref=86fa5de4fc7a62813adacf107775d3ebc9bb65c2", "patch": "@@ -21,100 +21,10 @@\n # opt-gather.awk, combines the flags of duplicate options and generates a\n # C header file.\n #\n-# This program uses functions from opt-functions.awk\n-# Usage: awk -f opt-functions.awk -f opth-gen.awk < inputfile > options.h\n-\n-BEGIN {\n-\tn_opts = 0\n-\tn_langs = 0\n-\tn_target_save = 0\n-\tn_extra_vars = 0\n-\tn_extra_target_vars = 0\n-\tn_extra_masks = 0\n-\tn_extra_c_includes = 0\n-\tn_extra_h_includes = 0\n-\thave_save = 0;\n-\tquote = \"\\042\"\n-\tFS=SUBSEP\n-}\n-\n-# Collect the text and flags of each option into an array\n-\t{\n-\t\tif ($1 == \"Language\") {\n-\t\t\tlangs[n_langs] = $2\n-\t\t\tn_langs++;\n-\t\t}\n-\t\telse if ($1 == \"TargetSave\") {\n-\t\t\t# Make sure the declarations are put in source order\n-\t\t\ttarget_save_decl[n_target_save] = $2\n-\t\t\tn_target_save++\n-\t\t}\n-\t\telse if ($1 == \"Variable\") {\n-\t\t\textra_vars[n_extra_vars] = $2\n-\t\t\tn_extra_vars++\n-\t\t}\n-\t\telse if ($1 == \"TargetVariable\") {\n-\t\t\t# Combination of TargetSave and Variable\n-\t\t\textra_vars[n_extra_vars] = $2\n-\t\t\tn_extra_vars++\n-\n-\t\t\tvar = $2\n-\t\t\tsub(\" *=.*\", \"\", var)\n-\t\t\torig_var = var\n-\t\t\tname = var\n-\t\t\ttype = var\n-\t\t\tsub(\"^.*[ *]\", \"\", name)\n-\t\t\tsub(\" *\" name \"$\", \"\", type)\n-\t\t\ttarget_save_decl[n_target_save] = type \" x_\" name\n-\t\t\tn_target_save++\n-\n-\t\t\textra_target_vars[n_extra_target_vars] = name\n-\t\t\tn_extra_target_vars++\n-\t\t}\n-\t\telse if ($1 == \"HeaderInclude\") {\n-\t\t\textra_h_includes[n_extra_h_includes++] = $2;\n-\t\t}\n-\t\telse if ($1 == \"SourceInclude\")  {\n-\t\t\textra_c_includes[n_extra_c_includes++] = $2;\n-\t\t}\n-\t\telse if ($1 == \"Enum\")  {\n-\t\t\tprops = $2\n-\t\t\tname = opt_args(\"Name\", props)\n-\t\t\ttype = opt_args(\"Type\", props)\n-\t\t\tunknown_error = opt_args(\"UnknownError\", props)\n-\t\t\tenum_names[n_enums] = name\n-\t\t\tenum_type[name] = type\n-\t\t\tenum_index[name] = n_enums\n-\t\t\tenum_unknown_error[name] = unknown_error\n-\t\t\tenum_help[name] = $3\n-\t\t\tn_enums++\n-\t\t}\n-\t\telse if ($1 == \"EnumValue\")  {\n-\t\t\tprops = $2\n-\t\t\tenum_name = opt_args(\"Enum\", props)\n-\t\t\tstring = opt_args(\"String\", props)\n-\t\t\tvalue = opt_args(\"Value\", props)\n-\t\t\tval_flags = \"0\"\n-\t\t\tval_flags = val_flags \\\n-\t\t\t  test_flag(\"Canonical\", props, \"| CL_ENUM_CANONICAL\") \\\n-\t\t\t  test_flag(\"DriverOnly\", props, \"| CL_ENUM_DRIVER_ONLY\")\n-\t\t\tenum_data[enum_name] = enum_data[enum_name] \\\n-\t\t\t  \"  { \" quote string quote \", \" value \", \" val_flags \\\n-\t\t\t  \" },\\n\"\n-\t\t}\n-\t\telse {\n-\t\t\tname = opt_args(\"Mask\", $1)\n-\t\t\tif (name == \"\") {\n-\t\t\t\topts[n_opts]  = $1\n-\t\t\t\tflags[n_opts] = $2\n-\t\t\t\thelp[n_opts]  = $3\n-\t\t\t\tn_opts++;\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\textra_masks[n_extra_masks++] = name\n-\t\t\t}\n-\t\t}\n-\t}\n+# This program uses functions from opt-functions.awk and code from\n+# opt-read.awk.\n+# Usage: awk -f opt-functions.awk -f opt-read.awk -f opth-gen.awk \\\n+#            < inputfile > options.h\n \n # Dump out an enumeration into a .h file.\n # Combine the flags of duplicate options."}]}