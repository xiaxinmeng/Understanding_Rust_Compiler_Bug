{"sha": "8775a18b96762a8db2c63d9fe4fe02f6d0139fad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODc3NWExOGI5Njc2MmE4ZGIyYzYzZDlmZTRmZTAyZjZkMDEzOWZhZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2011-06-13T15:31:22Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2011-06-13T15:31:22Z"}, "message": "ipa-utils.c (postorder_stack): New structure.\n\n\t* ipa-utils.c (postorder_stack): New structure.\n\t(ipa_reverse_postorder): Handle aliases.\n\nFrom-SVN: r174991", "tree": {"sha": "db86d7ac492fa048eb87a78155c9a8e26a0e0ac7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db86d7ac492fa048eb87a78155c9a8e26a0e0ac7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8775a18b96762a8db2c63d9fe4fe02f6d0139fad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8775a18b96762a8db2c63d9fe4fe02f6d0139fad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8775a18b96762a8db2c63d9fe4fe02f6d0139fad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8775a18b96762a8db2c63d9fe4fe02f6d0139fad/comments", "author": null, "committer": null, "parents": [{"sha": "db1d217c76a70b4c787630806c087f02fbdeffc8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db1d217c76a70b4c787630806c087f02fbdeffc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db1d217c76a70b4c787630806c087f02fbdeffc8"}], "stats": {"total": 98, "additions": 61, "deletions": 37}, "files": [{"sha": "75954951d6ad54b404149be263f9cd09a101d856", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8775a18b96762a8db2c63d9fe4fe02f6d0139fad/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8775a18b96762a8db2c63d9fe4fe02f6d0139fad/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8775a18b96762a8db2c63d9fe4fe02f6d0139fad", "patch": "@@ -1,3 +1,15 @@\n+2011-06-13  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-utils.c (postorder_stack): New structure.\n+\t(ipa_reverse_postorder): Handle aliases.\n+\n+2011-06-13  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-inline.c (reset_edge_caches): Walk aliases.\n+\t(update_caller_keys): Do not test inlinability of aliases.\n+\t* ipa-inline-analysis.c (do_estimate_edge_time): Look through alias.\n+\t(do_estimate_growth): Fix typo.\n+\n 2011-06-13  Jan Hubicka  <jh@suse.cz>\n \n \t* ipa-inline-transform.c (+can_remove_node_now_p_1): Break out from..."}, {"sha": "0a462ef25b56ab53da4ca78a69799c3cdc186f56", "filename": "gcc/ipa-utils.c", "status": "modified", "additions": 49, "deletions": 37, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8775a18b96762a8db2c63d9fe4fe02f6d0139fad/gcc%2Fipa-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8775a18b96762a8db2c63d9fe4fe02f6d0139fad/gcc%2Fipa-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.c?ref=8775a18b96762a8db2c63d9fe4fe02f6d0139fad", "patch": "@@ -233,6 +233,13 @@ ipa_free_postorder_info (void)\n     }\n }\n \n+struct postorder_stack\n+{\n+  struct cgraph_node *node;\n+  struct cgraph_edge *edge;\n+  int ref;\n+};\n+\n /* Fill array order with all nodes with output flag set in the reverse\n    topological order.  Return the number of elements in the array.\n    FIXME: While walking, consider aliases, too.  */\n@@ -243,11 +250,12 @@ ipa_reverse_postorder (struct cgraph_node **order)\n   struct cgraph_node *node, *node2;\n   int stack_size = 0;\n   int order_pos = 0;\n-  struct cgraph_edge *edge, last;\n+  struct cgraph_edge *edge;\n   int pass;\n+  struct ipa_ref *ref;\n \n-  struct cgraph_node **stack =\n-    XCNEWVEC (struct cgraph_node *, cgraph_n_nodes);\n+  struct postorder_stack *stack =\n+    XCNEWVEC (struct postorder_stack, cgraph_n_nodes);\n \n   /* We have to deal with cycles nicely, so use a depth first traversal\n      output algorithm.  Ignore the fact that some functions won't need\n@@ -261,47 +269,51 @@ ipa_reverse_postorder (struct cgraph_node **order)\n \t  && (pass\n \t      || (!node->address_taken\n \t\t  && !node->global.inlined_to\n-\t\t  && !cgraph_only_called_directly_or_aliased_p (node))))\n+\t\t  && !node->alias && !node->thunk.thunk_p\n+\t\t  && !cgraph_only_called_directly_p (node))))\n \t{\n-\t  node2 = node;\n-\t  if (!node->callers)\n-\t    node->aux = &last;\n-\t  else\n-\t    node->aux = node->callers;\n-\t  while (node2)\n+\t  stack_size = 0;\n+          stack[stack_size].node = node;\n+\t  stack[stack_size].edge = node->callers;\n+\t  stack[stack_size].ref = 0;\n+\t  node->aux = (void *)(size_t)1;\n+\t  while (stack_size >= 0)\n \t    {\n-\t      while (node2->aux != &last)\n+\t      while (true)\n \t\t{\n-\t\t  edge = (struct cgraph_edge *) node2->aux;\n-\t\t  if (edge->next_caller)\n-\t\t    node2->aux = edge->next_caller;\n-\t\t  else\n-\t\t    node2->aux = &last;\n-\t\t  /* Break possible cycles involving always-inline\n-\t\t     functions by ignoring edges from always-inline\n-\t\t     functions to non-always-inline functions.  */\n-\t\t  if (DECL_DISREGARD_INLINE_LIMITS (edge->caller->decl)\n-\t\t      && !DECL_DISREGARD_INLINE_LIMITS (edge->callee->decl))\n-\t\t    continue;\n-\t\t  if (!edge->caller->aux)\n+\t\t  node2 = NULL;\n+\t\t  while (stack[stack_size].edge && !node2)\n \t\t    {\n-\t\t      if (!edge->caller->callers)\n-\t\t\tedge->caller->aux = &last;\n-\t\t      else\n-\t\t\tedge->caller->aux = edge->caller->callers;\n-\t\t      stack[stack_size++] = node2;\n+\t\t      edge = stack[stack_size].edge;\n \t\t      node2 = edge->caller;\n-\t\t      break;\n+\t\t      stack[stack_size].edge = edge->next_caller;\n+\t\t      /* Break possible cycles involving always-inline\n+\t\t\t functions by ignoring edges from always-inline\n+\t\t\t functions to non-always-inline functions.  */\n+\t\t      if (DECL_DISREGARD_INLINE_LIMITS (edge->caller->decl)\n+\t\t\t  && !DECL_DISREGARD_INLINE_LIMITS\n+\t\t\t    (cgraph_function_node (edge->callee, NULL)->decl))\n+\t\t\tnode2 = NULL;\n+\t\t    }\n+\t\t  for (;ipa_ref_list_refering_iterate (&stack[stack_size].node->ref_list,\n+\t\t\t\t\t\t       stack[stack_size].ref,\n+\t\t\t\t\t\t       ref) && !node2;\n+\t\t       stack[stack_size].ref++)\n+\t\t    {\n+\t\t      if (ref->use == IPA_REF_ALIAS)\n+\t\t\tnode2 = ipa_ref_refering_node (ref);\n+\t\t    }\n+\t\t  if (!node2)\n+\t\t    break;\n+\t\t  if (!node2->aux)\n+\t\t    {\n+\t\t      stack[++stack_size].node = node2;\n+\t\t      stack[stack_size].edge = node2->callers;\n+\t\t      stack[stack_size].ref = 0;\n+\t\t      node2->aux = (void *)(size_t)1;\n \t\t    }\n \t\t}\n-\t      if (node2->aux == &last)\n-\t\t{\n-\t\t  order[order_pos++] = node2;\n-\t\t  if (stack_size)\n-\t\t    node2 = stack[--stack_size];\n-\t\t  else\n-\t\t    node2 = NULL;\n-\t\t}\n+\t      order[order_pos++] = stack[stack_size--].node;\n \t    }\n \t}\n   free (stack);"}]}