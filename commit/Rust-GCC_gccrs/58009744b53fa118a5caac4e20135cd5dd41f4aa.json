{"sha": "58009744b53fa118a5caac4e20135cd5dd41f4aa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTgwMDk3NDRiNTNmYTExOGE1Y2FhYzRlMjAxMzVjZDVkZDQxZjRhYQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-03-04T14:56:45Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-03-04T14:56:45Z"}, "message": "[multiple changes]\n\n2015-03-04  Robert Dewar  <dewar@adacore.com>\n\n\t* einfo.adb (Is_ARECnF_Entity): Removed.\n\t(Last_Formal): Remove special handling of Is_ARECnF_Entity.\n\t(Next_Formal): Remove special handling of Is_ARECnF_Entity.\n\t(Next_Formal_With_Extras): Remove special handling of Is_ARECnF_Entity.\n\t(Number_Entries): Minor reformatting.\n\t* einfo.ads (Is_ARECnF_Entity): Removed.\n\t* exp_unst.adb (Unnest_Subprogram): Remove setting of\n\tIs_ARECnF_Entity.\n\t(Add_Extra_Formal): Use normal Extra_Formal circuit.\n\t* sprint.adb (Write_Param_Specs): Properly handle case where\n\tthere are no source formals, but we have at least one Extra_Formal\n\tpresent.\n\n2015-03-04  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_aggr.adb (Resolve_Record_Aggregate,\n\tAdd_Discriminant_Values): If the value is a reference to the\n\tcurrent instance of an enclosing type, use its base type to check\n\tagainst prefix of attribute reference, because the target type\n\tmay be otherwise constrained.\n\nFrom-SVN: r221187", "tree": {"sha": "a31d55a9c9cb81867c321d17c1adb3d3cff5903b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a31d55a9c9cb81867c321d17c1adb3d3cff5903b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/58009744b53fa118a5caac4e20135cd5dd41f4aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58009744b53fa118a5caac4e20135cd5dd41f4aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58009744b53fa118a5caac4e20135cd5dd41f4aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58009744b53fa118a5caac4e20135cd5dd41f4aa/comments", "author": null, "committer": null, "parents": [{"sha": "e0601c0df98d918ee95226403438d291e12ab66b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0601c0df98d918ee95226403438d291e12ab66b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0601c0df98d918ee95226403438d291e12ab66b"}], "stats": {"total": 383, "additions": 178, "deletions": 205}, "files": [{"sha": "7b1f0f4d771b94d4b8ce673394aad975c0c3d466", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58009744b53fa118a5caac4e20135cd5dd41f4aa/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58009744b53fa118a5caac4e20135cd5dd41f4aa/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=58009744b53fa118a5caac4e20135cd5dd41f4aa", "patch": "@@ -1,3 +1,26 @@\n+2015-03-04  Robert Dewar  <dewar@adacore.com>\n+\n+\t* einfo.adb (Is_ARECnF_Entity): Removed.\n+\t(Last_Formal): Remove special handling of Is_ARECnF_Entity.\n+\t(Next_Formal): Remove special handling of Is_ARECnF_Entity.\n+\t(Next_Formal_With_Extras): Remove special handling of Is_ARECnF_Entity.\n+\t(Number_Entries): Minor reformatting.\n+\t* einfo.ads (Is_ARECnF_Entity): Removed.\n+\t* exp_unst.adb (Unnest_Subprogram): Remove setting of\n+\tIs_ARECnF_Entity.\n+\t(Add_Extra_Formal): Use normal Extra_Formal circuit.\n+\t* sprint.adb (Write_Param_Specs): Properly handle case where\n+\tthere are no source formals, but we have at least one Extra_Formal\n+\tpresent.\n+\n+2015-03-04  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_aggr.adb (Resolve_Record_Aggregate,\n+\tAdd_Discriminant_Values): If the value is a reference to the\n+\tcurrent instance of an enclosing type, use its base type to check\n+\tagainst prefix of attribute reference, because the target type\n+\tmay be otherwise constrained.\n+\n 2015-03-04  Robert Dewar  <dewar@adacore.com>\n \n \t* atree.h: Add entries for Flag287-Flag309."}, {"sha": "70dc46fc17a810c62bbd8603c400bc5979d08f2d", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 8, "deletions": 51, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58009744b53fa118a5caac4e20135cd5dd41f4aa/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58009744b53fa118a5caac4e20135cd5dd41f4aa/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=58009744b53fa118a5caac4e20135cd5dd41f4aa", "patch": "@@ -584,8 +584,8 @@ package body Einfo is\n    --    Is_Static_Type                  Flag281\n    --    Has_Nested_Subprogram           Flag282\n    --    Uplevel_Reference_Noted         Flag283\n-   --    Is_ARECnF_Entity                Flag284\n \n+   --    (unused)                        Flag284\n    --    (unused)                        Flag285\n    --    (unused)                        Flag286\n    --    (unused)                        Flag287\n@@ -1915,11 +1915,6 @@ package body Einfo is\n       return Flag146 (Id);\n    end Is_Abstract_Type;\n \n-   function Is_ARECnF_Entity (Id : E) return B is\n-   begin\n-      return Flag284 (Id);\n-   end Is_ARECnF_Entity;\n-\n    function Is_Local_Anonymous_Access (Id : E) return B is\n    begin\n       pragma Assert (Is_Access_Type (Id));\n@@ -4802,11 +4797,6 @@ package body Einfo is\n       Set_Flag146 (Id, V);\n    end Set_Is_Abstract_Type;\n \n-   procedure Set_Is_ARECnF_Entity (Id : E; V : B := True) is\n-   begin\n-      Set_Flag284 (Id, V);\n-   end Set_Is_ARECnF_Entity;\n-\n    procedure Set_Is_Local_Anonymous_Access (Id : E; V : B := True) is\n    begin\n       pragma Assert (Is_Access_Type (Id));\n@@ -7586,7 +7576,7 @@ package body Einfo is\n \n    function Last_Formal (Id : E) return E is\n       Formal : E;\n-      NForm  : E;\n+\n    begin\n       pragma Assert\n         (Is_Overloadable (Id)\n@@ -7601,10 +7591,8 @@ package body Einfo is\n          Formal := First_Formal (Id);\n \n          if Present (Formal) then\n-            loop\n-               NForm := Next_Formal (Formal);\n-               exit when No (NForm) or else Is_ARECnF_Entity (NForm);\n-               Formal := NForm;\n+            while Present (Next_Formal (Formal)) loop\n+               Formal := Next_Formal (Formal);\n             end loop;\n          end if;\n \n@@ -7812,19 +7800,8 @@ package body Einfo is\n       loop\n          Next_Entity (P);\n \n-         --  Return Empty if no next entity, or its an ARECnF entity (since\n-         --  the latter is the last extra formal, not to be returned here).\n-\n-         if No (P) or else Is_ARECnF_Entity (P) then\n-            return Empty;\n-\n-         --  If next entity is a formal, return it\n-\n-         elsif Is_Formal (P) then\n+         if No (P) or else Is_Formal (P) then\n             return P;\n-\n-         --  Else one, unless we have an internal entity, which we skip\n-\n          elsif not Is_Internal (P) then\n             return Empty;\n          end if;\n@@ -7836,30 +7813,11 @@ package body Einfo is\n    -----------------------------\n \n    function Next_Formal_With_Extras (Id : E) return E is\n-      NForm : Entity_Id;\n-      Next  : Entity_Id;\n-\n    begin\n       if Present (Extra_Formal (Id)) then\n          return Extra_Formal (Id);\n-\n       else\n-         NForm := Next_Formal (Id);\n-\n-         if Present (NForm) then\n-            return NForm;\n-\n-         --  Deal with ARECnF entity as last extra formal\n-\n-         else\n-            Next := Next_Entity (Id);\n-\n-            if Present (Next) and then Is_ARECnF_Entity (Next) then\n-               return Next;\n-            else\n-               return Empty;\n-            end if;\n-         end if;\n+         return Next_Formal (Id);\n       end if;\n    end Next_Formal_With_Extras;\n \n@@ -7922,8 +7880,8 @@ package body Einfo is\n    --------------------\n \n    function Number_Entries (Id : E) return Nat is\n-      N      : Int;\n-      Ent    : Entity_Id;\n+      N   : Int;\n+      Ent : Entity_Id;\n \n    begin\n       pragma Assert (Is_Concurrent_Type (Id));\n@@ -8708,7 +8666,6 @@ package body Einfo is\n       W (\"In_Use\",                          Flag8   (Id));\n       W (\"Is_Abstract_Subprogram\",          Flag19  (Id));\n       W (\"Is_Abstract_Type\",                Flag146 (Id));\n-      W (\"Is_ARECnF_Entity\",                Flag284 (Id));\n       W (\"Is_Access_Constant\",              Flag69  (Id));\n       W (\"Is_Ada_2005_Only\",                Flag185 (Id));\n       W (\"Is_Ada_2012_Only\",                Flag199 (Id));"}, {"sha": "cd92063e3f4f87c2863405f0a6d3f6a322d6990d", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58009744b53fa118a5caac4e20135cd5dd41f4aa/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58009744b53fa118a5caac4e20135cd5dd41f4aa/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=58009744b53fa118a5caac4e20135cd5dd41f4aa", "patch": "@@ -1214,10 +1214,12 @@ package Einfo is\n --       Extra_Formal field (i.e. the Extra_Formal field of the last \"real\"\n --       formal points to the first extra formal, and the Extra_Formal field of\n --       each extra formal points to the next one, with Empty indicating the\n---       end of the list of extra formals).\n+--       end of the list of extra formals). Another case of Extra_Formal arises\n+--       in connection with unnesting of subprograms, where the ARECnF formal\n+--       that represents an activation record pointer is an extra formal.\n \n --    Extra_Formals (Node28)\n---       Applies to subprograms and subprogram types, and also in entries\n+--       Applies to subprograms and subprogram types, and also to entries\n --       and entry families. Returns first extra formal of the subprogram\n --       or entry. Returns Empty if there are no extra formals.\n \n@@ -2176,15 +2178,6 @@ package Einfo is\n --       carry the keyword aliased, and on record components that have the\n --       keyword. For Ada 2012, also applies to formal parameters.\n \n---    Is_ARECnF_Entity (Flag284)\n---       Defined in all entities. Set for the ARECnF E_In_Parameter entity that\n---       is generated for nested subprograms that require an activation record.\n---       Logically this is an extra formal, and must be treated that way, but\n---       we can't use the normal Extra_Formal mechanism since it is designed\n---       to handle only cases where an extra formal is associated with one of\n---       the source formals, which is not the case for ARECnF entities. Hence\n---       we use this special flag to deal with this special extra formal.\n-\n --    Is_Atomic (Flag85)\n --       Defined in all type entities, and also in constants, components and\n --       variables. Set if a pragma Atomic or Shared applies to the entity.\n@@ -5257,7 +5250,6 @@ package Einfo is\n    --    In_Private_Part                     (Flag45)\n    --    Is_Ada_2005_Only                    (Flag185)\n    --    Is_Ada_2012_Only                    (Flag199)\n-   --    Is_ARECnF_Entity                    (Flag284)\n    --    Is_Bit_Packed_Array                 (Flag122)  (base type only)\n    --    Is_Aliased                          (Flag15)\n    --    Is_Character_Type                   (Flag63)\n@@ -6811,7 +6803,6 @@ package Einfo is\n    function Is_Ada_2005_Only                    (Id : E) return B;\n    function Is_Ada_2012_Only                    (Id : E) return B;\n    function Is_Aliased                          (Id : E) return B;\n-   function Is_ARECnF_Entity                    (Id : E) return B;\n    function Is_Asynchronous                     (Id : E) return B;\n    function Is_Atomic                           (Id : E) return B;\n    function Is_Bit_Packed_Array                 (Id : E) return B;\n@@ -7460,7 +7451,6 @@ package Einfo is\n    procedure Set_Is_Ada_2005_Only                (Id : E; V : B := True);\n    procedure Set_Is_Ada_2012_Only                (Id : E; V : B := True);\n    procedure Set_Is_Aliased                      (Id : E; V : B := True);\n-   procedure Set_Is_ARECnF_Entity                (Id : E; V : B := True);\n    procedure Set_Is_Asynchronous                 (Id : E; V : B := True);\n    procedure Set_Is_Atomic                       (Id : E; V : B := True);\n    procedure Set_Is_Bit_Packed_Array             (Id : E; V : B := True);\n@@ -8228,7 +8218,6 @@ package Einfo is\n    pragma Inline (Is_Ada_2012_Only);\n    pragma Inline (Is_Aggregate_Type);\n    pragma Inline (Is_Aliased);\n-   pragma Inline (Is_ARECnF_Entity);\n    pragma Inline (Is_Array_Type);\n    pragma Inline (Is_Assignable);\n    pragma Inline (Is_Asynchronous);\n@@ -8721,7 +8710,6 @@ package Einfo is\n    pragma Inline (Set_Is_Ada_2005_Only);\n    pragma Inline (Set_Is_Ada_2012_Only);\n    pragma Inline (Set_Is_Aliased);\n-   pragma Inline (Set_Is_ARECnF_Entity);\n    pragma Inline (Set_Is_Asynchronous);\n    pragma Inline (Set_Is_Atomic);\n    pragma Inline (Set_Is_Bit_Packed_Array);"}, {"sha": "b7bcf5c6e51e0fa5b7068a3cac14005be1e8e87e", "filename": "gcc/ada/exp_unst.adb", "status": "modified", "additions": 23, "deletions": 39, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58009744b53fa118a5caac4e20135cd5dd41f4aa/gcc%2Fada%2Fexp_unst.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58009744b53fa118a5caac4e20135cd5dd41f4aa/gcc%2Fada%2Fexp_unst.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_unst.adb?ref=58009744b53fa118a5caac4e20135cd5dd41f4aa", "patch": "@@ -611,7 +611,6 @@ package body Exp_Unst is\n                STJ.ARECnF :=\n                  Make_Defining_Identifier (Loc,\n                    Chars => Name_Find_Str (AREC_String (STJ.Lev - 1) & \"F\"));\n-               Set_Is_ARECnF_Entity (STJ.ARECnF, True);\n             else\n                STJ.ARECnF := Empty;\n             end if;\n@@ -679,7 +678,7 @@ package body Exp_Unst is\n                   --  and it is not obvious how we can get what we want if we\n                   --  try to use the normal Analyze circuit.\n \n-                  Extra_Formal : declare\n+                  Add_Extra_Formal : declare\n                      Encl : constant SI_Type := Enclosing_Subp (J);\n                      STJE : Subp_Entry renames Subps.Table (Encl);\n                      --  Index and Subp_Entry for enclosing routine\n@@ -688,56 +687,44 @@ package body Exp_Unst is\n                      --  The formal to be added. Note that n here is one less\n                      --  than the level of the subprogram itself (STJ.Ent).\n \n-                     Formb : Entity_Id;\n-                     --  If needed, this is the formal added to the body\n-\n                      procedure Add_Form_To_Spec (F : Entity_Id; S : Node_Id);\n                      --  S is an N_Function/Procedure_Specification node, and F\n-                     --  is the new entity to add to this subprogramn spec.\n+                     --  is the new entity to add to this subprogramn spec as\n+                     --  the last Extra_Formal.\n \n                      ----------------------\n                      -- Add_Form_To_Spec --\n                      ----------------------\n \n                      procedure Add_Form_To_Spec (F : Entity_Id; S : Node_Id) is\n                         Sub : constant Entity_Id := Defining_Unit_Name (S);\n+                        Ent : Entity_Id;\n \n                      begin\n-                        if No (First_Entity (Sub)) then\n-                           Set_First_Entity (Sub, F);\n-                           Set_Last_Entity (Sub, F);\n+                        --  Case of at least one Extra_Formal is present, set\n+                        --  ARECnF as the new last entry in the list.\n+\n+                        if Present (Extra_Formals (Sub)) then\n+                           Ent := Extra_Formals (Sub);\n+                           while Present (Extra_Formal (Ent)) loop\n+                              Ent := Extra_Formal (Ent);\n+                           end loop;\n+\n+                           Set_Extra_Formal (Ent, F);\n+\n+                        --  No Extra formals present\n \n                         else\n-                           declare\n-                              LastF : constant Entity_Id := Last_Formal (Sub);\n-                           begin\n-                              if No (LastF) then\n-                                 Set_Next_Entity (F, First_Entity (Sub));\n-                                 Set_First_Entity (Sub, F);\n-\n-                              else\n-                                 Set_Next_Entity (F, Next_Entity (LastF));\n-                                 Set_Next_Entity (LastF, F);\n-\n-                                 if Last_Entity (Sub) = LastF then\n-                                    Set_Last_Entity (Sub, F);\n-                                 end if;\n-                              end if;\n-                           end;\n-                        end if;\n+                           Set_Extra_Formals (Sub, F);\n+                           Ent := Last_Formal (Sub);\n \n-                        if No (Parameter_Specifications (S)) then\n-                           Set_Parameter_Specifications (S, Empty_List);\n+                           if Present (Ent) then\n+                              Set_Extra_Formal (Ent, F);\n+                           end if;\n                         end if;\n-\n-                        Append_To (Parameter_Specifications (S),\n-                          Make_Parameter_Specification (Sloc (F),\n-                            Defining_Identifier => F,\n-                            Parameter_Type      =>\n-                              New_Occurrence_Of (STJE.ARECnPT, Sloc (F))));\n                      end Add_Form_To_Spec;\n \n-                  --  Start of processing for Extra_Formal\n+                  --  Start of processing for Add_Extra_Formal\n \n                   begin\n                      --  Decorate the new formal entity\n@@ -758,12 +745,9 @@ package body Exp_Unst is\n                      --  Case of separate spec\n \n                      else\n-                        Formb := New_Entity (Nkind (Form), Sloc (Form));\n-                        Copy_Node (Form, Formb);\n                         Add_Form_To_Spec (Form, Parent (STJ.Ent));\n-                        Add_Form_To_Spec (Formb, Specification (STJ.Bod));\n                      end if;\n-                  end Extra_Formal;\n+                  end Add_Extra_Formal;\n                end if;\n \n                --  Processing for subprograms that have at least one nested"}, {"sha": "dce37c887fedc2ccd4b75e7cb9486bb8412bb358", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 72, "deletions": 85, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58009744b53fa118a5caac4e20135cd5dd41f4aa/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58009744b53fa118a5caac4e20135cd5dd41f4aa/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=58009744b53fa118a5caac4e20135cd5dd41f4aa", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -430,8 +430,8 @@ package body Sem_Aggr is\n       Aggr_Range : array (1 .. Aggr_Dimension) of Node_Id := (others => Empty);\n       --  Constrained N_Range of each index dimension in our aggregate itype\n \n-      Aggr_Low   : array (1 .. Aggr_Dimension) of Node_Id := (others => Empty);\n-      Aggr_High  : array (1 .. Aggr_Dimension) of Node_Id := (others => Empty);\n+      Aggr_Low  : array (1 .. Aggr_Dimension) of Node_Id := (others => Empty);\n+      Aggr_High : array (1 .. Aggr_Dimension) of Node_Id := (others => Empty);\n       --  Low and High bounds for each index dimension in our aggregate itype\n \n       Is_Fully_Positional : Boolean := True;\n@@ -607,7 +607,8 @@ package body Sem_Aggr is\n       --  regardless of the staticness of the bounds themselves. Subsequent\n       --  checks in exp_aggr verify that type is not packed, etc.\n \n-      Set_Size_Known_At_Compile_Time (Itype,\n+      Set_Size_Known_At_Compile_Time\n+        (Itype,\n          Is_Fully_Positional\n            and then Comes_From_Source (N)\n            and then Size_Known_At_Compile_Time (Component_Type (Typ)));\n@@ -778,7 +779,7 @@ package body Sem_Aggr is\n             Ind := First_Index (Etype (Comp));\n             while Present (Ind) loop\n                if Nkind (Ind) /= N_Range\n-                 or else Nkind (Low_Bound (Ind)) /= N_Integer_Literal\n+                 or else Nkind (Low_Bound (Ind))  /= N_Integer_Literal\n                  or else Nkind (High_Bound (Ind)) /= N_Integer_Literal\n                then\n                   return;\n@@ -807,8 +808,8 @@ package body Sem_Aggr is\n    begin\n       return No (Expressions (Aggr))\n         and then\n-          Nkind (First (Choices (First (Component_Associations (Aggr)))))\n-            = N_Others_Choice;\n+          Nkind (First (Choices (First (Component_Associations (Aggr))))) =\n+                                                              N_Others_Choice;\n    end Is_Others_Aggregate;\n \n    ----------------------------\n@@ -1294,8 +1295,8 @@ package body Sem_Aggr is\n \n             Expr_Pos :=\n               Make_Op_Add (Loc,\n-                           Left_Opnd  => To_Pos,\n-                           Right_Opnd => Make_Integer_Literal (Loc, Val));\n+                Left_Opnd  => To_Pos,\n+                Right_Opnd => Make_Integer_Literal (Loc, Val));\n \n             Expr :=\n               Make_Attribute_Reference\n@@ -1488,7 +1489,6 @@ package body Sem_Aggr is\n            and then Compile_Time_Known_Value (First (Expressions (From)))\n          then\n             Value := Expr_Value (First (Expressions (From)));\n-\n          else\n             Value := Uint_0;\n             OK := False;\n@@ -1553,8 +1553,8 @@ package body Sem_Aggr is\n \n                   if Paren_Count (Expr) > 0 then\n                      Error_Msg_N\n-                       (\"\\if single-component aggregate is intended,\"\n-                        & \" write e.g. (1 ='> ...)\", Expr);\n+                       (\"\\if single-component aggregate is intended, \"\n+                        & \"write e.g. (1 ='> ...)\", Expr);\n                   end if;\n \n                   return Failure;\n@@ -1636,12 +1636,10 @@ package body Sem_Aggr is\n \n       --  Variables local to Resolve_Array_Aggregate\n \n-      Assoc  : Node_Id;\n-      Choice : Node_Id;\n-      Expr   : Node_Id;\n-\n+      Assoc   : Node_Id;\n+      Choice  : Node_Id;\n+      Expr    : Node_Id;\n       Discard : Node_Id;\n-      pragma Warnings (Off, Discard);\n \n       Delete_Choice : Boolean;\n       --  Used when replacing a subtype choice with predicate by a list\n@@ -1687,7 +1685,6 @@ package body Sem_Aggr is\n          while Present (Assoc) loop\n             Choice := First (Choices (Assoc));\n             Delete_Choice := False;\n-\n             while Present (Choice) loop\n                if Nkind (Choice) = N_Others_Choice then\n                   Others_Present := True;\n@@ -1897,9 +1894,10 @@ package body Sem_Aggr is\n                      if Has_Dynamic_Predicate_Aspect\n                        (Entity (Subtype_Mark (Choice)))\n                      then\n-                        Error_Msg_NE (\"subtype& has dynamic predicate, \"\n-                          & \"not allowed in aggregate choice\",\n-                            Choice, Entity (Subtype_Mark (Choice)));\n+                        Error_Msg_NE\n+                          (\"subtype& has dynamic predicate, \"\n+                           & \"not allowed in aggregate choice\",\n+                           Choice, Entity (Subtype_Mark (Choice)));\n                      end if;\n \n                      --  Does the subtype indication evaluation raise CE?\n@@ -1964,8 +1962,8 @@ package body Sem_Aggr is\n                     and then Nb_Choices /= 1\n                   then\n                      Error_Msg_N\n-                       (\"dynamic or empty choice in aggregate \" &\n-                        \"must be the only choice\", Choice);\n+                       (\"dynamic or empty choice in aggregate \"\n+                        & \"must be the only choice\", Choice);\n                      return Failure;\n                   end if;\n \n@@ -2332,11 +2330,11 @@ package body Sem_Aggr is\n                   --  any of the bounds have values that are not known at\n                   --  compile time.\n \n-                  --  Another case warranting a warning is when the length is\n-                  --  right, but as above we have an index type that is an\n-                  --  enumeration, and the bounds do not match. This is a\n-                  --  case where dubious sliding is allowed and we generate\n-                  --  a warning that the bounds do not match.\n+                  --  Another case warranting a warning is when the length\n+                  --  is right, but as above we have an index type that is\n+                  --  an enumeration, and the bounds do not match. This is a\n+                  --  case where dubious sliding is allowed and we generate a\n+                  --  warning that the bounds do not match.\n \n                   if No (Expressions (N))\n                     and then Nkind (Index) = N_Range\n@@ -2444,9 +2442,7 @@ package body Sem_Aggr is\n \n             --  Ada 2005 (AI-231)\n \n-            if Ada_Version >= Ada_2005\n-              and then Known_Null (Expr)\n-            then\n+            if Ada_Version >= Ada_2005 and then Known_Null (Expr) then\n                Check_Can_Never_Be_Null (Etype (N), Expr);\n             end if;\n \n@@ -2471,9 +2467,7 @@ package body Sem_Aggr is\n \n             --  Ada 2005 (AI-231)\n \n-            if Ada_Version >= Ada_2005\n-              and then Known_Null (Assoc)\n-            then\n+            if Ada_Version >= Ada_2005 and then Known_Null (Assoc) then\n                Check_Can_Never_Be_Null (Etype (N), Expression (Assoc));\n             end if;\n \n@@ -2517,8 +2511,8 @@ package body Sem_Aggr is\n \n                   if Is_Tagged_Type (Etype (Expr)) then\n                      Check_Dynamically_Tagged_Expression\n-                       (Expr => Expr,\n-                        Typ  => Component_Type (Etype (N)),\n+                       (Expr        => Expr,\n+                        Typ         => Component_Type (Etype (N)),\n                         Related_Nod => N);\n                   end if;\n                end;\n@@ -2749,9 +2743,7 @@ package body Sem_Aggr is\n \n       --  In SPARK, the ancestor part cannot be a type mark\n \n-      if Is_Entity_Name (A)\n-        and then Is_Type (Entity (A))\n-      then\n+      if Is_Entity_Name (A) and then Is_Type (Entity (A)) then\n          Check_SPARK_05_Restriction (\"ancestor part cannot be a type mark\", A);\n \n          --  AI05-0115: if the ancestor part is a subtype mark, the ancestor\n@@ -2790,9 +2782,7 @@ package body Sem_Aggr is\n          return;\n       end if;\n \n-      if Is_Entity_Name (A)\n-        and then Is_Type (Entity (A))\n-      then\n+      if Is_Entity_Name (A) and then Is_Type (Entity (A)) then\n          A_Type := Get_Full_View (Entity (A));\n \n          if Valid_Ancestor_Type then\n@@ -2809,6 +2799,7 @@ package body Sem_Aggr is\n \n             Get_First_Interp (A, I, It);\n             while Present (It.Typ) loop\n+\n                --  Only consider limited interpretations in the Ada 2005 case\n \n                if Is_Tagged_Type (It.Typ)\n@@ -2828,7 +2819,8 @@ package body Sem_Aggr is\n \n             if A_Type = Any_Type then\n                if Ada_Version >= Ada_2005 then\n-                  Error_Msg_N (\"ancestor part must be of a tagged type\", A);\n+                  Error_Msg_N\n+                    (\"ancestor part must be of a tagged type\", A);\n                else\n                   Error_Msg_N\n                     (\"ancestor part must be of a nonlimited tagged type\", A);\n@@ -3184,12 +3176,11 @@ package body Sem_Aggr is\n       begin\n          Is_Box_Present := False;\n \n-         if Present (From) then\n-            Assoc := First (From);\n-         else\n+         if No (From) then\n             return Empty;\n          end if;\n \n+         Assoc := First (From);\n          while Present (Assoc) loop\n             Selector_Name := First (Choices (Assoc));\n             while Present (Selector_Name) loop\n@@ -3331,9 +3322,8 @@ package body Sem_Aggr is\n \n                            if Is_Generic_Type (Base_Type (Typ)) then\n                               Error_Msg_NE\n-                                (\"\\instance should provide actual \"\n-                                 & \"type with initialization for&\",\n-                                 Assoc, Typ);\n+                                (\"\\instance should provide actual type with \"\n+                                 & \"initialization for&\", Assoc, Typ);\n                            end if;\n                         end if;\n \n@@ -3381,6 +3371,7 @@ package body Sem_Aggr is\n       is\n          New_Copy : constant Node_Id :=\n                       New_Copy_Tree (Source, Map, New_Sloc, New_Scope);\n+\n       begin\n          --  Move the dimensions of Source to New_Copy\n \n@@ -3727,7 +3718,7 @@ package body Sem_Aggr is\n          then\n             Error_Msg_NE\n               (\"aggregate not available for type& whose ancestor \"\n-                 & \"has unknown discriminants \", N, Typ);\n+               & \"has unknown discriminants \", N, Typ);\n          end if;\n \n          if Has_Unknown_Discriminants (Typ)\n@@ -3774,7 +3765,7 @@ package body Sem_Aggr is\n             if not Discr_Present (Discrim) then\n                if Present (Expr) then\n                   Error_Msg_NE\n-                    (\"more than one value supplied for discriminant&\",\n+                    (\"more than one value supplied for discriminant &\",\n                      N, Discrim);\n                end if;\n \n@@ -3816,7 +3807,7 @@ package body Sem_Aggr is\n \n       if Has_Discriminants (Typ)\n         or else (Has_Unknown_Discriminants (Typ)\n-                   and then Present (Underlying_Record_View (Typ)))\n+                  and then Present (Underlying_Record_View (Typ)))\n       then\n          Build_Constrained_Itype : declare\n             Loc         : constant Source_Ptr := Sloc (N);\n@@ -3840,14 +3831,14 @@ package body Sem_Aggr is\n                  Make_Subtype_Indication (Loc,\n                    Subtype_Mark =>\n                      New_Occurrence_Of (Underlying_Record_View (Typ), Loc),\n-                   Constraint  =>\n+                   Constraint   =>\n                      Make_Index_Or_Discriminant_Constraint (Loc, C));\n             else\n                Indic :=\n                  Make_Subtype_Indication (Loc,\n                    Subtype_Mark =>\n                      New_Occurrence_Of (Base_Type (Typ), Loc),\n-                   Constraint  =>\n+                   Constraint   =>\n                      Make_Index_Or_Discriminant_Constraint (Loc, C));\n             end if;\n \n@@ -3895,6 +3886,7 @@ package body Sem_Aggr is\n \n          function Find_Private_Ancestor return Entity_Id is\n             Par : Entity_Id;\n+\n          begin\n             Par := Typ;\n             loop\n@@ -3941,8 +3933,7 @@ package body Sem_Aggr is\n                        Cunit_Entity\n                          (Get_Source_Unit (Base_Type (Etype (Ancestor))));\n                   begin\n-\n-                     --  check whether we are in a scope that has full view\n+                     --  Check whether we are in a scope that has full view\n                      --  over the private ancestor and its parent. This can\n                      --  only happen if the derivation takes place in a child\n                      --  unit of the unit that declares the parent, and we are\n@@ -3954,14 +3945,14 @@ package body Sem_Aggr is\n                        and then In_Open_Scopes (Scope (Ancestor))\n                        and then\n                         (In_Private_Part (Scope (Ancestor))\n-                           or else In_Package_Body (Scope (Ancestor)))\n+                          or else In_Package_Body (Scope (Ancestor)))\n                      then\n                         null;\n \n                      else\n                         Error_Msg_NE\n                           (\"type of aggregate has private ancestor&!\",\n-                              N, Root_Typ);\n+                           N, Root_Typ);\n                         Error_Msg_N (\"must use extension aggregate!\", N);\n                         return;\n                      end if;\n@@ -4102,9 +4093,7 @@ package body Sem_Aggr is\n \n          --  Ada 2005 (AI-231)\n \n-         if Ada_Version >= Ada_2005\n-           and then Known_Null (Positional_Expr)\n-         then\n+         if Ada_Version >= Ada_2005 and then Known_Null (Positional_Expr) then\n             Check_Can_Never_Be_Null (Component, Positional_Expr);\n          end if;\n \n@@ -4306,31 +4295,33 @@ package body Sem_Aggr is\n                                  Assoc := First (Assoc_List);\n                                  while Present (Assoc) loop\n                                     if Present\n-                                      (Entity (First (Choices (Assoc))))\n+                                         (Entity (First (Choices (Assoc))))\n                                       and then\n-                                        Entity (First (Choices (Assoc)))\n-                                          = Val\n+                                        Entity (First (Choices (Assoc))) = Val\n                                     then\n                                        Discr_Val := Expression (Assoc);\n                                        exit;\n                                     end if;\n+\n                                     Next (Assoc);\n                                  end loop;\n                               end if;\n \n                               Add_Association\n                                 (Discr, New_Copy_Tree (Discr_Val),\n-                                  Component_Associations (New_Aggr));\n+                                 Component_Associations (New_Aggr));\n \n                               --  If the discriminant constraint is a current\n                               --  instance, mark the current aggregate so that\n                               --  the self-reference can be expanded later.\n+                              --  The constraint may refer to the subtype of\n+                              --  aggregate, so use base type for comparison.\n \n                               if Nkind (Discr_Val) = N_Attribute_Reference\n                                 and then Is_Entity_Name (Prefix (Discr_Val))\n                                 and then Is_Type (Entity (Prefix (Discr_Val)))\n-                                and then Etype (N) =\n-                                  Entity (Prefix (Discr_Val))\n+                                and then Base_Type (Etype (N)) =\n+                                           Entity (Prefix (Discr_Val))\n                               then\n                                  Set_Has_Self_Reference (N);\n                               end if;\n@@ -4340,9 +4331,9 @@ package body Sem_Aggr is\n                            end loop;\n                         end Add_Discriminant_Values;\n \n-                        ------------------------------\n-                        --  Propagate_Discriminants --\n-                        ------------------------------\n+                        -----------------------------\n+                        -- Propagate_Discriminants --\n+                        -----------------------------\n \n                         procedure Propagate_Discriminants\n                           (Aggr       : Node_Id;\n@@ -4365,13 +4356,13 @@ package body Sem_Aggr is\n                            --  inner aggregate, and recurse if component is\n                            --  itself composite.\n \n-                           ------------------------\n-                           --  Process_Component --\n-                           ------------------------\n+                           -----------------------\n+                           -- Process_Component --\n+                           -----------------------\n \n                            procedure Process_Component (Comp : Entity_Id) is\n-                              T : constant Entity_Id := Etype (Comp);\n-                              New_Aggr   : Node_Id;\n+                              T        : constant Entity_Id := Etype (Comp);\n+                              New_Aggr : Node_Id;\n \n                            begin\n                               if Is_Record_Type (T)\n@@ -4406,8 +4397,7 @@ package body Sem_Aggr is\n                            --  list of the current aggregate.\n \n                            if Nkind (Def_Node) =  N_Record_Definition\n-                             and then\n-                               Present (Component_List (Def_Node))\n+                             and then Present (Component_List (Def_Node))\n                              and then\n                                Present\n                                  (Variant_Part (Component_List (Def_Node)))\n@@ -4420,8 +4410,7 @@ package body Sem_Aggr is\n \n                               Comp_Elmt := First_Elmt (Components);\n                               while Present (Comp_Elmt) loop\n-                                 if\n-                                   Ekind (Node (Comp_Elmt)) /= E_Discriminant\n+                                 if Ekind (Node (Comp_Elmt)) /= E_Discriminant\n                                  then\n                                     Process_Component (Node (Comp_Elmt));\n                                  end if;\n@@ -4488,10 +4477,10 @@ package body Sem_Aggr is\n                                          (Component_Associations (Expr),\n                                           Make_Component_Association (Loc,\n                                             Choices     =>\n-                                              New_List\n-                                               (Make_Others_Choice (Loc)),\n+                                              New_List (\n+                                                Make_Others_Choice (Loc)),\n                                             Expression  => Empty,\n-                                               Box_Present => True));\n+                                            Box_Present => True));\n                                     end if;\n                                     exit;\n                                  end if;\n@@ -4567,9 +4556,7 @@ package body Sem_Aggr is\n \n                --  Ada 2005 (AI-287): others choice may have expression or box\n \n-               if No (Others_Etype)\n-                  and then not Others_Box\n-               then\n+               if No (Others_Etype) and then not Others_Box then\n                   Error_Msg_N\n                     (\"OTHERS must represent at least one component\", Selectr);\n                end if;"}, {"sha": "bd772f3ab3586a5b5ced4680131fe1e3f0ced486", "filename": "gcc/ada/sprint.adb", "status": "modified", "additions": 48, "deletions": 14, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58009744b53fa118a5caac4e20135cd5dd41f4aa/gcc%2Fada%2Fsprint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58009744b53fa118a5caac4e20135cd5dd41f4aa/gcc%2Fada%2Fsprint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsprint.adb?ref=58009744b53fa118a5caac4e20135cd5dd41f4aa", "patch": "@@ -309,8 +309,9 @@ package body Sprint is\n    --  characters {} if the Do_Overflow flag is set on the node N.\n \n    procedure Write_Param_Specs (N : Node_Id);\n-   --  Output parameter specifications for node (which is either a function\n-   --  or procedure specification with a Parameter_Specifications field)\n+   --  Output parameter specifications for node N (which is a subprogram, or\n+   --  entry or entry family or access-subprogram-definition, all of which\n+   --  have a Parameter_Specificatioons field).\n \n    procedure Write_Rewrite_Str (S : String);\n    --  Writes out a string (typically containing <<< or >>>}) for a node\n@@ -4554,17 +4555,25 @@ package body Sprint is\n    -----------------------\n \n    procedure Write_Param_Specs (N : Node_Id) is\n-      Specs  : List_Id;\n+      Specs         : constant List_Id := Parameter_Specifications (N);\n+      Specs_Present : constant Boolean := Is_Non_Empty_List (Specs);\n+\n+      Ent    : Entity_Id;\n+      Extras : Node_Id;\n       Spec   : Node_Id;\n       Formal : Node_Id;\n \n+      Output : Boolean := False;\n+      --  Set true if we output at least one parameter\n+\n    begin\n-      Specs := Parameter_Specifications (N);\n+      --  Write out explicit specs from Parameter_Speficiations list\n \n-      if Is_Non_Empty_List (Specs) then\n+      if Specs_Present then\n          Write_Str_With_Col_Check (\" (\");\n-         Spec := First (Specs);\n+         Output := True;\n \n+         Spec := First (Specs);\n          loop\n             Sprint_Node (Spec);\n             Formal := Defining_Identifier (Spec);\n@@ -4579,17 +4588,42 @@ package body Sprint is\n                Write_Str (\"; \");\n             end if;\n          end loop;\n+      end if;\n \n-         --  Write out any extra formals\n+      --  See if we have extra formals\n \n-         while Present (Extra_Formal (Formal)) loop\n-            Formal := Extra_Formal (Formal);\n-            Write_Str (\"; \");\n-            Write_Name_With_Col_Check (Chars (Formal));\n-            Write_Str (\" : \");\n-            Write_Name_With_Col_Check (Chars (Etype (Formal)));\n-         end loop;\n+      if Nkind_In (N, N_Function_Specification,\n+                      N_Procedure_Specification)\n+      then\n+         Ent := Defining_Entity (N);\n+\n+         --  Loop to write extra formals (if any)\n+\n+         if Present (Ent) and then Is_Subprogram (Ent) then\n+            Extras := Extra_Formals (Ent);\n+\n+            if Present (Extras) then\n+               if not Specs_Present then\n+                  Write_Str_With_Col_Check (\" (\");\n+                  Output := True;\n+               end if;\n+\n+               Formal := Extras;\n+               while Present (Formal) loop\n+                  if Specs_Present or else Formal /= Extras then\n+                     Write_Str (\"; \");\n+                  end if;\n+\n+                  Write_Name_With_Col_Check (Chars (Formal));\n+                  Write_Str (\" : \");\n+                  Write_Name_With_Col_Check (Chars (Etype (Formal)));\n+                  Formal := Extra_Formal (Formal);\n+               end loop;\n+            end if;\n+         end if;\n+      end if;\n \n+      if Output then\n          Write_Char (')');\n       end if;\n    end Write_Param_Specs;"}]}