{"sha": "35aff10b0f617c6f4dab622ec0d1700e270f16a0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzVhZmYxMGIwZjYxN2M2ZjRkYWI2MjJlYzBkMTcwMGUyNzBmMTZhMA==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@bigpond.net.au", "date": "2002-09-12T02:14:26Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2002-09-12T02:14:26Z"}, "message": "emit-rtl.c (set_mem_size): New function.\n\n\t* emit-rtl.c (set_mem_size): New function.\n\t* expr.h (set_mem_size): Declare.\n\t* config/rs6000/rs6000.c (expand_block_move_mem): Exterminate.\n\t(expand_block_move): Instead, use adjust_address and\n\treplace_equiv_address to generate proper aliasing info.\n\tMove common code out of conditionals.  Localize vars.\n\nFrom-SVN: r57047", "tree": {"sha": "c62e432b50d8732639f52957046a8db3bed14147", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c62e432b50d8732639f52957046a8db3bed14147"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/35aff10b0f617c6f4dab622ec0d1700e270f16a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35aff10b0f617c6f4dab622ec0d1700e270f16a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35aff10b0f617c6f4dab622ec0d1700e270f16a0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35aff10b0f617c6f4dab622ec0d1700e270f16a0/comments", "author": null, "committer": null, "parents": [{"sha": "874f6a6d1f62dd04490e67f5c19e4621902e9dfa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/874f6a6d1f62dd04490e67f5c19e4621902e9dfa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/874f6a6d1f62dd04490e67f5c19e4621902e9dfa"}], "stats": {"total": 253, "additions": 94, "deletions": 159}, "files": [{"sha": "701bd4c78457601c42a1ea07bffe428268663aac", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35aff10b0f617c6f4dab622ec0d1700e270f16a0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35aff10b0f617c6f4dab622ec0d1700e270f16a0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=35aff10b0f617c6f4dab622ec0d1700e270f16a0", "patch": "@@ -1,3 +1,12 @@\n+2002-09-12  Alan Modra  <amodra@bigpond.net.au>\n+\n+\t* emit-rtl.c (set_mem_size): New function.\n+\t* expr.h (set_mem_size): Declare.\n+\t* config/rs6000/rs6000.c (expand_block_move_mem): Exterminate.\n+\t(expand_block_move): Instead, use adjust_address and\n+\treplace_equiv_address to generate proper aliasing info.\n+\tMove common code out of conditionals.  Localize vars.\n+\n 2002-09-09  Eric Botcazou  ebotcazou@libertysurf.fr\n   \n \t* optabs.c (expand_binop): Minor cleanup."}, {"sha": "7195ce9c11b2675df2ae371c80f5711b4cb9b69d", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 71, "deletions": 159, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35aff10b0f617c6f4dab622ec0d1700e270f16a0/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35aff10b0f617c6f4dab622ec0d1700e270f16a0/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=35aff10b0f617c6f4dab622ec0d1700e270f16a0", "patch": "@@ -167,7 +167,6 @@ struct builtin_description\n \n static void rs6000_add_gc_roots PARAMS ((void));\n static int num_insns_constant_wide PARAMS ((HOST_WIDE_INT));\n-static rtx expand_block_move_mem PARAMS ((enum machine_mode, rtx, rtx));\n static void validate_condition_mode \n   PARAMS ((enum rtx_code, enum machine_mode));\n static rtx rs6000_generate_compare PARAMS ((enum rtx_code));\n@@ -6044,21 +6043,7 @@ rs6000_common_init_builtins ()\n     }\n }\n \n-/* Generate a memory reference for expand_block_move, copying volatile,\n-   and other bits from an original memory reference.  */\n-\n-static rtx\n-expand_block_move_mem (mode, addr, orig_mem)\n-     enum machine_mode mode;\n-     rtx addr;\n-     rtx orig_mem;\n-{\n-  rtx mem = gen_rtx_MEM (mode, addr);\n-\n-  MEM_COPY_ATTRIBUTES (mem, orig_mem);\n-  return mem;\n-}\n-\n+\f\n /* Expand a block move operation, and return 1 if successful.  Return 0\n    if we should let the compiler generate normal code.\n \n@@ -6081,14 +6066,6 @@ expand_block_move (operands)\n   int align;\n   int bytes;\n   int offset;\n-  int num_reg;\n-  int i;\n-  rtx src_reg;\n-  rtx dest_reg;\n-  rtx src_addr;\n-  rtx dest_addr;\n-  rtx tmp_reg;\n-  rtx stores[MAX_MOVE_REG];\n   int move_bytes;\n \n   /* If this is not a fixed size move, just call memcpy */\n@@ -6110,14 +6087,17 @@ expand_block_move (operands)\n   if (bytes > (TARGET_POWERPC64 ? 64 : 32))\n     return 0;\n \n-  /* Move the address into scratch registers.  */\n-  dest_reg = copy_addr_to_reg (XEXP (orig_dest, 0));\n-  src_reg  = copy_addr_to_reg (XEXP (orig_src,  0));\n-\n   if (TARGET_STRING)\t/* string instructions are available */\n     {\n-      for ( ; bytes > 0; bytes -= move_bytes)\n+      for (offset = 0; bytes > 0; offset += move_bytes, bytes -= move_bytes)\n \t{\n+\t  union {\n+\t    rtx (*movstrsi) PARAMS ((rtx, rtx, rtx, rtx));\n+\t    rtx (*mov) PARAMS ((rtx, rtx));\n+\t  } gen_func;\n+\t  enum machine_mode mode = BLKmode;\n+\t  rtx src, dest;\n+\n \t  if (bytes > 24\t\t/* move up to 32 bytes at a time */\n \t      && ! fixed_regs[5]\n \t      && ! fixed_regs[6]\n@@ -6129,15 +6109,7 @@ expand_block_move (operands)\n \t      && ! fixed_regs[12])\n \t    {\n \t      move_bytes = (bytes > 32) ? 32 : bytes;\n-\t      emit_insn (gen_movstrsi_8reg (expand_block_move_mem (BLKmode,\n-\t\t\t\t\t\t\t\t   dest_reg,\n-\t\t\t\t\t\t\t\t   orig_dest),\n-\t\t\t\t\t    expand_block_move_mem (BLKmode,\n-\t\t\t\t\t\t\t\t   src_reg,\n-\t\t\t\t\t\t\t\t   orig_src),\n-\t\t\t\t\t    GEN_INT ((move_bytes == 32)\n-\t\t\t\t\t\t     ? 0 : move_bytes),\n-\t\t\t\t\t    align_rtx));\n+\t      gen_func.movstrsi = gen_movstrsi_8reg;\n \t    }\n \t  else if (bytes > 16\t/* move up to 24 bytes at a time */\n \t\t   && ! fixed_regs[5]\n@@ -6148,14 +6120,7 @@ expand_block_move (operands)\n \t\t   && ! fixed_regs[10])\n \t    {\n \t      move_bytes = (bytes > 24) ? 24 : bytes;\n-\t      emit_insn (gen_movstrsi_6reg (expand_block_move_mem (BLKmode,\n-\t\t\t\t\t\t\t\t   dest_reg,\n-\t\t\t\t\t\t\t\t   orig_dest),\n-\t\t\t\t\t    expand_block_move_mem (BLKmode,\n-\t\t\t\t\t\t\t\t   src_reg,\n-\t\t\t\t\t\t\t\t   orig_src),\n-\t\t\t\t\t    GEN_INT (move_bytes),\n-\t\t\t\t\t    align_rtx));\n+\t      gen_func.movstrsi = gen_movstrsi_6reg;\n \t    }\n \t  else if (bytes > 8\t/* move up to 16 bytes at a time */\n \t\t   && ! fixed_regs[5]\n@@ -6164,123 +6129,92 @@ expand_block_move (operands)\n \t\t   && ! fixed_regs[8])\n \t    {\n \t      move_bytes = (bytes > 16) ? 16 : bytes;\n-\t      emit_insn (gen_movstrsi_4reg (expand_block_move_mem (BLKmode,\n-\t\t\t\t\t\t\t\t   dest_reg,\n-\t\t\t\t\t\t\t\t   orig_dest),\n-\t\t\t\t\t    expand_block_move_mem (BLKmode,\n-\t\t\t\t\t\t\t\t   src_reg,\n-\t\t\t\t\t\t\t\t   orig_src),\n-\t\t\t\t\t    GEN_INT (move_bytes),\n-\t\t\t\t\t    align_rtx));\n+\t      gen_func.movstrsi = gen_movstrsi_4reg;\n \t    }\n \t  else if (bytes >= 8 && TARGET_POWERPC64\n \t\t   /* 64-bit loads and stores require word-aligned\n                       displacements.  */\n \t\t   && (align >= 8 || (! STRICT_ALIGNMENT && align >= 4)))\n \t    {\n \t      move_bytes = 8;\n-\t      tmp_reg = gen_reg_rtx (DImode);\n-\t      emit_move_insn (tmp_reg,\n-\t\t\t      expand_block_move_mem (DImode,\n-\t\t\t\t\t\t     src_reg, orig_src));\n-\t      emit_move_insn (expand_block_move_mem (DImode,\n-\t\t\t\t\t\t     dest_reg, orig_dest),\n-\t\t\t      tmp_reg);\n+\t      mode = DImode;\n+\t      gen_func.mov = gen_movdi;\n \t    }\n \t  else if (bytes > 4 && !TARGET_POWERPC64)\n \t    {\t\t\t/* move up to 8 bytes at a time */\n \t      move_bytes = (bytes > 8) ? 8 : bytes;\n-\t      emit_insn (gen_movstrsi_2reg (expand_block_move_mem (BLKmode,\n-\t\t\t\t\t\t\t\t   dest_reg,\n-\t\t\t\t\t\t\t\t   orig_dest),\n-\t\t\t\t\t    expand_block_move_mem (BLKmode,\n-\t\t\t\t\t\t\t\t   src_reg,\n-\t\t\t\t\t\t\t\t   orig_src),\n-\t\t\t\t\t    GEN_INT (move_bytes),\n-\t\t\t\t\t    align_rtx));\n+\t      gen_func.movstrsi = gen_movstrsi_2reg;\n \t    }\n \t  else if (bytes >= 4 && (align >= 4 || ! STRICT_ALIGNMENT))\n \t    {\t\t\t/* move 4 bytes */\n \t      move_bytes = 4;\n-\t      tmp_reg = gen_reg_rtx (SImode);\n-\t      emit_move_insn (tmp_reg,\n-\t\t\t      expand_block_move_mem (SImode,\n-\t\t\t\t\t\t     src_reg, orig_src));\n-\t      emit_move_insn (expand_block_move_mem (SImode,\n-\t\t\t\t\t\t     dest_reg, orig_dest),\n-\t\t\t      tmp_reg);\n+\t      mode = SImode;\n+\t      gen_func.mov = gen_movsi;\n \t    }\n \t  else if (bytes == 2 && (align >= 2 || ! STRICT_ALIGNMENT))\n \t    {\t\t\t/* move 2 bytes */\n \t      move_bytes = 2;\n-\t      tmp_reg = gen_reg_rtx (HImode);\n-\t      emit_move_insn (tmp_reg,\n-\t\t\t      expand_block_move_mem (HImode,\n-\t\t\t\t\t\t     src_reg, orig_src));\n-\t      emit_move_insn (expand_block_move_mem (HImode,\n-\t\t\t\t\t\t     dest_reg, orig_dest),\n-\t\t\t      tmp_reg);\n+\t      mode = HImode;\n+\t      gen_func.mov = gen_movhi;\n \t    }\n \t  else if (bytes == 1)\t/* move 1 byte */\n \t    {\n \t      move_bytes = 1;\n-\t      tmp_reg = gen_reg_rtx (QImode);\n-\t      emit_move_insn (tmp_reg,\n-\t\t\t      expand_block_move_mem (QImode,\n-\t\t\t\t\t\t     src_reg, orig_src));\n-\t      emit_move_insn (expand_block_move_mem (QImode,\n-\t\t\t\t\t\t     dest_reg, orig_dest),\n-\t\t\t      tmp_reg);\n+\t      mode = QImode;\n+\t      gen_func.mov = gen_movqi;\n \t    }\n \t  else\n \t    {\t\t\t/* move up to 4 bytes at a time */\n \t      move_bytes = (bytes > 4) ? 4 : bytes;\n-\t      emit_insn (gen_movstrsi_1reg (expand_block_move_mem (BLKmode,\n-\t\t\t\t\t\t\t\t   dest_reg,\n-\t\t\t\t\t\t\t\t   orig_dest),\n-\t\t\t\t\t    expand_block_move_mem (BLKmode,\n-\t\t\t\t\t\t\t\t   src_reg,\n-\t\t\t\t\t\t\t\t   orig_src),\n-\t\t\t\t\t    GEN_INT (move_bytes),\n-\t\t\t\t\t    align_rtx));\n+\t      gen_func.movstrsi = gen_movstrsi_1reg;\n \t    }\n \n-\t  if (bytes > move_bytes)\n+\t  src = adjust_address (orig_src, mode, offset);\n+\t  dest = adjust_address (orig_dest, mode, offset);\n+\n+\t  if (mode == BLKmode)\n \t    {\n-\t      if (! TARGET_POWERPC64)\n+\t      /* Move the address into scratch registers.  The movstrsi\n+\t\t patterns require zero offset.  */\n+\t      if (!REG_P (XEXP (src, 0)))\n \t\t{\n-\t\t  emit_insn (gen_addsi3 (src_reg, src_reg,\n-\t\t\t\t\t GEN_INT (move_bytes)));\n-\t\t  emit_insn (gen_addsi3 (dest_reg, dest_reg,\n-\t\t\t\t\t GEN_INT (move_bytes)));\n+\t\t  rtx src_reg = copy_addr_to_reg (XEXP (src, 0));\n+\t\t  src = replace_equiv_address (src, src_reg);\n \t\t}\n-\t      else\n+\t      set_mem_size (src, GEN_INT (move_bytes));\n+\n+\t      if (!REG_P (XEXP (dest, 0)))\n \t\t{\n-\t\t  emit_insn (gen_adddi3 (src_reg, src_reg,\n-\t\t\t\t\t GEN_INT (move_bytes)));\n-\t\t  emit_insn (gen_adddi3 (dest_reg, dest_reg,\n-\t\t\t\t\t GEN_INT (move_bytes)));\n+\t\t  rtx dest_reg = copy_addr_to_reg (XEXP (dest, 0));\n+\t\t  dest = replace_equiv_address (dest, dest_reg);\n \t\t}\n+\t      set_mem_size (dest, GEN_INT (move_bytes));\n+\n+\t      emit_insn ((*gen_func.movstrsi) (dest, src,\n+\t\t\t\t\t       GEN_INT (move_bytes & 31),\n+\t\t\t\t\t       align_rtx));\n+\t    }\n+\t  else\n+\t    {\n+\t      rtx tmp_reg = gen_reg_rtx (mode);\n+\n+\t      emit_insn ((*gen_func.mov) (tmp_reg, src));\n+\t      emit_insn ((*gen_func.mov) (dest, tmp_reg));\n \t    }\n \t}\n     }\n \n   else\t\t\t/* string instructions not available */\n     {\n-      num_reg = offset = 0;\n-      for ( ; bytes > 0; (bytes -= move_bytes), (offset += move_bytes))\n+      rtx stores[MAX_MOVE_REG];\n+      int num_reg = 0;\n+      int i;\n+\n+      for (offset = 0; bytes > 0; offset += move_bytes, bytes -= move_bytes)\n \t{\n-\t  /* Calculate the correct offset for src/dest */\n-\t  if (offset == 0)\n-\t    {\n-\t      src_addr  = src_reg;\n-\t      dest_addr = dest_reg;\n-\t    }\n-\t  else\n-\t    {\n-\t      src_addr = plus_constant (src_reg, offset);\n-\t      dest_addr = plus_constant (dest_reg, offset);\n-\t    }\n+\t  rtx (*gen_mov_func) PARAMS ((rtx, rtx));\n+\t  enum machine_mode mode;\n+\t  rtx src, dest, tmp_reg;\n \n \t  /* Generate the appropriate load and store, saving the stores\n \t     for later.  */\n@@ -6290,56 +6224,35 @@ expand_block_move (operands)\n \t      && (align >= 8 || (! STRICT_ALIGNMENT && align >= 4)))\n \t    {\n \t      move_bytes = 8;\n-\t      tmp_reg = gen_reg_rtx (DImode);\n-\t      emit_insn (gen_movdi (tmp_reg,\n-\t\t\t\t    expand_block_move_mem (DImode,\n-\t\t\t\t\t\t\t   src_addr,\n-\t\t\t\t\t\t\t   orig_src)));\n-\t      stores[num_reg++] = gen_movdi (expand_block_move_mem (DImode,\n-\t\t\t\t\t\t\t\t    dest_addr,\n-\t\t\t\t\t\t\t\t    orig_dest),\n-\t\t\t\t\t     tmp_reg);\n+\t      mode = DImode;\n+\t      gen_mov_func = gen_movdi;\n \t    }\n \t  else if (bytes >= 4 && (align >= 4 || ! STRICT_ALIGNMENT))\n \t    {\n \t      move_bytes = 4;\n-\t      tmp_reg = gen_reg_rtx (SImode);\n-\t      emit_insn (gen_movsi (tmp_reg,\n-\t\t\t\t    expand_block_move_mem (SImode,\n-\t\t\t\t\t\t\t   src_addr,\n-\t\t\t\t\t\t\t   orig_src)));\n-\t      stores[num_reg++] = gen_movsi (expand_block_move_mem (SImode,\n-\t\t\t\t\t\t\t\t    dest_addr,\n-\t\t\t\t\t\t\t\t    orig_dest),\n-\t\t\t\t\t     tmp_reg);\n+\t      mode = SImode;\n+\t      gen_mov_func = gen_movsi;\n \t    }\n \t  else if (bytes >= 2 && (align >= 2 || ! STRICT_ALIGNMENT))\n \t    {\n \t      move_bytes = 2;\n-\t      tmp_reg = gen_reg_rtx (HImode);\n-\t      emit_insn (gen_movhi (tmp_reg,\n-\t\t\t\t    expand_block_move_mem (HImode,\n-\t\t\t\t\t\t\t   src_addr,\n-\t\t\t\t\t\t\t   orig_src)));\n-\t      stores[num_reg++] = gen_movhi (expand_block_move_mem (HImode,\n-\t\t\t\t\t\t\t\t    dest_addr,\n-\t\t\t\t\t\t\t\t    orig_dest),\n-\t\t\t\t\t     tmp_reg);\n+\t      mode = HImode;\n+\t      gen_mov_func = gen_movhi;\n \t    }\n \t  else\n \t    {\n \t      move_bytes = 1;\n-\t      tmp_reg = gen_reg_rtx (QImode);\n-\t      emit_insn (gen_movqi (tmp_reg,\n-\t\t\t\t    expand_block_move_mem (QImode,\n-\t\t\t\t\t\t\t   src_addr,\n-\t\t\t\t\t\t\t   orig_src)));\n-\t      stores[num_reg++] = gen_movqi (expand_block_move_mem (QImode,\n-\t\t\t\t\t\t\t\t    dest_addr,\n-\t\t\t\t\t\t\t\t    orig_dest),\n-\t\t\t\t\t     tmp_reg);\n+\t      mode = QImode;\n+\t      gen_mov_func = gen_movqi;\n \t    }\n \n+\t  src = adjust_address (orig_src, mode, offset);\n+\t  dest = adjust_address (orig_dest, mode, offset);\n+\t  tmp_reg = gen_reg_rtx (mode);\n+\n+\t  emit_insn ((*gen_mov_func) (tmp_reg, src));\n+\t  stores[num_reg++] = (*gen_mov_func) (dest, tmp_reg);\n+\n \t  if (num_reg >= MAX_MOVE_REG)\n \t    {\n \t      for (i = 0; i < num_reg; i++)\n@@ -13225,4 +13138,3 @@ rs6000_binds_local_p (decl)\n {\n   return default_binds_local_p_1 (decl, flag_pic || rs6000_flag_pic);\n }\n-"}, {"sha": "b8297a8808cfb0534be94235f5a01c0cb0e7201e", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35aff10b0f617c6f4dab622ec0d1700e270f16a0/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35aff10b0f617c6f4dab622ec0d1700e270f16a0/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=35aff10b0f617c6f4dab622ec0d1700e270f16a0", "patch": "@@ -1968,6 +1968,17 @@ set_mem_offset (mem, offset)\n \t\t\t\t   offset, MEM_SIZE (mem), MEM_ALIGN (mem),\n \t\t\t\t   GET_MODE (mem));\n }\n+\n+/* Set the size of MEM to SIZE.  */\n+\n+void\n+set_mem_size (mem, size)\n+     rtx mem, size;\n+{\n+  MEM_ATTRS (mem) = get_mem_attrs (MEM_ALIAS_SET (mem), MEM_EXPR (mem),\n+\t\t\t\t   MEM_OFFSET (mem), size, MEM_ALIGN (mem),\n+\t\t\t\t   GET_MODE (mem));\n+}\n \f\n /* Return a memory reference like MEMREF, but with its mode changed to MODE\n    and its address changed to ADDR.  (VOIDmode means don't change the mode."}, {"sha": "470ebd49a17933d77f19002df040826a14c9ecae", "filename": "gcc/expr.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35aff10b0f617c6f4dab622ec0d1700e270f16a0/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35aff10b0f617c6f4dab622ec0d1700e270f16a0/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=35aff10b0f617c6f4dab622ec0d1700e270f16a0", "patch": "@@ -616,6 +616,9 @@ extern void set_mem_expr PARAMS ((rtx, tree));\n /* Set the offset for MEM to OFFSET.  */\n extern void set_mem_offset PARAMS ((rtx, rtx));\n \n+/* Set the size for MEM to SIZE.  */\n+extern void set_mem_size PARAMS ((rtx, rtx));\n+\n /* Return a memory reference like MEMREF, but with its mode changed\n    to MODE and its address changed to ADDR.\n    (VOIDmode means don't change the mode."}]}