{"sha": "9adee3052156ae36271be28e3ad47dd975c26f42", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWFkZWUzMDUyMTU2YWUzNjI3MWJlMjhlM2FkNDdkZDk3NWMyNmY0Mg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-04T10:40:35Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-04T10:40:35Z"}, "message": "Use base inequality for some vector alias checks\n\nThis patch checks whether two data references x and y cannot\npartially overlap and so are independent whenever &x != &y.\nWe can then use this in the vectoriser to optimise alias checks.\n\ngcc/\n2016-08-04  Richard Sandiford  <richard.sandiford@linaro.org>\n\n\t* hash-traits.h (pair_hash): New struct.\n\t* tree-data-ref.h (data_dependence_relation): Add object_a and\n\tobject_b fields.\n\t(DDR_OBJECT_A, DDR_OBJECT_B): New macros.\n\t* tree-data-ref.c (initialize_data_dependence_relation): Initialize\n\tDDR_OBJECT_A and DDR_OBJECT_B.\n\t* tree-vectorizer.h (vec_object_pair): New type.\n\t(_loop_vec_info): Add a check_unequal_addrs field.\n\t(LOOP_VINFO_CHECK_UNEQUAL_ADDRS): New macro.\n\t(LOOP_REQUIRES_VERSIONING_FOR_ALIAS): Return true if there is an\n\tentry in check_unequal_addrs.  Check comp_alias_ddrs instead of\n\tmay_alias_ddrs.\n\t* tree-vect-loop.c (destroy_loop_vec_info): Release\n\tLOOP_VINFO_CHECK_UNEQUAL_ADDRS.\n\t(vect_analyze_loop_2): Likewise, when restarting.\n\t(vect_estimate_min_profitable_iters): Estimate the cost of\n\tLOOP_VINFO_CHECK_UNEQUAL_ADDRS.\n\t* tree-vect-data-refs.c: Include tree-hash-traits.h.\n\t(vect_prune_runtime_alias_test_list): Try to handle conflicts\n\tusing LOOP_VINFO_CHECK_UNEQUAL_ADDRS, if the data dependence allows.\n\tCount such tests in the final summary.\n\t* tree-vect-loop-manip.c (chain_cond_expr): New function.\n\t(vect_create_cond_for_align_checks): Use it.\n\t(vect_create_cond_for_unequal_addrs): New function.\n\t(vect_loop_versioning): Call it.\n\ngcc/testsuite/\n\t* gcc.dg/vect/vect-alias-check-6.c: New test.\n\nFrom-SVN: r250868", "tree": {"sha": "6f0ef701d303fb3c40566aa3bcbea2eea6ba1a52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f0ef701d303fb3c40566aa3bcbea2eea6ba1a52"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9adee3052156ae36271be28e3ad47dd975c26f42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9adee3052156ae36271be28e3ad47dd975c26f42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9adee3052156ae36271be28e3ad47dd975c26f42", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9adee3052156ae36271be28e3ad47dd975c26f42/comments", "author": null, "committer": null, "parents": [{"sha": "dfbddbeb1ca912c9f9f806d8cff55a6ac2887d89", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfbddbeb1ca912c9f9f806d8cff55a6ac2887d89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfbddbeb1ca912c9f9f806d8cff55a6ac2887d89"}], "stats": {"total": 214, "additions": 200, "deletions": 14}, "files": [{"sha": "a5c4f10347403238b7cd40af68d2f26dda61fb5e", "filename": "gcc/hash-traits.h", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9adee3052156ae36271be28e3ad47dd975c26f42/gcc%2Fhash-traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9adee3052156ae36271be28e3ad47dd975c26f42/gcc%2Fhash-traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-traits.h?ref=9adee3052156ae36271be28e3ad47dd975c26f42", "patch": "@@ -301,6 +301,76 @@ struct ggc_cache_ptr_hash : pointer_hash <T>, ggc_cache_remove <T *> {};\n \n struct nofree_string_hash : string_hash, typed_noop_remove <const char *> {};\n \n+/* Traits for pairs of values, using the first to record empty and\n+   deleted slots.  */\n+\n+template <typename T1, typename T2>\n+struct pair_hash\n+{\n+  typedef std::pair <typename T1::value_type,\n+\t\t     typename T2::value_type> value_type;\n+  typedef std::pair <typename T1::compare_type,\n+\t\t     typename T2::compare_type> compare_type;\n+\n+  static inline hashval_t hash (const value_type &);\n+  static inline bool equal (const value_type &, const compare_type &);\n+  static inline void remove (value_type &);\n+  static inline void mark_deleted (value_type &);\n+  static inline void mark_empty (value_type &);\n+  static inline bool is_deleted (const value_type &);\n+  static inline bool is_empty (const value_type &);\n+};\n+\n+template <typename T1, typename T2>\n+inline hashval_t\n+pair_hash <T1, T2>::hash (const value_type &x)\n+{\n+  return iterative_hash_hashval_t (T1::hash (x.first), T2::hash (x.second));\n+}\n+\n+template <typename T1, typename T2>\n+inline bool\n+pair_hash <T1, T2>::equal (const value_type &x, const compare_type &y)\n+{\n+  return T1::equal (x.first, y.first) && T2::equal (x.second, y.second);\n+}\n+\n+template <typename T1, typename T2>\n+inline void\n+pair_hash <T1, T2>::remove (value_type &x)\n+{\n+  T1::remove (x.first);\n+  T2::remove (x.second);\n+}\n+\n+template <typename T1, typename T2>\n+inline void\n+pair_hash <T1, T2>::mark_deleted (value_type &x)\n+{\n+  T1::mark_deleted (x.first);\n+}\n+\n+template <typename T1, typename T2>\n+inline void\n+pair_hash <T1, T2>::mark_empty (value_type &x)\n+{\n+  T1::mark_empty (x.first);\n+}\n+\n+template <typename T1, typename T2>\n+inline bool\n+pair_hash <T1, T2>::is_deleted (const value_type &x)\n+{\n+  return T1::is_deleted (x.first);\n+}\n+\n+template <typename T1, typename T2>\n+inline bool\n+pair_hash <T1, T2>::is_empty (const value_type &x)\n+{\n+  return T1::is_empty (x.first);\n+}\n+\n template <typename T> struct default_hash_traits : T {};\n \n template <typename T>"}, {"sha": "0993c69a5bd306c83b665f18a39606dbec3d897e", "filename": "gcc/testsuite/gcc.dg/vect/vect-alias-check-6.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9adee3052156ae36271be28e3ad47dd975c26f42/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9adee3052156ae36271be28e3ad47dd975c26f42/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-6.c?ref=9adee3052156ae36271be28e3ad47dd975c26f42", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_int } */\n+\n+#define N 16\n+\n+struct s { int x[N]; };\n+\n+void\n+f1 (struct s *a, struct s *b)\n+{\n+  for (int i = 0; i < N - 1; ++i)\n+    a->x[i + 1] += b->x[i];\n+}\n+\n+void\n+f2 (struct s *a, struct s *b)\n+{\n+  for (int i = 0; i < N; ++i)\n+    a->x[i] += b->x[N - i - 1];\n+}\n+\n+/* { dg-final { scan-tree-dump-times {checking that [^\\n]* and [^\\n]* have different addresses} 2 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"LOOP VECTORIZED\" 2 \"vect\" } } */"}, {"sha": "4956c030f10c0763bb0211ad5bf096c5536f1722", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9adee3052156ae36271be28e3ad47dd975c26f42/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9adee3052156ae36271be28e3ad47dd975c26f42/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=9adee3052156ae36271be28e3ad47dd975c26f42", "patch": "@@ -2506,6 +2506,15 @@ initialize_data_dependence_relation (struct data_reference *a,\n \t}\n \n       DDR_COULD_BE_INDEPENDENT_P (res) = true;\n+      if (!loop_nest.exists ()\n+\t  || (object_address_invariant_in_loop_p (loop_nest[0],\n+\t\t\t\t\t\t  full_seq.object_a)\n+\t      && object_address_invariant_in_loop_p (loop_nest[0],\n+\t\t\t\t\t\t     full_seq.object_b)))\n+\t{\n+\t  DDR_OBJECT_A (res) = full_seq.object_a;\n+\t  DDR_OBJECT_B (res) = full_seq.object_b;\n+\t}\n     }\n \n   DDR_AFFINE_P (res) = true;"}, {"sha": "0f22d9dfe2a8f0928e24e26d82f159d3f3a78f1d", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9adee3052156ae36271be28e3ad47dd975c26f42/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9adee3052156ae36271be28e3ad47dd975c26f42/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=9adee3052156ae36271be28e3ad47dd975c26f42", "patch": "@@ -309,6 +309,13 @@ struct data_dependence_relation\n        but the analyzer cannot be more specific.  */\n   tree are_dependent;\n \n+  /* If nonnull, COULD_BE_INDEPENDENT_P is true and the accesses are\n+     independent when the runtime addresses of OBJECT_A and OBJECT_B\n+     are different.  The addresses of both objects are invariant in the\n+     loop nest.  */\n+  tree object_a;\n+  tree object_b;\n+\n   /* For each subscript in the dependence test, there is an element in\n      this array.  This is the attribute that labels the edge A->B of\n      the data_dependence_relation.  */\n@@ -372,6 +379,8 @@ typedef struct data_dependence_relation *ddr_p;\n #define DDR_B(DDR) (DDR)->b\n #define DDR_AFFINE_P(DDR) (DDR)->affine_p\n #define DDR_ARE_DEPENDENT(DDR) (DDR)->are_dependent\n+#define DDR_OBJECT_A(DDR) (DDR)->object_a\n+#define DDR_OBJECT_B(DDR) (DDR)->object_b\n #define DDR_SUBSCRIPTS(DDR) (DDR)->subscripts\n #define DDR_SUBSCRIPT(DDR, I) DDR_SUBSCRIPTS (DDR)[I]\n #define DDR_NUM_SUBSCRIPTS(DDR) DDR_SUBSCRIPTS (DDR).length ()"}, {"sha": "a91e304327b06e6278846230ad87d2e00024c91a", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 32, "deletions": 7, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9adee3052156ae36271be28e3ad47dd975c26f42/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9adee3052156ae36271be28e3ad47dd975c26f42/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=9adee3052156ae36271be28e3ad47dd975c26f42", "patch": "@@ -51,6 +51,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"builtins.h\"\n #include \"params.h\"\n #include \"tree-cfg.h\"\n+#include \"tree-hash-traits.h\"\n \n /* Return true if load- or store-lanes optab OPTAB is implemented for\n    COUNT vectors of type VECTYPE.  NAME is the name of OPTAB.  */\n@@ -2986,10 +2987,14 @@ dependence_distance_ge_vf (data_dependence_relation *ddr,\n bool\n vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n {\n-  vec<ddr_p> may_alias_ddrs =\n-    LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo);\n-  vec<dr_with_seg_len_pair_t>& comp_alias_ddrs =\n-    LOOP_VINFO_COMP_ALIAS_DDRS (loop_vinfo);\n+  typedef pair_hash <tree_operand_hash, tree_operand_hash> tree_pair_hash;\n+  hash_set <tree_pair_hash> compared_objects;\n+\n+  vec<ddr_p> may_alias_ddrs = LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo);\n+  vec<dr_with_seg_len_pair_t> &comp_alias_ddrs\n+    = LOOP_VINFO_COMP_ALIAS_DDRS (loop_vinfo);\n+  vec<vec_object_pair> &check_unequal_addrs\n+    = LOOP_VINFO_CHECK_UNEQUAL_ADDRS (loop_vinfo);\n   int vect_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n   tree scalar_loop_iters = LOOP_VINFO_NITERS (loop_vinfo);\n \n@@ -3024,6 +3029,24 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n       if (dependence_distance_ge_vf (ddr, loop_depth, vect_factor))\n \tcontinue;\n \n+      if (DDR_OBJECT_A (ddr))\n+\t{\n+\t  vec_object_pair new_pair (DDR_OBJECT_A (ddr), DDR_OBJECT_B (ddr));\n+\t  if (!compared_objects.add (new_pair))\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\t{\n+\t\t  dump_printf_loc (MSG_NOTE, vect_location, \"checking that \");\n+\t\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, new_pair.first);\n+\t\t  dump_printf (MSG_NOTE, \" and \");\n+\t\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, new_pair.second);\n+\t\t  dump_printf (MSG_NOTE, \" have different addresses\\n\");\n+\t\t}\n+\t      LOOP_VINFO_CHECK_UNEQUAL_ADDRS (loop_vinfo).safe_push (new_pair);\n+\t    }\n+\t  continue;\n+\t}\n+\n       dr_a = DDR_A (ddr);\n       stmt_a = DR_STMT (DDR_A (ddr));\n       dr_group_first_a = GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt_a));\n@@ -3085,11 +3108,13 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n \n   prune_runtime_alias_test_list (&comp_alias_ddrs,\n \t\t\t\t (unsigned HOST_WIDE_INT) vect_factor);\n+\n+  unsigned int count = (comp_alias_ddrs.length ()\n+\t\t\t+ check_unequal_addrs.length ());\n   dump_printf_loc (MSG_NOTE, vect_location,\n \t\t   \"improved number of alias checks from %d to %d\\n\",\n-\t\t   may_alias_ddrs.length (), comp_alias_ddrs.length ());\n-  if ((int) comp_alias_ddrs.length () >\n-      PARAM_VALUE (PARAM_VECT_MAX_VERSION_FOR_ALIAS_CHECKS))\n+\t\t   may_alias_ddrs.length (), count);\n+  if ((int) count > PARAM_VALUE (PARAM_VECT_MAX_VERSION_FOR_ALIAS_CHECKS))\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,"}, {"sha": "f78e4b420c3ffdb5081ca6fa12cbe698d40ef850", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 39, "deletions": 6, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9adee3052156ae36271be28e3ad47dd975c26f42/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9adee3052156ae36271be28e3ad47dd975c26f42/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=9adee3052156ae36271be28e3ad47dd975c26f42", "patch": "@@ -1944,6 +1944,19 @@ vect_create_cond_for_niters_checks (loop_vec_info loop_vinfo, tree *cond_expr)\n     *cond_expr = part_cond_expr;\n }\n \n+/* Set *COND_EXPR to a tree that is true when both the original *COND_EXPR\n+   and PART_COND_EXPR are true.  Treat a null *COND_EXPR as \"true\".  */\n+\n+static void\n+chain_cond_expr (tree *cond_expr, tree part_cond_expr)\n+{\n+  if (*cond_expr)\n+    *cond_expr = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t      *cond_expr, part_cond_expr);\n+  else\n+    *cond_expr = part_cond_expr;\n+}\n+\n /* Function vect_create_cond_for_align_checks.\n \n    Create a conditional expression that represents the alignment checks for\n@@ -2054,11 +2067,28 @@ vect_create_cond_for_align_checks (loop_vec_info loop_vinfo,\n   ptrsize_zero = build_int_cst (int_ptrsize_type, 0);\n   part_cond_expr = fold_build2 (EQ_EXPR, boolean_type_node,\n \t\t\t\tand_tmp_name, ptrsize_zero);\n-  if (*cond_expr)\n-    *cond_expr = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n-\t\t\t      *cond_expr, part_cond_expr);\n-  else\n-    *cond_expr = part_cond_expr;\n+  chain_cond_expr (cond_expr, part_cond_expr);\n+}\n+\n+/* If LOOP_VINFO_CHECK_UNEQUAL_ADDRS contains <A1, B1>, ..., <An, Bn>,\n+   create a tree representation of: (&A1 != &B1) && ... && (&An != &Bn).\n+   Set *COND_EXPR to a tree that is true when both the original *COND_EXPR\n+   and this new condition are true.  Treat a null *COND_EXPR as \"true\".  */\n+\n+static void\n+vect_create_cond_for_unequal_addrs (loop_vec_info loop_vinfo, tree *cond_expr)\n+{\n+  vec<vec_object_pair> pairs = LOOP_VINFO_CHECK_UNEQUAL_ADDRS (loop_vinfo);\n+  unsigned int i;\n+  vec_object_pair *pair;\n+  FOR_EACH_VEC_ELT (pairs, i, pair)\n+    {\n+      tree addr1 = build_fold_addr_expr (pair->first);\n+      tree addr2 = build_fold_addr_expr (pair->second);\n+      tree part_cond_expr = fold_build2 (NE_EXPR, boolean_type_node,\n+\t\t\t\t\t addr1, addr2);\n+      chain_cond_expr (cond_expr, part_cond_expr);\n+    }\n }\n \n /* Function vect_create_cond_for_alias_checks.\n@@ -2158,7 +2188,10 @@ vect_loop_versioning (loop_vec_info loop_vinfo,\n \t\t\t\t       &cond_expr_stmt_list);\n \n   if (version_alias)\n-    vect_create_cond_for_alias_checks (loop_vinfo, &cond_expr);\n+    {\n+      vect_create_cond_for_unequal_addrs (loop_vinfo, &cond_expr);\n+      vect_create_cond_for_alias_checks (loop_vinfo, &cond_expr);\n+    }\n \n   cond_expr = force_gimple_operand_1 (cond_expr, &gimplify_stmt_list,\n \t\t\t\t      is_gimple_condexpr, NULL_TREE);"}, {"sha": "9723f134a3ce8cf36a245a0f2d023ec15fe1903c", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9adee3052156ae36271be28e3ad47dd975c26f42/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9adee3052156ae36271be28e3ad47dd975c26f42/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=9adee3052156ae36271be28e3ad47dd975c26f42", "patch": "@@ -1275,6 +1275,8 @@ destroy_loop_vec_info (loop_vec_info loop_vinfo, bool clean_stmts)\n   destroy_cost_data (LOOP_VINFO_TARGET_COST_DATA (loop_vinfo));\n   loop_vinfo->scalar_cost_vec.release ();\n \n+  LOOP_VINFO_CHECK_UNEQUAL_ADDRS (loop_vinfo).release ();\n+\n   free (loop_vinfo);\n   loop->aux = NULL;\n }\n@@ -2343,6 +2345,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n     }\n   /* Free optimized alias test DDRS.  */\n   LOOP_VINFO_COMP_ALIAS_DDRS (loop_vinfo).release ();\n+  LOOP_VINFO_CHECK_UNEQUAL_ADDRS (loop_vinfo).release ();\n   /* Reset target cost data.  */\n   destroy_cost_data (LOOP_VINFO_TARGET_COST_DATA (loop_vinfo));\n   LOOP_VINFO_TARGET_COST_DATA (loop_vinfo)\n@@ -3434,6 +3437,11 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n       unsigned len = LOOP_VINFO_COMP_ALIAS_DDRS (loop_vinfo).length ();\n       (void) add_stmt_cost (target_cost_data, len, vector_stmt, NULL, 0,\n \t\t\t    vect_prologue);\n+      len = LOOP_VINFO_CHECK_UNEQUAL_ADDRS (loop_vinfo).length ();\n+      if (len)\n+\t/* Count LEN - 1 ANDs and LEN comparisons.  */\n+\t(void) add_stmt_cost (target_cost_data, len * 2 - 1, scalar_stmt,\n+\t\t\t      NULL, 0, vect_prologue);\n       dump_printf (MSG_NOTE,\n                    \"cost model: Adding cost of checks for loop \"\n                    \"versioning aliasing.\\n\");"}, {"sha": "01c416c7cbfd1e977e5c9e6fe29228a2095ac090", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9adee3052156ae36271be28e3ad47dd975c26f42/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9adee3052156ae36271be28e3ad47dd975c26f42/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=9adee3052156ae36271be28e3ad47dd975c26f42", "patch": "@@ -149,6 +149,10 @@ typedef struct _slp_instance {\n \n \n \n+/* Describes two objects whose addresses must be unequal for the vectorized\n+   loop to be valid.  */\n+typedef std::pair<tree, tree> vec_object_pair;\n+\n /* Vectorizer state common between loop and basic-block vectorization.  */\n struct vec_info {\n   enum { bb, loop } kind;\n@@ -245,6 +249,9 @@ typedef struct _loop_vec_info : public vec_info {\n      lengths from which the run-time aliasing check is built.  */\n   vec<dr_with_seg_len_pair_t> comp_alias_ddrs;\n \n+  /* Check that the addresses of each pair of objects is unequal.  */\n+  vec<vec_object_pair> check_unequal_addrs;\n+\n   /* Statements in the loop that have data references that are candidates for a\n      runtime (loop versioning) misalignment check.  */\n   vec<gimple *> may_misalign_stmts;\n@@ -339,6 +346,7 @@ typedef struct _loop_vec_info : public vec_info {\n #define LOOP_VINFO_MAY_MISALIGN_STMTS(L)   (L)->may_misalign_stmts\n #define LOOP_VINFO_MAY_ALIAS_DDRS(L)       (L)->may_alias_ddrs\n #define LOOP_VINFO_COMP_ALIAS_DDRS(L)      (L)->comp_alias_ddrs\n+#define LOOP_VINFO_CHECK_UNEQUAL_ADDRS(L)  (L)->check_unequal_addrs\n #define LOOP_VINFO_GROUPED_STORES(L)       (L)->grouped_stores\n #define LOOP_VINFO_SLP_INSTANCES(L)        (L)->slp_instances\n #define LOOP_VINFO_SLP_UNROLLING_FACTOR(L) (L)->slp_unrolling_factor\n@@ -358,7 +366,8 @@ typedef struct _loop_vec_info : public vec_info {\n #define LOOP_REQUIRES_VERSIONING_FOR_ALIGNMENT(L)\t\\\n   ((L)->may_misalign_stmts.length () > 0)\n #define LOOP_REQUIRES_VERSIONING_FOR_ALIAS(L)\t\t\\\n-  ((L)->comp_alias_ddrs.length () > 0)\n+  ((L)->comp_alias_ddrs.length () > 0 \\\n+   || (L)->check_unequal_addrs.length () > 0)\n #define LOOP_REQUIRES_VERSIONING_FOR_NITERS(L)\t\t\\\n   (LOOP_VINFO_NITERS_ASSUMPTIONS (L))\n #define LOOP_REQUIRES_VERSIONING(L)\t\t\t\\"}]}