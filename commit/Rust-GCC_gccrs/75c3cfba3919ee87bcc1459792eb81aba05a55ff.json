{"sha": "75c3cfba3919ee87bcc1459792eb81aba05a55ff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzVjM2NmYmEzOTE5ZWU4N2JjYzE0NTk3OTJlYjgxYWJhMDVhNTVmZg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2005-05-06T10:23:03Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2005-05-06T10:23:03Z"}, "message": "m32r.c (m32r_encode_section_info): Use gcc_assert and gcc_unreachable, as appropriate.\n\n\t* config/m32r/m32r.c (m32r_encode_section_info): Use gcc_assert\n\tand gcc_unreachable, as appropriate.\n\t(gen_compare, gen_split_move_double, m32r_setup_incoming_varargs,\n\tm32r_expand_prologue, m32r_output_function_epilogue,\n\tm32r_legitimize_pic_address, m32r_print_operand_address,\n\temit_cond_move, m32r_function_symbol,\n\tm32r_output_block_move): Likewise.\n\t* config/m32r/m32r.h (INITIAL_ELIMINATION_OFFSET): Likewise.\n\t* config/m32r/m32r.md (\t*movsi_insn, *zero_branch_insn,\n\t*rev_zero_branch_insn): Likewise.\n\nFrom-SVN: r99309", "tree": {"sha": "793e795f3aee62d7de93699942e869e6b205028d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/793e795f3aee62d7de93699942e869e6b205028d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/75c3cfba3919ee87bcc1459792eb81aba05a55ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75c3cfba3919ee87bcc1459792eb81aba05a55ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75c3cfba3919ee87bcc1459792eb81aba05a55ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75c3cfba3919ee87bcc1459792eb81aba05a55ff/comments", "author": null, "committer": null, "parents": [{"sha": "46fb43a7cf213582042c78ff14fc11e039012a72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46fb43a7cf213582042c78ff14fc11e039012a72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46fb43a7cf213582042c78ff14fc11e039012a72"}], "stats": {"total": 88, "additions": 44, "deletions": 44}, "files": [{"sha": "442259eb8d48c8893ea03be00379d846438ed41b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75c3cfba3919ee87bcc1459792eb81aba05a55ff/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75c3cfba3919ee87bcc1459792eb81aba05a55ff/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=75c3cfba3919ee87bcc1459792eb81aba05a55ff", "patch": "@@ -1,3 +1,16 @@\n+2005-05-06  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* config/m32r/m32r.c (m32r_encode_section_info): Use gcc_assert\n+\tand gcc_unreachable, as appropriate.\n+\t(gen_compare, gen_split_move_double, m32r_setup_incoming_varargs,\n+\tm32r_expand_prologue, m32r_output_function_epilogue,\n+\tm32r_legitimize_pic_address, m32r_print_operand_address,\n+\temit_cond_move, m32r_function_symbol,\n+\tm32r_output_block_move): Likewise.\n+\t* config/m32r/m32r.h (INITIAL_ELIMINATION_OFFSET): Likewise.\n+\t* config/m32r/m32r.md (\t*movsi_insn, *zero_branch_insn,\n+\t*rev_zero_branch_insn): Likewise.\n+\t\n 2005-05-06  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/20961"}, {"sha": "fbe539433f5142f68a764346c909c1d1782d1084", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 27, "deletions": 40, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75c3cfba3919ee87bcc1459792eb81aba05a55ff/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75c3cfba3919ee87bcc1459792eb81aba05a55ff/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=75c3cfba3919ee87bcc1459792eb81aba05a55ff", "patch": "@@ -432,7 +432,7 @@ m32r_encode_section_info (tree decl, rtx rtl, int first)\n       else if (id == large_ident1 || id == large_ident2)\n \tmodel = M32R_MODEL_LARGE;\n       else\n-\tabort (); /* shouldn't happen */\n+\tgcc_unreachable (); /* shouldn't happen */\n     }\n   else\n     {\n@@ -443,7 +443,7 @@ m32r_encode_section_info (tree decl, rtx rtl, int first)\n       else if (TARGET_MODEL_LARGE)\n \tmodel = M32R_MODEL_LARGE;\n       else\n-\tabort (); /* shouldn't happen */\n+\tgcc_unreachable (); /* shouldn't happen */\n     }\n   extra_flags |= model << SYMBOL_FLAG_MODEL_SHIFT;\n \n@@ -700,7 +700,7 @@ gen_compare (enum rtx_code code, rtx x, rtx y, int need_compare)\n     case GEU: compare_code = LTU; branch_code = EQ; break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   if (need_compare)\n@@ -766,7 +766,7 @@ gen_compare (enum rtx_code code, rtx x, rtx y, int need_compare)\n \t\t  code = NE;\n \t\t  break;\n \t\tdefault:\n-\t\t  abort ();\n+\t\t  gcc_unreachable ();\n \t\t}\n \t      \n \t      return gen_rtx_fmt_ee (code, CCmode, cc_reg, const0_rtx);\n@@ -806,15 +806,15 @@ gen_compare (enum rtx_code code, rtx x, rtx y, int need_compare)\n \t\t  code = NE;\n \t\t  break;\n \t\tdefault:\n-\t\t  abort();\n+\t\t  gcc_unreachable ();\n \t\t}\n \t      \n \t      return gen_rtx_fmt_ee (code, CCmode, cc_reg, const0_rtx);\n \t    }\n \t  break;\n \n \tdefault:\n-\t  abort();\n+\t  gcc_unreachable ();\n \t}\n     }\n   else\n@@ -876,7 +876,7 @@ gen_compare (enum rtx_code code, rtx x, rtx y, int need_compare)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   return gen_rtx_fmt_ee (branch_code, VOIDmode, cc_reg, CONST0_RTX (CCmode));\n@@ -968,7 +968,7 @@ gen_split_move_double (rtx operands[])\n \t\t\t\t\t\t  !reverse * UNITS_PER_WORD)));\n \t}\n       else\n-\tabort ();\n+\tgcc_unreachable ();\n     }\n \n   /* Mem = reg.  */\n@@ -995,7 +995,7 @@ gen_split_move_double (rtx operands[])\n     }\n \n   else\n-    abort ();\n+    gcc_unreachable ();\n \n   val = get_insns ();\n   end_sequence ();\n@@ -1049,8 +1049,7 @@ m32r_setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n     return;\n \n   /* All BLKmode values are passed by reference.  */\n-  if (mode == BLKmode)\n-    abort ();\n+  gcc_assert (mode != BLKmode);\n \n   first_anon_arg = (ROUND_ADVANCE_CUM (*cum, mode, type)\n \t\t    + ROUND_ADVANCE_ARG (mode, type));\n@@ -1401,8 +1400,7 @@ m32r_expand_prologue (void)\n   gmask = current_frame_info.gmask;\n \n   /* These cases shouldn't happen.  Catch them now.  */\n-  if (current_frame_info.total_size == 0 && gmask)\n-    abort ();\n+  gcc_assert (current_frame_info.total_size || !gmask);\n \n   /* Allocate space for register arguments if this is a variadic function.  */\n   if (current_frame_info.pretend_size != 0)\n@@ -1512,8 +1510,7 @@ m32r_output_function_epilogue (FILE * file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n   /* This is only for the human reader.  */\n   fprintf (file, \"\\t%s EPILOGUE\\n\", ASM_COMMENT_START);\n \n-  if (!current_frame_info.initialized)\n-    abort ();\n+  gcc_assert (current_frame_info.initialized);\n   total_size = current_frame_info.total_size;\n \n   if (total_size == 0)\n@@ -1572,7 +1569,7 @@ m32r_output_function_epilogue (FILE * file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n \t\t     sp_str, reg_names[PROLOGUE_TMP_REGNUM]);\n \t}\n       else\n-\tabort ();\n+\tgcc_unreachable ();\n \n       if (current_frame_info.save_lr)\n \tfprintf (file, \"\\tpop %s\\n\", reg_names[RETURN_ADDR_REGNUM]);\n@@ -1654,10 +1651,8 @@ m32r_legitimize_pic_address (rtx orig, rtx reg)\n \n       if (reg == 0)\n         {\n-          if (reload_in_progress || reload_completed)\n-            abort ();\n-          else\n-            reg = gen_reg_rtx (Pmode);\n+          gcc_assert (!reload_in_progress && !reload_completed);\n+\t  reg = gen_reg_rtx (Pmode);\n \n           subregs = 1;\n         }\n@@ -1700,10 +1695,8 @@ m32r_legitimize_pic_address (rtx orig, rtx reg)\n \n       if (reg == 0)\n         {\n-          if (reload_in_progress || reload_completed)\n-            abort ();\n-          else\n-            reg = gen_reg_rtx (Pmode);\n+          gcc_assert (!reload_in_progress && !reload_completed);\n+\t  reg = gen_reg_rtx (Pmode);\n         }\n \n       if (GET_CODE (XEXP (orig, 0)) == PLUS)\n@@ -1721,11 +1714,11 @@ m32r_legitimize_pic_address (rtx orig, rtx reg)\n         {\n           if (INT16_P (INTVAL (offset)))\n             return plus_constant (base, INTVAL (offset));\n-          else if (! reload_in_progress && ! reload_completed)\n-            offset = force_reg (Pmode, offset);\n           else\n-            /* If we reach here, then something is seriously wrong.  */\n-            abort ();\n+\t    {\n+\t      gcc_assert (! reload_in_progress && ! reload_completed);\n+\t      offset = force_reg (Pmode, offset);\n+\t    }\n         }\n \n       return gen_rtx_PLUS (Pmode, base, offset);\n@@ -2045,9 +2038,7 @@ m32r_print_operand_address (FILE * file, rtx addr)\n \t}\n       else if (GET_CODE (base) == LO_SUM)\n \t{\n-\t  if (index != 0\n-\t      || GET_CODE (XEXP (base, 0)) != REG)\n-\t    abort ();\n+\t  gcc_assert (!index && GET_CODE (XEXP (base, 0)) == REG);\n \t  if (small_data_operand (XEXP (base, 1), VOIDmode))\n \t    fputs (\"sda(\", file);\n \t  else\n@@ -2117,12 +2108,9 @@ emit_cond_move (rtx * operands, rtx insn ATTRIBUTE_UNUSED)\n   buffer [0] = 0;\n   \n   /* Destination must be a register.  */\n-  if (GET_CODE (operands [0]) != REG)\n-    abort();\n-  if (! conditional_move_operand (operands [2], SImode))\n-    abort();\n-  if (! conditional_move_operand (operands [3], SImode))\n-    abort();\n+  gcc_assert (GET_CODE (operands [0]) == REG);\n+  gcc_assert (conditional_move_operand (operands [2], SImode));\n+  gcc_assert (conditional_move_operand (operands [3], SImode));\n       \n   /* Check to see if the test is reversed.  */\n   if (GET_CODE (operands [1]) == NE)\n@@ -2181,7 +2169,7 @@ m32r_function_symbol (const char *name)\n   else if (TARGET_MODEL_LARGE)\n     model = M32R_MODEL_LARGE;\n   else\n-    abort (); /* Shouldn't happen.  */\n+    gcc_unreachable (); /* Shouldn't happen.  */\n   extra_flags |= model << SYMBOL_FLAG_MODEL_SHIFT;\n                                                                                 \n   if (extra_flags)\n@@ -2320,8 +2308,7 @@ m32r_output_block_move (rtx insn ATTRIBUTE_UNUSED, rtx operands[])\n   int\t\tfirst_time;\n   int\t\tgot_extra = 0;\n   \n-  if (bytes < 1 || bytes > MAX_MOVE_BYTES)\n-    abort ();\n+  gcc_assert (bytes >= 1 && bytes <= MAX_MOVE_BYTES);\n   \n   /* We do not have a post-increment store available, so the first set of\n      stores are done without any increment, then the remaining ones can use"}, {"sha": "a83886f3cefa694930c24950df635e64b19da8e0", "filename": "gcc/config/m32r/m32r.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75c3cfba3919ee87bcc1459792eb81aba05a55ff/gcc%2Fconfig%2Fm32r%2Fm32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75c3cfba3919ee87bcc1459792eb81aba05a55ff/gcc%2Fconfig%2Fm32r%2Fm32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.h?ref=75c3cfba3919ee87bcc1459792eb81aba05a55ff", "patch": "@@ -907,7 +907,7 @@ extern enum reg_class m32r_regno_reg_class[FIRST_PSEUDO_REGISTER];\n       else if ((FROM) == ARG_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM)\t\\\n \t(OFFSET) = size - current_function_pretend_args_size;\t\t\t\\\n       else\t\t\t\t\t\t\t\t\t\\\n-\tabort ();\t\t\t\t\t\t\t\t\\\n+\tgcc_unreachable ();\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\t\\\n   while (0)\n \f"}, {"sha": "20f37d3f36c229c03731201c65f0413d6cdb18a1", "filename": "gcc/config/m32r/m32r.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75c3cfba3919ee87bcc1459792eb81aba05a55ff/gcc%2Fconfig%2Fm32r%2Fm32r.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75c3cfba3919ee87bcc1459792eb81aba05a55ff/gcc%2Fconfig%2Fm32r%2Fm32r.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.md?ref=75c3cfba3919ee87bcc1459792eb81aba05a55ff", "patch": "@@ -410,7 +410,7 @@\n       return \\\"st %1,%0\\\";\n     }\n \n-  abort ();\n+  gcc_unreachable ();\n }\"\n   [(set_attr \"type\" \"int2,int2,int4,int4,int4,multi,load2,load2,load4,store2,store2,store4\")\n    (set_attr \"length\" \"2,2,4,4,4,8,2,2,4,2,2,4\")])\n@@ -1515,7 +1515,7 @@\n       case LT : br = \\\"lt\\\"; invbr = \\\"ge\\\"; break;\n       case GE : br = \\\"ge\\\"; invbr = \\\"lt\\\"; break;\n \n-      default: abort();\n+      default: gcc_unreachable ();\n     }\n \n   /* Is branch target reachable with bxxz?  */\n@@ -1562,7 +1562,7 @@\n       case LT : br = \\\"lt\\\"; invbr = \\\"ge\\\"; break;\n       case GE : br = \\\"ge\\\"; invbr = \\\"lt\\\"; break;\n \n-      default: abort();\n+      default: gcc_unreachable ();\n     }\n \n   /* Is branch target reachable with bxxz?  */"}]}