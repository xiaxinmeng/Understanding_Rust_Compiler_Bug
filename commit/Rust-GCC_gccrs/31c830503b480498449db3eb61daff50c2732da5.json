{"sha": "31c830503b480498449db3eb61daff50c2732da5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzFjODMwNTAzYjQ4MDQ5ODQ0OWRiM2ViNjFkYWZmNTBjMjczMmRhNQ==", "commit": {"author": {"name": "Jeff Downs", "email": "heydowns@somuchpressure.net", "date": "2017-05-03T15:22:51Z"}, "committer": {"name": "Rainer Orth", "email": "ro@gcc.gnu.org", "date": "2017-05-03T15:22:51Z"}, "message": "Support escaping special characters in specs\n\n2017-05-03  Jeff Downs  <heydowns@somuchpressure.net>\n\t    Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n\n\t* gcc.c (handle_braces): Support escaping in switch matching\n\ttext.\n\t* doc/invoke.texi (Spec Files): Document it.\n\tRemove superfluous @code markup in items.\n\nCo-Authored-By: Rainer Orth <ro@CeBiTec.Uni-Bielefeld.DE>\n\nFrom-SVN: r247552", "tree": {"sha": "7cfa04c0b21f8701559d66a4b492b1c0003253f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7cfa04c0b21f8701559d66a4b492b1c0003253f2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31c830503b480498449db3eb61daff50c2732da5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31c830503b480498449db3eb61daff50c2732da5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31c830503b480498449db3eb61daff50c2732da5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31c830503b480498449db3eb61daff50c2732da5/comments", "author": null, "committer": null, "parents": [{"sha": "4d0e904fbf9c50e15e8c9f66ab41eaf58c2a309c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d0e904fbf9c50e15e8c9f66ab41eaf58c2a309c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d0e904fbf9c50e15e8c9f66ab41eaf58c2a309c"}], "stats": {"total": 95, "additions": 78, "deletions": 17}, "files": [{"sha": "92a4e395ba8680aa7470ba1b5a917eaa9cdffadc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31c830503b480498449db3eb61daff50c2732da5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31c830503b480498449db3eb61daff50c2732da5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=31c830503b480498449db3eb61daff50c2732da5", "patch": "@@ -1,3 +1,11 @@\n+2017-05-03  Jeff Downs  <heydowns@somuchpressure.net>\n+\t    Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n+\n+\t* gcc.c (handle_braces): Support escaping in switch matching\n+\ttext.\n+\t* doc/invoke.texi (Spec Files): Document it.\n+\tRemove superfluous @code markup in items.\n+\n 2017-05-03  David Malcolm  <dmalcolm@redhat.com>\n \n \t* diagnostic-show-locus.c (struct column_range): New struct."}, {"sha": "ec7b9aa550e54bea614bc6b530fb3b67a788b786", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31c830503b480498449db3eb61daff50c2732da5/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31c830503b480498449db3eb61daff50c2732da5/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=31c830503b480498449db3eb61daff50c2732da5", "patch": "@@ -26239,7 +26239,7 @@ Substitute the variable part of a matched option.  See below.\n Note that each comma in the substituted string is replaced by\n a single space.\n \n-@item %<@code{S}\n+@item %<S\n Remove all occurrences of @code{-S} from the command line.  Note---this\n command is position dependent.  @samp{%} commands in the spec string\n before this one see @code{-S}, @samp{%} commands in the spec string\n@@ -26337,39 +26337,39 @@ It is used to separate compiler options from assembler options\n in the @option{--target-help} output.\n @end table\n \n-@item %@{@code{S}@}\n+@item %@{S@}\n Substitutes the @code{-S} switch, if that switch is given to GCC@.\n If that switch is not specified, this substitutes nothing.  Note that\n the leading dash is omitted when specifying this option, and it is\n automatically inserted if the substitution is performed.  Thus the spec\n string @samp{%@{foo@}} matches the command-line option @option{-foo}\n and outputs the command-line option @option{-foo}.\n \n-@item %W@{@code{S}@}\n+@item %W@{S@}\n Like %@{@code{S}@} but mark last argument supplied within as a file to be\n deleted on failure.\n \n-@item %@{@code{S}*@}\n+@item %@{S*@}\n Substitutes all the switches specified to GCC whose names start\n with @code{-S}, but which also take an argument.  This is used for\n switches like @option{-o}, @option{-D}, @option{-I}, etc.\n GCC considers @option{-o foo} as being\n one switch whose name starts with @samp{o}.  %@{o*@} substitutes this\n text, including the space.  Thus two arguments are generated.\n \n-@item %@{@code{S}*&@code{T}*@}\n+@item %@{S*&T*@}\n Like %@{@code{S}*@}, but preserve order of @code{S} and @code{T} options\n (the order of @code{S} and @code{T} in the spec is not significant).\n There can be any number of ampersand-separated variables; for each the\n wild card is optional.  Useful for CPP as @samp{%@{D*&U*&A*@}}.\n \n-@item %@{@code{S}:@code{X}@}\n+@item %@{S:X@}\n Substitutes @code{X}, if the @option{-S} switch is given to GCC@.\n \n-@item %@{!@code{S}:@code{X}@}\n+@item %@{!S:X@}\n Substitutes @code{X}, if the @option{-S} switch is @emph{not} given to GCC@.\n \n-@item %@{@code{S}*:@code{X}@}\n+@item %@{S*:X@}\n Substitutes @code{X} if one or more switches whose names start with\n @code{-S} are specified to GCC@.  Normally @code{X} is substituted only\n once, no matter how many such switches appeared.  However, if @code{%*}\n@@ -26394,19 +26394,19 @@ when matching an option like @option{-mcu=newchip} produces:\n --script=newchip/memory.ld\n @end smallexample\n \n-@item %@{.@code{S}:@code{X}@}\n+@item %@{.S:X@}\n Substitutes @code{X}, if processing a file with suffix @code{S}.\n \n-@item %@{!.@code{S}:@code{X}@}\n+@item %@{!.S:X@}\n Substitutes @code{X}, if @emph{not} processing a file with suffix @code{S}.\n \n-@item %@{,@code{S}:@code{X}@}\n+@item %@{,S:X@}\n Substitutes @code{X}, if processing a file for language @code{S}.\n \n-@item %@{!,@code{S}:@code{X}@}\n+@item %@{!,S:X@}\n Substitutes @code{X}, if not processing a file for language @code{S}.\n \n-@item %@{@code{S}|@code{P}:@code{X}@}\n+@item %@{S|P:X@}\n Substitutes @code{X} if either @code{-S} or @code{-P} is given to\n GCC@.  This may be combined with @samp{!}, @samp{.}, @samp{,}, and\n @code{*} sequences as well, although they have a stronger binding than\n@@ -26441,7 +26441,14 @@ be as many clauses as you need.  This may be combined with @code{.},\n \n @end table\n \n-The conditional text @code{X} in a %@{@code{S}:@code{X}@} or similar\n+The switch matching text @code{S} in a @samp{%@{S@}}, @samp{%@{S:X@}}\n+or similar construct can use a backslash to ignore the special meaning\n+of the character following it, thus allowing literal matching of a\n+character that is otherwise specially treated.  For example,\n+@samp{%@{std=iso9899\\:1999:X@}} substitutes @code{X} if the\n+@option{-std=iso9899:1999} option is given.\n+\n+The conditional text @code{X} in a @samp{%@{S:X@}} or similar\n construct may contain other nested @samp{%} constructs or spaces, or\n even newlines.  They are processed as usual, as described above.\n Trailing white space in @code{X} is ignored.  White space may also"}, {"sha": "120c5c0792a38afe06f7ddb5bd13209eb08a8a2c", "filename": "gcc/gcc.c", "status": "modified", "additions": 49, "deletions": 3, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31c830503b480498449db3eb61daff50c2732da5/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31c830503b480498449db3eb61daff50c2732da5/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=31c830503b480498449db3eb61daff50c2732da5", "patch": "@@ -584,6 +584,12 @@ or with constant text in a single argument.\n \n  %(Spec) processes a specification defined in a specs file as *Spec:\n \n+The switch matching text S in a %{S}, %{S:X}, or similar construct can use\n+a backslash to ignore the special meaning of the character following it,\n+thus allowing literal matching of a character that is otherwise specially\n+treated.  For example, %{std=iso9899\\:1999:X} substitutes X if the\n+-std=iso9899:1999 option is given.\n+\n The conditional text X in a %{S:X} or similar construct may contain\n other nested % constructs or spaces, or even newlines.  They are\n processed as usual, as described above.  Trailing white space in X is\n@@ -6237,6 +6243,8 @@ handle_braces (const char *p)\n {\n   const char *atom, *end_atom;\n   const char *d_atom = NULL, *d_end_atom = NULL;\n+  char *esc_buf = NULL, *d_esc_buf = NULL;\n+  int esc;\n   const char *orig = p;\n \n   bool a_is_suffix;\n@@ -6287,11 +6295,42 @@ handle_braces (const char *p)\n \t    p++, a_is_spectype = true;\n \n \t  atom = p;\n+\t  esc = 0;\n \t  while (ISIDNUM (*p) || *p == '-' || *p == '+' || *p == '='\n-\t\t || *p == ',' || *p == '.' || *p == '@')\n-\t    p++;\n+\t\t || *p == ',' || *p == '.' || *p == '@' || *p == '\\\\')\n+\t    {\n+\t      if (*p == '\\\\')\n+\t\t{\n+\t\t  p++;\n+\t\t  if (!*p)\n+\t\t    fatal_error (input_location,\n+\t\t\t\t \"braced spec %qs ends in escape\", orig);\n+\t\t  esc++;\n+\t\t}\n+\t      p++;\n+\t    }\n \t  end_atom = p;\n \n+\t  if (esc)\n+\t    {\n+\t      const char *ap;\n+\t      char *ep;\n+\n+\t      if (esc_buf && esc_buf != d_esc_buf)\n+\t\tfree (esc_buf);\n+\t      esc_buf = NULL;\n+\t      ep = esc_buf = (char *) xmalloc (end_atom - atom - esc + 1);\n+\t      for (ap = atom; ap != end_atom; ap++, ep++)\n+\t\t{\n+\t\t  if (*ap == '\\\\')\n+\t\t    ap++;\n+\t\t  *ep = *ap;\n+\t\t}\n+\t      *ep = '\\0';\n+\t      atom = esc_buf;\n+\t      end_atom = ep;\n+\t    }\n+\n \t  if (*p == '*')\n \t    p++, a_is_starred = 1;\n \t}\n@@ -6358,6 +6397,7 @@ handle_braces (const char *p)\n \t\t      disj_matched = true;\n \t\t      d_atom = atom;\n \t\t      d_end_atom = end_atom;\n+\t\t      d_esc_buf = esc_buf;\n \t\t    }\n \t\t}\n \t    }\n@@ -6369,7 +6409,7 @@ handle_braces (const char *p)\n \t      p = process_brace_body (p + 1, d_atom, d_end_atom, disj_starred,\n \t\t\t\t      disj_matched && !n_way_matched);\n \t      if (p == 0)\n-\t\treturn 0;\n+\t\tgoto done;\n \n \t      /* If we have an N-way choice, reset state for the next\n \t\t disjunction.  */\n@@ -6390,6 +6430,12 @@ handle_braces (const char *p)\n     }\n   while (*p++ != '}');\n \n+ done:\n+  if (d_esc_buf && d_esc_buf != esc_buf)\n+    free (d_esc_buf);\n+  if (esc_buf)\n+    free (esc_buf);\n+\n   return p;\n \n  invalid:"}]}