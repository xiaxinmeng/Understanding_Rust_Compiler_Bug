{"sha": "d27b7e69872b34890077e3dff291b4bcbc52e4cd", "node_id": "C_kwDOANBUbNoAKGQyN2I3ZTY5ODcyYjM0ODkwMDc3ZTNkZmYyOTFiNGJjYmM1MmU0Y2Q", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-12-06T18:29:30Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-12-06T18:29:30Z"}, "message": "ranger: Optimise irange_union\n\nWhen compiling an optabs.ii at -O2 with a release-checking build,\nthe hottest function in the profile was irange_union.  This patch\ntries to optimise it a bit.  The specific changes are:\n\n- Use quick_push rather than safe_push, since the final number\n  of entries is known in advance.\n\n- Avoid assigning wi::to_wide & co. to a temporary wide_int,\n  such as in:\n\n    wide_int val_j = wi::to_wide (res[j]);\n\n  wi::to_wide returns a wide_int \"view\" of the in-place INTEGER_CST\n  storage.  Assigning the result to wide_int forces an unnecessary\n  copy to temporary storage.\n\n  This is one area where \"auto\" helps a lot.  In the end though,\n  it seemed more readable to inline the wi::to_*s rather than\n  use auto.\n\n- Use to_widest_int rather than to_wide_int.  Both are functionally\n  correct, but to_widest_int is more efficient, for three reasons:\n\n  - to_wide returns a wide-int representation in which the most\n    significant element might not be canonically sign-extended.\n    This is because we want to allow the storage of an INTEGER_CST\n    like 0x1U << 31 to be accessed directly with both a wide_int view\n    (where only 32 bits matter) and a widest_int view (where many more\n    bits matter, and where the 32 bits are zero-extended to match the\n    unsigned type).  However, operating on uncanonicalised wide_int\n    forms is less efficient than operating on canonicalised forms.\n\n  - to_widest_int has a constant rather than variable precision and\n    there are never any redundant upper bits to worry about.\n\n  - Using widest_int avoids the need for an overflow check, since\n    there is enough precision to add 1 to any IL constant without\n    wrap-around.\n\nThis gives a ~2% compile-time speed up with the test above.\n\nI also tried adding a path for two single-pair ranges, but it\nwasn't a win.\n\ngcc/\n\t* value-range.cc (irange::irange_union): Use quick_push rather\n\tthan safe_push.  Use widest_int rather than wide_int.  Avoid\n\tassigning wi::to_* results to wide*_int temporaries.", "tree": {"sha": "702b9a2a1b93e6efa6a83ebe07dc9e7c9d3526f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/702b9a2a1b93e6efa6a83ebe07dc9e7c9d3526f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d27b7e69872b34890077e3dff291b4bcbc52e4cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d27b7e69872b34890077e3dff291b4bcbc52e4cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d27b7e69872b34890077e3dff291b4bcbc52e4cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d27b7e69872b34890077e3dff291b4bcbc52e4cd/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14dc5b71d7e845be4ac21b16e849d6689df81b67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14dc5b71d7e845be4ac21b16e849d6689df81b67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14dc5b71d7e845be4ac21b16e849d6689df81b67"}], "stats": {"total": 46, "additions": 13, "deletions": 33}, "files": [{"sha": "d38d07860723ca32cefbfcbd836b5c378a7310f8", "filename": "gcc/value-range.cc", "status": "modified", "additions": 13, "deletions": 33, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d27b7e69872b34890077e3dff291b4bcbc52e4cd/gcc%2Fvalue-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d27b7e69872b34890077e3dff291b4bcbc52e4cd/gcc%2Fvalue-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.cc?ref=d27b7e69872b34890077e3dff291b4bcbc52e4cd", "patch": "@@ -1550,70 +1550,50 @@ irange::irange_union (const irange &r)\n   // the merge is performed.\n   //\n   // [Xi,Yi]..[Xn,Yn]  U  [Xj,Yj]..[Xm,Ym]   -->  [Xk,Yk]..[Xp,Yp]\n-  tree ttype = r.type ();\n-  signop sign = TYPE_SIGN (ttype);\n-\n-  auto_vec<tree, 20> res;\n-  wide_int u1 ;\n-  wi::overflow_type ovf;\n+  auto_vec<tree, 20> res (m_num_ranges * 2 + r.m_num_ranges * 2);\n   unsigned i = 0, j = 0, k = 0;\n \n   while (i < m_num_ranges * 2 && j < r.m_num_ranges * 2)\n     {\n       // lower of Xi and Xj is the lowest point.\n-      if (wi::le_p (wi::to_wide (m_base[i]), wi::to_wide (r.m_base[j]), sign))\n+      if (wi::to_widest (m_base[i]) <= wi::to_widest (r.m_base[j]))\n \t{\n-\t  res.safe_push (m_base[i]);\n-\t  res.safe_push (m_base[i + 1]);\n+\t  res.quick_push (m_base[i]);\n+\t  res.quick_push (m_base[i + 1]);\n \t  k += 2;\n \t  i += 2;\n \t}\n       else\n \t{\n-\t  res.safe_push (r.m_base[j]);\n-\t  res.safe_push (r.m_base[j + 1]);\n+\t  res.quick_push (r.m_base[j]);\n+\t  res.quick_push (r.m_base[j + 1]);\n \t  k += 2;\n \t  j += 2;\n \t}\n     }\n   for ( ; i < m_num_ranges * 2; i += 2)\n     {\n-      res.safe_push (m_base[i]);\n-      res.safe_push (m_base[i + 1]);\n+      res.quick_push (m_base[i]);\n+      res.quick_push (m_base[i + 1]);\n       k += 2;\n     }\n   for ( ; j < r.m_num_ranges * 2; j += 2)\n     {\n-      res.safe_push (r.m_base[j]);\n-      res.safe_push (r.m_base[j + 1]);\n+      res.quick_push (r.m_base[j]);\n+      res.quick_push (r.m_base[j + 1]);\n       k += 2;\n     }\n \n   // Now normalize the vector removing any overlaps.\n   i = 2;\n-  int prec = TYPE_PRECISION (ttype);\n-  wide_int max_val = wi::max_value (prec, sign);\n   for (j = 2; j < k ; j += 2)\n     {\n-      wide_int val_im1 = wi::to_wide (res[i - 1]);\n-      if (val_im1 == max_val)\n-\tbreak;\n-      u1 = wi::add (val_im1, 1, sign, &ovf);\n-\n-      // Overflow indicates we are at MAX already.\n-      // A wide int bug requires the previous max_val check\n-      // trigger: gcc.c-torture/compile/pr80443.c  with -O3\n-      if (ovf == wi::OVF_OVERFLOW)\n-\tbreak;\n-\n-      wide_int val_j = wi::to_wide (res[j]);\n-      wide_int val_jp1 = wi::to_wide (res[j+1]);\n       // Current upper+1 is >= lower bound next pair, then we merge ranges.\n-      if (wi::ge_p (u1, val_j, sign))\n+      if (wi::to_widest (res[i - 1]) + 1 >= wi::to_widest (res[j]))\n \t{\n \t  // New upper bounds is greater of current or the next one.\n-\t  if (wi::gt_p (val_jp1, val_im1, sign))\n-\t    res [i - 1] = res[j + 1];\n+\t  if (wi::to_widest (res[j + 1]) > wi::to_widest (res[i - 1]))\n+\t    res[i - 1] = res[j + 1];\n \t}\n       else\n \t{"}]}