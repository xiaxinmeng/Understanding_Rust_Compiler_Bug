{"sha": "95eec0d671ffda4b666c138d426c503548981ed8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTVlZWMwZDY3MWZmZGE0YjY2NmMxMzhkNDI2YzUwMzU0ODk4MWVkOA==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2004-06-03T14:07:53Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2004-06-03T14:07:53Z"}, "message": "tree-ssa-ccp.c (varying_ssa_edges): New worklist.\n\n2004-06-03  Daniel Berlin  <dberlin@dberlin.org>\n\t\tKenneth Zadeck <zadeck@naturalbridge.com>\n\n\t* tree-ssa-ccp.c (varying_ssa_edges): New worklist.\n\t(add_var_to_ssa_edges_worklist): Add value argument.\n\tUpdate callers.\n\tUse new worklist.\n\t(process_ssa_edge_worklist): New function.\n\t(tree_ssa_ccp): Move worklist processing core to\n\tprocess_ssa_edge_worklist, and just call that for the two worklists.\n\nFrom-SVN: r82598", "tree": {"sha": "12af9b9a953f827a3fcaf207bde35ebb4587a732", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/12af9b9a953f827a3fcaf207bde35ebb4587a732"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/95eec0d671ffda4b666c138d426c503548981ed8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95eec0d671ffda4b666c138d426c503548981ed8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95eec0d671ffda4b666c138d426c503548981ed8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95eec0d671ffda4b666c138d426c503548981ed8/comments", "author": null, "committer": null, "parents": [{"sha": "6ce2bcb71c2f66918a8287090589a9d9ea45ed74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ce2bcb71c2f66918a8287090589a9d9ea45ed74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ce2bcb71c2f66918a8287090589a9d9ea45ed74"}], "stats": {"total": 103, "additions": 77, "deletions": 26}, "files": [{"sha": "55de96f8d40d64fb03ed4df4daae59ebc7228250", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95eec0d671ffda4b666c138d426c503548981ed8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95eec0d671ffda4b666c138d426c503548981ed8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=95eec0d671ffda4b666c138d426c503548981ed8", "patch": "@@ -1,4 +1,15 @@\n-2004-06-03  Steevn Bosscher  <stevenb@suse.de>\n+2004-06-03  Daniel Berlin  <dberlin@dberlin.org>\n+\t\tKenneth Zadeck <zadeck@naturalbridge.com>\n+\n+\t* tree-ssa-ccp.c (varying_ssa_edges): New worklist.\n+\t(add_var_to_ssa_edges_worklist): Add value argument.\n+\tUpdate callers.\n+\tUse new worklist.\n+\t(process_ssa_edge_worklist): New function.\n+\t(tree_ssa_ccp): Move worklist processing core to \n+\tprocess_ssa_edge_worklist, and just call that for the two worklists.\n+\n+2004-06-03  Steven Bosscher  <stevenb@suse.de>\n \n \t* basic-block.c (tail_recursion_label_list): Don't declare.\n \t(CLEANUP_PRE_SIBCALL): Remove.  Renumber the other CLEANUP_*"}, {"sha": "6127acbe2d30854f1018eef9eabd1e2ce6449314", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 65, "deletions": 25, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95eec0d671ffda4b666c138d426c503548981ed8/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95eec0d671ffda4b666c138d426c503548981ed8/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=95eec0d671ffda4b666c138d426c503548981ed8", "patch": "@@ -98,9 +98,28 @@ static value *value_vector;\n /* Worklist of SSA edges which will need reexamination as their definition\n    has changed.  SSA edges are def-use edges in the SSA web.  For each\n    edge, we store the definition statement or PHI node D.  The destination\n-   nodes that need to be visited are accessed using immediate_uses (D).  */\n+   nodes that need to be visited are accessed using immediate_uses\n+   (D).  */\n static GTY(()) varray_type ssa_edges;\n \n+/* Identical to SSA_EDGES.  For performance reasons, the list of SSA\n+   edges is split into two.  One contains all SSA edges who need to be\n+   reexamined because their lattice value changed to varying (this\n+   worklist), and the other contains all other SSA edges to be\n+   reexamined (ssa_edges).\n+   \n+   Since most values in the program are varying, the ideal situation\n+   is to move them to that lattice value as quickly as possible.\n+   Thus, it doesn't make sense to process any other type of lattice\n+   value until all varying values are propagated fully, which is one\n+   thing using the varying worklist achieves.  In addition, if you\n+   don't use a separate worklist for varying edges, you end up with\n+   situations where lattice values move from\n+   undefined->constant->varying instead of undefined->varying.\n+*/\n+static GTY(()) varray_type varying_ssa_edges;\n+\n+\n static void initialize (void);\n static void finalize (void);\n static void visit_phi_node (tree);\n@@ -109,7 +128,7 @@ static value cp_lattice_meet (value, value);\n static void visit_stmt (tree);\n static void visit_cond_stmt (tree);\n static void visit_assignment (tree);\n-static void add_var_to_ssa_edges_worklist (tree);\n+static void add_var_to_ssa_edges_worklist (tree, value);\n static void add_outgoing_control_edges (basic_block);\n static void add_control_edge (edge);\n static void def_to_varying (tree);\n@@ -132,6 +151,31 @@ static void cfg_blocks_add (basic_block);\n static basic_block cfg_blocks_get (void);\n static bool need_imm_uses_for (tree var);\n \n+/* Process an SSA edge worklist.  WORKLIST is the SSA edge worklist to\n+   drain. This pops statements off the given WORKLIST and processes\n+   them until there are no more statements on WORKLIST.  */\n+\n+static void\n+process_ssa_edge_worklist (varray_type *worklist)\n+{\n+  /* Drain the entire worklist.  */\n+  while (VARRAY_ACTIVE_SIZE (*worklist) > 0)\n+    {\n+      /* Pull the statement to simulate off the worklist.  */\n+      tree stmt = VARRAY_TOP_TREE (*worklist);\n+      stmt_ann_t ann = stmt_ann (stmt);\n+      VARRAY_POP (*worklist);\n+      \n+      /* visit_stmt can \"cancel\" reevaluation of some statements.\n+\t If it does, then in_ccp_worklist will be zero.  */\n+      if (ann->in_ccp_worklist)\n+\t{\n+\t  ann->in_ccp_worklist = 0;\n+\t  simulate_stmt (stmt);\n+\t}\n+    } \n+}\n+ \n /* Main entry point for SSA Conditional Constant Propagation.  FNDECL is\n    the declaration for the function to optimize.\n    \n@@ -148,7 +192,9 @@ tree_ssa_ccp (void)\n   initialize ();\n \n   /* Iterate until the worklists are empty.  */\n-  while (!cfg_blocks_empty_p () || VARRAY_ACTIVE_SIZE (ssa_edges) > 0)\n+  while (!cfg_blocks_empty_p () \n+\t || VARRAY_ACTIVE_SIZE (ssa_edges) > 0\n+\t || VARRAY_ACTIVE_SIZE (varying_ssa_edges) > 0)\n     {\n       if (!cfg_blocks_empty_p ())\n \t{\n@@ -157,23 +203,12 @@ tree_ssa_ccp (void)\n \t  simulate_block (dest_block);\n \t}\n \n-      /* The SSA_EDGES worklist can get rather large.  Go ahead and\n-         drain the entire worklist each iteration through this loop.  */\n-      while (VARRAY_ACTIVE_SIZE (ssa_edges) > 0)\n-\t{\n-\t  /* Pull the statement to simulate off the worklist.  */\n-\t  tree stmt = VARRAY_TOP_TREE (ssa_edges);\n-\t  stmt_ann_t ann = stmt_ann (stmt);\n-\t  VARRAY_POP (ssa_edges);\n-\n-\t  /* visit_stmt can \"cancel\" reevaluation of some statements.\n-\t     If it does, then in_ccp_worklist will be zero.  */\n-\t  if (ann->in_ccp_worklist)\n-\t    {\n-\t      ann->in_ccp_worklist = 0;\n-\t      simulate_stmt (stmt);\n-\t    }\n-\t}\n+      /* In order to move things to varying as quickly as\n+         possible,process the VARYING_SSA_EDGES worklist first.  */\n+      process_ssa_edge_worklist (&varying_ssa_edges);\n+\n+      /* Now process the SSA_EDGES worklist.  */\n+      process_ssa_edge_worklist (&ssa_edges);\n     }\n \n   /* Now perform substitutions based on the known constant values.  */\n@@ -1069,8 +1104,9 @@ initialize (void)\n   basic_block bb;\n   sbitmap virtual_var;\n \n-  /* Worklist of SSA edges.  */\n+  /* Worklists of SSA edges.  */\n   VARRAY_TREE_INIT (ssa_edges, 20, \"ssa_edges\");\n+  VARRAY_TREE_INIT (varying_ssa_edges, 20, \"varying_ssa_edges\");\n \n   executable_blocks = sbitmap_alloc (last_basic_block);\n   sbitmap_zero (executable_blocks);\n@@ -1187,6 +1223,7 @@ static void\n finalize (void)\n {\n   ssa_edges = NULL;\n+  varying_ssa_edges = NULL;\n   cfg_blocks = NULL;\n   free (value_vector);\n   sbitmap_free (bb_in_list);\n@@ -1258,9 +1295,9 @@ cfg_blocks_get (void)\n }\n \n /* We have just defined a new value for VAR.  Add all immediate uses\n-   of VAR to the ssa_edges worklist.  */\n+   of VAR to the ssa_edges or varying_ssa_edges worklist.  */\n static void\n-add_var_to_ssa_edges_worklist (tree var)\n+add_var_to_ssa_edges_worklist (tree var, value val)\n {\n   tree stmt = SSA_NAME_DEF_STMT (var);\n   dataflow_t df = get_immediate_uses (stmt);\n@@ -1277,7 +1314,10 @@ add_var_to_ssa_edges_worklist (tree var)\n \t  if (ann->in_ccp_worklist == 0)\n \t    {\n \t      ann->in_ccp_worklist = 1;\n-\t      VARRAY_PUSH_TREE (ssa_edges, use);\n+\t      if (val.lattice_val == VARYING)\n+\t\tVARRAY_PUSH_TREE (varying_ssa_edges, use);\n+\t      else\n+\t\tVARRAY_PUSH_TREE (ssa_edges, use);\n \t    }\n \t}\n     }\n@@ -1341,7 +1381,7 @@ set_lattice_value (tree var, value val)\n \t  fprintf (dump_file, \".  Adding definition to SSA edges.\\n\");\n \t}\n \n-      add_var_to_ssa_edges_worklist (var);\n+      add_var_to_ssa_edges_worklist (var, val);\n       *old = val;\n     }\n }"}]}