{"sha": "cc3bf3404e4b1cdd1110e450bd5df45fdaaaae85", "node_id": "C_kwDOANBUbNoAKGNjM2JmMzQwNGU0YjFjZGQxMTEwZTQ1MGJkNWRmNDVmZGFhYWFlODU", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-01-17T19:32:13Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-01-17T19:32:13Z"}, "message": "libstdc++: Directly implement hexfloat std::from_chars for binary32/64\n\nlibstdc++-v3/ChangeLog:\n\n\t* src/c++17/floating_from_chars.cc: Include <bit>.\n\t(ascii_to_hexit, starts_with_ci): Conditionally define.\n\t(__floating_from_chars_hex):  Conditionally define.\n\t(from_chars): Use __floating_from_chars_hex for\n\tchars_format::hex parsing of binary32/64 float/double.\n\t(testsuite/20_util/from_chars/7.cc): New test.", "tree": {"sha": "4aff96d3e0e99f9cd4d21f8a5c22a9c7f3ad6271", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4aff96d3e0e99f9cd4d21f8a5c22a9c7f3ad6271"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc3bf3404e4b1cdd1110e450bd5df45fdaaaae85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc3bf3404e4b1cdd1110e450bd5df45fdaaaae85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc3bf3404e4b1cdd1110e450bd5df45fdaaaae85", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc3bf3404e4b1cdd1110e450bd5df45fdaaaae85/comments", "author": null, "committer": null, "parents": [{"sha": "6cb61e50ade62f1e7c8653b8d6fc6a632fd3977f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cb61e50ade62f1e7c8653b8d6fc6a632fd3977f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6cb61e50ade62f1e7c8653b8d6fc6a632fd3977f"}], "stats": {"total": 526, "additions": 526, "deletions": 0}, "files": [{"sha": "3ad5b409da7befc669992b8415d9edbe9f7ab1c3", "filename": "libstdc++-v3/src/c++17/floating_from_chars.cc", "status": "modified", "additions": 374, "deletions": 0, "changes": 374, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc3bf3404e4b1cdd1110e450bd5df45fdaaaae85/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffloating_from_chars.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc3bf3404e4b1cdd1110e450bd5df45fdaaaae85/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffloating_from_chars.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffloating_from_chars.cc?ref=cc3bf3404e4b1cdd1110e450bd5df45fdaaaae85", "patch": "@@ -31,6 +31,7 @@\n #define _GLIBCXX_USE_CXX11_ABI 1\n \n #include <charconv>\n+#include <bit>\n #include <string>\n #include <memory_resource>\n #include <cfenv>\n@@ -396,6 +397,369 @@ namespace\n   }\n #endif\n \n+#if _GLIBCXX_FLOAT_IS_IEEE_BINARY32 && _GLIBCXX_DOUBLE_IS_IEEE_BINARY64\n+  // If the given ASCII character represents a hexit, return that hexit.\n+  // Otherwise return -1.\n+  int\n+  ascii_to_hexit(char ch)\n+  {\n+    if (ch >= '0' && ch <= '9')\n+      return ch - '0';\n+    if (ch >= 'a' && ch <= 'f')\n+      return ch - 'a' + 10;\n+    if (ch >= 'A' && ch <= 'F')\n+      return ch - 'A' + 10;\n+    return -1;\n+  }\n+\n+  // Return true iff [FIRST,LAST) begins with PREFIX, ignoring case.\n+  bool\n+  starts_with_ci(const char* first, const char* last, string_view prefix)\n+  {\n+    __glibcxx_requires_valid_range(first, last);\n+\n+    for (char ch : prefix)\n+      {\n+\t__glibcxx_assert(ch >= 'a' && ch <= 'z');\n+\tif (first == last || (*first != ch && *first != ch - 32))\n+\t  return false;\n+\t++first;\n+      }\n+\n+    return true;\n+  }\n+\n+  // An implementation of hexadecimal float parsing for binary32/64.\n+  template<typename T>\n+  from_chars_result\n+  __floating_from_chars_hex(const char* first, const char* last, T& value)\n+  {\n+    static_assert(is_same_v<T, float> || is_same_v<T, double>);\n+\n+    using uint_t = conditional_t<is_same_v<T, float>, uint32_t, uint64_t>;\n+    constexpr int mantissa_bits = is_same_v<T, float> ? 23 : 52;\n+    constexpr int exponent_bits = is_same_v<T, float> ? 8 : 11;\n+    constexpr int exponent_bias = (1 << (exponent_bits - 1)) - 1;\n+\n+    __glibcxx_requires_valid_range(first, last);\n+    if (first == last)\n+      return {first, errc::invalid_argument};\n+\n+    // Consume the sign bit.\n+    const char* const orig_first = first;\n+    bool sign_bit = false;\n+    if (*first == '-')\n+      {\n+\tsign_bit = true;\n+\t++first;\n+      }\n+\n+    // Handle \"inf\", \"infinity\", \"NaN\" and variants thereof.\n+    if (first != last)\n+      if (*first == 'i' || *first == 'I' || *first == 'n' || *first == 'N') [[unlikely]]\n+\t{\n+\t  if (starts_with_ci(first, last, \"inf\"sv))\n+\t    {\n+\t      first += strlen(\"inf\");\n+\t      if (starts_with_ci(first, last, \"inity\"sv))\n+\t\tfirst += strlen(\"inity\");\n+\n+\t      uint_t result = 0;\n+\t      result |= sign_bit;\n+\t      result <<= exponent_bits;\n+\t      result |= (1ull << exponent_bits) - 1;\n+\t      result <<= mantissa_bits;\n+\t      memcpy(&value, &result, sizeof(result));\n+\n+\t      return {first, errc{}};\n+\t    }\n+\t  else if (starts_with_ci(first, last, \"nan\"))\n+\t    {\n+\t      first += strlen(\"nan\");\n+\n+\t      if (first != last && *first == '(')\n+\t\t{\n+\t\t  // Tentatively consume the '(' as we look for an optional\n+\t\t  // n-char-sequence followed by a ')'.\n+\t\t  const char* const fallback_first = first;\n+\t\t  for (;;)\n+\t\t    {\n+\t\t      ++first;\n+\t\t      if (first == last)\n+\t\t\t{\n+\t\t\t  first = fallback_first;\n+\t\t\t  break;\n+\t\t\t}\n+\n+\t\t      char ch = *first;\n+\t\t      if (ch == ')')\n+\t\t\t{\n+\t\t\t  ++first;\n+\t\t\t  break;\n+\t\t\t}\n+\t\t      else if ((ch >= '0' && ch <= '9')\n+\t\t\t       || (ch >= 'a' && ch <= 'z')\n+\t\t\t       || (ch >= 'A' && ch <= 'Z')\n+\t\t\t       || ch == '_')\n+\t\t\tcontinue;\n+\t\t      else\n+\t\t\t{\n+\t\t\t  first = fallback_first;\n+\t\t\t  break;\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\n+\t      // We make the implementation-defined decision of ignoring the\n+\t      // sign bit and the n-char-sequence when assembling the NaN.\n+\t      uint_t result = 0;\n+\t      result <<= exponent_bits;\n+\t      result |= (1ull << exponent_bits) - 1;\n+\t      result <<= mantissa_bits;\n+\t      result |= (1ull << (mantissa_bits - 1)) | 1;\n+\t      memcpy(&value, &result, sizeof(result));\n+\n+\t      return {first, errc{}};\n+\t    }\n+\t}\n+\n+    // Consume all insignificant leading zeros in the whole part of the\n+    // mantissa.\n+    bool seen_hexit = false;\n+    while (first != last && *first == '0')\n+      {\n+\tseen_hexit = true;\n+\t++first;\n+      }\n+\n+    // Now consume the rest of the written mantissa, populating MANTISSA with\n+    // the first MANTISSA_BITS+k significant bits of the written mantissa, where\n+    // 1 <= k <= 4 is the bit width of the leading significant written hexit.\n+    //\n+    // Examples:\n+    //  After parsing \"1.2f3\", MANTISSA is 0x12f30000000000 (bit_width=52+1).\n+    //  After parsing \".0000f0e\", MANTISSA is 0xf0e00000000000 (bit_width=52+4).\n+    //  After parsing \".1234567890abcd8\", MANTISSA is 0x1234567890abcd (bit_width=52+1)\n+    //   and MIDPOINT_BIT is true (and NONZERO_TAIL is false).\n+    uint_t mantissa = 0;\n+    int mantissa_idx = mantissa_bits; // The current bit index into MANTISSA\n+\t\t\t\t       // into which we'll write the next hexit.\n+    int exponent_adjustment = 0; // How much we'd have to adjust the written\n+\t\t\t\t // exponent in order to represent the mantissa\n+\t\t\t\t // in scientific form h.hhhhhhhhhhhhh.\n+    bool midpoint_bit = false; // Whether the MANTISSA_BITS+k+1 significant\n+\t\t\t       // bit is set in the written mantissa.\n+    bool nonzero_tail = false; // Whether some bit thereafter is set in the\n+\t\t\t       // written mantissa.\n+    bool seen_decimal_point = false;\n+    for (; first != last; ++first)\n+      {\n+\tchar ch = *first;\n+\tif (ch == '.' && !seen_decimal_point)\n+\t  {\n+\t    seen_decimal_point = true;\n+\t    continue;\n+\t  }\n+\n+\tint hexit = ascii_to_hexit(ch);\n+\tif (hexit == -1)\n+\t  break;\n+\tseen_hexit = true;\n+\n+\tif (!seen_decimal_point && mantissa != 0)\n+\t  exponent_adjustment += 4;\n+\telse if (seen_decimal_point && mantissa == 0)\n+\t  {\n+\t    exponent_adjustment -= 4;\n+\t    if (hexit == 0x0)\n+\t      continue;\n+\t  }\n+\n+\tif (mantissa_idx >= 0)\n+\t  mantissa |= uint_t(hexit) << mantissa_idx;\n+\telse if (mantissa_idx >= -4)\n+\t  {\n+\t    if constexpr (is_same_v<T, float>)\n+\t      {\n+\t\t__glibcxx_assert(mantissa_idx == -1);\n+\t\tmantissa |= hexit >> 1;\n+\t\tmidpoint_bit = (hexit & 0b0001) != 0;\n+\t      }\n+\t    else\n+\t      {\n+\t\t__glibcxx_assert(mantissa_idx == -4);\n+\t\tmidpoint_bit = (hexit & 0b1000) != 0;\n+\t\tnonzero_tail = (hexit & 0b0111) != 0;\n+\t      }\n+\t  }\n+\telse\n+\t  nonzero_tail |= (hexit != 0x0);\n+\n+\tmantissa_idx -= 4;\n+      }\n+    if (mantissa != 0)\n+      __glibcxx_assert(__bit_width(mantissa) >= mantissa_bits + 1\n+\t\t       && __bit_width(mantissa) <= mantissa_bits + 4);\n+    else\n+      __glibcxx_assert(!midpoint_bit && !nonzero_tail);\n+\n+    if (!seen_hexit)\n+      // If we haven't seen any hexit at this point, the parse failed.\n+      return {orig_first, errc::invalid_argument};\n+\n+    // Parse the written exponent.\n+    int written_exponent = 0;\n+    if (first != last && *first == 'p')\n+      {\n+\t// Tentatively consume the 'p' and try to parse a decimal number.\n+\tconst char* const fallback_first = first;\n+\t++first;\n+\tif (first != last && *first == '+')\n+\t  ++first;\n+\tfrom_chars_result fcr = from_chars(first, last, written_exponent, 10);\n+\tif (fcr.ptr == first)\n+\t  // The parse failed, so undo consuming the 'p' and carry on as if the\n+\t  // exponent was omitted (i.e. is 0).\n+\t  first = fallback_first;\n+\telse\n+\t  {\n+\t    first = fcr.ptr;\n+\t    if (mantissa != 0 && fcr.ec == errc::result_out_of_range)\n+\t      // Punt on very large exponents for now. FIXME\n+\t      return {first, errc::result_out_of_range};\n+\t  }\n+      }\n+    int biased_exponent = written_exponent + exponent_bias;\n+    if (exponent_adjustment != 0)\n+      // The mantissa wasn't written in scientific form.  Adjust the exponent\n+      // so that we may assume scientific form.\n+      //\n+      // Examples;\n+      //  For input \"a.bcp5\", EXPONENT_ADJUSTMENT would be 0 since this\n+      //   written mantissa is already in scientific form.\n+      //  For input \"ab.cp5\", EXPONENT_ADJUSTMENT would be 4 since the\n+      //   scientific form is \"a.bcp9\".\n+      //  For input 0.0abcp5\", EXPONENT_ADJUSTMENT would be -8 since the\n+      //   scientific form is \"a.bcp-3\".\n+      biased_exponent += exponent_adjustment;\n+\n+    // Shifts the mantissa to the right by AMOUNT while updating\n+    // BIASED_EXPONENT, MIDPOINT_BIT and NONZERO_TAIL accordingly.\n+    auto shift_mantissa = [&] (int amount) {\n+      __glibcxx_assert(amount >= 0);\n+      if (amount > mantissa_bits + 1)\n+\t{\n+\t  // Shifting the mantissa by an amount greater than its precision.\n+\t  nonzero_tail |= midpoint_bit;\n+\t  nonzero_tail |= mantissa != 0;\n+\t  midpoint_bit = false;\n+\t  mantissa = 0;\n+\t  biased_exponent += amount;\n+\t}\n+      else if (amount != 0)\n+\t{\n+\t  nonzero_tail |= midpoint_bit;\n+\t  nonzero_tail |= (mantissa & ((1ull << (amount - 1)) - 1)) != 0;\n+\t  midpoint_bit = (mantissa & (1ull << (amount - 1))) != 0;\n+\t  mantissa >>= amount;\n+\t  biased_exponent += amount;\n+\t}\n+    };\n+\n+    if (mantissa != 0)\n+      {\n+\t// If the leading hexit is not '1', shift MANTISSA to make it so.\n+\t// This normalizes input like \"4.08p0\" into \"1.02p2\".\n+\tconst int leading_hexit = mantissa >> mantissa_bits;\n+\tconst int leading_hexit_width = __bit_width(leading_hexit); // FIXME: optimize?\n+\t__glibcxx_assert(leading_hexit_width >= 1 && leading_hexit_width <= 4);\n+\tshift_mantissa(leading_hexit_width - 1);\n+\t// After this adjustment, we can assume the leading hexit is '1'.\n+\t__glibcxx_assert((mantissa >> mantissa_bits) == 0x1);\n+      }\n+\n+    if (biased_exponent <= 0)\n+      {\n+\t// This number is too small to be represented as a normal number, so\n+\t// try for a subnormal number by shifting the mantissa sufficiently.\n+\t// We need to shift by 1 more than -BIASED_EXPONENT because the leading\n+\t// mantissa bit is omitted in the representation of a normal number but\n+\t// not in a subnormal number.\n+\tshift_mantissa(-biased_exponent + 1);\n+\t__glibcxx_assert(!(mantissa & (1ull << mantissa_bits)));\n+\t__glibcxx_assert(biased_exponent == 1);\n+\tbiased_exponent = 0;\n+      }\n+\n+    // Perform round-to-nearest, tie-to-even rounding according to\n+    // MIDPOINT_BIT and NONZERO_TAIL.\n+    if (midpoint_bit && (nonzero_tail || (mantissa % 2) != 0))\n+      {\n+\t// Rounding away from zero.\n+\t++mantissa;\n+\tmidpoint_bit = false;\n+\tnonzero_tail = false;\n+\n+\t// Deal with a couple of corner cases after rounding.\n+\tif (mantissa == (1ull << mantissa_bits))\n+\t  {\n+\t    // We rounded the subnormal number 1.fffffffffffff...p-1023\n+\t    // up to the normal number 1p-1022.\n+\t    __glibcxx_assert(biased_exponent == 0);\n+\t    ++biased_exponent;\n+\t  }\n+\telse if (mantissa & (1ull << (mantissa_bits + 1)))\n+\t  {\n+\t    // We rounded the normal number 1.fffffffffffff8pN (with maximal\n+\t    // mantissa) up to to 1p(N+1).\n+\t    mantissa >>= 1;\n+\t    ++biased_exponent;\n+\t  }\n+      }\n+    else\n+      {\n+\t// Rounding toward zero.\n+\n+\tif (mantissa == 0 && (midpoint_bit || nonzero_tail))\n+\t  {\n+\t    // A nonzero number that rounds to zero is unrepresentable.\n+\t    __glibcxx_assert(biased_exponent == 0);\n+\t    return {first, errc::result_out_of_range};\n+\t  }\n+\n+\tmidpoint_bit = false;\n+\tnonzero_tail = false;\n+      }\n+\n+    if (mantissa != 0 && biased_exponent >= (1 << exponent_bits) - 1)\n+      // The exponent of this number is too large to be representable.\n+      return {first, errc::result_out_of_range};\n+\n+    uint_t result = 0;\n+    if (mantissa == 0)\n+      {\n+\t// Assemble a (possibly signed) zero.\n+\tif (sign_bit)\n+\t  result |= 1ull << (exponent_bits + mantissa_bits);\n+      }\n+    else\n+      {\n+\t// Assemble a nonzero normal or subnormal value.\n+\tresult |= sign_bit;\n+\tresult <<= exponent_bits;\n+\tresult |= biased_exponent;\n+\tresult <<= mantissa_bits;\n+\tresult |= mantissa & ((1ull << mantissa_bits) - 1);\n+\t// The implicit leading mantissa bit is set iff the number is normal.\n+\t__glibcxx_assert(((mantissa & (1ull << mantissa_bits)) != 0)\n+\t\t\t == (biased_exponent != 0));\n+      }\n+    memcpy(&value, &result, sizeof(result));\n+\n+    return {first, errc{}};\n+  }\n+#endif\n+\n } // namespace\n \n // FIXME: This should be reimplemented so it doesn't use strtod and newlocale.\n@@ -406,6 +770,11 @@ from_chars_result\n from_chars(const char* first, const char* last, float& value,\n \t   chars_format fmt) noexcept\n {\n+#if _GLIBCXX_FLOAT_IS_IEEE_BINARY32 && _GLIBCXX_DOUBLE_IS_IEEE_BINARY64\n+  if (fmt == chars_format::hex)\n+    return __floating_from_chars_hex(first, last, value);\n+#endif\n+\n   errc ec = errc::invalid_argument;\n #if _GLIBCXX_USE_CXX11_ABI\n   buffer_resource mr;\n@@ -432,6 +801,11 @@ from_chars_result\n from_chars(const char* first, const char* last, double& value,\n \t   chars_format fmt) noexcept\n {\n+#if _GLIBCXX_FLOAT_IS_IEEE_BINARY32 && _GLIBCXX_DOUBLE_IS_IEEE_BINARY64\n+  if (fmt == chars_format::hex)\n+    return __floating_from_chars_hex(first, last, value);\n+#endif\n+\n   errc ec = errc::invalid_argument;\n #if _GLIBCXX_USE_CXX11_ABI\n   buffer_resource mr;"}, {"sha": "2a78c7441e233030f784d6a1df1b920b2f142bcc", "filename": "libstdc++-v3/testsuite/20_util/from_chars/7.cc", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc3bf3404e4b1cdd1110e450bd5df45fdaaaae85/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffrom_chars%2F7.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc3bf3404e4b1cdd1110e450bd5df45fdaaaae85/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffrom_chars%2F7.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffrom_chars%2F7.cc?ref=cc3bf3404e4b1cdd1110e450bd5df45fdaaaae85", "patch": "@@ -0,0 +1,152 @@\n+// Testcases for binary64 hexfloat std::from_chars.\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target ieee_floats }\n+\n+#include <charconv>\n+\n+#include <cfenv>\n+#include <cmath>\n+#include <cstring>\n+#include <cstdio>\n+#include <limits>\n+#include <testsuite_hooks.h>\n+\n+struct testcase {\n+  const char* input;\n+  size_t correct_idx;\n+  std::errc correct_ec;\n+  double correct_value;\n+};\n+\n+constexpr testcase testcases[] = {\n+  { \"1.fffffffffffff8p0\", 18, {}, 0x1.fffffffffffff8p0 },\n+  { \"0.fffffffffffff8p-1022\", 22, std::errc{}, 0x0.fffffffffffffep-1022 },\n+  { \"inf\", 3, {}, std::numeric_limits<double>::infinity() },\n+  { \"inff\", 3, {}, std::numeric_limits<double>::infinity() },\n+  { \"-inf\", 4, {}, -std::numeric_limits<double>::infinity() },\n+  { \"-inff\", 4, {}, -std::numeric_limits<double>::infinity() },\n+  { \"NAN\", 3, {}, std::numeric_limits<double>::quiet_NaN() },\n+  { \"-NAN\", 4, {}, std::numeric_limits<double>::quiet_NaN() },\n+  { \"NAN()\", 5, {}, std::numeric_limits<double>::quiet_NaN() },\n+  { \"-NAN()\", 6, {}, std::numeric_limits<double>::quiet_NaN() },\n+  { \"-NAN(test)\", 10, {}, std::numeric_limits<double>::quiet_NaN() },\n+  { \"-NAN(test\", 4, {}, std::numeric_limits<double>::quiet_NaN() },\n+  { \"-NAN(\", 4, {}, std::numeric_limits<double>::quiet_NaN() },\n+  { \"0.000000000000001p-100000000000000000\", 37, std::errc::result_out_of_range, 0 },\n+  { \"-lol\", 0, std::errc::invalid_argument, 1 },\n+  { \" 0\", 0, std::errc::invalid_argument, 1 },\n+  { \"\", 0, std::errc::invalid_argument, 0 },\n+  { \"1\", 1, {}, 1 },\n+  { \"2\", 1, {}, 2 },\n+  { \"3\", 1, {}, 3 },\n+  { \"4\", 1, {}, 4 },\n+  { \"5\", 1, {}, 5 },\n+  { \"6\", 1, {}, 6 },\n+  { \"7\", 1, {}, 7 },\n+  { \"8\", 1, {}, 8 },\n+  { \"9\", 1, {}, 9 },\n+  { \"a\", 1, {}, 0xa },\n+  { \"b\", 1, {}, 0xb },\n+  { \"c\", 1, {}, 0xc },\n+  { \"d\", 1, {}, 0xd },\n+  { \"e\", 1, {}, 0xe },\n+  { \"f\", 1, {}, 0xf },\n+  { \"0.000000000000000000000000000000000000000000001p-1022\", 53,\n+      std::errc::result_out_of_range, 0 },\n+  { \"0.00000000000000p-1022\", 22, {}, 0 },\n+  { \"0.00000000000009\", 16, {}, 0x0.00000000000009p0 },\n+  { \"0.0\", 3, {}, 0 },\n+  { \"1p10000000000000000000000\", 25, std::errc::result_out_of_range, 0 },\n+  { \"-0.0\", 4, {}, -0.0 },\n+  { \"0.00000000000000\", 16, {}, 0 },\n+  { \"0.0000000000000p-1022\", 21, {}, 0 },\n+  { \".\", 0, std::errc::invalid_argument, 0 },\n+  { \"-.\", 0, std::errc::invalid_argument, 0 },\n+  { \"0\", 1, {}, 0 },\n+  { \"00\", 2, {}, 0 },\n+  { \"00.\", 3, {}, 0 },\n+  { \"0.\", 2, {}, 0 },\n+  { \"1.ffffFFFFFFFFFF\", 16, {}, 0x2 },\n+  { \"1.ffffffffffffff\", 16, {}, 0x2 },\n+  { \"1.00000000000029\", 16, {}, 0x1.0000000000003p0 },\n+  { \"0.00000000000008p-1022\", 22, std::errc::result_out_of_range, 0 },\n+  { \"1.fffffffffffffp-1023\", 21, {}, 0x1p-1022 },\n+  { \"1.fffffffffffff8p+1023\", 22, std::errc::result_out_of_range, 0 },\n+  { \"0.ffffffffffffe8p-1022\", 22, {}, 0x0.ffffffffffffep-1022 },\n+  { \"2.11111111111111\", 16, {},   0x1.0888888888889p+1 },\n+  { \"1.1111111111111\", 15, {}, 0x1.1111111111111p0 },\n+  { \"1.11111111111111\", 16, {}, 0x1.1111111111111p0 },\n+  { \"1.11111111111118\", 16, {}, 0x1.1111111111112p0 },\n+  { \"1.11111111111128\", 16, {}, 0x1.1111111111112p0 },\n+  { \"1.1111111111112801\", 18, {}, 0x1.1111111111113p0 },\n+  { \"1.08888888888888\", 16, {}, 0x1.0888888888888p0 },\n+  { \"1.088888888888888\", 17, {}, 0x1.0888888888889p0 },\n+  { \"2.00000000000029\", 16, {}, 0x2.0000000000002p0 },\n+  { \"0.ffffffffffffep-1022\", 21, {}, 0x0.ffffffffffffep-1022 },\n+  { \"3.ffffffffffffep-1024\", 21, {}, 0x1p-1022 },\n+  { \"1.00000000000008p+0\", 19, {}, 1 },\n+  { \"1p-1023\", 7, {}, 0x0.8p-1022 },\n+  { \"1p-1022\", 7, {}, 0x1p-1022 },\n+  { \"1.1p-1033\", 9, {}, 0x1.1p-1033 }, // 0.0022p-1022\n+  { \"22p-1038\", 8, {}, 0x1.1p-1033 },\n+  { \"5\", 1, {}, 0x5 },\n+  { \"a\", 1, {}, 0xa },\n+  { \"1\", 1, {}, 1.0 },\n+  { \"1p1\", 3, {}, 0x1p1 },\n+  { \"1p-1\", 4, {}, 0x1p-1 },\n+  { \"0\", 1, {}, 0.0 },\n+  { \"A\", 1, {}, 0xA },\n+  { \"-1\", 2, {}, -1.0 },\n+  { \"-0\", 2, {}, -0.0 },\n+  { \"42\", 2, {}, 0x42p0 },\n+  { \"-42\", 3, {}, -0x42p0 },\n+  { \".1\", 2, {}, 0x0.1p0 },\n+  { \"22p-1000\", 8, {}, 0x22p-1000 },\n+  { \".0000008\", 8, {}, 0x.0000008p0 },\n+  { \".0000008p-1022\", 14, {}, 0x.0000008p-1022 },\n+  { \"1p-1074\", 7, {}, 0x.0000000000001p-1022 },\n+  { \"9999999999999\", 13, {}, 0x9999999999999p0 },\n+  { \"1.000000000000a000\", 18, {}, 0x1.000000000000ap0 },\n+  { \"1.000000000000a001\", 18, {}, 0x1.000000000000ap0 },\n+  { \"1.000000000000a800\", 18, {}, 0x1.000000000000ap0 },\n+  { \"1.000000000000a801\", 18, {}, 0x1.000000000000bp0 },\n+  { \"1.000000000000b800\", 18, {}, 0x1.000000000000cp0 },\n+  { \"000000\", 6, {}, 0x0 },\n+  { \"1p\", 1, {}, 0x1 },\n+  { \"0p99999999999999999999\", 22, {}, 0 },\n+  { \"1p99999999999999999999\", 22, std::errc::result_out_of_range, 0 },\n+  { \"0p-99999999999999999999\", 23, {}, 0 },\n+  { \"1p-99999999999999999999\", 23, std::errc::result_out_of_range, 0 },\n+  { \"99999999999999999999999\", 23, {}, 0x99999999999999999999999p0 },\n+  { \"-1.fffffffffffffp-1023\", 22, {}, -0x1p-1022 },\n+  { \"1.337\", 5, {}, 0x1.337p0 },\n+};\n+\n+void\n+test01()\n+{\n+  for (auto [input,correct_idx,correct_ec,correct_value] : testcases)\n+    {\n+      double value;\n+      auto [ptr,ec] = std::from_chars(input, input+strlen(input),\n+\t\t\t\t      value, std::chars_format::hex);\n+      VERIFY( ptr == input + correct_idx );\n+      VERIFY( ec == correct_ec );\n+      if (ec == std::errc{})\n+\t{\n+\t  if (std::isnan(value) || std::isnan(correct_value))\n+\t    VERIFY( std::isnan(value) && std::isnan(correct_value) );\n+\t  else\n+\t    {\n+\t      VERIFY( value == correct_value );\n+\t      VERIFY( !memcmp(&value, &correct_value, sizeof(double)) );\n+\t    }\n+\t}\n+    }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}]}