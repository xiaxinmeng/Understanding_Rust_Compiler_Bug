{"sha": "01ad6816a1ebfcbccabd2aaecc22ffa8d047f0e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDFhZDY4MTZhMWViZmNiY2NhYmQyYWFlY2MyMmZmYThkMDQ3ZjBlNg==", "commit": {"author": {"name": "Hans-Peter Nilsson", "email": "hp@axis.com", "date": "2005-12-23T03:02:30Z"}, "committer": {"name": "Hans-Peter Nilsson", "email": "hp@gcc.gnu.org", "date": "2005-12-23T03:02:30Z"}, "message": "arit.c (do_31div): Clarify what \"31\" refers to.\n\n\t* config/cris/arit.c (do_31div): Clarify what \"31\" refers to.\n\t[L_divsi3] (__Udiv): Don't use as inline function.\n\t[L_modsi3] (__Umod): Ditto.\n\t(__Div): Rearrange to call do_31div directly instead of __Udiv.\n\t(__Mod): Similarly regarding __Umod.\n\nFrom-SVN: r109007", "tree": {"sha": "a4d658b19495ecaf09986eadff5e37d6bebc513e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a4d658b19495ecaf09986eadff5e37d6bebc513e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01ad6816a1ebfcbccabd2aaecc22ffa8d047f0e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01ad6816a1ebfcbccabd2aaecc22ffa8d047f0e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01ad6816a1ebfcbccabd2aaecc22ffa8d047f0e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01ad6816a1ebfcbccabd2aaecc22ffa8d047f0e6/comments", "author": {"login": "hpataxisdotcom", "id": 80339731, "node_id": "MDQ6VXNlcjgwMzM5NzMx", "avatar_url": "https://avatars.githubusercontent.com/u/80339731?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hpataxisdotcom", "html_url": "https://github.com/hpataxisdotcom", "followers_url": "https://api.github.com/users/hpataxisdotcom/followers", "following_url": "https://api.github.com/users/hpataxisdotcom/following{/other_user}", "gists_url": "https://api.github.com/users/hpataxisdotcom/gists{/gist_id}", "starred_url": "https://api.github.com/users/hpataxisdotcom/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hpataxisdotcom/subscriptions", "organizations_url": "https://api.github.com/users/hpataxisdotcom/orgs", "repos_url": "https://api.github.com/users/hpataxisdotcom/repos", "events_url": "https://api.github.com/users/hpataxisdotcom/events{/privacy}", "received_events_url": "https://api.github.com/users/hpataxisdotcom/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1c3a47459b84141aeba46bc1273fed8fb39c8d79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c3a47459b84141aeba46bc1273fed8fb39c8d79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c3a47459b84141aeba46bc1273fed8fb39c8d79"}], "stats": {"total": 98, "additions": 58, "deletions": 40}, "files": [{"sha": "1b64d262c5e735166aab526c20116aa20c3693f0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ad6816a1ebfcbccabd2aaecc22ffa8d047f0e6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ad6816a1ebfcbccabd2aaecc22ffa8d047f0e6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=01ad6816a1ebfcbccabd2aaecc22ffa8d047f0e6", "patch": "@@ -1,5 +1,11 @@\n 2005-12-23  Hans-Peter Nilsson  <hp@axis.com>\n \n+\t* config/cris/arit.c (do_31div): Clarify what \"31\" refers to.\n+\t[L_divsi3] (__Udiv): Don't use as inline function.\n+\t[L_modsi3] (__Umod): Ditto.\n+\t(__Div): Rearrange to call do_31div directly instead of __Udiv.\n+\t(__Mod): Similarly regarding __Umod.\n+\n \tPR target/24342\n \t* config/cris/cris.c (cris_split_movdx): Add REG_INC notes for\n \temitted insns with post-increments."}, {"sha": "e094ea76ec0f81ba09d450c2c5a324ec8542bafa", "filename": "gcc/config/cris/arit.c", "status": "modified", "additions": 52, "deletions": 40, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ad6816a1ebfcbccabd2aaecc22ffa8d047f0e6/gcc%2Fconfig%2Fcris%2Farit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ad6816a1ebfcbccabd2aaecc22ffa8d047f0e6/gcc%2Fconfig%2Fcris%2Farit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Farit.c?ref=01ad6816a1ebfcbccabd2aaecc22ffa8d047f0e6", "patch": "@@ -2,7 +2,8 @@\n    Contributed by Axis Communications.\n    Written by Hans-Peter Nilsson <hp@axis.se>, c:a 1992.\n \n-   Copyright (C) 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002,\n+   2005 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -62,7 +63,8 @@ struct quot_rem\n  };\n \n /* This is the worker function for div and mod.  It is inlined into the\n-   respective library function.  */\n+   respective library function.  Parameter A must have bit 31 == 0.  */\n+\n static __inline__ struct quot_rem\n do_31div (unsigned long a, unsigned long b)\n      __attribute__ ((__const__, __always_inline__));\n@@ -155,19 +157,10 @@ do_31div (unsigned long a, unsigned long b)\n   }\n }\n \n-/* Note that unsigned and signed division both build when L_divsi3, but\n-   the unsigned variant is then inlined, as with do_31div above.  */\n-#if defined (L_udivsi3) || defined (L_divsi3)\n-#ifndef L_udivsi3\n-static __inline__\n-#endif\n+#ifdef L_udivsi3\n unsigned long\n-__Udiv (unsigned long a, unsigned long b)\n-     __attribute__ ((__const__, __always_inline__));\n+__Udiv (unsigned long a, unsigned long b) __attribute__ ((__const__));\n \n-#ifndef L_udivsi3\n-static __inline__\n-#endif\n unsigned long\n __Udiv (unsigned long a, unsigned long b)\n {\n@@ -208,7 +201,7 @@ __Udiv (unsigned long a, unsigned long b)\n \n   return do_31div (a, b).quot+extra;\n }\n-\n+#endif /* L_udivsi3 */\n \n #ifdef L_divsi3\n long\n@@ -217,35 +210,40 @@ __Div (long a, long b) __attribute__ ((__const__));\n long\n __Div (long a, long b)\n {\n-  long sign;\n-  long result;\n-\n-  /* Do *not* call do_31div since abs (-2147483648) == 2147483648\n-     <=> abs (-0x80000000) == 0x80000000\n-     which is still 32 bits.  */\n+  long extra = 0;\n+  long sign = (b < 0) ? -1 : 1;\n+\n+  /* We need to handle a == -2147483648 as expected and must while\n+     doing that avoid producing a sequence like \"abs (a) < 0\" as GCC\n+     may optimize out the test.  That sequence may not be obvious as\n+     we call inline functions.  Testing for a being negative and\n+     handling (presumably much rarer than positive) enables us to get\n+     a bit of optimization for an (accumulated) reduction of the\n+     penalty of the 0x80000000 special-case.  */\n+  if (a < 0)\n+    {\n+      sign = -sign;\n \n-  sign = a ^ b;\n-  result = __Udiv (__builtin_labs (a), __builtin_labs (b));\n+      if ((a & 0x7fffffff) == 0)\n+\t{\n+\t  /* We're at 0x80000000.  Tread carefully.  */\n+\t  a -= b * sign;\n+\t  extra = sign;\n+\t}\n+      a = -a;\n+    }\n \n-  return  (sign < 0) ? -result : result;\n+  /* We knowingly penalize pre-v10 models by multiplication with the\n+     sign.  */\n+  return sign * do_31div (a, __builtin_labs (b)).quot + extra;\n }\n #endif /* L_divsi3 */\n-#endif /* L_udivsi3 || L_divsi3 */\n \n \n-/* Note that unsigned and signed modulus both build when L_modsi3, but\n-   then the unsigned variant is inlined, as with do_31div above.  */\n-#if defined (L_umodsi3) || defined (L_modsi3)\n-#ifndef L_umodsi3\n-static __inline__\n-#endif\n+#ifdef L_umodsi3\n unsigned long\n-__Umod (unsigned long a, unsigned long b)\n-     __attribute__ ((__const__, __always_inline__));\n+__Umod (unsigned long a, unsigned long b) __attribute__ ((__const__));\n \n-#ifndef L_umodsi3\n-static __inline__\n-#endif\n unsigned long\n __Umod (unsigned long a, unsigned long b)\n {\n@@ -279,6 +277,7 @@ __Umod (unsigned long a, unsigned long b)\n \n   return do_31div (a, b).rem;\n }\n+#endif /* L_umodsi3 */\n \n #ifdef L_modsi3\n long\n@@ -287,14 +286,27 @@ __Mod (long a, long b) __attribute__ ((__const__));\n long\n __Mod (long a, long b)\n {\n-  long\tresult;\n-\n-  result = __Umod (__builtin_labs (a), __builtin_labs (b));\n+  long sign = 1;\n+\n+  /* We need to handle a == -2147483648 as expected and must while\n+     doing that avoid producing a sequence like \"abs (a) < 0\" as GCC\n+     may optimize out the test.  That sequence may not be obvious as\n+     we call inline functions.  Testing for a being negative and\n+     handling (presumably much rarer than positive) enables us to get\n+     a bit of optimization for an (accumulated) reduction of the\n+     penalty of the 0x80000000 special-case.  */\n+  if (a < 0)\n+    {\n+      sign = -1;\n+      if ((a & 0x7fffffff) == 0)\n+\t/* We're at 0x80000000.  Tread carefully.  */\n+\ta += __builtin_labs (b);\n+      a = -a;\n+    }\n \n-  return (a < 0) ? -result : result;\n+  return sign * do_31div (a, __builtin_labs (b)).rem;\n }\n #endif /* L_modsi3 */\n-#endif /* L_umodsi3 || L_modsi3 */\n #endif /* L_udivsi3 || L_divsi3 || L_umodsi3 || L_modsi3 */\n \n /*"}]}