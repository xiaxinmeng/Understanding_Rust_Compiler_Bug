{"sha": "53fb4de37502c525b7afef2401350a0797fd2373", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTNmYjRkZTM3NTAyYzUyNWI3YWZlZjI0MDEzNTBhMDc5N2ZkMjM3Mw==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2004-08-15T02:24:41Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-08-15T02:24:41Z"}, "message": "c-common.c (shorten_compare, [...]): Replace calls to build with calls to buildN.\n\n\n\t* c-common.c (shorten_compare, pointer_int_sum,\n\tc_common_truthvalue_conversion, boolean_increment): Replace calls\n\tto build with calls to buildN.\n\t* c-decl.c (complete_array_type, grokdeclarator): Likewise.\n\t* c-gimplify.c (c_build_bind_expr, gimplify_c_loop,\n\tgimplify_switch_stmt): Likewise.\n\t* c-typeck.c (default_function_array_conversion,\n\tbuild_component_ref, build_array_ref, build_function_call,\n\tpointer_diff, build_unary_op, build_conditional_expr,\n\tbuild_compound_expr, build_modify_expr, c_finish_goto_label,\n\tc_finish_goto_ptr, c_finish_return, c_finish_loop,\n\tc_finish_bc_stmt, c_finish_stmt_expr, c_end_compound_stmt,\n\tbuild_binary_op): Likewise.\n\nFrom-SVN: r86018", "tree": {"sha": "ebacdfeed0851e1d26ae03ca28fdcefe93df6304", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ebacdfeed0851e1d26ae03ca28fdcefe93df6304"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/53fb4de37502c525b7afef2401350a0797fd2373", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53fb4de37502c525b7afef2401350a0797fd2373", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53fb4de37502c525b7afef2401350a0797fd2373", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53fb4de37502c525b7afef2401350a0797fd2373/comments", "author": null, "committer": null, "parents": [{"sha": "b9413dbc44b6afbb28f88d9ed2f9716528fce94c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9413dbc44b6afbb28f88d9ed2f9716528fce94c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9413dbc44b6afbb28f88d9ed2f9716528fce94c"}], "stats": {"total": 132, "additions": 76, "deletions": 56}, "files": [{"sha": "4419c3c458a2d7e1afdcff3756a519cebf9004ff", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53fb4de37502c525b7afef2401350a0797fd2373/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53fb4de37502c525b7afef2401350a0797fd2373/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=53fb4de37502c525b7afef2401350a0797fd2373", "patch": "@@ -1,3 +1,19 @@\n+2004-08-14  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* c-common.c (shorten_compare, pointer_int_sum,\n+\tc_common_truthvalue_conversion, boolean_increment): Replace calls\n+\tto build with calls to buildN.\n+\t* c-decl.c (complete_array_type, grokdeclarator): Likewise.\n+\t* c-gimplify.c (c_build_bind_expr, gimplify_c_loop,\n+\tgimplify_switch_stmt): Likewise.\n+\t* c-typeck.c (default_function_array_conversion,\n+\tbuild_component_ref, build_array_ref, build_function_call,\n+\tpointer_diff, build_unary_op, build_conditional_expr,\n+\tbuild_compound_expr, build_modify_expr, c_finish_goto_label,\n+\tc_finish_goto_ptr, c_finish_return, c_finish_loop,\n+\tc_finish_bc_stmt, c_finish_stmt_expr, c_end_compound_stmt,\n+\tbuild_binary_op): Likewise.\n+\n 2004-08-15  Steven Bosscher  <stevenb@suse.de>\n \n \t* rtl.c (note_insn_name): Add NOTE_DISABLE_SCHED_OF_BLOCK."}, {"sha": "b4c914b4650b712af19557905d4a2692583a9cce", "filename": "gcc/c-common.c", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53fb4de37502c525b7afef2401350a0797fd2373/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53fb4de37502c525b7afef2401350a0797fd2373/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=53fb4de37502c525b7afef2401350a0797fd2373", "patch": "@@ -2114,7 +2114,7 @@ shorten_compare (tree *op0_ptr, tree *op1_ptr, tree *restype_ptr,\n \t{\n \t  /* Don't forget to evaluate PRIMOP0 if it has side effects.  */\n \t  if (TREE_SIDE_EFFECTS (primop0))\n-\t    return build (COMPOUND_EXPR, TREE_TYPE (val), primop0, val);\n+\t    return build2 (COMPOUND_EXPR, TREE_TYPE (val), primop0, val);\n \t  return val;\n \t}\n \n@@ -2198,8 +2198,8 @@ shorten_compare (tree *op0_ptr, tree *op1_ptr, tree *restype_ptr,\n \t    {\n \t      /* Don't forget to evaluate PRIMOP0 if it has side effects.  */\n \t      if (TREE_SIDE_EFFECTS (primop0))\n-\t\treturn build (COMPOUND_EXPR, TREE_TYPE (value),\n-\t\t\t      primop0, value);\n+\t\treturn build2 (COMPOUND_EXPR, TREE_TYPE (value),\n+\t\t\t       primop0, value);\n \t      return value;\n \t    }\n \t}\n@@ -2294,7 +2294,7 @@ pointer_int_sum (enum tree_code resultcode, tree ptrop, tree intop)\n \t\t\t\t    convert (TREE_TYPE (intop), size_exp), 1));\n \n   /* Create the sum or difference.  */\n-  return fold (build (resultcode, result_type, ptrop, intop));\n+  return fold (build2 (resultcode, result_type, ptrop, intop));\n }\n \f\n /* Prepare expr to be an argument of a TRUTH_NOT_EXPR,\n@@ -2360,8 +2360,8 @@ c_common_truthvalue_conversion (tree expr)\n \t  break;\n \n \tif (TREE_SIDE_EFFECTS (TREE_OPERAND (expr, 0)))\n-\t  return build (COMPOUND_EXPR, truthvalue_type_node,\n-\t\t\tTREE_OPERAND (expr, 0), truthvalue_true_node);\n+\t  return build2 (COMPOUND_EXPR, truthvalue_type_node,\n+\t\t\t TREE_OPERAND (expr, 0), truthvalue_true_node);\n \telse\n \t  return truthvalue_true_node;\n       }\n@@ -2384,14 +2384,16 @@ c_common_truthvalue_conversion (tree expr)\n       /* These don't change whether an object is zero or nonzero, but\n \t we can't ignore them if their second arg has side-effects.  */\n       if (TREE_SIDE_EFFECTS (TREE_OPERAND (expr, 1)))\n-\treturn build (COMPOUND_EXPR, truthvalue_type_node, TREE_OPERAND (expr, 1),\n-\t\t      lang_hooks.truthvalue_conversion (TREE_OPERAND (expr, 0)));\n+\treturn build2 (COMPOUND_EXPR, truthvalue_type_node,\n+\t\t       TREE_OPERAND (expr, 1),\n+\t\t       lang_hooks.truthvalue_conversion (TREE_OPERAND (expr, 0)));\n       else\n \treturn lang_hooks.truthvalue_conversion (TREE_OPERAND (expr, 0));\n \n     case COND_EXPR:\n       /* Distribute the conversion into the arms of a COND_EXPR.  */\n-      return fold (build (COND_EXPR, truthvalue_type_node, TREE_OPERAND (expr, 0),\n+      return fold (build3 (COND_EXPR, truthvalue_type_node,\n+\t\tTREE_OPERAND (expr, 0),\n \t\tlang_hooks.truthvalue_conversion (TREE_OPERAND (expr, 1)),\n \t\tlang_hooks.truthvalue_conversion (TREE_OPERAND (expr, 2))));\n \n@@ -3855,22 +3857,24 @@ boolean_increment (enum tree_code code, tree arg)\n   switch (code)\n     {\n     case PREINCREMENT_EXPR:\n-      val = build (MODIFY_EXPR, TREE_TYPE (arg), arg, true_res);\n+      val = build2 (MODIFY_EXPR, TREE_TYPE (arg), arg, true_res);\n       break;\n     case POSTINCREMENT_EXPR:\n-      val = build (MODIFY_EXPR, TREE_TYPE (arg), arg, true_res);\n+      val = build2 (MODIFY_EXPR, TREE_TYPE (arg), arg, true_res);\n       arg = save_expr (arg);\n-      val = build (COMPOUND_EXPR, TREE_TYPE (arg), val, arg);\n-      val = build (COMPOUND_EXPR, TREE_TYPE (arg), arg, val);\n+      val = build2 (COMPOUND_EXPR, TREE_TYPE (arg), val, arg);\n+      val = build2 (COMPOUND_EXPR, TREE_TYPE (arg), arg, val);\n       break;\n     case PREDECREMENT_EXPR:\n-      val = build (MODIFY_EXPR, TREE_TYPE (arg), arg, invert_truthvalue (arg));\n+      val = build2 (MODIFY_EXPR, TREE_TYPE (arg), arg,\n+\t\t    invert_truthvalue (arg));\n       break;\n     case POSTDECREMENT_EXPR:\n-      val = build (MODIFY_EXPR, TREE_TYPE (arg), arg, invert_truthvalue (arg));\n+      val = build2 (MODIFY_EXPR, TREE_TYPE (arg), arg,\n+\t\t    invert_truthvalue (arg));\n       arg = save_expr (arg);\n-      val = build (COMPOUND_EXPR, TREE_TYPE (arg), val, arg);\n-      val = build (COMPOUND_EXPR, TREE_TYPE (arg), arg, val);\n+      val = build2 (COMPOUND_EXPR, TREE_TYPE (arg), val, arg);\n+      val = build2 (COMPOUND_EXPR, TREE_TYPE (arg), arg, val);\n       break;\n     default:\n       abort ();"}, {"sha": "696fec88f2c4bcda1af31bb0697440fba3a00374", "filename": "gcc/c-decl.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53fb4de37502c525b7afef2401350a0797fd2373/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53fb4de37502c525b7afef2401350a0797fd2373/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=53fb4de37502c525b7afef2401350a0797fd2373", "patch": "@@ -3072,7 +3072,7 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n \t\t  && STATEMENT_LIST_HAS_LABEL (cur_stmt_list))\n \t\t{\n \t\t  tree bind;\n-\t\t  bind = build (BIND_EXPR, void_type_node, NULL, NULL, NULL);\n+\t\t  bind = build3 (BIND_EXPR, void_type_node, NULL, NULL, NULL);\n \t\t  TREE_SIDE_EFFECTS (bind) = 1;\n \t\t  add_stmt (bind);\n \t\t  BIND_EXPR_BODY (bind) = push_stmt_list ();\n@@ -3281,8 +3281,8 @@ complete_array_type (tree type, tree initial_value, int do_default)\n \t      if (TREE_PURPOSE (elts))\n \t\tmaxindex = TREE_PURPOSE (elts);\n \t      else\n-\t\tmaxindex = fold (build (PLUS_EXPR, integer_type_node,\n-\t\t\t\t\tmaxindex, integer_one_node));\n+\t\tmaxindex = fold (build2 (PLUS_EXPR, integer_type_node,\n+\t\t\t\t\t maxindex, integer_one_node));\n \t    }\n \t}\n       else\n@@ -4103,9 +4103,9 @@ grokdeclarator (tree declarator, tree declspecs,\n \t\t     Do the calculation in index_type, so that if it is\n \t\t     a variable the computations will be done in the\n \t\t     proper mode.  */\n-\t          itype = fold (build (MINUS_EXPR, index_type,\n-\t\t\t\t       convert (index_type, size),\n-\t\t\t\t       convert (index_type, size_one_node)));\n+\t          itype = fold (build2 (MINUS_EXPR, index_type,\n+\t\t\t\t\tconvert (index_type, size),\n+\t\t\t\t\tconvert (index_type, size_one_node)));\n \n \t          /* If that overflowed, the array is too big.\n \t\t     ??? While a size of INT_MAX+1 technically shouldn't"}, {"sha": "404ea71f0fcd6c5bdf699daf2494844d28d195a2", "filename": "gcc/c-gimplify.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53fb4de37502c525b7afef2401350a0797fd2373/gcc%2Fc-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53fb4de37502c525b7afef2401350a0797fd2373/gcc%2Fc-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-gimplify.c?ref=53fb4de37502c525b7afef2401350a0797fd2373", "patch": "@@ -196,7 +196,7 @@ c_build_bind_expr (tree block, tree body)\n     body = build_empty_stmt ();\n   if (decls || block)\n     {\n-      bind = build (BIND_EXPR, void_type_node, decls, body, block);\n+      bind = build3 (BIND_EXPR, void_type_node, decls, body, block);\n       TREE_SIDE_EFFECTS (bind) = 1;\n     }\n   else\n@@ -365,7 +365,7 @@ gimplify_c_loop (tree cond, tree body, tree incr, bool cond_is_first)\n       if (cond)\n \t{\n \t  t = build_bc_goto (bc_break);\n-\t  exit = build (COND_EXPR, void_type_node, cond, exit, t);\n+\t  exit = build3 (COND_EXPR, void_type_node, cond, exit, t);\n \t  exit = fold (exit);\n \t  gimplify_stmt (&exit);\n \t}\n@@ -456,8 +456,8 @@ gimplify_switch_stmt (tree *stmt_p)\n   if (!body)\n     body = build_empty_stmt ();\n \n-  *stmt_p = build (SWITCH_EXPR, SWITCH_TYPE (stmt), SWITCH_COND (stmt),\n-\t\t   body, NULL_TREE);\n+  *stmt_p = build3 (SWITCH_EXPR, SWITCH_TYPE (stmt), SWITCH_COND (stmt),\n+\t\t    body, NULL_TREE);\n   SET_EXPR_LOCATION (*stmt_p, stmt_locus);\n   gimplify_stmt (stmt_p);\n "}, {"sha": "b8a15a00780baab72fcf6a94b53da030756bf3ad", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53fb4de37502c525b7afef2401350a0797fd2373/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53fb4de37502c525b7afef2401350a0797fd2373/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=53fb4de37502c525b7afef2401350a0797fd2373", "patch": "@@ -1217,8 +1217,8 @@ default_function_array_conversion (tree exp)\n       if (TREE_CODE (exp) == COMPOUND_EXPR)\n \t{\n \t  tree op1 = default_conversion (TREE_OPERAND (exp, 1));\n-\t  return build (COMPOUND_EXPR, TREE_TYPE (op1),\n-\t\t\tTREE_OPERAND (exp, 0), op1);\n+\t  return build2 (COMPOUND_EXPR, TREE_TYPE (op1),\n+\t\t\t TREE_OPERAND (exp, 0), op1);\n \t}\n \n       lvalue_array_p = !not_lvalue && lvalue_p (exp);\n@@ -1456,8 +1456,8 @@ build_component_ref (tree datum, tree component)\n     case COMPOUND_EXPR:\n       {\n \ttree value = build_component_ref (TREE_OPERAND (datum, 1), component);\n-\treturn build (COMPOUND_EXPR, TREE_TYPE (value),\n-\t\t      TREE_OPERAND (datum, 0), non_lvalue (value));\n+\treturn build2 (COMPOUND_EXPR, TREE_TYPE (value),\n+\t\t       TREE_OPERAND (datum, 0), non_lvalue (value));\n       }\n     default:\n       break;\n@@ -1495,8 +1495,8 @@ build_component_ref (tree datum, tree component)\n \t  if (TREE_TYPE (subdatum) == error_mark_node)\n \t    return error_mark_node;\n \n-\t  ref = build (COMPONENT_REF, TREE_TYPE (subdatum), datum, subdatum,\n-\t\t       NULL_TREE);\n+\t  ref = build3 (COMPONENT_REF, TREE_TYPE (subdatum), datum, subdatum,\n+\t\t\tNULL_TREE);\n \t  if (TREE_READONLY (datum) || TREE_READONLY (subdatum))\n \t    TREE_READONLY (ref) = 1;\n \t  if (TREE_THIS_VOLATILE (datum) || TREE_THIS_VOLATILE (subdatum))\n@@ -1649,7 +1649,7 @@ build_array_ref (tree array, tree index)\n \t}\n \n       type = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (array)));\n-      rval = build (ARRAY_REF, type, array, index, NULL_TREE, NULL_TREE);\n+      rval = build4 (ARRAY_REF, type, array, index, NULL_TREE, NULL_TREE);\n       /* Array ref is const/volatile if the array elements are\n          or if the array is.  */\n       TREE_READONLY (rval)\n@@ -1869,7 +1869,7 @@ build_function_call (tree function, tree params)\n \t  else\n \t    rhs = fold (build1 (NOP_EXPR, return_type, integer_zero_node));\n \n-\t  return build (COMPOUND_EXPR, return_type, trap, rhs);\n+\t  return build2 (COMPOUND_EXPR, return_type, trap, rhs);\n \t}\n     }\n \n@@ -1883,8 +1883,8 @@ build_function_call (tree function, tree params)\n \n   check_function_arguments (TYPE_ATTRIBUTES (fntype), coerced_params);\n \n-  result = build (CALL_EXPR, TREE_TYPE (fntype),\n-\t\t  function, coerced_params, NULL_TREE);\n+  result = build3 (CALL_EXPR, TREE_TYPE (fntype),\n+\t\t   function, coerced_params, NULL_TREE);\n   TREE_SIDE_EFFECTS (result) = 1;\n \n   if (require_constant_value)\n@@ -2246,7 +2246,7 @@ pointer_diff (tree op0, tree op1)\n   op1 = c_size_in_bytes (target_type);\n \n   /* Divide by the size, in easiest possible way.  */\n-  return fold (build (EXACT_DIV_EXPR, restype, op0, convert (restype, op1)));\n+  return fold (build2 (EXACT_DIV_EXPR, restype, op0, convert (restype, op1)));\n }\n \f\n /* Construct and perhaps optimize a tree representation\n@@ -2395,8 +2395,8 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n \t  arg = stabilize_reference (arg);\n \t  real = build_unary_op (REALPART_EXPR, arg, 1);\n \t  imag = build_unary_op (IMAGPART_EXPR, arg, 1);\n-\t  return build (COMPLEX_EXPR, TREE_TYPE (arg),\n-\t\t\tbuild_unary_op (code, real, 1), imag);\n+\t  return build2 (COMPLEX_EXPR, TREE_TYPE (arg),\n+\t\t\t build_unary_op (code, real, 1), imag);\n \t}\n \n       /* Report invalid types.  */\n@@ -2466,7 +2466,7 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n \tif (TREE_CODE (TREE_TYPE (arg)) == BOOLEAN_TYPE)\n \t  val = boolean_increment (code, arg);\n \telse\n-\t  val = build (code, TREE_TYPE (arg), arg, inc);\n+\t  val = build2 (code, TREE_TYPE (arg), arg, inc);\n \tTREE_SIDE_EFFECTS (val) = 1;\n \tval = convert (result_type, val);\n \tif (TREE_CODE (val) != code)\n@@ -2535,9 +2535,9 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n \t\treturn error_mark_node;\n \t      }\n \n-\t    addr = fold (build (PLUS_EXPR, argtype,\n-\t\t\t\tconvert (argtype, addr),\n-\t\t\t\tconvert (argtype, byte_position (field))));\n+\t    addr = fold (build2 (PLUS_EXPR, argtype,\n+\t\t\t\t convert (argtype, addr),\n+\t\t\t\t convert (argtype, byte_position (field))));\n \t  }\n \telse\n \t  addr = build1 (code, argtype, arg);\n@@ -2867,7 +2867,7 @@ build_conditional_expr (tree ifexp, tree op1, tree op2)\n   if (TREE_CODE (ifexp) == INTEGER_CST)\n     return non_lvalue (integer_zerop (ifexp) ? op2 : op1);\n \n-  return fold (build (COND_EXPR, result_type, ifexp, op1, op2));\n+  return fold (build3 (COND_EXPR, result_type, ifexp, op1, op2));\n }\n \f\n /* Return a compound expression that performs two expressions and\n@@ -2901,7 +2901,7 @@ build_compound_expr (tree expr1, tree expr2)\n   else if (warn_unused_value)\n     warn_if_unused_value (expr1, input_location);\n \n-  return build (COMPOUND_EXPR, TREE_TYPE (expr2), expr1, expr2);\n+  return build2 (COMPOUND_EXPR, TREE_TYPE (expr2), expr1, expr2);\n }\n \n /* Build an expression representing a cast to type TYPE of expression EXPR.  */\n@@ -3223,7 +3223,7 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n \n   /* Scan operands */\n \n-  result = build (MODIFY_EXPR, lhstype, lhs, newrhs);\n+  result = build2 (MODIFY_EXPR, lhstype, lhs, newrhs);\n   TREE_SIDE_EFFECTS (result) = 1;\n \n   /* If we got the LHS in a different type for storing in,\n@@ -6217,7 +6217,7 @@ c_finish_goto_label (tree label)\n     return NULL_TREE;\n \n   TREE_USED (decl) = 1;\n-  return add_stmt (build (GOTO_EXPR, void_type_node, decl));\n+  return add_stmt (build1 (GOTO_EXPR, void_type_node, decl));\n }\n \n /* Generate a computed goto statement to EXPR.  */\n@@ -6228,7 +6228,7 @@ c_finish_goto_ptr (tree expr)\n   if (pedantic)\n     pedwarn (\"ISO C forbids `goto *expr;'\");\n   expr = convert (ptr_type_node, expr);\n-  return add_stmt (build (GOTO_EXPR, void_type_node, expr));\n+  return add_stmt (build1 (GOTO_EXPR, void_type_node, expr));\n }\n \n /* Generate a C `return' statement.  RETVAL is the expression for what\n@@ -6319,7 +6319,7 @@ c_finish_return (tree retval)\n \t  break;\n \t}\n \n-      retval = build (MODIFY_EXPR, TREE_TYPE (res), res, t);\n+      retval = build2 (MODIFY_EXPR, TREE_TYPE (res), res, t);\n     }\n \n   return add_stmt (build_stmt (RETURN_EXPR, retval));\n@@ -6554,7 +6554,7 @@ c_finish_loop (location_t start_locus, tree cond, tree incr, tree body,\n             }\n  \n \t  t = build_and_jump (&blab);\n-          exit = build (COND_EXPR, void_type_node, cond, exit, t);\n+          exit = build3 (COND_EXPR, void_type_node, cond, exit, t);\n           exit = fold (exit);\n \t  if (cond_is_first)\n             SET_EXPR_LOCATION (exit, start_locus);\n@@ -6595,7 +6595,7 @@ c_finish_bc_stmt (tree *label_p, bool is_break)\n       return NULL_TREE;\n     }\n \n-  return add_stmt (build (GOTO_EXPR, void_type_node, label));\n+  return add_stmt (build1 (GOTO_EXPR, void_type_node, label));\n }\n \n /* A helper routine for c_process_expr_stmt and c_finish_stmt_expr.  */\n@@ -6760,10 +6760,10 @@ c_finish_stmt_expr (tree body)\n       && TREE_TYPE (val) == TREE_TYPE (TREE_OPERAND (val, 0)))\n     val = TREE_OPERAND (val, 0);\n \n-  *last_p = build (MODIFY_EXPR, void_type_node, tmp, val);\n+  *last_p = build2 (MODIFY_EXPR, void_type_node, tmp, val);\n   SET_EXPR_LOCUS (*last_p, EXPR_LOCUS (last));\n \n-  return build (TARGET_EXPR, type, tmp, body, NULL_TREE, NULL_TREE);\n+  return build4 (TARGET_EXPR, type, tmp, body, NULL_TREE, NULL_TREE);\n }\n \f\n /* Begin and end compound statements.  This is as simple as pushing\n@@ -6802,7 +6802,7 @@ c_end_compound_stmt (tree stmt, bool do_scope)\n       && STATEMENT_LIST_STMT_EXPR (cur_stmt_list)\n       && TREE_CODE (stmt) != BIND_EXPR)\n     {\n-      stmt = build (BIND_EXPR, void_type_node, NULL, stmt, NULL);\n+      stmt = build3 (BIND_EXPR, void_type_node, NULL, stmt, NULL);\n       TREE_SIDE_EFFECTS (stmt) = 1;\n     }\n \n@@ -7553,7 +7553,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n     build_type = result_type;\n \n   {\n-    tree result = build (resultcode, build_type, op0, op1);\n+    tree result = build2 (resultcode, build_type, op0, op1);\n \n     /* Treat expressions in initializers specially as they can't trap.  */\n     result = require_constant_value ? fold_initializer (result)"}]}