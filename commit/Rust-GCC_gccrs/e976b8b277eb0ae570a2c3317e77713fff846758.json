{"sha": "e976b8b277eb0ae570a2c3317e77713fff846758", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTk3NmI4YjI3N2ViMGFlNTcwYTJjMzMxN2U3NzcxM2ZmZjg0Njc1OA==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1997-04-23T20:04:25Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1997-04-23T20:04:25Z"}, "message": "Add setjmp/longjmp exception handling.\n\nFrom-SVN: r13968", "tree": {"sha": "ed1bd25525ef36f94c97fb911c74203e02095a25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ed1bd25525ef36f94c97fb911c74203e02095a25"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e976b8b277eb0ae570a2c3317e77713fff846758", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e976b8b277eb0ae570a2c3317e77713fff846758", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e976b8b277eb0ae570a2c3317e77713fff846758", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e976b8b277eb0ae570a2c3317e77713fff846758/comments", "author": null, "committer": null, "parents": [{"sha": "2284f91b110a72392473ec763f64c1e7ea12a1d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2284f91b110a72392473ec763f64c1e7ea12a1d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2284f91b110a72392473ec763f64c1e7ea12a1d0"}], "stats": {"total": 1241, "additions": 665, "deletions": 576}, "files": [{"sha": "9b741b316bf80fc57c8ac3c3ed2fe9458fd68368", "filename": "gcc/calls.c", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e976b8b277eb0ae570a2c3317e77713fff846758/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e976b8b277eb0ae570a2c3317e77713fff846758/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=e976b8b277eb0ae570a2c3317e77713fff846758", "patch": "@@ -590,7 +590,6 @@ expand_call (exp, target, ignore)\n   int old_pending_adj = 0;\n   int old_stack_arg_under_construction;\n   int old_inhibit_defer_pop = inhibit_defer_pop;\n-  tree old_cleanups = cleanups_this_call;\n   rtx call_fusage = 0;\n   register tree p;\n   register int i, j;\n@@ -720,17 +719,6 @@ expand_call (exp, target, ignore)\n       /* If inlining succeeded, return.  */\n       if ((HOST_WIDE_INT) temp != -1)\n \t{\n-\t  if (flag_short_temps)\n-\t    {\n-\t      /* Perform all cleanups needed for the arguments of this\n-\t\t call (i.e. destructors in C++).  It is ok if these\n-\t\t destructors clobber RETURN_VALUE_REG, because the\n-\t\t only time we care about this is when TARGET is that\n-\t\t register.  But in C++, we take care to never return\n-\t\t that register directly.  */\n-\t      expand_cleanups_to (old_cleanups);\n-\t    }\n-\n #ifdef ACCUMULATE_OUTGOING_ARGS\n \t  /* If the outgoing argument list must be preserved, push\n \t     the stack before executing the inlined function if it\n@@ -1979,8 +1967,9 @@ expand_call (exp, target, ignore)\n \n   /* If value type not void, return an rtx for the value.  */\n \n-  /* If there are cleanups to be called, don't use a hard reg as target.  */\n-  if (cleanups_this_call != old_cleanups\n+  /* If there are cleanups to be called, don't use a hard reg as target.\n+     We need to double check this and see if it matters anymore.  */\n+  if (any_pending_cleanups ()\n       && target && REG_P (target)\n       && REGNO (target) < FIRST_PSEUDO_REGISTER)\n     target = 0;\n@@ -2153,13 +2142,6 @@ expand_call (exp, target, ignore)\n     }\n #endif\n \n-  if (flag_short_temps)\n-    {\n-      /* Perform all cleanups needed for the arguments of this call\n-\t (i.e. destructors in C++).  */\n-      expand_cleanups_to (old_cleanups);\n-    }\n-\n   /* If size of args is variable or this was a constructor call for a stack\n      argument, restore saved stack-pointer value.  */\n "}, {"sha": "e939afa88c724c5576d47f129a5b6b0af94d21f5", "filename": "gcc/except.h", "status": "modified", "additions": 54, "deletions": 10, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e976b8b277eb0ae570a2c3317e77713fff846758/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e976b8b277eb0ae570a2c3317e77713fff846758/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=e976b8b277eb0ae570a2c3317e77713fff846758", "patch": "@@ -82,8 +82,35 @@ struct eh_queue {\n };\n \n \n+/* Start an exception handling region.  All instructions emitted after\n+   this point are considered to be part of the region until\n+   expand_eh_region_end () is invoked.  */\n+\n extern void expand_eh_region_start\t\tPROTO((void));\n \n+/* Start an exception handling region for the given cleanup action.\n+   All instructions emitted after this point are considered to be part\n+   of the region until expand_eh_region_end () is invoked.  CLEANUP is\n+   the cleanup action to perform.  The return value is true if the\n+   exception region was optimized away.  If that case,\n+   expand_eh_region_end does not need to be called for this cleanup,\n+   nor should it be.\n+\n+   This routine notices one particular common case in C++ code\n+   generation, and optimizes it so as to not need the exception\n+   region.  */\n+\n+extern int expand_eh_region_start_tree\t\tPROTO((tree));\n+\n+/* End an exception handling region.  The information about the region\n+   is found on the top of ehstack.\n+\n+   HANDLER is either the cleanup for the exception region, or if we're\n+   marking the end of a try block, HANDLER is integer_zero_node.\n+\n+   HANDLER will be transformed to rtl when expand_leftover_cleanups ()\n+   is invoked.  */\n+\n extern void expand_eh_region_end\t\tPROTO((tree));\n \n /* Push RLABEL or TLABEL onto LABELSTACK. Only one of RLABEL or TLABEL\n@@ -101,16 +128,6 @@ extern rtx pop_label_entry\t\t\tPROTO((struct label_node **labelstack));\n \n extern tree top_label_entry\t\t\tPROTO((struct label_node **labelstack));\n \n-/* The stack used to keep track of the exception region corresponding to\n-   the current instruction.  */\n-\n-extern struct eh_stack ehstack;\n-\n-/* A queue used to track closed exception regions whose handlers have\n-   not been emitted yet.  */\n-\n-extern struct eh_queue ehqueue;\n-\n /* A set of insns for the catch clauses in the current function. They\n    will be emitted at the end of the current function.  */\n \n@@ -233,3 +250,30 @@ extern rtx eh_saved_pc_rtx;\n    unnecessary exception regions. Invoked from jump_optimize ().  */\n \n extern void exception_optimize\t\t\tPROTO((void));\n+\n+/* Get the dynamic handler chain.  */\n+extern rtx get_dynamic_handler_chain\t\tPROTO((void));\n+\n+/* Get the dynamic cleanup chain.  */\n+extern rtx get_dynamic_cleanup_chain\t\tPROTO((void));\n+\n+/* Throw an exception.  */\n+\n+extern void emit_throw\t\t\t\tPROTO((void));\n+\n+/* One to use setjmp/longjmp method of generating code.  */\n+\n+extern int exceptions_via_longjmp;\n+\n+/* One to enable asynchronous exception support.  */\n+\n+extern int asynchronous_exceptions;\n+\n+/* One to protect cleanup actions with a handler that calls\n+   __terminate, zero otherwise.  */\n+\n+extern int protect_cleanup_actions_with_terminate;\n+\n+#ifdef TREE_CODE\n+extern tree protect_with_terminate\t\tPROTO((tree));\n+#endif"}, {"sha": "b3babf6403f78899504c4c340e16537c6496ed88", "filename": "gcc/expr.c", "status": "modified", "additions": 64, "deletions": 471, "changes": 535, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e976b8b277eb0ae570a2c3317e77713fff846758/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e976b8b277eb0ae570a2c3317e77713fff846758/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=e976b8b277eb0ae570a2c3317e77713fff846758", "patch": "@@ -94,10 +94,6 @@ int pending_stack_adjust;\n    and in other cases as well.  */\n int inhibit_defer_pop;\n \n-/* A list of all cleanups which belong to the arguments of\n-   function calls being expanded by expand_call.  */\n-tree cleanups_this_call;\n-\n /* When temporaries are created by TARGET_EXPRs, they are created at\n    this level of temp_slot_level, so that they can remain allocated\n    until no longer needed.  CLEANUP_POINT_EXPRs define the lifetime\n@@ -211,7 +207,6 @@ static void do_jump_by_parts_equality_rtx PROTO((rtx, rtx, rtx));\n static void do_jump_for_compare\tPROTO((rtx, rtx, rtx));\n static rtx compare\t\tPROTO((tree, enum rtx_code, enum rtx_code));\n static rtx do_store_flag\tPROTO((tree, rtx, enum machine_mode, int));\n-static tree defer_cleanups_to\tPROTO((tree));\n extern tree truthvalue_conversion       PROTO((tree));\n \n /* Record for each mode whether we can move a register directly to or\n@@ -357,7 +352,6 @@ init_expr ()\n \n   pending_stack_adjust = 0;\n   inhibit_defer_pop = 0;\n-  cleanups_this_call = 0;\n   saveregs_value = 0;\n   apply_args_value = 0;\n   forced_labels = 0;\n@@ -375,14 +369,12 @@ save_expr_status (p)\n \n   p->pending_stack_adjust = pending_stack_adjust;\n   p->inhibit_defer_pop = inhibit_defer_pop;\n-  p->cleanups_this_call = cleanups_this_call;\n   p->saveregs_value = saveregs_value;\n   p->apply_args_value = apply_args_value;\n   p->forced_labels = forced_labels;\n \n   pending_stack_adjust = 0;\n   inhibit_defer_pop = 0;\n-  cleanups_this_call = 0;\n   saveregs_value = 0;\n   apply_args_value = 0;\n   forced_labels = 0;\n@@ -397,7 +389,6 @@ restore_expr_status (p)\n {\n   pending_stack_adjust = p->pending_stack_adjust;\n   inhibit_defer_pop = p->inhibit_defer_pop;\n-  cleanups_this_call = p->cleanups_this_call;\n   saveregs_value = p->saveregs_value;\n   apply_args_value = p->apply_args_value;\n   forced_labels = p->forced_labels;\n@@ -3014,93 +3005,27 @@ store_expr (exp, target, want_value)\n \t For non-BLKmode, it is more efficient not to do this.  */\n \n       rtx lab1 = gen_label_rtx (), lab2 = gen_label_rtx ();\n-      rtx flag = NULL_RTX;\n-      tree left_cleanups = NULL_TREE;\n-      tree right_cleanups = NULL_TREE;\n-      tree old_cleanups = cleanups_this_call;\n-\n-      /* Used to save a pointer to the place to put the setting of\n-\t the flag that indicates if this side of the conditional was\n-\t taken.  We backpatch the code, if we find out later that we\n-\t have any conditional cleanups that need to be performed.  */\n-      rtx dest_right_flag = NULL_RTX;\n-      rtx dest_left_flag = NULL_RTX;\n \n       emit_queue ();\n       target = protect_from_queue (target, 1);\n \n       do_pending_stack_adjust ();\n       NO_DEFER_POP;\n       jumpifnot (TREE_OPERAND (exp, 0), lab1);\n+      start_cleanup_deferal ();\n       store_expr (TREE_OPERAND (exp, 1), target, 0);\n-      dest_left_flag = get_last_insn ();\n-      /* Handle conditional cleanups, if any.  */\n-      left_cleanups = defer_cleanups_to (old_cleanups);\n+      end_cleanup_deferal ();\n       emit_queue ();\n       emit_jump_insn (gen_jump (lab2));\n       emit_barrier ();\n       emit_label (lab1);\n+      start_cleanup_deferal ();\n       store_expr (TREE_OPERAND (exp, 2), target, 0);\n-      dest_right_flag = get_last_insn ();\n-      /* Handle conditional cleanups, if any.  */\n-      right_cleanups = defer_cleanups_to (old_cleanups);\n+      end_cleanup_deferal ();\n       emit_queue ();\n       emit_label (lab2);\n       OK_DEFER_POP;\n \n-      /* Add back in any conditional cleanups.  */\n-      if (left_cleanups || right_cleanups)\n-\t{\n-\t  tree new_cleanups;\n-\t  tree cond;\n-\t  rtx last;\n-\n-\t  /* Now that we know that a flag is needed, go back and add in the\n-\t     setting of the flag.  */\n-\n-\t  flag = gen_reg_rtx (word_mode);\n-\n-\t  /* Do the left side flag.  */\n-\t  last = get_last_insn ();\n-\t  /* Flag left cleanups as needed.  */\n-\t  emit_move_insn (flag, const1_rtx);\n-\t  /* ??? deprecated, use sequences instead.  */\n-\t  reorder_insns (NEXT_INSN (last), get_last_insn (), dest_left_flag);\n-\n-\t  /* Do the right side flag.  */\n-\t  last = get_last_insn ();\n-\t  /* Flag left cleanups as needed.  */\n-\t  emit_move_insn (flag, const0_rtx);\n-\t  /* ??? deprecated, use sequences instead.  */\n-\t  reorder_insns (NEXT_INSN (last), get_last_insn (), dest_right_flag);\n-\n-\t  /* All cleanups must be on the function_obstack.  */\n-\t  push_obstacks_nochange ();\n-\t  resume_temporary_allocation ();\n-\n-\t  /* convert flag, which is an rtx, into a tree.  */\n-\t  cond = make_node (RTL_EXPR);\n-\t  TREE_TYPE (cond) = integer_type_node;\n-\t  RTL_EXPR_RTL (cond) = flag;\n-\t  RTL_EXPR_SEQUENCE (cond) = NULL_RTX;\n-\t  cond = save_expr (cond);\n-\n-\t  if (! left_cleanups)\n-\t    left_cleanups = integer_zero_node;\n-\t  if (! right_cleanups)\n-\t    right_cleanups = integer_zero_node;\n-\t  new_cleanups = build (COND_EXPR, void_type_node,\n-\t\t\t\ttruthvalue_conversion (cond),\n-\t\t\t\tleft_cleanups, right_cleanups);\n-\t  new_cleanups = fold (new_cleanups);\n-\n-\t  pop_obstacks ();\n-\n-\t  /* Now add in the conditionalized cleanups.  */\n-\t  cleanups_this_call\n-\t    = tree_cons (NULL_TREE, new_cleanups, cleanups_this_call);\n-\t  expand_eh_region_start ();\n-\t}\n       return want_value ? target : NULL_RTX;\n     }\n   else if (want_value && GET_CODE (target) == MEM && ! MEM_VOLATILE_P (target)\n@@ -5187,7 +5112,7 @@ expand_expr (exp, target, tmode, modifier)\n \tint vars_need_expansion = 0;\n \n \t/* Need to open a binding contour here because\n-\t   if there are any cleanups they most be contained here.  */\n+\t   if there are any cleanups they must be contained here.  */\n \texpand_start_bindings (0);\n \n \t/* Mark the corresponding BLOCK for output in its proper place.  */\n@@ -5831,30 +5756,28 @@ expand_expr (exp, target, tmode, modifier)\n \t{\n \t  RTL_EXPR_RTL (exp)\n \t    = expand_expr (TREE_OPERAND (exp, 0), target, tmode, modifier);\n-\t  cleanups_this_call\n-\t    = tree_cons (NULL_TREE, TREE_OPERAND (exp, 2), cleanups_this_call);\n+\t  expand_decl_cleanup (NULL_TREE, TREE_OPERAND (exp, 2));\n+\n \t  /* That's it for this cleanup.  */\n \t  TREE_OPERAND (exp, 2) = 0;\n-\t  expand_eh_region_start ();\n \t}\n       return RTL_EXPR_RTL (exp);\n \n     case CLEANUP_POINT_EXPR:\n       {\n \textern int temp_slot_level;\n-\ttree old_cleanups = cleanups_this_call;\n-\tint old_temp_level = target_temp_slot_level;\n-\tpush_temp_slots ();\n+\t/* Start a new binding layer that will keep track of all cleanup\n+\t   actions to be performed.  */\n+\texpand_start_bindings (0);\n+\n \ttarget_temp_slot_level = temp_slot_level;\n+\n \top0 = expand_expr (TREE_OPERAND (exp, 0), target, tmode, modifier);\n \t/* If we're going to use this value, load it up now.  */\n \tif (! ignore)\n \t  op0 = force_not_mem (op0);\n-\texpand_cleanups_to (old_cleanups);\n \tpreserve_temp_slots (op0);\n-\tfree_temp_slots ();\n-\tpop_temp_slots ();\n-\ttarget_temp_slot_level = old_temp_level;\n+\texpand_end_bindings (NULL_TREE, 0, 0);\n       }\n       return op0;\n \n@@ -6556,17 +6479,6 @@ expand_expr (exp, target, tmode, modifier)\n \t}\n \n       {\n-\trtx flag = NULL_RTX;\n-\ttree left_cleanups = NULL_TREE;\n-\ttree right_cleanups = NULL_TREE;\n-\n-\t/* Used to save a pointer to the place to put the setting of\n-\t   the flag that indicates if this side of the conditional was\n-\t   taken.  We backpatch the code, if we find out later that we\n-\t   have any conditional cleanups that need to be performed.  */\n-\trtx dest_right_flag = NULL_RTX;\n-\trtx dest_left_flag = NULL_RTX;\n-\n \t/* Note that COND_EXPRs whose type is a structure or union\n \t   are required to be constructed to contain assignments of\n \t   a temporary variable, so that we can evaluate them here\n@@ -6577,7 +6489,6 @@ expand_expr (exp, target, tmode, modifier)\n \n \ttree singleton = 0;\n \ttree binary_op = 0, unary_op = 0;\n-\ttree old_cleanups = cleanups_this_call;\n \n \t/* If this is (A ? 1 : 0) and A is a condition, just evaluate it and\n \t   convert it to our mode, if necessary.  */\n@@ -6705,7 +6616,6 @@ expand_expr (exp, target, tmode, modifier)\n \tNO_DEFER_POP;\n \top0 = gen_label_rtx ();\n \n-\tflag = gen_reg_rtx (word_mode);\n \tif (singleton && ! TREE_SIDE_EFFECTS (TREE_OPERAND (exp, 0)))\n \t  {\n \t    if (temp != 0)\n@@ -6724,14 +6634,12 @@ expand_expr (exp, target, tmode, modifier)\n \t    else\n \t      expand_expr (singleton,\n \t\t\t   ignore ? const0_rtx : NULL_RTX, VOIDmode, 0);\n-\t    dest_left_flag = get_last_insn ();\n \t    if (singleton == TREE_OPERAND (exp, 1))\n \t      jumpif (TREE_OPERAND (exp, 0), op0);\n \t    else\n \t      jumpifnot (TREE_OPERAND (exp, 0), op0);\n \n-\t    /* Allows cleanups up to here.  */\n-\t    old_cleanups = cleanups_this_call;\n+\t    start_cleanup_deferal ();\n \t    if (binary_op && temp == 0)\n \t      /* Just touch the other operand.  */\n \t      expand_expr (TREE_OPERAND (binary_op, 1),\n@@ -6746,43 +6654,7 @@ expand_expr (exp, target, tmode, modifier)\n \t\t\t\t  make_tree (type, temp)),\n \t\t\t  temp, 0);\n \t    op1 = op0;\n-\t    dest_right_flag = get_last_insn ();\n-\t  }\n-#if 0\n-\t/* This is now done in jump.c and is better done there because it\n-\t   produces shorter register lifetimes.  */\n-\t   \n-\t/* Check for both possibilities either constants or variables\n-\t   in registers (but not the same as the target!).  If so, can\n-\t   save branches by assigning one, branching, and assigning the\n-\t   other.  */\n-\telse if (temp && GET_MODE (temp) != BLKmode\n-\t\t && (TREE_CONSTANT (TREE_OPERAND (exp, 1))\n-\t\t     || ((TREE_CODE (TREE_OPERAND (exp, 1)) == PARM_DECL\n-\t\t\t  || TREE_CODE (TREE_OPERAND (exp, 1)) == VAR_DECL)\n-\t\t\t && DECL_RTL (TREE_OPERAND (exp, 1))\n-\t\t\t && GET_CODE (DECL_RTL (TREE_OPERAND (exp, 1))) == REG\n-\t\t\t && DECL_RTL (TREE_OPERAND (exp, 1)) != temp))\n-\t\t && (TREE_CONSTANT (TREE_OPERAND (exp, 2))\n-\t\t     || ((TREE_CODE (TREE_OPERAND (exp, 2)) == PARM_DECL\n-\t\t\t  || TREE_CODE (TREE_OPERAND (exp, 2)) == VAR_DECL)\n-\t\t\t && DECL_RTL (TREE_OPERAND (exp, 2))\n-\t\t\t && GET_CODE (DECL_RTL (TREE_OPERAND (exp, 2))) == REG\n-\t\t\t && DECL_RTL (TREE_OPERAND (exp, 2)) != temp)))\n-\t  {\n-\t    if (GET_CODE (temp) == REG && REGNO (temp) < FIRST_PSEUDO_REGISTER)\n-\t      temp = gen_reg_rtx (mode);\n-\t    store_expr (TREE_OPERAND (exp, 2), temp, 0);\n-\t    dest_left_flag = get_last_insn ();\n-\t    jumpifnot (TREE_OPERAND (exp, 0), op0);\n-\n-\t    /* Allows cleanups up to here.  */\n-\t    old_cleanups = cleanups_this_call;\n-\t    store_expr (TREE_OPERAND (exp, 1), temp, 0);\n-\t    op1 = op0;\n-\t    dest_right_flag = get_last_insn ();\n \t  }\n-#endif\n \t/* Check for A op 0 ? A : FOO and A op 0 ? FOO : A where OP is any\n \t   comparison operator.  If we have one of these cases, set the\n \t   output to A, branch on A (cse will merge these two references),\n@@ -6798,14 +6670,11 @@ expand_expr (exp, target, tmode, modifier)\n \t    if (GET_CODE (temp) == REG && REGNO (temp) < FIRST_PSEUDO_REGISTER)\n \t      temp = gen_reg_rtx (mode);\n \t    store_expr (TREE_OPERAND (exp, 1), temp, 0);\n-\t    dest_left_flag = get_last_insn ();\n \t    jumpif (TREE_OPERAND (exp, 0), op0);\n \n-\t    /* Allows cleanups up to here.  */\n-\t    old_cleanups = cleanups_this_call;\n+\t    start_cleanup_deferal ();\n \t    store_expr (TREE_OPERAND (exp, 2), temp, 0);\n \t    op1 = op0;\n-\t    dest_right_flag = get_last_insn ();\n \t  }\n \telse if (temp\n \t\t && TREE_CODE_CLASS (TREE_CODE (TREE_OPERAND (exp, 0))) == '<'\n@@ -6818,102 +6687,42 @@ expand_expr (exp, target, tmode, modifier)\n \t    if (GET_CODE (temp) == REG && REGNO (temp) < FIRST_PSEUDO_REGISTER)\n \t      temp = gen_reg_rtx (mode);\n \t    store_expr (TREE_OPERAND (exp, 2), temp, 0);\n-\t    dest_left_flag = get_last_insn ();\n \t    jumpifnot (TREE_OPERAND (exp, 0), op0);\n \n-\t    /* Allows cleanups up to here.  */\n-\t    old_cleanups = cleanups_this_call;\n+\t    start_cleanup_deferal ();\n \t    store_expr (TREE_OPERAND (exp, 1), temp, 0);\n \t    op1 = op0;\n-\t    dest_right_flag = get_last_insn ();\n \t  }\n \telse\n \t  {\n \t    op1 = gen_label_rtx ();\n \t    jumpifnot (TREE_OPERAND (exp, 0), op0);\n \n-\t    /* Allows cleanups up to here.  */\n-\t    old_cleanups = cleanups_this_call;\n+\t    start_cleanup_deferal ();\n \t    if (temp != 0)\n \t      store_expr (TREE_OPERAND (exp, 1), temp, 0);\n \t    else\n \t      expand_expr (TREE_OPERAND (exp, 1),\n \t\t\t   ignore ? const0_rtx : NULL_RTX, VOIDmode, 0);\n-\t    dest_left_flag = get_last_insn ();\n-\n-\t    /* Handle conditional cleanups, if any.  */\n-\t    left_cleanups = defer_cleanups_to (old_cleanups);\n-\n+\t    end_cleanup_deferal ();\n \t    emit_queue ();\n \t    emit_jump_insn (gen_jump (op1));\n \t    emit_barrier ();\n \t    emit_label (op0);\n+\t    start_cleanup_deferal ();\n \t    if (temp != 0)\n \t      store_expr (TREE_OPERAND (exp, 2), temp, 0);\n \t    else\n \t      expand_expr (TREE_OPERAND (exp, 2),\n \t\t\t   ignore ? const0_rtx : NULL_RTX, VOIDmode, 0);\n-\t    dest_right_flag = get_last_insn ();\n \t  }\n \n-\t/* Handle conditional cleanups, if any.  */\n-\tright_cleanups = defer_cleanups_to (old_cleanups);\n+\tend_cleanup_deferal ();\n \n \temit_queue ();\n \temit_label (op1);\n \tOK_DEFER_POP;\n \n-\t/* Add back in, any conditional cleanups.  */\n-\tif (left_cleanups || right_cleanups)\n-\t  {\n-\t    tree new_cleanups;\n-\t    tree cond;\n-\t    rtx last;\n-\n-\t    /* Now that we know that a flag is needed, go back and add in the\n-\t       setting of the flag.  */\n-\n-\t    /* Do the left side flag.  */\n-\t    last = get_last_insn ();\n-\t    /* Flag left cleanups as needed.  */\n-\t    emit_move_insn (flag, const1_rtx);\n-\t    /* ??? deprecated, use sequences instead.  */\n-\t    reorder_insns (NEXT_INSN (last), get_last_insn (), dest_left_flag);\n-\n-\t    /* Do the right side flag.  */\n-\t    last = get_last_insn ();\n-\t    /* Flag left cleanups as needed.  */\n-\t    emit_move_insn (flag, const0_rtx);\n-\t    /* ??? deprecated, use sequences instead.  */\n-\t    reorder_insns (NEXT_INSN (last), get_last_insn (), dest_right_flag);\n-\n-\t    /* All cleanups must be on the function_obstack.  */\n-\t    push_obstacks_nochange ();\n-\t    resume_temporary_allocation ();\n-\n-\t    /* convert flag, which is an rtx, into a tree.  */\n-\t    cond = make_node (RTL_EXPR);\n-\t    TREE_TYPE (cond) = integer_type_node;\n-\t    RTL_EXPR_RTL (cond) = flag;\n-\t    RTL_EXPR_SEQUENCE (cond) = NULL_RTX;\n-\t    cond = save_expr (cond);\n-\n-\t    if (! left_cleanups)\n-\t      left_cleanups = integer_zero_node;\n-\t    if (! right_cleanups)\n-\t      right_cleanups = integer_zero_node;\n-\t    new_cleanups = build (COND_EXPR, void_type_node,\n-\t\t\t\t  truthvalue_conversion (cond),\n-\t\t\t\t  left_cleanups, right_cleanups);\n-\t    new_cleanups = fold (new_cleanups);\n-\n-\t    pop_obstacks ();\n-\n-\t    /* Now add in the conditionalized cleanups.  */\n-\t    cleanups_this_call\n-\t      = tree_cons (NULL_TREE, new_cleanups, cleanups_this_call);\n-\t    expand_eh_region_start ();\n-\t  }\n \treturn temp;\n       }\n \n@@ -6996,13 +6805,7 @@ expand_expr (exp, target, tmode, modifier)\n \n \tstore_expr (exp1, target, 0);\n \n-\tif (cleanups)\n-\t  {\n-\t    cleanups_this_call = tree_cons (NULL_TREE,\n-\t\t\t\t\t    cleanups,\n-\t\t\t\t\t    cleanups_this_call);\n-\t    expand_eh_region_start ();\n-\t  }\n+\texpand_decl_cleanup (NULL_TREE, cleanups);\n \t\n \treturn target;\n       }\n@@ -7285,6 +7088,33 @@ expand_expr (exp, target, tmode, modifier)\n \treturn target;\n       }\n \n+    case TRY_CATCH_EXPR:\n+      {\n+\ttree handler = TREE_OPERAND (exp, 1);\n+\n+\texpand_eh_region_start ();\n+\n+\top0 = expand_expr (TREE_OPERAND (exp, 0), 0, VOIDmode, 0);\n+\n+\texpand_eh_region_end (handler);\n+\n+\treturn op0;\n+      }\n+\n+    case POPDCC_EXPR:\n+      {\n+\trtx dcc = get_dynamic_cleanup_chain ();\n+\temit_move_insn (dcc, validize_mem (gen_rtx (MEM, Pmode, dcc)));\n+\treturn const0_rtx;\n+      }\n+\n+    case POPDHC_EXPR:\n+      {\n+\trtx dhc = get_dynamic_handler_chain ();\n+\temit_move_insn (dhc, validize_mem (gen_rtx (MEM, Pmode, dhc)));\n+\treturn const0_rtx;\n+      }\n+\n     case ERROR_MARK:\n       op0 = CONST0_RTX (tmode);\n       if (op0 != 0)\n@@ -9925,68 +9755,6 @@ do_pending_stack_adjust ()\n       pending_stack_adjust = 0;\n     }\n }\n-\n-/* Defer the expansion all cleanups up to OLD_CLEANUPS.\n-   Returns the cleanups to be performed.  */\n-\n-static tree\n-defer_cleanups_to (old_cleanups)\n-     tree old_cleanups;\n-{\n-  tree new_cleanups = NULL_TREE;\n-  tree cleanups = cleanups_this_call;\n-  tree last = NULL_TREE;\n-\n-  while (cleanups_this_call != old_cleanups)\n-    {\n-      expand_eh_region_end (TREE_VALUE (cleanups_this_call));\n-      last = cleanups_this_call;\n-      cleanups_this_call = TREE_CHAIN (cleanups_this_call);\n-    }      \n-\n-  if (last)\n-    {\n-      /* Remove the list from the chain of cleanups.  */\n-      TREE_CHAIN (last) = NULL_TREE;\n-\n-      /* reverse them so that we can build them in the right order.  */\n-      cleanups = nreverse (cleanups);\n-\n-      /* All cleanups must be on the function_obstack.  */\n-      push_obstacks_nochange ();\n-      resume_temporary_allocation ();\n-\n-      while (cleanups)\n-\t{\n-\t  if (new_cleanups)\n-\t    new_cleanups = build (COMPOUND_EXPR, TREE_TYPE (new_cleanups),\n-\t\t\t\t  TREE_VALUE (cleanups), new_cleanups);\n-\t  else\n-\t    new_cleanups = TREE_VALUE (cleanups);\n-\n-\t  cleanups = TREE_CHAIN (cleanups);\n-\t}\n-\n-      pop_obstacks ();\n-    }\n-\n-  return new_cleanups;\n-}\n-\n-/* Expand all cleanups up to OLD_CLEANUPS.\n-   Needed here, and also for language-dependent calls.  */\n-\n-void\n-expand_cleanups_to (old_cleanups)\n-     tree old_cleanups;\n-{\n-  while (cleanups_this_call != old_cleanups)\n-    {\n-      expand_eh_region_end (TREE_VALUE (cleanups_this_call));\n-      expand_expr (TREE_VALUE (cleanups_this_call), const0_rtx, VOIDmode, 0);\n-      cleanups_this_call = TREE_CHAIN (cleanups_this_call);\n-    }\n-}\n \f\n /* Expand conditional expressions.  */\n \n@@ -10131,131 +9899,21 @@ do_jump (exp, if_false_label, if_true_label)\n       break;\n \n     case TRUTH_ANDIF_EXPR:\n-      {\n-\trtx seq1, seq2;\n-\ttree cleanups, old_cleanups;\n-\n-\tif (if_false_label == 0)\n-\t  if_false_label = drop_through_label = gen_label_rtx ();\n-\tstart_sequence ();\n-\tdo_jump (TREE_OPERAND (exp, 0), if_false_label, NULL_RTX);\n-\tseq1 = get_insns ();\n-\tend_sequence ();\n-\n-\told_cleanups = cleanups_this_call;\n-\tstart_sequence ();\n-\tdo_jump (TREE_OPERAND (exp, 1), if_false_label, if_true_label);\n-\tseq2 = get_insns ();\n-\tcleanups = defer_cleanups_to (old_cleanups);\n-\tend_sequence ();\n-\n-\tif (cleanups)\n-\t  {\n-\t    rtx flag = gen_reg_rtx (word_mode);\n-\t    tree new_cleanups;\n-\t    tree cond;\n-\n-\t    /* Flag cleanups as not needed.  */\n-\t    emit_move_insn (flag, const0_rtx);\n-\t    emit_insns (seq1);\n-\n-\t    /* Flag cleanups as needed.  */\n-\t    emit_move_insn (flag, const1_rtx);\n-\t    emit_insns (seq2);\n-\n-\t    /* All cleanups must be on the function_obstack.  */\n-\t    push_obstacks_nochange ();\n-\t    resume_temporary_allocation ();\n-\n-\t    /* convert flag, which is an rtx, into a tree.  */\n-\t    cond = make_node (RTL_EXPR);\n-\t    TREE_TYPE (cond) = integer_type_node;\n-\t    RTL_EXPR_RTL (cond) = flag;\n-\t    RTL_EXPR_SEQUENCE (cond) = NULL_RTX;\n-\t    cond = save_expr (cond);\n-\n-\t    new_cleanups = build (COND_EXPR, void_type_node,\n-\t\t\t\t  truthvalue_conversion (cond),\n-\t\t\t\t  cleanups, integer_zero_node);\n-\t    new_cleanups = fold (new_cleanups);\n-\n-\t    pop_obstacks ();\n-\n-\t    /* Now add in the conditionalized cleanups.  */\n-\t    cleanups_this_call\n-\t      = tree_cons (NULL_TREE, new_cleanups, cleanups_this_call);\n-\t    expand_eh_region_start ();\n-\t  }\n-\telse\n-\t  {\n-\t    emit_insns (seq1);\n-\t    emit_insns (seq2);\n-\t  }\n-      }\n+      if (if_false_label == 0)\n+\tif_false_label = drop_through_label = gen_label_rtx ();\n+      do_jump (TREE_OPERAND (exp, 0), if_false_label, NULL_RTX);\n+      start_cleanup_deferal ();\n+      do_jump (TREE_OPERAND (exp, 1), if_false_label, if_true_label);\n+      end_cleanup_deferal ();\n       break;\n \n     case TRUTH_ORIF_EXPR:\n-      {\n-\trtx seq1, seq2;\n-\ttree cleanups, old_cleanups;\n-\n-\tif (if_true_label == 0)\n-\t  if_true_label = drop_through_label = gen_label_rtx ();\n-\tstart_sequence ();\n-\tdo_jump (TREE_OPERAND (exp, 0), NULL_RTX, if_true_label);\n-\tseq1 = get_insns ();\n-\tend_sequence ();\n-\n-\told_cleanups = cleanups_this_call;\n-\tstart_sequence ();\n-\tdo_jump (TREE_OPERAND (exp, 1), if_false_label, if_true_label);\n-\tseq2 = get_insns ();\n-\tcleanups = defer_cleanups_to (old_cleanups);\n-\tend_sequence ();\n-\n-\tif (cleanups)\n-\t  {\n-\t    rtx flag = gen_reg_rtx (word_mode);\n-\t    tree new_cleanups;\n-\t    tree cond;\n-\n-\t    /* Flag cleanups as not needed.  */\n-\t    emit_move_insn (flag, const0_rtx);\n-\t    emit_insns (seq1);\n-\n-\t    /* Flag cleanups as needed.  */\n-\t    emit_move_insn (flag, const1_rtx);\n-\t    emit_insns (seq2);\n-\n-\t    /* All cleanups must be on the function_obstack.  */\n-\t    push_obstacks_nochange ();\n-\t    resume_temporary_allocation ();\n-\n-\t    /* convert flag, which is an rtx, into a tree.  */\n-\t    cond = make_node (RTL_EXPR);\n-\t    TREE_TYPE (cond) = integer_type_node;\n-\t    RTL_EXPR_RTL (cond) = flag;\n-\t    RTL_EXPR_SEQUENCE (cond) = NULL_RTX;\n-\t    cond = save_expr (cond);\n-\n-\t    new_cleanups = build (COND_EXPR, void_type_node,\n-\t\t\t\t  truthvalue_conversion (cond),\n-\t\t\t\t  cleanups, integer_zero_node);\n-\t    new_cleanups = fold (new_cleanups);\n-\n-\t    pop_obstacks ();\n-\n-\t    /* Now add in the conditionalized cleanups.  */\n-\t    cleanups_this_call\n-\t      = tree_cons (NULL_TREE, new_cleanups, cleanups_this_call);\n-\t    expand_eh_region_start ();\n-\t  }\n-\telse\n-\t  {\n-\t    emit_insns (seq1);\n-\t    emit_insns (seq2);\n-\t  }\n-      }\n+      if (if_true_label == 0)\n+\tif_true_label = drop_through_label = gen_label_rtx ();\n+      do_jump (TREE_OPERAND (exp, 0), NULL_RTX, if_true_label);\n+      start_cleanup_deferal ();\n+      do_jump (TREE_OPERAND (exp, 1), if_false_label, if_true_label);\n+      end_cleanup_deferal ();\n       break;\n \n     case COMPOUND_EXPR:\n@@ -10311,90 +9969,25 @@ do_jump (exp, if_false_label, if_true_label)\n \n       else\n \t{\n-\t  rtx seq1, seq2;\n-\t  tree cleanups_left_side, cleanups_right_side, old_cleanups;\n-\n \t  register rtx label1 = gen_label_rtx ();\n \t  drop_through_label = gen_label_rtx ();\n \n \t  do_jump (TREE_OPERAND (exp, 0), label1, NULL_RTX);\n \n-\t  /* We need to save the cleanups for the lhs and rhs separately. \n-\t     Keep track of the cleanups seen before the lhs. */\n-\t  old_cleanups = cleanups_this_call;\n-\t  start_sequence ();\n+\t  start_cleanup_deferal ();\n \t  /* Now the THEN-expression.  */\n \t  do_jump (TREE_OPERAND (exp, 1),\n \t\t   if_false_label ? if_false_label : drop_through_label,\n \t\t   if_true_label ? if_true_label : drop_through_label);\n \t  /* In case the do_jump just above never jumps.  */\n \t  do_pending_stack_adjust ();\n \t  emit_label (label1);\n-\t  seq1 = get_insns ();\n-\t  /* Now grab the cleanups for the lhs. */\n-\t  cleanups_left_side = defer_cleanups_to (old_cleanups);\n-\t  end_sequence ();\n \n-\t  /* And keep track of where we start before the rhs. */\n-\t  old_cleanups = cleanups_this_call;\n-\t  start_sequence ();\n \t  /* Now the ELSE-expression.  */\n \t  do_jump (TREE_OPERAND (exp, 2),\n \t\t   if_false_label ? if_false_label : drop_through_label,\n \t\t   if_true_label ? if_true_label : drop_through_label);\n-\t  seq2 = get_insns ();\n-\t  /* Grab the cleanups for the rhs. */\n-\t  cleanups_right_side = defer_cleanups_to (old_cleanups);\n-\t  end_sequence ();\n-\n-\t  if (cleanups_left_side || cleanups_right_side)\n-\t    {\n-\t      /* Make the cleanups for the THEN and ELSE clauses\n-\t\t conditional based on which half is executed. */\n-\t      rtx flag = gen_reg_rtx (word_mode);\n-\t      tree new_cleanups;\n-\t      tree cond;\n-\n-\t      /* Set the flag to 0 so that we know we executed the lhs. */\n-\t      emit_move_insn (flag, const0_rtx);\n-\t      emit_insns (seq1);\n-\n-\t      /* Set the flag to 1 so that we know we executed the rhs. */\n-\t      emit_move_insn (flag, const1_rtx);\n-\t      emit_insns (seq2);\n-\n-\t      /* Make sure the cleanup lives on the function_obstack. */\n-\t      push_obstacks_nochange ();\n-\t      resume_temporary_allocation ();\n-\n-\t      /* Now, build up a COND_EXPR that tests the value of the\n-\t\t flag, and then either do the cleanups for the lhs or the\n-\t\t rhs. */\n-\t      cond = make_node (RTL_EXPR);\n-\t      TREE_TYPE (cond) = integer_type_node;\n-\t      RTL_EXPR_RTL (cond) = flag;\n-\t      RTL_EXPR_SEQUENCE (cond) = NULL_RTX;\n-\t      cond = save_expr (cond);\n-\t      \n-\t      new_cleanups = build (COND_EXPR, void_type_node,\n-\t\t\t\t    truthvalue_conversion (cond),\n-\t\t\t\t    cleanups_right_side, cleanups_left_side);\n-\t      new_cleanups = fold (new_cleanups);\n-\n-\t      pop_obstacks ();\n-\n-\t      /* Now add in the conditionalized cleanups.  */\n-\t      cleanups_this_call\n-\t\t= tree_cons (NULL_TREE, new_cleanups, cleanups_this_call);\n-\t      expand_eh_region_start ();\n-\t    }\n-\t  else \n-\t    {\n-\t      /* No cleanups were needed, so emit the two sequences\n-\t\t directly. */\n-\t      emit_insns (seq1);\n-\t      emit_insns (seq2);\n-\t    }\n+\t  end_cleanup_deferal ();\n \t}\n       break;\n \n@@ -11336,7 +10929,7 @@ bc_load_memory (type, decl)\n     else\n       abort ();\n   else\n-    /* See corresponding comment in bc_store_memory().  */\n+    /* See corresponding comment in bc_store_memory.  */\n     if (TYPE_MODE (type) == BLKmode\n \t|| TYPE_MODE (type) == VOIDmode)\n       return;\n@@ -12012,7 +11605,7 @@ bc_load_bit_field (offset, size, unsignedp)\n \n   /* Load: sign-extend if signed, else zero-extend */\n   bc_emit_instruction (unsignedp ? zxloadBI : sxloadBI);\n-}  \n+}\n \n \n /* Adjust interpreter stack by NLEVELS.  Positive means drop NLEVELS"}, {"sha": "ee954ef43b7e4eb314d70cd18b3ee6e8ac0261ed", "filename": "gcc/expr.h", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e976b8b277eb0ae570a2c3317e77713fff846758/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e976b8b277eb0ae570a2c3317e77713fff846758/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=e976b8b277eb0ae570a2c3317e77713fff846758", "patch": "@@ -108,12 +108,6 @@ extern tree nonlocal_labels;\n    These are the arguments to function calls that have already returned.  */\n extern int pending_stack_adjust;\n \n-/* A list of all cleanups which belong to the arguments of\n-   function calls being expanded by expand_call.  */\n-#ifdef TREE_CODE   /* Don't lose if tree.h not included.  */\n-extern tree cleanups_this_call;\n-#endif\n-\n /* When temporaries are created by TARGET_EXPRs, they are created at\n    this level of temp_slot_level, so that they can remain allocated\n    until no longer needed.  CLEANUP_POINT_EXPRs define the lifetime\n@@ -359,6 +353,12 @@ extern rtx memset_libfunc;\n extern rtx bzero_libfunc;\n \n extern rtx throw_libfunc;\n+extern rtx sjthrow_libfunc;\n+extern rtx sjpopnthrow_libfunc;\n+extern rtx terminate_libfunc;\n+extern rtx setjmp_libfunc;\n+extern rtx longjmp_libfunc;\n+extern rtx get_dynamic_handler_chain_libfunc;\n \n extern rtx eqhf2_libfunc;\n extern rtx nehf2_libfunc;\n@@ -705,9 +705,6 @@ extern void clear_pending_stack_adjust PROTO((void));\n extern void do_pending_stack_adjust PROTO((void));\n \n #ifdef TREE_CODE\n-/* Expand all cleanups up to OLD_CLEANUPS.  */\n-extern void expand_cleanups_to PROTO((tree));\n-\n /* Generate code to evaluate EXP and jump to LABEL if the value is zero.  */\n extern void jumpifnot PROTO((tree, rtx));\n "}, {"sha": "ce4b96a8dd47e519022f36e924c1d0025b0aa928", "filename": "gcc/flags.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e976b8b277eb0ae570a2c3317e77713fff846758/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e976b8b277eb0ae570a2c3317e77713fff846758/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=e976b8b277eb0ae570a2c3317e77713fff846758", "patch": "@@ -308,10 +308,6 @@ extern int flag_schedule_insns_after_reload;\n \n extern int flag_delayed_branch;\n \n-/* Nonzero means to run cleanups after CALL_EXPRs. */\n-\n-extern int flag_short_temps;\n-\n /* Nonzero means pretend it is OK to examine bits of target floats,\n    even if that isn't true.  The resulting code will have incorrect constants,\n    but the same series of instructions that the native compiler would make.  */"}, {"sha": "63c26ac58163d07d5a6867305e6adb7e99b0acdf", "filename": "gcc/function.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e976b8b277eb0ae570a2c3317e77713fff846758/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e976b8b277eb0ae570a2c3317e77713fff846758/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=e976b8b277eb0ae570a2c3317e77713fff846758", "patch": "@@ -135,11 +135,12 @@ struct function\n   struct label_node *false_label_stack;\n   struct label_node *caught_return_label_stack;\n   tree protect_list;\n+  rtx dhc;\n+  rtx dcc;\n \n   /* For expr.c.  */\n   int pending_stack_adjust;\n   int inhibit_defer_pop;\n-  tree cleanups_this_call;\n   rtx saveregs_value;\n   rtx apply_args_value;\n   rtx forced_labels;"}, {"sha": "725161865dda57cb0a8d29c17fcba6feafe13320", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e976b8b277eb0ae570a2c3317e77713fff846758/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e976b8b277eb0ae570a2c3317e77713fff846758/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=e976b8b277eb0ae570a2c3317e77713fff846758", "patch": "@@ -3102,6 +3102,172 @@ EH_TABLE_LOOKUP\n \n #else\n \n+void\n+__default_terminate ()\n+{\n+  abort ();\n+}\n+\n+void (*__terminate_func)() = __default_terminate;\n+\n+void\n+__terminate ()\n+{\n+  (*__terminate_func)();\n+}\n+\n+/* Calls to __sjthrow are generated by the compiler when an exception\n+   is raised when using the setjmp/longjmp exception handling codegen\n+   method.  */\n+\n+extern longjmp (void *, int);\n+\n+extern void *__eh_type;\n+\n+static void *top_elt[2];\n+void **__dynamic_handler_chain = top_elt;\n+\n+/* Routine to get the head of the current thread's dynamic handler chain\n+   use for exception handling.\n+\n+   TODO: make thread safe.  */\n+\n+void ***\n+__get_dynamic_handler_chain ()\n+{\n+  return &__dynamic_handler_chain;\n+}\n+\n+/* This is used to throw an exception when the setjmp/longjmp codegen\n+   method is used for exception handling.\n+\n+   We call __terminate if there are no handlers left (we know this\n+   when the dynamic handler chain is top_elt).  Otherwise we run the\n+   cleanup actions off the dynamic cleanup stack, and pop the top of\n+   the dynamic handler chain, and use longjmp to transfer back to the\n+   associated handler.  */\n+\n+void\n+__sjthrow ()\n+{\n+  void ***dhc = __get_dynamic_handler_chain ();\n+  void *jmpbuf;\n+  void (*func)(void *, int);\n+  void *arg;\n+  void ***cleanup;\n+\n+  /* The cleanup chain is one word into the buffer.  Get the cleanup\n+     chain.  */\n+  cleanup = (void***)&(*dhc)[1];\n+\n+  /* If there are any cleanups in the chain, run them now.  */\n+  if (cleanup[0])\n+    {\n+      double store[200];\n+      void **buf = (void**)store;\n+      buf[1] = 0;\n+      buf[0] = (*dhc);\n+\n+      /* try { */\n+      if (! setjmp (&buf[2]))\n+\t{\n+\t  *dhc = buf;\n+\t  while (cleanup[0])\n+\t    {\n+\t      func = (void(*)(void*, int))cleanup[0][1];\n+\t      arg = (void*)cleanup[0][2];\n+\n+\t      /* Update this before running the cleanup.  */\n+\t      cleanup[0] = (void **)cleanup[0][0];\n+\n+\t      (*func)(arg, 2);\n+\t    }\n+\t  *dhc = buf[0];\n+\t}\n+      /* catch (...) */\n+      else\n+\t{\n+\t  __terminate ();\n+\t}\n+    }\n+  \n+  /* We must call terminate if we try and rethrow an exception, when\n+     there is no exception currently active and when there are no\n+     handlers left.  */\n+  if (! __eh_type || (*dhc) == top_elt)\n+    __terminate ();\n+    \n+  /* Find the jmpbuf associated with the top element of the dynamic\n+     handler chain.  The jumpbuf starts two words into the buffer.  */\n+  jmpbuf = &(*dhc)[2];\n+\n+  /* Then we pop the top element off the dynamic handler chain.  */\n+  *dhc = (void**)(*dhc)[0];\n+\n+  /* And then we jump to the handler.  */\n+\n+#ifdef USE_BUILTIN_SETJMP\n+  __builtin_longjmp (jmpbuf, 1);\n+#else\n+  longjmp (jmpbuf, 1);\n+#endif\n+}\n+\n+/* Run cleanups on the dynamic cleanup stack for the current dynamic\n+   handler, then pop the handler off the dynamic handler stack, and\n+   then throw.  This is used to skip the first handler, and transfer\n+   control to the next handler in the dynamic handler stack.  */\n+\n+void\n+__sjpopnthrow ()\n+{\n+  void ***dhc = __get_dynamic_handler_chain ();\n+  void *jmpbuf;\n+  void (*func)(void *, int);\n+  void *arg;\n+  void ***cleanup;\n+\n+  /* The cleanup chain is one word into the buffer.  Get the cleanup\n+     chain.  */\n+  cleanup = (void***)&(*dhc)[1];\n+\n+  /* If there are any cleanups in the chain, run them now.  */\n+  if (cleanup[0])\n+    {\n+      double store[200];\n+      void **buf = (void**)store;\n+      buf[1] = 0;\n+      buf[0] = (*dhc);\n+\n+      /* try { */\n+      if (! setjmp (&buf[2]))\n+\t{\n+\t  *dhc = buf;\n+\t  while (cleanup[0])\n+\t    {\n+\t      func = (void(*)(void*, int))cleanup[0][1];\n+\t      arg = (void*)cleanup[0][2];\n+\n+\t      /* Update this before running the cleanup.  */\n+\t      cleanup[0] = (void **)cleanup[0][0];\n+\n+\t      (*func)(arg, 2);\n+\t    }\n+\t  *dhc = buf[0];\n+\t}\n+      /* catch (...) */\n+      else\n+\t{\n+\t  __terminate ();\n+\t}\n+    }\n+\n+  /* Then we pop the top element off the dynamic handler chain.  */\n+  *dhc = (void**)(*dhc)[0];\n+\n+  __sjthrow ();\n+}\n+\n typedef struct {\n   void *start;\n   void *end;"}, {"sha": "04eaaff547582b7e8e0b1d75856e4abacb4b00c2", "filename": "gcc/stmt.c", "status": "modified", "additions": 339, "deletions": 55, "changes": 394, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e976b8b277eb0ae570a2c3317e77713fff846758/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e976b8b277eb0ae570a2c3317e77713fff846758/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=e976b8b277eb0ae570a2c3317e77713fff846758", "patch": "@@ -129,12 +129,10 @@ extern rtx arg_pointer_save_area;\n /* Chain of all RTL_EXPRs that have insns in them.  */\n extern tree rtl_expr_chain;\n \n-#if 0  /* Turned off because 0 seems to work just as well.  */\n-/* Cleanup lists are required for binding levels regardless of whether\n-   that binding level has cleanups or not.  This node serves as the\n-   cleanup list whenever an empty list is required.  */\n-static tree empty_cleanup_list;\n-#endif\n+/* Stack allocation level in which temporaries for TARGET_EXPRs live.  */\n+extern int target_temp_slot_level;\n+\n+extern int temp_slot_level;\n \f\n /* Functions and data structures for expanding case statements.  */\n \n@@ -262,7 +260,7 @@ struct nesting\n \t     as they were at the locus where this block appears.\n \t     There is an element for each containing block,\n \t     ordered innermost containing block first.\n-\t     The tail of this list can be 0 (was empty_cleanup_list),\n+\t     The tail of this list can be 0,\n \t     if all remaining elements would be empty lists.\n \t     The element's TREE_VALUE is the cleanup-list of that block,\n \t     which may be null.  */\n@@ -274,6 +272,28 @@ struct nesting\n \t  int function_call_count;\n \t  /* Bytecode specific: stack level to restore stack to on exit.  */\n \t  int bc_stack_level;\n+\t  /* Nonzero if this is associated with a EH region.  */\n+\t  int exception_region;\n+\t  /* The saved target_temp_slot_level from our outer block.\n+\t     We may reset target_temp_slot_level to be the level of\n+\t     this block, if that is done, target_temp_slot_level\n+\t     reverts to the saved target_temp_slot_level at the very\n+\t     end of the block.  */\n+\t  int target_temp_slot_level;\n+\t  /* True if we are currently emitting insns in an area of\n+\t     output code that is controlled by a conditional\n+\t     expression.  This is used by the cleanup handling code to\n+\t     generate conditional cleanup actions.  */\n+\t  int conditional_code;\n+\t  /* A place to move the start of the exception region for any\n+\t     of the conditional cleanups, must be at the end or after\n+\t     the start of the last unconditional cleanup, and before any\n+\t     conditional branch points.  */\n+\t  rtx last_unconditional_cleanup;\n+\t  /* When in a conditional context, this is the specific\n+\t     cleanup list associated with last_unconditional_cleanup,\n+\t     where we place the conditionalized cleanups.  */\n+\t  tree *cleanup_ptr;\n \t} block;\n       /* For switch (C) or case (Pascal) statements,\n \t and also for dummies (see `expand_start_case_dummy').  */\n@@ -391,7 +411,7 @@ struct goto_fixup\n   rtx stack_level;\n   /* List of lists of cleanup expressions to be run by this goto.\n      There is one element for each block that this goto is within.\n-     The tail of this list can be 0 (was empty_cleanup_list),\n+     The tail of this list can be 0,\n      if all remaining elements would be empty.\n      The TREE_VALUE contains the cleanup list of that block as of the\n      time this goto was seen.\n@@ -1021,11 +1041,7 @@ expand_fixup (tree_label, rtl_label, last_insn)\n       fixup->block_start_count = block_start_count;\n       fixup->stack_level = 0;\n       fixup->cleanup_list_list\n-\t= (((block->data.block.outer_cleanups\n-#if 0\n-\t     && block->data.block.outer_cleanups != empty_cleanup_list\n-#endif\n-\t     )\n+\t= ((block->data.block.outer_cleanups\n \t    || block->data.block.cleanups)\n \t   ? tree_cons (NULL_TREE, block->data.block.cleanups,\n \t\t\tblock->data.block.outer_cleanups)\n@@ -1301,7 +1317,7 @@ bc_fixup_gotos (thisblock, stack_level, cleanup_list, first_insn, dont_jump_in)\n       /* Emit code to restore the stack and continue */\n       bc_emit_bytecode_labeldef (f->label);\n \n-      /* Save stack_depth across call, since bc_adjust_stack () will alter\n+      /* Save stack_depth across call, since bc_adjust_stack will alter\n          the perceived stack depth via the instructions generated.  */\n \n       if (f->bc_stack_level >= 0)\n@@ -2918,10 +2934,7 @@ expand_return (retval)\n \tresult_reg_mode = tmpmode;\n       result_reg = gen_reg_rtx (result_reg_mode);\n \n-      /* Now that the value is in pseudos, copy it to the result reg(s).  */\n-      expand_cleanups_to (NULL_TREE);\n       emit_queue ();\n-      free_temp_slots ();\n       for (i = 0; i < n_regs; i++)\n \temit_move_insn (operand_subword (result_reg, i, 0, result_reg_mode),\n \t\t\tresult_pseudos[i]);\n@@ -2940,10 +2953,7 @@ expand_return (retval)\n       val = gen_reg_rtx (DECL_MODE (DECL_RESULT (current_function_decl)));\n       val = expand_expr (retval_rhs, val, GET_MODE (val), 0);\n       val = force_not_mem (val);\n-      expand_cleanups_to (NULL_TREE);\n       emit_queue ();\n-      /* All temporaries have now been used.  */\n-      free_temp_slots ();\n       /* Return the calculated value, doing cleanups first.  */\n       expand_value_return (val);\n     }\n@@ -2952,9 +2962,7 @@ expand_return (retval)\n       /* No cleanups or no hard reg used;\n \t calculate value into hard return reg.  */\n       expand_expr (retval, const0_rtx, VOIDmode, 0);\n-      expand_cleanups_to (NULL_TREE);\n       emit_queue ();\n-      free_temp_slots ();\n       expand_value_return (DECL_RTL (DECL_RESULT (current_function_decl)));\n     }\n }\n@@ -3061,22 +3069,13 @@ expand_start_bindings (exit_flag)\n   thisblock->data.block.stack_level = 0;\n   thisblock->data.block.cleanups = 0;\n   thisblock->data.block.function_call_count = 0;\n-#if 0\n-  if (block_stack)\n-    {\n-      if (block_stack->data.block.cleanups == NULL_TREE\n-\t  && (block_stack->data.block.outer_cleanups == NULL_TREE\n-\t      || block_stack->data.block.outer_cleanups == empty_cleanup_list))\n-\tthisblock->data.block.outer_cleanups = empty_cleanup_list;\n-      else\n-\tthisblock->data.block.outer_cleanups\n-\t  = tree_cons (NULL_TREE, block_stack->data.block.cleanups,\n-\t\t       block_stack->data.block.outer_cleanups);\n-    }\n-  else\n-    thisblock->data.block.outer_cleanups = 0;\n-#endif\n-#if 1\n+  thisblock->data.block.exception_region = 0;\n+  thisblock->data.block.target_temp_slot_level = target_temp_slot_level;\n+\n+  thisblock->data.block.conditional_code = 0;\n+  thisblock->data.block.last_unconditional_cleanup = note;\n+  thisblock->data.block.cleanup_ptr = &thisblock->data.block.cleanups;\n+\n   if (block_stack\n       && !(block_stack->data.block.cleanups == NULL_TREE\n \t   && block_stack->data.block.outer_cleanups == NULL_TREE))\n@@ -3085,7 +3084,6 @@ expand_start_bindings (exit_flag)\n \t\t   block_stack->data.block.outer_cleanups);\n   else\n     thisblock->data.block.outer_cleanups = 0;\n-#endif\n   thisblock->data.block.label_chain = 0;\n   thisblock->data.block.innermost_stack_block = stack_block_stack;\n   thisblock->data.block.first_insn = note;\n@@ -3101,6 +3099,91 @@ expand_start_bindings (exit_flag)\n     }\n }\n \n+/* Specify the scope of temporaries created by TARGET_EXPRs.  Similar\n+   to CLEANUP_POINT_EXPR, but handles cases when a series of calls to\n+   expand_expr are made.  After we end the region, we know that all\n+   space for all temporaries that were created by TARGET_EXPRs will be\n+   destroyed and their space freed for reuse.  */\n+\n+void\n+expand_start_target_temps ()\n+{\n+  /* This is so that even if the result is preserved, the space\n+     allocated will be freed, as we know that it is no longer in use.  */\n+  push_temp_slots ();\n+\n+  /* Start a new binding layer that will keep track of all cleanup\n+     actions to be performed.  */\n+  expand_start_bindings (0);\n+\n+  target_temp_slot_level = temp_slot_level;\n+}\n+\n+void\n+expand_end_target_temps ()\n+{\n+  expand_end_bindings (NULL_TREE, 0, 0);\n+  \n+  /* This is so that even if the result is preserved, the space\n+     allocated will be freed, as we know that it is no longer in use.  */\n+  pop_temp_slots ();\n+}\n+\n+/* Mark top block of block_stack as an implicit binding for an\n+   exception region.  This is used to prevent infinite recursion when\n+   ending a binding with expand_end_bindings.  It is only ever called\n+   by expand_eh_region_start, as that it the only way to create a\n+   block stack for a exception region.  */\n+\n+void\n+mark_block_as_eh_region ()\n+{\n+  block_stack->data.block.exception_region = 1;\n+  if (block_stack->next\n+      && block_stack->next->data.block.conditional_code)\n+    {\n+      block_stack->data.block.conditional_code\n+\t= block_stack->next->data.block.conditional_code;\n+      block_stack->data.block.last_unconditional_cleanup\n+\t= block_stack->next->data.block.last_unconditional_cleanup;\n+      block_stack->data.block.cleanup_ptr\n+\t= block_stack->next->data.block.cleanup_ptr;\n+    }\n+}\n+\n+/* True if we are currently emitting insns in an area of output code\n+   that is controlled by a conditional expression.  This is used by\n+   the cleanup handling code to generate conditional cleanup actions.  */\n+\n+int\n+conditional_context ()\n+{\n+  return block_stack && block_stack->data.block.conditional_code;\n+}\n+\n+/* Mark top block of block_stack as not for an implicit binding for an\n+   exception region.  This is only ever done by expand_eh_region_end\n+   to let expand_end_bindings know that it is being called explicitly\n+   to end the binding layer for just the binding layer associated with\n+   the exception region, otherwise expand_end_bindings would try and\n+   end all implicit binding layers for exceptions regions, and then\n+   one normal binding layer.  */\n+\n+void\n+mark_block_as_not_eh_region ()\n+{\n+  block_stack->data.block.exception_region = 0;\n+}\n+\n+/* True if the top block of block_stack was marked as for an exception\n+   region by mark_block_as_eh_region.  */\n+\n+int\n+is_eh_region ()\n+{\n+  return block_stack && block_stack->data.block.exception_region;\n+}\n+\n /* Given a pointer to a BLOCK node, save a pointer to the most recently\n    generated NOTE_INSN_BLOCK_END in the BLOCK_END_NOTE field of the given\n    BLOCK node.  */\n@@ -3128,15 +3211,34 @@ expand_end_bindings (vars, mark_ends, dont_jump_in)\n      int mark_ends;\n      int dont_jump_in;\n {\n-  register struct nesting *thisblock = block_stack;\n+  register struct nesting *thisblock;\n   register tree decl;\n \n+  while (block_stack->data.block.exception_region)\n+    {\n+      /* Because we don't need or want a new temporary level and\n+\t because we didn't create one in expand_eh_region_start,\n+\t create a fake one now to avoid removing one in\n+\t expand_end_bindings.  */\n+      push_temp_slots ();\n+\n+      block_stack->data.block.exception_region = 0;\n+\n+      expand_end_bindings (NULL_TREE, 0, 0);\n+    }\n+\n   if (output_bytecode)\n     {\n       bc_expand_end_bindings (vars, mark_ends, dont_jump_in);\n       return;\n     }\n \n+  /* Since expand_eh_region_start does an expand_start_bindings, we\n+     have to first end all the bindings that were created by\n+     expand_eh_region_start.  */\n+     \n+  thisblock = block_stack;\n+\n   if (warn_unused)\n     for (decl = vars; decl; decl = TREE_CHAIN (decl))\n       if (! TREE_USED (decl) && TREE_CODE (decl) == VAR_DECL\n@@ -3362,6 +3464,9 @@ expand_end_bindings (vars, mark_ends, dont_jump_in)\n \t  use_variable (rtl);\n       }\n \n+  /* Restore the temporary level of TARGET_EXPRs.  */\n+  target_temp_slot_level = thisblock->data.block.target_temp_slot_level;\n+\n   /* Restore block_stack level for containing block.  */\n \n   stack_block_stack = thisblock->data.block.innermost_stack_block;\n@@ -3614,7 +3719,7 @@ bc_expand_decl (decl, cleanup)\n   else if (DECL_SIZE (decl) == 0)\n \n     /* Variable with incomplete type.  The stack offset herein will be\n-       fixed later in expand_decl_init ().  */\n+       fixed later in expand_decl_init.  */\n     DECL_RTL (decl) = bc_gen_rtx ((char *) 0, 0, (struct bc_label *) 0);\n \n   else if (TREE_CONSTANT (DECL_SIZE (decl)))\n@@ -3765,7 +3870,8 @@ bc_expand_decl_init (decl)\n \n    We wrap CLEANUP in an UNSAVE_EXPR node, so that we can expand the\n    CLEANUP multiple times, and have the correct semantics.  This\n-   happens in exception handling, and for non-local gotos.\n+   happens in exception handling, for gotos, returns, breaks that\n+   leave the current scope.\n \n    If CLEANUP is nonzero and DECL is zero, we record a cleanup\n    that is not associated with any particular variable.   */\n@@ -3784,16 +3890,164 @@ expand_decl_cleanup (decl, cleanup)\n \n   if (cleanup != 0)\n     {\n+      tree t;\n+      rtx seq;\n+      tree *cleanups = &thisblock->data.block.cleanups;\n+      int cond_context = conditional_context ();\n+\n+      if (cond_context)\n+\t{\n+\t  rtx flag = gen_reg_rtx (word_mode);\n+\t  rtx set_flag_0;\n+\t  tree cond;\n+\n+\t  start_sequence ();\n+\t  emit_move_insn (flag, const0_rtx);\n+\t  set_flag_0 = get_insns ();\n+\t  end_sequence ();\n+\n+\t  thisblock->data.block.last_unconditional_cleanup\n+\t    = emit_insns_after (set_flag_0,\n+\t\t\t\tthisblock->data.block.last_unconditional_cleanup);\n+\n+\t  emit_move_insn (flag, const1_rtx);\n+\n+\t  /* All cleanups must be on the function_obstack.  */\n+\t  push_obstacks_nochange ();\n+\t  resume_temporary_allocation ();\n+\n+\t  cond = build_decl (VAR_DECL, NULL_TREE, type_for_mode (word_mode, 1));\n+\t  DECL_RTL (cond) = flag;\n+\n+\t  /* Conditionalize the cleanup.  */\n+\t  cleanup = build (COND_EXPR, void_type_node,\n+\t\t\t   truthvalue_conversion (cond),\n+\t\t\t   cleanup, integer_zero_node);\n+\t  cleanup = fold (cleanup);\n+\n+\t  pop_obstacks ();\n+\n+\t  cleanups = thisblock->data.block.cleanup_ptr;\n+\t}\n+\n+      /* All cleanups must be on the function_obstack.  */\n+      push_obstacks_nochange ();\n+      resume_temporary_allocation ();\n       cleanup = unsave_expr (cleanup);\n+      pop_obstacks ();\n+\n+      t = *cleanups = temp_tree_cons (decl, cleanup, *cleanups);\n+\n+      if (! cond_context)\n+\t/* If this block has a cleanup, it belongs in stack_block_stack.  */\n+\tstack_block_stack = thisblock;\n+\n+      if (cond_context)\n+\t{\n+\t  start_sequence ();\n+\t}\n \n-      thisblock->data.block.cleanups\n-\t= temp_tree_cons (decl, cleanup, thisblock->data.block.cleanups);\n-      /* If this block has a cleanup, it belongs in stack_block_stack.  */\n-      stack_block_stack = thisblock;\n-      expand_eh_region_start ();\n+      /* If this was optimized so that there is no exception region for the\n+\t cleanup, then mark the TREE_LIST node, so that we can later tell\n+\t if we need to call expand_eh_region_end.  */\n+      if (expand_eh_region_start_tree (cleanup))\n+\tTREE_ADDRESSABLE (t) = 1;\n+\n+      if (cond_context)\n+\t{\n+\t  seq = get_insns ();\n+\t  end_sequence ();\n+\t  thisblock->data.block.last_unconditional_cleanup\n+\t    = emit_insns_after (seq,\n+\t\t\t\tthisblock->data.block.last_unconditional_cleanup);\n+\t}\n+      else\n+\t{\n+\t  thisblock->data.block.last_unconditional_cleanup\n+\t    = get_last_insn ();\n+\t  thisblock->data.block.cleanup_ptr = &thisblock->data.block.cleanups;\n+\t}\n     }\n   return 1;\n }\n+\n+/* Arrange for the top element of the dynamic cleanup chain to be\n+   popped if we exit the current binding contour.  If the current\n+   contour is left via an exception, then __sjthrow will pop the top\n+   element off the dynamic cleanup chain.  The code that avoids doing\n+   the action we push into the cleanup chain in the exceptional case\n+   is contained in expand_cleanups.\n+\n+   This routine is only used by expand_eh_region_start, and that is\n+   the only way in which an exception region should be started.  This\n+   routine is only used when using the setjmp/longjmp codegen method\n+   for exception handling.  */\n+\n+int\n+expand_dcc_cleanup ()\n+{\n+  struct nesting *thisblock = block_stack;\n+  tree cleanup;\n+\n+  /* Error if we are not in any block.  */\n+  if (thisblock == 0)\n+    return 0;\n+\n+  /* Record the cleanup for the dynamic handler chain.  */\n+\n+  /* All cleanups must be on the function_obstack.  */\n+  push_obstacks_nochange ();\n+  resume_temporary_allocation ();\n+  cleanup = make_node (POPDCC_EXPR);\n+  pop_obstacks ();\n+\n+  /* Add the cleanup in a manner similar to expand_decl_cleanup.  */\n+  thisblock->data.block.cleanups\n+    = temp_tree_cons (NULL_TREE, cleanup, thisblock->data.block.cleanups);\n+\n+  /* If this block has a cleanup, it belongs in stack_block_stack.  */\n+  stack_block_stack = thisblock;\n+  return 1;\n+}\n+\n+/* Arrange for the top element of the dynamic handler chain to be\n+   popped if we exit the current binding contour.  If the current\n+   contour is left via an exception, then __sjthrow will pop the\n+   top element off the dynamic handler chain.  The code that avoids\n+   doing the action we push into the handler chain in the exceptional\n+   case is contained in expand_cleanups.\n+\n+   This routine is only used by expand_eh_region_start, and that is\n+   the only way in which an exception region should be started.  This\n+   routine is only used when using the setjmp/longjmp codegen method\n+   for exception handling.  */\n+\n+int\n+expand_dhc_cleanup ()\n+{\n+  struct nesting *thisblock = block_stack;\n+  tree cleanup;\n+\n+  /* Error if we are not in any block.  */\n+  if (thisblock == 0)\n+    return 0;\n+\n+  /* Record the cleanup for the dynamic handler chain.  */\n+\n+  /* All cleanups must be on the function_obstack.  */\n+  push_obstacks_nochange ();\n+  resume_temporary_allocation ();\n+  cleanup = make_node (POPDHC_EXPR);\n+  pop_obstacks ();\n+\n+  /* Add the cleanup in a manner similar to expand_decl_cleanup.  */\n+  thisblock->data.block.cleanups\n+    = temp_tree_cons (NULL_TREE, cleanup, thisblock->data.block.cleanups);\n+\n+  /* If this block has a cleanup, it belongs in stack_block_stack.  */\n+  stack_block_stack = thisblock;\n+  return 1;\n+}\n \f\n /* DECL is an anonymous union.  CLEANUP is a cleanup for DECL.\n    DECL_ELTS is the list of elements that belong to DECL's type.\n@@ -3891,7 +4145,19 @@ expand_cleanups (list, dont_do, in_fixup, reachable)\n \telse\n \t  {\n \t    if (! in_fixup)\n-\t      expand_eh_region_end (TREE_VALUE (tail));\n+\t      {\n+\t\ttree cleanup = TREE_VALUE (tail);\n+\n+\t\t/* See expand_d{h,c}c_cleanup for why we avoid this.  */\n+\t\tif (TREE_CODE (cleanup) != POPDHC_EXPR\n+\t\t    && TREE_CODE (cleanup) != POPDCC_EXPR\n+\t\t    /* See expand_eh_region_start_tree for this case.  */\n+\t\t    && ! TREE_ADDRESSABLE (tail))\n+\t\t  {\n+\t\t    cleanup = protect_with_terminate (cleanup);\n+\t\t    expand_eh_region_end (cleanup);\n+\t\t  }\n+\t      }\n \n \t    if (reachable)\n \t      {\n@@ -3910,6 +4176,29 @@ expand_cleanups (list, dont_do, in_fixup, reachable)\n       }\n }\n \n+/* Mark when the context we are emitting RTL for as a conditional\n+   context, so that any cleanup actions we register with\n+   expand_decl_init will be properly conditionalized when those\n+   cleanup actions are later performed.  Must be called before any\n+   expression (tree) is expanded that is within a contidional context.  */\n+\n+void\n+start_cleanup_deferal ()\n+{\n+  ++block_stack->data.block.conditional_code;\n+}\n+\n+/* Mark the end of a conditional region of code.  Because cleanup\n+   deferals may be nested, we may still be in a conditional region\n+   after we end the currently deferred cleanups, only after we end all\n+   deferred cleanups, are we back in unconditional code.  */\n+\n+void\n+end_cleanup_deferal ()\n+{\n+  --block_stack->data.block.conditional_code;\n+}\n+\n /* Move all cleanups from the current block_stack\n    to the containing block_stack, where they are assumed to\n    have been created.  If anything can cause a temporary to\n@@ -3953,11 +4242,7 @@ any_pending_cleanups (this_contour)\n   if (this_contour && block_stack->data.block.cleanups != NULL)\n     return 1;\n   if (block_stack->data.block.cleanups == 0\n-      && (block_stack->data.block.outer_cleanups == 0\n-#if 0\n-\t  || block_stack->data.block.outer_cleanups == empty_cleanup_list\n-#endif\n-\t  ))\n+      && block_stack->data.block.outer_cleanups == 0)\n     return 0;\n \n   for (block = block_stack->next; block; block = block->next)\n@@ -4101,7 +4386,7 @@ case_index_expr_type ()\n    If VALUE is a duplicate or overlaps, return 2 and do nothing\n    except store the (first) duplicate node in *DUPLICATE.\n    If VALUE is out of range, return 3 and do nothing.\n-   If we are jumping into the scope of a cleaup or var-sized array, return 5.\n+   If we are jumping into the scope of a cleanup or var-sized array, return 5.\n    Return 0 on success.\n \n    Extended to handle range statements.  */\n@@ -6186,4 +6471,3 @@ unroll_block_trees ()\n \n   reorder_blocks (block_vector, block, get_insns ());\n }\n-"}, {"sha": "855aaca571f1ceed4d3173989b2c550ec05ac776", "filename": "gcc/toplev.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e976b8b277eb0ae570a2c3317e77713fff846758/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e976b8b277eb0ae570a2c3317e77713fff846758/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=e976b8b277eb0ae570a2c3317e77713fff846758", "patch": "@@ -528,10 +528,6 @@ int flag_shared_data;\n \n int flag_delayed_branch;\n \n-/* Nonzero means to run cleanups after CALL_EXPRs.  */\n-\n-int flag_short_temps;\n-\n /* Nonzero if we are compiling pure (sharable) code.\n    Value is 1 if we are doing reasonable (i.e. simple\n    offset into offset table) pic.  Value is 2 if we can\n@@ -646,6 +642,8 @@ struct { char *string; int *variable; int on_value;} f_options[] =\n   {\"pic\", &flag_pic, 1},\n   {\"PIC\", &flag_pic, 2},\n   {\"exceptions\", &flag_exceptions, 1},\n+  {\"sjlj-exceptions\", &exceptions_via_longjmp, 1},\n+  {\"asynchronous-exceptions\", &asynchronous_exceptions, 1},\n   {\"profile-arcs\", &profile_arc_flag, 1},\n   {\"test-coverage\", &flag_test_coverage, 1},\n   {\"branch-probabilities\", &flag_branch_probabilities, 1},"}, {"sha": "e77adeb5c650cfe9d45a92af3160ecf41f57df00", "filename": "gcc/tree.def", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e976b8b277eb0ae570a2c3317e77713fff846758/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e976b8b277eb0ae570a2c3317e77713fff846758/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=e976b8b277eb0ae570a2c3317e77713fff846758", "patch": "@@ -458,7 +458,10 @@ DEFTREECODE (METHOD_CALL_EXPR, \"method_call_expr\", \"e\", 4)\n      manages to act on the proper value.\n    The cleanup is executed by the first enclosing CLEANUP_POINT_EXPR, if\n    it exists, otherwise it is the responsibility of the caller to manually\n-   call expand_cleanups_to, as needed.  */\n+   call expand_start_target_temps/expand_end_target_temps, as needed.\n+\n+   This differs from TRY_CATCH_EXPR in that operand 2 is always\n+   evaluated when an exception isn't throw when cleanups are run.  */\n DEFTREECODE (WITH_CLEANUP_EXPR, \"with_cleanup_expr\", \"e\", 3)\n \n /* Specify a cleanup point.\n@@ -689,6 +692,24 @@ DEFTREECODE (PREDECREMENT_EXPR, \"predecrement_expr\", \"e\", 2)\n DEFTREECODE (PREINCREMENT_EXPR, \"preincrement_expr\", \"e\", 2)\n DEFTREECODE (POSTDECREMENT_EXPR, \"postdecrement_expr\", \"e\", 2)\n DEFTREECODE (POSTINCREMENT_EXPR, \"postincrement_expr\", \"e\", 2)\n+\n+/* Evalute operand 1.  If and only if an exception is thrown during\n+   the evaluation of operand 1, evaluate operand 2.\n+\n+   This differs from WITH_CLEANUP_EXPR, in that operand 2 is never\n+   evaluated unless an exception is throw.  */\n+DEFTREECODE (TRY_CATCH_EXPR, \"try_catch_expr\", \"e\", 2)\n+\n+/* Pop the top element off the dynamic handler chain.  Used in\n+   conjunction with setjmp/longjmp based exception handling, see\n+   except.c for more details.  This is meant to be used only by the\n+   exception handling backend, expand_dhc_cleanup specifically.  */\n+DEFTREECODE (POPDHC_EXPR, \"popdhc_expr\", \"s\", 0)\n+\n+/* Pop the top element off the dynamic cleanup chain.  Used in\n+   conjunction with the exception handling.  This is meant to be used\n+   only by the exception handling backend.  */\n+DEFTREECODE (POPDCC_EXPR, \"popdcc_expr\", \"s\", 0)\n \f\n /* These types of expressions have no useful value,\n    and always have side effects.  */"}, {"sha": "e0ae9c91036e8b37fdc27a5ae35f74fd02bf3160", "filename": "gcc/tree.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e976b8b277eb0ae570a2c3317e77713fff846758/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e976b8b277eb0ae570a2c3317e77713fff846758/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=e976b8b277eb0ae570a2c3317e77713fff846758", "patch": "@@ -1690,7 +1690,14 @@ extern void expand_null_return\t\t\tPROTO((void));\n extern void expand_return\t\t\tPROTO((tree));\n extern void expand_start_bindings\t\tPROTO((int));\n extern void expand_end_bindings\t\t\tPROTO((tree, int, int));\n+extern void start_cleanup_deferal\t\tPROTO((void));\n+extern void end_cleanup_deferal\t\t\tPROTO((void));\n+extern void mark_block_as_eh_region\t\tPROTO((void));\n+extern void mark_block_as_not_eh_region\t\tPROTO((void));\n+extern int is_eh_region\t\t\t\tPROTO((void));\n+extern int conditional_context\t\t\tPROTO((void));\n extern tree last_cleanup_this_contour\t\tPROTO((void));\n+extern int expand_dhc_cleanup\t\t\tPROTO((void));\n extern void expand_start_case\t\t\tPROTO((int, tree, tree,\n \t\t\t\t\t\t       char *));\n extern void expand_end_case\t\t\tPROTO((tree));"}]}