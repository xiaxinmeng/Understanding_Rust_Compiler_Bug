{"sha": "058dcc25b74ed4d171182311a12d27272844ee16", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDU4ZGNjMjViNzRlZDRkMTcxMTgyMzExYTEyZDI3MjcyODQ0ZWUxNg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2007-06-12T17:47:37Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2007-06-12T17:47:37Z"}, "message": "re PR libstdc++/29286 (placement new does not change the dynamic type as it should)\n\n./:\tPR libstdc++/29286\n\t* tree.def: Add CHANGE_DYNAMIC_TYPE_EXPR.\n\t* tree.h (CHANGE_DYNAMIC_TYPE_NEW_TYPE): Define.\n\t(CHANGE_DYNAMIC_TYPE_LOCATION): Define.\n\t(DECL_NO_TBAA_P): Define.\n\t(struct tree_decl_common): Add no_tbaa_flag field.\n\t* tree-ssa-structalias.c (struct variable_info): Add\n\tno_tbaa_pruning field.\n\t(new_var_info): Initialize no_tbaa_pruning field.\n\t(unify_nodes): Copy no_tbaa_pruning field.\n\t(find_func_aliases): Handle CHANGE_DYNAMIC_TYPE_EXPR.\n\t(dump_solution_for_var): Print no_tbaa_pruning flag.\n\t(set_uids_in_ptset): Add no_tbaa_pruning parameter.  Change all\n\tcallers.\n\t(compute_tbaa_pruning): New static function.\n\t(compute_points_to_sets): Remove CHANGE_DYNAMIC_TYPE_EXPR nodes.\n\tCall compute_tbaa_pruning.\n\t* tree-ssa-alias.c (may_alias_p): Test no_tbaa_flag for pointers.\n\t* gimplify.c (gimplify_expr): Handle CHANGE_DYNAMIC_TYPE_EXPR.\n\t* gimple-low.c (lower_stmt): Likewise.\n\t* tree-gimple.c (is_gimple_stmt): Likewise.\n\t* tree-ssa-operands.c (get_expr_operands): Likewise.\n\t* tree-ssa-dce.c (mark_stmt_if_obviously_necessary): Likewise.\n\t* tree-inline.c (estimate_num_insns_1): Likewise.\n\t(copy_result_decl_to_var): Likewise.\n\t* expr.c (expand_expr_real_1): Likewise.\n\t* tree-pretty-print.c (dump_generic_node): Likewise.\n\t* tree-inline.c (copy_decl_to_var): Copy DECL_NO_TBAA_P flag.\n\t* omp-low.c (omp_copy_decl_2): Likewise.\n\t* print-tree.c (print_node): Print DECL_NO_TBAA_P flag.\n\t* doc/c-tree.texi (Expression trees): Document\n\tCHANGE_DYNAMIC_TYPE_EXPR.\ncp/:\n\tPR libstdc++/29286\n\t* init.c (avoid_placement_new_aliasing): New static function.\n\t(build_new_1): Call it.\ntestsuite/:\n\tPR libstdc++/29286\n\t* g++.dg/init/new16.C: New test.\n\t* g++.dg/init/new17.C: New test.\n\t* g++.dg/init/new18.C: New test.\n\t* g++.dg/init/new19.C: New test.\n\nCo-Authored-By: Daniel Berlin <dberlin@dberlin.org>\n\nFrom-SVN: r125653", "tree": {"sha": "10cbad9d2cb8a5b2d59d7944bd237eecb6610348", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/10cbad9d2cb8a5b2d59d7944bd237eecb6610348"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/058dcc25b74ed4d171182311a12d27272844ee16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/058dcc25b74ed4d171182311a12d27272844ee16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/058dcc25b74ed4d171182311a12d27272844ee16", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/058dcc25b74ed4d171182311a12d27272844ee16/comments", "author": null, "committer": null, "parents": [{"sha": "52a39a4c5db03b2e614f4bde1632e025348d1ebe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52a39a4c5db03b2e614f4bde1632e025348d1ebe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52a39a4c5db03b2e614f4bde1632e025348d1ebe"}], "stats": {"total": 699, "additions": 633, "deletions": 66}, "files": [{"sha": "d531d976f361a5dbac4f957e62a68135354b384f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058dcc25b74ed4d171182311a12d27272844ee16/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058dcc25b74ed4d171182311a12d27272844ee16/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=058dcc25b74ed4d171182311a12d27272844ee16", "patch": "@@ -1,3 +1,39 @@\n+2007-06-12  Ian Lance Taylor  <iant@google.com>\n+\t    Daniel Berlin  <dberlin@dberlin.org>\n+\n+\tPR libstdc++/29286\n+\t* tree.def: Add CHANGE_DYNAMIC_TYPE_EXPR.\n+\t* tree.h (CHANGE_DYNAMIC_TYPE_NEW_TYPE): Define.\n+\t(CHANGE_DYNAMIC_TYPE_LOCATION): Define.\n+\t(DECL_NO_TBAA_P): Define.\n+\t(struct tree_decl_common): Add no_tbaa_flag field.\n+\t* tree-ssa-structalias.c (struct variable_info): Add\n+\tno_tbaa_pruning field.\n+\t(new_var_info): Initialize no_tbaa_pruning field.\n+\t(unify_nodes): Copy no_tbaa_pruning field.\n+\t(find_func_aliases): Handle CHANGE_DYNAMIC_TYPE_EXPR.\n+\t(dump_solution_for_var): Print no_tbaa_pruning flag.\n+\t(set_uids_in_ptset): Add no_tbaa_pruning parameter.  Change all\n+\tcallers.\n+\t(compute_tbaa_pruning): New static function.\n+\t(compute_points_to_sets): Remove CHANGE_DYNAMIC_TYPE_EXPR nodes.\n+\tCall compute_tbaa_pruning.\n+\t* tree-ssa-alias.c (may_alias_p): Test no_tbaa_flag for pointers.\n+\t* gimplify.c (gimplify_expr): Handle CHANGE_DYNAMIC_TYPE_EXPR.\n+\t* gimple-low.c (lower_stmt): Likewise.\n+\t* tree-gimple.c (is_gimple_stmt): Likewise.\n+\t* tree-ssa-operands.c (get_expr_operands): Likewise.\n+\t* tree-ssa-dce.c (mark_stmt_if_obviously_necessary): Likewise.\n+\t* tree-inline.c (estimate_num_insns_1): Likewise.\n+\t(copy_result_decl_to_var): Likewise.\n+\t* expr.c (expand_expr_real_1): Likewise.\n+\t* tree-pretty-print.c (dump_generic_node): Likewise.\n+\t* tree-inline.c (copy_decl_to_var): Copy DECL_NO_TBAA_P flag.\n+\t* omp-low.c (omp_copy_decl_2): Likewise.\n+\t* print-tree.c (print_node): Print DECL_NO_TBAA_P flag.\n+\t* doc/c-tree.texi (Expression trees): Document\n+\tCHANGE_DYNAMIC_TYPE_EXPR.\n+\n 2007-06-12  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* fold-const.c (fold_binary): Guard (X-X) -> 0 transformation"}, {"sha": "f9ca0508ddc3404d816f9645a72169cc98ef7af7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058dcc25b74ed4d171182311a12d27272844ee16/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058dcc25b74ed4d171182311a12d27272844ee16/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=058dcc25b74ed4d171182311a12d27272844ee16", "patch": "@@ -1,3 +1,9 @@\n+2007-06-12  Ian Lance Taylor  <iant@google.com>\n+\n+\tPR libstdc++/29286\n+\t* init.c (avoid_placement_new_aliasing): New static function.\n+\t(build_new_1): Call it.\n+\n 2007-06-11  Rafael Avila de Espindola  <espindola@google.com>\n \n \t* cp-objcp-common.h (LANG_HOOKS_SIGNED_TYPE): Remove."}, {"sha": "aecbed967954c91808fbda9785bbad9f43c4977f", "filename": "gcc/cp/init.c", "status": "modified", "additions": 75, "deletions": 2, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058dcc25b74ed4d171182311a12d27272844ee16/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058dcc25b74ed4d171182311a12d27272844ee16/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=058dcc25b74ed4d171182311a12d27272844ee16", "patch": "@@ -1,6 +1,7 @@\n /* Handle initialization things in C++.\n    Copyright (C) 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n+   Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GCC.\n@@ -1564,6 +1565,55 @@ build_raw_new_expr (tree placement, tree type, tree nelts, tree init,\n   return new_expr;\n }\n \n+/* Make sure that there are no aliasing issues with T, a placement new\n+   expression applied to PLACEMENT, by recording the change in dynamic\n+   type.  If placement new is inlined, as it is with libstdc++, and if\n+   the type of the placement new differs from the type of the\n+   placement location itself, then alias analysis may think it is OK\n+   to interchange writes to the location from before the placement new\n+   and from after the placement new.  We have to prevent type-based\n+   alias analysis from applying.  PLACEMENT may be NULL, which means\n+   that we couldn't capture it in a temporary variable, in which case\n+   we use a memory clobber.  */\n+\n+static tree\n+avoid_placement_new_aliasing (tree t, tree placement)\n+{\n+  tree type_change;\n+\n+  if (processing_template_decl)\n+    return t;\n+\n+  /* If we are not using type based aliasing, we don't have to do\n+     anything.  */\n+  if (!flag_strict_aliasing)\n+    return t;\n+\n+  /* If we have a pointer and a location, record the change in dynamic\n+     type.  Otherwise we need a general memory clobber.  */\n+  if (TREE_CODE (TREE_TYPE (t)) == POINTER_TYPE\n+      && placement != NULL_TREE\n+      && TREE_CODE (TREE_TYPE (placement)) == POINTER_TYPE)\n+    type_change = build_stmt (CHANGE_DYNAMIC_TYPE_EXPR,\n+\t\t\t      TREE_TYPE (t),\n+\t\t\t      placement);\n+  else\n+    {\n+      /* Build a memory clobber.  */\n+      type_change = build_stmt (ASM_EXPR,\n+\t\t\t\tbuild_string (0, \"\"),\n+\t\t\t\tNULL_TREE,\n+\t\t\t\tNULL_TREE,\n+\t\t\t\ttree_cons (NULL_TREE,\n+\t\t\t\t\t   build_string (6, \"memory\"),\n+\t\t\t\t\t   NULL_TREE));\n+\n+      ASM_VOLATILE_P (type_change) = 1;\n+    }\n+\n+  return build2 (COMPOUND_EXPR, TREE_TYPE (t), type_change, t);\n+}\n+\n /* Generate code for a new-expression, including calling the \"operator\n    new\" function, initializing the object, and, if an exception occurs\n    during construction, cleaning up.  The arguments are as for\n@@ -1607,6 +1657,7 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n      beginning of the storage allocated for an array-new expression in\n      order to store the number of elements.  */\n   tree cookie_size = NULL_TREE;\n+  tree placement_var;\n   /* True if the function we are calling is a placement allocation\n      function.  */\n   bool placement_allocation_fn_p;\n@@ -1700,6 +1751,20 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n \n   alloc_fn = NULL_TREE;\n \n+  /* If PLACEMENT is a simple pointer type, then copy it into\n+     PLACEMENT_VAR.  */\n+  if (processing_template_decl\n+      || placement == NULL_TREE\n+      || TREE_CHAIN (placement) != NULL_TREE\n+      || TREE_CODE (TREE_TYPE (TREE_VALUE (placement))) != POINTER_TYPE)\n+    placement_var = NULL_TREE;\n+  else\n+    {\n+      placement_var = get_temp_regvar (TREE_TYPE (TREE_VALUE (placement)),\n+\t\t\t\t       TREE_VALUE (placement));\n+      placement = tree_cons (NULL_TREE, placement_var, NULL_TREE);\n+    }\n+\n   /* Allocate the object.  */\n   if (! placement && TYPE_FOR_JAVA (elt_type))\n     {\n@@ -1792,7 +1857,12 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n   /* In the simple case, we can stop now.  */\n   pointer_type = build_pointer_type (type);\n   if (!cookie_size && !is_initialized)\n-    return build_nop (pointer_type, alloc_call);\n+    {\n+      rval = build_nop (pointer_type, alloc_call);\n+      if (placement != NULL)\n+\trval = avoid_placement_new_aliasing (rval, placement_var);\n+      return rval;\n+    }\n \n   /* While we're working, use a pointer to the type we've actually\n      allocated. Store the result of the call in a variable so that we\n@@ -2052,6 +2122,9 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n   /* A new-expression is never an lvalue.  */\n   gcc_assert (!lvalue_p (rval));\n \n+  if (placement != NULL)\n+    rval = avoid_placement_new_aliasing (rval, placement_var);\n+\n   return rval;\n }\n "}, {"sha": "c61b871a6792482185b8f032d00ee16aa2a6039b", "filename": "gcc/doc/c-tree.texi", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058dcc25b74ed4d171182311a12d27272844ee16/gcc%2Fdoc%2Fc-tree.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058dcc25b74ed4d171182311a12d27272844ee16/gcc%2Fdoc%2Fc-tree.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fc-tree.texi?ref=058dcc25b74ed4d171182311a12d27272844ee16", "patch": "@@ -1965,6 +1965,7 @@ This macro returns the attributes on the type @var{type}.\n @tindex TARGET_EXPR\n @tindex AGGR_INIT_EXPR\n @tindex VA_ARG_EXPR\n+@tindex CHANGE_DYNAMIC_TYPE_EXPR\n @tindex OMP_PARALLEL\n @tindex OMP_FOR\n @tindex OMP_SECTIONS\n@@ -2655,6 +2656,13 @@ mechanism.  It represents expressions like @code{va_arg (ap, type)}.\n Its @code{TREE_TYPE} yields the tree representation for @code{type} and\n its sole argument yields the representation for @code{ap}.\n \n+@item CHANGE_DYNAMIC_TYPE_EXPR\n+Indicates the special aliasing required by C++ placement new.  It has\n+two operands: a type and a location.  It means that the dynamic type\n+of the location is changing to be the specified type.  The alias\n+analysis code takes this into account when doing type based alias\n+analysis.\n+\n @item OMP_PARALLEL\n \n Represents @code{#pragma omp parallel [clause1 ... clauseN]}. It"}, {"sha": "2a4629a71e03f7431efd71a4147511688f90317a", "filename": "gcc/expr.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058dcc25b74ed4d171182311a12d27272844ee16/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058dcc25b74ed4d171182311a12d27272844ee16/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=058dcc25b74ed4d171182311a12d27272844ee16", "patch": "@@ -8947,6 +8947,13 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       /* Lowered by gimplify.c.  */\n       gcc_unreachable ();\n \n+    case CHANGE_DYNAMIC_TYPE_EXPR:\n+      /* This is ignored at the RTL level.  The tree level set\n+\t DECL_POINTER_ALIAS_SET of any variable to be 0, which is\n+\t overkill for the RTL layer but is all that we can\n+\t represent.  */\n+      return const0_rtx;\n+\n     case EXC_PTR_EXPR:\n       return get_exception_pointer (cfun);\n "}, {"sha": "f7888e25482a7e519dbdccbf3aef80ff9756780a", "filename": "gcc/gimple-low.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058dcc25b74ed4d171182311a12d27272844ee16/gcc%2Fgimple-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058dcc25b74ed4d171182311a12d27272844ee16/gcc%2Fgimple-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.c?ref=058dcc25b74ed4d171182311a12d27272844ee16", "patch": "@@ -242,6 +242,7 @@ lower_stmt (tree_stmt_iterator *tsi, struct lower_data *data)\n     case GOTO_EXPR:\n     case LABEL_EXPR:\n     case SWITCH_EXPR:\n+    case CHANGE_DYNAMIC_TYPE_EXPR:\n     case OMP_FOR:\n     case OMP_SECTIONS:\n     case OMP_SECTION:"}, {"sha": "268bef184cfe548406fdefc4a77ad7a9904b5528", "filename": "gcc/gimplify.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058dcc25b74ed4d171182311a12d27272844ee16/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058dcc25b74ed4d171182311a12d27272844ee16/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=058dcc25b74ed4d171182311a12d27272844ee16", "patch": "@@ -5791,6 +5791,11 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \t  ret = GS_ALL_DONE;\n \t  break;\n \n+\tcase CHANGE_DYNAMIC_TYPE_EXPR:\n+\t  ret = gimplify_expr (&CHANGE_DYNAMIC_TYPE_LOCATION (*expr_p),\n+\t\t\t       pre_p, post_p, is_gimple_reg, fb_lvalue);\n+\t  break;\n+\n \tcase OBJ_TYPE_REF:\n \t  {\n \t    enum gimplify_status r0, r1;"}, {"sha": "5b1f3c4c3d8c1c2131a3415d643e51c391fb477e", "filename": "gcc/omp-low.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058dcc25b74ed4d171182311a12d27272844ee16/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058dcc25b74ed4d171182311a12d27272844ee16/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=058dcc25b74ed4d171182311a12d27272844ee16", "patch": "@@ -516,6 +516,7 @@ omp_copy_decl_2 (tree var, tree name, tree type, omp_context *ctx)\n \n   TREE_ADDRESSABLE (copy) = TREE_ADDRESSABLE (var);\n   DECL_GIMPLE_REG_P (copy) = DECL_GIMPLE_REG_P (var);\n+  DECL_NO_TBAA_P (copy) = DECL_NO_TBAA_P (var);\n   DECL_ARTIFICIAL (copy) = DECL_ARTIFICIAL (var);\n   DECL_IGNORED_P (copy) = DECL_IGNORED_P (var);\n   TREE_USED (copy) = 1;"}, {"sha": "7301f47a879be42e42ade606f74436db12f4949c", "filename": "gcc/print-tree.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058dcc25b74ed4d171182311a12d27272844ee16/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058dcc25b74ed4d171182311a12d27272844ee16/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=058dcc25b74ed4d171182311a12d27272844ee16", "patch": "@@ -401,7 +401,9 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n \t  if (DECL_VIRTUAL_P (node))\n \t    fputs (\" virtual\", file);\n \t  if (DECL_PRESERVE_P (node))\n-\t    fputs (\" preserve\", file);\t  \n+\t    fputs (\" preserve\", file);\n+\t  if (DECL_NO_TBAA_P (node))\n+\t    fputs (\" no-tbaa\", file);\n \t  if (DECL_LANG_FLAG_0 (node))\n \t    fputs (\" decl_0\", file);\n \t  if (DECL_LANG_FLAG_1 (node))"}, {"sha": "dff238910cd918a88e03da3e864498257d70d40f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058dcc25b74ed4d171182311a12d27272844ee16/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058dcc25b74ed4d171182311a12d27272844ee16/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=058dcc25b74ed4d171182311a12d27272844ee16", "patch": "@@ -1,3 +1,11 @@\n+2007-06-12  Ian Lance Taylor  <iant@google.com>\n+\n+\tPR libstdc++/29286\n+\t* g++.dg/init/new16.C: New test.\n+\t* g++.dg/init/new17.C: New test.\n+\t* g++.dg/init/new18.C: New test.\n+\t* g++.dg/init/new19.C: New test.\n+\n 2007-06-12  Olivier Hainque  <hainque@adacore.com>\n \n \t* gnat.dg/lhs_view_convert.adb: New test."}, {"sha": "c49f13f833f967ea0c3d59a72478d3ed616b3f86", "filename": "gcc/testsuite/g++.dg/init/new16.C", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058dcc25b74ed4d171182311a12d27272844ee16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058dcc25b74ed4d171182311a12d27272844ee16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew16.C?ref=058dcc25b74ed4d171182311a12d27272844ee16", "patch": "@@ -0,0 +1,38 @@\n+// { dg-do run }\n+// { dg-options \"-O2 -fstrict-aliasing\" }\n+\n+// Test that we don't let TBAA reorder an assignment across a\n+// placement new.\n+// See PR 29286.\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+inline void* operator new(size_t, void* __p) throw() { return __p; }\n+\n+void __attribute__((noinline)) bar() {}\n+\n+long __attribute__((noinline)) foo(double *p, int n)\n+{\n+  long *f;\n+  for (int i=0; i<n; ++i)\n+  {\n+    int *l = (int *)p;\n+    *l = 0;\n+    f = new (p) long;\n+    *f = -1;\n+  }\n+  bar ();\n+  return *f;\n+}\n+\n+extern \"C\" void abort(void);\n+int main()\n+{\n+  union {\n+    int i;\n+    long l;\n+  } u;\n+  if (foo((double *)&u, 1) != -1)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "58782ff5fbaf683557b8c5abc9e0d8cae6c3d906", "filename": "gcc/testsuite/g++.dg/init/new17.C", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058dcc25b74ed4d171182311a12d27272844ee16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058dcc25b74ed4d171182311a12d27272844ee16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew17.C?ref=058dcc25b74ed4d171182311a12d27272844ee16", "patch": "@@ -0,0 +1,37 @@\n+// { dg-do compile }\n+// { dg-options \"-O2 -fstrict-aliasing -fdump-tree-final_cleanup\" }\n+\n+// Test that placement new does not introduce an unnecessary memory\n+// barrier.\n+// See PR 29286.\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+inline void* operator new(size_t, void* __p) throw() { return __p; }\n+\n+template <class T, int D>\n+class Vector\n+{\n+public:\n+   Vector()\n+   {\n+     for (int i = 0; i < D; ++i)\n+        new (&x_m[i]) T();\n+   }\n+   T& operator[](int i) { return x_m[i]; }\n+\n+private:\n+   T x_m[D];\n+};\n+\n+void foo(Vector<float, 3> *m)\n+{\n+  Vector<float, 3> v;\n+  v[0] = 1.0;\n+  v[1] = 2.0;\n+  v[3] = 3.0;\n+  *m = v;\n+}\n+\n+// { dg-final { scan-tree-dump-times \"= 0\\.0\" 1 \"final_cleanup\" } }\n+// { dg-final { cleanup-tree-dump \"final_cleanup\" } }"}, {"sha": "45f6e7a095df452d8394c86bb60e85097776565d", "filename": "gcc/testsuite/g++.dg/init/new18.C", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058dcc25b74ed4d171182311a12d27272844ee16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew18.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058dcc25b74ed4d171182311a12d27272844ee16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew18.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew18.C?ref=058dcc25b74ed4d171182311a12d27272844ee16", "patch": "@@ -0,0 +1,45 @@\n+// { dg-do compile }\n+// { dg-options \"-O2 -fstrict-aliasing\" }\n+\n+// This caused an ICE during placement new.\n+\n+namespace Pooma {\n+   typedef int Context_t;\n+   namespace Arch {\n+   }\n+   inline Context_t context() {\n+  }\n+   inline int contexts() {\n+  }\n+ }\n+template<class DomT, class T, class NewDom1T> struct DomainTraitsScalar {\n+  };\n+template<class T> struct DomainTraits : public DomainTraitsScalar<T, T, T> {\n+  };\n+template<int Dim> class Grid;\n+template<class DT> class DomainBase {\n+  };\n+template<int Dim, class DT> class Domain : public DomainBase<DT> {\n+  };\n+#include <vector>\n+template<> class Grid<1> : public Domain<1, DomainTraits<Grid<1> > > {\n+  };\n+namespace Pooma {\n+ class PatchSizeSyncer {\n+    typedef Grid<1> Grid_t;\n+    PatchSizeSyncer(int contextKey, Grid_t &localGrid);\n+    int myContext_m;\n+    int numContexts_m;\n+    int localKey_m;\n+    Grid_t localGrid_m;\n+    typedef std::pair<int,Grid_t *> Elem_t;\n+    std::vector<Elem_t> gridList_m;\n+  };\n+ }\n+namespace Pooma {\n+ PatchSizeSyncer::PatchSizeSyncer(int contextKey, Grid_t &localGrid)   :\n+myContext_m(Pooma::context()),     numContexts_m(Pooma::contexts()),    \n+localKey_m(contextKey),     localGrid_m(localGrid) {\n+    if (myContext_m == 0) gridList_m.reserve(numContexts_m);\n+  }\n+ }"}, {"sha": "a139a35aa05ccffe0ce69e6987f64d760e56bf8d", "filename": "gcc/testsuite/g++.dg/init/new19.C", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058dcc25b74ed4d171182311a12d27272844ee16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew19.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058dcc25b74ed4d171182311a12d27272844ee16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew19.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew19.C?ref=058dcc25b74ed4d171182311a12d27272844ee16", "patch": "@@ -0,0 +1,73 @@\n+// { dg-do compile }\n+// { dg-options \"-O2 -fstrict-aliasing -fdump-tree-lim-details\" }\n+\n+// Make sure we hoist invariants out of the loop even in the presence\n+// of placement new.  This is similar to code in tramp3d.\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+inline void* operator new(size_t, void* __p) throw() { return __p; }\n+\n+template <class T, int D>\n+class Vector\n+{\n+public:\n+   Vector()\n+   {\n+     for (int i = 0; i < D; ++i)\n+        new (&x_m[i]) T();\n+   }\n+   T& operator[](int i) { return x_m[i]; }\n+\n+private:\n+   T x_m[D];\n+};\n+\n+struct sia\n+{\n+  int ai[3];\n+};\n+\n+struct s\n+{\n+  struct si\n+  {\n+    sia* p;\n+  } asi[3];\n+  float* pd;\n+};\n+\n+class c\n+{\n+  int foo(int, int, int);\n+  s sm;\n+};\n+\n+\n+extern void bar(Vector<float, 3>*, int);\n+int c::foo(int f1, int f2, int f3)\n+{\n+  float sum = 0;\n+  for (int i = 0; i < 3; ++i)\n+    {\n+      for (int j = 0; j < 3; ++j)\n+\t{\n+\t  Vector<float, 3> v;\n+\t  v[0] = 1.0;\n+\t  v[1] = 2.0;\n+\t  v[2] = 3.0;\n+\t  for (int k = 0; k < 3; ++k)\n+\t    {\n+\t      float f = (f1 * this->sm.asi[0].p->ai[0]\n+\t\t\t + f2 * this->sm.asi[1].p->ai[0]\n+\t\t\t + f3 * this->sm.asi[2].p->ai[0]);\n+\t      sum += f * v[k];\n+\t    }\n+\t  *this->sm.pd = sum;\n+\t}\n+    }\n+  return sum;\n+}\n+\n+// { dg-final { scan-tree-dump \"Moving statement\\\\n.*->ai\\\\\\[0\\\\\\];\\\\n.*out of loop\" \"lim\" } }\n+// { dg-final { cleanup-tree-dump \"lim\" } }"}, {"sha": "16caf0ad573b024656d1b3c3960aedbece9bbabd", "filename": "gcc/tree-gimple.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058dcc25b74ed4d171182311a12d27272844ee16/gcc%2Ftree-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058dcc25b74ed4d171182311a12d27272844ee16/gcc%2Ftree-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.c?ref=058dcc25b74ed4d171182311a12d27272844ee16", "patch": "@@ -1,5 +1,6 @@\n /* Functions to analyze and validate GIMPLE trees.\n-   Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007\n+   Free Software Foundation, Inc.\n    Contributed by Diego Novillo <dnovillo@redhat.com>\n    Rewritten by Jason Merrill <jason@redhat.com>\n \n@@ -222,6 +223,7 @@ is_gimple_stmt (tree t)\n     case TRY_FINALLY_EXPR:\n     case EH_FILTER_EXPR:\n     case CATCH_EXPR:\n+    case CHANGE_DYNAMIC_TYPE_EXPR:\n     case ASM_EXPR:\n     case RESX_EXPR:\n     case PHI_NODE:"}, {"sha": "11d400afe61c9470b12354a925c33537d5b63307", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058dcc25b74ed4d171182311a12d27272844ee16/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058dcc25b74ed4d171182311a12d27272844ee16/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=058dcc25b74ed4d171182311a12d27272844ee16", "patch": "@@ -2030,6 +2030,11 @@ estimate_num_insns_1 (tree *tp, int *walk_subtrees, void *data)\n       *walk_subtrees = 0;\n       return NULL;\n \n+      /* CHANGE_DYNAMIC_TYPE_EXPR explicitly expands to nothing.  */\n+    case CHANGE_DYNAMIC_TYPE_EXPR:\n+      *walk_subtrees = 0;\n+      return NULL;\n+\n     /* Try to estimate the cost of assignments.  We have three cases to\n        deal with:\n \t1) Simple assignments to registers;\n@@ -3217,6 +3222,7 @@ copy_decl_to_var (tree decl, copy_body_data *id)\n   TREE_READONLY (copy) = TREE_READONLY (decl);\n   TREE_THIS_VOLATILE (copy) = TREE_THIS_VOLATILE (decl);\n   DECL_GIMPLE_REG_P (copy) = DECL_GIMPLE_REG_P (decl);\n+  DECL_NO_TBAA_P (copy) = DECL_NO_TBAA_P (decl);\n \n   return copy_decl_for_dup_finish (id, decl, copy);\n }\n@@ -3243,6 +3249,7 @@ copy_result_decl_to_var (tree decl, copy_body_data *id)\n     {\n       TREE_ADDRESSABLE (copy) = TREE_ADDRESSABLE (decl);\n       DECL_GIMPLE_REG_P (copy) = DECL_GIMPLE_REG_P (decl);\n+      DECL_NO_TBAA_P (copy) = DECL_NO_TBAA_P (decl);\n     }\n \n   return copy_decl_for_dup_finish (id, decl, copy);"}, {"sha": "0c313f20e88bbf3a5dd073cd0d6e95f30c6dd303", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058dcc25b74ed4d171182311a12d27272844ee16/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058dcc25b74ed4d171182311a12d27272844ee16/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=058dcc25b74ed4d171182311a12d27272844ee16", "patch": "@@ -1496,6 +1496,17 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       is_expr = false;\n       break;\n \n+    case CHANGE_DYNAMIC_TYPE_EXPR:\n+      pp_string (buffer, \"<<<change_dynamic_type (\");\n+      dump_generic_node (buffer, CHANGE_DYNAMIC_TYPE_NEW_TYPE (node), spc + 2,\n+\t\t\t flags, false);\n+      pp_string (buffer, \") \");\n+      dump_generic_node (buffer, CHANGE_DYNAMIC_TYPE_LOCATION (node), spc + 2,\n+\t\t\t flags, false);\n+      pp_string (buffer, \")>>>\");\n+      is_expr = false;\n+      break;\n+\n     case LABEL_EXPR:\n       op0 = TREE_OPERAND (node, 0);\n       /* If this is for break or continue, don't bother printing it.  */"}, {"sha": "cf5dc2b45e7604a833efd97f6490af49d378c2bb", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 56, "deletions": 53, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058dcc25b74ed4d171182311a12d27272844ee16/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058dcc25b74ed4d171182311a12d27272844ee16/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=058dcc25b74ed4d171182311a12d27272844ee16", "patch": "@@ -1,5 +1,5 @@\n /* Alias analysis for trees.\n-   Copyright (C) 2004, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n    Contributed by Diego Novillo <dnovillo@redhat.com>\n \n This file is part of GCC.\n@@ -2720,69 +2720,72 @@ may_alias_p (tree ptr, HOST_WIDE_INT mem_alias_set,\n \n   gcc_assert (TREE_CODE (mem) == SYMBOL_MEMORY_TAG);\n \n-  alias_stats.tbaa_queries++;\n-\n-  /* If the alias sets don't conflict then MEM cannot alias VAR.  */\n-  if (!alias_sets_conflict_p (mem_alias_set, var_alias_set))\n+  if (!DECL_NO_TBAA_P (ptr))\n     {\n-      alias_stats.alias_noalias++;\n-      alias_stats.tbaa_resolved++;\n-      return false;\n-    }\n+      alias_stats.tbaa_queries++;\n \n-  /* If VAR is a record or union type, PTR cannot point into VAR\n-     unless there is some explicit address operation in the\n-     program that can reference a field of the type pointed-to by PTR.\n-     This also assumes that the types of both VAR and PTR are\n-     contained within the compilation unit, and that there is no fancy\n-     addressing arithmetic associated with any of the types\n-     involved.  */\n-  if (mem_alias_set != 0 && var_alias_set != 0)\n-    {\n-      tree ptr_type = TREE_TYPE (ptr);\n-      tree var_type = TREE_TYPE (var);\n-      \n-      /* The star count is -1 if the type at the end of the pointer_to \n-\t chain is not a record or union type. */ \n-      if ((!alias_set_only) && \n-\t  ipa_type_escape_star_count_of_interesting_type (var_type) >= 0)\n+      /* If the alias sets don't conflict then MEM cannot alias VAR.  */\n+      if (!alias_sets_conflict_p (mem_alias_set, var_alias_set))\n \t{\n-\t  int ptr_star_count = 0;\n-\t  \n-\t  /* ipa_type_escape_star_count_of_interesting_type is a\n-\t     little too restrictive for the pointer type, need to\n-\t     allow pointers to primitive types as long as those types\n-\t     cannot be pointers to everything.  */\n-\t  while (POINTER_TYPE_P (ptr_type))\n+\t  alias_stats.alias_noalias++;\n+\t  alias_stats.tbaa_resolved++;\n+\t  return false;\n+\t}\n+\n+      /* If VAR is a record or union type, PTR cannot point into VAR\n+\t unless there is some explicit address operation in the\n+\t program that can reference a field of the type pointed-to by\n+\t PTR.  This also assumes that the types of both VAR and PTR\n+\t are contained within the compilation unit, and that there is\n+\t no fancy addressing arithmetic associated with any of the\n+\t types involved.  */\n+      if (mem_alias_set != 0 && var_alias_set != 0)\n+\t{\n+\t  tree ptr_type = TREE_TYPE (ptr);\n+\t  tree var_type = TREE_TYPE (var);\n+      \n+\t  /* The star count is -1 if the type at the end of the\n+\t     pointer_to chain is not a record or union type. */ \n+\t  if ((!alias_set_only) && \n+\t      ipa_type_escape_star_count_of_interesting_type (var_type) >= 0)\n \t    {\n-\t      /* Strip the *s off.  */ \n-\t      ptr_type = TREE_TYPE (ptr_type);\n-\t      ptr_star_count++;\n-\t    }\n+\t      int ptr_star_count = 0;\n \t  \n-\t  /* There does not appear to be a better test to see if the \n-\t     pointer type was one of the pointer to everything \n-\t     types.  */\n-\t  if (ptr_star_count > 0)\n-\t    {\n-\t      alias_stats.structnoaddress_queries++;\n-\t      if (ipa_type_escape_field_does_not_clobber_p (var_type, \n-\t\t\t\t\t\t\t    TREE_TYPE (ptr))) \n+\t      /* ipa_type_escape_star_count_of_interesting_type is a\n+\t\t little too restrictive for the pointer type, need to\n+\t\t allow pointers to primitive types as long as those\n+\t\t types cannot be pointers to everything.  */\n+\t      while (POINTER_TYPE_P (ptr_type))\n+\t\t{\n+\t\t  /* Strip the *s off.  */ \n+\t\t  ptr_type = TREE_TYPE (ptr_type);\n+\t\t  ptr_star_count++;\n+\t\t}\n+\t  \n+\t      /* There does not appear to be a better test to see if\n+\t\t the pointer type was one of the pointer to everything\n+\t\t types.  */\n+\t      if (ptr_star_count > 0)\n \t\t{\n+\t\t  alias_stats.structnoaddress_queries++;\n+\t\t  if (ipa_type_escape_field_does_not_clobber_p (var_type, \n+\t\t\t\t\t\t\t\tTREE_TYPE (ptr)))\n+\t\t    {\n+\t\t      alias_stats.structnoaddress_resolved++;\n+\t\t      alias_stats.alias_noalias++;\n+\t\t      return false;\n+\t\t    }\n+\t\t}\n+\t      else if (ptr_star_count == 0)\n+\t\t{\n+\t\t  /* If PTR_TYPE was not really a pointer to type, it cannot \n+\t\t     alias.  */ \n+\t\t  alias_stats.structnoaddress_queries++;\n \t\t  alias_stats.structnoaddress_resolved++;\n \t\t  alias_stats.alias_noalias++;\n \t\t  return false;\n \t\t}\n \t    }\n-\t  else if (ptr_star_count == 0)\n-\t    {\n-\t      /* If PTR_TYPE was not really a pointer to type, it cannot \n-\t\t alias.  */ \n-\t      alias_stats.structnoaddress_queries++;\n-\t      alias_stats.structnoaddress_resolved++;\n-\t      alias_stats.alias_noalias++;\n-\t      return false;\n-\t    }\n \t}\n     }\n "}, {"sha": "d0335a0593f8d0aa189bc999694a53c8a5c442bf", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058dcc25b74ed4d171182311a12d27272844ee16/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058dcc25b74ed4d171182311a12d27272844ee16/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=058dcc25b74ed4d171182311a12d27272844ee16", "patch": "@@ -1,5 +1,6 @@\n /* Dead code elimination pass for the GNU compiler.\n-   Copyright (C) 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007\n+   Free Software Foundation, Inc.\n    Contributed by Ben Elliston <bje@redhat.com>\n    and Andrew MacLeod <amacleod@redhat.com>\n    Adapted to use control dependence by Steven Bosscher, SUSE Labs.\n@@ -286,6 +287,7 @@ mark_stmt_if_obviously_necessary (tree stmt, bool aggressive)\n     case ASM_EXPR:\n     case RESX_EXPR:\n     case RETURN_EXPR:\n+    case CHANGE_DYNAMIC_TYPE_EXPR:\n       mark_stmt_necessary (stmt, true);\n       return;\n "}, {"sha": "edd2b9021883f2027208198ea2ebf75a6cd61826", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058dcc25b74ed4d171182311a12d27272844ee16/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058dcc25b74ed4d171182311a12d27272844ee16/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=058dcc25b74ed4d171182311a12d27272844ee16", "patch": "@@ -2266,6 +2266,10 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n         return;\n       }\n \n+    case CHANGE_DYNAMIC_TYPE_EXPR:\n+      get_expr_operands (stmt, &CHANGE_DYNAMIC_TYPE_LOCATION (expr), opf_use);\n+      return;\n+\n     case BLOCK:\n     case FUNCTION_DECL:\n     case EXC_PTR_EXPR:"}, {"sha": "c5dbf5c5d7f4fd490dff754abda62a4c14bf9374", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 183, "deletions": 7, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058dcc25b74ed4d171182311a12d27272844ee16/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058dcc25b74ed4d171182311a12d27272844ee16/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=058dcc25b74ed4d171182311a12d27272844ee16", "patch": "@@ -250,6 +250,10 @@ struct variable_info\n   /* True if this is a heap variable.  */\n   unsigned int is_heap_var:1;\n \n+  /* True if we may not use TBAA to prune references to this\n+     variable.  This is used for C++ placement new.  */\n+  unsigned int no_tbaa_pruning : 1;\n+\n   /* Points-to set for this variable.  */\n   bitmap solution;\n \n@@ -359,6 +363,7 @@ static varinfo_t\n new_var_info (tree t, unsigned int id, const char *name)\n {\n   varinfo_t ret = (varinfo_t) pool_alloc (variable_info_pool);\n+  tree var;\n \n   ret->id = id;\n   ret->name = name;\n@@ -369,6 +374,12 @@ new_var_info (tree t, unsigned int id, const char *name)\n   ret->is_special_var = false;\n   ret->is_unknown_size_var = false;\n   ret->has_union = false;\n+  var = t;\n+  if (TREE_CODE (var) == SSA_NAME)\n+    var = SSA_NAME_VAR (var);\n+  ret->no_tbaa_pruning = (DECL_P (var)\n+\t\t\t  && POINTER_TYPE_P (TREE_TYPE (var))\n+\t\t\t  && DECL_NO_TBAA_P (var));\n   ret->solution = BITMAP_ALLOC (&pta_obstack);\n   ret->oldsolution = BITMAP_ALLOC (&oldpta_obstack);\n   ret->next = NULL;\n@@ -1195,6 +1206,9 @@ unify_nodes (constraint_graph_t graph, unsigned int to, unsigned int from,\n   merge_graph_nodes (graph, to, from);\n   merge_node_constraints (graph, to, from);\n \n+  if (get_varinfo (from)->no_tbaa_pruning)\n+    get_varinfo (to)->no_tbaa_pruning = true;\n+\n   if (update_changed && TEST_BIT (changed, from))\n     {\n       RESET_BIT (changed, from);\n@@ -3563,6 +3577,14 @@ find_func_aliases (tree origt)\n \t    }\n \t}\n     }\n+  else if (TREE_CODE (t) == CHANGE_DYNAMIC_TYPE_EXPR)\n+    {\n+      unsigned int j;\n+\n+      get_constraint_for (CHANGE_DYNAMIC_TYPE_LOCATION (t), &lhsc);\n+      for (j = 0; VEC_iterate (ce_s, lhsc, j, c); ++j)\n+\tget_varinfo (c->var)->no_tbaa_pruning = true;\n+    }\n \n   /* After promoting variables and computing aliasing we will\n      need to re-scan most statements.  FIXME: Try to minimize the\n@@ -4130,7 +4152,10 @@ dump_solution_for_var (FILE *file, unsigned int var)\n \t{\n \t  fprintf (file, \"%s \", get_varinfo (i)->name);\n \t}\n-      fprintf (file, \"}\\n\");\n+      fprintf (file, \"}\");\n+      if (vi->no_tbaa_pruning)\n+\tfprintf (file, \" no-tbaa-pruning\");\n+      fprintf (file, \"\\n\");\n     }\n }\n \n@@ -4292,10 +4317,13 @@ shared_bitmap_add (bitmap pt_vars)\n    For variables that are actually dereferenced, we also use type\n    based alias analysis to prune the points-to sets.\n    IS_DEREFED is true if PTR was directly dereferenced, which we use to\n-   help determine whether we are we are allowed to prune using TBAA.  */\n+   help determine whether we are we are allowed to prune using TBAA.\n+   If NO_TBAA_PRUNING is true, we do not perform any TBAA pruning of\n+   the from set.  */\n \n static void\n-set_uids_in_ptset (tree ptr, bitmap into, bitmap from, bool is_derefed)\n+set_uids_in_ptset (tree ptr, bitmap into, bitmap from, bool is_derefed,\n+\t\t   bool no_tbaa_pruning)\n {\n   unsigned int i;\n   bitmap_iterator bi;\n@@ -4331,7 +4359,8 @@ set_uids_in_ptset (tree ptr, bitmap into, bitmap from, bool is_derefed)\n \t      if (sft)\n \t\t{\n \t\t  var_alias_set = get_alias_set (sft);\n-\t\t  if ((!is_derefed && !vi->directly_dereferenced)\n+\t\t  if (no_tbaa_pruning\n+\t\t      || (!is_derefed && !vi->directly_dereferenced)\n \t\t      || alias_sets_conflict_p (ptr_alias_set, var_alias_set))\n \t\t    bitmap_set_bit (into, DECL_UID (sft));\n \t\t}\n@@ -4345,7 +4374,8 @@ set_uids_in_ptset (tree ptr, bitmap into, bitmap from, bool is_derefed)\n \t      else\n \t\t{\n \t\t  var_alias_set = get_alias_set (vi->decl);\n-\t\t  if ((!is_derefed && !vi->directly_dereferenced)\n+\t\t  if (no_tbaa_pruning\n+\t\t      || (!is_derefed && !vi->directly_dereferenced)\n \t\t      || alias_sets_conflict_p (ptr_alias_set, var_alias_set))\n \t\t    bitmap_set_bit (into, DECL_UID (vi->decl));\n \t\t}\n@@ -4558,7 +4588,8 @@ find_what_p_points_to (tree p)\n \t    }\n \t  \n \t  set_uids_in_ptset (vi->decl, finished_solution, vi->solution,\n-\t\t\t     vi->directly_dereferenced);\n+\t\t\t     vi->directly_dereferenced,\n+\t\t\t     vi->no_tbaa_pruning);\n \t  result = shared_bitmap_lookup (finished_solution);\n \n \t  if (!result)\n@@ -4784,6 +4815,142 @@ remove_preds_and_fake_succs (constraint_graph_t graph)\n   bitmap_obstack_release (&predbitmap_obstack);\n }\n \n+/* Compute the set of variables we can't TBAA prune.  */\n+\n+static void\n+compute_tbaa_pruning (void)\n+{\n+  unsigned int size = VEC_length (varinfo_t, varmap);\n+  unsigned int i;\n+  bool any;\n+\n+  changed_count = 0;\n+  changed = sbitmap_alloc (size);\n+  sbitmap_zero (changed);\n+\n+  /* Mark all initial no_tbaa_pruning nodes as changed.  */\n+  any = false;\n+  for (i = 0; i < size; ++i)\n+    {\n+      varinfo_t ivi = get_varinfo (i);\n+\n+      if (find (i) == i && ivi->no_tbaa_pruning)\n+\t{\n+\t  any = true;\n+\t  if ((graph->succs[i] && !bitmap_empty_p (graph->succs[i]))\n+\t      || VEC_length (constraint_t, graph->complex[i]) > 0)\n+\t    {\n+\t      SET_BIT (changed, i);\n+\t      ++changed_count;\n+\t    }\n+\t}\n+    }\n+\n+  while (changed_count > 0)\n+    {\n+      struct topo_info *ti = init_topo_info ();\n+      ++stats.iterations;\n+\n+      bitmap_obstack_initialize (&iteration_obstack);\n+\n+      compute_topo_order (graph, ti);\n+\n+      while (VEC_length (unsigned, ti->topo_order) != 0)\n+\t{\n+\t  bitmap_iterator bi;\n+\n+\t  i = VEC_pop (unsigned, ti->topo_order);\n+\n+\t  /* If this variable is not a representative, skip it.  */\n+\t  if (find (i) != i)\n+\t    continue;\n+\n+\t  /* If the node has changed, we need to process the complex\n+\t     constraints and outgoing edges again.  */\n+\t  if (TEST_BIT (changed, i))\n+\t    {\n+\t      unsigned int j;\n+\t      constraint_t c;\n+\t      VEC(constraint_t,heap) *complex = graph->complex[i];\n+\n+\t      RESET_BIT (changed, i);\n+\t      --changed_count;\n+\n+\t      /* Process the complex copy constraints.  */\n+\t      for (j = 0; VEC_iterate (constraint_t, complex, j, c); ++j)\n+\t\t{\n+\t\t  if (c->lhs.type == SCALAR && c->rhs.type == SCALAR)\n+\t\t    {\n+\t\t      varinfo_t lhsvi = get_varinfo (find (c->lhs.var));\n+\n+\t\t      if (!lhsvi->no_tbaa_pruning)\n+\t\t\t{\n+\t\t\t  lhsvi->no_tbaa_pruning = true;\n+\t\t\t  if (!TEST_BIT (changed, lhsvi->id))\n+\t\t\t    {\n+\t\t\t      SET_BIT (changed, lhsvi->id);\n+\t\t\t      ++changed_count;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\n+\t      /* Propagate to all successors.  */\n+\t      EXECUTE_IF_IN_NONNULL_BITMAP (graph->succs[i], 0, j, bi)\n+\t\t{\n+\t\t  unsigned int to = find (j);\n+\t\t  varinfo_t tovi = get_varinfo (to);\n+\n+\t\t  /* Don't propagate to ourselves.  */\n+\t\t  if (to == i)\n+\t\t    continue;\n+\n+\t\t  if (!tovi->no_tbaa_pruning)\n+\t\t    {\n+\t\t      tovi->no_tbaa_pruning = true;\n+\t\t      if (!TEST_BIT (changed, to))\n+\t\t\t{\n+\t\t\t  SET_BIT (changed, to);\n+\t\t\t  ++changed_count;\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+\n+      free_topo_info (ti);\n+      bitmap_obstack_release (&iteration_obstack);\n+    }\n+\n+  sbitmap_free (changed);\n+\n+  if (any)\n+    {\n+      for (i = 0; i < size; ++i)\n+\t{\n+\t  varinfo_t ivi = get_varinfo (i);\n+\t  varinfo_t ivip = get_varinfo (find (i));\n+\n+\t  if (ivip->no_tbaa_pruning)\n+\t    {\n+\t      tree var = ivi->decl;\n+\n+\t      if (TREE_CODE (var) == SSA_NAME)\n+\t\tvar = SSA_NAME_VAR (var);\n+\n+\t      if (POINTER_TYPE_P (TREE_TYPE (var)))\n+\t\t{\n+\t\t  DECL_NO_TBAA_P (var) = 1;\n+\n+\t\t  /* Tell the RTL layer that this pointer can alias\n+\t\t     anything.  */\n+\t\t  DECL_POINTER_ALIAS_SET (var) = 0;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+}\n+\n /* Create points-to sets for the current function.  See the comments\n    at the start of the file for an algorithmic overview.  */\n \n@@ -4820,7 +4987,7 @@ compute_points_to_sets (struct alias_info *ai)\n \t    }\n \t}\n \n-      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+      for (bsi = bsi_start (bb); !bsi_end_p (bsi); )\n \t{\n \t  tree stmt = bsi_stmt (bsi);\n \n@@ -4831,6 +4998,13 @@ compute_points_to_sets (struct alias_info *ai)\n \t     This is used when creating name tags and alias\n \t     sets.  */\n \t  update_alias_info (stmt, ai);\n+\n+\t  /* The information in CHANGE_DYNAMIC_TYPE_EXPR nodes has now\n+\t     been captured, and we can remove them.  */\n+\t  if (TREE_CODE (stmt) == CHANGE_DYNAMIC_TYPE_EXPR)\n+\t    bsi_remove (&bsi, true);\n+\t  else\n+\t    bsi_next (&bsi);\n \t}\n     }\n \n@@ -4862,6 +5036,8 @@ compute_points_to_sets (struct alias_info *ai)\n \n   solve_graph (graph);\n \n+  compute_tbaa_pruning ();\n+\n   if (dump_file)\n     dump_sa_points_to_info (dump_file);\n "}, {"sha": "d4038322bcd812cee8856111e13da180630c769d", "filename": "gcc/tree.def", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058dcc25b74ed4d171182311a12d27272844ee16/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058dcc25b74ed4d171182311a12d27272844ee16/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=058dcc25b74ed4d171182311a12d27272844ee16", "patch": "@@ -1,7 +1,7 @@\n /* This file contains the definitions and documentation for the\n    tree codes used in GCC.\n    Copyright (C) 1987, 1988, 1993, 1995, 1997, 1998, 2000, 2001, 2004, 2005, \n-   2006 Free Software Foundation, Inc.\n+   2006, 2007 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -876,6 +876,15 @@ DEFTREECODE (CATCH_EXPR, \"catch_expr\", tcc_statement, 2)\n    expanding.  */\n DEFTREECODE (EH_FILTER_EXPR, \"eh_filter_expr\", tcc_statement, 2)\n \n+/* Indicates a change in the dynamic type of a memory location.  This\n+   has no value and generates no executable code.  It is only used for\n+   type based alias analysis.  This is generated by C++ placement new.\n+   CHANGE_DYNAMIC_TYPE_NEW_TYPE, the first operand, is the new type.\n+   CHNAGE_DYNAMIC_TYPE_LOCATION, the second operand, is the location\n+   whose type is being changed.  */\n+DEFTREECODE (CHANGE_DYNAMIC_TYPE_EXPR, \"change_dynamic_type_expr\",\n+\t     tcc_statement, 2)\n+\n /* Node used for describing a property that is known at compile\n    time.  */\n DEFTREECODE (SCEV_KNOWN, \"scev_known\", tcc_expression, 0)"}, {"sha": "aefc00ee33a91dbc026d4f5414cb3268a32cd12e", "filename": "gcc/tree.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058dcc25b74ed4d171182311a12d27272844ee16/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058dcc25b74ed4d171182311a12d27272844ee16/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=058dcc25b74ed4d171182311a12d27272844ee16", "patch": "@@ -1637,6 +1637,12 @@ struct tree_constructor GTY(())\n #define EH_FILTER_FAILURE(NODE)\tTREE_OPERAND (EH_FILTER_EXPR_CHECK (NODE), 1)\n #define EH_FILTER_MUST_NOT_THROW(NODE) TREE_STATIC (EH_FILTER_EXPR_CHECK (NODE))\n \n+/* CHANGE_DYNAMIC_TYPE_EXPR accessors.  */\n+#define CHANGE_DYNAMIC_TYPE_NEW_TYPE(NODE) \\\n+  TREE_OPERAND (CHANGE_DYNAMIC_TYPE_EXPR_CHECK (NODE), 0)\n+#define CHANGE_DYNAMIC_TYPE_LOCATION(NODE) \\\n+  TREE_OPERAND (CHANGE_DYNAMIC_TYPE_EXPR_CHECK (NODE), 1)\n+\n /* OBJ_TYPE_REF accessors.  */\n #define OBJ_TYPE_REF_EXPR(NODE)\t  TREE_OPERAND (OBJ_TYPE_REF_CHECK (NODE), 0)\n #define OBJ_TYPE_REF_OBJECT(NODE) TREE_OPERAND (OBJ_TYPE_REF_CHECK (NODE), 1)\n@@ -2671,6 +2677,11 @@ struct tree_memory_partition_tag GTY(())\n #define DECL_GIMPLE_REG_P(DECL) \\\n   DECL_COMMON_CHECK (DECL)->decl_common.gimple_reg_flag\n \n+/* For a DECL with pointer type, this is set if Type Based Alias\n+   Analysis should not be applied to this DECL.  */\n+#define DECL_NO_TBAA_P(DECL) \\\n+  DECL_COMMON_CHECK (DECL)->decl_common.no_tbaa_flag\n+\n struct tree_decl_common GTY(())\n {\n   struct tree_decl_minimal common;\n@@ -2711,6 +2722,8 @@ struct tree_decl_common GTY(())\n   /* Logically, these two would go in a theoretical base shared by var and\n      parm decl. */\n   unsigned gimple_reg_flag : 1;\n+  /* In a DECL with pointer type, set if no TBAA should be done.  */\n+  unsigned no_tbaa_flag : 1;\n \n   union tree_decl_u1 {\n     /* In a FUNCTION_DECL for which DECL_BUILT_IN holds, this is"}]}