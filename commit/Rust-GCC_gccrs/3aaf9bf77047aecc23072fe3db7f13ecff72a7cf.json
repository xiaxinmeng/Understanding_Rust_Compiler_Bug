{"sha": "3aaf9bf77047aecc23072fe3db7f13ecff72a7cf", "node_id": "C_kwDOANBUbNoAKDNhYWY5YmY3NzA0N2FlY2MyMzA3MmZlM2RiN2YxM2VjZmY3MmE3Y2Y", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-03-30T14:13:11Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-03-30T14:13:11Z"}, "message": "c++: ICE with failed __is_constructible constraint [PR100474]\n\nHere we're crashing when diagnosing an unsatisfied __is_constructible\nconstraint because diagnose_trait_expr doesn't recognize this trait\n(along with a bunch of other traits).  Fix this by adding handling for\nall remaining traits and removing the default case so that when adding a\nnew trait we'll get a warning that diagnose_trait_expr needs to handle it.\n\n\tPR c++/100474\n\ngcc/cp/ChangeLog:\n\n\t* constraint.cc (diagnose_trait_expr): Handle all remaining\n\ttraits appropriately.  Remove default case.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp2a/concepts-traits3.C: New test.", "tree": {"sha": "e15c7dfec64ccf61c1d69ad1b49ee016bebe37f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e15c7dfec64ccf61c1d69ad1b49ee016bebe37f6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3aaf9bf77047aecc23072fe3db7f13ecff72a7cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3aaf9bf77047aecc23072fe3db7f13ecff72a7cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3aaf9bf77047aecc23072fe3db7f13ecff72a7cf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3aaf9bf77047aecc23072fe3db7f13ecff72a7cf/comments", "author": null, "committer": null, "parents": [{"sha": "6a777ceb0e975f0efc823d2d82e676346f068151", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a777ceb0e975f0efc823d2d82e676346f068151", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a777ceb0e975f0efc823d2d82e676346f068151"}], "stats": {"total": 109, "additions": 108, "deletions": 1}, "files": [{"sha": "94f6222b436c8403f275d420a6d65419b6618392", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aaf9bf77047aecc23072fe3db7f13ecff72a7cf/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aaf9bf77047aecc23072fe3db7f13ecff72a7cf/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=3aaf9bf77047aecc23072fe3db7f13ecff72a7cf", "patch": "@@ -3654,8 +3654,49 @@ diagnose_trait_expr (tree expr, tree args)\n     case CPTK_IS_UNION:\n       inform (loc, \"  %qT is not a union\", t1);\n       break;\n-    default:\n+    case CPTK_IS_AGGREGATE:\n+      inform (loc, \"  %qT is not an aggregate\", t1);\n+      break;\n+    case CPTK_IS_TRIVIALLY_COPYABLE:\n+      inform (loc, \"  %qT is not trivially copyable\", t1);\n+      break;\n+    case CPTK_IS_ASSIGNABLE:\n+      inform (loc, \"  %qT is not assignable from %qT\", t1, t2);\n+      break;\n+    case CPTK_IS_TRIVIALLY_ASSIGNABLE:\n+      inform (loc, \"  %qT is not trivially assignable from %qT\", t1, t2);\n+      break;\n+    case CPTK_IS_NOTHROW_ASSIGNABLE:\n+      inform (loc, \"  %qT is not %<nothrow%> assignable from %qT\", t1, t2);\n+      break;\n+    case CPTK_IS_CONSTRUCTIBLE:\n+      if (!t2)\n+\tinform (loc, \"  %qT is not default constructible\", t1);\n+      else\n+\tinform (loc, \"  %qT is not constructible from %qE\", t1, t2);\n+      break;\n+    case CPTK_IS_TRIVIALLY_CONSTRUCTIBLE:\n+      if (!t2)\n+\tinform (loc, \"  %qT is not trivially default constructible\", t1);\n+      else\n+\tinform (loc, \"  %qT is not trivially constructible from %qE\", t1, t2);\n+      break;\n+    case CPTK_IS_NOTHROW_CONSTRUCTIBLE:\n+      if (!t2)\n+\tinform (loc, \"  %qT is not %<nothrow%> default constructible\", t1);\n+      else\n+\tinform (loc, \"  %qT is not %<nothrow%> constructible from %qE\", t1, t2);\n+      break;\n+    case CPTK_HAS_UNIQUE_OBJ_REPRESENTATIONS:\n+      inform (loc, \"  %qT does not have unique object representations\", t1);\n+      break;\n+    case CPTK_BASES:\n+    case CPTK_DIRECT_BASES:\n+    case CPTK_UNDERLYING_TYPE:\n+      /* We shouldn't see these non-expression traits.  */\n       gcc_unreachable ();\n+    /* We deliberately omit the default case so that when adding a new\n+       trait we'll get reminded (by way of a warning) to handle it here.  */\n     }\n }\n "}, {"sha": "f20608b6918bb09d80f2672df8c475ed823b53d1", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-traits3.C", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aaf9bf77047aecc23072fe3db7f13ecff72a7cf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-traits3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aaf9bf77047aecc23072fe3db7f13ecff72a7cf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-traits3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-traits3.C?ref=3aaf9bf77047aecc23072fe3db7f13ecff72a7cf", "patch": "@@ -0,0 +1,66 @@\n+// PR c++/100474\n+// { dg-do compile { target c++20 } }\n+\n+struct S { S() = delete; S(const S&); };\n+\n+template<class T>\n+concept Aggregate = __is_aggregate(T);\n+// { dg-message \"'S' is not an aggregate\" \"\" { target *-*-* } .-1  }\n+\n+template<class T>\n+concept TriviallyCopyable = __is_trivially_copyable(T);\n+// { dg-message \"'S' is not trivially copyable\" \"\" { target *-*-* } .-1  }\n+\n+template<class T, class U>\n+concept Assignable = __is_assignable(T, U);\n+// { dg-message \"'S' is not assignable from 'int'\" \"\" { target *-*-* } .-1  }\n+\n+template<class T, class U>\n+concept TriviallyAssignable = __is_trivially_assignable(T, U);\n+// { dg-message \"'S' is not trivially assignable from 'int'\" \"\" { target *-*-* } .-1  }\n+\n+template<class T, class U>\n+concept NothrowAssignable = __is_nothrow_assignable(T, U);\n+// { dg-message \"'S' is not 'nothrow' assignable from 'int'\" \"\" { target *-*-* } .-1  }\n+\n+template<class T, class... Args>\n+concept Constructible = __is_constructible(T, Args...);\n+// { dg-message \"'S' is not default constructible\" \"\" { target *-*-* } .-1  }\n+// { dg-message \"'S' is not constructible from 'int'\" \"\" { target *-*-* } .-2  }\n+// { dg-message \"'S' is not constructible from 'int, char'\" \"\" { target *-*-* } .-3  }\n+\n+template<class T, class... Args>\n+concept TriviallyConstructible = __is_trivially_constructible(T, Args...);\n+// { dg-message \"'S' is not trivially default constructible\" \"\" { target *-*-* } .-1  }\n+// { dg-message \"'S' is not trivially constructible from 'int'\" \"\" { target *-*-* } .-2  }\n+// { dg-message \"'S' is not trivially constructible from 'int, char'\" \"\" { target *-*-* } .-3  }\n+\n+template<class T, class... Args>\n+concept NothrowConstructible = __is_nothrow_constructible(T, Args...);\n+// { dg-message \"'S' is not 'nothrow' default constructible\" \"\" { target *-*-* } .-1  }\n+// { dg-message \"'S' is not 'nothrow' constructible from 'int'\" \"\" { target *-*-* } .-2  }\n+// { dg-message \"'S' is not 'nothrow' constructible from 'int, char'\" \"\" { target *-*-* } .-3  }\n+\n+template<class T>\n+concept UniqueObjReps = __has_unique_object_representations(T);\n+// { dg-message \"'S' does not have unique object representations\" \"\" { target *-*-* } .-1  }\n+\n+static_assert(Aggregate<S>); // { dg-error \"assert\" }\n+static_assert(TriviallyCopyable<S>); // { dg-error \"assert\" }\n+static_assert(Assignable<S, int>); // { dg-error \"assert\" }\n+static_assert(TriviallyAssignable<S, int>); // { dg-error \"assert\" }\n+static_assert(NothrowAssignable<S, int>); // { dg-error \"assert\" }\n+\n+static_assert(Constructible<S>); // { dg-error \"assert\" }\n+static_assert(Constructible<S, int>); // { dg-error \"assert\" }\n+static_assert(Constructible<S, int, char>); // { dg-error \"assert\" }\n+\n+static_assert(TriviallyConstructible<S>); // { dg-error \"assert\" }\n+static_assert(TriviallyConstructible<S, int>); // { dg-error \"assert\" }\n+static_assert(TriviallyConstructible<S, int, char>); // { dg-error \"assert\" }\n+\n+static_assert(NothrowConstructible<S>); // { dg-error \"assert\" }\n+static_assert(NothrowConstructible<S, int>); // { dg-error \"assert\" }\n+static_assert(NothrowConstructible<S, int, char>); // { dg-error \"assert\" }\n+\n+static_assert(UniqueObjReps<S>); // { dg-error \"assert\" }"}]}