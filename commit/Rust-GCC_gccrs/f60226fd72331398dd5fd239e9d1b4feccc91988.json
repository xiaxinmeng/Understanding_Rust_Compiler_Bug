{"sha": "f60226fd72331398dd5fd239e9d1b4feccc91988", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjYwMjI2ZmQ3MjMzMTM5OGRkNWZkMjM5ZTlkMWI0ZmVjY2M5MTk4OA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-02-12T15:54:48Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-02-12T15:54:48Z"}, "message": "df: Record all definitions in DF_LR_BB_INFO->def [PR98863]\n\ndf_lr_bb_local_compute has:\n\n      FOR_EACH_INSN_INFO_DEF (def, insn_info)\n\t/* If the def is to only part of the reg, it does\n\t   not kill the other defs that reach here.  */\n\tif (!(DF_REF_FLAGS (def) & (DF_REF_PARTIAL | DF_REF_CONDITIONAL)))\n\nHowever, as noted in the comment in the patch and below, almost all\npartial definitions have an associated use.  This means that the\nconfluence function:\n\n  IN = (OUT & ~DEF) | USE\n\nis unaffected by whether partial definitions are in DEF or not.\n\nEven though the choice doesn't matter for the LR problem itself,\nit's IMO much more convenient for consumers if DEF contains all the\ndefinitions in the block.  The only pre-RTL-SSA code that tries to\nconsume DEF directly is shrink-wrap.c, which already has to work\naround the incompleteness of the information:\n\n\t  /* DF_LR_BB_INFO (bb)->def does not comprise the DF_REF_PARTIAL and\n\t     DF_REF_CONDITIONAL defs.  So if DF_LIVE doesn't exist, i.e.\n\t     at -O1, just give up searching NEXT_BLOCK.  */\n\nI hit the same problem when trying to fix the RTL-SSA part of PR98863.\n\nThis patch treats partial definitions as both a def and a use,\njust like the df_ref records almost always do.\n\nTo show that partial definitions almost always have uses:\n\n  DF_REF_CONDITIONAL:\n\n    Added by:\n\n      case COND_EXEC:\n\tdf_defs_record (collection_rec, COND_EXEC_CODE (x),\n\t\t\tbb, insn_info, DF_REF_CONDITIONAL);\n\tbreak;\n\n    Later, df_get_conditional_uses creates uses for all DF_REF_CONDITIONAL\n    definitions.\n\n  DF_REF_PARTIAL:\n\n    In total, there are 4 locations at which we add partial definitions.\n\n    Case 1:\n\n      if (GET_CODE (dst) == STRICT_LOW_PART)\n\t{\n\t  flags |= DF_REF_READ_WRITE | DF_REF_PARTIAL | DF_REF_STRICT_LOW_PART;\n\n\t  loc = &XEXP (dst, 0);\n\t  dst = *loc;\n\t}\n\n    Corresponding use:\n\n      case STRICT_LOW_PART:\n\t{\n\t  rtx *temp = &XEXP (dst, 0);\n\t  /* A strict_low_part uses the whole REG and not just the\n\t   SUBREG.  */\n\t  dst = XEXP (dst, 0);\n\t  df_uses_record (collection_rec,\n\t\t\t  (GET_CODE (dst) == SUBREG) ? &SUBREG_REG (dst) : temp,\n\t\t\t  DF_REF_REG_USE, bb, insn_info,\n\t\t\t  DF_REF_READ_WRITE | DF_REF_STRICT_LOW_PART);\n\t}\n\tbreak;\n\n    Case 2:\n\n      if (GET_CODE (dst) == ZERO_EXTRACT)\n\t{\n\t  flags |= DF_REF_READ_WRITE | DF_REF_PARTIAL | DF_REF_ZERO_EXTRACT;\n\n\t  loc = &XEXP (dst, 0);\n\t  dst = *loc;\n\t}\n\n    Corresponding use:\n\n      case ZERO_EXTRACT:\n\t{\n\t  df_uses_record (collection_rec, &XEXP (dst, 1),\n\t\t\t  DF_REF_REG_USE, bb, insn_info, flags);\n\t  df_uses_record (collection_rec, &XEXP (dst, 2),\n\t\t\t  DF_REF_REG_USE, bb, insn_info, flags);\n\t  if (GET_CODE (XEXP (dst,0)) == MEM)\n\t    df_uses_record (collection_rec, &XEXP (dst, 0),\n\t\t\t    DF_REF_REG_USE, bb, insn_info,\n\t\t\t    flags);\n\t  else\n\t    df_uses_record (collection_rec, &XEXP (dst, 0),\n\t\t\t    DF_REF_REG_USE, bb, insn_info,\n\t\t\t    DF_REF_READ_WRITE | DF_REF_ZERO_EXTRACT);\n----------------------------^^^^^^^^^^^^^^^^^\n\t}\n\tbreak;\n\n    Case 3:\n\n      else if (GET_CODE (dst) == SUBREG && REG_P (SUBREG_REG (dst)))\n\t{\n\t  if (read_modify_subreg_p (dst))\n\t    flags |= DF_REF_READ_WRITE | DF_REF_PARTIAL;\n\n\t  flags |= DF_REF_SUBREG;\n\n\t  df_ref_record (DF_REF_REGULAR, collection_rec,\n\t\t\t dst, loc, bb, insn_info, DF_REF_REG_DEF, flags);\n\t}\n\n    Corresponding use:\n\n      case SUBREG:\n\tif (read_modify_subreg_p (dst))\n\t  {\n\t    df_uses_record (collection_rec, &SUBREG_REG (dst),\n\t\t\t    DF_REF_REG_USE, bb, insn_info,\n\t\t\t    flags | DF_REF_READ_WRITE | DF_REF_SUBREG);\n\t    break;\n\t  }\n\n    Case 4:\n\n      /*  If this is a multiword hardreg, we create some extra\n\t  datastructures that will enable us to easily build REG_DEAD\n\t  and REG_UNUSED notes.  */\n      if (collection_rec\n\t  && (endregno != regno + 1) && insn_info)\n\t{\n\t  /* Sets to a subreg of a multiword register are partial.\n\t     Sets to a non-subreg of a multiword register are not.  */\n\t  if (GET_CODE (reg) == SUBREG)\n\t    ref_flags |= DF_REF_PARTIAL;\n\t  ref_flags |= DF_REF_MW_HARDREG;\n\n    Corresponding use:\n\n      None.  However, this case should be rare to non-existent on most\n      targets, and the current handling seems suspect.  See the comment\n      in the patch for more details.\n\ngcc/\n\t* df-problems.c (df_lr_bb_local_compute): Treat partial definitions\n\tas read-modify operations.\n\ngcc/testsuite/\n\t* gcc.dg/rtl/aarch64/multi-subreg-1.c: New test.", "tree": {"sha": "87e31f6a45c95a67487356d0425811c94bdb4d42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/87e31f6a45c95a67487356d0425811c94bdb4d42"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f60226fd72331398dd5fd239e9d1b4feccc91988", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f60226fd72331398dd5fd239e9d1b4feccc91988", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f60226fd72331398dd5fd239e9d1b4feccc91988", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f60226fd72331398dd5fd239e9d1b4feccc91988/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b7210405ed8eb5fd723b2c99960dcc5f0aec89b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7210405ed8eb5fd723b2c99960dcc5f0aec89b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7210405ed8eb5fd723b2c99960dcc5f0aec89b4"}], "stats": {"total": 73, "additions": 66, "deletions": 7}, "files": [{"sha": "83b200baf9d4cda30bb4a9389267f97b1a46d594", "filename": "gcc/df-problems.c", "status": "modified", "additions": 47, "deletions": 7, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f60226fd72331398dd5fd239e9d1b4feccc91988/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f60226fd72331398dd5fd239e9d1b4feccc91988/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=f60226fd72331398dd5fd239e9d1b4feccc91988", "patch": "@@ -842,14 +842,54 @@ df_lr_bb_local_compute (unsigned int bb_index)\n \n       df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n       FOR_EACH_INSN_INFO_DEF (def, insn_info)\n-\t/* If the def is to only part of the reg, it does\n-\t   not kill the other defs that reach here.  */\n-\tif (!(DF_REF_FLAGS (def) & (DF_REF_PARTIAL | DF_REF_CONDITIONAL)))\n-\t  {\n-\t    unsigned int dregno = DF_REF_REGNO (def);\n-\t    bitmap_set_bit (&bb_info->def, dregno);\n+\t{\n+\t  /* If the definition is to only part of the register, it will\n+\t     usually have a corresponding use.  For example, stores to one\n+\t     word of a multiword register R have both a use and a partial\n+\t     definition of R.\n+\n+\t     In those cases, the LR confluence function:\n+\n+\t       IN = (OUT & ~DEF) | USE\n+\n+\t     is unaffected by whether we count the partial definition or not.\n+\t     However, it's more convenient for consumers if DEF contains\n+\t     *all* the registers defined in a block.\n+\n+\t     The only current case in which we record a partial definition\n+\t     without a corresponding use is if the destination is the\n+\t     multi-register subreg of a hard register.  An artificial\n+\t     example of this is:\n+\n+\t\t(set (subreg:TI (reg:V8HI x0) 0) (const_int -1))\n+\n+\t     on AArch64.  This is described as a DF_REF_PARTIAL\n+\t     definition of x0 and x1 with no corresponding uses.\n+\t     In previous versions of GCC, the instruction had no\n+\t     effect on LR (that is, LR acted as though the instruction\n+\t     didn't exist).\n+\n+\t     It seems suspect that this case is treated differently.\n+\t     Either the instruction should be a full definition of x0 and x1,\n+\t     or the definition should be treated in the same way as other\n+\t     partial definitions, such as strict_lowparts or subregs that\n+\t     satisfy read_modify_subreg_p.\n+\n+\t     Fortunately, multi-register subregs of hard registers should\n+\t     be rare.  They should be folded into a plain REG if the target\n+\t     allows that (as AArch64 does for example above).\n+\n+\t     Here we treat the cases alike by forcing a use even in the rare\n+\t     case that no DF_REF_REG_USE is recorded.  That is, we model all\n+\t     partial definitions as both a use and a definition of the\n+\t     register.  */\n+\t  unsigned int dregno = DF_REF_REGNO (def);\n+\t  bitmap_set_bit (&bb_info->def, dregno);\n+\t  if (DF_REF_FLAGS (def) & (DF_REF_PARTIAL | DF_REF_CONDITIONAL))\n+\t    bitmap_set_bit (&bb_info->use, dregno);\n+\t  else\n \t    bitmap_clear_bit (&bb_info->use, dregno);\n-\t  }\n+\t}\n \n       FOR_EACH_INSN_INFO_USE (use, insn_info)\n \t/* Add use to set of uses in this BB.  */"}, {"sha": "d7be5592e78518b1d347312a8b8e4694e4ed9409", "filename": "gcc/testsuite/gcc.dg/rtl/aarch64/multi-subreg-1.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f60226fd72331398dd5fd239e9d1b4feccc91988/gcc%2Ftestsuite%2Fgcc.dg%2Frtl%2Faarch64%2Fmulti-subreg-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f60226fd72331398dd5fd239e9d1b4feccc91988/gcc%2Ftestsuite%2Fgcc.dg%2Frtl%2Faarch64%2Fmulti-subreg-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Frtl%2Faarch64%2Fmulti-subreg-1.c?ref=f60226fd72331398dd5fd239e9d1b4feccc91988", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-additional-options \"-O -fdump-rtl-cse1-all\" } */\n+\n+__int128 __RTL (startwith (\"vregs\")) foo (void)\n+{\n+(function \"foo\"\n+  (insn-chain\n+    (block 2\n+      (edge-from entry (flags \"FALLTHRU\"))\n+      (cnote 1 [bb 2] NOTE_INSN_BASIC_BLOCK)\n+      (cnote 2 NOTE_INSN_FUNCTION_BEG)\n+      (cinsn 3 (set (subreg:TI (reg:V8HI x0) 0) (const_int -1)))\n+      (edge-to exit (flags \"FALLTHRU\"))\n+    )\n+  )\n+  (crtl (return_rtx (reg/i:TI x0)))\n+)\n+}\n+\n+/* { dg-final { scan-rtl-dump {(?n)lr *def.*\\[x0\\].*\\[x1\\]} cse1 } } */"}]}