{"sha": "b2aec5c0ebe5c21cf62cc40f578ebc800ea02e7a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjJhZWM1YzBlYmU1YzIxY2Y2MmNjNDBmNTc4ZWJjODAwZWEwMmU3YQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-06-22T17:18:23Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-06-22T17:18:23Z"}, "message": "regs.h (struct reg_info_def): Add freq field.\n\n\t* regs.h (struct reg_info_def): Add freq field.\n\t(REG_N_REFS): Update comment.\n\t(REG_FREQ): New.\n\t* regclass.c (scan_one_insn): Update REG_FREQ.\n\t* flow.c (mark_set_1): Update REG_FREQ, make REG_N_SETS unweighted.\n\t(attempt_auto_inc): Likewise.\n\t(mark_used_reg): Likewise.\n\t(try_pre_increment_1): Likewise.\n\t* local-alloc.c (struct qty): Add freq field.\n\t(alloc_qty): Set freq.\n\t(update_equiv_regs): Set REG_FREQ.\n\t(QTY_CMP_PRI): Use freq.\n\t(combine_regs): Update qty->freq.\n\t* global.c (struct allocno): Update comment for n_refs;\n\tadd freq field.\n\t(local_reg_freq): New array.\n\t(global_alloc): Update freq field;\n\tallocate and initialize local_reg_freq.\n\t(allocno_compare): Use freq field.\n\t(find_reg): Likewise.\n\t* reload1.c (count_pseudo): Use freq isntead of n_refs.\n\t(count_spilled_pseudo): Likewise.\n\n\t* tm.texi (GCOV_TYPE_SIZE): Document.\n\t* basic-block.h (gcov_type): Define.\n\t(struct edge_def): Use gcov_type for count field.\n\t(struct basic_block_def): Likewise.\n\t* defaults.h (GCOV_TYPE_SIZE): Define.\n\t* final.c (end_final): Use GCOV_TYPE_SIZE.\n\t* flow.c (dump_edge_info, dump_flow_info, dump_bb): Print count fields\n\tusing HOST_WIDEST_INT_PRINT_DEC.\n\t* gcov-io.h (__fetch_gcov_type, __store_gcov_type, __read_gcov_type,\n\t__write_gcov_type): New.\n\t(store_long): Remove.\n\t* gcov.c (gcov_type): Set default.\n\t(struct adj_list): Use gcov_type for arc_count.\n\t(bb_info): Use gcov_type for succ_count, pred_count and exec_count.\n\t(create_program_flow_graph): Read arc_count properly.\n\t(solve_program_flow_graph): 'total' is gcov_type.\n\t(output_data): Line_counts is gcov_type, print it properly.\n\t* libgcc2.c (struct bb): Counts is gcov_type.\n\t(__bb_exit_func): Use __read_gcov_type and __write_gcov_type.\n\t* profile.c (LONG_TYPE_SIZE, LONG_LONG_TYPE_SIZE): Set default.\n\t(GCOV_TYPE_SIZE): Define.\n\t(struct bb_info): succ_count and pred_count is gcov_type.\n\t(compute_branch_probabilities): Use __read_gcov_type,\n\tprint read edges to the dump file.\n\t(total): Is gcov_type.\n\t(gen_edge_profiler): Use GCOV_TYPE_SIZE.\n\nFrom-SVN: r43505", "tree": {"sha": "d48fd46b997881efda1b77cb5b95669fa3c2921d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d48fd46b997881efda1b77cb5b95669fa3c2921d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b2aec5c0ebe5c21cf62cc40f578ebc800ea02e7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2aec5c0ebe5c21cf62cc40f578ebc800ea02e7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2aec5c0ebe5c21cf62cc40f578ebc800ea02e7a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2aec5c0ebe5c21cf62cc40f578ebc800ea02e7a/comments", "author": null, "committer": null, "parents": [{"sha": "5154e79ae48dfc2706c2268654f9304bc0c85367", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5154e79ae48dfc2706c2268654f9304bc0c85367", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5154e79ae48dfc2706c2268654f9304bc0c85367"}], "stats": {"total": 242, "additions": 182, "deletions": 60}, "files": [{"sha": "a9ef4ef33c616d1cdfc4cc8910efb97598019f3c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2aec5c0ebe5c21cf62cc40f578ebc800ea02e7a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2aec5c0ebe5c21cf62cc40f578ebc800ea02e7a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b2aec5c0ebe5c21cf62cc40f578ebc800ea02e7a", "patch": "@@ -1,3 +1,55 @@\n+Fri Jun 22 19:11:28 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* regs.h (struct reg_info_def): Add freq field.\n+\t(REG_N_REFS): Update comment.\n+\t(REG_FREQ): New.\n+\t* regclass.c (scan_one_insn): Update REG_FREQ.\n+\t* flow.c (mark_set_1): Update REG_FREQ, make REG_N_SETS unweighted.\n+\t(attempt_auto_inc): Likewise.\n+\t(mark_used_reg): Likewise.\n+\t(try_pre_increment_1): Likewise.\n+\t* local-alloc.c (struct qty): Add freq field.\n+\t(alloc_qty): Set freq.\n+\t(update_equiv_regs): Set REG_FREQ.\n+\t(QTY_CMP_PRI): Use freq.\n+\t(combine_regs): Update qty->freq.\n+\t* global.c (struct allocno): Update comment for n_refs;\n+\tadd freq field.\n+\t(local_reg_freq): New array.\n+\t(global_alloc): Update freq field;\n+\tallocate and initialize local_reg_freq.\n+\t(allocno_compare): Use freq field.\n+\t(find_reg): Likewise.\n+\t* reload1.c (count_pseudo): Use freq isntead of n_refs.\n+\t(count_spilled_pseudo): Likewise.\n+\n+\t* tm.texi (GCOV_TYPE_SIZE): Document.\n+\t* basic-block.h (gcov_type): Define.\n+\t(struct edge_def): Use gcov_type for count field.\n+\t(struct basic_block_def): Likewise.\n+\t* defaults.h (GCOV_TYPE_SIZE): Define.\n+\t* final.c (end_final): Use GCOV_TYPE_SIZE.\n+\t* flow.c (dump_edge_info, dump_flow_info, dump_bb): Print count fields\n+\tusing HOST_WIDEST_INT_PRINT_DEC.\n+\t* gcov-io.h (__fetch_gcov_type, __store_gcov_type, __read_gcov_type,\n+\t__write_gcov_type): New.\n+\t(store_long): Remove.\n+\t* gcov.c (gcov_type): Set default.\n+\t(struct adj_list): Use gcov_type for arc_count.\n+\t(bb_info): Use gcov_type for succ_count, pred_count and exec_count.\n+\t(create_program_flow_graph): Read arc_count properly.\n+\t(solve_program_flow_graph): 'total' is gcov_type.\n+\t(output_data): Line_counts is gcov_type, print it properly.\n+\t* libgcc2.c (struct bb): Counts is gcov_type.\n+\t(__bb_exit_func): Use __read_gcov_type and __write_gcov_type.\n+\t* profile.c (LONG_TYPE_SIZE, LONG_LONG_TYPE_SIZE): Set default.\n+\t(GCOV_TYPE_SIZE): Define.\n+\t(struct bb_info): succ_count and pred_count is gcov_type.\n+\t(compute_branch_probabilities): Use __read_gcov_type,\n+\tprint read edges to the dump file.\n+\t(total): Is gcov_type.\n+\t(gen_edge_profiler): Use GCOV_TYPE_SIZE.\n+\n 2001-06-14  Andrew Haley  <aph@cambridge.redhat.com>\n \n \t* optabs.c (emit_libcall_block): When using non-call exceptions,"}, {"sha": "c41ee322a0eba6372a8d0e135a7b8912acf4cc50", "filename": "gcc/basic-block.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2aec5c0ebe5c21cf62cc40f578ebc800ea02e7a/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2aec5c0ebe5c21cf62cc40f578ebc800ea02e7a/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=b2aec5c0ebe5c21cf62cc40f578ebc800ea02e7a", "patch": "@@ -111,6 +111,9 @@ do {\t\t\t\t\t\t\t\t\t\\\n    be done, other than zero the statistics on the first allocation.  */\n #define MAX_REGNO_REG_SET(NUM_REGS, NEW_P, RENUMBER_P) \n \n+/* Type we use to hold basic block counters.  Should be at least 64bit.  */\n+typedef HOST_WIDEST_INT gcov_type;\n+\n /* Control flow edge information.  */\n typedef struct edge_def {\n   /* Links through the predecessor and successor lists.  */\n@@ -127,7 +130,7 @@ typedef struct edge_def {\n \n   int flags;\t\t\t/* see EDGE_* below  */\n   int probability;\t\t/* biased by REG_BR_PROB_BASE */\n-  int count;\t\t\t/* Expected number of executions calculated\n+  gcov_type count;\t\t/* Expected number of executions calculated\n \t\t\t\t   in profile.c  */\n } *edge;\n \n@@ -201,7 +204,7 @@ typedef struct basic_block_def {\n   int loop_depth;\n \n   /* Expected number of executions: calculated in profile.c.  */\n-  int count;\n+  gcov_type count;\n  \n   /* Expected frequency.  Normalized to be in range 0 to BB_FREQ_MAX.  */\n   int frequency;"}, {"sha": "cf1042498867e095096b285c271846cdd3b505cb", "filename": "gcc/defaults.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2aec5c0ebe5c21cf62cc40f578ebc800ea02e7a/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2aec5c0ebe5c21cf62cc40f578ebc800ea02e7a/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=b2aec5c0ebe5c21cf62cc40f578ebc800ea02e7a", "patch": "@@ -297,6 +297,15 @@ do {\t\t\t\t\t\t\t\t\\\n #define PIC_OFFSET_TABLE_REGNUM INVALID_REGNUM\n #endif\n \n+/* Type used by GCOV counters.  Use 64bit data type if target supports\n+   it.  */\n+#if LONG_TYPE_SIZE >= 64\n+#define GCOV_TYPE_SIZE LONG_TYPE_SIZE\n+#else\n+#define GCOV_TYPE_SIZE LONG_LONG_TYPE_SIZE\n+#endif\n+\n+\n /* By default, the preprocessor should be invoked the same way in C++\n    as in C.  */\n #ifndef CPLUSPLUS_CPP_SPEC"}, {"sha": "5ef909b485a042ec0e372e3c1f2fbb5acb72e2c5", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2aec5c0ebe5c21cf62cc40f578ebc800ea02e7a/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2aec5c0ebe5c21cf62cc40f578ebc800ea02e7a/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=b2aec5c0ebe5c21cf62cc40f578ebc800ea02e7a", "patch": "@@ -1426,6 +1426,14 @@ characters.  If this is undefined, the default is\n largest value that @code{WCHAR_TYPE_SIZE} can have at run-time.  This is\n used in @code{cpp}.\n \n+@findex GCOV_TYPE_SIZE\n+@item GCOV_TYPE_SIZE\n+A C expression for the size in bits of the type used for gcov counters on the\n+target machine.  If you don't define this, the default is one\n+@code{LONG_TYPE_SIZE} in case it is greater or equal to 64-bit and\n+@code{LONG_LONG_TYPE_SIZE} otherwise.  You may want to re-define the type to\n+ensure atomicity for counters in multithreaded programs.\n+\n @findex WINT_TYPE\n @item WINT_TYPE\n A C expression for a string describing the name of the data type to"}, {"sha": "b1d2051c1cd247165b97f337dabc0b455ccdf9fa", "filename": "gcc/final.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2aec5c0ebe5c21cf62cc40f578ebc800ea02e7a/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2aec5c0ebe5c21cf62cc40f578ebc800ea02e7a/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=b2aec5c0ebe5c21cf62cc40f578ebc800ea02e7a", "patch": "@@ -298,12 +298,13 @@ end_final (filename)\n       struct bb_list *ptr;\n       struct bb_str *sptr;\n       int long_bytes = LONG_TYPE_SIZE / BITS_PER_UNIT;\n+      int gcov_type_bytes = GCOV_TYPE_SIZE / BITS_PER_UNIT;\n       int pointer_bytes = POINTER_SIZE / BITS_PER_UNIT;\n \n       if (profile_block_flag)\n \tsize = long_bytes * count_basic_blocks;\n       else\n-\tsize = long_bytes * count_instrumented_edges;\n+\tsize = gcov_type_bytes * count_instrumented_edges;\n       rounded = size;\n \n       rounded += (BIGGEST_ALIGNMENT / BITS_PER_UNIT) - 1;"}, {"sha": "b3d4327847708b792147408cb401ea4d879ebc8a", "filename": "gcc/flow.c", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2aec5c0ebe5c21cf62cc40f578ebc800ea02e7a/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2aec5c0ebe5c21cf62cc40f578ebc800ea02e7a/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=b2aec5c0ebe5c21cf62cc40f578ebc800ea02e7a", "patch": "@@ -4856,8 +4856,8 @@ mark_set_1 (pbi, code, reg, cond, insn, flags)\n \t\t  /* Count (weighted) references, stores, etc.  This counts a\n \t\t     register twice if it is modified, but that is correct.  */\n \t\t  REG_N_SETS (i) += 1;\n-\t\t  REG_N_REFS (i) += (optimize_size ? 1\n-\t\t\t\t     : pbi->bb->loop_depth + 1);\n+\t\t  REG_N_REFS (i) += 1;\n+\t\t  REG_FREQ (i) += (optimize_size ? 1 : pbi->bb->loop_depth + 1);\n \n \t          /* The insns where a reg is live are normally counted\n \t\t     elsewhere, but we want the count to include the insn\n@@ -5524,7 +5524,7 @@ attempt_auto_inc (pbi, inc, insn, mem, incr, incr_reg)\n       /* Count an extra reference to the reg.  When a reg is\n \t incremented, spilling it is worse, so we want to make\n \t that less likely.  */\n-      REG_N_REFS (regno) += (optimize_size ? 1 : pbi->bb->loop_depth + 1);\n+      REG_FREQ (regno) += (optimize_size ? 1 : pbi->bb->loop_depth + 1);\n \n       /* Count the increment as a setting of the register,\n \t even though it isn't a SET in rtl.  */\n@@ -5689,8 +5689,9 @@ mark_used_reg (pbi, reg, cond, insn)\n \t    REG_BASIC_BLOCK (regno_first) = REG_BLOCK_GLOBAL;\n \n \t  /* Count (weighted) number of uses of each reg.  */\n-\t  REG_N_REFS (regno_first)\n+\t  REG_FREQ (regno_first)\n \t    += (optimize_size ? 1 : pbi->bb->loop_depth + 1);\n+\t  REG_N_REFS (regno_first)++;\n \t}\n     }\n \n@@ -6111,8 +6112,7 @@ try_pre_increment_1 (pbi, insn)\n \t so we want to make that less likely.  */\n       if (regno >= FIRST_PSEUDO_REGISTER)\n \t{\n-\t  REG_N_REFS (regno) += (optimize_size ? 1\n-\t\t\t\t : pbi->bb->loop_depth + 1);\n+\t  REG_FREQ (regno) += (optimize_size ? 1 : pbi->bb->loop_depth + 1);\n \t  REG_N_SETS (regno)++;\n \t}\n \n@@ -6359,9 +6359,10 @@ dump_flow_info (file)\n       register basic_block bb = BASIC_BLOCK (i);\n       register edge e;\n \n-      fprintf (file, \"\\nBasic block %d: first insn %d, last %d, loop_depth %d, count %d, freq %d.\\n\",\n-\t       i, INSN_UID (bb->head), INSN_UID (bb->end), bb->loop_depth,\n-\t       bb->count, bb->frequency);\n+      fprintf (file, \"\\nBasic block %d: first insn %d, last %d, loop_depth %d, count \",\n+\t       i, INSN_UID (bb->head), INSN_UID (bb->end), bb->loop_depth);\n+      fprintf (file, HOST_WIDEST_INT_PRINT_DEC, (HOST_WIDEST_INT) bb->count);\n+      fprintf (file, \", freq %i.\\n\", bb->frequency);\n \n       fprintf (file, \"Predecessors: \");\n       for (e = bb->pred; e; e = e->pred_next)\n@@ -6405,7 +6406,10 @@ dump_edge_info (file, e, do_succ)\n     fprintf (file, \" %d\", side->index);\n \n   if (e->count)\n-    fprintf (file, \" count:%d\", e->count);\n+    {\n+      fprintf (file, \" count:\");\n+      fprintf (file, HOST_WIDEST_INT_PRINT_DEC, (HOST_WIDEST_INT) e->count);\n+    }\n \n   if (e->flags)\n     {\n@@ -6445,8 +6449,9 @@ dump_bb (bb, outf)\n   rtx last;\n   edge e;\n \n-  fprintf (outf, \";; Basic block %d, loop depth %d, count %d\",\n+  fprintf (outf, \";; Basic block %d, loop depth %d, count \",\n \t   bb->index, bb->loop_depth, bb->count);\n+  fprintf (outf, HOST_WIDEST_INT_PRINT_DEC, (HOST_WIDEST_INT) bb->count);\n   putc ('\\n', outf);\n \n   fputs (\";; Predecessors: \", outf);"}, {"sha": "91cbbd64109f74442a8a1379cd9c3b1de8a19c94", "filename": "gcc/gcov.c", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2aec5c0ebe5c21cf62cc40f578ebc800ea02e7a/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2aec5c0ebe5c21cf62cc40f578ebc800ea02e7a/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=b2aec5c0ebe5c21cf62cc40f578ebc800ea02e7a", "patch": "@@ -48,6 +48,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"intl.h\"\n #undef abort\n \n+typedef HOST_WIDEST_INT gcov_type;\n #include \"gcov-io.h\"\n \n /* The .bb file format consists of several lists of 4-byte integers\n@@ -104,7 +105,7 @@ struct sourcefile *sources;\n struct adj_list {\n   int source;\n   int target;\n-  int arc_count;\n+  gcov_type arc_count;\n   unsigned int count_valid : 1;\n   unsigned int on_tree : 1;\n   unsigned int fake : 1;\n@@ -123,9 +124,9 @@ struct adj_list {\n struct bb_info {\n   struct adj_list *succ;\n   struct adj_list *pred;\n-  int succ_count;\n-  int pred_count;\n-  int exec_count;\n+  gcov_type succ_count;\n+  gcov_type pred_count;\n+  gcov_type exec_count;\n   unsigned int count_valid : 1;\n   unsigned int on_tree : 1;\n #if 0\n@@ -579,8 +580,8 @@ create_program_flow_graph (bptr)\n     for (arcptr = bb_graph[i].succ; arcptr; arcptr = arcptr->succ_next)\n       if (! arcptr->on_tree)\n \t{\n-\t  long tmp_count = 0;\n-\t  if (da_file && __read_long (&tmp_count, da_file, 8))\n+\t  gcov_type tmp_count = 0;\n+\t  if (da_file && __read_gcov_type (&tmp_count, da_file, 8))\n \t    abort();\n \n \t  arcptr->arc_count = tmp_count;\n@@ -594,7 +595,8 @@ static void\n solve_program_flow_graph (bptr)\n      struct bb_info_list *bptr;\n {\n-  int passes, changes, total;\n+  int passes, changes;\n+  gcov_type total;\n   int i;\n   struct adj_list *arcptr;\n   struct bb_info *bb_graph;\n@@ -975,7 +977,7 @@ output_data ()\n   int this_file;\n   /* An array indexed by line number which indicates how many times that line\n      was executed.  */\n-  long *line_counts;\n+  gcov_type *line_counts;\n   /* An array indexed by line number which indicates whether the line was\n      present in the bb file (i.e. whether it had code associate with it).\n      Lines never executed are those which both exist, and have zero execution\n@@ -1035,7 +1037,7 @@ output_data ()\n       else\n \tsource_file_name = s_ptr->name;\n \n-      line_counts = (long *) xcalloc (sizeof (long), s_ptr->maxlineno);\n+      line_counts = (gcov_type *) xcalloc (sizeof (gcov_type), s_ptr->maxlineno);\n       line_exists = xcalloc (1, s_ptr->maxlineno);\n       if (output_branch_probs)\n \tbranch_probs = (struct arcdata **)\n@@ -1324,8 +1326,12 @@ output_data ()\n \t      if (line_exists[count])\n \t\t{\n \t\t  if (line_counts[count])\n-\t\t    fprintf (gcov_file, \"%12ld    %s\", line_counts[count],\n-\t\t\t     string);\n+\t\t    {\n+\t\t      char c[20];\n+\t\t      sprintf (c, HOST_WIDEST_INT_PRINT_DEC, (HOST_WIDEST_INT)line_counts[count]);\n+\t\t      fprintf (gcov_file, \"%12s    %s\", c,\n+\t\t\t       string);\n+\t\t    }\n \t\t  else\n \t\t    fprintf (gcov_file, \"      ######    %s\", string);\n \t\t}"}, {"sha": "f03de63c2c7349e9898bbc8c6c8a1753c73e7bde", "filename": "gcc/global.c", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2aec5c0ebe5c21cf62cc40f578ebc800ea02e7a/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2aec5c0ebe5c21cf62cc40f578ebc800ea02e7a/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=b2aec5c0ebe5c21cf62cc40f578ebc800ea02e7a", "patch": "@@ -94,9 +94,12 @@ struct allocno\n   /* Number of calls crossed by each allocno.  */\n   int calls_crossed;\n \n-  /* Number of refs (weighted) to each allocno.  */\n+  /* Number of refs to each allocno.  */\n   int n_refs;\n \n+  /* Frequency of uses of each allocno.  */\n+  int freq;\n+\n   /* Guess at live length of each allocno.\n      This is actually the max of the live lengths of the regs.  */\n   int live_length;\n@@ -215,11 +218,14 @@ static HARD_REG_SET no_global_alloc_regs;\n \n static HARD_REG_SET regs_used_so_far;\n \n-/* Number of refs (weighted) to each hard reg, as used by local alloc.\n+/* Number of refs to each hard reg, as used by local alloc.\n    It is zero for a reg that contains global pseudos or is explicitly used.  */\n \n static int local_reg_n_refs[FIRST_PSEUDO_REGISTER];\n \n+/* Frequency of uses of given hard reg.  */\n+static int local_reg_freq[FIRST_PSEUDO_REGISTER];\n+\n /* Guess at live length of each hard reg, as used by local alloc.\n    This is actually the sum of the live lengths of the specific regs.  */\n \n@@ -447,6 +453,7 @@ global_alloc (file)\n \tallocno[num].size = PSEUDO_REGNO_SIZE (i);\n \tallocno[num].calls_crossed += REG_N_CALLS_CROSSED (i);\n \tallocno[num].n_refs += REG_N_REFS (i);\n+\tallocno[num].freq += REG_FREQ (i);\n \tif (allocno[num].live_length < REG_LIVE_LENGTH (i))\n \t  allocno[num].live_length = REG_LIVE_LENGTH (i);\n       }\n@@ -456,6 +463,7 @@ global_alloc (file)\n      override it.  */\n   memset ((char *) local_reg_live_length, 0, sizeof local_reg_live_length);\n   memset ((char *) local_reg_n_refs, 0, sizeof local_reg_n_refs);\n+  memset ((char *) local_reg_freq, 0, sizeof local_reg_freq);\n   for (i = FIRST_PSEUDO_REGISTER; i < (size_t) max_regno; i++)\n     if (reg_renumber[i] >= 0)\n       {\n@@ -466,14 +474,15 @@ global_alloc (file)\n \tfor (j = regno; j < endregno; j++)\n \t  {\n \t    local_reg_n_refs[j] += REG_N_REFS (i);\n+\t    local_reg_freq[j] += REG_FREQ (i);\n \t    local_reg_live_length[j] += REG_LIVE_LENGTH (i);\n \t  }\n       }\n \n   /* We can't override local-alloc for a reg used not just by local-alloc.  */\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     if (regs_ever_live[i])\n-      local_reg_n_refs[i] = 0;\n+      local_reg_n_refs[i] = 0, local_reg_freq[i] = 0;\n \t\n   allocno_row_words = (max_allocno + INT_BITS - 1) / INT_BITS;\n \n@@ -605,11 +614,11 @@ allocno_compare (v1p, v2p)\n      times a register can occur in one insn (surely less than 100).\n      Multiplying this by 10000 can't overflow.  */\n   register int pri1\n-    = (((double) (floor_log2 (allocno[v1].n_refs) * allocno[v1].n_refs)\n+    = (((double) (floor_log2 (allocno[v1].n_refs) * allocno[v1].freq)\n \t/ allocno[v1].live_length)\n        * 10000 * allocno[v1].size);\n   register int pri2\n-    = (((double) (floor_log2 (allocno[v2].n_refs) * allocno[v2].n_refs)\n+    = (((double) (floor_log2 (allocno[v2].n_refs) * allocno[v2].freq)\n \t/ allocno[v2].live_length)\n        * 10000 * allocno[v2].size);\n   if (pri2 - pri1)\n@@ -1204,9 +1213,9 @@ find_reg (num, losers, alt_regs_p, accept_call_clobbered, retrying)\n \t\t variables so as to avoid excess precision problems that occur\n \t\t on a i386-unknown-sysv4.2 (unixware) host.  */\n \t\t \n-\t      double tmp1 = ((double) local_reg_n_refs[regno]\n+\t      double tmp1 = ((double) local_reg_freq[regno]\n \t\t\t    / local_reg_live_length[regno]);\n-\t      double tmp2 = ((double) allocno[num].n_refs\n+\t      double tmp2 = ((double) allocno[num].freq\n \t\t\t     / allocno[num].live_length);\n \n \t      if (tmp1 < tmp2)\n@@ -1256,6 +1265,7 @@ find_reg (num, losers, alt_regs_p, accept_call_clobbered, retrying)\n \t  SET_HARD_REG_BIT (regs_used_so_far, j);\n \t  /* This is no longer a reg used just by local regs.  */\n \t  local_reg_n_refs[j] = 0;\n+\t  local_reg_freq[j] = 0;\n \t}\n       /* For each other pseudo-reg conflicting with this one,\n \t mark it as conflicting with the hard regs this one occupies.  */"}, {"sha": "0c42ac6e2db2563254dd778f3cdc2232958b6c47", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2aec5c0ebe5c21cf62cc40f578ebc800ea02e7a/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2aec5c0ebe5c21cf62cc40f578ebc800ea02e7a/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=b2aec5c0ebe5c21cf62cc40f578ebc800ea02e7a", "patch": "@@ -1263,12 +1263,19 @@ __eprintf (const char *string, const char *expression,\n \n #ifdef L_bb\n \n+#if LONG_TYPE_SIZE == GCOV_TYPE_SIZE\n+typedef long gcov_type;\n+#else\n+typedef long long gcov_type;\n+#endif\n+\n+\n /* Structure emitted by -a  */\n struct bb\n {\n   long zero_word;\n   const char *filename;\n-  long *counts;\n+  gcov_type *counts;\n   long ncounts;\n   struct bb *next;\n   const unsigned long *addresses;\n@@ -1415,9 +1422,9 @@ __bb_exit_func (void)\n \n \t\t  for (i = 0; i < n_counts; i++)\n \t\t    {\n-\t\t      long v = 0;\n+\t\t      gcov_type v = 0;\n \n-\t\t      if (__read_long (&v, da_file, 8) != 0)\n+\t\t      if (__read_gcov_type (&v, da_file, 8) != 0)\n \t\t\t{\n \t\t\t  fprintf (stderr, \"arc profiling: Can't read output file %s.\\n\",\n \t\t\t\t   ptr->filename);\n@@ -1439,7 +1446,7 @@ __bb_exit_func (void)\n \t     That way we can easily verify that the proper source/executable/\n \t     data file combination is being used from gcov.  */\n \n-\t  if (__write_long (ptr->ncounts, da_file, 8) != 0)\n+\t  if (__write_gcov_type (ptr->ncounts, da_file, 8) != 0)\n \t    {\n \t      \n \t      fprintf (stderr, \"arc profiling: Error writing output file %s.\\n\",\n@@ -1448,11 +1455,11 @@ __bb_exit_func (void)\n \t  else\n \t    {\n \t      int j;\n-\t      long *count_ptr = ptr->counts;\n+\t      gcov_type *count_ptr = ptr->counts;\n \t      int ret = 0;\n \t      for (j = ptr->ncounts; j > 0; j--)\n \t\t{\n-\t\t  if (__write_long (*count_ptr, da_file, 8) != 0)\n+\t\t  if (__write_gcov_type (*count_ptr, da_file, 8) != 0)\n \t\t    {\n \t\t      ret=1;\n \t\t      break;"}, {"sha": "4424074b653519c806dee2eed7aac6af319e0a37", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2aec5c0ebe5c21cf62cc40f578ebc800ea02e7a/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2aec5c0ebe5c21cf62cc40f578ebc800ea02e7a/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=b2aec5c0ebe5c21cf62cc40f578ebc800ea02e7a", "patch": "@@ -85,6 +85,10 @@ struct qty\n \n   int n_refs;\n \n+  /* The frequency of uses of quantity Q.  */\n+\n+  int freq;\n+\n   /* Insn number (counting from head of basic block)\n      where quantity Q was born.  -1 if birth has not been recorded.  */\n \n@@ -321,6 +325,7 @@ alloc_qty (regno, mode, size, birth)\n   qty[qtyno].min_class = reg_preferred_class (regno);\n   qty[qtyno].alternate_class = reg_alternate_class (regno);\n   qty[qtyno].n_refs = REG_N_REFS (regno);\n+  qty[qtyno].freq = REG_FREQ (regno);\n   qty[qtyno].changes_mode = REG_CHANGES_MODE (regno);\n }\n \f\n@@ -1127,6 +1132,7 @@ update_equiv_regs ()\n \n \t\t  remove_death (regno, insn);\n \t\t  REG_N_REFS (regno) = 0;\n+\t\t  REG_FREQ (regno) = 0;\n \t\t  PUT_CODE (equiv_insn, NOTE);\n \t\t  NOTE_LINE_NUMBER (equiv_insn) = NOTE_INSN_DELETED;\n \t\t  NOTE_SOURCE_FILE (equiv_insn) = 0;\n@@ -1697,7 +1703,7 @@ block_alloc (b)\n    QTY_CMP_PRI is also used by qty_sugg_compare.  */\n \n #define QTY_CMP_PRI(q)\t\t\\\n-  ((int) (((double) (floor_log2 (qty[q].n_refs) * qty[q].n_refs * qty[q].size) \\\n+  ((int) (((double) (floor_log2 (qty[q].n_refs) * qty[q].freq * qty[q].size) \\\n \t  / (qty[q].death - qty[q].birth)) * 10000))\n \n static int\n@@ -1966,6 +1972,7 @@ combine_regs (usedreg, setreg, may_save_copy, insn_number, insn, already_dead)\n       /* Update info about quantity SQTY.  */\n       qty[sqty].n_calls_crossed += REG_N_CALLS_CROSSED (sreg);\n       qty[sqty].n_refs += REG_N_REFS (sreg);\n+      qty[sqty].freq += REG_FREQ (sreg);\n       if (usize < ssize)\n \t{\n \t  register int i;"}, {"sha": "37fe3c2e707b1970b742f20de33635f94f9f5701", "filename": "gcc/profile.c", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2aec5c0ebe5c21cf62cc40f578ebc800ea02e7a/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2aec5c0ebe5c21cf62cc40f578ebc800ea02e7a/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=b2aec5c0ebe5c21cf62cc40f578ebc800ea02e7a", "patch": "@@ -43,11 +43,11 @@ Boston, MA 02111-1307, USA.  */\n #include \"regs.h\"\n #include \"expr.h\"\n #include \"function.h\"\n-#include \"gcov-io.h\"\n #include \"toplev.h\"\n #include \"ggc.h\"\n #include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n+#include \"gcov-io.h\"\n \n /* Additional information about the edges we need.  */\n struct edge_info\n@@ -59,8 +59,8 @@ struct edge_info\n struct bb_info\n   {\n     unsigned int count_valid : 1;\n-    int succ_count;\n-    int pred_count;\n+    gcov_type succ_count;\n+    gcov_type pred_count;\n   };\n \n #define EDGE_INFO(e)  ((struct edge_info *) (e)->aux)\n@@ -256,20 +256,27 @@ compute_branch_probabilities ()\n \t    num_edges++;\n \t    if (da_file)\n \t      {\n-\t\tlong value;\n-\t\t__read_long (&value, da_file, 8);\n+\t\tgcov_type value;\n+\t\t__read_gcov_type (&value, da_file, 8);\n \t\te->count = value;\n \t      }\n \t    else\n \t      e->count = 0;\n \t    EDGE_INFO (e)->count_valid = 1;\n \t    BB_INFO (bb)->succ_count--;\n \t    BB_INFO (e->dest)->pred_count--;\n+\t    if (rtl_dump_file)\n+\t      {\n+\t\tfprintf (rtl_dump_file, \"\\nRead edge from %i to %i, count:\",\n+\t\t\t bb->index, e->dest->index);\n+\t\tfprintf (rtl_dump_file, HOST_WIDEST_INT_PRINT_DEC,\n+\t\t\t (HOST_WIDEST_INT) e->count);\n+\t      }\n \t  }\n     }\n \n   if (rtl_dump_file)\n-    fprintf (rtl_dump_file, \"%d edge counts read\\n\", num_edges);\n+    fprintf (rtl_dump_file, \"\\n%d edge counts read\\n\", num_edges);\n \n   /* For every block in the file,\n      - if every exit/entrance edge has a known count, then set the block count\n@@ -303,7 +310,7 @@ compute_branch_probabilities ()\n \t      if (bi->succ_count == 0)\n \t\t{\n \t\t  edge e;\n-\t\t  int total = 0;\n+\t\t  gcov_type total = 0;\n \n \t\t  for (e = bb->succ; e; e = e->succ_next)\n \t\t    total += e->count;\n@@ -314,7 +321,7 @@ compute_branch_probabilities ()\n \t      else if (bi->pred_count == 0)\n \t\t{\n \t\t  edge e;\n-\t\t  int total = 0;\n+\t\t  gcov_type total = 0;\n \n \t\t  for (e = bb->pred; e; e = e->pred_next)\n \t\t    total += e->count;\n@@ -328,7 +335,7 @@ compute_branch_probabilities ()\n \t      if (bi->succ_count == 1)\n \t\t{\n \t\t  edge e;\n-\t\t  int total = 0;\n+\t\t  gcov_type total = 0;\n \n \t\t  /* One of the counts will be invalid, but it is zero,\n \t\t     so adding it in also doesn't hurt.  */\n@@ -355,7 +362,7 @@ compute_branch_probabilities ()\n \t      if (bi->pred_count == 1)\n \t\t{\n \t\t  edge e;\n-\t\t  int total = 0;\n+\t\t  gcov_type total = 0;\n \n \t\t  /* One of the counts will be invalid, but it is zero,\n \t\t     so adding it in also doesn't hurt.  */\n@@ -411,7 +418,7 @@ compute_branch_probabilities ()\n       basic_block bb = BASIC_BLOCK (i);\n       edge e;\n       rtx insn;\n-      int total;\n+      gcov_type total;\n       rtx note;\n \n       total = bb->count;\n@@ -1036,14 +1043,14 @@ static rtx\n gen_edge_profiler (edgeno)\n      int edgeno;\n {\n-  enum machine_mode mode = mode_for_size (LONG_TYPE_SIZE, MODE_INT, 0);\n+  enum machine_mode mode = mode_for_size (GCOV_TYPE_SIZE, MODE_INT, 0);\n   rtx mem_ref, tmp;\n   rtx sequence;\n \n   start_sequence ();\n \n   tmp = force_reg (Pmode, profiler_label);\n-  tmp = plus_constant (tmp, LONG_TYPE_SIZE / BITS_PER_UNIT * edgeno);\n+  tmp = plus_constant (tmp, GCOV_TYPE_SIZE / BITS_PER_UNIT * edgeno);\n   mem_ref = validize_mem (gen_rtx_MEM (mode, tmp));\n \n   tmp = expand_binop (mode, add_optab, mem_ref, const1_rtx,\n@@ -1068,7 +1075,7 @@ output_func_start_profiler ()\n   char buf[20];\n   const char *cfnname;\n   rtx table_address;\n-  enum machine_mode mode = mode_for_size (LONG_TYPE_SIZE, MODE_INT, 0);\n+  enum machine_mode mode = mode_for_size (GCOV_TYPE_SIZE, MODE_INT, 0);\n   int save_flag_inline_functions = flag_inline_functions;\n   int save_flag_test_coverage = flag_test_coverage;\n   int save_profile_arc_flag = profile_arc_flag;"}, {"sha": "35f0e09fb02e3a68d0184267bea8d46188580544", "filename": "gcc/regclass.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2aec5c0ebe5c21cf62cc40f578ebc800ea02e7a/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2aec5c0ebe5c21cf62cc40f578ebc800ea02e7a/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=b2aec5c0ebe5c21cf62cc40f578ebc800ea02e7a", "patch": "@@ -1059,14 +1059,17 @@ scan_one_insn (insn, pass)\n       /* This makes one more setting of new insns's dest.  */\n       REG_N_SETS (REGNO (recog_data.operand[0]))++;\n       REG_N_REFS (REGNO (recog_data.operand[0]))++;\n+      REG_FREQ (REGNO (recog_data.operand[0])) += loop_cost;\n \n       *recog_data.operand_loc[1] = recog_data.operand[0];\n       REG_N_REFS (REGNO (recog_data.operand[0]))++;\n+      REG_FREQ (REGNO (recog_data.operand[0])) += loop_cost;\n       for (i = recog_data.n_dups - 1; i >= 0; i--)\n \tif (recog_data.dup_num[i] == 1)\n \t  {\n \t    *recog_data.dup_loc[i] = recog_data.operand[0];\n \t    REG_N_REFS (REGNO (recog_data.operand[0]))++;\n+\t    REG_FREQ (REGNO (recog_data.operand[0])) += loop_cost;\n \t  }\n \n       return PREV_INSN (newinsn);"}, {"sha": "3857c829dc1dbc489c6f5d611eeb0f6d528d876d", "filename": "gcc/regs.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2aec5c0ebe5c21cf62cc40f578ebc800ea02e7a/gcc%2Fregs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2aec5c0ebe5c21cf62cc40f578ebc800ea02e7a/gcc%2Fregs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregs.h?ref=b2aec5c0ebe5c21cf62cc40f578ebc800ea02e7a", "patch": "@@ -67,6 +67,7 @@ typedef struct reg_info_def\n \n \t\t\t\t/* fields set by flow_analysis */\n   int refs;\t\t\t/* # of times (REG n) is used or set */\n+  int freq;\t\t\t/* # estimated frequency (REG n) is used or set */\n   int deaths;\t\t\t/* # of times (REG n) dies */\n   int live_length;\t\t/* # of instructions (REG n) is live */\n   int calls_crossed;\t\t/* # of calls (REG n) is live across */\n@@ -77,11 +78,14 @@ typedef struct reg_info_def\n \n extern varray_type reg_n_info;\n \n-/* Indexed by n, gives number of times (REG n) is used or set.\n-   References within loops may be counted more times.  */\n+/* Indexed by n, gives number of times (REG n) is used or set.  */\n \n #define REG_N_REFS(N) (VARRAY_REG (reg_n_info, N)->refs)\n \n+/* Estimate frequency of references to register N.  */\n+\n+#define REG_FREQ(N) (VARRAY_REG (reg_n_info, N)->freq)\n+\n /* Indexed by n, gives number of times (REG n) is set.\n    ??? both regscan and flow allocate space for this.  We should settle\n    on just copy.  */"}, {"sha": "7a587a72111552a20448d6452edb37436287f39b", "filename": "gcc/reload1.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2aec5c0ebe5c21cf62cc40f578ebc800ea02e7a/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2aec5c0ebe5c21cf62cc40f578ebc800ea02e7a/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=b2aec5c0ebe5c21cf62cc40f578ebc800ea02e7a", "patch": "@@ -1567,7 +1567,7 @@ static void\n count_pseudo (reg)\n      int reg;\n {\n-  int n_refs = REG_N_REFS (reg);\n+  int freq = REG_FREQ (reg);\n   int r = reg_renumber[reg];\n   int nregs;\n \n@@ -1580,11 +1580,11 @@ count_pseudo (reg)\n   if (r < 0)\n     abort ();\n \n-  spill_add_cost[r] += n_refs;\n+  spill_add_cost[r] += freq;\n \n   nregs = HARD_REGNO_NREGS (r, PSEUDO_REGNO_MODE (reg));\n   while (nregs-- > 0)\n-    spill_cost[r + nregs] += n_refs;\n+    spill_cost[r + nregs] += freq;\n }\n \n /* Calculate the SPILL_COST and SPILL_ADD_COST arrays and determine the\n@@ -1654,9 +1654,9 @@ count_spilled_pseudo (spilled, spilled_nregs, reg)\n \n   SET_REGNO_REG_SET (&spilled_pseudos, reg);\n \n-  spill_add_cost[r] -= REG_N_REFS (reg);\n+  spill_add_cost[r] -= REG_FREQ (reg);\n   while (nregs-- > 0)\n-    spill_cost[r + nregs] -= REG_N_REFS (reg);\n+    spill_cost[r + nregs] -= REG_FREQ (reg);\n }\n \n /* Find reload register to use for reload number ORDER.  */"}]}