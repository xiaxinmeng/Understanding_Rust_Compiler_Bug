{"sha": "d8bf17f9d631136c88cbfd35203a4cd3e64b6fc7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDhiZjE3ZjlkNjMxMTM2Yzg4Y2JmZDM1MjAzYTRjZDNlNjRiNmZjNw==", "commit": {"author": {"name": "Lars Brinkhoff", "email": "lars@nocrew.org", "date": "2002-03-22T20:15:08Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-03-22T20:15:08Z"}, "message": "i386.c, i386.md: Change all occurences of GEN_INT (trunc_int_for_mode (...)) to gen_int_mode (...).\n\n        * config/i386/i386.c, config/i386/i386.md: Change all occurences\n        of GEN_INT (trunc_int_for_mode (...)) to gen_int_mode (...).\n\nFrom-SVN: r51186", "tree": {"sha": "6a296b0a73dceabeb213d0ac8c5ff4ce620ef6cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6a296b0a73dceabeb213d0ac8c5ff4ce620ef6cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d8bf17f9d631136c88cbfd35203a4cd3e64b6fc7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8bf17f9d631136c88cbfd35203a4cd3e64b6fc7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8bf17f9d631136c88cbfd35203a4cd3e64b6fc7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8bf17f9d631136c88cbfd35203a4cd3e64b6fc7/comments", "author": {"login": "larsbrinkhoff", "id": 775050, "node_id": "MDQ6VXNlcjc3NTA1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/775050?v=4", "gravatar_id": "", "url": "https://api.github.com/users/larsbrinkhoff", "html_url": "https://github.com/larsbrinkhoff", "followers_url": "https://api.github.com/users/larsbrinkhoff/followers", "following_url": "https://api.github.com/users/larsbrinkhoff/following{/other_user}", "gists_url": "https://api.github.com/users/larsbrinkhoff/gists{/gist_id}", "starred_url": "https://api.github.com/users/larsbrinkhoff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/larsbrinkhoff/subscriptions", "organizations_url": "https://api.github.com/users/larsbrinkhoff/orgs", "repos_url": "https://api.github.com/users/larsbrinkhoff/repos", "events_url": "https://api.github.com/users/larsbrinkhoff/events{/privacy}", "received_events_url": "https://api.github.com/users/larsbrinkhoff/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2ca08953848815c505cc930f1127564f0ed60056", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ca08953848815c505cc930f1127564f0ed60056", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ca08953848815c505cc930f1127564f0ed60056"}], "stats": {"total": 88, "additions": 41, "deletions": 47}, "files": [{"sha": "c2e75f152270e7192ded3adc9e9009c416603a5c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8bf17f9d631136c88cbfd35203a4cd3e64b6fc7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8bf17f9d631136c88cbfd35203a4cd3e64b6fc7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d8bf17f9d631136c88cbfd35203a4cd3e64b6fc7", "patch": "@@ -1,3 +1,8 @@\n+2002-03-22  Lars Brinkhoff  <lars@nocrew.org>\n+\n+\t* config/i386/i386.c, config/i386/i386.md: Change all occurences\n+\tof GEN_INT (trunc_int_for_mode (...)) to gen_int_mode (...).\n+\n 2002-03-22  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* flow.c (calculate_global_regs_live): Clear aux fields of"}, {"sha": "02bdc9888f44fea886d536a6108ccc2ba9ec3cf9", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8bf17f9d631136c88cbfd35203a4cd3e64b6fc7/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8bf17f9d631136c88cbfd35203a4cd3e64b6fc7/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=d8bf17f9d631136c88cbfd35203a4cd3e64b6fc7", "patch": "@@ -8060,8 +8060,7 @@ ix86_expand_int_movcc (operands)\n \t       */\n \t      tmp = expand_simple_binop (mode, AND,\n \t\t\t\t\t tmp,\n-\t\t\t\t\t GEN_INT (trunc_int_for_mode\n-\t\t\t\t\t\t  (cf - ct, mode)),\n+\t\t\t\t\t gen_int_mode (cf - ct, mode),\n \t\t\t\t\t tmp, 1, OPTAB_DIRECT);\n \t      if (ct)\n \t       \ttmp = expand_simple_binop (mode, PLUS,\n@@ -8211,8 +8210,7 @@ ix86_expand_int_movcc (operands)\n \t\t\t\t     out, 1, OPTAB_DIRECT);\n \t  out = expand_simple_binop (mode, AND,\n \t\t\t\t     out,\n-\t\t\t\t     GEN_INT (trunc_int_for_mode\n-\t\t\t\t\t      (cf - ct, mode)),\n+\t\t\t\t     gen_int_mode (cf - ct, mode),\n \t\t\t\t     out, 1, OPTAB_DIRECT);\n \t  out = expand_simple_binop (mode, PLUS,\n \t\t\t\t     out, GEN_INT (ct),\n@@ -8559,16 +8557,16 @@ ix86_split_to_parts (operand, parts, mode)\n \t\tcase XFmode:\n \t\tcase TFmode:\n \t\t  REAL_VALUE_TO_TARGET_LONG_DOUBLE (r, l);\n-\t\t  parts[2] = GEN_INT (trunc_int_for_mode (l[2], SImode));\n+\t\t  parts[2] = gen_int_mode (l[2], SImode);\n \t\t  break;\n \t\tcase DFmode:\n \t\t  REAL_VALUE_TO_TARGET_DOUBLE (r, l);\n \t\t  break;\n \t\tdefault:\n \t\t  abort ();\n \t\t}\n-\t      parts[1] = GEN_INT (trunc_int_for_mode (l[1], SImode));\n-\t      parts[0] = GEN_INT (trunc_int_for_mode (l[0], SImode));\n+\t      parts[1] = gen_int_mode (l[1], SImode);\n+\t      parts[0] = gen_int_mode (l[0], SImode);\n \t    }\n \t  else\n \t    abort ();\n@@ -8603,13 +8601,13 @@ ix86_split_to_parts (operand, parts, mode)\n \t      /* Do not use shift by 32 to avoid warning on 32bit systems.  */\n \t      if (HOST_BITS_PER_WIDE_INT >= 64)\n \t        parts[0]\n-\t\t  = GEN_INT (trunc_int_for_mode\n+\t\t  = gen_int_mode\n \t\t      ((l[0] & (((HOST_WIDE_INT) 2 << 31) - 1))\n \t\t       + ((((HOST_WIDE_INT) l[1]) << 31) << 1),\n-\t\t       DImode));\n+\t\t       DImode);\n \t      else\n \t        parts[0] = immed_double_const (l[0], l[1], DImode);\n-\t      parts[1] = GEN_INT (trunc_int_for_mode (l[2], SImode));\n+\t      parts[1] = gen_int_mode (l[2], SImode);\n \t    }\n \t  else\n \t    abort ();\n@@ -9632,8 +9630,7 @@ ix86_expand_strlensi_unroll_1 (out, align_rtx)\n   emit_insn (gen_one_cmplsi2 (scratch, scratch));\n   emit_insn (gen_andsi3 (tmpreg, tmpreg, scratch));\n   emit_insn (gen_andsi3 (tmpreg, tmpreg,\n-\t\t\t GEN_INT (trunc_int_for_mode\n-\t\t\t\t  (0x80808080, SImode))));\n+\t\t\t gen_int_mode (0x80808080, SImode)));\n   emit_cmp_and_jump_insns (tmpreg, const0_rtx, EQ, 0, SImode, 1,\n \t\t\t   align_4_label);\n \n@@ -10752,10 +10749,10 @@ x86_initialize_trampoline (tramp, fnaddr, cxt)\n \t\t\t       plus_constant (tramp, 10),\n \t\t\t       NULL_RTX, 1, OPTAB_DIRECT);\n       emit_move_insn (gen_rtx_MEM (QImode, tramp),\n-\t\t      GEN_INT (trunc_int_for_mode (0xb9, QImode)));\n+\t\t      gen_int_mode (0xb9, QImode));\n       emit_move_insn (gen_rtx_MEM (SImode, plus_constant (tramp, 1)), cxt);\n       emit_move_insn (gen_rtx_MEM (QImode, plus_constant (tramp, 5)),\n-\t\t      GEN_INT (trunc_int_for_mode (0xe9, QImode)));\n+\t\t      gen_int_mode (0xe9, QImode));\n       emit_move_insn (gen_rtx_MEM (SImode, plus_constant (tramp, 6)), disp);\n     }\n   else\n@@ -10768,30 +10765,30 @@ x86_initialize_trampoline (tramp, fnaddr, cxt)\n \t{\n \t  fnaddr = copy_to_mode_reg (DImode, fnaddr);\n \t  emit_move_insn (gen_rtx_MEM (HImode, plus_constant (tramp, offset)),\n-\t\t\t  GEN_INT (trunc_int_for_mode (0xbb41, HImode)));\n+\t\t\t  gen_int_mode (0xbb41, HImode));\n \t  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (tramp, offset + 2)),\n \t\t\t  gen_lowpart (SImode, fnaddr));\n \t  offset += 6;\n \t}\n       else\n \t{\n \t  emit_move_insn (gen_rtx_MEM (HImode, plus_constant (tramp, offset)),\n-\t\t\t  GEN_INT (trunc_int_for_mode (0xbb49, HImode)));\n+\t\t\t  gen_int_mode (0xbb49, HImode));\n \t  emit_move_insn (gen_rtx_MEM (DImode, plus_constant (tramp, offset + 2)),\n \t\t\t  fnaddr);\n \t  offset += 10;\n \t}\n       /* Load static chain using movabs to r10.  */\n       emit_move_insn (gen_rtx_MEM (HImode, plus_constant (tramp, offset)),\n-\t\t      GEN_INT (trunc_int_for_mode (0xba49, HImode)));\n+\t\t      gen_int_mode (0xba49, HImode));\n       emit_move_insn (gen_rtx_MEM (DImode, plus_constant (tramp, offset + 2)),\n \t\t      cxt);\n       offset += 10;\n       /* Jump to the r11 */\n       emit_move_insn (gen_rtx_MEM (HImode, plus_constant (tramp, offset)),\n-\t\t      GEN_INT (trunc_int_for_mode (0xff49, HImode)));\n+\t\t      gen_int_mode (0xff49, HImode));\n       emit_move_insn (gen_rtx_MEM (QImode, plus_constant (tramp, offset+2)),\n-\t\t      GEN_INT (trunc_int_for_mode (0xe3, QImode)));\n+\t\t      gen_int_mode (0xe3, QImode));\n       offset += 3;\n       if (offset > TRAMPOLINE_SIZE)\n \tabort ();"}, {"sha": "27a352df48656b2bb4c0092a5402e3b14bd355d9", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 20, "deletions": 28, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8bf17f9d631136c88cbfd35203a4cd3e64b6fc7/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8bf17f9d631136c88cbfd35203a4cd3e64b6fc7/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=d8bf17f9d631136c88cbfd35203a4cd3e64b6fc7", "patch": "@@ -8307,8 +8307,7 @@\n   mask  = ((HOST_WIDE_INT)1 << (pos + len)) - 1;\n   mask &= ~(((HOST_WIDE_INT)1 << pos) - 1);\n \n-  operands[3] = gen_rtx_AND (mode, operands[0],\n-\t\t\t     GEN_INT (trunc_int_for_mode (mask, mode)));\n+  operands[3] = gen_rtx_AND (mode, operands[0], gen_int_mode (mask, mode));\n })\n \n ;; %%% This used to optimize known byte-wide and operations to memory,\n@@ -9507,8 +9506,7 @@\n \t  operands[0] = force_reg (SFmode, operands[0]);\n \t  emit_move_insn (reg,\n \t\t\t  gen_lowpart (SFmode,\n-\t\t\t\t       GEN_INT (trunc_int_for_mode (0x80000000,\n-\t\t\t\t\t\t\t            SImode))));\n+\t\t\t\t       gen_int_mode (0x80000000, SImode)));\n \t  emit_insn (gen_negsf2_ifs (operands[0], operands[1], reg));\n \t  if (dest != operands[0])\n \t    emit_move_insn (dest, operands[0]);\n@@ -9602,7 +9600,7 @@\n   \"TARGET_80387 && reload_completed && !FP_REGNO_P (REGNO (operands[0]))\"\n   [(parallel [(set (match_dup 0) (xor:SI (match_dup 0) (match_dup 1)))\n \t      (clobber (reg:CC 17))])]\n-  \"operands[1] = GEN_INT (trunc_int_for_mode (0x80000000, SImode));\n+  \"operands[1] = gen_int_mode (0x80000000, SImode);\n    operands[0] = gen_rtx_REG (SImode, REGNO (operands[0]));\")\n \n (define_split\n@@ -9619,7 +9617,7 @@\n   if (size >= 12)\n     size = 10;\n   operands[0] = adjust_address (operands[0], QImode, size - 1);\n-  operands[1] = GEN_INT (trunc_int_for_mode (0x80, QImode));\n+  operands[1] = gen_int_mode (0x80, QImode);\n })\n \n (define_expand \"negdf2\"\n@@ -9639,8 +9637,7 @@\n \t     in register.  */\n \t  rtx reg = gen_reg_rtx (DFmode);\n #if HOST_BITS_PER_WIDE_INT >= 64\n-\t  rtx imm = GEN_INT (trunc_int_for_mode(((HOST_WIDE_INT)1) << 63,\n-\t\t\t\t\t        DImode));\n+\t  rtx imm = gen_int_mode (((HOST_WIDE_INT)1) << 63, DImode);\n #else\n \t  rtx imm = immed_double_const (0, 0x80000000, DImode);\n #endif\n@@ -9779,7 +9776,7 @@\n    && !FP_REGNO_P (REGNO (operands[0]))\"\n   [(parallel [(set (match_dup 3) (xor:SI (match_dup 3) (match_dup 4)))\n \t      (clobber (reg:CC 17))])]\n-  \"operands[4] = GEN_INT (trunc_int_for_mode (0x80000000, SImode));\n+  \"operands[4] = gen_int_mode (0x80000000, SImode);\n    split_di (operands+0, 1, operands+2, operands+3);\")\n \n (define_expand \"negxf2\"\n@@ -9970,8 +9967,7 @@\n \t  operands[0] = force_reg (SFmode, operands[0]);\n \t  emit_move_insn (reg,\n \t\t\t  gen_lowpart (SFmode,\n-\t\t\t\t       GEN_INT (trunc_int_for_mode (0x80000000,\n-\t\t\t\t\t\t\t            SImode))));\n+\t\t\t\t       gen_int_mode (0x80000000, SImode)));\n \t  emit_insn (gen_abssf2_ifs (operands[0], operands[1], reg));\n \t  if (dest != operands[0])\n \t    emit_move_insn (dest, operands[0]);\n@@ -10054,7 +10050,7 @@\n   \"TARGET_80387 && reload_completed && !FP_REGNO_P (REGNO (operands[0]))\"\n   [(parallel [(set (match_dup 0) (and:SI (match_dup 0) (match_dup 1)))\n \t      (clobber (reg:CC 17))])]\n-  \"operands[1] = GEN_INT (trunc_int_for_mode (~0x80000000, SImode));\n+  \"operands[1] = gen_int_mode (~0x80000000, SImode);\n    operands[0] = gen_rtx_REG (SImode, REGNO (operands[0]));\")\n \n (define_split\n@@ -10071,7 +10067,7 @@\n   if (size >= 12)\n     size = 10;\n   operands[0] = adjust_address (operands[0], QImode, size - 1);\n-  operands[1] = GEN_INT (trunc_int_for_mode (~0x80, QImode));\n+  operands[1] = gen_int_mode (~0x80, QImode);\n })\n \n (define_expand \"absdf2\"\n@@ -10091,8 +10087,7 @@\n \t     in register.  */\n \t  rtx reg = gen_reg_rtx (DFmode);\n #if HOST_BITS_PER_WIDE_INT >= 64\n-\t  rtx imm = GEN_INT (trunc_int_for_mode(((HOST_WIDE_INT)1) << 63,\n-\t\t\t\t\t        DImode));\n+\t  rtx imm = gen_int_mode (((HOST_WIDE_INT)1) << 63, DImode);\n #else\n \t  rtx imm = immed_double_const (0, 0x80000000, DImode);\n #endif\n@@ -10209,7 +10204,7 @@\n    !FP_REGNO_P (REGNO (operands[0]))\"\n   [(parallel [(set (match_dup 3) (and:SI (match_dup 3) (match_dup 4)))\n \t      (clobber (reg:CC 17))])]\n-  \"operands[4] = GEN_INT (trunc_int_for_mode (~0x80000000, SImode));\n+  \"operands[4] = gen_int_mode (~0x80000000, SImode);\n    split_di (operands+0, 1, operands+2, operands+3);\")\n \n (define_expand \"absxf2\"\n@@ -10660,8 +10655,7 @@\n   [(set (match_dup 0)\n \t(mult:DI (match_dup 1)\n \t\t (match_dup 2)))]\n-  \"operands[2] = GEN_INT (trunc_int_for_mode (1 << INTVAL (operands[2]),\n-\t\t\t\t\t      DImode));\")\n+  \"operands[2] = gen_int_mode (1 << INTVAL (operands[2]), DImode);\")\n \n ;; This pattern can't accept a variable shift count, since shifts by\n ;; zero don't affect the flags.  We assume that shifts by constant\n@@ -10868,8 +10862,7 @@\n   rtx pat;\n   operands[0] = gen_lowpart (SImode, operands[0]);\n   operands[1] = gen_lowpart (Pmode, operands[1]);\n-  operands[2] = GEN_INT (trunc_int_for_mode (1 << INTVAL (operands[2]),\n-\t\t\t\t\t     Pmode));\n+  operands[2] = gen_int_mode (1 << INTVAL (operands[2]), Pmode);\n   pat = gen_rtx_MULT (Pmode, operands[1], operands[2]);\n   if (Pmode != SImode)\n     pat = gen_rtx_SUBREG (SImode, pat, 0);\n@@ -10927,8 +10920,7 @@\n   [(set (match_dup 0) (zero_extend:DI (subreg:SI (mult:SI (match_dup 1) (match_dup 2)) 0)))]\n {\n   operands[1] = gen_lowpart (Pmode, operands[1]);\n-  operands[2] = GEN_INT (trunc_int_for_mode (1 << INTVAL (operands[2]),\n-\t\t\t\t\t     Pmode));\n+  operands[2] = gen_int_mode (1 << INTVAL (operands[2]), Pmode);\n })\n \n ;; This pattern can't accept a variable shift count, since shifts by\n@@ -16863,9 +16855,9 @@\n \t      (set (match_dup 0)\n \t\t   (and:SI (match_dup 1) (match_dup 2)))])]\n   \"operands[2]\n-     = GEN_INT (trunc_int_for_mode (INTVAL (operands[2])\n-\t\t\t\t    & GET_MODE_MASK (GET_MODE (operands[0])),\n-\t\t\t\t    SImode));\n+     = gen_int_mode (INTVAL (operands[2])\n+\t\t     & GET_MODE_MASK (GET_MODE (operands[0])),\n+\t\t     SImode);\n    operands[0] = gen_lowpart (SImode, operands[0]);\n    operands[1] = gen_lowpart (SImode, operands[1]);\")\n \n@@ -16883,9 +16875,9 @@\n \t(compare:CCNO (and:SI (match_dup 0) (match_dup 1))\n \t\t      (const_int 0)))]\n   \"operands[1]\n-     = GEN_INT (trunc_int_for_mode (INTVAL (operands[1])\n-\t\t\t\t    & GET_MODE_MASK (GET_MODE (operands[0])),\n-\t\t\t\t    SImode));\n+     = gen_int_mode (INTVAL (operands[1])\n+\t\t     & GET_MODE_MASK (GET_MODE (operands[0])),\n+\t\t     SImode);\n    operands[0] = gen_lowpart (SImode, operands[0]);\")\n \n (define_split"}]}