{"sha": "713f41f9b3bcb0153943f22989026727d39817ce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzEzZjQxZjliM2JjYjAxNTM5NDNmMjI5ODkwMjY3MjdkMzk4MTdjZQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.com", "date": "2001-01-03T15:00:31Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2001-01-03T15:00:31Z"}, "message": "Improve alias analysis for ia64\n\nFrom-SVN: r38660", "tree": {"sha": "5e80d5382067671928972e5a252296864e7664ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e80d5382067671928972e5a252296864e7664ee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/713f41f9b3bcb0153943f22989026727d39817ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/713f41f9b3bcb0153943f22989026727d39817ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/713f41f9b3bcb0153943f22989026727d39817ce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/713f41f9b3bcb0153943f22989026727d39817ce/comments", "author": null, "committer": null, "parents": [{"sha": "03378143aca4cb4276e6fb1d2f790ea58bdcaa86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03378143aca4cb4276e6fb1d2f790ea58bdcaa86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03378143aca4cb4276e6fb1d2f790ea58bdcaa86"}], "stats": {"total": 104, "additions": 78, "deletions": 26}, "files": [{"sha": "669c9e1b5213de9107f60a16affba1c9dc2e26f1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713f41f9b3bcb0153943f22989026727d39817ce/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713f41f9b3bcb0153943f22989026727d39817ce/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=713f41f9b3bcb0153943f22989026727d39817ce", "patch": "@@ -16,6 +16,12 @@ Wed Jan  3 08:53:50 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t* cse.c (cse_rtx_varies_p): Accept additional FROM_ALIAS arg.  All\n \tcallers changed.\n \n+\t* alias.c (throughout): Use ORIGINAL_REGNO when accessing\n+\treg_base_value and reg_known_value arrays.\n+\t(init_alias_analysis): Add more cases to detect known values.\n+\t* sched-deps.c (deps_may_trap_p): New function.\n+\t(sched_analyze_2): Use it.\n+\n 2001-01-03  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* combine.c (simplify_shift_const): Even if we're sign-extracting,"}, {"sha": "4f9eef3cfa686c4adaf0f4b580f1bd77c04def96", "filename": "gcc/alias.c", "status": "modified", "additions": 53, "deletions": 25, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713f41f9b3bcb0153943f22989026727d39817ce/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713f41f9b3bcb0153943f22989026727d39817ce/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=713f41f9b3bcb0153943f22989026727d39817ce", "patch": "@@ -148,7 +148,8 @@ static rtx *new_reg_base_value;\n static unsigned int reg_base_value_size; /* size of reg_base_value array */\n \n #define REG_BASE_VALUE(X) \\\n-  (REGNO (X) < reg_base_value_size ? reg_base_value[REGNO (X)] : 0)\n+  (ORIGINAL_REGNO (X) < reg_base_value_size \\\n+   ? reg_base_value[ORIGINAL_REGNO (X)] : 0)\n \n /* Vector of known invariant relationships between registers.  Set in\n    loop unrolling.  Indexed by register number, if nonzero the value\n@@ -659,30 +660,32 @@ static rtx\n find_base_value (src)\n      register rtx src;\n {\n+  unsigned int regno;\n   switch (GET_CODE (src))\n     {\n     case SYMBOL_REF:\n     case LABEL_REF:\n       return src;\n \n     case REG:\n+      regno = ORIGINAL_REGNO (src);\n       /* At the start of a function, argument registers have known base\n \t values which may be lost later.  Returning an ADDRESS\n \t expression here allows optimization based on argument values\n \t even when the argument registers are used for other purposes.  */\n-      if (REGNO (src) < FIRST_PSEUDO_REGISTER && copying_arguments)\n-\treturn new_reg_base_value[REGNO (src)];\n+      if (regno < FIRST_PSEUDO_REGISTER && copying_arguments)\n+\treturn new_reg_base_value[regno];\n \n       /* If a pseudo has a known base value, return it.  Do not do this\n \t for hard regs since it can result in a circular dependency\n \t chain for registers which have values at function entry.\n \n \t The test above is not sufficient because the scheduler may move\n \t a copy out of an arg reg past the NOTE_INSN_FUNCTION_BEGIN.  */\n-      if (REGNO (src) >= FIRST_PSEUDO_REGISTER\n-\t  && (unsigned) REGNO (src) < reg_base_value_size\n-\t  && reg_base_value[REGNO (src)])\n-\treturn reg_base_value[REGNO (src)];\n+      if (regno >= FIRST_PSEUDO_REGISTER\n+\t  && regno < reg_base_value_size\n+\t  && reg_base_value[regno])\n+\treturn reg_base_value[regno];\n \n       return src;\n \n@@ -789,7 +792,7 @@ record_set (dest, set, data)\n   if (GET_CODE (dest) != REG)\n     return;\n \n-  regno = REGNO (dest);\n+  regno = ORIGINAL_REGNO (dest);\n \n   if (regno >= reg_base_value_size)\n     abort ();\n@@ -870,8 +873,8 @@ record_base_value (regno, val, invariant)\n \n   if (GET_CODE (val) == REG)\n     {\n-      if (REGNO (val) < reg_base_value_size)\n-\treg_base_value[regno] = reg_base_value[REGNO (val)];\n+      if (ORIGINAL_REGNO (val) < reg_base_value_size)\n+\treg_base_value[regno] = reg_base_value[ORIGINAL_REGNO (val)];\n \n       return;\n     }\n@@ -889,10 +892,10 @@ canon_rtx (x)\n      rtx x;\n {\n   /* Recursively look for equivalences.  */\n-  if (GET_CODE (x) == REG && REGNO (x) >= FIRST_PSEUDO_REGISTER\n-      && REGNO (x) < reg_known_value_size)\n-    return reg_known_value[REGNO (x)] == x\n-      ? x : canon_rtx (reg_known_value[REGNO (x)]);\n+  if (GET_CODE (x) == REG && ORIGINAL_REGNO (x) >= FIRST_PSEUDO_REGISTER\n+      && ORIGINAL_REGNO (x) < reg_known_value_size)\n+    return reg_known_value[ORIGINAL_REGNO (x)] == x\n+      ? x : canon_rtx (reg_known_value[ORIGINAL_REGNO (x)]);\n   else if (GET_CODE (x) == PLUS)\n     {\n       rtx x0 = canon_rtx (XEXP (x, 0));\n@@ -2208,17 +2211,42 @@ init_alias_analysis ()\n \n \t      if (set != 0\n \t\t  && GET_CODE (SET_DEST (set)) == REG\n-\t\t  && REGNO (SET_DEST (set)) >= FIRST_PSEUDO_REGISTER\n-\t\t  && REG_NOTES (insn) != 0\n-\t\t  && (((note = find_reg_note (insn, REG_EQUAL, 0)) != 0\n-\t\t       && REG_N_SETS (REGNO (SET_DEST (set))) == 1)\n-\t\t      || (note = find_reg_note (insn, REG_EQUIV, NULL_RTX)) != 0)\n-\t\t  && GET_CODE (XEXP (note, 0)) != EXPR_LIST\n-\t\t  && ! reg_overlap_mentioned_p (SET_DEST (set), XEXP (note, 0)))\n+\t\t  && ORIGINAL_REGNO (SET_DEST (set)) >= FIRST_PSEUDO_REGISTER)\n \t\t{\n-\t\t  int regno = REGNO (SET_DEST (set));\n-\t\t  reg_known_value[regno] = XEXP (note, 0);\n-\t\t  reg_known_equiv_p[regno] = REG_NOTE_KIND (note) == REG_EQUIV;\n+\t\t  unsigned int regno = ORIGINAL_REGNO (SET_DEST (set));\n+\t\t  rtx src = SET_SRC (set);\n+\n+\t\t  if (REG_NOTES (insn) != 0\n+\t\t      && (((note = find_reg_note (insn, REG_EQUAL, 0)) != 0\n+\t\t\t   && REG_N_SETS (regno) == 1)\n+\t\t\t  || (note = find_reg_note (insn, REG_EQUIV, NULL_RTX)) != 0)\n+\t\t      && GET_CODE (XEXP (note, 0)) != EXPR_LIST\n+\t\t      && ! reg_overlap_mentioned_p (SET_DEST (set), XEXP (note, 0)))\n+\t\t    {\n+\t\t      reg_known_value[regno] = XEXP (note, 0);\n+\t\t      reg_known_equiv_p[regno] = REG_NOTE_KIND (note) == REG_EQUIV;\n+\t\t    }\n+\t\t  else if (REG_N_SETS (regno) == 1\n+\t\t\t   && GET_CODE (src) == PLUS\n+\t\t\t   && GET_CODE (XEXP (src, 0)) == REG\n+\t\t\t   && ORIGINAL_REGNO (XEXP (src, 0)) >= FIRST_PSEUDO_REGISTER\n+\t\t\t   && (reg_known_value[ORIGINAL_REGNO (XEXP (src, 0))])\n+\t\t\t   && GET_CODE (XEXP (src, 1)) == CONST_INT)\n+\t\t    {\n+\t\t      rtx op0 = XEXP (src, 0);\n+\t\t      if (reg_known_value[ORIGINAL_REGNO (op0)])\n+\t\t\top0 = reg_known_value[ORIGINAL_REGNO (op0)];\n+\t\t      reg_known_value[regno]\n+\t\t\t= plus_constant_for_output (op0,\n+\t\t\t\t\t\t    INTVAL (XEXP (src, 1)));\n+\t\t      reg_known_equiv_p[regno] = 0;\n+\t\t    }\n+\t\t  else if (REG_N_SETS (regno) == 1\n+\t\t\t   && ! rtx_varies_p (src, 1))\n+\t\t    {\n+\t\t      reg_known_value[regno] = src;\n+\t\t      reg_known_equiv_p[regno] = 0;\n+\t\t    }\n \t\t}\n \t    }\n \t  else if (GET_CODE (insn) == NOTE\n@@ -2265,7 +2293,7 @@ init_alias_analysis ()\n \t  rtx base = reg_base_value[ui];\n \t  if (base && GET_CODE (base) == REG)\n \t    {\n-\t      unsigned int base_regno = REGNO (base);\n+\t      unsigned int base_regno = ORIGINAL_REGNO (base);\n \t      if (base_regno == ui)\t\t/* register set from itself */\n \t\treg_base_value[ui] = 0;\n \t      else"}, {"sha": "750285e38d8abe0dae77547e394c5381cadf0406", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713f41f9b3bcb0153943f22989026727d39817ce/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713f41f9b3bcb0153943f22989026727d39817ce/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=713f41f9b3bcb0153943f22989026727d39817ce", "patch": "@@ -74,6 +74,7 @@ static sbitmap *output_dependency_cache;\n static sbitmap *forward_dependency_cache;\n #endif\n \n+static int deps_may_trap_p PARAMS ((rtx));\n static void remove_dependence PARAMS ((rtx, rtx));\n static void set_sched_group_p PARAMS ((rtx));\n \n@@ -86,6 +87,21 @@ static rtx group_leader PARAMS ((rtx));\n static rtx get_condition PARAMS ((rtx));\n static int conditions_mutex_p PARAMS ((rtx, rtx));\n \f\n+/* Return nonzero if a load of the memory reference MEM can cause a trap.  */\n+\n+static int\n+deps_may_trap_p (mem)\n+     rtx mem;\n+{\n+  rtx addr = XEXP (mem, 0);\n+\n+  if (REG_P (addr)\n+      && ORIGINAL_REGNO (addr) >= FIRST_PSEUDO_REGISTER\n+      && reg_known_value[ORIGINAL_REGNO (addr)])\n+    addr = reg_known_value[ORIGINAL_REGNO (addr)];\n+  return rtx_addr_can_trap_p (addr);\n+}\n+\f\n /* Return the INSN_LIST containing INSN in LIST, or NULL\n    if LIST does not contain INSN.  */\n \n@@ -817,7 +833,9 @@ sched_analyze_2 (deps, x, insn)\n \t  }\n \n \tfor (u = deps->last_pending_memory_flush; u; u = XEXP (u, 1))\n-\t  add_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n+\t  if (GET_CODE (XEXP (u, 0)) != JUMP_INSN\n+\t      || deps_may_trap_p (x))\n+\t    add_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n \n \t/* Always add these dependencies to pending_reads, since\n \t   this insn may be followed by a write.  */"}]}