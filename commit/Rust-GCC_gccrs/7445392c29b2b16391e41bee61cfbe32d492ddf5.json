{"sha": "7445392c29b2b16391e41bee61cfbe32d492ddf5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQ0NTM5MmMyOWIyYjE2MzkxZTQxYmVlNjFjZmJlMzJkNDkyZGRmNQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2005-03-04T11:10:35Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2005-03-04T11:10:35Z"}, "message": "* rtl.h (copy_rtx_ptr_loc, print_rtx_ptr_loc, join_c_conditions)\n\t(print_c_condition): Declare.\n\t* read-rtl.c (ptr_loc): New structure.\n\t(ptr_locs, ptr_loc_obstack, joined_conditions)\n\t(joined_conditions_obstack): New variables.\n\t(leading_ptr_hash, leading_ptr_eq_p, set_rtx_ptr_loc)\n\t(get_rtx_ptr_loc, copy_rtx_ptr_loc, print_rtx_ptr_loc)\n\t(join_c_conditions, print_c_condition): New functions.\n\t(apply_macro_to_string): Associate the new string with the same\n\tsource location as the old one.\n\t(add_condition_to_string): Use join_c_conditions.\n\t(read_string): Use set_rtx_ptr_loc to record a filename and line\n\tnumber for the string.\n\t(read_rtx): Initialize the new variables above.\n\t* genattrtab.c (write_test_expr, write_attr_value): Use\n\tprint_c_condition.\n\t* genconditions.c (write_header): Don't define MAYBE_EVAL.  Move its\n\tcomment above the GCC_VERSION check.\n\t(write_one_condition): Use print_rtx_ptr_loc and print_c_condition.\n\tInline the definition of MAYBE_EVAL.\n\t* genemit.c (gen_expand, gen_split): Use print_rtx_ptr_loc.\n\t* genoutput.c (process_template): Likewise.\n\t* genpreds.c (write_predicate_subfunction): Likewise.\n\t(write_predicate_expr): Use print_c_condition.\n\t* genrecog.c (write_cond): Likewise.\n\t* gensupport.c (process_rtx): Use join_c_conditions to join the\n\tconditions of a define_insn_and_split.  Record a source location\n\tfor the string after the \"&&\".\n\t(alter_test_for_insn): Use join_c_conditions.\n\nFrom-SVN: r95883", "tree": {"sha": "023da1eca2bd7656ce3641b1d6d446908d801399", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/023da1eca2bd7656ce3641b1d6d446908d801399"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7445392c29b2b16391e41bee61cfbe32d492ddf5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7445392c29b2b16391e41bee61cfbe32d492ddf5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7445392c29b2b16391e41bee61cfbe32d492ddf5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7445392c29b2b16391e41bee61cfbe32d492ddf5/comments", "author": null, "committer": null, "parents": [{"sha": "935167332d4ee2b0bb173e40a6cf36db53b67d16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/935167332d4ee2b0bb173e40a6cf36db53b67d16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/935167332d4ee2b0bb173e40a6cf36db53b67d16"}], "stats": {"total": 257, "additions": 219, "deletions": 38}, "files": [{"sha": "90bf5e2707d392d4f91697452f8aae0a6dd38a96", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7445392c29b2b16391e41bee61cfbe32d492ddf5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7445392c29b2b16391e41bee61cfbe32d492ddf5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7445392c29b2b16391e41bee61cfbe32d492ddf5", "patch": "@@ -1,3 +1,35 @@\n+2005-03-04  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* rtl.h (copy_rtx_ptr_loc, print_rtx_ptr_loc, join_c_conditions)\n+\t(print_c_condition): Declare.\n+\t* read-rtl.c (ptr_loc): New structure.\n+\t(ptr_locs, ptr_loc_obstack, joined_conditions)\n+\t(joined_conditions_obstack): New variables.\n+\t(leading_ptr_hash, leading_ptr_eq_p, set_rtx_ptr_loc)\n+\t(get_rtx_ptr_loc, copy_rtx_ptr_loc, print_rtx_ptr_loc)\n+\t(join_c_conditions, print_c_condition): New functions.\n+\t(apply_macro_to_string): Associate the new string with the same\n+\tsource location as the old one.\n+\t(add_condition_to_string): Use join_c_conditions.\n+\t(read_string): Use set_rtx_ptr_loc to record a filename and line\n+\tnumber for the string.\n+\t(read_rtx): Initialize the new variables above.\n+\t* genattrtab.c (write_test_expr, write_attr_value): Use\n+\tprint_c_condition.\n+\t* genconditions.c (write_header): Don't define MAYBE_EVAL.  Move its\n+\tcomment above the GCC_VERSION check.\n+\t(write_one_condition): Use print_rtx_ptr_loc and print_c_condition.\n+\tInline the definition of MAYBE_EVAL.\n+\t* genemit.c (gen_expand, gen_split): Use print_rtx_ptr_loc.\n+\t* genoutput.c (process_template): Likewise.\n+\t* genpreds.c (write_predicate_subfunction): Likewise.\n+\t(write_predicate_expr): Use print_c_condition.\n+\t* genrecog.c (write_cond): Likewise.\n+\t* gensupport.c (process_rtx): Use join_c_conditions to join the\n+\tconditions of a define_insn_and_split.  Record a source location\n+\tfor the string after the \"&&\".\n+\t(alter_test_for_insn): Use join_c_conditions.\n+\n 2005-03-04  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \tRevert for now:"}, {"sha": "99f66a14cf54447ba4b9495a4d9e4935c8560e1b", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7445392c29b2b16391e41bee61cfbe32d492ddf5/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7445392c29b2b16391e41bee61cfbe32d492ddf5/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=7445392c29b2b16391e41bee61cfbe32d492ddf5", "patch": "@@ -3506,7 +3506,7 @@ write_test_expr (rtx exp, int flags)\n \n     /* A random C expression.  */\n     case SYMBOL_REF:\n-      printf (\"%s\", XSTR (exp, 0));\n+      print_c_condition (XSTR (exp, 0));\n       break;\n \n     /* The address of the branch target.  */\n@@ -4035,7 +4035,7 @@ write_attr_value (struct attr_desc *attr, rtx value)\n       break;\n \n     case SYMBOL_REF:\n-      fputs (XSTR (value, 0), stdout);\n+      print_c_condition (XSTR (value, 0));\n       break;\n \n     case ATTR:"}, {"sha": "4630f1563736eeb34b88d659d743707f6a547787", "filename": "gcc/genconditions.c", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7445392c29b2b16391e41bee61cfbe32d492ddf5/gcc%2Fgenconditions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7445392c29b2b16391e41bee61cfbe32d492ddf5/gcc%2Fgenconditions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenconditions.c?ref=7445392c29b2b16391e41bee61cfbe32d492ddf5", "patch": "@@ -86,6 +86,10 @@ write_header (void)\n \n   puts (\"\\\n #include \\\"system.h\\\"\\n\\\n+/* If we don't have __builtin_constant_p, or it's not acceptable in array\\n\\\n+   initializers, fall back to assuming that all conditions potentially\\n\\\n+   vary at run time.  It works in 3.0.1 and later; 3.0 only when not\\n\\\n+   optimizing.  */\\n\\\n #if GCC_VERSION < 3001\\n\\\n #include \\\"dummy-conditions.c\\\"\\n\\\n #else\\n\\\n@@ -122,26 +126,23 @@ write_header (void)\n extern rtx insn;\\n\\\n extern rtx ins1;\\n\\\n extern rtx operands[];\\n\");\n-\n-  puts (\"\\\n-/* If we don't have __builtin_constant_p, or it's not acceptable in\\n\\\n-   array initializers, fall back (by using dummy-conditions.c above)\\n\\\n-   to assuming that all conditions potentially vary at run time.  It\\n\\\n-   works in 3.0.1 and later; 3.0 only when not optimizing.  */\\n\\\n-#define MAYBE_EVAL(expr) (__builtin_constant_p(expr) ? (int) (expr) : -1)\\n\");\n }\n \n /* Write out one entry in the conditions table, using the data pointed\n    to by SLOT.  Each entry looks like this:\n-  { \"! optimize_size && ! TARGET_READ_MODIFY_WRITE\",\n-    MAYBE_EVAL (! optimize_size && ! TARGET_READ_MODIFY_WRITE) },  */\n+\n+   { \"! optimize_size && ! TARGET_READ_MODIFY_WRITE\",\n+     __builtin_constant_p (! optimize_size && ! TARGET_READ_MODIFY_WRITE)\n+     ? (int) (! optimize_size && ! TARGET_READ_MODIFY_WRITE)\n+     : -1) },  */\n \n static int\n write_one_condition (void **slot, void * ARG_UNUSED (dummy))\n {\n   const struct c_test *test = * (const struct c_test **) slot;\n   const char *p;\n \n+  print_rtx_ptr_loc (test->expr);\n   fputs (\"  { \\\"\", stdout);\n   for (p = test->expr; *p; p++)\n     {\n@@ -153,7 +154,11 @@ write_one_condition (void **slot, void * ARG_UNUSED (dummy))\n \tputchar (*p);\n     }\n \n-  printf (\"\\\",\\n    MAYBE_EVAL (%s) },\\n\", test->expr);\n+  printf (\"\\\",\\n    __builtin_constant_p \");\n+  print_c_condition (test->expr);\n+  printf (\"\\n    ? (int) \");\n+  print_c_condition (test->expr);\n+  printf (\"\\n    : -1 },\\n\");\n   return 1;\n }\n "}, {"sha": "47970ce291b95e5ce4ebb11c866cea4189df0cf5", "filename": "gcc/genemit.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7445392c29b2b16391e41bee61cfbe32d492ddf5/gcc%2Fgenemit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7445392c29b2b16391e41bee61cfbe32d492ddf5/gcc%2Fgenemit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenemit.c?ref=7445392c29b2b16391e41bee61cfbe32d492ddf5", "patch": "@@ -509,6 +509,7 @@ gen_expand (rtx expand)\n \n       /* Output the special code to be executed before the sequence\n \t is generated.  */\n+      print_rtx_ptr_loc (XSTR (expand, 3));\n       printf (\"%s\\n\", XSTR (expand, 3));\n \n       /* Output code to copy the arguments back out of `operands'\n@@ -630,7 +631,10 @@ gen_split (rtx split)\n      before the actual construction.  */\n \n   if (XSTR (split, 3))\n-    printf (\"%s\\n\", XSTR (split, 3));\n+    {\n+      print_rtx_ptr_loc (XSTR (split, 3));\n+      printf (\"%s\\n\", XSTR (split, 3));\n+    }\n \n   /* Output code to copy the arguments back out of `operands'  */\n   for (i = 0; i < operands; i++)"}, {"sha": "e95f286011bff363d1f698a1e6bf8a2e9397ce39", "filename": "gcc/genoutput.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7445392c29b2b16391e41bee61cfbe32d492ddf5/gcc%2Fgenoutput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7445392c29b2b16391e41bee61cfbe32d492ddf5/gcc%2Fgenoutput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenoutput.c?ref=7445392c29b2b16391e41bee61cfbe32d492ddf5", "patch": "@@ -668,7 +668,7 @@ process_template (struct data *d, const char *template)\n       printf (\"output_%d (rtx *operands ATTRIBUTE_UNUSED, rtx insn ATTRIBUTE_UNUSED)\\n\",\n \t      d->code_number);\n       puts (\"{\");\n-\n+      print_rtx_ptr_loc (template);\n       puts (template + 1);\n       puts (\"}\");\n     }"}, {"sha": "b07abedc5b05b16ba42b21423bd31b503fc0b916", "filename": "gcc/genpreds.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7445392c29b2b16391e41bee61cfbe32d492ddf5/gcc%2Fgenpreds.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7445392c29b2b16391e41bee61cfbe32d492ddf5/gcc%2Fgenpreds.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenpreds.c?ref=7445392c29b2b16391e41bee61cfbe32d492ddf5", "patch": "@@ -138,6 +138,7 @@ write_predicate_subfunction (struct pred_data *p)\n   printf (\"static inline int\\n\"\n \t  \"%s_1 (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\\n\",\n \t  p->name);\n+  print_rtx_ptr_loc (p->c_block);\n   if (p->c_block[0] == '{')\n     fputs (p->c_block, stdout);\n   else\n@@ -377,7 +378,7 @@ write_predicate_expr (const char *name, rtx exp)\n       break;\n \n     case MATCH_TEST:\n-      fputs (XSTR (exp, 0), stdout);\n+      print_c_condition (XSTR (exp, 0));\n       break;\n \n     default:"}, {"sha": "7e1d879899ab6028f37095136f217918273229a0", "filename": "gcc/genrecog.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7445392c29b2b16391e41bee61cfbe32d492ddf5/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7445392c29b2b16391e41bee61cfbe32d492ddf5/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=7445392c29b2b16391e41bee61cfbe32d492ddf5", "patch": "@@ -2113,7 +2113,7 @@ write_cond (struct decision_test *p, int depth,\n       break;\n \n     case DT_c_test:\n-      printf (\"(%s)\", p->u.c_test);\n+      print_c_condition (p->u.c_test);\n       break;\n \n     case DT_accept_insn:"}, {"sha": "f13700aa74a34c519eb372226866ece71460db9f", "filename": "gcc/gensupport.c", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7445392c29b2b16391e41bee61cfbe32d492ddf5/gcc%2Fgensupport.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7445392c29b2b16391e41bee61cfbe32d492ddf5/gcc%2Fgensupport.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.c?ref=7445392c29b2b16391e41bee61cfbe32d492ddf5", "patch": "@@ -317,7 +317,10 @@ process_rtx (rtx desc, int lineno)\n \t   insn condition to create the new split condition.  */\n \tsplit_cond = XSTR (desc, 4);\n \tif (split_cond[0] == '&' && split_cond[1] == '&')\n-\t  split_cond = concat (XSTR (desc, 2), split_cond, NULL);\n+\t  {\n+\t    copy_rtx_ptr_loc (split_cond + 2, split_cond);\n+\t    split_cond = join_c_conditions (XSTR (desc, 2), split_cond + 2);\n+\t  }\n \tXSTR (split, 1) = split_cond;\n \tXVEC (split, 2) = XVEC (desc, 5);\n \tXSTR (split, 3) = XSTR (desc, 6);\n@@ -663,16 +666,8 @@ static const char *\n alter_test_for_insn (struct queue_elem *ce_elem,\n \t\t     struct queue_elem *insn_elem)\n {\n-  const char *ce_test, *insn_test;\n-\n-  ce_test = XSTR (ce_elem->data, 1);\n-  insn_test = XSTR (insn_elem->data, 2);\n-  if (!ce_test || *ce_test == '\\0')\n-    return insn_test;\n-  if (!insn_test || *insn_test == '\\0')\n-    return ce_test;\n-\n-  return concat (\"(\", ce_test, \") && (\", insn_test, \")\", NULL);\n+  return join_c_conditions (XSTR (ce_elem->data, 1),\n+\t\t\t    XSTR (insn_elem->data, 2));\n }\n \n /* Adjust all of the operand numbers in SRC to match the shift they'll"}, {"sha": "e2ea54a6ed2d33ade5682507cb37972213ecea39", "filename": "gcc/read-rtl.c", "status": "modified", "additions": 151, "deletions": 11, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7445392c29b2b16391e41bee61cfbe32d492ddf5/gcc%2Fread-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7445392c29b2b16391e41bee61cfbe32d492ddf5/gcc%2Fread-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-rtl.c?ref=7445392c29b2b16391e41bee61cfbe32d492ddf5", "patch": "@@ -79,6 +79,14 @@ struct macro_group {\n   void (*apply_macro) (rtx, int);\n };\n \n+/* Associates PTR (which can be a string, etc.) with the file location\n+   specified by FILENAME and LINENO.  */\n+struct ptr_loc {\n+  const void *ptr;\n+  const char *filename;\n+  int lineno;\n+};\n+\n /* If CODE is the number of a code macro, return a real rtx code that\n    has the same format.  Return CODE otherwise.  */\n #define BELLWETHER_CODE(CODE) \\\n@@ -105,6 +113,10 @@ static struct map_value **add_map_value (struct map_value **,\n \t\t\t\t\t int, const char *);\n static void initialize_macros (void);\n static void read_name (char *, FILE *);\n+static hashval_t leading_ptr_hash (const void *);\n+static int leading_ptr_eq_p (const void *, const void *);\n+static void set_rtx_ptr_loc (const void *, const char *, int);\n+static const struct ptr_loc *get_rtx_ptr_loc (const void *);\n static char *read_string (FILE *, int);\n static char *read_quoted_string (FILE *);\n static char *read_braced_string (FILE *);\n@@ -127,6 +139,22 @@ static enum rtx_code *bellwether_codes;\n /* Obstack used for allocating RTL strings.  */\n static struct obstack string_obstack;\n \n+/* A table of ptr_locs, hashed on the PTR field.  */\n+static htab_t ptr_locs;\n+\n+/* An obstack for the above.  Plain xmalloc is a bit heavyweight for a\n+   small structure like ptr_loc.  */\n+static struct obstack ptr_loc_obstack;\n+\n+/* A hash table of triples (A, B, C), where each of A, B and C is a condition\n+   and A is equivalent to \"B && C\".  This is used to keep track of the source\n+   of conditions that are made up of separate rtx strings (such as the split\n+   condition of a define_insn_and_split).  */\n+static htab_t joined_conditions;\n+\n+/* An obstack for allocating joined_conditions entries.  */\n+static struct obstack joined_conditions_obstack;\n+\n /* Subroutines of read_rtx.  */\n \n /* The current line number for the file.  */\n@@ -285,7 +313,9 @@ apply_macro_to_string (const char *string, struct mapping *macro, int value)\n   if (base != copy)\n     {\n       obstack_grow (&string_obstack, base, strlen (base) + 1);\n-      return (char *) obstack_finish (&string_obstack);\n+      copy = obstack_finish (&string_obstack);\n+      copy_rtx_ptr_loc (copy, string);\n+      return copy;\n     }\n   return string;\n }\n@@ -396,16 +426,9 @@ uses_macro_p (rtx x, struct mapping *macro)\n static const char *\n add_condition_to_string (const char *original, const char *extra)\n {\n-  char *result;\n-\n-  if (original == 0 || original[0] == 0)\n-    return extra;\n-\n-  if ((original[0] == '&' && original[1] == '&') || extra[0] == 0)\n+  if (original != 0 && original[0] == '&' && original[1] == '&')\n     return original;\n-\n-  asprintf (&result, \"(%s) && (%s)\", original, extra);\n-  return result;\n+  return join_c_conditions (original, extra);\n }\n \n /* Like add_condition, but applied to all conditions in rtx X.  */\n@@ -568,6 +591,116 @@ initialize_macros (void)\n     }\n }\n \n+/* Return a hash value for the pointer pointed to by DEF.  */\n+\n+static hashval_t\n+leading_ptr_hash (const void *def)\n+{\n+  return htab_hash_pointer (*(const void *const *) def);\n+}\n+\n+/* Return true if DEF1 and DEF2 are pointers to the same pointer.  */\n+\n+static int\n+leading_ptr_eq_p (const void *def1, const void *def2)\n+{\n+  return *(const void *const *) def1 == *(const void *const *) def2;\n+}\n+\n+/* Associate PTR with the file position given by FILENAME and LINENO.  */\n+\n+static void\n+set_rtx_ptr_loc (const void *ptr, const char *filename, int lineno)\n+{\n+  struct ptr_loc *loc;\n+\n+  loc = (struct ptr_loc *) obstack_alloc (&ptr_loc_obstack,\n+\t\t\t\t\t  sizeof (struct ptr_loc));\n+  loc->ptr = ptr;\n+  loc->filename = filename;\n+  loc->lineno = lineno;\n+  *htab_find_slot (ptr_locs, loc, INSERT) = loc;\n+}\n+\n+/* Return the position associated with pointer PTR.  Return null if no\n+   position was set.  */\n+\n+static const struct ptr_loc *\n+get_rtx_ptr_loc (const void *ptr)\n+{\n+  return (const struct ptr_loc *) htab_find (ptr_locs, &ptr);\n+}\n+\n+/* Associate NEW_PTR with the same file position as OLD_PTR.  */\n+\n+void\n+copy_rtx_ptr_loc (const void *new_ptr, const void *old_ptr)\n+{\n+  const struct ptr_loc *loc = get_rtx_ptr_loc (old_ptr);\n+  if (loc != 0)\n+    set_rtx_ptr_loc (new_ptr, loc->filename, loc->lineno);\n+}\n+\n+/* If PTR is associated with a known file position, print a #line\n+   directive for it.  */\n+\n+void\n+print_rtx_ptr_loc (const void *ptr)\n+{\n+  const struct ptr_loc *loc = get_rtx_ptr_loc (ptr);\n+  if (loc != 0)\n+    printf (\"#line %d \\\"%s\\\"\\n\", loc->lineno, loc->filename);\n+}\n+\n+/* Return a condition that satisfies both COND1 and COND2.  Either string\n+   may be null or empty.  */\n+\n+const char *\n+join_c_conditions (const char *cond1, const char *cond2)\n+{\n+  char *result;\n+  const void **entry;\n+\n+  if (cond1 == 0 || cond1[0] == 0)\n+    return cond2;\n+\n+  if (cond2 == 0 || cond2[0] == 0)\n+    return cond1;\n+\n+  result = concat (\"(\", cond1, \") && (\", cond2, \")\", NULL);\n+  obstack_ptr_grow (&joined_conditions_obstack, result);\n+  obstack_ptr_grow (&joined_conditions_obstack, cond1);\n+  obstack_ptr_grow (&joined_conditions_obstack, cond2);\n+  entry = obstack_finish (&joined_conditions_obstack);\n+  *htab_find_slot (joined_conditions, entry, INSERT) = entry;\n+  return result;\n+}\n+\n+/* Print condition COND, wrapped in brackets.  If COND was created by\n+   join_c_conditions, recursively invoke this function for the original\n+   conditions and join the result with \"&&\".  Otherwise print a #line\n+   directive for COND if its original file position is known.  */\n+\n+void\n+print_c_condition (const char *cond)\n+{\n+  const void **halves = htab_find (joined_conditions, &cond);\n+  if (halves != 0)\n+    {\n+      printf (\"(\");\n+      print_c_condition (halves[1]);\n+      printf (\" && \");\n+      print_c_condition (halves[2]);\n+      printf (\")\");\n+    }\n+  else\n+    {\n+      putc ('\\n', stdout);\n+      print_rtx_ptr_loc (cond);\n+      printf (\"(%s)\", cond);\n+    }\n+}\n+\n /* Read chars from INFILE until a non-whitespace char\n    and return that.  Comments, both Lisp style and C style,\n    are treated as whitespace.\n@@ -801,7 +934,7 @@ read_string (FILE *infile, int star_if_braced)\n {\n   char *stringbuf;\n   int saw_paren = 0;\n-  int c;\n+  int c, old_lineno;\n \n   c = read_skip_spaces (infile);\n   if (c == '(')\n@@ -810,6 +943,7 @@ read_string (FILE *infile, int star_if_braced)\n       c = read_skip_spaces (infile);\n     }\n \n+  old_lineno = read_rtx_lineno;\n   if (c == '\"')\n     stringbuf = read_quoted_string (infile);\n   else if (c == '{')\n@@ -828,6 +962,7 @@ read_string (FILE *infile, int star_if_braced)\n \tfatal_expected_char (infile, ')', c);\n     }\n \n+  set_rtx_ptr_loc (stringbuf, read_rtx_filename, old_lineno);\n   return stringbuf;\n }\n \f\n@@ -1094,6 +1229,11 @@ read_rtx (FILE *infile, rtx *x, int *lineno)\n       initialize_macros ();\n       obstack_init (&string_obstack);\n       queue_head = rtx_alloc (EXPR_LIST);\n+      ptr_locs = htab_create (161, leading_ptr_hash, leading_ptr_eq_p, 0);\n+      obstack_init (&ptr_loc_obstack);\n+      joined_conditions = htab_create (161, leading_ptr_hash,\n+\t\t\t\t       leading_ptr_eq_p, 0);\n+      obstack_init (&joined_conditions_obstack);\n     }\n \n   if (queue_next == 0)"}, {"sha": "cb3cb87578f15d646e735d9ffefb1c208d52e01d", "filename": "gcc/rtl.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7445392c29b2b16391e41bee61cfbe32d492ddf5/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7445392c29b2b16391e41bee61cfbe32d492ddf5/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=7445392c29b2b16391e41bee61cfbe32d492ddf5", "patch": "@@ -2119,6 +2119,10 @@ struct md_constant { char *name, *value; };\n /* In read-rtl.c */\n extern int read_skip_spaces (FILE *);\n extern bool read_rtx (FILE *, rtx *, int *);\n+extern void copy_rtx_ptr_loc (const void *, const void *);\n+extern void print_rtx_ptr_loc (const void *);\n+extern const char *join_c_conditions (const char *, const char *);\n+extern void print_c_condition (const char *);\n extern const char *read_rtx_filename;\n extern int read_rtx_lineno;\n "}]}