{"sha": "9580628d89a0e31314fcd893297ce550dd2ca0f8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTU4MDYyOGQ4OWEwZTMxMzE0ZmNkODkzMjk3Y2U1NTBkZDJjYTBmOA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2013-05-26T10:19:00Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2013-05-26T10:19:00Z"}, "message": "decl.c (vinfo_t): New type and associated vector.\n\n\t* gcc-interface/decl.c (vinfo_t): New type and associated vector.\n\t(components_to_record): Change return type to bool.\n\tLay out the variants in two passes.  Do not force a specific layout for\n\tthe variant part if the variants do not have a representation clause.\n\tTake the alignment of the variant part into account when laying out\n\tvariants without rep clause in a record type with a partial rep clause.\n\t(create_rep_part): Do not set the position of the field.\n\nFrom-SVN: r199342", "tree": {"sha": "cd0f881787a23a37b0d2de3a74a8dea7978ffd7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cd0f881787a23a37b0d2de3a74a8dea7978ffd7c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9580628d89a0e31314fcd893297ce550dd2ca0f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9580628d89a0e31314fcd893297ce550dd2ca0f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9580628d89a0e31314fcd893297ce550dd2ca0f8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9580628d89a0e31314fcd893297ce550dd2ca0f8/comments", "author": null, "committer": null, "parents": [{"sha": "7cc15171bee9d4a62d4618741e85bb0342525ca2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cc15171bee9d4a62d4618741e85bb0342525ca2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7cc15171bee9d4a62d4618741e85bb0342525ca2"}], "stats": {"total": 255, "additions": 168, "deletions": 87}, "files": [{"sha": "efe59e0fcfaba9cdfb966ee7a9f67742cd2c0f9c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9580628d89a0e31314fcd893297ce550dd2ca0f8/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9580628d89a0e31314fcd893297ce550dd2ca0f8/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=9580628d89a0e31314fcd893297ce550dd2ca0f8", "patch": "@@ -1,3 +1,13 @@\n+2013-05-26  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (vinfo_t): New type and associated vector.\n+\t(components_to_record): Change return type to bool.\n+\tLay out the variants in two passes.  Do not force a specific layout for\n+\tthe variant part if the variants do not have a representation clause.\n+\tTake the alignment of the variant part into account when laying out\n+\tvariants without rep clause in a record type with a partial rep clause.\n+\t(create_rep_part): Do not set the position of the field.\n+\n 2013-05-26  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/trans.c (Attribute_to_gnu) <Attr_Last_Bit>: Add kludge"}, {"sha": "26e3944df3787052b5759df6f7385c2e376bf449", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 158, "deletions": 87, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9580628d89a0e31314fcd893297ce550dd2ca0f8/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9580628d89a0e31314fcd893297ce550dd2ca0f8/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=9580628d89a0e31314fcd893297ce550dd2ca0f8", "patch": "@@ -145,7 +145,7 @@ static bool array_type_has_nonaliased_component (tree, Entity_Id);\n static bool compile_time_known_address_p (Node_Id);\n static bool cannot_be_superflat_p (Node_Id);\n static bool constructor_address_p (tree);\n-static void components_to_record (tree, Node_Id, tree, int, bool, bool, bool,\n+static bool components_to_record (tree, Node_Id, tree, int, bool, bool, bool,\n \t\t\t\t  bool, bool, bool, bool, bool, tree, tree *);\n static Uint annotate_value (tree);\n static void annotate_rep (Entity_Id, tree);\n@@ -6841,9 +6841,30 @@ compare_field_bitpos (const PTR rt1, const PTR rt2)\n   return ret ? ret : (int) (DECL_UID (field1) - DECL_UID (field2));\n }\n \n-/* Translate and chain the GNAT_COMPONENT_LIST to the GNU_FIELD_LIST, set\n-   the result as the field list of GNU_RECORD_TYPE and finish it up.  When\n-   called from gnat_to_gnu_entity during the processing of a record type\n+/* Structure holding information for a given variant.  */\n+typedef struct vinfo\n+{\n+  /* The record type of the variant.  */\n+  tree type;\n+\n+  /* The name of the variant.  */\n+  tree name;\n+\n+  /* The qualifier of the variant.  */\n+  tree qual;\n+\n+  /* Whether the variant has a rep clause.  */\n+  bool has_rep;\n+\n+  /* Whether the variant is packed.  */\n+  bool packed;\n+\n+} vinfo_t;\n+\n+/* Translate and chain the GNAT_COMPONENT_LIST to the GNU_FIELD_LIST, set the\n+   result as the field list of GNU_RECORD_TYPE and finish it up.  Return true\n+   if GNU_RECORD_TYPE has a rep clause which affects the layout (see below).\n+   When called from gnat_to_gnu_entity during the processing of a record type\n    definition, the GCC node for the parent, if any, will be the single field\n    of GNU_RECORD_TYPE and the GCC nodes for the discriminants will be on the\n    GNU_FIELD_LIST.  The other calls to this function are recursive calls for\n@@ -6880,9 +6901,9 @@ compare_field_bitpos (const PTR rt1, const PTR rt2)\n \n    P_GNU_REP_LIST, if nonzero, is a pointer to a list to which each field\n    with a rep clause is to be added; in this case, that is all that should\n-   be done with such fields.  */\n+   be done with such fields and the return value will be false.  */\n \n-static void\n+static bool\n components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \t\t      tree gnu_field_list, int packed, bool definition,\n \t\t      bool cancel_alignment, bool all_rep,\n@@ -6891,12 +6912,12 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \t\t      tree first_free_pos, tree *p_gnu_rep_list)\n {\n   bool all_rep_and_size = all_rep && TYPE_SIZE (gnu_record_type);\n+  bool variants_have_rep = all_rep;\n   bool layout_with_rep = false;\n   bool has_self_field = false;\n   bool has_aliased_after_self_field = false;\n   Node_Id component_decl, variant_part;\n   tree gnu_field, gnu_next, gnu_last;\n-  tree gnu_rep_part = NULL_TREE;\n   tree gnu_variant_part = NULL_TREE;\n   tree gnu_rep_list = NULL_TREE;\n   tree gnu_var_list = NULL_TREE;\n@@ -6978,6 +6999,12 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n       tree gnu_union_type, gnu_union_name;\n       tree this_first_free_pos, gnu_variant_list = NULL_TREE;\n       bool union_field_needs_strict_alignment = false;\n+      vec <vinfo_t, va_stack> variant_types;\n+      vinfo_t *gnu_variant;\n+      unsigned int variants_align = 0;\n+      unsigned int i;\n+\n+      vec_stack_alloc (vinfo_t, variant_types, 16);\n \n       if (TREE_CODE (gnu_name) == TYPE_DECL)\n \tgnu_name = DECL_NAME (gnu_name);\n@@ -7023,13 +7050,20 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \t      }\n \t}\n \n+      /* We build the variants in two passes.  The bulk of the work is done in\n+\t the first pass, that is to say translating the GNAT nodes, building\n+\t the container types and computing the associated properties.  However\n+\t we cannot finish up the container types during this pass because we\n+\t don't know where the variant part will be placed until the end.  */\n       for (variant = First_Non_Pragma (Variants (variant_part));\n \t   Present (variant);\n \t   variant = Next_Non_Pragma (variant))\n \t{\n \t  tree gnu_variant_type = make_node (RECORD_TYPE);\n-\t  tree gnu_inner_name;\n-\t  tree gnu_qual;\n+\t  tree gnu_inner_name, gnu_qual;\n+\t  bool has_rep;\n+\t  int field_packed;\n+\t  vinfo_t vinfo;\n \n \t  Get_Variant_Encoding (variant);\n \t  gnu_inner_name = get_identifier_with_length (Name_Buffer, Name_Len);\n@@ -7054,70 +7088,122 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \n \t  /* Add the fields into the record type for the variant.  Note that\n \t     we aren't sure to really use it at this point, see below.  */\n-\t  components_to_record (gnu_variant_type, Component_List (variant),\n-\t\t\t\tNULL_TREE, packed, definition,\n-\t\t\t\t!all_rep_and_size, all_rep, unchecked_union,\n-\t\t\t\ttrue, debug_info, true, reorder,\n-\t\t\t\tthis_first_free_pos,\n-\t\t\t\tall_rep || this_first_free_pos\n-\t\t\t\t? NULL : &gnu_rep_list);\n-\n+\t  has_rep\n+\t    = components_to_record (gnu_variant_type, Component_List (variant),\n+\t\t\t\t    NULL_TREE, packed, definition,\n+\t\t\t\t    !all_rep_and_size, all_rep,\n+\t\t\t\t    unchecked_union,\n+\t\t\t\t    true, debug_info, true, reorder,\n+\t\t\t\t    this_first_free_pos,\n+\t\t\t\t    all_rep || this_first_free_pos\n+\t\t\t\t    ? NULL : &gnu_rep_list);\n+\n+\t  /* Translate the qualifier and annotate the GNAT node.  */\n \t  gnu_qual = choices_to_gnu (gnu_discr, Discrete_Choices (variant));\n \t  Set_Present_Expr (variant, annotate_value (gnu_qual));\n \n+\t  /* Deal with packedness like in gnat_to_gnu_field.  */\n+\t  if (components_need_strict_alignment (Component_List (variant)))\n+\t    {\n+\t      field_packed = 0;\n+\t      union_field_needs_strict_alignment = true;\n+\t    }\n+\t  else\n+\t    field_packed\n+\t      = adjust_packed (gnu_variant_type, gnu_record_type, packed);\n+\n+\t  /* Push this variant onto the stack for the second pass.  */\n+\t  vinfo.type = gnu_variant_type;\n+\t  vinfo.name = gnu_inner_name;\n+\t  vinfo.qual = gnu_qual;\n+\t  vinfo.has_rep = has_rep;\n+\t  vinfo.packed = field_packed;\n+\t  variant_types.safe_push (vinfo);\n+\n+\t  /* Compute the global properties that will determine the placement of\n+\t     the variant part.  */\n+\t  variants_have_rep |= has_rep;\n+\t  if (!field_packed && TYPE_ALIGN (gnu_variant_type) > variants_align)\n+\t    variants_align = TYPE_ALIGN (gnu_variant_type);\n+\t}\n+\n+      /* Round up the first free position to the alignment of the variant part\n+\t for the variants without rep clause.  This will guarantee a consistent\n+\t layout independently of the placement of the variant part.  */\n+      if (variants_have_rep && variants_align > 0 && this_first_free_pos)\n+\tthis_first_free_pos = round_up (this_first_free_pos, variants_align);\n+\n+      /* In the second pass, the container types are adjusted if necessary and\n+\t finished up, then the corresponding fields of the variant part are\n+\t built with their qualifier, unless this is an unchecked union.  */\n+      FOR_EACH_VEC_ELT (variant_types, i, gnu_variant)\n+\t{\n+\t  tree gnu_variant_type = gnu_variant->type;\n+\t  tree gnu_field_list = TYPE_FIELDS (gnu_variant_type);\n+\n \t  /* If this is an Unchecked_Union whose fields are all in the variant\n \t     part and we have a single field with no representation clause or\n \t     placed at offset zero, use the field directly to match the layout\n \t     of C unions.  */\n \t  if (TREE_CODE (gnu_record_type) == UNION_TYPE\n-\t      && (gnu_field = TYPE_FIELDS (gnu_variant_type)) != NULL_TREE\n-\t      && !DECL_CHAIN (gnu_field)\n-\t      && (!DECL_FIELD_OFFSET (gnu_field)\n-\t\t  || integer_zerop (bit_position (gnu_field))))\n-\t    DECL_CONTEXT (gnu_field) = gnu_union_type;\n+\t      && gnu_field_list\n+\t      && !DECL_CHAIN (gnu_field_list)\n+\t      && (!DECL_FIELD_OFFSET (gnu_field_list)\n+\t\t  || integer_zerop (bit_position (gnu_field_list))))\n+\t    {\n+\t      gnu_field = gnu_field_list;\n+\t      DECL_CONTEXT (gnu_field) = gnu_record_type;\n+\t    }\n \t  else\n \t    {\n-\t      /* Deal with packedness like in gnat_to_gnu_field.  */\n-\t      bool field_needs_strict_alignment\n-\t        = components_need_strict_alignment (Component_List (variant));\n-\t      int field_packed;\n-\n-\t      if (field_needs_strict_alignment)\n+\t      /* Finalize the variant type now.  We used to throw away empty\n+\t\t record types but we no longer do that because we need them to\n+\t\t generate complete debug info for the variant; otherwise, the\n+\t\t union type definition will be lacking the fields associated\n+\t\t with these empty variants.  */\n+\t      if (gnu_field_list && variants_have_rep && !gnu_variant->has_rep)\n \t\t{\n-\t\t  field_packed = 0;\n-\t\t  union_field_needs_strict_alignment = true;\n+\t\t  /* The variant part will be at offset 0 so we need to ensure\n+\t\t     that the fields are laid out starting from the first free\n+\t\t     position at this level.  */\n+\t\t  tree gnu_rep_type = make_node (RECORD_TYPE);\n+\t\t  tree gnu_rep_part;\n+\t\t  finish_record_type (gnu_rep_type, NULL_TREE, 0, debug_info);\n+\t\t  gnu_rep_part\n+\t\t    = create_rep_part (gnu_rep_type, gnu_variant_type,\n+\t\t\t\t       this_first_free_pos);\n+\t\t  DECL_CHAIN (gnu_rep_part) = gnu_field_list;\n+\t\t  gnu_field_list = gnu_rep_part;\n+\t\t  finish_record_type (gnu_variant_type, gnu_field_list, 0,\n+\t\t\t\t      false);\n \t\t}\n-\t      else\n-\t\tfield_packed\n-\t\t  = adjust_packed (gnu_variant_type, gnu_record_type, packed);\n-\n-\t      /* Finalize the record type now.  We used to throw away\n-\t\t empty records but we no longer do that because we need\n-\t\t them to generate complete debug info for the variant;\n-\t\t otherwise, the union type definition will be lacking\n-\t\t the fields associated with these empty variants.  */\n-\t      rest_of_record_type_compilation (gnu_variant_type);\n+\n+\t      if (debug_info)\n+\t\trest_of_record_type_compilation (gnu_variant_type);\n \t      create_type_decl (TYPE_NAME (gnu_variant_type), gnu_variant_type,\n \t\t\t\ttrue, debug_info, gnat_component_list);\n \n \t      gnu_field\n-\t\t= create_field_decl (gnu_inner_name, gnu_variant_type,\n+\t\t= create_field_decl (gnu_variant->name, gnu_variant_type,\n \t\t\t\t     gnu_union_type,\n \t\t\t\t     all_rep_and_size\n \t\t\t\t     ? TYPE_SIZE (gnu_variant_type) : 0,\n-\t\t\t\t     all_rep ? bitsize_zero_node : 0,\n-\t\t\t\t     field_packed, 0);\n+\t\t\t\t     variants_have_rep ? bitsize_zero_node : 0,\n+\t\t\t\t     gnu_variant->packed, 0);\n \n \t      DECL_INTERNAL_P (gnu_field) = 1;\n \n \t      if (!unchecked_union)\n-\t\tDECL_QUALIFIER (gnu_field) = gnu_qual;\n+\t\tDECL_QUALIFIER (gnu_field) = gnu_variant->qual;\n \t    }\n \n \t  DECL_CHAIN (gnu_field) = gnu_variant_list;\n \t  gnu_variant_list = gnu_field;\n \t}\n \n+      /* We are done with the variants.  */\n+      variant_types.release ();\n+\n       /* Only make the QUAL_UNION_TYPE if there are non-empty variants.  */\n       if (gnu_variant_list)\n \t{\n@@ -7141,7 +7227,7 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \t      gcc_assert (unchecked_union\n \t\t\t  && !gnu_field_list\n \t\t\t  && !gnu_rep_list);\n-\t      return;\n+\t      return variants_have_rep;\n \t    }\n \n \t  create_type_decl (TYPE_NAME (gnu_union_type), gnu_union_type, true,\n@@ -7158,18 +7244,13 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \t    = create_field_decl (gnu_var_name, gnu_union_type, gnu_record_type,\n \t\t\t\t all_rep_and_size\n \t\t\t\t ? TYPE_SIZE (gnu_union_type) : 0,\n-\t\t\t\t all_rep || this_first_free_pos\n-\t\t\t\t ? bitsize_zero_node : 0,\n+\t\t\t\t variants_have_rep ? bitsize_zero_node : 0,\n \t\t\t\t union_field_packed, 0);\n \n \t  DECL_INTERNAL_P (gnu_variant_part) = 1;\n \t}\n     }\n \n-  /* From now on, a zero FIRST_FREE_POS is totally useless.  */\n-  if (first_free_pos && integer_zerop (first_free_pos))\n-    first_free_pos = NULL_TREE;\n-\n   /* Scan GNU_FIELD_LIST and see if any fields have rep clauses and, if we are\n      permitted to reorder components, self-referential sizes or variable sizes.\n      If they do, pull them out and put them onto the appropriate list.  We have\n@@ -7219,6 +7300,8 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \n #undef MOVE_FROM_FIELD_LIST_TO\n \n+  gnu_field_list = nreverse (gnu_field_list);\n+\n   /* If permitted, we reorder the fields as follows:\n \n        1) all fixed length fields,\n@@ -7229,14 +7312,13 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n      within the record and within each variant recursively.  */\n   if (reorder)\n     gnu_field_list\n-      = chainon (nreverse (gnu_self_list),\n-\t\t chainon (nreverse (gnu_var_list), gnu_field_list));\n+      = chainon (gnu_field_list, chainon (gnu_var_list, gnu_self_list));\n \n   /* Otherwise, if there is an aliased field placed after a field whose length\n      depends on discriminants, we put all the fields of the latter sort, last.\n      We need to do this in case an object of this record type is mutable.  */\n   else if (has_aliased_after_self_field)\n-    gnu_field_list = chainon (nreverse (gnu_self_list), gnu_field_list);\n+    gnu_field_list = chainon (gnu_field_list, gnu_self_list);\n \n   /* If P_REP_LIST is nonzero, this means that we are asked to move the fields\n      in our REP list to the previous level because this level needs them in\n@@ -7248,11 +7330,16 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n      record, before the others, if we also have fields without rep clause.  */\n   else if (gnu_rep_list)\n     {\n-      tree gnu_rep_type\n-\t= (gnu_field_list ? make_node (RECORD_TYPE) : gnu_record_type);\n+      tree gnu_rep_type, gnu_rep_part;\n       int i, len = list_length (gnu_rep_list);\n       tree *gnu_arr = XALLOCAVEC (tree, len);\n \n+      /* If all the fields have a rep clause, we can do a flat layout.  */\n+      layout_with_rep = !gnu_field_list\n+\t\t\t&& (!gnu_variant_part || variants_have_rep);\n+      gnu_rep_type\n+\t= layout_with_rep ? gnu_record_type : make_node (RECORD_TYPE);\n+\n       for (gnu_field = gnu_rep_list, i = 0;\n \t   gnu_field;\n \t   gnu_field = DECL_CHAIN (gnu_field), i++)\n@@ -7270,7 +7357,9 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \t  DECL_CONTEXT (gnu_arr[i]) = gnu_rep_type;\n \t}\n \n-      if (gnu_field_list)\n+      if (layout_with_rep)\n+\tgnu_field_list = gnu_rep_list;\n+      else\n \t{\n \t  finish_record_type (gnu_rep_type, gnu_rep_list, 1, debug_info);\n \n@@ -7279,44 +7368,26 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \t     Therefore, we force it as a minimal size on the REP part.  */\n \t  gnu_rep_part\n \t    = create_rep_part (gnu_rep_type, gnu_record_type, first_free_pos);\n-\t}\n-      else\n-\t{\n-\t  layout_with_rep = true;\n-\t  gnu_field_list = nreverse (gnu_rep_list);\n-\t}\n-    }\n \n-  /* If FIRST_FREE_POS is nonzero, we need to ensure that the fields without\n-     rep clause are laid out starting from this position.  Therefore, if we\n-     have not already done so, we create a fake REP part with this size.  */\n-  if (first_free_pos && !layout_with_rep && !gnu_rep_part)\n-    {\n-      tree gnu_rep_type = make_node (RECORD_TYPE);\n-      finish_record_type (gnu_rep_type, NULL_TREE, 0, debug_info);\n-      gnu_rep_part\n-\t= create_rep_part (gnu_rep_type, gnu_record_type, first_free_pos);\n+\t  /* Chain the REP part at the beginning of the field list.  */\n+\t  DECL_CHAIN (gnu_rep_part) = gnu_field_list;\n+\t  gnu_field_list = gnu_rep_part;\n+\t}\n     }\n \n-  /* Now chain the REP part at the end of the reversed field list.  */\n-  if (gnu_rep_part)\n-    gnu_field_list = chainon (gnu_field_list, gnu_rep_part);\n-\n-  /* And the variant part at the beginning.  */\n+  /* Chain the variant part at the end of the field list.  */\n   if (gnu_variant_part)\n-    {\n-      DECL_CHAIN (gnu_variant_part) = gnu_field_list;\n-      gnu_field_list = gnu_variant_part;\n-    }\n+    gnu_field_list = chainon (gnu_field_list, gnu_variant_part);\n \n   if (cancel_alignment)\n     TYPE_ALIGN (gnu_record_type) = 0;\n \n-  finish_record_type (gnu_record_type, nreverse (gnu_field_list),\n-\t\t      layout_with_rep ? 1 : 0, false);\n   TYPE_ARTIFICIAL (gnu_record_type) = artificial;\n-  if (debug_info && !maybe_unused)\n-    rest_of_record_type_compilation (gnu_record_type);\n+\n+  finish_record_type (gnu_record_type, gnu_field_list, layout_with_rep ? 1 : 0,\n+\t\t      debug_info && !maybe_unused);\n+\n+  return (gnu_rep_list && !p_gnu_rep_list) || variants_have_rep;\n }\n \f\n /* Given GNU_SIZE, a GCC tree representing a size, return a Uint to be\n@@ -8347,7 +8418,7 @@ create_rep_part (tree rep_type, tree record_type, tree min_size)\n     min_size = NULL_TREE;\n \n   field = create_field_decl (get_identifier (\"REP\"), rep_type, record_type,\n-\t\t\t     min_size, bitsize_zero_node, 0, 1);\n+\t\t\t     min_size, NULL_TREE, 0, 1);\n   DECL_INTERNAL_P (field) = 1;\n \n   return field;"}]}