{"sha": "1bb98cecc686cccc58d73e6654c216ed22feed24", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWJiOThjZWNjNjg2Y2NjYzU4ZDczZTY2NTRjMjE2ZWQyMmZlZWQyNA==", "commit": {"author": {"name": "David S. Miller", "email": "davem@redhat.com", "date": "1999-11-30T06:03:30Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "1999-11-30T06:03:30Z"}, "message": "Move quantity tables and register equivalence chains into\n\tper-qty and per-register structure arrays respectively.\n\nFrom-SVN: r30717", "tree": {"sha": "04bdfef672593a305e34d7bab729280b6b900c0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04bdfef672593a305e34d7bab729280b6b900c0c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1bb98cecc686cccc58d73e6654c216ed22feed24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bb98cecc686cccc58d73e6654c216ed22feed24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1bb98cecc686cccc58d73e6654c216ed22feed24", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bb98cecc686cccc58d73e6654c216ed22feed24/comments", "author": null, "committer": null, "parents": [{"sha": "de96bf571d4db9b506fbc92091f38135941239cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de96bf571d4db9b506fbc92091f38135941239cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de96bf571d4db9b506fbc92091f38135941239cd"}], "stats": {"total": 655, "additions": 371, "deletions": 284}, "files": [{"sha": "a0376e069f1a127ae08f568c2467193ff38a93e8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bb98cecc686cccc58d73e6654c216ed22feed24/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bb98cecc686cccc58d73e6654c216ed22feed24/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1bb98cecc686cccc58d73e6654c216ed22feed24", "patch": "@@ -1,3 +1,20 @@\n+1999-11-29  David S. Miller  <davem@redhat.com>\n+\n+\tMove quantity tables and register equivalence chains into\n+\tper-qty and per-register structure arrays respectively.\n+\t* cse.c (qty_first_reg, qty_last_reg, qty_mode, qty_const,\n+\tqty_const_insn, qty_comparison_code, qty_comparison_const,\n+\tqty_comparison_qty): Delete, replace with...\n+\t(qty_table): this structure table.\n+\t(reg_next_eqv, reg_prev_eqv): Delete, replace with...\n+\t(reg_eqv_table): this structure table.\n+\t(make_new_qty): Add argument MODE.  Caller updated.\n+\tUpdate to use qty_table and reg_eqv_table.\n+\t(make_regs_eqv, delete_reg_equiv, insert_regs,\n+\tinsert, exp_equiv_p, cse_rtx_varies_p, canon_reg,\n+\tfold_rtx, equiv_constant, record_jump_cond, cse_insn,\n+\tcse_process_notes, cse_main, cse_basic_block): Likewise.\n+\n Mon Nov 29 16:56:42 1999  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* fold-const.c (extract_muldiv, case {MIN,MAX}_EXPR): Reverse"}, {"sha": "1d82a96db363beaddeeab71190a6a487aa16a700", "filename": "gcc/cse.c", "status": "modified", "additions": 354, "deletions": 284, "changes": 638, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bb98cecc686cccc58d73e6654c216ed22feed24/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bb98cecc686cccc58d73e6654c216ed22feed24/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=1bb98cecc686cccc58d73e6654c216ed22feed24", "patch": "@@ -55,8 +55,8 @@ Boston, MA 02111-1307, USA.  */\n    optimizer after CSE to delete the unreachable code.\n \n    We use two data structures to record the equivalent expressions:\n-   a hash table for most expressions, and several vectors together\n-   with \"quantity numbers\" to record equivalent (pseudo) registers.\n+   a hash table for most expressions, and a vector of \"quantity\n+   numbers\" to record equivalent (pseudo) registers.\n \n    The use of the special data structure for registers is desirable\n    because it is faster.  It is possible because registers references\n@@ -81,19 +81,19 @@ Registers and \"quantity numbers\":\n    All real quantity numbers are greater than or equal to `max_reg'.\n    If register N has not been assigned a quantity, reg_qty[N] will equal N.\n \n-   Quantity numbers below `max_reg' do not exist and none of the `qty_...'\n-   variables should be referenced with an index below `max_reg'.\n+   Quantity numbers below `max_reg' do not exist and none of the `qty_table'\n+   entries should be referenced with an index below `max_reg'.\n \n    We also maintain a bidirectional chain of registers for each\n-   quantity number.  `qty_first_reg', `qty_last_reg',\n-   `reg_next_eqv' and `reg_prev_eqv' hold these chains.\n+   quantity number.  The `qty_table` members `first_reg' and `last_reg',\n+   and `reg_eqv_table' members `next' and `prev' hold these chains.\n \n    The first register in a chain is the one whose lifespan is least local.\n    Among equals, it is the one that was seen first.\n    We replace any equivalent register with that one.\n \n    If two registers have the same quantity number, it must be true that\n-   REG expressions with `qty_mode' must be in the hash table for both\n+   REG expressions with qty_table `mode' must be in the hash table for both\n    registers and must be in the same class.\n \n    The converse is not true.  Since hard registers may be referenced in\n@@ -104,16 +104,16 @@ Registers and \"quantity numbers\":\n Constants and quantity numbers\n \n    When a quantity has a known constant value, that value is stored\n-   in the appropriate element of qty_const.  This is in addition to\n+   in the appropriate qty_table `const_rtx'.  This is in addition to\n    putting the constant in the hash table as is usual for non-regs.\n \n    Whether a reg or a constant is preferred is determined by the configuration\n    macro CONST_COSTS and will often depend on the constant value.  In any\n    event, expressions containing constants can be simplified, by fold_rtx.\n \n    When a quantity has a known nearly constant value (such as an address\n-   of a stack slot), that value is stored in the appropriate element\n-   of qty_const.\n+   of a stack slot), that value is stored in the appropriate qty_table\n+   `const_rtx'.\n \n    Integer constants don't have a machine mode.  However, cse\n    determines the intended machine mode from the destination\n@@ -133,7 +133,7 @@ Other expressions:\n    currently have equivalent values.\n \n    Register references in an expression are canonicalized before hashing\n-   the expression.  This is done using `reg_qty' and `qty_first_reg'.\n+   the expression.  This is done using `reg_qty' and qty_table `first_reg'.\n    The hash code of a register reference is computed using the quantity\n    number, not the register number.\n \n@@ -205,8 +205,8 @@ static int max_reg;\n \n static int max_insn_uid;\n \n-/* Length of vectors indexed by quantity number.\n-   We know in advance we will not need a quantity number this big.  */\n+/* Length of qty_table vector.  We know in advance we will not need\n+   a quantity number this big.  */\n \n static int max_qty;\n \n@@ -215,48 +215,44 @@ static int max_qty;\n \n static int next_qty;\n \n-/* Indexed by quantity number, gives the first (or last) register \n-   in the chain of registers that currently contain this quantity.  */\n+/* Per-qty information tracking.\n \n-static int *qty_first_reg;\n-static int *qty_last_reg;\n+   `first_reg' and `last_reg' track the head and tail of the\n+   chain of registers which currently contain this quantity.\n \n-/* Index by quantity number, gives the mode of the quantity.  */\n+   `mode' contains the machine mode of this quantity.\n \n-static enum machine_mode *qty_mode;\n+   `const_rtx' holds the rtx of the constant value of this\n+   quantity, if known.  A summations of the frame/arg pointer\n+   and a constant can also be entered here.  When this holds\n+   a known value, `const_insn' is the insn which stored the\n+   constant value.\n \n-/* Indexed by quantity number, gives the rtx of the constant value of the\n-   quantity, or zero if it does not have a known value.\n-   A sum of the frame pointer (or arg pointer) plus a constant\n-   can also be entered here.  */\n+   `comparison_{code,const,qty}' are used to track when a\n+   comparison between a quantity and some constant or register has\n+   been passed.  In such a case, we know the results of the comparison\n+   in case we see it again.  These members record a comparison that\n+   is known to be true.  `comparison_code' holds the rtx code of such\n+   a comparison, else it is set to UNKNOWN and the other two\n+   comparison members are undefined.  `comparison_const' holds\n+   the constant being compared against, or zero if the comparison\n+   is not against a constant.  `comparison_qty' holds the quantity\n+   being compared against when the result is known.  If the comparison\n+   is not with a register, `comparison_qty' is -1.  */\n \n-static rtx *qty_const;\n-\n-/* Indexed by qty number, gives the insn that stored the constant value\n-   recorded in `qty_const'.  */\n-\n-static rtx *qty_const_insn;\n-\n-/* The next three variables are used to track when a comparison between a\n-   quantity and some constant or register has been passed.  In that case, we\n-   know the results of the comparison in case we see it again.  These variables\n-   record a comparison that is known to be true.  */\n-\n-/* Indexed by qty number, gives the rtx code of a comparison with a known\n-   result involving this quantity.  If none, it is UNKNOWN.  */\n-static enum rtx_code *qty_comparison_code;\n-\n-/* Indexed by qty number, gives the constant being compared against in a\n-   comparison of known result.  If no such comparison, it is undefined.\n-   If the comparison is not with a constant, it is zero.  */\n-\n-static rtx *qty_comparison_const;\n-\n-/* Indexed by qty number, gives the quantity being compared against in a\n-   comparison of known result.  If no such comparison, if it undefined.\n-   If the comparison is not with a register, it is -1.  */\n+struct qty_table_elem\n+{\n+  rtx const_rtx;\n+  rtx const_insn;\n+  rtx comparison_const;\n+  int comparison_qty;\n+  int first_reg, last_reg;\n+  enum machine_mode mode;\n+  enum rtx_code comparison_code;\n+};\n \n-static int *qty_comparison_qty;\n+/* The table of all qtys, indexed by qty number.  */\n+static struct qty_table_elem *qty_table;\n \n #ifdef HAVE_cc0\n /* For machines that have a CC0, we do not record its value in the hash\n@@ -286,10 +282,16 @@ static rtx this_insn;\n \n    Or -1 if this register is at the end of the chain.\n \n-   If reg_qty[N] == N, reg_next_eqv[N] is undefined.  */\n+   If reg_qty[N] == N, reg_eqv_table[N].next is undefined.  */\n \n-static int *reg_next_eqv;\n-static int *reg_prev_eqv;\n+/* Per-register equivalence chain.  */\n+struct reg_eqv_elem\n+{\n+  int next, prev;\n+};\n+\n+/* The table of all register equivalence chains.  */\n+static struct reg_eqv_elem *reg_eqv_table;\n \n struct cse_reg_info\n {\n@@ -519,7 +521,7 @@ struct table_elt\n #define REG_QTY(N) ((GET_CSE_REG_INFO (N))->reg_qty)\n \n /* Determine if the quantity number for register X represents a valid index\n-   into the `qty_...' variables.  */\n+   into the qty_table.  */\n \n #define REGNO_QTY_VALID_P(N) (REG_QTY (N) != (N))\n \n@@ -643,7 +645,7 @@ struct cse_basic_block_data\n \n static int notreg_cost\t\tPROTO((rtx));\n static void new_basic_block\tPROTO((void));\n-static void make_new_qty\tPROTO((int));\n+static void make_new_qty\tPROTO((int, enum machine_mode));\n static void make_regs_eqv\tPROTO((int, int));\n static void delete_reg_equiv\tPROTO((int));\n static int mention_regs\t\tPROTO((rtx));\n@@ -950,25 +952,31 @@ new_basic_block ()\n #endif\n }\n \n-/* Say that register REG contains a quantity not in any register before\n-   and initialize that quantity.  */\n+/* Say that register REG contains a quantity in mode MODE not in any\n+   register before and initialize that quantity.  */\n \n static void\n-make_new_qty (reg)\n+make_new_qty (reg, mode)\n      register int reg;\n+     register enum machine_mode mode;\n {\n   register int q;\n+  register struct qty_table_elem *ent;\n+  register struct reg_eqv_elem *eqv;\n \n   if (next_qty >= max_qty)\n     abort ();\n \n   q = REG_QTY (reg) = next_qty++;\n-  qty_first_reg[q] = reg;\n-  qty_last_reg[q] = reg;\n-  qty_const[q] = qty_const_insn[q] = 0;\n-  qty_comparison_code[q] = UNKNOWN;\n-\n-  reg_next_eqv[reg] = reg_prev_eqv[reg] = -1;\n+  ent = &qty_table[q];\n+  ent->first_reg = reg;\n+  ent->last_reg = reg;\n+  ent->mode = mode;\n+  ent->const_rtx = ent->const_insn = NULL_RTX;\n+  ent->comparison_code = UNKNOWN;\n+\n+  eqv = &reg_eqv_table[reg];\n+  eqv->next = eqv->prev = -1;\n }\n \n /* Make reg NEW equivalent to reg OLD.\n@@ -980,14 +988,17 @@ make_regs_eqv (new, old)\n {\n   register int lastr, firstr;\n   register int q = REG_QTY (old);\n+  register struct qty_table_elem *ent;\n+\n+  ent = &qty_table[q];\n \n   /* Nothing should become eqv until it has a \"non-invalid\" qty number.  */\n   if (! REGNO_QTY_VALID_P (old))\n     abort ();\n \n   REG_QTY (new) = q;\n-  firstr = qty_first_reg[q];\n-  lastr = qty_last_reg[q];\n+  firstr = ent->first_reg;\n+  lastr = ent->last_reg;\n \n   /* Prefer fixed hard registers to anything.  Prefer pseudo regs to other\n      hard regs.  Among pseudos, if NEW will live longer than any other reg\n@@ -1008,28 +1019,28 @@ make_regs_eqv (new, old)\n \t\t      && (uid_cuid[REGNO_LAST_UID (new)]\n \t\t\t  > uid_cuid[REGNO_LAST_UID (firstr)]))))))\n     {\n-      reg_prev_eqv[firstr] = new;\n-      reg_next_eqv[new] = firstr;\n-      reg_prev_eqv[new] = -1;\n-      qty_first_reg[q] = new;\n+      reg_eqv_table[firstr].prev = new;\n+      reg_eqv_table[new].next = firstr;\n+      reg_eqv_table[new].prev = -1;\n+      ent->first_reg = new;\n     }\n   else\n     {\n       /* If NEW is a hard reg (known to be non-fixed), insert at end.\n \t Otherwise, insert before any non-fixed hard regs that are at the\n \t end.  Registers of class NO_REGS cannot be used as an\n \t equivalent for anything.  */\n-      while (lastr < FIRST_PSEUDO_REGISTER && reg_prev_eqv[lastr] >= 0\n+      while (lastr < FIRST_PSEUDO_REGISTER && reg_eqv_table[lastr].prev >= 0\n \t     && (REGNO_REG_CLASS (lastr) == NO_REGS || ! FIXED_REGNO_P (lastr))\n \t     && new >= FIRST_PSEUDO_REGISTER)\n-\tlastr = reg_prev_eqv[lastr];\n-      reg_next_eqv[new] = reg_next_eqv[lastr];\n-      if (reg_next_eqv[lastr] >= 0)\n-\treg_prev_eqv[reg_next_eqv[lastr]] = new;\n+\tlastr = reg_eqv_table[lastr].prev;\n+      reg_eqv_table[new].next = reg_eqv_table[lastr].next;\n+      if (reg_eqv_table[lastr].next >= 0)\n+\treg_eqv_table[reg_eqv_table[lastr].next].prev = new;\n       else\n-\tqty_last_reg[q] = new;\n-      reg_next_eqv[lastr] = new;\n-      reg_prev_eqv[new] = lastr;\n+\tqty_table[q].last_reg = new;\n+      reg_eqv_table[lastr].next = new;\n+      reg_eqv_table[new].prev = lastr;\n     }\n }\n \n@@ -1039,24 +1050,27 @@ static void\n delete_reg_equiv (reg)\n      register int reg;\n {\n+  register struct qty_table_elem *ent;\n   register int q = REG_QTY (reg);\n   register int p, n;\n \n   /* If invalid, do nothing.  */\n   if (q == reg)\n     return;\n \n-  p = reg_prev_eqv[reg];\n-  n = reg_next_eqv[reg];\n+  ent = &qty_table[q];\n+\n+  p = reg_eqv_table[reg].prev;\n+  n = reg_eqv_table[reg].next;\n \n   if (n != -1)\n-    reg_prev_eqv[n] = p;\n+    reg_eqv_table[n].prev = p;\n   else\n-    qty_last_reg[q] = p;\n+    ent->last_reg = p;\n   if (p != -1)\n-    reg_next_eqv[p] = n;\n+    reg_eqv_table[p].next = n;\n   else\n-    qty_first_reg[q] = n;\n+    ent->first_reg = n;\n \n   REG_QTY (reg) = reg;\n }\n@@ -1188,15 +1202,21 @@ insert_regs (x, classp, modified)\n   if (GET_CODE (x) == REG)\n     {\n       register int regno = REGNO (x);\n+      register int qty_valid;\n \n       /* If REGNO is in the equivalence table already but is of the\n \t wrong mode for that equivalence, don't do anything here.  */\n \n-      if (REGNO_QTY_VALID_P (regno)\n-\t  && qty_mode[REG_QTY (regno)] != GET_MODE (x))\n-\treturn 0;\n+      qty_valid = REGNO_QTY_VALID_P (regno);\n+      if (qty_valid)\n+\t{\n+\t  struct qty_table_elem *ent = &qty_table[REG_QTY (regno)];\n \n-      if (modified || ! REGNO_QTY_VALID_P (regno))\n+\t  if (ent->mode != GET_MODE (x))\n+\t    return 0;\n+\t}\n+\n+      if (modified || ! qty_valid)\n \t{\n \t  if (classp)\n \t    for (classp = classp->first_same_value;\n@@ -1209,8 +1229,7 @@ insert_regs (x, classp, modified)\n \t\t  return 1;\n \t\t}\n \n-\t  make_new_qty (regno);\n-\t  qty_mode[REG_QTY (regno)] = GET_MODE (x);\n+\t  make_new_qty (regno, GET_MODE (x));\n \t  return 1;\n \t}\n \n@@ -1566,18 +1585,22 @@ insert (x, classp, hash, mode)\n      constant, we must check the entire class.\n \n      If this is a register that is already known equivalent to an insn,\n-     update `qty_const_insn' to show that `this_insn' is the latest\n+     update the qtys `const_insn' to show that `this_insn' is the latest\n      insn making that quantity equivalent to the constant.  */\n \n   if (elt->is_const && classp && GET_CODE (classp->exp) == REG\n       && GET_CODE (x) != REG)\n     {\n-      qty_const[REG_QTY (REGNO (classp->exp))]\n-\t= gen_lowpart_if_possible (qty_mode[REG_QTY (REGNO (classp->exp))], x);\n-      qty_const_insn[REG_QTY (REGNO (classp->exp))] = this_insn;\n+      int exp_q = REG_QTY (REGNO (classp->exp));\n+      struct qty_table_elem *exp_ent = &qty_table[exp_q];\n+\n+      exp_ent->const_rtx = gen_lowpart_if_possible (exp_ent->mode, x);\n+      exp_ent->const_insn = this_insn;\n     }\n \n-  else if (GET_CODE (x) == REG && classp && ! qty_const[REG_QTY (REGNO (x))]\n+  else if (GET_CODE (x) == REG\n+\t   && classp\n+\t   && ! qty_table[REG_QTY (REGNO (x))].const_rtx\n \t   && ! elt->is_const)\n     {\n       register struct table_elt *p;\n@@ -1586,17 +1609,20 @@ insert (x, classp, hash, mode)\n \t{\n \t  if (p->is_const && GET_CODE (p->exp) != REG)\n \t    {\n-\t      qty_const[REG_QTY (REGNO (x))]\n-\t\t= gen_lowpart_if_possible (GET_MODE (x), p->exp);\n-\t      qty_const_insn[REG_QTY (REGNO (x))] = this_insn;\n+\t      int x_q = REG_QTY (REGNO (x));\n+\t      struct qty_table_elem *x_ent = &qty_table[x_q];\n+\n+\t      x_ent->const_rtx = gen_lowpart_if_possible (GET_MODE (x), p->exp);\n+\t      x_ent->const_insn = this_insn;\n \t      break;\n \t    }\n \t}\n     }\n \n-  else if (GET_CODE (x) == REG && qty_const[REG_QTY (REGNO (x))]\n-\t   && GET_MODE (x) == qty_mode[REG_QTY (REGNO (x))])\n-    qty_const_insn[REG_QTY (REGNO (x))] = this_insn;\n+  else if (GET_CODE (x) == REG\n+\t   && qty_table[REG_QTY (REGNO (x))].const_rtx\n+\t   && GET_MODE (x) == qty_table[REG_QTY (REGNO (x))].mode)\n+    qty_table[REG_QTY (REGNO (x))].const_insn = this_insn;\n \n   /* If this is a constant with symbolic value,\n      and it has a term with an explicit integer value,\n@@ -2321,17 +2347,27 @@ exp_equiv_p (x, y, validate, equal_values)\n       /* If X is a constant and Y is a register or vice versa, they may be\n \t equivalent.  We only have to validate if Y is a register.  */\n       if (CONSTANT_P (x) && GET_CODE (y) == REG\n-\t  && REGNO_QTY_VALID_P (REGNO (y))\n-\t  && GET_MODE (y) == qty_mode[REG_QTY (REGNO (y))]\n-\t  && rtx_equal_p (x, qty_const[REG_QTY (REGNO (y))])\n-\t  && (! validate || REG_IN_TABLE (REGNO (y)) == REG_TICK (REGNO (y))))\n-\treturn 1;\n+\t  && REGNO_QTY_VALID_P (REGNO (y)))\n+\t{\n+\t  int y_q = REG_QTY (REGNO (y));\n+\t  struct qty_table_elem *y_ent = &qty_table[y_q];\n+\n+\t  if (GET_MODE (y) == y_ent->mode\n+\t      && rtx_equal_p (x, y_ent->const_rtx)\n+\t      && (! validate || REG_IN_TABLE (REGNO (y)) == REG_TICK (REGNO (y))))\n+\t    return 1;\n+\t}\n \n       if (CONSTANT_P (y) && code == REG\n-\t  && REGNO_QTY_VALID_P (REGNO (x))\n-\t  && GET_MODE (x) == qty_mode[REG_QTY (REGNO (x))]\n-\t  && rtx_equal_p (y, qty_const[REG_QTY (REGNO (x))]))\n-\treturn 1;\n+\t  && REGNO_QTY_VALID_P (REGNO (x)))\n+\t{\n+\t  int x_q = REG_QTY (REGNO (x));\n+\t  struct qty_table_elem *x_ent = &qty_table[x_q];\n+\n+\t  if (GET_MODE (x) == x_ent->mode\n+\t      && rtx_equal_p (y, x_ent->const_rtx))\n+\t    return 1;\n+\t}\n \n       return 0;\n     }\n@@ -2462,19 +2498,28 @@ cse_rtx_varies_p (x)\n      doesn't vary in any mode.  */\n \n   if (GET_CODE (x) == REG\n-      && REGNO_QTY_VALID_P (REGNO (x))\n-      && GET_MODE (x) == qty_mode[REG_QTY (REGNO (x))]\n-      && qty_const[REG_QTY (REGNO (x))] != 0)\n-    return 0;\n+      && REGNO_QTY_VALID_P (REGNO (x)))\n+    {\n+      int x_q = REG_QTY (REGNO (x));\n+      struct qty_table_elem *x_ent = &qty_table[x_q];\n+\n+      if (GET_MODE (x) == x_ent->mode\n+\t  && x_ent->const_rtx != NULL_RTX)\n+\treturn 0;\n+    }\n \n   if (GET_CODE (x) == PLUS\n       && GET_CODE (XEXP (x, 1)) == CONST_INT\n       && GET_CODE (XEXP (x, 0)) == REG\n-      && REGNO_QTY_VALID_P (REGNO (XEXP (x, 0)))\n-      && (GET_MODE (XEXP (x, 0))\n-\t  == qty_mode[REG_QTY (REGNO (XEXP (x, 0)))])\n-      && qty_const[REG_QTY (REGNO (XEXP (x, 0)))])\n-    return 0;\n+      && REGNO_QTY_VALID_P (REGNO (XEXP (x, 0))))\n+    {\n+      int x0_q = REG_QTY (REGNO (XEXP (x, 0)));\n+      struct qty_table_elem *x0_ent = &qty_table[x0_q];\n+\n+      if ((GET_MODE (XEXP (x, 0)) == x0_ent->mode)\n+\t  && x0_ent->const_rtx != NULL_RTX)\n+\treturn 0;\n+    }\n \n   /* This can happen as the result of virtual register instantiation, if\n      the initial constant is too large to be a valid address.  This gives\n@@ -2485,14 +2530,19 @@ cse_rtx_varies_p (x)\n       && GET_CODE (XEXP (x, 0)) == REG\n       && GET_CODE (XEXP (x, 1)) == REG\n       && REGNO_QTY_VALID_P (REGNO (XEXP (x, 0)))\n-      && (GET_MODE (XEXP (x, 0))\n-\t  == qty_mode[REG_QTY (REGNO (XEXP (x, 0)))])\n-      && qty_const[REG_QTY (REGNO (XEXP (x, 0)))]\n-      && REGNO_QTY_VALID_P (REGNO (XEXP (x, 1)))\n-      && (GET_MODE (XEXP (x, 1))\n-\t  == qty_mode[REG_QTY (REGNO (XEXP (x, 1)))])\n-      && qty_const[REG_QTY (REGNO (XEXP (x, 1)))])\n-    return 0;\n+      && REGNO_QTY_VALID_P (REGNO (XEXP (x, 1))))\n+    {\n+      int x0_q = REG_QTY (REGNO (XEXP (x, 0)));\n+      int x1_q = REG_QTY (REGNO (XEXP (x, 1)));\n+      struct qty_table_elem *x0_ent = &qty_table[x0_q];\n+      struct qty_table_elem *x1_ent = &qty_table[x1_q];\n+\n+      if ((GET_MODE (XEXP (x, 0)) == x0_ent->mode)\n+\t  && x0_ent->const_rtx != NULL_RTX\n+\t  && (GET_MODE (XEXP (x, 1)) == x1_ent->mode)\n+\t  && x1_ent->const_rtx != NULL_RTX)\n+\treturn 0;\n+    }\n \n   return rtx_varies_p (x);\n }\n@@ -2537,6 +2587,8 @@ canon_reg (x, insn)\n     case REG:\n       {\n \tregister int first;\n+\tregister int q;\n+\tregister struct qty_table_elem *ent;\n \n \t/* Never replace a hard reg, because hard regs can appear\n \t   in more than one machine mode, and we must preserve the mode\n@@ -2547,10 +2599,12 @@ canon_reg (x, insn)\n \t    || ! REGNO_QTY_VALID_P (REGNO (x)))\n \t  return x;\n \n-\tfirst = qty_first_reg[REG_QTY (REGNO (x))];\n+\tq = REG_QTY (REGNO(x));\n+\tent = &qty_table[q];\n+\tfirst = ent->first_reg;\n \treturn (first >= FIRST_PSEUDO_REGISTER ? regno_reg_rtx[first]\n \t\t: REGNO_REG_CLASS (first) == NO_REGS ? x\n-\t\t: gen_rtx_REG (qty_mode[REG_QTY (REGNO (x))], first));\n+\t\t: gen_rtx_REG (ent->mode, first));\n       }\n       \n     default:\n@@ -3105,7 +3159,7 @@ fold_rtx (x, insn)\n \t\t    && GET_MODE (SUBREG_REG (elt->exp)) == mode\n \t\t    && exp_equiv_p (elt->exp, elt->exp, 1, 0))\n \t\t  return copy_rtx (SUBREG_REG (elt->exp));\n-\t    }\n+\t      }\n \n \t  return x;\n \t}\n@@ -3279,10 +3333,15 @@ fold_rtx (x, insn)\n \tHOST_WIDE_INT offset = 0;\n \n \tif (GET_CODE (addr) == REG\n-\t    && REGNO_QTY_VALID_P (REGNO (addr))\n-\t    && GET_MODE (addr) == qty_mode[REG_QTY (REGNO (addr))]\n-\t    && qty_const[REG_QTY (REGNO (addr))] != 0)\n-\t  addr = qty_const[REG_QTY (REGNO (addr))];\n+\t    && REGNO_QTY_VALID_P (REGNO (addr)))\n+\t  {\n+\t    int addr_q = REG_QTY (REGNO (addr));\n+\t    struct qty_table_elem *addr_ent = &qty_table[addr_q];\n+\n+\t    if (GET_MODE (addr) == addr_ent->mode\n+\t\t&& addr_ent->const_rtx != NULL_RTX)\n+\t      addr = addr_ent->const_rtx;\n+\t  }\n \n \t/* If address is constant, split it into a base and integer offset.  */\n \tif (GET_CODE (addr) == SYMBOL_REF || GET_CODE (addr) == LABEL_REF)\n@@ -3423,13 +3482,18 @@ fold_rtx (x, insn)\n \t  case REG:\n \t    /* This is the same as calling equiv_constant; it is duplicated\n \t       here for speed.  */\n-\t    if (REGNO_QTY_VALID_P (REGNO (arg))\n-\t\t&& qty_const[REG_QTY (REGNO (arg))] != 0\n-\t\t&& GET_CODE (qty_const[REG_QTY (REGNO (arg))]) != REG\n-\t\t&& GET_CODE (qty_const[REG_QTY (REGNO (arg))]) != PLUS)\n-\t      const_arg\n-\t\t= gen_lowpart_if_possible (GET_MODE (arg),\n-\t\t\t\t\t   qty_const[REG_QTY (REGNO (arg))]);\n+\t    if (REGNO_QTY_VALID_P (REGNO (arg)))\n+\t      {\n+\t\tint arg_q = REG_QTY (REGNO (arg));\n+\t\tstruct qty_table_elem *arg_ent = &qty_table[arg_q];\n+\n+\t\tif (arg_ent->const_rtx != NULL_RTX\n+\t\t    && GET_CODE (arg_ent->const_rtx) != REG\n+\t\t    && GET_CODE (arg_ent->const_rtx) != PLUS)\n+\t\t  const_arg\n+\t\t    = gen_lowpart_if_possible (GET_MODE (arg),\n+\t\t\t\t\t       arg_ent->const_rtx);\n+\t      }\n \t    break;\n \n \t  case CONST:\n@@ -3672,21 +3736,23 @@ fold_rtx (x, insn)\n \t\t{\n \t\t  int qty = REG_QTY (REGNO (folded_arg0));\n \n-\t\t  if (REGNO_QTY_VALID_P (REGNO (folded_arg0))\n-\t\t      && (comparison_dominates_p (qty_comparison_code[qty], code)\n-\t\t\t  || (comparison_dominates_p (qty_comparison_code[qty],\n-\t\t\t\t\t\t      reverse_condition (code))\n-\t\t\t      && ! FLOAT_MODE_P (mode_arg0)))\n-\t\t      && (rtx_equal_p (qty_comparison_const[qty], folded_arg1)\n-\t\t\t  || (const_arg1\n-\t\t\t      && rtx_equal_p (qty_comparison_const[qty],\n-\t\t\t\t\t      const_arg1))\n-\t\t\t  || (GET_CODE (folded_arg1) == REG\n-\t\t\t      && (REG_QTY (REGNO (folded_arg1))\n-\t\t\t\t  == qty_comparison_qty[qty]))))\n-\t\t    return (comparison_dominates_p (qty_comparison_code[qty],\n-\t\t\t\t\t\t    code)\n-\t\t\t    ? true : false);\n+\t\t  if (REGNO_QTY_VALID_P (REGNO (folded_arg0)))\n+\t\t    {\n+\t\t      struct qty_table_elem *ent = &qty_table[qty];\n+\n+\t\t      if ((comparison_dominates_p (ent->comparison_code, code)\n+\t\t\t   || (comparison_dominates_p (ent->comparison_code,\n+\t\t\t\t\t\t       reverse_condition (code))\n+\t\t\t       && ! FLOAT_MODE_P (mode_arg0)))\n+\t\t\t  && (rtx_equal_p (ent->comparison_const, folded_arg1)\n+\t\t\t      || (const_arg1\n+\t\t\t\t  && rtx_equal_p (ent->comparison_const,\n+\t\t\t\t\t\t  const_arg1))\n+\t\t\t      || (GET_CODE (folded_arg1) == REG\n+\t\t\t\t  && (REG_QTY (REGNO (folded_arg1)) == ent->comparison_qty))))\n+\t\t\treturn (comparison_dominates_p (ent->comparison_code, code)\n+\t\t\t\t? true : false);\n+\t\t    }\n \t\t}\n \t    }\n \t}\n@@ -3984,9 +4050,14 @@ equiv_constant (x)\n      rtx x;\n {\n   if (GET_CODE (x) == REG\n-      && REGNO_QTY_VALID_P (REGNO (x))\n-      && qty_const[REG_QTY (REGNO (x))])\n-    x = gen_lowpart_if_possible (GET_MODE (x), qty_const[REG_QTY (REGNO (x))]);\n+      && REGNO_QTY_VALID_P (REGNO (x)))\n+    {\n+      int x_q = REG_QTY (REGNO (x));\n+      struct qty_table_elem *x_ent = &qty_table[x_q];\n+\n+      if (x_ent->const_rtx)\n+\tx = gen_lowpart_if_possible (GET_MODE (x), x_ent->const_rtx);\n+    }\n \n   if (x == 0 || CONSTANT_P (x))\n     return x;\n@@ -4229,6 +4300,9 @@ record_jump_cond (code, mode, op0, op1, reversed_nonequality)\n \n   if (code != EQ || FLOAT_MODE_P (GET_MODE (op0)))\n     {\n+      struct qty_table_elem *ent;\n+      int qty;\n+\n       /* If we reversed a floating-point comparison, if OP0 is not a\n \t register, or if OP1 is neither a register or constant, we can't\n \t do anything.  */\n@@ -4260,7 +4334,10 @@ record_jump_cond (code, mode, op0, op1, reversed_nonequality)\n \t  op0_elt->in_memory = op0_in_memory;\n \t}\n \n-      qty_comparison_code[REG_QTY (REGNO (op0))] = code;\n+      qty = REG_QTY (REGNO (op0));\n+      ent = &qty_table[qty];\n+\n+      ent->comparison_code = code;\n       if (GET_CODE (op1) == REG)\n \t{\n \t  /* Look it up again--in case op0 and op1 are the same.  */\n@@ -4279,13 +4356,13 @@ record_jump_cond (code, mode, op0, op1, reversed_nonequality)\n \t      op1_elt->in_memory = op1_in_memory;\n \t    }\n \n-\t  qty_comparison_qty[REG_QTY (REGNO (op0))] = REG_QTY (REGNO (op1));\n-\t  qty_comparison_const[REG_QTY (REGNO (op0))] = 0;\n+\t  ent->comparison_const = NULL_RTX;\n+\t  ent->comparison_qty = REG_QTY (REGNO (op1));\n \t}\n       else\n \t{\n-\t  qty_comparison_qty[REG_QTY (REGNO (op0))] = -1;\n-\t  qty_comparison_const[REG_QTY (REGNO (op0))] = op1;\n+\t  ent->comparison_const = op1;\n+\t  ent->comparison_qty = -1;\n \t}\n \n       return;\n@@ -5198,36 +5275,43 @@ cse_insn (insn, libcall_insn)\n \t both registers live over a portion of the basic block.  This way,\n \t their lifetimes will likely abut instead of overlapping.  */\n       if (GET_CODE (dest) == REG\n-\t  && REGNO_QTY_VALID_P (REGNO (dest))\n-\t  && qty_mode[REG_QTY (REGNO (dest))] == GET_MODE (dest)\n-\t  && qty_first_reg[REG_QTY (REGNO (dest))] != REGNO (dest)\n-\t  && GET_CODE (src) == REG && REGNO (src) == REGNO (dest)\n-\t  /* Don't do this if the original insn had a hard reg as\n-\t     SET_SRC or SET_DEST.  */\n-\t  && (GET_CODE (sets[i].src) != REG\n-\t      || REGNO (sets[i].src) >= FIRST_PSEUDO_REGISTER)\n-\t  && (GET_CODE (dest) != REG || REGNO (dest) >= FIRST_PSEUDO_REGISTER))\n-\t/* We can't call canon_reg here because it won't do anything if\n-\t   SRC is a hard register.  */\n+\t  && REGNO_QTY_VALID_P (REGNO (dest)))\n \t{\n-\t  int first = qty_first_reg[REG_QTY (REGNO (src))];\n-\t  rtx new_src\n-\t    = (first >= FIRST_PSEUDO_REGISTER\n-\t       ? regno_reg_rtx[first] : gen_rtx_REG (GET_MODE (src), first));\n-\n-\t  /* We must use validate-change even for this, because this\n-\t     might be a special no-op instruction, suitable only to\n-\t     tag notes onto.  */\n-\t  if (validate_change (insn, &SET_SRC (sets[i].rtl), new_src, 0))\n+\t  int dest_q = REG_QTY (REGNO (dest));\n+\t  struct qty_table_elem *dest_ent = &qty_table[dest_q];\n+\n+\t  if (dest_ent->mode == GET_MODE (dest)\n+\t      && dest_ent->first_reg != REGNO (dest)\n+\t      && GET_CODE (src) == REG && REGNO (src) == REGNO (dest)\n+\t      /* Don't do this if the original insn had a hard reg as\n+\t\t SET_SRC or SET_DEST.  */\n+\t      && (GET_CODE (sets[i].src) != REG\n+\t\t  || REGNO (sets[i].src) >= FIRST_PSEUDO_REGISTER)\n+\t      && (GET_CODE (dest) != REG || REGNO (dest) >= FIRST_PSEUDO_REGISTER))\n+\t    /* We can't call canon_reg here because it won't do anything if\n+\t       SRC is a hard register.  */\n \t    {\n-\t      src = new_src;\n-\t      /* If we had a constant that is cheaper than what we are now\n-\t\t setting SRC to, use that constant.  We ignored it when we\n-\t\t thought we could make this into a no-op.  */\n-\t      if (src_const && COST (src_const) < COST (src)\n-\t\t  && validate_change (insn, &SET_SRC (sets[i].rtl), src_const,\n-\t\t\t\t      0))\n-\t\tsrc = src_const;\n+\t      int src_q = REG_QTY (REGNO (src));\n+\t      struct qty_table_elem *src_ent = &qty_table[src_q];\n+\t      int first = src_ent->first_reg;\n+\t      rtx new_src\n+\t\t= (first >= FIRST_PSEUDO_REGISTER\n+\t\t   ? regno_reg_rtx[first] : gen_rtx_REG (GET_MODE (src), first));\n+\n+\t      /* We must use validate-change even for this, because this\n+\t\t might be a special no-op instruction, suitable only to\n+\t\t tag notes onto.  */\n+\t      if (validate_change (insn, &SET_SRC (sets[i].rtl), new_src, 0))\n+\t\t{\n+\t\t  src = new_src;\n+\t\t  /* If we had a constant that is cheaper than what we are now\n+\t\t     setting SRC to, use that constant.  We ignored it when we\n+\t\t     thought we could make this into a no-op.  */\n+\t\t  if (src_const && COST (src_const) < COST (src)\n+\t\t      && validate_change (insn, &SET_SRC (sets[i].rtl), src_const,\n+\t\t\t\t\t  0))\n+\t\t    src = src_const;\n+\t\t}\n \t    }\n \t}\n \n@@ -5284,22 +5368,27 @@ cse_insn (insn, libcall_insn)\n \t     Rather than track each register individually, we just see if\n \t     the last set for this quantity was for this register.  */\n \n-\t  if (REGNO_QTY_VALID_P (REGNO (dest))\n-\t      && qty_const[REG_QTY (REGNO (dest))] == const0_rtx)\n+\t  if (REGNO_QTY_VALID_P (REGNO (dest)))\n \t    {\n-\t      /* See if we previously had a REG_WAS_0 note.  */\n-\t      rtx note = find_reg_note (insn, REG_WAS_0, NULL_RTX);\n-\t      rtx const_insn = qty_const_insn[REG_QTY (REGNO (dest))];\n+\t      int dest_q = REG_QTY (REGNO (dest));\n+\t      struct qty_table_elem *dest_ent = &qty_table[dest_q];\n \n-\t      if ((tem = single_set (const_insn)) != 0\n-\t\t  && rtx_equal_p (SET_DEST (tem), dest))\n+\t      if (dest_ent->const_rtx == const0_rtx)\n \t\t{\n-\t\t  if (note)\n-\t\t    XEXP (note, 0) = const_insn;\n-\t\t  else\n-\t\t    REG_NOTES (insn)\n-\t\t      = gen_rtx_INSN_LIST (REG_WAS_0, const_insn,\n-\t\t\t\t\t   REG_NOTES (insn));\n+\t\t  /* See if we previously had a REG_WAS_0 note.  */\n+\t\t  rtx note = find_reg_note (insn, REG_WAS_0, NULL_RTX);\n+\t\t  rtx const_insn = dest_ent->const_insn;\n+\n+\t\t  if ((tem = single_set (const_insn)) != 0\n+\t\t      && rtx_equal_p (SET_DEST (tem), dest))\n+\t\t    {\n+\t\t      if (note)\n+\t\t\tXEXP (note, 0) = const_insn;\n+\t\t      else\n+\t\t\tREG_NOTES (insn)\n+\t\t\t  = gen_rtx_INSN_LIST (REG_WAS_0, const_insn,\n+\t\t\t\t\t       REG_NOTES (insn));\n+\t\t    }\n \t\t}\n \t    }\n \t}\n@@ -5828,50 +5917,54 @@ cse_insn (insn, libcall_insn)\n       && NEXT_INSN (PREV_INSN (insn)) == insn\n       && GET_CODE (SET_SRC (sets[0].rtl)) == REG\n       && REGNO (SET_SRC (sets[0].rtl)) >= FIRST_PSEUDO_REGISTER\n-      && REGNO_QTY_VALID_P (REGNO (SET_SRC (sets[0].rtl)))\n-      && (qty_first_reg[REG_QTY (REGNO (SET_SRC (sets[0].rtl)))]\n-\t  == REGNO (SET_DEST (sets[0].rtl)))\n-      && ! find_reg_note (insn, REG_RETVAL, NULL_RTX))\n+      && REGNO_QTY_VALID_P (REGNO (SET_SRC (sets[0].rtl))))\n     {\n-      rtx prev = PREV_INSN (insn);\n-      while (prev && GET_CODE (prev) == NOTE)\n-\tprev = PREV_INSN (prev);\n+      int src_q = REG_QTY (REGNO (SET_SRC (sets[0].rtl)));\n+      struct qty_table_elem *src_ent = &qty_table[src_q];\n \n-      if (prev && GET_CODE (prev) == INSN && GET_CODE (PATTERN (prev)) == SET\n-\t  && SET_DEST (PATTERN (prev)) == SET_SRC (sets[0].rtl))\n+      if ((src_ent->first_reg == REGNO (SET_DEST (sets[0].rtl)))\n+\t  && ! find_reg_note (insn, REG_RETVAL, NULL_RTX))\n \t{\n-\t  rtx dest = SET_DEST (sets[0].rtl);\n-\t  rtx note = find_reg_note (prev, REG_EQUIV, NULL_RTX);\n+\t  rtx prev = PREV_INSN (insn);\n+\t  while (prev && GET_CODE (prev) == NOTE)\n+\t    prev = PREV_INSN (prev);\n \n-\t  validate_change (prev, & SET_DEST (PATTERN (prev)), dest, 1);\n-\t  validate_change (insn, & SET_DEST (sets[0].rtl),\n-\t\t\t   SET_SRC (sets[0].rtl), 1);\n-\t  validate_change (insn, & SET_SRC (sets[0].rtl), dest, 1);\n-\t  apply_change_group ();\n+\t  if (prev && GET_CODE (prev) == INSN && GET_CODE (PATTERN (prev)) == SET\n+\t      && SET_DEST (PATTERN (prev)) == SET_SRC (sets[0].rtl))\n+\t    {\n+\t      rtx dest = SET_DEST (sets[0].rtl);\n+\t      rtx note = find_reg_note (prev, REG_EQUIV, NULL_RTX);\n \n-\t  /* If REG1 was equivalent to a constant, REG0 is not.  */\n-\t  if (note)\n-\t    PUT_REG_NOTE_KIND (note, REG_EQUAL);\n+\t      validate_change (prev, & SET_DEST (PATTERN (prev)), dest, 1);\n+\t      validate_change (insn, & SET_DEST (sets[0].rtl),\n+\t\t\t       SET_SRC (sets[0].rtl), 1);\n+\t      validate_change (insn, & SET_SRC (sets[0].rtl), dest, 1);\n+\t      apply_change_group ();\n \n-\t  /* If there was a REG_WAS_0 note on PREV, remove it.  Move\n-\t     any REG_WAS_0 note on INSN to PREV.  */\n-\t  note = find_reg_note (prev, REG_WAS_0, NULL_RTX);\n-\t  if (note)\n-\t    remove_note (prev, note);\n+\t      /* If REG1 was equivalent to a constant, REG0 is not.  */\n+\t      if (note)\n+\t\tPUT_REG_NOTE_KIND (note, REG_EQUAL);\n \n-\t  note = find_reg_note (insn, REG_WAS_0, NULL_RTX);\n-\t  if (note)\n-\t    {\n-\t      remove_note (insn, note);\n-\t      XEXP (note, 1) = REG_NOTES (prev);\n-\t      REG_NOTES (prev) = note;\n-\t    }\n+\t      /* If there was a REG_WAS_0 note on PREV, remove it.  Move\n+\t\t any REG_WAS_0 note on INSN to PREV.  */\n+\t      note = find_reg_note (prev, REG_WAS_0, NULL_RTX);\n+\t      if (note)\n+\t\tremove_note (prev, note);\n \n-\t  /* If INSN has a REG_EQUAL note, and this note mentions REG0,\n-\t     then we must delete it, because the value in REG0 has changed.  */\n-\t  note = find_reg_note (insn, REG_EQUAL, NULL_RTX);\n-\t  if (note && reg_mentioned_p (dest, XEXP (note, 0)))\n-\t    remove_note (insn, note);\n+\t      note = find_reg_note (insn, REG_WAS_0, NULL_RTX);\n+\t      if (note)\n+\t\t{\n+\t\t  remove_note (insn, note);\n+\t\t  XEXP (note, 1) = REG_NOTES (prev);\n+\t\t  REG_NOTES (prev) = note;\n+\t\t}\n+\n+\t      /* If INSN has a REG_EQUAL note, and this note mentions REG0,\n+\t\t then we must delete it, because the value in REG0 has changed.  */\n+\t      note = find_reg_note (insn, REG_EQUAL, NULL_RTX);\n+\t      if (note && reg_mentioned_p (dest, XEXP (note, 0)))\n+\t\tremove_note (insn, note);\n+\t    }\n \t}\n     }\n \n@@ -6049,14 +6142,18 @@ cse_process_notes (x, object)\n       i = REG_QTY (REGNO (x));\n \n       /* Return a constant or a constant register.  */\n-      if (REGNO_QTY_VALID_P (REGNO (x))\n-\t  && qty_const[i] != 0\n-\t  && (CONSTANT_P (qty_const[i])\n-\t      || GET_CODE (qty_const[i]) == REG))\n+      if (REGNO_QTY_VALID_P (REGNO (x)))\n \t{\n-\t  rtx new = gen_lowpart_if_possible (GET_MODE (x), qty_const[i]);\n-\t  if (new)\n-\t    return new;\n+\t  struct qty_table_elem *ent = &qty_table[i];\n+\n+\t  if (ent->const_rtx != NULL_RTX\n+\t      && (CONSTANT_P (ent->const_rtx)\n+\t\t  || GET_CODE (ent->const_rtx) == REG))\n+\t    {\n+\t      rtx new = gen_lowpart_if_possible (GET_MODE (x), ent->const_rtx);\n+\t      if (new)\n+\t\treturn new;\n+\t    }\n \t}\n \n       /* Otherwise, canonicalize this register.  */\n@@ -6615,8 +6712,8 @@ cse_main (f, nregs, after_loop, file)\n \n   max_insn_uid = get_max_uid ();\n \n-  reg_next_eqv = (int *) xmalloc (nregs * sizeof (int));\n-  reg_prev_eqv = (int *) xmalloc (nregs * sizeof (int));\n+  reg_eqv_table = (struct reg_eqv_elem *)\n+    xmalloc(nregs * sizeof(struct reg_eqv_elem));\n \n #ifdef LOAD_EXTEND_OP\n \n@@ -6753,17 +6850,13 @@ cse_main (f, nregs, after_loop, file)\n   if (ggc_p)\n     ggc_pop_context ();\n \n-  /* Tell refers_to_mem_p that qty_const info is not available.  */\n-  qty_const = 0;\n-\n   if (max_elements_made < n_elements_made)\n     max_elements_made = n_elements_made;\n \n   /* Clean up.  */\n   end_alias_analysis ();\n   free (uid_cuid);\n-  free (reg_next_eqv);\n-  free (reg_prev_eqv);\n+  free (reg_eqv_table);\n \n   return cse_jumps_altered || recorded_label_ref;\n }\n@@ -6787,28 +6880,12 @@ cse_basic_block (from, to, next_branch, around_loop)\n   rtx libcall_insn = NULL_RTX;\n   int num_insns = 0;\n \n-  /* Each of these arrays is undefined before max_reg, so only allocate\n-     the space actually needed and adjust the start below.  */\n-\n-  qty_first_reg = (int *) xmalloc ((max_qty - max_reg) * sizeof (int));\n-  qty_last_reg = (int *) xmalloc ((max_qty - max_reg) * sizeof (int));\n-  qty_mode = (enum machine_mode *) xmalloc ((max_qty - max_reg)\n-\t\t\t\t\t   * sizeof (enum machine_mode));\n-  qty_const = (rtx *) xmalloc ((max_qty - max_reg) * sizeof (rtx));\n-  qty_const_insn = (rtx *) xmalloc ((max_qty - max_reg) * sizeof (rtx));\n-  qty_comparison_code\n-    = (enum rtx_code *) xmalloc ((max_qty - max_reg) * sizeof (enum rtx_code));\n-  qty_comparison_qty = (int *) xmalloc ((max_qty - max_reg) * sizeof (int));\n-  qty_comparison_const = (rtx *) xmalloc ((max_qty - max_reg) * sizeof (rtx));\n-\n-  qty_first_reg -= max_reg;\n-  qty_last_reg -= max_reg;\n-  qty_mode -= max_reg;\n-  qty_const -= max_reg;\n-  qty_const_insn -= max_reg;\n-  qty_comparison_code -= max_reg;\n-  qty_comparison_qty -= max_reg;\n-  qty_comparison_const -= max_reg;\n+  /* This array is undefined before max_reg, so only allocate\n+     the space actually needed and adjust the start.  */\n+\n+  qty_table = (struct qty_table_elem *) xmalloc ((max_qty - max_reg)\n+\t\t\t\t\t\t * sizeof(struct qty_table_elem));\n+  qty_table -= max_reg;\n \n   new_basic_block ();\n \n@@ -6976,14 +7053,7 @@ cse_basic_block (from, to, next_branch, around_loop)\n       && LABEL_NUSES (JUMP_LABEL (PREV_INSN (to))) == 1)\n     cse_around_loop (JUMP_LABEL (PREV_INSN (to)));\n \n-  free (qty_first_reg + max_reg);\n-  free (qty_last_reg + max_reg);\n-  free (qty_mode + max_reg);\n-  free (qty_const + max_reg);\n-  free (qty_const_insn + max_reg);\n-  free (qty_comparison_code + max_reg);\n-  free (qty_comparison_qty + max_reg);\n-  free (qty_comparison_const + max_reg);\n+  free (qty_table + max_reg);\n \n   return to ? NEXT_INSN (to) : 0;\n }"}]}