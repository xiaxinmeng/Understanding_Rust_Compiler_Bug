{"sha": "b25d9e22e47f47935cd28c5df552d7bea4a45581", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjI1ZDllMjJlNDdmNDc5MzVjZDI4YzVkZjU1MmQ3YmVhNGE0NTU4MQ==", "commit": {"author": {"name": "Tom de Vries", "email": "tom@codesourcery.com", "date": "2012-09-15T21:00:33Z"}, "committer": {"name": "Tom de Vries", "email": "vries@gcc.gnu.org", "date": "2012-09-15T21:00:33Z"}, "message": "tree-vrp.c (extract_range_from_binary_expr_1): Fix bug in handling of LSHIFT_EXPR with shift range.\n\n2012-09-15  Tom de Vries  <tom@codesourcery.com>\n\n\t* tree-vrp.c (extract_range_from_binary_expr_1): Fix bug in handling of\n\tLSHIFT_EXPR with shift range.  Handle more LSHIFT_EXPR cases with shift\n\trange.\n\nFrom-SVN: r191351", "tree": {"sha": "8016b093f8efa67a0b865e63857661f6a988f589", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8016b093f8efa67a0b865e63857661f6a988f589"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b25d9e22e47f47935cd28c5df552d7bea4a45581", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b25d9e22e47f47935cd28c5df552d7bea4a45581", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b25d9e22e47f47935cd28c5df552d7bea4a45581", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b25d9e22e47f47935cd28c5df552d7bea4a45581/comments", "author": null, "committer": null, "parents": [{"sha": "583aa11c6bacdaa2be9d47226ec925ad24db76c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/583aa11c6bacdaa2be9d47226ec925ad24db76c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/583aa11c6bacdaa2be9d47226ec925ad24db76c2"}], "stats": {"total": 65, "additions": 57, "deletions": 8}, "files": [{"sha": "a5106a95fd883fbd612958aaec8ef1b85e72598f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25d9e22e47f47935cd28c5df552d7bea4a45581/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25d9e22e47f47935cd28c5df552d7bea4a45581/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b25d9e22e47f47935cd28c5df552d7bea4a45581", "patch": "@@ -1,3 +1,9 @@\n+2012-09-15  Tom de Vries  <tom@codesourcery.com>\n+\n+\t* tree-vrp.c (extract_range_from_binary_expr_1): Fix bug in handling of\n+\tLSHIFT_EXPR with shift range.  Handle more LSHIFT_EXPR cases with shift\n+\trange.\n+\n 2012-09-15  Georg-Johann Lay  <avr@gjlay.de>\n \n \tPR target/54222"}, {"sha": "34f1d1aaf66de6554482124bd7d9289190a4c05d", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 51, "deletions": 8, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25d9e22e47f47935cd28c5df552d7bea4a45581/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25d9e22e47f47935cd28c5df552d7bea4a45581/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=b25d9e22e47f47935cd28c5df552d7bea4a45581", "patch": "@@ -2766,20 +2766,63 @@ extract_range_from_binary_expr_1 (value_range_t *vr,\n \t  else if (code == LSHIFT_EXPR\n \t\t   && range_int_cst_p (&vr0))\n \t    {\n-\t      int overflow_pos = TYPE_PRECISION (expr_type);\n+\t      int prec = TYPE_PRECISION (expr_type);\n+\t      int overflow_pos = prec;\n \t      int bound_shift;\n-\t      double_int bound;\n+\t      double_int bound, complement, low_bound, high_bound;\n+\t      bool uns = TYPE_UNSIGNED (expr_type);\n+\t      bool in_bounds = false;\n \n-\t      if (!TYPE_UNSIGNED (expr_type))\n+\t      if (!uns)\n \t\toverflow_pos -= 1;\n \n \t      bound_shift = overflow_pos - TREE_INT_CST_LOW (vr1.max);\n-\t      bound = double_int_one.llshift (bound_shift,\n-\t\t\t\t\t      TYPE_PRECISION (expr_type));\n-\t      if (tree_to_double_int (vr0.max).ult (bound))\n+\t      /* If bound_shift == HOST_BITS_PER_DOUBLE_INT, the llshift can\n+\t\t overflow.  However, for that to happen, vr1.max needs to be\n+\t\t zero, which means vr1 is a singleton range of zero, which\n+\t\t means it should be handled by the previous LSHIFT_EXPR\n+\t\t if-clause.  */\n+\t      bound = double_int_one.llshift (bound_shift, prec);\n+\t      complement = ~(bound - double_int_one);\n+\n+\t      if (uns)\n+\t\t{\n+\t\t  low_bound = bound;\n+\t\t  high_bound = complement.zext (prec);\n+\t\t  if (tree_to_double_int (vr0.max).ult (low_bound))\n+\t\t    {\n+\t\t      /* [5, 6] << [1, 2] == [10, 24].  */\n+\t\t      /* We're shifting out only zeroes, the value increases\n+\t\t\t monotonically.  */\n+\t\t      in_bounds = true;\n+\t\t    }\n+\t\t  else if (high_bound.ult (tree_to_double_int (vr0.min)))\n+\t\t    {\n+\t\t      /* [0xffffff00, 0xffffffff] << [1, 2]\n+\t\t         == [0xfffffc00, 0xfffffffe].  */\n+\t\t      /* We're shifting out only ones, the value decreases\n+\t\t\t monotonically.  */\n+\t\t      in_bounds = true;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* [-1, 1] << [1, 2] == [-4, 4].  */\n+\t\t  low_bound = complement.sext (prec);\n+\t\t  high_bound = bound;\n+\t\t  if (tree_to_double_int (vr0.max).slt (high_bound)\n+\t\t      && low_bound.slt (tree_to_double_int (vr0.min)))\n+\t\t    {\n+\t\t      /* For non-negative numbers, we're shifting out only\n+\t\t\t zeroes, the value increases monotonically.\n+\t\t\t For negative numbers, we're shifting out only ones, the\n+\t\t\t value decreases monotomically.  */\n+\t\t      in_bounds = true;\n+\t\t    }\n+\t\t}\n+\n+\t      if (in_bounds)\n \t\t{\n-\t\t  /* In the absense of overflow, (a << b) is equivalent\n-\t\t     to (a * 2^b).  */\n \t\t  extract_range_from_multiplicative_op_1 (vr, code, &vr0, &vr1);\n \t\t  return;\n \t\t}"}]}