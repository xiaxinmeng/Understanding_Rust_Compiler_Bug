{"sha": "05101d1b575a57ca26e4275e971da85a0dd1d52a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDUxMDFkMWI1NzVhNTdjYTI2ZTQyNzVlOTcxZGE4NWEwZGQxZDUyYQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-11-14T15:16:40Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-11-14T15:16:40Z"}, "message": "Allow mixed vector sizes within a single vectorised stmt\n\nAlthough a previous patch allowed mixed vector sizes within a vector\nregion, we generally still required equal vector sizes within a vector\nstmt.  Specifically, vect_get_vector_types_for_stmt computes two vector\ntypes: the vector type corresponding to STMT_VINFO_VECTYPE and the\nvector type that determines the minimum vectorisation factor for the\nstmt (\"nunits_vectype\").  It then required these two types to be\nthe same size.\n\nThere doesn't seem to be any need for that restriction though.  AFAICT,\nall vectorizable_* functions either do their own compatibility checks\nor don't need to do them (because gimple guarantees that the scalar\ntypes are compatible).\n\nIt should always be the case that nunits_vectype has at least as many\nelements as the other vectype, but that's something we can assert for.\n\nI couldn't resist a couple of other tweaks while there:\n\n- there's no need to compute nunits_vectype if its element type is\n  the same as STMT_VINFO_VECTYPE's.\n\n- it's useful to distinguish the nunits_vectype from the main vectype\n  in dump messages\n\n- when reusing the existing STMT_VINFO_VECTYPE, it's useful to say so\n  in the dump, and say what the type is\n\n2019-11-14  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-vect-stmts.c (vect_get_vector_types_for_stmt): Don't\n\trequire vectype and nunits_vectype to have the same size;\n\tinstead assert that nunits_vectype has at least as many\n\telements as vectype.  Don't compute a separate nunits_vectype\n\tif the scalar type is obviously the same as vectype's.\n\tTweak dump messages.\n\nFrom-SVN: r278244", "tree": {"sha": "078be5300253c526cd4166b2aa26d4e2433c135d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/078be5300253c526cd4166b2aa26d4e2433c135d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/05101d1b575a57ca26e4275e971da85a0dd1d52a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05101d1b575a57ca26e4275e971da85a0dd1d52a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05101d1b575a57ca26e4275e971da85a0dd1d52a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05101d1b575a57ca26e4275e971da85a0dd1d52a/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "74166aabeb7f22990476b1169bba031b8323ee92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74166aabeb7f22990476b1169bba031b8323ee92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74166aabeb7f22990476b1169bba031b8323ee92"}], "stats": {"total": 64, "additions": 37, "deletions": 27}, "files": [{"sha": "6bb0a80e19db96916a9bcf3f5a4f00a5b2fc3552", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05101d1b575a57ca26e4275e971da85a0dd1d52a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05101d1b575a57ca26e4275e971da85a0dd1d52a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=05101d1b575a57ca26e4275e971da85a0dd1d52a", "patch": "@@ -1,3 +1,12 @@\n+2019-11-14  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vect-stmts.c (vect_get_vector_types_for_stmt): Don't\n+\trequire vectype and nunits_vectype to have the same size;\n+\tinstead assert that nunits_vectype has at least as many\n+\telements as vectype.  Don't compute a separate nunits_vectype\n+\tif the scalar type is obviously the same as vectype's.\n+\tTweak dump messages.\n+\n 2019-11-14  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* config/aarch64/aarch64.c (aarch64_vectorize_related_mode): New"}, {"sha": "5f30d1e84f5fbb64a4fb3a72a9bf1d5ffb461805", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 28, "deletions": 27, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05101d1b575a57ca26e4275e971da85a0dd1d52a/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05101d1b575a57ca26e4275e971da85a0dd1d52a/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=05101d1b575a57ca26e4275e971da85a0dd1d52a", "patch": "@@ -12018,7 +12018,12 @@ vect_get_vector_types_for_stmt (stmt_vec_info stmt_info,\n   tree vectype;\n   tree scalar_type = NULL_TREE;\n   if (STMT_VINFO_VECTYPE (stmt_info))\n-    *stmt_vectype_out = vectype = STMT_VINFO_VECTYPE (stmt_info);\n+    {\n+      *stmt_vectype_out = vectype = STMT_VINFO_VECTYPE (stmt_info);\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"precomputed vectype: %T\\n\", vectype);\n+    }\n   else\n     {\n       gcc_assert (!STMT_VINFO_DATA_REF (stmt_info));\n@@ -12050,7 +12055,7 @@ vect_get_vector_types_for_stmt (stmt_vec_info stmt_info,\n \n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t \"get vectype for scalar type:  %T\\n\", scalar_type);\n+\t\t\t \"get vectype for scalar type: %T\\n\", scalar_type);\n       vectype = get_vectype_for_scalar_type (vinfo, scalar_type);\n       if (!vectype)\n \treturn opt_result::failure_at (stmt,\n@@ -12067,42 +12072,38 @@ vect_get_vector_types_for_stmt (stmt_vec_info stmt_info,\n \n   /* Don't try to compute scalar types if the stmt produces a boolean\n      vector; use the existing vector type instead.  */\n-  tree nunits_vectype;\n-  if (VECTOR_BOOLEAN_TYPE_P (vectype))\n-    nunits_vectype = vectype;\n-  else\n+  tree nunits_vectype = vectype;\n+  if (!VECTOR_BOOLEAN_TYPE_P (vectype)\n+      && *stmt_vectype_out != boolean_type_node)\n     {\n       /* The number of units is set according to the smallest scalar\n \t type (or the largest vector size, but we only support one\n \t vector size per vectorization).  */\n-      if (*stmt_vectype_out != boolean_type_node)\n+      HOST_WIDE_INT dummy;\n+      scalar_type = vect_get_smallest_scalar_type (stmt_info, &dummy, &dummy);\n+      if (scalar_type != TREE_TYPE (vectype))\n \t{\n-\t  HOST_WIDE_INT dummy;\n-\t  scalar_type = vect_get_smallest_scalar_type (stmt_info,\n-\t\t\t\t\t\t       &dummy, &dummy);\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"get vectype for smallest scalar type: %T\\n\",\n+\t\t\t     scalar_type);\n+\t  nunits_vectype = get_vectype_for_scalar_type (vinfo, scalar_type);\n+\t  if (!nunits_vectype)\n+\t    return opt_result::failure_at\n+\t      (stmt, \"not vectorized: unsupported data-type %T\\n\",\n+\t       scalar_type);\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_NOTE, vect_location, \"nunits vectype: %T\\n\",\n+\t\t\t     nunits_vectype);\n \t}\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t \"get vectype for scalar type:  %T\\n\", scalar_type);\n-      nunits_vectype = get_vectype_for_scalar_type (vinfo, scalar_type);\n     }\n-  if (!nunits_vectype)\n-    return opt_result::failure_at (stmt,\n-\t\t\t\t   \"not vectorized: unsupported data-type %T\\n\",\n-\t\t\t\t   scalar_type);\n \n-  if (maybe_ne (GET_MODE_SIZE (TYPE_MODE (vectype)),\n-\t\tGET_MODE_SIZE (TYPE_MODE (nunits_vectype))))\n-    return opt_result::failure_at (stmt,\n-\t\t\t\t   \"not vectorized: different sized vector \"\n-\t\t\t\t   \"types in statement, %T and %T\\n\",\n-\t\t\t\t   vectype, nunits_vectype);\n+  gcc_assert (*stmt_vectype_out == boolean_type_node\n+\t      || multiple_p (TYPE_VECTOR_SUBPARTS (nunits_vectype),\n+\t\t\t     TYPE_VECTOR_SUBPARTS (*stmt_vectype_out)));\n \n   if (dump_enabled_p ())\n     {\n-      dump_printf_loc (MSG_NOTE, vect_location, \"vectype: %T\\n\",\n-\t\t       nunits_vectype);\n-\n       dump_printf_loc (MSG_NOTE, vect_location, \"nunits = \");\n       dump_dec (MSG_NOTE, TYPE_VECTOR_SUBPARTS (nunits_vectype));\n       dump_printf (MSG_NOTE, \"\\n\");"}]}