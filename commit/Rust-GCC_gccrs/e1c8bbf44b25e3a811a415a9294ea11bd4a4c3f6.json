{"sha": "e1c8bbf44b25e3a811a415a9294ea11bd4a4c3f6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTFjOGJiZjQ0YjI1ZTNhODExYTQxNWE5Mjk0ZWExMWJkNGE0YzNmNg==", "commit": {"author": {"name": "Charles Hannum", "email": "mycroft@gnu.org", "date": "1992-01-15T13:17:00Z"}, "committer": {"name": "Charles Hannum", "email": "mycroft@gnu.org", "date": "1992-01-15T13:17:00Z"}, "message": "entered into RCS\n\nFrom-SVN: r188", "tree": {"sha": "426f0b3fb99d31117ebd5c129c48e58f93d0f54b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/426f0b3fb99d31117ebd5c129c48e58f93d0f54b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e1c8bbf44b25e3a811a415a9294ea11bd4a4c3f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1c8bbf44b25e3a811a415a9294ea11bd4a4c3f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1c8bbf44b25e3a811a415a9294ea11bd4a4c3f6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1c8bbf44b25e3a811a415a9294ea11bd4a4c3f6/comments", "author": null, "committer": null, "parents": [{"sha": "2042e9d2d12a057728412add10b17b7c66999339", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2042e9d2d12a057728412add10b17b7c66999339", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2042e9d2d12a057728412add10b17b7c66999339"}], "stats": {"total": 220, "additions": 220, "deletions": 0}, "files": [{"sha": "9f49115af8b0da0095bc8f9542ec0e6d17e577e9", "filename": "gcc/config/convex/convex.c", "status": "added", "additions": 220, "deletions": 0, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1c8bbf44b25e3a811a415a9294ea11bd4a4c3f6/gcc%2Fconfig%2Fconvex%2Fconvex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1c8bbf44b25e3a811a415a9294ea11bd4a4c3f6/gcc%2Fconfig%2Fconvex%2Fconvex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fconvex%2Fconvex.c?ref=e1c8bbf44b25e3a811a415a9294ea11bd4a4c3f6", "patch": "@@ -0,0 +1,220 @@\n+/* Subroutines for insn-output.c for Convex.\n+   Copyright (C) 1989,1991 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 1, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"insn-flags.h\"\n+#include \"output.h\"\n+#include \"insn-attr.h\"\n+\n+/* Boolean to keep track of whether the current section is .text or not.\n+   Used by .align handler in convex.h. */\n+\n+int current_section_is_text;\n+\n+/* set_cmp saves the operands of a \"cmp\" insn, along with the type character\n+ * to be used in the compare instruction.\n+ *\n+ * gen_cmp finds out what comparison is to be performed and outputs the\n+ * necessary instructions, e.g.\n+ *    \"eq.w a1,a2\\;jbra.t L5\"\n+ * for (cmpsi a1 a2) (beq L5)  */\n+ \n+static rtx xop0, xop1;\n+static char typech, regch;\n+\n+char *\n+set_cmp (op0, op1, typechr)\n+     rtx op0, op1;\n+     char typechr;\n+{\n+  xop0 = op0;\n+  xop1 = op1;\n+  typech = typechr;\n+  if (GET_CODE (op0) == REG)\n+    regch = A_REGNO_P (REGNO (op0)) ? 'a' : 's';\n+  else if (GET_CODE (op1) == REG)\n+    regch = A_REGNO_P (REGNO (op1)) ? 'a' : 's';\n+  else abort ();\n+  return \"\";\n+}\n+\n+char *\n+gen_cmp (label, cmpop, tf)\n+     rtx label;\n+     char *cmpop;\n+     char tf;\n+{\n+  char buf[80];\n+  char revop[4];\n+  rtx ops[3];\n+\n+  ops[2] = label;\n+\n+  /* Constant must be first; swap operands if necessary.\n+     If lt, le, ltu, leu are swapped, change to le, lt, leu, ltu\n+     and reverse the sense of the jump. */\n+\n+  if (CONSTANT_P (xop1))\n+    {\n+      ops[0] = xop1;\n+      ops[1] = xop0;\n+      if (cmpop[0] == 'l')\n+\t{\n+\t  bcopy (cmpop, revop, sizeof revop);\n+\t  revop[1] ^= 'e' ^ 't';\n+\t  tf ^= 't' ^ 'f';\n+\t  cmpop = revop;\n+\t}\n+    }\n+  else\n+    {\n+      ops[0] = xop0;\n+      ops[1] = xop1;\n+    }\n+\n+  sprintf (buf, \"%s.%c %%0,%%1\\n\\tjbr%c.%c %%l2\", cmpop, typech, regch, tf);\n+  output_asm_insn (buf, ops);\n+  return \"\";\n+}\n+\f\n+/* Routines to separate CONST_DOUBLEs into component parts. */\n+\n+int\n+const_double_high_int (x)\n+     rtx x;\n+{\n+  if (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)\n+    return CONST_DOUBLE_LOW (x);\n+  else\n+    return CONST_DOUBLE_HIGH (x);\n+}\n+\n+int\n+const_double_low_int (x)\n+     rtx x;\n+{\n+  if (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)\n+    return CONST_DOUBLE_HIGH (x);\n+  else\n+    return CONST_DOUBLE_LOW (x);\n+}\n+\f\n+/* Return the number of args in the call insn X. */\n+\n+static int\n+call_num_args (x)\n+     rtx x;\n+{\n+  if (GET_CODE (x) == CALL)\n+    return INTVAL (x->fld[1].rtx);\n+  if (GET_CODE (x) == SET)\n+    return call_num_args (SET_SRC (x));\n+  abort ();\n+}\n+\n+/* Scan forward from a call to decide whether we need to reload AP\n+   from 12(FP) after it.  We need to if there can be a reference to\n+   arg_pointer_rtx before the next call, which will clobber AP.\n+   Look forward in the instruction list until encountering a call\n+   (don't need the load), or a reference to AP (do need it), or\n+   a jump (don't know, do the load).  */\n+\n+static int\n+ap_reload_needed (insn)\n+     rtx insn;\n+{\n+  for (;;)\n+    {\n+      insn = NEXT_INSN (insn);\n+      switch (GET_CODE (insn))\n+\t{\n+\tcase JUMP_INSN:\n+\t  /* Basic block ends.  If return, no AP needed, else assume it is. */\n+\t  return GET_CODE (PATTERN (insn)) != RETURN;\n+\tcase CALL_INSN:\n+\t  /* A subsequent call.  AP isn't needed unless the call itself\n+\t     requires it.  But zero-arg calls don't clobber AP, so\n+\t     don't terminate the search in that case. */\n+\t  if (reg_mentioned_p (arg_pointer_rtx, PATTERN (insn)))\n+\t    return 1;\n+\t  if (! TARGET_ARGCOUNT && call_num_args (PATTERN (insn)) == 0)\n+\t    break;\n+\t  return 0;\n+\tcase BARRIER:\n+\t  /* Barrier, don't need AP. */\n+\t  return 0;\n+\tcase INSN:\n+\t  /* Other insn may need AP; if not, keep looking. */\n+\t  if (reg_mentioned_p (arg_pointer_rtx, PATTERN (insn)))\n+\t    return 1;\n+\t}\n+    }\n+}\n+\n+/* Output the insns needed to do a call. */\n+\n+char *\n+output_call (insn, address, argcount)\n+    rtx insn, address, argcount;\n+{\n+  int set_ap = TARGET_ARGCOUNT || argcount != const0_rtx;\n+\n+  /* If AP is used by the call address, evaluate the address into a temp. */\n+  if (reg_mentioned_p (arg_pointer_rtx, address))\n+    if (set_ap)\n+      {\n+\taddress = XEXP (address, 0);\n+\toutput_asm_insn (\"ld.w %0,a1\", &address);\n+\taddress = gen_rtx (MEM, QImode, gen_rtx (REG, Pmode, 9));\n+      }\n+\n+  /* If there are args, point AP to them. */\n+  if (set_ap)\n+    output_asm_insn (\"mov sp,ap\");\n+\n+  /* If we are passing an arg count, convert it to words and push it. */\n+  if (TARGET_ARGCOUNT)\n+    {\n+      argcount = gen_rtx (CONST_INT, VOIDmode, (INTVAL (argcount) + 3) / 4);\n+      output_asm_insn (\"pshea %a0\", &argcount);\n+    }\n+\n+  /* The call. */\n+  output_asm_insn (\"calls %0\", &address);\n+\n+  /* If we clobbered AP, reload it if it is live. */\n+  if (set_ap)\n+    if (ap_reload_needed (insn))\n+      output_asm_insn (\"ld.w 12(fp),ap\");\n+\n+  /* If we pushed an arg count, pop it and the args. */\n+  if (TARGET_ARGCOUNT)\n+    {\n+      argcount = gen_rtx (CONST_INT, VOIDmode, INTVAL (argcount) * 4 + 4);\n+      output_asm_insn (\"add.w %0,sp\", &argcount);\n+    }\n+  \n+  return \"\";\n+}"}]}