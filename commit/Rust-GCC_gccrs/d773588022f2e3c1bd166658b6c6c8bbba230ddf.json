{"sha": "d773588022f2e3c1bd166658b6c6c8bbba230ddf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDc3MzU4ODAyMmYyZTNjMWJkMTY2NjU4YjZjNmM4YmJiYTIzMGRkZg==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2005-11-22T00:38:30Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2005-11-22T00:38:30Z"}, "message": "fp-bit.c (clzusi): New function.\n\n\t* config/fp-bit.c (clzusi): New function.\n\t(si_to_float, usi_to_float): Use it to compute proper shift.\n\t(usi_to_float): Preserve guard bits when shifting right.\n\t* libgcc-std.ver (GCC_4.2.0): New version.\n\t* libgcc2.c (__floatundixf, __floatunditf, __floatundidf,\n\t__floatundisf): New functions.\n\t* libgcc2.h (__floatundixf, __floatunditf, __floatundidf,\n\t__floatundisf): Declare.\n\t* mklibgcc.in (lib2funcs): Add _floatundidf, _floatundisf,\n\t_floatundixf, and _floatunditf.\n\t* optabs.c (expand_float): If target does not define a pattern for\n\tsigned or unsigned conversion, use an unsigned libcall instead of\n\ta signed one.\n\t(init_optabs): Initialize ufloat_optab.\n\ntestsuite:\n\t* gcc.c-torture/execute/floatunsisf-1.c: New test.\n\nFrom-SVN: r107345", "tree": {"sha": "cf1224f63a9636c4333be5cb2d3cabfe2eec233d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf1224f63a9636c4333be5cb2d3cabfe2eec233d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d773588022f2e3c1bd166658b6c6c8bbba230ddf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d773588022f2e3c1bd166658b6c6c8bbba230ddf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d773588022f2e3c1bd166658b6c6c8bbba230ddf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d773588022f2e3c1bd166658b6c6c8bbba230ddf/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "131aeb82d18736392c992c79c2184b2ad16c6190", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/131aeb82d18736392c992c79c2184b2ad16c6190", "html_url": "https://github.com/Rust-GCC/gccrs/commit/131aeb82d18736392c992c79c2184b2ad16c6190"}], "stats": {"total": 248, "additions": 231, "deletions": 17}, "files": [{"sha": "0fa5ae51e4070db48bfe65e40cf7a25be8a687a3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d773588022f2e3c1bd166658b6c6c8bbba230ddf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d773588022f2e3c1bd166658b6c6c8bbba230ddf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d773588022f2e3c1bd166658b6c6c8bbba230ddf", "patch": "@@ -1,3 +1,20 @@\n+2005-11-22  Joseph S. Myers  <joseph@codesourcery.com>\n+\n+\t* config/fp-bit.c (clzusi): New function.\n+\t(si_to_float, usi_to_float): Use it to compute proper shift.\n+\t(usi_to_float): Preserve guard bits when shifting right.\n+\t* libgcc-std.ver (GCC_4.2.0): New version.\n+\t* libgcc2.c (__floatundixf, __floatunditf, __floatundidf,\n+\t__floatundisf): New functions.\n+\t* libgcc2.h (__floatundixf, __floatunditf, __floatundidf,\n+\t__floatundisf): Declare.\n+\t* mklibgcc.in (lib2funcs): Add _floatundidf, _floatundisf,\n+\t_floatundixf, and _floatunditf.\n+\t* optabs.c (expand_float): If target does not define a pattern for\n+\tsigned or unsigned conversion, use an unsigned libcall instead of\n+\ta signed one.\n+\t(init_optabs): Initialize ufloat_optab.\n+\n 2005-11-22  Joseph S. Myers  <joseph@codesourcery.com>\n \n \t* config/rs6000/rs6000.opt (mmulhw): New option."}, {"sha": "ccf927e8c3bc667980f7f208d50f5dd7417d6081", "filename": "gcc/config/fp-bit.c", "status": "modified", "additions": 37, "deletions": 13, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d773588022f2e3c1bd166658b6c6c8bbba230ddf/gcc%2Fconfig%2Ffp-bit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d773588022f2e3c1bd166658b6c6c8bbba230ddf/gcc%2Fconfig%2Ffp-bit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffp-bit.c?ref=d773588022f2e3c1bd166658b6c6c8bbba230ddf", "patch": "@@ -186,6 +186,22 @@ flip_sign ( fp_number_type *  x)\n   x->sign = !x->sign;\n }\n \n+/* Count leading zeroes in N.  */\n+INLINE\n+static int\n+clzusi (USItype n)\n+{\n+  extern int __clzsi2 (USItype);\n+  if (sizeof (USItype) == sizeof (unsigned int))\n+    return __builtin_clz (n);\n+  else if (sizeof (USItype) == sizeof (unsigned long))\n+    return __builtin_clzl (n);\n+  else if (sizeof (USItype) == sizeof (unsigned long long))\n+    return __builtin_clzll (n);\n+  else\n+    return __clzsi2 (n);\n+}\n+\n extern FLO_type pack_d ( fp_number_type * );\n \n #if defined(L_pack_df) || defined(L_pack_sf) || defined(L_pack_tf)\n@@ -1334,6 +1350,8 @@ si_to_float (SItype arg_a)\n     }\n   else\n     {\n+      USItype uarg;\n+      int shift;\n       in.normal_exp = FRACBITS + NGARDS;\n       if (in.sign) \n \t{\n@@ -1343,15 +1361,17 @@ si_to_float (SItype arg_a)\n \t    {\n \t      return (FLO_type)(- MAX_SI_INT - 1);\n \t    }\n-\t  in.fraction.ll = (-arg_a);\n+\t  uarg = (-arg_a);\n \t}\n       else\n-\tin.fraction.ll = arg_a;\n+\tuarg = arg_a;\n \n-      while (in.fraction.ll < ((fractype)1 << (FRACBITS + NGARDS)))\n+      in.fraction.ll = uarg;\n+      shift = clzusi (uarg) - (BITS_PER_SI - 1 - FRACBITS - NGARDS);\n+      if (shift > 0)\n \t{\n-\t  in.fraction.ll <<= 1;\n-\t  in.normal_exp -= 1;\n+\t  in.fraction.ll <<= shift;\n+\t  in.normal_exp -= shift;\n \t}\n     }\n   return pack_d (&in);\n@@ -1371,19 +1391,23 @@ usi_to_float (USItype arg_a)\n     }\n   else\n     {\n+      int shift;\n       in.class = CLASS_NUMBER;\n       in.normal_exp = FRACBITS + NGARDS;\n       in.fraction.ll = arg_a;\n \n-      while (in.fraction.ll > ((fractype)1 << (FRACBITS + NGARDS)))\n-        {\n-          in.fraction.ll >>= 1;\n-          in.normal_exp += 1;\n-        }\n-      while (in.fraction.ll < ((fractype)1 << (FRACBITS + NGARDS)))\n+      shift = clzusi (arg_a) - (BITS_PER_SI - 1 - FRACBITS - NGARDS);\n+      if (shift < 0)\n+\t{\n+\t  fractype guard = in.fraction.ll & (((fractype)1 << -shift) - 1);\n+\t  in.fraction.ll >>= -shift;\n+\t  in.fraction.ll |= (guard != 0);\n+\t  in.normal_exp -= shift;\n+\t}\n+      else if (shift > 0)\n \t{\n-\t  in.fraction.ll <<= 1;\n-\t  in.normal_exp -= 1;\n+\t  in.fraction.ll <<= shift;\n+\t  in.normal_exp -= shift;\n \t}\n     }\n   return pack_d (&in);"}, {"sha": "a98ddb463a21a0b912c5fd20a9a481a4845182c6", "filename": "gcc/libgcc-std.ver", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d773588022f2e3c1bd166658b6c6c8bbba230ddf/gcc%2Flibgcc-std.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d773588022f2e3c1bd166658b6c6c8bbba230ddf/gcc%2Flibgcc-std.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc-std.ver?ref=d773588022f2e3c1bd166658b6c6c8bbba230ddf", "patch": "@@ -252,3 +252,20 @@ GCC_4.0.0 {\n   __mulxc3\n   __multc3\n }\n+\n+%inherit GCC_4.2.0 GCC_4.0.0\n+GCC_4.2.0 {\n+  # unsigned-to-floating conversions\n+  __floatunsisf\n+  __floatunsidf\n+  __floatunsixf\n+  __floatunsitf\n+  __floatundidf\n+  __floatundisf\n+  __floatundixf\n+  __floatunditf\n+  __floatuntidf\n+  __floatuntisf\n+  __floatuntixf\n+  __floatuntitf\n+}"}, {"sha": "94f4b30006abf625d6011b4e257c08f9fa6b3202", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d773588022f2e3c1bd166658b6c6c8bbba230ddf/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d773588022f2e3c1bd166658b6c6c8bbba230ddf/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=d773588022f2e3c1bd166658b6c6c8bbba230ddf", "patch": "@@ -1323,6 +1323,17 @@ __floatdixf (DWtype u)\n }\n #endif\n \n+#if defined(L_floatundixf) && LIBGCC2_HAS_XF_MODE\n+XFtype\n+__floatundixf (UDWtype u)\n+{\n+  XFtype d = (UWtype) (u >> W_TYPE_SIZE);\n+  d *= Wtype_MAXp1_F;\n+  d += (UWtype)u;\n+  return d;\n+}\n+#endif\n+\n #if defined(L_floatditf) && LIBGCC2_HAS_TF_MODE\n TFtype\n __floatditf (DWtype u)\n@@ -1334,6 +1345,17 @@ __floatditf (DWtype u)\n }\n #endif\n \n+#if defined(L_floatunditf) && LIBGCC2_HAS_TF_MODE\n+TFtype\n+__floatunditf (UDWtype u)\n+{\n+  TFtype d = (UWtype) (u >> W_TYPE_SIZE);\n+  d *= Wtype_MAXp1_F;\n+  d += (UWtype)u;\n+  return d;\n+}\n+#endif\n+\n #if defined(L_floatdidf) && LIBGCC2_HAS_DF_MODE\n DFtype\n __floatdidf (DWtype u)\n@@ -1345,6 +1367,17 @@ __floatdidf (DWtype u)\n }\n #endif\n \n+#if defined(L_floatundidf) && LIBGCC2_HAS_DF_MODE\n+DFtype\n+__floatundidf (UDWtype u)\n+{\n+  DFtype d = (UWtype) (u >> W_TYPE_SIZE);\n+  d *= Wtype_MAXp1_F;\n+  d += (UWtype)u;\n+  return d;\n+}\n+#endif\n+\n #if defined(L_floatdisf) && LIBGCC2_HAS_SF_MODE\n #define DI_SIZE (W_TYPE_SIZE * 2)\n #define SF_SIZE FLT_MANT_DIG\n@@ -1433,6 +1466,87 @@ __floatdisf (DWtype u)\n }\n #endif\n \n+#if defined(L_floatundisf) && LIBGCC2_HAS_SF_MODE\n+#define DI_SIZE (W_TYPE_SIZE * 2)\n+#define SF_SIZE FLT_MANT_DIG\n+\n+SFtype\n+__floatundisf (UDWtype u)\n+{\n+#if SF_SIZE >= W_TYPE_SIZE\n+  /* When the word size is small, we never get any rounding error.  */\n+  SFtype f = (UWtype) (u >> W_TYPE_SIZE);\n+  f *= Wtype_MAXp1_F;\n+  f += (UWtype)u;\n+  return f;\n+#elif LIBGCC2_HAS_DF_MODE\n+\n+#if LIBGCC2_DOUBLE_TYPE_SIZE == 64\n+#define DF_SIZE DBL_MANT_DIG\n+#elif LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 64\n+#define DF_SIZE LDBL_MANT_DIG\n+#else\n+# error\n+#endif\n+\n+#define REP_BIT ((UDWtype) 1 << (DI_SIZE - DF_SIZE))\n+\n+  /* Protect against double-rounding error.\n+     Represent any low-order bits, that might be truncated by a bit that\n+     won't be lost.  The bit can go in anywhere below the rounding position\n+     of the SFmode.  A fixed mask and bit position handles all usual\n+     configurations.  It doesn't handle the case of 128-bit DImode, however.  */\n+  if (DF_SIZE < DI_SIZE\n+      && DF_SIZE > (DI_SIZE - DF_SIZE + SF_SIZE))\n+    {\n+      if (u >= ((UDWtype) 1 << DF_SIZE))\n+\t{\n+\t  if ((UDWtype) u & (REP_BIT - 1))\n+\t    {\n+\t      u &= ~ (REP_BIT - 1);\n+\t      u |= REP_BIT;\n+\t    }\n+\t}\n+    }\n+\n+  /* Do the calculation in DFmode so that we don't lose any of the\n+     precision of the high word while multiplying it.  */\n+  DFtype f = (UWtype) (u >> W_TYPE_SIZE);\n+  f *= Wtype_MAXp1_F;\n+  f += (UWtype)u;\n+  return (SFtype) f;\n+#else\n+  /* Finally, the word size is larger than the number of bits in SFmode,\n+     and we've got no DFmode.  The only way to avoid double rounding is\n+     to special case the extraction.  */\n+\n+  /* If there are no high bits set, fall back to one conversion.  */\n+  if ((UWtype)u == u)\n+    return (SFtype)(UWtype)u;\n+\n+  /* Otherwise, find the power of two.  */\n+  UWtype hi = u >> W_TYPE_SIZE;\n+\n+  UWtype count, shift;\n+  count_leading_zeros (count, hi);\n+\n+  shift = W_TYPE_SIZE - count;\n+\n+  /* Shift down the most significant bits.  */\n+  hi = u >> shift;\n+\n+  /* If we lost any nonzero bits, set the lsb to ensure correct rounding.  */\n+  if (u & ((1 << shift) - 1))\n+    hi |= 1;\n+\n+  /* Convert the one word of data, and rescale.  */\n+  SFtype f = hi;\n+  f *= (UWtype)1 << shift;\n+  return f;\n+#endif\n+}\n+#endif\n+\n #if defined(L_fixunsxfsi) && LIBGCC2_HAS_XF_MODE\n /* Reenable the normal types, in case limits.h needs them.  */\n #undef char"}, {"sha": "11a1d9a3ff81ce845555de24baecd824eb1b5945", "filename": "gcc/libgcc2.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d773588022f2e3c1bd166658b6c6c8bbba230ddf/gcc%2Flibgcc2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d773588022f2e3c1bd166658b6c6c8bbba230ddf/gcc%2Flibgcc2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.h?ref=d773588022f2e3c1bd166658b6c6c8bbba230ddf", "patch": "@@ -238,6 +238,10 @@ typedef int word_type __attribute__ ((mode (__word__)));\n #define __floatditf\t__NDW(float,tf)\n #define __floatdidf\t__NDW(float,df)\n #define __floatdisf\t__NDW(float,sf)\n+#define __floatundixf\t__NDW(floatun,xf)\n+#define __floatunditf\t__NDW(floatun,tf)\n+#define __floatundidf\t__NDW(floatun,df)\n+#define __floatundisf\t__NDW(floatun,sf)\n #define __fixunsxfSI\t__NW(fixunsxf,)\n #define __fixunstfSI\t__NW(fixunstf,)\n #define __fixunsdfSI\t__NW(fixunsdf,)\n@@ -318,6 +322,7 @@ extern SItype __negvsi2 (SItype);\n #if LIBGCC2_HAS_SF_MODE\n extern DWtype __fixsfdi (SFtype);\n extern SFtype __floatdisf (DWtype);\n+extern SFtype __floatundisf (UDWtype);\n extern UWtype __fixunssfSI (SFtype);\n extern DWtype __fixunssfDI (SFtype);\n extern SFtype __powisf2 (SFtype, int);\n@@ -327,6 +332,7 @@ extern SCtype __mulsc3 (SFtype, SFtype, SFtype, SFtype);\n #if LIBGCC2_HAS_DF_MODE\n extern DWtype __fixdfdi (DFtype);\n extern DFtype __floatdidf (DWtype);\n+extern DFtype __floatundidf (UDWtype);\n extern UWtype __fixunsdfSI (DFtype);\n extern DWtype __fixunsdfDI (DFtype);\n extern DFtype __powidf2 (DFtype, int);\n@@ -338,6 +344,7 @@ extern DCtype __muldc3 (DFtype, DFtype, DFtype, DFtype);\n extern DWtype __fixxfdi (XFtype);\n extern DWtype __fixunsxfDI (XFtype);\n extern XFtype __floatdixf (DWtype);\n+extern XFtype __floatundixf (UDWtype);\n extern UWtype __fixunsxfSI (XFtype);\n extern XFtype __powixf2 (XFtype, int);\n extern XCtype __divxc3 (XFtype, XFtype, XFtype, XFtype);\n@@ -348,6 +355,7 @@ extern XCtype __mulxc3 (XFtype, XFtype, XFtype, XFtype);\n extern DWtype __fixunstfDI (TFtype);\n extern DWtype __fixtfdi (TFtype);\n extern TFtype __floatditf (DWtype);\n+extern TFtype __floatunditf (UDWtype);\n extern TFtype __powitf2 (TFtype, int);\n extern TCtype __divtc3 (TFtype, TFtype, TFtype, TFtype);\n extern TCtype __multc3 (TFtype, TFtype, TFtype, TFtype);"}, {"sha": "816e301023b930424a666701bf6c3252b2a57e3d", "filename": "gcc/mklibgcc.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d773588022f2e3c1bd166658b6c6c8bbba230ddf/gcc%2Fmklibgcc.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d773588022f2e3c1bd166658b6c6c8bbba230ddf/gcc%2Fmklibgcc.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmklibgcc.in?ref=d773588022f2e3c1bd166658b6c6c8bbba230ddf", "patch": "@@ -63,7 +63,7 @@ lib2funcs='_muldi3 _negdi2 _lshrdi3 _ashldi3 _ashrdi3\n \t_ffssi2 _ffsdi2 _clz _clzsi2 _clzdi2 _ctzsi2 _ctzdi2 _popcount_tab\n \t_popcountsi2 _popcountdi2 _paritysi2 _paritydi2 _powisf2 _powidf2\n \t_powixf2 _powitf2 _mulsc3 _muldc3 _mulxc3 _multc3 _divsc3 _divdc3\n-\t_divxc3 _divtc3'\n+\t_divxc3 _divtc3 _floatundidf _floatundisf _floatundixf _floatunditf'\n \n # Disable SHLIB_LINK if shared libgcc not enabled.\n if [ \"@enable_shared@\" = \"no\" ]; then"}, {"sha": "d764017a5d94ab213e4b4add2b45fe4e235118ac", "filename": "gcc/optabs.c", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d773588022f2e3c1bd166658b6c6c8bbba230ddf/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d773588022f2e3c1bd166658b6c6c8bbba230ddf/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=d773588022f2e3c1bd166658b6c6c8bbba230ddf", "patch": "@@ -4310,6 +4310,7 @@ expand_float (rtx to, rtx from, int unsignedp)\n   enum insn_code icode;\n   rtx target = to;\n   enum machine_mode fmode, imode;\n+  bool can_do_signed = false;\n \n   /* Crash now, because we won't be able to decide which mode to use.  */\n   gcc_assert (GET_MODE (from) != VOIDmode);\n@@ -4331,8 +4332,14 @@ expand_float (rtx to, rtx from, int unsignedp)\n \t  continue;\n \n \ticode = can_float_p (fmode, imode, unsignedp);\n-\tif (icode == CODE_FOR_nothing && imode != GET_MODE (from) && unsignedp)\n-\t  icode = can_float_p (fmode, imode, 0), doing_unsigned = 0;\n+\tif (icode == CODE_FOR_nothing && unsignedp)\n+\t  {\n+\t    enum insn_code scode = can_float_p (fmode, imode, 0);\n+\t    if (scode != CODE_FOR_nothing)\n+\t      can_do_signed = true;\n+\t    if (imode != GET_MODE (from))\n+\t      icode = scode, doing_unsigned = 0;\n+\t  }\n \n \tif (icode != CODE_FOR_nothing)\n \t  {\n@@ -4353,7 +4360,7 @@ expand_float (rtx to, rtx from, int unsignedp)\n \n   /* Unsigned integer, and no way to convert directly.\n      Convert as signed, then conditionally adjust the result.  */\n-  if (unsignedp)\n+  if (unsignedp && can_do_signed)\n     {\n       rtx label = gen_label_rtx ();\n       rtx temp;\n@@ -5232,6 +5239,8 @@ init_optabs (void)\n   /* Conversions.  */\n   init_interclass_conv_libfuncs (sfloat_optab, \"float\",\n \t\t\t\t MODE_INT, MODE_FLOAT);\n+  init_interclass_conv_libfuncs (ufloat_optab, \"floatun\",\n+\t\t\t\t MODE_INT, MODE_FLOAT);\n   init_interclass_conv_libfuncs (sfix_optab, \"fix\",\n \t\t\t\t MODE_FLOAT, MODE_INT);\n   init_interclass_conv_libfuncs (ufix_optab, \"fixuns\","}, {"sha": "c75ea547a70a6c4f921a93c2a9b93203d0efc10a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d773588022f2e3c1bd166658b6c6c8bbba230ddf/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d773588022f2e3c1bd166658b6c6c8bbba230ddf/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d773588022f2e3c1bd166658b6c6c8bbba230ddf", "patch": "@@ -1,3 +1,7 @@\n+2005-11-22  Joseph S. Myers  <joseph@codesourcery.com>\n+\n+\t* gcc.c-torture/execute/floatunsisf-1.c: New test.\n+\n 2005-11-22  Joseph S. Myers  <joseph@codesourcery.com>\n \n \t* gcc.target/powerpc/405-macchw-1.c,"}, {"sha": "cc4c49bbe055321da2062e25e45e624accd91ea0", "filename": "gcc/testsuite/gcc.c-torture/execute/floatunsisf-1.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d773588022f2e3c1bd166658b6c6c8bbba230ddf/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Ffloatunsisf-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d773588022f2e3c1bd166658b6c6c8bbba230ddf/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Ffloatunsisf-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Ffloatunsisf-1.c?ref=d773588022f2e3c1bd166658b6c6c8bbba230ddf", "patch": "@@ -0,0 +1,21 @@\n+/* The fp-bit.c function __floatunsisf had a latent bug where guard bits\n+   could be lost leading to incorrect rounding.  */\n+/* Origin: Joseph Myers <joseph@codesourcery.com> */\n+\n+extern void abort (void);\n+extern void exit (int);\n+#if __INT_MAX__ >= 0x7fffffff\n+volatile unsigned u = 0x80000081;\n+#else\n+volatile unsigned long u = 0x80000081;\n+#endif\n+volatile float f1, f2;\n+int\n+main (void)\n+{\n+  f1 = (float) u;\n+  f2 = (float) 0x80000081;\n+  if (f1 != f2)\n+    abort ();\n+  exit (0);\n+}"}]}