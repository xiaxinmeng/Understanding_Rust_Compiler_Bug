{"sha": "cafc9af2ea70fde45b287625de68423a233a24d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2FmYzlhZjJlYTcwZmRlNDViMjg3NjI1ZGU2ODQyM2EyMzNhMjRkOQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-11-18T17:29:41Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-11-18T17:29:41Z"}, "message": "compiler: Initialize variables in declaration order.\n\nFixes issue 8052.\n\nFrom-SVN: r217730", "tree": {"sha": "5cfdb5d3473bb29a60b8770f35e08186e141b38b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5cfdb5d3473bb29a60b8770f35e08186e141b38b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cafc9af2ea70fde45b287625de68423a233a24d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cafc9af2ea70fde45b287625de68423a233a24d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cafc9af2ea70fde45b287625de68423a233a24d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cafc9af2ea70fde45b287625de68423a233a24d9/comments", "author": null, "committer": null, "parents": [{"sha": "de6147508bdf9f319ad246031e58a9983461034e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de6147508bdf9f319ad246031e58a9983461034e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de6147508bdf9f319ad246031e58a9983461034e"}], "stats": {"total": 132, "additions": 100, "deletions": 32}, "files": [{"sha": "453db9af9c1acc405ec70ec5a246573eb1ddcb66", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 100, "deletions": 32, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cafc9af2ea70fde45b287625de68423a233a24d9/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cafc9af2ea70fde45b287625de68423a233a24d9/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=cafc9af2ea70fde45b287625de68423a233a24d9", "patch": "@@ -1018,11 +1018,11 @@ class Var_init\n {\n  public:\n   Var_init()\n-    : var_(NULL), init_(NULL)\n+    : var_(NULL), init_(NULL), dep_count_(0)\n   { }\n \n   Var_init(Named_object* var, Bstatement* init)\n-    : var_(var), init_(init)\n+    : var_(var), init_(init), dep_count_(0)\n   { }\n \n   // Return the variable.\n@@ -1035,13 +1035,38 @@ class Var_init\n   init() const\n   { return this->init_; }\n \n+  // Return the number of remaining dependencies.\n+  size_t\n+  dep_count() const\n+  { return this->dep_count_; }\n+\n+  // Increment the number of dependencies.\n+  void\n+  add_dependency()\n+  { ++this->dep_count_; }\n+\n+  // Decrement the number of dependencies.\n+  void\n+  remove_dependency()\n+  { --this->dep_count_; }\n+\n  private:\n   // The variable being initialized.\n   Named_object* var_;\n   // The initialization statement.\n   Bstatement* init_;\n+  // The number of initializations this is dependent on.  A variable\n+  // initialization should not be emitted if any of its dependencies\n+  // have not yet been resolved.\n+  size_t dep_count_;\n };\n \n+// For comparing Var_init keys in a map.\n+\n+inline bool\n+operator<(const Var_init& v1, const Var_init& v2)\n+{ return v1.var()->name() < v2.var()->name(); }\n+\n typedef std::list<Var_init> Var_inits;\n \n // Sort the variable initializations.  The rule we follow is that we\n@@ -1052,26 +1077,35 @@ typedef std::list<Var_init> Var_inits;\n static void\n sort_var_inits(Gogo* gogo, Var_inits* var_inits)\n {\n+  if (var_inits->empty())\n+    return;\n+\n   typedef std::pair<Named_object*, Named_object*> No_no;\n   typedef std::map<No_no, bool> Cache;\n   Cache cache;\n \n-  Var_inits ready;\n-  while (!var_inits->empty())\n+  // A mapping from a variable initialization to a set of\n+  // variable initializations that depend on it.\n+  typedef std::map<Var_init, std::set<Var_init*> > Init_deps;\n+  Init_deps init_deps;\n+  for (Var_inits::iterator p1 = var_inits->begin();\n+       p1 != var_inits->end();\n+       ++p1)\n     {\n-      Var_inits::iterator p1 = var_inits->begin();\n       Named_object* var = p1->var();\n       Expression* init = var->var_value()->init();\n       Block* preinit = var->var_value()->preinit();\n       Named_object* dep = gogo->var_depends_on(var->var_value());\n \n       // Start walking through the list to see which variables VAR\n       // needs to wait for.\n-      Var_inits::iterator p2 = p1;\n-      ++p2;\n-\n-      for (; p2 != var_inits->end(); ++p2)\n+      for (Var_inits::iterator p2 = var_inits->begin();\n+\t   p2 != var_inits->end();\n+\t   ++p2)\n \t{\n+\t  if (var == p2->var())\n+\t    continue;\n+\n \t  Named_object* p2var = p2->var();\n \t  No_no key(var, p2var);\n \t  std::pair<Cache::iterator, bool> ins =\n@@ -1080,6 +1114,10 @@ sort_var_inits(Gogo* gogo, Var_inits* var_inits)\n \t    ins.first->second = expression_requires(init, preinit, dep, p2var);\n \t  if (ins.first->second)\n \t    {\n+\t      // VAR depends on P2VAR.\n+\t      init_deps[*p2].insert(&(*p1));\n+\t      p1->add_dependency();\n+\n \t      // Check for cycles.\n \t      key = std::make_pair(p2var, var);\n \t      ins = cache.insert(std::make_pair(key, false));\n@@ -1100,36 +1138,66 @@ sort_var_inits(Gogo* gogo, Var_inits* var_inits)\n \t\t\t p2var->message_name().c_str());\n \t\t  p2 = var_inits->end();\n \t\t}\n-\t      else\n-\t\t{\n-\t\t  // We can't emit P1 until P2 is emitted.  Move P1.\n-\t\t  Var_inits::iterator p3 = p2;\n-\t\t  ++p3;\n-\t\t  var_inits->splice(p3, *var_inits, p1);\n-\t\t}\n-\t      break;\n \t    }\n \t}\n+    }\n \n-      if (p2 == var_inits->end())\n+  // If there are no dependencies then the declaration order is sorted.\n+  if (!init_deps.empty())\n+    {\n+      // Otherwise, sort variable initializations by emitting all variables with\n+      // no dependencies in declaration order. VAR_INITS is already in\n+      // declaration order.\n+      Var_inits ready;\n+      while (!var_inits->empty())\n \t{\n-\t  // VAR does not depends upon any other initialization expressions.\n-\n-\t  // Check for a loop of VAR on itself.  We only do this if\n-\t  // INIT is not NULL and there is no dependency; when INIT is\n-\t  // NULL, it means that PREINIT sets VAR, which we will\n-\t  // interpret as a loop.\n-\t  if (init != NULL && dep == NULL\n-\t      && expression_requires(init, preinit, NULL, var))\n-\t    error_at(var->location(),\n-\t\t     \"initialization expression for %qs depends upon itself\",\n-\t\t     var->message_name().c_str());\n-\t  ready.splice(ready.end(), *var_inits, p1);\n+\t  Var_inits::iterator v1;;\n+\t  for (v1 = var_inits->begin(); v1 != var_inits->end(); ++v1)\n+\t    {\n+\t      if (v1->dep_count() == 0)\n+\t\tbreak;\n+\t    }\n+\t  go_assert(v1 != var_inits->end());\n+\n+\t  // V1 either has no dependencies or its dependencies have already\n+\t  // been emitted, add it to READY next.  When V1 is emitted, remove\n+\t  // a dependency from each V that depends on V1.\n+\t  ready.splice(ready.end(), *var_inits, v1);\n+\n+\t  Init_deps::iterator p1 = init_deps.find(*v1);\n+\t  if (p1 != init_deps.end())\n+\t    {\n+\t      std::set<Var_init*> resolved = p1->second;\n+\t      for (std::set<Var_init*>::iterator pv = resolved.begin();\n+\t\t   pv != resolved.end();\n+\t\t   ++pv)\n+\t\t(*pv)->remove_dependency();\n+\t      init_deps.erase(p1);\n+\t    }\n \t}\n+      var_inits->swap(ready);\n+      go_assert(init_deps.empty());\n     }\n \n-  // Now READY is the list in the desired initialization order.\n-  var_inits->swap(ready);\n+  // VAR_INITS is in the correct order.  For each VAR in VAR_INITS,\n+  // check for a loop of VAR on itself.  We only do this if\n+  // INIT is not NULL and there is no dependency; when INIT is\n+  // NULL, it means that PREINIT sets VAR, which we will\n+  // interpret as a loop.\n+  for (Var_inits::const_iterator p = var_inits->begin();\n+       p != var_inits->end();\n+       ++p)\n+    {\n+      Named_object* var = p->var();\n+      Expression* init = var->var_value()->init();\n+      Block* preinit = var->var_value()->preinit();\n+      Named_object* dep = gogo->var_depends_on(var->var_value());\n+      if (init != NULL && dep == NULL\n+\t  && expression_requires(init, preinit, NULL, var))\n+\terror_at(var->location(),\n+\t\t \"initialization expression for %qs depends upon itself\",\n+\t\t var->message_name().c_str());\n+    }\n }\n \n // Write out the global definitions."}]}