{"sha": "9023bb8687347559702340c24cd72301f0656a59", "node_id": "C_kwDOANBUbNoAKDkwMjNiYjg2ODczNDc1NTk3MDIzNDBjMjRjZDcyMzAxZjA2NTZhNTk", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-02-11T10:29:35Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-02-11T10:29:35Z"}, "message": "Merge #918\n\n918: Refactor code to reuse a canonical way to compile items r=philberty a=philberty\n\nThis is a big cleanup so all paths that compile functions and constants\r\nend up in the same path so we avoid any duplication in how we actually\r\ncompile a function or constant.\r\n\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "d4059dbe453be902ebd68d4704160db6942bb1b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d4059dbe453be902ebd68d4704160db6942bb1b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9023bb8687347559702340c24cd72301f0656a59", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiBjqPCRBK7hj4Ov3rIwAAZKQIAJxaeoupEhfqlnLdMUVQ7uCC\nODMT7OUV8w9RPYeRnp8G57lVP81b/ZgS0eOg21aPb8kt23X93meTt0mbY8N+ARYO\n8ksavxjXP+4v42r9fyulMy53cl2CoHE1a5dww52KB+X2fRfzFUXasFiy8Kt7Qxia\n28l5HLjzkRKahumXd6Re6vo+4BEcM6DJCb4gc1fawswStt+ncvg/016e+vGuRFAq\nSuECgKA+tRYvlB2SmUyhqhgpwGWIyWz4yvjVt5y91OmCLcndJEJb1D7kpmaEdaSZ\nUYgFUfh2bZZn0e7zVcdYeUloj51uIIAxE5jFbOt9pVfPfOMJ92JD0wl8cnBPBJE=\n=7Q3U\n-----END PGP SIGNATURE-----\n", "payload": "tree d4059dbe453be902ebd68d4704160db6942bb1b3\nparent e2823b6747b36362387e5b26e8792f06185d7de8\nparent 4242d45d3d6590630ea88909ed996b8cf2640d35\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1644575375 +0000\ncommitter GitHub <noreply@github.com> 1644575375 +0000\n\nMerge #918\n\n918: Refactor code to reuse a canonical way to compile items r=philberty a=philberty\n\nThis is a big cleanup so all paths that compile functions and constants\r\nend up in the same path so we avoid any duplication in how we actually\r\ncompile a function or constant.\r\n\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9023bb8687347559702340c24cd72301f0656a59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9023bb8687347559702340c24cd72301f0656a59", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9023bb8687347559702340c24cd72301f0656a59/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2823b6747b36362387e5b26e8792f06185d7de8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2823b6747b36362387e5b26e8792f06185d7de8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2823b6747b36362387e5b26e8792f06185d7de8"}, {"sha": "4242d45d3d6590630ea88909ed996b8cf2640d35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4242d45d3d6590630ea88909ed996b8cf2640d35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4242d45d3d6590630ea88909ed996b8cf2640d35"}], "stats": {"total": 2014, "additions": 768, "deletions": 1246}, "files": [{"sha": "4f762160a5469d7d7c34ef91efac7f83318a2b76", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9023bb8687347559702340c24cd72301f0656a59/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9023bb8687347559702340c24cd72301f0656a59/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=9023bb8687347559702340c24cd72301f0656a59", "patch": "@@ -96,6 +96,8 @@ GRS_OBJS = \\\n     rust/rust-compile-intrinsic.o \\\n     rust/rust-compile-pattern.o \\\n     rust/rust-base62.o \\\n+    rust/rust-compile-item.o \\\n+    rust/rust-compile-implitem.o \\\n     rust/rust-compile-expr.o \\\n     rust/rust-compile-type.o \\\n     rust/rust-constexpr.o \\"}, {"sha": "9f936d2ea5cc36eec76b1e155c1a24e9f5d05b67", "filename": "gcc/rust/backend/rust-compile-base.cc", "status": "modified", "additions": 298, "deletions": 0, "changes": 298, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9023bb8687347559702340c24cd72301f0656a59/gcc%2Frust%2Fbackend%2Frust-compile-base.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9023bb8687347559702340c24cd72301f0656a59/gcc%2Frust%2Fbackend%2Frust-compile-base.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.cc?ref=9023bb8687347559702340c24cd72301f0656a59", "patch": "@@ -17,6 +17,11 @@\n // <http://www.gnu.org/licenses/>.\n \n #include \"rust-compile-base.h\"\n+#include \"rust-compile-item.h\"\n+#include \"rust-compile-stmt.h\"\n+#include \"rust-compile-fnparam.h\"\n+#include \"rust-compile-var-decl.h\"\n+\n #include \"fold-const.h\"\n #include \"stringpool.h\"\n \n@@ -169,5 +174,298 @@ HIRCompileBase::address_expression (tree expr, Location location)\n   return build_fold_addr_expr_loc (location.gcc_location (), expr);\n }\n \n+std::vector<Bvariable *>\n+HIRCompileBase::compile_locals_for_block (Context *ctx, Resolver::Rib &rib,\n+\t\t\t\t\t  tree fndecl)\n+{\n+  std::vector<Bvariable *> locals;\n+  rib.iterate_decls ([&] (NodeId n, Location) mutable -> bool {\n+    Resolver::Definition d;\n+    bool ok = ctx->get_resolver ()->lookup_definition (n, &d);\n+    rust_assert (ok);\n+\n+    HIR::Stmt *decl = nullptr;\n+    ok = ctx->get_mappings ()->resolve_nodeid_to_stmt (d.parent, &decl);\n+    rust_assert (ok);\n+\n+    // if its a function we extract this out side of this fn context\n+    // and it is not a local to this function\n+    bool is_item = ctx->get_mappings ()->lookup_hir_item (\n+\t\t     decl->get_mappings ().get_crate_num (),\n+\t\t     decl->get_mappings ().get_hirid ())\n+\t\t   != nullptr;\n+    if (is_item)\n+      {\n+\tHIR::Item *item = static_cast<HIR::Item *> (decl);\n+\tCompileItem::compile (item, ctx);\n+\treturn true;\n+      }\n+\n+    Bvariable *compiled = CompileVarDecl::compile (fndecl, decl, ctx);\n+    locals.push_back (compiled);\n+\n+    return true;\n+  });\n+\n+  return locals;\n+}\n+\n+void\n+HIRCompileBase::compile_function_body (Context *ctx, tree fndecl,\n+\t\t\t\t       HIR::BlockExpr &function_body,\n+\t\t\t\t       bool has_return_type)\n+{\n+  for (auto &s : function_body.get_statements ())\n+    {\n+      auto compiled_expr = CompileStmt::Compile (s.get (), ctx);\n+      if (compiled_expr != nullptr)\n+\t{\n+\t  tree compiled_stmt\n+\t    = ctx->get_backend ()->expression_statement (fndecl, compiled_expr);\n+\t  ctx->add_statement (compiled_stmt);\n+\t}\n+    }\n+\n+  if (function_body.has_expr ())\n+    {\n+      // the previous passes will ensure this is a valid return\n+      // or a valid trailing expression\n+      tree compiled_expr\n+\t= CompileExpr::Compile (function_body.expr.get (), ctx);\n+\n+      if (compiled_expr != nullptr)\n+\t{\n+\t  if (has_return_type)\n+\t    {\n+\t      std::vector<tree> retstmts;\n+\t      retstmts.push_back (compiled_expr);\n+\n+\t      auto ret = ctx->get_backend ()->return_statement (\n+\t\tfndecl, retstmts,\n+\t\tfunction_body.get_final_expr ()->get_locus ());\n+\t      ctx->add_statement (ret);\n+\t    }\n+\t  else\n+\t    {\n+\t      tree final_stmt\n+\t\t= ctx->get_backend ()->expression_statement (fndecl,\n+\t\t\t\t\t\t\t     compiled_expr);\n+\t      ctx->add_statement (final_stmt);\n+\t    }\n+\t}\n+    }\n+}\n+\n+tree\n+HIRCompileBase::compile_function (\n+  Context *ctx, const std::string &fn_name, HIR::SelfParam &self_param,\n+  std::vector<HIR::FunctionParam> &function_params,\n+  const HIR::FunctionQualifiers &qualifiers, HIR::Visibility &visibility,\n+  AST::AttrVec &outer_attrs, Location locus, HIR::BlockExpr *function_body,\n+  const Resolver::CanonicalPath *canonical_path, TyTy::FnType *fntype,\n+  bool function_has_return)\n+{\n+  tree compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n+  std::string ir_symbol_name\n+    = canonical_path->get () + fntype->subst_as_string ();\n+\n+  // we don't mangle the main fn since we haven't implemented the main shim\n+  bool is_main_fn = fn_name.compare (\"main\") == 0;\n+  std::string asm_name = fn_name;\n+  if (!is_main_fn)\n+    asm_name = ctx->mangle_item (fntype, *canonical_path);\n+\n+  unsigned int flags = 0;\n+  tree fndecl = ctx->get_backend ()->function (compiled_fn_type, ir_symbol_name,\n+\t\t\t\t\t       asm_name, flags, locus);\n+  setup_attributes_on_fndecl (fndecl, is_main_fn, !visibility.is_error (),\n+\t\t\t      qualifiers, outer_attrs);\n+  setup_abi_options (fndecl, fntype->get_abi ());\n+\n+  // insert into the context\n+  ctx->insert_function_decl (fntype, fndecl);\n+\n+  // setup the params\n+  TyTy::BaseType *tyret = fntype->get_return_type ();\n+  std::vector<Bvariable *> param_vars;\n+  if (!self_param.is_error ())\n+    {\n+      rust_assert (fntype->is_method ());\n+      TyTy::BaseType *self_tyty_lookup = fntype->get_self_type ();\n+\n+      tree self_type = TyTyResolveCompile::compile (ctx, self_tyty_lookup);\n+      Bvariable *compiled_self_param\n+\t= CompileSelfParam::compile (ctx, fndecl, self_param, self_type,\n+\t\t\t\t     self_param.get_locus ());\n+\n+      param_vars.push_back (compiled_self_param);\n+      ctx->insert_var_decl (self_param.get_mappings ().get_hirid (),\n+\t\t\t    compiled_self_param);\n+    }\n+\n+  // offset from + 1 for the TyTy::FnType being used when this is a method to\n+  // skip over Self on the FnType\n+  bool is_method = !self_param.is_error ();\n+  size_t i = is_method ? 1 : 0;\n+  for (auto &referenced_param : function_params)\n+    {\n+      auto tyty_param = fntype->param_at (i++);\n+      auto param_tyty = tyty_param.second;\n+      auto compiled_param_type = TyTyResolveCompile::compile (ctx, param_tyty);\n+\n+      Location param_locus = referenced_param.get_locus ();\n+      Bvariable *compiled_param_var\n+\t= CompileFnParam::compile (ctx, fndecl, &referenced_param,\n+\t\t\t\t   compiled_param_type, param_locus);\n+\n+      param_vars.push_back (compiled_param_var);\n+      ctx->insert_var_decl (referenced_param.get_mappings ().get_hirid (),\n+\t\t\t    compiled_param_var);\n+    }\n+\n+  if (!ctx->get_backend ()->function_set_parameters (fndecl, param_vars))\n+    return error_mark_node;\n+\n+  // lookup locals\n+  auto body_mappings = function_body->get_mappings ();\n+  Resolver::Rib *rib = nullptr;\n+  bool ok\n+    = ctx->get_resolver ()->find_name_rib (body_mappings.get_nodeid (), &rib);\n+  rust_assert (ok);\n+\n+  std::vector<Bvariable *> locals\n+    = compile_locals_for_block (ctx, *rib, fndecl);\n+\n+  tree enclosing_scope = NULL_TREE;\n+  Location start_location = function_body->get_locus ();\n+  Location end_location = function_body->get_end_locus ();\n+\n+  tree code_block = ctx->get_backend ()->block (fndecl, enclosing_scope, locals,\n+\t\t\t\t\t\tstart_location, end_location);\n+  ctx->push_block (code_block);\n+\n+  Bvariable *return_address = nullptr;\n+  if (function_has_return)\n+    {\n+      tree return_type = TyTyResolveCompile::compile (ctx, tyret);\n+\n+      bool address_is_taken = false;\n+      tree ret_var_stmt = NULL_TREE;\n+\n+      return_address\n+\t= ctx->get_backend ()->temporary_variable (fndecl, code_block,\n+\t\t\t\t\t\t   return_type, NULL,\n+\t\t\t\t\t\t   address_is_taken, locus,\n+\t\t\t\t\t\t   &ret_var_stmt);\n+\n+      ctx->add_statement (ret_var_stmt);\n+    }\n+\n+  ctx->push_fn (fndecl, return_address);\n+  compile_function_body (ctx, fndecl, *function_body, function_has_return);\n+  tree bind_tree = ctx->pop_block ();\n+\n+  gcc_assert (TREE_CODE (bind_tree) == BIND_EXPR);\n+  DECL_SAVED_TREE (fndecl) = bind_tree;\n+\n+  ctx->pop_fn ();\n+  ctx->push_function (fndecl);\n+\n+  return fndecl;\n+}\n+\n+tree\n+HIRCompileBase::compile_constant_item (\n+  Context *ctx, TyTy::BaseType *resolved_type,\n+  const Resolver::CanonicalPath *canonical_path, HIR::Expr *const_value_expr,\n+  Location locus)\n+{\n+  const std::string &ident = canonical_path->get ();\n+  tree type = TyTyResolveCompile::compile (ctx, resolved_type);\n+  tree const_type = build_qualified_type (type, TYPE_QUAL_CONST);\n+\n+  bool is_block_expr\n+    = const_value_expr->get_expression_type () == HIR::Expr::ExprType::Block;\n+\n+  // compile the expression\n+  tree folded_expr = error_mark_node;\n+  if (!is_block_expr)\n+    {\n+      tree value = CompileExpr::Compile (const_value_expr, ctx);\n+      folded_expr = ConstCtx::fold (value);\n+    }\n+  else\n+    {\n+      // in order to compile a block expr we want to reuse as much existing\n+      // machineary that we already have. This means the best approach is to\n+      // make a _fake_ function with a block so it can hold onto temps then\n+      // use our constexpr code to fold it completely or error_mark_node\n+      Backend::typed_identifier receiver;\n+      tree compiled_fn_type = ctx->get_backend ()->function_type (\n+\treceiver, {}, {Backend::typed_identifier (\"_\", const_type, locus)},\n+\tNULL, locus);\n+\n+      tree fndecl\n+\t= ctx->get_backend ()->function (compiled_fn_type, ident, \"\", 0, locus);\n+      TREE_READONLY (fndecl) = 1;\n+\n+      tree enclosing_scope = NULL_TREE;\n+      HIR::BlockExpr *function_body\n+\t= static_cast<HIR::BlockExpr *> (const_value_expr);\n+      Location start_location = function_body->get_locus ();\n+      Location end_location = function_body->get_end_locus ();\n+\n+      tree code_block\n+\t= ctx->get_backend ()->block (fndecl, enclosing_scope, {},\n+\t\t\t\t      start_location, end_location);\n+      ctx->push_block (code_block);\n+\n+      bool address_is_taken = false;\n+      tree ret_var_stmt = NULL_TREE;\n+      Bvariable *return_address\n+\t= ctx->get_backend ()->temporary_variable (fndecl, code_block,\n+\t\t\t\t\t\t   const_type, NULL,\n+\t\t\t\t\t\t   address_is_taken, locus,\n+\t\t\t\t\t\t   &ret_var_stmt);\n+\n+      ctx->add_statement (ret_var_stmt);\n+      ctx->push_fn (fndecl, return_address);\n+\n+      compile_function_body (ctx, fndecl, *function_body, true);\n+      tree bind_tree = ctx->pop_block ();\n+\n+      gcc_assert (TREE_CODE (bind_tree) == BIND_EXPR);\n+      DECL_SAVED_TREE (fndecl) = bind_tree;\n+\n+      ctx->pop_fn ();\n+\n+      // lets fold it into a call expr\n+      tree call = build_call_array_loc (locus.gcc_location (), const_type,\n+\t\t\t\t\tfndecl, 0, NULL);\n+      folded_expr = ConstCtx::fold (call);\n+    }\n+\n+  return named_constant_expression (const_type, ident, folded_expr, locus);\n+}\n+\n+tree\n+HIRCompileBase::named_constant_expression (tree type_tree,\n+\t\t\t\t\t   const std::string &name,\n+\t\t\t\t\t   tree const_val, Location location)\n+{\n+  if (type_tree == error_mark_node || const_val == error_mark_node)\n+    return error_mark_node;\n+\n+  tree name_tree = get_identifier_with_length (name.data (), name.length ());\n+  tree decl\n+    = build_decl (location.gcc_location (), CONST_DECL, name_tree, type_tree);\n+  DECL_INITIAL (decl) = const_val;\n+  TREE_CONSTANT (decl) = 1;\n+  TREE_READONLY (decl) = 1;\n+\n+  rust_preserve_from_gc (decl);\n+  return decl;\n+}\n+\n } // namespace Compile\n } // namespace Rust"}, {"sha": "a52886c9676a2c56d05a1cc09bb1f81a3dc8ef69", "filename": "gcc/rust/backend/rust-compile-base.h", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9023bb8687347559702340c24cd72301f0656a59/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9023bb8687347559702340c24cd72301f0656a59/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.h?ref=9023bb8687347559702340c24cd72301f0656a59", "patch": "@@ -35,14 +35,9 @@ class HIRCompileBase : public HIR::HIRFullVisitorBase\n \n   Context *ctx;\n \n+protected:\n   Context *get_context () { return ctx; }\n \n-  void compile_function_body (tree fndecl, HIR::BlockExpr &function_body,\n-\t\t\t      bool has_return_type);\n-\n-  bool compile_locals_for_block (Resolver::Rib &rib, tree fndecl,\n-\t\t\t\t std::vector<Bvariable *> &locals);\n-\n   tree coercion_site (tree rvalue, TyTy::BaseType *actual,\n \t\t      TyTy::BaseType *expected, Location lvalue_locus,\n \t\t      Location rvalue_locus);\n@@ -81,6 +76,30 @@ class HIRCompileBase : public HIR::HIRFullVisitorBase\n   static tree address_expression (tree, Location);\n \n   static bool mark_addressable (tree, Location);\n+\n+  static std::vector<Bvariable *>\n+  compile_locals_for_block (Context *ctx, Resolver::Rib &rib, tree fndecl);\n+\n+  static void compile_function_body (Context *ctx, tree fndecl,\n+\t\t\t\t     HIR::BlockExpr &function_body,\n+\t\t\t\t     bool has_return_type);\n+\n+  static tree compile_function (\n+    Context *ctx, const std::string &fn_name, HIR::SelfParam &self_param,\n+    std::vector<HIR::FunctionParam> &function_params,\n+    const HIR::FunctionQualifiers &qualifiers, HIR::Visibility &visibility,\n+    AST::AttrVec &outer_attrs, Location locus, HIR::BlockExpr *function_body,\n+    const Resolver::CanonicalPath *canonical_path, TyTy::FnType *fntype,\n+    bool function_has_return);\n+\n+  static tree\n+  compile_constant_item (Context *ctx, TyTy::BaseType *resolved_type,\n+\t\t\t const Resolver::CanonicalPath *canonical_path,\n+\t\t\t HIR::Expr *const_value_expr, Location locus);\n+\n+  static tree named_constant_expression (tree type_tree,\n+\t\t\t\t\t const std::string &name,\n+\t\t\t\t\t tree const_val, Location location);\n };\n \n } // namespace Compile"}, {"sha": "a592e352c00f47d5ed5d2c72f0e1d02b75b1e476", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9023bb8687347559702340c24cd72301f0656a59/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9023bb8687347559702340c24cd72301f0656a59/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=9023bb8687347559702340c24cd72301f0656a59", "patch": "@@ -18,6 +18,7 @@\n \n #include \"rust-compile.h\"\n #include \"rust-compile-item.h\"\n+#include \"rust-compile-implitem.h\"\n #include \"rust-compile-expr.h\"\n #include \"rust-compile-struct-field-expr.h\"\n #include \"rust-hir-trait-resolve.h\"\n@@ -204,7 +205,7 @@ CompileExpr::visit (HIR::MatchExpr &expr)\n \texpr.get_scrutinee_expr ()->get_mappings ().get_hirid (),\n \t&scrutinee_expr_tyty))\n     {\n-      translated = ctx->get_backend ()->error_expression ();\n+      translated = error_mark_node;\n       return;\n     }\n \n@@ -220,7 +221,7 @@ CompileExpr::visit (HIR::MatchExpr &expr)\n   if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n \t\t\t\t       &expr_tyty))\n     {\n-      translated = ctx->get_backend ()->error_expression ();\n+      translated = error_mark_node;\n       return;\n     }\n \n@@ -643,7 +644,7 @@ CompileExpr::compile_dyn_dispatch_call (const TyTy::DynamicObjectType *dyn,\n     }\n \n   if (ref == nullptr)\n-    return ctx->get_backend ()->error_expression ();\n+    return error_mark_node;\n \n   // get any indirection sorted out\n   if (receiver->get_kind () == TyTy::TypeKind::REF)\n@@ -713,7 +714,7 @@ CompileExpr::resolve_method_address (TyTy::FnType *fntype, HirId ref,\n   tree fn = NULL_TREE;\n   if (ctx->lookup_function_decl (fntype->get_ty_ref (), &fn))\n     {\n-      return ctx->get_backend ()->function_code_expression (fn, expr_locus);\n+      return address_expression (fn, expr_locus);\n     }\n \n   // Now we can try and resolve the address since this might be a forward\n@@ -765,8 +766,7 @@ CompileExpr::resolve_method_address (TyTy::FnType *fntype, HirId ref,\n       // contain an implementation we should actually return\n       // error_mark_node\n \n-      return CompileTraitItem::Compile (receiver,\n-\t\t\t\t\ttrait_item_ref->get_hir_trait_item (),\n+      return CompileTraitItem::Compile (trait_item_ref->get_hir_trait_item (),\n \t\t\t\t\tctx, fntype, true, expr_locus);\n     }\n   else\n@@ -1343,8 +1343,7 @@ CompileExpr::visit (HIR::IdentifierExpr &expr)\n     }\n   else if (ctx->lookup_function_decl (ref, &fn))\n     {\n-      translated\n-\t= ctx->get_backend ()->function_code_expression (fn, expr.get_locus ());\n+      translated = address_expression (fn, expr.get_locus ());\n     }\n   else if (ctx->lookup_var_decl (ref, &var))\n     {"}, {"sha": "2fee3bea6a66582cac9a4171a97d5975c6d13f4f", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9023bb8687347559702340c24cd72301f0656a59/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9023bb8687347559702340c24cd72301f0656a59/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=9023bb8687347559702340c24cd72301f0656a59", "patch": "@@ -383,8 +383,8 @@ class CompileExpr : public HIRCompileBase\n \tctx->add_statement (ret_var_stmt);\n       }\n \n-    auto code_block = CompileBlock::compile (&expr, ctx, tmp);\n-    auto block_stmt = ctx->get_backend ()->block_statement (code_block);\n+    auto block_stmt = CompileBlock::compile (&expr, ctx, tmp);\n+    rust_assert (TREE_CODE (block_stmt) == BIND_EXPR);\n     ctx->add_statement (block_stmt);\n \n     if (tmp != NULL)\n@@ -680,9 +680,9 @@ class CompileExpr : public HIRCompileBase\n       = ctx->get_backend ()->expression_statement (fnctx.fndecl, exit_expr);\n     ctx->add_statement (break_stmt);\n \n-    tree code_block\n+    tree code_block_stmt\n       = CompileBlock::compile (expr.get_loop_block ().get (), ctx, nullptr);\n-    tree code_block_stmt = ctx->get_backend ()->block_statement (code_block);\n+    rust_assert (TREE_CODE (code_block_stmt) == BIND_EXPR);\n     ctx->add_statement (code_block_stmt);\n \n     ctx->pop_loop_begin_label ();"}, {"sha": "1412e7a42eb01bb52d4cabe0e089e120bc1ae427", "filename": "gcc/rust/backend/rust-compile-extern.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9023bb8687347559702340c24cd72301f0656a59/gcc%2Frust%2Fbackend%2Frust-compile-extern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9023bb8687347559702340c24cd72301f0656a59/gcc%2Frust%2Fbackend%2Frust-compile-extern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-extern.h?ref=9023bb8687347559702340c24cd72301f0656a59", "patch": "@@ -21,12 +21,6 @@\n \n #include \"rust-compile-base.h\"\n #include \"rust-compile-intrinsic.h\"\n-#include \"rust-compile-tyty.h\"\n-#include \"rust-compile-implitem.h\"\n-#include \"rust-compile-var-decl.h\"\n-#include \"rust-compile-stmt.h\"\n-#include \"rust-compile-expr.h\"\n-#include \"rust-compile-fnparam.h\"\n \n namespace Rust {\n namespace Compile {"}, {"sha": "8dc18d3c5cc30527298a65955763268d562e4688", "filename": "gcc/rust/backend/rust-compile-implitem.cc", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9023bb8687347559702340c24cd72301f0656a59/gcc%2Frust%2Fbackend%2Frust-compile-implitem.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9023bb8687347559702340c24cd72301f0656a59/gcc%2Frust%2Fbackend%2Frust-compile-implitem.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-implitem.cc?ref=9023bb8687347559702340c24cd72301f0656a59", "patch": "@@ -0,0 +1,102 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-compile-implitem.h\"\n+#include \"rust-compile-expr.h\"\n+#include \"rust-compile-fnparam.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+void\n+CompileTraitItem::visit (HIR::TraitItemConst &constant)\n+{\n+  rust_assert (concrete != nullptr);\n+  TyTy::BaseType *resolved_type = concrete;\n+\n+  const Resolver::CanonicalPath *canonical_path = nullptr;\n+  bool ok = ctx->get_mappings ()->lookup_canonical_path (\n+    constant.get_mappings ().get_crate_num (),\n+    constant.get_mappings ().get_nodeid (), &canonical_path);\n+  rust_assert (ok);\n+\n+  HIR::Expr *const_value_expr = constant.get_expr ().get ();\n+  tree const_expr\n+    = compile_constant_item (ctx, resolved_type, canonical_path,\n+\t\t\t     const_value_expr, constant.get_locus ());\n+  ctx->push_const (const_expr);\n+  ctx->insert_const_decl (constant.get_mappings ().get_hirid (), const_expr);\n+\n+  reference = const_expr;\n+}\n+\n+void\n+CompileTraitItem::visit (HIR::TraitItemFunc &func)\n+{\n+  rust_assert (func.has_block_defined ());\n+\n+  rust_assert (concrete->get_kind () == TyTy::TypeKind::FNDEF);\n+  TyTy::FnType *fntype = static_cast<TyTy::FnType *> (concrete);\n+\n+  // items can be forward compiled which means we may not need to invoke this\n+  // code. We might also have already compiled this generic function as well.\n+  tree lookup = NULL_TREE;\n+  if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup,\n+\t\t\t\t fntype->get_id (), fntype))\n+    {\n+      // has this been added to the list then it must be finished\n+      if (ctx->function_completed (lookup))\n+\t{\n+\t  tree dummy = NULL_TREE;\n+\t  if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &dummy))\n+\t    {\n+\t      ctx->insert_function_decl (fntype, lookup);\n+\t    }\n+\t  reference = address_expression (lookup, ref_locus);\n+\t  return;\n+\t}\n+    }\n+\n+  if (fntype->has_subsititions_defined ())\n+    {\n+      // override the Hir Lookups for the substituions in this context\n+      fntype->override_context ();\n+    }\n+\n+  const Resolver::CanonicalPath *canonical_path = nullptr;\n+  bool ok = ctx->get_mappings ()->lookup_canonical_path (\n+    func.get_mappings ().get_crate_num (), func.get_mappings ().get_nodeid (),\n+    &canonical_path);\n+  rust_assert (ok);\n+\n+  // FIXME\n+  HIR::Visibility vis (HIR::Visibility::PublicVisType::NONE,\n+\t\t       AST::SimplePath::create_empty ());\n+  HIR::TraitFunctionDecl &function = func.get_decl ();\n+  tree fndecl\n+    = compile_function (ctx, function.get_function_name (),\n+\t\t\tfunction.get_self (), function.get_function_params (),\n+\t\t\tfunction.get_qualifiers (), vis,\n+\t\t\tfunc.get_outer_attrs (), func.get_locus (),\n+\t\t\tfunc.get_block_expr ().get (), canonical_path, fntype,\n+\t\t\tfunction.has_return_type ());\n+  reference = address_expression (fndecl, ref_locus);\n+}\n+\n+} // namespace Compile\n+} // namespace Rust"}, {"sha": "4d49c0b83d02d24f2d77c27e082cc88b61dd468d", "filename": "gcc/rust/backend/rust-compile-implitem.h", "status": "modified", "additions": 14, "deletions": 497, "changes": 511, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9023bb8687347559702340c24cd72301f0656a59/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9023bb8687347559702340c24cd72301f0656a59/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h?ref=9023bb8687347559702340c24cd72301f0656a59", "patch": "@@ -19,19 +19,17 @@\n #ifndef RUST_COMPILE_IMPLITEM_H\n #define RUST_COMPILE_IMPLITEM_H\n \n-#include \"rust-compile-base.h\"\n-#include \"rust-compile-tyty.h\"\n-#include \"rust-compile-var-decl.h\"\n-#include \"rust-compile-stmt.h\"\n+#include \"rust-compile-item.h\"\n #include \"rust-compile-expr.h\"\n #include \"rust-compile-fnparam.h\"\n \n namespace Rust {\n namespace Compile {\n \n-class CompileInherentImplItem : public HIRCompileBase\n+// this is a proxy for HIR::ImplItem's back to use the normel HIR::Item path\n+class CompileInherentImplItem : public CompileItem\n {\n-  using Rust::Compile::HIRCompileBase::visit;\n+  using Rust::Compile::CompileItem::visit;\n \n public:\n   static tree Compile (HIR::ImplItem *item, Context *ctx,\n@@ -42,530 +40,49 @@ class CompileInherentImplItem : public HIRCompileBase\n     CompileInherentImplItem compiler (ctx, concrete, ref_locus);\n     item->accept_vis (compiler);\n \n-    if (is_query_mode\n-\t&& ctx->get_backend ()->is_error_expression (compiler.reference))\n+    if (is_query_mode && compiler.reference == error_mark_node)\n       rust_internal_error_at (ref_locus, \"failed to compile impl item: %s\",\n \t\t\t      item->as_string ().c_str ());\n \n     return compiler.reference;\n   }\n \n-  void visit (HIR::ConstantItem &constant) override\n-  {\n-    TyTy::BaseType *resolved_type = nullptr;\n-    bool ok\n-      = ctx->get_tyctx ()->lookup_type (constant.get_mappings ().get_hirid (),\n-\t\t\t\t\t&resolved_type);\n-    rust_assert (ok);\n-\n-    tree type = TyTyResolveCompile::compile (ctx, resolved_type);\n-    tree value = CompileExpr::Compile (constant.get_expr (), ctx);\n-\n-    const Resolver::CanonicalPath *canonical_path = nullptr;\n-    ok = ctx->get_mappings ()->lookup_canonical_path (\n-      constant.get_mappings ().get_crate_num (),\n-      constant.get_mappings ().get_nodeid (), &canonical_path);\n-    rust_assert (ok);\n-\n-    std::string ident = canonical_path->get ();\n-    tree const_expr = ctx->get_backend ()->named_constant_expression (\n-      type, constant.get_identifier (), value, constant.get_locus ());\n-\n-    ctx->push_const (const_expr);\n-    ctx->insert_const_decl (constant.get_mappings ().get_hirid (), const_expr);\n-\n-    reference = const_expr;\n-  }\n-\n-  void visit (HIR::Function &function) override\n-  {\n-    TyTy::BaseType *fntype_tyty;\n-    if (!ctx->get_tyctx ()->lookup_type (function.get_mappings ().get_hirid (),\n-\t\t\t\t\t &fntype_tyty))\n-      {\n-\trust_fatal_error (function.get_locus (),\n-\t\t\t  \"failed to lookup function type\");\n-\treturn;\n-      }\n-\n-    rust_assert (fntype_tyty->get_kind () == TyTy::TypeKind::FNDEF);\n-    TyTy::FnType *fntype = static_cast<TyTy::FnType *> (fntype_tyty);\n-    if (fntype->has_subsititions_defined ())\n-      {\n-\t// we cant do anything for this only when it is used and a concrete type\n-\t// is given\n-\tif (concrete == nullptr)\n-\t  return;\n-\telse\n-\t  {\n-\t    rust_assert (concrete->get_kind () == TyTy::TypeKind::FNDEF);\n-\t    fntype = static_cast<TyTy::FnType *> (concrete);\n-\t  }\n-      }\n-\n-    // items can be forward compiled which means we may not need to invoke this\n-    // code. We might also have already compiled this generic function as well.\n-    tree lookup = NULL_TREE;\n-    if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup,\n-\t\t\t\t   fntype->get_id (), fntype))\n-      {\n-\t// has this been added to the list then it must be finished\n-\tif (ctx->function_completed (lookup))\n-\t  {\n-\t    tree dummy = NULL_TREE;\n-\t    if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &dummy))\n-\t      {\n-\t\tctx->insert_function_decl (fntype, lookup);\n-\t      }\n-\t    reference\n-\t      = ctx->get_backend ()->function_code_expression (lookup,\n-\t\t\t\t\t\t\t       ref_locus);\n-\t    return;\n-\t  }\n-      }\n-\n-    if (fntype->has_subsititions_defined ())\n-      {\n-\t// override the Hir Lookups for the substituions in this context\n-\tfntype->override_context ();\n-      }\n-\n-    // convert to the actual function type\n-    tree compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n-\n-    const Resolver::CanonicalPath *canonical_path = nullptr;\n-    bool ok = ctx->get_mappings ()->lookup_canonical_path (\n-      function.get_mappings ().get_crate_num (),\n-      function.get_mappings ().get_nodeid (), &canonical_path);\n-    rust_assert (ok);\n-\n-    std::string ir_symbol_name\n-      = canonical_path->get () + fntype->subst_as_string ();\n-    std::string asm_name = ctx->mangle_item (fntype, *canonical_path);\n-\n-    unsigned int flags = 0;\n-    tree fndecl\n-      = ctx->get_backend ()->function (compiled_fn_type, ir_symbol_name,\n-\t\t\t\t       asm_name, flags, function.get_locus ());\n-    setup_attributes_on_fndecl (fndecl, false, function.has_visibility (),\n-\t\t\t\tfunction.get_qualifiers (),\n-\t\t\t\tfunction.get_outer_attrs ());\n-    ctx->insert_function_decl (fntype, fndecl);\n-\n-    // setup the params\n-    TyTy::BaseType *tyret = fntype->get_return_type ();\n-    std::vector<Bvariable *> param_vars;\n-\n-    if (function.is_method ())\n-      {\n-\t// insert self\n-\tTyTy::BaseType *self_tyty_lookup = nullptr;\n-\tif (!ctx->get_tyctx ()->lookup_type (\n-\t      function.get_self_param ().get_mappings ().get_hirid (),\n-\t      &self_tyty_lookup))\n-\t  {\n-\t    rust_error_at (function.get_self_param ().get_locus (),\n-\t\t\t   \"failed to lookup self param type\");\n-\t    return;\n-\t  }\n-\n-\ttree self_type = TyTyResolveCompile::compile (ctx, self_tyty_lookup);\n-\tif (self_type == nullptr)\n-\t  {\n-\t    rust_error_at (function.get_self_param ().get_locus (),\n-\t\t\t   \"failed to compile self param type\");\n-\t    return;\n-\t  }\n-\n-\tBvariable *compiled_self_param\n-\t  = CompileSelfParam::compile (ctx, fndecl, function.get_self_param (),\n-\t\t\t\t       self_type,\n-\t\t\t\t       function.get_self_param ().get_locus ());\n-\tif (compiled_self_param == nullptr)\n-\t  {\n-\t    rust_error_at (function.get_self_param ().get_locus (),\n-\t\t\t   \"failed to compile self param variable\");\n-\t    return;\n-\t  }\n-\n-\tparam_vars.push_back (compiled_self_param);\n-\tctx->insert_var_decl (\n-\t  function.get_self_param ().get_mappings ().get_hirid (),\n-\t  compiled_self_param);\n-      }\n-\n-    // offset from + 1 for the TyTy::FnType being used when this is a method to\n-    // skip over Self on the FnType\n-    size_t i = function.is_method () ? 1 : 0;\n-    for (auto referenced_param : function.get_function_params ())\n-      {\n-\tauto tyty_param = fntype->param_at (i);\n-\tauto param_tyty = tyty_param.second;\n-\n-\tauto compiled_param_type\n-\t  = TyTyResolveCompile::compile (ctx, param_tyty);\n-\tif (compiled_param_type == nullptr)\n-\t  {\n-\t    rust_error_at (referenced_param.get_locus (),\n-\t\t\t   \"failed to compile parameter type\");\n-\t    return;\n-\t  }\n-\n-\tLocation param_locus\n-\t  = ctx->get_mappings ()->lookup_location (param_tyty->get_ref ());\n-\tBvariable *compiled_param_var\n-\t  = CompileFnParam::compile (ctx, fndecl, &referenced_param,\n-\t\t\t\t     compiled_param_type, param_locus);\n-\tif (compiled_param_var == nullptr)\n-\t  {\n-\t    rust_error_at (param_locus, \"Failed to compile parameter variable\");\n-\t    return;\n-\t  }\n-\n-\tparam_vars.push_back (compiled_param_var);\n-\n-\tctx->insert_var_decl (referenced_param.get_mappings ().get_hirid (),\n-\t\t\t      compiled_param_var);\n-\ti++;\n-      }\n-\n-    if (!ctx->get_backend ()->function_set_parameters (fndecl, param_vars))\n-      {\n-\trust_fatal_error (function.get_locus (),\n-\t\t\t  \"failed to setup parameter variables\");\n-\treturn;\n-      }\n-\n-    // lookup locals\n-    auto block_expr = function.get_definition ().get ();\n-    auto body_mappings = block_expr->get_mappings ();\n-\n-    Resolver::Rib *rib = nullptr;\n-    if (!ctx->get_resolver ()->find_name_rib (body_mappings.get_nodeid (),\n-\t\t\t\t\t      &rib))\n-      {\n-\trust_fatal_error (function.get_locus (),\n-\t\t\t  \"failed to setup locals per block\");\n-\treturn;\n-      }\n-\n-    std::vector<Bvariable *> locals;\n-    ok = compile_locals_for_block (*rib, fndecl, locals);\n-    rust_assert (ok);\n-\n-    tree enclosing_scope = NULL_TREE;\n-    HIR::BlockExpr *function_body = function.get_definition ().get ();\n-    Location start_location = function_body->get_locus ();\n-    Location end_location = function_body->get_end_locus ();\n-\n-    tree code_block\n-      = ctx->get_backend ()->block (fndecl, enclosing_scope, locals,\n-\t\t\t\t    start_location, end_location);\n-    ctx->push_block (code_block);\n-\n-    Bvariable *return_address = nullptr;\n-    if (function.has_function_return_type ())\n-      {\n-\ttree return_type = TyTyResolveCompile::compile (ctx, tyret);\n-\n-\tbool address_is_taken = false;\n-\ttree ret_var_stmt = NULL_TREE;\n-\n-\treturn_address = ctx->get_backend ()->temporary_variable (\n-\t  fndecl, code_block, return_type, NULL, address_is_taken,\n-\t  function.get_locus (), &ret_var_stmt);\n-\n-\tctx->add_statement (ret_var_stmt);\n-      }\n-\n-    ctx->push_fn (fndecl, return_address);\n-\n-    compile_function_body (fndecl, *function.get_definition ().get (),\n-\t\t\t   function.has_function_return_type ());\n-\n-    ctx->pop_block ();\n-    auto body = ctx->get_backend ()->block_statement (code_block);\n-    if (!ctx->get_backend ()->function_set_body (fndecl, body))\n-      {\n-\trust_error_at (function.get_locus (), \"failed to set body to function\");\n-\treturn;\n-      }\n-\n-    ctx->pop_fn ();\n-    ctx->push_function (fndecl);\n-\n-    reference\n-      = ctx->get_backend ()->function_code_expression (fndecl, ref_locus);\n-  }\n-\n private:\n   CompileInherentImplItem (Context *ctx, TyTy::BaseType *concrete,\n \t\t\t   Location ref_locus)\n-    : HIRCompileBase (ctx), concrete (concrete),\n-      reference (ctx->get_backend ()->error_expression ()),\n-      ref_locus (ref_locus)\n+    : CompileItem (ctx, concrete, ref_locus)\n   {}\n-\n-  TyTy::BaseType *concrete;\n-  tree reference;\n-  Location ref_locus;\n };\n \n class CompileTraitItem : public HIRCompileBase\n {\n   using Rust::Compile::HIRCompileBase::visit;\n \n public:\n-  static tree Compile (const TyTy::BaseType *self, HIR::TraitItem *item,\n-\t\t       Context *ctx, TyTy::BaseType *concrete,\n-\t\t       bool is_query_mode = false,\n+  static tree Compile (HIR::TraitItem *item, Context *ctx,\n+\t\t       TyTy::BaseType *concrete, bool is_query_mode = false,\n \t\t       Location ref_locus = Location ())\n   {\n-    CompileTraitItem compiler (self, ctx, concrete, ref_locus);\n+    CompileTraitItem compiler (ctx, concrete, ref_locus);\n     item->accept_vis (compiler);\n \n-    if (is_query_mode\n-\t&& ctx->get_backend ()->is_error_expression (compiler.reference))\n+    if (is_query_mode && compiler.reference == error_mark_node)\n       rust_internal_error_at (ref_locus, \"failed to compile trait item: %s\",\n \t\t\t      item->as_string ().c_str ());\n \n     return compiler.reference;\n   }\n \n-  void visit (HIR::TraitItemConst &constant) override\n-  {\n-    rust_assert (concrete != nullptr);\n-    TyTy::BaseType *resolved_type = concrete;\n-\n-    tree type = TyTyResolveCompile::compile (ctx, resolved_type);\n-    tree value = CompileExpr::Compile (constant.get_expr ().get (), ctx);\n-\n-    const Resolver::CanonicalPath *canonical_path = nullptr;\n-    bool ok = ctx->get_mappings ()->lookup_canonical_path (\n-      constant.get_mappings ().get_crate_num (),\n-      constant.get_mappings ().get_nodeid (), &canonical_path);\n-    rust_assert (ok);\n-\n-    std::string ident = canonical_path->get ();\n-    tree const_expr = ctx->get_backend ()->named_constant_expression (\n-      type, constant.get_name (), value, constant.get_locus ());\n-\n-    ctx->push_const (const_expr);\n-    ctx->insert_const_decl (constant.get_mappings ().get_hirid (), const_expr);\n-\n-    reference = const_expr;\n-  }\n-\n-  void visit (HIR::TraitItemFunc &func) override\n-  {\n-    rust_assert (func.has_block_defined ());\n-\n-    rust_assert (concrete->get_kind () == TyTy::TypeKind::FNDEF);\n-    TyTy::FnType *fntype = static_cast<TyTy::FnType *> (concrete);\n-\n-    // items can be forward compiled which means we may not need to invoke this\n-    // code. We might also have already compiled this generic function as well.\n-    tree lookup = NULL_TREE;\n-    if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup,\n-\t\t\t\t   fntype->get_id (), fntype))\n-      {\n-\t// has this been added to the list then it must be finished\n-\tif (ctx->function_completed (lookup))\n-\t  {\n-\t    tree dummy = NULL_TREE;\n-\t    if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &dummy))\n-\t      {\n-\t\tctx->insert_function_decl (fntype, lookup);\n-\t      }\n-\t    reference\n-\t      = ctx->get_backend ()->function_code_expression (lookup,\n-\t\t\t\t\t\t\t       ref_locus);\n-\t    return;\n-\t  }\n-      }\n-\n-    if (fntype->has_subsititions_defined ())\n-      {\n-\t// override the Hir Lookups for the substituions in this context\n-\tfntype->override_context ();\n-      }\n-\n-    // convert to the actual function type\n-    tree compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n-    HIR::TraitFunctionDecl &function = func.get_decl ();\n-\n-    const Resolver::CanonicalPath *canonical_path = nullptr;\n-    bool ok = ctx->get_mappings ()->lookup_canonical_path (\n-      func.get_mappings ().get_crate_num (), func.get_mappings ().get_nodeid (),\n-      &canonical_path);\n-    rust_assert (ok);\n-\n-    std::string fn_identifier = canonical_path->get ();\n-    std::string asm_name = ctx->mangle_item (fntype, *canonical_path);\n-\n-    unsigned int flags = 0;\n-    tree fndecl\n-      = ctx->get_backend ()->function (compiled_fn_type, fn_identifier,\n-\t\t\t\t       asm_name, flags, func.get_locus ());\n-    setup_attributes_on_fndecl (fndecl, false, false,\n-\t\t\t\tfunc.get_decl ().get_qualifiers (),\n-\t\t\t\tfunc.get_outer_attrs ());\n-    ctx->insert_function_decl (fntype, fndecl);\n-\n-    // setup the params\n-    TyTy::BaseType *tyret = fntype->get_return_type ();\n-    std::vector<Bvariable *> param_vars;\n-\n-    if (function.is_method ())\n-      {\n-\t// insert self\n-\tTyTy::BaseType *self_tyty_lookup = nullptr;\n-\tif (!ctx->get_tyctx ()->lookup_type (\n-\t      function.get_self ().get_mappings ().get_hirid (),\n-\t      &self_tyty_lookup))\n-\t  {\n-\t    rust_error_at (function.get_self ().get_locus (),\n-\t\t\t   \"failed to lookup self param type\");\n-\t    return;\n-\t  }\n-\n-\ttree self_type = TyTyResolveCompile::compile (ctx, self_tyty_lookup);\n-\tif (self_type == nullptr)\n-\t  {\n-\t    rust_error_at (function.get_self ().get_locus (),\n-\t\t\t   \"failed to compile self param type\");\n-\t    return;\n-\t  }\n+  void visit (HIR::TraitItemConst &constant) override;\n \n-\tBvariable *compiled_self_param\n-\t  = CompileSelfParam::compile (ctx, fndecl, function.get_self (),\n-\t\t\t\t       self_type,\n-\t\t\t\t       function.get_self ().get_locus ());\n-\tif (compiled_self_param == nullptr)\n-\t  {\n-\t    rust_error_at (function.get_self ().get_locus (),\n-\t\t\t   \"failed to compile self param variable\");\n-\t    return;\n-\t  }\n-\n-\tparam_vars.push_back (compiled_self_param);\n-\tctx->insert_var_decl (function.get_self ().get_mappings ().get_hirid (),\n-\t\t\t      compiled_self_param);\n-      }\n-\n-    // offset from + 1 for the TyTy::FnType being used when this is a method to\n-    // skip over Self on the FnType\n-    size_t i = function.is_method () ? 1 : 0;\n-    for (auto referenced_param : function.get_function_params ())\n-      {\n-\tauto tyty_param = fntype->param_at (i);\n-\tauto param_tyty = tyty_param.second;\n-\n-\tauto compiled_param_type\n-\t  = TyTyResolveCompile::compile (ctx, param_tyty);\n-\tif (compiled_param_type == nullptr)\n-\t  {\n-\t    rust_error_at (referenced_param.get_locus (),\n-\t\t\t   \"failed to compile parameter type\");\n-\t    return;\n-\t  }\n-\n-\tLocation param_locus\n-\t  = ctx->get_mappings ()->lookup_location (param_tyty->get_ref ());\n-\tBvariable *compiled_param_var\n-\t  = CompileFnParam::compile (ctx, fndecl, &referenced_param,\n-\t\t\t\t     compiled_param_type, param_locus);\n-\tif (compiled_param_var == nullptr)\n-\t  {\n-\t    rust_error_at (param_locus, \"Failed to compile parameter variable\");\n-\t    return;\n-\t  }\n-\n-\tparam_vars.push_back (compiled_param_var);\n-\n-\tctx->insert_var_decl (referenced_param.get_mappings ().get_hirid (),\n-\t\t\t      compiled_param_var);\n-\ti++;\n-      }\n-\n-    if (!ctx->get_backend ()->function_set_parameters (fndecl, param_vars))\n-      {\n-\trust_fatal_error (func.get_locus (),\n-\t\t\t  \"failed to setup parameter variables\");\n-\treturn;\n-      }\n-\n-    // lookup locals\n-    auto block_expr = func.get_block_expr ().get ();\n-    auto body_mappings = block_expr->get_mappings ();\n-\n-    Resolver::Rib *rib = nullptr;\n-    if (!ctx->get_resolver ()->find_name_rib (body_mappings.get_nodeid (),\n-\t\t\t\t\t      &rib))\n-      {\n-\trust_fatal_error (func.get_locus (),\n-\t\t\t  \"failed to setup locals per block\");\n-\treturn;\n-      }\n-\n-    std::vector<Bvariable *> locals;\n-    ok = compile_locals_for_block (*rib, fndecl, locals);\n-    rust_assert (ok);\n-\n-    tree enclosing_scope = NULL_TREE;\n-    HIR::BlockExpr *function_body = func.get_block_expr ().get ();\n-    Location start_location = function_body->get_locus ();\n-    Location end_location = function_body->get_end_locus ();\n-\n-    tree code_block\n-      = ctx->get_backend ()->block (fndecl, enclosing_scope, locals,\n-\t\t\t\t    start_location, end_location);\n-    ctx->push_block (code_block);\n-\n-    Bvariable *return_address = nullptr;\n-    if (function.has_return_type ())\n-      {\n-\ttree return_type = TyTyResolveCompile::compile (ctx, tyret);\n-\n-\tbool address_is_taken = false;\n-\ttree ret_var_stmt = NULL_TREE;\n-\n-\treturn_address = ctx->get_backend ()->temporary_variable (\n-\t  fndecl, code_block, return_type, NULL, address_is_taken,\n-\t  func.get_locus (), &ret_var_stmt);\n-\n-\tctx->add_statement (ret_var_stmt);\n-      }\n-\n-    ctx->push_fn (fndecl, return_address);\n-\n-    compile_function_body (fndecl, *func.get_block_expr ().get (),\n-\t\t\t   function.has_return_type ());\n-\n-    ctx->pop_block ();\n-    auto body = ctx->get_backend ()->block_statement (code_block);\n-    if (!ctx->get_backend ()->function_set_body (fndecl, body))\n-      {\n-\trust_error_at (func.get_locus (), \"failed to set body to function\");\n-\treturn;\n-      }\n-\n-    ctx->pop_fn ();\n-    ctx->push_function (fndecl);\n-\n-    reference\n-      = ctx->get_backend ()->function_code_expression (fndecl, ref_locus);\n-  }\n+  void visit (HIR::TraitItemFunc &func) override;\n \n private:\n-  CompileTraitItem (const TyTy::BaseType *self, Context *ctx,\n-\t\t    TyTy::BaseType *concrete, Location ref_locus)\n-    : HIRCompileBase (ctx), self (self), concrete (concrete),\n-      reference (ctx->get_backend ()->error_expression ()),\n+  CompileTraitItem (Context *ctx, TyTy::BaseType *concrete, Location ref_locus)\n+    : HIRCompileBase (ctx), concrete (concrete), reference (error_mark_node),\n       ref_locus (ref_locus)\n   {}\n \n-  const TyTy::BaseType *self;\n   TyTy::BaseType *concrete;\n   tree reference;\n   Location ref_locus;"}, {"sha": "8c5b073488d52c6e16004449cdc50353affa1621", "filename": "gcc/rust/backend/rust-compile-intrinsic.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9023bb8687347559702340c24cd72301f0656a59/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9023bb8687347559702340c24cd72301f0656a59/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc?ref=9023bb8687347559702340c24cd72301f0656a59", "patch": "@@ -85,7 +85,7 @@ Intrinsics::compile (TyTy::FnType *fntype)\n   Location locus = ctx->get_mappings ()->lookup_location (fntype->get_ref ());\n   rust_error_at (locus, \"unknown builtin\");\n \n-  return ctx->get_backend ()->error_function ();\n+  return error_mark_node;\n }\n \n } // namespace Compile"}, {"sha": "d42cc1ef9984d002369ce167d5cda892d6ac4301", "filename": "gcc/rust/backend/rust-compile-item.cc", "status": "added", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9023bb8687347559702340c24cd72301f0656a59/gcc%2Frust%2Fbackend%2Frust-compile-item.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9023bb8687347559702340c24cd72301f0656a59/gcc%2Frust%2Fbackend%2Frust-compile-item.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.cc?ref=9023bb8687347559702340c24cd72301f0656a59", "patch": "@@ -0,0 +1,202 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-compile-item.h\"\n+#include \"rust-compile-implitem.h\"\n+#include \"rust-compile-expr.h\"\n+#include \"rust-compile-extern.h\"\n+#include \"rust-constexpr.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+void\n+CompileItem::visit (HIR::StaticItem &var)\n+{\n+  // have we already compiled this?\n+  Bvariable *static_decl_ref = nullptr;\n+  if (ctx->lookup_var_decl (var.get_mappings ().get_hirid (), &static_decl_ref))\n+    {\n+      reference\n+\t= ctx->get_backend ()->var_expression (static_decl_ref, ref_locus);\n+      return;\n+    }\n+\n+  TyTy::BaseType *resolved_type = nullptr;\n+  bool ok = ctx->get_tyctx ()->lookup_type (var.get_mappings ().get_hirid (),\n+\t\t\t\t\t    &resolved_type);\n+  rust_assert (ok);\n+\n+  tree type = TyTyResolveCompile::compile (ctx, resolved_type);\n+  tree value = CompileExpr::Compile (var.get_expr (), ctx);\n+\n+  const Resolver::CanonicalPath *canonical_path = nullptr;\n+  ok = ctx->get_mappings ()->lookup_canonical_path (\n+    var.get_mappings ().get_crate_num (), var.get_mappings ().get_nodeid (),\n+    &canonical_path);\n+  rust_assert (ok);\n+\n+  std::string name = canonical_path->get ();\n+  std::string asm_name = ctx->mangle_item (resolved_type, *canonical_path);\n+\n+  bool is_external = false;\n+  bool is_hidden = false;\n+  bool in_unique_section = true;\n+\n+  Bvariable *static_global\n+    = ctx->get_backend ()->global_variable (name, asm_name, type, is_external,\n+\t\t\t\t\t    is_hidden, in_unique_section,\n+\t\t\t\t\t    var.get_locus ());\n+  ctx->get_backend ()->global_variable_set_init (static_global, value);\n+\n+  ctx->insert_var_decl (var.get_mappings ().get_hirid (), static_global);\n+  ctx->push_var (static_global);\n+\n+  reference = ctx->get_backend ()->var_expression (static_global, ref_locus);\n+}\n+\n+void\n+CompileItem::visit (HIR::ConstantItem &constant)\n+{\n+  // resolve the type\n+  TyTy::BaseType *resolved_type = nullptr;\n+  bool ok\n+    = ctx->get_tyctx ()->lookup_type (constant.get_mappings ().get_hirid (),\n+\t\t\t\t      &resolved_type);\n+  rust_assert (ok);\n+\n+  // canonical path\n+  const Resolver::CanonicalPath *canonical_path = nullptr;\n+  ok = ctx->get_mappings ()->lookup_canonical_path (\n+    constant.get_mappings ().get_crate_num (),\n+    constant.get_mappings ().get_nodeid (), &canonical_path);\n+  rust_assert (ok);\n+\n+  HIR::Expr *const_value_expr = constant.get_expr ();\n+  tree const_expr\n+    = compile_constant_item (ctx, resolved_type, canonical_path,\n+\t\t\t     const_value_expr, constant.get_locus ());\n+\n+  ctx->push_const (const_expr);\n+  ctx->insert_const_decl (constant.get_mappings ().get_hirid (), const_expr);\n+  reference = const_expr;\n+}\n+\n+void\n+CompileItem::visit (HIR::Function &function)\n+{\n+  TyTy::BaseType *fntype_tyty;\n+  if (!ctx->get_tyctx ()->lookup_type (function.get_mappings ().get_hirid (),\n+\t\t\t\t       &fntype_tyty))\n+    {\n+      rust_fatal_error (function.get_locus (),\n+\t\t\t\"failed to lookup function type\");\n+      return;\n+    }\n+\n+  rust_assert (fntype_tyty->get_kind () == TyTy::TypeKind::FNDEF);\n+  TyTy::FnType *fntype = static_cast<TyTy::FnType *> (fntype_tyty);\n+  if (fntype->has_subsititions_defined ())\n+    {\n+      // we cant do anything for this only when it is used and a concrete type\n+      // is given\n+      if (concrete == nullptr)\n+\treturn;\n+      else\n+\t{\n+\t  rust_assert (concrete->get_kind () == TyTy::TypeKind::FNDEF);\n+\t  fntype = static_cast<TyTy::FnType *> (concrete);\n+\t}\n+    }\n+\n+  // items can be forward compiled which means we may not need to invoke this\n+  // code. We might also have already compiled this generic function as well.\n+  tree lookup = NULL_TREE;\n+  if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup,\n+\t\t\t\t fntype->get_id (), fntype))\n+    {\n+      // has this been added to the list then it must be finished\n+      if (ctx->function_completed (lookup))\n+\t{\n+\t  tree dummy = NULL_TREE;\n+\t  if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &dummy))\n+\t    {\n+\t      ctx->insert_function_decl (fntype, lookup);\n+\t    }\n+\n+\t  reference = address_expression (lookup, ref_locus);\n+\t  return;\n+\t}\n+    }\n+\n+  if (fntype->has_subsititions_defined ())\n+    {\n+      // override the Hir Lookups for the substituions in this context\n+      fntype->override_context ();\n+    }\n+\n+  const Resolver::CanonicalPath *canonical_path = nullptr;\n+  bool ok = ctx->get_mappings ()->lookup_canonical_path (\n+    function.get_mappings ().get_crate_num (),\n+    function.get_mappings ().get_nodeid (), &canonical_path);\n+  rust_assert (ok);\n+\n+  tree fndecl\n+    = compile_function (ctx, function.get_function_name (),\n+\t\t\tfunction.get_self_param (),\n+\t\t\tfunction.get_function_params (),\n+\t\t\tfunction.get_qualifiers (), function.get_visibility (),\n+\t\t\tfunction.get_outer_attrs (), function.get_locus (),\n+\t\t\tfunction.get_definition ().get (), canonical_path,\n+\t\t\tfntype, function.has_function_return_type ());\n+  reference = address_expression (fndecl, ref_locus);\n+}\n+\n+void\n+CompileItem::visit (HIR::ImplBlock &impl_block)\n+{\n+  TyTy::BaseType *self_lookup = nullptr;\n+  if (!ctx->get_tyctx ()->lookup_type (\n+\timpl_block.get_type ()->get_mappings ().get_hirid (), &self_lookup))\n+    {\n+      rust_error_at (impl_block.get_locus (), \"failed to resolve type of impl\");\n+      return;\n+    }\n+\n+  for (auto &impl_item : impl_block.get_impl_items ())\n+    CompileInherentImplItem::Compile (impl_item.get (), ctx);\n+}\n+\n+void\n+CompileItem::visit (HIR::ExternBlock &extern_block)\n+{\n+  for (auto &item : extern_block.get_extern_items ())\n+    {\n+      CompileExternItem::compile (item.get (), ctx, concrete);\n+    }\n+}\n+\n+void\n+CompileItem::visit (HIR::Module &module)\n+{\n+  for (auto &item : module.get_items ())\n+    CompileItem::compile (item.get (), ctx);\n+}\n+\n+} // namespace Compile\n+} // namespace Rust"}, {"sha": "897fe851755c323948a4f933ecc258538972b85e", "filename": "gcc/rust/backend/rust-compile-item.h", "status": "modified", "additions": 7, "deletions": 363, "changes": 370, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9023bb8687347559702340c24cd72301f0656a59/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9023bb8687347559702340c24cd72301f0656a59/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.h?ref=9023bb8687347559702340c24cd72301f0656a59", "patch": "@@ -20,14 +20,6 @@\n #define RUST_COMPILE_ITEM\n \n #include \"rust-compile-base.h\"\n-#include \"rust-compile-tyty.h\"\n-#include \"rust-compile-implitem.h\"\n-#include \"rust-compile-var-decl.h\"\n-#include \"rust-compile-stmt.h\"\n-#include \"rust-compile-expr.h\"\n-#include \"rust-compile-fnparam.h\"\n-#include \"rust-compile-extern.h\"\n-#include \"rust-constexpr.h\"\n \n namespace Rust {\n namespace Compile {\n@@ -46,372 +38,24 @@ class CompileItem : public HIRCompileBase\n     CompileItem compiler (ctx, concrete, ref_locus);\n     item->accept_vis (compiler);\n \n-    if (is_query_mode\n-\t&& ctx->get_backend ()->is_error_expression (compiler.reference))\n+    if (is_query_mode && compiler.reference == error_mark_node)\n       rust_internal_error_at (ref_locus, \"failed to compile item: %s\",\n \t\t\t      item->as_string ().c_str ());\n \n     return compiler.reference;\n   }\n \n-  void visit (HIR::StaticItem &var) override\n-  {\n-    // have we already compiled this?\n-    Bvariable *static_decl_ref = nullptr;\n-    if (ctx->lookup_var_decl (var.get_mappings ().get_hirid (),\n-\t\t\t      &static_decl_ref))\n-      {\n-\treference\n-\t  = ctx->get_backend ()->var_expression (static_decl_ref, ref_locus);\n-\treturn;\n-      }\n-\n-    TyTy::BaseType *resolved_type = nullptr;\n-    bool ok = ctx->get_tyctx ()->lookup_type (var.get_mappings ().get_hirid (),\n-\t\t\t\t\t      &resolved_type);\n-    rust_assert (ok);\n-\n-    tree type = TyTyResolveCompile::compile (ctx, resolved_type);\n-    tree value = CompileExpr::Compile (var.get_expr (), ctx);\n-\n-    const Resolver::CanonicalPath *canonical_path = nullptr;\n-    ok = ctx->get_mappings ()->lookup_canonical_path (\n-      var.get_mappings ().get_crate_num (), var.get_mappings ().get_nodeid (),\n-      &canonical_path);\n-    rust_assert (ok);\n-\n-    std::string name = canonical_path->get ();\n-    std::string asm_name = ctx->mangle_item (resolved_type, *canonical_path);\n-\n-    bool is_external = false;\n-    bool is_hidden = false;\n-    bool in_unique_section = true;\n-\n-    Bvariable *static_global\n-      = ctx->get_backend ()->global_variable (name, asm_name, type, is_external,\n-\t\t\t\t\t      is_hidden, in_unique_section,\n-\t\t\t\t\t      var.get_locus ());\n-    ctx->get_backend ()->global_variable_set_init (static_global, value);\n-\n-    ctx->insert_var_decl (var.get_mappings ().get_hirid (), static_global);\n-    ctx->push_var (static_global);\n-\n-    reference = ctx->get_backend ()->var_expression (static_global, ref_locus);\n-  }\n-\n-  void visit (HIR::ConstantItem &constant) override\n-  {\n-    // resolve the type\n-    TyTy::BaseType *resolved_type = nullptr;\n-    bool ok\n-      = ctx->get_tyctx ()->lookup_type (constant.get_mappings ().get_hirid (),\n-\t\t\t\t\t&resolved_type);\n-    rust_assert (ok);\n-\n-    // canonical path\n-    const Resolver::CanonicalPath *canonical_path = nullptr;\n-    ok = ctx->get_mappings ()->lookup_canonical_path (\n-      constant.get_mappings ().get_crate_num (),\n-      constant.get_mappings ().get_nodeid (), &canonical_path);\n-    rust_assert (ok);\n-    std::string ident = canonical_path->get ();\n-\n-    // types\n-    tree type = TyTyResolveCompile::compile (ctx, resolved_type);\n-    tree const_type = build_qualified_type (type, TYPE_QUAL_CONST);\n-\n-    HIR::Expr *const_value_expr = constant.get_expr ();\n-    bool is_block_expr\n-      = const_value_expr->get_expression_type () == HIR::Expr::ExprType::Block;\n-\n-    // compile the expression\n-    tree folded_expr = error_mark_node;\n-    if (!is_block_expr)\n-      {\n-\ttree value = CompileExpr::Compile (constant.get_expr (), ctx);\n-\tfolded_expr = ConstCtx::fold (value);\n-      }\n-    else\n-      {\n-\t// in order to compile a block expr we want to reuse as much existing\n-\t// machineary that we already have. This means the best approach is to\n-\t// make a _fake_ function with a block so it can hold onto temps then\n-\t// use our constexpr code to fold it completely or error_mark_node\n-\tBackend::typed_identifier receiver;\n-\ttree compiled_fn_type = ctx->get_backend ()->function_type (\n-\t  receiver, {},\n-\t  {Backend::typed_identifier (\"_\", const_type, constant.get_locus ())},\n-\t  NULL, constant.get_locus ());\n-\n-\ttree fndecl\n-\t  = ctx->get_backend ()->function (compiled_fn_type, ident, \"\", 0,\n-\t\t\t\t\t   constant.get_locus ());\n-\tTREE_READONLY (fndecl) = 1;\n-\n-\ttree enclosing_scope = NULL_TREE;\n-\tHIR::BlockExpr *function_body\n-\t  = static_cast<HIR::BlockExpr *> (constant.get_expr ());\n-\tLocation start_location = function_body->get_locus ();\n-\tLocation end_location = function_body->get_end_locus ();\n-\n-\ttree code_block\n-\t  = ctx->get_backend ()->block (fndecl, enclosing_scope, {},\n-\t\t\t\t\tstart_location, end_location);\n-\tctx->push_block (code_block);\n-\n-\tbool address_is_taken = false;\n-\ttree ret_var_stmt = NULL_TREE;\n-\tBvariable *return_address = ctx->get_backend ()->temporary_variable (\n-\t  fndecl, code_block, const_type, NULL, address_is_taken,\n-\t  constant.get_locus (), &ret_var_stmt);\n-\n-\tctx->add_statement (ret_var_stmt);\n-\tctx->push_fn (fndecl, return_address);\n-\n-\tcompile_function_body (fndecl, *function_body, true);\n-\n-\tctx->pop_block ();\n-\n-\tauto body = ctx->get_backend ()->block_statement (code_block);\n-\tif (!ctx->get_backend ()->function_set_body (fndecl, body))\n-\t  {\n-\t    rust_error_at (constant.get_locus (),\n-\t\t\t   \"failed to set body to constant function\");\n-\t    return;\n-\t  }\n-\n-\tctx->pop_fn ();\n-\n-\t// lets fold it into a call expr\n-\ttree call = build_call_array_loc (constant.get_locus ().gcc_location (),\n-\t\t\t\t\t  const_type, fndecl, 0, NULL);\n-\tfolded_expr = ConstCtx::fold (call);\n-      }\n-\n-    tree const_expr\n-      = ctx->get_backend ()->named_constant_expression (const_type, ident,\n-\t\t\t\t\t\t\tfolded_expr,\n-\t\t\t\t\t\t\tconstant.get_locus ());\n-\n-    ctx->push_const (const_expr);\n-    ctx->insert_const_decl (constant.get_mappings ().get_hirid (), const_expr);\n-\n-    reference = const_expr;\n-  }\n-\n-  void visit (HIR::Function &function) override\n-  {\n-    TyTy::BaseType *fntype_tyty;\n-    if (!ctx->get_tyctx ()->lookup_type (function.get_mappings ().get_hirid (),\n-\t\t\t\t\t &fntype_tyty))\n-      {\n-\trust_fatal_error (function.get_locus (),\n-\t\t\t  \"failed to lookup function type\");\n-\treturn;\n-      }\n-\n-    rust_assert (fntype_tyty->get_kind () == TyTy::TypeKind::FNDEF);\n-    TyTy::FnType *fntype = static_cast<TyTy::FnType *> (fntype_tyty);\n-    if (fntype->has_subsititions_defined ())\n-      {\n-\t// we cant do anything for this only when it is used and a concrete type\n-\t// is given\n-\tif (concrete == nullptr)\n-\t  return;\n-\telse\n-\t  {\n-\t    rust_assert (concrete->get_kind () == TyTy::TypeKind::FNDEF);\n-\t    fntype = static_cast<TyTy::FnType *> (concrete);\n-\t  }\n-      }\n-\n-    // items can be forward compiled which means we may not need to invoke this\n-    // code. We might also have already compiled this generic function as well.\n-    tree lookup = NULL_TREE;\n-    if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup,\n-\t\t\t\t   fntype->get_id (), fntype))\n-      {\n-\t// has this been added to the list then it must be finished\n-\tif (ctx->function_completed (lookup))\n-\t  {\n-\t    tree dummy = NULL_TREE;\n-\t    if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &dummy))\n-\t      {\n-\t\tctx->insert_function_decl (fntype, lookup);\n-\t      }\n+  void visit (HIR::StaticItem &var) override;\n \n-\t    reference\n-\t      = ctx->get_backend ()->function_code_expression (lookup,\n-\t\t\t\t\t\t\t       ref_locus);\n-\t    return;\n-\t  }\n-      }\n+  void visit (HIR::ConstantItem &constant) override;\n \n-    if (fntype->has_subsititions_defined ())\n-      {\n-\t// override the Hir Lookups for the substituions in this context\n-\tfntype->override_context ();\n-      }\n+  void visit (HIR::Function &function) override;\n \n-    tree compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n+  void visit (HIR::ImplBlock &impl_block) override;\n \n-    const Resolver::CanonicalPath *canonical_path = nullptr;\n-    bool ok = ctx->get_mappings ()->lookup_canonical_path (\n-      function.get_mappings ().get_crate_num (),\n-      function.get_mappings ().get_nodeid (), &canonical_path);\n-    rust_assert (ok);\n+  void visit (HIR::ExternBlock &extern_block) override;\n \n-    std::string ir_symbol_name\n-      = canonical_path->get () + fntype->subst_as_string ();\n-    std::string asm_name = function.get_function_name ();\n-\n-    // we don't mangle the main fn since we haven't implemented the main shim\n-    // yet\n-    bool is_main_fn = function.get_function_name ().compare (\"main\") == 0;\n-    if (!is_main_fn)\n-      {\n-\tasm_name = ctx->mangle_item (fntype, *canonical_path);\n-      }\n-\n-    unsigned int flags = 0;\n-    tree fndecl\n-      = ctx->get_backend ()->function (compiled_fn_type, ir_symbol_name,\n-\t\t\t\t       asm_name, flags, function.get_locus ());\n-    setup_attributes_on_fndecl (fndecl, is_main_fn, function.has_visibility (),\n-\t\t\t\tfunction.get_qualifiers (),\n-\t\t\t\tfunction.get_outer_attrs ());\n-\n-    // insert into the context\n-    ctx->insert_function_decl (fntype, fndecl);\n-\n-    // setup the params\n-    TyTy::BaseType *tyret = fntype->get_return_type ();\n-    std::vector<Bvariable *> param_vars;\n-\n-    size_t i = 0;\n-    for (auto &it : fntype->get_params ())\n-      {\n-\tHIR::FunctionParam &referenced_param\n-\t  = function.get_function_params ().at (i);\n-\tauto param_tyty = it.second;\n-\tauto compiled_param_type\n-\t  = TyTyResolveCompile::compile (ctx, param_tyty);\n-\n-\tLocation param_locus\n-\t  = ctx->get_mappings ()->lookup_location (param_tyty->get_ref ());\n-\tBvariable *compiled_param_var\n-\t  = CompileFnParam::compile (ctx, fndecl, &referenced_param,\n-\t\t\t\t     compiled_param_type, param_locus);\n-\tif (compiled_param_var == nullptr)\n-\t  {\n-\t    rust_error_at (param_locus, \"failed to compile parameter variable\");\n-\t    return;\n-\t  }\n-\n-\tparam_vars.push_back (compiled_param_var);\n-\n-\tctx->insert_var_decl (referenced_param.get_mappings ().get_hirid (),\n-\t\t\t      compiled_param_var);\n-\ti++;\n-      }\n-\n-    if (!ctx->get_backend ()->function_set_parameters (fndecl, param_vars))\n-      {\n-\trust_fatal_error (function.get_locus (),\n-\t\t\t  \"failed to setup parameter variables\");\n-\treturn;\n-      }\n-\n-    // lookup locals\n-    auto block_expr = function.get_definition ().get ();\n-    auto body_mappings = block_expr->get_mappings ();\n-\n-    Resolver::Rib *rib = nullptr;\n-    if (!ctx->get_resolver ()->find_name_rib (body_mappings.get_nodeid (),\n-\t\t\t\t\t      &rib))\n-      {\n-\trust_fatal_error (function.get_locus (),\n-\t\t\t  \"failed to setup locals per block\");\n-\treturn;\n-      }\n-\n-    std::vector<Bvariable *> locals;\n-    ok = compile_locals_for_block (*rib, fndecl, locals);\n-    rust_assert (ok);\n-\n-    tree enclosing_scope = NULL_TREE;\n-    HIR::BlockExpr *function_body = function.get_definition ().get ();\n-    Location start_location = function_body->get_locus ();\n-    Location end_location = function_body->get_end_locus ();\n-\n-    tree code_block\n-      = ctx->get_backend ()->block (fndecl, enclosing_scope, locals,\n-\t\t\t\t    start_location, end_location);\n-    ctx->push_block (code_block);\n-\n-    Bvariable *return_address = nullptr;\n-    if (function.has_function_return_type ())\n-      {\n-\ttree return_type = TyTyResolveCompile::compile (ctx, tyret);\n-\n-\tbool address_is_taken = false;\n-\ttree ret_var_stmt = NULL_TREE;\n-\n-\treturn_address = ctx->get_backend ()->temporary_variable (\n-\t  fndecl, code_block, return_type, NULL, address_is_taken,\n-\t  function.get_locus (), &ret_var_stmt);\n-\n-\tctx->add_statement (ret_var_stmt);\n-      }\n-\n-    ctx->push_fn (fndecl, return_address);\n-\n-    compile_function_body (fndecl, *function.get_definition ().get (),\n-\t\t\t   function.has_function_return_type ());\n-\n-    ctx->pop_block ();\n-    auto body = ctx->get_backend ()->block_statement (code_block);\n-    if (!ctx->get_backend ()->function_set_body (fndecl, body))\n-      {\n-\trust_error_at (function.get_locus (), \"failed to set body to function\");\n-\treturn;\n-      }\n-\n-    ctx->pop_fn ();\n-    ctx->push_function (fndecl);\n-\n-    reference\n-      = ctx->get_backend ()->function_code_expression (fndecl, ref_locus);\n-  }\n-\n-  void visit (HIR::ImplBlock &impl_block) override\n-  {\n-    TyTy::BaseType *self_lookup = nullptr;\n-    if (!ctx->get_tyctx ()->lookup_type (\n-\t  impl_block.get_type ()->get_mappings ().get_hirid (), &self_lookup))\n-      {\n-\trust_error_at (impl_block.get_locus (),\n-\t\t       \"failed to resolve type of impl\");\n-\treturn;\n-      }\n-\n-    for (auto &impl_item : impl_block.get_impl_items ())\n-      CompileInherentImplItem::Compile (impl_item.get (), ctx);\n-  }\n-\n-  void visit (HIR::ExternBlock &extern_block) override\n-  {\n-    for (auto &item : extern_block.get_extern_items ())\n-      {\n-\tCompileExternItem::compile (item.get (), ctx, concrete);\n-      }\n-  }\n-\n-  void visit (HIR::Module &module) override\n-  {\n-    for (auto &item : module.get_items ())\n-      CompileItem::compile (item.get (), ctx);\n-  }\n+  void visit (HIR::Module &module) override;\n \n protected:\n   CompileItem (Context *ctx, TyTy::BaseType *concrete, Location ref_locus)"}, {"sha": "e41ee7f1493a15cca72971376a43b843bf21f3ee", "filename": "gcc/rust/backend/rust-compile-resolve-path.cc", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9023bb8687347559702340c24cd72301f0656a59/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9023bb8687347559702340c24cd72301f0656a59/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc?ref=9023bb8687347559702340c24cd72301f0656a59", "patch": "@@ -16,10 +16,10 @@\n // along with GCC; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-#include \"rust-linemap.h\"\n-#include \"rust-backend.h\"\n #include \"rust-compile-resolve-path.h\"\n #include \"rust-compile-item.h\"\n+#include \"rust-compile-implitem.h\"\n+#include \"rust-compile-expr.h\"\n #include \"rust-hir-trait-resolve.h\"\n #include \"rust-hir-path-probe.h\"\n \n@@ -58,7 +58,7 @@ ResolvePathRef::resolve (const HIR::PathIdentSegment &final_segment,\n       if (!ctx->get_resolver ()->lookup_definition (ref_node_id, &def))\n \t{\n \t  rust_error_at (expr_locus, \"unknown reference for resolved name\");\n-\t  return ctx->get_backend ()->error_expression ();\n+\t  return error_mark_node;\n \t}\n       ref_node_id = def.parent;\n     }\n@@ -69,22 +69,22 @@ ResolvePathRef::resolve (const HIR::PathIdentSegment &final_segment,\n     {\n       // it might be an enum data-less enum variant\n       if (lookup->get_kind () != TyTy::TypeKind::ADT)\n-\treturn ctx->get_backend ()->error_expression ();\n+\treturn error_mark_node;\n \n       TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (lookup);\n       if (!adt->is_enum ())\n-\treturn ctx->get_backend ()->error_expression ();\n+\treturn error_mark_node;\n \n       HirId variant_id;\n       if (!ctx->get_tyctx ()->lookup_variant_definition (mappings.get_hirid (),\n \t\t\t\t\t\t\t &variant_id))\n-\treturn ctx->get_backend ()->error_expression ();\n+\treturn error_mark_node;\n \n       int union_disriminator = -1;\n       TyTy::VariantDef *variant = nullptr;\n       if (!adt->lookup_variant_by_id (variant_id, &variant,\n \t\t\t\t      &union_disriminator))\n-\treturn ctx->get_backend ()->error_expression ();\n+\treturn error_mark_node;\n \n       // this can only be for discriminant variants the others are built up\n       // using call-expr or struct-init\n@@ -111,7 +111,7 @@ ResolvePathRef::resolve (const HIR::PathIdentSegment &final_segment,\n \t\t\t\t\t\t ref_node_id, &ref))\n     {\n       rust_error_at (expr_locus, \"reverse call path lookup failure\");\n-      return ctx->get_backend ()->error_expression ();\n+      return error_mark_node;\n     }\n \n   // might be a constant\n@@ -131,7 +131,7 @@ ResolvePathRef::resolve (const HIR::PathIdentSegment &final_segment,\n       tree fn = NULL_TREE;\n       if (ctx->lookup_function_decl (fntype->get_ty_ref (), &fn))\n \t{\n-\t  return ctx->get_backend ()->function_code_expression (fn, expr_locus);\n+\t  return address_expression (fn, expr_locus);\n \t}\n     }\n \n@@ -245,8 +245,8 @@ HIRCompileBase::query_compile (HirId ref, TyTy::BaseType *lookup,\n \t      associated->setup_associated_types ();\n \n \t      return CompileTraitItem::Compile (\n-\t\treceiver, trait_item_ref->get_hir_trait_item (), ctx, lookup,\n-\t\ttrue, expr_locus);\n+\t\ttrait_item_ref->get_hir_trait_item (), ctx, lookup, true,\n+\t\texpr_locus);\n \t    }\n \t  else\n \t    {\n@@ -274,7 +274,7 @@ HIRCompileBase::query_compile (HirId ref, TyTy::BaseType *lookup,\n \t}\n     }\n \n-  return ctx->get_backend ()->error_expression ();\n+  return error_mark_node;\n }\n \n } // namespace Compile"}, {"sha": "9c9d7c558ef8b1a4d14f38f15738cf4a73c89d52", "filename": "gcc/rust/backend/rust-compile-resolve-path.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9023bb8687347559702340c24cd72301f0656a59/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9023bb8687347559702340c24cd72301f0656a59/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h?ref=9023bb8687347559702340c24cd72301f0656a59", "patch": "@@ -50,7 +50,7 @@ class ResolvePathRef : public HIRCompileBase\n \n private:\n   ResolvePathRef (Context *ctx)\n-    : HIRCompileBase (ctx), resolved (ctx->get_backend ()->error_expression ())\n+    : HIRCompileBase (ctx), resolved (error_mark_node)\n   {}\n \n   tree resolve (const HIR::PathIdentSegment &final_segment,"}, {"sha": "24a2084bae289fc513de3a7259e331ecccc1fbd8", "filename": "gcc/rust/backend/rust-compile-stmt.h", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9023bb8687347559702340c24cd72301f0656a59/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9023bb8687347559702340c24cd72301f0656a59/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h?ref=9023bb8687347559702340c24cd72301f0656a59", "patch": "@@ -48,34 +48,6 @@ class CompileStmt : public HIRCompileBase\n     translated = CompileExpr::Compile (stmt.get_expr (), ctx);\n   }\n \n-  void visit (HIR::ConstantItem &constant) override\n-  {\n-    TyTy::BaseType *resolved_type = nullptr;\n-    bool ok\n-      = ctx->get_tyctx ()->lookup_type (constant.get_mappings ().get_hirid (),\n-\t\t\t\t\t&resolved_type);\n-    rust_assert (ok);\n-\n-    tree type = TyTyResolveCompile::compile (ctx, resolved_type);\n-    tree value = CompileExpr::Compile (constant.get_expr (), ctx);\n-\n-    const Resolver::CanonicalPath *canonical_path = nullptr;\n-    ok = ctx->get_mappings ()->lookup_canonical_path (\n-      constant.get_mappings ().get_crate_num (),\n-      constant.get_mappings ().get_nodeid (), &canonical_path);\n-    rust_assert (ok);\n-\n-    std::string ident = canonical_path->get ();\n-    tree const_expr\n-      = ctx->get_backend ()->named_constant_expression (type, ident, value,\n-\t\t\t\t\t\t\tconstant.get_locus ());\n-\n-    ctx->push_const (const_expr);\n-    ctx->insert_const_decl (constant.get_mappings ().get_hirid (), const_expr);\n-\n-    translated = const_expr;\n-  }\n-\n   void visit (HIR::LetStmt &stmt) override\n   {\n     // nothing to do"}, {"sha": "c431edd9172fc13538ec0294cc51d13e9c311f24", "filename": "gcc/rust/backend/rust-compile-var-decl.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9023bb8687347559702340c24cd72301f0656a59/gcc%2Frust%2Fbackend%2Frust-compile-var-decl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9023bb8687347559702340c24cd72301f0656a59/gcc%2Frust%2Fbackend%2Frust-compile-var-decl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-var-decl.h?ref=9023bb8687347559702340c24cd72301f0656a59", "patch": "@@ -72,8 +72,7 @@ class CompileVarDecl : public HIRCompileBase\n \n private:\n   CompileVarDecl (Context *ctx, tree fndecl)\n-    : HIRCompileBase (ctx), fndecl (fndecl),\n-      translated_type (ctx->get_backend ()->error_type ()),\n+    : HIRCompileBase (ctx), fndecl (fndecl), translated_type (error_mark_node),\n       compiled_variable (ctx->get_backend ()->error_variable ())\n   {}\n "}, {"sha": "fcbfc05a6c599559aebd277b50d292c45ac90cc3", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 10, "deletions": 90, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9023bb8687347559702340c24cd72301f0656a59/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9023bb8687347559702340c24cd72301f0656a59/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=9023bb8687347559702340c24cd72301f0656a59", "patch": "@@ -16,14 +16,16 @@\n // along with GCC; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-#include \"rust-compile.h\"\n-#include \"rust-compile-item.h\"\n-#include \"rust-compile-expr.h\"\n-#include \"rust-compile-struct-field-expr.h\"\n #include \"rust-hir-trait-resolve.h\"\n #include \"rust-hir-path-probe.h\"\n #include \"rust-hir-type-bounds.h\"\n #include \"rust-hir-dot-operator.h\"\n+#include \"rust-compile.h\"\n+#include \"rust-compile-item.h\"\n+#include \"rust-compile-implitem.h\"\n+#include \"rust-compile-expr.h\"\n+#include \"rust-compile-struct-field-expr.h\"\n+#include \"rust-compile-stmt.h\"\n \n namespace Rust {\n namespace Compile {\n@@ -67,9 +69,8 @@ CompileBlock::visit (HIR::BlockExpr &expr)\n       return;\n     }\n \n-  std::vector<Bvariable *> locals;\n-  bool ok = compile_locals_for_block (*rib, fndecl, locals);\n-  rust_assert (ok);\n+  std::vector<Bvariable *> locals\n+    = compile_locals_for_block (ctx, *rib, fndecl);\n \n   tree enclosing_scope = ctx->peek_enclosing_scope ();\n   tree new_block = ctx->get_backend ()->block (fndecl, enclosing_scope, locals,\n@@ -203,87 +204,6 @@ CompileStructExprField::visit (HIR::StructExprFieldIdentifier &field)\n \n // Shared methods in compilation\n \n-void\n-HIRCompileBase::compile_function_body (tree fndecl,\n-\t\t\t\t       HIR::BlockExpr &function_body,\n-\t\t\t\t       bool has_return_type)\n-{\n-  for (auto &s : function_body.get_statements ())\n-    {\n-      auto compiled_expr = CompileStmt::Compile (s.get (), ctx);\n-      if (compiled_expr != nullptr)\n-\t{\n-\t  tree compiled_stmt\n-\t    = ctx->get_backend ()->expression_statement (fndecl, compiled_expr);\n-\t  ctx->add_statement (compiled_stmt);\n-\t}\n-    }\n-\n-  if (function_body.has_expr ())\n-    {\n-      // the previous passes will ensure this is a valid return\n-      // or a valid trailing expression\n-      tree compiled_expr\n-\t= CompileExpr::Compile (function_body.expr.get (), ctx);\n-\n-      if (compiled_expr != nullptr)\n-\t{\n-\t  if (has_return_type)\n-\t    {\n-\t      std::vector<tree> retstmts;\n-\t      retstmts.push_back (compiled_expr);\n-\n-\t      auto ret = ctx->get_backend ()->return_statement (\n-\t\tfndecl, retstmts,\n-\t\tfunction_body.get_final_expr ()->get_locus ());\n-\t      ctx->add_statement (ret);\n-\t    }\n-\t  else\n-\t    {\n-\t      tree final_stmt\n-\t\t= ctx->get_backend ()->expression_statement (fndecl,\n-\t\t\t\t\t\t\t     compiled_expr);\n-\t      ctx->add_statement (final_stmt);\n-\t    }\n-\t}\n-    }\n-}\n-\n-bool\n-HIRCompileBase::compile_locals_for_block (Resolver::Rib &rib, tree fndecl,\n-\t\t\t\t\t  std::vector<Bvariable *> &locals)\n-{\n-  rib.iterate_decls ([&] (NodeId n, Location) mutable -> bool {\n-    Resolver::Definition d;\n-    bool ok = ctx->get_resolver ()->lookup_definition (n, &d);\n-    rust_assert (ok);\n-\n-    HIR::Stmt *decl = nullptr;\n-    ok = ctx->get_mappings ()->resolve_nodeid_to_stmt (d.parent, &decl);\n-    rust_assert (ok);\n-\n-    // if its a function we extract this out side of this fn context\n-    // and it is not a local to this function\n-    bool is_item = ctx->get_mappings ()->lookup_hir_item (\n-\t\t     decl->get_mappings ().get_crate_num (),\n-\t\t     decl->get_mappings ().get_hirid ())\n-\t\t   != nullptr;\n-    if (is_item)\n-      {\n-\tHIR::Item *item = static_cast<HIR::Item *> (decl);\n-\tCompileItem::compile (item, ctx);\n-\treturn true;\n-      }\n-\n-    Bvariable *compiled = CompileVarDecl::compile (fndecl, decl, ctx);\n-    locals.push_back (compiled);\n-\n-    return true;\n-  });\n-\n-  return true;\n-}\n-\n tree\n HIRCompileBase::coercion_site (tree rvalue, TyTy::BaseType *actual,\n \t\t\t       TyTy::BaseType *expected, Location lvalue_locus,\n@@ -533,8 +453,8 @@ HIRCompileBase::compute_address_for_trait_item (\n   rust_assert (trait_item_has_definition);\n \n   HIR::TraitItem *trait_item = ref->get_hir_trait_item ();\n-  return CompileTraitItem::Compile (root, trait_item, ctx, trait_item_fntype,\n-\t\t\t\t    true, locus);\n+  return CompileTraitItem::Compile (trait_item, ctx, trait_item_fntype, true,\n+\t\t\t\t    locus);\n }\n \n bool"}, {"sha": "d1cb762dce2bae7dde7c3a88ebe3924dbce9bc1b", "filename": "gcc/rust/hir/tree/rust-hir-item.h", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9023bb8687347559702340c24cd72301f0656a59/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9023bb8687347559702340c24cd72301f0656a59/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h?ref=9023bb8687347559702340c24cd72301f0656a59", "patch": "@@ -510,7 +510,6 @@ struct FunctionParam\n {\n   std::unique_ptr<Pattern> param_name;\n   std::unique_ptr<Type> type;\n-\n   Location locus;\n   Analysis::NodeMapping mappings;\n \n@@ -1226,11 +1225,7 @@ class Function : public VisItem, public ImplItem\n \n   bool is_method () const { return !self.is_error (); }\n \n-  SelfParam &get_self_param ()\n-  {\n-    rust_assert (is_method ());\n-    return self;\n-  }\n+  SelfParam &get_self_param () { return self; }\n \n protected:\n   /* Use covariance to implement clone function as returning this object\n@@ -2242,11 +2237,7 @@ struct TraitFunctionDecl\n \n   bool is_method () const { return !self.is_error (); }\n \n-  SelfParam &get_self ()\n-  {\n-    rust_assert (is_method ());\n-    return self;\n-  }\n+  SelfParam &get_self () { return self; }\n \n   Identifier get_function_name () const { return function_name; }\n \n@@ -2341,7 +2332,8 @@ class TraitItemFunc : public TraitItem\n     return TraitItemKind::FUNC;\n   }\n \n-  AST::AttrVec get_outer_attrs () const { return outer_attrs; }\n+  AST::AttrVec &get_outer_attrs () { return outer_attrs; }\n+  const AST::AttrVec &get_outer_attrs () const { return outer_attrs; }\n \n protected:\n   // Clone function implementation as (not pure) virtual method"}, {"sha": "fe809c911e22e40866d9faca292bedc195e64b8c", "filename": "gcc/rust/rust-backend.h", "status": "modified", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9023bb8687347559702340c24cd72301f0656a59/gcc%2Frust%2Frust-backend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9023bb8687347559702340c24cd72301f0656a59/gcc%2Frust%2Frust-backend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-backend.h?ref=9023bb8687347559702340c24cd72301f0656a59", "patch": "@@ -29,12 +29,6 @@\n #include \"operator.h\"\n #include \"tree.h\"\n \n-extern bool\n-saw_errors (void);\n-\n-// TODO: Will have to be significantly modified to work with Rust and current\n-// setup of gccrs\n-\n // Pointers to these types are created by the backend, passed to the\n // frontend, and passed back to the backend.  The types must be\n // defined by the backend using these names.\n@@ -76,15 +70,6 @@ class Backend\n \n   // Types.\n \n-  // Produce an error type.  Actually the backend could probably just\n-  // crash if this is called.\n-  virtual tree error_type () = 0;\n-\n-  // Get a void type.  This is used in (at least) two ways: 1) as the\n-  // return type of a function with no result parameters; 2)\n-  // unsafe.Pointer is represented as *void.\n-  virtual tree void_type () = 0;\n-\n   // get unit-type\n   virtual tree unit_type () = 0;\n \n@@ -188,17 +173,6 @@ class Backend\n   // converting nil to other types.\n   virtual tree zero_expression (tree) = 0;\n \n-  // Create an error expression. This is used for cases which should\n-  // not occur in a correct program, in order to keep the compilation\n-  // going without crashing.\n-  virtual tree error_expression () = 0;\n-\n-  // return whether this is error_mark_node\n-  virtual bool is_error_expression (tree) = 0;\n-\n-  // Create a nil pointer expression.\n-  virtual tree nil_pointer_expression () = 0;\n-\n   virtual tree unit_expression () = 0;\n \n   // Create a reference to a variable.\n@@ -212,12 +186,6 @@ class Backend\n \t\t\t\t    Location)\n     = 0;\n \n-  // Return an expression that declares a constant named NAME with the\n-  // constant value VAL in BTYPE.\n-  virtual tree named_constant_expression (tree btype, const std::string &name,\n-\t\t\t\t\t  tree val, Location)\n-    = 0;\n-\n   // Return an expression for the multi-precision integer VAL in BTYPE.\n   virtual tree integer_constant_expression (tree btype, mpz_t val) = 0;\n \n@@ -251,10 +219,6 @@ class Backend\n   // Return an expression that converts EXPR to TYPE.\n   virtual tree convert_expression (tree type, tree expr, Location) = 0;\n \n-  // Create an expression for the address of a function.  This is used to\n-  // get the address of the code for a function.\n-  virtual tree function_code_expression (tree, Location) = 0;\n-\n   // Return an expression for the field at INDEX in BSTRUCT.\n   virtual tree struct_field_expression (tree bstruct, size_t index, Location)\n     = 0;\n@@ -328,11 +292,6 @@ class Backend\n \n   // Statements.\n \n-  // Create an error statement.  This is used for cases which should\n-  // not occur in a correct program, in order to keep the compilation\n-  // going without crashing.\n-  virtual tree error_statement () = 0;\n-\n   // Create an expression statement within the specified function.\n   virtual tree expression_statement (tree, tree) = 0;\n \n@@ -409,10 +368,6 @@ class Backend\n   // be empty if there are no statements.\n   virtual void block_add_statements (tree, const std::vector<tree> &) = 0;\n \n-  // Return the block as a statement.  This is used to include a block\n-  // in a list of statements.\n-  virtual tree block_statement (tree) = 0;\n-\n   // Variables.\n \n   // Create an error variable.  This is used for cases which should\n@@ -512,11 +467,6 @@ class Backend\n \n   // Functions.\n \n-  // Create an error function.  This is used for cases which should\n-  // not occur in a correct program, in order to keep the compilation\n-  // going without crashing.\n-  virtual tree error_function () = 0;\n-\n   // Bit flags to pass to the function method.\n \n   // Set if this is a function declaration rather than a definition;\n@@ -561,10 +511,6 @@ class Backend\n \t\t\t   const std::vector<Bvariable *> &param_vars)\n     = 0;\n \n-  // Set the function body for FUNCTION using the code in CODE_STMT.  Returns\n-  // true on success, false on failure.\n-  virtual bool function_set_body (tree function, tree code_stmt) = 0;\n-\n   // Look up a named built-in function in the current backend implementation.\n   // Returns NULL if no built-in function by that name exists.\n   virtual tree lookup_gcc_builtin (const std::string &) = 0;"}, {"sha": "812fd55c61afe4a0c621e1dc4c293f8712dd235b", "filename": "gcc/rust/rust-gcc.cc", "status": "modified", "additions": 61, "deletions": 136, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9023bb8687347559702340c24cd72301f0656a59/gcc%2Frust%2Frust-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9023bb8687347559702340c24cd72301f0656a59/gcc%2Frust%2Frust-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-gcc.cc?ref=9023bb8687347559702340c24cd72301f0656a59", "patch": "@@ -116,9 +116,6 @@ class Gcc_backend : public Backend\n   }\n \n   // Types.\n-  tree error_type () { return error_mark_node; }\n-\n-  tree void_type () { return void_type_node; }\n \n   tree unit_type ()\n   {\n@@ -192,21 +189,12 @@ class Gcc_backend : public Backend\n \n   tree zero_expression (tree);\n \n-  tree error_expression () { return error_mark_node; }\n-\n-  bool is_error_expression (tree expr) { return expr == error_mark_node; }\n-\n-  tree nil_pointer_expression () { return null_pointer_node; }\n-\n   tree unit_expression () { return integer_zero_node; }\n \n   tree var_expression (Bvariable *var, Location);\n \n   tree indirect_expression (tree, tree expr, bool known_valid, Location);\n \n-  tree named_constant_expression (tree type, const std::string &name, tree val,\n-\t\t\t\t  Location);\n-\n   tree integer_constant_expression (tree type, mpz_t val);\n \n   tree float_constant_expression (tree type, mpfr_t val);\n@@ -229,8 +217,6 @@ class Gcc_backend : public Backend\n \n   tree convert_expression (tree type, tree expr, Location);\n \n-  tree function_code_expression (tree, Location);\n-\n   tree struct_field_expression (tree, size_t, Location);\n \n   tree compound_expression (tree, tree, Location);\n@@ -263,8 +249,6 @@ class Gcc_backend : public Backend\n \n   // Statements.\n \n-  tree error_statement () { return error_mark_node; }\n-\n   tree expression_statement (tree, tree);\n \n   tree init_statement (tree, Bvariable *var, tree init);\n@@ -297,8 +281,6 @@ class Gcc_backend : public Backend\n \n   void block_add_statements (tree, const std::vector<tree> &);\n \n-  tree block_statement (tree);\n-\n   // Variables.\n \n   Bvariable *error_variable () { return new Bvariable (error_mark_node); }\n@@ -332,8 +314,6 @@ class Gcc_backend : public Backend\n \n   // Functions.\n \n-  tree error_function () { return error_mark_node; }\n-\n   tree function (tree fntype, const std::string &name,\n \t\t const std::string &asm_name, unsigned int flags, Location);\n \n@@ -343,8 +323,6 @@ class Gcc_backend : public Backend\n   bool function_set_parameters (tree function,\n \t\t\t\tconst std::vector<Bvariable *> &);\n \n-  bool function_set_body (tree function, tree code_stmt);\n-\n   tree lookup_gcc_builtin (const std::string &);\n \n   tree lookup_builtin_by_rust_name (const std::string &);\n@@ -717,7 +695,7 @@ tree\n Gcc_backend::pointer_type (tree to_type)\n {\n   if (to_type == error_mark_node)\n-    return this->error_type ();\n+    return error_mark_node;\n   tree type = build_pointer_type (to_type);\n   return type;\n }\n@@ -728,7 +706,7 @@ tree\n Gcc_backend::reference_type (tree to_type)\n {\n   if (to_type == error_mark_node)\n-    return this->error_type ();\n+    return error_mark_node;\n   tree type = build_reference_type (to_type);\n   return type;\n }\n@@ -739,7 +717,7 @@ tree\n Gcc_backend::immutable_type (tree base)\n {\n   if (base == error_mark_node)\n-    return this->error_type ();\n+    return error_mark_node;\n   tree constified = build_qualified_type (base, TYPE_QUAL_CONST);\n   return constified;\n }\n@@ -758,7 +736,7 @@ Gcc_backend::function_type (const typed_identifier &receiver,\n     {\n       tree t = receiver.type;\n       if (t == error_mark_node)\n-\treturn this->error_type ();\n+\treturn error_mark_node;\n       *pp = tree_cons (NULL_TREE, t, NULL_TREE);\n       pp = &TREE_CHAIN (*pp);\n     }\n@@ -768,7 +746,7 @@ Gcc_backend::function_type (const typed_identifier &receiver,\n     {\n       tree t = p->type;\n       if (t == error_mark_node)\n-\treturn this->error_type ();\n+\treturn error_mark_node;\n       *pp = tree_cons (NULL_TREE, t, NULL_TREE);\n       pp = &TREE_CHAIN (*pp);\n     }\n@@ -788,7 +766,7 @@ Gcc_backend::function_type (const typed_identifier &receiver,\n       result = result_struct;\n     }\n   if (result == error_mark_node)\n-    return this->error_type ();\n+    return error_mark_node;\n \n   // The libffi library cannot represent a zero-sized object.  To\n   // avoid causing confusion on 32-bit SPARC, we treat a function that\n@@ -800,7 +778,7 @@ Gcc_backend::function_type (const typed_identifier &receiver,\n \n   tree fntype = build_function_type (result, args);\n   if (fntype == error_mark_node)\n-    return this->error_type ();\n+    return error_mark_node;\n \n   return build_pointer_type (fntype);\n }\n@@ -819,7 +797,7 @@ Gcc_backend::function_type_varadic (\n     {\n       tree t = receiver.type;\n       if (t == error_mark_node)\n-\treturn this->error_type ();\n+\treturn error_mark_node;\n \n       args[offs++] = t;\n     }\n@@ -829,7 +807,7 @@ Gcc_backend::function_type_varadic (\n     {\n       tree t = p->type;\n       if (t == error_mark_node)\n-\treturn this->error_type ();\n+\treturn error_mark_node;\n       args[offs++] = t;\n     }\n \n@@ -844,7 +822,7 @@ Gcc_backend::function_type_varadic (\n       result = result_struct;\n     }\n   if (result == error_mark_node)\n-    return this->error_type ();\n+    return error_mark_node;\n \n   // The libffi library cannot represent a zero-sized object.  To\n   // avoid causing confusion on 32-bit SPARC, we treat a function that\n@@ -856,7 +834,7 @@ Gcc_backend::function_type_varadic (\n \n   tree fntype = build_varargs_function_type_array (result, n, args);\n   if (fntype == error_mark_node)\n-    return this->error_type ();\n+    return error_mark_node;\n \n   return build_pointer_type (fntype);\n }\n@@ -872,7 +850,7 @@ Gcc_backend::function_ptr_type (tree result_type,\n   for (auto &param : parameters)\n     {\n       if (param == error_mark_node)\n-\treturn this->error_type ();\n+\treturn error_mark_node;\n \n       *pp = tree_cons (NULL_TREE, param, NULL_TREE);\n       pp = &TREE_CHAIN (*pp);\n@@ -886,7 +864,7 @@ Gcc_backend::function_ptr_type (tree result_type,\n \n   tree fntype = build_function_type (result, args);\n   if (fntype == error_mark_node)\n-    return this->error_type ();\n+    return error_mark_node;\n \n   return build_pointer_type (fntype);\n }\n@@ -921,7 +899,7 @@ Gcc_backend::fill_in_fields (tree fill,\n       tree name_tree = get_identifier_from_string (p->name);\n       tree type_tree = p->type;\n       if (type_tree == error_mark_node)\n-\treturn this->error_type ();\n+\treturn error_mark_node;\n       tree field = build_decl (p->location.gcc_location (), FIELD_DECL,\n \t\t\t       name_tree, type_tree);\n       DECL_CONTEXT (field) = fill;\n@@ -954,7 +932,7 @@ tree\n Gcc_backend::fill_in_array (tree fill, tree element_type, tree length_tree)\n {\n   if (element_type == error_mark_node || length_tree == error_mark_node)\n-    return this->error_type ();\n+    return error_mark_node;\n \n   gcc_assert (TYPE_SIZE (element_type) != NULL_TREE);\n \n@@ -986,7 +964,7 @@ tree\n Gcc_backend::named_type (const std::string &name, tree type, Location location)\n {\n   if (type == error_mark_node)\n-    return this->error_type ();\n+    return error_mark_node;\n \n   // The middle-end expects a basic type to have a name.  In Rust every\n   // basic type will have a name.  The first time we see a basic type,\n@@ -1089,7 +1067,7 @@ Gcc_backend::var_expression (Bvariable *var, Location location)\n {\n   tree ret = var->get_tree (location);\n   if (ret == error_mark_node)\n-    return this->error_expression ();\n+    return error_mark_node;\n   return ret;\n }\n \n@@ -1100,7 +1078,7 @@ Gcc_backend::indirect_expression (tree type_tree, tree expr_tree,\n \t\t\t\t  bool known_valid, Location location)\n {\n   if (expr_tree == error_mark_node || type_tree == error_mark_node)\n-    return this->error_expression ();\n+    return error_mark_node;\n \n   // If the type of EXPR is a recursive pointer type, then we\n   // need to insert a cast before indirecting.\n@@ -1115,34 +1093,13 @@ Gcc_backend::indirect_expression (tree type_tree, tree expr_tree,\n   return ret;\n }\n \n-// Return an expression that declares a constant named NAME with the\n-// constant value VAL in BTYPE.\n-\n-tree\n-Gcc_backend::named_constant_expression (tree type_tree, const std::string &name,\n-\t\t\t\t\ttree const_val, Location location)\n-{\n-  if (type_tree == error_mark_node || const_val == error_mark_node)\n-    return this->error_expression ();\n-\n-  tree name_tree = get_identifier_from_string (name);\n-  tree decl\n-    = build_decl (location.gcc_location (), CONST_DECL, name_tree, type_tree);\n-  DECL_INITIAL (decl) = const_val;\n-  TREE_CONSTANT (decl) = 1;\n-  TREE_READONLY (decl) = 1;\n-\n-  rust_preserve_from_gc (decl);\n-  return decl;\n-}\n-\n // Return a typed value as a constant integer.\n \n tree\n Gcc_backend::integer_constant_expression (tree t, mpz_t val)\n {\n   if (t == error_mark_node)\n-    return this->error_expression ();\n+    return error_mark_node;\n \n   tree ret = double_int_to_tree (t, mpz_get_double_int (t, val, true));\n   return ret;\n@@ -1155,7 +1112,7 @@ Gcc_backend::float_constant_expression (tree t, mpfr_t val)\n {\n   tree ret;\n   if (t == error_mark_node)\n-    return this->error_expression ();\n+    return error_mark_node;\n \n   REAL_VALUE_TYPE r1;\n   real_from_mpfr (&r1, val, t, GMP_RNDN);\n@@ -1172,7 +1129,7 @@ Gcc_backend::complex_constant_expression (tree t, mpc_t val)\n {\n   tree ret;\n   if (t == error_mark_node)\n-    return this->error_expression ();\n+    return error_mark_node;\n \n   REAL_VALUE_TYPE r1;\n   real_from_mpfr (&r1, mpc_realref (val), TREE_TYPE (t), GMP_RNDN);\n@@ -1230,7 +1187,7 @@ tree\n Gcc_backend::real_part_expression (tree complex_tree, Location location)\n {\n   if (complex_tree == error_mark_node)\n-    return this->error_expression ();\n+    return error_mark_node;\n   gcc_assert (COMPLEX_FLOAT_TYPE_P (TREE_TYPE (complex_tree)));\n   tree ret\n     = fold_build1_loc (location.gcc_location (), REALPART_EXPR,\n@@ -1244,7 +1201,7 @@ tree\n Gcc_backend::imag_part_expression (tree complex_tree, Location location)\n {\n   if (complex_tree == error_mark_node)\n-    return this->error_expression ();\n+    return error_mark_node;\n   gcc_assert (COMPLEX_FLOAT_TYPE_P (TREE_TYPE (complex_tree)));\n   tree ret\n     = fold_build1_loc (location.gcc_location (), IMAGPART_EXPR,\n@@ -1259,7 +1216,7 @@ Gcc_backend::complex_expression (tree real_tree, tree imag_tree,\n \t\t\t\t Location location)\n {\n   if (real_tree == error_mark_node || imag_tree == error_mark_node)\n-    return this->error_expression ();\n+    return error_mark_node;\n   gcc_assert (TYPE_MAIN_VARIANT (TREE_TYPE (real_tree))\n \t      == TYPE_MAIN_VARIANT (TREE_TYPE (imag_tree)));\n   gcc_assert (SCALAR_FLOAT_TYPE_P (TREE_TYPE (real_tree)));\n@@ -1277,7 +1234,7 @@ Gcc_backend::convert_expression (tree type_tree, tree expr_tree,\n {\n   if (type_tree == error_mark_node || expr_tree == error_mark_node\n       || TREE_TYPE (expr_tree) == error_mark_node)\n-    return this->error_expression ();\n+    return error_mark_node;\n \n   tree ret;\n   if (this->type_size (type_tree) == 0\n@@ -1305,18 +1262,6 @@ Gcc_backend::convert_expression (tree type_tree, tree expr_tree,\n   return ret;\n }\n \n-// Get the address of a function.\n-\n-tree\n-Gcc_backend::function_code_expression (tree func, Location location)\n-{\n-  if (func == error_mark_node)\n-    return this->error_expression ();\n-\n-  tree ret = build_fold_addr_expr_loc (location.gcc_location (), func);\n-  return ret;\n-}\n-\n // Return an expression for the field at INDEX in BSTRUCT.\n \n tree\n@@ -1325,23 +1270,23 @@ Gcc_backend::struct_field_expression (tree struct_tree, size_t index,\n {\n   if (struct_tree == error_mark_node\n       || TREE_TYPE (struct_tree) == error_mark_node)\n-    return this->error_expression ();\n+    return error_mark_node;\n   gcc_assert (TREE_CODE (TREE_TYPE (struct_tree)) == RECORD_TYPE\n \t      || TREE_CODE (TREE_TYPE (struct_tree)) == UNION_TYPE);\n   tree field = TYPE_FIELDS (TREE_TYPE (struct_tree));\n   if (field == NULL_TREE)\n     {\n       // This can happen for a type which refers to itself indirectly\n       // and then turns out to be erroneous.\n-      return this->error_expression ();\n+      return error_mark_node;\n     }\n   for (unsigned int i = index; i > 0; --i)\n     {\n       field = DECL_CHAIN (field);\n       gcc_assert (field != NULL_TREE);\n     }\n   if (TREE_TYPE (field) == error_mark_node)\n-    return this->error_expression ();\n+    return error_mark_node;\n   tree ret = fold_build3_loc (location.gcc_location (), COMPONENT_REF,\n \t\t\t      TREE_TYPE (field), struct_tree, field, NULL_TREE);\n   if (TREE_CONSTANT (struct_tree))\n@@ -1355,7 +1300,7 @@ tree\n Gcc_backend::compound_expression (tree stat, tree expr, Location location)\n {\n   if (stat == error_mark_node || expr == error_mark_node)\n-    return this->error_expression ();\n+    return error_mark_node;\n   tree ret = fold_build2_loc (location.gcc_location (), COMPOUND_EXPR,\n \t\t\t      TREE_TYPE (expr), stat, expr);\n   return ret;\n@@ -1371,7 +1316,7 @@ Gcc_backend::conditional_expression (tree, tree type_tree, tree cond_expr,\n {\n   if (type_tree == error_mark_node || cond_expr == error_mark_node\n       || then_expr == error_mark_node || else_expr == error_mark_node)\n-    return this->error_expression ();\n+    return error_mark_node;\n   tree ret = build3_loc (location.gcc_location (), COND_EXPR, type_tree,\n \t\t\t cond_expr, then_expr, else_expr);\n   return ret;\n@@ -1483,7 +1428,7 @@ Gcc_backend::negation_expression (NegationOperator op, tree expr_tree,\n   /* Check if the expression is an error, in which case we return an error\n      expression. */\n   if (expr_tree == error_mark_node || TREE_TYPE (expr_tree) == error_mark_node)\n-    return this->error_expression ();\n+    return error_mark_node;\n \n   /* For negation operators, the resulting type should be the same as its\n      operand. */\n@@ -1522,7 +1467,7 @@ Gcc_backend::arithmetic_or_logical_expression (ArithmeticOrLogicalOperator op,\n   /* Check if either expression is an error, in which case we return an error\n      expression. */\n   if (left_tree == error_mark_node || right_tree == error_mark_node)\n-    return this->error_expression ();\n+    return error_mark_node;\n \n   /* We need to determine if we're doing floating point arithmetics of integer\n      arithmetics. */\n@@ -1567,7 +1512,7 @@ Gcc_backend::comparison_expression (ComparisonOperator op, tree left_tree,\n   /* Check if either expression is an error, in which case we return an error\n      expression. */\n   if (left_tree == error_mark_node || right_tree == error_mark_node)\n-    return this->error_expression ();\n+    return error_mark_node;\n \n   /* For comparison operators, the resulting type should be boolean. */\n   auto tree_type = boolean_type_node;\n@@ -1587,7 +1532,7 @@ Gcc_backend::lazy_boolean_expression (LazyBooleanOperator op, tree left_tree,\n   /* Check if either expression is an error, in which case we return an error\n      expression. */\n   if (left_tree == error_mark_node || right_tree == error_mark_node)\n-    return this->error_expression ();\n+    return error_mark_node;\n \n   /* For lazy boolean operators, the resulting type should be the same as the\n      rhs operand. */\n@@ -1608,7 +1553,7 @@ Gcc_backend::constructor_expression (tree type_tree, bool is_variant,\n \t\t\t\t     int union_index, Location location)\n {\n   if (type_tree == error_mark_node)\n-    return this->error_expression ();\n+    return error_mark_node;\n \n   vec<constructor_elt, va_gc> *init;\n   vec_alloc (init, vals.size ());\n@@ -1652,7 +1597,7 @@ Gcc_backend::constructor_expression (tree type_tree, bool is_variant,\n \t    }\n \t  if (TREE_TYPE (field) == error_mark_node || val == error_mark_node\n \t      || TREE_TYPE (val) == error_mark_node)\n-\t    return this->error_expression ();\n+\t    return error_mark_node;\n \n \t  if (int_size_in_bytes (TREE_TYPE (field)) == 0)\n \t    {\n@@ -1684,7 +1629,7 @@ Gcc_backend::constructor_expression (tree type_tree, bool is_variant,\n \t      tree val = (*p);\n \t      if (TREE_TYPE (field) == error_mark_node || val == error_mark_node\n \t\t  || TREE_TYPE (val) == error_mark_node)\n-\t\treturn this->error_expression ();\n+\t\treturn error_mark_node;\n \n \t      if (int_size_in_bytes (TREE_TYPE (field)) == 0)\n \t\t{\n@@ -1724,7 +1669,7 @@ Gcc_backend::array_constructor_expression (\n   const std::vector<tree> &vals, Location location)\n {\n   if (type_tree == error_mark_node)\n-    return this->error_expression ();\n+    return error_mark_node;\n \n   gcc_assert (indexes.size () == vals.size ());\n \n@@ -1741,7 +1686,7 @@ Gcc_backend::array_constructor_expression (\n       tree val = vals[i];\n \n       if (index == error_mark_node || val == error_mark_node)\n-\treturn this->error_expression ();\n+\treturn error_mark_node;\n \n       if (element_size == 0)\n \t{\n@@ -1780,7 +1725,7 @@ Gcc_backend::pointer_offset_expression (tree base_tree, tree index_tree,\n   tree element_type_tree = TREE_TYPE (TREE_TYPE (base_tree));\n   if (base_tree == error_mark_node || TREE_TYPE (base_tree) == error_mark_node\n       || index_tree == error_mark_node || element_type_tree == error_mark_node)\n-    return this->error_expression ();\n+    return error_mark_node;\n \n   tree element_size = TYPE_SIZE_UNIT (element_type_tree);\n   index_tree\n@@ -1800,7 +1745,7 @@ Gcc_backend::array_index_expression (tree array_tree, tree index_tree,\n {\n   if (array_tree == error_mark_node || TREE_TYPE (array_tree) == error_mark_node\n       || index_tree == error_mark_node)\n-    return this->error_expression ();\n+    return error_mark_node;\n \n   // A function call that returns a zero sized object will have been\n   // changed to return void.  If we see void here, assume we are\n@@ -1824,7 +1769,7 @@ Gcc_backend::call_expression (tree, // containing fcn for call\n \t\t\t      tree chain_expr, Location location)\n {\n   if (fn == error_mark_node || TREE_TYPE (fn) == error_mark_node)\n-    return this->error_expression ();\n+    return error_mark_node;\n \n   gcc_assert (FUNCTION_POINTER_TYPE_P (TREE_TYPE (fn)));\n   tree rettype = TREE_TYPE (TREE_TYPE (TREE_TYPE (fn)));\n@@ -1835,7 +1780,7 @@ Gcc_backend::call_expression (tree, // containing fcn for call\n     {\n       args[i] = fn_args.at (i);\n       if (args[i] == error_mark_node)\n-\treturn this->error_expression ();\n+\treturn error_mark_node;\n     }\n \n   tree fndecl = fn;\n@@ -1907,7 +1852,7 @@ Gcc_backend::init_statement (tree, Bvariable *var, tree init_tree)\n {\n   tree var_tree = var->get_decl ();\n   if (var_tree == error_mark_node || init_tree == error_mark_node)\n-    return this->error_statement ();\n+    return error_mark_node;\n   gcc_assert (TREE_CODE (var_tree) == VAR_DECL);\n \n   // To avoid problems with GNU ld, we don't make zero-sized\n@@ -1939,7 +1884,7 @@ Gcc_backend::assignment_statement (tree bfn, tree lhs, tree rhs,\n \t\t\t\t   Location location)\n {\n   if (lhs == error_mark_node || rhs == error_mark_node)\n-    return this->error_statement ();\n+    return error_mark_node;\n \n   // To avoid problems with GNU ld, we don't make zero-sized\n   // externally visible variables.  That might lead us to doing an\n@@ -1967,10 +1912,10 @@ Gcc_backend::return_statement (tree fntree, const std::vector<tree> &vals,\n \t\t\t       Location location)\n {\n   if (fntree == error_mark_node)\n-    return this->error_statement ();\n+    return error_mark_node;\n   tree result = DECL_RESULT (fntree);\n   if (result == error_mark_node)\n-    return this->error_statement ();\n+    return error_mark_node;\n \n   // If the result size is zero bytes, we have set the function type\n   // to have a result type of void, so don't return anything.\n@@ -1984,7 +1929,7 @@ Gcc_backend::return_statement (tree fntree, const std::vector<tree> &vals,\n \t{\n \t  tree val = (*p);\n \t  if (val == error_mark_node)\n-\t    return this->error_statement ();\n+\t    return error_mark_node;\n \t  append_to_statement_list (val, &stmt_list);\n \t}\n       tree ret = fold_build1_loc (location.gcc_location (), RETURN_EXPR,\n@@ -2001,7 +1946,7 @@ Gcc_backend::return_statement (tree fntree, const std::vector<tree> &vals,\n     {\n       tree val = vals.front ();\n       if (val == error_mark_node)\n-\treturn this->error_statement ();\n+\treturn error_mark_node;\n       tree set = fold_build2_loc (location.gcc_location (), MODIFY_EXPR,\n \t\t\t\t  void_type_node, result, vals.front ());\n       ret = fold_build1_loc (location.gcc_location (), RETURN_EXPR,\n@@ -2033,7 +1978,7 @@ Gcc_backend::return_statement (tree fntree, const std::vector<tree> &vals,\n \t\t\t       TREE_TYPE (field), rettmp, field, NULL_TREE);\n \t  tree val = (*p);\n \t  if (val == error_mark_node)\n-\t    return this->error_statement ();\n+\t    return error_mark_node;\n \t  tree set = fold_build2_loc (location.gcc_location (), MODIFY_EXPR,\n \t\t\t\t      void_type_node, ref, (*p));\n \t  append_to_statement_list (set, &stmt_list);\n@@ -2061,7 +2006,7 @@ Gcc_backend::exception_handler_statement (tree try_stmt, tree except_stmt,\n {\n   if (try_stmt == error_mark_node || except_stmt == error_mark_node\n       || finally_stmt == error_mark_node)\n-    return this->error_statement ();\n+    return error_mark_node;\n \n   if (except_stmt != NULL_TREE)\n     try_stmt = build2_loc (location.gcc_location (), TRY_CATCH_EXPR,\n@@ -2082,7 +2027,7 @@ Gcc_backend::if_statement (tree, tree cond_tree, tree then_tree, tree else_tree,\n {\n   if (cond_tree == error_mark_node || then_tree == error_mark_node\n       || else_tree == error_mark_node)\n-    return this->error_statement ();\n+    return error_mark_node;\n   tree ret = build3_loc (location.gcc_location (), COND_EXPR, void_type_node,\n \t\t\t cond_tree, then_tree, else_tree);\n   return ret;\n@@ -2139,7 +2084,7 @@ Gcc_backend::switch_statement (tree decl, tree value,\n \t    {\n \t      tree t = (*pcv);\n \t      if (t == error_mark_node)\n-\t\treturn this->error_statement ();\n+\t\treturn error_mark_node;\n \t      location_t loc = EXPR_LOCATION (t);\n \t      tree label = create_artificial_label (loc);\n \t      tree c = build_case_label ((*pcv), NULL_TREE, label);\n@@ -2151,15 +2096,15 @@ Gcc_backend::switch_statement (tree decl, tree value,\n \t{\n \t  tree t = (*ps);\n \t  if (t == error_mark_node)\n-\t    return this->error_statement ();\n+\t    return error_mark_node;\n \t  append_to_statement_list (t, &stmt_list);\n \t}\n     }\n   pop_cfun ();\n \n   tree tv = value;\n   if (tv == error_mark_node)\n-    return this->error_statement ();\n+    return error_mark_node;\n   tree t = build2_loc (switch_location.gcc_location (), SWITCH_EXPR, NULL_TREE,\n \t\t       tv, stmt_list);\n   return t;\n@@ -2173,11 +2118,11 @@ Gcc_backend::compound_statement (tree s1, tree s2)\n   tree stmt_list = NULL_TREE;\n   tree t = s1;\n   if (t == error_mark_node)\n-    return this->error_statement ();\n+    return error_mark_node;\n   append_to_statement_list (t, &stmt_list);\n   t = s2;\n   if (t == error_mark_node)\n-    return this->error_statement ();\n+    return error_mark_node;\n   append_to_statement_list (t, &stmt_list);\n \n   // If neither statement has any side effects, stmt_list can be NULL\n@@ -2199,7 +2144,7 @@ Gcc_backend::statement_list (const std::vector<tree> &statements)\n     {\n       tree t = (*p);\n       if (t == error_mark_node)\n-\treturn this->error_statement ();\n+\treturn error_mark_node;\n       append_to_statement_list (t, &stmt_list);\n     }\n   return stmt_list;\n@@ -2289,15 +2234,6 @@ Gcc_backend::block_add_statements (tree bind_tree,\n   BIND_EXPR_BODY (bind_tree) = stmt_list;\n }\n \n-// Return a block as a statement.\n-\n-tree\n-Gcc_backend::block_statement (tree bind_tree)\n-{\n-  gcc_assert (TREE_CODE (bind_tree) == BIND_EXPR);\n-  return bind_tree;\n-}\n-\n // This is not static because we declare it with GTY(()) in rust-c.h.\n tree rust_non_zero_struct;\n \n@@ -2541,7 +2477,7 @@ Gcc_backend::temporary_variable (tree fndecl, tree bind_tree, tree type_tree,\n   if (type_tree == error_mark_node || init_tree == error_mark_node\n       || fndecl == error_mark_node)\n     {\n-      *pstatement = this->error_statement ();\n+      *pstatement = error_mark_node;\n       return this->error_variable ();\n     }\n \n@@ -2670,7 +2606,7 @@ Gcc_backend::function (tree functype, const std::string &name,\n     }\n   tree id = get_identifier_from_string (name);\n   if (functype == error_mark_node || id == error_mark_node)\n-    return this->error_function ();\n+    return error_mark_node;\n \n   tree decl\n     = build_decl (location.gcc_location (), FUNCTION_DECL, id, functype);\n@@ -2711,7 +2647,7 @@ Gcc_backend::function_defer_statement (tree function, tree undefer_tree,\n {\n   if (undefer_tree == error_mark_node || defer_tree == error_mark_node\n       || function == error_mark_node)\n-    return this->error_statement ();\n+    return error_mark_node;\n \n   if (DECL_STRUCT_FUNCTION (function) == NULL)\n     push_struct_function (function);\n@@ -2759,17 +2695,6 @@ Gcc_backend::function_set_parameters (\n   return true;\n }\n \n-// Set the function body for FUNCTION using the code in CODE_BLOCK.\n-\n-bool\n-Gcc_backend::function_set_body (tree function, tree code_stmt)\n-{\n-  if (function == error_mark_node || code_stmt == error_mark_node)\n-    return false;\n-  DECL_SAVED_TREE (function) = code_stmt;\n-  return true;\n-}\n-\n // Look up a named built-in function in the current backend implementation.\n // Returns NULL if no built-in function by that name exists.\n "}, {"sha": "5529fbf6931c3eb168a798784ae9259e9ab18c1b", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 7, "deletions": 24, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9023bb8687347559702340c24cd72301f0656a59/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9023bb8687347559702340c24cd72301f0656a59/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=9023bb8687347559702340c24cd72301f0656a59", "patch": "@@ -17,32 +17,8 @@\n // <http://www.gnu.org/licenses/>.\n // #include \"rust-session-manager.h\"\n \n-#include <fstream>\n-#include <sstream>\n #include \"rust-session-manager.h\"\n #include \"rust-diagnostics.h\"\n-#include \"diagnostic.h\"\n-#include \"input.h\"\n-\n-#include \"target.h\"\n-#include \"tm.h\"\n-#include \"memmodel.h\"\n-#include \"tm_p.h\"\n-\n-//#include \"rust-target.h\"\n-/*TODO This isn't (currently?) necessary, but if '#include'd after '#include\n-   \"target.h\"', causes: In file included from\n-   [...]/gcc/rust/rust-session-manager.cc:31:\n-    [...]/gcc/rust/rust-target.h:23: error: \"DEFHOOK\" redefined [-Werror]\n-       23 | #define DEFHOOK(NAME, DOC, TYPE, PARAMS, INIT) TYPE (*NAME) PARAMS;\n-\t  |\n-    In file included from [...]/gcc/rust/rust-session-manager.cc:27:\n-    [...]/gcc/target.h:272: note: this is the location of the previous\n-   definition 272 | #define DEFHOOK(NAME, DOC, TYPE, PARAMS, INIT) TYPE (* NAME)\n-   PARAMS;\n-\t  |\n-*/\n-\n #include \"rust-lex.h\"\n #include \"rust-parse.h\"\n #include \"rust-macro-expand.h\"\n@@ -54,6 +30,13 @@\n #include \"rust-ast-resolve-unused.h\"\n #include \"rust-compile.h\"\n \n+#include \"diagnostic.h\"\n+#include \"input.h\"\n+#include \"rust-target.h\"\n+\n+extern bool\n+saw_errors (void);\n+\n extern Linemap *\n rust_get_linemap ();\n "}, {"sha": "743ac518ebb5dca04ef4e3597284cd0c4d67cc29", "filename": "gcc/rust/rust-target.h", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9023bb8687347559702340c24cd72301f0656a59/gcc%2Frust%2Frust-target.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9023bb8687347559702340c24cd72301f0656a59/gcc%2Frust%2Frust-target.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-target.h?ref=9023bb8687347559702340c24cd72301f0656a59", "patch": "@@ -18,9 +18,14 @@\n #ifndef GCC_RUST_TARGET_H\n #define GCC_RUST_TARGET_H\n \n+#include \"target.h\"\n+#include \"tm.h\"\n+#include \"memmodel.h\"\n+#include \"tm_p.h\"\n+\n // TODO: find out what this stuff actually does\n #define DEFHOOKPOD(NAME, DOC, TYPE, INIT) TYPE NAME;\n-#define DEFHOOK(NAME, DOC, TYPE, PARAMS, INIT) TYPE (*NAME) PARAMS;\n+// #define DEFHOOK(NAME, DOC, TYPE, PARAMS, INIT) TYPE (*NAME) PARAMS;\n #define DEFHOOK_UNDOC DEFHOOK\n #define HOOKSTRUCT(FRAGMENT) FRAGMENT\n \n@@ -39,4 +44,4 @@ extern struct gcc_targetrustm targetrustm;\n extern void\n rust_add_target_info (const char *key, const char *value);\n \n-#endif\n\\ No newline at end of file\n+#endif"}, {"sha": "0bcc6c81064ea61faf019920cccd5467b0dfe6ba", "filename": "gcc/rust/typecheck/rust-tycheck-dump.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9023bb8687347559702340c24cd72301f0656a59/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9023bb8687347559702340c24cd72301f0656a59/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h?ref=9023bb8687347559702340c24cd72301f0656a59", "patch": "@@ -22,6 +22,9 @@\n #include \"rust-hir-type-check-base.h\"\n #include \"rust-hir-full.h\"\n \n+#include <fstream>\n+#include <sstream>\n+\n namespace Rust {\n namespace Resolver {\n "}]}