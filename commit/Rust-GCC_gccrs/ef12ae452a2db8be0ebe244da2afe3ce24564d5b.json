{"sha": "ef12ae452a2db8be0ebe244da2afe3ce24564d5b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWYxMmFlNDUyYTJkYjhiZTBlYmUyNDRkYTJhZmUzY2UyNDU2NGQ1Yg==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2009-06-30T07:59:01Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2009-06-30T07:59:01Z"}, "message": "re PR bootstrap/40597 (Powerpc bootstrap is broken due to changes in expmed.c)\n\n2009-06-30  Paolo Bonzini  <bonzini@gnu.org>\n\n\tPR boostrap/40597\n\t* expmed.c (emit_cstore): New name of emit_store_flag_1.\n\t(emit_store_flag_1): Extract from emit_store_flag, adjust\n\tcalls to (what now is) emit_cstore.\n\t(emit_store_flag): Call emit_store_flag_1 and also use it\n\tfor what used to be recursive calls.\n\nFrom-SVN: r149083", "tree": {"sha": "afc07285be9adf6c85faafebefaa8a02e707dd6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/afc07285be9adf6c85faafebefaa8a02e707dd6a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef12ae452a2db8be0ebe244da2afe3ce24564d5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef12ae452a2db8be0ebe244da2afe3ce24564d5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef12ae452a2db8be0ebe244da2afe3ce24564d5b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef12ae452a2db8be0ebe244da2afe3ce24564d5b/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "791b59e35bd36fce29aea0f0f16ec65b1c6ace14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/791b59e35bd36fce29aea0f0f16ec65b1c6ace14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/791b59e35bd36fce29aea0f0f16ec65b1c6ace14"}], "stats": {"total": 106, "additions": 67, "deletions": 39}, "files": [{"sha": "fe12202f69cb6afc42bc70f51f331b5cc02a3b22", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef12ae452a2db8be0ebe244da2afe3ce24564d5b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef12ae452a2db8be0ebe244da2afe3ce24564d5b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ef12ae452a2db8be0ebe244da2afe3ce24564d5b", "patch": "@@ -1,3 +1,12 @@\n+2009-06-30  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\tPR boostrap/40597\n+\t* expmed.c (emit_cstore): New name of emit_store_flag_1.\n+\t(emit_store_flag_1): Extract from emit_store_flag, adjust\n+\tcalls to (what now is) emit_cstore.\n+\t(emit_store_flag): Call emit_store_flag_1 and also use it\n+\tfor what used to be recursive calls.\n+\n 2009-06-30  Wei Guozhi  <carrot@google.com>\n \n \tPR/40416"}, {"sha": "b10ad1baea8123958742e6eef88250be30838339", "filename": "gcc/expmed.c", "status": "modified", "additions": 58, "deletions": 39, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef12ae452a2db8be0ebe244da2afe3ce24564d5b/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef12ae452a2db8be0ebe244da2afe3ce24564d5b/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=ef12ae452a2db8be0ebe244da2afe3ce24564d5b", "patch": "@@ -5115,9 +5115,9 @@ expand_and (enum machine_mode mode, rtx op0, rtx op1, rtx target)\n \n /* Helper function for emit_store_flag.  */\n static rtx\n-emit_store_flag_1 (rtx target, enum insn_code icode, enum rtx_code code,\n-\t\t   enum machine_mode mode, enum machine_mode compare_mode,\n-\t\t   int unsignedp, rtx x, rtx y, int normalizep)\n+emit_cstore (rtx target, enum insn_code icode, enum rtx_code code,\n+\t     enum machine_mode mode, enum machine_mode compare_mode,\n+\t     int unsignedp, rtx x, rtx y, int normalizep)\n {\n   rtx op0, last, comparison, subtarget, pattern;\n   enum machine_mode target_mode;\n@@ -5217,34 +5217,22 @@ emit_store_flag_1 (rtx target, enum insn_code icode, enum rtx_code code,\n     return op0;\n }\n \n-/* Emit a store-flags instruction for comparison CODE on OP0 and OP1\n-   and storing in TARGET.  Normally return TARGET.\n-   Return 0 if that cannot be done.\n \n-   MODE is the mode to use for OP0 and OP1 should they be CONST_INTs.  If\n-   it is VOIDmode, they cannot both be CONST_INT.\n-\n-   UNSIGNEDP is for the case where we have to widen the operands\n-   to perform the operation.  It says to use zero-extension.\n-\n-   NORMALIZEP is 1 if we should convert the result to be either zero\n-   or one.  Normalize is -1 if we should convert the result to be\n-   either zero or -1.  If NORMALIZEP is zero, the result will be left\n-   \"raw\" out of the scc insn.  */\n+/* A subroutine of emit_store_flag only including \"tricks\" that do not\n+   need a recursive call.  These are kept separate to avoid infinite\n+   loops.  */\n \n-rtx\n-emit_store_flag (rtx target, enum rtx_code code, rtx op0, rtx op1,\n-\t\t enum machine_mode mode, int unsignedp, int normalizep)\n+static rtx\n+emit_store_flag_1 (rtx target, enum rtx_code code, rtx op0, rtx op1,\n+\t\t   enum machine_mode mode, int unsignedp, int normalizep)\n {\n   rtx subtarget;\n   enum insn_code icode;\n   enum machine_mode compare_mode;\n   enum machine_mode target_mode = target ? GET_MODE (target) : VOIDmode;\n   enum mode_class mclass;\n-  enum rtx_code rcode;\n   enum rtx_code scode;\n-  rtx tem, trueval;\n-  rtx last;\n+  rtx tem;\n \n   if (unsignedp)\n     code = unsigned_condition (code);\n@@ -5390,23 +5378,52 @@ emit_store_flag (rtx target, enum rtx_code code, rtx op0, rtx op1,\n      if (icode != CODE_FOR_nothing)\n \t{\n \t  do_pending_stack_adjust ();\n-\t  tem = emit_store_flag_1 (target, icode, code, mode, compare_mode,\n-\t\t\t\t   unsignedp, op0, op1, normalizep);\n+\t  tem = emit_cstore (target, icode, code, mode, compare_mode,\n+\t\t\t     unsignedp, op0, op1, normalizep);\n \t  if (tem)\n \t    return tem;\n \n \t  if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n \t    {\n-\t      tem = emit_store_flag_1 (target, icode, scode, mode, compare_mode,\n-\t\t\t\t       unsignedp, op1, op0, normalizep);\n+\t      tem = emit_cstore (target, icode, scode, mode, compare_mode,\n+\t\t\t\t unsignedp, op1, op0, normalizep);\n \t      if (tem)\n \t        return tem;\n \t    }\n \t  break;\n \t}\n     }\n \n-  last = get_last_insn ();\n+  return 0;\n+}\n+\n+/* Emit a store-flags instruction for comparison CODE on OP0 and OP1\n+   and storing in TARGET.  Normally return TARGET.\n+   Return 0 if that cannot be done.\n+\n+   MODE is the mode to use for OP0 and OP1 should they be CONST_INTs.  If\n+   it is VOIDmode, they cannot both be CONST_INT.\n+\n+   UNSIGNEDP is for the case where we have to widen the operands\n+   to perform the operation.  It says to use zero-extension.\n+\n+   NORMALIZEP is 1 if we should convert the result to be either zero\n+   or one.  Normalize is -1 if we should convert the result to be\n+   either zero or -1.  If NORMALIZEP is zero, the result will be left\n+   \"raw\" out of the scc insn.  */\n+\n+rtx\n+emit_store_flag (rtx target, enum rtx_code code, rtx op0, rtx op1,\n+\t\t enum machine_mode mode, int unsignedp, int normalizep)\n+{\n+  enum machine_mode target_mode = target ? GET_MODE (target) : VOIDmode;\n+  enum rtx_code rcode;\n+  rtx subtarget;\n+  rtx tem, last, trueval;\n+\n+  tem = emit_store_flag_1 (target, code, op0, op1, mode, unsignedp, normalizep);\n+  if (tem)\n+    return tem;\n \n   /* If we reached here, we can't do this with a scc insn, however there\n      are some comparisons that can be done in other ways.  Don't do any\n@@ -5430,6 +5447,8 @@ emit_store_flag (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \treturn 0;\n     }\n \n+  last = get_last_insn ();\n+\n   /* If optimizing, use different pseudo registers for each insn, instead\n      of reusing the same pseudo.  This leads to better CSE, but slows\n      down the compiler, since there are more pseudos */\n@@ -5454,17 +5473,17 @@ emit_store_flag (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \t  if ((STORE_FLAG_VALUE == 1 && normalizep == -1)\n \t      || (STORE_FLAG_VALUE == -1 && normalizep == 1))\n \t    {\n-\t      tem = emit_store_flag (subtarget, rcode, op0, op1, mode, 0,\n-\t\t\t\t     STORE_FLAG_VALUE);\n+\t      tem = emit_store_flag_1 (subtarget, rcode, op0, op1, mode, 0,\n+\t\t\t\t       STORE_FLAG_VALUE);\n \t      if (tem)\n                 return expand_binop (target_mode, add_optab, tem,\n \t\t\t\t     GEN_INT (normalizep),\n \t\t\t\t     target, 0, OPTAB_WIDEN);\n \t    }\n \t  else\n \t    {\n-\t      tem = emit_store_flag (subtarget, rcode, op0, op1, mode, 0,\n-\t\t\t\t     normalizep);\n+\t      tem = emit_store_flag_1 (subtarget, rcode, op0, op1, mode, 0,\n+\t\t\t\t       normalizep);\n \t      if (tem)\n                 return expand_binop (target_mode, xor_optab, tem, trueval,\n \t\t\t\t     target, INTVAL (trueval) >= 0, OPTAB_WIDEN);\n@@ -5484,13 +5503,13 @@ emit_store_flag (rtx target, enum rtx_code code, rtx op0, rtx op1,\n       if (!HONOR_NANS (mode))\n \t{\n           gcc_assert (first_code == (and_them ? ORDERED : UNORDERED));\n-\t  return emit_store_flag (target, code, op0, op1, mode, 0, normalizep);\n+\t  return emit_store_flag_1 (target, code, op0, op1, mode, 0, normalizep);\n \t}\n \n #ifdef HAVE_conditional_move\n       /* Try using a setcc instruction for ORDERED/UNORDERED, followed by a\n \t conditional move.  */\n-      tem = emit_store_flag (subtarget, first_code, op0, op1, mode, 0, normalizep);\n+      tem = emit_store_flag_1 (subtarget, first_code, op0, op1, mode, 0, normalizep);\n       if (tem == 0)\n \treturn 0;\n \n@@ -5528,8 +5547,8 @@ emit_store_flag (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \ttem = expand_binop (mode, sub_optab, op0, op1, subtarget, 1,\n \t\t\t    OPTAB_WIDEN);\n       if (tem != 0)\n-\ttem = emit_store_flag (target, code, tem, const0_rtx,\n-\t\t\t       mode, unsignedp, normalizep);\n+\ttem = emit_store_flag_1 (target, code, tem, const0_rtx,\n+\t\t\t         mode, unsignedp, normalizep);\n       if (tem != 0)\n \treturn tem;\n \n@@ -5550,16 +5569,16 @@ emit_store_flag (rtx target, enum rtx_code code, rtx op0, rtx op1,\n       if ((STORE_FLAG_VALUE == 1 && normalizep == -1)\n \t  || (STORE_FLAG_VALUE == -1 && normalizep == 1))\n \t{\n-\t  tem = emit_store_flag (subtarget, rcode, op0, op1, mode, 0,\n-\t\t\t\t STORE_FLAG_VALUE);\n+\t  tem = emit_store_flag_1 (subtarget, rcode, op0, op1, mode, 0,\n+\t\t\t\t   STORE_FLAG_VALUE);\n \t  if (tem != 0)\n             tem = expand_binop (target_mode, add_optab, tem,\n \t\t\t\tGEN_INT (normalizep), target, 0, OPTAB_WIDEN);\n \t}\n       else\n \t{\n-\t  tem = emit_store_flag (subtarget, rcode, op0, op1, mode, 0,\n-\t\t\t\t normalizep);\n+\t  tem = emit_store_flag_1 (subtarget, rcode, op0, op1, mode, 0,\n+\t\t\t\t   normalizep);\n \t  if (tem != 0)\n             tem = expand_binop (target_mode, xor_optab, tem, trueval, target,\n \t\t\t\tINTVAL (trueval) >= 0, OPTAB_WIDEN);"}]}