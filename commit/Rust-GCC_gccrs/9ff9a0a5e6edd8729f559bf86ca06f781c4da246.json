{"sha": "9ff9a0a5e6edd8729f559bf86ca06f781c4da246", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWZmOWEwYTVlNmVkZDg3MjlmNTU5YmY4NmNhMDZmNzgxYzRkYTI0Ng==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2019-10-02T10:18:50Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-10-02T10:18:50Z"}, "message": "re PR tree-optimization/91940 (__builtin_bswap16 loop optimization)\n\n\tPR tree-optimization/91940\n\t* tree-vect-patterns.c: Include tree-vector-builder.h and\n\tvec-perm-indices.h.\n\t(vect_recog_rotate_pattern): Also handle __builtin_bswap16, either by\n\tunpromoting the argument back to uint16_t, or by converting into a\n\trotate, or into shifts plus ior.\n\n\t* gcc.dg/vect/vect-bswap16.c: Add -msse4 on x86, run on all targets,\n\texpect vectorized 1 loops message on both vect_bswap and sse4_runtime\n\ttargets.\n\t* gcc.dg/vect/vect-bswap16a.c: New test.\n\nFrom-SVN: r276442", "tree": {"sha": "674edce34be00804e4173059cfd92b57f8f34aff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/674edce34be00804e4173059cfd92b57f8f34aff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ff9a0a5e6edd8729f559bf86ca06f781c4da246", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ff9a0a5e6edd8729f559bf86ca06f781c4da246", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ff9a0a5e6edd8729f559bf86ca06f781c4da246", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ff9a0a5e6edd8729f559bf86ca06f781c4da246/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "291fa23ac04e317877c1e102937532f080180bb2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/291fa23ac04e317877c1e102937532f080180bb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/291fa23ac04e317877c1e102937532f080180bb2"}], "stats": {"total": 174, "additions": 157, "deletions": 17}, "files": [{"sha": "47093ed52961bdac12e3423fedc7b031d2e96278", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff9a0a5e6edd8729f559bf86ca06f781c4da246/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff9a0a5e6edd8729f559bf86ca06f781c4da246/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9ff9a0a5e6edd8729f559bf86ca06f781c4da246", "patch": "@@ -1,3 +1,12 @@\n+2019-10-02  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/91940\n+\t* tree-vect-patterns.c: Include tree-vector-builder.h and\n+\tvec-perm-indices.h.\n+\t(vect_recog_rotate_pattern): Also handle __builtin_bswap16, either by\n+\tunpromoting the argument back to uint16_t, or by converting into a\n+\trotate, or into shifts plus ior.\n+\n 2019-10-02  Richard Biener  <rguenther@suse.de>\n \n \t* tree-vectorizer.h (stmt_vec_info_type::cycle_phi_info_type):"}, {"sha": "4cb430364654e4611f2a3e22c5ffb147ce0e412b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff9a0a5e6edd8729f559bf86ca06f781c4da246/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff9a0a5e6edd8729f559bf86ca06f781c4da246/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9ff9a0a5e6edd8729f559bf86ca06f781c4da246", "patch": "@@ -1,3 +1,11 @@\n+2019-10-02  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/91940\n+\t* gcc.dg/vect/vect-bswap16.c: Add -msse4 on x86, run on all targets,\n+\texpect vectorized 1 loops message on both vect_bswap and sse4_runtime\n+\ttargets.\n+\t* gcc.dg/vect/vect-bswap16a.c: New test.\n+\n 2019-10-02  Joseph Myers  <joseph@codesourcery.com>\n \n \t* gcc.dg/asm-scope-1.c, gcc.dg/cpp/c11-scope-1.c,"}, {"sha": "d29b352b832a67e89e7cb3856634390244369daa", "filename": "gcc/testsuite/gcc.dg/vect/vect-bswap16.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff9a0a5e6edd8729f559bf86ca06f781c4da246/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-bswap16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff9a0a5e6edd8729f559bf86ca06f781c4da246/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-bswap16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-bswap16.c?ref=9ff9a0a5e6edd8729f559bf86ca06f781c4da246", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-require-effective-target vect_bswap } */\n+/* { dg-additional-options \"-msse4\" { target sse4_runtime } } */\n \n #include \"tree-vect.h\"\n \n@@ -39,4 +39,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target { vect_bswap || sse4_runtime } } } } */"}, {"sha": "730dc4e83529f3f5193e4739f10029a379c4abe5", "filename": "gcc/testsuite/gcc.dg/vect/vect-bswap16a.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff9a0a5e6edd8729f559bf86ca06f781c4da246/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-bswap16a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff9a0a5e6edd8729f559bf86ca06f781c4da246/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-bswap16a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-bswap16a.c?ref=9ff9a0a5e6edd8729f559bf86ca06f781c4da246", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-additional-options \"-msse2 -mno-sse3\" { target sse2_runtime } } */\n+\n+#include \"vect-bswap16.c\"\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target { vect_shift } } } } */"}, {"sha": "09db74bdd77f14f05ca54ade64c9de01ea4fcf34", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 133, "deletions": 15, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff9a0a5e6edd8729f559bf86ca06f781c4da246/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff9a0a5e6edd8729f559bf86ca06f781c4da246/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=9ff9a0a5e6edd8729f559bf86ca06f781c4da246", "patch": "@@ -46,6 +46,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cgraph.h\"\n #include \"omp-simd-clone.h\"\n #include \"predict.h\"\n+#include \"tree-vector-builder.h\"\n+#include \"vec-perm-indices.h\"\n \n /* Return true if we have a useful VR_RANGE range for VAR, storing it\n    in *MIN_VALUE and *MAX_VALUE if so.  Note the range in the dump files.  */\n@@ -2168,24 +2170,107 @@ vect_recog_rotate_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n   enum vect_def_type dt;\n   optab optab1, optab2;\n   edge ext_def = NULL;\n+  bool bswap16_p = false;\n \n-  if (!is_gimple_assign (last_stmt))\n-    return NULL;\n+  if (is_gimple_assign (last_stmt))\n+    {\n+      rhs_code = gimple_assign_rhs_code (last_stmt);\n+      switch (rhs_code)\n+\t{\n+\tcase LROTATE_EXPR:\n+\tcase RROTATE_EXPR:\n+\t  break;\n+\tdefault:\n+\t  return NULL;\n+\t}\n \n-  rhs_code = gimple_assign_rhs_code (last_stmt);\n-  switch (rhs_code)\n+      lhs = gimple_assign_lhs (last_stmt);\n+      oprnd0 = gimple_assign_rhs1 (last_stmt);\n+      type = TREE_TYPE (oprnd0);\n+      oprnd1 = gimple_assign_rhs2 (last_stmt);\n+    }\n+  else if (gimple_call_builtin_p (last_stmt, BUILT_IN_BSWAP16))\n     {\n-    case LROTATE_EXPR:\n-    case RROTATE_EXPR:\n-      break;\n-    default:\n-      return NULL;\n+      /* __builtin_bswap16 (x) is another form of x r>> 8.\n+\t The vectorizer has bswap support, but only if the argument isn't\n+\t promoted.  */\n+      lhs = gimple_call_lhs (last_stmt);\n+      oprnd0 = gimple_call_arg (last_stmt, 0);\n+      type = TREE_TYPE (oprnd0);\n+      if (TYPE_PRECISION (TREE_TYPE (lhs)) != 16\n+\t  || TYPE_PRECISION (type) <= 16\n+\t  || TREE_CODE (oprnd0) != SSA_NAME\n+\t  || BITS_PER_UNIT != 8\n+\t  || !TYPE_UNSIGNED (TREE_TYPE (lhs)))\n+\treturn NULL;\n+\n+      stmt_vec_info def_stmt_info;\n+      if (!vect_is_simple_use (oprnd0, vinfo, &dt, &def_stmt_info, &def_stmt))\n+\treturn NULL;\n+\n+      if (dt != vect_internal_def)\n+\treturn NULL;\n+\n+      if (gimple_assign_cast_p (def_stmt))\n+\t{\n+\t  def = gimple_assign_rhs1 (def_stmt);\n+\t  if (INTEGRAL_TYPE_P (TREE_TYPE (def))\n+\t      && TYPE_PRECISION (TREE_TYPE (def)) == 16)\n+\t    oprnd0 = def;\n+\t}\n+\n+      type = TREE_TYPE (lhs);\n+      vectype = get_vectype_for_scalar_type (type);\n+      if (vectype == NULL_TREE)\n+\treturn NULL;\n+\n+      if (tree char_vectype = get_same_sized_vectype (char_type_node, vectype))\n+\t{\n+\t  /* The encoding uses one stepped pattern for each byte in the\n+\t     16-bit word.  */\n+\t  vec_perm_builder elts (TYPE_VECTOR_SUBPARTS (char_vectype), 2, 3);\n+\t  for (unsigned i = 0; i < 3; ++i)\n+\t    for (unsigned j = 0; j < 2; ++j)\n+\t      elts.quick_push ((i + 1) * 2 - j - 1);\n+\n+\t  vec_perm_indices indices (elts, 1,\n+\t\t\t\t    TYPE_VECTOR_SUBPARTS (char_vectype));\n+\t  if (can_vec_perm_const_p (TYPE_MODE (char_vectype), indices))\n+\t    {\n+\t      /* vectorizable_bswap can handle the __builtin_bswap16 if we\n+\t\t undo the argument promotion.  */\n+\t      if (!useless_type_conversion_p (type, TREE_TYPE (oprnd0)))\n+\t\t{\n+\t\t  def = vect_recog_temp_ssa_var (type, NULL);\n+\t\t  def_stmt = gimple_build_assign (def, NOP_EXPR, oprnd0);\n+\t\t  append_pattern_def_seq (stmt_vinfo, def_stmt);\n+\t\t  oprnd0 = def;\n+\t\t}\n+\n+\t      /* Pattern detected.  */\n+\t      vect_pattern_detected (\"vect_recog_rotate_pattern\", last_stmt);\n+\n+\t      *type_out = vectype;\n+\n+\t      /* Pattern supported.  Create a stmt to be used to replace the\n+\t\t pattern, with the unpromoted argument.  */\n+\t      var = vect_recog_temp_ssa_var (type, NULL);\n+\t      pattern_stmt = gimple_build_call (gimple_call_fndecl (last_stmt),\n+\t\t\t\t\t\t1, oprnd0);\n+\t      gimple_call_set_lhs (pattern_stmt, var);\n+\t      gimple_call_set_fntype (as_a <gcall *> (pattern_stmt),\n+\t\t\t\t      gimple_call_fntype (last_stmt));\n+\t      return pattern_stmt;\n+\t    }\n+\t}\n+\n+      oprnd1 = build_int_cst (integer_type_node, 8);\n+      rhs_code = LROTATE_EXPR;\n+      bswap16_p = true;\n     }\n+  else\n+    return NULL;\n \n-  lhs = gimple_assign_lhs (last_stmt);\n-  oprnd0 = gimple_assign_rhs1 (last_stmt);\n-  type = TREE_TYPE (oprnd0);\n-  oprnd1 = gimple_assign_rhs2 (last_stmt);\n   if (TREE_CODE (oprnd0) != SSA_NAME\n       || TYPE_PRECISION (TREE_TYPE (lhs)) != TYPE_PRECISION (type)\n       || !INTEGRAL_TYPE_P (type)\n@@ -2210,14 +2295,39 @@ vect_recog_rotate_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n   optab1 = optab_for_tree_code (rhs_code, vectype, optab_vector);\n   if (optab1\n       && optab_handler (optab1, TYPE_MODE (vectype)) != CODE_FOR_nothing)\n-    return NULL;\n+    {\n+     use_rotate:\n+      if (bswap16_p)\n+\t{\n+\t  if (!useless_type_conversion_p (type, TREE_TYPE (oprnd0)))\n+\t    {\n+\t      def = vect_recog_temp_ssa_var (type, NULL);\n+\t      def_stmt = gimple_build_assign (def, NOP_EXPR, oprnd0);\n+\t      append_pattern_def_seq (stmt_vinfo, def_stmt);\n+\t      oprnd0 = def;\n+\t    }\n+\n+\t  /* Pattern detected.  */\n+\t  vect_pattern_detected (\"vect_recog_rotate_pattern\", last_stmt);\n+\n+\t  *type_out = vectype;\n+\n+\t  /* Pattern supported.  Create a stmt to be used to replace the\n+\t     pattern.  */\n+\t  var = vect_recog_temp_ssa_var (type, NULL);\n+\t  pattern_stmt = gimple_build_assign (var, LROTATE_EXPR, oprnd0,\n+\t\t\t\t\t      oprnd1);\n+\t  return pattern_stmt;\n+\t}\n+      return NULL;\n+    }\n \n   if (is_a <bb_vec_info> (vinfo) || dt != vect_internal_def)\n     {\n       optab2 = optab_for_tree_code (rhs_code, vectype, optab_scalar);\n       if (optab2\n \t  && optab_handler (optab2, TYPE_MODE (vectype)) != CODE_FOR_nothing)\n-\treturn NULL;\n+\tgoto use_rotate;\n     }\n \n   /* If vector/vector or vector/scalar shifts aren't supported by the target,\n@@ -2242,6 +2352,14 @@ vect_recog_rotate_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n \n   *type_out = vectype;\n \n+  if (bswap16_p && !useless_type_conversion_p (type, TREE_TYPE (oprnd0)))\n+    {\n+      def = vect_recog_temp_ssa_var (type, NULL);\n+      def_stmt = gimple_build_assign (def, NOP_EXPR, oprnd0);\n+      append_pattern_def_seq (stmt_vinfo, def_stmt);\n+      oprnd0 = def;\n+    }\n+\n   if (dt == vect_external_def\n       && TREE_CODE (oprnd1) == SSA_NAME)\n     ext_def = vect_get_external_def_edge (vinfo, oprnd1);"}]}