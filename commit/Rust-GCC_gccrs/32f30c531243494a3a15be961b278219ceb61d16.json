{"sha": "32f30c531243494a3a15be961b278219ceb61d16", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzJmMzBjNTMxMjQzNDk0YTNhMTViZTk2MWIyNzgyMTljZWI2MWQxNg==", "commit": {"author": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1991-10-24T17:29:16Z"}, "committer": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1991-10-24T17:29:16Z"}, "message": "Initial revision\n\nFrom-SVN: r48", "tree": {"sha": "2ba2c7599e0038d5163331c317b73a75d72632b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2ba2c7599e0038d5163331c317b73a75d72632b1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/32f30c531243494a3a15be961b278219ceb61d16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32f30c531243494a3a15be961b278219ceb61d16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32f30c531243494a3a15be961b278219ceb61d16", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32f30c531243494a3a15be961b278219ceb61d16/comments", "author": null, "committer": null, "parents": [{"sha": "41299f4171dc7020e3b4837a239678c5fcece89a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41299f4171dc7020e3b4837a239678c5fcece89a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41299f4171dc7020e3b4837a239678c5fcece89a"}], "stats": {"total": 489, "additions": 489, "deletions": 0}, "files": [{"sha": "832196f905526f12cf704d8f048e2b7fbaf88f08", "filename": "gcc/genpeep.c", "status": "added", "additions": 489, "deletions": 0, "changes": 489, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32f30c531243494a3a15be961b278219ceb61d16/gcc%2Fgenpeep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32f30c531243494a3a15be961b278219ceb61d16/gcc%2Fgenpeep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenpeep.c?ref=32f30c531243494a3a15be961b278219ceb61d16", "patch": "@@ -0,0 +1,489 @@\n+/* Generate code from machine description to perform peephole optimizations.\n+   Copyright (C) 1987, 1989 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+#include <stdio.h>\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"obstack.h\"\n+\n+static struct obstack obstack;\n+struct obstack *rtl_obstack = &obstack;\n+\n+#define obstack_chunk_alloc xmalloc\n+#define obstack_chunk_free free\n+\n+extern void free ();\n+\n+/* While tree-walking an instruction pattern, we keep a chain\n+   of these `struct link's to record how to get down to the\n+   current position.  In each one, POS is the operand number,\n+   and if the operand is a vector VEC is the element number.\n+   VEC is -1 if the operand is not a vector.  */\n+\n+struct link\n+{\n+  struct link *next;\n+  int pos;\n+  int vecelt;\n+};\n+\n+char *xmalloc ();\n+static void match_rtx ();\n+static void gen_exp ();\n+static void fatal ();\n+void fancy_abort ();\n+\n+static int max_opno;\n+\n+/* Number of operands used in current peephole definition.  */\n+\n+static int n_operands;\n+\n+/* Peephole optimizations get insn codes just like insn patterns.\n+   Count them so we know the code of the define_peephole we are handling.  */\n+\n+static int insn_code_number = 0;\n+\n+static void print_path ();\n+static void print_code ();\n+\f\n+static void\n+gen_peephole (peep)\n+     rtx peep;\n+{\n+  int ninsns = XVECLEN (peep, 0);\n+  int i;\n+\n+  n_operands = 0;\n+\n+  printf (\"  insn = ins1;\\n\");\n+#if 0\n+  printf (\"  want_jump = 0;\\n\");\n+#endif\n+\n+  for (i = 0; i < ninsns; i++)\n+    {\n+      if (i > 0)\n+\t{\n+\t  printf (\"  do { insn = NEXT_INSN (insn);\\n\");\n+\t  printf (\"       if (insn == 0) goto L%d; }\\n\",\n+\t\t  insn_code_number);\n+\t  printf (\"  while (GET_CODE (insn) == NOTE\\n\");\n+\t  printf (\"\\t || (GET_CODE (insn) == INSN\\n\");\n+\t  printf (\"\\t     && (GET_CODE (PATTERN (insn)) == USE\\n\");\n+\t  printf (\"\\t\\t || GET_CODE (PATTERN (insn)) == CLOBBER)));\\n\");\n+\n+\t  printf (\"  if (GET_CODE (insn) == CODE_LABEL\\n\\\n+      || GET_CODE (insn) == BARRIER)\\n    goto L%d;\\n\",\n+  \t\t  insn_code_number);\n+\t}\n+\n+#if 0\n+      printf (\"  if (GET_CODE (insn) == JUMP_INSN)\\n\");\n+      printf (\"    want_jump = JUMP_LABEL (insn);\\n\");\n+#endif\n+\n+      printf (\"  pat = PATTERN (insn);\\n\");\n+\n+      /* Walk the insn's pattern, remembering at all times the path\n+\t down to the walking point.  */\n+\n+      match_rtx (XVECEXP (peep, 0, i), 0, insn_code_number);\n+    }\n+\n+  /* We get this far if the pattern matches.\n+     Now test the extra condition.  */\n+\n+  if (XSTR (peep, 1) && XSTR (peep, 1)[0])\n+    printf (\"  if (! (%s)) goto L%d;\\n\",\n+\t    XSTR (peep, 1), insn_code_number);\n+\n+  /* If that matches, construct new pattern and put it in the first insn.\n+     This new pattern will never be matched.\n+     It exists only so that insn-extract can get the operands back.\n+     So use a simple regular form: a PARALLEL containing a vector\n+     of all the operands.  */\n+\n+  printf (\"  PATTERN (ins1) = gen_rtx (PARALLEL, VOIDmode, gen_rtvec_v (%d, operands));\\n\", n_operands);\n+\n+#if 0\n+  printf (\"  if (want_jump && GET_CODE (ins1) != JUMP_INSN)\\n\");\n+  printf (\"    {\\n\");\n+  printf (\"      rtx insn2 = emit_jump_insn_before (PATTERN (ins1), ins1);\\n\");\n+  printf (\"      delete_insn (ins1);\\n\");\n+  printf (\"      ins1 = ins2;\\n\");\n+  printf (\"    }\\n\");\n+#endif\n+\n+  /* Record this define_peephole's insn code in the insn,\n+     as if it had been recognized to match this.  */\n+  printf (\"  INSN_CODE (ins1) = %d;\\n\",\n+\t  insn_code_number);\n+\n+  /* Delete the remaining insns.  */\n+  if (ninsns > 1)\n+    printf (\"  delete_for_peephole (NEXT_INSN (ins1), insn);\\n\");\n+\n+  /* See reload1.c for insertion of NOTE which guarantees that this\n+     cannot be zero.  */\n+  printf (\"  return NEXT_INSN (insn);\\n\");\n+\n+  printf (\" L%d:\\n\\n\", insn_code_number);\n+}\n+\f\n+static void\n+match_rtx (x, path, fail_label)\n+     rtx x;\n+     struct link *path;\n+     int fail_label;\n+{\n+  register RTX_CODE code;\n+  register int i;\n+  register int len;\n+  register char *fmt;\n+  struct link link;\n+\n+  if (x == 0)\n+    return;\n+\n+\n+  code = GET_CODE (x);\n+\n+  switch (code)\n+    {\n+    case MATCH_OPERAND:\n+      if (XINT (x, 0) > max_opno)\n+\tmax_opno = XINT (x, 0);\n+      if (XINT (x, 0) >= n_operands)\n+\tn_operands = 1 + XINT (x, 0);\n+\n+      printf (\"  x = \");\n+      print_path (path);\n+      printf (\";\\n\");\n+\n+      printf (\"  operands[%d] = x;\\n\", XINT (x, 0));\n+      if (XSTR (x, 1) && XSTR (x, 1)[0])\n+\tprintf (\"  if (! %s (x, %smode)) goto L%d;\\n\",\n+\t\tXSTR (x, 1), GET_MODE_NAME (GET_MODE (x)), fail_label);\n+      return;\n+\n+    case MATCH_DUP:\n+      printf (\"  x = \");\n+      print_path (path);\n+      printf (\";\\n\");\n+\n+      printf (\"  if (!rtx_equal_p (operands[%d], x)) goto L%d;\\n\",\n+\t      XINT (x, 0), fail_label);\n+      return;\n+\n+    case MATCH_OP_DUP:\n+      printf (\"  x = \");\n+      print_path (path);\n+      printf (\";\\n\");\n+\n+      printf (\"  if (GET_CODE (operands[%d]) != GET_CODE (x)\\n\", XINT (x, 0));\n+      printf (\"      || GET_MODE (operands[%d]) != GET_MODE (x)) goto L%d;\\n\",\n+\t      XINT (x, 0), fail_label);\n+      printf (\"  operands[%d] = x;\\n\", XINT (x, 0));\n+      link.next = path;\n+      link.vecelt = -1;\n+      for (i = 0; i < XVECLEN (x, 1); i++)\n+\t{\n+\t  link.pos = i;\n+\t  match_rtx (XVECEXP (x, 1, i), &link, fail_label);\n+\t}\n+      return;\n+\n+    case MATCH_OPERATOR:\n+      if (XINT (x, 0) > max_opno)\n+\tmax_opno = XINT (x, 0);\n+      if (XINT (x, 0) >= n_operands)\n+\tn_operands = 1 + XINT (x, 0);\n+\n+      printf (\"  x = \");\n+      print_path (path);\n+      printf (\";\\n\");\n+\n+      printf (\"  operands[%d] = x;\\n\", XINT (x, 0));\n+      if (XSTR (x, 1) && XSTR (x, 1)[0])\n+\tprintf (\"  if (! %s (x, %smode)) goto L%d;\\n\",\n+\t\tXSTR (x, 1), GET_MODE_NAME (GET_MODE (x)), fail_label);\n+      link.next = path;\n+      link.vecelt = -1;\n+      for (i = 0; i < XVECLEN (x, 2); i++)\n+\t{\n+\t  link.pos = i;\n+\t  match_rtx (XVECEXP (x, 2, i), &link, fail_label);\n+\t}\n+      return;\n+\n+    case MATCH_PARALLEL:\n+      if (XINT (x, 0) > max_opno)\n+\tmax_opno = XINT (x, 0);\n+      if (XINT (x, 0) >= n_operands)\n+\tn_operands = 1 + XINT (x, 0);\n+\n+      printf (\"  x = \");\n+      print_path (path);\n+      printf (\";\\n\");\n+\n+      printf (\"  if (GET_CODE (x) != PARALLEL) goto L%d;\\n\", fail_label);\n+      printf (\"  operands[%d] = x;\\n\", XINT (x, 0));\n+      if (XSTR (x, 1) && XSTR (x, 1)[0])\n+\tprintf (\"  if (! %s (x, %smode)) goto L%d;\\n\",\n+\t\tXSTR (x, 1), GET_MODE_NAME (GET_MODE (x)), fail_label);\n+      link.next = path;\n+      link.pos = 0;\n+      for (i = 0; i < XVECLEN (x, 2); i++)\n+\t{\n+\t  link.vecelt = i;\n+\t  match_rtx (XVECEXP (x, 2, i), &link, fail_label);\n+\t}\n+      return;\n+\n+    case ADDRESS:\n+      match_rtx (XEXP (x, 0), path, fail_label);\n+      return;\n+    }\n+\n+  printf (\"  x = \");\n+  print_path (path);\n+  printf (\";\\n\");\n+\n+  printf (\"  if (GET_CODE (x) != \");\n+  print_code (code);\n+  printf (\") goto L%d;\\n\", fail_label);\n+\n+  if (GET_MODE (x) != VOIDmode)\n+    {\n+      printf (\"  if (GET_MODE (x) != %smode) goto L%d;\\n\",\n+\t      GET_MODE_NAME (GET_MODE (x)), fail_label);\n+    }\n+\n+  link.next = path;\n+  link.vecelt = -1;\n+  fmt = GET_RTX_FORMAT (code);\n+  len = GET_RTX_LENGTH (code);\n+  for (i = 0; i < len; i++)\n+    {\n+      link.pos = i;\n+      if (fmt[i] == 'e' || fmt[i] == 'u')\n+\tmatch_rtx (XEXP (x, i), &link, fail_label);\n+      else if (fmt[i] == 'E')\n+\t{\n+\t  int j;\n+\t  printf (\"  if (XVECLEN (x, %d) != %d) goto L%d;\\n\",\n+\t\t  i, XVECLEN (x, i), fail_label);\n+\t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t    {\n+\t      link.vecelt = j;\n+\t      match_rtx (XVECEXP (x, i, j), &link, fail_label);\n+\t    }\n+\t}\n+      else if (fmt[i] == 'i')\n+\t{\n+\t  /* Make sure that at run time `x' is the RTX we want to test.  */\n+\t  if (i != 0)\n+\t    {\n+\t      printf (\"  x = \");\n+\t      print_path (path);\n+\t      printf (\";\\n\");\n+\t    }\n+\n+\t  printf (\"  if (XINT (x, %d) != %d) goto L%d;\\n\",\n+\t\t  i, XINT (x, i), fail_label);\n+\t}\n+      else if (fmt[i] == 's')\n+\t{\n+\t  /* Make sure that at run time `x' is the RTX we want to test.  */\n+\t  if (i != 0)\n+\t    {\n+\t      printf (\"  x = \");\n+\t      print_path (path);\n+\t      printf (\";\\n\");\n+\t    }\n+\n+\t  printf (\"  if (strcmp (XSTR (x, %d), \\\"%s\\\")) goto L%d;\\n\",\n+\t\t  i, XSTR (x, i), fail_label);\n+\t}\n+    }\n+}\n+\n+/* Given a PATH, representing a path down the instruction's\n+   pattern from the root to a certain point, output code to\n+   evaluate to the rtx at that point.  */\n+\n+static void\n+print_path (path)\n+     struct link *path;\n+{\n+  if (path == 0)\n+    printf (\"pat\");\n+  else if (path->vecelt >= 0)\n+    {\n+      printf (\"XVECEXP (\");\n+      print_path (path->next);\n+      printf (\", %d, %d)\", path->pos, path->vecelt);\n+    }\n+  else\n+    {\n+      printf (\"XEXP (\");\n+      print_path (path->next);\n+      printf (\", %d)\", path->pos);\n+    }\n+}\n+\f\n+static void\n+print_code (code)\n+     RTX_CODE code;\n+{\n+  register char *p1;\n+  for (p1 = GET_RTX_NAME (code); *p1; p1++)\n+    {\n+      if (*p1 >= 'a' && *p1 <= 'z')\n+\tputchar (*p1 + 'A' - 'a');\n+      else\n+\tputchar (*p1);\n+    }\n+}\n+\f\n+char *\n+xmalloc (size)\n+     unsigned size;\n+{\n+  register char *val = (char *) malloc (size);\n+\n+  if (val == 0)\n+    fatal (\"virtual memory exhausted\");\n+  return val;\n+}\n+\n+char *\n+xrealloc (ptr, size)\n+     char *ptr;\n+     unsigned size;\n+{\n+  char *result = (char *) realloc (ptr, size);\n+  if (!result)\n+    fatal (\"virtual memory exhausted\");\n+  return result;\n+}\n+\n+static void\n+fatal (s, a1, a2)\n+     char *s;\n+{\n+  fprintf (stderr, \"genpeep: \");\n+  fprintf (stderr, s, a1, a2);\n+  fprintf (stderr, \"\\n\");\n+  exit (FATAL_EXIT_CODE);\n+}\n+\n+/* More 'friendly' abort that prints the line and file.\n+   config.h can #define abort fancy_abort if you like that sort of thing.  */\n+\n+void\n+fancy_abort ()\n+{\n+  fatal (\"Internal gcc abort.\");\n+}\n+\f\n+int\n+main (argc, argv)\n+     int argc;\n+     char **argv;\n+{\n+  rtx desc;\n+  FILE *infile;\n+  extern rtx read_rtx ();\n+  register int c;\n+\n+  max_opno = -1;\n+\n+  obstack_init (rtl_obstack);\n+\n+  if (argc <= 1)\n+    fatal (\"No input file name.\");\n+\n+  infile = fopen (argv[1], \"r\");\n+  if (infile == 0)\n+    {\n+      perror (argv[1]);\n+      exit (FATAL_EXIT_CODE);\n+    }\n+\n+  init_rtl ();\n+\n+  printf (\"/* Generated automatically by the program `genpeep'\\n\\\n+from the machine description file `md'.  */\\n\\n\");\n+\n+  printf (\"#include \\\"config.h\\\"\\n\");\n+  printf (\"#include \\\"rtl.h\\\"\\n\");\n+  printf (\"#include \\\"regs.h\\\"\\n\");\n+  printf (\"#include \\\"output.h\\\"\\n\");\n+  printf (\"#include \\\"real.h\\\"\\n\\n\");\n+\n+  printf (\"extern rtx peep_operand[];\\n\\n\");\n+  printf (\"#define operands peep_operand\\n\\n\");\n+\n+  printf (\"rtx\\npeephole (ins1)\\n     rtx ins1;\\n{\\n\");\n+  printf (\"  rtx insn, x, pat;\\n\");\n+  printf (\"  int i;\\n\\n\");\n+\n+  /* Early out: no peepholes for insns followed by barriers.  */\n+  printf (\"  if (NEXT_INSN (ins1)\\n\");\n+  printf (\"      && GET_CODE (NEXT_INSN (ins1)) == BARRIER)\\n\");\n+  printf (\"    return 0;\\n\\n\");\n+\n+  /* Read the machine description.  */\n+\n+  while (1)\n+    {\n+      c = read_skip_spaces (infile);\n+      if (c == EOF)\n+\tbreak;\n+      ungetc (c, infile);\n+\n+      desc = read_rtx (infile);\n+      if (GET_CODE (desc) == DEFINE_PEEPHOLE)\n+\t{\n+\t  gen_peephole (desc);\n+\t  insn_code_number++;\n+\t}\n+      if (GET_CODE (desc) == DEFINE_INSN\n+\t  || GET_CODE (desc) == DEFINE_EXPAND\n+\t  || GET_CODE (desc) == DEFINE_SPLIT)\n+\t{\n+\t  insn_code_number++;\n+\t}\n+    }\n+\n+  printf (\"  return 0;\\n}\\n\\n\");\n+\n+  if (max_opno == -1)\n+    max_opno = 1;\n+\n+  printf (\"rtx peep_operand[%d];\\n\", max_opno + 1);\n+\n+  fflush (stdout);\n+  exit (ferror (stdout) != 0 ? FATAL_EXIT_CODE : SUCCESS_EXIT_CODE);\n+  /* NOTREACHED */\n+  return 0;\n+}"}]}