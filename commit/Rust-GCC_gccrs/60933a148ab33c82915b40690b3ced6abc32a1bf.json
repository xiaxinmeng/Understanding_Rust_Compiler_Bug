{"sha": "60933a148ab33c82915b40690b3ced6abc32a1bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjA5MzNhMTQ4YWIzM2M4MjkxNWI0MDY5MGIzY2VkNmFiYzMyYTFiZg==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-07-23T02:36:05Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-07-23T02:36:05Z"}, "message": "analyzer: fix feasibility false +ve with overly complex svalues\n\ngcc/analyzer/ChangeLog:\n\t* diagnostic-manager.cc\n\t(class auto_disable_complexity_checks): New.\n\t(epath_finder::explore_feasible_paths): Use it to disable\n\tcomplexity checks whilst processing the worklist.\n\t* region-model-manager.cc\n\t(region_model_manager::region_model_manager): Initialize\n\tm_check_complexity.\n\t(region_model_manager::reject_if_too_complex): Bail if\n\tm_check_complexity is false.\n\t* region-model.h\n\t(region_model_manager::enable_complexity_check): New.\n\t(region_model_manager::disable_complexity_check): New.\n\t(region_model_manager::m_check_complexity): New.\n\ngcc/testsuite/ChangeLog:\n\t* gcc.dg/analyzer/feasibility-3.c: New test.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "04b6d29d7e1fe885237be0172dd4314fd15deb3f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04b6d29d7e1fe885237be0172dd4314fd15deb3f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/60933a148ab33c82915b40690b3ced6abc32a1bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60933a148ab33c82915b40690b3ced6abc32a1bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60933a148ab33c82915b40690b3ced6abc32a1bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60933a148ab33c82915b40690b3ced6abc32a1bf/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3382846558e02044598556e66e5ea1cb3115429d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3382846558e02044598556e66e5ea1cb3115429d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3382846558e02044598556e66e5ea1cb3115429d"}], "stats": {"total": 189, "additions": 182, "deletions": 7}, "files": [{"sha": "ef3df3243650d40b52f1e13070833c11dacee093", "filename": "gcc/analyzer/diagnostic-manager.cc", "status": "modified", "additions": 40, "deletions": 7, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60933a148ab33c82915b40690b3ced6abc32a1bf/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60933a148ab33c82915b40690b3ced6abc32a1bf/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.cc?ref=60933a148ab33c82915b40690b3ced6abc32a1bf", "patch": "@@ -292,6 +292,34 @@ class feasible_worklist\n   const shortest_paths<eg_traits, exploded_path> &m_sep;\n };\n \n+/* When we're building the exploded graph we want to simplify\n+   overly-complicated symbolic values down to \"UNKNOWN\" to try to avoid\n+   state explosions and unbounded chains of exploration.\n+\n+   However, when we're building the feasibility graph for a diagnostic\n+   (actually a tree), we don't want UNKNOWN values, as conditions on them\n+   are also unknown: we don't want to have a contradiction such as a path\n+   where (VAL != 0) and then (VAL == 0) along the same path.\n+\n+   Hence this is an RAII class for temporarily disabling complexity-checking\n+   in the region_model_manager, for use within\n+   epath_finder::explore_feasible_paths.  */\n+\n+class auto_disable_complexity_checks\n+{\n+public:\n+  auto_disable_complexity_checks (region_model_manager *mgr) : m_mgr (mgr)\n+  {\n+    m_mgr->disable_complexity_check ();\n+  }\n+  ~auto_disable_complexity_checks ()\n+  {\n+    m_mgr->enable_complexity_check ();\n+  }\n+private:\n+  region_model_manager *m_mgr;\n+};\n+\n /* Attempt to find the shortest feasible path from the origin to\n    TARGET_ENODE by iteratively building a feasible_graph, in which\n    every path to a feasible_node is feasible by construction.\n@@ -344,6 +372,8 @@ epath_finder::explore_feasible_paths (const exploded_node *target_enode,\n   logger *logger = get_logger ();\n   LOG_SCOPE (logger);\n \n+  region_model_manager *mgr = m_eg.get_engine ()->get_model_manager ();\n+\n   /* Determine the shortest path to TARGET_ENODE from each node in\n      the exploded graph.  */\n   shortest_paths<eg_traits, exploded_path> sep\n@@ -363,8 +393,7 @@ epath_finder::explore_feasible_paths (const exploded_node *target_enode,\n \n   /* Populate the worklist with the origin node.  */\n   {\n-    feasibility_state init_state (m_eg.get_engine ()->get_model_manager (),\n-\t\t\t\t  m_eg.get_supergraph ());\n+    feasibility_state init_state (mgr, m_eg.get_supergraph ());\n     feasible_node *origin = fg.add_node (m_eg.get_origin (), init_state, 0);\n     worklist.add_node (origin);\n   }\n@@ -376,11 +405,15 @@ epath_finder::explore_feasible_paths (const exploded_node *target_enode,\n   /* Set this if we find a feasible path to TARGET_ENODE.  */\n   exploded_path *best_path = NULL;\n \n-  while (process_worklist_item (&worklist, tg, &fg, target_enode, diag_idx,\n-\t\t\t\t&best_path))\n-    {\n-      /* Empty; the work is done within process_worklist_item.  */\n-    }\n+  {\n+    auto_disable_complexity_checks sentinel (mgr);\n+\n+    while (process_worklist_item (&worklist, tg, &fg, target_enode, diag_idx,\n+\t\t\t\t  &best_path))\n+      {\n+\t/* Empty; the work is done within process_worklist_item.  */\n+      }\n+  }\n \n   if (logger)\n     {"}, {"sha": "14c57d8e0d8ec7a51255594cbe5449563d9074bb", "filename": "gcc/analyzer/region-model-manager.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60933a148ab33c82915b40690b3ced6abc32a1bf/gcc%2Fanalyzer%2Fregion-model-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60933a148ab33c82915b40690b3ced6abc32a1bf/gcc%2Fanalyzer%2Fregion-model-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-manager.cc?ref=60933a148ab33c82915b40690b3ced6abc32a1bf", "patch": "@@ -71,6 +71,7 @@ region_model_manager::region_model_manager ()\n   m_stack_region (alloc_region_id (), &m_root_region),\n   m_heap_region (alloc_region_id (), &m_root_region),\n   m_unknown_NULL (NULL),\n+  m_check_complexity (true),\n   m_max_complexity (0, 0),\n   m_code_region (alloc_region_id (), &m_root_region),\n   m_fndecls_map (), m_labels_map (),\n@@ -160,6 +161,9 @@ region_model_manager::too_complex_p (const complexity &c) const\n bool\n region_model_manager::reject_if_too_complex (svalue *sval)\n {\n+  if (!m_check_complexity)\n+    return false;\n+\n   const complexity &c = sval->get_complexity ();\n   if (!too_complex_p (c))\n     {"}, {"sha": "1c7a3865346ec16ca9ef10dd5a9d89df77caefe3", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60933a148ab33c82915b40690b3ced6abc32a1bf/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60933a148ab33c82915b40690b3ced6abc32a1bf/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=60933a148ab33c82915b40690b3ced6abc32a1bf", "patch": "@@ -323,6 +323,9 @@ class region_model_manager\n \n   void log_stats (logger *logger, bool show_objs) const;\n \n+  void enable_complexity_check (void) { m_check_complexity = true; }\n+  void disable_complexity_check (void) { m_check_complexity = false; }\n+\n private:\n   bool too_complex_p (const complexity &c) const;\n   bool reject_if_too_complex (svalue *sval);\n@@ -407,6 +410,8 @@ class region_model_manager\n \t\t   conjured_svalue *> conjured_values_map_t;\n   conjured_values_map_t m_conjured_values_map;\n \n+  bool m_check_complexity;\n+\n   /* Maximum complexity of svalues that weren't rejected.  */\n   complexity m_max_complexity;\n "}, {"sha": "0c0bd14fa54a7d147dc48a1547a4f0565adc9fb8", "filename": "gcc/testsuite/gcc.dg/analyzer/feasibility-3.c", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60933a148ab33c82915b40690b3ced6abc32a1bf/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffeasibility-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60933a148ab33c82915b40690b3ced6abc32a1bf/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffeasibility-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffeasibility-3.c?ref=60933a148ab33c82915b40690b3ced6abc32a1bf", "patch": "@@ -0,0 +1,133 @@\n+/* Reduced and adapted from Linux: fs/proc/inode.c: proc_reg_open\n+   (GPL v2.0).  */\n+\n+/* Types.  */\n+\n+typedef unsigned char u8;\n+typedef _Bool bool;\n+typedef unsigned int gfp_t;\n+\n+struct file;\n+struct kmem_cache;\n+struct proc_dir_entry;\n+\n+struct inode { /* [...snip...] */ };\n+\n+enum {\n+ PROC_ENTRY_PERMANENT = 1U << 0,\n+};\n+\n+struct proc_ops {\n+ /* [...snip...] */\n+ int (*proc_open)(struct inode *, struct file *);\n+ /* [...snip...] */\n+ int (*proc_release)(struct inode *, struct file *);\n+ /* [...snip...] */\n+};\n+\n+struct proc_dir_entry {\n+ /* [...snip...] */\n+ struct completion *pde_unload_completion;\n+ /* [...snip...] */\n+ union {\n+  const struct proc_ops *proc_ops;\n+  const struct file_operations *proc_dir_ops;\n+ };\n+ /* [...snip...] */\n+ u8 flags;\n+ /* [...snip...] */\n+};\n+\n+struct pde_opener {\n+ /* [...snip...] */\n+ struct file *file;\n+ /* [...snip...] */\n+};\n+\n+struct proc_inode {\n+ /* [...snip...] */\n+ struct proc_dir_entry *pde;\n+ /* [...snip...] */\n+ struct inode vfs_inode;\n+};\n+\n+/* Data.  */\n+\n+static struct kmem_cache *pde_opener_cache __attribute__((__section__(\".data..ro_after_init\")));\n+\n+/* Functions. */\n+\n+void *kmem_cache_alloc(struct kmem_cache *, gfp_t flags) __attribute__((__malloc__));\n+void kmem_cache_free(struct kmem_cache *, void *);\n+\n+static inline bool pde_is_permanent(const struct proc_dir_entry *pde)\n+{\n+ return pde->flags & PROC_ENTRY_PERMANENT;\n+}\n+\n+static inline struct proc_inode *PROC_I(const struct inode *inode)\n+{\n+  void *__mptr = (void *)(inode);\n+  return ((struct proc_inode *)(__mptr - __builtin_offsetof(struct proc_inode, vfs_inode)));\n+}\n+\n+static inline struct proc_dir_entry *PDE(const struct inode *inode)\n+{\n+ return PROC_I(inode)->pde;\n+}\n+\n+/* We don't want to emit bogus use of uninitialized value 'pdeo'\n+   warnings from -Wanalyzer-use-of-uninitialized-value in this function;\n+   these would require following infeasible paths in which \"release\" is\n+   first NULL (to avoid the initialization of \"pdeo\") and then is non-NULL\n+   (to access \"pdeo\").\n+\n+   \"release\" is sufficiently complicated in this function to hit the\n+   complexity limit for symbolic values during enode exploration.  */\n+\n+static int proc_reg_open(struct inode *inode, struct file *file)\n+{\n+ struct proc_dir_entry *pde = PDE(inode);\n+ int rv = 0;\n+ typeof(((struct proc_ops*)0)->proc_open) open;\n+ typeof(((struct proc_ops*)0)->proc_release) release;\n+ struct pde_opener *pdeo;\n+\n+ if (pde_is_permanent(pde)) {\n+  open = pde->proc_ops->proc_open;\n+  if (open)\n+   rv = open(inode, file);\n+  return rv;\n+ }\n+\n+ /* [...snip...] */\n+\n+ release = pde->proc_ops->proc_release;\n+ if (release) {\n+  pdeo = kmem_cache_alloc(pde_opener_cache,\n+\t\t\t  ((( gfp_t)(0x400u|0x800u))\n+\t\t\t   | (( gfp_t)0x40u)\n+\t\t\t   | (( gfp_t)0x80u)));\n+  if (!pdeo) {\n+   rv = -12;\n+   goto out_unuse;\n+  }\n+ }\n+\n+ open = pde->proc_ops->proc_open;\n+ if (open)\n+  rv = open(inode, file);\n+\n+ if (release) {\n+  if (rv == 0) {\n+\n+   pdeo->file = file; /* { dg-bogus \"uninit\" } */\n+   /* [...snip...] */\n+  } else\n+   kmem_cache_free(pde_opener_cache, pdeo); /* { dg-bogus \"uninit\" } */\n+ }\n+\n+out_unuse:\n+ /* [...snip...] */\n+ return rv;\n+}"}]}