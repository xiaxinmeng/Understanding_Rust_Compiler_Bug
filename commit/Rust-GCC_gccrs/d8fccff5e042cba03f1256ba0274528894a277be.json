{"sha": "d8fccff5e042cba03f1256ba0274528894a277be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDhmY2NmZjVlMDQyY2JhMDNmMTI1NmJhMDI3NDUyODg5NGEyNzdiZQ==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@cygnus.com", "date": "1999-01-19T10:27:23Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "1999-01-19T10:27:23Z"}, "message": "java-tree.h: (check_for_initialization): Added prototype.\n\nSun Jan 17 22:34:22 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\t* java-tree.h: (check_for_initialization): Added prototype.\n\t* lex.c (java_parse_doc_section): `\\n' breaks the `*/' string.\n\t* parse.y (do_resolve_class): Removed unused locals.\n\t(read_import_dir): Likewise.\n\t(resolve_qualified_expression_name): Array creation\n \texpressions are valid primary expressions.\n\t(qualify_ambiguous_name): Likewise.\n\t(patch_synchronized_statement): Removed unused local.\n\nFrom-SVN: r24758", "tree": {"sha": "b10f299a9af3db7d575bc17bfd23bf7af6ad56b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b10f299a9af3db7d575bc17bfd23bf7af6ad56b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d8fccff5e042cba03f1256ba0274528894a277be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8fccff5e042cba03f1256ba0274528894a277be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8fccff5e042cba03f1256ba0274528894a277be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8fccff5e042cba03f1256ba0274528894a277be/comments", "author": null, "committer": null, "parents": [{"sha": "b472794d0e1babaa0e0e33975712084279933fe8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b472794d0e1babaa0e0e33975712084279933fe8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b472794d0e1babaa0e0e33975712084279933fe8"}], "stats": {"total": 79, "additions": 56, "deletions": 23}, "files": [{"sha": "bbd7ca3748971e5514ae8cb32ade32dbdb428df9", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8fccff5e042cba03f1256ba0274528894a277be/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8fccff5e042cba03f1256ba0274528894a277be/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=d8fccff5e042cba03f1256ba0274528894a277be", "patch": "@@ -3,6 +3,17 @@\n \t* parse.y (patch_binop): Do a type conversion from signed to\n \tunsigned and then back to signed when a \">>>\" is found.\n \n+Sun Jan 17 22:34:22 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* java-tree.h: (check_for_initialization): Added prototype.\n+\t* lex.c (java_parse_doc_section): `\\n' breaks the `*/' string.\n+\t* parse.y (do_resolve_class): Removed unused locals.\n+\t(read_import_dir): Likewise.\n+\t(resolve_qualified_expression_name): Array creation\n+ \texpressions are valid primary expressions.\n+\t(qualify_ambiguous_name): Likewise.\n+\t(patch_synchronized_statement): Removed unused local.\n+\n Sun Jan 17 21:55:42 1999  Jeffrey A Law  (law@cygnus.com)\n \n \t* Makefile.in (zextract.o): Add dependencies."}, {"sha": "c945dffb7e974d36ef9ddadedc25ce3fce01d0da", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8fccff5e042cba03f1256ba0274528894a277be/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8fccff5e042cba03f1256ba0274528894a277be/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=d8fccff5e042cba03f1256ba0274528894a277be", "patch": "@@ -566,6 +566,7 @@ extern tree build_primtype_type_ref PROTO ((char *));\n extern tree java_get_real_method_name PROTO ((tree));\n extern void finish_class PROTO ((tree));\n extern void java_layout_seen_class_methods PROTO (());\n+extern void check_for_initialization PROTO ((tree));\n \n /* Access flags etc for a method (a FUNCTION_DECL): */\n "}, {"sha": "ff7be9839ad958728867cd7fb7ff578398f7a7a7", "filename": "gcc/java/lex.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8fccff5e042cba03f1256ba0274528894a277be/gcc%2Fjava%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8fccff5e042cba03f1256ba0274528894a277be/gcc%2Fjava%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.c?ref=d8fccff5e042cba03f1256ba0274528894a277be", "patch": "@@ -409,7 +409,6 @@ java_parse_doc_section (c)\n \t  break;\n \tcase '\\n': /* ULT */\n \t  valid_tag = 1;\n-\t  break;\n \tdefault:\n \t  seen_star = 0;\n \t}"}, {"sha": "a57e019813655bfb6dd65cf58e8b2b96bb37e860", "filename": "gcc/java/parse.c", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8fccff5e042cba03f1256ba0274528894a277be/gcc%2Fjava%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8fccff5e042cba03f1256ba0274528894a277be/gcc%2Fjava%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.c?ref=d8fccff5e042cba03f1256ba0274528894a277be", "patch": "@@ -2250,7 +2250,7 @@ static const short yycheck[] = {     3,\n #define YYPURE 1\n \n /* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */\n-#line 3 \"/local/aph/tx39/share/bison.simple\"\n+#line 3 \"/usr/cygnus/gnupro-98r2/share/bison.simple\"\n \n /* Skeleton output parser for bison,\n    Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.\n@@ -2443,7 +2443,7 @@ __yy_memcpy (char *to, char *from, int count)\n #endif\n #endif\n \f\n-#line 196 \"/local/aph/tx39/share/bison.simple\"\n+#line 196 \"/usr/cygnus/gnupro-98r2/share/bison.simple\"\n \n /* The user can define YYPARSE_PARAM as the name of an argument to be passed\n    into yyparse.  The argument should have type void *.\n@@ -4701,7 +4701,7 @@ case 492:\n     break;}\n }\n    /* the action file gets copied in in place of this dollarsign */\n-#line 498 \"/local/aph/tx39/share/bison.simple\"\n+#line 498 \"/usr/cygnus/gnupro-98r2/share/bison.simple\"\n \f\n   yyvsp -= yylen;\n   yyssp -= yylen;\n@@ -6751,7 +6751,6 @@ do_resolve_class (class_type, decl, cl)\n      tree cl;\n {\n   tree new_class_decl;\n-  tree new_name;\n   tree original_name = NULL_TREE;\n \n   /* Do not try to replace TYPE_NAME (class_type) by a variable, since\n@@ -7595,7 +7594,7 @@ read_import_dir (wfl)\n   char *package_name = IDENTIFIER_POINTER (package_id);\n   int package_length = IDENTIFIER_LENGTH (package_id);\n   DIR *dirp = NULL;\n-  JCF jcfr, *jcf, *saved_jcf = current_jcf;\n+  JCF *saved_jcf = current_jcf;\n \n   int found = 0;\n   int k;\n@@ -7666,7 +7665,6 @@ read_import_dir (wfl)\n \t  *filename->ptr++ = '/';\n \t  for (;;)\n \t    {\n-\t      int java_or_class = 0;\n \t      int len; \n \t      char *d_name;\n \t      struct dirent *direntp = readdir (dirp);\n@@ -8848,6 +8846,14 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t    }\n \t  continue;\n \n+\tcase NEW_ARRAY_EXPR:\n+\t  *where_found = decl = java_complete_tree (qual_wfl);\n+\t  if (decl == error_mark_node)\n+\t    return 1;\n+\t  *type_found = type = QUAL_DECL_TYPE (decl);\n+\t  CLASS_LOADED_P (type) = 1;\n+\t  continue;\n+\n \tcase CONVERT_EXPR:\n \t  *where_found = decl = java_complete_tree (qual_wfl);\n \t  if (decl == error_mark_node)\n@@ -9889,7 +9895,7 @@ qualify_ambiguous_name (id)\n      tree id;\n {\n   tree qual, qual_wfl, name, decl, ptr_type, saved_current_class;\n-  int again, super_found = 0, this_found = 0;\n+  int again, super_found = 0, this_found = 0, new_array_found = 0;\n \n   /* We first qualify the first element, then derive qualification of\n      others based on the first one. If the first element is qualified\n@@ -9917,6 +9923,10 @@ qualify_ambiguous_name (id)\n \t    qual_wfl = QUAL_WFL (qual);\n \t  }\n \tbreak;\n+      case NEW_ARRAY_EXPR:\n+\tqual = TREE_CHAIN (qual);\n+\tnew_array_found = again = 1;\n+\tcontinue;\n       case NEW_CLASS_EXPR:\n       case CONVERT_EXPR:\n \tqual_wfl = TREE_OPERAND (qual_wfl, 0);\n@@ -9973,7 +9983,6 @@ qualify_ambiguous_name (id)\n      declaration or parameter declaration, then it is an expression\n      name. We don't carry this test out if we're in the context of the\n      use of SUPER or THIS */\n-\n   if (!this_found && !super_found && (decl = IDENTIFIER_LOCAL_VALUE (name)))\n     {\n       RESOLVE_EXPRESSION_NAME_P (qual_wfl) = 1;\n@@ -9982,11 +9991,13 @@ qualify_ambiguous_name (id)\n \n   /* If within the class/interface NAME was found to be used there\n      exists a (possibly inherited) field named NAME, then this is an\n-     expression name. */\n-  else if ((decl = lookup_field_wrapper (ptr_type, name)))\n+     expression name. If we saw a NEW_ARRAY_EXPR before and want to\n+     address length, it is OK. */\n+  else if ((decl = lookup_field_wrapper (ptr_type, name))\n+\t   || (new_array_found && name == length_identifier_node))\n     {\n       RESOLVE_EXPRESSION_NAME_P (qual_wfl) = 1;\n-      QUAL_RESOLUTION (qual) = decl;\n+      QUAL_RESOLUTION (qual) = (new_array_found ? NULL_TREE : decl);\n     }\n \n   /* We reclassify NAME as a type name if:\n@@ -11601,7 +11612,7 @@ patch_binop (node, wfl_op1, wfl_op2)\n \t{\n           tree utype = unsigned_type (prom_type);\n           op1 = convert (utype, op1);\n-\t  TREE_SET_CODE (node, RSHIFT_EXPR);\n+          TREE_SET_CODE (node, RSHIFT_EXPR);\n           TREE_OPERAND (node, 0) = op1;\n           TREE_OPERAND (node, 1) = op2;\n           TREE_TYPE (node) = utype;\n@@ -13471,7 +13482,7 @@ patch_synchronized_statement (node, wfl_op1)\n   tree expr = java_complete_tree (TREE_OPERAND (node, 0));\n   tree block = TREE_OPERAND (node, 1);\n \n-  tree enter, exit, finally, expr_decl, assignment;\n+  tree enter, exit, expr_decl, assignment;\n \n   if (expr == error_mark_node)\n     {"}, {"sha": "7bc1106c0e9118cab97ff272c4169a6469200ea9", "filename": "gcc/java/parse.y", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8fccff5e042cba03f1256ba0274528894a277be/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8fccff5e042cba03f1256ba0274528894a277be/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=d8fccff5e042cba03f1256ba0274528894a277be", "patch": "@@ -4113,7 +4113,6 @@ do_resolve_class (class_type, decl, cl)\n      tree cl;\n {\n   tree new_class_decl;\n-  tree new_name;\n   tree original_name = NULL_TREE;\n \n   /* Do not try to replace TYPE_NAME (class_type) by a variable, since\n@@ -4957,7 +4956,7 @@ read_import_dir (wfl)\n   char *package_name = IDENTIFIER_POINTER (package_id);\n   int package_length = IDENTIFIER_LENGTH (package_id);\n   DIR *dirp = NULL;\n-  JCF jcfr, *jcf, *saved_jcf = current_jcf;\n+  JCF *saved_jcf = current_jcf;\n \n   int found = 0;\n   int k;\n@@ -5028,7 +5027,6 @@ read_import_dir (wfl)\n \t  *filename->ptr++ = '/';\n \t  for (;;)\n \t    {\n-\t      int java_or_class = 0;\n \t      int len; \n \t      char *d_name;\n \t      struct dirent *direntp = readdir (dirp);\n@@ -6210,6 +6208,14 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t    }\n \t  continue;\n \n+\tcase NEW_ARRAY_EXPR:\n+\t  *where_found = decl = java_complete_tree (qual_wfl);\n+\t  if (decl == error_mark_node)\n+\t    return 1;\n+\t  *type_found = type = QUAL_DECL_TYPE (decl);\n+\t  CLASS_LOADED_P (type) = 1;\n+\t  continue;\n+\n \tcase CONVERT_EXPR:\n \t  *where_found = decl = java_complete_tree (qual_wfl);\n \t  if (decl == error_mark_node)\n@@ -7251,7 +7257,7 @@ qualify_ambiguous_name (id)\n      tree id;\n {\n   tree qual, qual_wfl, name, decl, ptr_type, saved_current_class;\n-  int again, super_found = 0, this_found = 0;\n+  int again, super_found = 0, this_found = 0, new_array_found = 0;\n \n   /* We first qualify the first element, then derive qualification of\n      others based on the first one. If the first element is qualified\n@@ -7279,6 +7285,10 @@ qualify_ambiguous_name (id)\n \t    qual_wfl = QUAL_WFL (qual);\n \t  }\n \tbreak;\n+      case NEW_ARRAY_EXPR:\n+\tqual = TREE_CHAIN (qual);\n+\tnew_array_found = again = 1;\n+\tcontinue;\n       case NEW_CLASS_EXPR:\n       case CONVERT_EXPR:\n \tqual_wfl = TREE_OPERAND (qual_wfl, 0);\n@@ -7335,7 +7345,6 @@ qualify_ambiguous_name (id)\n      declaration or parameter declaration, then it is an expression\n      name. We don't carry this test out if we're in the context of the\n      use of SUPER or THIS */\n-\n   if (!this_found && !super_found && (decl = IDENTIFIER_LOCAL_VALUE (name)))\n     {\n       RESOLVE_EXPRESSION_NAME_P (qual_wfl) = 1;\n@@ -7344,11 +7353,13 @@ qualify_ambiguous_name (id)\n \n   /* If within the class/interface NAME was found to be used there\n      exists a (possibly inherited) field named NAME, then this is an\n-     expression name. */\n-  else if ((decl = lookup_field_wrapper (ptr_type, name)))\n+     expression name. If we saw a NEW_ARRAY_EXPR before and want to\n+     address length, it is OK. */\n+  else if ((decl = lookup_field_wrapper (ptr_type, name))\n+\t   || (new_array_found && name == length_identifier_node))\n     {\n       RESOLVE_EXPRESSION_NAME_P (qual_wfl) = 1;\n-      QUAL_RESOLUTION (qual) = decl;\n+      QUAL_RESOLUTION (qual) = (new_array_found ? NULL_TREE : decl);\n     }\n \n   /* We reclassify NAME as a type name if:\n@@ -10833,7 +10844,7 @@ patch_synchronized_statement (node, wfl_op1)\n   tree expr = java_complete_tree (TREE_OPERAND (node, 0));\n   tree block = TREE_OPERAND (node, 1);\n \n-  tree enter, exit, finally, expr_decl, assignment;\n+  tree enter, exit, expr_decl, assignment;\n \n   if (expr == error_mark_node)\n     {"}]}