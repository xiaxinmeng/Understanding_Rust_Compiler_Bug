{"sha": "0982acbe282ded53440acdc8b6475f5bc5fb6a9d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDk4MmFjYmUyODJkZWQ1MzQ0MGFjZGM4YjY0NzVmNWJjNWZiNmE5ZA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-07-25T10:25:13Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-07-25T10:25:13Z"}, "message": "gimple-loop-versioning.cc (loop_versioning::prune_loop_conditions): Make value_range * temporary const.\n\n2019-07-25  Richard Biener  <rguenther@suse.de>\n\n\t* gimple-loop-versioning.cc (loop_versioning::prune_loop_conditions):\n\tMake value_range * temporary const.\n\t* gimple-ssa-evrp-analyze.c (evrp_range_analyzer::try_find_new_range):\n\tLikewise.\n\t(evrp_range_analyzer::record_ranges_from_): Likewise.\n\t(evrp_range_analyzer::pop_value_range): Return a const value_range *,\n\tdeal with having recorded a const one.\n\t* gimple-ssa-evrp-analyze.h (evrp_range_analyzer::get_value_range):\n\tReturn a const value_range *.\n\t(evrp_range_analyzer::pop_value_range): Likewise.\n\t(evrp_range_analyzer::stack): Record const value_range *s.\n\t* gimple-ssa-evrp.c (evrp_dom_walker::before_dom_children):\n\tAdjust.\n\t* gimple-ssa-sprintf.c (get_int_range): Likewise.\n\t(format_integer): Likewise.\n\t(sprintf_dom_walker::handle_gimple_call): Likewise.\n\t* tree-ssa-dom.c (simplify_stmt_for_jump_threading): Likewise.\n\t* tree-vrp.c (vrp_prop::set_def_to_varying): Add.\n\t(vrp_prop::get_value_range): Adjust.\n\t(vrp_prop::vrp_initialize): Use set_def_to_varying instead of\n\tmodifying the lattice in-place.\n\t(vrp_prop::visit_stmt): Likewise.\n\t* vr-values.c (vr_values::get_lattice_entry): New private method.\n\t(vr_values::get_value_range): Wrap it and return a const\n\tvalue_range *.\n\t(vr_values::set_def_to_varying): New.\n\t(vr_values::set_defs_to_varying): Use it.\n\t(vr_values::update_value_range): Likewise.\n\t(vr_values::vrp_stmt_computes_nonzero): Adjust.\n\t(values::op_with_constant_singleton_va): Likewise.\n\t(vr_values::extract_range_for_var_from_co): Likewise.\n\t(vr_values::extract_range_from_ssa_name): Likewise.\n\t(vr_values::extract_range_from_cond_expr): Likewise.\n\t(vr_values::extract_range_basic): Likewise.\n\t(compare_ranges): Take const value_range *, adjust.\n\t(compare_range_with_value): Likewise.\n\t(vrp_valueize): Adjust.\n\t(vrp_valueize_1): Likewise.\n\t(vr_values::get_vr_for_comparison): Return a const value_range *.\n\t(vr_values::compare_name_with_value): Adjust.\n\t(vr_values::compare_names): Likewise.\n\t(vr_values::vrp_evaluate_conditional_warnv_with_ops_using_ranges):\n\tLikewise.\n\t(vr_values::vrp_evaluate_conditional): Likewise.\n\t(find_case_label_ranges): Take a const value_range *.\n\t(vr_values::vrp_visit_switch_stmt): Adjust.\n\t(vr_values::extract_range_from_phi_node): Likewise.\n\t(vr_values::simplify_div_or_mod_using_ran): Likewise.\n\t(vr_values::simplify_abs_using_ranges): Likewise.\n\t(test_for_singularity): Take a const value_range *.\n\t(range_fits_type_p): Likewise.\n\t(vr_values::simplify_cond_using_ranges_1): Adjust.\n\t(vr_values::simplify_cond_using_ranges_2): Likewise.\n\t(vr_values::simplify_switch_using_ranges): Likewise.\n\t(vr_values::simplify_float_conversion_usi): Likewise.\n\t(vr_values::two_valued_val_range_p): Likewise.\n\t* vr-values.h (vr_values::get_value_range): Return a const\n\tvalue_range *.\n\t(vr_values::set_def_to_varying): New.\n\t(vr_values::get_lattice_entry): New private method.\n\t(vr_values::get_vr_for_comparison): Return a const value_range *.\n\nFrom-SVN: r273792", "tree": {"sha": "e98a4253b12caeaedbf13c58899150ac13e26a16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e98a4253b12caeaedbf13c58899150ac13e26a16"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0982acbe282ded53440acdc8b6475f5bc5fb6a9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0982acbe282ded53440acdc8b6475f5bc5fb6a9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0982acbe282ded53440acdc8b6475f5bc5fb6a9d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0982acbe282ded53440acdc8b6475f5bc5fb6a9d/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6343b6bf3bb83c87cfc80eb32400b45bebd571e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6343b6bf3bb83c87cfc80eb32400b45bebd571e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6343b6bf3bb83c87cfc80eb32400b45bebd571e0"}], "stats": {"total": 261, "additions": 174, "deletions": 87}, "files": [{"sha": "26f60f240d08942e8e1b50bc09a51c85b25b2980", "filename": "gcc/ChangeLog", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0982acbe282ded53440acdc8b6475f5bc5fb6a9d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0982acbe282ded53440acdc8b6475f5bc5fb6a9d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0982acbe282ded53440acdc8b6475f5bc5fb6a9d", "patch": "@@ -1,3 +1,67 @@\n+2019-07-25  Richard Biener  <rguenther@suse.de>\n+\n+\t* gimple-loop-versioning.cc (loop_versioning::prune_loop_conditions):\n+\tMake value_range * temporary const.\n+\t* gimple-ssa-evrp-analyze.c (evrp_range_analyzer::try_find_new_range):\n+\tLikewise.\n+\t(evrp_range_analyzer::record_ranges_from_): Likewise.\n+\t(evrp_range_analyzer::pop_value_range): Return a const value_range *,\n+\tdeal with having recorded a const one.\n+\t* gimple-ssa-evrp-analyze.h (evrp_range_analyzer::get_value_range):\n+\tReturn a const value_range *.\n+\t(evrp_range_analyzer::pop_value_range): Likewise.\n+\t(evrp_range_analyzer::stack): Record const value_range *s.\n+\t* gimple-ssa-evrp.c (evrp_dom_walker::before_dom_children):\n+\tAdjust.\n+\t* gimple-ssa-sprintf.c (get_int_range): Likewise.\n+\t(format_integer): Likewise.\n+\t(sprintf_dom_walker::handle_gimple_call): Likewise.\n+\t* tree-ssa-dom.c (simplify_stmt_for_jump_threading): Likewise.\n+\t* tree-vrp.c (vrp_prop::set_def_to_varying): Add.\n+\t(vrp_prop::get_value_range): Adjust.\n+\t(vrp_prop::vrp_initialize): Use set_def_to_varying instead of\n+\tmodifying the lattice in-place.\n+\t(vrp_prop::visit_stmt): Likewise.\n+\t* vr-values.c (vr_values::get_lattice_entry): New private method.\n+\t(vr_values::get_value_range): Wrap it and return a const\n+\tvalue_range *.\n+\t(vr_values::set_def_to_varying): New.\n+\t(vr_values::set_defs_to_varying): Use it.\n+\t(vr_values::update_value_range): Likewise.\n+\t(vr_values::vrp_stmt_computes_nonzero): Adjust.\n+\t(values::op_with_constant_singleton_va): Likewise.\n+\t(vr_values::extract_range_for_var_from_co): Likewise.\n+\t(vr_values::extract_range_from_ssa_name): Likewise.\n+\t(vr_values::extract_range_from_cond_expr): Likewise.\n+\t(vr_values::extract_range_basic): Likewise.\n+\t(compare_ranges): Take const value_range *, adjust.\n+\t(compare_range_with_value): Likewise.\n+\t(vrp_valueize): Adjust.\n+\t(vrp_valueize_1): Likewise.\n+\t(vr_values::get_vr_for_comparison): Return a const value_range *.\n+\t(vr_values::compare_name_with_value): Adjust.\n+\t(vr_values::compare_names): Likewise.\n+\t(vr_values::vrp_evaluate_conditional_warnv_with_ops_using_ranges):\n+\tLikewise.\n+\t(vr_values::vrp_evaluate_conditional): Likewise.\n+\t(find_case_label_ranges): Take a const value_range *.\n+\t(vr_values::vrp_visit_switch_stmt): Adjust.\n+\t(vr_values::extract_range_from_phi_node): Likewise.\n+\t(vr_values::simplify_div_or_mod_using_ran): Likewise.\n+\t(vr_values::simplify_abs_using_ranges): Likewise.\n+\t(test_for_singularity): Take a const value_range *.\n+\t(range_fits_type_p): Likewise.\n+\t(vr_values::simplify_cond_using_ranges_1): Adjust.\n+\t(vr_values::simplify_cond_using_ranges_2): Likewise.\n+\t(vr_values::simplify_switch_using_ranges): Likewise.\n+\t(vr_values::simplify_float_conversion_usi): Likewise.\n+\t(vr_values::two_valued_val_range_p): Likewise.\n+\t* vr-values.h (vr_values::get_value_range): Return a const\n+\tvalue_range *.\n+\t(vr_values::set_def_to_varying): New.\n+\t(vr_values::get_lattice_entry): New private method.\n+\t(vr_values::get_vr_for_comparison): Return a const value_range *.\n+\n 2019-07-25  Martin Liska  <mliska@suse.cz>\n \t    Dominik Infuhr  <dominik.infuehr@theobroma-systems.com>\n "}, {"sha": "8fa194884909458a579cc1cbcfb312e7f08f713b", "filename": "gcc/gimple-loop-versioning.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0982acbe282ded53440acdc8b6475f5bc5fb6a9d/gcc%2Fgimple-loop-versioning.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0982acbe282ded53440acdc8b6475f5bc5fb6a9d/gcc%2Fgimple-loop-versioning.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-loop-versioning.cc?ref=0982acbe282ded53440acdc8b6475f5bc5fb6a9d", "patch": "@@ -1489,7 +1489,7 @@ loop_versioning::prune_loop_conditions (class loop *loop, vr_values *vrs)\n   EXECUTE_IF_SET_IN_BITMAP (&li.unity_names, 0, i, bi)\n     {\n       tree name = ssa_name (i);\n-      value_range *vr = vrs->get_value_range (name);\n+      const value_range *vr = vrs->get_value_range (name);\n       if (vr && !vr->may_contain_p (build_one_cst (TREE_TYPE (name))))\n \t{\n \t  if (dump_enabled_p ())"}, {"sha": "3f813ba3cfe4f003b4addd391615a34775480a43", "filename": "gcc/gimple-ssa-evrp-analyze.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0982acbe282ded53440acdc8b6475f5bc5fb6a9d/gcc%2Fgimple-ssa-evrp-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0982acbe282ded53440acdc8b6475f5bc5fb6a9d/gcc%2Fgimple-ssa-evrp-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-evrp-analyze.c?ref=0982acbe282ded53440acdc8b6475f5bc5fb6a9d", "patch": "@@ -84,7 +84,7 @@ evrp_range_analyzer::try_find_new_range (tree name,\n \t\t\t\t    tree op, tree_code code, tree limit)\n {\n   value_range vr;\n-  value_range *old_vr = get_value_range (name);\n+  const value_range *old_vr = get_value_range (name);\n \n   /* Discover VR when condition is true.  */\n   vr_values->extract_range_for_var_from_comparison_expr (name, code, op,\n@@ -209,7 +209,7 @@ evrp_range_analyzer::record_ranges_from_incoming_edge (basic_block bb)\n \t      /* But make sure we do not weaken ranges like when\n \t         getting first [64, +INF] and then ~[0, 0] from\n \t\t conditions like (s & 0x3cc0) == 0).  */\n-\t      value_range *old_vr = get_value_range (vrs[i].first);\n+\t      const value_range *old_vr = get_value_range (vrs[i].first);\n \t      value_range_base tem (old_vr->kind (), old_vr->min (),\n \t\t\t\t    old_vr->max ());\n \t      tem.intersect (vrs[i].second);\n@@ -427,10 +427,10 @@ evrp_range_analyzer::push_value_range (tree var, value_range *vr)\n \n /* Pop the Value Range from the vrp_stack and update VAR with it.  */\n \n-value_range *\n+const value_range *\n evrp_range_analyzer::pop_value_range (tree var)\n {\n-  value_range *vr = stack.last ().second;\n+  const value_range *vr = stack.last ().second;\n   gcc_checking_assert (var == stack.last ().first);\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -440,7 +440,9 @@ evrp_range_analyzer::pop_value_range (tree var)\n       dump_value_range (dump_file, vr);\n       fprintf (dump_file, \"\\n\");\n     }\n-  vr_values->set_vr_value (var, vr);\n+  /* We saved off a lattice entry, now give it back - it can now\n+     be modified again, thus the const casting.  */\n+  vr_values->set_vr_value (var, const_cast <value_range *> (vr));\n   stack.pop ();\n   return vr;\n }"}, {"sha": "d252a2812c8f636b701116b4f8f26d1bcb258afc", "filename": "gcc/gimple-ssa-evrp-analyze.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0982acbe282ded53440acdc8b6475f5bc5fb6a9d/gcc%2Fgimple-ssa-evrp-analyze.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0982acbe282ded53440acdc8b6475f5bc5fb6a9d/gcc%2Fgimple-ssa-evrp-analyze.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-evrp-analyze.h?ref=0982acbe282ded53440acdc8b6475f5bc5fb6a9d", "patch": "@@ -37,7 +37,7 @@ class evrp_range_analyzer\n   void record_ranges_from_stmt (gimple *, bool);\n \n   /* Main interface to retrieve range information.  */\n-  value_range *get_value_range (const_tree op)\n+  const value_range *get_value_range (const_tree op)\n     { return vr_values->get_value_range (op); }\n \n   /* Record a new unwindable range.  */\n@@ -62,14 +62,14 @@ class evrp_range_analyzer\n   DISABLE_COPY_AND_ASSIGN (evrp_range_analyzer);\n   class vr_values *vr_values;\n \n-  value_range *pop_value_range (tree var);\n+  const value_range *pop_value_range (tree var);\n   value_range *try_find_new_range (tree, tree op, tree_code code, tree limit);\n   void record_ranges_from_incoming_edge (basic_block);\n   void record_ranges_from_phis (basic_block);\n   void set_ssa_range_info (tree, value_range *);\n \n   /* STACK holds the old VR.  */\n-  auto_vec<std::pair <tree, value_range*> > stack;\n+  auto_vec<std::pair <tree, const value_range*> > stack;\n \n   /* True if we are updating global ranges, false otherwise.  */\n   bool m_update_global_ranges;"}, {"sha": "c4ac13736a59cde156f250f61eb16e6a19cf2b6c", "filename": "gcc/gimple-ssa-evrp.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0982acbe282ded53440acdc8b6475f5bc5fb6a9d/gcc%2Fgimple-ssa-evrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0982acbe282ded53440acdc8b6475f5bc5fb6a9d/gcc%2Fgimple-ssa-evrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-evrp.c?ref=0982acbe282ded53440acdc8b6475f5bc5fb6a9d", "patch": "@@ -109,7 +109,7 @@ evrp_dom_walker::before_dom_children (basic_block bb)\n       if (virtual_operand_p (lhs))\n \tcontinue;\n \n-      value_range *vr = evrp_range_analyzer.get_value_range (lhs);\n+      const value_range *vr = evrp_range_analyzer.get_value_range (lhs);\n       /* Mark PHIs whose lhs we fully propagate for removal.  */\n       tree val;\n       if (vr->singleton_p (&val) && may_propagate_copy (lhs, val))\n@@ -159,7 +159,8 @@ evrp_dom_walker::before_dom_children (basic_block bb)\n \t  if (output)\n \t    {\n \t      tree val;\n-\t      value_range *vr = evrp_range_analyzer.get_value_range (output);\n+\t      const value_range *vr\n+\t\t= evrp_range_analyzer.get_value_range (output);\n \n \t      /* Mark stmts whose output we fully propagate for removal.  */\n \t      if (vr->singleton_p (&val)\n@@ -243,7 +244,7 @@ evrp_dom_walker::before_dom_children (basic_block bb)\n \t  if (TREE_CODE (arg) != SSA_NAME\n \t      || virtual_operand_p (arg))\n \t    continue;\n-\t  value_range *vr = evrp_range_analyzer.get_value_range (arg);\n+\t  const value_range *vr = evrp_range_analyzer.get_value_range (arg);\n \t  tree val;\n \t  if (vr->singleton_p (&val) && may_propagate_copy (arg, val))\n \t    propagate_value (use_p, val);"}, {"sha": "88ba1f2cac1690aa77de8cee3c41432bd68200dc", "filename": "gcc/gimple-ssa-sprintf.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0982acbe282ded53440acdc8b6475f5bc5fb6a9d/gcc%2Fgimple-ssa-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0982acbe282ded53440acdc8b6475f5bc5fb6a9d/gcc%2Fgimple-ssa-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-sprintf.c?ref=0982acbe282ded53440acdc8b6475f5bc5fb6a9d", "patch": "@@ -1086,7 +1086,7 @@ get_int_range (tree arg, HOST_WIDE_INT *pmin, HOST_WIDE_INT *pmax,\n \t  && TYPE_PRECISION (argtype) <= TYPE_PRECISION (type))\n \t{\n \t  /* Try to determine the range of values of the integer argument.  */\n-\t  value_range *vr = vr_values->get_value_range (arg);\n+\t  const value_range *vr = vr_values->get_value_range (arg);\n \t  if (range_int_cst_p (vr))\n \t    {\n \t      HOST_WIDE_INT type_min\n@@ -1386,7 +1386,7 @@ format_integer (const directive &dir, tree arg, vr_values *vr_values)\n     {\n       /* Try to determine the range of values of the integer argument\n \t (range information is not available for pointers).  */\n-      value_range *vr = vr_values->get_value_range (arg);\n+      const value_range *vr = vr_values->get_value_range (arg);\n       if (range_int_cst_p (vr))\n \t{\n \t  argmin = vr->min ();\n@@ -4119,7 +4119,7 @@ sprintf_dom_walker::handle_gimple_call (gimple_stmt_iterator *gsi)\n \t  /* Try to determine the range of values of the argument\n \t     and use the greater of the two at level 1 and the smaller\n \t     of them at level 2.  */\n-\t  value_range *vr = evrp_range_analyzer.get_value_range (size);\n+\t  const value_range *vr = evrp_range_analyzer.get_value_range (size);\n \t  if (range_int_cst_p (vr))\n \t    {\n \t      unsigned HOST_WIDE_INT minsize = TREE_INT_CST_LOW (vr->min ());"}, {"sha": "bcb5cf4f01f84e00bf4c037b5d40bea139a22ce1", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0982acbe282ded53440acdc8b6475f5bc5fb6a9d/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0982acbe282ded53440acdc8b6475f5bc5fb6a9d/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=0982acbe282ded53440acdc8b6475f5bc5fb6a9d", "patch": "@@ -901,7 +901,7 @@ simplify_stmt_for_jump_threading (gimple *stmt,\n       if (TREE_CODE (op) != SSA_NAME)\n \treturn NULL_TREE;\n \n-      value_range *vr = x_vr_values->get_value_range (op);\n+      const value_range *vr = x_vr_values->get_value_range (op);\n       if (vr->undefined_p ()\n \t  || vr->varying_p ()\n \t  || vr->symbolic_p ())"}, {"sha": "add6ad54bc8e035d056acb713d1b7ad9afc8ef26", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0982acbe282ded53440acdc8b6475f5bc5fb6a9d/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0982acbe282ded53440acdc8b6475f5bc5fb6a9d/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=0982acbe282ded53440acdc8b6475f5bc5fb6a9d", "patch": "@@ -4292,10 +4292,12 @@ class vrp_prop : public ssa_propagation_engine\n \n   class vr_values vr_values;\n   /* Temporary delegator to minimize code churn.  */\n-  value_range *get_value_range (const_tree op)\n+  const value_range *get_value_range (const_tree op)\n     { return vr_values.get_value_range (op); }\n+  void set_def_to_varying (const_tree def)\n+    { vr_values.set_def_to_varying (def); }\n   void set_defs_to_varying (gimple *stmt)\n-    { return vr_values.set_defs_to_varying (stmt); }\n+    { vr_values.set_defs_to_varying (stmt); }\n   void extract_range_from_stmt (gimple *stmt, edge *taken_edge_p,\n \t\t\t\ttree *output_p, value_range *vr)\n     { vr_values.extract_range_from_stmt (stmt, taken_edge_p, output_p, vr); }\n@@ -5148,7 +5150,7 @@ vrp_prop::vrp_initialize ()\n \t  if (!stmt_interesting_for_vrp (phi))\n \t    {\n \t      tree lhs = PHI_RESULT (phi);\n-\t      get_value_range (lhs)->set_varying ();\n+\t      set_def_to_varying (lhs);\n \t      prop_set_simulate_again (phi, false);\n \t    }\n \t  else\n@@ -5343,7 +5345,7 @@ vrp_prop::visit_stmt (gimple *stmt, edge *taken_edge_p, tree *output_p)\n \t    use_operand_p use_p;\n \t    enum ssa_prop_result res = SSA_PROP_VARYING;\n \n-\t    get_value_range (lhs)->set_varying ();\n+\t    set_def_to_varying (lhs);\n \n \t    FOR_EACH_IMM_USE_FAST (use_p, iter, lhs)\n \t      {"}, {"sha": "d6a8847369c9f0026627151872d6e94773995307", "filename": "gcc/vr-values.c", "status": "modified", "additions": 81, "deletions": 65, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0982acbe282ded53440acdc8b6475f5bc5fb6a9d/gcc%2Fvr-values.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0982acbe282ded53440acdc8b6475f5bc5fb6a9d/gcc%2Fvr-values.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.c?ref=0982acbe282ded53440acdc8b6475f5bc5fb6a9d", "patch": "@@ -69,37 +69,29 @@ set_value_range_to_truthvalue (value_range *vr, tree type)\n     vr->update (VR_RANGE, build_int_cst (type, 0), build_int_cst (type, 1));\n }\n \n-\n-/* Return value range information for VAR.\n-\n-   If we have no values ranges recorded (ie, VRP is not running), then\n-   return NULL.  Otherwise create an empty range if none existed for VAR.  */\n+/* Return the lattice entry for VAR or NULL if it doesn't exist or cannot\n+   be initialized.  */\n \n value_range *\n-vr_values::get_value_range (const_tree var)\n+vr_values::get_lattice_entry (const_tree var)\n {\n-  static const value_range vr_const_varying (VR_VARYING, NULL, NULL);\n   value_range *vr;\n   tree sym;\n   unsigned ver = SSA_NAME_VERSION (var);\n \n-  /* If we have no recorded ranges, then return NULL.  */\n-  if (! vr_value)\n-    return NULL;\n-\n-  /* If we query the range for a new SSA name return an unmodifiable VARYING.\n-     We should get here at most from the substitute-and-fold stage which\n+  /* If we query the entry for a new SSA name avoid reallocating the lattice\n+     since we should get here at most from the substitute-and-fold stage which\n      will never try to change values.  */\n   if (ver >= num_vr_values)\n-    return CONST_CAST (value_range *, &vr_const_varying);\n+    return NULL;\n \n   vr = vr_value[ver];\n   if (vr)\n     return vr;\n \n   /* After propagation finished do not allocate new value-ranges.  */\n   if (values_propagated)\n-    return CONST_CAST (value_range *, &vr_const_varying);\n+    return NULL;\n \n   /* Create a default value range.  */\n   vr_value[ver] = vr = vrp_value_range_pool.allocate ();\n@@ -142,6 +134,37 @@ vr_values::get_value_range (const_tree var)\n   return vr;\n }\n \n+/* Return value range information for VAR.\n+\n+   If we have no values ranges recorded (ie, VRP is not running), then\n+   return NULL.  Otherwise create an empty range if none existed for VAR.  */\n+\n+const value_range *\n+vr_values::get_value_range (const_tree var)\n+{\n+  static const value_range vr_const_varying (VR_VARYING, NULL, NULL);\n+\n+  /* If we have no recorded ranges, then return NULL.  */\n+  if (!vr_value)\n+    return NULL;\n+\n+  value_range *vr = get_lattice_entry (var);\n+  if (!vr)\n+    return &vr_const_varying;\n+\n+  return vr;\n+}\n+\n+/* Set the lattice entry for DEF to VARYING.  */\n+\n+void\n+vr_values::set_def_to_varying (const_tree def)\n+{\n+  value_range *vr = get_lattice_entry (def);\n+  if (vr)\n+    vr->set_varying ();\n+}\n+\n /* Set value-ranges of all SSA names defined by STMT to varying.  */\n \n void\n@@ -150,12 +173,7 @@ vr_values::set_defs_to_varying (gimple *stmt)\n   ssa_op_iter i;\n   tree def;\n   FOR_EACH_SSA_TREE_OPERAND (def, stmt, i, SSA_OP_DEF)\n-    {\n-      value_range *vr = get_value_range (def);\n-      /* Avoid writing to vr_const_varying get_value_range may return.  */\n-      if (!vr->varying_p ())\n-\tvr->set_varying ();\n-    }\n+    set_def_to_varying (def);\n }\n \n /* Update the value range and equivalence set for variable VAR to\n@@ -185,7 +203,7 @@ vr_values::update_value_range (const_tree var, value_range *new_vr)\n     }\n \n   /* Update the value range, if necessary.  */\n-  old_vr = get_value_range (var);\n+  old_vr = get_lattice_entry (var);\n   is_new = !old_vr->equal_p (*new_vr, /*ignore_equivs=*/false);\n \n   if (is_new)\n@@ -339,7 +357,7 @@ vr_values::vrp_stmt_computes_nonzero (gimple *stmt)\n \t      || (flag_delete_null_pointer_checks\n \t\t  && !TYPE_OVERFLOW_WRAPS (TREE_TYPE (expr))))\n \t    {\n-\t      value_range *vr = get_value_range (TREE_OPERAND (base, 0));\n+\t      const value_range *vr = get_value_range (TREE_OPERAND (base, 0));\n \t      if (!range_includes_zero_p (vr))\n \t\treturn true;\n \t    }\n@@ -398,7 +416,7 @@ vr_values::op_with_constant_singleton_value_range (tree op)\n bool\n vr_values::op_with_boolean_value_range_p (tree op)\n {\n-  value_range *vr;\n+  const value_range *vr;\n \n   if (TYPE_PRECISION (TREE_TYPE (op)) == 1)\n     return true;\n@@ -426,7 +444,7 @@ vr_values::extract_range_for_var_from_comparison_expr (tree var,\n \t\t\t\t\t\t       value_range *vr_p)\n {\n   tree  min, max, type;\n-  value_range *limit_vr;\n+  const value_range *limit_vr;\n   type = TREE_TYPE (var);\n \n   /* For pointer arithmetic, we only keep track of pointer equality\n@@ -715,7 +733,7 @@ vr_values::extract_range_from_assert (value_range *vr_p, tree expr)\n void\n vr_values::extract_range_from_ssa_name (value_range *vr, tree var)\n {\n-  value_range *var_vr = get_value_range (var);\n+  const value_range *var_vr = get_value_range (var);\n \n   if (!var_vr->varying_p ())\n     vr->deep_copy (var_vr);\n@@ -907,7 +925,7 @@ vr_values::extract_range_from_cond_expr (value_range *vr, gassign *stmt)\n      a new value range with the operand to simplify processing.  */\n   tree op0 = gimple_assign_rhs2 (stmt);\n   value_range tem0;\n-  value_range *vr0 = &tem0;\n+  const value_range *vr0 = &tem0;\n   if (TREE_CODE (op0) == SSA_NAME)\n     vr0 = get_value_range (op0);\n   else if (is_gimple_min_invariant (op0))\n@@ -917,7 +935,7 @@ vr_values::extract_range_from_cond_expr (value_range *vr, gassign *stmt)\n \n   tree op1 = gimple_assign_rhs3 (stmt);\n   value_range tem1;\n-  value_range *vr1 = &tem1;\n+  const value_range *vr1 = &tem1;\n   if (TREE_CODE (op1) == SSA_NAME)\n     vr1 = get_value_range (op1);\n   else if (is_gimple_min_invariant (op1))\n@@ -1113,7 +1131,7 @@ vr_values::extract_range_basic (value_range *vr, gimple *stmt)\n \t  maxi = prec;\n \t  if (TREE_CODE (arg) == SSA_NAME)\n \t    {\n-\t      value_range *vr0 = get_value_range (arg);\n+\t      const value_range *vr0 = get_value_range (arg);\n \t      /* If arg is non-zero, then ffs or popcount are non-zero.  */\n \t      if (range_includes_zero_p (vr0) == 0)\n \t\tmini = 1;\n@@ -1151,7 +1169,7 @@ vr_values::extract_range_basic (value_range *vr, gimple *stmt)\n \t    mini = -2;\n \t  if (TREE_CODE (arg) == SSA_NAME)\n \t    {\n-\t      value_range *vr0 = get_value_range (arg);\n+\t      const value_range *vr0 = get_value_range (arg);\n \t      /* From clz of VR_RANGE minimum we can compute\n \t\t result maximum.  */\n \t      if (vr0->kind () == VR_RANGE\n@@ -1208,7 +1226,7 @@ vr_values::extract_range_basic (value_range *vr, gimple *stmt)\n \t    }\n \t  if (TREE_CODE (arg) == SSA_NAME)\n \t    {\n-\t      value_range *vr0 = get_value_range (arg);\n+\t      const value_range *vr0 = get_value_range (arg);\n \t      /* If arg is non-zero, then use [0, prec - 1].  */\n \t      if ((vr0->kind () == VR_RANGE\n \t\t   && integer_nonzerop (vr0->min ()))\n@@ -1468,8 +1486,8 @@ vr_values::extract_range_from_assignment (value_range *vr, gassign *stmt)\n \n \n static tree\n-compare_ranges (enum tree_code comp, value_range *vr0, value_range *vr1,\n-\t\tbool *strict_overflow_p)\n+compare_ranges (enum tree_code comp, const value_range *vr0,\n+\t\tconst value_range *vr1, bool *strict_overflow_p)\n {\n   /* VARYING or UNDEFINED ranges cannot be compared.  */\n   if (vr0->varying_p ()\n@@ -1496,12 +1514,8 @@ compare_ranges (enum tree_code comp, value_range *vr0, value_range *vr1,\n       /* Equality can be computed only between a range and an\n \t anti-range.  ~[VAL1, VAL2] == [VAL1, VAL2] is always false.  */\n       if (vr0->kind () == VR_RANGE)\n-\t{\n-\t  /* To simplify processing, make VR0 the anti-range.  */\n-\t  value_range *tmp = vr0;\n-\t  vr0 = vr1;\n-\t  vr1 = tmp;\n-\t}\n+\t/* To simplify processing, make VR0 the anti-range.  */\n+\tstd::swap (vr0, vr1);\n \n       gcc_assert (comp == NE_EXPR || comp == EQ_EXPR);\n \n@@ -1607,7 +1621,7 @@ compare_ranges (enum tree_code comp, value_range *vr0, value_range *vr1,\n    assumed signed overflow is undefined.  */\n \n static tree\n-compare_range_with_value (enum tree_code comp, value_range *vr, tree val,\n+compare_range_with_value (enum tree_code comp, const value_range *vr, tree val,\n \t\t\t  bool *strict_overflow_p)\n {\n   if (vr->varying_p () || vr->undefined_p ())\n@@ -1961,7 +1975,7 @@ vrp_valueize (tree name)\n {\n   if (TREE_CODE (name) == SSA_NAME)\n     {\n-      value_range *vr = x_vr_values->get_value_range (name);\n+      const value_range *vr = x_vr_values->get_value_range (name);\n       if (vr->kind () == VR_RANGE\n \t  && (TREE_CODE (vr->min ()) == SSA_NAME\n \t      || is_gimple_min_invariant (vr->min ()))\n@@ -1986,7 +2000,7 @@ vrp_valueize_1 (tree name)\n       if (!gimple_nop_p (def_stmt)\n \t  && prop_simulate_again_p (def_stmt))\n \treturn NULL_TREE;\n-      value_range *vr = x_vr_values->get_value_range (name);\n+      const value_range *vr = x_vr_values->get_value_range (name);\n       tree singleton;\n       if (vr->singleton_p (&singleton))\n \treturn singleton;\n@@ -2064,11 +2078,11 @@ vr_values::vrp_visit_assignment_or_call (gimple *stmt, tree *output_p,\n    or a symbolic range containing the SSA_NAME only if the value range\n    is varying or undefined.  Uses TEM as storage for the alternate range.  */\n \n-value_range *\n+const value_range *\n vr_values::get_vr_for_comparison (int i, value_range *tem)\n {\n   /* Shallow-copy equiv bitmap.  */\n-  value_range *vr = get_value_range (ssa_name (i));\n+  const value_range *vr = get_value_range (ssa_name (i));\n \n   /* If name N_i does not have a valid range, use N_i as its own\n      range.  This allows us to compare against names that may\n@@ -2097,7 +2111,8 @@ vr_values::compare_name_with_value (enum tree_code comp, tree var, tree val,\n   tree retval, t;\n   int used_strict_overflow;\n   bool sop;\n-  value_range *equiv_vr, tem_vr;\n+  const value_range *equiv_vr;\n+  value_range tem_vr;\n \n   /* Get the set of equivalences for VAR.  */\n   e = get_value_range (var)->equiv ();\n@@ -2233,7 +2248,7 @@ vr_values::compare_names (enum tree_code comp, tree n1, tree n2,\n \tcontinue;\n \n       value_range tem_vr1;\n-      value_range *vr1 = get_vr_for_comparison (i1, &tem_vr1);\n+      const value_range *vr1 = get_vr_for_comparison (i1, &tem_vr1);\n \n       t = retval = NULL_TREE;\n       EXECUTE_IF_SET_IN_BITMAP (e2, 0, i2, bi2)\n@@ -2244,7 +2259,7 @@ vr_values::compare_names (enum tree_code comp, tree n1, tree n2,\n \t  bool sop = false;\n \n \t  value_range tem_vr2;\n-\t  value_range *vr2 = get_vr_for_comparison (i2, &tem_vr2);\n+\t  const value_range *vr2 = get_vr_for_comparison (i2, &tem_vr2);\n \n \t  t = compare_ranges (comp, vr1, vr2, &sop);\n \t  if (t)\n@@ -2293,7 +2308,7 @@ tree\n vr_values::vrp_evaluate_conditional_warnv_with_ops_using_ranges\n     (enum tree_code code, tree op0, tree op1, bool * strict_overflow_p)\n {\n-  value_range *vr0, *vr1;\n+  const value_range *vr0, *vr1;\n \n   vr0 = (TREE_CODE (op0) == SSA_NAME) ? get_value_range (op0) : NULL;\n   vr1 = (TREE_CODE (op1) == SSA_NAME) ? get_value_range (op1) : NULL;\n@@ -2373,7 +2388,7 @@ vr_values::vrp_evaluate_conditional_warnv_with_ops (enum tree_code code,\n \t    }\n \t  else\n \t    gcc_unreachable ();\n-\t  value_range *vr0 = get_value_range (op0);\n+\t  const value_range *vr0 = get_value_range (op0);\n \t  /* If vro, the range for OP0 to pass the overflow test, has\n \t     no intersection with *vr0, OP0's known range, then the\n \t     overflow test can't pass, so return the node for false.\n@@ -2479,7 +2494,7 @@ vr_values::vrp_evaluate_conditional (tree_code code, tree op0,\n \t always fold regardless of the value of OP0.  If -Wtype-limits\n \t was specified, emit a warning.  */\n       tree type = TREE_TYPE (op0);\n-      value_range *vr0 = get_value_range (op0);\n+      const value_range *vr0 = get_value_range (op0);\n \n       if (vr0->kind () == VR_RANGE\n \t  && INTEGRAL_TYPE_P (type)\n@@ -2605,7 +2620,7 @@ vr_values::vrp_visit_cond_stmt (gcond *stmt, edge *taken_edge_p)\n    Returns true if the default label is not needed.  */\n \n static bool\n-find_case_label_ranges (gswitch *stmt, value_range *vr, size_t *min_idx1,\n+find_case_label_ranges (gswitch *stmt, const value_range *vr, size_t *min_idx1,\n \t\t\tsize_t *max_idx1, size_t *min_idx2,\n \t\t\tsize_t *max_idx2)\n {\n@@ -2685,7 +2700,7 @@ void\n vr_values::vrp_visit_switch_stmt (gswitch *stmt, edge *taken_edge_p)\n {\n   tree op, val;\n-  value_range *vr;\n+  const value_range *vr;\n   size_t i = 0, j = 0, k, l;\n   bool take_default;\n \n@@ -2803,7 +2818,7 @@ vr_values::extract_range_from_phi_node (gphi *phi, value_range *vr_result)\n {\n   size_t i;\n   tree lhs = PHI_RESULT (phi);\n-  value_range *lhs_vr = get_value_range (lhs);\n+  const value_range *lhs_vr = get_value_range (lhs);\n   bool first = true;\n   int edges, old_edges;\n   class loop *l;\n@@ -2832,7 +2847,7 @@ vr_values::extract_range_from_phi_node (gphi *phi, value_range *vr_result)\n \t{\n \t  tree arg = PHI_ARG_DEF (phi, i);\n \t  value_range vr_arg_tem;\n-\t  value_range *vr_arg = &vr_arg_tem;\n+\t  const value_range *vr_arg = &vr_arg_tem;\n \n \t  ++edges;\n \n@@ -2845,7 +2860,7 @@ vr_values::extract_range_from_phi_node (gphi *phi, value_range *vr_result)\n \t\t  && e->flags & EDGE_DFS_BACK)\n \t\tmay_simulate_backedge_again = true;\n \n-\t      value_range *vr_arg_ = get_value_range (arg);\n+\t      const value_range *vr_arg_ = get_value_range (arg);\n \t      /* Do not allow equivalences or symbolic ranges to leak in from\n \t\t backedges.  That creates invalid equivalencies.\n \t\t See PR53465 and PR54767.  */\n@@ -3096,7 +3111,7 @@ vr_values::simplify_div_or_mod_using_ranges (gimple_stmt_iterator *gsi,\n   tree op1 = gimple_assign_rhs2 (stmt);\n   tree op0min = NULL_TREE, op0max = NULL_TREE;\n   tree op1min = op1;\n-  value_range *vr = NULL;\n+  const value_range *vr = NULL;\n \n   if (TREE_CODE (op0) == INTEGER_CST)\n     {\n@@ -3116,7 +3131,7 @@ vr_values::simplify_div_or_mod_using_ranges (gimple_stmt_iterator *gsi,\n   if (rhs_code == TRUNC_MOD_EXPR\n       && TREE_CODE (op1) == SSA_NAME)\n     {\n-      value_range *vr1 = get_value_range (op1);\n+      const value_range *vr1 = get_value_range (op1);\n       if (range_int_cst_p (vr1))\n \top1min = vr1->min ();\n     }\n@@ -3263,7 +3278,7 @@ bool\n vr_values::simplify_abs_using_ranges (gimple_stmt_iterator *gsi, gimple *stmt)\n {\n   tree op = gimple_assign_rhs1 (stmt);\n-  value_range *vr = get_value_range (op);\n+  const value_range *vr = get_value_range (op);\n \n   if (vr)\n     {\n@@ -3401,7 +3416,7 @@ vr_values::simplify_bit_ops_using_ranges (gimple_stmt_iterator *gsi,\n \n static tree\n test_for_singularity (enum tree_code cond_code, tree op0,\n-\t\t      tree op1, value_range *vr)\n+\t\t      tree op1, const value_range *vr)\n {\n   tree min = NULL;\n   tree max = NULL;\n@@ -3459,7 +3474,8 @@ test_for_singularity (enum tree_code cond_code, tree op0,\n    by PRECISION and UNSIGNED_P.  */\n \n static bool\n-range_fits_type_p (value_range *vr, unsigned dest_precision, signop dest_sgn)\n+range_fits_type_p (const value_range *vr,\n+\t\t   unsigned dest_precision, signop dest_sgn)\n {\n   tree src_type;\n   unsigned src_precision;\n@@ -3523,7 +3539,7 @@ vr_values::simplify_cond_using_ranges_1 (gcond *stmt)\n       && INTEGRAL_TYPE_P (TREE_TYPE (op0))\n       && is_gimple_min_invariant (op1))\n     {\n-      value_range *vr = get_value_range (op0);\n+      const value_range *vr = get_value_range (op0);\n \n       /* If we have range information for OP0, then we might be\n \t able to simplify this conditional. */\n@@ -3626,7 +3642,7 @@ vr_values::simplify_cond_using_ranges_2 (gcond *stmt)\n \t  && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (innerop)\n \t  && desired_pro_or_demotion_p (TREE_TYPE (innerop), TREE_TYPE (op0)))\n \t{\n-\t  value_range *vr = get_value_range (innerop);\n+\t  const value_range *vr = get_value_range (innerop);\n \n \t  if (range_int_cst_p (vr)\n \t      && range_fits_type_p (vr,\n@@ -3656,7 +3672,7 @@ bool\n vr_values::simplify_switch_using_ranges (gswitch *stmt)\n {\n   tree op = gimple_switch_index (stmt);\n-  value_range *vr = NULL;\n+  const value_range *vr = NULL;\n   bool take_default;\n   edge e;\n   edge_iterator ei;\n@@ -3956,7 +3972,7 @@ vr_values::simplify_float_conversion_using_ranges (gimple_stmt_iterator *gsi,\n \t\t\t\t\t\t   gimple *stmt)\n {\n   tree rhs1 = gimple_assign_rhs1 (stmt);\n-  value_range *vr = get_value_range (rhs1);\n+  const value_range *vr = get_value_range (rhs1);\n   scalar_float_mode fltmode\n     = SCALAR_FLOAT_TYPE_MODE (TREE_TYPE (gimple_assign_lhs (stmt)));\n   scalar_int_mode mode;\n@@ -4119,7 +4135,7 @@ vr_values::simplify_internal_call_using_ranges (gimple_stmt_iterator *gsi,\n bool\n vr_values::two_valued_val_range_p (tree var, tree *a, tree *b)\n {\n-  value_range *vr = get_value_range (var);\n+  const value_range *vr = get_value_range (var);\n   if (vr->varying_p ()\n       || vr->undefined_p ()\n       || TREE_CODE (vr->min ()) != INTEGER_CST"}, {"sha": "c26de2c2d93438bc03d8d501fa17191a3ad0ce47", "filename": "gcc/vr-values.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0982acbe282ded53440acdc8b6475f5bc5fb6a9d/gcc%2Fvr-values.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0982acbe282ded53440acdc8b6475f5bc5fb6a9d/gcc%2Fvr-values.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.h?ref=0982acbe282ded53440acdc8b6475f5bc5fb6a9d", "patch": "@@ -40,9 +40,10 @@ class vr_values\n   vr_values (void);\n   ~vr_values (void);\n \n-  value_range *get_value_range (const_tree);\n+  const value_range *get_value_range (const_tree);\n \n   void set_vr_value (tree, value_range *);\n+  void set_def_to_varying (const_tree);\n   void set_defs_to_varying (gimple *);\n   bool update_value_range (const_tree, value_range *);\n   tree op_with_constant_singleton_value_range (tree);\n@@ -72,10 +73,11 @@ class vr_values\n   void cleanup_edges_and_switches (void);\n \n  private:\n+  value_range *get_lattice_entry (const_tree);\n   bool vrp_stmt_computes_nonzero (gimple *);\n   bool op_with_boolean_value_range_p (tree);\n   bool check_for_binary_op_overflow (enum tree_code, tree, tree, tree, bool *);\n-  value_range *get_vr_for_comparison (int, value_range *);\n+  const value_range *get_vr_for_comparison (int, value_range *);\n   tree compare_name_with_value (enum tree_code, tree, tree, bool *, bool);\n   tree compare_names (enum tree_code, tree, tree, bool *);\n   bool two_valued_val_range_p (tree, tree *, tree *);"}]}