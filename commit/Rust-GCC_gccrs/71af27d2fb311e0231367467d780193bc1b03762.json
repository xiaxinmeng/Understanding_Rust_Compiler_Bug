{"sha": "71af27d2fb311e0231367467d780193bc1b03762", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzFhZjI3ZDJmYjMxMWUwMjMxMzY3NDY3ZDc4MDE5M2JjMWIwMzc2Mg==", "commit": {"author": {"name": "Olivier Hainque", "email": "hainque@gcc.gnu.org", "date": "2010-09-02T07:22:33Z"}, "committer": {"name": "Olivier Hainque", "email": "hainque@gcc.gnu.org", "date": "2010-09-02T07:22:33Z"}, "message": "ira-color.c (SORTGT): New macro, helper for qsort callbacks.\n\n        * ira-color.c (SORTGT): New macro, helper for qsort callbacks.\n        (allocno_priority_compare_func): Use it instead of a straight\n        difference computation over priorities.\n\nFrom-SVN: r163760", "tree": {"sha": "4a3c26d34c537a2a001d76836e75e512b848a275", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4a3c26d34c537a2a001d76836e75e512b848a275"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/71af27d2fb311e0231367467d780193bc1b03762", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71af27d2fb311e0231367467d780193bc1b03762", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71af27d2fb311e0231367467d780193bc1b03762", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71af27d2fb311e0231367467d780193bc1b03762/comments", "author": null, "committer": null, "parents": [{"sha": "e10909ceaf93ae366ee3c70500854a132c088afb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e10909ceaf93ae366ee3c70500854a132c088afb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e10909ceaf93ae366ee3c70500854a132c088afb"}], "stats": {"total": 17, "additions": 15, "deletions": 2}, "files": [{"sha": "04afe92495099502579548fbdd9e2f1bf25ab1fc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71af27d2fb311e0231367467d780193bc1b03762/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71af27d2fb311e0231367467d780193bc1b03762/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=71af27d2fb311e0231367467d780193bc1b03762", "patch": "@@ -1,3 +1,9 @@\n+2010-09-02  Olivier Hainque  <hainque@adacore.com>\n+\n+\t* ira-color.c (SORTGT): New macro, helper for qsort callbacks.\n+\t(allocno_priority_compare_func): Use it instead of a straight\n+\tdifference computation over priorities.\n+\n 2010-09-02  Andi Kleen  <ak@linux.intel.com>\n \n \t* opts.c (common_handle_option): Fix OPT_fwhopr/fwhopr_ handling.\n@@ -170,6 +176,7 @@\n \t(scev_probably_wraps_p): Adjust.\n \t* tree-ssa-loop.c (tree_ssa_loop_bounds): Likewise.\n \n+>>>>>>> .r163759\n 2010-09-01  Nick Clifton  <nickc@redhat.com>\n \n \t* config/stormy16/stormy16.c: Use REG_P, MEM_P and CONST_INT_P"}, {"sha": "7f02bcf45f3a955a153f1d1a1b7634073daf6e51", "filename": "gcc/ira-color.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71af27d2fb311e0231367467d780193bc1b03762/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71af27d2fb311e0231367467d780193bc1b03762/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=71af27d2fb311e0231367467d780193bc1b03762", "patch": "@@ -83,6 +83,12 @@ static alloc_pool splay_tree_node_pool;\n    more costly although simpler.  */\n static VEC(ira_allocno_t,heap) *removed_splay_allocno_vec;\n \n+/* Helper for qsort comparison callbacks - return a positive integer if\n+   X > Y, or a negative value otherwise.  Use a conditional expression\n+   instead of a difference computation to insulate from possible overflow\n+   issues, e.g. X - Y < 0 for some X > 0 and Y < 0.  */\n+#define SORTGT(x,y) (((x) > (y)) ? 1 : -1)\n+\n \f\n \n /* This page contains functions used to find conflicts using allocno\n@@ -1858,8 +1864,8 @@ allocno_priority_compare_func (const void *v1p, const void *v2p)\n \n   pri1 = allocno_priorities[ALLOCNO_NUM (a1)];\n   pri2 = allocno_priorities[ALLOCNO_NUM (a2)];\n-  if (pri2 - pri1)\n-    return pri2 - pri1;\n+  if (pri2 != pri1)\n+    return SORTGT (pri2, pri1);\n \n   /* If regs are equally good, sort by allocnos, so that the results of\n      qsort leave nothing to chance.  */"}]}