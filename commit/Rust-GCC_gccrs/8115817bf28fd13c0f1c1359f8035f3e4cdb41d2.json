{"sha": "8115817bf28fd13c0f1c1359f8035f3e4cdb41d2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODExNTgxN2JmMjhmZDEzYzBmMWMxMzU5ZjgwMzVmM2U0Y2RiNDFkMg==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2007-04-22T18:45:06Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2007-04-22T18:45:06Z"}, "message": "re PR tree-optimization/24659 (Conversions are not vectorized)\n\n2007-04-22  Uros Bizjak  <ubizjak@gmail.com>\n\n        PR tree-optimization/24659\n        * optabs.h (enum optab_index) [OTI_vec_unpacks_hi,\n        OTI_vec_unpacks_lo]: Update comment to mention floating point operands.\n        (vec_pack_trunc_optab): Rename from vec_pack_mod_optab.\n        * genopinit.c (optabs): Rename vec_pack_mod_optab\n        to vec_pack_trunc_optab.\n        * tree-vect-transform.c (vectorizable_type_demotion): Do not fail\n        early for scalar floating point operands for NOP_EXPR.\n        (vectorizable_type_promotion): Ditto.\n        * optabs.c (optab_for_tree_code) [VEC_PACK_TRUNC_EXPR]: Return\n        vec_pack_trunc_optab.\n        (expand_binop): Rename vec_float_trunc_optab to vec_pack_mod_optab.\n\n        * tree.def (VEC_PACK_TRUNC_EXPR): Rename from VEC_PACK_MOD_EXPR.\n        * tree-pretty-print.c (dump_generic_node) [VEC_PACK_TRUNC_EXPR]:\n        Rename from VEC_PACK_MOD_EXPR.\n        (op_prio) [VEC_PACK_TRUNC_EXPR]: Ditto.\n        * expr.c (expand_expr_real_1): Ditto.\n        * tree-inline.c (estimate_num_insns_1): Ditto.\n        * tree-vect-generic.c (expand_vector_operations_1): Ditto.\n\n        * config/i386/sse.md (vec_unpacks_hi_v4sf): New expander.\n        (vec_unpacks_lo_v4sf): Ditto.\n        (vec_pack_trunc_v2df): Ditto.\n        (vec_pack_trunc_v8hi): Rename from vec_pack_mod_v8hi.\n        (vec_pack_trunc_v4si): Rename from vec_pack_mod_v4si.\n        (vec_pack_trunc_v2di): Rename from vec_pack_mod_v2di.\n    \n        * config/rs6000/altivec.md (vec_pack_trunc_v8hi): Rename from\n        vec_pack_mod_v8hi.\n        (vec_pack_trunc_v4si): Rename from vec_pack_mod_v4si.\n\n        * doc/c-tree.texi (Expression trees) [VEC_PACK_TRUNC_EXPR]:\n        Rename from VEC_PACK_MOD_EXPR.  This expression also represent\n        packing of floating point operands.\n        [VEC_UNPACK_HI_EXPR, VEC_UNPACK_LO_EXPR]: These expression also\n        represent unpacking of floating point operands.\n        * doc/md.texi (Standard Names) [vec_pack_trunc]: Update documentation.\n        [vec_unpacks_hi]: Ditto.\n        [vec_unpacks_lo]: Ditto.\n\ntestsuite/ChangeLog:\n\n2007-04-22  Uros Bizjak  <ubizjak@gmail.com>\n\n    PR tree-optimization/24659\n    * gcc.dg/vect/vect-float-extend-1.c: New test.\n    * gcc.dg/vect/vect-float-truncate-1.c: New test.\n\nFrom-SVN: r124045", "tree": {"sha": "ed5f0d41e31a2f26e2f1a5a6ffcee8f2131348a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ed5f0d41e31a2f26e2f1a5a6ffcee8f2131348a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8115817bf28fd13c0f1c1359f8035f3e4cdb41d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8115817bf28fd13c0f1c1359f8035f3e4cdb41d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8115817bf28fd13c0f1c1359f8035f3e4cdb41d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8115817bf28fd13c0f1c1359f8035f3e4cdb41d2/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "395a40e0e28129430ca707dad8475fefad3d8782", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/395a40e0e28129430ca707dad8475fefad3d8782", "html_url": "https://github.com/Rust-GCC/gccrs/commit/395a40e0e28129430ca707dad8475fefad3d8782"}], "stats": {"total": 368, "additions": 245, "deletions": 123}, "files": [{"sha": "b9e35dc6666f43bb977580d0cdc74de081a37ca1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8115817bf28fd13c0f1c1359f8035f3e4cdb41d2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8115817bf28fd13c0f1c1359f8035f3e4cdb41d2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8115817bf28fd13c0f1c1359f8035f3e4cdb41d2", "patch": "@@ -1,3 +1,46 @@\n+2007-04-22  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\tPR tree-optimization/24659\n+\t* optabs.h (enum optab_index) [OTI_vec_unpacks_hi,\n+\tOTI_vec_unpacks_lo]: Update comment to mention floating point operands.\n+\t(vec_pack_trunc_optab): Rename from vec_pack_mod_optab.\n+\t* genopinit.c (optabs): Rename vec_pack_mod_optab\n+\tto vec_pack_trunc_optab.\n+\t* tree-vect-transform.c (vectorizable_type_demotion): Do not fail\n+\tearly for scalar floating point operands for NOP_EXPR.\n+\t(vectorizable_type_promotion): Ditto.\n+\t* optabs.c (optab_for_tree_code) [VEC_PACK_TRUNC_EXPR]: Return\n+\tvec_pack_trunc_optab.\n+\t(expand_binop): Rename vec_float_trunc_optab to vec_pack_mod_optab.\n+\n+\t* tree.def (VEC_PACK_TRUNC_EXPR): Rename from VEC_PACK_MOD_EXPR.\n+\t* tree-pretty-print.c (dump_generic_node) [VEC_PACK_TRUNC_EXPR]:\n+\tRename from VEC_PACK_MOD_EXPR.\n+\t(op_prio) [VEC_PACK_TRUNC_EXPR]: Ditto.\n+\t* expr.c (expand_expr_real_1): Ditto.\n+\t* tree-inline.c (estimate_num_insns_1): Ditto.\n+\t* tree-vect-generic.c (expand_vector_operations_1): Ditto.\n+\n+\t* config/i386/sse.md (vec_unpacks_hi_v4sf): New expander.\n+\t(vec_unpacks_lo_v4sf): Ditto.\n+\t(vec_pack_trunc_v2df): Ditto.\n+\t(vec_pack_trunc_v8hi): Rename from vec_pack_mod_v8hi.\n+\t(vec_pack_trunc_v4si): Rename from vec_pack_mod_v4si.\n+\t(vec_pack_trunc_v2di): Rename from vec_pack_mod_v2di.\n+\n+\t* config/rs6000/altivec.md (vec_pack_trunc_v8hi): Rename from\n+\tvec_pack_mod_v8hi.\n+\t(vec_pack_trunc_v4si): Rename from vec_pack_mod_v4si.\n+\n+\t* doc/c-tree.texi (Expression trees) [VEC_PACK_TRUNC_EXPR]:\n+\tRename from VEC_PACK_MOD_EXPR.  This expression also represent\n+\tpacking of floating point operands.\n+\t[VEC_UNPACK_HI_EXPR, VEC_UNPACK_LO_EXPR]: These expression also\n+\trepresent unpacking of floating point operands.\n+\t* doc/md.texi (Standard Names) [vec_pack_trunc]: Update documentation.\n+\t[vec_unpacks_hi]: Ditto.\n+\t[vec_unpacks_lo]: Ditto.\n+\n 2007-04-22  Jan Hubicka  <jh@suse.cz>\n \n \t* final.c (rest_of_handle_final): Call"}, {"sha": "16219e08aa23c368291d77bf75025581cd5e81d4", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 48, "deletions": 3, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8115817bf28fd13c0f1c1359f8035f3e4cdb41d2/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8115817bf28fd13c0f1c1359f8035f3e4cdb41d2/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=8115817bf28fd13c0f1c1359f8035f3e4cdb41d2", "patch": "@@ -2150,6 +2150,51 @@\n    (set_attr \"mode\" \"V2DF\")\n    (set_attr \"amdfam10_decode\" \"direct\")])\n \n+(define_expand \"vec_unpacks_hi_v4sf\"\n+  [(set (match_dup 2)\n+   (vec_select:V4SF\n+     (vec_concat:V8SF\n+       (match_dup 2)\n+       (match_operand:V4SF 1 \"nonimmediate_operand\" \"\"))\n+     (parallel [(const_int 6)\n+\t\t(const_int 7)\n+\t\t(const_int 2)\n+\t\t(const_int 3)])))\n+  (set (match_operand:V2DF 0 \"register_operand\" \"\")\n+   (float_extend:V2DF\n+     (vec_select:V2SF\n+       (match_dup 2)\n+       (parallel [(const_int 0) (const_int 1)]))))]\n+ \"TARGET_SSE2\"\n+{\n+ operands[2] = gen_reg_rtx (V4SFmode);\n+})\n+\n+(define_expand \"vec_unpacks_lo_v4sf\"\n+  [(set (match_operand:V2DF 0 \"register_operand\" \"\")\n+\t(float_extend:V2DF\n+\t  (vec_select:V2SF\n+\t    (match_operand:V4SF 1 \"nonimmediate_operand\" \"\")\n+\t    (parallel [(const_int 0) (const_int 1)]))))]\n+  \"TARGET_SSE2\")\n+\n+(define_expand \"vec_pack_trunc_v2df\"\n+  [(match_operand:V4SF 0 \"register_operand\" \"\")\n+   (match_operand:V2DF 1 \"nonimmediate_operand\" \"\")\n+   (match_operand:V2DF 2 \"nonimmediate_operand\" \"\")]\n+  \"TARGET_SSE2\"\n+{\n+  rtx r1, r2;\n+\n+  r1 = gen_reg_rtx (V4SFmode);\n+  r2 = gen_reg_rtx (V4SFmode);\n+\n+  emit_insn (gen_sse2_cvtpd2ps (r1, operands[1]));\n+  emit_insn (gen_sse2_cvtpd2ps (r2, operands[2]));\n+  emit_insn (gen_sse_movlhps (operands[0], r1, r2));\n+  DONE;\n+})\n+\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n ;;\n ;; Parallel double-precision floating point element swizzling\n@@ -3420,7 +3465,7 @@\n ;;       h3 = aeimquy2bfjnrvz3\n ;;       l3 = cgkosw04dhlptx15\n ;;   result = bdfhjlnprtvxz135\n-(define_expand \"vec_pack_mod_v8hi\"\n+(define_expand \"vec_pack_trunc_v8hi\"\n   [(match_operand:V16QI 0 \"register_operand\" \"\")\n    (match_operand:V8HI 1 \"register_operand\" \"\")\n    (match_operand:V8HI 2 \"register_operand\" \"\")]\n@@ -3455,7 +3500,7 @@\n ;;       h2 = aeimbfjn\n ;;       l2 = cgkodhlp\n ;;   result = bdfhjlnp\n-(define_expand \"vec_pack_mod_v4si\"\n+(define_expand \"vec_pack_trunc_v4si\"\n   [(match_operand:V8HI 0 \"register_operand\" \"\")\n    (match_operand:V4SI 1 \"register_operand\" \"\")\n    (match_operand:V4SI 2 \"register_operand\" \"\")]\n@@ -3484,7 +3529,7 @@\n ;;      h1 = aebf\n ;;      l1 = cgdh\n ;;  result = bdfh\n-(define_expand \"vec_pack_mod_v2di\"\n+(define_expand \"vec_pack_trunc_v2di\"\n   [(match_operand:V4SI 0 \"register_operand\" \"\")\n    (match_operand:V2DI 1 \"register_operand\" \"\")\n    (match_operand:V2DI 2 \"register_operand\" \"\")]"}, {"sha": "59bb481eba54523862071c27789512778ceac76b", "filename": "gcc/config/rs6000/altivec.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8115817bf28fd13c0f1c1359f8035f3e4cdb41d2/gcc%2Fconfig%2Frs6000%2Faltivec.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8115817bf28fd13c0f1c1359f8035f3e4cdb41d2/gcc%2Fconfig%2Frs6000%2Faltivec.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.md?ref=8115817bf28fd13c0f1c1359f8035f3e4cdb41d2", "patch": "@@ -2603,7 +2603,7 @@\n   DONE;\n }\")\n \n-(define_expand \"vec_pack_mod_v8hi\"\n+(define_expand \"vec_pack_trunc_v8hi\"\n   [(set (match_operand:V16QI 0 \"register_operand\" \"=v\")\n         (unspec:V16QI [(match_operand:V8HI 1 \"register_operand\" \"v\")\n                        (match_operand:V8HI 2 \"register_operand\" \"v\")]\n@@ -2615,7 +2615,7 @@\n   DONE;\n }\")\n                                                                                 \n-(define_expand \"vec_pack_mod_v4si\"\n+(define_expand \"vec_pack_trunc_v4si\"\n   [(set (match_operand:V8HI 0 \"register_operand\" \"=v\")\n         (unspec:V8HI [(match_operand:V4SI 1 \"register_operand\" \"v\")\n                       (match_operand:V4SI 2 \"register_operand\" \"v\")]"}, {"sha": "60482e4626c06732be9024306e51239005a16088", "filename": "gcc/doc/c-tree.texi", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8115817bf28fd13c0f1c1359f8035f3e4cdb41d2/gcc%2Fdoc%2Fc-tree.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8115817bf28fd13c0f1c1359f8035f3e4cdb41d2/gcc%2Fdoc%2Fc-tree.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fc-tree.texi?ref=8115817bf28fd13c0f1c1359f8035f3e4cdb41d2", "patch": "@@ -1983,7 +1983,7 @@ This macro returns the attributes on the type @var{type}.\n @tindex VEC_WIDEN_MULT_LO_EXPR\n @tindex VEC_UNPACK_HI_EXPR\n @tindex VEC_UNPACK_LO_EXPR\n-@tindex VEC_PACK_MOD_EXPR\n+@tindex VEC_PACK_TRUNC_EXPR\n @tindex VEC_PACK_SAT_EXPR\n @tindex VEC_EXTRACT_EVEN_EXPR \n @tindex VEC_EXTRACT_ODD_EXPR\n@@ -2837,23 +2837,30 @@ vector of @code{N/2} products.\n \n @item VEC_UNPACK_HI_EXPR\n @item VEC_UNPACK_LO_EXPR\n-These nodes represent unpacking of the high and low parts of the input vector, \n+These nodes represent unpacking of the high and low parts of the input vector,\n respectively.  The single operand is a vector that contains @code{N} elements \n-of the same integral type.  The result is a vector that contains half as many \n-elements, of an integral type whose size is twice as wide.  In the case of \n-@code{VEC_UNPACK_HI_EXPR} the high @code{N/2} elements of the vector are \n-extracted and widened (promoted).  In the case of @code{VEC_UNPACK_LO_EXPR} the \n-low @code{N/2} elements of the vector are extracted and widened (promoted).\n+of the same integral or floating point type.  The result is a vector\n+that contains half as many elements, of an integral or floating point type\n+whose size is twice as wide.  In the case of @code{VEC_UNPACK_HI_EXPR} the\n+high @code{N/2} elements of the vector are extracted and widened (promoted).\n+In the case of @code{VEC_UNPACK_LO_EXPR} the low @code{N/2} elements of the\n+vector are extracted and widened (promoted).\n+\n+@item VEC_PACK_TRUNC_EXPR\n+This node represents packing of truncated elements of the two input vectors\n+into the output vector.  Input operands are vectors that contain the same\n+number of elements of the same integral or floating point type.  The result\n+is a vector that contains twice as many elements of an integral or floating\n+point type whose size is half as wide. The elements of the two vectors are\n+demoted and merged (concatenated) to form the output vector.\n \n-@item VEC_PACK_MOD_EXPR\n @item VEC_PACK_SAT_EXPR\n-These nodes represent packing of elements of the two input vectors into the\n-output vector, using modulo or saturating arithmetic, respectively.\n-Their operands are vectors that contain the same number of elements \n-of the same integral type.  The result is a vector that contains twice as many \n-elements, of an integral type whose size is half as wide.  In both cases\n-the elements of the two vectors are demoted and merged (concatenated) to form\n-the output vector.\n+This node represents packing of elements of the two input vectors into the\n+output vector using saturation.  Input operands are vectors that contain\n+the same number of elements of the same integral type.  The result is a\n+vector that contains twice as many elements of an integral type whose size\n+is half as wide.  The elements of the two vectors are demoted and merged\n+(concatenated) to form the output vector.\n \n @item VEC_EXTRACT_EVEN_EXPR\n @item VEC_EXTRACT_ODD_EXPR"}, {"sha": "01705ad282dff509bc6a562f6069e3810a753cc1", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 28, "deletions": 15, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8115817bf28fd13c0f1c1359f8035f3e4cdb41d2/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8115817bf28fd13c0f1c1359f8035f3e4cdb41d2/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=8115817bf28fd13c0f1c1359f8035f3e4cdb41d2", "patch": "@@ -3591,35 +3591,48 @@ Operand 2 is an integer shift amount in bits.\n Operand 0 is where the resulting shifted vector is stored.\n The output and input vectors should have the same modes.\n \n-@cindex @code{vec_pack_mod_@var{m}} instruction pattern\n+@cindex @code{vec_pack_trunc_@var{m}} instruction pattern\n+@item @samp{vec_pack_trunc_@var{m}}\n+Narrow (demote) and merge the elements of two vectors. Operands 1 and 2\n+are vectors of the same mode having N integral or floating point elements\n+of size S.  Operand 0 is the resulting vector in which 2*N elements of\n+size N/2 are concatenated after narrowing them down using truncation.\n+\n @cindex @code{vec_pack_ssat_@var{m}} instruction pattern\n @cindex @code{vec_pack_usat_@var{m}} instruction pattern\n-@item @samp{vec_pack_mod_@var{m}}, @samp{vec_pack_ssat_@var{m}}, @samp{vec_pack_usat_@var{m}}\n-Narrow (demote) and merge the elements of two vectors.\n-Operands 1 and 2 are vectors of the same mode.\n+@item @samp{vec_pack_ssat_@var{m}}, @samp{vec_pack_usat_@var{m}}\n+Narrow (demote) and merge the elements of two vectors.  Operands 1 and 2\n+are vectors of the same mode having N integral elements of size S.\n Operand 0 is the resulting vector in which the elements of the two input\n-vectors are concatenated after narrowing them down using modulo arithmetic or\n-signed/unsigned saturating arithmetic.\n+vectors are concatenated after narrowing them down using signed/unsigned\n+saturating arithmetic.\n \n @cindex @code{vec_unpacks_hi_@var{m}} instruction pattern\n @cindex @code{vec_unpacks_lo_@var{m}} instruction pattern\n+@item @samp{vec_unpacks_hi_@var{m}}, @samp{vec_unpacks_lo_@var{m}}\n+Extract and widen (promote) the high/low part of a vector of signed\n+integral or floating point elements.  The input vector (operand 1) has N\n+elements of size S.  Widen (promote) the high/low elements of the vector\n+using signed or floating point extension and place the resulting N/2\n+values of size 2*S in the output vector (operand 0).\n+\n @cindex @code{vec_unpacku_hi_@var{m}} instruction pattern\n @cindex @code{vec_unpacku_lo_@var{m}} instruction pattern\n-@item @samp{vec_unpacks_hi_@var{m}}, @samp{vec_unpacks_lo_@var{m}}, @samp{vec_unpacku_hi_@var{m}}, @samp{vec_unpacku_lo_@var{m}}\n-Extract and widen (promote) the high/low part of a vector of signed/unsigned\n-elements. The input vector (operand 1) has N signed/unsigned elements of size S. \n-Using sign/zero extension widen (promote) the high/low elements of the vector,\n-and place the resulting N/2 values of size 2*S in the output vector (operand 0).\n+@item @samp{vec_unpacku_hi_@var{m}}, @samp{vec_unpacku_lo_@var{m}}\n+Extract and widen (promote) the high/low part of a vector of unsigned\n+integral elements.  The input vector (operand 1) has N elements of size S.\n+Widen (promote) the high/low elements of the vector using zero extension and\n+place the resulting N/2 values of size 2*S in the output vector (operand 0).\n \n @cindex @code{vec_widen_umult_hi_@var{m}} instruction pattern\n @cindex @code{vec_widen_umult_lo__@var{m}} instruction pattern\n @cindex @code{vec_widen_smult_hi_@var{m}} instruction pattern\n @cindex @code{vec_widen_smult_lo_@var{m}} instruction pattern\n @item @samp{vec_widen_umult_hi_@var{m}}, @samp{vec_widen_umult_lo_@var{m}}, @samp{vec_widen_smult_hi_@var{m}}, @samp{vec_widen_smult_lo_@var{m}}\n-Signed/Unsigned widening multiplication. \n-The two inputs (operands 1 and 2) are vectors with N \n-signed/unsigned elements of size S. Multiply the high/low elements of the two \n-vectors, and put the N/2 products of size 2*S in the output vector (operand 0). \n+Signed/Unsigned widening multiplication.  The two inputs (operands 1 and 2)\n+are vectors with N signed/unsigned elements of size S.  Multiply the high/low\n+elements of the two vectors, and put the N/2 products of size 2*S in the\n+output vector (operand 0).\n \n @cindex @code{mulhisi3} instruction pattern\n @item @samp{mulhisi3}"}, {"sha": "c644933c0ba0d8a1fc60afed3d55b35b1b2f6e8e", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8115817bf28fd13c0f1c1359f8035f3e4cdb41d2/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8115817bf28fd13c0f1c1359f8035f3e4cdb41d2/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=8115817bf28fd13c0f1c1359f8035f3e4cdb41d2", "patch": "@@ -8926,7 +8926,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \treturn target;\n       }\n \n-    case VEC_PACK_MOD_EXPR:\n+    case VEC_PACK_TRUNC_EXPR:\n     case VEC_PACK_SAT_EXPR:\n       {\n \tmode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));"}, {"sha": "0e6d419bcbe4e1ea590728b3998ebbac9f013c17", "filename": "gcc/genopinit.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8115817bf28fd13c0f1c1359f8035f3e4cdb41d2/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8115817bf28fd13c0f1c1359f8035f3e4cdb41d2/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=8115817bf28fd13c0f1c1359f8035f3e4cdb41d2", "patch": "@@ -229,8 +229,9 @@ static const char * const optabs[] =\n   \"vec_unpacks_lo_optab->handlers[$A].insn_code = CODE_FOR_$(vec_unpacks_lo_$a$)\",\n   \"vec_unpacku_hi_optab->handlers[$A].insn_code = CODE_FOR_$(vec_unpacku_hi_$a$)\",\n   \"vec_unpacku_lo_optab->handlers[$A].insn_code = CODE_FOR_$(vec_unpacku_lo_$a$)\",\n-  \"vec_pack_mod_optab->handlers[$A].insn_code = CODE_FOR_$(vec_pack_mod_$a$)\",\n-  \"vec_pack_ssat_optab->handlers[$A].insn_code = CODE_FOR_$(vec_pack_ssat_$a$)\",  \"vec_pack_usat_optab->handlers[$A].insn_code = CODE_FOR_$(vec_pack_usat_$a$)\"\n+  \"vec_pack_trunc_optab->handlers[$A].insn_code = CODE_FOR_$(vec_pack_trunc_$a$)\",\n+  \"vec_pack_ssat_optab->handlers[$A].insn_code = CODE_FOR_$(vec_pack_ssat_$a$)\",\n+  \"vec_pack_usat_optab->handlers[$A].insn_code = CODE_FOR_$(vec_pack_usat_$a$)\"\n };\n \n static void gen_insn (rtx);"}, {"sha": "b45a9b3abadf30ba2c0d2354fccb35ef4d6541b3", "filename": "gcc/optabs.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8115817bf28fd13c0f1c1359f8035f3e4cdb41d2/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8115817bf28fd13c0f1c1359f8035f3e4cdb41d2/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=8115817bf28fd13c0f1c1359f8035f3e4cdb41d2", "patch": "@@ -333,19 +333,19 @@ optab_for_tree_code (enum tree_code code, tree type)\n \tvec_widen_umult_lo_optab : vec_widen_smult_lo_optab;\n \n     case VEC_UNPACK_HI_EXPR:\n-      return TYPE_UNSIGNED (type) ? \n+      return TYPE_UNSIGNED (type) ?\n \tvec_unpacku_hi_optab : vec_unpacks_hi_optab;\n \n     case VEC_UNPACK_LO_EXPR:\n       return TYPE_UNSIGNED (type) ? \n \tvec_unpacku_lo_optab : vec_unpacks_lo_optab;\n \n-    case VEC_PACK_MOD_EXPR:\n-      return vec_pack_mod_optab;\n-                                                                                \n+    case VEC_PACK_TRUNC_EXPR:\n+      return vec_pack_trunc_optab;\n+\n     case VEC_PACK_SAT_EXPR:\n       return TYPE_UNSIGNED (type) ? vec_pack_usat_optab : vec_pack_ssat_optab;\n-                                                                                \n+\n     default:\n       break;\n     }\n@@ -1373,7 +1373,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \t  && mode1 != VOIDmode)\n \txop1 = copy_to_mode_reg (mode1, xop1);\n \n-      if (binoptab == vec_pack_mod_optab \n+      if (binoptab == vec_pack_trunc_optab \n \t  || binoptab == vec_pack_usat_optab\n           || binoptab == vec_pack_ssat_optab)\n \t{\n@@ -5560,7 +5560,7 @@ init_optabs (void)\n   vec_unpacks_lo_optab = init_optab (UNKNOWN);\n   vec_unpacku_hi_optab = init_optab (UNKNOWN);\n   vec_unpacku_lo_optab = init_optab (UNKNOWN);\n-  vec_pack_mod_optab = init_optab (UNKNOWN);\n+  vec_pack_trunc_optab = init_optab (UNKNOWN);\n   vec_pack_usat_optab = init_optab (UNKNOWN);\n   vec_pack_ssat_optab = init_optab (UNKNOWN);\n "}, {"sha": "62a69c742fbff4f5bde8b8847e96cd66574d01b9", "filename": "gcc/optabs.h", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8115817bf28fd13c0f1c1359f8035f3e4cdb41d2/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8115817bf28fd13c0f1c1359f8035f3e4cdb41d2/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=8115817bf28fd13c0f1c1359f8035f3e4cdb41d2", "patch": "@@ -278,14 +278,16 @@ enum optab_index\n   OTI_vec_widen_umult_lo,\n   OTI_vec_widen_smult_hi,\n   OTI_vec_widen_smult_lo,\n-  /* Extract and widen the high/low part of a vector of signed/unsigned \n-     elements.  */\n+  /* Extract and widen the high/low part of a vector of signed or\n+     floating point elements.  */\n   OTI_vec_unpacks_hi,\n   OTI_vec_unpacks_lo,\n+  /* Extract and widen the high/low part of a vector of unsigned\n+     elements.  */\n   OTI_vec_unpacku_hi,\n   OTI_vec_unpacku_lo,\n   /* Narrow (demote) and merge the elements of two vectors.  */\n-  OTI_vec_pack_mod,\n+  OTI_vec_pack_trunc,\n   OTI_vec_pack_usat,\n   OTI_vec_pack_ssat,\n \n@@ -404,7 +406,7 @@ extern GTY(()) optab optab_table[OTI_MAX];\n #define reduc_umin_optab (optab_table[OTI_reduc_umin])\n #define reduc_splus_optab (optab_table[OTI_reduc_splus])\n #define reduc_uplus_optab (optab_table[OTI_reduc_uplus])\n-                                                                                \n+\n #define ssum_widen_optab (optab_table[OTI_ssum_widen])\n #define usum_widen_optab (optab_table[OTI_usum_widen])\n #define sdot_prod_optab (optab_table[OTI_sdot_prod])\n@@ -425,13 +427,13 @@ extern GTY(()) optab optab_table[OTI_MAX];\n #define vec_widen_smult_hi_optab (optab_table[OTI_vec_widen_smult_hi])\n #define vec_widen_smult_lo_optab (optab_table[OTI_vec_widen_smult_lo])\n #define vec_unpacks_hi_optab (optab_table[OTI_vec_unpacks_hi])\n-#define vec_unpacku_hi_optab (optab_table[OTI_vec_unpacku_hi])\n #define vec_unpacks_lo_optab (optab_table[OTI_vec_unpacks_lo])\n+#define vec_unpacku_hi_optab (optab_table[OTI_vec_unpacku_hi])\n #define vec_unpacku_lo_optab (optab_table[OTI_vec_unpacku_lo])\n-#define vec_pack_mod_optab (optab_table[OTI_vec_pack_mod])\n+#define vec_pack_trunc_optab (optab_table[OTI_vec_pack_trunc])\n #define vec_pack_ssat_optab (optab_table[OTI_vec_pack_ssat])\n #define vec_pack_usat_optab (optab_table[OTI_vec_pack_usat])\n-                                                                                \n+\n #define powi_optab (optab_table[OTI_powi])\n \n /* Conversion optabs have their own table and indexes.  */"}, {"sha": "cc26895a3f5d292bdf080c132c7bfc7339bec244", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8115817bf28fd13c0f1c1359f8035f3e4cdb41d2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8115817bf28fd13c0f1c1359f8035f3e4cdb41d2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8115817bf28fd13c0f1c1359f8035f3e4cdb41d2", "patch": "@@ -1,3 +1,9 @@\n+2007-04-22  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\tPR tree-optimization/24659\n+\t* gcc.dg/vect/vect-float-extend-1.c: New test.\n+\t* gcc.dg/vect/vect-float-truncate-1.c: New test.\n+\n 2007-04-22  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/29789"}, {"sha": "ff76b7557c1a291075d36b93ba00ad98619f4fa3", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8115817bf28fd13c0f1c1359f8035f3e4cdb41d2/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8115817bf28fd13c0f1c1359f8035f3e4cdb41d2/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=8115817bf28fd13c0f1c1359f8035f3e4cdb41d2", "patch": "@@ -2149,7 +2149,7 @@ estimate_num_insns_1 (tree *tp, int *walk_subtrees, void *data)\n     case VEC_WIDEN_MULT_LO_EXPR:\n     case VEC_UNPACK_HI_EXPR:\n     case VEC_UNPACK_LO_EXPR:\n-    case VEC_PACK_MOD_EXPR:\n+    case VEC_PACK_TRUNC_EXPR:\n     case VEC_PACK_SAT_EXPR:\n \n     case WIDEN_MULT_EXPR:"}, {"sha": "ab637a8822af55f9fc6fb8cd0a84c047420ad66d", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8115817bf28fd13c0f1c1359f8035f3e4cdb41d2/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8115817bf28fd13c0f1c1359f8035f3e4cdb41d2/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=8115817bf28fd13c0f1c1359f8035f3e4cdb41d2", "patch": "@@ -1943,8 +1943,8 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       pp_string (buffer, \" > \");\n       break;\n \n-    case VEC_PACK_MOD_EXPR:\n-      pp_string (buffer, \" VEC_PACK_MOD_EXPR < \");\n+    case VEC_PACK_TRUNC_EXPR:\n+      pp_string (buffer, \" VEC_PACK_TRUNC_EXPR < \");\n       dump_generic_node (buffer, TREE_OPERAND (node, 0), spc, flags, false);\n       pp_string (buffer, \", \");\n       dump_generic_node (buffer, TREE_OPERAND (node, 1), spc, flags, false);\n@@ -2348,7 +2348,7 @@ op_prio (tree op)\n     case VEC_RSHIFT_EXPR:\n     case VEC_UNPACK_HI_EXPR:\n     case VEC_UNPACK_LO_EXPR:\n-    case VEC_PACK_MOD_EXPR:\n+    case VEC_PACK_TRUNC_EXPR:\n     case VEC_PACK_SAT_EXPR:\n       return 16;\n "}, {"sha": "0b9b91f6d9adaac22beb5564a4831303febb212e", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8115817bf28fd13c0f1c1359f8035f3e4cdb41d2/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8115817bf28fd13c0f1c1359f8035f3e4cdb41d2/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=8115817bf28fd13c0f1c1359f8035f3e4cdb41d2", "patch": "@@ -421,7 +421,7 @@ expand_vector_operations_1 (block_stmt_iterator *bsi)\n       || code == VEC_WIDEN_MULT_LO_EXPR\n       || code == VEC_UNPACK_HI_EXPR\n       || code == VEC_UNPACK_LO_EXPR\n-      || code == VEC_PACK_MOD_EXPR\n+      || code == VEC_PACK_TRUNC_EXPR\n       || code == VEC_PACK_SAT_EXPR)\n     type = TREE_TYPE (TREE_OPERAND (rhs, 0));\n "}, {"sha": "4051cc6eb3fce2120465b5b6c4c82940a03750c5", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 67, "deletions": 62, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8115817bf28fd13c0f1c1359f8035f3e4cdb41d2/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8115817bf28fd13c0f1c1359f8035f3e4cdb41d2/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=8115817bf28fd13c0f1c1359f8035f3e4cdb41d2", "patch": "@@ -174,7 +174,7 @@ vect_create_addr_base_for_vector_ref (tree stmt,\n       offset = fold_build2 (MULT_EXPR, TREE_TYPE (offset), offset, step);\n       base_offset = fold_build2 (PLUS_EXPR, TREE_TYPE (base_offset),\n \t\t\t\t base_offset, offset);\n-      base_offset = force_gimple_operand (base_offset, &new_stmt, false, tmp);  \n+      base_offset = force_gimple_operand (base_offset, &new_stmt, false, tmp);\n       append_to_statement_list_force (new_stmt, new_stmt_list);\n     }\n   \n@@ -561,7 +561,8 @@ get_initial_def_for_induction (tree iv_phi)\n \n   access_fn = analyze_scalar_evolution (loop, PHI_RESULT (iv_phi));\n   gcc_assert (access_fn);\n-  ok = vect_is_simple_iv_evolution (loop->num, access_fn, &init_expr, &step_expr);\n+  ok = vect_is_simple_iv_evolution (loop->num, access_fn,\n+\t\t\t\t    &init_expr, &step_expr);\n   gcc_assert (ok);\n \n   /* Create the vector that holds the initial_value of the induction.  */\n@@ -837,7 +838,7 @@ vect_get_vec_def_for_operand (tree op, tree stmt, tree *scalar_def)\n    vectorized stmt to be created (by the caller to this function) is a \"copy\" \n    created in case the vectorized result cannot fit in one vector, and several \n    copies of the vector-stmt are required. In this case the vector-def is \n-   retrieved from the vector stmt recorded in the STMT_VINFO_RELATED_STMT field \n+   retrieved from the vector stmt recorded in the STMT_VINFO_RELATED_STMT field\n    of the stmt that defines VEC_OPRND. \n    DT is the type of the vector def VEC_OPRND.\n \n@@ -1057,7 +1058,7 @@ get_initial_def_for_reduction (tree stmt, tree init_val, tree *adjustment_def)\n     \n         loop:\n           vec_def = phi <null, null>            # REDUCTION_PHI\n-          VECT_DEF = vector_stmt                # vectorized form of STMT       \n+          VECT_DEF = vector_stmt                # vectorized form of STMT\n           s_loop = scalar_stmt                  # (scalar) STMT\n         loop_exit:\n           s_out0 = phi <s_loop>                 # (scalar) EXIT_PHI\n@@ -1176,8 +1177,8 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt,\n   exit_bsi = bsi_start (exit_bb);\n \n   /* 2.2 Get the relevant tree-code to use in the epilog for schemes 2,3 \n-         (i.e. when reduc_code is not available) and in the final adjustment code\n-         (if needed).  Also get the original scalar reduction variable as\n+         (i.e. when reduc_code is not available) and in the final adjustment\n+\t code (if needed).  Also get the original scalar reduction variable as\n          defined in the loop.  In case STMT is a \"pattern-stmt\" (i.e. - it \n          represents a reduction pattern), the tree-code and scalar-def are \n          taken from the original stmt that the pattern-stmt (STMT) replaces.  \n@@ -1327,7 +1328,7 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt,\n \t\t\t\t bitpos);\n \t\t\n \t      BIT_FIELD_REF_UNSIGNED (rhs) = TYPE_UNSIGNED (scalar_type);\n-\t      epilog_stmt = build_gimple_modify_stmt (new_scalar_dest, rhs);\t\n+\t      epilog_stmt = build_gimple_modify_stmt (new_scalar_dest, rhs);\n \t      new_name = make_ssa_name (new_scalar_dest, epilog_stmt);\n \t      GIMPLE_STMT_OPERAND (epilog_stmt, 0) = new_name;\n \t      bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n@@ -1422,28 +1423,28 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt,\n    and it's STMT_VINFO_RELATED_STMT points to the last stmt in the original\n    sequence that had been detected and replaced by the pattern-stmt (STMT).\n   \n-   In some cases of reduction patterns, the type of the reduction variable X is \n+   In some cases of reduction patterns, the type of the reduction variable X is\n    different than the type of the other arguments of STMT.\n    In such cases, the vectype that is used when transforming STMT into a vector\n-   stmt is different than the vectype that is used to determine the \n+   stmt is different than the vectype that is used to determine the\n    vectorization factor, because it consists of a different number of elements \n    than the actual number of elements that are being operated upon in parallel.\n \n-   For example, consider an accumulation of shorts into an int accumulator. \n+   For example, consider an accumulation of shorts into an int accumulator.\n    On some targets it's possible to vectorize this pattern operating on 8\n    shorts at a time (hence, the vectype for purposes of determining the\n    vectorization factor should be V8HI); on the other hand, the vectype that\n-   is used to create the vector form is actually V4SI (the type of the result). \n+   is used to create the vector form is actually V4SI (the type of the result).\n \n-   Upon entry to this function, STMT_VINFO_VECTYPE records the vectype that \n-   indicates what is the actual level of parallelism (V8HI in the example), so \n-   that the right vectorization factor would be derived. This vectype \n-   corresponds to the type of arguments to the reduction stmt, and should *NOT* \n+   Upon entry to this function, STMT_VINFO_VECTYPE records the vectype that\n+   indicates what is the actual level of parallelism (V8HI in the example), so\n+   that the right vectorization factor would be derived. This vectype\n+   corresponds to the type of arguments to the reduction stmt, and should *NOT*\n    be used to create the vectorized stmt. The right vectype for the vectorized\n-   stmt is obtained from the type of the result X: \n+   stmt is obtained from the type of the result X:\n         get_vectype_for_scalar_type (TREE_TYPE (X))\n \n-   This means that, contrary to \"regular\" reductions (or \"regular\" stmts in \n+   This means that, contrary to \"regular\" reductions (or \"regular\" stmts in\n    general), the following equation:\n       STMT_VINFO_VECTYPE == get_vectype_for_scalar_type (TREE_TYPE (X))\n    does *NOT* necessarily hold for reduction patterns.  */\n@@ -1687,7 +1688,7 @@ vectorizable_reduction (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n               op = TREE_OPERAND (operation, 1);\n               loop_vec_def1 = vect_get_vec_def_for_operand (op, stmt, NULL);\n             }\n-                                                                                \n+\n           /* Get the vector def for the reduction variable from the phi node */\n           reduc_def = PHI_RESULT (new_phi);\n         }\n@@ -1697,34 +1698,33 @@ vectorizable_reduction (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n           loop_vec_def0 = vect_get_vec_def_for_stmt_copy (dt, loop_vec_def0);\n           if (op_type == ternary_op)\n             loop_vec_def1 = vect_get_vec_def_for_stmt_copy (dt, loop_vec_def1);\n-                                                                                \n+\n           /* Get the vector def for the reduction variable from the vectorized\n              reduction operation generated in the previous iteration (j-1)  */\n           reduc_def = GIMPLE_STMT_OPERAND (new_stmt ,0);\n         }\n-                                                                                \n+\n       /* Arguments are ready. create the new vector stmt.  */\n-                                                                                \n       if (op_type == binary_op)\n         expr = build2 (code, vectype, loop_vec_def0, reduc_def);\n       else\n         expr = build3 (code, vectype, loop_vec_def0, loop_vec_def1, \n-\t\t\t\t\t\t\t\treduc_def);\n+\t\t       reduc_def);\n       new_stmt = build_gimple_modify_stmt (vec_dest, expr);\n       new_temp = make_ssa_name (vec_dest, new_stmt);\n       GIMPLE_STMT_OPERAND (new_stmt, 0) = new_temp;\n       vect_finish_stmt_generation (stmt, new_stmt, bsi);\n-                                                                                \n+\n       if (j == 0)\n \tSTMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n       else\n \tSTMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n       prev_stmt_info = vinfo_for_stmt (new_stmt);\n     }\n-                                                                                \n+\n   /* Finalize the reduction-phi (set it's arguments) and create the\n      epilog reduction code.  */\n-  vect_create_epilog_for_reduction (new_temp, stmt, epilog_reduc_code, new_phi);                                                                                \n+  vect_create_epilog_for_reduction (new_temp, stmt, epilog_reduc_code, new_phi);\n   return true;\n }\n \n@@ -2329,7 +2329,7 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n         fprintf (vect_dump, \"use not simple.\");\n       return false;\n     }\n-                                                                                \n+\n   if (op_type == binary_op)\n     {\n       op1 = TREE_OPERAND (operation, 1);\n@@ -2415,12 +2415,12 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n      stmts that use the defs of the current stmt. The example below illustrates\n      the vectorization process when VF=16 and nunits=4 (i.e - we need to create\n      4 vectorized stmts):\n-                                                                                \n+\n      before vectorization:\n                                 RELATED_STMT    VEC_STMT\n         S1:     x = memref      -               -\n         S2:     z = x + 1       -               -\n-                                                                                \n+\n      step 1: vectorize stmt S1 (done in vectorizable_load. See more details\n              there):\n                                 RELATED_STMT    VEC_STMT\n@@ -2430,7 +2430,7 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n         VS1_3:  vx3 = memref3   -               -\n         S1:     x = load        -               VS1_0\n         S2:     z = x + 1       -               -\n-                                                                                \n+\n      step2: vectorize stmt S2 (done here):\n         To vectorize stmt S2 we first need to find the relevant vector\n         def for the first operand 'x'. This is, as usual, obtained from\n@@ -2457,7 +2457,7 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n         VS2_2:  vz2 = vx2 + v1  VS2_3           -\n         VS2_3:  vz3 = vx3 + v1  -               -\n         S2:     z = x + 1       -               VS2_0  */\n-                                                                                \n+\n   prev_stmt_info = NULL;\n   for (j = 0; j < ncopies; j++)\n     {\n@@ -2493,7 +2493,7 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \t}\n \n       /* Arguments are ready. create the new vector stmt.  */\n-                                                                                \n+\n       if (op_type == binary_op)\n         new_stmt = build_gimple_modify_stmt (vec_dest,\n                     build2 (code, vectype, vec_oprnd0, vec_oprnd1));\n@@ -2503,7 +2503,7 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n       new_temp = make_ssa_name (vec_dest, new_stmt);\n       GIMPLE_STMT_OPERAND (new_stmt, 0) = new_temp;\n       vect_finish_stmt_generation (stmt, new_stmt, bsi);\n-                                                                                \n+\n       if (j == 0)\n \tSTMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n       else\n@@ -2516,13 +2516,13 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \n \n /* Function vectorizable_type_demotion\n-                                                                                \n+\n    Check if STMT performs a binary or unary operation that involves\n    type demotion, and if it can be vectorized.\n    If VEC_STMT is also passed, vectorize the STMT: create a vectorized\n    stmt to replace it, put it in VEC_STMT, and insert it at BSI.\n    Return FALSE if not a vectorizable STMT, TRUE otherwise.  */\n-                                                                                \n+\n bool\n vectorizable_type_demotion (tree stmt, block_stmt_iterator *bsi,\n                              tree *vec_stmt)\n@@ -2550,7 +2550,7 @@ vectorizable_type_demotion (tree stmt, block_stmt_iterator *bsi,\n   tree scalar_type;\n   optab optab;\n   enum machine_mode vec_mode;\n-                                                                                \n+\n   if (!STMT_VINFO_RELEVANT_P (stmt_info))\n     return false;\n \n@@ -2564,69 +2564,71 @@ vectorizable_type_demotion (tree stmt, block_stmt_iterator *bsi,\n         fprintf (vect_dump, \"value used after loop.\");\n       return false;\n     }\n-                                                                                \n+\n   /* Is STMT a vectorizable type-demotion operation?  */\n   if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n     return false;\n-                                                                                \n+\n   if (TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 0)) != SSA_NAME)\n     return false;\n-                                                                                \n+\n   operation = GIMPLE_STMT_OPERAND (stmt, 1);\n   code = TREE_CODE (operation);\n   if (code != NOP_EXPR && code != CONVERT_EXPR)\n     return false;\n-                                                                                \n+\n   op0 = TREE_OPERAND (operation, 0);\n   vectype_in = get_vectype_for_scalar_type (TREE_TYPE (op0));\n   nunits_in = TYPE_VECTOR_SUBPARTS (vectype_in);\n-                                                                                \n+\n   scalar_dest = GIMPLE_STMT_OPERAND (stmt, 0);\n   scalar_type = TREE_TYPE (scalar_dest);\n   vectype_out = get_vectype_for_scalar_type (scalar_type);\n   nunits_out = TYPE_VECTOR_SUBPARTS (vectype_out);\n   if (nunits_in != nunits_out / 2) /* FORNOW */\n     return false;\n-                                                                                \n+\n   ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits_out;\n   gcc_assert (ncopies >= 1);\n \n-  if (! INTEGRAL_TYPE_P (scalar_type)\n-      || !INTEGRAL_TYPE_P (TREE_TYPE (op0)))\n+  if (! ((INTEGRAL_TYPE_P (TREE_TYPE (scalar_dest))\n+\t  && INTEGRAL_TYPE_P (TREE_TYPE (op0)))\n+\t || (SCALAR_FLOAT_TYPE_P (TREE_TYPE (scalar_dest))\n+\t     && SCALAR_FLOAT_TYPE_P (TREE_TYPE (op0))\n+\t     && (code == NOP_EXPR || code == CONVERT_EXPR))))\n     return false;\n-                                                                                \n+\n   /* Check the operands of the operation.  */\n   if (!vect_is_simple_use (op0, loop_vinfo, &def_stmt, &def, &dt0))\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"use not simple.\");\n       return false;\n     }\n-                                                                                \n+\n   /* Supportable by target?  */\n-  code = VEC_PACK_MOD_EXPR;\n-  optab = optab_for_tree_code (VEC_PACK_MOD_EXPR, vectype_in);\n+  code = VEC_PACK_TRUNC_EXPR;\n+  optab = optab_for_tree_code (code, vectype_in);\n   if (!optab)\n     return false;\n-                                                                                \n+\n   vec_mode = TYPE_MODE (vectype_in);\n   if (optab->handlers[(int) vec_mode].insn_code == CODE_FOR_nothing)\n     return false;\n-                                                                                \n+\n   STMT_VINFO_VECTYPE (stmt_info) = vectype_in;\n-                                                                                \n+\n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_TYPE (stmt_info) = type_demotion_vec_info_type;\n       return true;\n     }\n-                                                                                \n+\n   /** Transform.  **/\n-                                                                                \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"transform type demotion operation. ncopies = %d.\",\n-                        ncopies);\n-                                                                                \n+\t     ncopies);\n+\n   /* Handle def.  */\n   vec_dest = vect_create_destination_var (scalar_dest, vectype_out);\n   \n@@ -2648,22 +2650,22 @@ vectorizable_type_demotion (tree stmt, block_stmt_iterator *bsi,\n \t  vec_oprnd0 = vect_get_vec_def_for_stmt_copy (dt0, vec_oprnd1);\n \t  vec_oprnd1 = vect_get_vec_def_for_stmt_copy (dt0, vec_oprnd0);\n \t}\n-                                                                                \n+\n       /* Arguments are ready. Create the new vector stmt.  */\n       expr = build2 (code, vectype_out, vec_oprnd0, vec_oprnd1);\n       new_stmt = build_gimple_modify_stmt (vec_dest, expr);\n       new_temp = make_ssa_name (vec_dest, new_stmt);\n       GIMPLE_STMT_OPERAND (new_stmt, 0) = new_temp;\n       vect_finish_stmt_generation (stmt, new_stmt, bsi);\n-                                                                                \n+\n       if (j == 0)\n \tSTMT_VINFO_VEC_STMT (stmt_info) = new_stmt;\n       else\n \tSTMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n-                                                                                \n+\n       prev_stmt_info = vinfo_for_stmt (new_stmt);\n     }\n-                                                                                \n+\n   *vec_stmt = STMT_VINFO_VEC_STMT (stmt_info);\n   return true;\n }\n@@ -2798,8 +2800,11 @@ vectorizable_type_promotion (tree stmt, block_stmt_iterator *bsi,\n   if (nunits_out != nunits_in / 2) /* FORNOW */\n     return false;\n \n-  if (! INTEGRAL_TYPE_P (TREE_TYPE (scalar_dest))\n-      || !INTEGRAL_TYPE_P (TREE_TYPE (op0))) \n+  if (! ((INTEGRAL_TYPE_P (TREE_TYPE (scalar_dest))\n+\t  && INTEGRAL_TYPE_P (TREE_TYPE (op0)))\n+\t || (SCALAR_FLOAT_TYPE_P (TREE_TYPE (scalar_dest))\n+\t     && SCALAR_FLOAT_TYPE_P (TREE_TYPE (op0))\n+\t     && (code == CONVERT_EXPR || code == NOP_EXPR))))\n     return false;\n \n   /* Check the operands of the operation.  */\n@@ -3268,7 +3273,7 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \t  /* For interleaved stores we created vectorized defs for all the \n \t     defs stored in OPRNDS in the previous iteration (previous copy). \n \t     DR_CHAIN is then used as an input to vect_permute_store_chain(), \n-\t     and OPRNDS as an input to vect_get_vec_def_for_stmt_copy() for the \n+\t     and OPRNDS as an input to vect_get_vec_def_for_stmt_copy() for the\n \t     next copy.\n \t     If the store is not strided, GROUP_SIZE is 1, and DR_CHAIN and\n \t     OPRNDS are of size 1.  */\n@@ -4286,7 +4291,7 @@ vect_transform_stmt (tree stmt, block_stmt_iterator *bsi, bool *strided_store)\n       done = vectorizable_type_demotion (stmt, bsi, &vec_stmt);\n       gcc_assert (done);\n       break;\n-                                                                                \n+\n     case type_promotion_vec_info_type:\n       done = vectorizable_type_promotion (stmt, bsi, &vec_stmt);\n       gcc_assert (done);"}, {"sha": "3c41c5c4ee4798ba031918e8e428bda7eb970ae6", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8115817bf28fd13c0f1c1359f8035f3e4cdb41d2/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8115817bf28fd13c0f1c1359f8035f3e4cdb41d2/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=8115817bf28fd13c0f1c1359f8035f3e4cdb41d2", "patch": "@@ -1773,7 +1773,7 @@ supportable_widening_operation (enum tree_code code, tree stmt, tree vectype,\n   tree wide_vectype = get_vectype_for_scalar_type (type);\n   enum tree_code c1, c2;\n \n-  /* The result of a vectorized widening operation usually requires two vectors \n+  /* The result of a vectorized widening operation usually requires two vectors\n      (because the widened results do not fit int one vector). The generated \n      vector results would normally be expected to be generated in the same \n      order as in the original scalar computation. i.e. if 8 results are "}, {"sha": "feeab3fce1fe4491d5939e0637d715724f713ddf", "filename": "gcc/tree.def", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8115817bf28fd13c0f1c1359f8035f3e4cdb41d2/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8115817bf28fd13c0f1c1359f8035f3e4cdb41d2/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=8115817bf28fd13c0f1c1359f8035f3e4cdb41d2", "patch": "@@ -1093,12 +1093,12 @@ DEFTREECODE (VEC_UNPACK_HI_EXPR, \"vec_unpack_hi_expr\", tcc_unary, 1)\n DEFTREECODE (VEC_UNPACK_LO_EXPR, \"vec_unpack_lo_expr\", tcc_unary, 1)\n \n /* Pack (demote/narrow and merge) the elements of the two input vectors\n-   into the output vector, using modulo/saturating arithmetic.\n+   into the output vector using truncation/saturation.\n    The elements of the input vectors are twice the size of the elements of the\n    output vector.  This is used to support type demotion.  */\n-DEFTREECODE (VEC_PACK_MOD_EXPR, \"vec_pack_mod_expr\", tcc_binary, 2)\n+DEFTREECODE (VEC_PACK_TRUNC_EXPR, \"vec_pack_trunc_expr\", tcc_binary, 2)\n DEFTREECODE (VEC_PACK_SAT_EXPR, \"vec_pack_sat_expr\", tcc_binary, 2)\n-                                                                                \n+\n /* Extract even/odd fields from vectors.  */\n DEFTREECODE (VEC_EXTRACT_EVEN_EXPR, \"vec_extracteven_expr\", tcc_binary, 2)\n DEFTREECODE (VEC_EXTRACT_ODD_EXPR, \"vec_extractodd_expr\", tcc_binary, 2)"}]}