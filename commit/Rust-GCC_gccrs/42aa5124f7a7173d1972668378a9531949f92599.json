{"sha": "42aa5124f7a7173d1972668378a9531949f92599", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDJhYTUxMjRmN2E3MTczZDE5NzI2NjgzNzhhOTUzMTk0OWY5MjU5OQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-08-25T18:57:48Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-08-25T18:57:48Z"}, "message": "re PR debug/50132 (ICE: in maybe_record_trace_start, at dwarf2cfi.c:2234 with -fno-asynchronous-unwind-tables and long double)\n\nPR 50132\nPR 49864\n        * cfgcleanup.c (old_insns_match_p): Don't allow cross-jump for\n        non-constant stack adjutment.\n        * expr.c (find_args_size_adjust): Break out from ...\n        (fixup_args_size_notes): ... here.\n        * rtl.h (find_args_size_adjust): Declare.\n\nFrom-SVN: r178084", "tree": {"sha": "ba68cdf5cb12fb41f9051ea44e08934bd8482ab0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba68cdf5cb12fb41f9051ea44e08934bd8482ab0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/42aa5124f7a7173d1972668378a9531949f92599", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42aa5124f7a7173d1972668378a9531949f92599", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42aa5124f7a7173d1972668378a9531949f92599", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42aa5124f7a7173d1972668378a9531949f92599/comments", "author": null, "committer": null, "parents": [{"sha": "0ab71f306cd6148c0c9f93418a86763ee2cd4b72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ab71f306cd6148c0c9f93418a86763ee2cd4b72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ab71f306cd6148c0c9f93418a86763ee2cd4b72"}], "stats": {"total": 276, "additions": 163, "deletions": 113}, "files": [{"sha": "df92093b9b6248eb6cc4aff7726e02d9f43f2d3c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42aa5124f7a7173d1972668378a9531949f92599/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42aa5124f7a7173d1972668378a9531949f92599/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=42aa5124f7a7173d1972668378a9531949f92599", "patch": "@@ -1,3 +1,13 @@\n+2011-08-25  Richard Henderson  <rth@redhat.com>\n+\n+\tPR 50132\n+\tPR 49864\n+\t* cfgcleanup.c (old_insns_match_p): Don't allow cross-jump for\n+\tnon-constant stack adjutment.\n+\t* expr.c (find_args_size_adjust): Break out from ...\n+\t(fixup_args_size_notes): ... here.\n+\t* rtl.h (find_args_size_adjust): Declare.\n+\n 2011-08-25  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.md (isa): Add sse2, sse2_noavx, sse3,"}, {"sha": "396057cc19b348fba5fadad24ef361c537f44bc0", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42aa5124f7a7173d1972668378a9531949f92599/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42aa5124f7a7173d1972668378a9531949f92599/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=42aa5124f7a7173d1972668378a9531949f92599", "patch": "@@ -1081,11 +1081,20 @@ old_insns_match_p (int mode ATTRIBUTE_UNUSED, rtx i1, rtx i2)\n   /* ??? Do not allow cross-jumping between different stack levels.  */\n   p1 = find_reg_note (i1, REG_ARGS_SIZE, NULL);\n   p2 = find_reg_note (i2, REG_ARGS_SIZE, NULL);\n-  if (p1)\n-    p1 = XEXP (p1, 0);\n-  if (p2)\n-    p2 = XEXP (p2, 0);\n-  if (!rtx_equal_p (p1, p2))\n+  if (p1 && p2)\n+    {\n+      p1 = XEXP (p1, 0);\n+      p2 = XEXP (p2, 0);\n+      if (!rtx_equal_p (p1, p2))\n+        return dir_none;\n+\n+      /* ??? Worse, this adjustment had better be constant lest we\n+         have differing incoming stack levels.  */\n+      if (!frame_pointer_needed\n+          && find_args_size_adjust (i1) == HOST_WIDE_INT_MIN)\n+\treturn dir_none;\n+    }\n+  else if (p1 || p2)\n     return dir_none;\n \n   p1 = PATTERN (i1);"}, {"sha": "a6746d1b50e87ff1ad97caedaa8dd9c76ab2140b", "filename": "gcc/expr.c", "status": "modified", "additions": 128, "deletions": 108, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42aa5124f7a7173d1972668378a9531949f92599/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42aa5124f7a7173d1972668378a9531949f92599/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=42aa5124f7a7173d1972668378a9531949f92599", "patch": "@@ -3548,131 +3548,151 @@ mem_autoinc_base (rtx mem)\n    verified, via immediate operand or auto-inc.  If the adjustment\n    cannot be trivially extracted, the return value is INT_MIN.  */\n \n-int\n-fixup_args_size_notes (rtx prev, rtx last, int end_args_size)\n+HOST_WIDE_INT\n+find_args_size_adjust (rtx insn)\n {\n-  int args_size = end_args_size;\n-  bool saw_unknown = false;\n-  rtx insn;\n+  rtx dest, set, pat;\n+  int i;\n \n-  for (insn = last; insn != prev; insn = PREV_INSN (insn))\n-    {\n-      rtx dest, set, pat;\n-      HOST_WIDE_INT this_delta = 0;\n-      int i;\n+  pat = PATTERN (insn);\n+  set = NULL;\n \n-      if (!NONDEBUG_INSN_P (insn))\n-\tcontinue;\n-      pat = PATTERN (insn);\n-      set = NULL;\n+  /* Look for a call_pop pattern.  */\n+  if (CALL_P (insn))\n+    {\n+      /* We have to allow non-call_pop patterns for the case\n+\t of emit_single_push_insn of a TLS address.  */\n+      if (GET_CODE (pat) != PARALLEL)\n+\treturn 0;\n \n-      /* Look for a call_pop pattern.  */\n-      if (CALL_P (insn))\n+      /* All call_pop have a stack pointer adjust in the parallel.\n+\t The call itself is always first, and the stack adjust is\n+\t usually last, so search from the end.  */\n+      for (i = XVECLEN (pat, 0) - 1; i > 0; --i)\n \t{\n-          /* We have to allow non-call_pop patterns for the case\n-\t     of emit_single_push_insn of a TLS address.  */\n-\t  if (GET_CODE (pat) != PARALLEL)\n-\t    continue;\n-\n-\t  /* All call_pop have a stack pointer adjust in the parallel.\n-\t     The call itself is always first, and the stack adjust is\n-\t     usually last, so search from the end.  */\n-\t  for (i = XVECLEN (pat, 0) - 1; i > 0; --i)\n-\t    {\n-\t      set = XVECEXP (pat, 0, i);\n-\t      if (GET_CODE (set) != SET)\n-\t\tcontinue;\n-\t      dest = SET_DEST (set);\n-\t      if (dest == stack_pointer_rtx)\n-\t\tbreak;\n-\t    }\n-\t  /* We'd better have found the stack pointer adjust.  */\n-\t  if (i == 0)\n+\t  set = XVECEXP (pat, 0, i);\n+\t  if (GET_CODE (set) != SET)\n \t    continue;\n-\t  /* Fall through to process the extracted SET and DEST\n-\t     as if it was a standalone insn.  */\n+\t  dest = SET_DEST (set);\n+\t  if (dest == stack_pointer_rtx)\n+\t    break;\n \t}\n-      else if (GET_CODE (pat) == SET)\n-\tset = pat;\n-      else if ((set = single_set (insn)) != NULL)\n-\t;\n-      else if (GET_CODE (pat) == PARALLEL)\n+      /* We'd better have found the stack pointer adjust.  */\n+      if (i == 0)\n+\treturn 0;\n+      /* Fall through to process the extracted SET and DEST\n+\t as if it was a standalone insn.  */\n+    }\n+  else if (GET_CODE (pat) == SET)\n+    set = pat;\n+  else if ((set = single_set (insn)) != NULL)\n+    ;\n+  else if (GET_CODE (pat) == PARALLEL)\n+    {\n+      /* ??? Some older ports use a parallel with a stack adjust\n+\t and a store for a PUSH_ROUNDING pattern, rather than a\n+\t PRE/POST_MODIFY rtx.  Don't force them to update yet...  */\n+      /* ??? See h8300 and m68k, pushqi1.  */\n+      for (i = XVECLEN (pat, 0) - 1; i >= 0; --i)\n \t{\n-\t  /* ??? Some older ports use a parallel with a stack adjust\n-\t     and a store for a PUSH_ROUNDING pattern, rather than a\n-\t     PRE/POST_MODIFY rtx.  Don't force them to update yet...  */\n-\t  /* ??? See h8300 and m68k, pushqi1.  */\n-\t  for (i = XVECLEN (pat, 0) - 1; i >= 0; --i)\n-\t    {\n-\t      set = XVECEXP (pat, 0, i);\n-\t      if (GET_CODE (set) != SET)\n-\t\tcontinue;\n-\t      dest = SET_DEST (set);\n-\t      if (dest == stack_pointer_rtx)\n-\t\tbreak;\n-\n-\t      /* We do not expect an auto-inc of the sp in the parallel.  */\n-\t      gcc_checking_assert (mem_autoinc_base (dest)\n-\t\t\t\t   != stack_pointer_rtx);\n-\t      gcc_checking_assert (mem_autoinc_base (SET_SRC (set))\n-\t\t\t\t   != stack_pointer_rtx);\n-\t    }\n-\t  if (i < 0)\n+\t  set = XVECEXP (pat, 0, i);\n+\t  if (GET_CODE (set) != SET)\n \t    continue;\n+\t  dest = SET_DEST (set);\n+\t  if (dest == stack_pointer_rtx)\n+\t    break;\n+\n+\t  /* We do not expect an auto-inc of the sp in the parallel.  */\n+\t  gcc_checking_assert (mem_autoinc_base (dest) != stack_pointer_rtx);\n+\t  gcc_checking_assert (mem_autoinc_base (SET_SRC (set))\n+\t\t\t       != stack_pointer_rtx);\n \t}\n+      if (i < 0)\n+\treturn 0;\n+    }\n+  else\n+    return 0;\n+\n+  dest = SET_DEST (set);\n+\n+  /* Look for direct modifications of the stack pointer.  */\n+  if (REG_P (dest) && REGNO (dest) == STACK_POINTER_REGNUM)\n+    {\n+      /* Look for a trivial adjustment, otherwise assume nothing.  */\n+      /* Note that the SPU restore_stack_block pattern refers to\n+\t the stack pointer in V4SImode.  Consider that non-trivial.  */\n+      if (SCALAR_INT_MODE_P (GET_MODE (dest))\n+\t  && GET_CODE (SET_SRC (set)) == PLUS\n+\t  && XEXP (SET_SRC (set), 0) == stack_pointer_rtx\n+\t  && CONST_INT_P (XEXP (SET_SRC (set), 1)))\n+\treturn INTVAL (XEXP (SET_SRC (set), 1));\n+      /* ??? Reload can generate no-op moves, which will be cleaned\n+\t up later.  Recognize it and continue searching.  */\n+      else if (rtx_equal_p (dest, SET_SRC (set)))\n+\treturn 0;\n       else\n-\tcontinue;\n-      dest = SET_DEST (set);\n-\n-      /* Look for direct modifications of the stack pointer.  */\n-      if (REG_P (dest) && REGNO (dest) == STACK_POINTER_REGNUM)\n-\t{\n-\t  gcc_assert (!saw_unknown);\n-\t  /* Look for a trivial adjustment, otherwise assume nothing.  */\n-\t  /* Note that the SPU restore_stack_block pattern refers to\n-\t     the stack pointer in V4SImode.  Consider that non-trivial.  */\n-\t  if (SCALAR_INT_MODE_P (GET_MODE (dest))\n-\t      && GET_CODE (SET_SRC (set)) == PLUS\n-\t      && XEXP (SET_SRC (set), 0) == stack_pointer_rtx\n-\t      && CONST_INT_P (XEXP (SET_SRC (set), 1)))\n-\t    this_delta = INTVAL (XEXP (SET_SRC (set), 1));\n-\t  /* ??? Reload can generate no-op moves, which will be cleaned\n-\t     up later.  Recognize it and continue searching.  */\n-\t  else if (rtx_equal_p (dest, SET_SRC (set)))\n-\t    this_delta = 0;\n-\t  else\n-\t    saw_unknown = true;\n-\t}\n+\treturn HOST_WIDE_INT_MIN;\n+    }\n+  else\n+    {\n+      rtx mem, addr;\n+\n       /* Otherwise only think about autoinc patterns.  */\n-      else if (mem_autoinc_base (dest) == stack_pointer_rtx)\n+      if (mem_autoinc_base (dest) == stack_pointer_rtx)\n \t{\n-\t  rtx addr = XEXP (dest, 0);\n-\t  gcc_assert (!saw_unknown);\n-\t  switch (GET_CODE (addr))\n-\t    {\n-\t    case PRE_INC:\n-\t    case POST_INC:\n-\t      this_delta = GET_MODE_SIZE (GET_MODE (dest));\n-\t      break;\n-\t    case PRE_DEC:\n-\t    case POST_DEC:\n-\t      this_delta = -GET_MODE_SIZE (GET_MODE (dest));\n-\t      break;\n-\t    case PRE_MODIFY:\n-\t    case POST_MODIFY:\n-\t      addr = XEXP (addr, 1);\n-\t      gcc_assert (GET_CODE (addr) == PLUS);\n-\t      gcc_assert (XEXP (addr, 0) == stack_pointer_rtx);\n-\t      gcc_assert (CONST_INT_P (XEXP (addr, 1)));\n-\t      this_delta = INTVAL (XEXP (addr, 1));\n-\t      break;\n-\t    default:\n-\t      gcc_unreachable ();\n-\t    }\n+\t  mem = dest;\n+\t  gcc_checking_assert (mem_autoinc_base (SET_SRC (set))\n+\t\t\t       != stack_pointer_rtx);\n \t}\n+      else if (mem_autoinc_base (SET_SRC (set)) == stack_pointer_rtx)\n+\tmem = SET_SRC (set);\n       else\n+\treturn 0;\n+\n+      addr = XEXP (mem, 0);\n+      switch (GET_CODE (addr))\n+\t{\n+\tcase PRE_INC:\n+\tcase POST_INC:\n+\t  return GET_MODE_SIZE (GET_MODE (mem));\n+\tcase PRE_DEC:\n+\tcase POST_DEC:\n+\t  return -GET_MODE_SIZE (GET_MODE (mem));\n+\tcase PRE_MODIFY:\n+\tcase POST_MODIFY:\n+\t  addr = XEXP (addr, 1);\n+\t  gcc_assert (GET_CODE (addr) == PLUS);\n+\t  gcc_assert (XEXP (addr, 0) == stack_pointer_rtx);\n+\t  gcc_assert (CONST_INT_P (XEXP (addr, 1)));\n+\t  return INTVAL (XEXP (addr, 1));\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+}\n+\n+int\n+fixup_args_size_notes (rtx prev, rtx last, int end_args_size)\n+{\n+  int args_size = end_args_size;\n+  bool saw_unknown = false;\n+  rtx insn;\n+\n+  for (insn = last; insn != prev; insn = PREV_INSN (insn))\n+    {\n+      HOST_WIDE_INT this_delta;\n+\n+      if (!NONDEBUG_INSN_P (insn))\n+\tcontinue;\n+\n+      this_delta = find_args_size_adjust (insn);\n+      if (this_delta == 0)\n \tcontinue;\n \n+      gcc_assert (!saw_unknown);\n+      if (this_delta == HOST_WIDE_INT_MIN)\n+\tsaw_unknown = true;\n+\n       add_reg_note (insn, REG_ARGS_SIZE, GEN_INT (args_size));\n #ifdef STACK_GROWS_DOWNWARD\n       this_delta = -this_delta;"}, {"sha": "7f863899f64e36741a36a6c0a82739db3324075e", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42aa5124f7a7173d1972668378a9531949f92599/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42aa5124f7a7173d1972668378a9531949f92599/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=42aa5124f7a7173d1972668378a9531949f92599", "patch": "@@ -2508,6 +2508,7 @@ extern void emit_jump (rtx);\n /* In expr.c */\n extern rtx move_by_pieces (rtx, rtx, unsigned HOST_WIDE_INT,\n \t\t\t   unsigned int, int);\n+extern HOST_WIDE_INT find_args_size_adjust (rtx);\n extern int fixup_args_size_notes (rtx, rtx, int);\n \n /* In cfgrtl.c */"}, {"sha": "84a9c731f8bf7c15309c598553f4a65b689f4e12", "filename": "gcc/testsuite/gcc.dg/pr50132.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42aa5124f7a7173d1972668378a9531949f92599/gcc%2Ftestsuite%2Fgcc.dg%2Fpr50132.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42aa5124f7a7173d1972668378a9531949f92599/gcc%2Ftestsuite%2Fgcc.dg%2Fpr50132.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr50132.c?ref=42aa5124f7a7173d1972668378a9531949f92599", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Os -fno-asynchronous-unwind-tables -g\" } */\n+\n+void bar (long double n);\n+\n+void foo (int c)\n+{\n+  if (c)\n+    bar (0);\n+}"}]}