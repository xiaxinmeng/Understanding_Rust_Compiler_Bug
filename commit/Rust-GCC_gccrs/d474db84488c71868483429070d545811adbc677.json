{"sha": "d474db84488c71868483429070d545811adbc677", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDQ3NGRiODQ0ODhjNzE4Njg0ODM0MjkwNzBkNTQ1ODExYWRiYzY3Nw==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2010-07-12T18:53:59Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2010-07-12T18:53:59Z"}, "message": "Makefile.in (target-globals.o): Depend on reload.h.\n\ngcc/\n\t* Makefile.in (target-globals.o): Depend on reload.h.\n\t* reload.h (target_reload): New structure.\n\t(default_target_reload): Declare.\n\t(this_target_reload): Declare as a variable or define as a macro.\n\t(indirect_symref_ok, double_reg_address_ok): Redefine as macros.\n\t* reload1.c (default_target_reload): New variable\n\t(this_target_reload): New conditional variable.\n\t(indirect_symref_ok, double_reg_address_ok): Delete.\n\t(spill_indirect_levels): Redefine as a macro.\n\t* target-globals.h (this_target_reload): Declare.\n\t(target_globals): Add a reload field.\n\t(restore_target_globals): Copy the reload field to\n\tthis_target_reload.\n\t* target-globals.c: Include hard-reg-set.h.\n\t(default_target_globals): Initialize the reload field.\n\t(save_target_globals): Likewise.\n\nFrom-SVN: r162093", "tree": {"sha": "81833811781814bd7dc33b609cd55e47bc56fc7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/81833811781814bd7dc33b609cd55e47bc56fc7e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d474db84488c71868483429070d545811adbc677", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d474db84488c71868483429070d545811adbc677", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d474db84488c71868483429070d545811adbc677", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d474db84488c71868483429070d545811adbc677/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7bf84454ff6670c4e44561dc3f1de0b2eaa011fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bf84454ff6670c4e44561dc3f1de0b2eaa011fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7bf84454ff6670c4e44561dc3f1de0b2eaa011fa"}], "stats": {"total": 93, "additions": 66, "deletions": 27}, "files": [{"sha": "21d5e7d74dc75285e6d3311780eb6a575d4da414", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d474db84488c71868483429070d545811adbc677/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d474db84488c71868483429070d545811adbc677/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d474db84488c71868483429070d545811adbc677", "patch": "@@ -1,3 +1,22 @@\n+2010-07-12  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* Makefile.in (target-globals.o): Depend on reload.h.\n+\t* reload.h (target_reload): New structure.\n+\t(default_target_reload): Declare.\n+\t(this_target_reload): Declare as a variable or define as a macro.\n+\t(indirect_symref_ok, double_reg_address_ok): Redefine as macros.\n+\t* reload1.c (default_target_reload): New variable\n+\t(this_target_reload): New conditional variable.\n+\t(indirect_symref_ok, double_reg_address_ok): Delete.\n+\t(spill_indirect_levels): Redefine as a macro.\n+\t* target-globals.h (this_target_reload): Declare.\n+\t(target_globals): Add a reload field.\n+\t(restore_target_globals): Copy the reload field to\n+\tthis_target_reload.\n+\t* target-globals.c: Include hard-reg-set.h.\n+\t(default_target_globals): Initialize the reload field.\n+\t(save_target_globals): Likewise.\n+\n 2010-07-12  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* rtl.h (target_rtl): Add x_static_reg_base_value."}, {"sha": "325e97eef1f7a1cb9255098a8f56541cf04b2cac", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d474db84488c71868483429070d545811adbc677/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d474db84488c71868483429070d545811adbc677/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=d474db84488c71868483429070d545811adbc677", "patch": "@@ -3477,7 +3477,7 @@ lower-subreg.o : lower-subreg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(EXPR_H) $(EXCEPT_H) $(REGS_H) $(TREE_PASS_H) $(DF_H)\n target-globals.o : target-globals.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) insn-config.h $(MACHMODE_H) $(GGC_H) $(TOPLEV_H) target-globals.h \\\n-   $(FLAGS_H) $(REGS_H) $(RTL_H)\n+   $(FLAGS_H) $(REGS_H) $(RTL_H) reload.h\n \n $(out_object_file): $(out_file) $(CONFIG_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(RTL_H) $(REGS_H) hard-reg-set.h insn-config.h conditions.h \\"}, {"sha": "48b8dfd0386a7900d03a95b36d25be445c8f3507", "filename": "gcc/reload.h", "status": "modified", "additions": 31, "deletions": 9, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d474db84488c71868483429070d545811adbc677/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d474db84488c71868483429070d545811adbc677/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=d474db84488c71868483429070d545811adbc677", "patch": "@@ -154,6 +154,37 @@ extern struct reload rld[MAX_RELOADS];\n extern int n_reloads;\n #endif\n \n+/* Target-dependent globals.  */\n+struct target_reload {\n+  /* Nonzero if indirect addressing is supported when the innermost MEM is\n+     of the form (MEM (SYMBOL_REF sym)).  It is assumed that the level to\n+     which these are valid is the same as spill_indirect_levels, above.  */\n+  bool x_indirect_symref_ok;\n+\n+  /* Nonzero if an address (plus (reg frame_pointer) (reg ...)) is valid.  */\n+  bool x_double_reg_address_ok;\n+\n+  /* Nonzero if indirect addressing is supported on the machine; this means\n+     that spilling (REG n) does not require reloading it into a register in\n+     order to do (MEM (REG n)) or (MEM (PLUS (REG n) (CONST_INT c))).  The\n+     value indicates the level of indirect addressing supported, e.g., two\n+     means that (MEM (MEM (REG n))) is also valid if (REG n) does not get\n+     a hard register.  */\n+  bool x_spill_indirect_levels;\n+};\n+\n+extern struct target_reload default_target_reload;\n+#if SWITCHABLE_TARGET\n+extern struct target_reload *this_target_reload;\n+#else\n+#define this_target_reload (&default_target_reload)\n+#endif\n+\n+#define indirect_symref_ok \\\n+  (this_target_reload->x_indirect_symref_ok)\n+#define double_reg_address_ok \\\n+  (this_target_reload->x_double_reg_address_ok)\n+\n extern GTY (()) VEC(rtx,gc) *reg_equiv_memory_loc_vec;\n extern rtx *reg_equiv_constant;\n extern rtx *reg_equiv_invariant;\n@@ -181,15 +212,6 @@ extern int reload_n_operands;\n    Used in find_equiv_reg.  */\n extern int reload_first_uid;\n \n-/* Nonzero if indirect addressing is supported when the innermost MEM is\n-   of the form (MEM (SYMBOL_REF sym)).  It is assumed that the level to\n-   which these are valid is the same as spill_indirect_levels, above.  */\n-\n-extern char indirect_symref_ok;\n-\n-/* Nonzero if an address (plus (reg frame_pointer) (reg ...)) is valid.  */\n-extern char double_reg_address_ok;\n-\n extern int num_not_at_initial_offset;\n \n #if defined SET_HARD_REG_BIT && defined CLEAR_REG_SET"}, {"sha": "437b8c2f286e1ce8cd857d74367efc152abf7752", "filename": "gcc/reload1.c", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d474db84488c71868483429070d545811adbc677/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d474db84488c71868483429070d545811adbc677/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=d474db84488c71868483429070d545811adbc677", "patch": "@@ -81,6 +81,14 @@ along with GCC; see the file COPYING3.  If not see\n    fixing up each insn, and generating the new insns to copy values\n    into the reload registers.  */\n \f\n+struct target_reload default_target_reload;\n+#if SWITCHABLE_TARGET\n+struct target_reload *this_target_reload = &default_target_reload;\n+#endif\n+\n+#define spill_indirect_levels\t\t\t\\\n+  (this_target_reload->x_spill_indirect_levels)\n+\n /* During reload_as_needed, element N contains a REG rtx for the hard reg\n    into which reg N has been reloaded (perhaps for a previous insn).  */\n static rtx *reg_last_reload_reg;\n@@ -231,22 +239,6 @@ static HARD_REG_SET used_spill_regs;\n    a round-robin fashion.  */\n static int last_spill_reg;\n \n-/* Nonzero if indirect addressing is supported on the machine; this means\n-   that spilling (REG n) does not require reloading it into a register in\n-   order to do (MEM (REG n)) or (MEM (PLUS (REG n) (CONST_INT c))).  The\n-   value indicates the level of indirect addressing supported, e.g., two\n-   means that (MEM (MEM (REG n))) is also valid if (REG n) does not get\n-   a hard register.  */\n-static char spill_indirect_levels;\n-\n-/* Nonzero if indirect addressing is supported when the innermost MEM is\n-   of the form (MEM (SYMBOL_REF sym)).  It is assumed that the level to\n-   which these are valid is the same as spill_indirect_levels, above.  */\n-char indirect_symref_ok;\n-\n-/* Nonzero if an address (plus (reg frame_pointer) (reg ...)) is valid.  */\n-char double_reg_address_ok;\n-\n /* Record the stack slot for each spilled hard register.  */\n static rtx spill_stack_slot[FIRST_PSEUDO_REGISTER];\n "}, {"sha": "f78e58d092729a20140951337e9a9172ee5a1534", "filename": "gcc/target-globals.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d474db84488c71868483429070d545811adbc677/gcc%2Ftarget-globals.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d474db84488c71868483429070d545811adbc677/gcc%2Ftarget-globals.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-globals.c?ref=d474db84488c71868483429070d545811adbc677", "patch": "@@ -30,13 +30,15 @@ along with GCC; see the file COPYING3.  If not see\n #include \"regs.h\"\n #include \"rtl.h\"\n #include \"hard-reg-set.h\"\n+#include \"reload.h\"\n \n #if SWITCHABLE_TARGET\n struct target_globals default_target_globals = {\n   &default_target_flag_state,\n   &default_target_regs,\n   &default_target_rtl,\n-  &default_target_hard_regs\n+  &default_target_hard_regs,\n+  &default_target_reload\n };\n \n struct target_globals *\n@@ -49,6 +51,7 @@ save_target_globals (void)\n   g->regs = XCNEW (struct target_regs);\n   g->rtl = ggc_alloc_cleared_target_rtl ();\n   g->hard_regs = XCNEW (struct target_hard_regs);\n+  g->reload = XCNEW (struct target_reload);\n   restore_target_globals (g);\n   target_reinit ();\n   return g;"}, {"sha": "677aa94dddf5f983e52fc6d3dd51d68d10d2c51c", "filename": "gcc/target-globals.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d474db84488c71868483429070d545811adbc677/gcc%2Ftarget-globals.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d474db84488c71868483429070d545811adbc677/gcc%2Ftarget-globals.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-globals.h?ref=d474db84488c71868483429070d545811adbc677", "patch": "@@ -25,12 +25,14 @@ extern struct target_flag_state *this_target_flag_state;\n extern struct target_regs *this_target_regs;\n extern struct target_rtl *this_target_rtl;\n extern struct target_hard_regs *this_target_hard_regs;\n+extern struct target_reload *this_target_reload;\n \n struct GTY(()) target_globals {\n   struct target_flag_state *GTY((skip)) flag_state;\n   struct target_regs *GTY((skip)) regs;\n   struct target_rtl *rtl;\n   struct target_hard_regs *GTY((skip)) hard_regs;\n+  struct target_reload *GTY((skip)) reload;\n };\n \n extern struct target_globals default_target_globals;\n@@ -44,6 +46,7 @@ restore_target_globals (struct target_globals *g)\n   this_target_regs = g->regs;\n   this_target_rtl = g->rtl;\n   this_target_hard_regs = g->hard_regs;\n+  this_target_reload = g->reload;\n }\n #endif\n "}]}