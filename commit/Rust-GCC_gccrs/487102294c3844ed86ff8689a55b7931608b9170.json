{"sha": "487102294c3844ed86ff8689a55b7931608b9170", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDg3MTAyMjk0YzM4NDRlZDg2ZmY4Njg5YTU1Yjc5MzE2MDhiOTE3MA==", "commit": {"author": {"name": "Razya Ladelsky", "email": "razya@il.ibm.com", "date": "2009-10-22T14:43:40Z"}, "committer": {"name": "Razya Ladelsky", "email": "razya@gcc.gnu.org", "date": "2009-10-22T14:43:40Z"}, "message": "cfgloopmanip.c (duplicate_subloops): Export.\n\n2009-10-22  Razya Ladelsky  <razya@il.ibm.com>\n\n        * cfgloopmanip.c  (duplicate_subloops): Export.\n        * tree-parloops.c (loop_parallel_p): Dump if loop is innermost.\n        (transform_to_exit_first_loop): Duplicate bbs starting from \n        header up to loop->latch instead of exit->src.\n        Initialize control variable to the correct number of iterations.\n        (gather_scalar_reductions): Do not register double reductions.\n        (parallelize_loops): Dump which loop is tested. \n        Indicate whether the parallelized loop is inner or not. \n        Remove the innermost-loop requirement.\n        * cfgloop.h (duplicate_subloops): Export. \n        * tree-cfg.c (add_phi_args_after_redirect): New function.\n        (gimple_duplicate_sese_tail): Remove the no-subloops constraint.\n        Call duplicate_subloops.\n        Update number of iterations at the exit condition.\n        Don't redirect nexits always to the loop exit.\n        Redirect copied edges from latch to the loop exit.\n        * testsuite/libgomp.graphite/force-parallel-2.c: Adjust scan.\n        * testsuite/gcc.dg/autopar/outer-1.c: New testcase.\n        * testsuite/gcc.dg/autopar/outer-2.c: New testcase.\n        * testsuite/gcc.dg/autopar/outer-3.c: New testcase.\n        * testsuite/gcc.dg/autopar/outer-4.c: New testcase.\n        * testsuite/gcc.dg/autopar/outer-5.c: New testcase.\n        * testsuite/gcc.dg/autopar/outer-6.c: New testcase.\n\nFrom-SVN: r153457", "tree": {"sha": "e5cbd164c16ea25532929cae67f57059ca137cd2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e5cbd164c16ea25532929cae67f57059ca137cd2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/487102294c3844ed86ff8689a55b7931608b9170", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/487102294c3844ed86ff8689a55b7931608b9170", "html_url": "https://github.com/Rust-GCC/gccrs/commit/487102294c3844ed86ff8689a55b7931608b9170", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/487102294c3844ed86ff8689a55b7931608b9170/comments", "author": null, "committer": null, "parents": [{"sha": "0d4958d02272d61ab5e6e331d171ecc52de82b07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d4958d02272d61ab5e6e331d171ecc52de82b07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d4958d02272d61ab5e6e331d171ecc52de82b07"}], "stats": {"total": 483, "additions": 449, "deletions": 34}, "files": [{"sha": "54890010683f5a759726cf943e666d3fa19bd6d2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/487102294c3844ed86ff8689a55b7931608b9170/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/487102294c3844ed86ff8689a55b7931608b9170/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=487102294c3844ed86ff8689a55b7931608b9170", "patch": "@@ -1,3 +1,29 @@\n+2009-10-22  Razya Ladelsky  <razya@il.ibm.com>\n+\t\n+\t* cfgloopmanip.c  (duplicate_subloops): Export. \n+\t* tree-parloops.c (loop_parallel_p): Dump if loop is innermost.\n+\t(transform_to_exit_first_loop): Duplicate bbs starting from \n+\theader up to loop->latch instead of exit->src.\n+\tInitialize control variable to the correct number of iterations.\n+\t(gather_scalar_reductions): Do not register double reductions.\n+\t(parallelize_loops): Dump which loop is tested. \n+\tIndicate whether the parallelized loop is inner or not. \n+\tRemove the innermost-loop requirement.\n+\t* cfgloop.h (duplicate_subloops): Export. \n+\t* tree-cfg.c (add_phi_args_after_redirect): New function.\n+\t(gimple_duplicate_sese_tail): Remove the no-subloops constraint.\n+\tCall duplicate_subloops.\n+\tUpdate number of iterations at the exit condition.\n+\tDon't redirect nexits always to the loop exit.\n+\tRedirect copied edges from latch to the loop exit.\n+\t* testsuite/libgomp.graphite/force-parallel-2.c: Adjust scan.\n+\t* testsuite/gcc.dg/autopar/outer-1.c: New testcase.\n+\t* testsuite/gcc.dg/autopar/outer-2.c: New testcase.\n+\t* testsuite/gcc.dg/autopar/outer-3.c: New testcase.\n+\t* testsuite/gcc.dg/autopar/outer-4.c: New testcase.\n+\t* testsuite/gcc.dg/autopar/outer-5.c: New testcase.\n+\t* testsuite/gcc.dg/autopar/outer-6.c: New testcase.\n+\n 2009-10-22  Jan Hubicka  <jh@suse.cz>\n \n \t* ipa-cp.c (ipcp_read_summary): Remove now invalid FIXME and"}, {"sha": "4abdf8bfe1513eddfc577b47db2969d1ba5c0f04", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/487102294c3844ed86ff8689a55b7931608b9170/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/487102294c3844ed86ff8689a55b7931608b9170/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=487102294c3844ed86ff8689a55b7931608b9170", "patch": "@@ -288,6 +288,7 @@ extern edge create_empty_if_region_on_edge (edge, tree);\n extern struct loop *create_empty_loop_on_edge (edge, tree, tree, tree, tree,\n \t\t\t\t\t       tree *, tree *, struct loop *);\n extern struct loop * duplicate_loop (struct loop *, struct loop *);\n+extern void duplicate_subloops (struct loop *, struct loop *);\n extern bool duplicate_loop_to_header_edge (struct loop *, edge, \n \t\t\t\t\t   unsigned, sbitmap, edge,\n  \t\t\t\t\t   VEC (edge, heap) **, int);"}, {"sha": "6f24415a72dd97374efa99f6cb2d63ee3dca65f0", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/487102294c3844ed86ff8689a55b7931608b9170/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/487102294c3844ed86ff8689a55b7931608b9170/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=487102294c3844ed86ff8689a55b7931608b9170", "patch": "@@ -32,7 +32,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"output.h\"\n #include \"tree-flow.h\"\n \n-static void duplicate_subloops (struct loop *, struct loop *);\n static void copy_loops_to (struct loop **, int,\n \t\t\t   struct loop *);\n static void loop_redirect_edge (edge, basic_block);\n@@ -886,7 +885,7 @@ duplicate_loop (struct loop *loop, struct loop *target)\n \n /* Copies structure of subloops of LOOP into TARGET loop, placing\n    newly created loops into loop tree.  */\n-static void\n+void\n duplicate_subloops (struct loop *loop, struct loop *target)\n {\n   struct loop *aloop, *cloop;"}, {"sha": "913d390f6841a8e0f027cd476eea483c8aa98ca6", "filename": "gcc/testsuite/gcc.dg/autopar/outer-1.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/487102294c3844ed86ff8689a55b7931608b9170/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fouter-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/487102294c3844ed86ff8689a55b7931608b9170/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fouter-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fouter-1.c?ref=487102294c3844ed86ff8689a55b7931608b9170", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-parallelize-loops=4 -fdump-tree-parloops-details -fdump-tree-optimized\" } */\n+\n+void abort (void);\n+\n+void parloop (int N)\n+{\n+  int i, j;\n+  int x[10000][10000];\n+\n+  for (i = 0; i < N; i++)\n+    for (j = 0; j < N; j++)\n+      x[i][j] = i + j + 3;\n+\n+  for (i = 0; i < N; i++)\n+    for (j = 0; j < N; j++)\n+      if (x[i][j] != i + j + 3)\n+\tabort ();\n+}\n+\n+int main(void)\n+{\n+  parloop(10000);\n+\n+  return 0;\n+}\n+\n+\n+/* Check that outer loop is parallelized.  */\n+/* { dg-final { scan-tree-dump-times \"parallelizing outer loop\" 1 \"parloops\" } } */\n+/* { dg-final { scan-tree-dump-times \"loopfn\" 5 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"parloops\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "351b3499e8984516db3d780ededeb8d1d9ce8687", "filename": "gcc/testsuite/gcc.dg/autopar/outer-2.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/487102294c3844ed86ff8689a55b7931608b9170/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fouter-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/487102294c3844ed86ff8689a55b7931608b9170/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fouter-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fouter-2.c?ref=487102294c3844ed86ff8689a55b7931608b9170", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-parallelize-loops=4 -fdump-tree-parloops-details -fdump-tree-optimized\" } */\n+\n+void abort (void);\n+\n+void parloop (int N)\n+{\n+  int i, j,ii;\n+  int x[400][10][400];\n+\n+for (ii = 0; ii < N; ii++)\n+  for (i = 0; i < N; i++)\n+    for (j = 0; j < N; j++)\n+      x[i][j][ii] = ii+i + j + 3;\n+\n+for (ii = 0; ii < N; ii++)\n+  for (i = 0; i < N;i++)\n+    for (j = 0; j < N; j++)\n+      if (x[i][j][ii] != ii+i + j + 3)\n+\tabort ();\n+}\n+\n+int main(void)\n+{\n+  parloop(400);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"parallelizing outer loop\" 1 \"parloops\" } } */\n+/* { dg-final { scan-tree-dump-times \"loopfn\" 5 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"parloops\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "2f1033f9830493c32cac65b3fcceee1a3eaa6be3", "filename": "gcc/testsuite/gcc.dg/autopar/outer-3.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/487102294c3844ed86ff8689a55b7931608b9170/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fouter-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/487102294c3844ed86ff8689a55b7931608b9170/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fouter-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fouter-3.c?ref=487102294c3844ed86ff8689a55b7931608b9170", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-parallelize-loops=4 -fdump-tree-parloops-details -fdump-tree-optimized\" } */\n+\n+void abort (void);\n+\n+void parloop (int N)\n+{\n+  int i, j;\n+  int x[500][500];\n+\n+  for (i = 0; i < N; i++)\n+    for (j = 0; j < i; j++)\n+      x[i][j] = i + j + 3;\n+\n+  for (i = 0; i < N; i++)\n+    for (j = 0; j < i; j++)\n+      if (x[i][j] != i + j + 3)\n+\tabort ();\n+}\n+\n+int main(void)\n+{\n+  parloop(500);\n+\n+  return 0;\n+}\n+\n+\n+/* Check that outer loop is parallelized.  */\n+/* { dg-final { scan-tree-dump-times \"parallelizing outer loop\" 1 \"parloops\" } } */\n+/* { dg-final { scan-tree-dump-times \"loopfn\" 5 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"parloops\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "d6ad687d4085c6d1aa800c729e2e3adbe4cd3a3d", "filename": "gcc/testsuite/gcc.dg/autopar/outer-4.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/487102294c3844ed86ff8689a55b7931608b9170/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fouter-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/487102294c3844ed86ff8689a55b7931608b9170/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fouter-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fouter-4.c?ref=487102294c3844ed86ff8689a55b7931608b9170", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-parallelize-loops=4 -fdump-tree-parloops-details -fdump-tree-optimized\" } */\n+\n+void abort (void);\n+\n+int g_sum=0;\n+int x[500][500];\n+\n+__attribute__((noinline))\n+void parloop (int N)\n+{\n+  int i, j;\n+  int sum;\n+\n+  /* Double reduction is currently not supported, outer loop is not \n+     parallelized.  Inner reduction is detected, inner loop is \n+     parallelized.  */\n+  sum = 0;\n+  for (i = 0; i < N; i++)\n+    for (j = 0; j < N; j++)\n+      sum += x[i][j];\n+\n+  g_sum = sum;\n+}\n+\n+int main(void)\n+{\n+  parloop(500);\n+\n+  return 0;\n+}\n+\n+\n+/* Check that outer loop is parallelized.  */\n+/* { dg-final { scan-tree-dump-times \"parallelizing outer loop\" 0 \"parloops\" } } */\n+/* { dg-final { scan-tree-dump-times \"parallelizing inner loop\" 1 \"parloops\" } } */\n+/* { dg-final { cleanup-tree-dump \"parloops\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "e172b3f93327c0ddbe9f77206d831085ab0a1882", "filename": "gcc/testsuite/gcc.dg/autopar/outer-5.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/487102294c3844ed86ff8689a55b7931608b9170/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fouter-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/487102294c3844ed86ff8689a55b7931608b9170/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fouter-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fouter-5.c?ref=487102294c3844ed86ff8689a55b7931608b9170", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-parallelize-loops=4 -fdump-tree-parloops-details -fdump-tree-optimized\" } */\n+\n+void abort (void);\n+\n+int x[500][500];\n+int y[500];\n+int g_sum=0;\n+\n+__attribute__((noinline))\n+void init (int i, int j)\n+{\n+  x[i][j]=1;\n+}\n+\n+__attribute__((noinline))\n+void parloop (int N)\n+{\n+  int i, j;\n+  int sum;\n+\n+  /* Inner cycle is currently not supported, outer loop is not \n+     parallelized.  Inner reduction is detected, inner loop is \n+     parallelized.  */\n+  for (i = 0; i < N; i++)\n+  {\n+    sum = 0;\n+    for (j = 0; j < N; j++)\n+      sum += x[i][j];\n+    y[i]=sum;\n+  }\n+  g_sum = sum;\n+}\n+\n+int main(void)\n+{\n+  int i,j;\n+  for (i = 0; i < 500; i++) \n+    for (j = 0; j < 500; j++)\n+      init(i, j);\n+  \n+  parloop(500);\n+\n+  return 0;\n+}\n+\n+\n+/* Check that outer loop is parallelized.  */\n+/* { dg-final { scan-tree-dump-times \"parallelizing outer loop\" 0 \"parloops\" } } */\n+/* { dg-final { scan-tree-dump-times \"parallelizing inner loop\" 1 \"parloops\" } } */\n+/* { dg-final { cleanup-tree-dump \"parloops\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "67b89d05982425b71b0d31f8ea369395faf9099f", "filename": "gcc/testsuite/gcc.dg/autopar/outer-6.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/487102294c3844ed86ff8689a55b7931608b9170/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fouter-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/487102294c3844ed86ff8689a55b7931608b9170/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fouter-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fouter-6.c?ref=487102294c3844ed86ff8689a55b7931608b9170", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-parallelize-loops=4 -fdump-tree-parloops-details -fdump-tree-optimized\" } */\n+\n+void abort (void);\n+\n+int x[500][500];\n+int y[500];\n+int g_sum=0;\n+\n+__attribute__((noinline))\n+void init (int i, int j)\n+{\n+  x[i][j]=1;\n+}\n+\n+__attribute__((noinline))\n+void parloop (int N)\n+{\n+  int i, j;\n+  int sum;\n+\n+  /* Outer loop reduction, outerloop is parallelized.  */ \n+  sum=0;\n+  for (i = 0; i < N; i++)\n+  {\n+    for (j = 0; j < N; j++)\n+      y[i]=x[i][j];\n+    sum += y[i];\n+  }\n+  g_sum = sum;\n+}\n+\n+int main(void)\n+{\n+  int i,j;\n+  for (i = 0; i < 500; i++) \n+    for (j = 0; j < 500; j++)\n+      init(i, j);\n+  \n+  parloop(500);\n+\n+  return 0;\n+}\n+\n+\n+/* Check that outer loop is parallelized.  */\n+/* { dg-final { scan-tree-dump-times \"parallelizing outer loop\" 1 \"parloops\" } } */\n+/* { dg-final { scan-tree-dump-times \"parallelizing inner loop\" 0 \"parloops\" } } */\n+/* { dg-final { cleanup-tree-dump \"parloops\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "7f31868ea7b6f398d0bc9d4c3d8087a039109eac", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 131, "deletions": 15, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/487102294c3844ed86ff8689a55b7931608b9170/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/487102294c3844ed86ff8689a55b7931608b9170/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=487102294c3844ed86ff8689a55b7931608b9170", "patch": "@@ -4850,6 +4850,31 @@ gimple_duplicate_bb (basic_block bb)\n   return new_bb;\n }\n \n+/* Add phi arguments to the phi nodes in E_COPY->dest according to \n+   the phi arguments coming from the equivalent edge at\n+   the phi nodes of DEST.  */\n+\n+static void\n+add_phi_args_after_redirect (edge e_copy, edge orig_e)\n+{\n+   gimple_stmt_iterator psi, psi_copy;\n+   gimple phi, phi_copy;\n+   tree def; \n+   \n+    for (psi = gsi_start_phis (orig_e->dest),\n+       psi_copy = gsi_start_phis (e_copy->dest);\n+       !gsi_end_p (psi);\n+       gsi_next (&psi), gsi_next (&psi_copy))\n+    {\n+\n+      phi = gsi_stmt (psi);\n+      phi_copy = gsi_stmt (psi_copy);\n+      def = PHI_ARG_DEF_FROM_EDGE (phi, orig_e);\n+      add_phi_arg (phi_copy, def, e_copy,\n+                   gimple_phi_arg_location_from_edge (phi, orig_e));\n+    }\n+}\n+\n /* Adds phi node arguments for edge E_COPY after basic block duplication.  */\n \n static void\n@@ -5131,9 +5156,14 @@ gimple_duplicate_sese_tail (edge entry ATTRIBUTE_UNUSED, edge exit ATTRIBUTE_UNU\n   int total_freq = 0, exit_freq = 0;\n   gcov_type total_count = 0, exit_count = 0;\n   edge exits[2], nexits[2], e;\n-  gimple_stmt_iterator gsi;\n+  gimple_stmt_iterator gsi,gsi1;\n   gimple cond_stmt;\n-  edge sorig, snew;\n+  edge sorig, snew, orig_e;\n+  basic_block exit_bb;\n+  edge_iterator ei;\n+  VEC (edge, heap) *redirect_edges;\n+  basic_block iters_bb, orig_src;\n+  tree new_rhs;\n \n   gcc_assert (EDGE_COUNT (exit->src->succs) == 2);\n   exits[0] = exit;\n@@ -5149,17 +5179,13 @@ gimple_duplicate_sese_tail (edge entry ATTRIBUTE_UNUSED, edge exit ATTRIBUTE_UNU\n      it will work, but the resulting code will not be correct.  */\n   for (i = 0; i < n_region; i++)\n     {\n-      /* We do not handle subloops, i.e. all the blocks must belong to the\n-\t same loop.  */\n-      if (region[i]->loop_father != orig_loop)\n-\treturn false;\n-\n       if (region[i] == orig_loop->latch)\n \treturn false;\n     }\n \n   initialize_original_copy_tables ();\n   set_loop_copy (orig_loop, loop);\n+  duplicate_subloops (orig_loop, loop);\n \n   if (!region_copy)\n     {\n@@ -5225,8 +5251,36 @@ gimple_duplicate_sese_tail (edge entry ATTRIBUTE_UNUSED, edge exit ATTRIBUTE_UNU\n   cond_stmt = last_stmt (exit->src);\n   gcc_assert (gimple_code (cond_stmt) == GIMPLE_COND);\n   cond_stmt = gimple_copy (cond_stmt);\n+ \n+ /* If the block consisting of the exit condition has the latch as \n+    successor, then the body of the loop is executed before \n+    the exit consition is tested.  In such case, moving the \n+    condition to the entry, causes that the loop will iterate  \n+    one less iteration (which is the wanted outcome, since we \n+    peel out the last iteration).  If the body is executed after \n+    the condition, moving the condition to the entry requires \n+    decrementing one iteration.  */\n+  if (exits[1]->dest == orig_loop->latch)\n+    new_rhs = gimple_cond_rhs (cond_stmt);\n+  else\n+  {\n+    new_rhs = fold_build2 (MINUS_EXPR, TREE_TYPE (gimple_cond_rhs (cond_stmt)),\n+\t\t\t   gimple_cond_rhs (cond_stmt), \n+\t\t\t   build_int_cst (TREE_TYPE (gimple_cond_rhs (cond_stmt)), 1));\n+\n+    if (TREE_CODE (gimple_cond_rhs (cond_stmt)) == SSA_NAME)\n+      {\n+\titers_bb = gimple_bb (SSA_NAME_DEF_STMT (gimple_cond_rhs (cond_stmt)));\n+\tfor (gsi1 = gsi_start_bb (iters_bb); !gsi_end_p (gsi1); gsi_next (&gsi1))\n+\t  if (gsi_stmt (gsi1)==SSA_NAME_DEF_STMT (gimple_cond_rhs (cond_stmt)))\n+\t    break;\n+\t\t \n+\tnew_rhs = force_gimple_operand_gsi (&gsi1, new_rhs, true,\n+\t\t\t\t\t    NULL_TREE,false,GSI_CONTINUE_LINKING);\n+      }\n+  }   \n+  gimple_cond_set_rhs (cond_stmt, unshare_expr (new_rhs)); \n   gimple_cond_set_lhs (cond_stmt, unshare_expr (gimple_cond_lhs (cond_stmt)));\n-  gimple_cond_set_rhs (cond_stmt, unshare_expr (gimple_cond_rhs (cond_stmt)));\n   gsi_insert_after (&gsi, cond_stmt, GSI_NEW_STMT);\n \n   sorig = single_succ_edge (switch_bb);\n@@ -5238,25 +5292,87 @@ gimple_duplicate_sese_tail (edge entry ATTRIBUTE_UNUSED, edge exit ATTRIBUTE_UNU\n \n   /* Add the PHI node arguments.  */\n   add_phi_args_after_copy (region_copy, n_region, snew);\n-\n+  \n   /* Get rid of now superfluous conditions and associated edges (and phi node\n      arguments).  */\n+  exit_bb = exit->dest;\n+ \n   e = redirect_edge_and_branch (exits[0], exits[1]->dest);\n   PENDING_STMT (e) = NULL;\n-  e = redirect_edge_and_branch (nexits[1], nexits[0]->dest);\n-  PENDING_STMT (e) = NULL;\n-\n+ \n+  /* If the block consisting of the exit condition has the latch as \n+     successor, then the body of the loop is executed before \n+     the exit consition is tested.  \n+     \n+     { body  }\n+     { cond  } (exit[0])  -> { latch }\n+        |      \n+\tV (exit[1])\n+\t \n+     { exit_bb }\n+     \n+     \n+     In such case, the equivalent copied edge nexits[1]\n+     (for the peeled iteration) needs to be redirected to exit_bb.\n+     \n+     Otherwise, \n+     \n+     { cond  } (exit[0])  -> { body }\n+        |\n+\tV (exit[1])\n+     \n+     { exit_bb }\n+    \n+     \n+     exit[0] is pointing to the body of the loop,\n+     and the equivalent nexits[0] needs to be redirected to \n+     the copied body (of the peeled iteration).  */ \n+    \n+  if (exits[1]->dest == orig_loop->latch)\n+    e = redirect_edge_and_branch (nexits[1], nexits[0]->dest);\n+  else\n+    e = redirect_edge_and_branch (nexits[0], nexits[1]->dest);\n+  PENDING_STMT (e) = NULL; \n+  \n+  redirect_edges = VEC_alloc (edge, heap, 10);\n+  \n+  for (i = 0; i < n_region; i++)\n+    region_copy[i]->flags |= BB_DUPLICATED;\n+  \n+  /* Iterate all incoming edges to latch.  All those coming from \n+     copied bbs will be redicrecred to exit_bb.  */\n+  FOR_EACH_EDGE (e, ei, orig_loop->latch->preds)\n+    {\n+      if (e->src->flags & BB_DUPLICATED)\n+        VEC_safe_push (edge, heap, redirect_edges, e);\n+    }\n+  \n+  for (i = 0; i < n_region; i++)\n+    region_copy[i]->flags &= ~BB_DUPLICATED;\n+  \n+  for (i = 0; VEC_iterate (edge, redirect_edges, i, e); ++i)\n+    {\n+      e = redirect_edge_and_branch (e, exit_bb);\n+      PENDING_STMT (e) = NULL;\n+      orig_src = get_bb_original (e->src);\n+      orig_e = find_edge (orig_src, orig_loop->latch);\n+      add_phi_args_after_redirect (e, orig_e);\n+    }\n+  \n+  VEC_free (edge, heap, redirect_edges);\n+  \n+  \n   /* Anything that is outside of the region, but was dominated by something\n      inside needs to update dominance info.  */\n   iterate_fix_dominators (CDI_DOMINATORS, doms, false);\n   VEC_free (basic_block, heap, doms);\n-\n+  \n   /* Update the SSA web.  */\n   update_ssa (TODO_update_ssa);\n-\n+  \n   if (free_region_copy)\n     free (region_copy);\n-\n+  \n   free_original_copy_tables ();\n   return true;\n }"}, {"sha": "61e372a54c33f431a0234dbfe08801b132eaf0bd", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 50, "deletions": 16, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/487102294c3844ed86ff8689a55b7931608b9170/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/487102294c3844ed86ff8689a55b7931608b9170/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=487102294c3844ed86ff8689a55b7931608b9170", "patch": "@@ -255,7 +255,13 @@ loop_parallel_p (struct loop *loop)\n   bool ret = false;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"\\nConsidering loop %d\\n\", loop->num);\n+  {\n+    fprintf (dump_file, \"Considering loop %d\\n\", loop->num);\n+    if (!loop->inner)\n+      fprintf (dump_file, \"loop is innermost\\n\");\n+    else \n+      fprintf (dump_file, \"loop NOT innermost\\n\");\n+   }\n \n   /* Check for problems with dependences.  If the loop can be reversed,\n      the iterations are independent.  */\n@@ -1289,8 +1295,9 @@ transform_to_exit_first_loop (struct loop *loop, htab_t reduction_list, tree nit\n   bool ok;\n   edge exit = single_dom_exit (loop), hpred;\n   tree control, control_name, res, t;\n-  gimple phi, nphi, cond_stmt, stmt;\n+  gimple phi, nphi, cond_stmt, stmt, cond_nit;\n   gimple_stmt_iterator gsi;\n+  tree nit_1;\n \n   split_block_after_labels (loop->header);\n   orig_header = single_succ (loop->header);\n@@ -1308,7 +1315,6 @@ transform_to_exit_first_loop (struct loop *loop, htab_t reduction_list, tree nit\n       res = PHI_RESULT (phi);\n       t = make_ssa_name (SSA_NAME_VAR (res), phi);\n       SET_PHI_RESULT (phi, t);\n-\n       nphi = create_phi_node (res, orig_header);\n       SSA_NAME_DEF_STMT (res) = nphi;\n       add_phi_arg (nphi, t, hpred, UNKNOWN_LOCATION);\n@@ -1320,10 +1326,11 @@ transform_to_exit_first_loop (struct loop *loop, htab_t reduction_list, tree nit\n \t  control = t;\n \t}\n     }\n-\n   bbs = get_loop_body_in_dom_order (loop);\n-  for (n = 0; bbs[n] != exit->src; n++)\n+\n+  for (n = 0; bbs[n] != loop->latch; n++)\n     continue;\n+  n--;\n   nbbs = XNEWVEC (basic_block, n);\n   ok = gimple_duplicate_sese_tail (single_succ_edge (loop->header), exit,\n \t\t\t\t   bbs + 1, n, nbbs);\n@@ -1358,7 +1365,6 @@ transform_to_exit_first_loop (struct loop *loop, htab_t reduction_list, tree nit\n \t  struct reduction_info *red;\n \n \t  tree val = PHI_ARG_DEF_FROM_EDGE (phi, exit);\n-\n \t  red = reduction_phi (reduction_list, SSA_NAME_DEF_STMT (val));\n \t  if (red)\n \t    {\n@@ -1374,12 +1380,15 @@ transform_to_exit_first_loop (struct loop *loop, htab_t reduction_list, tree nit\n     }\n   gcc_assert (control_name != NULL_TREE);\n \n-  /* Initialize the control variable to NIT.  */\n+  /* Initialize the control variable to number of iterations \n+     according to the rhs of the exit condition.  */\n   gsi = gsi_after_labels (ex_bb);\n-  nit = force_gimple_operand_gsi (&gsi,\n-\t\t\t\t  fold_convert (TREE_TYPE (control_name), nit),\n+  cond_nit = last_stmt (exit->src); \n+  nit_1 =  gimple_cond_rhs (cond_nit);\n+  nit_1 = force_gimple_operand_gsi (&gsi,\n+\t\t\t\t  fold_convert (TREE_TYPE (control_name), nit_1),\n \t\t\t\t  false, NULL_TREE, false, GSI_SAME_STMT);\n-  stmt = gimple_build_assign (control_name, nit);\n+  stmt = gimple_build_assign (control_name, nit_1);\n   gsi_insert_before (&gsi, stmt, GSI_NEW_STMT);\n   SSA_NAME_DEF_STMT (control_name) = stmt;\n }\n@@ -1740,7 +1749,7 @@ gather_scalar_reductions (loop_p loop, htab_t reduction_list)\n \t&& simple_loop_info)\n \t{\n            gimple reduc_stmt = vect_is_simple_reduction (simple_loop_info, phi, true, &double_reduc);\n-\t   if (reduc_stmt)\n+\t   if (reduc_stmt && !double_reduc)\n               build_new_reduction (reduction_list, reduc_stmt, phi);\n         }\n     }\n@@ -1890,15 +1899,32 @@ parallelize_loops (void)\n   FOR_EACH_LOOP (li, loop, 0)\n     {\n       htab_empty (reduction_list);\n-\n-      /* If we use autopar in graphite pass, we use it's marked dependency\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+      {\n+        fprintf (dump_file, \"Trying loop %d as candidate\\n\",loop->num);\n+\tif (loop->inner)\n+\t  fprintf (dump_file, \"loop %d is not innermost\\n\",loop->num);\n+\telse\n+\t  fprintf (dump_file, \"loop %d is innermost\\n\",loop->num);\n+      }\n+      \n+      /* If we use autopar in graphite pass, we use its marked dependency\n       checking results.  */\n       if (flag_loop_parallelize_all && !loop->can_be_parallel)\n+      {\n+        if (dump_file && (dump_flags & TDF_DETAILS))\n+\t   fprintf (dump_file, \"loop is not parallel according to graphite\\n\");\n \tcontinue;\n+      }\n \n-      /* FIXME: Only consider innermost loops with just one exit.  */\n-      if (loop->inner || !single_dom_exit (loop))\n+      if (!single_dom_exit (loop))\n+      {\n+       \n+        if (dump_file && (dump_flags & TDF_DETAILS))\n+\t  fprintf (dump_file, \"loop is !single_dom_exit\\n\");\n+\t\t\n \tcontinue;\n+      }\n \n       if (/* And of course, the loop must be parallelizable.  */\n \t  !can_duplicate_loop_p (loop)\n@@ -1915,7 +1941,7 @@ parallelize_loops (void)\n \t      /* Do not bother with loops in cold areas.  */\n \t      || optimize_loop_nest_for_size_p (loop)))\n \tcontinue;\n-\n+ \n       if (!try_get_loop_niter (loop, &niter_desc))\n \tcontinue;\n \n@@ -1926,6 +1952,14 @@ parallelize_loops (void)\n \tcontinue;\n \n       changed = true;\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+      {\n+        fprintf (dump_file, \"parallelizing \");\n+\tif (loop->inner)\n+\t  fprintf (dump_file, \"outer loop\\n\");\n+\telse\n+\t  fprintf (dump_file, \"inner loop\\n\");\n+      } \n       gen_parallel_loop (loop, reduction_list, \n \t\t\t n_threads, &niter_desc);\n       verify_flow_info ();"}, {"sha": "7f2c823f73ea2ae464341a950c6326ae1db0fbcc", "filename": "libgomp/testsuite/libgomp.graphite/force-parallel-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/487102294c3844ed86ff8689a55b7931608b9170/libgomp%2Ftestsuite%2Flibgomp.graphite%2Fforce-parallel-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/487102294c3844ed86ff8689a55b7931608b9170/libgomp%2Ftestsuite%2Flibgomp.graphite%2Fforce-parallel-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.graphite%2Fforce-parallel-2.c?ref=487102294c3844ed86ff8689a55b7931608b9170", "patch": "@@ -23,7 +23,7 @@ int main(void)\n }\n \n /* Check that parallel code generation part make the right answer.  */\n-/* { dg-final { scan-tree-dump-times \"2 loops carried no dependency\" 1 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump-times \"2 loops carried no dependency\" 2 \"graphite\" } } */\n /* { dg-final { cleanup-tree-dump \"graphite\" } } */\n /* { dg-final { scan-tree-dump-times \"loopfn\" 5 \"optimized\" } } */\n /* { dg-final { cleanup-tree-dump \"parloops\" } } */"}]}