{"sha": "12c789666901a1e60b362e7ddd05429aa44e1554", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTJjNzg5NjY2OTAxYTFlNjBiMzYyZTdkZGQwNTQyOWFhNDRlMTU1NA==", "commit": {"author": {"name": "Brooks Moses", "email": "brooks.moses@codesourcery.com", "date": "2006-11-15T04:00:35Z"}, "committer": {"name": "Brooks Moses", "email": "brooks@gcc.gnu.org", "date": "2006-11-15T04:00:35Z"}, "message": "re PR fortran/29702 (RFE: Column number in error messages.)\n\nPR fortran/29702\n* fortran/error.c (show_loci): Move column-offset calculation to\nshow_locus.\n(show_locus): Remove blank lines before \"Included in\"\nlines, clean up code, calculate column-offsets, print\ncolumn number is error-header lines as appropriate.\n(error_integer): (new function) Print integer to error\nbuffer.\n(error_print): Use error_integer, avoid possible buffer\noverflows from buggy error formats.\n* testsuite/lib/gfortran-dg.exp (gfortran-dg-test): Ignore column\nnumbers in error message headers.\n\nFrom-SVN: r118843", "tree": {"sha": "d7709ad3562ebe854f381be781123a0a692f8253", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d7709ad3562ebe854f381be781123a0a692f8253"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/12c789666901a1e60b362e7ddd05429aa44e1554", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12c789666901a1e60b362e7ddd05429aa44e1554", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12c789666901a1e60b362e7ddd05429aa44e1554", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12c789666901a1e60b362e7ddd05429aa44e1554/comments", "author": null, "committer": null, "parents": [{"sha": "1dde868307b85e9be0f93c6e0483b4eb818ef3cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1dde868307b85e9be0f93c6e0483b4eb818ef3cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1dde868307b85e9be0f93c6e0483b4eb818ef3cf"}], "stats": {"total": 315, "additions": 194, "deletions": 121}, "files": [{"sha": "501517adbe4536f95a400e909c4cf1b511acd5b2", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c789666901a1e60b362e7ddd05429aa44e1554/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c789666901a1e60b362e7ddd05429aa44e1554/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=12c789666901a1e60b362e7ddd05429aa44e1554", "patch": "@@ -1,3 +1,16 @@\n+2006-11-14  Brooks Moses  <brooks.moses@codesourcery.com>\n+\n+\tPR fortran/29702\n+\t* error.c (show_loci): Move column-offset calculation to\n+\tshow_locus.\n+\t(show_locus): Remove blank lines before \"Included in\"\n+\tlines, clean up code, calculate column-offsets, print\n+\tcolumn number is error-header lines as appropriate.\n+\t(error_integer): (new function) Print integer to error\n+\tbuffer.\n+\t(error_print): Use error_integer, avoid possible buffer\n+\toverflows from buggy error formats.\n+\n 2006-11-14  Brooks Moses  <brooks.moses@codesourcery.com>\n  \n  \t* gfortran.h (GFC_MAX_LINE): Remove constant definition."}, {"sha": "9c2d466d285c447f86e21a4eb85ad3ca785af186", "filename": "gcc/fortran/error.c", "status": "modified", "additions": 166, "deletions": 114, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c789666901a1e60b362e7ddd05429aa44e1554/gcc%2Ffortran%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c789666901a1e60b362e7ddd05429aa44e1554/gcc%2Ffortran%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ferror.c?ref=12c789666901a1e60b362e7ddd05429aa44e1554", "patch": "@@ -114,33 +114,87 @@ error_string (const char *p)\n }\n \n \n-/* Show the file, where it was included and the source line, give a\n+/* Print a formatted integer to the error buffer or output.  */\n+\n+#define IBUF_LEN 30\n+\n+static void\n+error_integer (int i)\n+{\n+  char *p, int_buf[IBUF_LEN];\n+\n+  if (i < 0)\n+    {\n+      i = -i;\n+      error_char ('-');\n+    }\n+\n+  p = int_buf + IBUF_LEN - 1;\n+  *p-- = '\\0';\n+\n+  if (i == 0)\n+    *p-- = '0';\n+\n+  while (i > 0)\n+    {\n+      *p-- = i % 10 + '0';\n+      i = i / 10;\n+    }\n+\n+  error_string (p + 1);\n+}\n+\n+\n+/* Show the file, where it was included, and the source line, give a\n    locus.  Calls error_printf() recursively, but the recursion is at\n    most one level deep.  */\n \n static void error_printf (const char *, ...) ATTRIBUTE_GCC_GFC(1,2);\n \n static void\n-show_locus (int offset, locus * loc)\n+show_locus (locus * loc, int c1, int c2)\n {\n   gfc_linebuf *lb;\n   gfc_file *f;\n   char c, *p;\n-  int i, m;\n+  int i, m, offset, cmax;\n \n   /* TODO: Either limit the total length and number of included files\n      displayed or add buffering of arbitrary number of characters in\n      error messages.  */\n \n+  /* Write out the error header line, giving the source file and error\n+     location (in GNU standard \"[file]:[line].[column]:\" format),\n+     followed by an \"included by\" stack and a blank line.  This header\n+     format is matched by a testsuite parser defined in\n+     lib/gfortran-dg.exp.  */\n+\n   lb = loc->lb;\n   f = lb->file;\n-  error_printf (\"%s:%d:\\n\", f->filename,\n+\n+  error_string (f->filename);\n+  error_char (':');\n+    \n #ifdef USE_MAPPED_LOCATION\n-\t\tLOCATION_LINE (lb->location)\n+  error_integer (LOCATION_LINE (lb->location));\n #else\n-\t\tlb->linenum\n+  error_integer (lb->linenum);\n #endif\n-\t\t);\n+\n+  if ((c1 > 0) || (c2 > 0))\n+    error_char ('.');\n+\n+  if (c1 > 0)\n+    error_integer (c1);\n+\n+  if ((c1 > 0) && (c2 > 0))\n+    error_char ('-');\n+\n+  if (c2 > 0)\n+    error_integer (c2);\n+\n+  error_char (':');\n+  error_char ('\\n');\n \n   for (;;)\n     {\n@@ -149,11 +203,51 @@ show_locus (int offset, locus * loc)\n       f = f->included_by;\n       if (f == NULL) break;\n \n-      error_printf (\"    Included at %s:%d\\n\", f->filename, i);\n+      error_printf (\"    Included at %s:%d:\", f->filename, i);\n     }\n \n+  error_char ('\\n');\n+\n+  /* Calculate an appropriate horizontal offset of the source line in\n+     order to get the error locus within the visible portion of the\n+     line.  Note that if the margin of 5 here is changed, the\n+     corresponding margin of 10 in show_loci should be changed.  */\n+\n+  offset = 0;\n+\n+  /* When the loci is not associated with a column, it will have a\n+     value of zero.  We adjust this to 1 so that it will appear.  */\n+     \n+  if (c1 == 0)\n+    c1 = 1;\n+  if (c2 == 0)\n+    c2 = 1;\n+\n+  /* If the two loci would appear in the same column, we shift\n+     '2' one column to the right, so as to print '12' rather than\n+     just '1'.  We do this here so it will be accounted for in the\n+     margin calculations.  */\n+\n+  if (c1 == c2)\n+    c2 += 1;\n+\n+  cmax = (c1 < c2) ? c2 : c1;\n+  if (cmax > terminal_width - 5)\n+    offset = cmax - terminal_width + 5;\n+\n+  /* TODO: Is there a good reason for the following apparently-redundant\n+     check, and the similar ones in the single-locus cases below?  */\n+\n+  if (offset < 0)\n+    offset = 0;\n+\n   /* Show the line itself, taking care not to print more than what can\n-     show up on the terminal.  Tabs are converted to spaces.  */\n+     show up on the terminal.  Tabs are converted to spaces, and \n+     nonprintable characters are converted to a \"\\xNN\" sequence.  */\n+\n+  /* TODO: Although setting i to the terminal width is clever, it fails\n+     to work correctly when nonprintable characters exist.  A better \n+     solution should be found.  */\n \n   p = lb->line + offset;\n   i = strlen (p);\n@@ -186,29 +280,54 @@ show_locus (int offset, locus * loc)\n     }\n \n   error_char ('\\n');\n+\n+  /* Show the '1' and/or '2' corresponding to the column of the error\n+     locus.  Note that a value of -1 for c1 or c2 will simply cause \n+     the relevant number not to be printed.  */\n+\n+  c1 -= offset;\n+  c2 -= offset;\n+\n+  for (i = 1; i <= cmax; i++)\n+    {\n+      if (i == c1)\n+\terror_char ('1');\n+      else if (i == c2)\n+\terror_char ('2');\n+      else\n+\terror_char (' ');\n+    }\n+\n+  error_char ('\\n');\n+\n }\n \n \n /* As part of printing an error, we show the source lines that caused\n-   the problem.  We show at least one, possibly two loci.  If we're\n-   showing two loci and they both refer to the same file and line, we\n-   only print the line once.  */\n+   the problem.  We show at least one, and possibly two loci; the two\n+   loci may or may not be on the same source line.  */\n \n static void\n show_loci (locus * l1, locus * l2)\n {\n-  int offset, flag, i, m, c1, c2, cmax;\n+  int m, c1, c2;\n \n   if (l1 == NULL || l1->lb == NULL)\n     {\n       error_printf (\"<During initialization>\\n\");\n       return;\n     }\n \n+  /* While calculating parameters for printing the loci, we consider possible\n+     reasons for printing one per line.  If appropriate, print the loci\n+     individually; otherwise we print them both on the same line.  */\n+\n   c1 = l1->nextc - l1->lb->line;\n-  c2 = 0;\n   if (l2 == NULL)\n-    goto separate;\n+    {\n+      show_locus (l1, c1, -1);\n+      return;\n+    }\n \n   c2 = l2->nextc - l2->lb->line;\n \n@@ -217,108 +336,50 @@ show_loci (locus * l1, locus * l2)\n   else\n     m = c1 - c2;\n \n+  /* Note that the margin value of 10 here needs to be less than the \n+     margin of 5 used in the calculation of offset in show_locus.  */\n \n   if (l1->lb != l2->lb || m > terminal_width - 10)\n-    goto separate;\n-\n-  offset = 0;\n-  cmax = (c1 < c2) ? c2 : c1;\n-  if (cmax > terminal_width - 5)\n-    offset = cmax - terminal_width + 5;\n-\n-  if (offset < 0)\n-    offset = 0;\n-\n-  c1 -= offset;\n-  c2 -= offset;\n-\n-  show_locus (offset, l1);\n-\n-  /* Arrange that '1' and '2' will show up even if the two columns are equal.  */\n-  for (i = 1; i <= cmax; i++)\n     {\n-      flag = 0;\n-      if (i == c1)\n-\t{\n-\t  error_char ('1');\n-\t  flag = 1;\n-\t}\n-      if (i == c2)\n-\t{\n-\t  error_char ('2');\n-\t  flag = 1;\n-\t}\n-      if (flag == 0)\n-\terror_char (' ');\n+      show_locus (l1, c1, -1);\n+      show_locus (l2, -1, c2);\n+      return;\n     }\n \n-  error_char ('\\n');\n+  show_locus (l1, c1, c2);\n \n   return;\n \n-separate:\n-  offset = 0;\n-\n-  if (c1 > terminal_width - 5)\n-    {\n-      offset = c1 - 5;\n-      if (offset < 0)\n-\toffset = 0;\n-      c1 = c1 - offset;\n-    }\n-\n-  show_locus (offset, l1);\n-  for (i = 1; i < c1; i++)\n-    error_char (' ');\n-\n-  error_char ('1');\n-  error_char ('\\n');\n-\n-  if (l2 != NULL)\n-    {\n-      offset = 0;\n-\n-      if (c2 > terminal_width - 20)\n-\t{\n-\t  offset = c2 - 20;\n-\t  if (offset < 0)\n-\t    offset = 0;\n-\t  c2 = c2 - offset;\n-\t}\n-\n-      show_locus (offset, l2);\n-\n-      for (i = 1; i < c2; i++)\n-\terror_char (' ');\n-\n-      error_char ('2');\n-      error_char ('\\n');\n-    }\n }\n \n \n /* Workhorse for the error printing subroutines.  This subroutine is\n    inspired by g77's error handling and is similar to printf() with\n    the following %-codes:\n \n-   %c Character, %d Integer, %s String, %% Percent\n+   %c Character, %d or %i Integer, %s String, %% Percent\n    %L  Takes locus argument\n    %C  Current locus (no argument)\n \n    If a locus pointer is given, the actual source line is printed out\n    and the column is indicated.  Since we want the error message at\n    the bottom of any source file information, we must scan the\n-   argument list twice.  A maximum of two locus arguments are\n-   permitted.  */\n+   argument list twice -- once to determine whether the loci are \n+   present and record this for printing, and once to print the error\n+   message after and loci have been printed.  A maximum of two locus\n+   arguments are permitted.\n+   \n+   This function is also called (recursively) by show_locus in the\n+   case of included files; however, as show_locus does not resupply\n+   any loci, the recursion is at most one level deep.  */\n \n-#define IBUF_LEN 30\n #define MAX_ARGS 10\n \n static void ATTRIBUTE_GCC_GFC(2,0)\n error_print (const char *type, const char *format0, va_list argp)\n {\n-  char c, *p, int_buf[IBUF_LEN], c_arg[MAX_ARGS], *cp_arg[MAX_ARGS];\n-  int i, n, have_l1, i_arg[MAX_ARGS];\n+  char c, c_arg[MAX_ARGS], *cp_arg[MAX_ARGS];\n+  int n, have_l1, i_arg[MAX_ARGS];\n   locus *l1, *l2, *loc;\n   const char *format;\n \n@@ -372,16 +433,23 @@ error_print (const char *type, const char *format0, va_list argp)\n \t    case 's':\n \t      cp_arg[n++] = va_arg (argp, char *);\n \t      break;\n+\n+\t    case '\\0':\n+\t      format--;\n+\t      break;\n \t    }\n \t}\n     }\n \n   /* Show the current loci if we have to.  */\n   if (have_l1)\n     show_loci (l1, l2);\n-  error_string (type);\n+\n   if (*type)\n-    error_char (' ');\n+    {\n+      error_string (type);\n+      error_char (' ');\n+    }\n \n   have_l1 = 0;\n   format = format0;\n@@ -410,36 +478,20 @@ error_print (const char *type, const char *format0, va_list argp)\n \t  error_string (cp_arg[n++]);\n \t  break;\n \n-\tcase 'i':\n \tcase 'd':\n-\t  i = i_arg[n++];\n-\n-\t  if (i < 0)\n-\t    {\n-\t      i = -i;\n-\t      error_char ('-');\n-\t    }\n-\n-\t  p = int_buf + IBUF_LEN - 1;\n-\t  *p-- = '\\0';\n-\n-\t  if (i == 0)\n-\t    *p-- = '0';\n-\n-\t  while (i > 0)\n-\t    {\n-\t      *p-- = i % 10 + '0';\n-\t      i = i / 10;\n-\t    }\n-\n-\t  error_string (p + 1);\n+\tcase 'i':\n+\t  error_integer (i_arg[n++]);\n \t  break;\n \n \tcase 'C':\t\t/* Current locus */\n \tcase 'L':\t\t/* Specified locus */\n \t  error_string (have_l1 ? \"(2)\" : \"(1)\");\n \t  have_l1 = 1;\n \t  break;\n+\n+\tcase '\\0':\n+\t  format--;\n+\t  break;\n \t}\n     }\n "}, {"sha": "73486b10ce11fa0b609c6d84198135b46908cbe0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c789666901a1e60b362e7ddd05429aa44e1554/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c789666901a1e60b362e7ddd05429aa44e1554/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=12c789666901a1e60b362e7ddd05429aa44e1554", "patch": "@@ -1,3 +1,9 @@\n+2006-11-14  Brooks Moses  <brooks.moses@codesourcery.com>\n+\n+\tPR fortran/29702\n+\t* lib/gfortran-dg.exp (gfortran-dg-test): Ignore column\n+\tnumbers in error message headers.\n+\n 2006-11-14  Richard Guenther  <rguenther@suse.de>\n \n \t* gcc.target/i386/math-torture/math-torture.exp: Restrict"}, {"sha": "5a16a39a4cd4fcfe5b26e360e00681f0f1e0bab7", "filename": "gcc/testsuite/lib/gfortran-dg.exp", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c789666901a1e60b362e7ddd05429aa44e1554/gcc%2Ftestsuite%2Flib%2Fgfortran-dg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c789666901a1e60b362e7ddd05429aa44e1554/gcc%2Ftestsuite%2Flib%2Fgfortran-dg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fgfortran-dg.exp?ref=12c789666901a1e60b362e7ddd05429aa44e1554", "patch": "@@ -26,28 +26,30 @@ proc gfortran-dg-test { prog do_what extra_tool_flags } {\n     set output_file [lindex $result 1]\n \n     # gfortran error messages look like this:\n-    #     [name]:[line]:\n+    #     [name]:[locus]:\n     #\n     #        some code\n     #              1\n     #     Error: Some error at (1)\n     # or\n-    #     [name]:[line]:\n+    #     [name]:[locus]:\n     #\n     #       some code\n     #              1\n-    #     [name]:[line2]:\n+    #     [name]:[locus2]:\n     #\n     #       some other code\n     #         2\n     #     Error: Some error at (1) and (2)\n     # or\n-    #     [name]:[line]:\n+    #     [name]:[locus]:\n     #\n     #       some code and some more code\n     #              1       2\n     #     Error: Some error at (1) and (2)\n     #\n+    # Where [locus] is either [line] or [line].[columns] .\n+    #\n     # We collapse these to look like:\n     #  [name]:[line]: Error: Some error at (1) and (2)\n     # or\n@@ -59,13 +61,13 @@ proc gfortran-dg-test { prog do_what extra_tool_flags } {\n     # Note that these regexps only make sense in the combinations used below.\n     # Note also that is imperative that we first deal with the form with\n     # two loci.\n-    set locus_regexp \"(\\[^\\n\\]*):\\n\\n\\[^\\n\\]*\\n\\[^\\n\\]*\\n\"\n+    set locus_regexp \"(\\[^\\n\\]*):(\\[0-9\\]*)\\[^\\n\\]*:\\n\\n\\[^\\n\\]*\\n\\[^\\n\\]*\\n\"\n     set diag_regexp \"(\\[^\\n\\]*)\\n\"\n \n     set two_loci \"$locus_regexp$locus_regexp$diag_regexp\"\n     set single_locus \"$locus_regexp$diag_regexp\"\n-    regsub -all $two_loci $comp_output \"\\\\1: \\\\3\\n\\\\2: \\\\3\\n\" comp_output\n-    regsub -all $single_locus $comp_output \"\\\\1: \\\\2\\n\" comp_output\n+    regsub -all $two_loci $comp_output \"\\\\1:\\\\2: \\\\5\\n\\\\3:\\\\4: \\\\5\\n\" comp_output\n+    regsub -all $single_locus $comp_output \"\\\\1:\\\\2: \\\\3\\n\" comp_output\n \n     return [list $comp_output $output_file]\n }"}]}