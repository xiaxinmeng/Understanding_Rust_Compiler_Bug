{"sha": "eac188c5bcb1ed4f3fd61de2de2590dece32be2b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWFjMTg4YzViY2IxZWQ0ZjNmZDYxZGUyZGUyNTkwZGVjZTMyYmUyYg==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "avr@gjlay.de", "date": "2012-05-09T16:28:53Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2012-05-09T16:28:53Z"}, "message": "re PR target/53256 ([avr] Attribute 'interrupt' shall override attribute 'signal')\n\n\tPR target/53256\n\t* config/avr/elf.h (ASM_DECLARE_FUNCTION_NAME): Remove.\n\t* config/avr/avr-protos.h (avr_asm_declare_function_name): Remove.\n\t* config/avr/avr.h (struct machine_function): Add attributes_checked_p.\n\t* config/avr/avr.c (avr_asm_declare_function_name): Remove.\n\t(expand_prologue): Move initialization of cfun->machine->is_naked,\n\tis_interrupt, is_signal, is_OS_task, is_OS_main from here to...\n\t(avr_set_current_function): ...this new static function.\n\t(TARGET_SET_CURRENT_FUNCTION): New define.\n\t(avr_function_ok_for_sibcall): Use cfun->machine->is_* instead of\n\tchecking attributes of current_function_decl.\n\t(avr_regs_to_save): Ditto.\n\t(signal_function_p): Rename to avr_signal_function_p.\n\t(interrupt_function_p): Rename to avr_interrupt_function_p.\n\t* doc/extend.texi (Function Attributes): Better explanation of\n\t'interrupt' and 'signal' for AVR. Move 'ifunc' down to establish\n\talphabetical order.\n\nFrom-SVN: r187342", "tree": {"sha": "14aca0a603bf73054927ff0215465c4416a351f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/14aca0a603bf73054927ff0215465c4416a351f4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eac188c5bcb1ed4f3fd61de2de2590dece32be2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eac188c5bcb1ed4f3fd61de2de2590dece32be2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eac188c5bcb1ed4f3fd61de2de2590dece32be2b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eac188c5bcb1ed4f3fd61de2de2590dece32be2b/comments", "author": null, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b0d38e4e3934555341427ccd7217be0738f89b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b0d38e4e3934555341427ccd7217be0738f89b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b0d38e4e3934555341427ccd7217be0738f89b2"}], "stats": {"total": 295, "additions": 181, "deletions": 114}, "files": [{"sha": "f32e96f76b6b50bd9b1e291228d58416ff3203bb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac188c5bcb1ed4f3fd61de2de2590dece32be2b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac188c5bcb1ed4f3fd61de2de2590dece32be2b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eac188c5bcb1ed4f3fd61de2de2590dece32be2b", "patch": "@@ -1,3 +1,24 @@\n+2012-05-09  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tPR target/53256\n+\t* config/avr/elf.h (ASM_DECLARE_FUNCTION_NAME): Remove.\n+\t* config/avr/avr-protos.h (avr_asm_declare_function_name): Remove.\n+\t* config/avr/avr.h (struct machine_function): Add attributes_checked_p.\n+\t* config/avr/avr.c (avr_asm_declare_function_name): Remove.\n+\t(expand_prologue): Move initialization of cfun->machine->is_naked,\n+\tis_interrupt, is_signal, is_OS_task, is_OS_main from here to...\n+\t(avr_set_current_function): ...this new static function.\n+\t(TARGET_SET_CURRENT_FUNCTION): New define.\n+\t(avr_function_ok_for_sibcall): Use cfun->machine->is_* instead of\n+\tchecking attributes of current_function_decl.\n+\t(avr_regs_to_save): Ditto.\n+\t(signal_function_p): Rename to avr_signal_function_p.\n+\t(interrupt_function_p): Rename to avr_interrupt_function_p.\n+\n+\t* doc/extend.texi (Function Attributes): Better explanation of\n+\t'interrupt' and 'signal' for AVR. Move 'ifunc' down to establish\n+\talphabetical order.\n+\n 2012-05-09  Michael Matz  <matz@suse.de>\n \n \tPR tree-optimization/53185"}, {"sha": "fa1462ce886ea7167f4d88f8bc66b0aa0b4a0e77", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac188c5bcb1ed4f3fd61de2de2590dece32be2b/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac188c5bcb1ed4f3fd61de2de2590dece32be2b/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=eac188c5bcb1ed4f3fd61de2de2590dece32be2b", "patch": "@@ -26,7 +26,6 @@ extern int function_arg_regno_p (int r);\n extern void avr_cpu_cpp_builtins (struct cpp_reader * pfile);\n extern enum reg_class avr_regno_reg_class (int r);\n extern void asm_globalize_label (FILE *file, const char *name);\n-extern void avr_asm_declare_function_name (FILE *, const char *, tree);\n extern void order_regs_for_local_alloc (void);\n extern int avr_initial_elimination_offset (int from, int to);\n extern int avr_simple_epilogue (void);"}, {"sha": "5b28096d799e6ddf340ab0289bee304deb686935", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 88, "deletions": 58, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac188c5bcb1ed4f3fd61de2de2590dece32be2b/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac188c5bcb1ed4f3fd61de2de2590dece32be2b/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=eac188c5bcb1ed4f3fd61de2de2590dece32be2b", "patch": "@@ -138,12 +138,6 @@ static const char* out_movqi_mr_r (rtx, rtx[], int*);\n static const char* out_movhi_mr_r (rtx, rtx[], int*);\n static const char* out_movsi_mr_r (rtx, rtx[], int*);\n \n-static int avr_naked_function_p (tree);\n-static int interrupt_function_p (tree);\n-static int signal_function_p (tree);\n-static int avr_OS_task_function_p (tree);\n-static int avr_OS_main_function_p (tree);\n-static int avr_regs_to_save (HARD_REG_SET *);\n static int get_sequence_length (rtx insns);\n static int sequent_regs_live (void);\n static const char *ptrreg_to_str (int);\n@@ -491,7 +485,7 @@ avr_naked_function_p (tree func)\n    by the \"interrupt\" attribute.  */\n \n static int\n-interrupt_function_p (tree func)\n+avr_interrupt_function_p (tree func)\n {\n   return avr_lookup_function_attribute1 (func, \"interrupt\");\n }\n@@ -500,7 +494,7 @@ interrupt_function_p (tree func)\n    by the \"signal\" attribute.  */\n \n static int\n-signal_function_p (tree func)\n+avr_signal_function_p (tree func)\n {\n   return avr_lookup_function_attribute1 (func, \"signal\");\n }\n@@ -522,6 +516,80 @@ avr_OS_main_function_p (tree func)\n }\n \n \n+/* Implement `TARGET_SET_CURRENT_FUNCTION'.  */\n+/* Sanity cheching for above function attributes.  */\n+\n+static void\n+avr_set_current_function (tree decl)\n+{\n+  location_t loc;\n+  const char *isr;\n+\n+  if (decl == NULL_TREE\n+      || current_function_decl == NULL_TREE\n+      || current_function_decl == error_mark_node\n+      || cfun->machine->attributes_checked_p)\n+    return;\n+\n+  loc = DECL_SOURCE_LOCATION (decl);\n+\n+  cfun->machine->is_naked = avr_naked_function_p (decl);\n+  cfun->machine->is_signal = avr_signal_function_p (decl);\n+  cfun->machine->is_interrupt = avr_interrupt_function_p (decl);\n+  cfun->machine->is_OS_task = avr_OS_task_function_p (decl);\n+  cfun->machine->is_OS_main = avr_OS_main_function_p (decl);\n+\n+  isr = cfun->machine->is_interrupt ? \"interrupt\" : \"signal\";\n+\n+  /* Too much attributes make no sense as they request conflicting features. */\n+\n+  if (cfun->machine->is_OS_task + cfun->machine->is_OS_main\n+      + (cfun->machine->is_signal || cfun->machine->is_interrupt) > 1)\n+    error_at (loc, \"function attributes %qs, %qs and %qs are mutually\"\n+               \" exclusive\", \"OS_task\", \"OS_main\", isr);\n+\n+  /* 'naked' will hide effects of 'OS_task' and 'OS_main'.  */\n+\n+  if (cfun->machine->is_naked\n+      && (cfun->machine->is_OS_task || cfun->machine->is_OS_main))\n+    warning_at (loc, OPT_Wattributes, \"function attributes %qs and %qs have\"\n+                \" no effect on %qs function\", \"OS_task\", \"OS_main\", \"naked\");\n+\n+  if (cfun->machine->is_interrupt || cfun->machine->is_signal)\n+    {\n+      tree args = TYPE_ARG_TYPES (TREE_TYPE (decl));\n+      tree ret = TREE_TYPE (TREE_TYPE (decl));\n+      const char *name = IDENTIFIER_POINTER (DECL_NAME (decl));\n+      \n+      /* Silently ignore 'signal' if 'interrupt' is present.  AVR-LibC startet\n+         using this when it switched from SIGNAL and INTERRUPT to ISR.  */\n+\n+      if (cfun->machine->is_interrupt)\n+        cfun->machine->is_signal = 0;\n+\n+      /* Interrupt handlers must be  void __vector (void)  functions.  */\n+\n+      if (args && TREE_CODE (TREE_VALUE (args)) != VOID_TYPE)\n+        error_at (loc, \"%qs function cannot have arguments\", isr);\n+\n+      if (TREE_CODE (ret) != VOID_TYPE)\n+        error_at (loc, \"%qs function cannot return a value\", isr);\n+\n+      /* If the function has the 'signal' or 'interrupt' attribute, ensure\n+         that the name of the function is \"__vector_NN\" so as to catch\n+         when the user misspells the vector name.  */\n+\n+      if (!STR_PREFIX_P (name, \"__vector\"))\n+        warning_at (loc, 0, \"%qs appears to be a misspelled %s handler\",\n+                    name, isr);\n+    }\n+\n+  /* Avoid the above diagnosis to be printed more than once.  */\n+  \n+  cfun->machine->attributes_checked_p = 1;\n+}\n+\n+\n /* Implement `ACCUMULATE_OUTGOING_ARGS'.  */\n \n int\n@@ -570,8 +638,7 @@ static int\n avr_regs_to_save (HARD_REG_SET *set)\n {\n   int reg, count;\n-  int int_or_sig_p = (interrupt_function_p (current_function_decl)\n-                      || signal_function_p (current_function_decl));\n+  int int_or_sig_p = cfun->machine->is_interrupt || cfun->machine->is_signal;\n \n   if (set)\n     CLEAR_HARD_REG_SET (*set);\n@@ -683,9 +750,9 @@ avr_simple_epilogue (void)\n           && get_frame_size () == 0\n           && avr_outgoing_args_size() == 0\n           && avr_regs_to_save (NULL) == 0\n-          && ! interrupt_function_p (current_function_decl)\n-          && ! signal_function_p (current_function_decl)\n-          && ! avr_naked_function_p (current_function_decl)\n+          && ! cfun->machine->is_interrupt\n+          && ! cfun->machine->is_signal\n+          && ! cfun->machine->is_naked\n           && ! TREE_THIS_VOLATILE (current_function_decl));\n }\n \n@@ -1096,12 +1163,6 @@ expand_prologue (void)\n \n   size = get_frame_size() + avr_outgoing_args_size();\n   \n-  /* Init cfun->machine.  */\n-  cfun->machine->is_naked = avr_naked_function_p (current_function_decl);\n-  cfun->machine->is_interrupt = interrupt_function_p (current_function_decl);\n-  cfun->machine->is_signal = signal_function_p (current_function_decl);\n-  cfun->machine->is_OS_task = avr_OS_task_function_p (current_function_decl);\n-  cfun->machine->is_OS_main = avr_OS_main_function_p (current_function_decl);\n   cfun->machine->stack_usage = 0;\n   \n   /* Prologue: naked.  */\n@@ -2458,17 +2519,17 @@ avr_function_ok_for_sibcall (tree decl_callee, tree exp_callee)\n \n   /* Ensure that caller and callee have compatible epilogues */\n   \n-  if (interrupt_function_p (current_function_decl)\n-      || signal_function_p (current_function_decl)\n+  if (cfun->machine->is_interrupt\n+      || cfun->machine->is_signal\n+      || cfun->machine->is_naked\n       || avr_naked_function_p (decl_callee)\n-      || avr_naked_function_p (current_function_decl)\n       /* FIXME: For OS_task and OS_main, we are over-conservative.\n          This is due to missing documentation of these attributes\n          and what they actually should do and should not do. */\n       || (avr_OS_task_function_p (decl_callee)\n-          != avr_OS_task_function_p (current_function_decl))\n+          != cfun->machine->is_OS_task)\n       || (avr_OS_main_function_p (decl_callee)\n-          != avr_OS_main_function_p (current_function_decl)))\n+          != cfun->machine->is_OS_main))\n     {\n       return false;\n     }\n@@ -6656,40 +6717,6 @@ avr_assemble_integer (rtx x, unsigned int size, int aligned_p)\n }\n \n \n-/* Worker function for ASM_DECLARE_FUNCTION_NAME.  */\n-\n-void\n-avr_asm_declare_function_name (FILE *file, const char *name, tree decl)\n-{\n-\n-  /* If the function has the 'signal' or 'interrupt' attribute, test to\n-     make sure that the name of the function is \"__vector_NN\" so as to\n-     catch when the user misspells the interrupt vector name.  */\n-\n-  if (cfun->machine->is_interrupt)\n-    {\n-      if (!STR_PREFIX_P (name, \"__vector\"))\n-        {\n-          warning_at (DECL_SOURCE_LOCATION (decl), 0,\n-                      \"%qs appears to be a misspelled interrupt handler\",\n-                      name);\n-        }\n-    }\n-  else if (cfun->machine->is_signal)\n-    {\n-      if (!STR_PREFIX_P (name, \"__vector\"))\n-        {\n-           warning_at (DECL_SOURCE_LOCATION (decl), 0,\n-                       \"%qs appears to be a misspelled signal handler\",\n-                       name);\n-        }\n-    }\n-\n-  ASM_OUTPUT_TYPE_DIRECTIVE (file, name, \"function\");\n-  ASM_OUTPUT_LABEL (file, name);\n-}\n-\n-\n /* Return value is nonzero if pseudos that have been\n    assigned to registers of class CLASS would likely be spilled\n    because registers of CLASS are needed for spill registers.  */\n@@ -10865,6 +10892,9 @@ avr_fold_builtin (tree fndecl, int n_args ATTRIBUTE_UNUSED, tree *arg,\n #undef  TARGET_FUNCTION_ARG_ADVANCE\n #define TARGET_FUNCTION_ARG_ADVANCE avr_function_arg_advance\n \n+#undef  TARGET_SET_CURRENT_FUNCTION\n+#define TARGET_SET_CURRENT_FUNCTION avr_set_current_function\n+\n #undef  TARGET_RETURN_IN_MEMORY\n #define TARGET_RETURN_IN_MEMORY avr_return_in_memory\n "}, {"sha": "dfbd071d192a2d61ffade37bb111de345516756e", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac188c5bcb1ed4f3fd61de2de2590dece32be2b/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac188c5bcb1ed4f3fd61de2de2590dece32be2b/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=eac188c5bcb1ed4f3fd61de2de2590dece32be2b", "patch": "@@ -707,6 +707,10 @@ struct GTY(()) machine_function\n \n   /* 'true' if a callee might be tail called */\n   int sibcall_fails;\n+\n+  /* 'true' if the above is_foo predicates are sanity-checked to avoid\n+     multiple diagnose for the same function.  */\n+  int attributes_checked_p;\n };\n \n /* AVR does not round pushes, but the existance of this macro is"}, {"sha": "6d79dc38cb81475cbcb942a36bec850524586459", "filename": "gcc/config/avr/elf.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac188c5bcb1ed4f3fd61de2de2590dece32be2b/gcc%2Fconfig%2Favr%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac188c5bcb1ed4f3fd61de2de2590dece32be2b/gcc%2Fconfig%2Favr%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Felf.h?ref=eac188c5bcb1ed4f3fd61de2de2590dece32be2b", "patch": "@@ -32,11 +32,6 @@\n #undef STRING_LIMIT\n #define STRING_LIMIT ((unsigned) 64)\n \n-/* Take care of `signal' and `interrupt' attributes.  */\n-#undef ASM_DECLARE_FUNCTION_NAME\n-#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)     \\\n-  avr_asm_declare_function_name ((FILE), (NAME), (DECL))\n-\n /* Output alignment 2**1 for jump tables.  */\n #undef ASM_OUTPUT_BEFORE_CASE_LABEL\n #define ASM_OUTPUT_BEFORE_CASE_LABEL(FILE, PREFIX, NUM, TABLE) \\"}, {"sha": "22087c35eec0189c235d5865c92ca1ac139ba017", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 68, "deletions": 50, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac188c5bcb1ed4f3fd61de2de2590dece32be2b/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac188c5bcb1ed4f3fd61de2de2590dece32be2b/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=eac188c5bcb1ed4f3fd61de2de2590dece32be2b", "patch": "@@ -2714,6 +2714,51 @@ then be sure to write this declaration in both files.\n \n This attribute is ignored for R8C target.\n \n+@item ifunc (\"@var{resolver}\")\n+@cindex @code{ifunc} attribute\n+The @code{ifunc} attribute is used to mark a function as an indirect\n+function using the STT_GNU_IFUNC symbol type extension to the ELF\n+standard.  This allows the resolution of the symbol value to be\n+determined dynamically at load time, and an optimized version of the\n+routine can be selected for the particular processor or other system\n+characteristics determined then.  To use this attribute, first define\n+the implementation functions available, and a resolver function that\n+returns a pointer to the selected implementation function.  The\n+implementation functions' declarations must match the API of the\n+function being implemented, the resolver's declaration is be a\n+function returning pointer to void function returning void:\n+\n+@smallexample\n+void *my_memcpy (void *dst, const void *src, size_t len)\n+@{\n+  @dots{}\n+@}\n+\n+static void (*resolve_memcpy (void)) (void)\n+@{\n+  return my_memcpy; // we'll just always select this routine\n+@}\n+@end smallexample\n+\n+The exported header file declaring the function the user calls would\n+contain:\n+\n+@smallexample\n+extern void *memcpy (void *, const void *, size_t);\n+@end smallexample\n+\n+allowing the user to call this as a regular function, unaware of the\n+implementation.  Finally, the indirect function needs to be defined in\n+the same translation unit as the resolver function:\n+\n+@smallexample\n+void *memcpy (void *, const void *, size_t)\n+     __attribute__ ((ifunc (\"resolve_memcpy\")));\n+@end smallexample\n+\n+Indirect functions cannot be weak, and require a recent binutils (at\n+least version 2.20.1), and GNU C library (at least version 2.11.1).\n+\n @item interrupt\n @cindex interrupt handler functions\n Use this attribute on the ARM, AVR, CR16, Epiphany, M32C, M32R/D, m68k, MeP, MIPS,\n@@ -2726,7 +2771,13 @@ code to initialize the interrupt vector table.\n Note, interrupt handlers for the Blackfin, H8/300, H8/300H, H8S, MicroBlaze,\n and SH processors can be specified via the @code{interrupt_handler} attribute.\n \n-Note, on the AVR, interrupts will be enabled inside the function.\n+Note, on the AVR, the hardware globally disables interrupts when an\n+interrupt is executed.  The first instruction of an interrupt handler\n+declared with this attribute will be a @code{SEI} instruction to\n+re-enable interrupts.  See also the @code{signal} function attribute\n+that does not insert a @code{SEI} instuction.  If both @code{signal} and\n+@code{interrupt} are specified for the same function, @code{signal}\n+will be silently ignored.\n \n Note, for the ARM, you can specify the kind of interrupt to be handled by\n adding an optional parameter to the interrupt attribute like this:\n@@ -2822,51 +2873,6 @@ On RL78, use @code{brk_interrupt} instead of @code{interrupt} for\n handlers intended to be used with the @code{BRK} opcode (i.e.  those\n that must end with @code{RETB} instead of @code{RETI}).\n \n-@item ifunc (\"@var{resolver}\")\n-@cindex @code{ifunc} attribute\n-The @code{ifunc} attribute is used to mark a function as an indirect\n-function using the STT_GNU_IFUNC symbol type extension to the ELF\n-standard.  This allows the resolution of the symbol value to be\n-determined dynamically at load time, and an optimized version of the\n-routine can be selected for the particular processor or other system\n-characteristics determined then.  To use this attribute, first define\n-the implementation functions available, and a resolver function that\n-returns a pointer to the selected implementation function.  The\n-implementation functions' declarations must match the API of the\n-function being implemented, the resolver's declaration is be a\n-function returning pointer to void function returning void:\n-\n-@smallexample\n-void *my_memcpy (void *dst, const void *src, size_t len)\n-@{\n-  @dots{}\n-@}\n-\n-static void (*resolve_memcpy (void)) (void)\n-@{\n-  return my_memcpy; // we'll just always select this routine\n-@}\n-@end smallexample\n-\n-The exported header file declaring the function the user calls would\n-contain:\n-\n-@smallexample\n-extern void *memcpy (void *, const void *, size_t);\n-@end smallexample\n-\n-allowing the user to call this as a regular function, unaware of the\n-implementation.  Finally, the indirect function needs to be defined in\n-the same translation unit as the resolver function:\n-\n-@smallexample\n-void *memcpy (void *, const void *, size_t)\n-     __attribute__ ((ifunc (\"resolve_memcpy\")));\n-@end smallexample\n-\n-Indirect functions cannot be weak, and require a recent binutils (at\n-least version 2.20.1), and GNU C library (at least version 2.11.1).\n-\n @item interrupt_handler\n @cindex interrupt handler functions on the Blackfin, m68k, H8/300 and SH processors\n Use this attribute on the Blackfin, m68k, H8/300, H8/300H, H8S, and SH to\n@@ -3471,11 +3477,23 @@ See long_call/short_call.\n See longcall/shortcall.\n \n @item signal\n-@cindex signal handler functions on the AVR processors\n+@cindex interrupt handler functions on the AVR processors\n Use this attribute on the AVR to indicate that the specified\n-function is a signal handler.  The compiler will generate function\n-entry and exit sequences suitable for use in a signal handler when this\n-attribute is present.  Interrupts will be disabled inside the function.\n+function is an interrupt handler.  The compiler will generate function\n+entry and exit sequences suitable for use in an interrupt handler when this\n+attribute is present.\n+\n+See also the @code{interrupt} function attribute. \n+\n+The AVR hardware globally disables interrupts when an interrupt is executed.\n+Interrupt handler functions defined with the @code{signal} attribute\n+do not re-enable interrupts.  It is save to enable interrupts in a\n+@code{signal} handler.  This ``save'' only applies to the code\n+generated by the compiler and not to the IRQ-layout of the\n+application which is responsibility of the application.\n+\n+If both @code{signal} and @code{interrupt} are specified for the same\n+function, @code{signal} will be silently ignored.\n \n @item sp_switch\n Use this attribute on the SH to indicate an @code{interrupt_handler}"}]}