{"sha": "8d8ffd86d73d2dfc8b2a631261d39571f6f9a97c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQ4ZmZkODZkNzNkMmRmYzhiMmE2MzEyNjFkMzk1NzFmNmY5YTk3Yw==", "commit": {"author": {"name": "Cary Coutant", "email": "ccoutant@google.com", "date": "2014-04-25T23:05:14Z"}, "committer": {"name": "Cary Coutant", "email": "ccoutant@gcc.gnu.org", "date": "2014-04-25T23:05:14Z"}, "message": "Fix a few ICEs and other problems with -fdebug-types-sections.\n\n(1) If a function contains a local typedef of an anonymous structure, GCC\nwill generate a typedef DIE in the function, where the typedef DIE points\nto a structure_type DIE at the top level.  That structure_type DIE, if\nit's a non-POD, can contain ctor and dtor definitions.  This causes an\nassertion in should_move_die_to_comdat to fail, as we have up to now\nassumed that this could never happen.\n\n(2) With --std=c++11, a template parameter can refer to a local type defined\nwithin a function.  Because that local type doesn't qualify for its own\ntype unit, we copy it as an \"unworthy\" type into the type unit that refers\nto it, but we copy too much, leading to a comdat type unit that contains a\nDIE with subprogram definitions rather than declarations.  These DIEs may\nhave DW_AT_low_pc/high_pc or DW_AT_ranges attributes, and consequently can\nrefer to range list entries that don't get emitted because they're not\nmarked when the compile unit is scanned, eventually causing an undefined\nsymbol at link time.\n\n(3) When a class template instantiation is moved into a separate type unit,\nit can bring along a lot of other referenced types into the type unit,\nespecially if the template is derived from another (large) type that\ndoes not have an actually have a type definition in a type unit of its\nown. When there are many instantiations of the same template, we get\na lot of duplication, and in the worst case (a template with several\nparameters, instantiated multiple times along each dimension), GCC\ncan end up taking a long time and exhausting available memory.\n\nThis combinatorial explosion is being caused by copy_decls_walk, where\nit finds a type DIE that is referenced by the type unit, but is not\nitself a type unit, and copies a declaration for that type into the\ntype unit in order to resolve the reference within the type unit.\nIn the process, copy_decls_walk also copies all of the children of\nthat DIE. In the case of a base class with member function templates,\nevery one of the instantiated member functions is copied into every\ntype unit that references the base class.\n\ngcc/\n        PR debug/60929\n\t* dwarf2out.c (should_move_die_to_comdat): A type definition\n        can contain a subprogram definition, but don't move it to a\n        comdat unit.\n\t(clone_as_declaration): Copy DW_AT_abstract_origin attribute.\n        (generate_skeleton_bottom_up): Remove DW_AT_object_pointer attribute\n        from original DIE.\n\t(clone_tree_hash): Rename to...\n\t(clone_tree_partial): ...this; change callers.  Copy\n        DW_TAG_subprogram DIEs as declarations.\n\t(copy_decls_walk): Don't copy children of a declaration into a\n        type unit.\n\ngcc/testsuite/\n        PR debug/60929\n        * g++.dg/debug/dwarf2/dwarf4-nested.C: New test case.\n        * g++.dg/debug/dwarf2/dwarf4-typedef.C: Add\n        -fdebug-types-section flag.\n\nFrom-SVN: r209812", "tree": {"sha": "df26cb7c7b7a439560f4652dd9c1a6a9684b3d85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df26cb7c7b7a439560f4652dd9c1a6a9684b3d85"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d8ffd86d73d2dfc8b2a631261d39571f6f9a97c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d8ffd86d73d2dfc8b2a631261d39571f6f9a97c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d8ffd86d73d2dfc8b2a631261d39571f6f9a97c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d8ffd86d73d2dfc8b2a631261d39571f6f9a97c/comments", "author": null, "committer": null, "parents": [{"sha": "255671b0c551d54a8e9882e7284ea788fd2c402b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/255671b0c551d54a8e9882e7284ea788fd2c402b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/255671b0c551d54a8e9882e7284ea788fd2c402b"}], "stats": {"total": 135, "additions": 117, "deletions": 18}, "files": [{"sha": "ccb796432426aa3c90c29a7fddb9841b347b2f79", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d8ffd86d73d2dfc8b2a631261d39571f6f9a97c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d8ffd86d73d2dfc8b2a631261d39571f6f9a97c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8d8ffd86d73d2dfc8b2a631261d39571f6f9a97c", "patch": "@@ -1,3 +1,18 @@\n+2014-04-25  Cary Coutant  <ccoutant@google.com>\n+\n+        PR debug/60929\n+\t* dwarf2out.c (should_move_die_to_comdat): A type definition\n+        can contain a subprogram definition, but don't move it to a\n+        comdat unit.\n+\t(clone_as_declaration): Copy DW_AT_abstract_origin attribute.\n+        (generate_skeleton_bottom_up): Remove DW_AT_object_pointer attribute\n+        from original DIE.\n+\t(clone_tree_hash): Rename to...\n+\t(clone_tree_partial): ...this; change callers.  Copy\n+        DW_TAG_subprogram DIEs as declarations.\n+\t(copy_decls_walk): Don't copy children of a declaration into a\n+        type unit.\n+\n 2014-04-25  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/60969"}, {"sha": "12723265e879ce34852e12e284bbbd5aae1490d1", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 39, "deletions": 17, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d8ffd86d73d2dfc8b2a631261d39571f6f9a97c/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d8ffd86d73d2dfc8b2a631261d39571f6f9a97c/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=8d8ffd86d73d2dfc8b2a631261d39571f6f9a97c", "patch": "@@ -6830,14 +6830,13 @@ should_move_die_to_comdat (dw_die_ref die)\n     case DW_TAG_structure_type:\n     case DW_TAG_enumeration_type:\n     case DW_TAG_union_type:\n-      /* Don't move declarations, inlined instances, or types nested in a\n-\t subprogram.  */\n+      /* Don't move declarations, inlined instances, types nested in a\n+\t subprogram, or types that contain subprogram definitions.  */\n       if (is_declaration_die (die)\n           || get_AT (die, DW_AT_abstract_origin)\n-          || is_nested_in_subprogram (die))\n+          || is_nested_in_subprogram (die)\n+          || contains_subprogram_definition (die))\n         return 0;\n-      /* A type definition should never contain a subprogram definition.  */\n-      gcc_assert (!contains_subprogram_definition (die));\n       return 1;\n     case DW_TAG_array_type:\n     case DW_TAG_interface_type:\n@@ -6926,6 +6925,7 @@ clone_as_declaration (dw_die_ref die)\n \n       switch (a->dw_attr)\n         {\n+        case DW_AT_abstract_origin:\n         case DW_AT_artificial:\n         case DW_AT_containing_type:\n         case DW_AT_external:\n@@ -7158,6 +7158,12 @@ generate_skeleton_bottom_up (skeleton_chain_node *parent)\n \t    dw_die_ref clone = clone_die (c);\n \t    move_all_children (c, clone);\n \n+\t    /* If the original has a DW_AT_object_pointer attribute,\n+\t       it would now point to a child DIE just moved to the\n+\t       cloned tree, so we need to remove that attribute from\n+\t       the original.  */\n+\t    remove_AT (c, DW_AT_object_pointer);\n+\n \t    replace_child (c, clone, prev);\n \t    generate_skeleton_ancestor_tree (parent);\n \t    add_child_die (parent->new_die, c);\n@@ -7299,28 +7305,38 @@ break_out_comdat_types (dw_die_ref die)\n   } while (next != NULL);\n }\n \n-/* Like clone_tree, but additionally enter all the children into\n-   the hash table decl_table.  */\n+/* Like clone_tree, but copy DW_TAG_subprogram DIEs as declarations.\n+   Enter all the cloned children into the hash table decl_table.  */\n \n static dw_die_ref\n-clone_tree_hash (dw_die_ref die, decl_hash_type decl_table)\n+clone_tree_partial (dw_die_ref die, decl_hash_type decl_table)\n {\n   dw_die_ref c;\n-  dw_die_ref clone = clone_die (die);\n+  dw_die_ref clone;\n   struct decl_table_entry *entry;\n-  decl_table_entry **slot = decl_table.find_slot_with_hash (die,\n-\t\t\t\t\t  htab_hash_pointer (die), INSERT);\n+  decl_table_entry **slot;\n+\n+  if (die->die_tag == DW_TAG_subprogram)\n+    clone = clone_as_declaration (die);\n+  else\n+    clone = clone_die (die);\n+\n+  slot = decl_table.find_slot_with_hash (die,\n+\t\t\t\t\t htab_hash_pointer (die), INSERT);\n+\n   /* Assert that DIE isn't in the hash table yet.  If it would be there\n      before, the ancestors would be necessarily there as well, therefore\n-     clone_tree_hash wouldn't be called.  */\n+     clone_tree_partial wouldn't be called.  */\n   gcc_assert (*slot == HTAB_EMPTY_ENTRY);\n+\n   entry = XCNEW (struct decl_table_entry);\n   entry->orig = die;\n   entry->copy = clone;\n   *slot = entry;\n \n-  FOR_EACH_CHILD (die, c,\n-\t\t  add_child_die (clone, clone_tree_hash (c, decl_table)));\n+  if (die->die_tag != DW_TAG_subprogram)\n+    FOR_EACH_CHILD (die, c,\n+\t\t    add_child_die (clone, clone_tree_partial (c, decl_table)));\n \n   return clone;\n }\n@@ -7371,9 +7387,15 @@ copy_decls_walk (dw_die_ref unit, dw_die_ref die, decl_hash_type decl_table)\n               entry->copy = copy;\n               *slot = entry;\n \n-\t      FOR_EACH_CHILD (targ, c,\n-\t\t\t      add_child_die (copy,\n-\t\t\t\t\t     clone_tree_hash (c, decl_table)));\n+\t      /* If TARG is not a declaration DIE, we need to copy its\n+\t         children.  */\n+\t      if (!is_declaration_die (targ))\n+\t\t{\n+\t\t  FOR_EACH_CHILD (\n+\t\t      targ, c,\n+\t\t      add_child_die (copy,\n+\t\t\t\t     clone_tree_partial (c, decl_table)));\n+\t\t}\n \n               /* Make sure the cloned tree is marked as part of the\n                  type unit.  */"}, {"sha": "92a33c1102c79abde70b5a4170026d2c9502445c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d8ffd86d73d2dfc8b2a631261d39571f6f9a97c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d8ffd86d73d2dfc8b2a631261d39571f6f9a97c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8d8ffd86d73d2dfc8b2a631261d39571f6f9a97c", "patch": "@@ -1,3 +1,10 @@\n+2014-04-25  Cary Coutant  <ccoutant@google.com>\n+\n+        PR debug/60929\n+        * g++.dg/debug/dwarf2/dwarf4-nested.C: New test case.\n+        * g++.dg/debug/dwarf2/dwarf4-typedef.C: Add\n+        -fdebug-types-section flag.\n+\n 2014-04-25  Jiong Wang  <jiong.wang@arm.com>\n \n \t* gcc.target/arm/tail-long-call.c: New test."}, {"sha": "160694c3c9f2a9d0409ebfe221d51c5a76ebb0b8", "filename": "gcc/testsuite/g++.dg/debug/dwarf2/dwarf4-nested.C", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d8ffd86d73d2dfc8b2a631261d39571f6f9a97c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Fdwarf4-nested.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d8ffd86d73d2dfc8b2a631261d39571f6f9a97c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Fdwarf4-nested.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Fdwarf4-nested.C?ref=8d8ffd86d73d2dfc8b2a631261d39571f6f9a97c", "patch": "@@ -0,0 +1,55 @@\n+// { dg-do compile }\n+// { dg-options \"--std=c++11 -dA -gdwarf-4 -fdebug-types-section -fno-merge-debug-strings\" }\n+\n+// Check that -fdebug-types-sections does not copy a full referenced type\n+// into a type unit.\n+\n+// Checks that at least one type unit is generated.\n+//\n+// { dg-final { scan-assembler \"DIE \\\\(\\[^\\n\\]*\\\\) DW_TAG_type_unit\" } }\n+//\n+// Check that func is declared exactly once in the debug info (in the\n+// compile unit).\n+//\n+// { dg-final { scan-assembler-times \"\\\\.ascii \\\"func\\\\\\\\0\\\"\\[^\\n\\]*DW_AT_name\" 1 } }\n+//\n+// Check to make sure that no type unit contains a DIE with DW_AT_low_pc\n+// or DW_AT_ranges.  These patterns assume that the compile unit is always\n+// emitted after all type units.\n+//\n+// { dg-final { scan-assembler-not \"\\\\.quad\\[^\\n\\]*DW_AT_low_pc.*DIE \\\\(\\[^\\n\\]*\\\\) DW_TAG_compile_unit\" } }\n+// { dg-final { scan-assembler-not \"\\\\.quad\\[^\\n\\]*DW_AT_ranges.*DIE \\\\(\\[^\\n\\]*\\\\) DW_TAG_compile_unit\" } }\n+\n+struct A {\n+  A();\n+  virtual ~A();\n+  virtual void foo();\n+ private:\n+  int data;\n+};\n+\n+struct B {\n+  B();\n+  virtual ~B();\n+};\n+\n+extern B* table[];\n+\n+struct D {\n+  template <typename T>\n+  T* get(int i)\n+  {\n+    B*& cell = table[i];\n+    if (cell == 0)\n+      cell = new T();\n+    return static_cast<T*>(cell);\n+  }\n+};\n+\n+void func(D* d)\n+{\n+  struct C : B {\n+    A a;\n+  };\n+  d->get<C>(0)->a.foo();\n+}"}, {"sha": "89a6bb44e10beb40464e122e80bc1dc7e45a44ff", "filename": "gcc/testsuite/g++.dg/debug/dwarf2/dwarf4-typedef.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d8ffd86d73d2dfc8b2a631261d39571f6f9a97c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Fdwarf4-typedef.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d8ffd86d73d2dfc8b2a631261d39571f6f9a97c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Fdwarf4-typedef.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Fdwarf4-typedef.C?ref=8d8ffd86d73d2dfc8b2a631261d39571f6f9a97c", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-gdwarf-4\" } */\n+/* { dg-options \"-gdwarf-4 -fdebug-types-section\" } */\n \n /* Regression test for an ICE in output_die when using -gdwarf-4.  */\n "}]}