{"sha": "0995a441f572b99071e2ab2b256c027e4a19e217", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDk5NWE0NDFmNTcyYjk5MDcxZTJhYjJiMjU2YzAyN2U0YTE5ZTIxNw==", "commit": {"author": {"name": "Steven Bosscher", "email": "stevenb@suse.de", "date": "2005-05-12T22:13:00Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2005-05-12T22:13:00Z"}, "message": "re PR tree-optimization/21520 (missing PRE opportunity with operand after operand)\n\n\n\n\tFix PR tree-optimization/21520\n\t* tree-ssa-pre.c (phi_translate): Use fully_constant_expression\n\tto attempt to fold constants.\n\nFrom-SVN: r99632", "tree": {"sha": "354efb3b7fe79e6c570a46275544956edce4638f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/354efb3b7fe79e6c570a46275544956edce4638f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0995a441f572b99071e2ab2b256c027e4a19e217", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0995a441f572b99071e2ab2b256c027e4a19e217", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0995a441f572b99071e2ab2b256c027e4a19e217", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0995a441f572b99071e2ab2b256c027e4a19e217/comments", "author": null, "committer": null, "parents": [{"sha": "02f20dc3fdfe1031a02b856ce6a7cc283ea49cf1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02f20dc3fdfe1031a02b856ce6a7cc283ea49cf1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02f20dc3fdfe1031a02b856ce6a7cc283ea49cf1"}], "stats": {"total": 74, "additions": 57, "deletions": 17}, "files": [{"sha": "fb42b5759fd3bf6f5cfbb57b69ffe59ebee0bbe4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0995a441f572b99071e2ab2b256c027e4a19e217/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0995a441f572b99071e2ab2b256c027e4a19e217/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0995a441f572b99071e2ab2b256c027e4a19e217", "patch": "@@ -1,3 +1,9 @@\n+2005-05-12  Steven Bosscher <stevenb@suse.de>\n+\n+\tFix PR tree-optimization/21520\n+\t* tree-ssa-pre.c (phi_translate): Use fully_constant_expression\n+\tto attempt to fold constants.\n+\n 2005-05-12  Kaz Kojima  <kkojima@gcc.gnu.org>\n \n \t* config/sh/sh.c: Declare the prototype of sh_adjust_unroll_max"}, {"sha": "1b8bc22484951bf295b5940d80d754f734d8d89f", "filename": "gcc/testsuite/gcc.c-torture/compile/pr21532.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0995a441f572b99071e2ab2b256c027e4a19e217/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr21532.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0995a441f572b99071e2ab2b256c027e4a19e217/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr21532.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr21532.c?ref=0995a441f572b99071e2ab2b256c027e4a19e217", "patch": "@@ -0,0 +1,14 @@\n+\n+\n+int\n+bar (unsigned char key)\n+{\n+  unsigned char buf[sizeof (unsigned long)+2];\n+  unsigned char b;\n+  unsigned char *buf_ = buf + 1;\n+\n+  for (b = 8; b != 0; b--)\n+    buf_[b] = key >> b;\n+\n+  return foo (b);\n+}"}, {"sha": "0494774b6088595c6eb66ae036faeea856bc58ff", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 37, "deletions": 17, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0995a441f572b99071e2ab2b256c027e4a19e217/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0995a441f572b99071e2ab2b256c027e4a19e217/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=0995a441f572b99071e2ab2b256c027e4a19e217", "patch": "@@ -842,6 +842,19 @@ debug_value_set (value_set_t set, const char *setname, int blockindex)\n   print_value_set (stderr, set, setname, blockindex);\n }\n \n+/* Return the folded version of T if T, when folded, is a gimple\n+   min_invariant.  Otherwise, return T.  */ \n+\n+static tree\n+fully_constant_expression (tree t)\n+{  \n+  tree folded;\n+  folded = fold (t);\n+  if (folded && is_gimple_min_invariant (folded))\n+    return folded;\n+  return t;\n+}\n+\n /* Translate EXPR using phis in PHIBLOCK, so that it has the values of\n    the phis in PRED.  Return NULL if we can't find a leader for each\n    part of the translated expression.  */\n@@ -889,12 +902,22 @@ phi_translate (tree expr, value_set_t set, basic_block pred,\n \t  return NULL;\n \tif (newop1 != oldop1 || newop2 != oldop2)\n \t  {\n+\t    tree t;\n \t    newexpr = pool_alloc (binary_node_pool);\n \t    memcpy (newexpr, expr, tree_size (expr));\n-\t    create_tree_ann (newexpr);\n \t    TREE_OPERAND (newexpr, 0) = newop1 == oldop1 ? oldop1 : get_value_handle (newop1);\n \t    TREE_OPERAND (newexpr, 1) = newop2 == oldop2 ? oldop2 : get_value_handle (newop2);\n-\t    vn_lookup_or_add (newexpr, NULL);\n+\t    t = fully_constant_expression (newexpr);\n+\t    if (t != newexpr)\n+\t      {\n+\t\tpool_free (binary_node_pool, newexpr);\n+\t\tnewexpr = t;\n+\t      }\n+\t    else\n+\t      {\n+\t\tcreate_tree_ann (newexpr);\t \n+\t\tvn_lookup_or_add (newexpr, NULL);\n+\t      }\n \t    expr = newexpr;\n \t    phi_trans_add (oldexpr, newexpr, pred);\t    \n \t  }\n@@ -913,11 +936,21 @@ phi_translate (tree expr, value_set_t set, basic_block pred,\n \t  return NULL;\n \tif (newop1 != oldop1)\n \t  {\n+\t    tree t;\n \t    newexpr = pool_alloc (unary_node_pool);\n \t    memcpy (newexpr, expr, tree_size (expr));\n-\t    create_tree_ann (newexpr);\t \n \t    TREE_OPERAND (newexpr, 0) = get_value_handle (newop1);\n-\t    vn_lookup_or_add (newexpr, NULL);\n+\t    t = fully_constant_expression (newexpr);\n+\t    if (t != newexpr)\n+\t      {\n+\t\tpool_free (unary_node_pool, newexpr);\n+\t\tnewexpr = t;\n+\t      }\n+\t    else\n+\t      {\n+\t\tcreate_tree_ann (newexpr);\t \n+\t\tvn_lookup_or_add (newexpr, NULL);\n+\t      }\n \t    expr = newexpr;\n \t    phi_trans_add (oldexpr, newexpr, pred);\n \t  }\n@@ -1412,19 +1445,6 @@ create_expression_by_pieces (basic_block block, tree expr, tree stmts)\n   return name;\n }\n \n-/* Return the folded version of T if T, when folded, is a gimple\n-   min_invariant.  Otherwise, return T.  */ \n-\n-static tree\n-fully_constant_expression (tree t)\n-{  \n-  tree folded;\n-  folded = fold (t);\n-  if (folded && is_gimple_min_invariant (folded))\n-    return folded;\n-  return t;\n-}\n-\n /* Insert the to-be-made-available values of NODE for each predecessor, stored\n    in AVAIL, into the predecessors of BLOCK, and merge the result with a phi\n    node, given the same value handle as NODE.  The prefix of the phi node is"}]}