{"sha": "498ad15e8ca3576ed912b6e0bf5bd954e21aae5c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDk4YWQxNWU4Y2EzNTc2ZWQ5MTJiNmUwYmY1YmQ5NTRlMjFhYWU1Yw==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2012-05-12T08:41:29Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2012-05-12T08:41:29Z"}, "message": "parser.c (struct cp_parser_expression_stack_entry): Add location_t field.\n\n/cp\n2012-05-12  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* parser.c (struct cp_parser_expression_stack_entry): Add location_t\n\tfield.\n\t(cp_parser_binary_expression): Rework to always update at the same\n\ttime tree_type and loc.\n\t* call.c (print_z_candidate): Add location_t parameter.\n\t(print_z_candidates, convert_like_real, joust): Adjust.\n\n/testsuite\n2012-05-12  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* g++.dg/parse/error47.C: New.\n\nFrom-SVN: r187424", "tree": {"sha": "7a51c8397aaffd62e9daad7cd15a348cb1e73167", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7a51c8397aaffd62e9daad7cd15a348cb1e73167"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/498ad15e8ca3576ed912b6e0bf5bd954e21aae5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/498ad15e8ca3576ed912b6e0bf5bd954e21aae5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/498ad15e8ca3576ed912b6e0bf5bd954e21aae5c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/498ad15e8ca3576ed912b6e0bf5bd954e21aae5c/comments", "author": null, "committer": null, "parents": [{"sha": "819dc4613772c5cb207070666a61404b9c3a3797", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/819dc4613772c5cb207070666a61404b9c3a3797", "html_url": "https://github.com/Rust-GCC/gccrs/commit/819dc4613772c5cb207070666a61404b9c3a3797"}], "stats": {"total": 149, "additions": 88, "deletions": 61}, "files": [{"sha": "bf9dc573547cba026defc14b856ca9fb862b97d3", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/498ad15e8ca3576ed912b6e0bf5bd954e21aae5c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/498ad15e8ca3576ed912b6e0bf5bd954e21aae5c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=498ad15e8ca3576ed912b6e0bf5bd954e21aae5c", "patch": "@@ -1,3 +1,12 @@\n+2012-05-12  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* parser.c (struct cp_parser_expression_stack_entry): Add location_t\n+\tfield.\n+\t(cp_parser_binary_expression): Rework to always update at the same\n+\ttime tree_type and loc.\n+\t* call.c (print_z_candidate): Add location_t parameter.\n+\t(print_z_candidates, convert_like_real, joust): Adjust.\n+\n 2012-05-11  Alexandre Oliva  <aoliva@redhat.com>\n \n \tPR c++/53209"}, {"sha": "8497bfa3cb467deb7bb50500cdeed6801e280ed8", "filename": "gcc/cp/call.c", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/498ad15e8ca3576ed912b6e0bf5bd954e21aae5c/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/498ad15e8ca3576ed912b6e0bf5bd954e21aae5c/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=498ad15e8ca3576ed912b6e0bf5bd954e21aae5c", "patch": "@@ -163,7 +163,7 @@ static void op_error (location_t, enum tree_code, enum tree_code, tree,\n \t\t      tree, tree, bool);\n static struct z_candidate *build_user_type_conversion_1 (tree, tree, int,\n \t\t\t\t\t\t\t tsubst_flags_t);\n-static void print_z_candidate (const char *, struct z_candidate *);\n+static void print_z_candidate (location_t, const char *, struct z_candidate *);\n static void print_z_candidates (location_t, struct z_candidate *);\n static tree build_this (tree);\n static struct z_candidate *splice_viable (struct z_candidate *, bool, bool *);\n@@ -3159,36 +3159,38 @@ print_arity_information (location_t loc, unsigned int have, unsigned int want)\n    life simpler in print_z_candidates and for the translators.  */\n \n static void\n-print_z_candidate (const char *msgstr, struct z_candidate *candidate)\n+print_z_candidate (location_t loc, const char *msgstr,\n+\t\t   struct z_candidate *candidate)\n {\n   const char *msg = (msgstr == NULL\n \t\t     ? \"\"\n \t\t     : ACONCAT ((msgstr, \" \", NULL)));\n-  location_t loc = location_of (candidate->fn);\n+  location_t cloc = location_of (candidate->fn);\n \n   if (TREE_CODE (candidate->fn) == IDENTIFIER_NODE)\n     {\n+      cloc = loc;\n       if (candidate->num_convs == 3)\n-\tinform (input_location, \"%s%D(%T, %T, %T) <built-in>\", msg, candidate->fn,\n+\tinform (cloc, \"%s%D(%T, %T, %T) <built-in>\", msg, candidate->fn,\n \t\tcandidate->convs[0]->type,\n \t\tcandidate->convs[1]->type,\n \t\tcandidate->convs[2]->type);\n       else if (candidate->num_convs == 2)\n-\tinform (input_location, \"%s%D(%T, %T) <built-in>\", msg, candidate->fn,\n+\tinform (cloc, \"%s%D(%T, %T) <built-in>\", msg, candidate->fn,\n \t\tcandidate->convs[0]->type,\n \t\tcandidate->convs[1]->type);\n       else\n-\tinform (input_location, \"%s%D(%T) <built-in>\", msg, candidate->fn,\n+\tinform (cloc, \"%s%D(%T) <built-in>\", msg, candidate->fn,\n \t\tcandidate->convs[0]->type);\n     }\n   else if (TYPE_P (candidate->fn))\n-    inform (loc, \"%s%T <conversion>\", msg, candidate->fn);\n+    inform (cloc, \"%s%T <conversion>\", msg, candidate->fn);\n   else if (candidate->viable == -1)\n-    inform (loc, \"%s%#D <near match>\", msg, candidate->fn);\n+    inform (cloc, \"%s%#D <near match>\", msg, candidate->fn);\n   else if (DECL_DELETED_FN (STRIP_TEMPLATE (candidate->fn)))\n-    inform (loc, \"%s%#D <deleted>\", msg, candidate->fn);\n+    inform (cloc, \"%s%#D <deleted>\", msg, candidate->fn);\n   else\n-    inform (loc, \"%s%#D\", msg, candidate->fn);\n+    inform (cloc, \"%s%#D\", msg, candidate->fn);\n   /* Give the user some information about why this candidate failed.  */\n   if (candidate->reason != NULL)\n     {\n@@ -3197,23 +3199,23 @@ print_z_candidate (const char *msgstr, struct z_candidate *candidate)\n       switch (r->code)\n \t{\n \tcase rr_arity:\n-\t  print_arity_information (loc, r->u.arity.actual,\n+\t  print_arity_information (cloc, r->u.arity.actual,\n \t\t\t\t   r->u.arity.expected);\n \t  break;\n \tcase rr_arg_conversion:\n-\t  print_conversion_rejection (loc, &r->u.conversion);\n+\t  print_conversion_rejection (cloc, &r->u.conversion);\n \t  break;\n \tcase rr_bad_arg_conversion:\n-\t  print_conversion_rejection (loc, &r->u.bad_conversion);\n+\t  print_conversion_rejection (cloc, &r->u.bad_conversion);\n \t  break;\n \tcase rr_explicit_conversion:\n-\t  inform (loc, \"  return type %qT of explicit conversion function \"\n+\t  inform (cloc, \"  return type %qT of explicit conversion function \"\n \t\t  \"cannot be converted to %qT with a qualification \"\n \t\t  \"conversion\", r->u.conversion.from_type,\n \t\t  r->u.conversion.to_type);\n \t  break;\n \tcase rr_template_conversion:\n-\t  inform (loc, \"  conversion from return type %qT of template \"\n+\t  inform (cloc, \"  conversion from return type %qT of template \"\n \t\t  \"conversion function specialization to %qT is not an \"\n \t\t  \"exact match\", r->u.conversion.from_type,\n \t\t  r->u.conversion.to_type);\n@@ -3224,12 +3226,12 @@ print_z_candidate (const char *msgstr, struct z_candidate *candidate)\n \t     them here.  */\n \t  if (r->u.template_unification.tmpl == NULL_TREE)\n \t    {\n-\t      inform (loc, \"  substitution of deduced template arguments \"\n+\t      inform (cloc, \"  substitution of deduced template arguments \"\n \t\t      \"resulted in errors seen above\");\n \t      break;\n \t    }\n \t  /* Re-run template unification with diagnostics.  */\n-\t  inform (loc, \"  template argument deduction/substitution failed:\");\n+\t  inform (cloc, \"  template argument deduction/substitution failed:\");\n \t  fn_type_unification (r->u.template_unification.tmpl,\n \t\t\t       r->u.template_unification.explicit_targs,\n \t\t\t       r->u.template_unification.targs,\n@@ -3247,7 +3249,7 @@ print_z_candidate (const char *msgstr, struct z_candidate *candidate)\n \t\t\t\ttf_warning_or_error);\n \t  break;\n \tcase rr_invalid_copy:\n-\t  inform (loc,\n+\t  inform (cloc,\n \t\t  \"  a constructor taking a single argument of its own \"\n \t\t  \"class type is invalid\");\n \t  break;\n@@ -3312,7 +3314,7 @@ print_z_candidates (location_t loc, struct z_candidate *candidates)\n \n   inform_n (loc, n_candidates, \"candidate is:\", \"candidates are:\");\n   for (; candidates; candidates = candidates->next)\n-    print_z_candidate (NULL, candidates);\n+    print_z_candidate (loc, NULL, candidates);\n }\n \n /* USER_SEQ is a user-defined conversion sequence, beginning with a\n@@ -5678,7 +5680,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t    {\n \t      permerror (loc, \"invalid user-defined conversion \"\n \t\t\t \"from %qT to %qT\", TREE_TYPE (expr), totype);\n-\t      print_z_candidate (\"candidate is:\", t->cand);\n+\t      print_z_candidate (loc, \"candidate is:\", t->cand);\n \t      expr = convert_like_real (t, expr, fn, argnum, 1,\n \t\t\t\t\t/*issue_conversion_warnings=*/false,\n \t\t\t\t\t/*c_cast_p=*/false,\n@@ -8405,8 +8407,8 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn,\n \t      \"ISO C++ says that these are ambiguous, even \"\n \t      \"though the worst conversion for the first is better than \"\n \t      \"the worst conversion for the second:\");\n-\t      print_z_candidate (_(\"candidate 1:\"), w);\n-\t      print_z_candidate (_(\"candidate 2:\"), l);\n+\t      print_z_candidate (input_location, _(\"candidate 1:\"), w);\n+\t      print_z_candidate (input_location, _(\"candidate 2:\"), l);\n \t    }\n \t  else\n \t    add_warning (w, l);"}, {"sha": "dc64fa1f62ae2f91e87315b0b913575f1979559c", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 42, "deletions": 39, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/498ad15e8ca3576ed912b6e0bf5bd954e21aae5c/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/498ad15e8ca3576ed912b6e0bf5bd954e21aae5c/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=498ad15e8ca3576ed912b6e0bf5bd954e21aae5c", "patch": "@@ -1621,6 +1621,8 @@ typedef struct cp_parser_expression_stack_entry\n   enum tree_code tree_type;\n   /* Precedence of the binary operation we are parsing.  */\n   enum cp_parser_prec prec;\n+  /* Location of the binary operation we are parsing.  */\n+  location_t loc;\n } cp_parser_expression_stack_entry;\n \n /* The stack for storing partial expressions.  We only need NUM_PREC_VALUES\n@@ -7275,30 +7277,33 @@ cp_parser_binary_expression (cp_parser* parser, bool cast_p,\n {\n   cp_parser_expression_stack stack;\n   cp_parser_expression_stack_entry *sp = &stack[0];\n-  tree lhs, rhs;\n+  cp_parser_expression_stack_entry current;\n+  tree rhs;\n   cp_token *token;\n-  location_t loc;\n-  enum tree_code tree_type, lhs_type, rhs_type;\n+  enum tree_code rhs_type;\n   enum cp_parser_prec new_prec, lookahead_prec;\n   tree overload;\n \n   /* Parse the first expression.  */\n-  lhs = cp_parser_cast_expression (parser, /*address_p=*/false, cast_p, pidk);\n-  lhs_type = ERROR_MARK;\n+  current.lhs = cp_parser_cast_expression (parser, /*address_p=*/false,\n+\t\t\t\t\t   cast_p, pidk);\n+  current.lhs_type = ERROR_MARK;\n+  current.prec = prec;\n \n   for (;;)\n     {\n       /* Get an operator token.  */\n       token = cp_lexer_peek_token (parser->lexer);\n-      loc = token->location;\n \n       if (warn_cxx0x_compat\n           && token->type == CPP_RSHIFT\n           && !parser->greater_than_is_operator_p)\n         {\n-          if (warning_at (loc, OPT_Wc__0x_compat, \"%<>>%> operator is treated\"\n+          if (warning_at (token->location, OPT_Wc__0x_compat,\n+\t\t\t  \"%<>>%> operator is treated\"\n \t\t\t  \" as two right angle brackets in C++11\"))\n-\t    inform (loc, \"suggest parentheses around %<>>%> expression\");\n+\t    inform (token->location,\n+\t\t    \"suggest parentheses around %<>>%> expression\");\n         }\n \n       new_prec = TOKEN_PRECEDENCE (token);\n@@ -7310,7 +7315,7 @@ cp_parser_binary_expression (cp_parser* parser, bool cast_p,\n \t - or, we found an operator which has lower priority.  This is the case\n \t   where the recursive descent *ascends*, as in `3 * 4 + 5' after\n \t   parsing `3 * 4'.  */\n-      if (new_prec <= prec)\n+      if (new_prec <= current.prec)\n \t{\n \t  if (sp == stack)\n \t    break;\n@@ -7319,17 +7324,18 @@ cp_parser_binary_expression (cp_parser* parser, bool cast_p,\n \t}\n \n      get_rhs:\n-      tree_type = binops_by_token[token->type].tree_type;\n+      current.tree_type = binops_by_token[token->type].tree_type;\n+      current.loc = token->location;\n \n       /* We used the operator token.  */\n       cp_lexer_consume_token (parser->lexer);\n \n       /* For \"false && x\" or \"true || x\", x will never be executed;\n \t disable warnings while evaluating it.  */\n-      if (tree_type == TRUTH_ANDIF_EXPR)\n-\tc_inhibit_evaluation_warnings += lhs == truthvalue_false_node;\n-      else if (tree_type == TRUTH_ORIF_EXPR)\n-\tc_inhibit_evaluation_warnings += lhs == truthvalue_true_node;\n+      if (current.tree_type == TRUTH_ANDIF_EXPR)\n+\tc_inhibit_evaluation_warnings += current.lhs == truthvalue_false_node;\n+      else if (current.tree_type == TRUTH_ORIF_EXPR)\n+\tc_inhibit_evaluation_warnings += current.lhs == truthvalue_true_node;\n \n       /* Extract another operand.  It may be the RHS of this expression\n \t or the LHS of a new, higher priority expression.  */\n@@ -7347,14 +7353,11 @@ cp_parser_binary_expression (cp_parser* parser, bool cast_p,\n \t     expression.  Since precedence levels on the stack are\n \t     monotonically increasing, we do not have to care about\n \t     stack overflows.  */\n-\t  sp->prec = prec;\n-\t  sp->tree_type = tree_type;\n-\t  sp->lhs = lhs;\n-\t  sp->lhs_type = lhs_type;\n-\t  sp++;\n-\t  lhs = rhs;\n-\t  lhs_type = rhs_type;\n-\t  prec = new_prec;\n+\t  *sp = current;\n+\t  ++sp;\n+\t  current.lhs = rhs;\n+\t  current.lhs_type = rhs_type;\n+\t  current.prec = new_prec;\n \t  new_prec = lookahead_prec;\n \t  goto get_rhs;\n \n@@ -7367,20 +7370,17 @@ cp_parser_binary_expression (cp_parser* parser, bool cast_p,\n \t     the precedence of the higher level subexpression\n \t     (`PREC_ADDITIVE_EXPRESSION').  TOKEN is the CPP_PLUS token,\n \t     which will be used to actually build the additive expression.  */\n+\t  rhs = current.lhs;\n+\t  rhs_type = current.lhs_type;\n \t  --sp;\n-\t  prec = sp->prec;\n-\t  tree_type = sp->tree_type;\n-\t  rhs = lhs;\n-\t  rhs_type = lhs_type;\n-\t  lhs = sp->lhs;\n-\t  lhs_type = sp->lhs_type;\n+\t  current = *sp;\n \t}\n \n       /* Undo the disabling of warnings done above.  */\n-      if (tree_type == TRUTH_ANDIF_EXPR)\n-\tc_inhibit_evaluation_warnings -= lhs == truthvalue_false_node;\n-      else if (tree_type == TRUTH_ORIF_EXPR)\n-\tc_inhibit_evaluation_warnings -= lhs == truthvalue_true_node;\n+      if (current.tree_type == TRUTH_ANDIF_EXPR)\n+\tc_inhibit_evaluation_warnings -= current.lhs == truthvalue_false_node;\n+      else if (current.tree_type == TRUTH_ORIF_EXPR)\n+\tc_inhibit_evaluation_warnings -= current.lhs == truthvalue_true_node;\n \n       overload = NULL;\n       /* ??? Currently we pass lhs_type == ERROR_MARK and rhs_type ==\n@@ -7391,14 +7391,17 @@ cp_parser_binary_expression (cp_parser* parser, bool cast_p,\n \t surrounded by parentheses.\n       */\n       if (no_toplevel_fold_p\n-\t  && lookahead_prec <= prec\n+\t  && lookahead_prec <= current.prec\n \t  && sp == stack\n-\t  && TREE_CODE_CLASS (tree_type) == tcc_comparison)\n-\tlhs = build2 (tree_type, boolean_type_node, lhs, rhs);\n+\t  && TREE_CODE_CLASS (current.tree_type) == tcc_comparison)\n+\tcurrent.lhs = build2 (current.tree_type, boolean_type_node,\n+\t\t\t      current.lhs, rhs);\n       else\n-\tlhs = build_x_binary_op (loc, tree_type, lhs, lhs_type, rhs, rhs_type,\n-\t\t\t\t &overload, tf_warning_or_error);\n-      lhs_type = tree_type;\n+\tcurrent.lhs = build_x_binary_op (current.loc, current.tree_type,\n+\t\t\t\t\t current.lhs, current.lhs_type,\n+\t\t\t\t\t rhs, rhs_type, &overload,\n+\t\t\t\t\t tf_warning_or_error);\n+      current.lhs_type = current.tree_type;\n \n       /* If the binary operator required the use of an overloaded operator,\n \t then this expression cannot be an integral constant-expression.\n@@ -7412,7 +7415,7 @@ cp_parser_binary_expression (cp_parser* parser, bool cast_p,\n \treturn error_mark_node;\n     }\n \n-  return lhs;\n+  return current.lhs;\n }\n \n "}, {"sha": "282cfc0e3ec677d4d6b293f28cb632a02100ec2e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/498ad15e8ca3576ed912b6e0bf5bd954e21aae5c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/498ad15e8ca3576ed912b6e0bf5bd954e21aae5c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=498ad15e8ca3576ed912b6e0bf5bd954e21aae5c", "patch": "@@ -1,3 +1,7 @@\n+2012-05-12  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* g++.dg/parse/error47.C: New.\n+\n 2012-05-11  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/52537"}, {"sha": "44f14c4e4e00ab8a230bbf151addfac7ededa97d", "filename": "gcc/testsuite/g++.dg/parse/error47.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/498ad15e8ca3576ed912b6e0bf5bd954e21aae5c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror47.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/498ad15e8ca3576ed912b6e0bf5bd954e21aae5c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror47.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror47.C?ref=498ad15e8ca3576ed912b6e0bf5bd954e21aae5c", "patch": "@@ -0,0 +1,9 @@\n+struct T { };\n+\n+T foo();\n+\n+void bar(int a, int b)\n+{\n+  if (foo() && a < b) // { dg-error \"13:no match for 'operator&&'\" }\n+    ;\n+}"}]}