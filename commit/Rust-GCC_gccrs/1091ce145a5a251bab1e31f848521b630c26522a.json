{"sha": "1091ce145a5a251bab1e31f848521b630c26522a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTA5MWNlMTQ1YTVhMjUxYmFiMWUzMWY4NDg1MjFiNjMwYzI2NTIyYQ==", "commit": {"author": {"name": "Geert Bosch", "email": "bosch@adacore.com", "date": "2007-06-06T10:26:49Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-06-06T10:26:49Z"}, "message": "exp_fixd.adb (Integer_Literal): Add optional argument to construct a negative literal\n\n2007-04-20  Geert Bosch  <bosch@adacore.com>\n\n\t* exp_fixd.adb (Integer_Literal): Add optional argument to construct a\n\tnegative literal\n\t(Do_Divide_Fixed_Fixed): Add comments to indicate Frac is always\n\tpositive\n\t(Do_Divide_Fixed_Universal): Handle case of negative Frac.\n\t(Do_Multiply_Fixed_Fixed): Add coments to indicate Frac is always\n\tpositive\n\t(Do_Multiply_Fixed_Universal): Handle case of negative Frac.\n\nFrom-SVN: r125404", "tree": {"sha": "6cedafa661c022fcaf5e7c2b44677a0dfc1890c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6cedafa661c022fcaf5e7c2b44677a0dfc1890c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1091ce145a5a251bab1e31f848521b630c26522a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1091ce145a5a251bab1e31f848521b630c26522a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1091ce145a5a251bab1e31f848521b630c26522a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1091ce145a5a251bab1e31f848521b630c26522a/comments", "author": null, "committer": null, "parents": [{"sha": "c3d593c9d3e2716097a4feb03d16c92ba35f3fe7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3d593c9d3e2716097a4feb03d16c92ba35f3fe7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3d593c9d3e2716097a4feb03d16c92ba35f3fe7"}], "stats": {"total": 66, "additions": 39, "deletions": 27}, "files": [{"sha": "d1dbcd81ffdd63901b3ddc312bdf54527f3aa6f8", "filename": "gcc/ada/exp_fixd.adb", "status": "modified", "additions": 39, "deletions": 27, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1091ce145a5a251bab1e31f848521b630c26522a/gcc%2Fada%2Fexp_fixd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1091ce145a5a251bab1e31f848521b630c26522a/gcc%2Fada%2Fexp_fixd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_fixd.adb?ref=1091ce145a5a251bab1e31f848521b630c26522a", "patch": "@@ -183,13 +183,17 @@ package body Exp_Fixd is\n    --  The expression returned is neither analyzed and resolved. The Etype\n    --  of the result is properly set (to Universal_Real).\n \n-   function Integer_Literal (N : Node_Id; V : Uint) return Node_Id;\n+   function Integer_Literal\n+     (N        : Node_Id;\n+      V        : Uint;\n+      Negative : Boolean := False) return Node_Id;\n    --  Given a non-negative universal integer value, build a typed integer\n    --  literal node, using the smallest applicable standard integer type. If\n-   --  the value exceeds 2**63-1, the largest value allowed for perfect result\n-   --  set scaling factors (see RM G.2.3(22)), then Empty is returned. The\n-   --  node N provides the Sloc value for the constructed literal. The Etype\n-   --  of the resulting literal is correctly set, and it is marked as analyzed.\n+   --  and only if Negative is true a negative literal is built. If V exceeds\n+   --  2**63-1, the largest value allowed for perfect result set scaling\n+   --  factors (see RM G.2.3(22)), then Empty is returned. The node N provides\n+   --  the Sloc value for the constructed literal. The Etype of the resulting\n+   --  literal is correctly set, and it is marked as analyzed.\n \n    function Real_Literal (N : Node_Id; V : Ureal) return Node_Id;\n    --  Build a real literal node from the given value, the Etype of the\n@@ -202,14 +206,14 @@ package body Exp_Fixd is\n \n    procedure Set_Result (N : Node_Id; Expr : Node_Id; Rchk : Boolean := False);\n    --  N is the node for the current conversion, division or multiplication\n-   --  operation, and Expr is an expression representing the result. Expr\n-   --  may be of floating-point or integer type. If the operation result\n-   --  is fixed-point, then the value of Expr is in units of small of the\n-   --  result type (i.e. small's have already been dealt with). The result\n-   --  of the call is to replace N by an appropriate conversion to the\n-   --  result type, dealing with rounding for the decimal types case. The\n-   --  node is then analyzed and resolved using the result type. If Rchk\n-   --  is True, then Do_Range_Check is set in the resulting conversion.\n+   --  operation, and Expr is an expression representing the result. Expr may\n+   --  be of floating-point or integer type. If the operation result is fixed-\n+   --  point, then the value of Expr is in units of small of the result type\n+   --  (i.e. small's have already been dealt with). The result of the call is\n+   --  to replace N by an appropriate conversion to the result type, dealing\n+   --  with rounding for the decimal types case. The node is then analyzed and\n+   --  resolved using the result type. If Rchk is True, then Do_Range_Check is\n+   --  set in the resulting conversion.\n \n    ----------------------\n    -- Build_Conversion --\n@@ -1019,7 +1023,7 @@ package body Exp_Fixd is\n       --  would lose precision).\n \n       if Frac_Den = 1 then\n-         Lit_Int := Integer_Literal (N, Frac_Num);\n+         Lit_Int := Integer_Literal (N, Frac_Num); -- always positive\n \n          if Present (Lit_Int) then\n             Set_Result (N, Build_Scaled_Divide (N, Left, Lit_Int, Right));\n@@ -1035,7 +1039,7 @@ package body Exp_Fixd is\n       --  divisions), and we don't get inaccuracies from double rounding.\n \n       elsif Frac_Num = 1 then\n-         Lit_Int := Integer_Literal (N, Frac_Den);\n+         Lit_Int := Integer_Literal (N, Frac_Den); -- always positive\n \n          if Present (Lit_Int) then\n             Set_Result (N, Build_Double_Divide (N, Left, Right, Lit_Int));\n@@ -1128,7 +1132,7 @@ package body Exp_Fixd is\n       --  where the result can be obtained by dividing by this integer value.\n \n       if Frac_Num = 1 then\n-         Lit_Int := Integer_Literal (N, Frac_Den);\n+         Lit_Int := Integer_Literal (N, Frac_Den, UR_Is_Negative (Frac));\n \n          if Present (Lit_Int) then\n             Set_Result (N, Build_Divide (N, Left, Lit_Int));\n@@ -1143,8 +1147,8 @@ package body Exp_Fixd is\n       --  would lose precision).\n \n       else\n-         Lit_Int := Integer_Literal (N, Frac_Num);\n-         Lit_K   := Integer_Literal (N, Frac_Den);\n+         Lit_Int := Integer_Literal (N, Frac_Num, UR_Is_Negative (Frac));\n+         Lit_K   := Integer_Literal (N, Frac_Den, False);\n \n          if Present (Lit_Int) and then Present (Lit_K) then\n             Set_Result (N, Build_Scaled_Divide (N, Left, Lit_Int, Lit_K));\n@@ -1246,7 +1250,7 @@ package body Exp_Fixd is\n       --  can be obtained by dividing this integer by the right operand.\n \n       if Frac_Den = 1 then\n-         Lit_Int := Integer_Literal (N, Frac_Num);\n+         Lit_Int := Integer_Literal (N, Frac_Num, UR_Is_Negative (Frac));\n \n          if Present (Lit_Int) then\n             Set_Result (N, Build_Divide (N, Lit_Int, Right));\n@@ -1261,8 +1265,8 @@ package body Exp_Fixd is\n       --  is important (if we divided first, we would lose precision).\n \n       else\n-         Lit_Int := Integer_Literal (N, Frac_Den);\n-         Lit_K   := Integer_Literal (N, Frac_Num);\n+         Lit_Int := Integer_Literal (N, Frac_Den, UR_Is_Negative (Frac));\n+         Lit_K   := Integer_Literal (N, Frac_Num, False);\n \n          if Present (Lit_Int) and then Present (Lit_K) then\n             Set_Result (N, Build_Double_Divide (N, Lit_K, Right, Lit_Int));\n@@ -1337,7 +1341,7 @@ package body Exp_Fixd is\n       --  the operands, and then multiplying the result by the integer value.\n \n       if Frac_Den = 1 then\n-         Lit_Int := Integer_Literal (N, Frac_Num);\n+         Lit_Int := Integer_Literal (N, Frac_Num); -- always positive\n \n          if Present (Lit_Int) then\n             Set_Result (N,\n@@ -1352,7 +1356,7 @@ package body Exp_Fixd is\n       --  divided first, we would lose precision.\n \n       elsif Frac_Num = 1 then\n-         Lit_Int := Integer_Literal (N, Frac_Den);\n+         Lit_Int := Integer_Literal (N, Frac_Den); -- always positive\n \n          if Present (Lit_Int) then\n             Set_Result (N, Build_Scaled_Divide (N, Left, Right, Lit_Int));\n@@ -1448,7 +1452,7 @@ package body Exp_Fixd is\n       --  be obtained by multiplying by this integer value.\n \n       if Frac_Den = 1 then\n-         Lit_Int := Integer_Literal (N, Frac_Num);\n+         Lit_Int := Integer_Literal (N, Frac_Num, UR_Is_Negative (Frac));\n \n          if Present (Lit_Int) then\n             Set_Result (N, Build_Multiply (N, Left, Lit_Int));\n@@ -1462,7 +1466,7 @@ package body Exp_Fixd is\n       --  dividing by the integer value.\n \n       else\n-         Lit_Int := Integer_Literal (N, Frac_Den);\n+         Lit_Int := Integer_Literal (N, Frac_Den, UR_Is_Negative (Frac));\n          Lit_K   := Integer_Literal (N, Frac_Num);\n \n          if Present (Lit_Int) and then Present (Lit_K) then\n@@ -2265,7 +2269,11 @@ package body Exp_Fixd is\n    -- Integer_Literal --\n    ---------------------\n \n-   function Integer_Literal (N : Node_Id; V : Uint) return Node_Id is\n+   function Integer_Literal\n+     (N        : Node_Id;\n+      V        : Uint;\n+      Negative : Boolean := False) return Node_Id\n+   is\n       T : Entity_Id;\n       L : Node_Id;\n \n@@ -2286,7 +2294,11 @@ package body Exp_Fixd is\n          return Empty;\n       end if;\n \n-      L := Make_Integer_Literal (Sloc (N), V);\n+      if Negative then\n+         L := Make_Integer_Literal (Sloc (N), UI_Negate (V));\n+      else\n+         L := Make_Integer_Literal (Sloc (N), V);\n+      end if;\n \n       --  Set type of result in case used elsewhere (see note at start)\n "}]}