{"sha": "15529d0aa0264ae211db7acfebd1e23c8a944123", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTU1MjlkMGFhMDI2NGFlMjExZGI3YWNmZWJkMWUyM2M4YTk0NDEyMw==", "commit": {"author": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2017-10-09T15:49:59Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2017-10-09T15:49:59Z"}, "message": "exp_ch6.adb: (Make_Build_In_Place_Call_In_Object_Declaration): Remove the code at the end of...\n\ngcc/ada/\n\n2017-10-09  Bob Duff  <duff@adacore.com>\n\n\t* exp_ch6.adb: (Make_Build_In_Place_Call_In_Object_Declaration): Remove\n\tthe code at the end of this procedure that was setting the type of a\n\tclass-wide object to the specific type returned by a function call.\n\tTreat this case as indefinite instead.\n\n2017-10-09  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch4.adb (Try_Class_Wide_Operation, Traverse_Homonyms):\n\tSuppress spurious ambiguity error when two traversals of the homonym\n\tchain (first directly, and then through an examination of relevant\n\tinterfaces) retrieve the same operation, when other irrelevant homonyms\n\tof the operatioh are also present.\n\n2017-10-09  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_util.adb (Object_Access_Level): If the object is the return\n\tstatement of an expression function, return the level of the function.\n\tThis is relevant when the object involves an implicit conversion\n\tbetween access types and the expression function is a completion, which\n\tforces the analysis of the expression before rewriting it as a body, so\n\tthat freeze nodes can appear in the proper scope.\n\n2017-10-09  Bob Duff  <duff@adacore.com>\n\n\t* atree.adb: Make nnd apply to everything \"interesting\", including\n\tRewrite.  Remove rrd.\n\n2017-10-09  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_ch3.adb (Expand_N_Object_Declaration): Avoid never-ending loop\n\tprocessing the declaration of the dummy object internally created by\n\tMake_DT to compute the offset to the top of components referencing\n\tsecondary dispatch tables.\n\t(Initialize_Tag): Do not initialize the offset-to-top field if it has\n\tbeen initialized initialized.\n\t* exp_disp.ads (Building_Static_Secondary_DT): New subprogram.\n\t* exp_disp.adb (Building_Static_Secondary_DT): New subprogram.\n\t(Make_DT): Create a dummy constant object if we can statically build\n\tsecondary dispatch tables.\n\t(Make_Secondary_DT): For statically allocated secondary dispatch tables\n\tuse the dummy object to compute the offset-to-top field value by means\n\tof the attribute 'Position.\n\ngcc/testsuite/\n\n2017-10-09  Ed Schonberg  <schonberg@adacore.com>\n\n\t* gnat.dg/class_wide3.adb, gnat.dg/class_wide3_pkg.ads: New testcase.\n\nFrom-SVN: r253550", "tree": {"sha": "502d3d4524dac42d6f46e6e143c46c1c92fa6ac8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/502d3d4524dac42d6f46e6e143c46c1c92fa6ac8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15529d0aa0264ae211db7acfebd1e23c8a944123", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15529d0aa0264ae211db7acfebd1e23c8a944123", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15529d0aa0264ae211db7acfebd1e23c8a944123", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15529d0aa0264ae211db7acfebd1e23c8a944123/comments", "author": null, "committer": null, "parents": [{"sha": "5168a9b3d09e3da03cc51a09fd28813ff6b49b96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5168a9b3d09e3da03cc51a09fd28813ff6b49b96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5168a9b3d09e3da03cc51a09fd28813ff6b49b96"}], "stats": {"total": 949, "additions": 573, "deletions": 376}, "files": [{"sha": "cba97a1860b055bf7d11d0fd4acb0b5f32d91d4a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15529d0aa0264ae211db7acfebd1e23c8a944123/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15529d0aa0264ae211db7acfebd1e23c8a944123/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=15529d0aa0264ae211db7acfebd1e23c8a944123", "patch": "@@ -1,3 +1,48 @@\n+2017-10-09  Bob Duff  <duff@adacore.com>\n+\n+\t* exp_ch6.adb: (Make_Build_In_Place_Call_In_Object_Declaration): Remove\n+\tthe code at the end of this procedure that was setting the type of a\n+\tclass-wide object to the specific type returned by a function call.\n+\tTreat this case as indefinite instead.\n+\n+2017-10-09  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch4.adb (Try_Class_Wide_Operation, Traverse_Homonyms):\n+\tSuppress spurious ambiguity error when two traversals of the homonym\n+\tchain (first directly, and then through an examination of relevant\n+\tinterfaces) retrieve the same operation, when other irrelevant homonyms\n+\tof the operatioh are also present.\n+\n+2017-10-09  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_util.adb (Object_Access_Level): If the object is the return\n+\tstatement of an expression function, return the level of the function.\n+\tThis is relevant when the object involves an implicit conversion\n+\tbetween access types and the expression function is a completion, which\n+\tforces the analysis of the expression before rewriting it as a body, so\n+\tthat freeze nodes can appear in the proper scope.\n+\n+2017-10-09  Bob Duff  <duff@adacore.com>\n+\n+\t* atree.adb: Make nnd apply to everything \"interesting\", including\n+\tRewrite.  Remove rrd.\n+\n+2017-10-09  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_ch3.adb (Expand_N_Object_Declaration): Avoid never-ending loop\n+\tprocessing the declaration of the dummy object internally created by\n+\tMake_DT to compute the offset to the top of components referencing\n+\tsecondary dispatch tables.\n+\t(Initialize_Tag): Do not initialize the offset-to-top field if it has\n+\tbeen initialized initialized.\n+\t* exp_disp.ads (Building_Static_Secondary_DT): New subprogram.\n+\t* exp_disp.adb (Building_Static_Secondary_DT): New subprogram.\n+\t(Make_DT): Create a dummy constant object if we can statically build\n+\tsecondary dispatch tables.\n+\t(Make_Secondary_DT): For statically allocated secondary dispatch tables\n+\tuse the dummy object to compute the offset-to-top field value by means\n+\tof the attribute 'Position.\n+\n 2017-10-09  Bob Duff  <duff@adacore.com>\n \n \t* exp_ch6.adb (Expand_N_Extended_Return_Statement): Add self-checking"}, {"sha": "2519774fcdd3ac79a2e5860a6e9f838da1f26375", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 15, "deletions": 54, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15529d0aa0264ae211db7acfebd1e23c8a944123/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15529d0aa0264ae211db7acfebd1e23c8a944123/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=15529d0aa0264ae211db7acfebd1e23c8a944123", "patch": "@@ -73,11 +73,12 @@ package body Atree is\n    --     ww := 12345\n    --  and set a breakpoint on New_Node_Breakpoint (nickname \"nn\"). Continue.\n \n-   --  Either way, gnat1 will stop when node 12345 is created\n+   --  Either way, gnat1 will stop when node 12345 is created, or certain other\n+   --  interesting operations are performed, such as Rewrite. To see exactly\n+   --  which operations, search for \"pragma Debug\" below.\n \n-   --  The second method is much faster\n-\n-   --  Similarly, rr and rrd allow breaking on rewriting of a given node\n+   --  The second method is much faster if the amount of Ada code being\n+   --  compiled is large.\n \n    ww : Node_Id'Base := Node_Id'First - 1;\n    pragma Export (Ada, ww); --  trick the optimizer\n@@ -103,24 +104,8 @@ package body Atree is\n    --  If Node = Watch_Node, this prints out the new node and calls\n    --  New_Node_Breakpoint. Otherwise, does nothing.\n \n-   procedure rr;\n-   pragma Export (Ada, rr);\n-   procedure Rewrite_Breakpoint renames rr;\n-   --  This doesn't do anything interesting; it's just for setting breakpoint\n-   --  on as explained above.\n-\n-   procedure rrd (Old_Node, New_Node : Node_Id);\n-   pragma Export (Ada, rrd);\n-   procedure Rewrite_Debugging_Output\n-     (Old_Node, New_Node : Node_Id) renames rrd;\n-   --  For debugging. If debugging is turned on, Rewrite calls this. If debug\n-   --  flag N is turned on, this prints out the new node.\n-   --\n-   --  If Old_Node = Watch_Node, this prints out the old and new nodes and\n-   --  calls Rewrite_Breakpoint. Otherwise, does nothing.\n-\n    procedure Node_Debug_Output (Op : String; N : Node_Id);\n-   --  Common code for nnd and rrd, writes Op followed by information about N\n+   --  Called by nnd; writes Op followed by information about N\n \n    procedure Print_Statistics;\n    pragma Export (Ada, Print_Statistics);\n@@ -751,6 +736,8 @@ package body Atree is\n       Save_Link    : constant Union_Id := Nodes.Table (Destination).Link;\n \n    begin\n+      pragma Debug (New_Node_Debugging_Output (Source));\n+      pragma Debug (New_Node_Debugging_Output (Destination));\n       Nodes.Table (Destination)         := Nodes.Table (Source);\n       Nodes.Table (Destination).In_List := Save_In_List;\n       Nodes.Table (Destination).Link    := Save_Link;\n@@ -1348,6 +1335,8 @@ package body Atree is\n       Temp_Flg : Flags_Byte;\n \n    begin\n+      pragma Debug (New_Node_Debugging_Output (E1));\n+      pragma Debug (New_Node_Debugging_Output (E2));\n       pragma Assert (True\n         and then Has_Extension (E1)\n         and then Has_Extension (E2)\n@@ -1746,7 +1735,6 @@ package body Atree is\n    begin\n       Write_Str (\"Watched node \");\n       Write_Int (Int (Watch_Node));\n-      Write_Str (\" created\");\n       Write_Eol;\n    end nn;\n \n@@ -1759,7 +1747,7 @@ package body Atree is\n \n    begin\n       if Debug_Flag_N or else Node_Is_Watched then\n-         Node_Debug_Output (\"Allocate\", N);\n+         Node_Debug_Output (\"Node\", N);\n \n          if Node_Is_Watched then\n             New_Node_Breakpoint;\n@@ -2163,6 +2151,8 @@ package body Atree is\n         (not Has_Extension (Old_Node)\n           and not Has_Extension (New_Node)\n           and not Nodes.Table (New_Node).In_List);\n+      pragma Debug (New_Node_Debugging_Output (Old_Node));\n+      pragma Debug (New_Node_Debugging_Output (New_Node));\n \n       --  Do copy, preserving link and in list status and required flags\n \n@@ -2214,7 +2204,8 @@ package body Atree is\n         (not Has_Extension (Old_Node)\n           and not Has_Extension (New_Node)\n           and not Nodes.Table (New_Node).In_List);\n-      pragma Debug (Rewrite_Debugging_Output (Old_Node, New_Node));\n+      pragma Debug (New_Node_Debugging_Output (Old_Node));\n+      pragma Debug (New_Node_Debugging_Output (New_Node));\n \n       if Nkind (Old_Node) in N_Subexpr then\n          Old_Paren_Count     := Paren_Count (Old_Node);\n@@ -2264,36 +2255,6 @@ package body Atree is\n       end if;\n    end Rewrite;\n \n-   -------------------------\n-   -- Rewrite_Breakpoint --\n-   -------------------------\n-\n-   procedure rr is\n-   begin\n-      Write_Str (\"Watched node \");\n-      Write_Int (Int (Watch_Node));\n-      Write_Str (\" rewritten\");\n-      Write_Eol;\n-   end rr;\n-\n-   ------------------------------\n-   -- Rewrite_Debugging_Output --\n-   ------------------------------\n-\n-   procedure rrd (Old_Node, New_Node : Node_Id) is\n-      Node_Is_Watched : constant Boolean := Old_Node = Watch_Node;\n-\n-   begin\n-      if Debug_Flag_N or else Node_Is_Watched then\n-         Node_Debug_Output (\"Rewrite\", Old_Node);\n-         Node_Debug_Output (\"into\",    New_Node);\n-\n-         if Node_Is_Watched then\n-            Rewrite_Breakpoint;\n-         end if;\n-      end if;\n-   end rrd;\n-\n    ------------------\n    -- Set_Analyzed --\n    ------------------"}, {"sha": "8cc9cfd94e3fb0baab3d580d36c280bbeecce7a6", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15529d0aa0264ae211db7acfebd1e23c8a944123/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15529d0aa0264ae211db7acfebd1e23c8a944123/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=15529d0aa0264ae211db7acfebd1e23c8a944123", "patch": "@@ -6138,6 +6138,19 @@ package body Exp_Ch3 is\n          return;\n       end if;\n \n+      --  No action needed for the internal imported dummy object added by\n+      --  Make_DT to compute the offset of the components that reference\n+      --  secondary dispatch tables; required to avoid never-ending loop\n+      --  processing this internal object declaration.\n+\n+      if Tagged_Type_Expansion\n+        and then Is_Internal (Def_Id)\n+        and then Is_Imported (Def_Id)\n+        and then Related_Type (Def_Id) = Implementation_Base_Type (Typ)\n+      then\n+         return;\n+      end if;\n+\n       --  First we do special processing for objects of a tagged type where\n       --  this is the point at which the type is frozen. The creation of the\n       --  dispatch table and the initialization procedure have to be deferred\n@@ -8384,10 +8397,13 @@ package body Exp_Ch3 is\n          --  Normal case: No discriminants in the parent type\n \n          else\n-            --  Don't need to set any value if this interface shares the\n-            --  primary dispatch table.\n+            --  Don't need to set any value if the offset-to-top field is\n+            --  statically set or if this interface shares the primary\n+            --  dispatch table.\n \n-            if not Is_Ancestor (Iface, Typ, Use_Full_View => True) then\n+            if not Building_Static_Secondary_DT (Typ)\n+              and then not Is_Ancestor (Iface, Typ, Use_Full_View => True)\n+            then\n                Append_To (Stmts_List,\n                  Build_Set_Static_Offset_To_Top (Loc,\n                    Iface_Tag    => New_Occurrence_Of (Iface_Tag, Loc),"}, {"sha": "f0afc1e911122cb78fd5bcc87d65ea3bf31c4bf2", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 298, "deletions": 306, "changes": 604, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15529d0aa0264ae211db7acfebd1e23c8a944123/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15529d0aa0264ae211db7acfebd1e23c8a944123/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=15529d0aa0264ae211db7acfebd1e23c8a944123", "patch": "@@ -5024,16 +5024,15 @@ package body Exp_Ch6 is\n                --  existing object for use as the return object. If the value\n                --  is two, then the return object must be allocated on the\n                --  secondary stack. Otherwise, the object must be allocated in\n-               --  a storage pool (currently only supported for the global\n-               --  heap, user-defined storage pools TBD ???). We generate an\n-               --  if statement to test the implicit allocation formal and\n-               --  initialize a local access value appropriately, creating\n-               --  allocators in the secondary stack and global heap cases.\n-               --  The special formal also exists and must be tested when the\n-               --  function has a tagged result, even when the result subtype\n-               --  is constrained, because in general such functions can be\n-               --  called in dispatching contexts and must be handled similarly\n-               --  to functions with a class-wide result.\n+               --  a storage pool. We generate an if statement to test the\n+               --  implicit allocation formal and initialize a local access\n+               --  value appropriately, creating allocators in the secondary\n+               --  stack and global heap cases.  The special formal also exists\n+               --  and must be tested when the function has a tagged result,\n+               --  even when the result subtype is constrained, because in\n+               --  general such functions can be called in dispatching contexts\n+               --  and must be handled similarly to functions with a class-wide\n+               --  result.\n \n                if not Is_Constrained (Ret_Typ)\n                  or else Is_Tagged_Type (Underlying_Type (Ret_Typ))\n@@ -8192,7 +8191,28 @@ package body Exp_Ch6 is\n      (Obj_Decl      : Node_Id;\n       Function_Call : Node_Id)\n    is\n+      function Get_Function_Id (Func_Call : Node_Id) return Entity_Id;\n+      --  Get the value of Function_Id, below\n+\n+      function Get_Function_Id (Func_Call : Node_Id) return Entity_Id is\n+      begin\n+         if Is_Entity_Name (Name (Func_Call)) then\n+            return Entity (Name (Func_Call));\n+\n+         elsif Nkind (Name (Func_Call)) = N_Explicit_Dereference then\n+            return Etype (Name (Func_Call));\n+\n+         else\n+            raise Program_Error;\n+         end if;\n+      end Get_Function_Id;\n+\n+      Func_Call       : constant Node_Id   := Unqual_Conv (Function_Call);\n+      Function_Id     : constant Entity_Id := Get_Function_Id (Func_Call);\n+      Result_Subt     : constant Entity_Id := Etype (Function_Id);\n+\n       Obj_Def_Id : constant Entity_Id  := Defining_Identifier (Obj_Decl);\n+      Obj_Typ    : constant Entity_Id  := Etype (Obj_Def_Id);\n       Encl_Func  : constant Entity_Id  := Enclosing_Subprogram (Obj_Def_Id);\n       Loc        : constant Source_Ptr := Sloc (Function_Call);\n       Obj_Loc    : constant Source_Ptr := Sloc (Obj_Decl);\n@@ -8201,361 +8221,333 @@ package body Exp_Ch6 is\n       Caller_Object   : Node_Id;\n       Def_Id          : Entity_Id;\n       Fmaster_Actual  : Node_Id := Empty;\n-      Func_Call       : constant Node_Id := Unqual_Conv (Function_Call);\n-      Function_Id     : Entity_Id;\n       Pool_Actual     : Node_Id;\n       Designated_Type : Entity_Id;\n       Ptr_Typ         : Entity_Id;\n       Ptr_Typ_Decl    : Node_Id;\n       Pass_Caller_Acc : Boolean := False;\n       Res_Decl        : Node_Id;\n-      Result_Subt     : Entity_Id;\n+\n+      Definite : constant Boolean :=\n+                   Caller_Known_Size (Func_Call, Result_Subt)\n+                   and then not Is_Class_Wide_Type (Obj_Typ);\n+      --  In the case of \"X : T'Class := F(...);\", where F returns a\n+      --  Caller_Known_Size (specific) tagged type, we treat it as\n+      --  indefinite, because the code for the Definite case below sets the\n+      --  initialization expression of the object to Empty, which would be\n+      --  illegal Ada, and would cause gigi to mis-allocate X.\n \n    begin\n       --  Mark the call as processed as a build-in-place call\n \n       pragma Assert (not Is_Expanded_Build_In_Place_Call (Func_Call));\n       Set_Is_Expanded_Build_In_Place_Call (Func_Call);\n \n-      if Is_Entity_Name (Name (Func_Call)) then\n-         Function_Id := Entity (Name (Func_Call));\n+      --  Create an access type designating the function's result subtype.\n+      --  We use the type of the original call because it may be a call to an\n+      --  inherited operation, which the expansion has replaced with the parent\n+      --  operation that yields the parent type. Note that this access type\n+      --  must be declared before we establish a transient scope, so that it\n+      --  receives the proper accessibility level.\n \n-      elsif Nkind (Name (Func_Call)) = N_Explicit_Dereference then\n-         Function_Id := Etype (Name (Func_Call));\n+      if Is_Class_Wide_Type (Obj_Typ)\n+        and then not Is_Interface (Obj_Typ)\n+        and then not Is_Class_Wide_Type (Etype (Function_Call))\n+      then\n+         Designated_Type := Obj_Typ;\n+      else\n+         Designated_Type := Etype (Function_Call);\n+      end if;\n \n+      Ptr_Typ := Make_Temporary (Loc, 'A');\n+      Ptr_Typ_Decl :=\n+        Make_Full_Type_Declaration (Loc,\n+          Defining_Identifier => Ptr_Typ,\n+          Type_Definition     =>\n+            Make_Access_To_Object_Definition (Loc,\n+              All_Present        => True,\n+              Subtype_Indication =>\n+                New_Occurrence_Of (Designated_Type, Loc)));\n+\n+      --  The access type and its accompanying object must be inserted after\n+      --  the object declaration in the constrained case, so that the function\n+      --  call can be passed access to the object. In the indefinite case, or\n+      --  if the object declaration is for a return object, the access type and\n+      --  object must be inserted before the object, since the object\n+      --  declaration is rewritten to be a renaming of a dereference of the\n+      --  access object. Note: we need to freeze Ptr_Typ explicitly, because\n+      --  the result object is in a different (transient) scope, so won't cause\n+      --  freezing.\n+\n+      if Definite\n+        and then not Is_Return_Object (Obj_Def_Id)\n+      then\n+         Insert_After_And_Analyze (Obj_Decl, Ptr_Typ_Decl);\n       else\n-         raise Program_Error;\n+         Insert_Action (Obj_Decl, Ptr_Typ_Decl);\n       end if;\n \n-      Result_Subt := Etype (Function_Id);\n+      --  Force immediate freezing of Ptr_Typ because Res_Decl will be\n+      --  elaborated in an inner (transient) scope and thus won't cause\n+      --  freezing by itself. It's not an itype, but it needs to be frozen\n+      --  inside the current subprogram (see Freeze_Outside in freeze.adb).\n+\n+      Freeze_Itype (Ptr_Typ, Ptr_Typ_Decl);\n+\n+      --  If the object is a return object of an enclosing build-in-place\n+      --  function, then the implicit build-in-place parameters of the\n+      --  enclosing function are simply passed along to the called function.\n+      --  (Unfortunately, this won't cover the case of extension aggregates\n+      --  where the ancestor part is a build-in-place indefinite function\n+      --  call that should be passed along the caller's parameters.\n+      --  Currently those get mishandled by reassigning the result of the\n+      --  call to the aggregate return object, when the call result should\n+      --  really be directly built in place in the aggregate and not in a\n+      --  temporary. ???)\n+\n+      if Is_Return_Object (Obj_Def_Id) then\n+         Pass_Caller_Acc := True;\n+\n+         --  When the enclosing function has a BIP_Alloc_Form formal then we\n+         --  pass it along to the callee (such as when the enclosing\n+         --  function has an unconstrained or tagged result type).\n+\n+         if Needs_BIP_Alloc_Form (Encl_Func) then\n+            if RTE_Available (RE_Root_Storage_Pool_Ptr) then\n+               Pool_Actual :=\n+                 New_Occurrence_Of\n+                   (Build_In_Place_Formal\n+                     (Encl_Func, BIP_Storage_Pool), Loc);\n \n-      declare\n-         Definite : constant Boolean :=\n-                      Caller_Known_Size (Func_Call, Result_Subt);\n+            --  The build-in-place pool formal is not built on e.g. ZFP\n \n-      begin\n-         --  Create an access type designating the function's result subtype.\n-         --  We use the type of the original call because it may be a call to\n-         --  an inherited operation, which the expansion has replaced with the\n-         --  parent operation that yields the parent type. Note that this\n-         --  access type must be declared before we establish a transient\n-         --  scope, so that it receives the proper accessibility level.\n-\n-         if Is_Class_Wide_Type (Etype (Defining_Identifier (Obj_Decl)))\n-           and then not Is_Interface (Etype (Defining_Identifier (Obj_Decl)))\n-           and then not Is_Class_Wide_Type (Etype (Function_Call))\n-         then\n-            Designated_Type := Etype (Defining_Identifier (Obj_Decl));\n-         else\n-            Designated_Type := Etype (Function_Call);\n-         end if;\n+            else\n+               Pool_Actual := Empty;\n+            end if;\n+\n+            Add_Unconstrained_Actuals_To_Build_In_Place_Call\n+              (Function_Call  => Func_Call,\n+               Function_Id    => Function_Id,\n+               Alloc_Form_Exp =>\n+                 New_Occurrence_Of\n+                   (Build_In_Place_Formal (Encl_Func, BIP_Alloc_Form), Loc),\n+               Pool_Actual    => Pool_Actual);\n+\n+         --  Otherwise, if enclosing function has a definite result subtype,\n+         --  then caller allocation will be used.\n \n-         Ptr_Typ := Make_Temporary (Loc, 'A');\n-         Ptr_Typ_Decl :=\n-           Make_Full_Type_Declaration (Loc,\n-             Defining_Identifier => Ptr_Typ,\n-             Type_Definition     =>\n-               Make_Access_To_Object_Definition (Loc,\n-                 All_Present        => True,\n-                 Subtype_Indication =>\n-                   New_Occurrence_Of (Designated_Type, Loc)));\n-\n-         --  The access type and its accompanying object must be inserted after\n-         --  the object declaration in the constrained case, so that the\n-         --  function call can be passed access to the object. In the\n-         --  indefinite case, or if the object declaration is for a return\n-         --  object, the access type and object must be inserted before the\n-         --  object, since the object declaration is rewritten to be a renaming\n-         --  of a dereference of the access object. Note: we need to freeze\n-         --  Ptr_Typ explicitly, because the result object is in a different\n-         --  (transient) scope, so won't cause freezing.\n-\n-         if Definite\n-           and then not Is_Return_Object (Defining_Identifier (Obj_Decl))\n-         then\n-            Insert_After_And_Analyze (Obj_Decl, Ptr_Typ_Decl);\n          else\n-            Insert_Action (Obj_Decl, Ptr_Typ_Decl);\n+            Add_Unconstrained_Actuals_To_Build_In_Place_Call\n+              (Func_Call, Function_Id, Alloc_Form => Caller_Allocation);\n          end if;\n \n-         --  Force immediate freezing of Ptr_Typ because Res_Decl will be\n-         --  elaborated in an inner (transient) scope and thus won't cause\n-         --  freezing by itself. It's not an itype, but it needs to be frozen\n-         --  inside the current subprogram (see Freeze_Outside in freeze.adb).\n-\n-         Freeze_Itype (Ptr_Typ, Ptr_Typ_Decl);\n+         if Needs_BIP_Finalization_Master (Encl_Func) then\n+            Fmaster_Actual :=\n+              New_Occurrence_Of\n+                (Build_In_Place_Formal\n+                   (Encl_Func, BIP_Finalization_Master), Loc);\n+         end if;\n \n-         --  If the object is a return object of an enclosing build-in-place\n-         --  function, then the implicit build-in-place parameters of the\n-         --  enclosing function are simply passed along to the called function.\n-         --  (Unfortunately, this won't cover the case of extension aggregates\n-         --  where the ancestor part is a build-in-place indefinite function\n-         --  call that should be passed along the caller's parameters.\n-         --  Currently those get mishandled by reassigning the result of the\n-         --  call to the aggregate return object, when the call result should\n-         --  really be directly built in place in the aggregate and not in a\n-         --  temporary. ???)\n+         --  Retrieve the BIPacc formal from the enclosing function and convert\n+         --  it to the access type of the callee's BIP_Object_Access formal.\n \n-         if Is_Return_Object (Defining_Identifier (Obj_Decl)) then\n-            Pass_Caller_Acc := True;\n+         Caller_Object :=\n+           Make_Unchecked_Type_Conversion (Loc,\n+             Subtype_Mark =>\n+               New_Occurrence_Of\n+                 (Etype\n+                    (Build_In_Place_Formal\n+                      (Function_Id, BIP_Object_Access)),\n+                  Loc),\n+             Expression   =>\n+               New_Occurrence_Of\n+                 (Build_In_Place_Formal (Encl_Func, BIP_Object_Access),\n+                  Loc));\n \n-            --  When the enclosing function has a BIP_Alloc_Form formal then we\n-            --  pass it along to the callee (such as when the enclosing\n-            --  function has an unconstrained or tagged result type).\n+      --  In the definite case, add an implicit actual to the function call\n+      --  that provides access to the declared object. An unchecked conversion\n+      --  to the (specific) result type of the function is inserted to handle\n+      --  the case where the object is declared with a class-wide type.\n \n-            if Needs_BIP_Alloc_Form (Encl_Func) then\n-               if RTE_Available (RE_Root_Storage_Pool_Ptr) then\n-                  Pool_Actual :=\n-                    New_Occurrence_Of\n-                      (Build_In_Place_Formal\n-                        (Encl_Func, BIP_Storage_Pool), Loc);\n+      elsif Definite then\n+         Caller_Object :=\n+            Make_Unchecked_Type_Conversion (Loc,\n+              Subtype_Mark => New_Occurrence_Of (Result_Subt, Loc),\n+              Expression   => New_Occurrence_Of (Obj_Def_Id, Loc));\n \n-               --  The build-in-place pool formal is not built on e.g. ZFP\n+         --  When the function has a controlling result, an allocation-form\n+         --  parameter must be passed indicating that the caller is allocating\n+         --  the result object. This is needed because such a function can be\n+         --  called as a dispatching operation and must be treated similarly to\n+         --  functions with indefinite result subtypes.\n \n-               else\n-                  Pool_Actual := Empty;\n-               end if;\n+         Add_Unconstrained_Actuals_To_Build_In_Place_Call\n+           (Func_Call, Function_Id, Alloc_Form => Caller_Allocation);\n \n-               Add_Unconstrained_Actuals_To_Build_In_Place_Call\n-                 (Function_Call  => Func_Call,\n-                  Function_Id    => Function_Id,\n-                  Alloc_Form_Exp =>\n-                    New_Occurrence_Of\n-                      (Build_In_Place_Formal (Encl_Func, BIP_Alloc_Form), Loc),\n-                  Pool_Actual    => Pool_Actual);\n+      --  The allocation for indefinite library-level objects occurs on the\n+      --  heap as opposed to the secondary stack. This accommodates DLLs where\n+      --  the secondary stack is destroyed after each library unload. This is a\n+      --  hybrid mechanism where a stack-allocated object lives on the heap.\n \n-            --  Otherwise, if enclosing function has a definite result subtype,\n-            --  then caller allocation will be used.\n+      elsif Is_Library_Level_Entity (Obj_Def_Id)\n+        and then not Restriction_Active (No_Implicit_Heap_Allocations)\n+      then\n+         Add_Unconstrained_Actuals_To_Build_In_Place_Call\n+           (Func_Call, Function_Id, Alloc_Form => Global_Heap);\n+         Caller_Object := Empty;\n \n-            else\n-               Add_Unconstrained_Actuals_To_Build_In_Place_Call\n-                 (Func_Call, Function_Id, Alloc_Form => Caller_Allocation);\n-            end if;\n+         --  Create a finalization master for the access result type to ensure\n+         --  that the heap allocation can properly chain the object and later\n+         --  finalize it when the library unit goes out of scope.\n \n-            if Needs_BIP_Finalization_Master (Encl_Func) then\n-               Fmaster_Actual :=\n-                 New_Occurrence_Of\n-                   (Build_In_Place_Formal\n-                      (Encl_Func, BIP_Finalization_Master), Loc);\n-            end if;\n+         if Needs_Finalization (Etype (Func_Call)) then\n+            Build_Finalization_Master\n+              (Typ            => Ptr_Typ,\n+               For_Lib_Level  => True,\n+               Insertion_Node => Ptr_Typ_Decl);\n \n-            --  Retrieve the BIPacc formal from the enclosing function and\n-            --  convert it to the access type of the callee's BIP_Object_Access\n-            --  formal.\n-\n-            Caller_Object :=\n-              Make_Unchecked_Type_Conversion (Loc,\n-                Subtype_Mark =>\n-                  New_Occurrence_Of\n-                    (Etype\n-                       (Build_In_Place_Formal\n-                         (Function_Id, BIP_Object_Access)),\n-                     Loc),\n-                Expression   =>\n-                  New_Occurrence_Of\n-                    (Build_In_Place_Formal (Encl_Func, BIP_Object_Access),\n-                     Loc));\n-\n-         --  In the definite case, add an implicit actual to the function call\n-         --  that provides access to the declared object. An unchecked\n-         --  conversion to the (specific) result type of the function is\n-         --  inserted to handle the case where the object is declared with a\n-         --  class-wide type.\n-\n-         elsif Definite then\n-            Caller_Object :=\n-               Make_Unchecked_Type_Conversion (Loc,\n-                 Subtype_Mark => New_Occurrence_Of (Result_Subt, Loc),\n-                 Expression   => New_Occurrence_Of (Obj_Def_Id, Loc));\n-\n-            --  When the function has a controlling result, an allocation-form\n-            --  parameter must be passed indicating that the caller is\n-            --  allocating the result object. This is needed because such a\n-            --  function can be called as a dispatching operation and must be\n-            --  treated similarly to functions with indefinite result subtypes.\n+            Fmaster_Actual :=\n+              Make_Attribute_Reference (Loc,\n+                Prefix         =>\n+                  New_Occurrence_Of (Finalization_Master (Ptr_Typ), Loc),\n+                Attribute_Name => Name_Unrestricted_Access);\n+         end if;\n \n-            Add_Unconstrained_Actuals_To_Build_In_Place_Call\n-              (Func_Call, Function_Id, Alloc_Form => Caller_Allocation);\n+      --  In other indefinite cases, pass an indication to do the allocation on\n+      --  the secondary stack and set Caller_Object to Empty so that a null\n+      --  value will be passed for the caller's object address. A transient\n+      --  scope is established to ensure eventual cleanup of the result.\n \n-         --  The allocation for indefinite library-level objects occurs on the\n-         --  heap as opposed to the secondary stack. This accommodates DLLs\n-         --  where the secondary stack is destroyed after each library\n-         --  unload. This is a hybrid mechanism where a stack-allocated object\n-         --  lives on the heap.\n+      else\n+         Add_Unconstrained_Actuals_To_Build_In_Place_Call\n+           (Func_Call, Function_Id, Alloc_Form => Secondary_Stack);\n+         Caller_Object := Empty;\n \n-         elsif Is_Library_Level_Entity (Defining_Identifier (Obj_Decl))\n-           and then not Restriction_Active (No_Implicit_Heap_Allocations)\n-         then\n-            Add_Unconstrained_Actuals_To_Build_In_Place_Call\n-              (Func_Call, Function_Id, Alloc_Form => Global_Heap);\n-            Caller_Object := Empty;\n+         Establish_Transient_Scope (Obj_Decl, Sec_Stack => True);\n+      end if;\n \n-            --  Create a finalization master for the access result type to\n-            --  ensure that the heap allocation can properly chain the object\n-            --  and later finalize it when the library unit goes out of scope.\n+      --  Pass along any finalization master actual, which is needed in the\n+      --  case where the called function initializes a return object of an\n+      --  enclosing build-in-place function.\n \n-            if Needs_Finalization (Etype (Func_Call)) then\n-               Build_Finalization_Master\n-                 (Typ            => Ptr_Typ,\n-                  For_Lib_Level  => True,\n-                  Insertion_Node => Ptr_Typ_Decl);\n+      Add_Finalization_Master_Actual_To_Build_In_Place_Call\n+        (Func_Call  => Func_Call,\n+         Func_Id    => Function_Id,\n+         Master_Exp => Fmaster_Actual);\n \n-               Fmaster_Actual :=\n-                 Make_Attribute_Reference (Loc,\n-                   Prefix         =>\n-                     New_Occurrence_Of (Finalization_Master (Ptr_Typ), Loc),\n-                   Attribute_Name => Name_Unrestricted_Access);\n-            end if;\n+      if Nkind (Parent (Obj_Decl)) = N_Extended_Return_Statement\n+        and then Has_Task (Result_Subt)\n+      then\n+         --  Here we're passing along the master that was passed in to this\n+         --  function.\n \n-         --  In other indefinite cases, pass an indication to do the allocation\n-         --  on the secondary stack and set Caller_Object to Empty so that a\n-         --  null value will be passed for the caller's object address. A\n-         --  transient scope is established to ensure eventual cleanup of the\n-         --  result.\n+         Add_Task_Actuals_To_Build_In_Place_Call\n+           (Func_Call, Function_Id,\n+            Master_Actual =>\n+              New_Occurrence_Of\n+                (Build_In_Place_Formal (Encl_Func, BIP_Task_Master), Loc));\n \n-         else\n-            Add_Unconstrained_Actuals_To_Build_In_Place_Call\n-              (Func_Call, Function_Id, Alloc_Form => Secondary_Stack);\n-            Caller_Object := Empty;\n+      else\n+         Add_Task_Actuals_To_Build_In_Place_Call\n+           (Func_Call, Function_Id, Make_Identifier (Loc, Name_uMaster));\n+      end if;\n \n-            Establish_Transient_Scope (Obj_Decl, Sec_Stack => True);\n-         end if;\n+      Add_Access_Actual_To_Build_In_Place_Call\n+        (Func_Call,\n+         Function_Id,\n+         Caller_Object,\n+         Is_Access => Pass_Caller_Acc);\n \n-         --  Pass along any finalization master actual, which is needed in the\n-         --  case where the called function initializes a return object of an\n-         --  enclosing build-in-place function.\n+      --  Finally, create an access object initialized to a reference to the\n+      --  function call. We know this access value cannot be null, so mark the\n+      --  entity accordingly to suppress the access check.\n \n-         Add_Finalization_Master_Actual_To_Build_In_Place_Call\n-           (Func_Call  => Func_Call,\n-            Func_Id    => Function_Id,\n-            Master_Exp => Fmaster_Actual);\n+      Def_Id := Make_Temporary (Loc, 'R', Func_Call);\n+      Set_Etype (Def_Id, Ptr_Typ);\n+      Set_Is_Known_Non_Null (Def_Id);\n \n-         if Nkind (Parent (Obj_Decl)) = N_Extended_Return_Statement\n-           and then Has_Task (Result_Subt)\n-         then\n-            --  Here we're passing along the master that was passed in to this\n-            --  function.\n+      if Nkind (Function_Call) = N_Type_Conversion then\n+         Res_Decl :=\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Def_Id,\n+             Constant_Present    => True,\n+             Object_Definition   => New_Occurrence_Of (Ptr_Typ, Loc),\n+             Expression          =>\n+             Make_Unchecked_Type_Conversion (Loc,\n+                New_Occurrence_Of (Ptr_Typ, Loc),\n+                Make_Reference (Loc, Relocate_Node (Func_Call))));\n+      else\n+         Res_Decl :=\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Def_Id,\n+             Constant_Present    => True,\n+             Object_Definition   => New_Occurrence_Of (Ptr_Typ, Loc),\n+             Expression          =>\n+               Make_Reference (Loc, Relocate_Node (Func_Call)));\n+      end if;\n \n-            Add_Task_Actuals_To_Build_In_Place_Call\n-              (Func_Call, Function_Id,\n-               Master_Actual =>\n-                 New_Occurrence_Of\n-                   (Build_In_Place_Formal (Encl_Func, BIP_Task_Master), Loc));\n+      Insert_After_And_Analyze (Ptr_Typ_Decl, Res_Decl);\n \n-         else\n-            Add_Task_Actuals_To_Build_In_Place_Call\n-              (Func_Call, Function_Id, Make_Identifier (Loc, Name_uMaster));\n-         end if;\n+      --  If the result subtype of the called function is definite and is not\n+      --  itself the return expression of an enclosing BIP function, then mark\n+      --  the object as having no initialization.\n \n-         Add_Access_Actual_To_Build_In_Place_Call\n-           (Func_Call,\n-            Function_Id,\n-            Caller_Object,\n-            Is_Access => Pass_Caller_Acc);\n+      if Definite\n+        and then not Is_Return_Object (Obj_Def_Id)\n+      then\n+         --  The related object declaration is encased in a transient block\n+         --  because the build-in-place function call contains at least one\n+         --  nested function call that produces a controlled transient\n+         --  temporary:\n \n-         --  Finally, create an access object initialized to a reference to the\n-         --  function call. We know this access value cannot be null, so mark\n-         --  the entity accordingly to suppress the access check.\n+         --    Obj : ... := BIP_Func_Call (Ctrl_Func_Call);\n \n-         Def_Id := Make_Temporary (Loc, 'R', Func_Call);\n-         Set_Etype (Def_Id, Ptr_Typ);\n-         Set_Is_Known_Non_Null (Def_Id);\n+         --  Since the build-in-place expansion decouples the call from the\n+         --  object declaration, the finalization machinery lacks the context\n+         --  which prompted the generation of the transient block. To resolve\n+         --  this scenario, store the build-in-place call.\n \n-         if Nkind (Function_Call) = N_Type_Conversion then\n-            Res_Decl :=\n-              Make_Object_Declaration (Loc,\n-                Defining_Identifier => Def_Id,\n-                Constant_Present    => True,\n-                Object_Definition   => New_Occurrence_Of (Ptr_Typ, Loc),\n-                Expression          =>\n-                Make_Unchecked_Type_Conversion (Loc,\n-                   New_Occurrence_Of (Ptr_Typ, Loc),\n-                   Make_Reference (Loc, Relocate_Node (Func_Call))));\n-         else\n-            Res_Decl :=\n-              Make_Object_Declaration (Loc,\n-                Defining_Identifier => Def_Id,\n-                Constant_Present    => True,\n-                Object_Definition   => New_Occurrence_Of (Ptr_Typ, Loc),\n-                Expression          =>\n-                  Make_Reference (Loc, Relocate_Node (Func_Call)));\n+         if Scope_Is_Transient and then Node_To_Be_Wrapped = Obj_Decl then\n+            Set_BIP_Initialization_Call (Obj_Def_Id, Res_Decl);\n          end if;\n \n-         Insert_After_And_Analyze (Ptr_Typ_Decl, Res_Decl);\n-\n-         --  If the result subtype of the called function is definite and is\n-         --  not itself the return expression of an enclosing BIP function,\n-         --  then mark the object as having no initialization.\n-\n-         if Definite\n-           and then not Is_Return_Object (Defining_Identifier (Obj_Decl))\n-         then\n-            --  The related object declaration is encased in a transient block\n-            --  because the build-in-place function call contains at least one\n-            --  nested function call that produces a controlled transient\n-            --  temporary:\n-\n-            --    Obj : ... := BIP_Func_Call (Ctrl_Func_Call);\n-\n-            --  Since the build-in-place expansion decouples the call from the\n-            --  object declaration, the finalization machinery lacks the\n-            --  context which prompted the generation of the transient\n-            --  block. To resolve this scenario, store the build-in-place call.\n-\n-            if Scope_Is_Transient and then Node_To_Be_Wrapped = Obj_Decl then\n-               Set_BIP_Initialization_Call (Obj_Def_Id, Res_Decl);\n-            end if;\n-\n-            Set_Expression (Obj_Decl, Empty);\n-            Set_No_Initialization (Obj_Decl);\n-\n-         --  In case of an indefinite result subtype, or if the call is the\n-         --  return expression of an enclosing BIP function, rewrite the object\n-         --  declaration as an object renaming where the renamed object is a\n-         --  dereference of <function_Call>'reference:\n-         --\n-         --      Obj : Subt renames <function_call>'Ref.all;\n+         Set_Expression (Obj_Decl, Empty);\n+         Set_No_Initialization (Obj_Decl);\n \n-         else\n-            Call_Deref :=\n-              Make_Explicit_Dereference (Obj_Loc,\n-                Prefix => New_Occurrence_Of (Def_Id, Obj_Loc));\n-\n-            Rewrite (Obj_Decl,\n-              Make_Object_Renaming_Declaration (Obj_Loc,\n-                Defining_Identifier => Make_Temporary (Obj_Loc, 'D'),\n-                Subtype_Mark =>\n-                  New_Occurrence_Of (Designated_Type, Obj_Loc),\n-                Name => Call_Deref));\n-\n-            Set_Renamed_Object (Defining_Identifier (Obj_Decl), Call_Deref);\n-\n-            --  If the original entity comes from source, then mark the new\n-            --  entity as needing debug information, even though it's defined\n-            --  by a generated renaming that does not come from source, so that\n-            --  the Materialize_Entity flag will be set on the entity when\n-            --  Debug_Renaming_Declaration is called during analysis.\n-\n-            if Comes_From_Source (Obj_Def_Id) then\n-               Set_Debug_Info_Needed (Defining_Identifier (Obj_Decl));\n-            end if;\n+      --  In case of an indefinite result subtype, or if the call is the\n+      --  return expression of an enclosing BIP function, rewrite the object\n+      --  declaration as an object renaming where the renamed object is a\n+      --  dereference of <function_Call>'reference:\n+      --\n+      --      Obj : Subt renames <function_call>'Ref.all;\n \n-            Analyze (Obj_Decl);\n-            Replace_Renaming_Declaration_Id\n-              (Obj_Decl, Original_Node (Obj_Decl));\n+      else\n+         Call_Deref :=\n+           Make_Explicit_Dereference (Obj_Loc,\n+             Prefix => New_Occurrence_Of (Def_Id, Obj_Loc));\n+\n+         Rewrite (Obj_Decl,\n+           Make_Object_Renaming_Declaration (Obj_Loc,\n+             Defining_Identifier => Make_Temporary (Obj_Loc, 'D'),\n+             Subtype_Mark =>\n+               New_Occurrence_Of (Designated_Type, Obj_Loc),\n+             Name => Call_Deref));\n+\n+         Set_Renamed_Object (Obj_Def_Id, Call_Deref);\n+\n+         --  If the original entity comes from source, then mark the new\n+         --  entity as needing debug information, even though it's defined\n+         --  by a generated renaming that does not come from source, so that\n+         --  the Materialize_Entity flag will be set on the entity when\n+         --  Debug_Renaming_Declaration is called during analysis.\n+\n+         if Comes_From_Source (Obj_Def_Id) then\n+            Set_Debug_Info_Needed (Obj_Def_Id);\n          end if;\n-      end;\n-\n-      --  If the object entity has a class-wide Etype, then we need to change\n-      --  it to the result subtype of the function call, because otherwise the\n-      --  object will be class-wide without an explicit initialization and\n-      --  won't be allocated properly by the back end. It seems unclean to make\n-      --  such a revision to the type at this point, and we should try to\n-      --  improve this treatment when build-in-place functions with class-wide\n-      --  results are implemented. ???\n \n-      if Is_Class_Wide_Type (Etype (Defining_Identifier (Obj_Decl))) then\n-         Set_Etype (Defining_Identifier (Obj_Decl), Result_Subt);\n+         Analyze (Obj_Decl);\n+         Replace_Renaming_Declaration_Id\n+           (Obj_Decl, Original_Node (Obj_Decl));\n       end if;\n    end Make_Build_In_Place_Call_In_Object_Declaration;\n "}, {"sha": "80276a9325577f71a5b4ae41199889020f265d48", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 150, "deletions": 12, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15529d0aa0264ae211db7acfebd1e23c8a944123/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15529d0aa0264ae211db7acfebd1e23c8a944123/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=15529d0aa0264ae211db7acfebd1e23c8a944123", "patch": "@@ -29,6 +29,7 @@ with Debug;    use Debug;\n with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Errout;   use Errout;\n+with Expander; use Expander;\n with Exp_Atag; use Exp_Atag;\n with Exp_Ch6;  use Exp_Ch6;\n with Exp_CG;   use Exp_CG;\n@@ -299,6 +300,32 @@ package body Exp_Disp is\n         and then not Is_CPP_Class (Root_Typ);\n    end Building_Static_DT;\n \n+   ----------------------------------\n+   -- Building_Static_Secondary_DT --\n+   ----------------------------------\n+\n+   function Building_Static_Secondary_DT (Typ : Entity_Id) return Boolean is\n+      Full_Typ : Entity_Id := Typ;\n+      Root_Typ : Entity_Id := Root_Type (Typ);\n+\n+   begin\n+      --  Handle private types\n+\n+      if Present (Full_View (Typ)) then\n+         Full_Typ := Full_View (Typ);\n+      end if;\n+\n+      if Present (Full_View (Root_Typ)) then\n+         Root_Typ := Full_View (Root_Typ);\n+      end if;\n+\n+      return Building_Static_DT (Full_Typ)\n+        and then not Is_Interface (Full_Typ)\n+        and then Has_Interfaces (Full_Typ)\n+        and then (Full_Typ = Root_Typ\n+                    or else not Is_Variable_Size_Record (Etype (Full_Typ)));\n+   end Building_Static_Secondary_DT;\n+\n    ----------------------------------\n    -- Build_Static_Dispatch_Tables --\n    ----------------------------------\n@@ -1693,11 +1720,10 @@ package body Exp_Disp is\n \n                if From_Limited_With (Actual_Typ) then\n \n-                  --  If the type of the actual parameter comes from a\n-                  --  limited with-clause and the non-limited view is already\n-                  --  available, we replace the anonymous access type by\n-                  --  a duplicate declaration whose designated type is the\n-                  --  non-limited view.\n+                  --  If the type of the actual parameter comes from a limited\n+                  --  with_clause and the nonlimited view is already available,\n+                  --  we replace the anonymous access type by a duplicate\n+                  --  declaration whose designated type is the nonlimited view.\n \n                   if Has_Non_Limited_View (Actual_DDT) then\n                      Anon := New_Copy (Actual_Typ);\n@@ -3755,6 +3781,11 @@ package body Exp_Disp is\n       DT_Aggr : constant Elist_Id := New_Elmt_List;\n       --  Entities marked with attribute Is_Dispatch_Table_Entity\n \n+      Dummy_Object : Entity_Id := Empty;\n+      --  Extra nonexistent object of type Typ internally used to compute the\n+      --  offset to the components that reference secondary dispatch tables.\n+      --  Used to statically allocate secondary dispatch tables.\n+\n       procedure Check_Premature_Freezing\n         (Subp        : Entity_Id;\n          Tagged_Type : Entity_Id;\n@@ -3783,6 +3814,7 @@ package body Exp_Disp is\n       procedure Make_Secondary_DT\n         (Typ              : Entity_Id;\n          Iface            : Entity_Id;\n+         Iface_Comp       : Node_Id;\n          Suffix_Index     : Int;\n          Num_Iface_Prims  : Nat;\n          Iface_DT_Ptr     : Entity_Id;\n@@ -3941,6 +3973,7 @@ package body Exp_Disp is\n       procedure Make_Secondary_DT\n         (Typ              : Entity_Id;\n          Iface            : Entity_Id;\n+         Iface_Comp       : Node_Id;\n          Suffix_Index     : Int;\n          Num_Iface_Prims  : Nat;\n          Iface_DT_Ptr     : Entity_Id;\n@@ -4179,10 +4212,25 @@ package body Exp_Disp is\n              Prefix         => New_Occurrence_Of (Predef_Prims, Loc),\n              Attribute_Name => Name_Address));\n \n-         --  Note: The correct value of Offset_To_Top will be set by the init\n-         --  subprogram\n+         --  If the location of the component that references this secondary\n+         --  dispatch table is variable then we have not declared the internal\n+         --  dummy object; the value of Offset_To_Top will be set by the init\n+         --  subprogram.\n \n-         Append_To (DT_Aggr_List, Make_Integer_Literal (Loc, 0));\n+         if No (Dummy_Object) then\n+            Append_To (DT_Aggr_List, Make_Integer_Literal (Loc, 0));\n+\n+         else\n+            Append_To (DT_Aggr_List,\n+              Make_Attribute_Reference (Loc,\n+                Prefix         =>\n+                  Make_Selected_Component (Loc,\n+                    Prefix        =>\n+                      New_Occurrence_Of (Dummy_Object, Loc),\n+                    Selector_Name =>\n+                      New_Occurrence_Of (Iface_Comp, Loc)),\n+                Attribute_Name => Name_Position));\n+         end if;\n \n          --  Generate the Object Specific Data table required to dispatch calls\n          --  through synchronized interfaces.\n@@ -4407,15 +4455,16 @@ package body Exp_Disp is\n \n          Append_Elmt (New_Node, DT_Aggr);\n \n-         --  Note: Secondary dispatch tables cannot be declared constant\n-         --  because the component Offset_To_Top is currently initialized\n-         --  by the IP routine.\n+         --  Note: Secondary dispatch tables are declared constant only if\n+         --  we can compute their offset field by means of the extra dummy\n+         --  object; otherwise they cannot be declared constant and the\n+         --  Offset_To_Top component is initialized by the IP routine.\n \n          Append_To (Result,\n            Make_Object_Declaration (Loc,\n              Defining_Identifier => Iface_DT,\n              Aliased_Present     => True,\n-             Constant_Present    => False,\n+             Constant_Present    => Present (Dummy_Object),\n \n              Object_Definition   =>\n                Make_Subtype_Indication (Loc,\n@@ -4678,6 +4727,93 @@ package body Exp_Disp is\n          end;\n       end if;\n \n+      if Building_Static_Secondary_DT (Typ) then\n+         declare\n+            Cannot_Have_Null_Disc : Boolean := False;\n+            Name_Dummy_Object     : constant Name_Id :=\n+                                      New_External_Name (Tname,\n+                                        'P', Suffix_Index => -1);\n+         begin\n+            Dummy_Object := Make_Defining_Identifier (Loc, Name_Dummy_Object);\n+\n+            --  Define the extra object imported and constant to avoid linker\n+            --  errors (since this object is never declared). Required because\n+            --  we implement RM 13.3(19) for exported and imported (variable)\n+            --  objects by making them volatile.\n+\n+            Set_Is_Imported      (Dummy_Object);\n+            Set_Ekind            (Dummy_Object, E_Constant);\n+            Set_Is_True_Constant (Dummy_Object);\n+            Set_Related_Type     (Dummy_Object, Typ);\n+\n+            --  The scope must be set now to call Get_External_Name\n+\n+            Set_Scope (Dummy_Object, Current_Scope);\n+\n+            Get_External_Name (Dummy_Object);\n+            Set_Interface_Name (Dummy_Object,\n+              Make_String_Literal (Loc, Strval => String_From_Name_Buffer));\n+\n+            --  Ensure proper Sprint output of this implicit importation\n+\n+            Set_Is_Internal (Dummy_Object);\n+\n+            if not Has_Discriminants (Typ) then\n+               Append_To (Result,\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier => Dummy_Object,\n+                   Constant_Present    => True,\n+                   Object_Definition   => New_Occurrence_Of (Typ, Loc)));\n+            else\n+               declare\n+                  Constr_List  : constant List_Id := New_List;\n+                  Discrim      : Node_Id;\n+\n+               begin\n+                  Discrim := First_Discriminant (Typ);\n+                  while Present (Discrim) loop\n+                     if Is_Discrete_Type (Etype (Discrim)) then\n+                        Append_To (Constr_List,\n+                          Make_Attribute_Reference (Loc,\n+                            Prefix => New_Occurrence_Of (Etype (Discrim), Loc),\n+                            Attribute_Name => Name_First));\n+\n+                     else\n+                        pragma Assert (Is_Access_Type (Etype (Discrim)));\n+                        Cannot_Have_Null_Disc :=\n+                          Cannot_Have_Null_Disc\n+                            or else Can_Never_Be_Null (Etype (Discrim));\n+                        Append_To (Constr_List, Make_Null (Loc));\n+                     end if;\n+\n+                     Next_Discriminant (Discrim);\n+                  end loop;\n+\n+                  Append_To (Result,\n+                    Make_Object_Declaration (Loc,\n+                      Defining_Identifier => Dummy_Object,\n+                      Constant_Present    => True,\n+                      Object_Definition   =>\n+                        Make_Subtype_Indication (Loc,\n+                          Subtype_Mark => New_Occurrence_Of (Typ, Loc),\n+                          Constraint   =>\n+                            Make_Index_Or_Discriminant_Constraint (Loc,\n+                              Constraints => Constr_List))));\n+               end;\n+            end if;\n+\n+            --  Given that the dummy object will not be declared at run time,\n+            --  analyze its declaration with expansion disabled and warnings\n+            --  and error messages ignored.\n+\n+            Expander_Mode_Save_And_Set (False);\n+            Ignore_Errors_Enable := Ignore_Errors_Enable + 1;\n+            Analyze (Last (Result), Suppress => All_Checks);\n+            Ignore_Errors_Enable := Ignore_Errors_Enable - 1;\n+            Expander_Mode_Restore;\n+         end;\n+      end if;\n+\n       --  Ada 2005 (AI-251): Build the secondary dispatch tables\n \n       if Has_Interfaces (Typ) then\n@@ -4704,6 +4840,7 @@ package body Exp_Disp is\n              (Typ              => Typ,\n               Iface            => Base_Type\n                                     (Related_Type (Node (AI_Tag_Comp))),\n+              Iface_Comp       => Node (AI_Tag_Comp),\n               Suffix_Index     => Suffix_Index,\n               Num_Iface_Prims  => UI_To_Int\n                                     (DT_Entry_Count (Node (AI_Tag_Comp))),\n@@ -4731,6 +4868,7 @@ package body Exp_Disp is\n               (Typ              => Typ,\n                Iface            => Base_Type\n                                      (Related_Type (Node (AI_Tag_Comp))),\n+               Iface_Comp       => Node (AI_Tag_Comp),\n                Suffix_Index     => -1,\n                Num_Iface_Prims  => UI_To_Int\n                                      (DT_Entry_Count (Node (AI_Tag_Comp))),"}, {"sha": "cba4cac4145f5052ff7e19d6868394b7b29ac044", "filename": "gcc/ada/exp_disp.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15529d0aa0264ae211db7acfebd1e23c8a944123/gcc%2Fada%2Fexp_disp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15529d0aa0264ae211db7acfebd1e23c8a944123/gcc%2Fada%2Fexp_disp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.ads?ref=15529d0aa0264ae211db7acfebd1e23c8a944123", "patch": "@@ -174,6 +174,11 @@ package Exp_Disp is\n    pragma Inline (Building_Static_DT);\n    --  Returns true when building statically allocated dispatch tables\n \n+   function Building_Static_Secondary_DT (Typ : Entity_Id) return Boolean;\n+   pragma Inline (Building_Static_Secondary_DT);\n+   --  Returns true when building statically allocated secondary dispatch\n+   --  tables\n+\n    procedure Build_Static_Dispatch_Tables (N : Node_Id);\n    --  N is a library level package declaration or package body. Build the\n    --  static dispatch table of the tagged types defined at library level. In"}, {"sha": "fad52ebd106544b93fbeae5c17abed2c41975434", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15529d0aa0264ae211db7acfebd1e23c8a944123/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15529d0aa0264ae211db7acfebd1e23c8a944123/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=15529d0aa0264ae211db7acfebd1e23c8a944123", "patch": "@@ -8860,7 +8860,7 @@ package body Sem_Ch4 is\n             while Present (Hom) loop\n                if Ekind_In (Hom, E_Procedure, E_Function)\n                  and then (not Is_Hidden (Hom) or else In_Instance)\n-                 and then Scope (Hom) = Scope (Anc_Type)\n+                 and then Scope (Hom) = Scope (Base_Type (Anc_Type))\n                  and then Present (First_Formal (Hom))\n                  and then\n                    (Base_Type (Etype (First_Formal (Hom))) = Cls_Type\n@@ -8921,8 +8921,13 @@ package body Sem_Ch4 is\n                         Success    => Success,\n                         Skip_First => True);\n \n+                     --  The same operation may be encountered on two homonym\n+                     --  traversals, before and after looking at interfaces.\n+                     --  Check for this case before reporting a real ambiguity.\n+\n                      if Present (Valid_Candidate (Success, Call_Node, Hom))\n                        and then Nkind (Call_Node) /= N_Function_Call\n+                       and then Hom /= Matching_Op\n                      then\n                         Error_Msg_NE (\"ambiguous call to&\", N, Hom);\n                         Report_Ambiguity (Matching_Op);"}, {"sha": "420638277602b45c2ca85d326f85bc5187125c1d", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15529d0aa0264ae211db7acfebd1e23c8a944123/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15529d0aa0264ae211db7acfebd1e23c8a944123/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=15529d0aa0264ae211db7acfebd1e23c8a944123", "patch": "@@ -20383,6 +20383,17 @@ package body Sem_Util is\n                                     (Nearest_Dynamic_Scope\n                                        (Defining_Entity (Node_Par)));\n \n+                        --  For a return statement within a function, return\n+                        --  the depth of the function itself. This is not just\n+                        --  a small optimization, but matters when analyzing\n+                        --  the expression in an expression function before\n+                        --  the body is created.\n+\n+                        when N_Simple_Return_Statement =>\n+                           if Ekind (Current_Scope) = E_Function then\n+                              return Scope_Depth (Current_Scope);\n+                           end if;\n+\n                         when others =>\n                            null;\n                      end case;"}, {"sha": "c177029f29dc99e30fcccae8071b1958e0c0c2ff", "filename": "gcc/testsuite/gnat.dg/class_wide3.adb", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15529d0aa0264ae211db7acfebd1e23c8a944123/gcc%2Ftestsuite%2Fgnat.dg%2Fclass_wide3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15529d0aa0264ae211db7acfebd1e23c8a944123/gcc%2Ftestsuite%2Fgnat.dg%2Fclass_wide3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fclass_wide3.adb?ref=15529d0aa0264ae211db7acfebd1e23c8a944123", "patch": "@@ -0,0 +1,8 @@\n+with Ada.Text_IO; use Ada.Text_IO;\n+with Class_Wide3_Pkg; use Class_Wide3_Pkg;\n+\n+procedure Class_Wide3 is\n+   DC : Disc_Child := (N => 1, I => 3, J => 5);\n+begin\n+   DC.Put_Line;\n+end Class_Wide3;"}, {"sha": "a4104fcdebe94549ca61f4e8058d29874336cb96", "filename": "gcc/testsuite/gnat.dg/class_wide3_pkg.ads", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15529d0aa0264ae211db7acfebd1e23c8a944123/gcc%2Ftestsuite%2Fgnat.dg%2Fclass_wide3_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15529d0aa0264ae211db7acfebd1e23c8a944123/gcc%2Ftestsuite%2Fgnat.dg%2Fclass_wide3_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fclass_wide3_pkg.ads?ref=15529d0aa0264ae211db7acfebd1e23c8a944123", "patch": "@@ -0,0 +1,16 @@\n+package Class_Wide3_Pkg is\n+\n+   type Iface is interface;\n+   type Iface_Ptr is access all Iface'Class;\n+\n+   procedure Put_Line (I : Iface'Class);\n+\n+   type Root is tagged record\n+      I : Integer;\n+   end record;\n+\n+   type Disc_Child (N : Integer) is new Root and Iface with record\n+      J : Integer;\n+   end record;\n+\n+end Class_Wide3_Pkg;"}]}