{"sha": "4b267817ff0af3f2d5ec219e57a5db5ddb345543", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGIyNjc4MTdmZjBhZjNmMmQ1ZWMyMTllNTdhNWRiNWRkYjM0NTU0Mw==", "commit": {"author": {"name": "Francois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2008-05-14T21:51:27Z"}, "committer": {"name": "Fran\u00e7ois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2008-05-14T21:51:27Z"}, "message": "libgfortran.h (gfc_char4_t): New type.\n\n2008-05-14  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n\n\t* libgfortran.h (gfc_char4_t): New type.\n\t(GFC_SIZE_OF_CHAR_KIND): New macro.\n\t(compare_string): Adjust prototype.\n\t(compare_string_char4): New prototype.\n\t* gfortran.map (GFORTRAN_1.1): Add _gfortran_adjustl_char4,\n\t_gfortran_adjustr_char4, _gfortran_compare_string_char4,\n\t_gfortran_concat_string_char4, _gfortran_string_index_char4,\n\t_gfortran_string_len_trim_char4, _gfortran_string_minmax_char4,\n\t_gfortran_string_scan_char4, _gfortran_string_trim_char4 and\n\t_gfortran_string_verify_char4.\n\t* intrinsics/string_intrinsics_inc.c: New file from content of\n\tstring_intrinsics.c with types replaced by macros.\n\t* intrinsics/string_intrinsics.c: Move content to\n\tstring_intrinsics_inc.c.\n\nFrom-SVN: r135313", "tree": {"sha": "4927e53c7e5dc8572ba91ace7e7dd690a041a236", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4927e53c7e5dc8572ba91ace7e7dd690a041a236"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b267817ff0af3f2d5ec219e57a5db5ddb345543", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b267817ff0af3f2d5ec219e57a5db5ddb345543", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b267817ff0af3f2d5ec219e57a5db5ddb345543", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b267817ff0af3f2d5ec219e57a5db5ddb345543/comments", "author": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5fcd67041670039f624444358456f0a29c40b50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5fcd67041670039f624444358456f0a29c40b50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5fcd67041670039f624444358456f0a29c40b50"}], "stats": {"total": 860, "additions": 493, "deletions": 367}, "files": [{"sha": "40d2f09a8756be9ad90c070913ca3d0fb15a0038", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b267817ff0af3f2d5ec219e57a5db5ddb345543/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b267817ff0af3f2d5ec219e57a5db5ddb345543/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=4b267817ff0af3f2d5ec219e57a5db5ddb345543", "patch": "@@ -1,3 +1,20 @@\n+2008-05-14  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\t* libgfortran.h (gfc_char4_t): New type.\n+\t(GFC_SIZE_OF_CHAR_KIND): New macro.\n+\t(compare_string): Adjust prototype.\n+\t(compare_string_char4): New prototype.\n+\t* gfortran.map (GFORTRAN_1.1): Add _gfortran_adjustl_char4,\n+\t_gfortran_adjustr_char4, _gfortran_compare_string_char4,\n+\t_gfortran_concat_string_char4, _gfortran_string_index_char4,\n+\t_gfortran_string_len_trim_char4, _gfortran_string_minmax_char4,\n+\t_gfortran_string_scan_char4, _gfortran_string_trim_char4 and\n+\t_gfortran_string_verify_char4.\n+\t* intrinsics/string_intrinsics_inc.c: New file from content of\n+\tstring_intrinsics.c with types replaced by macros.\n+\t* intrinsics/string_intrinsics.c: Move content to\n+\tstring_intrinsics_inc.c.\n+\n 2008-05-11  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libfortran/36202"}, {"sha": "bd51d80edf3b128a212d54ebf6fc817c6f125f93", "filename": "libgfortran/gfortran.map", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b267817ff0af3f2d5ec219e57a5db5ddb345543/libgfortran%2Fgfortran.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b267817ff0af3f2d5ec219e57a5db5ddb345543/libgfortran%2Fgfortran.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgfortran.map?ref=4b267817ff0af3f2d5ec219e57a5db5ddb345543", "patch": "@@ -1039,6 +1039,16 @@ GFORTRAN_1.1 {\n     _gfortran_erfc_scaled_r16;\n     _gfortran_selected_char_kind;\n     _gfortran_st_wait;\n+    _gfortran_adjustl_char4;\n+    _gfortran_adjustr_char4;\n+    _gfortran_compare_string_char4;\n+    _gfortran_concat_string_char4;\n+    _gfortran_string_index_char4;\n+    _gfortran_string_len_trim_char4;\n+    _gfortran_string_minmax_char4;\n+    _gfortran_string_scan_char4;\n+    _gfortran_string_trim_char4;\n+    _gfortran_string_verify_char4;\n } GFORTRAN_1.0; \n \n F2C_1.0 {"}, {"sha": "f6d9663f0baa3d489b7a69b63f442b4c284e5906", "filename": "libgfortran/intrinsics/string_intrinsics.c", "status": "modified", "additions": 31, "deletions": 365, "changes": 396, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b267817ff0af3f2d5ec219e57a5db5ddb345543/libgfortran%2Fintrinsics%2Fstring_intrinsics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b267817ff0af3f2d5ec219e57a5db5ddb345543/libgfortran%2Fintrinsics%2Fstring_intrinsics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fstring_intrinsics.c?ref=4b267817ff0af3f2d5ec219e57a5db5ddb345543", "patch": "@@ -1,8 +1,7 @@\n /* String intrinsics helper functions.\n-   Copyright 2002, 2005, 2007 Free Software Foundation, Inc.\n-   Contributed by Paul Brook <paul@nowt.org>\n+   Copyright 2008 Free Software Foundation, Inc.\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -42,378 +41,45 @@ Boston, MA 02110-1301, USA.  */\n #include <string.h>\n \n \n-/* String functions.  */\n+/* Helper function to set parts of wide strings to a constant (usually\n+   spaces).  */\n \n-extern void concat_string (GFC_INTEGER_4, char *,\n-\t\t\t   GFC_INTEGER_4, const char *,\n-\t\t\t   GFC_INTEGER_4, const char *);\n-export_proto(concat_string);\n-\n-extern GFC_INTEGER_4 string_len_trim (GFC_INTEGER_4, const char *);\n-export_proto(string_len_trim);\n-\n-extern void adjustl (char *, GFC_INTEGER_4, const char *);\n-export_proto(adjustl);\n-\n-extern void adjustr (char *, GFC_INTEGER_4, const char *);\n-export_proto(adjustr);\n-\n-extern GFC_INTEGER_4 string_index (GFC_INTEGER_4, const char *, GFC_INTEGER_4,\n-\t\t\t\t   const char *, GFC_LOGICAL_4);\n-export_proto(string_index);\n-\n-extern GFC_INTEGER_4 string_scan (GFC_INTEGER_4, const char *, GFC_INTEGER_4,\n-\t\t\t\t  const char *, GFC_LOGICAL_4);\n-export_proto(string_scan);\n-\n-extern GFC_INTEGER_4 string_verify (GFC_INTEGER_4, const char *, GFC_INTEGER_4,\n-\t\t\t\t    const char *, GFC_LOGICAL_4);\n-export_proto(string_verify);\n-\n-extern void string_trim (GFC_INTEGER_4 *, void **, GFC_INTEGER_4, const char *);\n-export_proto(string_trim);\n-\n-extern void string_minmax (GFC_INTEGER_4 *, void **, int, int, ...);\n-export_proto(string_minmax);\n-\n-\n-/* Use for functions which can return a zero-length string.  */\n-static char zero_length_string = '\\0';\n-\n-\n-/* Strings of unequal length are extended with pad characters.  */\n-\n-int\n-compare_string (GFC_INTEGER_4 len1, const char * s1,\n-\t\tGFC_INTEGER_4 len2, const char * s2)\n-{\n-  int res;\n-  const unsigned char *s;\n-  int len;\n-\n-  res = memcmp (s1, s2, (len1 < len2) ? len1 : len2);\n-  if (res != 0)\n-    return res;\n-\n-  if (len1 == len2)\n-    return 0;\n-\n-  if (len1 < len2)\n-    {\n-      len = len2 - len1;\n-      s = (unsigned char *) &s2[len1];\n-      res = -1;\n-    }\n-  else\n-    {\n-      len = len1 - len2;\n-      s = (unsigned char *) &s1[len2];\n-      res = 1;\n-    }\n-\n-  while (len--)\n-    {\n-      if (*s != ' ')\n-        {\n-          if (*s > ' ')\n-            return res;\n-          else\n-            return -res;\n-        }\n-      s++;\n-    }\n-\n-  return 0;\n-}\n-iexport(compare_string);\n-\n-\n-/* The destination and source should not overlap.  */\n-\n-void\n-concat_string (GFC_INTEGER_4 destlen, char * dest,\n-\t       GFC_INTEGER_4 len1, const char * s1,\n-\t       GFC_INTEGER_4 len2, const char * s2)\n-{\n-  if (len1 >= destlen)\n-    {\n-      memcpy (dest, s1, destlen);\n-      return;\n-    }\n-  memcpy (dest, s1, len1);\n-  dest += len1;\n-  destlen -= len1;\n-\n-  if (len2 >= destlen)\n-    {\n-      memcpy (dest, s2, destlen);\n-      return;\n-    }\n-\n-  memcpy (dest, s2, len2);\n-  memset (&dest[len2], ' ', destlen - len2);\n-}\n-\n-\n-/* Return string with all trailing blanks removed.  */\n-\n-void\n-string_trim (GFC_INTEGER_4 * len, void ** dest, GFC_INTEGER_4 slen,\n-\t     const char * src)\n-{\n-  int i;\n-\n-  /* Determine length of result string.  */\n-  for (i = slen - 1; i >= 0; i--)\n-    {\n-      if (src[i] != ' ')\n-        break;\n-    }\n-  *len = i + 1;\n-\n-  if (*len == 0)\n-    *dest = &zero_length_string;\n-  else\n-    {\n-      /* Allocate space for result string.  */\n-      *dest = internal_malloc_size (*len);\n-\n-      /* Copy string if necessary.  */\n-      memmove (*dest, src, *len);\n-    }\n-}\n-\n-\n-/* The length of a string not including trailing blanks.  */\n-\n-GFC_INTEGER_4\n-string_len_trim (GFC_INTEGER_4 len, const char * s)\n-{\n-  int i;\n-\n-  for (i = len - 1; i >= 0; i--)\n-    {\n-      if (s[i] != ' ')\n-        break;\n-    }\n-  return i + 1;\n-}\n-\n-\n-/* Find a substring within a string.  */\n-\n-GFC_INTEGER_4\n-string_index (GFC_INTEGER_4 slen, const char * str, GFC_INTEGER_4 sslen,\n-\t      const char * sstr, GFC_LOGICAL_4 back)\n-{\n-  int start;\n-  int last;\n-  int i;\n-  int delta;\n-\n-  if (sslen == 0)\n-    return 1;\n-\n-  if (sslen > slen)\n-    return 0;\n-\n-  if (!back)\n-    {\n-      last = slen + 1 - sslen;\n-      start = 0;\n-      delta = 1;\n-    }\n-  else\n-    {\n-      last = -1;\n-      start = slen - sslen;\n-      delta = -1;\n-    }\n-  i = 0;\n-  for (; start != last; start+= delta)\n-    {\n-      for (i = 0; i < sslen; i++)\n-        {\n-          if (str[start + i] != sstr[i])\n-            break;\n-        }\n-      if (i == sslen)\n-        return (start + 1);\n-    }\n-  return 0;\n-}\n-\n-\n-/* Remove leading blanks from a string, padding at end.  The src and dest\n-   should not overlap.  */\n-\n-void\n-adjustl (char *dest, GFC_INTEGER_4 len, const char *src)\n-{\n-  int i;\n-\n-  i = 0;\n-  while (i<len && src[i] == ' ')\n-    i++;\n-\n-  if (i < len)\n-    memcpy (dest, &src[i], len - i);\n-  if (i > 0)\n-    memset (&dest[len - i], ' ', i);\n-}\n-\n-\n-/* Remove trailing blanks from a string.  */\n-\n-void\n-adjustr (char *dest, GFC_INTEGER_4 len, const char *src)\n-{\n-  int i;\n-\n-  i = len;\n-  while (i > 0 && src[i - 1] == ' ')\n-    i--;\n-\n-  if (i < len)\n-    memset (dest, ' ', len - i);\n-  memcpy (dest + (len - i), src, i );\n-}\n-\n-\n-/* Scan a string for any one of the characters in a set of characters.  */\n-\n-GFC_INTEGER_4\n-string_scan (GFC_INTEGER_4 slen, const char * str, GFC_INTEGER_4 setlen,\n-             const char * set, GFC_LOGICAL_4 back)\n-{\n-  int i, j;\n-\n-  if (slen == 0 || setlen == 0)\n-    return 0;\n-\n-  if (back)\n-    {\n-      for (i = slen - 1; i >= 0; i--)\n-\t{\n-\t  for (j = 0; j < setlen; j++)\n-\t    {\n-\t      if (str[i] == set[j])\n-\t\treturn (i + 1);\n-\t    }\n-\t}\n-    }\n-  else\n-    {\n-      for (i = 0; i < slen; i++)\n-\t{\n-\t  for (j = 0; j < setlen; j++)\n-\t    {\n-\t      if (str[i] == set[j])\n-\t\treturn (i + 1);\n-\t    }\n-\t}\n-    }\n-\n-  return 0;\n-}\n-\n-\n-/* Verify that a set of characters contains all the characters in a\n-   string by identifying the position of the first character in a\n-   characters that does not appear in a given set of characters.  */\n-\n-GFC_INTEGER_4\n-string_verify (GFC_INTEGER_4 slen, const char * str, GFC_INTEGER_4 setlen,\n-               const char * set, GFC_LOGICAL_4 back)\n+static gfc_char4_t *\n+memset_char4 (gfc_char4_t *b, gfc_char4_t c, size_t len)\n {\n-  int start;\n-  int last;\n-  int i;\n-  int delta;\n-\n-  if (slen == 0)\n-    return 0;\n+  size_t i;\n \n-  if (back)\n-    {\n-      last = -1;\n-      start = slen - 1;\n-      delta = -1;\n-    }\n-  else\n-    {\n-      last = slen;\n-      start = 0;\n-      delta = 1;\n-    }\n-  for (; start != last; start += delta)\n-    {\n-      for (i = 0; i < setlen; i++)\n-        {\n-          if (str[start] == set[i])\n-            break;\n-        }\n-      if (i == setlen)\n-        return (start + 1);\n-    }\n+  for (i = 0; i < len; i++)\n+    b[i] = c;\n \n-  return 0;\n+  return b;\n }\n \n \n-/* MIN and MAX intrinsics for strings.  The front-end makes sure that\n-   nargs is at least 2.  */\n+/* All other functions are defined using a few generic macros in\n+   string_intrinsics_inc.c, so we avoid code duplication between the\n+   various character type kinds.  */\n \n-void\n-string_minmax (GFC_INTEGER_4 *rlen, void **dest, int op, int nargs, ...)\n-{\n-  va_list ap;\n-  int i;\n-  char * next, * res;\n-  GFC_INTEGER_4 nextlen, reslen;\n-\n-  va_start (ap, nargs);\n-  reslen = va_arg (ap, GFC_INTEGER_4);\n-  res = va_arg (ap, char *);\n-  *rlen = reslen;\n-\n-  if (res == NULL)\n-    runtime_error (\"First argument of '%s' intrinsic should be present\",\n-\t\t   op > 0 ? \"MAX\" : \"MIN\");\n+#undef  CHARTYPE\n+#define CHARTYPE char\n+#undef  UCHARTYPE\n+#define UCHARTYPE unsigned char\n+#undef  SUFFIX\n+#define SUFFIX(x) x\n+#undef  MEMSET\n+#define MEMSET memset\n \n-  for (i = 1; i < nargs; i++)\n-    {\n-      nextlen = va_arg (ap, GFC_INTEGER_4);\n-      next = va_arg (ap, char *);\n+#include \"string_intrinsics_inc.c\"\n \n \n-      if (next == NULL)\n-\t{\n-\t  if (i == 1)\n-\t    runtime_error (\"Second argument of '%s' intrinsic should be \"\n-\t\t\t   \"present\", op > 0 ? \"MAX\" : \"MIN\");\n-\t  else\n-\t    continue;\n-\t}\n+#undef  CHARTYPE\n+#define CHARTYPE gfc_char4_t\n+#undef  UCHARTYPE\n+#define UCHARTYPE gfc_char4_t\n+#undef  SUFFIX\n+#define SUFFIX(x) x ## _char4\n+#undef  MEMSET\n+#define MEMSET memset_char4\n \n-      if (nextlen > *rlen)\n-\t*rlen = nextlen;\n+#include \"string_intrinsics_inc.c\"\n \n-      if (op * compare_string (reslen, res, nextlen, next) < 0)\n-\t{\n-\t  reslen = nextlen;\n-\t  res = next;\n-\t}\n-    }\n-  va_end (ap);\n-\n-  if (*rlen == 0)\n-    *dest = &zero_length_string;\n-  else\n-    {\n-      char * tmp = internal_malloc_size (*rlen);\n-      memcpy (tmp, res, reslen);\n-      memset (&tmp[reslen], ' ', *rlen - reslen);\n-      *dest = tmp;\n-    }\n-}"}, {"sha": "87e137e8e6cf6c77dd7ac155d990fc0f09072878", "filename": "libgfortran/intrinsics/string_intrinsics_inc.c", "status": "added", "additions": 418, "deletions": 0, "changes": 418, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b267817ff0af3f2d5ec219e57a5db5ddb345543/libgfortran%2Fintrinsics%2Fstring_intrinsics_inc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b267817ff0af3f2d5ec219e57a5db5ddb345543/libgfortran%2Fintrinsics%2Fstring_intrinsics_inc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fstring_intrinsics_inc.c?ref=4b267817ff0af3f2d5ec219e57a5db5ddb345543", "patch": "@@ -0,0 +1,418 @@\n+/* String intrinsics helper functions.\n+   Copyright 2002, 2005, 2007, 2008 Free Software Foundation, Inc.\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+\n+/* Rename the functions.  */\n+#define concat_string SUFFIX(concat_string)\n+#define string_len_trim SUFFIX(string_len_trim)\n+#define adjustl SUFFIX(adjustl)\n+#define adjustr SUFFIX(adjustr)\n+#define string_index SUFFIX(string_index)\n+#define string_scan SUFFIX(string_scan)\n+#define string_verify SUFFIX(string_verify)\n+#define string_trim SUFFIX(string_trim)\n+#define string_minmax SUFFIX(string_minmax)\n+#define zero_length_string SUFFIX(zero_length_string)\n+#define compare_string SUFFIX(compare_string)\n+\n+\n+/* The prototypes.  */\n+\n+extern void concat_string (gfc_charlen_type, CHARTYPE *,\n+\t\t\t   gfc_charlen_type, const CHARTYPE *,\n+\t\t\t   gfc_charlen_type, const CHARTYPE *);\n+export_proto(concat_string);\n+\n+extern gfc_charlen_type string_len_trim (gfc_charlen_type, const CHARTYPE *);\n+export_proto(string_len_trim);\n+\n+extern void adjustl (CHARTYPE *, gfc_charlen_type, const CHARTYPE *);\n+export_proto(adjustl);\n+\n+extern void adjustr (CHARTYPE *, gfc_charlen_type, const CHARTYPE *);\n+export_proto(adjustr);\n+\n+extern gfc_charlen_type string_index (gfc_charlen_type, const CHARTYPE *,\n+\t\t\t\t      gfc_charlen_type, const CHARTYPE *,\n+\t\t\t\t      GFC_LOGICAL_4);\n+export_proto(string_index);\n+\n+extern gfc_charlen_type string_scan (gfc_charlen_type, const CHARTYPE *,\n+\t\t\t\t     gfc_charlen_type, const CHARTYPE *,\n+\t\t\t\t     GFC_LOGICAL_4);\n+export_proto(string_scan);\n+\n+extern gfc_charlen_type string_verify (gfc_charlen_type, const CHARTYPE *,\n+\t\t\t\t       gfc_charlen_type, const CHARTYPE *,\n+\t\t\t\t       GFC_LOGICAL_4);\n+export_proto(string_verify);\n+\n+extern void string_trim (gfc_charlen_type *, CHARTYPE **, gfc_charlen_type,\n+\t\t\t const CHARTYPE *);\n+export_proto(string_trim);\n+\n+extern void string_minmax (gfc_charlen_type *, CHARTYPE **, int, int, ...);\n+export_proto(string_minmax);\n+\n+\n+/* Use for functions which can return a zero-length string.  */\n+static CHARTYPE zero_length_string = 0;\n+\n+\n+/* Strings of unequal length are extended with pad characters.  */\n+\n+int\n+compare_string (gfc_charlen_type len1, const CHARTYPE *s1,\n+\t\tgfc_charlen_type len2, const CHARTYPE *s2)\n+{\n+  const UCHARTYPE *s;\n+  gfc_charlen_type len;\n+  int res;\n+\n+  res = memcmp (s1, s2, ((len1 < len2) ? len1 : len2) * sizeof (CHARTYPE));\n+  if (res != 0)\n+    return res;\n+\n+  if (len1 == len2)\n+    return 0;\n+\n+  if (len1 < len2)\n+    {\n+      len = len2 - len1;\n+      s = (UCHARTYPE *) &s2[len1];\n+      res = -1;\n+    }\n+  else\n+    {\n+      len = len1 - len2;\n+      s = (UCHARTYPE *) &s1[len2];\n+      res = 1;\n+    }\n+\n+  while (len--)\n+    {\n+      if (*s != ' ')\n+        {\n+          if (*s > ' ')\n+            return res;\n+          else\n+            return -res;\n+        }\n+      s++;\n+    }\n+\n+  return 0;\n+}\n+iexport(compare_string);\n+\n+\n+/* The destination and source should not overlap.  */\n+\n+void\n+concat_string (gfc_charlen_type destlen, CHARTYPE * dest,\n+\t       gfc_charlen_type len1, const CHARTYPE * s1,\n+\t       gfc_charlen_type len2, const CHARTYPE * s2)\n+{\n+  if (len1 >= destlen)\n+    {\n+      memcpy (dest, s1, destlen * sizeof (CHARTYPE));\n+      return;\n+    }\n+  memcpy (dest, s1, len1 * sizeof (CHARTYPE));\n+  dest += len1;\n+  destlen -= len1;\n+\n+  if (len2 >= destlen)\n+    {\n+      memcpy (dest, s2, destlen * sizeof (CHARTYPE));\n+      return;\n+    }\n+\n+  memcpy (dest, s2, len2 * sizeof (CHARTYPE));\n+  MEMSET (&dest[len2], ' ', destlen - len2);\n+}\n+\n+\n+/* Return string with all trailing blanks removed.  */\n+\n+void\n+string_trim (gfc_charlen_type *len, CHARTYPE **dest, gfc_charlen_type slen,\n+\t     const CHARTYPE *src)\n+{\n+  gfc_charlen_type i;\n+\n+  /* Determine length of result string.  */\n+  for (i = slen - 1; i >= 0; i--)\n+    {\n+      if (src[i] != ' ')\n+        break;\n+    }\n+  *len = i + 1;\n+\n+  if (*len == 0)\n+    *dest = &zero_length_string;\n+  else\n+    {\n+      /* Allocate space for result string.  */\n+      *dest = internal_malloc_size (*len * sizeof (CHARTYPE));\n+\n+      /* Copy string if necessary.  */\n+      memcpy (*dest, src, *len * sizeof (CHARTYPE));\n+    }\n+}\n+\n+\n+/* The length of a string not including trailing blanks.  */\n+\n+gfc_charlen_type\n+string_len_trim (gfc_charlen_type len, const CHARTYPE *s)\n+{\n+  gfc_charlen_type i;\n+\n+  for (i = len - 1; i >= 0; i--)\n+    {\n+      if (s[i] != ' ')\n+        break;\n+    }\n+  return i + 1;\n+}\n+\n+\n+/* Find a substring within a string.  */\n+\n+gfc_charlen_type\n+string_index (gfc_charlen_type slen, const CHARTYPE *str,\n+\t      gfc_charlen_type sslen, const CHARTYPE *sstr,\n+\t      GFC_LOGICAL_4 back)\n+{\n+  gfc_charlen_type start, last, delta, i;\n+\n+  if (sslen == 0)\n+    return 1;\n+\n+  if (sslen > slen)\n+    return 0;\n+\n+  if (!back)\n+    {\n+      last = slen + 1 - sslen;\n+      start = 0;\n+      delta = 1;\n+    }\n+  else\n+    {\n+      last = -1;\n+      start = slen - sslen;\n+      delta = -1;\n+    }\n+\n+  for (; start != last; start+= delta)\n+    {\n+      for (i = 0; i < sslen; i++)\n+        {\n+          if (str[start + i] != sstr[i])\n+            break;\n+        }\n+      if (i == sslen)\n+        return (start + 1);\n+    }\n+  return 0;\n+}\n+\n+\n+/* Remove leading blanks from a string, padding at end.  The src and dest\n+   should not overlap.  */\n+\n+void\n+adjustl (CHARTYPE *dest, gfc_charlen_type len, const CHARTYPE *src)\n+{\n+  gfc_charlen_type i;\n+\n+  i = 0;\n+  while (i < len && src[i] == ' ')\n+    i++;\n+\n+  if (i < len)\n+    memcpy (dest, &src[i], (len - i) * sizeof (CHARTYPE));\n+  if (i > 0)\n+    MEMSET (&dest[len - i], ' ', i);\n+}\n+\n+\n+/* Remove trailing blanks from a string.  */\n+\n+void\n+adjustr (CHARTYPE *dest, gfc_charlen_type len, const CHARTYPE *src)\n+{\n+  gfc_charlen_type i;\n+\n+  i = len;\n+  while (i > 0 && src[i - 1] == ' ')\n+    i--;\n+\n+  if (i < len)\n+    MEMSET (dest, ' ', len - i);\n+  memcpy (&dest[len - i], src, i * sizeof (CHARTYPE));\n+}\n+\n+\n+/* Scan a string for any one of the characters in a set of characters.  */\n+\n+gfc_charlen_type\n+string_scan (gfc_charlen_type slen, const CHARTYPE *str,\n+\t     gfc_charlen_type setlen, const CHARTYPE *set, GFC_LOGICAL_4 back)\n+{\n+  gfc_charlen_type i, j;\n+\n+  if (slen == 0 || setlen == 0)\n+    return 0;\n+\n+  if (back)\n+    {\n+      for (i = slen - 1; i >= 0; i--)\n+\t{\n+\t  for (j = 0; j < setlen; j++)\n+\t    {\n+\t      if (str[i] == set[j])\n+\t\treturn (i + 1);\n+\t    }\n+\t}\n+    }\n+  else\n+    {\n+      for (i = 0; i < slen; i++)\n+\t{\n+\t  for (j = 0; j < setlen; j++)\n+\t    {\n+\t      if (str[i] == set[j])\n+\t\treturn (i + 1);\n+\t    }\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\n+\n+/* Verify that a set of characters contains all the characters in a\n+   string by identifying the position of the first character in a\n+   characters that does not appear in a given set of characters.  */\n+\n+gfc_charlen_type\n+string_verify (gfc_charlen_type slen, const CHARTYPE *str,\n+\t       gfc_charlen_type setlen, const CHARTYPE *set,\n+\t       GFC_LOGICAL_4 back)\n+{\n+  gfc_charlen_type start, last, delta, i;\n+\n+  if (slen == 0)\n+    return 0;\n+\n+  if (back)\n+    {\n+      last = -1;\n+      start = slen - 1;\n+      delta = -1;\n+    }\n+  else\n+    {\n+      last = slen;\n+      start = 0;\n+      delta = 1;\n+    }\n+  for (; start != last; start += delta)\n+    {\n+      for (i = 0; i < setlen; i++)\n+        {\n+          if (str[start] == set[i])\n+            break;\n+        }\n+      if (i == setlen)\n+        return (start + 1);\n+    }\n+\n+  return 0;\n+}\n+\n+\n+/* MIN and MAX intrinsics for strings.  The front-end makes sure that\n+   nargs is at least 2.  */\n+\n+void\n+string_minmax (gfc_charlen_type *rlen, CHARTYPE **dest, int op, int nargs, ...)\n+{\n+  va_list ap;\n+  int i;\n+  CHARTYPE *next, *res;\n+  gfc_charlen_type nextlen, reslen;\n+\n+  va_start (ap, nargs);\n+  reslen = va_arg (ap, gfc_charlen_type);\n+  res = va_arg (ap, CHARTYPE *);\n+  *rlen = reslen;\n+\n+  if (res == NULL)\n+    runtime_error (\"First argument of '%s' intrinsic should be present\",\n+\t\t   op > 0 ? \"MAX\" : \"MIN\");\n+\n+  for (i = 1; i < nargs; i++)\n+    {\n+      nextlen = va_arg (ap, gfc_charlen_type);\n+      next = va_arg (ap, CHARTYPE *);\n+\n+      if (next == NULL)\n+\t{\n+\t  if (i == 1)\n+\t    runtime_error (\"Second argument of '%s' intrinsic should be \"\n+\t\t\t   \"present\", op > 0 ? \"MAX\" : \"MIN\");\n+\t  else\n+\t    continue;\n+\t}\n+\n+      if (nextlen > *rlen)\n+\t*rlen = nextlen;\n+\n+      if (op * compare_string (reslen, res, nextlen, next) < 0)\n+\t{\n+\t  reslen = nextlen;\n+\t  res = next;\n+\t}\n+    }\n+  va_end (ap);\n+\n+  if (*rlen == 0)\n+    *dest = &zero_length_string;\n+  else\n+    {\n+      CHARTYPE *tmp = internal_malloc_size (*rlen * sizeof (CHARTYPE));\n+      memcpy (tmp, res, reslen * sizeof (CHARTYPE));\n+      MEMSET (&tmp[reslen], ' ', *rlen - reslen);\n+      *dest = tmp;\n+    }\n+}"}, {"sha": "6ff9f4fd072fbdf636c35d4275f92d7f80aebd5f", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b267817ff0af3f2d5ec219e57a5db5ddb345543/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b267817ff0af3f2d5ec219e57a5db5ddb345543/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=4b267817ff0af3f2d5ec219e57a5db5ddb345543", "patch": "@@ -259,9 +259,20 @@ typedef GFC_INTEGER_4 GFC_IO_INT;\n    by the compiler.  */\n /* The type used of array indices, amongst other things.  */\n typedef ssize_t index_type;\n+\n /* The type used for the lengths of character variables.  */\n typedef GFC_INTEGER_4 gfc_charlen_type;\n \n+/* Definitions of CHARACTER data types:\n+     - CHARACTER(KIND=1) corresponds to the C char type,\n+     - CHARACTER(KIND=4) corresponds to an unsigned 32-bit integer.  */\n+typedef GFC_UINTEGER_4 gfc_char4_t;\n+\n+/* Byte size of character kinds.  For the kinds currently supported, it's\n+   simply equal to the kind parameter itself.  */\n+#define GFC_SIZE_OF_CHAR_KIND(kind) (kind)\n+\n+\n /* This will be 0 on little-endian machines and one on big-endian machines.  */\n extern int l8_to_l4_offset;\n internal_proto(l8_to_l4_offset);\n@@ -1172,10 +1183,14 @@ internal_proto(spread_scalar_c16);\n \n /* string_intrinsics.c */\n \n-extern int compare_string (GFC_INTEGER_4, const char *,\n-\t\t\t   GFC_INTEGER_4, const char *);\n+extern int compare_string (gfc_charlen_type, const char *,\n+\t\t\t   gfc_charlen_type, const char *);\n iexport_proto(compare_string);\n \n+extern int compare_string_char4 (gfc_charlen_type, const gfc_char4_t *,\n+\t\t\t\t gfc_charlen_type, const gfc_char4_t *);\n+iexport_proto(compare_string_char4);\n+\n /* random.c */\n \n extern void random_seed_i4 (GFC_INTEGER_4 * size, gfc_array_i4 * put,"}]}