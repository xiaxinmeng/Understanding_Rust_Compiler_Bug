{"sha": "0022d9e31d01f2a31808ff38f66dd3e3ac96927a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDAyMmQ5ZTMxZDAxZjJhMzE4MDhmZjM4ZjY2ZGQzZTNhYzk2OTI3YQ==", "commit": {"author": {"name": "Pascal Obry", "email": "obry@adacore.com", "date": "2006-02-15T09:30:39Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-02-15T09:30:39Z"}, "message": "adaint.h, adaint.c (DIR_SEPARATOR): Use _T() macro for Unicode support.\n\n2006-02-13  Pascal Obry  <obry@adacore.com>\n\t    Nicolas Roche  <roche@adacore.com>\n\t    Arnaud Charlet  <charlet@adacore.com>\n\n\t* adaint.h, adaint.c (DIR_SEPARATOR): Use _T() macro for Unicode\n\tsupport.\n\t(__gnat_try_lock): Add unicode support by using a specific section on\n\tWindows.\n\t(__gnat_get_current_dir): Idem.\n\t(__gnat_open_read): Idem.\n\t(__gnat_open_rw): Idem.\n\t(__gnat_open_create): Idem.\n\t(__gnat_create_output_file): Idem.\n\t(__gnat_open_append): Idem.\n\t(__gnat_open_new): Idem.\n\t(__gnat_file_time_name): Idem.\n\t(__gnat_set_file_time_name): Idem.\n\t(__gnat_stat): Idem.\n\t(win32_no_block_spawn): Idem.\n\t(__gnat_locate_exec_on_path): Idem.\n\t(__gnat_opendir): New routine.\n\t(__gnat_closedir): Idem.\n\t(__gnat_readdir): Add new parameter length (pointer to int). Update\n\timplementation to use it and add specific Win32 code for Unicode\n\tsupport.\n\t(__gnat_get_env_value_ptr): Remove. Replaced by __gnat_getenv in env.c\n\t(__gnat_set_env_value): Remove. Replaced by __gnat_setenv in env.c\n\t(convert_addresses): Do not define this dummy routine on VMS.\n\n\t* mingw32.h (GNAT_UNICODE_SUPPORT): New definition, if set the GNAT\n\truntime Unicode support will be activated.\n\t(S2WS): String to Wide-String conversion. This version just copy a\n\tstring in non Unicode version.\n\t(WS2S): Wide-String to String conversion. This version just copy a\n\tstring in non Unicode version.\n\n\t* g-dirope.adb: (Close): Now import __gnat_closedir from adaint.c.\n\t(Open): Now import __gnat_opendir from adaint.c.\n\t(Read): Change the implementation to support unicode characters. It is\n\tnot possible to use strlen() on Windows as this version supports only\n\tstandard ASCII characters. So the length of the directory entry is now\n\treturned from the imported __gnat_readdir routine.\n\tUpdate copyright notice.\n\n\t* s-crtl-vms64.ads, s-crtl.ads: (closedir): Moved to adaint.c.\n\t(opendir): Moved to adaint.c.\n\n\t* g-os_lib.adb (Copy_Time_Stamp): Fix off-by-one range computation.\n\t(Get_Directory): Fix wrong indexing.\n\t(Getenv): replace __gnat_get_env_value_ptr from adaint.c by\n\t__gnat_getenv from env.c\n\t(Setenv): replace __gnat_set_env_value from adaint.c by __gnat_setenv\n\tfrom env.c\n\n\t* env.h, env.c: New file.\n\n\t* s-scaval.adb (Initialize): Replace __gnat_get_env_value_ptr from\n\tadaint.c by __gnat_getenv from env.c\n\n\t* s-shasto.adb (Initialize): replace __gnat_get_env_value_ptr from\n\tadaint.c by __gnat_getenv from env.c\n\n\t* Make-lang.in: Add env.o in the list of C object needed by gnat1\n\tand gnatbind.\n\tUpdate dependencies.\n\nFrom-SVN: r111029", "tree": {"sha": "ff53725d708aacac9be1a454735ad7f7bd86d8f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff53725d708aacac9be1a454735ad7f7bd86d8f1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0022d9e31d01f2a31808ff38f66dd3e3ac96927a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0022d9e31d01f2a31808ff38f66dd3e3ac96927a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0022d9e31d01f2a31808ff38f66dd3e3ac96927a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0022d9e31d01f2a31808ff38f66dd3e3ac96927a/comments", "author": {"login": "TurboGit", "id": 467069, "node_id": "MDQ6VXNlcjQ2NzA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/467069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TurboGit", "html_url": "https://github.com/TurboGit", "followers_url": "https://api.github.com/users/TurboGit/followers", "following_url": "https://api.github.com/users/TurboGit/following{/other_user}", "gists_url": "https://api.github.com/users/TurboGit/gists{/gist_id}", "starred_url": "https://api.github.com/users/TurboGit/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TurboGit/subscriptions", "organizations_url": "https://api.github.com/users/TurboGit/orgs", "repos_url": "https://api.github.com/users/TurboGit/repos", "events_url": "https://api.github.com/users/TurboGit/events{/privacy}", "received_events_url": "https://api.github.com/users/TurboGit/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4f37ea7d5f6ff5a77db8895034a682ff996b8bed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f37ea7d5f6ff5a77db8895034a682ff996b8bed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f37ea7d5f6ff5a77db8895034a682ff996b8bed"}], "stats": {"total": 4410, "additions": 1943, "deletions": 2467}, "files": [{"sha": "44729ce776b5de3ba89f8513cf26be38d8900364", "filename": "gcc/ada/Make-lang.in", "status": "modified", "additions": 1368, "deletions": 2261, "changes": 3629, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0022d9e31d01f2a31808ff38f66dd3e3ac96927a/gcc%2Fada%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0022d9e31d01f2a31808ff38f66dd3e3ac96927a/gcc%2Fada%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMake-lang.in?ref=0022d9e31d01f2a31808ff38f66dd3e3ac96927a"}, {"sha": "674df69bb7bda95f3079a14ae59ac9e952a71b8a", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 184, "deletions": 158, "changes": 342, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0022d9e31d01f2a31808ff38f66dd3e3ac96927a/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0022d9e31d01f2a31808ff38f66dd3e3ac96927a/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=0022d9e31d01f2a31808ff38f66dd3e3ac96927a", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *          Copyright (C) 1992-2005, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2006, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -411,11 +411,24 @@ __gnat_symlink (char *oldpath ATTRIBUTE_UNUSED,\n int\n __gnat_try_lock (char *dir, char *file)\n {\n-  char full_path[256];\n   int fd;\n+#ifdef __MINGW32__\n+  TCHAR wfull_path[GNAT_MAX_PATH_LEN];\n+  TCHAR wfile[GNAT_MAX_PATH_LEN];\n+  TCHAR wdir[GNAT_MAX_PATH_LEN];\n+\n+  S2WS (wdir, dir, GNAT_MAX_PATH_LEN);\n+  S2WS (wfile, file, GNAT_MAX_PATH_LEN);\n+\n+  _stprintf (wfull_path, _T(\"%s%c%s\"), wdir, _T(DIR_SEPARATOR), wfile);\n+  fd = _topen (wfull_path, O_CREAT | O_EXCL, 0600);\n+#else\n+  char full_path[256];\n \n   sprintf (full_path, \"%s%c%s\", dir, DIR_SEPARATOR, file);\n   fd = open (full_path, O_CREAT | O_EXCL, 0600);\n+#endif\n+\n   if (fd < 0)\n     return 0;\n \n@@ -436,6 +449,7 @@ __gnat_try_lock (char *dir, char *file)\n \n   sprintf (full_path, \"%s%c%s\", dir, DIR_SEPARATOR, file);\n   fd = open (full_path, O_CREAT | O_EXCL, 0600);\n+\n   if (fd < 0)\n     return 0;\n \n@@ -522,7 +536,14 @@ __gnat_get_default_identifier_character_set (void)\n void\n __gnat_get_current_dir (char *dir, int *length)\n {\n-#ifdef VMS\n+#if defined (__MINGW32__)\n+  TCHAR wdir[GNAT_MAX_PATH_LEN];\n+\n+  _tgetcwd (wdir, *length);\n+\n+  WS2S (dir, wdir, GNAT_MAX_PATH_LEN);\n+\n+#elif defined (VMS)\n    /* Force Unix style, which is what GNAT uses internally.  */\n    getcwd (dir, *length, 0);\n #else\n@@ -604,6 +625,13 @@ __gnat_open_read (char *path, int fmode)\n              \"mbc=16\", \"deq=64\", \"fop=tef\");\n #elif defined (__vxworks)\n   fd = open (path, O_RDONLY | o_fmode, 0444);\n+#elif defined (__MINGW32__)\n+ {\n+   TCHAR wpath[GNAT_MAX_PATH_LEN];\n+\n+   S2WS (wpath, path, GNAT_MAX_PATH_LEN);\n+   fd = _topen (wpath, O_RDONLY | o_fmode, 0444);\n+ }\n #else\n   fd = open (path, O_RDONLY | o_fmode);\n #endif\n@@ -638,6 +666,13 @@ __gnat_open_rw (char *path, int fmode)\n #if defined (VMS)\n   fd = open (path, O_RDWR | o_fmode, PERM,\n              \"mbc=16\", \"deq=64\", \"fop=tef\");\n+#elif defined (__MINGW32__)\n+  {\n+    TCHAR wpath[GNAT_MAX_PATH_LEN];\n+\n+    S2WS (wpath, path, GNAT_MAX_PATH_LEN);\n+    fd = _topen (wpath, O_RDWR | o_fmode, PERM);\n+  }\n #else\n   fd = open (path, O_RDWR | o_fmode, PERM);\n #endif\n@@ -657,6 +692,13 @@ __gnat_open_create (char *path, int fmode)\n #if defined (VMS)\n   fd = open (path, O_WRONLY | O_CREAT | O_TRUNC | o_fmode, PERM,\n              \"mbc=16\", \"deq=64\", \"fop=tef\");\n+#elif defined (__MINGW32__)\n+  {\n+    TCHAR wpath[GNAT_MAX_PATH_LEN];\n+\n+    S2WS (wpath, path, GNAT_MAX_PATH_LEN);\n+    fd = _topen (wpath, O_WRONLY | O_CREAT | O_TRUNC | o_fmode, PERM);\n+  }\n #else\n   fd = open (path, O_WRONLY | O_CREAT | O_TRUNC | o_fmode, PERM);\n #endif\n@@ -672,6 +714,13 @@ __gnat_create_output_file (char *path)\n   fd = open (path, O_WRONLY | O_CREAT | O_TRUNC | O_TEXT, PERM,\n              \"rfm=stmlf\", \"ctx=rec\", \"rat=none\", \"rop=nlk\",\n              \"shr=del,get,put,upd\");\n+#elif defined (__MINGW32__)\n+  {\n+    TCHAR wpath[GNAT_MAX_PATH_LEN];\n+\n+    S2WS (wpath, path, GNAT_MAX_PATH_LEN);\n+    fd = _topen (wpath, O_WRONLY | O_CREAT | O_TRUNC | O_TEXT, PERM);\n+  }\n #else\n   fd = open (path, O_WRONLY | O_CREAT | O_TRUNC | O_TEXT, PERM);\n #endif\n@@ -691,6 +740,13 @@ __gnat_open_append (char *path, int fmode)\n #if defined (VMS)\n   fd = open (path, O_WRONLY | O_CREAT | O_APPEND | o_fmode, PERM,\n              \"mbc=16\", \"deq=64\", \"fop=tef\");\n+#elif defined (__MINGW32__)\n+  {\n+    TCHAR wpath[GNAT_MAX_PATH_LEN];\n+\n+    S2WS (wpath, path, GNAT_MAX_PATH_LEN);\n+    fd = _topen (wpath, O_WRONLY | O_CREAT | O_APPEND | o_fmode, PERM);\n+  }\n #else\n   fd = open (path, O_WRONLY | O_CREAT | O_APPEND | o_fmode, PERM);\n #endif\n@@ -712,6 +768,13 @@ __gnat_open_new (char *path, int fmode)\n #if defined (VMS)\n   fd = open (path, O_WRONLY | O_CREAT | O_EXCL | o_fmode, PERM,\n              \"mbc=16\", \"deq=64\", \"fop=tef\");\n+#elif defined (__MINGW32__)\n+  {\n+    TCHAR wpath[GNAT_MAX_PATH_LEN];\n+\n+    S2WS (wpath, path, GNAT_MAX_PATH_LEN);\n+    fd = _topen (wpath, O_WRONLY | O_CREAT | O_EXCL | o_fmode, PERM);\n+  }\n #else\n   fd = open (path, O_WRONLY | O_CREAT | O_EXCL | o_fmode, PERM);\n #endif\n@@ -838,15 +901,44 @@ __gnat_tmp_name (char *tmp_filename)\n #endif\n }\n \n+/*  Open directory and returns a DIR pointer.  */\n+\n+DIR* __gnat_opendir (char *name)\n+{\n+#ifdef __MINGW32__\n+  TCHAR wname[GNAT_MAX_PATH_LEN];\n+\n+  S2WS (wname, name, GNAT_MAX_PATH_LEN);\n+  return (DIR*)_topendir (wname);\n+\n+#else\n+  return opendir (name);\n+#endif\n+}\n+\n /* Read the next entry in a directory.  The returned string points somewhere\n    in the buffer.  */\n \n char *\n-__gnat_readdir (DIR *dirp, char *buffer)\n+__gnat_readdir (DIR *dirp, char *buffer, int *len)\n {\n+#if defined (__MINGW32__)\n+  struct _tdirent *dirent = _treaddir ((_TDIR*)dirp);\n+\n+  if (dirent != NULL)\n+    {\n+      WS2S (buffer, dirent->d_name, GNAT_MAX_PATH_LEN);\n+      *len = strlen (buffer);\n+\n+      return buffer;\n+    }\n+  else\n+    return NULL;\n+\n+#elif defined (HAVE_READDIR_R)\n   /* If possible, try to use the thread-safe version.  */\n-#ifdef HAVE_READDIR_R\n   if (readdir_r (dirp, buffer) != NULL)\n+    *len = strlen (((struct dirent*) buffer)->d_name);\n     return ((struct dirent*) buffer)->d_name;\n   else\n     return NULL;\n@@ -857,6 +949,7 @@ __gnat_readdir (DIR *dirp, char *buffer)\n   if (dirent != NULL)\n     {\n       strcpy (buffer, dirent->d_name);\n+      *len = strlen (buffer);\n       return buffer;\n     }\n   else\n@@ -865,6 +958,18 @@ __gnat_readdir (DIR *dirp, char *buffer)\n #endif\n }\n \n+/* Close a directory entry.  */\n+\n+int __gnat_closedir (DIR *dirp)\n+{\n+#ifdef __MINGW32__\n+  return _tclosedir ((_TDIR*)dirp);\n+\n+#else\n+  return closedir (dirp);\n+#endif\n+}\n+\n /* Returns 1 if readdir is thread safe, 0 otherwise.  */\n \n int\n@@ -900,8 +1005,7 @@ win32_filetime (HANDLE h)\n      since <Jan 1st 1970>.  */\n \n   if (GetFileTime (h, NULL, NULL, &t_write.ft_time))\n-    return (time_t) (t_write.ull_time / 10000000ULL\n-\t\t     - w32_epoch_offset);\n+    return (time_t) (t_write.ull_time / 10000000ULL - w32_epoch_offset);\n   return (time_t) 0;\n }\n #endif\n@@ -920,8 +1024,13 @@ __gnat_file_time_name (char *name)\n \n #elif defined (_WIN32)\n   time_t ret = 0;\n-  HANDLE h = CreateFile (name, GENERIC_READ, FILE_SHARE_READ, 0,\n-\t\t\t OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, 0);\n+  TCHAR wname[GNAT_MAX_PATH_LEN];\n+\n+  S2WS (wname, name, GNAT_MAX_PATH_LEN);\n+\n+  HANDLE h = CreateFile\n+    (wname, GENERIC_READ, FILE_SHARE_READ, 0,\n+     OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, 0);\n \n   if (h != INVALID_HANDLE_VALUE)\n     {\n@@ -1052,10 +1161,14 @@ __gnat_set_file_time_name (char *name, time_t time_stamp)\n     FILETIME ft_time;\n     unsigned long long ull_time;\n   } t_write;\n+  TCHAR wname[GNAT_MAX_PATH_LEN];\n \n-  HANDLE h  = CreateFile (name, GENERIC_WRITE, FILE_SHARE_WRITE, NULL,\n-\t\t\t  OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS,\n-\t\t\t  NULL);\n+  S2WS (wname, name, GNAT_MAX_PATH_LEN);\n+\n+  HANDLE h  = CreateFile\n+    (wname, GENERIC_WRITE, FILE_SHARE_WRITE, NULL,\n+     OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS,\n+     NULL);\n   if (h == INVALID_HANDLE_VALUE)\n     return;\n   /* Add number of seconds between <Jan 1st 1601> and <Jan 1st 1970> */\n@@ -1122,7 +1235,13 @@ __gnat_set_file_time_name (char *name, time_t time_stamp)\n   struct dsc$descriptor_s resultdsc\n     = {NAM$C_MAXRSS, DSC$K_DTYPE_VT, DSC$K_CLASS_VS, (void *) result.string};\n \n-  tryfile = (char *) __gnat_to_host_dir_spec (name, 0);\n+  /* Convert parameter name (a file spec) to host file form. Note that this\n+     is needed on VMS to prepare for subsequent calls to VMS RMS library\n+     routines. Note that it would not work to call __gnat_to_host_dir_spec\n+     as was done in a previous version, since this fails silently unless\n+     the feature logical DECC$EFS_CHARSET is enabled, in which case a DNF\n+     (directory not found) condition is signalled.  */\n+  tryfile = (char *) __gnat_to_host_file_spec (name);\n \n   /* Allocate and initialize a FAB and NAM structures.  */\n   fab = cc$rms_fab;\n@@ -1238,123 +1357,6 @@ __gnat_set_file_time_name (char *name, time_t time_stamp)\n #endif\n }\n \n-void\n-__gnat_get_env_value_ptr (char *name, int *len, char **value)\n-{\n-  *value = getenv (name);\n-  if (!*value)\n-    *len = 0;\n-  else\n-    *len = strlen (*value);\n-\n-  return;\n-}\n-\n-/* VMS specific declarations for set_env_value.  */\n-\n-#ifdef VMS\n-\n-static char *to_host_path_spec (char *);\n-\n-struct descriptor_s\n-{\n-  unsigned short len, mbz;\n-  __char_ptr32 adr;\n-};\n-\n-typedef struct _ile3\n-{\n-  unsigned short len, code;\n-  __char_ptr32 adr;\n-  unsigned short *retlen_adr;\n-} ile_s;\n-\n-#endif\n-\n-void\n-__gnat_set_env_value (char *name, char *value)\n-{\n-#ifdef MSDOS\n-\n-#elif defined (VMS)\n-  struct descriptor_s name_desc;\n-  /* Put in JOB table for now, so that the project stuff at least works.  */\n-  struct descriptor_s table_desc = {7, 0, \"LNM$JOB\"};\n-  char *host_pathspec = value;\n-  char *copy_pathspec;\n-  int num_dirs_in_pathspec = 1;\n-  char *ptr;\n-  long status;\n-\n-  name_desc.len = strlen (name);\n-  name_desc.mbz = 0;\n-  name_desc.adr = name;\n-\n-  if (*host_pathspec == 0)\n-    /* deassign */\n-    {\n-      status = LIB$DELETE_LOGICAL (&name_desc, &table_desc);\n-      /* no need to check status; if the logical name is not\n-         defined, that's fine. */\n-      return;\n-    }\n-\n-  ptr = host_pathspec;\n-  while (*ptr++)\n-    if (*ptr == ',')\n-      num_dirs_in_pathspec++;\n-\n-  {\n-    int i, status;\n-    ile_s *ile_array = alloca (sizeof (ile_s) * (num_dirs_in_pathspec + 1));\n-    char *copy_pathspec = alloca (strlen (host_pathspec) + 1);\n-    char *curr, *next;\n-\n-    strcpy (copy_pathspec, host_pathspec);\n-    curr = copy_pathspec;\n-    for (i = 0; i < num_dirs_in_pathspec; i++)\n-      {\n-\tnext = strchr (curr, ',');\n-\tif (next == 0)\n-\t  next = strchr (curr, 0);\n-\n-\t*next = 0;\n-\tile_array[i].len = strlen (curr);\n-\n-\t/* Code 2 from lnmdef.h means it's a string.  */\n-\tile_array[i].code = 2;\n-\tile_array[i].adr = curr;\n-\n-\t/* retlen_adr is ignored.  */\n-\tile_array[i].retlen_adr = 0;\n-\tcurr = next + 1;\n-      }\n-\n-    /* Terminating item must be zero.  */\n-    ile_array[i].len = 0;\n-    ile_array[i].code = 0;\n-    ile_array[i].adr = 0;\n-    ile_array[i].retlen_adr = 0;\n-\n-    status = LIB$SET_LOGICAL (&name_desc, 0, &table_desc, 0, ile_array);\n-    if ((status & 1) != 1)\n-      LIB$SIGNAL (status);\n-  }\n-\n-#elif defined (__vxworks) && defined (__RTP__)\n-  setenv (name, value, 1);\n-\n-#else\n-  int size = strlen (name) + strlen (value) + 2;\n-  char *expression;\n-\n-  expression = (char *) xmalloc (size * sizeof (char));\n-\n-  sprintf (expression, \"%s=%s\", name, value);\n-  putenv (expression);\n-#endif\n-}\n-\n #ifdef _WIN32\n #include <windows.h>\n #endif\n@@ -1396,7 +1398,7 @@ __gnat_get_libraries_from_registry (void)\n   for (index = 0; res == ERROR_SUCCESS; index++)\n     {\n       value_size = name_size = 256;\n-      res = RegEnumValue (reg_key, index, name, &name_size, 0,\n+      res = RegEnumValue (reg_key, index, (TCHAR*)name, &name_size, 0,\n                           &type, (LPBYTE)value, &value_size);\n \n       if (res == ERROR_SUCCESS && type == REG_SZ)\n@@ -1421,29 +1423,34 @@ __gnat_get_libraries_from_registry (void)\n int\n __gnat_stat (char *name, struct stat *statbuf)\n {\n-#ifdef _WIN32\n+#ifdef __MINGW32__\n   /* Under Windows the directory name for the stat function must not be\n      terminated by a directory separator except if just after a drive name.  */\n-  int name_len  = strlen (name);\n-  char last_char = name[name_len - 1];\n-  char win32_name[GNAT_MAX_PATH_LEN + 2];\n+  TCHAR wname [GNAT_MAX_PATH_LEN + 2];\n+  int name_len;\n+  TCHAR last_char;\n+\n+  S2WS (wname, name, GNAT_MAX_PATH_LEN + 2);\n+  name_len = _tcslen (wname);\n \n   if (name_len > GNAT_MAX_PATH_LEN)\n     return -1;\n \n-  strcpy (win32_name, name);\n+  last_char = wname[name_len - 1];\n \n-  while (name_len > 1 && (last_char == '\\\\' || last_char == '/'))\n+  while (name_len > 1 && (last_char == _T('\\\\') || last_char == _T('/')))\n     {\n-      win32_name[name_len - 1] = '\\0';\n+      wname[name_len - 1] = _T('\\0');\n       name_len--;\n-      last_char = win32_name[name_len - 1];\n+      last_char = wname[name_len - 1];\n     }\n \n-  if (name_len == 2 && win32_name[1] == ':')\n-    strcat (win32_name, \"\\\\\");\n+  /* Only a drive letter followed by ':', we must add a directory separator\n+     for the stat routine to work properly.  */\n+  if (name_len == 2 && wname[1] == _T(':'))\n+    _tcscat (wname, _T(\"\\\\\"));\n \n-  return stat (win32_name, statbuf);\n+  return _tstat (wname, statbuf);\n \n #else\n   return stat (name, statbuf);\n@@ -1811,11 +1818,20 @@ win32_no_block_spawn (char *command, char *args[])\n       k++;\n     }\n \n-  result = CreateProcess\n-\t     (NULL, (char *) full_command, &SA, NULL, TRUE,\n-              GetPriorityClass (GetCurrentProcess()), NULL, NULL, &SI, &PI);\n+  {\n+    int wsize = csize * 2;\n+    TCHAR *wcommand = (TCHAR *) xmalloc (wsize);\n+\n+    S2WS (wcommand, full_command, wsize);\n+\n+    free (full_command);\n \n-  free (full_command);\n+    result = CreateProcess\n+      (NULL, wcommand, &SA, NULL, TRUE,\n+       GetPriorityClass (GetCurrentProcess()), NULL, NULL, &SI, &PI);\n+\n+    free (wcommand);\n+  }\n \n   if (result == TRUE)\n     {\n@@ -2075,33 +2091,42 @@ char *\n __gnat_locate_exec_on_path (char *exec_name)\n {\n   char *apath_val;\n-#ifdef VMS\n-  char *path_val = \"/VAXC$PATH\";\n-#else\n-  char *path_val = getenv (\"PATH\");\n-#endif\n+\n #ifdef _WIN32\n+  TCHAR *wpath_val = _tgetenv (_T(\"PATH\"));\n+  TCHAR *wapath_val;\n   /* In Win32 systems we expand the PATH as for XP environment\n      variables are not automatically expanded. We also prepend the\n      \".;\" to the path to match normal NT path search semantics */\n \n   #define EXPAND_BUFFER_SIZE 32767\n \n-  apath_val = alloca (EXPAND_BUFFER_SIZE);\n+  wapath_val = alloca (EXPAND_BUFFER_SIZE);\n \n-  apath_val [0] = '.';\n-  apath_val [1] = ';';\n+  wapath_val [0] = '.';\n+  wapath_val [1] = ';';\n \n   DWORD res = ExpandEnvironmentStrings\n-    (path_val, apath_val + 2, EXPAND_BUFFER_SIZE - 2);\n+    (wpath_val, &wapath_val[2], EXPAND_BUFFER_SIZE - 2);\n+\n+  if (!res) wapath_val [0] = _T('\\0');\n+\n+  apath_val = alloca (EXPAND_BUFFER_SIZE);\n+\n+  WS2S (apath_val, wapath_val, EXPAND_BUFFER_SIZE);\n+  return __gnat_locate_exec (exec_name, apath_val);\n \n-  if (!res) apath_val [0] = '\\0';\n #else\n+\n+#ifdef VMS\n+  char *path_val = \"/VAXC$PATH\";\n+#else\n+  char *path_val = getenv (\"PATH\");\n+#endif\n   apath_val = alloca (strlen (path_val) + 1);\n   strcpy (apath_val, path_val);\n-#endif\n-\n   return __gnat_locate_exec (exec_name, apath_val);\n+#endif\n }\n \n #ifdef VMS\n@@ -2556,6 +2581,7 @@ _flush_cache()\n       && ! defined (__APPLE__) \\\n       && ! defined (_AIX) \\\n       && ! (defined (__alpha__)  && defined (__osf__)) \\\n+      && ! defined (VMS) \\\n       && ! defined (__MINGW32__) \\\n       && ! (defined (__mips) && defined (__sgi)))\n "}, {"sha": "9bcf05886b7feafe6bada0b029581d7412cf23ad", "filename": "gcc/ada/adaint.h", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0022d9e31d01f2a31808ff38f66dd3e3ac96927a/gcc%2Fada%2Fadaint.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0022d9e31d01f2a31808ff38f66dd3e3ac96927a/gcc%2Fada%2Fadaint.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.h?ref=0022d9e31d01f2a31808ff38f66dd3e3ac96927a", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *          Copyright (C) 1992-2005, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2006, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -30,7 +30,13 @@\n  *                                                                          *\n  ****************************************************************************/\n \n+#include <sys/stat.h>\n #include <stdio.h>\n+\n+#ifdef _WIN32\n+#include \"mingw32.h\"\n+#endif\n+\n #include <dirent.h>\n \n typedef long OS_Time; /* Type corresponding to GNAT.OS_Lib.OS_Time */\n@@ -68,16 +74,17 @@ extern int    __gnat_open_append                   (char *, int);\n extern long   __gnat_file_length                   (int);\n extern long   __gnat_named_file_length             (char *);\n extern void   __gnat_tmp_name\t\t\t   (char *);\n-extern char  *__gnat_readdir                       (DIR *, char *);\n+extern DIR   *__gnat_opendir                       (char *);\n+extern char  *__gnat_readdir                       (DIR *, char *, int *);\n+extern int    __gnat_closedir                      (DIR *);\n extern int    __gnat_readdir_is_thread_safe        (void);\n \n extern OS_Time __gnat_file_time_name                (char *);\n extern OS_Time __gnat_file_time_fd                  (int);\n /* return -1 in case of error */\n \n extern void   __gnat_set_file_time_name\t\t   (char *, time_t);\n-extern void   __gnat_get_env_value_ptr             (char *, int *,\n-\t\t\t\t\t\t    char **);\n+\n extern int    __gnat_dup\t\t\t   (int);\n extern int    __gnat_dup2\t\t\t   (int, int);\n extern int    __gnat_file_exists\t\t   (char *);\n@@ -98,7 +105,6 @@ extern char  *__gnat_locate_exec_on_path\t   (char *);\n extern char  *__gnat_locate_regular_file           (char *, char *);\n extern void   __gnat_maybe_glob_args               (int *, char ***);\n extern void   __gnat_os_exit\t\t\t   (int);\n-extern void   __gnat_set_env_value\t\t   (char *, char *);\n extern char  *__gnat_get_libraries_from_registry   (void);\n extern int    __gnat_to_canonical_file_list_init   (char *, int);\n extern char  *__gnat_to_canonical_file_list_next   (void);"}, {"sha": "039e09ced6e78c9d243a4e5f877e3b6437305bb5", "filename": "gcc/ada/env.c", "status": "added", "additions": 314, "deletions": 0, "changes": 314, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0022d9e31d01f2a31808ff38f66dd3e3ac96927a/gcc%2Fada%2Fenv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0022d9e31d01f2a31808ff38f66dd3e3ac96927a/gcc%2Fada%2Fenv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fenv.c?ref=0022d9e31d01f2a31808ff38f66dd3e3ac96927a", "patch": "@@ -0,0 +1,314 @@\n+/****************************************************************************\n+ *                                                                          *\n+ *                         GNAT COMPILER COMPONENTS                         *\n+ *                                                                          *\n+ *                                  E N V                                   *\n+ *                                                                          *\n+ *                          C Implementation File                           *\n+ *                                                                          *\n+ *            Copyright (C) 2005-2006, Free Software Foundation, Inc.       *\n+ *                                                                          *\n+ * GNAT is free software;  you can  redistribute it  and/or modify it under *\n+ * terms of the  GNU General Public License as published  by the Free Soft- *\n+ * ware  Foundation;  either version 2,  or (at your option) any later ver- *\n+ * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n+ * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License *\n+ * for  more details.  You should have  received  a copy of the GNU General *\n+ * Public License  distributed with GNAT;  see file COPYING.  If not, write *\n+ * to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, *\n+ * Boston, MA 02110-1301, USA.                                              *\n+ *                                                                          *\n+ * As a  special  exception,  if you  link  this file  with other  files to *\n+ * produce an executable,  this file does not by itself cause the resulting *\n+ * executable to be covered by the GNU General Public License. This except- *\n+ * ion does not  however invalidate  any other reasons  why the  executable *\n+ * file might be covered by the  GNU Public License.                        *\n+ *                                                                          *\n+ * GNAT was originally developed  by the GNAT team at  New York University. *\n+ * Extensive contributions were provided by Ada Core Technologies Inc.      *\n+ *                                                                          *\n+ ****************************************************************************/\n+\n+#ifdef IN_RTS\n+#include \"tconfig.h\"\n+#include \"tsystem.h\"\n+\n+#include <sys/stat.h>\n+#include <fcntl.h>\n+#include <time.h>\n+#ifdef VMS\n+#include <unixio.h>\n+#endif\n+\n+#if defined (__APPLE__)\n+#include <crt_externs.h>\n+#endif\n+\n+#if defined (__MINGW32__)\n+#include <stdlib.h>\n+#endif\n+\n+#if defined (__vxworks) && ! (defined (__RTP__) || defined (__COREOS__))\n+#include \"envLib.h\"\n+extern char** ppGlobalEnviron;\n+#endif\n+\n+/* We don't have libiberty, so use malloc.  */\n+#define xmalloc(S) malloc (S)\n+#else /* IN_RTS */\n+#include \"config.h\"\n+#include \"system.h\"\n+#endif /* IN_RTS */\n+\n+#include \"env.h\"\n+\n+void\n+__gnat_getenv (char *name, int *len, char **value)\n+{\n+  *value = getenv (name);\n+  if (!*value)\n+    *len = 0;\n+  else\n+    *len = strlen (*value);\n+\n+  return;\n+}\n+\n+/* VMS specific declarations for set_env_value.  */\n+\n+#ifdef VMS\n+\n+static char *to_host_path_spec (char *);\n+\n+struct descriptor_s\n+{\n+  unsigned short len, mbz;\n+  __char_ptr32 adr;\n+};\n+\n+typedef struct _ile3\n+{\n+  unsigned short len, code;\n+  __char_ptr32 adr;\n+  unsigned short *retlen_adr;\n+} ile_s;\n+\n+#endif\n+\n+void\n+__gnat_setenv (char *name, char *value)\n+{\n+#ifdef MSDOS\n+\n+#elif defined (VMS)\n+  struct descriptor_s name_desc;\n+  /* Put in JOB table for now, so that the project stuff at least works.  */\n+  struct descriptor_s table_desc = {7, 0, \"LNM$JOB\"};\n+  char *host_pathspec = value;\n+  char *copy_pathspec;\n+  int num_dirs_in_pathspec = 1;\n+  char *ptr;\n+  long status;\n+\n+  name_desc.len = strlen (name);\n+  name_desc.mbz = 0;\n+  name_desc.adr = name;\n+\n+  if (*host_pathspec == 0)\n+    /* deassign */\n+    {\n+      status = LIB$DELETE_LOGICAL (&name_desc, &table_desc);\n+      /* no need to check status; if the logical name is not\n+         defined, that's fine. */\n+      return;\n+    }\n+\n+  ptr = host_pathspec;\n+  while (*ptr++)\n+    if (*ptr == ',')\n+      num_dirs_in_pathspec++;\n+\n+  {\n+    int i, status;\n+    ile_s *ile_array = alloca (sizeof (ile_s) * (num_dirs_in_pathspec + 1));\n+    char *copy_pathspec = alloca (strlen (host_pathspec) + 1);\n+    char *curr, *next;\n+\n+    strcpy (copy_pathspec, host_pathspec);\n+    curr = copy_pathspec;\n+    for (i = 0; i < num_dirs_in_pathspec; i++)\n+      {\n+\tnext = strchr (curr, ',');\n+\tif (next == 0)\n+\t  next = strchr (curr, 0);\n+\n+\t*next = 0;\n+\tile_array[i].len = strlen (curr);\n+\n+\t/* Code 2 from lnmdef.h means it's a string.  */\n+\tile_array[i].code = 2;\n+\tile_array[i].adr = curr;\n+\n+\t/* retlen_adr is ignored.  */\n+\tile_array[i].retlen_adr = 0;\n+\tcurr = next + 1;\n+      }\n+\n+    /* Terminating item must be zero.  */\n+    ile_array[i].len = 0;\n+    ile_array[i].code = 0;\n+    ile_array[i].adr = 0;\n+    ile_array[i].retlen_adr = 0;\n+\n+    status = LIB$SET_LOGICAL (&name_desc, 0, &table_desc, 0, ile_array);\n+    if ((status & 1) != 1)\n+      LIB$SIGNAL (status);\n+  }\n+\n+#elif defined (__vxworks) && defined (__RTP__)\n+  setenv (name, value, 1);\n+\n+#else\n+  int size = strlen (name) + strlen (value) + 2;\n+  char *expression;\n+\n+  expression = (char *) xmalloc (size * sizeof (char));\n+\n+  sprintf (expression, \"%s=%s\", name, value);\n+  putenv (expression);\n+#if defined (__FreeBSD__) || defined (__APPLE__) || defined (__MINGW32__) \\\n+   ||(defined (__vxworks) && ! defined (__RTP__))\n+  /* On some systems like FreeBSD, MacOS X and Windows, putenv is making\n+     a copy of the expression string so we can free it after the call to\n+     putenv */\n+  free (expression);\n+#endif\n+#endif\n+}\n+\n+char **\n+__gnat_environ (void)\n+{\n+#if defined (VMS)\n+  /* Not implemented */\n+  return NULL;\n+#elif defined (__APPLE__)\n+  char ***result = _NSGetEnviron ();\n+  return *result;\n+#elif defined (__MINGW32__)\n+  return _environ;\n+#elif defined (sun)\n+  extern char **_environ;\n+  return _environ;\n+#else\n+#if ! (defined (__vxworks) && ! (defined (__RTP__) || defined (__COREOS__)))\n+  /* in VxWorks kernel mode environ is macro and not a variable */\n+  /* same thing on 653 in the CoreOS */\n+  extern char **environ;\n+#endif\n+  return environ;\n+#endif\n+}\n+\n+void __gnat_unsetenv (char *name) {\n+#if defined (VMS)\n+  /* Not implemented */\n+  return;\n+#elif defined (__hpux__) || defined (sun) \\\n+     || (defined (__mips) && defined (__sgi)) \\\n+     || (defined (__vxworks) && ! defined (__RTP__)) \\\n+     || defined (_AIX)\n+\n+  /* On Solaris, HP-UX and IRIX there is no function to clear an environment\n+     variable. So we look for the variable in the environ table and delete it\n+     by setting the entry to NULL. This can clearly cause some memory leaks\n+     but free cannot be used on this context as not all strings in the environ\n+     have been allocated using malloc. To avoid this memory leak another\n+     method can be used. It consists in forcing the reallocation of all the\n+     strings in the environ table using malloc on the first call on the\n+     functions related to environment variable management. The disavantage\n+     is that if a program makes a direct call to getenv the return string\n+     may be deallocated at some point. */\n+  /* Note that on AIX, unsetenv is not supported on 5.1 but it is on 5.3.\n+     As we are still supporting AIX 5.1 we cannot use unsetenv */\n+  char **env = __gnat_environ ();\n+  int index = 0;\n+  int size = strlen (name);\n+\n+  while (env[index] != NULL) {\n+     if (strlen (env[index]) > size) {\n+       if (strstr (env[index], name) == env[index] &&\n+\t   env[index][size] == '=') {\n+#if defined (__vxworks) && ! defined (__RTP__)\n+         /* on Vxworks we are sure that the string has been allocated using\n+            malloc */\n+         free (env[index]);\n+#endif\n+         while (env[index] != NULL) {\n+          env[index]=env[index + 1];\n+          index++;\n+         }\n+       } else\n+           index++;\n+     } else\n+         index++;\n+  }\n+#elif defined (__MINGW32__)\n+  /* On Windows platform putenv (\"key=\") is equivalent to unsetenv (a\n+     subsequent call to getenv (\"key\") will return NULL and not the \"\\0\"\n+     string */\n+  int size = strlen (name) + 2;\n+  char *expression;\n+  expression = (char *) xmalloc (size * sizeof (char));\n+\n+  sprintf (expression, \"%s=\", name);\n+  putenv (expression);\n+  free (expression);\n+#else\n+  unsetenv (name);\n+#endif\n+}\n+\n+void __gnat_clearenv (void) {\n+#if defined (VMS)\n+  /* not implemented */\n+  return;\n+#elif defined (sun) || (defined (__mips) && defined (__sgi)) \\\n+   || (defined (__vxworks) && ! defined (__RTP__)) || defined (__Lynx__)\n+  /* On Solaris, IRIX, VxWorks (not RTPs), and Lynx there is no system\n+     call to unset a variable or to clear the environment so set all\n+     the entries in the environ table to NULL (see comment in\n+     __gnat_unsetenv for more explanation). */\n+  char **env = __gnat_environ ();\n+  int index = 0;\n+\n+  while (env[index] != NULL) {\n+    env[index]=NULL;\n+    index++;\n+  }\n+#elif defined (__MINGW32__) || defined (__FreeBSD__) || defined (__APPLE__) \\\n+   || (defined (__vxworks) && defined (__RTP__))\n+  /* On Windows, FreeBSD and MacOS there is no function to clean all the\n+     environment but there is a \"clean\" way to unset a variable. So go\n+     through the environ table and call __gnat_unsetenv on all entries */\n+  char **env = __gnat_environ ();\n+  int size;\n+\n+  while (env[0] != NULL) {\n+    size = 0;\n+    while (env[0][size] != '=')\n+      size++;\n+    /* create a string that contains \"name\" */\n+    size++;\n+    {\n+      char expression[size];\n+      strncpy (expression, env[0], size);\n+      expression[size - 1] = 0;\n+      __gnat_unsetenv (expression);\n+    }\n+  }\n+#else\n+  clearenv ();\n+#endif\n+}"}, {"sha": "c960e9f16ab324960181bda365c8625dc09cd6a5", "filename": "gcc/ada/env.h", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0022d9e31d01f2a31808ff38f66dd3e3ac96927a/gcc%2Fada%2Fenv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0022d9e31d01f2a31808ff38f66dd3e3ac96927a/gcc%2Fada%2Fenv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fenv.h?ref=0022d9e31d01f2a31808ff38f66dd3e3ac96927a", "patch": "@@ -0,0 +1,6 @@\n+extern void __gnat_getenv (char *name, int *len, char **value);\n+extern void __gnat_setenv (char *name, char *value);\n+extern char **__gnat_environ (void);\n+extern void __gnat_unsetenv (char *name);\n+extern void __gnat_clearenv (void);\n+"}, {"sha": "5302969ac716ed65e516bb9059db0ba4ddadd6d2", "filename": "gcc/ada/g-dirope.adb", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0022d9e31d01f2a31808ff38f66dd3e3ac96927a/gcc%2Fada%2Fg-dirope.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0022d9e31d01f2a31808ff38f66dd3e3ac96927a/gcc%2Fada%2Fg-dirope.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-dirope.adb?ref=0022d9e31d01f2a31808ff38f66dd3e3ac96927a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                     Copyright (C) 1998-2005, AdaCore                     --\n+--                     Copyright (C) 1998-2006, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -33,7 +33,6 @@\n \n with Ada.Characters.Handling;\n with Ada.Strings.Fixed;\n-with Ada.Strings.Maps;\n \n with Unchecked_Deallocation;\n with Unchecked_Conversion;\n@@ -187,6 +186,9 @@ package body GNAT.Directory_Operations is\n       Discard : Integer;\n       pragma Warnings (Off, Discard);\n \n+      function closedir (directory : DIRs) return Integer;\n+      pragma Import (C, closedir, \"__gnat_closedir\");\n+\n    begin\n       if not Is_Open (Dir) then\n          raise Directory_Error;\n@@ -625,6 +627,9 @@ package body GNAT.Directory_Operations is\n      (Dir      : out Dir_Type;\n       Dir_Name : Dir_Name_Str)\n    is\n+      function opendir (file_name : String) return DIRs;\n+      pragma Import (C, opendir, \"__gnat_opendir\");\n+\n       C_File_Name : constant String := Dir_Name & ASCII.NUL;\n \n    begin\n@@ -647,35 +652,32 @@ package body GNAT.Directory_Operations is\n       Last : out Natural)\n    is\n       Filename_Addr : Address;\n-      Filename_Len  : Integer;\n+      Filename_Len  : aliased Integer;\n \n       Buffer : array (0 .. Filename_Max + 12) of Character;\n       --  12 is the size of the dirent structure (see dirent.h), without the\n       --  field for the filename.\n \n       function readdir_gnat\n         (Directory : System.Address;\n-         Buffer    : System.Address) return System.Address;\n+         Buffer    : System.Address;\n+         Last      : access Integer) return System.Address;\n       pragma Import (C, readdir_gnat, \"__gnat_readdir\");\n \n-      function strlen (S : Address) return Integer;\n-      pragma Import (C, strlen, \"strlen\");\n-\n    begin\n       if not Is_Open (Dir) then\n          raise Directory_Error;\n       end if;\n \n       Filename_Addr :=\n-        readdir_gnat (System.Address (Dir.all), Buffer'Address);\n+        readdir_gnat\n+          (System.Address (Dir.all), Buffer'Address, Filename_Len'Access);\n \n       if Filename_Addr = System.Null_Address then\n          Last := 0;\n          return;\n       end if;\n \n-      Filename_Len  := strlen (Filename_Addr);\n-\n       if Str'Length > Filename_Len then\n          Last := Str'First + Filename_Len - 1;\n       else"}, {"sha": "dbfc6b9174538db099fc407bd53eaa5bc1e10883", "filename": "gcc/ada/g-os_lib.adb", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0022d9e31d01f2a31808ff38f66dd3e3ac96927a/gcc%2Fada%2Fg-os_lib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0022d9e31d01f2a31808ff38f66dd3e3ac96927a/gcc%2Fada%2Fg-os_lib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-os_lib.adb?ref=0022d9e31d01f2a31808ff38f66dd3e3ac96927a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                     Copyright (C) 1995-2005, AdaCore                     --\n+--                     Copyright (C) 1995-2006, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -609,11 +609,11 @@ package body GNAT.OS_Lib is\n             C_Source : String (1 .. Source'Length + 1);\n             C_Dest   : String (1 .. Dest'Length + 1);\n          begin\n-            C_Source (1 .. C_Source'Length) := Source;\n-            C_Source (C_Source'Last)        := ASCII.Nul;\n+            C_Source (1 .. Source'Length) := Source;\n+            C_Source (C_Source'Last)      := ASCII.NUL;\n \n-            C_Dest (1 .. C_Dest'Length) := Dest;\n-            C_Dest (C_Dest'Last)        := ASCII.Nul;\n+            C_Dest (1 .. Dest'Length) := Dest;\n+            C_Dest (C_Dest'Last)      := ASCII.NUL;\n \n             if Copy_Attributes (C_Source'Address, C_Dest'Address, 0) = -1 then\n                Success := False;\n@@ -1057,7 +1057,7 @@ package body GNAT.OS_Lib is\n \n    function Getenv (Name : String) return String_Access is\n       procedure Get_Env_Value_Ptr (Name, Length, Ptr : Address);\n-      pragma Import (C, Get_Env_Value_Ptr, \"__gnat_get_env_value_ptr\");\n+      pragma Import (C, Get_Env_Value_Ptr, \"__gnat_getenv\");\n \n       procedure Strncpy (Astring_Addr, Cstring : Address; N : Integer);\n       pragma Import (C, Strncpy, \"strncpy\");\n@@ -1702,12 +1702,11 @@ package body GNAT.OS_Lib is\n          --  Directory given, add directory separator if needed\n \n          if Dir'Length > 0 then\n-            if Dir (Dir'Length) = Directory_Separator then\n+            if Dir (Dir'Last) = Directory_Separator then\n                return Directory;\n             else\n                declare\n                   Result : String (1 .. Dir'Length + 1);\n-\n                begin\n                   Result (1 .. Dir'Length) := Dir;\n                   Result (Result'Length) := Directory_Separator;\n@@ -2313,7 +2312,7 @@ package body GNAT.OS_Lib is\n       F_Value : String (1 .. Value'Length + 1);\n \n       procedure Set_Env_Value (Name, Value : System.Address);\n-      pragma Import (C, Set_Env_Value, \"__gnat_set_env_value\");\n+      pragma Import (C, Set_Env_Value, \"__gnat_setenv\");\n \n    begin\n       F_Name (1 .. Name'Length) := Name;"}, {"sha": "79d70d777900234c2c9dc64d4a7bd9f22e8a8766", "filename": "gcc/ada/mingw32.h", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0022d9e31d01f2a31808ff38f66dd3e3ac96927a/gcc%2Fada%2Fmingw32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0022d9e31d01f2a31808ff38f66dd3e3ac96927a/gcc%2Fada%2Fmingw32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmingw32.h?ref=0022d9e31d01f2a31808ff38f66dd3e3ac96927a", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *          Copyright (C) 2002-2004, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 2002-2006, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -36,6 +36,35 @@\n #ifndef _MINGW32_H\n #define _MINGW32_H\n \n+\n+\n+/* Uncomment to activate the GNAT Unicode support. */\n+/*#define GNAT_UNICODE_SUPPORT */\n+\n+#ifdef GNAT_UNICODE_SUPPORT\n+#define _UNICODE /* For C runtime */\n+#define UNICODE  /* For Win32 API */\n+#endif\n+\n+#include <tchar.h>\n+\n+/* After including this file it is possible to use the character t as prefix\n+   to routines. If GNAT_UNICODE_SUPPORT is defined then the unicode enabled\n+   versions will be used. */\n+\n+/* Copy to/from wide-string, if GNAT_UNICODE_SUPPORT activated this will do\n+   the proper translations using the UTF-8 encoding.  */\n+\n+#ifdef GNAT_UNICODE_SUPPORT\n+#define S2WS(wstr,str,len) \\\n+   MultiByteToWideChar (CP_UTF8,0,str,-1,wstr,len);\n+#define WS2S(str,wstr,len) \\\n+   WideCharToMultiByte (CP_UTF8,0,wstr,-1,str,len,NULL,NULL);\n+#else\n+#define S2WS(wstr,str,len) strncpy(wstr,str,len);\n+#define WS2S(str,wstr,len) strncpy(str,wstr,len);\n+#endif\n+\n #include <stdlib.h>\n \n /* STD_MINGW: standard if MINGW32 version > 1.3, we have switched to this"}, {"sha": "83292b708957f11de2ac42a89cfcc3a83b73b258", "filename": "gcc/ada/s-crtl-vms64.ads", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0022d9e31d01f2a31808ff38f66dd3e3ac96927a/gcc%2Fada%2Fs-crtl-vms64.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0022d9e31d01f2a31808ff38f66dd3e3ac96927a/gcc%2Fada%2Fs-crtl-vms64.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-crtl-vms64.ads?ref=0022d9e31d01f2a31808ff38f66dd3e3ac96927a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                S p e c                                   --\n --                                                                          --\n---         Copyright (C) 2004-2005 Free Software Foundation, Inc.           --\n+--         Copyright (C) 2004-2006, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -63,9 +63,6 @@ package System.CRTL is\n    procedure clearerr (stream : FILEs);\n    pragma Import (C, clearerr, \"decc$clearerr\");\n \n-   function closedir (directory : DIRs) return Integer;\n-   pragma Import (C, closedir, \"decc$closedir\");\n-\n    function dup  (handle : int) return int;\n    pragma Import (C, dup, \"decc$dup\");\n \n@@ -137,9 +134,6 @@ package System.CRTL is\n    procedure mktemp (template : chars);\n    pragma Import (C, mktemp, \"decc$_mktemp64\");\n \n-   function opendir (file_name : String) return DIRs;\n-   pragma Import (C, opendir, \"decc$opendir\");\n-\n    function pclose (stream : System.Address) return int;\n    pragma Import (C, pclose, \"decc$pclose\");\n "}, {"sha": "7ce99bcb1e09a06fcd3f362a57aeb73c60e6bcd5", "filename": "gcc/ada/s-crtl.ads", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0022d9e31d01f2a31808ff38f66dd3e3ac96927a/gcc%2Fada%2Fs-crtl.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0022d9e31d01f2a31808ff38f66dd3e3ac96927a/gcc%2Fada%2Fs-crtl.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-crtl.ads?ref=0022d9e31d01f2a31808ff38f66dd3e3ac96927a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2003-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2003-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -63,9 +63,6 @@ package System.CRTL is\n    procedure clearerr (stream : FILEs);\n    pragma Import (C, clearerr, \"clearerr\");\n \n-   function closedir (directory : DIRs) return Integer;\n-   pragma Import (C, closedir, \"closedir\");\n-\n    function dup  (handle : int) return int;\n    pragma Import (C, dup, \"dup\");\n \n@@ -137,9 +134,6 @@ package System.CRTL is\n    procedure mktemp (template : chars);\n    pragma Import (C, mktemp, \"mktemp\");\n \n-   function opendir (file_name : String) return DIRs;\n-   pragma Import (C, opendir, \"opendir\");\n-\n    function pclose (stream : System.Address) return int;\n    pragma Import (C, pclose, \"pclose\");\n "}, {"sha": "c0ad1e10c309b477cc36d0e7237a46b073533f01", "filename": "gcc/ada/s-scaval.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0022d9e31d01f2a31808ff38f66dd3e3ac96927a/gcc%2Fada%2Fs-scaval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0022d9e31d01f2a31808ff38f66dd3e3ac96927a/gcc%2Fada%2Fs-scaval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-scaval.adb?ref=0022d9e31d01f2a31808ff38f66dd3e3ac96927a", "patch": "@@ -44,7 +44,7 @@ package body System.Scalar_Values is\n       C2 : Character := Mode2;\n \n       procedure Get_Env_Value_Ptr (Name, Length, Ptr : Address);\n-      pragma Import (C, Get_Env_Value_Ptr, \"__gnat_get_env_value_ptr\");\n+      pragma Import (C, Get_Env_Value_Ptr, \"__gnat_getenv\");\n \n       subtype String2 is String (1 .. 2);\n       type String2_Ptr is access all String2;"}, {"sha": "5d8e11f9e71c6d072761a420aaf7df4de5fbb50b", "filename": "gcc/ada/s-shasto.adb", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0022d9e31d01f2a31808ff38f66dd3e3ac96927a/gcc%2Fada%2Fs-shasto.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0022d9e31d01f2a31808ff38f66dd3e3ac96927a/gcc%2Fada%2Fs-shasto.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-shasto.adb?ref=0022d9e31d01f2a31808ff38f66dd3e3ac96927a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1998-2002 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1998-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -34,7 +34,6 @@\n with Ada.Exceptions;\n with Ada.IO_Exceptions;\n with Ada.Streams;\n-with Ada.Streams.Stream_IO;\n \n with System.Global_Locks;\n with System.Soft_Links;\n@@ -86,7 +85,7 @@ package body System.Shared_Storage is\n \n    procedure Write\n      (Stream : in out File_Stream_Type;\n-      Item   : in AS.Stream_Element_Array);\n+      Item   : AS.Stream_Element_Array);\n \n    subtype Hash_Header is Natural range 0 .. 30;\n    --  Number of hash headers, related (for efficiency purposes only)\n@@ -249,7 +248,7 @@ package body System.Shared_Storage is\n \n    procedure Initialize is\n       procedure Get_Env_Value_Ptr (Name, Length, Ptr : Address);\n-      pragma Import (C, Get_Env_Value_Ptr, \"__gnat_get_env_value_ptr\");\n+      pragma Import (C, Get_Env_Value_Ptr, \"__gnat_getenv\");\n \n       procedure Strncpy (Astring_Addr, Cstring : Address; N : Integer);\n       pragma Import (C, Strncpy, \"strncpy\");\n@@ -331,7 +330,7 @@ package body System.Shared_Storage is\n    -- Shared_Var_Close --\n    ----------------------\n \n-   procedure Shared_Var_Close (Var : in SIO.Stream_Access) is\n+   procedure Shared_Var_Close (Var : SIO.Stream_Access) is\n       pragma Warnings (Off, Var);\n \n    begin\n@@ -342,7 +341,7 @@ package body System.Shared_Storage is\n    -- Shared_Var_Lock --\n    ---------------------\n \n-   procedure Shared_Var_Lock (Var : in String) is\n+   procedure Shared_Var_Lock (Var : String) is\n       pragma Warnings (Off, Var);\n \n    begin\n@@ -429,7 +428,7 @@ package body System.Shared_Storage is\n    -- Shared_Var_Unlock --\n    -----------------------\n \n-   procedure Shared_Var_Unlock (Var : in String) is\n+   procedure Shared_Var_Unlock (Var : String) is\n       pragma Warnings (Off, Var);\n \n    begin\n@@ -522,7 +521,7 @@ package body System.Shared_Storage is\n \n    procedure Write\n      (Stream : in out File_Stream_Type;\n-      Item   : in AS.Stream_Element_Array)\n+      Item   : AS.Stream_Element_Array)\n    is\n    begin\n       SIO.Write (Stream.File, Item);"}]}