{"sha": "a6a0db7d1bc7ad640bab51769e53f1cb4ad4bb88", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTZhMGRiN2QxYmM3YWQ2NDBiYWI1MTc2OWU1M2YxY2I0YWQ0YmI4OA==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2020-12-07T08:35:09Z"}, "committer": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2020-12-07T08:35:09Z"}, "message": "ipa-cp: Avoid unwanted multiple propagations (PR 97816)\n\nWhen looking at the testcase of PR 97816 I realized that the reason\nwhy we were hitting overflows in size growth estimates in IPA-CP is\nnot because the chains of how lattices feed values to each other are\nso long but mainly because we add estimates in callee lattices to\ncaller lattices for each value source, which roughly corresponds to a\ncall graph edge, and therefore if there are multiple calls between two\nfunctions passing the same value in a parameter we end up doing it\nmore than once, sometimes actually quite many times.\n\nThis patch avoids it by using a has_set to remember the source values\nwe have already updated and not increasing their size again.\nFurhtermore, to improve estimation of times we scale the propagated\ntime benefits with edge frequencies as we accumulate them.\n\nThis should make any overflows very unlikely but not impossible, so I\nstill included checks for overflows but decided to restructure the\ncode to only need it in the propagate_effects function and modified it\nso that it does not need to perform the check before each sum.\n\nThis is because I decided to add local estimates to propagated\nestimates already in propagate_effects and not at the evaluation time.\nThe function can then do the sums in a wide type and discard them in\nthe unlikely case of an overflow.  I also decided to use the\nopportunity to make propagated effect stats now include stats from\nother values in the same SCCs.  In the dumps I have seen this tended\nto increase size cost a tiny bit more than the estimated time benefit\nbut both increases were small.\n\nMartin\n\ngcc/ChangeLog:\n\n2020-11-20  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/97816\n\t* ipa-cp.c (safe_add): Removed.\n\t(good_cloning_opportunity_p): Remove special handling of INT_MAX.\n\t(value_topo_info<valtype>::propagate_effects): Take care not to\n\tpropagate from size one value to another through more sources.  Scale\n\tpropagated times with edge frequencies.  Include local time and size\n\tin propagates ones here.  Take care not to overflow size.\n\t(decide_about_value): Do not add local and propagated effects when\n\tpassing them to good_cloning_opportunity_p.", "tree": {"sha": "5b1ccf8846ec4ba1857650f13c74c63768ffb5a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b1ccf8846ec4ba1857650f13c74c63768ffb5a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a6a0db7d1bc7ad640bab51769e53f1cb4ad4bb88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6a0db7d1bc7ad640bab51769e53f1cb4ad4bb88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6a0db7d1bc7ad640bab51769e53f1cb4ad4bb88", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6a0db7d1bc7ad640bab51769e53f1cb4ad4bb88/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8441545d4f2afb9e9342e0dac378eafd03f00462", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8441545d4f2afb9e9342e0dac378eafd03f00462", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8441545d4f2afb9e9342e0dac378eafd03f00462"}], "stats": {"total": 68, "additions": 32, "deletions": 36}, "files": [{"sha": "ac9bc239270c3dd0ec85d4884aa5f5f62b4d4733", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 32, "deletions": 36, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6a0db7d1bc7ad640bab51769e53f1cb4ad4bb88/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6a0db7d1bc7ad640bab51769e53f1cb4ad4bb88/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=a6a0db7d1bc7ad640bab51769e53f1cb4ad4bb88", "patch": "@@ -3272,13 +3272,6 @@ good_cloning_opportunity_p (struct cgraph_node *node, sreal time_benefit,\n     return false;\n \n   gcc_assert (size_cost > 0);\n-  if (size_cost == INT_MAX)\n-    {\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \"     good_cloning_opportunity_p returning \"\n-\t\t \"false because of size overflow.\\n\");\n-      return false;\n-    }\n \n   class ipa_node_params *info = IPA_NODE_REF (node);\n   int eval_threshold = opt_for_fn (node->decl, param_ipa_cp_eval_threshold);\n@@ -3848,20 +3841,6 @@ propagate_constants_topo (class ipa_topo_info *topo)\n     }\n }\n \n-\n-/* Return the sum of A and B if none of them is bigger than INT_MAX/2, return\n-   INT_MAX.  */\n-\n-static int\n-safe_add (int a, int b)\n-{\n-  if (a > INT_MAX/2 || b > INT_MAX/2)\n-    return INT_MAX;\n-  else\n-    return a + b;\n-}\n-\n-\n /* Propagate the estimated effects of individual values along the topological\n    from the dependent values to those they depend on.  */\n \n@@ -3870,30 +3849,51 @@ void\n value_topo_info<valtype>::propagate_effects ()\n {\n   ipcp_value<valtype> *base;\n+  hash_set<ipcp_value<valtype> *> processed_srcvals;\n \n   for (base = values_topo; base; base = base->topo_next)\n     {\n       ipcp_value_source<valtype> *src;\n       ipcp_value<valtype> *val;\n       sreal time = 0;\n-      int size = 0;\n+      HOST_WIDE_INT size = 0;\n \n       for (val = base; val; val = val->scc_next)\n \t{\n \t  time = time + val->local_time_benefit + val->prop_time_benefit;\n-\t  size = safe_add (size, safe_add (val->local_size_cost,\n-\t\t\t\t\t   val->prop_size_cost));\n+\t  size = size + val->local_size_cost + val->prop_size_cost;\n \t}\n \n       for (val = base; val; val = val->scc_next)\n-\tfor (src = val->sources; src; src = src->next)\n-\t  if (src->val\n-\t      && src->cs->maybe_hot_p ())\n+\t{\n+\t  processed_srcvals.empty ();\n+\t  for (src = val->sources; src; src = src->next)\n+\t    if (src->val\n+\t\t&& src->cs->maybe_hot_p ())\n+\t      {\n+\t\tif (!processed_srcvals.add (src->val))\n+\t\t  {\n+\t\t    HOST_WIDE_INT prop_size = size + src->val->prop_size_cost;\n+\t\t    if (prop_size < INT_MAX)\n+\t\t      src->val->prop_size_cost = prop_size;\n+\t\t    else\n+\t\t      continue;\n+\t\t  }\n+\t\tsrc->val->prop_time_benefit\n+\t\t  += time * src->cs->sreal_frequency ();\n+\t      }\n+\n+\t  if (size < INT_MAX)\n \t    {\n-\t      src->val->prop_time_benefit = time + src->val->prop_time_benefit;\n-\t      src->val->prop_size_cost = safe_add (size,\n-\t\t\t\t\t\t   src->val->prop_size_cost);\n+\t      val->prop_time_benefit = time;\n+\t      val->prop_size_cost = size;\n \t    }\n+\t  else\n+\t    {\n+\t      val->prop_time_benefit = 0;\n+\t      val->prop_size_cost = 0;\n+\t    }\n+\t}\n     }\n }\n \n@@ -5508,12 +5508,8 @@ decide_about_value (struct cgraph_node *node, int index, HOST_WIDE_INT offset,\n   if (!good_cloning_opportunity_p (node, val->local_time_benefit,\n \t\t\t\t   freq_sum, count_sum,\n \t\t\t\t   val->local_size_cost)\n-      && !good_cloning_opportunity_p (node,\n-\t\t\t\t      val->local_time_benefit\n-\t\t\t\t      + val->prop_time_benefit,\n-\t\t\t\t      freq_sum, count_sum,\n-\t\t\t\t      safe_add (val->local_size_cost,\n-\t\t\t\t\t\tval->prop_size_cost)))\n+      && !good_cloning_opportunity_p (node, val->prop_time_benefit,\n+\t\t\t\t      freq_sum, count_sum, val->prop_size_cost))\n     return false;\n \n   if (dump_file)"}]}