{"sha": "d9fd7154ec7908eff8bbbce75651eccf51064ac1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDlmZDcxNTRlYzc5MDhlZmY4YmJiY2U3NTY1MWVjY2Y1MTA2NGFjMQ==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2001-12-15T07:47:03Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2001-12-15T07:47:03Z"}, "message": "Collections drop from Classpath:\n\n2001-12-15  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>\n\n\t* java/util/BitSet.java (and): Fix off-by-one bug, don't skip part of\n\tthe bitset.\n\t(andNot): Likewise.\n\t(xor): Likewise.\n\n2001-12-15  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>\n\n\t* java/util/LinkedList.java (LinkedListItr.add): Don't skip the next\n\tentry.\n\n2001-12-15  Eric Blake  <ebb9@email.byu.edu>\n\n\t* java/util/TreeMap.java (removeNode): Fix bug in node removal.\n\n2001-12-15  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>\n\n\t* java/util/AbstractCollection.java (containsAll): Use size of the\n\tcorrect collection for loop bound.\n\t* java/util/AbstractList.java (iterator.next): Increment pos after\n\tcalling get on backing list.\n\t(listIterator.next): Likewise.\n\t* java/util/LinkedList.java (addLastEntry): Don't increment size before\n\tchecking for size == 0.\n\t(addFirstEntry): Rearrange to match addLastEntry.\n\t(add): Do not increment size before inserting the new entry.\n\n\t* java/util/AbstractCollection.java (addAll): Use size of the\n\tcorrect collection for loop bound.\n\n2001-12-15  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>\n\n\t* java/util/AbstractSet.java (removeAll): Fix scoping thinko.\n\t* java/util/HashMap.java (putAllInternal): Set size here.\n\t* java/util/Hashtable.java (putAllInternal): New method. Copy contents\n\tof a map efficiently without calling put() or putAll().\n\t(Hashtable (map)): Use putAllInternal.\n\t(clone): Likewise.\n\n2001-12-15  Eric Blake  <ebb9@email.byu.edu>\n\n\t* java/util/Collections.java:\n\t* java/util/Vector.java:\n\t* java/util/WeakHashMap.java: Fix spelling errors.\n\n2001-12-15  Eric Blake  <ebb9@email.byu.edu>\n\n\t* java/util/AbstractCollection.java (removeAllInternal),\n\t(retainAllInternal): Add hooks for use by ArrayList.\n\t* java/util/AbstractList.java: Minor code updates. Fix some\n\tscoping.\n\t* java/util/AbstractMap.java: ditto\n\t* java/util/ArrayList.java (readObject, writeObject): ditto\n\t(removeAllInternal, retainAllInternal): Optimize.\n\t* java/util/Arrays.java: ditto\n\t* java/util/Collections.java: ditto. Change order of parameters\n\tto equals(Object, Object) to match specs.\n\t* java/util/Dictionary.java: Improve javadoc.\n\t(Dictionary): Add explicit constructor.\n\t* java/util/HashMap.java: Improve javadoc. Rearrange methods to\n\tfollow order in JDK. Cleanups related to recent code migration to\n\tAbstractMap. Fix some scoping.\n\t(entrySet): Cache the result.\n\t(modCount): Ensure that this is updated correctly.\n\t* java/util/HashSet.java: Improve javadoc. Fix some scoping.\n\t(init): Add hooks for LinkedHashSet.\n\t(map): Use \"\" instead of Boolean.TRUE in backing map. Use\n\tpackage-private API where possible for less overhead.\n\t(readObject, writeObject): Fix serialization.\n\t* java/util/Hashtable.java: Improve javadoc. Fix some scoping.\n\t(entrySet, keySet, values): Cache the result.\n\t(modCount): Ensure that this is updated correctly.\n\t(contains, remove): Fix NullPointer checking to match specs.\n\t(class Enumeration): Make more like HashIterator.\n\t* java/util/IdentityHashMap.java: Minor code updates.\n\t(modCount): Ensure that this is updated correctly.\n\t(readObject, writeObject): Fix serialization.\n\t* java/util/LinkedHashMap.java: Minor code updates. Cleanups\n\trelated to recent code migration to AbstractMap.\n\t* java/util/LinkedHashSet.java: New file.\n\t* java/util/LinkedList.java:\n\t(readObject, writeObject): Fix serialization.\n\t* java/util/Makefile.am: List recently added files.\n\t* java/util/Stack.java: Minor code updates.\n\t* java/util/TreeMap.java: Improve javadoc. Overhaul the class to\n\tbe more efficient. Fix some scoping. Rearrange the methods.\n\t(nil): Ensure that this can be thread-safe, and make it a static\n\tfinal. Initialize it to be more useful as a sentinal node.\n\t(Node): Specify color in constructor.\n\t(deleteFixup, insertFixup): Improve comments and algorithm.\n\t(fabricateTree): Redesign with less overhead.\n\t(lowestGreaterThan): Add parameter first to make SubMap easier.\n\t(removeNode): Patch hole where nil was being modified. Choose\n\tpredecessor instead of successor so in-place swap works.\n\t(class VerifyResult, verifyTree, verifySub, verifyError): Remove\n\tthis dead code after verifying the class works.\n\t(class SubMap): Rewrite several algorithms to avoid problems with\n\tcomparing nil.\n\t* java/util/TreeSet.java: Improve javadoc. Fix some scoping.\n\t(clone): Fix ClassCastException when cloning subSet().\n\t(readObject, writeObject): Fix serialization.\n\t* java/util/WeakHashMap.java: Improve javadoc. Fix some scoping.\n\t(NULL_KEY): Make it compare as null, for ease elsewhere.\n\t(Class WeakEntry): Rename from Entry, to avoid shadowing\n\tMap.Entry. Add missing toString.\n\t(modCount): Ensure that this is updated correctly.\n\t(clear, containsValue, keySet, putAll, values, WeakHashMap(Map)):\n\tAdd missing methods and constructor.\n\n2001-12-15  Eric Blake  <ebb9@email.byu.edu>\n\n\t* java/util/ArrayList.java (checkBoundExclusive),\n\t(checkBoundInclusive): Rename from range??clusive, to match\n\tAbstractList.\n\t* java/util/LinkedList.java (checkBoundsExclusive),\n\t(checkBoundsInclusive): ditto\n\t* java/util/Vector.java (checkBoundExclusive),\n\t(checkBoundInclusive): Move bounds checking into common methods.\n\n2001-12-15  Eric Blake  <ebb9@email.byu.edu>\n\n\t* java/util/AbstractList.java:\n\t(modCount): Make sure it is updated in all needed places.\n\t* java/util/ArrayList.java: Improve javadoc. Implements\n\tRandomAccess. Add serialVersionUID. Reorder methods.\n\t(modCount): Make sure it is updated in all needed places.\n\t(rangeExclusive, rangeInclusive): Add common methods for bounds\n\tcheck.\n\t(isEmpty): Add missing method.\n\t* java/util/Collections.java: (class SynchronizedList): Make\n\tpackage visible.\n\t* java/util/ConcurrentModificationException.java: Improve\n\tjavadoc.\n\t* java/util/EmptyStackException.java: Improve javadoc.\n\t* java/util/LinkedList.java: Improve javadoc.\n\t(modCount): Make sure it is updated in all needed places.\n\t(rangeExclusive, rangeInclusive): Add common methods for bounds\n\tcheck.\n\t* java/util/NoSuchElementException.java: Improve javadoc.\n\t* java/util/Stack.java: Improve javadoc. Fix synchronization\n\tissues.\n\t(modCount): Make sure it is updated in all needed places.\n\t* java/util/Vector.java: Improve javadoc. Fix synchronization\n\tissues. Implements RandomAccess. Reorder methods.\n\t(modCount): Make sure it is updated in all needed places.\n\t(setSize): Fix according to specifications: this does not dictate\n\tthe backing array size.\n\t(removeAll, retainAll): Faster implementations.\n\n2001-12-15  Eric Blake  <ebb9@email.byu.edu>\n\n\t* java/util/BitSet.java: Improve javadoc.\n\t(cardinality(), clear(), clear(int, int), flip(int)),\n\t(flip(int, int), get(int, int), intersects(BitSet), isEmpty()),\n\t(nextClearBit(int), nextSetBit(int), set(int, boolean)),\n\t(set(int, int), set(int, int, boolean)): Add new JDK 1.4 methods.\n\t(clone): Fix so subclasses clone correctly.\n\n2001-12-15  Eric Blake  <ebb9@email.byu.edu>\n\n\t* java/util/AbstractCollection.java: Improve javadoc.\n\t(AbstractCollection()): Make constructor protected.\n\t(equals(Object, Object), hashCode(Object)): Add utility methods.\n\t* java/util/AbstractList.java: Improve javadoc.\n\t(AbstractList()): Make constructor protected.\n\t(indexOf(Object)): Call listIterator(), not listIterator(int).\n\t(iterator()): Follow Sun's requirement to not use listIterator(0).\n\t(listIterator(int)): Make AbstractListItr anonymous.\n\t(subList(int, int)): Add support for RandomAccess.\n\t(SubList.add(int, Object), SubList.remove(Object)): Fix bug with\n\tmodCount tracking.\n\t(SubList.addAll(Collection)): Add missing method.\n\t(SubList.listIterator(int)): Fix bugs in indexing, modCount\n\ttracking.\n\t(class RandomAccessSubList): Add new class.\n\t* java/util/AbstractMap.java: Improve javadoc.\n\t(keys, values, KEYS, VALUES, ENTRIES): Consolidate common map\n\tfields.\n\t(AbstractMap()): Make constructor protected.\n\t(equals(Object, Object), hashCode(Object)): Add utility methods.\n\t(equals(Object)): Change algorithm to\n\tentrySet().equals(m.entrySet()), as documented by Sun.\n\t(keySet(), values()): Cache the collections.\n\t* java/util/AbstractSequentialList.java: Improve javadoc.\n\t(AbstractSequentialList()): Make constructor protected.\n\t* java/util/AbstractSet.java: Improve javadoc.\n\t(AbstractSet()): Make constructor protected.\n\t(removeAll(Collection)): Add missing method.\n\t* java/util/Arrays.java: Improve javadoc, rearrange method orders.\n\t(defaultComparator): Remove, in favor of\n\tCollections.compare(Object, Object, Comparator).\n\t(binarySearch, equals, sort): Fix natural order comparison of\n\tfloats and doubles. Also improve Object comparison - when\n\tcomparator is null, use natural order.\n\t(fill, sort): Add missing checks for IllegalArgumentException.\n\t(sort, qsort): Fix sorting bugs, rework the code for more\n\tlegibility.\n\t(mergeSort): Inline into sort(Object[], int, int, Comparator).\n\t(class ArrayList): Rename from ListImpl, and make compatible with\n\tJDK serialization. Add methods which more efficiently override\n\tthose of AbstractList.\n\t* java/util/Collections: Improve javadoc.\n\t(isSequential(List)): Add and use a method for deciding between\n\tRandomAccess and sequential algorithms on lists.\n\t(class Empty*, class Synchronized*, class Unmodifiable*): Make\n\tcompliant with JDK serializability.\n\t(class Singleton*, class CopiesList, class RevereseComparator),\n\t(class UnmodifiableMap.UnmodifiableEntrySet),\n\t(class *RandomAccessList): New classes for serial compatibility.\n\t(class Empty*, class Singleton*, class CopiesList): Add methods\n\twhich more efficiently override those of Abstract*.\n\t(search): Inline into binarySearch(List, Object, Comparator).\n\t(binarySearch): Make sequential search only do log(n) comparisons,\n\tinstead of n.\n\t(copy(List, List)): Do bounds checking before starting.\n\t(indexOfSubList, lastIndexOfSubList, list, replaceAll, rotate),\n\t(swap):\tAdd new JDK 1.4 methods.\n\t(binarySearch, max, min, sort): Allow null comparator to represent\n\tnatural ordering.\n\t(reverse(List)): Avoid unnecessary swap.\n\t(shuffle(List, Random)): Do shuffle in-place for RandomAccess\n\tlists.\n\t(SingletonList.get): Fix logic bug.\n\t(SingletonMap.entrySet): Make the entry immutable, and cache the\n\treturned set.\n\t(SynchronizedCollection, SynchronizedMap, UnmodifiableCollection),\n\t(UnmodifiableMap): Detect null pointer in construction.\n\t(SynchronizedMap, UnmodifiableMap): Cache collection views.\n\t* java/util/BasicMapEntry: Improve javadoc.\n\nFrom-SVN: r48035", "tree": {"sha": "a0210bc88649e7cd6d847884e12a68146f35d955", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a0210bc88649e7cd6d847884e12a68146f35d955"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d9fd7154ec7908eff8bbbce75651eccf51064ac1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9fd7154ec7908eff8bbbce75651eccf51064ac1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9fd7154ec7908eff8bbbce75651eccf51064ac1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9fd7154ec7908eff8bbbce75651eccf51064ac1/comments", "author": null, "committer": null, "parents": [{"sha": "def9790d51a51a78a700567bb677225a90bc854e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/def9790d51a51a78a700567bb677225a90bc854e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/def9790d51a51a78a700567bb677225a90bc854e"}], "stats": {"total": 17658, "additions": 11486, "deletions": 6172}, "files": [{"sha": "3a3294cc366ab9bc367eee7c12d1a4e11d4f91e7", "filename": "libjava/ChangeLog", "status": "modified", "additions": 232, "deletions": 0, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=d9fd7154ec7908eff8bbbce75651eccf51064ac1", "patch": "@@ -1,4 +1,236 @@\n+2001-12-15  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>\n+\n+\t* java/util/BitSet.java (and): Fix off-by-one bug, don't skip part of\n+\tthe bitset.\n+\t(andNot): Likewise.\n+\t(xor): Likewise.\n+\n+2001-12-15  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>\n+\n+\t* java/util/LinkedList.java (LinkedListItr.add): Don't skip the next\n+\tentry.\n+\n+2001-12-15  Eric Blake  <ebb9@email.byu.edu>\n+\n+\t* java/util/TreeMap.java (removeNode): Fix bug in node removal.\n+\n+2001-12-15  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>\n+\n+\t* java/util/AbstractCollection.java (containsAll): Use size of the\n+\tcorrect collection for loop bound.\n+\t* java/util/AbstractList.java (iterator.next): Increment pos after\n+\tcalling get on backing list.\n+\t(listIterator.next): Likewise.\n+\t* java/util/LinkedList.java (addLastEntry): Don't increment size before\n+\tchecking for size == 0.\n+\t(addFirstEntry): Rearrange to match addLastEntry.\n+\t(add): Do not increment size before inserting the new entry.\n+\n+\t* java/util/AbstractCollection.java (addAll): Use size of the\n+\tcorrect collection for loop bound.\n+\n+2001-12-15  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>\n+\n+\t* java/util/AbstractSet.java (removeAll): Fix scoping thinko.\n+\t* java/util/HashMap.java (putAllInternal): Set size here.\n+\t* java/util/Hashtable.java (putAllInternal): New method. Copy contents\n+\tof a map efficiently without calling put() or putAll().\n+\t(Hashtable (map)): Use putAllInternal.\n+\t(clone): Likewise.\n+\n+2001-12-15  Eric Blake  <ebb9@email.byu.edu>\n+\n+\t* java/util/Collections.java:\n+\t* java/util/Vector.java:\n+\t* java/util/WeakHashMap.java: Fix spelling errors.\n+\n+2001-12-15  Eric Blake  <ebb9@email.byu.edu>\n+\n+\t* java/util/AbstractCollection.java (removeAllInternal),\n+\t(retainAllInternal): Add hooks for use by ArrayList.\n+\t* java/util/AbstractList.java: Minor code updates. Fix some\n+\tscoping.\n+\t* java/util/AbstractMap.java: ditto\n+\t* java/util/ArrayList.java (readObject, writeObject): ditto\n+\t(removeAllInternal, retainAllInternal): Optimize.\n+\t* java/util/Arrays.java: ditto\n+\t* java/util/Collections.java: ditto. Change order of parameters\n+\tto equals(Object, Object) to match specs.\n+\t* java/util/Dictionary.java: Improve javadoc.\n+\t(Dictionary): Add explicit constructor.\n+\t* java/util/HashMap.java: Improve javadoc. Rearrange methods to\n+\tfollow order in JDK. Cleanups related to recent code migration to\n+\tAbstractMap. Fix some scoping.\n+\t(entrySet): Cache the result.\n+\t(modCount): Ensure that this is updated correctly.\n+\t* java/util/HashSet.java: Improve javadoc. Fix some scoping.\n+\t(init): Add hooks for LinkedHashSet.\n+\t(map): Use \"\" instead of Boolean.TRUE in backing map. Use\n+\tpackage-private API where possible for less overhead.\n+\t(readObject, writeObject): Fix serialization.\n+\t* java/util/Hashtable.java: Improve javadoc. Fix some scoping.\n+\t(entrySet, keySet, values): Cache the result.\n+\t(modCount): Ensure that this is updated correctly.\n+\t(contains, remove): Fix NullPointer checking to match specs.\n+\t(class Enumeration): Make more like HashIterator.\n+\t* java/util/IdentityHashMap.java: Minor code updates.\n+\t(modCount): Ensure that this is updated correctly.\n+\t(readObject, writeObject): Fix serialization.\n+\t* java/util/LinkedHashMap.java: Minor code updates. Cleanups\n+\trelated to recent code migration to AbstractMap.\n+\t* java/util/LinkedHashSet.java: New file.\n+\t* java/util/LinkedList.java:\n+\t(readObject, writeObject): Fix serialization.\n+\t* java/util/Makefile.am: List recently added files.\n+\t* java/util/Stack.java: Minor code updates.\n+\t* java/util/TreeMap.java: Improve javadoc. Overhaul the class to\n+\tbe more efficient. Fix some scoping. Rearrange the methods.\n+\t(nil): Ensure that this can be thread-safe, and make it a static\n+\tfinal. Initialize it to be more useful as a sentinal node.\n+\t(Node): Specify color in constructor.\n+\t(deleteFixup, insertFixup): Improve comments and algorithm.\n+\t(fabricateTree): Redesign with less overhead.\n+\t(lowestGreaterThan): Add parameter first to make SubMap easier.\n+\t(removeNode): Patch hole where nil was being modified. Choose\n+\tpredecessor instead of successor so in-place swap works.\n+\t(class VerifyResult, verifyTree, verifySub, verifyError): Remove\n+\tthis dead code after verifying the class works.\n+\t(class SubMap): Rewrite several algorithms to avoid problems with\n+\tcomparing nil.\n+\t* java/util/TreeSet.java: Improve javadoc. Fix some scoping.\n+\t(clone): Fix ClassCastException when cloning subSet().\n+\t(readObject, writeObject): Fix serialization.\n+\t* java/util/WeakHashMap.java: Improve javadoc. Fix some scoping.\n+\t(NULL_KEY): Make it compare as null, for ease elsewhere.\n+\t(Class WeakEntry): Rename from Entry, to avoid shadowing\n+\tMap.Entry. Add missing toString.\n+\t(modCount): Ensure that this is updated correctly.\n+\t(clear, containsValue, keySet, putAll, values, WeakHashMap(Map)):\n+\tAdd missing methods and constructor.\n+\n+2001-12-15  Eric Blake  <ebb9@email.byu.edu>\n+\n+\t* java/util/ArrayList.java (checkBoundExclusive),\n+\t(checkBoundInclusive): Rename from range??clusive, to match\n+\tAbstractList.\n+\t* java/util/LinkedList.java (checkBoundsExclusive),\n+\t(checkBoundsInclusive): ditto\n+\t* java/util/Vector.java (checkBoundExclusive),\n+\t(checkBoundInclusive): Move bounds checking into common methods.\n+\n+2001-12-15  Eric Blake  <ebb9@email.byu.edu>\n+\n+\t* java/util/AbstractList.java:\n+\t(modCount): Make sure it is updated in all needed places.\n+\t* java/util/ArrayList.java: Improve javadoc. Implements\n+\tRandomAccess. Add serialVersionUID. Reorder methods.\n+\t(modCount): Make sure it is updated in all needed places.\n+\t(rangeExclusive, rangeInclusive): Add common methods for bounds\n+\tcheck.\n+\t(isEmpty): Add missing method.\n+\t* java/util/Collections.java: (class SynchronizedList): Make\n+\tpackage visible.\n+\t* java/util/ConcurrentModificationException.java: Improve\n+\tjavadoc.\n+\t* java/util/EmptyStackException.java: Improve javadoc.\n+\t* java/util/LinkedList.java: Improve javadoc.\n+\t(modCount): Make sure it is updated in all needed places.\n+\t(rangeExclusive, rangeInclusive): Add common methods for bounds\n+\tcheck.\n+\t* java/util/NoSuchElementException.java: Improve javadoc.\n+\t* java/util/Stack.java: Improve javadoc. Fix synchronization\n+\tissues.\n+\t(modCount): Make sure it is updated in all needed places.\n+\t* java/util/Vector.java: Improve javadoc. Fix synchronization\n+\tissues. Implements RandomAccess. Reorder methods.\n+\t(modCount): Make sure it is updated in all needed places.\n+\t(setSize): Fix according to specifications: this does not dictate\n+\tthe backing array size.\n+\t(removeAll, retainAll): Faster implementations.\n+\n+2001-12-15  Eric Blake  <ebb9@email.byu.edu>\n+\n+\t* java/util/BitSet.java: Improve javadoc.\n+\t(cardinality(), clear(), clear(int, int), flip(int)),\n+\t(flip(int, int), get(int, int), intersects(BitSet), isEmpty()),\n+\t(nextClearBit(int), nextSetBit(int), set(int, boolean)),\n+\t(set(int, int), set(int, int, boolean)): Add new JDK 1.4 methods.\n+\t(clone): Fix so subclasses clone correctly.\n+\n+2001-12-15  Eric Blake  <ebb9@email.byu.edu>\n+\n+\t* java/util/AbstractCollection.java: Improve javadoc.\n+\t(AbstractCollection()): Make constructor protected.\n+\t(equals(Object, Object), hashCode(Object)): Add utility methods.\n+\t* java/util/AbstractList.java: Improve javadoc.\n+\t(AbstractList()): Make constructor protected.\n+\t(indexOf(Object)): Call listIterator(), not listIterator(int).\n+\t(iterator()): Follow Sun's requirement to not use listIterator(0).\n+\t(listIterator(int)): Make AbstractListItr anonymous.\n+\t(subList(int, int)): Add support for RandomAccess.\n+\t(SubList.add(int, Object), SubList.remove(Object)): Fix bug with\n+\tmodCount tracking.\n+\t(SubList.addAll(Collection)): Add missing method.\n+\t(SubList.listIterator(int)): Fix bugs in indexing, modCount\n+\ttracking.\n+\t(class RandomAccessSubList): Add new class.\n+\t* java/util/AbstractMap.java: Improve javadoc.\n+\t(keys, values, KEYS, VALUES, ENTRIES): Consolidate common map\n+\tfields.\n+\t(AbstractMap()): Make constructor protected.\n+\t(equals(Object, Object), hashCode(Object)): Add utility methods.\n+\t(equals(Object)): Change algorithm to\n+\tentrySet().equals(m.entrySet()), as documented by Sun.\n+\t(keySet(), values()): Cache the collections.\n+\t* java/util/AbstractSequentialList.java: Improve javadoc.\n+\t(AbstractSequentialList()): Make constructor protected.\n+\t* java/util/AbstractSet.java: Improve javadoc.\n+\t(AbstractSet()): Make constructor protected.\n+\t(removeAll(Collection)): Add missing method.\n+\t* java/util/Arrays.java: Improve javadoc, rearrange method orders.\n+\t(defaultComparator): Remove, in favor of\n+\tCollections.compare(Object, Object, Comparator).\n+\t(binarySearch, equals, sort): Fix natural order comparison of\n+\tfloats and doubles. Also improve Object comparison - when\n+\tcomparator is null, use natural order.\n+\t(fill, sort): Add missing checks for IllegalArgumentException.\n+\t(sort, qsort): Fix sorting bugs, rework the code for more\n+\tlegibility.\n+\t(mergeSort): Inline into sort(Object[], int, int, Comparator).\n+\t(class ArrayList): Rename from ListImpl, and make compatible with\n+\tJDK serialization. Add methods which more efficiently override\n+\tthose of AbstractList.\n+\t* java/util/Collections: Improve javadoc.\n+\t(isSequential(List)): Add and use a method for deciding between\n+\tRandomAccess and sequential algorithms on lists.\n+\t(class Empty*, class Synchronized*, class Unmodifiable*): Make\n+\tcompliant with JDK serializability.\n+\t(class Singleton*, class CopiesList, class RevereseComparator),\n+\t(class UnmodifiableMap.UnmodifiableEntrySet),\n+\t(class *RandomAccessList): New classes for serial compatibility.\n+\t(class Empty*, class Singleton*, class CopiesList): Add methods\n+\twhich more efficiently override those of Abstract*.\n+\t(search): Inline into binarySearch(List, Object, Comparator).\n+\t(binarySearch): Make sequential search only do log(n) comparisons,\n+\tinstead of n.\n+\t(copy(List, List)): Do bounds checking before starting.\n+\t(indexOfSubList, lastIndexOfSubList, list, replaceAll, rotate),\n+\t(swap):\tAdd new JDK 1.4 methods.\n+\t(binarySearch, max, min, sort): Allow null comparator to represent\n+\tnatural ordering.\n+\t(reverse(List)): Avoid unnecessary swap.\n+\t(shuffle(List, Random)): Do shuffle in-place for RandomAccess\n+\tlists.\n+\t(SingletonList.get): Fix logic bug.\n+\t(SingletonMap.entrySet): Make the entry immutable, and cache the\n+\treturned set.\n+\t(SynchronizedCollection, SynchronizedMap, UnmodifiableCollection),\n+\t(UnmodifiableMap): Detect null pointer in construction.\n+\t(SynchronizedMap, UnmodifiableMap): Cache collection views.\n+\t* java/util/BasicMapEntry: Improve javadoc.\n+\n 2001-12-14  Hans Boehm  <Hans_Boehm@hp.com>\n+\n \t* libjava/prims.cc: Some old cleanups.  The collector now\n \thandles test for out of memory.\n "}, {"sha": "277995b37049e16542317ac79150be731d1d414d", "filename": "libjava/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=d9fd7154ec7908eff8bbbce75651eccf51064ac1", "patch": "@@ -1200,6 +1200,7 @@ java/util/IdentityHashMap.java \\\n java/util/Iterator.java\t\\\n java/util/LinkedList.java \\\n java/util/LinkedHashMap.java \\\n+java/util/LinkedHashSet.java \\\n java/util/List.java \\\n java/util/ListIterator.java \\\n java/util/ListResourceBundle.java \\"}, {"sha": "57471773dd38a69542d3bed3a113dfccc384a4a4", "filename": "libjava/Makefile.in", "status": "modified", "additions": 24, "deletions": 37, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=d9fd7154ec7908eff8bbbce75651eccf51064ac1", "patch": "@@ -123,40 +123,28 @@ libgcj_basedir = @libgcj_basedir@\n mkinstalldirs = @mkinstalldirs@\n \n AUTOMAKE_OPTIONS = foreign\n-@TESTSUBDIR_TRUE@SUBDIRS = \\\n-@TESTSUBDIR_TRUE@$(DIRLTDL) testsuite gcj include\n-@TESTSUBDIR_FALSE@SUBDIRS = \\\n-@TESTSUBDIR_FALSE@$(DIRLTDL) gcj include\n-@USE_LIBDIR_TRUE@toolexeclibdir = \\\n-@USE_LIBDIR_TRUE@$(libdir)$(MULTISUBDIR)\n-@USE_LIBDIR_FALSE@toolexeclibdir = \\\n-@USE_LIBDIR_FALSE@$(toolexecdir)/lib$(MULTISUBDIR)\n-@USE_LIBDIR_FALSE@toolexecdir = \\\n-@USE_LIBDIR_FALSE@$(exec_prefix)/$(target_alias)\n-@XLIB_AWT_TRUE@cond_x_ltlibrary = \\\n-@XLIB_AWT_TRUE@libgcjx.la\n-@XLIB_AWT_FALSE@cond_x_ltlibrary = \\\n+@TESTSUBDIR_TRUE@SUBDIRS = @TESTSUBDIR_TRUE@$(DIRLTDL) testsuite gcj include\n+@TESTSUBDIR_FALSE@SUBDIRS = @TESTSUBDIR_FALSE@$(DIRLTDL) gcj include\n+@USE_LIBDIR_TRUE@toolexeclibdir = @USE_LIBDIR_TRUE@$(libdir)$(MULTISUBDIR)\n+@USE_LIBDIR_FALSE@toolexeclibdir = @USE_LIBDIR_FALSE@$(toolexecdir)/lib$(MULTISUBDIR)\n+@USE_LIBDIR_FALSE@toolexecdir = @USE_LIBDIR_FALSE@$(exec_prefix)/$(target_alias)\n+@XLIB_AWT_TRUE@cond_x_ltlibrary = @XLIB_AWT_TRUE@libgcjx.la\n+@XLIB_AWT_FALSE@cond_x_ltlibrary = \n \n toolexeclib_LTLIBRARIES = libgcj.la $(cond_x_ltlibrary)\n toolexeclib_DATA = libgcj.spec\n data_DATA = libgcj.jar\n \n secdir = $(libdir)/security\n \n-@NATIVE_TRUE@bin_PROGRAMS = \\\n-@NATIVE_TRUE@jv-convert gij rmic rmiregistry\n+@NATIVE_TRUE@bin_PROGRAMS = @NATIVE_TRUE@jv-convert gij rmic rmiregistry\n \n bin_SCRIPTS = addr2name.awk\n-@CANADIAN_TRUE@@NULL_TARGET_TRUE@ZIP = \\\n-@CANADIAN_TRUE@@NULL_TARGET_TRUE@$(MULTIBUILDTOP)../$(COMPPATH)/fastjar/jar$(EXEEXT)\n-@CANADIAN_TRUE@@NULL_TARGET_FALSE@ZIP = \\\n-@CANADIAN_TRUE@@NULL_TARGET_FALSE@jar\n-@CANADIAN_FALSE@ZIP = \\\n-@CANADIAN_FALSE@$(MULTIBUILDTOP)../$(COMPPATH)/fastjar/jar$(EXEEXT)\n-@CANADIAN_TRUE@GCJH = \\\n-@CANADIAN_TRUE@gcjh\n-@CANADIAN_FALSE@GCJH = \\\n-@CANADIAN_FALSE@$(MULTIBUILDTOP)../$(COMPPATH)/gcc/gcjh$(EXEEXT)\n+@CANADIAN_TRUE@@NULL_TARGET_TRUE@ZIP = @CANADIAN_TRUE@@NULL_TARGET_TRUE@$(MULTIBUILDTOP)../$(COMPPATH)/fastjar/jar$(EXEEXT)\n+@CANADIAN_TRUE@@NULL_TARGET_FALSE@ZIP = @CANADIAN_TRUE@@NULL_TARGET_FALSE@jar\n+@CANADIAN_FALSE@ZIP = @CANADIAN_FALSE@$(MULTIBUILDTOP)../$(COMPPATH)/fastjar/jar$(EXEEXT)\n+@CANADIAN_TRUE@GCJH = @CANADIAN_TRUE@gcjh\n+@CANADIAN_FALSE@GCJH = @CANADIAN_FALSE@$(MULTIBUILDTOP)../$(COMPPATH)/gcc/gcjh$(EXEEXT)\n \n GCJ_WITH_FLAGS = $(GCJ) --encoding=UTF-8\n \n@@ -176,10 +164,8 @@ AM_CXXFLAGS = -fno-rtti -fnon-call-exceptions \\\n \t@LIBGCJ_CXXFLAGS@ @X_CFLAGS@ $(WARNINGS) -D_GNU_SOURCE \\\n \t-DPREFIX=\"\\\"$(prefix)\\\"\"\n \n-@USING_GCC_TRUE@AM_CFLAGS = \\\n-@USING_GCC_TRUE@@LIBGCJ_CFLAGS@ $(WARNINGS)\n-@USING_GCC_FALSE@AM_CFLAGS = \\\n-@USING_GCC_FALSE@@LIBGCJ_CFLAGS@\n+@USING_GCC_TRUE@AM_CFLAGS = @USING_GCC_TRUE@@LIBGCJ_CFLAGS@ $(WARNINGS)\n+@USING_GCC_FALSE@AM_CFLAGS = @USING_GCC_FALSE@@LIBGCJ_CFLAGS@\n \n JCFLAGS = -g\n JC1FLAGS = @LIBGCJ_JAVAFLAGS@ $(GCJFLAGS)\n@@ -252,8 +238,7 @@ extra_headers = java/lang/Object.h java/lang/Class.h\n \n NM = nm\n \n-@NATIVE_TRUE@@MAINTAINER_MODE_TRUE@noinst_PROGRAMS = \\\n-@NATIVE_TRUE@@MAINTAINER_MODE_TRUE@gen-from-JIS\n+@NATIVE_TRUE@@MAINTAINER_MODE_TRUE@noinst_PROGRAMS = @NATIVE_TRUE@@MAINTAINER_MODE_TRUE@gen-from-JIS\n \n CONVERT_DIR = gnu/gcj/convert\n \n@@ -950,6 +935,7 @@ java/util/IdentityHashMap.java \\\n java/util/Iterator.java\t\\\n java/util/LinkedList.java \\\n java/util/LinkedHashMap.java \\\n+java/util/LinkedHashSet.java \\\n java/util/List.java \\\n java/util/ListIterator.java \\\n java/util/ListResourceBundle.java \\\n@@ -1585,7 +1571,7 @@ libgcj-test.spec.in libgcj.spec.in\n \n DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)\n \n-TAR = tar\n+TAR = gtar\n GZIP_ENV = --best\n DIST_SUBDIRS =  @DIRLTDL@ testsuite gcj include @DIRLTDL@ gcj include\n DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n@@ -2224,10 +2210,11 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/util/GregorianCalendar.P .deps/java/util/HashMap.P \\\n .deps/java/util/HashSet.P .deps/java/util/Hashtable.P \\\n .deps/java/util/IdentityHashMap.P .deps/java/util/Iterator.P \\\n-.deps/java/util/LinkedHashMap.P .deps/java/util/LinkedList.P \\\n-.deps/java/util/List.P .deps/java/util/ListIterator.P \\\n-.deps/java/util/ListResourceBundle.P .deps/java/util/Locale.P \\\n-.deps/java/util/Map.P .deps/java/util/MissingResourceException.P \\\n+.deps/java/util/LinkedHashMap.P .deps/java/util/LinkedHashSet.P \\\n+.deps/java/util/LinkedList.P .deps/java/util/List.P \\\n+.deps/java/util/ListIterator.P .deps/java/util/ListResourceBundle.P \\\n+.deps/java/util/Locale.P .deps/java/util/Map.P \\\n+.deps/java/util/MissingResourceException.P \\\n .deps/java/util/NoSuchElementException.P .deps/java/util/Observable.P \\\n .deps/java/util/Observer.P .deps/java/util/Properties.P \\\n .deps/java/util/PropertyPermission.P \\\n@@ -2735,7 +2722,7 @@ distdir: $(DISTFILES)\n \t@for file in $(DISTFILES); do \\\n \t  d=$(srcdir); \\\n \t  if test -d $$d/$$file; then \\\n-\t    cp -pr $$/$$file $(distdir)/$$file; \\\n+\t    cp -pr $$d/$$file $(distdir)/$$file; \\\n \t  else \\\n \t    test -f $(distdir)/$$file \\\n \t    || ln $$d/$$file $(distdir)/$$file 2> /dev/null \\"}, {"sha": "095e1c418808a9e0d22cc411e4a8bcf97c57f24c", "filename": "libjava/java/util/AbstractCollection.java", "status": "modified", "additions": 224, "deletions": 118, "changes": 342, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2Fjava%2Futil%2FAbstractCollection.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2Fjava%2Futil%2FAbstractCollection.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FAbstractCollection.java?ref=d9fd7154ec7908eff8bbbce75651eccf51064ac1", "patch": "@@ -1,5 +1,5 @@\n /* AbstractCollection.java -- Abstract implementation of most of Collection\n-   Copyright (C) 1998, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 2000, 2001 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -42,77 +42,119 @@\n  * backing data structure allows for a more efficient implementation. The\n  * precise implementation used by AbstractCollection is documented, so that\n  * subclasses can tell which methods could be implemented more efficiently.\n+ * <p>\n+ *\n+ * The programmer should provide a no-argument constructor, and one that\n+ * accepts another Collection, as recommended by the Collection interface.\n+ * Unfortunately, there is no way to enforce this in Java.\n+ *\n+ * @author Original author unknown\n+ * @author Bryce McKinlay\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @see Collection\n+ * @see AbstractSet\n+ * @see AbstractList\n+ * @since 1.2\n+ * @status updated to 1.4\n  */\n public abstract class AbstractCollection implements Collection\n {\n+  /**\n+   * The main constructor, for use by subclasses.\n+   */\n+  protected AbstractCollection()\n+  {\n+  }\n+\n   /**\n    * Return an Iterator over this collection. The iterator must provide the\n    * hasNext and next methods and should in addition provide remove if the\n    * collection is modifiable.\n+   *\n+   * @return an iterator\n    */\n   public abstract Iterator iterator();\n \n   /**\n-   * Return the number of elements in this collection.\n+   * Return the number of elements in this collection. If there are more than\n+   * Integer.MAX_VALUE elements, return Integer.MAX_VALUE.\n+   *\n+   * @return the size\n    */\n   public abstract int size();\n \n   /**\n-   * Add an object to the collection. This implementation always throws an\n-   * UnsupportedOperationException - it should be overridden if the collection\n-   * is to be modifiable.\n+   * Add an object to the collection (optional operation). This implementation\n+   * always throws an UnsupportedOperationException - it should be\n+   * overridden if the collection is to be modifiable. If the collection\n+   * does not accept duplicates, simply return false. Collections may specify\n+   * limitations on what may be added.\n    *\n    * @param o the object to add\n    * @return true if the add operation caused the Collection to change\n-   * @exception UnsupportedOperationException if the add operation is not\n-   *   supported on this collection\n+   * @throws UnsupportedOperationException if the add operation is not\n+   *         supported on this collection\n+   * @throws NullPointerException if the collection does not support null\n+   * @throws ClassCastException if the object is of the wrong type\n+   * @throws IllegalArgumentException if some aspect of the object prevents\n+   *         it from being added\n    */\n   public boolean add(Object o)\n   {\n-    throw new java.lang.UnsupportedOperationException();\n+    throw new UnsupportedOperationException();\n   }\n \n   /**\n-   * Add all the elements of a given collection to this collection. This\n-   * implementation obtains an Iterator over the given collection and iterates\n-   * over it, adding each element with the add(Object) method (thus this method\n-   * will fail with an UnsupportedOperationException if the add method does).\n+   * Add all the elements of a given collection to this collection (optional\n+   * operation). This implementation obtains an Iterator over the given\n+   * collection and iterates over it, adding each element with the\n+   * add(Object) method (thus this method will fail with an\n+   * UnsupportedOperationException if the add method does). The behavior is\n+   * unspecified if the specified collection is modified during the iteration,\n+   * including the special case of trying addAll(this) on a non-empty\n+   * collection.\n    *\n    * @param c the collection to add the elements of to this collection\n    * @return true if the add operation caused the Collection to change\n-   * @exception UnsupportedOperationException if the add operation is not\n-   *   supported on this collection\n+   * @throws UnsupportedOperationException if the add operation is not\n+   *         supported on this collection\n+   * @throws NullPointerException if this collection does not support null,\n+   *         or if the specified collection is null\n+   * @throws ClassCastException if an object in c is of the wrong type\n+   * @throws IllegalArgumentException if some aspect of an object in c prevents\n+   *         it from being added\n+   * @see #add(Object)\n    */\n   public boolean addAll(Collection c)\n   {\n     Iterator itr = c.iterator();\n-    int size = c.size();\n     boolean modified = false;\n-    for (int pos = 0; pos < size; pos++)\n-      {\n-\tmodified |= add(itr.next());\n-      }\n+    int pos = c.size();\n+    while (--pos >= 0)\n+      modified |= add(itr.next());\n     return modified;\n   }\n \n   /**\n-   * Remove all elements from the collection. This implementation obtains an\n-   * iterator over the collection and calls next and remove on it repeatedly\n-   * (thus this method will fail with an UnsupportedOperationException if the\n-   * Iterator's remove method does) until there are no more elements to remove.\n+   * Remove all elements from the collection (optional operation). This\n+   * implementation obtains an iterator over the collection and calls next\n+   * and remove on it repeatedly (thus this method will fail with an\n+   * UnsupportedOperationException if the Iterator's remove method does)\n+   * until there are no more elements to remove.\n    * Many implementations will have a faster way of doing this.\n    *\n-   * @exception UnsupportedOperationException if the Iterator returned by\n-   *   iterator does not provide an implementation of remove\n+   * @throws UnsupportedOperationException if the Iterator returned by\n+   *         iterator does not provide an implementation of remove\n+   * @see Iterator#remove()\n    */\n   public void clear()\n   {\n     Iterator itr = iterator();\n-    int size = size();\n-    for (int pos = 0; pos < size; pos++)\n+    int pos = size();\n+    while (--pos >= 0)\n       {\n-\titr.next();\n-\titr.remove();\n+        itr.next();\n+        itr.remove();\n       }\n   }\n \n@@ -130,12 +172,10 @@ public void clear()\n   public boolean contains(Object o)\n   {\n     Iterator itr = iterator();\n-    int size = size();\n-    for (int pos = 0; pos < size; pos++)\n-      {\n-\tif (o == null ? itr.next() == null : o.equals(itr.next()))\n-\t  return true;\n-      }\n+    int pos = size();\n+    while (--pos >= 0)\n+      if (equals(o, itr.next()))\n+        return true;\n     return false;\n   }\n \n@@ -147,17 +187,17 @@ public boolean contains(Object o)\n    *\n    * @param c the collection to test against\n    * @return true if this collection contains all the elements in the given\n-   *   collection\n+   *         collection\n+   * @throws NullPointerException if the given collection is null\n+   * @see #contains(Object)\n    */\n   public boolean containsAll(Collection c)\n   {\n     Iterator itr = c.iterator();\n-    int size = c.size();\n-    for (int pos = 0; pos < size; pos++)\n-      {\n-\tif (!contains(itr.next()))\n-\t  return false;\n-      }\n+    int pos = c.size();\n+    while (--pos >= 0)\n+      if (!contains(itr.next()))\n+        return false;\n     return true;\n   }\n \n@@ -166,118 +206,158 @@ public boolean containsAll(Collection c)\n    * size() == 0.\n    *\n    * @return true if this collection is empty.\n+   * @see #size()\n    */\n   public boolean isEmpty()\n   {\n     return size() == 0;\n   }\n \n   /**\n-   * Remove a single instance of an object from this collection. That is,\n-   * remove one element e such that (o == null ? e == null : o.equals(e)), if\n-   * such an element exists. This implementation obtains an iterator over the\n-   * collection and iterates over it, testing each element for equality with\n-   * the given object. If it is equal, it is removed by the iterator's remove\n-   * method (thus this method will fail with an UnsupportedOperationException\n-   * if the Iterator's remove method does). After the first element has been\n+   * Remove a single instance of an object from this collection (optional\n+   * operation). That is, remove one element e such that\n+   * <code>(o == null ? e == null : o.equals(e))</code>, if such an element\n+   * exists. This implementation obtains an iterator over the collection\n+   * and iterates over it, testing each element for equality with the given\n+   * object. If it is equal, it is removed by the iterator's remove method\n+   * (thus this method will fail with an UnsupportedOperationException if\n+   * the Iterator's remove method does). After the first element has been\n    * removed, true is returned; if the end of the collection is reached, false\n    * is returned.\n    *\n    * @param o the object to remove from this collection\n    * @return true if the remove operation caused the Collection to change, or\n-   *   equivalently if the collection did contain o.\n-   * @exception UnsupportedOperationException if this collection's Iterator\n-   *   does not support the remove method\n+   *         equivalently if the collection did contain o.\n+   * @throws UnsupportedOperationException if this collection's Iterator\n+   *         does not support the remove method\n+   * @see Iterator#remove()\n    */\n   public boolean remove(Object o)\n   {\n     Iterator itr = iterator();\n-    int size = size();\n-    for (int pos = 0; pos < size; pos++)\n-      {\n-\tif (o == null ? itr.next() == null : o.equals(itr.next()))\n-\t  {\n-\t    itr.remove();\n-\t    return true;\n-\t  }\n-      }\n+    int pos = size();\n+    while (--pos >= 0)\n+      if (equals(o, itr.next()))\n+        {\n+          itr.remove();\n+          return true;\n+        }\n     return false;\n   }\n \n   /**\n    * Remove from this collection all its elements that are contained in a given\n-   * collection. This implementation iterates over this collection, and for\n-   * each element tests if it is contained in the given collection. If so, it\n-   * is removed by the Iterator's remove method (thus this method will fail\n-   * with an UnsupportedOperationException if the Iterator's remove method\n-   * does).\n+   * collection (optional operation). This implementation iterates over this\n+   * collection, and for each element tests if it is contained in the given\n+   * collection. If so, it is removed by the Iterator's remove method (thus\n+   * this method will fail with an UnsupportedOperationException if the\n+   * Iterator's remove method does).\n    *\n    * @param c the collection to remove the elements of\n    * @return true if the remove operation caused the Collection to change\n-   * @exception UnsupportedOperationException if this collection's Iterator\n-   *   does not support the remove method\n+   * @throws UnsupportedOperationException if this collection's Iterator\n+   *         does not support the remove method\n+   * @see Iterator#remove()\n    */\n   public boolean removeAll(Collection c)\n+  {\n+    return removeAllInternal(c);\n+  }\n+\n+  /**\n+   * Remove from this collection all its elements that are contained in a given\n+   * collection (optional operation). This implementation iterates over this\n+   * collection, and for each element tests if it is contained in the given\n+   * collection. If so, it is removed by the Iterator's remove method (thus\n+   * this method will fail with an UnsupportedOperationException if the\n+   * Iterator's remove method does). This method is necessary for ArrayList,\n+   * which cannot publicly override removeAll but can optimize this call.\n+   *\n+   * @param c the collection to remove the elements of\n+   * @return true if the remove operation caused the Collection to change\n+   * @throws UnsupportedOperationException if this collection's Iterator\n+   *         does not support the remove method\n+   * @see Iterator#remove()\n+   */\n+  boolean removeAllInternal(Collection c)\n   {\n     Iterator itr = iterator();\n-    int size = size();\n     boolean modified = false;\n-    for (int pos = 0; pos < size; pos++)\n-      {\n-\tif (c.contains(itr.next()))\n-\t  {\n-\t    itr.remove();\n-\t    modified = true;\n-\t  }\n-      }\n+    int pos = size();\n+    while (--pos >= 0)\n+      if (c.contains(itr.next()))\n+        {\n+          itr.remove();\n+          modified = true;\n+        }\n     return modified;\n   }\n \n   /**\n    * Remove from this collection all its elements that are not contained in a\n-   * given collection. This implementation iterates over this collection, and\n-   * for each element tests if it is contained in the given collection. If not,\n-   * it is removed by the Iterator's remove method (thus this method will fail\n-   * with an UnsupportedOperationException if the Iterator's remove method\n-   * does).\n+   * given collection (optional operation). This implementation iterates over\n+   * this collection, and for each element tests if it is contained in the\n+   * given collection. If not, it is removed by the Iterator's remove method\n+   * (thus this method will fail with an UnsupportedOperationException if\n+   * the Iterator's remove method does).\n    *\n    * @param c the collection to retain the elements of\n    * @return true if the remove operation caused the Collection to change\n-   * @exception UnsupportedOperationException if this collection's Iterator\n-   *   does not support the remove method\n+   * @throws UnsupportedOperationException if this collection's Iterator\n+   *         does not support the remove method\n+   * @see Iterator#remove()\n    */\n   public boolean retainAll(Collection c)\n+  {\n+    return retainAllInternal(c);\n+  }\n+\n+  /**\n+   * Remove from this collection all its elements that are not contained in a\n+   * given collection (optional operation). This implementation iterates over\n+   * this collection, and for each element tests if it is contained in the\n+   * given collection. If not, it is removed by the Iterator's remove method\n+   * (thus this method will fail with an UnsupportedOperationException if\n+   * the Iterator's remove method does). This method is necessary for\n+   * ArrayList, which cannot publicly override retainAll but can optimize\n+   * this call.\n+   *\n+   * @param c the collection to retain the elements of\n+   * @return true if the remove operation caused the Collection to change\n+   * @throws UnsupportedOperationException if this collection's Iterator\n+   *         does not support the remove method\n+   * @see Iterator#remove()\n+   */\n+  boolean retainAllInternal(Collection c)\n   {\n     Iterator itr = iterator();\n-    int size = size();\n     boolean modified = false;\n-    for (int pos = 0; pos < size; pos++)\n-      {\n-\tif (!c.contains(itr.next()))\n-\t  {\n-\t    itr.remove();\n-\t    modified = true;\n-\t  }\n-      }\n+    int pos = size();\n+    while (--pos >= 0)\n+      if (!c.contains(itr.next()))\n+        {\n+          itr.remove();\n+          modified = true;\n+        }\n     return modified;\n   }\n \n   /**\n    * Return an array containing the elements of this collection. This\n    * implementation creates an Object array of size size() and then iterates\n    * over the collection, setting each element of the array from the value\n-   * returned by the iterator.\n+   * returned by the iterator. The returned array is safe, and is not backed\n+   * by the collection.\n    *\n    * @return an array containing the elements of this collection\n    */\n   public Object[] toArray()\n   {\n     Iterator itr = iterator();\n-    Object[]a = new Object[size()];\n-    for (int pos = 0; pos < a.length; pos++)\n-      {\n-\ta[pos] = itr.next();\n-      }\n+    int size = size();\n+    Object[] a = new Object[size];\n+    for (int pos = 0; pos < size; pos++)\n+      a[pos] = itr.next();\n     return a;\n   }\n \n@@ -293,29 +373,29 @@ public Object[] toArray()\n    * obtained over the collection and the elements are placed in the array as\n    * they are returned by the iterator. Finally the first spare element, if\n    * any, of the array is set to null, and the created array is returned.\n+   * The returned array is safe; it is not backed by the collection. Note that\n+   * null may not mark the last element, if the collection allows null\n+   * elements.\n    *\n    * @param a the array to copy into, or of the correct run-time type\n    * @return the array that was produced\n-   * @exception ClassCastException if the type of the array precludes holding\n-   *   one of the elements of the Collection\n+   * @throws NullPointerException if the given array is null\n+   * @throws ArrayStoreException if the type of the array precludes holding\n+   *         one of the elements of the Collection\n    */\n-  public Object[] toArray(Object[]a)\n+  public Object[] toArray(Object[] a)\n   {\n     int size = size();\n     if (a.length < size)\n-      {\n-\ta = (Object[])Array.newInstance(a.getClass().getComponentType(),\n-\t\t\t\t\tsize);\n-      }\n+      a = (Object[]) Array.newInstance(a.getClass().getComponentType(),\n+                                       size);\n+    else if (a.length > size)\n+      a[size] = null;\n+\n     Iterator itr = iterator();\n     for (int pos = 0; pos < size; pos++)\n-      {\n-\ta[pos] = itr.next();\n-      }\n-    if (a.length > size)\n-      {\n-\ta[size] = null;\n-      }\n+      a[pos] = itr.next();\n+\n     return a;\n   }\n \n@@ -331,15 +411,41 @@ public Object[] toArray(Object[]a)\n   public String toString()\n   {\n     Iterator itr = iterator();\n-    int size = size();\n     StringBuffer r = new StringBuffer(\"[\");\n-    for (int pos = 0; pos < size; pos++)\n+    for (int pos = size(); pos > 0; pos--)\n       {\n-\tr.append(itr.next());\n-\tif (pos < size - 1)\n-\t  r.append(\", \");\n+        r.append(itr.next());\n+        if (pos > 1)\n+          r.append(\", \");\n       }\n     r.append(\"]\");\n     return r.toString();\n   }\n+\n+  /**\n+   * Compare two objects according to Collection semantics.\n+   *\n+   * @param o1 the first object\n+   * @param o2 the second object\n+   * @return o1 == null ? o2 == null : o1.equals(o2)\n+   */\n+  // Package visible for use throughout java.util.\n+  // It may be inlined since it is final.\n+  static final boolean equals(Object o1, Object o2)\n+  {\n+    return o1 == null ? o2 == null : o1.equals(o2);\n+  }\n+\n+  /**\n+   * Hash an object according to Collection semantics.\n+   *\n+   * @param o the object to hash\n+   * @return o1 == null ? 0 : o1.hashCode()\n+   */\n+  // Package visible for use throughout java.util.\n+  // It may be inlined since it is final.\n+  static final int hashCode(Object o)\n+  {\n+    return o == null ? 0 : o.hashCode();\n+  }\n }"}, {"sha": "714f92a7bc4a296fd09f394c8ab7d51012b3a384", "filename": "libjava/java/util/AbstractList.java", "status": "modified", "additions": 595, "deletions": 214, "changes": 809, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2Fjava%2Futil%2FAbstractList.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2Fjava%2Futil%2FAbstractList.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FAbstractList.java?ref=d9fd7154ec7908eff8bbbce75651eccf51064ac1", "patch": "@@ -1,5 +1,5 @@\n /* AbstractList.java -- Abstract implementation of most of List\n-   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -25,67 +25,192 @@\n executable file might be covered by the GNU General Public License. */\n \n \n-// TO DO:\n-// ~ Doc comments for almost everything.\n-// ~ Better general commenting\n-\n package java.util;\n \n /**\n  * A basic implementation of most of the methods in the List interface to make\n- * it easier to create a List based on a random-access data structure. To\n- * create an unmodifiable list, it is only necessary to override the size() and\n- * get(int) methods (this contrasts with all other abstract collection classes\n- * which require an iterator to be provided). To make the list modifiable, the\n- * set(int, Object)  method should also be overridden, and to make the list\n- * resizable, the add(int, Object) and remove(int) methods should be overridden\n- * too. Other methods should be overridden if the backing data structure allows\n- * for a more efficient implementation. The precise implementation used by\n- * AbstractList is documented, so that subclasses can tell which methods could\n- * be implemented more efficiently.\n+ * it easier to create a List based on a random-access data structure. If\n+ * the list is sequential (such as a linked list), use AbstractSequentialList.\n+ * To create an unmodifiable list, it is only necessary to override the\n+ * size() and get(int) methods (this contrasts with all other abstract\n+ * collection classes which require an iterator to be provided). To make the\n+ * list modifiable, the set(int, Object) method should also be overridden, and\n+ * to make the list resizable, the add(int, Object) and remove(int) methods\n+ * should be overridden too. Other methods should be overridden if the\n+ * backing data structure allows for a more efficient implementation.\n+ * The precise implementation used by AbstractList is documented, so that\n+ * subclasses can tell which methods could be implemented more efficiently.\n+ * <p>\n+ *\n+ * As recommended by Collection and List, the subclass should provide at\n+ * least a no-argument and a Collection constructor. This class is not\n+ * synchronized.\n+ *\n+ * @author Original author unknown\n+ * @author Bryce McKinlay\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @see Collection\n+ * @see List\n+ * @see AbstractSequentialList\n+ * @see AbstractCollection\n+ * @see ListIterator\n+ * @since 1.2\n+ * @status updated to 1.4\n  */\n public abstract class AbstractList extends AbstractCollection implements List\n {\n   /**\n    * A count of the number of structural modifications that have been made to\n-   * the list (that is, insertions and removals).\n+   * the list (that is, insertions and removals). Structural modifications\n+   * are ones which change the list size or affect how iterations would\n+   * behave. This field is available for use by Iterator and ListIterator,\n+   * in order to throw a {@link ConcurrentModificationException} in response\n+   * to the next operation on the iterator. This <i>fail-fast</i> behavior\n+   * saves the user from many subtle bugs otherwise possible from concurrent\n+   * modification during iteration.\n+   * <p>\n+   *\n+   * To make lists fail-fast, increment this field by just 1 in the\n+   * <code>add(int, Object)</code> and <code>remove(int)</code> methods.\n+   * Otherwise, this field may be ignored.\n+   */\n+  protected int modCount;\n+\n+  /**\n+   * The main constructor, for use by subclasses.\n    */\n-  protected transient int modCount = 0;\n+  protected AbstractList()\n+  {\n+  }\n \n+  /**\n+   * Returns the elements at the specified position in the list.\n+   *\n+   * @param index the element to return\n+   * @return the element at that position\n+   * @throws IndexOutOfBoundsException if index &lt; 0 || index &gt;= size()\n+   */\n   public abstract Object get(int index);\n \n+  /**\n+   * Insert an element into the list at a given position (optional operation).\n+   * This shifts all existing elements from that position to the end one\n+   * index to the right.  This version of add has no return, since it is\n+   * assumed to always succeed if there is no exception. This implementation\n+   * always throws UnsupportedOperationException, and must be overridden to\n+   * make a modifiable List.  If you want fail-fast iterators, be sure to\n+   * increment modCount when overriding this.\n+   *\n+   * @param index the location to insert the item\n+   * @param o the object to insert\n+   * @throws UnsupportedOperationException if this list does not support the\n+   *         add operation\n+   * @throws IndexOutOfBoundsException if index &lt; 0 || index &gt; size()\n+   * @throws ClassCastException if o cannot be added to this list due to its\n+   *         type\n+   * @throws IllegalArgumentException if o cannot be added to this list for\n+   *         some other reason\n+   * @see #modCount\n+   */\n   public void add(int index, Object o)\n   {\n     throw new UnsupportedOperationException();\n   }\n \n+  /**\n+   * Add an element to the end of the list (optional operation). If the list\n+   * imposes restraints on what can be inserted, such as no null elements,\n+   * this should be documented. This implementation calls\n+   * <code>add(size(), o);</code>, and will fail if that version does.\n+   *\n+   * @param o the object to add\n+   * @return true, as defined by Collection for a modified list\n+   * @throws UnsupportedOperationException if this list does not support the\n+   *         add operation\n+   * @throws ClassCastException if o cannot be added to this list due to its\n+   *         type\n+   * @throws IllegalArgumentException if o cannot be added to this list for\n+   *         some other reason\n+   * @see #add(int, Object)\n+   */\n   public boolean add(Object o)\n   {\n     add(size(), o);\n     return true;\n   }\n \n+  /**\n+   * Insert the contents of a collection into the list at a given position\n+   * (optional operation). Shift all elements at that position to the right\n+   * by the number of elements inserted. This operation is undefined if\n+   * this list is modified during the operation (for example, if you try\n+   * to insert a list into itself). This implementation uses the iterator of\n+   * the collection, repeatedly calling add(int, Object); this will fail\n+   * if add does. This can often be made more efficient.\n+   *\n+   * @param index the location to insert the collection\n+   * @param c the collection to insert\n+   * @return true if the list was modified by this action, that is, if c is\n+   *         non-empty\n+   * @throws UnsupportedOperationException if this list does not support the\n+   *         addAll operation\n+   * @throws IndexOutOfBoundsException if index &lt; 0 || index &gt; size()\n+   * @throws ClassCastException if some element of c cannot be added to this\n+   *         list due to its type\n+   * @throws IllegalArgumentException if some element of c cannot be added\n+   *         to this list for some other reason\n+   * @throws NullPointerException if the specified collection is null\n+   * @see #add(int, Object)\n+   */\n   public boolean addAll(int index, Collection c)\n   {\n     Iterator itr = c.iterator();\n     int size = c.size();\n-    for (int pos = 0; pos < size; pos++)\n-      {\n-\tadd(index++, itr.next());\n-      }\n-    return (size > 0);\n+    for (int pos = size; pos > 0; pos--)\n+      add(index++, itr.next());\n+    return size > 0;\n   }\n \n+  /**\n+   * Clear the list, such that a subsequent call to isEmpty() would return\n+   * true (optional operation). This implementation calls\n+   * <code>removeRange(0, size())</code>, so it will fail unless remove\n+   * or removeRange is overridden.\n+   *\n+   * @throws UnsupportedOperationException if this list does not support the\n+   *         clear operation\n+   * @see #remove(int)\n+   * @see #removeRange(int, int)\n+   */\n   public void clear()\n   {\n     removeRange(0, size());\n   }\n \n+  /**\n+   * Test whether this list is equal to another object. A List is defined to be\n+   * equal to an object if and only if that object is also a List, and the two\n+   * lists have the same sequence. Two lists l1 and l2 are equal if and only\n+   * if <code>l1.size() == l2.size()</code>, and for every integer n between 0\n+   * and <code>l1.size() - 1</code> inclusive, <code>l1.get(n) == null ?\n+   * l2.get(n) == null : l1.get(n).equals(l2.get(n))</code>.\n+   * <p>\n+   *\n+   * This implementation returns true if the object is this, or false if the\n+   * object is not a List.  Otherwise, it iterates over both lists (with\n+   * iterator()), returning false if two elements compare false or one list\n+   * is shorter, and true if the iteration completes successfully.\n+   *\n+   * @param o the object to test for equality with this list\n+   * @return true if o is equal to this list\n+   * @see Object#equals(Object)\n+   * @see #hashCode()\n+   */\n   public boolean equals(Object o)\n   {\n     if (o == this)\n       return true;\n-    if (!(o instanceof List))\n+    if (! (o instanceof List))\n       return false;\n     int size = size();\n     if (size != ((List) o).size())\n@@ -94,77 +219,272 @@ public boolean equals(Object o)\n     Iterator itr1 = iterator();\n     Iterator itr2 = ((List) o).iterator();\n \n-    for (int pos = 0; pos < size; pos++)\n-      {\n-\tObject e = itr1.next();\n-\tif (e == null ? itr2.next() != null : !e.equals(itr2.next()))\n-\t  return false;\n-      }\n+    while (--size >= 0)\n+      if (! equals(itr1.next(), itr2.next()))\n+        return false;\n     return true;\n   }\n \n+  /**\n+   * Obtain a hash code for this list. In order to obey the general contract of\n+   * the hashCode method of class Object, this value is calculated as follows:\n+   * <pre>\n+   *   hashCode = 1;\n+   *   Iterator i = list.iterator();\n+   *   while (i.hasNext())\n+   *     {\n+   *       Object obj = i.next();\n+   *       hashCode = 31 * hashCode + (obj == null ? 0 : obj.hashCode());\n+   *     }\n+   * </pre>\n+   * This ensures that the general contract of Object.hashCode() is adhered to.\n+   *\n+   * @return the hash code of this list\n+   * @see Object#hashCode()\n+   * @see #equals(Object)\n+   */\n   public int hashCode()\n   {\n     int hashCode = 1;\n     Iterator itr = iterator();\n-    int size = size();\n-    for (int pos = 0; pos < size; pos++)\n-      {\n-\tObject obj = itr.next();\n-\thashCode = 31 * hashCode + (obj == null ? 0 : obj.hashCode());\n-      }\n+    int pos = size();\n+    while (--pos >= 0)\n+      hashCode = 31 * hashCode + hashCode(itr.next());\n     return hashCode;\n   }\n \n+  /**\n+   * Obtain the first index at which a given object is to be found in this\n+   * list. This implementation follows a listIterator() until a match is found,\n+   * or returns -1 if the list end is reached.\n+   *\n+   * @param o the object to search for\n+   * @return the least integer n such that <code>o == null ? get(n) == null :\n+   *         o.equals(get(n))</code>, or -1 if there is no such index\n+   */\n   public int indexOf(Object o)\n   {\n-    ListIterator itr = listIterator(0);\n+    ListIterator itr = listIterator();\n     int size = size();\n     for (int pos = 0; pos < size; pos++)\n-      {\n-\tif (o == null ? itr.next() == null : o.equals(itr.next()))\n-\t  return pos;\n-      }\n+      if (equals(o, itr.next()))\n+        return pos;\n     return -1;\n   }\n \n+  /**\n+   * Obtain an Iterator over this list, whose sequence is the list order.\n+   * This implementation uses size(), get(int), and remove(int) of the\n+   * backing list, and does not support remove unless the list does. This\n+   * implementation is fail-fast if you correctly maintain modCount.\n+   * Also, this implementation is specified by Sun to be distinct from\n+   * listIterator, although you could easily implement it as\n+   * <code>return listIterator(0)</code>.\n+   *\n+   * @return an Iterator over the elements of this list, in order\n+   * @see #modCount\n+   */\n   public Iterator iterator()\n   {\n-    return new AbstractListItr(0);\n+    // Bah, Sun's implementation forbids using listIterator(0).\n+    return new Iterator()\n+    {\n+      private int pos = 0;\n+      private int size = size();\n+      private int last = -1;\n+      private int knownMod = modCount;\n+\n+      // This will get inlined, since it is private.\n+      private void checkMod()\n+      {\n+        if (knownMod != modCount)\n+          throw new ConcurrentModificationException();\n+      }\n+\n+      public boolean hasNext()\n+      {\n+        checkMod();\n+        return pos < size;\n+      }\n+\n+      public Object next()\n+      {\n+        checkMod();\n+        if (pos == size)\n+          throw new NoSuchElementException();\n+        last = pos;\n+        return get(pos++);\n+      }\n+\n+      public void remove()\n+      {\n+        checkMod();\n+        if (last < 0)\n+          throw new IllegalStateException();\n+        AbstractList.this.remove(last);\n+        pos--;\n+        size--;\n+        last = -1;\n+        knownMod = modCount;\n+      }\n+    };\n   }\n \n+  /**\n+   * Obtain the last index at which a given object is to be found in this\n+   * list. This implementation grabs listIterator(size()), then searches\n+   * backwards for a match or returns -1.\n+   *\n+   * @return the greatest integer n such that <code>o == null ? get(n) == null\n+   *         : o.equals(get(n))</code>, or -1 if there is no such index\n+   */\n   public int lastIndexOf(Object o)\n   {\n-    int size = size();\n-    ListIterator itr = listIterator(size);\n-    for (int pos = size; pos > 0; pos--)\n-      {\n-\tif (o == null ? itr.previous() == null : o.equals(itr.previous()))\n-\t  return pos - 1;\n-      }\n+    int pos = size();\n+    ListIterator itr = listIterator(pos);\n+    while (--pos >= 0)\n+      if (equals(o, itr.previous()))\n+        return pos;\n     return -1;\n   }\n \n   /**\n-   * Return an Iterator over this List. This implementation calls\n-   * listIterator(0).\n+   * Obtain a ListIterator over this list, starting at the beginning. This\n+   * implementation returns listIterator(0).\n    *\n-   * @return an Iterator over this List\n+   * @return a ListIterator over the elements of this list, in order, starting\n+   *         at the beginning\n    */\n   public ListIterator listIterator()\n   {\n     return listIterator(0);\n   }\n \n-  public ListIterator listIterator(int index)\n+  /**\n+   * Obtain a ListIterator over this list, starting at a given position.\n+   * A first call to next() would return the same as get(index), and a\n+   * first call to previous() would return the same as get(index - 1).\n+   * <p>\n+   *\n+   * This implementation uses size(), get(int), set(int, Object),\n+   * add(int, Object), and remove(int) of the backing list, and does not\n+   * support remove, set, or add unless the list does. This implementation\n+   * is fail-fast if you correctly maintain modCount.\n+   *\n+   * @param index the position, between 0 and size() inclusive, to begin the\n+   *        iteration from\n+   * @return a ListIterator over the elements of this list, in order, starting\n+   *         at index\n+   * @throws IndexOutOfBoundsException if index &lt; 0 || index &gt; size()\n+   * @see #modCount\n+   */\n+  public ListIterator listIterator(final int index)\n   {\n     if (index < 0 || index > size())\n-      throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size:\" + \n-                                          size());\n+      throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size:\"\n+                                          + size());\n \n-    return new AbstractListItr(index);\n+    return new ListIterator()\n+    {\n+      private int knownMod = modCount;\n+      private int position = index;\n+      private int lastReturned = -1;\n+      private int size = size();\n+\n+      // This will get inlined, since it is private.\n+      private void checkMod()\n+      {\n+        if (knownMod != modCount)\n+          throw new ConcurrentModificationException();\n+      }\n+\n+      public boolean hasNext()\n+      {\n+        checkMod();\n+        return position < size;\n+      }\n+\n+      public boolean hasPrevious()\n+      {\n+        checkMod();\n+        return position > 0;\n+      }\n+\n+      public Object next()\n+      {\n+        checkMod();\n+        if (position == size)\n+          throw new NoSuchElementException();\n+        lastReturned = position;\n+        return get(position++);\n+      }\n+\n+      public Object previous()\n+      {\n+        checkMod();\n+        if (position == 0)\n+          throw new NoSuchElementException();\n+        lastReturned = --position;\n+        return get(lastReturned);\n+      }\n+\n+      public int nextIndex()\n+      {\n+        checkMod();\n+        return position;\n+      }\n+\n+      public int previousIndex()\n+      {\n+        checkMod();\n+        return position - 1;\n+      }\n+\n+      public void remove()\n+      {\n+        checkMod();\n+        if (lastReturned < 0)\n+          throw new IllegalStateException();\n+        AbstractList.this.remove(lastReturned);\n+        size--;\n+        position = lastReturned;\n+        lastReturned = -1;\n+        knownMod = modCount;\n+      }\n+\n+      public void set(Object o)\n+      {\n+        checkMod();\n+        if (lastReturned < 0)\n+          throw new IllegalStateException();\n+        AbstractList.this.set(lastReturned, o);\n+      }\n+\n+      public void add(Object o)\n+      {\n+        checkMod();\n+        AbstractList.this.add(position++, o);\n+        size++;\n+        lastReturned = -1;\n+        knownMod = modCount;\n+      }\n+    };\n   }\n \n+  /**\n+   * Remove the element at a given position in this list (optional operation).\n+   * Shifts all remaining elements to the left to fill the gap. This\n+   * implementation always throws an UnsupportedOperationException.\n+   * If you want fail-fast iterators, be sure to increment modCount when\n+   * overriding this.\n+   *\n+   * @param index the position within the list of the object to remove\n+   * @return the object that was removed\n+   * @throws UnsupportedOperationException if this list does not support the\n+   *         remove operation\n+   * @throws IndexOutOfBoundsException if index &lt; 0 || index &gt;= size()\n+   * @see #modCount\n+   */\n   public Object remove(int index)\n   {\n     throw new UnsupportedOperationException();\n@@ -175,8 +495,10 @@ public Object remove(int index)\n    * removeRange methods of the class which implements subList, which are\n    * difficult for subclasses to override directly. Therefore, this method\n    * should be overridden instead by the more efficient implementation, if one\n-   * exists.\n+   * exists. Overriding this can reduce quadratic efforts to constant time\n+   * in some cases!\n    * <p>\n+   *\n    * This implementation first checks for illegal or out of range arguments. It\n    * then obtains a ListIterator over the list using listIterator(fromIndex).\n    * It then calls next() and remove() on this iterator repeatedly, toIndex -\n@@ -190,152 +512,131 @@ protected void removeRange(int fromIndex, int toIndex)\n     ListIterator itr = listIterator(fromIndex);\n     for (int index = fromIndex; index < toIndex; index++)\n       {\n-\titr.next();\n-\titr.remove();\n+        itr.next();\n+        itr.remove();\n       }\n   }\n \n+  /**\n+   * Replace an element of this list with another object (optional operation).\n+   * This implementation always throws an UnsupportedOperationException.\n+   *\n+   * @param index the position within this list of the element to be replaced\n+   * @param o the object to replace it with\n+   * @return the object that was replaced\n+   * @throws UnsupportedOperationException if this list does not support the\n+   *         set operation\n+   * @throws IndexOutOfBoundsException if index &lt; 0 || index &gt;= size()\n+   * @throws ClassCastException if o cannot be added to this list due to its\n+   *         type\n+   * @throws IllegalArgumentException if o cannot be added to this list for\n+   *         some other reason\n+   */\n   public Object set(int index, Object o)\n   {\n     throw new UnsupportedOperationException();\n   }\n \n+  /**\n+   * Obtain a List view of a subsection of this list, from fromIndex\n+   * (inclusive) to toIndex (exclusive). If the two indices are equal, the\n+   * sublist is empty. The returned list should be modifiable if and only\n+   * if this list is modifiable. Changes to the returned list should be\n+   * reflected in this list. If this list is structurally modified in\n+   * any way other than through the returned list, the result of any subsequent\n+   * operations on the returned list is undefined.\n+   * <p>\n+   *\n+   * This implementation returns a subclass of AbstractList. It stores, in\n+   * private fields, the offset and size of the sublist, and the expected\n+   * modCount of the backing list. If the backing list implements RandomAccess,\n+   * the sublist will also.\n+   * <p>\n+   *\n+   * The subclass's <code>set(int, Object)</code>, <code>get(int)</code>,\n+   * <code>add(int, Object)</code>, <code>remove(int)</code>,\n+   * <code>addAll(int, Collection)</code> and\n+   * <code>removeRange(int, int)</code> methods all delegate to the\n+   * corresponding methods on the backing abstract list, after\n+   * bounds-checking the index and adjusting for the offset. The\n+   * <code>addAll(Collection c)</code> method merely returns addAll(size, c).\n+   * The <code>listIterator(int)</code> method returns a \"wrapper object\"\n+   * over a list iterator on the backing list, which is created with the\n+   * corresponding method on the backing list. The <code>iterator()</code>\n+   * method merely returns listIterator(), and the <code>size()</code> method\n+   * merely returns the subclass's size field.\n+   * <p>\n+   *\n+   * All methods first check to see if the actual modCount of the backing\n+   * list is equal to its expected value, and throw a\n+   * ConcurrentModificationException if it is not. \n+   *\n+   * @param fromIndex the index that the returned list should start from\n+   *        (inclusive)\n+   * @param toIndex the index that the returned list should go to (exclusive)\n+   * @return a List backed by a subsection of this list\n+   * @throws IndexOutOfBoundsException if fromIndex &lt; 0\n+   *         || toIndex &gt; size()\n+   * @throws IllegalArgumentException if fromIndex &gt; toIndex\n+   * @see ConcurrentModificationException\n+   * @see RandomAccess\n+   */\n   public List subList(int fromIndex, int toIndex)\n   {\n+    // This follows the specification of AbstractList, but is inconsistent\n+    // with the one in List. Don't you love Sun's inconsistencies?\n     if (fromIndex > toIndex)\n       throw new IllegalArgumentException(fromIndex + \" > \" + toIndex);\n     if (fromIndex < 0 || toIndex > size())\n       throw new IndexOutOfBoundsException();\n \n+    if (this instanceof RandomAccess)\n+      return new RandomAccessSubList(this, fromIndex, toIndex);\n     return new SubList(this, fromIndex, toIndex);\n   }\n \n-  class AbstractListItr implements ListIterator\n-  {\n-    private int knownMod = modCount;\n-    private int position;\n-    private int lastReturned = -1;\n-    private int size = size();\n-\n-    AbstractListItr(int start_pos)\n-    {\n-      this.position = start_pos;\n-    }\n-\n-    private void checkMod()\n-    {\n-      if (knownMod != modCount)\n-\tthrow new ConcurrentModificationException();\n-    }\n-\n-    public boolean hasNext()\n-    {\n-      checkMod();\n-      return position < size;\n-    }\n-\n-    public boolean hasPrevious()\n-    {\n-      checkMod();\n-      return position > 0;\n-    }\n-\n-    public Object next()\n-    {\n-      checkMod();\n-      if (position < size)\n-\t{\n-\t  lastReturned = position++;\n-\t  return get(lastReturned);\n-\t}\n-      else\n-\t{\n-\t  throw new NoSuchElementException();\n-\t}\n-    }\n-\n-    public Object previous()\n-    {\n-      checkMod();\n-      if (position > 0)\n-\t{\n-\t  lastReturned = --position;\n-\t  return get(lastReturned);\n-\t}\n-      else\n-\t{\n-\t  throw new NoSuchElementException();\n-\t}\n-    }\n-\n-    public int nextIndex()\n-    {\n-      checkMod();\n-      return position;\n-    }\n-\n-    public int previousIndex()\n-    {\n-      checkMod();\n-      return position - 1;\n-    }\n-\n-    public void remove()\n-    {\n-      checkMod();\n-      if (lastReturned < 0)\n-\t{\n-\t  throw new IllegalStateException();\n-\t}\n-      AbstractList.this.remove(lastReturned);\n-      knownMod++;\n-      position = lastReturned;\n-      lastReturned = -1;\n-    }\n-\n-    public void set(Object o)\n-    {\n-      checkMod();\n-      if (lastReturned < 0)\n-\tthrow new IllegalStateException();\n-      AbstractList.this.set(lastReturned, o);\n-    }\n-\n-    public void add(Object o)\n-    {\n-      checkMod();\n-      AbstractList.this.add(position++, o);\n-      lastReturned = -1;\n-      knownMod++;\n-    }\n-  }\t\t\t\t// AbstractList.Iterator\n-}\n-\n+} // class AbstractList\n \n \n+/**\n+ * This class follows the implementation requirements set forth in\n+ * {@link AbstractList#subList(int, int)}. Some compilers have problems\n+ * with AbstractList.this.modCount if this class is nested in AbstractList,\n+ * even though the JLS defines that to be legal, so we make it a top-level\n+ * class.\n+ *\n+ * @author Original author unknown\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ */\n class SubList extends AbstractList\n {\n-  private AbstractList backingList;\n-  private int offset;\n+  private final AbstractList backingList;\n+  private final int offset;\n   private int size;\n \n-  public SubList(AbstractList backing, int fromIndex, int toIndex)\n+  /**\n+   * Construct the sublist.\n+   *\n+   * @param backing the list this comes from\n+   * @param fromIndex the lower bound, inclusive\n+   * @param toIndex the upper bound, exclusive\n+   */\n+  SubList(AbstractList backing, int fromIndex, int toIndex)\n   {\n     backingList = backing;\n-    modCount = backingList.modCount;\n+    modCount = backing.modCount;\n     offset = fromIndex;\n     size = toIndex - fromIndex;\n   }\n \n   /**\n    * This method checks the two modCount fields to ensure that there has\n-   * not been a concurrent modification. It throws an exception if there\n-   * has been, and otherwise returns normally.\n-   * Note that since this method is private, it will be inlined.\n+   * not been a concurrent modification, returning if all is okay.\n    *\n-   * @exception ConcurrentModificationException if there has been a\n-   *   concurrent modification.\n+   * @throws ConcurrentModificationException if the backing list has been\n+   *         modified externally to this sublist\n    */\n+  // This will get inlined, since it is private.\n   private void checkMod()\n   {\n     if (modCount != backingList.modCount)\n@@ -345,108 +646,174 @@ private void checkMod()\n   /**\n    * This method checks that a value is between 0 and size (inclusive). If\n    * it is not, an exception is thrown.\n-   * Note that since this method is private, it will be inlined.\n    *\n-   * @exception IndexOutOfBoundsException if the value is out of range.\n+   * @param index the value to check\n+   * @throws IndexOutOfBoundsException if the value is out of range\n    */\n+  // This will get inlined, since it is private.\n   private void checkBoundsInclusive(int index)\n   {\n     if (index < 0 || index > size)\n-      throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size:\" + \n-                                          size);\n+      throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size:\"\n+                                          + size);\n   }\n \n   /**\n    * This method checks that a value is between 0 (inclusive) and size\n    * (exclusive). If it is not, an exception is thrown.\n-   * Note that since this method is private, it will be inlined.\n    *\n-   * @exception IndexOutOfBoundsException if the value is out of range.\n+   * @param index the value to check\n+   * @throws IndexOutOfBoundsException if the value is out of range\n    */\n+  // This will get inlined, since it is private.\n   private void checkBoundsExclusive(int index)\n   {\n     if (index < 0 || index >= size)\n-      throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size:\" + \n-                                          size);\n+      throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size:\"\n+                                          + size);\n   }\n \n+  /**\n+   * Specified by AbstractList.subList to return the private field size.\n+   *\n+   * @return the sublist size\n+   */\n   public int size()\n   {\n     checkMod();\n     return size;\n   }\n \n+  /**\n+   * Specified by AbstractList.subList to delegate to the backing list.\n+   *\n+   * @param index the location to modify\n+   * @param o the new value\n+   * @return the old value\n+   */\n   public Object set(int index, Object o)\n   {\n     checkMod();\n     checkBoundsExclusive(index);\n-    o = backingList.set(index + offset, o);\n-    return o;\n+    return backingList.set(index + offset, o);\n   }\n \n+  /**\n+   * Specified by AbstractList.subList to delegate to the backing list.\n+   *\n+   * @param index the location to get from\n+   * @return the object at that location\n+   */\n   public Object get(int index)\n   {\n     checkMod();\n     checkBoundsExclusive(index);\n     return backingList.get(index + offset);\n   }\n \n+  /**\n+   * Specified by AbstractList.subList to delegate to the backing list.\n+   *\n+   * @param index the index to insert at\n+   * @param o the object to add\n+   */\n   public void add(int index, Object o)\n   {\n     checkMod();\n     checkBoundsInclusive(index);\n     backingList.add(index + offset, o);\n-    this.modCount++;\n     size++;\n+    modCount = backingList.modCount;\n   }\n \n+  /**\n+   * Specified by AbstractList.subList to delegate to the backing list.\n+   *\n+   * @param index the index to remove\n+   * @return the removed object\n+   */\n   public Object remove(int index)\n   {\n     checkMod();\n     checkBoundsExclusive(index);\n     Object o = backingList.remove(index + offset);\n-    this.modCount++;\n     size--;\n+    modCount = backingList.modCount;\n     return o;\n   }\n \n-  public void removeRange(int fromIndex, int toIndex)\n+  /**\n+   * Specified by AbstractList.subList to delegate to the backing list.\n+   * This does no bounds checking, as it assumes it will only be called\n+   * by trusted code like clear() which has already checked the bounds.\n+   *\n+   * @param fromIndex the lower bound, inclusive\n+   * @param toIndex the upper bound, exclusive\n+   */\n+  protected void removeRange(int fromIndex, int toIndex)\n   {\n     checkMod();\n-    checkBoundsExclusive(fromIndex);\n-    checkBoundsInclusive(toIndex);\n \n-    // this call will catch the toIndex < fromIndex condition\n     backingList.removeRange(offset + fromIndex, offset + toIndex);\n-    this.modCount = backingList.modCount;\n     size -= toIndex - fromIndex;\n+    modCount = backingList.modCount;\n   }\n \n+  /**\n+   * Specified by AbstractList.subList to delegate to the backing list.\n+   *\n+   * @param index the location to insert at\n+   * @param c the collection to insert\n+   * @return true if this list was modified, in other words, c is non-empty\n+   */\n   public boolean addAll(int index, Collection c)\n   {\n     checkMod();\n     checkBoundsInclusive(index);\n     int csize = c.size();\n     boolean result = backingList.addAll(offset + index, c);\n-    this.modCount = backingList.modCount;\n     size += csize;\n+    modCount = backingList.modCount;\n     return result;\n   }\n \n+  /**\n+   * Specified by AbstractList.subList to return addAll(size, c).\n+   *\n+   * @param c the collection to insert\n+   * @return true if this list was modified, in other words, c is non-empty\n+   */\n+  public boolean addAll(Collection c)\n+  {\n+    return addAll(size, c);\n+  }\n+\n+  /**\n+   * Specified by AbstractList.subList to return listIterator().\n+   *\n+   * @return an iterator over the sublist\n+   */\n   public Iterator iterator()\n   {\n-    return listIterator(0);\n+    return listIterator();\n   }\n \n+  /**\n+   * Specified by AbstractList.subList to return a wrapper around the\n+   * backing list's iterator.\n+   *\n+   * @param index the start location of the iterator\n+   * @return a list iterator over the sublist\n+   */\n   public ListIterator listIterator(final int index)\n-  {      \n+  {\n     checkMod();\n     checkBoundsInclusive(index);\n \n-    return new ListIterator() \n+    return new ListIterator()\n     {\n-      ListIterator i = backingList.listIterator(index + offset);\n-      int position = index;\n+      private final ListIterator i = backingList.listIterator(index + offset);\n+      private int position = index;\n \n       public boolean hasNext()\n       {\n@@ -462,44 +829,36 @@ public boolean hasPrevious()\n \n       public Object next()\n       {\n-        if (position < size)\n-\t  {\n-            Object o = i.next();\n-            position++;\n-            return o;\n-          }\n-\telse\n+        if (position == size)\n           throw new NoSuchElementException();\n+        position++;\n+        return i.next();\n       }\n \n       public Object previous()\n       {\n-        if (position > 0)\n-\t  {\n-            Object o = i.previous();\n-            position--;\n-            return o;\n-          }\n-\telse\n+        if (position == 0)\n           throw new NoSuchElementException();\n+        position--;\n+        return i.previous();\n       }\n \n       public int nextIndex()\n       {\n-        return offset + i.nextIndex();\n+        return i.nextIndex() - offset;\n       }\n \n       public int previousIndex()\n       {\n-        return offset + i.previousIndex();\n+        return i.previousIndex() - offset;\n       }\n \n       public void remove()\n       {\n         i.remove();\n-\tmodCount++;\n         size--;\n         position = nextIndex();\n+        modCount = backingList.modCount;\n       }\n \n       public void set(Object o)\n@@ -510,14 +869,14 @@ public void set(Object o)\n       public void add(Object o)\n       {\n         i.add(o);\n-\tmodCount++;\n         size++;\n         position++;\n+        modCount = backingList.modCount;\n       }\n \n       // Here is the reason why the various modCount fields are mostly\n       // ignored in this wrapper listIterator.\n-      // IF the backing listIterator is failfast, then the following holds:\n+      // If the backing listIterator is failfast, then the following holds:\n       //   Using any other method on this list will call a corresponding\n       //   method on the backing list *after* the backing listIterator\n       //   is created, which will in turn cause a ConcurrentModException\n@@ -530,9 +889,31 @@ public void add(Object o)\n       //   only, but somewhat pointless when the list can be changed under\n       //   us.\n       // Either way, no explicit handling of modCount is needed.\n-      // However modCount++ must be executed in add and remove, and size\n-      // must also be updated in these two methods, since they do not go\n-      // through the corresponding methods of the subList.\n+      // However modCount = backingList.modCount must be executed in add\n+      // and remove, and size must also be updated in these two methods,\n+      // since they do not go through the corresponding methods of the subList.\n     };\n   }\n-}  // SubList\n+} // class SubList\n+\n+/**\n+ * This class is a RandomAccess version of SubList, as required by\n+ * {@link AbstractList#subList(int, int)}.\n+ *\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ */\n+final class RandomAccessSubList extends SubList\n+  implements RandomAccess\n+{\n+  /**\n+   * Construct the sublist.\n+   *\n+   * @param backing the list this comes from\n+   * @param fromIndex the lower bound, inclusive\n+   * @param toIndex the upper bound, exclusive\n+   */\n+  RandomAccessSubList(AbstractList backing, int fromIndex, int toIndex)\n+  {\n+    super(backing, fromIndex, toIndex);\n+  }\n+} // class RandomAccessSubList"}, {"sha": "f8cf79f29b0d511457c759ccc007c8586fd0ee39", "filename": "libjava/java/util/AbstractMap.java", "status": "modified", "additions": 388, "deletions": 171, "changes": 559, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2Fjava%2Futil%2FAbstractMap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2Fjava%2Futil%2FAbstractMap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FAbstractMap.java?ref=d9fd7154ec7908eff8bbbce75651eccf51064ac1", "patch": "@@ -1,5 +1,5 @@\n /* AbstractMap.java -- Abstract implementation of most of Map\n-   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -25,269 +25,486 @@\n executable file might be covered by the GNU General Public License. */\n \n \n-// TO DO:\n-// comments\n-// test suite\n-\n package java.util;\n \n+/**\n+ * An abstract implementation of Map to make it easier to create your own\n+ * implementations. In order to create an unmodifiable Map, subclass\n+ * AbstractMap and implement the <code>entrySet</code> (usually via an\n+ * AbstractSet).  To make it modifiable, also implement <code>put</code>,\n+ * and have <code>entrySet().iterator()</code> support <code>remove</code>.\n+ * <p>\n+ *\n+ * It is recommended that classes which extend this support at least the\n+ * no-argument constructor, and a constructor which accepts another Map.\n+ * Further methods in this class may be overridden if you have a more\n+ * efficient implementation.\n+ *\n+ * @author Original author unknown\n+ * @author Bryce McKinlay\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @see Map\n+ * @see Collection\n+ * @see HashMap\n+ * @see LinkedHashMap\n+ * @see TreeMap\n+ * @see WeakHashMap\n+ * @see IdentityHashMap\n+ * @since 1.2\n+ * @status updated to 1.4\n+ */\n public abstract class AbstractMap implements Map\n {\n+  /** An \"enum\" of iterator types. */\n+  // Package visible for use by subclasses.\n+  static final int KEYS = 0,\n+                   VALUES = 1,\n+                   ENTRIES = 2;\n+\n+  /**\n+   * The cache for {@link #keySet()}.\n+   */\n+  // Package visible for use by subclasses.\n+  Set keys;\n+\n+  /**\n+   * The cache for {@link #values()}.\n+   */\n+  // Package visible for use by subclasses.\n+  Collection values;\n+\n   /**\n-   * Remove all entries from this Map. This default implementation calls\n-   * entrySet().clear().\n+   * The main constructor, for use by subclasses.\n+   */\n+  protected AbstractMap()\n+  {\n+  }\n+\n+  /**\n+   * Remove all entries from this Map (optional operation). This default\n+   * implementation calls entrySet().clear(). NOTE: If the entry set does\n+   * not permit clearing, then this will fail, too. Subclasses often\n+   * override this for efficiency.  Your implementation of entrySet() should\n+   * not call <code>AbstractMap.clear</code> unless you want an infinite loop.\n    *\n-   * @throws UnsupportedOperationException\n-   * @specnote The JCL book claims that this implementation always throws \n-   *           UnsupportedOperationException, while the online docs claim it\n-   *           calls entrySet().clear(). We take the later to be correct.\n+   * @throws UnsupportedOperationException if <code>entrySet().clear()</code>\n+   *         does not support clearing.\n+   * @see Set#clear()\n    */\n   public void clear()\n   {\n     entrySet().clear();\n   }\n \n   /**\n-   * Create a shallow copy of this Map, no keys or values are copied.\n+   * Create a shallow copy of this Map, no keys or values are copied. The\n+   * default implementation simply calls <code>super.clone()</code>.\n+   *\n+   * @return the shallow clone\n+   * @throws CloneNotSupportedException if a subclass is not Cloneable\n+   * @see Cloneable\n+   * @see Object#clone()\n    */\n-  protected Object clone () throws CloneNotSupportedException\n+  protected Object clone() throws CloneNotSupportedException\n   {\n-    return super.clone ();\n+    AbstractMap copy = (AbstractMap) super.clone();\n+    // Clear out the caches; they are stale.\n+    copy.keys = null;\n+    copy.values = null;\n+    return copy;\n   }\n \n+  /**\n+   * Returns true if this contains a mapping for the given key. This\n+   * implementation does a linear search, O(n), over the\n+   * <code>entrySet()</code>, returning <code>true</code> if a match\n+   * is found, <code>false</code> if the iteration ends. Many subclasses\n+   * can implement this more efficiently.\n+   *\n+   * @param key the key to search for\n+   * @return true if the map contains the key\n+   * @throws NullPointerException if key is <code>null</code> but the map\n+   *         does not permit null keys\n+   * @see #containsValue(Object)\n+   */\n   public boolean containsKey(Object key)\n   {\n-    Object k;\n-    Set es = entrySet();\n-    Iterator entries = es.iterator();\n-    int size = size();\n-    for (int pos = 0; pos < size; pos++)\n-      {\n-\tk = ((Map.Entry) entries.next()).getKey();\n-\tif (key == null ? k == null : key.equals(k))\n-\t  return true;\n-      }\n+    Iterator entries = entrySet().iterator();\n+    int pos = size();\n+    while (--pos >= 0)\n+      if (equals(key, ((Map.Entry) entries.next()).getKey()))\n+        return true;\n     return false;\n   }\n \n+  /**\n+   * Returns true if this contains at least one mapping with the given value.\n+   * This implementation does a linear search, O(n), over the\n+   * <code>entrySet()</code>, returning <code>true</code> if a match\n+   * is found, <code>false</code> if the iteration ends. A match is\n+   * defined as <code>(value == null ? v == null : value.equals(v))</code>\n+   * Subclasses are unlikely to implement this more efficiently.\n+   *\n+   * @param value the value to search for\n+   * @return true if the map contains the value\n+   * @see #containsKey(Object)\n+   */\n   public boolean containsValue(Object value)\n   {\n-    Object v;\n-    Set es = entrySet();\n-    Iterator entries = es.iterator();\n-    int size = size();\n-    for (int pos = 0; pos < size; pos++)\n-      {\n-\tv = ((Map.Entry) entries.next()).getValue();\n-\tif (value == null ? v == null : value.equals(v))\n-\t  return true;\n-      }\n+    Iterator entries = entrySet().iterator();\n+    int pos = size();\n+    while (--pos >= 0)\n+      if (equals(value, ((Map.Entry) entries.next()).getValue()))\n+        return true;\n     return false;\n   }\n \n+  /**\n+   * Returns a set view of the mappings in this Map.  Each element in the\n+   * set must be an implementation of Map.Entry.  The set is backed by\n+   * the map, so that changes in one show up in the other.  Modifications\n+   * made while an iterator is in progress cause undefined behavior.  If\n+   * the set supports removal, these methods must be valid:\n+   * <code>Iterator.remove</code>, <code>Set.remove</code>,\n+   * <code>removeAll</code>, <code>retainAll</code>, and <code>clear</code>.\n+   * Element addition is not supported via this set.\n+   *\n+   * @return the entry set\n+   * @see Map.Entry\n+   */\n   public abstract Set entrySet();\n \n+  /**\n+   * Compares the specified object with this map for equality. Returns\n+   * <code>true</code> if the other object is a Map with the same mappings,\n+   * that is,<br>\n+   * <code>o instanceof Map && entrySet().equals(((Map) o).entrySet();</code>\n+   *\n+   * @param o the object to be compared\n+   * @return true if the object equals this map\n+   * @see Set#equals(Object)\n+   */\n   public boolean equals(Object o)\n   {\n-    if (o == this)\n-      return true;\n-    if (!(o instanceof Map))\n-      return false;\n-\n-    Map m = (Map) o;\n-    Set s = m.entrySet();\n-    Iterator itr = entrySet().iterator();\n-    int size = size();\n-\n-    if (m.size() != size)\n-      return false;\n-\n-    for (int pos = 0; pos < size; pos++)\n-      {\n-\tif (!s.contains(itr.next()))\n-\t  return false;\n-      }\n-    return true;\n+    return (o == this ||\n+            (o instanceof Map &&\n+             entrySet().equals(((Map) o).entrySet())));\n   }\n \n+  /**\n+   * Returns the value mapped by the given key. Returns <code>null</code> if\n+   * there is no mapping.  However, in Maps that accept null values, you\n+   * must rely on <code>containsKey</code> to determine if a mapping exists.\n+   * This iteration takes linear time, searching entrySet().iterator() of\n+   * the key.  Many implementations override this method.\n+   *\n+   * @param key the key to look up\n+   * @return the value associated with the key, or null if key not in map\n+   * @throws NullPointerException if this map does not accept null keys\n+   * @see #containsKey(Object)\n+   */\n   public Object get(Object key)\n   {\n-    Set s = entrySet();\n-    Iterator entries = s.iterator();\n-    int size = size();\n-\n-    for (int pos = 0; pos < size; pos++)\n+    Iterator entries = entrySet().iterator();\n+    int pos = size();\n+    while (--pos >= 0)\n       {\n-\tMap.Entry entry = (Map.Entry) entries.next();\n-\tObject k = entry.getKey();\n-\tif (key == null ? k == null : key.equals(k))\n-\t  return entry.getValue();\n+        Map.Entry entry = (Map.Entry) entries.next();\n+        if (equals(key, entry.getKey()))\n+          return entry.getValue();\n       }\n-\n     return null;\n   }\n \n+  /**\n+   * Returns the hash code for this map. As defined in Map, this is the sum\n+   * of all hashcodes for each Map.Entry object in entrySet, or basically\n+   * entrySet().hashCode().\n+   *\n+   * @return the hash code\n+   * @see Map.Entry#hashCode()\n+   * @see Set#hashCode()\n+   */\n   public int hashCode()\n   {\n-    int hashcode = 0;\n-    Iterator itr = entrySet().iterator();\n-    int size = size();\n-    for (int pos = 0; pos < size; pos++)\n-      {\n-\thashcode += itr.next().hashCode();\n-      }\n-    return hashcode;\n+    return entrySet().hashCode();\n   }\n \n+  /**\n+   * Returns true if the map contains no mappings. This is implemented by\n+   * <code>size() == 0</code>.\n+   *\n+   * @return true if the map is empty\n+   * @see #size()\n+   */\n   public boolean isEmpty()\n   {\n     return size() == 0;\n   }\n \n+  /**\n+   * Returns a set view of this map's keys. The set is backed by the map,\n+   * so changes in one show up in the other. Modifications while an iteration\n+   * is in progress produce undefined behavior. The set supports removal\n+   * if entrySet() does, but does not support element addition.\n+   * <p>\n+   *\n+   * This implementation creates an AbstractSet, where the iterator wraps\n+   * the entrySet iterator, size defers to the Map's size, and contains\n+   * defers to the Map's containsKey. The set is created on first use, and\n+   * returned on subsequent uses, although since no synchronization occurs,\n+   * there is a slight possibility of creating two sets.\n+   *\n+   * @return a Set view of the keys\n+   * @see Set#iterator()\n+   * @see #size()\n+   * @see #containsKey(Object)\n+   * @see #values()\n+   */\n   public Set keySet()\n   {\n-    if (this.keySet == null)\n+    if (keys == null)\n+      keys = new AbstractSet()\n       {\n-\tthis.keySet = new AbstractSet()\n-\t{\n-\t  public int size()\n-\t  {\n-\t    return AbstractMap.this.size();\n-\t  }\n-\n-\t  public boolean contains(Object key)\n-\t  {\n-\t    return AbstractMap.this.containsKey(key);\n-\t  }\n-\n-\t  public Iterator iterator()\n-\t  {\n-\t    return new Iterator()\n-\t    {\n-\t      Iterator map_iterator = AbstractMap.this.entrySet().iterator();\n-\n-\t      public boolean hasNext()\n-\t      {\n-\t\treturn map_iterator.hasNext();\n-\t      }\n-\n-\t      public Object next()\n-\t      {\n-\t\treturn ((Map.Entry) map_iterator.next()).getKey();\n-\t      }\n-\n-\t      public void remove()\n-\t      {\n-\t\tmap_iterator.remove();\n-\t      }\n-\t    };\n-\t  }\n-\t};\n-      }\n-\n-    return this.keySet;\n+        public int size()\n+        {\n+          return AbstractMap.this.size();\n+        }\n+\n+        public boolean contains(Object key)\n+        {\n+          return containsKey(key);\n+        }\n+\n+        public Iterator iterator()\n+        {\n+          return new Iterator()\n+          {\n+            private final Iterator map_iterator = entrySet().iterator();\n+\n+            public boolean hasNext()\n+            {\n+              return map_iterator.hasNext();\n+            }\n+\n+            public Object next()\n+            {\n+              return ((Map.Entry) map_iterator.next()).getKey();\n+            }\n+\n+            public void remove()\n+            {\n+              map_iterator.remove();\n+            }\n+          };\n+        }\n+      };\n+    return keys;\n   }\n \n+  /**\n+   * Associates the given key to the given value (optional operation). If the\n+   * map already contains the key, its value is replaced. This implementation\n+   * simply throws an UnsupportedOperationException. Be aware that in a map\n+   * that permits <code>null</code> values, a null return does not always\n+   * imply that the mapping was created.\n+   *\n+   * @param key the key to map\n+   * @param value the value to be mapped\n+   * @return the previous value of the key, or null if there was no mapping\n+   * @throws UnsupportedOperationException if the operation is not supported\n+   * @throws ClassCastException if the key or value is of the wrong type\n+   * @throws IllegalArgumentException if something about this key or value\n+   *         prevents it from existing in this map\n+   * @throws NullPointerException if the map forbids null keys or values\n+   * @see #containsKey(Object)\n+   */\n   public Object put(Object key, Object value)\n   {\n     throw new UnsupportedOperationException();\n   }\n \n+  /**\n+   * Copies all entries of the given map to this one (optional operation). If\n+   * the map already contains a key, its value is replaced. This implementation\n+   * simply iterates over the map's entrySet(), calling <code>put</code>,\n+   * so it is not supported if puts are not.\n+   *\n+   * @param m the mapping to load into this map\n+   * @throws UnsupportedOperationException if the operation is not supported\n+   * @throws ClassCastException if a key or value is of the wrong type\n+   * @throws IllegalArgumentException if something about a key or value\n+   *         prevents it from existing in this map\n+   * @throws NullPointerException if the map forbids null keys or values, or\n+   *         if <code>m</code> is null.\n+   * @see #put(Object, Object)\n+   */\n   public void putAll(Map m)\n   {\n-    Map.Entry entry;\n     Iterator entries = m.entrySet().iterator();\n-    int size = m.size();\n-\n-    for (int pos = 0; pos < size; pos++)\n+    int pos = size();\n+    while (--pos >= 0)\n       {\n-\tentry = (Map.Entry) entries.next();\n-\tput(entry.getKey(), entry.getValue());\n+        Map.Entry entry = (Map.Entry) entries.next();\n+        put(entry.getKey(), entry.getValue());\n       }\n   }\n \n+  /**\n+   * Removes the mapping for this key if present (optional operation). This\n+   * implementation iterates over the entrySet searching for a matching\n+   * key, at which point it calls the iterator's <code>remove</code> method.\n+   * It returns the result of <code>getValue()</code> on the entry, if found,\n+   * or null if no entry is found. Note that maps which permit null values\n+   * may also return null if the key was removed.  If the entrySet does not\n+   * support removal, this will also fail. This is O(n), so many\n+   * implementations override it for efficiency.\n+   *\n+   * @param key the key to remove\n+   * @return the value the key mapped to, or null if not present\n+   * @throws UnsupportedOperationException if deletion is unsupported\n+   * @see Iterator#remove()\n+   */\n   public Object remove(Object key)\n   {\n     Iterator entries = entrySet().iterator();\n-    int size = size();\n-\n-    for (int pos = 0; pos < size; pos++)\n+    int pos = size();\n+    while (--pos >= 0)\n       {\n-\tMap.Entry entry = (Map.Entry) entries.next();\n-\tObject k = entry.getKey();\n-\tif (key == null ? k == null : key.equals(k))\n-\t  {\n-\t    Object value = entry.getValue();\n-\t    entries.remove();\n-\t    return value;\n-\t  }\n+        Map.Entry entry = (Map.Entry) entries.next();\n+        if (equals(key, entry.getKey()))\n+          {\n+            // Must get the value before we remove it from iterator.\n+            Object r = entry.getValue();\n+            entries.remove();\n+            return r;\n+          }\n       }\n-\n     return null;\n   }\n \n+  /**\n+   * Returns the number of key-value mappings in the map. If there are more\n+   * than Integer.MAX_VALUE mappings, return Integer.MAX_VALUE. This is\n+   * implemented as <code>entrySet().size()</code>.\n+   *\n+   * @return the number of mappings\n+   * @see Set#size()\n+   */\n   public int size()\n   {\n     return entrySet().size();\n   }\n \n+  /**\n+   * Returns a String representation of this map. This is a listing of the\n+   * map entries (which are specified in Map.Entry as being\n+   * <code>getKey() + \"=\" + getValue()</code>), separated by a comma and\n+   * space (\", \"), and surrounded by braces ('{' and '}'). This implementation\n+   * uses a StringBuffer and iterates over the entrySet to build the String.\n+   * Note that this can fail with an exception if underlying keys or\n+   * values complete abruptly in toString().\n+   *\n+   * @return a String representation\n+   * @see Map.Entry#toString()\n+   */\n   public String toString()\n   {\n     Iterator entries = entrySet().iterator();\n-    int size = size();\n     StringBuffer r = new StringBuffer(\"{\");\n-    for (int pos = 0; pos < size; pos++)\n+    for (int pos = size(); pos > 0; pos--)\n       {\n-        // Append the toString value of the entries rather than calling \n-\t// getKey/getValue. This is more efficient and it matches the JDK\n-\t// behaviour.\n-\tr.append(entries.next());\t\n-\tif (pos < size - 1)\n-\t  r.append(\", \");\n+        // Append the toString value of the entries rather than calling\n+        // getKey/getValue. This is more efficient and it matches the JDK\n+        // behaviour.\n+        r.append(entries.next());\n+        if (pos > 1)\n+          r.append(\", \");\n       }\n     r.append(\"}\");\n     return r.toString();\n   }\n \n+  /**\n+   * Returns a collection or bag view of this map's values. The collection\n+   * is backed by the map, so changes in one show up in the other.\n+   * Modifications while an iteration is in progress produce undefined\n+   * behavior. The collection supports removal if entrySet() does, but\n+   * does not support element addition.\n+   * <p>\n+   *\n+   * This implementation creates an AbstractCollection, where the iterator\n+   * wraps the entrySet iterator, size defers to the Map's size, and contains\n+   * defers to the Map's containsValue. The collection is created on first\n+   * use, and returned on subsequent uses, although since no synchronization\n+   * occurs, there is a slight possibility of creating two collections.\n+   *\n+   * @return a Collection view of the values\n+   * @see Collection#iterator()\n+   * @see #size()\n+   * @see #containsValue(Object)\n+   * @see #keySet()\n+   */\n   public Collection values()\n   {\n-    if (this.valueCollection == null)\n+    if (values == null)\n+      values = new AbstractCollection()\n       {\n-\tthis.valueCollection = new AbstractCollection()\n-\t{\n-\t  public int size()\n-\t  {\n-\t    return AbstractMap.this.size();\n-\t  }\n-\n-\t  public Iterator iterator()\n-\t  {\n-\t    return new Iterator()\n-\t    {\n-\t      Iterator map_iterator = AbstractMap.this.entrySet().iterator();\n-\n-\t      public boolean hasNext()\n-\t      {\n-\t\treturn map_iterator.hasNext();\n-\t      }\n-\n-\t      public Object next()\n-\t      {\n-\t\treturn ((Map.Entry) map_iterator.next()).getValue();\n-\t      }\n-\n-\t      public void remove()\n-\t      {\n-\t\tmap_iterator.remove();\n-\t      }\n-\t    };\n-\t  }\n-\t};\n-      }\n+        public int size()\n+        {\n+          return AbstractMap.this.size();\n+        }\n+\n+        public Iterator iterator()\n+        {\n+          return new Iterator()\n+          {\n+            private final Iterator map_iterator = entrySet().iterator();\n+\n+            public boolean hasNext()\n+            {\n+              return map_iterator.hasNext();\n+            }\n+\n+            public Object next()\n+            {\n+              return ((Map.Entry) map_iterator.next()).getValue();\n+            }\n+\n+            public void remove()\n+            {\n+              map_iterator.remove();\n+            }\n+          };\n+        }\n+      };\n+    return values;\n+  }\n \n-    return this.valueCollection;\n+  /**\n+   * Compare two objects according to Collection semantics.\n+   *\n+   * @param o1 the first object\n+   * @param o2 the second object\n+   * @return o1 == null ? o2 == null : o1.equals(o2)\n+   */\n+  // Package visible for use throughout java.util.\n+  // It may be inlined since it is final.\n+  static final boolean equals(Object o1, Object o2)\n+  {\n+    return o1 == null ? o2 == null : o1.equals(o2);\n   }\n \n-  private Collection valueCollection = null;\n-  private Set keySet = null;\n+  /**\n+   * Hash an object according to Collection semantics.\n+   *\n+   * @param o the object to hash\n+   * @return o1 == null ? 0 : o1.hashCode()\n+   */\n+  // Package visible for use throughout java.util.\n+  // It may be inlined since it is final.\n+  static final int hashCode(Object o)\n+  {\n+    return o == null ? 0 : o.hashCode();\n+  }\n }"}, {"sha": "2267b02e523fda4a746e59aacce136a5897e39b3", "filename": "libjava/java/util/AbstractSequentialList.java", "status": "modified", "additions": 134, "deletions": 42, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2Fjava%2Futil%2FAbstractSequentialList.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2Fjava%2Futil%2FAbstractSequentialList.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FAbstractSequentialList.java?ref=d9fd7154ec7908eff8bbbce75651eccf51064ac1", "patch": "@@ -1,5 +1,5 @@\n /* AbstractSequentialList.java -- List implementation for sequential access\n-   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -25,100 +25,192 @@\n executable file might be covered by the GNU General Public License. */\n \n \n-// TO DO:\n-// ~ Lots of doc comments still missing.\n-// ~ The class comment should include a description of what should be overridden\n-//   to provide what features, as should the listIterator comment.\n-\n package java.util;\n \n /**\n  * Abstract superclass to make it easier to implement the List interface when\n- * backed by a sequential-access store, such as a linked list.\n+ * backed by a sequential-access store, such as a linked list. For random\n+ * access data, use AbstractList. This class implements the random access\n+ * methods (<code>get</code>, <code>set</code>, <code>add</code>, and\n+ * <code>remove</code>) atop the list iterator, opposite of AbstractList's\n+ * approach of implementing the iterator atop random access.\n+ * <p>\n+ *\n+ * To implement a list, you need an implementation for <code>size()</code>\n+ * and <code>listIterator</code>.  With just <code>hasNext</code>,\n+ * <code>next</code>, <code>hasPrevious</code>, <code>previous</code>,\n+ * <code>nextIndex</code>, and <code>previousIndex</code>, you have an\n+ * unmodifiable list. For a modifiable one, add <code>set</code>, and for\n+ * a variable-size list, add <code>add</code> and <code>remove</code>.\n+ * <p>\n+ *\n+ * The programmer should provide a no-argument constructor, and one that\n+ * accepts another Collection, as recommended by the Collection interface.\n+ * Unfortunately, there is no way to enforce this in Java.\n+ *\n+ * @author Original author unknown\n+ * @author Bryce McKinlay\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @see Collection\n+ * @see List\n+ * @see AbstractList\n+ * @see AbstractCollection\n+ * @see ListIterator\n+ * @see LinkedList\n+ * @since 1.2\n+ * @status updated to 1.4\n  */\n public abstract class AbstractSequentialList extends AbstractList\n {\n+  /**\n+   * The main constructor, for use by subclasses.\n+   */\n+  protected AbstractSequentialList()\n+  {\n+  }\n+\n   /**\n    * Returns a ListIterator over the list, starting from position index.\n    * Subclasses must provide an implementation of this method.\n    *\n-   * @exception IndexOutOfBoundsException if index < 0 || index > size()\n+   * @param index the starting position of the list\n+   * @return the list iterator\n+   * @throws IndexOutOfBoundsException if index &lt; 0 || index &gt; size()\n    */\n   public abstract ListIterator listIterator(int index);\n \n   /**\n-   * Add an element to the list at a given index. This implementation obtains a\n-   * ListIterator positioned at the specified index, and then adds the element\n-   * using the ListIterator's add method.\n+   * Insert an element into the list at a given position (optional operation).\n+   * This shifts all existing elements from that position to the end one\n+   * index to the right. This version of add has no return, since it is\n+   * assumed to always succeed if there is no exception. This iteration\n+   * uses listIterator(index).add(o).\n    *\n-   * @param index the position to add the element\n-   * @param o the element to insert\n-   * @exception IndexOutOfBoundsException if index < 0 || index > size()\n-   * @exception UnsupportedOperationException if the iterator returned by\n-   *   listIterator(index) does not support the add method.\n+   * @param index the location to insert the item\n+   * @param o the object to insert\n+   * @throws UnsupportedOperationException if this list does not support the\n+   *         add operation\n+   * @throws IndexOutOfBoundsException if index &lt; 0 || index &gt; size()\n+   * @throws ClassCastException if o cannot be added to this list due to its\n+   *         type\n+   * @throws IllegalArgumentException if o cannot be added to this list for\n+   *         some other reason\n    */\n   public void add(int index, Object o)\n   {\n-    ListIterator i = listIterator(index);\n-    i.add(o);\n+    listIterator(index).add(o);\n   }\n \n   /**\n-   * @specnote The spec in the JDK1.3 online docs is wrong. The implementation\n-   *           should not call next() to skip over new elements as they are\n-   *           added, because iterator.add() should add new elements BEFORE\n-   *           the cursor.\n+   * Insert the contents of a collection into the list at a given position\n+   * (optional operation). Shift all elements at that position to the right\n+   * by the number of elements inserted. This operation is undefined if\n+   * this list is modified during the operation (for example, if you try\n+   * to insert a list into itself).\n+   * <p>\n+   *\n+   * This implementation grabs listIterator(index), then proceeds to use add\n+   * for each element returned by c's iterator. Sun's online specs are wrong,\n+   * claiming that this also calls next(): listIterator.add() correctly\n+   * skips the added element.\n+   *\n+   * @param index the location to insert the collection\n+   * @param c the collection to insert\n+   * @return true if the list was modified by this action, that is, if c is\n+   *         non-empty\n+   * @throws UnsupportedOperationException if this list does not support the\n+   *         addAll operation\n+   * @throws IndexOutOfBoundsException if index &lt; 0 || index &gt; size()\n+   * @throws ClassCastException if some element of c cannot be added to this\n+   *         list due to its type\n+   * @throws IllegalArgumentException if some element of c cannot be added\n+   *         to this list for some other reason\n+   * @throws NullPointerException if the specified collection is null\n+   * @see #add(int, Object)\n    */\n   public boolean addAll(int index, Collection c)\n   {\n-    boolean modified = false;\n     Iterator ci = c.iterator();\n     int size = c.size();\n     ListIterator i = listIterator(index);\n-    for (int pos = 0; pos < size; pos++)\n-      {\n-\ti.add(ci.next());\n-      }\n-    return (size > 0);\n+    for (int pos = size; pos > 0; pos--)\n+      i.add(ci.next());\n+    return size > 0;\n   }\n \n+  /**\n+   * Get the element at a given index in this list. This implementation\n+   * returns listIterator(index).next().\n+   *\n+   * @param index the index of the element to be returned\n+   * @return the element at index index in this list\n+   * @throws IndexOutOfBoundsException if index &lt; 0 || index &gt;= size()\n+   */\n   public Object get(int index)\n   {\n-    ListIterator i = listIterator(index);\n-    if (index < 0 || index > size())\n-      throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size:\" + \n-                                          size());\n-    return i.next();\n+    // This is a legal listIterator position, but an illegal get.\n+    if (index == size())\n+      throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size:\"\n+                                          + size());\n+    return listIterator(index).next();\n   }\n \n   /**\n-   * Return an Iterator over this List. This implementation returns\n-   * listIterator().\n+   * Obtain an Iterator over this list, whose sequence is the list order. This\n+   * implementation returns listIterator().\n    *\n-   * @return an Iterator over this List\n+   * @return an Iterator over the elements of this list, in order\n    */\n   public Iterator iterator()\n   {\n     return listIterator();\n   }\n \n+  /**\n+   * Remove the element at a given position in this list (optional operation).\n+   * Shifts all remaining elements to the left to fill the gap. This\n+   * implementation uses listIterator(index) and ListIterator.remove().\n+   *\n+   * @param index the position within the list of the object to remove\n+   * @return the object that was removed\n+   * @throws UnsupportedOperationException if this list does not support the\n+   *         remove operation\n+   * @throws IndexOutOfBoundsException if index &lt; 0 || index &gt;= size()\n+   */\n   public Object remove(int index)\n   {\n+    // This is a legal listIterator position, but an illegal remove.\n+    if (index == size())\n+      throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size:\"\n+                                          + size());\n     ListIterator i = listIterator(index);\n-    if (index < 0 || index > size())\n-      throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size:\" + \n-                                          size());\n     Object removed = i.next();\n     i.remove();\n     return removed;\n   }\n \n+  /**\n+   * Replace an element of this list with another object (optional operation).\n+   * This implementation uses listIterator(index) and ListIterator.set(o).\n+   *\n+   * @param index the position within this list of the element to be replaced\n+   * @param o the object to replace it with\n+   * @return the object that was replaced\n+   * @throws UnsupportedOperationException if this list does not support the\n+   *         set operation\n+   * @throws IndexOutOfBoundsException if index &lt; 0 || index &gt;= size()\n+   * @throws ClassCastException if o cannot be added to this list due to its\n+   *         type\n+   * @throws IllegalArgumentException if o cannot be added to this list for\n+   *         some other reason\n+   */\n   public Object set(int index, Object o)\n   {\n+    // This is a legal listIterator position, but an illegal set.\n+    if (index == size())\n+      throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size:\"\n+                                          + size());\n     ListIterator i = listIterator(index);\n-    if (index < 0 || index > size())\n-      throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size:\" + \n-                                          size());\n     Object old = i.next();\n     i.set(o);\n     return old;"}, {"sha": "e45e47ea84d9c67abc24899e3a2dc22c21b8524b", "filename": "libjava/java/util/AbstractSet.java", "status": "modified", "additions": 59, "deletions": 13, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2Fjava%2Futil%2FAbstractSet.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2Fjava%2Futil%2FAbstractSet.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FAbstractSet.java?ref=d9fd7154ec7908eff8bbbce75651eccf51064ac1", "patch": "@@ -1,5 +1,5 @@\n /* AbstractSet.java -- Abstract implementation of most of Set\n-   Copyright (C) 1998, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 2000, 2001 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -35,9 +35,27 @@\n  * on them - specifically, no element may be in the set more than once). This\n  * class simply provides implementations of equals() and hashCode() to fulfil\n  * the requirements placed on them by the Set interface.\n+ *\n+ * @author Original author unknown\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @see Collection\n+ * @see AbstractCollection\n+ * @see Set\n+ * @see HashSet\n+ * @see TreeSet\n+ * @see LinkedHashSet\n+ * @since 1.2\n+ * @status updated to 1.4\n  */\n public abstract class AbstractSet extends AbstractCollection implements Set\n {\n+  /**\n+   * The main constructor, for use by subclasses.\n+   */\n+  protected AbstractSet()\n+  {\n+  }\n+\n   /**\n    * Tests whether the given object is equal to this Set. This implementation\n    * first checks whether this set <em>is</em> the given object, and returns\n@@ -50,12 +68,9 @@ public abstract class AbstractSet extends AbstractCollection implements Set\n    */\n   public boolean equals(Object o)\n   {\n-    if (o == this)\n-      return true;\n-    else if (o instanceof Set && ((Set) o).size() == size())\n-      return containsAll((Collection) o);\n-    else\n-      return false;\n+    return (o == this ||\n+            (o instanceof Set && ((Set) o).size() == size()\n+             && containsAll((Collection) o)));\n   }\n \n   /**\n@@ -69,14 +84,45 @@ else if (o instanceof Set && ((Set) o).size() == size())\n   public int hashCode()\n   {\n     Iterator itr = iterator();\n-    int size = size();\n     int hash = 0;\n-    for (int pos = 0; pos < size; pos++)\n+    int pos = size();\n+    while (--pos >= 0)\n+      hash += hashCode(itr.next());\n+    return hash;\n+  }\n+\n+  /**\n+   * Removes from this set all elements in the given collection (optional\n+   * operation). This implementation uses <code>size()</code> to determine\n+   * the smaller collection.  Then, if this set is smaller, it iterates\n+   * over the set, calling Iterator.remove if the collection contains\n+   * the element.  If this set is larger, it iterates over the collection,\n+   * calling Set.remove for all elements in the collection. Note that\n+   * this operation will fail if a remove methods is not supported.\n+   *\n+   * @param c the collection of elements to remove\n+   * @return true if the set was modified as a result\n+   * @throws UnsupportedOperationException if remove is not supported\n+   * @throws NullPointerException if the collection is null\n+   * @see AbstractCollection#remove(Object)\n+   * @see Collection#contains(Object)\n+   * @see Iterator#remove()\n+   */\n+  public boolean removeAll(Collection c)\n+  {\n+    int oldsize = size();\n+    int count = c.size();\n+    Iterator i;\n+    if (oldsize < count)\n       {\n-\tObject obj = itr.next();\n-\tif (obj != null)\n-\t  hash += obj.hashCode();\n+\tfor (i = iterator(), count = oldsize; count > 0; count--)\n+          if (c.contains(i.next()))\n+            i.remove();\n       }\n-    return hash;\n+    else\n+      for (i = c.iterator(); count > 0; count--)\n+        remove(i.next());\n+    return oldsize != size();\n   }\n+\n }"}, {"sha": "3c75e56672fe550b74b5d1a3e85c836695e54910", "filename": "libjava/java/util/ArrayList.java", "status": "modified", "additions": 371, "deletions": 219, "changes": 590, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2Fjava%2Futil%2FArrayList.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2Fjava%2Futil%2FArrayList.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FArrayList.java?ref=d9fd7154ec7908eff8bbbce75651eccf51064ac1", "patch": "@@ -1,6 +1,6 @@\n /* ArrayList.java -- JDK1.2's answer to Vector; this is an array-backed\n    implementation of the List interface\n-   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -35,383 +35,535 @@\n import java.io.ObjectOutputStream;\n \n /**\n- * An array-backed implementation of the List interface.  ArrayList\n- * performs well on simple tasks:  random access into a list, appending\n- * to or removing from the end of a list, checking the size, &c.\n+ * An array-backed implementation of the List interface.  This implements\n+ * all optional list operations, and permits null elements, so that it is\n+ * better than Vector, which it replaces. Random access is roughly constant\n+ * time, and iteration is roughly linear time, so it is nice and fast, with\n+ * less overhead than a LinkedList.\n+ * <p>\n  *\n- * @author        Jon A. Zeppieri\n- * @see           java.util.AbstractList\n- * @see           java.util.List\n+ * Each list has a capacity, and as the array reaches that capacity it\n+ * is automatically transferred to a larger array. You also have access to\n+ * ensureCapacity and trimToSize to control the backing array's size, avoiding\n+ * reallocation or wasted memory.\n+ * <p>\n+ *\n+ * ArrayList is not synchronized, so if you need multi-threaded access,\n+ * consider using:<br>\n+ * <code>List l = Collections.synchronizedList(new ArrayList(...));</code>\n+ * <p>\n+ *\n+ * The iterators are <i>fail-fast</i>, meaning that any structural\n+ * modification, except for <code>remove()</code> called on the iterator\n+ * itself, cause the iterator to throw a\n+ * {@link ConcurrentModificationException} rather than exhibit\n+ * non-deterministic behavior.\n+ *\n+ * @author Jon A. Zeppieri\n+ * @author Bryce McKinlay\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @see Collection\n+ * @see List\n+ * @see LinkedList\n+ * @see Vector\n+ * @see Collections#synchronizedList(List)\n+ * @see AbstractList\n+ * @status updated to 1.4\n  */\n public class ArrayList extends AbstractList\n-  implements List, Cloneable, Serializable\n+  implements List, RandomAccess, Cloneable, Serializable\n {\n-  /** the default capacity for new ArrayLists */\n+  /**\n+   * Compatible with JDK 1.2\n+   */\n+  private static final long serialVersionUID = 8683452581122892189L;\n+\n+  /**\n+   * The default capacity for new ArrayLists.\n+   */\n   private static final int DEFAULT_CAPACITY = 16;\n \n-  /** the number of elements in this list */\n-  int size;\n+  /**\n+   * The number of elements in this list.\n+   * @serial the list size\n+   */\n+  private int size;\n \n-  /** where the data is stored */\n-  transient Object[] data;\n+  /**\n+   * Where the data is stored.\n+   */\n+  private transient Object[] data;\n \n-  /** \n-   * Construct a new ArrayList with the supplied initial capacity. \n+  /**\n+   * Construct a new ArrayList with the supplied initial capacity.\n    *\n-   * @param capacity Initial capacity of this ArrayList\n+   * @param capacity initial capacity of this ArrayList\n+   * @throws IllegalArgumentException if capacity is negative\n    */\n   public ArrayList(int capacity)\n   {\n+    // Must explicitly check, to get correct exception.\n+    if (capacity < 0)\n+      throw new IllegalArgumentException();\n     data = new Object[capacity];\n   }\n \n-\n   /**\n-   * Construct a new ArrayList with the default capcity \n+   * Construct a new ArrayList with the default capcity (16).\n    */\n   public ArrayList()\n   {\n     this(DEFAULT_CAPACITY);\n   }\n \n-  /** \n+  /**\n    * Construct a new ArrayList, and initialize it with the elements\n-   * in the supplied Collection; Sun specs say that the initial \n-   * capacity is 110% of the Collection's size.\n+   * in the supplied Collection. The initial capacity is 110% of the\n+   * Collection's size.\n    *\n    * @param c the collection whose elements will initialize this list\n+   * @throws NullPointerException if c is null\n    */\n   public ArrayList(Collection c)\n   {\n-    this((int) (c.size() * 1.1));\n+    this((int) (c.size() * 1.1f));\n     addAll(c);\n   }\n \n+  /**\n+   * Trims the capacity of this List to be equal to its size;\n+   * a memory saver.\n+   */\n+  public void trimToSize()\n+  {\n+    // Not a structural change from the perspective of iterators on this list,\n+    // so don't update modCount.\n+    if (size != data.length)\n+      {\n+        Object[] newData = new Object[size];\n+        System.arraycopy(data, 0, newData, 0, size);\n+        data = newData;\n+      }\n+  }\n+\n   /**\n    * Guarantees that this list will have at least enough capacity to\n-   * hold minCapacity elements. \n+   * hold minCapacity elements. This implementation will grow the list to\n+   * max(current * 2, minCapacity) if (minCapacity > current). The JCL says\n+   * explictly that \"this method increases its capacity to minCap\", while\n+   * the JDK 1.3 online docs specify that the list will grow to at least the\n+   * size specified.\n    *\n-   * @specnote This implementation will grow the list to \n-   *   max(current * 2, minCapacity) if (minCapacity > current). The JCL says\n-   *   explictly that \"this method increases its capacity to minCap\", while\n-   *   the JDK 1.3 online docs specify that the list will grow to at least the\n-   *   size specified.\n    * @param minCapacity the minimum guaranteed capacity\n    */\n   public void ensureCapacity(int minCapacity)\n   {\n-    Object[] newData;\n     int current = data.length;\n \n     if (minCapacity > current)\n       {\n-\tnewData = new Object[Math.max((current * 2), minCapacity)];\n-\tSystem.arraycopy(data, 0, newData, 0, size);\n-\tdata = newData;\n+        Object[] newData = new Object[Math.max(current * 2, minCapacity)];\n+        System.arraycopy(data, 0, newData, 0, size);\n+        data = newData;\n       }\n   }\n \n   /**\n-   * Appends the supplied element to the end of this list.\n+   * Returns the number of elements in this list.\n    *\n-   * @param       e      the element to be appended to this list\n+   * @return the list size\n    */\n-  public boolean add(Object e)\n+  public int size()\n   {\n-    modCount++;\n-    if (size == data.length)\n-      ensureCapacity(size + 1);\n-    data[size++] = e;\n-    return true;\n+    return size;\n   }\n \n   /**\n-   * Retrieves the element at the user-supplied index.\n+   * Checks if the list is empty.\n    *\n-   * @param    index        the index of the element we are fetching\n-   * @throws   IndexOutOfBoundsException  (iIndex < 0) || (iIndex >= size())\n+   * @return true if there are no elements\n    */\n-  public Object get(int index)\n+  public boolean isEmpty()\n   {\n-    if (index < 0 || index >= size)\n-      throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size:\" + \n-                                          size);\n-    return data[index];\n+    return size == 0;\n   }\n \n   /**\n-   * Returns the number of elements in this list \n+   * Returns true iff element is in this ArrayList.\n+   *\n+   * @param e the element whose inclusion in the List is being tested\n+   * @return true if the list contains e\n    */\n-  public int size()\n+  public boolean contains(Object e)\n   {\n-    return size;\n+    return indexOf(e) != -1;\n   }\n \n   /**\n-   * Removes the element at the user-supplied index\n+   * Returns the lowest index at which element appears in this List, or\n+   * -1 if it does not appear.\n    *\n-   * @param     iIndex      the index of the element to be removed\n-   * @return    the removed Object\n-   * @throws    IndexOutOfBoundsException  (iIndex < 0) || (iIndex >= size())\n+   * @param e the element whose inclusion in the List is being tested\n+   * @return the index where e was found\n    */\n-  public Object remove(int index)\n+  public int indexOf(Object e)\n   {\n-    modCount++;\n-    if (index < 0 || index > size)\n-      throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size:\" + \n-                                          size);\n-    Object r = data[index];\n-    if (index != --size)\n-      System.arraycopy(data, (index + 1), data, index, (size - index));\n-    data[size] = null;\n-    return r;\n+    for (int i = 0; i < size; i++)\n+      if (equals(e, data[i]))\n+        return i;\n+    return -1;\n   }\n \n   /**\n-   * Removes all elements in the half-open interval [iFromIndex, iToIndex).\n+   * Returns the highest index at which element appears in this List, or\n+   * -1 if it does not appear.\n    *\n-   * @param     fromIndex   the first index which will be removed\n-   * @param     toIndex     one greater than the last index which will be \n-   *                         removed\n+   * @param e the element whose inclusion in the List is being tested\n+   * @return the index where e was found\n    */\n-  protected void removeRange(int fromIndex, int toIndex)\n+  public int lastIndexOf(Object e)\n   {\n-    modCount++;\n-    if (fromIndex != toIndex)\n+    for (int i = size - 1; i >= 0; i--)\n+      if (equals(e, data[i]))\n+        return i;\n+    return -1;\n+  }\n+\n+  /**\n+   * Creates a shallow copy of this ArrayList (elements are not cloned).\n+   *\n+   * @return the cloned object\n+   */\n+  public Object clone()\n+  {\n+    ArrayList clone = null;\n+    try\n+      {\n+        clone = (ArrayList) super.clone();\n+        clone.data = (Object[]) data.clone();\n+      }\n+    catch (CloneNotSupportedException e)\n       {\n-\tSystem.arraycopy(data, toIndex, data, fromIndex, size - toIndex);\n-\tsize -= (toIndex - fromIndex);\n+        // Impossible to get here.\n       }\n+    return clone;\n+  }\n+\n+  /**\n+   * Returns an Object array containing all of the elements in this ArrayList.\n+   * The array is independent of this list.\n+   *\n+   * @return an array representation of this list\n+   */\n+  public Object[] toArray()\n+  {\n+    Object[] array = new Object[size];\n+    System.arraycopy(data, 0, array, 0, size);\n+    return array;\n+  }\n+\n+  /**\n+   * Returns an Array whose component type is the runtime component type of\n+   * the passed-in Array.  The returned Array is populated with all of the\n+   * elements in this ArrayList.  If the passed-in Array is not large enough\n+   * to store all of the elements in this List, a new Array will be created\n+   * and returned; if the passed-in Array is <i>larger</i> than the size\n+   * of this List, then size() index will be set to null.\n+   *\n+   * @param a the passed-in Array\n+   * @return an array representation of this list\n+   * @throws ArrayStoreException if the runtime type of a does not allow\n+   *         an element in this list\n+   * @throws NullPointerException if a is null\n+   */\n+  public Object[] toArray(Object[] a)\n+  {\n+    if (a.length < size)\n+      a = (Object[]) Array.newInstance(a.getClass().getComponentType(),\n+                                       size);\n+    else if (a.length > size)\n+      a[size] = null;\n+    System.arraycopy(data, 0, a, 0, size);\n+    return a;\n+  }\n+\n+  /**\n+   * Retrieves the element at the user-supplied index.\n+   *\n+   * @param index the index of the element we are fetching\n+   * @throws IndexOutOfBoundsException if index &lt; 0 || index &gt;= size()\n+   */\n+  public Object get(int index)\n+  {\n+    checkBoundExclusive(index);\n+    return data[index];\n+  }\n+\n+  /**\n+   * Sets the element at the specified index.\n+   *\n+   * @param index the index at which the element is being set\n+   * @param e the element to be set\n+   * @return the element previously at the specified index\n+   * @throws IndexOutOfBoundsException if index &lt; 0 || index &gt;= 0\n+   */\n+  public Object set(int index, Object e)\n+  {\n+    checkBoundExclusive(index);\n+    Object result = data[index];\n+    data[index] = e;\n+    return result;\n+  }\n+\n+  /**\n+   * Appends the supplied element to the end of this list.\n+   *\n+   * @param e the element to be appended to this list\n+   * @return true, the add will always succeed\n+   */\n+  public boolean add(Object e)\n+  {\n+    modCount++;\n+    if (size == data.length)\n+      ensureCapacity(size + 1);\n+    data[size++] = e;\n+    return true;\n   }\n \n   /**\n    * Adds the supplied element at the specified index, shifting all\n    * elements currently at that index or higher one to the right.\n    *\n-   * @param     index      the index at which the element is being added\n-   * @param     e          the item being added\n+   * @param index the index at which the element is being added\n+   * @param e the item being added\n+   * @throws IndexOutOfBoundsException if index &lt; 0 || index &gt; size()\n    */\n   public void add(int index, Object e)\n   {\n+    checkBoundInclusive(index);\n     modCount++;\n-    if (index < 0 || index > size)\n-      throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size:\" + \n-                                          size);\n     if (size == data.length)\n       ensureCapacity(size + 1);\n     if (index != size)\n-      System.arraycopy(data, index, data, index + 1, size - index);    \n+      System.arraycopy(data, index, data, index + 1, size - index);\n     data[index] = e;\n     size++;\n   }\n \n-  /** \n-   * Add each element in the supplied Collection to this List.\n+  /**\n+   * Removes the element at the user-supplied index.\n+   *\n+   * @param index the index of the element to be removed\n+   * @return the removed Object\n+   * @throws IndexOutOfBoundsException if index &lt; 0 || index &gt;= size()\n+   */\n+  public Object remove(int index)\n+  {\n+    checkBoundExclusive(index);\n+    Object r = data[index];\n+    modCount++;\n+    if (index != --size)\n+      System.arraycopy(data, index + 1, data, index, size - index);\n+    // Aid for garbage collection by releasing this pointer.\n+    data[size] = null;\n+    return r;\n+  }\n+\n+  /**\n+   * Removes all elements from this List\n+   */\n+  public void clear()\n+  {\n+    if (size > 0)\n+      {\n+        modCount++;\n+        // Allow for garbage collection.\n+        Arrays.fill(data, 0, size, null);\n+        size = 0;\n+      }\n+  }\n+\n+  /**\n+   * Add each element in the supplied Collection to this List. It is undefined\n+   * what happens if you modify the list while this is taking place; for\n+   * example, if the collection contains this list.\n    *\n-   * @param        c          a Collection containing elements to be \n-   *                          added to this List\n+   * @param c a Collection containing elements to be added to this List\n+   * @return true if the list was modified, in other words c is not empty\n+   * @throws NullPointerException if c is null\n    */\n   public boolean addAll(Collection c)\n   {\n     return addAll(size, c);\n   }\n \n-  /** \n+  /**\n    * Add all elements in the supplied collection, inserting them beginning\n    * at the specified index.\n    *\n-   * @param     index       the index at which the elements will be inserted\n-   * @param     c           the Collection containing the elements to be\n-   *                        inserted\n+   * @param index the index at which the elements will be inserted\n+   * @param c the Collection containing the elements to be inserted\n+   * @throws IndexOutOfBoundsException if index &lt; 0 || index &gt; 0\n+   * @throws NullPointerException if c is null\n    */\n   public boolean addAll(int index, Collection c)\n   {\n-    if (index < 0 || index > size)\n-      throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size:\" + \n-                                          size);\n-    modCount++;\n+    checkBoundInclusive(index);\n     Iterator itr = c.iterator();\n     int csize = c.size();\n \n+    modCount++;\n     if (csize + size > data.length)\n       ensureCapacity(size + csize);\n     int end = index + csize;\n-    if (size > 0 && index != size)\n+    if (index != size)\n       System.arraycopy(data, index, data, end, csize);\n     size += csize;\n-    for (; index < end; index++)\n-      {\n-        data[index] = itr.next();\n-      }\n-    return (csize > 0);\n+    for ( ; index < end; index++)\n+      data[index] = itr.next();\n+    return csize > 0;\n   }\n \n   /**\n-   * Creates a shallow copy of this ArrayList\n+   * Removes all elements in the half-open interval [fromIndex, toIndex).\n+   * You asked for it if you call this with invalid arguments.\n+   *\n+   * @param fromIndex the first index which will be removed\n+   * @param toIndex one greater than the last index which will be removed\n    */\n-  public Object clone()\n+  protected void removeRange(int fromIndex, int toIndex)\n   {\n-    ArrayList clone = null;\n-    try\n+    if (fromIndex != toIndex)\n       {\n-\tclone = (ArrayList) super.clone();\n-\tclone.data = new Object[data.length];\n-\tSystem.arraycopy(data, 0, clone.data, 0, size);\n+        modCount++;\n+        System.arraycopy(data, toIndex, data, fromIndex, size - toIndex);\n+        size -= toIndex - fromIndex;\n       }\n-    catch (CloneNotSupportedException e) {}\n-    return clone;\n   }\n \n-  /** \n-   * Returns true iff oElement is in this ArrayList.\n+  /**\n+   * Checks that the index is in the range of possible elements (inclusive).\n    *\n-   * @param     e     the element whose inclusion in the List is being\n-   *                  tested\n+   * @param index the index to check\n+   * @throws IndexOutOfBoundsException if index &gt; size\n    */\n-  public boolean contains(Object e)\n+  private void checkBoundInclusive(int index)\n   {\n-    return (indexOf(e) != -1);\n+    // Implementation note: we do not check for negative ranges here, since\n+    // use of a negative index will cause an ArrayIndexOutOfBoundsException,\n+    // a subclass of the required exception, with no effort on our part.\n+    if (index > size)\n+      throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \"\n+                                          + size);\n   }\n \n   /**\n-   * Returns the lowest index at which oElement appears in this List, or \n-   * -1 if it does not appear.\n+   * Checks that the index is in the range of existing elements (exclusive).\n    *\n-   * @param    e       the element whose inclusion in the List is being\n-   *                   tested\n+   * @param index the index to check\n+   * @throws IndexOutOfBoundsException if index &gt;= size\n    */\n-  public int indexOf(Object e)\n+  private void checkBoundExclusive(int index)\n   {\n-    for (int i = 0; i < size; i++)\n-      {\n-\tif (e == null ? data[i] == null : e.equals(data[i]))\n-\t  return i;\n-      }\n-    return -1;\n+    // Implementation note: we do not check for negative ranges here, since\n+    // use of a negative index will cause an ArrayIndexOutOfBoundsException,\n+    // a subclass of the required exception, with no effort on our part.\n+    if (index >= size)\n+      throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \"\n+                                          + size);\n   }\n \n   /**\n-   * Returns the highest index at which oElement appears in this List, or \n-   * -1 if it does not appear.\n+   * Remove from this list all elements contained in the given collection.\n+   * This is not public, due to Sun's API, but this performs in linear\n+   * time while the default behavior of AbstractList would be quadratic.\n    *\n-   * @param    e       the element whose inclusion in the List is being\n-   *                   tested\n+   * @param c the collection to filter out\n+   * @return true if this list changed\n+   * @throws NullPointerException if c is null\n    */\n-  public int lastIndexOf(Object e)\n+  boolean removeAllInternal(Collection c)\n   {\n     int i;\n+    int j;\n+    for (i = 0; i < size; i++)\n+      if (c.contains(data[i]))\n+        break;\n+    if (i == size)\n+      return false;\n \n-    for (i = size - 1; i >= 0; i--)\n-      {\n-\tif (e == null ? data[i] == null : e.equals(data[i]))\n-\t  return i;\n-      }\n-    return -1;\n-  }\n-\n-  /**\n-   * Removes all elements from this List\n-   */\n-  public void clear()\n-  {\n     modCount++;\n-    for (int i = 0; i < size; i++)\n-      {\n-\tdata[i] = null;\n-      }    \n-    size = 0;\n+    for (j = i++; i < size; i++)\n+      if (! c.contains(data[i]))\n+        data[j++] = data[i];\n+    size -= i - j;\n+    return true;\n   }\n \n   /**\n-   * Sets the element at the specified index.\n+   * Retain in this vector only the elements contained in the given collection.\n+   * This is not public, due to Sun's API, but this performs in linear\n+   * time while the default behavior of AbstractList would be quadratic.\n    *\n-   * @param     index   the index at which the element is being set\n-   * @param     e       the element to be set\n-   * @return    the element previously at the specified index, or null if\n-   *            none was there\n+   * @param c the collection to filter by\n+   * @return true if this vector changed\n+   * @throws NullPointerException if c is null\n+   * @since 1.2\n    */\n-  public Object set(int index, Object e)\n+  boolean retainAllInternal(Collection c)\n   {\n-    Object result;\n-    if (index < 0 || index >= size)\n-      throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size:\" + \n-                                          size);\n-    result = data[index];\n-    // SEH: no structural change, so don't update modCount\n-    data[index] = e;\n-    return result;\n-  }\n+    int i;\n+    int j;\n+    for (i = 0; i < size; i++)\n+      if (! c.contains(data[i]))\n+        break;\n+    if (i == size)\n+      return false;\n \n-  /**\n-   * Returns an Object Array containing all of the elements in this ArrayList\n-   */\n-  public Object[] toArray()\n-  {\n-    Object[] array = new Object[size];\n-    System.arraycopy(data, 0, array, 0, size);\n-    return array;\n+    modCount++;\n+    for (j = i++; i < size; i++)\n+      if (c.contains(data[i]))\n+        data[j++] = data[i];\n+    size -= i - j;\n+    return true;\n   }\n \n   /**\n-   * Returns an Array whose component type is the runtime component type of\n-   * the passed-in Array.  The returned Array is populated with all of the\n-   * elements in this ArrayList.  If the passed-in Array is not large enough\n-   * to store all of the elements in this List, a new Array will be created \n-   * and returned; if the passed-in Array is <i>larger</i> than the size\n-   * of this List, then size() index will be set to null.\n+   * Serializes this object to the given stream.\n    *\n-   * @param      array      the passed-in Array\n+   * @param out the stream to write to\n+   * @throws IOException if the underlying stream fails\n+   * @serialData the size field (int), the length of the backing array\n+   *             (int), followed by its elements (Objects) in proper order.\n    */\n-  public Object[] toArray(Object[] array)\n+  private void writeObject(ObjectOutputStream s) throws IOException\n   {\n-    if (array.length < size)\n-      array = (Object[]) Array.newInstance(array.getClass().getComponentType(), \n-        \t\t\t\t   size);\n-    else if (array.length > size)\n-      array[size] = null;\n-    System.arraycopy(data, 0, array, 0, size);\n-    return array;\n+    // The 'size' field.\n+    s.defaultWriteObject();\n+    // We serialize unused list entries to preserve capacity.\n+    int len = data.length;\n+    s.writeInt(len);\n+    for (int i = 0; i < len; i++)\n+      s.writeObject(data[i]);\n   }\n \n   /**\n-   * Trims the capacity of this List to be equal to its size; \n-   * a memory saver.   \n+   * Deserializes this object from the given stream.\n+   *\n+   * @param in the stream to read from\n+   * @throws ClassNotFoundException if the underlying stream fails\n+   * @throws IOException if the underlying stream fails\n+   * @serialData the size field (int), the length of the backing array\n+   *             (int), followed by its elements (Objects) in proper order.\n    */\n-  public void trimToSize()\n-  {\n-    // not a structural change from the perspective of iterators on this list, \n-    // so don't update modCount\n-    Object[] newData = new Object[size];\n-    System.arraycopy(data, 0, newData, 0, size);\n-    data = newData;\n-  }\n-\n-  private void writeObject(ObjectOutputStream out) throws IOException\n-  {\n-    int i;\n-\n-    // The 'size' field.\n-    out.defaultWriteObject();\n-\n-    // FIXME: Do we really want to serialize unused list entries??\n-    out.writeInt(data.length);\n-    for (i = 0; i < data.length; i++)\n-      out.writeObject(data[i]);\n-  }\n-\n-  private void readObject(ObjectInputStream in)\n+  private void readObject(ObjectInputStream s)\n     throws IOException, ClassNotFoundException\n   {\n-    int i;\n-    int capacity;\n-\n     // the `size' field.\n-    in.defaultReadObject();\n-\n-    capacity = in.readInt();\n+    s.defaultReadObject();\n+    int capacity = s.readInt();\n     data = new Object[capacity];\n-\n-    for (i = 0; i < capacity; i++)\n-      data[i] = in.readObject();\n+    for (int i = 0; i < capacity; i++)\n+      data[i] = s.readObject();\n   }\n }"}, {"sha": "d52431b7b3f88f601384da073818ec628d188608", "filename": "libjava/java/util/Arrays.java", "status": "modified", "additions": 1629, "deletions": 1284, "changes": 2913, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2Fjava%2Futil%2FArrays.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2Fjava%2Futil%2FArrays.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FArrays.java?ref=d9fd7154ec7908eff8bbbce75651eccf51064ac1"}, {"sha": "48fcc146664ab32f87b8e519cd9eab077f9b9c36", "filename": "libjava/java/util/BasicMapEntry.java", "status": "modified", "additions": 81, "deletions": 14, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2Fjava%2Futil%2FBasicMapEntry.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2Fjava%2Futil%2FBasicMapEntry.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FBasicMapEntry.java?ref=d9fd7154ec7908eff8bbbce75651eccf51064ac1", "patch": "@@ -1,6 +1,6 @@\n /* BasicMapEntry.java -- a class providing a plain-vanilla implementation of\n    the Map.Entry interface; could be used anywhere in java.util\n-   Copyright (C) 1998, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 2000, 2001 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -29,52 +29,113 @@\n package java.util;\n \n /**\n- * A class which implements Map.Entry. It is shared by HashMap, TreeMap, and\n- * Hashtable.\n+ * A class which implements Map.Entry. It is shared by HashMap, TreeMap,\n+ * Hashtable, and Collections. It is not specified by the JDK, but makes\n+ * life much easier.\n  *\n- * @author      Jon Zeppieri\n+ * @author Jon Zeppieri\n+ * @author Eric Blake <ebb9@email.byu.edu>\n  */\n class BasicMapEntry implements Map.Entry\n {\n+  /**\n+   * The key. Package visible for direct manipulation.\n+   */\n   Object key;\n+\n+  /**\n+   * The value. Package visible for direct manipulation.\n+   */\n   Object value;\n \n+  /**\n+   * Basic constructor initializes the fields.\n+   * @param newKey the key\n+   * @param newValue the value\n+   */\n   BasicMapEntry(Object newKey, Object newValue)\n   {\n     key = newKey;\n     value = newValue;\n   }\n \n+  /**\n+   * Compares the specified object with this entry. Returns true only if\n+   * the object is a mapping of identical key and value. In other words,\n+   * this must be:\n+   * <pre>\n+   * (o instanceof Map.Entry) &&\n+   * (getKey() == null ? ((HashMap) o).getKey() == null\n+   *                   : getKey().equals(((HashMap) o).getKey())) &&\n+   * (getValue() == null ? ((HashMap) o).getValue() == null\n+   *                   : getValue().equals(((HashMap) o).getValue()))\n+   * </pre>\n+   *\n+   * @param o the object to compare\n+   * @return true if it is equal\n+   */\n   public final boolean equals(Object o)\n   {\n-    if (!(o instanceof Map.Entry))\n+    if (! (o instanceof Map.Entry))\n       return false;\n+    // Optimize for our own entries.\n+    if (o instanceof BasicMapEntry)\n+      {\n+        BasicMapEntry e = (BasicMapEntry) o;\n+        return (AbstractCollection.equals(key, e.key)\n+                && AbstractCollection.equals(value, e.value));\n+      }\n     Map.Entry e = (Map.Entry) o;\n-    return (key == null ? e.getKey() == null : key.equals(e.getKey())\n-            && value == null ? e.getValue() == null \n-\t\t\t     : value.equals(e.getValue()));\n+    return (AbstractCollection.equals(key, e.getKey())\n+            && AbstractCollection.equals(value, e.getValue()));\n   }\n \n+  /**\n+   * Get the key corresponding to this entry.\n+   *\n+   * @return the key\n+   */\n   public final Object getKey()\n   {\n     return key;\n   }\n \n+  /**\n+   * Get the value corresponding to this entry. If you already called\n+   * Iterator.remove(), the behavior undefined, but in this case it works.\n+   *\n+   * @return the value\n+   */\n   public final Object getValue()\n   {\n     return value;\n   }\n \n+  /**\n+   * Returns the hash code of the entry.  This is defined as the exclusive-or\n+   * of the hashcodes of the key and value (using 0 for null). In other\n+   * words, this must be:\n+   * <pre>\n+   *  (getKey() == null ? 0 : getKey().hashCode()) ^\n+   *  (getValue() == null ? 0 : getValue().hashCode())\n+   * </pre>\n+   *\n+   * @return the hash code\n+   */\n   public final int hashCode()\n   {\n-    int kc = (key == null ? 0 : key.hashCode());\n-    int vc = (value == null ? 0 : value.hashCode());\n-    return kc ^ vc;\n+    return (AbstractCollection.hashCode(key)\n+            ^ AbstractCollection.hashCode(value));\n   }\n \n-  /** \n-   * sets the value of this Map.Entry. Note that this is overriden by \n-   * Hashtable.Entry, which does not permit a null value.\n+  /**\n+   * Replaces the value with the specified object. This writes through\n+   * to the map, unless you have already called Iterator.remove(). It\n+   * may be overridden to restrict a null value.\n+   *\n+   * @param newVal the new value to store\n+   * @return the old value\n+   * @throws NullPointerException if the map forbids null values\n    */\n   public Object setValue(Object newVal)\n   {\n@@ -83,6 +144,12 @@ public Object setValue(Object newVal)\n     return r;\n   }\n \n+  /**\n+   * This provides a string representation of the entry. It is of the form\n+   * \"key=value\", where string concatenation is used on key and value.\n+   *\n+   * @return the string representation\n+   */\n   public final String toString()\n   {\n     return key + \"=\" + value;"}, {"sha": "366c005333318c8da48950ef22f1595040ef796c", "filename": "libjava/java/util/BitSet.java", "status": "modified", "additions": 451, "deletions": 118, "changes": 569, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2Fjava%2Futil%2FBitSet.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2Fjava%2Futil%2FBitSet.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FBitSet.java?ref=d9fd7154ec7908eff8bbbce75651eccf51064ac1", "patch": "@@ -1,6 +1,5 @@\n-// BitSet - A vector of bits.\n-\n-/* Copyright (C) 1998, 1999, 2000  Free Software Foundation\n+/* BitSet.java -- A vector of bits.\n+   Copyright (C) 1998, 1999, 2000, 2001  Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -50,22 +49,32 @@\n  * while another thread is simultaneously modifying it, the results are\n  * undefined.\n  *\n- * @specnote Historically, there has been some confusion as to whether or not \n- *           this class should be synchronized. From an efficiency perspective,\n- *           it is very undesirable to synchronize it because multiple locks \n- *           and explicit lock ordering are required to safely synchronize some\n- *           methods. The JCL 1.2 supplement book specifies that as of JDK \n- *           1.2, the class is no longer synchronized.\n- *\n  * @author Jochen Hoenicke\n  * @author Tom Tromey <tromey@cygnus.com>\n- * @date October 23, 1998.\n- * @status API complete to JDK 1.3.\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @status updated to 1.4\n  */\n public class BitSet implements Cloneable, Serializable\n {\n   /**\n-   * Create a new empty bit set.\n+   * Compatible with JDK 1.0.\n+   */\n+  private static final long serialVersionUID = 7997698588986878753L;\n+\n+  /**\n+   * A common mask.\n+   */\n+  private static final int LONG_MASK = 0x3f;\n+\n+  /**\n+   * The actual bits.\n+   * @serial the i'th bit is in bits[i/64] at position i%64 (where position\n+   *         0 is the least significant).\n+   */\n+  private long[] bits;\n+\n+  /**\n+   * Create a new empty bit set. All bits are initially false.\n    */\n   public BitSet()\n   {\n@@ -75,18 +84,15 @@ public BitSet()\n   /**\n    * Create a new empty bit set, with a given size.  This\n    * constructor reserves enough space to represent the integers\n-   * from <code>0</code> to <code>nbits-1</code>.  \n-   * @param nbits the initial size of the bit set.\n-   * @throws NegativeArraySizeException if the specified initial\n-   * size is negative.  \n-   * @require nbits >= 0\n+   * from <code>0</code> to <code>nbits-1</code>.\n+   *\n+   * @param nbits the initial size of the bit set\n+   * @throws NegativeArraySizeException if nbits &lt; 0\n    */\n   public BitSet(int nbits)\n   {\n-    if (nbits < 0)\n-      throw new NegativeArraySizeException();\n-    int length = nbits / 64;\n-    if (nbits % 64 != 0)\n+    int length = nbits >>> 6;\n+    if ((nbits & LONG_MASK) != 0)\n       ++length;\n     bits = new long[length];\n   }\n@@ -95,72 +101,153 @@ public BitSet(int nbits)\n    * Performs the logical AND operation on this bit set and the\n    * given <code>set</code>.  This means it builds the intersection\n    * of the two sets.  The result is stored into this bit set.\n-   * @param set the second bit set.\n-   * @require set != null\n+   *\n+   * @param set the second bit set\n+   * @throws NullPointerException if set is null\n    */\n   public void and(BitSet bs)\n   {\n     int max = Math.min(bits.length, bs.bits.length);\n     int i;\n     for (i = 0; i < max; ++i)\n       bits[i] &= bs.bits[i];\n-    for (; i < bits.length; ++i)\n-      bits[i] = 0;\n+    while (i < bits.length)\n+      bits[i++] = 0;\n   }\n \n   /**\n    * Performs the logical AND operation on this bit set and the\n    * complement of the given <code>set</code>.  This means it\n    * selects every element in the first set, that isn't in the\n-   * second set.  The result is stored into this bit set.  \n-   * @param set the second bit set.  \n-   * @require set != null\n-   * @since JDK1.2\n+   * second set.  The result is stored into this bit set.\n+   *\n+   * @param set the second bit set\n+   * @throws NullPointerException if set is null\n+   * @since 1.2\n    */\n   public void andNot(BitSet bs)\n   {\n-    int max = Math.min(bits.length, bs.bits.length);\n-    int i;\n-    for (i = 0; i < max; ++i)\n+    int i = Math.min(bits.length, bs.bits.length);\n+    while (--i >= 0)\n       bits[i] &= ~bs.bits[i];\n   }\n \n+  /**\n+   * Returns the number of bits set to true.\n+   *\n+   * @return the number of true bits\n+   * @since 1.4\n+   */\n+  public int cardinality()\n+  {\n+    int card = 0;\n+    for (int i = bits.length - 1; i >= 0; i--)\n+      {\n+        long a = bits[i];\n+        // Take care of common cases.\n+        if (a == 0)\n+          continue;\n+        if (a == -1)\n+          {\n+            card += 64;\n+            continue;\n+          }\n+\n+        // Successively collapse alternating bit groups into a sum.\n+        a = ((a >> 1) & 0x5555555555555555L) + (a & 0x5555555555555555L);\n+        a = ((a >> 2) & 0x3333333333333333L) + (a & 0x3333333333333333L);\n+        int b = (int) ((a >>> 32) + a);\n+        b = ((b >> 4) & 0x0f0f0f0f) + (b & 0x0f0f0f0f);\n+        b = ((b >> 8) & 0x00ff00ff) + (b & 0x00ff00ff);\n+        card += ((b >> 16) & 0x0000ffff) + (b & 0x0000ffff);\n+      }\n+    return card;\n+  }\n+\n+  /**\n+   * Sets all bits in the set to false.\n+   *\n+   * @since 1.4\n+   */\n+  public void clear()\n+  {\n+    Arrays.fill(bits, 0);\n+  }\n+\n   /**\n    * Removes the integer <code>bitIndex</code> from this set. That is\n    * the corresponding bit is cleared.  If the index is not in the set,\n    * this method does nothing.\n-   * @param bitIndex a non-negative integer.\n-   * @exception ArrayIndexOutOfBoundsException if the specified bit index\n-   * is negative.\n-   * @require bitIndex >= 0\n+   *\n+   * @param bitIndex a non-negative integer\n+   * @throws IndexOutOfBoundsException if bitIndex &lt; 0\n    */\n   public void clear(int pos)\n   {\n-    if (pos < 0)\n-      throw new IndexOutOfBoundsException();\n-    int bit = pos % 64;\n-    int offset = pos / 64;\n+    int offset = pos >>> 6;\n     ensure(offset);\n-    bits[offset] &= ~(1L << bit);\n+    // ArrayIndexOutOfBoundsException subclasses IndexOutOfBoundsException,\n+    // so we'll just let that be our exception.\n+    bits[offset] &= ~(1L << pos);\n+  }\n+\n+  /**\n+   * Sets the bits between from (inclusive) and to (exclusive) to false.\n+   *\n+   * @param from the start range (inclusive)\n+   * @param to the end range (exclusive)\n+   * @throws IndexOutOfBoundsException if from &lt; 0 || from &gt; to\n+   * @since 1.4\n+   */\n+  public void clear(int from, int to)\n+  {\n+    if (from < 0 || from > to)\n+      throw new IndexOutOfBoundsException();\n+    if (from == to)\n+      return;\n+    int lo_offset = from >>> 6;\n+    int hi_offset = to >>> 6;\n+    ensure(hi_offset);\n+    if (lo_offset == hi_offset)\n+      {\n+        bits[hi_offset] &= ((1L << from) - 1) | (-1L << to);\n+        return;\n+      }\n+\n+    bits[lo_offset] &= (1L << from) - 1;\n+    bits[hi_offset] &= -1L << to;\n+    for (int i = lo_offset + 1; i < hi_offset; i++)\n+      bits[i] = 0;\n   }\n \n   /**\n    * Create a clone of this bit set, that is an instance of the same\n    * class and contains the same elements.  But it doesn't change when\n    * this bit set changes.\n+   *\n    * @return the clone of this object.\n    */\n   public Object clone()\n   {\n-    BitSet bs = new BitSet(bits.length * 64);\n-    System.arraycopy(bits, 0, bs.bits, 0, bits.length);\n-    return bs;\n+    try\n+      {\n+        BitSet bs = (BitSet) super.clone();\n+        bs.bits = (long[]) bits.clone();\n+        return bs;\n+      }\n+    catch (CloneNotSupportedException e)\n+      {\n+        // Impossible to get here.\n+        return null;\n+      }\n   }\n \n   /**\n    * Returns true if the <code>obj</code> is a bit set that contains\n    * exactly the same elements as this bit set, otherwise false.\n-   * @return true if obj equals this bit set.\n+   *\n+   * @param obj the object to compare to\n+   * @return true if obj equals this bit set\n    */\n   public boolean equals(Object obj)\n   {\n@@ -171,42 +258,124 @@ public boolean equals(Object obj)\n     int i;\n     for (i = 0; i < max; ++i)\n       if (bits[i] != bs.bits[i])\n-\treturn false;\n+        return false;\n     // If one is larger, check to make sure all extra bits are 0.\n     for (int j = i; j < bits.length; ++j)\n       if (bits[j] != 0)\n-\treturn false;\n+        return false;\n     for (int j = i; j < bs.bits.length; ++j)\n       if (bs.bits[j] != 0)\n-\treturn false;\n+        return false;\n     return true;\n   }\n \n   /**\n-   * Returns true if the integer <code>bitIndex</code> is in this bit\n-   * set, otherwise false.\n-   * @param bitIndex a non-negative integer\n-   * @return the value of the bit at the specified index.\n-   * @exception ArrayIndexOutOfBoundsException if the specified bit index\n-   * is negative.\n-   * @require bitIndex >= 0\n+   * Sets the bit at the index to the opposite value.\n+   *\n+   * @param index the index of the bit\n+   * @throws IndexOutOfBoundsException if index is negative\n+   * @since 1.4\n    */\n-  public boolean get(int pos)\n+  public void flip(int index)\n   {\n-    if (pos < 0)\n+    int offset = index >>> 6;\n+    ensure(offset);\n+    // ArrayIndexOutOfBoundsException subclasses IndexOutOfBoundsException,\n+    // so we'll just let that be our exception.\n+    bits[offset] ^= 1L << index;\n+  }\n+\n+  /**\n+   * Sets a range of bits to the opposite value.\n+   *\n+   * @param from the low index (inclusive)\n+   * @param to the high index (exclusive)\n+   * @throws IndexOutOfBoundsException if from &gt; to || from &lt; 0\n+   * @since 1.4\n+   */\n+  public void flip(int from, int to)\n+  {\n+    if (from < 0 || from > to)\n       throw new IndexOutOfBoundsException();\n+    if (from == to)\n+      return;\n+    int lo_offset = from >>> 6;\n+    int hi_offset = to >>> 6;\n+    ensure(hi_offset);\n+    if (lo_offset == hi_offset)\n+      {\n+        bits[hi_offset] ^= (-1L << from) & ((1L << to) - 1);\n+        return;\n+      }\n \n-    int bit = pos % 64;\n-    int offset = pos / 64;\n+    bits[lo_offset] ^= -1L << from;\n+    bits[hi_offset] ^= (1L << to) - 1;\n+    for (int i = lo_offset + 1; i < hi_offset; i++)\n+      bits[i] ^= -1;\n+  }\n \n+  /**\n+   * Returns true if the integer <code>bitIndex</code> is in this bit\n+   * set, otherwise false.\n+   *\n+   * @param pos a non-negative integer\n+   * @return the value of the bit at the specified index\n+   * @throws IndexOutOfBoundsException if the index is negative\n+   */\n+  public boolean get(int pos)\n+  {\n+    int offset = pos >>> 6;\n     if (offset >= bits.length)\n       return false;\n+    // ArrayIndexOutOfBoundsException subclasses IndexOutOfBoundsException,\n+    // so we'll just let that be our exception.\n+    return (bits[offset] & (1L << pos)) != 0;\n+  }\n+\n+  /**\n+   * Returns a new <code>BitSet</code> composed of a range of bits from\n+   * this one.\n+   *\n+   * @param from the low index (inclusive)\n+   * @param to the high index (exclusive)\n+   * @throws IndexOutOfBoundsException if from &gt; to || from &lt; 0\n+   * @since 1.4\n+   */\n+  public BitSet get(int from, int to)\n+  {\n+    if (from < 0 || from > to)\n+      throw new IndexOutOfBoundsException();\n+    BitSet bs = new BitSet(to - from);\n+    int lo_offset = from >>> 6;\n+    if (lo_offset >= bits.length)\n+      return bs;\n+\n+    int lo_bit = from & LONG_MASK;\n+    int hi_offset = to >>> 6;\n+    if (lo_bit == 0)\n+      {\n+        int len = Math.min(hi_offset - lo_offset + 1, bits.length - lo_offset);\n+        System.arraycopy(bits, lo_offset, bs.bits, 0, len);\n+        if (hi_offset < bits.length)\n+          bs.bits[hi_offset - lo_offset] &= (1L << to) - 1;\n+        return bs;\n+      }\n \n-    return (bits[offset] & (1L << bit)) == 0 ? false : true;\n+    int len = Math.min(hi_offset, bits.length - 1);\n+    int reverse = ~lo_bit;\n+    int i;\n+    for (i = 0; lo_offset < len; lo_offset++, i++)\n+      bs.bits[i] = ((bits[lo_offset] >>> lo_bit)\n+                    | (bits[lo_offset + 1] << reverse));\n+    if ((to & LONG_MASK) > lo_bit)\n+      bs.bits[i++] = bits[lo_offset] >>> lo_bit;\n+    if (hi_offset < bits.length)\n+      bs.bits[i - 1] &= (1L << (to - from)) - 1;\n+    return bs;\n   }\n \n   /**\n-   * Returns a hash code value for this bit set.  The hash code of \n+   * Returns a hash code value for this bit set.  The hash code of\n    * two bit sets containing the same integers is identical.  The algorithm\n    * used to compute it is as follows:\n    *\n@@ -233,21 +402,55 @@ public boolean get(int pos)\n    * </pre>\n    *\n    * Note that the hash code values changes, if the set is changed.\n+   *\n    * @return the hash code value for this bit set.\n    */\n   public int hashCode()\n   {\n     long h = 1234;\n-    for (int i = bits.length - 1; i >= 0; --i)\n-      h ^= bits[i] * (i + 1);\n+    for (int i = bits.length; i > 0; )\n+      h ^= i * bits[--i];\n     return (int) ((h >> 32) ^ h);\n   }\n \n+  /**\n+   * Returns true if the specified BitSet and this one share at least one\n+   * common true bit.\n+   *\n+   * @param set the set to check for intersection\n+   * @return true if the sets intersect\n+   * @throws NullPointerException if set is null\n+   * @since 1.4\n+   */\n+  public boolean intersects(BitSet set)\n+  {\n+    int i = Math.min(bits.length, set.bits.length);\n+    while (--i >= 0)\n+      if ((bits[i] & set.bits[i]) != 0)\n+        return true;\n+    return false;\n+  }\n+\n+  /**\n+   * Returns true if this set contains no true bits.\n+   *\n+   * @return true if all bits are false\n+   * @since 1.4\n+   */\n+  public boolean isEmpty()\n+  {\n+    for (int i = bits.length - 1; i >= 0; i--)\n+      if (bits[i] != 0)\n+        return false;\n+    return true;\n+  }\n+\n   /**\n    * Returns the logical number of bits actually used by this bit\n    * set.  It returns the index of the highest set bit plus one.\n    * Note that this method doesn't return the number of set bits.\n-   * @return the index of the highest set bit plus one.  \n+   *\n+   * @return the index of the highest set bit plus one.\n    */\n   public int length()\n   {\n@@ -266,54 +469,186 @@ public int length()\n     // b >= 0 checks if the highest bit is zero.\n     while (b >= 0)\n       {\n-\t--len;\n-\tb <<= 1;\n+        --len;\n+        b <<= 1;\n       }\n \n     return len;\n   }\n \n+  /**\n+   * Returns the index of the next false bit, from the specified bit\n+   * (inclusive).\n+   *\n+   * @param from the start location\n+   * @return the first false bit\n+   * @throws IndexOutOfBoundsException if from is negative\n+   * @since 1.4\n+   */\n+  public int nextClearBit(int from)\n+  {\n+    int offset = from >>> 6;\n+    long mask = 1L << from;\n+    while (offset < bits.length)\n+      {\n+        // ArrayIndexOutOfBoundsException subclasses IndexOutOfBoundsException,\n+        // so we'll just let that be our exception.\n+        long h = bits[offset];\n+        do\n+          {\n+            if ((h & mask) == 0)\n+              return from;\n+            mask <<= 1;\n+            from++;\n+          }\n+        while (mask != 0);\n+        mask = 1;\n+        offset++;\n+      }\n+    return from;\n+  }\n+\n+  /**\n+   * Returns the index of the next true bit, from the specified bit\n+   * (inclusive). If there is none, -1 is returned. You can iterate over\n+   * all true bits with this loop:<br>\n+   * <pre>\n+   * for (int i = bs.nextSetBit(0); i >= 0; i = bs.nextSetBit(i + 1))\n+   *   { // operate on i here }\n+   * </pre>\n+   *\n+   * @param from the start location\n+   * @return the first true bit, or -1\n+   * @throws IndexOutOfBoundsException if from is negative\n+   * @since 1.4\n+   */\n+  public int nextSetBit(int from)\n+  {\n+    int offset = from >>> 6;\n+    long mask = 1L << from;\n+    while (offset < bits.length)\n+      {\n+        // ArrayIndexOutOfBoundsException subclasses IndexOutOfBoundsException,\n+        // so we'll just let that be our exception.\n+        long h = bits[offset];\n+        do\n+          {\n+            if ((h & mask) != 0)\n+              return from;\n+            mask <<= 1;\n+            from++;\n+          }\n+        while (mask != 0);\n+        mask = 1;\n+        offset++;\n+      }\n+    return -1;\n+  }\n+\n   /**\n    * Performs the logical OR operation on this bit set and the\n    * given <code>set</code>.  This means it builds the union\n    * of the two sets.  The result is stored into this bit set, which\n    * grows as necessary.\n-   * @param set the second bit set.\n-   * @exception OutOfMemoryError if the current set can't grow.\n-   * @require set != null\n+   *\n+   * @param bs the second bit set\n+   * @throws NullPointerException if bs is null\n    */\n   public void or(BitSet bs)\n   {\n     ensure(bs.bits.length - 1);\n-    int i;\n-    for (i = 0; i < bs.bits.length; ++i)\n+    for (int i = bs.bits.length - 1; i >= 0; i--)\n       bits[i] |= bs.bits[i];\n   }\n \n   /**\n-   * Add the integer <code>bitIndex</code> to this set.  That is \n+   * Add the integer <code>bitIndex</code> to this set.  That is\n    * the corresponding bit is set to true.  If the index was already in\n    * the set, this method does nothing.  The size of this structure\n    * is automatically increased as necessary.\n-   * @param bitIndex a non-negative integer.\n-   * @exception ArrayIndexOutOfBoundsException if the specified bit index\n-   * is negative.\n-   * @require bitIndex >= 0\n+   *\n+   * @param pos a non-negative integer.\n+   * @throws IndexOutOfBoundsException if pos is negative\n    */\n   public void set(int pos)\n   {\n-    if (pos < 0)\n-      throw new IndexOutOfBoundsException();\n-    int bit = pos % 64;\n-    int offset = pos / 64;\n+    int offset = pos >>> 6;\n     ensure(offset);\n-    bits[offset] |= 1L << bit;\n+    // ArrayIndexOutOfBoundsException subclasses IndexOutOfBoundsException,\n+    // so we'll just let that be our exception.\n+    bits[offset] |= 1L << pos;\n+  }\n+\n+  /**\n+   * Sets the bit at the given index to the specified value. The size of\n+   * this structure is automatically increased as necessary.\n+   *\n+   * @param index the position to set\n+   * @param value the value to set it to\n+   * @throws IndexOutOfBoundsException if index is negative\n+   * @since 1.4\n+   */\n+  public void set(int index, boolean value)\n+  {\n+    if (value)\n+      set(index);\n+    else\n+      clear(index);\n+  }\n+\n+  /**\n+   * Sets the bits between from (inclusive) and to (exclusive) to true.\n+   *\n+   * @param from the start range (inclusive)\n+   * @param to the end range (exclusive)\n+   * @throws IndexOutOfBoundsException if from &lt; 0 || from &gt; to\n+   * @since 1.4\n+   */\n+  public void set(int from, int to)\n+  {\n+    if (from < 0 || from > to)\n+      throw new IndexOutOfBoundsException();\n+    if (from == to)\n+      return;\n+    int lo_offset = from >>> 6;\n+    int hi_offset = to >>> 6;\n+    ensure(hi_offset);\n+    if (lo_offset == hi_offset)\n+      {\n+        bits[hi_offset] |= (-1L << from) & ((1L << to) - 1);\n+        return;\n+      }\n+\n+    bits[lo_offset] |= -1L << from;\n+    bits[hi_offset] |= (1L << to) - 1;\n+    for (int i = lo_offset + 1; i < hi_offset; i++)\n+      bits[i] = -1;\n+  }\n+\n+  /**\n+   * Sets the bits between from (inclusive) and to (exclusive) to the\n+   * specified value.\n+   *\n+   * @param from the start range (inclusive)\n+   * @param to the end range (exclusive)\n+   * @param value the value to set it to\n+   * @throws IndexOutOfBoundsException if from &lt; 0 || from &gt; to\n+   * @since 1.4\n+   */\n+  public void set(int from, int to, boolean value)\n+  {\n+    if (value)\n+      set(from, to);\n+    else\n+      clear(from, to);\n   }\n \n   /**\n    * Returns the number of bits actually used by this bit set.  Note\n-   * that this method doesn't return the number of set bits.\n-   * @returns the number of bits currently used.  \n+   * that this method doesn't return the number of set bits, and that\n+   * future requests for larger bits will make this automatically grow.\n+   *\n+   * @return the number of bits currently used.\n    */\n   public int size()\n   {\n@@ -324,65 +659,63 @@ public int size()\n    * Returns the string representation of this bit set.  This\n    * consists of a comma separated list of the integers in this set\n    * surrounded by curly braces.  There is a space after each comma.\n+   * A sample string is thus \"{1, 3, 53}\".\n    * @return the string representation.\n    */\n   public String toString()\n   {\n-    String r = \"{\";\n+    StringBuffer r = new StringBuffer(\"{\");\n     boolean first = true;\n     for (int i = 0; i < bits.length; ++i)\n       {\n-\tlong bit = 1;\n-\tlong word = bits[i];\n-\tif (word == 0)\n-\t  continue;\n-\tfor (int j = 0; j < 64; ++j)\n-\t  {\n-\t    if ((word & bit) != 0)\n-\t      {\n-\t\tif (!first)\n-\t\t  r += \", \";\n-\t\tr += Integer.toString(64 * i + j);\n-\t\tfirst = false;\n-\t      }\n-\t    bit <<= 1;\n-\t  }\n+        long bit = 1;\n+        long word = bits[i];\n+        if (word == 0)\n+          continue;\n+        for (int j = 0; j < 64; ++j)\n+          {\n+            if ((word & bit) != 0)\n+              {\n+                if (! first)\n+                  r.append(\", \");\n+                r.append(64 * i + j);\n+                first = false;\n+              }\n+            bit <<= 1;\n+          }\n       }\n-\n-    return r += \"}\";\n+    return r.append(\"}\").toString();\n   }\n \n   /**\n    * Performs the logical XOR operation on this bit set and the\n    * given <code>set</code>.  This means it builds the symmetric\n    * remainder of the two sets (the elements that are in one set,\n    * but not in the other).  The result is stored into this bit set,\n-   * which grows as necessary.  \n-   * @param set the second bit set.\n-   * @exception OutOfMemoryError if the current set can't grow.  \n-   * @require set != null\n+   * which grows as necessary.\n+   *\n+   * @param bs the second bit set\n+   * @throws NullPointerException if bs is null\n    */\n   public void xor(BitSet bs)\n   {\n     ensure(bs.bits.length - 1);\n-    int i;\n-    for (i = 0; i < bs.bits.length; ++i)\n+    for (int i = bs.bits.length - 1; i >= 0; i--)\n       bits[i] ^= bs.bits[i];\n   }\n \n-  // Make sure the vector is big enough.\n+  /**\n+   * Make sure the vector is big enough.\n+   *\n+   * @param lastElt the size needed for the bits array\n+   */\n   private final void ensure(int lastElt)\n   {\n-    if (lastElt + 1 > bits.length)\n+    if (lastElt >= bits.length)\n       {\n-\tlong[] nd = new long[lastElt + 1];\n-\tSystem.arraycopy(bits, 0, nd, 0, bits.length);\n-\tbits = nd;\n+        long[] nd = new long[lastElt + 1];\n+        System.arraycopy(bits, 0, nd, 0, bits.length);\n+        bits = nd;\n       }\n   }\n-\n-  // The actual bits.\n-  long[] bits;\n-\n-  private static final long serialVersionUID = 7997698588986878753L;\n }"}, {"sha": "2f54502899896a88f7cf8b984f083d094f44f5ed", "filename": "libjava/java/util/Collections.java", "status": "modified", "additions": 2661, "deletions": 1060, "changes": 3721, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2Fjava%2Futil%2FCollections.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2Fjava%2Futil%2FCollections.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FCollections.java?ref=d9fd7154ec7908eff8bbbce75651eccf51064ac1"}, {"sha": "ef727c71c8b42fcd2650b6bfd58e36c887b75cf0", "filename": "libjava/java/util/Dictionary.java", "status": "modified", "additions": 57, "deletions": 18, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2Fjava%2Futil%2FDictionary.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2Fjava%2Futil%2FDictionary.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FDictionary.java?ref=d9fd7154ec7908eff8bbbce75651eccf51064ac1", "patch": "@@ -1,6 +1,6 @@\n /* Dictionary.java -- an abstract (and essentially worthless) \n    class which is Hashtable's superclass\n-   Copyright (C) 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 2001 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -35,49 +35,88 @@ class which is Hashtable's superclass\n  * This is an abstract class which has really gone by the wayside.\n  * People at Javasoft are probably embarrassed by it.  At this point,\n  * it might as well be an interface rather than a class, but it remains\n- * this poor, laugable skeleton for the sake of backwards compatibility.\n+ * this poor, laughable skeleton for the sake of backwards compatibility.\n  * At any rate, this was what came before the <pre>Map</pre> interface \n  * in the Collections framework.\n  *\n- * @author      Jon Zeppieri\n+ * @author Jon Zeppieri\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @see Map\n+ * @see Hashtable\n+ * @since 1.0\n+ * @status updated to 1.4\n  */\n public abstract class Dictionary extends Object\n {\n-  /** returns an Enumeration of the values in this Dictionary */\n+  /**\n+   * Sole constructor (often called implicitly).\n+   */\n+  public Dictionary()\n+  {\n+  }\n+\n+  /**\n+   * Returns an Enumeration of the values in this Dictionary.\n+   *\n+   * @return an Enumeration of the values\n+   * @see #keys()\n+   */\n   public abstract Enumeration elements();\n \n   /** \n-   * returns the value associated with the supplied key, or null\n-   * if no such value exists\n+   * Returns the value associated with the supplied key, or null\n+   * if no such value exists. Since Dictionaries are not allowed null keys\n+   * or elements, a null result always means the key is not present.\n    *\n-   * @param    key      the key to use to fetch the value\n+   * @param key the key to use to fetch the value\n+   * @return the mapped value\n+   * @throws NullPointerException if key is null\n+   * @see #put(Object, Object)\n    */\n   public abstract Object get(Object key);\n \n-  /** returns true IFF there are no elements in this Dictionary (size() == 0) */\n+  /**\n+   * Returns true when there are no elements in this Dictionary.\n+   *\n+   * @return <code>size() == 0</code>\n+   */\n   public abstract boolean isEmpty();\n \n-  /** returns an Enumeration of the keys in this Dictionary */\n+  /**\n+   * Returns an Enumeration of the keys in this Dictionary\n+   *\n+   * @return an Enumeration of the keys\n+   * @see #elements()\n+   */\n   public abstract Enumeration keys();\n \n   /**\n-   * inserts a new value into this Dictionary, located by the\n-   * supllied key; note: Dictionary's subclasses (all 1 of them)\n-   * do not support null keys or values (I can only assume this\n-   * would have been more general) \n+   * Inserts a new value into this Dictionary, located by the\n+   * supplied key. Dictionary does not support null keys or values, so\n+   * a null return can safely be interpreted as adding a new key.\n    *\n-   * @param      key      the key which locates the value\n-   * @param      value    the value to put into the Dictionary\n+   * @param key the key which locates the value\n+   * @param value the value to put into the Dictionary\n+   * @return the previous value of the key, or null if there was none\n+   * @throws NullPointerException if key or value is null\n+   * @see #get(Object)\n    */\n   public abstract Object put(Object key, Object value);\n \n   /**\n-   * removes fro the Dictionary the value located by the given key\n+   * Removes from the Dictionary the value located by the given key. A null\n+   * return safely means that the key was not mapped in the Dictionary.\n    *\n-   * @param       key      the key used to locate the value to be removed\n+   * @param key the key used to locate the value to be removed\n+   * @return the value associated with the removed key\n+   * @throws NullPointerException if key is null\n    */\n   public abstract Object remove(Object key);\n \n-  /** returns the number of values currently in this Dictionary */\n+  /**\n+   * Returns the number of values currently in this Dictionary.\n+   *\n+   * @return the number of keys in the Dictionary\n+   */\n   public abstract int size();\n }"}, {"sha": "dcf7e7e340b9fb8e8473e129575a291f49081242", "filename": "libjava/java/util/HashMap.java", "status": "modified", "additions": 277, "deletions": 248, "changes": 525, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2Fjava%2Futil%2FHashMap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2Fjava%2Futil%2FHashMap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FHashMap.java?ref=d9fd7154ec7908eff8bbbce75651eccf51064ac1", "patch": "@@ -53,14 +53,16 @@\n  * <p>\n  *\n  * Under ideal circumstances (no collisions), HashMap offers O(1)\n- * performance on most operations (<pre>containsValue()</pre> is,\n+ * performance on most operations (<code>containsValue()</code> is,\n  * of course, O(n)).  In the worst case (all keys map to the same\n  * hash code -- very unlikely), most operations are O(n).\n  * <p>\n  *\n  * HashMap is part of the JDK1.2 Collections API.  It differs from\n  * Hashtable in that it accepts the null key and null values, and it\n- * does not support \"Enumeration views.\"\n+ * does not support \"Enumeration views.\" Also, it is not synchronized;\n+ * if you plan to use it in multiple threads, consider using:<br>\n+ * <code>Map m = Collections.synchronizedMap(new HashMap(...));</code>\n  * <p>\n  *\n  * The iterators are <i>fail-fast</i>, meaning that any structural\n@@ -81,68 +83,79 @@\n  * @see IdentityHashMap\n  * @see Hashtable\n  * @since 1.2\n+ * @status updated to 1.4\n  */\n public class HashMap extends AbstractMap\n   implements Map, Cloneable, Serializable\n {\n   /**\n    * Default number of buckets. This is the value the JDK 1.3 uses. Some\n    * early documentation specified this value as 101. That is incorrect.\n+   * Package visible for use by HashSet.\n    */\n   static final int DEFAULT_CAPACITY = 11;\n \n   /**\n    * The default load factor; this is explicitly specified by the spec.\n+   * Package visible for use by HashSet.\n    */\n   static final float DEFAULT_LOAD_FACTOR = 0.75f;\n \n-  /** \"enum\" of iterator types. */\n-  static final int KEYS = 0,\n-                   VALUES = 1,\n-                   ENTRIES = 2;\n-\n   /**\n    * Compatible with JDK 1.2.\n    */\n   private static final long serialVersionUID = 362498820763181265L;\n \n   /**\n    * The rounded product of the capacity and the load factor; when the number\n-   * of elements exceeds the threshold, the HashMap calls <pre>rehash()</pre>.\n-   * @serial\n+   * of elements exceeds the threshold, the HashMap calls\n+   * <code>rehash()</code>.\n+   * @serial the threshold for rehashing\n    */\n-  int threshold;\n+  private int threshold;\n \n   /**\n    * Load factor of this HashMap:  used in computing the threshold.\n-   * @serial\n+   * Package visible for use by HashSet.\n+   * @serial the load factor\n    */\n   final float loadFactor;\n \n   /**\n    * Array containing the actual key-value mappings.\n+   * Package visible for use by nested and subclasses.\n    */\n   transient HashEntry[] buckets;\n \n   /**\n    * Counts the number of modifications this HashMap has undergone, used\n    * by Iterators to know when to throw ConcurrentModificationExceptions.\n+   * Package visible for use by nested and subclasses.\n    */\n   transient int modCount;\n \n   /**\n    * The size of this HashMap:  denotes the number of key-value pairs.\n+   * Package visible for use by nested and subclasses.\n    */\n   transient int size;\n \n+  /**\n+   * The cache for {@link #entrySet()}.\n+   */\n+  private transient Set entries;\n+\n   /**\n    * Class to represent an entry in the hash table. Holds a single key-value\n-   * pair.  This is extended again in LinkedHashMap.  See {@link clone()}\n-   * for why this must be Cloneable.\n+   * pair. Package visible for use by subclass.\n+   *\n+   * @author Eric Blake <ebb9@email.byu.edu>\n    */\n-  static class HashEntry extends BasicMapEntry implements Cloneable\n+  static class HashEntry extends BasicMapEntry\n   {\n-    /** The next entry in the linked list. */\n+    /**\n+     * The next entry in the linked list. Package visible for use by subclass.\n+     */\n     HashEntry next;\n \n     /**\n@@ -158,7 +171,8 @@ static class HashEntry extends BasicMapEntry implements Cloneable\n     /**\n      * Called when this entry is removed from the map. This version simply\n      * returns the value, but in LinkedHashMap, it must also do bookkeeping.\n-     * @return the value of this key as it is removed.\n+     *\n+     * @return the value of this key as it is removed\n      */\n     Object cleanup()\n     {\n@@ -182,9 +196,8 @@ public HashMap()\n    *\n    * Every element in Map m will be put into this new HashMap.\n    *\n-   * @param m a Map whose key / value pairs will be put into\n-   *          the new HashMap.  <b>NOTE: key / value pairs\n-   *          are not cloned in this constructor.</b>\n+   * @param m a Map whose key / value pairs will be put into the new HashMap.\n+   *        <b>NOTE: key / value pairs are not cloned in this constructor.</b>\n    * @throws NullPointerException if m is null\n    */\n   public HashMap(Map m)\n@@ -197,8 +210,8 @@ public HashMap(Map m)\n    * Construct a new HashMap with a specific inital capacity and\n    * default load factor of 0.75.\n    *\n-   * @param initialCapacity the initial capacity of this HashMap (>=0)\n-   * @throws IllegalArgumentException if (initialCapacity < 0)\n+   * @param initialCapacity the initial capacity of this HashMap (&gt;=0)\n+   * @throws IllegalArgumentException if (initialCapacity &lt; 0)\n    */\n   public HashMap(int initialCapacity)\n   {\n@@ -208,10 +221,10 @@ public HashMap(int initialCapacity)\n   /**\n    * Construct a new HashMap with a specific inital capacity and load factor.\n    *\n-   * @param initialCapacity the initial capacity (>=0)\n-   * @param loadFactor the load factor (>0, not NaN)\n-   * @throws IllegalArgumentException if (initialCapacity < 0) ||\n-   *                                     ! (loadFactor > 0.0)\n+   * @param initialCapacity the initial capacity (&gt;=0)\n+   * @param loadFactor the load factor (&gt; 0, not NaN)\n+   * @throws IllegalArgumentException if (initialCapacity &lt; 0) ||\n+   *                                     ! (loadFactor &gt; 0.0)\n    */\n   public HashMap(int initialCapacity, float loadFactor)\n   {\n@@ -229,7 +242,8 @@ public HashMap(int initialCapacity, float loadFactor)\n   }\n \n   /**\n-   * Returns the number of kay-value mappings currently in this Map\n+   * Returns the number of kay-value mappings currently in this Map.\n+   *\n    * @return the size\n    */\n   public int size()\n@@ -238,7 +252,8 @@ public int size()\n   }\n \n   /**\n-   * Returns true if there are no key-value mappings currently in this Map\n+   * Returns true if there are no key-value mappings currently in this Map.\n+   *\n    * @return <code>size() == 0</code>\n    */\n   public boolean isEmpty()\n@@ -247,29 +262,31 @@ public boolean isEmpty()\n   }\n \n   /**\n-   * Returns true if this HashMap contains a value <pre>o</pre>, such that\n-   * <pre>o.equals(value)</pre>.\n+   * Return the value in this HashMap associated with the supplied key,\n+   * or <code>null</code> if the key maps to nothing.  NOTE: Since the value\n+   * could also be null, you must use containsKey to see if this key\n+   * actually maps to something.\n    *\n-   * @param value the value to search for in this HashMap\n-   * @return true if at least one key maps to the value\n+   * @param key the key for which to fetch an associated value\n+   * @return what the key maps to, if present\n+   * @see #put(Object, Object)\n+   * @see #containsKey(Object)\n    */\n-  public boolean containsValue(Object value)\n+  public Object get(Object key)\n   {\n-    for (int i = buckets.length - 1; i >= 0; i--)\n+    int idx = hash(key);\n+    HashEntry e = buckets[idx];\n+    while (e != null)\n       {\n-        HashEntry e = buckets[i];\n-        while (e != null)\n-          {\n-            if (value == null ? e.value == null : value.equals(e.value))\n-              return true;\n-            e = e.next;\n-          }\n+        if (equals(key, e.key))\n+          return e.value;\n+        e = e.next;\n       }\n-    return false;\n+    return null;\n   }\n \n   /**\n-   * Returns true if the supplied object <pre>equals()</pre> a key\n+   * Returns true if the supplied object <code>equals()</code> a key\n    * in this HashMap.\n    *\n    * @param key the key to search for in this HashMap\n@@ -282,37 +299,13 @@ public boolean containsKey(Object key)\n     HashEntry e = buckets[idx];\n     while (e != null)\n       {\n-        if (key == null ? e.key == null : key.equals(e.key))\n+        if (equals(key, e.key))\n           return true;\n         e = e.next;\n       }\n     return false;\n   }\n \n-  /**\n-   * Return the value in this HashMap associated with the supplied key,\n-   * or <pre>null</pre> if the key maps to nothing.  NOTE: Since the value\n-   * could also be null, you must use containsKey to see if this key\n-   * actually maps to something.\n-   *\n-   * @param key the key for which to fetch an associated value\n-   * @return what the key maps to, if present\n-   * @see #put(Object, Object)\n-   * @see #containsKey(Object)\n-   */\n-  public Object get(Object key)\n-  {\n-    int idx = hash(key);\n-    HashEntry e = buckets[idx];\n-    while (e != null)\n-      {\n-        if (key == null ? e.key == null : key.equals(e.key))\n-          return e.value;\n-        e = e.next;\n-      }\n-    return null;\n-  }\n-\n   /**\n    * Puts the supplied value into the Map, mapped by the supplied key.\n    * The value may be retrieved by any object which <code>equals()</code>\n@@ -328,20 +321,20 @@ public Object get(Object key)\n    */\n   public Object put(Object key, Object value)\n   {\n-    modCount++;\n     int idx = hash(key);\n     HashEntry e = buckets[idx];\n \n     while (e != null)\n       {\n-        if (key == null ? e.key == null : key.equals(e.key))\n+        if (equals(key, e.key))\n           // Must use this method for necessary bookkeeping in LinkedHashMap.\n           return e.setValue(value);\n         else\n           e = e.next;\n       }\n \n     // At this point, we know we need to add a new entry.\n+    modCount++;\n     if (++size > threshold)\n       {\n         rehash();\n@@ -355,27 +348,36 @@ public Object put(Object key, Object value)\n   }\n \n   /**\n-   * Helper method for put, that creates and adds a new Entry.  This is\n-   * overridden in LinkedHashMap for bookkeeping purposes.\n+   * Copies all elements of the given map into this hashtable.  If this table\n+   * already has a mapping for a key, the new mapping replaces the current\n+   * one.\n    *\n-   * @param key the key of the new Entry\n-   * @param value the value\n-   * @param idx the index in buckets where the new Entry belongs\n-   * @param callRemove Whether to call the removeEldestEntry method.\n-   * @see #put(Object, Object)\n+   * @param m the map to be hashed into this\n    */\n-  void addEntry(Object key, Object value, int idx, boolean callRemove)\n+  public void putAll(Map m)\n   {\n-    HashEntry e = new HashEntry(key, value);\n+    Iterator itr = m.entrySet().iterator();\n \n-    e.next = buckets[idx];\n-    buckets[idx] = e;\n+    for (int msize = m.size(); msize > 0; msize--)\n+      {\n+        Map.Entry e = (Map.Entry) itr.next();\n+        // Optimize in case the Entry is one of our own.\n+        if (e instanceof BasicMapEntry)\n+          {\n+            BasicMapEntry entry = (BasicMapEntry) e;\n+            put(entry.key, entry.value);\n+          }\n+        else\n+          {\n+            put(e.getKey(), e.getValue());\n+          }\n+      }\n   }\n-\n+  \n   /**\n    * Removes from the HashMap and returns the value which is mapped by the\n    * supplied key. If the key maps to nothing, then the HashMap remains\n-   * unchanged, and <pre>null</pre> is returned. NOTE: Since the value\n+   * unchanged, and <code>null</code> is returned. NOTE: Since the value\n    * could also be null, you must use containsKey to see if you are\n    * actually removing a mapping.\n    *\n@@ -384,15 +386,15 @@ void addEntry(Object key, Object value, int idx, boolean callRemove)\n    */\n   public Object remove(Object key)\n   {\n-    modCount++;\n     int idx = hash(key);\n     HashEntry e = buckets[idx];\n     HashEntry last = null;\n \n     while (e != null)\n       {\n-        if (key == null ? e.key == null : key.equals(e.key))\n+        if (equals(key, e.key))\n           {\n+            modCount++;\n             if (last == null)\n               buckets[idx] = e.next;\n             else\n@@ -408,40 +410,39 @@ public Object remove(Object key)\n   }\n \n   /**\n-   * Copies all elements of the given map into this hashtable.  If this table\n-   * already has a mapping for a key, the new mapping replaces the current\n-   * one.\n-   *\n-   * @param m the map to be hashed into this\n+   * Clears the Map so it has no keys. This is O(1).\n    */\n-  public void putAll(Map m)\n+  public void clear()\n   {\n-    Iterator itr = m.entrySet().iterator();\n-\n-    for (int msize = m.size(); msize > 0; msize--)\n+    if (size != 0)\n       {\n-        Map.Entry e = (Map.Entry) itr.next();\n-        // Optimize in case the Entry is one of our own.\n-        if (e instanceof BasicMapEntry)\n-          {\n-            BasicMapEntry entry = (BasicMapEntry) e;\n-            put(entry.key, entry.value);\n-          }\n-        else\n-          {\n-            put(e.getKey(), e.getValue());\n-          }\n+        modCount++;\n+        Arrays.fill(buckets, null);\n+        size = 0;\n       }\n   }\n-  \n+\n   /**\n-   * Clears the Map so it has no keys. This is O(1).\n+   * Returns true if this HashMap contains a value <code>o</code>, such that\n+   * <code>o.equals(value)</code>.\n+   *\n+   * @param value the value to search for in this HashMap\n+   * @return true if at least one key maps to the value\n+   * @see containsKey(Object)\n    */\n-  public void clear()\n+  public boolean containsValue(Object value)\n   {\n-    modCount++;\n-    Arrays.fill(buckets, null);\n-    size = 0;\n+    for (int i = buckets.length - 1; i >= 0; i--)\n+      {\n+        HashEntry e = buckets[i];\n+        while (e != null)\n+          {\n+            if (equals(value, e.value))\n+              return true;\n+            e = e.next;\n+          }\n+      }\n+    return false;\n   }\n \n   /**\n@@ -463,6 +464,8 @@ public Object clone()\n       }\n     copy.buckets = new HashEntry[buckets.length];\n     copy.putAllInternal(this);\n+    // Clear the entry cache. AbstractMap.clone() does the others.\n+    copy.entries = null;\n     return copy;\n   }\n \n@@ -477,41 +480,43 @@ public Object clone()\n    */\n   public Set keySet()\n   {\n-    // Create an AbstractSet with custom implementations of those methods that\n-    // can be overridden easily and efficiently.\n-    return new AbstractSet()\n-    {\n-      public int size()\n-      {\n-        return size;\n-      }\n-\n-      public Iterator iterator()\n-      {\n-        // Cannot create the iterator directly, because of LinkedHashMap.\n-        return HashMap.this.iterator(KEYS);\n-      }\n-\n-      public void clear()\n-      {\n-        HashMap.this.clear();\n-      }\n-\n-      public boolean contains(Object o)\n-      {\n-        return HashMap.this.containsKey(o);\n-      }\n-\n-      public boolean remove(Object o)\n+    if (keys == null)\n+      // Create an AbstractSet with custom implementations of those methods\n+      // that can be overridden easily and efficiently.\n+      keys = new AbstractSet()\n       {\n-        // Test against the size of the HashMap to determine if anything\n-        // really got removed. This is necessary because the return value of\n-        // HashMap.remove() is ambiguous in the null case.\n-        int oldsize = size;\n-        HashMap.this.remove(o);\n-        return (oldsize != size);\n-      }\n-    };\n+        public int size()\n+        {\n+          return size;\n+        }\n+\n+        public Iterator iterator()\n+        {\n+          // Cannot create the iterator directly, because of LinkedHashMap.\n+          return HashMap.this.iterator(KEYS);\n+        }\n+\n+        public void clear()\n+        {\n+          HashMap.this.clear();\n+        }\n+\n+        public boolean contains(Object o)\n+        {\n+          return containsKey(o);\n+        }\n+\n+        public boolean remove(Object o)\n+        {\n+          // Test against the size of the HashMap to determine if anything\n+          // really got removed. This is neccessary because the return value\n+          // of HashMap.remove() is ambiguous in the null case.\n+          int oldsize = size;\n+          HashMap.this.remove(o);\n+          return oldsize != size;\n+        }\n+      };\n+    return keys;\n   }\n \n   /**\n@@ -526,33 +531,34 @@ public boolean remove(Object o)\n    */\n   public Collection values()\n   {\n-    // We don't bother overriding many of the optional methods, as doing so\n-    // wouldn't provide any significant performance advantage.\n-    return new AbstractCollection()\n-    {\n-      public int size()\n-      {\n-        return size;\n-      }\n-\n-      public Iterator iterator()\n-      {\n-        // Cannot create the iterator directly, because of LinkedHashMap.\n-        return HashMap.this.iterator(VALUES);\n-      }\n-\n-      public void clear()\n+    if (values == null)\n+      // We don't bother overriding many of the optional methods, as doing so\n+      // wouldn't provide any significant performance advantage.\n+      values = new AbstractCollection()\n       {\n-        HashMap.this.clear();\n-      }\n-    };\n+        public int size()\n+        {\n+          return size;\n+        }\n+\n+        public Iterator iterator()\n+        {\n+          // Cannot create the iterator directly, because of LinkedHashMap.\n+          return HashMap.this.iterator(VALUES);\n+        }\n+\n+        public void clear()\n+        {\n+          HashMap.this.clear();\n+        }\n+      };\n+    return values;\n   }\n \n   /**\n    * Returns a \"set view\" of this HashMap's entries. The set is backed by\n    * the HashMap, so changes in one show up in the other.  The set supports\n-   * element removal, but not element addition.\n-   * <p>\n+   * element removal, but not element addition.<p>\n    *\n    * Note that the iterators for all three views, from keySet(), entrySet(),\n    * and values(), traverse the HashMap in the same sequence.\n@@ -564,53 +570,62 @@ public void clear()\n    */\n   public Set entrySet()\n   {\n-    // Create an AbstractSet with custom implementations of those methods that\n-    // can be overridden easily and efficiently.\n-    return new AbstractSet()\n-    {\n-      public int size()\n-      {\n-        return size;\n-      }\n-\n-      public Iterator iterator()\n-      {\n-        // Cannot create the iterator directly, because of LinkedHashMap.\n-        return HashMap.this.iterator(ENTRIES);\n-      }\n-\n-      public void clear()\n-      {\n-        HashMap.this.clear();\n-      }\n-\n-      public boolean contains(Object o)\n-      {\n-        return getEntry(o) != null;\n-      }\n-\n-      public boolean remove(Object o)\n+    if (entries == null)\n+      // Create an AbstractSet with custom implementations of those methods\n+      // that can be overridden easily and efficiently.\n+      entries = new AbstractSet()\n       {\n-        HashEntry e = getEntry(o);\n-        if (e != null)\n-          {\n-            HashMap.this.remove(e.key);\n-            return true;\n-          }\n-        return false;\n-      }\n-    };\n+        public int size()\n+        {\n+          return size;\n+        }\n+\n+        public Iterator iterator()\n+        {\n+          // Cannot create the iterator directly, because of LinkedHashMap.\n+          return HashMap.this.iterator(ENTRIES);\n+        }\n+\n+        public void clear()\n+        {\n+          HashMap.this.clear();\n+        }\n+\n+        public boolean contains(Object o)\n+        {\n+          return getEntry(o) != null;\n+        }\n+\n+        public boolean remove(Object o)\n+        {\n+          HashEntry e = getEntry(o);\n+          if (e != null)\n+            {\n+              HashMap.this.remove(e.key);\n+              return true;\n+            }\n+          return false;\n+        }\n+      };\n+    return entries;\n   }\n \n-  /** Helper method that returns an index in the buckets array for `key;\n-   * based on its hashCode().\n+  /**\n+   * Helper method for put, that creates and adds a new Entry.  This is\n+   * overridden in LinkedHashMap for bookkeeping purposes.\n    *\n-   * @param key the key\n-   * @return the bucket number\n+   * @param key the key of the new Entry\n+   * @param value the value\n+   * @param idx the index in buckets where the new Entry belongs\n+   * @param callRemove whether to call the removeEldestEntry method\n+   * @see #put(Object, Object)\n    */\n-  int hash(Object key)\n+  void addEntry(Object key, Object value, int idx, boolean callRemove)\n   {\n-    return (key == null) ? 0 : Math.abs(key.hashCode() % buckets.length);\n+    HashEntry e = new HashEntry(key, value);\n+\n+    e.next = buckets[idx];\n+    buckets[idx] = e;\n   }\n \n   /**\n@@ -637,6 +652,52 @@ private HashEntry getEntry(Object o)\n     return null;\n   }\n \n+  /**\n+   * Helper method that returns an index in the buckets array for `key'\n+   * based on its hashCode().  Package visible for use by subclasses.\n+   *\n+   * @param key the key\n+   * @return the bucket number\n+   */\n+  final int hash(Object key)\n+  {\n+    return key == null ? 0 : Math.abs(key.hashCode() % buckets.length);\n+  }\n+\n+  /**\n+   * Generates a parameterized iterator.  Must be overrideable, since\n+   * LinkedHashMap iterates in a different order.\n+   *\n+   * @param type {@link #KEYS}, {@link #VALUES}, or {@link #ENTRIES}\n+   * @return the appropriate iterator\n+   */\n+  Iterator iterator(int type)\n+  {\n+    return new HashIterator(type);\n+  }\n+\n+  /**\n+   * A simplified, more efficient internal implementation of putAll(). The \n+   * Map constructor and clone() should not call putAll or put, in order to \n+   * be compatible with the JDK implementation with respect to subclasses.\n+   *\n+   * @param m the map to initialize this from\n+   */\n+  void putAllInternal(Map m)\n+  {\n+    Iterator itr = m.entrySet().iterator();\n+    int msize = m.size();\n+    this.size = msize;\n+\n+    for (; msize > 0; msize--)\n+      {\n+\tMap.Entry e = (Map.Entry) itr.next();\n+\tObject key = e.getKey();\n+\tint idx = hash(key);\n+\taddEntry(key, e.getValue(), idx, false);\n+      }\n+  }\n+\n   /**\n    * Increases the size of the HashMap and rehashes all keys to new array\n    * indices; this is called when the addition of a new value would cause\n@@ -681,35 +742,6 @@ private void rehash()\n       }\n   }\n \n-  /**\n-   * Generates a parameterized iterator.  Must be overrideable, since\n-   * LinkedHashMap iterates in a different order.\n-   * @param type {@link #KEYS}, {@link #VALUES}, or {@link #ENTRIES}\n-   * @return the appropriate iterator\n-   */\n-  Iterator iterator(int type)\n-  {\n-    return new HashIterator(type);\n-  }\n-\n-  /**\n-   * A simplified, more efficient internal implementation of putAll(). The \n-   * Map constructor and clone() should not call putAll or put, in order to \n-   * be compatible with the JDK implementation with respect to subclasses.\n-   */\n-  void putAllInternal(Map m)\n-  {\n-    Iterator itr = m.entrySet().iterator();\n-\n-    for (int msize = m.size(); msize > 0; msize--)\n-      {\n-\tMap.Entry e = (Map.Entry) itr.next();\n-\tObject key = e.getKey();\n-\tint idx = hash(key);\n-\taddEntry(key, e.getValue(), idx, false);\n-      }\n-  }\n-\n   /**\n    * Serializes this object to the given stream.\n    *\n@@ -757,9 +789,6 @@ private void readObject(ObjectInputStream s)\n     // Read and use capacity.\n     buckets = new HashEntry[s.readInt()];\n     int len = s.readInt();\n-    // Already happens automatically.\n-    // size = 0;\n-    // modCount = 0;\n \n     // Read and use key/value pairs.\n     for ( ; len > 0; len--)\n@@ -773,29 +802,29 @@ private void readObject(ObjectInputStream s)\n    *\n    * @author Jon Zeppieri\n    */\n-  class HashIterator implements Iterator\n+  private final class HashIterator implements Iterator\n   {\n     /**\n      * The type of this Iterator: {@link #KEYS}, {@link #VALUES},\n      * or {@link #ENTRIES}.\n      */\n-    final int type;\n+    private final int type;\n     /**\n      * The number of modifications to the backing HashMap that we know about.\n      */\n-    int knownMod = modCount;\n+    private int knownMod = modCount;\n     /** The number of elements remaining to be returned by next(). */\n-    int count = size;\n+    private int count = size;\n     /** Current index in the physical hash table. */\n-    int idx = buckets.length;\n+    private int idx = buckets.length;\n     /** The last Entry returned by a next() call. */\n-    HashEntry last;\n+    private HashEntry last;\n     /**\n      * The next entry that should be returned by next(). It is set to something\n      * if we're iterating through a bucket that contains multiple linked\n      * entries. It is null if next() needs to find a new bucket.\n      */\n-    HashEntry next;\n+    private HashEntry next;\n \n     /**\n      * Construct a new HashIterator with the supplied type.\n@@ -840,14 +869,14 @@ public Object next()\n       last = e;\n       if (type == VALUES)\n         return e.value;\n-      else if (type == KEYS)\n+      if (type == KEYS)\n         return e.key;\n       return e;\n     }\n \n     /**\n      * Removes from the backing HashMap the last element which was fetched\n-     * with the <pre>next()</pre> method.\n+     * with the <code>next()</code> method.\n      * @throws ConcurrentModificationException if the HashMap was modified\n      * @throws IllegalStateException if called when there is no last element\n      */\n@@ -859,8 +888,8 @@ public void remove()\n         throw new IllegalStateException();\n \n       HashMap.this.remove(last.key);\n-      knownMod++;\n       last = null;\n+      knownMod++;\n     }\n   }\n }"}, {"sha": "9d9c3315263fd9fa6dea94012c15b6b320dc1383", "filename": "libjava/java/util/HashSet.java", "status": "modified", "additions": 138, "deletions": 74, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2Fjava%2Futil%2FHashSet.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2Fjava%2Futil%2FHashSet.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FHashSet.java?ref=d9fd7154ec7908eff8bbbce75651eccf51064ac1", "patch": "@@ -1,5 +1,5 @@\n-/* HashSet.java -- a class providing a HashMap-backet Set\n-   Copyright (C) 1998, 1999 Free Software Foundation, Inc.\n+/* HashSet.java -- a class providing a HashMap-backed Set\n+   Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -33,186 +33,250 @@\n import java.io.ObjectOutputStream;\n \n /**\n- * This class provides a HashMap-backed implementation of the \n- * Set interface.\n- *\n- * Each element in the Set is a key in the backing HashMap; each key\n- * maps to a static token, denoting that the key does, in fact, exist.\n+ * This class provides a HashMap-backed implementation of the Set interface.\n+ * <p>\n  *\n  * Most operations are O(1), assuming no hash collisions.  In the worst\n- * case (where all hases collide), operations are O(n).\n+ * case (where all hashes collide), operations are O(n). Setting the\n+ * initial capacity too low will force many resizing operations, but\n+ * setting the initial capacity too high (or loadfactor too low) leads\n+ * to wasted memory and slower iteration.\n+ * <p>\n+ *\n+ * HashSet accepts the null key and null values.  It is not synchronized,\n+ * so if you need multi-threaded access, consider using:<br>\n+ * <code>Set s = Collections.synchronizedSet(new HashSet(...));</code>\n+ * <p>\n  *\n- * HashSet is a part of the JDK1.2 Collections API.\n+ * The iterators are <i>fail-fast</i>, meaning that any structural\n+ * modification, except for <code>remove()</code> called on the iterator\n+ * itself, cause the iterator to throw a\n+ * {@link ConcurrentModificationException} rather than exhibit\n+ * non-deterministic behavior.\n  *\n- * @author      Jon Zeppieri\n+ * @author Jon Zeppieri\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @see Collection\n+ * @see Set\n+ * @see TreeSet\n+ * @see Collections#synchronizedSet(Set)\n+ * @see HashMap\n+ * @see LinkedHashSet\n+ * @since 1.2\n+ * @status updated to 1.4\n  */\n public class HashSet extends AbstractSet\n   implements Set, Cloneable, Serializable\n {\n-  /** the HashMap which backs this Set */\n-  transient HashMap map;\n-  static final long serialVersionUID = -5024744406713321676L;\n+  /**\n+   * Compatible with JDK 1.2.\n+   */\n+  private static final long serialVersionUID = -5024744406713321676L;\n \n   /**\n-   * construct a new, empty HashSet whose backing HashMap has the default \n-   * capacity and loadFacor\n+   * The HashMap which backs this Set.\n+   */\n+  private transient HashMap map;\n+\n+  /**\n+   * Construct a new, empty HashSet whose backing HashMap has the default\n+   * capacity (11) and loadFacor (0.75).\n    */\n   public HashSet()\n   {\n-    map = new HashMap();\n+    this(HashMap.DEFAULT_CAPACITY, HashMap.DEFAULT_LOAD_FACTOR);\n   }\n \n   /**\n-   * construct a new, empty HashSet whose backing HashMap has the supplied\n-   * capacity and the default load factor\n+   * Construct a new, empty HashSet whose backing HashMap has the supplied\n+   * capacity and the default load factor (0.75).\n    *\n-   * @param          initialCapacity          the initial capacity of the backing\n-   *                                          HashMap\n+   * @param initialCapacity the initial capacity of the backing HashMap\n+   * @throws IllegalArgumentException if the capacity is negative\n    */\n   public HashSet(int initialCapacity)\n   {\n-    map = new HashMap(initialCapacity);\n+    this(initialCapacity, HashMap.DEFAULT_LOAD_FACTOR);\n   }\n \n   /**\n-   * construct a new, empty HashSet whose backing HashMap has the supplied\n-   * capacity and load factor\n+   * Construct a new, empty HashSet whose backing HashMap has the supplied\n+   * capacity and load factor.\n    *\n-   * @param          initialCapacity          the initial capacity of the backing\n-   *                                          HashMap\n-   * @param          loadFactor               the load factor of the backing HashMap\n+   * @param initialCapacity the initial capacity of the backing HashMap\n+   * @param loadFactor the load factor of the backing HashMap\n+   * @throws IllegalArgumentException if either argument is negative, or\n+   *         if loadFactor is POSITIVE_INFINITY or NaN\n    */\n   public HashSet(int initialCapacity, float loadFactor)\n   {\n-    map = new HashMap(initialCapacity, loadFactor);\n+    map = init(initialCapacity, loadFactor);\n   }\n \n   /**\n-   * construct a new HashSet with the same elements as are in the supplied\n-   * collection (eliminating any duplicates, of course; the backing HashMap\n-   * will have the default capacity and load factor\n+   * Construct a new HashSet with the same elements as are in the supplied\n+   * collection (eliminating any duplicates, of course). The backing storage\n+   * has twice the size of the collection, or the default size of 11,\n+   * whichever is greater; and the default load factor (0.75).\n    *\n-   * @param          c          a collection containing the elements with\n-   *                            which this set will be initialized\n+   * @param c a collection of initial set elements\n+   * @throws NullPointerException if c is null\n    */\n   public HashSet(Collection c)\n   {\n-    map = new HashMap();\n+    this(Math.max(2 * c.size(), HashMap.DEFAULT_CAPACITY));\n     addAll(c);\n   }\n \n   /**\n-   * adds the given Object to the set if it is not already in the Set,\n-   * returns true if teh element was added, false otherwise\n+   * Adds the given Object to the set if it is not already in the Set.\n+   * This set permits a null element.\n    *\n-   * @param       o       the Object to add to this Set\n+   * @param o the Object to add to this Set\n+   * @return true if the set did not already contain o\n    */\n   public boolean add(Object o)\n   {\n-    return (map.put(o, Boolean.TRUE) == null);\n+    return map.put(o, \"\") == null;\n   }\n \n   /**\n-   * empties this Set of all elements; this is a fast operation [O(1)]\n+   * Empties this Set of all elements; this takes constant time.\n    */\n   public void clear()\n   {\n     map.clear();\n   }\n \n   /**\n-   * returns a shallow copy of this Set (the Set itself is cloned; its \n-   * elements are not)\n+   * Returns a shallow copy of this Set. The Set itself is cloned; its\n+   * elements are not.\n+   *\n+   * @return a shallow clone of the set\n    */\n   public Object clone()\n   {\n     HashSet copy = null;\n     try\n       {\n-\tcopy = (HashSet) super.clone();\n+        copy = (HashSet) super.clone();\n       }\n     catch (CloneNotSupportedException x)\n       {\n+        // Impossible to get here.\n       }\n     copy.map = (HashMap) map.clone();\n     return copy;\n   }\n \n   /**\n-   * returns true if the supplied element is in this Set, false otherwise\n+   * Returns true if the supplied element is in this Set.\n    *\n-   * @param        o         the Object whose presence in this Set we are testing for\n+   * @param o the Object to look for\n+   * @return true if it is in the set\n    */\n   public boolean contains(Object o)\n   {\n     return map.containsKey(o);\n   }\n \n-  /** \n-   * returns true if this set has no elements in it (size() == 0)\n+  /**\n+   * Returns true if this set has no elements in it.\n+   *\n+   * @return <code>size() == 0</code>.\n    */\n   public boolean isEmpty()\n   {\n-    return map.isEmpty();\n+    return map.size == 0;\n   }\n \n   /**\n-   * returns an Iterator over the elements of this Set; the Iterator allows\n-   * removal of elements\n+   * Returns an Iterator over the elements of this Set, which visits the\n+   * elements in no particular order.  For this class, the Iterator allows\n+   * removal of elements. The iterator is fail-fast, and will throw a\n+   * ConcurrentModificationException if the set is modified externally.\n+   *\n+   * @return a set iterator\n+   * @see ConcurrentModificationException\n    */\n   public Iterator iterator()\n   {\n-    return map.keySet().iterator();\n+    // Avoid creating intermediate keySet() object by using non-public API.\n+    return map.iterator(HashMap.KEYS);\n   }\n \n   /**\n-   * removes the supplied Object from this Set if it is in the Set; returns\n-   * true if an element was removed, false otherwise\n+   * Removes the supplied Object from this Set if it is in the Set.\n+   *\n+   * @param o the object to remove\n+   * @return true if an element was removed\n    */\n   public boolean remove(Object o)\n   {\n     return (map.remove(o) != null);\n   }\n \n   /**\n-   * returns the number of elements in this Set\n+   * Returns the number of elements in this Set (its cardinality).\n+   *\n+   * @return the size of the set\n    */\n   public int size()\n   {\n-    return map.size();\n+    return map.size;\n   }\n \n-  /** Serialize this Object in a manner which is binary-compatible with the \n-    * JDK */\n+  /**\n+   * Helper method which initializes the backing Map. Overridden by\n+   * LinkedHashSet for correct semantics.\n+   *\n+   * @param capacity the initial capacity\n+   * @param load the initial load factor\n+   * @return the backing HashMap\n+   */\n+  HashMap init(int capacity, float load)\n+  {\n+    return new HashMap(capacity, load);\n+  }\n+\n+  /**\n+   * Serializes this object to the given stream.\n+   *\n+   * @param s the stream to write to\n+   * @throws IOException if the underlying stream fails\n+   * @serialData the <i>capacity</i> (int) and <i>loadFactor</i> (float)\n+   *             of the backing store, followed by the set size (int),\n+   *             then a listing of its elements (Object) in no order\n+   */\n   private void writeObject(ObjectOutputStream s) throws IOException\n   {\n-    Iterator it = iterator();\n+    s.defaultWriteObject();\n+    // Avoid creating intermediate keySet() object by using non-public API.\n+    Iterator it = map.iterator(HashMap.KEYS);\n     s.writeInt(map.buckets.length);\n     s.writeFloat(map.loadFactor);\n     s.writeInt(map.size);\n     while (it.hasNext())\n       s.writeObject(it.next());\n   }\n \n-  /** Deserialize this Object in a manner which is binary-compatible with \n-    * the JDK */\n-  private void readObject(ObjectInputStream s) throws IOException,\n-    ClassNotFoundException\n+  /**\n+   * Deserializes this object from the given stream.\n+   *\n+   * @param s the stream to read from\n+   * @throws ClassNotFoundException if the underlying stream fails\n+   * @throws IOException if the underlying stream fails\n+   * @serialData the <i>capacity</i> (int) and <i>loadFactor</i> (float)\n+   *             of the backing store, followed by the set size (int),\n+   *             then a listing of its elements (Object) in no order\n+   */\n+  private void readObject(ObjectInputStream s)\n+    throws IOException, ClassNotFoundException\n   {\n-    int i, size, capacity;\n-    float loadFactor;\n-    Object element;\n-\n-    capacity = s.readInt();\n-    loadFactor = s.readFloat();\n-    size = s.readInt();\n+    s.defaultReadObject();\n \n-    map = new HashMap(capacity, loadFactor);\n-\n-    for (i = 0; i < size; i++)\n-      {\n-\telement = s.readObject();\n-\tmap.put(element, Boolean.TRUE);\n-      }\n+    map = init(s.readInt(), s.readFloat());\n+    for (int size = s.readInt(); size > 0; size--)\n+      map.put(s.readObject(), \"\");\n   }\n }"}, {"sha": "01332698c6f958b8e64168dbcb6d6b0f3f84134a", "filename": "libjava/java/util/Hashtable.java", "status": "modified", "additions": 270, "deletions": 242, "changes": 512, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2Fjava%2Futil%2FHashtable.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2Fjava%2Futil%2FHashtable.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FHashtable.java?ref=d9fd7154ec7908eff8bbbce75651eccf51064ac1", "patch": "@@ -66,7 +66,9 @@\n  * Unlike HashMap, Hashtable does not accept `null' as a key value. Also,\n  * all accesses are synchronized: in a single thread environment, this is\n  * expensive, but in a multi-thread environment, this saves you the effort\n- * of extra synchronization.\n+ * of extra synchronization. However, the old-style enumerators are not\n+ * synchronized, because they can lead to unspecified behavior even if\n+ * they were synchronized. You have been warned.\n  * <p>\n  *\n  * The iterators are <i>fail-fast</i>, meaning that any structural\n@@ -84,6 +86,7 @@\n  * @see IdentityHashMap\n  * @see LinkedHashMap\n  * @since 1.0\n+ * @status updated to 1.4\n  */\n public class Hashtable extends Dictionary\n   implements Map, Cloneable, Serializable\n@@ -93,6 +96,12 @@ public class Hashtable extends Dictionary\n    */\n   private static final int DEFAULT_CAPACITY = 11;\n \n+  /** An \"enum\" of iterator types. */\n+  // Package visible for use by nested classes.\n+  static final int KEYS = 0,\n+                   VALUES = 1,\n+                   ENTRIES = 2;\n+\n   /**\n    * The default load factor; this is explicitly specified by the spec.\n    */\n@@ -106,39 +115,57 @@ public class Hashtable extends Dictionary\n   /**\n    * The rounded product of the capacity and the load factor; when the number\n    * of elements exceeds the threshold, the Hashtable calls\n-   * <pre>rehash()</pre>.\n+   * <code>rehash()</code>.\n    * @serial\n    */\n-  int threshold;\n+  private int threshold;\n \n   /**\n    * Load factor of this Hashtable:  used in computing the threshold.\n    * @serial\n    */\n-  final float loadFactor;\n+  private final float loadFactor;\n \n   /**\n    * Array containing the actual key-value mappings.\n    */\n+  // Package visible for use by nested classes.\n   transient HashEntry[] buckets;\n \n   /**\n    * Counts the number of modifications this Hashtable has undergone, used\n    * by Iterators to know when to throw ConcurrentModificationExceptions.\n    */\n+  // Package visible for use by nested classes.\n   transient int modCount;\n \n   /**\n    * The size of this Hashtable:  denotes the number of key-value pairs.\n    */\n+  // Package visible for use by nested classes.\n   transient int size;\n \n+  /**\n+   * The cache for {@link #keySet()}.\n+   */\n+  private transient Set keys;\n+\n+  /**\n+   * The cache for {@link #values()}.\n+   */\n+  private transient Collection values;\n+\n+  /**\n+   * The cache for {@link #entrySet()}.\n+   */\n+  private transient Set entries;\n+\n   /**\n    * Class to represent an entry in the hash table. Holds a single key-value\n    * pair. A Hashtable Entry is identical to a HashMap Entry, except that\n    * `null' is not allowed for keys and values.\n    */\n-  static class HashEntry extends BasicMapEntry\n+  private static final class HashEntry extends BasicMapEntry\n   {\n     /** The next entry in the linked list. */\n     HashEntry next;\n@@ -159,7 +186,7 @@ static class HashEntry extends BasicMapEntry\n      * @return the prior value\n      * @throws NullPointerException if <code>newVal</code> is null\n      */\n-    public final Object setValue(Object newVal)\n+    public Object setValue(Object newVal)\n     {\n       if (newVal == null)\n         throw new NullPointerException();\n@@ -193,15 +220,15 @@ public Hashtable()\n   public Hashtable(Map m)\n   {\n     this(Math.max(m.size() * 2, DEFAULT_CAPACITY), DEFAULT_LOAD_FACTOR);\n-    putAll(m);\n+    putAllInternal(m);\n   }\n \n   /**\n    * Construct a new Hashtable with a specific inital capacity and\n    * default load factor of 0.75.\n    *\n-   * @param initialCapacity the initial capacity of this Hashtable (>=0)\n-   * @throws IllegalArgumentException if (initialCapacity < 0)\n+   * @param initialCapacity the initial capacity of this Hashtable (&gt;= 0)\n+   * @throws IllegalArgumentException if (initialCapacity &lt; 0)\n    */\n   public Hashtable(int initialCapacity)\n   {\n@@ -212,10 +239,10 @@ public Hashtable(int initialCapacity)\n    * Construct a new Hashtable with a specific initial capacity and\n    * load factor.\n    *\n-   * @param initialCapacity the initial capacity (>=0)\n-   * @param loadFactor the load factor (>0, not NaN)\n-   * @throws IllegalArgumentException if (initialCapacity < 0) ||\n-   *                                     ! (loadFactor > 0.0)\n+   * @param initialCapacity the initial capacity (&gt;= 0)\n+   * @param loadFactor the load factor (&gt; 0, not NaN)\n+   * @throws IllegalArgumentException if (initialCapacity &lt; 0) ||\n+   *                                     ! (loadFactor &gt; 0.0)\n    */\n   public Hashtable(int initialCapacity, float loadFactor)\n   {\n@@ -251,30 +278,36 @@ public synchronized boolean isEmpty()\n   }\n \n   /**\n-   * Return an enumeration of the keys of this table.\n+   * Return an enumeration of the keys of this table. There's no point\n+   * in synchronizing this, as you have already been warned that the\n+   * enumeration is not specified to be thread-safe.\n+   *\n    * @return the keys\n    * @see #elements()\n    * @see #keySet()\n    */\n-  public synchronized Enumeration keys()\n+  public Enumeration keys()\n   {\n-    return new Enumerator(Enumerator.KEYS);\n+    return new Enumerator(KEYS);\n   }\n \n   /**\n-   * Return an enumeration of the values of this table.\n+   * Return an enumeration of the values of this table. There's no point\n+   * in synchronizing this, as you have already been warned that the\n+   * enumeration is not specified to be thread-safe.\n+   *\n    * @return the values\n    * @see #keys()\n    * @see #values()\n    */\n-  public synchronized Enumeration elements()\n+  public Enumeration elements()\n   {\n-    return new Enumerator(Enumerator.VALUES);\n+    return new Enumerator(VALUES);\n   }\n \n   /**\n-   * Returns true if this Hashtable contains a value <pre>o</pre>,\n-   * such that <pre>o.equals(value)</pre>.  This is the same as\n+   * Returns true if this Hashtable contains a value <code>o</code>,\n+   * such that <code>o.equals(value)</code>.  This is the same as\n    * <code>containsValue()</code>, and is O(n).\n    * <p>\n    *\n@@ -284,48 +317,46 @@ public synchronized Enumeration elements()\n    *\n    * @param value the value to search for in this Hashtable\n    * @return true if at least one key maps to the value\n-   * @throws NullPointerException if <pre>value</pre> is null\n+   * @throws NullPointerException if <code>value</code> is null\n    * @see #containsValue(Object)\n    * @see #containsKey(Object)\n    */\n   public synchronized boolean contains(Object value)\n   {\n-    // Check if value is null in case Hashtable is empty.\n+    // Check if value is null.\n     if (value == null)\n       throw new NullPointerException();\n-\n-    for (int i = buckets.length - 1; i >= 0; i--)\n-      {\n-        HashEntry e = buckets[i];\n-        while (e != null)\n-          {\n-            if (value.equals(e.value))\n-              return true;\n-            e = e.next;\n-          }\n-      }\n-    return false;\n+    return containsValue(value);\n   }\n \n   /**\n-   * Returns true if this Hashtable contains a value <pre>o</pre>, such that\n-   * <pre>o.equals(value)</pre>. This is the new API for the old\n-   * <code>contains()</code>.\n+   * Returns true if this Hashtable contains a value <code>o</code>, such that\n+   * <code>o.equals(value)</code>. This is the new API for the old\n+   * <code>contains()</code>, except that it is forgiving of null.\n    *\n    * @param value the value to search for in this Hashtable\n    * @return true if at least one key maps to the value\n-   * @throws NullPointerException if <pre>value</pre> is null\n    * @see #contains(Object)\n    * @see #containsKey(Object)\n    * @since 1.2\n    */\n   public boolean containsValue(Object value)\n   {\n-    return contains(value);\n+    for (int i = buckets.length - 1; i >= 0; i--)\n+      {\n+        HashEntry e = buckets[i];\n+        while (e != null)\n+          {\n+            if (AbstractCollection.equals(value, e.value))\n+              return true;\n+            e = e.next;\n+          }\n+      }\n+    return false;\n   }\n \n   /**\n-   * Returns true if the supplied object <pre>equals()</pre> a key\n+   * Returns true if the supplied object <code>equals()</code> a key\n    * in this Hashtable.\n    *\n    * @param key the key to search for in this Hashtable\n@@ -348,7 +379,7 @@ public synchronized boolean containsKey(Object key)\n \n   /**\n    * Return the value in this Hashtable associated with the supplied key,\n-   * or <pre>null</pre> if the key maps to nothing.\n+   * or <code>null</code> if the key maps to nothing.\n    *\n    * @param key the key for which to fetch an associated value\n    * @return what the key maps to, if present\n@@ -383,7 +414,6 @@ public synchronized Object get(Object key)\n    */\n   public synchronized Object put(Object key, Object value)\n   {\n-    modCount++;\n     int idx = hash(key);\n     HashEntry e = buckets[idx];\n \n@@ -407,6 +437,7 @@ public synchronized Object put(Object key, Object value)\n       }\n \n     // At this point, we know we need to add a new entry.\n+    modCount++;\n     if (++size > threshold)\n       {\n         rehash();\n@@ -425,15 +456,18 @@ public synchronized Object put(Object key, Object value)\n   /**\n    * Removes from the table and returns the value which is mapped by the\n    * supplied key. If the key maps to nothing, then the table remains\n-   * unchanged, and <pre>null</pre> is returned.\n+   * unchanged, and <code>null</code> is returned.\n+   * <b>NOTE:</b>Map.remove and Dictionary.remove disagree whether null\n+   * is a valid parameter; at the moment, this implementation obeys Map.remove,\n+   * and silently ignores null.\n    *\n    * @param key the key used to locate the value to remove\n    * @return whatever the key mapped to, if present\n-   * @throws NullPointerException if key is null\n    */\n   public synchronized Object remove(Object key)\n   {\n-    modCount++;\n+    if (key == null)\n+      return null;\n     int idx = hash(key);\n     HashEntry e = buckets[idx];\n     HashEntry last = null;\n@@ -442,6 +476,7 @@ public synchronized Object remove(Object key)\n       {\n         if (key.equals(e.key))\n           {\n+            modCount++;\n             if (last == null)\n               buckets[idx] = e.next;\n             else\n@@ -488,9 +523,12 @@ public synchronized void putAll(Map m)\n    */\n   public synchronized void clear()\n   {\n-    modCount++;\n-    Arrays.fill(buckets, null);\n-    size = 0;\n+    if (size > 0)\n+      {\n+        modCount++;\n+        Arrays.fill(buckets, null);\n+        size = 0;\n+      }\n   }\n \n   /**\n@@ -511,36 +549,18 @@ public synchronized Object clone()\n         // This is impossible.\n       }\n     copy.buckets = new HashEntry[buckets.length];\n-\n-    for (int i = buckets.length - 1; i >= 0; i--)\n-      {\n-        HashEntry e = buckets[i];\n-        HashEntry last = null;\n-\n-        while (e != null)\n-          {\n-            if (last == null)\n-              {\n-                last = new HashEntry(e.key, e.value);\n-                copy.buckets[i] = last;\n-              }\n-            else\n-              {\n-                last.next = new HashEntry(e.key, e.value);\n-                last = last.next;\n-              }\n-            e = e.next;\n-          }\n-      }\n+    copy.putAllInternal(this);\n+    // Clear the caches.\n+    copy.keys = null;\n+    copy.values = null;\n+    copy.entries = null;\n     return copy;\n   }\n \n   /**\n-   * Converts this Hashtable to a String, surrounded by braces (<pre>'{'</pre>\n-   * and <pre>'}'</pre>), key/value pairs listed with an equals sign between,\n-   * (<pre>'='</pre>), and pairs separated by comma and space\n-   * (<pre>\", \"</pre>).\n-   * <p>\n+   * Converts this Hashtable to a String, surrounded by braces, and with\n+   * key/value pairs listed with an equals sign between, separated by a\n+   * comma and space. For example, <code>\"{a=1, b=2}\"</code>.<p>\n    *\n    * NOTE: if the <code>toString()</code> method of any key or value\n    * throws an exception, this will fail for the same reason.\n@@ -552,7 +572,7 @@ public synchronized String toString()\n     // Since we are already synchronized, and entrySet().iterator()\n     // would repeatedly re-lock/release the monitor, we directly use the\n     // unsynchronized HashIterator instead.\n-    Iterator entries = new HashIterator(HashIterator.ENTRIES);\n+    Iterator entries = new HashIterator(ENTRIES);\n     StringBuffer r = new StringBuffer(\"{\");\n     for (int pos = size; pos > 0; pos--)\n       {\n@@ -568,9 +588,11 @@ public synchronized String toString()\n    * Returns a \"set view\" of this Hashtable's keys. The set is backed by\n    * the hashtable, so changes in one show up in the other.  The set supports\n    * element removal, but not element addition.  The set is properly\n-   * synchronized on the original hashtable.  The set will throw a\n-   * {@link NullPointerException} if null is passed to <code>contains</code>,\n-   * <code>remove</code>, or related methods.\n+   * synchronized on the original hashtable.  Sun has not documented the\n+   * proper interaction of null with this set, but has inconsistent behavior\n+   * in the JDK. Therefore, in this implementation, contains, remove,\n+   * containsAll, retainAll, removeAll, and equals just ignore a null key\n+   * rather than throwing a {@link NullPointerException}.\n    *\n    * @return a set view of the keys\n    * @see #values()\n@@ -579,50 +601,56 @@ public synchronized String toString()\n    */\n   public Set keySet()\n   {\n-    // Create a synchronized AbstractSet with custom implementations of those\n-    // methods that can be overridden easily and efficiently.\n-    Set r = new AbstractSet()\n-    {\n-      public int size()\n+    if (keys == null)\n       {\n-        return size;\n-      }\n+        // Create a synchronized AbstractSet with custom implementations of\n+        // those methods that can be overridden easily and efficiently.\n+        Set r = new AbstractSet()\n+        {\n+          public int size()\n+          {\n+            return size;\n+          }\n \n-      public Iterator iterator()\n-      {\n-        return new HashIterator(HashIterator.KEYS);\n-      }\n+          public Iterator iterator()\n+          {\n+            return new HashIterator(KEYS);\n+          }\n \n-      public void clear()\n-      {\n-        Hashtable.this.clear();\n-      }\n+          public void clear()\n+          {\n+            Hashtable.this.clear();\n+          }\n \n-      public boolean contains(Object o)\n-      {\n-        return Hashtable.this.containsKey(o);\n-      }\n+          public boolean contains(Object o)\n+          {\n+            if (o == null)\n+              return false;\n+            return containsKey(o);\n+          }\n \n-      public boolean remove(Object o)\n-      {\n-        return (Hashtable.this.remove(o) != null);\n+          public boolean remove(Object o)\n+          {\n+            return Hashtable.this.remove(o) != null;\n+          }\n+        };\n+        // We must specify the correct object to synchronize upon, hence the\n+        // use of a non-public API\n+        keys = new Collections.SynchronizedSet(this, r);\n       }\n-    };\n-\n-    // We must specify the correct object to synchronize upon, hence the\n-    // use of a non-public API\n-    return new Collections.SynchronizedSet(this, r);\n+    return keys;\n   }\n \n-\n   /**\n    * Returns a \"collection view\" (or \"bag view\") of this Hashtable's values.\n    * The collection is backed by the hashtable, so changes in one show up\n    * in the other.  The collection supports element removal, but not element\n    * addition.  The collection is properly synchronized on the original\n-   * hashtable.  The collection will throw a {@link NullPointerException}\n-   * if null is passed to <code>contains</code> or related methods, but not\n-   * if passed to <code>remove</code> or related methods.\n+   * hashtable.  Sun has not documented the proper interaction of null with\n+   * this set, but has inconsistent behavior in the JDK. Therefore, in this\n+   * implementation, contains, remove, containsAll, retainAll, removeAll, and\n+   * equals just ignore a null value rather than throwing a\n+   * {@link NullPointerException}.\n    *\n    * @return a bag view of the values\n    * @see #keySet()\n@@ -631,46 +659,45 @@ public boolean remove(Object o)\n    */\n   public Collection values()\n   {\n-    // We don't bother overriding many of the optional methods, as doing so\n-    // wouldn't provide any significant performance advantage.\n-    Collection r = new AbstractCollection()\n-    {\n-      public int size()\n-      {\n-        return size;\n-      }\n-\n-      public Iterator iterator()\n+    if (values == null)\n       {\n-        return new HashIterator(HashIterator.VALUES);\n-      }\n+        // We don't bother overriding many of the optional methods, as doing so\n+        // wouldn't provide any significant performance advantage.\n+        Collection r = new AbstractCollection()\n+        {\n+          public int size()\n+          {\n+            return size;\n+          }\n \n-      public void clear()\n-      {\n-        Hashtable.this.clear();\n-      }\n+          public Iterator iterator()\n+          {\n+            return new HashIterator(VALUES);\n+          }\n \n-      // Override this so that we check for null\n-      public boolean contains(Object o)\n-      {\n-        return Hashtable.this.contains(o);\n+          public void clear()\n+          {\n+            Hashtable.this.clear();\n+          }\n+        };\n+        // We must specify the correct object to synchronize upon, hence the\n+        // use of a non-public API\n+        values = new Collections.SynchronizedCollection(this, r);\n       }\n-    };\n-\n-    // We must specify the correct object to synchronize upon, hence the\n-    // use of a non-public API\n-    return new Collections.SynchronizedCollection(this, r);\n+    return values;\n   }\n \n   /**\n    * Returns a \"set view\" of this Hashtable's entries. The set is backed by\n    * the hashtable, so changes in one show up in the other.  The set supports\n    * element removal, but not element addition.  The set is properly\n-   * synchronized on the original hashtable.  The set will throw a\n-   * {@link NullPointerException} if the Map.Entry passed to\n-   * <code>contains</code>, <code>remove</code>, or related methods returns\n-   * null for <code>getKey</code>, but not if the Map.Entry is null or\n-   * returns null for <code>getValue</code>.\n+   * synchronized on the original hashtable.  Sun has not documented the\n+   * proper interaction of null with this set, but has inconsistent behavior\n+   * in the JDK. Therefore, in this implementation, contains, remove,\n+   * containsAll, retainAll, removeAll, and equals just ignore a null entry,\n+   * or an entry with a null key or value, rather than throwing a\n+   * {@link NullPointerException}. However, calling entry.setValue(null)\n+   * will fail.\n    * <p>\n    *\n    * Note that the iterators for all three views, from keySet(), entrySet(),\n@@ -684,49 +711,52 @@ public boolean contains(Object o)\n    */\n   public Set entrySet()\n   {\n-    // Create an AbstractSet with custom implementations of those methods that\n-    // can be overridden easily and efficiently.\n-    Set r = new AbstractSet()\n-    {\n-      public int size()\n+    if (entries == null)\n       {\n-        return size;\n-      }\n+        // Create an AbstractSet with custom implementations of those methods\n+        // that can be overridden easily and efficiently.\n+        Set r = new AbstractSet()\n+        {\n+          public int size()\n+          {\n+            return size;\n+          }\n \n-      public Iterator iterator()\n-      {\n-        return new HashIterator(HashIterator.ENTRIES);\n-      }\n+          public Iterator iterator()\n+          {\n+            return new HashIterator(ENTRIES);\n+          }\n \n-      public void clear()\n-      {\n-        Hashtable.this.clear();\n-      }\n+          public void clear()\n+          {\n+            Hashtable.this.clear();\n+          }\n \n-      public boolean contains(Object o)\n-      {\n-        return getEntry(o) != null;\n-      }\n+          public boolean contains(Object o)\n+          {\n+            return getEntry(o) != null;\n+          }\n \n-      public boolean remove(Object o)\n-      {\n-        HashEntry e = getEntry(o);\n-        if (e != null)\n+          public boolean remove(Object o)\n           {\n-            Hashtable.this.remove(e.key);\n-            return true;\n+            HashEntry e = getEntry(o);\n+            if (e != null)\n+              {\n+                Hashtable.this.remove(e.key);\n+                return true;\n+              }\n+            return false;\n           }\n-        return false;\n+        };\n+        // We must specify the correct object to synchronize upon, hence the\n+        // use of a non-public API\n+        entries = new Collections.SynchronizedSet(this, r);\n       }\n-    };\n-\n-    // We must specify the correct object to synchronize upon, hence the\n-    // use of a non-public API\n-    return new Collections.SynchronizedSet(this, r);\n+    return entries;\n   }\n \n   /**\n-   * Returns true if this Hashtable equals the supplied Object <pre>o</pre>.\n+   * Returns true if this Hashtable equals the supplied Object <code>o</code>.\n    * As specified by Map, this is:\n    * <pre>\n    * (o instanceof Map) && entrySet().equals(((Map) o).entrySet());\n@@ -759,7 +789,7 @@ public synchronized int hashCode()\n     // Since we are already synchronized, and entrySet().iterator()\n     // would repeatedly re-lock/release the monitor, we directly use the\n     // unsynchronized HashIterator instead.\n-    Iterator itr = new HashIterator(HashIterator.ENTRIES);\n+    Iterator itr = new HashIterator(ENTRIES);\n     int hashcode = 0;\n     for (int pos = size; pos > 0; pos--)\n       hashcode += itr.next().hashCode();\n@@ -782,29 +812,55 @@ private int hash(Object key)\n \n   /**\n    * Helper method for entrySet(), which matches both key and value\n-   * simultaneously.\n+   * simultaneously. Ignores null, as mentioned in entrySet().\n    *\n    * @param o the entry to match\n    * @return the matching entry, if found, or null\n-   * @throws NullPointerException if me.getKey() returns null\n    * @see #entrySet()\n    */\n   private HashEntry getEntry(Object o)\n   {\n-    if (!(o instanceof Map.Entry))\n+    if (! (o instanceof Map.Entry))\n+      return null;\n+    Object key = ((Map.Entry) o).getKey();\n+    if (key == null)\n       return null;\n-    Map.Entry me = (Map.Entry) o;\n-    int idx = hash(me.getKey());\n+\n+    int idx = hash(key);\n     HashEntry e = buckets[idx];\n     while (e != null)\n       {\n-        if (e.equals(me))\n+        if (o.equals(e))\n           return e;\n         e = e.next;\n       }\n     return null;\n   }\n \n+  /**\n+   * A simplified, more efficient internal implementation of putAll(). The \n+   * Map constructor and clone() should not call putAll or put, in order to \n+   * be compatible with the JDK implementation with respect to subclasses.\n+   *\n+   * @param m the map to initialize this from\n+   */\n+  void putAllInternal(Map m)\n+  {\n+    Iterator itr = m.entrySet().iterator();\n+    int msize = m.size();\n+    this.size = msize;\n+\n+    for (; msize > 0; msize--)\n+      {\n+\tMap.Entry e = (Map.Entry) itr.next();\n+\tObject key = e.getKey();\n+\tint idx = hash(key);\n+\tHashEntry he = new HashEntry(key, e.getValue());\n+\the.next = buckets[idx];\n+\tbuckets[idx] = he;\n+      }\n+  }\n+\n   /**\n    * Increases the size of the Hashtable and rehashes all keys to new array\n    * indices; this is called when the addition of a new value would cause\n@@ -813,7 +869,8 @@ private HashEntry getEntry(Object o)\n    * <p>\n    *\n    * This is not specified, but the new size is twice the current size plus\n-   * one; this number is not always prime, unfortunately.\n+   * one; this number is not always prime, unfortunately. This implementation\n+   * is not synchronized, as it is only invoked from synchronized methods.\n    */\n   protected void rehash()\n   {\n@@ -854,8 +911,8 @@ protected void rehash()\n    *\n    * @param s the stream to write to\n    * @throws IOException if the underlying stream fails\n-   * @serialData the <i>capacity</i>(int) that is the length of the\n-   *             bucket array, the <i>size</i>(int) of the hash map\n+   * @serialData the <i>capacity</i> (int) that is the length of the\n+   *             bucket array, the <i>size</i> (int) of the hash map\n    *             are emitted first.  They are followed by size entries,\n    *             each consisting of a key (Object) and a value (Object).\n    */\n@@ -870,7 +927,7 @@ private synchronized void writeObject(ObjectOutputStream s)\n     // Since we are already synchronized, and entrySet().iterator()\n     // would repeatedly re-lock/release the monitor, we directly use the\n     // unsynchronized HashIterator instead.\n-    Iterator it = new HashIterator(HashIterator.ENTRIES);\n+    Iterator it = new HashIterator(ENTRIES);\n     while (it.hasNext())\n       {\n         HashEntry entry = (HashEntry) it.next();\n@@ -885,8 +942,8 @@ private synchronized void writeObject(ObjectOutputStream s)\n    * @param s the stream to read from\n    * @throws ClassNotFoundException if the underlying stream fails\n    * @throws IOException if the underlying stream fails\n-   * @serialData the <i>capacity</i>(int) that is the length of the\n-   *             bucket array, the <i>size</i>(int) of the hash map\n+   * @serialData the <i>capacity</i> (int) that is the length of the\n+   *             bucket array, the <i>size</i> (int) of the hash map\n    *             are emitted first.  They are followed by size entries,\n    *             each consisting of a key (Object) and a value (Object).\n    */\n@@ -901,7 +958,8 @@ private void readObject(ObjectInputStream s)\n     int len = s.readInt();\n \n     // Read and use key/value pairs.\n-    for ( ; len > 0; len--)\n+    // TODO: should we be defensive programmers, and check for illegal nulls?\n+    while (--len >= 0)\n       put(s.readObject(), s.readObject());\n   }\n \n@@ -916,13 +974,8 @@ private void readObject(ObjectInputStream s)\n    *\n    * @author Jon Zeppieri\n    */\n-  class HashIterator implements Iterator\n+  private final class HashIterator implements Iterator\n   {\n-    /** \"enum\" of iterator types. */\n-    static final int KEYS = 0,\n-                     VALUES = 1,\n-                     ENTRIES = 2;\n-\n     /**\n      * The type of this Iterator: {@link #KEYS}, {@link #VALUES},\n      * or {@link #ENTRIES}.\n@@ -988,14 +1041,14 @@ public Object next()\n       last = e;\n       if (type == VALUES)\n         return e.value;\n-      else if (type == KEYS)\n+      if (type == KEYS)\n         return e.key;\n       return e;\n     }\n \n     /**\n      * Removes from the backing Hashtable the last element which was fetched\n-     * with the <pre>next()</pre> method.\n+     * with the <code>next()</code> method.\n      * @throws ConcurrentModificationException if the hashtable was modified\n      * @throws IllegalStateException if called when there is no last element\n      */\n@@ -1007,10 +1060,10 @@ public void remove()\n         throw new IllegalStateException();\n \n       Hashtable.this.remove(last.key);\n-      knownMod++;\n       last = null;\n+      knownMod++;\n     }\n-  }\n+  } // class HashIterator\n \n \n   /**\n@@ -1027,21 +1080,21 @@ public void remove()\n    *\n    * @author Jon Zeppieri\n    */\n-  class Enumerator implements Enumeration\n+  private final class Enumerator implements Enumeration\n   {\n-    /** \"enum\" of iterator types. */\n-    static final int KEYS = 0,\n-                     VALUES = 1;\n-\n     /**\n      * The type of this Iterator: {@link #KEYS} or {@link #VALUES}.\n      */\n-    int type;\n+    final int type;\n+    /** The number of elements remaining to be returned by next(). */\n+    int count = size;\n     /** Current index in the physical hash table. */\n-    int idx;\n-    /** The last Entry returned by nextEntry(). */\n-    HashEntry last;\n-    /** Entry which will be returned by the next nextElement() call. */\n+    int idx = buckets.length;\n+    /**\n+     * Entry which will be returned by the next nextElement() call. It is\n+     * set if we are iterating through a bucket with multiple entries, or null\n+     * if we must look in the next bucket.\n+     */\n     HashEntry next;\n \n     /**\n@@ -1051,25 +1104,6 @@ class Enumerator implements Enumeration\n     Enumerator(int type)\n     {\n       this.type = type;\n-      this.idx = buckets.length;\n-    }\n-\n-    /**\n-     * Helper method to find the next entry.\n-     * @return the next entry, or null\n-     */\n-    private HashEntry nextEntry()\n-    {\n-      HashEntry e = null;\n-\n-      if (last != null)\n-        e = last.next;\n-\n-      while (e == null && idx > 0)\n-        e = buckets[--idx];\n-\n-      last = e;\n-      return e;\n     }\n \n     /**\n@@ -1078,10 +1112,7 @@ private HashEntry nextEntry()\n      */\n     public boolean hasMoreElements()\n     {\n-      if (next != null)\n-        return true;\n-      next = nextEntry();\n-      return next != null;\n+      return count > 0;\n     }\n \n     /**\n@@ -1091,19 +1122,16 @@ public boolean hasMoreElements()\n      */\n     public Object nextElement()\n     {\n-      HashEntry e;\n-      if (next != null)\n-        {\n-          e = next;\n-          next = null;\n-        }\n-      else\n-        e = nextEntry();\n-      if (e == null)\n+      if (count == 0)\n         throw new NoSuchElementException(\"Hashtable Enumerator\");\n-      if (type == VALUES)\n-        return e.value;\n-      return e.key;\n+      count--;\n+      HashEntry e = next;\n+\n+      while (e == null)\n+        e = buckets[--idx];\n+\n+      next = e.next;\n+      return type == VALUES ? e.value : e.key;\n     }\n-  }\n+  } // class Enumerator\n }"}, {"sha": "d6a2f7c7c2d6ee159d8ab405b0e17356e8b96568", "filename": "libjava/java/util/IdentityHashMap.java", "status": "modified", "additions": 764, "deletions": 279, "changes": 1043, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2Fjava%2Futil%2FIdentityHashMap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2Fjava%2Futil%2FIdentityHashMap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FIdentityHashMap.java?ref=d9fd7154ec7908eff8bbbce75651eccf51064ac1", "patch": "@@ -31,403 +31,888 @@\n \n /**\n  * This class provides a hashtable-backed implementation of the\n- * Map interface.  Unlike HashMap, it uses object identity to\n- * do its hashing.  Also, it uses a linear-probe hash table.\n+ * Map interface, but uses object identity to do its hashing.  In fact,\n+ * it uses object identity for comparing values, as well. It uses a\n+ * linear-probe hash table, which may have faster performance\n+ * than the chaining employed by HashMap.\n+ * <p>\n+ *\n+ * <em>WARNING: This is not a general purpose map. Because it uses\n+ * System.identityHashCode and ==, instead of hashCode and equals, for\n+ * comparison, it violated Map's general contract, and may cause\n+ * undefined behavior when compared to other maps which are not\n+ * IdentityHashMaps.  This is designed only for the rare cases when\n+ * identity semantics are needed.</em> An example use is\n+ * topology-preserving graph transformations, such as deep cloning,\n+ * or as proxy object mapping such as in debugging.\n+ * <p>\n+ *\n+ * This map permits <code>null</code> keys and values, and does not\n+ * guarantee that elements will stay in the same order over time. The\n+ * basic operations (<code>get</code> and <code>put</code>) take\n+ * constant time, provided System.identityHashCode is decent. You can\n+ * tune the behavior by specifying the expected maximum size. As more\n+ * elements are added, the map may need to allocate a larger table,\n+ * which can be expensive.\n+ * <p>\n+ *\n+ * This implementation is unsynchronized.  If you want multi-thread\n+ * access to be consistent, you must synchronize it, perhaps by using\n+ * <code>Collections.synchronizedMap(new IdentityHashMap(...));</code>.\n+ * The iterators are <i>fail-fast</i>, meaning that a structural modification\n+ * made to the map outside of an iterator's remove method cause the\n+ * iterator, and in the case of the entrySet, the Map.Entry, to\n+ * fail with a {@link ConcurrentModificationException}.\n  *\n  * @author Tom Tromey <tromey@redhat.com>\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @see System#identityHashCode(Object)\n+ * @see Collection\n+ * @see Map\n+ * @see HashMap\n+ * @see TreeMap\n+ * @see LinkedHashMap\n+ * @see WeakHashMap\n  * @since 1.4\n+ * @status updated to 1.4\n  */\n public class IdentityHashMap extends AbstractMap\n   implements Map, Serializable, Cloneable\n {\n+  /** The default capacity. */\n   private static final int DEFAULT_CAPACITY = 21;\n \n-  /** Create a new IdentityHashMap with the default capacity (21\n-   * entries).\n+  /**\n+   * This object is used to mark deleted items. Package visible for use by\n+   * nested classes.\n+   */\n+  static final Object tombstone = new Object();\n+\n+  /**\n+   * This object is used to mark empty slots.  We need this because\n+   * using null is ambiguous. Package visible for use by nested classes.\n+   */\n+  static final Object emptyslot = new Object();\n+\n+  /**\n+   * Compatible with JDK 1.4.\n+   */\n+  private static final long serialVersionUID = 8188218128353913216L;\n+\n+  /**\n+   * The number of mappings in the table. Package visible for use by nested\n+   * classes.\n+   * @serial\n+   */\n+  int size;\n+\n+  /**\n+   * The table itself. Package visible for use by nested classes.\n    */\n-  public IdentityHashMap ()\n+  transient Object[] table;\n+\n+  /**\n+   * The number of structural modifications made so far. Package visible for\n+   * use by nested classes.\n+   */\n+  transient int modCount;\n+\n+  /**\n+   * The cache for {@link #entrySet()}.\n+   */\n+  private transient Set entries;\n+\n+  /**\n+   * The threshold for rehashing, which is 75% of (table.length / 2).\n+   */\n+  private transient int threshold;\n+\n+  /**\n+   * Create a new IdentityHashMap with the default capacity (21 entries).\n+   */\n+  public IdentityHashMap()\n   {\n-    this (DEFAULT_CAPACITY);\n+    this(DEFAULT_CAPACITY);\n   }\n \n-  /** Create a new IdentityHashMap with the indicated number of\n+  /**\n+   * Create a new IdentityHashMap with the indicated number of\n    * entries.  If the number of elements added to this hash map\n    * exceeds this maximum, the map will grow itself; however, that\n    * incurs a performance penalty.\n-   * @param max Initial size\n+   *\n+   * @param max initial size\n+   * @throws IllegalArgumentException if max is negative\n    */\n-  public IdentityHashMap (int max)\n+  public IdentityHashMap(int max)\n   {\n     if (max < 0)\n-      throw new IllegalArgumentException ();\n+      throw new IllegalArgumentException();\n+    // Need at least two slots, or hash() will break.\n+    if (max < 2)\n+      max = 2;\n     table = new Object[2 * max];\n-    Arrays.fill (table, emptyslot);\n-    size = 0;\n+    Arrays.fill(table, emptyslot);\n+    // This is automatically set.\n+    // size = 0;\n+    threshold = max / 4 * 3;\n   }\n \n-  /** Create a new IdentityHashMap whose contents are taken from the\n+  /**\n+   * Create a new IdentityHashMap whose contents are taken from the\n    * given Map.\n-   * @param m The map whose elements are to be put in this map.\n+   *\n+   * @param m The map whose elements are to be put in this map\n+   * @throws NullPointerException if m is null\n    */\n-  public IdentityHashMap (Map m)\n+  public IdentityHashMap(Map m)\n   {\n-    int len = 2 * Math.max (m.size (), DEFAULT_CAPACITY);\n-    table = new Object[len];\n-    Arrays.fill (table, emptyslot);\n-    putAll (m);\n+    this(Math.max(m.size() * 2, DEFAULT_CAPACITY));\n+    putAll(m);\n   }\n \n-  public void clear ()\n+  /**\n+   * Remove all mappings from this map.\n+   */\n+  public void clear()\n   {\n-    Arrays.fill (table, emptyslot);\n-    size = 0;\n+    if (size != 0)\n+      {\n+        modCount++;\n+        Arrays.fill(table, emptyslot);\n+        size = 0;\n+      }\n   }\n \n   /**\n    * Creates a shallow copy where keys and values are not cloned.\n    */\n-  public Object clone ()\n+  public Object clone()\n   {\n-    try \n+    try\n       {\n-        IdentityHashMap copy = (IdentityHashMap) super.clone ();\n-\tcopy.table = (Object[]) table.clone ();\n-\treturn copy;\n+        IdentityHashMap copy = (IdentityHashMap) super.clone();\n+        copy.table = (Object[]) table.clone();\n+        copy.entries = null; // invalidate the cache\n+        return copy;\n       }\n-    catch (CloneNotSupportedException e) \n+    catch (CloneNotSupportedException e)\n       {\n-\t// Can't happen.\n-\treturn null;\n+        // Can't happen.\n+        return null;\n       }\n   }\n \n-  public boolean containsKey (Object key)\n+  /**\n+   * Tests whether the specified key is in this map.  Unlike normal Maps,\n+   * this test uses <code>entry == key</code> instead of\n+   * <code>entry == null ? key == null : entry.equals(key)</code>.\n+   *\n+   * @param key the key to look for\n+   * @return true if the key is contained in the map\n+   * @see #containsValue(Object)\n+   * @see #get(Object)\n+   */\n+  public boolean containsKey(Object key)\n   {\n-    int h = getHash (key);\n-    int save = h;\n-    while (true)\n-      {\n-\tif (table[h] == key)\n-\t  return true;\n-\tif (table[h] == emptyslot)\n-\t  return false;\n-\th += 2;\n-\tif (h >= table.length)\n-\t  h = 0;\n-\tif (h == save)\n-\t  return false;\n-      }\n+    return key == table[hash(key)];\n   }\n \n-  public boolean containsValue (Object value)\n+  /**\n+   * Returns true if this HashMap contains the value.  Unlike normal maps,\n+   * this test uses <code>entry == value</code> instead of\n+   * <code>entry == null ? value == null : entry.equals(value)</code>.\n+   *\n+   * @param value the value to search for in this HashMap\n+   * @return true if at least one key maps to the value\n+   * @see #containsKey(Object)\n+   */\n+  public boolean containsValue(Object value)\n   {\n-    for (int i = 1; i < table.length; i += 2)\n+    for (int i = table.length - 1; i > 0; i -= 2)\n       if (table[i] == value)\n-\treturn true;\n+        return true;\n     return false;\n   }\n \n-  public Set entrySet ()\n+  /**\n+   * Returns a \"set view\" of this Map's entries. The set is backed by\n+   * the Map, so changes in one show up in the other.  The set supports\n+   * element removal, but not element addition.\n+   * <p>\n+   *\n+   * <em>The semantics of this set, and of its contained entries, are\n+   * different from the contract of Set and Map.Entry in order to make\n+   * IdentityHashMap work.  This means that while you can compare these\n+   * objects between IdentityHashMaps, comparing them with regular sets\n+   * or entries is likely to have undefined behavior.</em>  The entries\n+   * in this set are reference-based, rather than the normal object\n+   * equality.  Therefore, <code>e1.equals(e2)</code> returns\n+   * <code>e1.getKey() == e2.getKey() && e1.getValue() == e2.getValue()</code>,\n+   * and <code>e.hashCode()</code> returns\n+   * <code>System.identityHashCode(e.getKey()) ^\n+   *       System.identityHashCode(e.getValue())</code>.\n+   * <p>\n+   *\n+   * Note that the iterators for all three views, from keySet(), entrySet(),\n+   * and values(), traverse the Map in the same sequence.\n+   *\n+   * @return a set view of the entries\n+   * @see #keySet()\n+   * @see #values()\n+   * @see Map.Entry\n+   */\n+  public Set entrySet()\n   {\n-    return new AbstractSet ()\n-    {\n-      public int size ()\n+    if (entries == null)\n+      entries = new AbstractSet()\n       {\n-\treturn size;\n-      }\n-\n-      public Iterator iterator ()\n-      {\n-\treturn new IdentityIterator (IdentityIterator.ENTRIES);\n-      }\n-\n-      public void clear ()\n-      {\n-\tIdentityHashMap.this.clear ();\n-      }\n+        public int size()\n+        {\n+          return size;\n+        }\n+\n+        public Iterator iterator()\n+        {\n+          return new IdentityIterator(ENTRIES);\n+        }\n+\n+        public void clear()\n+        {\n+          IdentityHashMap.this.clear();\n+        }\n+\n+        public boolean contains(Object o)\n+        {\n+          if (! (o instanceof Map.Entry))\n+            return false;\n+          Map.Entry m = (Map.Entry) o;\n+          return m.getValue() == table[hash(m.getKey()) + 1];\n+        }\n+\n+        public int hashCode()\n+        {\n+          return IdentityHashMap.this.hashCode();\n+        }\n+\n+        public boolean remove(Object o)\n+        {\n+          if (! (o instanceof Map.Entry))\n+            return false;\n+          Object key = ((Map.Entry) o).getKey();\n+          int h = hash(key);\n+          if (table[h] == key)\n+            {\n+              size--;\n+              modCount++;\n+              table[h] = tombstone;\n+              table[h + 1] = tombstone;\n+              return true;\n+            }\n+          return false;\n+        }\n+      };\n+    return entries;\n+  }\n \n-      public boolean contains (Object o)\n-      {\n-\tif (! (o instanceof Map.Entry))\n-\t  return false;\n-\tMap.Entry m = (Map.Entry) o;\n-\treturn (IdentityHashMap.this.containsKey (m.getKey ())\n-\t\t&& IdentityHashMap.this.get (m.getKey ()) == m.getValue ());\n-      }\n+  /**\n+   * Compares two maps for equality. This returns true only if both maps\n+   * have the same reference-identity comparisons. While this returns\n+   * <code>this.entrySet().equals(m.entrySet())</code> as specified by Map,\n+   * this will not work with normal maps, since the entry set compares\n+   * with == instead of .equals.\n+   *\n+   * @param o the object to compare to\n+   * @return true if it is equal\n+   */\n+  public boolean equals(Object o)\n+  {\n+    // Why did Sun specify this one? The superclass does the right thing.\n+    return super.equals(o);\n+  }\n \n-      public boolean remove (Object o)\n-      {\n-\tif (! (o instanceof Map.Entry))\n-\t  return false;\n-\tMap.Entry m = (Map.Entry) o;\n-\tif (IdentityHashMap.this.containsKey (m.getKey ())\n-\t    && IdentityHashMap.this.get (m.getKey ()) == m.getValue ())\n-\t  {\n-\t    int oldsize = size;\n-\t    IdentityHashMap.this.remove (m.getKey ());\n-\t    return oldsize != size;\n-\t  }\n-\treturn false;\n-      }\n-    };\n+  /**\n+   * Return the value in this Map associated with the supplied key,\n+   * or <pre>null</pre> if the key maps to nothing.  NOTE: Since the value\n+   * could also be null, you must use containsKey to see if this key\n+   * actually maps to something.  Unlike normal maps, this tests for the key\n+   * with <code>entry == key</code> instead of\n+   * <code>entry == null ? key == null : entry.equals(key)</code>.\n+   *\n+   * @param key the key for which to fetch an associated value\n+   * @return what the key maps to, if present\n+   * @see #put(Object, Object)\n+   * @see #containsKey(Object)\n+   */\n+  public Object get(Object key)\n+  {\n+    int h = hash(key);\n+    return table[h] == key ? table[h + 1] : null;\n   }\n \n-  public Object get (Object key)\n+  /**\n+   * Returns the hashcode of this map. This guarantees that two\n+   * IdentityHashMaps that compare with equals() will have the same hash code,\n+   * but may break with comparison to normal maps since it uses\n+   * System.identityHashCode() instead of hashCode().\n+   *\n+   * @return the hash code\n+   */\n+  public int hashCode()\n   {\n-    int h = getHash (key);\n-    int save = h;\n-    while (true)\n+    int hash = 0;\n+    for (int i = table.length - 2; i >= 0; i -= 2)\n       {\n-\tif (table[h] == key)\n-\t  return table[h + 1];\n-\tif (table[h] == emptyslot)\n-\t  return null;\n-\th += 2;\n-\tif (h >= table.length)\n-\t  h = 0;\n-\tif (h == save)\n-\t  return null;\n+        Object key = table[i];\n+        if (key == emptyslot || key == tombstone)\n+          continue;\n+        hash += (System.identityHashCode(key)\n+                 ^ System.identityHashCode(table[i + 1]));\n       }\n+    return hash;\n   }\n \n-  public boolean isEmpty ()\n+  /**\n+   * Returns true if there are no key-value mappings currently in this Map\n+   * @return <code>size() == 0</code>\n+   */\n+  public boolean isEmpty()\n   {\n     return size == 0;\n   }\n \n-  public Set keySet ()\n+  /**\n+   * Returns a \"set view\" of this Map's keys. The set is backed by the\n+   * Map, so changes in one show up in the other.  The set supports\n+   * element removal, but not element addition.\n+   * <p>\n+   *\n+   * <em>The semantics of this set are different from the contract of Set\n+   * in order to make IdentityHashMap work.  This means that while you can\n+   * compare these objects between IdentityHashMaps, comparing them with\n+   * regular sets is likely to have undefined behavior.</em>  The hashCode\n+   * of the set is the sum of the identity hash codes, instead of the\n+   * regular hashCodes, and equality is determined by reference instead\n+   * of by the equals method.\n+   * <p>\n+   *\n+   * @return a set view of the keys\n+   * @see #values()\n+   * @see #entrySet()\n+   */\n+  public Set keySet()\n   {\n-    return new AbstractSet ()\n-    {\n-      public int size ()\n-      {\n-\treturn size;\n-      }\n-\n-      public Iterator iterator ()\n-      {\n-\treturn new IdentityIterator (IdentityIterator.KEYS);\n-      }\n-\n-      public void clear ()\n+    if (keys == null)\n+      keys = new AbstractSet()\n       {\n-\tIdentityHashMap.this.clear ();\n-      }\n-\n-      public boolean contains (Object o)\n-      {\n-\treturn IdentityHashMap.this.containsKey (o);\n-      }\n-\n-      public boolean remove (Object o)\n-      {\n-\tint oldsize = size;\n-\tIdentityHashMap.this.remove (o);\n-\treturn oldsize != size;\n-      }\n-    };\n+        public int size()\n+        {\n+          return size;\n+        }\n+\n+        public Iterator iterator()\n+        {\n+          return new IdentityIterator(KEYS);\n+        }\n+\n+        public void clear()\n+        {\n+          IdentityHashMap.this.clear();\n+        }\n+\n+        public boolean contains(Object o)\n+        {\n+          return containsKey(o);\n+        }\n+\n+        public int hashCode()\n+        {\n+          int hash = 0;\n+          for (int i = table.length - 2; i >= 0; i -= 2)\n+            {\n+              Object key = table[i];\n+              if (key == emptyslot || key == tombstone)\n+                continue;\n+              hash += System.identityHashCode(key);\n+            }\n+          return hash;\n+\n+        }\n+\n+        public boolean remove(Object o)\n+        {\n+          int h = hash(o);\n+          if (table[h] == o)\n+            {\n+              size--;\n+              modCount++;\n+              table[h] = tombstone;\n+              table[h + 1] = tombstone;\n+              return true;\n+            }\n+          return false;\n+        }\n+      };\n+    return keys;\n   }\n \n-  public Object put (Object key, Object value)\n+  /**\n+   * Puts the supplied value into the Map, mapped by the supplied key.\n+   * The value may be retrieved by any object which <code>equals()</code>\n+   * this key. NOTE: Since the prior value could also be null, you must\n+   * first use containsKey if you want to see if you are replacing the\n+   * key's mapping.  Unlike normal maps, this tests for the key\n+   * with <code>entry == key</code> instead of\n+   * <code>entry == null ? key == null : entry.equals(key)</code>.\n+   *\n+   * @param key the key used to locate the value\n+   * @param value the value to be stored in the HashMap\n+   * @return the prior mapping of the key, or null if there was none\n+   * @see #get(Object)\n+   */\n+  public Object put(Object key, Object value)\n   {\n-    // Rehash if the load factor is too high.  We use a factor of 1.5\n-    // -- the division by 2 is implicit on both sides.\n-    if (size * 3 > table.length)\n-      {\n-\tObject[] old = table;\n-\ttable = new Object[old.length * 2];\n-\tArrays.fill (table, emptyslot);\n-\tsize = 0;\n-\tfor (int i = 0; i < old.length; i += 2)\n-\t  {\n-\t    if (old[i] != tombstone && old[i] != emptyslot)\n-\t      {\n-\t\t// Just use put.  This isn't very efficient, but it is\n-\t\t// ok.\n-\t\tput (old[i], old[i + 1]);\n-\t      }\n-\t  }\n-      }\n-\n-    int h = getHash (key);\n-    int save = h;\n-    int del = -1;\n-    while (true)\n+    // Rehash if the load factor is too high.\n+    if (size > threshold)\n       {\n-\tif (table[h] == key)\n-\t  {\n-\t    Object r = table[h + 1];\n-\t    table[h + 1] = value;\n-\t    return r;\n-\t  }\n-\telse if (table[h] == tombstone && del == -1)\n-\t  del = h;\n-\telse if (table[h] == emptyslot)\n-\t  {\n-\t    if (del == -1)\n-\t      del = h;\n-\t    break;\n-\t  }\n-\th += 2;\n-\tif (h >= table.length)\n-\t  h = 0;\n-\tif (h == save)\n-\t  break;\n+        Object[] old = table;\n+        // This isn't necessarily prime, but it is an odd number of key/value\n+        // slots, which has a higher probability of fewer collisions.\n+        table = new Object[old.length * 2 + 2];\n+        Arrays.fill(table, emptyslot);\n+        size = 0;\n+        threshold = table.length / 4 * 3;\n+\n+        for (int i = old.length - 2; i >= 0; i -= 2)\n+          {\n+            Object oldkey = old[i];\n+            if (oldkey != tombstone && oldkey != emptyslot)\n+              // Just use put.  This isn't very efficient, but it is ok.\n+              put(oldkey, old[i + 1]);\n+          }\n       }\n \n-    if (del != -1)\n+    int h = hash(key);\n+    if (table[h] == key)\n       {\n-\ttable[del] = key;\n-\ttable[del + 1] = value;\n-\t++size;\n-\treturn null;\n+        Object r = table[h + 1];\n+        table[h + 1] = value;\n+        return r;\n       }\n \n-    // This is an error.\n+    // At this point, we add a new mapping.\n+    modCount++;\n+    size++;\n+    table[h] = key;\n+    table[h + 1] = value;\n     return null;\n   }\n \n-  public Object remove (Object key)\n+  /**\n+   * Copies all of the mappings from the specified map to this. If a key\n+   * is already in this map, its value is replaced.\n+   *\n+   * @param m the map to copy\n+   * @throws NullPointerException if m is null\n+   */\n+  public void putAll(Map m)\n   {\n-    int h = getHash (key);\n-    int save = h;\n-    while (true)\n+    // Why did Sun specify this one? The superclass does the right thing.\n+    super.putAll(m);\n+  }\n+\n+  /**\n+   * Removes from the HashMap and returns the value which is mapped by the\n+   * supplied key. If the key maps to nothing, then the HashMap remains\n+   * unchanged, and <pre>null</pre> is returned. NOTE: Since the value\n+   * could also be null, you must use containsKey to see if you are\n+   * actually removing a mapping.  Unlike normal maps, this tests for the\n+   * key with <code>entry == key</code> instead of\n+   * <code>entry == null ? key == null : entry.equals(key)</code>.\n+   *\n+   * @param key the key used to locate the value to remove\n+   * @return whatever the key mapped to, if present\n+   */\n+  public Object remove(Object key)\n+  {\n+    int h = hash(key);\n+    if (table[h] == key)\n       {\n-\tif (table[h] == key)\n-\t  {\n-\t    Object r = table[h + 1];\n-\t    table[h] = tombstone;\n-\t    table[h + 1] = tombstone;\n-\t    --size;\n-\t    return r;\n-\t  }\n-\th += 2;\n-\tif (h >= table.length)\n-\t  h = 0;\n-\tif (h == save)\n-\t  break;\n+        modCount++;\n+        size--;\n+        Object r = table[h + 1];\n+        table[h] = tombstone;\n+        table[h + 1] = tombstone;\n+        return r;\n       }\n-\n     return null;\n   }\n \n-  public int size ()\n+  /**\n+   * Returns the number of kay-value mappings currently in this Map\n+   * @return the size\n+   */\n+  public int size()\n   {\n     return size;\n   }\n \n-  public Collection values ()\n+  /**\n+   * Returns a \"collection view\" (or \"bag view\") of this Map's values.\n+   * The collection is backed by the Map, so changes in one show up\n+   * in the other.  The collection supports element removal, but not element\n+   * addition.\n+   * <p>\n+   *\n+   * <em>The semantics of this set are different from the contract of\n+   * Collection in order to make IdentityHashMap work.  This means that\n+   * while you can compare these objects between IdentityHashMaps, comparing\n+   * them with regular sets is likely to have undefined behavior.</em>\n+   * Likewise, contains and remove go by == instead of equals().\n+   * <p>\n+   *\n+   * @return a bag view of the values\n+   * @see #keySet()\n+   * @see #entrySet()\n+   */\n+  public Collection values()\n   {\n-    return new AbstractCollection ()\n-    {\n-      public int size ()\n+    if (values == null)\n+      values = new AbstractCollection()\n       {\n-\treturn size;\n-      }\n+        public int size()\n+        {\n+          return size;\n+        }\n+\n+        public Iterator iterator()\n+        {\n+          return new IdentityIterator(VALUES);\n+        }\n+\n+        public void clear()\n+        {\n+          IdentityHashMap.this.clear();\n+        }\n+\n+        public boolean remove(Object o)\n+        {\n+          for (int i = table.length - 1; i > 0; i -= 2)\n+            if (table[i] == o)\n+              {\n+                modCount++;\n+                table[i - 1] = tombstone;\n+                table[i] = tombstone;\n+                size--;\n+                return true;\n+              }\n+          return false;\n+        }\n+      };\n+    return values;\n+  }\n \n-      public Iterator iterator ()\n-      {\n-\treturn new IdentityIterator (IdentityIterator.VALUES);\n-      }\n+  /**\n+   * Helper method which computes the hash code, then traverses the table\n+   * until it finds the key, or the spot where the key would go.\n+   *\n+   * @param key the key to check\n+   * @return the index where the key belongs\n+   * @see #IdentityHashMap(int)\n+   * @see #put(Object, Object)\n+   */\n+  // Package visible for use by nested classes.\n+  int hash(Object key)\n+  {\n+    // Implementation note: it is feasible for the table to have no\n+    // emptyslots, if it is full with entries and tombstones, so we must\n+    // remember where we started. If we encounter the key or an emptyslot,\n+    // we are done.  If we encounter a tombstone, the key may still be in\n+    // the array.  If we don't encounter the key, we use the first emptyslot\n+    // or tombstone we encountered as the location where the key would go.\n+    // By requiring at least 2 key/value slots, and rehashing at 75%\n+    // capacity, we guarantee that there will always be either an emptyslot\n+    // or a tombstone somewhere in the table.\n+    int h = 2 * Math.abs(System.identityHashCode(key) % table.length);\n+    int del = -1;\n+    int save = h;\n \n-      public void clear ()\n+    do\n       {\n-\tIdentityHashMap.this.clear ();\n+        if (table[h] == key)\n+          return h;\n+        if (table[h] == emptyslot)\n+          break;\n+        if (table[h] == tombstone && del < 0)\n+          del = h;\n+        h -= 2;\n+        if (h < 0)\n+          h = table.length - 2;\n       }\n-    };\n+    while (h != save);\n+\n+    return del < 0 ? h : del;\n   }\n \n-  private class IdentityIterator implements Iterator\n+  /**\n+   * This class allows parameterized iteration over IdentityHashMaps.  Based\n+   * on its construction, it returns the key or value of a mapping, or\n+   * creates the appropriate Map.Entry object with the correct fail-fast\n+   * semantics and identity comparisons.\n+   *\n+   * @author Tom Tromey <tromey@redhat.com>\n+   * @author Eric Blake <ebb9@email.byu.edu>\n+   */\n+  private final class IdentityIterator implements Iterator\n   {\n-    static final int KEYS = 0;\n-    static final int VALUES = 1;\n-    static final int ENTRIES = 2;\n-\n-    // Type of iterator.\n-    int type;\n-    // Location in the table.\n-    int loc;\n-    // How many items we've seen.\n-    int seen;\n-\n-    IdentityIterator (int type)\n+    /**\n+     * The type of this Iterator: {@link #KEYS}, {@link #VALUES},\n+     * or {@link #ENTRIES}.\n+     */\n+    final int type;\n+    /** The number of modifications to the backing Map that we know about. */\n+    int knownMod = modCount;\n+    /** The number of elements remaining to be returned by next(). */\n+    int count = size;\n+    /** Location in the table. */\n+    int loc = table.length;\n+\n+    /**\n+     * Construct a new Iterator with the supplied type.\n+     * @param type {@link #KEYS}, {@link #VALUES}, or {@link #ENTRIES}\n+     */\n+    IdentityIterator(int type)\n     {\n       this.type = type;\n-      loc = 0;\n-      seen = 0;\n     }\n \n-    public boolean hasNext ()\n+    /**\n+     * Returns true if the Iterator has more elements.\n+     * @return true if there are more elements\n+     * @throws ConcurrentModificationException if the Map was modified\n+     */\n+    public boolean hasNext()\n     {\n-      return seen < size;\n+      if (knownMod != modCount)\n+        throw new ConcurrentModificationException();\n+      return count > 0;\n     }\n \n-    public Object next ()\n+    /**\n+     * Returns the next element in the Iterator's sequential view.\n+     * @return the next element\n+     * @throws ConcurrentModificationException if the Map was modified\n+     * @throws NoSuchElementException if there is none\n+     */\n+    public Object next()\n     {\n-      while (true)\n-\t{\n-\t  loc += 2;\n-\t  if (loc >= table.length)\n-\t    throw new NoSuchElementException ();\n-\t  if (table[loc] != tombstone && table[loc] != emptyslot)\n-\t    {\n-\t      ++seen;\n-\t      return table[loc];\n-\t    }\n-\t}\n+      if (knownMod != modCount)\n+        throw new ConcurrentModificationException();\n+      if (count == 0)\n+        throw new NoSuchElementException();\n+      count--;\n+\n+      Object key;\n+      do\n+        {\n+          loc -= 2;\n+          key = table[loc];\n+        }\n+      while (key == emptyslot || key == tombstone);\n+\n+      return type == KEYS ? key : (type == VALUES ? table[loc + 1]\n+                                   : new IdentityEntry(loc));\n     }\n \n-    public void remove ()\n+    /**\n+     * Removes from the backing Map the last element which was fetched\n+     * with the <pre>next()</pre> method.\n+     * @throws ConcurrentModificationException if the Map was modified\n+     * @throws IllegalStateException if called when there is no last element\n+     */\n+    public void remove()\n     {\n-      if (loc >= table.length\n-\t  || table[loc] == tombstone\n-\t  || table[loc] == emptyslot)\n-\tthrow new IllegalStateException ();\n+      if (knownMod != modCount)\n+        throw new ConcurrentModificationException();\n+      if (loc == table.length || table[loc] == tombstone)\n+        throw new IllegalStateException();\n+      modCount++;\n+      size--;\n       table[loc] = tombstone;\n       table[loc + 1] = tombstone;\n-      --size;\n+      knownMod++;\n     }\n-  }\n+  } // class IdentityIterator\n+\n+  /**\n+   * This class provides Map.Entry objects for IdentityHashMaps.  The entry\n+   * is fail-fast, and will throw a ConcurrentModificationException if\n+   * the underlying map is modified, or if remove is called on the iterator\n+   * that generated this object.  It is identity based, so it violates\n+   * the general contract of Map.Entry, and is probably unsuitable for\n+   * comparison to normal maps; but it works among other IdentityHashMaps.\n+   *\n+   * @author Eric Blake <ebb9@email.byu.edu>\n+   */\n+  private final class IdentityEntry implements Map.Entry\n+  {\n+    /** The location of this entry. */\n+    final int loc;\n+    /** The number of modifications to the backing Map that we know about. */\n+    final int knownMod = modCount;\n+\n+    /**\n+     * Constructs the Entry.\n+     *\n+     * @param loc the location of this entry in table\n+     */\n+    IdentityEntry(int loc)\n+    {\n+      this.loc = loc;\n+    }\n+\n+    /**\n+     * Compares the specified object with this entry, using identity\n+     * semantics. Note that this can lead to undefined results with\n+     * Entry objects created by normal maps.\n+     *\n+     * @param o the object to compare\n+     * @return true if it is equal\n+     * @throws ConcurrentModificationException if the entry was invalidated\n+     *         by modifying the Map or calling Iterator.remove()\n+     */\n+    public boolean equals(Object o)\n+    {\n+      if (knownMod != modCount || table[loc] == tombstone)\n+        throw new ConcurrentModificationException();\n+      if (! (o instanceof Map.Entry))\n+        return false;\n+      Map.Entry e = (Map.Entry) o;\n+      return table[loc] == e.getKey() && table[loc + 1] == e.getValue();\n+    }\n+\n+    /**\n+     * Returns the key of this entry.\n+     *\n+     * @return the key\n+     * @throws ConcurrentModificationException if the entry was invalidated\n+     *         by modifying the Map or calling Iterator.remove()\n+     */\n+    public Object getKey()\n+    {\n+      if (knownMod != modCount || table[loc] == tombstone)\n+        throw new ConcurrentModificationException();\n+      return table[loc];\n+    }\n+\n+    /**\n+     * Returns the value of this entry.\n+     *\n+     * @return the value\n+     * @throws ConcurrentModificationException if the entry was invalidated\n+     *         by modifying the Map or calling Iterator.remove()\n+     */\n+    public Object getValue()\n+    {\n+      if (knownMod != modCount || table[loc] == tombstone)\n+        throw new ConcurrentModificationException();\n+      return table[loc + 1];\n+    }\n+\n+    /**\n+     * Returns the hashcode of the entry, using identity semantics.\n+     * Note that this can lead to undefined results with Entry objects\n+     * created by normal maps.\n+     *\n+     * @return the hash code\n+     * @throws ConcurrentModificationException if the entry was invalidated\n+     *         by modifying the Map or calling Iterator.remove()\n+     */\n+    public int hashCode()\n+    {\n+      if (knownMod != modCount || table[loc] == tombstone)\n+        throw new ConcurrentModificationException();\n+      return (System.identityHashCode(table[loc])\n+              ^ System.identityHashCode(table[loc + 1]));\n+    }\n+\n+    /**\n+     * Replaces the value of this mapping, and returns the old value.\n+     *\n+     * @param value the new value\n+     * @return the old value\n+     * @throws ConcurrentModificationException if the entry was invalidated\n+     *         by modifying the Map or calling Iterator.remove()\n+     */\n+    public Object setValue(Object value)\n+    {\n+      if (knownMod != modCount || table[loc] == tombstone)\n+        throw new ConcurrentModificationException();\n+      Object r = table[loc + 1];\n+      table[loc + 1] = value;\n+      return r;\n+    }\n+\n+    /**\n+     * This provides a string representation of the entry. It is of the form\n+     * \"key=value\", where string concatenation is used on key and value.\n+     *\n+     * @return the string representation\n+     * @throws ConcurrentModificationException if the entry was invalidated\n+     *         by modifying the Map or calling Iterator.remove()\n+     */\n+    public final String toString()\n+    {\n+      if (knownMod != modCount || table[loc] == tombstone)\n+        throw new ConcurrentModificationException();\n+      return table[loc] + \"=\" + table[loc + 1];\n+    }\n+  } // class IdentityEntry\n \n-  private void readObject (ObjectInputStream s)\n+  /**\n+   * Reads the object from a serial stream.\n+   *\n+   * @param s the stream to read from\n+   * @throws ClassNotFoundException if the underlying stream fails\n+   * @throws IOException if the underlying stream fails\n+   * @serialData expects the size (int), followed by that many key (Object)\n+   *             and value (Object) pairs, with the pairs in no particular\n+   *             order\n+   */\n+  private void readObject(ObjectInputStream s)\n     throws IOException, ClassNotFoundException\n   {\n-    int num = s.readInt ();\n-    for (int i = 0; i < num; ++i)\n-      {\n-\tObject key = s.readObject ();\n-\tObject value = s.readObject ();\n-\tput (key, value);\n-      }\n+    s.defaultReadObject();\n+\n+    int num = s.readInt();\n+    table = new Object[2 * Math.max(num * 2, DEFAULT_CAPACITY)];\n+    // Read key/value pairs.\n+    while (--num >= 0)\n+      put(s.readObject(), s.readObject());\n   }\n \n-  private void writeObject (ObjectOutputStream s)\n+  /**\n+   * Writes the object to a serial stream.\n+   *\n+   * @param s the stream to write to\n+   * @throws IOException if the underlying stream fails\n+   * @serialData outputs the size (int), followed by that many key (Object)\n+   *             and value (Object) pairs, with the pairs in no particular\n+   *             order\n+   */\n+  private void writeObject(ObjectOutputStream s)\n     throws IOException\n   {\n-    s.writeInt (size);\n-    Iterator it = entrySet ().iterator ();\n-    while (it.hasNext ())\n+    s.defaultWriteObject();\n+    s.writeInt(size);\n+    for (int i = table.length - 2; i >= 0; i -= 2)\n       {\n-\tMap.Entry entry = (Map.Entry) it.next ();\n-\ts.writeObject (entry.getKey ());\n-\ts.writeObject (entry.getValue ());\n+        Object key = table[i];\n+        if (key != tombstone && key != emptyslot)\n+          {\n+            s.writeObject(key);\n+            s.writeObject(table[i + 1]);\n+          }\n       }\n   }\n-\n-  // Compute the hash value we will use for an object.\n-  private int getHash (Object o)\n-  {\n-    return 2 * Math.abs (System.identityHashCode (o) % (table.length / 2));\n-  }\n-\n-  // Number of items in hash table.\n-  private int size;\n-  // The table itself.\n-  private Object[] table;\n-\n-  // This object is used to mark deleted items.\n-  private static final Object tombstone = new Object ();\n-  // This object is used to mark empty slots.  We need this because\n-  // using null is ambiguous.\n-  private static final Object emptyslot = new Object ();\n }"}, {"sha": "8503e375ace4d60af4d82f82855bd508874e0219", "filename": "libjava/java/util/LinkedHashMap.java", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2Fjava%2Futil%2FLinkedHashMap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2Fjava%2Futil%2FLinkedHashMap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FLinkedHashMap.java?ref=d9fd7154ec7908eff8bbbce75651eccf51064ac1", "patch": "@@ -28,11 +28,6 @@\n \n package java.util;\n \n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.io.ObjectInputStream;\n-import java.io.ObjectOutputStream;\n-\n /**\n  * This class provides a hashtable-backed implementation of the\n  * Map interface, with predictable traversal order.\n@@ -89,6 +84,7 @@\n  * @see TreeMap\n  * @see Hashtable\n  * @since 1.4\n+ * @status updated to 1.4\n  */\n public class LinkedHashMap extends HashMap\n {\n@@ -218,8 +214,8 @@ public LinkedHashMap(Map m)\n    * Construct a new insertion-ordered LinkedHashMap with a specific\n    * inital capacity and default load factor of 0.75.\n    *\n-   * @param initialCapacity the initial capacity of this HashMap (>=0)\n-   * @throws IllegalArgumentException if (initialCapacity < 0)\n+   * @param initialCapacity the initial capacity of this HashMap (&gt;= 0)\n+   * @throws IllegalArgumentException if (initialCapacity &lt; 0)\n    */\n   public LinkedHashMap(int initialCapacity)\n   {\n@@ -231,10 +227,10 @@ public LinkedHashMap(int initialCapacity)\n    * Construct a new insertion-orderd LinkedHashMap with a specific\n    * inital capacity and load factor.\n    *\n-   * @param initialCapacity the initial capacity (>=0)\n-   * @param loadFactor the load factor (>0, not NaN)\n-   * @throws IllegalArgumentException if (initialCapacity < 0) ||\n-   *                                     ! (loadFactor > 0.0)\n+   * @param initialCapacity the initial capacity (&gt;= 0)\n+   * @param loadFactor the load factor (&gt; 0, not NaN)\n+   * @throws IllegalArgumentException if (initialCapacity &lt; 0) ||\n+   *                                     ! (loadFactor &gt; 0.0)\n    */\n   public LinkedHashMap(int initialCapacity, float loadFactor)\n   {\n@@ -281,7 +277,7 @@ public boolean containsValue(Object value)\n     LinkedHashEntry e = head;\n     while (e != null)\n       {\n-        if (value == null ? e.value == null : value.equals(e.value))\n+        if (equals(value, e.value))\n           return true;\n         e = e.succ;\n       }\n@@ -307,7 +303,7 @@ public Object get(Object key)\n     HashEntry e = buckets[idx];\n     while (e != null)\n       {\n-        if (key == null ? e.key == null : key.equals(e.key))\n+        if (equals(key, e.key))\n           {\n             if (accessOrder)\n               {\n@@ -376,13 +372,14 @@ protected boolean removeEldestEntry(Map.Entry eldest)\n     return false;\n   }\n \n-  /** Helper method called by <code>put</code>, which creates and adds a\n+  /**\n+   * Helper method called by <code>put</code>, which creates and adds a\n    * new Entry, followed by performing bookkeeping (like removeEldestEntry).\n    *\n    * @param key the key of the new Entry\n    * @param value the value\n    * @param idx the index in buckets where the new Entry belongs\n-   * @param callRemove Whether to call the removeEldestEntry method.\n+   * @param callRemove whether to call the removeEldestEntry method\n    * @see #put(Object, Object)\n    * @see #removeEldestEntry(Map.Entry)\n    */\n@@ -397,6 +394,11 @@ void addEntry(Object key, Object value, int idx, boolean callRemove)\n       remove(head);\n   }\n \n+  /**\n+   * Helper method, called by clone() to reset the doubly-linked list.\n+   * @param m the map to add entries from\n+   * @see #clone()\n+   */\n   void putAllInternal(Map m)\n   {\n     head = null;\n@@ -466,8 +468,8 @@ public void remove()\n           throw new IllegalStateException();\n \n         LinkedHashMap.this.remove(last.key);\n-        knownMod++;\n         last = null;\n+        knownMod++;\n       }\n     };\n   }"}, {"sha": "f98c32e4b70f7884ef306639ac794d4a7ccc85e1", "filename": "libjava/java/util/LinkedHashSet.java", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2Fjava%2Futil%2FLinkedHashSet.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2Fjava%2Futil%2FLinkedHashSet.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FLinkedHashSet.java?ref=d9fd7154ec7908eff8bbbce75651eccf51064ac1", "patch": "@@ -0,0 +1,149 @@\n+/* LinkedHashSet.java -- a set backed by a LinkedHashMap, for linked\n+   list traversal.\n+   Copyright (C) 2001 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.util;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * This class provides a hashtable-backed implementation of the\n+ * Set interface, with predictable traversal order.\n+ * <p>\n+ *\n+ * It uses a hash-bucket approach; that is, hash collisions are handled\n+ * by linking the new node off of the pre-existing node (or list of\n+ * nodes).  In this manner, techniques such as linear probing (which\n+ * can cause primary clustering) and rehashing (which does not fit very\n+ * well with Java's method of precomputing hash codes) are avoided.  In\n+ * addition, this maintains a doubly-linked list which tracks insertion\n+ * order.  Note that the insertion order is not modified if an\n+ * <code>add</code> simply reinserts an element in the set.\n+ * <p>\n+ *\n+ * One of the nice features of tracking insertion order is that you can\n+ * copy a set, and regardless of the implementation of the original,\n+ * produce the same results when iterating over the copy.  This is possible\n+ * without needing the overhead of <code>TreeSet</code>.\n+ * <p>\n+ *\n+ * Under ideal circumstances (no collisions), LinkedHashSet offers O(1) \n+ * performance on most operations.  In the worst case (all elements map\n+ * to the same hash code -- very unlikely), most operations are O(n).\n+ * <p>\n+ *\n+ * LinkedHashSet accepts the null entry.  It is not synchronized, so if\n+ * you need multi-threaded access, consider using:<br>\n+ * <code>Set s = Collections.synchronizedSet(new LinkedHashSet(...));</code>\n+ * <p>\n+ *\n+ * The iterators are <i>fail-fast</i>, meaning that any structural\n+ * modification, except for <code>remove()</code> called on the iterator\n+ * itself, cause the iterator to throw a\n+ * {@link ConcurrentModificationException} rather than exhibit\n+ * non-deterministic behavior.\n+ *\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @see Object#hashCode()\n+ * @see Collection\n+ * @see Set\n+ * @see HashSet\n+ * @see TreeSet\n+ * @see Collections#synchronizedSet(Set)\n+ * @since 1.4\n+ * @status updated to 1.4\n+ */\n+public class LinkedHashSet extends HashSet\n+  implements Set, Cloneable, Serializable\n+{\n+  /**\n+   * Compatible with JDK 1.4.\n+   */\n+  private static final long serialVersionUID = -2851667679971038690L;\n+\n+  /**\n+   * Construct a new, empty HashSet whose backing HashMap has the default\n+   * capacity (11) and loadFacor (0.75).\n+   */\n+  public LinkedHashSet()\n+  {\n+    super();\n+  }\n+\n+  /**\n+   * Construct a new, empty HashSet whose backing HashMap has the supplied\n+   * capacity and the default load factor (0.75).\n+   *\n+   * @param initialCapacity the initial capacity of the backing HashMap\n+   * @throws IllegalArgumentException if the capacity is negative\n+   */\n+  public LinkedHashSet(int initialCapacity)\n+  {\n+    super(initialCapacity);\n+  }\n+\n+  /**\n+   * Construct a new, empty HashSet whose backing HashMap has the supplied\n+   * capacity and load factor.\n+   *\n+   * @param initialCapacity the initial capacity of the backing HashMap\n+   * @param loadFactor the load factor of the backing HashMap\n+   * @throws IllegalArgumentException if either argument is negative, or\n+   *         if loadFactor is POSITIVE_INFINITY or NaN\n+   */\n+  public LinkedHashSet(int initialCapacity, float loadFactor)\n+  {\n+    super(initialCapacity, loadFactor);\n+  }\n+\n+  /**\n+   * Construct a new HashSet with the same elements as are in the supplied\n+   * collection (eliminating any duplicates, of course). The backing storage\n+   * has twice the size of the collection, or the default size of 11,\n+   * whichever is greater; and the default load factor (0.75).\n+   *\n+   * @param c a collection of initial set elements\n+   * @throws NullPointerException if c is null\n+   */\n+  public LinkedHashSet(Collection c)\n+  {\n+    super(c);\n+  }\n+\n+  /**\n+   * Helper method which initializes the backing Map.\n+   *\n+   * @param capacity the initial capacity\n+   * @param load the initial load factor\n+   * @return the backing HashMap\n+   */\n+  HashMap init(int capacity, float load)\n+  {\n+    return new LinkedHashMap(capacity, load);\n+  }\n+\n+}"}, {"sha": "f2f333c4ccffc5e935197ab3c7f6db1fa78a40ca", "filename": "libjava/java/util/LinkedList.java", "status": "modified", "additions": 482, "deletions": 208, "changes": 690, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2Fjava%2Futil%2FLinkedList.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2Fjava%2Futil%2FLinkedList.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FLinkedList.java?ref=d9fd7154ec7908eff8bbbce75651eccf51064ac1", "patch": "@@ -1,5 +1,5 @@\n /* LinkedList.java -- Linked list implementation of the List interface\n-   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -32,25 +32,50 @@\n import java.io.IOException;\n import java.lang.reflect.Array;\n \n-// TO DO:\n-// ~ Doc comment for the class.\n-// ~ Doc comments for the non-list methods.\n-// ~ other general implementation notes.\n-\n /**\n- * Linked list implementation of the List interface.\n+ * Linked list implementation of the List interface. In addition to the\n+ * methods of the List interface, this class provides access to the first\n+ * and last list elements in O(1) time for easy stack, queue, or double-ended\n+ * queue (deque) creation. The list is doubly-linked, with traversal to a\n+ * given index starting from the end closest to the element.<p>\n+ *\n+ * LinkedList is not synchronized, so if you need multi-threaded access,\n+ * consider using:<br>\n+ * <code>List l = Collections.synchronizedList(new LinkedList(...));</code>\n+ * <p>\n+ *\n+ * The iterators are <i>fail-fast</i>, meaning that any structural\n+ * modification, except for <code>remove()</code> called on the iterator\n+ * itself, cause the iterator to throw a\n+ * {@link ConcurrentModificationException} rather than exhibit\n+ * non-deterministic behavior.\n+ *\n+ * @author Original author unknown\n+ * @author Bryce McKinlay\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @see List\n+ * @see ArrayList\n+ * @see Vector\n+ * @see Collections#synchronizedList(List)\n+ * @since 1.2\n+ * @status missing javadoc, but complete to 1.4\n  */\n public class LinkedList extends AbstractSequentialList\n   implements List, Cloneable, Serializable\n {\n-  static final long serialVersionUID = 876323262645176354L;\n+  /**\n+   * Compatible with JDK 1.2.\n+   */\n+  private static final long serialVersionUID = 876323262645176354L;\n \n   /**\n-   * An Entry containing the head (in the next field) and the tail (in the\n-   * previous field) of the list. The data field is null. If the list is empty,\n-   * both the head and the tail point to ends itself.\n+   * The first element in the list.\n    */\n   transient Entry first;\n+\n+  /**\n+   * The last element in the list.\n+   */\n   transient Entry last;\n \n   /**\n@@ -61,18 +86,27 @@ public class LinkedList extends AbstractSequentialList\n   /**\n    * Class to represent an entry in the list. Holds a single element.\n    */\n-  private static class Entry\n+  private static final class Entry\n   {\n+    /** The element in the list. */\n     Object data;\n+\n+    /** The next list entry, null if this is last. */\n     Entry next;\n+\n+    /** The previous list entry, null if this is first. */\n     Entry previous;\n-    \n+\n+    /**\n+     * Construct an entry.\n+     * @param data the list element\n+     */\n     Entry(Object data)\n     {\n       this.data = data;\n     }\n-  }\n-  \n+  } // class Entry\n+\n   /**\n    * Obtain the Entry at a given position in a list. This method of course\n    * takes linear time, but it is intelligent enough to take the shorter of the\n@@ -82,364 +116,500 @@ public class LinkedList extends AbstractSequentialList\n    * For speed and flexibility, range checking is not done in this method:\n    * Incorrect values will be returned if (n < 0) or (n >= size).\n    *\n-   * @param n the number of the entry to get.\n+   * @param n the number of the entry to get\n+   * @return the entry at position n\n    */\n   private Entry getEntry(int n)\n   {\n     Entry e;\n     if (n < size / 2)\n       {\n         e = first;\n-\t// n less than size/2, iterate from start\n-\twhile (n-- > 0)\n-\t  {\n-\t    e = e.next;\n-\t  }\n+        // n less than size/2, iterate from start\n+        while (n-- > 0)\n+          e = e.next;\n       }\n     else\n       {\n-        e = last;      \n-\t// n greater than size/2, iterate from end\n-\twhile (++n < size)\n-\t  {\n-\t    e = e.previous;\n-\t  }\n+        e = last;\n+        // n greater than size/2, iterate from end\n+        while (++n < size)\n+          e = e.previous;\n       }\n     return e;\n   }\n-  \n-  /** Remove an entry from the list. This will adjust size and deal with\n-   *  `first' and  `last' appropriatly. It does not effect modCount, that is \n-   *  the responsibility of the caller. */\n+\n+  /**\n+   * Remove an entry from the list. This will adjust size and deal with\n+   *  `first' and  `last' appropriatly.\n+   *\n+   * @param e the entry to remove\n+   */\n   private void removeEntry(Entry e)\n   {\n-    if (size == 1)\n+    modCount++;\n+    size--;\n+    if (size == 0)\n       first = last = null;\n     else\n       {\n-\tif (e == first)\n-\t  {\n-\t    first = e.next;\n-\t    e.next.previous = null;\n-\t  }\n-\telse if (e == last)\n-\t  {\n-\t    last = e.previous;\n-\t    e.previous.next = null;\n-\t  }\n-\telse\n-\t  {\n-\t    e.next.previous = e.previous;\t\n-\t    e.previous.next = e.next;\n-\t  }\n+        if (e == first)\n+          {\n+            first = e.next;\n+            e.next.previous = null;\n+          }\n+        else if (e == last)\n+          {\n+            last = e.previous;\n+            e.previous.next = null;\n+          }\n+        else\n+          {\n+            e.next.previous = e.previous;\n+            e.previous.next = e.next;\n+          }\n       }\n-    size--;\n+  }\n+\n+  /**\n+   * Checks that the index is in the range of possible elements (inclusive).\n+   *\n+   * @param index the index to check\n+   * @throws IndexOutOfBoundsException if index &lt; 0 || index &gt; size\n+   */\n+  private void checkBoundsInclusive(int index)\n+  {\n+    if (index < 0 || index > size)\n+      throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size:\"\n+                                          + size);\n+  }\n+\n+  /**\n+   * Checks that the index is in the range of existing elements (exclusive).\n+   *\n+   * @param index the index to check\n+   * @throws IndexOutOfBoundsException if index &lt; 0 || index &gt;= size\n+   */\n+  private void checkBoundsExclusive(int index)\n+  {\n+    if (index < 0 || index >= size)\n+      throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size:\"\n+                                          + size);\n   }\n \n   /**\n    * Create an empty linked list.\n    */\n   public LinkedList()\n   {\n-    super();\n   }\n \n   /**\n    * Create a linked list containing the elements, in order, of a given\n    * collection.\n    *\n-   * @param c the collection to populate this list from.\n+   * @param c the collection to populate this list from\n+   * @throws NullPointerException if c is null\n    */\n   public LinkedList(Collection c)\n   {\n-    super();\n-    // Note: addAll could be made slightly faster, but not enough so to justify\n-    // re-implementing it from scratch. It is just a matter of a relatively\n-    // small constant factor.\n     addAll(c);\n   }\n \n+  /**\n+   * Returns the first element in the list.\n+   *\n+   * @return the first list element\n+   * @throws NoSuchElementException if the list is empty\n+   */\n   public Object getFirst()\n   {\n     if (size == 0)\n       throw new NoSuchElementException();\n     return first.data;\n   }\n \n+  /**\n+   * Returns the last element in the list.\n+   *\n+   * @return the last list element\n+   * @throws NoSuchElementException if the list is empty\n+   */\n   public Object getLast()\n   {\n     if (size == 0)\n       throw new NoSuchElementException();\n     return last.data;\n   }\n \n+  /**\n+   * Remove and return the first element in the list.\n+   *\n+   * @return the former first element in the list\n+   * @throws NoSuchElementException if the list is empty\n+   */\n   public Object removeFirst()\n   {\n     if (size == 0)\n       throw new NoSuchElementException();\n-    size--;\n     modCount++;\n+    size--;\n     Object r = first.data;\n-    \n+\n     if (first.next != null)\n       first.next.previous = null;\n     else\n       last = null;\n \n     first = first.next;\n-    \n+\n     return r;\n   }\n \n+  /**\n+   * Remove and return the last element in the list.\n+   *\n+   * @return the former last element in the list\n+   * @throws NoSuchElementException if the list is empty\n+   */\n   public Object removeLast()\n   {\n     if (size == 0)\n       throw new NoSuchElementException();\n-    size--;\n     modCount++;\n+    size--;\n     Object r = last.data;\n-    \n+\n     if (last.previous != null)\n       last.previous.next = null;\n     else\n       first = null;\n-    \n+\n     last = last.previous;\n-    \n+\n     return r;\n   }\n \n+  /**\n+   * Insert an element at the first of the list.\n+   *\n+   * @param o the element to insert\n+   */\n   public void addFirst(Object o)\n   {\n-    modCount++;\n     Entry e = new Entry(o);\n-    \n+\n+    modCount++;\n     if (size == 0)\n       first = last = e;\n     else\n       {\n-\te.next = first;\n+        e.next = first;\n         first.previous = e;\n-\tfirst = e;\n-      }    \n+        first = e;\n+      }\n     size++;\n   }\n \n+  /**\n+   * Insert an element at the last of the list.\n+   *\n+   * @param o the element to insert\n+   */\n   public void addLast(Object o)\n   {\n-    modCount++;\n     addLastEntry(new Entry(o));\n   }\n-  \n+\n+  /**\n+   * Inserts an element at the end of the list.\n+   *\n+   * @param e the entry to add\n+   */\n   private void addLastEntry(Entry e)\n   {\n+    modCount++;\n     if (size == 0)\n       first = last = e;\n     else\n       {\n-\te.previous = last;\n+        e.previous = last;\n         last.next = e;\n-\tlast = e;\n+        last = e;\n       }\n     size++;\n   }\n \n+  /**\n+   * Returns true if the list contains the given object. Comparison is done by\n+   * <code>o == null ? e = null : o.equals(e)</code>.\n+   *\n+   * @param o the element to look for\n+   * @return true if it is found\n+   */\n   public boolean contains(Object o)\n   {\n     Entry e = first;\n     while (e != null)\n       {\n-        if (e.data == null ? o == null : o.equals(e.data))\n-\t  return true;\n+        if (equals(o, e.data))\n+          return true;\n         e = e.next;\n       }\n     return false;\n   }\n \n+  /**\n+   * Returns the size of the list.\n+   *\n+   * @return the list size\n+   */\n   public int size()\n   {\n     return size;\n   }\n-  \n+\n+  /**\n+   * Adds an element to the end of the list.\n+   *\n+   * @param e the entry to add\n+   * @return true, as it always succeeds\n+   */\n   public boolean add(Object o)\n   {\n-    modCount++;\n     addLastEntry(new Entry(o));\n     return true;\n   }\n-  \n+\n+  /**\n+   * Removes the entry at the lowest index in the list that matches the given\n+   * object, comparing by <code>o == null ? e = null : o.equals(e)</code>.\n+   *\n+   * @param o the object to remove\n+   * @return true if an instance of the object was removed\n+   */\n   public boolean remove(Object o)\n   {\n-    modCount++;\n     Entry e = first;\n     while (e != null)\n       {\n-        if (e.data == null ? o == null : o.equals(e.data))\n-\t  {\n-\t    removeEntry(e);\n-\t    return true;\n-\t  }\n+        if (equals(o, e.data))\n+          {\n+            removeEntry(e);\n+            return true;\n+          }\n         e = e.next;\n       }\n     return false;\n   }\n \n+  /**\n+   * Append the elements of the collection in iteration order to the end of\n+   * this list. If this list is modified externally (for example, if this\n+   * list is the collection), behavior is unspecified.\n+   *\n+   * @param c the collection to append\n+   * @return true if the list was modified\n+   * @throws NullPointerException if c is null\n+   */\n   public boolean addAll(Collection c)\n   {\n     return addAll(size, c);\n   }\n-  \n+\n+  /**\n+   * Insert the elements of the collection in iteration order at the given\n+   * index of this list. If this list is modified externally (for example,\n+   * if this list is the collection), behavior is unspecified.\n+   *\n+   * @param c the collection to append\n+   * @return true if the list was modified\n+   * @throws NullPointerException if c is null\n+   * @throws IndexOutOfBoundsException if index &lt; 0 || index &gt; size()\n+   */\n   public boolean addAll(int index, Collection c)\n   {\n-    if (index < 0 || index > size)\n-      throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size:\" + \n-                                          size);\n-    modCount++;\n+    checkBoundsInclusive(index);\n     int csize = c.size();\n \n     if (csize == 0)\n       return false;\n \n     Iterator itr = c.iterator();\n-    \n+\n     // Get the entries just before and after index. If index is at the start\n-    // of the list, BEFORE is null. If index is at the end of thelist, AFTER is\n-    // null. If the list is empty, both are null.\n+    // of the list, BEFORE is null. If index is at the end of the list, AFTER\n+    // is null. If the list is empty, both are null.\n     Entry after = null;\n-    Entry before = null;    \n+    Entry before = null;\n     if (index != size)\n       {\n-\tafter = getEntry(index);\n-\tbefore = after.previous;\n+        after = getEntry(index);\n+        before = after.previous;\n       }\n     else\n       before = last;\n-      \n+\n     // Create the first new entry. We do not yet set the link from `before'\n-    // to the first entry, in order to deal with the case where (c == this). \n-    // [Actually, we don't have to handle this case to fufill the \n+    // to the first entry, in order to deal with the case where (c == this).\n+    // [Actually, we don't have to handle this case to fufill the\n     // contract for addAll(), but Sun's implementation appears to.]\n     Entry e = new Entry(itr.next());\n     e.previous = before;\n     Entry prev = e;\n     Entry firstNew = e;\n-    \n+\n     // Create and link all the remaining entries.\n     for (int pos = 1; pos < csize; pos++)\n       {\n         e = new Entry(itr.next());\n-\te.previous = prev;\t\n-\tprev.next = e;\n-\tprev = e;\n+        e.previous = prev;\n+        prev.next = e;\n+        prev = e;\n       }\n+\n     // Link the new chain of entries into the list.\n+    modCount++;\n+    size += csize;\n     prev.next = after;\n     if (after != null)\n       after.previous = e;\n     else\n       last = e;\n-    \n+\n     if (before != null)\n       before.next = firstNew;\n     else\n       first = firstNew;\n-    \n-    size += csize;\n     return true;\n   }\n \n+  /**\n+   * Remove all elements from this list.\n+   */\n   public void clear()\n   {\n-    modCount++;\n-    first = null;\n-    last = null;\n-    size = 0;\n+    if (size > 0)\n+      {\n+        modCount++;\n+        first = null;\n+        last = null;\n+        size = 0;\n+      }\n   }\n \n+  /**\n+   * Return the element at index.\n+   *\n+   * @param index the place to look\n+   * @return the element at index\n+   * @throws IndexOutOfBoundsException if index &lt; 0 || index &gt;= size()\n+   */\n   public Object get(int index)\n   {\n-    if (index < 0 || index >= size)\n-      throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size:\" + \n-                                          size);\n-    Entry e = getEntry(index);\n-    return e.data;\n+    checkBoundsExclusive(index);\n+    return getEntry(index).data;\n   }\n-  \n+\n+  /**\n+   * Replace the element at the given location in the list.\n+   *\n+   * @param index which index to change\n+   * @param o the new element\n+   * @return the prior element\n+   * @throws IndexOutOfBoundsException if index &lt; 0 || index &gt;= size()\n+   */\n   public Object set(int index, Object o)\n   {\n-    if (index < 0 || index >= size)\n-      throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size:\" + \n-                                          size);\n+    checkBoundsExclusive(index);\n     Entry e = getEntry(index);\n     Object old = e.data;\n     e.data = o;\n     return old;\n   }\n \n+  /**\n+   * Inserts an element in the given position in the list.\n+   *\n+   * @param index where to insert the element\n+   * @param o the element to insert\n+   * @throws IndexOutOfBoundsException if index &lt; 0 || index &gt; size()\n+   */\n   public void add(int index, Object o)\n   {\n-    if (index < 0 || index > size)\n-      throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size:\" + \n-                                          size);\n-    modCount++;\n-    addEntry(index, new Entry(o));    \n-  }\n-  \n-  private void addEntry(int index, Entry e)\n-  {\n+    checkBoundsInclusive(index);\n+    Entry e = new Entry(o);\n+\n     if (index < size)\n       {\n-\tEntry after = getEntry(index);\n-\te.next = after;\n-\te.previous = after.previous;\n-\tif (after.previous == null)\n-\t  first = e;\n-\telse\n-\t  after.previous.next = e;\n-\tafter.previous = e;\n-\tsize++;        \n+        modCount++;\n+        Entry after = getEntry(index);\n+        e.next = after;\n+        e.previous = after.previous;\n+        if (after.previous == null)\n+          first = e;\n+        else\n+          after.previous.next = e;\n+        after.previous = e;\n+        size++;\n       }\n     else\n       addLastEntry(e);\n   }\n-  \n+\n+  /**\n+   * Removes the element at the given position from the list.\n+   *\n+   * @param index the location of the element to remove\n+   * @return the removed element\n+   * @throws IndexOutOfBoundsException if index &lt; 0 || index &gt; size()\n+   */\n   public Object remove(int index)\n   {\n-    if (index < 0 || index >= size)\n-      throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size:\" + \n-                                          size);\n-    modCount++;\n+    checkBoundsExclusive(index);\n     Entry e = getEntry(index);\n     removeEntry(e);\n     return e.data;\n   }\n-  \n+\n+  /**\n+   * Returns the first index where the element is located in the list, or -1.\n+   *\n+   * @param o the element to look for\n+   * @return its position, or -1 if not found\n+   */\n   public int indexOf(Object o)\n   {\n     int index = 0;\n     Entry e = first;\n     while (e != null)\n       {\n-        if (e.data == null ? o == null : o.equals(e.data))\n-\t  return index;\n-\t++index;\n+        if (equals(o, e.data))\n+          return index;\n+        index++;\n         e = e.next;\n       }\n     return -1;\n   }\n-  \n+\n+  /**\n+   * Returns the last index where the element is located in the list, or -1.\n+   *\n+   * @param o the element to look for\n+   * @return its position, or -1 if not found\n+   */\n   public int lastIndexOf(Object o)\n   {\n     int index = size - 1;\n     Entry e = last;\n     while (e != null)\n       {\n-        if (e.data == null ? o == null : o.equals(e.data))\n-\t  return index;\n-\t--index;\n+        if (equals(o, e.data))\n+          return index;\n+        index--;\n         e = e.previous;\n       }\n-    return -1;  \n+    return -1;\n   }\n \n   /**\n@@ -448,28 +618,27 @@ public int lastIndexOf(Object o)\n    * methods.\n    *\n    * @param index the index of the element to be returned by the first call to\n-   *   next(), or size() to be initially positioned at the end of the list.\n-   * @exception IndexOutOfBoundsException if index < 0 || index > size().\n+   *        next(), or size() to be initially positioned at the end of the list\n+   * @throws IndexOutOfBoundsException if index &lt; 0 || index &gt; size()\n    */\n   public ListIterator listIterator(int index)\n   {\n-    if (index < 0 || index > size)\n-      throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size:\" + \n-                                          size);\n+    checkBoundsInclusive(index);\n     return new LinkedListItr(index);\n   }\n \n   /**\n-   * Create a shallow copy of this LinkedList.\n+   * Create a shallow copy of this LinkedList (the elements are not cloned).\n+   *\n    * @return an object of the same class as this object, containing the\n-   * same elements in the same order.\n+   *         same elements in the same order\n    */\n   public Object clone()\n   {\n     LinkedList copy = null;\n     try\n       {\n-\tcopy = (LinkedList) super.clone();\n+        copy = (LinkedList) super.clone();\n       }\n     catch (CloneNotSupportedException ex)\n       {\n@@ -478,7 +647,12 @@ public Object clone()\n     copy.addAll(this);\n     return copy;\n   }\n-  \n+\n+  /**\n+   * Returns an array which contains the elements of the list in order.\n+   *\n+   * @return an array containing the list elements\n+   */\n   public Object[] toArray()\n   {\n     Object[] array = new Object[size];\n@@ -490,182 +664,282 @@ public Object[] toArray()\n       }\n     return array;\n   }\n-  \n-  public Object[] toArray(Object[] array)\n+\n+  /**\n+   * Returns an Array whose component type is the runtime component type of\n+   * the passed-in Array.  The returned Array is populated with all of the\n+   * elements in this LinkedList.  If the passed-in Array is not large enough\n+   * to store all of the elements in this List, a new Array will be created \n+   * and returned; if the passed-in Array is <i>larger</i> than the size\n+   * of this List, then size() index will be set to null.\n+   *\n+   * @param a the passed-in Array\n+   * @return an array representation of this list\n+   * @throws ArrayStoreException if the runtime type of a does not allow\n+   *         an element in this list\n+   * @throws NullPointerException if a is null\n+   */\n+  public Object[] toArray(Object[] a)\n   {\n-    if (array.length < size)\n-      array = (Object[]) Array.newInstance(array.getClass().getComponentType(), \n-        \t\t\t\t   size);\n-    else if (array.length > size)\n-      array[size] = null;\n+    if (a.length < size)\n+      a = (Object[]) Array.newInstance(a.getClass().getComponentType(), size);\n+    else if (a.length > size)\n+      a[size] = null;\n     Entry e = first;\n     for (int i = 0; i < size; i++)\n       {\n-        array[i] = e.data;\n+        a[i] = e.data;\n         e = e.next;\n       }\n-    return array;  \n+    return a;\n   }\n \n   /**\n-   * Serialize an object to a stream.\n-   * @serialdata the size of the list (int), followed by all the elements\n-   * (Object) in proper order.\n+   * Serializes this object to the given stream.\n+   *\n+   * @param s the stream to write to\n+   * @throws IOException if the underlying stream fails\n+   * @serialData the size of the list (int), followed by all the elements\n+   *             (Object) in proper order\n    */\n   private void writeObject(ObjectOutputStream s) throws IOException\n   {\n+    s.defaultWriteObject();\n     s.writeInt(size);\n-    Iterator itr = iterator();\n-    for (int i = 0; i < size; i++)\n-      s.writeObject(itr.next());\n+    Entry e = first;\n+    while (e != null)\n+      {\n+        s.writeObject(e.data);\n+        e = e.next;\n+      }\n   }\n \n   /**\n-   * Deserialize an object from a stream.\n-   * @serialdata the size of the list (int), followed by all the elements\n-   * (Object) in proper order.\n+   * Deserializes this object from the given stream.\n+   *\n+   * @param s the stream to read from\n+   * @throws ClassNotFoundException if the underlying stream fails\n+   * @throws IOException if the underlying stream fails\n+   * @serialData the size of the list (int), followed by all the elements\n+   *             (Object) in proper order\n    */\n   private void readObject(ObjectInputStream s)\n     throws IOException, ClassNotFoundException\n   {\n-    int serialSize = s.readInt();\n-    for (int i = 0; i < serialSize; i++)\n+    s.defaultReadObject();\n+    int i = s.readInt();\n+    while (--i >= 0)\n       addLastEntry(new Entry(s.readObject()));\n   }\n-  \n-  /** A ListIterator over the list. This class keeps track of its\n+\n+  /**\n+   * A ListIterator over the list. This class keeps track of its\n    * position in the list and the two list entries it is between.\n+   *\n+   * @author Original author unknown\n+   * @author Eric Blake <ebb9@email.byu.edu>\n    */\n-  class LinkedListItr implements ListIterator\n+  private final class LinkedListItr implements ListIterator\n   {\n-    int knownMod;\n-    Entry next;         // entry that will be returned by next().\n-    Entry previous;     // entry that will be returned by previous().\n-    Entry lastReturned; // entry that will be affected by remove() or set().\n-    int position;       // index of `next'.\n+    /** Number of modifications we know about. */\n+    private int knownMod = modCount;\n+\n+    /** Entry that will be returned by next(). */\n+    private Entry next;\n+\n+    /** Entry that will be returned by previous(). */\n+    private Entry previous;\n \n+    /** Entry that will be affected by remove() or set(). */\n+    private Entry lastReturned;\n+\n+    /** Index of `next'. */\n+    private int position;\n+\n+    /**\n+     * Initialize the iterator.\n+     *\n+     * @param index the initial index\n+     */\n     LinkedListItr(int index)\n     {\n       if (index == size)\n         {\n           next = null;\n-\t  previous = last;\n-\t}\n+          previous = last;\n+        }\n       else\n         {\n           next = getEntry(index);\n-\t  previous = next.previous;\n-\t}\n+          previous = next.previous;\n+        }\n       position = index;\n-      knownMod = modCount;\n     }\n \n+    /**\n+     * Checks for iterator consistency.\n+     *\n+     * @throws ConcurrentModificationException if the list was modified\n+     */\n     private void checkMod()\n     {\n       if (knownMod != modCount)\n-\tthrow new ConcurrentModificationException();\n+        throw new ConcurrentModificationException();\n     }\n \n+    /**\n+     * Returns the index of the next element.\n+     *\n+     * @return the next index\n+     * @throws ConcurrentModificationException if the list was modified\n+     */\n     public int nextIndex()\n     {\n       checkMod();\n       return position;\n     }\n \n+    /**\n+     * Returns the index of the previous element.\n+     *\n+     * @return the previous index\n+     * @throws ConcurrentModificationException if the list was modified\n+     */\n     public int previousIndex()\n     {\n       checkMod();\n       return position - 1;\n     }\n \n+    /**\n+     * Returns true if more elements exist via next.\n+     *\n+     * @return true if next will succeed\n+     * @throws ConcurrentModificationException if the list was modified\n+     */\n     public boolean hasNext()\n     {\n       checkMod();\n       return (next != null);\n     }\n \n+    /**\n+     * Returns true if more elements exist via previous.\n+     *\n+     * @return true if previous will succeed\n+     * @throws ConcurrentModificationException if the list was modified\n+     */\n     public boolean hasPrevious()\n     {\n       checkMod();\n       return (previous != null);\n     }\n \n+    /**\n+     * Returns the next element.\n+     *\n+     * @return the next element\n+     * @throws ConcurrentModificationException if the list was modified\n+     * @throws NoSuchElementException if there is no next\n+     */\n     public Object next()\n     {\n       checkMod();\n       if (next == null)\n-\tthrow new NoSuchElementException();\n+        throw new NoSuchElementException();\n       position++;\n       lastReturned = previous = next;\n       next = lastReturned.next;\n       return lastReturned.data;\n     }\n \n+    /**\n+     * Returns the previous element.\n+     *\n+     * @return the previous element\n+     * @throws ConcurrentModificationException if the list was modified\n+     * @throws NoSuchElementException if there is no previous\n+     */\n     public Object previous()\n     {\n       checkMod();\n       if (previous == null)\n-\tthrow new NoSuchElementException();\n+        throw new NoSuchElementException();\n       position--;\n       lastReturned = next = previous;\n       previous = lastReturned.previous;\n       return lastReturned.data;\n     }\n \n+    /**\n+     * Remove the most recently returned element from the list.\n+     *\n+     * @throws ConcurrentModificationException if the list was modified\n+     * @throws IllegalStateException if there was no last element\n+     */\n     public void remove()\n     {\n       checkMod();\n       if (lastReturned == null)\n-\tthrow new IllegalStateException();\n+        throw new IllegalStateException();\n \n       // Adjust the position to before the removed element, if the element\n       // being removed is behind the cursor.\n       if (lastReturned == previous)\n-\tposition--;\n+        position--;\n \n       next = lastReturned.next;\n       previous = lastReturned.previous;\n-      modCount++;\n-      knownMod++;\n       removeEntry(lastReturned);\n-      \n+      knownMod++;\n+\n       lastReturned = null;\n     }\n \n+    /**\n+     * Adds an element between the previous and next, and advance to the next.\n+     *\n+     * @param o the element to add\n+     * @throws ConcurrentModificationException if the list was modified\n+     */\n     public void add(Object o)\n     {\n       checkMod();\n       modCount++;\n       knownMod++;\n+      size++;\n+      position++;\n       Entry e = new Entry(o);\n       e.previous = previous;\n       e.next = next;\n \n       if (previous != null)\n-\tprevious.next = e;\n+        previous.next = e;\n       else\n-\tfirst = e;\n+        first = e;\n \n       if (next != null)\n-        {\n-\t  next.previous = e;\n-\t  next = next.next;\n-\t}\n+        next.previous = e;\n       else\n-\tlast = e;\n+        last = e;\n \n       previous = e;\n-      size++;\n-      position++;\n       lastReturned = null;\n     }\n \n+    /**\n+     * Changes the contents of the element most recently returned.\n+     *\n+     * @param o the new element\n+     * @throws ConcurrentModificationException if the list was modified\n+     * @throws IllegalStateException if there was no last element\n+     */\n     public void set(Object o)\n     {\n       checkMod();\n       if (lastReturned == null)\n-\tthrow new IllegalStateException();\n+        throw new IllegalStateException();\n       lastReturned.data = o;\n     }\n-  }  // class LinkedListItr  \n+  } // class LinkedListItr\n }"}, {"sha": "a000604de4974ba4126a7a2446bd9c91de1e6fca", "filename": "libjava/java/util/List.java", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2Fjava%2Futil%2FList.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2Fjava%2Futil%2FList.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FList.java?ref=d9fd7154ec7908eff8bbbce75651eccf51064ac1", "patch": "@@ -190,7 +190,7 @@ public interface List extends Collection\n    * @see Object#equals(Object)\n    * @see #hashCode()\n    */\n-  boolean equals(Object o);\n+ /* boolean equals(Object o);*/\n \n   /**\n    * Get the element at a given index in this list.\n@@ -288,7 +288,7 @@ public interface List extends Collection\n   Object remove(int index);\n \n   /**\n-   * Remove the first occurrence of an object from this list (optional\n+   * Remove the first occurence of an object from this list (optional\n    * operation). That is, remove the first element e such that\n    * <code>o == null ? e == null : o.equals(e)</code>.\n    *"}, {"sha": "a7b3f5d4e705ebba630f2c6e1a908c7449547606", "filename": "libjava/java/util/Stack.java", "status": "modified", "additions": 33, "deletions": 25, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2Fjava%2Futil%2FStack.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2Fjava%2Futil%2FStack.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FStack.java?ref=d9fd7154ec7908eff8bbbce75651eccf51064ac1", "patch": "@@ -32,41 +32,46 @@\n  * \"The Java Language Specification\", ISBN 0-201-63451-1\n  * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n  * Status:  Believed complete and correct\n- */\n \n /**\n  * Stack provides a Last In First Out (LIFO) data type, commonly known\n- * as a Stack.  \n- *\n- * Stack itself extends Vector and provides the additional methods\n- * for stack manipulation (push, pop, peek). \n+ * as a Stack.  Stack itself extends Vector and provides the additional\n+ * methods for stack manipulation (push, pop, peek). You can also seek for\n+ * the 1-based position of an element on the stack.\n  *\n  * @author Warren Levy <warrenl@cygnus.com>\n- * @date August 20, 1998.\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @see List\n+ * @see AbstractList\n+ * @see LinkedList\n+ * @since 1.0\n+ * @status updated to 1.4\n  */\n public class Stack extends Vector\n {\n-  // Could use Vector methods internally for the following methods\n+  // We could use Vector methods internally for the following methods,\n   // but have used Vector fields directly for efficiency (i.e. this\n   // often reduces out duplicate bounds checking).\n \n+  /**\n+   * Compatible with JDK 1.0+.\n+   */\n   private static final long serialVersionUID = 1224463164541339165L;\n \n   /**\n    * This constructor creates a new Stack, initially empty\n    */\n   public Stack()\n   {\n-    super();\n   }\n \n   /**\n    * Pushes an Object onto the top of the stack.  This method is effectively\n-   * the same as addElement(item)\n+   * the same as addElement(item).\n    *\n    * @param item the Object to push onto the stack\n-   * @returns the Object pushed onto the stack\n-   * @see java.util.Vector#addElement(java.util.Object)\n+   * @return the Object pushed onto the stack\n+   * @see Vector#addElement(Object)\n    */\n   public Object push(Object item)\n   {\n@@ -80,26 +85,29 @@ public Object push(Object item)\n \n   /**\n    * Pops an item from the stack and returns it.  The item popped is\n-   * removed from the Stack\n+   * removed from the Stack.\n    *\n-   * @returns the Object popped from the stack\n+   * @return the Object popped from the stack\n+   * @throws EmptyStackException if the stack is empty\n    */\n   public synchronized Object pop()\n   {\n     if (elementCount == 0)\n       throw new EmptyStackException();\n \n+    modCount++;\n     Object obj = elementData[--elementCount];\n \n-    // Set topmost element to null to assist the gc in cleanup\n+    // Set topmost element to null to assist the gc in cleanup.\n     elementData[elementCount] = null;\n     return obj;\n   }\n \n   /**\n-   * Returns the top Object on the stack without removing it\n+   * Returns the top Object on the stack without removing it.\n    *\n-   * @returns the top Object on the stack\n+   * @return the top Object on the stack\n+   * @throws EmptyStackException if the stack is empty\n    */\n   public synchronized Object peek()\n   {\n@@ -110,30 +118,30 @@ public synchronized Object peek()\n   }\n \n   /**\n-   * Tests if the stack is empty\n+   * Tests if the stack is empty.\n    *\n-   * @returns true if the stack contains no items, false otherwise\n+   * @return true if the stack contains no items, false otherwise\n    */\n-  public boolean empty()\n+  public synchronized boolean empty()\n   {\n     return elementCount == 0;\n   }\n \n   /**\n    * Returns the position of an Object on the stack, with the top\n    * most Object being at position 1, and each Object deeper in the\n-   * stack at depth + 1\n+   * stack at depth + 1.\n    *\n    * @param o The object to search for\n-   * @returns The 1 based depth of the Object, or -1 if the Object \n-   * is not on the stack.\n+   * @return The 1 based depth of the Object, or -1 if the Object\n+   *         is not on the stack\n    */\n   public synchronized int search(Object o)\n   {\n-    for (int i = elementCount-1; i >=0; --i)\n-      if (elementData[i].equals(o))\n+    int i = elementCount;\n+    while (--i >= 0)\n+      if (equals(o, elementData[i]))\n         return elementCount - i;\n-\n     return -1;\n   }\n }"}, {"sha": "83386d6e54b6b646acb7169cef0a676ac88715a9", "filename": "libjava/java/util/TreeMap.java", "status": "modified", "additions": 1339, "deletions": 1030, "changes": 2369, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2Fjava%2Futil%2FTreeMap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2Fjava%2Futil%2FTreeMap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FTreeMap.java?ref=d9fd7154ec7908eff8bbbce75651eccf51064ac1", "patch": "@@ -38,143 +38,237 @@\n  * interface.  Elements in the Map will be sorted by either a user-provided\n  * Comparator object, or by the natural ordering of the keys.\n  *\n- * The algorithms are adopted from Corman, Leiserson,\n- * and Rivest's <i>Introduction to Algorithms.</i>  In other words,\n- * I cribbed from the same pseudocode as Sun.  <em>Any similarity\n- * between my code and Sun's (if there is any -- I have never looked\n- * at Sun's) is a result of this fact.</em>\n- *\n- * TreeMap guarantees O(log n) insertion and deletion of elements.  That \n- * being said, there is a large enough constant coefficient in front of \n- * that \"log n\" (overhead involved in keeping the tree \n- * balanced), that TreeMap may not be the best choice for small\n- * collections.\n+ * The algorithms are adopted from Corman, Leiserson, and Rivest's\n+ * <i>Introduction to Algorithms.</i>  TreeMap guarantees O(log n)\n+ * insertion and deletion of elements.  That being said, there is a large\n+ * enough constant coefficient in front of that \"log n\" (overhead involved\n+ * in keeping the tree balanced), that TreeMap may not be the best choice\n+ * for small collections. If something is already sorted, you may want to\n+ * just use a LinkedHashMap to maintain the order while providing O(1) access.\n  *\n  * TreeMap is a part of the JDK1.2 Collections API.  Null keys are allowed\n- * only if a Comparator is used which can deal with them.  Null values are \n- * always allowed.\n+ * only if a Comparator is used which can deal with them; natural ordering\n+ * cannot cope with null.  Null values are always allowed. Note that the\n+ * ordering must be <i>consistent with equals</i> to correctly implement\n+ * the Map interface. If this condition is violated, the map is still\n+ * well-behaved, but you may have suprising results when comparing it to\n+ * other maps.<p>\n+ *\n+ * This implementation is not synchronized. If you need to share this between\n+ * multiple threads, do something like:<br>\n+ * <code>SortedMap m\n+ *       = Collections.synchronizedSortedMap(new TreeMap(...));</code><p>\n+ *\n+ * The iterators are <i>fail-fast</i>, meaning that any structural\n+ * modification, except for <code>remove()</code> called on the iterator\n+ * itself, cause the iterator to throw a\n+ * <code>ConcurrentModificationException</code> rather than exhibit\n+ * non-deterministic behavior.\n  *\n- * @author           Jon Zeppieri\n- * @author\t     Bryce McKinlay\n+ * @author Jon Zeppieri\n+ * @author Bryce McKinlay\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @see Map\n+ * @see HashMap\n+ * @see Hashtable\n+ * @see LinkedHashMap\n+ * @see Comparable\n+ * @see Comparator\n+ * @see Collection\n+ * @see Collections#synchronizedSortedMap(SortedMap)\n+ * @since 1.2\n+ * @status updated to 1.4\n  */\n public class TreeMap extends AbstractMap\n   implements SortedMap, Cloneable, Serializable\n {\n-  private static final int RED = -1,\n-                           BLACK = 1;\n+  // Implementation note:\n+  // A red-black tree is a binary search tree with the additional properties\n+  // that all paths to a leaf node visit the same number of black nodes,\n+  // and no red node has red children. To avoid some null-pointer checks,\n+  // we use the special node nil which is always black, has no relatives,\n+  // and has key and value of null (but is not equal to a mapping of null).\n \n-  /** Sentinal node, used to avoid null checks for corner cases and make the\n-      delete rebalance code simpler. Note that this must not be static, due \n-      to thread-safety concerns. */\n-  transient Node nil = new Node(null, null);\n+  /**\n+   * Compatible with JDK 1.2.\n+   */\n+  private static final long serialVersionUID = 919286545866124006L;\n \n-  /** The root node of this TreeMap */\n-  transient Node root = nil;\n+  /**\n+   * Color status of a node. Package visible for use by nested classes.\n+   */\n+  static final int RED = -1,\n+                   BLACK = 1;\n \n-  /** The size of this TreeMap */\n-  transient int size = 0;\n+  /**\n+   * Sentinal node, used to avoid null checks for corner cases and make the\n+   * delete rebalance code simpler. The rebalance code must never assign\n+   * the parent, left, or right of nil, but may safely reassign the color\n+   * to be black. This object must never be used as a key in a TreeMap, or\n+   * it will break bounds checking of a SubMap.\n+   */\n+  static final Node nil = new Node(null, null, BLACK);\n+  static\n+    {\n+      // Nil is self-referential, so we must initialize it after creation.\n+      nil.parent = nil;\n+      nil.left = nil;\n+      nil.right = nil;\n+    }\n \n-  /** Number of modifications */\n-  transient int modCount = 0;\n+  /**\n+   * The root node of this TreeMap.\n+   */\n+  private transient Node root = nil;\n+\n+  /**\n+   * The size of this TreeMap. Package visible for use by nested classes.\n+   */\n+  transient int size;\n \n-  /** This TreeMap's comparator, if any. */\n-  Comparator comparator = null;\n+  /**\n+   * The cache for {@link #entrySet()}.\n+   */\n+  private transient Set entries;\n \n-  static final long serialVersionUID = 919286545866124006L;\n+  /**\n+   * Counts the number of modifications this TreeMap has undergone, used\n+   * by Iterators to know when to throw ConcurrentModificationExceptions.\n+   * Package visible for use by nested classes.\n+   */\n+  transient int modCount;\n+\n+  /**\n+   * This TreeMap's comparator, or null for natural ordering.\n+   * Package visible for use by nested classes.\n+   * @serial the comparator ordering this tree, or null\n+   */\n+  final Comparator comparator;\n \n-  private static class Node extends BasicMapEntry implements Map.Entry\n+  /**\n+   * Class to represent an entry in the tree. Holds a single key-value pair,\n+   * plus pointers to parent and child nodes.\n+   *\n+   * @author Eric Blake <ebb9@email.byu.edu>\n+   */\n+  private static final class Node extends BasicMapEntry\n   {\n+    // All fields package visible for use by nested classes.\n+    /** The color of this node. */\n     int color;\n-    Node left;\n-    Node right;\n-    Node parent;\n \n-    Node(Object key, Object value)\n+    /** The left child node. */\n+    Node left = nil;\n+    /** The right child node. */\n+    Node right = nil;\n+    /** The parent node. */\n+    Node parent = nil;\n+\n+    /**\n+     * Simple constructor.\n+     * @param key the key\n+     * @param value the value\n+     */\n+    Node(Object key, Object value, int color)\n     {\n       super(key, value);\n-      this.color = BLACK;\n+      this.color = color;\n     }\n   }\n \n   /**\n-   * Instantiate a new TreeMap with no elements, using the keys'\n-   * natural ordering to sort.\n+   * Instantiate a new TreeMap with no elements, using the keys' natural\n+   * ordering to sort. All entries in the map must have a key which implements\n+   * Comparable, and which are <i>mutually comparable</i>, otherwise map\n+   * operations may throw a {@link ClassCastException}. Attempts to use\n+   * a null key will throw a {@link NullPointerException}.\n    *\n-   * @see java.lang.Comparable\n+   * @see Comparable\n    */\n   public TreeMap()\n   {\n+    this((Comparator) null);\n   }\n \n   /**\n-   * Instantiate a new TreeMap with no elements, using the provided\n-   * comparator to sort.\n+   * Instantiate a new TreeMap with no elements, using the provided comparator\n+   * to sort. All entries in the map must have keys which are mutually\n+   * comparable by the Comparator, otherwise map operations may throw a\n+   * {@link ClassCastException}.\n    *\n-   * @param        oComparator        a Comparator object, used to sort \n-   *                                  the keys of this SortedMap\n+   * @param comparator the sort order for the keys of this map, or null\n+   *        for the natural order\n    */\n   public TreeMap(Comparator c)\n   {\n     comparator = c;\n   }\n \n   /**\n-   * Instantiate a new TreeMap, initializing it with all of the\n-   * elements in the provided Map.  The elements will be sorted \n-   * using the natural ordering of the keys.\n-   *\n-   * @param              map         a Map, whose keys will be put into\n-   *                                  this TreeMap\n+   * Instantiate a new TreeMap, initializing it with all of the elements in\n+   * the provided Map.  The elements will be sorted using the natural\n+   * ordering of the keys. This algorithm runs in n*log(n) time. All entries\n+   * in the map must have keys which implement Comparable and are mutually\n+   * comparable, otherwise map operations may throw a\n+   * {@link ClassCastException}.\n    *\n-   * @throws             ClassCastException     if the keys in the provided\n-   *                                            Map do not implement \n-   *                                            Comparable\n-   *\n-   * @see                java.lang.Comparable\n+   * @param map a Map, whose entries will be put into this TreeMap\n+   * @throws ClassCastException if the keys in the provided Map are not\n+   *         comparable\n+   * @throws NullPointerException if map is null\n+   * @see Comparable\n    */\n   public TreeMap(Map map)\n   {\n+    this((Comparator) null);\n     putAll(map);\n   }\n \n-  /** \n-   * Instantiate a new TreeMap, initializing it with all of the\n-   * elements in the provided SortedMap.  The elements will be sorted \n-   * using the same method as in the provided SortedMap.\n+  /**\n+   * Instantiate a new TreeMap, initializing it with all of the elements in\n+   * the provided SortedMap.  The elements will be sorted using the same\n+   * comparator as in the provided SortedMap. This runs in linear time.\n+   *\n+   * @param sm a SortedMap, whose entries will be put into this TreeMap\n+   * @throws NullPointerException if sm is null\n    */\n   public TreeMap(SortedMap sm)\n   {\n     this(sm.comparator());\n-\n-    int sm_size = sm.size();\n+    int pos = sm.size();\n     Iterator itr = sm.entrySet().iterator();\n \n-    fabricateTree(sm_size);\n+    fabricateTree(pos);\n     Node node = firstNode();\n-    \n-    for (int i = 0; i < sm_size; i++)\n+\n+    while (--pos >= 0)\n       {\n-\tMap.Entry me = (Map.Entry) itr.next();\n-\tnode.key = me.getKey();\n-\tnode.value = me.getValue();\t\n-\tnode = successor(node);\n+        Map.Entry me = (Map.Entry) itr.next();\n+        node.key = me.getKey();\n+        node.value = me.getValue();\n+        node = successor(node);\n       }\n   }\n \n-  public int size()\n-  {\n-    return size;\n-  }\n-\n+  /**\n+   * Clears the Map so it has no keys. This is O(1).\n+   */\n   public void clear()\n   {\n-    modCount++;\n-    root = nil;\n-    // nil node could have a residual parent reference, clear it for GC.\n-    nil.parent = null;\n-    size = 0;\n+    if (size > 0)\n+      {\n+        modCount++;\n+        root = nil;\n+        size = 0;\n+      }\n   }\n \n+  /**\n+   * Returns a shallow clone of this TreeMap. The Map itself is cloned,\n+   * but its contents are not.\n+   *\n+   * @return the clone\n+   */\n   public Object clone()\n   {\n     TreeMap copy = null;\n@@ -185,547 +279,805 @@ public Object clone()\n     catch (CloneNotSupportedException x)\n       {\n       }\n-    // Each instance must have a unique sentinal.\n-    copy.nil = new Node(null, null);\n+    copy.entries = null;\n     copy.fabricateTree(size);\n \n     Node node = firstNode();\n     Node cnode = copy.firstNode();\n-    \n+\n     while (node != nil)\n       {\n         cnode.key = node.key;\n-\tcnode.value = node.value;\n-\tnode = successor(node);\n-\tcnode = copy.successor(cnode);\n+        cnode.value = node.value;\n+        node = successor(node);\n+        cnode = copy.successor(cnode);\n       }\n     return copy;\n   }\n-  \n+\n+  /**\n+   * Return the comparator used to sort this map, or null if it is by\n+   * natural order.\n+   *\n+   * @return the map's comparator\n+   */\n   public Comparator comparator()\n   {\n     return comparator;\n   }\n \n+  /**\n+   * Returns true if the map contains a mapping for the given key.\n+   *\n+   * @param key the key to look for\n+   * @return true if the key has a mapping\n+   * @throws ClassCastException if key is not comparable to map elements\n+   * @throws NullPointerException if key is null and the comparator is not\n+   *         tolerant of nulls\n+   */\n   public boolean containsKey(Object key)\n   {\n     return getNode(key) != nil;\n   }\n \n+  /**\n+   * Returns true if the map contains at least one mapping to the given value.\n+   * This requires linear time.\n+   *\n+   * @param value the value to look for\n+   * @return true if the value appears in a mapping\n+   */\n   public boolean containsValue(Object value)\n   {\n     Node node = firstNode();\n-    Object currentVal;\n-\n     while (node != nil)\n       {\n-\tcurrentVal = node.getValue();\n-\n-        if (value == null ? currentVal == null : value.equals (currentVal))\n-\t  return true;\n-\n-\tnode = successor(node);\n+        if (equals(value, node.value))\n+          return true;\n+        node = successor(node);\n       }\n     return false;\n   }\n \n+  /**\n+   * Returns a \"set view\" of this TreeMap's entries. The set is backed by\n+   * the TreeMap, so changes in one show up in the other.  The set supports\n+   * element removal, but not element addition.<p>\n+   *\n+   * Note that the iterators for all three views, from keySet(), entrySet(),\n+   * and values(), traverse the TreeMap in sorted sequence.\n+   *\n+   * @return a set view of the entries\n+   * @see #keySet()\n+   * @see #values()\n+   * @see Map.Entry\n+   */\n   public Set entrySet()\n   {\n-    // Create an AbstractSet with custom implementations of those methods that \n-    // can be overriden easily and efficiently.\n-    return new AbstractSet()\n-    {\n-      public int size()\n-      {\n-        return size;\n-      }\n-      \n-      public Iterator iterator()\n-      {\n-        return new TreeIterator(TreeIterator.ENTRIES);\n-      }\n-            \n-      public void clear()\n+    if (entries == null)\n+      // Create an AbstractSet with custom implementations of those methods\n+      // that can be overriden easily and efficiently.\n+      entries = new AbstractSet()\n       {\n-        TreeMap.this.clear();\n-      }\n+        public int size()\n+        {\n+          return size;\n+        }\n \n-      public boolean contains(Object o)\n-      {\n-        if (!(o instanceof Map.Entry))\n-\t  return false;\n-\tMap.Entry me = (Map.Entry) o;\n-\tNode n = getNode(me.getKey());\n-\treturn (n != nil && me.getValue().equals(n.value));\n-      }\n-      \n-      public boolean remove(Object o)\n-      {\n-        if (!(o instanceof Map.Entry))\n-\t  return false;\n-\tMap.Entry me = (Map.Entry) o;\n-\tNode n = getNode(me.getKey());\n-\tif (n != nil && me.getValue().equals(n.value))\n-\t  {\n-\t    removeNode(n);\n-\t    return true;\n-\t  }\n-\treturn false;\n+        public Iterator iterator()\n+        {\n+          return new TreeIterator(ENTRIES);\n+        }\n+\n+        public void clear()\n+        {\n+          TreeMap.this.clear();\n+        }\n+\n+        public boolean contains(Object o)\n+        {\n+          if (! (o instanceof Map.Entry))\n+            return false;\n+          Map.Entry me = (Map.Entry) o;\n+          Node n = getNode(me.getKey());\n+          return n != nil && AbstractSet.equals(me.getValue(), n.value);\n       }\n-    };\n+\n+        public boolean remove(Object o)\n+        {\n+          if (! (o instanceof Map.Entry))\n+            return false;\n+          Map.Entry me = (Map.Entry) o;\n+          Node n = getNode(me.getKey());\n+          if (n != nil && AbstractSet.equals(me.getValue(), n.value))\n+            {\n+              removeNode(n);\n+              return true;\n+            }\n+          return false;\n+        }\n+      };\n+    return entries;\n   }\n \n+  /**\n+   * Returns the first (lowest) key in the map.\n+   *\n+   * @return the first key\n+   * @throws NoSuchElementException if the map is empty\n+   */\n   public Object firstKey()\n   {\n     if (root == nil)\n-      throw new NoSuchElementException(\"empty\");\n-    return firstNode().getKey();\n-  }\n-  \n-  private Node firstNode()\n-  {\n-    if (root == nil)\n-      return nil;\n-    Node node = root;\n-    while (node.left != nil)\n-      node = node.left;\n-    return node;\n+      throw new NoSuchElementException();\n+    return firstNode().key;\n   }\n \n-  public Object lastKey()\n-  {\n-    if (root == nil)\n-      throw new NoSuchElementException(\"empty\");\n-    return lastNode().getKey();\n-  }\n-  \n-  private Node lastNode()\n-  {\n-    if (root == nil)\n-      return nil;\n-    Node node = root;\n-    while (node.right != nil)\n-      node = node.right;\n-    return node;  \n-  }\n-  \n+  /**\n+   * Return the value in this TreeMap associated with the supplied key,\n+   * or <code>null</code> if the key maps to nothing.  NOTE: Since the value\n+   * could also be null, you must use containsKey to see if this key\n+   * actually maps to something.\n+   *\n+   * @param key the key for which to fetch an associated value\n+   * @return what the key maps to, if present\n+   * @throws ClassCastException if key is not comparable to elements in the map\n+   * @throws NullPointerException if key is null but the comparator does not\n+   *         tolerate nulls\n+   * @see #put(Object, Object)\n+   * @see #containsKey(Object)\n+   */\n   public Object get(Object key)\n   {\n+    // Exploit fact that nil.value == null.\n     return getNode(key).value;\n   }\n-  \n-  /** Return the TreeMap.Node associated with KEY, or the nil node if no such\n-      node exists in the tree. */\n-  private Node getNode(Object key)\n-  {\n-    int comparison;\n-    Node current = root;\n \n-    while (current != nil)\n-      {\n-        comparison = compare(key, current.key);\n-\tif (comparison > 0)\n-\t  current = current.right;\n-\telse if (comparison < 0)\n-\t  current = current.left;\n-\telse\n-\t  return current;\n-      }\n-    return current; \n+  /**\n+   * Returns a view of this Map including all entries with keys less than\n+   * <code>toKey</code>. The returned map is backed by the original, so changes\n+   * in one appear in the other. The submap will throw an\n+   * {@link IllegalArgumentException} for any attempt to access or add an\n+   * element beyond the specified cutoff. The returned map does not include\n+   * the endpoint; if you want inclusion, pass the successor element.\n+   *\n+   * @param toKey the (exclusive) cutoff point\n+   * @return a view of the map less than the cutoff\n+   * @throws ClassCastException if <code>toKey</code> is not compatible with\n+   *         the comparator (or is not Comparable, for natural ordering)\n+   * @throws NullPointerException if toKey is null, but the comparator does not\n+   *         tolerate null elements\n+   */\n+  public SortedMap headMap(Object toKey)\n+  {\n+    return new SubMap(nil, toKey);\n   }\n \n+  /**\n+   * Returns a \"set view\" of this TreeMap's keys. The set is backed by the\n+   * TreeMap, so changes in one show up in the other.  The set supports\n+   * element removal, but not element addition.\n+   *\n+   * @return a set view of the keys\n+   * @see #values()\n+   * @see #entrySet()\n+   */\n   public Set keySet()\n   {\n-    // Create an AbstractSet with custom implementations of those methods that \n-    // can be overriden easily and efficiently.\n-    return new AbstractSet()\n-    {\n-      public int size()\n+    if (keys == null)\n+      // Create an AbstractSet with custom implementations of those methods\n+      // that can be overriden easily and efficiently.\n+      keys = new AbstractSet()\n       {\n-        return size;\n-      }\n-      \n-      public Iterator iterator()\n-      {\n-        return new TreeIterator(TreeIterator.KEYS);\n-      }\n+        public int size()\n+        {\n+          return size;\n+        }\n \n-      public void clear()\n-      {\n-        TreeMap.this.clear();\n-      }\n+        public Iterator iterator()\n+        {\n+          return new TreeIterator(KEYS);\n+        }\n \n-      public boolean contains(Object o)\n-      {\n-        return TreeMap.this.containsKey(o);\n-      }\n-      \n-      public boolean remove(Object key)\n-      {\n-        Node n = getNode(key);\n-\tif (n == nil)\n-\t  return false;\n-        TreeMap.this.removeNode(n);\n-\treturn true;\n-      }\n-    };\n+        public void clear()\n+        {\n+          TreeMap.this.clear();\n+        }\n+\n+        public boolean contains(Object o)\n+        {\n+          return containsKey(o);\n+        }\n+\n+        public boolean remove(Object key)\n+        {\n+          Node n = getNode(key);\n+          if (n == nil)\n+            return false;\n+          removeNode(n);\n+          return true;\n+        }\n+      };\n+    return keys;\n+  }\n+\n+  /**\n+   * Returns the last (highest) key in the map.\n+   *\n+   * @return the last key\n+   * @throws NoSuchElementException if the map is empty\n+   */\n+  public Object lastKey()\n+  {\n+    if (root == nil)\n+      throw new NoSuchElementException(\"empty\");\n+    return lastNode().key;\n   }\n \n+  /**\n+   * Puts the supplied value into the Map, mapped by the supplied key.\n+   * The value may be retrieved by any object which <code>equals()</code>\n+   * this key. NOTE: Since the prior value could also be null, you must\n+   * first use containsKey if you want to see if you are replacing the\n+   * key's mapping.\n+   *\n+   * @param key the key used to locate the value\n+   * @param value the value to be stored in the HashMap\n+   * @return the prior mapping of the key, or null if there was none\n+   * @throws ClassCastException if key is not comparable to current map keys\n+   * @throws NullPointerException if key is null, but the comparator does\n+   *         not tolerate nulls\n+   * @see #get(Object)\n+   * @see Object#equals(Object)\n+   */\n   public Object put(Object key, Object value)\n   {\n-    modCount++;\n     Node current = root;\n     Node parent = nil;\n     int comparison = 0;\n-    \n+\n     // Find new node's parent.\n     while (current != nil)\n       {\n-\tparent = current;\n-\tcomparison = compare(key, current.key);\n-\tif (comparison > 0)\n-\t  current = current.right;\n-\telse if (comparison < 0)\n-\t  current = current.left;\n-\telse\n-\t  {\n-\t    // Key already in tree.\n-\t    Object r = current.value;\n-\t    current.value = value;\n-\t    return r;\n-\t  }\n+        parent = current;\n+        comparison = compare(key, current.key);\n+        if (comparison > 0)\n+          current = current.right;\n+        else if (comparison < 0)\n+          current = current.left;\n+        else // Key already in tree.\n+          return current.setValue(value);\n       }\n-    \n+\n     // Set up new node.\n-    Node n = new Node(key, value);\n-    n.color = RED;\n+    Node n = new Node(key, value, RED);\n     n.parent = parent;\n-    n.left = nil;\n-    n.right = nil;\n-    \n+\n     // Insert node in tree.\n+    modCount++;\n     size++;\n     if (parent == nil)\n       {\n-        // Special case: inserting into an empty tree.\n-\troot = n;\n-\tn.color = BLACK;\n-\treturn null;\n+        // Special case inserting into an empty tree.\n+        root = n;\n+        return null;\n       }\n-    else if (comparison > 0)\n+    if (comparison > 0)\n       parent.right = n;\n     else\n-      parent.left = n;   \n-    \n+      parent.left = n;\n+\n     // Rebalance after insert.\n     insertFixup(n);\n-    //verifyTree();\n     return null;\n   }\n \n-  /** Maintain red-black balance after inserting a new node. */\n-  private void insertFixup(Node n)\n-  {\n-    // Only need to rebalance when parent is a RED node, and while at least\n-    // 2 levels deep into the tree (ie: node has a grandparent).\n-    while (n != root && n.parent.parent != nil && n.parent.color == RED)\n-      {\n-\tif (n.parent == n.parent.parent.left)\n-\t  {\n-            Node uncle = n.parent.parent.right;\n-            if (uncle != nil && uncle.color == RED) \n-\t      {\n-        \tn.parent.color = BLACK;\n-        \tuncle.color = BLACK;\n-        \tn.parent.parent.color = RED;\n-        \tn = n.parent.parent;\n-              }\n-\t    else // Uncle is BLACK.\n-\t      {                \n-                if (n == n.parent.right)\n-\t\t  {\n-                    // Make n a left child.\n-                    n = n.parent;\n-                    rotateLeft(n);\n-                  }\n-\n-                // Recolor and rotate.\n-                n.parent.color = BLACK;\n-                n.parent.parent.color = RED;\n-                rotateRight(n.parent.parent);\n-              }\n-\t  }\n-\telse\n-\t  {\n-\t    // Mirror image of above code.\n-\t    Node uncle = n.parent.parent.left;\n-            if (uncle != nil && uncle.color == RED)\n-\t      {\n-                n.parent.color = BLACK;\n-                uncle.color = BLACK;\n-                n.parent.parent.color = RED;\n-                n = n.parent.parent;\n-              }\n-\t    else\n-\t      {\n-                if (n == n.parent.left)\n-\t\t  {\n-                    n = n.parent;\n-                    rotateRight(n);\n-                  }\n-                n.parent.color = BLACK;\n-                n.parent.parent.color = RED;\n-                rotateLeft(n.parent.parent);\n-\t      }\n-\t  }\n-      }\n-    root.color = BLACK;\n-  }\n-\n+  /**\n+   * Copies all elements of the given map into this hashtable.  If this table\n+   * already has a mapping for a key, the new mapping replaces the current\n+   * one.\n+   *\n+   * @param m the map to be hashed into this\n+   * @throws ClassCastException if a key in m is not comparable with keys\n+   *         in the map\n+   * @throws NullPointerException if a key in m is null, and the comparator\n+   *         does not tolerate nulls\n+   */\n   public void putAll(Map m)\n   {\n     Iterator itr = m.entrySet().iterator();\n-    int msize = m.size();\n-    Map.Entry e;\n-\n-    for (int i = 0; i < msize; i++)\n+    int pos = m.size();\n+    while (--pos >= 0)\n       {\n-\te = (Map.Entry) itr.next();\n-\tput(e.getKey(), e.getValue());\n+        Map.Entry e = (Map.Entry) itr.next();\n+        put(e.getKey(), e.getValue());\n       }\n   }\n \n+  /**\n+   * Removes from the TreeMap and returns the value which is mapped by the\n+   * supplied key. If the key maps to nothing, then the TreeMap remains\n+   * unchanged, and <code>null</code> is returned. NOTE: Since the value\n+   * could also be null, you must use containsKey to see if you are\n+   * actually removing a mapping.\n+   *\n+   * @param key the key used to locate the value to remove\n+   * @return whatever the key mapped to, if present\n+   * @throws ClassCastException if key is not comparable to current map keys\n+   * @throws NullPointerException if key is null, but the comparator does\n+   *         not tolerate nulls\n+   */\n   public Object remove(Object key)\n   {\n     Node n = getNode(key);\n-    if (n != nil)\n-      {\n-        removeNode(n);\n-\treturn n.value;\n-      }\n-    return null;\n+    if (n == nil)\n+      return null;\n+    removeNode(n);\n+    return n.value;\n   }\n-  \n-  // Remove node from tree. This will increment modCount and decrement size. \n-  // Node must exist in the tree.\n-  private void removeNode(Node node) // z\n+\n+  /**\n+   * Returns the number of key-value mappings currently in this Map.\n+   *\n+   * @return the size\n+   */\n+  public int size()\n   {\n-    Node splice; // y\n-    Node child;  // x\n-    \n-    modCount++;\n-    size--;\n+    return size;\n+  }\n \n-    // Find splice, the node at the position to actually remove from the tree. \n-    if (node.left == nil || node.right == nil)\n-      {\n-\t// Node to be deleted has 0 or 1 children.\n-        splice = node;\n-\tif (node.left == nil)\n-\t  child = node.right;\n-\telse\n-\t  child = node.left;\n-      }\n-    else\n-      {\n-\t// Node has 2 children. Splice is node's successor, and will be \n-\t// swapped with node since we can't remove node directly.\n-        splice = node.right;\n-        while (splice.left != nil)\n-\t  splice = splice.left;\n-\tchild = splice.right;\n-      }\n+  /**\n+   * Returns a view of this Map including all entries with keys greater or\n+   * equal to <code>fromKey</code> and less than <code>toKey</code> (a\n+   * half-open interval). The returned map is backed by the original, so\n+   * changes in one appear in the other. The submap will throw an\n+   * {@link IllegalArgumentException} for any attempt to access or add an\n+   * element beyond the specified cutoffs. The returned map includes the low\n+   * endpoint but not the high; if you want to reverse this behavior on\n+   * either end, pass in the successor element.\n+   *\n+   * @param fromKey the (inclusive) low cutoff point\n+   * @param toKey the (exclusive) high cutoff point\n+   * @return a view of the map between the cutoffs\n+   * @throws ClassCastException if either cutoff is not compatible with\n+   *         the comparator (or is not Comparable, for natural ordering)\n+   * @throws NullPointerException if fromKey or toKey is null, but the\n+   *         comparator does not tolerate null elements\n+   * @throws IllegalArgumentException if fromKey is greater than toKey\n+   */\n+  public SortedMap subMap(Object fromKey, Object toKey)\n+  {\n+    return new SubMap(fromKey, toKey);\n+  }\n \n-    // Unlink splice from the tree.\n-    Node parent = splice.parent;\n-    child.parent = parent;\n-    if (parent != nil)\n+  /**\n+   * Returns a view of this Map including all entries with keys greater or\n+   * equal to <code>fromKey</code>. The returned map is backed by the\n+   * original, so changes in one appear in the other. The submap will throw an\n+   * {@link IllegalArgumentException} for any attempt to access or add an\n+   * element beyond the specified cutoff. The returned map includes the\n+   * endpoint; if you want to exclude it, pass in the successor element.\n+   *\n+   * @param fromKey the (inclusive) low cutoff point\n+   * @return a view of the map above the cutoff\n+   * @throws ClassCastException if <code>fromKey</code> is not compatible with\n+   *         the comparator (or is not Comparable, for natural ordering)\n+   * @throws NullPointerException if fromKey is null, but the comparator\n+   *         does not tolerate null elements\n+   */\n+  public SortedMap tailMap(Object fromKey)\n+  {\n+    return new SubMap(fromKey, nil);\n+  }\n+\n+  /**\n+   * Returns a \"collection view\" (or \"bag view\") of this TreeMap's values.\n+   * The collection is backed by the TreeMap, so changes in one show up\n+   * in the other.  The collection supports element removal, but not element\n+   * addition.\n+   *\n+   * @return a bag view of the values\n+   * @see #keySet()\n+   * @see #entrySet()\n+   */\n+  public Collection values()\n+  {\n+    if (values == null)\n+      // We don't bother overriding many of the optional methods, as doing so\n+      // wouldn't provide any significant performance advantage.\n+      values = new AbstractCollection()\n       {\n-\tif (splice == parent.left)\n-          parent.left = child;\n-\telse\n-          parent.right = child;\n-      }\n-    else\n-      root = child;\n+        public int size()\n+        {\n+          return size;\n+        }\n \n-    // Keep track of splice's color in case it gets changed in the swap.\n-    int spliceColor = splice.color;\n+        public Iterator iterator()\n+        {\n+          return new TreeIterator(VALUES);\n+        }\n \n-/*\n-    if (splice != node)\n-      {\n-        node.key = splice.key;\n-\tnode.value = splice.value;\n-      }\n-*/\n-    if (splice != node)\n-      {\n-        // Swap SPLICE for NODE. Some implementations optimize here by simply\n-\t// swapping the values, but we can't do that: if an iterator was\n-\t// referencing a node in its \"next\" field, and that node got swapped, \n-\t// things would get confused.\n-\tif (node == root)\n-\t  {\n-\t    root = splice;\n-\t  }\n-\telse\n-\t  {\n-\t    if (node.parent.left == node)\n-\t      node.parent.left = splice;\n-\t    else\n-\t      node.parent.right = splice;\n-          }\n-\tsplice.parent = node.parent;\n-\tsplice.left = node.left;\n-\tsplice.right = node.right;\n-\tsplice.left.parent = splice;\n-\tsplice.right.parent = splice;\n-\tsplice.color = node.color;\n-      }\n+        public void clear()\n+        {\n+          TreeMap.this.clear();\n+        }\n+      };\n+    return values;\n+  }\n \n-    if (spliceColor == BLACK)\n-      deleteFixup (child);\n-    \n-    //verifyTree();      \n+  /**\n+   * Compares two elements by the set comparator, or by natural ordering.\n+   * Package visible for use by nested classes.\n+   *\n+   * @param o1 the first object\n+   * @param o2 the second object\n+   * @throws ClassCastException if o1 and o2 are not mutually comparable,\n+   *         or are not Comparable with natural ordering\n+   * @throws NullPointerException if o1 or o2 is null with natural ordering\n+   */\n+  final int compare(Object o1, Object o2)\n+  {\n+    return (comparator == null\n+            ? ((Comparable) o1).compareTo(o2)\n+            : comparator.compare(o1, o2));\n   }\n \n-  /** Maintain red-black balance after deleting a node. */\n-  private void deleteFixup (Node node)\n+  /**\n+   * Maintain red-black balance after deleting a node.\n+   *\n+   * @param node the child of the node just deleted, possibly nil\n+   * @param parent the parent of the node just deleted, never nil\n+   */\n+  private void deleteFixup(Node node, Node parent)\n   {\n-    // A black node has been removed, so we need to rebalance to avoid \n+    // if (parent == nil)\n+    //   throw new InternalError();\n+    // If a black node has been removed, we need to rebalance to avoid\n     // violating the \"same number of black nodes on any path\" rule. If\n-    // node is red, we can simply recolor it black and all is well. \n+    // node is red, we can simply recolor it black and all is well.\n     while (node != root && node.color == BLACK)\n       {\n-        if (node == node.parent.left)\n-\t  {\n-\t    // Rebalance left side.\n-\t    Node sibling = node.parent.right;\n-\t    if (sibling.color == RED)\n-\t      {\n+        if (node == parent.left)\n+          {\n+            // Rebalance left side.\n+            Node sibling = parent.right;\n+            // if (sibling == nil)\n+            //   throw new InternalError();\n+            if (sibling.color == RED)\n+              {\n+                // Case 1: Sibling is red.\n+                // Recolor sibling and parent, and rotate parent left.\n                 sibling.color = BLACK;\n-                node.parent.color = RED;\n-                rotateLeft(node.parent);\n-                sibling = node.parent.right;\n-\t      }\n+                parent.color = RED;\n+                rotateLeft(parent);\n+                sibling = parent.right;\n+              }\n \n-\t    if (sibling.left.color == BLACK && sibling.right.color == BLACK)\n+            if (sibling.left.color == BLACK && sibling.right.color == BLACK)\n               {\n-\t        // Case 2: Sibling has no red children.\n-\t\tsibling.color = RED;\n-\t\t// Black height has been decreased, so move up the tree and \n-\t\t// repeat.\n-\t\tnode = node.parent;\n+                // Case 2: Sibling has no red children.\n+                // Recolor sibling, and move to parent.\n+                sibling.color = RED;\n+                node = parent;\n+                parent = parent.parent;\n               }\n-\t    else\n-\t      {\t      \n-\t        if (sibling.right.color == BLACK)\n-\t\t  {\n-\t\t    // Case 3: Sibling has red left child.\n-\t\t    sibling.left.color = BLACK;\n-\t\t    sibling.color = RED;\n+            else\n+              {\n+                if (sibling.right.color == BLACK)\n+                  {\n+                    // Case 3: Sibling has red left child.\n+                    // Recolor sibling and left child, rotate sibling right.\n+                    sibling.left.color = BLACK;\n+                    sibling.color = RED;\n                     rotateRight(sibling);\n-                    sibling = node.parent.right;\n-\t\t  }\t\t  \n-\t\t\n-\t\t// Case 4: Sibling has red right child.\n-\t\tsibling.color = sibling.parent.color;\n-\t\tsibling.parent.color = BLACK;\n-\t\tsibling.right.color = BLACK;\n-                rotateLeft(node.parent);\n+                    sibling = parent.right;\n+                  }\n+                // Case 4: Sibling has red right child. Recolor sibling,\n+                // right child, and parent, and rotate parent left.\n+                sibling.color = parent.color;\n+                parent.color = BLACK;\n+                sibling.right.color = BLACK;\n+                rotateLeft(parent);\n                 node = root; // Finished.\n-\t      }\n-\t  }\n-\telse\n-\t  {\n-\t    // Symmetric \"mirror\" of left-side case.\n-\t    Node sibling = node.parent.left;\n-\t    if (sibling.color == RED)\n-\t      {\n+              }\n+          }\n+        else\n+          {\n+            // Symmetric \"mirror\" of left-side case.\n+            Node sibling = parent.left;\n+            // if (sibling == nil)\n+            //   throw new InternalError();\n+            if (sibling.color == RED)\n+              {\n+                // Case 1: Sibling is red.\n+                // Recolor sibling and parent, and rotate parent right.\n                 sibling.color = BLACK;\n-                node.parent.color = RED;\n-                rotateRight(node.parent);\n-                sibling = node.parent.left;\n-\t      }\n+                parent.color = RED;\n+                rotateRight(parent);\n+                sibling = parent.left;\n+              }\n \n-\t    if (sibling.left.color == BLACK && sibling.right.color == BLACK)\n+            if (sibling.right.color == BLACK && sibling.left.color == BLACK)\n               {\n-\t\tsibling.color = RED;\n-\t\tnode = node.parent;\n+                // Case 2: Sibling has no red children.\n+                // Recolor sibling, and move to parent.\n+                sibling.color = RED;\n+                node = parent;\n+                parent = parent.parent;\n               }\n-\t    else\n-\t      {\t      \n-\t        if (sibling.left.color == BLACK)\n-\t\t  {\n-\t\t    sibling.right.color = BLACK;\n-\t\t    sibling.color = RED;\n+            else\n+              {\n+                if (sibling.left.color == BLACK)\n+                  {\n+                    // Case 3: Sibling has red right child.\n+                    // Recolor sibling and right child, rotate sibling left.\n+                    sibling.right.color = BLACK;\n+                    sibling.color = RED;\n                     rotateLeft(sibling);\n-                    sibling = node.parent.left;\n-\t\t  }\t\t  \n-\t\t\n-\t\tsibling.color = sibling.parent.color;\n-\t\tsibling.parent.color = BLACK;\n-\t\tsibling.left.color = BLACK;\n-                rotateRight(node.parent);\n-                node = root;\n-\t      }\n-\t  }\n+                    sibling = parent.left;\n+                  }\n+                // Case 4: Sibling has red left child. Recolor sibling,\n+                // left child, and parent, and rotate parent right.\n+                sibling.color = parent.color;\n+                parent.color = BLACK;\n+                sibling.left.color = BLACK;\n+                rotateRight(parent);\n+                node = root; // Finished.\n+              }\n+          }\n       }\n     node.color = BLACK;\n   }\n \n-  public SortedMap subMap(Object fromKey, Object toKey)\n+  /**\n+   * Construct a perfectly balanced tree consisting of n \"blank\" nodes. This\n+   * permits a tree to be generated from pre-sorted input in linear time.\n+   *\n+   * @param count the number of blank nodes, non-negative\n+   */\n+  private void fabricateTree(final int count)\n   {\n-    if (compare(fromKey, toKey) <= 0)\n-      return new SubMap(fromKey, toKey);\n-    else\n-      throw new IllegalArgumentException(\"fromKey > toKey\");\n+    if (count == 0)\n+      return;\n+\n+    // We color every row of nodes black, except for the overflow nodes.\n+    // I believe that this is the optimal arrangement. We construct the tree\n+    // in place by temporarily linking each node to the next node in the row,\n+    // then updating those links to the children when working on the next row.\n+\n+    // Make the root node.\n+    root = new Node(null, null, BLACK);\n+    size = count;\n+    Node row = root;\n+    int rowsize;\n+\n+    // Fill each row that is completely full of nodes.\n+    for (rowsize = 2; rowsize + rowsize < count; rowsize <<= 1)\n+      {\n+        Node parent = row;\n+        Node last = null;\n+        for (int i = 0; i < rowsize; i += 2)\n+          {\n+            Node left = new Node(null, null, BLACK);\n+            Node right = new Node(null, null, BLACK);\n+            left.parent = parent;\n+            left.right = right;\n+            right.parent = parent;\n+            parent.left = left;\n+            Node next = parent.right;\n+            parent.right = right;\n+            parent = next;\n+            if (last != null)\n+              last.right = left;\n+            last = right;\n+          }\n+        row = row.left;\n+      }\n+\n+    // Now do the partial final row in red.\n+    int overflow = count - rowsize;\n+    Node parent = row;\n+    int i;\n+    for (i = 0; i < overflow; i += 2)\n+      {\n+        Node left = new Node(null, null, RED);\n+        Node right = new Node(null, null, RED);\n+        left.parent = parent;\n+        right.parent = parent;\n+        parent.left = left;\n+        Node next = parent.right;\n+        parent.right = right;\n+        parent = next;\n+      }\n+    // Add a lone left node if necessary.\n+    if (i - overflow == 0)\n+      {\n+        Node left = new Node(null, null, RED);\n+        left.parent = parent;\n+        parent.left = left;\n+        parent = parent.right;\n+        left.parent.right = nil;\n+      }\n+    // Unlink the remaining nodes of the previous row.\n+    while (parent != nil)\n+      {\n+        Node next = parent.right;\n+        parent.right = nil;\n+        parent = next;\n+      }\n   }\n \n-  public SortedMap headMap(Object toKey)\n+  /**\n+   * Returns the first sorted node in the map, or nil if empty. Package\n+   * visible for use by nested classes.\n+   *\n+   * @return the first node\n+   */\n+  final Node firstNode()\n   {\n-    return new SubMap(nil, toKey);\n+    // Exploit fact that nil.left == nil.\n+    Node node = root;\n+    while (node.left != nil)\n+      node = node.left;\n+    return node;\n   }\n \n-  public SortedMap tailMap(Object fromKey)\n+  /**\n+   * Return the TreeMap.Node associated with key, or the nil node if no such\n+   * node exists in the tree. Package visible for use by nested classes.\n+   *\n+   * @param key the key to search for\n+   * @return the node where the key is found, or nil\n+   */\n+  final Node getNode(Object key)\n   {\n-    return new SubMap(fromKey, nil);\n+    Node current = root;\n+    while (current != nil)\n+      {\n+        int comparison = compare(key, current.key);\n+        if (comparison > 0)\n+          current = current.right;\n+        else if (comparison < 0)\n+          current = current.left;\n+        else\n+          return current;\n+      }\n+    return current;\n+  }\n+\n+  /**\n+   * Find the \"highest\" node which is &lt; key. If key is nil, return last\n+   * node. Package visible for use by nested classes.\n+   *\n+   * @param key the upper bound, exclusive\n+   * @return the previous node\n+   */\n+  final Node highestLessThan(Object key)\n+  {\n+    if (key == nil)\n+      return lastNode();\n+\n+    Node last = nil;\n+    Node current = root;\n+    int comparison = 0;\n+\n+    while (current != nil)\n+      {\n+        last = current;\n+        comparison = compare(key, current.key);\n+        if (comparison > 0)\n+          current = current.right;\n+        else if (comparison < 0)\n+          current = current.left;\n+        else // Exact match.\n+          return predecessor(last);\n+      }\n+    return comparison <= 0 ? predecessor(last) : last;\n+  }\n+\n+  /**\n+   * Maintain red-black balance after inserting a new node.\n+   *\n+   * @param n the newly inserted node\n+   */\n+  private void insertFixup(Node n)\n+  {\n+    // Only need to rebalance when parent is a RED node, and while at least\n+    // 2 levels deep into the tree (ie: node has a grandparent). Remember\n+    // that nil.color == BLACK.\n+    while (n.parent.color == RED && n.parent.parent != nil)\n+      {\n+        if (n.parent == n.parent.parent.left)\n+          {\n+            Node uncle = n.parent.parent.right;\n+            // Uncle may be nil, in which case it is BLACK.\n+            if (uncle.color == RED)\n+              {\n+                // Case 1. Uncle is RED: Change colors of parent, uncle,\n+                // and grandparent, and move n to grandparent.\n+                n.parent.color = BLACK;\n+                uncle.color = BLACK;\n+                uncle.parent.color = RED;\n+                n = uncle.parent;\n+              }\n+            else\n+              {\n+                if (n == n.parent.right)\n+                  {\n+                    // Case 2. Uncle is BLACK and x is right child.\n+                    // Move n to parent, and rotate n left.\n+                    n = n.parent;\n+                    rotateLeft(n);\n+                  }\n+                // Case 3. Uncle is BLACK and x is left child.\n+                // Recolor parent, grandparent, and rotate grandparent right.\n+                n.parent.color = BLACK;\n+                n.parent.parent.color = RED;\n+                rotateRight(n.parent.parent);\n+              }\n+          }\n+        else\n+          {\n+            // Mirror image of above code.\n+            Node uncle = n.parent.parent.left;\n+            // Uncle may be nil, in which case it is BLACK.\n+            if (uncle.color == RED)\n+              {\n+                // Case 1. Uncle is RED: Change colors of parent, uncle,\n+                // and grandparent, and move n to grandparent.\n+                n.parent.color = BLACK;\n+                uncle.color = BLACK;\n+                uncle.parent.color = RED;\n+                n = uncle.parent;\n+              }\n+            else\n+              {\n+                if (n == n.parent.left)\n+                {\n+                    // Case 2. Uncle is BLACK and x is left child.\n+                    // Move n to parent, and rotate n right.\n+                    n = n.parent;\n+                    rotateRight(n);\n+                  }\n+                // Case 3. Uncle is BLACK and x is right child.\n+                // Recolor parent, grandparent, and rotate grandparent left.\n+                n.parent.color = BLACK;\n+                n.parent.parent.color = RED;\n+                rotateLeft(n.parent.parent);\n+              }\n+          }\n+      }\n+    root.color = BLACK;\n   }\n \n-  /** Returns a \"collection view\" (or \"bag view\") of this TreeMap's values. */\n-  public Collection values()\n+  /**\n+   * Returns the last sorted node in the map, or nil if empty.\n+   *\n+   * @return the last node\n+   */\n+  private Node lastNode()\n   {\n-    // We don't bother overriding many of the optional methods, as doing so\n-    // wouldn't provide any significant performance advantage.\n-    return new AbstractCollection()\n-    {\n-      public int size()\n-      {\n-        return size;\n-      }\n-      \n-      public Iterator iterator()\n-      {\n-        return new TreeIterator(TreeIterator.VALUES);\n-      }\n-      \n-      public void clear()\n-      {\n-        TreeMap.this.clear();\n-      }\n-    };\n+    // Exploit fact that nil.right == nil.\n+    Node node = root;\n+    while (node.right != nil)\n+      node = node.right;\n+    return node;\n   }\n \n-  // Find the \"highest\" node which is < key. If key is nil, return last node.\n-  // Note that highestLessThan is exclusive (it won't return a key which is\n-  // equal to \"key\"), while lowestGreaterThan is inclusive, in order to be \n-  // consistent with the semantics of subMap().\n-  private Node highestLessThan(Object key)\n+  /**\n+   * Find the \"lowest\" node which is &gt;= key. If key is nil, return either\n+   * nil or the first node, depending on the parameter first.\n+   * Package visible for use by nested classes.\n+   *\n+   * @param key the lower bound, inclusive\n+   * @param first true to return the first element instead of nil for nil key\n+   * @return the next node\n+   */\n+  final Node lowestGreaterThan(Object key, boolean first)\n   {\n     if (key == nil)\n-      return lastNode();\n-  \n+      return first ? firstNode() : nil;\n+\n     Node last = nil;\n     Node current = root;\n     int comparison = 0;\n@@ -734,122 +1086,176 @@ private Node highestLessThan(Object key)\n       {\n         last = current;\n         comparison = compare(key, current.key);\n-\tif (comparison > 0)\n-\t  current = current.right;\n-\telse if (comparison < 0)\n-\t  current = current.left;\n-\telse /* Exact match. */\n-\t  return predecessor(last);\n+        if (comparison > 0)\n+          current = current.right;\n+        else if (comparison < 0)\n+          current = current.left;\n+        else\n+          return current;\n       }\n-    if (comparison <= 0)\n-      return predecessor(last);\n-    else\n-      return last;\n+    return comparison > 0 ? successor(last) : last;\n   }\n \n-  // Find the \"lowest\" node which is >= key. If key is nil, return first node.\n-  private Node lowestGreaterThan(Object key)\n+  /**\n+   * Return the node preceding the given one, or nil if there isn't one.\n+   *\n+   * @param node the current node, not nil\n+   * @return the prior node in sorted order\n+   */\n+  private Node predecessor(Node node)\n   {\n-    if (key == nil)\n-      return firstNode();\n-\n-    Node last = nil;\n-    Node current = root;\n-    int comparison = 0;\n+    if (node.left != nil)\n+      {\n+        node = node.left;\n+        while (node.right != nil)\n+          node = node.right;\n+        return node;\n+      }\n \n-    while (current != nil)\n+    Node parent = node.parent;\n+    // Exploit fact that nil.left == nil and node is non-nil.\n+    while (node == parent.left)\n       {\n-        last = current;\n-        comparison = compare(key, current.key);\n-\tif (comparison > 0)\n-\t  current = current.right;\n-\telse if (comparison < 0)\n-\t  current = current.left;\n-\telse\n-\t  return current;\n+        node = parent;\n+        parent = node.parent;\n       }\n-    if (comparison > 0)\n-      return successor(last);\n-    else\n-      return last;\n-  }  \n+    return parent;\n+  }\n \n-  private void writeObject(ObjectOutputStream out) throws IOException\n+  /**\n+   * Construct a tree from sorted keys in linear time. Package visible for\n+   * use by TreeSet.\n+   *\n+   * @param s the stream to read from\n+   * @param count the number of keys to read\n+   * @param readValue true to read values, false to insert \"\" as the value\n+   * @throws ClassNotFoundException if the underlying stream fails\n+   * @throws IOException if the underlying stream fails\n+   * @see #readObject(ObjectInputStream)\n+   * @see TreeSet#readObject(ObjectInputStream)\n+   */\n+  final void putFromObjStream(ObjectInputStream s, int count,\n+                              boolean readValues)\n+    throws IOException, ClassNotFoundException\n   {\n-    out.defaultWriteObject();\n-\n+    fabricateTree(count);\n     Node node = firstNode();\n-    out.writeInt(size);\n-    \n-    while (node != nil)\n+\n+    while (--count >= 0)\n       {\n-        out.writeObject(node.key);\n-\tout.writeObject(node.value);\n-\tnode = successor(node);\n+        node.key = s.readObject();\n+        node.value = readValues ? s.readObject() : \"\";\n+        node = successor(node);\n       }\n   }\n \n-  private void readObject(ObjectInputStream in)\n-    throws IOException, ClassNotFoundException\n+  /**\n+   * Construct a tree from sorted keys in linear time, with values of \"\".\n+   * Package visible for use by TreeSet.\n+   *\n+   * @param keys the iterator over the sorted keys\n+   * @param count the number of nodes to insert\n+   * @see TreeSet#TreeSet(SortedSet)\n+   */\n+  final void putKeysLinear(Iterator keys, int count)\n   {\n-    in.defaultReadObject();\n-    int size = in.readInt();\n-    putFromObjStream(in, size, true);\n+    fabricateTree(count);\n+    Node node = firstNode();\n+\n+    while (--count >= 0)\n+      {\n+        node.key = keys.next();\n+        node.value = \"\";\n+        node = successor(node);\n+      }\n   }\n \n-  private int compare(Object o1, Object o2)\n+  /**\n+   * Deserializes this object from the given stream.\n+   *\n+   * @param s the stream to read from\n+   * @throws ClassNotFoundException if the underlying stream fails\n+   * @throws IOException if the underlying stream fails\n+   * @serialData the <i>size</i> (int), followed by key (Object) and value\n+   *             (Object) pairs in sorted order\n+   */\n+  private void readObject(ObjectInputStream s)\n+    throws IOException, ClassNotFoundException\n   {\n-    if (comparator == null)\n-      return ((Comparable) o1).compareTo(o2);\n-    else\n-      return comparator.compare(o1, o2);\n+    s.defaultReadObject();\n+    int size = s.readInt();\n+    putFromObjStream(s, size, true);\n   }\n \n-  /* Return the node following Node, or nil if there isn't one. */\n-  private Node successor(Node node)\n+  /**\n+   * Remove node from tree. This will increment modCount and decrement size.\n+   * Node must exist in the tree. Package visible for use by nested classes.\n+   *\n+   * @param node the node to remove\n+   */\n+  final void removeNode(Node node)\n   {\n-    if (node.right != nil)\n+    Node splice;\n+    Node child;\n+\n+    modCount++;\n+    size--;\n+\n+    // Find splice, the node at the position to actually remove from the tree.\n+    if (node.left == nil)\n       {\n-        node = node.right;\n-\twhile (node.left != nil)\n-\t  node = node.left;\n-\treturn node;\n+        // Node to be deleted has 0 or 1 children.\n+        splice = node;\n+        child = node.right;\n       }\n-\n-    Node parent = node.parent;\n-    while (parent != nil && node == parent.right)\n+    else if (node.right == nil)\n       {\n-\tnode = parent;\n-\tparent = parent.parent;\n+        // Node to be deleted has 1 child.\n+        splice = node;\n+        child = node.left;\n       }\n-    return parent;\n-  }\n-\n-  /* Return the node preceeding Node, or nil if there isn't one. */\n-  private Node predecessor(Node node)\n-  {\n-    if (node.left != nil)\n+    else\n       {\n-        node = node.left;\n-\twhile (node.right != nil)\n-\t  node = node.right;\n-\treturn node;\n+        // Node has 2 children. Splice is node's predecessor, and we swap\n+        // its contents into node.\n+        splice = node.left;\n+        while (splice.right != nil)\n+          splice = splice.right;\n+        child = splice.left;\n+        node.key = splice.key;\n+        node.value = splice.value;\n       }\n-      \n-    Node parent = node.parent;\n-    while (parent != nil && node == parent.left)\n+\n+    // Unlink splice from the tree.\n+    Node parent = splice.parent;\n+    if (child != nil)\n+      child.parent = parent;\n+    if (parent == nil)\n       {\n-\tnode = parent;\n-\tparent = parent.parent;\n+        // Special case for 0 or 1 node remaining.\n+        root = child;\n+        return;\n       }\n-    return parent;\n+    if (splice == parent.left)\n+      parent.left = child;\n+    else\n+      parent.right = child;\n+\n+    if (splice.color == BLACK)\n+      deleteFixup(child, parent);\n   }\n \n-  /** Rotate node n to the left. */\n+  /**\n+   * Rotate node n to the left.\n+   *\n+   * @param node the node to rotate\n+   */\n   private void rotateLeft(Node node)\n   {\n     Node child = node.right;\n-    \n+    // if (node == nil || child == nil)\n+    //   throw new InternalError();\n+\n     // Establish node.right link.\n     node.right = child.left;\n     if (child.left != nil)\n@@ -860,595 +1266,498 @@ private void rotateLeft(Node node)\n     if (node.parent != nil)\n       {\n         if (node == node.parent.left)\n-\t  node.parent.left = child;\n-\telse\n-\t  node.parent.right = child;\n+          node.parent.left = child;\n+        else\n+          node.parent.right = child;\n       }\n     else\n       root = child;\n \n     // Link n and child.\n     child.left = node;\n-    if (node != nil)\n-      node.parent = child;\n+    node.parent = child;\n   }\n \n-  /** Rotate node n to the right. */\n+  /**\n+   * Rotate node n to the right.\n+   *\n+   * @param node the node to rotate\n+   */\n   private void rotateRight(Node node)\n   {\n     Node child = node.left;\n-    \n+    // if (node == nil || child == nil)\n+    //   throw new InternalError();\n+\n     // Establish node.left link.\n     node.left = child.right;\n     if (child.right != nil)\n       child.right.parent = node;\n-      \n+\n     // Establish child->parent link.\n     child.parent = node.parent;\n     if (node.parent != nil)\n       {\n         if (node == node.parent.right)\n-\t  node.parent.right = child;\n-\telse\n-\t  node.parent.left = child;\n+          node.parent.right = child;\n+        else\n+          node.parent.left = child;\n       }\n     else\n       root = child;\n-    \n+\n     // Link n and child.\n     child.right = node;\n-    if (node != nil)\n-      node.parent = child;\n-  }\n-  \n-  /* Construct a tree from sorted keys in linear time. This is used to\n-     implement TreeSet's SortedSet constructor. */\n-  void putKeysLinear(Iterator keys, int count)\n-  {\n-    fabricateTree(count);    \n-    Node node = firstNode();\n-    \n-    for (int i = 0; i < count; i++)\n-      {\n-\tnode.key = keys.next();\n-\tnode.value = Boolean.TRUE;\n-\tnode = successor(node);\n-      }\n-  }\n-  \n-  /* As above, but load keys from an ObjectInputStream. Used by readObject()\n-     methods. If \"readValues\" is set, entry values will also be read from the \n-     stream. If not, only keys will be read. */\n-  void putFromObjStream(ObjectInputStream in, int count, boolean readValues) \n-    throws IOException, ClassNotFoundException\n-  {\n-    fabricateTree(count);    \n-    Node node = firstNode();\n-    \n-    for (int i = 0; i < count; i++)\n-      {\n-\tnode.key = in.readObject();\n-\tif (readValues)\n-\t  node.value = in.readObject();\n-\telse\n-\t  node.value = Boolean.TRUE;\t  \n-\tnode = successor(node);\n-      }\n-  }\n-     \n-  /* Construct a perfectly balanced tree consisting of n \"blank\" nodes. \n-     This permits a tree to be generated from pre-sorted input in linear \n-     time. */\n-  private void fabricateTree(int count)\n-  {\n-    if (count == 0)\n-      return;\n-    // Calculate the (maximum) depth of the perfectly balanced tree.\n-    double ddepth = (Math.log (count + 1) / Math.log (2));\n-    int maxdepth = (int) Math.ceil (ddepth);\n-    \n-    // The number of nodes which can fit in a perfectly-balanced tree of \n-    // height \"depth - 1\".\n-    int max = (int) Math.pow (2, maxdepth - 1) - 1;\n-    \n-    // Number of nodes which spill over into the deepest row of the tree.\n-    int overflow = (int) count - max;\n-    \n-    size = count;\n-    // Make the root node.\n-    root = new Node(null, null);\n-    root.parent = nil;\n-    root.left = nil;\n-    root.right = nil;\n-    \n-    Node row = root;\n-    for (int depth = 2; depth <= maxdepth; depth++)  // each row\n-      {\t\n-\t// Number of nodes at this depth\n-\tint rowcap = (int) Math.pow (2, depth - 1);\n-\tNode parent = row;\n-\tNode last = null;\n-\t\n-\t// Actual number of nodes to create in this row\n-\tint rowsize;\n-\tif (depth == maxdepth)\n-\t  rowsize = overflow;\n-\telse\n-\t  rowsize = rowcap;\n-\t\n-\t// The bottom most row of nodes is coloured red, as is every second row \n-\t// going up, except the root node (row 1). I'm not sure if this is the \n-\t// optimal configuration for the tree, but it seems logical enough.\n-\t// We just need to honour the black-height and red-parent rules here.\n-\tboolean colorRowRed = (depth % 2 == maxdepth % 2);\n-\t\n-\tint i;\n-\tfor (i = 1; i <= rowsize; i++)  // each node in row\n-\t  {\n-\t    Node node = new Node(null, null);\n-\t    node.parent = parent;\n-\t    if (i % 2 == 1)\n-\t      parent.left = node;\n-\t    else\n-\t      {\n-\t\tNode nextparent = parent.right;\n-\t\tparent.right = node;\n-\t\tparent = nextparent;\n-\t      }\n-\n-\t    // We use the \"right\" link to maintain a chain of nodes in \n-\t    // each row until the parent->child links are established.\n-\t    if (last != null)\n-\t      last.right = node;\n-\t    last = node;\n-\t    \n-\t    if (colorRowRed)\n-\t      node.color = RED;\n-\t    \n-\t    if (i == 1)\n-\t      row = node;\n-\t  }\n-\n-        // Set nil child pointers on leaf nodes.\n-\tif (depth == maxdepth)\n-\t  {\n-\t    // leaf nodes at maxdepth-1.\n-\t    if (parent != null)\n-\t      {\n-\t\tif (i % 2 == 0)\n-\t\t  {\n-\t            // Current \"parent\" has \"left\" set already.\n-\t\t    Node next = parent.right;\n-\t\t    parent.right = nil;\n-\t\t    parent = next;\n-\t\t  }\t\t  \t\t  \n-\t\twhile (parent != null)\n-\t\t  {\n-\t\t    parent.left = nil;\n-\t\t    Node next = parent.right;\n-\t\t    parent.right = nil;\n-\t\t    parent = next;\n-\t\t  }\n-\t      }\n-\t    // leaf nodes at maxdepth.\n-\t    Node node = row;\n-\t    Node next;\n-\t    while (node != null)\n-\t      {\n-\t        node.left = nil;\n-\t\tnext = node.right;\n-\t\tnode.right = nil;\n-\t\tnode = next;\n-\t      }\n-\t  }\n-      }\n-  }\n-  \n-  private class VerifyResult\n-  {\n-    int count; // Total number of nodes.\n-    int black; // Black height/depth.\n-    int maxdepth; // Maximum depth of branch.\n+    node.parent = child;\n   }\n \n-  /* Check that red-black properties are consistent for the tree. */\n-  private void verifyTree()\n-  {\n-    if (root == nil)\n-      {\n-        System.err.println (\"Verify: empty tree\");\n-\tif (size != 0)\n-\t  verifyError (this, \"no root node but size=\" + size);\n-\treturn;\n-      }\n-    VerifyResult vr = verifySub (root);\n-    if (vr.count != size)\n-      {\n-\tverifyError (this, \"Tree size not consistent with actual nodes counted. \"\n-                     + \"counted \" + vr.count + \", size=\" + size);\n-        System.exit(1);\n-      }\n-    System.err.println (\"Verify: \" + vr.count + \" nodes, black height=\" + vr.black\n-                        + \", maxdepth=\" + vr.maxdepth);\n-  }\n-  \n-  /* Recursive call to check that rbtree rules hold. Returns total node count\n-     and black height of the given branch. */\n-  private VerifyResult verifySub(Node n)\n+  /**\n+   * Return the node following the given one, or nil if there isn't one.\n+   * Package visible for use by nested classes.\n+   *\n+   * @param node the current node, not nil\n+   * @return the next node in sorted order\n+   */\n+  final Node successor(Node node)\n   {\n-    VerifyResult vr1 = null;\n-    VerifyResult vr2 = null;\n-    \n-    if (n.left == nil && n.right == nil)\n-      {\n-        // leaf node\n-\tVerifyResult r = new VerifyResult();\n-\tr.black = (n.color == BLACK ? 1 : 0);\n-\tr.count = 1;\n-\tr.maxdepth = 1;\n-\treturn r;\n-      }\n-    \n-    if (n.left != nil)\n+    if (node.right != nil)\n       {\n-        if (n.left.parent != n)\n-\t  verifyError(n.left, \"Node's parent link does not point to \" + n);\n-\t\n-\tif (n.color == RED && n.left.color == RED)\n-\t  verifyError(n, \"Red node has red left child\");\n-\t\n-\tvr1 = verifySub (n.left);\n-\tif (n.right == nil)\n-\t  {\n-\t    if (n.color == BLACK)\n-\t      vr1.black++;\n-\t    vr1.count++;\n-\t    vr1.maxdepth++;\n-\t    return vr1;\n-\t  }\n+        node = node.right;\n+        while (node.left != nil)\n+          node = node.left;\n+        return node;\n       }\n \n-    if (n.right != nil)\n+    Node parent = node.parent;\n+    // Exploit fact that nil.right == nil and node is non-nil.\n+    while (node == parent.right)\n       {\n-        if (n.right.parent != n)\n-\t  verifyError(n.right, \"Node's parent link does not point to \" + n);\n-\n-\tif (n.color == RED && n.right.color == RED)\n-\t  verifyError(n, \"Red node has red right child\");\n-\n-\tvr2 = verifySub (n.right);\n-\tif (n.left == nil)\n-\t  {\n-\t    if (n.color == BLACK)\n-\t      vr2.black++;\n-\t    vr2.count++;\n-\t    vr2.maxdepth++;\n-\t    return vr2;\n-\t  }\n+        node = parent;\n+        parent = parent.parent;\n       }\n-    \n-    if (vr1.black != vr2.black)\n-      verifyError (n, \"Black heights: \" + vr1.black + \",\" + vr2.black + \" don't match.\");\n-    vr1.count += vr2.count + 1;\n-    vr1.maxdepth = Math.max(vr1.maxdepth, vr2.maxdepth) + 1;\n-    if (n.color == BLACK)\n-      vr1.black++;\n-    return vr1;\n+    return parent;\n   }\n-  \n-  private void verifyError (Object obj, String msg)\n+\n+  /**\n+   * Serializes this object to the given stream.\n+   *\n+   * @param s the stream to write to\n+   * @throws IOException if the underlying stream fails\n+   * @serialData the <i>size</i> (int), followed by key (Object) and value\n+   *             (Object) pairs in sorted order\n+   */\n+  private void writeObject(ObjectOutputStream s) throws IOException\n   {\n-    System.err.print (\"Verify error: \");\n-    try\n-      {\n-        System.err.print (obj);\n-      }\n-    catch (Exception x)\n+    s.defaultWriteObject();\n+\n+    Node node = firstNode();\n+    s.writeInt(size);\n+    while (node != nil)\n       {\n-        System.err.print (\"(error printing obj): \" + x);\n+        s.writeObject(node.key);\n+        s.writeObject(node.value);\n+        node = successor(node);\n       }\n-    System.err.println();\n-    System.err.println (msg);\n-    Thread.dumpStack();\n-    System.exit(1);\n   }\n \n   /**\n-   * Iterate over HashMap's entries.\n-   * This implementation is parameterized to give a sequential view of\n-   * keys, values, or entries.\n-   */   \n-  class TreeIterator implements Iterator\n+   * Iterate over HashMap's entries. This implementation is parameterized\n+   * to give a sequential view of keys, values, or entries.\n+   *\n+   * @author Eric Blake <ebb9@email.byu.edu>\n+   */\n+  private final class TreeIterator implements Iterator\n   {\n-    static final int ENTRIES = 0,\n-                     KEYS = 1,\n-                     VALUES = 2;  \n-  \n-    // the type of this Iterator: KEYS, VALUES, or ENTRIES.\n-    int type;\n-    // the number of modifications to the backing Map that we know about.\n-    int knownMod = TreeMap.this.modCount;\n-    // The last Entry returned by a next() call.\n-    Node last;\n-    // The next entry that should be returned by next().\n-    Node next;\n-    // The last node visible to this iterator. This is used when iterating\n-    // on a SubMap.\n-    Node max;\n-\n-    /* Create Iterator with the supplied type: KEYS, VALUES, or ENTRIES */\n+    /**\n+     * The type of this Iterator: {@link #KEYS}, {@link #VALUES},\n+     * or {@link #ENTRIES}.\n+     */\n+    private final int type;\n+    /** The number of modifications to the backing Map that we know about. */\n+    private int knownMod = modCount;\n+    /** The last Entry returned by a next() call. */\n+    private Node last;\n+    /** The next entry that should be returned by next(). */\n+    private Node next;\n+    /**\n+     * The last node visible to this iterator. This is used when iterating\n+     * on a SubMap.\n+     */\n+    private final Node max;\n+\n+    /**\n+     * Construct a new TreeIterator with the supplied type.\n+     * @param type {@link #KEYS}, {@link #VALUES}, or {@link #ENTRIES}\n+     */\n     TreeIterator(int type)\n     {\n+      // FIXME gcj cannot handle this. Bug java/4695\n+      // this(type, firstNode(), nil);\n       this.type = type;\n       this.next = firstNode();\n+      this.max = nil;\n     }\n-    \n-    /* Construct an interator for a SubMap. Iteration will begin at node\n-       \"first\", and stop when \"max\" is reached. */    \n+\n+    /**\n+     * Construct a new TreeIterator with the supplied type. Iteration will\n+     * be from \"first\" (inclusive) to \"max\" (exclusive).\n+     *\n+     * @param type {@link #KEYS}, {@link #VALUES}, or {@link #ENTRIES}\n+     * @param first where to start iteration, nil for empty iterator\n+     * @param max the cutoff for iteration, nil for all remaining nodes\n+     */\n     TreeIterator(int type, Node first, Node max)\n     {\n       this.type = type;\n       this.next = first;\n       this.max = max;\n     }\n \n+    /**\n+     * Returns true if the Iterator has more elements.\n+     * @return true if there are more elements\n+     * @throws ConcurrentModificationException if the TreeMap was modified\n+     */\n     public boolean hasNext()\n     {\n-      if (knownMod != TreeMap.this.modCount)\n-\tthrow new ConcurrentModificationException();\n-      return (next != nil);\n+      if (knownMod != modCount)\n+        throw new ConcurrentModificationException();\n+      return next != max;\n     }\n \n+    /**\n+     * Returns the next element in the Iterator's sequential view.\n+     * @return the next element\n+     * @throws ConcurrentModificationException if the TreeMap was modified\n+     * @throws NoSuchElementException if there is none\n+     */\n     public Object next()\n     {\n-      if (next == nil)\n-\tthrow new NoSuchElementException();\n-      if (knownMod != TreeMap.this.modCount)\n-\tthrow new ConcurrentModificationException();\n-      Node n = next;\n-\n-      // Check limit in case we are iterating through a submap.\n-      if (n != max)\n-\tnext = successor(n);\n-      else\n-        next = nil;\n-      \n-      last = n;\n-      \n+      if (knownMod != modCount)\n+        throw new ConcurrentModificationException();\n+      if (next == max)\n+        throw new NoSuchElementException();\n+      last = next;\n+      next = successor(last);\n+\n       if (type == VALUES)\n-        return n.value;\n+        return last.value;\n       else if (type == KEYS)\n-        return n.key;\n-      return n;\n+        return last.key;\n+      return last;\n     }\n \n+    /**\n+     * Removes from the backing TreeMap the last element which was fetched\n+     * with the <code>next()</code> method.\n+     * @throws ConcurrentModificationException if the TreeMap was modified\n+     * @throws IllegalStateException if called when there is no last element\n+     */\n     public void remove()\n     {\n+      if (knownMod != modCount)\n+        throw new ConcurrentModificationException();\n       if (last == null)\n-\tthrow new IllegalStateException();\n-      if (knownMod != TreeMap.this.modCount)\n-\tthrow new ConcurrentModificationException();\n-/*\n-      Object key = null;\n-      if (next != nil)\n-        key = next.key;\n-*/\n-      TreeMap.this.removeNode(last);\n-      knownMod++;\n-/*\n-      if (key != null)\n-        next = getNode(key);\n-*/\t\n+        throw new IllegalStateException();\n+\n+      removeNode(last);\n       last = null;\n+      knownMod++;\n     }\n-  }\n+  } // class TreeIterator\n \n-  class SubMap extends AbstractMap implements SortedMap\n+  /**\n+   * Implementation of {@link #subMap(Object, Object)} and other map\n+   * ranges. This class provides a view of a portion of the original backing\n+   * map, and throws {@link IllegalArgumentException} for attempts to\n+   * access beyond that range.\n+   *\n+   * @author Eric Blake <ebb9@email.byu.edu>\n+   */\n+  private final class SubMap extends AbstractMap implements SortedMap\n   {\n-    Object minKey;\n-    Object maxKey;\n-\n-    /* Create a SubMap representing the elements between minKey and maxKey\n-       (inclusive). If minKey is nil, SubMap has no lower bound (headMap).\n-       If maxKey is nil, the SubMap has no upper bound (tailMap). */\n+    /**\n+     * The lower range of this view, inclusive, or nil for unbounded.\n+     * Package visible for use by nested classes.\n+     */\n+    final Object minKey;\n+\n+    /**\n+     * The upper range of this view, exclusive, or nil for unbounded.\n+     * Package visible for use by nested classes.\n+     */\n+    final Object maxKey;\n+\n+    /**\n+     * The cache for {@link #entrySet()}.\n+     */\n+    private Set entries;\n+\n+    /**\n+     * Create a SubMap representing the elements between minKey (inclusive)\n+     * and maxKey (exclusive). If minKey is nil, SubMap has no lower bound\n+     * (headMap). If maxKey is nil, the SubMap has no upper bound (tailMap).\n+     *\n+     * @param minKey the lower bound\n+     * @param maxKey the upper bound\n+     * @throws IllegalArgumentException if minKey &gt; maxKey\n+     */\n     SubMap(Object minKey, Object maxKey)\n     {\n+      if (minKey != nil && maxKey != nil && compare(minKey, maxKey) > 0)\n+        throw new IllegalArgumentException(\"fromKey > toKey\");\n       this.minKey = minKey;\n       this.maxKey = maxKey;\n     }\n \n+    /**\n+     * Check if \"key\" is in within the range bounds for this SubMap. The\n+     * lower (\"from\") SubMap range is inclusive, and the upper (\"to\") bound\n+     * is exclusive. Package visible for use by nested classes.\n+     *\n+     * @param key the key to check\n+     * @return true if the key is in range\n+     */\n+    final boolean keyInRange(Object key)\n+    {\n+      return ((minKey == nil || compare(key, minKey) >= 0)\n+              && (maxKey == nil || compare(key, maxKey) < 0));\n+    }\n+\n     public void clear()\n     {\n-      Node current;\n-      Node next = lowestGreaterThan(minKey);\n-      Node max = highestLessThan(maxKey);\n-      \n-      if (compare(next.key, max.key) > 0)\n-        // Nothing to delete.\n-\treturn;\n-        \n-      do\n+      Node next = lowestGreaterThan(minKey, true);\n+      Node max = lowestGreaterThan(maxKey, false);\n+      while (next != max)\n         {\n-\t  current = next;\n-\t  next = successor(current);\n-\t  remove(current);\n-\t}\n-      while (current != max);\n+          Node current = next;\n+          next = successor(current);\n+          removeNode(current);\n+        }\n     }\n-    \n-    /* Check if \"key\" is in within the range bounds for this SubMap. \n-       The lower (\"from\") SubMap range is inclusive, and the upper (to) bound\n-       is exclusive. */\n-    private boolean keyInRange(Object key)\n+\n+    public Comparator comparator()\n     {\n-      return ((minKey == nil || compare(key, minKey) >= 0)\n-\t      && (maxKey == nil || compare(key, maxKey) < 0));\n+      return comparator;\n     }\n \n     public boolean containsKey(Object key)\n     {\n-      return (keyInRange(key) && TreeMap.this.containsKey(key));\n+      return keyInRange(key) && TreeMap.this.containsKey(key);\n     }\n \n     public boolean containsValue(Object value)\n     {\n-      Node node = lowestGreaterThan(minKey);\n-      Node max = highestLessThan(maxKey);\n-      Object currentVal;\n-\n-      if (node == nil || max == nil || compare(node.key, max.key) > 0)\n-        // Nothing to search.\n-\treturn false;\n-\n-      while (true)\n-\t{\n-\t  currentVal = node.getValue();\n-          if (value == null ? currentVal == null : value.equals (currentVal))\n-\t    return true;\n-\t  if (node == max)\n-\t    return false;\n-\t  node = successor(node);\n-\t}\n+      Node node = lowestGreaterThan(minKey, true);\n+      Node max = lowestGreaterThan(maxKey, false);\n+      while (node != max)\n+        {\n+          if (equals(value, node.getValue()))\n+            return true;\n+          node = successor(node);\n+        }\n+      return false;\n     }\n \n-    public Object get(Object key)\n+    public Set entrySet()\n     {\n-      if (keyInRange(key))\n-\treturn TreeMap.this.get(key);\n-      return null;\n+      if (entries == null)\n+        // Create an AbstractSet with custom implementations of those methods\n+        // that can be overriden easily and efficiently.\n+        entries = new AbstractSet()\n+        {\n+          public int size()\n+          {\n+            return SubMap.this.size();\n+          }\n+\n+          public Iterator iterator()\n+          {\n+            Node first = lowestGreaterThan(minKey, true);\n+            Node max = lowestGreaterThan(maxKey, false);\n+            return new TreeIterator(ENTRIES, first, max);\n+          }\n+\n+          public void clear()\n+          {\n+            SubMap.this.clear();\n+          }\n+\n+          public boolean contains(Object o)\n+          {\n+            if (! (o instanceof Map.Entry))\n+              return false;\n+            Map.Entry me = (Map.Entry) o;\n+            Object key = me.getKey();\n+            if (! keyInRange(key))\n+              return false;\n+            Node n = getNode(key);\n+            return n != nil && AbstractSet.equals(me.getValue(), n.value);\n+          }\n+\n+          public boolean remove(Object o)\n+          {\n+            if (! (o instanceof Map.Entry))\n+              return false;\n+            Map.Entry me = (Map.Entry) o;\n+            Object key = me.getKey();\n+            if (! keyInRange(key))\n+              return false;\n+            Node n = getNode(key);\n+            if (n != nil && AbstractSet.equals(me.getValue(), n.value))\n+              {\n+                removeNode(n);\n+                return true;\n+              }\n+            return false;\n+          }\n+        };\n+      return entries;\n     }\n \n-    public Object put(Object key, Object value)\n+    public Object firstKey()\n     {\n-      if (keyInRange(key))\n-\treturn TreeMap.this.put(key, value);\n-      else\n-\tthrow new IllegalArgumentException(\"Key outside range\");\n+      Node node = lowestGreaterThan(minKey, true);\n+      if (node == nil || ! keyInRange(node.key))\n+        throw new NoSuchElementException();\n+      return node.key;\n     }\n \n-    public Object remove(Object key)\n+    public Object get(Object key)\n     {\n       if (keyInRange(key))\n-\treturn TreeMap.this.remove(key);\n-      else\n-        return null;\n+        return TreeMap.this.get(key);\n+      return null;\n     }\n \n-    public int size()\n+    public SortedMap headMap(Object toKey)\n     {\n-      Node node = lowestGreaterThan(minKey);\n-      Node max = highestLessThan(maxKey);\n-\n-      if (node == nil || max == nil || compare(node.key, max.key) > 0)\n-\treturn 0;  // Empty.\n+      if (! keyInRange(toKey))\n+        throw new IllegalArgumentException(\"key outside range\");\n+      return new SubMap(minKey, toKey);\n+    }\n \n-      int count = 1;\n-      while (node != max)\n+    public Set keySet()\n+    {\n+      if (this.keys == null)\n+        // Create an AbstractSet with custom implementations of those methods\n+        // that can be overriden easily and efficiently.\n+        this.keys = new AbstractSet()\n         {\n-\t  count++;\n-\t  node = successor(node);\n-\t}\n+          public int size()\n+          {\n+            return SubMap.this.size();\n+          }\n \n-      return count;\n+          public Iterator iterator()\n+          {\n+            Node first = lowestGreaterThan(minKey, true);\n+            Node max = lowestGreaterThan(maxKey, false);\n+            return new TreeIterator(KEYS, first, max);\n+          }\n+\n+          public void clear()\n+          {\n+            SubMap.this.clear();\n+          }\n+\n+          public boolean contains(Object o)\n+          {\n+            if (! keyInRange(o))\n+              return false;\n+            return getNode(o) != nil;\n+          }\n+\n+          public boolean remove(Object o)\n+          {\n+            if (! keyInRange(o))\n+              return false;\n+            Node n = getNode(o);\n+            if (n != nil)\n+              {\n+                removeNode(n);\n+                return true;\n+              }\n+            return false;\n+          }\n+        };\n+      return this.keys;\n     }\n \n-    public Set entrySet()\n+    public Object lastKey()\n     {\n-      // Create an AbstractSet with custom implementations of those methods that \n-      // can be overriden easily and efficiently.\n-      return new AbstractSet()\n-      {\n-\tpublic int size()\n-\t{\n-          return SubMap.this.size();\n-\t}\n-\n-\tpublic Iterator iterator()\n-\t{\n-\t  Node first = lowestGreaterThan(minKey);\n-\t  Node max = highestLessThan(maxKey);\n-          return new TreeIterator(TreeIterator.ENTRIES, first, max);\n-\t}\n-\n-\tpublic void clear()\n-\t{\n-          this.clear();\n-\t}\n-\n-\tpublic boolean contains(Object o)\n-\t{\n-          if (!(o instanceof Map.Entry))\n-\t    return false;\n-\t  Map.Entry me = (Map.Entry) o;\n-\t  Object key = me.getKey();\n-\t  if (!keyInRange(key))\n-\t    return false;\n-\t  Node n = getNode(key);\n-\t  return (n != nil && me.getValue().equals(n.value));\n-\t}\n-\n-\tpublic boolean remove(Object o)\n-\t{\n-          if (!(o instanceof Map.Entry))\n-\t    return false;\n-\t  Map.Entry me = (Map.Entry) o;\n-\t  Object key = me.getKey();\n-\t  if (!keyInRange(key))\n-\t    return false;\n-\t  Node n = getNode(key);\n-\t  if (n != nil && me.getValue().equals(n.value))\n-\t    {\n-\t      removeNode(n);\n-\t      return true;\n-\t    }\n-\t  return false;\n-\t}\n-      };    \n+      Node node = highestLessThan(maxKey);\n+      if (node == nil || ! keyInRange(node.key))\n+        throw new NoSuchElementException();\n+      return node.key;\n     }\n \n-    public Comparator comparator()\n+    public Object put(Object key, Object value)\n     {\n-      return comparator;\n+      if (! keyInRange(key))\n+        throw new IllegalArgumentException(\"Key outside range\");\n+      return TreeMap.this.put(key, value);\n     }\n \n-    public Object firstKey()\n+    public Object remove(Object key)\n     {\n-      Node node = lowestGreaterThan(minKey);\n-      if (node == nil || !keyInRange(node.key))\n-        throw new NoSuchElementException (\"empty\");\n-      return node.key;\n+      if (keyInRange(key))\n+        return TreeMap.this.remove(key);\n+      return null;\n     }\n \n-    public Object lastKey()\n+    public int size()\n     {\n-      Node node = highestLessThan(maxKey);\n-      if (node == nil || !keyInRange(node.key))\n-        throw new NoSuchElementException (\"empty\");\n-      return node.key;\n+      Node node = lowestGreaterThan(minKey, true);\n+      Node max = lowestGreaterThan(maxKey, false);\n+      int count = 0;\n+      while (node != max)\n+        {\n+          count++;\n+          node = successor(node);\n+        }\n+      return count;\n     }\n \n     public SortedMap subMap(Object fromKey, Object toKey)\n     {\n-      if (!keyInRange(fromKey) || !keyInRange(toKey))\n+      if (! keyInRange(fromKey) || ! keyInRange(toKey))\n         throw new IllegalArgumentException(\"key outside range\");\n-\n-      return TreeMap.this.subMap(fromKey, toKey);\n+      return new SubMap(fromKey, toKey);\n     }\n \n-    public SortedMap headMap(Object toKey)\n+    public SortedMap tailMap(Object fromKey)\n     {\n-      if (!keyInRange(toKey))\n+      if (! keyInRange(fromKey))\n         throw new IllegalArgumentException(\"key outside range\");\n-\n-      return TreeMap.this.subMap(minKey, toKey);\n+      return new SubMap(fromKey, maxKey);\n     }\n \n-    public SortedMap tailMap(Object fromKey)\n+    public Collection values()\n     {\n-      if (!keyInRange(fromKey))\n-        throw new IllegalArgumentException(\"key outside range\");\n+      if (this.values == null)\n+        // Create an AbstractCollection with custom implementations of those\n+        // methods that can be overriden easily and efficiently.\n+        this.values = new AbstractCollection()\n+        {\n+          public int size()\n+          {\n+            return SubMap.this.size();\n+          }\n \n-      return TreeMap.this.subMap(fromKey, maxKey);\n+          public Iterator iterator()\n+          {\n+            Node first = lowestGreaterThan(minKey, true);\n+            Node max = lowestGreaterThan(maxKey, false);\n+            return new TreeIterator(VALUES, first, max);\n+          }\n+\n+          public void clear()\n+          {\n+            SubMap.this.clear();\n+          }\n+        };\n+      return this.keys;\n     }\n-  }\n-}\n+  } // class SubMap  \n+} // class TreeMap"}, {"sha": "3d2ef3d24d190d3847f035f86467d91460bebcdb", "filename": "libjava/java/util/TreeSet.java", "status": "modified", "additions": 225, "deletions": 108, "changes": 333, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2Fjava%2Futil%2FTreeSet.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2Fjava%2Futil%2FTreeSet.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FTreeSet.java?ref=d9fd7154ec7908eff8bbbce75651eccf51064ac1", "patch": "@@ -1,4 +1,4 @@\n-/* TreeSet.java -- a class providing a TreeMap-backet SortedSet\n+/* TreeSet.java -- a class providing a TreeMap-backed SortedSet\n    Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -33,54 +33,91 @@\n import java.io.ObjectOutputStream;\n \n /**\n- * This class provides a TreeMap-backed implementation of the \n- * SortedSet interface.\n+ * This class provides a TreeMap-backed implementation of the SortedSet\n+ * interface. The elements will be sorted according to their <i>natural\n+ * order</i>, or according to the provided <code>Comparator</code>.<p>\n  *\n- * Each element in the Set is a key in the backing TreeMap; each key\n- * maps to a static token, denoting that the key does, in fact, exist.\n+ * Most operations are O(log n), but there is so much overhead that this\n+ * makes small sets expensive. Note that the ordering must be <i>consistent\n+ * with equals</i> to correctly implement the Set interface. If this\n+ * condition is violated, the set is still well-behaved, but you may have\n+ * suprising results when comparing it to other sets.<p>\n  *\n- * Most operations are O(log n).\n+ * This implementation is not synchronized. If you need to share this between\n+ * multiple threads, do something like:<br>\n+ * <code>SortedSet s\n+ *       = Collections.synchronizedSortedSet(new TreeSet(...));</code><p>\n  *\n- * TreeSet is a part of the JDK1.2 Collections API.\n+ * The iterators are <i>fail-fast</i>, meaning that any structural\n+ * modification, except for <code>remove()</code> called on the iterator\n+ * itself, cause the iterator to throw a\n+ * <code>ConcurrentModificationException</code> rather than exhibit\n+ * non-deterministic behavior.\n  *\n- * @author      Jon Zeppieri\n+ * @author Jon Zeppieri\n+ * @author Bryce McKinlay\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @see Collection\n+ * @see Set\n+ * @see HashSet\n+ * @see LinkedHashSet\n+ * @see Comparable\n+ * @see Comparator\n+ * @see Collections#synchronizedSortedSet(SortedSet)\n+ * @see TreeMap\n+ * @since 1.2\n+ * @status updated to 1.4\n  */\n-\n public class TreeSet extends AbstractSet\n   implements SortedSet, Cloneable, Serializable\n {\n-  /** The TreeMap which backs this Set */\n-  transient SortedMap map;\n+  /**\n+   * Compatible with JDK 1.2.\n+   */\n+  private static final long serialVersionUID = -2479143000061671589L;\n \n-  static final long serialVersionUID = -2479143000061671589L;\n+  /**\n+   * The SortedMap which backs this Set.\n+   */\n+  // Not final because of readObject. This will always be one of TreeMap or\n+  // TreeMap.SubMap, which both extend AbstractMap.\n+  private transient SortedMap map;\n \n   /**\n-   * Construct a new TreeSet whose backing TreeMap using the \"natural\" \n-   * ordering of keys.\n+   * Construct a new TreeSet whose backing TreeMap using the \"natural\"\n+   * ordering of keys. Elements that are not mutually comparable will cause\n+   * ClassCastExceptions down the road.\n+   *\n+   * @see Comparable\n    */\n   public TreeSet()\n   {\n     map = new TreeMap();\n   }\n \n-  /** \n-   * Construct a new TreeSet whose backing TreeMap uses the supplied \n-   * Comparator.\n+  /**\n+   * Construct a new TreeSet whose backing TreeMap uses the supplied\n+   * Comparator. Elements that are not mutually comparable will cause\n+   * ClassCastExceptions down the road.\n    *\n-   * @param     oComparator      the Comparator this Set will use\n+   * @param comparator the Comparator this Set will use\n    */\n   public TreeSet(Comparator comparator)\n   {\n     map = new TreeMap(comparator);\n   }\n \n-  /** \n+  /**\n    * Construct a new TreeSet whose backing TreeMap uses the \"natural\"\n    * orering of the keys and which contains all of the elements in the\n-   * supplied Collection.\n+   * supplied Collection. This runs in n*log(n) time.\n    *\n-   * @param     oCollection      the new Set will be initialized with all\n-   *                             of the elements in this Collection\n+   * @param collection the new Set will be initialized with all\n+   *        of the elements in this Collection\n+   * @throws ClassCastException if the elements of the collection are not\n+   *         comparable\n+   * @throws NullPointerException if the collection is null\n+   * @see Comparable\n    */\n   public TreeSet(Collection collection)\n   {\n@@ -93,54 +130,57 @@ public TreeSet(Collection collection)\n    * SortedSet and containing all of the elements in the supplied SortedSet.\n    * This constructor runs in linear time.\n    *\n-   * @param     sortedSet       the new TreeSet will use this SortedSet's\n-   *                            comparator and will initialize itself\n-   *                            with all of the elements in this SortedSet\n+   * @param sortedSet the new TreeSet will use this SortedSet's comparator\n+   *        and will initialize itself with all its elements\n+   * @throws NullPointerException if sortedSet is null\n    */\n   public TreeSet(SortedSet sortedSet)\n   {\n-    TreeMap map = new TreeMap(sortedSet.comparator());\n-    int i = 0;\n+    map = new TreeMap(sortedSet.comparator());\n     Iterator itr = sortedSet.iterator();\n-    map.putKeysLinear(itr, sortedSet.size());\n-    this.map = map;\n+    ((TreeMap) map).putKeysLinear(itr, sortedSet.size());\n   }\n-  \n-  /* This private constructor is used to implement the subSet() calls around\n-    a backing TreeMap.SubMap. */\n-  TreeSet(SortedMap backingMap)\n+\n+  /**\n+   * This private constructor is used to implement the subSet() calls around\n+   * a backing TreeMap.SubMap.\n+   *\n+   * @param backingMap the submap\n+   */\n+  private TreeSet(SortedMap backingMap)\n   {\n     map = backingMap;\n   }\n \n-  /** \n+  /**\n    * Adds the spplied Object to the Set if it is not already in the Set;\n-   * returns true if the element is added, false otherwise\n+   * returns true if the element is added, false otherwise.\n    *\n-   * @param       obj       the Object to be added to this Set\n+   * @param obj the Object to be added to this Set\n+   * @throws ClassCastException if the element cannot be compared with objects\n+   *         already in the set\n    */\n   public boolean add(Object obj)\n   {\n-    return (map.put(obj, Boolean.TRUE) == null);\n+    return map.put(obj, \"\") == null;\n   }\n \n   /**\n    * Adds all of the elements in the supplied Collection to this TreeSet.\n    *\n-   * @param        c         All of the elements in this Collection\n-   *                         will be added to the Set.\n-   *\n-   * @return       true if the Set is altered, false otherwise\n+   * @param c The collection to add\n+   * @return true if the Set is altered, false otherwise\n+   * @throws NullPointerException if c is null\n+   * @throws ClassCastException if an element in c cannot be compared with\n+   *         objects already in the set\n    */\n   public boolean addAll(Collection c)\n   {\n     boolean result = false;\n-    int size = c.size();\n+    int pos = c.size();\n     Iterator itr = c.iterator();\n-\n-    for (int i = 0; i < size; i++)\n-      result |= (map.put(itr.next(), Boolean.TRUE) == null);\n-\n+    while (--pos >= 0)\n+      result |= (map.put(itr.next(), \"\") == null);\n     return result;\n   }\n \n@@ -152,137 +192,214 @@ public void clear()\n     map.clear();\n   }\n \n-  /** Returns a shallow copy of this Set. */\n+  /**\n+   * Returns a shallow copy of this Set. The elements are not cloned.\n+   *\n+   * @return the cloned set\n+   */\n   public Object clone()\n   {\n     TreeSet copy = null;\n     try\n       {\n         copy = (TreeSet) super.clone();\n+        // Map may be either TreeMap or TreeMap.SubMap, hence the ugly casts.\n+        copy.map = (SortedMap) ((AbstractMap) map).clone();\n       }\n     catch (CloneNotSupportedException x)\n-      {      \n+      {\n+        // Impossible result.\n       }\n-    copy.map = (SortedMap) ((TreeMap) map).clone();\n     return copy;\n   }\n \n-  /** Returns this Set's comparator */\n+  /**\n+   * Returns this Set's comparator.\n+   *\n+   * @return the comparator, or null if the set uses natural ordering\n+   */\n   public Comparator comparator()\n   {\n     return map.comparator();\n   }\n \n-  /** \n-   * Returns true if this Set contains the supplied Object, \n-   * false otherwise \n+  /**\n+   * Returns true if this Set contains the supplied Object, false otherwise.\n    *\n-   * @param       oObject        the Object whose existence in the Set is\n-   *                             being tested\n+   * @param obj the Object to check for\n+   * @return true if it is in the set\n+   * @throws ClassCastException if obj cannot be compared with objects\n+   *         already in the set\n    */\n   public boolean contains(Object obj)\n   {\n     return map.containsKey(obj);\n   }\n \n-  /** Returns true if this Set has size 0, false otherwise */\n-  public boolean isEmpty()\n+  /**\n+   * Returns the first (by order) element in this Set.\n+   *\n+   * @return the first element\n+   * @throws NoSuchElementException if the set is empty\n+   */\n+  public Object first()\n   {\n-    return map.isEmpty();\n+    return map.firstKey();\n   }\n \n-  /** Returns the number of elements in this Set */\n-  public int size()\n+  /**\n+   * Returns a view of this Set including all elements less than\n+   * <code>to</code>. The returned set is backed by the original, so changes\n+   * in one appear in the other. The subset will throw an\n+   * {@link IllegalArgumentException} for any attempt to access or add an\n+   * element beyond the specified cutoff. The returned set does not include\n+   * the endpoint; if you want inclusion, pass the successor element.\n+   *\n+   * @param to the (exclusive) cutoff point\n+   * @return a view of the set less than the cutoff\n+   * @throws ClassCastException if <code>to</code> is not compatible with\n+   *         the comparator (or is not Comparable, for natural ordering)\n+   * @throws NullPointerException if to is null, but the comparator does not\n+   *         tolerate null elements\n+   */\n+  public SortedSet headSet(Object to)\n   {\n-    return map.size();\n+    return new TreeSet(map.headMap(to));\n   }\n \n-  /** \n-   * If the supplied Object is in this Set, it is removed, and true is\n-   * returned; otherwise, false is returned.\n+  /**\n+   * Returns true if this Set has size 0, false otherwise.\n    *\n-   * @param         obj        the Object we are attempting to remove\n-   *                           from this Set\n+   * @return true if the set is empty\n    */\n-  public boolean remove(Object obj)\n+  public boolean isEmpty()\n   {\n-    return (map.remove(obj) != null);\n+    return map.isEmpty();\n   }\n \n-  /** Returns the first (by order) element in this Set */\n-  public Object first()\n+  /**\n+   * Returns in Iterator over the elements in this TreeSet, which traverses\n+   * in ascending order.\n+   *\n+   * @return an iterator\n+   */\n+  public Iterator iterator()\n   {\n-    return map.firstKey();\n+    return map.keySet().iterator();\n   }\n \n-  /** Returns the last (by order) element in this Set */\n+  /**\n+   * Returns the last (by order) element in this Set.\n+   *\n+   * @return the last element\n+   * @throws NoSuchElementException if the set is empty\n+   */\n   public Object last()\n   {\n     return map.lastKey();\n   }\n \n   /**\n-   * Returns a view of this Set including all elements in the interval\n-   * [oFromElement, oToElement).\n+   * If the supplied Object is in this Set, it is removed, and true is\n+   * returned; otherwise, false is returned.\n    *\n-   * @param       from  the resultant view will contain all\n-   *                    elements greater than or equal to this element\n-   * @param       to    the resultant view will contain all\n-   *                    elements less than this element\n+   * @param obj the Object to remove from this Set\n+   * @return true if the set was modified\n+   * @throws ClassCastException if obj cannot be compared to set elements\n    */\n-  public SortedSet subSet(Object from, Object to)\n+  public boolean remove(Object obj)\n   {\n-    return new TreeSet(map.subMap(from, to));\n+    return map.remove(obj) != null;\n   }\n \n   /**\n-   * Returns a view of this Set including all elements less than oToElement\n+   * Returns the number of elements in this Set\n    *\n-   * @param       toElement    the resultant view will contain all\n-   *                            elements less than this element\n+   * @return the set size\n    */\n-  public SortedSet headSet(Object to)\n+  public int size()\n   {\n-    return new TreeSet(map.headMap(to));\n+    return map.size();\n   }\n \n   /**\n-   * Returns a view of this Set including all elements greater than or\n-   * equal to oFromElement.\n+   * Returns a view of this Set including all elements greater or equal to\n+   * <code>from</code> and less than <code>to</code> (a half-open interval).\n+   * The returned set is backed by the original, so changes in one appear in\n+   * the other. The subset will throw an {@link IllegalArgumentException}\n+   * for any attempt to access or add an element beyond the specified cutoffs.\n+   * The returned set includes the low endpoint but not the high; if you want\n+   * to reverse this behavior on either end, pass in the successor element.\n    *\n-   * @param       from  the resultant view will contain all\n-   *              elements greater than or equal to this element\n+   * @param from the (inclusive) low cutoff point\n+   * @param to the (exclusive) high cutoff point\n+   * @return a view of the set between the cutoffs\n+   * @throws ClassCastException if either cutoff is not compatible with\n+   *         the comparator (or is not Comparable, for natural ordering)\n+   * @throws NullPointerException if from or to is null, but the comparator\n+   *         does not tolerate null elements\n+   * @throws IllegalArgumentException if from is greater than to\n    */\n-  public SortedSet tailSet(Object from)\n+  public SortedSet subSet(Object from, Object to)\n   {\n-    return new TreeSet(map.tailMap(from));\n+    return new TreeSet(map.subMap(from, to));\n   }\n \n-  /** Returns in Iterator over the elements in this TreeSet */\n-  public Iterator iterator()\n+  /**\n+   * Returns a view of this Set including all elements greater or equal to\n+   * <code>from</code>. The returned set is backed by the original, so\n+   * changes in one appear in the other. The subset will throw an\n+   * {@link IllegalArgumentException} for any attempt to access or add an\n+   * element beyond the specified cutoff. The returned set includes the\n+   * endpoint; if you want to exclude it, pass in the successor element.\n+   *\n+   * @param from the (inclusive) low cutoff point\n+   * @return a view of the set above the cutoff\n+   * @throws ClassCastException if <code>from</code> is not compatible with\n+   *         the comparator (or is not Comparable, for natural ordering)\n+   * @throws NullPointerException if from is null, but the comparator\n+   *         does not tolerate null elements\n+   */\n+  public SortedSet tailSet(Object from)\n   {\n-    return map.keySet().iterator();\n+    return new TreeSet(map.tailMap(from));\n   }\n \n-  private void writeObject(ObjectOutputStream out) throws IOException\n+  /**\n+   * Serializes this object to the given stream.\n+   *\n+   * @param s the stream to write to\n+   * @throws IOException if the underlying stream fails\n+   * @serialData the <i>comparator</i> (Object), followed by the set size\n+   *             (int), the the elements in sorted order (Object)\n+   */\n+  private void writeObject(ObjectOutputStream s) throws IOException\n   {\n+    s.defaultWriteObject();\n     Iterator itr = map.keySet().iterator();\n-    int size = map.size();\n-\n-    out.writeObject(map.comparator());\n-    out.writeInt(size);\n-\n-    for (int i = 0; i < size; i++)\n-      out.writeObject(itr.next());\n+    int pos = map.size();\n+    s.writeObject(map.comparator());\n+    s.writeInt(pos);\n+    while (--pos >= 0)\n+      s.writeObject(itr.next());\n   }\n \n-  private void readObject(ObjectInputStream in)\n+  /**\n+   * Deserializes this object from the given stream.\n+   *\n+   * @param s the stream to read from\n+   * @throws ClassNotFoundException if the underlying stream fails\n+   * @throws IOException if the underlying stream fails\n+   * @serialData the <i>comparator</i> (Object), followed by the set size\n+   *             (int), the the elements in sorted order (Object)\n+   */\n+  private void readObject(ObjectInputStream s)\n     throws IOException, ClassNotFoundException\n   {\n-    Comparator comparator = (Comparator) in.readObject();\n-    int size = in.readInt();\n-    TreeMap map = new TreeMap(comparator);    \n-    map.putFromObjStream(in, size, false);\n-    this.map = map;\n+    s.defaultReadObject();\n+    Comparator comparator = (Comparator) s.readObject();\n+    int size = s.readInt();\n+    map = new TreeMap(comparator);\n+    ((TreeMap) map).putFromObjStream(s, size, false);\n   }\n }"}, {"sha": "24d80f8ca8fcf6e0977456ee96e62511c77fe1f9", "filename": "libjava/java/util/Vector.java", "status": "modified", "additions": 475, "deletions": 349, "changes": 824, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2Fjava%2Futil%2FVector.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2Fjava%2Futil%2FVector.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FVector.java?ref=d9fd7154ec7908eff8bbbce75651eccf51064ac1", "patch": "@@ -1,5 +1,5 @@\n /* Vector.java -- Class that provides growable arrays.\n-   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -30,88 +30,105 @@\n import java.io.Serializable;\n \n /**\n- * the <b>Vector</b> classes implements growable arrays of Objects.\n+ * The <code>Vector</code> classes implements growable arrays of Objects.\n  * You can access elements in a Vector with an index, just as you\n  * can in a built in array, but Vectors can grow and shrink to accommodate\n- * more or fewer objects.  \n+ * more or fewer objects.<p>\n  *\n  * Vectors try to mantain efficiency in growing by having a\n- * <b>capacityIncrement</b> that can be specified at instantiation.\n+ * <code>capacityIncrement</code> that can be specified at instantiation.\n  * When a Vector can no longer hold a new Object, it grows by the amount\n- * in <b>capacityIncrement</b>.  \n+ * in <code>capacityIncrement</code>. If this value is 0, the vector doubles in\n+ * size.<p>\n  *\n- * Vector implements the JDK 1.2 List interface, and is therefor a fully\n- * compliant Collection object.\n+ * Vector implements the JDK 1.2 List interface, and is therefore a fully\n+ * compliant Collection object. The iterators are fail-fast - if external\n+ * code structurally modifies the vector, any operation on the iterator will\n+ * then throw a {@link ConcurrentModificationException}. The Vector class is\n+ * fully synchronized, but the iterators are not. So, when iterating over a\n+ * vector, be sure to synchronize on the vector itself.  If you don't want the\n+ * expense of synchronization, use ArrayList instead. On the other hand, the\n+ * Enumeration of elements() is not thread-safe, nor is it fail-fast; so it\n+ * can lead to undefined behavior even in a single thread if you modify the\n+ * vector during iteration.<p>\n+ *\n+ * Note: Some methods, especially those specified by List, specify throwing\n+ * {@link IndexOutOfBoundsException}, but it is easier to implement by\n+ * throwing the subclass {@link ArrayIndexOutOfBoundsException}. Others\n+ * directly specify this subclass.\n  *\n- * @specnote The JCL claims that various methods in this class throw\n- * IndexOutOfBoundsException, which would be consistent with other collections\n- * classes. ArrayIndexOutOfBoundsException is actually thrown, per the online \n- * docs, even for List method implementations.\n- * \n  * @author Scott G. Miller\n+ * @author Bryce McKinlay\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @see Collection\n+ * @see List\n+ * @see ArrayList\n+ * @see LinkedList\n+ * @since 1.0\n+ * @status updated to 1.4\n  */\n-public class Vector extends AbstractList \n-  implements List, Cloneable, Serializable\n+public class Vector extends AbstractList\n+  implements List, RandomAccess, Cloneable, Serializable\n {\n   /**\n-   * The amount the Vector's internal array should be increased in size when\n-   * a new element is added that exceeds the current size of the array,\n-   * or when {@link #ensureCapacity} is called.\n-   * @serial\n+   * Compatible with JDK 1.0+.\n    */\n-  protected int capacityIncrement = 0;\n+  private static final long serialVersionUID = -2767605614048989439L;\n+\n+  /**\n+   * The internal array used to hold members of a Vector. The elements are\n+   * in positions 0 through elementCount - 1, and all remaining slots are null.\n+   * @serial the elements\n+   */\n+  protected Object[] elementData;\n \n   /**\n    * The number of elements currently in the vector, also returned by\n    * {@link #size}.\n-   * @serial\n+   * @serial the size\n    */\n-  protected int elementCount = 0;\n+  protected int elementCount;\n \n   /**\n-   * The internal array used to hold members of a Vector\n-   * @serial\n+   * The amount the Vector's internal array should be increased in size when\n+   * a new element is added that exceeds the current size of the array,\n+   * or when {@link #ensureCapacity} is called. If &lt;= 0, the vector just\n+   * doubles in size.\n+   * @serial the amount to grow the vector by\n    */\n-  protected Object[] elementData;\n-\n-  private static final long serialVersionUID = -2767605614048989439L;\n+  protected int capacityIncrement;\n \n   /**\n    * Constructs an empty vector with an initial size of 10, and\n    * a capacity increment of 0\n    */\n   public Vector()\n   {\n-    this(10);\n+    this(10, 0);\n   }\n \n   /**\n    * Constructs a vector containing the contents of Collection, in the\n-   * order given by the collection\n+   * order given by the collection.\n    *\n-   * @param c A collection of elements to be added to the newly constructed\n-   * vector\n+   * @param c collection of elements to add to the new vector\n+   * @throws NullPointerException if c is null\n+   * @since 1.2\n    */\n   public Vector(Collection c)\n   {\n-    int csize = c.size();\n-    elementData = new Object[csize];\n-    elementCount = csize;\n-    Iterator itr = c.iterator();\n-    for (int i = 0; i < csize; i++)\n-      {\n-\telementData[i] = itr.next();\n-      }\n+    elementCount = c.size();\n+    elementData = c.toArray(new Object[elementCount]);\n   }\n \n   /**\n-   * Constructs a Vector with the initial capacity and capacity \n-   * increment specified\n+   * Constructs a Vector with the initial capacity and capacity\n+   * increment specified.\n    *\n-   * @param initialCapacity The initial size of the Vector's internal\n-   * array\n-   * @param capacityIncrement The amount the internal array should be\n-   * increased if necessary\n+   * @param initialCapacity the initial size of the Vector's internal array\n+   * @param capacityIncrement the amount the internal array should be\n+   *        increased by when necessary, 0 to double the size\n+   * @throws IllegalArgumentException if initialCapacity &lt; 0\n    */\n   public Vector(int initialCapacity, int capacityIncrement)\n   {\n@@ -122,37 +139,37 @@ public Vector(int initialCapacity, int capacityIncrement)\n   }\n \n   /**\n-   * Constructs a Vector with the initial capacity specified\n+   * Constructs a Vector with the initial capacity specified, and a capacity\n+   * increment of 0 (double in size).\n    *\n-   * @param initialCapacity The initial size of the Vector's internal array\n+   * @param initialCapacity the initial size of the Vector's internal array\n+   * @throws IllegalArgumentException if initialCapacity &lt; 0\n    */\n   public Vector(int initialCapacity)\n   {\n-    if (initialCapacity < 0)\n-      throw new IllegalArgumentException();\n-    elementData = new Object[initialCapacity];\n+    this(initialCapacity, 0);\n   }\n \n   /**\n-   * Copies the contents of a provided array into the Vector.  If the \n-   * array is too large to fit in the Vector, an ArrayIndexOutOfBoundsException\n-   * is thrown.  Old elements in the Vector are overwritten by the new\n-   * elements\n+   * Copies the contents of a provided array into the Vector.  If the\n+   * array is too large to fit in the Vector, an IndexOutOfBoundsException\n+   * is thrown without modifying the array.  Old elements in the Vector are\n+   * overwritten by the new elements.\n    *\n-   * @param anArray An array from which elements will be copied into the Vector\n-   * \n-   * @throws ArrayIndexOutOfBoundsException the array being copied\n-   * is larger than the Vectors internal data array\n+   * @param a target array for the copy\n+   * @throws IndexOutOfBoundsException the array is not large enough\n+   * @throws NullPointerException the array is null\n+   * @see #toArray(Object[])\n    */\n-  public synchronized void copyInto(Object[] anArray)\n+  public synchronized void copyInto(Object[] a)\n   {\n-    System.arraycopy(elementData, 0, anArray, 0, elementCount);\n+    System.arraycopy(elementData, 0, a, 0, elementCount);\n   }\n \n   /**\n    * Trims the Vector down to size.  If the internal data array is larger\n    * than the number of Objects its holding, a new array is constructed\n-   * that precisely holds the elements.  \n+   * that precisely holds the elements. Otherwise this does nothing.\n    */\n   public synchronized void trimToSize()\n   {\n@@ -166,295 +183,279 @@ public synchronized void trimToSize()\n   }\n \n   /**\n-   * Ensures that <b>minCapacity</b> elements can fit within this Vector.\n-   * If it cannot hold this many elements, the internal data array is expanded\n-   * in the following manner.  If the current size plus the capacityIncrement\n-   * is sufficient, the internal array is expanded by capacityIncrement.  \n-   * If capacityIncrement is non-positive, the size is doubled.  If \n-   * neither is sufficient, the internal array is expanded to size minCapacity\n+   * Ensures that <code>minCapacity</code> elements can fit within this Vector.\n+   * If <code>elementData</code> is too small, it is expanded as follows:\n+   * If the <code>elementCount + capacityIncrement</code> is adequate, that\n+   * is the new size. If <code>capacityIncrement</code> is non-zero, the\n+   * candidate size is double the current. If that is not enough, the new\n+   * size is <code>minCapacity</code>.\n    *\n-   * @param minCapacity The minimum capacity the internal array should be\n-   * able to handle after executing this method\n+   * @param minCapacity the desired minimum capacity, negative values ignored\n    */\n   public synchronized void ensureCapacity(int minCapacity)\n   {\n     if (elementData.length >= minCapacity)\n       return;\n \n-    int newCapacity; \n+    int newCapacity;\n     if (capacityIncrement <= 0)\n       newCapacity = elementData.length * 2;\n     else\n       newCapacity = elementData.length + capacityIncrement;\n-      \n+\n     Object[] newArray = new Object[Math.max(newCapacity, minCapacity)];\n \n-    System.arraycopy(elementData, 0, newArray, 0, elementData.length);\n+    System.arraycopy(elementData, 0, newArray, 0, elementCount);\n     elementData = newArray;\n   }\n \n   /**\n-   * Explicitly sets the size of the internal data array, copying the \n-   * old values to the new internal array.  If the new array is smaller\n-   * than the old one, old values that don't fit are lost. If the new size\n-   * is larger than the old one, the vector is padded with null entries.\n+   * Explicitly sets the size of the vector (but not necessarily the size of\n+   * the internal data array). If the new size is smaller than the old one,\n+   * old values that don't fit are lost. If the new size is larger than the\n+   * old one, the vector is padded with null entries.\n    *\n    * @param newSize The new size of the internal array\n+   * @throws ArrayIndexOutOfBoundsException if the new size is negative\n    */\n   public synchronized void setSize(int newSize)\n   {\n+    // Don't bother checking for the case where size() == the capacity of the\n+    // vector since that is a much less likely case; it's more efficient to\n+    // not do the check and lose a bit of performance in that infrequent case\n     modCount++;\n-    Object[] newArray = new Object[newSize];\n-    System.arraycopy(elementData, 0, newArray, 0, \n-                     Math.min(newSize, elementCount));\n+    ensureCapacity(newSize);\n+    if (newSize < elementCount)\n+      Arrays.fill(elementData, newSize, elementCount, null);\n     elementCount = newSize;\n-    elementData = newArray;\n   }\n \n   /**\n    * Returns the size of the internal data array (not the amount of elements\n-   * contained in the Vector)\n+   * contained in the Vector).\n    *\n-   * @returns capacity of the internal data array\n+   * @return capacity of the internal data array\n    */\n-  public int capacity()\n+  public synchronized int capacity()\n   {\n     return elementData.length;\n   }\n \n   /**\n-   * Returns the number of elements stored in this Vector\n+   * Returns the number of elements stored in this Vector.\n    *\n-   * @returns the number of elements in this Vector\n+   * @return the number of elements in this Vector\n    */\n-  public int size()\n+  public synchronized int size()\n   {\n     return elementCount;\n   }\n \n   /**\n    * Returns true if this Vector is empty, false otherwise\n    *\n-   * @returns true if the Vector is empty, false otherwise\n+   * @return true if the Vector is empty, false otherwise\n    */\n-  public boolean isEmpty()\n+  public synchronized boolean isEmpty()\n   {\n     return elementCount == 0;\n   }\n \n   /**\n-   * Searches the vector starting at <b>index</b> for object <b>elem</b>\n-   * and returns the index of the first occurrence of this Object.  If\n-   * the object is not found, -1 is returned\n+   * Returns an Enumeration of the elements of this Vector. The enumeration\n+   * visits the elements in increasing index order, but is NOT thread-safe.\n    *\n-   * @param e The Object to search for\n-   * @param index Start searching at this index\n-   * @returns The index of the first occurrence of <b>elem</b>, or -1\n-   * if it is not found\n+   * @return an Enumeration\n+   * @see #iterator()\n    */\n-  public synchronized int indexOf(Object e, int index)\n+  // No need to synchronize as the Enumeration is not thread-safe!\n+  public Enumeration elements()\n   {\n-    for (int i = index; i < elementCount; i++)\n+    return new Enumeration()\n+    {\n+      private int i = 0;\n+\n+      public boolean hasMoreElements()\n       {\n-\tif (e == null ? elementData[i] == null : e.equals(elementData[i]))\n-\t  return i;\n+        return i < elementCount;\n       }\n-    return -1;\n+\n+      public Object nextElement()\n+      {\n+        if (i >= elementCount)\n+          throw new NoSuchElementException();\n+        return elementData[i++];\n+      }\n+    };\n   }\n \n   /**\n-   * Returns the first occurrence of <b>elem</b> in the Vector, or -1 if\n-   * <b>elem</b> is not found.\n+   * Returns true when <code>elem</code> is contained in this Vector.\n    *\n-   * @param elem The object to search for\n-   * @returns The index of the first occurrence of <b>elem</b> or -1 if \n-   * not found\n+   * @param elem the element to check\n+   * @return true if the object is contained in this Vector, false otherwise\n    */\n-  public int indexOf(Object elem)\n+  public boolean contains(Object elem)\n   {\n-    return indexOf(elem, 0);\n+    return indexOf(elem, 0) >= 0;\n   }\n \n   /**\n-   * Returns true if <b>elem</b> is contained in this Vector, false otherwise.\n+   * Returns the first occurrence of <code>elem</code> in the Vector, or -1 if\n+   * <code>elem</code> is not found.\n    *\n-   * @param elem The element to check\n-   * @returns true if the object is contained in this Vector, false otherwise\n+   * @param elem the object to search for\n+   * @return the index of the first occurrence, or -1 if not found\n    */\n-  public boolean contains(Object elem)\n+  public int indexOf(Object elem)\n   {\n-    return indexOf(elem, 0) != -1;\n+    return indexOf(elem, 0);\n   }\n \n   /**\n-   * Returns the index of the first occurrence of <b>elem</b>, when searching\n-   * backwards from <b>index</b>.  If the object does not occur in this Vector,\n-   * -1 is returned.\n+   * Searches the vector starting at <code>index</code> for object\n+   * <code>elem</code> and returns the index of the first occurrence of this\n+   * Object.  If the object is not found, or index is larger than the size\n+   * of the vector, -1 is returned.\n    *\n-   * @param eThe object to search for\n-   * @param index The index to start searching in reverse from\n-   * @returns The index of the Object if found, -1 otherwise\n+   * @param e the Object to search for\n+   * @param index start searching at this index\n+   * @return the index of the next occurrence, or -1 if it is not found\n+   * @throws IndexOutOfBoundsException if index &lt; 0\n    */\n-  public synchronized int lastIndexOf(Object e, int index)\n+  public synchronized int indexOf(Object e, int index)\n   {\n-    if (index >= elementCount)\n-      throw new ArrayIndexOutOfBoundsException(index + \" >= \" + elementCount);\n-\n-    for (int i = index; i >= 0; i--)\n-      {\n-\tif (e == null ? elementData[i] == null : e.equals(elementData[i]))\n-\t  return i;\n-      }\n+    for (int i = index; i < elementCount; i++)\n+      if (equals(e, elementData[i]))\n+        return i;\n     return -1;\n   }\n \n   /**\n-   * Returns the last index of <b>elem</b> within this Vector, or -1\n-   * if the object is not within the Vector\n+   * Returns the last index of <code>elem</code> within this Vector, or -1\n+   * if the object is not within the Vector.\n    *\n-   * @param elem The object to search for\n-   * @returns the last index of the object, or -1 if not found\n+   * @param elem the object to search for\n+   * @return the last index of the object, or -1 if not found\n    */\n   public int lastIndexOf(Object elem)\n   {\n     return lastIndexOf(elem, elementCount - 1);\n   }\n \n   /**\n-   * Returns the Object stored at <b>index</b>.  If index is out of range\n-   * an ArrayIndexOutOfBoundsException is thrown.\n+   * Returns the index of the first occurrence of <code>elem</code>, when\n+   * searching backwards from <code>index</code>.  If the object does not\n+   * occur in this Vector, or index is less than 0, -1 is returned.\n+   *\n+   * @param e the object to search for\n+   * @param index the index to start searching in reverse from\n+   * @return the index of the Object if found, -1 otherwise\n+   * @throws IndexOutOfBoundsException if index &gt;= size()\n+   */\n+  public synchronized int lastIndexOf(Object e, int index)\n+  {\n+    checkBoundExclusive(index);\n+    for (int i = index; i >= 0; i--)\n+      if (equals(e, elementData[i]))\n+        return i;\n+    return -1;\n+  }\n+\n+  /**\n+   * Returns the Object stored at <code>index</code>.\n    *\n    * @param index the index of the Object to retrieve\n-   * @returns The object at <b>index</b>\n-   * @throws ArrayIndexOutOfBoundsException <b>index</b> is\n-   * larger than the Vector\n+   * @return the object at <code>index</code>\n+   * @throws ArrayIndexOutOfBoundsException index &lt; 0 || index &gt;= size()\n+   * @see #get(int)\n    */\n   public synchronized Object elementAt(int index)\n   {\n-    //Within the bounds of this Vector does not necessarily mean within \n-    //the bounds of the internal array\n-    if (index >= elementCount)\n-      throw new ArrayIndexOutOfBoundsException(index + \" >= \" + elementCount);\n-\n+    checkBoundExclusive(index);\n     return elementData[index];\n   }\n \n   /**\n-   * Returns the first element in the Vector.  If there is no first Object \n-   * (The vector is empty), a NoSuchElementException is thrown.\n+   * Returns the first element (index 0) in the Vector.\n    *\n-   * @returns The first Object in the Vector\n+   * @return the first Object in the Vector\n    * @throws NoSuchElementException the Vector is empty\n    */\n   public synchronized Object firstElement()\n   {\n     if (elementCount == 0)\n       throw new NoSuchElementException();\n \n-    return elementAt(0);\n+    return elementData[0];\n   }\n \n   /**\n-   * Returns the last element in the Vector.  If the Vector has no last element\n-   * (The vector is empty), a NoSuchElementException is thrown.\n+   * Returns the last element in the Vector.\n    *\n-   * @returns The last Object in the Vector\n+   * @return the last Object in the Vector\n    * @throws NoSuchElementException the Vector is empty\n    */\n   public synchronized Object lastElement()\n   {\n     if (elementCount == 0)\n       throw new NoSuchElementException();\n \n-    return elementAt(elementCount - 1);\n-  }\n-\n-  /**\n-   * Places <b>obj</b> at <b>index</b> within the Vector.  If <b>index</b>\n-   * refers to an index outside the Vector, an ArrayIndexOutOfBoundsException\n-   * is thrown.  \n-   * \n-   * @param obj The object to store\n-   * @param index The position in the Vector to store the object\n-   * @throws ArrayIndexOutOfBoundsException the index is out of range\n-   */\n-  public synchronized void setElementAt(Object obj, int index)\n-  {\n-    if (index >= elementCount)\n-      throw new ArrayIndexOutOfBoundsException(index + \" >= \" + elementCount);\n-\n-    elementData[index] = obj;\n+    return elementData[elementCount - 1];\n   }\n \n   /**\n-   * Puts <b>element</b> into the Vector at position <b>index</b> and returns\n-   * the Object that previously occupied that position.\n+   * Changes the element at <code>index</code> to be <code>obj</code>\n    *\n-   * @param index The index within the Vector to place the Object\n-   * @param element The Object to store in the Vector\n-   * @returns The previous object at the specified index\n+   * @param obj the object to store\n+   * @param index the position in the Vector to store the object\n    * @throws ArrayIndexOutOfBoundsException the index is out of range\n-   *\n+   * @see #set(int, Object)\n    */\n-  public synchronized Object set(int index, Object element)\n+  public void setElementAt(Object obj, int index)\n   {\n-    if (index >= elementCount)\n-      throw new ArrayIndexOutOfBoundsException(index + \" >= \" + elementCount);\n-\n-    Object temp = elementData[index];\n-    elementData[index] = element;\n-    return temp;\n+    set(index, obj);\n   }\n \n   /**\n-   * Removes the element at <b>index</b>, and shifts all elements at\n-   * positions greater than index to their index - 1.  \n+   * Removes the element at <code>index</code>, and shifts all elements at\n+   * positions greater than index to their index - 1.\n    *\n-   * @param index The index of the element to remove\n+   * @param index the index of the element to remove\n+   * @throws ArrayIndexOutOfBoundsException index &lt; 0 || index &gt;= size();\n+   * @see #remove(int)\n    */\n-  public synchronized void removeElementAt(int index)\n+  public void removeElementAt(int index)\n   {\n-    if (index >= elementCount)\n-      throw new ArrayIndexOutOfBoundsException(index + \" >= \" + elementCount);\n-\n-    modCount++;\n-    elementCount--;\n-    if (index < elementCount)\n-      System.arraycopy(elementData, index + 1, elementData, index,\n-\t\t       elementCount - index);\n-    //Delete the last element (which has been copied back one index)\n-    //so it can be garbage collected;\n-    elementData[elementCount] = null;\n+    remove(index);\n   }\n \n   /**\n-   * Inserts a new element into the Vector at <b>index</b>.  Any elements\n+   * Inserts a new element into the Vector at <code>index</code>.  Any elements\n    * at or greater than index are shifted up one position.\n    *\n-   * @param obj The object to insert\n-   * @param index The index at which the object is inserted\n+   * @param obj the object to insert\n+   * @param index the index at which the object is inserted\n+   * @throws ArrayIndexOutOfBoundsException index &lt; 0 || index &gt; size()\n+   * @see #add(int, Object)\n    */\n-  public void insertElementAt(Object obj, int index)\n+  public synchronized void insertElementAt(Object obj, int index)\n   {\n-    if (index > elementCount)\n-      throw new ArrayIndexOutOfBoundsException(index + \" > \" + elementCount);\n-\n+    checkBoundInclusive(index);\n     if (elementCount == elementData.length)\n       ensureCapacity(elementCount + 1);\n-    ++modCount;\n-    ++elementCount;\n+    modCount++;\n     System.arraycopy(elementData, index, elementData, index + 1,\n-\t\t     elementCount - 1 - index);\n+                     elementCount - index);\n+    elementCount++;\n     elementData[index] = obj;\n   }\n \n   /**\n-   * Adds an element to the Vector at the end of the Vector.  If the vector\n-   * cannot hold the element with its present capacity, its size is increased\n-   * based on the same rules followed if ensureCapacity was called with the\n-   * argument currentSize+1.\n+   * Adds an element to the Vector at the end of the Vector.  The vector\n+   * is increased by ensureCapacity(size() + 1) if needed.\n    *\n-   * @param obj The object to add to the Vector\n+   * @param obj the object to add to the Vector\n    */\n   public synchronized void addElement(Object obj)\n   {\n@@ -465,67 +466,71 @@ public synchronized void addElement(Object obj)\n   }\n \n   /**\n-   * Removes the first occurrence of the given object from the Vector.\n-   * If such a remove was performed (the object was found), true is returned.\n-   * If there was no such object, false is returned.\n+   * Removes the first (the lowestindex) occurance of the given object from\n+   * the Vector. If such a remove was performed (the object was found), true\n+   * is returned. If there was no such object, false is returned.\n    *\n-   * @param obj The object to remove from the Vector\n-   * @returns true if the Object was in the Vector, false otherwise\n+   * @param obj the object to remove from the Vector\n+   * @return true if the Object was in the Vector, false otherwise\n+   * @see #remove(Object)\n    */\n   public synchronized boolean removeElement(Object obj)\n   {\n-    int idx = indexOf(obj);\n-    if (idx != -1)\n+    int idx = indexOf(obj, 0);\n+    if (idx >= 0)\n       {\n-\tremoveElementAt(idx);\n-\treturn true;\n+        remove(idx);\n+        return true;\n       }\n     return false;\n   }\n \n   /**\n    * Removes all elements from the Vector.  Note that this does not\n    * resize the internal data array.\n+   *\n+   * @see #clear()\n    */\n   public synchronized void removeAllElements()\n   {\n-    modCount++;\n     if (elementCount == 0)\n       return;\n \n-    for (int i = elementCount - 1; i >= 0; --i)\n-      {\n-\telementData[i] = null;\n-      }\n+    modCount++;\n+    Arrays.fill(elementData, 0, elementCount, null);\n     elementCount = 0;\n   }\n \n   /**\n-   * Creates a new Vector with the same contents as this one.\n+   * Creates a new Vector with the same contents as this one. The clone is\n+   * shallow; elements are not cloned.\n+   *\n+   * @return the clone of this vector\n    */\n   public synchronized Object clone()\n   {\n     try\n       {\n-\tVector clone = (Vector) super.clone();\n-\tclone.elementData = (Object[]) elementData.clone();\n-\treturn clone;\n+        Vector clone = (Vector) super.clone();\n+        clone.elementData = (Object[]) elementData.clone();\n+        return clone;\n       }\n     catch (CloneNotSupportedException ex)\n       {\n-\tthrow new InternalError(ex.toString());\n+        // Impossible to get here.\n+        throw new InternalError(ex.toString());\n       }\n   }\n \n   /**\n    * Returns an Object array with the contents of this Vector, in the order\n-   * they are stored within this Vector.  Note that the Object array returned \n-   * is not the internal data array, and that it holds only the elements \n-   * within the Vector.  This is similar to creating a new Object[] with the \n+   * they are stored within this Vector.  Note that the Object array returned\n+   * is not the internal data array, and that it holds only the elements\n+   * within the Vector.  This is similar to creating a new Object[] with the\n    * size of this Vector, then calling Vector.copyInto(yourArray).\n    *\n-   * @returns An Object[] containing the contents of this Vector in order\n-   *\n+   * @return an Object[] containing the contents of this Vector in order\n+   * @since 1.2\n    */\n   public synchronized Object[] toArray()\n   {\n@@ -535,76 +540,97 @@ public synchronized Object[] toArray()\n   }\n \n   /**\n-   * Returns an array containing the contents of this Vector.  \n+   * Returns an array containing the contents of this Vector.\n    * If the provided array is large enough, the contents are copied\n-   * into that array, and a null is placed in the position size(). \n+   * into that array, and a null is placed in the position size().\n    * In this manner, you can obtain the size of a Vector by the position\n-   * of the null element.  If the type of the provided array cannot \n-   * hold the elements, an ArrayStoreException is thrown.\n-   * \n-   * If the provided array is not large enough,\n-   * a new one is created with the contents of the Vector, and no null \n-   * element.  The new array is of the same runtime type as the provided\n-   * array.\n+   * of the null element, if you know the vector does not itself contain\n+   * null entries.  If the array is not large enough, reflection is used\n+   * to create a bigger one of the same runtime type.\n    *\n-   *\n-   * @param array An array to copy the Vector into if large enough\n-   * @returns An array with the contents of this Vector in order\n+   * @param a an array to copy the Vector into if large enough\n+   * @return an array with the contents of this Vector in order\n    * @throws ArrayStoreException the runtime type of the provided array\n-   * cannot hold the elements of the Vector\n+   *         cannot hold the elements of the Vector\n+   * @throws NullPointerException if <code>a</code> is null\n+   * @since 1.2\n    */\n-  public synchronized Object[] toArray(Object[] array)\n+  public synchronized Object[] toArray(Object[] a)\n   {\n-    if (array.length < elementCount)\n-      array = (Object[]) Array.newInstance(array.getClass().getComponentType(), \n-        \t\t\t\t   elementCount);\n-    else if (array.length > elementCount)\n-      array[elementCount] = null;\n-    System.arraycopy(elementData, 0, array, 0, elementCount);\n-    return array;\n+    if (a.length < elementCount)\n+      a = (Object[]) Array.newInstance(a.getClass().getComponentType(),\n+                                       elementCount);\n+    else if (a.length > elementCount)\n+      a[elementCount] = null;\n+    System.arraycopy(elementData, 0, a, 0, elementCount);\n+    return a;\n   }\n \n   /**\n-   * Returns the element at position <b>index</b>\n+   * Returns the element at position <code>index</code>.\n    *\n    * @param index the position from which an element will be retrieved\n-   * @throws ArrayIndexOutOfBoundsException the index is not within the \n-   * range of the Vector\n+   * @return the element at that position\n+   * @throws ArrayIndexOutOfBoundsException index &lt; 0 || index &gt;= size()\n+   * @since 1.2\n    */\n-  public synchronized Object get(int index)\n+  public Object get(int index)\n   {\n     return elementAt(index);\n   }\n \n   /**\n-   * Removes the given Object from the Vector.  If it exists, true\n-   * is returned, if not, false is returned.\n+   * Puts <code>element</code> into the Vector at position <code>index</code>\n+   * and returns the Object that previously occupied that position.\n    *\n-   * @param o The object to remove from the Vector\n-   * @returns true if the Object existed in the Vector, false otherwise\n+   * @param index the index within the Vector to place the Object\n+   * @param element the Object to store in the Vector\n+   * @return the previous object at the specified index\n+   * @throws ArrayIndexOutOfBoundsException index &lt; 0 || index &gt;= size()\n+   * @since 1.2\n    */\n-  public boolean remove(Object o)\n+  public synchronized Object set(int index, Object element)\n   {\n-    return removeElement(o);\n+    checkBoundExclusive(index);\n+    Object temp = elementData[index];\n+    elementData[index] = element;\n+    return temp;\n   }\n \n   /**\n    * Adds an object to the Vector.\n    *\n-   * @param o The element to add to the Vector\n+   * @param o the element to add to the Vector\n+   * @return true, as specified by List\n+   * @since 1.2\n    */\n-  public synchronized boolean add(Object o)\n+  public boolean add(Object o)\n   {\n     addElement(o);\n     return true;\n   }\n \n+  /**\n+   * Removes the given Object from the Vector.  If it exists, true\n+   * is returned, if not, false is returned.\n+   *\n+   * @param o the object to remove from the Vector\n+   * @return true if the Object existed in the Vector, false otherwise\n+   * @since 1.2\n+   */\n+  public boolean remove(Object o)\n+  {\n+    return removeElement(o);\n+  }\n+\n   /**\n    * Adds an object at the specified index.  Elements at or above\n    * index are shifted up one position.\n    *\n-   * @param index The index at which to add the element\n-   * @param element The element to add to the Vector\n+   * @param index the index at which to add the element\n+   * @param element the element to add to the Vector\n+   * @throws ArrayIndexOutOfBoundsException index &lt; 0 || index &gt; size()\n+   * @since 1.2\n    */\n   public void add(int index, Object element)\n   {\n@@ -614,153 +640,253 @@ public void add(int index, Object element)\n   /**\n    * Removes the element at the specified index, and returns it.\n    *\n-   * @param index The position from which to remove the element\n-   * @returns The object removed\n-   * @throws ArrayIndexOutOfBoundsException the index was out of the range\n-   * of the Vector\n+   * @param index the position from which to remove the element\n+   * @return the object removed\n+   * @throws ArrayIndexOutOfBoundsException index &lt; 0 || index &gt;= size()\n+   * @since 1.2\n    */\n   public synchronized Object remove(int index)\n   {\n-    if (index >= elementCount)\n-      throw new ArrayIndexOutOfBoundsException(index + \" >= \" + elementCount);\n-  \n+    checkBoundExclusive(index);\n     Object temp = elementData[index];\n-    removeElementAt(index);\n+    modCount++;\n+    elementCount--;\n+    if (index < elementCount)\n+      System.arraycopy(elementData, index + 1, elementData, index,\n+                       elementCount - index);\n+    elementData[elementCount] = null;\n     return temp;\n   }\n \n   /**\n-   * Clears all elements in the Vector and sets its size to 0\n+   * Clears all elements in the Vector and sets its size to 0.\n    */\n   public void clear()\n   {\n     removeAllElements();\n   }\n \n+  /**\n+   * Returns true if this Vector contains all the elements in c.\n+   *\n+   * @param c the collection to compare to\n+   * @return true if this vector contains all elements of c\n+   * @throws NullPointerException if c is null\n+   * @since 1.2\n+   */\n   public synchronized boolean containsAll(Collection c)\n   {\n-    Iterator itr = c.iterator();\n-    int size = c.size();\n-    for (int pos = 0; pos < size; pos++)\n-      {\n-\tif (!contains(itr.next()))\n-\t  return false;\n-      }\n-    return true;\n+    // Here just for the sychronization.\n+    return super.containsAll(c);\n   }\n \n+  /**\n+   * Appends all elements of the given collection to the end of this Vector.\n+   * Behavior is undefined if the collection is modified during this operation\n+   * (for example, if this == c).\n+   *\n+   * @param c the collection to append\n+   * @return true if this vector changed, in other words c was not empty\n+   * @throws NullPointerException if c is null\n+   * @since 1.2\n+   */\n   public synchronized boolean addAll(Collection c)\n   {\n     return addAll(elementCount, c);\n   }\n-  \n+\n+  /**\n+   * Remove from this vector all elements contained in the given collection.\n+   *\n+   * @param c the collection to filter out\n+   * @return true if this vector changed\n+   * @throws NullPointerException if c is null\n+   * @since 1.2\n+   */\n   public synchronized boolean removeAll(Collection c)\n   {\n-    return super.removeAll(c);\n+    int i;\n+    int j;\n+    for (i = 0; i < elementCount; i++)\n+      if (c.contains(elementData[i]))\n+        break;\n+    if (i == elementCount)\n+      return false;\n+\n+    modCount++;\n+    for (j = i++; i < elementCount; i++)\n+      if (! c.contains(elementData[i]))\n+        elementData[j++] = elementData[i];\n+    elementCount -= i - j;\n+    return true;\n   }\n-  \n+\n+  /**\n+   * Retain in this vector only the elements contained in the given collection.\n+   *\n+   * @param c the collection to filter by\n+   * @return true if this vector changed\n+   * @throws NullPointerException if c is null\n+   * @since 1.2\n+   */\n   public synchronized boolean retainAll(Collection c)\n   {\n-    return super.retainAll(c);\n+    int i;\n+    int j;\n+    for (i = 0; i < elementCount; i++)\n+      if (! c.contains(elementData[i]))\n+        break;\n+    if (i == elementCount)\n+      return false;\n+\n+    modCount++;\n+    for (j = i++; i < elementCount; i++)\n+      if (c.contains(elementData[i]))\n+        elementData[j++] = elementData[i];\n+    elementCount -= i - j;\n+    return true;\n   }\n \n+  /**\n+   * Inserts all elements of the given collection at the given index of\n+   * this Vector. Behavior is undefined if the collection is modified during\n+   * this operation (for example, if this == c).\n+   *\n+   * @param c the collection to append\n+   * @return true if this vector changed, in other words c was not empty\n+   * @throws NullPointerException if c is null\n+   * @throws ArrayIndexOutOfBoundsException index &lt; 0 || index &gt; size()\n+   * @since 1.2\n+   */\n   public synchronized boolean addAll(int index, Collection c)\n   {\n-    if (index < 0 || index > elementCount)\n-      throw new ArrayIndexOutOfBoundsException(index);\n-    modCount++;\n+    checkBoundInclusive(index);\n     Iterator itr = c.iterator();\n     int csize = c.size();\n \n+    modCount++;\n     ensureCapacity(elementCount + csize);\n     int end = index + csize;\n     if (elementCount > 0 && index != elementCount)\n       System.arraycopy(elementData, index, elementData, end, csize);\n     elementCount += csize;\n-    for (; index < end; index++)\n-      {\n-        elementData[index] = itr.next();\n-      }\n-    return (csize > 0);  \n+    for ( ; index < end; index++)\n+      elementData[index] = itr.next();\n+    return (csize > 0);\n   }\n \n-  public synchronized boolean equals(Object c)\n+  /**\n+   * Compares this to the given object.\n+   *\n+   * @param o the object to compare to\n+   * @return true if the two are equal\n+   * @since 1.2\n+   */\n+  public synchronized boolean equals(Object o)\n   {\n-    return super.equals(c);\n+    // Here just for the sychronization.\n+    return super.equals(o);\n   }\n \n+  /**\n+   * Computes the hashcode of this object.\n+   *\n+   * @return the hashcode\n+   * @since 1.2\n+   */\n   public synchronized int hashCode()\n   {\n+    // Here just for the sychronization.\n     return super.hashCode();\n   }\n \n   /**\n-   * Returns a string representation of this Vector in the form \n-   * [element0, element1, ... elementN]\n+   * Returns a string representation of this Vector in the form\n+   * \"[element0, element1, ... elementN]\".\n    *\n-   * @returns the String representation of this Vector\n+   * @return the String representation of this Vector\n    */\n   public synchronized String toString()\n   {\n-    String r = \"[\";\n-    for (int i = 0; i < elementCount; i++)\n-      {\n-\tr += elementData[i];\n-\tif (i < elementCount - 1)\n-\t  r += \", \";\n-      }\n-    r += \"]\";\n-    return r;\n+    // Here just for the sychronization.\n+    return super.toString();\n   }\n \n   /**\n-   * Returns an Enumeration of the elements of this List.\n-   * The Enumeration returned is compatible behavior-wise with\n-   * the 1.1 elements() method, in that it does not check for\n-   * concurrent modification.\n+   * Obtain a List view of a subsection of this list, from fromIndex\n+   * (inclusive) to toIndex (exclusive). If the two indices are equal, the\n+   * sublist is empty. The returned list is modifiable, and changes in one\n+   * reflect in the other. If this list is structurally modified in\n+   * any way other than through the returned list, the result of any subsequent\n+   * operations on the returned list is undefined.\n+   * <p>\n    *\n-   * @returns an Enumeration\n+   * @param fromIndex the index that the returned list should start from\n+   *        (inclusive)\n+   * @param toIndex the index that the returned list should go to (exclusive)\n+   * @return a List backed by a subsection of this vector\n+   * @throws IndexOutOfBoundsException if fromIndex &lt; 0\n+   *         || toIndex &gt; size()\n+   * @throws IllegalArgumentException if fromIndex &gt; toIndex\n+   * @see ConcurrentModificationException\n+   * @since 1.2\n    */\n-  public synchronized Enumeration elements()\n-  {\n-    return new Enumeration()\n-    {\n-      int i = 0;\n-      public boolean hasMoreElements()\n-      {\n-\treturn (i < elementCount);\n-      }\n-      public Object nextElement()\n-      {\n-\tif (i >= elementCount)\n-\t  throw new NoSuchElementException();\n-\treturn (elementAt(i++));\n-      }\n-    };\n-  }\n-  \n-  public List subList(int fromIndex, int toIndex)\n+  public synchronized List subList(int fromIndex, int toIndex)\n   {\n     List sub = super.subList(fromIndex, toIndex);\n-    return Collections.synchronizedList(sub);\n+    // We must specify the correct object to synchronize upon, hence the\n+    // use of a non-public API\n+    return new Collections.SynchronizedList(this, sub);\n   }\n-  \n-  /** @specnote This is not specified as synchronized in the JCL, but it seems\n-    * to me that is should be. If it isn't, a clear() operation on a sublist\n-    * will not be synchronized w.r.t. the Vector object.\n-    */\n-  protected synchronized void removeRange(int fromIndex, int toIndex)\n+\n+  /**\n+   * Removes a range of elements from this list.\n+   *\n+   * @param fromIndex the index to start deleting from (inclusive)\n+   * @param toIndex the index to delete up to (exclusive)\n+   */\n+  // This does not need to be synchronized, because it is only called through\n+  // clear() of a sublist, and clear() had already synchronized.\n+  protected void removeRange(int fromIndex, int toIndex)\n   {\n-    modCount++;\n     if (fromIndex != toIndex)\n       {\n-\tSystem.arraycopy(elementData, toIndex, elementData, fromIndex, \n-\t                 elementCount - toIndex);\n-\t// Clear unused elements so objects can be collected.\n-\tint save = elementCount;\n-\telementCount -= (toIndex - fromIndex);\n-\tfor (int i = elementCount; i < save; ++i)\n-\t  elementData[i] = null;\n+        modCount++;\n+        System.arraycopy(elementData, toIndex, elementData, fromIndex,\n+                         elementCount - toIndex);\n+        int save = elementCount;\n+        elementCount -= toIndex - fromIndex;\n+        Arrays.fill(elementData, elementCount, save, null);\n       }\n   }\n+\n+  /**\n+   * Checks that the index is in the range of possible elements (inclusive).\n+   *\n+   * @param index the index to check\n+   * @throws ArrayIndexOutOfBoundsException if index &gt; size\n+   */\n+  private void checkBoundInclusive(int index)\n+  {\n+    // Implementation note: we do not check for negative ranges here, since\n+    // use of a negative index will cause an ArrayIndexOutOfBoundsException\n+    // with no effort on our part.\n+    if (index > elementCount)\n+      throw new ArrayIndexOutOfBoundsException(index + \" > \" + elementCount);\n+  }\n+\n+  /**\n+   * Checks that the index is in the range of existing elements (exclusive).\n+   *\n+   * @param index the index to check\n+   * @throws ArrayIndexOutOfBoundsException if index &gt;= size\n+   */\n+  private void checkBoundExclusive(int index)\n+  {\n+    // Implementation note: we do not check for negative ranges here, since\n+    // use of a negative index will cause an ArrayIndexOutOfBoundsException\n+    // with no effort on our part.\n+    if (index >= elementCount)\n+      throw new ArrayIndexOutOfBoundsException(index + \" >= \" + elementCount);\n+  }\n }"}, {"sha": "6366e9822c2f39535ca8d0f4803ef408d406cf8c", "filename": "libjava/java/util/WeakHashMap.java", "status": "modified", "additions": 407, "deletions": 283, "changes": 690, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2Fjava%2Futil%2FWeakHashMap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9fd7154ec7908eff8bbbce75651eccf51064ac1/libjava%2Fjava%2Futil%2FWeakHashMap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FWeakHashMap.java?ref=d9fd7154ec7908eff8bbbce75651eccf51064ac1", "patch": "@@ -1,5 +1,6 @@\n-/* java.util.WeakHashMap\n-   Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n+/* java.util.WeakHashMap -- a hashtable that keeps only weak references\n+   to its keys, allowing the virtual machine to reclaim them\n+   Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -26,6 +27,7 @@\n \n \n package java.util;\n+\n import java.lang.ref.WeakReference;\n import java.lang.ref.ReferenceQueue;\n \n@@ -50,53 +52,80 @@\n  * has similar phenomenons: The size may spontaneously shrink, or an\n  * entry, that was in the set before, suddenly disappears. <br>\n  *\n- * A weak hash map is not meant for caches; use a normal map, with \n- * soft references as values instead.  <br>\n+ * A weak hash map is not meant for caches; use a normal map, with\n+ * soft references as values instead, or try {@link LinkedHashMap}.  <br>\n  *\n- * The weak hash map supports null values and null keys.  Null keys\n- * are never deleted from the map (except explictly of course). \n+ * The weak hash map supports null values and null keys.  The null key\n+ * is never deleted from the map (except explictly of course).\n  * The performance of the methods are similar to that of a hash map. <br>\n  *\n- * The value object are strongly referenced by this table.  So if a\n+ * The value objects are strongly referenced by this table.  So if a\n  * value object maintains a strong reference to the key (either direct\n  * or indirect) the key will never be removed from this map.  According\n- * to Sun, this problem may be fixed in a future release.  It is not \n+ * to Sun, this problem may be fixed in a future release.  It is not\n  * possible to do it with the jdk 1.2 reference model, though.\n  *\n- * @since jdk1.2\n- * @author Jochen Hoenicke \n+ * @author Jochen Hoenicke\n+ * @author Eric Blake <ebb9@email.byu.edu>\n  * @see HashMap\n- * @see WeakReference */\n+ * @see WeakReference\n+ * @see LinkedHashMap\n+ * @since 1.2\n+ * @status updated to 1.4\n+ */\n public class WeakHashMap extends AbstractMap implements Map\n {\n-  /** \n-   * The default capacity for an instance of HashMap.  \n+  /**\n+   * The default capacity for an instance of HashMap.\n    * Sun's documentation mildly suggests that this (11) is the correct\n-   * value.  \n+   * value.\n    */\n   private static final int DEFAULT_CAPACITY = 11;\n \n-  /** \n-   * The default load factor of a HashMap \n+  /**\n+   * The default load factor of a HashMap.\n    */\n   private static final float DEFAULT_LOAD_FACTOR = 0.75F;\n \n   /**\n    * This is used instead of the key value <i>null</i>.  It is needed\n-   * to distinguish between an null key and a removed key.  \n+   * to distinguish between an null key and a removed key.\n    */\n-  private static final Object NULL_KEY = new Object();\n+  // Package visible for use by nested classes.\n+  static final Object NULL_KEY = new Object()\n+  {\n+    /**\n+     * Sets the hashCode to 0, since that's what null would map to.\n+     * @return the hash code 0\n+     */\n+    public int hashCode()\n+    {\n+      return 0;\n+    }\n+\n+    /**\n+     * Compares this key to the given object. Normally, an object should\n+     * NEVER compare equal to null, but since we don't publicize NULL_VALUE,\n+     * it saves bytecode to do so here.\n+     * @return true iff o is this or null\n+     */\n+    public boolean equals(Object o)\n+    {\n+      return null == o || this == o;\n+    }\n+  };\n \n   /**\n    * The reference queue where our buckets (which are WeakReferences) are\n    * registered to.\n    */\n-  private ReferenceQueue queue;\n+  private final ReferenceQueue queue;\n \n   /**\n    * The number of entries in this hash map.\n    */\n-  private int size;\n+  // Package visible for use by nested classes.\n+  int size;\n \n   /**\n    * The load factor of this WeakHashMap.  This is the maximum ratio of\n@@ -108,7 +137,7 @@ public class WeakHashMap extends AbstractMap implements Map\n   /**\n    * The rounded product of the capacity (i.e. number of buckets) and\n    * the load factor. When the number of elements exceeds the\n-   * threshold, the HashMap calls <pre>rehash()</pre>.  \n+   * threshold, the HashMap calls <pre>rehash()</pre>.\n    */\n   private int threshold;\n \n@@ -119,17 +148,20 @@ public class WeakHashMap extends AbstractMap implements Map\n    * by the garbage collection.  Instead the iterators must make\n    * sure to have strong references to the entries they rely on.\n    */\n-  private int modCount;\n+  // Package visible for use by nested classes.\n+  int modCount;\n \n-  /** \n+  /**\n    * The entry set.  There is only one instance per hashmap, namely\n    * theEntrySet.  Note that the entry set may silently shrink, just\n    * like the WeakHashMap.\n    */\n-  private class WeakEntrySet extends AbstractSet\n+  private final class WeakEntrySet extends AbstractSet\n   {\n     /**\n-     * Returns the size of this set. \n+     * Returns the size of this set.\n+     *\n+     * @return the set size\n      */\n     public int size()\n     {\n@@ -138,151 +170,150 @@ public int size()\n \n     /**\n      * Returns an iterator for all entries.\n+     *\n+     * @return an Entry iterator\n      */\n     public Iterator iterator()\n     {\n       return new Iterator()\n       {\n-\t/** \n-\t * The entry that was returned by the last\n-\t * <code>next()</code> call.  This is also the entry whose\n-\t * bucket should be removed by the <code>remove</code> call. <br>\n-\t *\n-\t * It is null, if the <code>next</code> method wasn't \n-\t * called yet, or if the entry was already removed.  <br>\n-\t *\n-\t * Remembering this entry here will also prevent it from\n-\t * being removed under us, since the entry strongly refers\n-\t * to the key.\n-\t */\n-\tWeakBucket.Entry lastEntry;\n-\n-\t/** \n-\t * The entry that will be returned by the next\n-\t * <code>next()</code> call.  It is <code>null</code> if there\n-\t * is no further entry. <br>\n-\t *\n-\t * Remembering this entry here will also prevent it from\n-\t * being removed under us, since the entry strongly refers\n-\t * to the key.\n-\t */\n-\tWeakBucket.Entry nextEntry = findNext(null);\n-\n-\t/**\n-\t * The known number of modification to the list, if it differs\n-\t * from the real number, we through an exception.\n-\t */\n-\tint knownMod = modCount;\n-\n-\t/** \n-\t * Check the known number of modification to the number of\n-\t * modifications of the table.  If it differs from the real\n-\t * number, we throw an exception.\n-\t * @exception ConcurrentModificationException if the number\n-\t * of modifications doesn't match.\n-\t */\n-\tprivate void checkMod()\n-\t{\n-\t  /* This method will get inlined */\n-\t  if (knownMod != modCount)\n-\t    throw new ConcurrentModificationException();\n-\t}\n-\n-\t/**\n-\t * Get a strong reference to the next entry after\n-\t * lastBucket.\n-\t * @param lastBucket the previous bucket, or null if we should\n-\t * get the first entry.\n-\t * @return the next entry.\n-\t */\n-\tprivate WeakBucket.Entry findNext(WeakBucket.Entry lastEntry)\n-\t{\n-\t  int slot;\n-\t  WeakBucket nextBucket;\n-\t  if (lastEntry != null)\n-\t    {\n-\t      nextBucket = lastEntry.getBucket().next;\n-\t      slot = lastEntry.getBucket().slot;\n-\t    }\n-\t  else\n-\t    {\n-\t      nextBucket = buckets[0];\n-\t      slot = 0;\n-\t    }\n-\n-\t  while (true)\n-\t    {\n-\t      while (nextBucket != null)\n-\t\t{\n-\t\t  WeakBucket.Entry entry = nextBucket.getEntry();\n-\t\t  if (entry != null)\n-\t\t    /* This is the next entry */\n-\t\t    return entry;\n-\n-\t\t  /* entry was cleared, try next */\n-\t\t  nextBucket = nextBucket.next;\n-\t\t}\n-\n-\t      slot++;\n-\t      if (slot == buckets.length)\n-\t\t/* No more buckets, we are through */\n-\t\treturn null;\n-\n-\t      nextBucket = buckets[slot];\n-\t    }\n-\t}\n-\n-\n-\t/**\n-\t * Checks if there are more entries.\n-\t * @return true, iff there are more elements.\n-\t * @exception IllegalModificationException if the hash map was\n-\t * modified.\n-\t */\n-\tpublic boolean hasNext()\n-\t{\n-\t  cleanQueue();\n-\t  checkMod();\n-\t  return (nextEntry != null);\n-\t}\n-\n-\t/**\n-\t * Returns the next entry.\n-\t * @return the next entry.\n-\t * @exception IllegalModificationException if the hash map was\n-\t * modified.\n-\t * @exception NoSuchElementException if there is no entry.\n-\t */\n-\tpublic Object next()\n-\t{\n-\t  cleanQueue();\n-\t  checkMod();\n-\t  if (nextEntry == null)\n-\t    throw new NoSuchElementException();\n-\t  lastEntry = nextEntry;\n-\t  nextEntry = findNext(lastEntry);\n-\t  return lastEntry;\n-\t}\n-\n-\t/**\n-\t * Removes the last returned entry from this set.  This will\n-\t * also remove the bucket of the underlying weak hash map.\n-\t * @exception IllegalModificationException if the hash map was\n-\t * modified.\n-\t * @exception IllegalStateException if <code>next()</code> was\n-\t * never called or the element was already removed. \n-\t */\n-\tpublic void remove()\n-\t{\n-\t  cleanQueue();\n-\t  checkMod();\n-\t  if (lastEntry == null)\n-\t    throw new IllegalStateException();\n-\t  internalRemove(lastEntry.getBucket());\n-\t  lastEntry = null;\n-\t  modCount++;\n-\t  knownMod = modCount;\n-\t}\n+        /**\n+         * The entry that was returned by the last\n+         * <code>next()</code> call.  This is also the entry whose\n+         * bucket should be removed by the <code>remove</code> call. <br>\n+         *\n+         * It is null, if the <code>next</code> method wasn't\n+         * called yet, or if the entry was already removed.  <br>\n+         *\n+         * Remembering this entry here will also prevent it from\n+         * being removed under us, since the entry strongly refers\n+         * to the key.\n+         */\n+        WeakBucket.WeakEntry lastEntry;\n+\n+        /**\n+         * The entry that will be returned by the next\n+         * <code>next()</code> call.  It is <code>null</code> if there\n+         * is no further entry. <br>\n+         *\n+         * Remembering this entry here will also prevent it from\n+         * being removed under us, since the entry strongly refers\n+         * to the key.\n+         */\n+        WeakBucket.WeakEntry nextEntry = findNext(null);\n+\n+        /**\n+         * The known number of modification to the list, if it differs\n+         * from the real number, we throw an exception.\n+         */\n+        int knownMod = modCount;\n+\n+        /**\n+         * Check the known number of modification to the number of\n+         * modifications of the table.  If it differs from the real\n+         * number, we throw an exception.\n+         * @throws ConcurrentModificationException if the number\n+         *         of modifications doesn't match.\n+         */\n+        private void checkMod()\n+        {\n+          // This method will get inlined.\n+          cleanQueue();\n+          if (knownMod != modCount)\n+            throw new ConcurrentModificationException();\n+        }\n+\n+        /**\n+         * Get a strong reference to the next entry after\n+         * lastBucket.\n+         * @param lastEntry the previous bucket, or null if we should\n+         * get the first entry.\n+         * @return the next entry.\n+         */\n+        private WeakBucket.WeakEntry findNext(WeakBucket.WeakEntry lastEntry)\n+        {\n+          int slot;\n+          WeakBucket nextBucket;\n+          if (lastEntry != null)\n+            {\n+              nextBucket = lastEntry.getBucket().next;\n+              slot = lastEntry.getBucket().slot;\n+            }\n+          else\n+            {\n+              nextBucket = buckets[0];\n+              slot = 0;\n+            }\n+\n+          while (true)\n+            {\n+              while (nextBucket != null)\n+                {\n+                  WeakBucket.WeakEntry entry = nextBucket.getEntry();\n+                  if (entry != null)\n+                    // This is the next entry.\n+                    return entry;\n+\n+                  // Entry was cleared, try next.\n+                  nextBucket = nextBucket.next;\n+                }\n+\n+              slot++;\n+              if (slot == buckets.length)\n+                // No more buckets, we are through.\n+                return null;\n+\n+              nextBucket = buckets[slot];\n+            }\n+        }\n+\n+        /**\n+         * Checks if there are more entries.\n+         * @return true, iff there are more elements.\n+         * @throws ConcurrentModificationException if the hash map was\n+         *         modified.\n+         */\n+        public boolean hasNext()\n+        {\n+          checkMod();\n+          return nextEntry != null;\n+        }\n+\n+        /**\n+         * Returns the next entry.\n+         * @return the next entry.\n+         * @throws ConcurrentModificationException if the hash map was\n+         *         modified.\n+         * @throws NoSuchElementException if there is no entry.\n+         */\n+        public Object next()\n+        {\n+          checkMod();\n+          if (nextEntry == null)\n+            throw new NoSuchElementException();\n+          lastEntry = nextEntry;\n+          nextEntry = findNext(lastEntry);\n+          return lastEntry;\n+        }\n+\n+        /**\n+         * Removes the last returned entry from this set.  This will\n+         * also remove the bucket of the underlying weak hash map.\n+         * @throws ConcurrentModificationException if the hash map was\n+         *         modified.\n+         * @throws IllegalStateException if <code>next()</code> was\n+         *         never called or the element was already removed.\n+         */\n+        public void remove()\n+        {\n+          checkMod();\n+          if (lastEntry == null)\n+            throw new IllegalStateException();\n+          modCount++;\n+          internalRemove(lastEntry.getBucket());\n+          lastEntry = null;\n+          knownMod++;\n+        }\n       };\n     }\n   }\n@@ -293,28 +324,28 @@ public void remove()\n    * number. <br>\n    *\n    * It would be cleaner to have a WeakReference as field, instead of\n-   * extending it, but if a weak reference get cleared, we only get\n+   * extending it, but if a weak reference gets cleared, we only get\n    * the weak reference (by queue.poll) and wouldn't know where to\n    * look for this reference in the hashtable, to remove that entry.\n    *\n-   * @author Jochen Hoenicke \n+   * @author Jochen Hoenicke\n    */\n   private static class WeakBucket extends WeakReference\n   {\n     /**\n      * The value of this entry.  The key is stored in the weak\n-     * reference that we extend.  \n+     * reference that we extend.\n      */\n     Object value;\n \n     /**\n      * The next bucket describing another entry that uses the same\n-     * slot.  \n+     * slot.\n      */\n     WeakBucket next;\n \n     /**\n-     * The slot of this entry. This should be \n+     * The slot of this entry. This should be\n      * <pre>\n      *  Math.abs(key.hashCode() % buckets.length)\n      * </pre>\n@@ -329,24 +360,25 @@ private static class WeakBucket extends WeakReference\n      * Creates a new bucket for the given key/value pair and the specified\n      * slot.\n      * @param key the key\n+     * @param queue the queue the weak reference belongs to\n      * @param value the value\n      * @param slot the slot.  This must match the slot where this bucket\n-     * will be enqueued.\n+     *        will be enqueued.\n      */\n     public WeakBucket(Object key, ReferenceQueue queue, Object value,\n-\t\t      int slot)\n+                      int slot)\n     {\n       super(key, queue);\n       this.value = value;\n       this.slot = slot;\n     }\n \n     /**\n-     * This class gives the <code>Entry</code> representation of the \n+     * This class gives the <code>Entry</code> representation of the\n      * current bucket.  It also keeps a strong reference to the\n      * key; bad things may happen otherwise.\n      */\n-    class Entry implements Map.Entry\n+    class WeakEntry implements Map.Entry\n     {\n       /**\n        * The strong ref to the key.\n@@ -355,93 +387,105 @@ class Entry implements Map.Entry\n \n       /**\n        * Creates a new entry for the key.\n+       * @param key the key\n        */\n-      public Entry(Object key)\n+      public WeakEntry(Object key)\n       {\n-\tthis.key = key;\n+        this.key = key;\n       }\n \n       /**\n        * Returns the underlying bucket.\n+       * @return the owning bucket\n        */\n       public WeakBucket getBucket()\n       {\n-\treturn WeakBucket.this;\n+        return WeakBucket.this;\n       }\n \n       /**\n        * Returns the key.\n+       * @return the key\n        */\n       public Object getKey()\n       {\n-\treturn key == NULL_KEY ? null : key;\n+        return key == NULL_KEY ? null : key;\n       }\n \n       /**\n        * Returns the value.\n+       * @return the value\n        */\n       public Object getValue()\n       {\n-\treturn value;\n+        return value;\n       }\n \n       /**\n-       * This changes the value.  This change takes place in \n+       * This changes the value.  This change takes place in\n        * the underlying hash map.\n+       * @param newVal the new value\n+       * @return the old value\n        */\n       public Object setValue(Object newVal)\n       {\n-\tObject oldVal = value;\n-\tvalue = newVal;\n-\treturn oldVal;\n+        Object oldVal = value;\n+        value = newVal;\n+        return oldVal;\n       }\n \n       /**\n        * The hashCode as specified in the Entry interface.\n+       * @return the hash code\n        */\n       public int hashCode()\n       {\n-\treturn (key == NULL_KEY ? 0 : key.hashCode())\n-\t  ^ (value == null ? 0 : value.hashCode());\n+        return key.hashCode() ^ WeakHashMap.hashCode(value);\n       }\n \n       /**\n        * The equals method as specified in the Entry interface.\n+       * @param o the object to compare to\n+       * @return true iff o represents the same key/value pair\n        */\n       public boolean equals(Object o)\n       {\n-\tif (o instanceof Map.Entry)\n-\t  {\n-\t    Map.Entry e = (Map.Entry) o;\n-\t    return (key == NULL_KEY\n-\t\t    ? e.getKey() == null : key.equals(e.getKey()))\n-\t      && (value == null\n-\t\t  ? e.getValue() == null : value.equals(e.getValue()));\n-\t  }\n-\treturn false;\n+        if (o instanceof Map.Entry)\n+          {\n+            Map.Entry e = (Map.Entry) o;\n+            return key.equals(e.getKey())\n+              && WeakHashMap.equals(value, e.getValue());\n+          }\n+        return false;\n+      }\n+\n+      public String toString()\n+      {\n+        return key + \"=\" + value;\n       }\n     }\n \n     /**\n      * This returns the entry stored in this bucket, or null, if the\n      * bucket got cleared in the mean time.\n+     * @return the Entry for this bucket, if it exists\n      */\n-    Entry getEntry()\n+    WeakEntry getEntry()\n     {\n-      final Object key = this.get();\n+      final Object key = get();\n       if (key == null)\n-\treturn null;\n-      return new Entry(key);\n+        return null;\n+      return new WeakEntry(key);\n     }\n   }\n \n   /**\n    * The entry set returned by <code>entrySet()</code>.\n    */\n-  private WeakEntrySet theEntrySet;\n+  private final WeakEntrySet theEntrySet;\n \n   /**\n-   * The hash buckets.  This are linked lists.\n+   * The hash buckets.  These are linked lists.\n    */\n   private WeakBucket[] buckets;\n \n@@ -457,7 +501,8 @@ public WeakHashMap()\n   /**\n    * Creates a new weak hash map with default load factor and the given\n    * capacity.\n-   * @param initialCapacity the initial capacity \n+   * @param initialCapacity the initial capacity\n+   * @throws IllegalArgumentException if initialCapacity is negative\n    */\n   public WeakHashMap(int initialCapacity)\n   {\n@@ -466,13 +511,16 @@ public WeakHashMap(int initialCapacity)\n \n   /**\n    * Creates a new weak hash map with the given initial capacity and\n-   * load factor.  \n+   * load factor.\n    * @param initialCapacity the initial capacity.\n    * @param loadFactor the load factor (see class description of HashMap).\n+   * @throws IllegalArgumentException if initialCapacity is negative, or\n+   *         loadFactor is non-positive\n    */\n   public WeakHashMap(int initialCapacity, float loadFactor)\n   {\n-    if (initialCapacity < 0 || loadFactor <= 0 || loadFactor > 1)\n+    // Check loadFactor for NaN as well.\n+    if (initialCapacity < 0 || ! (loadFactor > 0))\n       throw new IllegalArgumentException();\n     this.loadFactor = loadFactor;\n     threshold = (int) (initialCapacity * loadFactor);\n@@ -481,8 +529,24 @@ public WeakHashMap(int initialCapacity, float loadFactor)\n     buckets = new WeakBucket[initialCapacity];\n   }\n \n-  /** \n-   * simply hashes a non-null Object to its array index \n+  /**\n+   * Construct a new WeakHashMap with the same mappings as the given map.\n+   * The WeakHashMap has a default load factor of 0.75.\n+   *\n+   * @param m the map to copy\n+   * @throws NullPointerException if m is null\n+   * @since 1.3\n+   */\n+  public WeakHashMap(Map m)\n+  {\n+    this(m.size(), DEFAULT_LOAD_FACTOR);\n+    putAll(m);\n+  }\n+\n+  /**\n+   * Simply hashes a non-null Object to its array index.\n+   * @param key the key to hash\n+   * @return its slot number\n    */\n   private int hash(Object key)\n   {\n@@ -498,80 +562,80 @@ private int hash(Object key)\n    * Currently the iterator maintains a strong reference to the key, so\n    * that is no problem.\n    */\n-  private void cleanQueue()\n+  // Package visible for use by nested classes.\n+  void cleanQueue()\n   {\n     Object bucket = queue.poll();\n     while (bucket != null)\n       {\n-\tinternalRemove((WeakBucket) bucket);\n-\tbucket = queue.poll();\n+        internalRemove((WeakBucket) bucket);\n+        bucket = queue.poll();\n       }\n   }\n \n   /**\n    * Rehashes this hashtable.  This will be called by the\n-   * <code>add()</code> method if the size grows beyond the threshold.  \n+   * <code>add()</code> method if the size grows beyond the threshold.\n    * It will grow the bucket size at least by factor two and allocates\n    * new buckets.\n    */\n   private void rehash()\n   {\n     WeakBucket[] oldBuckets = buckets;\n-    int newsize = buckets.length * 2 + 1;\t// XXX should be prime.\n+    int newsize = buckets.length * 2 + 1; // XXX should be prime.\n     threshold = (int) (newsize * loadFactor);\n     buckets = new WeakBucket[newsize];\n \n-    /* Now we have to insert the buckets again.\n-     */\n+    // Now we have to insert the buckets again.\n     for (int i = 0; i < oldBuckets.length; i++)\n       {\n-\tWeakBucket bucket = oldBuckets[i];\n-\tWeakBucket nextBucket;\n-\twhile (bucket != null)\n-\t  {\n-\t    nextBucket = bucket.next;\n-\n-\t    Object key = bucket.get();\n-\t    if (key == null)\n-\t      {\n-\t\t/* This bucket should be removed; it is probably\n-\t\t * already on the reference queue.  We don't insert it\n-\t\t * at all, and mark it as cleared.  */\n-\t\tbucket.slot = -1;\n-\t\tsize--;\n-\t      }\n-\t    else\n-\t      {\n-\t\t/* add this bucket to its new slot */\n-\t\tint slot = hash(key);\n-\t\tbucket.slot = slot;\n-\t\tbucket.next = buckets[slot];\n-\t\tbuckets[slot] = bucket;\n-\t      }\n-\t    bucket = nextBucket;\n-\t  }\n+        WeakBucket bucket = oldBuckets[i];\n+        WeakBucket nextBucket;\n+        while (bucket != null)\n+          {\n+            nextBucket = bucket.next;\n+\n+            Object key = bucket.get();\n+            if (key == null)\n+              {\n+                // This bucket should be removed; it is probably\n+                // already on the reference queue.  We don't insert it\n+                // at all, and mark it as cleared.\n+                bucket.slot = -1;\n+                size--;\n+              }\n+            else\n+              {\n+                // Add this bucket to its new slot.\n+                int slot = hash(key);\n+                bucket.slot = slot;\n+                bucket.next = buckets[slot];\n+                buckets[slot] = bucket;\n+              }\n+            bucket = nextBucket;\n+          }\n       }\n   }\n \n   /**\n    * Finds the entry corresponding to key.  Since it returns an Entry\n    * it will also prevent the key from being removed under us.\n-   * @param key the key. It may be null.\n-   * @return The WeakBucket.Entry or null, if the key wasn't found.\n+   * @param key the key, may be null\n+   * @return The WeakBucket.WeakEntry or null, if the key wasn't found.\n    */\n-  private WeakBucket.Entry internalGet(Object key)\n+  private WeakBucket.WeakEntry internalGet(Object key)\n   {\n     if (key == null)\n       key = NULL_KEY;\n     int slot = hash(key);\n     WeakBucket bucket = buckets[slot];\n     while (bucket != null)\n       {\n-\tWeakBucket.Entry entry = bucket.getEntry();\n-\tif (entry != null && key.equals(entry.key))\n-\t  return entry;\n+        WeakBucket.WeakEntry entry = bucket.getEntry();\n+        if (entry != null && key.equals(entry.key))\n+          return entry;\n \n-\tbucket = bucket.next;\n+        bucket = bucket.next;\n       }\n     return null;\n   }\n@@ -595,41 +659,40 @@ private void internalAdd(Object key, Object value)\n   /**\n    * Removes a bucket from this hash map, if it wasn't removed before\n    * (e.g. one time through rehashing and one time through reference queue)\n-   * @param bucket the bucket to remove.  \n+   * @param bucket the bucket to remove.\n    */\n   private void internalRemove(WeakBucket bucket)\n   {\n     int slot = bucket.slot;\n     if (slot == -1)\n-      /* this bucket was already removed. */\n+      // This bucket was already removed.\n       return;\n \n-    /* mark the bucket as removed.  This is necessary, since the\n-     * bucket may be enqueued later by the garbage collection and\n-     * internalRemove, will be called a second time.  \n-     */\n+    // Mark the bucket as removed.  This is necessary, since the\n+    // bucket may be enqueued later by the garbage collection, and\n+    // internalRemove will be called a second time.\n     bucket.slot = -1;\n     if (buckets[slot] == bucket)\n       buckets[slot] = bucket.next;\n     else\n       {\n-\tWeakBucket prev = buckets[slot];\n-\t/* This may throw a NullPointerException.  It shouldn't but if\n-\t * a race condition occurred (two threads removing the same\n-\t * bucket at the same time) it may happen.  <br>\n-\t * But with race condition many much worse things may happen\n-\t * anyway.\n-\t */\n-\twhile (prev.next != bucket)\n-\t  prev = prev.next;\n-\tprev.next = bucket.next;\n+        WeakBucket prev = buckets[slot];\n+        /* This may throw a NullPointerException.  It shouldn't but if\n+         * a race condition occurred (two threads removing the same\n+         * bucket at the same time) it may happen.  <br>\n+         * But with race condition many much worse things may happen\n+         * anyway.\n+         */\n+        while (prev.next != bucket)\n+          prev = prev.next;\n+        prev.next = bucket.next;\n       }\n     size--;\n   }\n \n   /**\n    * Returns the size of this hash map.  Note that the size() may shrink\n-   * spontanously, if the some of the keys were only weakly reachable.\n+   * spontaneously, if the some of the keys were only weakly reachable.\n    * @return the number of entries in this hash map.\n    */\n   public int size()\n@@ -651,9 +714,10 @@ public boolean isEmpty()\n \n   /**\n    * Tells if the map contains the given key.  Note that the result\n-   * may change spontanously, if all the key was only weakly\n-   * reachable.  \n-   * @return true, iff the map contains an entry for the given key. \n+   * may change spontanously, if the key was only weakly\n+   * reachable.\n+   * @param key the key to look for\n+   * @return true, iff the map contains an entry for the given key.\n    */\n   public boolean containsKey(Object key)\n   {\n@@ -662,57 +726,57 @@ public boolean containsKey(Object key)\n   }\n \n   /**\n-   * Gets the value the key will be mapped to.\n+   * Gets the value the key is mapped to.\n    * @return the value the key was mapped to.  It returns null if\n-   * the key wasn't in this map, or if the mapped value was explicitly\n-   * set to null.  \n+   *         the key wasn't in this map, or if the mapped value was\n+   *         explicitly set to null.\n    */\n   public Object get(Object key)\n   {\n     cleanQueue();\n-    WeakBucket.Entry entry = internalGet(key);\n+    WeakBucket.WeakEntry entry = internalGet(key);\n     return entry == null ? null : entry.getValue();\n   }\n \n   /**\n    * Adds a new key/value mapping to this map.\n-   * @param key the key. This may be null.\n-   * @param value the value. This may be null.\n+   * @param key the key, may be null\n+   * @param value the value, may be null\n    * @return the value the key was mapped to previously.  It returns\n-   * null if the key wasn't in this map, or if the mapped value was\n-   * explicitly set to null.  \n+   *         null if the key wasn't in this map, or if the mapped value\n+   *         was explicitly set to null.\n    */\n   public Object put(Object key, Object value)\n   {\n     cleanQueue();\n-    WeakBucket.Entry entry = internalGet(key);\n+    WeakBucket.WeakEntry entry = internalGet(key);\n     if (entry != null)\n       return entry.setValue(value);\n \n+    modCount++;\n     if (size >= threshold)\n       rehash();\n \n     internalAdd(key, value);\n-    modCount++;\n     return null;\n   }\n \n   /**\n    * Removes the key and the corresponding value from this map.\n    * @param key the key. This may be null.\n    * @return the value the key was mapped to previously.  It returns\n-   * null if the key wasn't in this map, or if the mapped value was\n-   * explicitly set to null.  */\n+   *         null if the key wasn't in this map, or if the mapped value was\n+   *         explicitly set to null.\n+   */\n   public Object remove(Object key)\n   {\n     cleanQueue();\n-    WeakBucket.Entry entry = internalGet(key);\n+    WeakBucket.WeakEntry entry = internalGet(key);\n     if (entry == null)\n-      {\n-\treturn null;\n-      }\n-    internalRemove(entry.getBucket());\n+      return null;\n+\n     modCount++;\n+    internalRemove(entry.getBucket());\n     return entry.getValue();\n   }\n \n@@ -721,11 +785,71 @@ public Object remove(Object key)\n    * set will not have strong references to the keys, so they can be\n    * silently removed.  The returned set has therefore the same\n    * strange behaviour (shrinking size(), disappearing entries) as\n-   * this weak hash map.  \n-   * @return a set representation of the entries.  */\n+   * this weak hash map.\n+   * @return a set representation of the entries.\n+   */\n   public Set entrySet()\n   {\n     cleanQueue();\n     return theEntrySet;\n   }\n+\n+  /**\n+   * Clears all entries from this map.\n+   */\n+  public void clear()\n+  {\n+    super.clear();\n+  }\n+\n+  /**\n+   * Returns true if the map contains at least one key which points to\n+   * the specified object as a value.  Note that the result\n+   * may change spontanously, if its key was only weakly reachable.\n+   * @param value the value to search for\n+   * @return true if it is found in the set.\n+   */\n+  public boolean containsValue(Object value)\n+  {\n+    cleanQueue();\n+    return super.containsValue(value);\n+  }\n+\n+  /**\n+   * Returns a set representation of the keys in this map.  This\n+   * set will not have strong references to the keys, so they can be\n+   * silently removed.  The returned set has therefore the same\n+   * strange behaviour (shrinking size(), disappearing entries) as\n+   * this weak hash map.\n+   * @return a set representation of the keys.\n+   */\n+  public Set keySet()\n+  {\n+    cleanQueue();\n+    return super.keySet();\n+  }\n+\n+  /**\n+   * Puts all of the mappings from the given map into this one. If the\n+   * key already exists in this map, its value is replaced.\n+   * @param m the map to copy in\n+   */\n+  public void putAll(Map m)\n+  {\n+    super.putAll(m);\n+  }\n+\n+  /**\n+   * Returns a collection representation of the values in this map.  This\n+   * collection will not have strong references to the keys, so mappings\n+   * can be silently removed.  The returned collection has therefore the same\n+   * strange behaviour (shrinking size(), disappearing entries) as\n+   * this weak hash map.\n+   * @return a collection representation of the values.\n+   */\n+  public Collection values()\n+  {\n+    cleanQueue();\n+    return super.values();\n+  }\n }"}]}