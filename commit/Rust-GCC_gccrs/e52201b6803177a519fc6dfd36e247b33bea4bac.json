{"sha": "e52201b6803177a519fc6dfd36e247b33bea4bac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTUyMjAxYjY4MDMxNzdhNTE5ZmM2ZGZkMzZlMjQ3YjMzYmVhNGJhYw==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2009-08-06T11:31:20Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2009-08-06T11:31:20Z"}, "message": "tree-ssa.c (useless_type_conversion_p_1): Make function and array type comparisons frontend independent.\n\n2009-08-06  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-ssa.c (useless_type_conversion_p_1): Make function and\n\tarray type comparisons frontend independent.\n\t* Makefile.in (tree-ssa.o): Add $(TARGET_H) dependency.\n\t* tree-ssa-sccvn.c (copy_reference_ops_from_ref): Always fill\n\tout array reference lower bound and element size operands.\n\t(ao_ref_init_from_vn_reference): Properly compute the offset\n\tfor ARRAY_RANGE_REF.\n\t(vn_reference_fold_indirect): Fill out array reference lower\n\tbound and element size operands.\n\t* tree-ssa-pre.c (phi_translate_1): Fail if we have to translate\n\ta non gimple valued reference operand which can happen for\n\tarray reference lower bound or element size.\n\t(create_component_ref_by_pieces_1): Properly generate the\n\telement size operand for array references.\n\nFrom-SVN: r150519", "tree": {"sha": "c86db63d8e19ae44aa8456ce2c320f63e0d91839", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c86db63d8e19ae44aa8456ce2c320f63e0d91839"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e52201b6803177a519fc6dfd36e247b33bea4bac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e52201b6803177a519fc6dfd36e247b33bea4bac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e52201b6803177a519fc6dfd36e247b33bea4bac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e52201b6803177a519fc6dfd36e247b33bea4bac/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b92fbdd7b3eee74a74f97bf7bc74155186efa1be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b92fbdd7b3eee74a74f97bf7bc74155186efa1be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b92fbdd7b3eee74a74f97bf7bc74155186efa1be"}], "stats": {"total": 210, "additions": 168, "deletions": 42}, "files": [{"sha": "97626d63f724014963989bd2e64c99983a6a6057", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e52201b6803177a519fc6dfd36e247b33bea4bac/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e52201b6803177a519fc6dfd36e247b33bea4bac/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e52201b6803177a519fc6dfd36e247b33bea4bac", "patch": "@@ -1,3 +1,20 @@\n+2009-08-06  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-ssa.c (useless_type_conversion_p_1): Make function and\n+\tarray type comparisons frontend independent.\n+\t* Makefile.in (tree-ssa.o): Add $(TARGET_H) dependency.\n+\t* tree-ssa-sccvn.c (copy_reference_ops_from_ref): Always fill\n+\tout array reference lower bound and element size operands.\n+\t(ao_ref_init_from_vn_reference): Properly compute the offset\n+\tfor ARRAY_RANGE_REF.\n+\t(vn_reference_fold_indirect): Fill out array reference lower\n+\tbound and element size operands.\n+\t* tree-ssa-pre.c (phi_translate_1): Fail if we have to translate\n+\ta non gimple valued reference operand which can happen for\n+\tarray reference lower bound or element size.\n+\t(create_component_ref_by_pieces_1): Properly generate the\n+\telement size operand for array references.\n+\n 2009-08-06  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/40964"}, {"sha": "4df47353b4916a66dde288299b3b061e579a61bf", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e52201b6803177a519fc6dfd36e247b33bea4bac/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e52201b6803177a519fc6dfd36e247b33bea4bac/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=e52201b6803177a519fc6dfd36e247b33bea4bac", "patch": "@@ -2193,7 +2193,7 @@ tree-ssa.o : tree-ssa.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(TOPLEV_H) $(FUNCTION_H) $(TIMEVAR_H) $(TM_H) coretypes.h \\\n    $(TREE_DUMP_H) langhooks.h $(TREE_PASS_H) $(BASIC_BLOCK_H) $(BITMAP_H) \\\n    $(FLAGS_H) $(GGC_H) hard-reg-set.h $(HASHTAB_H) pointer-set.h \\\n-   $(GIMPLE_H) $(TREE_INLINE_H) $(VARRAY_H)\n+   $(GIMPLE_H) $(TREE_INLINE_H) $(VARRAY_H) $(TARGET_H)\n tree-into-ssa.o : tree-into-ssa.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) output.h $(DIAGNOSTIC_H) \\\n    $(FUNCTION_H) $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\"}, {"sha": "c09f3ae901ed95b4a2409d656419cefbdb93c7d2", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e52201b6803177a519fc6dfd36e247b33bea4bac/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e52201b6803177a519fc6dfd36e247b33bea4bac/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=e52201b6803177a519fc6dfd36e247b33bea4bac", "patch": "@@ -1600,6 +1600,9 @@ phi_translate_1 (pre_expr expr, bitmap_set_t set1, bitmap_set_t set2,\n \t\telse if (!opresult)\n \t\t  break;\n \t      }\n+\t    /* We can't possibly insert these.  */\n+\t    else if (op1 && !is_gimple_min_invariant (op1))\n+\t      break;\n \t    changed |= op1 != oldop1;\n \t    if (op2 && TREE_CODE (op2) == SSA_NAME)\n \t      {\n@@ -1617,6 +1620,9 @@ phi_translate_1 (pre_expr expr, bitmap_set_t set1, bitmap_set_t set2,\n \t\telse if (!opresult)\n \t\t  break;\n \t      }\n+\t    /* We can't possibly insert these.  */\n+\t    else if (op2 && !is_gimple_min_invariant (op2))\n+\t      break;\n \t    changed |= op2 != oldop2;\n \n \t    if (!newoperands)\n@@ -2742,7 +2748,8 @@ create_component_ref_by_pieces_1 (basic_block block, vn_reference_t ref,\n \tpre_expr op1expr;\n \ttree genop2 = currop->op1;\n \tpre_expr op2expr;\n-\ttree genop3;\n+\ttree genop3 = currop->op2;\n+\tpre_expr op3expr;\n \tgenop0 = create_component_ref_by_pieces_1 (block, ref, operand,\n \t\t\t\t\t\t   stmts, domstmt);\n \tif (!genop0)\n@@ -2759,8 +2766,17 @@ create_component_ref_by_pieces_1 (basic_block block, vn_reference_t ref,\n \t    if (!genop2)\n \t      return NULL_TREE;\n \t  }\n-\n-\tgenop3 = currop->op2;\n+\tif (genop3)\n+\t  {\n+\t    tree elmt_type = TREE_TYPE (TREE_TYPE (genop0));\n+\t    genop3 = size_binop (EXACT_DIV_EXPR, genop3,\n+\t\t\t\t size_int (TYPE_ALIGN_UNIT (elmt_type)));\n+\t    op3expr = get_or_alloc_expr_for (genop3);\n+\t    genop3 = find_or_generate_expression (block, op3expr, stmts,\n+\t\t\t\t\t\t  domstmt);\n+\t    if (!genop3)\n+\t      return NULL_TREE;\n+\t  }\n \treturn build4 (currop->opcode, currop->type, genop0, genop1,\n \t\t       genop2, genop3);\n       }"}, {"sha": "3d814fc2e0bb023d62c6fa06b526841738094953", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 12, "deletions": 23, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e52201b6803177a519fc6dfd36e247b33bea4bac/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e52201b6803177a519fc6dfd36e247b33bea4bac/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=e52201b6803177a519fc6dfd36e247b33bea4bac", "patch": "@@ -561,18 +561,9 @@ copy_reference_ops_from_ref (tree ref, VEC(vn_reference_op_s, heap) **result)\n \tcase ARRAY_REF:\n \t  /* Record index as operand.  */\n \t  temp.op0 = TREE_OPERAND (ref, 1);\n-\t  /* Record even constant lower bounds.  */\n-\t  if (TREE_OPERAND (ref, 2))\n-\t    temp.op1 = TREE_OPERAND (ref, 2);\n-\t  else\n-\t    {\n-\t      tree domain = TYPE_DOMAIN (TREE_TYPE (TREE_OPERAND (ref, 0)));\n-\t      if (domain\n-\t\t  && TYPE_MIN_VALUE (domain)\n-\t\t  && !integer_zerop (TYPE_MIN_VALUE (domain)))\n-\t\ttemp.op1 = TYPE_MIN_VALUE (domain);\n-\t    }\n-\t  temp.op2 = TREE_OPERAND (ref, 3);\n+\t  /* Always record lower bounds and element size.  */\n+\t  temp.op1 = array_ref_low_bound (ref);\n+\t  temp.op2 = array_ref_element_size (ref);\n \t  break;\n \tcase STRING_CST:\n \tcase INTEGER_CST:\n@@ -731,19 +722,17 @@ ao_ref_init_from_vn_reference (ao_ref *ref,\n \n \tcase ARRAY_RANGE_REF:\n \tcase ARRAY_REF:\n-\t  /* Same for ARRAY_REFs.  We do not have access to the array\n-\t     type here, but we recorded the lower bound in op1.  */\n-\t  if (op->op2\n-\t      || !host_integerp (op->op0, 0)\n-\t      || (op->op1 && !host_integerp (op->op1, 0))\n-\t      || !host_integerp (TYPE_SIZE (op->type), 1))\n+\t  /* We recorded the lower bound and the element size.  */\n+\t  if (!host_integerp (op->op0, 0)\n+\t      || !host_integerp (op->op1, 0)\n+\t      || !host_integerp (op->op2, 0))\n \t    max_size = -1;\n \t  else\n \t    {\n \t      HOST_WIDE_INT hindex = TREE_INT_CST_LOW (op->op0);\n-\t      if (op->op1)\n-\t\thindex -= TREE_INT_CST_LOW (op->op1);\n-\t      hindex *= TREE_INT_CST_LOW (TYPE_SIZE (op->type));\n+\t      hindex -= TREE_INT_CST_LOW (op->op1);\n+\t      hindex *= TREE_INT_CST_LOW (op->op2);\n+\t      hindex *= BITS_PER_UNIT;\n \t      offset += hindex;\n \t    }\n \t  break;\n@@ -863,8 +852,8 @@ vn_reference_fold_indirect (VEC (vn_reference_op_s, heap) **ops,\n       if ((dom = TYPE_DOMAIN (TREE_TYPE (TREE_OPERAND (op->op0, 0))))\n \t  && TYPE_MIN_VALUE (dom))\n \taref.op0 = TYPE_MIN_VALUE (dom);\n-      aref.op1 = NULL_TREE;\n-      aref.op2 = NULL_TREE;\n+      aref.op1 = aref.op0;\n+      aref.op2 = TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (op->op0)));\n       VEC_safe_push (vn_reference_op_s, heap, mem, &aref);\n     }\n   copy_reference_ops_from_ref (TREE_OPERAND (op->op0, 0), &mem);"}, {"sha": "0b4cc964ee7fc16408fbab7f44c7b5848adde8a7", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 119, "deletions": 15, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e52201b6803177a519fc6dfd36e247b33bea4bac/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e52201b6803177a519fc6dfd36e247b33bea4bac/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=e52201b6803177a519fc6dfd36e247b33bea4bac", "patch": "@@ -26,6 +26,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"flags.h\"\n #include \"rtl.h\"\n #include \"tm_p.h\"\n+#include \"target.h\"\n #include \"ggc.h\"\n #include \"langhooks.h\"\n #include \"hard-reg-set.h\"\n@@ -871,8 +872,10 @@ useless_type_conversion_p_1 (tree outer_type, tree inner_type)\n       && TYPE_CANONICAL (inner_type) == TYPE_CANONICAL (outer_type))\n     return true;\n \n-  /* Changes in machine mode are never useless conversions.  */\n-  if (TYPE_MODE (inner_type) != TYPE_MODE (outer_type))\n+  /* Changes in machine mode are never useless conversions unless we\n+     deal with aggregate types in which case we defer to later checks.  */\n+  if (TYPE_MODE (inner_type) != TYPE_MODE (outer_type)\n+      && !AGGREGATE_TYPE_P (inner_type))\n     return false;\n \n   /* If both the inner and outer types are integral types, then the\n@@ -919,6 +922,11 @@ useless_type_conversion_p_1 (tree outer_type, tree inner_type)\n \t  && TYPE_VOLATILE (TREE_TYPE (outer_type)))\n \treturn false;\n \n+      /* We require explicit conversions from incomplete target types.  */\n+      if (!COMPLETE_TYPE_P (TREE_TYPE (inner_type))\n+\t  && COMPLETE_TYPE_P (TREE_TYPE (outer_type)))\n+\treturn false;\n+\n       /* Do not lose casts between pointers that when dereferenced access\n \t memory with different alias sets.  */\n       if (get_deref_alias_set (inner_type) != get_deref_alias_set (outer_type))\n@@ -948,33 +956,129 @@ useless_type_conversion_p_1 (tree outer_type, tree inner_type)\n     return useless_type_conversion_p (TREE_TYPE (outer_type),\n \t\t\t\t      TREE_TYPE (inner_type));\n \n-  /* For aggregates we may need to fall back to structural equality\n-     checks.  */\n-  else if (AGGREGATE_TYPE_P (inner_type)\n-\t   && AGGREGATE_TYPE_P (outer_type))\n+  else if (TREE_CODE (inner_type) == ARRAY_TYPE\n+\t   && TREE_CODE (outer_type) == ARRAY_TYPE)\n     {\n-      /* Different types of aggregates are incompatible.  */\n-      if (TREE_CODE (inner_type) != TREE_CODE (outer_type))\n+      /* Preserve string attributes.  */\n+      if (TYPE_STRING_FLAG (inner_type) != TYPE_STRING_FLAG (outer_type))\n \treturn false;\n \n       /* Conversions from array types with unknown extent to\n \t array types with known extent are not useless.  */\n-      if (TREE_CODE (inner_type) == ARRAY_TYPE\n-\t  && !TYPE_DOMAIN (inner_type)\n+      if (!TYPE_DOMAIN (inner_type)\n \t  && TYPE_DOMAIN (outer_type))\n \treturn false;\n \n+      /* Nor are conversions from array types with non-constant size to\n+         array types with constant size or to different size.  */\n+      if (TYPE_SIZE (outer_type)\n+\t  && TREE_CODE (TYPE_SIZE (outer_type)) == INTEGER_CST\n+\t  && (!TYPE_SIZE (inner_type)\n+\t      || TREE_CODE (TYPE_SIZE (inner_type)) != INTEGER_CST\n+\t      || !tree_int_cst_equal (TYPE_SIZE (outer_type),\n+\t\t\t\t      TYPE_SIZE (inner_type))))\n+\treturn false;\n+\n+      /* Check conversions between arrays with partially known extents.\n+\t If the array min/max values are constant they have to match.\n+\t Otherwise allow conversions to unknown and variable extents.\n+\t In particular this declares conversions that may change the\n+\t mode to BLKmode as useless.  */\n+      if (TYPE_DOMAIN (inner_type)\n+\t  && TYPE_DOMAIN (outer_type)\n+\t  && TYPE_DOMAIN (inner_type) != TYPE_DOMAIN (outer_type))\n+\t{\n+\t  tree inner_min = TYPE_MIN_VALUE (TYPE_DOMAIN (inner_type));\n+\t  tree outer_min = TYPE_MIN_VALUE (TYPE_DOMAIN (outer_type));\n+\t  tree inner_max = TYPE_MAX_VALUE (TYPE_DOMAIN (inner_type));\n+\t  tree outer_max = TYPE_MAX_VALUE (TYPE_DOMAIN (outer_type));\n+\n+\t  /* After gimplification a variable min/max value carries no\n+\t     additional information compared to a NULL value.  All that\n+\t     matters has been lowered to be part of the IL.  */\n+\t  if (inner_min && TREE_CODE (inner_min) != INTEGER_CST)\n+\t    inner_min = NULL_TREE;\n+\t  if (outer_min && TREE_CODE (outer_min) != INTEGER_CST)\n+\t    outer_min = NULL_TREE;\n+\t  if (inner_max && TREE_CODE (inner_max) != INTEGER_CST)\n+\t    inner_max = NULL_TREE;\n+\t  if (outer_max && TREE_CODE (outer_max) != INTEGER_CST)\n+\t    outer_max = NULL_TREE;\n+\n+\t  /* Conversions NULL / variable <- cst are useless, but not\n+\t     the other way around.  */\n+\t  if (outer_min\n+\t      && (!inner_min\n+\t\t  || !tree_int_cst_equal (inner_min, outer_min)))\n+\t    return false;\n+\t  if (outer_max\n+\t      && (!inner_max\n+\t\t  || !tree_int_cst_equal (inner_max, outer_max)))\n+\t    return false;\n+\t}\n+\n+      /* Recurse on the element check.  */\n+      return useless_type_conversion_p (TREE_TYPE (outer_type),\n+\t\t\t\t\tTREE_TYPE (inner_type));\n+    }\n+\n+  else if ((TREE_CODE (inner_type) == FUNCTION_TYPE\n+\t    || TREE_CODE (inner_type) == METHOD_TYPE)\n+\t   && TREE_CODE (inner_type) == TREE_CODE (outer_type))\n+    {\n+      tree outer_parm, inner_parm;\n+\n+      /* If the return types are not compatible bail out.  */\n+      if (!useless_type_conversion_p (TREE_TYPE (outer_type),\n+\t\t\t\t      TREE_TYPE (inner_type)))\n+\treturn false;\n+\n+      /* Method types should belong to a compatible base class.  */\n+      if (TREE_CODE (inner_type) == METHOD_TYPE\n+\t  && !useless_type_conversion_p (TYPE_METHOD_BASETYPE (outer_type),\n+\t\t\t\t\t TYPE_METHOD_BASETYPE (inner_type)))\n+\treturn false;\n+\n+      /* A conversion to an unprototyped argument list is ok.  */\n+      if (!TYPE_ARG_TYPES (outer_type))\n+\treturn true;\n+\n+      /* If the argument types are compatible the conversion is useless.  */\n+      if (TYPE_ARG_TYPES (outer_type) == TYPE_ARG_TYPES (inner_type))\n+\treturn true;\n+\n+      for (outer_parm = TYPE_ARG_TYPES (outer_type),\n+\t   inner_parm = TYPE_ARG_TYPES (inner_type);\n+\t   outer_parm && inner_parm;\n+\t   outer_parm = TREE_CHAIN (outer_parm),\n+\t   inner_parm = TREE_CHAIN (inner_parm))\n+\tif (!useless_type_conversion_p (TREE_VALUE (outer_parm),\n+\t\t\t\t\tTREE_VALUE (inner_parm)))\n+\t  return false;\n+\n+      /* If there is a mismatch in the number of arguments the functions\n+\t are not compatible.  */\n+      if (outer_parm || inner_parm)\n+\treturn false;\n+\n+      /* Defer to the target if necessary.  */\n+      if (TYPE_ATTRIBUTES (inner_type) || TYPE_ATTRIBUTES (outer_type))\n+\treturn targetm.comp_type_attributes (outer_type, inner_type) != 0;\n+\n+      return true;\n+    }\n+\n+  /* For aggregates we may need to fall back to structural equality\n+     checks.  */\n+  else if (AGGREGATE_TYPE_P (inner_type)\n+\t   && TREE_CODE (inner_type) == TREE_CODE (outer_type))\n+    {\n       /* ???  This seems to be necessary even for aggregates that don't\n \t have TYPE_STRUCTURAL_EQUALITY_P set.  */\n \n       /* ???  This should eventually just return false.  */\n       return lang_hooks.types_compatible_p (inner_type, outer_type);\n     }\n-  /* Also for functions and possibly other types with\n-     TYPE_STRUCTURAL_EQUALITY_P set.  */\n-  else if (TYPE_STRUCTURAL_EQUALITY_P (inner_type)\n-\t   && TYPE_STRUCTURAL_EQUALITY_P (outer_type))\n-    return lang_hooks.types_compatible_p (inner_type, outer_type);\n   \n   return false;\n }"}]}