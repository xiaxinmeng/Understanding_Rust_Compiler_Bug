{"sha": "3f99b0612f7db76b6ed1a25ecce8fa327eec9f61", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Y5OWIwNjEyZjdkYjc2YjZlZDFhMjVlY2NlOGZhMzI3ZWVjOWY2MQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2014-09-19T19:36:57Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2014-09-19T19:36:57Z"}, "message": "predicates.md (fusion_gpr_mem_load): Move testing for base_reg_operand to be common between LO_SUM and PLUS.\n\n2014-09-19  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* config/rs6000/predicates.md (fusion_gpr_mem_load): Move testing\n\tfor base_reg_operand to be common between LO_SUM and PLUS.\n\t(fusion_gpr_mem_combo): New predicate to match a fused address\n\tthat combines the addis and memory offset address.\n\n\t* config/rs6000/rs6000-protos.h (fusion_gpr_load_p): Change\n\tcalling signature.\n\t(emit_fusion_gpr_load): Likewise.\n\n\t* config/rs6000/rs6000.c (fusion_gpr_load_p): Change calling\n\tsignature to pass each argument separately, rather than\n\tusing an operands array.  Rewrite the insns found by peephole2 to\n\tbe a single insn, rather than hoping the insns will still be\n\ttogether when the peephole pass is done.  Drop being called via a\n\tnormal peephole.\n\t(emit_fusion_gpr_load): Change calling signature to be called from\n\tthe fusion_gpr_load_<mode> insns with a combined memory address\n\tinstead of the peephole pass passing the addis and offset\n\tseparately.\n\n\t* config/rs6000/rs6000.md (UNSPEC_FUSION_GPR): New unspec for GPR\n\tfusion.\n\t(power8 fusion peephole): Drop support for doing power8 via a\n\tnormal peephole that was created by the peephole2 pass.\n\t(power8 fusion peephole2): Create a new insn with the fused\n\taddress, so that the fused operation is kept together after\n\tregister allocation is done.\n\t(fusion_gpr_load_<mode>): Likewise.\n\nFrom-SVN: r215404", "tree": {"sha": "2c4b5b98291776695d4520da6754bb3ba6d54c1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2c4b5b98291776695d4520da6754bb3ba6d54c1a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f99b0612f7db76b6ed1a25ecce8fa327eec9f61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f99b0612f7db76b6ed1a25ecce8fa327eec9f61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f99b0612f7db76b6ed1a25ecce8fa327eec9f61", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f99b0612f7db76b6ed1a25ecce8fa327eec9f61/comments", "author": null, "committer": null, "parents": [{"sha": "ca21928bb3e052e0ddd0b190f83c9d8c18d7977d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca21928bb3e052e0ddd0b190f83c9d8c18d7977d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca21928bb3e052e0ddd0b190f83c9d8c18d7977d"}], "stats": {"total": 259, "additions": 150, "deletions": 109}, "files": [{"sha": "04db32adcce8f8c4dbacc994f0cb00e944ed863c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f99b0612f7db76b6ed1a25ecce8fa327eec9f61/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f99b0612f7db76b6ed1a25ecce8fa327eec9f61/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3f99b0612f7db76b6ed1a25ecce8fa327eec9f61", "patch": "@@ -1,3 +1,34 @@\n+2014-09-19  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/predicates.md (fusion_gpr_mem_load): Move testing\n+\tfor base_reg_operand to be common between LO_SUM and PLUS.\n+\t(fusion_gpr_mem_combo): New predicate to match a fused address\n+\tthat combines the addis and memory offset address.\n+\n+\t* config/rs6000/rs6000-protos.h (fusion_gpr_load_p): Change\n+\tcalling signature.\n+\t(emit_fusion_gpr_load): Likewise.\n+\n+\t* config/rs6000/rs6000.c (fusion_gpr_load_p): Change calling\n+\tsignature to pass each argument separately, rather than\n+\tusing an operands array.  Rewrite the insns found by peephole2 to\n+\tbe a single insn, rather than hoping the insns will still be\n+\ttogether when the peephole pass is done.  Drop being called via a\n+\tnormal peephole.\n+\t(emit_fusion_gpr_load): Change calling signature to be called from\n+\tthe fusion_gpr_load_<mode> insns with a combined memory address\n+\tinstead of the peephole pass passing the addis and offset\n+\tseparately.\n+\n+\t* config/rs6000/rs6000.md (UNSPEC_FUSION_GPR): New unspec for GPR\n+\tfusion.\n+\t(power8 fusion peephole): Drop support for doing power8 via a\n+\tnormal peephole that was created by the peephole2 pass.\n+\t(power8 fusion peephole2): Create a new insn with the fused\n+\taddress, so that the fused operation is kept together after\n+\tregister allocation is done.\n+\t(fusion_gpr_load_<mode>): Likewise.\n+\n 2014-09-19  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR lto/63286"}, {"sha": "379e0a25dbf3dd1990fe5a1acd50be0e12f2f2e1", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 65, "deletions": 10, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f99b0612f7db76b6ed1a25ecce8fa327eec9f61/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f99b0612f7db76b6ed1a25ecce8fa327eec9f61/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=3f99b0612f7db76b6ed1a25ecce8fa327eec9f61", "patch": "@@ -1797,7 +1797,7 @@\n (define_predicate \"fusion_gpr_mem_load\"\n   (match_code \"mem,sign_extend,zero_extend\")\n {\n-  rtx addr;\n+  rtx addr, base, offset;\n \n   /* Handle sign/zero extend.  */\n   if (GET_CODE (op) == ZERO_EXTEND\n@@ -1827,24 +1827,79 @@\n     }\n \n   addr = XEXP (op, 0);\n+  if (GET_CODE (addr) != PLUS && GET_CODE (addr) != LO_SUM)\n+    return 0;\n+\n+  base = XEXP (addr, 0);\n+  if (!base_reg_operand (base, GET_MODE (base)))\n+    return 0;\n+\n+  offset = XEXP (addr, 1);\n+\n   if (GET_CODE (addr) == PLUS)\n+    return satisfies_constraint_I (offset);\n+\n+  else if (GET_CODE (addr) == LO_SUM)\n     {\n-      rtx base = XEXP (addr, 0);\n-      rtx offset = XEXP (addr, 1);\n+      if (TARGET_XCOFF || (TARGET_ELF && TARGET_POWERPC64))\n+\treturn small_toc_ref (offset, GET_MODE (offset));\n \n-      return (base_reg_operand (base, GET_MODE (base))\n-\t      && satisfies_constraint_I (offset));\n+      else if (TARGET_ELF && !TARGET_POWERPC64)\n+\treturn CONSTANT_P (offset);\n     }\n \n-  else if (GET_CODE (addr) == LO_SUM)\n+  return 0;\n+})\n+\n+;; Match a GPR load (lbz, lhz, lwz, ld) that uses a combined address in the\n+;; memory field with both the addis and the memory offset.  Sign extension\n+;; is not handled here, since lha and lwa are not fused.\n+(define_predicate \"fusion_gpr_mem_combo\"\n+  (match_code \"mem,zero_extend\")\n+{\n+  rtx addr, base, offset;\n+\n+  /* Handle zero extend.  */\n+  if (GET_CODE (op) == ZERO_EXTEND)\n     {\n-      rtx base = XEXP (addr, 0);\n-      rtx offset = XEXP (addr, 1);\n+      op = XEXP (op, 0);\n+      mode = GET_MODE (op);\n+    }\n+\n+  if (!MEM_P (op))\n+    return 0;\n \n-      if (!base_reg_operand (base, GET_MODE (base)))\n+  switch (mode)\n+    {\n+    case QImode:\n+    case HImode:\n+    case SImode:\n+      break;\n+\n+    case DImode:\n+      if (!TARGET_POWERPC64)\n \treturn 0;\n+      break;\n \n-      else if (TARGET_XCOFF || (TARGET_ELF && TARGET_POWERPC64))\n+    default:\n+      return 0;\n+    }\n+\n+  addr = XEXP (op, 0);\n+  if (GET_CODE (addr) != PLUS && GET_CODE (addr) != LO_SUM)\n+    return 0;\n+\n+  base = XEXP (addr, 0);\n+  if (!fusion_gpr_addis (base, GET_MODE (base)))\n+    return 0;\n+\n+  offset = XEXP (addr, 1);\n+  if (GET_CODE (addr) == PLUS)\n+    return satisfies_constraint_I (offset);\n+\n+  else if (GET_CODE (addr) == LO_SUM)\n+    {\n+      if (TARGET_XCOFF || (TARGET_ELF && TARGET_POWERPC64))\n \treturn small_toc_ref (offset, GET_MODE (offset));\n \n       else if (TARGET_ELF && !TARGET_POWERPC64)"}, {"sha": "27f694b4abb484ed07b7747450d2af8298a73f0b", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f99b0612f7db76b6ed1a25ecce8fa327eec9f61/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f99b0612f7db76b6ed1a25ecce8fa327eec9f61/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=3f99b0612f7db76b6ed1a25ecce8fa327eec9f61", "patch": "@@ -80,9 +80,9 @@ extern int mems_ok_for_quad_peep (rtx, rtx);\n extern bool gpr_or_gpr_p (rtx, rtx);\n extern bool direct_move_p (rtx, rtx);\n extern bool quad_load_store_p (rtx, rtx);\n-extern bool fusion_gpr_load_p (rtx *, bool);\n+extern bool fusion_gpr_load_p (rtx, rtx, rtx, rtx);\n extern void expand_fusion_gpr_load (rtx *);\n-extern const char *emit_fusion_gpr_load (rtx *);\n+extern const char *emit_fusion_gpr_load (rtx, rtx);\n extern enum reg_class (*rs6000_preferred_reload_class_ptr) (rtx,\n \t\t\t\t\t\t\t    enum reg_class);\n extern enum reg_class (*rs6000_secondary_reload_class_ptr) (enum reg_class,"}, {"sha": "ffff264507dc29e866725c93efb5880c1f30123e", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 32, "deletions": 78, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f99b0612f7db76b6ed1a25ecce8fa327eec9f61/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f99b0612f7db76b6ed1a25ecce8fa327eec9f61/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=3f99b0612f7db76b6ed1a25ecce8fa327eec9f61", "patch": "@@ -33044,25 +33044,14 @@ rs6000_split_logical (rtx operands[3],\n \f\n /* Return true if the peephole2 can combine a load involving a combination of\n    an addis instruction and a load with an offset that can be fused together on\n-   a power8.\n-\n-   The operands are:\n-\toperands[0]\tregister set with addis\n-\toperands[1]\tvalue set via addis\n-\toperands[2]\ttarget register being loaded\n-\toperands[3]\tD-form memory reference using operands[0].\n-\n-   In addition, we are passed a boolean that is true if this is a peephole2,\n-   and we can use see if the addis_reg is dead after the insn and can be\n-   replaced by the target register.  */\n+   a power8.  */\n \n bool\n-fusion_gpr_load_p (rtx *operands, bool peep2_p)\n+fusion_gpr_load_p (rtx addis_reg,\t/* register set via addis.  */\n+\t\t   rtx addis_value,\t/* addis value.  */\n+\t\t   rtx target,\t\t/* target register that is loaded.  */\n+\t\t   rtx mem)\t\t/* bottom part of the memory addr. */\n {\n-  rtx addis_reg = operands[0];\n-  rtx addis_value = operands[1];\n-  rtx target = operands[2];\n-  rtx mem = operands[3];\n   rtx addr;\n   rtx base_reg;\n \n@@ -33076,9 +33065,6 @@ fusion_gpr_load_p (rtx *operands, bool peep2_p)\n   if (!fusion_gpr_addis (addis_value, GET_MODE (addis_value)))\n     return false;\n \n-  if (!fusion_gpr_mem_load (mem, GET_MODE (mem)))\n-    return false;\n-\n   /* Allow sign/zero extension.  */\n   if (GET_CODE (mem) == ZERO_EXTEND\n       || (GET_CODE (mem) == SIGN_EXTEND && TARGET_P8_FUSION_SIGN))\n@@ -33087,22 +33073,22 @@ fusion_gpr_load_p (rtx *operands, bool peep2_p)\n   if (!MEM_P (mem))\n     return false;\n \n+  if (!fusion_gpr_mem_load (mem, GET_MODE (mem)))\n+    return false;\n+\n   addr = XEXP (mem, 0);\t\t\t/* either PLUS or LO_SUM.  */\n   if (GET_CODE (addr) != PLUS && GET_CODE (addr) != LO_SUM)\n     return false;\n \n   /* Validate that the register used to load the high value is either the\n-     register being loaded, or we can safely replace its use in a peephole2.\n+     register being loaded, or we can safely replace its use.\n \n-     If this is a peephole2, we assume that there are 2 instructions in the\n-     peephole (addis and load), so we want to check if the target register was\n-     not used in the memory address and the register to hold the addis result\n-     is dead after the peephole.  */\n+     This function is only called from the peephole2 pass and we assume that\n+     there are 2 instructions in the peephole (addis and load), so we want to\n+     check if the target register was not used in the memory address and the\n+     register to hold the addis result is dead after the peephole.  */\n   if (REGNO (addis_reg) != REGNO (target))\n     {\n-      if (!peep2_p)\n-\treturn false;\n-\n       if (reg_mentioned_p (target, mem))\n \treturn false;\n \n@@ -33143,9 +33129,6 @@ expand_fusion_gpr_load (rtx *operands)\n   enum machine_mode extend_mode = target_mode;\n   enum machine_mode ptr_mode = Pmode;\n   enum rtx_code extend = UNKNOWN;\n-  rtx addis_reg = ((ptr_mode == target_mode)\n-\t\t   ? target\n-\t\t   : simplify_subreg (ptr_mode, target, target_mode, 0));\n \n   if (GET_CODE (orig_mem) == ZERO_EXTEND\n       || (TARGET_P8_FUSION_SIGN && GET_CODE (orig_mem) == SIGN_EXTEND))\n@@ -33162,13 +33145,14 @@ expand_fusion_gpr_load (rtx *operands)\n   gcc_assert (plus_or_lo_sum == PLUS || plus_or_lo_sum == LO_SUM);\n \n   offset = XEXP (orig_addr, 1);\n-  new_addr = gen_rtx_fmt_ee (plus_or_lo_sum, ptr_mode, addis_reg, offset);\n-  new_mem = change_address (orig_mem, target_mode, new_addr);\n+  new_addr = gen_rtx_fmt_ee (plus_or_lo_sum, ptr_mode, addis_value, offset);\n+  new_mem = replace_equiv_address_nv (orig_mem, new_addr, false);\n \n   if (extend != UNKNOWN)\n     new_mem = gen_rtx_fmt_e (ZERO_EXTEND, extend_mode, new_mem);\n \n-  emit_insn (gen_rtx_SET (VOIDmode, addis_reg, addis_value));\n+  new_mem = gen_rtx_UNSPEC (extend_mode, gen_rtvec (1, new_mem),\n+\t\t\t    UNSPEC_FUSION_GPR);\n   emit_insn (gen_rtx_SET (VOIDmode, target, new_mem));\n \n   if (extend == SIGN_EXTEND)\n@@ -33187,55 +33171,40 @@ expand_fusion_gpr_load (rtx *operands)\n }\n \n /* Return a string to fuse an addis instruction with a gpr load to the same\n-   register that we loaded up the addis instruction.  The code is complicated,\n-   so we call output_asm_insn directly, and just return \"\".\n+   register that we loaded up the addis instruction.  The address that is used\n+   is the logical address that was formed during peephole2:\n+\t(lo_sum (high) (low-part))\n \n-   The operands are:\n-\toperands[0]\tregister set with addis (must be same reg as target).\n-\toperands[1]\tvalue set via addis\n-\toperands[2]\ttarget register being loaded\n-\toperands[3]\tD-form memory reference using operands[0].  */\n+   The code is complicated, so we call output_asm_insn directly, and just\n+   return \"\".  */\n \n const char *\n-emit_fusion_gpr_load (rtx *operands)\n+emit_fusion_gpr_load (rtx target, rtx mem)\n {\n-  rtx addis_reg = operands[0];\n-  rtx addis_value = operands[1];\n-  rtx target = operands[2];\n-  rtx mem = operands[3];\n+  rtx addis_value;\n   rtx fuse_ops[10];\n   rtx addr;\n   rtx load_offset;\n   const char *addis_str = NULL;\n   const char *load_str = NULL;\n-  const char *extend_insn = NULL;\n   const char *mode_name = NULL;\n   char insn_template[80];\n   enum machine_mode mode;\n   const char *comment_str = ASM_COMMENT_START;\n-  bool sign_p = false;\n-\n-  gcc_assert (REG_P (addis_reg) && REG_P (target));\n-  gcc_assert (REGNO (addis_reg) == REGNO (target));\n-\n-  if (*comment_str == ' ')\n-    comment_str++;\n \n-  /* Allow sign/zero extension.  */\n   if (GET_CODE (mem) == ZERO_EXTEND)\n     mem = XEXP (mem, 0);\n \n-  else if (GET_CODE (mem) == SIGN_EXTEND && TARGET_P8_FUSION_SIGN)\n-    {\n-      sign_p = true;\n-      mem = XEXP (mem, 0);\n-    }\n+  gcc_assert (REG_P (target) && MEM_P (mem));\n+\n+  if (*comment_str == ' ')\n+    comment_str++;\n \n-  gcc_assert (MEM_P (mem));\n   addr = XEXP (mem, 0);\n   if (GET_CODE (addr) != PLUS && GET_CODE (addr) != LO_SUM)\n     gcc_unreachable ();\n \n+  addis_value = XEXP (addr, 0);\n   load_offset = XEXP (addr, 1);\n \n   /* Now emit the load instruction to the same register.  */\n@@ -33245,29 +33214,22 @@ emit_fusion_gpr_load (rtx *operands)\n     case QImode:\n       mode_name = \"char\";\n       load_str = \"lbz\";\n-      extend_insn = \"extsb %0,%0\";\n       break;\n \n     case HImode:\n       mode_name = \"short\";\n       load_str = \"lhz\";\n-      extend_insn = \"extsh %0,%0\";\n       break;\n \n     case SImode:\n       mode_name = \"int\";\n       load_str = \"lwz\";\n-      extend_insn = \"extsw %0,%0\";\n       break;\n \n     case DImode:\n-      if (TARGET_POWERPC64)\n-\t{\n-\t  mode_name = \"long\";\n-\t  load_str = \"ld\";\n-\t}\n-      else\n-\tgcc_unreachable ();\n+      gcc_assert (TARGET_POWERPC64);\n+      mode_name = \"long\";\n+      load_str = \"ld\";\n       break;\n \n     default:\n@@ -33411,14 +33373,6 @@ emit_fusion_gpr_load (rtx *operands)\n   else\n     fatal_insn (\"Unable to generate load offset for fusion\", load_offset);\n \n-  /* Handle sign extension.  The peephole2 pass generates this as a separate\n-     insn, but we handle it just in case it got reattached.  */\n-  if (sign_p)\n-    {\n-      gcc_assert (extend_insn != NULL);\n-      output_asm_insn (extend_insn, fuse_ops);\n-    }\n-\n   return \"\";\n }\n \f"}, {"sha": "d8264ca0b5e157b8475c09579025292aee45d370", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f99b0612f7db76b6ed1a25ecce8fa327eec9f61/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f99b0612f7db76b6ed1a25ecce8fa327eec9f61/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=3f99b0612f7db76b6ed1a25ecce8fa327eec9f61", "patch": "@@ -137,6 +137,7 @@\n    UNSPEC_UNPACK_128BIT\n    UNSPEC_PACK_128BIT\n    UNSPEC_LSQ\n+   UNSPEC_FUSION_GPR\n   ])\n \n ;;\n@@ -14296,38 +14297,38 @@\n ;; a GPR.  The addis instruction must be adjacent to the load, and use the same\n ;; register that is being loaded.  The fused ops must be physically adjacent.\n \n-;; We use define_peephole for the actual addis/load, and the register used to\n-;; hold the addis value must be the same as the register being loaded.  We use\n-;; define_peephole2 to change the register used for addis to be the register\n-;; being loaded, since we can look at whether it is dead after the load insn.\n-\n-(define_peephole\n-  [(set (match_operand:P 0 \"base_reg_operand\" \"\")\n-\t(match_operand:P 1 \"fusion_gpr_addis\" \"\"))\n-   (set (match_operand:INT1 2 \"base_reg_operand\" \"\")\n-\t(match_operand:INT1 3 \"fusion_gpr_mem_load\" \"\"))]\n-  \"TARGET_P8_FUSION && fusion_gpr_load_p (operands, false)\"\n-{\n-  return emit_fusion_gpr_load (operands);\n-}\n-  [(set_attr \"type\" \"load\")\n-   (set_attr \"length\" \"8\")])\n+;; Find cases where the addis that feeds into a load instruction is either used\n+;; once or is the same as the target register, and replace it with the fusion\n+;; insn\n \n (define_peephole2\n   [(set (match_operand:P 0 \"base_reg_operand\" \"\")\n \t(match_operand:P 1 \"fusion_gpr_addis\" \"\"))\n    (set (match_operand:INT1 2 \"base_reg_operand\" \"\")\n \t(match_operand:INT1 3 \"fusion_gpr_mem_load\" \"\"))]\n   \"TARGET_P8_FUSION\n-   && (REGNO (operands[0]) != REGNO (operands[2])\n-       || GET_CODE (operands[3]) == SIGN_EXTEND)\n-   && fusion_gpr_load_p (operands, true)\"\n+   && fusion_gpr_load_p (operands[0], operands[1], operands[2],\n+\t\t\t operands[3])\"\n   [(const_int 0)]\n {\n   expand_fusion_gpr_load (operands);\n   DONE;\n })\n \n+;; Fusion insn, created by the define_peephole2 above (and eventually by\n+;; reload)\n+\n+(define_insn \"fusion_gpr_load_<mode>\"\n+  [(set (match_operand:INT1 0 \"base_reg_operand\" \"=&b\")\n+\t(unspec:INT1 [(match_operand:INT1 1 \"fusion_gpr_mem_combo\" \"\")]\n+\t\t     UNSPEC_FUSION_GPR))]\n+  \"TARGET_P8_FUSION\"\n+{\n+  return emit_fusion_gpr_load (operands[0], operands[1]);\n+}\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"8\")])\n+\n \f\n ;; Miscellaneous ISA 2.06 (power7) instructions\n (define_insn \"addg6s\""}]}