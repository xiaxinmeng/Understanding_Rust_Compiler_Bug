{"sha": "61c4c989034548f481d1f10198447be27fb9a55f", "node_id": "C_kwDOANBUbNoAKDYxYzRjOTg5MDM0NTQ4ZjQ4MWQxZjEwMTk4NDQ3YmUyN2ZiOWE1NWY", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2022-08-30T14:43:47Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2022-08-30T14:43:47Z"}, "message": "Extend SLP permutation optimisations\n\nCurrently SLP tries to force permute operations \"down\" the graph\nfrom loads in the hope of reducing the total number of permutations\nneeded or (in the best case) removing the need for the permutations\nentirely.  This patch tries to extend it as follows:\n\n- Allow loads to take a different permutation from the one they\n  started with, rather than choosing between \"original permutation\"\n  and \"no permutation\".\n\n- Allow changes in both directions, if the target supports the\n  reverse permutation.\n\n- Treat the placement of permutations as a two-way dataflow problem:\n  after propagating information from leaves to roots (as now), propagate\n  information back up the graph.\n\n- Take execution frequency into account when optimising for speed,\n  so that (for example) permutations inside loops have a higher\n  cost than permutations outside loops.\n\n- Try to reduce the total number of permutations when optimising for\n  size, even if that increases the number of permutations on a given\n  execution path.\n\nSee the big block comment above vect_optimize_slp_pass for\na detailed description.\n\nThe original motivation for doing this was to add a framework that would\nallow other layout differences in future.  The two main ones are:\n\n- Make it easier to represent predicated operations, including\n  predicated operations with gaps.  E.g.:\n\n     a[0] += 1;\n     a[1] += 1;\n     a[3] += 1;\n\n  could be a single load/add/store for SVE.  We could handle this\n  by representing a layout such as { 0, 1, _, 2 } or { 0, 1, _, 3 }\n  (depending on what's being counted).  We might need to move\n  elements between lanes at various points, like with permutes.\n\n  (This would first mean adding support for stores with gaps.)\n\n- Make it easier to switch between an even/odd and unpermuted layout\n  when switching between wide and narrow elements.  E.g. if a widening\n  operation produces an even vector and an odd vector, we should try\n  to keep operations on the wide elements in that order rather than\n  force them to be permuted back \"in order\".\n\nTo give some examples of what the patch does:\n\nint f1(int *__restrict a, int *__restrict b, int *__restrict c,\n       int *__restrict d)\n{\n  a[0] = (b[1] << c[3]) - d[1];\n  a[1] = (b[0] << c[2]) - d[0];\n  a[2] = (b[3] << c[1]) - d[3];\n  a[3] = (b[2] << c[0]) - d[2];\n}\n\ncontinues to produce the same code as before when optimising for\nspeed: b, c and d are permuted at load time.  But when optimising\nfor size we instead permute c into the same order as b+d and then\npermute the result of the arithmetic into the same order as a:\n\n        ldr     q1, [x2]\n        ldr     q0, [x1]\n        ext     v1.16b, v1.16b, v1.16b, #8     // <------\n        sshl    v0.4s, v0.4s, v1.4s\n        ldr     q1, [x3]\n        sub     v0.4s, v0.4s, v1.4s\n        rev64   v0.4s, v0.4s                   // <------\n        str     q0, [x0]\n        ret\n\nThe following function:\n\nint f2(int *__restrict a, int *__restrict b, int *__restrict c,\n       int *__restrict d)\n{\n  a[0] = (b[3] << c[3]) - d[3];\n  a[1] = (b[2] << c[2]) - d[2];\n  a[2] = (b[1] << c[1]) - d[1];\n  a[3] = (b[0] << c[0]) - d[0];\n}\n\ncontinues to push the reverse down to just before the store,\nlike the previous code did.\n\nIn:\n\nint f3(int *__restrict a, int *__restrict b, int *__restrict c,\n       int *__restrict d)\n{\n  for (int i = 0; i < 100; ++i)\n    {\n      a[0] = (a[0] + c[3]);\n      a[1] = (a[1] + c[2]);\n      a[2] = (a[2] + c[1]);\n      a[3] = (a[3] + c[0]);\n      c += 4;\n    }\n}\n\nthe loads of a are hoisted and the stores of a are sunk, so that\nonly the load from c happens in the loop.  When optimising for\nspeed, we prefer to have the loop operate on the reversed layout,\nchanging on entry and exit from the loop:\n\n        mov     x3, x0\n        adrp    x0, .LC0\n        add     x1, x2, 1600\n        ldr     q2, [x0, #:lo12:.LC0]\n        ldr     q0, [x3]\n        mov     v1.16b, v0.16b\n        tbl     v0.16b, {v0.16b - v1.16b}, v2.16b    // <--------\n        .p2align 3,,7\n.L6:\n        ldr     q1, [x2], 16\n        add     v0.4s, v0.4s, v1.4s\n        cmp     x2, x1\n        bne     .L6\n        mov     v1.16b, v0.16b\n        adrp    x0, .LC0\n        ldr     q2, [x0, #:lo12:.LC0]\n        tbl     v0.16b, {v0.16b - v1.16b}, v2.16b    // <--------\n        str     q0, [x3]\n        ret\n\nSimilarly, for the very artificial testcase:\n\nint f4(int *__restrict a, int *__restrict b, int *__restrict c,\n       int *__restrict d)\n{\n  int a0 = a[0];\n  int a1 = a[1];\n  int a2 = a[2];\n  int a3 = a[3];\n  for (int i = 0; i < 100; ++i)\n    {\n      a0 ^= c[0];\n      a1 ^= c[1];\n      a2 ^= c[2];\n      a3 ^= c[3];\n      c += 4;\n      for (int j = 0; j < 100; ++j)\n\t{\n\t  a0 += d[1];\n\t  a1 += d[0];\n\t  a2 += d[3];\n\t  a3 += d[2];\n\t  d += 4;\n\t}\n      b[0] = a0;\n      b[1] = a1;\n      b[2] = a2;\n      b[3] = a3;\n      b += 4;\n    }\n  a[0] = a0;\n  a[1] = a1;\n  a[2] = a2;\n  a[3] = a3;\n}\n\nthe a vector in the inner loop maintains the order { 1, 0, 3, 2 },\neven though it's part of an SCC that includes the outer loop.\nIn other words, this is a motivating case for not assigning\npermutes at SCC granularity.  The code we get is:\n\n        ldr     q0, [x0]\n        mov     x4, x1\n        mov     x5, x0\n        add     x1, x3, 1600\n        add     x3, x4, 1600\n        .p2align 3,,7\n.L11:\n        ldr     q1, [x2], 16\n        sub     x0, x1, #1600\n        eor     v0.16b, v1.16b, v0.16b\n        rev64   v0.4s, v0.4s              // <---\n        .p2align 3,,7\n.L10:\n        ldr     q1, [x0], 16\n        add     v0.4s, v0.4s, v1.4s\n        cmp     x0, x1\n        bne     .L10\n        rev64   v0.4s, v0.4s              // <---\n        add     x1, x0, 1600\n        str     q0, [x4], 16\n        cmp     x3, x4\n        bne     .L11\n        str     q0, [x5]\n        ret\n\nbb-slp-layout-17.c is a collection of compile tests for problems\nI hit with earlier versions of the patch.  The same prolems might\nshow up elsewhere, but it seemed worth having the test anyway.\n\nIn slp-11b.c we previously pushed the permutation of the in[i*4]\ngroup down from the load to just before the store.  That didn't\nreduce the number or frequency of the permutations (or increase\nthem either).  But separating the permute from the load meant\nthat we could no longer use load/store lanes.\n\nWhether load/store lanes are a good idea here is another question.\nIf there were two sets of loads, and if we could use a single\npermutation instead of one per load, then avoiding load/store\nlanes should be a good thing even under the current abstract\ncost model.  But I think under the current model we should\ntry to avoid splitting up potential load/store lanes groups\nif there is no specific benefit to the split.\n\nPreferring load/store lanes is still a source of missed optimisations\nthat we should fix one day...\n\ngcc/\n\t* params.opt (-param=vect-max-layout-candidates=): New parameter.\n\t* doc/invoke.texi (vect-max-layout-candidates): Document it.\n\t* tree-vectorizer.h (auto_lane_permutation_t): New typedef.\n\t(auto_load_permutation_t): Likewise.\n\t* tree-vect-slp.cc (vect_slp_node_weight): New function.\n\t(slpg_layout_cost): New class.\n\t(slpg_vertex): Replace perm_in and perm_out with partition,\n\tout_degree, weight and out_weight.\n\t(slpg_partition_info, slpg_partition_layout_costs): New classes.\n\t(vect_optimize_slp_pass): Likewise, cannibalizing some part of\n\tthe previous vect_optimize_slp.\n\t(vect_optimize_slp): Use it.\n\ngcc/testsuite/\n\t* lib/target-supports.exp (check_effective_target_vect_var_shift):\n\tReturn true for aarch64.\n\t* gcc.dg/vect/bb-slp-layout-1.c: New test.\n\t* gcc.dg/vect/bb-slp-layout-2.c: New test.\n\t* gcc.dg/vect/bb-slp-layout-3.c: New test.\n\t* gcc.dg/vect/bb-slp-layout-4.c: New test.\n\t* gcc.dg/vect/bb-slp-layout-5.c: New test.\n\t* gcc.dg/vect/bb-slp-layout-6.c: New test.\n\t* gcc.dg/vect/bb-slp-layout-7.c: New test.\n\t* gcc.dg/vect/bb-slp-layout-8.c: New test.\n\t* gcc.dg/vect/bb-slp-layout-9.c: New test.\n\t* gcc.dg/vect/bb-slp-layout-10.c: New test.\n\t* gcc.dg/vect/bb-slp-layout-11.c: New test.\n\t* gcc.dg/vect/bb-slp-layout-13.c: New test.\n\t* gcc.dg/vect/bb-slp-layout-14.c: New test.\n\t* gcc.dg/vect/bb-slp-layout-15.c: New test.\n\t* gcc.dg/vect/bb-slp-layout-16.c: New test.\n\t* gcc.dg/vect/bb-slp-layout-17.c: New test.\n\t* gcc.dg/vect/slp-11b.c: XFAIL SLP test for load-lanes targets.", "tree": {"sha": "578e8d5b702ad817e058473188eee0ff43c7f324", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/578e8d5b702ad817e058473188eee0ff43c7f324"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61c4c989034548f481d1f10198447be27fb9a55f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61c4c989034548f481d1f10198447be27fb9a55f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61c4c989034548f481d1f10198447be27fb9a55f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61c4c989034548f481d1f10198447be27fb9a55f/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "050309d15e5838832cc61a1fec390bf8d3aca941", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/050309d15e5838832cc61a1fec390bf8d3aca941", "html_url": "https://github.com/Rust-GCC/gccrs/commit/050309d15e5838832cc61a1fec390bf8d3aca941"}], "stats": {"total": 2379, "additions": 1975, "deletions": 404}, "files": [{"sha": "e5eb525a2c12687ed6d64b86289abc6afb60677c", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61c4c989034548f481d1f10198447be27fb9a55f/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61c4c989034548f481d1f10198447be27fb9a55f/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=61c4c989034548f481d1f10198447be27fb9a55f", "patch": "@@ -14619,6 +14619,10 @@ Complex expressions slow the analyzer.\n Maximum number of arguments in a PHI supported by TREE if conversion\n unless the loop is marked with simd pragma.\n \n+@item vect-max-layout-candidates\n+The maximum number of possible vector layouts (such as permutations)\n+to consider when optimizing to-be-vectorized code.\n+\n @item vect-max-version-for-alignment-checks\n The maximum number of run-time checks that can be performed when\n doing loop versioning for alignment in the vectorizer."}, {"sha": "3001566e6414caa9f950f83f4c7aa9f0ea33c13e", "filename": "gcc/params.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61c4c989034548f481d1f10198447be27fb9a55f/gcc%2Fparams.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61c4c989034548f481d1f10198447be27fb9a55f/gcc%2Fparams.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.opt?ref=61c4c989034548f481d1f10198447be27fb9a55f", "patch": "@@ -1137,6 +1137,10 @@ Whether to use canonical types.\n Common Joined UInteger Var(param_vect_epilogues_nomask) Init(1) IntegerRange(0, 1) Param Optimization\n Enable loop epilogue vectorization using smaller vector size.\n \n+-param=vect-max-layout-candidates=\n+Common Joined UInteger Var(param_vect_max_layout_candidates) Init(32) Param Optimization\n+Maximum number of possible vector layouts (such as permutations) to consider when optimizing to-be-vectorized code.\n+\n -param=vect-max-peeling-for-alignment=\n Common Joined UInteger Var(param_vect_max_peeling_for_alignment) Init(-1) IntegerRange(0, 64) Param Optimization\n Maximum number of loop peels to enhance alignment of data references in a loop."}, {"sha": "c1d4ba3ecb42229b95483bbc2fae75e6274df132", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-layout-1.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61c4c989034548f481d1f10198447be27fb9a55f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61c4c989034548f481d1f10198447be27fb9a55f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-1.c?ref=61c4c989034548f481d1f10198447be27fb9a55f", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+\n+int a[4], b[4], c[4], d[4];\n+\n+void f1()\n+{\n+  a[0] = (b[1] << c[3]) - d[1];\n+  a[1] = (b[0] << c[2]) - d[0];\n+  a[2] = (b[3] << c[1]) - d[3];\n+  a[3] = (b[2] << c[0]) - d[2];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"add new stmt: \\[^\\\\n\\\\r\\]* = VEC_PERM_EXPR\" 3 \"slp2\" { target { vect_var_shift && vect_perm } } } } */"}, {"sha": "e2c86f3bd74d9964fdb2c85455f5ff4c1bdbad06", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-layout-10.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61c4c989034548f481d1f10198447be27fb9a55f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61c4c989034548f481d1f10198447be27fb9a55f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-10.c?ref=61c4c989034548f481d1f10198447be27fb9a55f", "patch": "@@ -0,0 +1,6 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-Os -fno-tree-loop-vectorize\" } */\n+\n+#include \"bb-slp-layout-9.c\"\n+\n+/* { dg-final { scan-tree-dump-times \"add new stmt: \\[^\\\\n\\\\r\\]* = VEC_PERM_EXPR\" 1 \"slp1\" { target { vect_int && { vect_perm && vect_hw_misalign } } } } } */"}, {"sha": "d9b5349b70813638f74b8ed4e5186c8fdb6b6fbc", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-layout-11.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61c4c989034548f481d1f10198447be27fb9a55f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61c4c989034548f481d1f10198447be27fb9a55f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-11.c?ref=61c4c989034548f481d1f10198447be27fb9a55f", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-fno-tree-loop-vectorize\" } */\n+\n+int a[4], b[4], c[400], d[400];\n+\n+void f1()\n+{\n+  int a0 = a[0] - b[0];\n+  int a1 = a[1] + b[1];\n+  int a2 = a[2] - b[2];\n+  int a3 = a[3] + b[3];\n+  int b0 = a0;\n+  int b1 = a1;\n+  int b2 = a2;\n+  int b3 = a3;\n+  for (int i = 0; i < 100; ++i)\n+    {\n+      a0 += c[i * 4 + 1];\n+      a1 += c[i * 4 + 0];\n+      a2 += c[i * 4 + 3];\n+      a3 += c[i * 4 + 2];\n+      b0 ^= d[i * 4 + 3];\n+      b1 ^= d[i * 4 + 2];\n+      b2 ^= d[i * 4 + 1];\n+      b3 ^= d[i * 4 + 0];\n+    }\n+  a[0] = a0 ^ b0;\n+  a[1] = a1 ^ b1;\n+  a[2] = a2 ^ b2;\n+  a[3] = a3 ^ b3;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"add new stmt: \\[^\\\\n\\\\r\\]* = VEC_PERM_EXPR\" 4 \"slp1\" { target { vect_int && vect_perm } } } } */\n+/* { dg-final { scan-tree-dump \"duplicating permutation node\" \"slp1\" { target { vect_int && vect_perm } } } } */"}, {"sha": "3bf48af35db4db4ae47b52f4bfeb767eb157b88e", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-layout-12.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61c4c989034548f481d1f10198447be27fb9a55f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61c4c989034548f481d1f10198447be27fb9a55f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-12.c?ref=61c4c989034548f481d1f10198447be27fb9a55f", "patch": "@@ -0,0 +1,8 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-Os -fno-tree-loop-vectorize\" } */\n+\n+#include \"bb-slp-layout-11.c\"\n+\n+/* It would be better to keep the original three permutations.  */\n+/* { dg-final { scan-tree-dump-times \"add new stmt: \\[^\\\\n\\\\r\\]* = VEC_PERM_EXPR\" 3 \"slp1\" { target { vect_int && { vect_perm && vect_hw_misalign } } xfail { *-*-* } } } } */\n+/* { dg-final { scan-tree-dump-not \"duplicating permutation node\" \"slp1\" { target { vect_int && { vect_perm && vect_hw_misalign } } xfail { *-*-* } } } } */"}, {"sha": "9669ade2522a9266c4704643285901429c3ba53a", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-layout-13.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61c4c989034548f481d1f10198447be27fb9a55f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61c4c989034548f481d1f10198447be27fb9a55f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-13.c?ref=61c4c989034548f481d1f10198447be27fb9a55f", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+\n+int a[4], b[4], c[4], d[4];\n+\n+void f1()\n+{\n+  a[0] = (b[1] << c[3]) - (d[1] >> c[3]);\n+  a[1] = (b[0] << c[2]) - (d[0] >> c[2]);\n+  a[2] = (b[3] << c[1]) - (d[3] >> c[1]);\n+  a[3] = (b[2] << c[0]) - (d[2] >> c[0]);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"add new stmt: \\[^\\\\n\\\\r\\]* = VEC_PERM_EXPR\" 3 \"slp2\" { target { vect_var_shift && vect_perm } } } } */"}, {"sha": "159bb15c410c14caa18ddef3ce38f8eecdd8758d", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-layout-14.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61c4c989034548f481d1f10198447be27fb9a55f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61c4c989034548f481d1f10198447be27fb9a55f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-14.c?ref=61c4c989034548f481d1f10198447be27fb9a55f", "patch": "@@ -0,0 +1,6 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-Os\" } */\n+\n+#include \"bb-slp-layout-13.c\"\n+\n+/* { dg-final { scan-tree-dump-times \"add new stmt: \\[^\\\\n\\\\r\\]* = VEC_PERM_EXPR\" 2 \"slp2\" { target { vect_var_shift && { vect_perm && vect_hw_misalign } } } } } */"}, {"sha": "d87fc1e929be96b81dfb462366f6dc4304c2143e", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-layout-15.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61c4c989034548f481d1f10198447be27fb9a55f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61c4c989034548f481d1f10198447be27fb9a55f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-15.c?ref=61c4c989034548f481d1f10198447be27fb9a55f", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+\n+int a[4], b[4], c[4], d[4];\n+\n+void f1()\n+{\n+  a[0] = (b[3] << c[3]) - d[0];\n+  a[1] = (b[2] << c[2]) - d[2];\n+  a[2] = (b[1] << c[1]) - d[4];\n+  a[3] = (b[0] << c[0]) - d[6];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"add new stmt: \\[^\\\\n\\\\r\\]* = VEC_PERM_EXPR\" 1 \"slp2\" { target { vect_var_shift && vect_perm } } } } */"}, {"sha": "559583a01624821657719b1cdaa724f985d009e6", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-layout-16.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61c4c989034548f481d1f10198447be27fb9a55f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61c4c989034548f481d1f10198447be27fb9a55f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-16.c?ref=61c4c989034548f481d1f10198447be27fb9a55f", "patch": "@@ -0,0 +1,6 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-Os\" } */\n+\n+#include \"bb-slp-layout-15.c\"\n+\n+/* { dg-final { scan-tree-dump-times \"add new stmt: \\[^\\\\n\\\\r\\]* = VEC_PERM_EXPR\" 1 \"slp2\" { target { vect_var_shift && { vect_perm && vect_hw_misalign } } } } } */"}, {"sha": "f64a2d98230fa4cb87b545fff501c86b36c05549", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-layout-17.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61c4c989034548f481d1f10198447be27fb9a55f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61c4c989034548f481d1f10198447be27fb9a55f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-17.c?ref=61c4c989034548f481d1f10198447be27fb9a55f", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+\n+int a[8], b[8];\n+\n+int f1()\n+{\n+  a[0] = b[4] + 1;\n+  a[1] = b[5] + 1;\n+  a[2] = b[6] + 1;\n+  a[3] = b[7] + 1;\n+  a[4] = b[0] + 1;\n+  a[5] = b[1] + 1;\n+  a[6] = b[2] + 1;\n+  a[7] = b[3] + 1;\n+}\n+\n+unsigned short c[2], d[2];\n+void f2() {\n+  c[0] += d[1];\n+  c[1] += d[0];\n+}\n+\n+typedef int v4si __attribute__((vector_size(16)));\n+void f3(v4si x) {\n+  a[0] = b[1] + x[1];\n+  a[1] = b[0] + x[3];\n+}"}, {"sha": "f12290ba849acbce7ce807f7515a9fde307dc46e", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-layout-2.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61c4c989034548f481d1f10198447be27fb9a55f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61c4c989034548f481d1f10198447be27fb9a55f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-2.c?ref=61c4c989034548f481d1f10198447be27fb9a55f", "patch": "@@ -0,0 +1,6 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-Os\" } */\n+\n+#include \"bb-slp-layout-1.c\"\n+\n+/* { dg-final { scan-tree-dump-times \"add new stmt: \\[^\\\\n\\\\r\\]* = VEC_PERM_EXPR\" 2 \"slp2\" { target { vect_var_shift && { vect_perm && vect_hw_misalign } } } } } */"}, {"sha": "82c2720ae5a38c72445fc65b83e10f012d914a51", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-layout-3.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61c4c989034548f481d1f10198447be27fb9a55f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61c4c989034548f481d1f10198447be27fb9a55f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-3.c?ref=61c4c989034548f481d1f10198447be27fb9a55f", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+\n+int a[4], b[4], c[4], d[4];\n+\n+void f1()\n+{\n+  a[0] = (b[3] << c[3]) - d[3];\n+  a[1] = (b[2] << c[2]) - d[2];\n+  a[2] = (b[1] << c[1]) - d[1];\n+  a[3] = (b[0] << c[0]) - d[0];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"add new stmt: \\[^\\\\n\\\\r\\]* = VEC_PERM_EXPR\" 1 \"slp2\" { target { vect_var_shift && vect_perm } } } } */"}, {"sha": "45bd6c800bc9b8ed028cff4a57caf79914ea6738", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-layout-4.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61c4c989034548f481d1f10198447be27fb9a55f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61c4c989034548f481d1f10198447be27fb9a55f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-4.c?ref=61c4c989034548f481d1f10198447be27fb9a55f", "patch": "@@ -0,0 +1,6 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-Os\" } */\n+\n+#include \"bb-slp-layout-3.c\"\n+\n+/* { dg-final { scan-tree-dump-times \"add new stmt: \\[^\\\\n\\\\r\\]* = VEC_PERM_EXPR\" 1 \"slp2\" { target { vect_var_shift && { vect_perm && vect_hw_misalign } } } } } */"}, {"sha": "b59a1592275c1c92fda577b3eaa4834cf95689ba", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-layout-5.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61c4c989034548f481d1f10198447be27fb9a55f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61c4c989034548f481d1f10198447be27fb9a55f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-5.c?ref=61c4c989034548f481d1f10198447be27fb9a55f", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+\n+int a[4], b[4], c[4];\n+\n+void f1()\n+{\n+  a[0] = b[3] - c[3];\n+  a[1] = b[2] + c[2];\n+  a[2] = b[1] - c[1];\n+  a[3] = b[0] + c[0];\n+}\n+\n+/* { dg-final { scan-tree-dump \"absorbing input layouts\" \"slp2\" { target { vect_int && vect_perm } } } } */"}, {"sha": "06f53084f86d3fa7f7a2d143b3991c51a39cc24f", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-layout-6.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61c4c989034548f481d1f10198447be27fb9a55f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61c4c989034548f481d1f10198447be27fb9a55f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-6.c?ref=61c4c989034548f481d1f10198447be27fb9a55f", "patch": "@@ -0,0 +1,6 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-Os\" } */\n+\n+#include \"bb-slp-layout-5.c\"\n+\n+/* { dg-final { scan-tree-dump \"absorbing input layouts\" \"slp2\" { target { vect_int && { vect_perm && vect_hw_misalign } } } } } */"}, {"sha": "7a20c60064580906cc3a22dfca78217482103519", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-layout-7.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61c4c989034548f481d1f10198447be27fb9a55f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61c4c989034548f481d1f10198447be27fb9a55f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-7.c?ref=61c4c989034548f481d1f10198447be27fb9a55f", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-fno-tree-loop-vectorize\" } */\n+\n+int a[4], b[400];\n+\n+void f1()\n+{\n+  for (int i = 0; i < 100; ++i)\n+    {\n+      a[0] += b[i * 4 + 3];\n+      a[1] += b[i * 4 + 2];\n+      a[2] += b[i * 4 + 1];\n+      a[3] += b[i * 4 + 0];\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"add new stmt: \\[^\\\\n\\\\r\\]* = VEC_PERM_EXPR\" 2 \"slp1\" { target { vect_int && vect_perm } } } } */"}, {"sha": "ef2f0c693bb335319c26b5b6fa2c3de37f35a795", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-layout-8.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61c4c989034548f481d1f10198447be27fb9a55f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61c4c989034548f481d1f10198447be27fb9a55f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-8.c?ref=61c4c989034548f481d1f10198447be27fb9a55f", "patch": "@@ -0,0 +1,6 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-Os -fno-tree-loop-vectorize\" } */\n+\n+#include \"bb-slp-layout-7.c\"\n+\n+/* { dg-final { scan-tree-dump-times \"add new stmt: \\[^\\\\n\\\\r\\]* = VEC_PERM_EXPR\" 1 \"slp1\" { target { vect_int && { vect_perm && vect_hw_misalign } } } } } */"}, {"sha": "c8418620bee25c5ec2b026b779626c113a27cc80", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-layout-9.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61c4c989034548f481d1f10198447be27fb9a55f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61c4c989034548f481d1f10198447be27fb9a55f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-9.c?ref=61c4c989034548f481d1f10198447be27fb9a55f", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-fno-tree-loop-vectorize\" } */\n+\n+int a[4], b[400], c[400], d[40000];\n+\n+void f1()\n+{\n+  int a0 = a[0];\n+  int a1 = a[1];\n+  int a2 = a[2];\n+  int a3 = a[3];\n+  for (int i = 0; i < 100; ++i)\n+    {\n+      a0 ^= c[i * 4 + 0];\n+      a1 ^= c[i * 4 + 1];\n+      a2 ^= c[i * 4 + 2];\n+      a3 ^= c[i * 4 + 3];\n+      for (int j = 0; j < 100; ++j)\n+\t{\n+\t  a0 += d[i * 400 + j * 4 + 1];\n+\t  a1 += d[i * 400 + j * 4 + 0];\n+\t  a2 += d[i * 400 + j * 4 + 3];\n+\t  a3 += d[i * 400 + j * 4 + 2];\n+\t}\n+      b[i * 4 + 0] = a0;\n+      b[i * 4 + 1] = a1;\n+      b[i * 4 + 2] = a2;\n+      b[i * 4 + 3] = a3;\n+    }\n+  a[0] = a0;\n+  a[1] = a1;\n+  a[2] = a2;\n+  a[3] = a3;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"add new stmt: \\[^\\\\n\\\\r\\]* = VEC_PERM_EXPR\" 2 \"slp1\" { target { vect_int && vect_perm } } } } */"}, {"sha": "d0b972f720be1c965207ded917f979957c76ee67", "filename": "gcc/testsuite/gcc.dg/vect/slp-11b.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61c4c989034548f481d1f10198447be27fb9a55f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-11b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61c4c989034548f481d1f10198447be27fb9a55f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-11b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-11b.c?ref=61c4c989034548f481d1f10198447be27fb9a55f", "patch": "@@ -44,4 +44,4 @@ int main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target { { vect_strided4 || vect_perm } && vect_int_mult } } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" { target { vect_perm && vect_int_mult } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" { target { vect_perm && vect_int_mult } xfail vect_load_lanes } } } */"}, {"sha": "3c1913bc54c6a8719718f433466c2107f807978d", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61c4c989034548f481d1f10198447be27fb9a55f/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61c4c989034548f481d1f10198447be27fb9a55f/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=61c4c989034548f481d1f10198447be27fb9a55f", "patch": "@@ -6814,6 +6814,7 @@ proc check_effective_target_vect_var_shift { } {\n     return [check_cached_effective_target_indexed vect_var_shift {\n       expr {(([istarget i?86-*-*] || [istarget x86_64-*-*])\n \t     && [check_avx2_available])\n+\t    || [istarget aarch64*-*-*]\n       }}]\n }\n "}, {"sha": "ab4c6fa677607dae97b12161a6fb114c377dc65d", "filename": "gcc/tree-vect-slp.cc", "status": "modified", "additions": 1734, "deletions": 403, "changes": 2137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61c4c989034548f481d1f10198447be27fb9a55f/gcc%2Ftree-vect-slp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61c4c989034548f481d1f10198447be27fb9a55f/gcc%2Ftree-vect-slp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.cc?ref=61c4c989034548f481d1f10198447be27fb9a55f", "patch": "@@ -20,6 +20,7 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"config.h\"\n+#define INCLUDE_ALGORITHM\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"backend.h\"\n@@ -49,7 +50,20 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-eh.h\"\n #include \"tree-cfg.h\"\n #include \"alloc-pool.h\"\n-\n+#include \"sreal.h\"\n+#include \"predict.h\"\n+\n+static bool vect_transform_slp_perm_load_1 (vec_info *, slp_tree,\n+\t\t\t\t\t    load_permutation_t &,\n+\t\t\t\t\t    const vec<tree> &,\n+\t\t\t\t\t    gimple_stmt_iterator *,\n+\t\t\t\t\t    poly_uint64, bool, bool,\n+\t\t\t\t\t    unsigned *,\n+\t\t\t\t\t    unsigned * = nullptr,\n+\t\t\t\t\t    bool = false);\n+static int vectorizable_slp_permutation_1 (vec_info *, gimple_stmt_iterator *,\n+\t\t\t\t\t   slp_tree, lane_permutation_t &,\n+\t\t\t\t\t   vec<slp_tree> &, bool);\n static bool vectorizable_slp_permutation (vec_info *, gimple_stmt_iterator *,\n \t\t\t\t\t  slp_tree, stmt_vector_for_cost *);\n static void vect_print_slp_tree (dump_flags_t, dump_location_t, slp_tree);\n@@ -304,6 +318,16 @@ vect_free_oprnd_info (vec<slp_oprnd_info> &oprnds_info)\n   oprnds_info.release ();\n }\n \n+/* Return the execution frequency of NODE (so that a higher value indicates\n+   a \"more important\" node when optimizing for speed).  */\n+\n+static sreal\n+vect_slp_node_weight (slp_tree node)\n+{\n+  stmt_vec_info stmt_info = vect_orig_stmt (SLP_TREE_REPRESENTATIVE (node));\n+  basic_block bb = gimple_bb (stmt_info->stmt);\n+  return bb->count.to_sreal_scale (ENTRY_BLOCK_PTR_FOR_FN (cfun)->count);\n+}\n \n /* Return true if STMTS contains a pattern statement.  */\n \n@@ -3531,46 +3555,489 @@ vect_analyze_slp (vec_info *vinfo, unsigned max_tree_size)\n   return opt_result::success ();\n }\n \n-struct slpg_vertex\n+/* Estimates the cost of inserting layout changes into the SLP graph.\n+   It can also say that the insertion is impossible.  */\n+\n+struct slpg_layout_cost\n+{\n+  slpg_layout_cost () = default;\n+  slpg_layout_cost (sreal, bool);\n+\n+  static slpg_layout_cost impossible () { return { sreal::max (), 0 }; }\n+  bool is_possible () const { return depth != sreal::max (); }\n+\n+  bool operator== (const slpg_layout_cost &) const;\n+  bool operator!= (const slpg_layout_cost &) const;\n+\n+  bool is_better_than (const slpg_layout_cost &, bool) const;\n+\n+  void add_parallel_cost (const slpg_layout_cost &);\n+  void add_serial_cost (const slpg_layout_cost &);\n+  void split (unsigned int);\n+\n+  /* The longest sequence of layout changes needed during any traversal\n+     of the partition dag, weighted by execution frequency.\n+\n+     This is the most important metric when optimizing for speed, since\n+     it helps to ensure that we keep the number of operations on\n+     critical paths to a minimum.  */\n+  sreal depth = 0;\n+\n+  /* An estimate of the total number of operations needed.  It is weighted by\n+     execution frequency when optimizing for speed but not when optimizing for\n+     size.  In order to avoid double-counting, a node with a fanout of N will\n+     distribute 1/N of its total cost to each successor.\n+\n+     This is the most important metric when optimizing for size, since\n+     it helps to keep the total number of operations to a minimum,  */\n+  sreal total = 0;\n+};\n+\n+/* Construct costs for a node with weight WEIGHT.  A higher weight\n+   indicates more frequent execution.  IS_FOR_SIZE is true if we are\n+   optimizing for size rather than speed.  */\n+\n+slpg_layout_cost::slpg_layout_cost (sreal weight, bool is_for_size)\n+  : depth (weight), total (is_for_size && weight > 0 ? 1 : weight)\n {\n-  slpg_vertex (slp_tree node_)\n-    : node (node_), perm_in (-1), perm_out (-1) {}\n+}\n \n-  int get_perm_materialized () const\n-    { return perm_in != perm_out ? perm_in : 0; }\n+bool\n+slpg_layout_cost::operator== (const slpg_layout_cost &other) const\n+{\n+  return depth == other.depth && total == other.total;\n+}\n \n+bool\n+slpg_layout_cost::operator!= (const slpg_layout_cost &other) const\n+{\n+  return !operator== (other);\n+}\n+\n+/* Return true if these costs are better than OTHER.  IS_FOR_SIZE is\n+   true if we are optimizing for size rather than speed.  */\n+\n+bool\n+slpg_layout_cost::is_better_than (const slpg_layout_cost &other,\n+\t\t\t\t  bool is_for_size) const\n+{\n+  if (is_for_size)\n+    {\n+      if (total != other.total)\n+\treturn total < other.total;\n+      return depth < other.depth;\n+    }\n+  else\n+    {\n+      if (depth != other.depth)\n+\treturn depth < other.depth;\n+      return total < other.total;\n+    }\n+}\n+\n+/* Increase the costs to account for something with cost INPUT_COST\n+   happening in parallel with the current costs.  */\n+\n+void\n+slpg_layout_cost::add_parallel_cost (const slpg_layout_cost &input_cost)\n+{\n+  depth = std::max (depth, input_cost.depth);\n+  total += input_cost.total;\n+}\n+\n+/* Increase the costs to account for something with cost INPUT_COST\n+   happening in series with the current costs.  */\n+\n+void\n+slpg_layout_cost::add_serial_cost (const slpg_layout_cost &other)\n+{\n+  depth += other.depth;\n+  total += other.total;\n+}\n+\n+/* Split the total cost among TIMES successors or predecessors.  */\n+\n+void\n+slpg_layout_cost::split (unsigned int times)\n+{\n+  if (times > 1)\n+    total /= times;\n+}\n+\n+/* Information about one node in the SLP graph, for use during\n+   vect_optimize_slp_pass.  */\n+\n+struct slpg_vertex\n+{\n+  slpg_vertex (slp_tree node_) : node (node_) {}\n+\n+  /* The node itself.  */\n   slp_tree node;\n-  /* The common permutation on the incoming lanes (towards SLP children).  */\n-  int perm_in;\n-  /* The permutation on the outgoing lanes (towards SLP parents).  When\n-     the node is a materialization point for a permute this differs\n-     from perm_in (and is then usually zero).  Materialization happens\n-     on the input side.  */\n-  int perm_out;\n+\n+  /* Which partition the node belongs to, or -1 if none.  Nodes outside of\n+     partitions are flexible; they can have whichever layout consumers\n+     want them to have.  */\n+  int partition = -1;\n+\n+  /* The number of nodes that directly use the result of this one\n+     (i.e. the number of nodes that count this one as a child).  */\n+  unsigned int out_degree = 0;\n+\n+  /* The execution frequency of the node.  */\n+  sreal weight = 0;\n+\n+  /* The total execution frequency of all nodes that directly use the\n+     result of this one.  */\n+  sreal out_weight = 0;\n };\n \n-/* Fill the vertices and leafs vector with all nodes in the SLP graph.  */\n+/* Information about one partition of the SLP graph, for use during\n+   vect_optimize_slp_pass.  */\n \n-static void\n-vect_slp_build_vertices (hash_set<slp_tree> &visited, slp_tree node,\n-\t\t\t vec<slpg_vertex> &vertices, vec<int> &leafs)\n+struct slpg_partition_info\n+{\n+  /* The nodes in the partition occupy indices [NODE_BEGIN, NODE_END)\n+     of m_partitioned_nodes.  */\n+  unsigned int node_begin = 0;\n+  unsigned int node_end = 0;\n+\n+  /* Which layout we've chosen to use for this partition, or -1 if\n+     we haven't picked one yet.  */\n+  int layout = -1;\n+\n+  /* The number of predecessors and successors in the partition dag.\n+     The predecessors always have lower partition numbers and the\n+     successors always have higher partition numbers.\n+\n+     Note that the directions of these edges are not necessarily the\n+     same as in the data flow graph.  For example, if an SCC has separate\n+     partitions for an inner loop and an outer loop, the inner loop's\n+     partition will have at least two incoming edges from the outer loop's\n+     partition: one for a live-in value and one for a live-out value.\n+     In data flow terms, one of these edges would also be from the outer loop\n+     to the inner loop, but the other would be in the opposite direction.  */\n+  unsigned int in_degree = 0;\n+  unsigned int out_degree = 0;\n+};\n+\n+/* Information about the costs of using a particular layout for a\n+   particular partition.  It can also say that the combination is\n+   impossible.  */\n+\n+struct slpg_partition_layout_costs\n+{\n+  bool is_possible () const { return internal_cost.is_possible (); }\n+  void mark_impossible () { internal_cost = slpg_layout_cost::impossible (); }\n+\n+  /* The costs inherited from predecessor partitions.  */\n+  slpg_layout_cost in_cost;\n+\n+  /* The inherent cost of the layout within the node itself.  For example,\n+     this is nonzero for a load if choosing a particular layout would require\n+     the load to permute the loaded elements.  It is nonzero for a\n+     VEC_PERM_EXPR if the permutation cannot be eliminated or converted\n+     to full-vector moves.  */\n+  slpg_layout_cost internal_cost;\n+\n+  /* The costs inherited from successor partitions.  */\n+  slpg_layout_cost out_cost;\n+};\n+\n+/* This class tries to optimize the layout of vectors in order to avoid\n+   unnecessary shuffling.  At the moment, the set of possible layouts are\n+   restricted to bijective permutations.\n+\n+   The goal of the pass depends on whether we're optimizing for size or\n+   for speed.  When optimizing for size, the goal is to reduce the overall\n+   number of layout changes (including layout changes implied by things\n+   like load permutations).  When optimizing for speed, the goal is to\n+   reduce the maximum latency attributable to layout changes on any\n+   non-cyclical path through the data flow graph.\n+\n+   For example, when optimizing a loop nest for speed, we will prefer\n+   to make layout changes outside of a loop rather than inside of a loop,\n+   and will prefer to make layout changes in parallel rather than serially,\n+   even if that increases the overall number of layout changes.\n+\n+   The high-level procedure is:\n+\n+   (1) Build a graph in which edges go from uses (parents) to definitions\n+       (children).\n+\n+   (2) Divide the graph into a dag of strongly-connected components (SCCs).\n+\n+   (3) When optimizing for speed, partition the nodes in each SCC based\n+       on their containing cfg loop.  When optimizing for size, treat\n+       each SCC as a single partition.\n+\n+       This gives us a dag of partitions.  The goal is now to assign a\n+       layout to each partition.\n+\n+   (4) Construct a set of vector layouts that are worth considering.\n+       Record which nodes must keep their current layout.\n+\n+   (5) Perform a forward walk over the partition dag (from loads to stores)\n+       accumulating the \"forward\" cost of using each layout.  When visiting\n+       each partition, assign a tentative choice of layout to the partition\n+       and use that choice when calculating the cost of using a different\n+       layout in successor partitions.\n+\n+   (6) Perform a backward walk over the partition dag (from stores to loads),\n+       accumulating the \"backward\" cost of using each layout.  When visiting\n+       each partition, make a final choice of layout for that partition based\n+       on the accumulated forward costs (from (5)) and backward costs\n+       (from (6)).\n+\n+   (7) Apply the chosen layouts to the SLP graph.\n+\n+   For example, consider the SLP statements:\n+\n+   S1:      a_1 = load\n+       loop:\n+   S2:      a_2 = PHI<a_1, a_3>\n+   S3:      b_1 = load\n+   S4:      a_3 = a_2 + b_1\n+       exit:\n+   S5:      a_4 = PHI<a_3>\n+   S6:      store a_4\n+\n+   S2 and S4 form an SCC and are part of the same loop.  Every other\n+   statement is in a singleton SCC.  In this example there is a one-to-one\n+   mapping between SCCs and partitions and the partition dag looks like this;\n+\n+\tS1     S3\n+\t \\     /\n+\t  S2+S4\n+\t    |\n+\t   S5\n+\t    |\n+\t   S6\n+\n+   S2, S3 and S4 will have a higher execution frequency than the other\n+   statements, so when optimizing for speed, the goal is to avoid any\n+   layout changes:\n+\n+   - within S3\n+   - within S2+S4\n+   - on the S3->S2+S4 edge\n+\n+   For example, if S3 was originally a reversing load, the goal of the\n+   pass is to make it an unreversed load and change the layout on the\n+   S1->S2+S4 and S2+S4->S5 edges to compensate.  (Changing the layout\n+   on S1->S2+S4 and S5->S6 would also be acceptable.)\n+\n+   The difference between SCCs and partitions becomes important if we\n+   add an outer loop:\n+\n+   S1:      a_1 = ...\n+       loop1:\n+   S2:      a_2 = PHI<a_1, a_6>\n+   S3:      b_1 = load\n+   S4:      a_3 = a_2 + b_1\n+       loop2:\n+   S5:      a_4 = PHI<a_3, a_5>\n+   S6:      c_1 = load\n+   S7:      a_5 = a_4 + c_1\n+       exit2:\n+   S8:      a_6 = PHI<a_5>\n+   S9:      store a_6\n+       exit1:\n+\n+   Here, S2, S4, S5, S7 and S8 form a single SCC.  However, when optimizing\n+   for speed, we usually do not want restrictions in the outer loop to \"infect\"\n+   the decision for the inner loop.  For example, if an outer-loop node\n+   in the SCC contains a statement with a fixed layout, that should not\n+   prevent the inner loop from using a different layout.  Conversely,\n+   the inner loop should not dictate a layout to the outer loop: if the\n+   outer loop does a lot of computation, then it may not be efficient to\n+   do all of that computation in the inner loop's preferred layout.\n+\n+   So when optimizing for speed, we partition the SCC into S2+S4+S8 (outer)\n+   and S5+S7 (inner).  We also try to arrange partitions so that:\n+\n+   - the partition for an outer loop comes before the partition for\n+     an inner loop\n+\n+   - if a sibling loop A dominates a sibling loop B, A's partition\n+     comes before B's\n+\n+   This gives the following partition dag for the example above:\n+\n+\tS1        S3\n+\t \\        /\n+\t  S2+S4+S8   S6\n+\t   |   \\\\    /\n+\t   |    S5+S7\n+\t   |\n+\t  S9\n+\n+   There are two edges from S2+S4+S8 to S5+S7: one for the edge S4->S5 and\n+   one for a reversal of the edge S7->S8.\n+\n+   The backward walk picks a layout for S5+S7 before S2+S4+S8.  The choice\n+   for S2+S4+S8 therefore has to balance the cost of using the outer loop's\n+   preferred layout against the cost of changing the layout on entry to the\n+   inner loop (S4->S5) and on exit from the inner loop (S7->S8 reversed).\n+\n+   Although this works well when optimizing for speed, it has the downside\n+   when optimizing for size that the choice of layout for S5+S7 is completely\n+   independent of S9, which lessens the chance of reducing the overall number\n+   of permutations.  We therefore do not partition SCCs when optimizing\n+   for size.\n+\n+   To give a concrete example of the difference between optimizing\n+   for size and speed, consider:\n+\n+   a[0] = (b[1] << c[3]) - d[1];\n+   a[1] = (b[0] << c[2]) - d[0];\n+   a[2] = (b[3] << c[1]) - d[3];\n+   a[3] = (b[2] << c[0]) - d[2];\n+\n+   There are three different layouts here: one for a, one for b and d,\n+   and one for c.  When optimizing for speed it is better to permute each\n+   of b, c and d into the order required by a, since those permutations\n+   happen in parallel.  But when optimizing for size, it is better to:\n+\n+   - permute c into the same order as b\n+   - do the arithmetic\n+   - permute the result into the order required by a\n+\n+   This gives 2 permutations rather than 3.  */\n+\n+class vect_optimize_slp_pass\n+{\n+public:\n+  vect_optimize_slp_pass (vec_info *vinfo) : m_vinfo (vinfo) {}\n+  void run ();\n+\n+private:\n+  /* Graph building.  */\n+  struct loop *containing_loop (slp_tree);\n+  bool is_cfg_latch_edge (graph_edge *);\n+  void build_vertices (hash_set<slp_tree> &, slp_tree);\n+  void build_vertices ();\n+  void build_graph ();\n+\n+  /* Partitioning.  */\n+  void create_partitions ();\n+  template<typename T> void for_each_partition_edge (unsigned int, T);\n+\n+  /* Layout selection.  */\n+  bool is_compatible_layout (slp_tree, unsigned int);\n+  int change_layout_cost (slp_tree, unsigned int, unsigned int);\n+  slpg_partition_layout_costs &partition_layout_costs (unsigned int,\n+\t\t\t\t\t\t       unsigned int);\n+  void change_vec_perm_layout (slp_tree, lane_permutation_t &,\n+\t\t\t       int, unsigned int);\n+  int internal_node_cost (slp_tree, int, unsigned int);\n+  void start_choosing_layouts ();\n+\n+  /* Cost propagation.  */\n+  slpg_layout_cost edge_layout_cost (graph_edge *, unsigned int,\n+\t\t\t\t     unsigned int, unsigned int);\n+  slpg_layout_cost total_in_cost (unsigned int);\n+  slpg_layout_cost forward_cost (graph_edge *, unsigned int, unsigned int);\n+  slpg_layout_cost backward_cost (graph_edge *, unsigned int, unsigned int);\n+  void forward_pass ();\n+  void backward_pass ();\n+\n+  /* Rematerialization.  */\n+  slp_tree get_result_with_layout (slp_tree, unsigned int);\n+  void materialize ();\n+\n+  /* Clean-up.  */\n+  void remove_redundant_permutations ();\n+\n+  void dump ();\n+\n+  vec_info *m_vinfo;\n+\n+  /* True if we should optimize the graph for size, false if we should\n+     optimize it for speed.  (It wouldn't be easy to make this decision\n+     more locally.)  */\n+  bool m_optimize_size;\n+\n+  /* A graph of all SLP nodes, with edges leading from uses to definitions.\n+     In other words, a node's predecessors are its slp_tree parents and\n+     a node's successors are its slp_tree children.  */\n+  graph *m_slpg = nullptr;\n+\n+  /* The vertices of M_SLPG, indexed by slp_tree::vertex.  */\n+  auto_vec<slpg_vertex> m_vertices;\n+\n+  /* The list of all leaves of M_SLPG. such as external definitions, constants,\n+     and loads.  */\n+  auto_vec<int> m_leafs;\n+\n+  /* This array has one entry for every vector layout that we're considering.\n+     Element 0 is null and indicates \"no change\".  Other entries describe\n+     permutations that are inherent in the current graph and that we would\n+     like to reverse if possible.\n+\n+     For example, a permutation { 1, 2, 3, 0 } means that something has\n+     effectively been permuted in that way, such as a load group\n+     { a[1], a[2], a[3], a[0] } (viewed as a permutation of a[0:3]).\n+     We'd then like to apply the reverse permutation { 3, 0, 1, 2 }\n+     in order to put things \"back\" in order.  */\n+  auto_vec<vec<unsigned> > m_perms;\n+\n+  /* A partitioning of the nodes for which a layout must be chosen.\n+     Each partition represents an <SCC, cfg loop> pair; that is,\n+     nodes in different SCCs belong to different partitions, and nodes\n+     within an SCC can be further partitioned according to a containing\n+     cfg loop.  Partition <SCC1, L1> comes before <SCC2, L2> if:\n+\n+     - SCC1 != SCC2 and SCC1 is a predecessor of SCC2 in a forward walk\n+       from leaves (such as loads) to roots (such as stores).\n+\n+     - SCC1 == SCC2 and L1's header strictly dominates L2's header.  */\n+  auto_vec<slpg_partition_info> m_partitions;\n+\n+  /* The list of all nodes for which a layout must be chosen.  Nodes for\n+     partition P come before the nodes for partition P+1.  Nodes within a\n+     partition are in reverse postorder.  */\n+  auto_vec<unsigned int> m_partitioned_nodes;\n+\n+  /* Index P * num-layouts + L contains the cost of using layout L\n+     for partition P.  */\n+  auto_vec<slpg_partition_layout_costs> m_partition_layout_costs;\n+\n+  /* Index N * num-layouts + L, if nonnull, is a node that provides the\n+     original output of node N adjusted to have layout L.  */\n+  auto_vec<slp_tree> m_node_layouts;\n+};\n+\n+/* Fill the vertices and leafs vector with all nodes in the SLP graph.\n+   Also record whether we should optimize anything for speed rather\n+   than size.  */\n+\n+void\n+vect_optimize_slp_pass::build_vertices (hash_set<slp_tree> &visited,\n+\t\t\t\t\tslp_tree node)\n {\n   unsigned i;\n   slp_tree child;\n \n   if (visited.add (node))\n     return;\n \n-  node->vertex = vertices.length ();\n-  vertices.safe_push (slpg_vertex (node));\n+  if (stmt_vec_info rep = SLP_TREE_REPRESENTATIVE (node))\n+    {\n+      basic_block bb = gimple_bb (vect_orig_stmt (rep)->stmt);\n+      if (optimize_bb_for_speed_p (bb))\n+\tm_optimize_size = false;\n+    }\n+\n+  node->vertex = m_vertices.length ();\n+  m_vertices.safe_push (slpg_vertex (node));\n \n   bool leaf = true;\n   bool force_leaf = false;\n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n     if (child)\n       {\n \tleaf = false;\n-\tvect_slp_build_vertices (visited, child, vertices, leafs);\n+\tbuild_vertices (visited, child);\n       }\n     else\n       force_leaf = true;\n@@ -3580,21 +4047,19 @@ vect_slp_build_vertices (hash_set<slp_tree> &visited, slp_tree node,\n      and inductions.  Force those SLP PHIs to act as leafs to make them\n      backwards reachable.  */\n   if (leaf || force_leaf)\n-    leafs.safe_push (node->vertex);\n+    m_leafs.safe_push (node->vertex);\n }\n \n /* Fill the vertices and leafs vector with all nodes in the SLP graph.  */\n \n-static void\n-vect_slp_build_vertices (vec_info *info, vec<slpg_vertex> &vertices,\n-\t\t\t vec<int> &leafs)\n+void\n+vect_optimize_slp_pass::build_vertices ()\n {\n   hash_set<slp_tree> visited;\n   unsigned i;\n   slp_instance instance;\n-  FOR_EACH_VEC_ELT (info->slp_instances, i, instance)\n-    vect_slp_build_vertices (visited, SLP_INSTANCE_TREE (instance), vertices,\n-\t\t\t     leafs);\n+  FOR_EACH_VEC_ELT (m_vinfo->slp_instances, i, instance)\n+    build_vertices (visited, SLP_INSTANCE_TREE (instance));\n }\n \n /* Apply (reverse) bijectite PERM to VEC.  */\n@@ -3625,75 +4090,457 @@ vect_slp_permute (vec<unsigned> perm,\n     }\n }\n \n-/* Return whether permutations PERM_A and PERM_B as recorded in the\n-   PERMS vector are equal.  */\n+/* Return the cfg loop that contains NODE.  */\n \n-static bool\n-vect_slp_perms_eq (const vec<vec<unsigned> > &perms,\n-\t\t   int perm_a, int perm_b)\n+struct loop *\n+vect_optimize_slp_pass::containing_loop (slp_tree node)\n {\n-  return (perm_a == perm_b\n-\t  || (perm_a != -1 && perm_b != -1\n-\t      && perms[perm_a].length () == perms[perm_b].length ()\n-\t      && memcmp (&perms[perm_a][0], &perms[perm_b][0],\n-\t\t\t sizeof (unsigned) * perms[perm_a].length ()) == 0));\n+  stmt_vec_info rep = SLP_TREE_REPRESENTATIVE (node);\n+  if (!rep)\n+    return ENTRY_BLOCK_PTR_FOR_FN (cfun)->loop_father;\n+  return gimple_bb (vect_orig_stmt (rep)->stmt)->loop_father;\n }\n \n-/* Optimize the SLP graph of VINFO.  */\n+/* Return true if UD (an edge from a use to a definition) is associated\n+   with a loop latch edge in the cfg.  */\n \n-void\n-vect_optimize_slp (vec_info *vinfo)\n+bool\n+vect_optimize_slp_pass::is_cfg_latch_edge (graph_edge *ud)\n {\n-  if (vinfo->slp_instances.is_empty ())\n-    return;\n+  slp_tree use = m_vertices[ud->src].node;\n+  slp_tree def = m_vertices[ud->dest].node;\n+  if (SLP_TREE_DEF_TYPE (use) != vect_internal_def\n+      || SLP_TREE_DEF_TYPE (def) != vect_internal_def)\n+    return false;\n \n-  slp_tree node;\n-  unsigned i;\n-  auto_vec<slpg_vertex> vertices;\n-  auto_vec<int> leafs;\n-  vect_slp_build_vertices (vinfo, vertices, leafs);\n+  stmt_vec_info use_rep = vect_orig_stmt (SLP_TREE_REPRESENTATIVE (use));\n+  return (is_a<gphi *> (use_rep->stmt)\n+\t  && bb_loop_header_p (gimple_bb (use_rep->stmt))\n+\t  && containing_loop (def) == containing_loop (use));\n+}\n+\n+/* Build the graph.  Mark edges that correspond to cfg loop latch edges with\n+   a nonnull data field.  */\n+\n+void\n+vect_optimize_slp_pass::build_graph ()\n+{\n+  m_optimize_size = true;\n+  build_vertices ();\n \n-  struct graph *slpg = new_graph (vertices.length ());\n-  for (slpg_vertex &v : vertices)\n+  m_slpg = new_graph (m_vertices.length ());\n+  for (slpg_vertex &v : m_vertices)\n     for (slp_tree child : SLP_TREE_CHILDREN (v.node))\n       if (child)\n-\tadd_edge (slpg, v.node->vertex, child->vertex);\n+\t{\n+\t  graph_edge *ud = add_edge (m_slpg, v.node->vertex, child->vertex);\n+\t  if (is_cfg_latch_edge (ud))\n+\t    ud->data = this;\n+\t}\n+}\n+\n+/* Return true if E corresponds to a loop latch edge in the cfg.  */\n \n-  /* Compute (reverse) postorder on the inverted graph.  */\n-  auto_vec<int> ipo;\n-  graphds_dfs (slpg, &leafs[0], leafs.length (), &ipo, false, NULL, NULL);\n+static bool\n+skip_cfg_latch_edges (graph_edge *e)\n+{\n+  return e->data;\n+}\n \n-  auto_vec<vec<unsigned> > perms;\n-  perms.safe_push (vNULL); /* zero is no permute */\n+/* Create the node partitions.  */\n \n-  /* Produce initial permutations.  */\n-  for (i = 0; i < leafs.length (); ++i)\n+void\n+vect_optimize_slp_pass::create_partitions ()\n+{\n+  /* Calculate a postorder of the graph, ignoring edges that correspond\n+     to natural latch edges in the cfg.  Reading the vector from the end\n+     to the beginning gives the reverse postorder.  */\n+  auto_vec<int> initial_rpo;\n+  graphds_dfs (m_slpg, &m_leafs[0], m_leafs.length (), &initial_rpo,\n+\t       false, NULL, skip_cfg_latch_edges);\n+  gcc_assert (initial_rpo.length () == m_vertices.length ());\n+\n+  /* Calculate the strongly connected components of the graph.  */\n+  auto_vec<int> scc_grouping;\n+  unsigned int num_sccs = graphds_scc (m_slpg, NULL, NULL, &scc_grouping);\n+\n+  /* Create a new index order in which all nodes from the same SCC are\n+     consecutive.  Use scc_pos to record the index of the first node in\n+     each SCC.  */\n+  auto_vec<unsigned int> scc_pos (num_sccs);\n+  int last_component = -1;\n+  unsigned int node_count = 0;\n+  for (unsigned int node_i : scc_grouping)\n+    {\n+      if (last_component != m_slpg->vertices[node_i].component)\n+\t{\n+\t  last_component = m_slpg->vertices[node_i].component;\n+\t  gcc_assert (last_component == int (scc_pos.length ()));\n+\t  scc_pos.quick_push (node_count);\n+\t}\n+      node_count += 1;\n+    }\n+  gcc_assert (node_count == initial_rpo.length ()\n+\t      && last_component + 1 == int (num_sccs));\n+\n+  /* Use m_partitioned_nodes to group nodes into SCC order, with the nodes\n+     inside each SCC following the RPO we calculated above.  The fact that\n+     we ignored natural latch edges when calculating the RPO should ensure\n+     that, for natural loop nests:\n+\n+     - the first node that we encounter in a cfg loop is the loop header phi\n+     - the loop header phis are in dominance order\n+\n+     Arranging for this is an optimization (see below) rather than a\n+     correctness issue.  Unnatural loops with a tangled mess of backedges\n+     will still work correctly, but might give poorer results.\n+\n+     Also update scc_pos so that it gives 1 + the index of the last node\n+     in the SCC.  */\n+  m_partitioned_nodes.safe_grow (node_count);\n+  for (unsigned int old_i = initial_rpo.length (); old_i-- > 0;)\n+    {\n+      unsigned int node_i = initial_rpo[old_i];\n+      unsigned int new_i = scc_pos[m_slpg->vertices[node_i].component]++;\n+      m_partitioned_nodes[new_i] = node_i;\n+    }\n+\n+  /* When optimizing for speed, partition each SCC based on the containing\n+     cfg loop. The order we constructed above should ensure that, for natural\n+     cfg loops, we'll create sub-SCC partitions for outer loops before\n+     the corresponding sub-SCC partitions for inner loops.  Similarly,\n+     when one sibling loop A dominates another sibling loop B, we should\n+     create a sub-SCC partition for A before a sub-SCC partition for B.\n+\n+     As above, nothing depends for correctness on whether this achieves\n+     a natural nesting, but we should get better results when it does.  */\n+  m_partitions.reserve (m_vertices.length ());\n+  unsigned int next_partition_i = 0;\n+  hash_map<struct loop *, int> loop_partitions;\n+  unsigned int rpo_begin = 0;\n+  unsigned int num_partitioned_nodes = 0;\n+  for (unsigned int rpo_end : scc_pos)\n+    {\n+      loop_partitions.empty ();\n+      unsigned int partition_i = next_partition_i;\n+      for (unsigned int rpo_i = rpo_begin; rpo_i < rpo_end; ++rpo_i)\n+\t{\n+\t  /* Handle externals and constants optimistically throughout.\n+\t     But treat existing vectors as fixed since we do not handle\n+\t     permuting them.  */\n+\t  unsigned int node_i = m_partitioned_nodes[rpo_i];\n+\t  auto &vertex = m_vertices[node_i];\n+\t  if ((SLP_TREE_DEF_TYPE (vertex.node) == vect_external_def\n+\t       && !SLP_TREE_VEC_DEFS (vertex.node).exists ())\n+\t      || SLP_TREE_DEF_TYPE (vertex.node) == vect_constant_def)\n+\t    vertex.partition = -1;\n+\t  else\n+\t    {\n+\t      bool existed;\n+\t      if (m_optimize_size)\n+\t\texisted = next_partition_i > partition_i;\n+\t      else\n+\t\t{\n+\t\t  struct loop *loop = containing_loop (vertex.node);\n+\t\t  auto &entry = loop_partitions.get_or_insert (loop, &existed);\n+\t\t  if (!existed)\n+\t\t    entry = next_partition_i;\n+\t\t  partition_i = entry;\n+\t\t}\n+\t      if (!existed)\n+\t\t{\n+\t\t  m_partitions.quick_push (slpg_partition_info ());\n+\t\t  next_partition_i += 1;\n+\t\t}\n+\t      vertex.partition = partition_i;\n+\t      num_partitioned_nodes += 1;\n+\t      m_partitions[partition_i].node_end += 1;\n+\t    }\n+\t}\n+      rpo_begin = rpo_end;\n+    }\n+\n+  /* Assign ranges of consecutive node indices to each partition,\n+     in partition order.  Start with node_end being the same as\n+     node_begin so that the next loop can use it as a counter.  */\n+  unsigned int node_begin = 0;\n+  for (auto &partition : m_partitions)\n     {\n-      int idx = leafs[i];\n-      slp_tree node = vertices[idx].node;\n+      partition.node_begin = node_begin;\n+      node_begin += partition.node_end;\n+      partition.node_end = partition.node_begin;\n+    }\n+  gcc_assert (node_begin == num_partitioned_nodes);\n \n-      /* Handle externals and constants optimistically throughout the\n-\t iteration.  But treat existing vectors as fixed since we\n-\t do not handle permuting them below.  */\n-      if ((SLP_TREE_DEF_TYPE (node) == vect_external_def\n-\t   && !SLP_TREE_VEC_DEFS (node).exists ())\n-\t  || SLP_TREE_DEF_TYPE (node) == vect_constant_def)\n-\tcontinue;\n+  /* Finally build the list of nodes in partition order.  */\n+  m_partitioned_nodes.truncate (num_partitioned_nodes);\n+  for (unsigned int node_i = 0; node_i < m_vertices.length (); ++node_i)\n+    {\n+      int partition_i = m_vertices[node_i].partition;\n+      if (partition_i >= 0)\n+\t{\n+\t  unsigned int order_i = m_partitions[partition_i].node_end++;\n+\t  m_partitioned_nodes[order_i] = node_i;\n+\t}\n+    }\n+}\n+\n+/* Look for edges from earlier partitions into node NODE_I and edges from\n+   node NODE_I into later partitions.  Call:\n+\n+      FN (ud, other_node_i)\n+\n+   for each such use-to-def edge ud, where other_node_i is the node at the\n+   other end of the edge.  */\n+\n+template<typename T>\n+void\n+vect_optimize_slp_pass::for_each_partition_edge (unsigned int node_i, T fn)\n+{\n+  int partition_i = m_vertices[node_i].partition;\n+  for (graph_edge *pred = m_slpg->vertices[node_i].pred;\n+       pred; pred = pred->pred_next)\n+    {\n+      int src_partition_i = m_vertices[pred->src].partition;\n+      if (src_partition_i >= 0 && src_partition_i != partition_i)\n+\tfn (pred, pred->src);\n+    }\n+  for (graph_edge *succ = m_slpg->vertices[node_i].succ;\n+       succ; succ = succ->succ_next)\n+    {\n+      int dest_partition_i = m_vertices[succ->dest].partition;\n+      if (dest_partition_i >= 0 && dest_partition_i != partition_i)\n+\tfn (succ, succ->dest);\n+    }\n+}\n+\n+/* Return true if layout LAYOUT_I is compatible with the number of SLP lanes\n+   that NODE would operate on.  This test is independent of NODE's actual\n+   operation.  */\n+\n+bool\n+vect_optimize_slp_pass::is_compatible_layout (slp_tree node,\n+\t\t\t\t\t      unsigned int layout_i)\n+{\n+  if (layout_i == 0)\n+    return true;\n+\n+  /* SLP_TREE_LANES is zero for existing vectors, but those only support\n+     layout 0 anyway.  */\n+  if (SLP_TREE_LANES (node) != m_perms[layout_i].length ())\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Return the cost (in arbtirary units) of going from layout FROM_LAYOUT_I\n+   to layout TO_LAYOUT_I for a node like NODE.  Return -1 if either of the\n+   layouts is incompatible with NODE or if the change is not possible for\n+   some other reason.\n+\n+   The properties taken from NODE include the number of lanes and the\n+   vector type.  The actual operation doesn't matter.  */\n+\n+int\n+vect_optimize_slp_pass::change_layout_cost (slp_tree node,\n+\t\t\t\t\t    unsigned int from_layout_i,\n+\t\t\t\t\t    unsigned int to_layout_i)\n+{\n+  if (!is_compatible_layout (node, from_layout_i)\n+      || !is_compatible_layout (node, to_layout_i))\n+    return -1;\n+\n+  if (from_layout_i == to_layout_i)\n+    return 0;\n+\n+  auto_vec<slp_tree, 1> children (1);\n+  children.quick_push (node);\n+  auto_lane_permutation_t perm (SLP_TREE_LANES (node));\n+  if (from_layout_i > 0)\n+    for (unsigned int i : m_perms[from_layout_i])\n+      perm.quick_push ({ 0, i });\n+  else\n+    for (unsigned int i = 0; i < SLP_TREE_LANES (node); ++i)\n+      perm.quick_push ({ 0, i });\n+  if (to_layout_i > 0)\n+    vect_slp_permute (m_perms[to_layout_i], perm, true);\n+  auto count = vectorizable_slp_permutation_1 (m_vinfo, nullptr, node, perm,\n+\t\t\t\t\t       children, false);\n+  if (count >= 0)\n+    return MAX (count, 1);\n+\n+  /* ??? In principle we could try changing via layout 0, giving two\n+     layout changes rather than 1.  Doing that would require\n+     corresponding support in get_result_with_layout.  */\n+  return -1;\n+}\n+\n+/* Return the costs of assigning layout LAYOUT_I to partition PARTITION_I.  */\n+\n+inline slpg_partition_layout_costs &\n+vect_optimize_slp_pass::partition_layout_costs (unsigned int partition_i,\n+\t\t\t\t\t\tunsigned int layout_i)\n+{\n+  return m_partition_layout_costs[partition_i * m_perms.length () + layout_i];\n+}\n+\n+/* Change PERM in one of two ways:\n+\n+   - if IN_LAYOUT_I < 0, accept input operand I in the layout that has been\n+     chosen for child I of NODE.\n+\n+   - if IN_LAYOUT >= 0, accept all inputs operands with that layout.\n+\n+   In both cases, arrange for the output to have layout OUT_LAYOUT_I  */\n+\n+void\n+vect_optimize_slp_pass::\n+change_vec_perm_layout (slp_tree node, lane_permutation_t &perm,\n+\t\t\tint in_layout_i, unsigned int out_layout_i)\n+{\n+  for (auto &entry : perm)\n+    {\n+      int this_in_layout_i = in_layout_i;\n+      if (this_in_layout_i < 0)\n+\t{\n+\t  slp_tree in_node = SLP_TREE_CHILDREN (node)[entry.first];\n+\t  unsigned int in_partition_i = m_vertices[in_node->vertex].partition;\n+\t  this_in_layout_i = m_partitions[in_partition_i].layout;\n+\t}\n+      if (this_in_layout_i > 0)\n+\tentry.second = m_perms[this_in_layout_i][entry.second];\n+    }\n+  if (out_layout_i > 0)\n+    vect_slp_permute (m_perms[out_layout_i], perm, true);\n+}\n \n-      /* Leafs do not change across iterations.  Note leafs also double\n-\t as entries to the reverse graph.  */\n-      if (!slpg->vertices[idx].succ)\n+/* Check whether the target allows NODE to be rearranged so that the node's\n+   output has layout OUT_LAYOUT_I.  Return the cost of the change if so,\n+   in the same arbitrary units as for change_layout_cost.  Return -1 otherwise.\n+\n+   If NODE is a VEC_PERM_EXPR and IN_LAYOUT_I < 0, also check whether\n+   NODE can adapt to the layout changes that have (perhaps provisionally)\n+   been chosen for NODE's children, so that no extra permutations are\n+   needed on either the input or the output of NODE.\n+\n+   If NODE is a VEC_PERM_EXPR and IN_LAYOUT_I >= 0, instead assume\n+   that all inputs will be forced into layout IN_LAYOUT_I beforehand.\n+\n+   IN_LAYOUT_I has no meaning for other types of node.\n+\n+   Keeping the node as-is is always valid.  If the target doesn't appear to\n+   support the node as-is then layout 0 has a high and arbitrary cost instead\n+   of being invalid.  On the one hand, this ensures that every node has at\n+   least one valid layout, avoiding what would otherwise be an awkward\n+   special case.  On the other, it still encourages the pass to change\n+   an invalid pre-existing layout choice into a valid one.  */\n+\n+int\n+vect_optimize_slp_pass::internal_node_cost (slp_tree node, int in_layout_i,\n+\t\t\t\t\t    unsigned int out_layout_i)\n+{\n+  const int fallback_cost = 100;\n+\n+  if (SLP_TREE_CODE (node) == VEC_PERM_EXPR)\n+    {\n+      auto_lane_permutation_t tmp_perm;\n+      tmp_perm.safe_splice (SLP_TREE_LANE_PERMUTATION (node));\n+\n+      /* Check that the child nodes support the chosen layout.  Checking\n+\t the first child is enough, since any second child would have the\n+\t same shape.  */\n+      if (in_layout_i > 0\n+\t  && !is_compatible_layout (SLP_TREE_CHILDREN (node)[0], in_layout_i))\n+\treturn -1;\n+\n+      change_vec_perm_layout (node, tmp_perm, in_layout_i, out_layout_i);\n+      int count = vectorizable_slp_permutation_1 (m_vinfo, nullptr,\n+\t\t\t\t\t\t  node, tmp_perm,\n+\t\t\t\t\t\t  SLP_TREE_CHILDREN (node),\n+\t\t\t\t\t\t  false);\n+      if (count < 0)\n \t{\n-\t  vertices[idx].perm_in = 0;\n-\t  vertices[idx].perm_out = 0;\n+\t  if (in_layout_i == 0 && out_layout_i == 0)\n+\t    return fallback_cost;\n+\t  return -1;\n \t}\n \n+      /* We currently have no way of telling whether the new layout is cheaper\n+\t or more expensive than the old one.  But at least in principle,\n+\t it should be worth making zero permutations (whole-vector shuffles)\n+\t cheaper than real permutations, in case the pass is able to remove\n+\t the latter.  */\n+      return count == 0 ? 0 : 1;\n+    }\n+\n+  stmt_vec_info rep = SLP_TREE_REPRESENTATIVE (node);\n+  if (rep\n+      && STMT_VINFO_DATA_REF (rep)\n+      && DR_IS_READ (STMT_VINFO_DATA_REF (rep)))\n+    {\n+      auto_load_permutation_t tmp_perm;\n+      tmp_perm.safe_splice (SLP_TREE_LOAD_PERMUTATION (node));\n+      if (out_layout_i > 0)\n+\tvect_slp_permute (m_perms[out_layout_i], tmp_perm, true);\n+\n+      poly_uint64 vf = 1;\n+      if (auto loop_vinfo = dyn_cast<loop_vec_info> (m_vinfo))\n+\tvf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+      unsigned int n_perms;\n+      if (!vect_transform_slp_perm_load_1 (m_vinfo, node, tmp_perm, vNULL,\n+\t\t\t\t\t   nullptr, vf, true, false, &n_perms))\n+\t{\n+\t  if (out_layout_i == 0)\n+\t    return fallback_cost;\n+\t  return -1;\n+\t}\n+\n+      /* See the comment above the corresponding VEC_PERM_EXPR handling.  */\n+      return n_perms == 0 ? 0 : 1;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Decide which element layouts we should consider using.  Calculate the\n+   weights associated with inserting layout changes on partition edges.\n+   Also mark partitions that cannot change layout, by setting their\n+   layout to zero.  */\n+\n+void\n+vect_optimize_slp_pass::start_choosing_layouts ()\n+{\n+  /* Used to assign unique permutation indices.  */\n+  using perm_hash = unbounded_hashmap_traits<\n+    vec_free_hash_base<int_hash_base<unsigned>>,\n+    int_hash<int, -1, -2>\n+  >;\n+  hash_map<vec<unsigned>, int, perm_hash> layout_ids;\n+\n+  /* Layout 0 is \"no change\".  */\n+  m_perms.safe_push (vNULL);\n+\n+  /* Create layouts from existing permutations.  */\n+  for (unsigned int node_i : m_leafs)\n+    {\n+      auto &vertex = m_vertices[node_i];\n+      if (vertex.partition < 0)\n+\tcontinue;\n+\n+      /* Leafs also double as entries to the reverse graph.  Allow the\n+\t layout of those to be changed.  */\n+      auto &partition = m_partitions[vertex.partition];\n+      if (!m_slpg->vertices[node_i].succ)\n+\tpartition.layout = 0;\n+\n       /* Loads are the only thing generating permutes.  */\n+      slp_tree node = vertex.node;\n       if (!SLP_TREE_LOAD_PERMUTATION (node).exists ())\n \tcontinue;\n \n-      /* If splitting out a SLP_TREE_LANE_PERMUTATION can make the\n-\t node unpermuted, record this permute.  */\n+      /* If splitting out a SLP_TREE_LANE_PERMUTATION can make the node\n+\t unpermuted, record a layout that reverses this permutation.  */\n+      gcc_assert (partition.layout == 0);\n       stmt_vec_info dr_stmt = SLP_TREE_REPRESENTATIVE (node);\n       if (!STMT_VINFO_GROUPED_ACCESS (dr_stmt))\n \tcontinue;\n@@ -3708,13 +4555,18 @@ vect_optimize_slp (vec_info *vinfo)\n \t  if (idx - SLP_TREE_LOAD_PERMUTATION (node)[0] != j)\n \t    any_permute = true;\n \t}\n-      /* If there's no permute no need to split one out.  */\n-      if (!any_permute)\n-\tcontinue;\n       /* If the span doesn't match we'd disrupt VF computation, avoid\n \t that for now.  */\n       if (imax - imin + 1 != SLP_TREE_LANES (node))\n \tcontinue;\n+      /* If there's no permute no need to split one out.  In this case\n+\t we can consider turning the load into a permuted load, if that\n+\t turns out to be cheaper than alternatives.  */\n+      if (!any_permute)\n+\t{\n+\t  partition.layout = -1;\n+\t  continue;\n+\t}\n \n       /* For now only handle true permutes, like\n \t vect_attempt_slp_rearrange_stmts did.  This allows us to be lazy\n@@ -3735,407 +4587,742 @@ vect_optimize_slp (vec_info *vinfo)\n       perm.safe_grow (SLP_TREE_LANES (node), true);\n       for (unsigned j = 0; j < SLP_TREE_LANES (node); ++j)\n \tperm[j] = SLP_TREE_LOAD_PERMUTATION (node)[j] - imin;\n-      perms.safe_push (perm);\n-      vertices[idx].perm_in = perms.length () - 1;\n-      vertices[idx].perm_out = perms.length () - 1;\n+\n+      if (int (m_perms.length ()) >= param_vect_max_layout_candidates)\n+\t{\n+\t  /* Continue to use existing layouts, but don't add any more.  */\n+\t  int *entry = layout_ids.get (perm);\n+\t  partition.layout = entry ? *entry : 0;\n+\t  perm.release ();\n+\t}\n+      else\n+\t{\n+\t  bool existed;\n+\t  int &layout_i = layout_ids.get_or_insert (perm, &existed);\n+\t  if (existed)\n+\t    perm.release ();\n+\t  else\n+\t    {\n+\t      layout_i = m_perms.length ();\n+\t      m_perms.safe_push (perm);\n+\t    }\n+\t  partition.layout = layout_i;\n+\t}\n     }\n \n-  /* In addition to the above we have to mark outgoing permutes facing\n-     non-reduction graph entries that are not represented as to be\n-     materialized.  */\n-  for (slp_instance instance : vinfo->slp_instances)\n+  /* Initially assume that every layout is possible and has zero cost\n+     in every partition.  */\n+  m_partition_layout_costs.safe_grow_cleared (m_partitions.length ()\n+\t\t\t\t\t      * m_perms.length ());\n+\n+  /* We have to mark outgoing permutations facing non-reduction graph\n+     entries that are not represented as to be materialized.  */\n+  for (slp_instance instance : m_vinfo->slp_instances)\n     if (SLP_INSTANCE_KIND (instance) == slp_inst_kind_ctor)\n       {\n-\t/* Just setting perm_out isn't enough for the propagation to\n-\t   pick this up.  */\n-\tvertices[SLP_INSTANCE_TREE (instance)->vertex].perm_in = 0;\n-\tvertices[SLP_INSTANCE_TREE (instance)->vertex].perm_out = 0;\n+\tunsigned int node_i = SLP_INSTANCE_TREE (instance)->vertex;\n+\tm_partitions[m_vertices[node_i].partition].layout = 0;\n       }\n \n-  /* Propagate permutes along the graph and compute materialization points.  */\n-  bool changed;\n-  bool do_materialization = false;\n-  unsigned iteration = 0;\n-  do\n+  /* Check which layouts each node and partition can handle.  Calculate the\n+     weights associated with inserting layout changes on edges.  */\n+  for (unsigned int node_i : m_partitioned_nodes)\n     {\n-      changed = false;\n-      ++iteration;\n+      auto &vertex = m_vertices[node_i];\n+      auto &partition = m_partitions[vertex.partition];\n+      slp_tree node = vertex.node;\n \n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t \"SLP optimize iteration %d\\n\", iteration);\n+      if (stmt_vec_info rep = SLP_TREE_REPRESENTATIVE (node))\n+\t{\n+\t  vertex.weight = vect_slp_node_weight (node);\n+\n+\t  /* We do not handle stores with a permutation, so all\n+\t     incoming permutations must have been materialized.  */\n+\t  if (STMT_VINFO_DATA_REF (rep)\n+\t      && DR_IS_WRITE (STMT_VINFO_DATA_REF (rep)))\n+\t    /* ???  We're forcing materialization in place\n+\t       of the child here, we'd need special handling\n+\t       in materialization to leave layout -1 here.  */\n+\t    partition.layout = 0;\n+\n+\t  /* We cannot change the layout of an operation that is\n+\t     not independent on lanes.  Note this is an explicit\n+\t     negative list since that's much shorter than the respective\n+\t     positive one but it's critical to keep maintaining it.  */\n+\t  if (is_gimple_call (STMT_VINFO_STMT (rep)))\n+\t    switch (gimple_call_combined_fn (STMT_VINFO_STMT (rep)))\n+\t      {\n+\t      case CFN_COMPLEX_ADD_ROT90:\n+\t      case CFN_COMPLEX_ADD_ROT270:\n+\t      case CFN_COMPLEX_MUL:\n+\t      case CFN_COMPLEX_MUL_CONJ:\n+\t      case CFN_VEC_ADDSUB:\n+\t      case CFN_VEC_FMADDSUB:\n+\t      case CFN_VEC_FMSUBADD:\n+\t\tpartition.layout = 0;\n+\t      default:;\n+\t      }\n+\t}\n \n-      for (i = vertices.length (); i > 0 ; --i)\n+      auto process_edge = [&](graph_edge *ud, unsigned int other_node_i)\n \t{\n-\t  int idx = ipo[i-1];\n-\t  slp_tree node = vertices[idx].node;\n+\t  auto &other_vertex = m_vertices[other_node_i];\n \n-\t  /* Handle externals and constants optimistically throughout the\n-\t     iteration.  */\n-\t  if (SLP_TREE_DEF_TYPE (node) == vect_external_def\n-\t      || SLP_TREE_DEF_TYPE (node) == vect_constant_def)\n+\t  /* Count the number of edges from earlier partitions and the number\n+\t     of edges to later partitions.  */\n+\t  if (other_vertex.partition < vertex.partition)\n+\t    partition.in_degree += 1;\n+\t  else\n+\t    partition.out_degree += 1;\n+\n+\t  /* If the current node uses the result of OTHER_NODE_I, accumulate\n+\t     the effects of that.  */\n+\t  if (ud->src == int (node_i))\n+\t    {\n+\t      other_vertex.out_weight += vertex.weight;\n+\t      other_vertex.out_degree += 1;\n+\t    }\n+\t};\n+      for_each_partition_edge (node_i, process_edge);\n+    }\n+}\n+\n+/* Return the incoming costs for node NODE_I, assuming that each input keeps\n+   its current (provisional) choice of layout.  The inputs do not necessarily\n+   have the same layout as each other.  */\n+\n+slpg_layout_cost\n+vect_optimize_slp_pass::total_in_cost (unsigned int node_i)\n+{\n+  auto &vertex = m_vertices[node_i];\n+  slpg_layout_cost cost;\n+  auto add_cost = [&](graph_edge *, unsigned int other_node_i)\n+    {\n+      auto &other_vertex = m_vertices[other_node_i];\n+      if (other_vertex.partition < vertex.partition)\n+\t{\n+\t  auto &other_partition = m_partitions[other_vertex.partition];\n+\t  auto &other_costs = partition_layout_costs (other_vertex.partition,\n+\t\t\t\t\t\t      other_partition.layout);\n+\t  slpg_layout_cost this_cost = other_costs.in_cost;\n+\t  this_cost.add_serial_cost (other_costs.internal_cost);\n+\t  this_cost.split (other_partition.out_degree);\n+\t  cost.add_parallel_cost (this_cost);\n+\t}\n+    };\n+  for_each_partition_edge (node_i, add_cost);\n+  return cost;\n+}\n+\n+/* Return the cost of switching between layout LAYOUT1_I (at node NODE1_I)\n+   and layout LAYOUT2_I on cross-partition use-to-def edge UD.  Return\n+   slpg_layout_cost::impossible () if the change isn't possible.  */\n+\n+slpg_layout_cost\n+vect_optimize_slp_pass::\n+edge_layout_cost (graph_edge *ud, unsigned int node1_i, unsigned int layout1_i,\n+\t\t  unsigned int layout2_i)\n+{\n+  auto &def_vertex = m_vertices[ud->dest];\n+  auto &use_vertex = m_vertices[ud->src];\n+  auto def_layout_i = ud->dest == int (node1_i) ? layout1_i : layout2_i;\n+  auto use_layout_i = ud->dest == int (node1_i) ? layout2_i : layout1_i;\n+  auto factor = change_layout_cost (def_vertex.node, def_layout_i,\n+\t\t\t\t    use_layout_i);\n+  if (factor < 0)\n+    return slpg_layout_cost::impossible ();\n+\n+  /* We have a choice of putting the layout change at the site of the\n+     definition or at the site of the use.  Prefer the former when\n+     optimizing for size or when the execution frequency of the\n+     definition is no greater than the combined execution frequencies of\n+     the uses.  When putting the layout change at the site of the definition,\n+     divvy up the cost among all consumers.  */\n+  if (m_optimize_size || def_vertex.weight <= def_vertex.out_weight)\n+    {\n+      slpg_layout_cost cost = { def_vertex.weight * factor, m_optimize_size };\n+      cost.split (def_vertex.out_degree);\n+      return cost;\n+    }\n+  return { use_vertex.weight * factor, m_optimize_size };\n+}\n+\n+/* UD represents a use-def link between FROM_NODE_I and a node in a later\n+   partition; FROM_NODE_I could be the definition node or the use node.\n+   The node at the other end of the link wants to use layout TO_LAYOUT_I.\n+   Return the cost of any necessary fix-ups on edge UD, or return\n+   slpg_layout_cost::impossible () if the change isn't possible.\n+\n+   At this point, FROM_NODE_I's partition has chosen the cheapest\n+   layout based on the information available so far, but this choice\n+   is only provisional.  */\n+\n+slpg_layout_cost\n+vect_optimize_slp_pass::forward_cost (graph_edge *ud, unsigned int from_node_i,\n+\t\t\t\t      unsigned int to_layout_i)\n+{\n+  auto &from_vertex = m_vertices[from_node_i];\n+  unsigned int from_partition_i = from_vertex.partition;\n+  slpg_partition_info &from_partition = m_partitions[from_partition_i];\n+  gcc_assert (from_partition.layout >= 0);\n+\n+  /* First calculate the cost on the assumption that FROM_PARTITION sticks\n+     with its current layout preference.  */\n+  slpg_layout_cost cost = slpg_layout_cost::impossible ();\n+  auto edge_cost = edge_layout_cost (ud, from_node_i,\n+\t\t\t\t     from_partition.layout, to_layout_i);\n+  if (edge_cost.is_possible ())\n+    {\n+      auto &from_costs = partition_layout_costs (from_partition_i,\n+\t\t\t\t\t\t from_partition.layout);\n+      cost = from_costs.in_cost;\n+      cost.add_serial_cost (from_costs.internal_cost);\n+      cost.split (from_partition.out_degree);\n+      cost.add_serial_cost (edge_cost);\n+    }\n+\n+  /* Take the minimum of that cost and the cost that applies if\n+     FROM_PARTITION instead switches to TO_LAYOUT_I.  */\n+  auto &direct_layout_costs = partition_layout_costs (from_partition_i,\n+\t\t\t\t\t\t      to_layout_i);\n+  if (direct_layout_costs.is_possible ())\n+    {\n+      slpg_layout_cost direct_cost = direct_layout_costs.in_cost;\n+      direct_cost.add_serial_cost (direct_layout_costs.internal_cost);\n+      direct_cost.split (from_partition.out_degree);\n+      if (!cost.is_possible ()\n+\t  || direct_cost.is_better_than (cost, m_optimize_size))\n+\tcost = direct_cost;\n+    }\n+\n+  return cost;\n+}\n+\n+/* UD represents a use-def link between TO_NODE_I and a node in an earlier\n+   partition; TO_NODE_I could be the definition node or the use node.\n+   The node at the other end of the link wants to use layout FROM_LAYOUT_I;\n+   return the cost of any necessary fix-ups on edge UD, or\n+   slpg_layout_cost::impossible () if the choice cannot be made.\n+\n+   At this point, TO_NODE_I's partition has a fixed choice of layout.  */\n+\n+slpg_layout_cost\n+vect_optimize_slp_pass::backward_cost (graph_edge *ud, unsigned int to_node_i,\n+\t\t\t\t       unsigned int from_layout_i)\n+{\n+  auto &to_vertex = m_vertices[to_node_i];\n+  unsigned int to_partition_i = to_vertex.partition;\n+  slpg_partition_info &to_partition = m_partitions[to_partition_i];\n+  gcc_assert (to_partition.layout >= 0);\n+\n+  /* If TO_NODE_I is a VEC_PERM_EXPR consumer, see whether it can be\n+     adjusted for this input having layout FROM_LAYOUT_I.  Assume that\n+     any other inputs keep their current choice of layout.  */\n+  auto &to_costs = partition_layout_costs (to_partition_i,\n+\t\t\t\t\t   to_partition.layout);\n+  if (ud->src == int (to_node_i)\n+      && SLP_TREE_CODE (to_vertex.node) == VEC_PERM_EXPR)\n+    {\n+      auto &from_partition = m_partitions[m_vertices[ud->dest].partition];\n+      auto old_layout = from_partition.layout;\n+      from_partition.layout = from_layout_i;\n+      int factor = internal_node_cost (to_vertex.node, -1,\n+\t\t\t\t       to_partition.layout);\n+      from_partition.layout = old_layout;\n+      if (factor >= 0)\n+\t{\n+\t  slpg_layout_cost cost = to_costs.out_cost;\n+\t  cost.add_serial_cost ({ to_vertex.weight * factor,\n+\t\t\t\t  m_optimize_size });\n+\t  cost.split (to_partition.in_degree);\n+\t  return cost;\n+\t}\n+    }\n+\n+  /* Compute the cost if we insert any necessary layout change on edge UD.  */\n+  auto edge_cost = edge_layout_cost (ud, to_node_i,\n+\t\t\t\t     to_partition.layout, from_layout_i);\n+  if (edge_cost.is_possible ())\n+    {\n+      slpg_layout_cost cost = to_costs.out_cost;\n+      cost.add_serial_cost (to_costs.internal_cost);\n+      cost.split (to_partition.in_degree);\n+      cost.add_serial_cost (edge_cost);\n+      return cost;\n+    }\n+\n+  return slpg_layout_cost::impossible ();\n+}\n+\n+/* Make a forward pass through the partitions, accumulating input costs.\n+   Make a tentative (provisional) choice of layout for each partition,\n+   ensuring that this choice still allows later partitions to keep\n+   their original layout.  */\n+\n+void\n+vect_optimize_slp_pass::forward_pass ()\n+{\n+  for (unsigned int partition_i = 0; partition_i < m_partitions.length ();\n+       ++partition_i)\n+    {\n+      auto &partition = m_partitions[partition_i];\n+\n+      /* If the partition consists of a single VEC_PERM_EXPR, precompute\n+\t the incoming cost that would apply if every predecessor partition\n+\t keeps its current layout.  This is used within the loop below.  */\n+      slpg_layout_cost in_cost;\n+      slp_tree single_node = nullptr;\n+      if (partition.node_end == partition.node_begin + 1)\n+\t{\n+\t  unsigned int node_i = m_partitioned_nodes[partition.node_begin];\n+\t  single_node = m_vertices[node_i].node;\n+\t  if (SLP_TREE_CODE (single_node) == VEC_PERM_EXPR)\n+\t    in_cost = total_in_cost (node_i);\n+\t}\n+\n+      /* Go through the possible layouts.  Decide which ones are valid\n+\t for this partition and record which of the valid layouts has\n+\t the lowest cost.  */\n+      unsigned int min_layout_i = 0;\n+      slpg_layout_cost min_layout_cost = slpg_layout_cost::impossible ();\n+      for (unsigned int layout_i = 0; layout_i < m_perms.length (); ++layout_i)\n+\t{\n+\t  auto &layout_costs = partition_layout_costs (partition_i, layout_i);\n+\t  if (!layout_costs.is_possible ())\n \t    continue;\n \n-\t  /* We still eventually have failed backedge SLP nodes in the\n-\t     graph, those are only cancelled when analyzing operations.\n-\t     Simply treat them as transparent ops, propagating permutes\n-\t     through them.  */\n-\t  if (SLP_TREE_DEF_TYPE (node) == vect_internal_def)\n+\t  /* If the recorded layout is already 0 then the layout cannot\n+\t     change.  */\n+\t  if (partition.layout == 0 && layout_i != 0)\n \t    {\n-\t      /* We do not handle stores with a permutation, so all\n-\t\t incoming permutes must have been materialized.  */\n-\t      stmt_vec_info rep = SLP_TREE_REPRESENTATIVE (node);\n-\t      if (STMT_VINFO_DATA_REF (rep)\n-\t\t  && DR_IS_WRITE (STMT_VINFO_DATA_REF (rep)))\n-\t\t{\n-\t\t  /* ???  We're forcing materialization in place\n-\t\t     of the child here, we'd need special handling\n-\t\t     in materialization to leave perm_in -1 here.  */\n-\t\t  vertices[idx].perm_in = 0;\n-\t\t  vertices[idx].perm_out = 0;\n-\t\t}\n-\t      /* We cannot move a permute across an operation that is\n-\t\t not independent on lanes.  Note this is an explicit\n-\t\t negative list since that's much shorter than the respective\n-\t\t positive one but it's critical to keep maintaining it.  */\n-\t      if (is_gimple_call (STMT_VINFO_STMT (rep)))\n-\t\tswitch (gimple_call_combined_fn (STMT_VINFO_STMT (rep)))\n-\t\t  {\n-\t\t  case CFN_COMPLEX_ADD_ROT90:\n-\t\t  case CFN_COMPLEX_ADD_ROT270:\n-\t\t  case CFN_COMPLEX_MUL:\n-\t\t  case CFN_COMPLEX_MUL_CONJ:\n-\t\t  case CFN_VEC_ADDSUB:\n-\t\t  case CFN_VEC_FMADDSUB:\n-\t\t  case CFN_VEC_FMSUBADD:\n-\t\t    vertices[idx].perm_in = 0;\n-\t\t    vertices[idx].perm_out = 0;\n-\t\t  default:;\n-\t\t  }\n+\t      layout_costs.mark_impossible ();\n+\t      continue;\n \t    }\n \n-\t  if (!slpg->vertices[idx].succ)\n-\t    /* Pick up pre-computed leaf values.  */\n-\t    ;\n-\t  else\n+\t  bool is_possible = true;\n+\t  for (unsigned int order_i = partition.node_begin;\n+\t       order_i < partition.node_end; ++order_i)\n \t    {\n-\t      bool any_succ_perm_out_m1 = false;\n-\t      int perm_in = vertices[idx].perm_in;\n-\t      for (graph_edge *succ = slpg->vertices[idx].succ;\n-\t\t   succ; succ = succ->succ_next)\n+\t      unsigned int node_i = m_partitioned_nodes[order_i];\n+\t      auto &vertex = m_vertices[node_i];\n+\n+\t      /* Reject the layout if it is individually incompatible\n+\t\t with any node in the partition.  */\n+\t      if (!is_compatible_layout (vertex.node, layout_i))\n \t\t{\n-\t\t  int succ_idx = succ->dest;\n-\t\t  int succ_perm = vertices[succ_idx].perm_out;\n-\t\t  /* Handle unvisited (and constant) nodes optimistically.  */\n-\t\t  /* ???  But for constants once we want to handle\n-\t\t     non-bijective permutes we have to verify the permute,\n-\t\t     when unifying lanes, will not unify different constants.\n-\t\t     For example see gcc.dg/vect/bb-slp-14.c for a case\n-\t\t     that would break.  */\n-\t\t  if (succ_perm == -1)\n-\t\t    {\n-\t\t      /* When we handled a non-leaf optimistically, note\n-\t\t\t that so we can adjust its outgoing permute below.  */\n-\t\t      slp_tree succ_node = vertices[succ_idx].node;\n-\t\t      if (SLP_TREE_DEF_TYPE (succ_node) != vect_external_def\n-\t\t\t  && SLP_TREE_DEF_TYPE (succ_node) != vect_constant_def)\n-\t\t\tany_succ_perm_out_m1 = true;\n-\t\t      continue;\n-\t\t    }\n-\t\t  if (perm_in == -1)\n-\t\t    perm_in = succ_perm;\n-\t\t  else if (succ_perm == 0\n-\t\t\t   || !vect_slp_perms_eq (perms, perm_in, succ_perm))\n-\t\t    {\n-\t\t      perm_in = 0;\n-\t\t      break;\n-\t\t    }\n+\t\t  is_possible = false;\n+\t\t  break;\n \t\t}\n \n-\t      /* Adjust any incoming permutes we treated optimistically.  */\n-\t      if (perm_in != -1 && any_succ_perm_out_m1)\n+\t      auto add_cost = [&](graph_edge *ud, unsigned int other_node_i)\n \t\t{\n-\t\t  for (graph_edge *succ = slpg->vertices[idx].succ;\n-\t\t       succ; succ = succ->succ_next)\n+\t\t  auto &other_vertex = m_vertices[other_node_i];\n+\t\t  if (other_vertex.partition < vertex.partition)\n \t\t    {\n-\t\t      slp_tree succ_node = vertices[succ->dest].node;\n-\t\t      if (vertices[succ->dest].perm_out == -1\n-\t\t\t  && SLP_TREE_DEF_TYPE (succ_node) != vect_external_def\n-\t\t\t  && SLP_TREE_DEF_TYPE (succ_node) != vect_constant_def)\n-\t\t\t{\n-\t\t\t  vertices[succ->dest].perm_out = perm_in;\n-\t\t\t  /* And ensure this propagates.  */\n-\t\t\t  if (vertices[succ->dest].perm_in == -1)\n-\t\t\t    vertices[succ->dest].perm_in = perm_in;\n-\t\t\t}\n+\t\t      /* Accumulate the incoming costs from earlier\n+\t\t\t partitions, plus the cost of any layout changes\n+\t\t\t on UD itself.  */\n+\t\t      auto cost = forward_cost (ud, other_node_i, layout_i);\n+\t\t      if (!cost.is_possible ())\n+\t\t\tis_possible = false;\n+\t\t      else\n+\t\t\tlayout_costs.in_cost.add_parallel_cost (cost);\n \t\t    }\n-\t\t  changed = true;\n+\t\t  else\n+\t\t    /* Reject the layout if it would make layout 0 impossible\n+\t\t       for later partitions.  This amounts to testing that the\n+\t\t       target supports reversing the layout change on edges\n+\t\t       to later partitions.\n+\n+\t\t       In principle, it might be possible to push a layout\n+\t\t       change all the way down a graph, so that it never\n+\t\t       needs to be reversed and so that the target doesn't\n+\t\t       need to support the reverse operation.  But it would\n+\t\t       be awkward to bail out if we hit a partition that\n+\t\t       does not support the new layout, especially since\n+\t\t       we are not dealing with a lattice.  */\n+\t\t    is_possible &= edge_layout_cost (ud, other_node_i, 0,\n+\t\t\t\t\t\t     layout_i).is_possible ();\n+\t\t};\n+\t      for_each_partition_edge (node_i, add_cost);\n+\n+\t      /* Accumulate the cost of using LAYOUT_I within NODE,\n+\t\t both for the inputs and the outputs.  */\n+\t      int factor = internal_node_cost (vertex.node, layout_i,\n+\t\t\t\t\t       layout_i);\n+\t      if (factor < 0)\n+\t\t{\n+\t\t  is_possible = false;\n+\t\t  break;\n \t\t}\n+\t      else if (factor)\n+\t\tlayout_costs.internal_cost.add_serial_cost\n+\t\t  ({ vertex.weight * factor, m_optimize_size });\n+\t    }\n+\t  if (!is_possible)\n+\t    {\n+\t      layout_costs.mark_impossible ();\n+\t      continue;\n+\t    }\n \n-\t      if (!vect_slp_perms_eq (perms, perm_in,\n-\t\t\t\t      vertices[idx].perm_in))\n+\t  /* Combine the incoming and partition-internal costs.  */\n+\t  slpg_layout_cost combined_cost = layout_costs.in_cost;\n+\t  combined_cost.add_serial_cost (layout_costs.internal_cost);\n+\n+\t  /* If this partition consists of a single VEC_PERM_EXPR, see\n+\t     if the VEC_PERM_EXPR can be changed to support output layout\n+\t     LAYOUT_I while keeping all the provisional choices of input\n+\t     layout.  */\n+\t  if (single_node\n+\t      && SLP_TREE_CODE (single_node) == VEC_PERM_EXPR)\n+\t    {\n+\t      int factor = internal_node_cost (single_node, -1, layout_i);\n+\t      if (factor >= 0)\n \t\t{\n-\t\t  /* Make sure we eventually converge.  */\n-\t\t  gcc_checking_assert (vertices[idx].perm_in == -1\n-\t\t\t\t       || perm_in == 0);\n-\t\t  vertices[idx].perm_in = perm_in;\n-\n-\t\t  /* While we can handle VEC_PERM nodes as transparent\n-\t\t     pass-through they can be a cheap materialization\n-\t\t     point as well.  In addition they can act as source\n-\t\t     of a random permutation as well.\n-\t\t     The following ensures that former materialization\n-\t\t     points that now have zero incoming permutes no\n-\t\t     longer appear as such and that former \"any\" permutes\n-\t\t     get pass-through.  We keep VEC_PERM nodes optimistic\n-\t\t     as \"any\" outgoing permute though.  */\n-\t\t  if (vertices[idx].perm_out != 0\n-\t\t      && SLP_TREE_CODE (node) != VEC_PERM_EXPR)\n-\t\t    vertices[idx].perm_out = perm_in;\n-\t\t  changed = true;\n+\t\t  auto weight = m_vertices[single_node->vertex].weight;\n+\t\t  slpg_layout_cost internal_cost\n+\t\t    = { weight * factor, m_optimize_size };\n+\n+\t\t  slpg_layout_cost alt_cost = in_cost;\n+\t\t  alt_cost.add_serial_cost (internal_cost);\n+\t\t  if (alt_cost.is_better_than (combined_cost, m_optimize_size))\n+\t\t    {\n+\t\t      combined_cost = alt_cost;\n+\t\t      layout_costs.in_cost = in_cost;\n+\t\t      layout_costs.internal_cost = internal_cost;\n+\t\t    }\n \t\t}\n \t    }\n \n-\t  /* Elide pruning at materialization points in the first\n-\t     iteration phase.  */\n-\t  if (!do_materialization)\n-\t    continue;\n+\t  /* Record the layout with the lowest cost.  Prefer layout 0 in\n+\t     the event of a tie between it and another layout.  */\n+\t  if (!min_layout_cost.is_possible ()\n+\t      || combined_cost.is_better_than (min_layout_cost,\n+\t\t\t\t\t       m_optimize_size))\n+\t    {\n+\t      min_layout_i = layout_i;\n+\t      min_layout_cost = combined_cost;\n+\t    }\n+\t}\n+\n+      /* This loop's handling of earlier partitions should ensure that\n+\t choosing the original layout for the current partition is no\n+\t less valid than it was in the original graph, even with the\n+\t provisional layout choices for those earlier partitions.  */\n+      gcc_assert (min_layout_cost.is_possible ());\n+      partition.layout = min_layout_i;\n+    }\n+}\n+\n+/* Make a backward pass through the partitions, accumulating output costs.\n+   Make a final choice of layout for each partition.  */\n+\n+void\n+vect_optimize_slp_pass::backward_pass ()\n+{\n+  for (unsigned int partition_i = m_partitions.length (); partition_i-- > 0;)\n+    {\n+      auto &partition = m_partitions[partition_i];\n \n-\t  int perm = vertices[idx].perm_out;\n-\t  if (perm == 0 || perm == -1)\n+      unsigned int min_layout_i = 0;\n+      slpg_layout_cost min_layout_cost = slpg_layout_cost::impossible ();\n+      for (unsigned int layout_i = 0; layout_i < m_perms.length (); ++layout_i)\n+\t{\n+\t  auto &layout_costs = partition_layout_costs (partition_i, layout_i);\n+\t  if (!layout_costs.is_possible ())\n \t    continue;\n \n-\t  /* Decide on permute materialization.  Look whether there's\n-\t     a use (pred) edge that is permuted differently than us.\n-\t     In that case mark ourselves so the permutation is applied.  */\n-\t  bool all_preds_permuted = slpg->vertices[idx].pred != NULL;\n-\t  if (all_preds_permuted)\n-\t    for (graph_edge *pred = slpg->vertices[idx].pred;\n-\t\t pred; pred = pred->pred_next)\n-\t      {\n-\t\tint pred_perm = vertices[pred->src].perm_in;\n-\t\tgcc_checking_assert (pred_perm != -1);\n-\t\tif (!vect_slp_perms_eq (perms, perm, pred_perm))\n-\t\t  {\n-\t\t    all_preds_permuted = false;\n-\t\t    break;\n-\t\t  }\n-\t      }\n-\t  if (!all_preds_permuted)\n+\t  /* Accumulate the costs from successor partitions.  */\n+\t  bool is_possible = true;\n+\t  for (unsigned int order_i = partition.node_begin;\n+\t       order_i < partition.node_end; ++order_i)\n \t    {\n-\t      vertices[idx].perm_out = 0;\n-\t      changed = true;\n+\t      unsigned int node_i = m_partitioned_nodes[order_i];\n+\t      auto &vertex = m_vertices[node_i];\n+\t      auto add_cost = [&](graph_edge *ud, unsigned int other_node_i)\n+\t\t{\n+\t\t  auto &other_vertex = m_vertices[other_node_i];\n+\t\t  auto &other_partition = m_partitions[other_vertex.partition];\n+\t\t  if (other_vertex.partition > vertex.partition)\n+\t\t    {\n+\t\t      /* Accumulate the incoming costs from later\n+\t\t\t partitions, plus the cost of any layout changes\n+\t\t\t on UD itself.  */\n+\t\t      auto cost = backward_cost (ud, other_node_i, layout_i);\n+\t\t      if (!cost.is_possible ())\n+\t\t\tis_possible = false;\n+\t\t      else\n+\t\t\tlayout_costs.out_cost.add_parallel_cost (cost);\n+\t\t    }\n+\t\t  else\n+\t\t    /* Make sure that earlier partitions can (if necessary\n+\t\t       or beneficial) keep the layout that they chose in\n+\t\t       the forward pass.  This ensures that there is at\n+\t\t       least one valid choice of layout.  */\n+\t\t    is_possible &= edge_layout_cost (ud, other_node_i,\n+\t\t\t\t\t\t     other_partition.layout,\n+\t\t\t\t\t\t     layout_i).is_possible ();\n+\t\t};\n+\t      for_each_partition_edge (node_i, add_cost);\n+\t    }\n+\t  if (!is_possible)\n+\t    {\n+\t      layout_costs.mark_impossible ();\n+\t      continue;\n+\t    }\n+\n+\t  /* Locally combine the costs from the forward and backward passes.\n+\t     (This combined cost is not passed on, since that would lead\n+\t     to double counting.)  */\n+\t  slpg_layout_cost combined_cost = layout_costs.in_cost;\n+\t  combined_cost.add_serial_cost (layout_costs.internal_cost);\n+\t  combined_cost.add_serial_cost (layout_costs.out_cost);\n+\n+\t  /* Record the layout with the lowest cost.  Prefer layout 0 in\n+\t     the event of a tie between it and another layout.  */\n+\t  if (!min_layout_cost.is_possible ()\n+\t      || combined_cost.is_better_than (min_layout_cost,\n+\t\t\t\t\t       m_optimize_size))\n+\t    {\n+\t      min_layout_i = layout_i;\n+\t      min_layout_cost = combined_cost;\n \t    }\n \t}\n \n-      /* If the initial propagation converged, switch on materialization\n-\t and re-propagate.  */\n-      if (!changed && !do_materialization)\n+      gcc_assert (min_layout_cost.is_possible ());\n+      partition.layout = min_layout_i;\n+    }\n+}\n+\n+/* Return a node that applies layout TO_LAYOUT_I to the original form of NODE.\n+   NODE already has the layout that was selected for its partition.  */\n+\n+slp_tree\n+vect_optimize_slp_pass::get_result_with_layout (slp_tree node,\n+\t\t\t\t\t\tunsigned int to_layout_i)\n+{\n+  unsigned int result_i = node->vertex * m_perms.length () + to_layout_i;\n+  slp_tree result = m_node_layouts[result_i];\n+  if (result)\n+    return result;\n+\n+  if (SLP_TREE_DEF_TYPE (node) == vect_constant_def\n+      || SLP_TREE_DEF_TYPE (node) == vect_external_def)\n+    {\n+      /* If the vector is uniform or unchanged, there's nothing to do.  */\n+      if (to_layout_i == 0 || vect_slp_tree_uniform_p (node))\n+\tresult = node;\n+      else\n \t{\n-\t  do_materialization = true;\n-\t  changed = true;\n+\t  auto scalar_ops = SLP_TREE_SCALAR_OPS (node).copy ();\n+\t  result = vect_create_new_slp_node (scalar_ops);\n+\t  vect_slp_permute (m_perms[to_layout_i], scalar_ops, true);\n \t}\n     }\n-  while (changed);\n-  statistics_histogram_event (cfun, \"SLP optimize perm iterations\", iteration);\n-\n-  /* Materialize.  */\n-  for (i = 0; i < vertices.length (); ++i)\n+  else\n     {\n-      int perm_in = vertices[i].perm_in;\n-      slp_tree node = vertices[i].node;\n+      unsigned int partition_i = m_vertices[node->vertex].partition;\n+      unsigned int from_layout_i = m_partitions[partition_i].layout;\n+      if (from_layout_i == to_layout_i)\n+\treturn node;\n \n-      /* First permute invariant/external original successors, we handle\n-\t those optimistically during propagation and duplicate them if\n-\t they are used with different permutations.  */\n-      unsigned j;\n-      slp_tree child;\n-      if (perm_in > 0)\n-\tFOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), j, child)\n-\t  {\n-\t    if (!child\n-\t\t|| (SLP_TREE_DEF_TYPE (child) != vect_constant_def\n-\t\t    && SLP_TREE_DEF_TYPE (child) != vect_external_def))\n-\t      continue;\n+      /* If NODE is itself a VEC_PERM_EXPR, try to create a parallel\n+\t permutation instead of a serial one.  Leave the new permutation\n+\t in TMP_PERM on success.  */\n+      auto_lane_permutation_t tmp_perm;\n+      unsigned int num_inputs = 1;\n+      if (SLP_TREE_CODE (node) == VEC_PERM_EXPR)\n+\t{\n+\t  tmp_perm.safe_splice (SLP_TREE_LANE_PERMUTATION (node));\n+\t  if (from_layout_i != 0)\n+\t    vect_slp_permute (m_perms[from_layout_i], tmp_perm, false);\n+\t  if (to_layout_i != 0)\n+\t    vect_slp_permute (m_perms[to_layout_i], tmp_perm, true);\n+\t  if (vectorizable_slp_permutation_1 (m_vinfo, nullptr, node,\n+\t\t\t\t\t      tmp_perm,\n+\t\t\t\t\t      SLP_TREE_CHILDREN (node),\n+\t\t\t\t\t      false) >= 0)\n+\t    num_inputs = SLP_TREE_CHILDREN (node).length ();\n+\t  else\n+\t    tmp_perm.truncate (0);\n+\t}\n \n-\t    /* If the vector is uniform there's nothing to do.  */\n-\t    if (vect_slp_tree_uniform_p (child))\n-\t      continue;\n+      if (dump_enabled_p ())\n+\t{\n+\t  if (tmp_perm.length () > 0)\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"duplicating permutation node %p with\"\n+\t\t\t     \" layout %d\\n\",\n+\t\t\t     node, to_layout_i);\n+\t  else\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"inserting permutation node in place of %p\\n\",\n+\t\t\t     node);\n+\t}\n \n-\t    /* We can end up sharing some externals via two_operator\n-\t       handling.  Be prepared to unshare those.  */\n-\t    if (child->refcnt != 1)\n-\t      {\n-\t\tgcc_assert (slpg->vertices[child->vertex].pred->pred_next);\n-\t\tSLP_TREE_CHILDREN (node)[j] = child\n-\t\t  = vect_create_new_slp_node\n-\t\t      (SLP_TREE_SCALAR_OPS (child).copy ());\n-\t      }\n-\t    vect_slp_permute (perms[perm_in],\n-\t\t\t      SLP_TREE_SCALAR_OPS (child), true);\n-\t  }\n+      unsigned int num_lanes = SLP_TREE_LANES (node);\n+      result = vect_create_new_slp_node (num_inputs, VEC_PERM_EXPR);\n+      if (SLP_TREE_SCALAR_STMTS (node).length ())\n+\t{\n+\t  auto &stmts = SLP_TREE_SCALAR_STMTS (result);\n+\t  stmts.safe_splice (SLP_TREE_SCALAR_STMTS (result));\n+\t  if (from_layout_i != 0)\n+\t    vect_slp_permute (m_perms[from_layout_i], stmts, false);\n+\t  if (to_layout_i != 0)\n+\t    vect_slp_permute (m_perms[to_layout_i], stmts, true);\n+\t}\n+      SLP_TREE_REPRESENTATIVE (result) = SLP_TREE_REPRESENTATIVE (node);\n+      SLP_TREE_LANES (result) = num_lanes;\n+      SLP_TREE_VECTYPE (result) = SLP_TREE_VECTYPE (node);\n+      result->vertex = -1;\n+\n+      auto &lane_perm = SLP_TREE_LANE_PERMUTATION (result);\n+      if (tmp_perm.length ())\n+\t{\n+\t  lane_perm.safe_splice (tmp_perm);\n+\t  SLP_TREE_CHILDREN (result).safe_splice (SLP_TREE_CHILDREN (node));\n+\t}\n+      else\n+\t{\n+\t  lane_perm.create (num_lanes);\n+\t  for (unsigned j = 0; j < num_lanes; ++j)\n+\t    lane_perm.quick_push ({ 0, j });\n+\t  if (from_layout_i != 0)\n+\t    vect_slp_permute (m_perms[from_layout_i], lane_perm, false);\n+\t  if (to_layout_i != 0)\n+\t    vect_slp_permute (m_perms[to_layout_i], lane_perm, true);\n+\t  SLP_TREE_CHILDREN (result).safe_push (node);\n+\t}\n+      for (slp_tree child : SLP_TREE_CHILDREN (result))\n+\tchild->refcnt++;\n+    }\n+  m_node_layouts[result_i] = result;\n+  return result;\n+}\n+\n+/* Apply the chosen vector layouts to the SLP graph.  */\n \n+void\n+vect_optimize_slp_pass::materialize ()\n+{\n+  /* We no longer need the costs, so avoid having two O(N * P) arrays\n+     live at the same time.  */\n+  m_partition_layout_costs.release ();\n+  m_node_layouts.safe_grow_cleared (m_vertices.length () * m_perms.length ());\n+\n+  auto_sbitmap fully_folded (m_vertices.length ());\n+  bitmap_clear (fully_folded);\n+  for (unsigned int node_i : m_partitioned_nodes)\n+    {\n+      auto &vertex = m_vertices[node_i];\n+      slp_tree node = vertex.node;\n+      int layout_i = m_partitions[vertex.partition].layout;\n+      gcc_assert (layout_i >= 0);\n+\n+      /* Rearrange the scalar statements to match the chosen layout.  */\n+      if (layout_i > 0)\n+\tvect_slp_permute (m_perms[layout_i],\n+\t\t\t  SLP_TREE_SCALAR_STMTS (node), true);\n+\n+      /* Update load and lane permutations.  */\n       if (SLP_TREE_CODE (node) == VEC_PERM_EXPR)\n \t{\n-\t  /* Apply the common permutes to the input vectors.  */\n-\t  if (perm_in > 0)\n+\t  /* First try to absorb the input vector layouts.  If that fails,\n+\t     force the inputs to have layout LAYOUT_I too.  We checked that\n+\t     that was possible before deciding to use nonzero output layouts.\n+\t     (Note that at this stage we don't really have any guarantee that\n+\t     the target supports the original VEC_PERM_EXPR.)  */\n+\t  auto &perm = SLP_TREE_LANE_PERMUTATION (node);\n+\t  auto_lane_permutation_t tmp_perm;\n+\t  tmp_perm.safe_splice (perm);\n+\t  change_vec_perm_layout (node, tmp_perm, -1, layout_i);\n+\t  if (vectorizable_slp_permutation_1 (m_vinfo, nullptr, node,\n+\t\t\t\t\t      tmp_perm,\n+\t\t\t\t\t      SLP_TREE_CHILDREN (node),\n+\t\t\t\t\t      false) >= 0)\n \t    {\n-\t      /* If the node is already a permute node we can apply\n-\t\t the permutation to the lane selection, effectively\n-\t\t materializing it on the incoming vectors.  */\n-\t      if (dump_enabled_p ())\n+\t      if (dump_enabled_p ()\n+\t\t  && !std::equal (tmp_perm.begin (), tmp_perm.end (),\n+\t\t\t\t  perm.begin ()))\n \t\tdump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t\t \"simplifying permute node %p\\n\",\n-\t\t\t\t node);\n-\t      for (unsigned k = 0;\n-\t\t   k < SLP_TREE_LANE_PERMUTATION (node).length (); ++k)\n-\t\tSLP_TREE_LANE_PERMUTATION (node)[k].second\n-\t\t  = perms[perm_in][SLP_TREE_LANE_PERMUTATION (node)[k].second];\n-\t    }\n-\t  /* Apply the anticipated output permute to the permute and\n-\t     stmt vectors.  */\n-\t  int perm_out = vertices[i].perm_out;\n-\t  if (perm_out > 0)\n-\t    {\n-\t      vect_slp_permute (perms[perm_out],\n-\t\t\t\tSLP_TREE_SCALAR_STMTS (node), true);\n-\t      vect_slp_permute (perms[perm_out],\n-\t\t\t\tSLP_TREE_LANE_PERMUTATION (node), true);\n+\t\t\t\t \"absorbing input layouts into %p\\n\", node);\n+\t      std::copy (tmp_perm.begin (), tmp_perm.end (), perm.begin ());\n+\t      bitmap_set_bit (fully_folded, node_i);\n \t    }\n-\t}\n-      else if (vertices[i].get_perm_materialized () != 0)\n-\t{\n-\t  if (SLP_TREE_LOAD_PERMUTATION (node).exists ())\n-\t    /* For loads simply drop the permutation, the load permutation\n-\t       already performs the desired permutation.  */\n-\t    ;\n-\t  else if (SLP_TREE_LANE_PERMUTATION (node).exists ())\n-\t    gcc_unreachable ();\n \t  else\n \t    {\n+\t      /* Not MSG_MISSED because it would make no sense to users.  */\n \t      if (dump_enabled_p ())\n \t\tdump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t\t \"inserting permute node in place of %p\\n\",\n+\t\t\t\t \"failed to absorb input layouts into %p\\n\",\n \t\t\t\t node);\n-\n-\t      /* Make a copy of NODE and in-place change it to a\n-\t\t VEC_PERM node to permute the lanes of the copy.  */\n-\t      slp_tree copy = new _slp_tree;\n-\t      SLP_TREE_CHILDREN (copy) = SLP_TREE_CHILDREN (node);\n-\t      SLP_TREE_CHILDREN (node) = vNULL;\n-\t      SLP_TREE_SCALAR_STMTS (copy)\n-\t\t= SLP_TREE_SCALAR_STMTS (node).copy ();\n-\t      vect_slp_permute (perms[perm_in],\n-\t\t\t\tSLP_TREE_SCALAR_STMTS (copy), true);\n-\t      gcc_assert (!SLP_TREE_SCALAR_OPS (node).exists ());\n-\t      SLP_TREE_REPRESENTATIVE (copy) = SLP_TREE_REPRESENTATIVE (node);\n-\t      gcc_assert (!SLP_TREE_LOAD_PERMUTATION (node).exists ());\n-\t      SLP_TREE_LANE_PERMUTATION (copy)\n-\t\t= SLP_TREE_LANE_PERMUTATION (node);\n-\t      SLP_TREE_LANE_PERMUTATION (node) = vNULL;\n-\t      SLP_TREE_VECTYPE (copy) = SLP_TREE_VECTYPE (node);\n-\t      copy->refcnt = 1;\n-\t      copy->max_nunits = node->max_nunits;\n-\t      SLP_TREE_DEF_TYPE (copy) = SLP_TREE_DEF_TYPE (node);\n-\t      SLP_TREE_LANES (copy) = SLP_TREE_LANES (node);\n-\t      SLP_TREE_CODE (copy) = SLP_TREE_CODE (node);\n-\n-\t      /* Now turn NODE into a VEC_PERM.  */\n-\t      SLP_TREE_CHILDREN (node).safe_push (copy);\n-\t      SLP_TREE_LANE_PERMUTATION (node).create (SLP_TREE_LANES (node));\n-\t      for (unsigned j = 0; j < SLP_TREE_LANES (node); ++j)\n-\t\tSLP_TREE_LANE_PERMUTATION (node)\n-\t\t  .quick_push (std::make_pair (0, perms[perm_in][j]));\n-\t      SLP_TREE_CODE (node) = VEC_PERM_EXPR;\n+\t      change_vec_perm_layout (nullptr, perm, layout_i, layout_i);\n \t    }\n \t}\n-      else if (perm_in > 0) /* perm_in == perm_out */\n+      else\n \t{\n-\t  /* Apply the reverse permutation to our stmts.  */\n-\t  vect_slp_permute (perms[perm_in],\n-\t\t\t    SLP_TREE_SCALAR_STMTS (node), true);\n-\t  /* And to the lane/load permutation, which we can simply\n-\t     make regular by design.  */\n-\t  if (SLP_TREE_LOAD_PERMUTATION (node).exists ())\n-\t    {\n-\t      gcc_assert (!SLP_TREE_LANE_PERMUTATION (node).exists ());\n-\t      /* ???  When we handle non-bijective permutes the idea\n-\t\t is that we can force the load-permutation to be\n-\t\t { min, min + 1, min + 2, ... max }.  But then the\n-\t\t scalar defs might no longer match the lane content\n-\t\t which means wrong-code with live lane vectorization.\n-\t\t So we possibly have to have NULL entries for those.  */\n-\t      vect_slp_permute (perms[perm_in],\n-\t\t\t\tSLP_TREE_LOAD_PERMUTATION (node), true);\n-\t    }\n-\t  else if (SLP_TREE_LANE_PERMUTATION (node).exists ())\n-\t    gcc_unreachable ();\n+\t  gcc_assert (!SLP_TREE_LANE_PERMUTATION (node).exists ());\n+\t  auto &load_perm = SLP_TREE_LOAD_PERMUTATION (node);\n+\t  if (layout_i > 0)\n+\t    /* ???  When we handle non-bijective permutes the idea\n+\t       is that we can force the load-permutation to be\n+\t       { min, min + 1, min + 2, ... max }.  But then the\n+\t       scalar defs might no longer match the lane content\n+\t       which means wrong-code with live lane vectorization.\n+\t       So we possibly have to have NULL entries for those.  */\n+\t    vect_slp_permute (m_perms[layout_i], load_perm, true);\n \t}\n     }\n \n-  /* Elide any permutations at BB reduction roots.  */\n-  if (is_a <bb_vec_info> (vinfo))\n+  /* Do this before any nodes disappear, since it involves a walk\n+     over the leaves.  */\n+  remove_redundant_permutations ();\n+\n+  /* Replace each child with a correctly laid-out version.  */\n+  for (unsigned int node_i : m_partitioned_nodes)\n     {\n-      for (slp_instance instance : vinfo->slp_instances)\n+      /* Skip nodes that have already been handled above.  */\n+      if (bitmap_bit_p (fully_folded, node_i))\n+\tcontinue;\n+\n+      auto &vertex = m_vertices[node_i];\n+      int in_layout_i = m_partitions[vertex.partition].layout;\n+      gcc_assert (in_layout_i >= 0);\n+\n+      unsigned j;\n+      slp_tree child;\n+      FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (vertex.node), j, child)\n \t{\n-\t  if (SLP_INSTANCE_KIND (instance) != slp_inst_kind_bb_reduc)\n+\t  if (!child)\n \t    continue;\n-\t  slp_tree old = SLP_INSTANCE_TREE (instance);\n-\t  if (SLP_TREE_CODE (old) == VEC_PERM_EXPR\n-\t      && SLP_TREE_CHILDREN (old).length () == 1)\n-\t    {\n-\t      slp_tree child = SLP_TREE_CHILDREN (old)[0];\n-\t      if (SLP_TREE_DEF_TYPE (child) == vect_external_def)\n-\t\t{\n-\t\t  /* Preserve the special VEC_PERM we use to shield existing\n-\t\t     vector defs from the rest.  But make it a no-op.  */\n-\t\t  unsigned i = 0;\n-\t\t  for (std::pair<unsigned, unsigned> &p\n-\t\t       : SLP_TREE_LANE_PERMUTATION (old))\n-\t\t    p.second = i++;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  SLP_INSTANCE_TREE (instance) = child;\n-\t\t  SLP_TREE_REF_COUNT (child)++;\n-\t\t  vect_free_slp_tree (old);\n-\t\t}\n-\t    }\n-\t  else if (SLP_TREE_LOAD_PERMUTATION (old).exists ()\n-\t\t   && SLP_TREE_REF_COUNT (old) == 1\n-\t\t   && vertices[old->vertex].get_perm_materialized () != 0)\n+\n+\t  slp_tree new_child = get_result_with_layout (child, in_layout_i);\n+\t  if (new_child != child)\n \t    {\n-\t      /* ???  For loads the situation is more complex since\n-\t\t we can't modify the permute in place in case the\n-\t\t node is used multiple times.  In fact for loads this\n-\t\t should be somehow handled in the propagation engine.  */\n-\t      /* Apply the reverse permutation to our stmts.  */\n-\t      int perm = vertices[old->vertex].get_perm_materialized ();\n-\t      vect_slp_permute (perms[perm],\n-\t\t\t\tSLP_TREE_SCALAR_STMTS (old), true);\n-\t      vect_slp_permute (perms[perm],\n-\t\t\t\tSLP_TREE_LOAD_PERMUTATION (old), true);\n+\t      vect_free_slp_tree (child);\n+\t      SLP_TREE_CHILDREN (vertex.node)[j] = new_child;\n+\t      new_child->refcnt += 1;\n \t    }\n \t}\n     }\n+}\n \n-  /* Free the perms vector used for propagation.  */\n-  while (!perms.is_empty ())\n-    perms.pop ().release ();\n-  free_graph (slpg);\n-\n+/* Elide load permutations that are not necessary.  Such permutations might\n+   be pre-existing, rather than created by the layout optimizations.  */\n \n-  /* Now elide load permutations that are not necessary.  */\n-  for (i = 0; i < leafs.length (); ++i)\n+void\n+vect_optimize_slp_pass::remove_redundant_permutations ()\n+{\n+  for (unsigned int node_i : m_leafs)\n     {\n-      node = vertices[leafs[i]].node;\n+      slp_tree node = m_vertices[node_i].node;\n       if (!SLP_TREE_LOAD_PERMUTATION (node).exists ())\n \tcontinue;\n \n       /* In basic block vectorization we allow any subchain of an interleaving\n \t chain.\n \t FORNOW: not in loop SLP because of realignment complications.  */\n-      if (is_a <bb_vec_info> (vinfo))\n+      if (is_a <bb_vec_info> (m_vinfo))\n \t{\n \t  bool subchain_p = true;\n \t  stmt_vec_info next_load_info = NULL;\n@@ -4160,6 +5347,7 @@ vect_optimize_slp (vec_info *vinfo)\n \t}\n       else\n \t{\n+\t  loop_vec_info loop_vinfo = as_a<loop_vec_info> (m_vinfo);\n \t  stmt_vec_info load_info;\n \t  bool this_load_permuted = false;\n \t  unsigned j;\n@@ -4175,8 +5363,7 @@ vect_optimize_slp (vec_info *vinfo)\n \t      /* The load requires permutation when unrolling exposes\n \t\t a gap either because the group is larger than the SLP\n \t\t group-size or because there is a gap between the groups.  */\n-\t      && (known_eq (LOOP_VINFO_VECT_FACTOR\n-\t\t\t      (as_a <loop_vec_info> (vinfo)), 1U)\n+\t      && (known_eq (LOOP_VINFO_VECT_FACTOR (loop_vinfo), 1U)\n \t\t  || ((SLP_TREE_LANES (node) == DR_GROUP_SIZE (first_stmt_info))\n \t\t      && DR_GROUP_GAP (first_stmt_info) == 0)))\n \t    {\n@@ -4187,6 +5374,150 @@ vect_optimize_slp (vec_info *vinfo)\n     }\n }\n \n+/* Print the partition graph and layout information to the dump file.  */\n+\n+void\n+vect_optimize_slp_pass::dump ()\n+{\n+  dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t   \"SLP optimize permutations:\\n\");\n+  for (unsigned int layout_i = 1; layout_i < m_perms.length (); ++layout_i)\n+    {\n+      dump_printf_loc (MSG_NOTE, vect_location, \"  %d: { \", layout_i);\n+      const char *sep = \"\";\n+      for (unsigned int idx : m_perms[layout_i])\n+\t{\n+\t  dump_printf (MSG_NOTE, \"%s%d\", sep, idx);\n+\t  sep = \", \";\n+\t}\n+      dump_printf (MSG_NOTE, \" }\\n\");\n+    }\n+  dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t   \"SLP optimize partitions:\\n\");\n+  for (unsigned int partition_i = 0; partition_i < m_partitions.length ();\n+       ++partition_i)\n+    {\n+      auto &partition = m_partitions[partition_i];\n+      dump_printf_loc (MSG_NOTE, vect_location,  \"  -------------\\n\");\n+      dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t       \"  partition %d (layout %d):\\n\",\n+\t\t       partition_i, partition.layout);\n+      dump_printf_loc (MSG_NOTE, vect_location, \"    nodes:\\n\");\n+      for (unsigned int order_i = partition.node_begin;\n+\t   order_i < partition.node_end; ++order_i)\n+\t{\n+\t  auto &vertex = m_vertices[m_partitioned_nodes[order_i]];\n+\t  dump_printf_loc (MSG_NOTE, vect_location, \"      - %p:\\n\",\n+\t\t\t   (void *) vertex.node);\n+\t  dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t   \"          weight: %f\\n\",\n+\t\t\t   vertex.weight.to_double ());\n+\t  if (vertex.out_degree)\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"          out weight: %f (degree %d)\\n\",\n+\t\t\t     vertex.out_weight.to_double (),\n+\t\t\t     vertex.out_degree);\n+\t  if (SLP_TREE_CODE (vertex.node) == VEC_PERM_EXPR)\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"          op: VEC_PERM_EXPR\\n\");\n+\t  else if (auto rep = SLP_TREE_REPRESENTATIVE (vertex.node))\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"          op template: %G\", rep->stmt);\n+\t}\n+      dump_printf_loc (MSG_NOTE, vect_location, \"    edges:\\n\");\n+      for (unsigned int order_i = partition.node_begin;\n+\t   order_i < partition.node_end; ++order_i)\n+\t{\n+\t  unsigned int node_i = m_partitioned_nodes[order_i];\n+\t  auto &vertex = m_vertices[node_i];\n+\t  auto print_edge = [&](graph_edge *, unsigned int other_node_i)\n+\t    {\n+\t      auto &other_vertex = m_vertices[other_node_i];\n+\t      if (other_vertex.partition < vertex.partition)\n+\t\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t\t \"      - %p [%d] --> %p\\n\",\n+\t\t\t\t other_vertex.node, other_vertex.partition,\n+\t\t\t\t vertex.node);\n+\t      else\n+\t\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t\t \"      - %p --> [%d] %p\\n\",\n+\t\t\t\t vertex.node, other_vertex.partition,\n+\t\t\t\t other_vertex.node);\n+\t    };\n+\t  for_each_partition_edge (node_i, print_edge);\n+\t}\n+\n+      for (unsigned int layout_i = 0; layout_i < m_perms.length (); ++layout_i)\n+\t{\n+\t  auto &layout_costs = partition_layout_costs (partition_i, layout_i);\n+\t  if (layout_costs.is_possible ())\n+\t    {\n+\t      dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t       \"    layout %d:%s\\n\", layout_i,\n+\t\t\t       partition.layout == int (layout_i)\n+\t\t\t       ? \" (*)\" : \"\");\n+\t      slpg_layout_cost combined_cost = layout_costs.in_cost;\n+\t      combined_cost.add_serial_cost (layout_costs.internal_cost);\n+\t      combined_cost.add_serial_cost (layout_costs.out_cost);\n+#define TEMPLATE \"{depth: %f, total: %f}\"\n+\t      dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t       \"        \" TEMPLATE \"\\n\", layout_i,\n+\t\t\t       layout_costs.in_cost.depth.to_double (),\n+\t\t\t       layout_costs.in_cost.total.to_double ());\n+\t      dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t       \"      + \" TEMPLATE \"\\n\",\n+\t\t\t       layout_costs.internal_cost.depth.to_double (),\n+\t\t\t       layout_costs.internal_cost.total.to_double ());\n+\t      dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t       \"      + \" TEMPLATE \"\\n\",\n+\t\t\t       layout_costs.out_cost.depth.to_double (),\n+\t\t\t       layout_costs.out_cost.total.to_double ());\n+\t      dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t       \"      = \" TEMPLATE \"\\n\",\n+\t\t\t       combined_cost.depth.to_double (),\n+\t\t\t       combined_cost.total.to_double ());\n+#undef TEMPLATE\n+\t    }\n+\t  else\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"    layout %d: rejected\\n\", layout_i);\n+\t}\n+    }\n+}\n+\n+/* Main entry point for the SLP graph optimization pass.  */\n+\n+void\n+vect_optimize_slp_pass::run ()\n+{\n+  build_graph ();\n+  create_partitions ();\n+  start_choosing_layouts ();\n+  if (m_perms.length () > 1)\n+    {\n+      forward_pass ();\n+      backward_pass ();\n+      if (dump_enabled_p ())\n+\tdump ();\n+      materialize ();\n+      while (!m_perms.is_empty ())\n+\tm_perms.pop ().release ();\n+    }\n+  else\n+    remove_redundant_permutations ();\n+  free_graph (m_slpg);\n+}\n+\n+/* Optimize the SLP graph of VINFO.  */\n+\n+void\n+vect_optimize_slp (vec_info *vinfo)\n+{\n+  if (vinfo->slp_instances.is_empty ())\n+    return;\n+  vect_optimize_slp_pass (vinfo).run ();\n+}\n+\n /* Gather loads reachable from the individual SLP graph entries.  */\n \n void"}, {"sha": "a2b0afb8a4192109c05b6122be69a3fff5f9a240", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61c4c989034548f481d1f10198447be27fb9a55f/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61c4c989034548f481d1f10198447be27fb9a55f/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=61c4c989034548f481d1f10198447be27fb9a55f", "patch": "@@ -154,7 +154,9 @@ struct vect_scalar_ops_slice_hash : typed_noop_remove<vect_scalar_ops_slice>\n   SLP\n  ************************************************************************/\n typedef vec<std::pair<unsigned, unsigned> > lane_permutation_t;\n+typedef auto_vec<std::pair<unsigned, unsigned>, 16> auto_lane_permutation_t;\n typedef vec<unsigned> load_permutation_t;\n+typedef auto_vec<unsigned, 16> auto_load_permutation_t;\n \n /* A computation tree of an SLP instance.  Each node corresponds to a group of\n    stmts to be packed in a SIMD stmt.  */"}]}