{"sha": "46ed811bcb4b86a81ef3d78ea8cfffc6cd043144", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDZlZDgxMWJjYjRiODZhODFlZjNkNzhlYThjZmZmYzZjZDA0MzE0NA==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-05-24T19:24:44Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-05-24T19:24:44Z"}, "message": "libstdc++: Fix iterator caching inside range adaptors [PR100479]\n\nThis fixes two issues with our iterator caching as described in detail\nin the PR.  Since we recently added the __non_propagating_cache class\ntemplate as part of r12-336 for P2328, this patch just rewrites the\nproblematic _CachedPosition partial specialization in terms of this\nclass template.\n\nFor the offset partial specialization, it's safe to propagate the cached\noffset on copy/move, but we should still invalidate the cached offset in\nthe source object on move.\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/100479\n\t* include/std/ranges (__detail::__non_propagating_cache): Move\n\tdefinition up to before that of _CachedPosition.  Make base\n\tclass _Optional_base protected instead of private.  Add const\n\toverload for operator*.\n\t(__detail::_CachedPosition): Rewrite the partial specialization\n\tfor forward ranges as a derived class of __non_propagating_cache.\n\tRemove the size constraint on the partial specialization for\n\trandom access ranges.  Add copy/move/copy-assignment/move-assignment\n\tmembers to the offset partial specialization for random\n\taccess ranges that propagate the cached value but additionally\n\tinvalidate it in the source object on move.\n\t* testsuite/std/ranges/adaptors/100479.cc: New test.", "tree": {"sha": "4b7829c60803aa3e33be3cc9ebd61e2630fb93db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b7829c60803aa3e33be3cc9ebd61e2630fb93db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/46ed811bcb4b86a81ef3d78ea8cfffc6cd043144", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46ed811bcb4b86a81ef3d78ea8cfffc6cd043144", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46ed811bcb4b86a81ef3d78ea8cfffc6cd043144", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46ed811bcb4b86a81ef3d78ea8cfffc6cd043144/comments", "author": null, "committer": null, "parents": [{"sha": "6fdc59f196c3e1b4aeeb8a0407d4eb40645c5251", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fdc59f196c3e1b4aeeb8a0407d4eb40645c5251", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fdc59f196c3e1b4aeeb8a0407d4eb40645c5251"}], "stats": {"total": 268, "additions": 201, "deletions": 67}, "files": [{"sha": "e1df42401174f96b727ff2169a09d9c90e281357", "filename": "libstdc++-v3/include/std/ranges", "status": "modified", "additions": 88, "deletions": 67, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46ed811bcb4b86a81ef3d78ea8cfffc6cd043144/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46ed811bcb4b86a81ef3d78ea8cfffc6cd043144/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges?ref=46ed811bcb4b86a81ef3d78ea8cfffc6cd043144", "patch": "@@ -1043,6 +1043,67 @@ namespace views::__adaptor\n \n   namespace __detail\n   {\n+    template<typename _Tp>\n+      struct __non_propagating_cache\n+      {\n+\t// When _Tp is not an object type (e.g. is a reference type), we make\n+\t// __non_propagating_cache<_Tp> empty rather than ill-formed so that\n+\t// users can easily conditionally declare data members with this type\n+\t// (such as join_view::_M_inner).\n+      };\n+\n+    template<typename _Tp>\n+      requires is_object_v<_Tp>\n+      struct __non_propagating_cache<_Tp> : protected _Optional_base<_Tp>\n+      {\n+\t__non_propagating_cache() = default;\n+\n+\tconstexpr\n+\t__non_propagating_cache(const __non_propagating_cache&) noexcept\n+\t{ }\n+\n+\tconstexpr\n+\t__non_propagating_cache(__non_propagating_cache&& __other) noexcept\n+\t{ __other._M_reset(); }\n+\n+\tconstexpr __non_propagating_cache&\n+\toperator=(const __non_propagating_cache& __other) noexcept\n+\t{\n+\t  if (std::__addressof(__other) != this)\n+\t    this->_M_reset();\n+\t  return *this;\n+\t}\n+\n+\tconstexpr __non_propagating_cache&\n+\toperator=(__non_propagating_cache&& __other) noexcept\n+\t{\n+\t  this->_M_reset();\n+\t  __other._M_reset();\n+\t  return *this;\n+\t}\n+\n+\tconstexpr _Tp&\n+\toperator*() noexcept\n+\t{ return this->_M_get(); }\n+\n+\tconstexpr const _Tp&\n+\toperator*() const noexcept\n+\t{ return this->_M_get(); }\n+\n+\ttemplate<typename _Iter>\n+\t  _Tp&\n+\t  _M_emplace_deref(const _Iter& __i)\n+\t  {\n+\t    this->_M_reset();\n+\t    // Using _Optional_base::_M_construct to initialize from '*__i'\n+\t    // would incur an extra move due to the indirection, so we instead\n+\t    // use placement new directly.\n+\t    ::new ((void *) std::__addressof(this->_M_payload._M_payload)) _Tp(*__i);\n+\t    this->_M_payload._M_engaged = true;\n+\t    return this->_M_get();\n+\t  }\n+      };\n+\n     template<range _Range>\n       struct _CachedPosition\n       {\n@@ -1064,27 +1125,26 @@ namespace views::__adaptor\n \n     template<forward_range _Range>\n       struct _CachedPosition<_Range>\n+\t: protected __non_propagating_cache<iterator_t<_Range>>\n       {\n-      private:\n-\titerator_t<_Range> _M_iter{};\n-\n-      public:\n \tconstexpr bool\n \t_M_has_value() const\n-\t{ return _M_iter != iterator_t<_Range>{}; }\n+\t{ return this->_M_is_engaged(); }\n \n \tconstexpr iterator_t<_Range>\n \t_M_get(const _Range&) const\n \t{\n \t  __glibcxx_assert(_M_has_value());\n-\t  return _M_iter;\n+\t  return **this;\n \t}\n \n \tconstexpr void\n \t_M_set(const _Range&, const iterator_t<_Range>& __it)\n \t{\n \t  __glibcxx_assert(!_M_has_value());\n-\t  _M_iter = __it;\n+\t  std::construct_at(std::__addressof(this->_M_payload._M_payload),\n+\t\t\t    in_place, __it);\n+\t  this->_M_payload._M_engaged = true;\n \t}\n       };\n \n@@ -1097,6 +1157,27 @@ namespace views::__adaptor\n \trange_difference_t<_Range> _M_offset = -1;\n \n       public:\n+\t_CachedPosition() = default;\n+\n+\tconstexpr\n+\t_CachedPosition(const _CachedPosition&) = default;\n+\n+\tconstexpr\n+\t_CachedPosition(_CachedPosition&& __other) noexcept\n+\t{ *this = std::move(__other); }\n+\n+\tconstexpr _CachedPosition&\n+\toperator=(const _CachedPosition&) = default;\n+\n+\tconstexpr _CachedPosition&\n+\toperator=(_CachedPosition&& __other) noexcept\n+\t{\n+\t  // Propagate the cached offset, but invalidate the source.\n+\t  _M_offset = __other._M_offset;\n+\t  __other._M_offset = -1;\n+\t  return *this;\n+\t}\n+\n \tconstexpr bool\n \t_M_has_value() const\n \t{ return _M_offset >= 0; }\n@@ -2238,66 +2319,6 @@ namespace views::__adaptor\n     inline constexpr _DropWhile drop_while;\n   } // namespace views\n \n-  namespace __detail\n-  {\n-    template<typename _Tp>\n-      struct __non_propagating_cache\n-      {\n-\t// When _Tp is not an object type (e.g. is a reference type), we make\n-\t// __non_propagating_cache<_Tp> empty rather than ill-formed so that\n-\t// users can easily conditionally declare data members with this type\n-\t// (such as join_view::_M_inner).\n-      };\n-\n-    template<typename _Tp>\n-      requires is_object_v<_Tp>\n-      struct __non_propagating_cache<_Tp> : private _Optional_base<_Tp>\n-      {\n-\t__non_propagating_cache() = default;\n-\n-\tconstexpr\n-\t__non_propagating_cache(const __non_propagating_cache&) noexcept\n-\t{ }\n-\n-\tconstexpr\n-\t__non_propagating_cache(__non_propagating_cache&& __other) noexcept\n-\t{ __other._M_reset(); }\n-\n-\tconstexpr __non_propagating_cache&\n-\toperator=(const __non_propagating_cache& __other) noexcept\n-\t{\n-\t  if (std::__addressof(__other) != this)\n-\t    this->_M_reset();\n-\t  return *this;\n-\t}\n-\n-\tconstexpr __non_propagating_cache&\n-\toperator=(__non_propagating_cache&& __other) noexcept\n-\t{\n-\t  this->_M_reset();\n-\t  __other._M_reset();\n-\t  return *this;\n-\t}\n-\n-\tconstexpr _Tp&\n-\toperator*() noexcept\n-\t{ return this->_M_get(); }\n-\n-\ttemplate<typename _Iter>\n-\t  _Tp&\n-\t  _M_emplace_deref(const _Iter& __i)\n-\t  {\n-\t    this->_M_reset();\n-\t    // Using _Optional_base::_M_construct to initialize from '*__i'\n-\t    // would incur an extra move due to the indirection, so we instead\n-\t    // use placement new directly.\n-\t    ::new ((void *) std::__addressof(this->_M_payload._M_payload)) _Tp(*__i);\n-\t    this->_M_payload._M_engaged = true;\n-\t    return this->_M_get();\n-\t  }\n-      };\n-  }\n-\n   template<input_range _Vp>\n     requires view<_Vp> && input_range<range_reference_t<_Vp>>\n     class join_view : public view_interface<join_view<_Vp>>"}, {"sha": "ba10b7baf3f522c228891a5208371bb3c06e22db", "filename": "libstdc++-v3/testsuite/std/ranges/adaptors/100479.cc", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46ed811bcb4b86a81ef3d78ea8cfffc6cd043144/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2F100479.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46ed811bcb4b86a81ef3d78ea8cfffc6cd043144/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2F100479.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2F100479.cc?ref=46ed811bcb4b86a81ef3d78ea8cfffc6cd043144", "patch": "@@ -0,0 +1,113 @@\n+// Copyright (C) 2021 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+// PR libstdc++/100479\n+\n+#include <ranges>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_forward_range;\n+using __gnu_test::test_random_access_range;\n+\n+namespace ranges = std::ranges;\n+namespace views = std::views;\n+\n+void\n+test01()\n+{\n+  // Verify we don't propagate cached iterators when copying/moving an adapted\n+  // forward range that memoizes its begin().\n+  static int pred_counter;\n+  int x[] = {1,2,3,4,5};\n+  test_forward_range rx(x);\n+  auto is_odd = [](auto n) { ++pred_counter; return n%2 != 0; };\n+\n+  auto v = rx | views::filter(is_odd);\n+  v.begin(); v.begin();\n+  VERIFY( pred_counter == 1 ); // filter_view caches its begin() iterator\n+\n+  auto w = v;\n+  v.begin(); v.begin();\n+  VERIFY( pred_counter == 1 ); // cached iterator not invalidated on copy\n+  w.begin(); w.begin();\n+  VERIFY( pred_counter == 2 ); // cached iterator not propagated on copy\n+\n+  auto z = std::move(w);\n+  w.begin(); w.begin();\n+  VERIFY( pred_counter == 3 ); // cached iterator invalidated on move\n+  z.begin(); z.begin();\n+  VERIFY( pred_counter == 4 ); // cached iterator not propagated on move\n+}\n+\n+void\n+test02()\n+{\n+  // Verify we invalidate the cached offset when moving an adapted\n+  // random access range that memoizes its begin().\n+  static int pred_counter;\n+  int x[] = {1,2,3,4,5};\n+  test_random_access_range rx(x);\n+  auto is_odd = [](auto n) { ++pred_counter; return n%2 != 0; };\n+\n+  auto v = rx | views::filter(is_odd);\n+  v.begin(); v.begin();\n+  VERIFY( pred_counter == 1 ); // filter_view caches its begin() iterator\n+\n+  auto w = v;\n+  v.begin(); v.begin();\n+  VERIFY( pred_counter == 1 ); // cached offset not invalidated on copy\n+  w.begin(); w.begin();\n+  VERIFY( pred_counter == 1 ); // cached offset propagated on copy\n+\n+  auto z = std::move(w);\n+  w.begin(); w.begin();\n+  VERIFY( pred_counter == 2 ); // cached offset invalidated on move\n+  z.begin(); z.begin();\n+  VERIFY( pred_counter == 2 ); // cached offset propagated on move\n+}\n+\n+constexpr bool\n+test03()\n+{\n+  // Propagating cached iterators during copy/move would cause these asserts\n+  // to fail here.\n+  auto v = views::single(1)\n+    | views::split(1)\n+    | views::drop(0)\n+    | views::drop_while([](auto) { return false; })\n+    | views::filter([](auto) { return true; });\n+  static_assert(ranges::forward_range<decltype(v)>);\n+  VERIFY( ranges::next(v.begin()) == v.end() );\n+  auto w = v;\n+  VERIFY( ranges::next(w.begin()) == w.end() );\n+  auto z = std::move(w);\n+  VERIFY( ranges::next(z.begin()) == z.end() );\n+  return true;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  static_assert(test03());\n+}"}]}