{"sha": "f470c378ac3e1ee9261034709851f4c6ef068fef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjQ3MGMzNzhhYzNlMWVlOTI2MTAzNDcwOTg1MWY0YzZlZjA2OGZlZg==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@atrey.karlin.mff.cuni.cz", "date": "2004-01-29T07:47:56Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2004-01-29T07:47:56Z"}, "message": "Makefile.in (cfghooks.o): Add TIMEVAR_H and toplev.h dependency.\n\n\t* Makefile.in (cfghooks.o): Add TIMEVAR_H and toplev.h dependency.\n\t* basic-block.h (tidy_fallthru_edge, tidy_fallthru_edges, dump_bb,\n\tverify_flow_info): Declaration removed.\n\t* cfg.c (verify_flow_info, dump_bb): Moved to cfghooks.c.\n\t(debug_bb, debug_bb_n): Add argument to dump_bb call.\n\t* cfgcleanup.c (try_simplify_condjump, try_crossjump_to_edge,\n\ttry_optimize_cfg, delete_unreachable_blocks): Use delete_basic_block\n\tinstead of delete_block.\n\t* cfghooks.c: Include timevar.h and toplev.h.\n\t(cfg_hooks): Define here.\n\t(verify_flow_info, dump_bb): Moved from cfg.c.\n\t(redirect_edge_and_branch, redirect_edge_and_branch_force,\n\tsplit_block, split_block_after_labels, move_block_after,\n\tdelete_basic_block, split_edge, create_basic_block,\n\tcreate_empty_bb, can_merge_blocks_p, merge_blocks,\n\tmake_forwarder_block, tidy_fallthru_edge, tidy_fallthru_edges):\n\tNew functions.\n\t* cfghooks.h (struct cfg_hooks): Added fields name,\n\tmake_forwarder_block, tidy_fallthru_edge and\n\tmove_block_after. Changed type of verify_flow_info, dump_bb,\n\tsplit_block fields. Renamed cfgh_split_edge and delete_block\n\tfields.\n\t(redirect_edge_and_branch, redirect_edge_and_branch_force,\n\tsplit_block, delete_block, split_edge, create_basic_block,\n\tcan_merge_blocks_p, merge_blocks): Macros removed.\n\t(cfg_hooks): Do not export.\n\t(verify_flow_info, dump_bb, redirect_edge_and_branch,\n\tredirect_edge_and_branch_force, split_block, split_block_after_labels,\n\tmove_block_after, delete_basic_block, split_edge, create_basic_block,\n\tcreate_empty_bb, can_merge_blocks_p, merge_blocks,\n\tmake_forwarder_block, tidy_fallthru_edge, tidy_fallthru_edges):\n\tDeclare.\n\t(cfg_layout_rtl_cfg_hooks): Declare.\n\t* cfgloop.c (update_latch_info, mfb_keep_just, mfb_keep_nonlatch):\n\tNew functions.\n\t(canonicalize_loop_headers): Use new semantics of make_forwarder_block.\n\t(redirect_edge_with_latch_update): Removed.\n\t(make_forwarder_block): Moved to cfghooks.c, semantics changed.\n\t* cfgloopmanip.c (remove_bbs): Do not update dominators here.\n\t* cfgrtl.c (cfg_layout_split_block, rtl_split_block, rtl_dump_bb,\n\trtl_delete_block, rtl_split_block, rtl_merge_blocks,\n\ttidy_fallthru_edge, rtl_split_edge, cfg_layout_delete_block,\n\tcfg_layout_merge_blocks, cfg_layout_split_edge): Partly moved to\n\tcfghooks.c.\n\t(rtl_create_basic_block): Coding style fix.\n\t(rtl_tidy_fallthru_edge, rtl_move_block_after,\n\trtl_make_forwarder_block): New functions.\n\t(update_cfg_after_block_merging): Removed.\n\t(rtl_cfg_hooks, cfg_layout_rtl_cfg_hooks): Fill in new entries.\n\t* flow.c (verify_wide_reg, verify_local_live_at_start): Add argument\n\tto dump_bb.\n\t* ifcvt.c (merge_if_block, find_cond_trap, find_if_case_1,\n\tfind_if_case_2): Don't update dominators.\n\t* timevar.def (TV_CFG_VERIFY): New.\n\t* loop-unswitch.c (unswitch_loop): Don't call add_to_dominance_info.\n\t* cfglayout.c (copy_bbs): Don't call add_to_dominance_info.\n\t* cfgloopmanip.c (split_loop_bb): Don't update dominators.\n\t(remove_bbs): Don't call remove_bbs.\n\t(create_preheader): Use make_forwarder_block.\n\t(mfb_keep_just, mfb_update_loops): New static functions.\n\nFrom-SVN: r76851", "tree": {"sha": "075d0d98ba746f488ac4ecf2ecf94a83992aacbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/075d0d98ba746f488ac4ecf2ecf94a83992aacbc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f470c378ac3e1ee9261034709851f4c6ef068fef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f470c378ac3e1ee9261034709851f4c6ef068fef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f470c378ac3e1ee9261034709851f4c6ef068fef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f470c378ac3e1ee9261034709851f4c6ef068fef/comments", "author": null, "committer": null, "parents": [{"sha": "3cea47884638a56ebe6a71d2ffd4a13e18a52598", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cea47884638a56ebe6a71d2ffd4a13e18a52598", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3cea47884638a56ebe6a71d2ffd4a13e18a52598"}], "stats": {"total": 1317, "additions": 824, "deletions": 493}, "files": [{"sha": "39e5a4b520208537833269efe86dcb334b4f7633", "filename": "gcc/ChangeLog", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f470c378ac3e1ee9261034709851f4c6ef068fef/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f470c378ac3e1ee9261034709851f4c6ef068fef/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f470c378ac3e1ee9261034709851f4c6ef068fef", "patch": "@@ -1,3 +1,66 @@\n+2004-01-29  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\t* Makefile.in (cfghooks.o): Add TIMEVAR_H and toplev.h dependency.\n+\t* basic-block.h (tidy_fallthru_edge, tidy_fallthru_edges, dump_bb,\n+\tverify_flow_info): Declaration removed.\n+\t* cfg.c (verify_flow_info, dump_bb): Moved to cfghooks.c.\n+\t(debug_bb, debug_bb_n): Add argument to dump_bb call.\n+\t* cfgcleanup.c (try_simplify_condjump, try_crossjump_to_edge,\n+\ttry_optimize_cfg, delete_unreachable_blocks): Use delete_basic_block\n+\tinstead of delete_block.\n+\t* cfghooks.c: Include timevar.h and toplev.h.\n+\t(cfg_hooks): Define here.\n+\t(verify_flow_info, dump_bb): Moved from cfg.c.\n+\t(redirect_edge_and_branch, redirect_edge_and_branch_force,\n+\tsplit_block, split_block_after_labels, move_block_after,\n+\tdelete_basic_block, split_edge, create_basic_block,\n+\tcreate_empty_bb, can_merge_blocks_p, merge_blocks,\n+\tmake_forwarder_block, tidy_fallthru_edge, tidy_fallthru_edges):\n+\tNew functions.\n+\t* cfghooks.h (struct cfg_hooks): Added fields name,\n+\tmake_forwarder_block, tidy_fallthru_edge and\n+\tmove_block_after. Changed type of verify_flow_info, dump_bb,\n+\tsplit_block fields. Renamed cfgh_split_edge and delete_block\n+\tfields.\n+\t(redirect_edge_and_branch, redirect_edge_and_branch_force,\n+\tsplit_block, delete_block, split_edge, create_basic_block,\n+\tcan_merge_blocks_p, merge_blocks): Macros removed.\n+\t(cfg_hooks): Do not export.\n+\t(verify_flow_info, dump_bb, redirect_edge_and_branch,\n+\tredirect_edge_and_branch_force, split_block, split_block_after_labels,\n+\tmove_block_after, delete_basic_block, split_edge, create_basic_block,\n+\tcreate_empty_bb, can_merge_blocks_p, merge_blocks,\n+\tmake_forwarder_block, tidy_fallthru_edge, tidy_fallthru_edges):\n+\tDeclare.\n+\t(cfg_layout_rtl_cfg_hooks): Declare.\n+\t* cfgloop.c (update_latch_info, mfb_keep_just, mfb_keep_nonlatch):\n+\tNew functions.\n+\t(canonicalize_loop_headers): Use new semantics of make_forwarder_block.\n+\t(redirect_edge_with_latch_update): Removed.\n+\t(make_forwarder_block): Moved to cfghooks.c, semantics changed.\n+\t* cfgloopmanip.c (remove_bbs): Do not update dominators here.\n+\t* cfgrtl.c (cfg_layout_split_block, rtl_split_block, rtl_dump_bb,\n+\trtl_delete_block, rtl_split_block, rtl_merge_blocks,\n+\ttidy_fallthru_edge, rtl_split_edge, cfg_layout_delete_block,\n+\tcfg_layout_merge_blocks, cfg_layout_split_edge): Partly moved to\n+\tcfghooks.c.\n+\t(rtl_create_basic_block): Coding style fix.\n+\t(rtl_tidy_fallthru_edge, rtl_move_block_after,\n+\trtl_make_forwarder_block): New functions.\n+\t(update_cfg_after_block_merging): Removed.\n+\t(rtl_cfg_hooks, cfg_layout_rtl_cfg_hooks): Fill in new entries.\n+\t* flow.c (verify_wide_reg, verify_local_live_at_start): Add argument\n+\tto dump_bb.\n+\t* ifcvt.c (merge_if_block, find_cond_trap, find_if_case_1,\n+\tfind_if_case_2): Don't update dominators.\n+\t* timevar.def (TV_CFG_VERIFY): New.\n+\t* loop-unswitch.c (unswitch_loop): Don't call add_to_dominance_info.\n+\t* cfglayout.c (copy_bbs): Don't call add_to_dominance_info.\n+\t* cfgloopmanip.c (split_loop_bb): Don't update dominators.\n+\t(remove_bbs): Don't call remove_bbs.\n+\t(create_preheader): Use make_forwarder_block.\n+\t(mfb_keep_just, mfb_update_loops): New static functions.\n+\n 2004-01-29  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/avr/avr.h: Remove target-independent comments about"}, {"sha": "946b4f75b18cd6969e5be536fa5950f291dd2d33", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f470c378ac3e1ee9261034709851f4c6ef068fef/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f470c378ac3e1ee9261034709851f4c6ef068fef/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=f470c378ac3e1ee9261034709851f4c6ef068fef", "patch": "@@ -1686,7 +1686,7 @@ cfg.o : cfg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) flags.h insn-\n    $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h $(RECOG_H) \\\n    function.h except.h $(GGC_H) $(TM_P_H) alloc-pool.h\n cfghooks.o: cfghooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n-   $(BASIC_BLOCK_H) cfglayout.h\n+   $(BASIC_BLOCK_H) cfglayout.h $(TIMEVAR_H) toplev.h\n cfgrtl.o : cfgrtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) flags.h \\\n    insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h $(RECOG_H) \\\n    function.h except.h $(GGC_H) $(TM_P_H) insn-config.h $(EXPR_H)"}, {"sha": "240edfd79dfd321b0b2e609251c39f6c433ab782", "filename": "gcc/basic-block.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f470c378ac3e1ee9261034709851f4c6ef068fef/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f470c378ac3e1ee9261034709851f4c6ef068fef/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=f470c378ac3e1ee9261034709851f4c6ef068fef", "patch": "@@ -363,8 +363,6 @@ extern edge redirect_edge_succ_nodup (edge, basic_block);\n extern void redirect_edge_pred (edge, basic_block);\n extern basic_block create_basic_block_structure (rtx, rtx, rtx, basic_block);\n extern void clear_bb_flags (void);\n-extern void tidy_fallthru_edge (edge, basic_block, basic_block);\n-extern void tidy_fallthru_edges (void);\n extern void flow_reverse_top_sort_order_compute (int *);\n extern int flow_depth_first_order_compute (int *, int *);\n extern void flow_preorder_transversal_compute (int *);\n@@ -537,7 +535,6 @@ extern bool probably_never_executed_bb_p (basic_block);\n \n /* In flow.c */\n extern void init_flow (void);\n-extern void dump_bb (basic_block, FILE *);\n extern void debug_bb (basic_block);\n extern basic_block debug_bb_n (int);\n extern void dump_regset (regset, FILE *);\n@@ -570,11 +567,6 @@ extern void alloc_aux_for_edges (int);\n extern void clear_aux_for_edges (void);\n extern void free_aux_for_edges (void);\n \n-/* This function is always defined so it can be called from the\n-   debugger, and it is declared extern so we don't get warnings about\n-   it being unused.  */\n-extern void verify_flow_info (void);\n-\n typedef struct conflict_graph_def *conflict_graph;\n \n /* Callback function when enumerating conflicts.  The arguments are"}, {"sha": "ff3f367913678045160983eb988011d67bb644d7", "filename": "gcc/cfg.c", "status": "modified", "additions": 2, "deletions": 171, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f470c378ac3e1ee9261034709851f4c6ef068fef/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f470c378ac3e1ee9261034709851f4c6ef068fef/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=f470c378ac3e1ee9261034709851f4c6ef068fef", "patch": "@@ -810,185 +810,16 @@ free_aux_for_edges (void)\n   clear_aux_for_edges ();\n }\n \n-/* Verify the CFG consistency.\n-\n-   Currently it does following checks edge and basic block list correctness\n-   and calls into IL dependent checking then.  */\n-void\n-verify_flow_info (void)\n-{\n-  size_t *edge_checksum;\n-  int num_bb_notes, err = 0;\n-  basic_block bb, last_bb_seen;\n-  basic_block *last_visited;\n-\n-  last_visited = xcalloc (last_basic_block + 2, sizeof (basic_block));\n-  edge_checksum = xcalloc (last_basic_block + 2, sizeof (size_t));\n-\n-  /* Check bb chain & numbers.  */\n-  last_bb_seen = ENTRY_BLOCK_PTR;\n-  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR->next_bb, NULL, next_bb)\n-    {\n-      if (bb != EXIT_BLOCK_PTR\n-\t  && bb != BASIC_BLOCK (bb->index))\n-\t{\n-\t  error (\"bb %d on wrong place\", bb->index);\n-\t  err = 1;\n-\t}\n-\n-      if (bb->prev_bb != last_bb_seen)\n-\t{\n-\t  error (\"prev_bb of %d should be %d, not %d\",\n-\t\t bb->index, last_bb_seen->index, bb->prev_bb->index);\n-\t  err = 1;\n-\t}\n-\n-      last_bb_seen = bb;\n-    }\n-\n-  /* Now check the basic blocks (boundaries etc.) */\n-  FOR_EACH_BB_REVERSE (bb)\n-    {\n-      int n_fallthru = 0;\n-      edge e;\n-\n-      if (bb->count < 0)\n-\t{\n-\t  error (\"verify_flow_info: Wrong count of block %i %i\",\n-\t         bb->index, (int)bb->count);\n-\t  err = 1;\n-\t}\n-      if (bb->frequency < 0)\n-\t{\n-\t  error (\"verify_flow_info: Wrong frequency of block %i %i\",\n-\t         bb->index, bb->frequency);\n-\t  err = 1;\n-\t}\n-      for (e = bb->succ; e; e = e->succ_next)\n-\t{\n-\t  if (last_visited [e->dest->index + 2] == bb)\n-\t    {\n-\t      error (\"verify_flow_info: Duplicate edge %i->%i\",\n-\t\t     e->src->index, e->dest->index);\n-\t      err = 1;\n-\t    }\n-\t  if (e->probability < 0 || e->probability > REG_BR_PROB_BASE)\n-\t    {\n-\t      error (\"verify_flow_info: Wrong probability of edge %i->%i %i\",\n-\t\t     e->src->index, e->dest->index, e->probability);\n-\t      err = 1;\n-\t    }\n-\t  if (e->count < 0)\n-\t    {\n-\t      error (\"verify_flow_info: Wrong count of edge %i->%i %i\",\n-\t\t     e->src->index, e->dest->index, (int)e->count);\n-\t      err = 1;\n-\t    }\n-\n-\t  last_visited [e->dest->index + 2] = bb;\n-\n-\t  if (e->flags & EDGE_FALLTHRU)\n-\t    n_fallthru++;\n-\n-\t  if (e->src != bb)\n-\t    {\n-\t      error (\"verify_flow_info: Basic block %d succ edge is corrupted\",\n-\t\t     bb->index);\n-\t      fprintf (stderr, \"Predecessor: \");\n-\t      dump_edge_info (stderr, e, 0);\n-\t      fprintf (stderr, \"\\nSuccessor: \");\n-\t      dump_edge_info (stderr, e, 1);\n-\t      fprintf (stderr, \"\\n\");\n-\t      err = 1;\n-\t    }\n-\n-\t  edge_checksum[e->dest->index + 2] += (size_t) e;\n-\t}\n-      if (n_fallthru > 1)\n-\t{\n-\t  error (\"Wrong amount of branch edges after unconditional jump %i\", bb->index);\n-\t  err = 1;\n-\t}\n-\n-      for (e = bb->pred; e; e = e->pred_next)\n-\t{\n-\t  if (e->dest != bb)\n-\t    {\n-\t      error (\"basic block %d pred edge is corrupted\", bb->index);\n-\t      fputs (\"Predecessor: \", stderr);\n-\t      dump_edge_info (stderr, e, 0);\n-\t      fputs (\"\\nSuccessor: \", stderr);\n-\t      dump_edge_info (stderr, e, 1);\n-\t      fputc ('\\n', stderr);\n-\t      err = 1;\n-\t    }\n-\t  edge_checksum[e->dest->index + 2] -= (size_t) e;\n-\t}\n-    }\n-\n-  /* Complete edge checksumming for ENTRY and EXIT.  */\n-  {\n-    edge e;\n-\n-    for (e = ENTRY_BLOCK_PTR->succ; e ; e = e->succ_next)\n-      edge_checksum[e->dest->index + 2] += (size_t) e;\n-\n-    for (e = EXIT_BLOCK_PTR->pred; e ; e = e->pred_next)\n-      edge_checksum[e->dest->index + 2] -= (size_t) e;\n-  }\n-\n-  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n-    if (edge_checksum[bb->index + 2])\n-      {\n-\terror (\"basic block %i edge lists are corrupted\", bb->index);\n-\terr = 1;\n-      }\n-\n-  num_bb_notes = 0;\n-  last_bb_seen = ENTRY_BLOCK_PTR;\n-\n-  /* Clean up.  */\n-  free (last_visited);\n-  free (edge_checksum);\n-  err |= cfg_hooks->cfgh_verify_flow_info ();\n-  if (err)\n-    internal_error (\"verify_flow_info failed\");\n-}\n-\n-/* Print out one basic block with live information at start and end.  */\n-\n-void\n-dump_bb (basic_block bb, FILE *outf)\n-{\n-  edge e;\n-\n-  fprintf (outf, \";; Basic block %d, loop depth %d, count \",\n-\t   bb->index, bb->loop_depth);\n-  fprintf (outf, HOST_WIDEST_INT_PRINT_DEC, (HOST_WIDEST_INT) bb->count);\n-  putc ('\\n', outf);\n-  fputs (\";; Predecessors: \", outf);\n-  for (e = bb->pred; e; e = e->pred_next)\n-    dump_edge_info (outf, e, 0);\n-  putc ('\\n', outf);\n-\n-  cfg_hooks->dump_bb (bb, outf);\n-\n-  fputs (\";; Successors: \", outf);\n-  for (e = bb->succ; e; e = e->succ_next)\n-    dump_edge_info (outf, e, 1);\n-  putc ('\\n', outf);\n-}\n-\n void\n debug_bb (basic_block bb)\n {\n-  dump_bb (bb, stderr);\n+  dump_bb (bb, stderr, 0);\n }\n \n basic_block\n debug_bb_n (int n)\n {\n   basic_block bb = BASIC_BLOCK (n);\n-  dump_bb (bb, stderr);\n+  dump_bb (bb, stderr, 0);\n   return bb;\n }"}, {"sha": "a886e832bb5bb71f33d357a1c85c17adbb423833", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f470c378ac3e1ee9261034709851f4c6ef068fef/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f470c378ac3e1ee9261034709851f4c6ef068fef/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=f470c378ac3e1ee9261034709851f4c6ef068fef", "patch": "@@ -194,8 +194,8 @@ try_simplify_condjump (basic_block cbranch_block)\n \t}\n     }\n   /* Delete the block with the unconditional jump, and clean up the mess.  */\n-  delete_block (jump_block);\n-  tidy_fallthru_edge (cbranch_jump_edge, cbranch_block, cbranch_dest_block);\n+  delete_basic_block (jump_block);\n+  tidy_fallthru_edge (cbranch_jump_edge);\n \n   return true;\n }\n@@ -1530,7 +1530,7 @@ try_crossjump_to_edge (int mode, edge e1, edge e2)\n   to_remove = redirect_from->succ->dest;\n \n   redirect_edge_and_branch_force (redirect_from->succ, redirect_to);\n-  delete_block (to_remove);\n+  delete_basic_block (to_remove);\n \n   update_forwarder_flag (redirect_from);\n \n@@ -1694,7 +1694,7 @@ try_optimize_cfg (int mode)\n \t\t    fprintf (rtl_dump_file, \"Deleting block %i.\\n\",\n \t\t\t     b->index);\n \n-\t\t  delete_block (b);\n+\t\t  delete_basic_block (b);\n \t\t  if (!(mode & CLEANUP_CFGLAYOUT))\n \t\t    changed = true;\n \t\t  b = c;\n@@ -1755,7 +1755,7 @@ try_optimize_cfg (int mode)\n \n \t\t  c = b->prev_bb == ENTRY_BLOCK_PTR ? b->next_bb : b->prev_bb;\n \t\t  redirect_edge_succ_nodup (b->pred, b->succ->dest);\n-\t\t  delete_block (b);\n+\t\t  delete_basic_block (b);\n \t\t  changed = true;\n \t\t  b = c;\n \t\t}\n@@ -1873,7 +1873,7 @@ delete_unreachable_blocks (void)\n \n       if (!(b->flags & BB_REACHABLE))\n \t{\n-\t  delete_block (b);\n+\t  delete_basic_block (b);\n \t  changed = true;\n \t}\n     }"}, {"sha": "fd361c5fc85d65ce9fae611a29e8b247678d77a7", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 532, "deletions": 4, "changes": 536, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f470c378ac3e1ee9261034709851f4c6ef068fef/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f470c378ac3e1ee9261034709851f4c6ef068fef/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=f470c378ac3e1ee9261034709851f4c6ef068fef", "patch": "@@ -26,12 +26,11 @@ Boston, MA 02111-1307, USA.  */\n #include \"tree.h\"\n #include \"rtl.h\"\n #include \"basic-block.h\"\n-\n-extern struct cfg_hooks rtl_cfg_hooks;\n-extern struct cfg_hooks cfg_layout_rtl_cfg_hooks;\n+#include \"timevar.h\"\n+#include \"toplev.h\"\n \n /* A pointer to one of the hooks containers.  */\n-struct cfg_hooks *cfg_hooks;\n+static struct cfg_hooks *cfg_hooks;\n \n /* Initialization of functions specific to the rtl IR.  */\n void\n@@ -46,3 +45,532 @@ cfg_layout_rtl_register_cfg_hooks (void)\n {\n   cfg_hooks = &cfg_layout_rtl_cfg_hooks;\n }\n+\n+/* Verify the CFG consistency.\n+\n+   Currently it does following: checks edge and basic block list correctness\n+   and calls into IL dependent checking then.  */\n+\n+void\n+verify_flow_info (void)\n+{\n+  size_t *edge_checksum;\n+  int num_bb_notes, err = 0;\n+  basic_block bb, last_bb_seen;\n+  basic_block *last_visited;\n+\n+  timevar_push (TV_CFG_VERIFY);\n+  last_visited = xcalloc (last_basic_block + 2, sizeof (basic_block));\n+  edge_checksum = xcalloc (last_basic_block + 2, sizeof (size_t));\n+\n+  /* Check bb chain & numbers.  */\n+  last_bb_seen = ENTRY_BLOCK_PTR;\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR->next_bb, NULL, next_bb)\n+    {\n+      if (bb != EXIT_BLOCK_PTR\n+\t  && bb != BASIC_BLOCK (bb->index))\n+\t{\n+\t  error (\"bb %d on wrong place\", bb->index);\n+\t  err = 1;\n+\t}\n+\n+      if (bb->prev_bb != last_bb_seen)\n+\t{\n+\t  error (\"prev_bb of %d should be %d, not %d\",\n+\t\t bb->index, last_bb_seen->index, bb->prev_bb->index);\n+\t  err = 1;\n+\t}\n+\n+      last_bb_seen = bb;\n+    }\n+\n+  /* Now check the basic blocks (boundaries etc.) */\n+  FOR_EACH_BB_REVERSE (bb)\n+    {\n+      int n_fallthru = 0;\n+      edge e;\n+\n+      if (bb->count < 0)\n+\t{\n+\t  error (\"verify_flow_info: Wrong count of block %i %i\",\n+\t         bb->index, (int)bb->count);\n+\t  err = 1;\n+\t}\n+      if (bb->frequency < 0)\n+\t{\n+\t  error (\"verify_flow_info: Wrong frequency of block %i %i\",\n+\t         bb->index, bb->frequency);\n+\t  err = 1;\n+\t}\n+      for (e = bb->succ; e; e = e->succ_next)\n+\t{\n+\t  if (last_visited [e->dest->index + 2] == bb)\n+\t    {\n+\t      error (\"verify_flow_info: Duplicate edge %i->%i\",\n+\t\t     e->src->index, e->dest->index);\n+\t      err = 1;\n+\t    }\n+\t  if (e->probability < 0 || e->probability > REG_BR_PROB_BASE)\n+\t    {\n+\t      error (\"verify_flow_info: Wrong probability of edge %i->%i %i\",\n+\t\t     e->src->index, e->dest->index, e->probability);\n+\t      err = 1;\n+\t    }\n+\t  if (e->count < 0)\n+\t    {\n+\t      error (\"verify_flow_info: Wrong count of edge %i->%i %i\",\n+\t\t     e->src->index, e->dest->index, (int)e->count);\n+\t      err = 1;\n+\t    }\n+\n+\t  last_visited [e->dest->index + 2] = bb;\n+\n+\t  if (e->flags & EDGE_FALLTHRU)\n+\t    n_fallthru++;\n+\n+\t  if (e->src != bb)\n+\t    {\n+\t      error (\"verify_flow_info: Basic block %d succ edge is corrupted\",\n+\t\t     bb->index);\n+\t      fprintf (stderr, \"Predecessor: \");\n+\t      dump_edge_info (stderr, e, 0);\n+\t      fprintf (stderr, \"\\nSuccessor: \");\n+\t      dump_edge_info (stderr, e, 1);\n+\t      fprintf (stderr, \"\\n\");\n+\t      err = 1;\n+\t    }\n+\n+\t  edge_checksum[e->dest->index + 2] += (size_t) e;\n+\t}\n+      if (n_fallthru > 1)\n+\t{\n+\t  error (\"Wrong amount of branch edges after unconditional jump %i\", bb->index);\n+\t  err = 1;\n+\t}\n+\n+      for (e = bb->pred; e; e = e->pred_next)\n+\t{\n+\t  if (e->dest != bb)\n+\t    {\n+\t      error (\"basic block %d pred edge is corrupted\", bb->index);\n+\t      fputs (\"Predecessor: \", stderr);\n+\t      dump_edge_info (stderr, e, 0);\n+\t      fputs (\"\\nSuccessor: \", stderr);\n+\t      dump_edge_info (stderr, e, 1);\n+\t      fputc ('\\n', stderr);\n+\t      err = 1;\n+\t    }\n+\t  edge_checksum[e->dest->index + 2] -= (size_t) e;\n+\t}\n+    }\n+\n+  /* Complete edge checksumming for ENTRY and EXIT.  */\n+  {\n+    edge e;\n+\n+    for (e = ENTRY_BLOCK_PTR->succ; e ; e = e->succ_next)\n+      edge_checksum[e->dest->index + 2] += (size_t) e;\n+\n+    for (e = EXIT_BLOCK_PTR->pred; e ; e = e->pred_next)\n+      edge_checksum[e->dest->index + 2] -= (size_t) e;\n+  }\n+\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n+    if (edge_checksum[bb->index + 2])\n+      {\n+\terror (\"basic block %i edge lists are corrupted\", bb->index);\n+\terr = 1;\n+      }\n+\n+  num_bb_notes = 0;\n+  last_bb_seen = ENTRY_BLOCK_PTR;\n+\n+  /* Clean up.  */\n+  free (last_visited);\n+  free (edge_checksum);\n+\n+  if (cfg_hooks->verify_flow_info)\n+    err |= cfg_hooks->verify_flow_info ();\n+  if (err)\n+    internal_error (\"verify_flow_info failed\");\n+  timevar_pop (TV_CFG_VERIFY);\n+}\n+\n+/* Print out one basic block.  This function takes care of the purely\n+   graph related information.  The cfg hook for the active representation\n+   should dump representation-specific information.  */\n+\n+void\n+dump_bb (basic_block bb, FILE *outf, int indent)\n+{\n+  edge e;\n+  char *s_indent;\n+ \n+  s_indent = (char *) alloca ((size_t) indent + 1);\n+  memset ((void *) s_indent, ' ', (size_t) indent);\n+  s_indent[indent] = '\\0';\n+\n+  fprintf (outf, \";;%s basic block %d, loop depth %d, count \",\n+\t   s_indent, bb->index, bb->loop_depth);\n+  fprintf (outf, HOST_WIDEST_INT_PRINT_DEC, (HOST_WIDEST_INT) bb->count);\n+  putc ('\\n', outf);\n+\n+  fprintf (outf, \";;%s prev block \", s_indent);\n+  if (bb->prev_bb)\n+    fprintf (outf, \"%d, \", bb->prev_bb->index);\n+  else\n+    fprintf (outf, \"(nil), \");\n+  fprintf (outf, \"next block \");\n+  if (bb->next_bb)\n+    fprintf (outf, \"%d\", bb->next_bb->index);\n+  else\n+    fprintf (outf, \"(nil)\");\n+  putc ('\\n', outf);\n+\n+  fprintf (outf, \";;%s pred:      \", s_indent);\n+  for (e = bb->pred; e; e = e->pred_next)\n+    dump_edge_info (outf, e, 0);\n+  putc ('\\n', outf);\n+\n+  fprintf (outf, \";;%s succ:      \", s_indent);\n+  for (e = bb->succ; e; e = e->succ_next)\n+    dump_edge_info (outf, e, 1);\n+  putc ('\\n', outf);\n+\n+  if (cfg_hooks->dump_bb)\n+    cfg_hooks->dump_bb (bb, outf, indent);\n+}\n+\n+/* Redirect edge E to the given basic block DEST and update underlying program\n+   representation.  Returns edge representing redirected branch (that may not\n+   be equivalent to E in the case of duplicate edges being removed) or NULL\n+   if edge is not easily redirectable for whatever reason.  */\n+\n+bool\n+redirect_edge_and_branch (edge e, basic_block dest)\n+{\n+  bool ret;\n+\n+  if (!cfg_hooks->redirect_edge_and_branch)\n+    internal_error (\"%s does not support redirect_edge_and_branch.\",\n+\t\t    cfg_hooks->name);\n+\n+  ret = cfg_hooks->redirect_edge_and_branch (e, dest);\n+\n+  return ret;\n+}\n+\n+/* Redirect the edge E to basic block DEST even if it requires creating\n+   of a new basic block; then it returns the newly created basic block.\n+   Aborts when redirection is impossible.  */\n+\n+basic_block\n+redirect_edge_and_branch_force (edge e, basic_block dest)\n+{\n+  basic_block ret;\n+\n+  if (!cfg_hooks->redirect_edge_and_branch_force)\n+    internal_error (\"%s does not support redirect_edge_and_branch_force.\",\n+\t\t    cfg_hooks->name);\n+\n+  ret = cfg_hooks->redirect_edge_and_branch_force (e, dest);\n+\n+  return ret;\n+}\n+\n+/* Splits basic block BB after the specified instruction I (but at least after\n+   the labels).  If I is NULL, splits just after labels.  The newly created edge\n+   is returned.  The new basic block is created just after the old one.  */\n+\n+edge\n+split_block (basic_block bb, void *i)\n+{\n+  basic_block new_bb;\n+\n+  if (!cfg_hooks->split_block)\n+    internal_error (\"%s does not support split_block.\", cfg_hooks->name);\n+\n+  new_bb = cfg_hooks->split_block (bb, i);\n+  if (!new_bb)\n+    return NULL;\n+\n+  new_bb->count = bb->count;\n+  new_bb->frequency = bb->frequency;\n+  new_bb->loop_depth = bb->loop_depth;\n+\n+  if (dom_computed[CDI_DOMINATORS] >= DOM_CONS_OK)\n+    {\n+      redirect_immediate_dominators (CDI_DOMINATORS, bb, new_bb);\n+      set_immediate_dominator (CDI_DOMINATORS, new_bb, bb);\n+    }\n+\n+  return make_edge (bb, new_bb, EDGE_FALLTHRU);\n+}\n+\n+/* Splits block BB just after labels.  The newly created edge is returned.  */\n+\n+edge\n+split_block_after_labels (basic_block bb)\n+{\n+  return split_block (bb, NULL);\n+}\n+\n+/* Moves block BB immediatelly after block AFTER.  Returns false if the\n+   movement was impossible.  */\n+\n+bool\n+move_block_after (basic_block bb, basic_block after)\n+{\n+  bool ret;\n+\n+  if (!cfg_hooks->move_block_after)\n+    internal_error (\"%s does not support move_block_after.\", cfg_hooks->name);\n+\n+  ret = cfg_hooks->move_block_after (bb, after);\n+\n+  return ret;\n+}\n+\n+/* Deletes the basic block BB.  */\n+\n+void\n+delete_basic_block (basic_block bb)\n+{\n+  if (!cfg_hooks->delete_basic_block)\n+    internal_error (\"%s does not support delete_basic_block.\", cfg_hooks->name);\n+\n+  cfg_hooks->delete_basic_block (bb);\n+\n+  /* Remove the edges into and out of this block.  Note that there may\n+     indeed be edges in, if we are removing an unreachable loop.  */\n+  while (bb->pred != NULL)\n+    remove_edge (bb->pred);\n+  while (bb->succ != NULL)\n+    remove_edge (bb->succ);\n+\n+  bb->pred = NULL;\n+  bb->succ = NULL;\n+\n+  if (dom_computed[CDI_DOMINATORS])\n+    delete_from_dominance_info (CDI_DOMINATORS, bb);\n+  if (dom_computed[CDI_POST_DOMINATORS])\n+    delete_from_dominance_info (CDI_POST_DOMINATORS, bb);\n+\n+  /* Remove the basic block from the array.  */\n+  expunge_block (bb);\n+}\n+\n+/* Splits edge E and returns the newly created basic block.  */\n+\n+basic_block\n+split_edge (edge e)\n+{\n+  basic_block ret;\n+  gcov_type count = e->count;\n+  int freq = EDGE_FREQUENCY (e);\n+\n+  if (!cfg_hooks->split_edge)\n+    internal_error (\"%s does not support split_edge.\", cfg_hooks->name);\n+\n+  ret = cfg_hooks->split_edge (e);\n+  ret->count = count;\n+  ret->frequency = freq;\n+  ret->succ->probability = REG_BR_PROB_BASE;\n+  ret->succ->count = count;\n+\n+  if (dom_computed[CDI_DOMINATORS])\n+    set_immediate_dominator (CDI_DOMINATORS, ret, ret->pred->src);\n+\n+  if (dom_computed[CDI_DOMINATORS] >= DOM_NO_FAST_QUERY)\n+    set_immediate_dominator (CDI_DOMINATORS, ret->succ->dest,\n+\t\t\t     recount_dominator (CDI_DOMINATORS,\n+\t\t\t\t\t\tret->succ->dest));\n+\n+  return ret;\n+}\n+\n+/* Creates a new basic block just after the basic block AFTER.\n+   HEAD and END are the first and the last statement belonging\n+   to the block.  If both are NULL, an empty block is created.  */\n+\n+basic_block\n+create_basic_block (void *head, void *end, basic_block after)\n+{\n+  basic_block ret;\n+\n+  if (!cfg_hooks->create_basic_block)\n+    internal_error (\"%s does not support create_basic_block.\", cfg_hooks->name);\n+\n+  ret = cfg_hooks->create_basic_block (head, end, after);\n+\n+  if (dom_computed[CDI_DOMINATORS])\n+    add_to_dominance_info (CDI_DOMINATORS, ret);\n+  if (dom_computed[CDI_POST_DOMINATORS])\n+    add_to_dominance_info (CDI_POST_DOMINATORS, ret);\n+\n+  return ret;\n+}\n+\n+/* Creates an empty basic block just after basic block AFTER.  */\n+\n+basic_block\n+create_empty_bb (basic_block after)\n+{\n+  return create_basic_block (NULL, NULL, after);\n+}\n+\n+/* Checks whether we may merge blocks BB1 and BB2.  */\n+\n+bool\n+can_merge_blocks_p (basic_block bb1, basic_block bb2)\n+{\n+  bool ret;\n+\n+  if (!cfg_hooks->can_merge_blocks_p)\n+    internal_error (\"%s does not support can_merge_blocks_p.\", cfg_hooks->name);\n+\n+  ret = cfg_hooks->can_merge_blocks_p (bb1, bb2);\n+\n+  return ret;\n+}\n+\n+/* Merges basic block B into basic block A.  */\n+\n+void\n+merge_blocks (basic_block a, basic_block b)\n+{\n+  edge e;\n+\n+  if (!cfg_hooks->merge_blocks)\n+    internal_error (\"%s does not support merge_blocks.\", cfg_hooks->name);\n+\n+  cfg_hooks->merge_blocks (a, b);\n+\n+  /* Normally there should only be one successor of A and that is B, but\n+     partway though the merge of blocks for conditional_execution we'll\n+     be merging a TEST block with THEN and ELSE successors.  Free the\n+     whole lot of them and hope the caller knows what they're doing.  */\n+  while (a->succ)\n+    remove_edge (a->succ);\n+\n+  /* Adjust the edges out of B for the new owner.  */\n+  for (e = b->succ; e; e = e->succ_next)\n+    e->src = a;\n+  a->succ = b->succ;\n+  a->flags |= b->flags;\n+\n+  /* B hasn't quite yet ceased to exist.  Attempt to prevent mishap.  */\n+  b->pred = b->succ = NULL;\n+  a->global_live_at_end = b->global_live_at_end;\n+\n+  if (dom_computed[CDI_DOMINATORS])\n+    redirect_immediate_dominators (CDI_DOMINATORS, b, a);\n+\n+  if (dom_computed[CDI_DOMINATORS])\n+    delete_from_dominance_info (CDI_DOMINATORS, b);\n+  if (dom_computed[CDI_POST_DOMINATORS])\n+    delete_from_dominance_info (CDI_POST_DOMINATORS, b);\n+\n+  expunge_block (b);\n+}\n+\n+/* Split BB into entry part and the rest (the rest is the newly created block).\n+   Redirect those edges for that REDIRECT_EDGE_P returns true to the entry\n+   part.  Returns the edge connecting the entry part to the rest.  */\n+\n+edge\n+make_forwarder_block (basic_block bb, bool (*redirect_edge_p) (edge),\n+\t\t      void (*new_bb_cbk) (basic_block))\n+{\n+  edge e, next_e, fallthru;\n+  basic_block dummy, jump;\n+\n+  if (!cfg_hooks->make_forwarder_block)\n+    internal_error (\"%s does not support make_forwarder_block.\",\n+\t\t    cfg_hooks->name);\n+\n+  fallthru = split_block_after_labels (bb);\n+  dummy = fallthru->src;\n+  bb = fallthru->dest;\n+\n+  /* Redirect back edges we want to keep.  */\n+  for (e = dummy->pred; e; e = next_e)\n+    {\n+      next_e = e->pred_next;\n+      if (redirect_edge_p (e))\n+\tcontinue;\n+\n+      dummy->frequency -= EDGE_FREQUENCY (e);\n+      dummy->count -= e->count;\n+      if (dummy->frequency < 0)\n+\tdummy->frequency = 0;\n+      if (dummy->count < 0)\n+\tdummy->count = 0;\n+\n+      jump = redirect_edge_and_branch_force (e, bb);\n+      if (jump)\n+\tnew_bb_cbk (jump);\n+    }\n+\n+  if (dom_computed[CDI_DOMINATORS] >= DOM_CONS_OK)\n+    {\n+      basic_block doms_to_fix[2];\n+\n+      doms_to_fix[0] = dummy;\n+      doms_to_fix[1] = bb;\n+      iterate_fix_dominators (CDI_DOMINATORS, doms_to_fix, 2);\n+    }\n+\n+  cfg_hooks->make_forwarder_block (fallthru);\n+\n+  return fallthru;\n+}\n+\n+void\n+tidy_fallthru_edge (edge e)\n+{\n+  if (cfg_hooks->tidy_fallthru_edge)\n+    cfg_hooks->tidy_fallthru_edge (e);\n+}\n+\n+/* Fix up edges that now fall through, or rather should now fall through\n+   but previously required a jump around now deleted blocks.  Simplify\n+   the search by only examining blocks numerically adjacent, since this\n+   is how find_basic_blocks created them.  */\n+\n+void\n+tidy_fallthru_edges (void)\n+{\n+  basic_block b, c;\n+\n+  if (!cfg_hooks->tidy_fallthru_edge)\n+    return;\n+\n+  if (ENTRY_BLOCK_PTR->next_bb == EXIT_BLOCK_PTR)\n+    return;\n+\n+  FOR_BB_BETWEEN (b, ENTRY_BLOCK_PTR->next_bb, EXIT_BLOCK_PTR->prev_bb, next_bb)\n+    {\n+      edge s;\n+\n+      c = b->next_bb;\n+\n+      /* We care about simple conditional or unconditional jumps with\n+\t a single successor.\n+\n+\t If we had a conditional branch to the next instruction when\n+\t find_basic_blocks was called, then there will only be one\n+\t out edge for the block which ended with the conditional\n+\t branch (since we do not create duplicate edges).\n+\n+\t Furthermore, the edge will be marked as a fallthru because we\n+\t merge the flags for the duplicate edges.  So we do not want to\n+\t check that the edge is not a FALLTHRU edge.  */\n+\n+      if ((s = b->succ) != NULL\n+\t  && ! (s->flags & EDGE_COMPLEX)\n+\t  && s->succ_next == NULL\n+\t  && s->dest == c)\n+\ttidy_fallthru_edge (s);\n+    }\n+}"}, {"sha": "4c2d0bf37bb1f1b564d57bd53fc72635f962802e", "filename": "gcc/cfghooks.h", "status": "modified", "additions": 37, "deletions": 20, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f470c378ac3e1ee9261034709851f4c6ef068fef/gcc%2Fcfghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f470c378ac3e1ee9261034709851f4c6ef068fef/gcc%2Fcfghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.h?ref=f470c378ac3e1ee9261034709851f4c6ef068fef", "patch": "@@ -24,10 +24,12 @@ Boston, MA 02111-1307, USA.  */\n \n struct cfg_hooks\n {\n-  /* Debugging.  Do not use macros to hook these so they can be called from\n-     debugger!  */\n-  int (*cfgh_verify_flow_info) (void);\n-  void (*dump_bb) (basic_block, FILE *);\n+  /* Name of the corresponding ir.  */\n+  const char *name;\n+\n+  /* Debugging.  */\n+  int (*verify_flow_info) (void);\n+  void (*dump_bb) (basic_block, FILE *, int);\n \n   /* Basic CFG manipulation.  */\n \n@@ -44,11 +46,15 @@ struct cfg_hooks\n      on abnormal edge.  */\n   basic_block (*redirect_edge_and_branch_force) (edge, basic_block);\n \n-  /* Remove given basic block and all edges possibly pointing into it.  */\n-  void (*delete_block) (basic_block);\n+  /* Remove statements corresponding to a given basic block.  */\n+  void (*delete_basic_block) (basic_block);\n+\n+  /* Creates a new basic block just after basic block B by splitting\n+     everything after specified instruction I.  */\n+  basic_block (*split_block) (basic_block b, void * i);\n \n-  /* Split basic block B after specified instruction I.  */\n-  edge (*split_block) (basic_block b, void * i);\n+  /* Move block B immediately after block A.  */\n+  bool (*move_block_after) (basic_block b, basic_block a);\n \n   /* Return true when blocks A and B can be merged into single basic block.  */\n   bool (*can_merge_blocks_p) (basic_block a, basic_block b);\n@@ -58,23 +64,34 @@ struct cfg_hooks\n \n   /* Higher level functions representable by primitive operations above if\n      we didn't have some oddities in RTL and Tree representations.  */\n-  basic_block (*cfgh_split_edge) (edge);\n+  basic_block (*split_edge) (edge);\n+  void (*make_forwarder_block) (edge);\n+\n+  /* Tries to make the edge fallthru.  */\n+  void (*tidy_fallthru_edge) (edge);\n };\n \n-#define redirect_edge_and_branch(e,b)        cfg_hooks->redirect_edge_and_branch (e,b)\n-#define redirect_edge_and_branch_force(e,b)  cfg_hooks->redirect_edge_and_branch_force (e,b)\n-#define split_block(e,i)                     cfg_hooks->split_block (e,i)\n-#define delete_block(b)\t\t\t     cfg_hooks->delete_block (b)\n-#define split_edge(e)                        cfg_hooks->cfgh_split_edge (e)\n-#define create_basic_block(h,e,a)            cfg_hooks->create_basic_block (h,e,a)\n-#define can_merge_blocks_p(a,b)\t\t     cfg_hooks->can_merge_blocks_p (a,b)\n-#define merge_blocks(a,b)\t\t     cfg_hooks->merge_blocks (a,b)\n+extern void verify_flow_info (void);\n+extern void dump_bb (basic_block, FILE *, int);\n+extern bool redirect_edge_and_branch (edge, basic_block);\n+extern basic_block redirect_edge_and_branch_force (edge, basic_block);\n+extern edge split_block (basic_block, void *);\n+extern edge split_block_after_labels (basic_block);\n+extern bool move_block_after (basic_block, basic_block);\n+extern void delete_basic_block (basic_block);\n+extern basic_block split_edge (edge);\n+extern basic_block create_basic_block (void *, void *, basic_block);\n+extern basic_block create_empty_bb (basic_block);\n+extern bool can_merge_blocks_p (basic_block, basic_block);\n+extern void merge_blocks (basic_block, basic_block);\n+extern edge make_forwarder_block (basic_block, bool (*)(edge),\n+\t\t\t\t  void (*) (basic_block));\n+extern void tidy_fallthru_edge (edge);\n+extern void tidy_fallthru_edges (void);\n \n /* Hooks containers.  */\n extern struct cfg_hooks rtl_cfg_hooks;\n-\n-/* A pointer to one of the hooks containers.  */\n-extern struct cfg_hooks *cfg_hooks;\n+extern struct cfg_hooks cfg_layout_rtl_cfg_hooks;\n \n /* Declarations.  */\n extern void rtl_register_cfg_hooks (void);"}, {"sha": "bdee86757684d8232377b47c83c42581593d5d5e", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f470c378ac3e1ee9261034709851f4c6ef068fef/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f470c378ac3e1ee9261034709851f4c6ef068fef/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=f470c378ac3e1ee9261034709851f4c6ef068fef", "patch": "@@ -1268,7 +1268,6 @@ copy_bbs (basic_block *bbs, unsigned n, basic_block *new_bbs,\n       bb->rbi->duplicated = 1;\n       /* Add to loop.  */\n       add_bb_to_loop (new_bb, bb->loop_father->copy);\n-      add_to_dominance_info (CDI_DOMINATORS, new_bb);\n       /* Possibly set header.  */\n       if (bb->loop_father->header == bb && bb->loop_father != base)\n \tnew_bb->loop_father->header = new_bb;"}, {"sha": "6fa8b17706ae6a7e40d69c6d6b23a9b05cfb122d", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 49, "deletions": 79, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f470c378ac3e1ee9261034709851f4c6ef068fef/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f470c378ac3e1ee9261034709851f4c6ef068fef/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=f470c378ac3e1ee9261034709851f4c6ef068fef", "patch": "@@ -33,6 +33,9 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    considered to belong to inner loop with same header.  */\n #define HEAVY_EDGE_RATIO 8\n \n+#define HEADER_BLOCK(B) (* (int *) (B)->aux)\n+#define LATCH_EDGE(E) (*(int *) (E)->aux)\n+\n static void flow_loops_cfg_dump (const struct loops *, FILE *);\n static void flow_loop_entry_edges_find (struct loop *);\n static void flow_loop_exit_edges_find (struct loop *);\n@@ -42,10 +45,8 @@ static basic_block flow_loop_pre_header_find (basic_block);\n static int flow_loop_level_compute (struct loop *);\n static int flow_loops_level_compute (struct loops *);\n static void establish_preds (struct loop *);\n-static basic_block make_forwarder_block (basic_block, int, int, edge, int);\n static void canonicalize_loop_headers (void);\n static bool glb_enum_p (basic_block, void *);\n-static void redirect_edge_with_latch_update (edge, basic_block);\n \f\n /* Dump loop related CFG information.  */\n \n@@ -547,78 +548,41 @@ flow_loop_scan (struct loop *loop, int flags)\n   return 1;\n }\n \n-#define HEADER_BLOCK(B) (* (int *) (B)->aux)\n-#define LATCH_EDGE(E) (*(int *) (E)->aux)\n+/* A callback to update latch and header info for basic block JUMP created\n+   by redirecting an edge.  */\n \n-/* Redirect edge and update latch and header info.  */\n static void\n-redirect_edge_with_latch_update (edge e, basic_block to)\n+update_latch_info (basic_block jump)\n {\n-  basic_block jump;\n-\n-  jump = redirect_edge_and_branch_force (e, to);\n-  if (jump)\n-    {\n-      alloc_aux_for_block (jump, sizeof (int));\n-      HEADER_BLOCK (jump) = 0;\n-      alloc_aux_for_edge (jump->pred, sizeof (int));\n-      LATCH_EDGE (jump->succ) = LATCH_EDGE (e);\n-      LATCH_EDGE (jump->pred) = 0;\n-    }\n+  alloc_aux_for_block (jump, sizeof (int));\n+  HEADER_BLOCK (jump) = 0;\n+  alloc_aux_for_edge (jump->pred, sizeof (int));\n+  LATCH_EDGE (jump->pred) = 0;\n }\n \n-/* Split BB into entry part and rest; if REDIRECT_LATCH, redirect edges\n-   marked as latch into entry part, analogically for REDIRECT_NONLATCH.\n-   In both of these cases, ignore edge EXCEPT.  If CONN_LATCH, set edge\n-   between created entry part and BB as latch one.  Return created entry\n-   part.  */\n+/* A callback for make_forwarder block, to redirect all edges except for\n+   MFB_KJ_EDGE to the entry part.  E is the edge for that we should decide\n+   whether to redirect it.  */\n \n-static basic_block\n-make_forwarder_block (basic_block bb, int redirect_latch, int redirect_nonlatch, edge except, int conn_latch)\n+static edge mfb_kj_edge;\n+static bool\n+mfb_keep_just (edge e)\n {\n-  edge e, next_e, fallthru;\n-  basic_block dummy;\n-  rtx insn;\n-\n-  insn = PREV_INSN (first_insn_after_basic_block_note (bb));\n-\n-  /* For empty block split_block will return NULL.  */\n-  if (BB_END (bb) == insn)\n-    emit_note_after (NOTE_INSN_DELETED, insn);\n-\n-  fallthru = split_block (bb, insn);\n-  dummy = fallthru->src;\n-  bb = fallthru->dest;\n-\n-  bb->aux = xmalloc (sizeof (int));\n-  HEADER_BLOCK (dummy) = 0;\n-  HEADER_BLOCK (bb) = 1;\n-\n-  /* Redirect back edges we want to keep.  */\n-  for (e = dummy->pred; e; e = next_e)\n-    {\n-      next_e = e->pred_next;\n-      if (e == except\n-\t  || !((redirect_latch && LATCH_EDGE (e))\n-\t       || (redirect_nonlatch && !LATCH_EDGE (e))))\n-\t{\n-\t  dummy->frequency -= EDGE_FREQUENCY (e);\n-\t  dummy->count -= e->count;\n-\t  if (dummy->frequency < 0)\n-\t    dummy->frequency = 0;\n-\t  if (dummy->count < 0)\n-\t    dummy->count = 0;\n-\t  redirect_edge_with_latch_update (e, bb);\n-\t}\n-    }\n+  return e != mfb_kj_edge;\n+}\n \n-  alloc_aux_for_edge (fallthru, sizeof (int));\n-  LATCH_EDGE (fallthru) = conn_latch;\n+/* A callback for make_forwarder block, to redirect the latch edges into an\n+   entry part.  E is the edge for that we should decide whether to redirect\n+   it.  */\n \n-  return dummy;\n+static bool\n+mfb_keep_nonlatch (edge e)\n+{\n+  return LATCH_EDGE (e);\n }\n \n /* Takes care of merging natural loops with shared headers.  */\n+\n static void\n canonicalize_loop_headers (void)\n {\n@@ -675,19 +639,10 @@ canonicalize_loop_headers (void)\n \n   FOR_EACH_BB (header)\n     {\n-      int num_latch;\n-      int want_join_latch;\n       int max_freq, is_heavy;\n-      edge heavy;\n+      edge heavy, tmp_edge;\n \n-      if (!HEADER_BLOCK (header))\n-\tcontinue;\n-\n-      num_latch = HEADER_BLOCK (header);\n-\n-      want_join_latch = (num_latch > 1);\n-\n-      if (!want_join_latch)\n+      if (HEADER_BLOCK (header) <= 1)\n \tcontinue;\n \n       /* Find a heavy edge.  */\n@@ -713,13 +668,28 @@ canonicalize_loop_headers (void)\n \n       if (is_heavy)\n \t{\n-\t  basic_block new_header =\n-\t    make_forwarder_block (header, true, true, heavy, 0);\n-\t  if (num_latch > 2)\n-\t    make_forwarder_block (new_header, true, false, NULL, 1);\n+\t  /* Split out the heavy edge, and create inner loop for it.  */\n+\t  mfb_kj_edge = heavy;\n+\t  tmp_edge = make_forwarder_block (header, mfb_keep_just,\n+\t\t\t\t\t   update_latch_info);\n+\t  alloc_aux_for_block (tmp_edge->dest, sizeof (int));\n+\t  HEADER_BLOCK (tmp_edge->dest) = 1;\n+\t  alloc_aux_for_edge (tmp_edge, sizeof (int));\n+\t  LATCH_EDGE (tmp_edge) = 0;\n+\t  HEADER_BLOCK (header)--;\n+\t}\n+\n+      if (HEADER_BLOCK (header) > 1)\n+\t{\n+\t  /* Create a new latch block.  */\n+\t  tmp_edge = make_forwarder_block (header, mfb_keep_nonlatch,\n+\t\t\t\t\t   update_latch_info);\n+\t  alloc_aux_for_block (tmp_edge->dest, sizeof (int));\n+\t  HEADER_BLOCK (tmp_edge->src) = 0;\n+\t  HEADER_BLOCK (tmp_edge->dest) = 1;\n+\t  alloc_aux_for_edge (tmp_edge, sizeof (int));\n+\t  LATCH_EDGE (tmp_edge) = 1;\n \t}\n-      else\n-\tmake_forwarder_block (header, true, false, NULL, 1);\n     }\n \n   free_aux_for_blocks ();"}, {"sha": "2c60659fec8b8e91cd2045a8af78fb52fa2e0a5e", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 45, "deletions": 50, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f470c378ac3e1ee9261034709851f4c6ef068fef/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f470c378ac3e1ee9261034709851f4c6ef068fef/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=f470c378ac3e1ee9261034709851f4c6ef068fef", "patch": "@@ -63,11 +63,6 @@ split_loop_bb (basic_block bb, rtx insn)\n   /* Add dest to loop.  */\n   add_bb_to_loop (e->dest, e->src->loop_father);\n \n-  /* Fix dominators.  */\n-  add_to_dominance_info (CDI_DOMINATORS, e->dest);\n-  redirect_immediate_dominators (CDI_DOMINATORS, e->src, e->dest);\n-  set_immediate_dominator (CDI_DOMINATORS, e->dest, e->src);\n-\n   return e;\n }\n \n@@ -88,8 +83,7 @@ remove_bbs (basic_block *bbs, int nbbs)\n   for (i = 0; i < nbbs; i++)\n     {\n       remove_bb_from_loops (bbs[i]);\n-      delete_from_dominance_info (CDI_DOMINATORS, bbs[i]);\n-      delete_block (bbs[i]);\n+      delete_basic_block (bbs[i]);\n     }\n }\n \n@@ -1070,26 +1064,53 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e, struct loops *loops,\n   return true;\n }\n \n+/* A callback for make_forwarder block, to redirect all edges except for\n+   MFB_KJ_EDGE to the entry part.  E is the edge for that we should decide\n+   whether to redirect it.  */\n+\n+static edge mfb_kj_edge;\n+static bool\n+mfb_keep_just (edge e)\n+{\n+  return e != mfb_kj_edge;\n+}\n+\n+/* A callback for make_forwarder block, to update data structures for a basic\n+   block JUMP created by redirecting an edge (only the latch edge is being\n+   redirected).  */\n+\n+static void\n+mfb_update_loops (basic_block jump)\n+{\n+  struct loop *loop = jump->succ->dest->loop_father;\n+\n+  if (dom_computed[CDI_DOMINATORS])\n+    set_immediate_dominator (CDI_DOMINATORS, jump, jump->pred->src);\n+  add_bb_to_loop (jump, loop);\n+  loop->latch = jump;\n+}\n+\n /* Creates a pre-header for a LOOP.  Returns newly created block.  Unless\n    CP_SIMPLE_PREHEADERS is set in FLAGS, we only force LOOP to have single\n    entry; otherwise we also force preheader block to have only one successor.\n-   The function also updates dominators stored in DOM.  */\n+   The function also updates dominators.  */\n+\n static basic_block\n create_preheader (struct loop *loop, int flags)\n {\n   edge e, fallthru;\n   basic_block dummy;\n-  basic_block jump, src = 0;\n   struct loop *cloop, *ploop;\n   int nentry = 0;\n-  rtx insn;\n+  bool irred = false;\n \n   cloop = loop->outer;\n \n   for (e = loop->header->pred; e; e = e->pred_next)\n     {\n       if (e->src == loop->latch)\n \tcontinue;\n+      irred |= (e->flags & EDGE_IRREDUCIBLE_LOOP) != 0;\n       nentry++;\n     }\n   if (!nentry)\n@@ -1102,17 +1123,9 @@ create_preheader (struct loop *loop, int flags)\n \treturn NULL;\n     }\n \n-  insn = first_insn_after_basic_block_note (loop->header);\n-  if (insn)\n-    insn = PREV_INSN (insn);\n-  else\n-    insn = get_last_insn ();\n-  if (insn == BB_END (loop->header))\n-    {\n-      /* Split_block would not split block after its end.  */\n-      emit_note_after (NOTE_INSN_DELETED, insn);\n-    }\n-  fallthru = split_block (loop->header, insn);\n+  mfb_kj_edge = loop_latch_edge (loop);\n+  fallthru = make_forwarder_block (loop->header, mfb_keep_just,\n+\t\t\t\t   mfb_update_loops);\n   dummy = fallthru->src;\n   loop->header = fallthru->dest;\n \n@@ -1122,35 +1135,22 @@ create_preheader (struct loop *loop, int flags)\n     if (ploop->latch == dummy)\n       ploop->latch = fallthru->dest;\n \n-  add_to_dominance_info (CDI_DOMINATORS, fallthru->dest);\n-\n-  /* Redirect edges.  */\n+  /* Reorganize blocks so that the preheader is not stuck in the middle of the\n+     loop.  */\n   for (e = dummy->pred; e; e = e->pred_next)\n-    {\n-      src = e->src;\n-      if (src == loop->latch)\n-\tbreak;\n-    }\n-  if (!e)\n-    abort ();\n+    if (e->src != loop->latch)\n+      break;\n+  move_block_after (dummy, e->src);\n+\n+  loop->header->loop_father = loop;\n+  add_bb_to_loop (dummy, cloop);\n \n-  dummy->frequency -= EDGE_FREQUENCY (e);\n-  dummy->count -= e->count;\n-  fallthru->count -= e->count;\n-  jump = redirect_edge_and_branch_force (e, loop->header);\n-  if (jump)\n+  if (irred)\n     {\n-      add_to_dominance_info (CDI_DOMINATORS, jump);\n-      set_immediate_dominator (CDI_DOMINATORS, jump, src);\n-      add_bb_to_loop (jump, loop);\n-      loop->latch = jump;\n+      dummy->flags |= BB_IRREDUCIBLE_LOOP;\n+      dummy->succ->flags |= EDGE_IRREDUCIBLE_LOOP;\n     }\n \n-  /* Update structures.  */\n-  redirect_immediate_dominators (CDI_DOMINATORS, dummy, loop->header);\n-  set_immediate_dominator (CDI_DOMINATORS, loop->header, dummy);\n-  loop->header->loop_father = loop;\n-  add_bb_to_loop (dummy, cloop);\n   if (rtl_dump_file)\n     fprintf (rtl_dump_file, \"Created preheader block for loop %i\\n\",\n \t     loop->num);\n@@ -1212,7 +1212,6 @@ loop_split_edge_with (edge e, rtx insns)\n   /* Create basic block for it.  */\n \n   new_bb = split_edge (e);\n-  add_to_dominance_info (CDI_DOMINATORS, new_bb);\n   add_bb_to_loop (new_bb, loop_c);\n   new_bb->flags = insns ? BB_SUPERBLOCK : 0;\n \n@@ -1226,10 +1225,6 @@ loop_split_edge_with (edge e, rtx insns)\n   if (insns)\n     emit_insn_after (insns, BB_END (new_bb));\n \n-  set_immediate_dominator (CDI_DOMINATORS, new_bb, src);\n-  set_immediate_dominator (CDI_DOMINATORS, dest,\n-\t\t\t   recount_dominator (CDI_DOMINATORS, dest));\n-\n   if (dest->loop_father->latch == src)\n     dest->loop_father->latch = new_bb;\n "}, {"sha": "01a5f3dbe668bccec6b7aa3505404326594702aa", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 81, "deletions": 127, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f470c378ac3e1ee9261034709851f4c6ef068fef/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f470c378ac3e1ee9261034709851f4c6ef068fef/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=f470c378ac3e1ee9261034709851f4c6ef068fef", "patch": "@@ -76,18 +76,20 @@ static rtx last_loop_beg_note (rtx);\n static bool back_edge_of_syntactic_loop_p (basic_block, basic_block);\n basic_block force_nonfallthru_and_redirect (edge, basic_block);\n static basic_block rtl_split_edge (edge);\n+static bool rtl_move_block_after (basic_block, basic_block);\n static int rtl_verify_flow_info (void);\n-static edge cfg_layout_split_block (basic_block, void *);\n+static basic_block cfg_layout_split_block (basic_block, void *);\n static bool cfg_layout_redirect_edge_and_branch (edge, basic_block);\n static basic_block cfg_layout_redirect_edge_and_branch_force (edge, basic_block);\n static void cfg_layout_delete_block (basic_block);\n static void rtl_delete_block (basic_block);\n static basic_block rtl_redirect_edge_and_branch_force (edge, basic_block);\n static bool rtl_redirect_edge_and_branch (edge, basic_block);\n-static edge rtl_split_block (basic_block, void *);\n-static void rtl_dump_bb (basic_block, FILE *);\n+static basic_block rtl_split_block (basic_block, void *);\n+static void rtl_dump_bb (basic_block, FILE *, int);\n static int rtl_verify_flow_info_1 (void);\n static void mark_killed_regs (rtx, rtx, void *);\n+static void rtl_make_forwarder_block (edge);\n \f\n /* Return true if NOTE is not one of the ones that must be kept paired,\n    so that we may simply delete it.  */\n@@ -337,7 +339,7 @@ rtl_create_basic_block (void *headp, void *endp, basic_block after)\n   basic_block bb;\n \n   /* Place the new block just after the end.  */\n-  VARRAY_GROW (basic_block_info, last_basic_block+1);\n+  VARRAY_GROW (basic_block_info, last_basic_block + 1);\n \n   n_basic_blocks++;\n \n@@ -407,19 +409,6 @@ rtl_delete_block (basic_block b)\n   /* Selectively delete the entire chain.  */\n   BB_HEAD (b) = NULL;\n   delete_insn_chain (insn, end);\n-\n-  /* Remove the edges into and out of this block.  Note that there may\n-     indeed be edges in, if we are removing an unreachable loop.  */\n-  while (b->pred != NULL)\n-    remove_edge (b->pred);\n-  while (b->succ != NULL)\n-    remove_edge (b->succ);\n-\n-  b->pred = NULL;\n-  b->succ = NULL;\n-\n-  /* Remove the basic block from the array.  */\n-  expunge_block (b);\n }\n \f\n /* Records the basic block struct in BLOCK_FOR_INSN for every insn.  */\n@@ -470,28 +459,34 @@ update_bb_for_insn (basic_block bb)\n     }\n }\n \f\n-/* Split a block BB after insn INSN creating a new fallthru edge.\n-   Return the new edge.  Note that to keep other parts of the compiler happy,\n-   this function renumbers all the basic blocks so that the new\n-   one has a number one greater than the block split.  */\n+/* Creates a new basic block just after basic block B by splitting\n+   everything after specified instruction I.  */\n \n-static edge\n+static basic_block\n rtl_split_block (basic_block bb, void *insnp)\n {\n   basic_block new_bb;\n-  edge new_edge;\n-  edge e;\n   rtx insn = insnp;\n+  edge e;\n \n-  /* There is no point splitting the block after its end.  */\n-  if (BB_END (bb) == insn)\n-    return 0;\n+  if (!insn)\n+    {\n+      insn = first_insn_after_basic_block_note (bb);\n+\n+      if (insn)\n+\tinsn = PREV_INSN (insn);\n+      else\n+\tinsn = get_last_insn ();\n+    }\n+\n+  /* We probably should check type of the insn so that we do not create\n+     inconsistent cfg.  It is checked in verify_flow_info anyway, so do not\n+     bother.  */\n+  if (insn == BB_END (bb))\n+    emit_note_after (NOTE_INSN_DELETED, insn);\n \n   /* Create the new basic block.  */\n   new_bb = create_basic_block (NEXT_INSN (insn), BB_END (bb), bb);\n-  new_bb->count = bb->count;\n-  new_bb->frequency = bb->frequency;\n-  new_bb->loop_depth = bb->loop_depth;\n   BB_END (bb) = insn;\n \n   /* Redirect the outgoing edges.  */\n@@ -500,8 +495,6 @@ rtl_split_block (basic_block bb, void *insnp)\n   for (e = new_bb->succ; e; e = e->succ_next)\n     e->src = new_bb;\n \n-  new_edge = make_single_succ_edge (bb, new_bb, EDGE_FALLTHRU);\n-\n   if (bb->global_live_at_start)\n     {\n       new_bb->global_live_at_start = OBSTACK_ALLOC_REG_SET (&flow_obstack);\n@@ -528,34 +521,7 @@ rtl_split_block (basic_block bb, void *insnp)\n #endif\n     }\n \n-  return new_edge;\n-}\n-\n-/* Assume that the code of basic block B has been merged into A.\n-   Do corresponding CFG updates:  redirect edges accordingly etc.  */\n-static void\n-update_cfg_after_block_merging (basic_block a, basic_block b)\n-{\n-  edge e;\n-\n-  /* Normally there should only be one successor of A and that is B, but\n-     partway though the merge of blocks for conditional_execution we'll\n-     be merging a TEST block with THEN and ELSE successors.  Free the\n-     whole lot of them and hope the caller knows what they're doing.  */\n-  while (a->succ)\n-    remove_edge (a->succ);\n-\n-  /* Adjust the edges out of B for the new owner.  */\n-  for (e = b->succ; e; e = e->succ_next)\n-    e->src = a;\n-  a->succ = b->succ;\n-  a->flags |= b->flags;\n-\n-  /* B hasn't quite yet ceased to exist.  Attempt to prevent mishap.  */\n-  b->pred = b->succ = NULL;\n-  a->global_live_at_end = b->global_live_at_end;\n-\n-  expunge_block (b);\n+  return new_bb;\n }\n \n /* Blocks A and B are to be merged into a single block A.  The insns\n@@ -625,10 +591,9 @@ rtl_merge_blocks (basic_block a, basic_block b)\n   else if (GET_CODE (NEXT_INSN (a_end)) == BARRIER)\n     del_first = NEXT_INSN (a_end);\n \n-  update_cfg_after_block_merging (a, b);\n-\n   /* Delete everything marked above as well as crap that might be\n      hanging out between the two blocks.  */\n+  BB_HEAD (b) = NULL;\n   delete_insn_chain (del_first, del_last);\n \n   /* Reassociate the insns of B with A.  */\n@@ -1159,10 +1124,16 @@ rtl_redirect_edge_and_branch_force (edge e, basic_block target)\n /* The given edge should potentially be a fallthru edge.  If that is in\n    fact true, delete the jump and barriers that are in the way.  */\n \n-void\n-tidy_fallthru_edge (edge e, basic_block b, basic_block c)\n+static void\n+rtl_tidy_fallthru_edge (edge e)\n {\n   rtx q;\n+  basic_block b = e->src, c = b->next_bb;\n+\n+  /* If the jump insn has side effects, we can't tidy the edge.  */\n+  if (GET_CODE (BB_END (b)) == JUMP_INSN\n+      && !onlyjump_p (BB_END (b)))\n+    return;\n \n   /* ??? In a late-running flow pass, other folks may have deleted basic\n      blocks by nopping out blocks, leaving multiple BARRIERs between here\n@@ -1208,48 +1179,6 @@ tidy_fallthru_edge (edge e, basic_block b, basic_block c)\n \n   e->flags |= EDGE_FALLTHRU;\n }\n-\n-/* Fix up edges that now fall through, or rather should now fall through\n-   but previously required a jump around now deleted blocks.  Simplify\n-   the search by only examining blocks numerically adjacent, since this\n-   is how find_basic_blocks created them.  */\n-\n-void\n-tidy_fallthru_edges (void)\n-{\n-  basic_block b, c;\n-\n-  if (ENTRY_BLOCK_PTR->next_bb == EXIT_BLOCK_PTR)\n-    return;\n-\n-  FOR_BB_BETWEEN (b, ENTRY_BLOCK_PTR->next_bb, EXIT_BLOCK_PTR->prev_bb, next_bb)\n-    {\n-      edge s;\n-\n-      c = b->next_bb;\n-\n-      /* We care about simple conditional or unconditional jumps with\n-\t a single successor.\n-\n-\t If we had a conditional branch to the next instruction when\n-\t find_basic_blocks was called, then there will only be one\n-\t out edge for the block which ended with the conditional\n-\t branch (since we do not create duplicate edges).\n-\n-\t Furthermore, the edge will be marked as a fallthru because we\n-\t merge the flags for the duplicate edges.  So we do not want to\n-\t check that the edge is not a FALLTHRU edge.  */\n-\n-      if ((s = b->succ) != NULL\n-\t  && ! (s->flags & EDGE_COMPLEX)\n-\t  && s->succ_next == NULL\n-\t  && s->dest == c\n-\t  /* If the jump insn has side effects, we can't tidy the edge.  */\n-\t  && (GET_CODE (BB_END (b)) != JUMP_INSN\n-\t      || onlyjump_p (BB_END (b))))\n-\ttidy_fallthru_edge (s, b, c);\n-    }\n-}\n \f\n /* Helper function for split_edge.  Return true in case edge BB2 to BB1\n    is back edge of syntactic loop.  */\n@@ -1285,6 +1214,15 @@ back_edge_of_syntactic_loop_p (basic_block bb1, basic_block bb2)\n   return count >= 0;\n }\n \n+/* Should move basic block BB after basic block AFTER.  NIY.  */\n+\n+static bool\n+rtl_move_block_after (basic_block bb ATTRIBUTE_UNUSED,\n+\t\t      basic_block after ATTRIBUTE_UNUSED)\n+{\n+  return false;\n+}\n+\n /* Split a (typically critical) edge.  Return the new block.\n    Abort on abnormal edges.\n \n@@ -1347,8 +1285,6 @@ rtl_split_edge (edge edge_in)\n     before = NULL_RTX;\n \n   bb = create_basic_block (before, NULL, edge_in->dest->prev_bb);\n-  bb->count = edge_in->count;\n-  bb->frequency = EDGE_FREQUENCY (edge_in);\n \n   /* ??? This info is likely going to be out of date very soon.  */\n   if (edge_in->dest->global_live_at_start)\n@@ -1714,23 +1650,29 @@ commit_edge_insertions_watch_calls (void)\n   sbitmap_free (blocks);\n }\n \f\n-/* Print out one basic block with live information at start and end.  */\n+/* Print out RTL-specific basic block information (live information\n+   at start and end).  */\n \n static void\n-rtl_dump_bb (basic_block bb, FILE *outf)\n+rtl_dump_bb (basic_block bb, FILE *outf, int indent)\n {\n   rtx insn;\n   rtx last;\n+  char *s_indent;\n \n-  fputs (\";; Registers live at start:\", outf);\n+  s_indent = (char *) alloca ((size_t) indent + 1);\n+  memset ((void *) s_indent, ' ', (size_t) indent);\n+  s_indent[indent] = '\\0';\n+\n+  fprintf (outf, \";;%s Registers live at start: \", s_indent);\n   dump_regset (bb->global_live_at_start, outf);\n   putc ('\\n', outf);\n \n   for (insn = BB_HEAD (bb), last = NEXT_INSN (BB_END (bb)); insn != last;\n        insn = NEXT_INSN (insn))\n     print_rtl_single (outf, insn);\n \n-  fputs (\";; Registers live at end:\", outf);\n+  fprintf (outf, \";;%s Registers live at end: \", s_indent);\n   dump_regset (bb->global_live_at_end, outf);\n   putc ('\\n', outf);\n }\n@@ -1847,6 +1789,7 @@ update_br_prob_note (basic_block bb)\n \n    In future it can be extended check a lot of other stuff as well\n    (reachability of basic blocks, life information, etc. etc.).  */\n+\n static int\n rtl_verify_flow_info_1 (void)\n {\n@@ -2412,16 +2355,17 @@ purge_all_dead_edges (int update_life_p)\n }\n \n /* Same as split_block but update cfg_layout structures.  */\n-static edge\n+\n+static basic_block\n cfg_layout_split_block (basic_block bb, void *insnp)\n {\n   rtx insn = insnp;\n+  basic_block new_bb = rtl_split_block (bb, insn);\n \n-  edge fallthru = rtl_split_block (bb, insn);\n+  new_bb->rbi->footer = bb->rbi->footer;\n+  bb->rbi->footer = NULL;\n \n-  fallthru->dest->rbi->footer = fallthru->src->rbi->footer;\n-  fallthru->src->rbi->footer = NULL;\n-  return fallthru;\n+  return new_bb;\n }\n \n \n@@ -2511,7 +2455,8 @@ cfg_layout_redirect_edge_and_branch_force (edge e, basic_block dest)\n   return NULL;\n }\n \n-/* Same as flow_delete_block but update cfg_layout structures.  */\n+/* Same as delete_basic_block but update cfg_layout structures.  */\n+\n static void\n cfg_layout_delete_block (basic_block bb)\n {\n@@ -2693,11 +2638,10 @@ cfg_layout_merge_blocks (basic_block a, basic_block b)\n   if (rtl_dump_file)\n     fprintf (rtl_dump_file, \"Merged blocks %d and %d.\\n\",\n \t     a->index, b->index);\n-\n-  update_cfg_after_block_merging (a, b);\n }\n \n /* Split edge E.  */\n+\n static basic_block\n cfg_layout_split_edge (edge e)\n {\n@@ -2707,44 +2651,54 @@ cfg_layout_split_edge (edge e)\n \t\t\t? NEXT_INSN (BB_END (e->src)) : get_insns (),\n \t\t\tNULL_RTX, e->src);\n \n-  new_bb->count = e->count;\n-  new_bb->frequency = EDGE_FREQUENCY (e);\n-\n   new_e = make_edge (new_bb, e->dest, EDGE_FALLTHRU);\n-  new_e->probability = REG_BR_PROB_BASE;\n-  new_e->count = e->count;\n   redirect_edge_and_branch_force (e, new_bb);\n \n   return new_bb;\n }\n \n+/* Do postprocessing after making a forwarder block joined by edge FALLTHRU.  */\n+\n+static void\n+rtl_make_forwarder_block (edge fallthru ATTRIBUTE_UNUSED)\n+{\n+}\n+\n /* Implementation of CFG manipulation for linearized RTL.  */\n struct cfg_hooks rtl_cfg_hooks = {\n+  \"rtl\",\n   rtl_verify_flow_info,\n   rtl_dump_bb,\n   rtl_create_basic_block,\n   rtl_redirect_edge_and_branch,\n   rtl_redirect_edge_and_branch_force,\n   rtl_delete_block,\n   rtl_split_block,\n+  rtl_move_block_after,\n   rtl_can_merge_blocks,  /* can_merge_blocks_p */\n   rtl_merge_blocks,\n-  rtl_split_edge\n+  rtl_split_edge,\n+  rtl_make_forwarder_block,\n+  rtl_tidy_fallthru_edge\n };\n \n /* Implementation of CFG manipulation for cfg layout RTL, where\n    basic block connected via fallthru edges does not have to be adjacent.\n    This representation will hopefully become the default one in future\n    version of the compiler.  */\n struct cfg_hooks cfg_layout_rtl_cfg_hooks = {\n+  \"cfglayout mode\",\n   rtl_verify_flow_info_1,\n   rtl_dump_bb,\n   cfg_layout_create_basic_block,\n   cfg_layout_redirect_edge_and_branch,\n   cfg_layout_redirect_edge_and_branch_force,\n   cfg_layout_delete_block,\n   cfg_layout_split_block,\n+  rtl_move_block_after,\n   cfg_layout_can_merge_blocks_p,\n   cfg_layout_merge_blocks,\n-  cfg_layout_split_edge\n+  cfg_layout_split_edge,\n+  rtl_make_forwarder_block,\n+  NULL\n };"}, {"sha": "76ffdacc19441c12a5b207b56d6b707f466f2a16", "filename": "gcc/flow.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f470c378ac3e1ee9261034709851f4c6ef068fef/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f470c378ac3e1ee9261034709851f4c6ef068fef/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=f470c378ac3e1ee9261034709851f4c6ef068fef", "patch": "@@ -517,7 +517,7 @@ verify_wide_reg (int regno, basic_block bb)\n   if (rtl_dump_file)\n     {\n       fprintf (rtl_dump_file, \"Register %d died unexpectedly.\\n\", regno);\n-      dump_bb (bb, rtl_dump_file);\n+      dump_bb (bb, rtl_dump_file, 0);\n     }\n   abort ();\n }\n@@ -541,7 +541,7 @@ verify_local_live_at_start (regset new_live_at_start, basic_block bb)\n \t\t       bb->index);\n \t      debug_bitmap_file (rtl_dump_file, new_live_at_start);\n \t      fputs (\"Old:\\n\", rtl_dump_file);\n-\t      dump_bb (bb, rtl_dump_file);\n+\t      dump_bb (bb, rtl_dump_file, 0);\n \t    }\n \t  abort ();\n \t}\n@@ -562,7 +562,7 @@ verify_local_live_at_start (regset new_live_at_start, basic_block bb)\n \t\t{\n \t\t  fprintf (rtl_dump_file,\n \t\t\t   \"Register %d died unexpectedly.\\n\", i);\n-\t\t  dump_bb (bb, rtl_dump_file);\n+\t\t  dump_bb (bb, rtl_dump_file, 0);\n \t\t}\n \t      abort ();\n \t    }"}, {"sha": "7a790638091eaafd9d05e26f340bf72e26723e00", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 4, "deletions": 22, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f470c378ac3e1ee9261034709851f4c6ef068fef/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f470c378ac3e1ee9261034709851f4c6ef068fef/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=f470c378ac3e1ee9261034709851f4c6ef068fef", "patch": "@@ -2103,8 +2103,6 @@ merge_if_block (struct ce_if_block * ce_info)\n \t{\n \t  bb = fallthru;\n \t  fallthru = block_fallthru (bb);\n-\t  if (dom_computed[CDI_POST_DOMINATORS] >= DOM_NO_FAST_QUERY)\n-\t    delete_from_dominance_info (CDI_POST_DOMINATORS, bb);\n \t  merge_blocks (combo_bb, bb);\n \t  num_true_changes++;\n \t}\n@@ -2120,8 +2118,6 @@ merge_if_block (struct ce_if_block * ce_info)\n       if (combo_bb->global_live_at_end)\n \tCOPY_REG_SET (combo_bb->global_live_at_end,\n \t\t      then_bb->global_live_at_end);\n-      if (dom_computed[CDI_POST_DOMINATORS] >= DOM_NO_FAST_QUERY)\n-\tdelete_from_dominance_info (CDI_POST_DOMINATORS, then_bb);\n       merge_blocks (combo_bb, then_bb);\n       num_true_changes++;\n     }\n@@ -2131,8 +2127,6 @@ merge_if_block (struct ce_if_block * ce_info)\n      get their addresses taken.  */\n   if (else_bb)\n     {\n-      if (dom_computed[CDI_POST_DOMINATORS] >= DOM_NO_FAST_QUERY)\n-       \tdelete_from_dominance_info (CDI_POST_DOMINATORS, else_bb);\n       merge_blocks (combo_bb, else_bb);\n       num_true_changes++;\n     }\n@@ -2188,8 +2182,6 @@ merge_if_block (struct ce_if_block * ce_info)\n \tCOPY_REG_SET (combo_bb->global_live_at_end,\n \t\t      join_bb->global_live_at_end);\n \n-      if (dom_computed[CDI_POST_DOMINATORS] >= DOM_NO_FAST_QUERY)\n-\tdelete_from_dominance_info (CDI_POST_DOMINATORS, join_bb);\n       merge_blocks (combo_bb, join_bb);\n       num_true_changes++;\n     }\n@@ -2205,7 +2197,7 @@ merge_if_block (struct ce_if_block * ce_info)\n \n       /* Remove the jump and cruft from the end of the COMBO block.  */\n       if (join_bb != EXIT_BLOCK_PTR)\n-\ttidy_fallthru_edge (combo_bb->succ, combo_bb, join_bb);\n+\ttidy_fallthru_edge (combo_bb->succ);\n     }\n \n   num_updated_if_blocks++;\n@@ -2643,11 +2635,7 @@ find_cond_trap (basic_block test_bb, edge then_edge, edge else_edge)\n   /* Delete the trap block if possible.  */\n   remove_edge (trap_bb == then_bb ? then_edge : else_edge);\n   if (trap_bb->pred == NULL)\n-    {\n-      if (dom_computed[CDI_POST_DOMINATORS] >= DOM_NO_FAST_QUERY)\n-\tdelete_from_dominance_info (CDI_POST_DOMINATORS, trap_bb);\n-      delete_block (trap_bb);\n-    }\n+    delete_basic_block (trap_bb);\n \n   /* If the non-trap block and the test are now adjacent, merge them.\n      Otherwise we must insert a direct branch.  */\n@@ -2829,18 +2817,14 @@ find_if_case_1 (basic_block test_bb, edge then_edge, edge else_edge)\n \n   new_bb = redirect_edge_and_branch_force (FALLTHRU_EDGE (test_bb), else_bb);\n   then_bb_index = then_bb->index;\n-  if (dom_computed[CDI_POST_DOMINATORS] >= DOM_NO_FAST_QUERY)\n-    delete_from_dominance_info (CDI_POST_DOMINATORS, then_bb);\n-  delete_block (then_bb);\n+  delete_basic_block (then_bb);\n \n   /* Make rest of code believe that the newly created block is the THEN_BB\n      block we removed.  */\n   if (new_bb)\n     {\n       new_bb->index = then_bb_index;\n       BASIC_BLOCK (then_bb_index) = new_bb;\n-      if (dom_computed[CDI_POST_DOMINATORS] >= DOM_NO_FAST_QUERY)\n-\tadd_to_dominance_info (CDI_POST_DOMINATORS, new_bb);\n     }\n   /* We've possibly created jump to next insn, cleanup_cfg will solve that\n      later.  */\n@@ -2909,9 +2893,7 @@ find_if_case_2 (basic_block test_bb, edge then_edge, edge else_edge)\n \t\t    then_bb->global_live_at_start,\n \t\t    else_bb->global_live_at_end, BITMAP_IOR);\n \n-  if (dom_computed[CDI_POST_DOMINATORS] >= DOM_NO_FAST_QUERY)\n-    delete_from_dominance_info (CDI_POST_DOMINATORS, else_bb);\n-  delete_block (else_bb);\n+  delete_basic_block (else_bb);\n \n   num_true_changes++;\n   num_updated_if_blocks++;"}, {"sha": "aa39ae238165015a3e9a6af045a2baeeda0a42ef", "filename": "gcc/loop-unswitch.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f470c378ac3e1ee9261034709851f4c6ef068fef/gcc%2Floop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f470c378ac3e1ee9261034709851f4c6ef068fef/gcc%2Floop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unswitch.c?ref=f470c378ac3e1ee9261034709851f4c6ef068fef", "patch": "@@ -381,7 +381,6 @@ unswitch_loop (struct loops *loops, struct loop *loop, basic_block unswitch_on)\n       switch_bb->succ->flags &= ~EDGE_IRREDUCIBLE_LOOP;\n       switch_bb->succ->succ_next->flags &= ~EDGE_IRREDUCIBLE_LOOP;\n     }\n-  add_to_dominance_info (CDI_DOMINATORS, switch_bb);\n   unswitch_on->rbi->copy = unswitch_on_alt;\n \n   /* Loopify from the copy of LOOP body, constructing the new loop.  */"}, {"sha": "19dc0c468f0dcb5a5a41060e65ca56ad24b96473", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f470c378ac3e1ee9261034709851f4c6ef068fef/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f470c378ac3e1ee9261034709851f4c6ef068fef/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=f470c378ac3e1ee9261034709851f4c6ef068fef", "patch": "@@ -45,6 +45,7 @@ DEFTIMEVAR (TV_CGRAPHOPT             , \"callgraph optimization\")\n DEFTIMEVAR (TV_CFG                   , \"cfg construction\")\n /* Time spent by cleaning up CFG.  */\n DEFTIMEVAR (TV_CLEANUP_CFG           , \"cfg cleanup\")\n+DEFTIMEVAR (TV_CFG_VERIFY            , \"CFG verifier\")\n DEFTIMEVAR (TV_DELETE_TRIVIALLY_DEAD , \"trivially dead code\")\n /* Time spent by life analysis.  */\n DEFTIMEVAR (TV_LIFE\t\t     , \"life analysis\")"}]}