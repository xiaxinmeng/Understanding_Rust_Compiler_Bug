{"sha": "5f61007448569bb7dcca95979ac5fce82cb405d7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWY2MTAwNzQ0ODU2OWJiN2RjY2E5NTk3OWFjNWZjZTgyY2I0MDVkNw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-04-18T19:41:06Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-04-18T19:41:06Z"}, "message": "(const_binop): If arg is NaN, just return it\n\n(const_binop): If arg is NaN, just return it\n(fold_convert): Handle NaN in real->int and real->real cases.\n\nFrom-SVN: r7072", "tree": {"sha": "0c2b23edf6954ac49a88781b4eb437f4b0ae92a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c2b23edf6954ac49a88781b4eb437f4b0ae92a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f61007448569bb7dcca95979ac5fce82cb405d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f61007448569bb7dcca95979ac5fce82cb405d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f61007448569bb7dcca95979ac5fce82cb405d7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f61007448569bb7dcca95979ac5fce82cb405d7/comments", "author": null, "committer": null, "parents": [{"sha": "a47a0ed53b1068e5100befb6bb6b7d5af211a382", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a47a0ed53b1068e5100befb6bb6b7d5af211a382", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a47a0ed53b1068e5100befb6bb6b7d5af211a382"}], "stats": {"total": 45, "additions": 27, "deletions": 18}, "files": [{"sha": "9fa976b92b78b323fb70b38d2317547771db22c5", "filename": "gcc/fold-const.c", "status": "modified", "additions": 27, "deletions": 18, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f61007448569bb7dcca95979ac5fce82cb405d7/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f61007448569bb7dcca95979ac5fce82cb405d7/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=5f61007448569bb7dcca95979ac5fce82cb405d7", "patch": "@@ -1339,7 +1339,14 @@ const_binop (code, arg1, arg2, notrunc)\n \n       d1 = TREE_REAL_CST (arg1);\n       d2 = TREE_REAL_CST (arg2);\n-      if (setjmp (float_error))\n+\n+      /* If either operand is a NaN, just return it.  Otherwise, set up\n+\t for floating-point trap; we return an overflow.  */\n+      if (REAL_VALUE_ISNAN (d1))\n+\treturn arg1;\n+      else if (REAL_VALUE_ISNAN (d2))\n+\treturn arg2;\n+      else if (setjmp (float_error))\n \t{\n \t  t = copy_node (arg1);\n \t  overflow = 1;\n@@ -1577,11 +1584,9 @@ fold_convert (t, arg1)\n #if !defined (REAL_IS_NOT_DOUBLE) || defined (REAL_ARITHMETIC)\n       else if (TREE_CODE (arg1) == REAL_CST)\n \t{\n-\t  REAL_VALUE_TYPE l, x, u;\n-\n-\t  l = real_value_from_int_cst (TYPE_MIN_VALUE (type));\n-\t  x = TREE_REAL_CST (arg1);\n-\t  u = real_value_from_int_cst (TYPE_MAX_VALUE (type));\n+\t  REAL_VALUE_TYPE x = TREE_REAL_CST (arg1);\n+\t  REAL_VALUE_TYPE l = real_value_from_int_cst (TYPE_MIN_VALUE (type));\n+\t  REAL_VALUE_TYPE u = real_value_from_int_cst (TYPE_MAX_VALUE (type));\n \n \t  /* See if X will be in range after truncation towards 0.\n \t     To compensate for truncation, move the bounds away from 0,\n@@ -1593,37 +1598,39 @@ fold_convert (t, arg1)\n \t  l--;\n \t  u++;\n #endif\n-\t  if (! (REAL_VALUES_LESS (l, x) && REAL_VALUES_LESS (x, u)))\n+\t  /* If X is a NaN, use zero instead and show we have an overflow.\n+\t     Otherwise, range check.  */\n+\t  if (REAL_VALUE_ISNAN (x))\n+\t    overflow = 1, x = dconst0;\n+\t  else if (! (REAL_VALUES_LESS (l, x) && REAL_VALUES_LESS (x, u)))\n \t    overflow = 1;\n \n #ifndef REAL_ARITHMETIC\n \t  {\n-\t    REAL_VALUE_TYPE d;\n \t    HOST_WIDE_INT low, high;\n \t    HOST_WIDE_INT half_word\n \t      = (HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT / 2);\n \n-\t    d = TREE_REAL_CST (arg1);\n-\t    if (d < 0)\n-\t      d = -d;\n+\t    if (x < 0)\n+\t      x = -x;\n \n-\t    high = (HOST_WIDE_INT) (d / half_word / half_word);\n-\t    d -= (REAL_VALUE_TYPE) high * half_word * half_word;\n-\t    if (d >= (REAL_VALUE_TYPE) half_word * half_word / 2)\n+\t    high = (HOST_WIDE_INT) (x / half_word / half_word);\n+\t    x -= (REAL_VALUE_TYPE) high * half_word * half_word;\n+\t    if (x >= (REAL_VALUE_TYPE) half_word * half_word / 2)\n \t      {\n-\t\tlow = d - (REAL_VALUE_TYPE) half_word * half_word / 2;\n+\t\tlow = x - (REAL_VALUE_TYPE) half_word * half_word / 2;\n \t\tlow |= (HOST_WIDE_INT) -1 << (HOST_BITS_PER_WIDE_INT - 1);\n \t      }\n \t    else\n-\t      low = (HOST_WIDE_INT) d;\n+\t      low = (HOST_WIDE_INT) x;\n \t    if (TREE_REAL_CST (arg1) < 0)\n \t      neg_double (low, high, &low, &high);\n \t    t = build_int_2 (low, high);\n \t  }\n #else\n \t  {\n \t    HOST_WIDE_INT low, high;\n-\t    REAL_VALUE_TO_INT (&low, &high, (TREE_REAL_CST (arg1)));\n+\t    REAL_VALUE_TO_INT (&low, &high, x);\n \t    t = build_int_2 (low, high);\n \t  }\n #endif\n@@ -1644,7 +1651,9 @@ fold_convert (t, arg1)\n #endif /* not REAL_IS_NOT_DOUBLE, or REAL_ARITHMETIC */\n       if (TREE_CODE (arg1) == REAL_CST)\n \t{\n-\t  if (setjmp (float_error))\n+\t  if (REAL_VALUE_ISNAN (TREE_REAL_CST (arg1)))\n+\t    return arg1;\n+\t  else if (setjmp (float_error))\n \t    {\n \t      overflow = 1;\n \t      t = copy_node (arg1);"}]}