{"sha": "c946adde12fa27f4572f3b23917b143e1767e475", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzk0NmFkZGUxMmZhMjdmNDU3MmYzYjIzOTE3YjE0M2UxNzY3ZTQ3NQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2011-09-11T18:38:30Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-09-11T18:38:30Z"}, "message": "trans.c (call_to_gnu): Use local variable.\n\n\t* gcc-interface/trans.c (call_to_gnu): Use local variable.  Make sure\n\tthis is a real formal parameter before testing whether it is by ref.\n\nFrom-SVN: r178763", "tree": {"sha": "51aa3aba42bd99f341de99f686148515433bafa1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/51aa3aba42bd99f341de99f686148515433bafa1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c946adde12fa27f4572f3b23917b143e1767e475", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c946adde12fa27f4572f3b23917b143e1767e475", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c946adde12fa27f4572f3b23917b143e1767e475", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c946adde12fa27f4572f3b23917b143e1767e475/comments", "author": null, "committer": null, "parents": [{"sha": "dddf8120dbd8633f77e47501efc234057778ecfc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dddf8120dbd8633f77e47501efc234057778ecfc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dddf8120dbd8633f77e47501efc234057778ecfc"}], "stats": {"total": 30, "additions": 15, "deletions": 15}, "files": [{"sha": "781f4b4488165f3622f9f3c5edac5d9f6104baa6", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c946adde12fa27f4572f3b23917b143e1767e475/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c946adde12fa27f4572f3b23917b143e1767e475/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=c946adde12fa27f4572f3b23917b143e1767e475", "patch": "@@ -1,3 +1,8 @@\n+2011-09-11  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/trans.c (call_to_gnu): Use local variable.  Make sure\n+\tthis is a real formal parameter before testing whether it is by ref.\n+\n 2011-09-11  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/gigi.h (build_call_0_expr): Delete."}, {"sha": "fdc8acba1481867a98816d47dd1ef78acf5dbc1a", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c946adde12fa27f4572f3b23917b143e1767e475/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c946adde12fa27f4572f3b23917b143e1767e475/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=c946adde12fa27f4572f3b23917b143e1767e475", "patch": "@@ -2943,6 +2943,8 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n       tree gnu_formal = present_gnu_tree (gnat_formal)\n \t\t\t? get_gnu_tree (gnat_formal) : NULL_TREE;\n       tree gnu_formal_type = gnat_to_gnu_type (Etype (gnat_formal));\n+      const bool is_true_formal_parm\n+\t= gnu_formal && TREE_CODE (gnu_formal) == PARM_DECL;\n       /* In the Out or In Out case, we must suppress conversions that yield\n \t an lvalue but can nevertheless cause the creation of a temporary,\n \t because we need the real object in this case, either to pass its\n@@ -2951,7 +2953,7 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t We do it in the In case too, except for an unchecked conversion\n \t because it alone can cause the actual to be misaligned and the\n \t addressability test is applied to the real object.  */\n-      bool suppress_type_conversion\n+      const bool suppress_type_conversion\n \t= ((Nkind (gnat_actual) == N_Unchecked_Type_Conversion\n \t    && Ekind (gnat_formal) != E_In_Parameter)\n \t   || (Nkind (gnat_actual) == N_Type_Conversion\n@@ -2972,11 +2974,10 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n       /* If we are passing a non-addressable parameter by reference, pass the\n \t address of a copy.  In the Out or In Out case, set up to copy back\n \t out after the call.  */\n-      if (gnu_formal\n+      if (is_true_formal_parm\n \t  && (DECL_BY_REF_P (gnu_formal)\n-\t      || (TREE_CODE (gnu_formal) == PARM_DECL\n-\t\t  && (DECL_BY_COMPONENT_PTR_P (gnu_formal)\n-\t\t      || (DECL_BY_DESCRIPTOR_P (gnu_formal)))))\n+\t      || DECL_BY_COMPONENT_PTR_P (gnu_formal)\n+\t      || DECL_BY_DESCRIPTOR_P (gnu_formal))\n \t  && (gnu_name_type = gnat_to_gnu_type (Etype (gnat_name)))\n \t  && !addressable_p (gnu_name, gnu_name_type))\n \t{\n@@ -3118,9 +3119,7 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n       /* If we have not saved a GCC object for the formal, it means it is an\n \t Out parameter not passed by reference and that need not be copied in.\n \t Otherwise, first see if the parameter is passed by reference.  */\n-      if (gnu_formal\n-\t  && TREE_CODE (gnu_formal) == PARM_DECL\n-\t  && DECL_BY_REF_P (gnu_formal))\n+      if (is_true_formal_parm && DECL_BY_REF_P (gnu_formal))\n \t{\n \t  if (Ekind (gnat_formal) != E_In_Parameter)\n \t    {\n@@ -3171,9 +3170,7 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \n \t  gnu_actual = build_unary_op (ADDR_EXPR, gnu_formal_type, gnu_actual);\n \t}\n-      else if (gnu_formal\n-\t       && TREE_CODE (gnu_formal) == PARM_DECL\n-\t       && DECL_BY_COMPONENT_PTR_P (gnu_formal))\n+      else if (is_true_formal_parm && DECL_BY_COMPONENT_PTR_P (gnu_formal))\n \t{\n \t  gnu_formal_type = TREE_TYPE (gnu_formal);\n \t  gnu_actual = maybe_implicit_deref (gnu_actual);\n@@ -3193,9 +3190,7 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t     but this is the most likely to work in all cases.  */\n \t  gnu_actual = build_unary_op (ADDR_EXPR, gnu_formal_type, gnu_actual);\n \t}\n-      else if (gnu_formal\n-\t       && TREE_CODE (gnu_formal) == PARM_DECL\n-\t       && DECL_BY_DESCRIPTOR_P (gnu_formal))\n+      else if (is_true_formal_parm && DECL_BY_DESCRIPTOR_P (gnu_formal))\n \t{\n \t  gnu_actual = convert (gnu_formal_type, gnu_actual);\n \n@@ -3218,7 +3213,7 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t  if (Ekind (gnat_formal) != E_In_Parameter)\n \t    gnu_name_list = tree_cons (NULL_TREE, gnu_name, gnu_name_list);\n \n-\t  if (!(gnu_formal && TREE_CODE (gnu_formal) == PARM_DECL))\n+\t  if (!is_true_formal_parm)\n \t    {\n \t      /* Make sure side-effects are evaluated before the call.  */\n \t      if (TREE_SIDE_EFFECTS (gnu_name))"}]}