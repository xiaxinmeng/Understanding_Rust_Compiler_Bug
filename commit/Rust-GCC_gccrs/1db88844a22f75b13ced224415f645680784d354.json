{"sha": "1db88844a22f75b13ced224415f645680784d354", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWRiODg4NDRhMjJmNzViMTNjZWQyMjQ0MTVmNjQ1NjgwNzg0ZDM1NA==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-08-25T09:05:57Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-08-26T08:03:55Z"}, "message": "d: Fix small struct literals that have non-deterministic hash values\n\nSame issue as the initial commit that addressed PR96153, only this time to fix\nit also for structs that are not returned in memory.  Tests have been added\nthat triggered an assertion on x86_64, however the original test was failing\non SPARC 64-bit targets.\n\ngcc/d/ChangeLog:\n\n\tPR d/96153\n\t* d-codegen.cc (build_address): Create a temporary for CALL_EXPRs\n\treturning trivial aggregates, pre-filling it with zeroes.\n\t(build_memset_call): Use build_zero_cst if setting the entire object.\n\ngcc/testsuite/ChangeLog:\n\n\tPR d/96153\n\t* gdc.dg/pr96153.d: Add new tests.", "tree": {"sha": "a4485d214e8b889e877596535d9a7d0de971b27b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a4485d214e8b889e877596535d9a7d0de971b27b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1db88844a22f75b13ced224415f645680784d354", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1db88844a22f75b13ced224415f645680784d354", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1db88844a22f75b13ced224415f645680784d354", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1db88844a22f75b13ced224415f645680784d354/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "312ad889e99ff9458c01518325775e75ab57f272", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/312ad889e99ff9458c01518325775e75ab57f272", "html_url": "https://github.com/Rust-GCC/gccrs/commit/312ad889e99ff9458c01518325775e75ab57f272"}], "stats": {"total": 49, "additions": 47, "deletions": 2}, "files": [{"sha": "4050b85af28e44642dc0641bcb5f82d9b66fda6f", "filename": "gcc/d/d-codegen.cc", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1db88844a22f75b13ced224415f645680784d354/gcc%2Fd%2Fd-codegen.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1db88844a22f75b13ced224415f645680784d354/gcc%2Fd%2Fd-codegen.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-codegen.cc?ref=1db88844a22f75b13ced224415f645680784d354", "patch": "@@ -668,9 +668,23 @@ build_address (tree exp)\n   /* Some expression lowering may request an address of a compile-time constant,\n      or other non-lvalue expression.  Make sure it is assigned to a location we\n      can reference.  */\n-  if ((CONSTANT_CLASS_P (exp) && TREE_CODE (exp) != STRING_CST)\n-      || TREE_CODE (exp) == CALL_EXPR)\n+  if (CONSTANT_CLASS_P (exp) && TREE_CODE (exp) != STRING_CST)\n     exp = force_target_expr (exp);\n+  else if (TREE_CODE (exp) == CALL_EXPR)\n+    {\n+      /* When a struct or array is returned in registers, we need to again fill\n+\t in all alignment holes.  */\n+      if (AGGREGATE_TYPE_P (TREE_TYPE (exp))\n+\t  && !aggregate_value_p (TREE_TYPE (exp), exp))\n+\t{\n+\t  tree tmp = build_local_temp (TREE_TYPE (exp));\n+\t  init = compound_expr (init, build_memset_call (tmp));\n+\t  init = compound_expr (init, modify_expr (tmp, exp));\n+\t  exp = tmp;\n+\t}\n+      else\n+\texp = force_target_expr (exp);\n+    }\n \n   d_mark_addressable (exp);\n   exp = build_fold_addr_expr_with_type_loc (input_location, exp, ptrtype);\n@@ -825,6 +839,19 @@ build_memset_call (tree ptr, tree num)\n       ptr = build_address (ptr);\n     }\n \n+  /* Use a zero constant to fill the destination if setting the entire object.\n+     For CONSTRUCTORs, the memcpy() is lowered to a ref-all pointer assignment,\n+     which can then be merged with other stores to the object.  */\n+  tree valtype = TREE_TYPE (TREE_TYPE (ptr));\n+  if (tree_int_cst_equal (TYPE_SIZE_UNIT (valtype), num))\n+    {\n+      tree cst = build_zero_cst (valtype);\n+      if (TREE_CODE (cst) == CONSTRUCTOR)\n+\treturn build_memcpy_call (ptr, build_address (cst), num);\n+\n+      return modify_expr (build_deref (ptr), cst);\n+    }\n+\n   return build_call_expr (builtin_decl_explicit (BUILT_IN_MEMSET), 3,\n \t\t\t  ptr, integer_zero_node, num);\n }"}, {"sha": "e1b8d816df0f91f56efc0513c767f74285c07436", "filename": "gcc/testsuite/gdc.dg/pr96153.d", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1db88844a22f75b13ced224415f645680784d354/gcc%2Ftestsuite%2Fgdc.dg%2Fpr96153.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1db88844a22f75b13ced224415f645680784d354/gcc%2Ftestsuite%2Fgdc.dg%2Fpr96153.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fpr96153.d?ref=1db88844a22f75b13ced224415f645680784d354", "patch": "@@ -20,6 +20,24 @@ Checked!(T, Hook) checked(Hook, T)(const T value)\n \n @system unittest\n {\n+    static struct Hook1\n+    {\n+        uint var1 = uint.max;\n+        uint var2 = uint.max;\n+    }\n+\n+    assert(checked!Hook1(12).toHash() != checked!Hook1(13).toHash());\n+    assert(checked!Hook1(13).toHash() == checked!Hook1(13).toHash());\n+\n+    static struct Hook2\n+    {\n+        uint var1 = uint.max;\n+        ushort var2 = ushort.max;\n+    }\n+\n+    assert(checked!Hook2(12).toHash() != checked!Hook2(13).toHash());\n+    assert(checked!Hook2(13).toHash() == checked!Hook2(13).toHash());\n+\n     static struct Hook3\n     {\n         ulong var1 = ulong.max;"}]}