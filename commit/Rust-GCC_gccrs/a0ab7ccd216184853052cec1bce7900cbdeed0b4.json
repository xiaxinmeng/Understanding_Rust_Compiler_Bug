{"sha": "a0ab7ccd216184853052cec1bce7900cbdeed0b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTBhYjdjY2QyMTYxODQ4NTMwNTJjZWMxYmNlNzkwMGNiZGVlZDBiNA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2017-08-29T19:40:14Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2017-08-29T19:40:14Z"}, "message": "Add immediate potential_constant_expression variants.\n\n\t* constexpr.c (potential_constant_expression_1): Add \"now\" parm.\n\t(is_constant_expression, require_constant_expression): New.\n\t(is_static_init_expression, is_nondependent_constant_expression)\n\t(is_nondependent_static_init_expression): Drop \"potential\".\n\t* except.c (build_must_not_throw_expr): Do type conversion on\n\tvalue-dependent argument.\n\t* pt.c, semantics.c, typeck2.c: Use variants without \"potential\".\n\nFrom-SVN: r251423", "tree": {"sha": "29a36ea3eecd68beb15c9eab599e458926584a2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/29a36ea3eecd68beb15c9eab599e458926584a2b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a0ab7ccd216184853052cec1bce7900cbdeed0b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0ab7ccd216184853052cec1bce7900cbdeed0b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0ab7ccd216184853052cec1bce7900cbdeed0b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0ab7ccd216184853052cec1bce7900cbdeed0b4/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "12659e10c78200717fc82ed77892de5059fa44b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12659e10c78200717fc82ed77892de5059fa44b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12659e10c78200717fc82ed77892de5059fa44b5"}], "stats": {"total": 163, "additions": 120, "deletions": 43}, "files": [{"sha": "f91f6bebcb6f40b4e1c092858e492500167ff011", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ab7ccd216184853052cec1bce7900cbdeed0b4/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ab7ccd216184853052cec1bce7900cbdeed0b4/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a0ab7ccd216184853052cec1bce7900cbdeed0b4", "patch": "@@ -1,5 +1,13 @@\n 2017-08-29  Jason Merrill  <jason@redhat.com>\n \n+\t* constexpr.c (potential_constant_expression_1): Add \"now\" parm.\n+\t(is_constant_expression, require_constant_expression): New.\n+\t(is_static_init_expression, is_nondependent_constant_expression)\n+\t(is_nondependent_static_init_expression): Drop \"potential\".\n+\t* except.c (build_must_not_throw_expr): Do type conversion on\n+\tvalue-dependent argument.\n+\t* pt.c, semantics.c, typeck2.c: Use variants without \"potential\".\n+\n \tInstantiate default arguments/member initializers once.\n \t* init.c (get_nsdmi): Remember NSDMI instantiations.\n \t* parser.c (inject_this_parameter): Be more picky about"}, {"sha": "8cfc5a455c1958210e447dc1ff3430c10b85cd35", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 70, "deletions": 25, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ab7ccd216184853052cec1bce7900cbdeed0b4/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ab7ccd216184853052cec1bce7900cbdeed0b4/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=a0ab7ccd216184853052cec1bce7900cbdeed0b4", "patch": "@@ -1181,7 +1181,7 @@ cxx_eval_builtin_function_call (const constexpr_ctx *ctx, tree t, tree fun,\n       return t;\n     }\n \n-  if (!potential_constant_expression (new_call))\n+  if (!is_constant_expression (new_call))\n     {\n       if (!*non_constant_p && !ctx->quiet)\n \terror (\"%q+E is not a constant expression\", new_call);\n@@ -4861,7 +4861,7 @@ maybe_constant_value (tree t, tree decl)\n {\n   tree r;\n \n-  if (!potential_nondependent_constant_expression (t))\n+  if (!is_nondependent_constant_expression (t))\n     {\n       if (TREE_OVERFLOW_P (t))\n \t{\n@@ -4929,7 +4929,7 @@ fold_non_dependent_expr (tree t)\n      as two declarations of the same function, for example.  */\n   if (processing_template_decl)\n     {\n-      if (potential_nondependent_constant_expression (t))\n+      if (is_nondependent_constant_expression (t))\n \t{\n \t  processing_template_decl_sentinel s;\n \t  t = instantiate_non_dependent_expr_internal (t, tf_none);\n@@ -4982,7 +4982,7 @@ maybe_constant_init (tree t, tree decl)\n     t = TREE_OPERAND (t, 1);\n   if (TREE_CODE (t) == TARGET_EXPR)\n     t = TARGET_EXPR_INITIAL (t);\n-  if (!potential_nondependent_static_init_expression (t))\n+  if (!is_nondependent_static_init_expression (t))\n     /* Don't try to evaluate it.  */;\n   else if (CONSTANT_CLASS_P (t))\n     /* No evaluation needed.  */;\n@@ -5025,7 +5025,9 @@ check_automatic_or_tls (tree ref)\n \n /* Return true if T denotes a potentially constant expression.  Issue\n    diagnostic as appropriate under control of FLAGS.  If WANT_RVAL is true,\n-   an lvalue-rvalue conversion is implied.\n+   an lvalue-rvalue conversion is implied.  If NOW is true, we want to\n+   consider the expression in the current context, independent of constexpr\n+   substitution.\n \n    C++0x [expr.const] used to say\n \n@@ -5041,10 +5043,12 @@ check_automatic_or_tls (tree ref)\n       not evaluated are not considered.   */\n \n static bool\n-potential_constant_expression_1 (tree t, bool want_rval, bool strict,\n+potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n \t\t\t\t tsubst_flags_t flags)\n {\n-#define RECUR(T,RV) potential_constant_expression_1 ((T), (RV), strict, flags)\n+#define RECUR(T,RV) \\\n+  potential_constant_expression_1 ((T), (RV), strict, now, flags)\n+\n   enum { any = false, rval = true };\n   int i;\n   tree tmp;\n@@ -5087,7 +5091,6 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict,\n     case USERDEF_LITERAL:\n       /* We can see a FIELD_DECL in a pointer-to-member expression.  */\n     case FIELD_DECL:\n-    case PARM_DECL:\n     case RESULT_DECL:\n     case USING_DECL:\n     case USING_STMT:\n@@ -5098,6 +5101,15 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict,\n     case STATIC_ASSERT:\n       return true;\n \n+    case PARM_DECL:\n+      if (now)\n+\t{\n+\t  if (flags & tf_error)\n+\t    error (\"%qE is not a constant expression\", t);\n+\t  return false;\n+\t}\n+      return true;\n+\n     case AGGR_INIT_EXPR:\n     case CALL_EXPR:\n       /* -- an invocation of a function other than a constexpr function\n@@ -5173,7 +5185,11 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict,\n \t\t    tree x = get_nth_callarg (t, 0);\n \t\t    if (is_this_parameter (x))\n \t\t      return true;\n-\t\t    else if (!RECUR (x, rval))\n+\t\t    /* Don't require an immediately constant value, as\n+\t\t       constexpr substitution might not use the value.  */\n+\t\t    bool sub_now = false;\n+\t\t    if (!potential_constant_expression_1 (x, rval, strict,\n+\t\t\t\t\t\t\t  sub_now, flags))\n \t\t      return false;\n \t\t    i = 1;\n \t\t  }\n@@ -5203,7 +5219,11 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict,\n \t       REFERENCE_TYPE and we might not even know if the parameter\n \t       is a reference, so accept lvalue constants too.  */\n \t    bool rv = processing_template_decl ? any : rval;\n-\t    if (!RECUR (x, rv))\n+\t    /* Don't require an immediately constant value, as constexpr\n+\t       substitution might not use the value of the argument.  */\n+\t    bool sub_now = false;\n+\t    if (!potential_constant_expression_1 (x, rv, strict,\n+\t\t\t\t\t\t  sub_now, flags))\n \t      return false;\n           }\n         return true;\n@@ -5759,7 +5779,7 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict,\n \treturn RECUR (TREE_OPERAND (t, 1), want_rval);\n       for (i = 1; i < 3; ++i)\n \tif (potential_constant_expression_1 (TREE_OPERAND (t, i),\n-\t\t\t\t\t     want_rval, strict, tf_none))\n+\t\t\t\t\t     want_rval, strict, now, tf_none))\n \t  return true;\n       if (flags & tf_error)\n \terror_at (loc, \"expression %qE is not a constant expression\", t);\n@@ -5816,61 +5836,86 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict,\n bool\n potential_constant_expression (tree t)\n {\n-  return potential_constant_expression_1 (t, false, true, tf_none);\n-}\n-\n-bool\n-potential_static_init_expression (tree t)\n-{\n-  return potential_constant_expression_1 (t, false, false, tf_none);\n+  return potential_constant_expression_1 (t, false, true, false, tf_none);\n }\n \n /* As above, but require a constant rvalue.  */\n \n bool\n potential_rvalue_constant_expression (tree t)\n {\n-  return potential_constant_expression_1 (t, true, true, tf_none);\n+  return potential_constant_expression_1 (t, true, true, false, tf_none);\n }\n \n /* Like above, but complain about non-constant expressions.  */\n \n bool\n require_potential_constant_expression (tree t)\n {\n-  return potential_constant_expression_1 (t, false, true, tf_warning_or_error);\n+  return potential_constant_expression_1 (t, false, true, false, tf_warning_or_error);\n }\n \n /* Cross product of the above.  */\n \n bool\n require_potential_rvalue_constant_expression (tree t)\n {\n-  return potential_constant_expression_1 (t, true, true, tf_warning_or_error);\n+  return potential_constant_expression_1 (t, true, true, false, tf_warning_or_error);\n+}\n+\n+/* Like potential_constant_expression, but don't consider possible constexpr\n+   substitution of the current function.  That is, PARM_DECL qualifies under\n+   potential_constant_expression, but not here.\n+\n+   This is basically what you can check when any actual constant values might\n+   be value-dependent.  */\n+\n+bool\n+is_constant_expression (tree t)\n+{\n+  return potential_constant_expression_1 (t, false, true, true, tf_none);\n+}\n+\n+/* Like above, but complain about non-constant expressions.  */\n+\n+bool\n+require_constant_expression (tree t)\n+{\n+  return potential_constant_expression_1 (t, false, true, true,\n+\t\t\t\t\t  tf_warning_or_error);\n+}\n+\n+/* Like is_constant_expression, but allow const variables that are not allowed\n+   under constexpr rules.  */\n+\n+bool\n+is_static_init_expression (tree t)\n+{\n+  return potential_constant_expression_1 (t, false, false, true, tf_none);\n }\n \n /* Returns true if T is a potential constant expression that is not\n    instantiation-dependent, and therefore a candidate for constant folding even\n    in a template.  */\n \n bool\n-potential_nondependent_constant_expression (tree t)\n+is_nondependent_constant_expression (tree t)\n {\n   return (!type_unknown_p (t)\n \t  && !BRACE_ENCLOSED_INITIALIZER_P (t)\n-\t  && potential_constant_expression (t)\n+\t  && is_constant_expression (t)\n \t  && !instantiation_dependent_expression_p (t));\n }\n \n /* Returns true if T is a potential static initializer expression that is not\n    instantiation-dependent.  */\n \n bool\n-potential_nondependent_static_init_expression (tree t)\n+is_nondependent_static_init_expression (tree t)\n {\n   return (!type_unknown_p (t)\n \t  && !BRACE_ENCLOSED_INITIALIZER_P (t)\n-\t  && potential_static_init_expression (t)\n+\t  && is_static_init_expression (t)\n \t  && !instantiation_dependent_expression_p (t));\n }\n "}, {"sha": "f0eafb3c27705c6ac1a4b700826b5070f3c4b764", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ab7ccd216184853052cec1bce7900cbdeed0b4/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ab7ccd216184853052cec1bce7900cbdeed0b4/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=a0ab7ccd216184853052cec1bce7900cbdeed0b4", "patch": "@@ -7325,11 +7325,13 @@ extern bool is_valid_constexpr_fn\t\t(tree, bool);\n extern bool check_constexpr_ctor_body           (tree, tree, bool);\n extern tree ensure_literal_type_for_constexpr_object (tree);\n extern bool potential_constant_expression       (tree);\n-extern bool potential_nondependent_constant_expression (tree);\n-extern bool potential_nondependent_static_init_expression (tree);\n-extern bool potential_static_init_expression    (tree);\n+extern bool is_constant_expression (tree);\n+extern bool is_nondependent_constant_expression (tree);\n+extern bool is_nondependent_static_init_expression (tree);\n+extern bool is_static_init_expression    (tree);\n extern bool potential_rvalue_constant_expression (tree);\n extern bool require_potential_constant_expression (tree);\n+extern bool require_constant_expression (tree);\n extern bool require_potential_rvalue_constant_expression (tree);\n extern tree cxx_constant_value\t\t\t(tree, tree = NULL_TREE);\n extern tree maybe_constant_value\t\t(tree, tree = NULL_TREE);"}, {"sha": "2ee7e97ea2315f0a6ea8bcb0bf31f180021fc472", "filename": "gcc/cp/except.c", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ab7ccd216184853052cec1bce7900cbdeed0b4/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ab7ccd216184853052cec1bce7900cbdeed0b4/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=a0ab7ccd216184853052cec1bce7900cbdeed0b4", "patch": "@@ -261,13 +261,19 @@ build_must_not_throw_expr (tree body, tree cond)\n   if (!flag_exceptions)\n     return body;\n \n-  if (cond && !value_dependent_expression_p (cond))\n+  if (!cond)\n+    /* OK, unconditional.  */;\n+  else\n     {\n-      cond = perform_implicit_conversion_flags (boolean_type_node, cond,\n-\t\t\t\t\t\ttf_warning_or_error,\n-\t\t\t\t\t\tLOOKUP_NORMAL);\n-      cond = instantiate_non_dependent_expr (cond);\n-      cond = cxx_constant_value (cond);\n+      tree conv = NULL_TREE;\n+      if (!type_dependent_expression_p (cond))\n+\tconv = perform_implicit_conversion_flags (boolean_type_node, cond,\n+\t\t\t\t\t\t  tf_warning_or_error,\n+\t\t\t\t\t\t  LOOKUP_NORMAL);\n+      if (tree inst = instantiate_non_dependent_or_null (conv))\n+\tcond = cxx_constant_value (inst);\n+      else\n+\trequire_constant_expression (cond);\n       if (integer_zerop (cond))\n \treturn body;\n       else if (integer_onep (cond))"}, {"sha": "e34fe21cb1592b8fcc8ef469b26b04713f9ac9dd", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ab7ccd216184853052cec1bce7900cbdeed0b4/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ab7ccd216184853052cec1bce7900cbdeed0b4/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=a0ab7ccd216184853052cec1bce7900cbdeed0b4", "patch": "@@ -5827,7 +5827,7 @@ instantiate_non_dependent_expr_sfinae (tree expr, tsubst_flags_t complain)\n \n      as two declarations of the same function, for example.  */\n   if (processing_template_decl\n-      && potential_nondependent_constant_expression (expr))\n+      && is_nondependent_constant_expression (expr))\n     {\n       processing_template_decl_sentinel s;\n       expr = instantiate_non_dependent_expr_internal (expr, complain);\n@@ -5851,7 +5851,7 @@ instantiate_non_dependent_or_null (tree expr)\n     return NULL_TREE;\n   if (processing_template_decl)\n     {\n-      if (!potential_nondependent_constant_expression (expr))\n+      if (!is_nondependent_constant_expression (expr))\n \texpr = NULL_TREE;\n       else\n \t{\n@@ -6437,15 +6437,11 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n       && has_value_dependent_address (expr))\n     /* If we want the address and it's value-dependent, don't fold.  */;\n   else if (processing_template_decl\n-\t   && potential_nondependent_constant_expression (expr))\n+\t   && is_nondependent_constant_expression (expr))\n     non_dep = true;\n   if (error_operand_p (expr))\n     return error_mark_node;\n   expr_type = TREE_TYPE (expr);\n-  if (TREE_CODE (type) == REFERENCE_TYPE)\n-    expr = mark_lvalue_use (expr);\n-  else\n-    expr = mark_rvalue_use (expr);\n \n   /* If the argument is non-dependent, perform any conversions in\n      non-dependent context as well.  */\n@@ -6493,6 +6489,11 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n \t}\n     }\n \n+  if (TREE_CODE (type) == REFERENCE_TYPE)\n+    expr = mark_lvalue_use (expr);\n+  else\n+    expr = mark_rvalue_use (expr);\n+\n   /* HACK: Due to double coercion, we can get a\n      NOP_EXPR<REFERENCE_TYPE>(ADDR_EXPR<POINTER_TYPE> (arg)) here,\n      which is the tree that we built on the first call (see"}, {"sha": "86ce9ce9461d26d9f940c38016b455ef8642799e", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ab7ccd216184853052cec1bce7900cbdeed0b4/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ab7ccd216184853052cec1bce7900cbdeed0b4/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=a0ab7ccd216184853052cec1bce7900cbdeed0b4", "patch": "@@ -735,7 +735,7 @@ finish_if_stmt_cond (tree cond, tree if_stmt)\n {\n   cond = maybe_convert_cond (cond);\n   if (IF_STMT_CONSTEXPR_P (if_stmt)\n-      && require_potential_rvalue_constant_expression (cond)\n+      && is_constant_expression (cond)\n       && !value_dependent_expression_p (cond))\n     {\n       cond = instantiate_non_dependent_expr (cond);"}, {"sha": "e9aca395911dc1145b17a0ce71dd3af2d33bfb82", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ab7ccd216184853052cec1bce7900cbdeed0b4/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ab7ccd216184853052cec1bce7900cbdeed0b4/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=a0ab7ccd216184853052cec1bce7900cbdeed0b4", "patch": "@@ -821,7 +821,7 @@ store_init_value (tree decl, tree init, vec<tree, va_gc>** cleanups, int flags)\n \t  || (DECL_IN_AGGR_P (decl) && !DECL_VAR_DECLARED_INLINE_P (decl)))\n \t{\n \t  /* Diagnose a non-constant initializer for constexpr.  */\n-\t  if (!require_potential_constant_expression (value))\n+\t  if (!require_constant_expression (value))\n \t    value = error_mark_node;\n \t  else\n \t    value = cxx_constant_value (value, decl);"}, {"sha": "c64fb3d2fa0c2b63598d3e4caec781ec5fef86c7", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-conv2.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ab7ccd216184853052cec1bce7900cbdeed0b4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-conv2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ab7ccd216184853052cec1bce7900cbdeed0b4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-conv2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-conv2.C?ref=a0ab7ccd216184853052cec1bce7900cbdeed0b4", "patch": "@@ -0,0 +1,15 @@\n+// { dg-do compile { target c++11 } }\n+\n+template <int I> void f();\n+\n+struct A { constexpr operator int() { return 24; } };\n+\n+template <class T> constexpr void g(T t)\n+{\n+  f<t>();\n+}\n+\n+int main()\n+{\n+  g(A());\n+}"}]}