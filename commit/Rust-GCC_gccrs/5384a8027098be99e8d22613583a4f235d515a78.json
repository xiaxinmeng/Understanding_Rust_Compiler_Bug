{"sha": "5384a8027098be99e8d22613583a4f235d515a78", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTM4NGE4MDI3MDk4YmU5OWU4ZDIyNjEzNTgzYTRmMjM1ZDUxNWE3OA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2019-11-08T10:53:50Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-11-08T10:53:50Z"}, "message": "re PR target/92038 (Extremely inefficient x86_64 code for trivally copyable types passed in registers.)\n\n\tPR target/92038\n\t* gimple-ssa-store-merging.c (find_constituent_stores): For return\n\tvalue only, return non-NULL if there is a single non-clobber\n\tconstituent store even if there are constituent clobbers and return\n\tone of clobber constituent stores if all constituent stores are\n\tclobbers.\n\t(split_group): Handle clobbers.\n\t(imm_store_chain_info::output_merged_store): When computing\n\tbzero_first, look after all clobbers at the start.  Don't count\n\tclobber stmts in orig_num_stmts, except if the first orig store is\n\ta clobber covering the whole area and split_stores cover the whole\n\tarea, consider equal number of stmts ok.  Punt if split_stores\n\tcontains only ->orig stores and their number plus number of original\n\tclobbers is equal to original number of stmts.  For ->orig, look past\n\tclobbers in the constituent stores.\n\t(imm_store_chain_info::output_merged_stores): Don't remove clobber\n\tstmts.\n\t(rhs_valid_for_store_merging_p): Don't return false for clobber stmt\n\trhs.\n\t(store_valid_for_store_merging_p): Allow clobber stmts.\n\t(verify_clear_bit_region_be): Fix up a thinko in function comment.\n\n\t* g++.dg/opt/store-merging-1.C: New test.\n\t* g++.dg/opt/store-merging-2.C: New test.\n\t* g++.dg/opt/store-merging-3.C: New test.\n\nFrom-SVN: r277963", "tree": {"sha": "3da30d6c2947039f7b36622f564967a6ce69a57c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3da30d6c2947039f7b36622f564967a6ce69a57c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5384a8027098be99e8d22613583a4f235d515a78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5384a8027098be99e8d22613583a4f235d515a78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5384a8027098be99e8d22613583a4f235d515a78", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5384a8027098be99e8d22613583a4f235d515a78/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "aea86742ce3963750a6becb4b45d3dd2fa11ecc4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aea86742ce3963750a6becb4b45d3dd2fa11ecc4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aea86742ce3963750a6becb4b45d3dd2fa11ecc4"}], "stats": {"total": 246, "additions": 219, "deletions": 27}, "files": [{"sha": "277c21c9e831d4055da2ca9aaae8b7541143b336", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5384a8027098be99e8d22613583a4f235d515a78/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5384a8027098be99e8d22613583a4f235d515a78/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5384a8027098be99e8d22613583a4f235d515a78", "patch": "@@ -1,5 +1,27 @@\n 2019-11-08  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR target/92038\n+\t* gimple-ssa-store-merging.c (find_constituent_stores): For return\n+\tvalue only, return non-NULL if there is a single non-clobber\n+\tconstituent store even if there are constituent clobbers and return\n+\tone of clobber constituent stores if all constituent stores are\n+\tclobbers.\n+\t(split_group): Handle clobbers.\n+\t(imm_store_chain_info::output_merged_store): When computing\n+\tbzero_first, look after all clobbers at the start.  Don't count\n+\tclobber stmts in orig_num_stmts, except if the first orig store is\n+\ta clobber covering the whole area and split_stores cover the whole\n+\tarea, consider equal number of stmts ok.  Punt if split_stores\n+\tcontains only ->orig stores and their number plus number of original\n+\tclobbers is equal to original number of stmts.  For ->orig, look past\n+\tclobbers in the constituent stores.\n+\t(imm_store_chain_info::output_merged_stores): Don't remove clobber\n+\tstmts.\n+\t(rhs_valid_for_store_merging_p): Don't return false for clobber stmt\n+\trhs.\n+\t(store_valid_for_store_merging_p): Allow clobber stmts.\n+\t(verify_clear_bit_region_be): Fix up a thinko in function comment.\n+\n \tPR c++/92384\n \t* function.c (assign_parm_setup_block, assign_parm_setup_stack): Don't\n \tcopy TYPE_EMPTY_P arguments from data->entry_parm to data->stack_parm"}, {"sha": "c6dbac268c8d97b8a73bb01ef039df935031ed8e", "filename": "gcc/gimple-ssa-store-merging.c", "status": "modified", "additions": 165, "deletions": 27, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5384a8027098be99e8d22613583a4f235d515a78/gcc%2Fgimple-ssa-store-merging.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5384a8027098be99e8d22613583a4f235d515a78/gcc%2Fgimple-ssa-store-merging.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-store-merging.c?ref=5384a8027098be99e8d22613583a4f235d515a78", "patch": "@@ -3110,7 +3110,8 @@ split_store::split_store (unsigned HOST_WIDE_INT bp,\n /* Record all stores in GROUP that write to the region starting at BITPOS and\n    is of size BITSIZE.  Record infos for such statements in STORES if\n    non-NULL.  The stores in GROUP must be sorted by bitposition.  Return INFO\n-   if there is exactly one original store in the range.  */\n+   if there is exactly one original store in the range (in that case ignore\n+   clobber stmts, unless there are only clobber stmts).  */\n \n static store_immediate_info *\n find_constituent_stores (class merged_store_group *group,\n@@ -3146,16 +3147,24 @@ find_constituent_stores (class merged_store_group *group,\n       if (stmt_start >= end)\n \treturn ret;\n \n+      if (gimple_clobber_p (info->stmt))\n+\t{\n+\t  if (stores)\n+\t    stores->safe_push (info);\n+\t  if (ret == NULL)\n+\t    ret = info;\n+\t  continue;\n+\t}\n       if (stores)\n \t{\n \t  stores->safe_push (info);\n-\t  if (ret)\n+\t  if (ret && !gimple_clobber_p (ret->stmt))\n \t    {\n \t      ret = NULL;\n \t      second = true;\n \t    }\n \t}\n-      else if (ret)\n+      else if (ret && !gimple_clobber_p (ret->stmt))\n \treturn NULL;\n       if (!second)\n \tret = info;\n@@ -3347,13 +3356,17 @@ split_group (merged_store_group *group, bool allow_unaligned_store,\n \n   if (bzero_first)\n     {\n-      first = 1;\n+      store_immediate_info *gstore;\n+      FOR_EACH_VEC_ELT (group->stores, first, gstore)\n+\tif (!gimple_clobber_p (gstore->stmt))\n+\t  break;\n+      ++first;\n       ret = 1;\n       if (split_stores)\n \t{\n \t  split_store *store\n-\t    = new split_store (bytepos, group->stores[0]->bitsize, align_base);\n-\t  store->orig_stores.safe_push (group->stores[0]);\n+\t    = new split_store (bytepos, gstore->bitsize, align_base);\n+\t  store->orig_stores.safe_push (gstore);\n \t  store->orig = true;\n \t  any_orig = true;\n \t  split_stores->safe_push (store);\n@@ -3377,6 +3390,7 @@ split_group (merged_store_group *group, bool allow_unaligned_store,\n       unsigned HOST_WIDE_INT align_bitpos\n \t= (try_bitpos - align_base) & (group_align - 1);\n       unsigned HOST_WIDE_INT align = group_align;\n+      bool found_orig = false;\n       if (align_bitpos)\n \talign = least_bit_hwi (align_bitpos);\n       if (!allow_unaligned_store)\n@@ -3408,7 +3422,7 @@ split_group (merged_store_group *group, bool allow_unaligned_store,\n \t}\n       store_immediate_info *info\n \t= find_constituent_stores (group, NULL, &first, try_bitpos, try_size);\n-      if (info)\n+      if (info && !gimple_clobber_p (info->stmt))\n \t{\n \t  /* If there is just one original statement for the range, see if\n \t     we can just reuse the original store which could be even larger\n@@ -3419,8 +3433,30 @@ split_group (merged_store_group *group, bool allow_unaligned_store,\n \t\t\t\t\t  stmt_end - try_bitpos);\n \t  if (info && info->bitpos >= try_bitpos)\n \t    {\n-\t      try_size = stmt_end - try_bitpos;\n-\t      goto found;\n+\t      store_immediate_info *info2 = NULL;\n+\t      unsigned int first_copy = first;\n+\t      if (info->bitpos > try_bitpos\n+\t\t  && stmt_end - try_bitpos <= try_size)\n+\t\t{\n+\t\t  info2 = find_constituent_stores (group, NULL, &first_copy,\n+\t\t\t\t\t\t   try_bitpos,\n+\t\t\t\t\t\t   info->bitpos - try_bitpos);\n+\t\t  gcc_assert (info2 == NULL || gimple_clobber_p (info2->stmt));\n+\t\t}\n+\t      if (info2 == NULL && stmt_end - try_bitpos < try_size)\n+\t\t{\n+\t\t  info2 = find_constituent_stores (group, NULL, &first_copy,\n+\t\t\t\t\t\t   stmt_end,\n+\t\t\t\t\t\t   (try_bitpos + try_size)\n+\t\t\t\t\t\t   - stmt_end);\n+\t\t  gcc_assert (info2 == NULL || gimple_clobber_p (info2->stmt));\n+\t\t}\n+\t      if (info2 == NULL)\n+\t\t{\n+\t\t  try_size = stmt_end - try_bitpos;\n+\t\t  found_orig = true;\n+\t\t  goto found;\n+\t\t}\n \t    }\n \t}\n \n@@ -3435,7 +3471,7 @@ split_group (merged_store_group *group, bool allow_unaligned_store,\n \t    && (!bzero_first\n \t\t|| group->val[try_pos - bytepos + nonmasked - 1] != 0))\n \t  break;\n-      if (nonmasked == 0)\n+      if (nonmasked == 0 || (info && gimple_clobber_p (info->stmt)))\n \t{\n \t  /* If entire try_size range is padding, skip it.  */\n \t  try_pos += try_size / BITS_PER_UNIT;\n@@ -3483,8 +3519,14 @@ split_group (merged_store_group *group, bool allow_unaligned_store,\n \t  info = find_constituent_stores (group, &store->orig_stores,\n \t\t\t\t\t  &first, try_bitpos, try_size);\n \t  if (info\n+\t      && !gimple_clobber_p (info->stmt)\n \t      && info->bitpos >= try_bitpos\n-\t      && info->bitpos + info->bitsize <= try_bitpos + try_size)\n+\t      && info->bitpos + info->bitsize <= try_bitpos + try_size\n+\t      && (store->orig_stores.length () == 1\n+\t\t  || found_orig\n+\t\t  || (info->bitpos == try_bitpos\n+\t\t      && (info->bitpos + info->bitsize\n+\t\t\t  == try_bitpos + try_size))))\n \t    {\n \t      store->orig = true;\n \t      any_orig = true;\n@@ -3671,14 +3713,32 @@ imm_store_chain_info::output_merged_store (merged_store_group *group)\n     = !STRICT_ALIGNMENT && PARAM_VALUE (PARAM_STORE_MERGING_ALLOW_UNALIGNED);\n   bool allow_unaligned_load = allow_unaligned_store;\n   bool bzero_first = false;\n-  if (group->stores[0]->rhs_code == INTEGER_CST\n-      && TREE_CODE (gimple_assign_rhs1 (group->stores[0]->stmt)) == CONSTRUCTOR\n-      && CONSTRUCTOR_NELTS (gimple_assign_rhs1 (group->stores[0]->stmt)) == 0\n-      && group->start == group->stores[0]->bitpos\n-      && group->width == group->stores[0]->bitsize\n-      && (group->start % BITS_PER_UNIT) == 0\n-      && (group->width % BITS_PER_UNIT) == 0)\n-    bzero_first = true;\n+  store_immediate_info *store;\n+  unsigned int num_clobber_stmts = 0;\n+  if (group->stores[0]->rhs_code == INTEGER_CST)\n+    {\n+      FOR_EACH_VEC_ELT (group->stores, i, store)\n+\tif (gimple_clobber_p (store->stmt))\n+\t  num_clobber_stmts++;\n+\telse if (TREE_CODE (gimple_assign_rhs1 (store->stmt)) == CONSTRUCTOR\n+\t\t && CONSTRUCTOR_NELTS (gimple_assign_rhs1 (store->stmt)) == 0\n+\t\t && group->start == store->bitpos\n+\t\t && group->width == store->bitsize\n+\t\t && (group->start % BITS_PER_UNIT) == 0\n+\t\t && (group->width % BITS_PER_UNIT) == 0)\n+\t  {\n+\t    bzero_first = true;\n+\t    break;\n+\t  }\n+\telse\n+\t  break;\n+      FOR_EACH_VEC_ELT_FROM (group->stores, i, store, i)\n+\tif (gimple_clobber_p (store->stmt))\n+\t  num_clobber_stmts++;\n+      if (num_clobber_stmts == orig_num_stmts)\n+\treturn false;\n+      orig_num_stmts -= num_clobber_stmts;\n+    }\n   if (allow_unaligned_store || bzero_first)\n     {\n       /* If unaligned stores are allowed, see how many stores we'd emit\n@@ -3710,8 +3770,35 @@ imm_store_chain_info::output_merged_store (merged_store_group *group)\n   split_group (group, allow_unaligned_store, allow_unaligned_load, bzero_first,\n \t       &split_stores, &total_orig, &total_new);\n \n-  if (split_stores.length () >= orig_num_stmts)\n+  /* Determine if there is a clobber covering the whole group at the start,\n+     followed by proposed split stores that cover the whole group.  In that\n+     case, prefer the transformation even if\n+     split_stores.length () == orig_num_stmts.  */\n+  bool clobber_first = false;\n+  if (num_clobber_stmts\n+      && gimple_clobber_p (group->stores[0]->stmt)\n+      && group->start == group->stores[0]->bitpos\n+      && group->width == group->stores[0]->bitsize\n+      && (group->start % BITS_PER_UNIT) == 0\n+      && (group->width % BITS_PER_UNIT) == 0)\n+    {\n+      clobber_first = true;\n+      unsigned HOST_WIDE_INT pos = group->start / BITS_PER_UNIT;\n+      FOR_EACH_VEC_ELT (split_stores, i, split_store)      \n+\tif (split_store->bytepos != pos)\n+\t  {\n+\t    clobber_first = false;\n+\t    break;\n+\t  }\n+\telse\n+\t  pos += split_store->size / BITS_PER_UNIT;\n+      if (pos != (group->start + group->width) / BITS_PER_UNIT)\n+\tclobber_first = false;\n+    }\n+\n+  if (split_stores.length () >= orig_num_stmts + clobber_first)\n     {\n+\n       /* We didn't manage to reduce the number of statements.  Bail out.  */\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"Exceeded original number of stmts (%u).\"\n@@ -3734,6 +3821,36 @@ imm_store_chain_info::output_merged_store (merged_store_group *group)\n \tdelete split_store;\n       return false;\n     }\n+  if (group->stores[0]->rhs_code == INTEGER_CST)\n+    {\n+      bool all_orig = true;\n+      FOR_EACH_VEC_ELT (split_stores, i, split_store)\n+\tif (!split_store->orig)\n+\t  {\n+\t    all_orig = false;\n+\t    break;\n+\t  }\n+      if (all_orig)\n+\t{\n+\t  unsigned int cnt = split_stores.length ();\n+\t  store_immediate_info *store;\n+\t  FOR_EACH_VEC_ELT (group->stores, i, store)\n+\t    if (gimple_clobber_p (store->stmt))\n+\t      ++cnt;\n+\t  /* Punt if we wouldn't make any real changes, i.e. keep all\n+\t     orig stmts + all clobbers.  */\n+\t  if (cnt == group->stores.length ())\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file, \"Exceeded original number of stmts (%u).\"\n+\t\t\t\t    \"  Not profitable to emit new sequence.\\n\",\n+\t\t\t orig_num_stmts);\n+\t      FOR_EACH_VEC_ELT (split_stores, i, split_store)\n+\t\tdelete split_store;\n+\t      return false;\n+\t    }\n+\t}\n+    }\n \n   gimple_stmt_iterator last_gsi = gsi_for_stmt (group->last_stmt);\n   gimple_seq seq = NULL;\n@@ -3742,6 +3859,13 @@ imm_store_chain_info::output_merged_store (merged_store_group *group)\n   new_vuse = gimple_vuse (group->last_stmt);\n   tree bswap_res = NULL_TREE;\n \n+  /* Clobbers are not removed.  */\n+  if (gimple_clobber_p (group->last_stmt))\n+    {\n+      new_vuse = make_ssa_name (gimple_vop (cfun), group->last_stmt);\n+      gimple_set_vdef (group->last_stmt, new_vuse);\n+    }\n+\n   if (group->stores[0]->rhs_code == LROTATE_EXPR\n       || group->stores[0]->rhs_code == NOP_EXPR)\n     {\n@@ -3865,9 +3989,17 @@ imm_store_chain_info::output_merged_store (merged_store_group *group)\n       location_t loc;\n       if (split_store->orig)\n \t{\n-\t  /* If there is just a single constituent store which covers\n-\t     the whole area, just reuse the lhs and rhs.  */\n-\t  gimple *orig_stmt = split_store->orig_stores[0]->stmt;\n+\t  /* If there is just a single non-clobber constituent store\n+\t     which covers the whole area, just reuse the lhs and rhs.  */\n+\t  gimple *orig_stmt = NULL;\n+\t  store_immediate_info *store;\n+\t  unsigned int j;\n+\t  FOR_EACH_VEC_ELT (split_store->orig_stores, j, store)\n+\t    if (!gimple_clobber_p (store->stmt))\n+\t      {\n+\t\torig_stmt = store->stmt;\n+\t\tbreak;\n+\t      }\n \t  dest = gimple_assign_lhs (orig_stmt);\n \t  src = gimple_assign_rhs1 (orig_stmt);\n \t  loc = gimple_location (orig_stmt);\n@@ -4194,6 +4326,9 @@ imm_store_chain_info::output_merged_store (merged_store_group *group)\n \tprint_gimple_seq (dump_file, seq, 0, TDF_VOPS | TDF_MEMSYMS);\n     }\n \n+  if (gimple_clobber_p (group->last_stmt))\n+    update_stmt (group->last_stmt);\n+\n   if (group->lp_nr > 0)\n     {\n       /* We're going to insert a sequence of (potentially) throwing stores\n@@ -4279,6 +4414,10 @@ imm_store_chain_info::output_merged_stores ()\n \t    {\n \t      gimple *stmt = store->stmt;\n \t      gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n+\t      /* Don't remove clobbers, they are still useful even if\n+\t\t everything is overwritten afterwards.  */\n+\t      if (gimple_clobber_p (stmt))\n+\t\tcontinue;\n \t      gsi_remove (&gsi, true);\n \t      if (store->lp_nr)\n \t\tremove_stmt_from_eh_lp (stmt);\n@@ -4361,7 +4500,6 @@ rhs_valid_for_store_merging_p (tree rhs)\n {\n   unsigned HOST_WIDE_INT size;\n   if (TREE_CODE (rhs) == CONSTRUCTOR\n-      && !TREE_CLOBBER_P (rhs)\n       && CONSTRUCTOR_NELTS (rhs) == 0\n       && TYPE_SIZE_UNIT (TREE_TYPE (rhs))\n       && tree_fits_uhwi_p (TYPE_SIZE_UNIT (TREE_TYPE (rhs))))\n@@ -4794,7 +4932,7 @@ store_valid_for_store_merging_p (gimple *stmt)\n   return gimple_assign_single_p (stmt)\n \t && gimple_vdef (stmt)\n \t && lhs_valid_for_store_merging_p (gimple_assign_lhs (stmt))\n-\t && !gimple_has_volatile_ops (stmt);\n+\t && (!gimple_has_volatile_ops (stmt) || gimple_clobber_p (stmt));\n }\n \n enum basic_block_status { BB_INVALID, BB_VALID, BB_EXTENDED_VALID };\n@@ -4875,7 +5013,7 @@ pass_store_merging::execute (function *fun)\n \t  if (is_gimple_debug (stmt))\n \t    continue;\n \n-\t  if (gimple_has_volatile_ops (stmt))\n+\t  if (gimple_has_volatile_ops (stmt) && !gimple_clobber_p (stmt))\n \t    {\n \t      /* Terminate all chains.  */\n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -5022,7 +5160,7 @@ verify_clear_bit_region (void)\n   verify_array_eq (in, expected, sizeof in);\n }\n \n-/* Test verify_clear_bit_region_be that it clears exactly the bits asked and\n+/* Test clear_bit_region_be that it clears exactly the bits asked and\n    nothing more.  */\n \n static void"}, {"sha": "9ab6b0de4dc4acf40f730d7f3b680b292a26db46", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5384a8027098be99e8d22613583a4f235d515a78/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5384a8027098be99e8d22613583a4f235d515a78/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5384a8027098be99e8d22613583a4f235d515a78", "patch": "@@ -1,5 +1,10 @@\n 2019-11-08  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR target/92038\n+\t* g++.dg/opt/store-merging-1.C: New test.\n+\t* g++.dg/opt/store-merging-2.C: New test.\n+\t* g++.dg/opt/store-merging-3.C: New test.\n+\n \tPR c++/92384\n \t* g++.dg/torture/pr92384.C: New test.\n "}, {"sha": "c7f294ec386c9f2d9664c5be799a1d803e1153c7", "filename": "gcc/testsuite/g++.dg/opt/store-merging-1.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5384a8027098be99e8d22613583a4f235d515a78/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fstore-merging-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5384a8027098be99e8d22613583a4f235d515a78/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fstore-merging-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fstore-merging-1.C?ref=5384a8027098be99e8d22613583a4f235d515a78", "patch": "@@ -0,0 +1,9 @@\n+// PR target/92038\n+// { dg-do compile { target int32 } }\n+// { dg-require-effective-target store_merge }\n+// { dg-options \"-O2 -flifetime-dse=2 -fdump-tree-store-merging-details\" }\n+// { dg-final { scan-tree-dump \"New sequence of \\[12] stores to replace old one of 2 stores\" \"store-merging\" } }\n+\n+struct S { S () : a (0), b (0) {} int a; char b; char c[3]; };\n+void foo (struct S);\n+void bar (void) { struct S s; foo (s); }"}, {"sha": "3c17033764b75608dd9e609d2f776f6f7bf8cd4e", "filename": "gcc/testsuite/g++.dg/opt/store-merging-2.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5384a8027098be99e8d22613583a4f235d515a78/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fstore-merging-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5384a8027098be99e8d22613583a4f235d515a78/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fstore-merging-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fstore-merging-2.C?ref=5384a8027098be99e8d22613583a4f235d515a78", "patch": "@@ -0,0 +1,10 @@\n+// PR target/92038\n+// { dg-do compile { target int32 } }\n+// { dg-require-effective-target store_merge }\n+// { dg-options \"-O2 -flifetime-dse=2 -fdump-tree-store-merging-details\" }\n+// { dg-final { scan-tree-dump \"New sequence of 2 stores to replace old one of 3 stores\" \"store-merging\" } }\n+\n+struct T { char a[128]; };\n+struct S { S () : a () { a.a[12] = 0; a.a[13] = 1; a.a[14] = 0; a.a[15] = 6; } T a; };\n+void foo (S &);\n+void bar (void) { S s; foo (s); }"}, {"sha": "e3c72ab7407398a915010b84180737d19f301c2a", "filename": "gcc/testsuite/g++.dg/opt/store-merging-3.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5384a8027098be99e8d22613583a4f235d515a78/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fstore-merging-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5384a8027098be99e8d22613583a4f235d515a78/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fstore-merging-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fstore-merging-3.C?ref=5384a8027098be99e8d22613583a4f235d515a78", "patch": "@@ -0,0 +1,8 @@\n+// PR target/92038\n+// { dg-do compile }\n+// { dg-options \"-O2 -flifetime-dse=2\" }\n+\n+struct A { A (int); int a; };\n+struct B { B () : b(0) {} A b; };\n+struct C { C () : c () {} bool c; B d; };\n+void foo () { C d; }"}]}