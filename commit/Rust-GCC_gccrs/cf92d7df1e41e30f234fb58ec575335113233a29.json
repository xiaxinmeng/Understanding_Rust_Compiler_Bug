{"sha": "cf92d7df1e41e30f234fb58ec575335113233a29", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2Y5MmQ3ZGYxZTQxZTMwZjIzNGZiNThlYzU3NTMzNTExMzIzM2EyOQ==", "commit": {"author": {"name": "Michael Hayes", "email": "m.hayes@elec.canterbury.ac.nz", "date": "2000-03-23T22:15:46Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "2000-03-23T22:15:46Z"}, "message": "Clobber DP reg in case address needs to be loaded out of memory.\n\n\t* config/c4x/c4x.md (load_immed_address):  Add DP reg clobber.\n\nFrom-SVN: r32717", "tree": {"sha": "57cfcca15c8ea370dacd238a58b8eeb4849165aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57cfcca15c8ea370dacd238a58b8eeb4849165aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf92d7df1e41e30f234fb58ec575335113233a29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf92d7df1e41e30f234fb58ec575335113233a29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf92d7df1e41e30f234fb58ec575335113233a29", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf92d7df1e41e30f234fb58ec575335113233a29/comments", "author": null, "committer": null, "parents": [{"sha": "25a1fcb433c7e1aef52102292a77483753418e32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25a1fcb433c7e1aef52102292a77483753418e32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25a1fcb433c7e1aef52102292a77483753418e32"}], "stats": {"total": 38, "additions": 29, "deletions": 9}, "files": [{"sha": "d4128b0c5842ea38b601e2cc565e992911d3fb48", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf92d7df1e41e30f234fb58ec575335113233a29/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf92d7df1e41e30f234fb58ec575335113233a29/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cf92d7df1e41e30f234fb58ec575335113233a29", "patch": "@@ -1,3 +1,7 @@\n+2000-03-24  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n+\n+\t* config/c4x/c4x.md (load_immed_address):  Add DP reg clobber.\n+\n Thu Mar 23 17:10:48 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* calls.c (expand_call): If TARGET is passed by reference and"}, {"sha": "89fe2d0bb169a3c63d11a73291f9ac260924007e", "filename": "gcc/config/c4x/c4x.md", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf92d7df1e41e30f234fb58ec575335113233a29/gcc%2Fconfig%2Fc4x%2Fc4x.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf92d7df1e41e30f234fb58ec575335113233a29/gcc%2Fconfig%2Fc4x%2Fc4x.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.md?ref=cf92d7df1e41e30f234fb58ec575335113233a29", "patch": "@@ -1245,13 +1245,35 @@\n    operands[5] = c4x_operand_subword (operands[1], 1, 1, HImode);\n }\")\n \n+\n+; We need to clobber the DP reg to be safe in case we\n+; need to load this address from memory\n+(define_insn \"load_immed_address\"\n+  [(set (match_operand:QI 0 \"reg_operand\" \"=a?x?c*r\")\n+        (match_operand:QI 1 \"symbolic_address_operand\" \"\"))\n+   (clobber (reg:QI 16))]\n+  \"TARGET_LOAD_ADDRESS\"\n+  \"#\"\n+  [(set_attr \"type\" \"multi\")])\n+\n+\n+(define_split\n+  [(set (match_operand:QI 0 \"std_reg_operand\" \"\")\n+        (match_operand:QI 1 \"symbolic_address_operand\" \"\"))\n+   (clobber (reg:QI 16))]\n+  \"! TARGET_C3X && ! TARGET_TI\"\n+  [(set (match_dup 0) (high:QI (match_dup 1)))\n+   (set (match_dup 0) (lo_sum:QI (match_dup 0) (match_dup 1)))]\n+  \"\")\n+\n ; CC has been selected to load a symbolic address.  We force the address\n ; into memory and then generate LDP and LDIU insns.\n ; This is also required for the C30 if we pretend that we can \n ; easily load symbolic addresses into a register.\n (define_split\n   [(set (match_operand:QI 0 \"reg_operand\" \"\")\n-        (match_operand:QI 1 \"symbolic_address_operand\" \"\"))]\n+        (match_operand:QI 1 \"symbolic_address_operand\" \"\"))\n+   (clobber (reg:QI 16))]\n   \"! TARGET_SMALL \n    && (TARGET_C3X || TARGET_TI\n        || (reload_completed\n@@ -1274,7 +1296,8 @@\n ; for the small memory model.\n (define_split\n   [(set (match_operand:QI 0 \"reg_operand\" \"\")\n-        (match_operand:QI 1 \"symbolic_address_operand\" \"\"))]\n+        (match_operand:QI 1 \"symbolic_address_operand\" \"\"))\n+   (clobber (reg:QI 16))]\n   \"TARGET_SMALL\n    && (TARGET_C3X || TARGET_TI\n        || (reload_completed\n@@ -1290,13 +1313,6 @@\n                                                  XEXP (operands[2], 0)));\n }\")\n \n-(define_insn \"load_immed_address\"\n-  [(set (match_operand:QI 0 \"reg_operand\" \"=a?x?c*r\")\n-        (match_operand:QI 1 \"symbolic_address_operand\" \"\"))]\n-  \"TARGET_LOAD_ADDRESS\"\n-  \"#\"\n-  [(set_attr \"type\" \"multi\")])\n-\n (define_insn \"loadhi_big_constant\"\n   [(set (match_operand:HI 0 \"reg_operand\" \"=c*d\")\n         (match_operand:HI 1 \"const_int_operand\" \"\"))]"}]}