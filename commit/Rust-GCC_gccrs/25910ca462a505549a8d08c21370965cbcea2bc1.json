{"sha": "25910ca462a505549a8d08c21370965cbcea2bc1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjU5MTBjYTQ2MmE1MDU1NDlhOGQwOGMyMTM3MDk2NWNiY2VhMmJjMQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-03-06T05:21:10Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-03-06T05:21:10Z"}, "message": "cse.c (fold_rtx_subreg, [...]): New.\n\n\t* cse.c (fold_rtx_subreg, fold_rtx_mem): New.\n\t(fold_rtx): Call fold_rtx_subreg and fold_rtx_mem to handle\n\tSUBREG and MEM, respectively.\n\nFrom-SVN: r95964", "tree": {"sha": "2f8010afca8a7da10d61061b99cbcd710b11199a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f8010afca8a7da10d61061b99cbcd710b11199a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/25910ca462a505549a8d08c21370965cbcea2bc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25910ca462a505549a8d08c21370965cbcea2bc1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25910ca462a505549a8d08c21370965cbcea2bc1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25910ca462a505549a8d08c21370965cbcea2bc1/comments", "author": null, "committer": null, "parents": [{"sha": "7104730324dd854cf0280494f941854c50299312", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7104730324dd854cf0280494f941854c50299312", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7104730324dd854cf0280494f941854c50299312"}], "stats": {"total": 660, "additions": 348, "deletions": 312}, "files": [{"sha": "ca8e3d755b00cc7226d57b109c5902e75ec0ec25", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25910ca462a505549a8d08c21370965cbcea2bc1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25910ca462a505549a8d08c21370965cbcea2bc1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=25910ca462a505549a8d08c21370965cbcea2bc1", "patch": "@@ -1,3 +1,9 @@\n+2005-03-06  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* cse.c (fold_rtx_subreg, fold_rtx_mem): New.\n+\t(fold_rtx): Call fold_rtx_subreg and fold_rtx_mem to handle\n+\tSUBREG and MEM, respectively.\n+\n 2005-03-06  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* fold-const.c (fold_binary): Avoid directly using the original"}, {"sha": "8603eac1ecfd6a5ea0960ee3d83936487bb0329a", "filename": "gcc/cse.c", "status": "modified", "additions": 342, "deletions": 312, "changes": 654, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25910ca462a505549a8d08c21370965cbcea2bc1/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25910ca462a505549a8d08c21370965cbcea2bc1/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=25910ca462a505549a8d08c21370965cbcea2bc1", "patch": "@@ -3210,6 +3210,346 @@ find_comparison_args (enum rtx_code code, rtx *parg1, rtx *parg2,\n   return code;\n }\n \f\n+/* Fold SUBREG.  */\n+\n+static rtx\n+fold_rtx_subreg (rtx x, rtx insn)\n+{\n+  enum machine_mode mode = GET_MODE (x);\n+  rtx folded_arg0;\n+  rtx const_arg0;\n+  rtx new;\n+\n+  /* See if we previously assigned a constant value to this SUBREG.  */\n+  if ((new = lookup_as_function (x, CONST_INT)) != 0\n+      || (new = lookup_as_function (x, CONST_DOUBLE)) != 0)\n+    return new;\n+\n+  /* If this is a paradoxical SUBREG, we have no idea what value the\n+     extra bits would have.  However, if the operand is equivalent to\n+     a SUBREG whose operand is the same as our mode, and all the modes\n+     are within a word, we can just use the inner operand because\n+     these SUBREGs just say how to treat the register.\n+\n+     Similarly if we find an integer constant.  */\n+\n+  if (GET_MODE_SIZE (mode) > GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))))\n+    {\n+      enum machine_mode imode = GET_MODE (SUBREG_REG (x));\n+      struct table_elt *elt;\n+\n+      if (GET_MODE_SIZE (mode) <= UNITS_PER_WORD\n+\t  && GET_MODE_SIZE (imode) <= UNITS_PER_WORD\n+\t  && (elt = lookup (SUBREG_REG (x), HASH (SUBREG_REG (x), imode),\n+\t\t\t    imode)) != 0)\n+\tfor (elt = elt->first_same_value; elt; elt = elt->next_same_value)\n+\t  {\n+\t    if (CONSTANT_P (elt->exp)\n+\t\t&& GET_MODE (elt->exp) == VOIDmode)\n+\t      return elt->exp;\n+\n+\t    if (GET_CODE (elt->exp) == SUBREG\n+\t\t&& GET_MODE (SUBREG_REG (elt->exp)) == mode\n+\t\t&& exp_equiv_p (elt->exp, elt->exp, 1, false))\n+\t      return copy_rtx (SUBREG_REG (elt->exp));\n+\t  }\n+\n+      return x;\n+    }\n+\n+  /* Fold SUBREG_REG.  If it changed, see if we can simplify the\n+     SUBREG.  We might be able to if the SUBREG is extracting a single\n+     word in an integral mode or extracting the low part.  */\n+\n+  folded_arg0 = fold_rtx (SUBREG_REG (x), insn);\n+  const_arg0 = equiv_constant (folded_arg0);\n+  if (const_arg0)\n+    folded_arg0 = const_arg0;\n+\n+  if (folded_arg0 != SUBREG_REG (x))\n+    {\n+      new = simplify_subreg (mode, folded_arg0,\n+\t\t\t     GET_MODE (SUBREG_REG (x)), SUBREG_BYTE (x));\n+      if (new)\n+\treturn new;\n+    }\n+\n+  if (REG_P (folded_arg0)\n+      && GET_MODE_SIZE (mode) < GET_MODE_SIZE (GET_MODE (folded_arg0)))\n+    {\n+      struct table_elt *elt;\n+\n+      elt = lookup (folded_arg0,\n+\t\t    HASH (folded_arg0, GET_MODE (folded_arg0)),\n+\t\t    GET_MODE (folded_arg0));\n+\n+      if (elt)\n+\telt = elt->first_same_value;\n+\n+      if (subreg_lowpart_p (x))\n+\t/* If this is a narrowing SUBREG and our operand is a REG, see\n+\t   if we can find an equivalence for REG that is an arithmetic\n+\t   operation in a wider mode where both operands are\n+\t   paradoxical SUBREGs from objects of our result mode.  In\n+\t   that case, we couldn-t report an equivalent value for that\n+\t   operation, since we don't know what the extra bits will be.\n+\t   But we can find an equivalence for this SUBREG by folding\n+\t   that operation in the narrow mode.  This allows us to fold\n+\t   arithmetic in narrow modes when the machine only supports\n+\t   word-sized arithmetic.\n+\n+\t   Also look for a case where we have a SUBREG whose operand\n+\t   is the same as our result.  If both modes are smaller than\n+\t   a word, we are simply interpreting a register in different\n+\t   modes and we can use the inner value.  */\n+\n+\tfor (; elt; elt = elt->next_same_value)\n+\t  {\n+\t    enum rtx_code eltcode = GET_CODE (elt->exp);\n+\n+\t    /* Just check for unary and binary operations.  */\n+\t    if (UNARY_P (elt->exp)\n+\t\t&& eltcode != SIGN_EXTEND\n+\t\t&& eltcode != ZERO_EXTEND\n+\t\t&& GET_CODE (XEXP (elt->exp, 0)) == SUBREG\n+\t\t&& GET_MODE (SUBREG_REG (XEXP (elt->exp, 0))) == mode\n+\t\t&& (GET_MODE_CLASS (mode)\n+\t\t    == GET_MODE_CLASS (GET_MODE (XEXP (elt->exp, 0)))))\n+\t      {\n+\t\trtx op0 = SUBREG_REG (XEXP (elt->exp, 0));\n+\n+\t\tif (!REG_P (op0) && ! CONSTANT_P (op0))\n+\t\t  op0 = fold_rtx (op0, NULL_RTX);\n+\n+\t\top0 = equiv_constant (op0);\n+\t\tif (op0)\n+\t\t  new = simplify_unary_operation (GET_CODE (elt->exp), mode,\n+\t\t\t\t\t\t  op0, mode);\n+\t      }\n+\t    else if (ARITHMETIC_P (elt->exp)\n+\t\t     && eltcode != DIV && eltcode != MOD\n+\t\t     && eltcode != UDIV && eltcode != UMOD\n+\t\t     && eltcode != ASHIFTRT && eltcode != LSHIFTRT\n+\t\t     && eltcode != ROTATE && eltcode != ROTATERT\n+\t\t     && ((GET_CODE (XEXP (elt->exp, 0)) == SUBREG\n+\t\t\t  && (GET_MODE (SUBREG_REG (XEXP (elt->exp, 0)))\n+\t\t\t      == mode))\n+\t\t\t || CONSTANT_P (XEXP (elt->exp, 0)))\n+\t\t     && ((GET_CODE (XEXP (elt->exp, 1)) == SUBREG\n+\t\t\t  && (GET_MODE (SUBREG_REG (XEXP (elt->exp, 1)))\n+\t\t\t      == mode))\n+\t\t\t || CONSTANT_P (XEXP (elt->exp, 1))))\n+\t      {\n+\t\trtx op0 = gen_lowpart_common (mode, XEXP (elt->exp, 0));\n+\t\trtx op1 = gen_lowpart_common (mode, XEXP (elt->exp, 1));\n+\n+\t\tif (op0 && !REG_P (op0) && ! CONSTANT_P (op0))\n+\t\t  op0 = fold_rtx (op0, NULL_RTX);\n+\n+\t\tif (op0)\n+\t\t  op0 = equiv_constant (op0);\n+\n+\t\tif (op1 && !REG_P (op1) && ! CONSTANT_P (op1))\n+\t\t  op1 = fold_rtx (op1, NULL_RTX);\n+\n+\t\tif (op1)\n+\t\t  op1 = equiv_constant (op1);\n+\n+\t\t/* If we are looking for the low SImode part of\n+\t\t   (ashift:DI c (const_int 32)), it doesn't work to\n+\t\t   compute that in SImode, because a 32-bit shift in\n+\t\t   SImode is unpredictable.  We know the value is\n+\t\t   0.  */\n+\t\tif (op0 && op1\n+\t\t    && GET_CODE (elt->exp) == ASHIFT\n+\t\t    && GET_CODE (op1) == CONST_INT\n+\t\t    && INTVAL (op1) >= GET_MODE_BITSIZE (mode))\n+\t\t  {\n+\t\t    if (INTVAL (op1)\n+\t\t\t< GET_MODE_BITSIZE (GET_MODE (elt->exp)))\n+\t\t      /* If the count fits in the inner mode's width,\n+\t\t\t but exceeds the outer mode's width, the value\n+\t\t\t will get truncated to 0 by the subreg.  */\n+\t\t      new = CONST0_RTX (mode);\n+\t\t    else\n+\t\t      /* If the count exceeds even the inner mode's width,\n+\t\t\t don't fold this expression.  */\n+\t\t      new = 0;\n+\t\t  }\n+\t\telse if (op0 && op1)\n+\t\t  new = simplify_binary_operation (GET_CODE (elt->exp),\n+\t\t\t\t\t\t   mode, op0, op1);\n+\t      }\n+\n+\t    else if (GET_CODE (elt->exp) == SUBREG\n+\t\t     && GET_MODE (SUBREG_REG (elt->exp)) == mode\n+\t\t     && (GET_MODE_SIZE (GET_MODE (folded_arg0))\n+\t\t\t <= UNITS_PER_WORD)\n+\t\t     && exp_equiv_p (elt->exp, elt->exp, 1, false))\n+\t      new = copy_rtx (SUBREG_REG (elt->exp));\n+\n+\t    if (new)\n+\t      return new;\n+\t  }\n+      else\n+\t/* A SUBREG resulting from a zero extension may fold to zero\n+\t   if it extracts higher bits than the ZERO_EXTEND's source\n+\t   bits.  FIXME: if combine tried to, er, combine these\n+\t   instructions, this transformation may be moved to\n+\t   simplify_subreg.  */\n+\tfor (; elt; elt = elt->next_same_value)\n+\t  {\n+\t    if (GET_CODE (elt->exp) == ZERO_EXTEND\n+\t\t&& subreg_lsb (x)\n+\t\t>= GET_MODE_BITSIZE (GET_MODE (XEXP (elt->exp, 0))))\n+\t      return CONST0_RTX (mode);\n+\t  }\n+    }\n+\n+  return x;\n+}\n+\n+/* Fold MEM.  */\n+\n+static rtx\n+fold_rtx_mem (rtx x, rtx insn)\n+{\n+  enum machine_mode mode = GET_MODE (x);\n+  rtx new;\n+\n+  /* If we are not actually processing an insn, don't try to find the\n+     best address.  Not only don't we care, but we could modify the\n+     MEM in an invalid way since we have no insn to validate\n+     against.  */\n+  if (insn != 0)\n+    find_best_addr (insn, &XEXP (x, 0), mode);\n+\n+  {\n+    /* Even if we don't fold in the insn itself, we can safely do so\n+       here, in hopes of getting a constant.  */\n+    rtx addr = fold_rtx (XEXP (x, 0), NULL_RTX);\n+    rtx base = 0;\n+    HOST_WIDE_INT offset = 0;\n+\n+    if (REG_P (addr)\n+\t&& REGNO_QTY_VALID_P (REGNO (addr)))\n+      {\n+\tint addr_q = REG_QTY (REGNO (addr));\n+\tstruct qty_table_elem *addr_ent = &qty_table[addr_q];\n+\n+\tif (GET_MODE (addr) == addr_ent->mode\n+\t    && addr_ent->const_rtx != NULL_RTX)\n+\t  addr = addr_ent->const_rtx;\n+      }\n+\n+    /* If address is constant, split it into a base and integer\n+       offset.  */\n+    if (GET_CODE (addr) == SYMBOL_REF || GET_CODE (addr) == LABEL_REF)\n+      base = addr;\n+    else if (GET_CODE (addr) == CONST && GET_CODE (XEXP (addr, 0)) == PLUS\n+\t     && GET_CODE (XEXP (XEXP (addr, 0), 1)) == CONST_INT)\n+      {\n+\tbase = XEXP (XEXP (addr, 0), 0);\n+\toffset = INTVAL (XEXP (XEXP (addr, 0), 1));\n+      }\n+    else if (GET_CODE (addr) == LO_SUM\n+\t     && GET_CODE (XEXP (addr, 1)) == SYMBOL_REF)\n+      base = XEXP (addr, 1);\n+\n+    /* If this is a constant pool reference, we can fold it into its\n+       constant to allow better value tracking.  */\n+    if (base && GET_CODE (base) == SYMBOL_REF\n+\t&& CONSTANT_POOL_ADDRESS_P (base))\n+      {\n+\trtx constant = get_pool_constant (base);\n+\tenum machine_mode const_mode = get_pool_mode (base);\n+\trtx new;\n+\n+\tif (CONSTANT_P (constant) && GET_CODE (constant) != CONST_INT)\n+\t  {\n+\t    constant_pool_entries_cost = COST (constant);\n+\t    constant_pool_entries_regcost = approx_reg_cost (constant);\n+\t  }\n+\n+\t/* If we are loading the full constant, we have an\n+\t   equivalence.  */\n+\tif (offset == 0 && mode == const_mode)\n+\t  return constant;\n+\n+\t/* If this actually isn't a constant (weird!), we can't do\n+\t   anything.  Otherwise, handle the two most common cases:\n+\t   extracting a word from a multi-word constant, and\n+\t   extracting the low-order bits.  Other cases don't seem\n+\t   common enough to worry about.  */\n+\tif (! CONSTANT_P (constant))\n+\t  return x;\n+\n+\tif (GET_MODE_CLASS (mode) == MODE_INT\n+\t    && GET_MODE_SIZE (mode) == UNITS_PER_WORD\n+\t    && offset % UNITS_PER_WORD == 0\n+\t    && (new = operand_subword (constant,\n+\t\t\t\t       offset / UNITS_PER_WORD,\n+\t\t\t\t       0, const_mode)) != 0)\n+\t  return new;\n+\n+\tif (((BYTES_BIG_ENDIAN\n+\t      && offset == GET_MODE_SIZE (GET_MODE (constant)) - 1)\n+\t     || (! BYTES_BIG_ENDIAN && offset == 0))\n+\t    && (new = gen_lowpart (mode, constant)) != 0)\n+\t  return new;\n+      }\n+\n+    /* If this is a reference to a label at a known position in a jump\n+       table, we also know its value.  */\n+    if (base && GET_CODE (base) == LABEL_REF)\n+      {\n+\trtx label = XEXP (base, 0);\n+\trtx table_insn = NEXT_INSN (label);\n+\n+\tif (table_insn && JUMP_P (table_insn)\n+\t    && GET_CODE (PATTERN (table_insn)) == ADDR_VEC)\n+\t  {\n+\t    rtx table = PATTERN (table_insn);\n+\n+\t    if (offset >= 0\n+\t\t&& (offset / GET_MODE_SIZE (GET_MODE (table))\n+\t\t    < XVECLEN (table, 0)))\n+\t      return XVECEXP (table, 0,\n+\t\t\t      offset / GET_MODE_SIZE (GET_MODE (table)));\n+\t  }\n+\tif (table_insn && JUMP_P (table_insn)\n+\t    && GET_CODE (PATTERN (table_insn)) == ADDR_DIFF_VEC)\n+\t  {\n+\t    rtx table = PATTERN (table_insn);\n+\n+\t    if (offset >= 0\n+\t\t&& (offset / GET_MODE_SIZE (GET_MODE (table))\n+\t\t    < XVECLEN (table, 1)))\n+\t      {\n+\t\toffset /= GET_MODE_SIZE (GET_MODE (table));\n+\t\tnew = gen_rtx_MINUS (Pmode, XVECEXP (table, 1, offset),\n+\t\t\t\t     XEXP (table, 0));\n+\n+\t\tif (GET_MODE (table) != Pmode)\n+\t\t  new = gen_rtx_TRUNCATE (GET_MODE (table), new);\n+\n+\t\t/* Indicate this is a constant.  This isn't a valid\n+\t\t   form of CONST, but it will only be used to fold the\n+\t\t   next insns and then discarded, so it should be\n+\t\t   safe.\n+\n+\t\t   Note this expression must be explicitly discarded,\n+\t\t   by cse_insn, else it may end up in a REG_EQUAL note\n+\t\t   and \"escape\" to cause problems elsewhere.  */\n+\t\treturn gen_rtx_CONST (GET_MODE (new), new);\n+\t      }\n+\t  }\n+      }\n+\n+    return x;\n+  }\n+}\n+\n /* If X is a nontrivial arithmetic operation on an argument\n    for which a constant value can be determined, return\n    the result of operating on that value, as a constant.\n@@ -3275,190 +3615,7 @@ fold_rtx (rtx x, rtx insn)\n #endif\n \n     case SUBREG:\n-      /* See if we previously assigned a constant value to this SUBREG.  */\n-      if ((new = lookup_as_function (x, CONST_INT)) != 0\n-\t  || (new = lookup_as_function (x, CONST_DOUBLE)) != 0)\n-\treturn new;\n-\n-      /* If this is a paradoxical SUBREG, we have no idea what value the\n-\t extra bits would have.  However, if the operand is equivalent\n-\t to a SUBREG whose operand is the same as our mode, and all the\n-\t modes are within a word, we can just use the inner operand\n-\t because these SUBREGs just say how to treat the register.\n-\n-\t Similarly if we find an integer constant.  */\n-\n-      if (GET_MODE_SIZE (mode) > GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))))\n-\t{\n-\t  enum machine_mode imode = GET_MODE (SUBREG_REG (x));\n-\t  struct table_elt *elt;\n-\n-\t  if (GET_MODE_SIZE (mode) <= UNITS_PER_WORD\n-\t      && GET_MODE_SIZE (imode) <= UNITS_PER_WORD\n-\t      && (elt = lookup (SUBREG_REG (x), HASH (SUBREG_REG (x), imode),\n-\t\t\t\timode)) != 0)\n-\t    for (elt = elt->first_same_value; elt; elt = elt->next_same_value)\n-\t      {\n-\t\tif (CONSTANT_P (elt->exp)\n-\t\t    && GET_MODE (elt->exp) == VOIDmode)\n-\t\t  return elt->exp;\n-\n-\t\tif (GET_CODE (elt->exp) == SUBREG\n-\t\t    && GET_MODE (SUBREG_REG (elt->exp)) == mode\n-\t\t    && exp_equiv_p (elt->exp, elt->exp, 1, false))\n-\t\t  return copy_rtx (SUBREG_REG (elt->exp));\n-\t      }\n-\n-\t  return x;\n-\t}\n-\n-      /* Fold SUBREG_REG.  If it changed, see if we can simplify the SUBREG.\n-\t We might be able to if the SUBREG is extracting a single word in an\n-\t integral mode or extracting the low part.  */\n-\n-      folded_arg0 = fold_rtx (SUBREG_REG (x), insn);\n-      const_arg0 = equiv_constant (folded_arg0);\n-      if (const_arg0)\n-\tfolded_arg0 = const_arg0;\n-\n-      if (folded_arg0 != SUBREG_REG (x))\n-\t{\n-\t  new = simplify_subreg (mode, folded_arg0,\n-\t\t\t\t GET_MODE (SUBREG_REG (x)), SUBREG_BYTE (x));\n-\t  if (new)\n-\t    return new;\n-\t}\n-\n-      if (REG_P (folded_arg0)\n-\t  && GET_MODE_SIZE (mode) < GET_MODE_SIZE (GET_MODE (folded_arg0)))\n-\t{\n-\t  struct table_elt *elt;\n-\n-\t  elt = lookup (folded_arg0,\n-\t\t\tHASH (folded_arg0, GET_MODE (folded_arg0)),\n-\t\t\tGET_MODE (folded_arg0));\n-\n-\t  if (elt)\n-\t    elt = elt->first_same_value;\n-\n-\t  if (subreg_lowpart_p (x))\n-\t    /* If this is a narrowing SUBREG and our operand is a REG, see\n-\t       if we can find an equivalence for REG that is an arithmetic\n-\t       operation in a wider mode where both operands are paradoxical\n-\t       SUBREGs from objects of our result mode.  In that case, we\n-\t       couldn-t report an equivalent value for that operation, since we\n-\t       don't know what the extra bits will be.  But we can find an\n-\t       equivalence for this SUBREG by folding that operation in the\n-\t       narrow mode.  This allows us to fold arithmetic in narrow modes\n-\t       when the machine only supports word-sized arithmetic.\n-\n-\t       Also look for a case where we have a SUBREG whose operand\n-\t       is the same as our result.  If both modes are smaller\n-\t       than a word, we are simply interpreting a register in\n-\t       different modes and we can use the inner value.\t*/\n-\n-\t    for (; elt; elt = elt->next_same_value)\n-\t      {\n-\t\tenum rtx_code eltcode = GET_CODE (elt->exp);\n-\n-\t        /* Just check for unary and binary operations.  */\n-\t        if (UNARY_P (elt->exp)\n-\t\t    && eltcode != SIGN_EXTEND\n-\t\t    && eltcode != ZERO_EXTEND\n-\t\t    && GET_CODE (XEXP (elt->exp, 0)) == SUBREG\n-\t\t    && GET_MODE (SUBREG_REG (XEXP (elt->exp, 0))) == mode\n-\t\t    && (GET_MODE_CLASS (mode)\n-\t\t        == GET_MODE_CLASS (GET_MODE (XEXP (elt->exp, 0)))))\n-\t\t  {\n-\t\t    rtx op0 = SUBREG_REG (XEXP (elt->exp, 0));\n-\n-\t\t    if (!REG_P (op0) && ! CONSTANT_P (op0))\n-\t\t      op0 = fold_rtx (op0, NULL_RTX);\n-\n-\t\t    op0 = equiv_constant (op0);\n-\t\t    if (op0)\n-\t\t      new = simplify_unary_operation (GET_CODE (elt->exp), mode,\n-\t\t\t\t\t\t      op0, mode);\n-\t\t  }\n-\t        else if (ARITHMETIC_P (elt->exp)\n-\t\t         && eltcode != DIV && eltcode != MOD\n-\t\t         && eltcode != UDIV && eltcode != UMOD\n-\t\t         && eltcode != ASHIFTRT && eltcode != LSHIFTRT\n-\t\t         && eltcode != ROTATE && eltcode != ROTATERT\n-\t\t         && ((GET_CODE (XEXP (elt->exp, 0)) == SUBREG\n-\t\t\t      && (GET_MODE (SUBREG_REG (XEXP (elt->exp, 0)))\n-\t\t\t\t  == mode))\n-\t\t\t     || CONSTANT_P (XEXP (elt->exp, 0)))\n-\t\t         && ((GET_CODE (XEXP (elt->exp, 1)) == SUBREG\n-\t\t\t      && (GET_MODE (SUBREG_REG (XEXP (elt->exp, 1)))\n-\t\t\t\t  == mode))\n-\t\t\t     || CONSTANT_P (XEXP (elt->exp, 1))))\n-\t\t  {\n-\t\t    rtx op0 = gen_lowpart_common (mode, XEXP (elt->exp, 0));\n-\t\t    rtx op1 = gen_lowpart_common (mode, XEXP (elt->exp, 1));\n-\n-\t\t    if (op0 && !REG_P (op0) && ! CONSTANT_P (op0))\n-\t\t      op0 = fold_rtx (op0, NULL_RTX);\n-\n-\t\t    if (op0)\n-\t\t      op0 = equiv_constant (op0);\n-\n-\t\t    if (op1 && !REG_P (op1) && ! CONSTANT_P (op1))\n-\t\t      op1 = fold_rtx (op1, NULL_RTX);\n-\n-\t\t    if (op1)\n-\t\t      op1 = equiv_constant (op1);\n-\n-\t\t    /* If we are looking for the low SImode part of\n-\t\t       (ashift:DI c (const_int 32)), it doesn't work\n-\t\t       to compute that in SImode, because a 32-bit shift\n-\t\t       in SImode is unpredictable.  We know the value is 0.  */\n-\t\t    if (op0 && op1\n-\t\t        && GET_CODE (elt->exp) == ASHIFT\n-\t\t        && GET_CODE (op1) == CONST_INT\n-\t\t        && INTVAL (op1) >= GET_MODE_BITSIZE (mode))\n-\t\t      {\n-\t\t        if (INTVAL (op1)\n-\t\t\t    < GET_MODE_BITSIZE (GET_MODE (elt->exp)))\n-\t\t\t  /* If the count fits in the inner mode's width,\n-\t\t\t     but exceeds the outer mode's width,\n-\t\t\t     the value will get truncated to 0\n-\t\t\t     by the subreg.  */\n-\t\t\t  new = CONST0_RTX (mode);\n-\t\t        else\n-\t\t\t  /* If the count exceeds even the inner mode's width,\n-\t\t\t   don't fold this expression.  */\n-\t\t\t  new = 0;\n-\t\t      }\n-\t\t    else if (op0 && op1)\n-\t\t      new = simplify_binary_operation (GET_CODE (elt->exp),\t\t\t\t\t\t\t       mode, op0, op1);\n-\t\t  }\n-\n-\t        else if (GET_CODE (elt->exp) == SUBREG\n-\t\t         && GET_MODE (SUBREG_REG (elt->exp)) == mode\n-\t\t         && (GET_MODE_SIZE (GET_MODE (folded_arg0))\n-\t\t\t     <= UNITS_PER_WORD)\n-\t\t         && exp_equiv_p (elt->exp, elt->exp, 1, false))\n-\t\t  new = copy_rtx (SUBREG_REG (elt->exp));\n-\n-\t        if (new)\n-\t\t  return new;\n-\t      }\n-\t  else\n-\t    /* A SUBREG resulting from a zero extension may fold to zero if\n-\t       it extracts higher bits than the ZERO_EXTEND's source bits.\n-\t       FIXME: if combine tried to, er, combine these instructions,\n-\t       this transformation may be moved to simplify_subreg.  */\n-\t    for (; elt; elt = elt->next_same_value)\n-\t      {\n-\t      \tif (GET_CODE (elt->exp) == ZERO_EXTEND\n-\t\t    && subreg_lsb (x)\n-\t\t       >= GET_MODE_BITSIZE (GET_MODE (XEXP (elt->exp, 0))))\n-\t\t  return CONST0_RTX (mode);\n-\t      }\n-\t}\n-\n-      return x;\n+      return fold_rtx_subreg (x, insn);\n \n     case NOT:\n     case NEG:\n@@ -3470,134 +3627,7 @@ fold_rtx (rtx x, rtx insn)\n       break;\n \n     case MEM:\n-      /* If we are not actually processing an insn, don't try to find the\n-\t best address.  Not only don't we care, but we could modify the\n-\t MEM in an invalid way since we have no insn to validate against.  */\n-      if (insn != 0)\n-\tfind_best_addr (insn, &XEXP (x, 0), GET_MODE (x));\n-\n-      {\n-\t/* Even if we don't fold in the insn itself,\n-\t   we can safely do so here, in hopes of getting a constant.  */\n-\trtx addr = fold_rtx (XEXP (x, 0), NULL_RTX);\n-\trtx base = 0;\n-\tHOST_WIDE_INT offset = 0;\n-\n-\tif (REG_P (addr)\n-\t    && REGNO_QTY_VALID_P (REGNO (addr)))\n-\t  {\n-\t    int addr_q = REG_QTY (REGNO (addr));\n-\t    struct qty_table_elem *addr_ent = &qty_table[addr_q];\n-\n-\t    if (GET_MODE (addr) == addr_ent->mode\n-\t\t&& addr_ent->const_rtx != NULL_RTX)\n-\t      addr = addr_ent->const_rtx;\n-\t  }\n-\n-\t/* If address is constant, split it into a base and integer offset.  */\n-\tif (GET_CODE (addr) == SYMBOL_REF || GET_CODE (addr) == LABEL_REF)\n-\t  base = addr;\n-\telse if (GET_CODE (addr) == CONST && GET_CODE (XEXP (addr, 0)) == PLUS\n-\t\t && GET_CODE (XEXP (XEXP (addr, 0), 1)) == CONST_INT)\n-\t  {\n-\t    base = XEXP (XEXP (addr, 0), 0);\n-\t    offset = INTVAL (XEXP (XEXP (addr, 0), 1));\n-\t  }\n-\telse if (GET_CODE (addr) == LO_SUM\n-\t\t && GET_CODE (XEXP (addr, 1)) == SYMBOL_REF)\n-\t  base = XEXP (addr, 1);\n-\n-\t/* If this is a constant pool reference, we can fold it into its\n-\t   constant to allow better value tracking.  */\n-\tif (base && GET_CODE (base) == SYMBOL_REF\n-\t    && CONSTANT_POOL_ADDRESS_P (base))\n-\t  {\n-\t    rtx constant = get_pool_constant (base);\n-\t    enum machine_mode const_mode = get_pool_mode (base);\n-\t    rtx new;\n-\n-\t    if (CONSTANT_P (constant) && GET_CODE (constant) != CONST_INT)\n-\t      {\n-\t\tconstant_pool_entries_cost = COST (constant);\n-\t\tconstant_pool_entries_regcost = approx_reg_cost (constant);\n-\t      }\n-\n-\t    /* If we are loading the full constant, we have an equivalence.  */\n-\t    if (offset == 0 && mode == const_mode)\n-\t      return constant;\n-\n-\t    /* If this actually isn't a constant (weird!), we can't do\n-\t       anything.  Otherwise, handle the two most common cases:\n-\t       extracting a word from a multi-word constant, and extracting\n-\t       the low-order bits.  Other cases don't seem common enough to\n-\t       worry about.  */\n-\t    if (! CONSTANT_P (constant))\n-\t      return x;\n-\n-\t    if (GET_MODE_CLASS (mode) == MODE_INT\n-\t\t&& GET_MODE_SIZE (mode) == UNITS_PER_WORD\n-\t\t&& offset % UNITS_PER_WORD == 0\n-\t\t&& (new = operand_subword (constant,\n-\t\t\t\t\t   offset / UNITS_PER_WORD,\n-\t\t\t\t\t   0, const_mode)) != 0)\n-\t      return new;\n-\n-\t    if (((BYTES_BIG_ENDIAN\n-\t\t  && offset == GET_MODE_SIZE (GET_MODE (constant)) - 1)\n-\t\t || (! BYTES_BIG_ENDIAN && offset == 0))\n-\t\t&& (new = gen_lowpart (mode, constant)) != 0)\n-\t      return new;\n-\t  }\n-\n-\t/* If this is a reference to a label at a known position in a jump\n-\t   table, we also know its value.  */\n-\tif (base && GET_CODE (base) == LABEL_REF)\n-\t  {\n-\t    rtx label = XEXP (base, 0);\n-\t    rtx table_insn = NEXT_INSN (label);\n-\n-\t    if (table_insn && JUMP_P (table_insn)\n-\t\t&& GET_CODE (PATTERN (table_insn)) == ADDR_VEC)\n-\t      {\n-\t\trtx table = PATTERN (table_insn);\n-\n-\t\tif (offset >= 0\n-\t\t    && (offset / GET_MODE_SIZE (GET_MODE (table))\n-\t\t\t< XVECLEN (table, 0)))\n-\t\t  return XVECEXP (table, 0,\n-\t\t\t\t  offset / GET_MODE_SIZE (GET_MODE (table)));\n-\t      }\n-\t    if (table_insn && JUMP_P (table_insn)\n-\t\t&& GET_CODE (PATTERN (table_insn)) == ADDR_DIFF_VEC)\n-\t      {\n-\t\trtx table = PATTERN (table_insn);\n-\n-\t\tif (offset >= 0\n-\t\t    && (offset / GET_MODE_SIZE (GET_MODE (table))\n-\t\t\t< XVECLEN (table, 1)))\n-\t\t  {\n-\t\t    offset /= GET_MODE_SIZE (GET_MODE (table));\n-\t\t    new = gen_rtx_MINUS (Pmode, XVECEXP (table, 1, offset),\n-\t\t\t\t\t XEXP (table, 0));\n-\n-\t\t    if (GET_MODE (table) != Pmode)\n-\t\t      new = gen_rtx_TRUNCATE (GET_MODE (table), new);\n-\n-\t\t    /* Indicate this is a constant.  This isn't a\n-\t\t       valid form of CONST, but it will only be used\n-\t\t       to fold the next insns and then discarded, so\n-\t\t       it should be safe.\n-\n-\t\t       Note this expression must be explicitly discarded,\n-\t\t       by cse_insn, else it may end up in a REG_EQUAL note\n-\t\t       and \"escape\" to cause problems elsewhere.  */\n-\t\t    return gen_rtx_CONST (GET_MODE (new), new);\n-\t\t  }\n-\t      }\n-\t  }\n-\n-\treturn x;\n-      }\n+      return fold_rtx_mem (x, insn);\n \n #ifdef NO_FUNCTION_CSE\n     case CALL:"}]}