{"sha": "31905f34981000880dd1e24709eb1fe4ec0cc4b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzE5MDVmMzQ5ODEwMDA4ODBkZDFlMjQ3MDllYjFmZTRlYzBjYzRiNA==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2006-01-03T13:19:23Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2006-01-03T13:19:23Z"}, "message": "stl_list.h (_List_base<>::_M_get_Node_allocator): Add.\n\n2006-01-03  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/bits/stl_list.h (_List_base<>::_M_get_Node_allocator): Add.\n\t(_M_get_Tp_allocator, get_allocator): Tidy.\n\t(list<>::list(const list&), insert(iterator, size_type, const\n\tvalue_type&), insert(iterator, _InputIterator, _InputIterator)):\n\tUse _M_get_Node_allocator.\n\t* include/bits/stl_tree.h (_Rb_tree<>::_M_get_Node_allocator()): Add.\n\t(_Rb_tree(const _Rb_tree<>&): Use it.\n\t* include/bits/stl_deque.h (_Deque_base<>::_M_get_map_allocator,\n\tget_allocator): Tidy.\n\t* include/bits/stl_vector.h (_Vector_base<>::get_allocator): Tidy.\n\t* testsuite/23_containers/map/operators/1_neg.cc: Adjust dg-error\n\tline numbers.\n\t* testsuite/23_containers/set/operators/1_neg.cc: Likewise.\n\t\n\t* testsuite/testsuite_allocator.h (uneq_allocator<>::swap): Fix.\n\n\t* testsuite/testsuite_allocator.h (class uneq_allocator): A simple\n\tnon-empty testing allocator which can be endowed of a \"personality\"\n\tat construction time.\n\nFrom-SVN: r109280", "tree": {"sha": "b25500a53dc212597d68b7b184276b59752bd888", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b25500a53dc212597d68b7b184276b59752bd888"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31905f34981000880dd1e24709eb1fe4ec0cc4b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31905f34981000880dd1e24709eb1fe4ec0cc4b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31905f34981000880dd1e24709eb1fe4ec0cc4b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31905f34981000880dd1e24709eb1fe4ec0cc4b4/comments", "author": null, "committer": null, "parents": [{"sha": "1387fef3fbf29d527e8ca1956a2eaf1de137a377", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1387fef3fbf29d527e8ca1956a2eaf1de137a377", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1387fef3fbf29d527e8ca1956a2eaf1de137a377"}], "stats": {"total": 233, "additions": 200, "deletions": 33}, "files": [{"sha": "7a775d4f68b35aaf3b14cdb17e5c00c60882e78b", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31905f34981000880dd1e24709eb1fe4ec0cc4b4/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31905f34981000880dd1e24709eb1fe4ec0cc4b4/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=31905f34981000880dd1e24709eb1fe4ec0cc4b4", "patch": "@@ -1,3 +1,25 @@\n+2006-01-03  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/bits/stl_list.h (_List_base<>::_M_get_Node_allocator): Add.\n+\t(_M_get_Tp_allocator, get_allocator): Tidy.\n+\t(list<>::list(const list&), insert(iterator, size_type, const\n+\tvalue_type&), insert(iterator, _InputIterator, _InputIterator)):\n+\tUse _M_get_Node_allocator.\n+\t* include/bits/stl_tree.h (_Rb_tree<>::_M_get_Node_allocator()): Add.\n+\t(_Rb_tree(const _Rb_tree<>&): Use it.\n+\t* include/bits/stl_deque.h (_Deque_base<>::_M_get_map_allocator,\n+\tget_allocator): Tidy.\n+\t* include/bits/stl_vector.h (_Vector_base<>::get_allocator): Tidy.\n+\t* testsuite/23_containers/map/operators/1_neg.cc: Adjust dg-error\n+\tline numbers.\n+\t* testsuite/23_containers/set/operators/1_neg.cc: Likewise.\n+\t\n+\t* testsuite/testsuite_allocator.h (uneq_allocator<>::swap): Fix.\n+\n+\t* testsuite/testsuite_allocator.h (class uneq_allocator): A simple\n+\tnon-empty testing allocator which can be endowed of a \"personality\"\n+\tat construction time.\n+\n 2006-01-03  Paolo Carlini  <pcarlini@suse.de>\n \n \t* testsuite/27_io/basic_stringstream/str/char/1.cc: Initialize vars."}, {"sha": "d9bbb007b060ab7480c85a23c70369e2225741af", "filename": "libstdc++-v3/include/bits/stl_deque.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31905f34981000880dd1e24709eb1fe4ec0cc4b4/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31905f34981000880dd1e24709eb1fe4ec0cc4b4/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h?ref=31905f34981000880dd1e24709eb1fe4ec0cc4b4", "patch": "@@ -1,6 +1,7 @@\n // Deque implementation -*- C++ -*-\n \n-// Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006\n+// Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -369,7 +370,7 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD)\n \n       allocator_type\n       get_allocator() const\n-      { return _M_get_Tp_allocator(); }\n+      { return allocator_type(_M_get_Tp_allocator()); }\n \n       typedef _Deque_iterator<_Tp, _Tp&, _Tp*>             iterator;\n       typedef _Deque_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;\n@@ -416,7 +417,7 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD)\n \n       _Map_alloc_type\n       _M_get_map_allocator() const\n-      { return _M_get_Tp_allocator(); }\n+      { return _Map_alloc_type(_M_get_Tp_allocator()); }\n \n       _Tp*\n       _M_allocate_node()"}, {"sha": "1761bf5c133fb4ce16de033aba18f272cfde4bc1", "filename": "libstdc++-v3/include/bits/stl_list.h", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31905f34981000880dd1e24709eb1fe4ec0cc4b4/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31905f34981000880dd1e24709eb1fe4ec0cc4b4/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h?ref=31905f34981000880dd1e24709eb1fe4ec0cc4b4", "patch": "@@ -1,6 +1,7 @@\n // List implementation -*- C++ -*-\n \n-// Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006\n+// Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -322,13 +323,21 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD)\n   public:\n       typedef _Alloc allocator_type;\n \n+      _Node_alloc_type&\n+      _M_get_Node_allocator()\n+      { return *static_cast<_Node_alloc_type*>(&this->_M_impl); }\n+\n+      const _Node_alloc_type&\n+      _M_get_Node_allocator() const\n+      { return *static_cast<const _Node_alloc_type*>(&this->_M_impl); }\n+\n       _Tp_alloc_type\n       _M_get_Tp_allocator() const\n-      { return *static_cast<const _Node_alloc_type*>(&this->_M_impl); }\n+      { return _Tp_alloc_type(_M_get_Node_allocator()); }\n \n       allocator_type\n       get_allocator() const\n-      { return _M_get_Tp_allocator(); }\n+      { return allocator_type(_M_get_Node_allocator()); }\n \n       _List_base(const allocator_type& __a)\n       : _M_impl(__a)\n@@ -424,16 +433,11 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD)\n       // iterator types.\n       typedef _List_node<_Tp>\t\t\t\t _Node;\n \n-      /** @if maint\n-       *  One data member plus two memory-handling functions.  If the\n-       *  _Alloc type requires separate instances, then one of those\n-       *  will also be included, accumulated from the topmost parent.\n-       *  @endif\n-       */\n       using _Base::_M_impl;\n       using _Base::_M_put_node;\n       using _Base::_M_get_node;\n       using _Base::_M_get_Tp_allocator;\n+      using _Base::_M_get_Node_allocator;\n \n       /**\n        *  @if maint\n@@ -489,7 +493,7 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD)\n        *  by @a x.\n        */\n       list(const list& __x)\n-      : _Base(__x.get_allocator())\n+      : _Base(__x._M_get_Node_allocator())\n       { _M_initialize_dispatch(__x.begin(), __x.end(), __false_type()); }\n \n       /**\n@@ -803,7 +807,7 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD)\n       void\n       insert(iterator __position, size_type __n, const value_type& __x)\n       {  \n-\tlist __tmp(__n, __x, get_allocator());\n+\tlist __tmp(__n, __x, _M_get_Node_allocator());\n \tsplice(__position, __tmp);\n       }\n \n@@ -825,7 +829,7 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD)\n         insert(iterator __position, _InputIterator __first,\n \t       _InputIterator __last)\n         {\n-\t  list __tmp(__first, __last, get_allocator());\n+\t  list __tmp(__first, __last, _M_get_Node_allocator());\n \t  splice(__position, __tmp);\n \t}\n "}, {"sha": "c2acf87e3500c10eb2a70aea38decec33ea81a02", "filename": "libstdc++-v3/include/bits/stl_tree.h", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31905f34981000880dd1e24709eb1fe4ec0cc4b4/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31905f34981000880dd1e24709eb1fe4ec0cc4b4/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h?ref=31905f34981000880dd1e24709eb1fe4ec0cc4b4", "patch": "@@ -1,6 +1,7 @@\n // RB tree implementation -*- C++ -*-\n \n-// Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006\n+// Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -348,10 +349,18 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       typedef ptrdiff_t difference_type;\n       typedef _Alloc allocator_type;\n \n-      allocator_type \n-      get_allocator() const\n+      _Node_allocator&\n+      _M_get_Node_allocator()\n+      { return *static_cast<_Node_allocator*>(&this->_M_impl); }\n+      \n+      const _Node_allocator&\n+      _M_get_Node_allocator() const\n       { return *static_cast<const _Node_allocator*>(&this->_M_impl); }\n \n+      allocator_type\n+      get_allocator() const\n+      { return allocator_type(_M_get_Node_allocator()); }\n+\n     protected:\n       _Rb_tree_node*\n       _M_get_node()\n@@ -563,7 +572,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       { }\n \n       _Rb_tree(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x)\n-      : _M_impl(__x.get_allocator(), __x._M_impl._M_key_compare)\n+      : _M_impl(__x._M_get_Node_allocator(), __x._M_impl._M_key_compare)\n       {\n \tif (__x._M_root() != 0)\n \t  {"}, {"sha": "43f69de450e2eb76000b6f47adf041748ad6dd11", "filename": "libstdc++-v3/include/bits/stl_vector.h", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31905f34981000880dd1e24709eb1fe4ec0cc4b4/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31905f34981000880dd1e24709eb1fe4ec0cc4b4/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h?ref=31905f34981000880dd1e24709eb1fe4ec0cc4b4", "patch": "@@ -1,6 +1,7 @@\n // Vector implementation -*- C++ -*-\n \n-// Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006\n+// Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -101,7 +102,7 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD)\n \n       allocator_type\n       get_allocator() const\n-      { return _M_get_Tp_allocator(); }\n+      { return allocator_type(_M_get_Tp_allocator()); }\n \n       _Vector_base(const allocator_type& __a)\n       : _M_impl(__a)\n@@ -182,11 +183,6 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD)\n       typedef _Alloc                        \t\t allocator_type;\n \n     protected:\n-      /** @if maint\n-       *  These two functions and three data members are all from the\n-       *  base class.  They should be pretty self-explanatory, as\n-       *  %vector uses a simple contiguous allocation scheme.  @endif\n-       */\n       using _Base::_M_allocate;\n       using _Base::_M_deallocate;\n       using _Base::_M_impl;"}, {"sha": "54e741425dec6066125716366c83a28edf28a0ed", "filename": "libstdc++-v3/testsuite/23_containers/map/operators/1_neg.cc", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31905f34981000880dd1e24709eb1fe4ec0cc4b4/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Foperators%2F1_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31905f34981000880dd1e24709eb1fe4ec0cc4b4/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Foperators%2F1_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Foperators%2F1_neg.cc?ref=31905f34981000880dd1e24709eb1fe4ec0cc4b4", "patch": "@@ -1,6 +1,7 @@\n // { dg-do compile }\n \n-// Copyright (C) 2000, 2001, 2002, 2004, 2005 Free Software Foundation, Inc.\n+// Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006\n+// Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -41,5 +42,5 @@ void test01()\n   test &= itr == mapByName.end(); // { dg-error \"no\" } \n }\n  \n-// { dg-error \"candidates are\" \"\" { target *-*-* } 210 }\n-// { dg-error \"candidates are\" \"\" { target *-*-* } 214 }\n+// { dg-error \"candidates are\" \"\" { target *-*-* } 211 }\n+// { dg-error \"candidates are\" \"\" { target *-*-* } 215 }"}, {"sha": "48f6ae68f69f7c2d1b086bb5fc472b07b5e2dc71", "filename": "libstdc++-v3/testsuite/23_containers/set/operators/1_neg.cc", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31905f34981000880dd1e24709eb1fe4ec0cc4b4/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Foperators%2F1_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31905f34981000880dd1e24709eb1fe4ec0cc4b4/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Foperators%2F1_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Foperators%2F1_neg.cc?ref=31905f34981000880dd1e24709eb1fe4ec0cc4b4", "patch": "@@ -1,6 +1,7 @@\n // { dg-do compile }\n \n-// Copyright (C) 2000, 2001, 2002, 2004, 2005 Free Software Foundation, Inc.\n+// Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006\n+// Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -39,5 +40,5 @@ void test01()\n   test &= itr == setByName.end(); // { dg-error \"no\" } \n }\n \n-// { dg-error \"candidates are\" \"\" { target *-*-* } 285 }\n-// { dg-error \"candidates are\" \"\" { target *-*-* } 289 }\n+// { dg-error \"candidates are\" \"\" { target *-*-* } 286 }\n+// { dg-error \"candidates are\" \"\" { target *-*-* } 290 }"}, {"sha": "0ea1215e3b4c6a150b758ff798cde358d8da62c1", "filename": "libstdc++-v3/testsuite/testsuite_allocator.h", "status": "modified", "additions": 134, "deletions": 1, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31905f34981000880dd1e24709eb1fe4ec0cc4b4/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31905f34981000880dd1e24709eb1fe4ec0cc4b4/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_allocator.h?ref=31905f34981000880dd1e24709eb1fe4ec0cc4b4", "patch": "@@ -1,7 +1,7 @@\n // -*- C++ -*-\n // Testing allocator for the C++ library testsuite.\n //\n-// Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+// Copyright (C) 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -37,6 +37,8 @@\n \n #include <cstddef>\n #include <limits>\n+#include <tr1/unordered_map>\n+#include <cassert>\n \n namespace \n {\n@@ -231,6 +233,137 @@ namespace __gnu_test\n       throw;\n     }\n \n+\n+  // A simple allocator which can be constructed endowed of a given\n+  // \"personality\" (an integer), queried in operator== to simulate the\n+  // behavior of realworld \"unequal\" allocators (i.e., not exploiting\n+  // the provision in 20.1.5/4, first bullet).  A global unordered_map,\n+  // filled at allocation time with (pointer, personality) pairs, is\n+  // then consulted to enforce the requirements in Table 32 about\n+  // deallocation vs allocator equality.  Note that this allocator is\n+  // swappable, not assignable, consistently with Option 3 of DR 431\n+  // (see N1599).\n+  struct uneq_allocator_base\n+  {\n+    typedef std::tr1::unordered_map<void*, int>   map_type;\n+\n+    // Avoid static initialization troubles and/or bad interactions\n+    // with tests linking testsuite_allocator.o and playing globally\n+    // with operator new/delete.\n+    static map_type&\n+    get_map()\n+    {\n+      static map_type alloc_map;\n+      return alloc_map;\n+    }\n+  };\n+\n+  template<typename Tp>\n+    class uneq_allocator\n+    : private uneq_allocator_base\n+    {\n+    public:\n+      typedef size_t                              size_type;\n+      typedef ptrdiff_t                           difference_type;\n+      typedef Tp*                                 pointer;\n+      typedef const Tp*                           const_pointer;\n+      typedef Tp&                                 reference;\n+      typedef const Tp&                           const_reference;\n+      typedef Tp                                  value_type;\n+      \n+      template<typename Tp1>\n+        struct rebind\n+\t{ typedef uneq_allocator<Tp1> other; };\n+\n+      uneq_allocator() throw()\n+      : personality(0) { }\n+\n+      uneq_allocator(int person) throw()\n+      : personality(person) { }\n+      \n+      template<typename Tp1>\n+        uneq_allocator(const uneq_allocator<Tp1>& b) throw()\n+\t: personality(b.get_personality()) { }\n+\n+      int get_personality() const { return personality; }\n+      \n+      pointer\n+      address(reference x) const { return &x; }\n+    \n+      const_pointer\n+      address(const_reference x) const { return &x; }\n+    \n+      pointer\n+      allocate(size_type n, const void* = 0)\n+      { \n+\tif (__builtin_expect(n > this->max_size(), false))\n+\t  std::__throw_bad_alloc();\n+\t\n+\tpointer p = static_cast<Tp*>(::operator new(n * sizeof(Tp)));\n+\ttry\n+\t  {\n+\t    get_map().insert(map_type::value_type(reinterpret_cast<void*>(p),\n+\t\t\t\t\t\t  personality));\n+\t  }\n+\tcatch(...)\n+\t  {\n+\t    ::operator delete(p);\n+\t    __throw_exception_again;\n+\t  }\n+\treturn p;\n+      }\n+      \n+      void\n+      deallocate(pointer p, size_type)\n+      {\n+\tassert( p );\n+\t\n+\tmap_type::iterator it = get_map().find(reinterpret_cast<void*>(p));\n+\tassert( it != get_map().end() );\n+\n+\t// Enforce requirements in Table 32 about deallocation vs\n+\t// allocator equality.\n+\tassert( it->second == personality );\n+\t\n+\tget_map().erase(it);\n+\t::operator delete(p);\n+      }\n+      \n+      size_type\n+      max_size() const throw() \n+      { return size_t(-1) / sizeof(Tp); }\n+      \n+      void \n+      construct(pointer p, const Tp& val) \n+      { ::new(p) Tp(val); }\n+    \n+      void \n+      destroy(pointer p) { p->~Tp(); }\n+\n+    private:\n+      // Not assignable...\n+      uneq_allocator&\n+      operator=(const uneq_allocator&);\n+\n+      // ... yet swappable!\n+      friend inline void\n+      swap(uneq_allocator& a, uneq_allocator& b)\n+      { std::swap(a.personality, b.personality); } \n+      \n+      template<typename Tp1>\n+        friend inline bool\n+        operator==(const uneq_allocator& a, const uneq_allocator<Tp1>& b)\n+        { return a.personality == b.personality; }\n+\n+      template<typename Tp1>\n+        friend inline bool\n+        operator!=(const uneq_allocator& a, const uneq_allocator<Tp1>& b)\n+        { return !(a == b); }\n+      \n+      int personality;\n+    };\n+\n+\n   template<typename Tp>\n     class throw_allocator\n     {"}]}