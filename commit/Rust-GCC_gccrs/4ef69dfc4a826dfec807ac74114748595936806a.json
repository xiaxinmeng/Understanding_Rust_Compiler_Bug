{"sha": "4ef69dfc4a826dfec807ac74114748595936806a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGVmNjlkZmM0YTgyNmRmZWM4MDdhYzc0MTE0NzQ4NTk1OTM2ODA2YQ==", "commit": {"author": {"name": "Ira Rosen", "email": "ira.rosen@linaro.org", "date": "2011-09-27T12:26:34Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2011-09-27T12:26:34Z"}, "message": "tree-vect-stmts.c (vectorizable_type_demotion): Handle basic block vectorization.\n\n\n        * tree-vect-stmts.c (vectorizable_type_demotion): Handle basic\n        block vectorization.\n        (vectorizable_type_promotion): Likewise.\n        (vect_analyze_stmt): Call vectorizable_type_demotion and\n        vectorizable_type_promotion for basic blocks.\n        (supportable_widening_operation): Don't assume loop\n        vectorization.\n        * tree-vect-slp.c (vect_build_slp_tree): Allow multiple types\n        for basic blocks.  Update vectorization factor for basic block\n        vectorization.\n        (vect_analyze_slp_instance): Allow multiple types for basic\n        block vectorization.  Recheck unrolling factor after\n        construction of SLP instance.\n\nFrom-SVN: r179267", "tree": {"sha": "a9affb65d722fc832803aca53919d2087436bef2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a9affb65d722fc832803aca53919d2087436bef2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ef69dfc4a826dfec807ac74114748595936806a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ef69dfc4a826dfec807ac74114748595936806a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ef69dfc4a826dfec807ac74114748595936806a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ef69dfc4a826dfec807ac74114748595936806a/comments", "author": null, "committer": null, "parents": [{"sha": "d22c9c31169e048e885a60847cd3da066de200ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d22c9c31169e048e885a60847cd3da066de200ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d22c9c31169e048e885a60847cd3da066de200ed"}], "stats": {"total": 211, "additions": 177, "deletions": 34}, "files": [{"sha": "1f01b9ef44169ae53d4d4a58b08f4b09b816e2e4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ef69dfc4a826dfec807ac74114748595936806a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ef69dfc4a826dfec807ac74114748595936806a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4ef69dfc4a826dfec807ac74114748595936806a", "patch": "@@ -1,3 +1,18 @@\n+2011-09-27  Ira Rosen  <ira.rosen@linaro.org>\n+\n+\t* tree-vect-stmts.c (vectorizable_type_demotion): Handle basic block\n+\tvectorization.\n+\t(vectorizable_type_promotion): Likewise.\n+\t(vect_analyze_stmt): Call vectorizable_type_demotion and\n+\tvectorizable_type_promotion for basic blocks.\n+\t(supportable_widening_operation): Don't assume loop vectorization.\n+\t* tree-vect-slp.c (vect_build_slp_tree): Allow multiple types for\n+\tbasic blocks.  Update vectorization factor for basic block\n+\tvectorization.\n+\t(vect_analyze_slp_instance): Allow multiple types for basic block\n+\tvectorization.  Recheck unrolling factor after construction of SLP\n+\tinstance.\n+\n 2011-09-27  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-object-size.c (compute_object_sizes): Fix dumping of"}, {"sha": "a45af3b68c531febafc552820506e29dfdd595ce", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ef69dfc4a826dfec807ac74114748595936806a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ef69dfc4a826dfec807ac74114748595936806a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4ef69dfc4a826dfec807ac74114748595936806a", "patch": "@@ -1,3 +1,10 @@\n+2011-09-27  Ira Rosen  <ira.rosen@linaro.org>\n+\n+\t* gcc.dg/vect/bb-slp-11.c: Expect to get vectorized with 64-bit\n+\tvectors.\n+\t* gcc.dg/vect/bb-slp-27.c: New.\n+\t* gcc.dg/vect/bb-slp-28.c: New.\n+\n 2011-09-27  Bernd Schmidt  <bernds@codesourcery.com>\n \n \t* testsuite/lib/target-supports.exp (check_profiling_available):"}, {"sha": "225d08ec33b2b9ef4f1014c504f7f1541ade7bcc", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-11.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ef69dfc4a826dfec807ac74114748595936806a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ef69dfc4a826dfec807ac74114748595936806a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-11.c?ref=4ef69dfc4a826dfec807ac74114748595936806a", "patch": "@@ -48,8 +48,6 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"basic block vectorized using SLP\" 0 \"slp\" } } */\n-/* { dg-final { scan-tree-dump-times \"SLP with multiple types\" 1 \"slp\" { xfail vect_multiple_sizes } } } */\n-/* { dg-final { scan-tree-dump-times \"SLP with multiple types\" 2 \"slp\" { target vect_multiple_sizes } } } */\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized using SLP\" 1 \"slp\" { target vect64 } } } */\n /* { dg-final { cleanup-tree-dump \"slp\" } } */\n   "}, {"sha": "7157ebadddc13af2de30f1bb37ba825740909d0a", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-27.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ef69dfc4a826dfec807ac74114748595936806a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-27.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ef69dfc4a826dfec807ac74114748595936806a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-27.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-27.c?ref=4ef69dfc4a826dfec807ac74114748595936806a", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define A 3\n+#define N 16\n+\n+short src[N], dst[N];\n+\n+void foo (int a)\n+{\n+  dst[0] += a*src[0];\n+  dst[1] += a*src[1];\n+  dst[2] += a*src[2];\n+  dst[3] += a*src[3];\n+  dst[4] += a*src[4];\n+  dst[5] += a*src[5];\n+  dst[6] += a*src[6];\n+  dst[7] += a*src[7];\n+}\n+\n+\n+int main (void)\n+{\n+  int i;\n+\n+  check_vect ();\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      dst[i] = 0;\n+      src[i] = i;\n+    }\n+\n+  foo (A);\n+\n+  for (i = 0; i < 8; i++)\n+    {\n+      if (dst[i] != A * i)\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized using SLP\" 1 \"slp\" { target { vect_int_mult && { vect_unpack && vect_pack_trunc } } } } } */\n+/* { dg-final { cleanup-tree-dump \"slp\" } } */\n+"}, {"sha": "996f8f3cad86ea906c1d6fda95ae3f0ba673aa7b", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-28.c", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ef69dfc4a826dfec807ac74114748595936806a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-28.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ef69dfc4a826dfec807ac74114748595936806a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-28.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-28.c?ref=4ef69dfc4a826dfec807ac74114748595936806a", "patch": "@@ -0,0 +1,71 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define A 300\n+#define N 16\n+\n+char src[N];\n+short dst[N];\n+short src1[N], dst1[N];\n+\n+void foo (int a)\n+{\n+  dst[0] = (short) (a * (int) src[0]);\n+  dst[1] = (short) (a * (int) src[1]);\n+  dst[2] = (short) (a * (int) src[2]);\n+  dst[3] = (short) (a * (int) src[3]);\n+  dst[4] = (short) (a * (int) src[4]);\n+  dst[5] = (short) (a * (int) src[5]);\n+  dst[6] = (short) (a * (int) src[6]);\n+  dst[7] = (short) (a * (int) src[7]);\n+  dst[8] = (short) (a * (int) src[8]);\n+  dst[9] = (short) (a * (int) src[9]);\n+  dst[10] = (short) (a * (int) src[10]);\n+  dst[11] = (short) (a * (int) src[11]);\n+  dst[12] = (short) (a * (int) src[12]);\n+  dst[13] = (short) (a * (int) src[13]);\n+  dst[14] = (short) (a * (int) src[14]);\n+  dst[15] = (short) (a * (int) src[15]);\n+\n+  dst1[0] += src1[0];\n+  dst1[1] += src1[1];\n+  dst1[2] += src1[2];\n+  dst1[3] += src1[3];\n+  dst1[4] += src1[4];\n+  dst1[5] += src1[5];\n+  dst1[6] += src1[6];\n+  dst1[7] += src1[7];\n+}\n+\n+\n+int main (void)\n+{\n+  int i;\n+\n+  check_vect ();\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      dst[i] = 2;\n+      dst1[i] = 0;\n+      src[i] = i;\n+      src1[i] = i+2;\n+    }\n+\n+  foo (A);\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      if (dst[i] != A * i\n+          || (i < N/2 && dst1[i] != i + 2))\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized using SLP\" 1 \"slp\" { target { vect_int_mult &&  { vect_pack_trunc && vect_unpack } } } } } */\n+/* { dg-final { cleanup-tree-dump \"slp\" } } */\n+"}, {"sha": "4b205bf332ac1e642be923537b31f795f1723347", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ef69dfc4a826dfec807ac74114748595936806a/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ef69dfc4a826dfec807ac74114748595936806a/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=4ef69dfc4a826dfec807ac74114748595936806a", "patch": "@@ -393,20 +393,15 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n           return false;\n         }\n \n-      ncopies = vectorization_factor / TYPE_VECTOR_SUBPARTS (vectype);\n-      if (ncopies != 1)\n+      /* In case of multiple types we need to detect the smallest type.  */\n+      if (*max_nunits < TYPE_VECTOR_SUBPARTS (vectype))\n         {\n-\t  if (vect_print_dump_info (REPORT_SLP))\n-            fprintf (vect_dump, \"SLP with multiple types \");\n-\n-          /* FORNOW: multiple types are unsupported in BB SLP.  */\n-\t  if (bb_vinfo)\n-\t    return false;\n+          *max_nunits = TYPE_VECTOR_SUBPARTS (vectype);\n+          if (bb_vinfo)\n+            vectorization_factor = *max_nunits;\n         }\n \n-      /* In case of multiple types we need to detect the smallest type.  */\n-      if (*max_nunits < TYPE_VECTOR_SUBPARTS (vectype))\n-        *max_nunits = TYPE_VECTOR_SUBPARTS (vectype);\n+      ncopies = vectorization_factor / TYPE_VECTOR_SUBPARTS (vectype);\n \n       if (is_gimple_call (stmt))\n \trhs_code = CALL_EXPR;\n@@ -1201,7 +1196,6 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n   if (loop_vinfo)\n     vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n   else\n-    /* No multitypes in BB SLP.  */\n     vectorization_factor = nunits;\n \n   /* Calculate the unrolling factor.  */\n@@ -1257,16 +1251,23 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t\t   &max_nunits, &load_permutation, &loads,\n \t\t\t   vectorization_factor))\n     {\n-      /* Create a new SLP instance.  */\n-      new_instance = XNEW (struct _slp_instance);\n-      SLP_INSTANCE_TREE (new_instance) = node;\n-      SLP_INSTANCE_GROUP_SIZE (new_instance) = group_size;\n-      /* Calculate the unrolling factor based on the smallest type in the\n-         loop.  */\n+      /* Calculate the unrolling factor based on the smallest type.  */\n       if (max_nunits > nunits)\n         unrolling_factor = least_common_multiple (max_nunits, group_size)\n                            / group_size;\n \n+      if (unrolling_factor != 1 && !loop_vinfo)\n+        {\n+          if (vect_print_dump_info (REPORT_SLP))\n+            fprintf (vect_dump, \"Build SLP failed: unrolling required in basic\"\n+                               \" block SLP\");\n+          return false;\n+        }\n+\n+      /* Create a new SLP instance.  */\n+      new_instance = XNEW (struct _slp_instance);\n+      SLP_INSTANCE_TREE (new_instance) = node;\n+      SLP_INSTANCE_GROUP_SIZE (new_instance) = group_size;\n       SLP_INSTANCE_UNROLLING_FACTOR (new_instance) = unrolling_factor;\n       SLP_INSTANCE_OUTSIDE_OF_LOOP_COST (new_instance) = outside_cost;\n       SLP_INSTANCE_INSIDE_OF_LOOP_COST (new_instance) = inside_cost;"}, {"sha": "8c2edadba13e9f93088e154f605725c8093f6336", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ef69dfc4a826dfec807ac74114748595936806a/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ef69dfc4a826dfec807ac74114748595936806a/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=4ef69dfc4a826dfec807ac74114748595936806a", "patch": "@@ -3039,11 +3039,9 @@ vectorizable_type_demotion (gimple stmt, gimple_stmt_iterator *gsi,\n   VEC (tree, heap) *vec_oprnds0 = NULL;\n   VEC (tree, heap) *vec_dsts = NULL, *interm_types = NULL, *tmp_vec_dsts = NULL;\n   tree last_oprnd, intermediate_type;\n+  bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n \n-  /* FORNOW: not supported by basic block SLP vectorization.  */\n-  gcc_assert (loop_vinfo);\n-\n-  if (!STMT_VINFO_RELEVANT_P (stmt_info))\n+  if (!STMT_VINFO_RELEVANT_P (stmt_info) && !bb_vinfo)\n     return false;\n \n   if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_internal_def)\n@@ -3071,7 +3069,7 @@ vectorizable_type_demotion (gimple stmt, gimple_stmt_iterator *gsi,\n \t     && SCALAR_FLOAT_TYPE_P (TREE_TYPE (op0))\n \t     && CONVERT_EXPR_CODE_P (code))))\n     return false;\n-  if (!vect_is_simple_use_1 (op0, loop_vinfo, NULL,\n+  if (!vect_is_simple_use_1 (op0, loop_vinfo, bb_vinfo,\n \t\t\t     &def_stmt, &def, &dt[0], &vectype_in))\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n@@ -3318,11 +3316,9 @@ vectorizable_type_promotion (gimple stmt, gimple_stmt_iterator *gsi,\n   int multi_step_cvt = 0;\n   VEC (tree, heap) *vec_oprnds0 = NULL, *vec_oprnds1 = NULL;\n   VEC (tree, heap) *vec_dsts = NULL, *interm_types = NULL, *tmp_vec_dsts = NULL;\n+  bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n \n-  /* FORNOW: not supported by basic block SLP vectorization.  */\n-  gcc_assert (loop_vinfo);\n-\n-  if (!STMT_VINFO_RELEVANT_P (stmt_info))\n+  if (!STMT_VINFO_RELEVANT_P (stmt_info) && !bb_vinfo)\n     return false;\n \n   if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_internal_def)\n@@ -3351,7 +3347,7 @@ vectorizable_type_promotion (gimple stmt, gimple_stmt_iterator *gsi,\n \t     && SCALAR_FLOAT_TYPE_P (TREE_TYPE (op0))\n \t     && CONVERT_EXPR_CODE_P (code))))\n     return false;\n-  if (!vect_is_simple_use_1 (op0, loop_vinfo, NULL,\n+  if (!vect_is_simple_use_1 (op0, loop_vinfo, bb_vinfo,\n \t\t\t     &def_stmt, &def, &dt[0], &vectype_in))\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n@@ -5083,7 +5079,9 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n     else\n       {\n         if (bb_vinfo)\n-          ok = (vectorizable_shift (stmt, NULL, NULL, node)\n+          ok = (vectorizable_type_promotion (stmt, NULL, NULL, node)\n+                || vectorizable_type_demotion (stmt, NULL, NULL, node)\n+               || vectorizable_shift (stmt, NULL, NULL, node)\n                 || vectorizable_operation (stmt, NULL, NULL, node)\n                 || vectorizable_assignment (stmt, NULL, NULL, node)\n                 || vectorizable_load (stmt, NULL, NULL, node, NULL)\n@@ -5719,7 +5717,7 @@ supportable_widening_operation (enum tree_code code, gimple stmt,\n {\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   loop_vec_info loop_info = STMT_VINFO_LOOP_VINFO (stmt_info);\n-  struct loop *vect_loop = LOOP_VINFO_LOOP (loop_info);\n+  struct loop *vect_loop = NULL;\n   bool ordered_p;\n   enum machine_mode vec_mode;\n   enum insn_code icode1, icode2;\n@@ -5728,6 +5726,9 @@ supportable_widening_operation (enum tree_code code, gimple stmt,\n   tree wide_vectype = vectype_out;\n   enum tree_code c1, c2;\n \n+  if (loop_info)\n+    vect_loop = LOOP_VINFO_LOOP (loop_info);\n+\n   /* The result of a vectorized widening operation usually requires two vectors\n      (because the widened results do not fit int one vector). The generated\n      vector results would normally be expected to be generated in the same\n@@ -5748,7 +5749,8 @@ supportable_widening_operation (enum tree_code code, gimple stmt,\n      iterations in parallel).  We therefore don't allow to change the order\n      of the computation in the inner-loop during outer-loop vectorization.  */\n \n-   if (STMT_VINFO_RELEVANT (stmt_info) == vect_used_by_reduction\n+   if (vect_loop\n+       && STMT_VINFO_RELEVANT (stmt_info) == vect_used_by_reduction\n        && !nested_in_vect_loop_p (vect_loop, stmt))\n      ordered_p = false;\n    else"}]}