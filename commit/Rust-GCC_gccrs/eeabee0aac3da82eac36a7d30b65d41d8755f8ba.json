{"sha": "eeabee0aac3da82eac36a7d30b65d41d8755f8ba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWVhYmVlMGFhYzNkYTgyZWFjMzZhN2QzMGI2NWQ0MWQ4NzU1ZjhiYQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2011-11-12T11:35:42Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2011-11-12T11:35:42Z"}, "message": "gcov.c (struct name_map): New.\n\n\t* gcov.c (struct name_map): New.\n\t(names, n_names, a_names): New global vars.\n\t(print_usage): Adjust usage.\n\t(generate_results): Canonicalize main file name.\n\t(release_structures): Adjust.\n\t(name_search, name_sort): New callbacks.\n\t(find_source): Look for and create a canonical name.\n\t(canonicalize_name): New.\n\t(make_gcov_file_name): Reimplement and fix mangling.\n\t(mangle_name): New.\n\t* doc/gcov.texi: Update documentation about path preservation.\n\n\ttestsuite/\n\t* gcc.misc-tests/gcov-15.c: New.\n\nFrom-SVN: r181309", "tree": {"sha": "2e9f87b3156339bef982192181004d19888c7861", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e9f87b3156339bef982192181004d19888c7861"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eeabee0aac3da82eac36a7d30b65d41d8755f8ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eeabee0aac3da82eac36a7d30b65d41d8755f8ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eeabee0aac3da82eac36a7d30b65d41d8755f8ba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eeabee0aac3da82eac36a7d30b65d41d8755f8ba/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "926706f8282e7e29a9c413a199348678654c0725", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/926706f8282e7e29a9c413a199348678654c0725", "html_url": "https://github.com/Rust-GCC/gccrs/commit/926706f8282e7e29a9c413a199348678654c0725"}], "stats": {"total": 420, "additions": 319, "deletions": 101}, "files": [{"sha": "9f0505b7063ba4dc2f881d6ea9133773fcd32eb5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeabee0aac3da82eac36a7d30b65d41d8755f8ba/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeabee0aac3da82eac36a7d30b65d41d8755f8ba/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eeabee0aac3da82eac36a7d30b65d41d8755f8ba", "patch": "@@ -1,3 +1,17 @@\n+2011-11-12  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* gcov.c (struct name_map): New.\n+\t(names, n_names, a_names): New global vars.\n+\t(print_usage): Adjust usage.\n+\t(generate_results): Canonicalize main file name.\n+\t(release_structures): Adjust.\n+\t(name_search, name_sort): New callbacks.\n+\t(find_source): Look for and create a canonical name.\n+\t(canonicalize_name): New.\n+\t(make_gcov_file_name): Reimplement and fix mangling.\n+\t(mangle_name): New.\n+\t* doc/gcov.texi: Update documentation about path preservation.\n+\n 2011-11-11  David S. Miller  <davem@davemloft.net>\n \n \t* config/sparc/linux.h (ASM_GENERATE_INTERNAL_LABEL): Delete."}, {"sha": "d158b357807daf31205f865c94872ef0f6df2173", "filename": "gcc/doc/gcov.texi", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeabee0aac3da82eac36a7d30b65d41d8755f8ba/gcc%2Fdoc%2Fgcov.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeabee0aac3da82eac36a7d30b65d41d8755f8ba/gcc%2Fdoc%2Fgcov.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgcov.texi?ref=eeabee0aac3da82eac36a7d30b65d41d8755f8ba", "patch": "@@ -113,7 +113,7 @@ compatible with any other profiling or test coverage mechanism.\n @section Invoking @command{gcov}\n \n @smallexample\n-gcov @r{[}@var{options}@r{]} @var{sourcefiles}\n+gcov @r{[}@var{options}@r{]} @var{files}\n @end smallexample\n \n @command{gcov} accepts the following options:\n@@ -176,21 +176,22 @@ Do not create the @command{gcov} output file.\n @itemx --long-file-names\n Create long file names for included source files.  For example, if the\n header file @file{x.h} contains code, and was included in the file\n-@file{a.c}, then running @command{gcov} on the file @file{a.c} will produce\n-an output file called @file{a.c##x.h.gcov} instead of @file{x.h.gcov}.\n-This can be useful if @file{x.h} is included in multiple source\n-files.  If you use the @samp{-p} option, both the including and\n-included file names will be complete path names.\n+@file{a.c}, then running @command{gcov} on the file @file{a.c} will\n+produce an output file called @file{a.c##x.h.gcov} instead of\n+@file{x.h.gcov}.  This can be useful if @file{x.h} is included in\n+multiple source files and you want to see the individual\n+contributions.  If you use the @samp{-p} option, both the including\n+and included file names will be complete path names.\n \n @item -p\n @itemx --preserve-paths\n Preserve complete path information in the names of generated\n @file{.gcov} files.  Without this option, just the filename component is\n used.  With this option, all directories are used, with @samp{/} characters\n translated to @samp{#} characters, @file{.} directory components\n-removed and @file{..}\n+removed and unremoveable @file{..}\n components renamed to @samp{^}.  This is useful if sourcefiles are in several\n-different directories.  It also affects the @samp{-l} option.\n+different directories.\n \n @item -f\n @itemx --function-summaries\n@@ -203,9 +204,8 @@ Specify either the directory containing the gcov data files, or the\n object path name.  The @file{.gcno}, and\n @file{.gcda} data files are searched for using this option.  If a directory\n is specified, the data files are in that directory and named after the\n-source file name, without its extension.  If a file is specified here,\n-the data files are named after that file, without its extension.  If this\n-option is not supplied, it defaults to the current directory.\n+input file name, without its extension.  If a file is specified here,\n+the data files are named after that file, without its extension.\n \n @item -u\n @itemx --unconditional-branches\n@@ -223,12 +223,17 @@ when you invoked the compiler.  Otherwise it will not be able to locate\n the source files.  @command{gcov} produces files called\n @file{@var{mangledname}.gcov} in the current directory.  These contain\n the coverage information of the source file they correspond to.\n-One @file{.gcov} file is produced for each source file containing code,\n+One @file{.gcov} file is produced for each source (or header) file\n+containing code,\n which was compiled to produce the data files.  The @var{mangledname} part\n of the output file name is usually simply the source file name, but can\n be something more complicated if the @samp{-l} or @samp{-p} options are\n given.  Refer to those options for details.\n \n+If you invoke @command{gcov} with multiple input files, the\n+contributions from each input file are summed.  Typically you would\n+invoke it with the same list of files as the final link of your executable.\n+\n The @file{.gcov} files contain the @samp{:} separated fields along with\n program source code.  The format is\n "}, {"sha": "a39e75d1d2756ffd6f4abbaff222cddc19c68530", "filename": "gcc/gcov.c", "status": "modified", "additions": 254, "deletions": 89, "changes": 343, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeabee0aac3da82eac36a7d30b65d41d8755f8ba/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeabee0aac3da82eac36a7d30b65d41d8755f8ba/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=eeabee0aac3da82eac36a7d30b65d41d8755f8ba", "patch": "@@ -231,7 +231,7 @@ typedef struct line_info\n \n typedef struct source_info\n {\n-  /* Name of source file.  */\n+  /* Canonical name of source file.  */\n   char *name;\n   time_t file_time;\n \n@@ -246,6 +246,12 @@ typedef struct source_info\n   function_t *functions;\n } source_t;\n \n+typedef struct name_map\n+{\n+  char *name;  /* Source file name */\n+  unsigned src;  /* Source file */\n+} name_map_t;\n+\n /* Holds a list of function basic block graphs.  */\n \n static function_t *functions;\n@@ -255,6 +261,10 @@ static source_t *sources;   /* Array of source files  */\n static unsigned n_sources;  /* Number of sources */\n static unsigned a_sources;  /* Allocated sources */\n \n+static name_map_t *names;   /* Mapping of file names to sources */\n+static unsigned n_names;    /* Number of names */\n+static unsigned a_names;    /* Allocated names */\n+\n /* This holds data summary information.  */\n \n static unsigned object_runs;\n@@ -341,6 +351,9 @@ static void print_version (void) ATTRIBUTE_NORETURN;\n static void process_file (const char *);\n static void generate_results (const char *);\n static void create_file_names (const char *);\n+static int name_search (const void *, const void *);\n+static int name_sort (const void *, const void *);\n+static char *canonicalize_name (const char *);\n static unsigned find_source (const char *);\n static function_t *read_graph_file (void);\n static int read_count_file (function_t *);\n@@ -353,6 +366,7 @@ static void accumulate_line_counts (source_t *);\n static int output_branch_count (FILE *, int, const arc_t *);\n static void output_lines (FILE *, const source_t *);\n static char *make_gcov_file_name (const char *, const char *);\n+static char *mangle_name (const char *, char *);\n static void release_structures (void);\n static void release_function (function_t *);\n extern int main (int, char **);\n@@ -414,7 +428,7 @@ print_usage (int error_p)\n   FILE *file = error_p ? stderr : stdout;\n   int status = error_p ? FATAL_EXIT_CODE : SUCCESS_EXIT_CODE;\n \n-  fnotice (file, \"Usage: gcov [OPTION]... SOURCEFILE...\\n\\n\");\n+  fnotice (file, \"Usage: gcov [OPTION]... SOURCE|OBJ...\\n\\n\");\n   fnotice (file, \"Print code coverage information.\\n\\n\");\n   fnotice (file, \"  -h, --help                      Print this help, then exit\\n\");\n   fnotice (file, \"  -v, --version                   Print version number, then exit\\n\");\n@@ -524,7 +538,7 @@ process_args (int argc, char **argv)\n   return optind;\n }\n \n-/* Process a single source file.  */\n+/* Process a single input file.  */\n \n static void\n process_file (const char *file_name)\n@@ -622,6 +636,16 @@ generate_results (const char *file_name)\n \t}\n     }\n \n+  if (file_name)\n+    {\n+      name_map_t *name_map = (name_map_t *)bsearch\n+\t(file_name, names, n_names, sizeof (*names), name_search);\n+      if (name_map)\n+\tfile_name = sources[name_map->src].name;\n+      else\n+\tfile_name = canonicalize_name (file_name);\n+    }\n+  \n   for (ix = n_sources, src = sources; ix--; src++)\n     {\n       accumulate_line_counts (src);\n@@ -681,10 +705,12 @@ release_structures (void)\n   function_t *fn;\n \n   for (ix = n_sources; ix--;)\n-    {\n-      free (sources[ix].name);\n-      free (sources[ix].lines);\n-    }\n+    free (sources[ix].lines);\n+  free (sources);\n+  \n+  for (ix = n_names; ix--;)\n+    free (names[ix].name);\n+  free (names);\n \n   while ((fn = functions))\n     {\n@@ -761,28 +787,75 @@ create_file_names (const char *file_name)\n   return;\n }\n \n+/* A is a string and B is a pointer to name_map_t.  Compare for file\n+   name orderability.  */\n+\n+static int\n+name_search (const void *a_, const void *b_)\n+{\n+  const char *a = (const char *)a_;\n+  const name_map_t *b = (const name_map_t *)b_;\n+\n+#if HAVE_DOS_BASED_FILE_SYSTEM\n+  return strcasecmp (a, b->name);\n+#else\n+  return strcmp (a, b->name);\n+#endif\n+}\n+\n+/* A and B are a pointer to name_map_t.  Compare for file name\n+   orderability.  */\n+\n+static int\n+name_sort (const void *a_, const void *b_)\n+{\n+  const name_map_t *a = (const name_map_t *)a_;\n+  return name_search (a->name, b_);\n+}\n+\n /* Find or create a source file structure for FILE_NAME. Copies\n    FILE_NAME on creation */\n \n static unsigned\n find_source (const char *file_name)\n {\n-  unsigned ix;\n-  source_t *src = 0;\n+  name_map_t *name_map;\n+  char *canon;\n+  unsigned idx;\n   struct stat status;\n \n   if (!file_name)\n     file_name = \"<unknown>\";\n+  name_map = (name_map_t *)bsearch\n+    (file_name, names, n_names, sizeof (*names), name_search);\n+  if (name_map)\n+    {\n+      idx = name_map->src;\n+      goto check_date;\n+    }\n \n-  for (ix = n_sources; ix--;)\n-    if (!filename_cmp (file_name, sources[ix].name))\n-      {\n-\tsrc = &sources[ix];\n-\tbreak;\n-      }\n-\n-  if (!src)\n+  if (n_names + 2 > a_names)\n     {\n+      /* Extend the name map array -- we'll be inserting one or two\n+\t entries.  */\n+      if (!a_names)\n+\ta_names = 10;\n+      a_names *= 2;\n+      name_map = XNEWVEC (name_map_t, a_names);\n+      memcpy (name_map, names, n_names * sizeof (*names));\n+      free (names);\n+      names = name_map;\n+    }\n+  \n+  /* Not found, try the canonical name. */\n+  canon = canonicalize_name (file_name);\n+  name_map = (name_map_t *)bsearch\n+    (canon, names, n_names, sizeof (*names), name_search);\n+  if (!name_map)\n+    {\n+      /* Not found with canonical name, create a new source.  */\n+      source_t *src;\n+      \n       if (n_sources == a_sources)\n \t{\n \t  if (!a_sources)\n@@ -793,31 +866,51 @@ find_source (const char *file_name)\n \t  free (sources);\n \t  sources = src;\n \t}\n-      ix = n_sources;\n-      src = &sources[ix];\n-      src->name = xstrdup (file_name);\n+\n+      idx = n_sources;\n+\n+      name_map = &names[n_names++];\n+      name_map->name = canon;\n+      name_map->src = idx;\n+\n+      src = &sources[n_sources++];\n+      memset (src, 0, sizeof (*src));\n+      src->name = canon;\n       src->coverage.name = src->name;\n-      n_sources++;\n-      if (!stat (file_name, &status))\n+      if (!stat (src->name, &status))\n \tsrc->file_time = status.st_mtime;\n     }\n+  else\n+    idx = name_map->src;\n+\n+  if (name_search (file_name, name_map))\n+    {\n+      /* Append the non-canonical name.  */\n+      name_map = &names[n_names++];\n+      name_map->name = xstrdup (file_name);\n+      name_map->src = idx;\n+    }\n \n-  if (src->file_time > bbg_file_time)\n+  /* Resort the name map.  */\n+  qsort (names, n_names, sizeof (*names), name_sort);\n+  \n+ check_date:\n+  if (sources[idx].file_time > bbg_file_time)\n     {\n       static int info_emitted;\n \n       fnotice (stderr, \"%s:source file is newer than graph file '%s'\\n\",\n-\t       src->name, bbg_file_name);\n+\t       file_name, bbg_file_name);\n       if (!info_emitted)\n \t{\n \t  fnotice (stderr,\n \t\t   \"(the message is only displayed one per source file)\\n\");\n \t  info_emitted = 1;\n \t}\n-      src->file_time = 0;\n+      sources[idx].file_time = 0;\n     }\n \n-  return ix;\n+  return idx;\n }\n \n /* Read the graph file.  Return list of functions read -- in reverse order.  */\n@@ -1510,97 +1603,169 @@ function_summary (const coverage_t *coverage, const char *title)\n     }\n }\n \n-/* Generate an output file name. LONG_OUTPUT_NAMES and PRESERVE_PATHS\n-   affect name generation. With preserve_paths we create a filename\n-   from all path components of the source file, replacing '/' with\n-   '#', without it we simply take the basename component. With\n+/* Canonicalize the filename NAME by canonicalizing directory\n+   separators, eliding . components and resolving .. components\n+   appropriately.  Always returns a unique string.  */\n+\n+static char *\n+canonicalize_name (const char *name)\n+{\n+  /* The canonical name cannot be longer than the incoming name.  */\n+  char *result = XNEWVEC (char, strlen (name) + 1);\n+  const char *base = name, *probe;\n+  char *ptr = result;\n+  char *dd_base;\n+  int slash = 0;\n+\n+#if HAVE_DOS_BASED_FILE_SYSTEM\n+  if (base[0] && base[1] == ':')\n+    {\n+      result[0] = base[0];\n+      result[1] = ':';\n+      base += 2;\n+      ptr += 2;\n+    }\n+#endif\n+  for (dd_base = ptr; *base; base = probe)\n+    {\n+      size_t len;\n+      \n+      for (probe = base; *probe; probe++)\n+\tif (IS_DIR_SEPARATOR (*probe))\n+\t  break;\n+\n+      len = probe - base;\n+      if (len == 1 && base[0] == '.')\n+\t/* Elide a '.' directory */\n+\t;\n+      else if (len == 2 && base[0] == '.' && base[1] == '.')\n+\t{\n+\t  /* '..', we can only elide it and the previous directory, if\n+\t     we're not a symlink.  */\n+\t  struct stat buf;\n+\t  \n+\t  *ptr = 0;\n+\t  if (dd_base == ptr || stat (result, &buf) || S_ISLNK (buf.st_mode))\n+\t    {\n+\t      /* Cannot elide, or unreadable or a symlink.  */\n+\t      dd_base = ptr + 2 + slash;\n+\t      goto regular;\n+\t    }\n+\t  while (ptr != dd_base && *ptr != '/')\n+\t    ptr--;\n+\t  slash = ptr != result;\n+\t}\n+      else\n+\t{\n+\tregular:\n+\t  /* Regular pathname component.  */\n+\t  if (slash)\n+\t    *ptr++ = '/';\n+\t  memcpy (ptr, base, len);\n+\t  ptr += len;\n+\t  slash = 1;\n+\t}\n+\n+      for (; IS_DIR_SEPARATOR (*probe); probe++)\n+\tcontinue;\n+    }\n+  *ptr = 0;\n+\n+  return result;\n+}\n+\n+/* Generate an output file name. INPUT_NAME is the canonicalized main\n+   input file and SRC_NAME is the canonicalized file name.\n+   LONG_OUTPUT_NAMES and PRESERVE_PATHS affect name generation.  With\n    long_output_names we prepend the processed name of the input file\n    to each output name (except when the current source file is the\n    input file, so you don't get a double concatenation). The two\n-   components are separated by '##'. Also '.' filename components are\n-   removed and '..'  components are renamed to '^'.  */\n+   components are separated by '##'.  With preserve_paths we create a\n+   filename from all path components of the source file, replacing '/'\n+   with '#', and .. with '^', without it we simply take the basename\n+   component.  (Remember, the canonicalized name will already have\n+   elided '.' components and converted \\\\ separators.)  */\n \n static char *\n make_gcov_file_name (const char *input_name, const char *src_name)\n {\n-  const char *cptr;\n-  char *name;\n+  char *ptr;\n+  char *result;\n \n   if (flag_long_names && input_name && strcmp (src_name, input_name))\n     {\n-      name = XNEWVEC (char, strlen (src_name) + strlen (input_name) + 10);\n-      name[0] = 0;\n       /* Generate the input filename part.  */\n-      cptr = flag_preserve_paths ? NULL : lbasename (input_name);\n-      strcat (name, cptr ? cptr : input_name);\n-      strcat (name, \"##\");\n+      result = XNEWVEC (char, strlen (input_name) + strlen (src_name) + 10);\n+  \n+      ptr = result;\n+      ptr = mangle_name (input_name, ptr);\n+      ptr[0] = ptr[1] = '#';\n+      ptr += 2;\n     }\n   else\n     {\n-      name = XNEWVEC (char, strlen (src_name) + 10);\n-      name[0] = 0;\n+      result = XNEWVEC (char, strlen (src_name) + 10);\n+      ptr = result;\n     }\n \n-  /* Generate the source filename part.  */\n-\n-  cptr = flag_preserve_paths ? NULL : lbasename (src_name);\n-  strcat (name, cptr ? cptr : src_name);\n+  ptr = mangle_name (src_name, ptr);\n+  strcpy (ptr, \".gcov\");\n+  \n+  return result;\n+}\n \n-  if (flag_preserve_paths)\n+static char *\n+mangle_name (char const *base, char *ptr)\n+{\n+  size_t len;\n+  \n+  /* Generate the source filename part.  */\n+  if (!flag_preserve_paths)\n+    {\n+      base = lbasename (base);\n+      len = strlen (base);\n+      memcpy (ptr, base, len);\n+      ptr += len;\n+    }\n+  else\n     {\n-      /* Convert '/' and '\\' to '#', remove '/./', convert '/../' to '#^#',\n+      /* Convert '/' to '#', convert '..' to '^',\n \t convert ':' to '~' on DOS based file system.  */\n-      char *pnew = name, *pold = name;\n-\n-      /* First check for leading drive separator.  */\n+      const char *probe;\n \n-      while (*pold != '\\0')\n+#if HAVE_DOS_BASED_FILE_SYSTEM\n+      if (base[0] && base[1] == ':')\n \t{\n-#if defined (HAVE_DOS_BASED_FILE_SYSTEM)\n-\t  if (*pold == ':')\n-\t    {\n-\t      *pnew++ = '~';\n-\t      pold++;\n-\t    }\n-\t  else\n+\t  ptr[0] = base[0];\n+\t  ptr[1] = '~';\n+\t  ptr += 2;\n+\t  base += 2;\n+\t}\n #endif\n-\t  if ((*pold == '/'\n-\t\t    && (strstr (pold, \"/./\") == pold\n-\t\t        || strstr (pold, \"/.\\\\\") == pold))\n-\t\t   || (*pold == '\\\\'\n-\t\t       && (strstr (pold, \"\\\\.\\\\\") == pold\n-\t\t           || strstr (pold, \"\\\\./\") == pold)))\n-\t      pold += 3;\n-\t  else if (*pold == '/'\n-\t\t   && (strstr (pold, \"/../\") == pold\n-\t\t       || strstr (pold, \"/..\\\\\") == pold))\n-\t    {\n-\t      strcpy (pnew, \"#^#\");\n-\t      pnew += 3;\n-\t      pold += 4;\n-\t    }\n-\t  else if (*pold == '\\\\'\n-\t\t   && (strstr (pold, \"\\\\..\\\\\") == pold\n-\t\t       || strstr (pold, \"\\\\../\") == pold))\n+      for (; *base; base = probe)\n+\t{\n+\t  size_t len;\n+\n+\t  for (probe = base; *probe; probe++)\n+\t    if (*probe == '/')\n+\t      break;\n+\t  len = probe - base;\n+\t  if (len == 2 && base[0] == '.' && base[1] == '.')\n+\t    *ptr++ = '^';\n+\t  else\n \t    {\n-\t      strcpy (pnew, \"#^#\");\n-\t      pnew += 3;\n-\t      pold += 4;\n+\t      memcpy (ptr, base, len);\n+\t      ptr += len;\n \t    }\n-\t  else if (*pold == '/' || *pold == '\\\\')\n+\t  if (*probe)\n \t    {\n-\t      *pnew++ = '#';\n-\t      pold++;\n+\t      *ptr++ = '#';\n+\t      probe++;\n \t    }\n-\t  else\n-\t    *pnew++ = *pold++;\n \t}\n-\n-      *pnew = '\\0';\n     }\n-\n-  strcat (name, \".gcov\");\n-  return name;\n+  \n+  return ptr;\n }\n \n /* Scan through the bb_data for each line in the block, increment"}, {"sha": "1d5be98626de84a27df513fdaec8bfd7b5182fc2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeabee0aac3da82eac36a7d30b65d41d8755f8ba/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeabee0aac3da82eac36a7d30b65d41d8755f8ba/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=eeabee0aac3da82eac36a7d30b65d41d8755f8ba", "patch": "@@ -1,3 +1,7 @@\n+2011-11-12  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* gcc.misc-tests/gcov-15.c: New.\n+\n 2011-11-11  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/51058"}, {"sha": "04273fcec4257f9f004a77010a651a2343d67aa2", "filename": "gcc/testsuite/gcc.misc-tests/gcov-15.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeabee0aac3da82eac36a7d30b65d41d8755f8ba/gcc%2Ftestsuite%2Fgcc.misc-tests%2Fgcov-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeabee0aac3da82eac36a7d30b65d41d8755f8ba/gcc%2Ftestsuite%2Fgcc.misc-tests%2Fgcov-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.misc-tests%2Fgcov-15.c?ref=eeabee0aac3da82eac36a7d30b65d41d8755f8ba", "patch": "@@ -0,0 +1,30 @@\n+/* Test gcov multiple paths to file.  */\n+\n+/* { dg-options \"-fprofile-arcs -ftest-coverage\" } */\n+/* { dg-do run { target native } } */\n+\n+#if !RECURSIVE\n+#define RECURSIVE 1\n+#include \"./gcov-15.c\"\n+#undef RECURSIVE\n+#endif\n+\n+static void __attribute__ ((noinline)) Recursive (void);\n+\n+\n+#if RECURSIVE\n+static void __attribute__ ((noinline))\n+Recursive ()\n+{\n+  return; /* count(1) */\n+}\n+\n+#else\n+int main ()\n+{\n+  Recursive (); /* count(1) */\n+  return 0;\n+}\n+#endif\n+\n+/* { dg-final { run-gcov { -a gcov-15.c } } } */"}]}