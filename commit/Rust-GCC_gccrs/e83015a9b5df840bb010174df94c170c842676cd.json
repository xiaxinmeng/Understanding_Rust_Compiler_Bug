{"sha": "e83015a9b5df840bb010174df94c170c842676cd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTgzMDE1YTliNWRmODQwYmIwMTAxNzRkZjk0YzE3MGM4NDI2NzZjZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1998-05-11T08:31:20Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1998-05-11T08:31:20Z"}, "message": "alpha.h (PRINT_OPERAND_PUNCT_VALID_P): Add '`'.\n\n        * alpha.h (PRINT_OPERAND_PUNCT_VALID_P): Add '`'.\n        * alpha.c (print_operand): Handle it.\n        * alpha.md (fix_truncdfsi2, fix_truncsfsi2): New patterns and\n        related define_splits.  Also add peepholes for SImode reload\n        plus sign_extend lossage.\n\nFrom-SVN: r19664", "tree": {"sha": "a574426b3ec9ad03f3bce70fbba0368bfa25c0da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a574426b3ec9ad03f3bce70fbba0368bfa25c0da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e83015a9b5df840bb010174df94c170c842676cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e83015a9b5df840bb010174df94c170c842676cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e83015a9b5df840bb010174df94c170c842676cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e83015a9b5df840bb010174df94c170c842676cd/comments", "author": null, "committer": null, "parents": [{"sha": "830bfa74b082c1cd0d5550ee4f0f4364f46f1a0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/830bfa74b082c1cd0d5550ee4f0f4364f46f1a0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/830bfa74b082c1cd0d5550ee4f0f4364f46f1a0a"}], "stats": {"total": 169, "additions": 165, "deletions": 4}, "files": [{"sha": "b0d3d45c02af292b5ed6d823b463a0eb116e5164", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e83015a9b5df840bb010174df94c170c842676cd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e83015a9b5df840bb010174df94c170c842676cd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e83015a9b5df840bb010174df94c170c842676cd", "patch": "@@ -1,3 +1,11 @@\n+Mon May 11 08:24:18 1998  Richard Henderson <rth@cygnus.com>\n+\n+\t* alpha.h (PRINT_OPERAND_PUNCT_VALID_P): Add '`'.\n+\t* alpha.c (print_operand): Handle it.\n+\t* alpha.md (fix_truncdfsi2, fix_truncsfsi2): New patterns and \n+\trelated define_splits.  Also add peepholes for SImode reload\n+\tplus sign_extend lossage.\n+\n Mon May 11 09:33:10 1998  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n         * genattr.c: Include stdarg.h/varargs.h.  Change function"}, {"sha": "45e725dcaa401b600ad592615b6f545c93e39e89", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e83015a9b5df840bb010174df94c170c842676cd/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e83015a9b5df840bb010174df94c170c842676cd/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=e83015a9b5df840bb010174df94c170c842676cd", "patch": "@@ -2496,6 +2496,23 @@ print_operand (file, x, code)\n \tfputs (\"su\", file);\n       break;\n \n+    case '`':\n+      /* Generates trap-mode suffix for instructions that accept the\n+\t v and sv suffix.  The only instruction that needs this is cvtql.  */\n+      switch (alpha_fptm)\n+\t{\n+\tcase ALPHA_FPTM_N:\n+\t  break;\n+\tcase ALPHA_FPTM_U:\n+\t  fputs (\"v\", file);\n+\t  break;\n+\tcase ALPHA_FPTM_SU:\n+\tcase ALPHA_FPTM_SUI:\n+\t  fputs (\"sv\", file);\n+\t  break;\n+\t}\n+      break;\n+\n     case '(':\n       /* Generates trap-mode suffix for instructions that accept the\n \t v, sv, and svi suffix.  The only instruction that needs this\n@@ -2541,7 +2558,8 @@ print_operand (file, x, code)\n \t suffix (cvtqt and cvtqs).  */\n       switch (alpha_fptm)\n \t{\n-\tcase ALPHA_FPTM_N: case ALPHA_FPTM_U:\n+\tcase ALPHA_FPTM_N:\n+\tcase ALPHA_FPTM_U:\n \tcase ALPHA_FPTM_SU:\t/* cvtqt/cvtqs can't cause underflow */\n \t  break;\n \tcase ALPHA_FPTM_SUI:"}, {"sha": "bb762fb0e2b047c82cae3aa78ef7f1c60702b131", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e83015a9b5df840bb010174df94c170c842676cd/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e83015a9b5df840bb010174df94c170c842676cd/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=e83015a9b5df840bb010174df94c170c842676cd", "patch": "@@ -1076,6 +1076,7 @@ extern int alpha_memory_latency;\n    insns and emitted.  */\n extern struct rtx_def *alpha_emit_set_const ();\n extern struct rtx_def *alpha_emit_set_long_const ();\n+extern struct rtx_def *alpha_emit_conditional_branch ();\n extern struct rtx_def *alpha_emit_conditional_move ();\n \n /* Generate necessary RTL for __builtin_saveregs().\n@@ -2184,6 +2185,9 @@ do {\t\t\t\t\t\t\t\t\t\\\n    '\tGenerates trap-mode suffix for instructions that accept the\n         su suffix only (cmpt et al).\n \n+   `    Generates trap-mode suffix for instructions that accept the\n+\tv and sv suffix.  The only instruction that needs this is cvtql.\n+\n    (\tGenerates trap-mode suffix for instructions that accept the\n \tv, sv, and svi suffix.  The only instruction that needs this\n \tis cvttq.\n@@ -2203,8 +2207,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n    */\n \n #define PRINT_OPERAND_PUNCT_VALID_P(CODE)\t\t\t\t\\\n-  ((CODE) == '&' || (CODE) == '\\'' || (CODE) == '(' || (CODE) == ')'\t\\\n-   || (CODE) == '+' || (CODE) == ',' || (CODE) == '-')\n+  ((CODE) == '&' || (CODE) == '`' || (CODE) == '\\'' || (CODE) == '('\t\\\n+   || (CODE) == ')' || (CODE) == '+' || (CODE) == ',' || (CODE) == '-')\n \f\n /* Print a memory address as an operand to reference that memory location.  */\n \n@@ -2419,4 +2423,3 @@ do {\t\t\t\t\t\t\t\\\n \n /* Prototypes for alpha.c functions used in the md file.  */\n extern struct rtx_def *get_unaligned_address ();\n- "}, {"sha": "3538b48a60c720cb344ad6ec827ac449259f8867", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e83015a9b5df840bb010174df94c170c842676cd/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e83015a9b5df840bb010174df94c170c842676cd/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=e83015a9b5df840bb010174df94c170c842676cd", "patch": "@@ -28,6 +28,7 @@\n ;;\t2\tinsxh\n ;;\t3\tmskxh\n ;;\t4\tcvtlq\n+;;\t5\tcvtql\n ;;\t\n ;; UNSPEC_VOLATILE:\n ;;\n@@ -1769,6 +1770,62 @@\n   [(set_attr \"type\" \"fadd\")\n    (set_attr \"trap\" \"yes\")])\n \n+;; Define conversion operators between DFmode and SImode, using the cvtql\n+;; instruction.  To allow combine et al to do useful things, we keep the\n+;; operation as a unit until after reload, at which point we split the\n+;; instructions.\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(fix:SI (match_operand:DF 1 \"reg_or_fp0_operand\" \"\")))\n+   (clobber (match_scratch:DI 2 \"\"))]\n+  \"TARGET_FP && reload_completed\"\n+  [(set (match_dup 2) (fix:DI (match_dup 1)))\n+   (set (match_dup 0) (unspec:SI [(match_dup 2)] 5))]\n+  \"\")\n+\n+;; Due to issues with CLASS_CANNOT_CHANGE_SIZE, we cannot use a subreg here.\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(fix:SI (match_operand:DF 1 \"reg_or_fp0_operand\" \"\")))]\n+  \"TARGET_FP && reload_completed\"\n+  [(set (match_dup 2) (fix:DI (match_dup 1)))\n+   (set (match_dup 0) (unspec:SI [(match_dup 2)] 5))]\n+  \"operands[2] = gen_rtx_REG (DImode, REGNO (operands[0]));\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=f\")\n+\t(unspec:SI [(match_operand:DI 1 \"reg_or_fp0_operand\" \"fG\")] 5))]\n+  \"TARGET_FP\"\n+  \"cvtql%` %R1,%0\"\n+  [(set_attr \"type\" \"fadd\")\n+   (set_attr \"trap\" \"yes\")])\n+\n+(define_insn \"fix_truncdfsi2_tp\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&f\")\n+\t(fix:SI (match_operand:DF 1 \"reg_or_fp0_operand\" \"fG\")))\n+   (clobber (match_scratch:DI 2 \"=&f\"))]\n+  \"TARGET_FP && alpha_tp == ALPHA_TP_INSN\"\n+  \"#\"\n+  [(set_attr \"type\" \"fadd\")\n+   (set_attr \"trap\" \"yes\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=f\")\n+\t(fix:SI (match_operand:DF 1 \"reg_or_fp0_operand\" \"fG\")))]\n+  \"TARGET_FP && alpha_tp != ALPHA_TP_INSN\"\n+  \"#\"\n+  [(set_attr \"type\" \"fadd\")\n+   (set_attr \"trap\" \"yes\")])\n+\n+(define_expand \"fix_truncdfsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=f\")\n+\t(fix:SI (match_operand:DF 1 \"reg_or_fp0_operand\" \"fG\")))]\n+  \"TARGET_FP\"\n+  \"{ if (alpha_tp == ALPHA_TP_INSN)\n+       { emit_insn(gen_fix_truncdfsi2_tp(operands[0], operands[1])); DONE; }\n+   }\")\n+\n (define_insn \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=&f\")\n \t(fix:DI (match_operand:DF 1 \"reg_or_fp0_operand\" \"fG\")))]\n@@ -1785,6 +1842,56 @@\n   [(set_attr \"type\" \"fadd\")\n    (set_attr \"trap\" \"yes\")])\n \n+;; Likewise between SFmode and SImode.\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(fix:SI (float_extend:DF\n+\t\t (match_operand:SF 1 \"reg_or_fp0_operand\" \"\"))))\n+   (clobber (match_scratch:DI 2 \"\"))]\n+  \"TARGET_FP && reload_completed\"\n+  [(set (match_dup 2) (fix:DI (float_extend:DF (match_dup 1))))\n+   (set (match_dup 0) (unspec:SI [(match_dup 2)] 5))]\n+  \"\")\n+\n+;; Due to issues with CLASS_CANNOT_CHANGE_SIZE, we cannot use a subreg here.\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(fix:SI (float_extend:DF\n+\t\t (match_operand:SF 1 \"reg_or_fp0_operand\" \"\"))))]\n+  \"TARGET_FP && reload_completed\"\n+  [(set (match_dup 2) (fix:DI (float_extend:DF (match_dup 1))))\n+   (set (match_dup 0) (unspec:SI [(match_dup 2)] 5))]\n+  \"operands[2] = gen_rtx_REG (DImode, REGNO (operands[0]));\")\n+\n+(define_insn \"fix_truncsfsi2_tp\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&f\")\n+\t(fix:SI (float_extend:DF\n+\t\t (match_operand:SF 1 \"reg_or_fp0_operand\" \"fG\"))))\n+   (clobber (match_scratch:DI 2 \"=&f\"))]\n+  \"TARGET_FP && alpha_tp == ALPHA_TP_INSN\"\n+  \"#\"\n+  [(set_attr \"type\" \"fadd\")\n+   (set_attr \"trap\" \"yes\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=f\")\n+\t(fix:SI (float_extend:DF\n+\t\t (match_operand:SF 1 \"reg_or_fp0_operand\" \"fG\"))))]\n+  \"TARGET_FP && alpha_tp != ALPHA_TP_INSN\"\n+  \"#\"\n+  [(set_attr \"type\" \"fadd\")\n+   (set_attr \"trap\" \"yes\")])\n+\n+(define_expand \"fix_truncsfsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=f\")\n+\t(fix:SI (float_extend:DF\n+\t\t (match_operand:SF 1 \"reg_or_fp0_operand\" \"fG\"))))]\n+  \"TARGET_FP\"\n+  \"{ if (alpha_tp == ALPHA_TP_INSN)\n+       { emit_insn(gen_fix_truncsfsi2_tp(operands[0], operands[1])); DONE; }\n+   }\")\n+\n (define_insn \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=&f\")\n \t(fix:DI (float_extend:DF\n@@ -4986,3 +5093,28 @@\n   \"\"\n   \"trapb\"\n   [(set_attr \"type\" \"misc\")])\n+\f\n+;; Peepholes go at the end.\n+\n+;; Optimize sign-extension of SImode loads.  This shows up in the wake of\n+;; reload when converting fp->int.\n+;;\n+;; ??? What to do when we are actually caring about the packing and\n+;; alignment of instructions?  Perhaps reload can be enlightened, or\n+;; the peephole pass moved up after reload but before sched2.\n+\n+(define_peephole\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (match_operand:SI 1 \"memory_operand\" \"m\"))\n+   (set (match_operand:DI 2 \"register_operand\" \"=r\")\n+        (sign_extend:DI (match_dup 0)))]\n+  \"dead_or_set_p (insn, operands[0])\"\n+  \"ldl %2,%1\")\n+\n+(define_peephole\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (match_operand:SI 1 \"hard_fp_register_operand\" \"f\"))\n+   (set (match_operand:DI 2 \"register_operand\" \"=r\")\n+        (sign_extend:DI (match_dup 0)))]\n+  \"TARGET_CIX && dead_or_set_p (insn, operands[0])\"\n+  \"ftois %1,%2\")"}]}