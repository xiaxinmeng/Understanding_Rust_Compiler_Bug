{"sha": "23249ac43c6d4d9dde16347bc44dc757e41f1d8d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjMyNDlhYzQzYzZkNGQ5ZGRlMTYzNDdiYzQ0ZGM3NTdlNDFmMWQ4ZA==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2006-05-19T21:18:23Z"}, "committer": {"name": "Kenneth Zadeck", "email": "zadeck@gcc.gnu.org", "date": "2006-05-19T21:18:23Z"}, "message": "re PR rtl-optimization/26855 (ICE in add_deps_for_def with -fmodulo-sched -maltivec)\n\n2006-05-19  Daniel Berlin  <dberlin@dberlin.org>\n            Kenneth Zadeck <zadeck@naturalbridge.com>\n\n\tPR rtl-optimization/26855\n\n\t* df-scan.c (mw_reg_pool, mw_link_pool): New allocation pools for\n\tmultiword refs.\n\t(df_scan_alloc): Added code to properly handle multiword hard\n\tregisters and add all_blocks parameter.\n\t(df_scan_free_internal, df_insn_refs_delete, df_ref_record): Added\n\tcode to properly handle multiword hard registers.\n\t(df_rescan_blocks): Added code to remove deleted blocks from\n\tbitmap.\n\t(df_ref_create_structure, df_ref_record): Added code to properly\n\thandle subregs.\n\t(df_ref_record_1): Changed DF_REF_CLOBBER into DF_REF_MUST_CLOBBER\n\tand set DF_REF_PARTIAL.\n\t(df_defs_record): Changed DF_REF_CLOBBER into DF_REF_MUST_CLOBBER.\n\t(df_uses_record): Added DF_REF_PARTIAL for subreg. \n\t(df_scan_add_problem): Added flags parameter.\n\t(df_ref_create_structure): Changed switching structure.\n\t(df_bb_refs_record): Fixed case where duplicate artificial refs\n\twere created.  Changed location of flags.\n\t(df_record_entry_block_defs): Added code to make stack pointer\n\tlive in entry block.  Refined cases where frame pointer is needed.\n\tChanged location of flags.\n\t(df_record_exit_block_uses, df_insn_refs_record): Changed location of flags.\n\t(df_set_state): Removed function.\n\t(df_grow_reg_info, df_reg_chain_unlink, df_ref_remove,\n\tdf_insn_create_insn_record, df_insn_refs_delete, \n\tdf_ref_create_structure): Formatting changes.  \n\t* df-core.c (df_mvs_dump, df_set_flags, df_clear_flags,\n\tdf_delete_basic_block): New function.\n\t(df_init): Changed location of flags.\n\t(df_add_problem): Added flags parameter and the way flags are\n\tprocessed.\n\t(df_insn_uid_debug, df_ref_debug, debug_df_defno, debug_df_ref,\n\tdebug_df_chain): Improved debugging output.\n\t(df_insn_debug, df_insn_uid_debug): Added multiword reg support.\n\t(df_refs_chain_dump): Removed df parameter.\n\t(df_iterative_dataflow): Added consistency check.\n\t(df_prune_to_subcfg): Made public.\n\t(df_analyze_problem): Added blocks_to_init parameter and made\n\tpublic.\n\t(df_ref_record, df_bb_refs_record, df_mark_reg, \n\t df_record_exit_block_uses): Whitespace changes.\n\t(df_dump): Whitespace changes.\n\t* df.h: Some reordering to remove forward references.\n\t(df_ref_flags.DF_REF_MW_HARDREG, DF_REF_PARTIAL,\n\tDF_REF_MUST_CLOBBER, DF_REF_MAY_CLOBBER): New fields.\n\t(df_ref_flags.DF_REF_CLOBBER): Deleted field.\n\t(dataflow.flags): New field.\n\t(df.flag): Deleted field.\n\t(df_alloc_function): Added additional bitmap parameter.\n\t(df_dependent_problem_function): New type.\n\t(df_problem.changeable_flags): New field.\n\t(df_ref_flags.DF_REF_DIES_AFTER_THIS_USE, DF_SCAN_INITIAL,\n\tDF_SCAN_GLOBAL, DF_SCAN_POST_ALLOC, df_state): Removed.\n\t(df_mw_hardreg): New struct.\n\t(DF_INSN_UID_MWS): New macro.\n\t(df_refs_chain_dump, df_ref_debug, df_chain_dump): Removed df\n\tparameter.\n\t(df_add_problem, df_ru_add_problem, df_rd_add_problem,\n\tdf_lr_add_problem, df_ur_add_problem, df_urec_add_problem,\n\tdf_ri_add_problem, df_scan_add_problem): Added flags parameter.\n\t(df_set_state): Removed function.\n\t(df_set_flags, df_clear_flags, df_delete_basic_block) New functions.\n\t* df-problems.c (df_chain_dump): Removed df parameter.\n\t(df_ru_alloc, df_rd_alloc, df_lr_alloc, df_ur_alloc,\n\tdf_urec_alloc, df_chain_alloc, df_ri_alloc): Added all blocks\n\tparameter.\n\t(df_ru_alloc, df_rd_alloc): Now resets all blocks.\n\t(df_rd_bb_local_compute_process_def, df_ur_bb_local_compute,\n\tdf_chain_create_bb, df_create_unused_note, df_ri_bb_compute):\n\tSplit DF_REF_CLOBBER into DF_REF_MAY_CLOBBER and\n\tDF_REF_MUST_CLOBBER cases.\n\t(df_ru_bb_local_compute_process_def,\n\tdf_rd_bb_local_compute_process_def, df_lr_bb_local_compute,\n\tdf_lr_bb_local_compute, df_ur_bb_local_compute,\n\tdf_chain_create_bb): Made subreg aware.\n\t(df_ru_bb_local_compute, df_rd_bb_local_compute,\n\tdf_lr_bb_local_compute, df_lr_bb_local_compute,\n\tdf_chain_create_bb): Cleanup to use proper macros.\n\t(df_ur_local_finalize, df_urec_local_finalize): Removed unnecessary\n\tcode to fixup bitvectors.\n\t(df_ri_alloc): Cleared lifetime.\n\t(df_ignore_stack_reg, df_kill_notes, df_set_notes_for_mw,\n\tdf_create_unused_note): New function.\n\t(df_ri_bb_compute, df_ri_compute): Added code to create/update\n\tREG_DEAD and REG_UNUSED notes as well as register information.\n\t(df_ru_dump, df_rd_dump, df_lr_dump, df_ur_dump, df_urec_dump,\n\tdf_chains_dump): Fixed crash if problem was never run.\n\t(df_ru_add_problem, df_rd_add_problem, df_lr_add_problem,\n\tdf_ur_add_problem, df_urec_add_problem, df_chain_add_problem,\n\tdf_ri_add_problem): Processes flags in uniform manner.\n\t(df_ru_alloc, df_ru_local_compute, df_ru_confluence_n, df_ru_free,\n\tdf_ru_dump, df_rd_local_compute, df_rd_confluence_n, df_rd_free,\n\tdf_rd_dump, df_urec_free_bb_info): Formatting changes.\n\t(df_ru_free_bb_info, df_ru_bb_local_compute, df_ru_dump,\n\tdf_rd_free_bb_info, df_rd_bb_local_compute_process_def,\n\tdf_rd_bb_local_compute, df_rd_dump, df_lr_free_bb_info,\n\tdf_lr_bb_local_compute, df_lr_local_compute, df_ur_free_bb_info,\n\tdf_ur_dump, df_urec_free_bb_info, df_urec_dump,\n\tdf_chain_create_bb, df_ri_bb_compute): Whitespace changes.\n\t* modulo-sched.c (sms_schedule): Added flag parameter to calls.\n\t* see.c (see_initialize_data): Ditto.\n\t* final.c (rest_of_clean_state) Added regstack_completed.\n\t* rtl.h (regstack_completed): Ditto.\n\t* reg-stack.c (regstack_completed): Ditto.\n\nFrom-SVN: r113915", "tree": {"sha": "46c1322fa64c2c9e1ac1a3a67befc79d25478490", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/46c1322fa64c2c9e1ac1a3a67befc79d25478490"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/23249ac43c6d4d9dde16347bc44dc757e41f1d8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23249ac43c6d4d9dde16347bc44dc757e41f1d8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23249ac43c6d4d9dde16347bc44dc757e41f1d8d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23249ac43c6d4d9dde16347bc44dc757e41f1d8d/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d593cb3da7ebc6246c3da0ef3b46292b20d9f233", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d593cb3da7ebc6246c3da0ef3b46292b20d9f233", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d593cb3da7ebc6246c3da0ef3b46292b20d9f233"}], "stats": {"total": 1827, "additions": 1286, "deletions": 541}, "files": [{"sha": "1d4aff2315feddfc76d6dc7c3cbb44c8465b6451", "filename": "gcc/df-core.c", "status": "modified", "additions": 128, "deletions": 38, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23249ac43c6d4d9dde16347bc44dc757e41f1d8d/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23249ac43c6d4d9dde16347bc44dc757e41f1d8d/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=23249ac43c6d4d9dde16347bc44dc757e41f1d8d", "patch": "@@ -45,7 +45,7 @@ Here is an example of using the dataflow routines.\n \n       df = df_init (init_flags);\n       \n-      df_add_problem (df, problem);\n+      df_add_problem (df, problem, flags);\n \n       df_set_blocks (df, blocks);\n \n@@ -63,21 +63,20 @@ DF_INIT simply creates a poor man's object (df) that needs to be\n passed to all the dataflow routines.  df_finish destroys this object\n and frees up any allocated memory.\n \n-There are two flags that can be passed to df_init:\n-\n-DF_NO_SCAN means that no scanning of the rtl code is performed.  This\n-is used if the problem instance is to do it's own scanning.\n+There are three flags that can be passed to df_init, each of these\n+flags controls the scanning of the rtl:\n \n DF_HARD_REGS means that the scanning is to build information about\n both pseudo registers and hardware registers.  Without this\n information, the problems will be solved only on pseudo registers.\n-\n+DF_EQUIV_NOTES marks the uses present in EQUIV/EQUAL notes.\n+DF_SUBREGS return subregs rather than the inner reg.\n \n \n DF_ADD_PROBLEM adds a problem, defined by an instance to struct\n df_problem, to the set of problems solved in this instance of df.  All\n calls to add a problem for a given instance of df must occur before\n-the first call to DF_RESCAN_BLOCKS or DF_ANALYZE.\n+the first call to DF_RESCAN_BLOCKS, DF_SET_BLOCKS or DF_ANALYZE.\n \n For all of the problems defined in df-problems.c, there are\n convenience functions named DF_*_ADD_PROBLEM.\n@@ -297,7 +296,7 @@ are write-only operations.\n static struct df *ddf = NULL;\n struct df *shared_df = NULL;\n \n-static void * df_get_bb_info (struct dataflow *, unsigned int);\n+static void *df_get_bb_info (struct dataflow *, unsigned int);\n static void df_set_bb_info (struct dataflow *, unsigned int, void *);\n /*----------------------------------------------------------------------------\n   Functions to create, destroy and manipulate an instance of df.\n@@ -311,28 +310,27 @@ struct df *\n df_init (int flags)\n {\n   struct df *df = XCNEW (struct df);\n-  df->flags = flags;\n \n   /* This is executed once per compilation to initialize platform\n      specific data structures. */\n   df_hard_reg_init ();\n   \n   /* All df instance must define the scanning problem.  */\n-  df_scan_add_problem (df);\n+  df_scan_add_problem (df, flags);\n   ddf = df;\n   return df;\n }\n \n /* Add PROBLEM to the DF instance.  */\n \n struct dataflow *\n-df_add_problem (struct df *df, struct df_problem *problem)\n+df_add_problem (struct df *df, struct df_problem *problem, int flags)\n {\n   struct dataflow *dflow;\n \n   /* First try to add the dependent problem. */\n-  if (problem->dependent_problem)\n-    df_add_problem (df, problem->dependent_problem);\n+  if (problem->dependent_problem_fun)\n+    (problem->dependent_problem_fun) (df, 0);\n \n   /* Check to see if this problem has already been defined.  If it\n      has, just return that instance, if not, add it to the end of the\n@@ -343,6 +341,7 @@ df_add_problem (struct df *df, struct df_problem *problem)\n \n   /* Make a new one and add it to the end.  */\n   dflow = XCNEW (struct dataflow);\n+  dflow->flags = flags;\n   dflow->df = df;\n   dflow->problem = problem;\n   df->problems_in_order[df->num_problems_defined++] = dflow;\n@@ -352,6 +351,36 @@ df_add_problem (struct df *df, struct df_problem *problem)\n }\n \n \n+/* Set the MASK flags in the DFLOW problem.  The old flags are\n+   returned.  If a flag is not allowed to be changed this will fail if\n+   checking is enabled.  */\n+int \n+df_set_flags (struct dataflow *dflow, int mask)\n+{\n+  int old_flags = dflow->flags;\n+\n+  gcc_assert (!(mask & (~dflow->problem->changeable_flags)));\n+\n+  dflow->flags |= mask;\n+\n+  return old_flags;\n+}\n+\n+/* Clear the MASK flags in the DFLOW problem.  The old flags are\n+   returned.  If a flag is not allowed to be changed this will fail if\n+   checking is enabled.  */\n+int \n+df_clear_flags (struct dataflow *dflow, int mask)\n+{\n+  int old_flags = dflow->flags;\n+\n+  gcc_assert (!(mask & (~dflow->problem->changeable_flags)));\n+\n+  dflow->flags &= !mask;\n+\n+  return old_flags;\n+}\n+\n /* Set the blocks that are to be considered for analysis.  If this is\n    not called or is called with null, the entire function in\n    analyzed.  */\n@@ -435,6 +464,26 @@ df_set_blocks (struct df *df, bitmap blocks)\n }\n \n \n+/* Free all of the per basic block dataflow from all of the problems.\n+   This is typically called before a basic block is deleted and the\n+   problem will be reanalyzed.  */\n+\n+void\n+df_delete_basic_block (struct df *df, int bb_index)\n+{\n+  basic_block bb = BASIC_BLOCK (bb_index);\n+  int i;\n+  \n+  for (i = 0; i < df->num_problems_defined; i++)\n+    {\n+      struct dataflow *dflow = df->problems_in_order[i];\n+      if (dflow->problem->free_bb_fun)\n+\tdflow->problem->free_bb_fun \n+\t  (dflow, bb, df_get_bb_info (dflow, bb_index)); \n+    }\n+}\n+\n+\n /* Free all the dataflow info and the DF structure.  This should be\n    called from the df_finish macro which also NULLs the parm.  */\n \n@@ -594,6 +643,8 @@ df_iterative_dataflow (struct dataflow *dataflow,\n   sbitmap_zero (pending);\n   sbitmap_zero (considered);\n \n+  gcc_assert (dataflow->problem->dir);\n+\n   EXECUTE_IF_SET_IN_BITMAP (blocks_to_consider, 0, idx, bi)\n     {\n       SET_BIT (considered, idx);\n@@ -696,7 +747,7 @@ df_prune_to_subcfg (int list[], unsigned len, bitmap blocks)\n    small fixup     fringe                sub               sub\n */\n \n-static void\n+void\n df_analyze_problem (struct dataflow *dflow, \n \t\t    bitmap blocks_to_consider, \n \t\t    bitmap blocks_to_init,\n@@ -705,7 +756,7 @@ df_analyze_problem (struct dataflow *dflow,\n {\n   /* (Re)Allocate the datastructures necessary to solve the problem.  */ \n   if (dflow->problem->alloc_fun)\n-    dflow->problem->alloc_fun (dflow, blocks_to_scan);\n+    dflow->problem->alloc_fun (dflow, blocks_to_scan, blocks_to_init);\n \n   /* Set up the problem and compute the local information.  This\n      function is passed both the blocks_to_consider and the\n@@ -1066,7 +1117,7 @@ df_dump (struct df *df, FILE *file)\n {\n   int i;\n \n-  if (! df || ! file)\n+  if (!df || !file)\n     return;\n \n   fprintf (file, \"\\n\\n%s\\n\", current_function_name ());\n@@ -1082,8 +1133,7 @@ df_dump (struct df *df, FILE *file)\n \n \n void\n-df_refs_chain_dump (struct df *df, struct df_ref *ref, \n-\t\t   bool follow_chain, FILE *file)\n+df_refs_chain_dump (struct df_ref *ref, bool follow_chain, FILE *file)\n {\n   fprintf (file, \"{ \");\n   while (ref)\n@@ -1093,7 +1143,7 @@ df_refs_chain_dump (struct df *df, struct df_ref *ref,\n \t       DF_REF_ID (ref),\n \t       DF_REF_REGNO (ref));\n       if (follow_chain)\n-\tdf_chain_dump (df, DF_REF_CHAIN (ref), file);\n+\tdf_chain_dump (DF_REF_CHAIN (ref), file);\n       ref = ref->next_ref;\n     }\n   fprintf (file, \"}\");\n@@ -1118,13 +1168,32 @@ df_regs_chain_dump (struct df *df ATTRIBUTE_UNUSED, struct df_ref *ref,  FILE *f\n }\n \n \n-void\n-df_insn_debug (struct df *df, rtx insn, bool follow_chain, FILE *file)\n+static void\n+df_mws_dump (struct df_mw_hardreg *mws, FILE *file)\n {\n-  unsigned int uid;\n-  int bbi;\n+  while (mws)\n+    {\n+      struct df_link *regs = mws->regs;\n+      fprintf (file, \"%c%d(\", \n+\t       (mws->type == DF_REF_REG_DEF) ? 'd' : 'u',\n+\t       DF_REF_REGNO (regs->ref));\n+      while (regs)\n+\t{\n+\t  fprintf (file, \"%d \", DF_REF_REGNO (regs->ref));\n+\t  regs = regs->next;\n+\t}\n \n-  uid = INSN_UID (insn);\n+      fprintf (file, \") \"); \n+      mws = mws->next;\n+    }\n+}\n+\n+\n+static void \n+df_insn_uid_debug (struct df *df, unsigned int uid, \n+\t\t   bool follow_chain, FILE *file)\n+{\n+  int bbi;\n \n   if (DF_INSN_UID_DEFS (df, uid))\n     bbi = DF_REF_BBNO (DF_INSN_UID_DEFS (df, uid));\n@@ -1133,15 +1202,36 @@ df_insn_debug (struct df *df, rtx insn, bool follow_chain, FILE *file)\n   else\n     bbi = -1;\n \n-  fprintf (file, \"insn %d bb %d luid %d defs \",\n-\t   uid, bbi, DF_INSN_LUID (df, insn));\n+  fprintf (file, \"insn %d bb %d luid %d\",\n+\t   uid, bbi, DF_INSN_UID_LUID (df, uid));\n \n-  df_refs_chain_dump (df, DF_INSN_UID_DEFS (df, uid), follow_chain, file);\n-  fprintf (file, \" defs \");\n-  df_refs_chain_dump (df, DF_INSN_UID_USES (df, uid), follow_chain, file);\n+  if (DF_INSN_UID_DEFS (df, uid))\n+    {\n+      fprintf (file, \" defs \");\n+      df_refs_chain_dump (DF_INSN_UID_DEFS (df, uid), follow_chain, file);\n+    }\n+\n+  if (DF_INSN_UID_USES (df, uid))\n+    {\n+      fprintf (file, \" uses \");\n+      df_refs_chain_dump (DF_INSN_UID_USES (df, uid), follow_chain, file);\n+    }\n+\n+  if (DF_INSN_UID_MWS (df, uid))\n+    {\n+      fprintf (file, \" mws \");\n+      df_mws_dump (DF_INSN_UID_MWS (df, uid), file);\n+    }\n   fprintf (file, \"\\n\");\n }\n \n+\n+void\n+df_insn_debug (struct df *df, rtx insn, bool follow_chain, FILE *file)\n+{\n+  df_insn_uid_debug (df, INSN_UID (insn), follow_chain, file);\n+}\n+\n void\n df_insn_debug_regno (struct df *df, rtx insn, FILE *file)\n {\n@@ -1177,17 +1267,17 @@ df_regno_debug (struct df *df, unsigned int regno, FILE *file)\n \n \n void\n-df_ref_debug (struct df *df, struct df_ref *ref, FILE *file)\n+df_ref_debug (struct df_ref *ref, FILE *file)\n {\n   fprintf (file, \"%c%d \",\n \t   DF_REF_REG_DEF_P (ref) ? 'd' : 'u',\n \t   DF_REF_ID (ref));\n-  fprintf (file, \"reg %d bb %d luid %d insn %d chain \",\n+  fprintf (file, \"reg %d bb %d insn %d flag %x chain \",\n \t   DF_REF_REGNO (ref),\n \t   DF_REF_BBNO (ref),\n-\t   DF_REF_INSN (ref) ? DF_INSN_LUID (df, DF_REF_INSN (ref)) : -1,\n-\t   DF_REF_INSN (ref) ? INSN_UID (DF_REF_INSN (ref)) : -1);\n-  df_chain_dump (df, DF_REF_CHAIN (ref), file);\n+\t   DF_REF_INSN (ref) ? INSN_UID (DF_REF_INSN (ref)) : -1,\n+\t   DF_REF_FLAGS (ref));\n+  df_chain_dump (DF_REF_CHAIN (ref), file);\n   fprintf (file, \"\\n\");\n }\n \f\n@@ -1218,27 +1308,27 @@ debug_df_regno (unsigned int regno)\n void\n debug_df_ref (struct df_ref *ref)\n {\n-  df_ref_debug (ddf, ref, stderr);\n+  df_ref_debug (ref, stderr);\n }\n \n \n void\n debug_df_defno (unsigned int defno)\n {\n-  df_ref_debug (ddf, DF_DEFS_GET (ddf, defno), stderr);\n+  df_ref_debug (DF_DEFS_GET (ddf, defno), stderr);\n }\n \n \n void\n debug_df_useno (unsigned int defno)\n {\n-  df_ref_debug (ddf, DF_USES_GET (ddf, defno), stderr);\n+  df_ref_debug (DF_USES_GET (ddf, defno), stderr);\n }\n \n \n void\n debug_df_chain (struct df_link *link)\n {\n-  df_chain_dump (ddf, link, stderr);\n+  df_chain_dump (link, stderr);\n   fputc ('\\n', stderr);\n }"}, {"sha": "8c5ed6d7bd3863dd8c2aef16d76a6a763dd11c40", "filename": "gcc/df-problems.c", "status": "modified", "additions": 749, "deletions": 249, "changes": 998, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23249ac43c6d4d9dde16347bc44dc757e41f1d8d/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23249ac43c6d4d9dde16347bc44dc757e41f1d8d/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=23249ac43c6d4d9dde16347bc44dc757e41f1d8d", "patch": "@@ -43,30 +43,23 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"timevar.h\"\n #include \"df.h\"\n #include \"vecprim.h\"\n+#include \"except.h\"\n+\n+#if 0\n+#define REG_DEAD_DEBUGGING\n+#endif\n \n #define DF_SPARSE_THRESHOLD 32\n \n static bitmap seen_in_block = NULL;\n static bitmap seen_in_insn = NULL;\n+static void df_ri_dump (struct dataflow *, FILE *);\n \n \f\n /*----------------------------------------------------------------------------\n    Public functions access functions for the dataflow problems.\n ----------------------------------------------------------------------------*/\n \n-/* Get the instance of the problem that DFLOW is dependent on.  */\n-\n-struct dataflow *\n-df_get_dependent_problem (struct dataflow *dflow)\n-{\n-  struct df *df = dflow->df;\n-  struct df_problem *dependent_problem = dflow->problem->dependent_problem;\n-\n-  gcc_assert (dependent_problem);\n-  return df->problems_by_index[dependent_problem->id];\n-}\n-\n-\n /* Create a du or ud chain from SRC to DST and link it into SRC.   */\n \n struct df_link *\n@@ -207,7 +200,7 @@ df_grow_bb_info (struct dataflow *dflow)\n /* Dump a def-use or use-def chain for REF to FILE.  */\n \n void\n-df_chain_dump (struct df *df ATTRIBUTE_UNUSED, struct df_link *link, FILE *file)\n+df_chain_dump (struct df_link *link, FILE *file)\n {\n   fprintf (file, \"{ \");\n   for (; link; link = link->next)\n@@ -346,21 +339,23 @@ df_ru_free_bb_info (struct dataflow *dflow,\n    not touched unless the block is new.  */\n \n static void \n-df_ru_alloc (struct dataflow *dflow, bitmap blocks_to_rescan)\n+df_ru_alloc (struct dataflow *dflow, \n+\t     bitmap blocks_to_rescan ATTRIBUTE_UNUSED,\n+\t     bitmap all_blocks)\n {\n   unsigned int bb_index;\n   bitmap_iterator bi;\n   unsigned int reg_size = max_reg_num ();\n \n-  if (! dflow->block_pool)\n+  if (!dflow->block_pool)\n     dflow->block_pool = create_alloc_pool (\"df_ru_block pool\", \n \t\t\t\t\t   sizeof (struct df_ru_bb_info), 50);\n \n   if (dflow->problem_data)\n     {\n       unsigned int i;\n-      struct df_ru_problem_data *problem_data =\n-\t(struct df_ru_problem_data *) dflow->problem_data;\n+      struct df_ru_problem_data *problem_data\n+\t= (struct df_ru_problem_data *) dflow->problem_data;\n \n       for (i = 0; i < problem_data->use_sites_size; i++)\n \t{\n@@ -401,7 +396,7 @@ df_ru_alloc (struct dataflow *dflow, bitmap blocks_to_rescan)\n      we have to process all of the blocks before doing the\n      analysis.  */\n \n-  EXECUTE_IF_SET_IN_BITMAP (blocks_to_rescan, 0, bb_index, bi)\n+  EXECUTE_IF_SET_IN_BITMAP (all_blocks, 0, bb_index, bi)\n     {\n       struct df_ru_bb_info *bb_info = df_ru_get_bb_info (dflow, bb_index);\n       if (bb_info)\n@@ -435,7 +430,10 @@ df_ru_bb_local_compute_process_def (struct dataflow *dflow,\n   struct df *df = dflow->df;\n   while (def)\n     {\n-      if (top_flag == (DF_REF_FLAGS (def) & DF_REF_AT_TOP))\n+      if ((top_flag == (DF_REF_FLAGS (def) & DF_REF_AT_TOP))\n+\t  /* If the def is to only part of the reg, it is as if it did\n+\t     not happen, since some of the bits may get thru.  */\n+\t  && (!(DF_REF_FLAGS (def) & DF_REF_PARTIAL)))\n \t{\n \t  unsigned int regno = DF_REF_REGNO (def);\n \t  unsigned int begin = DF_REG_USE_GET (df, regno)->begin;\n@@ -453,10 +451,10 @@ df_ru_bb_local_compute_process_def (struct dataflow *dflow,\n \t\t    }\n \t\t  else\n \t\t    {\n-\t\t      struct df_ru_problem_data * problem_data =\n-\t\t\t(struct df_ru_problem_data *)dflow->problem_data;\n-\t\t      bitmap uses = \n-\t\t\tdf_ref_bitmap (problem_data->use_sites, regno, \n+\t\t      struct df_ru_problem_data * problem_data\n+\t\t\t= (struct df_ru_problem_data *)dflow->problem_data;\n+\t\t      bitmap uses \n+\t\t\t= df_ref_bitmap (problem_data->use_sites, regno, \n \t\t\t\t       begin, n_uses);\n \t\t      bitmap_ior_into (bb_info->kill, uses);\n \t\t      bitmap_and_compl_into (bb_info->gen, uses);\n@@ -519,18 +517,18 @@ df_ru_bb_local_compute (struct dataflow *dflow, unsigned int bb_index)\n   FOR_BB_INSNS (bb, insn)\n     {\n       unsigned int uid = INSN_UID (insn);\n-      if (! INSN_P (insn))\n+      if (!INSN_P (insn))\n \tcontinue;\n \n       df_ru_bb_local_compute_process_def (dflow, bb_info, \n-\t\t\t\t\t  DF_INSN_UID_GET (df, uid)->defs, 0);\n+\t\t\t\t\t  DF_INSN_UID_DEFS (df, uid), 0);\n \n       /* The use processing must happen after the defs processing even\n \t though the uses logically happen first since the defs clear\n \t the gen set. Otherwise, a use for regno occuring in the same\n \t instruction as a def for regno would be cleared.  */ \n       df_ru_bb_local_compute_process_use (bb_info, \n-\t\t\t\t\t  DF_INSN_UID_GET (df, uid)->uses, 0);\n+\t\t\t\t\t  DF_INSN_UID_USES (df, uid), 0);\n \n       bitmap_ior_into (seen_in_block, seen_in_insn);\n       bitmap_clear (seen_in_insn);\n@@ -556,8 +554,8 @@ df_ru_local_compute (struct dataflow *dflow,\n   unsigned int bb_index;\n   bitmap_iterator bi;\n   unsigned int regno;\n-  struct df_ru_problem_data *problem_data =\n-    (struct df_ru_problem_data *) dflow->problem_data;\n+  struct df_ru_problem_data *problem_data\n+    = (struct df_ru_problem_data *) dflow->problem_data;\n   bitmap sparse_invalidated = problem_data->sparse_invalidated_by_call;\n   bitmap dense_invalidated = problem_data->dense_invalidated_by_call;\n \n@@ -616,8 +614,8 @@ df_ru_confluence_n (struct dataflow *dflow, edge e)\n \n   if (e->flags & EDGE_EH)\n     {\n-      struct df_ru_problem_data *problem_data =\n-\t(struct df_ru_problem_data *) dflow->problem_data;\n+      struct df_ru_problem_data *problem_data\n+\t= (struct df_ru_problem_data *) dflow->problem_data;\n       bitmap sparse_invalidated = problem_data->sparse_invalidated_by_call;\n       bitmap dense_invalidated = problem_data->dense_invalidated_by_call;\n       struct df *df = dflow->df;\n@@ -691,8 +689,8 @@ static void\n df_ru_free (struct dataflow *dflow)\n {\n   unsigned int i;\n-  struct df_ru_problem_data *problem_data =\n-    (struct df_ru_problem_data *) dflow->problem_data;\n+  struct df_ru_problem_data *problem_data\n+    = (struct df_ru_problem_data *) dflow->problem_data;\n \n   if (problem_data)\n     {\n@@ -737,10 +735,13 @@ df_ru_dump (struct dataflow *dflow, FILE *file)\n {\n   basic_block bb;\n   struct df *df = dflow->df;\n-  struct df_ru_problem_data *problem_data =\n-    (struct df_ru_problem_data *) dflow->problem_data;\n+  struct df_ru_problem_data *problem_data\n+    = (struct df_ru_problem_data *) dflow->problem_data;\n   unsigned int m = max_reg_num ();\n   unsigned int regno;\n+  \n+  if (!dflow->block_info) \n+    return;\n \n   fprintf (file, \"Reaching uses:\\n\");\n \n@@ -761,7 +762,7 @@ df_ru_dump (struct dataflow *dflow, FILE *file)\n       struct df_ru_bb_info *bb_info = df_ru_get_bb_info (dflow, bb->index);\n       df_print_bb_index (bb, file);\n       \n-      if (! bb_info->in)\n+      if (!bb_info->in)\n \tcontinue;\n       \n       fprintf (file, \"  in  \\t\");\n@@ -793,7 +794,8 @@ static struct df_problem problem_RU =\n   NULL,                       /* Finalize function.  */\n   df_ru_free,                 /* Free all of the problem information.  */\n   df_ru_dump,                 /* Debugging.  */\n-  NULL                        /* Dependent problem.  */\n+  NULL,                       /* Dependent problem.  */\n+  0                           /* Changeable flags.  */\n };\n \n \n@@ -803,9 +805,9 @@ static struct df_problem problem_RU =\n    solution.  */\n \n struct dataflow *\n-df_ru_add_problem (struct df *df)\n+df_ru_add_problem (struct df *df, int flags)\n {\n-  return df_add_problem (df, &problem_RU);\n+  return df_add_problem (df, &problem_RU, flags);\n }\n \n \f\n@@ -869,21 +871,23 @@ df_rd_free_bb_info (struct dataflow *dflow,\n    not touched unless the block is new.  */\n \n static void \n-df_rd_alloc (struct dataflow *dflow, bitmap blocks_to_rescan)\n+df_rd_alloc (struct dataflow *dflow, \n+\t     bitmap blocks_to_rescan ATTRIBUTE_UNUSED,\n+\t     bitmap all_blocks)\n {\n   unsigned int bb_index;\n   bitmap_iterator bi;\n   unsigned int reg_size = max_reg_num ();\n \n-  if (! dflow->block_pool)\n+  if (!dflow->block_pool)\n     dflow->block_pool = create_alloc_pool (\"df_rd_block pool\", \n \t\t\t\t\t   sizeof (struct df_rd_bb_info), 50);\n \n   if (dflow->problem_data)\n     {\n       unsigned int i;\n-      struct df_rd_problem_data *problem_data =\n-\t(struct df_rd_problem_data *) dflow->problem_data;\n+      struct df_rd_problem_data *problem_data\n+\t= (struct df_rd_problem_data *) dflow->problem_data;\n \n       for (i = 0; i < problem_data->def_sites_size; i++)\n \t{\n@@ -920,11 +924,11 @@ df_rd_alloc (struct dataflow *dflow, bitmap blocks_to_rescan)\n \n   df_grow_bb_info (dflow);\n \n-  /* Because of the clustering of all def sites for the same pseudo,\n+  /* Because of the clustering of all use sites for the same pseudo,\n      we have to process all of the blocks before doing the\n      analysis.  */\n \n-  EXECUTE_IF_SET_IN_BITMAP (blocks_to_rescan, 0, bb_index, bi)\n+  EXECUTE_IF_SET_IN_BITMAP (all_blocks, 0, bb_index, bi)\n     {\n       struct df_rd_bb_info *bb_info = df_rd_get_bb_info (dflow, bb_index);\n       if (bb_info)\n@@ -970,7 +974,11 @@ df_rd_bb_local_compute_process_def (struct dataflow *dflow,\n \t    {\n \t      /* The first def for regno in insn gets to knock out the\n \t\t defs from other instructions.  */\n-\t      if (!bitmap_bit_p (seen_in_insn, regno))\n+\t      if ((!bitmap_bit_p (seen_in_insn, regno))\n+\t\t  /* If the def is to only part of the reg, it does\n+\t\t     not kill the other defs that reach here.  */\n+\t\t  && (!((DF_REF_FLAGS (def) & DF_REF_PARTIAL)\n+\t\t\t || (DF_REF_FLAGS (def) & DF_REF_MAY_CLOBBER))))\n \t\t{\n \t\t  if (n_defs > DF_SPARSE_THRESHOLD)\n \t\t    {\n@@ -979,11 +987,10 @@ df_rd_bb_local_compute_process_def (struct dataflow *dflow,\n \t\t    }\n \t\t  else\n \t\t    {\n-\t\t      struct df_rd_problem_data * problem_data =\n-\t\t\t(struct df_rd_problem_data *)dflow->problem_data;\n-\t\t      bitmap defs = \n-\t\t\tdf_ref_bitmap (problem_data->def_sites, regno, \n-\t\t\t\t       begin, n_defs);\n+\t\t      struct df_rd_problem_data * problem_data\n+\t\t\t= (struct df_rd_problem_data *)dflow->problem_data;\n+\t\t      bitmap defs = df_ref_bitmap (problem_data->def_sites, \n+\t\t\t\t\t\t   regno, begin, n_defs);\n \t\t      bitmap_ior_into (bb_info->kill, defs);\n \t\t      bitmap_and_compl_into (bb_info->gen, defs);\n \t\t    }\n@@ -992,7 +999,8 @@ df_rd_bb_local_compute_process_def (struct dataflow *dflow,\n \t      bitmap_set_bit (seen_in_insn, regno);\n \t      /* All defs for regno in the instruction may be put into\n \t\t the gen set.  */\n-\t      if (! (DF_REF_FLAGS (def) & DF_REF_CLOBBER))\n+\t      if (!(DF_REF_FLAGS (def) \n+\t\t     & (DF_REF_MUST_CLOBBER | DF_REF_MAY_CLOBBER)))\n \t\tbitmap_set_bit (bb_info->gen, DF_REF_ID (def));\n \t    }\n \t}\n@@ -1020,11 +1028,11 @@ df_rd_bb_local_compute (struct dataflow *dflow, unsigned int bb_index)\n     {\n       unsigned int uid = INSN_UID (insn);\n \n-      if (! INSN_P (insn))\n+      if (!INSN_P (insn))\n \tcontinue;\n \n       df_rd_bb_local_compute_process_def (dflow, bb_info, \n-\t\t\t\t\t  DF_INSN_UID_GET (df, uid)->defs, 0);\n+\t\t\t\t\t  DF_INSN_UID_DEFS (df, uid), 0);\n \n       /* This complex dance with the two bitmaps is required because\n \t instructions can assign twice to the same pseudo.  This\n@@ -1056,8 +1064,8 @@ df_rd_local_compute (struct dataflow *dflow,\n   unsigned int bb_index;\n   bitmap_iterator bi;\n   unsigned int regno;\n-  struct df_rd_problem_data *problem_data =\n-    (struct df_rd_problem_data *) dflow->problem_data;\n+  struct df_rd_problem_data *problem_data\n+    = (struct df_rd_problem_data *) dflow->problem_data;\n   bitmap sparse_invalidated = problem_data->sparse_invalidated_by_call;\n   bitmap dense_invalidated = problem_data->dense_invalidated_by_call;\n \n@@ -1117,8 +1125,8 @@ df_rd_confluence_n (struct dataflow *dflow, edge e)\n \n   if (e->flags & EDGE_EH)\n     {\n-      struct df_rd_problem_data *problem_data =\n-\t(struct df_rd_problem_data *) dflow->problem_data;\n+      struct df_rd_problem_data *problem_data\n+\t= (struct df_rd_problem_data *) dflow->problem_data;\n       bitmap sparse_invalidated = problem_data->sparse_invalidated_by_call;\n       bitmap dense_invalidated = problem_data->dense_invalidated_by_call;\n       struct df *df = dflow->df;\n@@ -1192,8 +1200,8 @@ static void\n df_rd_free (struct dataflow *dflow)\n {\n   unsigned int i;\n-  struct df_rd_problem_data *problem_data =\n-    (struct df_rd_problem_data *) dflow->problem_data;\n+  struct df_rd_problem_data *problem_data\n+    = (struct df_rd_problem_data *) dflow->problem_data;\n \n   if (problem_data)\n     {\n@@ -1238,11 +1246,14 @@ df_rd_dump (struct dataflow *dflow, FILE *file)\n {\n   struct df *df = dflow->df;\n   basic_block bb;\n-  struct df_rd_problem_data *problem_data =\n-    (struct df_rd_problem_data *) dflow->problem_data;\n+  struct df_rd_problem_data *problem_data\n+    = (struct df_rd_problem_data *) dflow->problem_data;\n   unsigned int m = max_reg_num ();\n   unsigned int regno;\n   \n+  if (!dflow->block_info) \n+    return;\n+\n   fprintf (file, \"Reaching defs:\\n\\n\");\n \n   fprintf (file, \"  sparse invalidated \\t\");\n@@ -1262,7 +1273,7 @@ df_rd_dump (struct dataflow *dflow, FILE *file)\n       struct df_rd_bb_info *bb_info = df_rd_get_bb_info (dflow, bb->index);\n       df_print_bb_index (bb, file);\n       \n-      if (! bb_info->in)\n+      if (!bb_info->in)\n \tcontinue;\n       \n       fprintf (file, \"  in\\t(%d)\\n\", (int) bitmap_count_bits (bb_info->in));\n@@ -1294,7 +1305,8 @@ static struct df_problem problem_RD =\n   NULL,                       /* Finalize function.  */\n   df_rd_free,                 /* Free all of the problem information.  */\n   df_rd_dump,                 /* Debugging.  */\n-  NULL                        /* Dependent problem.  */\n+  NULL,                       /* Dependent problem.  */\n+  0                           /* Changeable flags.  */\n };\n \n \n@@ -1304,9 +1316,9 @@ static struct df_problem problem_RD =\n    solution.  */\n \n struct dataflow *\n-df_rd_add_problem (struct df *df)\n+df_rd_add_problem (struct df *df, int flags)\n {\n-  return df_add_problem (df, &problem_RD);\n+  return df_add_problem (df, &problem_RD, flags);\n }\n \n \n@@ -1360,21 +1372,18 @@ df_lr_free_bb_info (struct dataflow *dflow,\n    not touched unless the block is new.  */\n \n static void \n-df_lr_alloc (struct dataflow *dflow, bitmap blocks_to_rescan)\n+df_lr_alloc (struct dataflow *dflow, bitmap blocks_to_rescan,\n+\t     bitmap all_blocks ATTRIBUTE_UNUSED)\n {\n   unsigned int bb_index;\n   bitmap_iterator bi;\n \n-  if (! dflow->block_pool)\n+  if (!dflow->block_pool)\n     dflow->block_pool = create_alloc_pool (\"df_lr_block pool\", \n \t\t\t\t\t   sizeof (struct df_lr_bb_info), 50);\n \n   df_grow_bb_info (dflow);\n \n-  /* Because of the clustering of all def sites for the same pseudo,\n-     we have to process all of the blocks before doing the\n-     analysis.  */\n-\n   EXECUTE_IF_SET_IN_BITMAP (blocks_to_rescan, 0, bb_index, bi)\n     {\n       struct df_lr_bb_info *bb_info = df_lr_get_bb_info (dflow, bb_index);\n@@ -1410,7 +1419,8 @@ df_lr_bb_local_compute (struct dataflow *dflow,\n \n   /* Process the registers set in an exception handler.  */\n   for (def = df_get_artificial_defs (df, bb_index); def; def = def->next_ref)\n-    if ((DF_REF_FLAGS (def) & DF_REF_AT_TOP) == 0)\n+    if (((DF_REF_FLAGS (def) & DF_REF_AT_TOP) == 0)\n+\t&& (!(DF_REF_FLAGS (def) & DF_REF_PARTIAL)))\n       {\n \tunsigned int dregno = DF_REF_REGNO (def);\n \tbitmap_set_bit (bb_info->def, dregno);\n@@ -1427,12 +1437,12 @@ df_lr_bb_local_compute (struct dataflow *dflow,\n     {\n       unsigned int uid = INSN_UID (insn);\n \n-      if (! INSN_P (insn))\n+      if (!INSN_P (insn))\n \tcontinue;\t\n \n       if (CALL_P (insn))\n \t{\n-\t  for (def = DF_INSN_UID_GET (df, uid)->defs; def; def = def->next_ref)\n+\t  for (def = DF_INSN_UID_DEFS (df, uid); def; def = def->next_ref)\n \t    {\n \t      unsigned int dregno = DF_REF_REGNO (def);\n \t      \n@@ -1443,41 +1453,50 @@ df_lr_bb_local_compute (struct dataflow *dflow,\n \t\t\t\t\t      current_function_return_rtx,\n \t\t\t\t\t      (rtx *)0)))\n \t\t{\n-\t\t  /* Add def to set of defs in this BB.  */\n-\t\t  bitmap_set_bit (bb_info->def, dregno);\n-\t\t  bitmap_clear_bit (bb_info->use, dregno);\n+\t\t  /* If the def is to only part of the reg, it does\n+\t\t     not kill the other defs that reach here.  */\n+\t\t  if (!(DF_REF_FLAGS (def) & DF_REF_PARTIAL))\n+\t\t    {\n+\t\t      bitmap_set_bit (bb_info->def, dregno);\n+\t\t      bitmap_clear_bit (bb_info->use, dregno);\n+\t\t    }\n \t\t}\n \t    }\n \t}\n       else\n \t{\n-\t  for (def = DF_INSN_UID_GET (df, uid)->defs; def; def = def->next_ref)\n+\t  for (def = DF_INSN_UID_DEFS (df, uid); def; def = def->next_ref)\n \t    {\n \t      unsigned int dregno = DF_REF_REGNO (def);\n \t      \n \t      if (DF_INSN_CONTAINS_ASM (df, insn) \n \t\t  && dregno < FIRST_PSEUDO_REGISTER)\n \t\t{\n \t\t  unsigned int i;\n-\t\t  unsigned int end = \n-\t\t    dregno + hard_regno_nregs[dregno][GET_MODE (DF_REF_REG (def))] - 1;\n+\t\t  unsigned int end = dregno \n+\t\t    + hard_regno_nregs[dregno][GET_MODE (DF_REF_REG (def))] - 1;\n \t\t  for (i = dregno; i <= end; ++i)\n \t\t    regs_asm_clobbered[i] = 1;\n \t\t}\n-\t      /* Add def to set of defs in this BB.  */\n-\t      bitmap_set_bit (bb_info->def, dregno);\n-\t      bitmap_clear_bit (bb_info->use, dregno);\n+\t      /* If the def is to only part of the reg, it does\n+\t\t     not kill the other defs that reach here.  */\n+\t      if (!(DF_REF_FLAGS (def) & DF_REF_PARTIAL))\n+\t\t{\n+\t\t  bitmap_set_bit (bb_info->def, dregno);\n+\t\t  bitmap_clear_bit (bb_info->use, dregno);\n+\t\t}\n \t    }\n \t}\n \n-      for (use = DF_INSN_UID_GET (df, uid)->uses; use; use = use->next_ref)\n+      for (use = DF_INSN_UID_USES (df, uid); use; use = use->next_ref)\n \t/* Add use to set of uses in this BB.  */\n \tbitmap_set_bit (bb_info->use, DF_REF_REGNO (use));\n     }\n \n   /* Process the registers set in an exception handler.  */\n   for (def = df_get_artificial_defs (df, bb_index); def; def = def->next_ref)\n-    if (DF_REF_FLAGS (def) & DF_REF_AT_TOP)\n+    if ((DF_REF_FLAGS (def) & DF_REF_AT_TOP)\n+\t&& (!(DF_REF_FLAGS (def) & DF_REF_PARTIAL)))\n       {\n \tunsigned int dregno = DF_REF_REGNO (def);\n \tbitmap_set_bit (bb_info->def, dregno);\n@@ -1493,6 +1512,7 @@ df_lr_bb_local_compute (struct dataflow *dflow,\n #endif\n }\n \n+\n /* Compute local live register info for each basic block within BLOCKS.  */\n \n static void\n@@ -1517,7 +1537,7 @@ df_lr_local_compute (struct dataflow *dflow,\n   /* Before reload, there are a few registers that must be forced\n      live everywhere -- which might not already be the case for\n      blocks within infinite loops.  */\n-  if (! reload_completed)\n+  if (!reload_completed)\n     {\n       /* Any reference to any pseudo before reload is a potential\n \t reference of the frame pointer.  */\n@@ -1586,6 +1606,7 @@ df_lr_confluence_0 (struct dataflow *dflow, basic_block bb)\n \n \n /* Confluence function that ignores fake edges.  */\n+\n static void\n df_lr_confluence_n (struct dataflow *dflow, edge e)\n {\n@@ -1605,6 +1626,7 @@ df_lr_confluence_n (struct dataflow *dflow, edge e)\n \n \n /* Transfer function.  */\n+\n static bool\n df_lr_transfer_function (struct dataflow *dflow, int bb_index)\n {\n@@ -1642,6 +1664,8 @@ df_lr_free (struct dataflow *dflow)\n       dflow->block_info_size = 0;\n       free (dflow->block_info);\n     }\n+\n+  free (dflow->problem_data);\n   free (dflow);\n }\n \n@@ -1653,6 +1677,9 @@ df_lr_dump (struct dataflow *dflow, FILE *file)\n {\n   basic_block bb;\n   \n+  if (!dflow->block_info) \n+    return;\n+\n   fprintf (file, \"Live Registers:\\n\");\n   FOR_ALL_BB (bb)\n     {\n@@ -1691,7 +1718,8 @@ static struct df_problem problem_LR =\n   NULL,                       /* Finalize function.  */\n   df_lr_free,                 /* Free all of the problem information.  */\n   df_lr_dump,                 /* Debugging.  */\n-  NULL                        /* Dependent problem.  */\n+  NULL,                       /* Dependent problem.  */\n+  0\n };\n \n \n@@ -1700,9 +1728,9 @@ static struct df_problem problem_LR =\n    solution.  */\n \n struct dataflow *\n-df_lr_add_problem (struct df *df)\n+df_lr_add_problem (struct df *df, int flags)\n {\n-  return df_add_problem (df, &problem_LR);\n+  return df_add_problem (df, &problem_LR, flags);\n }\n \n \n@@ -1756,21 +1784,18 @@ df_ur_free_bb_info (struct dataflow *dflow,\n    not touched unless the block is new.  */\n \n static void \n-df_ur_alloc (struct dataflow *dflow, bitmap blocks_to_rescan)\n+df_ur_alloc (struct dataflow *dflow, bitmap blocks_to_rescan,\n+\t     bitmap all_blocks ATTRIBUTE_UNUSED)\n {\n   unsigned int bb_index;\n   bitmap_iterator bi;\n \n-  if (! dflow->block_pool)\n+  if (!dflow->block_pool)\n     dflow->block_pool = create_alloc_pool (\"df_ur_block pool\", \n \t\t\t\t\t   sizeof (struct df_ur_bb_info), 100);\n \n   df_grow_bb_info (dflow);\n \n-  /* Because of the clustering of all def sites for the same pseudo,\n-     we have to process all of the blocks before doing the\n-     analysis.  */\n-\n   EXECUTE_IF_SET_IN_BITMAP (blocks_to_rescan, 0, bb_index, bi)\n     {\n       struct df_ur_bb_info *bb_info = df_ur_get_bb_info (dflow, bb_index);\n@@ -1823,16 +1848,23 @@ df_ur_bb_local_compute (struct dataflow *dflow, unsigned int bb_index)\n       if (!INSN_P (insn))\n \tcontinue;\n \n-      for (def = DF_INSN_UID_GET (df, uid)->defs; def; def = def->next_ref)\n+      for (def = DF_INSN_UID_DEFS (df, uid); def; def = def->next_ref)\n \t{\n \t  unsigned int regno = DF_REF_REGNO (def);\n-\t      /* Only the last def counts.  */\n+\t  /* Only the last def counts.  */\n \t  if (!bitmap_bit_p (seen_in_block, regno))\n \t    {\n \t      bitmap_set_bit (seen_in_insn, regno);\n \t      \n-\t      if (DF_REF_FLAGS (def) & DF_REF_CLOBBER)\n-\t\tbitmap_set_bit (bb_info->kill, regno);\n+\t      if (DF_REF_FLAGS (def) \n+\t\t  & (DF_REF_MUST_CLOBBER | DF_REF_MAY_CLOBBER))\n+\t\t{\n+\t\t  /* Only must clobbers for the entire reg destroy the\n+\t\t     value.  */\n+\t\t  if ((DF_REF_FLAGS (def) & DF_REF_MUST_CLOBBER)\n+\t\t      && (!DF_REF_FLAGS (def) & DF_REF_PARTIAL))\n+\t\t    bitmap_set_bit (bb_info->kill, regno);\n+\t\t}\n \t      else\n \t\tbitmap_set_bit (bb_info->gen, regno);\n \t    }\n@@ -1927,7 +1959,7 @@ df_ur_local_finalize (struct dataflow *dflow, bitmap all_blocks)\n       bitmap_and_into (bb_info->out, tmp);\n #endif\n     }\n-  \n+\n   BITMAP_FREE (tmp);\n }\n \n@@ -1998,14 +2030,17 @@ df_ur_dump (struct dataflow *dflow, FILE *file)\n {\n   basic_block bb;\n   \n+  if (!dflow->block_info) \n+    return;\n+\n   fprintf (file, \"Undefined regs:\\n\");\n  \n   FOR_ALL_BB (bb)\n     {\n       struct df_ur_bb_info *bb_info = df_ur_get_bb_info (dflow, bb->index);\n       df_print_bb_index (bb, file);\n       \n-      if (! bb_info->in)\n+      if (!bb_info->in)\n \tcontinue;\n       \n       fprintf (file, \"  in  \\t\");\n@@ -2037,7 +2072,8 @@ static struct df_problem problem_UR =\n   df_ur_local_finalize,       /* Finalize function.  */\n   df_ur_free,                 /* Free all of the problem information.  */\n   df_ur_dump,                 /* Debugging.  */\n-  &problem_LR                 /* Dependent problem.  */\n+  df_lr_add_problem,          /* Dependent problem.  */\n+  0                           /* Changeable flags.  */\n };\n \n \n@@ -2046,9 +2082,9 @@ static struct df_problem problem_UR =\n    solution.  */\n \n struct dataflow *\n-df_ur_add_problem (struct df *df)\n+df_ur_add_problem (struct df *df, int flags)\n {\n-  return df_add_problem (df, &problem_UR);\n+  return df_add_problem (df, &problem_UR, flags);\n }\n \n \n@@ -2116,14 +2152,16 @@ df_urec_free_bb_info (struct dataflow *dflow,\n    not touched unless the block is new.  */\n \n static void \n-df_urec_alloc (struct dataflow *dflow, bitmap blocks_to_rescan)\n+df_urec_alloc (struct dataflow *dflow, bitmap blocks_to_rescan,\n+\t       bitmap all_blocks ATTRIBUTE_UNUSED)\n+\n {\n   unsigned int bb_index;\n   bitmap_iterator bi;\n-  struct df_urec_problem_data *problem_data =\n-    (struct df_urec_problem_data *) dflow->problem_data;\n+  struct df_urec_problem_data *problem_data\n+    = (struct df_urec_problem_data *) dflow->problem_data;\n \n-  if (! dflow->block_pool)\n+  if (!dflow->block_pool)\n     dflow->block_pool = create_alloc_pool (\"df_urec_block pool\", \n \t\t\t\t\t   sizeof (struct df_urec_bb_info), 50);\n \n@@ -2136,10 +2174,6 @@ df_urec_alloc (struct dataflow *dflow, bitmap blocks_to_rescan)\n \n   df_grow_bb_info (dflow);\n \n-  /* Because of the clustering of all def sites for the same pseudo,\n-     we have to process all of the blocks before doing the\n-     analysis.  */\n-\n   EXECUTE_IF_SET_IN_BITMAP (blocks_to_rescan, 0, bb_index, bi)\n     {\n       struct df_urec_bb_info *bb_info = df_urec_get_bb_info (dflow, bb_index);\n@@ -2376,11 +2410,10 @@ df_urec_bb_local_compute (struct dataflow *dflow, unsigned int bb_index)\n       if (INSN_P (insn))\n \t{\n \t  note_stores (PATTERN (insn), df_urec_mark_reg_change, bb_info);\n-\t  if (df_state & (DF_SCAN_GLOBAL | DF_SCAN_POST_ALLOC) \n-\t      && df_urec_check_earlyclobber (insn))\n+\t  if (df_urec_check_earlyclobber (insn))\n \t    {\n-\t      struct df_urec_problem_data *problem_data =\n-\t\t(struct df_urec_problem_data *) dflow->problem_data;\n+\t      struct df_urec_problem_data *problem_data\n+\t\t= (struct df_urec_problem_data *) dflow->problem_data;\n \t      problem_data->earlyclobbers_found = true;\n \t      note_uses (&PATTERN (insn), \n \t\t\t df_urec_mark_reg_use_for_earlyclobber_1, bb_info);\n@@ -2410,8 +2443,8 @@ df_urec_local_compute (struct dataflow *dflow,\n #ifdef STACK_REGS\n   int i;\n   HARD_REG_SET zero, stack_hard_regs, used;\n-  struct df_urec_problem_data *problem_data =\n-    (struct df_urec_problem_data *) dflow->problem_data;\n+  struct df_urec_problem_data *problem_data\n+    = (struct df_urec_problem_data *) dflow->problem_data;\n   \n   /* Any register that MAY be allocated to a register stack (like the\n      387) is treated poorly.  Each such register is marked as being\n@@ -2479,8 +2512,8 @@ df_urec_local_finalize (struct dataflow *dflow, bitmap all_blocks)\n   bitmap tmp = BITMAP_ALLOC (NULL);\n   bitmap_iterator bi;\n   unsigned int bb_index;\n-  struct df_urec_problem_data *problem_data =\n-    (struct df_urec_problem_data *) dflow->problem_data;\n+  struct df_urec_problem_data *problem_data\n+    = (struct df_urec_problem_data *) dflow->problem_data;\n \n   EXECUTE_IF_SET_IN_BITMAP (all_blocks, 0, bb_index, bi)\n     {\n@@ -2597,14 +2630,17 @@ df_urec_dump (struct dataflow *dflow, FILE *file)\n {\n   basic_block bb;\n   \n+  if (!dflow->block_info) \n+    return;\n+\n   fprintf (file, \"Undefined regs:\\n\");\n  \n   FOR_ALL_BB (bb)\n     {\n       struct df_urec_bb_info *bb_info = df_urec_get_bb_info (dflow, bb->index);\n       df_print_bb_index (bb, file);\n       \n-      if (! bb_info->in)\n+      if (!bb_info->in)\n \tcontinue;\n       \n       fprintf (file, \"  in  \\t\");\n@@ -2638,7 +2674,8 @@ static struct df_problem problem_UREC =\n   df_urec_local_finalize,     /* Finalize function.  */\n   df_urec_free,               /* Free all of the problem information.  */\n   df_urec_dump,               /* Debugging.  */\n-  &problem_LR                 /* Dependent problem.  */\n+  df_lr_add_problem,          /* Dependent problem.  */\n+  0                           /* Changeable flags.  */\n };\n \n \n@@ -2647,9 +2684,9 @@ static struct df_problem problem_UREC =\n    solution.  */\n \n struct dataflow *\n-df_urec_add_problem (struct df *df)\n+df_urec_add_problem (struct df *df, int flags)\n {\n-  return df_add_problem (df, &problem_UREC);\n+  return df_add_problem (df, &problem_UREC, flags);\n }\n \n \n@@ -2665,22 +2702,16 @@ df_urec_add_problem (struct df *df)\n    the reaching defs information (the dependent problem).\n ----------------------------------------------------------------------------*/\n \n-struct df_chain_problem_data\n-{\n-  int flags;\n-};\n-\n-\n /* Create def-use or use-def chains.  */\n \n static void  \n df_chain_alloc (struct dataflow *dflow, \n-\t\tbitmap blocks_to_rescan ATTRIBUTE_UNUSED)\n+\t\tbitmap blocks_to_rescan ATTRIBUTE_UNUSED,\n+\t\tbitmap all_blocks ATTRIBUTE_UNUSED)\n+\n {\n   struct df *df = dflow->df;\n   unsigned int i;\n-  struct df_chain_problem_data *problem_data =\n-    (struct df_chain_problem_data *) dflow->problem_data;\n \n   /* Wholesale destruction of the old chains.  */ \n   if (dflow->block_pool)\n@@ -2689,7 +2720,7 @@ df_chain_alloc (struct dataflow *dflow,\n   dflow->block_pool = create_alloc_pool (\"df_chain_chain_block pool\", \n \t\t\t\t\t sizeof (struct df_link), 100);\n \n-  if (problem_data->flags & DF_DU_CHAIN)\n+  if (dflow->flags & DF_DU_CHAIN)\n     {\n       if (!df->def_info.refs_organized)\n \tdf_reorganize_refs (&df->def_info);\n@@ -2702,7 +2733,7 @@ df_chain_alloc (struct dataflow *dflow,\n \t}\n     }\n   \n-  if (problem_data->flags & DF_UD_CHAIN)\n+  if (dflow->flags & DF_UD_CHAIN)\n     {\n       if (!df->use_info.refs_organized)\n \tdf_reorganize_refs (&df->use_info);\n@@ -2721,8 +2752,6 @@ static void\n df_chain_insn_reset (struct dataflow *dflow, rtx insn)\n {\n   struct df *df = dflow->df;\n-  struct df_chain_problem_data *problem_data =\n-    (struct df_chain_problem_data *) dflow->problem_data;\n   unsigned int uid = INSN_UID (insn);\n   struct df_insn_info *insn_info = NULL;\n   struct df_ref *ref;\n@@ -2732,7 +2761,7 @@ df_chain_insn_reset (struct dataflow *dflow, rtx insn)\n \n   if (insn_info)\n     {\n-      if (problem_data->flags & DF_DU_CHAIN)\n+      if (dflow->flags & DF_DU_CHAIN)\n \t{\n \t  ref = insn_info->defs;\n \t  while (ref)\n@@ -2742,7 +2771,7 @@ df_chain_insn_reset (struct dataflow *dflow, rtx insn)\n \t    }\n \t}\n \n-      if (problem_data->flags & DF_UD_CHAIN)\n+      if (dflow->flags & DF_UD_CHAIN)\n \t{\n \t  ref = insn_info->uses;\n \t  while (ref) \n@@ -2761,8 +2790,6 @@ static void\n df_chain_bb_reset (struct dataflow *dflow, unsigned int bb_index)\n {\n   struct df *df = dflow->df; \n-  struct df_chain_problem_data *problem_data =\n-    (struct df_chain_problem_data *) dflow->problem_data;\n   rtx insn;\n   basic_block bb = BASIC_BLOCK (bb_index);\n \n@@ -2780,7 +2807,7 @@ df_chain_bb_reset (struct dataflow *dflow, unsigned int bb_index)\n     }\n   \n   /* Get rid of any chains in artificial uses or defs.  */\n-  if (problem_data->flags & DF_DU_CHAIN)\n+  if (dflow->flags & DF_DU_CHAIN)\n     {\n       struct df_ref *def;\n       def = df_get_artificial_defs (df, bb_index);\n@@ -2791,7 +2818,7 @@ df_chain_bb_reset (struct dataflow *dflow, unsigned int bb_index)\n \t}\n     }\n \n-  if (problem_data->flags & DF_UD_CHAIN)\n+  if (dflow->flags & DF_UD_CHAIN)\n     {\n       struct df_ref *use;\n       use = df_get_artificial_uses (df, bb_index);\n@@ -2827,7 +2854,6 @@ df_chain_reset (struct dataflow *dflow, bitmap blocks_to_clear)\n \n static void\n df_chain_create_bb_process_use (struct dataflow *dflow, \n-\t\t\t\tstruct df_chain_problem_data *problem_data,\n \t\t\t\tbitmap local_rd,\n \t\t\t\tstruct df_ref *use,\n \t\t\t\tenum df_ref_flags top_flag)\n@@ -2855,9 +2881,9 @@ df_chain_create_bb_process_use (struct dataflow *dflow,\n \t\t    break;\n \t\t  \n \t\t  def = DF_DEFS_GET (df, def_index);\n-\t\t  if (problem_data->flags & DF_DU_CHAIN)\n+\t\t  if (dflow->flags & DF_DU_CHAIN)\n \t\t    df_chain_create (dflow, def, use);\n-\t\t  if (problem_data->flags & DF_UD_CHAIN)\n+\t\t  if (dflow->flags & DF_UD_CHAIN)\n \t\t    df_chain_create (dflow, use, def);\n \t\t}\n \t    }\n@@ -2881,8 +2907,6 @@ df_chain_create_bb (struct dataflow *dflow,\n   rtx insn;\n   bitmap cpy = BITMAP_ALLOC (NULL);\n   struct df *df = dflow->df;\n-  struct df_chain_problem_data *problem_data =\n-    (struct df_chain_problem_data *) dflow->problem_data;\n   struct df_ref *def;\n \n   bitmap_copy (cpy, bb_info->in);\n@@ -2893,7 +2917,7 @@ df_chain_create_bb (struct dataflow *dflow,\n #ifdef EH_USES\n   /* Create the chains for the artificial uses from the EH_USES at the\n      beginning of the block.  */\n-  df_chain_create_bb_process_use (dflow, problem_data, cpy,\n+  df_chain_create_bb_process_use (dflow, cpy,\n \t\t\t\t  df_get_artificial_uses (df, bb->index), \n \t\t\t\t  DF_REF_AT_TOP);\n #endif\n@@ -2902,11 +2926,11 @@ df_chain_create_bb (struct dataflow *dflow,\n     if (DF_REF_FLAGS (def) & DF_REF_AT_TOP)\n       {\n \tunsigned int dregno = DF_REF_REGNO (def);\n-\tbitmap_clear_range (cpy, \n-\t\t\t    DF_REG_DEF_GET (df, dregno)->begin, \n-\t\t\t    DF_REG_DEF_GET (df, dregno)->n_refs);\n-\tif (! (DF_REF_FLAGS (def) & DF_REF_CLOBBER))\n-\t  bitmap_set_bit (cpy, DF_REF_ID (def));\n+\tif (!(DF_REF_FLAGS (def) & DF_REF_PARTIAL))\n+\t  bitmap_clear_range (cpy, \n+\t\t\t      DF_REG_DEF_GET (df, dregno)->begin, \n+\t\t\t      DF_REG_DEF_GET (df, dregno)->n_refs);\n+\tbitmap_set_bit (cpy, DF_REF_ID (def));\n       }\n   \n   /* Process the regular instructions next.  */\n@@ -2915,31 +2939,33 @@ df_chain_create_bb (struct dataflow *dflow,\n       struct df_ref *def;\n       unsigned int uid = INSN_UID (insn);\n \n-      if (! INSN_P (insn))\n+      if (!INSN_P (insn))\n \tcontinue;\n \n       /* Now scan the uses and link them up with the defs that remain\n \t in the cpy vector.  */\n       \n-      df_chain_create_bb_process_use (dflow, problem_data, cpy,\t\t     \n-\t\t\t\t     DF_INSN_UID_GET (df, uid)->uses, 0);\n+      df_chain_create_bb_process_use (dflow, cpy,\n+\t\t\t\t     DF_INSN_UID_USES (df, uid), 0);\n \n       /* Since we are going forwards, process the defs second.  This\n          pass only changes the bits in cpy.  */\n-      for (def = DF_INSN_UID_GET (df, uid)->defs; def; def = def->next_ref)\n+      for (def = DF_INSN_UID_DEFS (df, uid); def; def = def->next_ref)\n \t{\n \t  unsigned int dregno = DF_REF_REGNO (def);\n-\t  bitmap_clear_range (cpy, \n-\t\t\t      DF_REG_DEF_GET (df, dregno)->begin, \n-\t\t\t      DF_REG_DEF_GET (df, dregno)->n_refs);\n-\t  if (! (DF_REF_FLAGS (def) & DF_REF_CLOBBER))\n+\t  if (!(DF_REF_FLAGS (def) & DF_REF_PARTIAL))\n+\t    bitmap_clear_range (cpy, \n+\t\t\t\tDF_REG_DEF_GET (df, dregno)->begin, \n+\t\t\t\tDF_REG_DEF_GET (df, dregno)->n_refs);\n+\t  if (!(DF_REF_FLAGS (def) \n+\t\t & (DF_REF_MUST_CLOBBER | DF_REF_MAY_CLOBBER)))\n \t    bitmap_set_bit (cpy, DF_REF_ID (def));\n \t}\n     }\n \n   /* Create the chains for the artificial uses of the hard registers\n      at the end of the block.  */\n-  df_chain_create_bb_process_use (dflow, problem_data, cpy,\n+  df_chain_create_bb_process_use (dflow, cpy,\n \t\t\t\t  df_get_artificial_uses (df, bb->index), 0);\n }\n \n@@ -2967,7 +2993,6 @@ static void\n df_chain_free (struct dataflow *dflow)\n {\n   free_alloc_pool (dflow->block_pool);\n-  free (dflow->problem_data);\n   free (dflow);\n }\n \n@@ -2979,10 +3004,8 @@ df_chains_dump (struct dataflow *dflow, FILE *file)\n {\n   struct df *df = dflow->df;\n   unsigned int j;\n-  struct df_chain_problem_data *problem_data =\n-    (struct df_chain_problem_data *) dflow->problem_data;\n \n-  if (problem_data->flags & DF_DU_CHAIN)\n+  if (dflow->flags & DF_DU_CHAIN)\n     {\n       fprintf (file, \"Def-use chains:\\n\");\n       for (j = 0; j < df->def_info.bitmap_size; j++)\n@@ -2999,13 +3022,13 @@ df_chains_dump (struct dataflow *dflow, FILE *file)\n \t\t       DF_REF_REGNO (def));\n \t      if (def->flags & DF_REF_READ_WRITE)\n \t\tfprintf (file, \"read/write \");\n-\t      df_chain_dump (df, DF_REF_CHAIN (def), file);\n+\t      df_chain_dump (DF_REF_CHAIN (def), file);\n \t      fprintf (file, \"\\n\");\n \t    }\n \t}\n     }\n \n-  if (problem_data->flags & DF_UD_CHAIN)\n+  if (dflow->flags & DF_UD_CHAIN)\n     {\n       fprintf (file, \"Use-def chains:\\n\");\n       for (j = 0; j < df->use_info.bitmap_size; j++)\n@@ -3028,7 +3051,7 @@ df_chains_dump (struct dataflow *dflow, FILE *file)\n \t\tfprintf (file, \"stripped \");\n \t      if (use->flags & DF_REF_IN_NOTE)\n \t\tfprintf (file, \"note \");\n-\t      df_chain_dump (df, DF_REF_CHAIN (use), file);\n+\t      df_chain_dump (DF_REF_CHAIN (use), file);\n \t      fprintf (file, \"\\n\");\n \t    }\n \t}\n@@ -3052,7 +3075,8 @@ static struct df_problem problem_CHAIN =\n   df_chain_finalize,          /* Finalize function.  */\n   df_chain_free,              /* Free all of the problem information.  */\n   df_chains_dump,             /* Debugging.  */\n-  &problem_RD                 /* Dependent problem.  */\n+  df_rd_add_problem,          /* Dependent problem.  */\n+  0                           /* Changeable flags.  */\n };\n \n \n@@ -3063,104 +3087,560 @@ static struct df_problem problem_CHAIN =\n struct dataflow *\n df_chain_add_problem (struct df *df, int flags)\n {\n-  struct df_chain_problem_data *problem_data =\n-\tXNEW (struct df_chain_problem_data);\n-  struct dataflow *dflow = df_add_problem (df, &problem_CHAIN);\n-\n-  dflow->problem_data = problem_data;\n-  problem_data->flags = flags;\n-  \n-  return dflow;\n+  return df_add_problem (df, &problem_CHAIN, flags);\n }\n \n \n /*----------------------------------------------------------------------------\n    REGISTER INFORMATION\n \n-   Currently this consists of only lifetime information.  But the plan is\n-   to enhance it so that it produces all of the register information needed\n-   by the register allocators.\n-----------------------------------------------------------------------------*/\n-\n+   Currently this consists of only lifetime information and reg_dead\n+   and reg_unused.  \n+   ----------------------------------------------------------------------------*/\n \n-struct df_ri_problem_data\n+#ifdef REG_DEAD_DEBUGGING\n+static void \n+print_note (char *prefix, rtx insn, rtx note)\n {\n-  int *lifetime;\n-};\n-\n+  fprintf (stderr, \"%s %d \", prefix, INSN_UID (insn));\n+  print_rtl (stderr, note);\n+  fprintf (stderr, \"\\n\");\n+}\n+#endif\n \n /* Allocate the lifetime information.  */\n \n static void \n-df_ri_alloc (struct dataflow *dflow, bitmap blocks_to_rescan ATTRIBUTE_UNUSED)\n+df_ri_alloc (struct dataflow *dflow, \n+\t     bitmap blocks_to_rescan ATTRIBUTE_UNUSED,\n+\t     bitmap all_blocks ATTRIBUTE_UNUSED)\n {\n-  struct df_ri_problem_data *problem_data =\n-    (struct df_ri_problem_data *) dflow->problem_data;\n+  int i;\n+  struct df *df = dflow->df;\n \n-  if (!dflow->problem_data)\n+  if (dflow->flags & DF_RI_LIFE)\n     {\n-      struct df_ri_problem_data *problem_data =\tXNEW (struct df_ri_problem_data);\n-      dflow->problem_data = problem_data;\n+      max_regno = max_reg_num ();\n+      allocate_reg_info (max_regno, FALSE, FALSE);\n+      \n+      /* Reset all the data we'll collect.  */\n+      for (i = 0; i < max_regno; i++)\n+\t{\n+\t  REG_N_SETS (i) = DF_REG_DEF_COUNT (df, i);\n+\t  REG_N_REFS (i) = DF_REG_USE_COUNT (df, i) + REG_N_SETS (i);\n+\t  REG_N_DEATHS (i) = 0;\n+\t  REG_N_CALLS_CROSSED (i) = 0;\n+\t  REG_N_THROWING_CALLS_CROSSED (i) = 0;\n+\t  REG_LIVE_LENGTH (i) = 0;\n+\t  REG_FREQ (i) = 0;\n+\t  REG_BASIC_BLOCK (i) = REG_BLOCK_UNKNOWN;\n+\t}\n+    }\n+}\n+\n+\n+/* After reg-stack, the x86 floating point stack regs are difficult to\n+   analyze because of all of the pushes, pops and rotations.  Thus, we\n+   just leave the notes alone. */\n+\n+static inline bool \n+df_ignore_stack_reg (int regno ATTRIBUTE_UNUSED)\n+{\n+#ifdef STACK_REGS\n+  return (regstack_completed\n+\t  && IN_RANGE (regno, FIRST_STACK_REG, LAST_STACK_REG));\n+#else\n+  return false;\n+#endif\n+}\n+\n+\n+/* Remove all of the REG_DEAD or REG_UNUSED notes from INSN.  */\n+\n+static void\n+df_kill_notes (rtx insn, int flags)\n+{\n+  rtx *pprev = &REG_NOTES (insn);\n+  rtx link = *pprev;\n+  \n+  while (link)\n+    {\n+      switch (REG_NOTE_KIND (link))\n+\t{\n+\tcase REG_DEAD:\n+\t  if (flags & DF_RI_LIFE)\n+\t    if (df_ignore_stack_reg (REGNO (XEXP (link, 0))))\n+\t      REG_N_DEATHS (REGNO (XEXP (link, 0)))++;\n+\n+\t  /* Fallthru */\n+\tcase REG_UNUSED:\n+\t  if (!df_ignore_stack_reg (REGNO (XEXP (link, 0))))\n+\t    {\n+\t      rtx next = XEXP (link, 1);\n+#ifdef REG_DEAD_DEBUGGING\n+\t      print_note (\"deleting: \", insn, link);\n+#endif\n+\t      free_EXPR_LIST_node (link);\n+\t      *pprev = link = next;\n+\t    }\n+\t  break;\n+\t  \n+\tdefault:\n+\t  pprev = &XEXP (link, 1);\n+\t  link = *pprev;\n+\t  break;\n+\t}\n+    }\n+}\n+\n+\n+/* Set the REG_UNUSED notes for the multiword hardreg defs in INSN\n+   based on the bits in LIVE.  Do not generate notes for registers in\n+   artificial uses.  DO_NOT_GEN is updated so that REG_DEAD notes are\n+   not generated if the reg is both read and written by the\n+   instruction.\n+*/\n+\n+static void\n+df_set_unused_notes_for_mw (rtx insn, struct df_mw_hardreg *mws,\n+\t\t\t    bitmap live, bitmap do_not_gen, \n+\t\t\t    bitmap artificial_uses, int flags)\n+{\n+  bool all_dead = true;\n+  struct df_link *regs = mws->regs;\n+  unsigned int regno = DF_REF_REGNO (regs->ref);\n+  \n+#ifdef REG_DEAD_DEBUGGING\n+  fprintf (stderr, \"mw unused looking at %d\\n\", DF_REF_REGNO (regs->ref));\n+  df_ref_debug (regs->ref, stderr);\n+#endif\n+  while (regs)\n+    {\n+      unsigned int regno = DF_REF_REGNO (regs->ref);\n+      if ((bitmap_bit_p (live, regno))\n+\t  || bitmap_bit_p (artificial_uses, regno))\n+\t{\n+\t  all_dead = false;\n+\t  break;\n+\t}\n+      regs = regs->next;\n+    }\n+  \n+  if (all_dead)\n+    {\n+      struct df_link *regs = mws->regs;\n+      rtx note = alloc_EXPR_LIST (REG_UNUSED, *DF_REF_LOC (regs->ref), \n+\t\t\t\t  REG_NOTES (insn));\n+      REG_NOTES (insn) = note;\n+#ifdef REG_DEAD_DEBUGGING\n+      print_note (\"adding 1: \", insn, note);\n+#endif\n+      bitmap_set_bit (do_not_gen, regno);\n+      /* Only do this if the value is totally dead.  */\n+      if (flags & DF_RI_LIFE)\n+\t{\n+\t  REG_N_DEATHS (regno) ++;\n+\t  REG_LIVE_LENGTH (regno)++;\n+\t}\n+    }\n+  else\n+    {\n+      struct df_link *regs = mws->regs;\n+      while (regs)\n+\t{\n+\t  struct df_ref *ref = regs->ref;\n+\t  \n+\t  regno = DF_REF_REGNO (ref);\n+\t  if ((!bitmap_bit_p (live, regno))\n+\t      && (!bitmap_bit_p (artificial_uses, regno)))\n+\t    {\n+\t      rtx note = alloc_EXPR_LIST (REG_UNUSED, regno_reg_rtx[regno], \n+\t\t\t\t\t  REG_NOTES (insn));\n+\t      REG_NOTES (insn) = note;\n+#ifdef REG_DEAD_DEBUGGING\n+\t      print_note (\"adding 2: \", insn, note);\n+#endif\n+\t    }\n+\t  bitmap_set_bit (do_not_gen, regno);\n+\t  regs = regs->next;\n+\t}\n+    }\n+}\n+\n+\n+/* Set the REG_DEAD notes for the multiword hardreg use in INSN based\n+   on the bits in LIVE.  DO_NOT_GEN is used to keep REG_DEAD notes\n+   from being set if the instruction both reads and writes the\n+   register.  */\n+\n+static void\n+df_set_dead_notes_for_mw (rtx insn, struct df_mw_hardreg *mws,\n+\t\t\t  bitmap live, bitmap do_not_gen,\n+\t\t\t  bitmap artificial_uses, int flags)\n+{\n+  bool all_dead = true;\n+  struct df_link *regs = mws->regs;\n+  unsigned int regno = DF_REF_REGNO (regs->ref);\n+  \n+#ifdef REG_DEAD_DEBUGGING\n+  fprintf (stderr, \"mw looking at %d\\n\", DF_REF_REGNO (regs->ref));\n+  df_ref_debug (regs->ref, stderr);\n+#endif\n+  while (regs)\n+    {\n+      unsigned int regno = DF_REF_REGNO (regs->ref);\n+      if ((bitmap_bit_p (live, regno))\n+\t  || bitmap_bit_p (artificial_uses, regno))\n+\t{\n+\t  all_dead = false;\n+\t  break;\n+\t}\n+      regs = regs->next;\n+    }\n+  \n+  if (all_dead)\n+    {\n+      if (!bitmap_bit_p (do_not_gen, regno))\n+\t{\n+\t  /* Add a dead note for the entire multi word register.  */\n+\t  struct df_link *regs = mws->regs;\n+\t  rtx note = alloc_EXPR_LIST (REG_DEAD, *DF_REF_LOC (regs->ref), \n+\t\t\t\t      REG_NOTES (insn));\n+\t  REG_NOTES (insn) = note;\n+#ifdef REG_DEAD_DEBUGGING\n+\t  print_note (\"adding 1: \", insn, note);\n+#endif\n+\n+\t  if (flags & DF_RI_LIFE)\n+\t    {\n+\t      struct df_link *regs = mws->regs;\n+\t      while (regs)\n+\t\t{\n+\t\t  struct df_ref *ref = regs->ref;\n+\t\t  regno = DF_REF_REGNO (ref);\n+\t\t  REG_N_DEATHS (regno)++;\n+\t\t  regs = regs->next;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  else\n+    {\n+      struct df_link *regs = mws->regs;\n+      while (regs)\n+\t{\n+\t  struct df_ref *ref = regs->ref;\n+\n+\t  regno = DF_REF_REGNO (ref);\n+\t  if ((!bitmap_bit_p (live, regno))\n+\t      && (!bitmap_bit_p (artificial_uses, regno))\n+\t      && (!bitmap_bit_p (do_not_gen, regno)))\n+\t    {\n+\t      rtx note = alloc_EXPR_LIST (REG_DEAD, regno_reg_rtx[regno], \n+\t\t\t\t\t  REG_NOTES (insn));\n+\t      REG_NOTES (insn) = note;\n+\t      if (flags & DF_RI_LIFE)\n+\t\tREG_N_DEATHS (regno)++;\n+#ifdef REG_DEAD_DEBUGGING\n+\t      print_note (\"adding 2: \", insn, note);\n+#endif\n+\t    }\n+\n+\t  regs = regs->next;\n+\t}\n+    }\n+}\n+\n+\n+/* Create a REG_UNUSED note if necessary for DEF in INSN updating LIVE\n+   and DO_NOT_GEN.  Do not generate notes for registers in artificial\n+   uses.  */\n+\n+static void\n+df_create_unused_note (basic_block bb, rtx insn, struct df_ref *def, \n+\t\t       bitmap live, bitmap do_not_gen, bitmap artificial_uses, \n+\t\t       bitmap local_live, bitmap local_processed, \n+\t\t       int flags, int luid)\n+{\n+  unsigned int dregno = DF_REF_REGNO (def);\n+  \n+#ifdef REG_DEAD_DEBUGGING\n+  fprintf (stderr, \"  regular looking at def \");\n+  df_ref_debug (def, stderr);\n+#endif\n+\n+  if (bitmap_bit_p (live, dregno))\n+    {\n+      if (flags & DF_RI_LIFE)\n+\t{\n+\t  /* If we have seen this regno, then it has already been\n+\t     processed correctly with the per insn increment.  If we\n+\t     have not seen it we need to add the length from here to\n+\t     the end of the block to the live length.  */\n+\t  if (bitmap_bit_p (local_processed, dregno))\n+\t    {\n+\t      if (!(DF_REF_FLAGS (def) & DF_REF_PARTIAL))\n+\t\tbitmap_clear_bit (local_live, dregno);\n+\t    }\n+\t  else\n+\t    {\n+\t      bitmap_set_bit (local_processed, dregno);\n+\t      REG_LIVE_LENGTH (dregno) += luid;\n+\t    }\n+\t}\n+    }\n+  else if ((!(DF_REF_FLAGS (def) & DF_REF_MW_HARDREG))\n+\t    && (!bitmap_bit_p (artificial_uses, dregno)) \n+\t    && (!df_ignore_stack_reg (dregno)))\n+    {\n+      rtx reg = GET_CODE (*DF_REF_LOC (def)) == SUBREG ?\n+\tSUBREG_REG (*DF_REF_LOC (def)) : *DF_REF_LOC (def);\n+      rtx note = alloc_EXPR_LIST (REG_UNUSED, reg, REG_NOTES (insn));\n+      REG_NOTES (insn) = note;\n+#ifdef REG_DEAD_DEBUGGING\n+      print_note (\"adding 3: \", insn, note);\n+#endif\n+      if (flags & DF_RI_LIFE)\n+\t{\n+\t  REG_N_DEATHS (dregno) ++;\n+\t  REG_LIVE_LENGTH (dregno)++;\n+\t}\n+    }\n+  \n+  if ((flags & DF_RI_LIFE) && (dregno >= FIRST_PSEUDO_REGISTER))\n+    {\n+      REG_FREQ (dregno) += REG_FREQ_FROM_BB (bb);\n+      if (REG_BASIC_BLOCK (dregno) == REG_BLOCK_UNKNOWN)\n+\tREG_BASIC_BLOCK (dregno) = bb->index;\n+      else if (REG_BASIC_BLOCK (dregno) != bb->index)\n+\tREG_BASIC_BLOCK (dregno) = REG_BLOCK_GLOBAL;\n     }\n \n-  problem_data->lifetime = xrealloc (problem_data->lifetime, \n-\t\t\t\t     max_reg_num () *sizeof (int));\n-  memset (problem_data->lifetime, 0, max_reg_num () *sizeof (int));\n+  if (!(DF_REF_FLAGS (def) & (DF_REF_MUST_CLOBBER + DF_REF_MAY_CLOBBER)))\n+    bitmap_set_bit (do_not_gen, dregno);\n+  \n+  /* Kill this register if it is not a subreg store.  */\n+  if (!(DF_REF_FLAGS (def) & DF_REF_PARTIAL))\n+    bitmap_clear_bit (live, dregno);\n }\n \n-/* Compute register info: lifetime, bb, and number of defs and uses\n-   for basic block BB.  */\n+\n+/* Recompute the REG_DEAD and REG_UNUSED notes and compute register\n+   info: lifetime, bb, and number of defs and uses for basic block\n+   BB.  The three bitvectors are scratch regs used here.  */\n \n static void\n-df_ri_bb_compute (struct dataflow *dflow, unsigned int bb_index, bitmap live)\n+df_ri_bb_compute (struct dataflow *dflow, unsigned int bb_index, \n+\t\t  bitmap live, bitmap do_not_gen, bitmap artificial_uses,\n+\t\t  bitmap local_live, bitmap local_processed, bitmap setjumps_crossed)\n {\n   struct df *df = dflow->df;\n-  struct df_ur_bb_info *bb_info = df_ur_get_bb_info (dflow, bb_index);\n-  struct df_ri_problem_data *problem_data =\n-    (struct df_ri_problem_data *) dflow->problem_data;\n   basic_block bb = BASIC_BLOCK (bb_index);\n   rtx insn;\n+  struct df_ref *def;\n+  struct df_ref *use;\n+  int luid = 0;\n+\n+  bitmap_copy (live, df_get_live_out (df, bb));\n+  bitmap_clear (artificial_uses);\n+\n+  if (dflow->flags & DF_RI_LIFE)\n+    {\n+      /* Process the regs live at the end of the block.  Mark them as\n+\t not local to any one basic block.  */\n+      bitmap_iterator bi;\n+      unsigned int regno;\n+      EXECUTE_IF_SET_IN_BITMAP (live, 0, regno, bi)\n+\tREG_BASIC_BLOCK (regno) = REG_BLOCK_GLOBAL;\n+    }\n+\n+  /* Process the artificial defs and uses at the bottom of the block\n+     to begin processing.  */\n+  for (def = df_get_artificial_defs (df, bb_index); def; def = def->next_ref)\n+    if ((DF_REF_FLAGS (def) & DF_REF_AT_TOP) == 0)\n+      bitmap_clear_bit (live, DF_REF_REGNO (def));\n \n-  bitmap_copy (live, bb_info->out);\n+  for (use = df_get_artificial_uses (df, bb_index); use; use = use->next_ref)\n+    if ((DF_REF_FLAGS (use) & DF_REF_AT_TOP) == 0)\n+      {\n+\tunsigned int regno = DF_REF_REGNO (use);\n+\tbitmap_set_bit (live, regno);\n \n+\t/* Notes are not generated for any of the artificial registers\n+\t   at the bottom of the block.  */\n+\tbitmap_set_bit (artificial_uses, regno);\n+      }\n+  \n   FOR_BB_INSNS_REVERSE (bb, insn)\n     {\n       unsigned int uid = INSN_UID (insn);\n       unsigned int regno;\n       bitmap_iterator bi;\n-      struct df_ref *def;\n-      struct df_ref *use;\n-\n-      if (! INSN_P (insn))\n+      struct df_mw_hardreg *mws;\n+      \n+      if (!INSN_P (insn))\n \tcontinue;\n \n-      for (def = DF_INSN_UID_GET (df, uid)->defs; def; def = def->next_ref)\n+      if (dflow->flags & DF_RI_LIFE)\n \t{\n-\t  unsigned int dregno = DF_REF_REGNO (def);\n+\t  /* Increment the live_length for all of the registers that\n+\t     are are referenced in this block and live at this\n+\t     particular point.  */\n+\t  bitmap_iterator bi;\n+\t  unsigned int regno;\n+\t  EXECUTE_IF_SET_IN_BITMAP (local_live, 0, regno, bi)\n+\t    {\n+\t      REG_LIVE_LENGTH (regno)++;\n+\t    }\n+\t  luid++;\n+\t}\n+\n+      bitmap_clear (do_not_gen);\n+      df_kill_notes (insn, dflow->flags);\n+\n+      /* Process the defs.  */\n+      if (CALL_P (insn))\n+\t{\n+\t  if (dflow->flags & DF_RI_LIFE)\n+\t    {\n+\t      bool can_throw = can_throw_internal (insn); \n+\t      bool set_jump = (find_reg_note (insn, REG_SETJMP, NULL) != NULL);\n+\t      EXECUTE_IF_SET_IN_BITMAP (live, 0, regno, bi)\n+\t\t{\n+\t\t  REG_N_CALLS_CROSSED (regno)++;\n+\t\t  if (can_throw)\n+\t\t    REG_N_THROWING_CALLS_CROSSED (regno)++;\n+\n+\t\t  /* We have a problem with any pseudoreg that lives\n+\t\t     across the setjmp.  ANSI says that if a user\n+\t\t     variable does not change in value between the\n+\t\t     setjmp and the longjmp, then the longjmp\n+\t\t     preserves it.  This includes longjmp from a place\n+\t\t     where the pseudo appears dead.  (In principle,\n+\t\t     the value still exists if it is in scope.)  If\n+\t\t     the pseudo goes in a hard reg, some other value\n+\t\t     may occupy that hard reg where this pseudo is\n+\t\t     dead, thus clobbering the pseudo.  Conclusion:\n+\t\t     such a pseudo must not go in a hard reg.  */\n+\t\t  if (set_jump && regno >= FIRST_PSEUDO_REGISTER)\n+\t\t    bitmap_set_bit (setjumps_crossed, regno);\n+\t\t}\n+\t    }\n+\t  \n+\t  /* We only care about real sets for calls.  Clobbers only\n+\t     may clobber and cannot be depended on.  */\n+\t  for (mws = DF_INSN_UID_MWS (df, uid); mws; mws = mws->next)\n+\t    {\n+\t      if ((mws->type == DF_REF_REG_DEF) \n+\t\t  && !df_ignore_stack_reg (REGNO (mws->mw_reg)))\n+\t\tdf_set_unused_notes_for_mw (insn, mws, live, do_not_gen, \n+\t\t\t\t\t    artificial_uses, dflow->flags);\n+\t    }\n+\n+\t  /* All of the defs except the return value are some sort of\n+\t     clobber.  This code is for the return.  */\n+\t  for (def = DF_INSN_UID_DEFS (df, uid); def; def = def->next_ref)\n+\t    if (!(DF_REF_FLAGS (def) & (DF_REF_MUST_CLOBBER | DF_REF_MAY_CLOBBER)))\n+\t      df_create_unused_note (bb, insn, def, live, do_not_gen, \n+\t\t\t\t     artificial_uses, local_live, \n+\t\t\t\t     local_processed, dflow->flags, luid);\n \n-\t  /* Kill this register.  */\n-\t  bitmap_clear_bit (live, dregno);\n+\t}\n+      else\n+\t{\n+\t  /* Regular insn.  */\n+\t  for (mws = DF_INSN_UID_MWS (df, uid); mws; mws = mws->next)\n+\t    {\n+\t      if (mws->type == DF_REF_REG_DEF)\n+\t\tdf_set_unused_notes_for_mw (insn, mws, live, do_not_gen, \n+\t\t\t\t\t    artificial_uses, dflow->flags);\n+\t    }\n+\n+\t  for (def = DF_INSN_UID_DEFS (df, uid); def; def = def->next_ref)\n+\t    df_create_unused_note (bb, insn, def, live, do_not_gen, \n+\t\t\t\t   artificial_uses, local_live, \n+\t\t\t\t   local_processed, dflow->flags, luid);\n+\t}\n+      \n+      /* Process the uses.  */\n+      for (mws = DF_INSN_UID_MWS (df, uid); mws; mws = mws->next)\n+\t{\n+\t  if ((mws->type != DF_REF_REG_DEF)  \n+\t      && !df_ignore_stack_reg (REGNO (mws->mw_reg)))\n+\t    df_set_dead_notes_for_mw (insn, mws, live, do_not_gen,\n+\t\t\t\t      artificial_uses, dflow->flags);\n \t}\n \n-      for (use = DF_INSN_UID_GET (df, uid)->uses; use; use = use->next_ref)\n+      for (use = DF_INSN_UID_USES (df, uid); use; use = use->next_ref)\n \t{\n \t  unsigned int uregno = DF_REF_REGNO (use);\n \n+\t  if ((dflow->flags & DF_RI_LIFE) && (uregno >= FIRST_PSEUDO_REGISTER))\n+\t    {\n+\t      REG_FREQ (uregno) += REG_FREQ_FROM_BB (bb);\n+\t      if (REG_BASIC_BLOCK (uregno) == REG_BLOCK_UNKNOWN)\n+\t\tREG_BASIC_BLOCK (uregno) = bb->index;\n+\t      else if (REG_BASIC_BLOCK (uregno) != bb->index)\n+\t\tREG_BASIC_BLOCK (uregno) = REG_BLOCK_GLOBAL;\n+\t    }\n+\t  \n+#ifdef REG_DEAD_DEBUGGING\n+\t  fprintf (stderr, \"  regular looking at use \");\n+\t  df_ref_debug (use, stderr);\n+#endif\n \t  if (!bitmap_bit_p (live, uregno))\n \t    {\n-\t      use->flags |= DF_REF_DIES_AFTER_THIS_USE;\n+\t      if ( (!(DF_REF_FLAGS (use) & DF_REF_MW_HARDREG))\n+\t\t   && (!bitmap_bit_p (do_not_gen, uregno))\n+\t\t   && (!bitmap_bit_p (artificial_uses, uregno))\n+\t\t   && (!(DF_REF_FLAGS (use) & DF_REF_READ_WRITE))\n+\t\t   && (!df_ignore_stack_reg (uregno)))\n+\t\t{\n+\t\t  rtx reg = GET_CODE (*DF_REF_LOC (use)) == SUBREG ?\n+\t\t    SUBREG_REG (*DF_REF_LOC (use)) : *DF_REF_LOC (use);\n+\t\t  rtx note = alloc_EXPR_LIST (REG_DEAD, reg, REG_NOTES (insn));\n+\t\t  REG_NOTES (insn) = note;\n+\t\t  if (dflow->flags & DF_RI_LIFE)\n+\t\t    REG_N_DEATHS (uregno)++;\n+\n+#ifdef REG_DEAD_DEBUGGING\n+\t\t  print_note (\"adding 4: \", insn, note);\n+#endif\n+\t\t}\n \t      /* This register is now live.  */\n \t      bitmap_set_bit (live, uregno);\n+\n+\t      if (dflow->flags & DF_RI_LIFE)\n+\t\t{\n+\t\t  /* If we have seen this regno, then it has already\n+\t\t     been processed correctly with the per insn\n+\t\t     increment.  If we have not seen it we set the bit\n+\t\t     so that begins to get processed locally.  Note\n+\t\t     that we don't even get here if the variable was\n+\t\t     live at the end of the block since just a ref\n+\t\t     inside the block does not effect the\n+\t\t     calculations.  */\n+\t\t  REG_LIVE_LENGTH (uregno) ++;\n+\t\t  bitmap_set_bit (local_live, uregno);\n+\t\t  bitmap_set_bit (local_processed, uregno);\n+\t\t}\n \t    }\n-\t  else\n-\t    use->flags &= ~DF_REF_DIES_AFTER_THIS_USE;\n \t}\n-\n-      /* Increment lifetimes of all live registers.  */\n+    }\n+  \n+  if (dflow->flags & DF_RI_LIFE)\n+    {\n+      /* Add the length of the block to all of the registers that were\n+\t not referenced, but still live in this block.  */\n+      bitmap_iterator bi;\n+      unsigned int regno;\n+      bitmap_and_compl_into (live, local_processed);\n       EXECUTE_IF_SET_IN_BITMAP (live, 0, regno, bi)\n \t{\n-\t  problem_data->lifetime[regno]++;\n+\t  REG_LIVE_LENGTH (regno) += luid;\n \t}\n+      bitmap_clear (local_processed);\n+      bitmap_clear (local_live);\n     }\n }\n \n@@ -3172,16 +3652,50 @@ df_ri_compute (struct dataflow *dflow, bitmap all_blocks ATTRIBUTE_UNUSED,\n {\n   unsigned int bb_index;\n   bitmap_iterator bi;\n-  bitmap live;\n+  bitmap live = BITMAP_ALLOC (NULL);\n+  bitmap do_not_gen = BITMAP_ALLOC (NULL);\n+  bitmap artificial_uses = BITMAP_ALLOC (NULL);\n+  bitmap local_live = NULL;\n+  bitmap local_processed = NULL;\n+  bitmap setjumps_crossed = NULL;\n+\n+  if (dflow->flags & DF_RI_LIFE)\n+    {\n+      local_live = BITMAP_ALLOC (NULL);\n+      local_processed = BITMAP_ALLOC (NULL);\n+      setjumps_crossed = BITMAP_ALLOC (NULL);\n+    }\n \n-  live = BITMAP_ALLOC (NULL);\n+\n+#ifdef REG_DEAD_DEBUGGING\n+  df_lr_dump (dflow->df->problems_by_index [DF_LR], stderr);\n+  print_rtl_with_bb (stderr, get_insns());\n+#endif\n \n   EXECUTE_IF_SET_IN_BITMAP (blocks_to_scan, 0, bb_index, bi)\n   {\n-    df_ri_bb_compute (dflow, bb_index, live);\n+    df_ri_bb_compute (dflow, bb_index, live, do_not_gen, artificial_uses,\n+\t\t      local_live, local_processed, setjumps_crossed);\n   }\n \n   BITMAP_FREE (live);\n+  BITMAP_FREE (do_not_gen);\n+  BITMAP_FREE (artificial_uses);\n+  if (dflow->flags & DF_RI_LIFE)\n+    {\n+      bitmap_iterator bi;\n+      unsigned int regno;\n+      /* See the setjump comment in df_ri_bb_compute.  */\n+      EXECUTE_IF_SET_IN_BITMAP (setjumps_crossed, 0, regno, bi)\n+\t{\n+\t  REG_BASIC_BLOCK (regno) = REG_BLOCK_UNKNOWN;\n+\t  REG_LIVE_LENGTH (regno) = -1;\n+\t}\t  \n+\n+      BITMAP_FREE (local_live);\n+      BITMAP_FREE (local_processed);\n+      BITMAP_FREE (setjumps_crossed);\n+    }\n }\n \n \n@@ -3190,10 +3704,6 @@ df_ri_compute (struct dataflow *dflow, bitmap all_blocks ATTRIBUTE_UNUSED,\n static void\n df_ri_free (struct dataflow *dflow)\n {\n-  struct df_ri_problem_data *problem_data =\n-    (struct df_ri_problem_data *) dflow->problem_data;\n-\n-  free (problem_data->lifetime);\n   free (dflow->problem_data);\n   free (dflow);\n }\n@@ -3204,14 +3714,12 @@ df_ri_free (struct dataflow *dflow)\n static void\n df_ri_dump (struct dataflow *dflow, FILE *file)\n {\n-  struct df_ri_problem_data *problem_data =\n-    (struct df_ri_problem_data *) dflow->problem_data;\n-  int j;\n+  print_rtl_with_bb (file, get_insns ());\n \n-  fprintf (file, \"Register info:\\n\");\n-  for (j = 0; j < max_reg_num (); j++)\n+  if (dflow->flags & DF_RI_LIFE)\n     {\n-      fprintf (file, \"reg %d life %d\\n\", j, problem_data->lifetime[j]);\n+      fprintf (file, \"Register info:\\n\");\n+      dump_flow_info (file, -1);\n     }\n }\n \n@@ -3233,7 +3741,12 @@ static struct df_problem problem_RI =\n   NULL,                       /* Finalize function.  */\n   df_ri_free,                 /* Free all of the problem information.  */\n   df_ri_dump,                 /* Debugging.  */\n-  &problem_UR                 /* Dependent problem.  */\n+\n+  /* Technically this is only dependent on the live registers problem\n+     but it will produce infomation if built one of uninitialized\n+     register problems (UR, UREC) is also run.  */\n+  df_lr_add_problem,          /* Dependent problem.  */\n+  0                           /* Changeable flags.  */\n };\n \n \n@@ -3242,20 +3755,7 @@ static struct df_problem problem_RI =\n    solution.  */\n \n struct dataflow * \n-df_ri_add_problem (struct df *df)\n+df_ri_add_problem (struct df *df, int flags)\n {\n-  return df_add_problem (df, &problem_RI);\n+  return df_add_problem (df, &problem_RI, flags);\n }\n-\n-\n-/* Return total lifetime (in insns) of REG.  */\n-int\n-df_reg_lifetime (struct df *df, rtx reg)\n-{\n-  struct dataflow *dflow = df->problems_by_index[DF_RI];\n-  struct df_ri_problem_data *problem_data =\n-    (struct df_ri_problem_data *) dflow->problem_data;\n-  return problem_data->lifetime[REGNO (reg)];\n-}\n-\n-"}, {"sha": "46dfb072cce43fb561134e1950cfac56f14166af", "filename": "gcc/df-scan.c", "status": "modified", "additions": 264, "deletions": 157, "changes": 421, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23249ac43c6d4d9dde16347bc44dc757e41f1d8d/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23249ac43c6d4d9dde16347bc44dc757e41f1d8d/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=23249ac43c6d4d9dde16347bc44dc757e41f1d8d", "patch": "@@ -65,9 +65,6 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #define EPILOGUE_USES(REGNO)  0\n #endif\n \n-/* Indicates where we are in the compilation.  */\n-int df_state;\n-\n /* The bitmap_obstack is used to hold some static variables that\n    should not be reset after each function is compiled.  */\n \n@@ -122,6 +119,8 @@ struct df_scan_problem_data\n   alloc_pool ref_pool;\n   alloc_pool insn_pool;\n   alloc_pool reg_pool;\n+  alloc_pool mw_reg_pool;\n+  alloc_pool mw_link_pool;\n };\n \n typedef struct df_scan_bb_info *df_scan_bb_info_t;\n@@ -130,8 +129,8 @@ static void\n df_scan_free_internal (struct dataflow *dflow)\n {\n   struct df *df = dflow->df;\n-  struct df_scan_problem_data *problem_data = \n-    (struct df_scan_problem_data *) dflow->problem_data;\n+  struct df_scan_problem_data *problem_data\n+    = (struct df_scan_problem_data *) dflow->problem_data;\n \n   free (df->def_info.regs);\n   free (df->def_info.refs);\n@@ -157,6 +156,8 @@ df_scan_free_internal (struct dataflow *dflow)\n   free_alloc_pool (problem_data->ref_pool);\n   free_alloc_pool (problem_data->insn_pool);\n   free_alloc_pool (problem_data->reg_pool);\n+  free_alloc_pool (problem_data->mw_reg_pool);\n+  free_alloc_pool (problem_data->mw_link_pool);\n }\n \n \n@@ -200,7 +201,8 @@ df_scan_free_bb_info (struct dataflow *dflow, basic_block bb, void *vbb_info)\n    be rescanned.  */\n \n static void \n-df_scan_alloc (struct dataflow *dflow, bitmap blocks_to_rescan)\n+df_scan_alloc (struct dataflow *dflow, bitmap blocks_to_rescan, \n+\t       bitmap all_blocks ATTRIBUTE_UNUSED)\n {\n   struct df *df = dflow->df;\n   struct df_scan_problem_data *problem_data;\n@@ -231,6 +233,12 @@ df_scan_alloc (struct dataflow *dflow, bitmap blocks_to_rescan)\n   problem_data->reg_pool \n     = create_alloc_pool (\"df_scan_reg pool\", \n \t\t\t sizeof (struct df_reg_info), block_size);\n+  problem_data->mw_reg_pool \n+    = create_alloc_pool (\"df_scan_mw_reg pool\", \n+\t\t\t sizeof (struct df_mw_hardreg), block_size);\n+  problem_data->mw_link_pool \n+    = create_alloc_pool (\"df_scan_mw_link pool\", \n+\t\t\t sizeof (struct df_link), block_size);\n \n   insn_num += insn_num / 4; \n   df_grow_reg_info (dflow, &df->def_info);\n@@ -319,7 +327,8 @@ static struct df_problem problem_SCAN =\n   NULL,                       /* Finalize function.  */\n   df_scan_free,               /* Free all of the problem information.  */\n   df_scan_dump,               /* Debugging.  */\n-  NULL                        /* Dependent problem.  */\n+  NULL,                       /* Dependent problem.  */\n+  0                           /* Changeable flags.  */\n };\n \n \n@@ -328,9 +337,9 @@ static struct df_problem problem_SCAN =\n    solution.  */\n \n struct dataflow *\n-df_scan_add_problem (struct df *df)\n+df_scan_add_problem (struct df *df, int flags)\n {\n-  return df_add_problem (df, &problem_SCAN);\n+  return df_add_problem (df, &problem_SCAN, flags);\n }\n \n /*----------------------------------------------------------------------------\n@@ -350,8 +359,8 @@ df_grow_reg_info (struct dataflow *dflow, struct df_ref_info *ref_info)\n {\n   unsigned int max_reg = max_reg_num ();\n   unsigned int new_size = max_reg;\n-  struct df_scan_problem_data *problem_data =\n-    (struct df_scan_problem_data *) dflow->problem_data;\n+  struct df_scan_problem_data *problem_data\n+    = (struct df_scan_problem_data *) dflow->problem_data;\n   unsigned int i;\n \n   if (ref_info->regs_size < new_size)\n@@ -432,6 +441,9 @@ df_rescan_blocks (struct df *df, bitmap blocks)\n   if (blocks)\n     {\n       int i;\n+      unsigned int bb_index;\n+      bitmap_iterator bi;\n+      bool cleared_bits = false;\n \n       /* Need to assure that there are space in all of the tables.  */\n       unsigned int insn_num = get_max_uid () + 1;\n@@ -447,6 +459,20 @@ df_rescan_blocks (struct df *df, bitmap blocks)\n       df_grow_bb_info (dflow);\n \n       bitmap_copy (local_blocks_to_scan, blocks);\n+\n+      EXECUTE_IF_SET_IN_BITMAP (blocks, 0, bb_index, bi)\n+\t{\n+\t  basic_block bb = BASIC_BLOCK (bb_index);\n+\t  if (!bb)\n+\t    {\n+\t      bitmap_clear_bit (local_blocks_to_scan, bb_index);\n+\t      cleared_bits = true;\n+\t    }\n+\t}\n+\n+      if (cleared_bits)\n+\tbitmap_copy (blocks, local_blocks_to_scan);\n+\n       df->def_info.add_refs_inline = true;\n       df->use_info.add_refs_inline = true;\n \n@@ -490,7 +516,7 @@ df_rescan_blocks (struct df *df, bitmap blocks)\n \t  {\n \t    bitmap_set_bit (local_blocks_to_scan, bb->index);\n \t  }\n-      df_scan_alloc (dflow, local_blocks_to_scan);\n+      df_scan_alloc (dflow, local_blocks_to_scan, NULL);\n \n       df->def_info.add_refs_inline = false;\n       df->use_info.add_refs_inline = false;\n@@ -508,6 +534,7 @@ df_rescan_blocks (struct df *df, bitmap blocks)\n   BITMAP_FREE (local_blocks_to_scan);\n }\n \n+\n /* Create a new ref of type DF_REF_TYPE for register REG at address\n    LOC within INSN of BB.  */\n \n@@ -634,8 +661,8 @@ df_reg_chain_unlink (struct dataflow *dflow, struct df_ref *ref)\n   struct df *df = dflow->df;\n   struct df_ref *next = DF_REF_NEXT_REG (ref);  \n   struct df_ref *prev = DF_REF_PREV_REG (ref);\n-  struct df_scan_problem_data *problem_data =\n-    (struct df_scan_problem_data *) dflow->problem_data;\n+  struct df_scan_problem_data *problem_data\n+    = (struct df_scan_problem_data *) dflow->problem_data;\n   struct df_reg_info *reg_info;\n   struct df_ref *next_ref = ref->next_ref;\n   unsigned int id = DF_REF_ID (ref);\n@@ -697,8 +724,8 @@ df_ref_remove (struct df *df, struct df_ref *ref)\n \t    = df_ref_unlink (bb_info->artificial_defs, ref);\n \t}\n       else\n-\tDF_INSN_UID_DEFS (df, DF_REF_INSN_UID (ref)) = \n-\t  df_ref_unlink (DF_INSN_UID_DEFS (df, DF_REF_INSN_UID (ref)), ref);\n+\tDF_INSN_UID_DEFS (df, DF_REF_INSN_UID (ref))\n+\t  = df_ref_unlink (DF_INSN_UID_DEFS (df, DF_REF_INSN_UID (ref)), ref);\n \n       if (df->def_info.add_refs_inline)\n \tDF_DEFS_SET (df, DF_REF_ID (ref), NULL);\n@@ -713,8 +740,8 @@ df_ref_remove (struct df *df, struct df_ref *ref)\n \t    = df_ref_unlink (bb_info->artificial_uses, ref);\n \t}\n       else\n-\tDF_INSN_UID_USES (df, DF_REF_INSN_UID (ref)) = \n-\t  df_ref_unlink (DF_INSN_UID_USES (df, DF_REF_INSN_UID (ref)), ref);\n+\tDF_INSN_UID_USES (df, DF_REF_INSN_UID (ref))\n+\t  = df_ref_unlink (DF_INSN_UID_USES (df, DF_REF_INSN_UID (ref)), ref);\n       \n       if (df->use_info.add_refs_inline)\n \tDF_USES_SET (df, DF_REF_ID (ref), NULL);\n@@ -730,8 +757,8 @@ static struct df_insn_info *\n df_insn_create_insn_record (struct dataflow *dflow, rtx insn)\n {\n   struct df *df = dflow->df;\n-  struct df_scan_problem_data *problem_data =\n-    (struct df_scan_problem_data *) dflow->problem_data;\n+  struct df_scan_problem_data *problem_data\n+    = (struct df_scan_problem_data *) dflow->problem_data;\n \n   struct df_insn_info *insn_rec = DF_INSN_GET (df, insn);\n   if (!insn_rec)\n@@ -754,14 +781,31 @@ df_insn_refs_delete (struct dataflow *dflow, rtx insn)\n   unsigned int uid = INSN_UID (insn);\n   struct df_insn_info *insn_info = NULL;\n   struct df_ref *ref;\n-  struct df_scan_problem_data *problem_data =\n-    (struct df_scan_problem_data *) dflow->problem_data;\n+  struct df_scan_problem_data *problem_data\n+    = (struct df_scan_problem_data *) dflow->problem_data;\n \n   if (uid < df->insns_size)\n     insn_info = DF_INSN_UID_GET (df, uid);\n \n   if (insn_info)\n     {\n+      struct df_mw_hardreg *hardregs = insn_info->mw_hardregs;\n+      \n+      while (hardregs)\n+\t{\n+\t  struct df_mw_hardreg *next_hr = hardregs->next;\n+\t  struct df_link *link = hardregs->regs;\n+\t  while (link)\n+\t    {\n+\t      struct df_link *next_l = link->next;\n+\t      pool_free (problem_data->mw_link_pool, link);\n+\t      link = next_l;\n+\t    }\n+\t  \n+\t  pool_free (problem_data->mw_reg_pool, hardregs);\n+\t  hardregs = next_hr;\n+\t}\n+\n       ref = insn_info->defs;\n       while (ref) \n \tref = df_reg_chain_unlink (dflow, ref);\n@@ -875,20 +919,6 @@ df_reorganize_refs (struct df_ref_info *ref_info)\n   ref_info->add_refs_inline = true;\n }\n \n-\f\n-/* Local miscellaneous routines.  */\n-\n-/* Local routines for recording refs.  */\n-\n-/* Set where we are in the compilation.  */\n-\n-void \n-df_set_state (int state)\n-{\n-  df_state = state;\n-}\n-\n-\n \f\n /*----------------------------------------------------------------------------\n    Hard core instruction scanning code.  No external interfaces here,\n@@ -906,8 +936,8 @@ df_ref_create_structure (struct dataflow *dflow, rtx reg, rtx *loc,\n   struct df_ref *this_ref;\n   struct df *df = dflow->df;\n   int regno = REGNO (GET_CODE (reg) == SUBREG ? SUBREG_REG (reg) : reg);\n-  struct df_scan_problem_data *problem_data =\n-    (struct df_scan_problem_data *) dflow->problem_data;\n+  struct df_scan_problem_data *problem_data\n+    = (struct df_scan_problem_data *) dflow->problem_data;\n \n   this_ref = pool_alloc (problem_data->ref_pool);\n   DF_REF_REG (this_ref) = reg;\n@@ -922,76 +952,88 @@ df_ref_create_structure (struct dataflow *dflow, rtx reg, rtx *loc,\n \n   /* Link the ref into the reg_def and reg_use chains and keep a count\n      of the instances.  */\n-  if (ref_type == DF_REF_REG_DEF)\n+  switch (ref_type)\n     {\n-      struct df_reg_info *reg_info = DF_REG_DEF_GET (df, regno);\n-      reg_info->n_refs++;\n-\n-      /* Add the ref to the reg_def chain.  */\n-      df_reg_chain_create (reg_info, this_ref);\n-      DF_REF_ID (this_ref) = df->def_info.bitmap_size;\n-      if (df->def_info.add_refs_inline)\n-\t{\n-\t  if (DF_DEFS_SIZE (df) >= df->def_info.refs_size)\n-\t    {\n-\t      int new_size = df->def_info.bitmap_size \n-\t\t+ df->def_info.bitmap_size / 4;\n-\t      df_grow_ref_info (&df->def_info, new_size);\n-\t    }\n-\t  /* Add the ref to the big array of defs.  */\n-\t  DF_DEFS_SET (df, df->def_info.bitmap_size, this_ref);\n-\t  df->def_info.refs_organized = false;\n-\t}\n-\n-      df->def_info.bitmap_size++;\n+    case DF_REF_REG_DEF:\n+      {\n+\tstruct df_reg_info *reg_info = DF_REG_DEF_GET (df, regno);\n+\treg_info->n_refs++;\n+\t\n+\t/* Add the ref to the reg_def chain.  */\n+\tdf_reg_chain_create (reg_info, this_ref);\n+\tDF_REF_ID (this_ref) = df->def_info.bitmap_size;\n+\tif (df->def_info.add_refs_inline)\n+\t  {\n+\t    if (DF_DEFS_SIZE (df) >= df->def_info.refs_size)\n+\t      {\n+\t\tint new_size = df->def_info.bitmap_size \n+\t\t  + df->def_info.bitmap_size / 4;\n+\t\tdf_grow_ref_info (&df->def_info, new_size);\n+\t      }\n+\t    /* Add the ref to the big array of defs.  */\n+\t    DF_DEFS_SET (df, df->def_info.bitmap_size, this_ref);\n+\t    df->def_info.refs_organized = false;\n+\t  }\n+\t\n+\tdf->def_info.bitmap_size++;\n+\t\n+\tif (DF_REF_FLAGS (this_ref) & DF_REF_ARTIFICIAL)\n+\t  {\n+\t    struct df_scan_bb_info *bb_info \n+\t      = df_scan_get_bb_info (dflow, bb->index);\n+\t    this_ref->next_ref = bb_info->artificial_defs;\n+\t    bb_info->artificial_defs = this_ref;\n+\t  }\n+\telse\n+\t  {\n+\t    this_ref->next_ref = DF_INSN_GET (df, insn)->defs;\n+\t    DF_INSN_GET (df, insn)->defs = this_ref;\n+\t  }\n+      }\n+      break;\n \n-      if (DF_REF_FLAGS (this_ref) & DF_REF_ARTIFICIAL)\n-\t{\n-\t  struct df_scan_bb_info *bb_info \n-\t    = df_scan_get_bb_info (dflow, bb->index);\n-\t  this_ref->next_ref = bb_info->artificial_defs;\n-\t  bb_info->artificial_defs = this_ref;\n-\t}\n-      else\n-\t{\n-\t  this_ref->next_ref = DF_INSN_GET (df, insn)->defs;\n-\t  DF_INSN_GET (df, insn)->defs = this_ref;\n-\t}\n-    }\n-  else\n-    {\n-      struct df_reg_info *reg_info = DF_REG_USE_GET (df, regno);\n-      reg_info->n_refs++;\n+    case DF_REF_REG_MEM_LOAD:\n+    case DF_REF_REG_MEM_STORE:\n+    case DF_REF_REG_USE:\n+      {\n+\tstruct df_reg_info *reg_info = DF_REG_USE_GET (df, regno);\n+\treg_info->n_refs++;\n+\t\n+\t/* Add the ref to the reg_use chain.  */\n+\tdf_reg_chain_create (reg_info, this_ref);\n+\tDF_REF_ID (this_ref) = df->use_info.bitmap_size;\n+\tif (df->use_info.add_refs_inline)\n+\t  {\n+\t    if (DF_USES_SIZE (df) >= df->use_info.refs_size)\n+\t      {\n+\t\tint new_size = df->use_info.bitmap_size \n+\t\t  + df->use_info.bitmap_size / 4;\n+\t\tdf_grow_ref_info (&df->use_info, new_size);\n+\t      }\n+\t    /* Add the ref to the big array of defs.  */\n+\t    DF_USES_SET (df, df->use_info.bitmap_size, this_ref);\n+\t    df->use_info.refs_organized = false;\n+\t  }\n+\t\n+\tdf->use_info.bitmap_size++;\n+\tif (DF_REF_FLAGS (this_ref) & DF_REF_ARTIFICIAL)\n+\t  {\n+\t    struct df_scan_bb_info *bb_info \n+\t      = df_scan_get_bb_info (dflow, bb->index);\n+\t    this_ref->next_ref = bb_info->artificial_uses;\n+\t    bb_info->artificial_uses = this_ref;\n+\t  }\n+\telse\n+\t  {\n+\t    this_ref->next_ref = DF_INSN_GET (df, insn)->uses;\n+\t    DF_INSN_GET (df, insn)->uses = this_ref;\n+\t  }\n+      }\n+      break;\n \n-      /* Add the ref to the reg_use chain.  */\n-      df_reg_chain_create (reg_info, this_ref);\n-      DF_REF_ID (this_ref) = df->use_info.bitmap_size;\n-      if (df->use_info.add_refs_inline)\n-\t{\n-\t  if (DF_USES_SIZE (df) >= df->use_info.refs_size)\n-\t    {\n-\t      int new_size = df->use_info.bitmap_size \n-\t\t+ df->use_info.bitmap_size / 4;\n-\t      df_grow_ref_info (&df->use_info, new_size);\n-\t    }\n-\t  /* Add the ref to the big array of defs.  */\n-\t  DF_USES_SET (df, df->use_info.bitmap_size, this_ref);\n-\t  df->use_info.refs_organized = false;\n-\t}\n+    default:\n+      gcc_unreachable ();\n \n-      df->use_info.bitmap_size++;\n-      if (DF_REF_FLAGS (this_ref) & DF_REF_ARTIFICIAL)\n-\t{\n-\t  struct df_scan_bb_info *bb_info \n-\t    = df_scan_get_bb_info (dflow, bb->index);\n-\t  this_ref->next_ref = bb_info->artificial_uses;\n-\t  bb_info->artificial_uses = this_ref;\n-\t}\n-      else\n-\t{\n-\t  this_ref->next_ref = DF_INSN_GET (df, insn)->uses;\n-\t  DF_INSN_GET (df, insn)->uses = this_ref;\n-\t}\n     }\n   return this_ref;\n }\n@@ -1007,8 +1049,9 @@ df_ref_record (struct dataflow *dflow, rtx reg, rtx *loc,\n \t       enum df_ref_flags ref_flags, \n \t       bool record_live)\n {\n-  unsigned int regno;\n   struct df *df = dflow->df;\n+  rtx oldreg = reg;\n+  unsigned int regno;\n \n   gcc_assert (REG_P (reg) || GET_CODE (reg) == SUBREG);\n \n@@ -1017,7 +1060,7 @@ df_ref_record (struct dataflow *dflow, rtx reg, rtx *loc,\n      reg.  As written in the docu those should have the form\n      (subreg:SI (reg:M A) N), with size(SImode) > size(Mmode).\n      XXX Is that true?  We could also use the global word_mode variable.  */\n-  if ((df->flags & DF_SUBREGS) == 0\n+  if ((dflow->flags & DF_SUBREGS) == 0\n       && GET_CODE (reg) == SUBREG\n       && (GET_MODE_SIZE (GET_MODE (reg)) < GET_MODE_SIZE (word_mode)\n \t  || GET_MODE_SIZE (GET_MODE (reg))\n@@ -1031,10 +1074,13 @@ df_ref_record (struct dataflow *dflow, rtx reg, rtx *loc,\n   regno = REGNO (GET_CODE (reg) == SUBREG ? SUBREG_REG (reg) : reg);\n   if (regno < FIRST_PSEUDO_REGISTER)\n     {\n-      int i;\n-      int endregno;\n+      unsigned int i;\n+      unsigned int endregno;\n+      struct df_mw_hardreg *hardreg = NULL;\n+      struct df_scan_problem_data *problem_data\n+\t= (struct df_scan_problem_data *) dflow->problem_data;\n \n-      if (! (df->flags & DF_HARD_REGS))\n+      if (!(dflow->flags & DF_HARD_REGS))\n \treturn;\n \n       /* GET_MODE (reg) is correct here.  We do not want to go into a SUBREG\n@@ -1048,8 +1094,30 @@ df_ref_record (struct dataflow *dflow, rtx reg, rtx *loc,\n \t\t\t\t      SUBREG_BYTE (reg), GET_MODE (reg));\n       endregno += regno;\n \n+      /*  If this is a multiword hardreg, we create some extra datastructures that \n+\t  will enable us to easily build REG_DEAD and REG_UNUSED notes.  */\n+      if ((endregno != regno + 1) && insn)\n+\t{\n+\t  struct df_insn_info *insn_info = DF_INSN_GET (df, insn);\n+\t  /* Sets to a subreg of a multiword register are partial. \n+\t     Sets to a non-subreg of a multiword register are not.  */\n+\t  if (GET_CODE (oldreg) == SUBREG)\n+\t    ref_flags |= DF_REF_PARTIAL;\n+\t  ref_flags |= DF_REF_MW_HARDREG;\n+\t  hardreg = pool_alloc (problem_data->mw_reg_pool);\n+\t  hardreg->next = insn_info->mw_hardregs;\n+\t  insn_info->mw_hardregs = hardreg;\n+\t  hardreg->type = ref_type;\n+\t  hardreg->flags = ref_flags;\n+\t  hardreg->mw_reg = reg;\n+\t  hardreg->regs = NULL;\n+\n+\t}\n+\n       for (i = regno; i < endregno; i++)\n \t{\n+\t  struct df_ref *ref;\n+\n \t  /* Calls are handled at call site because regs_ever_live\n \t     doesn't include clobbered regs, only used ones.  */\n \t  if (ref_type == DF_REF_REG_DEF && record_live)\n@@ -1061,14 +1129,22 @@ df_ref_record (struct dataflow *dflow, rtx reg, rtx *loc,\n \t    {\n \t      /* Set regs_ever_live on uses of non-eliminable frame\n \t\t pointers and arg pointers.  */\n-\t      if (! (TEST_HARD_REG_BIT (elim_reg_set, regno)\n+\t      if (!(TEST_HARD_REG_BIT (elim_reg_set, regno)\n \t\t     && (regno == FRAME_POINTER_REGNUM \n \t\t\t || regno == ARG_POINTER_REGNUM)))\n \t\tregs_ever_live[i] = 1;\n \t    }\n \n-\t  df_ref_create_structure (dflow, regno_reg_rtx[i], loc, \n-\t\t\t\t   bb, insn, ref_type, ref_flags);\n+\t  ref = df_ref_create_structure (dflow, regno_reg_rtx[i], loc, \n+\t\t\t\t\t bb, insn, ref_type, ref_flags);\n+\t  if (hardreg)\n+\t    {\n+\t      struct df_link *link = pool_alloc (problem_data->mw_link_pool);\n+\n+\t      link->next = hardreg->regs;\n+\t      link->ref = ref;\n+\t      hardreg->regs = link;\n+\t    }\n \t}\n     }\n   else\n@@ -1107,6 +1183,7 @@ df_def_record_1 (struct dataflow *dflow, rtx x,\n {\n   rtx *loc;\n   rtx dst;\n+  bool dst_in_strict_lowpart = false;\n \n  /* We may recursively call ourselves on EXPR_LIST when dealing with PARALLEL\n      construct.  */\n@@ -1127,7 +1204,8 @@ df_def_record_1 (struct dataflow *dflow, rtx x,\n \t  if (GET_CODE (temp) == EXPR_LIST || GET_CODE (temp) == CLOBBER\n \t      || GET_CODE (temp) == SET)\n \t    df_def_record_1 (dflow, temp, bb, insn, \n-\t\t\t     GET_CODE (temp) == CLOBBER ? flags | DF_REF_CLOBBER : flags, \n+\t\t\t     GET_CODE (temp) == CLOBBER \n+\t\t\t     ? flags | DF_REF_MUST_CLOBBER : flags, \n \t\t\t     record_live);\n \t}\n       return;\n@@ -1149,10 +1227,20 @@ df_def_record_1 (struct dataflow *dflow, rtx x,\n \t}\n #endif\n       loc = &XEXP (dst, 0);\n+      if (GET_CODE (dst) == STRICT_LOW_PART)\n+\tdst_in_strict_lowpart = true;\n       dst = *loc;\n       flags |= DF_REF_READ_WRITE;\n+\n     }\n \n+  /* Sets to a subreg of a single word register are partial sets if\n+     they are wrapped in a strict lowpart, and not partial otherwise.\n+  */\n+  if (GET_CODE (dst) == SUBREG && REG_P (SUBREG_REG (dst))\n+      && dst_in_strict_lowpart)\n+    flags |= DF_REF_PARTIAL;\n+    \n   if (REG_P (dst)\n       || (GET_CODE (dst) == SUBREG && REG_P (SUBREG_REG (dst))))\n     df_ref_record (dflow, dst, loc, bb, insn, \n@@ -1171,7 +1259,7 @@ df_defs_record (struct dataflow *dflow, rtx x, basic_block bb, rtx insn)\n     {\n       /* Mark the single def within the pattern.  */\n       df_def_record_1 (dflow, x, bb, insn, \n-\t\t       code == CLOBBER ? DF_REF_CLOBBER : 0, true);\n+\t\t       code == CLOBBER ? DF_REF_MUST_CLOBBER : 0, true);\n     }\n   else if (code == COND_EXEC)\n     {\n@@ -1232,7 +1320,7 @@ df_uses_record (struct dataflow *dflow, rtx *loc, enum df_ref_type ref_type,\n \n     case SUBREG:\n       /* While we're here, optimize this case.  */\n-\n+      flags |= DF_REF_PARTIAL;\n       /* In case the SUBREG is not of a REG, do not optimize.  */\n       if (!REG_P (SUBREG_REG (x)))\n \t{\n@@ -1424,8 +1512,8 @@ df_insn_contains_asm (rtx insn)\n static void\n df_insn_refs_record (struct dataflow *dflow, basic_block bb, rtx insn)\n {\n-  int i;\n   struct df *df = dflow->df;\n+  int i;\n \n   if (INSN_P (insn))\n     {\n@@ -1437,7 +1525,7 @@ df_insn_refs_record (struct dataflow *dflow, basic_block bb, rtx insn)\n       /* Record register defs.  */\n       df_defs_record (dflow, PATTERN (insn), bb, insn);\n \n-      if (df->flags & DF_EQUIV_NOTES)\n+      if (dflow->flags & DF_EQUIV_NOTES)\n \tfor (note = REG_NOTES (insn); note;\n \t     note = XEXP (note, 1))\n \t  {\n@@ -1490,7 +1578,7 @@ df_insn_refs_record (struct dataflow *dflow, basic_block bb, rtx insn)\n \t\t\t  DF_REF_REG_USE, bb, insn, \n \t\t\t  0);\n \n-\t  if (df->flags & DF_HARD_REGS)\n+\t  if (dflow->flags & DF_HARD_REGS)\n \t    {\n \t      bitmap_iterator bi;\n \t      unsigned int ui;\n@@ -1502,8 +1590,8 @@ df_insn_refs_record (struct dataflow *dflow, basic_block bb, rtx insn)\n \t\t\t\t  DF_REF_REG_USE, bb, insn, \n \t\t\t\t  0);\n \t      EXECUTE_IF_SET_IN_BITMAP (df_invalidated_by_call, 0, ui, bi)\n-\t        df_ref_record (dflow, regno_reg_rtx[ui], &regno_reg_rtx[ui], bb, insn, \n-\t                       DF_REF_REG_DEF, DF_REF_CLOBBER, false);\n+\t        df_ref_record (dflow, regno_reg_rtx[ui], &regno_reg_rtx[ui], bb, \n+\t\t\t       insn, DF_REF_REG_DEF, DF_REF_MAY_CLOBBER, false);\n \t    }\n \t}\n \n@@ -1537,6 +1625,10 @@ df_bb_refs_record (struct dataflow *dflow, basic_block bb)\n   rtx insn;\n   int luid = 0;\n   struct df_scan_bb_info *bb_info = df_scan_get_bb_info (dflow, bb->index);\n+  bitmap artificial_uses_at_bottom = NULL;\n+\n+  if (dflow->flags & DF_HARD_REGS)\n+    artificial_uses_at_bottom = BITMAP_ALLOC (NULL);\n \n   /* Need to make sure that there is a record in the basic block info. */  \n   if (!bb_info)\n@@ -1561,7 +1653,7 @@ df_bb_refs_record (struct dataflow *dflow, basic_block bb)\n     }\n \n #ifdef EH_RETURN_DATA_REGNO\n-  if ((df->flags & DF_HARD_REGS)\n+  if ((dflow->flags & DF_HARD_REGS)\n       && df_has_eh_preds (bb))\n     {\n       unsigned int i;\n@@ -1580,7 +1672,7 @@ df_bb_refs_record (struct dataflow *dflow, basic_block bb)\n #endif\n \n \n-  if ((df->flags & DF_HARD_REGS)\n+  if ((dflow->flags & DF_HARD_REGS)\n       && df_has_eh_preds (bb))\n     {\n #ifdef EH_USES\n@@ -1611,56 +1703,60 @@ df_bb_refs_record (struct dataflow *dflow, basic_block bb)\n \t{\n \t  if (frame_pointer_needed)\n \t    {\n-\t      df_uses_record (dflow, &regno_reg_rtx[FRAME_POINTER_REGNUM],\n-\t\t\t      DF_REF_REG_USE, bb, NULL, DF_REF_ARTIFICIAL);\n+\t      bitmap_set_bit (artificial_uses_at_bottom, FRAME_POINTER_REGNUM);\n #if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n-\t      df_uses_record (dflow, &regno_reg_rtx[HARD_FRAME_POINTER_REGNUM],\n-\t\t\t      DF_REF_REG_USE, bb, NULL, DF_REF_ARTIFICIAL);\n+\t      bitmap_set_bit (artificial_uses_at_bottom, HARD_FRAME_POINTER_REGNUM);\n #endif\n \t    }\n #if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n \t  if (fixed_regs[ARG_POINTER_REGNUM])\n-\t    df_uses_record (dflow, &regno_reg_rtx[ARG_POINTER_REGNUM],\n-\t\t\t    DF_REF_REG_USE, bb, NULL, \n-\t\t\t    DF_REF_ARTIFICIAL);\n+\t    bitmap_set_bit (artificial_uses_at_bottom, ARG_POINTER_REGNUM);\n #endif\n \t}\n     }\n \n-  if ((df->flags & DF_HARD_REGS) \n+  if ((dflow->flags & DF_HARD_REGS) \n       && bb->index >= NUM_FIXED_BLOCKS)\n     {\n       /* Before reload, there are a few registers that must be forced\n \t live everywhere -- which might not already be the case for\n \t blocks within infinite loops.  */\n-      if (! reload_completed)\n+      if (!reload_completed)\n \t{\n \t  \n \t  /* Any reference to any pseudo before reload is a potential\n \t     reference of the frame pointer.  */\n-\t  df_uses_record (dflow, &regno_reg_rtx[FRAME_POINTER_REGNUM],\n-\t\t\t  DF_REF_REG_USE, bb, NULL, DF_REF_ARTIFICIAL);\n+\t  bitmap_set_bit (artificial_uses_at_bottom, FRAME_POINTER_REGNUM);\n \t  \n #if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n \t  /* Pseudos with argument area equivalences may require\n \t     reloading via the argument pointer.  */\n \t  if (fixed_regs[ARG_POINTER_REGNUM])\n-\t    df_uses_record (dflow, &regno_reg_rtx[ARG_POINTER_REGNUM],\n-\t\t\t    DF_REF_REG_USE, bb, NULL, \n-\t\t\t    DF_REF_ARTIFICIAL);\n+\t    bitmap_set_bit (artificial_uses_at_bottom, ARG_POINTER_REGNUM);\n #endif\n \t  \n \t  /* Any constant, or pseudo with constant equivalences, may\n \t     require reloading from memory using the pic register.  */\n \t  if ((unsigned) PIC_OFFSET_TABLE_REGNUM != INVALID_REGNUM\n \t      && fixed_regs[PIC_OFFSET_TABLE_REGNUM])\n-\t    df_uses_record (dflow, &regno_reg_rtx[PIC_OFFSET_TABLE_REGNUM],\n-\t\t\t    DF_REF_REG_USE, bb, NULL, \n-\t\t\t    DF_REF_ARTIFICIAL);\n+\t    bitmap_set_bit (artificial_uses_at_bottom, PIC_OFFSET_TABLE_REGNUM);\n \t}\n       /* The all-important stack pointer must always be live.  */\n-      df_uses_record (dflow, &regno_reg_rtx[STACK_POINTER_REGNUM],\n-\t\t      DF_REF_REG_USE, bb, NULL, DF_REF_ARTIFICIAL);\n+      bitmap_set_bit (artificial_uses_at_bottom, STACK_POINTER_REGNUM);\n+    }\n+\n+  if (dflow->flags & DF_HARD_REGS)\n+    {\n+      bitmap_iterator bi;\n+      unsigned int regno;\n+\n+      EXECUTE_IF_SET_IN_BITMAP (artificial_uses_at_bottom, 0, regno, bi)\n+\t{\n+\t  df_uses_record (dflow, &regno_reg_rtx[regno],\n+\t\t\t  DF_REF_REG_USE, bb, NULL, DF_REF_ARTIFICIAL);\n+\t}\n+\n+      BITMAP_FREE (artificial_uses_at_bottom);\n     }\n }\n \n@@ -1716,16 +1812,16 @@ df_mark_reg (rtx reg, void *vset)\n    entry to the function.  */\n \n static void\n-df_record_entry_block_defs (struct dataflow * dflow)\n+df_record_entry_block_defs (struct dataflow *dflow)\n {\n   unsigned int i; \n   bitmap_iterator bi;\n   rtx r;\n-  struct df * df = dflow->df;\n+  struct df *df = dflow->df;\n \n   bitmap_clear (df->entry_block_defs);\n \n-  if (! (df->flags & DF_HARD_REGS))\n+  if (!(dflow->flags & DF_HARD_REGS))\n     return;\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n@@ -1750,6 +1846,9 @@ df_record_entry_block_defs (struct dataflow * dflow)\n     }\n   else\n     {\n+      /* The always important stack pointer.  */\n+      bitmap_set_bit (df->entry_block_defs, STACK_POINTER_REGNUM);\n+\n #ifdef INCOMING_RETURN_ADDR_RTX\n       if (REG_P (INCOMING_RETURN_ADDR_RTX))\n \tbitmap_set_bit (df->entry_block_defs, REGNO (INCOMING_RETURN_ADDR_RTX));\n@@ -1771,13 +1870,21 @@ df_record_entry_block_defs (struct dataflow * dflow)\n \tbitmap_set_bit (df->entry_block_defs, REGNO (r));\n     }\n \n-  /* These registers are live everywhere.  */\n-  if (!reload_completed)\n+  if ((!reload_completed) || frame_pointer_needed)\n     {\n       /* Any reference to any pseudo before reload is a potential\n \t reference of the frame pointer.  */\n       bitmap_set_bit (df->entry_block_defs, FRAME_POINTER_REGNUM);\n+#if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n+      /* If they are different, also mark the hard frame pointer as live.  */\n+      if (!LOCAL_REGNO (HARD_FRAME_POINTER_REGNUM))\n+\tbitmap_set_bit (df->entry_block_defs, HARD_FRAME_POINTER_REGNUM);\n+#endif\n+    }\n \n+  /* These registers are live everywhere.  */\n+  if (!reload_completed)\n+    {\n #ifdef EH_USES\n       /* The ia-64, the only machine that uses this, does not define these \n \t until after reload.  */\n@@ -1826,15 +1933,15 @@ df_record_exit_block_uses (struct dataflow *dflow)\n \n   bitmap_clear (df->exit_block_uses);\n   \n-  if (! (df->flags & DF_HARD_REGS))\n+  if (!(dflow->flags & DF_HARD_REGS))\n     return;\n \n   /* If exiting needs the right stack value, consider the stack\n      pointer live at the end of the function.  */\n   if ((HAVE_epilogue && epilogue_completed)\n-      || ! EXIT_IGNORE_STACK\n-      || (! FRAME_POINTER_REQUIRED\n-\t  && ! current_function_calls_alloca\n+      || !EXIT_IGNORE_STACK\n+      || (!FRAME_POINTER_REQUIRED\n+\t  && !current_function_calls_alloca\n \t  && flag_omit_frame_pointer)\n       || current_function_sp_is_unchanging)\n     {\n@@ -1845,12 +1952,12 @@ df_record_exit_block_uses (struct dataflow *dflow)\n      If we end up eliminating it, it will be removed from the live\n      list of each basic block by reload.  */\n   \n-  if (! reload_completed || frame_pointer_needed)\n+  if ((!reload_completed) || frame_pointer_needed)\n     {\n       bitmap_set_bit (df->exit_block_uses, FRAME_POINTER_REGNUM);\n #if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n       /* If they are different, also mark the hard frame pointer as live.  */\n-      if (! LOCAL_REGNO (HARD_FRAME_POINTER_REGNUM))\n+      if (!LOCAL_REGNO (HARD_FRAME_POINTER_REGNUM))\n \tbitmap_set_bit (df->exit_block_uses, HARD_FRAME_POINTER_REGNUM);\n #endif\n     }\n@@ -1875,8 +1982,8 @@ df_record_exit_block_uses (struct dataflow *dflow)\n     {\n       /* Mark all call-saved registers that we actually used.  */\n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\tif (regs_ever_live[i] && ! LOCAL_REGNO (i)\n-\t    && ! TEST_HARD_REG_BIT (regs_invalidated_by_call, i))\n+\tif (regs_ever_live[i] && !LOCAL_REGNO (i)\n+\t    && !TEST_HARD_REG_BIT (regs_invalidated_by_call, i))\n \t  bitmap_set_bit (df->exit_block_uses, i);\n     }\n   \n@@ -1893,7 +2000,7 @@ df_record_exit_block_uses (struct dataflow *dflow)\n #endif\n \n #ifdef EH_RETURN_STACKADJ_RTX\n-  if ((! HAVE_epilogue || ! epilogue_completed)\n+  if ((!HAVE_epilogue || ! epilogue_completed)\n       && current_function_calls_eh_return)\n     {\n       rtx tmp = EH_RETURN_STACKADJ_RTX;\n@@ -1903,7 +2010,7 @@ df_record_exit_block_uses (struct dataflow *dflow)\n #endif\n \n #ifdef EH_RETURN_HANDLER_RTX\n-  if ((! HAVE_epilogue || ! epilogue_completed)\n+  if ((!HAVE_epilogue || ! epilogue_completed)\n       && current_function_calls_eh_return)\n     {\n       rtx tmp = EH_RETURN_HANDLER_RTX;\n@@ -1915,7 +2022,7 @@ df_record_exit_block_uses (struct dataflow *dflow)\n   /* Mark function return value.  */\n   diddle_return_value (df_mark_reg, (void*) df->exit_block_uses);\n \n-  if (df->flags & DF_HARD_REGS)\n+  if (dflow->flags & DF_HARD_REGS)\n     EXECUTE_IF_SET_IN_BITMAP (df->exit_block_uses, 0, i, bi)\n       df_uses_record (dflow, &regno_reg_rtx[i], \n   \t\t      DF_REF_REG_USE, EXIT_BLOCK_PTR, NULL,"}, {"sha": "b1e93844ed3f82dc9bbcbe624cb39ceef44478d4", "filename": "gcc/df.h", "status": "modified", "additions": 126, "deletions": 91, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23249ac43c6d4d9dde16347bc44dc757e41f1d8d/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23249ac43c6d4d9dde16347bc44dc757e41f1d8d/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=23249ac43c6d4d9dde16347bc44dc757e41f1d8d", "patch": "@@ -34,6 +34,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n struct dataflow;\n struct df;\n struct df_problem;\n+struct df_link;\n \n /* Data flow problems.  All problems must have a unique here.  */ \n /* Scanning is not really a dataflow problem, but it is useful to have\n@@ -49,10 +50,6 @@ struct df_problem;\n #define DF_RI    7      /* Register Info. */\n #define DF_LAST_PROBLEM_PLUS1 (DF_RI + 1)\n \n-/* Flags that control the building of chains.  */\n-#define DF_DU_CHAIN   1    /* Build DU chains.  */  \n-#define DF_UD_CHAIN   2    /* Build UD chains.  */\n-\n \n /* Dataflow direction.  */\n enum df_flow_dir\n@@ -62,10 +59,72 @@ enum df_flow_dir\n     DF_BACKWARD\n   };\n \n+\n+/* The first of these is a set of a register.  The remaining three are\n+   all uses of a register (the mem_load and mem_store relate to how\n+   the register as an addressing operand).  */\n+enum df_ref_type {DF_REF_REG_DEF, DF_REF_REG_USE, DF_REF_REG_MEM_LOAD,\n+\t\t  DF_REF_REG_MEM_STORE};\n+\n+#define DF_REF_TYPE_NAMES {\"def\", \"use\", \"mem load\", \"mem store\"}\n+\n+enum df_ref_flags\n+  {\n+    /* Read-modify-write refs generate both a use and a def and\n+       these are marked with this flag to show that they are not\n+       independent.  */\n+    DF_REF_READ_WRITE = 1,\n+\n+    /* This flag is set, if we stripped the subreg from the reference.\n+       In this case we must make conservative guesses, at what the\n+       outer mode was.  */\n+    DF_REF_STRIPPED = 2,\n+    \n+    /* If this flag is set, this is not a real definition/use, but an\n+       artificial one created to model always live registers, eh uses, etc.  */\n+    DF_REF_ARTIFICIAL = 4,\n+\n+\n+    /* If this flag is set for an artificial use or def, that ref\n+       logically happens at the top of the block.  If it is not set\n+       for an artificial use or def, that ref logically happens at the\n+       bottom of the block.  This is never set for regular refs.  */\n+    DF_REF_AT_TOP = 8,\n+\n+    /* This flag is set if the use is inside a REG_EQUAL note.  */\n+    DF_REF_IN_NOTE = 16,\n+\n+    /* This flag is set if this ref, generally a def, may clobber the\n+       referenced register.  This is generally only set for hard\n+       registers that cross a call site.  With better information\n+       about calls, some of these could be changed in the future to\n+       DF_REF_MUST_CLOBBER.  */\n+    DF_REF_MAY_CLOBBER = 32,\n+\n+    /* This flag is set if this ref, generally a def, is a real\n+       clobber. This is not currently set for registers live across a\n+       call because that clobbering may or may not happen.  \n+\n+       Most of the uses of this are with sets that have a\n+       GET_CODE(..)==CLOBBER.  Note that this is set even if the\n+       clobber is to a subreg.  So in order to tell if the clobber\n+       wipes out the entire register, it is necessary to also check\n+       the DF_REF_PARTIAL flag.  */\n+    DF_REF_MUST_CLOBBER = 64,\n+\n+    /* This bit is true if this ref is part of a multiword hardreg.  */\n+    DF_REF_MW_HARDREG = 128,\n+\n+    /* This flag is set if this ref is a partial use or def of the\n+       associated register.  */\n+    DF_REF_PARTIAL = 256\n+  };\n+\n+\n /* Function prototypes added to df_problem instance.  */\n \n /* Allocate the problem specific data.  */\n-typedef void (*df_alloc_function) (struct dataflow *, bitmap);\n+typedef void (*df_alloc_function) (struct dataflow *, bitmap, bitmap);\n \n /* This function is called if the problem has global data that needs\n    to be cleared when ever the set of blocks changes.  The bitmap\n@@ -107,6 +166,10 @@ typedef void (*df_free_function) (struct dataflow *);\n /* Function to dump results to FILE.  */\n typedef void (*df_dump_problem_function) (struct dataflow *, FILE *);\n \n+/* Function to add problem a dataflow problem that must be solved\n+   before this problem can be solved.  */\n+typedef struct dataflow * (*df_dependent_problem_function) (struct df *, int);\n+\n /* The static description of a dataflow problem to solve.  See above\n    typedefs for doc for the function fields.  */\n \n@@ -127,10 +190,10 @@ struct df_problem {\n   df_finalizer_function finalize_fun;\n   df_free_function free_fun;\n   df_dump_problem_function dump_fun;\n+  df_dependent_problem_function dependent_problem_fun;\n \n-  /* A dataflow problem that must be solved before this problem can be\n-     solved.  */\n-  struct df_problem *dependent_problem;\n+  /* Flags can be changed after analysis starts.  */\n+  int changeable_flags;\n };\n \n \n@@ -151,24 +214,56 @@ struct dataflow\n   /* The pool to allocate the block_info from. */\n   alloc_pool block_pool;                \n \n+  /* Problem specific control infomation.  */\n+\n+  /* Scanning flags.  */\n+#define DF_HARD_REGS\t     1\t/* Mark hard registers.  */\n+#define DF_EQUIV_NOTES\t     2\t/* Mark uses present in EQUIV/EQUAL notes.  */\n+#define DF_SUBREGS\t     4\t/* Return subregs rather than the inner reg.  */\n+  /* Flags that control the building of chains.  */\n+#define DF_DU_CHAIN          1    /* Build DU chains.  */  \n+#define DF_UD_CHAIN          2    /* Build UD chains.  */\n+  /* Flag to control the building of register info.  */\n+#define DF_RI_LIFE           1    /* Build register info.  */\n+\n+  int flags;\n+\n   /* Other problem specific data that is not on a per basic block\n      basis.  The structure is generally defined privately for the\n      problem.  The exception being the scanning problem where it is\n      fully public.  */\n   void *problem_data;                  \n };\n \n+\n+/* The set of multiword hardregs used as operands to this\n+   instruction. These are factored into individual uses and defs but\n+   the aggregate is still needed to service the REG_DEAD and\n+   REG_UNUSED notes.  */\n+struct df_mw_hardreg\n+{\n+  rtx mw_reg;                   /* The multiword hardreg.  */ \n+  enum df_ref_type type;        /* Used to see if the ref is read or write.  */\n+  enum df_ref_flags flags;\t/* Various flags.  */\n+  struct df_link *regs;         /* The individual regs that make up\n+\t\t\t\t   this hardreg.  */\n+  struct df_mw_hardreg *next;   /* The next mw_hardreg in this insn.  */\n+};\n+ \n+\n /* One of these structures is allocated for every insn.  */\n struct df_insn_info\n {\n   struct df_ref *defs;\t        /* Head of insn-def chain.  */\n   struct df_ref *uses;\t        /* Head of insn-use chain.  */\n+  struct df_mw_hardreg *mw_hardregs;   \n   /* ???? The following luid field should be considered private so that\n      we can change it on the fly to accommodate new insns?  */\n   int luid;\t\t\t/* Logical UID.  */\n   bool contains_asm;            /* Contains an asm instruction.  */\n };\n \n+\n /* Two of these structures are allocated for every pseudo reg, one for\n    the uses and one for the defs.  */\n struct df_reg_info\n@@ -178,48 +273,6 @@ struct df_reg_info\n   unsigned int n_refs;          /* Number of refs or defs for this pseudo.  */\n };\n \n-\n-enum df_ref_type {DF_REF_REG_DEF, DF_REF_REG_USE, DF_REF_REG_MEM_LOAD,\n-\t\t  DF_REF_REG_MEM_STORE};\n-\n-#define DF_REF_TYPE_NAMES {\"def\", \"use\", \"mem load\", \"mem store\"}\n-\n-enum df_ref_flags\n-  {\n-    /* Read-modify-write refs generate both a use and a def and\n-       these are marked with this flag to show that they are not\n-       independent.  */\n-    DF_REF_READ_WRITE = 1,\n-\n-    /* This flag is set, if we stripped the subreg from the reference.\n-       In this case we must make conservative guesses, at what the\n-       outer mode was.  */\n-    DF_REF_STRIPPED = 2,\n-    \n-    /* If this flag is set, this is not a real definition/use, but an\n-       artificial one created to model always live registers, eh uses, etc.  */\n-    DF_REF_ARTIFICIAL = 4,\n-\n-\n-    /* If this flag is set for an artificial use or def, that ref\n-       logically happens at the top of the block.  If it is not set\n-       for an artificial use or def, that ref logically happens at the\n-       bottom of the block.  This is never set for regular refs.  */\n-    DF_REF_AT_TOP = 8,\n-\n-    /* This flag is set if the use is inside a REG_EQUAL note.  */\n-    DF_REF_IN_NOTE = 16,\n-\n-    /* This flag is set if this ref is really a clobber, and not a def.  */\n-    DF_REF_CLOBBER = 32,\n-\n-    /* True if ref is dead (i.e. the next ref is a def or clobber or\n-       the end of the function.)  This is only valid the RI problem\n-       has been set in this df instance.  */\n-    DF_REF_DIES_AFTER_THIS_USE = 64\n-  };\n-\n-\n /* Define a register reference structure.  One of these is allocated\n    for every register reference (use or def).  Note some register\n    references (e.g., post_inc, subreg) generate both a def and a use.  */\n@@ -250,9 +303,9 @@ struct df_ref\n   void *data;\t\t\t/* The data assigned to it by user.  */\n };\n \n-/* There are two kinds of links: */\n-\n-/* This is used for def-use or use-def chains.  */\n+/* These links are used for two purposes:\n+   1) def-use or use-def chains. \n+   2) Multiword hard registers that underly a single hardware register.  */\n struct df_link\n {\n   struct df_ref *ref;\n@@ -288,12 +341,6 @@ struct df_ref_info\n struct df\n {\n \n-#define DF_HARD_REGS\t     1\t/* Mark hard registers.  */\n-#define DF_EQUIV_NOTES\t     2\t/* Mark uses present in EQUIV/EQUAL notes.  */\n-#define DF_SUBREGS\t     4\t/* Return subregs rather than the inner reg.  */\n-\n-  int flags;\t\t\t/* Indicates what's recorded.  */\n-\n   /* The set of problems to be solved is stored in two arrays.  In\n      PROBLEMS_IN_ORDER, the problems are stored in the order that they\n      are solved.  This is an internally dense array that may have\n@@ -379,7 +426,7 @@ struct df\n /* Macros to determine the reference type.  */\n \n #define DF_REF_REG_DEF_P(REF) (DF_REF_TYPE (REF) == DF_REF_REG_DEF)\n-#define DF_REF_REG_USE_P(REF) ((REF) && ! DF_REF_REG_DEF_P (REF))\n+#define DF_REF_REG_USE_P(REF) ((REF) && !DF_REF_REG_DEF_P (REF))\n #define DF_REF_REG_MEM_STORE_P(REF) (DF_REF_TYPE (REF) == DF_REF_REG_MEM_STORE)\n #define DF_REF_REG_MEM_LOAD_P(REF) (DF_REF_TYPE (REF) == DF_REF_REG_MEM_LOAD)\n #define DF_REF_REG_MEM_P(REF) (DF_REF_REG_MEM_STORE_P (REF) \\\n@@ -398,8 +445,10 @@ struct df\n #define DF_REG_SIZE(DF) ((DF)->def_info.regs_inited)\n #define DF_REG_DEF_GET(DF, REG) ((DF)->def_info.regs[(REG)])\n #define DF_REG_DEF_SET(DF, REG, VAL) ((DF)->def_info.regs[(REG)]=(VAL))\n+#define DF_REG_DEF_COUNT(DF, REG) ((DF)->def_info.regs[(REG)]->n_refs)\n #define DF_REG_USE_GET(DF, REG) ((DF)->use_info.regs[(REG)])\n #define DF_REG_USE_SET(DF, REG, VAL) ((DF)->use_info.regs[(REG)]=(VAL))\n+#define DF_REG_USE_COUNT(DF, REG) ((DF)->use_info.regs[(REG)]->n_refs)\n \n /* Macros to access the elements within the reg_info structure table.  */\n \n@@ -422,27 +471,13 @@ struct df\n #define DF_INSN_UID_LUID(DF, INSN) (DF_INSN_UID_GET(DF,INSN)->luid)\n #define DF_INSN_UID_DEFS(DF, INSN) (DF_INSN_UID_GET(DF,INSN)->defs)\n #define DF_INSN_UID_USES(DF, INSN) (DF_INSN_UID_GET(DF,INSN)->uses)\n+#define DF_INSN_UID_MWS(DF, INSN) (DF_INSN_UID_GET(DF,INSN)->mw_hardregs)\n \n /* This is a bitmap copy of regs_invalidated_by_call so that we can\n    easily add it into bitmaps, etc. */ \n \n extern bitmap df_invalidated_by_call;\n \n-/* Initialize ur_in and ur_out as if all hard registers were partially\n-available.  */\n-\n-/* The way that registers are processed, especially hard registers,\n-   changes as the compilation proceeds. These states are passed to\n-   df_set_state to control this processing.  */\n-\n-#define DF_SCAN_INITIAL    1    /* Processing from beginning of rtl to\n-\t\t\t\t   global-alloc.  */\n-#define DF_SCAN_GLOBAL     2    /* Processing before global\n-\t\t\t\t   allocation.  */\n-#define DF_SCAN_POST_ALLOC 4    /* Processing after register\n-\t\t\t\t   allocation.  */\n-extern int df_state;            /* Indicates where we are in the compilation.  */\n-\n \n /* One of these structures is allocated for every basic block.  */\n struct df_scan_bb_info\n@@ -513,9 +548,13 @@ struct df_urec_bb_info\n /* Functions defined in df-core.c.  */\n \n extern struct df *df_init (int);\n-extern struct dataflow *df_add_problem (struct df *, struct df_problem *);\n+extern struct dataflow *df_add_problem (struct df *, struct df_problem *, int);\n+extern int df_set_flags (struct dataflow *, int);\n+extern int df_clear_flags (struct dataflow *, int);\n extern void df_set_blocks (struct df*, bitmap);\n+extern void df_delete_basic_block (struct df *, int);\n extern void df_finish1 (struct df *);\n+extern void df_analyze_problem (struct dataflow *, bitmap, bitmap, bitmap, int *, int, bool);\n extern void df_analyze (struct df *);\n extern void df_compact_blocks (struct df *);\n extern void df_bb_replace (struct df *, int, basic_block);\n@@ -529,13 +568,12 @@ extern struct df_ref *df_find_use (struct df *, rtx, rtx);\n extern bool df_reg_used (struct df *, rtx, rtx);\n extern void df_iterative_dataflow (struct dataflow *, bitmap, bitmap, int *, int, bool);\n extern void df_dump (struct df *, FILE *);\n-extern void df_chain_dump (struct df *, struct df_link *, FILE *);\n-extern void df_refs_chain_dump (struct df *, struct df_ref *, bool, FILE *);\n+extern void df_refs_chain_dump (struct df_ref *, bool, FILE *);\n extern void df_regs_chain_dump (struct df *, struct df_ref *,  FILE *);\n extern void df_insn_debug (struct df *, rtx, bool, FILE *);\n extern void df_insn_debug_regno (struct df *, rtx, FILE *);\n extern void df_regno_debug (struct df *, unsigned int, FILE *);\n-extern void df_ref_debug (struct df *, struct df_ref *, FILE *);\n+extern void df_ref_debug (struct df_ref *, FILE *);\n extern void debug_df_insn (rtx);\n extern void debug_df_regno (unsigned int);\n extern void debug_df_reg (rtx);\n@@ -549,34 +587,32 @@ extern struct df *shared_df;\n \n /* Functions defined in df-problems.c. */\n \n-extern struct dataflow *df_get_dependent_problem (struct dataflow *);\n extern struct df_link *df_chain_create (struct dataflow *, struct df_ref *, struct df_ref *);\n extern void df_chain_unlink (struct dataflow *, struct df_ref *, struct df_link *);\n extern void df_chain_copy (struct dataflow *, struct df_ref *, struct df_link *);\n extern bitmap df_get_live_in (struct df *, basic_block);\n extern bitmap df_get_live_out (struct df *, basic_block);\n extern void df_grow_bb_info (struct dataflow *);\n-extern void df_chain_dump (struct df *, struct df_link *, FILE *);\n+extern void df_chain_dump (struct df_link *, FILE *);\n extern void df_print_bb_index (basic_block bb, FILE *file);\n-extern struct dataflow *df_ru_add_problem (struct df *);\n+extern struct dataflow *df_ru_add_problem (struct df *, int);\n extern struct df_ru_bb_info *df_ru_get_bb_info (struct dataflow *, unsigned int);\n-extern struct dataflow *df_rd_add_problem (struct df *);\n+extern struct dataflow *df_rd_add_problem (struct df *, int);\n extern struct df_rd_bb_info *df_rd_get_bb_info (struct dataflow *, unsigned int);\n-extern struct dataflow *df_lr_add_problem (struct df *);\n+extern struct dataflow *df_lr_add_problem (struct df *, int);\n extern struct df_lr_bb_info *df_lr_get_bb_info (struct dataflow *, unsigned int);\n-extern struct dataflow *df_ur_add_problem (struct df *);\n+extern struct dataflow *df_ur_add_problem (struct df *, int);\n extern struct df_ur_bb_info *df_ur_get_bb_info (struct dataflow *, unsigned int);\n-extern struct dataflow *df_urec_add_problem (struct df *);\n+extern struct dataflow *df_urec_add_problem (struct df *, int);\n extern struct df_urec_bb_info *df_urec_get_bb_info (struct dataflow *, unsigned int);\n-extern struct dataflow *df_chain_add_problem (struct df *, int flags);\n-extern struct dataflow *df_ri_add_problem (struct df *);\n-extern int df_reg_lifetime (struct df *, rtx reg);\n+extern struct dataflow *df_chain_add_problem (struct df *, int);\n+extern struct dataflow *df_ri_add_problem (struct df *, int);\n \n \n /* Functions defined in df-scan.c.  */\n \n extern struct df_scan_bb_info *df_scan_get_bb_info (struct dataflow *, unsigned int);\n-extern struct dataflow *df_scan_add_problem (struct df *);\n+extern struct dataflow *df_scan_add_problem (struct df *, int);\n extern void df_rescan_blocks (struct df *, bitmap);\n extern struct df_ref *df_ref_create (struct df *, rtx, rtx *, rtx,basic_block,enum df_ref_type, enum df_ref_flags);\n extern struct df_ref *df_get_artificial_defs (struct df *, unsigned int);\n@@ -588,7 +624,6 @@ extern void df_insn_refs_delete (struct dataflow *, rtx);\n extern void df_bb_refs_delete (struct dataflow *, int);\n extern void df_refs_delete (struct dataflow *, bitmap);\n extern void df_reorganize_refs (struct df_ref_info *);\n-extern void df_set_state (int);\n extern void df_hard_reg_init (void);\n extern bool df_read_modify_subreg_p (rtx);\n "}, {"sha": "044ef3a2afb0857e75c24f17a4ffe1064b263e25", "filename": "gcc/final.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23249ac43c6d4d9dde16347bc44dc757e41f1d8d/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23249ac43c6d4d9dde16347bc44dc757e41f1d8d/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=23249ac43c6d4d9dde16347bc44dc757e41f1d8d", "patch": "@@ -4026,6 +4026,9 @@ rest_of_clean_state (void)\n   epilogue_completed = 0;\n   flow2_completed = 0;\n   no_new_pseudos = 0;\n+#ifdef STACK_REGS\n+  regstack_completed = 0;\n+#endif\n \n   /* Clear out the insn_length contents now that they are no\n      longer valid.  */"}, {"sha": "8b620c4b119d91e56ed36fb42c765e5904daac72", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23249ac43c6d4d9dde16347bc44dc757e41f1d8d/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23249ac43c6d4d9dde16347bc44dc757e41f1d8d/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=23249ac43c6d4d9dde16347bc44dc757e41f1d8d", "patch": "@@ -934,9 +934,9 @@ sms_schedule (void)\n   sched_init ();\n \n   /* Init Data Flow analysis, to be used in interloop dep calculation.  */\n-  df = df_init (DF_HARD_REGS | DF_EQUIV_NOTES |\tDF_SUBREGS);\n-  df_rd_add_problem (df);\n-  df_ru_add_problem (df);\n+  df = df_init (DF_HARD_REGS | DF_EQUIV_NOTES | DF_SUBREGS);\n+  df_rd_add_problem (df, 0);\n+  df_ru_add_problem (df, 0);\n   df_chain_add_problem (df, DF_DU_CHAIN | DF_UD_CHAIN);\n   df_analyze (df);\n "}, {"sha": "bb2e1a1f9c67faa5eedcd0121c22d3ff951bb43e", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23249ac43c6d4d9dde16347bc44dc757e41f1d8d/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23249ac43c6d4d9dde16347bc44dc757e41f1d8d/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=23249ac43c6d4d9dde16347bc44dc757e41f1d8d", "patch": "@@ -187,6 +187,8 @@ static VEC(char,heap) *stack_regs_mentioned_data;\n \n #define REG_STACK_SIZE (LAST_STACK_REG - FIRST_STACK_REG + 1)\n \n+int regstack_completed = 0;\n+\n /* This is the basic stack record.  TOP is an index into REG[] such\n    that REG[TOP] is the top of stack.  If TOP is -1 the stack is empty.\n \n@@ -3151,6 +3153,7 @@ rest_of_handle_stack_regs (void)\n #ifdef STACK_REGS\n   if (reg_to_stack () && optimize)\n     {\n+      regstack_completed = 1;\n       if (cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_POST_REGSTACK\n                        | (flag_crossjumping ? CLEANUP_CROSSJUMP : 0))\n           && (flag_reorder_blocks || flag_reorder_blocks_and_partition))\n@@ -3159,6 +3162,8 @@ rest_of_handle_stack_regs (void)\n           cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_POST_REGSTACK);\n         }\n     }\n+  else \n+    regstack_completed = 1;\n #endif\n   return 0;\n }"}, {"sha": "7539eadf96d16c8fa101b94b45697ade1f79804e", "filename": "gcc/rtl.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23249ac43c6d4d9dde16347bc44dc757e41f1d8d/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23249ac43c6d4d9dde16347bc44dc757e41f1d8d/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=23249ac43c6d4d9dde16347bc44dc757e41f1d8d", "patch": "@@ -1978,6 +1978,12 @@ extern int epilogue_completed;\n \n extern int reload_in_progress;\n \n+#ifdef STACK_REGS\n+/* Nonzero after end of regstack pass.\n+   Set to 1 or 0 by reg-stack.c.  */\n+extern int regstack_completed;\n+#endif\n+\n /* If this is nonzero, we do not bother generating VOLATILE\n    around volatile memory references, and we are willing to\n    output indirect addresses.  If cse is to follow, we reject"}, {"sha": "77fb6600772cac6d3418326fb29e0595e68c7dd2", "filename": "gcc/see.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23249ac43c6d4d9dde16347bc44dc757e41f1d8d/gcc%2Fsee.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23249ac43c6d4d9dde16347bc44dc757e41f1d8d/gcc%2Fsee.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsee.c?ref=23249ac43c6d4d9dde16347bc44dc757e41f1d8d", "patch": "@@ -1323,9 +1323,8 @@ static void\n see_initialize_data_structures (void)\n {\n   /* Build the df object. */\n-  df = df_init (DF_HARD_REGS | DF_EQUIV_NOTES |\tDF_SUBREGS);\n-  df_rd_add_problem (df);\n-  /* df_ru_add_problem (df); */\n+  df = df_init (DF_HARD_REGS | DF_EQUIV_NOTES | DF_SUBREGS);\n+  df_rd_add_problem (df, 0);\n   df_chain_add_problem (df, DF_DU_CHAIN | DF_UD_CHAIN);\n   df_analyze (df);\n "}]}