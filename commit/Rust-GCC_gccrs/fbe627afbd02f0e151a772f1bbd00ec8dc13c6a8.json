{"sha": "fbe627afbd02f0e151a772f1bbd00ec8dc13c6a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmJlNjI3YWZiZDAyZjBlMTUxYTc3MmYxYmJkMDBlYzhkYzEzYzZhOA==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2007-06-06T10:29:05Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-06-06T10:29:05Z"}, "message": "g-comlin.ads, [...]: Add new warning for renaming of function return objects\n\n2007-04-20  Robert Dewar  <dewar@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\n\t* g-comlin.ads, g-comlin.adb: \n\tAdd new warning for renaming of function return objects\n\n\t* opt.adb (Tree_Write, Tree_Read): Use proper expressions for size\n\t(Tree_Read): Use size of object instead of type'object_size, since the\n\tlatter is incorrect for packed array types.\n\t(Tree_Write): Same fix\n\n\t* opt.ads: Add new warning for renaming of function return objects\n\t(Generating_Code): New boolean variable used to indicate that the\n\tfrontend as finished its work and has called the backend to process\n\tthe tree and generate the object file.\n\t(GCC_Version): Is now private\n\t(Static_Dispatch_Tables): New constant declaration.\n\t(Overflow_Checks_Unsuppressed): New flag.\n\t(Process_Suppress_Unsuppress): Set Overflow_Checks_Unsuppressed.\n\t(List_Closure): New flag for gnatbind (-R)\n\tZero_Formatting: New flag for gnatbind (-Z)\n\t(Special_Exception_Package_Used): New flag.\n\t(Warn_On_Unrepped_Components): New flag.\n\n\t* sem_ch8.adb (Check_Library_Unit_Renaming): Check that the renamed\n\tunit is a compilation unit, rather than relying on its scope, so that\n\tStandard can be renamed.\n\t(Analyze_Object_Renaming): Add new warning for renaming of function\n\treturn objects.\n\tAlso reject attempt to rename function return object in Ada 83 mode.\n\t(Attribute_Renaming): In case of tagged types, add the body of the\n\tgenerated function to the freezing actions of the type.\n\t(Find_Type): A protected type is visible right after the reserved word\n\t\"is\" is encountered in its type declaration. Set the entity and type\n\trather than emitting an error message.\n\t(New_Scope): Properly propagate Discard_Names to inner scopes\n\t(Check_Nested_Access): New procedure.\n\t(Has_Nested_Access, Set_Has_Nested_Access): New procedures.\n\t(Find_Direct_Name, Note_Possible_Modification): Use Check_Nested_Access.\n\n\t* sem_warn.ads, sem_warn.adb: Improvements to infinite loop warning\n\tAdd new warning for renaming of function return objects\n\t(Check_References): Suppress warnings for objects whose type or\n\tbase type has Warnings suppressed.\n\t(Set_Dot_Warning_Switch): Add processing for -gnatw.c/C\n\t(Set_Warning_Switch): Include new -gnatwc in -gnatwa\n\nFrom-SVN: r125414", "tree": {"sha": "6ff0bdc51ae48b263304958cee5149a99a48f365", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6ff0bdc51ae48b263304958cee5149a99a48f365"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fbe627afbd02f0e151a772f1bbd00ec8dc13c6a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbe627afbd02f0e151a772f1bbd00ec8dc13c6a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbe627afbd02f0e151a772f1bbd00ec8dc13c6a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbe627afbd02f0e151a772f1bbd00ec8dc13c6a8/comments", "author": null, "committer": null, "parents": [{"sha": "f24f72e8928aad26ed15009ef1047de16d0193c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f24f72e8928aad26ed15009ef1047de16d0193c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f24f72e8928aad26ed15009ef1047de16d0193c2"}], "stats": {"total": 909, "additions": 743, "deletions": 166}, "files": [{"sha": "52a15550762c14713c1f57118fa71bc78564c666", "filename": "gcc/ada/g-comlin.adb", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbe627afbd02f0e151a772f1bbd00ec8dc13c6a8/gcc%2Fada%2Fg-comlin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbe627afbd02f0e151a772f1bbd00ec8dc13c6a8/gcc%2Fada%2Fg-comlin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-comlin.adb?ref=fbe627afbd02f0e151a772f1bbd00ec8dc13c6a8", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1999-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1999-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -32,7 +32,7 @@\n ------------------------------------------------------------------------------\n \n with Ada.Command_Line;\n-with GNAT.OS_Lib; use GNAT.OS_Lib;\n+with GNAT.OS_Lib;      use GNAT.OS_Lib;\n \n package body GNAT.Command_Line is\n \n@@ -142,9 +142,9 @@ package body GNAT.Command_Line is\n       use GNAT.Directory_Operations;\n       type Pointer is access all Expansion_Iterator;\n \n+      It   : constant Pointer := Iterator'Unrestricted_Access;\n       S    : String (1 .. 1024);\n       Last : Natural;\n-      It   : constant Pointer := Iterator'Unrestricted_Access;\n \n       Current : Depth := It.Current_Depth;\n       NL      : Positive;\n@@ -304,8 +304,8 @@ package body GNAT.Command_Line is\n \n       if Do_Expansion then\n          declare\n-            Arg       : String renames CL.Argument (Current_Argument - 1);\n-            Index     : Positive := Arg'First;\n+            Arg   : constant String := CL.Argument (Current_Argument - 1);\n+            Index : Positive := Arg'First;\n \n          begin\n             while Index <= Arg'Last loop\n@@ -381,7 +381,7 @@ package body GNAT.Command_Line is\n       end if;\n \n       declare\n-         Arg            : String renames CL.Argument (Current_Argument);\n+         Arg            : constant String := CL.Argument (Current_Argument);\n          Index_Switches : Natural := 0;\n          Max_Length     : Natural := 0;\n          Index          : Natural;\n@@ -780,9 +780,9 @@ package body GNAT.Command_Line is\n    is\n       Directory_Separator : Character;\n       pragma Import (C, Directory_Separator, \"__gnat_dir_separator\");\n-      First : Positive := Pattern'First;\n \n-      Pat : String := Pattern;\n+      First : Positive := Pattern'First;\n+      Pat   : String := Pattern;\n \n    begin\n       Canonical_Case_File_Name (Pat);\n@@ -838,7 +838,6 @@ package body GNAT.Command_Line is\n             exit when Iterator.Maximum_Depth = Max_Depth;\n          end if;\n       end loop;\n-\n    end Start_Expansion;\n \n begin"}, {"sha": "60073f303c6ad4388cd1cee1e1978acfe8721f5e", "filename": "gcc/ada/g-comlin.ads", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbe627afbd02f0e151a772f1bbd00ec8dc13c6a8/gcc%2Fada%2Fg-comlin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbe627afbd02f0e151a772f1bbd00ec8dc13c6a8/gcc%2Fada%2Fg-comlin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-comlin.ads?ref=fbe627afbd02f0e151a772f1bbd00ec8dc13c6a8", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---                     Copyright (C) 1999-2005, AdaCore                     --\n+--                     Copyright (C) 1999-2007, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -322,7 +322,6 @@ private\n       Maximum_Depth : Depth := 1;\n       --  The maximum depth of directories, reflecting the number of directory\n       --  separators in the pattern.\n-\n    end record;\n \n end GNAT.Command_Line;"}, {"sha": "783481245b23a6d9e5ca46ad4d854f1fc213de90", "filename": "gcc/ada/opt.adb", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbe627afbd02f0e151a772f1bbd00ec8dc13c6a8/gcc%2Fada%2Fopt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbe627afbd02f0e151a772f1bbd00ec8dc13c6a8/gcc%2Fada%2Fopt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.adb?ref=fbe627afbd02f0e151a772f1bbd00ec8dc13c6a8", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -37,6 +37,9 @@ with Tree_IO; use Tree_IO;\n \n package body Opt is\n \n+   SU : constant := Storage_Unit;\n+   --  Shorthand for System.Storage_Unit\n+\n    ----------------------------------\n    -- Register_Opt_Config_Switches --\n    ----------------------------------\n@@ -169,10 +172,10 @@ package body Opt is\n       Tree_Read_Char (Identifier_Character_Set);\n       Tree_Read_Int  (Maximum_File_Name_Length);\n       Tree_Read_Data (Suppress_Options'Address,\n-                      Suppress_Array'Object_Size / Storage_Unit);\n+                      (Suppress_Options'Size + SU - 1) / SU);\n       Tree_Read_Bool (Verbose_Mode);\n       Tree_Read_Data (Warning_Mode'Address,\n-                      Warning_Mode_Type'Object_Size / Storage_Unit);\n+                      (Warning_Mode'Size + SU - 1) / SU);\n       Tree_Read_Int  (Ada_Version_Config_Val);\n       Tree_Read_Int  (Ada_Version_Explicit_Config_Val);\n       Tree_Read_Int  (Assertions_Enabled_Config_Val);\n@@ -198,23 +201,23 @@ package body Opt is\n       begin\n          Tree_Read_Data\n            (Tmp'Address, Tree_Version_String_Len);\n-         GNAT.Strings.Free (Tree_Version_String);\n+         System.Strings.Free (Tree_Version_String);\n          Free (Tree_Version_String);\n          Tree_Version_String := new String'(Tmp);\n       end;\n \n       Tree_Read_Data (Distribution_Stub_Mode'Address,\n-                      Distribution_Stub_Mode_Type'Object_Size / Storage_Unit);\n+                      (Distribution_Stub_Mode'Size + SU - 1) / Storage_Unit);\n       Tree_Read_Bool (Inline_Active);\n       Tree_Read_Bool (Inline_Processing_Required);\n       Tree_Read_Bool (List_Units);\n       Tree_Read_Bool (Configurable_Run_Time_Mode);\n       Tree_Read_Data (Operating_Mode'Address,\n-                      Operating_Mode_Type'Object_Size / Storage_Unit);\n+                      (Operating_Mode'Size + SU - 1) / Storage_Unit);\n       Tree_Read_Bool (Suppress_Checks);\n       Tree_Read_Bool (Try_Semantics);\n       Tree_Read_Data (Wide_Character_Encoding_Method'Address,\n-                      WC_Encoding_Method'Object_Size / Storage_Unit);\n+                      (Wide_Character_Encoding_Method'Size + SU - 1) / SU);\n       Tree_Read_Bool (Upper_Half_Encoding);\n       Tree_Read_Bool (Force_ALI_Tree_File);\n    end Tree_Read;\n@@ -233,10 +236,10 @@ package body Opt is\n       Tree_Write_Char (Identifier_Character_Set);\n       Tree_Write_Int  (Maximum_File_Name_Length);\n       Tree_Write_Data (Suppress_Options'Address,\n-                       Suppress_Array'Object_Size / Storage_Unit);\n+                       (Suppress_Options'Size + SU - 1) / SU);\n       Tree_Write_Bool (Verbose_Mode);\n       Tree_Write_Data (Warning_Mode'Address,\n-                       Warning_Mode_Type'Object_Size / Storage_Unit);\n+                       (Warning_Mode'Size + SU - 1) / Storage_Unit);\n       Tree_Write_Int  (Ada_Version_Type'Pos (Ada_Version_Config));\n       Tree_Write_Int  (Ada_Version_Type'Pos (Ada_Version_Explicit_Config));\n       Tree_Write_Int  (Boolean'Pos (Assertions_Enabled_Config));\n@@ -246,20 +249,19 @@ package body Opt is\n       Tree_Write_Bool (Enable_Overflow_Checks);\n       Tree_Write_Bool (Full_List);\n       Tree_Write_Int  (Int (Version_String'Length));\n-      Tree_Write_Data (Version_String'Address,\n-                       Version_String'Length);\n+      Tree_Write_Data (Version_String'Address, Version_String'Length);\n       Tree_Write_Data (Distribution_Stub_Mode'Address,\n-                       Distribution_Stub_Mode_Type'Object_Size / Storage_Unit);\n+                       (Distribution_Stub_Mode'Size + SU - 1) / SU);\n       Tree_Write_Bool (Inline_Active);\n       Tree_Write_Bool (Inline_Processing_Required);\n       Tree_Write_Bool (List_Units);\n       Tree_Write_Bool (Configurable_Run_Time_Mode);\n       Tree_Write_Data (Operating_Mode'Address,\n-                       Operating_Mode_Type'Object_Size / Storage_Unit);\n+                       (Operating_Mode'Size + SU - 1) / SU);\n       Tree_Write_Bool (Suppress_Checks);\n       Tree_Write_Bool (Try_Semantics);\n       Tree_Write_Data (Wide_Character_Encoding_Method'Address,\n-                       WC_Encoding_Method'Object_Size / Storage_Unit);\n+                       (Wide_Character_Encoding_Method'Size + SU - 1) / SU);\n       Tree_Write_Bool (Upper_Half_Encoding);\n       Tree_Write_Bool (Force_ALI_Tree_File);\n    end Tree_Write;"}, {"sha": "14d04dbbc2b2437f100de7a4e54ebd9dce903c5d", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 65, "deletions": 10, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbe627afbd02f0e151a772f1bbd00ec8dc13c6a8/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbe627afbd02f0e151a772f1bbd00ec8dc13c6a8/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=fbe627afbd02f0e151a772f1bbd00ec8dc13c6a8", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,8 +39,8 @@\n with Hostparm; use Hostparm;\n with Types;    use Types;\n \n+with System.Strings; use System.Strings;\n with System.WCh_Con; use System.WCh_Con;\n-with GNAT.Strings;   use GNAT.Strings;\n \n package Opt is\n \n@@ -386,6 +386,11 @@ package Opt is\n    --  Set to True if -gnato (enable overflow checks) switch is set,\n    --  but not -gnatp.\n \n+   Overflow_Checks_Unsuppressed : Boolean := False;\n+   --  GNAT\n+   --  Set to True if at least one pragma Unsuppress\n+   --  (All_Checks|Overflow_Checks) has been processed.\n+\n    Error_Msg_Line_Length : Nat := 0;\n    --  GNAT\n    --  Records the error message line length limit. If this is set to zero,\n@@ -510,16 +515,15 @@ package Opt is\n    --  the name is of the form .xxx, then to name.xxx where name is the source\n    --  file name with extension stripped.\n \n-   function get_gcc_version return Int;\n-   pragma Import (C, get_gcc_version, \"get_gcc_version\");\n-\n-   GCC_Version : constant Nat := get_gcc_version;\n-   --  GNATMAKE\n-   --  Indicates which version of gcc is in use (2 = 2.8.1, 3 = 3.x)\n+   Generating_Code : Boolean := False;\n+   --  GNAT\n+   --  True if the frontend finished its work and has called the backend to\n+   --  processs the tree and generate the object file.\n \n    Global_Discard_Names : Boolean := False;\n    --  GNAT, GNATBIND\n-   --  Set true if a pragma Discard_Names applies to the current unit\n+   --  True if a pragma Discard_Names appeared as a configuration pragma for\n+   --  the current compilation unit.\n \n    GNAT_Mode : Boolean := False;\n    --  GNAT\n@@ -633,6 +637,10 @@ package Opt is\n    --  GNAT\n    --  List units in the active library for a compilation (-gnatu switch)\n \n+   List_Closure : Boolean := False;\n+   --  GNATBIND\n+   --  List all sources in the closure of a main (-R gnatbind switch)\n+\n    List_Dependencies : Boolean := False;\n    --  GNATMAKE\n    --  When True gnatmake verifies that the objects are up to date and\n@@ -668,7 +676,7 @@ package Opt is\n    --  before preprocessing occurs. Set to True by switch -s of gnatprep\n    --  or -s in preprocessing data file for the compiler.\n \n-   type Create_Repinfo_File_Proc is access procedure (Src : File_Name_Type);\n+   type Create_Repinfo_File_Proc is access procedure (Src  : String);\n    type Write_Repinfo_Line_Proc  is access procedure (Info : String);\n    type Close_Repinfo_File_Proc  is access procedure;\n    --  Types used for procedure addresses below\n@@ -753,6 +761,12 @@ package Opt is\n    --  GNATMAKE\n    --  Set to True if minimal recompilation mode requested\n \n+   Special_Exception_Package_Used : Boolean := False;\n+   --  GNAT\n+   --  Set to True if either of the unit GNAT.Most_Recent_Exception or\n+   --  GNAT.Exception_Traces is with'ed. Used to inhibit transformation of\n+   --  local raise statements into gotos in the presence of either package.\n+\n    Multiple_Unit_Index : Int;\n    --  GNAT\n    --  This is set non-zero if the current unit is being compiled in multiple\n@@ -1186,6 +1200,11 @@ package Opt is\n    --  Set to True to generate warnings for redundant constructs (e.g. useless\n    --  assignments/conversions). The default is that this warning is disabled.\n \n+   Warn_On_Object_Renames_Function : Boolean := False;\n+   --  GNAT\n+   --  Set to True to generate warnings when a function result is renamed as\n+   --  an object. The default is that this warning is disabled.\n+\n    Warn_On_Reverse_Bit_Order : Boolean := True;\n    --  GNAT\n    --  Set to True to generate warning (informational) messages for component\n@@ -1203,6 +1222,12 @@ package Opt is\n    --  Set to True to generate warnings for unrecognized pragmas. The default\n    --  is that this warning is enabled.\n \n+   Warn_On_Unrepped_Components : Boolean := False;\n+   --  GNAT\n+   --  Set to True to generate warnings for the case of components of record\n+   --  which have a record representation clause but this component does not\n+   --  have a component clause. The default is that this warning is disabled.\n+\n    type Warning_Mode_Type is (Suppress, Normal, Treat_As_Error);\n    Warning_Mode : Warning_Mode_Type := Normal;\n    --  GNAT, GNATBIND\n@@ -1226,6 +1251,11 @@ package Opt is\n    --  GNAT\n    --  Set if cross-referencing is enabled (i.e. xref info in ALI files)\n \n+   Zero_Formatting : Boolean := False;\n+   --  GNATBIND\n+   --  Do no formatting (no title, no leading spaces, no empty lines) in\n+   --  auxiliary outputs (-e, -K, -l, -R).\n+\n    ----------------------------\n    -- Configuration Settings --\n    ----------------------------\n@@ -1362,6 +1392,15 @@ package Opt is\n    -- Other Global Flags --\n    ------------------------\n \n+   Static_Dispatch_Tables : constant Boolean;\n+   --  This flag indicates if the backend supports generation of statically\n+   --  allocated dispatch tables. If it is True, then the front end will\n+   --  generate static aggregates for dispatch tables that contain forward\n+   --  references to addresses of subprograms not seen yet, and the back end\n+   --  must be prepared to handle this case. If it is False, then the front\n+   --  end generates assignments to initialize the dispatch table, and there\n+   --  are no such forward references.\n+\n    Expander_Active : Boolean := False;\n    --  A flag that indicates if expansion is active (True) or deactivated\n    --  (False). When expansion is deactivated all calls to expander routines\n@@ -1431,4 +1470,20 @@ private\n       Use_VADS_Size                  : Boolean;\n    end record;\n \n+   --  The following declarations are for GCC version dependent flags. We do\n+   --  not let client code in the compiler test GCC_Version directly, but\n+   --  instead use deferred constants for relevant feature tags.\n+\n+   function get_gcc_version return Int;\n+   pragma Import (C, get_gcc_version, \"get_gcc_version\");\n+\n+   GCC_Version : constant Nat := get_gcc_version;\n+   --  GNATMAKE\n+   --  Indicates which version of gcc is in use (3 = 3.x, 4 = 4.x). Note that\n+   --  gcc 2.8.1 (which used to be a value of 2) is no longer supported.\n+\n+   Static_Dispatch_Tables : constant Boolean := GCC_Version >= 4;\n+   --  GCC version 4 can handle the static dispatch tables, but not version 3.\n+   --  Also we need -funit-at-a-time, which should also be tested here ???\n+\n end Opt;"}, {"sha": "7de0b707c54233ddd8c4a8d98059cbc33dc6db4e", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 242, "deletions": 124, "changes": 366, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbe627afbd02f0e151a772f1bbd00ec8dc13c6a8/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbe627afbd02f0e151a772f1bbd00ec8dc13c6a8/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=fbe627afbd02f0e151a772f1bbd00ec8dc13c6a8", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -721,10 +721,25 @@ package body Sem_Ch8 is\n             Set_Etype (Nam, T);\n          end if;\n \n+         --  Complete analysis of the subtype mark in any case, for ASIS use.\n+\n+         if Present (Subtype_Mark (N)) then\n+            Find_Type (Subtype_Mark (N));\n+         end if;\n+\n       elsif Present (Subtype_Mark (N)) then\n          Find_Type (Subtype_Mark (N));\n          T := Entity (Subtype_Mark (N));\n-         Analyze_And_Resolve (Nam, T);\n+         Analyze (Nam);\n+\n+         if Nkind (Nam) = N_Type_Conversion\n+            and then not Is_Tagged_Type (T)\n+         then\n+            Error_Msg_N\n+              (\"renaming of conversion only allowed for tagged types\", Nam);\n+         end if;\n+\n+         Resolve (Nam, T);\n \n       --  Ada 2005 (AI-230/AI-254): Access renaming\n \n@@ -748,6 +763,40 @@ package body Sem_Ch8 is\n          end if;\n       end if;\n \n+      --  Special processing for renaming function return object\n+\n+      if Nkind (Nam) = N_Function_Call\n+        and then Comes_From_Source (Nam)\n+      then\n+         case Ada_Version is\n+\n+            --  Usage is illegal in Ada 83\n+\n+            when Ada_83 =>\n+               Error_Msg_N\n+                 (\"(Ada 83) cannot rename function return object\", Nam);\n+\n+            --  In Ada 95, warn for odd case of renaming parameterless function\n+            --  call if this is not a limited type (where this is useful)\n+\n+            when others =>\n+               if Warn_On_Object_Renames_Function\n+                 and then No (Parameter_Associations (Nam))\n+                 and then not Is_Limited_Type (Etype (Nam))\n+               then\n+                  Error_Msg_N\n+                    (\"?renaming function result object is suspicious\",\n+                     Nam);\n+                  Error_Msg_NE\n+                    (\"\\?function & will be called only once\",\n+                     Nam, Entity (Name (Nam)));\n+                  Error_Msg_N\n+                    (\"\\?suggest using an initialized constant object instead\",\n+                     Nam);\n+               end if;\n+         end case;\n+      end if;\n+\n       --  An object renaming requires an exact match of the type. Class-wide\n       --  matching is not allowed.\n \n@@ -802,7 +851,7 @@ package body Sem_Ch8 is\n                --  formal object of a generic unit G, and the object renaming\n                --  declaration occurs within the body of G or within the body\n                --  of a generic unit declared within the declarative region\n-               --  of G, then the declaration of the formal object of G shall\n+               --  of G, then the declaration of the formal object of G must\n                --  have a null exclusion.\n \n                if Is_Formal_Object (Nam_Ent)\n@@ -818,17 +867,22 @@ package body Sem_Ch8 is\n                      Error_Node := Access_Definition (Nam_Decl);\n                   end if;\n \n-                  Error_Msg_N (\"null-exclusion required in formal \" &\n-                               \"object declaration\", Error_Node);\n+                  Error_Msg_N\n+                    (\"`NOT NULL` required in formal object declaration\",\n+                     Error_Node);\n+                  Error_Msg_Sloc := Sloc (N);\n+                  Error_Msg_N\n+                    (\"\\because of renaming at# ('R'M 8.5.4(4))\", Error_Node);\n \n                --  Ada 2005 (AI-423): Otherwise, the subtype of the object name\n                --  shall exclude null.\n \n                elsif Nkind (Subtyp_Decl) = N_Subtype_Declaration\n                  and then not Has_Null_Exclusion (Subtyp_Decl)\n                then\n-                  Error_Msg_N (\"subtype must have null-exclusion\",\n-                               Subtyp_Decl);\n+                  Error_Msg_N\n+                    (\"`NOT NULL` required for subtype & ('R'M 8.5.1(4.6/2))\",\n+                     Defining_Identifier (Subtyp_Decl));\n                end if;\n             end if;\n          end;\n@@ -1275,8 +1329,9 @@ package body Sem_Ch8 is\n                 not (Has_Null_Exclusion (Parent (Sub_Formal))\n                        or else Can_Never_Be_Null (Etype (Sub_Formal)))\n             then\n-               Error_Msg_N (\"null-exclusion required in parameter profile\",\n-                            Parent (Sub_Formal));\n+               Error_Msg_NE\n+                 (\"`NOT NULL` required for parameter &\",\n+                  Parent (Sub_Formal), Sub_Formal);\n             end if;\n \n             Next_Formal (Ren_Formal);\n@@ -1292,8 +1347,9 @@ package body Sem_Ch8 is\n              not (Has_Null_Exclusion (Parent (Sub))\n                     or else Can_Never_Be_Null (Etype (Sub)))\n          then\n-            Error_Msg_N (\"null-exclusion required in return profile\",\n-                         Result_Definition (Parent (Sub)));\n+            Error_Msg_N\n+              (\"return must specify `NOT NULL`\",\n+               Result_Definition (Parent (Sub)));\n          end if;\n       end Check_Null_Exclusion;\n \n@@ -1525,6 +1581,7 @@ package body Sem_Ch8 is\n          --  for it at the freezing point.\n \n          Set_Corresponding_Spec (N, Rename_Spec);\n+\n          if Nkind (Unit_Declaration_Node (Rename_Spec)) =\n                                      N_Abstract_Subprogram_Declaration\n          then\n@@ -1954,8 +2011,9 @@ package body Sem_Ch8 is\n                  and then not Can_Never_Be_Null (Old_F)\n                then\n                   Error_Msg_N (\"access parameter is controlling,\", New_F);\n-                  Error_Msg_NE (\"\\corresponding parameter of& \" &\n-                    \" must be explicitly null excluding\", New_F, Old_S);\n+                  Error_Msg_NE\n+                    (\"\\corresponding parameter of& \"\n+                     & \"must be explicitly null excluding\", New_F, Old_S);\n                end if;\n \n                Next_Formal (Old_F);\n@@ -2334,16 +2392,43 @@ package body Sem_Ch8 is\n                    Statements => New_List (Attr_Node)));\n       end if;\n \n-      Rewrite (N, Body_Node);\n-      Analyze (N);\n+      --  In case of tagged types we add the body of the generated function to\n+      --  the freezing actions of the type (because in the general case such\n+      --  type is still not frozen). We exclude from this processing generic\n+      --  formal subprograms found in instantiations and AST_Entry renamings.\n+\n+      if not Present (Corresponding_Formal_Spec (N))\n+        and then Etype (Nam) /= RTE (RE_AST_Handler)\n+      then\n+         declare\n+            P : constant Entity_Id := Prefix (Nam);\n+\n+         begin\n+            Find_Type (P);\n+\n+            if Is_Tagged_Type (Etype (P)) then\n+               Ensure_Freeze_Node (Etype (P));\n+               Append_Freeze_Action (Etype (P), Body_Node);\n+            else\n+               Rewrite (N, Body_Node);\n+               Analyze (N);\n+               Set_Etype (New_S, Base_Type (Etype (New_S)));\n+            end if;\n+         end;\n+\n+      --  Generic formal subprograms or AST_Handler renaming\n+\n+      else\n+         Rewrite (N, Body_Node);\n+         Analyze (N);\n+         Set_Etype (New_S, Base_Type (Etype (New_S)));\n+      end if;\n \n       if Is_Compilation_Unit (New_S) then\n          Error_Msg_N\n            (\"a library unit can only rename another library unit\", N);\n       end if;\n \n-      Set_Etype (New_S, Base_Type (Etype (New_S)));\n-\n       --  We suppress elaboration warnings for the resulting entity, since\n       --  clearly they are not needed, and more particularly, in the case\n       --  of a generic formal subprogram, the resulting entity can appear\n@@ -2502,7 +2587,10 @@ package body Sem_Ch8 is\n       if Nkind (Parent (N)) /= N_Compilation_Unit then\n          return;\n \n-      elsif Scope (Old_E) /= Standard_Standard\n+      --  Check for library unit. Note that we used to check for the scope\n+      --  being Standard here, but that was wrong for Standard itself.\n+\n+      elsif not Is_Compilation_Unit (Old_E)\n         and then not Is_Child_Unit (Old_E)\n       then\n          Error_Msg_N (\"renamed unit must be a library unit\", Name (N));\n@@ -3276,7 +3364,7 @@ package body Sem_Ch8 is\n \n             --  Another special check if N is the prefix of a selected\n             --  component which is a known unit, add message complaining\n-            --  about missingw with for this unit.\n+            --  about missing with for this unit.\n \n             elsif Nkind (Parent (N)) = N_Selected_Component\n               and then N = Prefix (Parent (N))\n@@ -3735,6 +3823,7 @@ package body Sem_Ch8 is\n \n             else\n                Generate_Reference (E, N);\n+               Check_Nested_Access (E);\n             end if;\n \n             --  Set Entity, with style check if need be. For a discriminant\n@@ -4029,8 +4118,10 @@ package body Sem_Ch8 is\n                --  we assume a missing with for the corresponding package.\n \n                if Is_Known_Unit (N) then\n-                  Error_Msg_Node_2 := Selector;\n-                  Error_Msg_N (\"missing `WITH &.&;`\", Prefix (N));\n+                  if not Error_Posted (N) then\n+                     Error_Msg_Node_2 := Selector;\n+                     Error_Msg_N (\"missing `WITH &.&;`\", Prefix (N));\n+                  end if;\n \n                --  If this is a selection from a dummy package, then suppress\n                --  the error message, of course the entity is missing if the\n@@ -5005,8 +5096,27 @@ package body Sem_Ch8 is\n                   else\n                      Error_Msg_N\n                        (\"task type cannot be used as type mark \" &\n-                        \"within its own body\", N);\n+                        \"within its own spec or body\", N);\n                   end if;\n+\n+               elsif Ekind (Base_Type (T_Name)) = E_Protected_Type then\n+\n+                  --  In Ada 2005, a protected name can be used in an access\n+                  --  definition within its own body.\n+\n+                  if Ada_Version >= Ada_05\n+                    and then Nkind (Parent (N)) = N_Access_Definition\n+                  then\n+                     Set_Entity (N, T_Name);\n+                     Set_Etype  (N, T_Name);\n+                     return;\n+\n+                  else\n+                     Error_Msg_N\n+                       (\"protected type cannot be used as type mark \" &\n+                        \"within its own spec or body\", N);\n+                  end if;\n+\n                else\n                   Error_Msg_N (\"type declaration cannot refer to itself\", N);\n                end if;\n@@ -5151,10 +5261,10 @@ package body Sem_Ch8 is\n       procedure Add_Implicit_Operator\n         (T       : Entity_Id;\n          Op_Type : Entity_Id := Empty);\n-      --  Add implicit interpretation to node N, using the type for which\n-      --  a predefined operator exists. If the operator yields a boolean\n-      --  type, the Operand_Type is implicitly referenced by the operator,\n-      --  and a reference to it must be generated.\n+      --  Add implicit interpretation to node N, using the type for which a\n+      --  predefined operator exists. If the operator yields a boolean type,\n+      --  the Operand_Type is implicitly referenced by the operator, and a\n+      --  reference to it must be generated.\n \n       ---------------------------\n       -- Add_Implicit_Operator --\n@@ -5511,101 +5621,6 @@ package body Sem_Ch8 is\n                                and then Has_Components (Designated_Type (T))));\n    end Is_Appropriate_For_Record;\n \n-   ---------------\n-   -- New_Scope --\n-   ---------------\n-\n-   procedure New_Scope (S : Entity_Id) is\n-      E : Entity_Id;\n-\n-   begin\n-      if Ekind (S) = E_Void then\n-         null;\n-\n-      --  Set scope depth if not a non-concurrent type, and we have not\n-      --  yet set the scope depth. This means that we have the first\n-      --  occurrence of the scope, and this is where the depth is set.\n-\n-      elsif (not Is_Type (S) or else Is_Concurrent_Type (S))\n-        and then not Scope_Depth_Set (S)\n-      then\n-         if S = Standard_Standard then\n-            Set_Scope_Depth_Value (S, Uint_0);\n-\n-         elsif Is_Child_Unit (S) then\n-            Set_Scope_Depth_Value (S, Uint_1);\n-\n-         elsif not Is_Record_Type (Current_Scope) then\n-            if Ekind (S) = E_Loop then\n-               Set_Scope_Depth_Value (S, Scope_Depth (Current_Scope));\n-            else\n-               Set_Scope_Depth_Value (S, Scope_Depth (Current_Scope) + 1);\n-            end if;\n-         end if;\n-      end if;\n-\n-      Scope_Stack.Increment_Last;\n-\n-      declare\n-         SST : Scope_Stack_Entry renames Scope_Stack.Table (Scope_Stack.Last);\n-\n-      begin\n-         SST.Entity                         := S;\n-         SST.Save_Scope_Suppress            := Scope_Suppress;\n-         SST.Save_Local_Entity_Suppress     := Local_Entity_Suppress.Last;\n-\n-         if Scope_Stack.Last > Scope_Stack.First then\n-            SST.Component_Alignment_Default := Scope_Stack.Table\n-                                                 (Scope_Stack.Last - 1).\n-                                                   Component_Alignment_Default;\n-         end if;\n-\n-         SST.Last_Subprogram_Name           := null;\n-         SST.Is_Transient                   := False;\n-         SST.Node_To_Be_Wrapped             := Empty;\n-         SST.Pending_Freeze_Actions         := No_List;\n-         SST.Actions_To_Be_Wrapped_Before   := No_List;\n-         SST.Actions_To_Be_Wrapped_After    := No_List;\n-         SST.First_Use_Clause               := Empty;\n-         SST.Is_Active_Stack_Base           := False;\n-         SST.Previous_Visibility            := False;\n-      end;\n-\n-      if Debug_Flag_W then\n-         Write_Str (\"--> new scope: \");\n-         Write_Name (Chars (Current_Scope));\n-         Write_Str (\", Id=\");\n-         Write_Int (Int (Current_Scope));\n-         Write_Str (\", Depth=\");\n-         Write_Int (Int (Scope_Stack.Last));\n-         Write_Eol;\n-      end if;\n-\n-      --  Copy from Scope (S) the categorization flags to S, this is not\n-      --  done in case Scope (S) is Standard_Standard since propagation\n-      --  is from library unit entity inwards.\n-\n-      if S /= Standard_Standard\n-        and then Scope (S) /= Standard_Standard\n-        and then not Is_Child_Unit (S)\n-      then\n-         E := Scope (S);\n-\n-         if Nkind (E) not in N_Entity then\n-            return;\n-         end if;\n-\n-         --  We only propagate inwards for library level entities,\n-         --  inner level subprograms do not inherit the categorization.\n-\n-         if Is_Library_Level_Entity (S) then\n-            Set_Is_Preelaborated (S, Is_Preelaborated (E));\n-            Set_Is_Shared_Passive (S, Is_Shared_Passive (E));\n-            Set_Categorization_From_Scope (E => S, Scop => E);\n-         end if;\n-      end if;\n-   end New_Scope;\n-\n    ------------------------\n    -- Note_Redundant_Use --\n    ------------------------\n@@ -5832,6 +5847,109 @@ package body Sem_Ch8 is\n       Scope_Stack.Decrement_Last;\n    end Pop_Scope;\n \n+   ---------------\n+   -- Push_Scope --\n+   ---------------\n+\n+   procedure Push_Scope (S : Entity_Id) is\n+      E : Entity_Id;\n+\n+   begin\n+      if Ekind (S) = E_Void then\n+         null;\n+\n+      --  Set scope depth if not a non-concurrent type, and we have not\n+      --  yet set the scope depth. This means that we have the first\n+      --  occurrence of the scope, and this is where the depth is set.\n+\n+      elsif (not Is_Type (S) or else Is_Concurrent_Type (S))\n+        and then not Scope_Depth_Set (S)\n+      then\n+         if S = Standard_Standard then\n+            Set_Scope_Depth_Value (S, Uint_0);\n+\n+         elsif Is_Child_Unit (S) then\n+            Set_Scope_Depth_Value (S, Uint_1);\n+\n+         elsif not Is_Record_Type (Current_Scope) then\n+            if Ekind (S) = E_Loop then\n+               Set_Scope_Depth_Value (S, Scope_Depth (Current_Scope));\n+            else\n+               Set_Scope_Depth_Value (S, Scope_Depth (Current_Scope) + 1);\n+            end if;\n+         end if;\n+      end if;\n+\n+      Scope_Stack.Increment_Last;\n+\n+      declare\n+         SST : Scope_Stack_Entry renames Scope_Stack.Table (Scope_Stack.Last);\n+\n+      begin\n+         SST.Entity                         := S;\n+         SST.Save_Scope_Suppress            := Scope_Suppress;\n+         SST.Save_Local_Entity_Suppress     := Local_Entity_Suppress.Last;\n+\n+         if Scope_Stack.Last > Scope_Stack.First then\n+            SST.Component_Alignment_Default := Scope_Stack.Table\n+                                                 (Scope_Stack.Last - 1).\n+                                                   Component_Alignment_Default;\n+         end if;\n+\n+         SST.Last_Subprogram_Name           := null;\n+         SST.Is_Transient                   := False;\n+         SST.Node_To_Be_Wrapped             := Empty;\n+         SST.Pending_Freeze_Actions         := No_List;\n+         SST.Actions_To_Be_Wrapped_Before   := No_List;\n+         SST.Actions_To_Be_Wrapped_After    := No_List;\n+         SST.First_Use_Clause               := Empty;\n+         SST.Is_Active_Stack_Base           := False;\n+         SST.Previous_Visibility            := False;\n+      end;\n+\n+      if Debug_Flag_W then\n+         Write_Str (\"--> new scope: \");\n+         Write_Name (Chars (Current_Scope));\n+         Write_Str (\", Id=\");\n+         Write_Int (Int (Current_Scope));\n+         Write_Str (\", Depth=\");\n+         Write_Int (Int (Scope_Stack.Last));\n+         Write_Eol;\n+      end if;\n+\n+      --  Deal with copying flags from the previous scope to this one. This\n+      --  is not necessary if either scope is standard, or if the new scope\n+      --  is a child unit.\n+\n+      if S /= Standard_Standard\n+        and then Scope (S) /= Standard_Standard\n+        and then not Is_Child_Unit (S)\n+      then\n+         E := Scope (S);\n+\n+         if Nkind (E) not in N_Entity then\n+            return;\n+         end if;\n+\n+         --  Copy categorization flags from Scope (S) to S, this is not done\n+         --  when Scope (S) is Standard_Standard since propagation is from\n+         --  library unit entity inwards. Copy other relevant attributes as\n+         --  well (Discard_Names in particular).\n+\n+         --  We only propagate inwards for library level entities,\n+         --  inner level subprograms do not inherit the categorization.\n+\n+         if Is_Library_Level_Entity (S) then\n+            Set_Is_Preelaborated  (S, Is_Preelaborated (E));\n+            Set_Is_Shared_Passive (S, Is_Shared_Passive (E));\n+            Set_Discard_Names     (S, Discard_Names (E));\n+            Set_Suppress_Value_Tracking_On_Call\n+                                  (S, Suppress_Value_Tracking_On_Call (E));\n+            Set_Categorization_From_Scope (E => S, Scop => E);\n+         end if;\n+      end if;\n+   end Push_Scope;\n+\n    ---------------------\n    -- Premature_Usage --\n    ---------------------\n@@ -5897,7 +6015,7 @@ package body Sem_Ch8 is\n \n    function Present_System_Aux (N : Node_Id := Empty) return Boolean is\n       Loc      : Source_Ptr;\n-      Aux_Name : Name_Id;\n+      Aux_Name : Unit_Name_Type;\n       Unum     : Unit_Number_Type;\n       Withn    : Node_Id;\n       With_Sys : Node_Id;\n@@ -6104,11 +6222,11 @@ package body Sem_Ch8 is\n          end if;\n \n          if Is_Child_Unit (S)\n-            and not In_Child     --  check only for current unit.\n+            and not In_Child     --  check only for current unit\n          then\n             In_Child := True;\n \n-            --  restore visibility of parents according to whether the child\n+            --  Restore visibility of parents according to whether the child\n             --  is private and whether we are in its visible part.\n \n             Comp_Unit := Parent (Unit_Declaration_Node (S));"}, {"sha": "b2141d7cce4a40ab8b8ad2179701ec7c1ce117b7", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 405, "deletions": 5, "changes": 410, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbe627afbd02f0e151a772f1bbd00ec8dc13c6a8/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbe627afbd02f0e151a772f1bbd00ec8dc13c6a8/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=fbe627afbd02f0e151a772f1bbd00ec8dc13c6a8", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1999-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1999-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -26,6 +26,7 @@\n \n with Alloc;\n with Atree;    use Atree;\n+with Debug;    use Debug;\n with Einfo;    use Einfo;\n with Errout;   use Errout;\n with Exp_Code; use Exp_Code;\n@@ -119,6 +120,377 @@ package body Sem_Warn is\n       end if;\n    end Check_Code_Statement;\n \n+   ---------------------------------\n+   -- Check_Infinite_Loop_Warning --\n+   ---------------------------------\n+\n+   --  The case we look for is a while loop which tests a local variable, where\n+   --  there is no obvious direct or possible indirect update of the variable\n+   --  within the body of the loop.\n+\n+   procedure Check_Infinite_Loop_Warning (Loop_Statement : Node_Id) is\n+      Iter : constant Node_Id := Iteration_Scheme (Loop_Statement);\n+\n+      Ref : Node_Id   := Empty;\n+      --  Reference in iteration scheme to variable that may not be modified\n+      --  in loop, indicating a possible infinite loop.\n+\n+      Var : Entity_Id := Empty;\n+      --  Corresponding entity (entity of Ref)\n+\n+      procedure Find_Var (N : Node_Id);\n+      --  Inspect condition to see if it depends on a single entity\n+      --  reference. If so, Ref is set to point to the reference node,\n+      --  and Var is set to the referenced Entity.\n+\n+      function Has_Indirection (T : Entity_Id) return Boolean;\n+      --  If the controlling variable is an access type, or is a record type\n+      --  with access components, assume that it is changed indirectly and\n+      --  suppress the warning. As a concession to low-level programming, in\n+      --  particular within Declib, we also suppress warnings on a record\n+      --  type that contains components of type Address or Short_Address.\n+\n+      function Is_Suspicious_Function_Name (E : Entity_Id) return Boolean;\n+      --  Given an entity name, see if the name appears to have something to\n+      --  do with I/O or network stuff, and if so, return True. Used to kill\n+      --  some false positives on a heuristic basis that such functions will\n+      --  likely have some strange side effect dependencies. A rather funny\n+      --  kludge, but warning messages are in the heuristics business.\n+\n+      function Test_Ref (N : Node_Id) return Traverse_Result;\n+      --  Test for reference to variable in question. Returns Abandon if\n+      --  matching reference found.\n+\n+      function Find_Ref is new Traverse_Func (Test_Ref);\n+      --  Function to traverse body of procedure. Returns Abandon if matching\n+      --  reference found.\n+\n+      --------------\n+      -- Find_Var --\n+      --------------\n+\n+      procedure Find_Var (N : Node_Id) is\n+      begin\n+         --  Condition is a direct variable reference\n+\n+         if Is_Entity_Name (N) then\n+            Ref := N;\n+            Var := Entity (Ref);\n+\n+            --  Case of condition is a comparison with compile time known value\n+\n+         elsif Nkind (N) in N_Op_Compare then\n+            if Compile_Time_Known_Value (Right_Opnd (N)) then\n+               Find_Var (Left_Opnd (N));\n+\n+            elsif Compile_Time_Known_Value (Left_Opnd (N)) then\n+               Find_Var (Right_Opnd (N));\n+\n+            --  Ignore any other comparison\n+\n+            else\n+               return;\n+            end if;\n+\n+            --  If condition is a negation, check its operand\n+\n+         elsif Nkind (N) = N_Op_Not then\n+            Find_Var (Right_Opnd (N));\n+\n+            --  Case of condition is function call\n+\n+         elsif Nkind (N) = N_Function_Call then\n+\n+            --  Forget it if function name is not entity, who knows what\n+            --  we might be calling?\n+\n+            if not Is_Entity_Name (Name (N)) then\n+               return;\n+\n+               --  Forget it if warnings are suppressed on function entity\n+\n+            elsif Warnings_Off (Entity (Name (N))) then\n+               return;\n+\n+               --  Forget it if function name is suspicious. A strange test\n+               --  but warning generation is in the heuristics business!\n+\n+            elsif Is_Suspicious_Function_Name (Entity (Name (N))) then\n+               return;\n+            end if;\n+\n+            --  OK, see if we have one argument\n+\n+            declare\n+               PA : constant List_Id := Parameter_Associations (N);\n+\n+            begin\n+               --  One argument, so check the argument\n+\n+               if Present (PA)\n+                 and then List_Length (PA) = 1\n+               then\n+                  if Nkind (First (PA)) = N_Parameter_Association then\n+                     Find_Var (Explicit_Actual_Parameter (First (PA)));\n+                  else\n+                     Find_Var (First (PA));\n+                  end if;\n+\n+                  --  Not one argument\n+\n+               else\n+                  return;\n+               end if;\n+            end;\n+\n+            --  Any other kind of node is not something we warn for\n+\n+         else\n+            return;\n+         end if;\n+      end Find_Var;\n+\n+      ---------------------\n+      -- Has_Indirection --\n+      ---------------------\n+\n+      function Has_Indirection (T : Entity_Id) return Boolean is\n+         Comp : Entity_Id;\n+         Rec  : Entity_Id;\n+\n+      begin\n+         if Is_Access_Type (T) then\n+            return True;\n+\n+         elsif Is_Private_Type (T)\n+           and then Present (Full_View (T))\n+           and then Is_Access_Type (Full_View (T))\n+         then\n+            return True;\n+\n+         elsif Is_Record_Type (T) then\n+            Rec := T;\n+\n+         elsif Is_Private_Type (T)\n+           and then Present (Full_View (T))\n+           and then Is_Record_Type (Full_View (T))\n+         then\n+            Rec := Full_View (T);\n+         else\n+            return False;\n+         end if;\n+\n+         Comp := First_Component (Rec);\n+         while Present (Comp) loop\n+            if Is_Access_Type (Etype (Comp))\n+              or else Is_Descendent_Of_Address (Etype (Comp))\n+            then\n+               return True;\n+            end if;\n+\n+            Next_Component (Comp);\n+         end loop;\n+\n+         return False;\n+      end Has_Indirection;\n+\n+      ---------------------------------\n+      -- Is_Suspicious_Function_Name --\n+      ---------------------------------\n+\n+      function Is_Suspicious_Function_Name (E : Entity_Id) return Boolean is\n+         S : Entity_Id;\n+\n+         function Substring_Present (S : String) return Boolean;\n+         --  Returns True if name buffer has given string delimited by non-\n+         --  alphabetic characters or by end of string. S is lower case.\n+\n+         -----------------------\n+         -- Substring_Present --\n+         -----------------------\n+\n+         function Substring_Present (S : String) return Boolean is\n+            Len : constant Natural := S'Length;\n+\n+         begin\n+            for J in 1 .. Name_Len - (Len - 1) loop\n+               if Name_Buffer (J .. J + (Len - 1)) = S\n+                 and then\n+                   (J = 1\n+                     or else Name_Buffer (J - 1) not in 'a' .. 'z')\n+                 and then\n+                   (J + Len > Name_Len\n+                     or else Name_Buffer (J + Len) not in 'a' .. 'z')\n+               then\n+                  return True;\n+               end if;\n+            end loop;\n+\n+            return False;\n+         end Substring_Present;\n+\n+         --  Start of processing for Is_Suspicious_Function_Name\n+\n+      begin\n+         S := E;\n+         while Present (S) and then S /= Standard_Standard loop\n+            Get_Name_String (Chars (S));\n+\n+            if Substring_Present (\"io\")\n+              or else Substring_Present (\"file\")\n+              or else Substring_Present (\"network\")\n+            then\n+               return True;\n+            else\n+               S := Scope (S);\n+            end if;\n+         end loop;\n+\n+         return False;\n+      end Is_Suspicious_Function_Name;\n+\n+      --------------\n+      -- Test_Ref --\n+      --------------\n+\n+      function Test_Ref (N : Node_Id) return Traverse_Result is\n+      begin\n+         --  Waste of time to look at iteration scheme\n+\n+         if N = Iter then\n+            return Skip;\n+\n+            --  Direct reference to variable in question\n+\n+         elsif Is_Entity_Name (N)\n+           and then Present (Entity (N))\n+           and then Entity (N) = Var\n+         then\n+            --  If this is an Lvalue, then definitely abandon, since\n+            --  this could be a direct modification of the variable.\n+\n+            if May_Be_Lvalue (N) then\n+               return Abandon;\n+            end if;\n+\n+            --  If we appear in the context of a procedure call, then also\n+            --  abandon, since there may be issues of non-visible side\n+            --  effects going on in the call.\n+\n+            declare\n+               P : Node_Id;\n+            begin\n+               P := N;\n+               loop\n+                  P := Parent (P);\n+                  exit when P = Loop_Statement;\n+\n+                  if Nkind (P) = N_Procedure_Call_Statement then\n+                     return Abandon;\n+                  end if;\n+               end loop;\n+            end;\n+\n+            --  Reference to variable renaming variable in question\n+\n+         elsif Is_Entity_Name (N)\n+           and then Present (Entity (N))\n+           and then Ekind (Entity (N)) = E_Variable\n+           and then Present (Renamed_Object (Entity (N)))\n+           and then Is_Entity_Name (Renamed_Object (Entity (N)))\n+           and then Entity (Renamed_Object (Entity (N))) = Var\n+           and then May_Be_Lvalue (N)\n+         then\n+            return Abandon;\n+\n+            --  Call to subprogram\n+\n+         elsif Nkind (N) = N_Procedure_Call_Statement\n+           or else Nkind (N) = N_Function_Call\n+         then\n+            --  If subprogram is within the scope of the entity we are\n+            --  dealing with as the loop variable, then it could modify\n+            --  this parameter, so we abandon in this case. In the case\n+            --  of a subprogram that is not an entity we also abandon.\n+\n+            if not Is_Entity_Name (Name (N))\n+              or else Scope_Within (Entity (Name (N)), Scope (Var))\n+            then\n+               return Abandon;\n+            end if;\n+         end if;\n+\n+         --  All OK, continue scan\n+\n+         return OK;\n+      end Test_Ref;\n+\n+   --  Start of processing for Check_Infinite_Loop_Warning\n+\n+   begin\n+      --  We need a while iteration with no condition actions. Conditions\n+      --  actions just make things too complicated to get the warning right.\n+\n+      if No (Iter)\n+        or else No (Condition (Iter))\n+        or else Present (Condition_Actions (Iter))\n+        or else Debug_Flag_Dot_W\n+      then\n+         return;\n+      end if;\n+\n+      --  Initial conditions met, see if condition is of right form\n+\n+      Find_Var (Condition (Iter));\n+\n+      --  Nothing to do if local variable from source not found\n+\n+      if No (Var)\n+        or else Ekind (Var) /= E_Variable\n+        or else Is_Library_Level_Entity (Var)\n+        or else not Comes_From_Source (Var)\n+      then\n+         return;\n+\n+      --  Nothing to do if there is some indirection involved (assume that the\n+      --  designated variable might be modified in some way we don't see).\n+\n+      elsif Has_Indirection (Etype (Var)) then\n+         return;\n+\n+      --  Same sort of thing for volatile variable, might be modified by\n+      --  some other task or by the operating system in some way.\n+\n+      elsif Is_Volatile (Var) then\n+         return;\n+      end if;\n+\n+      --  Filter out case of original statement sequence starting with delay.\n+      --  We assume this is a multi-tasking program and that the condition\n+      --  is affected by other threads (some kind of busy wait).\n+\n+      declare\n+         Fstm : constant Node_Id :=\n+                  Original_Node (First (Statements (Loop_Statement)));\n+      begin\n+         if Nkind (Fstm) = N_Delay_Relative_Statement\n+           or else Nkind (Fstm) = N_Delay_Until_Statement\n+         then\n+            return;\n+         end if;\n+      end;\n+\n+      --  We have a variable reference of the right form, now we scan the loop\n+      --  body to see if it looks like it might not be modified\n+\n+      if Find_Ref (Loop_Statement) = OK then\n+         Error_Msg_NE\n+           (\"variable& is not modified in loop body?\", Ref, Var);\n+         Error_Msg_N\n+           (\"\\possible infinite loop\", Ref);\n+      end if;\n+   end Check_Infinite_Loop_Warning;\n+\n    ----------------------\n    -- Check_References --\n    ----------------------\n@@ -334,10 +706,14 @@ package body Sem_Warn is\n       E1 := First_Entity (E);\n       while Present (E1) loop\n \n-         --  We only look at source entities with warning flag on\n-\n-         if Comes_From_Source (E1) and then not Warnings_Off (E1) then\n+         --  We only look at source entities with warning flag on. We also\n+         --  ignore objects whose type or base type has warnings suppressed.\n \n+         if Comes_From_Source (E1)\n+           and then not Warnings_Off (E1)\n+           and then not Warnings_Off (Etype (E1))\n+           and then not Warnings_Off (Base_Type (Etype (E1)))\n+         then\n             --  We are interested in variables and out parameters, but we\n             --  exclude protected types, too complicated to worry about.\n \n@@ -629,6 +1005,14 @@ package body Sem_Warn is\n                and then (Nkind (Unit (Cunit (Main_Unit))) /= N_Subunit\n                            or else\n                          Get_Source_Unit (E1) = Main_Unit)\n+\n+               --  No warning on a return object, because these are often\n+               --  created with a single expression and an implicit return.\n+               --  If the object is a variable there will be a warning\n+               --  indicating that it could be declared constant.\n+\n+               and then not\n+                 (Ekind (E1) = E_Constant and then Is_Return_Object (E1))\n             then\n                --  Suppress warnings in internal units if not in -gnatg mode\n                --  (these would be junk warnings for an applications program,\n@@ -870,7 +1254,7 @@ package body Sem_Warn is\n                               return;\n                            end if;\n \n-                           --  We are only interested in deferences\n+                           --  We are only interested in dereferences\n \n                            if not Is_Dereferenced (N) then\n                               return;\n@@ -1741,6 +2125,18 @@ package body Sem_Warn is\n    function Set_Dot_Warning_Switch (C : Character) return Boolean is\n    begin\n       case C is\n+         when 'c' =>\n+            Warn_On_Unrepped_Components         := True;\n+\n+         when 'C' =>\n+            Warn_On_Unrepped_Components         := False;\n+\n+         when 'r' =>\n+            Warn_On_Object_Renames_Function     := True;\n+\n+         when 'R' =>\n+            Warn_On_Object_Renames_Function     := False;\n+\n          when 'x' =>\n             Warn_On_Non_Local_Exception         := True;\n \n@@ -1779,8 +2175,10 @@ package body Sem_Warn is\n             Warn_On_Obsolescent_Feature         := True;\n             Warn_On_Questionable_Missing_Parens := True;\n             Warn_On_Redundant_Constructs        := True;\n+            Warn_On_Object_Renames_Function     := True;\n             Warn_On_Unchecked_Conversion        := True;\n             Warn_On_Unrecognized_Pragma         := True;\n+            Warn_On_Unrepped_Components         := True;\n \n          when 'A' =>\n             Check_Unreferenced                  := False;\n@@ -1803,8 +2201,10 @@ package body Sem_Warn is\n             Warn_On_Obsolescent_Feature         := False;\n             Warn_On_Questionable_Missing_Parens := False;\n             Warn_On_Redundant_Constructs        := False;\n+            Warn_On_Object_Renames_Function     := False;\n             Warn_On_Unchecked_Conversion        := False;\n             Warn_On_Unrecognized_Pragma         := False;\n+            Warn_On_Unrepped_Components         := False;\n \n          when 'b' =>\n             Warn_On_Bad_Fixed_Value             := True;"}, {"sha": "86c36a96577db6dcee2ac9649edef546ae1101fe", "filename": "gcc/ada/sem_warn.ads", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbe627afbd02f0e151a772f1bbd00ec8dc13c6a8/gcc%2Fada%2Fsem_warn.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbe627afbd02f0e151a772f1bbd00ec8dc13c6a8/gcc%2Fada%2Fsem_warn.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.ads?ref=fbe627afbd02f0e151a772f1bbd00ec8dc13c6a8", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1999-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1999-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -120,7 +120,11 @@ package Sem_Warn is\n    ----------------------------\n \n    procedure Check_Code_Statement (N : Node_Id);\n-   --  Peform warning checks on a code statement node\n+   --  Perform warning checks on a code statement node\n+\n+   procedure Check_Infinite_Loop_Warning (Loop_Statement : Node_Id);\n+   --  N is the node for a loop statement. This procedure checks if a warning\n+   --  should be given for a possible infinite loop, and if so issues it.\n \n    procedure Warn_On_Known_Condition (C : Node_Id);\n    --  C is a node for a boolean expression resluting from a relational"}]}