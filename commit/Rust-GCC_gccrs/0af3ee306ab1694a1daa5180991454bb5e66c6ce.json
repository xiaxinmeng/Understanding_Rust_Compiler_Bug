{"sha": "0af3ee306ab1694a1daa5180991454bb5e66c6ce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGFmM2VlMzA2YWIxNjk0YTFkYWE1MTgwOTkxNDU0YmI1ZTY2YzZjZQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-05-10T12:31:01Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-05-10T12:31:01Z"}, "message": "(alpha_set_emit_const): Cleanups to work properly when run on 32-bit\nhost.\n\nFrom-SVN: r9609", "tree": {"sha": "ce7a5c2bf852fd7d93a8817375e899b2e4cb60a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ce7a5c2bf852fd7d93a8817375e899b2e4cb60a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0af3ee306ab1694a1daa5180991454bb5e66c6ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0af3ee306ab1694a1daa5180991454bb5e66c6ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0af3ee306ab1694a1daa5180991454bb5e66c6ce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0af3ee306ab1694a1daa5180991454bb5e66c6ce/comments", "author": null, "committer": null, "parents": [{"sha": "7ac16ba05b3599300418c4d941b25c97c4c7c3fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ac16ba05b3599300418c4d941b25c97c4c7c3fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ac16ba05b3599300418c4d941b25c97c4c7c3fe"}], "stats": {"total": 26, "additions": 14, "deletions": 12}, "files": [{"sha": "625c933878a0c2eb729a0896c8c088757f00dceb", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0af3ee306ab1694a1daa5180991454bb5e66c6ce/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0af3ee306ab1694a1daa5180991454bb5e66c6ce/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=0af3ee306ab1694a1daa5180991454bb5e66c6ce", "patch": "@@ -689,10 +689,12 @@ alpha_emit_set_const (target, mode, c, n)\n \n   /* If this is a sign-extended 32-bit constant, we can do this in at most\n      three insns, so do it if we have enough insns left.  We always have\n-     a sign-extended 32-bit constant when compiling on a narrow machine.  */\n+     a sign-extended 32-bit constant when compiling on a narrow machine. \n+     Note that we cannot handle the constant 0x80000000.  */\n \n-  if (HOST_BITS_PER_WIDE_INT != 64\n-      || c >> 31 == -1 || c >> 31 == 0)\n+  if ((HOST_BITS_PER_WIDE_INT != 64\n+       || c >> 31 == -1 || c >> 31 == 0)\n+      && c != 0x80000000u)\n     {\n       HOST_WIDE_INT low = (c & 0xffff) - 2 * (c & 0x8000);\n       HOST_WIDE_INT tmp1 = c - low;\n@@ -725,15 +727,13 @@ alpha_emit_set_const (target, mode, c, n)\n \t}\n     }\n \n-  /* If we couldn't do it that way, try some other methods (that depend on\n-     being able to compute in the target's word size).  But if we have no\n-     instructions left, don't bother.  Also, don't even try if this is \n-     SImode (in which case we should have already done something, but\n-     do a sanity check here).  */\n+  /* If we couldn't do it that way, try some other methods.  But if we have\n+     no instructions left, don't bother.  */\n \n-  if (n == 1 || HOST_BITS_PER_WIDE_INT < 64 || mode != DImode)\n+  if (n == 1)\n     return 0;\n \n+#if HOST_BITS_PER_WIDE_INT == 64\n   /* First, see if can load a value into the target that is the same as the\n      constant except that all bytes that are 0 are changed to be 0xff.  If we\n      can, then we can do a ZAPNOT to obtain the desired constant.  */\n@@ -745,8 +745,9 @@ alpha_emit_set_const (target, mode, c, n)\n   if ((temp = alpha_emit_set_const (subtarget, mode, new, n - 1)) != 0)\n     return expand_binop (mode, and_optab, temp, GEN_INT (c | ~ new),\n \t\t\t target, 0, OPTAB_WIDEN);\n+#endif\n \n-  /* Find, see if we can load a related constant and then shift and possibly\n+  /* Next, see if we can load a related constant and then shift and possibly\n      negate it to get the constant we want.  Try this once each increasing\n      numbers of insns.  */\n \n@@ -767,8 +768,9 @@ alpha_emit_set_const (target, mode, c, n)\n \n       if ((bits = exact_log2 (c & - c)) > 0)\n \tfor (; bits > 0; bits--)\n-\t  if ((temp = alpha_emit_set_const (subtarget, mode,\n-\t\t\t\t\t    c >> bits, i)) != 0\n+\t  if ((temp = (alpha_emit_set_const\n+\t\t       (subtarget, mode,\n+\t\t\t(unsigned HOST_WIDE_INT) c >> bits, i))) != 0\n \t      || ((temp = (alpha_emit_set_const\n \t\t\t  (subtarget, mode,\n \t\t\t   ((unsigned HOST_WIDE_INT) c) >> bits, i)))"}]}