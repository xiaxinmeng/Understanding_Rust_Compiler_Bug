{"sha": "8d2d39587d941a40f25ea0144cceb677df115040", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQyZDM5NTg3ZDk0MWE0MGYyNWVhMDE0NGNjZWI2NzdkZjExNTA0MA==", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2018-10-22T20:23:39Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@gcc.gnu.org", "date": "2018-10-22T20:23:39Z"}, "message": "combine: Do not combine moves from hard registers\n\nOn most targets every function starts with moves from the parameter\npassing (hard) registers into pseudos.  Similarly, after every call\nthere is a move from the return register into a pseudo.  These moves\nusually combine with later instructions (leaving pretty much the same\ninstruction, just with a hard reg instead of a pseudo).\n\nThis isn't a good idea.  Register allocation can get rid of unnecessary\nmoves just fine, and moving the parameter passing registers into many\nlater instructions tends to prevent good register allocation.  This\npatch disallows combining moves from a hard (non-fixed) register.\n\nThis also avoid the problem mentioned in PR87600 #c3 (combining hard\nregisters into inline assembler is problematic).\n\nBecause the register move can often be combined with other instructions\n*itself*, for example for setting some condition code, this patch adds\nextra copies via new pseudos after every copy-from-hard-reg.\n\nOn some targets this reduces average code size.  On others it increases\nit a bit, 0.1% or 0.2% or so.  (I tested this on all *-linux targets).\n\n\n\tPR rtl-optimization/87600\n\t* combine.c: Add include of expr.h.\n\t(cant_combine_insn_p): Do not combine moves from any hard non-fixed\n\tregister to a pseudo.\n\t(make_more_copies): New function, add a copy to a new pseudo after\n\tthe moves from hard registers into pseudos.\n\t(rest_of_handle_combine): Declare rebuild_jump_labels_after_combine\n\tlater.  Call make_more_copies.\n\nFrom-SVN: r265398", "tree": {"sha": "2f6a7fb98a24d7e9e26b2519b4f4ae5c355579b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f6a7fb98a24d7e9e26b2519b4f4ae5c355579b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d2d39587d941a40f25ea0144cceb677df115040", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d2d39587d941a40f25ea0144cceb677df115040", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d2d39587d941a40f25ea0144cceb677df115040", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d2d39587d941a40f25ea0144cceb677df115040/comments", "author": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f3b13f46fa6b9e28859e26ec2201bc6017cda0c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3b13f46fa6b9e28859e26ec2201bc6017cda0c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3b13f46fa6b9e28859e26ec2201bc6017cda0c1"}], "stats": {"total": 61, "additions": 57, "deletions": 4}, "files": [{"sha": "1cfcc31b9630d19b350334bca5e3994327391e2a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2d39587d941a40f25ea0144cceb677df115040/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2d39587d941a40f25ea0144cceb677df115040/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8d2d39587d941a40f25ea0144cceb677df115040", "patch": "@@ -1,3 +1,14 @@\n+2018-10-22  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\tPR rtl-optimization/87600\n+\t* combine.c: Add include of expr.h.\n+\t(cant_combine_insn_p): Do not combine moves from any hard non-fixed\n+\tregister to a pseudo.\n+\t(make_more_copies): New function, add a copy to a new pseudo after\n+\tthe moves from hard registers into pseudos.\n+\t(rest_of_handle_combine): Declare rebuild_jump_labels_after_combine\n+\tlater.  Call make_more_copies.\n+\n 2018-10-22  Andrew Stubbs  <ams@codesourcery.com>\n \n \t* lra-constraints.c (process_alt_operands): New local array,"}, {"sha": "8ec6809c05c1f92119caa4f267c9307521e96110", "filename": "gcc/combine.c", "status": "modified", "additions": 46, "deletions": 4, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2d39587d941a40f25ea0144cceb677df115040/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2d39587d941a40f25ea0144cceb677df115040/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=8d2d39587d941a40f25ea0144cceb677df115040", "patch": "@@ -99,6 +99,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"explow.h\"\n #include \"insn-attr.h\"\n #include \"rtlhooks-def.h\"\n+#include \"expr.h\"\n #include \"params.h\"\n #include \"tree-pass.h\"\n #include \"valtrack.h\"\n@@ -2348,8 +2349,7 @@ cant_combine_insn_p (rtx_insn *insn)\n     dest = SUBREG_REG (dest);\n   if (REG_P (src) && REG_P (dest)\n       && ((HARD_REGISTER_P (src)\n-\t   && ! TEST_HARD_REG_BIT (fixed_reg_set, REGNO (src))\n-\t   && targetm.class_likely_spilled_p (REGNO_REG_CLASS (REGNO (src))))\n+\t   && ! TEST_HARD_REG_BIT (fixed_reg_set, REGNO (src)))\n \t  || (HARD_REGISTER_P (dest)\n \t      && ! TEST_HARD_REG_BIT (fixed_reg_set, REGNO (dest))\n \t      && targetm.class_likely_spilled_p (REGNO_REG_CLASS (REGNO (dest))))))\n@@ -14935,11 +14935,53 @@ dump_combine_total_stats (FILE *file)\n      total_attempts, total_merges, total_extras, total_successes);\n }\n \f\n+/* Make pseudo-to-pseudo copies after every hard-reg-to-pseudo-copy, because\n+   the reg-to-reg copy can usefully combine with later instructions, but we\n+   do not want to combine the hard reg into later instructions, for that\n+   restricts register allocation.  */\n+static void\n+make_more_copies (void)\n+{\n+  basic_block bb;\n+\n+  FOR_EACH_BB_FN (bb, cfun)\n+    {\n+      rtx_insn *insn;\n+\n+      FOR_BB_INSNS (bb, insn)\n+        {\n+          if (!NONDEBUG_INSN_P (insn))\n+            continue;\n+\n+\t  rtx set = single_set (insn);\n+\t  if (!set)\n+\t    continue;\n+\t  rtx src = SET_SRC (set);\n+\t  rtx dest = SET_DEST (set);\n+\t  if (GET_CODE (src) == SUBREG)\n+\t    src = SUBREG_REG (src);\n+\t  if (!(REG_P (src) && HARD_REGISTER_P (src)))\n+\t    continue;\n+\t  if (TEST_HARD_REG_BIT (fixed_reg_set, REGNO (src)))\n+\t    continue;\n+\n+\t  rtx new_reg = gen_reg_rtx (GET_MODE (dest));\n+\t  rtx_insn *insn1 = gen_move_insn (new_reg, src);\n+\t  rtx_insn *insn2 = gen_move_insn (dest, new_reg);\n+\t  emit_insn_after (insn1, insn);\n+\t  emit_insn_after (insn2, insn1);\n+\t  delete_insn (insn);\n+\n+\t  insn = insn2;\n+\t}\n+    }\n+}\n+\n /* Try combining insns through substitution.  */\n static unsigned int\n rest_of_handle_combine (void)\n {\n-  int rebuild_jump_labels_after_combine;\n+  make_more_copies ();\n \n   df_set_flags (DF_LR_RUN_DCE + DF_DEFER_INSN_RESCAN);\n   df_note_add_problem ();\n@@ -14948,7 +14990,7 @@ rest_of_handle_combine (void)\n   regstat_init_n_sets_and_refs ();\n   reg_n_sets_max = max_reg_num ();\n \n-  rebuild_jump_labels_after_combine\n+  int rebuild_jump_labels_after_combine\n     = combine_instructions (get_insns (), max_reg_num ());\n \n   /* Combining insns may have turned an indirect jump into a"}]}