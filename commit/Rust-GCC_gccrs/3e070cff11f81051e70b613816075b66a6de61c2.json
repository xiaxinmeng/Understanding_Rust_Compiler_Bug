{"sha": "3e070cff11f81051e70b613816075b66a6de61c2", "node_id": "C_kwDOANBUbNoAKDNlMDcwY2ZmMTFmODEwNTFlNzBiNjEzODE2MDc1YjY2YTZkZTYxYzI", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2022-11-13T20:59:48Z"}, "committer": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2022-11-14T08:35:06Z"}, "message": "Revert \"sphinx: use tm.rst.in file in target macros\"\n\nThis reverts commit 8f2b513c28ae24f0204b3b438747bbd1cfebba0a.", "tree": {"sha": "df5239508898a3e5af0bbf34a9cf7ce86e19e5d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df5239508898a3e5af0bbf34a9cf7ce86e19e5d6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3e070cff11f81051e70b613816075b66a6de61c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e070cff11f81051e70b613816075b66a6de61c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e070cff11f81051e70b613816075b66a6de61c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e070cff11f81051e70b613816075b66a6de61c2/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e3dcf20763d7d4b2c06553ee14c88b573aabafc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e3dcf20763d7d4b2c06553ee14c88b573aabafc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e3dcf20763d7d4b2c06553ee14c88b573aabafc"}], "stats": {"total": 7975, "additions": 6480, "deletions": 1495}, "files": [{"sha": "fcff73bb179505ef1ea026c08a5e4e245e6eb70e", "filename": "gcc/doc/gccint/target-macros/adding-support-for-named-address-spaces.rst", "status": "modified", "additions": 98, "deletions": 30, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fadding-support-for-named-address-spaces.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fadding-support-for-named-address-spaces.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fadding-support-for-named-address-spaces.rst?ref=3e070cff11f81051e70b613816075b66a6de61c2", "patch": "@@ -45,51 +45,119 @@ named address space #1:\n   #define ADDR_SPACE_EA 1\n   c_register_addr_space (\"__ea\", ADDR_SPACE_EA);\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_ADDR_SPACE_POINTER_MODE]\n-  :end-before: [TARGET_ADDR_SPACE_POINTER_MODE]\n+.. function:: scalar_int_mode TARGET_ADDR_SPACE_POINTER_MODE (addr_space_t address_space)\n \n+  .. hook-start:TARGET_ADDR_SPACE_POINTER_MODE\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_ADDR_SPACE_ADDRESS_MODE]\n-  :end-before: [TARGET_ADDR_SPACE_ADDRESS_MODE]\n+  Define this to return the machine mode to use for pointers to\n+  :samp:`{address_space}` if the target supports named address spaces.\n+  The default version of this hook returns ``ptr_mode``.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_ADDR_SPACE_VALID_POINTER_MODE]\n-  :end-before: [TARGET_ADDR_SPACE_VALID_POINTER_MODE]\n+.. function:: scalar_int_mode TARGET_ADDR_SPACE_ADDRESS_MODE (addr_space_t address_space)\n \n+  .. hook-start:TARGET_ADDR_SPACE_ADDRESS_MODE\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P]\n-  :end-before: [TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P]\n+  Define this to return the machine mode to use for addresses in\n+  :samp:`{address_space}` if the target supports named address spaces.\n+  The default version of this hook returns ``Pmode``.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_ADDR_SPACE_LEGITIMIZE_ADDRESS]\n-  :end-before: [TARGET_ADDR_SPACE_LEGITIMIZE_ADDRESS]\n+.. function:: bool TARGET_ADDR_SPACE_VALID_POINTER_MODE (scalar_int_mode mode, addr_space_t as)\n \n+  .. hook-start:TARGET_ADDR_SPACE_VALID_POINTER_MODE\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_ADDR_SPACE_SUBSET_P]\n-  :end-before: [TARGET_ADDR_SPACE_SUBSET_P]\n+  Define this to return nonzero if the port can handle pointers\n+  with machine mode :samp:`{mode}` to address space :samp:`{as}`.  This target\n+  hook is the same as the ``TARGET_VALID_POINTER_MODE`` target hook,\n+  except that it includes explicit named address space support.  The default\n+  version of this hook returns true for the modes returned by either the\n+  ``TARGET_ADDR_SPACE_POINTER_MODE`` or ``TARGET_ADDR_SPACE_ADDRESS_MODE``\n+  target hooks for the given address space.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_ADDR_SPACE_ZERO_ADDRESS_VALID]\n-  :end-before: [TARGET_ADDR_SPACE_ZERO_ADDRESS_VALID]\n+.. function:: bool TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P (machine_mode mode, rtx exp, bool strict, addr_space_t as)\n \n+  .. hook-start:TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_ADDR_SPACE_CONVERT]\n-  :end-before: [TARGET_ADDR_SPACE_CONVERT]\n+  Define this to return true if :samp:`{exp}` is a valid address for mode\n+  :samp:`{mode}` in the named address space :samp:`{as}`.  The :samp:`{strict}`\n+  parameter says whether strict addressing is in effect after reload has\n+  finished.  This target hook is the same as the\n+  ``TARGET_LEGITIMATE_ADDRESS_P`` target hook, except that it includes\n+  explicit named address space support.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_ADDR_SPACE_DEBUG]\n-  :end-before: [TARGET_ADDR_SPACE_DEBUG]\n+.. function:: rtx TARGET_ADDR_SPACE_LEGITIMIZE_ADDRESS (rtx x, rtx oldx, machine_mode mode, addr_space_t as)\n \n+  .. hook-start:TARGET_ADDR_SPACE_LEGITIMIZE_ADDRESS\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_ADDR_SPACE_DIAGNOSE_USAGE]\n-  :end-before: [TARGET_ADDR_SPACE_DIAGNOSE_USAGE]\n+  Define this to modify an invalid address :samp:`{x}` to be a valid address\n+  with mode :samp:`{mode}` in the named address space :samp:`{as}`.  This target\n+  hook is the same as the ``TARGET_LEGITIMIZE_ADDRESS`` target hook,\n+  except that it includes explicit named address space support.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_ADDR_SPACE_SUBSET_P (addr_space_t subset, addr_space_t superset)\n+\n+  .. hook-start:TARGET_ADDR_SPACE_SUBSET_P\n+\n+  Define this to return whether the :samp:`{subset}` named address space is\n+  contained within the :samp:`{superset}` named address space.  Pointers to\n+  a named address space that is a subset of another named address space\n+  will be converted automatically without a cast if used together in\n+  arithmetic operations.  Pointers to a superset address space can be\n+  converted to pointers to a subset address space via explicit casts.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_ADDR_SPACE_ZERO_ADDRESS_VALID (addr_space_t as)\n+\n+  .. hook-start:TARGET_ADDR_SPACE_ZERO_ADDRESS_VALID\n+\n+  Define this to modify the default handling of address 0 for the\n+  address space.  Return true if 0 should be considered a valid address.\n+\n+.. hook-end\n+\n+.. function:: rtx TARGET_ADDR_SPACE_CONVERT (rtx op, tree from_type, tree to_type)\n+\n+  .. hook-start:TARGET_ADDR_SPACE_CONVERT\n+\n+  Define this to convert the pointer expression represented by the RTL\n+  :samp:`{op}` with type :samp:`{from_type}` that points to a named address\n+  space to a new pointer expression with type :samp:`{to_type}` that points\n+  to a different named address space.  When this hook it called, it is\n+  guaranteed that one of the two address spaces is a subset of the other,\n+  as determined by the ``TARGET_ADDR_SPACE_SUBSET_P`` target hook.\n+\n+.. hook-end\n+\n+.. function:: int TARGET_ADDR_SPACE_DEBUG (addr_space_t as)\n+\n+  .. hook-start:TARGET_ADDR_SPACE_DEBUG\n+\n+  Define this to define how the address space is encoded in dwarf.\n+  The result is the value to be used with ``DW_AT_address_class``.\n+\n+.. hook-end\n+\n+.. function:: void TARGET_ADDR_SPACE_DIAGNOSE_USAGE (addr_space_t as, location_t loc)\n+\n+  .. hook-start:TARGET_ADDR_SPACE_DIAGNOSE_USAGE\n+\n+  Define this hook if the availability of an address space depends on\n+  command line options and some diagnostics should be printed when the\n+  address space is used.  This hook is called during parsing and allows\n+  to emit a better diagnostic compared to the case where the address space\n+  was not registered with ``c_register_addr_space``.  :samp:`{as}` is\n+  the address space as registered with ``c_register_addr_space``.\n+  :samp:`{loc}` is the location of the address space qualifier token.\n+  The default implementation does nothing.\n+\n+.. hook-end\n\\ No newline at end of file"}, {"sha": "03428bd48cacf87195263e0b8215df7685b776ad", "filename": "gcc/doc/gccint/target-macros/addressing-modes.rst", "status": "modified", "additions": 602, "deletions": 126, "changes": 728, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Faddressing-modes.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Faddressing-modes.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Faddressing-modes.rst?ref=3e070cff11f81051e70b613816075b66a6de61c2", "patch": "@@ -58,10 +58,75 @@ This is about addressing modes.\n   the maximum number that ``TARGET_LEGITIMATE_ADDRESS_P`` would ever\n   accept.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_LEGITIMATE_ADDRESS_P]\n-  :end-before: [TARGET_LEGITIMATE_ADDRESS_P]\n+.. function:: bool TARGET_LEGITIMATE_ADDRESS_P (machine_mode mode, rtx x, bool strict)\n \n+  .. hook-start:TARGET_LEGITIMATE_ADDRESS_P\n+\n+  A function that returns whether :samp:`{x}` (an RTX) is a legitimate memory\n+  address on the target machine for a memory operand of mode :samp:`{mode}`.\n+\n+  Legitimate addresses are defined in two variants: a strict variant and a\n+  non-strict one.  The :samp:`{strict}` parameter chooses which variant is\n+  desired by the caller.\n+\n+  The strict variant is used in the reload pass.  It must be defined so\n+  that any pseudo-register that has not been allocated a hard register is\n+  considered a memory reference.  This is because in contexts where some\n+  kind of register is required, a pseudo-register with no hard register\n+  must be rejected.  For non-hard registers, the strict variant should look\n+  up the ``reg_renumber`` array; it should then proceed using the hard\n+  register number in the array, or treat the pseudo as a memory reference\n+  if the array holds ``-1``.\n+\n+  The non-strict variant is used in other passes.  It must be defined to\n+  accept all pseudo-registers in every context where some kind of\n+  register is required.\n+\n+  Normally, constant addresses which are the sum of a ``symbol_ref``\n+  and an integer are stored inside a ``const`` RTX to mark them as\n+  constant.  Therefore, there is no need to recognize such sums\n+  specifically as legitimate addresses.  Normally you would simply\n+  recognize any ``const`` as legitimate.\n+\n+  Usually ``PRINT_OPERAND_ADDRESS`` is not prepared to handle constant\n+  sums that are not marked with  ``const``.  It assumes that a naked\n+  ``plus`` indicates indexing.  If so, then you *must* reject such\n+  naked constant sums as illegitimate addresses, so that none of them will\n+  be given to ``PRINT_OPERAND_ADDRESS``.\n+\n+  .. index:: TARGET_ENCODE_SECTION_INFO and address validation\n+\n+  On some machines, whether a symbolic address is legitimate depends on\n+  the section that the address refers to.  On these machines, define the\n+  target hook ``TARGET_ENCODE_SECTION_INFO`` to store the information\n+  into the ``symbol_ref``, and then check for it here.  When you see a\n+  ``const``, you will have to look inside it to find the\n+  ``symbol_ref`` in order to determine the section.  See :ref:`assembler-format`.\n+\n+  .. index:: GO_IF_LEGITIMATE_ADDRESS\n+\n+  Some ports are still using a deprecated legacy substitute for\n+  this hook, the ``GO_IF_LEGITIMATE_ADDRESS`` macro.  This macro\n+  has this syntax:\n+\n+  .. code-block:: c++\n+\n+    #define GO_IF_LEGITIMATE_ADDRESS (mode, x, label)\n+\n+  and should ``goto label`` if the address :samp:`{x}` is a valid\n+  address on the target machine for a memory operand of mode :samp:`{mode}`.\n+\n+  .. index:: REG_OK_STRICT\n+\n+  Compiler source files that want to use the strict variant of this\n+  macro define the macro ``REG_OK_STRICT``.  You should use an\n+  ``#ifdef REG_OK_STRICT`` conditional to define the strict variant in\n+  that case and the non-strict variant otherwise.\n+\n+  Using the hook is usually simpler because it limits the number of\n+  files that are recompiled when changes are made.\n+\n+.. hook-end\n \n .. c:macro:: TARGET_MEM_CONSTRAINT\n \n@@ -87,10 +152,33 @@ This is about addressing modes.\n   The typical use of this macro is to handle addresses containing\n   a label_ref or symbol_ref within an UNSPEC.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_LEGITIMIZE_ADDRESS]\n-  :end-before: [TARGET_LEGITIMIZE_ADDRESS]\n+.. function:: rtx TARGET_LEGITIMIZE_ADDRESS (rtx x, rtx oldx, machine_mode mode)\n \n+  .. hook-start:TARGET_LEGITIMIZE_ADDRESS\n+\n+  This hook is given an invalid memory address :samp:`{x}` for an\n+  operand of mode :samp:`{mode}` and should try to return a valid memory\n+  address.\n+\n+  .. index:: break_out_memory_refs\n+\n+  :samp:`{x}` will always be the result of a call to ``break_out_memory_refs``,\n+  and :samp:`{oldx}` will be the operand that was given to that function to produce\n+  :samp:`{x}`.\n+\n+  The code of the hook should not alter the substructure of\n+  :samp:`{x}`.  If it transforms :samp:`{x}` into a more legitimate form, it\n+  should return the new :samp:`{x}`.\n+\n+  It is not necessary for this hook to come up with a legitimate address,\n+  with the exception of native TLS addresses (see :ref:`emulated-tls`).\n+  The compiler has standard ways of doing so in all cases.  In fact, if\n+  the target supports only emulated TLS, it\n+  is safe to omit this hook or make it return :samp:`{x}` if it cannot find\n+  a valid way to legitimize the address.  But often a machine-dependent\n+  strategy can generate better code.\n+\n+.. hook-end\n \n .. c:macro:: LEGITIMIZE_RELOAD_ADDRESS (x, mode, opnum, type, ind_levels, win)\n \n@@ -148,201 +236,589 @@ This is about addressing modes.\n   It is not necessary for this macro to come up with a legitimate\n   address;  but often a machine-dependent strategy can generate better code.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_MODE_DEPENDENT_ADDRESS_P]\n-  :end-before: [TARGET_MODE_DEPENDENT_ADDRESS_P]\n+.. function:: bool TARGET_MODE_DEPENDENT_ADDRESS_P (const_rtx addr, addr_space_t addrspace)\n+\n+  .. hook-start:TARGET_MODE_DEPENDENT_ADDRESS_P\n+\n+  This hook returns ``true`` if memory address :samp:`{addr}` in address\n+  space :samp:`{addrspace}` can have\n+  different meanings depending on the machine mode of the memory\n+  reference it is used for or if the address is valid for some modes\n+  but not others.\n+\n+  Autoincrement and autodecrement addresses typically have mode-dependent\n+  effects because the amount of the increment or decrement is the size\n+  of the operand being addressed.  Some machines have other mode-dependent\n+  addresses.  Many RISC machines have no mode-dependent addresses.\n+\n+  You may assume that :samp:`{addr}` is a valid address for the machine.\n+\n+  The default version of this hook returns ``false``.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_LEGITIMATE_CONSTANT_P (machine_mode mode, rtx x)\n+\n+  .. hook-start:TARGET_LEGITIMATE_CONSTANT_P\n+\n+  This hook returns true if :samp:`{x}` is a legitimate constant for a\n+  :samp:`{mode}` -mode immediate operand on the target machine.  You can assume that\n+  :samp:`{x}` satisfies ``CONSTANT_P``, so you need not check this.\n+\n+  The default definition returns true.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_PRECOMPUTE_TLS_P (machine_mode mode, rtx x)\n+\n+  .. hook-start:TARGET_PRECOMPUTE_TLS_P\n+\n+  This hook returns true if :samp:`{x}` is a TLS operand on the target\n+  machine that should be pre-computed when used as the argument in a call.\n+  You can assume that :samp:`{x}` satisfies ``CONSTANT_P``, so you need not\n+  check this.\n+\n+  The default definition returns false.\n+\n+.. hook-end\n+\n+.. function:: rtx TARGET_DELEGITIMIZE_ADDRESS (rtx x)\n+\n+  .. hook-start:TARGET_DELEGITIMIZE_ADDRESS\n+\n+  This hook is used to undo the possibly obfuscating effects of the\n+  ``LEGITIMIZE_ADDRESS`` and ``LEGITIMIZE_RELOAD_ADDRESS`` target\n+  macros.  Some backend implementations of these macros wrap symbol\n+  references inside an ``UNSPEC`` rtx to represent PIC or similar\n+  addressing modes.  This target hook allows GCC's optimizers to understand\n+  the semantics of these opaque ``UNSPEC`` s by converting them back\n+  into their original form.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_CONST_NOT_OK_FOR_DEBUG_P (rtx x)\n+\n+  .. hook-start:TARGET_CONST_NOT_OK_FOR_DEBUG_P\n+\n+  This hook should return true if :samp:`{x}` should not be emitted into\n+  debug sections.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_CANNOT_FORCE_CONST_MEM (machine_mode mode, rtx x)\n+\n+  .. hook-start:TARGET_CANNOT_FORCE_CONST_MEM\n+\n+  This hook should return true if :samp:`{x}` is of a form that cannot (or\n+  should not) be spilled to the constant pool.  :samp:`{mode}` is the mode\n+  of :samp:`{x}`.\n+\n+  The default version of this hook returns false.\n+\n+  The primary reason to define this hook is to prevent reload from\n+  deciding that a non-legitimate constant would be better reloaded\n+  from the constant pool instead of spilling and reloading a register\n+  holding the constant.  This restriction is often true of addresses\n+  of TLS symbols for various targets.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_USE_BLOCKS_FOR_CONSTANT_P (machine_mode mode, const_rtx x)\n+\n+  .. hook-start:TARGET_USE_BLOCKS_FOR_CONSTANT_P\n+\n+  This hook should return true if pool entries for constant :samp:`{x}` can\n+  be placed in an ``object_block`` structure.  :samp:`{mode}` is the mode\n+  of :samp:`{x}`.\n+\n+  The default version returns false for all constants.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_USE_BLOCKS_FOR_DECL_P (const_tree decl)\n+\n+  .. hook-start:TARGET_USE_BLOCKS_FOR_DECL_P\n+\n+  This hook should return true if pool entries for :samp:`{decl}` should\n+  be placed in an ``object_block`` structure.\n+\n+  The default version returns true for all decls.\n+\n+.. hook-end\n+\n+.. function:: tree TARGET_BUILTIN_RECIPROCAL (tree fndecl)\n+\n+  .. hook-start:TARGET_BUILTIN_RECIPROCAL\n+\n+  This hook should return the DECL of a function that implements the\n+  reciprocal of the machine-specific builtin function :samp:`{fndecl}`, or\n+  ``NULL_TREE`` if such a function is not available.\n+\n+.. hook-end\n+\n+.. function:: tree TARGET_VECTORIZE_BUILTIN_MASK_FOR_LOAD (void)\n+\n+  .. hook-start:TARGET_VECTORIZE_BUILTIN_MASK_FOR_LOAD\n+\n+  This hook should return the DECL of a function :samp:`{f}` that given an\n+  address :samp:`{addr}` as an argument returns a mask :samp:`{m}` that can be\n+  used to extract from two vectors the relevant data that resides in\n+  :samp:`{addr}` in case :samp:`{addr}` is not properly aligned.\n+\n+  The autovectorizer, when vectorizing a load operation from an address\n+  :samp:`{addr}` that may be unaligned, will generate two vector loads from\n+  the two aligned addresses around :samp:`{addr}`. It then generates a\n+  ``REALIGN_LOAD`` operation to extract the relevant data from the\n+  two loaded vectors. The first two arguments to ``REALIGN_LOAD``,\n+  :samp:`{v1}` and :samp:`{v2}`, are the two vectors, each of size :samp:`{VS}`, and\n+  the third argument, :samp:`{OFF}`, defines how the data will be extracted\n+  from these two vectors: if :samp:`{OFF}` is 0, then the returned vector is\n+  :samp:`{v2}` ; otherwise, the returned vector is composed from the last\n+  :samp:`{VS}` - :samp:`{OFF}` elements of :samp:`{v1}` concatenated to the first\n+  :samp:`{OFF}` elements of :samp:`{v2}`.\n+\n+  If this hook is defined, the autovectorizer will generate a call\n+  to :samp:`{f}` (using the DECL tree that this hook returns) and will\n+  use the return value of :samp:`{f}` as the argument :samp:`{OFF}` to\n+  ``REALIGN_LOAD``. Therefore, the mask :samp:`{m}` returned by :samp:`{f}`\n+  should comply with the semantics expected by ``REALIGN_LOAD``\n+  described above.\n+  If this hook is not defined, then :samp:`{addr}` will be used as\n+  the argument :samp:`{OFF}` to ``REALIGN_LOAD``, in which case the low\n+  log2(:samp:`{VS}`) - 1 bits of :samp:`{addr}` will be considered.\n+\n+.. hook-end\n+\n+.. function:: int TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST (enum vect_cost_for_stmt type_of_cost, tree vectype, int misalign)\n+\n+  .. hook-start:TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST\n+\n+  Returns cost of different scalar or vector statements for vectorization cost model.\n+  For vector memory operations the cost may depend on type (:samp:`{vectype}`) and\n+  misalignment value (:samp:`{misalign}`).\n+\n+.. hook-end\n+\n+.. function:: poly_uint64 TARGET_VECTORIZE_PREFERRED_VECTOR_ALIGNMENT (const_tree type)\n+\n+  .. hook-start:TARGET_VECTORIZE_PREFERRED_VECTOR_ALIGNMENT\n+\n+  This hook returns the preferred alignment in bits for accesses to\n+  vectors of type :samp:`{type}` in vectorized code.  This might be less than\n+  or greater than the ABI-defined value returned by\n+  ``TARGET_VECTOR_ALIGNMENT``.  It can be equal to the alignment of\n+  a single element, in which case the vectorizer will not try to optimize\n+  for alignment.\n+\n+  The default hook returns ``TYPE_ALIGN (type)``, which is\n+  correct for most targets.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_VECTORIZE_VECTOR_ALIGNMENT_REACHABLE (const_tree type, bool is_packed)\n+\n+  .. hook-start:TARGET_VECTORIZE_VECTOR_ALIGNMENT_REACHABLE\n+\n+  Return true if vector alignment is reachable (by peeling N iterations)\n+  for the given scalar type :samp:`{type}`.  :samp:`{is_packed}` is false if the scalar\n+  access using :samp:`{type}` is known to be naturally aligned.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_VECTORIZE_VEC_PERM_CONST (machine_mode mode, machine_mode op_mode, rtx output, rtx in0, rtx in1, const vec_perm_indices &sel)\n+\n+  .. hook-start:TARGET_VECTORIZE_VEC_PERM_CONST\n+\n+  This hook is used to test whether the target can permute up to two\n+  vectors of mode :samp:`{op_mode}` using the permutation vector ``sel``,\n+  producing a vector of mode :samp:`{mode}`.  The hook is also used to emit such\n+  a permutation.\n+\n+  When the hook is being used to test whether the target supports a permutation,\n+  :samp:`{in0}`, :samp:`{in1}`, and :samp:`{out}` are all null.  When the hook is being used\n+  to emit a permutation, :samp:`{in0}` and :samp:`{in1}` are the source vectors of mode\n+  :samp:`{op_mode}` and :samp:`{out}` is the destination vector of mode :samp:`{mode}`.\n+  :samp:`{in1}` is the same as :samp:`{in0}` if :samp:`{sel}` describes a permutation on one\n+  vector instead of two.\n+\n+  Return true if the operation is possible, emitting instructions for it\n+  if rtxes are provided.\n+\n+  .. index:: vec_permm instruction pattern\n+\n+  If the hook returns false for a mode with multibyte elements, GCC will\n+  try the equivalent byte operation.  If that also fails, it will try forcing\n+  the selector into a register and using the :samp:`{vec_perm {mode} }`\n+  instruction pattern.  There is no need for the hook to handle these two\n+  implementation approaches itself.\n+\n+.. hook-end\n+\n+.. function:: tree TARGET_VECTORIZE_BUILTIN_VECTORIZED_FUNCTION (unsigned code, tree vec_type_out, tree vec_type_in)\n+\n+  .. hook-start:TARGET_VECTORIZE_BUILTIN_VECTORIZED_FUNCTION\n+\n+  This hook should return the decl of a function that implements the\n+  vectorized variant of the function with the ``combined_fn`` code\n+  :samp:`{code}` or ``NULL_TREE`` if such a function is not available.\n+  The return type of the vectorized function shall be of vector type\n+  :samp:`{vec_type_out}` and the argument types should be :samp:`{vec_type_in}`.\n+\n+.. hook-end\n+\n+.. function:: tree TARGET_VECTORIZE_BUILTIN_MD_VECTORIZED_FUNCTION (tree fndecl, tree vec_type_out, tree vec_type_in)\n+\n+  .. hook-start:TARGET_VECTORIZE_BUILTIN_MD_VECTORIZED_FUNCTION\n+\n+  This hook should return the decl of a function that implements the\n+  vectorized variant of target built-in function ``fndecl``.  The\n+  return type of the vectorized function shall be of vector type\n+  :samp:`{vec_type_out}` and the argument types should be :samp:`{vec_type_in}`.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_VECTORIZE_SUPPORT_VECTOR_MISALIGNMENT (machine_mode mode, const_tree type, int misalignment, bool is_packed)\n+\n+  .. hook-start:TARGET_VECTORIZE_SUPPORT_VECTOR_MISALIGNMENT\n+\n+  This hook should return true if the target supports misaligned vector\n+  store/load of a specific factor denoted in the :samp:`{misalignment}`\n+  parameter.  The vector store/load should be of machine mode :samp:`{mode}` and\n+  the elements in the vectors should be of type :samp:`{type}`.  :samp:`{is_packed}`\n+  parameter is true if the memory access is defined in a packed struct.\n+\n+.. hook-end\n+\n+.. function:: machine_mode TARGET_VECTORIZE_PREFERRED_SIMD_MODE (scalar_mode mode)\n+\n+  .. hook-start:TARGET_VECTORIZE_PREFERRED_SIMD_MODE\n+\n+  This hook should return the preferred mode for vectorizing scalar\n+  mode :samp:`{mode}`.  The default is\n+  equal to ``word_mode``, because the vectorizer can do some\n+  transformations even in absence of specialized SIMD hardware.\n+\n+.. hook-end\n+\n+.. function:: machine_mode TARGET_VECTORIZE_SPLIT_REDUCTION (machine_mode)\n+\n+  .. hook-start:TARGET_VECTORIZE_SPLIT_REDUCTION\n+\n+  This hook should return the preferred mode to split the final reduction\n+  step on :samp:`{mode}` to.  The reduction is then carried out reducing upper\n+  against lower halves of vectors recursively until the specified mode is\n+  reached.  The default is :samp:`{mode}` which means no splitting.\n+\n+.. hook-end\n+\n+.. function:: unsigned int TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_MODES (vector_modes *modes, bool all)\n+\n+  .. hook-start:TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_MODES\n+\n+  If using the mode returned by ``TARGET_VECTORIZE_PREFERRED_SIMD_MODE``\n+  is not the only approach worth considering, this hook should add one mode to\n+  :samp:`{modes}` for each useful alternative approach.  These modes are then\n+  passed to ``TARGET_VECTORIZE_RELATED_MODE`` to obtain the vector mode\n+  for a given element mode.\n+\n+  The modes returned in :samp:`{modes}` should use the smallest element mode\n+  possible for the vectorization approach that they represent, preferring\n+  integer modes over floating-poing modes in the event of a tie.  The first\n+  mode should be the ``TARGET_VECTORIZE_PREFERRED_SIMD_MODE`` for its\n+  element mode.\n+\n+  If :samp:`{all}` is true, add suitable vector modes even when they are generally\n+  not expected to be worthwhile.\n+\n+  The hook returns a bitmask of flags that control how the modes in\n+  :samp:`{modes}` are used.  The flags are:\n+\n+  .. envvar:: VECT_COMPARE_COSTS\n+\n+    Tells the loop vectorizer to try all the provided modes and pick the one\n+    with the lowest cost.  By default the vectorizer will choose the first\n+    mode that works.\n+\n+  The hook does not need to do anything if the vector returned by\n+  ``TARGET_VECTORIZE_PREFERRED_SIMD_MODE`` is the only one relevant\n+  for autovectorization.  The default implementation adds no modes and\n+  returns 0.\n+\n+.. hook-end\n+\n+.. function:: opt_machine_mode TARGET_VECTORIZE_RELATED_MODE (machine_mode vector_mode, scalar_mode element_mode, poly_uint64 nunits)\n+\n+  .. hook-start:TARGET_VECTORIZE_RELATED_MODE\n+\n+  If a piece of code is using vector mode :samp:`{vector_mode}` and also wants\n+  to operate on elements of mode :samp:`{element_mode}`, return the vector mode\n+  it should use for those elements.  If :samp:`{nunits}` is nonzero, ensure that\n+  the mode has exactly :samp:`{nunits}` elements, otherwise pick whichever vector\n+  size pairs the most naturally with :samp:`{vector_mode}`.  Return an empty\n+  ``opt_machine_mode`` if there is no supported vector mode with the\n+  required properties.\n+\n+  There is no prescribed way of handling the case in which :samp:`{nunits}`\n+  is zero.  One common choice is to pick a vector mode with the same size\n+  as :samp:`{vector_mode}` ; this is the natural choice if the target has a\n+  fixed vector size.  Another option is to choose a vector mode with the\n+  same number of elements as :samp:`{vector_mode}` ; this is the natural choice\n+  if the target has a fixed number of elements.  Alternatively, the hook\n+  might choose a middle ground, such as trying to keep the number of\n+  elements as similar as possible while applying maximum and minimum\n+  vector sizes.\n+\n+  The default implementation uses ``mode_for_vector`` to find the\n+  requested mode, returning a mode with the same size as :samp:`{vector_mode}`\n+  when :samp:`{nunits}` is zero.  This is the correct behavior for most targets.\n+\n+.. hook-end\n+\n+.. function:: opt_machine_mode TARGET_VECTORIZE_GET_MASK_MODE (machine_mode mode)\n+\n+  .. hook-start:TARGET_VECTORIZE_GET_MASK_MODE\n+\n+  Return the mode to use for a vector mask that holds one boolean\n+  result for each element of vector mode :samp:`{mode}`.  The returned mask mode\n+  can be a vector of integers (class ``MODE_VECTOR_INT``), a vector of\n+  booleans (class ``MODE_VECTOR_BOOL``) or a scalar integer (class\n+  ``MODE_INT``).  Return an empty ``opt_machine_mode`` if no such\n+  mask mode exists.\n \n+  The default implementation returns a ``MODE_VECTOR_INT`` with the\n+  same size and number of elements as :samp:`{mode}`, if such a mode exists.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_LEGITIMATE_CONSTANT_P]\n-  :end-before: [TARGET_LEGITIMATE_CONSTANT_P]\n+.. hook-end\n \n+.. function:: bool TARGET_VECTORIZE_EMPTY_MASK_IS_EXPENSIVE (unsigned ifn)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_PRECOMPUTE_TLS_P]\n-  :end-before: [TARGET_PRECOMPUTE_TLS_P]\n+  .. hook-start:TARGET_VECTORIZE_EMPTY_MASK_IS_EXPENSIVE\n \n+  This hook returns true if masked internal function :samp:`{ifn}` (really of\n+  type ``internal_fn``) should be considered expensive when the mask is\n+  all zeros.  GCC can then try to branch around the instruction instead.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_DELEGITIMIZE_ADDRESS]\n-  :end-before: [TARGET_DELEGITIMIZE_ADDRESS]\n+.. hook-end\n \n+.. function:: class vector_costs * TARGET_VECTORIZE_CREATE_COSTS (vec_info *vinfo, bool costing_for_scalar)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_CONST_NOT_OK_FOR_DEBUG_P]\n-  :end-before: [TARGET_CONST_NOT_OK_FOR_DEBUG_P]\n+  .. hook-start:TARGET_VECTORIZE_CREATE_COSTS\n \n+  This hook should initialize target-specific data structures in preparation\n+  for modeling the costs of vectorizing a loop or basic block.  The default\n+  allocates three unsigned integers for accumulating costs for the prologue,\n+  body, and epilogue of the loop or basic block.  If :samp:`{loop_info}` is\n+  non-NULL, it identifies the loop being vectorized; otherwise a single block\n+  is being vectorized.  If :samp:`{costing_for_scalar}` is true, it indicates the\n+  current cost model is for the scalar version of a loop or block; otherwise\n+  it is for the vector version.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_CANNOT_FORCE_CONST_MEM]\n-  :end-before: [TARGET_CANNOT_FORCE_CONST_MEM]\n+.. hook-end\n \n+.. function:: tree TARGET_VECTORIZE_BUILTIN_GATHER (const_tree mem_vectype, const_tree index_type, int scale)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_USE_BLOCKS_FOR_CONSTANT_P]\n-  :end-before: [TARGET_USE_BLOCKS_FOR_CONSTANT_P]\n+  .. hook-start:TARGET_VECTORIZE_BUILTIN_GATHER\n \n+  Target builtin that implements vector gather operation.  :samp:`{mem_vectype}`\n+  is the vector type of the load and :samp:`{index_type}` is scalar type of\n+  the index, scaled by :samp:`{scale}`.\n+  The default is ``NULL_TREE`` which means to not vectorize gather\n+  loads.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_USE_BLOCKS_FOR_DECL_P]\n-  :end-before: [TARGET_USE_BLOCKS_FOR_DECL_P]\n+.. hook-end\n \n+.. function:: tree TARGET_VECTORIZE_BUILTIN_SCATTER (const_tree vectype, const_tree index_type, int scale)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_BUILTIN_RECIPROCAL]\n-  :end-before: [TARGET_BUILTIN_RECIPROCAL]\n+  .. hook-start:TARGET_VECTORIZE_BUILTIN_SCATTER\n \n+  Target builtin that implements vector scatter operation.  :samp:`{vectype}`\n+  is the vector type of the store and :samp:`{index_type}` is scalar type of\n+  the index, scaled by :samp:`{scale}`.\n+  The default is ``NULL_TREE`` which means to not vectorize scatter\n+  stores.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_VECTORIZE_BUILTIN_MASK_FOR_LOAD]\n-  :end-before: [TARGET_VECTORIZE_BUILTIN_MASK_FOR_LOAD]\n+.. hook-end\n \n+.. function:: int TARGET_SIMD_CLONE_COMPUTE_VECSIZE_AND_SIMDLEN (struct cgraph_node *, struct cgraph_simd_clone *, tree, int)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST]\n-  :end-before: [TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST]\n+  .. hook-start:TARGET_SIMD_CLONE_COMPUTE_VECSIZE_AND_SIMDLEN\n \n+  This hook should set :samp:`{vecsize_mangle}`, :samp:`{vecsize_int}`, :samp:`{vecsize_float}`\n+  fields in :samp:`{simd_clone}` structure pointed by :samp:`{clone_info}` argument and also\n+  :samp:`{simdlen}` field if it was previously 0.\n+  :samp:`{vecsize_mangle}` is a marker for the backend only. :samp:`{vecsize_int}` and\n+  :samp:`{vecsize_float}` should be left zero on targets where the number of lanes is\n+  not determined by the bitsize (in which case :samp:`{simdlen}` is always used).\n+  The hook should return 0 if SIMD clones shouldn't be emitted,\n+  or number of :samp:`{vecsize_mangle}` variants that should be emitted.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_VECTORIZE_PREFERRED_VECTOR_ALIGNMENT]\n-  :end-before: [TARGET_VECTORIZE_PREFERRED_VECTOR_ALIGNMENT]\n+.. hook-end\n \n+.. function:: void TARGET_SIMD_CLONE_ADJUST (struct cgraph_node *)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_VECTORIZE_VECTOR_ALIGNMENT_REACHABLE]\n-  :end-before: [TARGET_VECTORIZE_VECTOR_ALIGNMENT_REACHABLE]\n+  .. hook-start:TARGET_SIMD_CLONE_ADJUST\n \n+  This hook should add implicit ``attribute(target(\"...\"))`` attribute\n+  to SIMD clone :samp:`{node}` if needed.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_VECTORIZE_VEC_PERM_CONST]\n-  :end-before: [TARGET_VECTORIZE_VEC_PERM_CONST]\n+.. hook-end\n \n+.. function:: int TARGET_SIMD_CLONE_USABLE (struct cgraph_node *)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_VECTORIZE_BUILTIN_VECTORIZED_FUNCTION]\n-  :end-before: [TARGET_VECTORIZE_BUILTIN_VECTORIZED_FUNCTION]\n+  .. hook-start:TARGET_SIMD_CLONE_USABLE\n \n+  This hook should return -1 if SIMD clone :samp:`{node}` shouldn't be used\n+  in vectorized loops in current function, or non-negative number if it is\n+  usable.  In that case, the smaller the number is, the more desirable it is\n+  to use it.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_VECTORIZE_BUILTIN_MD_VECTORIZED_FUNCTION]\n-  :end-before: [TARGET_VECTORIZE_BUILTIN_MD_VECTORIZED_FUNCTION]\n+.. hook-end\n \n+.. function:: int TARGET_SIMT_VF (void)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_VECTORIZE_SUPPORT_VECTOR_MISALIGNMENT]\n-  :end-before: [TARGET_VECTORIZE_SUPPORT_VECTOR_MISALIGNMENT]\n+  .. hook-start:TARGET_SIMT_VF\n \n+  Return number of threads in SIMT thread group on the target.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_VECTORIZE_PREFERRED_SIMD_MODE]\n-  :end-before: [TARGET_VECTORIZE_PREFERRED_SIMD_MODE]\n+.. hook-end\n \n+.. function:: int TARGET_OMP_DEVICE_KIND_ARCH_ISA (enum omp_device_kind_arch_isa trait, const char *name)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_VECTORIZE_SPLIT_REDUCTION]\n-  :end-before: [TARGET_VECTORIZE_SPLIT_REDUCTION]\n+  .. hook-start:TARGET_OMP_DEVICE_KIND_ARCH_ISA\n \n+  Return 1 if :samp:`{trait}` :samp:`{name}` is present in the OpenMP context's\n+  device trait set, return 0 if not present in any OpenMP context in the\n+  whole translation unit, or -1 if not present in the current OpenMP context\n+  but might be present in another OpenMP context in the same TU.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_MODES]\n-  :end-before: [TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_MODES]\n+.. hook-end\n \n+.. function:: bool TARGET_GOACC_VALIDATE_DIMS (tree decl, int *dims, int fn_level, unsigned used)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_VECTORIZE_RELATED_MODE]\n-  :end-before: [TARGET_VECTORIZE_RELATED_MODE]\n+  .. hook-start:TARGET_GOACC_VALIDATE_DIMS\n \n+  This hook should check the launch dimensions provided for an OpenACC\n+  compute region, or routine.  Defaulted values are represented as -1\n+  and non-constant values as 0.  The :samp:`{fn_level}` is negative for the\n+  function corresponding to the compute region.  For a routine it is the\n+  outermost level at which partitioned execution may be spawned.  The hook\n+  should verify non-default values.  If DECL is NULL, global defaults\n+  are being validated and unspecified defaults should be filled in.\n+  Diagnostics should be issued as appropriate.  Return\n+  true, if changes have been made.  You must override this hook to\n+  provide dimensions larger than 1.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_VECTORIZE_GET_MASK_MODE]\n-  :end-before: [TARGET_VECTORIZE_GET_MASK_MODE]\n+.. hook-end\n \n+.. function:: int TARGET_GOACC_DIM_LIMIT (int axis)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_VECTORIZE_EMPTY_MASK_IS_EXPENSIVE]\n-  :end-before: [TARGET_VECTORIZE_EMPTY_MASK_IS_EXPENSIVE]\n+  .. hook-start:TARGET_GOACC_DIM_LIMIT\n \n+  This hook should return the maximum size of a particular dimension,\n+  or zero if unbounded.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_VECTORIZE_CREATE_COSTS]\n-  :end-before: [TARGET_VECTORIZE_CREATE_COSTS]\n+.. hook-end\n \n+.. function:: bool TARGET_GOACC_FORK_JOIN (gcall *call, const int *dims, bool is_fork)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_VECTORIZE_BUILTIN_GATHER]\n-  :end-before: [TARGET_VECTORIZE_BUILTIN_GATHER]\n+  .. hook-start:TARGET_GOACC_FORK_JOIN\n \n+  This hook can be used to convert IFN_GOACC_FORK and IFN_GOACC_JOIN\n+  function calls to target-specific gimple, or indicate whether they\n+  should be retained.  It is executed during the oacc_device_lower pass.\n+  It should return true, if the call should be retained.  It should\n+  return false, if it is to be deleted (either because target-specific\n+  gimple has been inserted before it, or there is no need for it).\n+  The default hook returns false, if there are no RTL expanders for them.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_VECTORIZE_BUILTIN_SCATTER]\n-  :end-before: [TARGET_VECTORIZE_BUILTIN_SCATTER]\n+.. hook-end\n \n+.. function:: void TARGET_GOACC_REDUCTION (gcall *call)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SIMD_CLONE_COMPUTE_VECSIZE_AND_SIMDLEN]\n-  :end-before: [TARGET_SIMD_CLONE_COMPUTE_VECSIZE_AND_SIMDLEN]\n+  .. hook-start:TARGET_GOACC_REDUCTION\n \n+  This hook is used by the oacc_transform pass to expand calls to the\n+  :samp:`{GOACC_REDUCTION}` internal function, into a sequence of gimple\n+  instructions.  :samp:`{call}` is gimple statement containing the call to\n+  the function.  This hook removes statement :samp:`{call}` after the\n+  expanded sequence has been inserted.  This hook is also responsible\n+  for allocating any storage for reductions when necessary.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SIMD_CLONE_ADJUST]\n-  :end-before: [TARGET_SIMD_CLONE_ADJUST]\n+.. hook-end\n \n+.. function:: tree TARGET_PREFERRED_ELSE_VALUE (unsigned ifn, tree type, unsigned nops, tree *ops)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SIMD_CLONE_USABLE]\n-  :end-before: [TARGET_SIMD_CLONE_USABLE]\n+  .. hook-start:TARGET_PREFERRED_ELSE_VALUE\n \n+  This hook returns the target's preferred final argument for a call\n+  to conditional internal function :samp:`{ifn}` (really of type\n+  ``internal_fn``).  :samp:`{type}` specifies the return type of the\n+  function and :samp:`{ops}` are the operands to the conditional operation,\n+  of which there are :samp:`{nops}`.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SIMT_VF]\n-  :end-before: [TARGET_SIMT_VF]\n+  For example, if :samp:`{ifn}` is ``IFN_COND_ADD``, the hook returns\n+  a value of type :samp:`{type}` that should be used when :samp:`{ops}[0]`\n+  and :samp:`{ops}[1]` are conditionally added together.\n \n+  This hook is only relevant if the target supports conditional patterns\n+  like ``cond_addm``.  The default implementation returns a zero\n+  constant of type :samp:`{type}`.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_OMP_DEVICE_KIND_ARCH_ISA]\n-  :end-before: [TARGET_OMP_DEVICE_KIND_ARCH_ISA]\n+.. hook-end\n \n+.. function:: tree TARGET_GOACC_ADJUST_PRIVATE_DECL (location_t loc, tree var, int level)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_GOACC_VALIDATE_DIMS]\n-  :end-before: [TARGET_GOACC_VALIDATE_DIMS]\n+  .. hook-start:TARGET_GOACC_ADJUST_PRIVATE_DECL\n \n+  This hook, if defined, is used by accelerator target back-ends to adjust\n+  OpenACC variable declarations that should be made private to the given\n+  parallelism level (i.e. ``GOMP_DIM_GANG``, ``GOMP_DIM_WORKER`` or\n+  ``GOMP_DIM_VECTOR``).  A typical use for this hook is to force variable\n+  declarations at the ``gang`` level to reside in GPU shared memory.\n+  :samp:`{loc}` may be used for diagnostic purposes.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_GOACC_DIM_LIMIT]\n-  :end-before: [TARGET_GOACC_DIM_LIMIT]\n+  You may also use the ``TARGET_GOACC_EXPAND_VAR_DECL`` hook if the\n+  adjusted variable declaration needs to be expanded to RTL in a non-standard\n+  way.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_GOACC_FORK_JOIN]\n-  :end-before: [TARGET_GOACC_FORK_JOIN]\n+.. function:: rtx TARGET_GOACC_EXPAND_VAR_DECL (tree var)\n \n+  .. hook-start:TARGET_GOACC_EXPAND_VAR_DECL\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_GOACC_REDUCTION]\n-  :end-before: [TARGET_GOACC_REDUCTION]\n+  This hook, if defined, is used by accelerator target back-ends to expand\n+  specially handled kinds of ``VAR_DECL`` expressions.  A particular use is\n+  to place variables with specific attributes inside special accelarator\n+  memories.  A return value of ``NULL`` indicates that the target does not\n+  handle this ``VAR_DECL``, and normal RTL expanding is resumed.\n \n+  Only define this hook if your accelerator target needs to expand certain\n+  ``VAR_DECL`` nodes in a way that differs from the default.  You can also adjust\n+  private variables at OpenACC device-lowering time using the\n+  ``TARGET_GOACC_ADJUST_PRIVATE_DECL`` target hook.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_PREFERRED_ELSE_VALUE]\n-  :end-before: [TARGET_PREFERRED_ELSE_VALUE]\n+.. hook-end\n \n+.. function:: tree TARGET_GOACC_CREATE_WORKER_BROADCAST_RECORD (tree rec, bool sender, const char *name, unsigned HOST_WIDE_INT offset)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_GOACC_ADJUST_PRIVATE_DECL]\n-  :end-before: [TARGET_GOACC_ADJUST_PRIVATE_DECL]\n+  .. hook-start:TARGET_GOACC_CREATE_WORKER_BROADCAST_RECORD\n \n+  Create a record used to propagate local-variable state from an active\n+  worker to other workers.  A possible implementation might adjust the type\n+  of REC to place the new variable in shared GPU memory.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_GOACC_EXPAND_VAR_DECL]\n-  :end-before: [TARGET_GOACC_EXPAND_VAR_DECL]\n+  Presence of this target hook indicates that middle end neutering/broadcasting\n+  be used.\n+.. hook-end\n \n+.. function:: void TARGET_GOACC_SHARED_MEM_LAYOUT (unsigned HOST_WIDE_INT *, unsigned HOST_WIDE_INT *, int[], unsigned HOST_WIDE_INT[], unsigned HOST_WIDE_INT[])\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_GOACC_CREATE_WORKER_BROADCAST_RECORD]\n-  :end-before: [TARGET_GOACC_CREATE_WORKER_BROADCAST_RECORD]\n+  .. hook-start:TARGET_GOACC_SHARED_MEM_LAYOUT\n \n+  Lay out a fixed shared-memory region on the target.  The LO and HI\n+  arguments should be set to a range of addresses that can be used for worker\n+  broadcasting. The dimensions, reduction size and gang-private size\n+  arguments are for the current offload region.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_GOACC_SHARED_MEM_LAYOUT]\n-  :end-before: [TARGET_GOACC_SHARED_MEM_LAYOUT]\n+.. hook-end\n\\ No newline at end of file"}, {"sha": "0c12d7ad24ba5ceeccbfe9701bb9258efda3d70a", "filename": "gcc/doc/gccint/target-macros/adjusting-the-instruction-scheduler.rst", "status": "modified", "additions": 553, "deletions": 141, "changes": 694, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fadjusting-the-instruction-scheduler.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fadjusting-the-instruction-scheduler.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fadjusting-the-instruction-scheduler.rst?ref=3e070cff11f81051e70b613816075b66a6de61c2", "patch": "@@ -13,236 +13,648 @@ adjustment in order to produce good code.  GCC provides several target\n hooks for this purpose.  It is usually enough to define just a few of\n them: try the first ones in this list first.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SCHED_ISSUE_RATE]\n-  :end-before: [TARGET_SCHED_ISSUE_RATE]\n+.. function:: int TARGET_SCHED_ISSUE_RATE (void)\n+\n+  .. hook-start:TARGET_SCHED_ISSUE_RATE\n+\n+  This hook returns the maximum number of instructions that can ever\n+  issue at the same time on the target machine.  The default is one.\n+  Although the insn scheduler can define itself the possibility of issue\n+  an insn on the same cycle, the value can serve as an additional\n+  constraint to issue insns on the same simulated processor cycle (see\n+  hooks :samp:`TARGET_SCHED_REORDER` and :samp:`TARGET_SCHED_REORDER2`).\n+  This value must be constant over the entire compilation.  If you need\n+  it to vary depending on what the instructions are, you must use\n+  :samp:`TARGET_SCHED_VARIABLE_ISSUE`.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SCHED_VARIABLE_ISSUE]\n-  :end-before: [TARGET_SCHED_VARIABLE_ISSUE]\n+.. function:: int TARGET_SCHED_VARIABLE_ISSUE (FILE *file, int verbose, rtx_insn *insn, int more)\n \n+  .. hook-start:TARGET_SCHED_VARIABLE_ISSUE\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SCHED_ADJUST_COST]\n-  :end-before: [TARGET_SCHED_ADJUST_COST]\n+  This hook is executed by the scheduler after it has scheduled an insn\n+  from the ready list.  It should return the number of insns which can\n+  still be issued in the current cycle.  The default is\n+  :samp:`{more} - 1` for insns other than ``CLOBBER`` and\n+  ``USE``, which normally are not counted against the issue rate.\n+  You should define this hook if some insns take more machine resources\n+  than others, so that fewer insns can follow them in the same cycle.\n+  :samp:`{file}` is either a null pointer, or a stdio stream to write any\n+  debug output to.  :samp:`{verbose}` is the verbose level provided by\n+  :option:`-fsched-verbose-n`.  :samp:`{insn}` is the instruction that\n+  was scheduled.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SCHED_ADJUST_PRIORITY]\n-  :end-before: [TARGET_SCHED_ADJUST_PRIORITY]\n+.. function:: int TARGET_SCHED_ADJUST_COST (rtx_insn *insn, int dep_type1, rtx_insn *dep_insn, int cost, unsigned int dw)\n \n+  .. hook-start:TARGET_SCHED_ADJUST_COST\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SCHED_REORDER]\n-  :end-before: [TARGET_SCHED_REORDER]\n+  This function corrects the value of :samp:`{cost}` based on the\n+  relationship between :samp:`{insn}` and :samp:`{dep_insn}` through a\n+  dependence of type dep_type, and strength :samp:`{dw}`.  It should return the new\n+  value.  The default is to make no adjustment to :samp:`{cost}`.  This can be\n+  used for example to specify to the scheduler using the traditional pipeline\n+  description that an output- or anti-dependence does not incur the same cost\n+  as a data-dependence.  If the scheduler using the automaton based pipeline\n+  description, the cost of anti-dependence is zero and the cost of\n+  output-dependence is maximum of one and the difference of latency\n+  times of the first and the second insns.  If these values are not\n+  acceptable, you could use the hook to modify them too.  See also\n+  see :ref:`processor-pipeline-description`.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SCHED_REORDER2]\n-  :end-before: [TARGET_SCHED_REORDER2]\n+.. function:: int TARGET_SCHED_ADJUST_PRIORITY (rtx_insn *insn, int priority)\n \n+  .. hook-start:TARGET_SCHED_ADJUST_PRIORITY\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SCHED_MACRO_FUSION_P]\n-  :end-before: [TARGET_SCHED_MACRO_FUSION_P]\n+  This hook adjusts the integer scheduling priority :samp:`{priority}` of\n+  :samp:`{insn}`.  It should return the new priority.  Increase the priority to\n+  execute :samp:`{insn}` earlier, reduce the priority to execute :samp:`{insn}`\n+  later.  Do not define this hook if you do not need to adjust the\n+  scheduling priorities of insns.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SCHED_MACRO_FUSION_PAIR_P]\n-  :end-before: [TARGET_SCHED_MACRO_FUSION_PAIR_P]\n+.. function:: int TARGET_SCHED_REORDER (FILE *file, int verbose, rtx_insn **ready, int *n_readyp, int clock)\n \n+  .. hook-start:TARGET_SCHED_REORDER\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SCHED_DEPENDENCIES_EVALUATION_HOOK]\n-  :end-before: [TARGET_SCHED_DEPENDENCIES_EVALUATION_HOOK]\n+  This hook is executed by the scheduler after it has scheduled the ready\n+  list, to allow the machine description to reorder it (for example to\n+  combine two small instructions together on :samp:`VLIW` machines).\n+  :samp:`{file}` is either a null pointer, or a stdio stream to write any\n+  debug output to.  :samp:`{verbose}` is the verbose level provided by\n+  :option:`-fsched-verbose-n`.  :samp:`{ready}` is a pointer to the ready\n+  list of instructions that are ready to be scheduled.  :samp:`{n_readyp}` is\n+  a pointer to the number of elements in the ready list.  The scheduler\n+  reads the ready list in reverse order, starting with\n+  :samp:`{ready}` [ :samp:`{*n_readyp}` - 1] and going to :samp:`{ready}` [0].  :samp:`{clock}`\n+  is the timer tick of the scheduler.  You may modify the ready list and\n+  the number of ready insns.  The return value is the number of insns that\n+  can issue this cycle; normally this is just ``issue_rate``.  See also\n+  :samp:`TARGET_SCHED_REORDER2`.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SCHED_INIT]\n-  :end-before: [TARGET_SCHED_INIT]\n+.. function:: int TARGET_SCHED_REORDER2 (FILE *file, int verbose, rtx_insn **ready, int *n_readyp, int clock)\n \n+  .. hook-start:TARGET_SCHED_REORDER2\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SCHED_FINISH]\n-  :end-before: [TARGET_SCHED_FINISH]\n+  Like :samp:`TARGET_SCHED_REORDER`, but called at a different time.  That\n+  function is called whenever the scheduler starts a new cycle.  This one\n+  is called once per iteration over a cycle, immediately after\n+  :samp:`TARGET_SCHED_VARIABLE_ISSUE`; it can reorder the ready list and\n+  return the number of insns to be scheduled in the same cycle.  Defining\n+  this hook can be useful if there are frequent situations where\n+  scheduling one insn causes other insns to become ready in the same\n+  cycle.  These other insns can then be taken into account properly.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SCHED_INIT_GLOBAL]\n-  :end-before: [TARGET_SCHED_INIT_GLOBAL]\n+.. function:: bool TARGET_SCHED_MACRO_FUSION_P (void)\n \n+  .. hook-start:TARGET_SCHED_MACRO_FUSION_P\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SCHED_FINISH_GLOBAL]\n-  :end-before: [TARGET_SCHED_FINISH_GLOBAL]\n+  This hook is used to check whether target platform supports macro fusion.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SCHED_DFA_PRE_CYCLE_INSN]\n-  :end-before: [TARGET_SCHED_DFA_PRE_CYCLE_INSN]\n+.. function:: bool TARGET_SCHED_MACRO_FUSION_PAIR_P (rtx_insn *prev, rtx_insn *curr)\n \n+  .. hook-start:TARGET_SCHED_MACRO_FUSION_PAIR_P\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SCHED_INIT_DFA_PRE_CYCLE_INSN]\n-  :end-before: [TARGET_SCHED_INIT_DFA_PRE_CYCLE_INSN]\n+  This hook is used to check whether two insns should be macro fused for\n+  a target microarchitecture. If this hook returns true for the given insn pair\n+  (:samp:`{prev}` and :samp:`{curr}`), the scheduler will put them into a sched\n+  group, and they will not be scheduled apart.  The two insns will be either\n+  two SET insns or a compare and a conditional jump and this hook should\n+  validate any dependencies needed to fuse the two insns together.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SCHED_DFA_POST_CYCLE_INSN]\n-  :end-before: [TARGET_SCHED_DFA_POST_CYCLE_INSN]\n+.. function:: void TARGET_SCHED_DEPENDENCIES_EVALUATION_HOOK (rtx_insn *head, rtx_insn *tail)\n \n+  .. hook-start:TARGET_SCHED_DEPENDENCIES_EVALUATION_HOOK\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SCHED_INIT_DFA_POST_CYCLE_INSN]\n-  :end-before: [TARGET_SCHED_INIT_DFA_POST_CYCLE_INSN]\n+  This hook is called after evaluation forward dependencies of insns in\n+  chain given by two parameter values (:samp:`{head}` and :samp:`{tail}`\n+  correspondingly) but before insns scheduling of the insn chain.  For\n+  example, it can be used for better insn classification if it requires\n+  analysis of dependencies.  This hook can use backward and forward\n+  dependencies of the insn scheduler because they are already\n+  calculated.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SCHED_DFA_PRE_ADVANCE_CYCLE]\n-  :end-before: [TARGET_SCHED_DFA_PRE_ADVANCE_CYCLE]\n+.. function:: void TARGET_SCHED_INIT (FILE *file, int verbose, int max_ready)\n \n+  .. hook-start:TARGET_SCHED_INIT\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SCHED_DFA_POST_ADVANCE_CYCLE]\n-  :end-before: [TARGET_SCHED_DFA_POST_ADVANCE_CYCLE]\n+  This hook is executed by the scheduler at the beginning of each block of\n+  instructions that are to be scheduled.  :samp:`{file}` is either a null\n+  pointer, or a stdio stream to write any debug output to.  :samp:`{verbose}`\n+  is the verbose level provided by :option:`-fsched-verbose-n`.\n+  :samp:`{max_ready}` is the maximum number of insns in the current scheduling\n+  region that can be live at the same time.  This can be used to allocate\n+  scratch space if it is needed, e.g. by :samp:`TARGET_SCHED_REORDER`.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD]\n-  :end-before: [TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD]\n+.. function:: void TARGET_SCHED_FINISH (FILE *file, int verbose)\n \n+  .. hook-start:TARGET_SCHED_FINISH\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD]\n-  :end-before: [TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD]\n+  This hook is executed by the scheduler at the end of each block of\n+  instructions that are to be scheduled.  It can be used to perform\n+  cleanup of any actions done by the other scheduling hooks.  :samp:`{file}`\n+  is either a null pointer, or a stdio stream to write any debug output\n+  to.  :samp:`{verbose}` is the verbose level provided by\n+  :option:`-fsched-verbose-n`.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SCHED_FIRST_CYCLE_MULTIPASS_BEGIN]\n-  :end-before: [TARGET_SCHED_FIRST_CYCLE_MULTIPASS_BEGIN]\n+.. function:: void TARGET_SCHED_INIT_GLOBAL (FILE *file, int verbose, int old_max_uid)\n \n+  .. hook-start:TARGET_SCHED_INIT_GLOBAL\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SCHED_FIRST_CYCLE_MULTIPASS_ISSUE]\n-  :end-before: [TARGET_SCHED_FIRST_CYCLE_MULTIPASS_ISSUE]\n+  This hook is executed by the scheduler after function level initializations.\n+  :samp:`{file}` is either a null pointer, or a stdio stream to write any debug output to.\n+  :samp:`{verbose}` is the verbose level provided by :option:`-fsched-verbose-n`.\n+  :samp:`{old_max_uid}` is the maximum insn uid when scheduling begins.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SCHED_FIRST_CYCLE_MULTIPASS_BACKTRACK]\n-  :end-before: [TARGET_SCHED_FIRST_CYCLE_MULTIPASS_BACKTRACK]\n+.. function:: void TARGET_SCHED_FINISH_GLOBAL (FILE *file, int verbose)\n \n+  .. hook-start:TARGET_SCHED_FINISH_GLOBAL\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SCHED_FIRST_CYCLE_MULTIPASS_END]\n-  :end-before: [TARGET_SCHED_FIRST_CYCLE_MULTIPASS_END]\n+  This is the cleanup hook corresponding to ``TARGET_SCHED_INIT_GLOBAL``.\n+  :samp:`{file}` is either a null pointer, or a stdio stream to write any debug output to.\n+  :samp:`{verbose}` is the verbose level provided by :option:`-fsched-verbose-n`.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SCHED_FIRST_CYCLE_MULTIPASS_INIT]\n-  :end-before: [TARGET_SCHED_FIRST_CYCLE_MULTIPASS_INIT]\n+.. function:: rtx TARGET_SCHED_DFA_PRE_CYCLE_INSN (void)\n \n+  .. hook-start:TARGET_SCHED_DFA_PRE_CYCLE_INSN\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SCHED_FIRST_CYCLE_MULTIPASS_FINI]\n-  :end-before: [TARGET_SCHED_FIRST_CYCLE_MULTIPASS_FINI]\n+  The hook returns an RTL insn.  The automaton state used in the\n+  pipeline hazard recognizer is changed as if the insn were scheduled\n+  when the new simulated processor cycle starts.  Usage of the hook may\n+  simplify the automaton pipeline description for some VLIW\n+  processors.  If the hook is defined, it is used only for the automaton\n+  based pipeline description.  The default is not to change the state\n+  when the new simulated processor cycle starts.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SCHED_DFA_NEW_CYCLE]\n-  :end-before: [TARGET_SCHED_DFA_NEW_CYCLE]\n+.. function:: void TARGET_SCHED_INIT_DFA_PRE_CYCLE_INSN (void)\n \n+  .. hook-start:TARGET_SCHED_INIT_DFA_PRE_CYCLE_INSN\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SCHED_IS_COSTLY_DEPENDENCE]\n-  :end-before: [TARGET_SCHED_IS_COSTLY_DEPENDENCE]\n+  The hook can be used to initialize data used by the previous hook.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SCHED_H_I_D_EXTENDED]\n-  :end-before: [TARGET_SCHED_H_I_D_EXTENDED]\n+.. function:: rtx_insn * TARGET_SCHED_DFA_POST_CYCLE_INSN (void)\n \n+  .. hook-start:TARGET_SCHED_DFA_POST_CYCLE_INSN\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SCHED_ALLOC_SCHED_CONTEXT]\n-  :end-before: [TARGET_SCHED_ALLOC_SCHED_CONTEXT]\n+  The hook is analogous to :samp:`TARGET_SCHED_DFA_PRE_CYCLE_INSN` but used\n+  to changed the state as if the insn were scheduled when the new\n+  simulated processor cycle finishes.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SCHED_INIT_SCHED_CONTEXT]\n-  :end-before: [TARGET_SCHED_INIT_SCHED_CONTEXT]\n+.. function:: void TARGET_SCHED_INIT_DFA_POST_CYCLE_INSN (void)\n \n+  .. hook-start:TARGET_SCHED_INIT_DFA_POST_CYCLE_INSN\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SCHED_SET_SCHED_CONTEXT]\n-  :end-before: [TARGET_SCHED_SET_SCHED_CONTEXT]\n+  The hook is analogous to :samp:`TARGET_SCHED_INIT_DFA_PRE_CYCLE_INSN` but\n+  used to initialize data used by the previous hook.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SCHED_CLEAR_SCHED_CONTEXT]\n-  :end-before: [TARGET_SCHED_CLEAR_SCHED_CONTEXT]\n+.. function:: void TARGET_SCHED_DFA_PRE_ADVANCE_CYCLE (void)\n \n+  .. hook-start:TARGET_SCHED_DFA_PRE_ADVANCE_CYCLE\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SCHED_FREE_SCHED_CONTEXT]\n-  :end-before: [TARGET_SCHED_FREE_SCHED_CONTEXT]\n+  The hook to notify target that the current simulated cycle is about to finish.\n+  The hook is analogous to :samp:`TARGET_SCHED_DFA_PRE_CYCLE_INSN` but used\n+  to change the state in more complicated situations - e.g., when advancing\n+  state on a single insn is not enough.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SCHED_SPECULATE_INSN]\n-  :end-before: [TARGET_SCHED_SPECULATE_INSN]\n+.. function:: void TARGET_SCHED_DFA_POST_ADVANCE_CYCLE (void)\n \n+  .. hook-start:TARGET_SCHED_DFA_POST_ADVANCE_CYCLE\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SCHED_NEEDS_BLOCK_P]\n-  :end-before: [TARGET_SCHED_NEEDS_BLOCK_P]\n+  The hook to notify target that new simulated cycle has just started.\n+  The hook is analogous to :samp:`TARGET_SCHED_DFA_POST_CYCLE_INSN` but used\n+  to change the state in more complicated situations - e.g., when advancing\n+  state on a single insn is not enough.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SCHED_GEN_SPEC_CHECK]\n-  :end-before: [TARGET_SCHED_GEN_SPEC_CHECK]\n+.. function:: int TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD (void)\n \n+  .. hook-start:TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SCHED_SET_SCHED_FLAGS]\n-  :end-before: [TARGET_SCHED_SET_SCHED_FLAGS]\n+  This hook controls better choosing an insn from the ready insn queue\n+  for the DFA-based insn scheduler.  Usually the scheduler\n+  chooses the first insn from the queue.  If the hook returns a positive\n+  value, an additional scheduler code tries all permutations of\n+  :samp:`TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD ()`\n+  subsequent ready insns to choose an insn whose issue will result in\n+  maximal number of issued insns on the same cycle.  For the\n+  VLIW processor, the code could actually solve the problem of\n+  packing simple insns into the VLIW insn.  Of course, if the\n+  rules of VLIW packing are described in the automaton.\n \n+  This code also could be used for superscalar RISC\n+  processors.  Let us consider a superscalar RISC processor\n+  with 3 pipelines.  Some insns can be executed in pipelines :samp:`{A}` or\n+  :samp:`{B}`, some insns can be executed only in pipelines :samp:`{B}` or\n+  :samp:`{C}`, and one insn can be executed in pipeline :samp:`{B}`.  The\n+  processor may issue the 1st insn into :samp:`{A}` and the 2nd one into\n+  :samp:`{B}`.  In this case, the 3rd insn will wait for freeing :samp:`{B}`\n+  until the next cycle.  If the scheduler issues the 3rd insn the first,\n+  the processor could issue all 3 insns per cycle.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SCHED_CAN_SPECULATE_INSN]\n-  :end-before: [TARGET_SCHED_CAN_SPECULATE_INSN]\n+  Actually this code demonstrates advantages of the automaton based\n+  pipeline hazard recognizer.  We try quickly and easy many insn\n+  schedules to choose the best one.\n \n+  The default is no multipass scheduling.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SCHED_SMS_RES_MII]\n-  :end-before: [TARGET_SCHED_SMS_RES_MII]\n+.. hook-end\n \n+.. function:: int TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD (rtx_insn *insn, int ready_index)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SCHED_DISPATCH]\n-  :end-before: [TARGET_SCHED_DISPATCH]\n+  .. hook-start:TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD\n \n+  This hook controls what insns from the ready insn queue will be\n+  considered for the multipass insn scheduling.  If the hook returns\n+  zero for :samp:`{insn}`, the insn will be considered in multipass scheduling.\n+  Positive return values will remove :samp:`{insn}` from consideration on\n+  the current round of multipass scheduling.\n+  Negative return values will remove :samp:`{insn}` from consideration for given\n+  number of cycles.\n+  Backends should be careful about returning non-zero for highest priority\n+  instruction at position 0 in the ready list.  :samp:`{ready_index}` is passed\n+  to allow backends make correct judgements.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SCHED_DISPATCH_DO]\n-  :end-before: [TARGET_SCHED_DISPATCH_DO]\n+  The default is that any ready insns can be chosen to be issued.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SCHED_EXPOSED_PIPELINE]\n-  :end-before: [TARGET_SCHED_EXPOSED_PIPELINE]\n+.. function:: void TARGET_SCHED_FIRST_CYCLE_MULTIPASS_BEGIN (void *data, signed char *ready_try, int n_ready, bool first_cycle_insn_p)\n \n+  .. hook-start:TARGET_SCHED_FIRST_CYCLE_MULTIPASS_BEGIN\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SCHED_REASSOCIATION_WIDTH]\n-  :end-before: [TARGET_SCHED_REASSOCIATION_WIDTH]\n+  This hook prepares the target backend for a new round of multipass\n+  scheduling.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SCHED_FUSION_PRIORITY]\n-  :end-before: [TARGET_SCHED_FUSION_PRIORITY]\n+.. function:: void TARGET_SCHED_FIRST_CYCLE_MULTIPASS_ISSUE (void *data, signed char *ready_try, int n_ready, rtx_insn *insn, const void *prev_data)\n \n+  .. hook-start:TARGET_SCHED_FIRST_CYCLE_MULTIPASS_ISSUE\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_EXPAND_DIVMOD_LIBFUNC]\n-  :end-before: [TARGET_EXPAND_DIVMOD_LIBFUNC]\n+  This hook is called when multipass scheduling evaluates instruction INSN.\n+\n+.. hook-end\n+\n+.. function:: void TARGET_SCHED_FIRST_CYCLE_MULTIPASS_BACKTRACK (const void *data, signed char *ready_try, int n_ready)\n+\n+  .. hook-start:TARGET_SCHED_FIRST_CYCLE_MULTIPASS_BACKTRACK\n+\n+  This is called when multipass scheduling backtracks from evaluation of\n+  an instruction.\n+\n+.. hook-end\n+\n+.. function:: void TARGET_SCHED_FIRST_CYCLE_MULTIPASS_END (const void *data)\n+\n+  .. hook-start:TARGET_SCHED_FIRST_CYCLE_MULTIPASS_END\n+\n+  This hook notifies the target about the result of the concluded current\n+  round of multipass scheduling.\n+\n+.. hook-end\n+\n+.. function:: void TARGET_SCHED_FIRST_CYCLE_MULTIPASS_INIT (void *data)\n+\n+  .. hook-start:TARGET_SCHED_FIRST_CYCLE_MULTIPASS_INIT\n+\n+  This hook initializes target-specific data used in multipass scheduling.\n+\n+.. hook-end\n+\n+.. function:: void TARGET_SCHED_FIRST_CYCLE_MULTIPASS_FINI (void *data)\n+\n+  .. hook-start:TARGET_SCHED_FIRST_CYCLE_MULTIPASS_FINI\n+\n+  This hook finalizes target-specific data used in multipass scheduling.\n+\n+.. hook-end\n+\n+.. function:: int TARGET_SCHED_DFA_NEW_CYCLE (FILE *dump, int verbose, rtx_insn *insn, int last_clock, int clock, int *sort_p)\n+\n+  .. hook-start:TARGET_SCHED_DFA_NEW_CYCLE\n+\n+  This hook is called by the insn scheduler before issuing :samp:`{insn}`\n+  on cycle :samp:`{clock}`.  If the hook returns nonzero,\n+  :samp:`{insn}` is not issued on this processor cycle.  Instead,\n+  the processor cycle is advanced.  If \\* :samp:`{sort_p}`\n+  is zero, the insn ready queue is not sorted on the new cycle\n+  start as usually.  :samp:`{dump}` and :samp:`{verbose}` specify the file and\n+  verbosity level to use for debugging output.\n+  :samp:`{last_clock}` and :samp:`{clock}` are, respectively, the\n+  processor cycle on which the previous insn has been issued,\n+  and the current processor cycle.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_SCHED_IS_COSTLY_DEPENDENCE (struct _dep *_dep, int cost, int distance)\n+\n+  .. hook-start:TARGET_SCHED_IS_COSTLY_DEPENDENCE\n+\n+  This hook is used to define which dependences are considered costly by\n+  the target, so costly that it is not advisable to schedule the insns that\n+  are involved in the dependence too close to one another.  The parameters\n+  to this hook are as follows:  The first parameter :samp:`{_dep}` is the dependence\n+  being evaluated.  The second parameter :samp:`{cost}` is the cost of the\n+  dependence as estimated by the scheduler, and the third\n+  parameter :samp:`{distance}` is the distance in cycles between the two insns.\n+  The hook returns ``true`` if considering the distance between the two\n+  insns the dependence between them is considered costly by the target,\n+  and ``false`` otherwise.\n+\n+  Defining this hook can be useful in multiple-issue out-of-order machines,\n+  where (a) it's practically hopeless to predict the actual data/resource\n+  delays, however: (b) there's a better chance to predict the actual grouping\n+  that will be formed, and (c) correctly emulating the grouping can be very\n+  important.  In such targets one may want to allow issuing dependent insns\n+  closer to one another---i.e., closer than the dependence distance;  however,\n+  not in cases of 'costly dependences', which this hooks allows to define.\n+\n+.. hook-end\n+\n+.. function:: void TARGET_SCHED_H_I_D_EXTENDED (void)\n+\n+  .. hook-start:TARGET_SCHED_H_I_D_EXTENDED\n+\n+  This hook is called by the insn scheduler after emitting a new instruction to\n+  the instruction stream.  The hook notifies a target backend to extend its\n+  per instruction data structures.\n+\n+.. hook-end\n+\n+.. function:: void * TARGET_SCHED_ALLOC_SCHED_CONTEXT (void)\n+\n+  .. hook-start:TARGET_SCHED_ALLOC_SCHED_CONTEXT\n+\n+  Return a pointer to a store large enough to hold target scheduling context.\n+\n+.. hook-end\n+\n+.. function:: void TARGET_SCHED_INIT_SCHED_CONTEXT (void *tc, bool clean_p)\n+\n+  .. hook-start:TARGET_SCHED_INIT_SCHED_CONTEXT\n+\n+  Initialize store pointed to by :samp:`{tc}` to hold target scheduling context.\n+  It :samp:`{clean_p}` is true then initialize :samp:`{tc}` as if scheduler is at the\n+  beginning of the block.  Otherwise, copy the current context into :samp:`{tc}`.\n+\n+.. hook-end\n+\n+.. function:: void TARGET_SCHED_SET_SCHED_CONTEXT (void *tc)\n+\n+  .. hook-start:TARGET_SCHED_SET_SCHED_CONTEXT\n+\n+  Copy target scheduling context pointed to by :samp:`{tc}` to the current context.\n+\n+.. hook-end\n+\n+.. function:: void TARGET_SCHED_CLEAR_SCHED_CONTEXT (void *tc)\n+\n+  .. hook-start:TARGET_SCHED_CLEAR_SCHED_CONTEXT\n+\n+  Deallocate internal data in target scheduling context pointed to by :samp:`{tc}`.\n+\n+.. hook-end\n+\n+.. function:: void TARGET_SCHED_FREE_SCHED_CONTEXT (void *tc)\n+\n+  .. hook-start:TARGET_SCHED_FREE_SCHED_CONTEXT\n+\n+  Deallocate a store for target scheduling context pointed to by :samp:`{tc}`.\n+\n+.. hook-end\n+\n+.. function:: int TARGET_SCHED_SPECULATE_INSN (rtx_insn *insn, unsigned int dep_status, rtx *new_pat)\n+\n+  .. hook-start:TARGET_SCHED_SPECULATE_INSN\n+\n+  This hook is called by the insn scheduler when :samp:`{insn}` has only\n+  speculative dependencies and therefore can be scheduled speculatively.\n+  The hook is used to check if the pattern of :samp:`{insn}` has a speculative\n+  version and, in case of successful check, to generate that speculative\n+  pattern.  The hook should return 1, if the instruction has a speculative form,\n+  or -1, if it doesn't.  :samp:`{request}` describes the type of requested\n+  speculation.  If the return value equals 1 then :samp:`{new_pat}` is assigned\n+  the generated speculative pattern.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_SCHED_NEEDS_BLOCK_P (unsigned int dep_status)\n+\n+  .. hook-start:TARGET_SCHED_NEEDS_BLOCK_P\n+\n+  This hook is called by the insn scheduler during generation of recovery code\n+  for :samp:`{insn}`.  It should return ``true``, if the corresponding check\n+  instruction should branch to recovery code, or ``false`` otherwise.\n+\n+.. hook-end\n+\n+.. function:: rtx TARGET_SCHED_GEN_SPEC_CHECK (rtx_insn *insn, rtx_insn *label, unsigned int ds)\n+\n+  .. hook-start:TARGET_SCHED_GEN_SPEC_CHECK\n+\n+  This hook is called by the insn scheduler to generate a pattern for recovery\n+  check instruction.  If :samp:`{mutate_p}` is zero, then :samp:`{insn}` is a\n+  speculative instruction for which the check should be generated.\n+  :samp:`{label}` is either a label of a basic block, where recovery code should\n+  be emitted, or a null pointer, when requested check doesn't branch to\n+  recovery code (a simple check).  If :samp:`{mutate_p}` is nonzero, then\n+  a pattern for a branchy check corresponding to a simple check denoted by\n+  :samp:`{insn}` should be generated.  In this case :samp:`{label}` can't be null.\n+\n+.. hook-end\n+\n+.. function:: void TARGET_SCHED_SET_SCHED_FLAGS (struct spec_info_def *spec_info)\n+\n+  .. hook-start:TARGET_SCHED_SET_SCHED_FLAGS\n+\n+  This hook is used by the insn scheduler to find out what features should be\n+  enabled/used.\n+  The structure \\* :samp:`{spec_info}` should be filled in by the target.\n+  The structure describes speculation types that can be used in the scheduler.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_SCHED_CAN_SPECULATE_INSN (rtx_insn *insn)\n+\n+  .. hook-start:TARGET_SCHED_CAN_SPECULATE_INSN\n+\n+  Some instructions should never be speculated by the schedulers, usually\n+  because the instruction is too expensive to get this wrong.  Often such\n+  instructions have long latency, and often they are not fully modeled in the\n+  pipeline descriptions.  This hook should return ``false`` if :samp:`{insn}`\n+  should not be speculated.\n+\n+.. hook-end\n+\n+.. function:: int TARGET_SCHED_SMS_RES_MII (struct ddg *g)\n+\n+  .. hook-start:TARGET_SCHED_SMS_RES_MII\n+\n+  This hook is called by the swing modulo scheduler to calculate a\n+  resource-based lower bound which is based on the resources available in\n+  the machine and the resources required by each instruction.  The target\n+  backend can use :samp:`{g}` to calculate such bound.  A very simple lower\n+  bound will be used in case this hook is not implemented: the total number\n+  of instructions divided by the issue rate.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_SCHED_DISPATCH (rtx_insn *insn, int x)\n+\n+  .. hook-start:TARGET_SCHED_DISPATCH\n+\n+  This hook is called by Haifa Scheduler.  It returns true if dispatch scheduling\n+  is supported in hardware and the condition specified in the parameter is true.\n+\n+.. hook-end\n+\n+.. function:: void TARGET_SCHED_DISPATCH_DO (rtx_insn *insn, int x)\n+\n+  .. hook-start:TARGET_SCHED_DISPATCH_DO\n+\n+  This hook is called by Haifa Scheduler.  It performs the operation specified\n+  in its second parameter.\n+\n+.. hook-end\n+\n+.. c:var:: bool TARGET_SCHED_EXPOSED_PIPELINE\n+\n+  .. hook-start:TARGET_SCHED_EXPOSED_PIPELINE\n+\n+  True if the processor has an exposed pipeline, which means that not just\n+  the order of instructions is important for correctness when scheduling, but\n+  also the latencies of operations.\n+\n+.. hook-end\n+\n+.. function:: int TARGET_SCHED_REASSOCIATION_WIDTH (unsigned int opc, machine_mode mode)\n+\n+  .. hook-start:TARGET_SCHED_REASSOCIATION_WIDTH\n+\n+  This hook is called by tree reassociator to determine a level of\n+  parallelism required in output calculations chain.\n+\n+.. hook-end\n+\n+.. function:: void TARGET_SCHED_FUSION_PRIORITY (rtx_insn *insn, int max_pri, int *fusion_pri, int *pri)\n+\n+  .. hook-start:TARGET_SCHED_FUSION_PRIORITY\n+\n+  This hook is called by scheduling fusion pass.  It calculates fusion\n+  priorities for each instruction passed in by parameter.  The priorities\n+  are returned via pointer parameters.\n+\n+  :samp:`{insn}` is the instruction whose priorities need to be calculated.\n+  :samp:`{max_pri}` is the maximum priority can be returned in any cases.\n+  :samp:`{fusion_pri}` is the pointer parameter through which :samp:`{insn}` 's\n+  fusion priority should be calculated and returned.\n+  :samp:`{pri}` is the pointer parameter through which :samp:`{insn}` 's priority\n+  should be calculated and returned.\n+\n+  Same :samp:`{fusion_pri}` should be returned for instructions which should\n+  be scheduled together.  Different :samp:`{pri}` should be returned for\n+  instructions with same :samp:`{fusion_pri}`.  :samp:`{fusion_pri}` is the major\n+  sort key, :samp:`{pri}` is the minor sort key.  All instructions will be\n+  scheduled according to the two priorities.  All priorities calculated\n+  should be between 0 (exclusive) and :samp:`{max_pri}` (inclusive).  To avoid\n+  false dependencies, :samp:`{fusion_pri}` of instructions which need to be\n+  scheduled together should be smaller than :samp:`{fusion_pri}` of irrelevant\n+  instructions.\n+\n+  Given below example:\n+\n+  .. code-block:: c++\n+\n+        ldr r10, [r1, 4]\n+        add r4, r4, r10\n+        ldr r15, [r2, 8]\n+        sub r5, r5, r15\n+        ldr r11, [r1, 0]\n+        add r4, r4, r11\n+        ldr r16, [r2, 12]\n+        sub r5, r5, r16\n+\n+  On targets like ARM/AArch64, the two pairs of consecutive loads should be\n+  merged.  Since peephole2 pass can't help in this case unless consecutive\n+  loads are actually next to each other in instruction flow.  That's where\n+  this scheduling fusion pass works.  This hook calculates priority for each\n+  instruction based on its fustion type, like:\n+\n+  .. code-block:: c++\n+\n+        ldr r10, [r1, 4]  ; fusion_pri=99,  pri=96\n+        add r4, r4, r10   ; fusion_pri=100, pri=100\n+        ldr r15, [r2, 8]  ; fusion_pri=98,  pri=92\n+        sub r5, r5, r15   ; fusion_pri=100, pri=100\n+        ldr r11, [r1, 0]  ; fusion_pri=99,  pri=100\n+        add r4, r4, r11   ; fusion_pri=100, pri=100\n+        ldr r16, [r2, 12] ; fusion_pri=98,  pri=88\n+        sub r5, r5, r16   ; fusion_pri=100, pri=100\n+\n+  Scheduling fusion pass then sorts all ready to issue instructions according\n+  to the priorities.  As a result, instructions of same fusion type will be\n+  pushed together in instruction flow, like:\n+\n+  .. code-block:: c++\n+\n+        ldr r11, [r1, 0]\n+        ldr r10, [r1, 4]\n+        ldr r15, [r2, 8]\n+        ldr r16, [r2, 12]\n+        add r4, r4, r10\n+        sub r5, r5, r15\n+        add r4, r4, r11\n+        sub r5, r5, r16\n+\n+  Now peephole2 pass can simply merge the two pairs of loads.\n+\n+  Since scheduling fusion pass relies on peephole2 to do real fusion\n+  work, it is only enabled by default when peephole2 is in effect.\n+\n+  This is firstly introduced on ARM/AArch64 targets, please refer to\n+  the hook implementation for how different fusion types are supported.\n+\n+.. hook-end\n+\n+.. function:: void TARGET_EXPAND_DIVMOD_LIBFUNC (rtx libfunc, machine_mode mode, rtx op0, rtx op1, rtx *quot, rtx *rem)\n+\n+  .. hook-start:TARGET_EXPAND_DIVMOD_LIBFUNC\n+\n+  Define this hook for enabling divmod transform if the port does not have\n+  hardware divmod insn but defines target-specific divmod libfuncs.\n+\n+.. hook-end\n\\ No newline at end of file"}, {"sha": "52f588a3ca02eb814c742cc60f6ac8df17d88f12", "filename": "gcc/doc/gccint/target-macros/anchored-addresses.rst", "status": "modified", "additions": 44, "deletions": 12, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fanchored-addresses.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fanchored-addresses.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fanchored-addresses.rst?ref=3e070cff11f81051e70b613816075b66a6de61c2", "patch": "@@ -40,21 +40,53 @@ in order to make effective use of section anchors.  It won't use\n section anchors at all unless either ``TARGET_MIN_ANCHOR_OFFSET``\n or ``TARGET_MAX_ANCHOR_OFFSET`` is set to a nonzero value.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_MIN_ANCHOR_OFFSET]\n-  :end-before: [TARGET_MIN_ANCHOR_OFFSET]\n+.. c:var:: HOST_WIDE_INT TARGET_MIN_ANCHOR_OFFSET\n \n+  .. hook-start:TARGET_MIN_ANCHOR_OFFSET\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_MAX_ANCHOR_OFFSET]\n-  :end-before: [TARGET_MAX_ANCHOR_OFFSET]\n+  The minimum offset that should be applied to a section anchor.\n+  On most targets, it should be the smallest offset that can be\n+  applied to a base register while still giving a legitimate address\n+  for every mode.  The default value is 0.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_ASM_OUTPUT_ANCHOR]\n-  :end-before: [TARGET_ASM_OUTPUT_ANCHOR]\n+.. c:var:: HOST_WIDE_INT TARGET_MAX_ANCHOR_OFFSET\n \n+  .. hook-start:TARGET_MAX_ANCHOR_OFFSET\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_USE_ANCHORS_FOR_SYMBOL_P]\n-  :end-before: [TARGET_USE_ANCHORS_FOR_SYMBOL_P]\n+  Like ``TARGET_MIN_ANCHOR_OFFSET``, but the maximum (inclusive)\n+  offset that should be applied to section anchors.  The default\n+  value is 0.\n+\n+.. hook-end\n+\n+.. function:: void TARGET_ASM_OUTPUT_ANCHOR (rtx x)\n+\n+  .. hook-start:TARGET_ASM_OUTPUT_ANCHOR\n+\n+  Write the assembly code to define section anchor :samp:`{x}`, which is a\n+  ``SYMBOL_REF`` for which :samp:`SYMBOL_REF_ANCHOR_P ({x})` is true.\n+  The hook is called with the assembly output position set to the beginning\n+  of ``SYMBOL_REF_BLOCK (x)``.\n+\n+  If ``ASM_OUTPUT_DEF`` is available, the hook's default definition uses\n+  it to define the symbol as :samp:`. + SYMBOL_REF_BLOCK_OFFSET ({x})`.\n+  If ``ASM_OUTPUT_DEF`` is not available, the hook's default definition\n+  is ``NULL``, which disables the use of section anchors altogether.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_USE_ANCHORS_FOR_SYMBOL_P (const_rtx x)\n+\n+  .. hook-start:TARGET_USE_ANCHORS_FOR_SYMBOL_P\n+\n+  Return true if GCC should attempt to use anchors to access ``SYMBOL_REF``\n+  :samp:`{x}`.  You can assume :samp:`SYMBOL_REF_HAS_BLOCK_INFO_P ({x})` and\n+  :samp:`!SYMBOL_REF_ANCHOR_P ({x})`.\n+\n+  The default version is correct for most targets, but you might need to\n+  intercept this hook to handle things like target-specific attributes\n+  or target-specific sections.\n+\n+.. hook-end\n\\ No newline at end of file"}, {"sha": "4dd9f67a2ea6da0c773910f846abcdcc1883a07e", "filename": "gcc/doc/gccint/target-macros/c++-abi-parameters.rst", "status": "modified", "additions": 126, "deletions": 42, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fc%2B%2B-abi-parameters.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fc%2B%2B-abi-parameters.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fc%2B%2B-abi-parameters.rst?ref=3e070cff11f81051e70b613816075b66a6de61c2", "patch": "@@ -10,71 +10,155 @@\n C++ ABI parameters\n ******************\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_CXX_GUARD_TYPE]\n-  :end-before: [TARGET_CXX_GUARD_TYPE]\n+.. function:: tree TARGET_CXX_GUARD_TYPE (void)\n \n+  .. hook-start:TARGET_CXX_GUARD_TYPE\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_CXX_GUARD_MASK_BIT]\n-  :end-before: [TARGET_CXX_GUARD_MASK_BIT]\n+  Define this hook to override the integer type used for guard variables.\n+  These are used to implement one-time construction of static objects.  The\n+  default is long_long_integer_type_node.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_CXX_GET_COOKIE_SIZE]\n-  :end-before: [TARGET_CXX_GET_COOKIE_SIZE]\n+.. function:: bool TARGET_CXX_GUARD_MASK_BIT (void)\n \n+  .. hook-start:TARGET_CXX_GUARD_MASK_BIT\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_CXX_COOKIE_HAS_SIZE]\n-  :end-before: [TARGET_CXX_COOKIE_HAS_SIZE]\n+  This hook determines how guard variables are used.  It should return\n+  ``false`` (the default) if the first byte should be used.  A return value of\n+  ``true`` indicates that only the least significant bit should be used.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_CXX_IMPORT_EXPORT_CLASS]\n-  :end-before: [TARGET_CXX_IMPORT_EXPORT_CLASS]\n+.. function:: tree TARGET_CXX_GET_COOKIE_SIZE (tree type)\n \n+  .. hook-start:TARGET_CXX_GET_COOKIE_SIZE\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_CXX_CDTOR_RETURNS_THIS]\n-  :end-before: [TARGET_CXX_CDTOR_RETURNS_THIS]\n+  This hook returns the size of the cookie to use when allocating an array\n+  whose elements have the indicated :samp:`{type}`.  Assumes that it is already\n+  known that a cookie is needed.  The default is\n+  ``max(sizeof (size_t), alignof(type))``, as defined in section 2.7 of the\n+  IA64/Generic C++ ABI.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_CXX_KEY_METHOD_MAY_BE_INLINE]\n-  :end-before: [TARGET_CXX_KEY_METHOD_MAY_BE_INLINE]\n+.. function:: bool TARGET_CXX_COOKIE_HAS_SIZE (void)\n \n+  .. hook-start:TARGET_CXX_COOKIE_HAS_SIZE\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_CXX_DETERMINE_CLASS_DATA_VISIBILITY]\n-  :end-before: [TARGET_CXX_DETERMINE_CLASS_DATA_VISIBILITY]\n+  This hook should return ``true`` if the element size should be stored in\n+  array cookies.  The default is to return ``false``.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_CXX_CLASS_DATA_ALWAYS_COMDAT]\n-  :end-before: [TARGET_CXX_CLASS_DATA_ALWAYS_COMDAT]\n+.. function:: int TARGET_CXX_IMPORT_EXPORT_CLASS (tree type, int import_export)\n \n+  .. hook-start:TARGET_CXX_IMPORT_EXPORT_CLASS\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_CXX_LIBRARY_RTTI_COMDAT]\n-  :end-before: [TARGET_CXX_LIBRARY_RTTI_COMDAT]\n+  If defined by a backend this hook allows the decision made to export\n+  class :samp:`{type}` to be overruled.  Upon entry :samp:`{import_export}`\n+  will contain 1 if the class is going to be exported, -1 if it is going\n+  to be imported and 0 otherwise.  This function should return the\n+  modified value and perform any other actions necessary to support the\n+  backend's targeted operating system.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_CXX_USE_AEABI_ATEXIT]\n-  :end-before: [TARGET_CXX_USE_AEABI_ATEXIT]\n+.. function:: bool TARGET_CXX_CDTOR_RETURNS_THIS (void)\n \n+  .. hook-start:TARGET_CXX_CDTOR_RETURNS_THIS\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_CXX_USE_ATEXIT_FOR_CXA_ATEXIT]\n-  :end-before: [TARGET_CXX_USE_ATEXIT_FOR_CXA_ATEXIT]\n+  This hook should return ``true`` if constructors and destructors return\n+  the address of the object created/destroyed.  The default is to return\n+  ``false``.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_CXX_ADJUST_CLASS_AT_DEFINITION]\n-  :end-before: [TARGET_CXX_ADJUST_CLASS_AT_DEFINITION]\n+.. function:: bool TARGET_CXX_KEY_METHOD_MAY_BE_INLINE (void)\n \n+  .. hook-start:TARGET_CXX_KEY_METHOD_MAY_BE_INLINE\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_CXX_DECL_MANGLING_CONTEXT]\n-  :end-before: [TARGET_CXX_DECL_MANGLING_CONTEXT]\n+  This hook returns true if the key method for a class (i.e., the method\n+  which, if defined in the current translation unit, causes the virtual\n+  table to be emitted) may be an inline function.  Under the standard\n+  Itanium C++ ABI the key method may be an inline function so long as\n+  the function is not declared inline in the class definition.  Under\n+  some variants of the ABI, an inline function can never be the key\n+  method.  The default is to return ``true``.\n+\n+.. hook-end\n+\n+.. function:: void TARGET_CXX_DETERMINE_CLASS_DATA_VISIBILITY (tree decl)\n+\n+  .. hook-start:TARGET_CXX_DETERMINE_CLASS_DATA_VISIBILITY\n+\n+  :samp:`{decl}` is a virtual table, virtual table table, typeinfo object,\n+  or other similar implicit class data object that will be emitted with\n+  external linkage in this translation unit.  No ELF visibility has been\n+  explicitly specified.  If the target needs to specify a visibility\n+  other than that of the containing class, use this hook to set\n+  ``DECL_VISIBILITY`` and ``DECL_VISIBILITY_SPECIFIED``.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_CXX_CLASS_DATA_ALWAYS_COMDAT (void)\n+\n+  .. hook-start:TARGET_CXX_CLASS_DATA_ALWAYS_COMDAT\n+\n+  This hook returns true (the default) if virtual tables and other\n+  similar implicit class data objects are always COMDAT if they have\n+  external linkage.  If this hook returns false, then class data for\n+  classes whose virtual table will be emitted in only one translation\n+  unit will not be COMDAT.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_CXX_LIBRARY_RTTI_COMDAT (void)\n+\n+  .. hook-start:TARGET_CXX_LIBRARY_RTTI_COMDAT\n+\n+  This hook returns true (the default) if the RTTI information for\n+  the basic types which is defined in the C++ runtime should always\n+  be COMDAT, false if it should not be COMDAT.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_CXX_USE_AEABI_ATEXIT (void)\n+\n+  .. hook-start:TARGET_CXX_USE_AEABI_ATEXIT\n+\n+  This hook returns true if ``__aeabi_atexit`` (as defined by the ARM EABI)\n+  should be used to register static destructors when :option:`-fuse-cxa-atexit`\n+  is in effect.  The default is to return false to use ``__cxa_atexit``.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_CXX_USE_ATEXIT_FOR_CXA_ATEXIT (void)\n+\n+  .. hook-start:TARGET_CXX_USE_ATEXIT_FOR_CXA_ATEXIT\n+\n+  This hook returns true if the target ``atexit`` function can be used\n+  in the same manner as ``__cxa_atexit`` to register C++ static\n+  destructors. This requires that ``atexit`` -registered functions in\n+  shared libraries are run in the correct order when the libraries are\n+  unloaded. The default is to return false.\n+\n+.. hook-end\n+\n+.. function:: void TARGET_CXX_ADJUST_CLASS_AT_DEFINITION (tree type)\n+\n+  .. hook-start:TARGET_CXX_ADJUST_CLASS_AT_DEFINITION\n+\n+  :samp:`{type}` is a C++ class (i.e., RECORD_TYPE or UNION_TYPE) that has just\n+  been defined.  Use this hook to make adjustments to the class (eg, tweak\n+  visibility or perform any other required target modifications).\n+\n+.. hook-end\n+\n+.. function:: tree TARGET_CXX_DECL_MANGLING_CONTEXT (const_tree decl)\n+\n+  .. hook-start:TARGET_CXX_DECL_MANGLING_CONTEXT\n+\n+  Return target-specific mangling context of :samp:`{decl}` or ``NULL_TREE``.\n+\n+.. hook-end\n\\ No newline at end of file"}, {"sha": "e62de9dc7b5c1b09fe074665fa05f83761f158a9", "filename": "gcc/doc/gccint/target-macros/condition-code-status.rst", "status": "modified", "additions": 65, "deletions": 12, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fcondition-code-status.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fcondition-code-status.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fcondition-code-status.rst?ref=3e070cff11f81051e70b613816075b66a6de61c2", "patch": "@@ -104,10 +104,31 @@ Representation of condition codes using registers\n   You should define this macro if and only if you define extra CC modes\n   in :samp:`{machine}-modes.def`.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_CANONICALIZE_COMPARISON]\n-  :end-before: [TARGET_CANONICALIZE_COMPARISON]\n+.. function:: void TARGET_CANONICALIZE_COMPARISON (int *code, rtx *op0, rtx *op1, bool op0_preserve_value)\n \n+  .. hook-start:TARGET_CANONICALIZE_COMPARISON\n+\n+  On some machines not all possible comparisons are defined, but you can\n+  convert an invalid comparison into a valid one.  For example, the Alpha\n+  does not have a ``GT`` comparison, but you can use an ``LT``\n+  comparison instead and swap the order of the operands.\n+\n+  On such machines, implement this hook to do any required conversions.\n+  :samp:`{code}` is the initial comparison code and :samp:`{op0}` and :samp:`{op1}`\n+  are the left and right operands of the comparison, respectively.  If\n+  :samp:`{op0_preserve_value}` is ``true`` the implementation is not\n+  allowed to change the value of :samp:`{op0}` since the value might be used\n+  in RTXs which aren't comparisons.  E.g. the implementation is not\n+  allowed to swap operands in that case.\n+\n+  GCC will not assume that the comparison resulting from this macro is\n+  valid but will see if the resulting insn matches a pattern in the\n+  :samp:`md` file.\n+\n+  You need not to implement this hook if it would never change the\n+  comparison code or operands.\n+\n+.. hook-end\n \n .. c:macro:: REVERSIBLE_CC_MODE (mode)\n \n@@ -142,16 +163,48 @@ Representation of condition codes using registers\n        ((MODE) != CCFPmode ? reverse_condition (CODE) \\\n         : reverse_condition_maybe_unordered (CODE))\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_FIXED_CONDITION_CODE_REGS]\n-  :end-before: [TARGET_FIXED_CONDITION_CODE_REGS]\n+.. function:: bool TARGET_FIXED_CONDITION_CODE_REGS (unsigned int *p1, unsigned int *p2)\n+\n+  .. hook-start:TARGET_FIXED_CONDITION_CODE_REGS\n+\n+  On targets which use a hard\n+  register rather than a pseudo-register to hold condition codes, the\n+  regular CSE passes are often not able to identify cases in which the\n+  hard register is set to a common value.  Use this hook to enable a\n+  small pass which optimizes such cases.  This hook should return true\n+  to enable this pass, and it should set the integers to which its\n+  arguments point to the hard register numbers used for condition codes.\n+  When there is only one such register, as is true on most systems, the\n+  integer pointed to by :samp:`{p2}` should be set to\n+  ``INVALID_REGNUM``.\n+\n+  The default version of this hook returns false.\n+\n+.. hook-end\n+\n+.. function:: machine_mode TARGET_CC_MODES_COMPATIBLE (machine_mode m1, machine_mode m2)\n+\n+  .. hook-start:TARGET_CC_MODES_COMPATIBLE\n+\n+  On targets which use multiple condition code modes in class\n+  ``MODE_CC``, it is sometimes the case that a comparison can be\n+  validly done in more than one mode.  On such a system, define this\n+  target hook to take two mode arguments and to return a mode in which\n+  both comparisons may be validly done.  If there is no such mode,\n+  return ``VOIDmode``.\n+\n+  The default version of this hook checks whether the modes are the\n+  same.  If they are, it returns that mode.  If they are different, it\n+  returns ``VOIDmode``.\n+\n+.. hook-end\n \n+.. c:var:: unsigned int TARGET_FLAGS_REGNUM\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_CC_MODES_COMPATIBLE]\n-  :end-before: [TARGET_CC_MODES_COMPATIBLE]\n+  .. hook-start:TARGET_FLAGS_REGNUM\n \n+  If the target has a dedicated flags register, and it needs to use the\n+  post-reload comparison elimination pass, or the delay slot filler pass,\n+  then this value should be set appropriately.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_FLAGS_REGNUM]\n-  :end-before: [TARGET_FLAGS_REGNUM]\n+.. hook-end\n\\ No newline at end of file"}, {"sha": "e1eb465ea07cebf2f78b1ac4fd295b644bffb492", "filename": "gcc/doc/gccint/target-macros/controlling-debugging-information-format.rst", "status": "modified", "additions": 78, "deletions": 24, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fcontrolling-debugging-information-format.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fcontrolling-debugging-information-format.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fcontrolling-debugging-information-format.rst?ref=3e070cff11f81051e70b613816075b66a6de61c2", "patch": "@@ -103,10 +103,15 @@ Here are macros for DWARF output.\n   prologue, or call ``dwarf2out_def_cfa`` and ``dwarf2out_reg_save``\n   as appropriate from ``TARGET_ASM_FUNCTION_PROLOGUE`` if you don't.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_DWARF_CALLING_CONVENTION]\n-  :end-before: [TARGET_DWARF_CALLING_CONVENTION]\n+.. function:: int TARGET_DWARF_CALLING_CONVENTION (const_tree function)\n+\n+    .. hook-start:TARGET_DWARF_CALLING_CONVENTION\n+\n+    Define this to enable the dwarf attribute ``DW_AT_calling_convention`` to\n+    be emitted for each function.  Instead of an integer return the enum\n+    value for the ``DW_CC_`` tag.\n \n+.. hook-end\n \n .. function:: int TARGET_DWARF_CALLING_CONVENTION (const_tree function)\n \n@@ -122,10 +127,22 @@ Here are macros for DWARF output.\n   exceptions are enabled, GCC will output this information not matter\n   how you define ``DWARF2_FRAME_INFO``.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_DEBUG_UNWIND_INFO]\n-  :end-before: [TARGET_DEBUG_UNWIND_INFO]\n+.. function:: enum unwind_info_type TARGET_DEBUG_UNWIND_INFO (void)\n+\n+  .. hook-start:TARGET_DEBUG_UNWIND_INFO\n+\n+  This hook defines the mechanism that will be used for describing frame\n+  unwind information to the debugger.  Normally the hook will return\n+  ``UI_DWARF2`` if DWARF 2 debug information is enabled, and\n+  return ``UI_NONE`` otherwise.\n+\n+  A target may return ``UI_DWARF2`` even when DWARF 2 debug information\n+  is disabled in order to always output DWARF 2 frame information.\n \n+  A target may return ``UI_TARGET`` if it has ABI specified unwind tables.\n+  This will suppress generation of the normal debug frame unwind information.\n+\n+.. hook-end\n \n .. c:macro:: DWARF2_ASM_LINE_DEBUG_INFO\n \n@@ -140,30 +157,63 @@ Here are macros for DWARF output.\n   user enables location views, the compiler may have to fallback to\n   internal line number tables.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_RESET_LOCATION_VIEW]\n-  :end-before: [TARGET_RESET_LOCATION_VIEW]\n+.. function:: int TARGET_RESET_LOCATION_VIEW (rtx_insn *)\n+\n+  .. hook-start:TARGET_RESET_LOCATION_VIEW\n+\n+  This hook, if defined, enables -ginternal-reset-location-views, and\n+  uses its result to override cases in which the estimated min insn\n+  length might be nonzero even when a PC advance (i.e., a view reset)\n+  cannot be taken for granted.\n+\n+  If the hook is defined, it must return a positive value to indicate\n+  the insn definitely advances the PC, and so the view number can be\n+  safely assumed to be reset; a negative value to mean the insn\n+  definitely does not advance the PC, and os the view number must not\n+  be reset; or zero to decide based on the estimated insn length.\n+\n+  If insn length is to be regarded as reliable, set the hook to\n+  ``hook_int_rtx_insn_0``.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_WANT_DEBUG_PUB_SECTIONS]\n-  :end-before: [TARGET_WANT_DEBUG_PUB_SECTIONS]\n+.. c:var:: bool TARGET_WANT_DEBUG_PUB_SECTIONS\n \n+  .. hook-start:TARGET_WANT_DEBUG_PUB_SECTIONS\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_DELAY_SCHED2]\n-  :end-before: [TARGET_DELAY_SCHED2]\n+  True if the ``.debug_pubtypes`` and ``.debug_pubnames`` sections\n+  should be emitted.  These sections are not used on most platforms, and\n+  in particular GDB does not use them.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_DELAY_VARTRACK]\n-  :end-before: [TARGET_DELAY_VARTRACK]\n+.. c:var:: bool TARGET_DELAY_SCHED2\n \n+  .. hook-start:TARGET_DELAY_SCHED2\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_NO_REGISTER_ALLOCATION]\n-  :end-before: [TARGET_NO_REGISTER_ALLOCATION]\n+  True if sched2 is not to be run at its normal place.\n+  This usually means it will be run as part of machine-specific reorg.\n \n+.. hook-end\n+\n+.. c:var:: bool TARGET_DELAY_VARTRACK\n+\n+  .. hook-start:TARGET_DELAY_VARTRACK\n+\n+  True if vartrack is not to be run at its normal place.\n+  This usually means it will be run as part of machine-specific reorg.\n+\n+.. hook-end\n+\n+.. c:var:: bool TARGET_NO_REGISTER_ALLOCATION\n+\n+  .. hook-start:TARGET_NO_REGISTER_ALLOCATION\n+\n+  True if register allocation and the passes\n+  following it should not be run.  Usually true only for virtual assembler\n+  targets.\n+\n+.. hook-end\n \n .. c:macro:: ASM_OUTPUT_DWARF_DELTA (stream, size, label1, label2)\n \n@@ -200,10 +250,14 @@ Here are macros for DWARF output.\n   is used on some systems to avoid garbage collecting a DWARF table which\n   is referenced by a function.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_ASM_OUTPUT_DWARF_DTPREL]\n-  :end-before: [TARGET_ASM_OUTPUT_DWARF_DTPREL]\n+.. function:: void TARGET_ASM_OUTPUT_DWARF_DTPREL (FILE *file, int size, rtx x)\n+\n+  .. hook-start:TARGET_ASM_OUTPUT_DWARF_DTPREL\n+\n+  If defined, this target hook is a function which outputs a DTP-relative\n+  reference to the given TLS symbol of the specified size.\n \n+.. hook-end\n \n .. _vms-debug:\n "}, {"sha": "9a201c7eaa71bd28e62bcba305ee0b84e55c4985", "filename": "gcc/doc/gccint/target-macros/controlling-the-compilation-driver-gcc.rst", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fcontrolling-the-compilation-driver-gcc.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fcontrolling-the-compilation-driver-gcc.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fcontrolling-the-compilation-driver-gcc.rst?ref=3e070cff11f81051e70b613816075b66a6de61c2", "patch": "@@ -291,10 +291,16 @@ You can control the compilation driver.\n   the effect you need.  Overriding this macro may be avoidable by overriding\n   ``LINK_GCC_C_SEQUENCE_SPEC`` instead.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_ALWAYS_STRIP_DOTDOT]\n-  :end-before: [TARGET_ALWAYS_STRIP_DOTDOT]\n+.. c:var:: bool TARGET_ALWAYS_STRIP_DOTDOT\n \n+  .. hook-start:TARGET_ALWAYS_STRIP_DOTDOT\n+\n+  True if :samp:`..` components should always be removed from directory names\n+  computed relative to GCC's internal directories, false (default) if such\n+  components should be preserved and directory names containing them passed\n+  to other tools such as the linker.\n+\n+.. hook-end\n \n .. c:macro:: MULTILIB_DEFAULTS\n "}, {"sha": "38ee6ab3ff2ec96b7f031d3ed4e0ecae068aa3f5", "filename": "gcc/doc/gccint/target-macros/d-abi-parameters.rst", "status": "modified", "additions": 83, "deletions": 27, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fd-abi-parameters.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fd-abi-parameters.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fd-abi-parameters.rst?ref=3e070cff11f81051e70b613816075b66a6de61c2", "patch": "@@ -10,46 +10,102 @@\n D ABI parameters\n ****************\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_D_CPU_VERSIONS]\n-  :end-before: [TARGET_D_CPU_VERSIONS]\n+.. function:: void TARGET_D_CPU_VERSIONS (void)\n \n+  .. hook-start:TARGET_D_CPU_VERSIONS\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_D_OS_VERSIONS]\n-  :end-before: [TARGET_D_OS_VERSIONS]\n+  Declare all environmental version identifiers relating to the target CPU\n+  using the function ``builtin_version``, which takes a string representing\n+  the name of the version.  Version identifiers predefined by this hook apply\n+  to all modules that are being compiled and imported.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_D_REGISTER_CPU_TARGET_INFO]\n-  :end-before: [TARGET_D_REGISTER_CPU_TARGET_INFO]\n+.. function:: void TARGET_D_OS_VERSIONS (void)\n \n+  .. hook-start:TARGET_D_OS_VERSIONS\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_D_REGISTER_OS_TARGET_INFO]\n-  :end-before: [TARGET_D_REGISTER_OS_TARGET_INFO]\n+  Similarly to ``TARGET_D_CPU_VERSIONS``, but is used for versions\n+  relating to the target operating system.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_D_MINFO_SECTION]\n-  :end-before: [TARGET_D_MINFO_SECTION]\n+.. function:: void TARGET_D_REGISTER_CPU_TARGET_INFO (void)\n \n+  .. hook-start:TARGET_D_REGISTER_CPU_TARGET_INFO\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_D_MINFO_SECTION_START]\n-  :end-before: [TARGET_D_MINFO_SECTION_START]\n+  Register all target information keys relating to the target CPU using the\n+  function ``d_add_target_info_handlers``, which takes a\n+  :samp:`struct d_target_info_spec` (defined in :samp:`d/d-target.h`).  The keys\n+  added by this hook are made available at compile time by the\n+  ``__traits(getTargetInfo)`` extension, the result is an expression\n+  describing the requested target information.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_D_MINFO_SECTION_END]\n-  :end-before: [TARGET_D_MINFO_SECTION_END]\n+.. function:: void TARGET_D_REGISTER_OS_TARGET_INFO (void)\n \n+  .. hook-start:TARGET_D_REGISTER_OS_TARGET_INFO\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_D_HAS_STDCALL_CONVENTION]\n-  :end-before: [TARGET_D_HAS_STDCALL_CONVENTION]\n+  Same as ``TARGET_D_CPU_TARGET_INFO``, but is used for keys relating to\n+  the target operating system.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_D_TEMPLATES_ALWAYS_COMDAT]\n-  :end-before: [TARGET_D_TEMPLATES_ALWAYS_COMDAT]\n+.. c:var:: const char * TARGET_D_MINFO_SECTION\n+\n+  .. hook-start:TARGET_D_MINFO_SECTION\n+\n+  Contains the name of the section in which module info references should be\n+  placed.  By default, the compiler puts all module info symbols in the\n+  ``\"minfo\"`` section.  Define this macro to override the string if a\n+  different section name should be used.  This section is expected to be\n+  bracketed by two symbols ``TARGET_D_MINFO_SECTION_START`` and \n+  ``TARGET_D_MINFO_SECTION_END`` to indicate the start and end address of\n+  the section, so that the runtime library can collect all modules for each\n+  loaded shared library and executable.  Setting the value to ``NULL``\n+  disables the use of sections for storing module info altogether.\n+\n+.. hook-end\n+\n+.. c:var:: const char * TARGET_D_MINFO_SECTION_START\n+\n+  .. hook-start:TARGET_D_MINFO_SECTION_START\n+\n+  If ``TARGET_D_MINFO_SECTION`` is defined, then this must also be defined\n+  as the name of the symbol indicating the start address of the module info\n+  section\n+\n+.. hook-end\n+\n+.. c:var:: const char * TARGET_D_MINFO_SECTION_END\n+\n+  .. hook-start:TARGET_D_MINFO_SECTION_END\n+\n+  If ``TARGET_D_MINFO_SECTION`` is defined, then this must also be defined\n+  as the name of the symbol indicating the end address of the module info\n+  section\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_D_HAS_STDCALL_CONVENTION (unsigned int *link_system, unsigned int *link_windows)\n+\n+  .. hook-start:TARGET_D_HAS_STDCALL_CONVENTION\n+\n+  Returns ``true`` if the target supports the stdcall calling convention.\n+  The hook should also set :samp:`{link_system}` to ``1`` if the ``stdcall``\n+  attribute should be applied to functions with ``extern(System)`` linkage,\n+  and :samp:`{link_windows}` to ``1`` to apply ``stdcall`` to functions with\n+  ``extern(Windows)`` linkage.\n+\n+.. hook-end\n+\n+.. c:var:: bool TARGET_D_TEMPLATES_ALWAYS_COMDAT\n+\n+  .. hook-start:TARGET_D_TEMPLATES_ALWAYS_COMDAT\n+\n+  This flag is true if instantiated functions and variables are always COMDAT\n+  if they have external linkage.  If this flag is false, then instantiated\n+  decls will be emitted as weak symbols.  The default is ``false``.\n+\n+.. hook-end"}, {"sha": "0a265b2d1c9ef953a2e3ddd143c7551bb1590c67", "filename": "gcc/doc/gccint/target-macros/defining-target-specific-uses-of-attribute.rst", "status": "modified", "additions": 252, "deletions": 66, "changes": 318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fdefining-target-specific-uses-of-attribute.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fdefining-target-specific-uses-of-attribute.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fdefining-target-specific-uses-of-attribute.rst?ref=3e070cff11f81051e70b613816075b66a6de61c2", "patch": "@@ -14,40 +14,100 @@ Target-specific attributes may be defined for functions, data and types.\n These are described using the following target hooks; they also need to\n be documented in :samp:`extend.texi`.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_ATTRIBUTE_TABLE]\n-  :end-before: [TARGET_ATTRIBUTE_TABLE]\n+.. c:var:: const struct attribute_spec * TARGET_ATTRIBUTE_TABLE\n \n+  .. hook-start:TARGET_ATTRIBUTE_TABLE\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_ATTRIBUTE_TAKES_IDENTIFIER_P]\n-  :end-before: [TARGET_ATTRIBUTE_TAKES_IDENTIFIER_P]\n+  If defined, this target hook points to an array of :samp:`struct\n+  attribute_spec` (defined in :samp:`tree-core.h`) specifying the machine\n+  specific attributes for this target and some of the restrictions on the\n+  entities to which these attributes are applied and the arguments they\n+  take.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_COMP_TYPE_ATTRIBUTES]\n-  :end-before: [TARGET_COMP_TYPE_ATTRIBUTES]\n+.. function:: bool TARGET_ATTRIBUTE_TAKES_IDENTIFIER_P (const_tree name)\n \n+  .. hook-start:TARGET_ATTRIBUTE_TAKES_IDENTIFIER_P\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SET_DEFAULT_TYPE_ATTRIBUTES]\n-  :end-before: [TARGET_SET_DEFAULT_TYPE_ATTRIBUTES]\n+  If defined, this target hook is a function which returns true if the\n+  machine-specific attribute named :samp:`{name}` expects an identifier\n+  given as its first argument to be passed on as a plain identifier, not\n+  subjected to name lookup.  If this is not defined, the default is\n+  false for all machine-specific attributes.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_MERGE_TYPE_ATTRIBUTES]\n-  :end-before: [TARGET_MERGE_TYPE_ATTRIBUTES]\n+.. function:: int TARGET_COMP_TYPE_ATTRIBUTES (const_tree type1, const_tree type2)\n \n+  .. hook-start:TARGET_COMP_TYPE_ATTRIBUTES\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_MERGE_DECL_ATTRIBUTES]\n-  :end-before: [TARGET_MERGE_DECL_ATTRIBUTES]\n+  If defined, this target hook is a function which returns zero if the attributes on\n+  :samp:`{type1}` and :samp:`{type2}` are incompatible, one if they are compatible,\n+  and two if they are nearly compatible (which causes a warning to be\n+  generated).  If this is not defined, machine-specific attributes are\n+  supposed always to be compatible.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_VALID_DLLIMPORT_ATTRIBUTE_P]\n-  :end-before: [TARGET_VALID_DLLIMPORT_ATTRIBUTE_P]\n+.. function:: void TARGET_SET_DEFAULT_TYPE_ATTRIBUTES (tree type)\n \n+  .. hook-start:TARGET_SET_DEFAULT_TYPE_ATTRIBUTES\n+\n+  If defined, this target hook is a function which assigns default attributes to\n+  the newly defined :samp:`{type}`.\n+\n+.. hook-end\n+\n+.. function:: tree TARGET_MERGE_TYPE_ATTRIBUTES (tree type1, tree type2)\n+\n+  .. hook-start:TARGET_MERGE_TYPE_ATTRIBUTES\n+\n+  Define this target hook if the merging of type attributes needs special\n+  handling.  If defined, the result is a list of the combined\n+  ``TYPE_ATTRIBUTES`` of :samp:`{type1}` and :samp:`{type2}`.  It is assumed\n+  that ``comptypes`` has already been called and returned 1.  This\n+  function may call ``merge_attributes`` to handle machine-independent\n+  merging.\n+\n+.. hook-end\n+\n+.. function:: tree TARGET_MERGE_DECL_ATTRIBUTES (tree olddecl, tree newdecl)\n+\n+  .. hook-start:TARGET_MERGE_DECL_ATTRIBUTES\n+\n+  Define this target hook if the merging of decl attributes needs special\n+  handling.  If defined, the result is a list of the combined\n+  ``DECL_ATTRIBUTES`` of :samp:`{olddecl}` and :samp:`{newdecl}`.\n+  :samp:`{newdecl}` is a duplicate declaration of :samp:`{olddecl}`.  Examples of\n+  when this is needed are when one attribute overrides another, or when an\n+  attribute is nullified by a subsequent definition.  This function may\n+  call ``merge_attributes`` to handle machine-independent merging.\n+\n+  .. index:: TARGET_DLLIMPORT_DECL_ATTRIBUTES\n+\n+  If the only target-specific handling you require is :samp:`dllimport`\n+  for Microsoft Windows targets, you should define the macro\n+  ``TARGET_DLLIMPORT_DECL_ATTRIBUTES`` to ``1``.  The compiler\n+  will then define a function called\n+  ``merge_dllimport_decl_attributes`` which can then be defined as\n+  the expansion of ``TARGET_MERGE_DECL_ATTRIBUTES``.  You can also\n+  add ``handle_dll_attribute`` in the attribute table for your port\n+  to perform initial processing of the :samp:`dllimport` and\n+  :samp:`dllexport` attributes.  This is done in :samp:`i386/cygwin.h` and\n+  :samp:`i386/i386.cc`, for example.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_VALID_DLLIMPORT_ATTRIBUTE_P (const_tree decl)\n+\n+  .. hook-start:TARGET_VALID_DLLIMPORT_ATTRIBUTE_P\n+\n+  :samp:`{decl}` is a variable or function with ``__attribute__((dllimport))``\n+  specified.  Use this hook if the target needs to add extra validation\n+  checks to ``handle_dll_attribute``.\n+\n+.. hook-end\n \n .. c:macro:: TARGET_DECLSPEC\n \n@@ -58,76 +118,202 @@ be documented in :samp:`extend.texi`.\n   of ``__declspec`` is via a built-in macro, but you should not rely\n   on this implementation detail.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_INSERT_ATTRIBUTES]\n-  :end-before: [TARGET_INSERT_ATTRIBUTES]\n+.. function:: void TARGET_INSERT_ATTRIBUTES (tree node, tree *attr_ptr)\n+\n+  .. hook-start:TARGET_INSERT_ATTRIBUTES\n+\n+  Define this target hook if you want to be able to add attributes to a decl\n+  when it is being created.  This is normally useful for back ends which\n+  wish to implement a pragma by using the attributes which correspond to\n+  the pragma's effect.  The :samp:`{node}` argument is the decl which is being\n+  created.  The :samp:`{attr_ptr}` argument is a pointer to the attribute list\n+  for this decl.  The list itself should not be modified, since it may be\n+  shared with other decls, but attributes may be chained on the head of\n+  the list and ``*attr_ptr`` modified to point to the new\n+  attributes, or a copy of the list may be made if further changes are\n+  needed.\n+\n+.. hook-end\n+\n+.. function:: tree TARGET_HANDLE_GENERIC_ATTRIBUTE (tree *node, tree name, tree args, int flags, bool *no_add_attrs)\n+\n+  .. hook-start:TARGET_HANDLE_GENERIC_ATTRIBUTE\n+\n+  Define this target hook if you want to be able to perform additional\n+  target-specific processing of an attribute which is handled generically\n+  by a front end.  The arguments are the same as those which are passed to\n+  attribute handlers.  So far this only affects the :samp:`{noinit}` and\n+  :samp:`{section}` attribute.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_FUNCTION_ATTRIBUTE_INLINABLE_P (const_tree fndecl)\n+\n+  .. hook-start:TARGET_FUNCTION_ATTRIBUTE_INLINABLE_P\n+\n+  .. index:: inlining\n+\n+  This target hook returns ``true`` if it is OK to inline :samp:`{fndecl}`\n+  into the current function, despite its having target-specific\n+  attributes, ``false`` otherwise.  By default, if a function has a\n+  target specific attribute attached to it, it will not be inlined.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_OPTION_VALID_ATTRIBUTE_P (tree fndecl, tree name, tree args, int flags)\n+\n+  .. hook-start:TARGET_OPTION_VALID_ATTRIBUTE_P\n+\n+  This hook is called to parse ``attribute(target(\"...\"))``, which\n+  allows setting target-specific options on individual functions.\n+  These function-specific options may differ\n+  from the options specified on the command line.  The hook should return\n+  ``true`` if the options are valid.\n+\n+  The hook should set the ``DECL_FUNCTION_SPECIFIC_TARGET`` field in\n+  the function declaration to hold a pointer to a target-specific\n+  ``struct cl_target_option`` structure.\n+\n+.. hook-end\n+\n+.. function:: void TARGET_OPTION_SAVE (struct cl_target_option *ptr, struct gcc_options *opts, struct gcc_options *opts_set)\n+\n+  .. hook-start:TARGET_OPTION_SAVE\n+\n+  This hook is called to save any additional target-specific information\n+  in the ``struct cl_target_option`` structure for function-specific\n+  options from the ``struct gcc_options`` structure.\n+  See :ref:`option-file-format`.\n+\n+.. hook-end\n+\n+.. function:: void TARGET_OPTION_RESTORE (struct gcc_options *opts, struct gcc_options *opts_set, struct cl_target_option *ptr)\n+\n+  .. hook-start:TARGET_OPTION_RESTORE\n+\n+  This hook is called to restore any additional target-specific\n+  information in the ``struct cl_target_option`` structure for\n+  function-specific options to the ``struct gcc_options`` structure.\n+\n+.. hook-end\n+\n+.. function:: void TARGET_OPTION_POST_STREAM_IN (struct cl_target_option *ptr)\n+\n+  .. hook-start:TARGET_OPTION_POST_STREAM_IN\n+\n+  This hook is called to update target-specific information in the\n+  ``struct cl_target_option`` structure after it is streamed in from\n+  LTO bytecode.\n+\n+.. hook-end\n+\n+.. function:: void TARGET_OPTION_PRINT (FILE *file, int indent, struct cl_target_option *ptr)\n+\n+  .. hook-start:TARGET_OPTION_PRINT\n+\n+  This hook is called to print any additional target-specific\n+  information in the ``struct cl_target_option`` structure for\n+  function-specific options.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_OPTION_PRAGMA_PARSE (tree args, tree pop_target)\n+\n+  .. hook-start:TARGET_OPTION_PRAGMA_PARSE\n \n+  This target hook parses the options for ``#pragma GCC target``, which\n+  sets the target-specific options for functions that occur later in the\n+  input stream.  The options accepted should be the same as those handled by the\n+  ``TARGET_OPTION_VALID_ATTRIBUTE_P`` hook.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_HANDLE_GENERIC_ATTRIBUTE]\n-  :end-before: [TARGET_HANDLE_GENERIC_ATTRIBUTE]\n+.. hook-end\n \n+.. function:: void TARGET_OPTION_OVERRIDE (void)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_FUNCTION_ATTRIBUTE_INLINABLE_P]\n-  :end-before: [TARGET_FUNCTION_ATTRIBUTE_INLINABLE_P]\n+  .. hook-start:TARGET_OPTION_OVERRIDE\n \n+  Sometimes certain combinations of command options do not make sense on\n+  a particular target machine.  You can override the hook\n+  ``TARGET_OPTION_OVERRIDE`` to take account of this.  This hooks is called\n+  once just after all the command options have been parsed.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_OPTION_VALID_ATTRIBUTE_P]\n-  :end-before: [TARGET_OPTION_VALID_ATTRIBUTE_P]\n+  Don't use this hook to turn on various extra optimizations for\n+  :option:`-O`.  That is what ``TARGET_OPTION_OPTIMIZATION`` is for.\n \n+  If you need to do something whenever the optimization level is\n+  changed via the optimize attribute or pragma, see\n+  ``TARGET_OVERRIDE_OPTIONS_AFTER_CHANGE``\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_OPTION_SAVE]\n-  :end-before: [TARGET_OPTION_SAVE]\n+.. hook-end\n \n+.. function:: bool TARGET_OPTION_FUNCTION_VERSIONS (tree decl1, tree decl2)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_OPTION_RESTORE]\n-  :end-before: [TARGET_OPTION_RESTORE]\n+  .. hook-start:TARGET_OPTION_FUNCTION_VERSIONS\n \n+  This target hook returns ``true`` if :samp:`{DECL1}` and :samp:`{DECL2}` are\n+  versions of the same function.  :samp:`{DECL1}` and :samp:`{DECL2}` are function\n+  versions if and only if they have the same function signature and\n+  different target specific attributes, that is, they are compiled for\n+  different target machines.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_OPTION_POST_STREAM_IN]\n-  :end-before: [TARGET_OPTION_POST_STREAM_IN]\n+.. hook-end\n \n+.. function:: bool TARGET_CAN_INLINE_P (tree caller, tree callee)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_OPTION_PRINT]\n-  :end-before: [TARGET_OPTION_PRINT]\n+  .. hook-start:TARGET_CAN_INLINE_P\n \n+  This target hook returns ``false`` if the :samp:`{caller}` function\n+  cannot inline :samp:`{callee}`, based on target specific information.  By\n+  default, inlining is not allowed if the callee function has function\n+  specific target options and the caller does not use the same options.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_OPTION_PRAGMA_PARSE]\n-  :end-before: [TARGET_OPTION_PRAGMA_PARSE]\n+.. hook-end\n \n+.. function:: bool TARGET_UPDATE_IPA_FN_TARGET_INFO (unsigned int& info, const gimple* stmt)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_OPTION_OVERRIDE]\n-  :end-before: [TARGET_OPTION_OVERRIDE]\n+   .. hook-start:TARGET_UPDATE_IPA_FN_TARGET_INFO\n \n+  Allow target to analyze all gimple statements for the given function to\n+  record and update some target specific information for inlining.  A typical\n+  example is that a caller with one isa feature disabled is normally not\n+  allowed to inline a callee with that same isa feature enabled even which is\n+  attributed by always_inline, but with the conservative analysis on all\n+  statements of the callee if we are able to guarantee the callee does not\n+  exploit any instructions from the mismatch isa feature, it would be safe to\n+  allow the caller to inline the callee.\n+  :samp:`{info}` is one ``unsigned int`` value to record information in which\n+  one set bit indicates one corresponding feature is detected in the analysis,\n+  :samp:`{stmt}` is the statement being analyzed.  Return true if target still\n+  need to analyze the subsequent statements, otherwise return false to stop\n+  subsequent analysis.\n+  The default version of this hook returns false.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_OPTION_FUNCTION_VERSIONS]\n-  :end-before: [TARGET_OPTION_FUNCTION_VERSIONS]\n+.. hook-end\n \n+.. function:: bool TARGET_NEED_IPA_FN_TARGET_INFO (const_tree decl, unsigned int& info)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_CAN_INLINE_P]\n-  :end-before: [TARGET_CAN_INLINE_P]\n+  .. hook-start:TARGET_NEED_IPA_FN_TARGET_INFO\n \n+  Allow target to check early whether it is necessary to analyze all gimple\n+  statements in the given function to update target specific information for\n+  inlining.  See hook ``update_ipa_fn_target_info`` for usage example of\n+  target specific information.  This hook is expected to be invoked ahead of\n+  the iterating with hook ``update_ipa_fn_target_info``.\n+  :samp:`{decl}` is the function being analyzed, :samp:`{info}` is the same as what\n+  in hook ``update_ipa_fn_target_info``, target can do one time update\n+  into :samp:`{info}` without iterating for some case.  Return true if target\n+  decides to analyze all gimple statements to collect information, otherwise\n+  return false.\n+  The default version of this hook returns false.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_UPDATE_IPA_FN_TARGET_INFO]\n-  :end-before: [TARGET_UPDATE_IPA_FN_TARGET_INFO]\n+.. hook-end\n \n+.. function:: void TARGET_RELAYOUT_FUNCTION (tree fndecl)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_NEED_IPA_FN_TARGET_INFO]\n-  :end-before: [TARGET_NEED_IPA_FN_TARGET_INFO]\n+  .. hook-start:TARGET_RELAYOUT_FUNCTION\n \n+  This target hook fixes function :samp:`{fndecl}` after attributes are processed.\n+  Default does nothing. On ARM, the default function's alignment is updated\n+  with the attribute target.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_RELAYOUT_FUNCTION]\n-  :end-before: [TARGET_RELAYOUT_FUNCTION]\n+.. hook-end\n\\ No newline at end of file"}, {"sha": "3f38048f932e41c7f9e80360134a7ca1e844c70a", "filename": "gcc/doc/gccint/target-macros/defining-the-output-assembler-language/assembler-commands-for-exception-regions.rst", "status": "modified", "additions": 67, "deletions": 24, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fdefining-the-output-assembler-language%2Fassembler-commands-for-exception-regions.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fdefining-the-output-assembler-language%2Fassembler-commands-for-exception-regions.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fdefining-the-output-assembler-language%2Fassembler-commands-for-exception-regions.rst?ref=3e070cff11f81051e70b613816075b66a6de61c2", "patch": "@@ -54,10 +54,11 @@ region.\n   ``INCOMING_RETURN_ADDR_RTX`` and ``OBJECT_FORMAT_ELF``),\n   GCC will provide a default definition of 1.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_EXCEPT_UNWIND_INFO]\n-  :end-before: [TARGET_EXCEPT_UNWIND_INFO]\n+.. function:: enum unwind_info_type TARGET_EXCEPT_UNWIND_INFO (struct gcc_options *opts)\n \n+  .. hook-start:TARGET_EXCEPT_UNWIND_INFO\n+\n+  .. hook-end\n \n   This hook defines the mechanism that will be used for exception handling\n   by the target.  If the target has ABI specified unwind tables, the hook\n@@ -83,10 +84,11 @@ region.\n   ``DWARF2_UNWIND_INFO`` depends on command-line options, the target\n   must define this hook so that :samp:`{opts}` is used correctly.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_UNWIND_TABLES_DEFAULT]\n-  :end-before: [TARGET_UNWIND_TABLES_DEFAULT]\n+.. c:var:: bool TARGET_UNWIND_TABLES_DEFAULT\n+\n+  .. hook-start:TARGET_UNWIND_TABLES_DEFAULT\n \n+  .. hook-end\n \n   This variable should be set to ``true`` if the target ABI requires unwinding\n   tables even when exceptions are not used.  It must not be modified by\n@@ -115,31 +117,72 @@ region.\n   minimum alignment otherwise.  See :ref:`dwarf`.  Only applicable if\n   the target supports DWARF 2 frame unwind information.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_TERMINATE_DW2_EH_FRAME_INFO]\n-  :end-before: [TARGET_TERMINATE_DW2_EH_FRAME_INFO]\n+.. c:var:: bool TARGET_TERMINATE_DW2_EH_FRAME_INFO\n+\n+  .. hook-start:TARGET_TERMINATE_DW2_EH_FRAME_INFO\n+\n+  Contains the value true if the target should add a zero word onto the\n+  end of a Dwarf-2 frame info section when used for exception handling.\n+  Default value is false if ``EH_FRAME_SECTION_NAME`` is defined, and\n+  true otherwise.\n+\n+.. hook-end\n+\n+.. function:: rtx TARGET_DWARF_REGISTER_SPAN (rtx reg)\n+\n+  .. hook-start:TARGET_DWARF_REGISTER_SPAN\n+\n+  Given a register, this hook should return a parallel of registers to\n+  represent where to find the register pieces.  Define this hook if the\n+  register and its mode are represented in Dwarf in non-contiguous\n+  locations, or if the register should be represented in more than one\n+  register in Dwarf.  Otherwise, this hook should return ``NULL_RTX``.\n+  If not defined, the default is to return ``NULL_RTX``.\n+\n+.. hook-end\n+\n+.. function:: machine_mode TARGET_DWARF_FRAME_REG_MODE (int regno)\n+\n+  .. hook-start:TARGET_DWARF_FRAME_REG_MODE\n+\n+  Given a register, this hook should return the mode which the\n+  corresponding Dwarf frame register should have.  This is normally\n+  used to return a smaller mode than the raw mode to prevent call\n+  clobbered parts of a register altering the frame register size\n+\n+.. hook-end\n+\n+.. function:: void TARGET_INIT_DWARF_REG_SIZES_EXTRA (tree address)\n+\n+  .. hook-start:TARGET_INIT_DWARF_REG_SIZES_EXTRA\n \n+  If some registers are represented in Dwarf-2 unwind information in\n+  multiple pieces, define this hook to fill in information about the\n+  sizes of those pieces in the table used by the unwinder at runtime.\n+  It will be called by ``expand_builtin_init_dwarf_reg_sizes`` after\n+  filling in a single size corresponding to each hard register;\n+  :samp:`{address}` is the address of the table.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_DWARF_REGISTER_SPAN]\n-  :end-before: [TARGET_DWARF_REGISTER_SPAN]\n+.. hook-end\n \n+.. function:: bool TARGET_ASM_TTYPE (rtx sym)\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_DWARF_FRAME_REG_MODE]\n-  :end-before: [TARGET_DWARF_FRAME_REG_MODE]\n+  .. hook-start:TARGET_ASM_TTYPE\n \n+  This hook is used to output a reference from a frame unwinding table to\n+  the type_info object identified by :samp:`{sym}`.  It should return ``true``\n+  if the reference was output.  Returning ``false`` will cause the\n+  reference to be output using the normal Dwarf2 routines.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_INIT_DWARF_REG_SIZES_EXTRA]\n-  :end-before: [TARGET_INIT_DWARF_REG_SIZES_EXTRA]\n+.. hook-end\n \n+.. c:var:: bool TARGET_ARM_EABI_UNWINDER\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_ASM_TTYPE]\n-  :end-before: [TARGET_ASM_TTYPE]\n+  .. hook-start:TARGET_ARM_EABI_UNWINDER\n \n+  This flag should be set to ``true`` on targets that use an ARM EABI\n+  based unwinding library, and ``false`` on other targets.  This effects\n+  the format of unwinding tables, and how the unwinder in entered after\n+  running a cleanup.  The default is ``false``.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_ARM_EABI_UNWINDER]\n-  :end-before: [TARGET_ARM_EABI_UNWINDER]\n+.. hook-end\n\\ No newline at end of file"}, {"sha": "2cfe0c8e3d739f0406aa3b42dea9ac3a98a29620", "filename": "gcc/doc/gccint/target-macros/defining-the-output-assembler-language/macros-controlling-initialization-routines.rst", "status": "modified", "additions": 42, "deletions": 12, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fdefining-the-output-assembler-language%2Fmacros-controlling-initialization-routines.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fdefining-the-output-assembler-language%2Fmacros-controlling-initialization-routines.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fdefining-the-output-assembler-language%2Fmacros-controlling-initialization-routines.rst?ref=3e070cff11f81051e70b613816075b66a6de61c2", "patch": "@@ -71,25 +71,55 @@ and termination functions:\n   of objects.  If zero, the compiler will issue an error message upon\n   encountering an ``init_priority`` attribute.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_HAVE_CTORS_DTORS]\n-  :end-before: [TARGET_HAVE_CTORS_DTORS]\n+.. c:var:: bool TARGET_HAVE_CTORS_DTORS\n \n+  .. hook-start:TARGET_HAVE_CTORS_DTORS\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_DTORS_FROM_CXA_ATEXIT]\n-  :end-before: [TARGET_DTORS_FROM_CXA_ATEXIT]\n+  This value is true if the target supports some 'native' method of\n+  collecting constructors and destructors to be run at startup and exit.\n+  It is false if we must use :command:`collect2`.\n \n+.. hook-end\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_ASM_CONSTRUCTOR]\n-  :end-before: [TARGET_ASM_CONSTRUCTOR]\n+.. c:var:: bool TARGET_DTORS_FROM_CXA_ATEXIT\n \n+  .. hook-start:TARGET_DTORS_FROM_CXA_ATEXIT\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_ASM_DESTRUCTOR]\n-  :end-before: [TARGET_ASM_DESTRUCTOR]\n+  This value is true if the target wants destructors to be queued to be\n+  run from __cxa_atexit.  If this is the case then, for each priority level,\n+  a new constructor will be entered that registers the destructors for that\n+  level with __cxa_atexit (and there will be no destructors emitted).\n+  It is false the method implied by ``have_ctors_dtors`` is used.\n \n+.. hook-end\n+\n+.. function:: void TARGET_ASM_CONSTRUCTOR (rtx symbol, int priority)\n+\n+  .. hook-start:TARGET_ASM_CONSTRUCTOR\n+\n+  If defined, a function that outputs assembler code to arrange to call\n+  the function referenced by :samp:`{symbol}` at initialization time.\n+\n+  Assume that :samp:`{symbol}` is a ``SYMBOL_REF`` for a function taking\n+  no arguments and with no return value.  If the target supports initialization\n+  priorities, :samp:`{priority}` is a value between 0 and ``MAX_INIT_PRIORITY`` ;\n+  otherwise it must be ``DEFAULT_INIT_PRIORITY``.\n+\n+  If this macro is not defined by the target, a suitable default will\n+  be chosen if (1) the target supports arbitrary section names, (2) the\n+  target defines ``CTORS_SECTION_ASM_OP``, or (3) ``USE_COLLECT2``\n+  is not defined.\n+\n+.. hook-end\n+\n+.. function:: void TARGET_ASM_DESTRUCTOR (rtx symbol, int priority)\n+\n+  .. hook-start:TARGET_ASM_DESTRUCTOR\n+\n+  This is like ``TARGET_ASM_CONSTRUCTOR`` but used for termination\n+  functions rather than initialization functions.\n+\n+.. hook-end\n \n If ``TARGET_HAVE_CTORS_DTORS`` is true, the initialization routine\n generated for the generated object file will have static linkage."}, {"sha": "e729ff3fab29c7d2c82d064873374fe866950cb6", "filename": "gcc/doc/gccint/target-macros/defining-the-output-assembler-language/output-and-generation-of-labels.rst", "status": "modified", "additions": 99, "deletions": 27, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fdefining-the-output-assembler-language%2Foutput-and-generation-of-labels.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fdefining-the-output-assembler-language%2Foutput-and-generation-of-labels.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fdefining-the-output-assembler-language%2Foutput-and-generation-of-labels.rst?ref=3e070cff11f81051e70b613816075b66a6de61c2", "patch": "@@ -199,10 +199,23 @@ This is about outputting labels.\n   You may wish to use ``ASM_OUTPUT_TYPE_DIRECTIVE`` and/or\n   ``ASM_OUTPUT_SIZE_DIRECTIVE`` in the definition of this macro.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_ASM_DECLARE_CONSTANT_NAME]\n-  :end-before: [TARGET_ASM_DECLARE_CONSTANT_NAME]\n+.. function:: void TARGET_ASM_DECLARE_CONSTANT_NAME (FILE *file, const char *name, const_tree expr, HOST_WIDE_INT size)\n \n+  .. hook-start:TARGET_ASM_DECLARE_CONSTANT_NAME\n+\n+  A target hook to output to the stdio stream :samp:`{file}` any text necessary\n+  for declaring the name :samp:`{name}` of a constant which is being defined.  This\n+  target hook is responsible for outputting the label definition (perhaps using\n+  ``assemble_label``).  The argument :samp:`{exp}` is the value of the constant,\n+  and :samp:`{size}` is the size of the constant in bytes.  The :samp:`{name}`\n+  will be an internal label.\n+\n+  The default version of this target hook, define the :samp:`{name}` in the\n+  usual manner as a label (by means of ``assemble_label``).\n+\n+  You may wish to use ``ASM_OUTPUT_TYPE_DIRECTIVE`` in this target hook.\n+\n+.. hook-end\n \n .. c:macro:: ASM_DECLARE_REGISTER_GLOBAL (stream, decl, regno, name)\n \n@@ -227,20 +240,41 @@ This is about outputting labels.\n   You may wish to use ``ASM_OUTPUT_SIZE_DIRECTIVE`` and/or\n   ``ASM_OUTPUT_MEASURED_SIZE`` in the definition of this macro.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_ASM_GLOBALIZE_LABEL]\n-  :end-before: [TARGET_ASM_GLOBALIZE_LABEL]\n+.. function:: void TARGET_ASM_GLOBALIZE_LABEL (FILE *stream, const char *name)\n+\n+  .. hook-start:TARGET_ASM_GLOBALIZE_LABEL\n+\n+  This target hook is a function to output to the stdio stream\n+  :samp:`{stream}` some commands that will make the label :samp:`{name}` global;\n+  that is, available for reference from other files.\n+\n+  The default implementation relies on a proper definition of\n+  ``GLOBAL_ASM_OP``.\n \n+.. hook-end\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_ASM_GLOBALIZE_DECL_NAME]\n-  :end-before: [TARGET_ASM_GLOBALIZE_DECL_NAME]\n+.. function:: void TARGET_ASM_GLOBALIZE_DECL_NAME (FILE *stream, tree decl)\n \n+  .. hook-start:TARGET_ASM_GLOBALIZE_DECL_NAME\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_ASM_ASSEMBLE_UNDEFINED_DECL]\n-  :end-before: [TARGET_ASM_ASSEMBLE_UNDEFINED_DECL]\n+  This target hook is a function to output to the stdio stream\n+  :samp:`{stream}` some commands that will make the name associated with :samp:`{decl}`\n+  global; that is, available for reference from other files.\n \n+  The default implementation uses the TARGET_ASM_GLOBALIZE_LABEL target hook.\n+\n+.. hook-end\n+\n+.. function:: void TARGET_ASM_ASSEMBLE_UNDEFINED_DECL (FILE *stream, const char *name, const_tree decl)\n+\n+  .. hook-start:TARGET_ASM_ASSEMBLE_UNDEFINED_DECL\n+\n+  This target hook is a function to output to the stdio stream\n+  :samp:`{stream}` some commands that will declare the name associated with\n+  :samp:`{decl}` which is not defined in the current translation unit.  Most\n+  assemblers do not require anything to be output in this case.\n+\n+.. hook-end\n \n .. c:macro:: ASM_WEAKEN_LABEL (stream, name)\n \n@@ -311,10 +345,15 @@ This is about outputting labels.\n   setting the ``DECL_ONE_ONLY`` flag is enough to mark a declaration to\n   be emitted as one-only.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_ASM_ASSEMBLE_VISIBILITY]\n-  :end-before: [TARGET_ASM_ASSEMBLE_VISIBILITY]\n+.. function:: void TARGET_ASM_ASSEMBLE_VISIBILITY (tree decl, int visibility)\n+\n+  .. hook-start:TARGET_ASM_ASSEMBLE_VISIBILITY\n \n+  This target hook is a function to output to :samp:`{asm_out_file}` some\n+  commands that will make the symbol(s) associated with :samp:`{decl}` have\n+  hidden, protected or internal visibility as specified by :samp:`{visibility}`.\n+\n+.. hook-end\n \n .. c:macro:: TARGET_WEAK_NOT_IN_ARCHIVE_TOC\n \n@@ -346,15 +385,25 @@ This is about outputting labels.\n   This macro need not be defined if it does not need to output anything.\n   The GNU assembler and most Unix assemblers don't require anything.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_ASM_EXTERNAL_LIBCALL]\n-  :end-before: [TARGET_ASM_EXTERNAL_LIBCALL]\n+.. function:: void TARGET_ASM_EXTERNAL_LIBCALL (rtx symref)\n+\n+  .. hook-start:TARGET_ASM_EXTERNAL_LIBCALL\n+\n+  This target hook is a function to output to :samp:`{asm_out_file}` an assembler\n+  pseudo-op to declare a library function name external.  The name of the\n+  library function is given by :samp:`{symref}`, which is a ``symbol_ref``.\n \n+.. hook-end\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_ASM_MARK_DECL_PRESERVED]\n-  :end-before: [TARGET_ASM_MARK_DECL_PRESERVED]\n+.. function:: void TARGET_ASM_MARK_DECL_PRESERVED (const char *symbol)\n \n+  .. hook-start:TARGET_ASM_MARK_DECL_PRESERVED\n+\n+  This target hook is a function to output to :samp:`{asm_out_file}` an assembler\n+  directive to annotate :samp:`{symbol}` as used.  The Darwin target uses the\n+  .no_dead_code_strip directive.\n+\n+.. hook-end\n \n .. c:macro:: ASM_OUTPUT_LABELREF (stream, name)\n \n@@ -364,10 +413,17 @@ This is about outputting labels.\n   is customary on your operating system, as it is in most Berkeley Unix\n   systems.  This macro is used in ``assemble_name``.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_MANGLE_ASSEMBLER_NAME]\n-  :end-before: [TARGET_MANGLE_ASSEMBLER_NAME]\n+.. function:: tree TARGET_MANGLE_ASSEMBLER_NAME (const char *name)\n+\n+  .. hook-start:TARGET_MANGLE_ASSEMBLER_NAME\n \n+  Given a symbol :samp:`{name}`, perform same mangling as ``varasm.cc`` 's\n+  ``assemble_name``, but in memory rather than to a file stream, returning\n+  result as an ``IDENTIFIER_NODE``.  Required for correct LTO symtabs.  The\n+  default implementation calls the ``TARGET_STRIP_NAME_ENCODING`` hook and\n+  then prepends the ``USER_LABEL_PREFIX``, if any.\n+\n+.. hook-end\n \n .. c:macro:: ASM_OUTPUT_SYMBOL_REF (stream, sym)\n \n@@ -387,10 +443,26 @@ This is about outputting labels.\n   when it is necessary to output a label differently when its address is\n   being taken.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_ASM_INTERNAL_LABEL]\n-  :end-before: [TARGET_ASM_INTERNAL_LABEL]\n+.. function:: void TARGET_ASM_INTERNAL_LABEL (FILE *stream, const char *prefix, unsigned long labelno)\n+\n+  .. hook-start:TARGET_ASM_INTERNAL_LABEL\n+\n+  A function to output to the stdio stream :samp:`{stream}` a label whose\n+  name is made from the string :samp:`{prefix}` and the number :samp:`{labelno}`.\n+\n+  It is absolutely essential that these labels be distinct from the labels\n+  used for user-level functions and variables.  Otherwise, certain programs\n+  will have name conflicts with internal labels.\n+\n+  It is desirable to exclude internal labels from the symbol table of the\n+  object file.  Most assemblers have a naming convention for labels that\n+  should be excluded; on many systems, the letter :samp:`L` at the\n+  beginning of a label has this effect.  You should find out what\n+  convention your system uses, and follow it.\n+\n+  The default version of this function utilizes ``ASM_GENERATE_INTERNAL_LABEL``.\n \n+.. hook-end\n \n .. c:macro:: ASM_OUTPUT_DEBUG_LABEL (stream, prefix, num)\n "}, {"sha": "66a32f5f888b5fdec91be52d7090798c22e85b8d", "filename": "gcc/doc/gccint/target-macros/defining-the-output-assembler-language/output-of-assembler-instructions.rst", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fdefining-the-output-assembler-language%2Foutput-of-assembler-instructions.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fdefining-the-output-assembler-language%2Foutput-of-assembler-instructions.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fdefining-the-output-assembler-language%2Foutput-of-assembler-instructions.rst?ref=3e070cff11f81051e70b613816075b66a6de61c2", "patch": "@@ -91,10 +91,22 @@ This describes assembler instruction output.\n \n   If this macro is not defined, it is equivalent to a null statement.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_ASM_FINAL_POSTSCAN_INSN]\n-  :end-before: [TARGET_ASM_FINAL_POSTSCAN_INSN]\n+.. function:: void TARGET_ASM_FINAL_POSTSCAN_INSN (FILE *file, rtx_insn *insn, rtx *opvec, int noperands)\n \n+  .. hook-start:TARGET_ASM_FINAL_POSTSCAN_INSN\n+\n+  If defined, this target hook is a function which is executed just after the\n+  output of assembler code for :samp:`{insn}`, to change the mode of the assembler\n+  if necessary.\n+\n+  Here the argument :samp:`{opvec}` is the vector containing the operands\n+  extracted from :samp:`{insn}`, and :samp:`{noperands}` is the number of\n+  elements of the vector which contain meaningful data for this insn.\n+  The contents of this vector are what was used to convert the insn\n+  template into assembler code, so you can change the assembler mode\n+  by checking the contents of the vector.\n+\n+.. hook-end\n \n .. c:macro:: PRINT_OPERAND (stream, x, code)\n "}, {"sha": "2a0bfce9b4860181912630f370f9f13a2b919e84", "filename": "gcc/doc/gccint/target-macros/defining-the-output-assembler-language/output-of-data.rst", "status": "modified", "additions": 58, "deletions": 15, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fdefining-the-output-assembler-language%2Foutput-of-data.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fdefining-the-output-assembler-language%2Foutput-of-data.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fdefining-the-output-assembler-language%2Foutput-of-data.rst?ref=3e070cff11f81051e70b613816075b66a6de61c2", "patch": "@@ -8,25 +8,63 @@\n Output of Data\n ^^^^^^^^^^^^^^\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_ASM_BYTE_OP]\n-  :end-before: [TARGET_ASM_BYTE_OP]\n+.. c:var:: const char * TARGET_ASM_BYTE_OP\n \n+  .. hook-start:TARGET_ASM_BYTE_OP\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_ASM_INTEGER]\n-  :end-before: [TARGET_ASM_INTEGER]\n+  These hooks specify assembly directives for creating certain kinds\n+  of integer object.  The ``TARGET_ASM_BYTE_OP`` directive creates a\n+  byte-sized object, the ``TARGET_ASM_ALIGNED_HI_OP`` one creates an\n+  aligned two-byte object, and so on.  Any of the hooks may be\n+  ``NULL``, indicating that no suitable directive is available.\n \n+  The compiler will print these strings at the start of a new line,\n+  followed immediately by the object's initial value.  In most cases,\n+  the string should contain a tab, a pseudo-op, and then another tab.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_ASM_DECL_END]\n-  :end-before: [TARGET_ASM_DECL_END]\n+.. hook-end\n \n+.. function:: bool TARGET_ASM_INTEGER (rtx x, unsigned int size, int aligned_p)\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_ASM_OUTPUT_ADDR_CONST_EXTRA]\n-  :end-before: [TARGET_ASM_OUTPUT_ADDR_CONST_EXTRA]\n+  .. hook-start:TARGET_ASM_INTEGER\n \n+  The ``assemble_integer`` function uses this hook to output an\n+  integer object.  :samp:`{x}` is the object's value, :samp:`{size}` is its size\n+  in bytes and :samp:`{aligned_p}` indicates whether it is aligned.  The\n+  function should return ``true`` if it was able to output the\n+  object.  If it returns false, ``assemble_integer`` will try to\n+  split the object into smaller parts.\n+\n+  The default implementation of this hook will use the\n+  ``TARGET_ASM_BYTE_OP`` family of strings, returning ``false``\n+  when the relevant string is ``NULL``.\n+\n+.. hook-end\n+\n+.. function:: void TARGET_ASM_DECL_END (void)\n+\n+  .. hook-start:TARGET_ASM_DECL_END\n+\n+  Define this hook if the target assembler requires a special marker to\n+  terminate an initialized variable declaration.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_ASM_OUTPUT_ADDR_CONST_EXTRA (FILE *file, rtx x)\n+\n+  .. hook-start:TARGET_ASM_OUTPUT_ADDR_CONST_EXTRA\n+\n+  A target hook to recognize :samp:`{rtx}` patterns that ``output_addr_const``\n+  can't deal with, and output assembly code to :samp:`{file}` corresponding to\n+  the pattern :samp:`{x}`.  This may be used to allow machine-dependent\n+  ``UNSPEC`` s to appear within constants.\n+\n+  If target hook fails to recognize a pattern, it must return ``false``,\n+  so that a standard error message is printed.  If it prints an error message\n+  itself, by calling, for example, ``output_operand_lossage``, it may just\n+  return ``true``.\n+\n+.. hook-end\n \n .. c:macro:: ASM_OUTPUT_ASCII (stream, ptr, len)\n \n@@ -117,10 +155,15 @@ Output of Data\n \n .. c:var:: const char * TARGET_ASM_OPEN_PAREN\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_ASM_OPEN_PAREN]\n-  :end-before: [TARGET_ASM_OPEN_PAREN]\n+.. c:var:: const char * TARGET_ASM_CLOSE_PAREN\n+\n+  .. hook-start:TARGET_ASM_OPEN_PAREN\n+\n+  These target hooks are C string constants, describing the syntax in the\n+  assembler for grouping arithmetic expressions.  If not overridden, they\n+  default to normal parentheses, which is correct for most assemblers.\n \n+.. hook-end\n \n These macros are provided by :samp:`real.h` for writing the definitions\n of ``ASM_OUTPUT_DOUBLE`` and the like:"}, {"sha": "a378099bf758d727c28f177f175cc03cb0346a76", "filename": "gcc/doc/gccint/target-macros/defining-the-output-assembler-language/output-of-dispatch-tables.rst", "status": "modified", "additions": 80, "deletions": 24, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fdefining-the-output-assembler-language%2Foutput-of-dispatch-tables.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fdefining-the-output-assembler-language%2Foutput-of-dispatch-tables.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fdefining-the-output-assembler-language%2Foutput-of-dispatch-tables.rst?ref=3e070cff11f81051e70b613816075b66a6de61c2", "patch": "@@ -75,41 +75,97 @@ This concerns dispatch tables.\n   If this macro is not defined, nothing special is output at the end of\n   the jump-table.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_ASM_POST_CFI_STARTPROC]\n-  :end-before: [TARGET_ASM_POST_CFI_STARTPROC]\n+.. function:: void TARGET_ASM_POST_CFI_STARTPROC (FILE *, tree)\n \n+  .. hook-start:TARGET_ASM_POST_CFI_STARTPROC\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_ASM_EMIT_UNWIND_LABEL]\n-  :end-before: [TARGET_ASM_EMIT_UNWIND_LABEL]\n+  This target hook is used to emit assembly strings required by the target\n+  after the .cfi_startproc directive.  The first argument is the file stream to\n+  write the strings to and the second argument is the function's declaration.  The\n+  expected use is to add more .cfi_\\* directives.\n \n+  The default is to not output any assembly strings.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_ASM_EMIT_EXCEPT_TABLE_LABEL]\n-  :end-before: [TARGET_ASM_EMIT_EXCEPT_TABLE_LABEL]\n+.. hook-end\n \n+.. function:: void TARGET_ASM_EMIT_UNWIND_LABEL (FILE *stream, tree decl, int for_eh, int empty)\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_ASM_EMIT_EXCEPT_PERSONALITY]\n-  :end-before: [TARGET_ASM_EMIT_EXCEPT_PERSONALITY]\n+  .. hook-start:TARGET_ASM_EMIT_UNWIND_LABEL\n \n+  This target hook emits a label at the beginning of each FDE.  It\n+  should be defined on targets where FDEs need special labels, and it\n+  should write the appropriate label, for the FDE associated with the\n+  function declaration :samp:`{decl}`, to the stdio stream :samp:`{stream}`.\n+  The third argument, :samp:`{for_eh}`, is a boolean: true if this is for an\n+  exception table.  The fourth argument, :samp:`{empty}`, is a boolean:\n+  true if this is a placeholder label for an omitted FDE.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_ASM_UNWIND_EMIT]\n-  :end-before: [TARGET_ASM_UNWIND_EMIT]\n+  The default is that FDEs are not given nonlocal labels.\n \n+.. hook-end\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_ASM_MAKE_EH_SYMBOL_INDIRECT]\n-  :end-before: [TARGET_ASM_MAKE_EH_SYMBOL_INDIRECT]\n+.. function:: void TARGET_ASM_EMIT_EXCEPT_TABLE_LABEL (FILE *stream)\n \n+  .. hook-start:TARGET_ASM_EMIT_EXCEPT_TABLE_LABEL\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_ASM_UNWIND_EMIT_BEFORE_INSN]\n-  :end-before: [TARGET_ASM_UNWIND_EMIT_BEFORE_INSN]\n+  This target hook emits a label at the beginning of the exception table.\n+  It should be defined on targets where it is desirable for the table\n+  to be broken up according to function.\n \n+  The default is that no label is emitted.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_ASM_SHOULD_RESTORE_CFA_STATE]\n-  :end-before: [TARGET_ASM_SHOULD_RESTORE_CFA_STATE]\n+.. hook-end\n+\n+.. function:: void TARGET_ASM_EMIT_EXCEPT_PERSONALITY (rtx personality)\n+\n+  .. hook-start:TARGET_ASM_EMIT_EXCEPT_PERSONALITY\n+\n+  If the target implements ``TARGET_ASM_UNWIND_EMIT``, this hook may be\n+  used to emit a directive to install a personality hook into the unwind\n+  info.  This hook should not be used if dwarf2 unwind info is used.\n+\n+.. hook-end\n+\n+.. function:: void TARGET_ASM_UNWIND_EMIT (FILE *stream, rtx_insn *insn)\n+\n+  .. hook-start:TARGET_ASM_UNWIND_EMIT\n+\n+  This target hook emits assembly directives required to unwind the\n+  given instruction.  This is only used when ``TARGET_EXCEPT_UNWIND_INFO``\n+  returns ``UI_TARGET``.\n+\n+.. hook-end\n+\n+.. function:: rtx TARGET_ASM_MAKE_EH_SYMBOL_INDIRECT (rtx origsymbol, bool pubvis)\n+\n+  .. hook-start:TARGET_ASM_MAKE_EH_SYMBOL_INDIRECT\n+\n+  If necessary, modify personality and LSDA references to handle indirection.\n+  The original symbol is in ``origsymbol`` and if ``pubvis`` is true\n+  the symbol is visible outside the TU.\n+\n+.. hook-end\n+\n+.. c:var:: bool TARGET_ASM_UNWIND_EMIT_BEFORE_INSN\n+\n+  .. hook-start:TARGET_ASM_UNWIND_EMIT_BEFORE_INSN\n+\n+  True if the ``TARGET_ASM_UNWIND_EMIT`` hook should be called before\n+  the assembly for :samp:`{insn}` has been emitted, false if the hook should\n+  be called afterward.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_ASM_SHOULD_RESTORE_CFA_STATE (void)\n+\n+  .. hook-start:TARGET_ASM_SHOULD_RESTORE_CFA_STATE\n+\n+  For DWARF-based unwind frames, two CFI instructions provide for save and\n+  restore of register state.  GCC maintains the current frame address (CFA)\n+  separately from the register bank but the unwinder in libgcc preserves this\n+  state along with the registers (and this is expected by the code that writes\n+  the unwind frames).  This hook allows the target to specify that the CFA data\n+  is not saved/restored along with the registers by the target unwinder so that\n+  suitable additional instructions should be emitted to restore it.\n+\n+.. hook-end\n\\ No newline at end of file"}, {"sha": "d0dfe7dd55857f0a93cf3531676f413479b117ac", "filename": "gcc/doc/gccint/target-macros/defining-the-output-assembler-language/the-overall-framework-of-an-assembler-file.rst", "status": "modified", "additions": 183, "deletions": 54, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fdefining-the-output-assembler-language%2Fthe-overall-framework-of-an-assembler-file.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fdefining-the-output-assembler-language%2Fthe-overall-framework-of-an-assembler-file.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fdefining-the-output-assembler-language%2Fthe-overall-framework-of-an-assembler-file.rst?ref=3e070cff11f81051e70b613816075b66a6de61c2", "patch": "@@ -16,25 +16,56 @@ This describes the overall framework of an assembly file.\n \n .. index:: default_file_start\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_ASM_FILE_START]\n-  :end-before: [TARGET_ASM_FILE_START]\n+.. function:: void TARGET_ASM_FILE_START (void)\n \n+  .. hook-start:TARGET_ASM_FILE_START\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_ASM_FILE_START_APP_OFF]\n-  :end-before: [TARGET_ASM_FILE_START_APP_OFF]\n+  Output to ``asm_out_file`` any text which the assembler expects to\n+  find at the beginning of a file.  The default behavior is controlled\n+  by two flags, documented below.  Unless your target's assembler is\n+  quite unusual, if you override the default, you should call\n+  ``default_file_start`` at some point in your target hook.  This\n+  lets other target files rely on these variables.\n \n+.. hook-end\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_ASM_FILE_START_FILE_DIRECTIVE]\n-  :end-before: [TARGET_ASM_FILE_START_FILE_DIRECTIVE]\n+.. c:var:: bool TARGET_ASM_FILE_START_APP_OFF\n \n+  .. hook-start:TARGET_ASM_FILE_START_APP_OFF\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_ASM_FILE_END]\n-  :end-before: [TARGET_ASM_FILE_END]\n+  If this flag is true, the text of the macro ``ASM_APP_OFF`` will be\n+  printed as the very first line in the assembly file, unless\n+  :option:`-fverbose-asm` is in effect.  (If that macro has been defined\n+  to the empty string, this variable has no effect.)  With the normal\n+  definition of ``ASM_APP_OFF``, the effect is to notify the GNU\n+  assembler that it need not bother stripping comments or extra\n+  whitespace from its input.  This allows it to work a bit faster.\n \n+  The default is false.  You should not set it to true unless you have\n+  verified that your port does not generate any extra whitespace or\n+  comments that will cause GAS to issue errors in NO_APP mode.\n+\n+.. hook-end\n+\n+.. c:var:: bool TARGET_ASM_FILE_START_FILE_DIRECTIVE\n+\n+  .. hook-start:TARGET_ASM_FILE_START_FILE_DIRECTIVE\n+\n+  If this flag is true, ``output_file_directive`` will be called\n+  for the primary source file, immediately after printing\n+  ``ASM_APP_OFF`` (if that is enabled).  Most ELF assemblers expect\n+  this to be done.  The default is false.\n+\n+.. hook-end\n+\n+.. function:: void TARGET_ASM_FILE_END (void)\n+\n+  .. hook-start:TARGET_ASM_FILE_END\n+\n+  Output to ``asm_out_file`` any text which the assembler expects\n+  to find at the end of a file.  The default is to output nothing.\n+\n+.. hook-end\n \n .. function:: void file_end_indicate_exec_stack ()\n \n@@ -45,20 +76,37 @@ This describes the overall framework of an assembly file.\n   need to do other things in that hook, have your hook function call\n   this function.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_ASM_LTO_START]\n-  :end-before: [TARGET_ASM_LTO_START]\n+.. function:: void TARGET_ASM_LTO_START (void)\n+\n+  .. hook-start:TARGET_ASM_LTO_START\n+\n+  Output to ``asm_out_file`` any text which the assembler expects\n+  to find at the start of an LTO section.  The default is to output\n+  nothing.\n \n+.. hook-end\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_ASM_LTO_END]\n-  :end-before: [TARGET_ASM_LTO_END]\n+.. function:: void TARGET_ASM_LTO_END (void)\n \n+  .. hook-start:TARGET_ASM_LTO_END\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_ASM_CODE_END]\n-  :end-before: [TARGET_ASM_CODE_END]\n+  Output to ``asm_out_file`` any text which the assembler expects\n+  to find at the end of an LTO section.  The default is to output\n+  nothing.\n \n+.. hook-end\n+\n+.. function:: void TARGET_ASM_CODE_END (void)\n+\n+  .. hook-start:TARGET_ASM_CODE_END\n+\n+  Output to ``asm_out_file`` any text which is needed before emitting\n+  unwind info and debug info at the end of a file.  Some targets emit\n+  here PIC setup thunks that cannot be emitted at the end of file,\n+  because they couldn't have unwind info then.  The default is to output\n+  nothing.\n+\n+.. hook-end\n \n .. c:macro:: ASM_COMMENT_START\n \n@@ -90,15 +138,28 @@ This describes the overall framework of an assembly file.\n   This macro need not be defined if the standard form of output\n   for the file format in use is appropriate.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_ASM_OUTPUT_SOURCE_FILENAME]\n-  :end-before: [TARGET_ASM_OUTPUT_SOURCE_FILENAME]\n+.. function:: void TARGET_ASM_OUTPUT_SOURCE_FILENAME (FILE *file, const char *name)\n+\n+  .. hook-start:TARGET_ASM_OUTPUT_SOURCE_FILENAME\n+\n+  Output DWARF debugging information which indicates that filename\n+  :samp:`{name}` is the current source file to the stdio stream :samp:`{file}`.\n+\n+  This target hook need not be defined if the standard form of output\n+  for the file format in use is appropriate.\n+\n+.. hook-end\n+\n+.. function:: void TARGET_ASM_OUTPUT_IDENT (const char *name)\n \n+  .. hook-start:TARGET_ASM_OUTPUT_IDENT\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_ASM_OUTPUT_IDENT]\n-  :end-before: [TARGET_ASM_OUTPUT_IDENT]\n+  Output a string based on :samp:`{name}`, suitable for the :samp:`#ident`\n+  directive, or the equivalent directive or pragma in non-C-family languages.\n+  If this hook is not defined, nothing is output for the :samp:`#ident`\n+  directive.\n \n+.. hook-end\n \n .. c:macro:: OUTPUT_QUOTED_STRING (stream, string)\n \n@@ -108,51 +169,119 @@ This describes the overall framework of an assembly file.\n   the assembler source.  So you can use it to canonicalize the format\n   of the filename using this macro.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_ASM_NAMED_SECTION]\n-  :end-before: [TARGET_ASM_NAMED_SECTION]\n+.. function:: void TARGET_ASM_NAMED_SECTION (const char *name, unsigned int flags, tree decl)\n \n+  .. hook-start:TARGET_ASM_NAMED_SECTION\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_ASM_ELF_FLAGS_NUMERIC]\n-  :end-before: [TARGET_ASM_ELF_FLAGS_NUMERIC]\n+  Output assembly directives to switch to section :samp:`{name}`.  The section\n+  should have attributes as specified by :samp:`{flags}`, which is a bit mask\n+  of the ``SECTION_*`` flags defined in :samp:`output.h`.  If :samp:`{decl}`\n+  is non-NULL, it is the ``VAR_DECL`` or ``FUNCTION_DECL`` with which\n+  this section is associated.\n \n+.. hook-end\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_ASM_FUNCTION_SECTION]\n-  :end-before: [TARGET_ASM_FUNCTION_SECTION]\n+.. function:: bool TARGET_ASM_ELF_FLAGS_NUMERIC (unsigned int flags, unsigned int *num)\n \n+  .. hook-start:TARGET_ASM_ELF_FLAGS_NUMERIC\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_ASM_FUNCTION_SWITCHED_TEXT_SECTIONS]\n-  :end-before: [TARGET_ASM_FUNCTION_SWITCHED_TEXT_SECTIONS]\n+  This hook can be used to encode ELF section flags for which no letter\n+  code has been defined in the assembler.  It is called by\n+  ``default_asm_named_section`` whenever the section flags need to be\n+  emitted in the assembler output.  If the hook returns true, then the\n+  numerical value for ELF section flags should be calculated from\n+  :samp:`{flags}` and saved in :samp:`{*num}` ; the value is printed out instead of the\n+  normal sequence of letter codes.  If the hook is not defined, or if it\n+  returns false, then :samp:`{num}` is ignored and the traditional letter sequence\n+  is emitted.\n \n+.. hook-end\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_HAVE_NAMED_SECTIONS]\n-  :end-before: [TARGET_HAVE_NAMED_SECTIONS]\n+.. function:: section * TARGET_ASM_FUNCTION_SECTION (tree decl, enum node_frequency freq, bool startup, bool exit)\n \n+  .. hook-start:TARGET_ASM_FUNCTION_SECTION\n+\n+  Return preferred text (sub)section for function :samp:`{decl}`.\n+  Main purpose of this function is to separate cold, normal and hot\n+  functions. :samp:`{startup}` is true when function is known to be used only\n+  at startup (from static constructors or it is ``main()``).\n+  :samp:`{exit}` is true when function is known to be used only at exit\n+  (from static destructors).\n+  Return NULL if function should go to default text section.\n+\n+.. hook-end\n+\n+.. function:: void TARGET_ASM_FUNCTION_SWITCHED_TEXT_SECTIONS (FILE *file, tree decl, bool new_is_cold)\n+\n+  .. hook-start:TARGET_ASM_FUNCTION_SWITCHED_TEXT_SECTIONS\n+\n+  Used by the target to emit any assembler directives or additional\n+  labels needed when a function is partitioned between different\n+  sections.  Output should be written to :samp:`{file}`.  The function\n+  decl is available as :samp:`{decl}` and the new section is 'cold' if\n+  :samp:`{new_is_cold}` is ``true``.\n+\n+.. hook-end\n+\n+.. c:var:: bool TARGET_HAVE_NAMED_SECTIONS\n+\n+  .. hook-start:TARGET_HAVE_NAMED_SECTIONS\n+\n+  .. hook-end\n \n   This flag is true if the target supports ``TARGET_ASM_NAMED_SECTION``.\n   It must not be modified by command-line option processing.\n \n .. _target_have_switchable_bss_sections:\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_HAVE_SWITCHABLE_BSS_SECTIONS]\n-  :end-before: [TARGET_HAVE_SWITCHABLE_BSS_SECTIONS]\n+.. c:var:: bool TARGET_HAVE_SWITCHABLE_BSS_SECTIONS\n+\n+  .. hook-start:TARGET_HAVE_SWITCHABLE_BSS_SECTIONS\n+\n+  This flag is true if we can create zeroed data by switching to a BSS\n+  section and then using ``ASM_OUTPUT_SKIP`` to allocate the space.\n+  This is true on most ELF targets.\n+\n+.. hook-end\n+\n+.. function:: unsigned int TARGET_SECTION_TYPE_FLAGS (tree decl, const char *name, int reloc)\n+\n+  .. hook-start:TARGET_SECTION_TYPE_FLAGS\n+\n+  Choose a set of section attributes for use by ``TARGET_ASM_NAMED_SECTION``\n+  based on a variable or function decl, a section name, and whether or not the\n+  declaration's initializer may contain runtime relocations.  :samp:`{decl}` may be\n+  null, in which case read-write data should be assumed.\n+\n+  The default version of this function handles choosing code vs data,\n+  read-only vs read-write data, and ``flag_pic``.  You should only\n+  need to override this if your target has special flags that might be\n+  set via ``__attribute__``.\n+\n+.. hook-end\n+\n+.. function:: void TARGET_ASM_RECORD_GCC_SWITCHES (const char *)\n+\n+  .. hook-start:TARGET_ASM_RECORD_GCC_SWITCHES\n+\n+  Provides the target with the ability to record the gcc command line\n+  switches provided as argument.\n \n+  By default this hook is set to NULL, but an example implementation is\n+  provided for ELF based targets.  Called :samp:`{elf_record_gcc_switches}`,\n+  it records the switches as ASCII text inside a new, string mergeable\n+  section in the assembler output file.  The name of the new section is\n+  provided by the ``TARGET_ASM_RECORD_GCC_SWITCHES_SECTION`` target\n+  hook.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_SECTION_TYPE_FLAGS]\n-  :end-before: [TARGET_SECTION_TYPE_FLAGS]\n+.. hook-end\n \n+.. c:var:: const char * TARGET_ASM_RECORD_GCC_SWITCHES_SECTION\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_ASM_RECORD_GCC_SWITCHES]\n-  :end-before: [TARGET_ASM_RECORD_GCC_SWITCHES]\n+  .. hook-start:TARGET_ASM_RECORD_GCC_SWITCHES_SECTION\n \n+  This is the name of the section that will be created by the example\n+  ELF implementation of the ``TARGET_ASM_RECORD_GCC_SWITCHES`` target\n+  hook.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_ASM_RECORD_GCC_SWITCHES_SECTION]\n-  :end-before: [TARGET_ASM_RECORD_GCC_SWITCHES_SECTION]\n+.. hook-end\n\\ No newline at end of file"}, {"sha": "4991d3da98e6dff41378928efe8c60d7e8b5b296", "filename": "gcc/doc/gccint/target-macros/describing-relative-costs-of-operations.rst", "status": "modified", "additions": 290, "deletions": 45, "changes": 335, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fdescribing-relative-costs-of-operations.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fdescribing-relative-costs-of-operations.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fdescribing-relative-costs-of-operations.rst?ref=3e070cff11f81051e70b613816075b66a6de61c2", "patch": "@@ -35,10 +35,30 @@ on the target machine.\n   These macros are obsolete, new ports should use the target hook\n   ``TARGET_REGISTER_MOVE_COST`` instead.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_REGISTER_MOVE_COST]\n-  :end-before: [TARGET_REGISTER_MOVE_COST]\n+.. function:: int TARGET_REGISTER_MOVE_COST (machine_mode mode, reg_class_t from, reg_class_t to)\n \n+  .. hook-start:TARGET_REGISTER_MOVE_COST\n+\n+  This target hook should return the cost of moving data of mode :samp:`{mode}`\n+  from a register in class :samp:`{from}` to one in class :samp:`{to}`.  The classes\n+  are expressed using the enumeration values such as ``GENERAL_REGS``.\n+  A value of 2 is the default; other values are interpreted relative to\n+  that.\n+\n+  It is not required that the cost always equal 2 when :samp:`{from}` is the\n+  same as :samp:`{to}` ; on some machines it is expensive to move between\n+  registers if they are not general registers.\n+\n+  If reload sees an insn consisting of a single ``set`` between two\n+  hard registers, and if ``TARGET_REGISTER_MOVE_COST`` applied to their\n+  classes returns a value of 2, reload does not check to ensure that the\n+  constraints of the insn are met.  Setting a cost of other than 2 will\n+  allow reload to verify that the constraints are met.  You should do this\n+  if the :samp:`mov{m}` pattern's constraints do not allow such copying.\n+\n+  The default version of this function returns 2.\n+\n+.. hook-end\n \n .. c:macro:: MEMORY_MOVE_COST (mode, class, in)\n \n@@ -67,10 +87,33 @@ on the target machine.\n   These macros are obsolete, new ports should use the target hook\n   ``TARGET_MEMORY_MOVE_COST`` instead.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_MEMORY_MOVE_COST]\n-  :end-before: [TARGET_MEMORY_MOVE_COST]\n+.. function:: int TARGET_MEMORY_MOVE_COST (machine_mode mode, reg_class_t rclass, bool in)\n+\n+  .. hook-start:TARGET_MEMORY_MOVE_COST\n \n+  This target hook should return the cost of moving data of mode :samp:`{mode}`\n+  between a register of class :samp:`{rclass}` and memory; :samp:`{in}` is ``false``\n+  if the value is to be written to memory, ``true`` if it is to be read in.\n+  This cost is relative to those in ``TARGET_REGISTER_MOVE_COST``.\n+  If moving between registers and memory is more expensive than between two\n+  registers, you should add this target hook to express the relative cost.\n+\n+  If you do not add this target hook, GCC uses a default cost of 4 plus\n+  the cost of copying via a secondary reload register, if one is\n+  needed.  If your machine requires a secondary reload register to copy\n+  between memory and a register of :samp:`{rclass}` but the reload mechanism is\n+  more complex than copying via an intermediate, use this target hook to\n+  reflect the actual cost of the move.\n+\n+  GCC defines the function ``memory_move_secondary_cost`` if\n+  secondary reloads are needed.  It computes the costs due to copying via\n+  a secondary register.  If your machine copies from memory using a\n+  secondary register in the conventional way but the default base value of\n+  4 is not correct for your machine, use this target hook to add some other\n+  value to the result of that function.  The arguments to that function\n+  are the same as to this target hook.\n+\n+.. hook-end\n \n .. c:macro:: BRANCH_COST (speed_p, predictable_p)\n \n@@ -101,10 +144,26 @@ ordinarily expect.\n   may eliminate subsequent memory access if subsequent accesses occur to\n   other fields in the same word of the structure, but to different bytes.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SLOW_UNALIGNED_ACCESS]\n-  :end-before: [TARGET_SLOW_UNALIGNED_ACCESS]\n+.. function:: bool TARGET_SLOW_UNALIGNED_ACCESS (machine_mode mode, unsigned int align)\n+\n+  .. hook-start:TARGET_SLOW_UNALIGNED_ACCESS\n+\n+  This hook returns true if memory accesses described by the\n+  :samp:`{mode}` and :samp:`{alignment}` parameters have a cost many times greater\n+  than aligned accesses, for example if they are emulated in a trap handler.\n+  This hook is invoked only for unaligned accesses, i.e. when\n+  ``alignment < GET_MODE_ALIGNMENT (mode)``.\n+\n+  When this hook returns true, the compiler will act as if\n+  ``STRICT_ALIGNMENT`` were true when generating code for block\n+  moves.  This can cause significantly more instructions to be produced.\n+  Therefore, do not make this hook return true if unaligned accesses only\n+  add a cycle or two to the time for a memory access.\n+\n+  The hook must return true whenever ``STRICT_ALIGNMENT`` is true.\n+  The default implementation returns ``STRICT_ALIGNMENT``.\n \n+.. hook-end\n \n .. c:macro:: MOVE_RATIO (speed)\n \n@@ -122,20 +181,69 @@ ordinarily expect.\n \n   If you don't define this, a reasonable default is used.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_USE_BY_PIECES_INFRASTRUCTURE_P]\n-  :end-before: [TARGET_USE_BY_PIECES_INFRASTRUCTURE_P]\n+.. function:: bool TARGET_USE_BY_PIECES_INFRASTRUCTURE_P (unsigned HOST_WIDE_INT size, unsigned int alignment, enum by_pieces_operation op, bool speed_p)\n+\n+  .. hook-start:TARGET_USE_BY_PIECES_INFRASTRUCTURE_P\n+\n+  GCC will attempt several strategies when asked to copy between\n+  two areas of memory, or to set, clear or store to memory, for example\n+  when copying a ``struct``. The ``by_pieces`` infrastructure\n+  implements such memory operations as a sequence of load, store or move\n+  insns.  Alternate strategies are to expand the\n+  ``cpymem`` or ``setmem`` optabs, to emit a library call, or to emit\n+  unit-by-unit, loop-based operations.\n+\n+  This target hook should return true if, for a memory operation with a\n+  given :samp:`{size}` and :samp:`{alignment}`, using the ``by_pieces``\n+  infrastructure is expected to result in better code generation.\n+  Both :samp:`{size}` and :samp:`{alignment}` are measured in terms of storage\n+  units.\n+\n+  The parameter :samp:`{op}` is one of: ``CLEAR_BY_PIECES``,\n+  ``MOVE_BY_PIECES``, ``SET_BY_PIECES``, ``STORE_BY_PIECES`` or\n+  ``COMPARE_BY_PIECES``.  These describe the type of memory operation\n+  under consideration.\n+\n+  The parameter :samp:`{speed_p}` is true if the code is currently being\n+  optimized for speed rather than size.\n+\n+  Returning true for higher values of :samp:`{size}` can improve code generation\n+  for speed if the target does not provide an implementation of the\n+  ``cpymem`` or ``setmem`` standard names, if the ``cpymem`` or\n+  ``setmem`` implementation would be more expensive than a sequence of\n+  insns, or if the overhead of a library call would dominate that of\n+  the body of the memory operation.\n+\n+  Returning true for higher values of ``size`` may also cause an increase\n+  in code size, for example where the number of insns emitted to perform a\n+  move would be greater than that of a library call.\n+\n+.. hook-end\n \n+.. function:: bool TARGET_OVERLAP_OP_BY_PIECES_P (void)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_OVERLAP_OP_BY_PIECES_P]\n-  :end-before: [TARGET_OVERLAP_OP_BY_PIECES_P]\n+  .. hook-start:TARGET_OVERLAP_OP_BY_PIECES_P\n \n+  This target hook should return true if when the ``by_pieces``\n+  infrastructure is used, an offset adjusted unaligned memory operation\n+  in the smallest integer mode for the last piece operation of a memory\n+  region can be generated to avoid doing more than one smaller operations.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_COMPARE_BY_PIECES_BRANCH_RATIO]\n-  :end-before: [TARGET_COMPARE_BY_PIECES_BRANCH_RATIO]\n+.. hook-end\n \n+.. function:: int TARGET_COMPARE_BY_PIECES_BRANCH_RATIO (machine_mode mode)\n+\n+  .. hook-start:TARGET_COMPARE_BY_PIECES_BRANCH_RATIO\n+\n+  When expanding a block comparison in MODE, gcc can try to reduce the\n+  number of branches at the expense of more memory operations.  This hook\n+  allows the target to override the default choice.  It should return the\n+  factor by which branches should be reduced over the plain expansion with\n+  one comparison per :samp:`{mode}` -sized piece.  A port can also prevent a\n+  particular mode from being used for block comparisons by returning a\n+  negative number from this hook.\n+\n+.. hook-end\n \n .. c:macro:: MOVE_MAX_PIECES\n \n@@ -238,46 +346,183 @@ ordinarily expect.\n   :samp:`fold_range_test ()` is optimal.  This macro defaults to true if\n   ``BRANCH_COST`` is greater than or equal to the value 2.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_OPTAB_SUPPORTED_P]\n-  :end-before: [TARGET_OPTAB_SUPPORTED_P]\n+.. function:: bool TARGET_OPTAB_SUPPORTED_P (int op, machine_mode mode1, machine_mode mode2, optimization_type opt_type)\n+\n+  .. hook-start:TARGET_OPTAB_SUPPORTED_P\n+\n+  Return true if the optimizers should use optab :samp:`{op}` with\n+  modes :samp:`{mode1}` and :samp:`{mode2}` for optimization type :samp:`{opt_type}`.\n+  The optab is known to have an associated :samp:`.md` instruction\n+  whose C condition is true.  :samp:`{mode2}` is only meaningful for conversion\n+  optabs; for direct optabs it is a copy of :samp:`{mode1}`.\n+\n+  For example, when called with :samp:`{op}` equal to ``rint_optab`` and\n+  :samp:`{mode1}` equal to ``DFmode``, the hook should say whether the\n+  optimizers should use optab ``rintdf2``.\n+\n+  The default hook returns true for all inputs.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_RTX_COSTS (rtx x, machine_mode mode, int outer_code, int opno, int *total, bool speed)\n+\n+  .. hook-start:TARGET_RTX_COSTS\n+\n+  This target hook describes the relative costs of RTL expressions.\n+\n+  The cost may depend on the precise form of the expression, which is\n+  available for examination in :samp:`{x}`, and the fact that :samp:`{x}` appears\n+  as operand :samp:`{opno}` of an expression with rtx code :samp:`{outer_code}`.\n+  That is, the hook can assume that there is some rtx :samp:`{y}` such\n+  that :samp:`GET_CODE ({y}) == {outer_code}` and such that\n+  either (a) :samp:`XEXP ({y}, {opno}) == {x}` or\n+  (b) :samp:`XVEC ({y}, {opno})` contains :samp:`{x}`.\n+\n+  :samp:`{mode}` is :samp:`{x}` 's machine mode, or for cases like ``const_int`` that\n+  do not have a mode, the mode in which :samp:`{x}` is used.\n+\n+  In implementing this hook, you can use the construct\n+  ``COSTS_N_INSNS (n)`` to specify a cost equal to :samp:`{n}` fast\n+  instructions.\n+\n+  On entry to the hook, ``*total`` contains a default estimate\n+  for the cost of the expression.  The hook should modify this value as\n+  necessary.  Traditionally, the default costs are ``COSTS_N_INSNS (5)``\n+  for multiplications, ``COSTS_N_INSNS (7)`` for division and modulus\n+  operations, and ``COSTS_N_INSNS (1)`` for all other operations.\n+\n+  When optimizing for code size, i.e. when ``speed`` is\n+  false, this target hook should be used to estimate the relative\n+  size cost of an expression, again relative to ``COSTS_N_INSNS``.\n+\n+  The hook returns true when all subexpressions of :samp:`{x}` have been\n+  processed, and false when ``rtx_cost`` should recurse.\n+\n+.. hook-end\n+\n+.. function:: int TARGET_ADDRESS_COST (rtx address, machine_mode mode, addr_space_t as, bool speed)\n+\n+  .. hook-start:TARGET_ADDRESS_COST\n+\n+  This hook computes the cost of an addressing mode that contains\n+  :samp:`{address}`.  If not defined, the cost is computed from\n+  the :samp:`{address}` expression and the ``TARGET_RTX_COST`` hook.\n+\n+  For most CISC machines, the default cost is a good approximation of the\n+  true cost of the addressing mode.  However, on RISC machines, all\n+  instructions normally have the same length and execution time.  Hence\n+  all addresses will have equal costs.\n+\n+  In cases where more than one form of an address is known, the form with\n+  the lowest cost will be used.  If multiple forms have the same, lowest,\n+  cost, the one that is the most complex will be used.\n+\n+  For example, suppose an address that is equal to the sum of a register\n+  and a constant is used twice in the same basic block.  When this macro\n+  is not defined, the address will be computed in a register and memory\n+  references will be indirect through that register.  On machines where\n+  the cost of the addressing mode containing the sum is no higher than\n+  that of a simple indirect reference, this will produce an additional\n+  instruction and possibly require an additional register.  Proper\n+  specification of this macro eliminates this overhead for such machines.\n+\n+  This hook is never called with an invalid address.\n+\n+  On machines where an address involving more than one register is as\n+  cheap as an address computation involving only one register, defining\n+  ``TARGET_ADDRESS_COST`` to reflect this can cause two registers to\n+  be live over a region of code where only one would have been if\n+  ``TARGET_ADDRESS_COST`` were not defined in that manner.  This effect\n+  should be considered in the definition of this macro.  Equivalent costs\n+  should probably only be given to addresses with different numbers of\n+  registers on machines with lots of registers.\n+\n+.. hook-end\n+\n+.. function:: int TARGET_INSN_COST (rtx_insn *insn, bool speed)\n+\n+  .. hook-start:TARGET_INSN_COST\n+\n+  This target hook describes the relative costs of RTL instructions.\n+\n+  In implementing this hook, you can use the construct\n+  ``COSTS_N_INSNS (n)`` to specify a cost equal to :samp:`{n}` fast\n+  instructions.\n+\n+  When optimizing for code size, i.e. when ``speed`` is\n+  false, this target hook should be used to estimate the relative\n+  size cost of an expression, again relative to ``COSTS_N_INSNS``.\n+\n+.. hook-end\n+\n+.. function:: unsigned int TARGET_MAX_NOCE_IFCVT_SEQ_COST (edge e)\n+\n+  .. hook-start:TARGET_MAX_NOCE_IFCVT_SEQ_COST\n+\n+  This hook returns a value in the same units as ``TARGET_RTX_COSTS``,\n+  giving the maximum acceptable cost for a sequence generated by the RTL\n+  if-conversion pass when conditional execution is not available.\n+  The RTL if-conversion pass attempts to convert conditional operations\n+  that would require a branch to a series of unconditional operations and\n+  ``movmodecc`` insns.  This hook returns the maximum cost of the\n+  unconditional instructions and the ``movmodecc`` insns.\n+  RTL if-conversion is cancelled if the cost of the converted sequence\n+  is greater than the value returned by this hook.\n+\n+  ``e`` is the edge between the basic block containing the conditional\n+  branch to the basic block which would be executed if the condition\n+  were true.\n+\n+  The default implementation of this hook uses the\n+  ``max-rtl-if-conversion-[un]predictable`` parameters if they are set,\n+  and uses a multiple of ``BRANCH_COST`` otherwise.\n+\n+.. hook-end\n \n+.. function:: bool TARGET_NOCE_CONVERSION_PROFITABLE_P (rtx_insn *seq, struct noce_if_info *if_info)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_RTX_COSTS]\n-  :end-before: [TARGET_RTX_COSTS]\n+  .. hook-start:TARGET_NOCE_CONVERSION_PROFITABLE_P\n \n+  This hook returns true if the instruction sequence ``seq`` is a good\n+  candidate as a replacement for the if-convertible sequence described in\n+  ``if_info``.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_ADDRESS_COST]\n-  :end-before: [TARGET_ADDRESS_COST]\n+.. hook-end\n \n+.. function:: bool TARGET_NEW_ADDRESS_PROFITABLE_P (rtx memref, rtx_insn * insn, rtx new_addr)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_INSN_COST]\n-  :end-before: [TARGET_INSN_COST]\n+  .. hook-start:TARGET_NEW_ADDRESS_PROFITABLE_P\n \n+  Return ``true`` if it is profitable to replace the address in\n+  :samp:`{memref}` with :samp:`{new_addr}`.  This allows targets to prevent the\n+  scheduler from undoing address optimizations.  The instruction containing the\n+  memref is :samp:`{insn}`.  The default implementation returns ``true``.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_MAX_NOCE_IFCVT_SEQ_COST]\n-  :end-before: [TARGET_MAX_NOCE_IFCVT_SEQ_COST]\n+.. hook-end\n \n+.. function:: bool TARGET_NO_SPECULATION_IN_DELAY_SLOTS_P (void)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_NOCE_CONVERSION_PROFITABLE_P]\n-  :end-before: [TARGET_NOCE_CONVERSION_PROFITABLE_P]\n+  .. hook-start:TARGET_NO_SPECULATION_IN_DELAY_SLOTS_P\n \n+  This predicate controls the use of the eager delay slot filler to disallow\n+  speculatively executed instructions being placed in delay slots.  Targets\n+  such as certain MIPS architectures possess both branches with and without\n+  delay slots.  As the eager delay slot filler can decrease performance,\n+  disabling it is beneficial when ordinary branches are available.  Use of\n+  delay slot branches filled using the basic filler is often still desirable\n+  as the delay slot can hide a pipeline bubble.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_NEW_ADDRESS_PROFITABLE_P]\n-  :end-before: [TARGET_NEW_ADDRESS_PROFITABLE_P]\n+.. hook-end\n \n+.. function:: HOST_WIDE_INT TARGET_ESTIMATED_POLY_VALUE (poly_int64 val, poly_value_estimate_kind kind)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_NO_SPECULATION_IN_DELAY_SLOTS_P]\n-  :end-before: [TARGET_NO_SPECULATION_IN_DELAY_SLOTS_P]\n+  .. hook-start:TARGET_ESTIMATED_POLY_VALUE\n \n+  Return an estimate of the runtime value of :samp:`{val}`, for use in\n+  things like cost calculations or profiling frequencies.  :samp:`{kind}` is used\n+  to ask for the minimum, maximum, and likely estimates of the value through\n+  the ``POLY_VALUE_MIN``, ``POLY_VALUE_MAX`` and\n+  ``POLY_VALUE_LIKELY`` values.  The default\n+  implementation returns the lowest possible value of :samp:`{val}`.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_ESTIMATED_POLY_VALUE]\n-  :end-before: [TARGET_ESTIMATED_POLY_VALUE]\n+.. hook-end\n\\ No newline at end of file"}, {"sha": "f5adf3d0f80844eecc1c80324cd35d6f7b744949", "filename": "gcc/doc/gccint/target-macros/dividing-the-output-into-sections-texts-data.rst", "status": "modified", "additions": 211, "deletions": 51, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fdividing-the-output-into-sections-texts-data.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fdividing-the-output-into-sections-texts-data.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fdividing-the-output-into-sections-texts-data.rst?ref=3e070cff11f81051e70b613816075b66a6de61c2", "patch": "@@ -191,25 +191,65 @@ if the target does not provide them.\n \n   This macro is irrelevant if there is no separate readonly data section.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_ASM_INIT_SECTIONS]\n-  :end-before: [TARGET_ASM_INIT_SECTIONS]\n+.. function:: void TARGET_ASM_INIT_SECTIONS (void)\n \n+  .. hook-start:TARGET_ASM_INIT_SECTIONS\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_ASM_RELOC_RW_MASK]\n-  :end-before: [TARGET_ASM_RELOC_RW_MASK]\n+  Define this hook if you need to do something special to set up the\n+  :samp:`varasm.cc` sections, or if your target has some special sections\n+  of its own that you need to create.\n \n+  GCC calls this hook after processing the command line, but before writing\n+  any assembly code, and before calling any of the section-returning hooks\n+  described below.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_ASM_GENERATE_PIC_ADDR_DIFF_VEC]\n-  :end-before: [TARGET_ASM_GENERATE_PIC_ADDR_DIFF_VEC]\n+.. hook-end\n \n+.. function:: int TARGET_ASM_RELOC_RW_MASK (void)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_ASM_SELECT_SECTION]\n-  :end-before: [TARGET_ASM_SELECT_SECTION]\n+  .. hook-start:TARGET_ASM_RELOC_RW_MASK\n \n+  Return a mask describing how relocations should be treated when\n+  selecting sections.  Bit 1 should be set if global relocations\n+  should be placed in a read-write section; bit 0 should be set if\n+  local relocations should be placed in a read-write section.\n+\n+  The default version of this function returns 3 when :option:`-fpic`\n+  is in effect, and 0 otherwise.  The hook is typically redefined\n+  when the target cannot support (some kinds of) dynamic relocations\n+  in read-only sections even in executables.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_ASM_GENERATE_PIC_ADDR_DIFF_VEC (void)\n+\n+  .. hook-start:TARGET_ASM_GENERATE_PIC_ADDR_DIFF_VEC\n+\n+  Return true to generate ADDR_DIF_VEC table\n+  or false to generate ADDR_VEC table for jumps in case of -fPIC.\n+\n+  The default version of this function returns true if flag_pic\n+  equals true and false otherwise\n+\n+.. hook-end\n+\n+.. function:: section * TARGET_ASM_SELECT_SECTION (tree exp, int reloc, unsigned HOST_WIDE_INT align)\n+\n+  .. hook-start:TARGET_ASM_SELECT_SECTION\n+\n+  Return the section into which :samp:`{exp}` should be placed.  You can\n+  assume that :samp:`{exp}` is either a ``VAR_DECL`` node or a constant of\n+  some sort.  :samp:`{reloc}` indicates whether the initial value of :samp:`{exp}`\n+  requires link-time relocations.  Bit 0 is set when variable contains\n+  local relocations only, while bit 1 is set for global relocations.\n+  :samp:`{align}` is the constant alignment in bits.\n+\n+  The default version of this function takes care of putting read-only\n+  variables in ``readonly_data_section``.\n+\n+  See also :samp:`{USE_SELECT_SECTION_FOR_FUNCTIONS}`.\n+\n+.. hook-end\n \n .. c:macro:: USE_SELECT_SECTION_FOR_FUNCTIONS\n \n@@ -220,66 +260,186 @@ if the target does not provide them.\n   function has been determined to be likely to be called, and nonzero if\n   it is unlikely to be called.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_ASM_UNIQUE_SECTION]\n-  :end-before: [TARGET_ASM_UNIQUE_SECTION]\n+.. function:: void TARGET_ASM_UNIQUE_SECTION (tree decl, int reloc)\n+\n+  .. hook-start:TARGET_ASM_UNIQUE_SECTION\n+\n+  Build up a unique section name, expressed as a ``STRING_CST`` node,\n+  and assign it to :samp:`DECL_SECTION_NAME ({decl})`.\n+  As with ``TARGET_ASM_SELECT_SECTION``, :samp:`{reloc}` indicates whether\n+  the initial value of :samp:`{exp}` requires link-time relocations.\n+\n+  The default version of this function appends the symbol name to the\n+  ELF section name that would normally be used for the symbol.  For\n+  example, the function ``foo`` would be placed in ``.text.foo``.\n+  Whatever the actual target object format, this is often good enough.\n+\n+.. hook-end\n+\n+.. function:: section * TARGET_ASM_FUNCTION_RODATA_SECTION (tree decl, bool relocatable)\n+\n+  .. hook-start:TARGET_ASM_FUNCTION_RODATA_SECTION\n+\n+  Return the readonly data or reloc readonly data section associated with\n+  :samp:`DECL_SECTION_NAME ({decl})`. :samp:`{relocatable}` selects the latter\n+  over the former.\n+  The default version of this function selects ``.gnu.linkonce.r.name`` if\n+  the function's section is ``.gnu.linkonce.t.name``, ``.rodata.name``\n+  or ``.data.rel.ro.name`` if function is in ``.text.name``, and\n+  the normal readonly-data or reloc readonly data section otherwise.\n+\n+.. hook-end\n+\n+.. c:var:: const char * TARGET_ASM_MERGEABLE_RODATA_PREFIX\n+\n+  .. hook-start:TARGET_ASM_MERGEABLE_RODATA_PREFIX\n+\n+  Usually, the compiler uses the prefix ``\".rodata\"`` to construct\n+  section names for mergeable constant data.  Define this macro to override\n+  the string if a different section name should be used.\n+\n+.. hook-end\n+\n+.. function:: section * TARGET_ASM_TM_CLONE_TABLE_SECTION (void)\n+\n+  .. hook-start:TARGET_ASM_TM_CLONE_TABLE_SECTION\n+\n+  Return the section that should be used for transactional memory clone\n+  tables.\n+\n+.. hook-end\n+\n+.. function:: section * TARGET_ASM_SELECT_RTX_SECTION (machine_mode mode, rtx x, unsigned HOST_WIDE_INT align)\n+\n+  .. hook-start:TARGET_ASM_SELECT_RTX_SECTION\n+\n+  Return the section into which a constant :samp:`{x}`, of mode :samp:`{mode}`,\n+  should be placed.  You can assume that :samp:`{x}` is some kind of\n+  constant in RTL.  The argument :samp:`{mode}` is redundant except in the\n+  case of a ``const_int`` rtx.  :samp:`{align}` is the constant alignment\n+  in bits.\n+\n+  The default version of this function takes care of putting symbolic\n+  constants in ``flag_pic`` mode in ``data_section`` and everything\n+  else in ``readonly_data_section``.\n+\n+.. hook-end\n+\n+.. function:: tree TARGET_MANGLE_DECL_ASSEMBLER_NAME (tree decl, tree id)\n+\n+  .. hook-start:TARGET_MANGLE_DECL_ASSEMBLER_NAME\n+\n+  Define this hook if you need to postprocess the assembler name generated\n+  by target-independent code.  The :samp:`{id}` provided to this hook will be\n+  the computed name (e.g., the macro ``DECL_NAME`` of the :samp:`{decl}` in C,\n+  or the mangled name of the :samp:`{decl}` in C++).  The return value of the\n+  hook is an ``IDENTIFIER_NODE`` for the appropriate mangled name on\n+  your target system.  The default implementation of this hook just\n+  returns the :samp:`{id}` provided.\n+\n+.. hook-end\n+\n+.. function:: void TARGET_ENCODE_SECTION_INFO (tree decl, rtx rtl, int new_decl_p)\n+\n+  .. hook-start:TARGET_ENCODE_SECTION_INFO\n+\n+  Define this hook if references to a symbol or a constant must be\n+  treated differently depending on something about the variable or\n+  function named by the symbol (such as what section it is in).\n+\n+  The hook is executed immediately after rtl has been created for\n+  :samp:`{decl}`, which may be a variable or function declaration or\n+  an entry in the constant pool.  In either case, :samp:`{rtl}` is the\n+  rtl in question.  Do *not* use ``DECL_RTL (decl)``\n+  in this hook; that field may not have been initialized yet.\n+\n+  In the case of a constant, it is safe to assume that the rtl is\n+  a ``mem`` whose address is a ``symbol_ref``.  Most decls\n+  will also have this form, but that is not guaranteed.  Global\n+  register variables, for instance, will have a ``reg`` for their\n+  rtl.  (Normally the right thing to do with such unusual rtl is\n+  leave it alone.)\n+\n+  The :samp:`{new_decl_p}` argument will be true if this is the first time\n+  that ``TARGET_ENCODE_SECTION_INFO`` has been invoked on this decl.  It will\n+  be false for subsequent invocations, which will happen for duplicate\n+  declarations.  Whether or not anything must be done for the duplicate\n+  declaration depends on whether the hook examines ``DECL_ATTRIBUTES``.\n+  :samp:`{new_decl_p}` is always true when the hook is called for a constant.\n+\n+  .. index:: SYMBOL_REF_FLAG, in TARGET_ENCODE_SECTION_INFO\n+\n+  The usual thing for this hook to do is to record flags in the\n+  ``symbol_ref``, using ``SYMBOL_REF_FLAG`` or ``SYMBOL_REF_FLAGS``.\n+  Historically, the name string was modified if it was necessary to\n+  encode more than one bit of information, but this practice is now\n+  discouraged; use ``SYMBOL_REF_FLAGS``.\n+\n+  The default definition of this hook, ``default_encode_section_info``\n+  in :samp:`varasm.cc`, sets a number of commonly-useful bits in\n+  ``SYMBOL_REF_FLAGS``.  Check whether the default does what you need\n+  before overriding it.\n+\n+.. hook-end\n+\n+.. function:: const char * TARGET_STRIP_NAME_ENCODING (const char *name)\n+\n+  .. hook-start:TARGET_STRIP_NAME_ENCODING\n \n+  Decode :samp:`{name}` and return the real name part, sans\n+  the characters that ``TARGET_ENCODE_SECTION_INFO``\n+  may have added.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_ASM_FUNCTION_RODATA_SECTION]\n-  :end-before: [TARGET_ASM_FUNCTION_RODATA_SECTION]\n+.. hook-end\n \n+.. function:: bool TARGET_IN_SMALL_DATA_P (const_tree exp)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_ASM_MERGEABLE_RODATA_PREFIX]\n-  :end-before: [TARGET_ASM_MERGEABLE_RODATA_PREFIX]\n+  .. hook-start:TARGET_IN_SMALL_DATA_P\n \n+  Returns true if :samp:`{exp}` should be placed into a 'small data' section.\n+  The default version of this hook always returns false.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_ASM_TM_CLONE_TABLE_SECTION]\n-  :end-before: [TARGET_ASM_TM_CLONE_TABLE_SECTION]\n+.. hook-end\n \n+.. c:var:: bool TARGET_HAVE_SRODATA_SECTION\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_ASM_SELECT_RTX_SECTION]\n-  :end-before: [TARGET_ASM_SELECT_RTX_SECTION]\n+  .. hook-start:TARGET_HAVE_SRODATA_SECTION\n \n+  Contains the value true if the target places read-only\n+  'small data' into a separate section.  The default value is false.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_MANGLE_DECL_ASSEMBLER_NAME]\n-  :end-before: [TARGET_MANGLE_DECL_ASSEMBLER_NAME]\n+.. hook-end\n \n+.. function:: bool TARGET_PROFILE_BEFORE_PROLOGUE (void)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_ENCODE_SECTION_INFO]\n-  :end-before: [TARGET_ENCODE_SECTION_INFO]\n+  .. hook-start:TARGET_PROFILE_BEFORE_PROLOGUE\n \n+  It returns true if target wants profile code emitted before prologue.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_STRIP_NAME_ENCODING]\n-  :end-before: [TARGET_STRIP_NAME_ENCODING]\n+  The default version of this hook use the target macro\n+  ``PROFILE_BEFORE_PROLOGUE``.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_IN_SMALL_DATA_P]\n-  :end-before: [TARGET_IN_SMALL_DATA_P]\n+.. function:: bool TARGET_BINDS_LOCAL_P (const_tree exp)\n \n+  .. hook-start:TARGET_BINDS_LOCAL_P\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_HAVE_SRODATA_SECTION]\n-  :end-before: [TARGET_HAVE_SRODATA_SECTION]\n+  Returns true if :samp:`{exp}` names an object for which name resolution\n+  rules must resolve to the current 'module' (dynamic shared library\n+  or executable image).\n \n+  The default version of this hook implements the name resolution rules\n+  for ELF, which has a looser model of global name binding than other\n+  currently supported object file formats.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_PROFILE_BEFORE_PROLOGUE]\n-  :end-before: [TARGET_PROFILE_BEFORE_PROLOGUE]\n+.. hook-end\n \n+.. c:var:: bool TARGET_HAVE_TLS\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_BINDS_LOCAL_P]\n-  :end-before: [TARGET_BINDS_LOCAL_P]\n+  .. hook-start:TARGET_HAVE_TLS\n \n+  Contains the value true if the target supports thread-local storage.\n+  The default value is false.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_HAVE_TLS]\n-  :end-before: [TARGET_HAVE_TLS]\n+.. hook-end\n\\ No newline at end of file"}, {"sha": "d8d33b00fa2becac5cc3b1b68a5af66d142f6be6", "filename": "gcc/doc/gccint/target-macros/emulating-tls.rst", "status": "modified", "additions": 83, "deletions": 30, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Femulating-tls.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Femulating-tls.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Femulating-tls.rst?ref=3e070cff11f81051e70b613816075b66a6de61c2", "patch": "@@ -22,51 +22,104 @@ object.  To access the TLS object, a lookup function is provided\n which, when given the address of the control object, will return the\n address of the current thread's instance of the TLS object.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_EMUTLS_GET_ADDRESS]\n-  :end-before: [TARGET_EMUTLS_GET_ADDRESS]\n+.. c:var:: const char * TARGET_EMUTLS_GET_ADDRESS\n \n+  .. hook-start:TARGET_EMUTLS_GET_ADDRESS\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_EMUTLS_REGISTER_COMMON]\n-  :end-before: [TARGET_EMUTLS_REGISTER_COMMON]\n+  Contains the name of the helper function that uses a TLS control\n+  object to locate a TLS instance.  The default causes libgcc's\n+  emulated TLS helper function to be used.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_EMUTLS_VAR_SECTION]\n-  :end-before: [TARGET_EMUTLS_VAR_SECTION]\n+.. c:var:: const char * TARGET_EMUTLS_REGISTER_COMMON\n \n+  .. hook-start:TARGET_EMUTLS_REGISTER_COMMON\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_EMUTLS_TMPL_SECTION]\n-  :end-before: [TARGET_EMUTLS_TMPL_SECTION]\n+  Contains the name of the helper function that should be used at\n+  program startup to register TLS objects that are implicitly\n+  initialized to zero.  If this is ``NULL``, all TLS objects will\n+  have explicit initializers.  The default causes libgcc's emulated TLS\n+  registration function to be used.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_EMUTLS_VAR_PREFIX]\n-  :end-before: [TARGET_EMUTLS_VAR_PREFIX]\n+.. c:var:: const char * TARGET_EMUTLS_VAR_SECTION\n \n+  .. hook-start:TARGET_EMUTLS_VAR_SECTION\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_EMUTLS_TMPL_PREFIX]\n-  :end-before: [TARGET_EMUTLS_TMPL_PREFIX]\n+  Contains the name of the section in which TLS control variables should\n+  be placed.  The default of ``NULL`` allows these to be placed in\n+  any section.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_EMUTLS_VAR_FIELDS]\n-  :end-before: [TARGET_EMUTLS_VAR_FIELDS]\n+.. c:var:: const char * TARGET_EMUTLS_TMPL_SECTION\n \n+  .. hook-start:TARGET_EMUTLS_TMPL_SECTION\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_EMUTLS_VAR_INIT]\n-  :end-before: [TARGET_EMUTLS_VAR_INIT]\n+  Contains the name of the section in which TLS initializers should be\n+  placed.  The default of ``NULL`` allows these to be placed in any\n+  section.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_EMUTLS_VAR_ALIGN_FIXED]\n-  :end-before: [TARGET_EMUTLS_VAR_ALIGN_FIXED]\n+.. c:var:: const char * TARGET_EMUTLS_VAR_PREFIX\n \n+  .. hook-start:TARGET_EMUTLS_VAR_PREFIX\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_EMUTLS_DEBUG_FORM_TLS_ADDRESS]\n-  :end-before: [TARGET_EMUTLS_DEBUG_FORM_TLS_ADDRESS]\n+  Contains the prefix to be prepended to TLS control variable names.\n+  The default of ``NULL`` uses a target-specific prefix.\n+\n+.. hook-end\n+\n+.. c:var:: const char * TARGET_EMUTLS_TMPL_PREFIX\n+\n+  .. hook-start:TARGET_EMUTLS_TMPL_PREFIX\n+\n+  Contains the prefix to be prepended to TLS initializer objects.  The\n+  default of ``NULL`` uses a target-specific prefix.\n+\n+.. hook-end\n+\n+.. function:: tree TARGET_EMUTLS_VAR_FIELDS (tree type, tree *name)\n+\n+  .. hook-start:TARGET_EMUTLS_VAR_FIELDS\n+\n+  Specifies a function that generates the FIELD_DECLs for a TLS control\n+  object type.  :samp:`{type}` is the RECORD_TYPE the fields are for and\n+  :samp:`{name}` should be filled with the structure tag, if the default of\n+  ``__emutls_object`` is unsuitable.  The default creates a type suitable\n+  for libgcc's emulated TLS function.\n+\n+.. hook-end\n+\n+.. function:: tree TARGET_EMUTLS_VAR_INIT (tree var, tree decl, tree tmpl_addr)\n+\n+  .. hook-start:TARGET_EMUTLS_VAR_INIT\n+\n+  Specifies a function that generates the CONSTRUCTOR to initialize a\n+  TLS control object.  :samp:`{var}` is the TLS control object, :samp:`{decl}`\n+  is the TLS object and :samp:`{tmpl_addr}` is the address of the\n+  initializer.  The default initializes libgcc's emulated TLS control object.\n+\n+.. hook-end\n+\n+.. c:var:: bool TARGET_EMUTLS_VAR_ALIGN_FIXED\n+\n+  .. hook-start:TARGET_EMUTLS_VAR_ALIGN_FIXED\n+\n+  Specifies whether the alignment of TLS control variable objects is\n+  fixed and should not be increased as some backends may do to optimize\n+  single objects.  The default is false.\n+\n+.. hook-end\n+\n+.. c:var:: bool TARGET_EMUTLS_DEBUG_FORM_TLS_ADDRESS\n+\n+  .. hook-start:TARGET_EMUTLS_DEBUG_FORM_TLS_ADDRESS\n+\n+  Specifies whether a DWARF ``DW_OP_form_tls_address`` location descriptor\n+  may be used to describe emulated TLS control objects.\n+\n+.. hook-end\n\\ No newline at end of file"}, {"sha": "e64357f1505b7e5563cc428806fdb111d9d39307", "filename": "gcc/doc/gccint/target-macros/implementing-the-varargs-macros.rst", "status": "modified", "additions": 104, "deletions": 18, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fimplementing-the-varargs-macros.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fimplementing-the-varargs-macros.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fimplementing-the-varargs-macros.rst?ref=3e070cff11f81051e70b613816075b66a6de61c2", "patch": "@@ -76,31 +76,117 @@ below.\n \n These machine description macros help implement varargs:\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_EXPAND_BUILTIN_SAVEREGS]\n-  :end-before: [TARGET_EXPAND_BUILTIN_SAVEREGS]\n+.. function:: rtx TARGET_EXPAND_BUILTIN_SAVEREGS (void)\n \n+  .. hook-start:TARGET_EXPAND_BUILTIN_SAVEREGS\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SETUP_INCOMING_VARARGS]\n-  :end-before: [TARGET_SETUP_INCOMING_VARARGS]\n+  If defined, this hook produces the machine-specific code for a call to\n+  ``__builtin_saveregs``.  This code will be moved to the very\n+  beginning of the function, before any parameter access are made.  The\n+  return value of this function should be an RTX that contains the value\n+  to use as the return of ``__builtin_saveregs``.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_STRICT_ARGUMENT_NAMING]\n-  :end-before: [TARGET_STRICT_ARGUMENT_NAMING]\n+.. function:: void TARGET_SETUP_INCOMING_VARARGS (cumulative_args_t args_so_far, const function_arg_info &arg, int *pretend_args_size, int second_time)\n \n+  .. hook-start:TARGET_SETUP_INCOMING_VARARGS\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_CALL_ARGS]\n-  :end-before: [TARGET_CALL_ARGS]\n+  This target hook offers an alternative to using\n+  ``__builtin_saveregs`` and defining the hook\n+  ``TARGET_EXPAND_BUILTIN_SAVEREGS``.  Use it to store the anonymous\n+  register arguments into the stack so that all the arguments appear to\n+  have been passed consecutively on the stack.  Once this is done, you can\n+  use the standard implementation of varargs that works for machines that\n+  pass all their arguments on the stack.\n \n+  The argument :samp:`{args_so_far}` points to the ``CUMULATIVE_ARGS`` data\n+  structure, containing the values that are obtained after processing the\n+  named arguments.  The argument :samp:`{arg}` describes the last of these named\n+  arguments.  The argument :samp:`{arg}` should not be used if the function type\n+  satisfies ``TYPE_NO_NAMED_ARGS_STDARG_P``, since in that case there are\n+  no named arguments and all arguments are accessed with ``va_arg``.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_END_CALL_ARGS]\n-  :end-before: [TARGET_END_CALL_ARGS]\n+  The target hook should do two things: first, push onto the stack all the\n+  argument registers *not* used for the named arguments, and second,\n+  store the size of the data thus pushed into the ``int`` -valued\n+  variable pointed to by :samp:`{pretend_args_size}`.  The value that you\n+  store here will serve as additional offset for setting up the stack\n+  frame.\n \n+  Because you must generate code to push the anonymous arguments at\n+  compile time without knowing their data types,\n+  ``TARGET_SETUP_INCOMING_VARARGS`` is only useful on machines that\n+  have just a single category of argument register and use it uniformly\n+  for all data types.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_PRETEND_OUTGOING_VARARGS_NAMED]\n-  :end-before: [TARGET_PRETEND_OUTGOING_VARARGS_NAMED]\n+  If the argument :samp:`{second_time}` is nonzero, it means that the\n+  arguments of the function are being analyzed for the second time.  This\n+  happens for an inline function, which is not actually compiled until the\n+  end of the source file.  The hook ``TARGET_SETUP_INCOMING_VARARGS`` should\n+  not generate any instructions in this case.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_STRICT_ARGUMENT_NAMING (cumulative_args_t ca)\n+\n+  .. hook-start:TARGET_STRICT_ARGUMENT_NAMING\n+\n+  Define this hook to return ``true`` if the location where a function\n+  argument is passed depends on whether or not it is a named argument.\n+\n+  This hook controls how the :samp:`{named}` argument to ``TARGET_FUNCTION_ARG``\n+  is set for varargs and stdarg functions.  If this hook returns\n+  ``true``, the :samp:`{named}` argument is always true for named\n+  arguments, and false for unnamed arguments.  If it returns ``false``,\n+  but ``TARGET_PRETEND_OUTGOING_VARARGS_NAMED`` returns ``true``,\n+  then all arguments are treated as named.  Otherwise, all named arguments\n+  except the last are treated as named.\n+\n+  You need not define this hook if it always returns ``false``.\n+\n+.. hook-end\n+\n+.. function:: void TARGET_CALL_ARGS (rtx, tree)\n+\n+  .. hook-start:TARGET_CALL_ARGS\n+\n+  While generating RTL for a function call, this target hook is invoked once\n+  for each argument passed to the function, either a register returned by\n+  ``TARGET_FUNCTION_ARG`` or a memory location.  It is called just\n+  before the point where argument registers are stored.  The type of the\n+  function to be called is also passed as the second argument; it is\n+  ``NULL_TREE`` for libcalls.  The ``TARGET_END_CALL_ARGS`` hook is\n+  invoked just after the code to copy the return reg has been emitted.\n+  This functionality can be used to perform special setup of call argument\n+  registers if a target needs it.\n+  For functions without arguments, the hook is called once with ``pc_rtx``\n+  passed instead of an argument register.\n+  Most ports do not need to implement anything for this hook.\n+\n+.. hook-end\n+\n+.. function:: void TARGET_END_CALL_ARGS (void)\n+\n+  .. hook-start:TARGET_END_CALL_ARGS\n+\n+  This target hook is invoked while generating RTL for a function call,\n+  just after the point where the return reg is copied into a pseudo.  It\n+  signals that all the call argument and return registers for the just\n+  emitted call are now no longer in use.\n+  Most ports do not need to implement anything for this hook.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_PRETEND_OUTGOING_VARARGS_NAMED (cumulative_args_t ca)\n+\n+  .. hook-start:TARGET_PRETEND_OUTGOING_VARARGS_NAMED\n+\n+  If you need to conditionally change ABIs so that one works with\n+  ``TARGET_SETUP_INCOMING_VARARGS``, but the other works like neither\n+  ``TARGET_SETUP_INCOMING_VARARGS`` nor ``TARGET_STRICT_ARGUMENT_NAMING`` was\n+  defined, then define this hook to return ``true`` if\n+  ``TARGET_SETUP_INCOMING_VARARGS`` is used, ``false`` otherwise.\n+  Otherwise, you should not define this hook.\n+\n+.. hook-end\n\\ No newline at end of file"}, {"sha": "cefd33d3814937ec9c698d9028de03c5c07e8d28", "filename": "gcc/doc/gccint/target-macros/implicit-calls-to-library-routines.rst", "status": "modified", "additions": 40, "deletions": 12, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fimplicit-calls-to-library-routines.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fimplicit-calls-to-library-routines.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fimplicit-calls-to-library-routines.rst?ref=3e070cff11f81051e70b613816075b66a6de61c2", "patch": "@@ -23,15 +23,32 @@ Here is an explanation of implicit calls to library routines.\n \n .. index:: set_optab_libfunc, init_one_libfunc\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_INIT_LIBFUNCS]\n-  :end-before: [TARGET_INIT_LIBFUNCS]\n+.. function:: void TARGET_INIT_LIBFUNCS (void)\n \n+  .. hook-start:TARGET_INIT_LIBFUNCS\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_LIBFUNC_GNU_PREFIX]\n-  :end-before: [TARGET_LIBFUNC_GNU_PREFIX]\n+  This hook should declare additional library routines or rename\n+  existing ones, using the functions ``set_optab_libfunc`` and\n+  ``init_one_libfunc`` defined in :samp:`optabs.cc`.\n+  ``init_optabs`` calls this macro after initializing all the normal\n+  library routines.\n \n+  The default is to do nothing.  Most ports don't need to define this hook.\n+\n+.. hook-end\n+\n+.. c:var:: bool TARGET_LIBFUNC_GNU_PREFIX\n+\n+  .. hook-start:TARGET_LIBFUNC_GNU_PREFIX\n+\n+  If false (the default), internal library routines start with two\n+  underscores.  If set to true, these routines start with ``__gnu_``\n+  instead.  E.g., ``__muldi3`` changes to ``__gnu_muldi3``.  This\n+  currently only affects functions defined in :samp:`libgcc2.c`.  If this\n+  is set to true, the :samp:`tm.h` file must also\n+  ``#define LIBGCC2_GNU_PREFIX``.\n+\n+.. hook-end\n \n .. c:macro:: FLOAT_LIB_COMPARE_RETURNS_BOOL (mode, comparison)\n \n@@ -87,15 +104,26 @@ Here is an explanation of implicit calls to library routines.\n   ``errno`` may not actually be a variable.)  If you don't define this\n   macro, a reasonable default is used.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_LIBC_HAS_FUNCTION]\n-  :end-before: [TARGET_LIBC_HAS_FUNCTION]\n+.. function:: bool TARGET_LIBC_HAS_FUNCTION (enum function_class fn_class, tree type)\n+\n+  .. hook-start:TARGET_LIBC_HAS_FUNCTION\n+\n+  This hook determines whether a function from a class of functions\n+  :samp:`{fn_class}` is present in the target C library.  If :samp:`{type}` is NULL,\n+  the caller asks for support for all standard (float, double, long double)\n+  types.  If :samp:`{type}` is non-NULL, the caller asks for support for a\n+  specific type.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_LIBC_HAS_FAST_FUNCTION (int fcode)\n \n+  .. hook-start:TARGET_LIBC_HAS_FAST_FUNCTION\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_LIBC_HAS_FAST_FUNCTION]\n-  :end-before: [TARGET_LIBC_HAS_FAST_FUNCTION]\n+  This hook determines whether a function from a class of functions\n+   ``(enum function_class)``:samp:`{fcode}` has a fast implementation.\n \n+.. hook-end\n \n .. c:macro:: NEXT_OBJC_RUNTIME\n "}, {"sha": "082293c6b4fcb300bfc5c9d167a26b1d34305f48", "filename": "gcc/doc/gccint/target-macros/layout-of-source-language-data-types.rst", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Flayout-of-source-language-data-types.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Flayout-of-source-language-data-types.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Flayout-of-source-language-data-types.rst?ref=3e070cff11f81051e70b613816075b66a6de61c2", "patch": "@@ -146,10 +146,18 @@ languages, rather than to fundamental aspects of storage layout.\n   always override this default with the options :option:`-fsigned-char`\n   and :option:`-funsigned-char`.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_DEFAULT_SHORT_ENUMS]\n-  :end-before: [TARGET_DEFAULT_SHORT_ENUMS]\n+.. function:: bool TARGET_DEFAULT_SHORT_ENUMS (void)\n \n+  .. hook-start:TARGET_DEFAULT_SHORT_ENUMS\n+\n+  This target hook should return true if the compiler should give an\n+  ``enum`` type only as many bytes as it takes to represent the range\n+  of possible values of that type.  It should return false if all\n+  ``enum`` types should be allocated like ``int``.\n+\n+  The default is to return false.\n+\n+.. hook-end\n \n .. c:macro:: SIZE_TYPE\n "}, {"sha": "4476d3e8f7456b9828375df41edb26674cf87b5c", "filename": "gcc/doc/gccint/target-macros/miscellaneous-parameters.rst", "status": "modified", "additions": 927, "deletions": 222, "changes": 1149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fmiscellaneous-parameters.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fmiscellaneous-parameters.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fmiscellaneous-parameters.rst?ref=3e070cff11f81051e70b613816075b66a6de61c2", "patch": "@@ -55,10 +55,16 @@ Here are several miscellaneous parameters.\n   contain relative addresses only when :option:`-fPIC` or :option:`-fPIC`\n   is in effect.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_CASE_VALUES_THRESHOLD]\n-  :end-before: [TARGET_CASE_VALUES_THRESHOLD]\n+.. function:: unsigned int TARGET_CASE_VALUES_THRESHOLD (void)\n \n+  .. hook-start:TARGET_CASE_VALUES_THRESHOLD\n+\n+  This function return the smallest number of different values for which it\n+  is best to use a jump-table instead of a tree of conditional branches.\n+  The default is four for machines with a ``casesi`` instruction and\n+  five otherwise.  This is best for most machines.\n+\n+.. hook-end\n \n .. c:macro:: WORD_REGISTER_OPERATIONS\n \n@@ -70,10 +76,26 @@ Here are several miscellaneous parameters.\n   result has a known value in ``word_mode`` too if the macro is defined\n   to 1.  Most RISC machines have this property and most CISC machines do not.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_MIN_ARITHMETIC_PRECISION]\n-  :end-before: [TARGET_MIN_ARITHMETIC_PRECISION]\n+.. function:: unsigned int TARGET_MIN_ARITHMETIC_PRECISION (void)\n+\n+  .. hook-start:TARGET_MIN_ARITHMETIC_PRECISION\n+\n+  On some RISC architectures with 64-bit registers, the processor also\n+  maintains 32-bit condition codes that make it possible to do real 32-bit\n+  arithmetic, although the operations are performed on the full registers.\n+\n+  On such architectures, defining this hook to 32 tells the compiler to try\n+  using 32-bit arithmetical operations setting the condition codes instead\n+  of doing full 64-bit arithmetic.\n+\n+  More generally, define this hook on RISC architectures if you want the\n+  compiler to try using arithmetical operations setting the condition codes\n+  with a precision lower than the word precision.\n \n+  You need not define this hook if ``WORD_REGISTER_OPERATIONS`` is not\n+  defined to 1.\n+\n+.. hook-end\n \n .. c:macro:: LOAD_EXTEND_OP (mem_mode)\n \n@@ -107,10 +129,18 @@ Here are several miscellaneous parameters.\n   Define this macro to 1 if loading short immediate values into registers sign\n   extends.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_MIN_DIVISIONS_FOR_RECIP_MUL]\n-  :end-before: [TARGET_MIN_DIVISIONS_FOR_RECIP_MUL]\n+.. function:: unsigned int TARGET_MIN_DIVISIONS_FOR_RECIP_MUL (machine_mode mode)\n+\n+  .. hook-start:TARGET_MIN_DIVISIONS_FOR_RECIP_MUL\n+\n+  When :option:`-ffast-math` is in effect, GCC tries to optimize\n+  divisions by the same divisor, by turning them into multiplications by\n+  the reciprocal.  This target hook specifies the minimum number of divisions\n+  that should be there for GCC to perform the optimization for a variable\n+  of mode :samp:`{mode}`.  The default implementation returns 3 if the machine\n+  has an instruction for the division, and 2 if it does not.\n \n+.. hook-end\n \n .. c:macro:: MOVE_MAX\n \n@@ -152,25 +182,100 @@ Here are several miscellaneous parameters.\n \n .. _target_shift_truncation_mask:\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SHIFT_TRUNCATION_MASK]\n-  :end-before: [TARGET_SHIFT_TRUNCATION_MASK]\n+.. function:: unsigned HOST_WIDE_INT TARGET_SHIFT_TRUNCATION_MASK (machine_mode mode)\n+\n+  .. hook-start:TARGET_SHIFT_TRUNCATION_MASK\n+\n+  This function describes how the standard shift patterns for :samp:`{mode}`\n+  deal with shifts by negative amounts or by more than the width of the mode.\n+  See :ref:`shift-patterns`.\n+\n+  On many machines, the shift patterns will apply a mask :samp:`{m}` to the\n+  shift count, meaning that a fixed-width shift of :samp:`{x}` by :samp:`{y}` is\n+  equivalent to an arbitrary-width shift of :samp:`{x}` by :samp:`{y & m}`.  If\n+  this is true for mode :samp:`{mode}`, the function should return :samp:`{m}`,\n+  otherwise it should return 0.  A return value of 0 indicates that no\n+  particular behavior is guaranteed.\n+\n+  Note that, unlike ``SHIFT_COUNT_TRUNCATED``, this function does\n+  *not* apply to general shift rtxes; it applies only to instructions\n+  that are generated by the named shift patterns.\n+\n+  The default implementation of this function returns\n+  ``GET_MODE_BITSIZE (mode) - 1`` if ``SHIFT_COUNT_TRUNCATED``\n+  and 0 otherwise.  This definition is always safe, but if\n+  ``SHIFT_COUNT_TRUNCATED`` is false, and some shift patterns\n+  nevertheless truncate the shift count, you may get better code\n+  by overriding it.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_TRULY_NOOP_TRUNCATION (poly_uint64 outprec, poly_uint64 inprec)\n+\n+  .. hook-start:TARGET_TRULY_NOOP_TRUNCATION\n+\n+  This hook returns true if it is safe to 'convert' a value of\n+  :samp:`{inprec}` bits to one of :samp:`{outprec}` bits (where :samp:`{outprec}` is\n+  smaller than :samp:`{inprec}`) by merely operating on it as if it had only\n+  :samp:`{outprec}` bits.  The default returns true unconditionally, which\n+  is correct for most machines.  When ``TARGET_TRULY_NOOP_TRUNCATION``\n+  returns false, the machine description should provide a ``trunc``\n+  optab to specify the RTL that performs the required truncation.\n+\n+  If ``TARGET_MODES_TIEABLE_P`` returns false for a pair of modes,\n+  suboptimal code can result if this hook returns true for the corresponding\n+  mode sizes.  Making this hook return false in such cases may improve things.\n+\n+.. hook-end\n+\n+.. function:: int TARGET_MODE_REP_EXTENDED (scalar_int_mode mode, scalar_int_mode rep_mode)\n+\n+  .. hook-start:TARGET_MODE_REP_EXTENDED\n+\n+  The representation of an integral mode can be such that the values\n+  are always extended to a wider integral mode.  Return\n+  ``SIGN_EXTEND`` if values of :samp:`{mode}` are represented in\n+  sign-extended form to :samp:`{rep_mode}`.  Return ``UNKNOWN``\n+  otherwise.  (Currently, none of the targets use zero-extended\n+  representation this way so unlike ``LOAD_EXTEND_OP``,\n+  ``TARGET_MODE_REP_EXTENDED`` is expected to return either\n+  ``SIGN_EXTEND`` or ``UNKNOWN``.  Also no target extends\n+  :samp:`{mode}` to :samp:`{rep_mode}` so that :samp:`{rep_mode}` is not the next\n+  widest integral mode and currently we take advantage of this fact.)\n+\n+  Similarly to ``LOAD_EXTEND_OP`` you may return a non- ``UNKNOWN``\n+  value even if the extension is not performed on certain hard registers\n+  as long as for the ``REGNO_REG_CLASS`` of these hard registers\n+  ``TARGET_CAN_CHANGE_MODE_CLASS`` returns false.\n \n+  Note that ``TARGET_MODE_REP_EXTENDED`` and ``LOAD_EXTEND_OP``\n+  describe two related properties.  If you define\n+  ``TARGET_MODE_REP_EXTENDED (mode, word_mode)`` you probably also want\n+  to define ``LOAD_EXTEND_OP (mode)`` to return the same type of\n+  extension.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_TRULY_NOOP_TRUNCATION]\n-  :end-before: [TARGET_TRULY_NOOP_TRUNCATION]\n+  In order to enforce the representation of ``mode``,\n+  ``TARGET_TRULY_NOOP_TRUNCATION`` should return false when truncating to\n+  ``mode``.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_MODE_REP_EXTENDED]\n-  :end-before: [TARGET_MODE_REP_EXTENDED]\n+.. function:: bool TARGET_SETJMP_PRESERVES_NONVOLATILE_REGS_P (void)\n \n+  .. hook-start:TARGET_SETJMP_PRESERVES_NONVOLATILE_REGS_P\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SETJMP_PRESERVES_NONVOLATILE_REGS_P]\n-  :end-before: [TARGET_SETJMP_PRESERVES_NONVOLATILE_REGS_P]\n+  On some targets, it is assumed that the compiler will spill all pseudos\n+  that are live across a call to ``setjmp``, while other targets treat\n+  ``setjmp`` calls as normal function calls.\n \n+  This hook returns false if ``setjmp`` calls do not preserve all\n+  non-volatile registers so that gcc that must spill all pseudos that are\n+  live across ``setjmp`` calls.  Define this to return true if the\n+  target does not need to spill all pseudos live across ``setjmp`` calls.\n+  The default implementation conservatively assumes all pseudos must be\n+  spilled across ``setjmp`` calls.\n+\n+.. hook-end\n \n .. c:macro:: STORE_FLAG_VALUE\n \n@@ -344,15 +449,34 @@ Here are several miscellaneous parameters.\n   convention when processing system header files, but when processing user\n   files ``__STDC__`` will always expand to 1.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_C_PREINCLUDE]\n-  :end-before: [TARGET_C_PREINCLUDE]\n+.. function:: const char * TARGET_C_PREINCLUDE (void)\n+\n+  .. hook-start:TARGET_C_PREINCLUDE\n+\n+  Define this hook to return the name of a header file to be included at\n+  the start of all compilations, as if it had been included with\n+  ``#include <file>``.  If this hook returns ``NULL``, or is\n+  not defined, or the header is not found, or if the user specifies\n+  :option:`-ffreestanding` or :option:`-nostdinc`, no header is included.\n+\n+  This hook can be used together with a header provided by the system C\n+  library to implement ISO C requirements for certain macros to be\n+  predefined that describe properties of the whole implementation rather\n+  than just the compiler.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_CXX_IMPLICIT_EXTERN_C (const char*)\n \n+  .. hook-start:TARGET_CXX_IMPLICIT_EXTERN_C\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_CXX_IMPLICIT_EXTERN_C]\n-  :end-before: [TARGET_CXX_IMPLICIT_EXTERN_C]\n+  Define this hook to add target-specific C++ implicit extern C functions.\n+  If this function returns true for the name of a file-scope function, that\n+  function implicitly gets extern \"C\" linkage rather than whatever language\n+  linkage the declaration would normally have.  An example of such function\n+  is WinMain on Win32 targets.\n \n+.. hook-end\n \n .. c:macro:: SYSTEM_IMPLICIT_EXTERN_C\n \n@@ -470,10 +594,23 @@ Here are several miscellaneous parameters.\n \n   You need not define this macro if it would always evaluate to zero.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_MD_ASM_ADJUST]\n-  :end-before: [TARGET_MD_ASM_ADJUST]\n+.. function:: rtx_insn * TARGET_MD_ASM_ADJUST (vec<rtx>& outputs, vec<rtx>& inputs, vec<machine_mode>& input_modes, vec<const char *>& constraints, vec<rtx>& clobbers, HARD_REG_SET& clobbered_regs, location_t loc)\n \n+  .. hook-start:TARGET_MD_ASM_ADJUST\n+\n+  This target hook may add :dfn:`clobbers` to :samp:`{clobbers}` and\n+  :samp:`{clobbered_regs}` for any hard regs the port wishes to automatically\n+  clobber for an asm.  The :samp:`{outputs}` and :samp:`{inputs}` may be inspected\n+  to avoid clobbering a register that is already used by the asm.  :samp:`{loc}`\n+  is the source location of the asm.\n+\n+  It may modify the :samp:`{outputs}`, :samp:`{inputs}`, :samp:`{input_modes}`, and\n+  :samp:`{constraints}` as necessary for other pre-processing.  In this case the\n+  return value is a sequence of insns to emit after the asm.  Note that\n+  changes to :samp:`{inputs}` must be accompanied by the corresponding changes\n+  to :samp:`{input_modes}`.\n+\n+.. hook-end\n \n .. c:macro:: MATH_LIBRARY\n \n@@ -551,125 +688,364 @@ Here are several miscellaneous parameters.\n   of the if-block in the ``struct ce_if_block`` structure that is pointed\n   to by :samp:`{ce_info}`.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_MACHINE_DEPENDENT_REORG]\n-  :end-before: [TARGET_MACHINE_DEPENDENT_REORG]\n+.. function:: void TARGET_MACHINE_DEPENDENT_REORG (void)\n+\n+  .. hook-start:TARGET_MACHINE_DEPENDENT_REORG\n+\n+  If non-null, this hook performs a target-specific pass over the\n+  instruction stream.  The compiler will run it at all optimization levels,\n+  just before the point at which it normally does delayed-branch scheduling.\n+\n+  The exact purpose of the hook varies from target to target.  Some use\n+  it to do transformations that are necessary for correctness, such as\n+  laying out in-function constant pools or avoiding hardware hazards.\n+  Others use it as an opportunity to do some machine-dependent optimizations.\n+\n+  You need not implement the hook if it has nothing to do.  The default\n+  definition is null.\n+\n+.. hook-end\n+\n+.. function:: void TARGET_INIT_BUILTINS (void)\n+\n+  .. hook-start:TARGET_INIT_BUILTINS\n+\n+  Define this hook if you have any machine-specific built-in functions\n+  that need to be defined.  It should be a function that performs the\n+  necessary setup.\n+\n+  Machine specific built-in functions can be useful to expand special machine\n+  instructions that would otherwise not normally be generated because\n+  they have no equivalent in the source language (for example, SIMD vector\n+  instructions or prefetch instructions).\n+\n+  To create a built-in function, call the function\n+  ``lang_hooks.builtin_function``\n+  which is defined by the language front end.  You can use any type nodes set\n+  up by ``build_common_tree_nodes`` ;\n+  only language front ends that use those two functions will call\n+  :samp:`TARGET_INIT_BUILTINS`.\n+\n+.. hook-end\n+\n+.. function:: tree TARGET_BUILTIN_DECL (unsigned code, bool initialize_p)\n+\n+  .. hook-start:TARGET_BUILTIN_DECL\n+\n+  Define this hook if you have any machine-specific built-in functions\n+  that need to be defined.  It should be a function that returns the\n+  builtin function declaration for the builtin function code :samp:`{code}`.\n+  If there is no such builtin and it cannot be initialized at this time\n+  if :samp:`{initialize_p}` is true the function should return ``NULL_TREE``.\n+  If :samp:`{code}` is out of range the function should return\n+  ``error_mark_node``.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_INIT_BUILTINS]\n-  :end-before: [TARGET_INIT_BUILTINS]\n+.. function:: rtx TARGET_EXPAND_BUILTIN (tree exp, rtx target, rtx subtarget, machine_mode mode, int ignore)\n \n+  .. hook-start:TARGET_EXPAND_BUILTIN\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_BUILTIN_DECL]\n-  :end-before: [TARGET_BUILTIN_DECL]\n+  Expand a call to a machine specific built-in function that was set up by\n+  :samp:`TARGET_INIT_BUILTINS`.  :samp:`{exp}` is the expression for the\n+  function call; the result should go to :samp:`{target}` if that is\n+  convenient, and have mode :samp:`{mode}` if that is convenient.\n+  :samp:`{subtarget}` may be used as the target for computing one of\n+  :samp:`{exp}` 's operands.  :samp:`{ignore}` is nonzero if the value is to be\n+  ignored.  This function should return the result of the call to the\n+  built-in function.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_EXPAND_BUILTIN]\n-  :end-before: [TARGET_EXPAND_BUILTIN]\n+.. function:: tree TARGET_RESOLVE_OVERLOADED_BUILTIN (unsigned int loc, tree fndecl, void *arglist)\n \n+  .. hook-start:TARGET_RESOLVE_OVERLOADED_BUILTIN\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_RESOLVE_OVERLOADED_BUILTIN]\n-  :end-before: [TARGET_RESOLVE_OVERLOADED_BUILTIN]\n+  Select a replacement for a machine specific built-in function that\n+  was set up by :samp:`TARGET_INIT_BUILTINS`.  This is done\n+  *before* regular type checking, and so allows the target to\n+  implement a crude form of function overloading.  :samp:`{fndecl}` is the\n+  declaration of the built-in function.  :samp:`{arglist}` is the list of\n+  arguments passed to the built-in function.  The result is a\n+  complete expression that implements the operation, usually\n+  another ``CALL_EXPR``.\n+  :samp:`{arglist}` really has type :samp:`VEC(tree,gc)*`\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_CHECK_BUILTIN_CALL]\n-  :end-before: [TARGET_CHECK_BUILTIN_CALL]\n+.. function:: bool TARGET_CHECK_BUILTIN_CALL (location_t loc, vec<location_t> arg_loc, tree fndecl, tree orig_fndecl, unsigned int nargs, tree *args)\n \n+  .. hook-start:TARGET_CHECK_BUILTIN_CALL\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_FOLD_BUILTIN]\n-  :end-before: [TARGET_FOLD_BUILTIN]\n+  Perform semantic checking on a call to a machine-specific built-in\n+  function after its arguments have been constrained to the function\n+  signature.  Return true if the call is valid, otherwise report an error\n+  and return false.\n \n+  This hook is called after ``TARGET_RESOLVE_OVERLOADED_BUILTIN``.\n+  The call was originally to built-in function :samp:`{orig_fndecl}`,\n+  but after the optional ``TARGET_RESOLVE_OVERLOADED_BUILTIN``\n+  step is now to built-in function :samp:`{fndecl}`.  :samp:`{loc}` is the\n+  location of the call and :samp:`{args}` is an array of function arguments,\n+  of which there are :samp:`{nargs}`.  :samp:`{arg_loc}` specifies the location\n+  of each argument.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_GIMPLE_FOLD_BUILTIN]\n-  :end-before: [TARGET_GIMPLE_FOLD_BUILTIN]\n+.. hook-end\n \n+.. function:: tree TARGET_FOLD_BUILTIN (tree fndecl, int n_args, tree *argp, bool ignore)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_COMPARE_VERSION_PRIORITY]\n-  :end-before: [TARGET_COMPARE_VERSION_PRIORITY]\n+  .. hook-start:TARGET_FOLD_BUILTIN\n \n+  Fold a call to a machine specific built-in function that was set up by\n+  :samp:`TARGET_INIT_BUILTINS`.  :samp:`{fndecl}` is the declaration of the\n+  built-in function.  :samp:`{n_args}` is the number of arguments passed to\n+  the function; the arguments themselves are pointed to by :samp:`{argp}`.\n+  The result is another tree, valid for both GIMPLE and GENERIC,\n+  containing a simplified expression for the call's result.  If\n+  :samp:`{ignore}` is true the value will be ignored.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_GET_FUNCTION_VERSIONS_DISPATCHER]\n-  :end-before: [TARGET_GET_FUNCTION_VERSIONS_DISPATCHER]\n+.. hook-end\n \n+.. function:: bool TARGET_GIMPLE_FOLD_BUILTIN (gimple_stmt_iterator *gsi)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_GENERATE_VERSION_DISPATCHER_BODY]\n-  :end-before: [TARGET_GENERATE_VERSION_DISPATCHER_BODY]\n+  .. hook-start:TARGET_GIMPLE_FOLD_BUILTIN\n \n+  Fold a call to a machine specific built-in function that was set up\n+  by :samp:`TARGET_INIT_BUILTINS`.  :samp:`{gsi}` points to the gimple\n+  statement holding the function call.  Returns true if any change\n+  was made to the GIMPLE stream.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_PREDICT_DOLOOP_P]\n-  :end-before: [TARGET_PREDICT_DOLOOP_P]\n+.. hook-end\n \n+.. function:: int TARGET_COMPARE_VERSION_PRIORITY (tree decl1, tree decl2)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_HAVE_COUNT_REG_DECR_P]\n-  :end-before: [TARGET_HAVE_COUNT_REG_DECR_P]\n+  .. hook-start:TARGET_COMPARE_VERSION_PRIORITY\n \n+  This hook is used to compare the target attributes in two functions to\n+  determine which function's features get higher priority.  This is used\n+  during function multi-versioning to figure out the order in which two\n+  versions must be dispatched.  A function version with a higher priority\n+  is checked for dispatching earlier.  :samp:`{decl1}` and :samp:`{decl2}` are\n+  the two function decls that will be compared.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_DOLOOP_COST_FOR_GENERIC]\n-  :end-before: [TARGET_DOLOOP_COST_FOR_GENERIC]\n+.. hook-end\n \n+.. function:: tree TARGET_GET_FUNCTION_VERSIONS_DISPATCHER (void *decl)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_DOLOOP_COST_FOR_ADDRESS]\n-  :end-before: [TARGET_DOLOOP_COST_FOR_ADDRESS]\n+  .. hook-start:TARGET_GET_FUNCTION_VERSIONS_DISPATCHER\n \n+  This hook is used to get the dispatcher function for a set of function\n+  versions.  The dispatcher function is called to invoke the right function\n+  version at run-time. :samp:`{decl}` is one version from a set of semantically\n+  identical versions.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_CAN_USE_DOLOOP_P]\n-  :end-before: [TARGET_CAN_USE_DOLOOP_P]\n+.. hook-end\n \n+.. function:: tree TARGET_GENERATE_VERSION_DISPATCHER_BODY (void *arg)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_INVALID_WITHIN_DOLOOP]\n-  :end-before: [TARGET_INVALID_WITHIN_DOLOOP]\n+  .. hook-start:TARGET_GENERATE_VERSION_DISPATCHER_BODY\n \n+  This hook is used to generate the dispatcher logic to invoke the right\n+  function version at run-time for a given set of function versions.\n+  :samp:`{arg}` points to the callgraph node of the dispatcher function whose\n+  body must be generated.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_PREFERRED_DOLOOP_MODE]\n-  :end-before: [TARGET_PREFERRED_DOLOOP_MODE]\n+.. hook-end\n \n+.. function:: bool TARGET_PREDICT_DOLOOP_P (class loop *loop)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_LEGITIMATE_COMBINED_INSN]\n-  :end-before: [TARGET_LEGITIMATE_COMBINED_INSN]\n+  .. hook-start:TARGET_PREDICT_DOLOOP_P\n \n+  Return true if we can predict it is possible to use a low-overhead loop\n+  for a particular loop.  The parameter :samp:`{loop}` is a pointer to the loop.\n+  This target hook is required only when the target supports low-overhead\n+  loops, and will help ivopts to make some decisions.\n+  The default version of this hook returns false.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_CAN_FOLLOW_JUMP]\n-  :end-before: [TARGET_CAN_FOLLOW_JUMP]\n+.. hook-end\n \n+.. c:var:: bool TARGET_HAVE_COUNT_REG_DECR_P\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_COMMUTATIVE_P]\n-  :end-before: [TARGET_COMMUTATIVE_P]\n+  .. hook-start:TARGET_HAVE_COUNT_REG_DECR_P\n \n+  Return true if the target supports hardware count register for decrement\n+  and branch.\n+  The default value is false.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_ALLOCATE_INITIAL_VALUE]\n-  :end-before: [TARGET_ALLOCATE_INITIAL_VALUE]\n+.. hook-end\n \n+.. c:var:: int64_t TARGET_DOLOOP_COST_FOR_GENERIC\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_UNSPEC_MAY_TRAP_P]\n-  :end-before: [TARGET_UNSPEC_MAY_TRAP_P]\n+  .. hook-start:TARGET_DOLOOP_COST_FOR_GENERIC\n \n+  One IV candidate dedicated for doloop is introduced in IVOPTs, we can\n+  calculate the computation cost of adopting it to any generic IV use by\n+  function get_computation_cost as before.  But for targets which have\n+  hardware count register support for decrement and branch, it may have to\n+  move IV value from hardware count register to general purpose register\n+  while doloop IV candidate is used for generic IV uses.  It probably takes\n+  expensive penalty.  This hook allows target owners to define the cost for\n+  this especially for generic IV uses.\n+  The default value is zero.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SET_CURRENT_FUNCTION]\n-  :end-before: [TARGET_SET_CURRENT_FUNCTION]\n+.. hook-end\n \n+.. c:var:: int64_t TARGET_DOLOOP_COST_FOR_ADDRESS\n+\n+  .. hook-start:TARGET_DOLOOP_COST_FOR_ADDRESS\n+\n+  One IV candidate dedicated for doloop is introduced in IVOPTs, we can\n+  calculate the computation cost of adopting it to any address IV use by\n+  function get_computation_cost as before.  But for targets which have\n+  hardware count register support for decrement and branch, it may have to\n+  move IV value from hardware count register to general purpose register\n+  while doloop IV candidate is used for address IV uses.  It probably takes\n+  expensive penalty.  This hook allows target owners to define the cost for\n+  this escpecially for address IV uses.\n+  The default value is zero.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_CAN_USE_DOLOOP_P (const widest_int &iterations, const widest_int &iterations_max, unsigned int loop_depth, bool entered_at_top)\n+\n+  .. hook-start:TARGET_CAN_USE_DOLOOP_P\n+\n+  Return true if it is possible to use low-overhead loops (``doloop_end``\n+  and ``doloop_begin``) for a particular loop.  :samp:`{iterations}` gives the\n+  exact number of iterations, or 0 if not known.  :samp:`{iterations_max}` gives\n+  the maximum number of iterations, or 0 if not known.  :samp:`{loop_depth}` is\n+  the nesting depth of the loop, with 1 for innermost loops, 2 for loops that\n+  contain innermost loops, and so on.  :samp:`{entered_at_top}` is true if the\n+  loop is only entered from the top.\n+\n+  This hook is only used if ``doloop_end`` is available.  The default\n+  implementation returns true.  You can use ``can_use_doloop_if_innermost``\n+  if the loop must be the innermost, and if there are no other restrictions.\n+\n+.. hook-end\n+\n+.. function:: const char * TARGET_INVALID_WITHIN_DOLOOP (const rtx_insn *insn)\n+\n+  .. hook-start:TARGET_INVALID_WITHIN_DOLOOP\n+\n+  Take an instruction in :samp:`{insn}` and return NULL if it is valid within a\n+  low-overhead loop, otherwise return a string explaining why doloop\n+  could not be applied.\n+\n+  Many targets use special registers for low-overhead looping. For any\n+  instruction that clobbers these this function should return a string indicating\n+  the reason why the doloop could not be applied.\n+  By default, the RTL loop optimizer does not use a present doloop pattern for\n+  loops containing function calls or branch on table instructions.\n+\n+.. hook-end\n+\n+.. function:: machine_mode TARGET_PREFERRED_DOLOOP_MODE (machine_mode mode)\n+\n+  .. hook-start:TARGET_PREFERRED_DOLOOP_MODE\n+\n+  This hook takes a :samp:`{mode}` for a doloop IV, where ``mode`` is the\n+  original mode for the operation.  If the target prefers an alternate\n+  ``mode`` for the operation, then this hook should return that mode;\n+  otherwise the original ``mode`` should be returned.  For example, on a\n+  64-bit target, ``DImode`` might be preferred over ``SImode``.  Both the\n+  original and the returned modes should be ``MODE_INT``.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_LEGITIMATE_COMBINED_INSN (rtx_insn *insn)\n+\n+  .. hook-start:TARGET_LEGITIMATE_COMBINED_INSN\n+\n+  Take an instruction in :samp:`{insn}` and return ``false`` if the instruction\n+  is not appropriate as a combination of two or more instructions.  The\n+  default is to accept all instructions.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_CAN_FOLLOW_JUMP (const rtx_insn *follower, const rtx_insn *followee)\n+\n+  .. hook-start:TARGET_CAN_FOLLOW_JUMP\n+\n+  FOLLOWER and FOLLOWEE are JUMP_INSN instructions;\n+  return true if FOLLOWER may be modified to follow FOLLOWEE;\n+  false, if it can't.\n+  For example, on some targets, certain kinds of branches can't be made to\n+  follow through a hot/cold partitioning.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_COMMUTATIVE_P (const_rtx x, int outer_code)\n+\n+  .. hook-start:TARGET_COMMUTATIVE_P\n+\n+  This target hook returns ``true`` if :samp:`{x}` is considered to be commutative.\n+  Usually, this is just COMMUTATIVE_P (:samp:`{x}`), but the HP PA doesn't consider\n+  PLUS to be commutative inside a MEM.  :samp:`{outer_code}` is the rtx code\n+  of the enclosing rtl, if known, otherwise it is UNKNOWN.\n+\n+.. hook-end\n+\n+.. function:: rtx TARGET_ALLOCATE_INITIAL_VALUE (rtx hard_reg)\n+\n+  .. hook-start:TARGET_ALLOCATE_INITIAL_VALUE\n+\n+  When the initial value of a hard register has been copied in a pseudo\n+  register, it is often not necessary to actually allocate another register\n+  to this pseudo register, because the original hard register or a stack slot\n+  it has been saved into can be used.  ``TARGET_ALLOCATE_INITIAL_VALUE``\n+  is called at the start of register allocation once for each hard register\n+  that had its initial value copied by using\n+  ``get_func_hard_reg_initial_val`` or ``get_hard_reg_initial_val``.\n+  Possible values are ``NULL_RTX``, if you don't want\n+  to do any special allocation, a ``REG`` rtx---that would typically be\n+  the hard register itself, if it is known not to be clobbered---or a\n+  ``MEM``.\n+  If you are returning a ``MEM``, this is only a hint for the allocator;\n+  it might decide to use another register anyways.\n+  You may use ``current_function_is_leaf`` or\n+  ``REG_N_SETS`` in the hook to determine if the hard\n+  register in question will not be clobbered.\n+  The default value of this hook is ``NULL``, which disables any special\n+  allocation.\n+\n+.. hook-end\n+\n+.. function:: int TARGET_UNSPEC_MAY_TRAP_P (const_rtx x, unsigned flags)\n+\n+  .. hook-start:TARGET_UNSPEC_MAY_TRAP_P\n+\n+  This target hook returns nonzero if :samp:`{x}`, an ``unspec`` or\n+  ``unspec_volatile`` operation, might cause a trap.  Targets can use\n+  this hook to enhance precision of analysis for ``unspec`` and\n+  ``unspec_volatile`` operations.  You may call ``may_trap_p_1``\n+  to analyze inner elements of :samp:`{x}` in which case :samp:`{flags}` should be\n+  passed along.\n+\n+.. hook-end\n+\n+.. function:: void TARGET_SET_CURRENT_FUNCTION (tree decl)\n+\n+  .. hook-start:TARGET_SET_CURRENT_FUNCTION\n+\n+  The compiler invokes this hook whenever it changes its current function\n+  context (``cfun``).  You can define this function if\n+  the back end needs to perform any initialization or reset actions on a\n+  per-function basis.  For example, it may be used to implement function\n+  attributes that affect register usage or code generation patterns.\n+  The argument :samp:`{decl}` is the declaration for the new function context,\n+  and may be null to indicate that the compiler has left a function context\n+  and is returning to processing at the top level.\n+  The default hook function does nothing.\n+\n+  GCC sets ``cfun`` to a dummy function context during initialization of\n+  some parts of the back end.  The hook function is not invoked in this\n+  situation; you need not worry about the hook being invoked recursively,\n+  or when the back end is in a partially-initialized state.\n+  ``cfun`` might be ``NULL`` to indicate processing at top level,\n+  outside of any function scope.\n+\n+.. hook-end\n \n .. c:macro:: TARGET_OBJECT_SUFFIX\n \n@@ -692,35 +1068,91 @@ Here are several miscellaneous parameters.\n   object files that are not referenced from ``main`` and uses export\n   lists.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_CANNOT_MODIFY_JUMPS_P]\n-  :end-before: [TARGET_CANNOT_MODIFY_JUMPS_P]\n+.. function:: bool TARGET_CANNOT_MODIFY_JUMPS_P (void)\n+\n+  .. hook-start:TARGET_CANNOT_MODIFY_JUMPS_P\n+\n+  This target hook returns ``true`` past the point in which new jump\n+  instructions could be created.  On machines that require a register for\n+  every jump such as the SHmedia ISA of SH5, this point would typically be\n+  reload, so this target hook should be defined to a function such as:\n+\n+  .. code-block:: c++\n \n+    static bool\n+    cannot_modify_jumps_past_reload_p ()\n+    {\n+      return (reload_completed || reload_in_progress);\n+    }\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_HAVE_CONDITIONAL_EXECUTION]\n-  :end-before: [TARGET_HAVE_CONDITIONAL_EXECUTION]\n+.. hook-end\n \n+.. function:: bool TARGET_HAVE_CONDITIONAL_EXECUTION (void)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_GEN_CCMP_FIRST]\n-  :end-before: [TARGET_GEN_CCMP_FIRST]\n+  .. hook-start:TARGET_HAVE_CONDITIONAL_EXECUTION\n \n+  This target hook returns true if the target supports conditional execution.\n+  This target hook is required only when the target has several different\n+  modes and they have different conditional execution capability, such as ARM.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_GEN_CCMP_NEXT]\n-  :end-before: [TARGET_GEN_CCMP_NEXT]\n+.. hook-end\n \n+.. function:: rtx TARGET_GEN_CCMP_FIRST (rtx_insn **prep_seq, rtx_insn **gen_seq, int code, tree op0, tree op1)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_GEN_MEMSET_SCRATCH_RTX]\n-  :end-before: [TARGET_GEN_MEMSET_SCRATCH_RTX]\n+  .. hook-start:TARGET_GEN_CCMP_FIRST\n \n+  This function prepares to emit a comparison insn for the first compare in a\n+  sequence of conditional comparisions.  It returns an appropriate comparison\n+  with ``CC`` for passing to ``gen_ccmp_next`` or ``cbranch_optab``.\n+  The insns to prepare the compare are saved in :samp:`{prep_seq}` and the compare\n+  insns are saved in :samp:`{gen_seq}`.  They will be emitted when all the\n+  compares in the conditional comparision are generated without error.\n+  :samp:`{code}` is the ``rtx_code`` of the compare for :samp:`{op0}` and :samp:`{op1}`.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_LOOP_UNROLL_ADJUST]\n-  :end-before: [TARGET_LOOP_UNROLL_ADJUST]\n+.. hook-end\n \n+.. function:: rtx TARGET_GEN_CCMP_NEXT (rtx_insn **prep_seq, rtx_insn **gen_seq, rtx prev, int cmp_code, tree op0, tree op1, int bit_code)\n+\n+  .. hook-start:TARGET_GEN_CCMP_NEXT\n+\n+  This function prepares to emit a conditional comparison within a sequence\n+  of conditional comparisons.  It returns an appropriate comparison with\n+  ``CC`` for passing to ``gen_ccmp_next`` or ``cbranch_optab``.\n+  The insns to prepare the compare are saved in :samp:`{prep_seq}` and the compare\n+  insns are saved in :samp:`{gen_seq}`.  They will be emitted when all the\n+  compares in the conditional comparision are generated without error.  The\n+  :samp:`{prev}` expression is the result of a prior call to ``gen_ccmp_first``\n+  or ``gen_ccmp_next``.  It may return ``NULL`` if the combination of\n+  :samp:`{prev}` and this comparison is not supported, otherwise the result must\n+  be appropriate for passing to ``gen_ccmp_next`` or ``cbranch_optab``.\n+  :samp:`{code}` is the ``rtx_code`` of the compare for :samp:`{op0}` and :samp:`{op1}`.\n+  :samp:`{bit_code}` is ``AND`` or ``IOR``, which is the op on the compares.\n+\n+.. hook-end\n+\n+.. function:: rtx TARGET_GEN_MEMSET_SCRATCH_RTX (machine_mode mode)\n+\n+  .. hook-start:TARGET_GEN_MEMSET_SCRATCH_RTX\n+\n+  This hook should return an rtx for a scratch register in :samp:`{mode}` to\n+  be used when expanding memset calls.  The backend can use a hard scratch\n+  register to avoid stack realignment when expanding memset.  The default\n+  is ``gen_reg_rtx``.\n+\n+.. hook-end\n+\n+.. function:: unsigned TARGET_LOOP_UNROLL_ADJUST (unsigned nunroll, class loop *loop)\n+\n+  .. hook-start:TARGET_LOOP_UNROLL_ADJUST\n+\n+  This target hook returns a new value for the number of times :samp:`{loop}`\n+  should be unrolled. The parameter :samp:`{nunroll}` is the number of times\n+  the loop is to be unrolled. The parameter :samp:`{loop}` is a pointer to\n+  the loop, which is going to be checked for unrolling. This target hook\n+  is required only when the target has special constraints like maximum\n+  number of memory accesses.\n+\n+.. hook-end\n \n .. c:macro:: POWI_MAX_MULTS\n \n@@ -792,40 +1224,90 @@ Here are several miscellaneous parameters.\n   routine for target specific customizations of the system printf\n   and scanf formatter settings.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_INVALID_ARG_FOR_UNPROTOTYPED_FN]\n-  :end-before: [TARGET_INVALID_ARG_FOR_UNPROTOTYPED_FN]\n+.. function:: const char * TARGET_INVALID_ARG_FOR_UNPROTOTYPED_FN (const_tree typelist, const_tree funcdecl, const_tree val)\n+\n+  .. hook-start:TARGET_INVALID_ARG_FOR_UNPROTOTYPED_FN\n+\n+  If defined, this macro returns the diagnostic message when it is\n+  illegal to pass argument :samp:`{val}` to function :samp:`{funcdecl}`\n+  with prototype :samp:`{typelist}`.\n+\n+.. hook-end\n+\n+.. function:: const char * TARGET_INVALID_CONVERSION (const_tree fromtype, const_tree totype)\n+\n+  .. hook-start:TARGET_INVALID_CONVERSION\n+\n+  If defined, this macro returns the diagnostic message when it is\n+  invalid to convert from :samp:`{fromtype}` to :samp:`{totype}`, or ``NULL``\n+  if validity should be determined by the front end.\n+\n+.. hook-end\n+\n+.. function:: const char * TARGET_INVALID_UNARY_OP (int op, const_tree type)\n+\n+  .. hook-start:TARGET_INVALID_UNARY_OP\n+\n+  If defined, this macro returns the diagnostic message when it is\n+  invalid to apply operation :samp:`{op}` (where unary plus is denoted by\n+  ``CONVERT_EXPR``) to an operand of type :samp:`{type}`, or ``NULL``\n+  if validity should be determined by the front end.\n+\n+.. hook-end\n+\n+.. function:: const char * TARGET_INVALID_BINARY_OP (int op, const_tree type1, const_tree type2)\n \n+  .. hook-start:TARGET_INVALID_BINARY_OP\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_INVALID_CONVERSION]\n-  :end-before: [TARGET_INVALID_CONVERSION]\n+  If defined, this macro returns the diagnostic message when it is\n+  invalid to apply operation :samp:`{op}` to operands of types :samp:`{type1}`\n+  and :samp:`{type2}`, or ``NULL`` if validity should be determined by\n+  the front end.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_INVALID_UNARY_OP]\n-  :end-before: [TARGET_INVALID_UNARY_OP]\n+.. function:: tree TARGET_PROMOTED_TYPE (const_tree type)\n \n+  .. hook-start:TARGET_PROMOTED_TYPE\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_INVALID_BINARY_OP]\n-  :end-before: [TARGET_INVALID_BINARY_OP]\n+  If defined, this target hook returns the type to which values of\n+  :samp:`{type}` should be promoted when they appear in expressions,\n+  analogous to the integer promotions, or ``NULL_TREE`` to use the\n+  front end's normal promotion rules.  This hook is useful when there are\n+  target-specific types with special promotion rules.\n+  This is currently used only by the C and C++ front ends.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_PROMOTED_TYPE]\n-  :end-before: [TARGET_PROMOTED_TYPE]\n+.. function:: tree TARGET_CONVERT_TO_TYPE (tree type, tree expr)\n \n+  .. hook-start:TARGET_CONVERT_TO_TYPE\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_CONVERT_TO_TYPE]\n-  :end-before: [TARGET_CONVERT_TO_TYPE]\n+  If defined, this hook returns the result of converting :samp:`{expr}` to\n+  :samp:`{type}`.  It should return the converted expression,\n+  or ``NULL_TREE`` to apply the front end's normal conversion rules.\n+  This hook is useful when there are target-specific types with special\n+  conversion rules.\n+  This is currently used only by the C and C++ front ends.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_VERIFY_TYPE_CONTEXT]\n-  :end-before: [TARGET_VERIFY_TYPE_CONTEXT]\n+.. function:: bool TARGET_VERIFY_TYPE_CONTEXT (location_t loc, type_context_kind context, const_tree type, bool silent_p)\n \n+  .. hook-start:TARGET_VERIFY_TYPE_CONTEXT\n+\n+  If defined, this hook returns false if there is a target-specific reason\n+  why type :samp:`{type}` cannot be used in the source language context described\n+  by :samp:`{context}`.  When :samp:`{silent_p}` is false, the hook also reports an\n+  error against :samp:`{loc}` for invalid uses of :samp:`{type}`.\n+\n+  Calls to this hook should be made through the global function\n+  ``verify_type_context``, which makes the :samp:`{silent_p}` parameter\n+  default to false and also handles ``error_mark_node``.\n+\n+  The default implementation always returns true.\n+\n+.. hook-end\n \n .. c:macro:: OBJC_JBLEN\n \n@@ -839,75 +1321,188 @@ Here are several miscellaneous parameters.\n   call stack unwinding.  It is used in declarations in :samp:`unwind-generic.h`\n   and the associated definitions of those functions.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_UPDATE_STACK_BOUNDARY]\n-  :end-before: [TARGET_UPDATE_STACK_BOUNDARY]\n+.. function:: void TARGET_UPDATE_STACK_BOUNDARY (void)\n+\n+  .. hook-start:TARGET_UPDATE_STACK_BOUNDARY\n+\n+  Define this macro to update the current function stack boundary if\n+  necessary.\n+\n+.. hook-end\n+\n+.. function:: rtx TARGET_GET_DRAP_RTX (void)\n+\n+  .. hook-start:TARGET_GET_DRAP_RTX\n+\n+  This hook should return an rtx for Dynamic Realign Argument Pointer (DRAP) if a\n+  different argument pointer register is needed to access the function's\n+  argument list due to stack realignment.  Return ``NULL`` if no DRAP\n+  is needed.\n+\n+.. hook-end\n+\n+.. function:: HARD_REG_SET TARGET_ZERO_CALL_USED_REGS (HARD_REG_SET selected_regs)\n+\n+  .. hook-start:TARGET_ZERO_CALL_USED_REGS\n+\n+  This target hook emits instructions to zero the subset of :samp:`{selected_regs}`\n+  that could conceivably contain values that are useful to an attacker.\n+  Return the set of registers that were actually cleared.\n+\n+  For most targets, the returned set of registers is a subset of\n+  :samp:`{selected_regs}`, however, for some of the targets (for example MIPS),\n+  clearing some registers that are in the :samp:`{selected_regs}` requires\n+  clearing other call used registers that are not in the :samp:`{selected_regs}`,\n+  under such situation, the returned set of registers must be a subset of all\n+  call used registers.\n+\n+  The default implementation uses normal move instructions to zero\n+  all the registers in :samp:`{selected_regs}`.  Define this hook if the\n+  target has more efficient ways of zeroing certain registers,\n+  or if you believe that certain registers would never contain\n+  values that are useful to an attacker.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_ALLOCATE_STACK_SLOTS_FOR_ARGS (void)\n+\n+  .. hook-start:TARGET_ALLOCATE_STACK_SLOTS_FOR_ARGS\n+\n+  When optimization is disabled, this hook indicates whether or not\n+  arguments should be allocated to stack slots.  Normally, GCC allocates\n+  stacks slots for arguments when not optimizing in order to make\n+  debugging easier.  However, when a function is declared with\n+  ``__attribute__((naked))``, there is no stack frame, and the compiler\n+  cannot safely move arguments from the registers in which they are passed\n+  to the stack.  Therefore, this hook should return true in general, but\n+  false for naked functions.  The default implementation always returns true.\n+\n+.. hook-end\n+\n+.. c:var:: unsigned HOST_WIDE_INT TARGET_CONST_ANCHOR\n+\n+  .. hook-start:TARGET_CONST_ANCHOR\n \n+  On some architectures it can take multiple instructions to synthesize\n+  a constant.  If there is another constant already in a register that\n+  is close enough in value then it is preferable that the new constant\n+  is computed from this register using immediate addition or\n+  subtraction.  We accomplish this through CSE.  Besides the value of\n+  the constant we also add a lower and an upper constant anchor to the\n+  available expressions.  These are then queried when encountering new\n+  constants.  The anchors are computed by rounding the constant up and\n+  down to a multiple of the value of ``TARGET_CONST_ANCHOR``.\n+  ``TARGET_CONST_ANCHOR`` should be the maximum positive value\n+  accepted by immediate-add plus one.  We currently assume that the\n+  value of ``TARGET_CONST_ANCHOR`` is a power of 2.  For example, on\n+  MIPS, where add-immediate takes a 16-bit signed value,\n+  ``TARGET_CONST_ANCHOR`` is set to :samp:`0x8000`.  The default value\n+  is zero, which disables this optimization.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_GET_DRAP_RTX]\n-  :end-before: [TARGET_GET_DRAP_RTX]\n+.. hook-end\n \n+.. function:: unsigned HOST_WIDE_INT TARGET_ASAN_SHADOW_OFFSET (void)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_ZERO_CALL_USED_REGS]\n-  :end-before: [TARGET_ZERO_CALL_USED_REGS]\n+  .. hook-start:TARGET_ASAN_SHADOW_OFFSET\n \n+  Return the offset bitwise ored into shifted address to get corresponding\n+  Address Sanitizer shadow memory address.  NULL if Address Sanitizer is not\n+  supported by the target.  May return 0 if Address Sanitizer is not supported\n+  by a subtarget.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_ALLOCATE_STACK_SLOTS_FOR_ARGS]\n-  :end-before: [TARGET_ALLOCATE_STACK_SLOTS_FOR_ARGS]\n+.. hook-end\n \n+.. function:: unsigned HOST_WIDE_INT TARGET_MEMMODEL_CHECK (unsigned HOST_WIDE_INT val)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_CONST_ANCHOR]\n-  :end-before: [TARGET_CONST_ANCHOR]\n+  .. hook-start:TARGET_MEMMODEL_CHECK\n \n+  Validate target specific memory model mask bits. When NULL no target specific\n+  memory model bits are allowed.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_ASAN_SHADOW_OFFSET]\n-  :end-before: [TARGET_ASAN_SHADOW_OFFSET]\n+.. hook-end\n \n+.. c:var:: unsigned char TARGET_ATOMIC_TEST_AND_SET_TRUEVAL\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_MEMMODEL_CHECK]\n-  :end-before: [TARGET_MEMMODEL_CHECK]\n+  .. hook-start:TARGET_ATOMIC_TEST_AND_SET_TRUEVAL\n \n+  This value should be set if the result written by\n+  ``atomic_test_and_set`` is not exactly 1, i.e. the\n+  ``bool`` ``true``.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_ATOMIC_TEST_AND_SET_TRUEVAL]\n-  :end-before: [TARGET_ATOMIC_TEST_AND_SET_TRUEVAL]\n+.. hook-end\n \n+.. function:: bool TARGET_HAS_IFUNC_P (void)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_HAS_IFUNC_P]\n-  :end-before: [TARGET_HAS_IFUNC_P]\n+  .. hook-start:TARGET_HAS_IFUNC_P\n \n+  It returns true if the target supports GNU indirect functions.\n+  The support includes the assembler, linker and dynamic linker.\n+  The default value of this hook is based on target's libc.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_IFUNC_REF_LOCAL_OK]\n-  :end-before: [TARGET_IFUNC_REF_LOCAL_OK]\n+.. hook-end\n \n+.. function:: bool TARGET_IFUNC_REF_LOCAL_OK (void)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_ATOMIC_ALIGN_FOR_MODE]\n-  :end-before: [TARGET_ATOMIC_ALIGN_FOR_MODE]\n+   .. hook-start:TARGET_IFUNC_REF_LOCAL_OK\n \n+  Return true if it is OK to reference indirect function resolvers\n+  locally.  The default is to return false.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_ATOMIC_ASSIGN_EXPAND_FENV]\n-  :end-before: [TARGET_ATOMIC_ASSIGN_EXPAND_FENV]\n+.. hook-end\n \n+.. function:: unsigned int TARGET_ATOMIC_ALIGN_FOR_MODE (machine_mode mode)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_RECORD_OFFLOAD_SYMBOL]\n-  :end-before: [TARGET_RECORD_OFFLOAD_SYMBOL]\n+  .. hook-start:TARGET_ATOMIC_ALIGN_FOR_MODE\n \n+  If defined, this function returns an appropriate alignment in bits for an\n+  atomic object of machine_mode :samp:`{mode}`.  If 0 is returned then the\n+  default alignment for the specified mode is used.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_OFFLOAD_OPTIONS]\n-  :end-before: [TARGET_OFFLOAD_OPTIONS]\n+.. hook-end\n \n+.. function:: void TARGET_ATOMIC_ASSIGN_EXPAND_FENV (tree *hold, tree *clear, tree *update)\n+\n+  .. hook-start:TARGET_ATOMIC_ASSIGN_EXPAND_FENV\n+\n+  ISO C11 requires atomic compound assignments that may raise floating-point\n+  exceptions to raise exceptions corresponding to the arithmetic operation\n+  whose result was successfully stored in a compare-and-exchange sequence.\n+  This requires code equivalent to calls to ``feholdexcept``,\n+  ``feclearexcept`` and ``feupdateenv`` to be generated at\n+  appropriate points in the compare-and-exchange sequence.  This hook should\n+  set ``*hold`` to an expression equivalent to the call to\n+  ``feholdexcept``, ``*clear`` to an expression equivalent to\n+  the call to ``feclearexcept`` and ``*update`` to an expression\n+  equivalent to the call to ``feupdateenv``.  The three expressions are\n+  ``NULL_TREE`` on entry to the hook and may be left as ``NULL_TREE``\n+  if no code is required in a particular place.  The default implementation\n+  leaves all three expressions as ``NULL_TREE``.  The\n+  ``__atomic_feraiseexcept`` function from ``libatomic`` may be of use\n+  as part of the code generated in ``*update``.\n+\n+.. hook-end\n+\n+.. function:: void TARGET_RECORD_OFFLOAD_SYMBOL (tree)\n+\n+  .. hook-start:TARGET_RECORD_OFFLOAD_SYMBOL\n+\n+  Used when offloaded functions are seen in the compilation unit and no named\n+  sections are available.  It is called once for each symbol that must be\n+  recorded in the offload function and variable table.\n+\n+.. hook-end\n+\n+.. function:: char * TARGET_OFFLOAD_OPTIONS (void)\n+\n+  .. hook-start:TARGET_OFFLOAD_OPTIONS\n+\n+  Used when writing out the list of options into an LTO file.  It should\n+  translate any relevant target-specific options (such as the ABI in use)\n+  into one of the :option:`-foffload` options that exist as a common interface\n+  to express such options.  It should return a string containing these options,\n+  separated by spaces, which the caller will free.\n+\n+.. hook-end\n \n .. c:macro:: TARGET_SUPPORTS_WIDE_INT\n \n@@ -948,66 +1543,176 @@ Here are several miscellaneous parameters.\n   All and all it does not take long to convert ports that the\n   maintainer is familiar with.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_HAVE_SPECULATION_SAFE_VALUE]\n-  :end-before: [TARGET_HAVE_SPECULATION_SAFE_VALUE]\n+.. function:: bool TARGET_HAVE_SPECULATION_SAFE_VALUE (bool active)\n+\n+  .. hook-start:TARGET_HAVE_SPECULATION_SAFE_VALUE\n+\n+  This hook is used to determine the level of target support for\n+  ``__builtin_speculation_safe_value``.  If called with an argument\n+  of false, it returns true if the target has been modified to support\n+  this builtin.  If called with an argument of true, it returns true\n+  if the target requires active mitigation execution might be speculative.\n+\n+  The default implementation returns false if the target does not define\n+  a pattern named ``speculation_barrier``.  Else it returns true\n+  for the first case and whether the pattern is enabled for the current\n+  compilation for the second case.\n+\n+  For targets that have no processors that can execute instructions\n+  speculatively an alternative implemenation of this hook is available:\n+  simply redefine this hook to ``speculation_safe_value_not_needed``\n+  along with your other target hooks.\n+\n+.. hook-end\n+\n+.. function:: rtx TARGET_SPECULATION_SAFE_VALUE (machine_mode mode, rtx result, rtx val, rtx failval)\n+\n+  .. hook-start:TARGET_SPECULATION_SAFE_VALUE\n+\n+  This target hook can be used to generate a target-specific code\n+  sequence that implements the ``__builtin_speculation_safe_value``\n+  built-in function.  The function must always return :samp:`{val}` in\n+  :samp:`{result}` in mode :samp:`{mode}` when the cpu is not executing\n+  speculatively, but must never return that when speculating until it\n+  is known that the speculation will not be unwound.  The hook supports\n+  two primary mechanisms for implementing the requirements.  The first\n+  is to emit a speculation barrier which forces the processor to wait\n+  until all prior speculative operations have been resolved; the second\n+  is to use a target-specific mechanism that can track the speculation\n+  state and to return :samp:`{failval}` if it can determine that\n+  speculation must be unwound at a later time.\n+\n+  The default implementation simply copies :samp:`{val}` to :samp:`{result}` and\n+  emits a ``speculation_barrier`` instruction if that is defined.\n+\n+.. hook-end\n+\n+.. function:: void TARGET_RUN_TARGET_SELFTESTS (void)\n+\n+  .. hook-start:TARGET_RUN_TARGET_SELFTESTS\n+\n+  If selftests are enabled, run any selftests for this target.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_MEMTAG_CAN_TAG_ADDRESSES ()\n+\n+  .. hook-start:TARGET_MEMTAG_CAN_TAG_ADDRESSES\n+\n+  True if the backend architecture naturally supports ignoring some region\n+  of pointers.  This feature means that :option:`-fsanitize=hwaddress` can\n+  work.\n+\n+  At preset, this feature does not support address spaces.  It also requires\n+  ``Pmode`` to be the same as ``ptr_mode``.\n+\n+.. hook-end\n+\n+.. function:: uint8_t TARGET_MEMTAG_TAG_SIZE ()\n+\n+  .. hook-start:TARGET_MEMTAG_TAG_SIZE\n+\n+  Return the size of a tag (in bits) for this platform.\n+\n+  The default returns 8.\n+\n+.. hook-end\n+\n+.. function:: uint8_t TARGET_MEMTAG_GRANULE_SIZE ()\n+\n+  .. hook-start:TARGET_MEMTAG_GRANULE_SIZE\n+\n+  Return the size in real memory that each byte in shadow memory refers to.\n+  I.e. if a variable is :samp:`{X}` bytes long in memory, then this hook should\n+  return the value :samp:`{Y}` such that the tag in shadow memory spans\n+  :samp:`{X}` / :samp:`{Y}` bytes.\n+\n+  Most variables will need to be aligned to this amount since two variables\n+  that are neighbors in memory and share a tag granule would need to share\n+  the same tag.\n+\n+  The default returns 16.\n+\n+.. hook-end\n+\n+.. function:: rtx TARGET_MEMTAG_INSERT_RANDOM_TAG (rtx untagged, rtx target)\n+\n+  .. hook-start:TARGET_MEMTAG_INSERT_RANDOM_TAG\n+\n+  Return an RTX representing the value of :samp:`{untagged}` but with a\n+  (possibly) random tag in it.\n+  Put that value into :samp:`{target}` if it is convenient to do so.\n+  This function is used to generate a tagged base for the current stack frame.\n+\n+.. hook-end\n+\n+.. function:: rtx TARGET_MEMTAG_ADD_TAG (rtx base, poly_int64 addr_offset, uint8_t tag_offset)\n \n+  .. hook-start:TARGET_MEMTAG_ADD_TAG\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SPECULATION_SAFE_VALUE]\n-  :end-before: [TARGET_SPECULATION_SAFE_VALUE]\n+  Return an RTX that represents the result of adding :samp:`{addr_offset}` to\n+  the address in pointer :samp:`{base}` and :samp:`{tag_offset}` to the tag in pointer\n+  :samp:`{base}`.\n+  The resulting RTX must either be a valid memory address or be able to get\n+  put into an operand with ``force_operand``.\n \n+  Unlike other memtag hooks, this must return an expression and not emit any\n+  RTL.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_RUN_TARGET_SELFTESTS]\n-  :end-before: [TARGET_RUN_TARGET_SELFTESTS]\n+.. hook-end\n \n+.. function:: rtx TARGET_MEMTAG_SET_TAG (rtx untagged_base, rtx tag, rtx target)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_MEMTAG_CAN_TAG_ADDRESSES]\n-  :end-before: [TARGET_MEMTAG_CAN_TAG_ADDRESSES]\n+  .. hook-start:TARGET_MEMTAG_SET_TAG\n \n+  Return an RTX representing :samp:`{untagged_base}` but with the tag :samp:`{tag}`.\n+  Try and store this in :samp:`{target}` if convenient.\n+  :samp:`{untagged_base}` is required to have a zero tag when this hook is called.\n+  The default of this hook is to set the top byte of :samp:`{untagged_base}` to\n+  :samp:`{tag}`.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_MEMTAG_TAG_SIZE]\n-  :end-before: [TARGET_MEMTAG_TAG_SIZE]\n+.. hook-end\n \n+.. function:: rtx TARGET_MEMTAG_EXTRACT_TAG (rtx tagged_pointer, rtx target)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_MEMTAG_GRANULE_SIZE]\n-  :end-before: [TARGET_MEMTAG_GRANULE_SIZE]\n+  .. hook-start:TARGET_MEMTAG_EXTRACT_TAG\n \n+  Return an RTX representing the tag stored in :samp:`{tagged_pointer}`.\n+  Store the result in :samp:`{target}` if it is convenient.\n+  The default represents the top byte of the original pointer.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_MEMTAG_INSERT_RANDOM_TAG]\n-  :end-before: [TARGET_MEMTAG_INSERT_RANDOM_TAG]\n+.. hook-end\n \n+.. function:: rtx TARGET_MEMTAG_UNTAGGED_POINTER (rtx tagged_pointer, rtx target)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_MEMTAG_ADD_TAG]\n-  :end-before: [TARGET_MEMTAG_ADD_TAG]\n+  .. hook-start:TARGET_MEMTAG_UNTAGGED_POINTER\n \n+  Return an RTX representing :samp:`{tagged_pointer}` with its tag set to zero.\n+  Store the result in :samp:`{target}` if convenient.\n+  The default clears the top byte of the original pointer.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_MEMTAG_SET_TAG]\n-  :end-before: [TARGET_MEMTAG_SET_TAG]\n+.. hook-end\n \n+.. function:: HOST_WIDE_INT TARGET_GCOV_TYPE_SIZE (void)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_MEMTAG_EXTRACT_TAG]\n-  :end-before: [TARGET_MEMTAG_EXTRACT_TAG]\n+  .. hook-start:TARGET_GCOV_TYPE_SIZE\n \n+  Returns the gcov type size in bits.  This type is used for example for\n+  counters incremented by profiling and code-coverage events.  The default\n+  value is 64, if the type size of long long is greater than 32, otherwise the\n+  default value is 32.  A 64-bit type is recommended to avoid overflows of the\n+  counters.  If the :option:`-fprofile-update=atomic` is used, then the\n+  counters are incremented using atomic operations.  Targets not supporting\n+  64-bit atomic operations may override the default value and request a 32-bit\n+  type.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_MEMTAG_UNTAGGED_POINTER]\n-  :end-before: [TARGET_MEMTAG_UNTAGGED_POINTER]\n+.. hook-end\n \n+.. c:var:: bool TARGET_HAVE_SHADOW_CALL_STACK\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_GCOV_TYPE_SIZE]\n-  :end-before: [TARGET_GCOV_TYPE_SIZE]\n+  .. hook-start:TARGET_HAVE_SHADOW_CALL_STACK\n \n+  This value is true if the target platform supports\n+  :option:`-fsanitize=shadow-call-stack`.  The default value is false.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_HAVE_SHADOW_CALL_STACK]\n-  :end-before: [TARGET_HAVE_SHADOW_CALL_STACK]\n+.. hook-end\n\\ No newline at end of file"}, {"sha": "e60f941dd8a211d6322c09604cb108423551c9a0", "filename": "gcc/doc/gccint/target-macros/mode-switching-instructions.rst", "status": "modified", "additions": 62, "deletions": 18, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fmode-switching-instructions.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fmode-switching-instructions.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fmode-switching-instructions.rst?ref=3e070cff11f81051e70b613816075b66a6de61c2", "patch": "@@ -47,31 +47,75 @@ The following macros control mode switching optimizations:\n   represented as numbers 0 ... N - 1.  N is used to specify that no mode\n   switch is needed / supplied.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_MODE_EMIT]\n-  :end-before: [TARGET_MODE_EMIT]\n+.. function:: void TARGET_MODE_EMIT (int entity, int mode, int prev_mode, HARD_REG_SET regs_live)\n \n+  .. hook-start:TARGET_MODE_EMIT\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_MODE_NEEDED]\n-  :end-before: [TARGET_MODE_NEEDED]\n+  Generate one or more insns to set :samp:`{entity}` to :samp:`{mode}`.\n+  :samp:`{hard_reg_live}` is the set of hard registers live at the point where\n+  the insn(s) are to be inserted. :samp:`{prev_moxde}` indicates the mode\n+  to switch from. Sets of a lower numbered entity will be emitted before\n+  sets of a higher numbered entity to a mode of the same or lower priority.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_MODE_AFTER]\n-  :end-before: [TARGET_MODE_AFTER]\n+.. function:: int TARGET_MODE_NEEDED (int entity, rtx_insn *insn)\n \n+  .. hook-start:TARGET_MODE_NEEDED\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_MODE_ENTRY]\n-  :end-before: [TARGET_MODE_ENTRY]\n+  :samp:`{entity}` is an integer specifying a mode-switched entity.\n+  If ``OPTIMIZE_MODE_SWITCHING`` is defined, you must define this macro\n+  to return an integer value not larger than the corresponding element\n+  in ``NUM_MODES_FOR_MODE_SWITCHING``, to denote the mode that :samp:`{entity}`\n+  must be switched into prior to the execution of :samp:`{insn}`.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_MODE_EXIT]\n-  :end-before: [TARGET_MODE_EXIT]\n+.. function:: int TARGET_MODE_AFTER (int entity, int mode, rtx_insn *insn)\n \n+  .. hook-start:TARGET_MODE_AFTER\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_MODE_PRIORITY]\n-  :end-before: [TARGET_MODE_PRIORITY]\n+  :samp:`{entity}` is an integer specifying a mode-switched entity.\n+  If this macro is defined, it is evaluated for every :samp:`{insn}` during mode\n+  switching.  It determines the mode that an insn results\n+  in (if different from the incoming mode).\n+\n+.. hook-end\n+\n+.. function:: int TARGET_MODE_ENTRY (int entity)\n+\n+  .. hook-start:TARGET_MODE_ENTRY\n+\n+  If this macro is defined, it is evaluated for every :samp:`{entity}` that\n+  needs mode switching.  It should evaluate to an integer, which is a mode\n+  that :samp:`{entity}` is assumed to be switched to at function entry.\n+  If ``TARGET_MODE_ENTRY`` is defined then ``TARGET_MODE_EXIT``\n+  must be defined.\n+\n+.. hook-end\n+\n+.. function:: int TARGET_MODE_EXIT (int entity)\n+\n+  .. hook-start:TARGET_MODE_EXIT\n+\n+  If this macro is defined, it is evaluated for every :samp:`{entity}` that\n+  needs mode switching.  It should evaluate to an integer, which is a mode\n+  that :samp:`{entity}` is assumed to be switched to at function exit.\n+  If ``TARGET_MODE_EXIT`` is defined then ``TARGET_MODE_ENTRY``\n+  must be defined.\n+\n+.. hook-end\n+\n+.. function:: int TARGET_MODE_PRIORITY (int entity, int n)\n+\n+  .. hook-start:TARGET_MODE_PRIORITY\n+\n+  This macro specifies the order in which modes for :samp:`{entity}`\n+  are processed. 0 is the highest priority,\n+  ``NUM_MODES_FOR_MODE_SWITCHING[entity] - 1`` the lowest.\n+  The value of the macro should be an integer designating a mode\n+  for :samp:`{entity}`.  For any fixed :samp:`{entity}`, ``mode_priority``\n+  (:samp:`{entity}`, :samp:`{n}`) shall be a bijection in 0 ...\n+  ``num_modes_for_mode_switching[entity] - 1``.\n+\n+.. hook-end\n\\ No newline at end of file"}, {"sha": "a85e4a0646ac2abd25f78d79ef78645b7a9c5d04", "filename": "gcc/doc/gccint/target-macros/parameters-for-precompiled-header-validity-checking.rst", "status": "modified", "additions": 45, "deletions": 12, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fparameters-for-precompiled-header-validity-checking.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fparameters-for-precompiled-header-validity-checking.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fparameters-for-precompiled-header-validity-checking.rst?ref=3e070cff11f81051e70b613816075b66a6de61c2", "patch": "@@ -10,21 +10,54 @@\n Parameters for Precompiled Header Validity Checking\n ***************************************************\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_GET_PCH_VALIDITY]\n-  :end-before: [TARGET_GET_PCH_VALIDITY]\n+.. function:: void * TARGET_GET_PCH_VALIDITY (size_t *sz)\n \n+  .. hook-start:TARGET_GET_PCH_VALIDITY\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_PCH_VALID_P]\n-  :end-before: [TARGET_PCH_VALID_P]\n+  This hook returns a pointer to the data needed by\n+  ``TARGET_PCH_VALID_P`` and sets\n+  :samp:`*{sz}` to the size of the data in bytes.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_CHECK_PCH_TARGET_FLAGS]\n-  :end-before: [TARGET_CHECK_PCH_TARGET_FLAGS]\n+.. function:: const char * TARGET_PCH_VALID_P (const void *data, size_t sz)\n \n+  .. hook-start:TARGET_PCH_VALID_P\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_PREPARE_PCH_SAVE]\n-  :end-before: [TARGET_PREPARE_PCH_SAVE]\n+  This hook checks whether the options used to create a PCH file are\n+  compatible with the current settings.  It returns ``NULL``\n+  if so and a suitable error message if not.  Error messages will\n+  be presented to the user and must be localized using :samp:`_({msg})`.\n+\n+  :samp:`{data}` is the data that was returned by ``TARGET_GET_PCH_VALIDITY``\n+  when the PCH file was created and :samp:`{sz}` is the size of that data in bytes.\n+  It's safe to assume that the data was created by the same version of the\n+  compiler, so no format checking is needed.\n+\n+  The default definition of ``default_pch_valid_p`` should be\n+  suitable for most targets.\n+\n+.. hook-end\n+\n+.. function:: const char * TARGET_CHECK_PCH_TARGET_FLAGS (int pch_flags)\n+\n+  .. hook-start:TARGET_CHECK_PCH_TARGET_FLAGS\n+\n+  If this hook is nonnull, the default implementation of\n+  ``TARGET_PCH_VALID_P`` will use it to check for compatible values\n+  of ``target_flags``.  :samp:`{pch_flags}` specifies the value that\n+  ``target_flags`` had when the PCH file was created.  The return\n+  value is the same as for ``TARGET_PCH_VALID_P``.\n+\n+.. hook-end\n+\n+.. function:: void TARGET_PREPARE_PCH_SAVE (void)\n+\n+  .. hook-start:TARGET_PREPARE_PCH_SAVE\n+\n+  Called before writing out a PCH file.  If the target has some\n+  garbage-collected data that needs to be in a particular state on PCH loads,\n+  it can use this hook to enforce that state.  Very few targets need\n+  to do anything here.\n+\n+.. hook-end\n\\ No newline at end of file"}, {"sha": "b1654579576e6698282e52c197405753df0d2079", "filename": "gcc/doc/gccint/target-macros/register-classes.rst", "status": "modified", "additions": 402, "deletions": 63, "changes": 465, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fregister-classes.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fregister-classes.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fregister-classes.rst?ref=3e070cff11f81051e70b613816075b66a6de61c2", "patch": "@@ -221,15 +221,60 @@ in many of the tables described below.\n   looking for one that is valid, and will reload one or both registers\n   only if neither labeling works.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_PREFERRED_RENAME_CLASS]\n-  :end-before: [TARGET_PREFERRED_RENAME_CLASS]\n+.. function:: reg_class_t TARGET_PREFERRED_RENAME_CLASS (reg_class_t rclass)\n \n+  .. hook-start:TARGET_PREFERRED_RENAME_CLASS\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_PREFERRED_RELOAD_CLASS]\n-  :end-before: [TARGET_PREFERRED_RELOAD_CLASS]\n+  A target hook that places additional preference on the register\n+  class to use when it is necessary to rename a register in class\n+  :samp:`{rclass}` to another class, or perhaps :samp:`{NO_REGS}`, if no\n+  preferred register class is found or hook ``preferred_rename_class``\n+  is not implemented.\n+  Sometimes returning a more restrictive class makes better code.  For\n+  example, on ARM, thumb-2 instructions using ``LO_REGS`` may be\n+  smaller than instructions using ``GENERIC_REGS``.  By returning\n+  ``LO_REGS`` from ``preferred_rename_class``, code size can\n+  be reduced.\n+\n+.. hook-end\n+\n+.. function:: reg_class_t TARGET_PREFERRED_RELOAD_CLASS (rtx x, reg_class_t rclass)\n+\n+  .. hook-start:TARGET_PREFERRED_RELOAD_CLASS\n+\n+  A target hook that places additional restrictions on the register class\n+  to use when it is necessary to copy value :samp:`{x}` into a register in class\n+  :samp:`{rclass}`.  The value is a register class; perhaps :samp:`{rclass}`, or perhaps\n+  another, smaller class.\n+\n+  The default version of this hook always returns value of ``rclass`` argument.\n+\n+  Sometimes returning a more restrictive class makes better code.  For\n+  example, on the 68000, when :samp:`{x}` is an integer constant that is in range\n+  for a :samp:`moveq` instruction, the value of this macro is always\n+  ``DATA_REGS`` as long as :samp:`{rclass}` includes the data registers.\n+  Requiring a data register guarantees that a :samp:`moveq` will be used.\n+\n+  One case where ``TARGET_PREFERRED_RELOAD_CLASS`` must not return\n+  :samp:`{rclass}` is if :samp:`{x}` is a legitimate constant which cannot be\n+  loaded into some register class.  By returning ``NO_REGS`` you can\n+  force :samp:`{x}` into a memory location.  For example, rs6000 can load\n+  immediate values into general-purpose registers, but does not have an\n+  instruction for loading an immediate value into a floating-point\n+  register, so ``TARGET_PREFERRED_RELOAD_CLASS`` returns ``NO_REGS`` when\n+  :samp:`{x}` is a floating-point constant.  If the constant can't be loaded\n+  into any kind of register, code generation will be better if\n+  ``TARGET_LEGITIMATE_CONSTANT_P`` makes the constant illegitimate instead\n+  of using ``TARGET_PREFERRED_RELOAD_CLASS``.\n+\n+  If an insn has pseudos in it after register allocation, reload will go\n+  through the alternatives and call repeatedly ``TARGET_PREFERRED_RELOAD_CLASS``\n+  to find the best one.  Returning ``NO_REGS``, in this case, makes\n+  reload add a ``!`` in front of the constraint: the x86 back-end uses\n+  this feature to discourage usage of 387 registers when math is done in\n+  the SSE registers (and vice versa).\n \n+.. hook-end\n \n .. c:macro:: PREFERRED_RELOAD_CLASS (x, class)\n \n@@ -268,10 +313,20 @@ in many of the tables described below.\n   this feature to discourage usage of 387 registers when math is done in\n   the SSE registers (and vice versa).\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_PREFERRED_OUTPUT_RELOAD_CLASS]\n-  :end-before: [TARGET_PREFERRED_OUTPUT_RELOAD_CLASS]\n+.. function:: reg_class_t TARGET_PREFERRED_OUTPUT_RELOAD_CLASS (rtx x, reg_class_t rclass)\n+\n+  .. hook-start:TARGET_PREFERRED_OUTPUT_RELOAD_CLASS\n+\n+  Like ``TARGET_PREFERRED_RELOAD_CLASS``, but for output reloads instead of\n+  input reloads.\n \n+  The default version of this hook always returns value of ``rclass``\n+  argument.\n+\n+  You can also use ``TARGET_PREFERRED_OUTPUT_RELOAD_CLASS`` to discourage\n+  reload from using some alternatives, like ``TARGET_PREFERRED_RELOAD_CLASS``.\n+\n+.. hook-end\n \n .. c:macro:: LIMIT_RELOAD_CLASS (mode, class)\n \n@@ -289,10 +344,103 @@ in many of the tables described below.\n   Don't define this macro unless the target machine has limitations which\n   require the macro to do something nontrivial.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SECONDARY_RELOAD]\n-  :end-before: [TARGET_SECONDARY_RELOAD]\n+.. function:: reg_class_t TARGET_SECONDARY_RELOAD (bool in_p, rtx x, reg_class_t reload_class, machine_mode reload_mode, secondary_reload_info *sri)\n+\n+  .. hook-start:TARGET_SECONDARY_RELOAD\n+\n+  Many machines have some registers that cannot be copied directly to or\n+  from memory or even from other types of registers.  An example is the\n+  :samp:`MQ` register, which on most machines, can only be copied to or\n+  from general registers, but not memory.  Below, we shall be using the\n+  term 'intermediate register' when a move operation cannot be performed\n+  directly, but has to be done by copying the source into the intermediate\n+  register first, and then copying the intermediate register to the\n+  destination.  An intermediate register always has the same mode as\n+  source and destination.  Since it holds the actual value being copied,\n+  reload might apply optimizations to re-use an intermediate register\n+  and eliding the copy from the source when it can determine that the\n+  intermediate register still holds the required value.\n+\n+  Another kind of secondary reload is required on some machines which\n+  allow copying all registers to and from memory, but require a scratch\n+  register for stores to some memory locations (e.g., those with symbolic\n+  address on the RT, and those with certain symbolic address on the SPARC\n+  when compiling PIC).  Scratch registers need not have the same mode\n+  as the value being copied, and usually hold a different value than\n+  that being copied.  Special patterns in the md file are needed to\n+  describe how the copy is performed with the help of the scratch register;\n+  these patterns also describe the number, register class(es) and mode(s)\n+  of the scratch register(s).\n+\n+  In some cases, both an intermediate and a scratch register are required.\n+\n+  For input reloads, this target hook is called with nonzero :samp:`{in_p}`,\n+  and :samp:`{x}` is an rtx that needs to be copied to a register of class\n+  :samp:`{reload_class}` in :samp:`{reload_mode}`.  For output reloads, this target\n+  hook is called with zero :samp:`{in_p}`, and a register of class :samp:`{reload_class}`\n+  needs to be copied to rtx :samp:`{x}` in :samp:`{reload_mode}`.\n+\n+  If copying a register of :samp:`{reload_class}` from/to :samp:`{x}` requires\n+  an intermediate register, the hook ``secondary_reload`` should\n+  return the register class required for this intermediate register.\n+  If no intermediate register is required, it should return NO_REGS.\n+  If more than one intermediate register is required, describe the one\n+  that is closest in the copy chain to the reload register.\n+\n+  If scratch registers are needed, you also have to describe how to\n+  perform the copy from/to the reload register to/from this\n+  closest intermediate register.  Or if no intermediate register is\n+  required, but still a scratch register is needed, describe the\n+  copy  from/to the reload register to/from the reload operand :samp:`{x}`.\n+\n+  You do this by setting ``sri->icode`` to the instruction code of a pattern\n+  in the md file which performs the move.  Operands 0 and 1 are the output\n+  and input of this copy, respectively.  Operands from operand 2 onward are\n+  for scratch operands.  These scratch operands must have a mode, and a\n+  single-register-class\n+\n+  .. [later: or memory]\n+\n+  output constraint.\n+\n+  When an intermediate register is used, the ``secondary_reload``\n+  hook will be called again to determine how to copy the intermediate\n+  register to/from the reload operand :samp:`{x}`, so your hook must also\n+  have code to handle the register class of the intermediate operand.\n+\n+  .. [For later: maybe we'll allow multi-alternative reload patterns -\n+\n+  ..   the port maintainer could name a mov<mode> pattern that has clobbers -\n+\n+  ..   and match the constraints of input and output to determine the required\n+\n+  ..   alternative.  A restriction would be that constraints used to match\n+\n+  ..   against reloads registers would have to be written as register class\n+\n+  ..   constraints, or we need a new target macro / hook that tells us if an\n+\n+  ..   arbitrary constraint can match an unknown register of a given class.\n+\n+  ..   Such a macro / hook would also be useful in other places.]\n+\n+  :samp:`{x}` might be a pseudo-register or a ``subreg`` of a\n+  pseudo-register, which could either be in a hard register or in memory.\n+  Use ``true_regnum`` to find out; it will return -1 if the pseudo is\n+  in memory and the hard register number if it is in a register.\n+\n+  Scratch operands in memory (constraint ``\"=m\"`` / ``\"=&m\"``) are\n+  currently not supported.  For the time being, you will have to continue\n+  to use ``TARGET_SECONDARY_MEMORY_NEEDED`` for that purpose.\n+\n+  ``copy_cost`` also uses this target hook to find out how values are\n+  copied.  If you want it to include some extra cost for the need to allocate\n+  (a) scratch register(s), set ``sri->extra_cost`` to the additional cost.\n+  Or if two dependent moves are supposed to have a lower cost than the sum\n+  of the individual moves due to expected fortuitous scheduling and/or special\n+  forwarding logic, you can set ``sri->extra_cost`` to a negative amount.\n \n+.. hook-end\n \n .. c:macro:: SECONDARY_RELOAD_CLASS (class, mode, x)\n              SECONDARY_INPUT_RELOAD_CLASS (class, mode, x)\n@@ -354,10 +502,19 @@ in many of the tables described below.\n   intermediate storage.  This case often occurs between floating-point and\n   general registers.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SECONDARY_MEMORY_NEEDED]\n-  :end-before: [TARGET_SECONDARY_MEMORY_NEEDED]\n+.. function:: bool TARGET_SECONDARY_MEMORY_NEEDED (machine_mode mode, reg_class_t class1, reg_class_t class2)\n \n+  .. hook-start:TARGET_SECONDARY_MEMORY_NEEDED\n+\n+  Certain machines have the property that some registers cannot be copied\n+  to some other registers without using memory.  Define this hook on\n+  those machines to return true if objects of mode :samp:`{m}` in registers\n+  of :samp:`{class1}` can only be copied to registers of class :samp:`{class2}` by\n+  storing a register of :samp:`{class1}` into memory and loading that memory\n+  location into a register of :samp:`{class2}`.  The default definition returns\n+  false for all inputs.\n+\n+.. hook-end\n \n .. c:macro:: SECONDARY_MEMORY_NEEDED_RTX (mode)\n \n@@ -369,25 +526,87 @@ in many of the tables described below.\n   Do not define this macro if you do not define\n   ``TARGET_SECONDARY_MEMORY_NEEDED``.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SECONDARY_MEMORY_NEEDED_MODE]\n-  :end-before: [TARGET_SECONDARY_MEMORY_NEEDED_MODE]\n+.. function:: machine_mode TARGET_SECONDARY_MEMORY_NEEDED_MODE (machine_mode mode)\n+\n+  .. hook-start:TARGET_SECONDARY_MEMORY_NEEDED_MODE\n+\n+  If ``TARGET_SECONDARY_MEMORY_NEEDED`` tells the compiler to use memory\n+  when moving between two particular registers of mode :samp:`{mode}`,\n+  this hook specifies the mode that the memory should have.\n+\n+  The default depends on ``TARGET_LRA_P``.  Without LRA, the default\n+  is to use a word-sized mode for integral modes that are smaller than a\n+  a word.  This is right thing to do on most machines because it ensures\n+  that all bits of the register are copied and prevents accesses to the\n+  registers in a narrower mode, which some machines prohibit for\n+  floating-point registers.\n+\n+  However, this default behavior is not correct on some machines, such as\n+  the DEC Alpha, that store short integers in floating-point registers\n+  differently than in integer registers.  On those machines, the default\n+  widening will not work correctly and you must define this hook to\n+  suppress that widening in some cases.  See the file :samp:`alpha.cc` for\n+  details.\n+\n+  With LRA, the default is to use :samp:`{mode}` unmodified.\n+\n+.. hook-end\n+\n+.. function:: void TARGET_SELECT_EARLY_REMAT_MODES (sbitmap modes)\n+\n+  .. hook-start:TARGET_SELECT_EARLY_REMAT_MODES\n+\n+  On some targets, certain modes cannot be held in registers around a\n+  standard ABI call and are relatively expensive to spill to the stack.\n+  The early rematerialization pass can help in such cases by aggressively\n+  recomputing values after calls, so that they don't need to be spilled.\n+\n+  This hook returns the set of such modes by setting the associated bits\n+  in :samp:`{modes}`.  The default implementation selects no modes, which has\n+  the effect of disabling the early rematerialization pass.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_CLASS_LIKELY_SPILLED_P (reg_class_t rclass)\n \n+  .. hook-start:TARGET_CLASS_LIKELY_SPILLED_P\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SELECT_EARLY_REMAT_MODES]\n-  :end-before: [TARGET_SELECT_EARLY_REMAT_MODES]\n+  A target hook which returns ``true`` if pseudos that have been assigned\n+  to registers of class :samp:`{rclass}` would likely be spilled because\n+  registers of :samp:`{rclass}` are needed for spill registers.\n \n+  The default version of this target hook returns ``true`` if :samp:`{rclass}`\n+  has exactly one register and ``false`` otherwise.  On most machines, this\n+  default should be used.  For generally register-starved machines, such as\n+  i386, or machines with right register constraints, such as SH, this hook\n+  can be used to avoid excessive spilling.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_CLASS_LIKELY_SPILLED_P]\n-  :end-before: [TARGET_CLASS_LIKELY_SPILLED_P]\n+  This hook is also used by some of the global intra-procedural code\n+  transformations to throtle code motion, to avoid increasing register\n+  pressure.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_CLASS_MAX_NREGS]\n-  :end-before: [TARGET_CLASS_MAX_NREGS]\n+.. function:: unsigned char TARGET_CLASS_MAX_NREGS (reg_class_t rclass, machine_mode mode)\n \n+  .. hook-start:TARGET_CLASS_MAX_NREGS\n+\n+  A target hook returns the maximum number of consecutive registers\n+  of class :samp:`{rclass}` needed to hold a value of mode :samp:`{mode}`.\n+\n+  This is closely related to the macro ``TARGET_HARD_REGNO_NREGS``.\n+  In fact, the value returned by ``TARGET_CLASS_MAX_NREGS (rclass,\n+  mode)`` target hook should be the maximum value of\n+  ``TARGET_HARD_REGNO_NREGS (regno, mode)`` for all :samp:`{regno}`\n+  values in the class :samp:`{rclass}`.\n+\n+  This target hook helps control the handling of multiple-word values\n+  in the reload pass.\n+\n+  The default version of this target hook returns the size of :samp:`{mode}`\n+  in words.\n+\n+.. hook-end\n \n .. c:macro:: CLASS_MAX_NREGS (class, mode)\n \n@@ -402,61 +621,181 @@ in many of the tables described below.\n   This macro helps control the handling of multiple-word values\n   in the reload pass.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_CAN_CHANGE_MODE_CLASS]\n-  :end-before: [TARGET_CAN_CHANGE_MODE_CLASS]\n+.. function:: bool TARGET_CAN_CHANGE_MODE_CLASS (machine_mode from, machine_mode to, reg_class_t rclass)\n+\n+  .. hook-start:TARGET_CAN_CHANGE_MODE_CLASS\n+\n+  This hook returns true if it is possible to bitcast values held in\n+  registers of class :samp:`{rclass}` from mode :samp:`{from}` to mode :samp:`{to}`\n+  and if doing so preserves the low-order bits that are common to both modes.\n+  The result is only meaningful if :samp:`{rclass}` has registers that can hold\n+  both ``from`` and ``to``.  The default implementation returns true.\n+\n+  As an example of when such bitcasting is invalid, loading 32-bit integer or\n+  floating-point objects into floating-point registers on Alpha extends them\n+  to 64 bits.  Therefore loading a 64-bit object and then storing it as a\n+  32-bit object does not store the low-order 32 bits, as would be the case\n+  for a normal register.  Therefore, :samp:`alpha.h` defines\n+  ``TARGET_CAN_CHANGE_MODE_CLASS`` to return:\n+\n+  .. code-block:: c++\n+\n+    (GET_MODE_SIZE (from) == GET_MODE_SIZE (to)\n+     || !reg_classes_intersect_p (FLOAT_REGS, rclass))\n+\n+  Even if storing from a register in mode :samp:`{to}` would be valid,\n+  if both :samp:`{from}` and ``raw_reg_mode`` for :samp:`{rclass}` are wider\n+  than ``word_mode``, then we must prevent :samp:`{to}` narrowing the\n+  mode.  This happens when the middle-end assumes that it can load\n+  or store pieces of an :samp:`{N}` -word pseudo, and that the pseudo will\n+  eventually be allocated to :samp:`{N}` ``word_mode`` hard registers.\n+  Failure to prevent this kind of mode change will result in the\n+  entire ``raw_reg_mode`` being modified instead of the partial\n+  value that the middle-end intended.\n+\n+.. hook-end\n+\n+.. function:: reg_class_t TARGET_IRA_CHANGE_PSEUDO_ALLOCNO_CLASS (int, reg_class_t, reg_class_t)\n+\n+  .. hook-start:TARGET_IRA_CHANGE_PSEUDO_ALLOCNO_CLASS\n+\n+  A target hook which can change allocno class for given pseudo from\n+  allocno and best class calculated by IRA.\n+\n+  The default version of this target hook always returns given class.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_LRA_P (void)\n+\n+  .. hook-start:TARGET_LRA_P\n+\n+  A target hook which returns true if we use LRA instead of reload pass.\n+\n+  The default version of this target hook returns true.  New ports\n+  should use LRA, and existing ports are encouraged to convert.\n+\n+.. hook-end\n+\n+.. function:: int TARGET_REGISTER_PRIORITY (int)\n+\n+  .. hook-start:TARGET_REGISTER_PRIORITY\n+\n+  A target hook which returns the register priority number to which the\n+  register :samp:`{hard_regno}` belongs to.  The bigger the number, the\n+  more preferable the hard register usage (when all other conditions are\n+  the same).  This hook can be used to prefer some hard register over\n+  others in LRA.  For example, some x86-64 register usage needs\n+  additional prefix which makes instructions longer.  The hook can\n+  return lower priority number for such registers make them less favorable\n+  and as result making the generated code smaller.\n+\n+  The default version of this target hook returns always zero.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_REGISTER_USAGE_LEVELING_P (void)\n+\n+  .. hook-start:TARGET_REGISTER_USAGE_LEVELING_P\n+\n+  A target hook which returns true if we need register usage leveling.\n+  That means if a few hard registers are equally good for the\n+  assignment, we choose the least used hard register.  The register\n+  usage leveling may be profitable for some targets.  Don't use the\n+  usage leveling for targets with conditional execution or targets\n+  with big register files as it hurts if-conversion and cross-jumping\n+  optimizations.\n+\n+  The default version of this target hook returns always false.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_DIFFERENT_ADDR_DISPLACEMENT_P (void)\n+\n+  .. hook-start:TARGET_DIFFERENT_ADDR_DISPLACEMENT_P\n+\n+  A target hook which returns true if an address with the same structure\n+  can have different maximal legitimate displacement.  For example, the\n+  displacement can depend on memory mode or on operand combinations in\n+  the insn.\n+\n+  The default version of this target hook returns always false.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_CANNOT_SUBSTITUTE_MEM_EQUIV_P (rtx subst)\n+\n+  .. hook-start:TARGET_CANNOT_SUBSTITUTE_MEM_EQUIV_P\n+\n+  A target hook which returns ``true`` if :samp:`{subst}` can't\n+  substitute safely pseudos with equivalent memory values during\n+  register allocation.\n+  The default version of this target hook returns ``false``.\n+  On most machines, this default should be used.  For generally\n+  machines with non orthogonal register usage for addressing, such\n+  as SH, this hook can be used to avoid excessive spilling.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_IRA_CHANGE_PSEUDO_ALLOCNO_CLASS]\n-  :end-before: [TARGET_IRA_CHANGE_PSEUDO_ALLOCNO_CLASS]\n+.. function:: bool TARGET_LEGITIMIZE_ADDRESS_DISPLACEMENT (rtx *offset1, rtx *offset2, poly_int64 orig_offset, machine_mode mode)\n \n+  .. hook-start:TARGET_LEGITIMIZE_ADDRESS_DISPLACEMENT\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_LRA_P]\n-  :end-before: [TARGET_LRA_P]\n+  This hook tries to split address offset :samp:`{orig_offset}` into\n+  two parts: one that should be added to the base address to create\n+  a local anchor point, and an additional offset that can be applied\n+  to the anchor to address a value of mode :samp:`{mode}`.  The idea is that\n+  the local anchor could be shared by other accesses to nearby locations.\n \n+  The hook returns true if it succeeds, storing the offset of the\n+  anchor from the base in :samp:`{offset1}` and the offset of the final address\n+  from the anchor in :samp:`{offset2}`.  The default implementation returns false.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_REGISTER_PRIORITY]\n-  :end-before: [TARGET_REGISTER_PRIORITY]\n+.. hook-end\n \n+.. function:: reg_class_t TARGET_SPILL_CLASS (reg_class_t, machine_mode)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_REGISTER_USAGE_LEVELING_P]\n-  :end-before: [TARGET_REGISTER_USAGE_LEVELING_P]\n+  .. hook-start:TARGET_SPILL_CLASS\n \n+  This hook defines a class of registers which could be used for spilling\n+  pseudos of the given mode and class, or ``NO_REGS`` if only memory\n+  should be used.  Not defining this hook is equivalent to returning\n+  ``NO_REGS`` for all inputs.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_DIFFERENT_ADDR_DISPLACEMENT_P]\n-  :end-before: [TARGET_DIFFERENT_ADDR_DISPLACEMENT_P]\n+.. hook-end\n \n+.. function:: bool TARGET_ADDITIONAL_ALLOCNO_CLASS_P (reg_class_t)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_CANNOT_SUBSTITUTE_MEM_EQUIV_P]\n-  :end-before: [TARGET_CANNOT_SUBSTITUTE_MEM_EQUIV_P]\n+  .. hook-start:TARGET_ADDITIONAL_ALLOCNO_CLASS_P\n \n+  This hook should return ``true`` if given class of registers should\n+  be an allocno class in any way.  Usually RA uses only one register\n+  class from all classes containing the same register set.  In some\n+  complicated cases, you need to have two or more such classes as\n+  allocno ones for RA correct work.  Not defining this hook is\n+  equivalent to returning ``false`` for all inputs.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_LEGITIMIZE_ADDRESS_DISPLACEMENT]\n-  :end-before: [TARGET_LEGITIMIZE_ADDRESS_DISPLACEMENT]\n+.. hook-end\n \n+.. function:: scalar_int_mode TARGET_CSTORE_MODE (enum insn_code icode)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_SPILL_CLASS]\n-  :end-before: [TARGET_SPILL_CLASS]\n+  .. hook-start:TARGET_CSTORE_MODE\n \n+  This hook defines the machine mode to use for the boolean result of\n+  conditional store patterns.  The ICODE argument is the instruction code\n+  for the cstore being performed.  Not definiting this hook is the same\n+  as accepting the mode encoded into operand 0 of the cstore expander\n+  patterns.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_ADDITIONAL_ALLOCNO_CLASS_P]\n-  :end-before: [TARGET_ADDITIONAL_ALLOCNO_CLASS_P]\n+.. hook-end\n \n+.. function:: int TARGET_COMPUTE_PRESSURE_CLASSES (enum reg_class *pressure_classes)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_CSTORE_MODE]\n-  :end-before: [TARGET_CSTORE_MODE]\n+  .. hook-start:TARGET_COMPUTE_PRESSURE_CLASSES\n \n+  A target hook which lets a backend compute the set of pressure classes to\n+  be used by those optimization passes which take register pressure into\n+  account, as opposed to letting IRA compute them.  It returns the number of\n+  register classes stored in the array :samp:`{pressure_classes}`.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_COMPUTE_PRESSURE_CLASSES]\n-  :end-before: [TARGET_COMPUTE_PRESSURE_CLASSES]\n+.. hook-end\n\\ No newline at end of file"}, {"sha": "4860f0a766a018af64e22d5e096b36cf877102ec", "filename": "gcc/doc/gccint/target-macros/register-usage.rst", "status": "modified", "additions": 191, "deletions": 29, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fregister-usage.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fregister-usage.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fregister-usage.rst?ref=3e070cff11f81051e70b613816075b66a6de61c2", "patch": "@@ -91,34 +91,104 @@ Registers have various characteristics.\n \n .. index:: call-used register, call-clobbered register, call-saved register\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_FNTYPE_ABI]\n-  :end-before: [TARGET_FNTYPE_ABI]\n+.. function:: const predefined_function_abi & TARGET_FNTYPE_ABI (const_tree type)\n \n+  .. hook-start:TARGET_FNTYPE_ABI\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_INSN_CALLEE_ABI]\n-  :end-before: [TARGET_INSN_CALLEE_ABI]\n+  Return the ABI used by a function with type :samp:`{type}` ; see the\n+  definition of ``predefined_function_abi`` for details of the ABI\n+  descriptor.  Targets only need to define this hook if they support\n+  interoperability between several ABIs in the same translation unit.\n \n+.. hook-end\n+\n+.. function:: const predefined_function_abi & TARGET_INSN_CALLEE_ABI (const rtx_insn *insn)\n+\n+  .. hook-start:TARGET_INSN_CALLEE_ABI\n+\n+  This hook returns a description of the ABI used by the target of\n+  call instruction :samp:`{insn}` ; see the definition of\n+  ``predefined_function_abi`` for details of the ABI descriptor.\n+  Only the global function ``insn_callee_abi`` should call this hook\n+  directly.\n+\n+  Targets only need to define this hook if they support\n+  interoperability between several ABIs in the same translation unit.\n+\n+.. hook-end\n \n .. index:: call-used register, call-clobbered register, call-saved register\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_HARD_REGNO_CALL_PART_CLOBBERED]\n-  :end-before: [TARGET_HARD_REGNO_CALL_PART_CLOBBERED]\n+.. function:: bool TARGET_HARD_REGNO_CALL_PART_CLOBBERED (unsigned int abi_id, unsigned int regno, machine_mode mode)\n \n+  .. hook-start:TARGET_HARD_REGNO_CALL_PART_CLOBBERED\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_GET_MULTILIB_ABI_NAME]\n-  :end-before: [TARGET_GET_MULTILIB_ABI_NAME]\n+  ABIs usually specify that calls must preserve the full contents\n+  of a particular register, or that calls can alter any part of a\n+  particular register.  This information is captured by the target macro\n+  ``CALL_REALLY_USED_REGISTERS``.  However, some ABIs specify that calls\n+  must preserve certain bits of a particular register but can alter others.\n+  This hook should return true if this applies to at least one of the\n+  registers in :samp:`(reg:{mode}{regno})`, and if as a result the\n+  call would alter part of the :samp:`{mode}` value.  For example, if a call\n+  preserves the low 32 bits of a 64-bit hard register :samp:`{regno}` but can\n+  clobber the upper 32 bits, this hook should return true for a 64-bit mode\n+  but false for a 32-bit mode.\n \n+  The value of :samp:`{abi_id}` comes from the ``predefined_function_abi``\n+  structure that describes the ABI of the call; see the definition of the\n+  structure for more details.  If (as is usual) the target uses the same ABI\n+  for all functions in a translation unit, :samp:`{abi_id}` is always 0.\n \n-.. index:: fixed_regs, call_used_regs, global_regs, reg_names, reg_class_contents\n+  The default implementation returns false, which is correct\n+  for targets that don't have partly call-clobbered registers.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_CONDITIONAL_REGISTER_USAGE]\n-  :end-before: [TARGET_CONDITIONAL_REGISTER_USAGE]\n+.. hook-end\n+\n+.. function:: const char * TARGET_GET_MULTILIB_ABI_NAME (void)\n+\n+  .. hook-start:TARGET_GET_MULTILIB_ABI_NAME\n+\n+  This hook returns name of multilib ABI name.\n+\n+.. hook-end\n+\n+.. index:: fixed_regs, call_used_regs, global_regs, reg_names, reg_class_contents\n \n+.. function:: void TARGET_CONDITIONAL_REGISTER_USAGE (void)\n+\n+  .. hook-start:TARGET_CONDITIONAL_REGISTER_USAGE\n+\n+  This hook may conditionally modify five variables\n+  ``fixed_regs``, ``call_used_regs``, ``global_regs``,\n+  ``reg_names``, and ``reg_class_contents``, to take into account\n+  any dependence of these register sets on target flags.  The first three\n+  of these are of type ``char []`` (interpreted as boolean vectors).\n+  ``global_regs`` is a ``const char *[]``, and\n+  ``reg_class_contents`` is a ``HARD_REG_SET``.  Before the macro is\n+  called, ``fixed_regs``, ``call_used_regs``,\n+  ``reg_class_contents``, and ``reg_names`` have been initialized\n+  from ``FIXED_REGISTERS``, ``CALL_USED_REGISTERS``,\n+  ``REG_CLASS_CONTENTS``, and ``REGISTER_NAMES``, respectively.\n+  ``global_regs`` has been cleared, and any :option:`-ffixed-reg`,\n+  :option:`-fcall-used-reg` and :option:`-fcall-saved-reg`\n+  command options have been applied.\n+\n+  .. index:: disabling certain registers, controlling register usage\n+\n+  If the usage of an entire class of registers depends on the target\n+  flags, you may indicate this to GCC by using this macro to modify\n+  ``fixed_regs`` and ``call_used_regs`` to 1 for each of the\n+  registers in the classes which should not be used by GCC.  Also make\n+  ``define_register_constraint`` s return ``NO_REGS`` for constraints\n+  that shouldn't be used.\n+\n+  (However, if this class is not included in ``GENERAL_REGS`` and all\n+  of the insn patterns whose constraints permit this class are\n+  controlled by target switches, then GCC will automatically avoid using\n+  these registers when the target switches are opposed to them.)\n+\n+.. hook-end\n \n .. c:macro:: INCOMING_REGNO (out)\n \n@@ -219,10 +289,20 @@ This section discusses the macros that describe which kinds of values\n (specifically, which machine modes) each register can hold, and how many\n consecutive registers are needed for a given mode.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_HARD_REGNO_NREGS]\n-  :end-before: [TARGET_HARD_REGNO_NREGS]\n+.. function:: unsigned int TARGET_HARD_REGNO_NREGS (unsigned int regno, machine_mode mode)\n \n+  .. hook-start:TARGET_HARD_REGNO_NREGS\n+\n+  This hook returns the number of consecutive hard registers, starting\n+  at register number :samp:`{regno}`, required to hold a value of mode\n+  :samp:`{mode}`.  This hook must never return zero, even if a register\n+  cannot hold the requested mode - indicate that with\n+  ``TARGET_HARD_REGNO_MODE_OK`` and/or\n+  ``TARGET_CAN_CHANGE_MODE_CLASS`` instead.\n+\n+  The default definition returns the number of words in :samp:`{mode}`.\n+\n+.. hook-end\n \n .. c:macro:: HARD_REGNO_NREGS_HAS_PADDING (regno, mode)\n \n@@ -260,10 +340,67 @@ consecutive registers are needed for a given mode.\n   happens for example on SPARC 64-bit where the natural size of\n   floating-point registers is still 32-bit.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_HARD_REGNO_MODE_OK]\n-  :end-before: [TARGET_HARD_REGNO_MODE_OK]\n-\n+.. function:: bool TARGET_HARD_REGNO_MODE_OK (unsigned int regno, machine_mode mode)\n+\n+  .. hook-start:TARGET_HARD_REGNO_MODE_OK\n+\n+  This hook returns true if it is permissible to store a value\n+  of mode :samp:`{mode}` in hard register number :samp:`{regno}` (or in several\n+  registers starting with that one).  The default definition returns true\n+  unconditionally.\n+\n+  You need not include code to check for the numbers of fixed registers,\n+  because the allocation mechanism considers them to be always occupied.\n+\n+  .. index:: register pairs\n+\n+  On some machines, double-precision values must be kept in even/odd\n+  register pairs.  You can implement that by defining this hook to reject\n+  odd register numbers for such modes.\n+\n+  The minimum requirement for a mode to be OK in a register is that the\n+  :samp:`mov{mode}` instruction pattern support moves between the\n+  register and other hard register in the same class and that moving a\n+  value into the register and back out not alter it.\n+\n+  Since the same instruction used to move ``word_mode`` will work for\n+  all narrower integer modes, it is not necessary on any machine for\n+  this hook to distinguish between these modes, provided you define\n+  patterns :samp:`movhi`, etc., to take advantage of this.  This is\n+  useful because of the interaction between ``TARGET_HARD_REGNO_MODE_OK``\n+  and ``TARGET_MODES_TIEABLE_P`` ; it is very desirable for all integer\n+  modes to be tieable.\n+\n+  Many machines have special registers for floating point arithmetic.\n+  Often people assume that floating point machine modes are allowed only\n+  in floating point registers.  This is not true.  Any registers that\n+  can hold integers can safely *hold* a floating point machine\n+  mode, whether or not floating arithmetic can be done on it in those\n+  registers.  Integer move instructions can be used to move the values.\n+\n+  On some machines, though, the converse is true: fixed-point machine\n+  modes may not go in floating registers.  This is true if the floating\n+  registers normalize any value stored in them, because storing a\n+  non-floating value there would garble it.  In this case,\n+  ``TARGET_HARD_REGNO_MODE_OK`` should reject fixed-point machine modes in\n+  floating registers.  But if the floating registers do not automatically\n+  normalize, if you can store any bit pattern in one and retrieve it\n+  unchanged without a trap, then any machine mode may go in a floating\n+  register, so you can define this hook to say so.\n+\n+  The primary significance of special floating registers is rather that\n+  they are the registers acceptable in floating point arithmetic\n+  instructions.  However, this is of no concern to\n+  ``TARGET_HARD_REGNO_MODE_OK``.  You handle it by writing the proper\n+  constraints for those instructions.\n+\n+  On some machines, the floating registers are especially slow to access,\n+  so that it is better to store a value in a stack frame than in such a\n+  register if floating point arithmetic is not being done.  As long as the\n+  floating registers are not in class ``GENERAL_REGS``, they will not\n+  be used unless some pattern's constraint asks for one.\n+\n+.. hook-end\n \n .. c:macro:: HARD_REGNO_RENAME_OK (from, to)\n \n@@ -276,15 +413,40 @@ consecutive registers are needed for a given mode.\n \n   The default is always nonzero.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_MODES_TIEABLE_P]\n-  :end-before: [TARGET_MODES_TIEABLE_P]\n+.. function:: bool TARGET_MODES_TIEABLE_P (machine_mode mode1, machine_mode mode2)\n+\n+  .. hook-start:TARGET_MODES_TIEABLE_P\n+\n+  This hook returns true if a value of mode :samp:`{mode1}` is accessible\n+  in mode :samp:`{mode2}` without copying.\n+\n+  If ``TARGET_HARD_REGNO_MODE_OK (r, mode1)`` and\n+  ``TARGET_HARD_REGNO_MODE_OK (r, mode2)`` are always\n+  the same for any :samp:`{r}`, then\n+  ``TARGET_MODES_TIEABLE_P (mode1, mode2)``\n+  should be true.  If they differ for any :samp:`{r}`, you should define\n+  this hook to return false unless some other mechanism ensures the\n+  accessibility of the value in a narrower mode.\n+\n+  You should define this hook to return true in as many cases as\n+  possible since doing so will allow GCC to perform better register\n+  allocation.  The default definition returns true unconditionally.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_HARD_REGNO_SCRATCH_OK (unsigned int regno)\n+\n+  .. hook-start:TARGET_HARD_REGNO_SCRATCH_OK\n+\n+  This target hook should return ``true`` if it is OK to use a hard register\n+  :samp:`{regno}` as scratch reg in peephole2.\n \n+  One common use of this macro is to prevent using of a register that\n+  is not saved by a prologue in an interrupt handler.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_HARD_REGNO_SCRATCH_OK]\n-  :end-before: [TARGET_HARD_REGNO_SCRATCH_OK]\n+  The default version of this hook always returns ``true``.\n \n+.. hook-end\n \n .. c:macro:: AVOID_CCMODE_COPIES\n "}, {"sha": "b2f4015df8bea39e2e8ce1503a998d65f2d90523", "filename": "gcc/doc/gccint/target-macros/run-time-target-specification.rst", "status": "modified", "additions": 112, "deletions": 39, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Frun-time-target-specification.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Frun-time-target-specification.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Frun-time-target-specification.rst?ref=3e070cff11f81051e70b613816075b66a6de61c2", "patch": "@@ -67,20 +67,22 @@ Here are run-time target specifications.\n Variable extern int target_flagsThis variable is declared in :samp:`options.h`, which is included before\n any target-specific headers.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_DEFAULT_TARGET_FLAGS]\n-  :end-before: [TARGET_DEFAULT_TARGET_FLAGS]\n+.. c:var:: int TARGET_DEFAULT_TARGET_FLAGS\n \n+  .. hook-start:TARGET_DEFAULT_TARGET_FLAGS\n+\n+  .. hook-end\n \n   This variable specifies the initial value of ``target_flags``.\n   Its default setting is 0.\n \n .. index:: optional hardware or system features, features, optional, in system conventions\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_HANDLE_OPTION]\n-  :end-before: [TARGET_HANDLE_OPTION]\n+.. function:: bool TARGET_HANDLE_OPTION (struct gcc_options *opts, struct gcc_options *opts_set, const struct cl_decoded_option *decoded, location_t loc)\n+\n+  .. hook-start:TARGET_HANDLE_OPTION\n \n+  .. hook-end\n \n   This hook is called whenever the user specifies one of the\n   target-specific options described by the :samp:`.opt` definition files\n@@ -94,10 +96,11 @@ any target-specific headers.\n   option was passed (``UNKNOWN_LOCATION`` except for options passed\n   via attributes).\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_HANDLE_C_OPTION]\n-  :end-before: [TARGET_HANDLE_C_OPTION]\n+.. function:: bool TARGET_HANDLE_C_OPTION (size_t code, const char *arg, int value)\n+\n+  .. hook-start:TARGET_HANDLE_C_OPTION\n \n+  .. hook-end\n \n   This target hook is called whenever the user specifies one of the\n   target-specific C language family options described by the :samp:`.opt`\n@@ -111,35 +114,76 @@ any target-specific headers.\n   only available in the C (and related language) front ends, then you\n   should use ``TARGET_HANDLE_C_OPTION`` instead.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_OBJC_CONSTRUCT_STRING_OBJECT]\n-  :end-before: [TARGET_OBJC_CONSTRUCT_STRING_OBJECT]\n+.. function:: tree TARGET_OBJC_CONSTRUCT_STRING_OBJECT (tree string)\n+\n+  .. hook-start:TARGET_OBJC_CONSTRUCT_STRING_OBJECT\n+\n+  Targets may provide a string object type that can be used within\n+  and between C, C++ and their respective Objective-C dialects.\n+  A string object might, for example, embed encoding and length information.\n+  These objects are considered opaque to the compiler and handled as references.\n+  An ideal implementation makes the composition of the string object\n+  match that of the Objective-C ``NSString`` (``NXString`` for GNUStep),\n+  allowing efficient interworking between C-only and Objective-C code.\n+  If a target implements string objects then this hook should return a\n+  reference to such an object constructed from the normal 'C' string\n+  representation provided in :samp:`{string}`.\n+  At present, the hook is used by Objective-C only, to obtain a\n+  common-format string object when the target provides one.\n+\n+.. hook-end\n+\n+.. function:: void TARGET_OBJC_DECLARE_UNRESOLVED_CLASS_REFERENCE (const char *classname)\n+\n+  .. hook-start:TARGET_OBJC_DECLARE_UNRESOLVED_CLASS_REFERENCE\n+\n+  Declare that Objective C class :samp:`{classname}` is referenced\n+  by the current TU.\n+\n+.. hook-end\n+\n+.. function:: void TARGET_OBJC_DECLARE_CLASS_DEFINITION (const char *classname)\n+\n+  .. hook-start:TARGET_OBJC_DECLARE_CLASS_DEFINITION\n \n+  Declare that Objective C class :samp:`{classname}` is defined\n+  by the current TU.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_OBJC_DECLARE_UNRESOLVED_CLASS_REFERENCE]\n-  :end-before: [TARGET_OBJC_DECLARE_UNRESOLVED_CLASS_REFERENCE]\n+.. hook-end\n \n+.. function:: bool TARGET_STRING_OBJECT_REF_TYPE_P (const_tree stringref)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_OBJC_DECLARE_CLASS_DEFINITION]\n-  :end-before: [TARGET_OBJC_DECLARE_CLASS_DEFINITION]\n+  .. hook-start:TARGET_STRING_OBJECT_REF_TYPE_P\n \n+  If a target implements string objects then this hook should return\n+  ``true`` if :samp:`{stringref}` is a valid reference to such an object.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_STRING_OBJECT_REF_TYPE_P]\n-  :end-before: [TARGET_STRING_OBJECT_REF_TYPE_P]\n+.. hook-end\n \n+.. function:: void TARGET_CHECK_STRING_OBJECT_FORMAT_ARG (tree format_arg, tree args_list)\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_CHECK_STRING_OBJECT_FORMAT_ARG]\n-  :end-before: [TARGET_CHECK_STRING_OBJECT_FORMAT_ARG]\n+  .. hook-start:TARGET_CHECK_STRING_OBJECT_FORMAT_ARG\n \n+  If a target implements string objects then this hook should\n+  provide a facility to check the function arguments in :samp:`{args_list}`\n+  against the format specifiers in :samp:`{format_arg}` where the type of\n+  :samp:`{format_arg}` is one recognized as a valid string reference type.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_OVERRIDE_OPTIONS_AFTER_CHANGE]\n-  :end-before: [TARGET_OVERRIDE_OPTIONS_AFTER_CHANGE]\n+.. hook-end\n \n+.. function:: void TARGET_OVERRIDE_OPTIONS_AFTER_CHANGE (void)\n+\n+  .. hook-start:TARGET_OVERRIDE_OPTIONS_AFTER_CHANGE\n+\n+  This target function is similar to the hook ``TARGET_OPTION_OVERRIDE``\n+  but is called when the optimize level is changed via an attribute or\n+  pragma or when it is reset at the end of the code affected by the\n+  attribute or pragma.  It is not called at the beginning of compilation\n+  when ``TARGET_OPTION_OVERRIDE`` is called so if you want to perform these\n+  actions then, you should have ``TARGET_OPTION_OVERRIDE`` call\n+  ``TARGET_OVERRIDE_OPTIONS_AFTER_CHANGE``.\n+\n+.. hook-end\n \n .. c:macro:: C_COMMON_OVERRIDE_OPTIONS\n \n@@ -149,10 +193,11 @@ any target-specific headers.\n   used to alter option flag variables which only exist in those\n   frontends.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_OPTION_OPTIMIZATION_TABLE]\n-  :end-before: [TARGET_OPTION_OPTIMIZATION_TABLE]\n+.. c:var:: const struct default_options * TARGET_OPTION_OPTIMIZATION_TABLE\n \n+  .. hook-start:TARGET_OPTION_OPTIMIZATION_TABLE\n+\n+  .. hook-end\n \n   Some machines may desire to change what optimizations are performed for\n   various optimization levels.   This variable, if defined, describes\n@@ -166,15 +211,33 @@ any target-specific headers.\n   options are changed via ``#pragma GCC optimize`` or by using the\n   ``optimize`` attribute.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_OPTION_INIT_STRUCT]\n-  :end-before: [TARGET_OPTION_INIT_STRUCT]\n+.. function:: void TARGET_OPTION_INIT_STRUCT (struct gcc_options *opts)\n+\n+  .. hook-start:TARGET_OPTION_INIT_STRUCT\n+\n+  Set target-dependent initial values of fields in :samp:`{opts}`.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_COMPUTE_MULTILIB]\n-  :end-before: [TARGET_COMPUTE_MULTILIB]\n+.. function:: const char * TARGET_COMPUTE_MULTILIB (const struct switchstr *switches, int n_switches, const char *multilib_dir, const char *multilib_defaults, const char *multilib_select, const char *multilib_matches, const char *multilib_exclusions, const char *multilib_reuse)\n \n+  .. hook-start:TARGET_COMPUTE_MULTILIB\n+\n+  Some targets like RISC-V might have complicated multilib reuse rules which\n+  are hard to implement with the current multilib scheme.  This hook allows\n+  targets to override the result from the built-in multilib mechanism.\n+  :samp:`{switches}` is the raw option list with :samp:`{n_switches}` items;\n+  :samp:`{multilib_dir}` is the multi-lib result which is computed by the built-in\n+  multi-lib mechanism;\n+  :samp:`{multilib_defaults}` is the default options list for multi-lib;\n+  :samp:`{multilib_select}` is the string containing the list of supported\n+  multi-libs, and the option checking list.\n+  :samp:`{multilib_matches}`, :samp:`{multilib_exclusions}`, and :samp:`{multilib_reuse}`\n+  are corresponding to :samp:`{MULTILIB_MATCHES}`, :samp:`{MULTILIB_EXCLUSIONS}`,\n+  and :samp:`{MULTILIB_REUSE}`.\n+  The default definition does nothing but return :samp:`{multilib_dir}` directly.\n+\n+.. hook-end\n \n .. c:macro:: SWITCHABLE_TARGET\n \n@@ -195,6 +258,16 @@ any target-specific headers.\n   Define this macro to 1 if your target needs this facility.  The default\n   is 0.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_FLOAT_EXCEPTIONS_ROUNDING_SUPPORTED_P]\n-  :end-before: [TARGET_FLOAT_EXCEPTIONS_ROUNDING_SUPPORTED_P]\n+.. function:: bool TARGET_FLOAT_EXCEPTIONS_ROUNDING_SUPPORTED_P (void)\n+\n+  .. hook-start:TARGET_FLOAT_EXCEPTIONS_ROUNDING_SUPPORTED_P\n+\n+  Returns true if the target supports IEEE 754 floating-point exceptions\n+  and rounding modes, false otherwise.  This is intended to relate to the\n+  ``float`` and ``double`` types, but not necessarily ``long double``.\n+  By default, returns true if the ``adddf3`` instruction pattern is\n+  available and false otherwise, on the assumption that hardware floating\n+  point supports exceptions and rounding modes but software floating point\n+  does not.\n+\n+.. hook-end"}, {"sha": "4b5bb18be8ff7b6c62dd3e9ad059ee56177ef45d", "filename": "gcc/doc/gccint/target-macros/stack-layout-and-calling-conventions/basic-stack-layout.rst", "status": "modified", "additions": 58, "deletions": 12, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fstack-layout-and-calling-conventions%2Fbasic-stack-layout.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fstack-layout-and-calling-conventions%2Fbasic-stack-layout.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fstack-layout-and-calling-conventions%2Fbasic-stack-layout.rst?ref=3e070cff11f81051e70b613816075b66a6de61c2", "patch": "@@ -45,10 +45,17 @@ Here is the basic stack layout.\n   Define this macro if successive arguments to a function occupy decreasing\n   addresses on the stack.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_STARTING_FRAME_OFFSET]\n-  :end-before: [TARGET_STARTING_FRAME_OFFSET]\n+.. function:: HOST_WIDE_INT TARGET_STARTING_FRAME_OFFSET (void)\n \n+  .. hook-start:TARGET_STARTING_FRAME_OFFSET\n+\n+  This hook returns the offset from the frame pointer to the first local\n+  variable slot to be allocated.  If ``FRAME_GROWS_DOWNWARD``, it is the\n+  offset to *end* of the first slot allocated, otherwise it is the\n+  offset to *beginning* of the first slot allocated.  The default\n+  implementation returns 0.\n+\n+.. hook-end\n \n .. c:macro:: STACK_ALIGNMENT_NEEDED\n \n@@ -115,10 +122,17 @@ Here is the basic stack layout.\n   before we can access arbitrary stack frames.  You will seldom need to\n   define this macro.  The default is to do nothing.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_BUILTIN_SETJMP_FRAME_VALUE]\n-  :end-before: [TARGET_BUILTIN_SETJMP_FRAME_VALUE]\n+.. function:: rtx TARGET_BUILTIN_SETJMP_FRAME_VALUE (void)\n+\n+  .. hook-start:TARGET_BUILTIN_SETJMP_FRAME_VALUE\n \n+  This target hook should return an rtx that is used to store\n+  the address of the current frame into the built in ``setjmp`` buffer.\n+  The default value, ``virtual_stack_vars_rtx``, is correct for most\n+  machines.  One reason you may need to define this target hook is if\n+  ``hard_frame_pointer_rtx`` is the appropriate value on your machine.\n+\n+.. hook-end\n \n .. c:macro:: FRAME_ADDR_RTX (frameaddr)\n \n@@ -186,15 +200,47 @@ Here is the basic stack layout.\n   and advertise when generating dwarf debug information, in absence of\n   an explicit :option:`-gdwarf-version` option on the command line.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_DWARF_HANDLE_FRAME_UNSPEC]\n-  :end-before: [TARGET_DWARF_HANDLE_FRAME_UNSPEC]\n+.. function:: void TARGET_DWARF_HANDLE_FRAME_UNSPEC (const char *label, rtx pattern, int index)\n+\n+  .. hook-start:TARGET_DWARF_HANDLE_FRAME_UNSPEC\n+\n+  This target hook allows the backend to emit frame-related insns that\n+  contain UNSPECs or UNSPEC_VOLATILEs.  The DWARF 2 call frame debugging\n+  info engine will invoke it on insns of the form\n+\n+  .. code-block:: c++\n+\n+    (set (reg) (unspec [...] UNSPEC_INDEX))\n+\n+  and\n+\n+  .. code-block:: c++\n+\n+    (set (reg) (unspec_volatile [...] UNSPECV_INDEX)).\n+\n+  to let the backend emit the call frame instructions.  :samp:`{label}` is\n+  the CFI label attached to the insn, :samp:`{pattern}` is the pattern of\n+  the insn and :samp:`{index}` is ``UNSPEC_INDEX`` or ``UNSPECV_INDEX``.\n+\n+.. hook-end\n+\n+.. function:: unsigned int TARGET_DWARF_POLY_INDETERMINATE_VALUE (unsigned int i, unsigned int *factor, int *offset)\n+\n+  .. hook-start:TARGET_DWARF_POLY_INDETERMINATE_VALUE\n+\n+  Express the value of ``poly_int`` indeterminate :samp:`{i}` as a DWARF\n+  expression, with :samp:`{i}` counting from 1.  Return the number of a DWARF\n+  register :samp:`{R}` and set :samp:`*{factor}` and :samp:`*{offset}` such\n+  that the value of the indeterminate is:\n+\n+  .. code-block:: c++\n \n+    value_of(R) / factor - offset\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_DWARF_POLY_INDETERMINATE_VALUE]\n-  :end-before: [TARGET_DWARF_POLY_INDETERMINATE_VALUE]\n+  A target only needs to define this hook if it sets\n+  :samp:`NUM_POLY_INT_COEFFS` to a value greater than 1.\n \n+.. hook-end\n \n .. c:macro:: INCOMING_FRAME_SP_OFFSET\n "}, {"sha": "79118da6452eaab72c529e904564cf9f6fa479bc", "filename": "gcc/doc/gccint/target-macros/stack-layout-and-calling-conventions/eliminating-frame-pointer-and-arg-pointer.rst", "status": "modified", "additions": 51, "deletions": 9, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fstack-layout-and-calling-conventions%2Feliminating-frame-pointer-and-arg-pointer.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fstack-layout-and-calling-conventions%2Feliminating-frame-pointer-and-arg-pointer.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fstack-layout-and-calling-conventions%2Feliminating-frame-pointer-and-arg-pointer.rst?ref=3e070cff11f81051e70b613816075b66a6de61c2", "patch": "@@ -12,10 +12,34 @@ Eliminating Frame Pointer and Arg Pointer\n \n This is about eliminating the frame pointer and arg pointer.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_FRAME_POINTER_REQUIRED]\n-  :end-before: [TARGET_FRAME_POINTER_REQUIRED]\n+.. function:: bool TARGET_FRAME_POINTER_REQUIRED (void)\n \n+  .. hook-start:TARGET_FRAME_POINTER_REQUIRED\n+\n+  This target hook should return ``true`` if a function must have and use\n+  a frame pointer.  This target hook is called in the reload pass.  If its return\n+  value is ``true`` the function will have a frame pointer.\n+\n+  This target hook can in principle examine the current function and decide\n+  according to the facts, but on most machines the constant ``false`` or the\n+  constant ``true`` suffices.  Use ``false`` when the machine allows code\n+  to be generated with no frame pointer, and doing so saves some time or space.\n+  Use ``true`` when there is no possible advantage to avoiding a frame\n+  pointer.\n+\n+  In certain cases, the compiler does not know how to produce valid code\n+  without a frame pointer.  The compiler recognizes those cases and\n+  automatically gives the function a frame pointer regardless of what\n+  ``targetm.frame_pointer_required`` returns.  You don't need to worry about\n+  them.\n+\n+  In a function that does not require a frame pointer, the frame pointer\n+  register can be allocated for ordinary usage, unless you mark it as a\n+  fixed register.  See ``FIXED_REGISTERS`` for more information.\n+\n+  Default return value is ``false``.\n+\n+.. hook-end\n \n .. c:macro:: ELIMINABLE_REGS\n \n@@ -43,10 +67,19 @@ This is about eliminating the frame pointer and arg pointer.\n   Note that the elimination of the argument pointer with the stack pointer is\n   specified first since that is the preferred elimination.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_CAN_ELIMINATE]\n-  :end-before: [TARGET_CAN_ELIMINATE]\n+.. function:: bool TARGET_CAN_ELIMINATE (const int from_reg, const int to_reg)\n \n+  .. hook-start:TARGET_CAN_ELIMINATE\n+\n+  This target hook should return ``true`` if the compiler is allowed to\n+  try to replace register number :samp:`{from_reg}` with register number\n+  :samp:`{to_reg}`.  This target hook will usually be ``true``, since most of the\n+  cases preventing register elimination are things that the compiler already\n+  knows about.\n+\n+  Default return value is ``true``.\n+\n+.. hook-end\n \n .. c:macro:: INITIAL_ELIMINATION_OFFSET (from_reg, to_reg, offset_var)\n \n@@ -55,6 +88,15 @@ This is about eliminating the frame pointer and arg pointer.\n   such as the result of ``get_frame_size ()`` and the tables of\n   registers ``df_regs_ever_live_p`` and ``call_used_regs``.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_COMPUTE_FRAME_LAYOUT]\n-  :end-before: [TARGET_COMPUTE_FRAME_LAYOUT]\n+.. function:: void TARGET_COMPUTE_FRAME_LAYOUT (void)\n+\n+  .. hook-start:TARGET_COMPUTE_FRAME_LAYOUT\n+\n+  This target hook is called once each time the frame layout needs to be\n+  recalculated.  The calculations can be cached by the target and can then\n+  be used by ``INITIAL_ELIMINATION_OFFSET`` instead of re-computing the\n+  layout on every invocation of that hook.  This is particularly useful\n+  for targets that have an expensive frame layout function.  Implementing\n+  this callback is optional.\n+\n+.. hook-end\n\\ No newline at end of file"}, {"sha": "d1055c81d099a2f6f78789a418dc06ec1c662ea8", "filename": "gcc/doc/gccint/target-macros/stack-layout-and-calling-conventions/function-entry-and-exit.rst", "status": "modified", "additions": 182, "deletions": 21, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fstack-layout-and-calling-conventions%2Ffunction-entry-and-exit.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fstack-layout-and-calling-conventions%2Ffunction-entry-and-exit.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fstack-layout-and-calling-conventions%2Ffunction-entry-and-exit.rst?ref=3e070cff11f81051e70b613816075b66a6de61c2", "patch": "@@ -13,30 +13,142 @@ Function Entry and Exit\n This section describes the macros that output function entry\n (:dfn:`prologue`) and exit (:dfn:`epilogue`) code.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_ASM_PRINT_PATCHABLE_FUNCTION_ENTRY]\n-  :end-before: [TARGET_ASM_PRINT_PATCHABLE_FUNCTION_ENTRY]\n+.. function:: void TARGET_ASM_PRINT_PATCHABLE_FUNCTION_ENTRY (FILE *file, unsigned HOST_WIDE_INT patch_area_size, bool record_p)\n \n+  .. hook-start:TARGET_ASM_PRINT_PATCHABLE_FUNCTION_ENTRY\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_ASM_FUNCTION_PROLOGUE]\n-  :end-before: [TARGET_ASM_FUNCTION_PROLOGUE]\n+  Generate a patchable area at the function start, consisting of\n+  :samp:`{patch_area_size}` NOP instructions.  If the target supports named\n+  sections and if :samp:`{record_p}` is true, insert a pointer to the current\n+  location in the table of patchable functions.  The default implementation\n+  of the hook places the table of pointers in the special section named\n+  ``__patchable_function_entries``.\n \n+.. hook-end\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_ASM_FUNCTION_END_PROLOGUE]\n-  :end-before: [TARGET_ASM_FUNCTION_END_PROLOGUE]\n+.. function:: void TARGET_ASM_FUNCTION_PROLOGUE (FILE *file)\n \n+  .. hook-start:TARGET_ASM_FUNCTION_PROLOGUE\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_ASM_FUNCTION_BEGIN_EPILOGUE]\n-  :end-before: [TARGET_ASM_FUNCTION_BEGIN_EPILOGUE]\n+  If defined, a function that outputs the assembler code for entry to a\n+  function.  The prologue is responsible for setting up the stack frame,\n+  initializing the frame pointer register, saving registers that must be\n+  saved, and allocating :samp:`{size}` additional bytes of storage for the\n+  local variables.  :samp:`{file}` is a stdio stream to which the assembler\n+  code should be output.\n \n+  The label for the beginning of the function need not be output by this\n+  macro.  That has already been done when the macro is run.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_ASM_FUNCTION_EPILOGUE]\n-  :end-before: [TARGET_ASM_FUNCTION_EPILOGUE]\n+  .. index:: regs_ever_live\n \n+  To determine which registers to save, the macro can refer to the array\n+  ``regs_ever_live`` : element :samp:`{r}` is nonzero if hard register\n+  :samp:`{r}` is used anywhere within the function.  This implies the function\n+  prologue should save register :samp:`{r}`, provided it is not one of the\n+  call-used registers.  (``TARGET_ASM_FUNCTION_EPILOGUE`` must likewise use\n+  ``regs_ever_live``.)\n+\n+  On machines that have 'register windows', the function entry code does\n+  not save on the stack the registers that are in the windows, even if\n+  they are supposed to be preserved by function calls; instead it takes\n+  appropriate steps to 'push' the register stack, if any non-call-used\n+  registers are used in the function.\n+\n+  .. index:: frame_pointer_needed\n+\n+  On machines where functions may or may not have frame-pointers, the\n+  function entry code must vary accordingly; it must set up the frame\n+  pointer if one is wanted, and not otherwise.  To determine whether a\n+  frame pointer is in wanted, the macro can refer to the variable\n+  ``frame_pointer_needed``.  The variable's value will be 1 at run\n+  time in a function that needs a frame pointer.  See :ref:`elimination`.\n+\n+  The function entry code is responsible for allocating any stack space\n+  required for the function.  This stack space consists of the regions\n+  listed below.  In most cases, these regions are allocated in the\n+  order listed, with the last listed region closest to the top of the\n+  stack (the lowest address if ``STACK_GROWS_DOWNWARD`` is defined, and\n+  the highest address if it is not defined).  You can use a different order\n+  for a machine if doing so is more convenient or required for\n+  compatibility reasons.  Except in cases where required by standard\n+  or by a debugger, there is no reason why the stack layout used by GCC\n+  need agree with that used by other compilers for a machine.\n+\n+.. hook-end\n+\n+.. function:: void TARGET_ASM_FUNCTION_END_PROLOGUE (FILE *file)\n+\n+  .. hook-start:TARGET_ASM_FUNCTION_END_PROLOGUE\n+\n+  If defined, a function that outputs assembler code at the end of a\n+  prologue.  This should be used when the function prologue is being\n+  emitted as RTL, and you have some extra assembler that needs to be\n+  emitted.  See :ref:`prologue-instruction-pattern`.\n+\n+.. hook-end\n+\n+.. function:: void TARGET_ASM_FUNCTION_BEGIN_EPILOGUE (FILE *file)\n+\n+  .. hook-start:TARGET_ASM_FUNCTION_BEGIN_EPILOGUE\n+\n+  If defined, a function that outputs assembler code at the start of an\n+  epilogue.  This should be used when the function epilogue is being\n+  emitted as RTL, and you have some extra assembler that needs to be\n+  emitted.  See :ref:`epilogue-instruction-pattern`.\n+\n+.. hook-end\n+\n+.. function:: void TARGET_ASM_FUNCTION_EPILOGUE (FILE *file)\n+\n+  .. hook-start:TARGET_ASM_FUNCTION_EPILOGUE\n+\n+  If defined, a function that outputs the assembler code for exit from a\n+  function.  The epilogue is responsible for restoring the saved\n+  registers and stack pointer to their values when the function was\n+  called, and returning control to the caller.  This macro takes the\n+  same argument as the macro ``TARGET_ASM_FUNCTION_PROLOGUE``, and the\n+  registers to restore are determined from ``regs_ever_live`` and\n+  ``CALL_USED_REGISTERS`` in the same way.\n+\n+  On some machines, there is a single instruction that does all the work\n+  of returning from the function.  On these machines, give that\n+  instruction the name :samp:`return` and do not define the macro\n+  ``TARGET_ASM_FUNCTION_EPILOGUE`` at all.\n+\n+  Do not define a pattern named :samp:`return` if you want the\n+  ``TARGET_ASM_FUNCTION_EPILOGUE`` to be used.  If you want the target\n+  switches to control whether return instructions or epilogues are used,\n+  define a :samp:`return` pattern with a validity condition that tests the\n+  target switches appropriately.  If the :samp:`return` pattern's validity\n+  condition is false, epilogues will be used.\n+\n+  On machines where functions may or may not have frame-pointers, the\n+  function exit code must vary accordingly.  Sometimes the code for these\n+  two cases is completely different.  To determine whether a frame pointer\n+  is wanted, the macro can refer to the variable\n+  ``frame_pointer_needed``.  The variable's value will be 1 when compiling\n+  a function that needs a frame pointer.\n+\n+  Normally, ``TARGET_ASM_FUNCTION_PROLOGUE`` and\n+  ``TARGET_ASM_FUNCTION_EPILOGUE`` must treat leaf functions specially.\n+  The C variable ``current_function_is_leaf`` is nonzero for such a\n+  function.  See :ref:`leaf-functions`.\n+\n+  On some machines, some functions pop their arguments on exit while\n+  others leave that for the caller to do.  For example, the 68020 when\n+  given :option:`-mrtd` pops arguments in functions that take a fixed\n+  number of arguments.\n+\n+  .. index:: pops_args, crtl->args.pops_args\n+\n+  Your definition of the macro ``RETURN_POPS_ARGS`` decides which\n+  functions pop their own arguments.  ``TARGET_ASM_FUNCTION_EPILOGUE``\n+  needs to know what was decided.  The number of bytes of the current\n+  function's arguments that this function should pop is available in\n+  ``crtl->args.pops_args``.  See :ref:`scalar-return`.\n+\n+.. hook-end\n \n *\n   .. index:: pretend_args_size, crtl->args.pretend_args_size\n@@ -94,11 +206,60 @@ This section describes the macros that output function entry\n   used by the exception handling mechanism, and so should be considered live\n   on entry to an exception edge.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_ASM_OUTPUT_MI_THUNK]\n-  :end-before: [TARGET_ASM_OUTPUT_MI_THUNK]\n+.. function:: void TARGET_ASM_OUTPUT_MI_THUNK (FILE *file, tree thunk_fndecl, HOST_WIDE_INT delta, HOST_WIDE_INT vcall_offset, tree function)\n+\n+  .. hook-start:TARGET_ASM_OUTPUT_MI_THUNK\n+\n+  A function that outputs the assembler code for a thunk\n+  function, used to implement C++ virtual function calls with multiple\n+  inheritance.  The thunk acts as a wrapper around a virtual function,\n+  adjusting the implicit object parameter before handing control off to\n+  the real function.\n+\n+  First, emit code to add the integer :samp:`{delta}` to the location that\n+  contains the incoming first argument.  Assume that this argument\n+  contains a pointer, and is the one used to pass the ``this`` pointer\n+  in C++.  This is the incoming argument *before* the function prologue,\n+  e.g. :samp:`%o0` on a sparc.  The addition must preserve the values of\n+  all other incoming arguments.\n+\n+  Then, if :samp:`{vcall_offset}` is nonzero, an additional adjustment should be\n+  made after adding ``delta``.  In particular, if :samp:`{p}` is the\n+  adjusted pointer, the following adjustment should be made:\n+\n+  .. code-block:: c++\n+\n+    p += (*((ptrdiff_t **)p))[vcall_offset/sizeof(ptrdiff_t)]\n+\n+  After the additions, emit code to jump to :samp:`{function}`, which is a\n+  ``FUNCTION_DECL``.  This is a direct pure jump, not a call, and does\n+  not touch the return address.  Hence returning from :samp:`{FUNCTION}` will\n+  return to whoever called the current :samp:`thunk`.\n+\n+  The effect must be as if :samp:`{function}` had been called directly with\n+  the adjusted first argument.  This macro is responsible for emitting all\n+  of the code for a thunk function; ``TARGET_ASM_FUNCTION_PROLOGUE``\n+  and ``TARGET_ASM_FUNCTION_EPILOGUE`` are not invoked.\n+\n+  The :samp:`{thunk_fndecl}` is redundant.  (:samp:`{delta}` and :samp:`{function}`\n+  have already been extracted from it.)  It might possibly be useful on\n+  some targets, but probably not.\n+\n+  If you do not define this macro, the target-independent code in the C++\n+  front end will generate a less efficient heavyweight thunk that calls\n+  :samp:`{function}` instead of jumping to it.  The generic approach does\n+  not support varargs.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_ASM_CAN_OUTPUT_MI_THUNK (const_tree thunk_fndecl, HOST_WIDE_INT delta, HOST_WIDE_INT vcall_offset, const_tree function)\n+\n+  .. hook-start:TARGET_ASM_CAN_OUTPUT_MI_THUNK\n \n+  A function that returns true if TARGET_ASM_OUTPUT_MI_THUNK would be able\n+  to output the assembler code for the thunk function specified by the\n+  arguments it is passed, and false otherwise.  In the latter case, the\n+  generic approach will be used by the C++ front end, with the limitations\n+  previously exposed.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_ASM_CAN_OUTPUT_MI_THUNK]\n-  :end-before: [TARGET_ASM_CAN_OUTPUT_MI_THUNK]\n+.. hook-end\n\\ No newline at end of file"}, {"sha": "c68796aa8822aa46ef5bef75b3cb83ce3d1ba93b", "filename": "gcc/doc/gccint/target-macros/stack-layout-and-calling-conventions/generating-code-for-profiling.rst", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fstack-layout-and-calling-conventions%2Fgenerating-code-for-profiling.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fstack-layout-and-calling-conventions%2Fgenerating-code-for-profiling.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fstack-layout-and-calling-conventions%2Fgenerating-code-for-profiling.rst?ref=3e070cff11f81051e70b613816075b66a6de61c2", "patch": "@@ -48,6 +48,14 @@ These macros will help you generate code for profiling.\n   Define this macro if the code for function profiling should come before\n   the function prologue.  Normally, the profiling code comes after.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_KEEP_LEAF_WHEN_PROFILED]\n-  :end-before: [TARGET_KEEP_LEAF_WHEN_PROFILED]\n+.. function:: bool TARGET_KEEP_LEAF_WHEN_PROFILED (void)\n+\n+  .. hook-start:TARGET_KEEP_LEAF_WHEN_PROFILED\n+\n+  This target hook returns true if the target wants the leaf flag for\n+  the current function to stay true even if it calls mcount.  This might\n+  make sense for targets using the leaf flag only to determine whether a\n+  stack frame needs to be generated or not and for which the call to\n+  mcount is generated before the function prologue.\n+\n+.. hook-end\n\\ No newline at end of file"}, {"sha": "ebd8af4a7ffedee3785a43d332f72b960b31f78c", "filename": "gcc/doc/gccint/target-macros/stack-layout-and-calling-conventions/how-large-values-are-returned.rst", "status": "modified", "additions": 77, "deletions": 18, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fstack-layout-and-calling-conventions%2Fhow-large-values-are-returned.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fstack-layout-and-calling-conventions%2Fhow-large-values-are-returned.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fstack-layout-and-calling-conventions%2Fhow-large-values-are-returned.rst?ref=3e070cff11f81051e70b613816075b66a6de61c2", "patch": "@@ -20,10 +20,28 @@ address`.\n This section describes how to control returning structure values in\n memory.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_RETURN_IN_MEMORY]\n-  :end-before: [TARGET_RETURN_IN_MEMORY]\n+.. function:: bool TARGET_RETURN_IN_MEMORY (const_tree type, const_tree fntype)\n \n+  .. hook-start:TARGET_RETURN_IN_MEMORY\n+\n+  This target hook should return a nonzero value to say to return the\n+  function value in memory, just as large structures are always returned.\n+  Here :samp:`{type}` will be the data type of the value, and :samp:`{fntype}`\n+  will be the type of the function doing the returning, or ``NULL`` for\n+  libcalls.\n+\n+  Note that values of mode ``BLKmode`` must be explicitly handled\n+  by this function.  Also, the option :option:`-fpcc-struct-return`\n+  takes effect regardless of this macro.  On most systems, it is\n+  possible to leave the hook undefined; this causes a default\n+  definition to be used, whose value is the constant 1 for ``BLKmode``\n+  values, and 0 otherwise.\n+\n+  Do not use this hook to indicate that structures and unions should always\n+  be returned in memory.  You should instead use ``DEFAULT_PCC_STRUCT_RETURN``\n+  to indicate this.\n+\n+.. hook-end\n \n .. c:macro:: DEFAULT_PCC_STRUCT_RETURN\n \n@@ -36,10 +54,32 @@ memory.\n \n   If not defined, this defaults to the value 1.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_STRUCT_VALUE_RTX]\n-  :end-before: [TARGET_STRUCT_VALUE_RTX]\n+.. function:: rtx TARGET_STRUCT_VALUE_RTX (tree fndecl, int incoming)\n+\n+  .. hook-start:TARGET_STRUCT_VALUE_RTX\n \n+  This target hook should return the location of the structure value\n+  address (normally a ``mem`` or ``reg``), or 0 if the address is\n+  passed as an 'invisible' first argument.  Note that :samp:`{fndecl}` may\n+  be ``NULL``, for libcalls.  You do not need to define this target\n+  hook if the address is always passed as an 'invisible' first\n+  argument.\n+\n+  On some architectures the place where the structure value address\n+  is found by the called function is not the same place that the\n+  caller put it.  This can be due to register windows, or it could\n+  be because the function prologue moves it to a different place.\n+  :samp:`{incoming}` is ``1`` or ``2`` when the location is needed in\n+  the context of the called function, and ``0`` in the context of\n+  the caller.\n+\n+  If :samp:`{incoming}` is nonzero and the address is to be found on the\n+  stack, return a ``mem`` which refers to the frame pointer. If\n+  :samp:`{incoming}` is ``2``, the result is being used to fetch the\n+  structure value address at the beginning of a function.  If you need\n+  to emit adjusting code, you should do it at this point.\n+\n+.. hook-end\n \n .. c:macro:: PCC_STATIC_STRUCT_RETURN\n \n@@ -53,21 +93,40 @@ memory.\n   This macro has effect in :option:`-fpcc-struct-return` mode, but it does\n   nothing when you use :option:`-freg-struct-return` mode.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_GET_RAW_RESULT_MODE]\n-  :end-before: [TARGET_GET_RAW_RESULT_MODE]\n+.. function:: fixed_size_mode TARGET_GET_RAW_RESULT_MODE (int regno)\n+\n+  .. hook-start:TARGET_GET_RAW_RESULT_MODE\n+\n+  This target hook returns the mode to be used when accessing raw return\n+  registers in ``__builtin_return``.  Define this macro if the value\n+  in :samp:`{reg_raw_mode}` is not correct.\n+\n+.. hook-end\n+\n+.. function:: fixed_size_mode TARGET_GET_RAW_ARG_MODE (int regno)\n+\n+  .. hook-start:TARGET_GET_RAW_ARG_MODE\n+\n+  This target hook returns the mode to be used when accessing raw argument\n+  registers in ``__builtin_apply_args``.  Define this macro if the value\n+  in :samp:`{reg_raw_mode}` is not correct.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_EMPTY_RECORD_P (const_tree type)\n+\n+  .. hook-start:TARGET_EMPTY_RECORD_P\n \n+  This target hook returns true if the type is an empty record.  The default\n+  is to return ``false``.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_GET_RAW_ARG_MODE]\n-  :end-before: [TARGET_GET_RAW_ARG_MODE]\n+.. hook-end\n \n+.. function:: void TARGET_WARN_PARAMETER_PASSING_ABI (cumulative_args_t ca, tree type)\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_EMPTY_RECORD_P]\n-  :end-before: [TARGET_EMPTY_RECORD_P]\n+  .. hook-start:TARGET_WARN_PARAMETER_PASSING_ABI\n \n+  This target hook warns about the change in empty class parameter passing\n+  ABI.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_WARN_PARAMETER_PASSING_ABI]\n-  :end-before: [TARGET_WARN_PARAMETER_PASSING_ABI]\n+.. hook-end\n\\ No newline at end of file"}, {"sha": "ea11268807da1f6982919b83f89f696bda65e820", "filename": "gcc/doc/gccint/target-macros/stack-layout-and-calling-conventions/how-scalar-function-values-are-returned.rst", "status": "modified", "additions": 102, "deletions": 16, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fstack-layout-and-calling-conventions%2Fhow-scalar-function-values-are-returned.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fstack-layout-and-calling-conventions%2Fhow-scalar-function-values-are-returned.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fstack-layout-and-calling-conventions%2Fhow-scalar-function-values-are-returned.rst?ref=3e070cff11f81051e70b613816075b66a6de61c2", "patch": "@@ -13,10 +13,52 @@ How Scalar Function Values Are Returned\n This section discusses the macros that control returning scalars as\n values---values that can fit in registers.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_FUNCTION_VALUE]\n-  :end-before: [TARGET_FUNCTION_VALUE]\n-\n+.. function:: rtx TARGET_FUNCTION_VALUE (const_tree ret_type, const_tree fn_decl_or_type, bool outgoing)\n+\n+  .. hook-start:TARGET_FUNCTION_VALUE\n+\n+  Define this to return an RTX representing the place where a function\n+  returns or receives a value of data type :samp:`{ret_type}`, a tree node\n+  representing a data type.  :samp:`{fn_decl_or_type}` is a tree node\n+  representing ``FUNCTION_DECL`` or ``FUNCTION_TYPE`` of a\n+  function being called.  If :samp:`{outgoing}` is false, the hook should\n+  compute the register in which the caller will see the return value.\n+  Otherwise, the hook should return an RTX representing the place where\n+  a function returns a value.\n+\n+  On many machines, only ``TYPE_MODE (ret_type)`` is relevant.\n+  (Actually, on most machines, scalar values are returned in the same\n+  place regardless of mode.)  The value of the expression is usually a\n+  ``reg`` RTX for the hard register where the return value is stored.\n+  The value can also be a ``parallel`` RTX, if the return value is in\n+  multiple places.  See ``TARGET_FUNCTION_ARG`` for an explanation of the\n+  ``parallel`` form.   Note that the callee will populate every\n+  location specified in the ``parallel``, but if the first element of\n+  the ``parallel`` contains the whole return value, callers will use\n+  that element as the canonical location and ignore the others.  The m68k\n+  port uses this type of ``parallel`` to return pointers in both\n+  :samp:`%a0` (the canonical location) and :samp:`%d0`.\n+\n+  If ``TARGET_PROMOTE_FUNCTION_RETURN`` returns true, you must apply\n+  the same promotion rules specified in ``PROMOTE_MODE`` if\n+  :samp:`{valtype}` is a scalar type.\n+\n+  If the precise function being called is known, :samp:`{func}` is a tree\n+  node (``FUNCTION_DECL``) for it; otherwise, :samp:`{func}` is a null\n+  pointer.  This makes it possible to use a different value-returning\n+  convention for specific functions when all their calls are\n+  known.\n+\n+  Some target machines have 'register windows' so that the register in\n+  which a function returns its value is not the same as the one in which\n+  the caller sees the value.  For such machines, you should return\n+  different RTX depending on :samp:`{outgoing}`.\n+\n+  ``TARGET_FUNCTION_VALUE`` is not used for return values with\n+  aggregate data types, because these are returned in another way.  See\n+  ``TARGET_STRUCT_VALUE_RTX`` and related macros, below.\n+\n+.. hook-end\n \n .. c:macro:: FUNCTION_VALUE (valtype, func)\n \n@@ -33,10 +75,20 @@ values---values that can fit in registers.\n   specially by the compiler and was not mentioned in the C code being\n   compiled.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_LIBCALL_VALUE]\n-  :end-before: [TARGET_LIBCALL_VALUE]\n+.. function:: rtx TARGET_LIBCALL_VALUE (machine_mode mode, const_rtx fun)\n+\n+  .. hook-start:TARGET_LIBCALL_VALUE\n+\n+  Define this hook if the back-end needs to know the name of the libcall\n+  function in order to determine where the result should be returned.\n \n+  The mode of the result is given by :samp:`{mode}` and the name of the called\n+  library function is given by :samp:`{fun}`.  The hook should return an RTX\n+  representing the place where the library function result will be returned.\n+\n+  If this hook is not defined, then LIBCALL_VALUE will be used.\n+\n+.. hook-end\n \n .. c:macro:: FUNCTION_VALUE_REGNO_P (regno)\n \n@@ -59,22 +111,56 @@ values---values that can fit in registers.\n   This macro has been deprecated.  Use ``TARGET_FUNCTION_VALUE_REGNO_P``\n   for a new target instead.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_FUNCTION_VALUE_REGNO_P]\n-  :end-before: [TARGET_FUNCTION_VALUE_REGNO_P]\n+.. function:: bool TARGET_FUNCTION_VALUE_REGNO_P (const unsigned int regno)\n \n+  .. hook-start:TARGET_FUNCTION_VALUE_REGNO_P\n+\n+  A target hook that return ``true`` if :samp:`{regno}` is the number of a hard\n+  register in which the values of called function may come back.\n+\n+  A register whose use for returning values is limited to serving as the\n+  second of a pair (for a value of type ``double``, say) need not be\n+  recognized by this target hook.\n+\n+  If the machine has register windows, so that the caller and the called\n+  function use different registers for the return value, this target hook\n+  should recognize only the caller's register numbers.\n+\n+  If this hook is not defined, then FUNCTION_VALUE_REGNO_P will be used.\n+\n+.. hook-end\n \n .. c:macro:: APPLY_RESULT_SIZE\n \n   Define this macro if :samp:`untyped_call` and :samp:`untyped_return`\n   need more space than is implied by ``FUNCTION_VALUE_REGNO_P`` for\n   saving and restoring an arbitrary return value.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_OMIT_STRUCT_RETURN_REG]\n-  :end-before: [TARGET_OMIT_STRUCT_RETURN_REG]\n+.. c:var:: bool TARGET_OMIT_STRUCT_RETURN_REG\n+\n+  .. hook-start:TARGET_OMIT_STRUCT_RETURN_REG\n+\n+  Normally, when a function returns a structure by memory, the address\n+  is passed as an invisible pointer argument, but the compiler also\n+  arranges to return the address from the function like it would a normal\n+  pointer return value.  Define this to true if that behavior is\n+  undesirable on your target.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_RETURN_IN_MSB (const_tree type)\n+\n+  .. hook-start:TARGET_RETURN_IN_MSB\n+\n+  This hook should return true if values of type :samp:`{type}` are returned\n+  at the most significant end of a register (in other words, if they are\n+  padded at the least significant end).  You can assume that :samp:`{type}`\n+  is returned in a register; the caller is required to check this.\n \n+  Note that the register provided by ``TARGET_FUNCTION_VALUE`` must\n+  be able to hold the complete return value.  For example, if a 1-, 2-\n+  or 3-byte structure is returned at the most significant end of a\n+  4-byte register, ``TARGET_FUNCTION_VALUE`` should provide an\n+  ``SImode`` rtx.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_RETURN_IN_MSB]\n-  :end-before: [TARGET_RETURN_IN_MSB]\n+.. hook-end\n\\ No newline at end of file"}, {"sha": "907ea8228fd8a1ef351b45c088a607f130fbc144", "filename": "gcc/doc/gccint/target-macros/stack-layout-and-calling-conventions/miscellaneous-register-hooks.rst", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fstack-layout-and-calling-conventions%2Fmiscellaneous-register-hooks.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fstack-layout-and-calling-conventions%2Fmiscellaneous-register-hooks.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fstack-layout-and-calling-conventions%2Fmiscellaneous-register-hooks.rst?ref=3e070cff11f81051e70b613816075b66a6de61c2", "patch": "@@ -10,6 +10,17 @@\n Miscellaneous register hooks\n ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_CALL_FUSAGE_CONTAINS_NON_CALLEE_CLOBBERS]\n-  :end-before: [TARGET_CALL_FUSAGE_CONTAINS_NON_CALLEE_CLOBBERS]\n+.. c:var:: bool TARGET_CALL_FUSAGE_CONTAINS_NON_CALLEE_CLOBBERS\n+\n+  .. hook-start:TARGET_CALL_FUSAGE_CONTAINS_NON_CALLEE_CLOBBERS\n+\n+  Set to true if each call that binds to a local definition explicitly\n+  clobbers or sets all non-fixed registers modified by performing the call.\n+  That is, by the call pattern itself, or by code that might be inserted by the\n+  linker (e.g. stubs, veneers, branch islands), but not including those\n+  modifiable by the callee.  The affected registers may be mentioned explicitly\n+  in the call pattern, or included as clobbers in CALL_INSN_FUNCTION_USAGE.\n+  The default version of this hook is set to false.  The purpose of this hook\n+  is to enable the fipa-ra optimization.\n+\n+.. hook-end\n\\ No newline at end of file"}, {"sha": "d724d655163a9bb3af8b5da48c2b004258c6b786", "filename": "gcc/doc/gccint/target-macros/stack-layout-and-calling-conventions/passing-arguments-in-registers.rst", "status": "modified", "additions": 461, "deletions": 93, "changes": 554, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fstack-layout-and-calling-conventions%2Fpassing-arguments-in-registers.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fstack-layout-and-calling-conventions%2Fpassing-arguments-in-registers.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fstack-layout-and-calling-conventions%2Fpassing-arguments-in-registers.rst?ref=3e070cff11f81051e70b613816075b66a6de61c2", "patch": "@@ -14,45 +14,164 @@ This section describes the macros which let you control how various\n types of arguments are passed in registers or how they are arranged in\n the stack.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_FUNCTION_ARG]\n-  :end-before: [TARGET_FUNCTION_ARG]\n+.. function:: rtx TARGET_FUNCTION_ARG (cumulative_args_t ca, const function_arg_info &arg)\n \n+  .. hook-start:TARGET_FUNCTION_ARG\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_MUST_PASS_IN_STACK]\n-  :end-before: [TARGET_MUST_PASS_IN_STACK]\n+  Return an RTX indicating whether function argument :samp:`{arg}` is passed\n+  in a register and if so, which register.  Argument :samp:`{ca}` summarizes all\n+  the previous arguments.\n \n+  The return value is usually either a ``reg`` RTX for the hard\n+  register in which to pass the argument, or zero to pass the argument\n+  on the stack.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_FUNCTION_INCOMING_ARG]\n-  :end-before: [TARGET_FUNCTION_INCOMING_ARG]\n+  The value of the expression can also be a ``parallel`` RTX.  This is\n+  used when an argument is passed in multiple locations.  The mode of the\n+  ``parallel`` should be the mode of the entire argument.  The\n+  ``parallel`` holds any number of ``expr_list`` pairs; each one\n+  describes where part of the argument is passed.  In each\n+  ``expr_list`` the first operand must be a ``reg`` RTX for the hard\n+  register in which to pass this part of the argument, and the mode of the\n+  register RTX indicates how large this part of the argument is.  The\n+  second operand of the ``expr_list`` is a ``const_int`` which gives\n+  the offset in bytes into the entire argument of where this part starts.\n+  As a special exception the first ``expr_list`` in the ``parallel``\n+  RTX may have a first operand of zero.  This indicates that the entire\n+  argument is also stored on the stack.\n \n+  The last time this hook is called, it is called with ``MODE ==\n+  VOIDmode``, and its result is passed to the ``call`` or ``call_value``\n+  pattern as operands 2 and 3 respectively.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_USE_PSEUDO_PIC_REG]\n-  :end-before: [TARGET_USE_PSEUDO_PIC_REG]\n+  .. index:: stdarg.h and register arguments\n \n+  The usual way to make the ISO library :samp:`stdarg.h` work on a\n+  machine where some arguments are usually passed in registers, is to\n+  cause nameless arguments to be passed on the stack instead.  This is\n+  done by making ``TARGET_FUNCTION_ARG`` return 0 whenever\n+  :samp:`{named}` is ``false``.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_INIT_PIC_REG]\n-  :end-before: [TARGET_INIT_PIC_REG]\n+  .. index:: TARGET_MUST_PASS_IN_STACK, and TARGET_FUNCTION_ARG, REG_PARM_STACK_SPACE, and TARGET_FUNCTION_ARG\n \n+  You may use the hook ``targetm.calls.must_pass_in_stack``\n+  in the definition of this macro to determine if this argument is of a\n+  type that must be passed in the stack.  If ``REG_PARM_STACK_SPACE``\n+  is not defined and ``TARGET_FUNCTION_ARG`` returns nonzero for such an\n+  argument, the compiler will abort.  If ``REG_PARM_STACK_SPACE`` is\n+  defined, the argument will be computed in the stack and then loaded into\n+  a register.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_ARG_PARTIAL_BYTES]\n-  :end-before: [TARGET_ARG_PARTIAL_BYTES]\n+.. hook-end\n \n+.. function:: bool TARGET_MUST_PASS_IN_STACK (const function_arg_info &arg)\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_PASS_BY_REFERENCE]\n-  :end-before: [TARGET_PASS_BY_REFERENCE]\n+  .. hook-start:TARGET_MUST_PASS_IN_STACK\n \n+  This target hook should return ``true`` if we should not pass :samp:`{arg}`\n+  solely in registers.  The file :samp:`expr.h` defines a\n+  definition that is usually appropriate, refer to :samp:`expr.h` for additional\n+  documentation.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_CALLEE_COPIES]\n-  :end-before: [TARGET_CALLEE_COPIES]\n+.. hook-end\n \n+.. function:: rtx TARGET_FUNCTION_INCOMING_ARG (cumulative_args_t ca, const function_arg_info &arg)\n+\n+  .. hook-start:TARGET_FUNCTION_INCOMING_ARG\n+\n+  Define this hook if the caller and callee on the target have different\n+  views of where arguments are passed.  Also define this hook if there are\n+  functions that are never directly called, but are invoked by the hardware\n+  and which have nonstandard calling conventions.\n+\n+  In this case ``TARGET_FUNCTION_ARG`` computes the register in\n+  which the caller passes the value, and\n+  ``TARGET_FUNCTION_INCOMING_ARG`` should be defined in a similar\n+  fashion to tell the function being called where the arguments will\n+  arrive.\n+\n+  ``TARGET_FUNCTION_INCOMING_ARG`` can also return arbitrary address\n+  computation using hard register, which can be forced into a register,\n+  so that it can be used to pass special arguments.\n+\n+  If ``TARGET_FUNCTION_INCOMING_ARG`` is not defined,\n+  ``TARGET_FUNCTION_ARG`` serves both purposes.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_USE_PSEUDO_PIC_REG (void)\n+\n+  .. hook-start:TARGET_USE_PSEUDO_PIC_REG\n+\n+  This hook should return 1 in case pseudo register should be created\n+  for pic_offset_table_rtx during function expand.\n+\n+.. hook-end\n+\n+.. function:: void TARGET_INIT_PIC_REG (void)\n+\n+  .. hook-start:TARGET_INIT_PIC_REG\n+\n+  Perform a target dependent initialization of pic_offset_table_rtx.\n+  This hook is called at the start of register allocation.\n+\n+.. hook-end\n+\n+.. function:: int TARGET_ARG_PARTIAL_BYTES (cumulative_args_t cum, const function_arg_info &arg)\n+\n+  .. hook-start:TARGET_ARG_PARTIAL_BYTES\n+\n+  This target hook returns the number of bytes at the beginning of an\n+  argument that must be put in registers.  The value must be zero for\n+  arguments that are passed entirely in registers or that are entirely\n+  pushed on the stack.\n+\n+  On some machines, certain arguments must be passed partially in\n+  registers and partially in memory.  On these machines, typically the\n+  first few words of arguments are passed in registers, and the rest\n+  on the stack.  If a multi-word argument (a ``double`` or a\n+  structure) crosses that boundary, its first few words must be passed\n+  in registers and the rest must be pushed.  This macro tells the\n+  compiler when this occurs, and how many bytes should go in registers.\n+\n+  ``TARGET_FUNCTION_ARG`` for these arguments should return the first\n+  register to be used by the caller for this argument; likewise\n+  ``TARGET_FUNCTION_INCOMING_ARG``, for the called function.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_PASS_BY_REFERENCE (cumulative_args_t cum, const function_arg_info &arg)\n+\n+  .. hook-start:TARGET_PASS_BY_REFERENCE\n+\n+  This target hook should return ``true`` if argument :samp:`{arg}` at the\n+  position indicated by :samp:`{cum}` should be passed by reference.  This\n+  predicate is queried after target independent reasons for being\n+  passed by reference, such as ``TREE_ADDRESSABLE (arg.type)``.\n+\n+  If the hook returns true, a copy of that argument is made in memory and a\n+  pointer to the argument is passed instead of the argument itself.\n+  The pointer is passed in whatever way is appropriate for passing a pointer\n+  to that type.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_CALLEE_COPIES (cumulative_args_t cum, const function_arg_info &arg)\n+\n+  .. hook-start:TARGET_CALLEE_COPIES\n+\n+  The function argument described by the parameters to this hook is\n+  known to be passed by reference.  The hook should return true if the\n+  function argument should be copied by the callee instead of copied\n+  by the caller.\n+\n+  For any argument for which the hook returns true, if it can be\n+  determined that the argument is not modified, then a copy need\n+  not be generated.\n+\n+  The default version of this hook always returns false.\n+\n+.. hook-end\n \n .. c:macro:: CUMULATIVE_ARGS\n \n@@ -122,20 +241,52 @@ the stack.\n \n   .. -mew 5feb93   i switched the order of the sentences.  -mew 10feb93\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_FUNCTION_ARG_ADVANCE]\n-  :end-before: [TARGET_FUNCTION_ARG_ADVANCE]\n+.. function:: void TARGET_FUNCTION_ARG_ADVANCE (cumulative_args_t ca, const function_arg_info &arg)\n+\n+  .. hook-start:TARGET_FUNCTION_ARG_ADVANCE\n+\n+  This hook updates the summarizer variable pointed to by :samp:`{ca}` to\n+  advance past argument :samp:`{arg}` in the argument list.  Once this is done,\n+  the variable :samp:`{cum}` is suitable for analyzing the *following*\n+  argument with ``TARGET_FUNCTION_ARG``, etc.\n+\n+  This hook need not do anything if the argument in question was passed\n+  on the stack.  The compiler knows how to track the amount of stack space\n+  used for arguments without any special help.\n+\n+.. hook-end\n+\n+.. function:: HOST_WIDE_INT TARGET_FUNCTION_ARG_OFFSET (machine_mode mode, const_tree type)\n+\n+  .. hook-start:TARGET_FUNCTION_ARG_OFFSET\n \n+  This hook returns the number of bytes to add to the offset of an\n+  argument of type :samp:`{type}` and mode :samp:`{mode}` when passed in memory.\n+  This is needed for the SPU, which passes ``char`` and ``short``\n+  arguments in the preferred slot that is in the middle of the quad word\n+  instead of starting at the top.  The default implementation returns 0.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_FUNCTION_ARG_OFFSET]\n-  :end-before: [TARGET_FUNCTION_ARG_OFFSET]\n+.. hook-end\n \n+.. function:: pad_direction TARGET_FUNCTION_ARG_PADDING (machine_mode mode, const_tree type)\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_FUNCTION_ARG_PADDING]\n-  :end-before: [TARGET_FUNCTION_ARG_PADDING]\n+  .. hook-start:TARGET_FUNCTION_ARG_PADDING\n \n+  This hook determines whether, and in which direction, to pad out\n+  an argument of mode :samp:`{mode}` and type :samp:`{type}`.  It returns\n+  ``PAD_UPWARD`` to insert padding above the argument, ``PAD_DOWNWARD``\n+  to insert padding below the argument, or ``PAD_NONE`` to inhibit padding.\n+\n+  The *amount* of padding is not controlled by this hook, but by\n+  ``TARGET_FUNCTION_ARG_ROUND_BOUNDARY``.  It is always just enough\n+  to reach the next multiple of that boundary.\n+\n+  This hook has a default definition that is right for most systems.\n+  For little-endian machines, the default is to pad upward.  For\n+  big-endian machines, the default is to pad downward for an argument of\n+  constant size shorter than an ``int``, and upward otherwise.\n+\n+.. hook-end\n \n .. c:macro:: PAD_VARARGS_DOWN\n \n@@ -156,15 +307,26 @@ the stack.\n   a three byte aggregate may be passed in the high part of a register if so\n   required.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_FUNCTION_ARG_BOUNDARY]\n-  :end-before: [TARGET_FUNCTION_ARG_BOUNDARY]\n+.. function:: unsigned int TARGET_FUNCTION_ARG_BOUNDARY (machine_mode mode, const_tree type)\n+\n+  .. hook-start:TARGET_FUNCTION_ARG_BOUNDARY\n+\n+  This hook returns the alignment boundary, in bits, of an argument\n+  with the specified mode and type.  The default hook returns\n+  ``PARM_BOUNDARY`` for all arguments.\n+\n+.. hook-end\n \n+.. function:: unsigned int TARGET_FUNCTION_ARG_ROUND_BOUNDARY (machine_mode mode, const_tree type)\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_FUNCTION_ARG_ROUND_BOUNDARY]\n-  :end-before: [TARGET_FUNCTION_ARG_ROUND_BOUNDARY]\n+  .. hook-start:TARGET_FUNCTION_ARG_ROUND_BOUNDARY\n \n+  Normally, the size of an argument is rounded up to ``PARM_BOUNDARY``,\n+  which is the default value for this hook.  You can define this hook to\n+  return a different value if an argument size must be rounded to a larger\n+  value.\n+\n+.. hook-end\n \n .. c:macro:: FUNCTION_ARG_REGNO_P (regno)\n \n@@ -175,91 +337,297 @@ the stack.\n   used for this purpose since all function arguments are pushed on the\n   stack.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_SPLIT_COMPLEX_ARG]\n-  :end-before: [TARGET_SPLIT_COMPLEX_ARG]\n+.. function:: bool TARGET_SPLIT_COMPLEX_ARG (const_tree type)\n+\n+  .. hook-start:TARGET_SPLIT_COMPLEX_ARG\n+\n+  This hook should return true if parameter of type :samp:`{type}` are passed\n+  as two scalar parameters.  By default, GCC will attempt to pack complex\n+  arguments into the target's word size.  Some ABIs require complex arguments\n+  to be split and treated as their individual components.  For example, on\n+  AIX64, complex floats should be passed in a pair of floating point\n+  registers, even though a complex float would fit in one 64-bit floating\n+  point register.\n+\n+  The default value of this hook is ``NULL``, which is treated as always\n+  false.\n+\n+.. hook-end\n+\n+.. function:: tree TARGET_BUILD_BUILTIN_VA_LIST (void)\n+\n+  .. hook-start:TARGET_BUILD_BUILTIN_VA_LIST\n+\n+  This hook returns a type node for ``va_list`` for the target.\n+  The default version of the hook returns ``void*``.\n+\n+.. hook-end\n+\n+.. function:: int TARGET_ENUM_VA_LIST_P (int idx, const char **pname, tree *ptree)\n+\n+  .. hook-start:TARGET_ENUM_VA_LIST_P\n+\n+  This target hook is used in function ``c_common_nodes_and_builtins``\n+  to iterate through the target specific builtin types for va_list. The\n+  variable :samp:`{idx}` is used as iterator. :samp:`{pname}` has to be a pointer\n+  to a ``const char *`` and :samp:`{ptree}` a pointer to a ``tree`` typed\n+  variable.\n+  The arguments :samp:`{pname}` and :samp:`{ptree}` are used to store the result of\n+  this macro and are set to the name of the va_list builtin type and its\n+  internal type.\n+  If the return value of this macro is zero, then there is no more element.\n+  Otherwise the :samp:`{IDX}` should be increased for the next call of this\n+  macro to iterate through all types.\n+\n+.. hook-end\n+\n+.. function:: tree TARGET_FN_ABI_VA_LIST (tree fndecl)\n+\n+  .. hook-start:TARGET_FN_ABI_VA_LIST\n+\n+  This hook returns the va_list type of the calling convention specified by\n+  :samp:`{fndecl}`.\n+  The default version of this hook returns ``va_list_type_node``.\n+\n+.. hook-end\n+\n+.. function:: tree TARGET_CANONICAL_VA_LIST_TYPE (tree type)\n+\n+  .. hook-start:TARGET_CANONICAL_VA_LIST_TYPE\n+\n+  This hook returns the va_list type of the calling convention specified by the\n+  type of :samp:`{type}`. If :samp:`{type}` is not a valid va_list type, it returns\n+  ``NULL_TREE``.\n+\n+.. hook-end\n+\n+.. function:: tree TARGET_GIMPLIFY_VA_ARG_EXPR (tree valist, tree type, gimple_seq *pre_p, gimple_seq *post_p)\n+\n+  .. hook-start:TARGET_GIMPLIFY_VA_ARG_EXPR\n+\n+  This hook performs target-specific gimplification of\n+  ``VA_ARG_EXPR``.  The first two parameters correspond to the\n+  arguments to ``va_arg`` ; the latter two are as in\n+  ``gimplify.cc:gimplify_expr``.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_VALID_POINTER_MODE (scalar_int_mode mode)\n+\n+  .. hook-start:TARGET_VALID_POINTER_MODE\n+\n+  Define this to return nonzero if the port can handle pointers\n+  with machine mode :samp:`{mode}`.  The default version of this\n+  hook returns true for both ``ptr_mode`` and ``Pmode``.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_REF_MAY_ALIAS_ERRNO (ao_ref *ref)\n+\n+  .. hook-start:TARGET_REF_MAY_ALIAS_ERRNO\n+\n+  Define this to return nonzero if the memory reference :samp:`{ref}`\n+  may alias with the system C library errno location.  The default\n+  version of this hook assumes the system C library errno location\n+  is either a declaration of type int or accessed by dereferencing\n+  a pointer to int.\n+\n+.. hook-end\n+\n+.. function:: machine_mode TARGET_TRANSLATE_MODE_ATTRIBUTE (machine_mode mode)\n+\n+  .. hook-start:TARGET_TRANSLATE_MODE_ATTRIBUTE\n+\n+  Define this hook if during mode attribute processing, the port should\n+  translate machine_mode :samp:`{mode}` to another mode.  For example, rs6000's\n+  ``KFmode``, when it is the same as ``TFmode``.\n+\n+  The default version of the hook returns that mode that was passed in.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_SCALAR_MODE_SUPPORTED_P (scalar_mode mode)\n+\n+  .. hook-start:TARGET_SCALAR_MODE_SUPPORTED_P\n+\n+  Define this to return nonzero if the port is prepared to handle\n+  insns involving scalar mode :samp:`{mode}`.  For a scalar mode to be\n+  considered supported, all the basic arithmetic and comparisons\n+  must work.\n+\n+  The default version of this hook returns true for any mode\n+  required to handle the basic C types (as defined by the port).\n+  Included here are the double-word arithmetic supported by the\n+  code in :samp:`optabs.cc`.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_VECTOR_MODE_SUPPORTED_P (machine_mode mode)\n+\n+  .. hook-start:TARGET_VECTOR_MODE_SUPPORTED_P\n+\n+  Define this to return nonzero if the port is prepared to handle\n+  insns involving vector mode :samp:`{mode}`.  At the very least, it\n+  must have move patterns for this mode.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_COMPATIBLE_VECTOR_TYPES_P (const_tree type1, const_tree type2)\n+\n+  .. hook-start:TARGET_COMPATIBLE_VECTOR_TYPES_P\n+\n+  Return true if there is no target-specific reason for treating\n+  vector types :samp:`{type1}` and :samp:`{type2}` as distinct types.  The caller\n+  has already checked for target-independent reasons, meaning that the\n+  types are known to have the same mode, to have the same number of elements,\n+  and to have what the caller considers to be compatible element types.\n+\n+  The main reason for defining this hook is to reject pairs of types\n+  that are handled differently by the target's calling convention.\n+  For example, when a new :samp:`{N}` -bit vector architecture is added\n+  to a target, the target may want to handle normal :samp:`{N}` -bit\n+  ``VECTOR_TYPE`` arguments and return values in the same way as\n+  before, to maintain backwards compatibility.  However, it may also\n+  provide new, architecture-specific ``VECTOR_TYPE`` s that are passed\n+  and returned in a more efficient way.  It is then important to maintain\n+  a distinction between the 'normal' ``VECTOR_TYPE`` s and the new\n+  architecture-specific ones.\n+\n+  The default implementation returns true, which is correct for most targets.\n+\n+.. hook-end\n+\n+.. function:: opt_machine_mode TARGET_ARRAY_MODE (machine_mode mode, unsigned HOST_WIDE_INT nelems)\n \n+  .. hook-start:TARGET_ARRAY_MODE\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_BUILD_BUILTIN_VA_LIST]\n-  :end-before: [TARGET_BUILD_BUILTIN_VA_LIST]\n+  Return the mode that GCC should use for an array that has\n+  :samp:`{nelems}` elements, with each element having mode :samp:`{mode}`.\n+  Return no mode if the target has no special requirements.  In the\n+  latter case, GCC looks for an integer mode of the appropriate size\n+  if available and uses BLKmode otherwise.  Usually the search for the\n+  integer mode is limited to ``MAX_FIXED_MODE_SIZE``, but the\n+  ``TARGET_ARRAY_MODE_SUPPORTED_P`` hook allows a larger mode to be\n+  used in specific cases.\n \n+  The main use of this hook is to specify that an array of vectors should\n+  also have a vector mode.  The default implementation returns no mode.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_ENUM_VA_LIST_P]\n-  :end-before: [TARGET_ENUM_VA_LIST_P]\n+.. hook-end\n \n+.. function:: bool TARGET_ARRAY_MODE_SUPPORTED_P (machine_mode mode, unsigned HOST_WIDE_INT nelems)\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_FN_ABI_VA_LIST]\n-  :end-before: [TARGET_FN_ABI_VA_LIST]\n+  .. hook-start:TARGET_ARRAY_MODE_SUPPORTED_P\n \n+  Return true if GCC should try to use a scalar mode to store an array\n+  of :samp:`{nelems}` elements, given that each element has mode :samp:`{mode}`.\n+  Returning true here overrides the usual ``MAX_FIXED_MODE`` limit\n+  and allows GCC to use any defined integer mode.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_CANONICAL_VA_LIST_TYPE]\n-  :end-before: [TARGET_CANONICAL_VA_LIST_TYPE]\n+  One use of this hook is to support vector load and store operations\n+  that operate on several homogeneous vectors.  For example, ARM NEON\n+  has operations like:\n \n+  .. code-block:: c++\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_GIMPLIFY_VA_ARG_EXPR]\n-  :end-before: [TARGET_GIMPLIFY_VA_ARG_EXPR]\n+    int8x8x3_t vld3_s8 (const int8_t *)\n \n+  where the return type is defined as:\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_VALID_POINTER_MODE]\n-  :end-before: [TARGET_VALID_POINTER_MODE]\n+  .. code-block:: c++\n \n+    typedef struct int8x8x3_t\n+    {\n+      int8x8_t val[3];\n+    } int8x8x3_t;\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_REF_MAY_ALIAS_ERRNO]\n-  :end-before: [TARGET_REF_MAY_ALIAS_ERRNO]\n+  If this hook allows ``val`` to have a scalar mode, then\n+  ``int8x8x3_t`` can have the same mode.  GCC can then store\n+  ``int8x8x3_t`` s in registers rather than forcing them onto the stack.\n \n+.. hook-end\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_TRANSLATE_MODE_ATTRIBUTE]\n-  :end-before: [TARGET_TRANSLATE_MODE_ATTRIBUTE]\n+.. function:: bool TARGET_LIBGCC_FLOATING_MODE_SUPPORTED_P (scalar_float_mode mode)\n \n+  .. hook-start:TARGET_LIBGCC_FLOATING_MODE_SUPPORTED_P\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_SCALAR_MODE_SUPPORTED_P]\n-  :end-before: [TARGET_SCALAR_MODE_SUPPORTED_P]\n+  Define this to return nonzero if libgcc provides support for the\n+  floating-point mode :samp:`{mode}`, which is known to pass\n+  ``TARGET_SCALAR_MODE_SUPPORTED_P``.  The default version of this\n+  hook returns true for all of ``SFmode``, ``DFmode``,\n+  ``XFmode`` and ``TFmode``, if such modes exist.\n \n+.. hook-end\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_VECTOR_MODE_SUPPORTED_P]\n-  :end-before: [TARGET_VECTOR_MODE_SUPPORTED_P]\n+.. function:: opt_scalar_float_mode TARGET_FLOATN_MODE (int n, bool extended)\n \n+  .. hook-start:TARGET_FLOATN_MODE\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_COMPATIBLE_VECTOR_TYPES_P]\n-  :end-before: [TARGET_COMPATIBLE_VECTOR_TYPES_P]\n+  Define this to return the machine mode to use for the type\n+  ``_Floatn``, if :samp:`{extended}` is false, or the type\n+  ``_Floatnx``, if :samp:`{extended}` is true.  If such a type is not\n+  supported, return ``opt_scalar_float_mode ()``.  The default version of\n+  this hook returns ``SFmode`` for ``_Float32``, ``DFmode`` for\n+  ``_Float64`` and ``_Float32x`` and ``TFmode`` for\n+  ``_Float128``, if those modes exist and satisfy the requirements for\n+  those types and pass ``TARGET_SCALAR_MODE_SUPPORTED_P`` and\n+  ``TARGET_LIBGCC_FLOATING_MODE_SUPPORTED_P`` ; for ``_Float64x``, it\n+  returns the first of ``XFmode`` and ``TFmode`` that exists and\n+  satisfies the same requirements; for other types, it returns\n+  ``opt_scalar_float_mode ()``.  The hook is only called for values\n+  of :samp:`{n}` and :samp:`{extended}` that are valid according to\n+  ISO/IEC TS 18661-3:2015; that is, :samp:`{n}` is one of 32, 64, 128, or,\n+  if :samp:`{extended}` is false, 16 or greater than 128 and a multiple of 32.\n \n+.. hook-end\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_ARRAY_MODE]\n-  :end-before: [TARGET_ARRAY_MODE]\n+.. function:: bool TARGET_FLOATN_BUILTIN_P (int func)\n \n+  .. hook-start:TARGET_FLOATN_BUILTIN_P\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_ARRAY_MODE_SUPPORTED_P]\n-  :end-before: [TARGET_ARRAY_MODE_SUPPORTED_P]\n+  Define this to return true if the ``_Floatn`` and\n+  ``_Floatnx`` built-in functions should implicitly enable the\n+  built-in function without the ``__builtin_`` prefix in addition to the\n+  normal built-in function with the ``__builtin_`` prefix.  The default is\n+  to only enable built-in functions without the ``__builtin_`` prefix for\n+  the GNU C langauge.  In strict ANSI/ISO mode, the built-in function without\n+  the ``__builtin_`` prefix is not enabled.  The argument ``FUNC`` is the\n+  ``enum built_in_function`` id of the function to be enabled.\n \n+.. hook-end\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_LIBGCC_FLOATING_MODE_SUPPORTED_P]\n-  :end-before: [TARGET_LIBGCC_FLOATING_MODE_SUPPORTED_P]\n+.. function:: bool TARGET_SMALL_REGISTER_CLASSES_FOR_MODE_P (machine_mode mode)\n \n+  .. hook-start:TARGET_SMALL_REGISTER_CLASSES_FOR_MODE_P\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_FLOATN_MODE]\n-  :end-before: [TARGET_FLOATN_MODE]\n+  Define this to return nonzero for machine modes for which the port has\n+  small register classes.  If this target hook returns nonzero for a given\n+  :samp:`{mode}`, the compiler will try to minimize the lifetime of registers\n+  in :samp:`{mode}`.  The hook may be called with ``VOIDmode`` as argument.\n+  In this case, the hook is expected to return nonzero if it returns nonzero\n+  for any mode.\n \n+  On some machines, it is risky to let hard registers live across arbitrary\n+  insns.  Typically, these machines have instructions that require values\n+  to be in specific registers (like an accumulator), and reload will fail\n+  if the required hard register is used for another purpose across such an\n+  insn.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_FLOATN_BUILTIN_P]\n-  :end-before: [TARGET_FLOATN_BUILTIN_P]\n+  Passes before reload do not know which hard registers will be used\n+  in an instruction, but the machine modes of the registers set or used in\n+  the instruction are already known.  And for some machines, register\n+  classes are small for, say, integer registers but not for floating point\n+  registers.  For example, the AMD x86-64 architecture requires specific\n+  registers for the legacy x86 integer instructions, but there are many\n+  SSE registers for floating point operations.  On such targets, a good\n+  strategy may be to return nonzero from this hook for ``INTEGRAL_MODE_P``\n+  machine modes but zero for the SSE register classes.\n \n+  The default version of this hook returns false for any mode.  It is always\n+  safe to redefine this hook to return with a nonzero value.  But if you\n+  unnecessarily define it, you will reduce the amount of optimizations\n+  that can be performed in some cases.  If you do not define this hook\n+  to return a nonzero value when it is required, the compiler will run out\n+  of spill registers and print a fatal error message.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_SMALL_REGISTER_CLASSES_FOR_MODE_P]\n-  :end-before: [TARGET_SMALL_REGISTER_CLASSES_FOR_MODE_P]\n+.. hook-end\n\\ No newline at end of file"}, {"sha": "ed99faaf4b4ac6fea0bb3780bc3591df336b1dc2", "filename": "gcc/doc/gccint/target-macros/stack-layout-and-calling-conventions/passing-function-arguments-on-the-stack.rst", "status": "modified", "additions": 65, "deletions": 10, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fstack-layout-and-calling-conventions%2Fpassing-function-arguments-on-the-stack.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fstack-layout-and-calling-conventions%2Fpassing-function-arguments-on-the-stack.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fstack-layout-and-calling-conventions%2Fpassing-function-arguments-on-the-stack.rst?ref=3e070cff11f81051e70b613816075b66a6de61c2", "patch": "@@ -14,15 +14,33 @@ The macros in this section control how arguments are passed\n on the stack.  See the following section for other macros that\n control passing certain arguments in registers.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_PROMOTE_PROTOTYPES]\n-  :end-before: [TARGET_PROMOTE_PROTOTYPES]\n+.. function:: bool TARGET_PROMOTE_PROTOTYPES (const_tree fntype)\n \n+  .. hook-start:TARGET_PROMOTE_PROTOTYPES\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_PUSH_ARGUMENT]\n-  :end-before: [TARGET_PUSH_ARGUMENT]\n+  This target hook returns ``true`` if an argument declared in a\n+  prototype as an integral type smaller than ``int`` should actually be\n+  passed as an ``int``.  In addition to avoiding errors in certain\n+  cases of mismatch, it also makes for better code on certain machines.\n+  The default is to not promote prototypes.\n \n+.. hook-end\n+\n+.. function:: bool TARGET_PUSH_ARGUMENT (unsigned int npush)\n+\n+  .. hook-start:TARGET_PUSH_ARGUMENT\n+\n+  This target hook returns ``true`` if push instructions will be\n+  used to pass outgoing arguments.  When the push instruction usage is\n+  optional, :samp:`{npush}` is nonzero to indicate the number of bytes to\n+  push.  Otherwise, :samp:`{npush}` is zero.  If the target machine does not\n+  have a push instruction or push instruction should be avoided,\n+  ``false`` should be returned.  That directs GCC to use an alternate\n+  strategy: to allocate the entire argument block and then store the\n+  arguments into it.  If this target hook may return ``true``,\n+  ``PUSH_ROUNDING`` must be defined.\n+\n+.. hook-end\n \n .. c:macro:: PUSH_ARGS_REVERSED\n \n@@ -117,10 +135,47 @@ control passing certain arguments in registers.\n   suppresses this behavior and causes the parameter to be passed on the\n   stack in its natural location.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_RETURN_POPS_ARGS]\n-  :end-before: [TARGET_RETURN_POPS_ARGS]\n-\n+.. function:: poly_int64 TARGET_RETURN_POPS_ARGS (tree fundecl, tree funtype, poly_int64 size)\n+\n+  .. hook-start:TARGET_RETURN_POPS_ARGS\n+\n+  This target hook returns the number of bytes of its own arguments that\n+  a function pops on returning, or 0 if the function pops no arguments\n+  and the caller must therefore pop them all after the function returns.\n+\n+  :samp:`{fundecl}` is a C variable whose value is a tree node that describes\n+  the function in question.  Normally it is a node of type\n+  ``FUNCTION_DECL`` that describes the declaration of the function.\n+  From this you can obtain the ``DECL_ATTRIBUTES`` of the function.\n+\n+  :samp:`{funtype}` is a C variable whose value is a tree node that\n+  describes the function in question.  Normally it is a node of type\n+  ``FUNCTION_TYPE`` that describes the data type of the function.\n+  From this it is possible to obtain the data types of the value and\n+  arguments (if known).\n+\n+  When a call to a library function is being considered, :samp:`{fundecl}`\n+  will contain an identifier node for the library function.  Thus, if\n+  you need to distinguish among various library functions, you can do so\n+  by their names.  Note that 'library function' in this context means\n+  a function used to perform arithmetic, whose name is known specially\n+  in the compiler and was not mentioned in the C code being compiled.\n+\n+  :samp:`{size}` is the number of bytes of arguments passed on the\n+  stack.  If a variable number of bytes is passed, it is zero, and\n+  argument popping will always be the responsibility of the calling function.\n+\n+  On the VAX, all functions always pop their arguments, so the definition\n+  of this macro is :samp:`{size}`.  On the 68000, using the standard\n+  calling convention, no functions pop their arguments, so the value of\n+  the macro is always 0 in this case.  But an alternative calling\n+  convention is available in which functions that take a fixed number of\n+  arguments pop them but other functions (such as ``printf``) pop\n+  nothing (the caller pops all).  When this convention is in use,\n+  :samp:`{funtype}` is examined to determine whether a function takes a fixed\n+  number of arguments.\n+\n+.. hook-end\n \n .. c:macro:: CALL_POPS_ARGS (cum)\n "}, {"sha": "229248cac3ebb8c53ccc885dca8352a38d026169", "filename": "gcc/doc/gccint/target-macros/stack-layout-and-calling-conventions/permitting-tail-calls.rst", "status": "modified", "additions": 42, "deletions": 12, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fstack-layout-and-calling-conventions%2Fpermitting-tail-calls.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fstack-layout-and-calling-conventions%2Fpermitting-tail-calls.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fstack-layout-and-calling-conventions%2Fpermitting-tail-calls.rst?ref=3e070cff11f81051e70b613816075b66a6de61c2", "patch": "@@ -10,21 +10,51 @@\n Permitting tail calls\n ^^^^^^^^^^^^^^^^^^^^^\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_FUNCTION_OK_FOR_SIBCALL]\n-  :end-before: [TARGET_FUNCTION_OK_FOR_SIBCALL]\n+.. function:: bool TARGET_FUNCTION_OK_FOR_SIBCALL (tree decl, tree exp)\n \n+  .. hook-start:TARGET_FUNCTION_OK_FOR_SIBCALL\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_EXTRA_LIVE_ON_ENTRY]\n-  :end-before: [TARGET_EXTRA_LIVE_ON_ENTRY]\n+  True if it is OK to do sibling call optimization for the specified\n+  call expression :samp:`{exp}`.  :samp:`{decl}` will be the called function,\n+  or ``NULL`` if this is an indirect call.\n \n+  It is not uncommon for limitations of calling conventions to prevent\n+  tail calls to functions outside the current unit of translation, or\n+  during PIC compilation.  The hook is used to enforce these restrictions,\n+  as the ``sibcall`` md pattern cannot fail, or fall over to a\n+  'normal' call.  The criteria for successful sibling call optimization\n+  may vary greatly between different architectures.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_SET_UP_BY_PROLOGUE]\n-  :end-before: [TARGET_SET_UP_BY_PROLOGUE]\n+.. hook-end\n \n+.. function:: void TARGET_EXTRA_LIVE_ON_ENTRY (bitmap regs)\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_WARN_FUNC_RETURN]\n-  :end-before: [TARGET_WARN_FUNC_RETURN]\n+  .. hook-start:TARGET_EXTRA_LIVE_ON_ENTRY\n+\n+  Add any hard registers to :samp:`{regs}` that are live on entry to the\n+  function.  This hook only needs to be defined to provide registers that\n+  cannot be found by examination of FUNCTION_ARG_REGNO_P, the callee saved\n+  registers, STATIC_CHAIN_INCOMING_REGNUM, STATIC_CHAIN_REGNUM,\n+  TARGET_STRUCT_VALUE_RTX, FRAME_POINTER_REGNUM, EH_USES,\n+  FRAME_POINTER_REGNUM, ARG_POINTER_REGNUM, and the PIC_OFFSET_TABLE_REGNUM.\n+\n+.. hook-end\n+\n+.. function:: void TARGET_SET_UP_BY_PROLOGUE (struct hard_reg_set_container *)\n+\n+  .. hook-start:TARGET_SET_UP_BY_PROLOGUE\n+\n+  This hook should add additional registers that are computed by the prologue\n+  to the hard regset for shrink-wrapping optimization purposes.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_WARN_FUNC_RETURN (tree)\n+\n+  .. hook-start:TARGET_WARN_FUNC_RETURN\n+\n+  True if a function's return statements should be checked for matching\n+  the function's return type.  This includes checking for falling off the end\n+  of a non-void function.  Return false if no such check should be made.\n+\n+.. hook-end\n\\ No newline at end of file"}, {"sha": "129d22b899eb4f6aebd5fb730a0669d2d031f21e", "filename": "gcc/doc/gccint/target-macros/stack-layout-and-calling-conventions/registers-that-address-the-stack-frame.rst", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fstack-layout-and-calling-conventions%2Fregisters-that-address-the-stack-frame.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fstack-layout-and-calling-conventions%2Fregisters-that-address-the-stack-frame.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fstack-layout-and-calling-conventions%2Fregisters-that-address-the-stack-frame.rst?ref=3e070cff11f81051e70b613816075b66a6de61c2", "patch": "@@ -102,10 +102,31 @@ This discusses registers that address the stack frame.\n   If the static chain is passed in memory, these macros should not be\n   defined; instead, the ``TARGET_STATIC_CHAIN`` hook should be used.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_STATIC_CHAIN]\n-  :end-before: [TARGET_STATIC_CHAIN]\n+.. function:: rtx TARGET_STATIC_CHAIN (const_tree fndecl_or_type, bool incoming_p)\n \n+  .. hook-start:TARGET_STATIC_CHAIN\n+\n+  This hook replaces the use of ``STATIC_CHAIN_REGNUM`` et al for\n+  targets that may use different static chain locations for different\n+  nested functions.  This may be required if the target has function\n+  attributes that affect the calling conventions of the function and\n+  those calling conventions use different static chain locations.\n+\n+  The default version of this hook uses ``STATIC_CHAIN_REGNUM`` et al.\n+\n+  If the static chain is passed in memory, this hook should be used to\n+  provide rtx giving ``mem`` expressions that denote where they are stored.\n+  Often the ``mem`` expression as seen by the caller will be at an offset\n+  from the stack pointer and the ``mem`` expression as seen by the callee\n+  will be at an offset from the frame pointer.\n+\n+  .. index:: stack_pointer_rtx, frame_pointer_rtx, arg_pointer_rtx\n+\n+  The variables ``stack_pointer_rtx``, ``frame_pointer_rtx``, and\n+  ``arg_pointer_rtx`` will have been initialized and should be used\n+  to refer to those items.\n+\n+.. hook-end\n \n .. c:macro:: DWARF_FRAME_REGISTERS\n "}, {"sha": "f2c85db45fab2a9ec30c8003e57a05ec2bbd5ba0", "filename": "gcc/doc/gccint/target-macros/stack-layout-and-calling-conventions/shrink-wrapping-separate-components.rst", "status": "modified", "additions": 50, "deletions": 18, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fstack-layout-and-calling-conventions%2Fshrink-wrapping-separate-components.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fstack-layout-and-calling-conventions%2Fshrink-wrapping-separate-components.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fstack-layout-and-calling-conventions%2Fshrink-wrapping-separate-components.rst?ref=3e070cff11f81051e70b613816075b66a6de61c2", "patch": "@@ -31,31 +31,63 @@ code treats them abstractly, as a bit in an ``sbitmap``.  These\n and ``shrink_wrap.components_for_bb`` hooks, and deallocated by the\n generic code.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_SHRINK_WRAP_GET_SEPARATE_COMPONENTS]\n-  :end-before: [TARGET_SHRINK_WRAP_GET_SEPARATE_COMPONENTS]\n+.. function:: sbitmap TARGET_SHRINK_WRAP_GET_SEPARATE_COMPONENTS (void)\n \n+  .. hook-start:TARGET_SHRINK_WRAP_GET_SEPARATE_COMPONENTS\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_SHRINK_WRAP_COMPONENTS_FOR_BB]\n-  :end-before: [TARGET_SHRINK_WRAP_COMPONENTS_FOR_BB]\n+  This hook should return an ``sbitmap`` with the bits set for those\n+  components that can be separately shrink-wrapped in the current function.\n+  Return ``NULL`` if the current function should not get any separate\n+  shrink-wrapping.\n+  Don't define this hook if it would always return ``NULL``.\n+  If it is defined, the other hooks in this group have to be defined as well.\n \n+.. hook-end\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_SHRINK_WRAP_DISQUALIFY_COMPONENTS]\n-  :end-before: [TARGET_SHRINK_WRAP_DISQUALIFY_COMPONENTS]\n+.. function:: sbitmap TARGET_SHRINK_WRAP_COMPONENTS_FOR_BB (basic_block)\n \n+  .. hook-start:TARGET_SHRINK_WRAP_COMPONENTS_FOR_BB\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_SHRINK_WRAP_EMIT_PROLOGUE_COMPONENTS]\n-  :end-before: [TARGET_SHRINK_WRAP_EMIT_PROLOGUE_COMPONENTS]\n+  This hook should return an ``sbitmap`` with the bits set for those\n+  components where either the prologue component has to be executed before\n+  the ``basic_block``, or the epilogue component after it, or both.\n \n+.. hook-end\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_SHRINK_WRAP_EMIT_EPILOGUE_COMPONENTS]\n-  :end-before: [TARGET_SHRINK_WRAP_EMIT_EPILOGUE_COMPONENTS]\n+.. function:: void TARGET_SHRINK_WRAP_DISQUALIFY_COMPONENTS (sbitmap components, edge e, sbitmap edge_components, bool is_prologue)\n \n+  .. hook-start:TARGET_SHRINK_WRAP_DISQUALIFY_COMPONENTS\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_SHRINK_WRAP_SET_HANDLED_COMPONENTS]\n-  :end-before: [TARGET_SHRINK_WRAP_SET_HANDLED_COMPONENTS]\n+  This hook should clear the bits in the :samp:`{components}` bitmap for those\n+  components in :samp:`{edge_components}` that the target cannot handle on edge\n+  :samp:`{e}`, where :samp:`{is_prologue}` says if this is for a prologue or an\n+  epilogue instead.\n+\n+.. hook-end\n+\n+.. function:: void TARGET_SHRINK_WRAP_EMIT_PROLOGUE_COMPONENTS (sbitmap)\n+\n+  .. hook-start:TARGET_SHRINK_WRAP_EMIT_PROLOGUE_COMPONENTS\n+\n+  Emit prologue insns for the components indicated by the parameter.\n+\n+.. hook-end\n+\n+.. function:: void TARGET_SHRINK_WRAP_EMIT_EPILOGUE_COMPONENTS (sbitmap)\n+\n+  .. hook-start:TARGET_SHRINK_WRAP_EMIT_EPILOGUE_COMPONENTS\n+\n+  Emit epilogue insns for the components indicated by the parameter.\n+\n+.. hook-end\n+\n+.. function:: void TARGET_SHRINK_WRAP_SET_HANDLED_COMPONENTS (sbitmap)\n+\n+  .. hook-start:TARGET_SHRINK_WRAP_SET_HANDLED_COMPONENTS\n+\n+  Mark the components in the parameter as handled, so that the\n+  ``prologue`` and ``epilogue`` named patterns know to ignore those\n+  components.  The target code should not hang on to the ``sbitmap``, it\n+  will be deleted after this call.\n+\n+.. hook-end\n\\ No newline at end of file"}, {"sha": "cc23c7063f41e7bca5815ce4bf972622fab0b3ab", "filename": "gcc/doc/gccint/target-macros/stack-layout-and-calling-conventions/specifying-how-stack-checking-is-done.rst", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fstack-layout-and-calling-conventions%2Fspecifying-how-stack-checking-is-done.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fstack-layout-and-calling-conventions%2Fspecifying-how-stack-checking-is-done.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fstack-layout-and-calling-conventions%2Fspecifying-how-stack-checking-is-done.rst?ref=3e070cff11f81051e70b613816075b66a6de61c2", "patch": "@@ -102,6 +102,17 @@ in the opposite case.\n   GCC computed the default from the values of the above macros and you will\n   normally not need to override that default.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_STACK_CLASH_PROTECTION_ALLOCA_PROBE_RANGE]\n-  :end-before: [TARGET_STACK_CLASH_PROTECTION_ALLOCA_PROBE_RANGE]\n+.. function:: HOST_WIDE_INT TARGET_STACK_CLASH_PROTECTION_ALLOCA_PROBE_RANGE (void)\n+\n+  .. hook-start:TARGET_STACK_CLASH_PROTECTION_ALLOCA_PROBE_RANGE\n+\n+  Some targets have an ABI defined interval for which no probing needs to be done.\n+  When a probe does need to be done this same interval is used as the probe distance\n+  up when doing stack clash protection for alloca.\n+  On such targets this value can be set to override the default probing up interval.\n+  Define this variable to return nonzero if such a probe range is required or zero otherwise.\n+  Defining this hook also requires your functions which make use of alloca to have at least 8 byes\n+  of outgoing arguments.  If this is not the case the stack will be corrupted.\n+  You need not define this macro if it would always have the value zero.\n+\n+.. hook-end\n\\ No newline at end of file"}, {"sha": "d27a27118b67256de2cd8153c6ef0232577d14e9", "filename": "gcc/doc/gccint/target-macros/stack-layout-and-calling-conventions/stack-smashing-protection.rst", "status": "modified", "additions": 55, "deletions": 15, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fstack-layout-and-calling-conventions%2Fstack-smashing-protection.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fstack-layout-and-calling-conventions%2Fstack-smashing-protection.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fstack-layout-and-calling-conventions%2Fstack-smashing-protection.rst?ref=3e070cff11f81051e70b613816075b66a6de61c2", "patch": "@@ -10,26 +10,66 @@\n Stack smashing protection\n ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_STACK_PROTECT_GUARD]\n-  :end-before: [TARGET_STACK_PROTECT_GUARD]\n+.. function:: tree TARGET_STACK_PROTECT_GUARD (void)\n \n+  .. hook-start:TARGET_STACK_PROTECT_GUARD\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_STACK_PROTECT_FAIL]\n-  :end-before: [TARGET_STACK_PROTECT_FAIL]\n+  This hook returns a ``DECL`` node for the external variable to use\n+  for the stack protection guard.  This variable is initialized by the\n+  runtime to some random value and is used to initialize the guard value\n+  that is placed at the top of the local stack frame.  The type of this\n+  variable must be ``ptr_type_node``.\n \n+  The default version of this hook creates a variable called\n+  :samp:`__stack_chk_guard`, which is normally defined in :samp:`libgcc2.c`.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_STACK_PROTECT_RUNTIME_ENABLED_P]\n-  :end-before: [TARGET_STACK_PROTECT_RUNTIME_ENABLED_P]\n+.. hook-end\n \n+.. function:: tree TARGET_STACK_PROTECT_FAIL (void)\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_SUPPORTS_SPLIT_STACK]\n-  :end-before: [TARGET_SUPPORTS_SPLIT_STACK]\n+  .. hook-start:TARGET_STACK_PROTECT_FAIL\n \n+  This hook returns a ``CALL_EXPR`` that alerts the runtime that the\n+  stack protect guard variable has been modified.  This expression should\n+  involve a call to a ``noreturn`` function.\n \n-.. include:: ../tm.rst.in\n-  :start-after: [TARGET_GET_VALID_OPTION_VALUES]\n-  :end-before: [TARGET_GET_VALID_OPTION_VALUES]\n+  The default version of this hook invokes a function called\n+  :samp:`__stack_chk_fail`, taking no arguments.  This function is\n+  normally defined in :samp:`libgcc2.c`.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_STACK_PROTECT_RUNTIME_ENABLED_P (void)\n+\n+  .. hook-start:TARGET_STACK_PROTECT_RUNTIME_ENABLED_P\n+\n+  Returns true if the target wants GCC's default stack protect runtime support,\n+  otherwise return false.  The default implementation always returns true.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_SUPPORTS_SPLIT_STACK (bool report, struct gcc_options *opts)\n+\n+  .. hook-start:TARGET_SUPPORTS_SPLIT_STACK\n+\n+  Whether this target supports splitting the stack when the options\n+  described in :samp:`{opts}` have been passed.  This is called\n+  after options have been parsed, so the target may reject splitting\n+  the stack in some configurations.  The default version of this hook\n+  returns false.  If :samp:`{report}` is true, this function may issue a warning\n+  or error; if :samp:`{report}` is false, it must simply return a value\n+\n+.. hook-end\n+\n+.. function:: vec<const char *> TARGET_GET_VALID_OPTION_VALUES (int option_code, const char *prefix)\n+\n+  .. hook-start:TARGET_GET_VALID_OPTION_VALUES\n+\n+  The hook is used for options that have a non-trivial list of\n+  possible option values.  OPTION_CODE is option code of opt_code\n+  enum type.  PREFIX is used for bash completion and allows an implementation\n+  to return more specific completion based on the prefix.  All string values\n+  should be allocated from heap memory and consumers should release them.\n+  The result will be pruned to cases with PREFIX if not NULL.\n+\n+.. hook-end\n\\ No newline at end of file"}, {"sha": "3b68e400bf22e95d6ff325ba73dcac42eb13356d", "filename": "gcc/doc/gccint/target-macros/storage-layout.rst", "status": "modified", "additions": 259, "deletions": 60, "changes": 319, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fstorage-layout.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fstorage-layout.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fstorage-layout.rst?ref=3e070cff11f81051e70b613816075b66a6de61c2", "patch": "@@ -121,15 +121,61 @@ See :ref:`run-time-target`.\n \n   Do not define this macro if it would never modify :samp:`{m}`.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_C_EXCESS_PRECISION]\n-  :end-before: [TARGET_C_EXCESS_PRECISION]\n-\n-\n-.. include:: tm.rst.in\n-  :start-after: [TARGET_PROMOTE_FUNCTION_MODE]\n-  :end-before: [TARGET_PROMOTE_FUNCTION_MODE]\n-\n+.. function:: enum flt_eval_method TARGET_C_EXCESS_PRECISION (enum excess_precision_type type)\n+\n+  .. hook-start:TARGET_C_EXCESS_PRECISION\n+\n+  Return a value, with the same meaning as the C99 macro\n+  ``FLT_EVAL_METHOD`` that describes which excess precision should be\n+  applied.  :samp:`{type}` is either ``EXCESS_PRECISION_TYPE_IMPLICIT``,\n+  ``EXCESS_PRECISION_TYPE_FAST``,\n+  ``EXCESS_PRECISION_TYPE_STANDARD``, or\n+  ``EXCESS_PRECISION_TYPE_FLOAT16``.  For\n+  ``EXCESS_PRECISION_TYPE_IMPLICIT``, the target should return which\n+  precision and range operations will be implictly evaluated in regardless\n+  of the excess precision explicitly added.  For\n+  ``EXCESS_PRECISION_TYPE_STANDARD``,\n+  ``EXCESS_PRECISION_TYPE_FLOAT16``, and\n+  ``EXCESS_PRECISION_TYPE_FAST``, the target should return the\n+  explicit excess precision that should be added depending on the\n+  value set for :option:`-fexcess-precision=[standard|fast|16]`.\n+  Note that unpredictable explicit excess precision does not make sense,\n+  so a target should never return ``FLT_EVAL_METHOD_UNPREDICTABLE``\n+  when :samp:`{type}` is ``EXCESS_PRECISION_TYPE_STANDARD``,\n+  ``EXCESS_PRECISION_TYPE_FLOAT16`` or\n+  ``EXCESS_PRECISION_TYPE_FAST``.\n+\n+Return a value, with the same meaning as the C99 macro\n+``FLT_EVAL_METHOD`` that describes which excess precision should be\n+applied.\n+\n+.. hook-end\n+\n+.. function:: machine_mode TARGET_PROMOTE_FUNCTION_MODE (const_tree type, machine_mode mode, int *punsignedp, const_tree funtype, int for_return)\n+\n+  .. hook-start:TARGET_PROMOTE_FUNCTION_MODE\n+\n+  Like ``PROMOTE_MODE``, but it is applied to outgoing function arguments or\n+  function return values.  The target hook should return the new mode\n+  and possibly change ``*punsignedp`` if the promotion should\n+  change signedness.  This function is called only for scalar *or\n+  pointer* types.\n+\n+  :samp:`{for_return}` allows to distinguish the promotion of arguments and\n+  return values.  If it is ``1``, a return value is being promoted and\n+  ``TARGET_FUNCTION_VALUE`` must perform the same promotions done here.\n+  If it is ``2``, the returned mode should be that of the register in\n+  which an incoming parameter is copied, or the outgoing result is computed;\n+  then the hook should return the same mode as ``promote_mode``, though\n+  the signedness may be different.\n+\n+  :samp:`{type}` can be NULL when promoting function arguments of libcalls.\n+\n+  The default is to not promote arguments and return values.  You can\n+  also define the hook to ``default_promote_function_mode_always_promote``\n+  if you would like to apply the same rules given by ``PROMOTE_MODE``.\n+\n+.. hook-end\n \n .. c:macro:: PARM_BOUNDARY\n \n@@ -170,10 +216,15 @@ See :ref:`run-time-target`.\n   bits.  Note that this is not the biggest alignment that is supported,\n   just the biggest alignment that, when violated, may cause a fault.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_ABSOLUTE_BIGGEST_ALIGNMENT]\n-  :end-before: [TARGET_ABSOLUTE_BIGGEST_ALIGNMENT]\n+.. c:var:: HOST_WIDE_INT TARGET_ABSOLUTE_BIGGEST_ALIGNMENT\n \n+  .. hook-start:TARGET_ABSOLUTE_BIGGEST_ALIGNMENT\n+\n+  If defined, this target hook specifies the absolute biggest alignment\n+  that a type or variable can have on this machine, otherwise,\n+  ``BIGGEST_ALIGNMENT`` is used.\n+\n+.. hook-end\n \n .. c:macro:: MALLOC_ABI_ALIGNMENT\n \n@@ -238,15 +289,25 @@ See :ref:`run-time-target`.\n   On 32-bit ELF the largest supported section alignment in bits is\n   :samp:`(0x80000000 * 8)`, but this is not representable on 32-bit hosts.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_LOWER_LOCAL_DECL_ALIGNMENT]\n-  :end-before: [TARGET_LOWER_LOCAL_DECL_ALIGNMENT]\n+.. function:: void TARGET_LOWER_LOCAL_DECL_ALIGNMENT (tree decl)\n+\n+  .. hook-start:TARGET_LOWER_LOCAL_DECL_ALIGNMENT\n \n+  Define this hook to lower alignment of local, parm or result\n+  decl :samp:`({decl})`.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_STATIC_RTX_ALIGNMENT]\n-  :end-before: [TARGET_STATIC_RTX_ALIGNMENT]\n+.. hook-end\n \n+.. function:: HOST_WIDE_INT TARGET_STATIC_RTX_ALIGNMENT (machine_mode mode)\n+\n+  .. hook-start:TARGET_STATIC_RTX_ALIGNMENT\n+\n+  This hook returns the preferred alignment in bits for a\n+  statically-allocated rtx, such as a constant pool entry.  :samp:`{mode}`\n+  is the mode of the rtx.  The default implementation returns\n+  :samp:`GET_MODE_ALIGNMENT ({mode})`.\n+\n+.. hook-end\n \n .. c:macro:: DATA_ALIGNMENT (type, basic_align)\n \n@@ -272,10 +333,22 @@ See :ref:`run-time-target`.\n \n   If this macro is not defined, then :samp:`{basic_align}` is used.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_CONSTANT_ALIGNMENT]\n-  :end-before: [TARGET_CONSTANT_ALIGNMENT]\n+.. function:: HOST_WIDE_INT TARGET_CONSTANT_ALIGNMENT (const_tree constant, HOST_WIDE_INT basic_align)\n+\n+  .. hook-start:TARGET_CONSTANT_ALIGNMENT\n+\n+  This hook returns the alignment in bits of a constant that is being\n+  placed in memory.  :samp:`{constant}` is the constant and :samp:`{basic_align}`\n+  is the alignment that the object would ordinarily have.\n+\n+  The default definition just returns :samp:`{basic_align}`.\n \n+  The typical use of this hook is to increase alignment for string\n+  constants to be word aligned so that ``strcpy`` calls that copy\n+  constants can be done inline.  The function\n+  ``constant_alignment_word_strings`` provides such a definition.\n+\n+.. hook-end\n \n .. c:macro:: LOCAL_ALIGNMENT (type, basic_align)\n \n@@ -291,10 +364,17 @@ See :ref:`run-time-target`.\n \n   If the value of this macro has a type, it should be an unsigned type.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_VECTOR_ALIGNMENT]\n-  :end-before: [TARGET_VECTOR_ALIGNMENT]\n+.. function:: HOST_WIDE_INT TARGET_VECTOR_ALIGNMENT (const_tree type)\n+\n+  .. hook-start:TARGET_VECTOR_ALIGNMENT\n+\n+  This hook can be used to define the alignment for a vector of type\n+  :samp:`{type}`, in order to comply with a platform ABI.  The default is to\n+  require natural alignment for vector types.  The alignment returned by\n+  this hook must be a power-of-two multiple of the default alignment of\n+  the vector element type.\n \n+.. hook-end\n \n .. c:macro:: STACK_SLOT_ALIGNMENT (type, mode, basic_align)\n \n@@ -428,20 +508,44 @@ See :ref:`run-time-target`.\n   Like ``PCC_BITFIELD_TYPE_MATTERS`` except that its effect is limited\n   to aligning a bit-field within the structure.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_ALIGN_ANON_BITFIELD]\n-  :end-before: [TARGET_ALIGN_ANON_BITFIELD]\n+.. function:: bool TARGET_ALIGN_ANON_BITFIELD (void)\n+\n+  .. hook-start:TARGET_ALIGN_ANON_BITFIELD\n+\n+  When ``PCC_BITFIELD_TYPE_MATTERS`` is true this hook will determine\n+  whether unnamed bitfields affect the alignment of the containing\n+  structure.  The hook should return true if the structure should inherit\n+  the alignment requirements of an unnamed bitfield's type.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_NARROW_VOLATILE_BITFIELD (void)\n+\n+  .. hook-start:TARGET_NARROW_VOLATILE_BITFIELD\n+\n+  This target hook should return ``true`` if accesses to volatile bitfields\n+  should use the narrowest mode possible.  It should return ``false`` if\n+  these accesses should use the bitfield container type.\n+\n+  The default is ``false``.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_MEMBER_TYPE_FORCES_BLK (const_tree field, machine_mode mode)\n \n+  .. hook-start:TARGET_MEMBER_TYPE_FORCES_BLK\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_NARROW_VOLATILE_BITFIELD]\n-  :end-before: [TARGET_NARROW_VOLATILE_BITFIELD]\n+  Return true if a structure, union or array containing :samp:`{field}` should\n+  be accessed using ``BLKMODE``.\n \n+  If :samp:`{field}` is the only field in the structure, :samp:`{mode}` is its\n+  mode, otherwise :samp:`{mode}` is VOIDmode.  :samp:`{mode}` is provided in the\n+  case where structures of one field would require the structure's mode to\n+  retain the field's mode.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_MEMBER_TYPE_FORCES_BLK]\n-  :end-before: [TARGET_MEMBER_TYPE_FORCES_BLK]\n+  Normally, this is not needed.\n \n+.. hook-end\n \n .. c:macro:: ROUND_TYPE_ALIGN (type, computed, specified)\n \n@@ -485,46 +589,141 @@ See :ref:`run-time-target`.\n   You would most commonly define this macro if the ``allocate_stack``\n   pattern needs to support both a 32- and a 64-bit mode.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_LIBGCC_CMP_RETURN_MODE]\n-  :end-before: [TARGET_LIBGCC_CMP_RETURN_MODE]\n+.. function:: scalar_int_mode TARGET_LIBGCC_CMP_RETURN_MODE (void)\n+\n+  .. hook-start:TARGET_LIBGCC_CMP_RETURN_MODE\n+\n+  This target hook should return the mode to be used for the return value\n+  of compare instructions expanded to libgcc calls.  If not defined\n+  ``word_mode`` is returned which is the right choice for a majority of\n+  targets.\n+\n+.. hook-end\n+\n+.. function:: scalar_int_mode TARGET_LIBGCC_SHIFT_COUNT_MODE (void)\n+\n+  .. hook-start:TARGET_LIBGCC_SHIFT_COUNT_MODE\n+\n+  This target hook should return the mode to be used for the shift count operand\n+  of shift instructions expanded to libgcc calls.  If not defined\n+  ``word_mode`` is returned which is the right choice for a majority of\n+  targets.\n+\n+.. hook-end\n+\n+.. function:: scalar_int_mode TARGET_UNWIND_WORD_MODE (void)\n+\n+  .. hook-start:TARGET_UNWIND_WORD_MODE\n+\n+  Return machine mode to be used for ``_Unwind_Word`` type.\n+  The default is to use ``word_mode``.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_MS_BITFIELD_LAYOUT_P (const_tree record_type)\n+\n+  .. hook-start:TARGET_MS_BITFIELD_LAYOUT_P\n+\n+  This target hook returns ``true`` if bit-fields in the given\n+  :samp:`{record_type}` are to be laid out following the rules of Microsoft\n+  Visual C/C++, namely: (i) a bit-field won't share the same storage\n+  unit with the previous bit-field if their underlying types have\n+  different sizes, and the bit-field will be aligned to the highest\n+  alignment of the underlying types of itself and of the previous\n+  bit-field; (ii) a zero-sized bit-field will affect the alignment of\n+  the whole enclosing structure, even if it is unnamed; except that\n+  (iii) a zero-sized bit-field will be disregarded unless it follows\n+  another bit-field of nonzero size.  If this hook returns ``true``,\n+  other macros that control bit-field layout are ignored.\n+\n+  When a bit-field is inserted into a packed record, the whole size\n+  of the underlying type is used by one or more same-size adjacent\n+  bit-fields (that is, if its long:3, 32 bits is used in the record,\n+  and any additional adjacent long bit-fields are packed into the same\n+  chunk of 32 bits.  However, if the size changes, a new field of that\n+  size is allocated).  In an unpacked record, this is the same as using\n+  alignment, but not equivalent when packing.\n+\n+  If both MS bit-fields and :samp:`__attribute__((packed))` are used,\n+  the latter will take precedence.  If :samp:`__attribute__((packed))` is\n+  used on a single field when MS bit-fields are in use, it will take\n+  precedence for that field, but the alignment of the rest of the structure\n+  may affect its placement.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_DECIMAL_FLOAT_SUPPORTED_P (void)\n+\n+  .. hook-start:TARGET_DECIMAL_FLOAT_SUPPORTED_P\n+\n+  Returns true if the target supports decimal floating point.\n+\n+.. hook-end\n+\n+.. function:: bool TARGET_FIXED_POINT_SUPPORTED_P (void)\n+\n+  .. hook-start:TARGET_FIXED_POINT_SUPPORTED_P\n+\n+  Returns true if the target supports fixed-point arithmetic.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_LIBGCC_SHIFT_COUNT_MODE]\n-  :end-before: [TARGET_LIBGCC_SHIFT_COUNT_MODE]\n+.. function:: void TARGET_EXPAND_TO_RTL_HOOK (void)\n \n+  .. hook-start:TARGET_EXPAND_TO_RTL_HOOK\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_UNWIND_WORD_MODE]\n-  :end-before: [TARGET_UNWIND_WORD_MODE]\n+  This hook is called just before expansion into rtl, allowing the target\n+  to perform additional initializations or analysis before the expansion.\n+  For example, the rs6000 port uses it to allocate a scratch stack slot\n+  for use in copying SDmode values between memory and floating point\n+  registers whenever the function being expanded has any SDmode\n+  usage.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_MS_BITFIELD_LAYOUT_P]\n-  :end-before: [TARGET_MS_BITFIELD_LAYOUT_P]\n+.. function:: void TARGET_INSTANTIATE_DECLS (void)\n \n+  .. hook-start:TARGET_INSTANTIATE_DECLS\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_DECIMAL_FLOAT_SUPPORTED_P]\n-  :end-before: [TARGET_DECIMAL_FLOAT_SUPPORTED_P]\n+  This hook allows the backend to perform additional instantiations on rtl\n+  that are not actually in any insns yet, but will be later.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_FIXED_POINT_SUPPORTED_P]\n-  :end-before: [TARGET_FIXED_POINT_SUPPORTED_P]\n+.. function:: const char * TARGET_MANGLE_TYPE (const_tree type)\n \n+  .. hook-start:TARGET_MANGLE_TYPE\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_EXPAND_TO_RTL_HOOK]\n-  :end-before: [TARGET_EXPAND_TO_RTL_HOOK]\n+  If your target defines any fundamental types, or any types your target\n+  uses should be mangled differently from the default, define this hook\n+  to return the appropriate encoding for these types as part of a C++\n+  mangled name.  The :samp:`{type}` argument is the tree structure representing\n+  the type to be mangled.  The hook may be applied to trees which are\n+  not target-specific fundamental types; it should return ``NULL``\n+  for all such types, as well as arguments it does not recognize.  If the\n+  return value is not ``NULL``, it must point to a statically-allocated\n+  string constant.\n \n+  Target-specific fundamental types might be new fundamental types or\n+  qualified versions of ordinary fundamental types.  Encode new\n+  fundamental types as :samp:`u {n}{name}`, where :samp:`{name}`\n+  is the name used for the type in source code, and :samp:`{n}` is the\n+  length of :samp:`{name}` in decimal.  Encode qualified versions of\n+  ordinary types as :samp:`U{n}{name}{code}`, where\n+  :samp:`{name}` is the name used for the type qualifier in source code,\n+  :samp:`{n}` is the length of :samp:`{name}` as above, and :samp:`{code}` is the\n+  code used to represent the unqualified version of this type.  (See\n+  ``write_builtin_type`` in :samp:`cp/mangle.cc` for the list of\n+  codes.)  In both cases the spaces are for clarity; do not include any\n+  spaces in your string.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_INSTANTIATE_DECLS]\n-  :end-before: [TARGET_INSTANTIATE_DECLS]\n+  This hook is applied to types prior to typedef resolution.  If the mangled\n+  name for a particular type depends only on that type's main variant, you\n+  can perform typedef resolution yourself using ``TYPE_MAIN_VARIANT``\n+  before mangling.\n \n+  The default version of this hook always returns ``NULL``, which is\n+  appropriate for a target that does not define any new fundamental\n+  types.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_MANGLE_TYPE]\n-  :end-before: [TARGET_MANGLE_TYPE]\n+.. hook-end\n\\ No newline at end of file"}, {"sha": "72c389d063342c877a9c4d89e2d1cd23e9a0c3e3", "filename": "gcc/doc/gccint/target-macros/support-for-nested-functions.rst", "status": "modified", "additions": 83, "deletions": 15, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fsupport-for-nested-functions.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e070cff11f81051e70b613816075b66a6de61c2/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fsupport-for-nested-functions.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint%2Ftarget-macros%2Fsupport-for-nested-functions.rst?ref=3e070cff11f81051e70b613816075b66a6de61c2", "patch": "@@ -49,10 +49,28 @@ Define the following hook if your backend either implements ABI-specified\n descriptor support, or can use GCC's generic descriptor implementation\n for nested functions.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_CUSTOM_FUNCTION_DESCRIPTORS]\n-  :end-before: [TARGET_CUSTOM_FUNCTION_DESCRIPTORS]\n+.. c:var:: int TARGET_CUSTOM_FUNCTION_DESCRIPTORS\n \n+  .. hook-start:TARGET_CUSTOM_FUNCTION_DESCRIPTORS\n+\n+  If the target can use GCC's generic descriptor mechanism for nested\n+  functions, define this hook to a power of 2 representing an unused bit\n+  in function pointers which can be used to differentiate descriptors at\n+  run time.  This value gives the number of bytes by which descriptor\n+  pointers are misaligned compared to function pointers.  For example, on\n+  targets that require functions to be aligned to a 4-byte boundary, a\n+  value of either 1 or 2 is appropriate unless the architecture already\n+  reserves the bit for another purpose, such as on ARM.\n+\n+  Define this hook to 0 if the target implements ABI support for\n+  function descriptors in its standard calling sequence, like for example\n+  HPPA or IA-64.\n+\n+  Using descriptors for nested functions\n+  eliminates the need for trampolines that reside on the stack and require\n+  it to be made executable.\n+\n+.. hook-end\n \n The following macros tell GCC how to generate code to allocate and\n initialize an executable trampoline.  You can also use this interface\n@@ -76,10 +94,21 @@ proper offset from the start of the trampoline.  On a RISC machine, it\n may be necessary to take out pieces of the address and store them\n separately.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_ASM_TRAMPOLINE_TEMPLATE]\n-  :end-before: [TARGET_ASM_TRAMPOLINE_TEMPLATE]\n+.. function:: void TARGET_ASM_TRAMPOLINE_TEMPLATE (FILE *f)\n \n+  .. hook-start:TARGET_ASM_TRAMPOLINE_TEMPLATE\n+\n+  This hook is called by ``assemble_trampoline_template`` to output,\n+  on the stream :samp:`{f}`, assembler code for a block of data that contains\n+  the constant parts of a trampoline.  This code should not include a\n+  label---the label is taken care of automatically.\n+\n+  If you do not define this hook, it means no template is needed\n+  for the target.  Do not define this hook on systems where the block move\n+  code to copy the trampoline into place would be larger than the code\n+  to generate it on the spot.\n+\n+.. hook-end\n \n .. c:macro:: TRAMPOLINE_SECTION\n \n@@ -97,20 +126,59 @@ separately.\n   If you don't define this macro, the value of ``FUNCTION_ALIGNMENT``\n   is used for aligning trampolines.\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_TRAMPOLINE_INIT]\n-  :end-before: [TARGET_TRAMPOLINE_INIT]\n+.. function:: void TARGET_TRAMPOLINE_INIT (rtx m_tramp, tree fndecl, rtx static_chain)\n+\n+  .. hook-start:TARGET_TRAMPOLINE_INIT\n+\n+  This hook is called to initialize a trampoline.\n+  :samp:`{m_tramp}` is an RTX for the memory block for the trampoline; :samp:`{fndecl}`\n+  is the ``FUNCTION_DECL`` for the nested function; :samp:`{static_chain}` is an\n+  RTX for the static chain value that should be passed to the function\n+  when it is called.\n+\n+  If the target defines ``TARGET_ASM_TRAMPOLINE_TEMPLATE``, then the\n+  first thing this hook should do is emit a block move into :samp:`{m_tramp}`\n+  from the memory block returned by ``assemble_trampoline_template``.\n+  Note that the block move need only cover the constant parts of the\n+  trampoline.  If the target isolates the variable parts of the trampoline\n+  to the end, not all ``TRAMPOLINE_SIZE`` bytes need be copied.\n+\n+  If the target requires any other actions, such as flushing caches\n+  (possibly calling function maybe_emit_call_builtin___clear_cache) or\n+  enabling stack execution, these actions should be performed after\n+  initializing the trampoline proper.\n+\n+.. hook-end\n+\n+.. function:: void TARGET_EMIT_CALL_BUILTIN___CLEAR_CACHE (rtx begin, rtx end)\n+\n+  .. hook-start:TARGET_EMIT_CALL_BUILTIN___CLEAR_CACHE\n+\n+  On targets that do not define a ``clear_cache`` insn expander,\n+  but that define the ``CLEAR_CACHE_INSN`` macro,\n+  maybe_emit_call_builtin___clear_cache relies on this target hook\n+  to clear an address range in the instruction cache.\n+\n+  The default implementation calls the ``__clear_cache`` builtin,\n+  taking the assembler name from the builtin declaration.  Overriding\n+  definitions may call alternate functions, with alternate calling\n+  conventions, or emit alternate RTX to perform the job.\n \n+.. hook-end\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_EMIT_CALL_BUILTIN___CLEAR_CACHE]\n-  :end-before: [TARGET_EMIT_CALL_BUILTIN___CLEAR_CACHE]\n+.. function:: rtx TARGET_TRAMPOLINE_ADJUST_ADDRESS (rtx addr)\n \n+  .. hook-start:TARGET_TRAMPOLINE_ADJUST_ADDRESS\n \n-.. include:: tm.rst.in\n-  :start-after: [TARGET_TRAMPOLINE_ADJUST_ADDRESS]\n-  :end-before: [TARGET_TRAMPOLINE_ADJUST_ADDRESS]\n+  This hook should perform any machine-specific adjustment in\n+  the address of the trampoline.  Its argument contains the address of the\n+  memory block that was passed to ``TARGET_TRAMPOLINE_INIT``.  In case\n+  the address to be used for a function call should be different from the\n+  address at which the template was stored, the different address should\n+  be returned; otherwise :samp:`{addr}` should be returned unchanged.\n+  If this hook is not defined, :samp:`{addr}` will be used for function calls.\n \n+.. hook-end\n \n Implementing trampolines is difficult on many machines because they have\n separate instruction and data caches.  Writing into a stack location"}]}