{"sha": "9413bb55185b9e88d84e91d5145d59f9f83b884a", "node_id": "C_kwDOANBUbNoAKDk0MTNiYjU1MTg1YjllODhkODRlOTFkNTE0NWQ1OWY5ZjgzYjg4NGE", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-03-12T20:00:40Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-03-12T20:00:40Z"}, "message": "c++: return-type-req in constraint using only outer tparms [PR104527]\n\nHere the template context for the atomic constraint has two levels of\ntemplate parameters, but since it depends only on the innermost parameter\nT we use a single-level argument vector (built by get_mapped_args) during\nsubstitution into the atom.  We eventually pass this vector to\ndo_auto_deduction as part of checking the return-type-requirement within\nthe atom, but do_auto_deduction expects outer_targs to be a full set of\narguments for sake of satisfaction.\n\nThis patch fixes this by making get_mapped_args always return an\nargument vector whose depth corresponds to the template depth of the\ncontext in which the atomic constraint expression was written, instead\nof the highest parameter level that the expression happens to use.\n\n\tPR c++/104527\n\ngcc/cp/ChangeLog:\n\n\t* constraint.cc (normalize_atom): Set\n\tATOMIC_CONSTR_EXPR_FROM_CONCEPT_P appropriately.\n\t(get_mapped_args):  Make static, adjust parameters.  Always\n\treturn a vector whose depth corresponds to the template depth of\n\tthe context of the atomic constraint expression.  Micro-optimize\n\tby passing false as exact to safe_grow_cleared and by collapsing\n\ta multi-level depth-one argument vector.\n\t(satisfy_atom): Adjust call to get_mapped_args and\n\tdiagnose_atomic_constraint.\n\t(diagnose_atomic_constraint): Replace map parameter with an args\n\tparameter.\n\t* cp-tree.h (ATOMIC_CONSTR_EXPR_FROM_CONCEPT_P): Define.\n\t(get_mapped_args): Remove declaration.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp2a/concepts-return-req4.C: New test.", "tree": {"sha": "a5495acc5806a95ad66ddfaf09d6d8b023fbc163", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a5495acc5806a95ad66ddfaf09d6d8b023fbc163"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9413bb55185b9e88d84e91d5145d59f9f83b884a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9413bb55185b9e88d84e91d5145d59f9f83b884a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9413bb55185b9e88d84e91d5145d59f9f83b884a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9413bb55185b9e88d84e91d5145d59f9f83b884a/comments", "author": null, "committer": null, "parents": [{"sha": "ab71d3fe4b23af4c29a8d6fcf1e914fed4393e3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab71d3fe4b23af4c29a8d6fcf1e914fed4393e3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab71d3fe4b23af4c29a8d6fcf1e914fed4393e3b"}], "stats": {"total": 101, "additions": 75, "deletions": 26}, "files": [{"sha": "e14578b172112dd74b23b5682f7bf04d56050a66", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 45, "deletions": 25, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9413bb55185b9e88d84e91d5145d59f9f83b884a/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9413bb55185b9e88d84e91d5145d59f9f83b884a/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=9413bb55185b9e88d84e91d5145d59f9f83b884a", "patch": "@@ -764,6 +764,15 @@ normalize_atom (tree t, tree args, norm_info info)\n   tree ci = build_tree_list (t, info.context);\n \n   tree atom = build1 (ATOMIC_CONSTR, ci, map);\n+\n+  /* Remember whether the expression of this atomic constraint belongs to\n+     a concept definition by inspecting in_decl, which should always be set\n+     in this case either by norm_info::update_context (when recursing into a\n+     concept-id during normalization) or by normalize_concept_definition\n+     (when starting out with a concept-id).  */\n+  if (info.in_decl && concept_definition_p (info.in_decl))\n+    ATOMIC_CONSTR_EXPR_FROM_CONCEPT_P (atom) = true;\n+\n   if (!info.generate_diagnostics ())\n     {\n       /* Cache the ATOMIC_CONSTRs that we return, so that sat_hasher::equal\n@@ -2826,33 +2835,37 @@ satisfaction_value (tree t)\n     return boolean_true_node;\n }\n \n-/* Build a new template argument list with template arguments corresponding\n-   to the parameters used in an atomic constraint.  */\n+/* Build a new template argument vector corresponding to the parameter\n+   mapping of the atomic constraint T, using arguments from ARGS.  */\n \n-tree\n-get_mapped_args (tree map)\n+static tree\n+get_mapped_args (tree t, tree args)\n {\n+  tree map = ATOMIC_CONSTR_MAP (t);\n+\n   /* No map, no arguments.  */\n   if (!map)\n     return NULL_TREE;\n \n-  /* Find the mapped parameter with the highest level.  */\n-  int count = 0;\n-  for (tree p = map; p; p = TREE_CHAIN (p))\n-    {\n-      int level;\n-      int index;\n-      template_parm_level_and_index (TREE_VALUE (p), &level, &index);\n-      if (level > count)\n-        count = level;\n-    }\n+  /* Determine the depth of the resulting argument vector.  */\n+  int depth;\n+  if (ATOMIC_CONSTR_EXPR_FROM_CONCEPT_P (t))\n+    /* The expression of this atomic constraint comes from a concept definition,\n+       whose template depth is always one, so the resulting argument vector\n+       will also have depth one.  */\n+    depth = 1;\n+  else\n+    /* Otherwise, the expression of this atomic constraint comes from\n+       the context of the constrained entity, whose template depth is that\n+       of ARGS.  */\n+    depth = TMPL_ARGS_DEPTH (args);\n \n   /* Place each argument at its corresponding position in the argument\n      list. Note that the list will be sparse (not all arguments supplied),\n      but instantiation is guaranteed to only use the parameters in the\n      mapping, so null arguments would never be used.  */\n-  auto_vec< vec<tree> > lists (count);\n-  lists.quick_grow_cleared (count);\n+  auto_vec< vec<tree> > lists (depth);\n+  lists.quick_grow_cleared (depth);\n   for (tree p = map; p; p = TREE_CHAIN (p))\n     {\n       int level;\n@@ -2862,12 +2875,12 @@ get_mapped_args (tree map)\n       /* Insert the argument into its corresponding position.  */\n       vec<tree> &list = lists[level - 1];\n       if (index >= (int)list.length ())\n-\tlist.safe_grow_cleared (index + 1, true);\n+\tlist.safe_grow_cleared (index + 1, /*exact=*/false);\n       list[index] = TREE_PURPOSE (p);\n     }\n \n   /* Build the new argument list.  */\n-  tree args = make_tree_vec (lists.length ());\n+  args = make_tree_vec (lists.length ());\n   for (unsigned i = 0; i != lists.length (); ++i)\n     {\n       vec<tree> &list = lists[i];\n@@ -2879,6 +2892,15 @@ get_mapped_args (tree map)\n     }\n   SET_NON_DEFAULT_TEMPLATE_ARGS_COUNT (args, 0);\n \n+  if (TMPL_ARGS_HAVE_MULTIPLE_LEVELS (args)\n+      && TMPL_ARGS_DEPTH (args) == 1)\n+    {\n+      /* Get rid of the redundant outer TREE_VEC.  */\n+      tree level = TMPL_ARGS_LEVEL (args, 1);\n+      ggc_free (args);\n+      args = level;\n+    }\n+\n   return args;\n }\n \n@@ -2933,7 +2955,7 @@ satisfy_atom (tree t, tree args, sat_info info)\n     }\n \n   /* Rebuild the argument vector from the parameter mapping.  */\n-  args = get_mapped_args (map);\n+  args = get_mapped_args (t, args);\n \n   /* Apply the parameter mapping (i.e., just substitute).  */\n   tree expr = ATOMIC_CONSTR_EXPR (t);\n@@ -2955,7 +2977,7 @@ satisfy_atom (tree t, tree args, sat_info info)\n   if (!same_type_p (TREE_TYPE (result), boolean_type_node))\n     {\n       if (info.noisy ())\n-\tdiagnose_atomic_constraint (t, map, result, info);\n+\tdiagnose_atomic_constraint (t, args, result, info);\n       return cache.save (inst_cache.save (error_mark_node));\n     }\n \n@@ -2974,7 +2996,7 @@ satisfy_atom (tree t, tree args, sat_info info)\n     }\n   result = satisfaction_value (result);\n   if (result == boolean_false_node && info.diagnose_unsatisfaction_p ())\n-    diagnose_atomic_constraint (t, map, result, info);\n+    diagnose_atomic_constraint (t, args, result, info);\n \n   return cache.save (inst_cache.save (result));\n }\n@@ -3642,11 +3664,10 @@ diagnose_trait_expr (tree expr, tree args)\n     }\n }\n \n-/* Diagnose a substitution failure in the atomic constraint T when applied\n-   with the instantiated parameter mapping MAP.  */\n+/* Diagnose a substitution failure in the atomic constraint T using ARGS.  */\n \n static void\n-diagnose_atomic_constraint (tree t, tree map, tree result, sat_info info)\n+diagnose_atomic_constraint (tree t, tree args, tree result, sat_info info)\n {\n   /* If the constraint is already ill-formed, we've previously diagnosed\n      the reason. We should still say why the constraints aren't satisfied.  */\n@@ -3667,7 +3688,6 @@ diagnose_atomic_constraint (tree t, tree map, tree result, sat_info info)\n   /* Generate better diagnostics for certain kinds of expressions.  */\n   tree expr = ATOMIC_CONSTR_EXPR (t);\n   STRIP_ANY_LOCATION_WRAPPER (expr);\n-  tree args = get_mapped_args (map);\n   switch (TREE_CODE (expr))\n     {\n     case TRAIT_EXPR:"}, {"sha": "02054142cb13979862f828ac8c1fc59b2c913d63", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9413bb55185b9e88d84e91d5145d59f9f83b884a/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9413bb55185b9e88d84e91d5145d59f9f83b884a/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=9413bb55185b9e88d84e91d5145d59f9f83b884a", "patch": "@@ -466,6 +466,7 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n       IMPLICIT_CONV_EXPR_NONTYPE_ARG (in IMPLICIT_CONV_EXPR)\n       BASELINK_FUNCTIONS_MAYBE_INCOMPLETE_P (in BASELINK)\n       BIND_EXPR_VEC_DTOR (in BIND_EXPR)\n+      ATOMIC_CONSTR_EXPR_FROM_CONCEPT_P (in ATOMIC_CONSTR)\n    2: IDENTIFIER_KIND_BIT_2 (in IDENTIFIER_NODE)\n       ICS_THIS_FLAG (in _CONV)\n       DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (in VAR_DECL)\n@@ -1679,6 +1680,11 @@ check_constraint_info (tree t)\n #define ATOMIC_CONSTR_MAP_INSTANTIATED_P(NODE) \\\n   TREE_LANG_FLAG_0 (ATOMIC_CONSTR_CHECK (NODE))\n \n+/* Whether the expression for this atomic constraint belongs to a\n+   concept definition.  */\n+#define ATOMIC_CONSTR_EXPR_FROM_CONCEPT_P(NODE) \\\n+  TREE_LANG_FLAG_1 (ATOMIC_CONSTR_CHECK (NODE))\n+\n /* The expression of an atomic constraint. */\n #define ATOMIC_CONSTR_EXPR(NODE) \\\n   CONSTR_EXPR (ATOMIC_CONSTR_CHECK (NODE))\n@@ -8315,7 +8321,6 @@ extern tree evaluate_requires_expr\t\t(tree);\n extern tree tsubst_constraint                   (tree, tree, tsubst_flags_t, tree);\n extern tree tsubst_constraint_info              (tree, tree, tsubst_flags_t, tree);\n extern tree tsubst_parameter_mapping\t\t(tree, tree, tsubst_flags_t, tree);\n-extern tree get_mapped_args\t\t\t(tree);\n \n struct processing_constraint_expression_sentinel\n {"}, {"sha": "471946bc8eb001db7a50a2885a74742acbea90ab", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-return-req4.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9413bb55185b9e88d84e91d5145d59f9f83b884a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-return-req4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9413bb55185b9e88d84e91d5145d59f9f83b884a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-return-req4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-return-req4.C?ref=9413bb55185b9e88d84e91d5145d59f9f83b884a", "patch": "@@ -0,0 +1,24 @@\n+// PR c++/104527\n+// { dg-do compile { target c++20 } }\n+\n+template<class T, class U>\n+concept is_same = __is_same(T, U);\n+\n+template<class T>\n+struct A {\n+  template<class...>\n+    requires requires { { 0 } -> is_same<T>; }\n+  struct B {};\n+\n+  template<class...>\n+    requires requires { { 1 } -> is_same<T>; }\n+  static void f();\n+};\n+\n+A<int>::B<> a1;\n+A<bool>::B<> a2; // { dg-error \"constraint\" }\n+\n+int main() {\n+  A<int>::f();\n+  A<bool>::f(); // { dg-error \"no match\" }\n+}"}]}