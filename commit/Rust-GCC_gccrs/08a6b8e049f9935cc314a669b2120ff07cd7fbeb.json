{"sha": "08a6b8e049f9935cc314a669b2120ff07cd7fbeb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDhhNmI4ZTA0OWY5OTM1Y2MzMTRhNjY5YjIxMjBmZjA3Y2Q3ZmJlYg==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2009-06-28T17:56:41Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2009-06-28T17:56:41Z"}, "message": "re PR fortran/34112 (Add $!DEC ATTRIBUTE support for 32bit Windows' STDCALL)\n\n2009-06-28  Tobias Burnus  <burnus@net-b.de>\n\t    Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n\n\tPR fortran/34112\n\t* symbol.c (gfc_add_ext_attribute): New function.\n\t(gfc_get_sym_tree): New argument allow_subroutine.\n\t(gfc_get_symbol,gfc_get_ha_sym_tree,gen_cptr_param,gen_fptr_param\n\tgen_shape_param,generate_isocbinding_symbol): Use it.\n\t* decl.c (find_special): New argument allow_subroutine.\n\t(add_init_expr_to_sym,add_hidden_procptr_result,attr_decl1,\n\tmatch_procedure_in_type,gfc_match_final_decl): Use it.\n\t(gfc_match_gcc_attributes): New function.\n\t* gfortran.texi (Mixed-Language Programming): New section\n\t\"GNU Fortran Compiler Directives\".\n\t* gfortran.h (ext_attr_t): New struct.\n\t(symbol_attributes): Use it.\n\t(gfc_add_ext_attribute): New prototype.\n\t(gfc_get_sym_tree): Update pototype.\n\t* expr.c (gfc_check_pointer_assign): Check whether call\n\tconvention is the same.\n\t* module.c (import_iso_c_binding_module, create_int_parameter,\n\tuse_iso_fortran_env_module): Update gfc_get_sym_tree call.\n\t* scanner.c (skip_gcc_attribute): New function.\n\t(skip_free_comments,skip_fixed_comments): Use it.\n\t(gfc_next_char_literal): Support !GCC$ lines.\n\t* resolve.c (check_host_association): Update\n\tgfc_get_sym_tree call.\n\t* match.c (gfc_match_sym_tree,gfc_match_call): Update\n\tgfc_get_sym_tree call.\n\t* trans-decl.c (add_attributes_to_decl): New function.\n\t(gfc_get_symbol_decl,get_proc_pointer_decl,\n\tgfc_get_extern_function_decl,build_function_decl: Use it.\n\t* match.h (gfc_match_gcc_attributes): Add prototype.\n\t* parse.c (decode_gcc_attribute): New function.\n\t(next_free,next_fixed): Support !GCC$ lines.\n\t* primary.c (match_actual_arg,check_for_implicit_index,\n\tgfc_match_rvalue,gfc_match_rvalue): Update\n\tgfc_get_sym_tree call.\n\n2009-06-28  Tobias Burnus  <burnus@net-b.de>\n\n\tPR fortran/34112\n\t* gfortran.dg/compiler-directive_1.f90: New test.\n\t* gfortran.dg/compiler-directive_2.f: New test.\n\n\nCo-Authored-By: Francois-Xavier Coudert <fxcoudert@gcc.gnu.org>\n\nFrom-SVN: r149036", "tree": {"sha": "49b09d2f1e0cfee1a1f1901ff04e9da4c8a351d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/49b09d2f1e0cfee1a1f1901ff04e9da4c8a351d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08a6b8e049f9935cc314a669b2120ff07cd7fbeb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08a6b8e049f9935cc314a669b2120ff07cd7fbeb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08a6b8e049f9935cc314a669b2120ff07cd7fbeb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08a6b8e049f9935cc314a669b2120ff07cd7fbeb/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0948ccb243a5b2244bef375addc6f1a4b3a2f526", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0948ccb243a5b2244bef375addc6f1a4b3a2f526", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0948ccb243a5b2244bef375addc6f1a4b3a2f526"}], "stats": {"total": 550, "additions": 507, "deletions": 43}, "files": [{"sha": "3357fde67902d2d47e3bf9833bb60024d90d388f", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a6b8e049f9935cc314a669b2120ff07cd7fbeb/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a6b8e049f9935cc314a669b2120ff07cd7fbeb/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=08a6b8e049f9935cc314a669b2120ff07cd7fbeb", "patch": "@@ -1,3 +1,42 @@\n+2009-06-28  Tobias Burnus  <burnus@net-b.de>\n+\t    Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\tPR fortran/34112\n+\t* symbol.c (gfc_add_ext_attribute): New function.\n+\t(gfc_get_sym_tree): New argument allow_subroutine.\n+\t(gfc_get_symbol,gfc_get_ha_sym_tree,gen_cptr_param,gen_fptr_param\n+\tgen_shape_param,generate_isocbinding_symbol): Use it.\n+\t* decl.c (find_special): New argument allow_subroutine.\n+\t(add_init_expr_to_sym,add_hidden_procptr_result,attr_decl1,\n+\tmatch_procedure_in_type,gfc_match_final_decl): Use it.\n+\t(gfc_match_gcc_attributes): New function.\n+\t* gfortran.texi (Mixed-Language Programming): New section\n+\t\"GNU Fortran Compiler Directives\".\n+\t* gfortran.h (ext_attr_t): New struct.\n+\t(symbol_attributes): Use it.\n+\t(gfc_add_ext_attribute): New prototype.\n+\t(gfc_get_sym_tree): Update pototype.\n+\t* expr.c (gfc_check_pointer_assign): Check whether call\n+\tconvention is the same.\n+\t* module.c (import_iso_c_binding_module, create_int_parameter,\n+\tuse_iso_fortran_env_module): Update gfc_get_sym_tree call.\n+\t* scanner.c (skip_gcc_attribute): New function.\n+\t(skip_free_comments,skip_fixed_comments): Use it.\n+\t(gfc_next_char_literal): Support !GCC$ lines.\n+\t* resolve.c (check_host_association): Update\n+\tgfc_get_sym_tree call.\n+\t* match.c (gfc_match_sym_tree,gfc_match_call): Update\n+\tgfc_get_sym_tree call.\n+\t* trans-decl.c (add_attributes_to_decl): New function.\n+\t(gfc_get_symbol_decl,get_proc_pointer_decl,\n+\tgfc_get_extern_function_decl,build_function_decl: Use it.\n+\t* match.h (gfc_match_gcc_attributes): Add prototype.\n+\t* parse.c (decode_gcc_attribute): New function.\n+\t(next_free,next_fixed): Support !GCC$ lines.\n+\t* primary.c (match_actual_arg,check_for_implicit_index,\n+\tgfc_match_rvalue,gfc_match_rvalue): Update\n+\tgfc_get_sym_tree call.\n+\n 2009-06-28  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* gfortran.h: Define HAVE_mpc_pow."}, {"sha": "c3760a81c0b27dda472b5e125409c1783314c310", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 110, "deletions": 8, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a6b8e049f9935cc314a669b2120ff07cd7fbeb/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a6b8e049f9935cc314a669b2120ff07cd7fbeb/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=08a6b8e049f9935cc314a669b2120ff07cd7fbeb", "patch": "@@ -696,14 +696,18 @@ match_char_length (gfc_expr **expr)\n    (located in another namespace).  */\n \n static int\n-find_special (const char *name, gfc_symbol **result)\n+find_special (const char *name, gfc_symbol **result, bool allow_subroutine)\n {\n   gfc_state_data *s;\n+  gfc_symtree *st;\n   int i;\n \n-  i = gfc_get_symbol (name, NULL, result);\n+  i = gfc_get_sym_tree (name, NULL, &st, allow_subroutine);\n   if (i == 0)\n-    goto end;\n+    {\n+      *result = st ? st->n.sym : NULL;\n+      goto end;\n+    }\n \n   if (gfc_current_state () != COMP_SUBROUTINE\n       && gfc_current_state () != COMP_FUNCTION)\n@@ -1204,7 +1208,7 @@ add_init_expr_to_sym (const char *name, gfc_expr **initp, locus *var_locus)\n   gfc_expr *init;\n \n   init = *initp;\n-  if (find_special (name, &sym))\n+  if (find_special (name, &sym, false))\n     return FAILURE;\n \n   attr = sym->attr;\n@@ -4103,11 +4107,11 @@ add_hidden_procptr_result (gfc_symbol *sym)\n     {\n       gfc_symtree *stree;\n       if (case1)\n-\tgfc_get_sym_tree (\"ppr@\", gfc_current_ns, &stree);\n+\tgfc_get_sym_tree (\"ppr@\", gfc_current_ns, &stree, false);\n       else if (case2)\n \t{\n \t  gfc_symtree *st2;\n-\t  gfc_get_sym_tree (\"ppr@\", gfc_current_ns->parent, &stree);\n+\t  gfc_get_sym_tree (\"ppr@\", gfc_current_ns->parent, &stree, false);\n \t  st2 = gfc_new_symtree (&gfc_current_ns->sym_root, \"ppr@\");\n \t  st2->n.sym = stree->n.sym;\n \t}\n@@ -5539,7 +5543,7 @@ attr_decl1 (void)\n   if (m != MATCH_YES)\n     goto cleanup;\n \n-  if (find_special (name, &sym))\n+  if (find_special (name, &sym, false))\n     return MATCH_ERROR;\n \n   var_locus = gfc_current_locus;\n@@ -7375,7 +7379,7 @@ match_procedure_in_type (void)\n     }\n   stree->n.tb = tb;\n \n-  if (gfc_get_sym_tree (target, gfc_current_ns, &tb->u.specific))\n+  if (gfc_get_sym_tree (target, gfc_current_ns, &tb->u.specific, false))\n     return MATCH_ERROR;\n   gfc_set_sym_referenced (tb->u.specific->n.sym);\n \n@@ -7618,3 +7622,101 @@ gfc_match_final_decl (void)\n \n   return MATCH_YES;\n }\n+\n+\n+const ext_attr_t ext_attr_list[] = {\n+  { \"dllimport\", EXT_ATTR_DLLIMPORT, \"dllimport\" },\n+  { \"dllexport\", EXT_ATTR_DLLEXPORT, \"dllexport\" },\n+  { \"cdecl\",     EXT_ATTR_CDECL,     \"cdecl\"     },\n+  { \"stdcall\",   EXT_ATTR_STDCALL,   \"stdcall\"   },\n+  { \"fastcall\",  EXT_ATTR_FASTCALL,  \"fastcall\"  },\n+  { NULL,        EXT_ATTR_LAST,      NULL        }\n+};\n+\n+/* Match a !GCC$ ATTRIBUTES statement of the form:\n+      !GCC$ ATTRIBUTES attribute-list :: var-name [, var-name] ...\n+   When we come here, we have already matched the !GCC$ ATTRIBUTES string.\n+\n+   TODO: We should support all GCC attributes using the same syntax for\n+   the attribute list, i.e. the list in C\n+      __attributes(( attribute-list ))\n+   matches then\n+      !GCC$ ATTRIBUTES attribute-list ::\n+   Cf. c-parser.c's c_parser_attributes; the data can then directly be\n+   saved into a TREE.\n+\n+   As there is absolutely no risk of confusion, we should never return\n+   MATCH_NO.  */\n+match\n+gfc_match_gcc_attributes (void)\n+{ \n+  symbol_attribute attr;\n+  char name[GFC_MAX_SYMBOL_LEN + 1];\n+  unsigned id;\n+  gfc_symbol *sym;\n+  match m;\n+\n+  gfc_clear_attr (&attr);\n+  for(;;)\n+    {\n+      char ch;\n+\n+      if (gfc_match_name (name) != MATCH_YES)\n+\treturn MATCH_ERROR;\n+\n+      for (id = 0; id < EXT_ATTR_LAST; id++)\n+\tif (strcmp (name, ext_attr_list[id].name) == 0)\n+\t  break;\n+\n+      if (id == EXT_ATTR_LAST)\n+\t{\n+\t  gfc_error (\"Unknown attribute in !GCC$ ATTRIBUTES statement at %C\");\n+\t  return MATCH_ERROR;\n+\t}\n+\n+      if (gfc_add_ext_attribute (&attr, id, &gfc_current_locus)\n+\t  == FAILURE)\n+\treturn MATCH_ERROR;\n+\n+      gfc_gobble_whitespace ();\n+      ch = gfc_next_ascii_char ();\n+      if (ch == ':')\n+        {\n+          /* This is the successful exit condition for the loop.  */\n+          if (gfc_next_ascii_char () == ':')\n+            break;\n+        }\n+\n+      if (ch == ',')\n+\tcontinue;\n+\n+      goto syntax;\n+    }\n+\n+  if (gfc_match_eos () == MATCH_YES)\n+    goto syntax;\n+\n+  for(;;)\n+    {\n+      m = gfc_match_name (name);\n+      if (m != MATCH_YES)\n+\treturn m;\n+\n+      if (find_special (name, &sym, true))\n+\treturn MATCH_ERROR;\n+      \n+      sym->attr.ext_attr |= attr.ext_attr;\n+\n+      if (gfc_match_eos () == MATCH_YES)\n+\tbreak;\n+\n+      if (gfc_match_char (',') != MATCH_YES)\n+\tgoto syntax;\n+    }\n+\n+  return MATCH_YES;\n+\n+syntax:\n+  gfc_error (\"Syntax error in !GCC$ ATTRIBUTES statement at %C\");\n+  return MATCH_ERROR;\n+}"}, {"sha": "b1d572ec2319d5cd4cb14677da8dd570abc2378b", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a6b8e049f9935cc314a669b2120ff07cd7fbeb/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a6b8e049f9935cc314a669b2120ff07cd7fbeb/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=08a6b8e049f9935cc314a669b2120ff07cd7fbeb", "patch": "@@ -3186,6 +3186,32 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n \t\t\t      rvalue->symtree->name, &rvalue->where) == FAILURE)\n \t    return FAILURE;\n \t}\n+\n+      /* Ensure that the calling convention is the same. As other attributes\n+\t such as DLLEXPORT may differ, one explicitly only tests for the\n+\t calling conventions.  */\n+      if (rvalue->expr_type == EXPR_VARIABLE\n+\t  && lvalue->symtree->n.sym->attr.ext_attr\n+\t       != rvalue->symtree->n.sym->attr.ext_attr)\n+\t{\n+\t  symbol_attribute cdecl, stdcall, fastcall;\n+\t  unsigned calls;\n+\n+\t  gfc_add_ext_attribute (&cdecl, (unsigned) EXT_ATTR_CDECL, NULL);\n+\t  gfc_add_ext_attribute (&stdcall, (unsigned) EXT_ATTR_STDCALL, NULL);\n+\t  gfc_add_ext_attribute (&fastcall, (unsigned) EXT_ATTR_FASTCALL, NULL);\n+\t  calls = cdecl.ext_attr | stdcall.ext_attr | fastcall.ext_attr;\n+\n+\t  if ((calls & lvalue->symtree->n.sym->attr.ext_attr)\n+\t      != (calls & rvalue->symtree->n.sym->attr.ext_attr))\n+\t    {\n+\t      gfc_error (\"Mismatch in the procedure pointer assignment \"\n+\t\t\t \"at %L: mismatch in the calling convention\",\n+\t\t\t &rvalue->where);\n+\t  return FAILURE;\n+\t    }\n+\t}\n+\n       /* TODO: Enable interface check for PPCs.  */\n       if (is_proc_ptr_comp (rvalue, NULL))\n \treturn SUCCESS;"}, {"sha": "67127419b007fc5cdd2652c9c39471a951073781", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a6b8e049f9935cc314a669b2120ff07cd7fbeb/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a6b8e049f9935cc314a669b2120ff07cd7fbeb/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=08a6b8e049f9935cc314a669b2120ff07cd7fbeb", "patch": "@@ -619,6 +619,28 @@ CInteropKind_t;\n    that the list is initialized.  */\n extern CInteropKind_t c_interop_kinds_table[];\n \n+\n+/* Structure and list of supported extension attributes.  */\n+enum\n+{\n+  EXT_ATTR_DLLIMPORT = 0,\n+  EXT_ATTR_DLLEXPORT,\n+  EXT_ATTR_STDCALL,\n+  EXT_ATTR_CDECL,\n+  EXT_ATTR_FASTCALL,\n+  EXT_ATTR_LAST, EXT_ATTR_NUM = EXT_ATTR_LAST\n+};\n+\n+typedef struct\n+{\n+  const char *name;\n+  unsigned id;\n+  const char *middle_end_name;\n+}\n+ext_attr_t;\n+\n+extern const ext_attr_t ext_attr_list[];\n+\n /* Symbol attribute structure.  */\n typedef struct\n {\n@@ -704,6 +726,9 @@ typedef struct\n   unsigned alloc_comp:1, pointer_comp:1, proc_pointer_comp:1,\n \t   private_comp:1, zero_comp:1;\n \n+  /* Attributes set by compiler extensions (!GCC$ ATTRIBUTES).  */\n+  unsigned ext_attr:EXT_ATTR_NUM;\n+\n   /* The namespace where the VOLATILE attribute has been set.  */\n   struct gfc_namespace *volatile_ns;\n }\n@@ -2299,6 +2324,7 @@ gfc_try gfc_set_default_type (gfc_symbol *, int, gfc_namespace *);\n void gfc_set_sym_referenced (gfc_symbol *);\n \n gfc_try gfc_add_attribute (symbol_attribute *, locus *);\n+gfc_try gfc_add_ext_attribute (symbol_attribute *, unsigned, locus *);\n gfc_try gfc_add_allocatable (symbol_attribute *, locus *);\n gfc_try gfc_add_dimension (symbol_attribute *, const char *, locus *);\n gfc_try gfc_add_external (symbol_attribute *, locus *);\n@@ -2379,7 +2405,7 @@ gfc_try verify_bind_c_derived_type (gfc_symbol *);\n gfc_try verify_com_block_vars_c_interop (gfc_common_head *);\n void generate_isocbinding_symbol (const char *, iso_c_binding_symbol, const char *);\n gfc_symbol *get_iso_c_sym (gfc_symbol *, char *, char *, int);\n-int gfc_get_sym_tree (const char *, gfc_namespace *, gfc_symtree **);\n+int gfc_get_sym_tree (const char *, gfc_namespace *, gfc_symtree **, bool);\n int gfc_get_ha_symbol (const char *, gfc_symbol **);\n int gfc_get_ha_sym_tree (const char *, gfc_symtree **);\n "}, {"sha": "f0b1c675922733fc3ee88b4126067c5e29b31bf5", "filename": "gcc/fortran/gfortran.texi", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a6b8e049f9935cc314a669b2120ff07cd7fbeb/gcc%2Ffortran%2Fgfortran.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a6b8e049f9935cc314a669b2120ff07cd7fbeb/gcc%2Ffortran%2Fgfortran.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.texi?ref=08a6b8e049f9935cc314a669b2120ff07cd7fbeb", "patch": "@@ -1851,6 +1851,7 @@ c\n \n @menu\n * Interoperability with C::\n+* GNU Fortran Compiler Directives::\n * Non-Fortran Main Program::\n @end menu\n \n@@ -2097,6 +2098,60 @@ C-interoperable @code{OPTIONAL} and for assumed-rank and assumed-type\n dummy arguments. However, the TR has neither been approved nor implemented\n in GNU Fortran; therefore, these features are not yet available.\n \n+\n+\n+@node GNU Fortran Compiler Directives\n+@section GNU Fortran Compiler Directives\n+\n+The Fortran standard standard describes how a conforming program shall\n+behave; however, the exact implementation is not standardized. In order\n+to allow the user to choose specific implementation details, compiler\n+directives can be used to set attributes of variables and procedures\n+which are not part of the standard. Whether a given attribute is\n+supported and its exact effects depend on both the operating system and\n+on the processor; see\n+@ref{Top,,C Extensions,gcc,Using the GNU Compiler Collection (GCC)}\n+for details.\n+\n+For procedures and procedure pointers, the following attributes can\n+be used to change the calling convention:\n+\n+@itemize\n+@item @code{CDECL} -- standard C calling convention\n+@item @code{STDCALL} -- convention where the called procedure pops the stack\n+@item @code{FASTCALL} -- part of the arguments are passed via registers\n+instead using the stack\n+@end itemize\n+\n+Besides changing the calling convention, the attributes also influence\n+the decoration of the symbol name, e.g., by a leading underscore or by\n+a trailing at-sign followed by the number of bytes on the stack. When\n+assigning a procedure to a procedure pointer, both should use the same\n+calling convention.\n+\n+On some systems, procedures and global variables (module variables and\n+@code{COMMON} blocks) need special handling to be accessible when they\n+are in a shared library. The following attributes are available:\n+\n+@itemize\n+@item @code{DLLEXPORT} -- provide a global pointer to a pointer in the DLL\n+@item @code{DLLIMPORT} -- reference the function or variable using a global pointer \n+@end itemize\n+\n+The attributes are specified using the syntax\n+\n+@code{!GCC$ ATTRIBUTES} @var{attribute-list} @code{::} @var{variable-list}\n+\n+where in free-form source code only whitespace is allowed before @code{!GCC$}\n+and in fixed-form source code @code{!GCC$}, @code{cGCC$} or @code{*GCC$} shall\n+start in the first column.\n+\n+For procedures, the compiler directives shall be placed into the body\n+of the procedure; for variables and procedure pointers, they shall be in\n+the same declaration part as the variable or procedure pointer.\n+\n+\n+\n @node Non-Fortran Main Program\n @section Non-Fortran Main Program\n "}, {"sha": "1cc6e5fdfa20b78fe5acfb68f2f11f52d9c96746", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a6b8e049f9935cc314a669b2120ff07cd7fbeb/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a6b8e049f9935cc314a669b2120ff07cd7fbeb/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=08a6b8e049f9935cc314a669b2120ff07cd7fbeb", "patch": "@@ -674,7 +674,7 @@ gfc_match_sym_tree (gfc_symtree **matched_symbol, int host_assoc)\n     return (gfc_get_ha_sym_tree (buffer, matched_symbol))\n \t    ? MATCH_ERROR : MATCH_YES;\n \n-  if (gfc_get_sym_tree (buffer, NULL, matched_symbol))\n+  if (gfc_get_sym_tree (buffer, NULL, matched_symbol, false))\n     return MATCH_ERROR;\n \n   return MATCH_YES;\n@@ -2711,7 +2711,7 @@ gfc_match_call (void)\n \t{\n \t  /* ...create a symbol in this scope...  */\n \t  if (sym->ns != gfc_current_ns\n-\t        && gfc_get_sym_tree (name, NULL, &st) == 1)\n+\t        && gfc_get_sym_tree (name, NULL, &st, false) == 1)\n             return MATCH_ERROR;\n \n \t  if (sym != st->n.sym)"}, {"sha": "b6c092416935e8b2fc44a0abb769ede0ae6c2b83", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a6b8e049f9935cc314a669b2120ff07cd7fbeb/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a6b8e049f9935cc314a669b2120ff07cd7fbeb/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=08a6b8e049f9935cc314a669b2120ff07cd7fbeb", "patch": "@@ -160,6 +160,7 @@ void gfc_set_constant_character_len (int, gfc_expr *, int);\n match gfc_match_allocatable (void);\n match gfc_match_dimension (void);\n match gfc_match_external (void);\n+match gfc_match_gcc_attributes (void);\n match gfc_match_import (void);\n match gfc_match_intent (void);\n match gfc_match_intrinsic (void);"}, {"sha": "7e6e8ff93c4dc38dc499ad2f3fa4a0117a1e8e1f", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a6b8e049f9935cc314a669b2120ff07cd7fbeb/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a6b8e049f9935cc314a669b2120ff07cd7fbeb/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=08a6b8e049f9935cc314a669b2120ff07cd7fbeb", "patch": "@@ -5006,7 +5006,8 @@ import_iso_c_binding_module (void)\n   if (mod_symtree == NULL)\n     {\n       /* symtree doesn't already exist in current namespace.  */\n-      gfc_get_sym_tree (iso_c_module_name, gfc_current_ns, &mod_symtree);\n+      gfc_get_sym_tree (iso_c_module_name, gfc_current_ns, &mod_symtree,\n+\t\t\tfalse);\n       \n       if (mod_symtree != NULL)\n \tmod_sym = mod_symtree->n.sym;\n@@ -5094,7 +5095,7 @@ create_int_parameter (const char *name, int value, const char *modname,\n \tgfc_error (\"Symbol '%s' already declared\", name);\n     }\n \n-  gfc_get_sym_tree (name, gfc_current_ns, &tmp_symtree);\n+  gfc_get_sym_tree (name, gfc_current_ns, &tmp_symtree, false);\n   sym = tmp_symtree->n.sym;\n \n   sym->module = gfc_get_string (modname);\n@@ -5135,7 +5136,7 @@ use_iso_fortran_env_module (void)\n   mod_symtree = gfc_find_symtree (gfc_current_ns->sym_root, mod);\n   if (mod_symtree == NULL)\n     {\n-      gfc_get_sym_tree (mod, gfc_current_ns, &mod_symtree);\n+      gfc_get_sym_tree (mod, gfc_current_ns, &mod_symtree, false);\n       gcc_assert (mod_symtree);\n       mod_sym = mod_symtree->n.sym;\n "}, {"sha": "da16c2b570fd63a52a57236799e96a4cbb5e84c5", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 65, "deletions": 9, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a6b8e049f9935cc314a669b2120ff07cd7fbeb/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a6b8e049f9935cc314a669b2120ff07cd7fbeb/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=08a6b8e049f9935cc314a669b2120ff07cd7fbeb", "patch": "@@ -566,6 +566,34 @@ decode_omp_directive (void)\n   return ST_NONE;\n }\n \n+static gfc_statement\n+decode_gcc_attribute (void)\n+{\n+  locus old_locus;\n+\n+#ifdef GFC_DEBUG\n+  gfc_symbol_state ();\n+#endif\n+\n+  gfc_clear_error ();\t/* Clear any pending errors.  */\n+  gfc_clear_warning ();\t/* Clear any pending warnings.  */\n+  old_locus = gfc_current_locus;\n+\n+  match (\"attributes\", gfc_match_gcc_attributes, ST_ATTR_DECL);\n+\n+  /* All else has failed, so give up.  See if any of the matchers has\n+     stored an error message of some sort.  */\n+\n+  if (gfc_error_check () == 0)\n+    gfc_error_now (\"Unclassifiable GCC directive at %C\");\n+\n+  reject_statement ();\n+\n+  gfc_error_recovery ();\n+\n+  return ST_NONE;\n+}\n+\n #undef match\n \n \n@@ -637,21 +665,39 @@ next_free (void)\n   else if (c == '!')\n     {\n       /* Comments have already been skipped by the time we get here,\n-\t except for OpenMP directives.  */\n-      if (gfc_option.flag_openmp)\n+\t except for GCC attributes and OpenMP directives.  */\n+\n+      gfc_next_ascii_char (); /* Eat up the exclamation sign.  */\n+      c = gfc_peek_ascii_char ();\n+\n+      if (c == 'g')\n \t{\n \t  int i;\n \n \t  c = gfc_next_ascii_char ();\n-\t  for (i = 0; i < 5; i++, c = gfc_next_ascii_char ())\n-\t    gcc_assert (c == \"!$omp\"[i]);\n+\t  for (i = 0; i < 4; i++, c = gfc_next_ascii_char ())\n+\t    gcc_assert (c == \"gcc$\"[i]);\n+\n+\t  gfc_gobble_whitespace ();\n+\t  return decode_gcc_attribute ();\n+\n+\t}\n+      else if (c == '$' && gfc_option.flag_openmp)\n+\t{\n+\t  int i;\n+\n+\t  c = gfc_next_ascii_char ();\n+\t  for (i = 0; i < 4; i++, c = gfc_next_ascii_char ())\n+\t    gcc_assert (c == \"$omp\"[i]);\n \n \t  gcc_assert (c == ' ' || c == '\\t');\n \t  gfc_gobble_whitespace ();\n \t  return decode_omp_directive ();\n \t}\n-    }\n \n+      gcc_unreachable (); \n+    }\n+ \n   if (at_bol && c == ';')\n     {\n       gfc_error_now (\"Semicolon at %C needs to be preceded by statement\");\n@@ -709,12 +755,22 @@ next_fixed (void)\n \t  break;\n \n \t  /* Comments have already been skipped by the time we get\n-\t     here, except for OpenMP directives.  */\n+\t     here, except for GCC attributes and OpenMP directives.  */\n+\n \tcase '*':\n-\t  if (gfc_option.flag_openmp)\n+\t  c = gfc_next_char_literal (0);\n+\t  \n+\t  if (TOLOWER (c) == 'g')\n+\t    {\n+\t      for (i = 0; i < 4; i++, c = gfc_next_char_literal (0))\n+\t\tgcc_assert (TOLOWER (c) == \"gcc$\"[i]);\n+\n+\t      return decode_gcc_attribute ();\n+\t    }\n+\t  else if (c == '$' && gfc_option.flag_openmp)\n \t    {\n-\t      for (i = 0; i < 5; i++, c = gfc_next_char_literal (0))\n-\t\tgcc_assert ((char) gfc_wide_tolower (c) == \"*$omp\"[i]);\n+\t      for (i = 0; i < 4; i++, c = gfc_next_char_literal (0))\n+\t\tgcc_assert ((char) gfc_wide_tolower (c) == \"$omp\"[i]);\n \n \t      if (c != ' ' && c != '0')\n \t\t{"}, {"sha": "cc6cada545c15fde0ff310a60a2f9daee3682754", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a6b8e049f9935cc314a669b2120ff07cd7fbeb/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a6b8e049f9935cc314a669b2120ff07cd7fbeb/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=08a6b8e049f9935cc314a669b2120ff07cd7fbeb", "patch": "@@ -1388,7 +1388,7 @@ match_actual_arg (gfc_expr **result)\n \t have a function argument.  */\n       if (symtree == NULL)\n \t{\n-\t  gfc_get_sym_tree (name, NULL, &symtree);\n+\t  gfc_get_sym_tree (name, NULL, &symtree, false);\n \t  gfc_set_sym_referenced (symtree->n.sym);\n \t}\n       else\n@@ -2365,7 +2365,7 @@ check_for_implicit_index (gfc_symtree **st, gfc_symbol **sym)\n       && !(*sym)->attr.use_assoc)\n     {\n       int i;\n-      i = gfc_get_sym_tree ((*sym)->name, NULL, st);\n+      i = gfc_get_sym_tree ((*sym)->name, NULL, st, false);\n       if (i)\n \treturn MATCH_ERROR;\n       *sym = (*st)->n.sym;\n@@ -2423,7 +2423,7 @@ gfc_match_rvalue (gfc_expr **result)\n \n   if (gfc_find_state (COMP_INTERFACE) == SUCCESS\n       && !gfc_current_ns->has_import_set)\n-    i = gfc_get_sym_tree (name, NULL, &symtree);\n+    i = gfc_get_sym_tree (name, NULL, &symtree, false);\n   else\n     i = gfc_get_ha_sym_tree (name, &symtree);\n \n@@ -2782,7 +2782,7 @@ gfc_match_rvalue (gfc_expr **result)\n \n       /* Give up, assume we have a function.  */\n \n-      gfc_get_sym_tree (name, NULL, &symtree);\t/* Can't fail */\n+      gfc_get_sym_tree (name, NULL, &symtree, false);\t/* Can't fail */\n       sym = symtree->n.sym;\n       e->expr_type = EXPR_FUNCTION;\n \n@@ -2815,7 +2815,7 @@ gfc_match_rvalue (gfc_expr **result)\n       break;\n \n     generic_function:\n-      gfc_get_sym_tree (name, NULL, &symtree);\t/* Can't fail */\n+      gfc_get_sym_tree (name, NULL, &symtree, false);\t/* Can't fail */\n \n       e = gfc_get_expr ();\n       e->symtree = symtree;"}, {"sha": "697c1ab507059ce7e26e40ce677bd300acd6ee77", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a6b8e049f9935cc314a669b2120ff07cd7fbeb/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a6b8e049f9935cc314a669b2120ff07cd7fbeb/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=08a6b8e049f9935cc314a669b2120ff07cd7fbeb", "patch": "@@ -4400,7 +4400,7 @@ check_host_association (gfc_expr *e)\n \t    }\n \n \t  /* Give the symbol a symtree in the right place!  */\n-\t  gfc_get_sym_tree (sym->name, gfc_current_ns, &st);\n+\t  gfc_get_sym_tree (sym->name, gfc_current_ns, &st, false);\n \t  st->n.sym = sym;\n \n \t  if (old_sym->attr.flavor == FL_PROCEDURE)"}, {"sha": "58422907d368721e69f4f1c339d26a9f7f5cccb5", "filename": "gcc/fortran/scanner.c", "status": "modified", "additions": 49, "deletions": 1, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a6b8e049f9935cc314a669b2120ff07cd7fbeb/gcc%2Ffortran%2Fscanner.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a6b8e049f9935cc314a669b2120ff07cd7fbeb/gcc%2Ffortran%2Fscanner.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fscanner.c?ref=08a6b8e049f9935cc314a669b2120ff07cd7fbeb", "patch": "@@ -63,9 +63,10 @@ static gfc_directorylist *include_dirs, *intrinsic_modules_dirs;\n \n static gfc_file *file_head, *current_file;\n \n-static int continue_flag, end_flag, openmp_flag;\n+static int continue_flag, end_flag, openmp_flag, gcc_attribute_flag;\n static int continue_count, continue_line;\n static locus openmp_locus;\n+static locus gcc_attribute_locus;\n \n gfc_source_form gfc_current_form;\n static gfc_linebuf *line_head, *line_tail;\n@@ -663,6 +664,34 @@ gfc_define_undef_line (void)\n }\n \n \n+/* Return true if GCC$ was matched.  */\n+static bool\n+skip_gcc_attribute (locus start)\n+{\n+  bool r = false;\n+  char c;\n+  locus old_loc = gfc_current_locus;\n+\n+  if ((c = next_char ()) == 'g' || c == 'G')\n+    if ((c = next_char ()) == 'c' || c == 'C')\n+      if ((c = next_char ()) == 'c' || c == 'C')\n+\tif ((c = next_char ()) == '$')\n+\t  r = true;\n+\n+  if (r == false)\n+    gfc_current_locus = old_loc;\n+  else\n+   {\n+      gcc_attribute_flag = 1;\n+      gcc_attribute_locus = old_loc;\n+      gfc_current_locus = start;\n+   }\n+\n+  return r;\n+}\n+\n+\n+\n /* Comment lines are null lines, lines containing only blanks or lines\n    on which the first nonblank line is a '!'.\n    Return true if !$ openmp conditional compilation sentinel was\n@@ -694,6 +723,10 @@ skip_free_comments (void)\n \n       if (c == '!')\n \t{\n+\t  /* Keep the !GCC$ line.  */\n+\t\t  if (at_bol && skip_gcc_attribute (start))\n+\t    return false;\n+\n \t  /* If -fopenmp, we need to handle here 2 things:\n \t     1) don't treat !$omp as comments, but directives\n \t     2) handle OpenMP conditional compilation, where\n@@ -752,6 +785,8 @@ skip_free_comments (void)\n \n   if (openmp_flag && at_bol)\n     openmp_flag = 0;\n+\n+  gcc_attribute_flag = 0;\n   gfc_current_locus = start;\n   return false;\n }\n@@ -806,6 +841,13 @@ skip_fixed_comments (void)\n \n       if (c == '!' || c == 'c' || c == 'C' || c == '*')\n \t{\n+\t  if (skip_gcc_attribute (start))\n+\t    {\n+\t      /* Canonicalize to *$omp.  */\n+\t      *start.nextc = '*';\n+\t      return;\n+\t    }\n+\n \t  /* If -fopenmp, we need to handle here 2 things:\n \t     1) don't treat !$omp|c$omp|*$omp as comments, but directives\n \t     2) handle OpenMP conditional compilation, where\n@@ -917,6 +959,7 @@ skip_fixed_comments (void)\n     }\n \n   openmp_flag = 0;\n+  gcc_attribute_flag = 0;\n   gfc_current_locus = start;\n }\n \n@@ -963,6 +1006,11 @@ gfc_next_char_literal (int in_string)\n \n       if (!in_string && c == '!')\n \t{\n+\t  if (gcc_attribute_flag\n+\t      && memcmp (&gfc_current_locus, &gcc_attribute_locus,\n+\t\t sizeof (gfc_current_locus)) == 0)\n+\t    goto done;\n+\n \t  if (openmp_flag\n \t      && memcmp (&gfc_current_locus, &openmp_locus,\n \t\t sizeof (gfc_current_locus)) == 0)"}, {"sha": "0c1a2fdaad0186e6a572ab9f9aa5c0f55de48bd7", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a6b8e049f9935cc314a669b2120ff07cd7fbeb/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a6b8e049f9935cc314a669b2120ff07cd7fbeb/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=08a6b8e049f9935cc314a669b2120ff07cd7fbeb", "patch": "@@ -809,19 +809,28 @@ duplicate_attr (const char *attr, locus *where)\n }\n \n \n+gfc_try\n+gfc_add_ext_attribute (symbol_attribute *attr, unsigned ext_attr,\n+\t\t       locus *where ATTRIBUTE_UNUSED)\n+{\n+  attr->ext_attr |= 1 << ext_attr;\n+  return SUCCESS;\n+}\n+\n+\n /* Called from decl.c (attr_decl1) to check attributes, when declared\n    separately.  */\n \n gfc_try\n gfc_add_attribute (symbol_attribute *attr, locus *where)\n {\n-\n   if (check_used (attr, NULL, where))\n     return FAILURE;\n \n   return check_conflict (attr, NULL, where);\n }\n \n+\n gfc_try\n gfc_add_allocatable (symbol_attribute *attr, locus *where)\n {\n@@ -2539,7 +2548,8 @@ save_symbol_data (gfc_symbol *sym)\n    So if the return value is nonzero, then an error was issued.  */\n \n int\n-gfc_get_sym_tree (const char *name, gfc_namespace *ns, gfc_symtree **result)\n+gfc_get_sym_tree (const char *name, gfc_namespace *ns, gfc_symtree **result,\n+\t\t  bool allow_subroutine)\n {\n   gfc_symtree *st;\n   gfc_symbol *p;\n@@ -2580,11 +2590,10 @@ gfc_get_sym_tree (const char *name, gfc_namespace *ns, gfc_symtree **result)\n \t}\n \n       p = st->n.sym;\n-\n       if (p->ns != ns && (!p->attr.function || ns->proc_name != p)\n-\t    && !(ns->proc_name\n-\t\t   && ns->proc_name->attr.if_source == IFSRC_IFBODY\n-\t\t   && (ns->has_import_set || p->attr.imported)))\n+\t  && !(allow_subroutine && p->attr.subroutine)\n+\t  && !(ns->proc_name && ns->proc_name->attr.if_source == IFSRC_IFBODY\n+\t  && (ns->has_import_set || p->attr.imported)))\n \t{\n \t  /* Symbol is from another namespace.  */\n \t  gfc_error (\"Symbol '%s' at %C has already been host associated\",\n@@ -2609,7 +2618,7 @@ gfc_get_symbol (const char *name, gfc_namespace *ns, gfc_symbol **result)\n   gfc_symtree *st;\n   int i;\n \n-  i = gfc_get_sym_tree (name, ns, &st);\n+  i = gfc_get_sym_tree (name, ns, &st, false);\n   if (i != 0)\n     return i;\n \n@@ -2651,7 +2660,7 @@ gfc_get_ha_sym_tree (const char *name, gfc_symtree **result)\n \t}\n     }\n \n-  return gfc_get_sym_tree (name, gfc_current_ns, result);\n+  return gfc_get_sym_tree (name, gfc_current_ns, result, false);\n }\n \n \n@@ -3653,7 +3662,7 @@ gen_cptr_param (gfc_formal_arglist **head,\n     c_ptr_in = \"gfc_cptr__\";\n   else\n     c_ptr_in = c_ptr_name;\n-  gfc_get_sym_tree (c_ptr_in, ns, &param_symtree);\n+  gfc_get_sym_tree (c_ptr_in, ns, &param_symtree, false);\n   if (param_symtree != NULL)\n     param_sym = param_symtree->n.sym;\n   else\n@@ -3719,7 +3728,7 @@ gen_fptr_param (gfc_formal_arglist **head,\n   if (f_ptr_name != NULL)\n     f_ptr_out = f_ptr_name;\n \n-  gfc_get_sym_tree (f_ptr_out, ns, &param_symtree);\n+  gfc_get_sym_tree (f_ptr_out, ns, &param_symtree, false);\n   if (param_symtree != NULL)\n     param_sym = param_symtree->n.sym;\n   else\n@@ -3766,7 +3775,7 @@ gen_shape_param (gfc_formal_arglist **head,\n   if (shape_param_name != NULL)\n     shape_param = shape_param_name;\n \n-  gfc_get_sym_tree (shape_param, ns, &param_symtree);\n+  gfc_get_sym_tree (shape_param, ns, &param_symtree, false);\n   if (param_symtree != NULL)\n     param_sym = param_symtree->n.sym;\n   else\n@@ -4115,7 +4124,7 @@ generate_isocbinding_symbol (const char *mod_name, iso_c_binding_symbol s,\n     return;\n \n   /* Create the sym tree in the current ns.  */\n-  gfc_get_sym_tree (name, gfc_current_ns, &tmp_symtree);\n+  gfc_get_sym_tree (name, gfc_current_ns, &tmp_symtree, false);\n   if (tmp_symtree)\n     tmp_sym = tmp_symtree->n.sym;\n   else"}, {"sha": "d64c3fae3c925e7eb7b276ef86f349e5582e32a8", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a6b8e049f9935cc314a669b2120ff07cd7fbeb/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a6b8e049f9935cc314a669b2120ff07cd7fbeb/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=08a6b8e049f9935cc314a669b2120ff07cd7fbeb", "patch": "@@ -980,6 +980,26 @@ gfc_add_assign_aux_vars (gfc_symbol * sym)\n   GFC_DECL_ASSIGN_ADDR (decl) = addr;\n }\n \n+\n+static tree\n+add_attributes_to_decl (symbol_attribute sym_attr, tree list)\n+{\n+  unsigned id;\n+  tree attr;\n+\n+  for (id = 0; id < EXT_ATTR_NUM; id++)\n+    if (sym_attr.ext_attr & (1 << id))\n+      {\n+\tattr = build_tree_list (\n+\t\t get_identifier (ext_attr_list[id].middle_end_name),\n+\t\t\t\t NULL_TREE);\n+\tlist = chainon (list, attr);\n+      }\n+\n+  return list;\n+}\n+\n+\n /* Return the decl for a gfc_symbol, create it if it doesn't already\n    exist.  */\n \n@@ -988,6 +1008,7 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n {\n   tree decl;\n   tree length = NULL_TREE;\n+  tree attributes;\n   int byref;\n \n   gcc_assert (sym->attr.referenced\n@@ -1187,6 +1208,10 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n       && !sym->attr.proc_pointer)\n     DECL_BY_REFERENCE (decl) = 1;\n \n+  /* Add attributes to variables.  Functions are handled elsewhere.  */\n+  attributes = add_attributes_to_decl (sym->attr, NULL_TREE);\n+  decl_attributes (&decl, attributes, 0);\n+\n   return decl;\n }\n \n@@ -1223,6 +1248,7 @@ static tree\n get_proc_pointer_decl (gfc_symbol *sym)\n {\n   tree decl;\n+  tree attributes;\n \n   decl = sym->backend_decl;\n   if (decl)\n@@ -1266,6 +1292,9 @@ get_proc_pointer_decl (gfc_symbol *sym)\n \t  TREE_TYPE (decl), sym->attr.dimension, sym->attr.proc_pointer);\n     }\n \n+  attributes = add_attributes_to_decl (sym->attr, NULL_TREE);\n+  decl_attributes (&decl, attributes, 0);\n+\n   return decl;\n }\n \n@@ -1277,6 +1306,7 @@ gfc_get_extern_function_decl (gfc_symbol * sym)\n {\n   tree type;\n   tree fndecl;\n+  tree attributes;\n   gfc_expr e;\n   gfc_intrinsic_sym *isym;\n   gfc_expr argexpr;\n@@ -1439,6 +1469,9 @@ gfc_get_extern_function_decl (gfc_symbol * sym)\n   if (DECL_CONTEXT (fndecl) == NULL_TREE)\n     pushdecl_top_level (fndecl);\n \n+  attributes = add_attributes_to_decl (sym->attr, NULL_TREE);\n+  decl_attributes (&fndecl, attributes, 0);\n+\n   return fndecl;\n }\n \n@@ -1450,7 +1483,7 @@ gfc_get_extern_function_decl (gfc_symbol * sym)\n static void\n build_function_decl (gfc_symbol * sym)\n {\n-  tree fndecl, type;\n+  tree fndecl, type, attributes;\n   symbol_attribute attr;\n   tree result_decl;\n   gfc_formal_arglist *f;\n@@ -1557,6 +1590,9 @@ build_function_decl (gfc_symbol * sym)\n       TREE_SIDE_EFFECTS (fndecl) = 0;\n     }\n \n+  attributes = add_attributes_to_decl (attr, NULL_TREE);\n+  decl_attributes (&fndecl, attributes, 0);\n+\n   /* Layout the function declaration and put it in the binding level\n      of the current function.  */\n   pushdecl (fndecl);"}, {"sha": "ce26ed9504352a5c05cb74503e4ec313b83ab1f3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a6b8e049f9935cc314a669b2120ff07cd7fbeb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a6b8e049f9935cc314a669b2120ff07cd7fbeb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=08a6b8e049f9935cc314a669b2120ff07cd7fbeb", "patch": "@@ -1,3 +1,9 @@\n+2009-06-28  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/34112\n+\t* gfortran.dg/compiler-directive_1.f90: New test.\n+\t* gfortran.dg/compiler-directive_2.f: New test.\n+\n 2009-06-28  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* gfortran.dg/integer_exponentiation_4.f90: Temporarily"}, {"sha": "75f28dcc928d3480fcd67dc6cc05c7f5cc36e5cd", "filename": "gcc/testsuite/gfortran.dg/compiler-directive_1.f90", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a6b8e049f9935cc314a669b2120ff07cd7fbeb/gcc%2Ftestsuite%2Fgfortran.dg%2Fcompiler-directive_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a6b8e049f9935cc314a669b2120ff07cd7fbeb/gcc%2Ftestsuite%2Fgfortran.dg%2Fcompiler-directive_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcompiler-directive_1.f90?ref=08a6b8e049f9935cc314a669b2120ff07cd7fbeb", "patch": "@@ -0,0 +1,48 @@\n+! { dg-do compile }\n+!\n+! PR fortran/34112\n+!\n+! Check for calling convention consitency\n+! in procedure-pointer assignments.\n+\n+program test\n+  interface\n+    subroutine sub1()\n+    end subroutine sub1\n+    subroutine sub2()\n+      !GCC$ ATTRIBUTES CDECL :: sub2\n+    end subroutine sub2\n+    subroutine sub3()\n+      !GCC$ ATTRIBUTES STDCALL :: sub3\n+    end subroutine sub3\n+    subroutine sub4()\n+!GCC$ ATTRIBUTES FASTCALL :: sub4\n+    end subroutine sub4\n+  end interface\n+\n+  !gcc$ attributes cdecl :: cdecl\n+  !gcc$ attributes stdcall :: stdcall\n+  procedure(), pointer :: ptr\n+  procedure(), pointer :: cdecl\n+  procedure(), pointer :: stdcall\n+  procedure(), pointer :: fastcall\n+  !gcc$ attributes fastcall :: fastcall\n+\n+  ! Valid:\n+  ptr => sub1\n+  cdecl => sub2\n+  stdcall => sub3\n+  fastcall => sub4\n+\n+  ! Invalid:\n+  ptr => sub3 ! { dg-error \"mismatch in the calling convention\" }\n+  ptr => sub4 ! { dg-error \"mismatch in the calling convention\" }\n+  cdecl => sub3 ! { dg-error \"mismatch in the calling convention\" }\n+  cdecl => sub4 ! { dg-error \"mismatch in the calling convention\" }\n+  stdcall => sub1 ! { dg-error \"mismatch in the calling convention\" }\n+  stdcall => sub2 ! { dg-error \"mismatch in the calling convention\" }\n+  stdcall => sub4 ! { dg-error \"mismatch in the calling convention\" }\n+  fastcall => sub1 ! { dg-error \"mismatch in the calling convention\" }\n+  fastcall => sub2 ! { dg-error \"mismatch in the calling convention\" }\n+  fastcall => sub3 ! { dg-error \"mismatch in the calling convention\" }\n+end program"}, {"sha": "fcb1657b4ea5190774447b916ba1f0a7ccb43458", "filename": "gcc/testsuite/gfortran.dg/compiler-directive_2.f", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a6b8e049f9935cc314a669b2120ff07cd7fbeb/gcc%2Ftestsuite%2Fgfortran.dg%2Fcompiler-directive_2.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a6b8e049f9935cc314a669b2120ff07cd7fbeb/gcc%2Ftestsuite%2Fgfortran.dg%2Fcompiler-directive_2.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcompiler-directive_2.f?ref=08a6b8e049f9935cc314a669b2120ff07cd7fbeb", "patch": "@@ -0,0 +1,11 @@\n+! { dg-do compile { target i?86-*-* x86_64-*-* } }\n+! { dg-require-effective-target ilp32 }\n+!\n+! PR fortran/34112\n+!\n+! Check for calling convention consitency\n+! in procedure-pointer assignments.\n+!\n+      subroutine test() ! { dg-error \"fastcall and stdcall attributes are not compatible\" }\n+cGCC$ attributes stdcall, fastcall::test\n+      end subroutine test"}]}