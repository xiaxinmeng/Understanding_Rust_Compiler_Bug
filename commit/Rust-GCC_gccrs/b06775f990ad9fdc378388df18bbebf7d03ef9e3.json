{"sha": "b06775f990ad9fdc378388df18bbebf7d03ef9e3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjA2Nzc1Zjk5MGFkOWZkYzM3ODM4OGRmMThiYmViZjdkMDNlZjllMw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-03-27T00:50:27Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-03-27T00:50:27Z"}, "message": "calls.c (expand_call): Pass parms not original exp to optimize_tail_recursion.\n\n        * calls.c (expand_call): Pass parms not original exp to\n        optimize_tail_recursion.  Mind return value instead of looking\n        for a barrier.\n        * stmt.c (optimize_tail_recursion): Take parameter list, not entire\n        call_expr.  Move checks for call_expr and current_function_decl ...\n        (expand_return): ... here.\n\nFrom-SVN: r32758", "tree": {"sha": "ea8ea170426cc8cb9e99e73acabed34e6c0a6bc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea8ea170426cc8cb9e99e73acabed34e6c0a6bc2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b06775f990ad9fdc378388df18bbebf7d03ef9e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b06775f990ad9fdc378388df18bbebf7d03ef9e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b06775f990ad9fdc378388df18bbebf7d03ef9e3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b06775f990ad9fdc378388df18bbebf7d03ef9e3/comments", "author": null, "committer": null, "parents": [{"sha": "a843e0ced84306002584b6c824996632690149d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a843e0ced84306002584b6c824996632690149d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a843e0ced84306002584b6c824996632690149d7"}], "stats": {"total": 66, "additions": 30, "deletions": 36}, "files": [{"sha": "ca9d214541e26eaf41a3d5f6ccea1af07a93c88a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b06775f990ad9fdc378388df18bbebf7d03ef9e3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b06775f990ad9fdc378388df18bbebf7d03ef9e3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b06775f990ad9fdc378388df18bbebf7d03ef9e3", "patch": "@@ -1,3 +1,12 @@\n+2000-03-26  Richard Henderson  <rth@cygnus.com>\n+\n+\t* calls.c (expand_call): Pass parms not original exp to\n+\toptimize_tail_recursion.  Mind return value instead of looking\n+\tfor a barrier.\n+\t* stmt.c (optimize_tail_recursion): Take parameter list, not entire\n+\tcall_expr.  Move checks for call_expr and current_function_decl ...\n+\t(expand_return): ... here.\n+\n 2000-03-26  Tom Tromey  <tromey@cygnus.com>\n \n \t* gcc.c (handle_braces): Recognize `%{<S}' construct."}, {"sha": "07898c328d5350ced594b36b504f82d12fa526a3", "filename": "gcc/calls.c", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b06775f990ad9fdc378388df18bbebf7d03ef9e3/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b06775f990ad9fdc378388df18bbebf7d03ef9e3/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=b06775f990ad9fdc378388df18bbebf7d03ef9e3", "patch": "@@ -2099,28 +2099,20 @@ expand_call (exp, target, ignore)\n \t recursion call can be ignored if we indeed use the tail recursion\n \t call expansion.  */\n       int save_pending_stack_adjust = pending_stack_adjust;\n-      rtx last;\n \n       /* Use a new sequence to hold any RTL we generate.  We do not even\n \t know if we will use this RTL yet.  The final decision can not be\n \t made until after RTL generation for the entire function is\n \t complete.  */\n-      push_to_sequence (0);\n+      start_sequence ();\n \n       /* Emit the pending stack adjustments before we expand any arguments.  */\n       do_pending_stack_adjust ();\n \n-      optimize_tail_recursion (exp, get_last_insn ());\n- \n-      last = get_last_insn ();\n-      tail_recursion_insns = get_insns ();\n+      if (optimize_tail_recursion (actparms, get_last_insn ()))\n+        tail_recursion_insns = get_insns ();\n       end_sequence ();\n \n-      /* If the last insn on the tail recursion sequence is not a\n-\t BARRIER, then tail recursion optimization failed.  */\n-      if (last == NULL_RTX || GET_CODE (last) != BARRIER)\n-\ttail_recursion_insns = NULL_RTX;\n-\n       /* Restore the original pending stack adjustment for the sibling and\n \t normal call cases below.  */\n       pending_stack_adjust = save_pending_stack_adjust;"}, {"sha": "88d665e72366ec38ba23512af823e7e9d0ef5505", "filename": "gcc/stmt.c", "status": "modified", "additions": 18, "deletions": 25, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b06775f990ad9fdc378388df18bbebf7d03ef9e3/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b06775f990ad9fdc378388df18bbebf7d03ef9e3/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=b06775f990ad9fdc378388df18bbebf7d03ef9e3", "patch": "@@ -2872,7 +2872,14 @@ expand_return (retval)\n     }\n \n   /* Attempt to optimize the call if it is tail recursive.  */\n-  if (optimize_tail_recursion (retval_rhs, last_insn))\n+  if (optimize\n+      && retval_rhs != NULL_TREE\n+      && frame_offset == 0\n+      && TREE_CODE (retval_rhs) == CALL_EXPR\n+      && TREE_CODE (TREE_OPERAND (retval_rhs, 0)) == ADDR_EXPR\n+      && (TREE_OPERAND (TREE_OPERAND (retval_rhs, 0), 0)\n+\t  == current_function_decl)\n+      && optimize_tail_recursion (TREE_OPERAND (retval_rhs, 1), last_insn))\n     return;\n \n #ifdef HAVE_return\n@@ -3084,33 +3091,20 @@ drop_through_at_end_p ()\n   return insn && GET_CODE (insn) != BARRIER;\n }\n \f\n-/* Test CALL_EXPR to determine if it is a potential tail recursion call\n-   and emit code to optimize the tail recursion.  LAST_INSN indicates where\n-   to place the jump to the tail recursion label.  Return TRUE if the\n-   call was optimized into a goto.\n-\n-   This is only used by expand_return, but expand_call is expected to\n-   use it soon.  */\n+/* Attempt to optimize a potential tail recursion call into a goto.\n+   ARGUMENTS are the arguments to a CALL_EXPR; LAST_INSN indicates\n+   where to place the jump to the tail recursion label. \n+   \n+   Return TRUE if the call was optimized into a goto.  */\n \n int\n-optimize_tail_recursion (call_expr, last_insn)\n-     tree call_expr;\n+optimize_tail_recursion (arguments, last_insn)\n+     tree arguments;\n      rtx last_insn;\n {\n-  /* For tail-recursive call to current function,\n-     just jump back to the beginning.\n-     It's unsafe if any auto variable in this function\n-     has its address taken; for simplicity,\n-     require stack frame to be empty.  */\n-  if (optimize && call_expr != 0\n-      && frame_offset == 0\n-      && TREE_CODE (call_expr) == CALL_EXPR\n-      && TREE_CODE (TREE_OPERAND (call_expr, 0)) == ADDR_EXPR\n-      && TREE_OPERAND (TREE_OPERAND (call_expr, 0), 0) == current_function_decl\n-      /* Finish checking validity, and if valid emit code\n-\t to set the argument variables for the new call.  */\n-      && tail_recursion_args (TREE_OPERAND (call_expr, 1),\n-\t\t\t      DECL_ARGUMENTS (current_function_decl)))\n+  /* Finish checking validity, and if valid emit code to set the\n+     argument variables for the new call.  */\n+  if (tail_recursion_args (arguments, DECL_ARGUMENTS (current_function_decl)))\n     {\n       if (tail_recursion_label == 0)\n \t{\n@@ -3123,7 +3117,6 @@ optimize_tail_recursion (call_expr, last_insn)\n       emit_barrier ();\n       return 1;\n     }\n-\n   return 0;\n }\n "}]}