{"sha": "f3940b0e3d26190dbcfe86f0bc5f4a84b259c298", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjM5NDBiMGUzZDI2MTkwZGJjZmU4NmYwYmM1ZjRhODRiMjU5YzI5OA==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2005-10-05T15:16:42Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "2005-10-05T15:16:42Z"}, "message": "re PR tree-optimization/18587 (build_v_may_defs and build_vuses can be improved when adding)\n\n\n\n2005-10-05  Andrew MacLeod  <amacleod@redhat.com>\n\n\tPR tree-optimization/18587\n\n\t* tree-ssa-operands.c (struct opbuild_list_d, OPBUILD_LAST): Delete.\n\t(build_defs, build_uses, build_v_may_defs, build_v_must_defs,\n\tbuild_vuses): Change to VEC type.\n\t(opbuild_initialize_virtual, opbuild_initialize_real, opbuild_free,\n\topbuild_num_elems, opbuild_append_real, opbuild_append_virtual,\n\topbuild_first, opbuild_next, opbuild_elem_real, opbuild_elem_virtual,\n\topbuild_elem_uid, opbuild_clear, opbuild_remove_elem): Delete.\n\t(get_name_decl): New.  Return DECL_UID of base variable.\n\t(operand_build_cmp): New.  qsort comparison routine.\n\t(operand_build_sort_virtual): New.  Sort virtual build vector.\n\t(init_ssa_operands, fini_ssa_operands): Use VEC routines.\n\t(FINALIZE_OPBUILD_BASE, FINALIZE_OPBUILD_ELEM): Use VEC_Index.\n\t(FINALIZE_BASE): Use get_name_decl.\n\t(finalize_ssa_defs, finalize_ssa_uses, cleanup_v_may_defs,\n\tfinalize_ssa_v_may_defs, finalize_ssa_vuses, finalize_ssa_v_must_defs,\n\t(start_ssa_stmt_operands, append_def, append_use, append_vuse,\n\tappend_v_may_def, append_v_must_def): Replace opbuild_* routines with\n\tdirect VEC_* manipulations.\n\t(build_ssa_operands): Call operand_build_sort_virtual.\n\t(copy_virtual_operand, create_ssa_artficial_load_stmt,\n\tadd_call_clobber_ops, add_call_read_ops): Replace opbuild_* routines\n\twith direct VEC_* manipulations.\n\t* tree-ssa-opfinalize.h (FINALIZE_FUNC): Replace opbuild_* routines\n\twith direct VEC manipulations.\n\nFrom-SVN: r104996", "tree": {"sha": "182364a4d7933c18a0c9f487847c27928270bd71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/182364a4d7933c18a0c9f487847c27928270bd71"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f3940b0e3d26190dbcfe86f0bc5f4a84b259c298", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3940b0e3d26190dbcfe86f0bc5f4a84b259c298", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3940b0e3d26190dbcfe86f0bc5f4a84b259c298", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3940b0e3d26190dbcfe86f0bc5f4a84b259c298/comments", "author": null, "committer": null, "parents": [{"sha": "3015564c8a0d5d125441bf61a10740b07887cb43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3015564c8a0d5d125441bf61a10740b07887cb43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3015564c8a0d5d125441bf61a10740b07887cb43"}], "stats": {"total": 496, "additions": 172, "deletions": 324}, "files": [{"sha": "a21d4d83097e1b36ce18ee298e0ff9e5ac784699", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3940b0e3d26190dbcfe86f0bc5f4a84b259c298/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3940b0e3d26190dbcfe86f0bc5f4a84b259c298/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f3940b0e3d26190dbcfe86f0bc5f4a84b259c298", "patch": "@@ -1,3 +1,31 @@\n+2005-10-05  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\tPR tree-optimization/18587\n+\t* tree-ssa-operands.c (struct opbuild_list_d, OPBUILD_LAST): Delete.\n+\t(build_defs, build_uses, build_v_may_defs, build_v_must_defs,\n+\tbuild_vuses): Change to VEC type.\n+\t(opbuild_initialize_virtual, opbuild_initialize_real, opbuild_free,\n+\topbuild_num_elems, opbuild_append_real, opbuild_append_virtual,\n+\topbuild_first, opbuild_next, opbuild_elem_real, opbuild_elem_virtual,\n+\topbuild_elem_uid, opbuild_clear, opbuild_remove_elem): Delete.\n+\t(get_name_decl): New.  Return DECL_UID of base variable. \n+\t(operand_build_cmp): New.  qsort comparison routine.\n+\t(operand_build_sort_virtual): New.  Sort virtual build vector.\n+\t(init_ssa_operands, fini_ssa_operands): Use VEC routines.\n+\t(FINALIZE_OPBUILD_BASE, FINALIZE_OPBUILD_ELEM): Use VEC_Index.\n+\t(FINALIZE_BASE): Use get_name_decl.\n+\t(finalize_ssa_defs, finalize_ssa_uses, cleanup_v_may_defs,\n+\tfinalize_ssa_v_may_defs, finalize_ssa_vuses, finalize_ssa_v_must_defs,\n+\t(start_ssa_stmt_operands, append_def, append_use, append_vuse, \n+\tappend_v_may_def, append_v_must_def): Replace opbuild_* routines with \n+\tdirect VEC_* manipulations.\n+\t(build_ssa_operands): Call operand_build_sort_virtual.\n+\t(copy_virtual_operand, create_ssa_artficial_load_stmt,\n+\tadd_call_clobber_ops, add_call_read_ops): Replace opbuild_* routines \n+\twith direct VEC_* manipulations.\n+\t* tree-ssa-opfinalize.h (FINALIZE_FUNC): Replace opbuild_* routines\n+\twith direct VEC manipulations.\n+\n 2005-10-05  Paolo Bonzini  <bonzini@gnu.org>\n \n \tPR tree-optimization/21419"}, {"sha": "30845546d287bce9ee582b81e9394eb5358dbb77", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 137, "deletions": 315, "changes": 452, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3940b0e3d26190dbcfe86f0bc5f4a84b259c298/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3940b0e3d26190dbcfe86f0bc5f4a84b259c298/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=f3940b0e3d26190dbcfe86f0bc5f4a84b259c298", "patch": "@@ -103,34 +103,21 @@ Boston, MA 02110-1301, USA.  */\n    to distinguish \"reset the world\" events from explicit MODIFY_EXPRs.  */\n #define opf_non_specific  (1 << 3)\n \n-/* This structure maintain a sorted list of operands which is created by\n-   parse_ssa_operand.  */\n-struct opbuild_list_d GTY (())\n-{\n-  varray_type vars;     /* The VAR_DECLS tree.  */\n-  varray_type uid;      /* The sort value for virtual symbols.  */\n-  varray_type next;     /* The next index in the sorted list.  */\n-  int first;            /* First element in list.  */\n-  unsigned num;\t\t/* Number of elements.  */\n-};\n-                                                                                \n-#define OPBUILD_LAST     -1\n-                                                                                \n \n /* Array for building all the def operands.  */\n-static GTY (()) struct opbuild_list_d build_defs;\n+static VEC(tree,heap) *build_defs;\n \n /* Array for building all the use operands.  */\n-static GTY (()) struct opbuild_list_d build_uses;\n+static VEC(tree,heap) *build_uses;\n \n /* Array for building all the v_may_def operands.  */\n-static GTY (()) struct opbuild_list_d build_v_may_defs;\n+static VEC(tree,heap) *build_v_may_defs;\n \n /* Array for building all the vuse operands.  */\n-static GTY (()) struct opbuild_list_d build_vuses;\n+static VEC(tree,heap) *build_vuses;\n \n /* Array for building all the v_must_def operands.  */\n-static GTY (()) struct opbuild_list_d build_v_must_defs;\n+static VEC(tree,heap) *build_v_must_defs;\n \n /* True if the operands for call clobbered vars are cached and valid.  */\n bool ssa_call_clobbered_cache_valid;\n@@ -168,222 +155,65 @@ static vuse_optype_p free_vuses = NULL;\n static maydef_optype_p free_maydefs = NULL;\n static mustdef_optype_p free_mustdefs = NULL;\n \n-/* Initialize a virtual operand build LIST called NAME with NUM elements.  */\n-\n-static inline void\n-opbuild_initialize_virtual (struct  opbuild_list_d *list, int num, \n-\t\t\t   const char *name)\n-{\n-  list->first = OPBUILD_LAST;\n-  list->num = 0;\n-  VARRAY_TREE_INIT (list->vars, num, name);\n-  VARRAY_UINT_INIT (list->uid, num, \"List UID\");\n-  VARRAY_INT_INIT (list->next, num, \"List NEXT\");\n-}\n-\n-\n-/* Initialize a real operand build LIST called NAME with NUM elements.  */\n-\n-static inline void\n-opbuild_initialize_real (struct opbuild_list_d *list, int num, const char *name)\n-{\n-  list->first = OPBUILD_LAST;\n-  list->num = 0;\n-  VARRAY_TREE_PTR_INIT (list->vars, num, name);\n-  VARRAY_INT_INIT (list->next, num, \"List NEXT\");\n-  /* The UID field is not needed since we sort based on the pointer value.  */\n-  list->uid = NULL;\n-}\n-\n \n-/* Free memory used in virtual operand build object LIST.  */\n-\n-static inline void\n-opbuild_free (struct opbuild_list_d *list)\n-{\n-  list->vars = NULL;\n-  list->uid = NULL;\n-  list->next = NULL;\n-}\n-\n-\n-/* Number of elements in an opbuild list.  */\n+/* Return the DECL_UID of the base varaiable of T.  */\n \n static inline unsigned\n-opbuild_num_elems (struct opbuild_list_d *list)\n+get_name_decl (tree t)\n {\n-  return list->num;\n+  if (TREE_CODE (t) != SSA_NAME)\n+    return DECL_UID (t);\n+  else\n+    return DECL_UID (SSA_NAME_VAR (t));\n }\n \n+/* Comparison function for qsort used in operand_build_sort_virtual.  */\n \n-/* Add VAR to the real operand list LIST, keeping it sorted and avoiding\n-   duplicates.  The actual sort value is the tree pointer value.  */\n-\n-static inline void\n-opbuild_append_real (struct opbuild_list_d *list, tree *var)\n+static int\n+operand_build_cmp (const void *p, const void *q)\n {\n-  int index;\n+  tree e1 = *((const tree *)p);\n+  tree e2 = *((const tree *)q);\n+  unsigned int u1,u2;\n+\n+  u1 = get_name_decl (e1);\n+  u2 = get_name_decl (e2);\n \n+  /* We want to sort in ascending order.  They can never be equal.  */\n #ifdef ENABLE_CHECKING\n-  /* Ensure the real operand doesn't exist already.  */\n-  for (index = list->first; \n-       index != OPBUILD_LAST; \n-       index = VARRAY_INT (list->next, index))\n-    gcc_assert (VARRAY_TREE_PTR (list->vars, index) != var);\n+  gcc_assert (u1 != u2);\n #endif\n-\n-  /* First item in the list.  */\n-  index = VARRAY_ACTIVE_SIZE (list->vars);\n-  if (index == 0)\n-    list->first = index;\n-  else\n-    VARRAY_INT (list->next, index - 1) = index;\n-  VARRAY_PUSH_INT (list->next, OPBUILD_LAST);\n-  VARRAY_PUSH_TREE_PTR (list->vars, var);\n-  list->num++;\n+  return (u1 > u2 ? 1 : -1);\n }\n \n-\n-/* Add VAR to the virtual operand list LIST, keeping it sorted and avoiding\n-   duplicates.  The actual sort value is the DECL UID of the base variable.  */\n+/* Sort the virtual operands in LIST from lowest DECL_UID to highest.  */\n \n static inline void\n-opbuild_append_virtual (struct opbuild_list_d *list, tree var)\n+operand_build_sort_virtual (VEC(tree,heap) *list)\n {\n-  int index, curr, last;\n-  unsigned int var_uid;\n-\n-  if (TREE_CODE (var) != SSA_NAME)\n-    var_uid = DECL_UID (var);\n-  else\n-    var_uid = DECL_UID (SSA_NAME_VAR (var));\n-\n-  index = VARRAY_ACTIVE_SIZE (list->vars);\n-\n-  if (index == 0)\n+  int num = VEC_length (tree, list);\n+  if (num < 2)\n+    return;\n+  if (num == 2)\n     {\n-      VARRAY_PUSH_TREE (list->vars, var);\n-      VARRAY_PUSH_UINT (list->uid, var_uid);\n-      VARRAY_PUSH_INT (list->next, OPBUILD_LAST);\n-      list->first = 0;\n-      list->num = 1;\n+      if (get_name_decl (VEC_index (tree, list, 0)) \n+\t  > get_name_decl (VEC_index (tree, list, 1)))\n+\t{  \n+\t  /* Swap elements if in the wrong order.  */\n+\t  tree tmp = VEC_index (tree, list, 0);\n+\t  VEC_replace (tree, list, 0, VEC_index (tree, list, 1));\n+\t  VEC_replace (tree, list, 1, tmp);\n+\t}\n       return;\n     }\n-\n-  last = OPBUILD_LAST;\n-  /* Find the correct spot in the sorted list.  */\n-  for (curr = list->first; \n-       curr != OPBUILD_LAST; \n-       last = curr, curr = VARRAY_INT (list->next, curr))\n-    {\n-      if (VARRAY_UINT (list->uid, curr) > var_uid)\n-        break;\n-    }\n-\n-  if (last == OPBUILD_LAST)\n-    {\n-      /* First item in the list.  */\n-      VARRAY_PUSH_INT (list->next, list->first);\n-      list->first = index;\n-    }\n-  else\n-    {\n-      /* Don't enter duplicates at all.  */\n-      if (VARRAY_UINT (list->uid, last) == var_uid)\n-        return;\n-      \n-      VARRAY_PUSH_INT (list->next, VARRAY_INT (list->next, last));\n-      VARRAY_INT (list->next, last) = index;\n-    }\n-  VARRAY_PUSH_TREE (list->vars, var);\n-  VARRAY_PUSH_UINT (list->uid, var_uid);\n-  list->num++;\n-}\n-\n-\n-/*  Return the first element index in LIST.  OPBUILD_LAST means there are no \n-    more elements.  */\n-\n-static inline int\n-opbuild_first (struct opbuild_list_d *list)\n-{\n-  if (list->num > 0)\n-    return list->first;\n-  else\n-    return OPBUILD_LAST;\n-}\n-\n-\n-/* Return the next element after PREV in LIST.  */\n-\n-static inline int\n-opbuild_next (struct opbuild_list_d *list, int prev)\n-{\n-  return VARRAY_INT (list->next, prev);\n-}\n-\n-\n-/* Return the real element at index ELEM in LIST.  */\n-\n-static inline tree *\n-opbuild_elem_real (struct opbuild_list_d *list, int elem)\n-{\n-  return VARRAY_TREE_PTR (list->vars, elem);\n-}\n-\n-\n-/* Return the virtual element at index ELEM in LIST.  */\n-\n-static inline tree\n-opbuild_elem_virtual (struct opbuild_list_d *list, int elem)\n-{\n-  return VARRAY_TREE (list->vars, elem);\n+  /* There are 3 or more elements, call qsort.  */\n+  qsort (VEC_address (tree, list), \n+\t VEC_length (tree, list), \n+\t sizeof (tree),\n+\t operand_build_cmp);\n }\n \n \n-/* Return the virtual element uid at index ELEM in LIST.  */\n-static inline unsigned int\n-opbuild_elem_uid (struct opbuild_list_d *list, int elem)\n-{\n-  return VARRAY_UINT (list->uid, elem);\n-}\n-\n-\n-/* Reset an operand build list.  */\n-\n-static inline void\n-opbuild_clear (struct opbuild_list_d *list)\n-{\n-  list->first = OPBUILD_LAST;\n-  VARRAY_POP_ALL (list->vars);\n-  VARRAY_POP_ALL (list->next);\n-  if (list->uid)\n-    VARRAY_POP_ALL (list->uid);\n-  list->num = 0;\n-}\n-\n-\n-/* Remove ELEM from LIST where PREV is the previous element.  Return the next \n-   element.  */\n-\n-static inline int \n-opbuild_remove_elem (struct opbuild_list_d *list, int elem, int prev)\n-{\n-  int ret;\n-  if (prev != OPBUILD_LAST)\n-    {\n-      gcc_assert (VARRAY_INT (list->next, prev) == elem);\n-      ret = VARRAY_INT (list->next, prev) = VARRAY_INT (list->next, elem);\n-    }\n-  else\n-    {\n-      gcc_assert (list->first == elem);\n-      ret = list->first = VARRAY_INT (list->next, elem);\n-    }\n-  list->num--;\n-  return ret;\n-}\n-\n \n /*  Return true if the ssa operands cache is active.  */\n \n@@ -399,11 +229,12 @@ ssa_operands_active (void)\n void\n init_ssa_operands (void)\n {\n-  opbuild_initialize_real (&build_defs, 5, \"build defs\");\n-  opbuild_initialize_real (&build_uses, 10, \"build uses\");\n-  opbuild_initialize_virtual (&build_vuses, 25, \"build_vuses\");\n-  opbuild_initialize_virtual (&build_v_may_defs, 25, \"build_v_may_defs\");\n-  opbuild_initialize_virtual (&build_v_must_defs, 25, \"build_v_must_defs\");\n+  build_defs = VEC_alloc (tree, heap, 5);\n+  build_uses = VEC_alloc (tree, heap, 10);\n+  build_vuses = VEC_alloc (tree, heap, 25);\n+  build_v_may_defs = VEC_alloc (tree, heap, 25);\n+  build_v_must_defs = VEC_alloc (tree, heap, 25);\n+\n   gcc_assert (operand_memory == NULL);\n   operand_memory_index = SSA_OPERAND_MEMORY_SIZE;\n   ops_active = true;\n@@ -416,11 +247,11 @@ void\n fini_ssa_operands (void)\n {\n   struct ssa_operand_memory_d *ptr;\n-  opbuild_free (&build_defs);\n-  opbuild_free (&build_uses);\n-  opbuild_free (&build_v_must_defs);\n-  opbuild_free (&build_v_may_defs);\n-  opbuild_free (&build_vuses);\n+  VEC_free (tree, heap, build_defs);\n+  VEC_free (tree, heap, build_uses);\n+  VEC_free (tree, heap, build_v_must_defs);\n+  VEC_free (tree, heap, build_v_may_defs);\n+  VEC_free (tree, heap, build_vuses);\n   free_defs = NULL;\n   free_uses = NULL;\n   free_vuses = NULL;\n@@ -530,8 +361,10 @@ set_virtual_use_link (use_operand_p ptr, tree stmt)\n \n \n #define FINALIZE_OPBUILD\t\tbuild_defs\n-#define FINALIZE_OPBUILD_BASE(I)\topbuild_elem_real (&build_defs, (I))\n-#define FINALIZE_OPBUILD_ELEM(I)\topbuild_elem_real (&build_defs, (I))\n+#define FINALIZE_OPBUILD_BASE(I)\t(tree *)VEC_index (tree,\t\\\n+\t\t\t\t\t\t\t   build_defs, (I))\n+#define FINALIZE_OPBUILD_ELEM(I)\t(tree *)VEC_index (tree,\t\\\n+\t\t\t\t\t\t\t   build_defs, (I))\n #define FINALIZE_FUNC\t\t\tfinalize_ssa_def_ops\n #define FINALIZE_ALLOC\t\t\talloc_def\n #define FINALIZE_FREE\t\t\tfree_defs\n@@ -550,20 +383,22 @@ set_virtual_use_link (use_operand_p ptr, tree stmt)\n static void\n finalize_ssa_defs (tree stmt)\n {\n-  unsigned int num = opbuild_num_elems (&build_defs);\n+  unsigned int num = VEC_length (tree, build_defs);\n   /* There should only be a single real definition per assignment.  */\n   gcc_assert ((stmt && TREE_CODE (stmt) != MODIFY_EXPR) || num <= 1);\n \n   /* If there is an old list, often the new list is identical, or close, so\n      find the elements at the beginning that are the same as the vector.  */\n \n   finalize_ssa_def_ops (stmt);\n-  opbuild_clear (&build_defs);\n+  VEC_truncate (tree, build_defs, 0);\n }\n \n #define FINALIZE_OPBUILD\tbuild_uses\n-#define FINALIZE_OPBUILD_BASE(I)\topbuild_elem_real (&build_uses, (I))\n-#define FINALIZE_OPBUILD_ELEM(I)\topbuild_elem_real (&build_uses, (I))\n+#define FINALIZE_OPBUILD_BASE(I)\t(tree *)VEC_index (tree,\t\\\n+\t\t\t\t\t\t\t   build_uses, (I))\n+#define FINALIZE_OPBUILD_ELEM(I)\t(tree *)VEC_index (tree,\t\\\n+\t\t\t\t\t\t\t   build_uses, (I))\n #define FINALIZE_FUNC\t\tfinalize_ssa_use_ops\n #define FINALIZE_ALLOC\t\talloc_use\n #define FINALIZE_FREE\t\tfree_uses\n@@ -589,25 +424,26 @@ finalize_ssa_uses (tree stmt)\n #ifdef ENABLE_CHECKING\n   {\n     unsigned x;\n-    unsigned num = opbuild_num_elems (&build_uses);\n+    unsigned num = VEC_length (tree, build_uses);\n \n     /* If the pointer to the operand is the statement itself, something is\n        wrong.  It means that we are pointing to a local variable (the \n        initial call to get_stmt_operands does not pass a pointer to a \n        statement).  */\n     for (x = 0; x < num; x++)\n-      gcc_assert (*(opbuild_elem_real (&build_uses, x)) != stmt);\n+      gcc_assert (*((tree *)VEC_index (tree, build_uses, x)) != stmt);\n   }\n #endif\n   finalize_ssa_use_ops (stmt);\n-  opbuild_clear (&build_uses);\n+  VEC_truncate (tree, build_uses, 0);\n }\n                                                                               \n                                                                               \n /* Return a new v_may_def operand vector for STMT, comparing to OLD_OPS_P.  */                                                                                \n #define FINALIZE_OPBUILD\tbuild_v_may_defs\n-#define FINALIZE_OPBUILD_ELEM(I)\topbuild_elem_virtual (&build_v_may_defs, (I))\n-#define FINALIZE_OPBUILD_BASE(I)\topbuild_elem_uid (&build_v_may_defs, (I))\n+#define FINALIZE_OPBUILD_ELEM(I)\tVEC_index (tree, build_v_may_defs, (I))\n+#define FINALIZE_OPBUILD_BASE(I)\tget_name_decl (VEC_index (tree,\t\\\n+\t\t\t\t\t\t\tbuild_v_may_defs, (I)))\n #define FINALIZE_FUNC\t\tfinalize_ssa_v_may_def_ops\n #define FINALIZE_ALLOC\t\talloc_maydef\n #define FINALIZE_FREE\t\tfree_maydefs\n@@ -617,8 +453,7 @@ finalize_ssa_uses (tree stmt)\n #define FINALIZE_USE_PTR(PTR)\tMAYDEF_OP_PTR (PTR)\n #define FINALIZE_CORRECT_USE\tset_virtual_use_link\n #define FINALIZE_BASE_ZERO\t0\n-#define FINALIZE_BASE(VAR)\t((TREE_CODE (VAR) == SSA_NAME)\t\t\\\n-\t\t\t\t? DECL_UID (SSA_NAME_VAR (VAR)) : DECL_UID ((VAR)))\n+#define FINALIZE_BASE(VAR)\tget_name_decl (VAR)\n #define FINALIZE_BASE_TYPE\tunsigned\n #define FINALIZE_INITIALIZE(PTR, VAL, STMT)\t\t\t\t\\\n \t\t\t\t(PTR)->def_var = (VAL);\t\t\t\\\n@@ -642,24 +477,25 @@ static inline void\n cleanup_v_may_defs (void)\n {\n   unsigned x, num;\n-  num = opbuild_num_elems (&build_v_may_defs);\n+  num = VEC_length (tree, build_v_may_defs);\n \n   for (x = 0; x < num; x++)\n     {\n-      tree t = opbuild_elem_virtual (&build_v_may_defs, x);\n+      tree t = VEC_index (tree, build_v_may_defs, x);\n       if (TREE_CODE (t) != SSA_NAME)\n \t{\n \t  var_ann_t ann = var_ann (t);\n \t  ann->in_v_may_def_list = 0;\n \t}\n     }\n-  opbuild_clear (&build_v_may_defs);\n+  VEC_truncate (tree, build_v_may_defs, 0);\n }                                                                             \n \n                                                                               \n #define FINALIZE_OPBUILD\tbuild_vuses\n-#define FINALIZE_OPBUILD_ELEM(I)\topbuild_elem_virtual (&build_vuses, (I))\n-#define FINALIZE_OPBUILD_BASE(I)\topbuild_elem_uid (&build_vuses, (I))\n+#define FINALIZE_OPBUILD_ELEM(I)\tVEC_index (tree, build_vuses, (I))\n+#define FINALIZE_OPBUILD_BASE(I)\tget_name_decl (VEC_index (tree,\t\\\n+\t\t\t\t\t\t\tbuild_vuses, (I)))\n #define FINALIZE_FUNC\t\tfinalize_ssa_vuse_ops\n #define FINALIZE_ALLOC\t\talloc_vuse\n #define FINALIZE_FREE\t\tfree_vuses\n@@ -669,8 +505,7 @@ cleanup_v_may_defs (void)\n #define FINALIZE_USE_PTR(PTR)\tVUSE_OP_PTR (PTR)\n #define FINALIZE_CORRECT_USE\tset_virtual_use_link\n #define FINALIZE_BASE_ZERO\t0\n-#define FINALIZE_BASE(VAR)\t((TREE_CODE (VAR) == SSA_NAME)\t\t\\\n-\t\t\t\t? DECL_UID (SSA_NAME_VAR (VAR)) : DECL_UID ((VAR)))\n+#define FINALIZE_BASE(VAR)\tget_name_decl (VAR)\n #define FINALIZE_BASE_TYPE\tunsigned\n #define FINALIZE_INITIALIZE(PTR, VAL, STMT)\t\t\t\t\\\n \t\t\t\t(PTR)->use_var = (VAL);\t\t\t\\\n@@ -686,7 +521,7 @@ static void\n finalize_ssa_vuses (tree stmt)\n {\n   unsigned num, num_v_may_defs;\n-  int vuse_index;\n+  unsigned vuse_index;\n \n   /* Remove superfluous VUSE operands.  If the statement already has a\n    V_MAY_DEF operation for a variable 'a', then a VUSE for 'a' is not\n@@ -700,39 +535,35 @@ finalize_ssa_vuses (tree stmt)\n   The VUSE <a_2> is superfluous because it is implied by the V_MAY_DEF\n   operation.  */\n \n-  num = opbuild_num_elems (&build_vuses);\n-  num_v_may_defs = opbuild_num_elems (&build_v_may_defs);\n+  num = VEC_length (tree, build_vuses);\n+  num_v_may_defs = VEC_length (tree, build_v_may_defs);\n \n   if (num > 0 && num_v_may_defs > 0)\n     {\n-      int last = OPBUILD_LAST;\n-      vuse_index = opbuild_first (&build_vuses);\n-      for ( ; vuse_index != OPBUILD_LAST; )\n+      for (vuse_index = 0; vuse_index < VEC_length (tree, build_vuses); )\n         {\n \t  tree vuse;\n-\t  vuse = opbuild_elem_virtual (&build_vuses, vuse_index);\n+\t  vuse = VEC_index (tree, build_vuses, vuse_index);\n \t  if (TREE_CODE (vuse) != SSA_NAME)\n \t    {\n \t      var_ann_t ann = var_ann (vuse);\n \t      ann->in_vuse_list = 0;\n \t      if (ann->in_v_may_def_list)\n \t        {\n-\t\t  vuse_index = opbuild_remove_elem (&build_vuses, vuse_index, \n-\t\t\t\t\t\t    last);\n+\t\t  VEC_ordered_remove (tree, build_vuses, vuse_index);\n \t\t  continue;\n \t\t}\n \t    }\n-\t  last = vuse_index;\n-\t  vuse_index = opbuild_next (&build_vuses, vuse_index);\n+\t  vuse_index++;\n \t}\n     }\n   else\n     /* Clear out the in_list bits.  */\n-    for (vuse_index = opbuild_first (&build_vuses);\n-\t vuse_index != OPBUILD_LAST;\n-\t vuse_index = opbuild_next (&build_vuses, vuse_index))\n+    for (vuse_index = 0;\n+\t vuse_index < VEC_length (tree, build_vuses);\n+\t vuse_index++)\n       {\n-\ttree t = opbuild_elem_virtual (&build_vuses, vuse_index);\n+\ttree t = VEC_index (tree, build_vuses, vuse_index);\n \tif (TREE_CODE (t) != SSA_NAME)\n \t  {\n \t    var_ann_t ann = var_ann (t);\n@@ -745,15 +576,16 @@ finalize_ssa_vuses (tree stmt)\n   cleanup_v_may_defs ();\n                                                                               \n   /* Free the vuses build vector.  */\n-  opbuild_clear (&build_vuses);\n+  VEC_truncate (tree, build_vuses, 0);\n \n }\n                                                                               \n /* Return a new v_must_def operand vector for STMT, comparing to OLD_OPS_P.  */\n                                                                               \n #define FINALIZE_OPBUILD\tbuild_v_must_defs\n-#define FINALIZE_OPBUILD_ELEM(I)\topbuild_elem_virtual (&build_v_must_defs, (I))\n-#define FINALIZE_OPBUILD_BASE(I)\topbuild_elem_uid (&build_v_must_defs, (I))\n+#define FINALIZE_OPBUILD_ELEM(I)\tVEC_index (tree, build_v_must_defs, (I))\n+#define FINALIZE_OPBUILD_BASE(I)\tget_name_decl (VEC_index (tree,\t\\\n+\t\t\t\t\t\t\tbuild_v_must_defs, (I)))\n #define FINALIZE_FUNC\t\tfinalize_ssa_v_must_def_ops\n #define FINALIZE_ALLOC\t\talloc_mustdef\n #define FINALIZE_FREE\t\tfree_mustdefs\n@@ -763,8 +595,7 @@ finalize_ssa_vuses (tree stmt)\n #define FINALIZE_USE_PTR(PTR)\tMUSTDEF_KILL_PTR (PTR)\n #define FINALIZE_CORRECT_USE\tset_virtual_use_link\n #define FINALIZE_BASE_ZERO\t0\n-#define FINALIZE_BASE(VAR)\t((TREE_CODE (VAR) == SSA_NAME)\t\t\\\n-\t\t\t\t? DECL_UID (SSA_NAME_VAR (VAR)) : DECL_UID ((VAR)))\n+#define FINALIZE_BASE(VAR)\tget_name_decl (VAR)\n #define FINALIZE_BASE_TYPE\tunsigned\n #define FINALIZE_INITIALIZE(PTR, VAL, STMT)\t\t\t\t\\\n \t\t\t\t(PTR)->def_var = (VAL);\t\t\t\\\n@@ -785,7 +616,7 @@ finalize_ssa_v_must_defs (tree stmt)\n      having subvars, and have num >1, you have hit a bug. */\n \n   finalize_ssa_v_must_def_ops (stmt);\n-  opbuild_clear (&build_v_must_defs);\n+  VEC_truncate (tree, build_v_must_defs, 0);\n }\n \n \n@@ -807,11 +638,11 @@ finalize_ssa_stmt_operands (tree stmt)\n static inline void\n start_ssa_stmt_operands (void)\n {\n-  gcc_assert (opbuild_num_elems (&build_defs) == 0);\n-  gcc_assert (opbuild_num_elems (&build_uses) == 0);\n-  gcc_assert (opbuild_num_elems (&build_vuses) == 0);\n-  gcc_assert (opbuild_num_elems (&build_v_may_defs) == 0);\n-  gcc_assert (opbuild_num_elems (&build_v_must_defs) == 0);\n+  gcc_assert (VEC_length (tree, build_defs) == 0);\n+  gcc_assert (VEC_length (tree, build_uses) == 0);\n+  gcc_assert (VEC_length (tree, build_vuses) == 0);\n+  gcc_assert (VEC_length (tree, build_v_may_defs) == 0);\n+  gcc_assert (VEC_length (tree, build_v_must_defs) == 0);\n }\n \n \n@@ -820,7 +651,7 @@ start_ssa_stmt_operands (void)\n static inline void\n append_def (tree *def_p)\n {\n-  opbuild_append_real (&build_defs, def_p);\n+  VEC_safe_push (tree, heap, build_defs, (tree)def_p);\n }\n \n \n@@ -829,7 +660,7 @@ append_def (tree *def_p)\n static inline void\n append_use (tree *use_p)\n {\n-  opbuild_append_real (&build_uses, use_p);\n+  VEC_safe_push (tree, heap, build_uses, (tree)use_p);\n }\n \n \n@@ -848,7 +679,7 @@ append_v_may_def (tree var)\n       ann->in_v_may_def_list = 1;\n     }\n \n-  opbuild_append_virtual (&build_v_may_defs, var);\n+  VEC_safe_push (tree, heap, build_v_may_defs, (tree)var);\n }\n \n \n@@ -868,7 +699,7 @@ append_vuse (tree var)\n       ann->in_vuse_list = 1;\n     }\n \n-  opbuild_append_virtual (&build_vuses, var);\n+  VEC_safe_push (tree, heap, build_vuses, (tree)var);\n }\n \n \n@@ -880,11 +711,11 @@ append_v_must_def (tree var)\n   unsigned i;\n \n   /* Don't allow duplicate entries.  */\n-  for (i = 0; i < opbuild_num_elems (&build_v_must_defs); i++)\n-    if (var == opbuild_elem_virtual (&build_v_must_defs, i))\n+  for (i = 0; i < VEC_length (tree, build_v_must_defs); i++)\n+    if (var == VEC_index (tree, build_v_must_defs, i))\n       return;\n \n-  opbuild_append_virtual (&build_v_must_defs, var);\n+  VEC_safe_push (tree, heap, build_v_must_defs, (tree)var);\n }\n \n \n@@ -1014,6 +845,9 @@ build_ssa_operands (tree stmt)\n   start_ssa_stmt_operands ();\n \n   parse_ssa_operands (stmt);\n+  operand_build_sort_virtual (build_vuses);\n+  operand_build_sort_virtual (build_v_may_defs);\n+  operand_build_sort_virtual (build_v_must_defs);\n \n   finalize_ssa_stmt_operands (stmt);\n }\n@@ -1082,9 +916,9 @@ copy_virtual_operands (tree dest, tree src)\n   FOR_EACH_SSA_TREE_OPERAND (t, src, iter, SSA_OP_VMUSTDEF)\n     append_v_must_def (t);\n \n-  if (opbuild_num_elems (&build_vuses) == 0\n-      && opbuild_num_elems (&build_v_may_defs) == 0\n-      && opbuild_num_elems (&build_v_must_defs) == 0)\n+  if (VEC_length (tree, build_vuses) == 0\n+      && VEC_length (tree, build_v_may_defs) == 0\n+      && VEC_length (tree, build_v_must_defs) == 0)\n     return;\n \n   /* Now commit the virtual operands to this stmt.  */\n@@ -1148,29 +982,29 @@ create_ssa_artficial_load_stmt (tree new_stmt, tree old_stmt)\n   start_ssa_stmt_operands ();\n   parse_ssa_operands (new_stmt);\n \n-  for (x = 0; x < opbuild_num_elems (&build_vuses); x++)\n+  for (x = 0; x < VEC_length (tree, build_vuses); x++)\n     {\n-      tree t = opbuild_elem_virtual (&build_vuses, x);\n+      tree t = VEC_index (tree, build_vuses, x);\n       if (TREE_CODE (t) != SSA_NAME)\n \t{\n \t  var_ann_t ann = var_ann (t);\n \t  ann->in_vuse_list = 0;\n \t}\n     }\n    \n-  for (x = 0; x < opbuild_num_elems (&build_v_may_defs); x++)\n+  for (x = 0; x < VEC_length (tree, build_v_may_defs); x++)\n     {\n-      tree t = opbuild_elem_virtual (&build_v_may_defs, x);\n+      tree t = VEC_index (tree, build_v_may_defs, x);\n       if (TREE_CODE (t) != SSA_NAME)\n \t{\n \t  var_ann_t ann = var_ann (t);\n \t  ann->in_v_may_def_list = 0;\n \t}\n     }\n   /* Remove any virtual operands that were found.  */\n-  opbuild_clear (&build_v_may_defs);\n-  opbuild_clear (&build_v_must_defs);\n-  opbuild_clear (&build_vuses);\n+  VEC_truncate (tree, build_v_may_defs, 0);\n+  VEC_truncate (tree, build_v_must_defs, 0);\n+  VEC_truncate (tree, build_vuses, 0);\n \n   /* For each VDEF on the original statement, we want to create a\n      VUSE of the V_MAY_DEF result or V_MUST_DEF op on the new \n@@ -1972,7 +1806,6 @@ add_to_addressable_set (tree ref, bitmap *addresses_taken)\n static void\n add_call_clobber_ops (tree stmt, tree callee)\n {\n-  int i;\n   unsigned u;\n   tree t;\n   bitmap_iterator bi;\n@@ -2010,21 +1843,19 @@ add_call_clobber_ops (tree stmt, tree callee)\n       && (!not_read_b || bitmap_empty_p (not_read_b))\n       && (!not_written_b || bitmap_empty_p (not_written_b)))\n     {\n-      /* Process the caches in reverse order so we are always inserting at\n-         the head of the list.  */\n-      for (i = VEC_length (tree, clobbered_vuses) - 1; i >=0; i--)\n+      for (u = 0 ; u < VEC_length (tree, clobbered_vuses); u++)\n \t{\n-\t  t = VEC_index (tree, clobbered_vuses, i);\n+\t  t = VEC_index (tree, clobbered_vuses, u);\n \t  gcc_assert (TREE_CODE (t) != SSA_NAME);\n \t  var_ann (t)->in_vuse_list = 1;\n-\t  opbuild_append_virtual (&build_vuses, t);\n+\t  VEC_safe_push (tree, heap, build_vuses, (tree)t);\n \t}\n-      for (i = VEC_length (tree, clobbered_v_may_defs) - 1; i >= 0; i--)\n+      for (u = 0; u < VEC_length (tree, clobbered_v_may_defs); u++)\n \t{\n-\t  t = VEC_index (tree, clobbered_v_may_defs, i);\n+\t  t = VEC_index (tree, clobbered_v_may_defs, u);\n \t  gcc_assert (TREE_CODE (t) != SSA_NAME);\n \t  var_ann (t)->in_v_may_def_list = 1;\n-\t  opbuild_append_virtual (&build_v_may_defs, t);\n+\t  VEC_safe_push (tree, heap, build_v_may_defs, (tree)t);\n \t}\n       if (s_ann)\n \t{\n@@ -2079,22 +1910,18 @@ add_call_clobber_ops (tree stmt, tree callee)\n       VEC_truncate (tree, clobbered_v_may_defs, 0);\n \n       /* Now fill the clobbered cache with the values that have been found.  */\n-      for (i = opbuild_first (&build_vuses);\n-\t   i != OPBUILD_LAST;\n-\t   i = opbuild_next (&build_vuses, i))\n+      for (u = 0; u < VEC_length (tree, build_vuses); u++)\n \tVEC_safe_push (tree, heap, clobbered_vuses,\n-\t\t       opbuild_elem_virtual (&build_vuses, i));\n+\t\t       VEC_index (tree, build_vuses, u));\n \n-      gcc_assert (opbuild_num_elems (&build_vuses) \n+      gcc_assert (VEC_length (tree, build_vuses) \n \t\t  == VEC_length (tree, clobbered_vuses));\n \n-      for (i = opbuild_first (&build_v_may_defs);\n-\t   i != OPBUILD_LAST;\n-\t   i = opbuild_next (&build_v_may_defs, i))\n+      for (u = 0; u < VEC_length (tree, build_v_may_defs); u++)\n \tVEC_safe_push (tree, heap, clobbered_v_may_defs, \n-\t\t       opbuild_elem_virtual (&build_v_may_defs, i));\n+\t\t       VEC_index (tree, build_v_may_defs, u));\n \n-      gcc_assert (opbuild_num_elems (&build_v_may_defs) \n+      gcc_assert (VEC_length (tree, build_v_may_defs) \n \t\t  == VEC_length (tree, clobbered_v_may_defs));\n \n       ssa_call_clobbered_cache_valid = true;\n@@ -2108,7 +1935,6 @@ add_call_clobber_ops (tree stmt, tree callee)\n static void\n add_call_read_ops (tree stmt)\n {\n-  int i;\n   unsigned u;\n   tree t;\n   bitmap_iterator bi;\n@@ -2127,14 +1953,12 @@ add_call_read_ops (tree stmt)\n   /* If cache is valid, copy the elements into the build vector.  */\n   if (ssa_ro_call_cache_valid)\n     {\n-      for (i = VEC_length (tree, ro_call_vuses) - 1; i >=0 ; i--)\n+      for (u = 0; u < VEC_length (tree, ro_call_vuses); u++)\n \t{\n-\t  /* Process the caches in reverse order so we are always inserting at\n-\t     the head of the list.  */\n-\t  t = VEC_index (tree, ro_call_vuses, i);\n+\t  t = VEC_index (tree, ro_call_vuses, u);\n \t  gcc_assert (TREE_CODE (t) != SSA_NAME);\n \t  var_ann (t)->in_vuse_list = 1;\n-\t  opbuild_append_virtual (&build_vuses, t);\n+\t  VEC_safe_push (tree, heap, build_vuses, (tree)t);\n \t}\n       if (s_ann)\n \ts_ann->makes_aliased_loads = ro_call_aliased_loads;\n@@ -2158,13 +1982,11 @@ add_call_read_ops (tree stmt)\n   VEC_truncate (tree, ro_call_vuses, 0);\n \n   /* Now fill the clobbered cache with the values that have been found.  */\n-  for (i = opbuild_first (&build_vuses);\n-       i != OPBUILD_LAST;\n-       i = opbuild_next (&build_vuses, i))\n+  for (u = 0; u <  VEC_length (tree, build_vuses); u++)\n     VEC_safe_push (tree, heap, ro_call_vuses,\n-\t\t   opbuild_elem_virtual (&build_vuses, i));\n+\t\t   VEC_index (tree, build_vuses, u));\n \n-  gcc_assert (opbuild_num_elems (&build_vuses) \n+  gcc_assert (VEC_length (tree, build_vuses) \n \t      == VEC_length (tree, ro_call_vuses));\n \n   ssa_ro_call_cache_valid = true;"}, {"sha": "cc48e9ed742da0285647d456d5fe8976ea17d7e7", "filename": "gcc/tree-ssa-opfinalize.h", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3940b0e3d26190dbcfe86f0bc5f4a84b259c298/gcc%2Ftree-ssa-opfinalize.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3940b0e3d26190dbcfe86f0bc5f4a84b259c298/gcc%2Ftree-ssa-opfinalize.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-opfinalize.h?ref=f3940b0e3d26190dbcfe86f0bc5f4a84b259c298", "patch": "@@ -63,7 +63,7 @@ FINALIZE_ALLOC (void)\n static inline void\n FINALIZE_FUNC (tree stmt)\n {\n-  int new_i;\n+  unsigned new_i;\n   FINALIZE_TYPE *old_ops, *ptr, *last;\n   FINALIZE_BASE_TYPE old_base;\n   FINALIZE_TYPE new_list;\n@@ -77,8 +77,8 @@ FINALIZE_FUNC (tree stmt)\n   else\n     old_base = FINALIZE_BASE_ZERO;\n \n-  new_i = opbuild_first (&FINALIZE_OPBUILD);\n-  while (old_ops && new_i != OPBUILD_LAST)\n+  new_i = 0;\n+  while (old_ops && new_i < VEC_length (tree, FINALIZE_OPBUILD))\n     {\n       FINALIZE_BASE_TYPE new_base = FINALIZE_OPBUILD_BASE (new_i);\n       if (old_base == new_base)\n@@ -90,7 +90,7 @@ FINALIZE_FUNC (tree stmt)\n \t  FINALIZE_CORRECT_USE (FINALIZE_USE_PTR (last), stmt);\n #endif\n \t  old_ops = old_ops->next;\n-\t  new_i = opbuild_next (&FINALIZE_OPBUILD, new_i);\n+\t  new_i++;\n \t}\n       else\n         if (old_base < new_base)\n@@ -112,16 +112,14 @@ FINALIZE_FUNC (tree stmt)\n \t    FINALIZE_INITIALIZE (ptr, FINALIZE_OPBUILD_ELEM (new_i), stmt);\n \t    last->next = ptr;\n \t    last = ptr;\n-\t    new_i = opbuild_next (&FINALIZE_OPBUILD, new_i);\n+\t    new_i++;\n \t  }\n       if (old_ops)\n         old_base = FINALIZE_BASE (FINALIZE_ELEM (old_ops));\n     }\n \n   /* If there is anything remaining in the opbuild list, simply emit them.  */\n-  for ( ; \n-\tnew_i != OPBUILD_LAST; \n-\tnew_i = opbuild_next (&FINALIZE_OPBUILD, new_i))\n+  for ( ; new_i < VEC_length (tree, FINALIZE_OPBUILD); new_i++)\n     {\n       ptr = FINALIZE_ALLOC ();\n       FINALIZE_INITIALIZE (ptr, FINALIZE_OPBUILD_ELEM (new_i), stmt);\n@@ -154,7 +152,7 @@ FINALIZE_FUNC (tree stmt)\n     for (ptr = FINALIZE_OPS (stmt); ptr; ptr = ptr->next)\n       x++;\n \n-    gcc_assert (x == opbuild_num_elems (&FINALIZE_OPBUILD));\n+    gcc_assert (x == VEC_length (tree, FINALIZE_OPBUILD));\n   }\n #endif\n }"}]}