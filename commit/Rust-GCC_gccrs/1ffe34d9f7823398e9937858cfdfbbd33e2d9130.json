{"sha": "1ffe34d9f7823398e9937858cfdfbbd33e2d9130", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWZmZTM0ZDlmNzgyMzM5OGU5OTM3ODU4Y2ZkZmJiZDMzZTJkOTEzMA==", "commit": {"author": {"name": "Andrew Pinski", "email": "andrew_pinski@playstation.sony.com", "date": "2008-03-11T09:36:51Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2008-03-11T09:36:51Z"}, "message": "re PR tree-optimization/31358 (IV-OPTs produces a weird MEM_REF)\n\n2008-03-11  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n\tRichard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/31358\n\t* tree-ssa-loop-manip.c (create_iv): Call force_gimple_operand for\n\tthe step with a NULL_TREE.\n\t* tree-ssa-loop-ivopts.c (find_bivs): Convert the step\n\tto sizetype if type is a pointer type.\n\t(add_candidate_1): Don't convert the base and step to\n\tthe generic type if the orginal type is a pointer type.\n\t(add_iv_value_candidates): Use sizetype for the step\n\tif type is a pointer type.\n\t(cand_value_at): Likewise.\n\t* tree-ssa-address.c (add_to_parts): Use POINTER_PLUS_EXPR\n\tfor pointer types.\n\t* tree-affine.c (tree_to_aff_combination <POINTER_PLUS_EXPR>):\n\tDon't convert the tem affine to the type.\n\t(add_elt_to_tree): Use sizetype for the step if a pointer.\n\tUse POINTER_PLUS_EXPR for pointers.\n\t(aff_combination_to_tree): Use sizetype for the step if a\n\tpointer.\n\nCo-Authored-By: Richard Guenther <rguenther@suse.de>\n\nFrom-SVN: r133102", "tree": {"sha": "f1231d387b8e29a423766fa3401b01369f01515b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f1231d387b8e29a423766fa3401b01369f01515b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ffe34d9f7823398e9937858cfdfbbd33e2d9130", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ffe34d9f7823398e9937858cfdfbbd33e2d9130", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ffe34d9f7823398e9937858cfdfbbd33e2d9130", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ffe34d9f7823398e9937858cfdfbbd33e2d9130/comments", "author": null, "committer": null, "parents": [{"sha": "7f2ad78b6dbee7d3124ba5fb4f953a3c5e22abde", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f2ad78b6dbee7d3124ba5fb4f953a3c5e22abde", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f2ad78b6dbee7d3124ba5fb4f953a3c5e22abde"}], "stats": {"total": 85, "additions": 70, "deletions": 15}, "files": [{"sha": "3dae5cd52d8d7d51160c1255de2b99d6e1ebe384", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ffe34d9f7823398e9937858cfdfbbd33e2d9130/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ffe34d9f7823398e9937858cfdfbbd33e2d9130/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1ffe34d9f7823398e9937858cfdfbbd33e2d9130", "patch": "@@ -1,3 +1,25 @@\n+2008-03-11  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\tRichard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/31358\n+\t* tree-ssa-loop-manip.c (create_iv): Call force_gimple_operand for\n+\tthe step with a NULL_TREE.\n+\t* tree-ssa-loop-ivopts.c (find_bivs): Convert the step\n+\tto sizetype if type is a pointer type.\n+\t(add_candidate_1): Don't convert the base and step to\n+\tthe generic type if the orginal type is a pointer type.\n+\t(add_iv_value_candidates): Use sizetype for the step\n+\tif type is a pointer type.\n+\t(cand_value_at): Likewise.\n+\t* tree-ssa-address.c (add_to_parts): Use POINTER_PLUS_EXPR\n+\tfor pointer types.\n+\t* tree-affine.c (tree_to_aff_combination <POINTER_PLUS_EXPR>):\n+\tDon't convert the tem affine to the type.\n+\t(add_elt_to_tree): Use sizetype for the step if a pointer.\n+\tUse POINTER_PLUS_EXPR for pointers.\n+\t(aff_combination_to_tree): Use sizetype for the step if a\n+\tpointer.\n+\n 2008-03-10  Vladimir Makarov  <vmakarov@redhat.com>\n \n \t* config/i386/sse.md (ssse3_pmaddubswv8hi3, ssse3_pmaddubswv4hi3):"}, {"sha": "3a4d897b2d9b7a6915b14e749ee43d65c1381e18", "filename": "gcc/tree-affine.c", "status": "modified", "additions": 28, "deletions": 9, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ffe34d9f7823398e9937858cfdfbbd33e2d9130/gcc%2Ftree-affine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ffe34d9f7823398e9937858cfdfbbd33e2d9130/gcc%2Ftree-affine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-affine.c?ref=1ffe34d9f7823398e9937858cfdfbbd33e2d9130", "patch": "@@ -279,7 +279,6 @@ tree_to_aff_combination (tree expr, tree type, aff_tree *comb)\n     case POINTER_PLUS_EXPR:\n       tree_to_aff_combination (TREE_OPERAND (expr, 0), type, comb);\n       tree_to_aff_combination (TREE_OPERAND (expr, 1), sizetype, &tmp);\n-      aff_combination_convert (&tmp, type);\n       aff_combination_add (comb, &tmp);\n       return;\n \n@@ -350,29 +349,40 @@ add_elt_to_tree (tree expr, tree type, tree elt, double_int scale,\n \t\t aff_tree *comb)\n {\n   enum tree_code code;\n+  tree type1 = type;\n+  if (POINTER_TYPE_P (type))\n+    type1 = sizetype;\n \n   scale = double_int_ext_for_comb (scale, comb);\n-  elt = fold_convert (type, elt);\n+  elt = fold_convert (type1, elt);\n \n   if (double_int_one_p (scale))\n     {\n       if (!expr)\n-\treturn elt;\n+\treturn fold_convert (type, elt);\n \n+      if (POINTER_TYPE_P (type))\n+        return fold_build2 (POINTER_PLUS_EXPR, type, expr, elt);\n       return fold_build2 (PLUS_EXPR, type, expr, elt);\n     }\n \n   if (double_int_minus_one_p (scale))\n     {\n       if (!expr)\n-\treturn fold_build1 (NEGATE_EXPR, type, elt);\n+\treturn fold_convert (type, fold_build1 (NEGATE_EXPR, type1, elt));\n \n+      if (POINTER_TYPE_P (type))\n+\t{\n+\t  elt = fold_build1 (NEGATE_EXPR, type1, elt);\n+\t  return fold_build2 (POINTER_PLUS_EXPR, type, expr, elt);\n+\t}\n       return fold_build2 (MINUS_EXPR, type, expr, elt);\n     }\n \n   if (!expr)\n-    return fold_build2 (MULT_EXPR, type, elt,\n-\t\t\tdouble_int_to_tree (type, scale));\n+    return fold_convert (type,\n+\t\t\t fold_build2 (MULT_EXPR, type1, elt,\n+\t\t\t\t      double_int_to_tree (type1, scale)));\n \n   if (double_int_negative_p (scale))\n     {\n@@ -382,8 +392,14 @@ add_elt_to_tree (tree expr, tree type, tree elt, double_int scale,\n   else\n     code = PLUS_EXPR;\n \n-  elt = fold_build2 (MULT_EXPR, type, elt,\n-\t\t     double_int_to_tree (type, scale));\n+  elt = fold_build2 (MULT_EXPR, type1, elt,\n+\t\t     double_int_to_tree (type1, scale));\n+  if (POINTER_TYPE_P (type))\n+    {\n+      if (code == MINUS_EXPR)\n+        elt = fold_build1 (NEGATE_EXPR, type1, elt);\n+      return fold_build2 (POINTER_PLUS_EXPR, type, expr, elt);\n+    }\n   return fold_build2 (code, type, expr, elt);\n }\n \n@@ -396,6 +412,9 @@ aff_combination_to_tree (aff_tree *comb)\n   tree expr = comb->rest;\n   unsigned i;\n   double_int off, sgn;\n+  tree type1 = type;\n+  if (POINTER_TYPE_P (type))\n+    type1 = sizetype;\n \n   gcc_assert (comb->n == MAX_AFF_ELTS || comb->rest == NULL_TREE);\n \n@@ -415,7 +434,7 @@ aff_combination_to_tree (aff_tree *comb)\n       off = comb->offset;\n       sgn = double_int_one;\n     }\n-  return add_elt_to_tree (expr, type, double_int_to_tree (type, off), sgn,\n+  return add_elt_to_tree (expr, type, double_int_to_tree (type1, off), sgn,\n \t\t\t  comb);\n }\n "}, {"sha": "9b406ce06ef8a0f2d1553099dcdbdb3a8b9ef0e1", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ffe34d9f7823398e9937858cfdfbbd33e2d9130/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ffe34d9f7823398e9937858cfdfbbd33e2d9130/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=1ffe34d9f7823398e9937858cfdfbbd33e2d9130", "patch": "@@ -914,7 +914,12 @@ find_bivs (struct ivopts_data *data)\n       type = TREE_TYPE (PHI_RESULT (phi));\n       base = fold_convert (type, base);\n       if (step)\n-\tstep = fold_convert (type, step);\n+\t{\n+\t  if (POINTER_TYPE_P (type))\n+\t    step = fold_convert (sizetype, step);\n+\t  else\n+\t    step = fold_convert (type, step);\n+\t}\n \n       set_iv (data, PHI_RESULT (phi), base, step);\n       found = true;\n@@ -2040,7 +2045,9 @@ add_candidate_1 (struct ivopts_data *data,\n     {\n       orig_type = TREE_TYPE (base);\n       type = generic_type_for (orig_type);\n-      if (type != orig_type)\n+      /* Don't convert the base to the generic type for pointers as the generic\n+\t type is an integer type with the same size as the pointer type.  */\n+      if (type != orig_type && !POINTER_TYPE_P (orig_type))\n \t{\n \t  base = fold_convert (type, base);\n \t  step = fold_convert (type, step);\n@@ -2237,13 +2244,17 @@ add_iv_value_candidates (struct ivopts_data *data,\n {\n   unsigned HOST_WIDE_INT offset;\n   tree base;\n+  tree basetype;\n \n   add_candidate (data, iv->base, iv->step, false, use);\n \n   /* The same, but with initial value zero.  Make such variable important,\n      since it is generic enough so that possibly many uses may be based\n      on it.  */\n-  add_candidate (data, build_int_cst (TREE_TYPE (iv->base), 0),\n+  basetype = TREE_TYPE (iv->base);\n+  if (POINTER_TYPE_P (basetype))\n+    basetype = sizetype;\n+  add_candidate (data, build_int_cst (basetype, 0),\n \t\t iv->step, true, use);\n \n   /* Third, try removing the constant offset.  */\n@@ -3671,10 +3682,13 @@ cand_value_at (struct loop *loop, struct iv_cand *cand, tree at, tree niter,\n   aff_tree step, delta, nit;\n   struct iv *iv = cand->iv;\n   tree type = TREE_TYPE (iv->base);\n+  tree steptype = type;\n+  if (POINTER_TYPE_P (type))\n+    steptype = sizetype;\n \n-  tree_to_aff_combination (iv->step, type, &step);\n+  tree_to_aff_combination (iv->step, steptype, &step);\n   tree_to_aff_combination (niter, TREE_TYPE (niter), &nit);\n-  aff_combination_convert (&nit, type);\n+  aff_combination_convert (&nit, steptype);\n   aff_combination_mult (&nit, &step, &delta);\n   if (stmt_after_increment (loop, cand, at))\n     aff_combination_add (&delta, &step);"}, {"sha": "835b0062d8add10a98394daf85c18f4609e87ff7", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ffe34d9f7823398e9937858cfdfbbd33e2d9130/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ffe34d9f7823398e9937858cfdfbbd33e2d9130/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=1ffe34d9f7823398e9937858cfdfbbd33e2d9130", "patch": "@@ -104,7 +104,7 @@ create_iv (tree base, tree step, tree var, struct loop *loop,\n     }\n   /* Gimplify the step if necessary.  We put the computations in front of the\n      loop (i.e. the step should be loop invariant).  */\n-  step = force_gimple_operand (step, &stmts, true, var);\n+  step = force_gimple_operand (step, &stmts, true, NULL_TREE);\n   if (stmts)\n     bsi_insert_on_edge_immediate (pe, stmts);\n "}]}