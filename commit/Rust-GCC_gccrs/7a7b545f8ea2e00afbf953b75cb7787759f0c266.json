{"sha": "7a7b545f8ea2e00afbf953b75cb7787759f0c266", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2E3YjU0NWY4ZWEyZTAwYWZiZjk1M2I3NWNiNzc4Nzc1OWYwYzI2Ng==", "commit": {"author": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2017-08-12T09:07:12Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2017-08-12T09:07:12Z"}, "message": "[PR79542][Ada] Fix ICE in dwarf2out.c with nested func. inlining\n\nhttps://gcc.gnu.org/bugzilla/show_bug.cgi?id=79542 reports an ICE in\ndwarf2out.c for an Ada testcase built with optimization.\n\nThis crash happens during the late generation pass because\nadd_gnat_descriptive_type cannot find the type DIE corresponding to some\ndescriptive type after having tried to generate it. This is because the\nDIE was generated during the early generation pass, but then pruned by\nthe type pruning machinery. So why was it pruned?\n\nWe are in a situation where we have cloned types (because of inlining,\nIIUC) whose TYPE_NAME have non-null DECL_ABSTRACT_ORIGIN attributes. As\na consequence:\n\n  * In modified_type_die, the \"handle C typedef types\" part calls\n    gen_type_die on the cloned type.\n\n  * gen_type_die matches a typedef variant, and then calls gen_decl_die\n    on its TYPE_NAME, which will end up calling gen_typedef_die.\n\n  * gen_typedef_die checks decl_ultimate_origin for this TYPE_DECL, and\n    finds one, so it only adds a DW_AT_abstract_origin attribute to the\n    DW_TAG_typedef DIE, but the cloned type itself does not get its own\n    DIE.\n\n  * Back in modified_type_die, the call to lookup_type_die on the type\n    passed to gen_type_die returns NULL.\n\nIn the end, whole type trees, i.e. the ones referenced by\nDECL_ABSTRACT_ORIGIN attributes, are never referenced from type pruning\n\"roots\" and are thus pruned. The descriptive type at stake here is one\nof them, hence the assertion failure.\n\nThis patch attemps to fix that with what seems to be the most sensible\nthing to do in my opinion: updating the \"handle C typedef types\" part in\nmodified_type_die to check decl_ultimate_origin before calling\ngen_type_die: if that function returns something not null, then we know\nthat gen_type_die/gen_typedef_die will not generate a DIE for the input\ntype, so we try to process the ultimate origin instead. It also updates\nin a similar way gen_type_die_with_usage, assert that when\ngen_typedef_die is called on nodes that have an ultimate origin, this\norigin is themselves.\n\ngcc/\n\tPR ada/79542\n\t* dwarf2out.c (modified_type_die): For C typedef types that have\n\tan ultimate origin, process the ultimate origin instead of the\n\tinput type.\n\t(gen_typedef_die): Assert that input DECLs have no ultimate\n\torigin.\n\t(gen_type_die_with_usage): For typedef variants that have an\n\tultimate origin, just call gen_decl_die on the original DECL.\n\t(process_scope_var): Avoid creating DIEs for local typedefs and\n\tconcrete static variables.\n\ngcc/testsuite/\n\n\tPR ada/79542\n\t* gnat.dg/debug13.ads, gnat.dg/debug13.adb: New testcase.\n\nFrom-SVN: r251066", "tree": {"sha": "815e31380890e6c3c5aa4d41111eb531a4cd6d5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/815e31380890e6c3c5aa4d41111eb531a4cd6d5d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a7b545f8ea2e00afbf953b75cb7787759f0c266", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a7b545f8ea2e00afbf953b75cb7787759f0c266", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a7b545f8ea2e00afbf953b75cb7787759f0c266", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a7b545f8ea2e00afbf953b75cb7787759f0c266/comments", "author": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ff97dd826e77fa9ee1f3c89a73e2cee855cf5fb9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff97dd826e77fa9ee1f3c89a73e2cee855cf5fb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff97dd826e77fa9ee1f3c89a73e2cee855cf5fb9"}], "stats": {"total": 204, "additions": 147, "deletions": 57}, "files": [{"sha": "bbe6658766958efdce8b6c2ae39541f5a9d0bda1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a7b545f8ea2e00afbf953b75cb7787759f0c266/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a7b545f8ea2e00afbf953b75cb7787759f0c266/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7a7b545f8ea2e00afbf953b75cb7787759f0c266", "patch": "@@ -1,3 +1,16 @@\n+2017-08-12  Pierre-Marie de Rodat  <derodat@adacore.com>\n+\n+\tPR ada/79542\n+\t* dwarf2out.c (modified_type_die): For C typedef types that have\n+\tan ultimate origin, process the ultimate origin instead of the\n+\tinput type.\n+\t(gen_typedef_die): Assert that input DECLs have no ultimate\n+\torigin.\n+\t(gen_type_die_with_usage): For typedef variants that have an\n+\tultimate origin, just call gen_decl_die on the original DECL.\n+\t(process_scope_var): Avoid creating DIEs for local typedefs and\n+\tconcrete static variables.\n+\n 2017-08-12  Alan Modra  <amodra@gmail.com>\n \n \tPR target/81170"}, {"sha": "917ab9fa58a3e772f422f3d276b83a7846beaddb", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 86, "deletions": 57, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a7b545f8ea2e00afbf953b75cb7787759f0c266/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a7b545f8ea2e00afbf953b75cb7787759f0c266/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=7a7b545f8ea2e00afbf953b75cb7787759f0c266", "patch": "@@ -12506,6 +12506,15 @@ modified_type_die (tree type, int cv_quals, bool reverse,\n \n       if (qualified_type == dtype)\n \t{\n+\t  tree origin = decl_ultimate_origin (name);\n+\n+\t  /* Typedef variants that have an abstract origin don't get their own\n+\t     type DIE (see gen_typedef_die), so fall back on the ultimate\n+\t     abstract origin instead.  */\n+\t  if (origin != NULL)\n+\t    return modified_type_die (TREE_TYPE (origin), cv_quals, reverse,\n+\t\t\t\t      context_die);\n+\n \t  /* For a named type, use the typedef.  */\n \t  gen_type_die (qualified_type, context_die);\n \t  return lookup_type_die (qualified_type);\n@@ -24296,7 +24305,7 @@ static void\n gen_typedef_die (tree decl, dw_die_ref context_die)\n {\n   dw_die_ref type_die;\n-  tree origin;\n+  tree type;\n \n   if (TREE_ASM_WRITTEN (decl))\n     {\n@@ -24305,75 +24314,71 @@ gen_typedef_die (tree decl, dw_die_ref context_die)\n       return;\n     }\n \n+  /* As we avoid creating DIEs for local typedefs (see decl_ultimate_origin\n+     checks in process_scope_var and modified_type_die), this should be called\n+     only for original types.  */\n+  gcc_assert (decl_ultimate_origin (decl) == NULL);\n+\n   TREE_ASM_WRITTEN (decl) = 1;\n   type_die = new_die (DW_TAG_typedef, context_die, decl);\n-  origin = decl_ultimate_origin (decl);\n-  if (origin != NULL)\n-    add_abstract_origin_attribute (type_die, origin);\n-  else\n+\n+  add_name_and_src_coords_attributes (type_die, decl);\n+  if (DECL_ORIGINAL_TYPE (decl))\n     {\n-      tree type = TREE_TYPE (decl);\n+      type = DECL_ORIGINAL_TYPE (decl);\n+      if (type == error_mark_node)\n+\treturn;\n \n+      gcc_assert (type != TREE_TYPE (decl));\n+      equate_type_number_to_die (TREE_TYPE (decl), type_die);\n+    }\n+  else\n+    {\n+      type = TREE_TYPE (decl);\n       if (type == error_mark_node)\n \treturn;\n \n-      add_name_and_src_coords_attributes (type_die, decl);\n-      if (DECL_ORIGINAL_TYPE (decl))\n+      if (is_naming_typedef_decl (TYPE_NAME (type)))\n \t{\n-\t  type = DECL_ORIGINAL_TYPE (decl);\n+\t  /* Here, we are in the case of decl being a typedef naming\n+\t     an anonymous type, e.g:\n+\t\t typedef struct {...} foo;\n+\t     In that case TREE_TYPE (decl) is not a typedef variant\n+\t     type and TYPE_NAME of the anonymous type is set to the\n+\t     TYPE_DECL of the typedef. This construct is emitted by\n+\t     the C++ FE.\n \n-\t  if (type == error_mark_node)\n-\t    return;\n+\t     TYPE is the anonymous struct named by the typedef\n+\t     DECL. As we need the DW_AT_type attribute of the\n+\t     DW_TAG_typedef to point to the DIE of TYPE, let's\n+\t     generate that DIE right away. add_type_attribute\n+\t     called below will then pick (via lookup_type_die) that\n+\t     anonymous struct DIE.  */\n+\t  if (!TREE_ASM_WRITTEN (type))\n+\t    gen_tagged_type_die (type, context_die, DINFO_USAGE_DIR_USE);\n \n-\t  gcc_assert (type != TREE_TYPE (decl));\n-\t  equate_type_number_to_die (TREE_TYPE (decl), type_die);\n-\t}\n-      else\n-\t{\n-\t  if (is_naming_typedef_decl (TYPE_NAME (type)))\n-\t    {\n-\t      /* Here, we are in the case of decl being a typedef naming\n-\t         an anonymous type, e.g:\n-\t             typedef struct {...} foo;\n-\t         In that case TREE_TYPE (decl) is not a typedef variant\n-\t         type and TYPE_NAME of the anonymous type is set to the\n-\t         TYPE_DECL of the typedef. This construct is emitted by\n-\t         the C++ FE.\n-\n-\t         TYPE is the anonymous struct named by the typedef\n-\t         DECL. As we need the DW_AT_type attribute of the\n-\t         DW_TAG_typedef to point to the DIE of TYPE, let's\n-\t         generate that DIE right away. add_type_attribute\n-\t         called below will then pick (via lookup_type_die) that\n-\t         anonymous struct DIE.  */\n-\t      if (!TREE_ASM_WRITTEN (type))\n-\t        gen_tagged_type_die (type, context_die, DINFO_USAGE_DIR_USE);\n-\n-\t      /* This is a GNU Extension.  We are adding a\n-\t\t DW_AT_linkage_name attribute to the DIE of the\n-\t\t anonymous struct TYPE.  The value of that attribute\n-\t\t is the name of the typedef decl naming the anonymous\n-\t\t struct.  This greatly eases the work of consumers of\n-\t\t this debug info.  */\n-\t      add_linkage_name_raw (lookup_type_die (type), decl);\n-\t    }\n+\t  /* This is a GNU Extension.  We are adding a\n+\t     DW_AT_linkage_name attribute to the DIE of the\n+\t     anonymous struct TYPE.  The value of that attribute\n+\t     is the name of the typedef decl naming the anonymous\n+\t     struct.  This greatly eases the work of consumers of\n+\t     this debug info.  */\n+\t  add_linkage_name_raw (lookup_type_die (type), decl);\n \t}\n+    }\n \n-      add_type_attribute (type_die, type, decl_quals (decl), false,\n-\t\t\t  context_die);\n-\n-      if (is_naming_typedef_decl (decl))\n-\t/* We want that all subsequent calls to lookup_type_die with\n-\t   TYPE in argument yield the DW_TAG_typedef we have just\n-\t   created.  */\n-\tequate_type_number_to_die (type, type_die);\n+  add_type_attribute (type_die, type, decl_quals (decl), false,\n+\t\t      context_die);\n \n-      type = TREE_TYPE (decl);\n+  if (is_naming_typedef_decl (decl))\n+    /* We want that all subsequent calls to lookup_type_die with\n+       TYPE in argument yield the DW_TAG_typedef we have just\n+       created.  */\n+    equate_type_number_to_die (type, type_die);\n \n-      add_alignment_attribute (type_die, type);\n+  add_alignment_attribute (type_die, TREE_TYPE (decl));\n \n-      add_accessibility_attribute (type_die, decl);\n-    }\n+  add_accessibility_attribute (type_die, decl);\n \n   if (DECL_ABSTRACT_P (decl))\n     equate_decl_number_to_die (decl, type_die);\n@@ -24485,15 +24490,23 @@ gen_type_die_with_usage (tree type, dw_die_ref context_die,\n       if (TREE_ASM_WRITTEN (type))\n \treturn;\n \n+      tree name = TYPE_NAME (type);\n+      tree origin = decl_ultimate_origin (name);\n+      if (origin != NULL)\n+\t{\n+\t  gen_decl_die (origin, NULL, NULL, context_die);\n+\t  return;\n+\t}\n+\n       /* Prevent broken recursion; we can't hand off to the same type.  */\n-      gcc_assert (DECL_ORIGINAL_TYPE (TYPE_NAME (type)) != type);\n+      gcc_assert (DECL_ORIGINAL_TYPE (name) != type);\n \n       /* Give typedefs the right scope.  */\n       context_die = scope_die_for (type, context_die);\n \n       TREE_ASM_WRITTEN (type) = 1;\n \n-      gen_decl_die (TYPE_NAME (type), NULL, NULL, context_die);\n+      gen_decl_die (name, NULL, NULL, context_die);\n       return;\n     }\n \n@@ -24812,6 +24825,22 @@ process_scope_var (tree stmt, tree decl, tree origin, dw_die_ref context_die)\n   else\n     die = NULL;\n \n+  /* Avoid creating DIEs for local typedefs and concrete static variables that\n+     will only be pruned later.  */\n+  if ((origin || decl_ultimate_origin (decl))\n+      && (TREE_CODE (decl_or_origin) == TYPE_DECL\n+\t  || (VAR_P (decl_or_origin) && TREE_STATIC (decl_or_origin))))\n+    {\n+      origin = decl_ultimate_origin (decl_or_origin);\n+      if (decl && VAR_P (decl) && die != NULL)\n+\t{\n+\t  die = lookup_decl_die (origin);\n+\t  if (die != NULL)\n+\t    equate_decl_number_to_die (decl, die);\n+\t}\n+      return;\n+    }\n+\n   if (die != NULL && die->die_parent == NULL)\n     add_child_die (context_die, die);\n   else if (TREE_CODE (decl_or_origin) == IMPORTED_DECL)"}, {"sha": "e13b30ba25062a89f87b4c3a473a85119e0710fa", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a7b545f8ea2e00afbf953b75cb7787759f0c266/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a7b545f8ea2e00afbf953b75cb7787759f0c266/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7a7b545f8ea2e00afbf953b75cb7787759f0c266", "patch": "@@ -1,3 +1,8 @@\n+2017-08-12  Pierre-Marie de Rodat  <derodat@adacore.com>\n+\n+\tPR ada/79542\n+\t* gnat.dg/debug13.ads, gnat.dg/debug13.adb: New testcase.\n+\n 2017-08-11  Marek Polacek  <polacek@redhat.com>\n \n \tPR c/81795"}, {"sha": "4b94b3e6bf16417f1185b83472c32706409ad7a7", "filename": "gcc/testsuite/gnat.dg/debug13.adb", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a7b545f8ea2e00afbf953b75cb7787759f0c266/gcc%2Ftestsuite%2Fgnat.dg%2Fdebug13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a7b545f8ea2e00afbf953b75cb7787759f0c266/gcc%2Ftestsuite%2Fgnat.dg%2Fdebug13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fdebug13.adb?ref=7a7b545f8ea2e00afbf953b75cb7787759f0c266", "patch": "@@ -0,0 +1,38 @@\n+--  { dg-options \"-cargs -O2 -g -margs\" }\n+\n+package body Debug13 is\n+\n+   procedure Compile (P : Natural)\n+   is\n+      Max_Pos : constant Natural := P;\n+      type Position_Set is array (1 .. Max_Pos) of Boolean;\n+\n+      Empty  : constant Position_Set := (others => False);\n+\n+      type Position_Set_Array is array (1 .. Max_Pos) of Position_Set;\n+\n+      Follow  : Position_Set_Array := (others => Empty);\n+\n+      function Get_Follows return Position_Set;\n+\n+      procedure Make_DFA;\n+\n+      function Get_Follows return Position_Set is\n+         Result : Position_Set := Empty;\n+      begin\n+         Result := Result or Follow (1);\n+\n+         return Result;\n+      end Get_Follows;\n+\n+      procedure Make_DFA is\n+         Next   : constant Position_Set := Get_Follows;\n+      begin\n+         null;\n+      end Make_DFA;\n+\n+   begin\n+      Make_DFA;\n+   end Compile;\n+\n+end Debug13;"}, {"sha": "512a9ef75bbab0ad0664a2bb891c88f6effdf42b", "filename": "gcc/testsuite/gnat.dg/debug13.ads", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a7b545f8ea2e00afbf953b75cb7787759f0c266/gcc%2Ftestsuite%2Fgnat.dg%2Fdebug13.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a7b545f8ea2e00afbf953b75cb7787759f0c266/gcc%2Ftestsuite%2Fgnat.dg%2Fdebug13.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fdebug13.ads?ref=7a7b545f8ea2e00afbf953b75cb7787759f0c266", "patch": "@@ -0,0 +1,5 @@\n+package Debug13 is\n+\n+   procedure Compile (P : Natural);\n+\n+end Debug13;"}]}