{"sha": "2d83f07035a5ca542ba42a858f39a94026b4f6ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmQ4M2YwNzAzNWE1Y2E1NDJiYTQyYTg1OGYzOWE5NDAyNmI0ZjZhZQ==", "commit": {"author": {"name": "Janis Johnson", "email": "janis@gcc.gnu.org", "date": "2007-04-24T19:29:34Z"}, "committer": {"name": "Janis Johnson", "email": "janis@gcc.gnu.org", "date": "2007-04-24T19:29:34Z"}, "message": "rs6000.c (function_arg_advance): For 32-bit ELF ABI...\n\n\t* config/rs6000/rs6000.c (function_arg_advance): For 32-bit ELF ABI,\n\texpand on the comment about _Decimal128 arguments and check the\n\tinteger result of the modulus operation; for 64-bit ELF ABI, ensure\n\tthat _Decimal128 argument uses even/odd register pair.\n\t(function_arg): For 32-bit ELF ABI, expand on the comment about\n\t_Decimal128 arguments and check the integer result of the modulus\n\toperation; for 64-bit ELF ABI, ensure that _Decimal128 argument\n\tuses even/odd register pair.\ntestsuite/\n\t* gcc.target/powerpc/ppc32-abi-dfp-1.c: New test.\n\t* gcc.target/powerpc/ppc64-abi-dfp-1.c: New test.\n\nFrom-SVN: r124116", "tree": {"sha": "7eefd836e127548366c12356ea02af0f40754fc9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7eefd836e127548366c12356ea02af0f40754fc9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2d83f07035a5ca542ba42a858f39a94026b4f6ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d83f07035a5ca542ba42a858f39a94026b4f6ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d83f07035a5ca542ba42a858f39a94026b4f6ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d83f07035a5ca542ba42a858f39a94026b4f6ae/comments", "author": null, "committer": null, "parents": [{"sha": "b883ab57fad6a9e6b0a2b40f3c512612bf3192ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b883ab57fad6a9e6b0a2b40f3c512612bf3192ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b883ab57fad6a9e6b0a2b40f3c512612bf3192ee"}], "stats": {"total": 589, "additions": 583, "deletions": 6}, "files": [{"sha": "7f72336a82a3b7790510f14db273f593ba41f265", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d83f07035a5ca542ba42a858f39a94026b4f6ae/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d83f07035a5ca542ba42a858f39a94026b4f6ae/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2d83f07035a5ca542ba42a858f39a94026b4f6ae", "patch": "@@ -1,3 +1,11 @@\n+2007-04-24  Janis Johnson  <janis187@us.ibm.com>\n+\n+\t* config/rs6000/rs6000.c (function_arg_advance): For 32-bit ELF ABI,\n+\texpand on the comment about _Decimal128 arguments and check the\n+\tinteger result of the modulus operation; for 64-bit ELF ABI, ensure\n+\tthat _Decimal128 argument uses even/odd register pair.\n+\t(function_arg): Ditto.\n+\n 2007-04-24  Hui-May Chang <hm.chang@apple.com>\n \n \t* reload1.c (merge_assigned_reloads) : Do not merge a RELOAD_OTHER"}, {"sha": "9172e28de043a5ee5774f8fa19322b8042ffd820", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d83f07035a5ca542ba42a858f39a94026b4f6ae/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d83f07035a5ca542ba42a858f39a94026b4f6ae/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=2d83f07035a5ca542ba42a858f39a94026b4f6ae", "patch": "@@ -5047,8 +5047,9 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t      || mode == DDmode || mode == TDmode\n \t      || (mode == TFmode && !TARGET_IEEEQUAD)))\n \t{\n-\t  /* _Decimal128 must use an even/odd register pair.  */\n-\t  if (mode == TDmode && cum->fregno % 2)\n+\t  /* _Decimal128 must use an even/odd register pair.  This assumes\n+\t     that the register number is odd when fregno is odd.  */\n+\t  if (mode == TDmode && (cum->fregno % 2) == 1)\n \t    cum->fregno++;\n \n \t  if (cum->fregno + (mode == TFmode || mode == TDmode ? 1 : 0)\n@@ -5111,7 +5112,14 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n       if (SCALAR_FLOAT_MODE_P (mode)\n \t  && mode != SDmode\n \t  && TARGET_HARD_FLOAT && TARGET_FPRS)\n-\tcum->fregno += (GET_MODE_SIZE (mode) + 7) >> 3;\n+\t{\n+\t  /* _Decimal128 must be passed in an even/odd float register pair.\n+\t     This assumes that the register number is odd when fregno is\n+\t     odd.  */\n+\t  if (mode == TDmode && (cum->fregno % 2) == 1)\n+\t    cum->fregno++;\n+\t  cum->fregno += (GET_MODE_SIZE (mode) + 7) >> 3;\n+\t}\n \n       if (TARGET_DEBUG_ARG)\n \t{\n@@ -5603,8 +5611,9 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t      || (mode == TFmode && !TARGET_IEEEQUAD)\n \t      || mode == DDmode || mode == TDmode))\n \t{\n-\t  /* _Decimal128 must use an even/odd register pair.  */\n-\t  if (mode == TDmode && cum->fregno % 2)\n+\t  /* _Decimal128 must use an even/odd register pair.  This assumes\n+\t     that the register number is odd when fregno is odd.  */\n+\t  if (mode == TDmode && (cum->fregno % 2) == 1)\n \t    cum->fregno++;\n \n \t  if (cum->fregno + (mode == TFmode || mode == TDmode ? 1 : 0)\n@@ -5638,6 +5647,11 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n     {\n       int align_words = rs6000_parm_start (mode, type, cum->words);\n \n+      /* _Decimal128 must be passed in an even/odd float register pair.\n+\t This assumes that the register number is odd when fregno is odd.  */\n+      if (mode == TDmode && (cum->fregno % 2) == 1)\n+\tcum->fregno++;\n+\n       if (USE_FP_FOR_ARG_P (cum, mode, type))\n \t{\n \t  rtx rvec[GP_ARG_NUM_REG + 1];"}, {"sha": "0504789f109ba910773e9139c0f413565e49faf4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d83f07035a5ca542ba42a858f39a94026b4f6ae/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d83f07035a5ca542ba42a858f39a94026b4f6ae/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2d83f07035a5ca542ba42a858f39a94026b4f6ae", "patch": "@@ -1,4 +1,9 @@\n-2007-04-24  Hui-May Chang <hm.chang@apple.com>\n+2007-04-24  Janis Johnson  <janis187@us.ibm.com>\n+\n+\t* gcc.target/powerpc/ppc32-abi-dfp-1.c: New test.\n+\t* gcc.target/powerpc/ppc64-abi-dfp-1.c: New test.\n+\n+2007-04-24  Hui-May Chang  <hm.chang@apple.com>\n \n \t* gcc.target/i386/reload-1.c. New.\n "}, {"sha": "15f3372f58f97156668cfe1d46abc15d11938b69", "filename": "gcc/testsuite/gcc.target/powerpc/ppc32-abi-dfp-1.c", "status": "added", "additions": 232, "deletions": 0, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d83f07035a5ca542ba42a858f39a94026b4f6ae/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc32-abi-dfp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d83f07035a5ca542ba42a858f39a94026b4f6ae/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc32-abi-dfp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc32-abi-dfp-1.c?ref=2d83f07035a5ca542ba42a858f39a94026b4f6ae", "patch": "@@ -0,0 +1,232 @@\n+/* { dg-do run { target { powerpc*-*-* && { ilp32 && dfprt } } } } */\n+/* { dg-options \"-std=gnu99 -O2 -fno-strict-aliasing\" } */\n+\n+/* Testcase to check for ABI compliance of parameter passing\n+   for the PowerPC ELF ABI for decimal float values.  */\n+\n+extern void abort (void);\n+int failcnt = 0;\n+\n+/* Support compiling the test to report individual failures; default is\n+   to abort as soon as a check fails.  */\n+#ifdef DBG\n+#include <stdio.h>\n+#define FAILURE { printf (\"failed at line %d\\n\", __LINE__); failcnt++; }\n+#else\n+#define FAILURE abort ();\n+#endif\n+\n+typedef struct\n+{\n+  int pad;\n+  _Decimal32 d;\n+} d32parm_t;\n+\n+typedef struct\n+{\n+  unsigned int gprs[8];\n+  double fprs[8];\n+} reg_parms_t;\n+\n+reg_parms_t gparms;\n+\n+\n+/* Testcase could break on future gcc's, if parameter regs\n+   are changed before this asm.  */\n+\n+#define save_parms(lparms)\t\t\t\t\\\n+    asm volatile (\"lis 11,gparms@ha\\n\\t\"\t\t\\\n+                  \"la 11,gparms@l(11)\\n\\t\"\t\t\\\n+                  \"st 3,0(11)\\n\\t\"\t\t        \\\n+\t          \"st 4,4(11)\\n\\t\"\t\t\t\\\n+\t          \"st 5,8(11)\\n\\t\"\t\t\t\\\n+\t          \"st 6,12(11)\\n\\t\"\t\t\t\\\n+\t          \"st 7,16(11)\\n\\t\"\t\t\t\\\n+\t          \"st 8,20(11)\\n\\t\"\t\t\t\\\n+\t          \"st 9,24(11)\\n\\t\"\t\t\t\\\n+\t          \"st 10,28(11)\\n\\t\"\t\t\t\\\n+                  \"stfd 1,32(11)\\n\\t\"\t\t\t\\\n+\t          \"stfd 2,40(11)\\n\\t\"\t\t\t\\\n+\t          \"stfd 3,48(11)\\n\\t\"\t\t\t\\\n+\t          \"stfd 4,56(11)\\n\\t\"\t\t\t\\\n+\t          \"stfd 5,64(11)\\n\\t\"\t\t\t\\\n+\t          \"stfd 6,72(11)\\n\\t\"\t\t\t\\\n+\t          \"stfd 7,80(11)\\n\\t\"\t\t\t\\\n+\t          \"stfd 8,88(11)\\n\\t\":::\"11\", \"memory\");  \\\n+                  lparms = gparms;\n+\n+typedef struct sf\n+{\n+  struct sf *backchain;\n+  int a1;\n+  unsigned int slot[200];\n+} stack_frame_t;\n+\n+/* Fill up floating point registers with double arguments, forcing\n+   decimal float arguments into the parameter save area.  */\n+void __attribute__ ((noinline))\n+func0 (double a1, double a2, double a3, double a4, double a5,\n+       double a6, double a7, double a8, _Decimal64 a9, _Decimal128 a10)\n+{\n+  reg_parms_t lparms;\n+  stack_frame_t *sp;\n+\n+  save_parms (lparms);\n+  sp = __builtin_frame_address (0);\n+  sp = sp->backchain;\n+\n+  if (a1 != lparms.fprs[0]) FAILURE\n+  if (a2 != lparms.fprs[1]) FAILURE\n+  if (a3 != lparms.fprs[2]) FAILURE\n+  if (a4 != lparms.fprs[3]) FAILURE\n+  if (a5 != lparms.fprs[4]) FAILURE\n+  if (a6 != lparms.fprs[5]) FAILURE\n+  if (a7 != lparms.fprs[6]) FAILURE\n+  if (a8 != lparms.fprs[7]) FAILURE\n+  if (a9 != *(_Decimal64 *)&sp->slot[0]) FAILURE\n+  if (a10 != *(_Decimal128 *)&sp->slot[2]) FAILURE\n+}\n+\n+/* Alternate 64-bit and 128-bit decimal float arguments, checking that\n+   _Decimal128 is always passed in even/odd register pairs.  */\n+void __attribute__ ((noinline))\n+func1 (_Decimal64 a1, _Decimal128 a2, _Decimal64 a3, _Decimal128 a4,\n+       _Decimal64 a5, _Decimal128 a6, _Decimal64 a7, _Decimal128 a8)\n+{\n+  reg_parms_t lparms;\n+  stack_frame_t *sp;\n+\n+  save_parms (lparms);\n+  sp = __builtin_frame_address (0);\n+  sp = sp->backchain;\n+\n+  if (a1 != *(_Decimal64 *)&lparms.fprs[0]) FAILURE\t/* f1 */\n+  if (a2 != *(_Decimal128 *)&lparms.fprs[1]) FAILURE\t/* f2 & f3 */\n+  if (a3 != *(_Decimal64 *)&lparms.fprs[3]) FAILURE\t/* f4 */\n+  if (a4 != *(_Decimal128 *)&lparms.fprs[5]) FAILURE\t/* f6 & f7 */\n+  if (a5 != *(_Decimal64 *)&lparms.fprs[7]) FAILURE\t/* f8 */\n+  if (a6 != *(_Decimal128 *)&sp->slot[0]) FAILURE\n+  if (a7 != *(_Decimal64 *)&sp->slot[4]) FAILURE\n+  if (a8 != *(_Decimal128 *)&sp->slot[6]) FAILURE\n+}\n+\n+void __attribute__ ((noinline))\n+func2 (_Decimal128 a1, _Decimal64 a2, _Decimal128 a3, _Decimal64 a4,\n+       _Decimal128 a5, _Decimal64 a6, _Decimal128 a7, _Decimal64 a8)\n+{\n+  reg_parms_t lparms;\n+  stack_frame_t *sp;\n+\n+  save_parms (lparms);\n+  sp = __builtin_frame_address (0);\n+  sp = sp->backchain;\n+\n+  if (a1 != *(_Decimal128 *)&lparms.fprs[1]) FAILURE\t/* f2 & f3 */\n+  if (a2 != *(_Decimal64 *)&lparms.fprs[3]) FAILURE\t/* f4 */\n+  if (a3 != *(_Decimal128 *)&lparms.fprs[5]) FAILURE\t/* f6 & f7 */\n+  if (a4 != *(_Decimal64 *)&lparms.fprs[7]) FAILURE\t/* f8 */\n+  if (a5 != *(_Decimal128 *)&sp->slot[0]) FAILURE\n+  if (a6 != *(_Decimal64 *)&sp->slot[4]) FAILURE\n+  if (a7 != *(_Decimal128 *)&sp->slot[6]) FAILURE\n+  if (a8 != *(_Decimal64 *)&sp->slot[10]) FAILURE\n+}\n+\n+void __attribute__ ((noinline))\n+func3 (_Decimal64 a1, _Decimal128 a2, _Decimal64 a3, _Decimal128 a4,\n+       _Decimal64 a5)\n+{\n+  reg_parms_t lparms;\n+  stack_frame_t *sp;\n+\n+  save_parms (lparms);\n+  sp = __builtin_frame_address (0);\n+  sp = sp->backchain;\n+\n+  if (a1 != *(_Decimal64 *)&lparms.fprs[0]) FAILURE\t/* f1 */\n+  if (a2 != *(_Decimal128 *)&lparms.fprs[1]) FAILURE\t/* f2 & f3 */\n+  if (a3 != *(_Decimal64 *)&lparms.fprs[3]) FAILURE\t/* f4 */\n+  if (a4 != *(_Decimal128 *)&lparms.fprs[5]) FAILURE\t/* f6 & f7 */\n+  if (a5 != *(_Decimal128 *)&sp->slot[0]) FAILURE\n+}\n+\n+void __attribute__ ((noinline))\n+func4 (_Decimal32 a1, _Decimal32 a2, _Decimal32 a3, _Decimal32 a4,\n+       _Decimal32 a5, _Decimal32 a6, _Decimal32 a7, _Decimal32 a8,\n+       _Decimal32 a9, _Decimal32 a10, _Decimal32 a11, _Decimal32 a12,\n+       _Decimal32 a13, _Decimal32 a14, _Decimal32 a15, _Decimal32 a16)\n+{\n+  reg_parms_t lparms;\n+  stack_frame_t *sp;\n+\n+  save_parms (lparms);\n+  sp = __builtin_frame_address (0);\n+  sp = sp->backchain;\n+\n+  /* _Decimal32 is passed in the lower half of an FPR, or in parameter slot.  */\n+  if (a1 != ((d32parm_t *)&lparms.fprs[0])->d) FAILURE\t\t/* f1  */\n+  if (a2 != ((d32parm_t *)&lparms.fprs[1])->d) FAILURE\t\t/* f2  */\n+  if (a3 != ((d32parm_t *)&lparms.fprs[2])->d) FAILURE\t\t/* f3  */\n+  if (a4 != ((d32parm_t *)&lparms.fprs[3])->d) FAILURE\t\t/* f4  */\n+  if (a5 != ((d32parm_t *)&lparms.fprs[4])->d) FAILURE\t\t/* f5  */\n+  if (a6 != ((d32parm_t *)&lparms.fprs[5])->d) FAILURE\t\t/* f6  */\n+  if (a7 != ((d32parm_t *)&lparms.fprs[6])->d) FAILURE\t\t/* f7  */\n+  if (a8 != ((d32parm_t *)&lparms.fprs[7])->d) FAILURE\t\t/* f8  */\n+  if (a9 != *(_Decimal32 *)&sp->slot[0]) FAILURE\n+  if (a10 != *(_Decimal32 *)&sp->slot[1]) FAILURE\n+  if (a11 != *(_Decimal32 *)&sp->slot[2]) FAILURE\n+  if (a12 != *(_Decimal32 *)&sp->slot[3]) FAILURE\n+  if (a13 != *(_Decimal32 *)&sp->slot[4]) FAILURE\n+  if (a14 != *(_Decimal32 *)&sp->slot[5]) FAILURE\n+  if (a15 != *(_Decimal32 *)&sp->slot[6]) FAILURE\n+  if (a16 != *(_Decimal32 *)&sp->slot[7]) FAILURE\n+}\n+\n+void __attribute__ ((noinline))\n+func5 (_Decimal32 a1, _Decimal64 a2, _Decimal128 a3,\n+       _Decimal32 a4, _Decimal64 a5, _Decimal128 a6,\n+       _Decimal32 a7, _Decimal64 a8, _Decimal128 a9,\n+       _Decimal32 a10, _Decimal64 a11, _Decimal128 a12)\n+{\n+  reg_parms_t lparms;\n+  stack_frame_t *sp;\n+\n+  save_parms (lparms);\n+  sp = __builtin_frame_address (0);\n+  sp = sp->backchain;\n+\n+  if (a1 != ((d32parm_t *)&lparms.fprs[0])->d) FAILURE\t\t/* f1      */\n+  if (a2 != *(_Decimal64 *)&lparms.fprs[1]) FAILURE\t\t/* f2      */\n+  if (a3 != *(_Decimal128 *)&lparms.fprs[3]) FAILURE\t\t/* f4 & f5 */\n+  if (a4 != ((d32parm_t *)&lparms.fprs[5])->d) FAILURE\t\t/* f6      */\n+  if (a5 != *(_Decimal64 *)&lparms.fprs[6]) FAILURE\t\t/* f7      */\n+\n+  if (a6 != *(_Decimal128 *)&sp->slot[0]) FAILURE\n+  if (a7 != *(_Decimal32 *)&sp->slot[4]) FAILURE\n+  if (a8 != *(_Decimal64 *)&sp->slot[6]) FAILURE\n+  if (a9 != *(_Decimal128 *)&sp->slot[8]) FAILURE\n+  if (a10 != *(_Decimal32 *)&sp->slot[12]) FAILURE\n+  if (a11 != *(_Decimal64 *)&sp->slot[14]) FAILURE\n+  if (a12 != *(_Decimal128 *)&sp->slot[16]) FAILURE\n+}\n+\n+int\n+main ()\n+{\n+  func0 (1., 2., 3., 4., 5., 6., 7., 8., 9.dd, 10.dl);\n+  func1 (1.dd, 2.dl, 3.dd, 4.dl, 5.dd, 6.dl, 7.dd, 8.dl);\n+  func2 (1.dl, 2.dd, 3.dl, 4.dd, 5.dl, 6.dd, 7.dl, 8.dd);\n+  func3 (1.dd, 2.dl, 3.dd, 4.dl, 5.dl);\n+#if 0\n+  /* _Decimal32 doesn't yet follow the ABI; enable this when it does.  */\n+  func4 (501.2df, 502.2df, 503.2df, 504.2df, 505.2df, 506.2df, 507.2df,\n+\t 508.2df, 509.2df, 510.2df, 511.2df, 512.2df, 513.2df, 514.2df,\n+\t 515.2df, 516.2df);\n+  func5 (601.2df, 602.2dd, 603.2dl, 604.2df, 605.2dd, 606.2dl,\n+\t 607.2df, 608.2dd, 609.2dl, 610.2df, 611.2dd, 612.2dl);\n+#endif\n+\n+  if (failcnt != 0)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "3badf7f984894ef0bc1add67d6fd701d5ff3def0", "filename": "gcc/testsuite/gcc.target/powerpc/ppc64-abi-dfp-1.c", "status": "added", "additions": 318, "deletions": 0, "changes": 318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d83f07035a5ca542ba42a858f39a94026b4f6ae/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc64-abi-dfp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d83f07035a5ca542ba42a858f39a94026b4f6ae/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc64-abi-dfp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc64-abi-dfp-1.c?ref=2d83f07035a5ca542ba42a858f39a94026b4f6ae", "patch": "@@ -0,0 +1,318 @@\n+/* { dg-do run { target { powerpc64-*-* && { lp64 && dfprt } } } } */\n+/* { dg-options \"-std=gnu99 -O2 -fno-strict-aliasing\" } */\n+\n+/* Testcase to check for ABI compliance of parameter passing\n+   for the PowerPC64 ELF ABI for decimal float values.  */\n+\n+extern void abort (void);\n+int failcnt = 0;\n+\n+/* Support compiling the test to report individual failures; default is\n+   to abort as soon as a check fails.  */\n+#ifdef DBG\n+#include <stdio.h>\n+#define FAILURE { printf (\"failed at line %d\\n\", __LINE__); failcnt++; }\n+#else\n+#define FAILURE abort ();\n+#endif\n+\n+typedef struct\n+{\n+  int pad;\n+  _Decimal32 d;\n+} d32parm_t;\n+\n+typedef struct\n+{\n+  unsigned long gprs[8];\n+  double fprs[13];\n+} reg_parms_t;\n+\n+reg_parms_t gparms;\n+\n+\n+/* Testcase could break on future gcc's, if parameter regs\n+   are changed before this asm.  */\n+\n+#ifndef __MACH__\n+#define save_parms(lparms)\t\t\t\t\\\n+    asm volatile (\"ld 11,gparms@got(2)\\n\\t\"                \\\n+                  \"std 3,0(11)\\n\\t\"\t\t        \\\n+\t          \"std 4,8(11)\\n\\t\"\t\t\t\\\n+\t          \"std 5,16(11)\\n\\t\"\t\t\t\\\n+\t          \"std 6,24(11)\\n\\t\"\t\t\t\\\n+\t          \"std 7,32(11)\\n\\t\"\t\t\t\\\n+\t          \"std 8,40(11)\\n\\t\"\t\t\t\\\n+\t          \"std 9,48(11)\\n\\t\"\t\t\t\\\n+\t          \"std 10,56(11)\\n\\t\"\t\t\t\\\n+                  \"stfd 1,64(11)\\n\\t\"\t\t\t\\\n+\t          \"stfd 2,72(11)\\n\\t\"\t\t\t\\\n+\t          \"stfd 3,80(11)\\n\\t\"\t\t\t\\\n+\t          \"stfd 4,88(11)\\n\\t\"\t\t\t\\\n+\t          \"stfd 5,96(11)\\n\\t\"\t\t\t\\\n+\t          \"stfd 6,104(11)\\n\\t\"\t\t\t\\\n+\t          \"stfd 7,112(11)\\n\\t\"\t\t\t\\\n+\t          \"stfd 8,120(11)\\n\\t\"\t\t\t\\\n+\t          \"stfd 9,128(11)\\n\\t\"\t\t\t\\\n+\t          \"stfd 10,136(11)\\n\\t\"\t\t\t\\\n+\t          \"stfd 11,144(11)\\n\\t\"\t\t\t\\\n+\t          \"stfd 12,152(11)\\n\\t\"                 \\\n+\t          \"stfd 13,160(11)\\n\\t\":::\"11\", \"memory\");  \\\n+                  lparms = gparms;\n+#else\n+#define save_parms(lparms)\t\t\t\t\\\n+    asm volatile (\"ld r11,gparms@got(r2)\\n\\t\"           \\\n+                  \"std r3,0(r11)\\n\\t\"\t\t        \\\n+\t          \"std r4,8(r11)\\n\\t\"\t\t\t\\\n+\t          \"std r5,16(r11)\\n\\t\"\t\t\t\\\n+\t          \"std r6,24(r11)\\n\\t\"\t\t\t\\\n+\t          \"std r7,32(r11)\\n\\t\"\t\t\t\\\n+\t          \"std r8,40(r11)\\n\\t\"\t\t\t\\\n+\t          \"std r9,48(r11)\\n\\t\"\t\t\t\\\n+\t          \"std r10,56(r11)\\n\\t\"                 \\\n+                  \"stfd f1,64(r11)\\n\\t\"\t\t        \\\n+\t          \"stfd f2,72(r11)\\n\\t\"\t\t\t\\\n+\t          \"stfd f3,80(r11)\\n\\t\"\t\t\t\\\n+\t          \"stfd f4,88(r11)\\n\\t\"\t\t\t\\\n+\t          \"stfd f5,96(r11)\\n\\t\"\t\t\t\\\n+\t          \"stfd f6,104(r11)\\n\\t\"\t\t\\\n+\t          \"stfd f7,112(r11)\\n\\t\"\t\t\\\n+\t          \"stfd f8,120(r11)\\n\\t\"\t\t\\\n+\t          \"stfd f9,128(r11)\\n\\t\"\t\t\\\n+\t          \"stfd f10,136(r11)\\n\\t\"\t\t\\\n+\t          \"stfd f11,144(r11)\\n\\t\"\t\t\\\n+\t          \"stfd f12,152(r11)\\n\\t\"               \\\n+\t          \"stfd f13,160(r11)\\n\\t\":::\"r11\", \"memory\");  \\\n+                  lparms = gparms;\n+#endif\n+\n+typedef struct sf\n+{\n+  struct sf *backchain;\n+  long a1;\n+  long a2;\n+  long a3;\n+  long a4;\n+  long a5;\n+  unsigned long slot[100];\n+} stack_frame_t;\n+\n+/* Fill up floating point registers with double arguments, forcing\n+   decimal float arguments into the parameter save area.  */\n+void __attribute__ ((noinline))\n+func0 (double a1, double a2, double a3, double a4, double a5, double a6,\n+       double a7, double a8, double a9, double a10, double a11, double a12,\n+       double a13, double a14, \n+       _Decimal64 a15, _Decimal128 a16, _Decimal64 a17)\n+{\n+  reg_parms_t lparms;\n+  stack_frame_t *sp;\n+\n+  save_parms (lparms);\n+  sp = __builtin_frame_address (0);\n+  sp = sp->backchain;\n+\n+  if (a1 != lparms.fprs[0]) FAILURE\n+  if (a2 != lparms.fprs[1]) FAILURE\n+  if (a3 != lparms.fprs[2]) FAILURE\n+  if (a4 != lparms.fprs[3]) FAILURE\n+  if (a5 != lparms.fprs[4]) FAILURE\n+  if (a6 != lparms.fprs[5]) FAILURE\n+  if (a7 != lparms.fprs[6]) FAILURE\n+  if (a8 != lparms.fprs[7]) FAILURE\n+  if (a9 != lparms.fprs[8]) FAILURE\n+  if (a10 != lparms.fprs[9]) FAILURE\n+  if (a11 != lparms.fprs[10]) FAILURE\n+  if (a12 != lparms.fprs[11]) FAILURE\n+  if (a13 != lparms.fprs[12]) FAILURE\n+  if (a14 != *(double *)&sp->slot[13]) FAILURE\n+  if (a15 != *(_Decimal64 *)&sp->slot[14]) FAILURE\n+  if (a16 != *(_Decimal128 *)&sp->slot[15]) FAILURE\n+  if (a17 != *(_Decimal64 *)&sp->slot[17]) FAILURE\n+}\n+\n+void __attribute__ ((noinline))\n+func1 (double a1, double a2, double a3, double a4, double a5, double a6,\n+       double a7, double a8, double a9, double a10, double a11, double a12,\n+       double a13, _Decimal128 a14)\n+{\n+  reg_parms_t lparms;\n+  stack_frame_t *sp;\n+\n+  save_parms (lparms);\n+  sp = __builtin_frame_address (0);\n+  sp = sp->backchain;\n+\n+  if (a1 != lparms.fprs[0]) FAILURE\n+  if (a2 != lparms.fprs[1]) FAILURE\n+  if (a3 != lparms.fprs[2]) FAILURE\n+  if (a4 != lparms.fprs[3]) FAILURE\n+  if (a5 != lparms.fprs[4]) FAILURE\n+  if (a6 != lparms.fprs[5]) FAILURE\n+  if (a7 != lparms.fprs[6]) FAILURE\n+  if (a8 != lparms.fprs[7]) FAILURE\n+  if (a9 != lparms.fprs[8]) FAILURE\n+  if (a10 != lparms.fprs[9]) FAILURE\n+  if (a11 != lparms.fprs[10]) FAILURE\n+  if (a12 != lparms.fprs[11]) FAILURE\n+  if (a13 != lparms.fprs[12]) FAILURE\n+  if (a14 != *(_Decimal128 *)&sp->slot[13]) FAILURE\n+}\n+\n+void __attribute__ ((noinline))\n+func2 (double a1, double a2, double a3, double a4, double a5, double a6,\n+       double a7, double a8, double a9, double a10, double a11, double a12,\n+       _Decimal128 a13)\n+{\n+  reg_parms_t lparms;\n+  stack_frame_t *sp;\n+\n+  save_parms (lparms);\n+  sp = __builtin_frame_address (0);\n+  sp = sp->backchain;\n+\n+  if (a1 != lparms.fprs[0]) FAILURE\n+  if (a2 != lparms.fprs[1]) FAILURE\n+  if (a3 != lparms.fprs[2]) FAILURE\n+  if (a4 != lparms.fprs[3]) FAILURE\n+  if (a5 != lparms.fprs[4]) FAILURE\n+  if (a6 != lparms.fprs[5]) FAILURE\n+  if (a7 != lparms.fprs[6]) FAILURE\n+  if (a8 != lparms.fprs[7]) FAILURE\n+  if (a9 != lparms.fprs[8]) FAILURE\n+  if (a10 != lparms.fprs[9]) FAILURE\n+  if (a11 != lparms.fprs[10]) FAILURE\n+  if (a12 != lparms.fprs[11]) FAILURE\n+  if (a13 != *(_Decimal128 *)&sp->slot[12]) FAILURE\n+}\n+\n+void __attribute__ ((noinline))\n+func3 (_Decimal64 a1, _Decimal128 a2, _Decimal64 a3, _Decimal128 a4,\n+       _Decimal64 a5, _Decimal128 a6, _Decimal64 a7, _Decimal128 a8,\n+       _Decimal64 a9, _Decimal128 a10)\n+{\n+  reg_parms_t lparms;\n+  stack_frame_t *sp;\n+\n+  save_parms (lparms);\n+  sp = __builtin_frame_address (0);\n+  sp = sp->backchain;\n+\n+  if (a1 != *(_Decimal64 *)&lparms.fprs[0]) FAILURE\t/* f1        */\n+  if (a2 != *(_Decimal128 *)&lparms.fprs[1]) FAILURE\t/* f2 & f3   */\n+  if (a3 != *(_Decimal64 *)&lparms.fprs[3]) FAILURE\t/* f4        */\n+  if (a4 != *(_Decimal128 *)&lparms.fprs[5]) FAILURE\t/* f6 & f7   */\n+  if (a5 != *(_Decimal64 *)&lparms.fprs[7]) FAILURE\t/* f8        */\n+  if (a6 != *(_Decimal128 *)&lparms.fprs[9]) FAILURE\t/* f10 & f11 */\n+  if (a7 != *(_Decimal64 *)&lparms.fprs[11]) FAILURE\t/* f12       */\n+  if (a8 != *(_Decimal128 *)&sp->slot[10]) FAILURE\n+  if (a9 != *(_Decimal64 *)&sp->slot[12]) FAILURE\n+  if (a10 != *(_Decimal128 *)&sp->slot[13]) FAILURE\n+}\n+\n+void __attribute__ ((noinline))\n+func4 (_Decimal128 a1, _Decimal64 a2, _Decimal128 a3, _Decimal64 a4,\n+       _Decimal128 a5, _Decimal64 a6, _Decimal128 a7, _Decimal64 a8)\n+{\n+  reg_parms_t lparms;\n+  stack_frame_t *sp;\n+\n+  save_parms (lparms);\n+  sp = __builtin_frame_address (0);\n+  sp = sp->backchain;\n+\n+  if (a1 != *(_Decimal128 *)&lparms.fprs[1]) FAILURE\t/* f2 & f3   */\n+  if (a2 != *(_Decimal64 *)&lparms.fprs[3]) FAILURE\t/* f4        */\n+  if (a3 != *(_Decimal128 *)&lparms.fprs[5]) FAILURE\t/* f6 & f7   */\n+  if (a4 != *(_Decimal64 *)&lparms.fprs[7]) FAILURE\t/* f8        */\n+  if (a5 != *(_Decimal128 *)&lparms.fprs[9]) FAILURE\t/* f10 & f11 */\n+  if (a6 != *(_Decimal64 *)&lparms.fprs[11]) FAILURE\t/* f12       */\n+  if (a7 != *(_Decimal128 *)&sp->slot[9]) FAILURE\n+  if (a8 != *(_Decimal64 *)&sp->slot[11]) FAILURE\n+}\n+\n+void __attribute__ ((noinline))\n+func5 (_Decimal32 a1, _Decimal32 a2, _Decimal32 a3, _Decimal32 a4,\n+       _Decimal32 a5, _Decimal32 a6, _Decimal32 a7, _Decimal32 a8,\n+       _Decimal32 a9, _Decimal32 a10, _Decimal32 a11, _Decimal32 a12,\n+       _Decimal32 a13, _Decimal32 a14, _Decimal32 a15, _Decimal32 a16)\n+{\n+  reg_parms_t lparms;\n+  stack_frame_t *sp;\n+\n+  save_parms (lparms);\n+  sp = __builtin_frame_address (0);\n+  sp = sp->backchain;\n+\n+  /* _Decimal32 is passed in the lower half of an FPR or parameter slot.  */\n+  if (a1 != ((d32parm_t *)&lparms.fprs[0])->d) FAILURE\t\t/* f1  */\n+  if (a2 != ((d32parm_t *)&lparms.fprs[1])->d) FAILURE\t\t/* f2  */\n+  if (a3 != ((d32parm_t *)&lparms.fprs[2])->d) FAILURE\t\t/* f3  */\n+  if (a4 != ((d32parm_t *)&lparms.fprs[3])->d) FAILURE\t\t/* f4  */\n+  if (a5 != ((d32parm_t *)&lparms.fprs[4])->d) FAILURE\t\t/* f5  */\n+  if (a6 != ((d32parm_t *)&lparms.fprs[5])->d) FAILURE\t\t/* f6  */\n+  if (a7 != ((d32parm_t *)&lparms.fprs[6])->d) FAILURE\t\t/* f7  */\n+  if (a8 != ((d32parm_t *)&lparms.fprs[7])->d) FAILURE\t\t/* f8  */\n+  if (a9 != ((d32parm_t *)&lparms.fprs[8])->d) FAILURE\t\t/* f9  */\n+  if (a10 != ((d32parm_t *)&lparms.fprs[9])->d) FAILURE\t\t/* f10 */\n+  if (a11 != ((d32parm_t *)&lparms.fprs[10])->d) FAILURE\t/* f11 */\n+  if (a12 != ((d32parm_t *)&lparms.fprs[11])->d) FAILURE\t/* f12 */\n+  if (a13 != ((d32parm_t *)&lparms.fprs[12])->d) FAILURE\t/* f13 */\n+  if (a14 != ((d32parm_t *)&sp->slot[13])->d) FAILURE\n+  if (a15 != ((d32parm_t *)&sp->slot[14])->d) FAILURE\n+  if (a16 != ((d32parm_t *)&sp->slot[15])->d) FAILURE\n+}\n+\n+void __attribute__ ((noinline))\n+func6 (_Decimal32 a1, _Decimal64 a2, _Decimal128 a3,\n+       _Decimal32 a4, _Decimal64 a5, _Decimal128 a6,\n+       _Decimal32 a7, _Decimal64 a8, _Decimal128 a9,\n+       _Decimal32 a10, _Decimal64 a11, _Decimal128 a12)\n+{\n+  reg_parms_t lparms;\n+  stack_frame_t *sp;\n+\n+  save_parms (lparms);\n+  sp = __builtin_frame_address (0);\n+  sp = sp->backchain;\n+\n+  if (a1 != ((d32parm_t *)&lparms.fprs[0])->d) FAILURE\t\t/* f1        */\n+  if (a2 != *(_Decimal64 *)&lparms.fprs[1]) FAILURE\t\t/* f2        */\n+  if (a3 != *(_Decimal128 *)&lparms.fprs[3]) FAILURE\t\t/* f4 & f5   */\n+  if (a4 != ((d32parm_t *)&lparms.fprs[5])->d) FAILURE\t\t/* f6        */\n+  if (a5 != *(_Decimal64 *)&lparms.fprs[6]) FAILURE\t\t/* f7        */\n+  if (a6 != *(_Decimal128 *)&lparms.fprs[7]) FAILURE\t\t/* f8 & f9   */\n+  if (a7 != ((d32parm_t *)&lparms.fprs[9])->d) FAILURE\t\t/* f10       */\n+  if (a8 != *(_Decimal64 *)&lparms.fprs[10]) FAILURE\t\t/* f11       */\n+  if (a9 != *(_Decimal128 *)&lparms.fprs[11]) FAILURE\t\t/* f12 & f13 */\n+  if (a10 != ((d32parm_t *)&sp->slot[12])->d) FAILURE\n+  if (a11 != *(_Decimal64 *)&sp->slot[13]) FAILURE\n+}\n+\n+int\n+main (void)\n+{\n+  func0 (1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5, 10.5, 11.5, 12.5, 13.5,\n+\t 14.5, 15.2dd, 16.2dl, 17.2dd);\n+  func1 (101.5, 102.5, 103.5, 104.5, 105.5, 106.5, 107.5, 108.5, 109.5,\n+\t 110.5, 111.5, 112.5, 113.5, 114.2dd);\n+  func2 (201.5, 202.5, 203.5, 204.5, 205.5, 206.5, 207.5, 208.5, 209.5,\n+\t 210.5, 211.5, 212.5, 213.2dd);\n+  func3 (301.2dd, 302.2dl, 303.2dd, 304.2dl, 305.2dd, 306.2dl, 307.2dd,\n+\t 308.2dl, 309.2dd, 310.2dl);\n+  func4 (401.2dl, 402.2dd, 403.2dl, 404.2dd, 405.2dl, 406.2dd, 407.2dl,\n+\t 408.2dd);\n+#if 0\n+  /* _Decimal32 doesn't yet follow the ABI; enable this when it does.  */\n+  func5 (501.2df, 502.2df, 503.2df, 504.2df, 505.2df, 506.2df, 507.2df,\n+\t 508.2df, 509.2df, 510.2df, 511.2df, 512.2df, 513.2df, 514.2df,\n+\t 515.2df, 516.2df);\n+  func6 (601.2df, 602.2dd, 603.2dl, 604.2df, 605.2dd, 606.2dl,\n+\t 607.2df, 608.2dd, 609.2dl, 610.2df, 611.2dd, 612.2dl);\n+#endif\n+\n+  if (failcnt != 0)\n+    abort ();\n+\n+  return 0;\n+}"}]}