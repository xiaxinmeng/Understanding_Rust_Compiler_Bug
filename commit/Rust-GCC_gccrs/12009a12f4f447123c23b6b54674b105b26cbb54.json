{"sha": "12009a12f4f447123c23b6b54674b105b26cbb54", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTIwMDlhMTJmNGY0NDcxMjNjMjNiNmI1NDY3NGIxMDViMjZjYmI1NA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-18T10:06:53Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-18T10:06:53Z"}, "message": "[multiple changes]\n\n2010-10-18  Tristan Gingold  <gingold@adacore.com>\n\n\t* init.c: Add __gnat_set_stack_guard_page and __gnat_set_stack_limit.\n\tImplement stack limitation on VMS.\n\tMinor reformatting.\n\n2010-10-18  Vincent Celier  <celier@adacore.com>\n\n\t* prj.adb (Is_Compilable): Do not modify Source.Compilable until the\n\tsource record has been initialized.\n\n2010-10-18  Robert Dewar  <dewar@adacore.com>\n\n\t* einfo.adb: Minor code reorganization (Primitive_Operations is a\n\tsynthesized attribute routine and was in the wrong place).\n\nFrom-SVN: r165620", "tree": {"sha": "15cf7ddbdb39be1740cdc9eea238f48ccc4c277e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/15cf7ddbdb39be1740cdc9eea238f48ccc4c277e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/12009a12f4f447123c23b6b54674b105b26cbb54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12009a12f4f447123c23b6b54674b105b26cbb54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12009a12f4f447123c23b6b54674b105b26cbb54", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12009a12f4f447123c23b6b54674b105b26cbb54/comments", "author": null, "committer": null, "parents": [{"sha": "e7efbe2f093468f9316e891136833aae0e404a24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7efbe2f093468f9316e891136833aae0e404a24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7efbe2f093468f9316e891136833aae0e404a24"}], "stats": {"total": 276, "additions": 211, "deletions": 65}, "files": [{"sha": "e94ba7ffa3812401c427f046bc82f7ac5eba89f8", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12009a12f4f447123c23b6b54674b105b26cbb54/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12009a12f4f447123c23b6b54674b105b26cbb54/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=12009a12f4f447123c23b6b54674b105b26cbb54", "patch": "@@ -1,3 +1,19 @@\n+2010-10-18  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* init.c: Add __gnat_set_stack_guard_page and __gnat_set_stack_limit.\n+\tImplement stack limitation on VMS.\n+\tMinor reformatting.\n+\n+2010-10-18  Vincent Celier  <celier@adacore.com>\n+\n+\t* prj.adb (Is_Compilable): Do not modify Source.Compilable until the\n+\tsource record has been initialized.\n+\n+2010-10-18  Robert Dewar  <dewar@adacore.com>\n+\n+\t* einfo.adb: Minor code reorganization (Primitive_Operations is a\n+\tsynthesized attribute routine and was in the wrong place).\n+\n 2010-10-18  Tristan Gingold  <gingold@adacore.com>\n \n \t* init.c: Indentation, and minor changes to more closely follow GNU"}, {"sha": "1ffdbbb17feb13950229362aa524a6953dfd0090", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12009a12f4f447123c23b6b54674b105b26cbb54/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12009a12f4f447123c23b6b54674b105b26cbb54/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=12009a12f4f447123c23b6b54674b105b26cbb54", "patch": "@@ -2359,20 +2359,6 @@ package body Einfo is\n       return Node8 (Id);\n    end Postcondition_Proc;\n \n-   function Primitive_Operations (Id : E) return L is\n-   begin\n-      if Is_Concurrent_Type (Id) then\n-         if Present (Corresponding_Record_Type (Id)) then\n-            return Direct_Primitive_Operations\n-                     (Corresponding_Record_Type (Id));\n-         else\n-            return No_Elist;\n-         end if;\n-      else\n-         return Direct_Primitive_Operations (Id);\n-      end if;\n-   end Primitive_Operations;\n-\n    function Prival (Id : E) return E is\n    begin\n       pragma Assert (Is_Protected_Component (Id));\n@@ -6599,6 +6585,24 @@ package body Einfo is\n       Set_First_Rep_Item (E, N);\n    end Record_Rep_Item;\n \n+   --------------------------\n+   -- Primitive_Operations --\n+   --------------------------\n+\n+   function Primitive_Operations (Id : E) return L is\n+   begin\n+      if Is_Concurrent_Type (Id) then\n+         if Present (Corresponding_Record_Type (Id)) then\n+            return Direct_Primitive_Operations\n+                     (Corresponding_Record_Type (Id));\n+         else\n+            return No_Elist;\n+         end if;\n+      else\n+         return Direct_Primitive_Operations (Id);\n+      end if;\n+   end Primitive_Operations;\n+\n    ---------------\n    -- Root_Type --\n    ---------------"}, {"sha": "d90a1ace197b9511c7e5c68eaeffaa1cc669f291", "filename": "gcc/ada/init.c", "status": "modified", "additions": 166, "deletions": 49, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12009a12f4f447123c23b6b54674b105b26cbb54/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12009a12f4f447123c23b6b54674b105b26cbb54/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=12009a12f4f447123c23b6b54674b105b26cbb54", "patch": "@@ -1050,11 +1050,9 @@ __gnat_install_handler (void)\n #elif defined (VMS)\n \n /* Routine called from binder to override default feature values. */\n-void __gnat_set_features ();\n+void __gnat_set_features (void);\n int __gnat_features_set = 0;\n \n-long __gnat_error_handler (int *, void *);\n-\n #ifdef __IA64\n #define lib_get_curr_invo_context LIB$I64_GET_CURR_INVO_CONTEXT\n #define lib_get_prev_invo_context LIB$I64_GET_PREV_INVO_CONTEXT\n@@ -1065,15 +1063,6 @@ long __gnat_error_handler (int *, void *);\n #define lib_get_invo_handle LIB$GET_INVO_HANDLE\n #endif\n \n-#if defined (IN_RTS) && !defined (__IA64)\n-\n-/* The prehandler actually gets control first on a condition.  It swaps the\n-   stack pointer and calls the handler (__gnat_error_handler).  */\n-extern long __gnat_error_prehandler (void);\n-\n-extern char *__gnat_error_prehandler_stack;   /* Alternate signal stack */\n-#endif\n-\n /* Define macro symbols for the VMS conditions that become Ada exceptions.\n    Most of these are also defined in the header file ssdef.h which has not\n    yet been converted to be recognized by GNU C.  */\n@@ -1105,7 +1094,10 @@ struct cond_except {\n   const struct Exception_Data *except;\n };\n \n-struct descriptor_s {unsigned short len, mbz; __char_ptr32 adr; };\n+struct descriptor_s {\n+  unsigned short len, mbz;\n+  __char_ptr32 adr;\n+};\n \n /* Conditions that don't have an Ada exception counterpart must raise\n    Non_Ada_Error.  Since this is defined in s-auxdec, it should only be\n@@ -1545,62 +1537,187 @@ __gnat_adjust_context_for_raise (int signo ATTRIBUTE_UNUSED, void *ucontext)\n \n #endif\n \n+/* Easier interface for LIB$GET_LOGICAL: put the equivalence of NAME into BUF,\n+   always NUL terminated.  In case of error or if the result is longer than\n+   LEN (length of BUF) an empty string is written info BUF.  */\n+\n+static void\n+__gnat_vms_get_logical (const char *name, char *buf, int len)\n+{\n+  struct descriptor_s name_desc, result_desc;\n+  int status;\n+  unsigned short rlen;\n+\n+  /* Build the descriptor for NAME.  */\n+  name_desc.len = strlen (name);\n+  name_desc.mbz = 0;\n+  name_desc.adr = (char *)name;\n+\n+  /* Build the descriptor for the result.  */\n+  result_desc.len = len;\n+  result_desc.mbz = 0;\n+  result_desc.adr = buf;\n+\n+  status = LIB$GET_LOGICAL (&name_desc, &result_desc, &rlen);\n+\n+  if ((status & 1) == 1 && rlen < len)\n+    buf[rlen] = 0;\n+  else\n+    buf[0] = 0;\n+}\n+\n+/* Size of a page on ia64 and alpha VMS.  */\n+#define VMS_PAGESIZE 8192\n+\n+/* User mode.  */\n+#define PSL__C_USER 3\n+\n+/* No access.  */\n+#define PRT__C_NA 0\n+\n+/* Descending region.  */\n+#define VA__M_DESCEND 1\n+\n+/* Get by virtual address.  */\n+#define VA___REGSUM_BY_VA 1\n+\n+/* Memory region summary.  */\n+struct regsum\n+{\n+  unsigned long long q_region_id;\n+  unsigned int l_flags;\n+  unsigned int l_region_protection;\n+  void *pq_start_va;\n+  unsigned long long q_region_size;\n+  void *pq_first_free_va;\n+};\n+\n+extern int SYS$GET_REGION_INFO (unsigned int, unsigned long long *,\n+                                void *, void *, unsigned int,\n+                                void *, unsigned int *);\n+extern int SYS$EXPREG_64 (unsigned long long *, unsigned long long,\n+                          unsigned int, unsigned int, void **,\n+                          unsigned long long *);\n+extern int SYS$SETPRT_64 (void *, unsigned long long, unsigned int,\n+                          unsigned int, void **, unsigned long long *,\n+                          unsigned int *);\n+extern int SYS$PUTMSG (void *, int (*)(), void *, unsigned long long);\n+\n+/* Add a guard page in the memory region containing ADDR at ADDR +/- SIZE.\n+   (The sign depends on the kind of the memory region).  */\n+\n+static int\n+__gnat_set_stack_guard_page (void *addr, unsigned long size)\n+{\n+  int status;\n+  void *ret_va;\n+  unsigned long long ret_len;\n+  unsigned int ret_prot;\n+  void *start_va;\n+  unsigned long long length;\n+  unsigned int retlen;\n+  struct regsum buffer;\n+\n+  /* Get the region for ADDR.  */\n+  status = SYS$GET_REGION_INFO\n+    (VA___REGSUM_BY_VA, NULL, addr, NULL, sizeof (buffer), &buffer, &retlen);\n+\n+  if ((status & 1) != 1)\n+    return -1;\n+\n+  /* Extend the region.  */\n+  status = SYS$EXPREG_64 (&buffer.q_region_id,\n+                          size, 0, 0, &start_va, &length);\n+\n+  if ((status & 1) != 1)\n+    return -1;\n+\n+  /* Create a guard page.  */\n+  if (!(buffer.l_flags & VA__M_DESCEND))\n+    start_va = (void *)((unsigned long long)start_va + length - VMS_PAGESIZE);\n+\n+  status = SYS$SETPRT_64 (start_va, VMS_PAGESIZE, PSL__C_USER, PRT__C_NA,\n+                          &ret_va, &ret_len, &ret_prot);\n+\n+  if ((status & 1) != 1)\n+    return -1;\n+  return 0;\n+}\n+\n+/* Read logicals to limit the stack(s) size.  */\n+\n+static void\n+__gnat_set_stack_limit (void)\n+{\n+#ifdef __ia64__\n+  void *sp;\n+  unsigned long size;\n+  char value[16];\n+  char *e;\n+\n+  /* The main stack.  */\n+  __gnat_vms_get_logical (\"GNAT_STACK_SIZE\", value, sizeof (value));\n+  size = strtoul (value, &e, 0);\n+  if (e > value && *e == 0)\n+    {\n+      asm (\"mov %0=sp\" : \"=r\" (sp));\n+      __gnat_set_stack_guard_page (sp, size * 1024);\n+    }\n+\n+  /* The register stack.  */\n+  __gnat_vms_get_logical (\"GNAT_RBS_SIZE\", value, sizeof (value));\n+  size = strtoul (value, &e, 0);\n+  if (e > value && *e == 0)\n+    {\n+      asm (\"mov %0=ar.bsp\" : \"=r\" (sp));\n+      __gnat_set_stack_guard_page (sp, size * 1024);\n+    }\n+#endif\n+}\n+\n /* Feature logical name and global variable address pair.\n    If we ever add another feature logical to this list, the\n    feature struct will need to be enhanced to take into account\n    possible values for *gl_addr.  */\n struct feature {\n-  char *name;\n+  const char *name;\n   int *gl_addr;\n };\n \n-/* Default values for GNAT features set by environment. */\n+/* Default values for GNAT features set by environment.  */\n int __gl_heap_size = 64;\n \n-/* Array feature logical names and global variable addresses */\n-static struct feature features[] = {\n+/* Array feature logical names and global variable addresses.  */\n+static const struct feature features[] = {\n   {\"GNAT$NO_MALLOC_64\", &__gl_heap_size},\n   {0, 0}\n };\n \n-void __gnat_set_features (void)\n+void\n+__gnat_set_features (void)\n {\n-  struct descriptor_s name_desc, result_desc;\n-  int i, status;\n-  unsigned short rlen;\n-\n-#define MAXEQUIV 10\n-  char buff[MAXEQUIV];\n+  int i;\n+  char buff[16];\n \n-  /* Loop through features array and test name for enable/disable */\n+  /* Loop through features array and test name for enable/disable.  */\n   for (i = 0; features[i].name; i++)\n     {\n-       name_desc.len = strlen (features[i].name);\n-       name_desc.mbz = 0;\n-       name_desc.adr = features[i].name;\n-\n-       result_desc.len = MAXEQUIV - 1;\n-       result_desc.mbz = 0;\n-       result_desc.adr = buff;\n-\n-       status = LIB$GET_LOGICAL (&name_desc, &result_desc, &rlen);\n-\n-       if (((status & 1) == 1) && (rlen < MAXEQUIV))\n-         buff[rlen] = 0;\n-       else\n-         strcpy (buff, \"\");\n-\n-       if ((strcmp (buff, \"ENABLE\") == 0) ||\n-           (strcmp (buff, \"TRUE\") == 0) ||\n-           (strcmp (buff, \"1\") == 0))\n-          *features[i].gl_addr = 32;\n-       else if ((strcmp (buff, \"DISABLE\") == 0) ||\n-                (strcmp (buff, \"FALSE\") == 0) ||\n-                (strcmp (buff, \"0\") == 0))\n-          *features[i].gl_addr = 64;\n+      __gnat_vms_get_logical (features[i].name, buff, sizeof (buff));\n+\n+      if (strcmp (buff, \"ENABLE\") == 0\n+          || strcmp (buff, \"TRUE\") == 0\n+          || strcmp (buff, \"1\") == 0)\n+        *features[i].gl_addr = 32;\n+      else if (strcmp (buff, \"DISABLE\") == 0\n+               || strcmp (buff, \"FALSE\") == 0\n+               || strcmp (buff, \"0\") == 0)\n+        *features[i].gl_addr = 64;\n     }\n \n-    __gnat_features_set = 1;\n+  /* Features to artificially limit the stack size.  */\n+  __gnat_set_stack_limit ();\n+\n+  __gnat_features_set = 1;\n }\n \n /*******************/"}, {"sha": "99886c13c0f2ae313e451bbd3479ffb99f57e08b", "filename": "gcc/ada/prj.adb", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12009a12f4f447123c23b6b54674b105b26cbb54/gcc%2Fada%2Fprj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12009a12f4f447123c23b6b54674b105b26cbb54/gcc%2Fada%2Fprj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.adb?ref=12009a12f4f447123c23b6b54674b105b26cbb54", "patch": "@@ -1164,10 +1164,19 @@ package body Prj is\n                         or else\n                           Source.Kind /= Spec)\n             then\n-               Source.Compilable := Yes;\n+               --  Do not modify Source.Compilable before the source record\n+               --  has been initilaized.\n+\n+               if Source.Source_TS /= Empty_Time_Stamp then\n+                  Source.Compilable := Yes;\n+               end if;\n+\n                return True;\n             else\n-               Source.Compilable := No;\n+               if Source.Source_TS /= Empty_Time_Stamp then\n+                  Source.Compilable := No;\n+               end if;\n+\n                return False;\n             end if;\n "}]}