{"sha": "464b453d445ffae5eff76787fdf4155bcef697a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDY0YjQ1M2Q0NDVmZmFlNWVmZjc2Nzg3ZmRmNDE1NWJjZWY2OTdhMg==", "commit": {"author": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-08-26T22:19:37Z"}, "committer": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-08-26T22:19:37Z"}, "message": "Enhance to fill the last delay slot of a call with an unconditional jump.\n\nEnhance to fill the last delay slot of a call with an\n\tunconditional jump.\n\t(fill_simple_delay_slots): Look for the case of a call/branch\n\tfirst.  If this applies, record the jump as `last_delay_insn'.\n\tLater, don't look for additional delay insns if the last one has\n\talreay been filled.\n\t(mark_target_live_regs): A sequence may end in an unconditional\n\tbranch.\n\nFrom-SVN: r1969", "tree": {"sha": "2b55089ff3700f9ca5cc1f1248c124eb90c7cb8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b55089ff3700f9ca5cc1f1248c124eb90c7cb8e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/464b453d445ffae5eff76787fdf4155bcef697a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/464b453d445ffae5eff76787fdf4155bcef697a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/464b453d445ffae5eff76787fdf4155bcef697a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/464b453d445ffae5eff76787fdf4155bcef697a2/comments", "author": null, "committer": null, "parents": [{"sha": "4d032a67aaa632dde65c7b1d868309bd51ba9952", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d032a67aaa632dde65c7b1d868309bd51ba9952", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d032a67aaa632dde65c7b1d868309bd51ba9952"}], "stats": {"total": 174, "additions": 107, "deletions": 67}, "files": [{"sha": "e9802a919694fdf78b8d8ad3715ee36b651d48af", "filename": "gcc/reorg.c", "status": "modified", "additions": 107, "deletions": 67, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/464b453d445ffae5eff76787fdf4155bcef697a2/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/464b453d445ffae5eff76787fdf4155bcef697a2/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=464b453d445ffae5eff76787fdf4155bcef697a2", "patch": "@@ -1926,6 +1926,7 @@ mark_target_live_regs (target, res)\n   struct target_info *tinfo;\n   rtx insn, next;\n   rtx jump_insn = 0;\n+  rtx jump_target;\n   HARD_REG_SET scratch;\n   struct resources set, needed;\n   int jump_count = 0;\n@@ -2148,7 +2149,7 @@ mark_target_live_regs (target, res)\n \n   for (insn = target; insn; insn = next)\n     {\n-      rtx main_insn = insn;\n+      rtx this_jump_insn = insn;\n \n       next = NEXT_INSN (insn);\n       switch (GET_CODE (insn))\n@@ -2168,18 +2169,30 @@ mark_target_live_regs (target, res)\n \t      || GET_CODE (PATTERN (insn)) == CLOBBER)\n \t    continue;\n \t  if (GET_CODE (PATTERN (insn)) == SEQUENCE)\n-\t    main_insn = XVECEXP (PATTERN (insn), 0, 0);\n+\t    {\n+\t      /* An unconditional jump can be used to fill the delay slot\n+\t\t of a call, so search for a JUMP_INSN in any position.  */\n+\t      for (i = 0; i < XVECLEN (PATTERN (insn), 0); i++)\n+\t\t{\n+\t\t  this_jump_insn = XVECEXP (PATTERN (insn), 0, i);\n+\t\t  if (GET_CODE (this_jump_insn) == JUMP_INSN)\n+\t\t    break;\n+\t\t}\n+\t    }\n \t}\n \n-      if (GET_CODE (main_insn) == JUMP_INSN)\n+      if (GET_CODE (this_jump_insn) == JUMP_INSN)\n \t{\n \t  if (jump_count++ < 10\n-\t      && (simplejump_p (main_insn)\n-\t\t  || GET_CODE (PATTERN (main_insn)) == RETURN))\n+\t      && (simplejump_p (this_jump_insn)\n+\t\t  || GET_CODE (PATTERN (this_jump_insn)) == RETURN))\n \t    {\n-\t      next = next_active_insn (JUMP_LABEL (main_insn));\n+\t      next = next_active_insn (JUMP_LABEL (this_jump_insn));\n \t      if (jump_insn == 0)\n-\t\tjump_insn = insn;\n+\t\t{\n+\t\t  jump_insn = insn;\n+\t\t  jump_target = JUMP_LABEL (this_jump_insn);\n+\t\t}\n \t    }\n \t  else\n \t    break;\n@@ -2203,9 +2216,6 @@ mark_target_live_regs (target, res)\n \n   if (jump_insn && jump_count < 10)\n     {\n-      rtx jump_target = (GET_CODE (jump_insn) == INSN\n-\t\t\t ? JUMP_LABEL (XVECEXP (PATTERN (jump_insn), 0, 0))\n-\t\t\t : JUMP_LABEL (jump_insn));\n       struct resources new_resources;\n       rtx stop_insn = next_active_insn (jump_insn);\n \n@@ -2250,7 +2260,7 @@ fill_simple_delay_slots (first, non_jumps_p)\n      rtx first;\n {\n   register rtx insn, pat, trial, next_trial;\n-  register int i;\n+  register int i, j;\n   int num_unfilled_slots = unfilled_slots_next - unfilled_slots_base;\n   struct resources needed, set;\n   register int slots_to_fill, slots_filled;\n@@ -2275,10 +2285,48 @@ fill_simple_delay_slots (first, non_jumps_p)\n \tabort ();\n \n       /* This insn needs, or can use, some delay slots.  SLOTS_TO_FILL\n-\t says how many.  After initialization, scan backwards from the\n-\t insn to search for a potential delay-slot candidate.  Stop\n-\t searching when a label or jump is hit.\n-\t \n+\t says how many.  After initialization, first try optimizing\n+\n+\t call _foo\t\tcall _foo\n+\t nop\t\t\tadd %o7,.-L1,%o7\n+\t b,a L1\n+\t nop\n+\n+\t If this case applies, the delay slot of the call is filled with\n+\t the unconditional jump.  This is done first to avoid having the\n+\t delay slot of the call filled in the backward scan.  Also, since\n+\t the unconditional jump is likely to also have a delay slot, that\n+\t insn must exist when it is subsequently scanned.  */\n+\n+      slots_filled = 0;\n+      delay_list = 0;\n+\n+      if (GET_CODE (insn) == CALL_INSN\n+\t  && (trial = next_active_insn (insn))\n+\t  && GET_CODE (trial) == JUMP_INSN\n+\t  && simplejump_p (trial)\n+\t  && eligible_for_delay (insn, slots_filled, trial)\n+\t  && no_labels_between_p (insn, trial))\n+\t{\n+\t  slots_filled++;\n+\t  delay_list = add_to_delay_list (trial, delay_list);\n+\t  /* Remove the unconditional jump from consideration for delay slot\n+\t     filling and unthread it.  */\n+\t  if (unfilled_slots_base[i + 1] == trial)\n+\t    unfilled_slots_base[i + 1] = 0;\n+\t  {\n+\t    rtx next = NEXT_INSN (trial);\n+\t    rtx prev = PREV_INSN (trial);\n+\t    if (prev)\n+\t      NEXT_INSN (prev) = next;\n+\t    if (next)\n+\t      PREV_INSN (next) = prev;\n+\t  }\n+\t}\n+\n+      /* Now, scan backwards from the insn to search for a potential\n+\t delay-slot candidate.  Stop searching when a label or jump is hit.\n+\n \t For each candidate, if it is to go into the delay slot (moved\n \t forward in execution sequence), it must not need or set any resources\n \t that were set by later insns and must not set any resources that\n@@ -2288,58 +2336,59 @@ fill_simple_delay_slots (first, non_jumps_p)\n \t (in which case the called routine, not the insn itself, is doing\n \t the setting).  */\n \n-      slots_filled = 0;\n-      delay_list = 0;\n-      CLEAR_RESOURCE (&needed);\n-      CLEAR_RESOURCE (&set);\n-      mark_set_resources (insn, &set, 0, 0);\n-      mark_referenced_resources (insn, &needed, 0);\n-\n-      for (trial = prev_nonnote_insn (insn); ! stop_search_p (trial, 1);\n-\t   trial = next_trial)\n+      if (slots_filled < slots_to_fill)\n \t{\n-\t  next_trial = prev_nonnote_insn (trial);\n+\t  CLEAR_RESOURCE (&needed);\n+\t  CLEAR_RESOURCE (&set);\n+\t  mark_set_resources (insn, &set, 0, 0);\n+\t  mark_referenced_resources (insn, &needed, 0);\n \n-\t  /* This must be an INSN or CALL_INSN.  */\n-\t  pat = PATTERN (trial);\n+\t  for (trial = prev_nonnote_insn (insn); ! stop_search_p (trial, 1);\n+\t       trial = next_trial)\n+\t    {\n+\t      next_trial = prev_nonnote_insn (trial);\n \n-\t  /* USE and CLOBBER at this level was just for flow; ignore it.  */\n-\t  if (GET_CODE (pat) == USE || GET_CODE (pat) == CLOBBER)\n-\t    continue;\n+\t      /* This must be an INSN or CALL_INSN.  */\n+\t      pat = PATTERN (trial);\n+\n+\t      /* USE and CLOBBER at this level was just for flow; ignore it.  */\n+\t      if (GET_CODE (pat) == USE || GET_CODE (pat) == CLOBBER)\n+\t\tcontinue;\n \n-\t  /* Check for resource conflict first, to avoid unnecessary \n-\t     splitting.  */\n-\t  if (! insn_references_resource_p (trial, &set, 1)\n-\t      && ! insn_sets_resource_p (trial, &set, 1)\n-\t      && ! insn_sets_resource_p (trial, &needed, 1)\n+\t      /* Check for resource conflict first, to avoid unnecessary \n+\t\t splitting.  */\n+\t      if (! insn_references_resource_p (trial, &set, 1)\n+\t\t  && ! insn_sets_resource_p (trial, &set, 1)\n+\t\t  && ! insn_sets_resource_p (trial, &needed, 1)\n #ifdef HAVE_cc0\n-\t      /* Can't separate set of cc0 from its use.  */\n-\t      && ! (reg_mentioned_p (cc0_rtx, pat)\n-\t\t    && ! sets_cc0_p (cc0_rtx, pat))\n+\t\t  /* Can't separate set of cc0 from its use.  */\n+\t\t  && ! (reg_mentioned_p (cc0_rtx, pat)\n+\t\t\t&& ! sets_cc0_p (cc0_rtx, pat))\n #endif\n-\t      )\n-\t    {\n-\t      trial = try_split (pat, trial, 1);\n-\t      next_trial = prev_nonnote_insn (trial);\n-\t      if (eligible_for_delay (insn, slots_filled, trial))\n+\t\t  )\n \t\t{\n-\t\t  /* In this case, we are searching backward, so if we\n-\t\t     find insns to put on the delay list, we want\n-\t\t     to put them at the head, rather than the\n-\t\t     tail, of the list.  */\n-\n-\t\t  delay_list = gen_rtx (INSN_LIST, VOIDmode,\n-\t\t\t\t\ttrial, delay_list);\n-\t\t  update_block (trial, trial);\n-\t\t  delete_insn (trial);\n-\t\t  if (slots_to_fill == ++slots_filled)\n-\t\t    break;\n-\t\t  continue;\n+\t\t  trial = try_split (pat, trial, 1);\n+\t\t  next_trial = prev_nonnote_insn (trial);\n+\t\t  if (eligible_for_delay (insn, slots_filled, trial))\n+\t\t    {\n+\t\t      /* In this case, we are searching backward, so if we\n+\t\t\t find insns to put on the delay list, we want\n+\t\t\t to put them at the head, rather than the\n+\t\t\t tail, of the list.  */\n+\n+\t\t      delay_list = gen_rtx (INSN_LIST, VOIDmode,\n+\t\t\t\t\t    trial, delay_list);\n+\t\t      update_block (trial, trial);\n+\t\t      delete_insn (trial);\n+\t\t      if (slots_to_fill == ++slots_filled)\n+\t\t\tbreak;\n+\t\t      continue;\n+\t\t    }\n \t\t}\n-\t    }\n \n-\t  mark_set_resources (trial, &set, 0, 1);\n-\t  mark_referenced_resources (trial, &needed, 1);\n+\t      mark_set_resources (trial, &set, 0, 1);\n+\t      mark_referenced_resources (trial, &needed, 1);\n+\t    }\n \t}\n \n       /* If all needed slots haven't been filled, we come here.  */\n@@ -2356,15 +2405,6 @@ fill_simple_delay_slots (first, non_jumps_p)\n \t}\n #endif\n \n-      /* @@ This would be a good place to optimize:\n-\n-\t call _foo\t\tcall _foo\n-\t nop\t\t\tadd %o7,.-L1,%o7\n-\t b,a L1\n-\t nop\n-\n-\t Someday... */\n-\n       /* Try to get insns from beyond the insn needing the delay slot.\n \t These insns can neither set or reference resources set in insns being\n \t skipped, cannot set resources in the insn being skipped, and, if this"}]}